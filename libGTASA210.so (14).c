)m_pHead->m_pVoid + 16))(m_pHead->m_pVoid);
        if ( (unsigned __int8)((*((_BYTE *)v2.m_pVoid + 58) & 7) - 2) <= 2u )
          CPhysical::RemoveFromMovingList((CPhysical *)v2.m_pVoid);
        if ( m_pHead->m_pVoid )
          (*(void (__fastcall **)(void *))(*(_DWORD *)m_pHead->m_pVoid + 4))(m_pHead->m_pVoid);
        m_pHead = v2.m_pNext;
      }
      while ( v2.m_pNext );
    }
    m_pNext = CWorld::ms_aRepeatSectors[i].m_ptrListArray[0].m_pHead;
    if ( m_pNext )
    {
      do
      {
        v4 = *m_pNext;
        (*(void (__fastcall **)(void *))(*(_DWORD *)m_pNext->m_pVoid + 16))(m_pNext->m_pVoid);
        if ( (unsigned __int8)((*((_BYTE *)v4.m_pVoid + 58) & 7) - 2) <= 2u )
          CPhysical::RemoveFromMovingList((CPhysical *)v4.m_pVoid);
        if ( m_pNext->m_pVoid )
          (*(void (__fastcall **)(void *))(*(_DWORD *)m_pNext->m_pVoid + 4))(m_pNext->m_pVoid);
        m_pNext = v4.m_pNext;
      }
      while ( v4.m_pNext );
    }
  }
  CPickups::ReInit();
  sub_19E698();
}

//----- (00423418) --------------------------------------------------------
void __fastcall CWorld::Add(CEntity *pEntity)
{
  RwObject_0 *m_pRwObject; // r0
  char *parent; // r1
  CMatrix *m_pMat; // r0
  RwMatrix *v5; // r1

  m_pRwObject = pEntity->m_pRwObject;
  if ( m_pRwObject )
  {
    parent = (char *)m_pRwObject->parent;
    m_pMat = pEntity->m_pMat;
    v5 = (RwMatrix *)(parent + 16);
    if ( m_pMat )
      CMatrix::UpdateRwMatrix(m_pMat, v5);
    else
      CSimpleTransform::UpdateRwMatrix(&pEntity->m_transform, v5);
  }
  CEntity::UpdateRwFrame(pEntity);
  (*((void (__fastcall **)(CEntity *))pEntity->_vptr$CPlaceable + 2))(pEntity);
  if ( (*(_BYTE *)&pEntity->m_info & 3 | 4) != 5 && (*(_DWORD *)&pEntity->m_nFlags & 0x40004) == 0 )
    sub_18BF70((CPhysical *)pEntity);
}

//----- (00423468) --------------------------------------------------------
bool __fastcall CWorld::GetIsLineOfSightClear(
        const CVector *vecStart,
        const CVector *vecEnd,
        int bCheckBuildings,
        int bCheckVehicles,
        int bCheckPeds,
        int bCheckObjects,
        int bCheckDummies,
        bool bSeeThroughStuff,
        bool bIgnoreSomeObjectsForCamera)
{
  uint16 v9; // r0
  float x; // s24
  float y; // s22
  float v12; // r4
  float v13; // r6
  float v14; // s26
  float v15; // s20
  float v16; // r5
  int v17; // r0
  int v18; // r1
  int v19; // r6
  int v20; // r11
  bool v21; // zf
  int v22; // r1
  int v23; // r0
  int v24; // r8
  int v25; // r4
  int v26; // r5
  int v27; // r9
  int v28; // r11
  char v29; // r5
  int v30; // r0
  int v31; // r10
  int v32; // r4
  bool v33; // cc
  int v34; // r0
  int v35; // r5
  int v36; // r9
  int v37; // r0
  int v38; // r4
  int v39; // r10
  int v40; // r0
  int v41; // r10
  int v42; // r8
  float v43; // s20
  float v44; // s0
  int v45; // r8
  int v46; // s0
  char v47; // r5
  int v48; // r0
  int v49; // r10
  int v50; // r4
  int v51; // r2
  int v52; // r0
  int v53; // r4
  int v54; // r10
  float v55; // s0
  int v56; // r8
  int v57; // s0
  char v58; // r5
  int v59; // r0
  int v60; // r10
  int v61; // r4
  int v62; // r2
  int v63; // r0
  int v64; // r10
  int v65; // r9
  int v66; // r1
  int v67; // r0
  int v68; // r1
  int v69; // r5
  float v70; // r0
  int v71; // r9
  char v72; // r4
  int v73; // s0
  int v74; // r0
  int v75; // r8
  int v76; // r6
  int v77; // r0
  int v78; // r8
  int v79; // r6
  int v80; // r5
  int v81; // r9
  char v82; // r6
  int v83; // r4
  int v84; // r0
  int v85; // r10
  int v86; // r4
  int v87; // r11
  int v88; // r0
  int v89; // r10
  int v90; // r9
  int v91; // r1
  int v92; // r0
  int v93; // r1
  int v94; // r5
  float v95; // r0
  int v96; // r9
  char v97; // r4
  int v98; // s0
  int v99; // r0
  int v100; // r8
  int v101; // r6
  int v102; // r0
  int v103; // r8
  int v104; // r6
  int v105; // r5
  int v106; // r9
  char v107; // r6
  int v108; // r4
  int v109; // r0
  int v110; // r10
  int v111; // r4
  int v112; // r11
  int v113; // r4
  int v114; // r0
  int v115; // r11
  int v116; // r4
  int v117; // r10
  int v118; // r4
  int v119; // r0
  int v120; // r11
  int v121; // r4
  int v122; // r10
  int v124; // [sp+28h] [bp-90h]
  int v125; // [sp+28h] [bp-90h]
  int v126; // [sp+28h] [bp-90h]
  int v127; // [sp+28h] [bp-90h]
  int v128; // [sp+30h] [bp-88h]
  int v129; // [sp+34h] [bp-84h]
  CColLine line; // [sp+48h] [bp-70h] BYREF

  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v9 = 1;
  }
  else
  {
    v9 = CWorld::ms_nCurrentScanCode + 1;
  }
  CWorld::ms_nCurrentScanCode = v9;
  x = vecStart->x;
  y = vecStart->y;
  v12 = floorf((float)(vecStart->x / 50.0) + 60.0);
  v13 = floorf((float)(y / 50.0) + 60.0);
  v14 = vecEnd->x;
  v15 = vecEnd->y;
  v16 = floorf((float)(vecEnd->x / 50.0) + 60.0);
  v17 = (int)floorf((float)(v15 / 50.0) + 60.0);
  v18 = (int)v16;
  v19 = (int)v13;
  v20 = (int)v12;
  v21 = SLODWORD(v12) == SLODWORD(v16);
  if ( SLODWORD(v12) == SLODWORD(v16) )
    v21 = v19 == v17;
  if ( !v21 )
  {
    v129 = v17;
    if ( v20 == v18 )
    {
      v27 = 0;
      if ( v20 > 0 )
        v27 = (int)v12;
      v28 = (int)v12 & 0xF;
      if ( v27 >= 119 )
        v27 = 119;
      v29 = 16 * v19;
      if ( v19 >= v17 )
      {
        while ( 1 )
        {
          CColLine::CColLine(&line, vecStart, vecEnd);
          v40 = 0;
          if ( v19 > 0 )
            v40 = v19;
          if ( v40 >= 119 )
            v40 = 119;
          v41 = v27 + 120 * v40;
          if ( bCheckBuildings == 1
            && !CWorld::GetIsLineOfSightSectorListClear(
                  &CWorld::ms_aSectors[v41].m_buildingPtrListArray,
                  &line,
                  bSeeThroughStuff,
                  0) )
          {
            break;
          }
          v42 = v29 & 0xF0 | v28;
          if ( bCheckVehicles == 1
            && !CWorld::GetIsLineOfSightSectorListClear(
                  (CPtrList *)&CWorld::ms_aRepeatSectors[v42],
                  &line,
                  bSeeThroughStuff,
                  0) )
          {
            break;
          }
          if ( bCheckPeds == 1
            && !CWorld::GetIsLineOfSightSectorListClear(
                  &CWorld::ms_aRepeatSectors[v42].m_ptrListArray[1],
                  &line,
                  bSeeThroughStuff,
                  0)
            || bCheckObjects == 1
            && !CWorld::GetIsLineOfSightSectorListClear(
                  &CWorld::ms_aRepeatSectors[v42].m_ptrListArray[2],
                  &line,
                  bSeeThroughStuff,
                  bIgnoreSomeObjectsForCamera)
            || bCheckDummies == 1
            && !CWorld::GetIsLineOfSightSectorListClear(
                  &CWorld::ms_aSectors[v41].m_dummyPtrListArray,
                  &line,
                  bSeeThroughStuff,
                  0) )
          {
            break;
          }
          v29 -= 16;
          v33 = v19-- <= v129;
          if ( v33 )
            return 1;
        }
      }
      else
      {
        while ( 1 )
        {
          CColLine::CColLine(&line, vecStart, vecEnd);
          v30 = 0;
          if ( v19 > 0 )
            v30 = v19;
          if ( v30 >= 119 )
            v30 = 119;
          v31 = v27 + 120 * v30;
          if ( bCheckBuildings == 1
            && !CWorld::GetIsLineOfSightSectorListClear(
                  &CWorld::ms_aSectors[v31].m_buildingPtrListArray,
                  &line,
                  bSeeThroughStuff,
                  0) )
          {
            break;
          }
          v32 = v29 & 0xF0 | v28;
          if ( bCheckVehicles == 1
            && !CWorld::GetIsLineOfSightSectorListClear(
                  (CPtrList *)&CWorld::ms_aRepeatSectors[v32],
                  &line,
                  bSeeThroughStuff,
                  0) )
          {
            break;
          }
          if ( bCheckPeds == 1
            && !CWorld::GetIsLineOfSightSectorListClear(
                  &CWorld::ms_aRepeatSectors[v32].m_ptrListArray[1],
                  &line,
                  bSeeThroughStuff,
                  0)
            || bCheckObjects == 1
            && !CWorld::GetIsLineOfSightSectorListClear(
                  &CWorld::ms_aRepeatSectors[v32].m_ptrListArray[2],
                  &line,
                  bSeeThroughStuff,
                  bIgnoreSomeObjectsForCamera)
            || bCheckDummies == 1
            && !CWorld::GetIsLineOfSightSectorListClear(
                  &CWorld::ms_aSectors[v31].m_dummyPtrListArray,
                  &line,
                  bSeeThroughStuff,
                  0) )
          {
            break;
          }
          v29 += 16;
          v33 = v19++ < v129;
          if ( !v33 )
            return 1;
        }
      }
    }
    else
    {
      v128 = (int)v16;
      if ( v19 == v17 )
      {
        v34 = 0;
        if ( v19 > 0 )
          v34 = v19;
        if ( v34 >= 119 )
          v34 = 119;
        v35 = 120 * v34;
        v36 = (unsigned __int8)(16 * v19);
        if ( v20 >= v18 )
        {
          while ( 1 )
          {
            CColLine::CColLine(&line, vecStart, vecEnd);
            v52 = 0;
            if ( v20 > 0 )
              v52 = v20;
            if ( v52 >= 119 )
              v52 = 119;
            v53 = v52 + v35;
            if ( bCheckBuildings == 1
              && !CWorld::GetIsLineOfSightSectorListClear(
                    &CWorld::ms_aSectors[v53].m_buildingPtrListArray,
                    &line,
                    bSeeThroughStuff,
                    0) )
            {
              break;
            }
            v54 = v20 & 0xF | v36;
            if ( bCheckVehicles == 1
              && !CWorld::GetIsLineOfSightSectorListClear(
                    (CPtrList *)&CWorld::ms_aRepeatSectors[v54],
                    &line,
                    bSeeThroughStuff,
                    0) )
            {
              break;
            }
            if ( bCheckPeds == 1
              && !CWorld::GetIsLineOfSightSectorListClear(
                    &CWorld::ms_aRepeatSectors[v54].m_ptrListArray[1],
                    &line,
                    bSeeThroughStuff,
                    0)
              || bCheckObjects == 1
              && !CWorld::GetIsLineOfSightSectorListClear(
                    &CWorld::ms_aRepeatSectors[v54].m_ptrListArray[2],
                    &line,
                    bSeeThroughStuff,
                    bIgnoreSomeObjectsForCamera)
              || bCheckDummies == 1
              && !CWorld::GetIsLineOfSightSectorListClear(
                    &CWorld::ms_aSectors[v53].m_dummyPtrListArray,
                    &line,
                    bSeeThroughStuff,
                    0) )
            {
              break;
            }
            v25 = 1;
            v33 = v20-- <= v128;
            if ( v33 )
              return v25;
          }
        }
        else
        {
          while ( 1 )
          {
            CColLine::CColLine(&line, vecStart, vecEnd);
            v37 = 0;
            if ( v20 > 0 )
              v37 = v20;
            if ( v37 >= 119 )
              v37 = 119;
            v38 = v37 + v35;
            if ( bCheckBuildings == 1
              && !CWorld::GetIsLineOfSightSectorListClear(
                    &CWorld::ms_aSectors[v38].m_buildingPtrListArray,
                    &line,
                    bSeeThroughStuff,
                    0) )
            {
              break;
            }
            v39 = v20 & 0xF | v36;
            if ( bCheckVehicles == 1
              && !CWorld::GetIsLineOfSightSectorListClear(
                    (CPtrList *)&CWorld::ms_aRepeatSectors[v39],
                    &line,
                    bSeeThroughStuff,
                    0) )
            {
              break;
            }
            if ( bCheckPeds == 1
              && !CWorld::GetIsLineOfSightSectorListClear(
                    &CWorld::ms_aRepeatSectors[v39].m_ptrListArray[1],
                    &line,
                    bSeeThroughStuff,
                    0)
              || bCheckObjects == 1
              && !CWorld::GetIsLineOfSightSectorListClear(
                    &CWorld::ms_aRepeatSectors[v39].m_ptrListArray[2],
                    &line,
                    bSeeThroughStuff,
                    bIgnoreSomeObjectsForCamera)
              || bCheckDummies == 1
              && !CWorld::GetIsLineOfSightSectorListClear(
                    &CWorld::ms_aSectors[v38].m_dummyPtrListArray,
                    &line,
                    bSeeThroughStuff,
                    0) )
            {
              break;
            }
            v25 = 1;
            v33 = v20++ < v128;
            if ( !v33 )
              return v25;
          }
        }
      }
      else
      {
        v43 = (float)(v15 - y) / (float)(v14 - x);
        if ( v14 <= x )
        {
          v55 = floorf((float)((float)(y + (float)((float)((float)((float)(v20 - 60) * 50.0) - x) * v43)) / 50.0) + 60.0);
          v56 = 0;
          if ( v20 > 0 )
            v56 = (int)v12;
          v57 = (int)v55;
          v58 = 16 * v19;
          if ( v56 >= 119 )
            v56 = 119;
          v125 = (int)v12 & 0xF;
          if ( v57 <= v19 )
          {
            while ( 1 )
            {
              CColLine::CColLine(&line, vecStart, vecEnd);
              v88 = 0;
              if ( v19 > 0 )
                v88 = v19;
              if ( v88 >= 119 )
                v88 = 119;
              v89 = v56 + 120 * v88;
              if ( bCheckBuildings == 1
                && !CWorld::GetIsLineOfSightSectorListClear(
                      &CWorld::ms_aSectors[v89].m_buildingPtrListArray,
                      &line,
                      bSeeThroughStuff,
                      0) )
              {
                break;
              }
              v90 = v58 & 0xF0 | v125;
              if ( bCheckVehicles == 1
                && !CWorld::GetIsLineOfSightSectorListClear(
                      (CPtrList *)&CWorld::ms_aRepeatSectors[v90],
                      &line,
                      bSeeThroughStuff,
                      0) )
              {
                break;
              }
              if ( bCheckPeds == 1
                && !CWorld::GetIsLineOfSightSectorListClear(
                      &CWorld::ms_aRepeatSectors[v90].m_ptrListArray[1],
                      &line,
                      bSeeThroughStuff,
                      0)
                || bCheckObjects == 1
                && !CWorld::GetIsLineOfSightSectorListClear(
                      &CWorld::ms_aRepeatSectors[v90].m_ptrListArray[2],
                      &line,
                      bSeeThroughStuff,
                      bIgnoreSomeObjectsForCamera)
                || bCheckDummies == 1
                && !CWorld::GetIsLineOfSightSectorListClear(
                      &CWorld::ms_aSectors[v89].m_dummyPtrListArray,
                      &line,
                      bSeeThroughStuff,
                      0) )
              {
                break;
              }
              v62 = v57;
              v58 -= 16;
              v33 = v19-- <= v57;
              if ( v33 )
              {
LABEL_239:
                v91 = v128;
                v92 = v20 - 1;
                if ( v20 - 1 <= v128 )
                {
LABEL_278:
                  v105 = 0;
                  if ( v91 > 0 )
                    v105 = v91;
                  v106 = v91 & 0xF;
                  if ( v105 >= 119 )
                    v105 = 119;
                  v107 = 16 * v62;
                  if ( v62 >= v129 )
                  {
                    while ( 1 )
                    {
                      v118 = v62;
                      CColLine::CColLine(&line, vecStart, vecEnd);
                      v119 = 0;
                      if ( v118 > 0 )
                        v119 = v118;
                      v120 = v118;
                      if ( v119 >= 119 )
                        v119 = 119;
                      v121 = v105 + 120 * v119;
                      if ( bCheckBuildings == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aSectors[v121].m_buildingPtrListArray,
                              &line,
                              bSeeThroughStuff,
                              0) )
                      {
                        break;
                      }
                      v122 = v107 & 0xF0 | v106;
                      if ( bCheckVehicles == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              (CPtrList *)&CWorld::ms_aRepeatSectors[v122],
                              &line,
                              bSeeThroughStuff,
                              0) )
                      {
                        break;
                      }
                      if ( bCheckPeds == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aRepeatSectors[v122].m_ptrListArray[1],
                              &line,
                              bSeeThroughStuff,
                              0)
                        || bCheckObjects == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aRepeatSectors[v122].m_ptrListArray[2],
                              &line,
                              bSeeThroughStuff,
                              bIgnoreSomeObjectsForCamera)
                        || bCheckDummies == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aSectors[v121].m_dummyPtrListArray,
                              &line,
                              bSeeThroughStuff,
                              0) )
                      {
                        break;
                      }
                      v107 -= 16;
                      v25 = 1;
                      v62 = v120 - 1;
                      if ( v120 <= v129 )
                        return v25;
                    }
                  }
                  else
                  {
                    while ( 1 )
                    {
                      v108 = v62;
                      CColLine::CColLine(&line, vecStart, vecEnd);
                      v109 = 0;
                      if ( v108 > 0 )
                        v109 = v108;
                      v110 = v108;
                      if ( v109 >= 119 )
                        v109 = 119;
                      v111 = v105 + 120 * v109;
                      if ( bCheckBuildings == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aSectors[v111].m_buildingPtrListArray,
                              &line,
                              bSeeThroughStuff,
                              0) )
                      {
                        break;
                      }
                      v112 = v107 & 0xF0 | v106;
                      if ( bCheckVehicles == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              (CPtrList *)&CWorld::ms_aRepeatSectors[v112],
                              &line,
                              bSeeThroughStuff,
                              0) )
                      {
                        break;
                      }
                      if ( bCheckPeds == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aRepeatSectors[v112].m_ptrListArray[1],
                              &line,
                              bSeeThroughStuff,
                              0)
                        || bCheckObjects == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aRepeatSectors[v112].m_ptrListArray[2],
                              &line,
                              bSeeThroughStuff,
                              bIgnoreSomeObjectsForCamera)
                        || bCheckDummies == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aSectors[v111].m_dummyPtrListArray,
                              &line,
                              bSeeThroughStuff,
                              0) )
                      {
                        break;
                      }
                      v107 += 16;
                      v25 = 1;
                      v62 = v110 + 1;
                      if ( v110 >= v129 )
                        return v25;
                    }
                  }
                }
                else
                {
LABEL_240:
                  v93 = v20;
                  v20 = v92;
                  v94 = v62;
                  v95 = floorf(
                          (float)((float)(vecStart->y
                                        + (float)(v43 * (float)((float)((float)(v93 - 61) * 50.0) - vecStart->x)))
                                / 50.0)
                        + 60.0);
                  v96 = 0;
                  v97 = 16 * v94;
                  if ( v20 > 0 )
                    v96 = v20;
                  v98 = (int)v95;
                  if ( v96 >= 119 )
                    v96 = 119;
                  v127 = v20 & 0xF;
                  if ( v94 >= v98 )
                  {
                    while ( 1 )
                    {
                      CColLine::CColLine(&line, vecStart, vecEnd);
                      v102 = 0;
                      if ( v94 > 0 )
                        v102 = v94;
                      if ( v102 >= 119 )
                        v102 = 119;
                      v103 = v96 + 120 * v102;
                      if ( bCheckBuildings == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aSectors[v103].m_buildingPtrListArray,
                              &line,
                              bSeeThroughStuff,
                              0) )
                      {
                        break;
                      }
                      v104 = v97 & 0xF0 | v127;
                      if ( bCheckVehicles == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              (CPtrList *)&CWorld::ms_aRepeatSectors[v104],
                              &line,
                              bSeeThroughStuff,
                              0) )
                      {
                        break;
                      }
                      if ( bCheckPeds == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aRepeatSectors[v104].m_ptrListArray[1],
                              &line,
                              bSeeThroughStuff,
                              0)
                        || bCheckObjects == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aRepeatSectors[v104].m_ptrListArray[2],
                              &line,
                              bSeeThroughStuff,
                              bIgnoreSomeObjectsForCamera)
                        || bCheckDummies == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aSectors[v103].m_dummyPtrListArray,
                              &line,
                              bSeeThroughStuff,
                              0) )
                      {
                        break;
                      }
                      v62 = v98;
                      v97 -= 16;
                      v33 = v94-- <= v98;
                      if ( v33 )
                      {
LABEL_277:
                        v91 = v128;
                        v92 = v20 - 1;
                        if ( v20 - 1 > v128 )
                          goto LABEL_240;
                        goto LABEL_278;
                      }
                    }
                  }
                  else
                  {
                    while ( 1 )
                    {
                      CColLine::CColLine(&line, vecStart, vecEnd);
                      v99 = 0;
                      if ( v94 > 0 )
                        v99 = v94;
                      if ( v99 >= 119 )
                        v99 = 119;
                      v100 = v96 + 120 * v99;
                      if ( bCheckBuildings == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aSectors[v100].m_buildingPtrListArray,
                              &line,
                              bSeeThroughStuff,
                              0) )
                      {
                        break;
                      }
                      v101 = v97 & 0xF0 | v127;
                      if ( bCheckVehicles == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              (CPtrList *)&CWorld::ms_aRepeatSectors[v101],
                              &line,
                              bSeeThroughStuff,
                              0) )
                      {
                        break;
                      }
                      if ( bCheckPeds == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aRepeatSectors[v101].m_ptrListArray[1],
                              &line,
                              bSeeThroughStuff,
                              0)
                        || bCheckObjects == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aRepeatSectors[v101].m_ptrListArray[2],
                              &line,
                              bSeeThroughStuff,
                              bIgnoreSomeObjectsForCamera)
                        || bCheckDummies == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aSectors[v100].m_dummyPtrListArray,
                              &line,
                              bSeeThroughStuff,
                              0) )
                      {
                        break;
                      }
                      v62 = v98;
                      v97 += 16;
                      v33 = v94++ < v98;
                      if ( !v33 )
                        goto LABEL_277;
                    }
                  }
                }
                return 0;
              }
            }
          }
          else
          {
            while ( 1 )
            {
              CColLine::CColLine(&line, vecStart, vecEnd);
              v59 = 0;
              if ( v19 > 0 )
                v59 = v19;
              if ( v59 >= 119 )
                v59 = 119;
              v60 = v56 + 120 * v59;
              if ( bCheckBuildings == 1
                && !CWorld::GetIsLineOfSightSectorListClear(
                      &CWorld::ms_aSectors[v60].m_buildingPtrListArray,
                      &line,
                      bSeeThroughStuff,
                      0) )
              {
                break;
              }
              v61 = v58 & 0xF0 | v125;
              if ( bCheckVehicles == 1
                && !CWorld::GetIsLineOfSightSectorListClear(
                      (CPtrList *)&CWorld::ms_aRepeatSectors[v61],
                      &line,
                      bSeeThroughStuff,
                      0) )
              {
                break;
              }
              if ( bCheckPeds == 1
                && !CWorld::GetIsLineOfSightSectorListClear(
                      &CWorld::ms_aRepeatSectors[v61].m_ptrListArray[1],
                      &line,
                      bSeeThroughStuff,
                      0)
                || bCheckObjects == 1
                && !CWorld::GetIsLineOfSightSectorListClear(
                      &CWorld::ms_aRepeatSectors[v61].m_ptrListArray[2],
                      &line,
                      bSeeThroughStuff,
                      bIgnoreSomeObjectsForCamera)
                || bCheckDummies == 1
                && !CWorld::GetIsLineOfSightSectorListClear(
                      &CWorld::ms_aSectors[v60].m_dummyPtrListArray,
                      &line,
                      bSeeThroughStuff,
                      0) )
              {
                break;
              }
              v62 = v57;
              v58 += 16;
              v33 = v19++ < v57;
              if ( !v33 )
                goto LABEL_239;
            }
          }
        }
        else
        {
          v44 = floorf((float)((float)(y + (float)((float)((float)((float)(v20 - 59) * 50.0) - x) * v43)) / 50.0) + 60.0);
          v45 = 0;
          if ( v20 > 0 )
            v45 = (int)v12;
          v46 = (int)v44;
          v47 = 16 * v19;
          if ( v45 >= 119 )
            v45 = 119;
          v124 = (int)v12 & 0xF;
          if ( v46 <= v19 )
          {
            while ( 1 )
            {
              CColLine::CColLine(&line, vecStart, vecEnd);
              v63 = 0;
              if ( v19 > 0 )
                v63 = v19;
              if ( v63 >= 119 )
                v63 = 119;
              v64 = v45 + 120 * v63;
              if ( bCheckBuildings == 1
                && !CWorld::GetIsLineOfSightSectorListClear(
                      &CWorld::ms_aSectors[v64].m_buildingPtrListArray,
                      &line,
                      bSeeThroughStuff,
                      0) )
              {
                break;
              }
              v65 = v47 & 0xF0 | v124;
              if ( bCheckVehicles == 1
                && !CWorld::GetIsLineOfSightSectorListClear(
                      (CPtrList *)&CWorld::ms_aRepeatSectors[v65],
                      &line,
                      bSeeThroughStuff,
                      0) )
              {
                break;
              }
              if ( bCheckPeds == 1
                && !CWorld::GetIsLineOfSightSectorListClear(
                      &CWorld::ms_aRepeatSectors[v65].m_ptrListArray[1],
                      &line,
                      bSeeThroughStuff,
                      0)
                || bCheckObjects == 1
                && !CWorld::GetIsLineOfSightSectorListClear(
                      &CWorld::ms_aRepeatSectors[v65].m_ptrListArray[2],
                      &line,
                      bSeeThroughStuff,
                      bIgnoreSomeObjectsForCamera)
                || bCheckDummies == 1
                && !CWorld::GetIsLineOfSightSectorListClear(
                      &CWorld::ms_aSectors[v64].m_dummyPtrListArray,
                      &line,
                      bSeeThroughStuff,
                      0) )
              {
                break;
              }
              v51 = v46;
              v47 -= 16;
              v33 = v19-- <= v46;
              if ( v33 )
              {
LABEL_163:
                v66 = v128;
                v67 = v20 + 1;
                if ( v20 + 1 >= v128 )
                {
LABEL_202:
                  v80 = 0;
                  if ( v66 > 0 )
                    v80 = v66;
                  v81 = v66 & 0xF;
                  if ( v80 >= 119 )
                    v80 = 119;
                  v82 = 16 * v51;
                  if ( v51 >= v129 )
                  {
                    while ( 1 )
                    {
                      v113 = v51;
                      CColLine::CColLine(&line, vecStart, vecEnd);
                      v114 = 0;
                      if ( v113 > 0 )
                        v114 = v113;
                      v115 = v113;
                      if ( v114 >= 119 )
                        v114 = 119;
                      v116 = v80 + 120 * v114;
                      if ( bCheckBuildings == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aSectors[v116].m_buildingPtrListArray,
                              &line,
                              bSeeThroughStuff,
                              0) )
                      {
                        break;
                      }
                      v117 = v82 & 0xF0 | v81;
                      if ( bCheckVehicles == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              (CPtrList *)&CWorld::ms_aRepeatSectors[v117],
                              &line,
                              bSeeThroughStuff,
                              0) )
                      {
                        break;
                      }
                      if ( bCheckPeds == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aRepeatSectors[v117].m_ptrListArray[1],
                              &line,
                              bSeeThroughStuff,
                              0)
                        || bCheckObjects == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aRepeatSectors[v117].m_ptrListArray[2],
                              &line,
                              bSeeThroughStuff,
                              bIgnoreSomeObjectsForCamera)
                        || bCheckDummies == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aSectors[v116].m_dummyPtrListArray,
                              &line,
                              bSeeThroughStuff,
                              0) )
                      {
                        break;
                      }
                      v82 -= 16;
                      v25 = 1;
                      v51 = v115 - 1;
                      if ( v115 <= v129 )
                        return v25;
                    }
                  }
                  else
                  {
                    while ( 1 )
                    {
                      v83 = v51;
                      CColLine::CColLine(&line, vecStart, vecEnd);
                      v84 = 0;
                      if ( v83 > 0 )
                        v84 = v83;
                      v85 = v83;
                      if ( v84 >= 119 )
                        v84 = 119;
                      v86 = v80 + 120 * v84;
                      if ( bCheckBuildings == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aSectors[v86].m_buildingPtrListArray,
                              &line,
                              bSeeThroughStuff,
                              0) )
                      {
                        break;
                      }
                      v87 = v82 & 0xF0 | v81;
                      if ( bCheckVehicles == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              (CPtrList *)&CWorld::ms_aRepeatSectors[v87],
                              &line,
                              bSeeThroughStuff,
                              0) )
                      {
                        break;
                      }
                      if ( bCheckPeds == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aRepeatSectors[v87].m_ptrListArray[1],
                              &line,
                              bSeeThroughStuff,
                              0)
                        || bCheckObjects == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aRepeatSectors[v87].m_ptrListArray[2],
                              &line,
                              bSeeThroughStuff,
                              bIgnoreSomeObjectsForCamera)
                        || bCheckDummies == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aSectors[v86].m_dummyPtrListArray,
                              &line,
                              bSeeThroughStuff,
                              0) )
                      {
                        break;
                      }
                      v82 += 16;
                      v25 = 1;
                      v51 = v85 + 1;
                      if ( v85 >= v129 )
                        return v25;
                    }
                  }
                }
                else
                {
LABEL_164:
                  v68 = v20;
                  v20 = v67;
                  v69 = v51;
                  v70 = floorf(
                          (float)((float)(vecStart->y
                                        + (float)(v43 * (float)((float)((float)(v68 - 58) * 50.0) - vecStart->x)))
                                / 50.0)
                        + 60.0);
                  v71 = 0;
                  v72 = 16 * v69;
                  if ( v20 > 0 )
                    v71 = v20;
                  v73 = (int)v70;
                  if ( v71 >= 119 )
                    v71 = 119;
                  v126 = v20 & 0xF;
                  if ( v69 >= v73 )
                  {
                    while ( 1 )
                    {
                      CColLine::CColLine(&line, vecStart, vecEnd);
                      v77 = 0;
                      if ( v69 > 0 )
                        v77 = v69;
                      if ( v77 >= 119 )
                        v77 = 119;
                      v78 = v71 + 120 * v77;
                      if ( bCheckBuildings == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aSectors[v78].m_buildingPtrListArray,
                              &line,
                              bSeeThroughStuff,
                              0) )
                      {
                        break;
                      }
                      v79 = v72 & 0xF0 | v126;
                      if ( bCheckVehicles == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              (CPtrList *)&CWorld::ms_aRepeatSectors[v79],
                              &line,
                              bSeeThroughStuff,
                              0) )
                      {
                        break;
                      }
                      if ( bCheckPeds == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aRepeatSectors[v79].m_ptrListArray[1],
                              &line,
                              bSeeThroughStuff,
                              0)
                        || bCheckObjects == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aRepeatSectors[v79].m_ptrListArray[2],
                              &line,
                              bSeeThroughStuff,
                              bIgnoreSomeObjectsForCamera)
                        || bCheckDummies == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aSectors[v78].m_dummyPtrListArray,
                              &line,
                              bSeeThroughStuff,
                              0) )
                      {
                        break;
                      }
                      v51 = v73;
                      v72 -= 16;
                      v33 = v69-- <= v73;
                      if ( v33 )
                      {
LABEL_201:
                        v66 = v128;
                        v67 = v20 + 1;
                        if ( v20 + 1 < v128 )
                          goto LABEL_164;
                        goto LABEL_202;
                      }
                    }
                  }
                  else
                  {
                    while ( 1 )
                    {
                      CColLine::CColLine(&line, vecStart, vecEnd);
                      v74 = 0;
                      if ( v69 > 0 )
                        v74 = v69;
                      if ( v74 >= 119 )
                        v74 = 119;
                      v75 = v71 + 120 * v74;
                      if ( bCheckBuildings == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aSectors[v75].m_buildingPtrListArray,
                              &line,
                              bSeeThroughStuff,
                              0) )
                      {
                        break;
                      }
                      v76 = v72 & 0xF0 | v126;
                      if ( bCheckVehicles == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              (CPtrList *)&CWorld::ms_aRepeatSectors[v76],
                              &line,
                              bSeeThroughStuff,
                              0) )
                      {
                        break;
                      }
                      if ( bCheckPeds == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aRepeatSectors[v76].m_ptrListArray[1],
                              &line,
                              bSeeThroughStuff,
                              0)
                        || bCheckObjects == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aRepeatSectors[v76].m_ptrListArray[2],
                              &line,
                              bSeeThroughStuff,
                              bIgnoreSomeObjectsForCamera)
                        || bCheckDummies == 1
                        && !CWorld::GetIsLineOfSightSectorListClear(
                              &CWorld::ms_aSectors[v75].m_dummyPtrListArray,
                              &line,
                              bSeeThroughStuff,
                              0) )
                      {
                        break;
                      }
                      v51 = v73;
                      v72 += 16;
                      v33 = v69++ < v73;
                      if ( !v33 )
                        goto LABEL_201;
                    }
                  }
                }
                return 0;
              }
            }
          }
          else
          {
            while ( 1 )
            {
              CColLine::CColLine(&line, vecStart, vecEnd);
              v48 = 0;
              if ( v19 > 0 )
                v48 = v19;
              if ( v48 >= 119 )
                v48 = 119;
              v49 = v45 + 120 * v48;
              if ( bCheckBuildings == 1
                && !CWorld::GetIsLineOfSightSectorListClear(
                      &CWorld::ms_aSectors[v49].m_buildingPtrListArray,
                      &line,
                      bSeeThroughStuff,
                      0) )
              {
                break;
              }
              v50 = v47 & 0xF0 | v124;
              if ( bCheckVehicles == 1
                && !CWorld::GetIsLineOfSightSectorListClear(
                      (CPtrList *)&CWorld::ms_aRepeatSectors[v50],
                      &line,
                      bSeeThroughStuff,
                      0) )
              {
                break;
              }
              if ( bCheckPeds == 1
                && !CWorld::GetIsLineOfSightSectorListClear(
                      &CWorld::ms_aRepeatSectors[v50].m_ptrListArray[1],
                      &line,
                      bSeeThroughStuff,
                      0)
                || bCheckObjects == 1
                && !CWorld::GetIsLineOfSightSectorListClear(
                      &CWorld::ms_aRepeatSectors[v50].m_ptrListArray[2],
                      &line,
                      bSeeThroughStuff,
                      bIgnoreSomeObjectsForCamera)
                || bCheckDummies == 1
                && !CWorld::GetIsLineOfSightSectorListClear(
                      &CWorld::ms_aSectors[v49].m_dummyPtrListArray,
                      &line,
                      bSeeThroughStuff,
                      0) )
              {
                break;
              }
              v51 = v46;
              v47 += 16;
              v33 = v19++ < v46;
              if ( !v33 )
                goto LABEL_163;
            }
          }
        }
      }
    }
    return 0;
  }
  CColLine::CColLine(&line, vecStart, vecEnd);
  v22 = 0;
  if ( v20 > 0 )
    v22 = (int)v12;
  v23 = 0;
  if ( v22 >= 119 )
    v22 = 119;
  if ( v19 > 0 )
    v23 = v19;
  if ( v23 >= 119 )
    v23 = 119;
  v24 = v22 + 120 * v23;
  if ( bCheckBuildings != 1
    || (v25 = 0,
        CWorld::GetIsLineOfSightSectorListClear(
          &CWorld::ms_aSectors[v24].m_buildingPtrListArray,
          &line,
          bSeeThroughStuff,
          0)) )
  {
    v26 = v20 & 0xF | (16 * (v19 & 0xF));
    if ( bCheckVehicles != 1
      || (v25 = 0,
          CWorld::GetIsLineOfSightSectorListClear(
            (CPtrList *)&CWorld::ms_aRepeatSectors[v26],
            &line,
            bSeeThroughStuff,
            0)) )
    {
      if ( bCheckPeds != 1
        || (v25 = 0,
            CWorld::GetIsLineOfSightSectorListClear(
              &CWorld::ms_aRepeatSectors[v26].m_ptrListArray[1],
              &line,
              bSeeThroughStuff,
              0)) )
      {
        if ( bCheckObjects == 1
          && !CWorld::GetIsLineOfSightSectorListClear(
                &CWorld::ms_aRepeatSectors[v26].m_ptrListArray[2],
                &line,
                bSeeThroughStuff,
                bIgnoreSomeObjectsForCamera) )
        {
          return 0;
        }
        return bCheckDummies != 1
            || CWorld::GetIsLineOfSightSectorListClear(
                 &CWorld::ms_aSectors[v24].m_dummyPtrListArray,
                 &line,
                 bSeeThroughStuff,
                 0);
      }
    }
  }
  return v25;
}

//----- (00424AF8) --------------------------------------------------------
bool __fastcall CWorld::GetIsLineOfSightSectorClear(
        CSector *sector,
        CRepeatSector *rsector,
        const CColLine *line,
        int bCheckBuildings,
        int bCheckVehicles,
        int bCheckPeds,
        int bCheckObjects,
        int bCheckDummies,
        bool bSeeThroughStuff,
        bool bIgnoreSomeObjectsForCamera)
{
  int v13; // r6

  if ( bCheckBuildings != 1
    || (v13 = 0, CWorld::GetIsLineOfSightSectorListClear(&sector->m_buildingPtrListArray, line, bSeeThroughStuff, 0)) )
  {
    if ( bCheckVehicles != 1
      || (v13 = 0, CWorld::GetIsLineOfSightSectorListClear((CPtrList *)rsector, line, bSeeThroughStuff, 0)) )
    {
      if ( bCheckPeds != 1
        || (v13 = 0, CWorld::GetIsLineOfSightSectorListClear(&rsector->m_ptrListArray[1], line, bSeeThroughStuff, 0)) )
      {
        if ( bCheckObjects == 1
          && !CWorld::GetIsLineOfSightSectorListClear(
                &rsector->m_ptrListArray[2],
                line,
                bSeeThroughStuff,
                bIgnoreSomeObjectsForCamera) )
        {
          return 0;
        }
        else
        {
          return bCheckDummies != 1
              || CWorld::GetIsLineOfSightSectorListClear(&sector->m_dummyPtrListArray, line, bSeeThroughStuff, 0);
        }
      }
    }
  }
  return v13;
}

//----- (00424B94) --------------------------------------------------------
int __fastcall CWorld::ProcessLineOfSight(
        const CVector *vecStart,
        const CVector *vecEnd,
        CColPoint *colPoint,
        CEntity **refEntityPtr,
        int bCheckBuildings,
        int bCheckVehicles,
        int bCheckPeds,
        int bCheckObjects,
        int bCheckDummies,
        int bSeeThroughStuff,
        int bIgnoreSomeObjectsForCamera,
        int bShootThroughStuff)
{
  uint16 v16; // r0
  float x; // s24
  float y; // s22
  float v19; // r10
  float v20; // r0
  float v21; // s26
  float v22; // r11
  float v23; // s20
  float v24; // r5
  int v25; // s6
  int v26; // r0
  int v27; // r1
  int v28; // r10
  int v29; // r5
  bool v30; // zf
  int v31; // r2
  int v32; // r0
  int v34; // r4
  int v35; // r9
  char v36; // r5
  int v37; // r0
  bool v38; // cc
  int v39; // r0
  int v40; // r6
  int v41; // r4
  int v42; // r8
  int v43; // r0
  int v44; // r0
  float v45; // s20
  float v46; // s0
  int v47; // r4
  int v48; // s0
  int v49; // r8
  char v50; // r5
  int v51; // r0
  int v52; // r3
  int v53; // r0
  float v54; // s0
  int v55; // r4
  int v56; // s0
  char v57; // r5
  int v58; // r0
  int v59; // r3
  int v60; // r0
  int v61; // r6
  int v62; // r1
  int v63; // r0
  int v64; // r4
  int v65; // r8
  float v66; // r0
  int v67; // r9
  int v68; // r6
  int v69; // s0
  char v70; // r4
  int v71; // r0
  int v72; // r0
  int v73; // r4
  int v74; // r9
  char v75; // r5
  int v76; // r11
  int v77; // r0
  int v78; // r0
  int v79; // r6
  int v80; // r1
  int v81; // r0
  int v82; // r5
  int v83; // r11
  float v84; // r0
  int v85; // r4
  int v86; // s0
  int v87; // r8
  char v88; // r6
  int v89; // r0
  char v90; // r9
  int v91; // r0
  int v92; // r4
  int v93; // r6
  char v94; // r5
  int v95; // r10
  int v96; // r0
  int v97; // r6
  int v98; // r0
  int v99; // r10
  int v100; // r6
  int v101; // r0
  int v102; // [sp+30h] [bp-A0h]
  CVector *v103; // [sp+34h] [bp-9Ch]
  int v104; // [sp+38h] [bp-98h]
  int v105; // [sp+3Ch] [bp-94h]
  CVector *v106; // [sp+50h] [bp-80h]
  CEntity **v107; // [sp+54h] [bp-7Ch]
  CColPoint *v108; // [sp+58h] [bp-78h]
  CColLine v109; // [sp+5Ch] [bp-74h] BYREF
  float fCollisionRatio[21]; // [sp+7Ch] [bp-54h] BYREF

  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v16 = 1;
  }
  else
  {
    v16 = CWorld::ms_nCurrentScanCode + 1;
  }
  CWorld::ms_iProcessLineNumCrossings = 0;
  CWorld::ms_nCurrentScanCode = v16;
  *refEntityPtr = 0;
  x = vecStart->x;
  y = vecStart->y;
  v19 = floorf((float)(vecStart->x / 50.0) + 60.0);
  v20 = floorf((float)(y / 50.0) + 60.0);
  v21 = vecEnd->x;
  v22 = v20;
  v23 = vecEnd->y;
  v24 = floorf((float)(vecEnd->x / 50.0) + 60.0);
  v25 = (int)v19;
  fCollisionRatio[0] = 1.0;
  v26 = (int)floorf((float)(v23 / 50.0) + 60.0);
  v27 = (int)v24;
  v28 = (int)v22;
  v29 = v25;
  v30 = v25 == v27;
  if ( v25 == v27 )
    v30 = v28 == v26;
  if ( v30 )
  {
    CColLine::CColLine(&v109, vecStart, vecEnd);
    v31 = 0;
    if ( v25 > 0 )
      v31 = v25;
    v32 = 0;
    if ( v31 >= 119 )
      v31 = 119;
    if ( v28 > 0 )
      v32 = (int)v22;
    if ( v32 >= 119 )
      v32 = 119;
    return CWorld::ProcessLineOfSightSector(
             &CWorld::ms_aSectors[120 * v32 + v31],
             &CWorld::ms_aRepeatSectors[v25 & 0xF | (16 * ((int)v22 & 0xF))],
             &v109,
             colPoint,
             fCollisionRatio,
             refEntityPtr,
             bCheckBuildings,
             bCheckVehicles,
             bCheckPeds,
             bCheckObjects,
             bCheckDummies,
             bSeeThroughStuff,
             bIgnoreSomeObjectsForCamera,
             bShootThroughStuff);
  }
  else
  {
    v106 = (CVector *)vecEnd;
    v107 = refEntityPtr;
    v108 = colPoint;
    v103 = (CVector *)vecStart;
    v105 = v26;
    if ( v25 == v27 )
    {
      v34 = 0;
      if ( v25 > 0 )
        v34 = v25;
      v35 = v25 & 0xF;
      if ( v34 >= 119 )
        v34 = 119;
      v36 = 16 * v28;
      if ( v28 >= v26 )
      {
        do
        {
          CColLine::CColLine(&v109, v103, vecEnd);
          v44 = 0;
          if ( v28 > 0 )
            v44 = v28;
          if ( v44 >= 119 )
            v44 = 119;
          CWorld::ProcessLineOfSightSector(
            &CWorld::ms_aSectors[120 * v44 + v34],
            &CWorld::ms_aRepeatSectors[v36 & 0xF0 | v35],
            &v109,
            v108,
            fCollisionRatio,
            refEntityPtr,
            bCheckBuildings,
            bCheckVehicles,
            bCheckPeds,
            bCheckObjects,
            bCheckDummies,
            bSeeThroughStuff,
            bIgnoreSomeObjectsForCamera,
            bShootThroughStuff);
          v36 -= 16;
          v38 = v28-- <= v105;
        }
        while ( !v38 );
      }
      else
      {
        do
        {
          CColLine::CColLine(&v109, v103, vecEnd);
          v37 = 0;
          if ( v28 > 0 )
            v37 = v28;
          if ( v37 >= 119 )
            v37 = 119;
          CWorld::ProcessLineOfSightSector(
            &CWorld::ms_aSectors[120 * v37 + v34],
            &CWorld::ms_aRepeatSectors[v36 & 0xF0 | v35],
            &v109,
            v108,
            fCollisionRatio,
            refEntityPtr,
            bCheckBuildings,
            bCheckVehicles,
            bCheckPeds,
            bCheckObjects,
            bCheckDummies,
            bSeeThroughStuff,
            bIgnoreSomeObjectsForCamera,
            bShootThroughStuff);
          v36 += 16;
          v38 = v28++ < v105;
        }
        while ( v38 );
      }
    }
    else
    {
      v104 = v27;
      if ( v28 == v26 )
      {
        v39 = 0;
        if ( v28 > 0 )
          v39 = (int)v22;
        if ( v39 >= 119 )
          v39 = 119;
        v40 = 120 * v39;
        v41 = (unsigned __int8)(16 * v28);
        if ( v25 >= v27 )
        {
          do
          {
            CColLine::CColLine(&v109, v103, v106);
            v53 = 0;
            if ( v29 > 0 )
              v53 = v29;
            if ( v53 >= 119 )
              v53 = 119;
            CWorld::ProcessLineOfSightSector(
              &CWorld::ms_aSectors[v53 + v40],
              &CWorld::ms_aRepeatSectors[v29 & 0xF | v41],
              &v109,
              colPoint,
              fCollisionRatio,
              refEntityPtr,
              bCheckBuildings,
              bCheckVehicles,
              bCheckPeds,
              bCheckObjects,
              bCheckDummies,
              bSeeThroughStuff,
              bIgnoreSomeObjectsForCamera,
              bShootThroughStuff);
            v38 = v29-- <= v104;
          }
          while ( !v38 );
        }
        else
        {
          v42 = v25;
          do
          {
            CColLine::CColLine(&v109, v103, v106);
            v43 = 0;
            if ( v42 > 0 )
              v43 = v42;
            if ( v43 >= 119 )
              v43 = 119;
            CWorld::ProcessLineOfSightSector(
              &CWorld::ms_aSectors[v43 + v40],
              &CWorld::ms_aRepeatSectors[v42 & 0xF | v41],
              &v109,
              colPoint,
              fCollisionRatio,
              v107,
              bCheckBuildings,
              bCheckVehicles,
              bCheckPeds,
              bCheckObjects,
              bCheckDummies,
              bSeeThroughStuff,
              bIgnoreSomeObjectsForCamera,
              bShootThroughStuff);
            v38 = v42++ < v104;
          }
          while ( v38 );
        }
      }
      else
      {
        v45 = (float)(v23 - y) / (float)(v21 - x);
        if ( v21 <= x )
        {
          v54 = floorf((float)((float)(y + (float)(v45 * (float)((float)((float)(v25 - 60) * 50.0) - x))) / 50.0) + 60.0);
          v55 = 0;
          if ( v25 > 0 )
            v55 = v25;
          v56 = (int)v54;
          if ( v55 >= 119 )
            v55 = 119;
          v57 = 16 * v28;
          if ( v56 <= v28 )
          {
            do
            {
              CColLine::CColLine(&v109, v103, vecEnd);
              v78 = 0;
              if ( v28 > 0 )
                v78 = v28;
              if ( v78 >= 119 )
                v78 = 119;
              CWorld::ProcessLineOfSightSector(
                &CWorld::ms_aSectors[120 * v78 + v55],
                &CWorld::ms_aRepeatSectors[v57 & 0xF0 | v25 & 0xF],
                &v109,
                colPoint,
                fCollisionRatio,
                refEntityPtr,
                bCheckBuildings,
                bCheckVehicles,
                bCheckPeds,
                bCheckObjects,
                bCheckDummies,
                bSeeThroughStuff,
                bIgnoreSomeObjectsForCamera,
                bShootThroughStuff);
              v59 = v56;
              v57 -= 16;
              v38 = v28-- <= v56;
            }
            while ( !v38 );
          }
          else
          {
            do
            {
              CColLine::CColLine(&v109, v103, vecEnd);
              v58 = 0;
              if ( v28 > 0 )
                v58 = v28;
              if ( v58 >= 119 )
                v58 = 119;
              CWorld::ProcessLineOfSightSector(
                &CWorld::ms_aSectors[120 * v58 + v55],
                &CWorld::ms_aRepeatSectors[v57 & 0xF0 | v25 & 0xF],
                &v109,
                colPoint,
                fCollisionRatio,
                refEntityPtr,
                bCheckBuildings,
                bCheckVehicles,
                bCheckPeds,
                bCheckObjects,
                bCheckDummies,
                bSeeThroughStuff,
                bIgnoreSomeObjectsForCamera,
                bShootThroughStuff);
              v59 = v56;
              v57 += 16;
              v38 = v28++ < v56;
            }
            while ( v38 );
          }
          v79 = v25;
          v80 = v104;
          v81 = v25 - 1;
          if ( v25 - 1 > v104 )
          {
            do
            {
              v82 = v81;
              v83 = v59;
              v84 = floorf(
                      (float)((float)(v103->y + (float)(v45 * (float)((float)((float)(v79 - 61) * 50.0) - v103->x)))
                            / 50.0)
                    + 60.0);
              v85 = 0;
              if ( v82 > 0 )
                v85 = v82;
              v86 = (int)v84;
              if ( v85 >= 119 )
                v85 = 119;
              v87 = v82 & 0xF;
              if ( v83 >= v86 )
              {
                v90 = 16 * v83;
                do
                {
                  CColLine::CColLine(&v109, v103, v106);
                  v91 = 0;
                  if ( v83 > 0 )
                    v91 = v83;
                  if ( v91 >= 119 )
                    v91 = 119;
                  CWorld::ProcessLineOfSightSector(
                    &CWorld::ms_aSectors[120 * v91 + v85],
                    &CWorld::ms_aRepeatSectors[v90 & 0xF0 | v87],
                    &v109,
                    v108,
                    fCollisionRatio,
                    v107,
                    bCheckBuildings,
                    bCheckVehicles,
                    bCheckPeds,
                    bCheckObjects,
                    bCheckDummies,
                    bSeeThroughStuff,
                    bIgnoreSomeObjectsForCamera,
                    bShootThroughStuff);
                  v90 -= 16;
                  v59 = v86;
                  v38 = v83-- <= v86;
                }
                while ( !v38 );
              }
              else
              {
                v88 = 16 * v83;
                do
                {
                  CColLine::CColLine(&v109, v103, v106);
                  v89 = 0;
                  if ( v83 > 0 )
                    v89 = v83;
                  if ( v89 >= 119 )
                    v89 = 119;
                  CWorld::ProcessLineOfSightSector(
                    &CWorld::ms_aSectors[120 * v89 + v85],
                    &CWorld::ms_aRepeatSectors[v88 & 0xF0 | v87],
                    &v109,
                    v108,
                    fCollisionRatio,
                    v107,
                    bCheckBuildings,
                    bCheckVehicles,
                    bCheckPeds,
                    bCheckObjects,
                    bCheckDummies,
                    bSeeThroughStuff,
                    bIgnoreSomeObjectsForCamera,
                    bShootThroughStuff);
                  v88 += 16;
                  v59 = v86;
                  v38 = v83++ < v86;
                }
                while ( v38 );
              }
              v79 = v82;
              v80 = v104;
              v81 = v82 - 1;
            }
            while ( v82 - 1 > v104 );
          }
          v92 = 0;
          if ( v80 > 0 )
            v92 = v80;
          v93 = v80 & 0xF;
          if ( v92 >= 119 )
            v92 = 119;
          v94 = 16 * v59;
          if ( v59 >= v105 )
          {
            v99 = v80 & 0xF;
            do
            {
              v100 = v59;
              CColLine::CColLine(&v109, v103, v106);
              v101 = 0;
              if ( v100 > 0 )
                v101 = v100;
              if ( v101 >= 119 )
                v101 = 119;
              CWorld::ProcessLineOfSightSector(
                &CWorld::ms_aSectors[120 * v101 + v92],
                &CWorld::ms_aRepeatSectors[v94 & 0xF0 | v99],
                &v109,
                v108,
                fCollisionRatio,
                v107,
                bCheckBuildings,
                bCheckVehicles,
                bCheckPeds,
                bCheckObjects,
                bCheckDummies,
                bSeeThroughStuff,
                bIgnoreSomeObjectsForCamera,
                bShootThroughStuff);
              v94 -= 16;
              v59 = v100 - 1;
            }
            while ( v100 > v105 );
          }
          else
          {
            do
            {
              v95 = v59;
              CColLine::CColLine(&v109, v103, v106);
              v96 = 0;
              if ( v95 > 0 )
                v96 = v95;
              if ( v96 >= 119 )
                v96 = 119;
              CWorld::ProcessLineOfSightSector(
                &CWorld::ms_aSectors[120 * v96 + v92],
                &CWorld::ms_aRepeatSectors[v94 & 0xF0 | v93],
                &v109,
                v108,
                fCollisionRatio,
                v107,
                bCheckBuildings,
                bCheckVehicles,
                bCheckPeds,
                bCheckObjects,
                bCheckDummies,
                bSeeThroughStuff,
                bIgnoreSomeObjectsForCamera,
                bShootThroughStuff);
              v94 += 16;
              v59 = v95 + 1;
            }
            while ( v95 < v105 );
          }
        }
        else
        {
          v46 = floorf((float)((float)(y + (float)(v45 * (float)((float)((float)(v25 - 59) * 50.0) - x))) / 50.0) + 60.0);
          v47 = 0;
          if ( v25 > 0 )
            v47 = v25;
          v48 = (int)v46;
          v49 = v25 & 0xF;
          if ( v47 >= 119 )
            v47 = 119;
          v50 = 16 * v28;
          if ( v48 <= v28 )
          {
            do
            {
              CColLine::CColLine(&v109, v103, vecEnd);
              v60 = 0;
              if ( v28 > 0 )
                v60 = v28;
              if ( v60 >= 119 )
                v60 = 119;
              CWorld::ProcessLineOfSightSector(
                &CWorld::ms_aSectors[120 * v60 + v47],
                &CWorld::ms_aRepeatSectors[v50 & 0xF0 | v49],
                &v109,
                colPoint,
                fCollisionRatio,
                v107,
                bCheckBuildings,
                bCheckVehicles,
                bCheckPeds,
                bCheckObjects,
                bCheckDummies,
                bSeeThroughStuff,
                bIgnoreSomeObjectsForCamera,
                bShootThroughStuff);
              v52 = v48;
              v50 -= 16;
              v38 = v28-- <= v48;
            }
            while ( !v38 );
          }
          else
          {
            do
            {
              CColLine::CColLine(&v109, v103, vecEnd);
              v51 = 0;
              if ( v28 > 0 )
                v51 = v28;
              if ( v51 >= 119 )
                v51 = 119;
              CWorld::ProcessLineOfSightSector(
                &CWorld::ms_aSectors[120 * v51 + v47],
                &CWorld::ms_aRepeatSectors[v50 & 0xF0 | v49],
                &v109,
                colPoint,
                fCollisionRatio,
                v107,
                bCheckBuildings,
                bCheckVehicles,
                bCheckPeds,
                bCheckObjects,
                bCheckDummies,
                bSeeThroughStuff,
                bIgnoreSomeObjectsForCamera,
                bShootThroughStuff);
              v52 = v48;
              v50 += 16;
              v38 = v28++ < v48;
            }
            while ( v38 );
          }
          v61 = v25;
          v62 = v104;
          v63 = v25 + 1;
          if ( v25 + 1 < v104 )
          {
            do
            {
              v64 = v63;
              v65 = v52;
              v66 = floorf(
                      (float)((float)(v103->y + (float)(v45 * (float)((float)((float)(v61 - 58) * 50.0) - v103->x)))
                            / 50.0)
                    + 60.0);
              v67 = 0;
              v68 = v64 & 0xF;
              if ( v64 > 0 )
                v67 = v64;
              v69 = (int)v66;
              if ( v67 >= 119 )
                v67 = 119;
              v102 = v64;
              v70 = 16 * v65;
              if ( v65 >= v69 )
              {
                do
                {
                  CColLine::CColLine(&v109, v103, v106);
                  v72 = 0;
                  if ( v65 > 0 )
                    v72 = v65;
                  if ( v72 >= 119 )
                    v72 = 119;
                  CWorld::ProcessLineOfSightSector(
                    &CWorld::ms_aSectors[120 * v72 + v67],
                    &CWorld::ms_aRepeatSectors[v70 & 0xF0 | v68],
                    &v109,
                    v108,
                    fCollisionRatio,
                    v107,
                    bCheckBuildings,
                    bCheckVehicles,
                    bCheckPeds,
                    bCheckObjects,
                    bCheckDummies,
                    bSeeThroughStuff,
                    bIgnoreSomeObjectsForCamera,
                    bShootThroughStuff);
                  v70 -= 16;
                  v52 = v69;
                  v38 = v65-- <= v69;
                }
                while ( !v38 );
              }
              else
              {
                do
                {
                  CColLine::CColLine(&v109, v103, v106);
                  v71 = 0;
                  if ( v65 > 0 )
                    v71 = v65;
                  if ( v71 >= 119 )
                    v71 = 119;
                  CWorld::ProcessLineOfSightSector(
                    &CWorld::ms_aSectors[120 * v71 + v67],
                    &CWorld::ms_aRepeatSectors[v70 & 0xF0 | v68],
                    &v109,
                    v108,
                    fCollisionRatio,
                    v107,
                    bCheckBuildings,
                    bCheckVehicles,
                    bCheckPeds,
                    bCheckObjects,
                    bCheckDummies,
                    bSeeThroughStuff,
                    bIgnoreSomeObjectsForCamera,
                    bShootThroughStuff);
                  v70 += 16;
                  v52 = v69;
                  v38 = v65++ < v69;
                }
                while ( v38 );
              }
              v61 = v102;
              v62 = v104;
              v63 = v102 + 1;
            }
            while ( v102 + 1 != v104 );
          }
          v73 = 0;
          if ( v62 > 0 )
            v73 = v62;
          v74 = v62 & 0xF;
          if ( v73 >= 119 )
            v73 = 119;
          v75 = 16 * v52;
          if ( v52 >= v105 )
          {
            do
            {
              v97 = v52;
              CColLine::CColLine(&v109, v103, v106);
              v98 = 0;
              if ( v97 > 0 )
                v98 = v97;
              if ( v98 >= 119 )
                v98 = 119;
              CWorld::ProcessLineOfSightSector(
                &CWorld::ms_aSectors[120 * v98 + v73],
                &CWorld::ms_aRepeatSectors[v75 & 0xF0 | v74],
                &v109,
                v108,
                fCollisionRatio,
                v107,
                bCheckBuildings,
                bCheckVehicles,
                bCheckPeds,
                bCheckObjects,
                bCheckDummies,
                bSeeThroughStuff,
                bIgnoreSomeObjectsForCamera,
                bShootThroughStuff);
              v75 -= 16;
              v52 = v97 - 1;
            }
            while ( v97 > v105 );
          }
          else
          {
            do
            {
              v76 = v52;
              CColLine::CColLine(&v109, v103, v106);
              v77 = 0;
              if ( v76 > 0 )
                v77 = v76;
              if ( v77 >= 119 )
                v77 = 119;
              CWorld::ProcessLineOfSightSector(
                &CWorld::ms_aSectors[120 * v77 + v73],
                &CWorld::ms_aRepeatSectors[v75 & 0xF0 | v74],
                &v109,
                v108,
                fCollisionRatio,
                v107,
                bCheckBuildings,
                bCheckVehicles,
                bCheckPeds,
                bCheckObjects,
                bCheckDummies,
                bSeeThroughStuff,
                bIgnoreSomeObjectsForCamera,
                bShootThroughStuff);
              v75 += 16;
              v52 = v76 + 1;
            }
            while ( v76 < v105 );
          }
        }
      }
    }
    return fCollisionRatio[0] < 1.0;
  }
}

//----- (004259FC) --------------------------------------------------------
int __fastcall CWorld::ProcessLineOfSightSector(
        CSector *sector,
        CRepeatSector *rsector,
        const CColLine *line,
        CColPoint *colPoint,
        float *fCollisionRatio,
        CEntity **refEntityPtr,
        int bCheckBuildings,
        int bCheckVehicles,
        int bCheckPeds,
        int bCheckObjects,
        int bCheckDummies,
        int bSeeThroughStuff,
        int bIgnoreSomeObjectsForCamera,
        int bShootThroughStuff)
{
  float v16; // r5
  int v17; // r6
  int v18; // r4
  bool v19; // zf
  bool8 v20; // r9
  float v21; // s16
  bool8 v22; // r8
  int v23; // r0
  float v27[11]; // [sp+1Ch] [bp-2Ch] BYREF

  v16 = *fCollisionRatio;
  v17 = CWorld::bIncludeBikers;
  v18 = CWorld::bIncludeDeadPeds;
  v19 = CWorld::bIncludeBikers == 0;
  CWorld::bIncludeBikers = 0;
  v20 = v17;
  v21 = CWorld::fWeaponSpreadRate;
  v22 = CWorld::bIncludeDeadPeds;
  CWorld::fWeaponSpreadRate = 0.0;
  CWorld::bIncludeDeadPeds = 0;
  v27[0] = v16;
  if ( !v19 )
    v20 = 1;
  if ( v18 )
    v22 = 1;
  if ( bCheckBuildings )
    CWorld::ProcessLineOfSightSectorList(
      &sector->m_buildingPtrListArray,
      line,
      colPoint,
      v27,
      refEntityPtr,
      bSeeThroughStuff,
      0,
      bShootThroughStuff);
  if ( v21 > 0.0 )
    CWorld::fWeaponSpreadRate = v21;
  if ( bCheckVehicles == 1 )
    CWorld::ProcessLineOfSightSectorList(
      (CPtrList *)rsector,
      line,
      colPoint,
      v27,
      refEntityPtr,
      bSeeThroughStuff,
      0,
      bShootThroughStuff);
  v23 = bCheckObjects;
  if ( bCheckPeds == 1 )
  {
    if ( v18 )
      CWorld::bIncludeDeadPeds = 1;
    if ( v17 )
      CWorld::bIncludeBikers = 1;
    CWorld::ProcessLineOfSightSectorList(
      &rsector->m_ptrListArray[1],
      line,
      colPoint,
      v27,
      refEntityPtr,
      bSeeThroughStuff,
      0,
      bShootThroughStuff);
    CWorld::bIncludeDeadPeds = 0;
    v23 = bCheckObjects;
    CWorld::bIncludeBikers = 0;
  }
  if ( v23 == 1 )
    CWorld::ProcessLineOfSightSectorList(
      &rsector->m_ptrListArray[2],
      line,
      colPoint,
      v27,
      refEntityPtr,
      bSeeThroughStuff,
      bIgnoreSomeObjectsForCamera,
      bShootThroughStuff);
  if ( bCheckDummies == 1 )
    CWorld::ProcessLineOfSightSectorList(
      &sector->m_dummyPtrListArray,
      line,
      colPoint,
      v27,
      refEntityPtr,
      bSeeThroughStuff,
      0,
      bShootThroughStuff);
  CWorld::bIncludeBikers = v20;
  CWorld::bIncludeDeadPeds = v22;
  if ( v27[0] >= *fCollisionRatio )
    return 0;
  *fCollisionRatio = v27[0];
  return 1;
}

//----- (00425BA8) --------------------------------------------------------
int __fastcall CWorld::ProcessLineOfSightSectorList(
        CPtrList *list,
        const CColLine *line,
        CColPoint *colPoint,
        float *fCollisionRatio,
        CEntity **refEntityPtr,
        int bSeeThroughStuff,
        int bIgnoreSomeObjectsForCamera,
        int bShootThroughStuff)
{
  float *v8; // r5
  float v9; // r4
  CPtrNode *m_pHead; // r9
  CCollisionData *v11; // r0
  _BOOL4 v12; // r1
  _BOOL4 v13; // r2
  int v14; // r10
  CPtrNode v15; // kr00_8
  int v16; // r0
  bool v17; // zf
  bool v18; // zf
  int v19; // r1
  int v20; // r0
  bool v21; // zf
  CColModel *v22; // r4
  CCollisionData *m_pColData; // r6
  float v24; // s20
  int v25; // r0
  float *v26; // r1
  RwReal v27; // s2
  RwReal v28; // s4
  RwReal v29; // s6
  RwReal v30; // s8
  RwReal v31; // s10
  float v32; // s12
  int v33; // r0
  int v34; // r1
  float *v35; // r2
  const CMatrix *v36; // r1
  RwReal v37; // s2
  RwReal v38; // s4
  RwReal v39; // s6
  RwReal v40; // s8
  RwReal v41; // s10
  float v42; // s12
  int v43; // r0
  int v44; // r1
  float *v45; // r2
  const CMatrix *v46; // r1
  float v47; // s22
  float v48; // s24
  float *v49; // r0
  float v50; // s20
  const CSimpleTransform *v51; // r4
  float v52; // s0
  float v53; // s4
  float *p_x; // r1
  float v55; // s8
  float v56; // s2
  float v57; // s26
  float v58; // s22
  float v59; // s6
  float v60; // s24
  float v61; // s20
  float *v62; // r0
  float v63; // s0
  float32x2_t v64; // d16
  unsigned __int64 v65; // d1
  float v66; // s0
  int v67; // r4
  _BOOL4 v69; // [sp+18h] [bp-198h]
  _BOOL4 v70; // [sp+1Ch] [bp-194h]
  float *v71; // [sp+28h] [bp-188h]
  int v74; // [sp+4Ch] [bp-164h]
  float v75; // [sp+50h] [bp-160h] BYREF
  char v76; // [sp+54h] [bp-15Ch] BYREF
  CCollisionData v77; // [sp+CCh] [bp-E4h] BYREF
  CColModel colModel; // [sp+100h] [bp-B0h] BYREF
  CColPoint p; // [sp+130h] [bp-80h] BYREF
  float v80[21]; // [sp+15Ch] [bp-54h] BYREF

  v8 = fCollisionRatio;
  v9 = *fCollisionRatio;
  v80[0] = *fCollisionRatio;
  m_pHead = list->m_pHead;
  CColModel::CColModel(&colModel);
  CCollisionData::CCollisionData(&v77);
  v74 = 0;
  if ( m_pHead )
  {
    if ( CWorld::bIncludeCarTyres )
    {
      v74 = 0;
      if ( (*((_BYTE *)m_pHead->m_pVoid + 58) & 7) == 2 )
      {
        colModel.m_pColData = v11;
        v77.m_pSphereArray = (CColSphere *)&v76;
        v77.m_nNoOfSpheres = 6;
        v77._anon_0.m_nNoOfLines = 0;
        *(_DWORD *)&v77.m_nNoOfBoxes = 0;
        v74 = 1;
      }
    }
  }
  v12 = 0;
  if ( m_pHead && CWorld::bIncludeDeadPeds )
    v12 = (*((_BYTE *)m_pHead->m_pVoid + 58) & 7) == 3;
  if ( m_pHead && CWorld::bIncludeBikers )
  {
    v71 = v8;
    v13 = (*((_BYTE *)m_pHead->m_pVoid + 58) & 7) == 3;
LABEL_13:
    v69 = v13;
    v70 = v12;
    v14 = v13 || v12;
    while ( 1 )
    {
      v15 = *m_pHead;
      m_pHead = m_pHead->m_pNext;
      v16 = *((unsigned __int16 *)v15.m_pVoid + 24);
      v17 = v16 == CWorld::ms_nCurrentScanCode;
      if ( v16 != CWorld::ms_nCurrentScanCode )
        v17 = CWorld::pIgnoreEntity == v15.m_pVoid;
      if ( v17 )
        goto LABEL_77;
      v18 = v14 == 0;
      if ( !v14 )
        v18 = (*((_DWORD *)v15.m_pVoid + 7) & 1) == 0;
      if ( v18 )
        goto LABEL_77;
      if ( bIgnoreSomeObjectsForCamera == 1 && !CGarages::IsModelIndexADoor(*((__int16 *)v15.m_pVoid + 19)) )
      {
        v19 = *(unsigned __int8 *)(*((_DWORD *)v15.m_pVoid + 89) + 30);
        if ( v19 == 3 )
        {
          if ( gCurCamColVars < 0xAu )
            goto LABEL_77;
        }
        else if ( v19 != 2 && (v19 != 1 || gCurCamColVars >= 0xAu) )
        {
          goto LABEL_77;
        }
      }
      *((_WORD *)v15.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
      v75 = v80[0];
      v20 = *((_DWORD *)v15.m_pVoid + 7) & 1;
      if ( (*((_BYTE *)v15.m_pVoid + 58) & 7) == 3 )
        break;
      if ( v20 )
      {
        v22 = CEntity::GetColModel((CEntity *)v15.m_pVoid);
LABEL_36:
        m_pColData = v22->m_pColData;
        if ( m_pColData )
        {
          v24 = 0.0;
          if ( CWorld::fWeaponSpreadRate > 0.0 )
          {
            v25 = *((_DWORD *)v15.m_pVoid + 5);
            v26 = (float *)(v25 + 48);
            if ( !v25 )
              v26 = (float *)((char *)v15.m_pVoid + 4);
            v24 = CWorld::fWeaponSpreadRate
                * sqrtf(
                    (float)((float)((float)(*v26 - line->m_vecStart.x) * (float)(*v26 - line->m_vecStart.x))
                          + (float)((float)(v26[1] - line->m_vecStart.y) * (float)(v26[1] - line->m_vecStart.y)))
                  + (float)((float)(v26[2] - line->m_vecStart.z) * (float)(v26[2] - line->m_vecStart.z)));
            v27 = v22->m_boxBound.m_vecMin.y - v24;
            v28 = v22->m_boxBound.m_vecMin.z - v24;
            v29 = v24 + v22->m_boxBound.m_vecMax.x;
            v30 = v24 + v22->m_boxBound.m_vecMax.y;
            v31 = v24 + v22->m_boxBound.m_vecMax.z;
            v32 = v24 + v22->m_sphereBound.m_fRadius;
            v22->m_boxBound.m_vecMin.x = v22->m_boxBound.m_vecMin.x - v24;
            v22->m_boxBound.m_vecMin.y = v27;
            v22->m_boxBound.m_vecMin.z = v28;
            v22->m_boxBound.m_vecMax.x = v29;
            v22->m_boxBound.m_vecMax.y = v30;
            v22->m_boxBound.m_vecMax.z = v31;
            v22->m_sphereBound.m_fRadius = v32;
            if ( m_pColData->m_nNoOfSpheres >= 1 )
            {
              v33 = 0;
              v34 = 12;
              do
              {
                ++v33;
                v35 = (float *)((char *)&m_pColData->m_pSphereArray->m_vecCentre.x + v34);
                v34 += 20;
                *v35 = v24 + *v35;
              }
              while ( v33 < m_pColData->m_nNoOfSpheres );
            }
          }
          v36 = (const CMatrix *)*((_DWORD *)v15.m_pVoid + 5);
          if ( !v36 )
          {
            CPlaceable::AllocateMatrix((CPlaceable *)v15.m_pVoid);
            CSimpleTransform::UpdateMatrix(
              (const CSimpleTransform *)((char *)v15.m_pVoid + 4),
              *((CMatrix **)v15.m_pVoid + 5));
            v36 = (const CMatrix *)*((_DWORD *)v15.m_pVoid + 5);
          }
          if ( CCollision::ProcessLineOfSight(line, v36, v22, colPoint, v80, bSeeThroughStuff, bShootThroughStuff) == 1 )
          {
            *refEntityPtr = (CEntity *)v15.m_pVoid;
            CWorld::ms_iProcessLineNumCrossings += CCollision::ms_iProcessLineNumCrossings;
          }
          if ( v24 > 0.0 )
          {
            v37 = v24 + v22->m_boxBound.m_vecMin.y;
            v38 = v24 + v22->m_boxBound.m_vecMin.z;
            v39 = v22->m_boxBound.m_vecMax.x - v24;
            v40 = v22->m_boxBound.m_vecMax.y - v24;
            v41 = v22->m_boxBound.m_vecMax.z - v24;
            v42 = v22->m_sphereBound.m_fRadius - v24;
            v22->m_boxBound.m_vecMin.x = v24 + v22->m_boxBound.m_vecMin.x;
            v22->m_boxBound.m_vecMin.y = v37;
            v22->m_boxBound.m_vecMin.z = v38;
            v22->m_boxBound.m_vecMax.x = v39;
            v22->m_boxBound.m_vecMax.y = v40;
            v22->m_boxBound.m_vecMax.z = v41;
            v22->m_sphereBound.m_fRadius = v42;
            if ( m_pColData->m_nNoOfSpheres >= 1 )
            {
              v43 = 0;
              v44 = 12;
              do
              {
                ++v43;
                v45 = (float *)((char *)&m_pColData->m_pSphereArray->m_vecCentre.x + v44);
                v44 += 20;
                *v45 = *v45 - v24;
              }
              while ( v43 < m_pColData->m_nNoOfSpheres );
            }
          }
        }
      }
LABEL_56:
      if ( v74 != 1
        || (*(int (__fastcall **)(void *, CColModel *))(*(_DWORD *)v15.m_pVoid + 176))(v15.m_pVoid, &colModel) != 1 )
      {
        goto LABEL_77;
      }
      v46 = (const CMatrix *)*((_DWORD *)v15.m_pVoid + 5);
      if ( !v46 )
      {
        CPlaceable::AllocateMatrix((CPlaceable *)v15.m_pVoid);
        CSimpleTransform::UpdateMatrix(
          (const CSimpleTransform *)((char *)v15.m_pVoid + 4),
          *((CMatrix **)v15.m_pVoid + 5));
        v46 = (const CMatrix *)*((_DWORD *)v15.m_pVoid + 5);
      }
      if ( CCollision::ProcessLineOfSight(line, v46, &colModel, &p, &v75, 0, bShootThroughStuff) != 1 )
        goto LABEL_77;
      CWorld::ms_iProcessLineNumCrossings += CCollision::ms_iProcessLineNumCrossings;
      if ( v75 >= v80[0] )
      {
        v47 = line->m_vecEnd.x - line->m_vecStart.x;
        v48 = line->m_vecEnd.y - line->m_vecStart.y;
        v49 = (float *)*((_DWORD *)v15.m_pVoid + 5);
        v50 = line->m_vecEnd.z - line->m_vecStart.z;
        if ( v49 )
        {
          v51 = (const CSimpleTransform *)((char *)v15.m_pVoid + 4);
        }
        else
        {
          CPlaceable::AllocateMatrix((CPlaceable *)v15.m_pVoid);
          v51 = (const CSimpleTransform *)((char *)v15.m_pVoid + 4);
          CSimpleTransform::UpdateMatrix(
            (const CSimpleTransform *)((char *)v15.m_pVoid + 4),
            *((CMatrix **)v15.m_pVoid + 5));
          v49 = (float *)*((_DWORD *)v15.m_pVoid + 5);
        }
        v52 = *v49;
        v53 = v49[1];
        p_x = &v51->m_translate.x;
        v55 = v47 * *v49;
        v56 = v49[2];
        if ( v49 )
          p_x = v49 + 12;
        v57 = p.m_vecPosition.y - p_x[1];
        v58 = p.m_vecPosition.z - p_x[2];
        v59 = v55 + (float)(v48 * v53);
        v60 = p.m_vecPosition.x - *p_x;
        v61 = v59 + (float)(v50 * v56);
        if ( !v49 )
        {
          CPlaceable::AllocateMatrix((CPlaceable *)v15.m_pVoid);
          CSimpleTransform::UpdateMatrix(v51, *((CMatrix **)v15.m_pVoid + 5));
          v62 = (float *)*((_DWORD *)v15.m_pVoid + 5);
          v52 = *v62;
          v53 = v62[1];
          v56 = v62[2];
        }
        v63 = (float)((float)(v60 * v52) + (float)(v57 * v53)) + (float)(v58 * v56);
        if ( (v61 >= 0.0 || v63 <= 0.0) && (v61 <= 0.0 || v63 >= 0.0) )
          goto LABEL_77;
        v64.n64_u64[0] = vsub_f32(*(float32x2_t *)&line->m_vecEnd.y, *(float32x2_t *)&line->m_vecStart.y).n64_u64[0];
        v65 = vmul_f32(v64, v64).n64_u64[0];
        if ( (float)(fabsf(v61)
                   / sqrtf(
                       (float)((float)((float)(line->m_vecEnd.x - line->m_vecStart.x)
                                     * (float)(line->m_vecEnd.x - line->m_vecStart.x))
                             + *(float *)&v65)
                     + *((float *)&v65 + 1))) <= 0.5 )
          goto LABEL_77;
        v80[0] = v75;
      }
      else
      {
        v80[0] = v75;
      }
      CColPoint::operator=(colPoint, &p);
      *refEntityPtr = (CEntity *)v15.m_pVoid;
LABEL_77:
      if ( !m_pHead )
      {
        v8 = v71;
        v66 = v80[0];
        goto LABEL_79;
      }
    }
    v21 = v20 == 0;
    if ( !v20 )
      v21 = *((_DWORD *)v15.m_pVoid + 64) == 0;
    if ( v21
      && (!v70 || CPed::IsAlive((const CPed *)v15.m_pVoid))
      && (!v69 || (*((_BYTE *)v15.m_pVoid + 1170) & 0x10) == 0) )
    {
      goto LABEL_56;
    }
    v22 = CPedModelInfo::AnimatePedColModelSkinned(
            (CPedModelInfo *)CModelInfo::ms_modelInfoPtrs[*((__int16 *)v15.m_pVoid + 19)],
            *((RpClump_0 **)v15.m_pVoid + 6));
    if ( !v22 )
      goto LABEL_56;
    goto LABEL_36;
  }
  if ( m_pHead )
  {
    v13 = 0;
    v71 = v8;
    goto LABEL_13;
  }
  v66 = v9;
LABEL_79:
  v67 = 0;
  colModel.m_pColData = 0;
  if ( v66 < *v8 )
  {
    *v8 = v66;
    v67 = 1;
  }
  CColModel::~CColModel(&colModel);
  return v67;
}
// 425BFC: variable 'v11' is possibly undefined
// 425BA8: using guessed type float var_54[21];

//----- (00426194) --------------------------------------------------------
bool __fastcall CWorld::CameraToIgnoreThisObject(CEntity *pObject)
{
  _BOOL4 IsModelIndexADoor; // r1
  bool result; // r0
  int v4; // r2

  IsModelIndexADoor = CGarages::IsModelIndexADoor(pObject->m_nModelIndex);
  result = 0;
  if ( !IsModelIndexADoor )
  {
    v4 = *(unsigned __int8 *)(*(_DWORD *)&pObject[5].numLodChildren + 30);
    if ( gCurCamColVars < 0xAu )
      result = 1;
    if ( v4 != 3 )
      return v4 != 2 && (v4 != 1 || gCurCamColVars > 9u);
  }
  return result;
}

//----- (004261E0) --------------------------------------------------------
bool __fastcall CWorld::ProcessVerticalLine(
        const CVector *vecStart,
        float zEnd,
        CColPoint *colPoint,
        CEntity **refEntityPtr,
        int bCheckBuildings,
        int bCheckVehicles,
        int bCheckPeds,
        int bCheckObjects,
        int bCheckDummies,
        int bSeeThroughStuff,
        CStoredCollPoly *pStoredPoly)
{
  uint16 v15; // r0
  int v16; // r6
  float x; // s18
  float y; // s20
  float v19; // r4
  int v20; // s2
  int v21; // r0
  CVector vecEnd; // [sp+24h] [bp-64h] BYREF
  CColLine v24; // [sp+30h] [bp-58h] BYREF

  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v15 = 1;
  }
  else
  {
    v15 = CWorld::ms_nCurrentScanCode + 1;
  }
  v16 = 0;
  CWorld::ms_iProcessLineNumCrossings = 0;
  CWorld::ms_nCurrentScanCode = v15;
  x = vecStart->x;
  vecEnd.y = vecStart->y;
  y = vecEnd.y;
  vecEnd.x = x;
  vecEnd.z = zEnd;
  CColLine::CColLine(&v24, vecStart, &vecEnd);
  v19 = floorf((float)(x / 50.0) + 60.0);
  v20 = (int)floorf((float)(y / 50.0) + 60.0);
  v21 = (int)v19;
  if ( (int)v19 <= 0 )
    v21 = 0;
  if ( v21 >= 119 )
    v21 = 119;
  if ( v20 > 0 )
    v16 = v20;
  if ( v16 >= 119 )
    v16 = 119;
  return CWorld::ProcessVerticalLineSector(
           &CWorld::ms_aSectors[120 * v16 + v21],
           &CWorld::ms_aRepeatSectors[(int)v19 & 0xF | (16 * (v20 & 0xF))],
           &v24,
           colPoint,
           refEntityPtr,
           bCheckBuildings,
           bCheckVehicles,
           bCheckPeds,
           bCheckObjects,
           bCheckDummies,
           bSeeThroughStuff,
           pStoredPoly);
}

//----- (00426320) --------------------------------------------------------
bool __fastcall CWorld::ProcessVerticalLineSector(
        CSector *sector,
        CRepeatSector *rsector,
        const CColLine *Line,
        CColPoint *colPoint,
        CEntity **refEntityPtr,
        int bCheckBuildings,
        int bCheckVehicles,
        int bCheckPeds,
        int bCheckObjects,
        int bCheckDummies,
        int bSeeThroughStuff,
        CStoredCollPoly *pStoredPoly)
{
  float fCollisionRatio[8]; // [sp+10h] [bp-20h] BYREF

  fCollisionRatio[0] = 1.0;
  if ( bCheckBuildings == 1 )
    CWorld::ProcessVerticalLineSectorList(
      &sector->m_buildingPtrListArray,
      Line,
      colPoint,
      fCollisionRatio,
      refEntityPtr,
      bSeeThroughStuff,
      pStoredPoly);
  if ( bCheckVehicles == 1 )
    CWorld::ProcessVerticalLineSectorList(
      (CPtrList *)rsector,
      Line,
      colPoint,
      fCollisionRatio,
      refEntityPtr,
      bSeeThroughStuff,
      pStoredPoly);
  if ( bCheckPeds == 1 )
    CWorld::ProcessVerticalLineSectorList(
      &rsector->m_ptrListArray[1],
      Line,
      colPoint,
      fCollisionRatio,
      refEntityPtr,
      bSeeThroughStuff,
      pStoredPoly);
  if ( bCheckObjects == 1 )
    CWorld::ProcessVerticalLineSectorList(
      &rsector->m_ptrListArray[2],
      Line,
      colPoint,
      fCollisionRatio,
      refEntityPtr,
      bSeeThroughStuff,
      pStoredPoly);
  if ( bCheckDummies == 1 )
    CWorld::ProcessVerticalLineSectorList(
      &sector->m_dummyPtrListArray,
      Line,
      colPoint,
      fCollisionRatio,
      refEntityPtr,
      bSeeThroughStuff,
      pStoredPoly);
  return fCollisionRatio[0] < 1.0;
}

//----- (00426404) --------------------------------------------------------
int __fastcall CWorld::ProcessVerticalLine_FillGlobeColPoints(
        const CVector *vecStart,
        float zEnd,
        CEntity **refEntityPtr,
        int bCheckBuildings,
        int bCheckVehicles,
        int bCheckPeds,
        int bCheckObjects,
        int bCheckDummies,
        bool bSeeThroughStuff,
        CStoredCollPoly *pStoredPoly)
{
  uint16 v14; // r0
  int v15; // r11
  float x; // s18
  float y; // s20
  RwReal v18; // r0
  float v19; // r4
  int v20; // s2
  int v21; // r0
  CVector vecEnd; // [sp+1Ch] [bp-64h] BYREF
  CColLine v24; // [sp+28h] [bp-58h] BYREF

  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v14 = 1;
  }
  else
  {
    v14 = CWorld::ms_nCurrentScanCode + 1;
  }
  v15 = 0;
  CWorld::ms_nCurrentScanCode = v14;
  x = vecStart->x;
  y = vecStart->y;
  FilledColPointIndex = 0;
  v18 = vecStart->x;
  vecEnd.y = y;
  vecEnd.x = v18;
  vecEnd.z = zEnd;
  CColLine::CColLine(&v24, vecStart, &vecEnd);
  v19 = floorf((float)(x / 50.0) + 60.0);
  v20 = (int)floorf((float)(y / 50.0) + 60.0);
  v21 = (int)v19;
  if ( (int)v19 <= 0 )
    v21 = 0;
  if ( v21 >= 119 )
    v21 = 119;
  if ( v20 > 0 )
    v15 = v20;
  if ( v15 >= 119 )
    v15 = 119;
  return CWorld::ProcessVerticalLineSector_FillGlobeColPoints(
           &CWorld::ms_aSectors[120 * v15 + v21],
           &CWorld::ms_aRepeatSectors[(int)v19 & 0xF | (16 * (v20 & 0xF))],
           &v24,
           refEntityPtr,
           bCheckBuildings,
           bCheckVehicles,
           bCheckPeds,
           bCheckObjects,
           bCheckDummies,
           bSeeThroughStuff,
           pStoredPoly);
}

//----- (00426544) --------------------------------------------------------
int __fastcall CWorld::ProcessVerticalLineSector_FillGlobeColPoints(
        CSector *sector,
        CRepeatSector *rsector,
        const CColLine *Line,
        CEntity **refEntityPtr,
        int bCheckBuildings,
        int bCheckVehicles,
        int bCheckPeds,
        int bCheckObjects,
        int bCheckDummies,
        bool bSeeThroughStuff,
        CStoredCollPoly *pStoredPoly)
{
  int v14; // r5
  CStoredCollPoly *v16; // [sp+0h] [bp-20h]

  v14 = bCheckBuildings == 1
     && CWorld::ProcessVerticalLineSectorList_FillGlobeColPoints(
          &sector->m_buildingPtrListArray,
          Line,
          (CEntity **)Line,
          bSeeThroughStuff,
          v16);
  if ( bCheckVehicles == 1 )
    v14 |= CWorld::ProcessVerticalLineSectorList_FillGlobeColPoints(
             (CPtrList *)rsector,
             Line,
             (CEntity **)Line,
             bSeeThroughStuff,
             v16);
  if ( bCheckPeds == 1 )
    v14 |= CWorld::ProcessVerticalLineSectorList_FillGlobeColPoints(
             &rsector->m_ptrListArray[1],
             Line,
             (CEntity **)Line,
             bSeeThroughStuff,
             v16);
  if ( bCheckObjects == 1 )
    v14 |= CWorld::ProcessVerticalLineSectorList_FillGlobeColPoints(
             &rsector->m_ptrListArray[2],
             Line,
             (CEntity **)Line,
             bSeeThroughStuff,
             v16);
  if ( bCheckDummies == 1 )
    return CWorld::ProcessVerticalLineSectorList_FillGlobeColPoints(
             &sector->m_dummyPtrListArray,
             Line,
             (CEntity **)Line,
             bSeeThroughStuff,
             v16) | v14;
  else
    return v14;
}
// 426566: variable 'v16' is possibly undefined
// 426580: variable 'Line' is possibly undefined
// 426544: using guessed type _DWORD bCheckVehicles;

//----- (004265D4) --------------------------------------------------------
bool __fastcall CWorld::ProcessVerticalLineSectorList_FillGlobeColPoints(
        CPtrList *list,
        const CColLine *Line,
        CEntity **refEntityPtr,
        bool bSeeThroughStuff,
        CStoredCollPoly *pStoredPoly)
{
  CPtrNode *m_pHead; // r11
  __int64 v7; // d17
  __int64 v8; // d18
  __int64 v9; // d19
  void (__fastcall *v10)(int, int, int, int, int, int, int, int, int); // r0
  CEntity *m_pVoid; // r4
  float v12; // s16
  int v13; // r8
  float v14; // s18
  const CMatrix *m_pMat; // r6
  CColModel *ColModel; // r0
  int v17; // r0
  float v18; // s0
  __int64 v19; // d17
  __int64 v20; // d18
  __int64 v21; // d19
  CPtrNode v22; // kr00_8
  bool v23; // zf
  int v25; // [sp+2Ch] [bp-84h]
  CColLine v26; // [sp+30h] [bp-80h] BYREF
  CColPoint colPoint; // [sp+50h] [bp-60h] BYREF
  float fCollisionRatio[13]; // [sp+7Ch] [bp-34h] BYREF

  v25 = bSeeThroughStuff;
  fCollisionRatio[0] = 1.0;
  m_pHead = list->m_pHead;
  v7 = *(_QWORD *)&Line->m_vecStart.z;
  v8 = *(_QWORD *)&Line->m_vecEnd.x;
  v9 = *(_QWORD *)&Line->m_vecEnd.z;
  *(_QWORD *)&v26.m_vecStart.x = *(_QWORD *)&Line->m_vecStart.x;
  *(_QWORD *)&v26.m_vecStart.z = v7;
  *(_QWORD *)&v26.m_vecEnd.x = v8;
  *(_QWORD *)&v26.m_vecEnd.z = v9;
  if ( m_pHead )
  {
    v10 = sub_4267B0;
    m_pVoid = 0;
    v12 = v26.m_vecEnd.z - *(float *)&v7;
    v13 = 0;
    if ( (float)(v26.m_vecEnd.z - *(float *)&v7) < 0.0 )
      v10 = (void (__fastcall *)(int, int, int, int, int, int, int, int, int))&loc_4267B4;
    v14 = *(float *)v10;
    do
    {
      if ( !(v13 << 31) )
      {
        v19 = *(_QWORD *)&Line->m_vecStart.z;
        v20 = *(_QWORD *)&Line->m_vecEnd.x;
        v21 = *(_QWORD *)&Line->m_vecEnd.z;
        v22 = *m_pHead;
        m_pHead = m_pHead->m_pNext;
        m_pVoid = (CEntity *)v22.m_pVoid;
        *(_QWORD *)&v26.m_vecStart.x = *(_QWORD *)&Line->m_vecStart.x;
        *(_QWORD *)&v26.m_vecStart.z = v19;
        *(_QWORD *)&v26.m_vecEnd.x = v20;
        *(_QWORD *)&v26.m_vecEnd.z = v21;
      }
      if ( m_pVoid->m_nScanCode == CWorld::ms_nCurrentScanCode || !(*(_BYTE *)&m_pVoid->m_nFlags << 31) )
      {
        v13 = 0;
        goto LABEL_21;
      }
      m_pVoid->m_nScanCode = CWorld::ms_nCurrentScanCode;
      fCollisionRatio[0] = 1.0;
      m_pMat = m_pVoid->m_pMat;
      if ( !m_pMat )
      {
        CPlaceable::AllocateMatrix(m_pVoid);
        CSimpleTransform::UpdateMatrix(&m_pVoid->m_transform, m_pVoid->m_pMat);
        m_pMat = m_pVoid->m_pMat;
      }
      ColModel = CEntity::GetColModel(m_pVoid);
      v13 = 0;
      if ( CCollision::ProcessVerticalLine(&v26, m_pMat, ColModel, &colPoint, fCollisionRatio, v25, 0, 0) != 1 )
        goto LABEL_21;
      v17 = FilledColPointIndex;
      if ( FilledColPointIndex >= 32 )
        goto LABEL_21;
      v26.m_vecStart.z = colPoint.m_vecPosition.z;
      v18 = v26.m_vecEnd.z - colPoint.m_vecPosition.z;
      *(_QWORD *)&v26.m_vecStart.x = *(_QWORD *)&colPoint.m_vecPosition.x;
      if ( v12 >= 0.0 )
      {
        if ( v18 <= 0.0 )
        {
LABEL_14:
          v13 = 0;
          goto LABEL_15;
        }
      }
      else if ( v18 >= 0.0 )
      {
        goto LABEL_14;
      }
      m_pVoid->m_nScanCode = CWorld::ms_nCurrentScanCode - 1;
      CColPoint::operator=(&gaTempSphereColPoints[v17], &colPoint);
      v13 = 1;
      ++FilledColPointIndex;
LABEL_15:
      v26.m_vecStart.z = v14 + v26.m_vecStart.z;
LABEL_21:
      v23 = m_pHead == 0;
      if ( !m_pHead )
        v23 = v13 == 0;
    }
    while ( !v23 );
  }
  return FilledColPointIndex > 0;
}
// 4265D4: using guessed type float var_34[13];

//----- (004267B0) --------------------------------------------------------
void __fastcall sub_4267B0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  __asm { POP             {R2,R3,R6,R7,PC} }
}
// 4267B6: unbalanced stack, ignored a potential tail call

//----- (004267DC) --------------------------------------------------------
int __fastcall CWorld::ProcessVerticalLineSectorList(
        CPtrList *list,
        const CColLine *Line,
        CColPoint *colPoint,
        float *fCollisionRatio,
        CEntity **refEntityPtr,
        int bSeeThroughStuff,
        CStoredCollPoly *pStoredPoly)
{
  int v7; // r11
  CPtrNode *m_pHead; // r5
  CPtrNode v9; // kr00_8
  int v10; // r1
  bool v11; // zf
  const CMatrix *v12; // r4
  CColModel *ColModel; // r0
  float v18[8]; // [sp+20h] [bp-20h] BYREF

  v7 = 0;
  v18[0] = *fCollisionRatio;
  m_pHead = list->m_pHead;
  if ( list->m_pHead )
  {
    do
    {
      while ( 1 )
      {
        v9 = *m_pHead;
        m_pHead = m_pHead->m_pNext;
        v10 = *((unsigned __int16 *)v9.m_pVoid + 24);
        v11 = v10 == CWorld::ms_nCurrentScanCode;
        if ( v10 != CWorld::ms_nCurrentScanCode )
          v11 = *((unsigned __int8 *)v9.m_pVoid + 28) << 31 == 0;
        if ( !v11 && CWorld::pIgnoreEntity != v9.m_pVoid )
        {
          v12 = (const CMatrix *)*((_DWORD *)v9.m_pVoid + 5);
          *((_WORD *)v9.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
          if ( !v12 )
          {
            CPlaceable::AllocateMatrix((CPlaceable *)v9.m_pVoid);
            CSimpleTransform::UpdateMatrix(
              (const CSimpleTransform *)((char *)v9.m_pVoid + 4),
              *((CMatrix **)v9.m_pVoid + 5));
            v12 = (const CMatrix *)*((_DWORD *)v9.m_pVoid + 5);
          }
          ColModel = CEntity::GetColModel((CEntity *)v9.m_pVoid);
          if ( CCollision::ProcessVerticalLine(Line, v12, ColModel, colPoint, v18, bSeeThroughStuff, 0, pStoredPoly) == 1 )
            break;
        }
        if ( !m_pHead )
          goto LABEL_13;
      }
      *refEntityPtr = (CEntity *)v9.m_pVoid;
      CWorld::ms_iProcessLineNumCrossings += CCollision::ms_iProcessLineNumCrossings;
    }
    while ( m_pHead );
LABEL_13:
    if ( v18[0] >= *fCollisionRatio )
    {
      return 0;
    }
    else
    {
      *fCollisionRatio = v18[0];
      return 1;
    }
  }
  return v7;
}
// 4267DC: using guessed type float var_20[8];

//----- (004268C8) --------------------------------------------------------
void __fastcall CWorld::TriggerExplosion(
        const CVector *vecPosition,
        float fEffectRadius,
        float fImpulseMagnitude,
        CEntity *pExplodingEntity,
        CEntity *pExplosionOwner,
        int BlowUpQuick,
        float DamagePercentage)
{
  float x; // s16
  float y; // s18
  float v14; // r9
  float v15; // s2
  float v16; // s18
  float v17; // s20
  int v18; // s2
  int v19; // r3
  int v20; // r2
  int v21; // r9
  CRepeatSector *v22; // r5
  bool v23; // cc
  int v24; // [sp+10h] [bp-60h]
  int v25; // [sp+18h] [bp-58h]

  x = vecPosition->x;
  y = vecPosition->y;
  v14 = floorf((float)((float)(vecPosition->x - fEffectRadius) / 50.0) + 60.0);
  v15 = y + fEffectRadius;
  v16 = floorf((float)((float)(y - fEffectRadius) / 50.0) + 60.0);
  v17 = floorf((float)((float)(x + fEffectRadius) / 50.0) + 60.0);
  v24 = (int)floorf((float)(v15 / 50.0) + 60.0);
  v25 = (int)v16;
  if ( (int)v16 <= v24 )
  {
    v19 = BlowUpQuick;
    v20 = (int)v17;
    v18 = (int)v14;
    do
    {
      if ( v18 <= v20 )
      {
        v21 = v18;
        do
        {
          v22 = &CWorld::ms_aRepeatSectors[v21 & 0xF | (unsigned __int8)(16 * v25)];
          CWorld::TriggerExplosionSectorList(
            (CPtrList *)v22,
            vecPosition,
            fEffectRadius,
            fImpulseMagnitude,
            pExplodingEntity,
            pExplosionOwner,
            v19,
            DamagePercentage);
          CWorld::TriggerExplosionSectorList(
            &v22->m_ptrListArray[1],
            vecPosition,
            fEffectRadius,
            fImpulseMagnitude,
            pExplodingEntity,
            pExplosionOwner,
            BlowUpQuick,
            DamagePercentage);
          CWorld::TriggerExplosionSectorList(
            &v22->m_ptrListArray[2],
            vecPosition,
            fEffectRadius,
            fImpulseMagnitude,
            pExplodingEntity,
            pExplosionOwner,
            BlowUpQuick,
            DamagePercentage);
          v20 = (int)v17;
          v19 = BlowUpQuick;
          v23 = v21++ < (int)v17;
        }
        while ( v23 );
      }
      v23 = v25++ < v24;
    }
    while ( v23 );
  }
}

//----- (00426A3C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CWorld::TriggerExplosionSectorList(
        CPtrList *list,
        const CVector *vecPosition,
        float fEffectRadius,
        float fImpulseMagnitude,
        CEntity *pExplodingEntity,
        CEntity *pExplosionOwner,
        int BlowUpQuick,
        float DamagePercentage)
{
  float32x2_t v8; // d0
  float32x2_t v9; // d2
  float32x2_t v10; // d3
  float32x2_t v11; // d4
  float32x2_t v12; // d5
  float32x2_t v13; // d6
  float v14; // s16
  float32x2_t v15; // d11
  float32x2_t v16; // d14
  float32x2_t v17; // d15
  CPtrNode *m_pHead; // r9
  CEntity *p_m_pedDamageResponse; // r11
  __int64 v24; // d12
  Fx_c *v25; // r5
  CPtrNode v26; // kr00_8
  float *v27; // r8
  int v28; // r0
  float *v29; // r1
  float v30; // s19
  float v31; // s21
  float v32; // s27
  int v33; // r0
  int v34; // r1
  int v35; // r2
  _DWORD *v36; // r5
  int v37; // r0
  __int16 *v38; // r11
  CBaseModelInfo *v39; // r0
  int v40; // r0
  float v41; // s4
  float32x2_t v42; // d1
  float v43; // s2
  char v44; // r0
  int v45; // r1
  CPed *v46; // r0
  int32 v47; // r0
  CColModel *ColModel; // r5
  CColModel *v49; // r0
  const CMatrix *v50; // r1
  float v51; // s2
  float v52; // s21
  float32x2_t v53; // d12
  __int64 v54; // r2
  int v55; // r0
  float32x2_t v56; // d13
  char *v57; // r1
  float v58; // s30
  float32x2_t v59; // d8
  float v60; // s19
  float32x2_t v61; // d16
  float32x2_t v62; // d16
  unsigned __int64 v63; // d1
  float z; // s2
  float v65; // s4
  int v66; // r0
  RwReal v67; // s6
  uint8 LocalDirection; // r1
  int v69; // r0
  uint8 v70; // r5
  const CEventDamage *v71; // r0
  CVector *v72; // r0
  CVector *v73; // r1
  unsigned int *v74; // r6
  float v75; // s0
  float v76; // s2
  int v77; // r0
  bool v78; // zf
  CEntity *v79; // r2
  float v80; // s0
  int v81; // r3
  int v82; // r5
  int v83; // r12
  const CEventDamage *v84; // r0
  eCrimeType v85; // r0
  CVector fImpulse; // [sp+0h] [bp-168h] BYREF
  int v87; // [sp+24h] [bp-144h]
  CEntity *pEntityResponsible; // [sp+28h] [bp-140h]
  Fx_c *v89; // [sp+2Ch] [bp-13Ch]
  unsigned __int64 *p_y; // [sp+40h] [bp-128h]
  CEventDamage v91; // [sp+5Ch] [bp-10Ch] BYREF
  CVector v; // [sp+9Ch] [bp-CCh] BYREF
  CVector v93; // [sp+A8h] [bp-C0h] BYREF
  CVector v94; // [sp+B8h] [bp-B0h] BYREF
  float fDistanceSqr; // [sp+C4h] [bp-A4h] BYREF
  CColBox v96; // [sp+C8h] [bp-A0h] BYREF
  CColSphere v97; // [sp+E4h] [bp-84h] BYREF
  CVector vecNorm; // [sp+F8h] [bp-70h] BYREF
  CVector v99; // 0:r1.12
  CVector v100; // 0:r1.12
  CVector v101; // 0:r1.12

  m_pHead = list->m_pHead;
  if ( list->m_pHead )
  {
    v15.n64_u32[0] = 1.0;
    p_m_pedDamageResponse = (CEntity *)&v91.m_pedDamageResponse;
    p_y = (unsigned __int64 *)&vecPosition->y;
    v16.n64_u32[0] = 1008981770;
    v24 = 0x4396000044AF0000LL;
    v25 = &g_fx;
    do
    {
      while ( 1 )
      {
        v26 = *m_pHead;
        m_pHead = m_pHead->m_pNext;
        v27 = (float *)((char *)v26.m_pVoid + 4);
        v28 = *((_DWORD *)v26.m_pVoid + 5);
        v29 = (float *)((char *)v26.m_pVoid + 4);
        if ( v28 )
          v29 = (float *)(v28 + 48);
        v30 = *v29 - vecPosition->x;
        v31 = v29[1] - vecPosition->y;
        v32 = v29[2] - vecPosition->z;
        v17.n64_f32[0] = sqrtf((float)((float)(v30 * v30) + (float)(v31 * v31)) + (float)(v32 * v32));
        if ( v17.n64_f32[0] < fEffectRadius )
        {
          if ( (*((_BYTE *)v26.m_pVoid + 58) & 7) == 4 )
            CObject::TryToExplode((CObject *)v26.m_pVoid);
          v33 = *((_DWORD *)v26.m_pVoid + 17);
          if ( (v33 & 0x800000) == 0 )
          {
            v34 = *((_BYTE *)v26.m_pVoid + 58) & 7;
            if ( v34 != 3 || !(*((unsigned __int8 *)v26.m_pVoid + 1157) << 31) )
              break;
          }
        }
        if ( !m_pHead )
          return;
      }
      v89 = v25;
      v36 = (char *)v26.m_pVoid + 28;
      v35 = *((_DWORD *)v26.m_pVoid + 7);
      if ( (v35 & 0x40004) != 0 )
      {
        if ( v34 == 4 )
        {
          pEntityResponsible = p_m_pedDamageResponse;
          if ( (v33 & 4) != 0 )
          {
            v38 = (__int16 *)((char *)v26.m_pVoid + 38);
          }
          else
          {
            if ( *(float *)(*((_DWORD *)v26.m_pVoid + 89) + 20) >= fImpulseMagnitude )
            {
              v38 = (__int16 *)((char *)v26.m_pVoid + 38);
              v37 = *((__int16 *)v26.m_pVoid + 19);
              if ( v37 != MI_FENCE && v37 != MI_FENCE2 )
                goto LABEL_25;
            }
            v38 = (__int16 *)((char *)v26.m_pVoid + 38);
            v39 = CModelInfo::ms_modelInfoPtrs[*((__int16 *)v26.m_pVoid + 19)];
            v40 = (*((int (__fastcall **)(CBaseModelInfo *))v39->_vptr$CBaseModelInfo + 2))(v39);
            if ( v40 && (*(_WORD *)(v40 + 40) & 0x7000 | 0x800) == 10240 )
            {
              CGlass::WindowRespondsToExplosion((CEntity *)v26.m_pVoid, *vecPosition);
            }
            else
            {
              (*(void (__fastcall **)(void *, _DWORD))(*(_DWORD *)v26.m_pVoid + 20))(v26.m_pVoid, 0);
              CPhysical::AddToMovingList((CPhysical *)v26.m_pVoid);
              if ( *((__int16 *)v26.m_pVoid + 19) != MI_FIRE_HYDRANT || (*((_BYTE *)v26.m_pVoid + 324) & 0x40) != 0 )
              {
                if ( (*((_BYTE *)v26.m_pVoid + 58) & 7) != 4 || *(_BYTE *)(*((_DWORD *)v26.m_pVoid + 89) + 31) )
                  goto LABEL_25;
              }
              else
              {
                v72 = (CVector *)*((_DWORD *)v26.m_pVoid + 5);
                v73 = (CVector *)((char *)v26.m_pVoid + 4);
                if ( v72 )
                  v73 = v72 + 4;
                Fx_c::TriggerWaterHydrant(v89, v73);
              }
              *((_DWORD *)v26.m_pVoid + 81) |= 0x40u;
            }
          }
LABEL_25:
          if ( *v38 == MI_ATM && FindPlayerPed(-1) == pExplosionOwner )
            *((float *)v26.m_pVoid + 86) = *((float *)v26.m_pVoid + 86) + (float)(v14 * -2.0);
          p_m_pedDamageResponse = pEntityResponsible;
          if ( (*v36 & 0x40004) != 0 )
          {
            v8.n64_f32[0] = (float)((float)(fEffectRadius - v17.n64_f32[0]) + (float)(fEffectRadius - v17.n64_f32[0]))
                          / fEffectRadius;
            v14 = vmin_f32(v8, v15).n64_f32[0];
            CObject::ObjectDamage(
              (CObject *)v26.m_pVoid,
              v14 * *((float *)&v24 + 1),
              0,
              0,
              (int)pExplosionOwner,
              WEAPONTYPE_EXPLOSION);
          }
          goto LABEL_30;
        }
        if ( v35 << 31 )
        {
          (*(void (__fastcall **)(void *, _DWORD))(*(_DWORD *)v26.m_pVoid + 20))(v26.m_pVoid, 0);
          CPhysical::AddToMovingList((CPhysical *)v26.m_pVoid);
        }
      }
LABEL_30:
      if ( (*v36 & 0x40005) != 1 )
        goto LABEL_102;
      v41 = *((float *)v26.m_pVoid + 36);
      v42.n64_u64[0] = vmax_f32(v17, v16).n64_u64[0];
      v13.n64_u32[0] = 0;
      v10.n64_f32[0] = v15.n64_f32[0] / v42.n64_f32[0];
      v42.n64_f32[0] = (float)((float)(fEffectRadius - v17.n64_f32[0]) + (float)(fEffectRadius - v17.n64_f32[0]))
                     / fEffectRadius;
      v8.n64_f32[0] = v31 * v10.n64_f32[0];
      v14 = vmin_f32(v42, v15).n64_f32[0];
      v43 = v30 * v10.n64_f32[0];
      v10.n64_f32[0] = v32 * v10.n64_f32[0];
      v15.n64_u32[0] = v24;
      v10.n64_u64[0] = vmax_f32(v10, v13).n64_u64[0];
      *(float *)&v24 = (float)(v14 * fImpulseMagnitude) * (float)(v41 / *(float *)&v24);
      LODWORD(vecNorm.z) = v10.n64_u32[0];
      LODWORD(vecNorm.y) = v8.n64_u32[0];
      vecNorm.x = v43;
      v44 = *((_BYTE *)v26.m_pVoid + 58);
      v45 = v44 & 7;
      switch ( v45 )
      {
        case 4:
          if ( (*((_BYTE *)v26.m_pVoid + 68) & 0x84) == 0 )
          {
            if ( v10.n64_f32[0] < 0.1 )
            {
              v10.n64_u32[0] = 1045220557;
              vecNorm.z = 0.2;
            }
            v9.n64_f32[0] = v41
                          * (float)((float)((float)(*((float *)v26.m_pVoid + 18) * v43)
                                          + (float)(*((float *)v26.m_pVoid + 19) * v8.n64_f32[0]))
                                  + (float)(*((float *)v26.m_pVoid + 20) * v10.n64_f32[0]));
            if ( v9.n64_f32[0] > (float)(*(float *)&v24 * 4.0) )
            {
              v9.n64_f32[0] = *(float *)&v24 - v9.n64_f32[0];
              v11.n64_u32[0] = 0;
              LODWORD(v24) = vmax_f32(v9, v11).n64_u32[0];
            }
            v100.y = *(float *)&v24 * v8.n64_f32[0];
            vecNorm.y = *(float *)&v24 * v8.n64_f32[0];
            v100.x = *(float *)&v24 * v43;
            vecNorm.x = *(float *)&v24 * v43;
            v100.z = *(float *)&v24 * v10.n64_f32[0];
            vecNorm.z = *(float *)&v24 * v10.n64_f32[0];
            CPhysical::ApplyMoveForce((CPhysical *)v26.m_pVoid, v100);
            v11.n64_u32[0] = 1.0;
            v8.n64_f32[0] = *((float *)v26.m_pVoid + 37) / *((float *)v26.m_pVoid + 36);
            v8.n64_u64[0] = vmin_f32(v8, v11).n64_u64[0];
            v67 = CModelInfo::ms_modelInfoPtrs[*((__int16 *)v26.m_pVoid + 19)]->m_pColModel->m_sphereBound.m_fRadius
                * 0.5;
            vecNorm.x = vecNorm.x * v8.n64_f32[0];
            vecNorm.y = vecNorm.y * v8.n64_f32[0];
            vecNorm.z = v8.n64_f32[0] * vecNorm.z;
            fImpulse.z = v67;
            *(_QWORD *)&fImpulse.x = 0LL;
            CPhysical::ApplyTurnForce((CPhysical *)v26.m_pVoid, vecNorm, fImpulse);
          }
          CObject::ObjectDamage((CObject *)v26.m_pVoid, v14 * 300.0, 0, 0, (int)pExplosionOwner, WEAPONTYPE_EXPLOSION);
          v24 = v15.n64_u32[0] | 0x4396000000000000LL;
          v15.n64_u32[0] = 1.0;
          break;
        case 3:
          *(float *)&v91.m_iAccumulatedTime = -v8.n64_f32[0];
          *(float *)&v91._vptr$CEvent = -v43;
          LocalDirection = CPed::GetLocalDirection((CPed *)v26.m_pVoid, (const CVector2D *)&v91);
          v69 = *((_DWORD *)v26.m_pVoid + 64);
          if ( v69 )
          {
            if ( *(_BYTE *)(v69 + 58) == 42 )
            {
              v70 = LocalDirection;
              CPedDamageResponseCalculator::CPedDamageResponseCalculator(
                (CPedDamageResponseCalculator *)&v96,
                pExplosionOwner,
                1000.0,
                WEAPONTYPE_EXPLOSION,
                PED_SPHERE_CHEST,
                0);
              CEventDamage::CEventDamage(
                &v91,
                pExplosionOwner,
                CTimer::m_snTimeInMilliseconds,
                WEAPONTYPE_EXPLOSION,
                PED_SPHERE_CHEST,
                v70,
                0,
                *((_DWORD *)v26.m_pVoid + 289) & 0x100);
              if ( CEventDamage::AffectsPed(v71, (CPed *)v26.m_pVoid) )
              {
                CPedDamageResponseCalculator::ComputeDamageResponse(
                  (CPedDamageResponseCalculator *)&v96,
                  (CPed *)v26.m_pVoid,
                  (CPedDamageResponse *)p_m_pedDamageResponse,
                  1);
                v24 = v15.n64_u32[0] | 0x4396000000000000LL;
              }
              else
              {
                v24 = v15.n64_u32[0] | 0x4396000000000000LL;
                v91.m_pedDamageResponse.m_bDamageCalculated = 1;
              }
              CEventGroup::Add((CEventGroup *)(*((_DWORD *)v26.m_pVoid + 272) + 104), (CEvent *)&v91, 0);
              CEventDamage::~CEventDamage(&v91);
              CPedDamageResponseCalculator::~CPedDamageResponseCalculator((CPedDamageResponseCalculator *)&v96);
              v15.n64_u32[0] = 1.0;
              v79 = pExplosionOwner;
              if ( pExplosionOwner )
                goto LABEL_97;
              break;
            }
            v24 = v15.n64_u32[0] | 0x4396000000000000LL;
            LOBYTE(v87) = LocalDirection;
            pEntityResponsible = p_m_pedDamageResponse;
            v74 = (unsigned int *)((char *)v26.m_pVoid + 1156);
            v15.n64_u32[0] = 1.0;
          }
          else
          {
            v74 = (unsigned int *)((char *)v26.m_pVoid + 1156);
            v75 = *((float *)v26.m_pVoid + 36);
            LOBYTE(v87) = LocalDirection;
            pEntityResponsible = p_m_pedDamageResponse;
            v12.n64_f32[0] = v75
                           * (float)((float)((float)(*((float *)v26.m_pVoid + 18) * vecNorm.x)
                                           + (float)(*((float *)v26.m_pVoid + 19) * vecNorm.y))
                                   + (float)(*((float *)v26.m_pVoid + 20) * vecNorm.z));
            v11.n64_f32[0] = v75 * 0.25;
            v11.n64_u64[0] = vmin_f32((float32x2_t)v24, v11).n64_u64[0];
            v24 = v15.n64_u32[0] | 0x4396000000000000LL;
            v15.n64_u32[0] = 1.0;
            if ( v12.n64_f32[0] > (float)(v11.n64_f32[0] + v11.n64_f32[0]) )
            {
              v11.n64_f32[0] = v11.n64_f32[0] - v12.n64_f32[0];
              v12.n64_u32[0] = 0;
              v11.n64_u64[0] = vmax_f32(v11, v12).n64_u64[0];
            }
            v76 = v11.n64_f32[0] * vecNorm.z;
            v101.y = v11.n64_f32[0] * vecNorm.y;
            vecNorm.y = v11.n64_f32[0] * vecNorm.y;
            v101.x = v11.n64_f32[0] * vecNorm.x;
            vecNorm.x = v11.n64_f32[0] * vecNorm.x;
            vecNorm.z = v11.n64_f32[0] * vecNorm.z;
            v77 = *((_DWORD *)v26.m_pVoid + 289);
            v78 = (v77 & 1) == 0;
            if ( (v77 & 1) != 0 )
              v78 = *(unsigned __int8 *)v36 << 31 == 0;
            if ( v78 )
            {
              v80 = v76 + (float)((float)(v75 * 0.008) * CTimer::ms_fTimeStep);
              vecNorm.z = v80;
            }
            else
            {
              v80 = v76 + 4.0;
              v81 = *((_DWORD *)v26.m_pVoid + 290);
              v82 = *((_DWORD *)v26.m_pVoid + 291);
              v83 = *((_DWORD *)v26.m_pVoid + 292);
              vecNorm.z = v76 + 4.0;
              *v74 = v77 & 0xFFFFFFFE;
              *((_DWORD *)v26.m_pVoid + 290) = v81;
              *((_DWORD *)v26.m_pVoid + 291) = v82;
              *((_DWORD *)v26.m_pVoid + 292) = v83;
            }
            v101.z = v80;
            CPhysical::ApplyMoveForce((CPhysical *)v26.m_pVoid, v101);
          }
          CPedDamageResponseCalculator::CPedDamageResponseCalculator(
            (CPedDamageResponseCalculator *)&v96,
            pExplosionOwner,
            v14 * 250.0,
            WEAPONTYPE_EXPLOSION,
            PED_SPHERE_CHEST,
            0);
          CEventDamage::CEventDamage(
            &v91,
            pExplosionOwner,
            CTimer::m_snTimeInMilliseconds,
            WEAPONTYPE_EXPLOSION,
            PED_SPHERE_CHEST,
            v87,
            0,
            *v74 & 0x100);
          if ( CEventDamage::AffectsPed(v84, (CPed *)v26.m_pVoid) )
            CPedDamageResponseCalculator::ComputeDamageResponse(
              (CPedDamageResponseCalculator *)&v96,
              (CPed *)v26.m_pVoid,
              (CPedDamageResponse *)pEntityResponsible,
              1);
          else
            v91.m_pedDamageResponse.m_bDamageCalculated = 1;
          CEventGroup::Add((CEventGroup *)(*((_DWORD *)v26.m_pVoid + 272) + 104), (CEvent *)&v91, 0);
          CEventDamage::~CEventDamage(&v91);
          CPedDamageResponseCalculator::~CPedDamageResponseCalculator((CPedDamageResponseCalculator *)&v96);
          p_m_pedDamageResponse = pEntityResponsible;
          v79 = pExplosionOwner;
          if ( pExplosionOwner )
          {
LABEL_97:
            if ( (*(_BYTE *)&v79->m_info & 7) == 3 )
            {
              if ( *((_DWORD *)v26.m_pVoid + 359) == 6 )
                v85 = CRIME_SHOOT_COP;
              else
                v85 = CRIME_SHOOT_PED;
              CCrime::ReportCrime(v85, (CEntity *)v26.m_pVoid, (CPed *)v79);
            }
          }
          break;
        case 2:
          v24 = v15.n64_u32[0] | 0x4396000000000000LL;
          v15.n64_u32[1] = 1045220557;
          if ( *((_DWORD *)v26.m_pVoid + 361) == 10 && *((_DWORD *)v26.m_pVoid + 281) )
          {
            CEventKnockOffBike::CEventKnockOffBike(
              (CEventKnockOffBike *)&v91,
              (CVehicle *)v26.m_pVoid,
              (const CVector *)v26.m_pVoid + 6,
              &vecNorm,
              0.0,
              0.0,
              WEAPONTYPE_EXPLOSION,
              0,
              0,
              0,
              1,
              0);
            CEventGroup::Add(
              (CEventGroup *)(*(_DWORD *)(*((_DWORD *)v26.m_pVoid + 281) + 1088) + 104),
              (CEvent *)&v91,
              0);
            v46 = (CPed *)*((_DWORD *)v26.m_pVoid + 281);
            v96.m_vecMin.x = vecNorm.x;
            v96.m_vecMin.y = vecNorm.y;
            v47 = CPed::GetLocalDirection(v46, (const CVector2D *)&v96);
            CWeapon::GenerateDamageEvent(
              *((CPed **)v26.m_pVoid + 281),
              (CEntity *)v26.m_pVoid,
              WEAPONTYPE_EXPLOSION,
              (int)(float)((float)(v14 * 1100.0) * DamagePercentage),
              PED_SPHERE_CHEST,
              v47);
            CEventKnockOffBike::~CEventKnockOffBike((CEventKnockOffBike *)&v91);
            v44 = *((_BYTE *)v26.m_pVoid + 58);
          }
          if ( (v44 & 0xF8) == 16 )
            CCarCtrl::SwitchVehicleToRealPhysics((CVehicle *)v26.m_pVoid);
          memset(&fImpulse, 0, sizeof(fImpulse));
          CVehicle::InflictDamage(
            (CVehicle *)v26.m_pVoid,
            pExplosionOwner,
            WEAPONTYPE_EXPLOSION,
            (float)(v14 * 1100.0) * DamagePercentage,
            fImpulse);
          if ( BlowUpQuick == 1 && *((_WORD *)v26.m_pVoid + 631) )
            *((_WORD *)v26.m_pVoid + 631) = *((_WORD *)v26.m_pVoid + 631) / 0xAu + 1;
          v96.m_vecMin.y = -v31;
          v96.m_vecMin.x = -v30;
          v96.m_vecMin.z = -v32;
          Multiply3x3((CVector *)&v91, &v96.m_vecMin, *((const CMatrix **)v26.m_pVoid + 5));
          CColSphere::Set(&v97, v17.n64_f32[0], (const CVector *)&v91, 0, 0, 0xFFu);
          ColModel = CEntity::GetColModel((CEntity *)v26.m_pVoid);
          v49 = CEntity::GetColModel((CEntity *)v26.m_pVoid);
          CColBox::Set(&v96, &ColModel->m_boxBound.m_vecMin, &v49->m_boxBound.m_vecMax, 0, 0, 0xFFu);
          memset(&v94, 0, sizeof(v94));
          fDistanceSqr = 100000.0;
          if ( CCollision::ProcessSphereBox(&v97, &v96, (CColPoint *)&v91, &fDistanceSqr) )
          {
            Multiply3x3(&v93, *((const CMatrix **)v26.m_pVoid + 5), (const CVector *)&v91);
            v94 = v93;
            v50 = (const CMatrix *)*((_DWORD *)v26.m_pVoid + 5);
            v.x = -*(float *)&v91.m_pInflictor;
            v.y = -*(float *)&v91.m_nDamageTime;
            v.z = -*(float *)&v91.m_eWeaponUsed;
            Multiply3x3(&v93, v50, &v);
            vecNorm = v93;
            v51 = -0.2;
            if ( v93.z < -0.2 )
              goto LABEL_47;
            if ( v93.z < 0.2 && v93.z > 0.0 )
            {
              v51 = v93.z + 0.2;
LABEL_47:
              vecNorm.z = v51;
            }
            v52 = DamagePercentage;
            v59.n64_u32[0] = LODWORD(v94.x);
            v53.n64_u64[0] = *(unsigned __int64 *)&v94.y;
            v54 = *(_QWORD *)&v94.x;
            v55 = *((_DWORD *)v26.m_pVoid + 5);
            v56.n64_u64[0] = *p_y;
            v57 = (char *)v26.m_pVoid + 4;
            v58 = *((float *)v26.m_pVoid + 36);
            v59.n64_u32[1] = LODWORD(vecPosition->x);
            if ( v55 )
              v57 = (char *)(v55 + 48);
            v16.n64_u64[0] = *(unsigned __int64 *)(v57 + 4);
            v60 = *(float *)v57;
            fImpulse.x = v94.z;
            CPhysical::GetSpeed(&v93, (CPhysical *)v26.m_pVoid, *(CVector *)&v54);
            v61.n64_u64[0] = vadd_f32(v53, v16).n64_u64[0];
            v8.n64_u32[1] = 1045220557;
            v24 = v15.n64_u32[0] | 0x4396000000000000LL;
            v62.n64_u64[0] = vsub_f32(v61, v56).n64_u64[0];
            DamagePercentage = v52;
            v16.n64_u32[0] = 1008981770;
            v8.n64_f32[0] = (float)(v59.n64_f32[0] + v60) - v59.n64_f32[1];
            v59.n64_u32[0] = 1.0;
            v63 = vmul_f32(v62, v62).n64_u64[0];
            v10.n64_f32[0] = v58 / 3000.0;
            v8.n64_f32[0] = sqrtf((float)((float)(v8.n64_f32[0] * v8.n64_f32[0]) + *(float *)&v63) + *((float *)&v63 + 1));
            z = vecNorm.z;
            v10.n64_u64[0] = vmin_f32(v10, v59).n64_u64[0];
            v10.n64_f32[0] = v10.n64_f32[0] * fImpulseMagnitude;
            v11.n64_f32[0] = (float)((float)(fEffectRadius - v8.n64_f32[0]) + (float)(fEffectRadius - v8.n64_f32[0]))
                           / fEffectRadius;
            v8.n64_u32[0] = LODWORD(vecNorm.x);
            v11.n64_u64[0] = vmin_f32(v11, v59).n64_u64[0];
            if ( v26.m_pVoid == pExplodingEntity )
              v11.n64_f32[0] = v11.n64_f32[0] * 0.2;
            v14 = v10.n64_f32[0] * v11.n64_f32[0];
            v10.n64_f32[0] = *((float *)v26.m_pVoid + 36)
                           * (float)((float)((float)(v93.x * vecNorm.x) + (float)(v93.y * vecNorm.y))
                                   + (float)(v93.z * vecNorm.z));
            if ( v10.n64_f32[0] > (float)(v14 * 3.0) )
            {
              v10.n64_f32[0] = v14 - v10.n64_f32[0];
              v11.n64_u32[0] = 0;
              LODWORD(v14) = vmax_f32(v10, v11).n64_u32[0];
            }
            v65 = v14 * vecNorm.y;
            vecNorm.y = v14 * vecNorm.y;
            vecNorm.x = v14 * vecNorm.x;
            vecNorm.z = v14 * vecNorm.z;
            if ( (*((_BYTE *)v26.m_pVoid + 68) & 4) == 0 )
            {
              v99.x = v14 * v8.n64_f32[0];
              v99.y = v65;
              v99.z = v14 * z;
              CPhysical::ApplyForce((CPhysical *)v26.m_pVoid, v99, v94, 1);
            }
          }
          if ( *((_DWORD *)v26.m_pVoid + 361) == 4 )
          {
            v66 = *((_DWORD *)v26.m_pVoid + 5);
            if ( v66 )
              v27 = (float *)(v66 + 48);
            v94.x = *v27 + v94.x;
            v94.y = v27[1] + v94.y;
            v94.z = v27[2] + v94.z;
            v93.x = -*(float *)&v91.m_pInflictor;
            v93.y = -*(float *)&v91.m_nDamageTime;
            v93.z = -*(float *)&v91.m_eWeaponUsed;
            (*(void (__fastcall **)(void *, int, _DWORD, CEntity *, CVector *, CVector *, int))(*(_DWORD *)v26.m_pVoid
                                                                                              + 228))(
              v26.m_pVoid,
              1148846080,
              0,
              pExplosionOwner,
              &v94,
              &v93,
              51);
          }
          v15.n64_u32[0] = 1.0;
          break;
        default:
          v24 = v15.n64_u32[0] | 0x4396000000000000LL;
          v15.n64_u32[0] = 1.0;
          break;
      }
LABEL_102:
      v25 = v89;
    }
    while ( m_pHead );
  }
}
// 426A3C: fragmented variable at r2.8 may be wrong

//----- (00427564) --------------------------------------------------------
void __fastcall CWorld::CastShadow(float xmin, float ymin, float xmax, float ymax)
{
  float v7; // s20
  float v8; // r6
  float v9; // s16
  int v10; // r11
  int v11; // r9
  int v12; // r8
  int v13; // r10
  uint16 v14; // r0
  int v15; // r2
  int v16; // r3
  int v17; // r2
  int v18; // r6
  CPtrNode *m_pHead; // r5
  CPtrNode v20; // kr00_8
  bool v21; // cc

  v7 = floorf((float)(xmin / 50.0) + 60.0);
  v8 = floorf((float)(ymin / 50.0) + 60.0);
  v9 = floorf((float)(xmax / 50.0) + 60.0);
  v10 = 120;
  v11 = 0;
  v12 = (int)floorf((float)(ymax / 50.0) + 60.0);
  v13 = (int)v8;
  if ( v12 >= 120 )
    v12 = 120;
  if ( (int)v9 < 120 )
    v10 = (int)v9;
  if ( v13 <= 0 )
    v13 = 0;
  if ( (int)v7 > 0 )
    v11 = (int)v7;
  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v14 = 1;
  }
  else
  {
    v14 = CWorld::ms_nCurrentScanCode + 1;
  }
  CWorld::ms_nCurrentScanCode = v14;
  if ( v13 <= v12 )
  {
    do
    {
      if ( v11 <= v10 )
      {
        v15 = 119;
        if ( v13 < 119 )
          v15 = v13;
        v16 = v11;
        v17 = 120 * v15;
        do
        {
          v18 = 119;
          if ( v16 < 119 )
            v18 = v16;
          m_pHead = CWorld::ms_aSectors[v18 + v17].m_buildingPtrListArray.m_pHead;
          while ( m_pHead )
          {
            v20 = *m_pHead;
            m_pHead = m_pHead->m_pNext;
            if ( *((unsigned __int16 *)v20.m_pVoid + 24) != v14 )
            {
              if ( *((unsigned __int8 *)v20.m_pVoid + 28) << 31 )
                *((_WORD *)v20.m_pVoid + 24) = v14;
            }
          }
          v21 = v16++ < v10;
        }
        while ( v21 );
      }
      v21 = v13++ < v12;
    }
    while ( v21 );
  }
}

//----- (004276CC) --------------------------------------------------------
void __fastcall CWorld::CastShadowSectorList(CPtrList *list, float xmin, float ymin, float xmax, float ymax)
{
  CPtrNode *m_pHead; // r0
  int v6; // r1
  CPtrNode v7; // kr00_8
  int v8; // r3
  bool v9; // zf

  m_pHead = list->m_pHead;
  if ( m_pHead )
  {
    v6 = CWorld::ms_nCurrentScanCode;
    do
    {
      v7 = *m_pHead;
      m_pHead = m_pHead->m_pNext;
      v8 = *((unsigned __int16 *)v7.m_pVoid + 24);
      v9 = v8 == v6;
      if ( v8 != v6 )
        v9 = *((unsigned __int8 *)v7.m_pVoid + 28) << 31 == 0;
      if ( !v9 )
        *((_WORD *)v7.m_pVoid + 24) = v6;
    }
    while ( m_pHead );
  }
}

//----- (004276F8) --------------------------------------------------------
void CWorld::ProcessForAnimViewer()
{
  __int64 v0; // r4
  int v1; // r0
  int v2; // r1
  const CMatrix *v3; // r0
  RwMatrix *v4; // r1

  HIDWORD(v0) = CWorld::ms_listMovingEntityPtrs;
  while ( HIDWORD(v0) )
  {
    v0 = *(_QWORD *)HIDWORD(v0);
    if ( (*(_BYTE *)(v0 + 29) & 8) == 0 )
    {
      CEntity::UpdateAnim((CEntity *)v0);
      v1 = *(_DWORD *)(v0 + 24);
      if ( v1 )
      {
        v2 = *(_DWORD *)(v1 + 4);
        v3 = *(const CMatrix **)(v0 + 20);
        v4 = (RwMatrix *)(v2 + 16);
        if ( v3 )
          CMatrix::UpdateRwMatrix(v3, v4);
        else
          CSimpleTransform::UpdateRwMatrix((const CSimpleTransform *)(v0 + 4), v4);
      }
      CEntity::UpdateRwFrame((CEntity *)v0);
    }
  }
}

//----- (00427744) --------------------------------------------------------
void CWorld::Process()
{
  __int64 v0; // r4
  CEventGlobalGroup *EventGlobalGroup; // r0
  CEventGlobalGroup *v2; // r0
  CEventGlobalGroup *v3; // r0
  CEventGlobalGroup *v4; // r0
  CEventGlobalGroup *v5; // r0
  CEventGlobalGroup *v6; // r0
  CEventGlobalGroup *v7; // r0
  CEventGlobalGroup *v8; // r0
  CEventGlobalGroup *v9; // r0
  CEventGlobalGroup *v10; // r0
  int i; // r5
  CObject *v12; // r4
  bool v13; // zf
  RwObject_0 *m_pRwObject; // r0
  char *parent; // r1
  const CMatrix *m_pMat; // r0
  RwMatrix *v17; // r1
  CPtrNode *m_pHead; // r4
  CPtrNode v19; // kr00_8
  __int64 v20; // r4
  int v21; // r0
  unsigned int v22; // r0
  int v23; // r0
  __int64 v24; // r4
  int v25; // r0
  __int64 v26; // r4
  __int64 v27; // kr08_8
  CPtrNode *v28; // r6
  CPtrNode v29; // kr10_8
  int v30; // r0
  int v31; // r1
  const CMatrix *v32; // r0
  RwMatrix *v33; // r1
  int v34; // r6
  int v35; // r0
  int v36; // r1
  const CMatrix *v37; // r0
  RwMatrix *v38; // r1
  int v39; // r0
  _QWORD *v40; // r6
  __int64 v41; // r0
  int v42; // r0
  int v43; // r1
  const CMatrix *v44; // r0
  RwMatrix *v45; // r1
  __int64 v46; // r0
  __int64 v47; // r4
  _DWORD *v48; // r6
  int v49; // r0
  int v50; // r1
  const CMatrix *v51; // r0
  RwMatrix *v52; // r1
  __int64 v53; // r0
  CPtrNode *v54; // r5
  CPtrNode v55; // kr18_8
  _DWORD *v56; // r4
  int v57; // r0
  int v58; // r1
  const CMatrix *v59; // r0
  RwMatrix *v60; // r1
  __int64 v61; // r0
  float v62; // r0
  float v63; // s2
  float v64; // s4
  __int64 v65; // r4
  int v66; // r0
  int v67; // r0
  int v68; // r1
  const CMatrix *v69; // r0
  RwMatrix *v70; // r1

  HIDWORD(v0) = CWorld::ms_listMovingEntityPtrs;
  while ( HIDWORD(v0) )
  {
    v0 = *(_QWORD *)HIDWORD(v0);
    if ( (*(_BYTE *)(v0 + 58) & 7) == 3 )
    {
      EventGlobalGroup = GetEventGlobalGroup();
      CEventGlobalGroup::AddEventsToPed(EventGlobalGroup, (CPed *)v0);
    }
  }
  if ( CPedGroups::ms_activeGroups[0] )
  {
    v2 = GetEventGlobalGroup();
    CEventGlobalGroup::AddEventsToGroup(v2, CPedGroups::ms_groups);
  }
  if ( CPedGroups::ms_activeGroups[1] )
  {
    v3 = GetEventGlobalGroup();
    CEventGlobalGroup::AddEventsToGroup(v3, &CPedGroups::ms_groups[1]);
  }
  if ( CPedGroups::ms_activeGroups[2] )
  {
    v4 = GetEventGlobalGroup();
    CEventGlobalGroup::AddEventsToGroup(v4, &CPedGroups::ms_groups[2]);
  }
  if ( CPedGroups::ms_activeGroups[3] )
  {
    v5 = GetEventGlobalGroup();
    CEventGlobalGroup::AddEventsToGroup(v5, &CPedGroups::ms_groups[3]);
  }
  if ( CPedGroups::ms_activeGroups[4] )
  {
    v6 = GetEventGlobalGroup();
    CEventGlobalGroup::AddEventsToGroup(v6, &CPedGroups::ms_groups[4]);
  }
  if ( CPedGroups::ms_activeGroups[5] )
  {
    v7 = GetEventGlobalGroup();
    CEventGlobalGroup::AddEventsToGroup(v7, &CPedGroups::ms_groups[5]);
  }
  if ( CPedGroups::ms_activeGroups[6] )
  {
    v8 = GetEventGlobalGroup();
    CEventGlobalGroup::AddEventsToGroup(v8, &CPedGroups::ms_groups[6]);
  }
  if ( CPedGroups::ms_activeGroups[7] )
  {
    v9 = GetEventGlobalGroup();
    CEventGlobalGroup::AddEventsToGroup(v9, &CPedGroups::ms_groups[7]);
  }
  CInformFriendsEventQueue::Process();
  CInformGroupEventQueue::Process();
  v10 = GetEventGlobalGroup();
  CEventGroup::Flush(v10, 0);
  if ( !((unsigned __int8)CTimer::m_FrameCounter << 26) )
    CReferences::PruneAllReferencesInWorld();
  if ( CWorld::bProcessCutsceneOnly && CCutsceneMgr::ms_running )
  {
    for ( i = 0; i != 50; ++i )
    {
      v12 = CCutsceneMgr::ms_pCutsceneObjects[i];
      v13 = v12 == 0;
      if ( v12 )
        v13 = v12->m_listEntryInfo.m_pHead == 0;
      if ( !v13 )
      {
        CEntity::UpdateAnim(CCutsceneMgr::ms_pCutsceneObjects[i]);
        (*((void (__fastcall **)(CObject *))v12->_vptr$CPlaceable + 11))(v12);
        (*((void (__fastcall **)(CObject *))v12->_vptr$CPlaceable + 12))(v12);
        m_pRwObject = v12->m_pRwObject;
        if ( m_pRwObject )
        {
          parent = (char *)m_pRwObject->parent;
          m_pMat = v12->m_pMat;
          v17 = (RwMatrix *)(parent + 16);
          if ( m_pMat )
            CMatrix::UpdateRwMatrix(m_pMat, v17);
          else
            CSimpleTransform::UpdateRwMatrix(&v12->m_transform, v17);
        }
        CEntity::UpdateRwFrame(v12);
      }
    }
    return;
  }
  m_pHead = CWorld::ms_listMovingEntityPtrs.m_pHead;
  if ( !CWorld::ms_listMovingEntityPtrs.m_pHead )
    goto LABEL_62;
  do
  {
    v19 = *m_pHead;
    m_pHead = m_pHead->m_pNext;
    if ( (*((_BYTE *)v19.m_pVoid + 29) & 8) == 0 )
      CEntity::UpdateAnim((CEntity *)v19.m_pVoid);
  }
  while ( m_pHead );
  HIDWORD(v20) = CWorld::ms_listMovingEntityPtrs;
  if ( CWorld::ms_listMovingEntityPtrs.m_pHead )
  {
    do
    {
      while ( 1 )
      {
        v20 = *(_QWORD *)HIDWORD(v20);
        if ( (*(_BYTE *)(v20 + 29) & 8) == 0 )
          break;
        CWorld::RemoveEntityInsteadOfProcessingIt((CEntity *)v20);
        if ( !HIDWORD(v20) )
          goto LABEL_55;
      }
      if ( (*(_BYTE *)(v20 + 58) & 7) == 2 )
      {
        v21 = *(_DWORD *)(v20 + 1124);
        if ( v21 )
        {
          v22 = *(_DWORD *)(v21 + 1436);
          if ( v22 <= 1 )
            CHID::currentInstanceIndex = v22;
        }
      }
      (*(void (__fastcall **)(_DWORD))(*(_DWORD *)v20 + 44))(v20);
      if ( (*(_BYTE *)(v20 + 58) & 7) == 2 )
      {
        v23 = *(_DWORD *)(v20 + 1124);
        if ( v23 )
        {
          if ( *(_DWORD *)(v23 + 1436) <= 1u )
            CHID::currentInstanceIndex = 0;
        }
      }
      if ( (*(_DWORD *)(v20 + 28) & 0x40004) != 0 )
        CPhysical::RemoveFromMovingList((CPhysical *)v20);
    }
    while ( HIDWORD(v20) );
LABEL_55:
    HIDWORD(v24) = CWorld::ms_listMovingEntityPtrs;
    CWorld::bForceProcessControl = 1;
    while ( HIDWORD(v24) )
    {
      v24 = *(_QWORD *)HIDWORD(v24);
      v25 = *(_DWORD *)(v24 + 28);
      if ( (v25 & 0x40) != 0 )
      {
        if ( (v25 & 0x800) != 0 )
        {
          CWorld::RemoveEntityInsteadOfProcessingIt((CEntity *)v24);
        }
        else
        {
          (*(void (__fastcall **)(_DWORD))(*(_DWORD *)v24 + 44))(v24);
          if ( (*(_DWORD *)(v24 + 28) & 0x40004) != 0 )
            CPhysical::RemoveFromMovingList((CPhysical *)v24);
        }
      }
    }
  }
  else
  {
LABEL_62:
    CWorld::bForceProcessControl = 1;
  }
  v26 = (unsigned int)CWorld::ms_listObjectsWithControlCode.m_pHead;
  CWorld::bForceProcessControl = 0;
  if ( CWorld::ms_listObjectsWithControlCode.m_pHead )
  {
    do
    {
      v27 = *(_QWORD *)v26;
      LODWORD(v26) = *(_DWORD *)(v26 + 4);
      CObject::ProcessControlLogic((CObject *)v27);
    }
    while ( (_DWORD)v26 );
  }
  CLoadMonitor::StartTimer(&g_LoadMonitor, eCollision);
  v28 = CWorld::ms_listMovingEntityPtrs.m_pHead;
  CWorld::bNoMoreCollisionTorque = 0;
  if ( CWorld::ms_listMovingEntityPtrs.m_pHead )
  {
    do
    {
      v29 = *v28;
      v28 = v28->m_pNext;
      if ( (*((_BYTE *)v29.m_pVoid + 28) & 0x20) == 0 )
      {
        (*(void (__fastcall **)(void *))(*(_DWORD *)v29.m_pVoid + 48))(v29.m_pVoid);
        v30 = *((_DWORD *)v29.m_pVoid + 6);
        if ( v30 )
        {
          v31 = *(_DWORD *)(v30 + 4);
          v32 = (const CMatrix *)*((_DWORD *)v29.m_pVoid + 5);
          v33 = (RwMatrix *)(v31 + 16);
          if ( v32 )
            CMatrix::UpdateRwMatrix(v32, v33);
          else
            CSimpleTransform::UpdateRwMatrix((const CSimpleTransform *)((char *)v29.m_pVoid + 4), v33);
        }
        CEntity::UpdateRwFrame((CEntity *)v29.m_pVoid);
      }
    }
    while ( v28 );
    HIDWORD(v26) = CWorld::ms_listMovingEntityPtrs;
  }
  v34 = 0;
  CWorld::bNoMoreCollisionTorque = 1;
  do
  {
    if ( HIDWORD(v26) )
    {
      do
      {
        v26 = *(_QWORD *)HIDWORD(v26);
        if ( (*(_BYTE *)(v26 + 28) & 0x20) == 0 )
        {
          (*(void (__fastcall **)(_DWORD))(*(_DWORD *)v26 + 48))(v26);
          v35 = *(_DWORD *)(v26 + 24);
          if ( v35 )
          {
            v36 = *(_DWORD *)(v35 + 4);
            v37 = *(const CMatrix **)(v26 + 20);
            v38 = (RwMatrix *)(v36 + 16);
            if ( v37 )
              CMatrix::UpdateRwMatrix(v37, v38);
            else
              CSimpleTransform::UpdateRwMatrix((const CSimpleTransform *)(v26 + 4), v38);
          }
          CEntity::UpdateRwFrame((CEntity *)v26);
        }
      }
      while ( HIDWORD(v26) );
      HIDWORD(v26) = CWorld::ms_listMovingEntityPtrs;
    }
    ++v34;
  }
  while ( v34 != 4 );
  if ( HIDWORD(v26) )
  {
    do
    {
      v26 = *(_QWORD *)HIDWORD(v26);
      v40 = (_QWORD *)(v26 + 28);
      v39 = *(_DWORD *)(v26 + 28);
      if ( (v39 & 0x20) == 0 )
      {
        HIDWORD(v41) = *(_DWORD *)(v26 + 32);
        LODWORD(v41) = v39 | 0x10;
        *v40 = v41;
        (*(void (__fastcall **)(_DWORD))(*(_DWORD *)v26 + 48))(v26);
        v42 = *(_DWORD *)(v26 + 24);
        if ( v42 )
        {
          v43 = *(_DWORD *)(v42 + 4);
          v44 = *(const CMatrix **)(v26 + 20);
          v45 = (RwMatrix *)(v43 + 16);
          if ( v44 )
            CMatrix::UpdateRwMatrix(v44, v45);
          else
            CSimpleTransform::UpdateRwMatrix((const CSimpleTransform *)(v26 + 4), v45);
        }
        CEntity::UpdateRwFrame((CEntity *)v26);
        if ( (*(_DWORD *)v40 & 0x20) == 0 )
        {
          HIDWORD(v46) = *(_DWORD *)(v26 + 32);
          LODWORD(v46) = *(_DWORD *)v40 | 0x10;
          *v40 = v46;
        }
      }
    }
    while ( HIDWORD(v26) );
    HIDWORD(v47) = CWorld::ms_listMovingEntityPtrs;
    CWorld::bSecondShift = 0;
    if ( CWorld::ms_listMovingEntityPtrs.m_pHead )
    {
      do
      {
        v47 = *(_QWORD *)HIDWORD(v47);
        v48 = (_DWORD *)(v47 + 28);
        if ( (*(_BYTE *)(v47 + 28) & 0x20) == 0 )
        {
          (*(void (__fastcall **)(_DWORD))(*(_DWORD *)v47 + 52))(v47);
          v49 = *(_DWORD *)(v47 + 24);
          if ( v49 )
          {
            v50 = *(_DWORD *)(v49 + 4);
            v51 = *(const CMatrix **)(v47 + 20);
            v52 = (RwMatrix *)(v50 + 16);
            if ( v51 )
              CMatrix::UpdateRwMatrix(v51, v52);
            else
              CSimpleTransform::UpdateRwMatrix((const CSimpleTransform *)(v47 + 4), v52);
          }
          CEntity::UpdateRwFrame((CEntity *)v47);
          if ( (*v48 & 0x20) == 0 )
          {
            HIDWORD(v53) = *(_DWORD *)(v47 + 32);
            LODWORD(v53) = *v48 | 0x10;
            *(_QWORD *)v48 = v53;
          }
        }
      }
      while ( HIDWORD(v47) );
      v54 = CWorld::ms_listMovingEntityPtrs.m_pHead;
      CWorld::bSecondShift = 1;
      while ( v54 )
      {
        v55 = *v54;
        v54 = v54->m_pNext;
        v56 = (char *)v55.m_pVoid + 28;
        if ( (*((_BYTE *)v55.m_pVoid + 28) & 0x20) == 0 )
        {
          (*(void (__fastcall **)(void *))(*(_DWORD *)v55.m_pVoid + 52))(v55.m_pVoid);
          v57 = *((_DWORD *)v55.m_pVoid + 6);
          if ( v57 )
          {
            v58 = *(_DWORD *)(v57 + 4);
            v59 = (const CMatrix *)*((_DWORD *)v55.m_pVoid + 5);
            v60 = (RwMatrix *)(v58 + 16);
            if ( v59 )
              CMatrix::UpdateRwMatrix(v59, v60);
            else
              CSimpleTransform::UpdateRwMatrix((const CSimpleTransform *)((char *)v55.m_pVoid + 4), v60);
          }
          CEntity::UpdateRwFrame((CEntity *)v55.m_pVoid);
          if ( (*v56 & 0x20) == 0 )
          {
            HIDWORD(v61) = *((_DWORD *)v55.m_pVoid + 8);
            LODWORD(v61) = *v56 | 0x10;
            *(_QWORD *)v56 = v61;
            if ( *((unsigned __int8 *)v55.m_pVoid + 58) <= 7u )
            {
              v62 = powf(WORLD_PLAYER_SHIFT_DAMPING, CTimer::ms_fTimeStep);
              v63 = v62 * *((float *)v55.m_pVoid + 19);
              v64 = v62 * *((float *)v55.m_pVoid + 20);
              *((float *)v55.m_pVoid + 18) = v62 * *((float *)v55.m_pVoid + 18);
              *((float *)v55.m_pVoid + 19) = v63;
              *((float *)v55.m_pVoid + 20) = v64;
              CPhysical::ApplyMoveSpeed((CPhysical *)v55.m_pVoid);
              CPhysical::ApplyTurnSpeed((CPhysical *)v55.m_pVoid);
            }
          }
        }
      }
      goto LABEL_116;
    }
  }
  else
  {
    CWorld::bSecondShift = 0;
  }
  CWorld::bSecondShift = 1;
LABEL_116:
  CLoadMonitor::EndTimer(&g_LoadMonitor, eCollision);
  CVehicleRecording::SaveOrRetrieveDataForThisFrame();
  IKChainManager_c::Update(&g_ikChainMan, CTimer::ms_fTimeStep / 50.0);
  CWorld::ProcessAttachedEntities();
  HIDWORD(v65) = CWorld::ms_listMovingEntityPtrs;
  while ( HIDWORD(v65) )
  {
    v65 = *(_QWORD *)HIDWORD(v65);
    if ( (*(_BYTE *)(v65 + 58) & 7) == 3 )
    {
      CPedIntelligence::ProcessAfterProcCol(*(CPedIntelligence **)(v65 + 1088));
      v66 = *(_DWORD *)(v65 + 256);
      if ( v66 )
      {
        *(_DWORD *)(v65 + 300) = v66;
        CPed::PositionAttachedPed((CPed *)v65);
        v67 = *(_DWORD *)(v65 + 24);
        if ( v67 )
        {
          v68 = *(_DWORD *)(v67 + 4);
          v69 = *(const CMatrix **)(v65 + 20);
          v70 = (RwMatrix *)(v68 + 16);
          if ( v69 )
            CMatrix::UpdateRwMatrix(v69, v70);
          else
            CSimpleTransform::UpdateRwMatrix((const CSimpleTransform *)(v65 + 4), v70);
        }
        CEntity::UpdateRwFrame((CEntity *)v65);
      }
    }
  }
  CMessages::Process();
  if ( CWorld::Players[0].pPed )
  {
    CHID::currentInstanceIndex = 0;
    CPlayerInfo::Process(CWorld::Players, 0);
  }
  if ( CWorld::Players[1].pPed )
  {
    CHID::currentInstanceIndex = 1;
    CPlayerInfo::Process(&CWorld::Players[1], 1);
  }
  CHID::currentInstanceIndex = 0;
  CPedScriptedTaskRecord::Process();
  CPedGroups::Process();
  if ( (CTimer::m_FrameCounter & 7) == 1 )
  {
    CWorld::RemoveFallenPeds();
  }
  else if ( (CTimer::m_FrameCounter & 7) == 5 )
  {
    CWorld::RemoveFallenCars();
  }
}

//----- (00427E88) --------------------------------------------------------
void __fastcall CWorld::RemoveEntityInsteadOfProcessingIt(CEntity *pEntityToRemove)
{
  if ( (*(_BYTE *)&pEntityToRemove->m_info & 7) == 3 )
  {
    if ( FindPlayerPed(-1) == pEntityToRemove )
    {
      (*((void (__fastcall **)(CEntity *))pEntityToRemove->_vptr$CPlaceable + 4))(pEntityToRemove);
      if ( (unsigned __int8)((*(_BYTE *)&pEntityToRemove->m_info & 7) - 2) <= 2u )
        sub_18E984((CPhysical *)pEntityToRemove);
    }
    else
    {
      j_CPopulation::RemovePed((CPed *)pEntityToRemove);
    }
  }
  else
  {
    (*((void (__fastcall **)(CEntity *))pEntityToRemove->_vptr$CPlaceable + 4))(pEntityToRemove);
    if ( (unsigned __int8)((*(_BYTE *)&pEntityToRemove->m_info & 7) - 2) <= 2u )
      CPhysical::RemoveFromMovingList((CPhysical *)pEntityToRemove);
    (*((void (__fastcall **)(CEntity *))pEntityToRemove->_vptr$CPlaceable + 1))(pEntityToRemove);
  }
}

//----- (00427F00) --------------------------------------------------------
void CWorld::ProcessAttachedEntities()
{
  CVehiclePool *v0; // r8
  int32 m_nSize; // r0
  int v2; // r5
  int v3; // r6
  CEntity *m_aStorage; // r0
  bool v5; // zf
  CPhysical *v6; // r4
  RwObject_0 *m_pRwObject; // r0
  char *parent; // r1
  const CMatrix *m_pMat; // r0
  RwMatrix *v10; // r1
  CObjectPool *v11; // r8
  int32 v12; // r0
  int v13; // r5
  int v14; // r6
  uint8 *v15; // r4
  bool v16; // zf
  int v17; // r0
  int v18; // r1
  const CMatrix *v19; // r0
  RwMatrix *v20; // r1
  int v21; // r0
  int v22; // r1
  const CMatrix *v23; // r0
  RwMatrix *v24; // r1

  v0 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( m_nSize )
  {
    v2 = m_nSize - 1;
    v3 = 2604 * m_nSize - 2604;
    do
    {
      if ( (v0->m_aFlags[v2] & 0x80u) == 0 )
      {
        m_aStorage = (CEntity *)v0->m_aStorage;
        v6 = (CPhysical *)&(*v0->m_aStorage)[v3];
        v5 = v6 == 0;
        if ( v6 )
        {
          m_aStorage = v6->m_pAttachToEntity;
          v5 = m_aStorage == 0;
        }
        if ( !v5 )
        {
          v6->m_pNOCollisionVehicle = m_aStorage;
          CPhysical::PositionAttachedEntity(v6);
          m_pRwObject = v6->m_pRwObject;
          if ( m_pRwObject )
          {
            parent = (char *)m_pRwObject->parent;
            m_pMat = v6->m_pMat;
            v10 = (RwMatrix *)(parent + 16);
            if ( m_pMat )
              CMatrix::UpdateRwMatrix(m_pMat, v10);
            else
              CSimpleTransform::UpdateRwMatrix(&v6->m_transform, v10);
          }
          CEntity::UpdateRwFrame(v6);
        }
      }
      --v2;
      v3 -= 2604;
    }
    while ( v2 != -1 );
  }
  v11 = CPools::ms_pObjectPool;
  v12 = CPools::ms_pObjectPool->m_nSize;
  if ( v12 )
  {
    v13 = v12 - 1;
    v14 = 420 * v12 - 164;
    do
    {
      if ( (v11->m_aFlags[v13] & 0x80u) == 0 )
      {
        v15 = &(*v11->m_aStorage)[v14];
        v16 = v15 == (uint8 *)&elf_hash_bucket[1];
        if ( v15 != (uint8 *)&elf_hash_bucket[1] )
          v16 = *(_DWORD *)&(*v11->m_aStorage)[v14] == 0;
        if ( !v16 )
        {
          (*(void (__fastcall **)(uint8 *))(*((_DWORD *)v15 - 64) + 16))(v15 - 256);
          if ( (unsigned __int8)((*(v15 - 198) & 7) - 2) <= 2u )
            CPhysical::RemoveFromMovingList((CPhysical *)(v15 - 256));
          CPhysical::PositionAttachedEntity((CPhysical *)(v15 - 256));
          v17 = *((_DWORD *)v15 - 58);
          if ( v17 )
          {
            v18 = *(_DWORD *)(v17 + 4);
            v19 = (const CMatrix *)*((_DWORD *)v15 - 59);
            v20 = (RwMatrix *)(v18 + 16);
            if ( v19 )
              CMatrix::UpdateRwMatrix(v19, v20);
            else
              CSimpleTransform::UpdateRwMatrix((const CSimpleTransform *)(v15 - 252), v20);
          }
          CEntity::UpdateRwFrame((CEntity *)(v15 - 256));
          v21 = *((_DWORD *)v15 - 58);
          if ( v21 )
          {
            v22 = *(_DWORD *)(v21 + 4);
            v23 = (const CMatrix *)*((_DWORD *)v15 - 59);
            v24 = (RwMatrix *)(v22 + 16);
            if ( v23 )
              CMatrix::UpdateRwMatrix(v23, v24);
            else
              CSimpleTransform::UpdateRwMatrix((const CSimpleTransform *)(v15 - 252), v24);
          }
          CEntity::UpdateRwFrame((CEntity *)(v15 - 256));
          (*(void (__fastcall **)(uint8 *))(*((_DWORD *)v15 - 64) + 8))(v15 - 256);
          if ( (*(v15 - 198) & 3 | 4) != 5 && (*((_DWORD *)v15 - 57) & 0x40004) == 0 )
            CPhysical::AddToMovingList((CPhysical *)(v15 - 256));
        }
      }
      --v13;
      v14 -= 420;
    }
    while ( v13 != -1 );
  }
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (00428068) --------------------------------------------------------
void CWorld::RemoveFallenPeds()
{
  CPedPool *v0; // r11
  int32 m_nSize; // r0
  int v2; // r5
  int v3; // r4
  CPool<CPed,CCopPed>::StorageType *m_aStorage; // r1
  uint8 *v5; // r10
  int v6; // r0
  int v7; // r8
  int v8; // r2
  CNodeAddress *NodeClosestToCoors; // r0
  __int16 *v10; // r0
  CPathFind *bIgnoreInteriors; // [sp+1Ch] [bp-44h]
  CVector v12; // 0:r2.8,8:^0.4

  v0 = CPools::ms_pPedPool;
  m_nSize = CPools::ms_pPedPool->m_nSize;
  if ( m_nSize )
  {
    v2 = m_nSize - 1;
    v3 = 1996 * m_nSize - 900;
    bIgnoreInteriors = &ThePaths;
    while ( 1 )
    {
      if ( (v0->m_aFlags[v2] & 0x80u) != 0 )
        goto LABEL_18;
      m_aStorage = v0->m_aStorage;
      v5 = &(*v0->m_aStorage)[v3];
      if ( v5 == (uint8 *)&elf_hash_bucket[211] )
        goto LABEL_18;
      v6 = *((_DWORD *)v5 - 269);
      v7 = (int)&(*m_aStorage)[v3 - 1092];
      v8 = v7;
      if ( v6 )
        v8 = v6 + 48;
      if ( *(float *)(v8 + 8) >= -100.0 )
        goto LABEL_18;
      if ( (*m_aStorage)[v3] != 1 )
        goto LABEL_11;
      if ( CPed::IsPlayer((const CPed *)(v5 - 1096)) )
        break;
      CPopulation::RemovePed((CPed *)(v5 - 1096));
LABEL_18:
      --v2;
      v3 -= 1996;
      if ( v2 == -1 )
        return;
    }
    v6 = *((_DWORD *)v5 - 269);
LABEL_11:
    if ( v6 )
      v7 = v6 + 48;
    *(_QWORD *)&v12.x = *(_QWORD *)(v7 + 4);
    LODWORD(v12.z) = 1;
    NodeClosestToCoors = CPathFind::FindNodeClosestToCoors(
                           (CNodeAddress *)&ThePaths,
                           *(CPathFind **)v7,
                           v12,
                           1000000.0,
                           0.0,
                           0,
                           0,
                           0,
                           0,
                           (bool)bIgnoreInteriors);
    if ( (unsigned __int16)NodeClosestToCoors == 0xFFFF )
    {
      *(_DWORD *)(*((_DWORD *)v5 - 269) + 56) = -1027735552;
    }
    else
    {
      v10 = (__int16 *)&bIgnoreInteriors->pNodes[(unsigned __int16)NodeClosestToCoors][(unsigned int)NodeClosestToCoors >> 16];
      (*(void (__fastcall **)(uint8 *, _DWORD, _DWORD, _DWORD, _DWORD))(*((_DWORD *)v5 - 274) + 60))(
        v5 - 1096,
        (float)v10[4] * 0.125,
        (float)v10[5] * 0.125,
        (float)((float)v10[6] * 0.125) + 2.0,
        0);
    }
    *((_DWORD *)v5 - 255) = 0;
    *((_DWORD *)v5 - 256) = 0;
    *((_DWORD *)v5 - 254) = 0;
    goto LABEL_18;
  }
}
// 42814E: variable 'bIgnoreInteriors' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];

//----- (0042823C) --------------------------------------------------------
void CWorld::RemoveFallenCars()
{
  CVehiclePool *v0; // r9
  int32 m_nSize; // r0
  int v2; // r6
  int v3; // r4
  CPool<CVehicle,CHeli>::StorageType *m_aStorage; // r11
  uint8 *v5; // r5
  int v6; // r0
  _DWORD *v7; // r8
  uint8 *v8; // r1
  const CPed *v9; // r0
  int v10; // r0
  uint8 *v11; // r3
  CPathFind *v12; // r1
  CNodeAddress *NodeClosestToCoors; // r0
  void (__fastcall *v14)(uint8 *, _DWORD, _DWORD, _DWORD, int); // r12
  CPathNode *v15; // r0
  int v16; // r0
  bool v17; // [sp+1Ch] [bp-44h]
  CVector v18; // 0:r2.8,8:^0.4

  v0 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( m_nSize )
  {
    v2 = m_nSize - 1;
    v3 = 2604 * m_nSize - 2604;
    do
    {
      if ( (v0->m_aFlags[v2] & 0x80u) == 0 )
      {
        m_aStorage = v0->m_aStorage;
        v5 = &(*v0->m_aStorage)[v3];
        if ( v5 )
        {
          v6 = *((_DWORD *)v5 + 5);
          v7 = v5 + 4;
          v8 = v5 + 4;
          if ( v6 )
            v8 = (uint8 *)(v6 + 48);
          if ( *((float *)v8 + 2) < -100.0 )
          {
            if ( v5[1192] == 2 && (v5[71] & 0x20) == 0
              || v5 == (uint8 *)FindPlayerVehicle(-1, 0)
              || (v9 = (const CPed *)*((_DWORD *)v5 + 281)) != 0 && CPed::IsPlayer(v9) )
            {
              v10 = *((_DWORD *)v5 + 5);
              v11 = v5 + 4;
              if ( v10 )
                v11 = (uint8 *)(v10 + 48);
              v12 = *(CPathFind **)v11;
              *(_QWORD *)&v18.x = *(_QWORD *)(v11 + 4);
              v18.z = 0.0;
              NodeClosestToCoors = CPathFind::FindNodeClosestToCoors(
                                     (CNodeAddress *)&ThePaths,
                                     v12,
                                     v18,
                                     1000000.0,
                                     0.0,
                                     0,
                                     0,
                                     0,
                                     0,
                                     v17);
              v14 = *(void (__fastcall **)(uint8 *, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)&(*m_aStorage)[v3] + 60);
              if ( (unsigned __int16)NodeClosestToCoors == 0xFFFF )
              {
                v16 = *((_DWORD *)v5 + 5);
                if ( v16 )
                  v7 = (_DWORD *)(v16 + 48);
                v14(v5, *v7, v7[1], 0, 1);
              }
              else
              {
                v15 = &ThePaths.pNodes[(unsigned __int16)NodeClosestToCoors][(unsigned int)NodeClosestToCoors >> 16];
                v14(
                  v5,
                  (float)v15->CoorsX * 0.125,
                  (float)v15->CoorsY * 0.125,
                  (float)((float)v15->CoorsZ * 0.125) + 3.0,
                  1);
              }
              *((_DWORD *)v5 + 18) = 0;
              *((_DWORD *)v5 + 19) = 0;
              *((_DWORD *)v5 + 20) = 0;
            }
            else if ( (v5[1192] | 2) == 3 )
            {
              (*(void (__fastcall **)(uint8 *))(*(_DWORD *)&(*m_aStorage)[v3] + 16))(v5);
              if ( (unsigned __int8)((v5[58] & 7) - 2) <= 2u )
                CPhysical::RemoveFromMovingList((CPhysical *)v5);
              (*(void (__fastcall **)(uint8 *))(*(_DWORD *)&(*m_aStorage)[v3] + 4))(v5);
            }
          }
        }
      }
      --v2;
      v3 -= 2604;
    }
    while ( v2 != -1 );
  }
}
// 42831A: variable 'v17' is possibly undefined

//----- (00428410) --------------------------------------------------------
void CWorld::ProcessPedsAfterPreRender()
{
  CPtrNode *m_pHead; // r4
  CPtrNode v1; // kr00_8

  if ( !CTimer::bSkipProcessThisFrame )
  {
    m_pHead = CWorld::ms_listMovingEntityPtrs.m_pHead;
    while ( m_pHead )
    {
      v1 = *m_pHead;
      m_pHead = m_pHead->m_pNext;
      if ( (*((_BYTE *)v1.m_pVoid + 58) & 7) == 3 )
        CPedIntelligence::ProcessAfterPreRender(*((CPedIntelligence **)v1.m_pVoid + 272));
    }
  }
}

//----- (00428454) --------------------------------------------------------
void CWorld::ClearScanCodes()
{
  int i; // r3
  CPtrNode *j; // r1
  CSector *k; // r1
  int m; // r1
  CPtrNode *n; // r4
  CRepeatSector *ii; // r4
  CPtrNode *jj; // r2

  for ( i = 0; i != 14400; ++i )
  {
    for ( j = CWorld::ms_aSectors[i].m_buildingPtrListArray.m_pHead; j; j = j->m_pNext )
      *((_WORD *)j->m_pVoid + 24) = 0;
    for ( k = &CWorld::ms_aSectors[i]; ; LOWORD(k->m_buildingPtrListArray.m_pHead[6].m_pVoid) = 0 )
    {
      k = (CSector *)k->m_dummyPtrListArray.m_pHead;
      if ( !k )
        break;
    }
  }
  for ( m = 0; m != 256; ++m )
  {
    for ( n = CWorld::ms_aRepeatSectors[m].m_ptrListArray[0].m_pHead; n; n = n->m_pNext )
      *((_WORD *)n->m_pVoid + 24) = 0;
    for ( ii = &CWorld::ms_aRepeatSectors[m]; ; LOWORD(ii->m_ptrListArray[0].m_pHead[6].m_pVoid) = 0 )
    {
      ii = (CRepeatSector *)ii->m_ptrListArray[1].m_pHead;
      if ( !ii )
        break;
    }
    for ( jj = CWorld::ms_aRepeatSectors[m].m_ptrListArray[2].m_pHead; jj; jj = jj->m_pNext )
      *((_WORD *)jj->m_pVoid + 24) = 0;
  }
}

//----- (00428508) --------------------------------------------------------
bool __fastcall CWorld::GetIsLineOfSightSectorListClear(
        CPtrList *list,
        const CColLine *line,
        bool bSeeThroughStuff,
        bool bIgnoreSomeObjectsForCamera)
{
  _BOOL4 v4; // r10
  CPtrNode *m_pHead; // r4
  CPtrNode v7; // kr00_8
  int v8; // r1
  bool v9; // zf
  int v10; // r1
  const CMatrix *v11; // r6
  CColModel *ColModel; // r0
  bool v13; // r5

  v4 = bIgnoreSomeObjectsForCamera;
  m_pHead = list->m_pHead;
  while ( m_pHead )
  {
    v7 = *m_pHead;
    m_pHead = m_pHead->m_pNext;
    v8 = *((unsigned __int16 *)v7.m_pVoid + 24);
    v9 = v8 == CWorld::ms_nCurrentScanCode;
    if ( v8 != CWorld::ms_nCurrentScanCode )
      v9 = *((unsigned __int8 *)v7.m_pVoid + 28) << 31 == 0;
    if ( v9 )
      continue;
    *((_WORD *)v7.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
    if ( CWorld::pIgnoreEntity == v7.m_pVoid )
      continue;
    if ( v4 && !CGarages::IsModelIndexADoor(*((__int16 *)v7.m_pVoid + 19)) )
    {
      v10 = *(unsigned __int8 *)(*((_DWORD *)v7.m_pVoid + 89) + 30);
      if ( v10 == 3 )
      {
        if ( gCurCamColVars < 0xAu )
          continue;
      }
      else if ( v10 != 2 && (v10 != 1 || gCurCamColVars >= 0xAu) )
      {
        continue;
      }
    }
    v11 = (const CMatrix *)*((_DWORD *)v7.m_pVoid + 5);
    if ( !v11 )
    {
      CPlaceable::AllocateMatrix((CPlaceable *)v7.m_pVoid);
      CSimpleTransform::UpdateMatrix((const CSimpleTransform *)((char *)v7.m_pVoid + 4), *((CMatrix **)v7.m_pVoid + 5));
      v11 = (const CMatrix *)*((_DWORD *)v7.m_pVoid + 5);
    }
    ColModel = CEntity::GetColModel((CEntity *)v7.m_pVoid);
    v13 = 0;
    if ( CCollision::TestLineOfSight(line, v11, ColModel, bSeeThroughStuff, 0) == 1 )
      return v13;
  }
  return 1;
}

//----- (004285D0) --------------------------------------------------------
void __fastcall CWorld::FindObjectsInRange(
        const CVector *Coors,
        float Range,
        int Dist2D,
        Int16 *pNum,
        int MaxNum,
        CEntity **ppResults,
        int bCheckBuildings,
        int bCheckVehicles,
        int bCheckPeds,
        int bCheckObjects,
        int bCheckDummies)
{
  float x; // s18
  float y; // s20
  float v17; // r8
  float v18; // r9
  float v19; // r10
  uint16 v20; // r0
  float v21; // s0
  int v22; // r0
  int v23; // r0
  int v24; // r2
  CPtrNode *m_pHead; // r9
  int v26; // r3
  CPtrNode v27; // kr00_8
  float32x2_t *v28; // r0
  float32x2_t *v29; // r1
  float32x2_t v30; // d16
  unsigned __int64 v31; // d2
  float v32; // s4
  float v33; // s2
  int v34; // r9
  CPtrNode *v35; // r2
  int v36; // r0
  CPtrNode v37; // kr08_8
  float32x2_t *v38; // r1
  float32x2_t *v39; // r4
  float32x2_t v40; // d16
  unsigned __int64 v41; // d2
  float v42; // s4
  float v43; // s2
  CPtrNode *v44; // r2
  int v45; // r0
  CPtrNode v46; // kr10_8
  float32x2_t *v47; // r1
  float32x2_t *v48; // r4
  float32x2_t v49; // d16
  unsigned __int64 v50; // d2
  float v51; // s4
  float v52; // s2
  CPtrNode *v53; // r0
  int v54; // r3
  CPtrNode v55; // kr18_8
  float32x2_t *v56; // r1
  float32x2_t *v57; // r4
  float32x2_t v58; // d16
  unsigned __int64 v59; // d2
  float v60; // s4
  float v61; // s2
  CPtrNode *v62; // r0
  int v63; // r3
  CPtrNode v64; // kr20_8
  float32x2_t *v65; // r1
  float32x2_t *v66; // r4
  float32x2_t v67; // d16
  unsigned __int64 v68; // d2
  float v69; // s4
  float v70; // s2
  int v71; // r2
  int v72; // [sp+0h] [bp-88h]
  int v73; // [sp+8h] [bp-80h]
  int v74; // [sp+24h] [bp-64h]
  int v75; // [sp+28h] [bp-60h]
  int v76; // [sp+2Ch] [bp-5Ch]
  int v77; // [sp+30h] [bp-58h]
  int v78; // [sp+34h] [bp-54h]

  x = Coors->x;
  y = Coors->y;
  v17 = floorf((float)((float)(Coors->x - Range) / 50.0) + 60.0);
  v18 = floorf((float)((float)(y - Range) / 50.0) + 60.0);
  v19 = floorf((float)((float)(x + Range) / 50.0) + 60.0);
  v72 = (int)floorf((float)((float)(y + Range) / 50.0) + 60.0);
  v73 = (int)v18;
  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v20 = 1;
  }
  else
  {
    v20 = CWorld::ms_nCurrentScanCode + 1;
  }
  CWorld::ms_nCurrentScanCode = v20;
  *pNum = 0;
  if ( v73 <= v72 )
  {
    v21 = Range * Range;
    v75 = (int)v19;
    do
    {
      if ( (int)v17 <= v75 )
      {
        v22 = 0;
        if ( v73 > 0 )
          v22 = v73;
        if ( v22 >= 119 )
          v22 = 119;
        v74 = 120 * v22;
        v23 = (int)v17;
        do
        {
          v24 = 0;
          v77 = v23 & 0xF;
          v78 = v23;
          if ( v23 > 0 )
            v24 = v23;
          if ( v24 >= 119 )
            v24 = 119;
          v76 = v74 + v24;
          if ( bCheckBuildings == 1 )
          {
            m_pHead = CWorld::ms_aSectors[v76].m_buildingPtrListArray.m_pHead;
            while ( m_pHead )
            {
              v27 = *m_pHead;
              m_pHead = m_pHead->m_pNext;
              if ( *((unsigned __int16 *)v27.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
              {
                v28 = (float32x2_t *)*((_DWORD *)v27.m_pVoid + 5);
                *((_WORD *)v27.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
                v29 = v28 + 6;
                if ( !v28 )
                  v29 = (float32x2_t *)((char *)v27.m_pVoid + 4);
                v30.n64_u64[0] = vsub_f32(*(float32x2_t *)&Coors->x, (float32x2_t)v29->n64_u64[0]).n64_u64[0];
                v31 = vmul_f32(v30, v30).n64_u64[0];
                v32 = *(float *)&v31 + *((float *)&v31 + 1);
                v33 = v32 + (float)((float)(Coors->z - v29[1].n64_f32[0]) * (float)(Coors->z - v29[1].n64_f32[0]));
                if ( Dist2D )
                  v33 = v32;
                if ( v33 < v21 )
                {
                  v26 = *pNum;
                  if ( v26 < MaxNum )
                  {
                    if ( ppResults )
                    {
                      ppResults[v26] = (CEntity *)v27.m_pVoid;
                      LOWORD(v26) = *pNum;
                    }
                    *pNum = v26 + 1;
                  }
                }
              }
            }
          }
          v34 = v77 | (unsigned __int8)(16 * v73);
          if ( bCheckVehicles == 1 )
          {
            v35 = CWorld::ms_aRepeatSectors[v34].m_ptrListArray[0].m_pHead;
            while ( v35 )
            {
              v37 = *v35;
              v35 = v35->m_pNext;
              if ( *((unsigned __int16 *)v37.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
              {
                v38 = (float32x2_t *)*((_DWORD *)v37.m_pVoid + 5);
                *((_WORD *)v37.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
                v39 = v38 + 6;
                if ( !v38 )
                  v39 = (float32x2_t *)((char *)v37.m_pVoid + 4);
                v40.n64_u64[0] = vsub_f32(*(float32x2_t *)&Coors->x, (float32x2_t)v39->n64_u64[0]).n64_u64[0];
                v41 = vmul_f32(v40, v40).n64_u64[0];
                v42 = *(float *)&v41 + *((float *)&v41 + 1);
                v43 = v42 + (float)((float)(Coors->z - v39[1].n64_f32[0]) * (float)(Coors->z - v39[1].n64_f32[0]));
                if ( Dist2D )
                  v43 = v42;
                if ( v43 < v21 )
                {
                  v36 = *pNum;
                  if ( v36 < MaxNum )
                  {
                    if ( ppResults )
                    {
                      ppResults[v36] = (CEntity *)v37.m_pVoid;
                      LOWORD(v36) = *pNum;
                    }
                    *pNum = v36 + 1;
                  }
                }
              }
            }
          }
          if ( bCheckPeds == 1 )
          {
            v44 = CWorld::ms_aRepeatSectors[v34].m_ptrListArray[1].m_pHead;
            while ( v44 )
            {
              v46 = *v44;
              v44 = v44->m_pNext;
              if ( *((unsigned __int16 *)v46.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
              {
                v47 = (float32x2_t *)*((_DWORD *)v46.m_pVoid + 5);
                *((_WORD *)v46.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
                v48 = v47 + 6;
                if ( !v47 )
                  v48 = (float32x2_t *)((char *)v46.m_pVoid + 4);
                v49.n64_u64[0] = vsub_f32(*(float32x2_t *)&Coors->x, (float32x2_t)v48->n64_u64[0]).n64_u64[0];
                v50 = vmul_f32(v49, v49).n64_u64[0];
                v51 = *(float *)&v50 + *((float *)&v50 + 1);
                v52 = v51 + (float)((float)(Coors->z - v48[1].n64_f32[0]) * (float)(Coors->z - v48[1].n64_f32[0]));
                if ( Dist2D )
                  v52 = v51;
                if ( v52 < v21 )
                {
                  v45 = *pNum;
                  if ( v45 < MaxNum )
                  {
                    if ( ppResults )
                    {
                      ppResults[v45] = (CEntity *)v46.m_pVoid;
                      LOWORD(v45) = *pNum;
                    }
                    *pNum = v45 + 1;
                  }
                }
              }
            }
          }
          if ( bCheckObjects == 1 )
          {
            v53 = CWorld::ms_aRepeatSectors[v34].m_ptrListArray[2].m_pHead;
            while ( v53 )
            {
              v55 = *v53;
              v53 = v53->m_pNext;
              if ( *((unsigned __int16 *)v55.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
              {
                v56 = (float32x2_t *)*((_DWORD *)v55.m_pVoid + 5);
                *((_WORD *)v55.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
                v57 = v56 + 6;
                if ( !v56 )
                  v57 = (float32x2_t *)((char *)v55.m_pVoid + 4);
                v58.n64_u64[0] = vsub_f32(*(float32x2_t *)&Coors->x, (float32x2_t)v57->n64_u64[0]).n64_u64[0];
                v59 = vmul_f32(v58, v58).n64_u64[0];
                v60 = *(float *)&v59 + *((float *)&v59 + 1);
                v61 = v60 + (float)((float)(Coors->z - v57[1].n64_f32[0]) * (float)(Coors->z - v57[1].n64_f32[0]));
                if ( Dist2D )
                  v61 = v60;
                if ( v61 < v21 )
                {
                  v54 = *pNum;
                  if ( v54 < MaxNum )
                  {
                    if ( ppResults )
                    {
                      ppResults[v54] = (CEntity *)v55.m_pVoid;
                      LOWORD(v54) = *pNum;
                    }
                    *pNum = v54 + 1;
                  }
                }
              }
            }
          }
          if ( bCheckDummies == 1 )
          {
            v62 = CWorld::ms_aSectors[v76].m_dummyPtrListArray.m_pHead;
            while ( v62 )
            {
              v64 = *v62;
              v62 = v62->m_pNext;
              if ( *((unsigned __int16 *)v64.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
              {
                v65 = (float32x2_t *)*((_DWORD *)v64.m_pVoid + 5);
                *((_WORD *)v64.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
                v66 = v65 + 6;
                if ( !v65 )
                  v66 = (float32x2_t *)((char *)v64.m_pVoid + 4);
                v67.n64_u64[0] = vsub_f32(*(float32x2_t *)&Coors->x, (float32x2_t)v66->n64_u64[0]).n64_u64[0];
                v68 = vmul_f32(v67, v67).n64_u64[0];
                v69 = *(float *)&v68 + *((float *)&v68 + 1);
                v70 = v69 + (float)((float)(Coors->z - v66[1].n64_f32[0]) * (float)(Coors->z - v66[1].n64_f32[0]));
                if ( Dist2D )
                  v70 = v69;
                if ( v70 < v21 )
                {
                  v63 = *pNum;
                  if ( v63 < MaxNum )
                  {
                    if ( ppResults )
                    {
                      ppResults[v63] = (CEntity *)v64.m_pVoid;
                      LOWORD(v63) = *pNum;
                    }
                    *pNum = v63 + 1;
                  }
                }
              }
            }
          }
          v23 = v78 + 1;
        }
        while ( v78 < v75 );
      }
      v71 = v73++;
    }
    while ( v71 < v72 );
  }
}

//----- (00428A9C) --------------------------------------------------------
void __fastcall CWorld::FindObjectsInRangeSectorList(
        CPtrList *list,
        const CVector *Coors,
        float Range,
        int Dist2D,
        __int16 *a5,
        int a6,
        int a7)
{
  CPtrNode *m_pHead; // r0
  float v8; // s0
  CPtrNode v9; // kr00_8
  float32x2_t *v10; // r2
  float32x2_t *v11; // r4
  RwReal *p_z; // r6
  float32x2_t v13; // d16
  unsigned __int64 v14; // d2
  float v15; // s4
  float v16; // s2
  bool v17; // cc

  m_pHead = list->m_pHead;
  if ( m_pHead )
  {
    v8 = Range * Range;
    do
    {
      while ( 1 )
      {
        v9 = *m_pHead;
        m_pHead = m_pHead->m_pNext;
        if ( *((unsigned __int16 *)v9.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
        {
          v10 = (float32x2_t *)*((_DWORD *)v9.m_pVoid + 5);
          *((_WORD *)v9.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
          v11 = v10 + 6;
          p_z = &Coors->z;
          if ( !v10 )
            v11 = (float32x2_t *)((char *)v9.m_pVoid + 4);
          v13.n64_u64[0] = vsub_f32(*(float32x2_t *)&Coors->x, (float32x2_t)v11->n64_u64[0]).n64_u64[0];
          v14 = vmul_f32(v13, v13).n64_u64[0];
          v15 = *(float *)&v14 + *((float *)&v14 + 1);
          v16 = v15 + (float)((float)(*p_z - v11[1].n64_f32[0]) * (float)(*p_z - v11[1].n64_f32[0]));
          if ( Dist2D )
            v16 = v15;
          v17 = v16 < v8;
          if ( v16 < v8 )
          {
            p_z = (RwReal *)*a5;
            v17 = (int)p_z < a6;
          }
          if ( v17 )
            break;
        }
        if ( !m_pHead )
          return;
      }
      if ( a7 )
      {
        *(_DWORD *)(a7 + 4 * (_DWORD)p_z) = v9.m_pVoid;
        LOWORD(p_z) = *a5;
      }
      *a5 = (_WORD)p_z + 1;
    }
    while ( m_pHead );
  }
}

//----- (00428B4C) --------------------------------------------------------
void __fastcall CWorld::FindObjectsOfTypeInRange(
        uint32 ModelIndx,
        const CVector *Coors,
        float Range,
        int Dist2D,
        Int16 *pNum,
        int MaxNum,
        CEntity **ppResults,
        int bCheckBuildings,
        int bCheckVehicles,
        int bCheckPeds,
        int bCheckObjects,
        int bCheckDummies)
{
  float x; // s18
  float y; // s20
  float v18; // r4
  float v19; // r9
  float v20; // s22
  int v21; // s18
  uint16 v22; // r0
  float v23; // s0
  int v24; // r0
  int v25; // r0
  int v26; // r1
  bool v27; // cc
  int v28; // r0
  CPtrNode *m_pHead; // r12
  CPtrNode v30; // kr00_8
  int v31; // r3
  float32x2_t *v32; // r0
  float32x2_t *v33; // r2
  float32x2_t v34; // d16
  unsigned __int64 v35; // d2
  float v36; // s4
  float v37; // s2
  int v38; // r3
  Int16 *v39; // r1
  int v40; // r12
  CPtrNode *v41; // r2
  int v42; // r0
  CPtrNode v43; // kr08_8
  int v44; // r1
  float32x2_t *v45; // r0
  float32x2_t *v46; // r4
  float32x2_t v47; // d16
  unsigned __int64 v48; // d2
  float v49; // s4
  float v50; // s2
  CPtrNode *v51; // r2
  int v52; // r0
  CPtrNode v53; // kr10_8
  int v54; // r1
  float32x2_t *v55; // r0
  float32x2_t *v56; // r4
  float32x2_t v57; // d16
  unsigned __int64 v58; // d2
  float v59; // s4
  float v60; // s2
  CPtrNode *v61; // r2
  int v62; // r0
  CPtrNode v63; // kr18_8
  int v64; // r1
  float32x2_t *v65; // r0
  float32x2_t *v66; // r4
  float32x2_t v67; // d16
  unsigned __int64 v68; // d2
  float v69; // s4
  float v70; // s2
  CPtrNode *v71; // r2
  int v72; // r0
  CPtrNode v73; // kr20_8
  int v74; // r1
  float32x2_t *v75; // r0
  float32x2_t *v76; // r4
  float32x2_t v77; // d16
  unsigned __int64 v78; // d2
  float v79; // s4
  float v80; // s2
  int v81; // r2
  int v82; // [sp+4h] [bp-8Ch]
  int v83; // [sp+8h] [bp-88h]
  int v84; // [sp+Ch] [bp-84h]
  int v85; // [sp+28h] [bp-68h]
  int v86; // [sp+34h] [bp-5Ch]
  int v87; // [sp+38h] [bp-58h]
  int v88; // [sp+3Ch] [bp-54h]

  x = Coors->x;
  y = Coors->y;
  v18 = floorf((float)((float)(Coors->x - Range) / 50.0) + 60.0);
  v19 = floorf((float)((float)(x + Range) / 50.0) + 60.0);
  v20 = floorf((float)((float)(y - Range) / 50.0) + 60.0);
  v21 = (int)v19;
  v82 = (int)floorf((float)((float)(y + Range) / 50.0) + 60.0);
  v84 = (int)v20;
  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v22 = 1;
  }
  else
  {
    v22 = CWorld::ms_nCurrentScanCode + 1;
  }
  CWorld::ms_nCurrentScanCode = v22;
  *pNum = 0;
  if ( v84 <= v82 )
  {
    v23 = Range * Range;
    v83 = (int)v18;
    do
    {
      if ( v83 <= v21 )
      {
        v24 = 0;
        if ( v84 > 0 )
          v24 = v84;
        if ( v24 >= 119 )
          v24 = 119;
        v85 = 120 * v24;
        v25 = v83;
        do
        {
          v26 = v25;
          v87 = v25 & 0xF;
          v27 = v25 <= 0;
          v28 = 0;
          v88 = v26;
          if ( !v27 )
            v28 = v26;
          if ( v28 >= 119 )
            v28 = 119;
          v86 = v28 + v85;
          if ( bCheckBuildings == 1 )
          {
            m_pHead = CWorld::ms_aSectors[v86].m_buildingPtrListArray.m_pHead;
            while ( m_pHead )
            {
              v30 = *m_pHead;
              m_pHead = m_pHead->m_pNext;
              if ( *((unsigned __int16 *)v30.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
              {
                v31 = *((__int16 *)v30.m_pVoid + 19);
                *((_WORD *)v30.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
                if ( v31 == ModelIndx )
                {
                  v32 = (float32x2_t *)*((_DWORD *)v30.m_pVoid + 5);
                  v33 = v32 + 6;
                  if ( !v32 )
                    v33 = (float32x2_t *)((char *)v30.m_pVoid + 4);
                  v34.n64_u64[0] = vsub_f32(*(float32x2_t *)&Coors->x, (float32x2_t)v33->n64_u64[0]).n64_u64[0];
                  v35 = vmul_f32(v34, v34).n64_u64[0];
                  v36 = *(float *)&v35 + *((float *)&v35 + 1);
                  v37 = v36 + (float)((float)(Coors->z - v33[1].n64_f32[0]) * (float)(Coors->z - v33[1].n64_f32[0]));
                  if ( Dist2D )
                    v37 = v36;
                  if ( v37 < v23 )
                  {
                    v38 = *pNum;
                    if ( v38 < MaxNum )
                    {
                      if ( ppResults )
                      {
                        ppResults[v38] = (CEntity *)v30.m_pVoid;
                        v39 = pNum;
                        LOWORD(v38) = *pNum;
                      }
                      else
                      {
                        v39 = pNum;
                      }
                      *v39 = v38 + 1;
                    }
                  }
                }
              }
            }
          }
          v40 = v87 | (unsigned __int8)(16 * v84);
          if ( bCheckVehicles == 1 )
          {
            v41 = CWorld::ms_aRepeatSectors[v40].m_ptrListArray[0].m_pHead;
            while ( v41 )
            {
              v43 = *v41;
              v41 = v41->m_pNext;
              if ( *((unsigned __int16 *)v43.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
              {
                v44 = *((__int16 *)v43.m_pVoid + 19);
                *((_WORD *)v43.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
                if ( v44 == ModelIndx )
                {
                  v45 = (float32x2_t *)*((_DWORD *)v43.m_pVoid + 5);
                  v46 = v45 + 6;
                  if ( !v45 )
                    v46 = (float32x2_t *)((char *)v43.m_pVoid + 4);
                  v47.n64_u64[0] = vsub_f32(*(float32x2_t *)&Coors->x, (float32x2_t)v46->n64_u64[0]).n64_u64[0];
                  v48 = vmul_f32(v47, v47).n64_u64[0];
                  v49 = *(float *)&v48 + *((float *)&v48 + 1);
                  v50 = v49 + (float)((float)(Coors->z - v46[1].n64_f32[0]) * (float)(Coors->z - v46[1].n64_f32[0]));
                  if ( Dist2D )
                    v50 = v49;
                  if ( v50 < v23 )
                  {
                    v42 = *pNum;
                    if ( v42 < MaxNum )
                    {
                      if ( ppResults )
                      {
                        ppResults[v42] = (CEntity *)v43.m_pVoid;
                        LOWORD(v42) = *pNum;
                      }
                      *pNum = v42 + 1;
                    }
                  }
                }
              }
            }
          }
          if ( bCheckPeds == 1 )
          {
            v51 = CWorld::ms_aRepeatSectors[v40].m_ptrListArray[1].m_pHead;
            while ( v51 )
            {
              v53 = *v51;
              v51 = v51->m_pNext;
              if ( *((unsigned __int16 *)v53.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
              {
                v54 = *((__int16 *)v53.m_pVoid + 19);
                *((_WORD *)v53.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
                if ( v54 == ModelIndx )
                {
                  v55 = (float32x2_t *)*((_DWORD *)v53.m_pVoid + 5);
                  v56 = v55 + 6;
                  if ( !v55 )
                    v56 = (float32x2_t *)((char *)v53.m_pVoid + 4);
                  v57.n64_u64[0] = vsub_f32(*(float32x2_t *)&Coors->x, (float32x2_t)v56->n64_u64[0]).n64_u64[0];
                  v58 = vmul_f32(v57, v57).n64_u64[0];
                  v59 = *(float *)&v58 + *((float *)&v58 + 1);
                  v60 = v59 + (float)((float)(Coors->z - v56[1].n64_f32[0]) * (float)(Coors->z - v56[1].n64_f32[0]));
                  if ( Dist2D )
                    v60 = v59;
                  if ( v60 < v23 )
                  {
                    v52 = *pNum;
                    if ( v52 < MaxNum )
                    {
                      if ( ppResults )
                      {
                        ppResults[v52] = (CEntity *)v53.m_pVoid;
                        LOWORD(v52) = *pNum;
                      }
                      *pNum = v52 + 1;
                    }
                  }
                }
              }
            }
          }
          if ( bCheckObjects == 1 )
          {
            v61 = CWorld::ms_aRepeatSectors[v40].m_ptrListArray[2].m_pHead;
            while ( v61 )
            {
              v63 = *v61;
              v61 = v61->m_pNext;
              if ( *((unsigned __int16 *)v63.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
              {
                v64 = *((__int16 *)v63.m_pVoid + 19);
                *((_WORD *)v63.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
                if ( v64 == ModelIndx )
                {
                  v65 = (float32x2_t *)*((_DWORD *)v63.m_pVoid + 5);
                  v66 = v65 + 6;
                  if ( !v65 )
                    v66 = (float32x2_t *)((char *)v63.m_pVoid + 4);
                  v67.n64_u64[0] = vsub_f32(*(float32x2_t *)&Coors->x, (float32x2_t)v66->n64_u64[0]).n64_u64[0];
                  v68 = vmul_f32(v67, v67).n64_u64[0];
                  v69 = *(float *)&v68 + *((float *)&v68 + 1);
                  v70 = v69 + (float)((float)(Coors->z - v66[1].n64_f32[0]) * (float)(Coors->z - v66[1].n64_f32[0]));
                  if ( Dist2D )
                    v70 = v69;
                  if ( v70 < v23 )
                  {
                    v62 = *pNum;
                    if ( v62 < MaxNum )
                    {
                      if ( ppResults )
                      {
                        ppResults[v62] = (CEntity *)v63.m_pVoid;
                        LOWORD(v62) = *pNum;
                      }
                      *pNum = v62 + 1;
                    }
                  }
                }
              }
            }
          }
          if ( bCheckDummies == 1 )
          {
            v71 = CWorld::ms_aSectors[v86].m_dummyPtrListArray.m_pHead;
            while ( v71 )
            {
              v73 = *v71;
              v71 = v71->m_pNext;
              if ( *((unsigned __int16 *)v73.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
              {
                v74 = *((__int16 *)v73.m_pVoid + 19);
                *((_WORD *)v73.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
                if ( v74 == ModelIndx )
                {
                  v75 = (float32x2_t *)*((_DWORD *)v73.m_pVoid + 5);
                  v76 = v75 + 6;
                  if ( !v75 )
                    v76 = (float32x2_t *)((char *)v73.m_pVoid + 4);
                  v77.n64_u64[0] = vsub_f32(*(float32x2_t *)&Coors->x, (float32x2_t)v76->n64_u64[0]).n64_u64[0];
                  v78 = vmul_f32(v77, v77).n64_u64[0];
                  v79 = *(float *)&v78 + *((float *)&v78 + 1);
                  v80 = v79 + (float)((float)(Coors->z - v76[1].n64_f32[0]) * (float)(Coors->z - v76[1].n64_f32[0]));
                  if ( Dist2D )
                    v80 = v79;
                  if ( v80 < v23 )
                  {
                    v72 = *pNum;
                    if ( v72 < MaxNum )
                    {
                      if ( ppResults )
                      {
                        ppResults[v72] = (CEntity *)v73.m_pVoid;
                        LOWORD(v72) = *pNum;
                      }
                      *pNum = v72 + 1;
                    }
                  }
                }
              }
            }
          }
          v25 = v88 + 1;
        }
        while ( v88 < v21 );
      }
      v81 = v84++;
    }
    while ( v81 < v82 );
  }
}

//----- (00429050) --------------------------------------------------------
void __fastcall CWorld::FindObjectsOfTypeInRangeSectorList(
        uint32 ModelIndx,
        CPtrList *list,
        const CVector *Coors,
        float Range,
        int a5,
        __int16 *a6,
        int a7,
        int a8)
{
  CPtrNode *m_pHead; // r1
  float v9; // s0
  CPtrNode v10; // kr00_8
  int v11; // r4
  float32x2_t *v12; // r3
  float32x2_t *v13; // r5
  float32x2_t v14; // d16
  unsigned __int64 v15; // d2
  float v16; // s4
  float v17; // s2
  bool v18; // cc

  m_pHead = list->m_pHead;
  if ( m_pHead )
  {
    v9 = Range * Range;
    do
    {
      while ( 1 )
      {
        v10 = *m_pHead;
        m_pHead = m_pHead->m_pNext;
        if ( *((unsigned __int16 *)v10.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
        {
          v11 = *((__int16 *)v10.m_pVoid + 19);
          *((_WORD *)v10.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
          if ( v11 == ModelIndx )
          {
            v12 = (float32x2_t *)*((_DWORD *)v10.m_pVoid + 5);
            v13 = v12 + 6;
            if ( !v12 )
              v13 = (float32x2_t *)((char *)v10.m_pVoid + 4);
            v14.n64_u64[0] = vsub_f32(*(float32x2_t *)&Coors->x, (float32x2_t)v13->n64_u64[0]).n64_u64[0];
            v15 = vmul_f32(v14, v14).n64_u64[0];
            v16 = *(float *)&v15 + *((float *)&v15 + 1);
            v17 = v16 + (float)((float)(Coors->z - v13[1].n64_f32[0]) * (float)(Coors->z - v13[1].n64_f32[0]));
            if ( a5 )
              v17 = v16;
            v18 = v17 < v9;
            if ( v17 < v9 )
            {
              v12 = (float32x2_t *)*a6;
              v18 = (int)v12 < a7;
            }
            if ( v18 )
              break;
          }
        }
        if ( !m_pHead )
          return;
      }
      if ( a8 )
      {
        *(_DWORD *)(a8 + 4 * (_DWORD)v12) = v10.m_pVoid;
        LOWORD(v12) = *a6;
      }
      *a6 = (_WORD)v12 + 1;
    }
    while ( m_pHead );
  }
}

//----- (0042910C) --------------------------------------------------------
void __fastcall CWorld::FindLodOfTypeInRange(
        uint32 ModelIndx,
        const CVector *Coors,
        float Range,
        int Dist2D,
        Int16 *pNum,
        int MaxNum,
        CEntity **ppResults)
{
  int v7; // lr
  float y; // s2
  int v13; // s18
  int v14; // s20
  uint16 v15; // r0
  float v16; // s0
  int v17; // r9
  CPtrNode *m_pHead; // r12
  CPtrNode v19; // kr00_8
  int v20; // r0
  float32x2_t *v21; // r0
  float32x2_t *v22; // r2
  float32x2_t v23; // d16
  unsigned __int64 v24; // d2
  float v25; // s4
  float v26; // s2
  bool v27; // cc
  int v28; // [sp+0h] [bp-50h]
  int v29; // [sp+8h] [bp-48h]

  y = Coors->y;
  v13 = (int)(float)((float)((float)(Coors->x + Range) / 200.0) + 15.0);
  v14 = (int)(float)((float)((float)(Coors->x - Range) / 200.0) + 15.0);
  v28 = (int)(float)((float)((float)(y + Range) / 200.0) + 15.0);
  v29 = (int)(float)((float)((float)(y - Range) / 200.0) + 15.0);
  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v15 = 1;
  }
  else
  {
    v15 = CWorld::ms_nCurrentScanCode + 1;
  }
  CWorld::ms_nCurrentScanCode = v15;
  *pNum = 0;
  if ( v29 <= v28 )
  {
    v16 = Range * Range;
    do
    {
      if ( v14 <= v13 )
      {
        v17 = v14;
        do
        {
          m_pHead = CWorld::ms_aLodPtrLists[30 * v29 + v17].m_pHead;
          while ( m_pHead )
          {
            v19 = *m_pHead;
            m_pHead = m_pHead->m_pNext;
            if ( *((unsigned __int16 *)v19.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
            {
              v20 = *((__int16 *)v19.m_pVoid + 19);
              *((_WORD *)v19.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
              if ( v20 == ModelIndx )
              {
                v21 = (float32x2_t *)*((_DWORD *)v19.m_pVoid + 5);
                v22 = v21 + 6;
                if ( !v21 )
                  v22 = (float32x2_t *)((char *)v19.m_pVoid + 4);
                v23.n64_u64[0] = vsub_f32(*(float32x2_t *)&Coors->x, (float32x2_t)v22->n64_u64[0]).n64_u64[0];
                v24 = vmul_f32(v23, v23).n64_u64[0];
                v25 = *(float *)&v24 + *((float *)&v24 + 1);
                v26 = v25 + (float)((float)(Coors->z - v22[1].n64_f32[0]) * (float)(Coors->z - v22[1].n64_f32[0]));
                if ( Dist2D )
                  v26 = v25;
                v27 = v26 < v16;
                if ( v26 < v16 )
                {
                  v7 = *pNum;
                  v27 = v7 < MaxNum;
                }
                if ( v27 )
                {
                  if ( ppResults )
                  {
                    ppResults[v7] = (CEntity *)v19.m_pVoid;
                    v7 = (unsigned __int16)*pNum;
                  }
                  *pNum = v7 + 1;
                }
              }
            }
          }
          v27 = v17++ < v13;
        }
        while ( v27 );
      }
      v27 = v29++ < v28;
    }
    while ( v27 );
  }
}
// 429202: variable 'v7' is possibly undefined

//----- (004292C8) --------------------------------------------------------
void __fastcall CWorld::FindObjectsKindaColliding(
        const CVector *Coors,
        float Range,
        int Dist2D,
        Int16 *pNum,
        int MaxNum,
        CEntity **ppResults,
        int bCheckBuildings,
        int bCheckVehicles,
        int bCheckPeds,
        int bCheckObjects,
        int bCheckDummies)
{
  float x; // s18
  float y; // s20
  float v17; // r10
  float v18; // r5
  float v19; // r4
  float v20; // r0
  int v21; // s18
  int v22; // s20
  uint16 v23; // r0
  int v25; // r0
  int v26; // r0
  int v27; // r1
  bool v28; // cc
  int v29; // r0
  CEntity **v30; // r6
  CPtrNode *m_pHead; // r10
  int v32; // r0
  CPtrNode v33; // kr00_8
  float32x2_t v34; // d16
  unsigned __int64 v35; // d1
  float v36; // s2
  float v37; // s0
  CPtrNode *v38; // r6
  int v39; // r0
  CPtrNode v40; // kr08_8
  float32x2_t v41; // d16
  unsigned __int64 v42; // d1
  float v43; // s2
  float v44; // s0
  CPtrNode *v45; // r6
  int v46; // r0
  CPtrNode v47; // kr10_8
  float32x2_t v48; // d16
  unsigned __int64 v49; // d1
  float v50; // s2
  float v51; // s0
  CPtrNode *v52; // r6
  int v53; // r0
  CPtrNode v54; // kr18_8
  float32x2_t v55; // d16
  unsigned __int64 v56; // d1
  float v57; // s2
  float v58; // s0
  CPtrNode *v59; // r6
  int v60; // r0
  CPtrNode v61; // kr20_8
  float32x2_t v62; // d16
  unsigned __int64 v63; // d1
  float v64; // s2
  float v65; // s0
  int v66; // r2
  int v67; // [sp+0h] [bp-B8h]
  int v68; // [sp+8h] [bp-B0h]
  int v69; // [sp+24h] [bp-94h]
  int v70; // [sp+2Ch] [bp-8Ch]
  int v71; // [sp+30h] [bp-88h]
  int v72; // [sp+34h] [bp-84h]
  int v73; // [sp+34h] [bp-84h]
  CVector v74; // [sp+60h] [bp-58h] BYREF

  x = Coors->x;
  y = Coors->y;
  v17 = floorf((float)((float)(Coors->x - Range) / 50.0) + 60.0);
  v18 = floorf((float)((float)(y - Range) / 50.0) + 60.0);
  v19 = floorf((float)((float)(x + Range) / 50.0) + 60.0);
  v20 = floorf((float)((float)(y + Range) / 50.0) + 60.0);
  v21 = (int)v19;
  v22 = (int)v17;
  v67 = (int)v20;
  v68 = (int)v18;
  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v23 = 1;
  }
  else
  {
    v23 = CWorld::ms_nCurrentScanCode + 1;
  }
  CWorld::ms_nCurrentScanCode = v23;
  *pNum = 0;
  if ( v68 <= v67 )
  {
    do
    {
      if ( v22 <= v21 )
      {
        v25 = 0;
        if ( v68 > 0 )
          v25 = v68;
        if ( v25 >= 119 )
          v25 = 119;
        v69 = 120 * v25;
        v26 = v22;
        do
        {
          v27 = v26;
          v72 = v26 & 0xF;
          v28 = v26 <= 0;
          v29 = 0;
          v71 = v27;
          if ( !v28 )
            v29 = v27;
          v30 = ppResults;
          if ( v29 >= 119 )
            v29 = 119;
          v70 = v29 + v69;
          if ( bCheckBuildings == 1 )
          {
            m_pHead = CWorld::ms_aSectors[v70].m_buildingPtrListArray.m_pHead;
            while ( m_pHead )
            {
              v33 = *m_pHead;
              m_pHead = m_pHead->m_pNext;
              if ( *((unsigned __int16 *)v33.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
              {
                *((_WORD *)v33.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
                CEntity::GetBoundCentre(&v74, (const CEntity *)v33.m_pVoid);
                v34.n64_u64[0] = vsub_f32(*(float32x2_t *)&Coors->x, *(float32x2_t *)&v74.x).n64_u64[0];
                v35 = vmul_f32(v34, v34).n64_u64[0];
                v36 = *(float *)&v35 + *((float *)&v35 + 1);
                v37 = v36 + (float)((float)(Coors->z - v74.z) * (float)(Coors->z - v74.z));
                if ( Dist2D )
                  v37 = v36;
                if ( sqrtf(v37) < (float)(CModelInfo::ms_modelInfoPtrs[*((__int16 *)v33.m_pVoid + 19)]->m_pColModel->m_sphereBound.m_fRadius
                                        + Range) )
                {
                  v32 = *pNum;
                  if ( v32 < MaxNum )
                  {
                    if ( v30 )
                    {
                      v30[v32] = (CEntity *)v33.m_pVoid;
                      LOWORD(v32) = *pNum;
                    }
                    *pNum = v32 + 1;
                  }
                }
              }
            }
          }
          ppResults = v30;
          v73 = (unsigned __int8)(16 * v68) | v72;
          if ( bCheckVehicles == 1 )
          {
            v38 = CWorld::ms_aRepeatSectors[v73].m_ptrListArray[0].m_pHead;
            while ( v38 )
            {
              v40 = *v38;
              v38 = v38->m_pNext;
              if ( *((unsigned __int16 *)v40.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
              {
                *((_WORD *)v40.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
                CEntity::GetBoundCentre(&v74, (const CEntity *)v40.m_pVoid);
                v41.n64_u64[0] = vsub_f32(*(float32x2_t *)&Coors->x, *(float32x2_t *)&v74.x).n64_u64[0];
                v42 = vmul_f32(v41, v41).n64_u64[0];
                v43 = *(float *)&v42 + *((float *)&v42 + 1);
                v44 = v43 + (float)((float)(Coors->z - v74.z) * (float)(Coors->z - v74.z));
                if ( Dist2D )
                  v44 = v43;
                if ( sqrtf(v44) < (float)(CModelInfo::ms_modelInfoPtrs[*((__int16 *)v40.m_pVoid + 19)]->m_pColModel->m_sphereBound.m_fRadius
                                        + Range) )
                {
                  v39 = *pNum;
                  if ( v39 < MaxNum )
                  {
                    if ( ppResults )
                    {
                      ppResults[v39] = (CEntity *)v40.m_pVoid;
                      LOWORD(v39) = *pNum;
                    }
                    *pNum = v39 + 1;
                  }
                }
              }
            }
          }
          if ( bCheckPeds == 1 )
          {
            v45 = CWorld::ms_aRepeatSectors[v73].m_ptrListArray[1].m_pHead;
            while ( v45 )
            {
              v47 = *v45;
              v45 = v45->m_pNext;
              if ( *((unsigned __int16 *)v47.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
              {
                *((_WORD *)v47.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
                CEntity::GetBoundCentre(&v74, (const CEntity *)v47.m_pVoid);
                v48.n64_u64[0] = vsub_f32(*(float32x2_t *)&Coors->x, *(float32x2_t *)&v74.x).n64_u64[0];
                v49 = vmul_f32(v48, v48).n64_u64[0];
                v50 = *(float *)&v49 + *((float *)&v49 + 1);
                v51 = v50 + (float)((float)(Coors->z - v74.z) * (float)(Coors->z - v74.z));
                if ( Dist2D )
                  v51 = v50;
                if ( sqrtf(v51) < (float)(CModelInfo::ms_modelInfoPtrs[*((__int16 *)v47.m_pVoid + 19)]->m_pColModel->m_sphereBound.m_fRadius
                                        + Range) )
                {
                  v46 = *pNum;
                  if ( v46 < MaxNum )
                  {
                    if ( ppResults )
                    {
                      ppResults[v46] = (CEntity *)v47.m_pVoid;
                      LOWORD(v46) = *pNum;
                    }
                    *pNum = v46 + 1;
                  }
                }
              }
            }
          }
          if ( bCheckObjects == 1 )
          {
            v52 = CWorld::ms_aRepeatSectors[v73].m_ptrListArray[2].m_pHead;
            while ( v52 )
            {
              v54 = *v52;
              v52 = v52->m_pNext;
              if ( *((unsigned __int16 *)v54.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
              {
                *((_WORD *)v54.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
                CEntity::GetBoundCentre(&v74, (const CEntity *)v54.m_pVoid);
                v55.n64_u64[0] = vsub_f32(*(float32x2_t *)&Coors->x, *(float32x2_t *)&v74.x).n64_u64[0];
                v56 = vmul_f32(v55, v55).n64_u64[0];
                v57 = *(float *)&v56 + *((float *)&v56 + 1);
                v58 = v57 + (float)((float)(Coors->z - v74.z) * (float)(Coors->z - v74.z));
                if ( Dist2D )
                  v58 = v57;
                if ( sqrtf(v58) < (float)(CModelInfo::ms_modelInfoPtrs[*((__int16 *)v54.m_pVoid + 19)]->m_pColModel->m_sphereBound.m_fRadius
                                        + Range) )
                {
                  v53 = *pNum;
                  if ( v53 < MaxNum )
                  {
                    if ( ppResults )
                    {
                      ppResults[v53] = (CEntity *)v54.m_pVoid;
                      LOWORD(v53) = *pNum;
                    }
                    *pNum = v53 + 1;
                  }
                }
              }
            }
          }
          if ( bCheckDummies == 1 )
          {
            v59 = CWorld::ms_aSectors[v70].m_dummyPtrListArray.m_pHead;
            while ( v59 )
            {
              v61 = *v59;
              v59 = v59->m_pNext;
              if ( *((unsigned __int16 *)v61.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
              {
                *((_WORD *)v61.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
                CEntity::GetBoundCentre(&v74, (const CEntity *)v61.m_pVoid);
                v62.n64_u64[0] = vsub_f32(*(float32x2_t *)&Coors->x, *(float32x2_t *)&v74.x).n64_u64[0];
                v63 = vmul_f32(v62, v62).n64_u64[0];
                v64 = *(float *)&v63 + *((float *)&v63 + 1);
                v65 = v64 + (float)((float)(Coors->z - v74.z) * (float)(Coors->z - v74.z));
                if ( Dist2D )
                  v65 = v64;
                if ( sqrtf(v65) < (float)(CModelInfo::ms_modelInfoPtrs[*((__int16 *)v61.m_pVoid + 19)]->m_pColModel->m_sphereBound.m_fRadius
                                        + Range) )
                {
                  v60 = *pNum;
                  if ( v60 < MaxNum )
                  {
                    if ( ppResults )
                    {
                      ppResults[v60] = (CEntity *)v61.m_pVoid;
                      LOWORD(v60) = *pNum;
                    }
                    *pNum = v60 + 1;
                  }
                }
              }
            }
          }
          v26 = v71 + 1;
        }
        while ( v71 < v21 );
      }
      v66 = v68++;
    }
    while ( v66 < v67 );
  }
}

//----- (00429864) --------------------------------------------------------
void __fastcall CWorld::FindObjectsKindaCollidingSectorList(
        CPtrList *list,
        const CVector *Coors,
        float Range,
        int Dist2D,
        Int16 *pNum,
        int MaxNum,
        CEntity **ppResults)
{
  __int64 v7; // r4
  float32x2_t v11; // d16
  unsigned __int64 v12; // d1
  float v13; // s2
  float v14; // s0
  int v15; // r0
  Int16 *v16; // r1
  CVector v17; // [sp+0h] [bp-38h] BYREF

  HIDWORD(v7) = (CPtrList)list->m_pHead;
  if ( list->m_pHead )
  {
    do
    {
      v7 = *(_QWORD *)HIDWORD(v7);
      if ( *(unsigned __int16 *)(v7 + 48) != CWorld::ms_nCurrentScanCode )
      {
        *(_WORD *)(v7 + 48) = CWorld::ms_nCurrentScanCode;
        CEntity::GetBoundCentre(&v17, (const CEntity *)v7);
        v11.n64_u64[0] = vsub_f32(*(float32x2_t *)&Coors->x, *(float32x2_t *)&v17.x).n64_u64[0];
        v12 = vmul_f32(v11, v11).n64_u64[0];
        v13 = *(float *)&v12 + *((float *)&v12 + 1);
        v14 = v13 + (float)((float)(Coors->z - v17.z) * (float)(Coors->z - v17.z));
        if ( Dist2D )
          v14 = v13;
        if ( sqrtf(v14) < (float)(CModelInfo::ms_modelInfoPtrs[*(__int16 *)(v7 + 38)]->m_pColModel->m_sphereBound.m_fRadius
                                + Range) )
        {
          v15 = *pNum;
          if ( v15 < MaxNum )
          {
            if ( ppResults )
            {
              ppResults[v15] = (CEntity *)v7;
              v16 = pNum;
              LOWORD(v15) = *pNum;
            }
            else
            {
              v16 = pNum;
            }
            *v16 = v15 + 1;
          }
        }
      }
    }
    while ( HIDWORD(v7) );
  }
}
// 429864: using guessed type CVector anonymous_0;

//----- (0042993C) --------------------------------------------------------
void __fastcall CWorld::FindObjectsIntersectingCube(
        const CVector *CoorsMin,
        const CVector *CoorsMax,
        Int16 *pNum,
        int MaxNum,
        CEntity **ppResults,
        int bCheckBuildings,
        int bCheckVehicles,
        int bCheckPeds,
        int bCheckObjects,
        int bCheckDummies)
{
  float y; // s18
  float v14; // r9
  float v15; // s22
  float v16; // r10
  float v17; // s20
  int v18; // s0
  int v19; // s18
  uint16 v20; // r0
  int v21; // r0
  int v22; // r10
  int v23; // r0
  int v24; // r11
  int v25; // r9
  int v27; // r2
  int v28; // [sp+10h] [bp-68h]
  int v29; // [sp+2Ch] [bp-4Ch]
  int v30; // [sp+30h] [bp-48h]

  y = CoorsMin->y;
  v14 = floorf((float)(CoorsMin->x / 50.0) + 60.0);
  v15 = CoorsMax->y;
  v16 = floorf((float)(CoorsMax->x / 50.0) + 60.0);
  v17 = floorf((float)(y / 50.0) + 60.0);
  v18 = (int)floorf((float)(v15 / 50.0) + 60.0);
  v19 = (int)v14;
  v28 = (int)v17;
  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v20 = 1;
  }
  else
  {
    v20 = CWorld::ms_nCurrentScanCode + 1;
  }
  CWorld::ms_nCurrentScanCode = v20;
  *pNum = 0;
  if ( v28 <= v18 )
  {
    v30 = (int)v16;
    do
    {
      if ( v19 <= v30 )
      {
        v21 = 0;
        if ( v28 > 0 )
          v21 = v28;
        if ( v21 >= 119 )
          v21 = 119;
        v22 = v19;
        v29 = 120 * v21;
        do
        {
          v23 = 0;
          if ( v22 > 0 )
            v23 = v22;
          if ( v23 >= 119 )
            v23 = 119;
          v24 = v23 + v29;
          if ( bCheckBuildings == 1 )
            CWorld::FindObjectsIntersectingCubeSectorList(
              &CWorld::ms_aSectors[v24].m_buildingPtrListArray,
              CoorsMin,
              CoorsMax,
              pNum,
              MaxNum,
              (int)ppResults);
          v25 = v22 & 0xF | (unsigned __int8)(16 * v28);
          if ( bCheckVehicles == 1 )
            CWorld::FindObjectsIntersectingCubeSectorList(
              (CPtrList *)&CWorld::ms_aRepeatSectors[v25],
              CoorsMin,
              CoorsMax,
              pNum,
              MaxNum,
              (int)ppResults);
          if ( bCheckPeds == 1 )
            CWorld::FindObjectsIntersectingCubeSectorList(
              &CWorld::ms_aRepeatSectors[v25].m_ptrListArray[1],
              CoorsMin,
              CoorsMax,
              pNum,
              MaxNum,
              (int)ppResults);
          if ( bCheckObjects == 1 )
            CWorld::FindObjectsIntersectingCubeSectorList(
              &CWorld::ms_aRepeatSectors[v25].m_ptrListArray[2],
              CoorsMin,
              CoorsMax,
              pNum,
              MaxNum,
              (int)ppResults);
          if ( bCheckDummies == 1 )
            CWorld::FindObjectsIntersectingCubeSectorList(
              &CWorld::ms_aSectors[v24].m_dummyPtrListArray,
              CoorsMin,
              CoorsMax,
              pNum,
              MaxNum,
              (int)ppResults);
        }
        while ( v22++ < v30 );
      }
      v27 = v28++;
    }
    while ( v27 < v18 );
  }
}

//----- (00429B88) --------------------------------------------------------
void __fastcall CWorld::FindObjectsIntersectingCubeSectorList(
        CPtrList *list,
        const CVector *CoorsMin,
        const CVector *CoorsMax,
        Int16 *pNum,
        int a5,
        int a6)
{
  CPtrNode *i; // r10
  CPtrNode v7; // kr00_8
  int v8; // r4
  int v9; // r0
  int v10; // r5
  CColModel *m_pColModel; // r4
  float m_fRadius; // s0
  float v13; // s2
  float v14; // s2
  float v15; // s0
  float z; // s2
  bool v17; // cc

  for ( i = list->m_pHead; i; *pNum = v10 + 1 )
  {
    while ( 1 )
    {
      v7 = *i;
      i = i->m_pNext;
      if ( *((unsigned __int16 *)v7.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
      {
        v8 = *((__int16 *)v7.m_pVoid + 19);
        v9 = *((_DWORD *)v7.m_pVoid + 5);
        *((_WORD *)v7.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
        v10 = v9 + 48;
        m_pColModel = CModelInfo::ms_modelInfoPtrs[v8]->m_pColModel;
        if ( !v9 )
          v10 = (int)v7.m_pVoid + 4;
        m_fRadius = m_pColModel->m_sphereBound.m_fRadius;
        if ( (float)(*(float *)v10 + m_fRadius) >= CoorsMin->x && (float)(*(float *)v10 - m_fRadius) <= CoorsMax->x )
        {
          v13 = *(float *)(v10 + 4);
          if ( (float)(m_fRadius + v13) >= CoorsMin->y && (float)(v13 - m_fRadius) <= CoorsMax->y )
          {
            v14 = *(float *)(v10 + 8);
            if ( (float)(m_fRadius + v14) >= CoorsMin->z )
            {
              v15 = v14 - m_fRadius;
              z = CoorsMax->z;
              v17 = v15 < z;
              if ( v15 <= z )
              {
                v10 = *pNum;
                v17 = v10 < a5;
              }
              if ( v17 )
                break;
            }
          }
        }
      }
      if ( !i )
        return;
    }
    if ( a6 )
    {
      *(_DWORD *)(a6 + 4 * v10) = v7.m_pVoid;
      LOWORD(v10) = *pNum;
    }
  }
}

//----- (00429C84) --------------------------------------------------------
void __fastcall CWorld::FindObjectsIntersectingAngledCollisionBox(
        const CBox *Box,
        const CMatrix *RotationOfBoxMatrix,
        const CVector *BoxCentre,
        float MinX,
        float MinY,
        float MaxX,
        float MaxY,
        Int16 *pNum,
        int MaxNum,
        CEntity **ppResults,
        int bCheckBuildings,
        int bCheckVehicles,
        int bCheckPeds,
        int bCheckObjects,
        int bCheckDummies)
{
  float v18; // r8
  float v19; // s18
  float v20; // r9
  uint16 v21; // r0
  int v22; // r0
  int v23; // r10
  int v24; // r0
  int v25; // r9
  int v26; // r8
  int v28; // r2
  int v29; // [sp+Ch] [bp-5Ch]
  int v30; // [sp+10h] [bp-58h]
  int v31; // [sp+14h] [bp-54h]
  int v32; // [sp+30h] [bp-38h]
  int v33; // [sp+34h] [bp-34h]

  v18 = floorf((float)(MinX / 50.0) + 60.0);
  v19 = floorf((float)(MinY / 50.0) + 60.0);
  v20 = floorf((float)(MaxX / 50.0) + 60.0);
  v29 = (int)floorf((float)(MaxY / 50.0) + 60.0);
  v31 = (int)v19;
  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v21 = 1;
  }
  else
  {
    v21 = CWorld::ms_nCurrentScanCode + 1;
  }
  CWorld::ms_nCurrentScanCode = v21;
  *pNum = 0;
  if ( v31 <= v29 )
  {
    v30 = (int)v18;
    v33 = (int)v20;
    do
    {
      if ( v30 <= v33 )
      {
        v22 = 0;
        if ( v31 > 0 )
          v22 = v31;
        if ( v22 >= 119 )
          v22 = 119;
        v23 = v30;
        v32 = 120 * v22;
        do
        {
          v24 = 0;
          if ( v23 > 0 )
            v24 = v23;
          if ( v24 >= 119 )
            v24 = 119;
          v25 = v24 + v32;
          if ( bCheckBuildings == 1 )
            CWorld::FindObjectsIntersectingAngledCollisionBoxSectorList(
              &CWorld::ms_aSectors[v25].m_buildingPtrListArray,
              Box,
              RotationOfBoxMatrix,
              BoxCentre,
              pNum,
              MaxNum,
              ppResults);
          v26 = v23 & 0xF | (unsigned __int8)(16 * v31);
          if ( bCheckVehicles == 1 )
            CWorld::FindObjectsIntersectingAngledCollisionBoxSectorList(
              (CPtrList *)&CWorld::ms_aRepeatSectors[v26],
              Box,
              RotationOfBoxMatrix,
              BoxCentre,
              pNum,
              MaxNum,
              ppResults);
          if ( bCheckPeds == 1 )
            CWorld::FindObjectsIntersectingAngledCollisionBoxSectorList(
              &CWorld::ms_aRepeatSectors[v26].m_ptrListArray[1],
              Box,
              RotationOfBoxMatrix,
              BoxCentre,
              pNum,
              MaxNum,
              ppResults);
          if ( bCheckObjects == 1 )
            CWorld::FindObjectsIntersectingAngledCollisionBoxSectorList(
              &CWorld::ms_aRepeatSectors[v26].m_ptrListArray[2],
              Box,
              RotationOfBoxMatrix,
              BoxCentre,
              pNum,
              MaxNum,
              ppResults);
          if ( bCheckDummies == 1 )
            CWorld::FindObjectsIntersectingAngledCollisionBoxSectorList(
              &CWorld::ms_aSectors[v25].m_dummyPtrListArray,
              Box,
              RotationOfBoxMatrix,
              BoxCentre,
              pNum,
              MaxNum,
              ppResults);
        }
        while ( v23++ < v33 );
      }
      v28 = v31++;
    }
    while ( v28 < v29 );
  }
}

//----- (00429EE4) --------------------------------------------------------
void __fastcall CWorld::FindObjectsIntersectingAngledCollisionBoxSectorList(
        CPtrList *list,
        const CBox *Box,
        const CMatrix *RotationOfBoxMatrix,
        const CVector *BoxCentre,
        Int16 *pNum,
        int MaxNum,
        CEntity **ppResults)
{
  CPtrNode *m_pHead; // r6
  CPtrNode v10; // kr00_8
  int v11; // r1
  RwReal *v12; // r0
  __int64 v13; // d16
  float y; // s6
  float z; // s8
  int v16; // r0
  Int16 *v17; // r1
  CVector v19; // [sp+8h] [bp-40h] BYREF
  CSphere v[3]; // [sp+18h] [bp-30h] BYREF

  m_pHead = list->m_pHead;
  while ( m_pHead )
  {
    v10 = *m_pHead;
    m_pHead = m_pHead->m_pNext;
    if ( *((unsigned __int16 *)v10.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
    {
      v11 = *((_DWORD *)v10.m_pVoid + 5);
      *((_WORD *)v10.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
      v12 = (RwReal *)(v11 + 48);
      if ( !v11 )
        v12 = (RwReal *)((char *)v10.m_pVoid + 4);
      v13 = *(_QWORD *)v12;
      v[0].m_vecCentre.z = v12[2];
      *(_QWORD *)&v[0].m_vecCentre.x = v13;
      v[0].m_fRadius = CModelInfo::ms_modelInfoPtrs[*((__int16 *)v10.m_pVoid + 19)]->m_pColModel->m_sphereBound.m_fRadius;
      y = BoxCentre->y;
      z = BoxCentre->z;
      v[0].m_vecCentre.x = *(float *)&v13 - BoxCentre->x;
      v[0].m_vecCentre.y = *((float *)&v13 + 1) - y;
      v[0].m_vecCentre.z = v[0].m_vecCentre.z - z;
      Multiply3x3(&v19, &v[0].m_vecCentre, RotationOfBoxMatrix);
      v[0].m_vecCentre = v19;
      if ( CCollision::TestSphereBox(v, Box) )
      {
        v16 = *pNum;
        if ( v16 < MaxNum )
        {
          if ( ppResults )
          {
            ppResults[v16] = (CEntity *)v10.m_pVoid;
            v17 = pNum;
            LOWORD(v16) = *pNum;
          }
          else
          {
            v17 = pNum;
          }
          *v17 = v16 + 1;
        }
      }
    }
  }
}

//----- (00429FD0) --------------------------------------------------------
void __fastcall CWorld::FindMissionEntitiesIntersectingCube(
        const CVector *CoorsMin,
        const CVector *CoorsMax,
        Int16 *pNum,
        int MaxNum,
        CEntity **ppResults,
        int bCheckVehicles,
        int bCheckPeds,
        int bCheckObjects)
{
  float v10; // s4
  float v11; // s18
  float v12; // s0
  float v13; // s16
  float v14; // s20
  float v15; // r9
  int v16; // s0
  int v17; // s16
  int v18; // s18
  uint16 v19; // r0
  int v20; // r8
  int v21; // r11
  bool v22; // cc
  int v23; // [sp+20h] [bp-50h]

  v10 = (float)(CoorsMin->y / 50.0) + 60.0;
  v11 = floorf((float)(CoorsMin->x / 50.0) + 60.0);
  v12 = (float)(CoorsMax->x / 50.0) + 60.0;
  v13 = (float)(CoorsMax->y / 50.0) + 60.0;
  v14 = floorf(v10);
  v15 = floorf(v12);
  v16 = (int)floorf(v13);
  v18 = (int)v11;
  v23 = (int)v14;
  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v19 = 1;
  }
  else
  {
    v19 = CWorld::ms_nCurrentScanCode + 1;
  }
  CWorld::ms_nCurrentScanCode = v19;
  *pNum = 0;
  if ( v23 <= v16 )
  {
    v17 = (int)v15;
    do
    {
      if ( v18 <= v17 )
      {
        v20 = v18;
        do
        {
          v21 = v20 & 0xF | (unsigned __int8)(16 * v23);
          if ( bCheckVehicles == 1 )
            CWorld::FindMissionEntitiesIntersectingCubeSectorList(
              (CPtrList *)&CWorld::ms_aRepeatSectors[v21],
              CoorsMin,
              CoorsMax,
              pNum,
              MaxNum,
              ppResults,
              1LL,
              0);
          if ( bCheckPeds == 1 )
            CWorld::FindMissionEntitiesIntersectingCubeSectorList(
              &CWorld::ms_aRepeatSectors[v21].m_ptrListArray[1],
              CoorsMin,
              CoorsMax,
              pNum,
              MaxNum,
              ppResults,
              0x100000000LL,
              0);
          if ( bCheckObjects == 1 )
            CWorld::FindMissionEntitiesIntersectingCubeSectorList(
              &CWorld::ms_aRepeatSectors[v21].m_ptrListArray[2],
              CoorsMin,
              CoorsMax,
              pNum,
              MaxNum,
              ppResults,
              0LL,
              0);
          v22 = v20++ < v17;
        }
        while ( v22 );
      }
      v22 = v23++ < v16;
    }
    while ( v22 );
  }
}

//----- (0042A1A4) --------------------------------------------------------
void __fastcall CWorld::FindMissionEntitiesIntersectingCubeSectorList(
        CPtrList *list,
        const CVector *CoorsMin,
        const CVector *CoorsMax,
        Int16 *pNum,
        int MaxNum,
        CEntity **ppResults,
        __int64 EntitiesAreVehicles,
        bool EntitiesAreObjects)
{
  CPtrNode *m_pHead; // r0
  int v9; // r8
  CPtrNode v10; // kr00_8
  int v11; // r6
  float *v12; // r5
  float m_fRadius; // s0
  float v14; // s2
  float v15; // s2
  int v16; // r5

  m_pHead = list->m_pHead;
  if ( m_pHead )
  {
    v9 = 1096;
    if ( (_DWORD)EntitiesAreVehicles )
      v9 = 1192;
    do
    {
      v10 = *m_pHead;
      m_pHead = m_pHead->m_pNext;
      if ( *((unsigned __int16 *)v10.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
      {
        *((_WORD *)v10.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
        if ( EntitiesAreVehicles )
        {
          if ( *((_BYTE *)v10.m_pVoid + v9) == 2 )
            goto LABEL_9;
        }
        else if ( (*((unsigned __int8 *)v10.m_pVoid + 320) | 4) == 6 )
        {
LABEL_9:
          v11 = *((_DWORD *)v10.m_pVoid + 5);
          v12 = (float *)(v11 + 48);
          if ( !v11 )
            v12 = (float *)((char *)v10.m_pVoid + 4);
          m_fRadius = CModelInfo::ms_modelInfoPtrs[*((__int16 *)v10.m_pVoid + 19)]->m_pColModel->m_sphereBound.m_fRadius;
          if ( (float)(*v12 + m_fRadius) >= CoorsMin->x && (float)(*v12 - m_fRadius) <= CoorsMax->x )
          {
            v14 = v12[1];
            if ( (float)(m_fRadius + v14) >= CoorsMin->y && (float)(v14 - m_fRadius) <= CoorsMax->y )
            {
              v15 = v12[2];
              if ( (float)(m_fRadius + v15) >= CoorsMin->z && (float)(v15 - m_fRadius) <= CoorsMax->z )
              {
                v16 = *pNum;
                if ( v16 < MaxNum )
                {
                  if ( ppResults )
                  {
                    ppResults[v16] = (CEntity *)v10.m_pVoid;
                    LOWORD(v16) = *pNum;
                  }
                  *pNum = v16 + 1;
                }
              }
            }
          }
        }
      }
    }
    while ( m_pHead );
  }
}

//----- (0042A2C8) --------------------------------------------------------
CEntity *__fastcall CWorld::FindNearestObjectOfType(
        Int32 ModelIndex,
        const CVector *Coors,
        float Range,
        int Dist2D,
        int bCheckBuildings,
        int bCheckVehicles,
        int bCheckPeds,
        int bCheckObjects,
        int bCheckDummies)
{
  float v10; // s16
  float x; // s18
  float y; // s20
  float v15; // r8
  float v16; // r4
  float v17; // r5
  int v18; // s18
  int v19; // s0
  int v20; // r3
  uint16 v21; // r1
  CEntity *result; // r0
  int v23; // r6
  int v24; // r2
  int v25; // r2
  int v26; // lr
  bool v27; // cc
  int v28; // r2
  __int64 v29; // r2
  float32x2_t *v30; // r4
  float32x2_t *v31; // r6
  float32x2_t v32; // d16
  unsigned __int64 v33; // d1
  float v34; // s2
  float v35; // s0
  float v36; // s0
  int v37; // r8
  int v38; // r12
  CPtrNode *m_pHead; // r2
  float32x2_t *v40; // r6
  float32x2_t *v41; // r5
  float32x2_t v42; // d16
  unsigned __int64 v43; // d1
  float v44; // s2
  float v45; // s0
  float v46; // s0
  CPtrNode v47; // kr00_8
  int v48; // r4
  CPtrNode *v49; // r2
  float32x2_t *v50; // r4
  float32x2_t *v51; // r6
  float32x2_t v52; // d16
  unsigned __int64 v53; // d1
  float v54; // s2
  float v55; // s0
  float v56; // s0
  CPtrNode v57; // kr08_8
  int v58; // r4
  CPtrNode *v59; // r2
  float32x2_t *v60; // r6
  float32x2_t *v61; // r4
  float32x2_t v62; // d16
  unsigned __int64 v63; // d1
  float v64; // s2
  float v65; // s0
  float v66; // s0
  CPtrNode v67; // kr10_8
  int v68; // r4
  CPtrNode *v69; // r2
  float32x2_t *v70; // r6
  float32x2_t *v71; // r4
  float32x2_t v72; // d16
  unsigned __int64 v73; // d1
  float v74; // s2
  float v75; // s0
  float v76; // s0
  CPtrNode v77; // kr18_8
  int v78; // r4
  int v79; // [sp+0h] [bp-78h]
  int v80; // [sp+4h] [bp-74h]
  int v81; // [sp+8h] [bp-70h]
  int v82; // [sp+20h] [bp-58h]
  int v83; // [sp+24h] [bp-54h]
  int v84; // [sp+2Ch] [bp-4Ch]

  v10 = Range;
  x = Coors->x;
  y = Coors->y;
  v15 = floorf((float)((float)(Coors->x - Range) / 50.0) + 60.0);
  v16 = floorf((float)((float)(x + v10) / 50.0) + 60.0);
  v17 = floorf((float)((float)(y + v10) / 50.0) + 60.0);
  v18 = (int)v16;
  v19 = (int)floorf((float)((float)(y - v10) / 50.0) + 60.0);
  v20 = v19;
  v80 = (int)v17;
  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v20 = v19;
    v21 = 1;
  }
  else
  {
    v21 = CWorld::ms_nCurrentScanCode + 1;
  }
  CWorld::ms_nCurrentScanCode = v21;
  result = 0;
  if ( v20 <= v80 )
  {
    v23 = (int)v15;
    v79 = (int)v15;
    do
    {
      v81 = v20;
      if ( v23 <= v18 )
      {
        v24 = 0;
        if ( v20 > 0 )
          v24 = v20;
        if ( v24 >= 119 )
          v24 = 119;
        v83 = 120 * v24;
        v82 = (unsigned __int8)(16 * v20);
        v25 = v23;
        do
        {
          v26 = v25;
          v27 = v25 <= 0;
          v28 = 0;
          if ( !v27 )
            v28 = v26;
          if ( v28 >= 119 )
            v28 = 119;
          v84 = v83 + v28;
          if ( bCheckBuildings == 1 )
          {
            HIDWORD(v29) = CWorld::ms_aSectors[v83 + v28].m_buildingPtrListArray.m_pHead;
            while ( HIDWORD(v29) )
            {
              v29 = *(_QWORD *)HIDWORD(v29);
              if ( *(unsigned __int16 *)(v29 + 48) != v21 )
              {
                v37 = *(__int16 *)(v29 + 38);
                *(_WORD *)(v29 + 48) = v21;
                if ( ModelIndex < 0 || v37 == ModelIndex )
                {
                  v30 = *(float32x2_t **)(v29 + 20);
                  v31 = v30 + 6;
                  if ( !v30 )
                    v31 = (float32x2_t *)(v29 + 4);
                  v32.n64_u64[0] = vsub_f32(*(float32x2_t *)&Coors->x, (float32x2_t)v31->n64_u64[0]).n64_u64[0];
                  v33 = vmul_f32(v32, v32).n64_u64[0];
                  v34 = *(float *)&v33 + *((float *)&v33 + 1);
                  v35 = v34 + (float)((float)(Coors->z - v31[1].n64_f32[0]) * (float)(Coors->z - v31[1].n64_f32[0]));
                  if ( Dist2D )
                    v35 = v34;
                  v36 = sqrtf(v35);
                  if ( v36 < v10 )
                  {
                    result = (CEntity *)v29;
                    v10 = v36;
                  }
                }
              }
            }
          }
          v38 = v26 & 0xF | v82;
          if ( bCheckVehicles == 1 )
          {
            m_pHead = CWorld::ms_aRepeatSectors[v38].m_ptrListArray[0].m_pHead;
            while ( m_pHead )
            {
              v47 = *m_pHead;
              m_pHead = m_pHead->m_pNext;
              if ( *((unsigned __int16 *)v47.m_pVoid + 24) != v21 )
              {
                v48 = *((__int16 *)v47.m_pVoid + 19);
                *((_WORD *)v47.m_pVoid + 24) = v21;
                if ( ModelIndex < 0 || v48 == ModelIndex )
                {
                  v40 = (float32x2_t *)*((_DWORD *)v47.m_pVoid + 5);
                  v41 = v40 + 6;
                  if ( !v40 )
                    v41 = (float32x2_t *)((char *)v47.m_pVoid + 4);
                  v42.n64_u64[0] = vsub_f32(*(float32x2_t *)&Coors->x, (float32x2_t)v41->n64_u64[0]).n64_u64[0];
                  v43 = vmul_f32(v42, v42).n64_u64[0];
                  v44 = *(float *)&v43 + *((float *)&v43 + 1);
                  v45 = v44 + (float)((float)(Coors->z - v41[1].n64_f32[0]) * (float)(Coors->z - v41[1].n64_f32[0]));
                  if ( Dist2D )
                    v45 = v44;
                  v46 = sqrtf(v45);
                  if ( v46 < v10 )
                  {
                    result = (CEntity *)v47.m_pVoid;
                    v10 = v46;
                  }
                }
              }
            }
          }
          if ( bCheckPeds == 1 )
          {
            v49 = CWorld::ms_aRepeatSectors[v38].m_ptrListArray[1].m_pHead;
            while ( v49 )
            {
              v57 = *v49;
              v49 = v49->m_pNext;
              if ( *((unsigned __int16 *)v57.m_pVoid + 24) != v21 )
              {
                v58 = *((__int16 *)v57.m_pVoid + 19);
                *((_WORD *)v57.m_pVoid + 24) = v21;
                if ( ModelIndex < 0 || v58 == ModelIndex )
                {
                  v50 = (float32x2_t *)*((_DWORD *)v57.m_pVoid + 5);
                  v51 = v50 + 6;
                  if ( !v50 )
                    v51 = (float32x2_t *)((char *)v57.m_pVoid + 4);
                  v52.n64_u64[0] = vsub_f32(*(float32x2_t *)&Coors->x, (float32x2_t)v51->n64_u64[0]).n64_u64[0];
                  v53 = vmul_f32(v52, v52).n64_u64[0];
                  v54 = *(float *)&v53 + *((float *)&v53 + 1);
                  v55 = v54 + (float)((float)(Coors->z - v51[1].n64_f32[0]) * (float)(Coors->z - v51[1].n64_f32[0]));
                  if ( Dist2D )
                    v55 = v54;
                  v56 = sqrtf(v55);
                  if ( v56 < v10 )
                  {
                    result = (CEntity *)v57.m_pVoid;
                    v10 = v56;
                  }
                }
              }
            }
          }
          if ( bCheckObjects == 1 )
          {
            v59 = CWorld::ms_aRepeatSectors[v38].m_ptrListArray[2].m_pHead;
            while ( v59 )
            {
              v67 = *v59;
              v59 = v59->m_pNext;
              if ( *((unsigned __int16 *)v67.m_pVoid + 24) != v21 )
              {
                v68 = *((__int16 *)v67.m_pVoid + 19);
                *((_WORD *)v67.m_pVoid + 24) = v21;
                if ( ModelIndex < 0 || v68 == ModelIndex )
                {
                  v60 = (float32x2_t *)*((_DWORD *)v67.m_pVoid + 5);
                  v61 = v60 + 6;
                  if ( !v60 )
                    v61 = (float32x2_t *)((char *)v67.m_pVoid + 4);
                  v62.n64_u64[0] = vsub_f32(*(float32x2_t *)&Coors->x, (float32x2_t)v61->n64_u64[0]).n64_u64[0];
                  v63 = vmul_f32(v62, v62).n64_u64[0];
                  v64 = *(float *)&v63 + *((float *)&v63 + 1);
                  v65 = v64 + (float)((float)(Coors->z - v61[1].n64_f32[0]) * (float)(Coors->z - v61[1].n64_f32[0]));
                  if ( Dist2D )
                    v65 = v64;
                  v66 = sqrtf(v65);
                  if ( v66 < v10 )
                  {
                    result = (CEntity *)v67.m_pVoid;
                    v10 = v66;
                  }
                }
              }
            }
          }
          if ( bCheckDummies == 1 )
          {
            v69 = CWorld::ms_aSectors[v84].m_dummyPtrListArray.m_pHead;
            while ( v69 )
            {
              v77 = *v69;
              v69 = v69->m_pNext;
              if ( *((unsigned __int16 *)v77.m_pVoid + 24) != v21 )
              {
                v78 = *((__int16 *)v77.m_pVoid + 19);
                *((_WORD *)v77.m_pVoid + 24) = v21;
                if ( ModelIndex < 0 || v78 == ModelIndex )
                {
                  v70 = (float32x2_t *)*((_DWORD *)v77.m_pVoid + 5);
                  v71 = v70 + 6;
                  if ( !v70 )
                    v71 = (float32x2_t *)((char *)v77.m_pVoid + 4);
                  v72.n64_u64[0] = vsub_f32(*(float32x2_t *)&Coors->x, (float32x2_t)v71->n64_u64[0]).n64_u64[0];
                  v73 = vmul_f32(v72, v72).n64_u64[0];
                  v74 = *(float *)&v73 + *((float *)&v73 + 1);
                  v75 = v74 + (float)((float)(Coors->z - v71[1].n64_f32[0]) * (float)(Coors->z - v71[1].n64_f32[0]));
                  if ( Dist2D )
                    v75 = v74;
                  v76 = sqrtf(v75);
                  if ( v76 < v10 )
                  {
                    result = (CEntity *)v77.m_pVoid;
                    v10 = v76;
                  }
                }
              }
            }
          }
          v25 = v26 + 1;
        }
        while ( v26 < v18 );
      }
      v23 = v79;
      v20 = v81 + 1;
    }
    while ( v81 < v80 );
  }
  return result;
}

//----- (0042A71C) --------------------------------------------------------
void __fastcall CWorld::FindNearestObjectOfTypeSectorList(
        Int32 ModelIndex,
        CPtrList *list,
        const CVector *Coors,
        float Range,
        int a5,
        void **a6,
        float *a7)
{
  CPtrNode *m_pHead; // r1
  int v8; // r9
  CPtrNode v9; // kr00_8
  int v10; // r6
  float32x2_t *v11; // r6
  float32x2_t *v12; // r4
  float32x2_t v13; // d16
  unsigned __int64 v14; // d1
  float v15; // s2
  float v16; // s0
  float v17; // s0

  m_pHead = list->m_pHead;
  if ( m_pHead )
  {
    v8 = CWorld::ms_nCurrentScanCode;
    do
    {
      while ( 1 )
      {
        v9 = *m_pHead;
        m_pHead = m_pHead->m_pNext;
        if ( *((unsigned __int16 *)v9.m_pVoid + 24) != v8 )
        {
          v10 = *((__int16 *)v9.m_pVoid + 19);
          *((_WORD *)v9.m_pVoid + 24) = v8;
          if ( ModelIndex < 0 || v10 == ModelIndex )
            break;
        }
        if ( !m_pHead )
          return;
      }
      v11 = (float32x2_t *)*((_DWORD *)v9.m_pVoid + 5);
      v12 = v11 + 6;
      if ( !v11 )
        v12 = (float32x2_t *)((char *)v9.m_pVoid + 4);
      v13.n64_u64[0] = vsub_f32(*(float32x2_t *)&Coors->x, (float32x2_t)v12->n64_u64[0]).n64_u64[0];
      v14 = vmul_f32(v13, v13).n64_u64[0];
      v15 = *(float *)&v14 + *((float *)&v14 + 1);
      v16 = v15 + (float)((float)(Coors->z - v12[1].n64_f32[0]) * (float)(Coors->z - v12[1].n64_f32[0]));
      if ( a5 )
        v16 = v15;
      v17 = sqrtf(v16);
      if ( v17 < *a7 )
      {
        *a7 = v17;
        *a6 = v9.m_pVoid;
      }
    }
    while ( m_pHead );
  }
}

//----- (0042A7C4) --------------------------------------------------------
float __fastcall CWorld::FindGroundZForCoord(float x, float y)
{
  float v2; // s0
  CEntity *refEntityPtr; // [sp+1Ch] [bp-44h] BYREF
  CColPoint colPoint; // [sp+20h] [bp-40h] BYREF
  CVector vecStart; // [sp+4Ch] [bp-14h] BYREF

  vecStart.x = x;
  vecStart.y = y;
  vecStart.z = 1000.0;
  v2 = 20.0;
  if ( CWorld::ProcessVerticalLine(&vecStart, -1000.0, &colPoint, &refEntityPtr, 1, 0, 0, 0, 1, 0, 0) )
    return colPoint.m_vecPosition.z;
  return v2;
}

//----- (0042A810) --------------------------------------------------------
float __fastcall CWorld::FindGroundZFor3DCoord(float x, float y, float z, bool *pBool, CEntity **ppEnt)
{
  float v6; // s0
  CEntity *refEntityPtr; // [sp+1Ch] [bp-44h] BYREF
  CColPoint colPoint; // [sp+20h] [bp-40h] BYREF
  CVector vecStart; // [sp+4Ch] [bp-14h] BYREF

  vecStart.x = x;
  vecStart.y = y;
  vecStart.z = z;
  if ( CWorld::ProcessVerticalLine(&vecStart, -1000.0, &colPoint, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0) )
  {
    if ( pBool )
      *pBool = 1;
    if ( ppEnt )
      *ppEnt = refEntityPtr;
    return colPoint.m_vecPosition.z;
  }
  else
  {
    v6 = 0.0;
    if ( pBool )
      *pBool = 0;
    if ( ppEnt )
      *ppEnt = 0;
  }
  return v6;
}

//----- (0042A878) --------------------------------------------------------
float __fastcall CWorld::FindRoofZFor3DCoord(float x, float y, float z, bool *pBool)
{
  float v5; // s0
  CEntity *refEntityPtr; // [sp+1Ch] [bp-44h] BYREF
  CColPoint colPoint; // [sp+20h] [bp-40h] BYREF
  CVector vecStart; // [sp+4Ch] [bp-14h] BYREF

  vecStart.x = x;
  vecStart.y = y;
  vecStart.z = z;
  if ( CWorld::ProcessVerticalLine(&vecStart, 1000.0, &colPoint, &refEntityPtr, 1, 0, 0, 0, 1, 0, 0) )
  {
    if ( pBool )
      *pBool = 1;
    return colPoint.m_vecPosition.z;
  }
  else
  {
    v5 = 20.0;
    if ( pBool )
      *pBool = 0;
  }
  return v5;
}

//----- (0042A8CA) --------------------------------------------------------
float __fastcall CWorld::FindLowestZForCoord(float x, float y)
{
  float v2; // s0
  CEntity *refEntityPtr; // [sp+1Ch] [bp-44h] BYREF
  CColPoint colPoint; // [sp+20h] [bp-40h] BYREF
  CVector vecStart; // [sp+4Ch] [bp-14h] BYREF

  vecStart.x = x;
  vecStart.y = y;
  vecStart.z = -1000.0;
  v2 = 20.0;
  if ( CWorld::ProcessVerticalLine(&vecStart, 1000.0, &colPoint, &refEntityPtr, 1, 0, 0, 0, 1, 0, 0) )
    return colPoint.m_vecPosition.z;
  return v2;
}

//----- (0042A918) --------------------------------------------------------
void __fastcall CWorld::RemoveReferencesToDeletedObject(CEntity *pToBeDeletedEntity)
{
  CPedPool *v2; // r11
  int32 m_nSize; // r0
  int v4; // r4
  int v5; // r6
  CPool<CPed,CCopPed>::StorageType *m_aStorage; // r5
  int v7; // r0
  bool v8; // zf
  CVehiclePool *v9; // r9
  int32 v10; // r0
  int v11; // r6
  int v12; // r4
  CPool<CVehicle,CHeli>::StorageType *v13; // r5
  bool v14; // zf
  uint8 *v15; // r11
  CObjectPool *v16; // r4
  int32 v17; // r0
  int v18; // r6
  int v19; // r5

  v2 = CPools::ms_pPedPool;
  m_nSize = CPools::ms_pPedPool->m_nSize;
  if ( m_nSize )
  {
    v4 = m_nSize - 1;
    v5 = 1996 * m_nSize - 608;
    do
    {
      if ( (v2->m_aFlags[v4] & 0x80u) == 0 )
      {
        m_aStorage = v2->m_aStorage;
        v7 = (int)&(*v2->m_aStorage)[-1996];
        v8 = v7 + v5 == -608;
        if ( v7 + v5 != -608 )
          v8 = v7 - (_DWORD)pToBeDeletedEntity + v5 == -608;
        if ( !v8 )
        {
          CPhysical::RemoveRefsToEntity((CPhysical *)&(*m_aStorage)[v5 - 1388], pToBeDeletedEntity);
          if ( *(CEntity **)&(*m_aStorage)[v5] == pToBeDeletedEntity )
            *(_DWORD *)&(*m_aStorage)[v5] = 0;
        }
      }
      --v4;
      v5 -= 1996;
    }
    while ( v4 != -1 );
  }
  v9 = CPools::ms_pVehiclePool;
  v10 = CPools::ms_pVehiclePool->m_nSize;
  if ( v10 )
  {
    v11 = v10 - 1;
    v12 = 2604 * v10 - 2604;
    do
    {
      if ( (v9->m_aFlags[v11] & 0x80u) == 0 )
      {
        v13 = v9->m_aStorage;
        v15 = &(*v9->m_aStorage)[v12];
        v14 = v15 == 0;
        if ( v15 )
          v14 = (char *)v13 - (char *)pToBeDeletedEntity + v12 == 0;
        if ( !v14 )
        {
          CPhysical::RemoveRefsToEntity((CPhysical *)&(*v9->m_aStorage)[v12], pToBeDeletedEntity);
          (*(void (__fastcall **)(uint8 *, CEntity *))(*(_DWORD *)&(*v13)[v12] + 164))(v15, pToBeDeletedEntity);
        }
      }
      --v11;
      v12 -= 2604;
    }
    while ( v11 != -1 );
  }
  v16 = CPools::ms_pObjectPool;
  v17 = CPools::ms_pObjectPool->m_nSize;
  if ( v17 )
  {
    v18 = v17 - 1;
    v19 = 420 * v17 - 420;
    do
    {
      if ( (v16->m_aFlags[v18] & 0x80u) == 0 && &(*v16->m_aStorage)[v19] )
      {
        if ( (char *)v16->m_aStorage - (char *)pToBeDeletedEntity + v19 )
          CPhysical::RemoveRefsToEntity((CPhysical *)&(*v16->m_aStorage)[v19], pToBeDeletedEntity);
      }
      --v18;
      v19 -= 420;
    }
    while ( v18 != -1 );
  }
}

//----- (0042AA3C) --------------------------------------------------------
void __fastcall CWorld::SetPedsOnFire(
        float CenterX,
        float CenterY,
        float CenterZ,
        float Radius,
        int NumGenerationsAllowed)
{
  CPedPool *v5; // r5
  int32 m_nSize; // r4
  int v8; // r12
  int v10; // r6
  int v13; // r4
  int v14; // r0
  int v15; // r3
  float *v16; // r2
  float v17; // s2
  bool v18; // zf
  _BOOL4 IsPlayer; // r0
  CEntity *v20; // r1
  int v21; // r10
  CPool<CPed,CCopPed>::StorageType *m_aStorage; // r1
  uint8 *v23; // r10
  bool v24; // zf
  bool v25; // zf

  v5 = CPools::ms_pPedPool;
  m_nSize = CPools::ms_pPedPool->m_nSize;
  if ( m_nSize )
  {
    v8 = NumGenerationsAllowed;
    v10 = 1996 * m_nSize - 896;
    v13 = m_nSize - 1;
    do
    {
      if ( (v5->m_aFlags[v13] & 0x80u) == 0 )
      {
        m_aStorage = v5->m_aStorage;
        v23 = &(*v5->m_aStorage)[v10];
        v24 = v23 == (uint8 *)&elf_hash_bucket[212];
        if ( v23 != (uint8 *)&elf_hash_bucket[212] )
          v24 = *(_DWORD *)&(*m_aStorage)[v10] == 55;
        if ( !v24 )
        {
          v25 = v23[57] << 31 == 0;
          if ( !(v23[57] << 31) )
            v25 = *((_DWORD *)v23 + 187) == 0;
          if ( v25 )
          {
            v14 = *((_DWORD *)v23 - 258);
            if ( (v14 & 0x80000) == 0 )
            {
              v15 = *((_DWORD *)v23 - 270);
              v16 = (float *)(v15 + 48);
              if ( !v15 )
                v16 = (float *)(v23 - 1096);
              if ( fabsf(v16[2] - CenterZ) < 5.0 )
              {
                v17 = 1.0;
                if ( &(*m_aStorage)[-1996 - NumGenerationsAllowed + v10] == (uint8 *)-896 )
                  v17 = 0.5;
                if ( fabsf(*v16 - CenterX) < (float)(v17 * Radius) && fabsf(v16[1] - CenterY) < (float)(v17 * Radius) )
                {
                  v18 = v8 == 0;
                  if ( v8 )
                    v18 = (v14 & 0x400000) == 0;
                  if ( v18
                    || (*(_BYTE *)(v8 + 58) & 7) == 3
                    && (IsPlayer = CPed::IsPlayer((const CPed *)v8), v8 = NumGenerationsAllowed, IsPlayer) )
                  {
                    v20 = (CEntity *)(v23 - 1100);
                    v21 = v8;
                    CFireManager::StartFire(&gFireManager, v20, (CEntity *)v8, 0.8, 1u, 7000, 2);
                    v8 = v21;
                  }
                }
              }
            }
          }
        }
      }
      --v13;
      v10 -= 1996;
    }
    while ( v13 != -1 );
  }
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (0042ABC0) --------------------------------------------------------
void __fastcall CWorld::SetPedsChoking(float CenterX, float CenterY, float CenterZ, float Radius, CEntity *pCulprit)
{
  CPedPool *v5; // r6
  int32 m_nSize; // r5
  int v8; // r0
  int v10; // r5
  int v13; // r4
  int v14; // r3
  uint8 *v15; // r1
  float *v16; // r2
  float v17; // s0
  int32 LocalDirection; // r0
  CPool<CPed,CCopPed>::StorageType *m_aStorage; // r1
  uint8 *v20; // r0
  bool v21; // zf
  bool v22; // zf
  CPed *pHitPed; // [sp+Ch] [bp-54h]
  CVector2D v24; // [sp+10h] [bp-50h] BYREF

  v5 = CPools::ms_pPedPool;
  m_nSize = CPools::ms_pPedPool->m_nSize;
  if ( m_nSize )
  {
    v8 = 1996 * m_nSize;
    v10 = m_nSize - 1;
    v13 = v8 - 900;
    do
    {
      if ( (v5->m_aFlags[v10] & 0x80u) == 0 )
      {
        m_aStorage = v5->m_aStorage;
        v20 = &(*v5->m_aStorage)[v13];
        v21 = v20 == (uint8 *)&elf_hash_bucket[211];
        if ( v20 != (uint8 *)&elf_hash_bucket[211] )
          v21 = *((_DWORD *)v20 + 1) == 55;
        if ( !v21 )
        {
          v22 = v20[61] << 31 == 0;
          if ( !(v20[61] << 31) )
            v22 = *((_DWORD *)v20 + 188) == 0;
          if ( v22 && (*(v20 - 1026) & 8) == 0 && (*m_aStorage)[v13] != 2 )
          {
            v14 = *((_DWORD *)v20 - 269);
            v15 = &(*m_aStorage)[v13 - 1992];
            v16 = (float *)(v14 + 48);
            if ( !v14 )
              v16 = (float *)(v15 + 900);
            if ( fabsf(v16[2] - CenterZ) < 5.0 )
            {
              v17 = *v16 - CenterX;
              if ( fabsf(v17) < Radius && fabsf(v16[1] - CenterY) < Radius )
              {
                v24.y = v16[1] - CenterY;
                pHitPed = (CPed *)(v20 - 1096);
                v24.x = v17;
                LocalDirection = CPed::GetLocalDirection((CPed *)(v20 - 1096), &v24);
                CWeapon::GenerateDamageEvent(pHitPed, pCulprit, WEAPONTYPE_TEARGAS, 1, PED_SPHERE_CHEST, LocalDirection);
              }
            }
          }
        }
      }
      --v10;
      v13 -= 1996;
    }
    while ( v10 != -1 );
  }
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (0042ACF4) --------------------------------------------------------
void __fastcall CWorld::SetCarsOnFire(
        float CenterX,
        float CenterY,
        float CenterZ,
        float Radius,
        CEntity *pStartedFireEntity)
{
  CVehiclePool *v5; // r4
  int32 m_nSize; // r6
  int v8; // r0
  int v11; // r6
  int v13; // r5
  bool v14; // zf
  uint8 *v15; // r1
  int v16; // r2
  float *v17; // r0

  v5 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( m_nSize )
  {
    v8 = 2604 * m_nSize;
    v11 = m_nSize - 1;
    v13 = v8 - 2604;
    do
    {
      if ( (v5->m_aFlags[v11] & 0x80u) == 0 )
      {
        v15 = &(*v5->m_aStorage)[v13];
        v14 = v15 == 0;
        if ( v15 )
          v14 = (v15[58] & 0xF8) == 40;
        if ( !v14 && !*((_DWORD *)v15 + 293) && (v15[70] & 8) == 0 )
        {
          v16 = *((_DWORD *)v15 + 5);
          v17 = (float *)(v16 + 48);
          if ( !v16 )
            v17 = (float *)(v15 + 4);
          if ( fabsf(v17[2] - CenterZ) < 5.0 && fabsf(*v17 - CenterX) < Radius && fabsf(v17[1] - CenterY) < Radius )
            CFireManager::StartFire(&gFireManager, (CEntity *)v15, pStartedFireEntity, 0.8, 1u, 7000, 100);
        }
      }
      --v11;
      v13 -= 2604;
    }
    while ( v11 != -1 );
  }
}

//----- (0042AE04) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CWorld::SetWorldOnFire(float CenterX, float CenterY, float CenterZ, float Radius, CEntity *pCulprit)
{
  RwReal v5; // r1
  RwReal v6; // r2
  CVector pos; // [sp+1Ch] [bp-14h] BYREF

  pos.x = CenterX;
  pos.y = v5;
  pos.z = v6;
  if ( CWorld::TestSphereAgainstWorld(*(CVector *)&CenterX, Radius, 0, 1, 0, 0, 1, 0, 0) )
  {
    if ( !CFireManager::GetNumFiresInRange(&gFireManager, &pos, 2.0) )
      CFireManager::StartFire(&gFireManager, pos.x, pos.y, pos.z, 0.8, 1u, 0, 0x1B58u, 100);
  }
}
// 42AE04: variables would overlap: r0.4 and r0.12

//----- (0042AE88) --------------------------------------------------------
CEntity *__fastcall CWorld::TestSphereAgainstWorld(
        CVector Coors,
        float Radius,
        CEntity *pException,
        int bCheckBuildings,
        int bCheckVehicles,
        int bCheckPeds,
        int bCheckObjects,
        int bCheckDummies,
        int bCamIgnoreCertainObjects)
{
  float v10; // s4
  float v11; // s20
  float v12; // s22
  float v13; // r4
  int v14; // s0
  int v15; // s18
  int v16; // s20
  int v17; // r6
  uint16 v18; // r0
  int v19; // r4
  int v20; // r1
  int v21; // r0
  int v22; // r11
  int v23; // r0
  int v24; // r9
  CEntity *v25; // r0
  int v26; // r10
  bool v27; // cc
  RwReal z; // [sp+18h] [bp-68h]
  int v30; // [sp+34h] [bp-4Ch]
  RwReal x; // [sp+38h] [bp-48h]
  float y; // [sp+3Ch] [bp-44h]
  CVector v33; // 0:r1.12
  CVector v34; // 0:r1.12
  CVector v35; // 0:r1.12
  CVector v36; // 0:r1.12
  CVector v37; // 0:r1.12

  x = Coors.x;
  z = Coors.z;
  y = Coors.y;
  v10 = (float)((float)(Coors.x + Radius) / 50.0) + 60.0;
  v11 = floorf((float)((float)(Coors.x - Radius) / 50.0) + 60.0);
  v12 = floorf((float)((float)(y - Radius) / 50.0) + 60.0);
  v13 = floorf(v10);
  v14 = (int)floorf((float)((float)(y + Radius) / 50.0) + 60.0);
  v15 = (int)v13;
  v16 = (int)v11;
  v17 = (int)v12;
  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v18 = 1;
  }
  else
  {
    v18 = CWorld::ms_nCurrentScanCode + 1;
  }
  v19 = 0;
  CWorld::ms_nCurrentScanCode = v18;
  if ( v17 <= v14 )
  {
    v20 = v16;
    while ( v20 > v15 )
    {
LABEL_27:
      v20 = v16;
      v27 = v17++ < v14;
      if ( !v27 )
        return 0;
    }
    v21 = 0;
    if ( v17 > 0 )
      v21 = v17;
    if ( v21 >= 119 )
      v21 = 119;
    v22 = v16;
    v30 = 120 * v21;
    while ( 1 )
    {
      v23 = 0;
      if ( v22 > 0 )
        v23 = v22;
      if ( v23 >= 119 )
        v23 = 119;
      v24 = v23 + v30;
      if ( bCheckBuildings == 1 )
      {
        v33.x = x;
        *(_QWORD *)&v33.y = __PAIR64__(LODWORD(z), LODWORD(y));
        v25 = CWorld::TestSphereAgainstSectorList(
                &CWorld::ms_aSectors[v24].m_buildingPtrListArray,
                v33,
                Radius,
                pException,
                0);
        if ( v25 )
          return v25;
      }
      v26 = v22 & 0xF | (unsigned __int8)(16 * v17);
      if ( bCheckVehicles == 1 )
      {
        v34.x = x;
        *(_QWORD *)&v34.y = __PAIR64__(LODWORD(z), LODWORD(y));
        v25 = CWorld::TestSphereAgainstSectorList(
                (CPtrList *)&CWorld::ms_aRepeatSectors[v26],
                v34,
                Radius,
                pException,
                0);
        if ( v25 )
          return v25;
      }
      if ( bCheckPeds == 1 )
      {
        v35.x = x;
        *(_QWORD *)&v35.y = __PAIR64__(LODWORD(z), LODWORD(y));
        v25 = CWorld::TestSphereAgainstSectorList(
                &CWorld::ms_aRepeatSectors[v26].m_ptrListArray[1],
                v35,
                Radius,
                pException,
                0);
        if ( v25 )
          return v25;
      }
      if ( bCheckObjects == 1 )
      {
        v36.x = x;
        *(_QWORD *)&v36.y = __PAIR64__(LODWORD(z), LODWORD(y));
        v25 = CWorld::TestSphereAgainstSectorList(
                &CWorld::ms_aRepeatSectors[v26].m_ptrListArray[2],
                v36,
                Radius,
                pException,
                bCamIgnoreCertainObjects);
        if ( v25 )
          return v25;
      }
      if ( bCheckDummies == 1 )
      {
        v37.x = x;
        *(_QWORD *)&v37.y = __PAIR64__(LODWORD(z), LODWORD(y));
        v25 = CWorld::TestSphereAgainstSectorList(
                &CWorld::ms_aSectors[v24].m_dummyPtrListArray,
                v37,
                Radius,
                pException,
                0);
        if ( v25 )
          return v25;
      }
      v27 = v22++ < v15;
      if ( !v27 )
        goto LABEL_27;
    }
  }
  return (CEntity *)v19;
}

//----- (0042B0FC) --------------------------------------------------------
int __fastcall CWorld::SprayPaintWorld(CVector *vecPos, CVector *vecHitNormal, float fRadius, bool bFadeUp)
{
  __int16 v4; // r8
  int v6; // r4
  int v7; // r6
  int v8; // r11
  char v9; // r5
  CEntity *v10; // r5
  CMatrix *m_pMat; // r1
  CEntity *v12; // r0
  __int64 v13; // d16
  int Alpha; // r5
  int v15; // r0
  int v16; // r1
  _BOOL4 v18; // [sp+1Ch] [bp-64h]
  Int16 pNum; // [sp+22h] [bp-5Eh] BYREF
  CEntity *v20[23]; // [sp+24h] [bp-5Ch] BYREF

  v18 = bFadeUp;
  v6 = 0;
  CWorld::FindObjectsInRange(vecPos, fRadius, 0, &pNum, 15, v20, 1, 0, 0, 0, 0);
  v7 = pNum;
  if ( pNum >= 1 )
  {
    v8 = 0;
    v9 = 0;
    do
    {
      if ( CTagManager::IsTag(v20[v6]) )
      {
        v10 = v20[v6];
        m_pMat = v10->m_pMat;
        if ( m_pMat )
        {
          v12 = v20[v6];
        }
        else
        {
          CPlaceable::AllocateMatrix(v20[v6]);
          CSimpleTransform::UpdateMatrix(&v10->m_transform, v10->m_pMat);
          v12 = v20[v6];
          m_pMat = v10->m_pMat;
        }
        v13 = *(_QWORD *)&m_pMat->xy;
        vecHitNormal->z = m_pMat->zy;
        *(_QWORD *)&vecHitNormal->x = v13;
        Alpha = CTagManager::GetAlpha(v12);
        if ( v18 )
        {
          v4 = Alpha + 8;
          if ( (unsigned int)(Alpha + 8) >= 0xFF )
            v4 = 255;
        }
        CTagManager::SetAlpha(v20[v6], v4);
        v15 = 0;
        v16 = 0;
        if ( v4 == 255 )
          v15 = 1;
        if ( Alpha != 255 )
          v16 = 1;
        v9 = 1;
        v8 |= v15 & v16;
      }
      ++v6;
    }
    while ( v6 < v7 );
    v6 = v9 & 1;
    if ( v8 << 31 )
      return 2;
  }
  return v6;
}
// 42B198: variable 'v4' is possibly undefined

//----- (0042B1D8) --------------------------------------------------------
void CWorld::RepositionCertainDynamicObjects()
{
  CDummyPool *v0; // r4
  int32 m_nSize; // r0
  int v2; // r6
  int v3; // r5

  v0 = CPools::ms_pDummyPool;
  m_nSize = CPools::ms_pDummyPool->m_nSize;
  if ( m_nSize )
  {
    v2 = m_nSize - 1;
    v3 = 60 * m_nSize - 60;
    do
    {
      if ( (v0->m_aFlags[v2] & 0x80u) == 0 )
      {
        if ( &(*v0->m_aStorage)[v3] )
          CWorld::RepositionOneObject((CEntity *)&(*v0->m_aStorage)[v3]);
      }
      --v2;
      v3 -= 60;
    }
    while ( v2 != -1 );
  }
}

//----- (0042B220) --------------------------------------------------------
void __fastcall CWorld::RepositionOneObject(CEntity *pEntity)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d2
  int m_nModelIndex; // r0
  int v5; // r6
  int v6; // r3
  CBaseModelInfo *v7; // r1
  int v8; // r2
  CColModel *v9; // r0
  CMatrix *v10; // r1
  CSimpleTransform *p_tx; // r2
  float v12; // s2
  __int64 v13; // d16
  CCollisionData *m_pColData; // r0
  float v15; // s16
  float *p_x; // r0
  float v17; // s4
  CColModel *m_pColModel; // r0
  float z; // s2
  CMatrix *m_pMat; // r0
  float v21; // s16
  RwReal tx; // s18
  RwReal ty; // s20
  float tz; // s0
  float v25; // s2
  float v26; // s0
  CMatrix *v27; // r0
  RwObject_0 *m_pRwObject; // r0
  char *parent; // r1
  CMatrix *v30; // r0
  RwMatrix *v31; // r1
  CSimpleTransform *p_m_transform; // r0
  CMatrix *v33; // r0
  RwReal v34; // s16
  RwReal v35; // s18
  float v36; // s2
  CColModel *v37; // r0
  float v38; // s0
  float v39; // s2
  CMatrix *v40; // r0
  float v41; // s0
  int m_nNoOfSpheres; // r2
  float v43; // s0
  int v44; // r3
  int v45; // r5
  CColSphere *v46; // r6
  __int64 v47; // d16
  RwReal x; // r5
  RwReal y; // r6
  CMatrix *v50; // r0
  float v51; // s0
  float v52; // s2
  float v53; // s0
  CMatrix *v54; // r0
  RwObject_0 *v55; // r0
  char *v56; // r1
  CVector v; // [sp+20h] [bp-70h] BYREF
  CEntity *refEntityPtr; // [sp+2Ch] [bp-64h] BYREF
  CColPoint v59; // [sp+30h] [bp-60h] BYREF
  CVector vecStart; // [sp+5Ch] [bp-34h] BYREF

  m_nModelIndex = pEntity->m_nModelIndex;
  if ( m_nModelIndex == MI_PARKINGMETER
    || m_nModelIndex == MI_PHONEBOOTH1
    || m_nModelIndex == MI_WASTEBIN
    || m_nModelIndex == MI_BIN
    || m_nModelIndex == MI_POSTBOX1
    || m_nModelIndex == MI_NEWSSTAND
    || m_nModelIndex == MI_TRAFFICCONE
    || m_nModelIndex == MI_DUMP1
    || m_nModelIndex == MI_ROADWORKBARRIER1
    || m_nModelIndex == MI_ROADBLOCKFUCKEDCAR1
    || m_nModelIndex == MI_ROADBLOCKFUCKEDCAR2
    || m_nModelIndex == MI_BUSSIGN1
    || m_nModelIndex == MI_NOPARKINGSIGN1
    || m_nModelIndex == MI_PHONESIGN
    || m_nModelIndex == MI_FIRE_HYDRANT
    || m_nModelIndex == MI_BOLLARDLIGHT
    || m_nModelIndex == MI_PARKTABLE
    || m_nModelIndex == MI_PARKINGMETER2
    || m_nModelIndex == MI_TELPOLE02
    || m_nModelIndex == MI_PARKBENCH
    || m_nModelIndex == MI_BARRIER1 )
  {
    goto LABEL_47;
  }
  v5 = 0;
  v6 = 0;
  v7 = CModelInfo::ms_modelInfoPtrs[m_nModelIndex];
  v8 = v7->m_flags & 0x7800;
  if ( v8 != 2048 )
    v5 = 1;
  if ( v8 == 4096 )
    v6 = 1;
  if ( v6 == v5 )
  {
LABEL_47:
    v2.n64_u32[0] = 2.0;
    m_pColModel = CModelInfo::ms_modelInfoPtrs[m_nModelIndex]->m_pColModel;
    v1.n64_u32[0] = LODWORD(m_pColModel->m_boxBound.m_vecMin.z);
    z = m_pColModel->m_boxBound.m_vecMax.z;
    m_pMat = pEntity->m_pMat;
    v1.n64_f32[0] = z - v1.n64_f32[0];
    LODWORD(v21) = vmax_f32(v1, v2).n64_u32[0];
    if ( m_pMat )
    {
      tx = m_pMat->tx;
      ty = m_pMat->ty;
    }
    else
    {
      CPlaceable::AllocateMatrix(pEntity);
      CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
      m_pMat = pEntity->m_pMat;
      tx = m_pMat->tx;
      if ( m_pMat )
      {
        ty = m_pMat->ty;
      }
      else
      {
        CPlaceable::AllocateMatrix(pEntity);
        CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
        m_pMat = pEntity->m_pMat;
        ty = m_pMat->ty;
        if ( !m_pMat )
        {
          CPlaceable::AllocateMatrix(pEntity);
          CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
          m_pMat = pEntity->m_pMat;
        }
      }
    }
    tz = m_pMat->tz;
    vecStart.y = ty;
    vecStart.x = tx;
    vecStart.z = v21 + tz;
    v25 = 0.0;
    if ( CWorld::ProcessVerticalLine(&vecStart, -1000.0, &v59, (CEntity **)&v, 1, 0, 0, 0, 0, 0, 0) )
      v25 = v59.m_vecPosition.z;
    v26 = CModelInfo::ms_modelInfoPtrs[pEntity->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMin.z;
    v27 = pEntity->m_pMat;
    if ( !v27 )
    {
      CPlaceable::AllocateMatrix(pEntity);
      CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
      v27 = pEntity->m_pMat;
    }
    v27->tz = v25 - v26;
    m_pRwObject = pEntity->m_pRwObject;
    if ( !m_pRwObject )
      goto LABEL_62;
    parent = (char *)m_pRwObject->parent;
    v30 = pEntity->m_pMat;
    v31 = (RwMatrix *)(parent + 16);
    if ( !v30 )
    {
      p_m_transform = &pEntity->m_transform;
LABEL_61:
      CSimpleTransform::UpdateRwMatrix(p_m_transform, v31);
      goto LABEL_62;
    }
LABEL_59:
    CMatrix::UpdateRwMatrix(v30, v31);
LABEL_62:
    CEntity::UpdateRwFrame(pEntity);
    goto LABEL_63;
  }
  if ( m_nModelIndex == MI_SINGLESTREETLIGHTS1
    || m_nModelIndex == MI_SINGLESTREETLIGHTS2
    || m_nModelIndex == MI_SINGLESTREETLIGHTS3
    || m_nModelIndex == MI_TRAFFICLIGHTS_MIAMI
    || m_nModelIndex == MI_TRAFFICLIGHTS_VEGAS
    || m_nModelIndex == MI_TRAFFICLIGHTS_TWOVERTICAL
    || m_nModelIndex == MI_TRAFFICLIGHTS_3
    || m_nModelIndex == MI_TRAFFICLIGHTS_4
    || m_nModelIndex == MI_TRAFFICLIGHTS_5
    || m_nModelIndex == MI_MLAMPPOST
    || m_nModelIndex == MI_STREETLAMP1
    || m_nModelIndex == MI_STREETLAMP2 )
  {
    v9 = v7->m_pColModel;
    v10 = pEntity->m_pMat;
    p_tx = &pEntity->m_transform;
    v1.n64_u32[0] = LODWORD(v9->m_boxBound.m_vecMin.z);
    v12 = v9->m_boxBound.m_vecMax.z;
    if ( v10 )
      p_tx = (CSimpleTransform *)&v10->tx;
    v13 = *(_QWORD *)&p_tx->m_translate.x;
    v.z = p_tx->m_translate.z;
    *(_QWORD *)&v.x = v13;
    m_pColData = v9->m_pColData;
    if ( m_pColData )
    {
      v2.n64_u32[0] = 2.0;
      v1.n64_f32[0] = v12 - v1.n64_f32[0];
      LODWORD(v15) = vmax_f32(v1, v2).n64_u32[0];
      if ( m_pColData->m_nNoOfBoxes == 1 )
      {
        p_x = &m_pColData->m_pBoxArray->m_vecMin.x;
        v17 = p_x[4];
        v.x = (float)(*p_x + p_x[3]) * 0.5;
        v.y = (float)(p_x[1] + v17) * 0.5;
        v.z = p_x[2];
      }
      else
      {
        if ( m_pColData->m_nNoOfSpheres < 1 )
          goto LABEL_81;
        v.z = 1000.0;
        m_nNoOfSpheres = m_pColData->m_nNoOfSpheres;
        if ( m_nNoOfSpheres < 1 )
          goto LABEL_81;
        v43 = 1000.0;
        v44 = 0;
        v45 = 0;
        do
        {
          v46 = &m_pColData->m_pSphereArray[v44];
          if ( v46->m_vecCentre.z < v43 )
          {
            v47 = *(_QWORD *)&v46->m_vecCentre.x;
            v.z = v46->m_vecCentre.z;
            *(_QWORD *)&v.x = v47;
            LOWORD(m_nNoOfSpheres) = m_pColData->m_nNoOfSpheres;
          }
          v43 = v.z;
          ++v44;
          ++v45;
        }
        while ( v45 < (__int16)m_nNoOfSpheres );
        if ( v.z >= 1000.0 )
        {
LABEL_81:
          x = v.x;
          y = v.y;
          v50 = pEntity->m_pMat;
          if ( !v50 )
          {
            CPlaceable::AllocateMatrix(pEntity);
            CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
            v50 = pEntity->m_pMat;
          }
          v51 = v50->tz;
          vecStart.x = x;
          vecStart.y = y;
          vecStart.z = v15 + v51;
          v52 = 0.0;
          if ( CWorld::ProcessVerticalLine(&vecStart, -1000.0, &v59, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0) )
            v52 = v59.m_vecPosition.z;
          v53 = CModelInfo::ms_modelInfoPtrs[pEntity->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMin.z;
          v54 = pEntity->m_pMat;
          if ( !v54 )
          {
            CPlaceable::AllocateMatrix(pEntity);
            CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
            v54 = pEntity->m_pMat;
          }
          v54->tz = v52 - v53;
          v55 = pEntity->m_pRwObject;
          if ( !v55 )
            goto LABEL_62;
          v56 = (char *)v55->parent;
          v30 = pEntity->m_pMat;
          v31 = (RwMatrix *)(v56 + 16);
          if ( !v30 )
          {
            p_m_transform = &pEntity->m_transform;
            goto LABEL_61;
          }
          goto LABEL_59;
        }
      }
      if ( !v10 )
      {
        CPlaceable::AllocateMatrix(pEntity);
        CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
        v10 = pEntity->m_pMat;
      }
      operator*(&v59.m_vecPosition, v10, &v);
      v = v59.m_vecPosition;
      goto LABEL_81;
    }
  }
LABEL_63:
  if ( pEntity->m_nModelIndex == MI_BUOY )
  {
    v33 = pEntity->m_pMat;
    if ( v33 )
    {
      v34 = v33->tx;
      v35 = v33->ty;
    }
    else
    {
      CPlaceable::AllocateMatrix(pEntity);
      CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
      v33 = pEntity->m_pMat;
      v34 = v33->tx;
      if ( v33 )
      {
        v35 = v33->ty;
      }
      else
      {
        CPlaceable::AllocateMatrix(pEntity);
        CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
        v33 = pEntity->m_pMat;
        v35 = v33->ty;
        if ( !v33 )
        {
          CPlaceable::AllocateMatrix(pEntity);
          CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
          v33 = pEntity->m_pMat;
        }
      }
    }
    v36 = v33->tz;
    vecStart.y = v35;
    vecStart.x = v34;
    vecStart.z = v36 + 2.0;
    CWorld::ProcessVerticalLine(&vecStart, -1000.0, &v59, (CEntity **)&v, 1, 0, 0, 0, 0, 0, 0);
    v37 = CModelInfo::ms_modelInfoPtrs[pEntity->m_nModelIndex]->m_pColModel;
    v38 = v37->m_boxBound.m_vecMin.z;
    v39 = v37->m_boxBound.m_vecMax.z;
    v40 = pEntity->m_pMat;
    v41 = v39 - v38;
    if ( !v40 )
    {
      CPlaceable::AllocateMatrix(pEntity);
      CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
      v40 = pEntity->m_pMat;
    }
    v40->tz = (float)(v41 * 0.2) + (float)((float)(v41 * -0.5) + 6.0);
  }
}
// 42B496: variable 'v1' is possibly undefined
// 42B496: variable 'v2' is possibly undefined

//----- (0042B8AC) --------------------------------------------------------
void __fastcall CWorld::UseDetonator(CEntity *pUser)
{
  CVehiclePool *v2; // r10
  int32 m_nSize; // r0
  int v4; // r12
  int v5; // r6
  int v6; // r4
  CEntity **v7; // r1
  int v8; // r5
  CPool<CVehicle,CHeli>::StorageType *m_aStorage; // r0
  uint8 *v10; // r2
  uint8 v11; // r3
  bool v12; // zf

  v2 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( m_nSize )
  {
    v4 = -1340;
    v5 = 2604 * m_nSize;
    v6 = m_nSize - 1;
    do
    {
      if ( (v2->m_aFlags[v6] & 0x80u) == 0 )
      {
        m_aStorage = v2->m_aStorage;
        v10 = v2->m_aStorage[v5 / 0xA2Cu];
        if ( v10 != (uint8 *)&elf_hash_bucket[588] )
        {
          v11 = (*m_aStorage)[v5 - 1402];
          v12 = (v11 & 7) == 3;
          if ( (v11 & 7) == 3 )
            v12 = *((_DWORD *)v10 - 340) == (_DWORD)pUser;
          if ( v12 )
          {
            (*m_aStorage)[v5 - 1402] = v11 & 0xF8;
            v7 = (CEntity **)&(*m_aStorage)[v4 + v5];
            *v7 = pUser;
            *((_WORD *)v7 - 1) = 500;
            if ( pUser )
            {
              v8 = v4;
              CEntity::RegisterReference(pUser, v7);
              v4 = v8;
            }
          }
        }
      }
      --v6;
      v5 -= 2604;
    }
    while ( v6 != -1 );
  }
  j_CProjectileInfo::RemoveDetonatorProjectiles();
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (0042B958) --------------------------------------------------------
CEntity *__fastcall CWorld::TestSphereAgainstSectorList(
        CPtrList *list,
        CVector Coors,
        float Radius,
        CEntity *pException,
        int bCamIgnoreCertainObjects)
{
  float z; // r6
  float y; // r9
  CCollisionData *v8; // r0
  __int64 v9; // r4
  float v10; // s18
  float v11; // s22
  int v12; // r1
  bool v13; // zf
  int v14; // r1
  const CMatrix *v15; // r6
  CColModel *ColModel; // r0
  CVector v18; // [sp+1Ch] [bp-10Ch] BYREF
  int v19[5]; // [sp+28h] [bp-100h] BYREF
  CCollisionData v20; // [sp+3Ch] [bp-ECh] BYREF
  CColModel colModelA; // [sp+70h] [bp-B8h] BYREF
  CMatrix matA; // [sp+A0h] [bp-88h] BYREF

  z = Coors.z;
  y = Coors.y;
  *(RwReal *)&v9 = Coors.x;
  matA.m_pRwMat = 0;
  matA.m_owner = 0;
  CColModel::CColModel(&colModelA);
  CCollisionData::CCollisionData(&v20);
  memset(v19, 0, 12);
  colModelA.m_boxBound.m_vecMin.x = -Radius;
  colModelA.m_boxBound.m_vecMin.z = -Radius;
  colModelA.m_boxBound.m_vecMax.x = Radius;
  colModelA.m_boxBound.m_vecMin.y = -Radius;
  memset(&colModelA.m_sphereBound, 0, 12);
  colModelA.m_sphereBound.m_fRadius = Radius;
  colModelA.m_pColData = v8;
  v20.m_nNoOfSpheres = 1;
  v20.m_pSphereArray = (CColSphere *)v19;
  colModelA.m_boxBound.m_vecMax.z = Radius;
  *(float *)&v19[3] = Radius;
  colModelA.m_boxBound.m_vecMax.y = Radius;
  CMatrix::SetTranslate(&matA, *(float *)&v9, y, z);
  HIDWORD(v9) = (CPtrList)list->m_pHead;
  if ( list->m_pHead )
  {
    v10 = z;
    v11 = *(float *)&v9;
    do
    {
      v9 = *(_QWORD *)HIDWORD(v9);
      v12 = *(unsigned __int16 *)(v9 + 48);
      v13 = v12 == CWorld::ms_nCurrentScanCode;
      if ( v12 != CWorld::ms_nCurrentScanCode )
      {
        *(_WORD *)(v9 + 48) = CWorld::ms_nCurrentScanCode;
        v13 = (_DWORD)v9 == (_DWORD)pException;
      }
      if ( v13 || !(*(unsigned __int8 *)(v9 + 28) << 31) )
        continue;
      if ( bCamIgnoreCertainObjects == 1 && !CGarages::IsModelIndexADoor(*(__int16 *)(v9 + 38)) )
      {
        v14 = *(unsigned __int8 *)(*(_DWORD *)(v9 + 356) + 30);
        if ( v14 == 3 )
        {
          if ( gCurCamColVars < 0xAu )
            continue;
        }
        else if ( v14 != 2 && (v14 != 1 || gCurCamColVars >= 0xAu) )
        {
          continue;
        }
      }
      CEntity::GetBoundCentre(&v18, (const CEntity *)v9);
      if ( sqrtf(
             (float)((float)((float)(v11 - v18.x) * (float)(v11 - v18.x))
                   + (float)((float)(y - v18.y) * (float)(y - v18.y)))
           + (float)((float)(v10 - v18.z) * (float)(v10 - v18.z))) < (float)(CModelInfo::ms_modelInfoPtrs[*(__int16 *)(v9 + 38)]->m_pColModel->m_sphereBound.m_fRadius
                                                                           + Radius) )
      {
        v15 = *(const CMatrix **)(v9 + 20);
        if ( !v15 )
        {
          CPlaceable::AllocateMatrix((CPlaceable *)v9);
          CSimpleTransform::UpdateMatrix((const CSimpleTransform *)(v9 + 4), *(CMatrix **)(v9 + 20));
          v15 = *(const CMatrix **)(v9 + 20);
        }
        ColModel = CEntity::GetColModel((CEntity *)v9);
        if ( CCollision::ProcessColModels(&matA, &colModelA, v15, ColModel, gaTempSphereColPoints, 0, 0, 0) )
          goto LABEL_23;
      }
    }
    while ( HIDWORD(v9) );
  }
  LODWORD(v9) = 0;
LABEL_23:
  colModelA.m_pColData = 0;
  CColModel::~CColModel(&colModelA);
  CMatrix::~CMatrix(&matA);
  return (CEntity *)v9;
}
// 42B9AE: variable 'v8' is possibly undefined

//----- (0042BB1C) --------------------------------------------------------
void CWorld::PrintCarChanges()
{
  CVehiclePool *v0; // r0
  int32 m_nSize; // r3
  uint8 *m_aFlags; // r1
  int v3; // r2
  uint8 *v4; // r5
  UInt32 v5; // r5
  int v6; // r6

  v0 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( m_nSize )
  {
    m_aFlags = CPools::ms_pVehiclePool->m_aFlags;
    v3 = 2604 * m_nSize - 1164;
    do
    {
      if ( (m_aFlags[m_nSize - 1] & 0x80u) != 0 || (v4 = &(*v0->m_aStorage)[v3], v4 == (uint8 *)&elf_hash_bucket[297]) )
      {
        v5 = 0;
      }
      else if ( *(_DWORD *)&(*v0->m_aStorage)[v3] )
      {
        v5 = 0;
      }
      else
      {
        v5 = *((__int16 *)v4 - 701);
      }
      v6 = m_nSize - 1;
      v3 -= 2604;
      if ( v5 != MIs[m_nSize - 1] )
        MIs[m_nSize - 1] = v5;
      --m_nSize;
    }
    while ( v6 );
  }
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (0042BBA8) --------------------------------------------------------
void CWorld::RemoveStaticObjects()
{
  int i; // r11
  CPtrNode *m_pHead; // r6
  CPtrNode v2; // kr00_8
  CSector *v3; // r5
  CPtrNode *m_pNext; // r4
  CPtrListDoubleLink *p_m_dummyPtrListArray; // r5
  CPtrNode *v6; // t1
  CPtrNode v7; // kr08_8
  int j; // r9
  CPtrNode *v9; // r6
  CPtrNode v10; // r4

  for ( i = 0; i != 14400; ++i )
  {
    m_pHead = CWorld::ms_aSectors[i].m_buildingPtrListArray.m_pHead;
    if ( m_pHead )
    {
      do
      {
        v2 = *m_pHead;
        (*(void (__fastcall **)(void *))(*(_DWORD *)m_pHead->m_pVoid + 16))(m_pHead->m_pVoid);
        if ( (unsigned __int8)((*((_BYTE *)v2.m_pVoid + 58) & 7) - 2) <= 2u )
          CPhysical::RemoveFromMovingList((CPhysical *)v2.m_pVoid);
        if ( m_pHead->m_pVoid )
          (*(void (__fastcall **)(void *))(*(_DWORD *)m_pHead->m_pVoid + 4))(m_pHead->m_pVoid);
        m_pHead = v2.m_pNext;
      }
      while ( v2.m_pNext );
    }
    v3 = &CWorld::ms_aSectors[i];
    v6 = v3->m_dummyPtrListArray.m_pHead;
    p_m_dummyPtrListArray = &v3->m_dummyPtrListArray;
    m_pNext = v6;
    if ( v6 )
    {
      do
      {
        v7 = *m_pNext;
        (*(void (__fastcall **)(void *))(*(_DWORD *)m_pNext->m_pVoid + 16))(m_pNext->m_pVoid);
        if ( (unsigned __int8)((*((_BYTE *)v7.m_pVoid + 58) & 7) - 2) <= 2u )
          CPhysical::RemoveFromMovingList((CPhysical *)v7.m_pVoid);
        if ( m_pNext->m_pVoid )
          (*(void (__fastcall **)(void *))(*(_DWORD *)m_pNext->m_pVoid + 4))(m_pNext->m_pVoid);
        m_pNext = v7.m_pNext;
      }
      while ( v7.m_pNext );
    }
    CPtrListSingleLink::Flush(&CWorld::ms_aSectors[i].m_buildingPtrListArray);
    CPtrListDoubleLink::Flush(p_m_dummyPtrListArray);
  }
  for ( j = 0; j != 256; ++j )
  {
    v9 = CWorld::ms_aRepeatSectors[j].m_ptrListArray[2].m_pHead;
    if ( v9 )
    {
      do
      {
        v10 = *v9;
        (*(void (__fastcall **)(void *))(*(_DWORD *)v9->m_pVoid + 16))(v9->m_pVoid);
        if ( (unsigned __int8)((*((_BYTE *)v10.m_pVoid + 58) & 7) - 2) <= 2u )
          CPhysical::RemoveFromMovingList((CPhysical *)v10.m_pVoid);
        if ( v9->m_pVoid )
          (*(void (__fastcall **)(void *))(*(_DWORD *)v9->m_pVoid + 4))(v9->m_pVoid);
        v9 = v10.m_pNext;
      }
      while ( v10.m_pNext );
    }
  }
}

//----- (0042BCCA) --------------------------------------------------------
void __fastcall CWorld::TestForBuildingsOnTopOfEachOther(CPtrList *list)
{
  CPtrNode *i; // r0
  CPtrNode *v2; // r1

  for ( i = list->m_pHead; i; i = i->m_pNext )
  {
    v2 = i;
    do
      v2 = v2->m_pNext;
    while ( v2 );
  }
}

//----- (0042BCE0) --------------------------------------------------------
void CWorld::TestForUnusedModels()
{
  uint16 v0; // r0
  int v1; // r12
  int v2; // r2
  int v3; // r9
  CPtrNode *i; // r6
  __int16 *m_pVoid; // r3
  int v6; // r1
  CPtrNode *j; // r5
  __int16 *v8; // r3
  int v9; // r1
  _DWORD v10[20008]; // [sp+0h] [bp-138A0h] BYREF

  memset(v10, 0, (size_t)&elf_hash_chain[3526]);
  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v0 = 1;
  }
  else
  {
    v0 = CWorld::ms_nCurrentScanCode + 1;
  }
  v1 = 0;
  CWorld::ms_nCurrentScanCode = v0;
  do
  {
    v2 = 0;
    v3 = 120 * v1;
    do
    {
      for ( i = CWorld::ms_aSectors[v2 + v3].m_buildingPtrListArray.m_pHead; i; i = i->m_pNext )
      {
        m_pVoid = (__int16 *)i->m_pVoid;
        if ( *((unsigned __int16 *)i->m_pVoid + 24) != v0 )
        {
          v6 = m_pVoid[19];
          m_pVoid[24] = v0;
          ++v10[v6];
        }
      }
      for ( j = CWorld::ms_aSectors[v2 + v3].m_dummyPtrListArray.m_pHead; j; j = j->m_pNext )
      {
        v8 = (__int16 *)j->m_pVoid;
        if ( *((unsigned __int16 *)j->m_pVoid + 24) != v0 )
        {
          v9 = v8[19];
          v8[24] = v0;
          ++v10[v9];
        }
      }
      ++v2;
    }
    while ( v2 != 120 );
    ++v1;
  }
  while ( v1 != 120 );
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (0042BDC0) --------------------------------------------------------
void __fastcall CWorld::TestForUnusedModels(CPtrList *list, int32 *modelCounts)
{
  CPtrNode *m_pHead; // r0
  int v3; // r12
  __int16 *m_pVoid; // r3
  int v5; // r2

  m_pHead = list->m_pHead;
  if ( m_pHead )
  {
    v3 = CWorld::ms_nCurrentScanCode;
    do
    {
      m_pVoid = (__int16 *)m_pHead->m_pVoid;
      if ( *((unsigned __int16 *)m_pHead->m_pVoid + 24) != v3 )
      {
        v5 = m_pVoid[19];
        m_pVoid[24] = v3;
        ++modelCounts[v5];
      }
      m_pHead = m_pHead->m_pNext;
    }
    while ( m_pHead );
  }
}

//----- (0042BDF8) --------------------------------------------------------
void __fastcall CWorld::ClearExcitingStuffFromArea(const CVector *Centre, float Radius, Bool8 bRemoveProjectiles)
{
  CPedPool *v5; // r9
  int32 m_nSize; // r8
  float v7; // s18
  int v8; // r5
  int i; // r4
  CPed *v10; // r6
  CMatrix *m_pMat; // r0
  float32x2_t *p_tx; // r1
  float32x2_t v13; // d16
  unsigned __int64 v14; // d0
  CPlayerPed *PlayerPed; // r0
  CPedGroup *PedsGroup; // r0
  int j; // r9
  int v18; // r6
  CPlayerPed *v19; // r0
  const CPed *v20; // r1
  CPedGroup *v21; // r4
  unsigned __int8 v22; // r0
  unsigned __int8 *v23; // r10
  int v24; // r11
  bool v25; // zf
  CEntity *m_pEntityStandingOn; // r0
  bool v27; // zf
  float32x2_t *v28; // r0
  CVector **v29; // r5
  CVector *v30; // r4
  float32x2_t *v31; // r1
  float32x2_t v32; // d16
  unsigned __int64 v33; // d0
  CPed *v34; // r0
  unsigned __int8 v35; // r0
  int v36; // r5
  CPed *v37; // r4
  CVehiclePool *v38; // r4
  int32 v39; // r8
  float v40; // s16
  float v41; // s18
  float v42; // s20
  int v43; // r6
  float v44; // s22
  int k; // r5
  CVehicle *v46; // r0
  CMatrix *v47; // r1
  float *p_x; // r2
  int v49; // [sp+4h] [bp-54h]
  float32x2_t *v51; // [sp+Ch] [bp-4Ch]
  int v52; // [sp+10h] [bp-48h]
  CVehiclePool *v53; // [sp+14h] [bp-44h]

  v49 = bRemoveProjectiles;
  v5 = CPools::ms_pPedPool;
  v53 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pPedPool->m_nSize;
  if ( m_nSize >= 1 )
  {
    v7 = Radius * Radius;
    v8 = 0;
    for ( i = 0; i != m_nSize; ++i )
    {
      if ( (v5->m_aFlags[i] & 0x80u) == 0 )
      {
        v10 = (CPed *)v5->m_aStorage[v8];
        if ( v10 )
        {
          if ( !CPed::IsPlayer((const CPed *)v5->m_aStorage[v8]) && CPed::CanBeDeleted(v10) )
          {
            m_pMat = v10->m_pMat;
            p_tx = (float32x2_t *)&m_pMat->tx;
            if ( !m_pMat )
              p_tx = (float32x2_t *)&v10->m_transform;
            v13.n64_u64[0] = vsub_f32((float32x2_t)p_tx->n64_u64[0], *(float32x2_t *)&Centre->x).n64_u64[0];
            v14 = vmul_f32(v13, v13).n64_u64[0];
            if ( (float)(*(float *)&v14 + *((float *)&v14 + 1)) < v7 )
            {
              PlayerPed = FindPlayerPed(-1);
              PedsGroup = CPedGroups::GetPedsGroup(PlayerPed);
              if ( !PedsGroup || !CPedGroupMembership::IsFollower(&PedsGroup->m_membership, v10) )
                CPopulation::RemovePed(v10);
            }
          }
        }
      }
      ++v8;
    }
  }
  v51 = (float32x2_t *)Centre;
  v52 = v53->m_nSize;
  if ( v52 >= 1 )
  {
    for ( j = 0; j != v52; ++j )
    {
      if ( (v53->m_aFlags[j] & 0x80u) == 0 )
      {
        v18 = (int)v53->m_aStorage[j];
        if ( v18 )
        {
          v19 = FindPlayerPed(-1);
          v21 = CPedGroups::GetPedsGroup(v19);
          v22 = *(_BYTE *)(v18 + 1164);
          v23 = (unsigned __int8 *)(v18 + 1164);
          if ( v22 )
          {
            v24 = 0;
            do
            {
              v25 = v21 == 0;
              if ( v21 )
              {
                v20 = *(const CPed **)(v18 + 1128 + 4 * v24);
                v25 = v20 == 0;
              }
              if ( !v25 )
              {
                if ( CPedGroupMembership::IsFollower(&v21->m_membership, v20) )
                  goto LABEL_51;
                v22 = *v23;
              }
              ++v24;
              v20 = (const CPed *)v22;
            }
            while ( v24 < v22 );
          }
          m_pEntityStandingOn = FindPlayerPed(-1)->m_pEntityStandingOn;
          v27 = m_pEntityStandingOn == (CEntity *)v18;
          if ( m_pEntityStandingOn == (CEntity *)v18 )
            v27 = *(_DWORD *)(v18 + 1440) == 5;
          if ( !v27 )
          {
            v29 = (CVector **)(v18 + 20);
            v28 = *(float32x2_t **)(v18 + 20);
            v30 = (CVector *)(v18 + 4);
            v31 = (float32x2_t *)(v18 + 4);
            if ( v28 )
              v31 = v28 + 6;
            v32.n64_u64[0] = vsub_f32((float32x2_t)v31->n64_u64[0], (float32x2_t)v51->n64_u64[0]).n64_u64[0];
            v33 = vmul_f32(v32, v32).n64_u64[0];
            if ( (float)(*(float *)&v33 + *((float *)&v33 + 1)) < (float)(Radius * Radius)
              && (*(_BYTE *)(v18 + 1068) & 8) == 0
              && CVehicle::CanBeDeleted((const CVehicle *)v18) )
            {
              if ( *v29 )
                v30 = *v29 + 4;
              if ( !CGarages::IsPointWithinHideOutGarage(v30) )
              {
                v34 = *(CPed **)(v18 + 1124);
                if ( v34 )
                {
                  CPopulation::RemovePed(v34);
                  if ( *(_DWORD *)(v18 + 1124) )
                    CEntity::CleanUpOldReference(*(CEntity **)(v18 + 1124), (CEntity **)(v18 + 1124));
                  *(_DWORD *)(v18 + 1124) = 0;
                }
                v35 = *v23;
                if ( *v23 )
                {
                  v36 = 0;
                  do
                  {
                    v37 = *(CPed **)(v18 + 1128 + 4 * v36);
                    if ( v37 )
                    {
                      CVehicle::RemovePassenger((CVehicle *)v18, *(CPed **)(v18 + 1128 + 4 * v36));
                      CPopulation::RemovePed(v37);
                      v35 = *v23;
                    }
                    ++v36;
                  }
                  while ( v36 < v35 );
                }
                if ( CCarCtrl::IsThisVehicleInteresting((CVehicle *)v18) )
                  CGarages::StoreCarInNearestImpoundingGarage((CVehicle *)v18);
                CCarCtrl::RemoveFromInterestingVehicleList((CVehicle *)v18);
                (*(void (__fastcall **)(int))(*(_DWORD *)v18 + 16))(v18);
                if ( (unsigned __int8)((*(_BYTE *)(v18 + 58) & 7) - 2) <= 2u )
                  CPhysical::RemoveFromMovingList((CPhysical *)v18);
                (*(void (__fastcall **)(int))(*(_DWORD *)v18 + 4))(v18);
              }
            }
          }
        }
      }
LABEL_51:
      ;
    }
  }
  CObject::DeleteAllTempObjectsInArea(*(CVector *)v51->n64_u64, Radius);
  CFireManager::ExtinguishPoint(&gFireManager, *(CVector *)v51->n64_u64, Radius);
  v38 = CPools::ms_pVehiclePool;
  v39 = CPools::ms_pVehiclePool->m_nSize;
  if ( v39 >= 1 )
  {
    v40 = Radius * Radius;
    v41 = v51->n64_f32[0];
    v42 = v51->n64_f32[1];
    v43 = 0;
    v44 = v51[1].n64_f32[0];
    for ( k = 0; k != v39; ++k )
    {
      if ( (v38->m_aFlags[k] & 0x80u) == 0 )
      {
        v46 = (CVehicle *)v38->m_aStorage[v43];
        if ( v46 )
        {
          v47 = v46->m_pMat;
          p_x = &v47->tx;
          if ( !v47 )
            p_x = &v46->m_transform.m_translate.x;
          if ( (float)((float)((float)((float)(v41 - *p_x) * (float)(v41 - *p_x))
                             + (float)((float)(v42 - p_x[1]) * (float)(v42 - p_x[1])))
                     + (float)((float)(v44 - p_x[2]) * (float)(v44 - p_x[2]))) < v40 )
            CVehicle::ExtinguishCarFire(v46);
        }
      }
      ++v43;
    }
  }
  CExplosion::RemoveAllExplosionsInArea(*(CVector *)v51->n64_u64, Radius);
  if ( v49 )
  {
    CProjectileInfo::RemoveAllProjectiles();
    CShadows::TidyUpShadows();
  }
  sub_194FF4((const CVector *)v51, Radius);
}
// 42BF18: variable 'v20' is possibly undefined

//----- (0042C11C) --------------------------------------------------------
void __fastcall CWorld::ExtinguishAllCarFiresInArea(CVector Centre, float Radius)
{
  CVehiclePool *v2; // r4
  int32 m_nSize; // r8
  int v4; // r6
  float x; // s18
  int v6; // r5
  float v7; // s16
  float y; // s20
  float z; // s22
  CVehicle *v10; // r0
  CMatrix *m_pMat; // r1
  float *p_tx; // r2

  v2 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( m_nSize >= 1 )
  {
    v4 = 0;
    x = Centre.x;
    v6 = 0;
    v7 = Radius * Radius;
    y = Centre.y;
    z = Centre.z;
    do
    {
      if ( (v2->m_aFlags[v6] & 0x80u) == 0 )
      {
        v10 = (CVehicle *)v2->m_aStorage[v4];
        if ( v10 )
        {
          m_pMat = v10->m_pMat;
          p_tx = &m_pMat->tx;
          if ( !m_pMat )
            p_tx = &v10->m_transform.m_translate.x;
          if ( (float)((float)((float)((float)(x - *p_tx) * (float)(x - *p_tx))
                             + (float)((float)(y - p_tx[1]) * (float)(y - p_tx[1])))
                     + (float)((float)(z - p_tx[2]) * (float)(z - p_tx[2]))) < v7 )
            CVehicle::ExtinguishCarFire(v10);
        }
      }
      ++v6;
      ++v4;
    }
    while ( m_nSize != v6 );
  }
}

//----- (0042C1C0) --------------------------------------------------------
void __fastcall CWorld::ClearCarsFromArea(float MinX, float MinY, float MinZ, float MaxX, float MaxY, float MaxZ)
{
  CVehiclePool *v6; // r11
  int32 m_nSize; // r8
  int i; // r6
  int v13; // r4
  CEntity *m_pEntityStandingOn; // r0
  bool v15; // zf
  int v16; // r1
  float *v17; // r0
  float v18; // s0
  float v19; // s0
  CPed *v20; // r0
  unsigned __int8 v21; // r0
  int v22; // r9
  CPed *v23; // r5

  v6 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( m_nSize >= 1 )
  {
    for ( i = 0; i != m_nSize; ++i )
    {
      if ( (v6->m_aFlags[i] & 0x80u) == 0 )
      {
        v13 = (int)v6->m_aStorage[i];
        if ( v13 )
        {
          m_pEntityStandingOn = FindPlayerPed(-1)->m_pEntityStandingOn;
          v15 = m_pEntityStandingOn == (CEntity *)v13;
          if ( m_pEntityStandingOn == (CEntity *)v13 )
            v15 = *(_DWORD *)(v13 + 1440) == 5;
          if ( !v15 )
          {
            v16 = *(_DWORD *)(v13 + 20);
            v17 = (float *)(v16 + 48);
            if ( !v16 )
              v17 = (float *)(v13 + 4);
            if ( *v17 >= MinX && *v17 <= MaxX )
            {
              v18 = v17[1];
              if ( v18 >= MinY && v18 <= MaxY )
              {
                v19 = v17[2];
                if ( v19 >= MinZ
                  && v19 <= MaxZ
                  && (*(_BYTE *)(v13 + 1068) & 8) == 0
                  && CVehicle::CanBeDeleted((const CVehicle *)v13) )
                {
                  v20 = *(CPed **)(v13 + 1124);
                  if ( v20 )
                  {
                    CPopulation::RemovePed(v20);
                    if ( *(_DWORD *)(v13 + 1124) )
                      CEntity::CleanUpOldReference(*(CEntity **)(v13 + 1124), (CEntity **)(v13 + 1124));
                    *(_DWORD *)(v13 + 1124) = 0;
                  }
                  v21 = *(_BYTE *)(v13 + 1164);
                  if ( v21 )
                  {
                    v22 = 0;
                    do
                    {
                      v23 = *(CPed **)(v13 + 1128 + 4 * v22);
                      if ( v23 )
                      {
                        CVehicle::RemovePassenger((CVehicle *)v13, *(CPed **)(v13 + 1128 + 4 * v22));
                        CPopulation::RemovePed(v23);
                        v21 = *(_BYTE *)(v13 + 1164);
                      }
                      ++v22;
                    }
                    while ( v22 < v21 );
                  }
                  if ( CCarCtrl::IsThisVehicleInteresting((CVehicle *)v13) )
                    CGarages::StoreCarInNearestImpoundingGarage((CVehicle *)v13);
                  CCarCtrl::RemoveFromInterestingVehicleList((CVehicle *)v13);
                  (*(void (__fastcall **)(int))(*(_DWORD *)v13 + 16))(v13);
                  if ( (unsigned __int8)((*(_BYTE *)(v13 + 58) & 7) - 2) <= 2u )
                    CPhysical::RemoveFromMovingList((CPhysical *)v13);
                  (*(void (__fastcall **)(int))(*(_DWORD *)v13 + 4))(v13);
                }
              }
            }
          }
        }
      }
    }
  }
}
// 678534: using guessed type int *CPools::ms_pVehiclePool;

//----- (0042C354) --------------------------------------------------------
void __fastcall CWorld::ClearPedsFromArea(float MinX, float MinY, float MinZ, float MaxX, float MaxY, float MaxZ)
{
  CPedPool *v6; // r9
  int32 m_nSize; // r8
  int v11; // r6
  int i; // r5
  CPed *v14; // r4
  CMatrix *m_pMat; // r1
  float *p_tx; // r0
  float v17; // s0
  float v18; // s0

  v6 = CPools::ms_pPedPool;
  m_nSize = CPools::ms_pPedPool->m_nSize;
  if ( m_nSize >= 1 )
  {
    v11 = 0;
    for ( i = 0; i != m_nSize; ++i )
    {
      if ( (v6->m_aFlags[i] & 0x80u) == 0 )
      {
        v14 = (CPed *)v6->m_aStorage[v11];
        if ( v14 )
        {
          if ( !CPed::IsPlayer((const CPed *)v6->m_aStorage[v11]) && CPed::CanBeDeleted(v14) )
          {
            m_pMat = v14->m_pMat;
            p_tx = &m_pMat->tx;
            if ( !m_pMat )
              p_tx = &v14->m_transform.m_translate.x;
            if ( *p_tx >= MinX && *p_tx <= MaxX )
            {
              v17 = p_tx[1];
              if ( v17 >= MinY && v17 <= MaxY )
              {
                v18 = p_tx[2];
                if ( v18 >= MinZ && v18 <= MaxZ )
                  CPopulation::RemovePed(v14);
              }
            }
          }
        }
      }
      ++v11;
    }
  }
}
// 676C84: using guessed type int CPools::ms_pPedPool[2];

//----- (0042C424) --------------------------------------------------------
void __fastcall CWorld::SetAllCarsCanBeDamaged(bool DmgeFlag)
{
  CVehiclePool *v1; // r1
  int32 m_nSize; // lr
  int v3; // r12
  int v4; // r3
  int i; // r0

  v1 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( m_nSize >= 1 )
  {
    v3 = DmgeFlag << 21;
    v4 = 0;
    for ( i = 0; i != m_nSize; ++i )
    {
      if ( (v1->m_aFlags[i] & 0x80u) == 0 )
      {
        if ( v1->m_aStorage[v4] )
          *(_DWORD *)&v1->m_aStorage[v4][1068] = *(_DWORD *)&v1->m_aStorage[v4][1068] & 0xFFDFFFFF | v3;
      }
      ++v4;
    }
  }
}

//----- (0042C474) --------------------------------------------------------
void __fastcall CWorld::CallOffChaseForArea(float MinX, float MinY, float MaxX, float MaxY)
{
  float v5; // s16
  float v6; // s18
  float v7; // s22
  float v8; // s24
  float v9; // r8
  float v10; // s30
  int v11; // s2
  int v12; // s26
  uint16 v13; // r0
  int v14; // r10
  bool v15; // cc
  float v16; // [sp+4h] [bp-8Ch]
  float v17; // [sp+8h] [bp-88h]
  float v18; // [sp+Ch] [bp-84h]
  float v19; // [sp+10h] [bp-80h]
  int v23; // [sp+28h] [bp-68h]
  int v24; // [sp+2Ch] [bp-64h]

  v5 = MinX + -10.0;
  v6 = MinY + -10.0;
  v7 = MaxX + 10.0;
  v8 = MaxY + 10.0;
  v9 = floorf((float)((float)(MinX + -10.0) / 50.0) + 60.0);
  v10 = floorf((float)(v6 / 50.0) + 60.0);
  v11 = (int)floorf((float)(v8 / 50.0) + 60.0);
  v12 = (int)floorf((float)(v7 / 50.0) + 60.0);
  v23 = (int)v10;
  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v13 = 1;
  }
  else
  {
    v13 = CWorld::ms_nCurrentScanCode + 1;
  }
  CWorld::ms_nCurrentScanCode = v13;
  if ( v23 <= v11 )
  {
    do
    {
      if ( (int)v9 <= v12 )
      {
        v14 = (int)v9;
        v24 = (unsigned __int8)(16 * v23);
        do
        {
          CWorld::CallOffChaseForAreaSectorListVehicles(
            (CPtrList *)&CWorld::ms_aRepeatSectors[v14 & 0xF | v24],
            MinX,
            MinY,
            MaxX,
            MaxY,
            v5,
            v6,
            v7,
            v8);
          CWorld::CallOffChaseForAreaSectorListPeds(
            &CWorld::ms_aRepeatSectors[v14 & 0xF | v24].m_ptrListArray[1],
            MinX,
            MinY,
            MaxX,
            MaxY,
            v16,
            v17,
            v18,
            v19);
          v15 = v14++ < v12;
        }
        while ( v15 );
      }
      v15 = v23++ < v11;
    }
    while ( v15 );
  }
}
// 42C5BE: variable 'v16' is possibly undefined
// 42C5BE: variable 'v17' is possibly undefined
// 42C5BE: variable 'v18' is possibly undefined
// 42C5BE: variable 'v19' is possibly undefined

//----- (0042C600) --------------------------------------------------------
void __fastcall CWorld::CallOffChaseForAreaSectorListVehicles(
        CPtrList *list,
        float MinX,
        float MinY,
        float MaxX,
        float MaxY,
        float BiggerMinX,
        float BiggerMinY,
        float BiggerMaxX,
        float BiggerMaxY)
{
  float32x2_t v9; // d0
  float32x2_t v10; // d1
  float32x2_t v11; // d3
  CPtrNode *m_pHead; // r6
  uint16 *v16; // r11
  uint32 *v17; // r8
  float v18; // s17
  float v19; // s19
  CPtrNode v20; // kr00_8
  int v21; // r0
  int v22; // r1
  float *v23; // r0
  float v24; // s0
  int v25; // r0
  bool v26; // cc
  CCollisionData *m_pColData; // r10
  int v28; // r9
  CColSphere *m_pSphereArray; // r0
  int v30; // r8
  int v31; // r11
  char v32; // r2
  char v33; // r3
  CColSphere *v34; // r1
  float m_fRadius; // s4
  bool v36; // zf
  float *v37; // r1
  int v38; // r0
  float32x2_t v39; // d16
  unsigned __int32 v40; // s4
  uint16 *v41; // [sp+0h] [bp-78h]
  uint32 *v42; // [sp+4h] [bp-74h]
  CVector v43; // [sp+Ch] [bp-6Ch] BYREF

  m_pHead = list->m_pHead;
  if ( list->m_pHead )
  {
    v16 = &CWorld::ms_nCurrentScanCode;
    v17 = &CTimer::m_snTimeInMilliseconds;
    v18 = (float)(MinY + MaxY) * 0.5;
    v19 = (float)(MinX + MaxX) * 0.5;
    do
    {
      v20 = *m_pHead;
      m_pHead = m_pHead->m_pNext;
      v21 = *v16;
      if ( *((unsigned __int16 *)v20.m_pVoid + 24) != v21 )
      {
        *((_WORD *)v20.m_pVoid + 24) = v21;
        if ( FindPlayerVehicle(-1, 0) != v20.m_pVoid )
        {
          v22 = *((_DWORD *)v20.m_pVoid + 5);
          v23 = (float *)((char *)v20.m_pVoid + 4);
          if ( v22 )
            v23 = (float *)(v22 + 48);
          if ( *v23 > BiggerMinX && *v23 < BiggerMaxX )
          {
            v24 = v23[1];
            if ( v24 > BiggerMinY && v24 < BiggerMaxY && *((unsigned __int8 *)v20.m_pVoid + 1068) << 31 )
            {
              v25 = *((unsigned __int8 *)v20.m_pVoid + 958);
              v26 = (unsigned int)(v25 - 2) > 4;
              if ( (unsigned int)(v25 - 2) >= 4 )
                v26 = (unsigned int)(v25 - 60) > 1;
              if ( !v26 )
              {
                *((_BYTE *)v20.m_pVoid + 959) = 1;
                *((_DWORD *)v20.m_pVoid + 240) = *v17 + 2000;
                m_pColData = CEntity::GetColModel((CEntity *)v20.m_pVoid)->m_pColData;
                if ( m_pColData->m_nNoOfSpheres >= 1 )
                {
                  v41 = v16;
                  v42 = v17;
                  v28 = 0;
                  m_pSphereArray = m_pColData->m_pSphereArray;
                  v30 = 0;
                  v31 = 0;
                  do
                  {
                    operator*(&v43, *((const CMatrix **)v20.m_pVoid + 5), &m_pSphereArray[v28].m_vecCentre);
                    m_pSphereArray = m_pColData->m_pSphereArray;
                    v32 = 0;
                    v33 = 0;
                    v34 = &m_pSphereArray[v28++];
                    ++v31;
                    m_fRadius = v34->m_fRadius;
                    if ( (float)(v43.x - m_fRadius) < MaxX )
                      v32 = 1;
                    if ( (float)(v43.x + m_fRadius) > MinX )
                      v33 = 1;
                    v30 |= (unsigned __int8)(v32 & v33) & ((float)(v43.y + m_fRadius) > MinY) & ((float)(v43.y - m_fRadius) < MaxY);
                  }
                  while ( v31 < m_pColData->m_nNoOfSpheres );
                  v36 = v30 << 31 == 0;
                  v17 = v42;
                  v16 = v41;
                  v37 = (float *)((char *)v20.m_pVoid + 4);
                  if ( !v36 )
                  {
                    v38 = *((_DWORD *)v20.m_pVoid + 5);
                    v9.n64_u32[0] = *((_DWORD *)v20.m_pVoid + 18);
                    v10.n64_u32[0] = *((_DWORD *)v20.m_pVoid + 19);
                    if ( v38 )
                      v37 = (float *)(v38 + 48);
                    v11.n64_u32[0] = 0;
                    v39.n64_u64[0] = v11.n64_u64[0];
                    v11.n64_u64[0] = vmax_f32(v9, v11).n64_u64[0];
                    v9.n64_u64[0] = vmin_f32(v9, v39).n64_u64[0];
                    v40 = vmax_f32(v10, v39).n64_u32[0];
                    v10.n64_u64[0] = vmin_f32(v10, v39).n64_u64[0];
                    if ( *v37 > v19 )
                      v9.n64_u32[0] = v11.n64_u32[0];
                    *((_DWORD *)v20.m_pVoid + 18) = v9.n64_u32[0];
                    if ( v37[1] > v18 )
                      v10.n64_u32[0] = v40;
                    *((_DWORD *)v20.m_pVoid + 19) = v10.n64_u32[0];
                  }
                }
              }
            }
          }
        }
      }
    }
    while ( m_pHead );
  }
}
// 42C7DA: variable 'v11' is possibly undefined
// 42C7E6: variable 'v9' is possibly undefined
// 42C7EE: variable 'v10' is possibly undefined

//----- (0042C838) --------------------------------------------------------
void __fastcall CWorld::CallOffChaseForAreaSectorListPeds(
        CPtrList *list,
        float MinX,
        float MinY,
        float MaxX,
        float MaxY,
        float BiggerMinX,
        float BiggerMinY,
        float BiggerMaxX,
        float BiggerMaxY)
{
  CPtrNode *m_pHead; // r4
  CPtrNode v13; // kr00_8
  CPedGroup *PedsGroup; // r0
  CPlayerPed *v15; // r6
  int v16; // r1
  float *v17; // r0
  float v18; // s0
  CTask *ActiveTaskByType; // r0
  CPlayerPed *v20; // r11
  CTask *v21; // r0
  CVehicle *v22; // r6
  CWanted *PlayerWanted; // r0
  CTaskSimpleStandStill *v24; // r6
  CEventScriptCommand v25[3]; // [sp+8h] [bp-58h] BYREF

  m_pHead = list->m_pHead;
  while ( m_pHead )
  {
    v13 = *m_pHead;
    m_pHead = m_pHead->m_pNext;
    if ( *((unsigned __int16 *)v13.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
    {
      *((_WORD *)v13.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
      PedsGroup = CPedGroups::GetPedsGroup((const CPed *)v13.m_pVoid);
      v15 = PedsGroup ? (CPlayerPed *)CPedGroupMembership::GetLeader(&PedsGroup->m_membership) : 0;
      if ( FindPlayerPed(-1) != v13.m_pVoid && v15 != FindPlayerPed(-1) )
      {
        v16 = *((_DWORD *)v13.m_pVoid + 5);
        v17 = (float *)(v16 + 48);
        if ( !v16 )
          v17 = (float *)((char *)v13.m_pVoid + 4);
        if ( *v17 > MinX && *v17 < MaxX )
        {
          v18 = v17[1];
          if ( v18 > MinY && v18 < MaxY )
          {
            ActiveTaskByType = CTaskManager::FindActiveTaskByType(
                                 (const CTaskManager *)(*((_DWORD *)v13.m_pVoid + 272) + 4),
                                 1000);
            v20 = ActiveTaskByType ? (CPlayerPed *)ActiveTaskByType[2]._vptr$CTask : 0;
            v21 = CTaskManager::FindActiveTaskByType((const CTaskManager *)(*((_DWORD *)v13.m_pVoid + 272) + 4), 1003);
            v22 = v21 ? (CVehicle *)v21[2]._vptr$CTask : 0;
            if ( (v20 == FindPlayerPed(-1) || v22 && v22 == FindPlayerVehicle(-1, 0))
              && CPed::IsAlive((const CPed *)v13.m_pVoid) )
            {
              if ( *((_DWORD *)v13.m_pVoid + 359) == 6 )
              {
                PlayerWanted = FindPlayerWanted(-1);
                CWanted::RemovePursuitCop(PlayerWanted, (CCopPed *)v13.m_pVoid);
              }
              v24 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
              CTaskSimpleStandStill::CTaskSimpleStandStill(v24, 0, 1, 0, 8.0);
              CEventScriptCommand::CEventScriptCommand(v25, 3, v24, 0);
              CEventGroup::Add((CEventGroup *)(*((_DWORD *)v13.m_pVoid + 272) + 104), v25, 0);
              CEventScriptCommand::~CEventScriptCommand(v25);
            }
          }
        }
      }
    }
  }
}

//----- (0042C9A8) --------------------------------------------------------
void CWorld::StopAllLawEnforcersInTheirTracks()
{
  CVehiclePool *v0; // r0
  int32 m_nSize; // r3
  int v2; // r2
  int v3; // r3
  uint8 *v4; // r6
  bool v5; // zf

  v0 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( m_nSize )
  {
    v2 = m_nSize;
    v3 = m_nSize - 1;
    do
    {
      if ( (v0->m_aFlags[v3] & 0x80u) == 0 )
      {
        v4 = v0->m_aStorage[v2];
        v5 = v4 == (uint8 *)&elf_hash_bucket[588];
        if ( v4 != (uint8 *)&elf_hash_bucket[588] )
          v5 = *(v4 - 1536) << 31 == 0;
        if ( !v5 )
        {
          *((_DWORD *)v4 - 632) = 0;
          *((_DWORD *)v4 - 633) = 0;
          *((_DWORD *)v4 - 631) = 0;
        }
      }
      --v3;
      --v2;
    }
    while ( v3 != -1 );
  }
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (0042CA1C) --------------------------------------------------------
Int32 __fastcall CWorld::FindPlayerSlotWithPedPointer(void *pPlayersPed)
{
  Int32 result; // r0

  if ( CWorld::Players[0].pPed == pPlayersPed )
    return 0;
  result = -1;
  if ( CWorld::Players[1].pPed == pPlayersPed )
    return 1;
  return result;
}

//----- (0042CA4C) --------------------------------------------------------
Int32 __fastcall CWorld::FindPlayerSlotWithRemoteVehiclePointer(void *pRemote)
{
  Int32 result; // r0

  if ( CWorld::Players[0].pRemoteVehicle == pRemote )
    return 0;
  result = -1;
  if ( CWorld::Players[1].pRemoteVehicle == pRemote )
    return 1;
  return result;
}

//----- (0042CA80) --------------------------------------------------------
Int32 __fastcall CWorld::FindPlayerSlotWithVehiclePointer(CEntity *pVehicle)
{
  return (!CWorld::Players[0].pPed || CWorld::Players[0].pPed->m_pMyVehicle != pVehicle)
      && CWorld::Players[1].pPed
      && CWorld::Players[1].pPed->m_pMyVehicle == pVehicle;
}

//----- (0042CAB8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
CVehicle *__fastcall CWorld::FindUnsuspectingTargetCar(CVector Coors, CVector AimTowardsCoors)
{
  int32 m_nSize; // r2
  float x; // s4
  float v4; // s0
  float y; // s8
  CVehicle *result; // r0
  int v7; // r1
  int i; // r6
  uint8 *v9; // r5
  int v10; // r1
  bool v11; // zf
  float *v12; // r4
  float *v13; // r1
  float v14; // s1
  float v15; // s12

  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( !m_nSize )
    return 0;
  x = Coors.x;
  v4 = 9999.9;
  y = Coors.y;
  result = 0;
  do
  {
    v7 = 2604 * m_nSize--;
    for ( i = v7 - 1160; ; i -= 2604 )
    {
      if ( (CPools::ms_pVehiclePool->m_aFlags[m_nSize] & 0x80u) == 0 )
      {
        v9 = &(*CPools::ms_pVehiclePool->m_aStorage)[i];
        if ( v9 != (uint8 *)&elf_hash_bucket[298] )
        {
          v10 = *(_DWORD *)&(*CPools::ms_pVehiclePool->m_aStorage)[i];
          v11 = v10 == 0;
          if ( !v10 )
            v11 = *(v9 - 252) == 1;
          if ( v11 && (*(v9 - 1386) & 0xF0) == 16 )
          {
            v12 = (float *)*((_DWORD *)v9 - 356);
            v13 = v12 + 12;
            if ( !v12 )
              v13 = (float *)(v9 - 1440);
            v14 = v13[1];
            v15 = sqrtf((float)((float)(x - *v13) * (float)(x - *v13)) + (float)((float)(y - v14) * (float)(y - v14)));
            if ( v15 < v4 )
              break;
          }
        }
      }
      if ( --m_nSize == -1 )
        return result;
    }
    if ( (float)((float)((float)((float)(AimTowardsCoors.x - *v13) * v12[4])
                       + (float)((float)(AimTowardsCoors.y - v14) * v12[5]))
               + (float)((float)(AimTowardsCoors.z - v13[2]) * v12[6])) > 0.0 )
    {
      v4 = v15;
      result = (CVehicle *)(v9 - 1444);
    }
  }
  while ( m_nSize );
  return result;
}
// 42CAB8: fragmented variable at 0:r3.4,4:^20.8 may be wrong
// 42CAB8: variables would overlap: 0:r3.4,4:^20.8 and ^20.4
// 42CAB8: variables would overlap: 0:r3.4,4:^20.8 and ^24.4
// FC: using guessed type int elf_hash_bucket[16411];

//----- (0042CBE4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
CPed *__fastcall CWorld::FindUnsuspectingTargetPed(CVector Coors, CVector AimTowardsCoors)
{
  CPedPool *v2; // r6
  float v3; // s16
  float x; // s18
  uint8 *v5; // r8
  float y; // s22
  int v7; // r4
  int v8; // r5
  float v9; // s26
  CPool<CPed,CCopPed>::StorageType *m_aStorage; // r10
  uint8 *v11; // r11
  unsigned int v12; // r0
  bool v13; // cc
  CTask *ActiveTask; // r0
  float *v15; // r0
  float *v16; // r1
  float v17; // s4
  float v18; // s0

  v2 = CPools::ms_pPedPool;
  LODWORD(Coors.z) = CPools::ms_pPedPool->m_nSize;
  if ( !LODWORD(Coors.z) )
    return 0;
  v3 = 9999.9;
  x = Coors.x;
  v5 = 0;
  y = Coors.y;
  v7 = 1996 * LODWORD(Coors.z) - 908;
  v8 = LODWORD(Coors.z) - 1;
  v9 = AimTowardsCoors.x;
  do
  {
    if ( (v2->m_aFlags[v8] & 0x80u) == 0 )
    {
      m_aStorage = v2->m_aStorage;
      v11 = &(*v2->m_aStorage)[v7];
      if ( v11 != (uint8 *)&elf_hash_bucket[209] && v11[8] == 1 && CPed::IsAlive((const CPed *)(v11 - 1088)) )
      {
        v12 = *((_DWORD *)v11 + 87);
        v13 = v12 > 4;
        if ( v12 != 4 )
          v13 = v12 - 7 > 9;
        if ( !v13 )
        {
          ActiveTask = CTaskManager::GetActiveTask((const CTaskManager *)(*(_DWORD *)&(*m_aStorage)[v7] + 4));
          if ( !ActiveTask || (*((int (__fastcall **)(CTask *))ActiveTask->_vptr$CTask + 5))(ActiveTask) != 912 )
          {
            v15 = (float *)*((_DWORD *)v11 - 267);
            v16 = v15 + 12;
            if ( !v15 )
              v16 = (float *)&(*m_aStorage)[v7 - 1084];
            v17 = v16[1];
            v18 = sqrtf((float)((float)(x - *v16) * (float)(x - *v16)) + (float)((float)(y - v17) * (float)(y - v17)));
            if ( v18 < v3
              && (float)((float)((float)((float)(v9 - *v16) * v15[4])
                               + (float)((float)(AimTowardsCoors.y - v17) * v15[5]))
                       + (float)((float)(AimTowardsCoors.z - v16[2]) * v15[6])) > 0.0 )
            {
              v3 = v18;
              v5 = v11 - 1088;
            }
          }
        }
      }
    }
    --v8;
    v7 -= 1996;
  }
  while ( v8 != -1 );
  return (CPed *)v5;
}
// 42CBE4: fragmented variable at 0:r3.4,4:^58.8 may be wrong
// 42CBE4: variables would overlap: 0:r3.4,4:^58.8 and ^58.4
// 42CBE4: variables would overlap: 0:r3.4,4:^58.8 and ^5C.4
// FC: using guessed type int elf_hash_bucket[16411];

//----- (0042CD3C) --------------------------------------------------------
void __fastcall CPtrListDoubleLink::~CPtrListDoubleLink(CPtrListDoubleLink *this)
{
  CPtrListDoubleLink::Flush(this);
}

//----- (0042CD50) --------------------------------------------------------
GxtChar *__fastcall CZone::GetTranslatedName(CZone *this)
{
  return sub_18A500(&TheText, (const unsigned __int8 *)&this->TextLabel);
}

//----- (0042CD70) --------------------------------------------------------
void CTheZones::Init()
{
  int v0; // r0
  CZone *v1; // r2
  int v2; // r1
  CZoneInfo *v3; // r0
  __int16 v4; // r3
  int v5; // r0
  CZone *v6; // r5

  v0 = 0;
  do
  {
    v1 = &CTheZones::NavigationZoneArray[v0++];
    v1->InfoLabel = 0LL;
    v1->TextLabel = 0LL;
    v1 = (CZone *)((char *)v1 + 15);
    v1->InfoLabel = 0LL;
    v1->TextLabel = 0LL;
  }
  while ( v0 != 380 );
  v2 = 380;
  v3 = CTheZones::ZoneInfoArray;
  do
  {
    v4 = *(_WORD *)((char *)v3 + 15);
    --v2;
    *(_DWORD *)&v3->aGangStrengths[4] = 0;
    *(_DWORD *)v3->aGangStrengths = 0;
    v3->DealerStrength = 0;
    *(_WORD *)&v3->aGangStrengths[8] = 0;
    *(_WORD *)((char *)v3++ + 15) = v4 & 0xF000 | 0xF05;
  }
  while ( v2 );
  CTheZones::TotalNumberOfZoneInfos = 1;
  CTheZones::NavigationZoneArray[0].y1 = -3000;
  CTheZones::NavigationZoneArray[0].z1 = -2000;
  CTheZones::TotalNumberOfNavigationZones = 1;
  CTheZones::NavigationZoneArray[0].x2 = 3000;
  CTheZones::NavigationZoneArray[0].y2 = 3000;
  CTheZones::NavigationZoneArray[0].z2 = 2000;
  *(_DWORD *)&CTheZones::ZonesVisited[9][6] = 0;
  *(_QWORD *)&CTheZones::ZonesVisited[0][0] = 0LL;
  *(_QWORD *)&CTheZones::ZonesVisited[0][8] = 0LL;
  *(_QWORD *)&CTheZones::ZonesVisited[1][6] = 0LL;
  *(_QWORD *)&CTheZones::ZonesVisited[2][4] = 0LL;
  *(_QWORD *)&CTheZones::ZonesVisited[8][0] = 0LL;
  *(_QWORD *)&CTheZones::ZonesVisited[8][8] = 0LL;
  *(_QWORD *)&CTheZones::ZonesVisited[6][4] = 0LL;
  *(_QWORD *)&CTheZones::ZonesVisited[7][2] = 0LL;
  *(_QWORD *)&CTheZones::ZonesVisited[4][8] = 0LL;
  *(_QWORD *)&CTheZones::ZonesVisited[5][6] = 0LL;
  CTheZones::NavigationZoneArray[0].Level = 0;
  strcpy((char *)CTheZones::NavigationZoneArray, "SAN_AND");
  strcpy((char *)&CTheZones::NavigationZoneArray[0].TextLabel, "SAN_AND");
  CTheZones::NavigationZoneArray[0].x1 = -3000;
  *(_QWORD *)&CTheZones::ZonesVisited[3][2] = 0LL;
  *(_QWORD *)&CTheZones::ZonesVisited[4][0] = 0LL;
  CTheZones::NavigationZoneArray[0].ZoneType = 0;
  v5 = 0;
  CTheZones::ZonesRevealed = 0;
  CTheZones::m_CurrLevel = LEVEL_GENERIC;
  do
  {
    v6 = &CTheZones::MapZoneArray[v5++];
    v6->InfoLabel = 0LL;
    v6->TextLabel = 0LL;
    v6->ZoneType = 3;
    v6->ZoneInfoIndex = 0;
    v6 = (CZone *)((char *)v6 + 12);
    v6->InfoLabel = 0LL;
    v6->TextLabel = 0LL;
  }
  while ( v5 != 39 );
  CTheZones::TotalNumberOfMapZones = 1;
  strcpy((char *)CTheZones::MapZoneArray, "THEMAP");
  BYTE6(CTheZones::MapZoneArray[0].TextLabel) = 0;
  WORD2(CTheZones::MapZoneArray[0].TextLabel) = 20545;
  *(_DWORD *)&CTheZones::MapZoneArray[0].x2 = 196611000;
  LODWORD(CTheZones::MapZoneArray[0].TextLabel) = CTheZones::MapZoneArray[0].InfoLabel;
  CTheZones::MapZoneArray[0].x1 = -3000;
  CTheZones::MapZoneArray[0].y1 = -3000;
  CTheZones::MapZoneArray[0].z1 = -2000;
  CTheZones::MapZoneArray[0].z2 = 2000;
  CTheZones::MapZoneArray[0].Level = 0;
}

//----- (0042CF1C) --------------------------------------------------------
void CTheZones::InitZonesPopulationSettings()
{
  int v0; // r1
  CZoneInfo *v1; // r0
  __int16 v2; // r3

  v0 = 380;
  v1 = CTheZones::ZoneInfoArray;
  do
  {
    v2 = *(_WORD *)((char *)v1 + 15);
    --v0;
    *(_DWORD *)&v1->aGangStrengths[4] = 0;
    *(_DWORD *)v1->aGangStrengths = 0;
    v1->DealerStrength = 0;
    *(_WORD *)&v1->aGangStrengths[8] = 0;
    *(_WORD *)((char *)v1++ + 15) = v2 & 0xF000 | 0xF05;
  }
  while ( v0 );
}

//----- (0042CF54) --------------------------------------------------------
void CTheZones::Update()
{
  char v0; // r0
  uint32 v1; // r0

  v0 = `guard variable for'CTheZones::Update(void)::CountSeconds;
  __dmb(0xBu);
  if ( (v0 & 1) == 0 )
  {
    if ( _cxa_guard_acquire((__guard *)&`guard variable for'CTheZones::Update(void)::CountSeconds) )
    {
      CTheZones::Update(void)::CountSeconds = CTimer::m_snTimeInMilliseconds - 5000;
      _cxa_guard_release((__guard *)&`guard variable for'CTheZones::Update(void)::CountSeconds);
    }
  }
  v1 = CTimer::m_snTimeInMilliseconds;
  if ( CGame::currArea == AREA_MAIN_MAP )
  {
    if ( CTimer::m_snTimeInMilliseconds - CTheZones::Update(void)::CountSeconds < 0x1389 )
      return;
    CTheZones::SetCurrentZoneAsUnlocked();
    v1 = CTimer::m_snTimeInMilliseconds;
  }
  CTheZones::Update(void)::CountSeconds = v1;
}
// 98F0EC: using guessed type char `guard variable for'CTheZones::Update(void)::CountSeconds;

//----- (0042CFF0) --------------------------------------------------------
void CTheZones::SetCurrentZoneAsUnlocked()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d1
  float32x2_t v2; // d3
  float32x2_t v3; // d4
  unsigned int v4; // r2
  CZone *v5; // r0
  bool v6; // zf
  unsigned int v7; // s0
  unsigned int v8; // r1
  CVector v9; // [sp+4h] [bp-14h] BYREF

  FindPlayerCoors(&v9, -1);
  if ( CTheZones::TotalNumberOfMapZones < 2u )
  {
    v5 = CTheZones::MapZoneArray;
  }
  else
  {
    v4 = 1;
    v5 = &CTheZones::MapZoneArray[1];
    while ( v9.x < (float)v5->x1
         || v9.x > (float)v5->x2
         || v9.y < (float)v5->y1
         || v9.y > (float)v5->y2
         || v9.z < (float)v5->z1
         || v9.z > (float)v5->z2 )
    {
      ++v4;
      ++v5;
      if ( v4 >= CTheZones::TotalNumberOfMapZones )
      {
        v5 = CTheZones::MapZoneArray;
        break;
      }
    }
  }
  v6 = CTheScripts::bPlayerIsOffTheMap == 0;
  CTheZones::m_CurrLevel = v5->Level;
  if ( !CTheScripts::bPlayerIsOffTheMap )
    v6 = CGame::currArea == AREA_MAIN_MAP;
  if ( v6 )
  {
    v0.n64_u32[0] = LODWORD(v9.x);
    v2.n64_u32[0] = 1161523200;
    v3.n64_u32[0] = -985960448;
    v1.n64_u32[0] = LODWORD(v9.y);
    v7 = (unsigned int)(float)((float)(vmax_f32(vmin_f32(v0, v2), v3).n64_f32[0] + 3000.0) / 600.0);
    v8 = 9 - (unsigned int)(float)((float)(vmax_f32(vmin_f32(v1, v2), v3).n64_f32[0] + 3000.0) / 600.0);
    if ( !CTheZones::ZonesVisited[v7][v8] )
    {
      CTheZones::ZonesVisited[v7][(unsigned __int8)v8] = 1;
      ++CTheZones::ZonesRevealed;
    }
  }
}
// 42D0EE: variable 'v0' is possibly undefined
// 42D0EE: variable 'v2' is possibly undefined
// 42D0FC: variable 'v3' is possibly undefined
// 42D102: variable 'v1' is possibly undefined

//----- (0042D19C) --------------------------------------------------------
void CTheZones::ResetZonesRevealed()
{
  CTheZones::ZonesRevealed = 0;
  *(_DWORD *)&CTheZones::ZonesVisited[9][6] = 0;
  *(_QWORD *)&CTheZones::ZonesVisited[8][0] = 0LL;
  *(_QWORD *)&CTheZones::ZonesVisited[8][8] = 0LL;
  *(_QWORD *)&CTheZones::ZonesVisited[6][4] = 0LL;
  *(_QWORD *)&CTheZones::ZonesVisited[7][2] = 0LL;
  *(_QWORD *)&CTheZones::ZonesVisited[4][8] = 0LL;
  *(_QWORD *)&CTheZones::ZonesVisited[5][6] = 0LL;
  *(_QWORD *)&CTheZones::ZonesVisited[3][2] = 0LL;
  *(_QWORD *)&CTheZones::ZonesVisited[4][0] = 0LL;
  *(_QWORD *)&CTheZones::ZonesVisited[0][0] = 0LL;
  *(_QWORD *)&CTheZones::ZonesVisited[0][8] = 0LL;
  *(_QWORD *)&CTheZones::ZonesVisited[1][6] = 0LL;
  *(_QWORD *)&CTheZones::ZonesVisited[2][4] = 0LL;
}

//----- (0042D1E4) --------------------------------------------------------
eLevelName __fastcall CTheZones::GetLevelFromPosition(const CVector *pPoint)
{
  unsigned int v1; // r3
  float x; // s0
  CZone *v3; // r1
  float y; // s2
  float z; // s2

  if ( CTheZones::TotalNumberOfMapZones < 2u )
    return CTheZones::MapZoneArray[0].Level;
  v1 = 1;
  x = pPoint->x;
  v3 = &CTheZones::MapZoneArray[1];
  while ( 1 )
  {
    if ( x >= (float)v3->x1 && x <= (float)v3->x2 )
    {
      y = pPoint->y;
      if ( y >= (float)v3->y1 && y <= (float)v3->y2 )
      {
        z = pPoint->z;
        if ( z >= (float)v3->z1 && z <= (float)v3->z2 )
          break;
      }
    }
    ++v1;
    ++v3;
    if ( v1 >= CTheZones::TotalNumberOfMapZones )
    {
      v3 = CTheZones::MapZoneArray;
      return v3->Level;
    }
  }
  return v3->Level;
}

//----- (0042D2C4) --------------------------------------------------------
bool8 __fastcall CTheZones::GetCurrentZoneLockedOrUnlocked(float x, float y)
{
  float32x2_t v2; // d1
  float32x2_t v3; // d2
  float32x2_t v4; // d3
  float32x2_t v5; // d4

  v2.n64_u32[0] = 1161523200;
  v3.n64_f32[0] = x;
  v4.n64_u32[0] = -985960448;
  v5.n64_f32[0] = y;
  return CTheZones::ZonesVisited[(float)((float)(vmax_f32(vmin_f32(v3, v2), v4).n64_f32[0] + 3000.0) / 600.0)][9 - (unsigned int)(float)((float)(vmax_f32(vmin_f32(v5, v2), v4).n64_f32[0] + 3000.0) / 600.0)] != 0;
}
// 42D2D4: variable 'v3' is possibly undefined
// 42D2D4: variable 'v2' is possibly undefined
// 42D2E0: variable 'v4' is possibly undefined
// 42D2E4: variable 'v5' is possibly undefined

//----- (0042D33C) --------------------------------------------------------
void __fastcall CTheZones::CreateZone(
        Char *pNewInfoLabel,
        eZoneType NewZoneType,
        float NewX1,
        float NewY1,
        float NewZ1,
        float NewX2,
        float NewY2,
        float NewZ2,
        eLevelName level,
        Char *pTextLabel)
{
  float32x2_t v10; // d0
  float32x2_t v11; // d1
  float32x2_t v12; // d2
  float32x2_t v13; // d3
  float v16; // s16
  float v17; // s20
  float v18; // s18
  float v19; // s24
  float v20; // s22
  float v21; // s26
  unsigned __int16 v22; // r0
  unsigned int v23; // r1
  int v24; // r12
  int v25; // lr
  unsigned int v26; // r2
  int v27; // r0
  bool v28; // zf
  unsigned __int16 v29; // r2
  int8x16_t v30; // q8
  uint8x16_t v31; // q9
  int v32; // r2
  Char *v33; // r4
  int8x16_t v34; // q10
  uint8x16_t v35; // q11
  Char v36; // r3
  unsigned __int16 v37; // r0
  unsigned int v38; // r1
  int v39; // r12
  int v40; // r3
  unsigned int v41; // r2
  int v42; // r0
  unsigned __int16 v43; // r2
  int8x16_t v44; // q8
  uint8x16_t v45; // q9
  int v46; // r2
  Char *v47; // r4
  int8x16_t v48; // q10
  uint8x16_t v49; // q11
  Char v50; // r3
  unsigned int v51; // r0
  CZone *v52; // r1
  int v53; // r6
  unsigned __int16 v54; // r2
  UInt16 *v55; // r5
  CZone *v56; // r1
  int v57; // r3
  UInt16 v58; // r3
  char v59[8]; // [sp+4h] [bp-5Ch] BYREF
  char v60[8]; // [sp+Ch] [bp-54h] BYREF

  v10.n64_f32[0] = NewZ2;
  v11.n64_f32[0] = NewZ1;
  v12.n64_f32[0] = NewY2;
  LODWORD(v16) = vmax_f32(v11, v10).n64_u32[0];
  v13.n64_f32[0] = NewX2;
  LODWORD(v17) = vmin_f32(v11, v10).n64_u32[0];
  v10.n64_f32[0] = NewX1;
  v11.n64_f32[0] = NewY1;
  LODWORD(v18) = vmin_f32(v11, v12).n64_u32[0];
  LODWORD(v19) = vmax_f32(v11, v12).n64_u32[0];
  LODWORD(v20) = vmin_f32(v10, v13).n64_u32[0];
  LODWORD(v21) = vmax_f32(v10, v13).n64_u32[0];
  v22 = strlen((const char *)pNewInfoLabel);
  v23 = v22;
  if ( !v22 )
    goto LABEL_47;
  if ( v22 < 0x10u || (v24 = v22 & 0xF, v25 = v22 - v24, v22 == v24) )
  {
    v27 = 0;
    v29 = 0;
    goto LABEL_44;
  }
  v26 = v22 - 1;
  v27 = 0;
  if ( (unsigned __int16)(v23 - 1) == 0xFFFF )
  {
    v29 = 0;
    do
    {
LABEL_44:
      v36 = pNewInfoLabel[v27];
      ++v29;
      if ( (unsigned __int8)(v36 - 97) <= 0x19u )
        pNewInfoLabel[v27] = v36 - 32;
      v27 = v29;
    }
    while ( v23 > v29 );
    goto LABEL_47;
  }
  v28 = HIWORD(v26) == 0;
  v29 = 0;
  if ( !v28 )
    goto LABEL_44;
  v30.n128_u64[0] = 0x9F9F9F9F9F9F9F9FLL;
  v30.n128_u64[1] = 0x9F9F9F9F9F9F9F9FLL;
  v27 = v25;
  v31.n128_u64[0] = 0x1A1A1A1A1A1A1A1ALL;
  v31.n128_u64[1] = 0x1A1A1A1A1A1A1A1ALL;
  v32 = 0;
  do
  {
    v33 = &pNewInfoLabel[v32];
    v34 = *(int8x16_t *)&pNewInfoLabel[v32];
    v35 = vcgtq_u8(v31, vaddq_s8(v34, v30));
    if ( v35.n128_u8[0] << 31 )
      pNewInfoLabel[v32] = v34.n128_u8[0] - 32;
    v32 += 16;
    if ( v35.n128_u8[1] << 31 )
      v33[1] = v34.n128_u8[1] - 32;
    if ( v35.n128_u8[2] << 31 )
      v33[2] = v34.n128_u8[2] - 32;
    if ( v35.n128_u8[3] << 31 )
      v33[3] = v34.n128_u8[3] - 32;
    if ( v35.n128_u8[4] << 31 )
      v33[4] = v34.n128_u8[4] - 32;
    if ( v35.n128_u8[5] << 31 )
      v33[5] = v34.n128_u8[5] - 32;
    if ( v35.n128_u8[6] << 31 )
      v33[6] = v34.n128_u8[6] - 32;
    if ( v35.n128_u8[7] << 31 )
      v33[7] = v34.n128_u8[7] - 32;
    if ( v35.n128_u8[8] << 31 )
      v33[8] = v34.n128_u8[8] - 32;
    if ( v35.n128_u8[9] << 31 )
      v33[9] = v34.n128_u8[9] - 32;
    if ( v35.n128_u8[10] << 31 )
      v33[10] = v34.n128_u8[10] - 32;
    if ( v35.n128_u8[11] << 31 )
      v33[11] = v34.n128_u8[11] - 32;
    if ( v35.n128_u8[12] << 31 )
      v33[12] = v34.n128_u8[12] - 32;
    if ( v35.n128_u8[13] << 31 )
      v33[13] = v34.n128_u8[13] - 32;
    if ( v35.n128_u8[14] << 31 )
      v33[14] = v34.n128_u8[14] - 32;
    if ( v35.n128_u8[15] << 31 )
      v33[15] = v34.n128_u8[15] - 32;
  }
  while ( v25 != v32 );
  v29 = v25;
  if ( v24 )
    goto LABEL_44;
LABEL_47:
  strncpy(v60, (const char *)pNewInfoLabel, 7u);
  v60[7] = 0;
  v37 = strlen((const char *)pTextLabel);
  v38 = v37;
  if ( !v37 )
    goto LABEL_93;
  if ( v37 < 0x10u || (v39 = v37 & 0xF, v40 = v37 - v39, v37 == v39) )
  {
    v42 = 0;
    v43 = 0;
    goto LABEL_90;
  }
  v41 = v37 - 1;
  v42 = 0;
  if ( (unsigned __int16)(v38 - 1) == 0xFFFF )
  {
    v43 = 0;
    do
    {
LABEL_90:
      v50 = pTextLabel[v42];
      ++v43;
      if ( (unsigned __int8)(v50 - 97) <= 0x19u )
        pTextLabel[v42] = v50 - 32;
      v42 = v43;
    }
    while ( v38 > v43 );
    goto LABEL_93;
  }
  v28 = HIWORD(v41) == 0;
  v43 = 0;
  if ( !v28 )
    goto LABEL_90;
  v44.n128_u64[0] = 0x9F9F9F9F9F9F9F9FLL;
  v44.n128_u64[1] = 0x9F9F9F9F9F9F9F9FLL;
  v42 = v40;
  v45.n128_u64[0] = 0x1A1A1A1A1A1A1A1ALL;
  v45.n128_u64[1] = 0x1A1A1A1A1A1A1A1ALL;
  v46 = 0;
  do
  {
    v47 = &pTextLabel[v46];
    v48 = *(int8x16_t *)&pTextLabel[v46];
    v49 = vcgtq_u8(v45, vaddq_s8(v48, v44));
    if ( v49.n128_u8[0] << 31 )
      pTextLabel[v46] = v48.n128_u8[0] - 32;
    v46 += 16;
    if ( v49.n128_u8[1] << 31 )
      v47[1] = v48.n128_u8[1] - 32;
    if ( v49.n128_u8[2] << 31 )
      v47[2] = v48.n128_u8[2] - 32;
    if ( v49.n128_u8[3] << 31 )
      v47[3] = v48.n128_u8[3] - 32;
    if ( v49.n128_u8[4] << 31 )
      v47[4] = v48.n128_u8[4] - 32;
    if ( v49.n128_u8[5] << 31 )
      v47[5] = v48.n128_u8[5] - 32;
    if ( v49.n128_u8[6] << 31 )
      v47[6] = v48.n128_u8[6] - 32;
    if ( v49.n128_u8[7] << 31 )
      v47[7] = v48.n128_u8[7] - 32;
    if ( v49.n128_u8[8] << 31 )
      v47[8] = v48.n128_u8[8] - 32;
    if ( v49.n128_u8[9] << 31 )
      v47[9] = v48.n128_u8[9] - 32;
    if ( v49.n128_u8[10] << 31 )
      v47[10] = v48.n128_u8[10] - 32;
    if ( v49.n128_u8[11] << 31 )
      v47[11] = v48.n128_u8[11] - 32;
    if ( v49.n128_u8[12] << 31 )
      v47[12] = v48.n128_u8[12] - 32;
    if ( v49.n128_u8[13] << 31 )
      v47[13] = v48.n128_u8[13] - 32;
    if ( v49.n128_u8[14] << 31 )
      v47[14] = v48.n128_u8[14] - 32;
    if ( v49.n128_u8[15] << 31 )
      v47[15] = v48.n128_u8[15] - 32;
  }
  while ( v40 != v46 );
  v43 = v40;
  if ( v39 )
    goto LABEL_90;
LABEL_93:
  strncpy(v59, (const char *)pTextLabel, 7u);
  v59[7] = 0;
  if ( (unsigned int)NewZoneType >= ZONE_INFORMATION )
  {
    if ( NewZoneType != ZONE_MAP )
      return;
    v55 = &CTheZones::TotalNumberOfMapZones;
    strcpy((char *)&CTheZones::MapZoneArray[CTheZones::TotalNumberOfMapZones], v60);
    strcpy((char *)&CTheZones::MapZoneArray[CTheZones::TotalNumberOfMapZones].TextLabel, v59);
    LOWORD(v51) = CTheZones::TotalNumberOfMapZones;
    v56 = &CTheZones::MapZoneArray[CTheZones::TotalNumberOfMapZones];
    v56->x1 = (int)v20;
    v56->ZoneType = 3;
    v56->y1 = (int)v18;
    v56->z1 = (int)v17;
    v56->x2 = (int)v21;
    v56->y2 = (int)v19;
    v56->z2 = (int)v16;
    v56->Level = level;
  }
  else
  {
    strcpy((char *)&CTheZones::NavigationZoneArray[CTheZones::TotalNumberOfNavigationZones], v60);
    strcpy((char *)&CTheZones::NavigationZoneArray[CTheZones::TotalNumberOfNavigationZones].TextLabel, v59);
    v51 = CTheZones::TotalNumberOfNavigationZones;
    v52 = &CTheZones::NavigationZoneArray[CTheZones::TotalNumberOfNavigationZones];
    v53 = 0;
    v52->x1 = (int)v20;
    v52->ZoneType = NewZoneType;
    v52->y1 = (int)v18;
    v52->z1 = (int)v17;
    v52->x2 = (int)v21;
    v52->y2 = (int)v19;
    v52->z2 = (int)v16;
    v54 = 0;
    v52->Level = level;
    while ( v54 < v51 && !(v53 << 24) )
    {
      v53 = 0;
      if ( v54 != v51 )
      {
        v57 = LODWORD(CTheZones::NavigationZoneArray[v54].InfoLabel) ^ LODWORD(v52->InfoLabel) | HIDWORD(CTheZones::NavigationZoneArray[v54].InfoLabel) ^ HIDWORD(v52->InfoLabel);
        v53 = 0;
        if ( CTheZones::NavigationZoneArray[v54].InfoLabel == v52->InfoLabel )
          v53 = 1;
        else
          LOWORD(v57) = 1;
        v54 += v57;
      }
    }
    v55 = &CTheZones::TotalNumberOfNavigationZones;
    if ( v53 << 24 )
    {
      CTheZones::NavigationZoneArray[v51].ZoneInfoIndex = CTheZones::NavigationZoneArray[v54].ZoneInfoIndex;
    }
    else
    {
      v58 = CTheZones::TotalNumberOfZoneInfos;
      CTheZones::NavigationZoneArray[v51].ZoneInfoIndex = CTheZones::TotalNumberOfZoneInfos;
      CTheZones::TotalNumberOfZoneInfos = v58 + 1;
    }
  }
  *v55 = v51 + 1;
}
// 42D362: variable 'v11' is possibly undefined
// 42D362: variable 'v10' is possibly undefined
// 42D37E: variable 'v12' is possibly undefined
// 42D386: variable 'v13' is possibly undefined

//----- (0042D878) --------------------------------------------------------
void __fastcall CTheZones::AssignZoneInfoForThisZone(UInt16 NewZoneIndex)
{
  CZone *v1; // r12
  unsigned __int16 v2; // r1
  int v3; // r2
  int v4; // r4
  int v5; // r2
  UInt16 v6; // r3

  v1 = &CTheZones::NavigationZoneArray[NewZoneIndex];
  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    v5 = v3 << 24;
    if ( v5 || v2 >= (unsigned int)CTheZones::TotalNumberOfNavigationZones )
      break;
    v3 = 0;
    if ( v2 != NewZoneIndex )
    {
      v4 = HIDWORD(CTheZones::NavigationZoneArray[v2].InfoLabel) ^ HIDWORD(v1->InfoLabel) | LODWORD(v1->InfoLabel) ^ LODWORD(CTheZones::NavigationZoneArray[v2].InfoLabel);
      v3 = 0;
      if ( v1->InfoLabel == CTheZones::NavigationZoneArray[v2].InfoLabel )
        v3 = 1;
      else
        LOWORD(v4) = 1;
      v2 += v4;
    }
  }
  if ( v5 )
  {
    CTheZones::NavigationZoneArray[NewZoneIndex].ZoneInfoIndex = CTheZones::NavigationZoneArray[v2].ZoneInfoIndex;
  }
  else
  {
    v6 = CTheZones::TotalNumberOfZoneInfos;
    CTheZones::NavigationZoneArray[NewZoneIndex].ZoneInfoIndex = CTheZones::TotalNumberOfZoneInfos;
    CTheZones::TotalNumberOfZoneInfos = v6 + 1;
  }
}

//----- (0042D92A) --------------------------------------------------------
Bool8 __fastcall CTheZones::ZoneIsEntirelyContainedWithinOtherZone(CZone *pSmallZone, CZone *pBigZone)
{
  return pSmallZone->x1 >= pBigZone->x1
      && pSmallZone->x2 <= pBigZone->x2
      && pSmallZone->y1 >= pBigZone->y1
      && pSmallZone->y2 <= pBigZone->y2
      && pSmallZone->z1 >= pBigZone->z1
      && pSmallZone->z2 <= pBigZone->z2;
}

//----- (0042D97C) --------------------------------------------------------
Bool8 __fastcall CTheZones::PointLiesWithinZone(const CVector *pPoint, CZone *pZone)
{
  float y; // s0
  float z; // s0
  Bool8 result; // r0

  result = 0;
  if ( pPoint->x >= (float)pZone->x1 && pPoint->x <= (float)pZone->x2 )
  {
    y = pPoint->y;
    if ( y >= (float)pZone->y1 && y <= (float)pZone->y2 )
    {
      z = pPoint->z;
      if ( z >= (float)pZone->z1 && z <= (float)pZone->z2 )
        return 1;
    }
  }
  return result;
}

//----- (0042DA14) --------------------------------------------------------
int __fastcall CTheZones::DoesPointLieWithinZoneWithGivenName(
        const CVector *pPoint,
        UInt64 FindZoneInt,
        eZoneType ZType)
{
  int v4; // lr
  Int16 *i; // r1
  float y; // s0
  float z; // s0
  int v8; // lr
  Int16 *j; // r1
  float v10; // s0
  float v11; // s0

  if ( ZType )
  {
    if ( ZType == ZONE_INFORMATION && CTheZones::TotalNumberOfNavigationZones )
    {
      v4 = 0;
      for ( i = &CTheZones::NavigationZoneArray[0].x1; ; i += 16 )
      {
        if ( *((_QWORD *)i - 2) == FindZoneInt && pPoint->x >= (float)*i && pPoint->x <= (float)i[3] )
        {
          y = pPoint->y;
          if ( y >= (float)i[1] && y <= (float)i[4] )
          {
            z = pPoint->z;
            if ( z >= (float)i[2] && z <= (float)i[5] )
              break;
          }
        }
        if ( ++v4 >= (unsigned int)CTheZones::TotalNumberOfNavigationZones )
          return 0;
      }
      return 1;
    }
    return 0;
  }
  if ( !CTheZones::TotalNumberOfNavigationZones )
    return 0;
  v8 = 0;
  for ( j = &CTheZones::NavigationZoneArray[0].x1; ; j += 16 )
  {
    if ( *((_QWORD *)j - 1) == FindZoneInt && pPoint->x >= (float)*j && pPoint->x <= (float)j[3] )
    {
      v10 = pPoint->y;
      if ( v10 >= (float)j[1] && v10 <= (float)j[4] )
      {
        v11 = pPoint->z;
        if ( v11 >= (float)j[2] && v11 <= (float)j[5] )
          break;
      }
    }
    if ( ++v8 >= (unsigned int)CTheZones::TotalNumberOfNavigationZones )
      return 0;
  }
  return 1;
}

//----- (0042DBC8) --------------------------------------------------------
CZone *__fastcall CTheZones::GetNavigationZone(const UInt16 Index)
{
  return &CTheZones::NavigationZoneArray[Index];
}

//----- (0042DBD8) --------------------------------------------------------
Int16 __fastcall CTheZones::FindZoneByLabelAndReturnIndex(Char *FindLabel, eZoneType ZType)
{
  Int16 v3; // r12
  unsigned __int16 v4; // r3
  __int64 v5; // r4
  int v7; // [sp+0h] [bp-10h] BYREF
  int v8; // [sp+4h] [bp-Ch]

  v7 = 0;
  v8 = 0;
  strcpy((char *)&v7, (const char *)FindLabel);
  v3 = -1;
  if ( ZType == ZONE_INFORMATION && CTheZones::TotalNumberOfNavigationZones )
  {
    v4 = 0;
    LODWORD(v5) = v8;
    while ( 1 )
    {
      HIDWORD(v5) = LODWORD(CTheZones::NavigationZoneArray[v4].InfoLabel) ^ v7;
      if ( v5 == HIDWORD(CTheZones::NavigationZoneArray[v4].InfoLabel) )
        break;
      if ( ++v4 >= (unsigned int)CTheZones::TotalNumberOfNavigationZones )
        return v3;
    }
    return v4;
  }
  return v3;
}

//----- (0042DC40) --------------------------------------------------------
CZone *__fastcall CTheZones::FindSmallestZoneForPosition(const CVector *pPoint, Bool8 bCheckForNavigationZonesOnly)
{
  CZone *v2; // lr
  unsigned int v3; // r4
  unsigned int v4; // r12
  UInt8 *p_ZoneType; // r2
  bool v6; // zf
  int v7; // r8
  float y; // s0
  int v9; // r9
  float z; // s0

  if ( CTheZones::TotalNumberOfNavigationZones < 2u )
    return CTheZones::NavigationZoneArray;
  v2 = CTheZones::NavigationZoneArray;
  v3 = 1;
  v4 = CTheZones::NavigationZoneArray[0].x2
     - CTheZones::NavigationZoneArray[0].x1
     + CTheZones::NavigationZoneArray[0].y2
     - CTheZones::NavigationZoneArray[0].y1;
  p_ZoneType = &CTheZones::NavigationZoneArray[1].ZoneType;
  do
  {
    v6 = bCheckForNavigationZonesOnly == 0;
    if ( bCheckForNavigationZonesOnly )
      v6 = *p_ZoneType == 0;
    if ( v6 && pPoint->x >= (float)*((__int16 *)p_ZoneType - 7) && pPoint->x <= (float)*((__int16 *)p_ZoneType - 4) )
    {
      v7 = *((__int16 *)p_ZoneType - 6);
      y = pPoint->y;
      if ( y >= (float)v7 )
      {
        v9 = *((__int16 *)p_ZoneType - 3);
        if ( y <= (float)v9 )
        {
          z = pPoint->z;
          if ( z >= (float)*((__int16 *)p_ZoneType - 5)
            && z <= (float)*((__int16 *)p_ZoneType - 2)
            && *((__int16 *)p_ZoneType - 4) - *((__int16 *)p_ZoneType - 7) + v9 - v7 < v4 )
          {
            v2 = (CZone *)(p_ZoneType - 30);
            v4 = *((__int16 *)p_ZoneType - 4) - *((__int16 *)p_ZoneType - 7) + v9 - v7;
          }
        }
      }
    }
    ++v3;
    p_ZoneType += 32;
  }
  while ( v3 < CTheZones::TotalNumberOfNavigationZones );
  return v2;
}

//----- (0042DD50) --------------------------------------------------------
CZoneInfo *__fastcall CTheZones::GetZoneInfo(const CVector *pPoint, CZone **ppZoneReturn)
{
  CZone *SmallestZoneForPosition; // r0
  CZoneInfo *result; // r0

  SmallestZoneForPosition = CTheZones::FindSmallestZoneForPosition(pPoint, 0);
  if ( SmallestZoneForPosition )
  {
    if ( ppZoneReturn )
      *ppZoneReturn = SmallestZoneForPosition;
    return &CTheZones::ZoneInfoArray[SmallestZoneForPosition->ZoneInfoIndex];
  }
  else
  {
    result = CTheZones::ZoneInfoArray;
    if ( ppZoneReturn )
      *ppZoneReturn = CTheZones::NavigationZoneArray;
  }
  return result;
}

//----- (0042DDA0) --------------------------------------------------------
void __fastcall CTheZones::SetZoneRadarColours(
        const int32 ZoneIndex,
        __int16 ArgRadarMode,
        const UInt8 ArgRadarRed,
        const UInt8 ArgRadarGreen,
        const UInt8 ArgRadarBlue)
{
  CZoneInfo *v5; // r0
  __int16 v6; // r2

  v5 = &CTheZones::ZoneInfoArray[CTheZones::NavigationZoneArray[(unsigned __int16)ZoneIndex].ZoneInfoIndex];
  v5->RadarRed = ArgRadarRed;
  v5->RadarGreen = ArgRadarGreen;
  v6 = *(_WORD *)((char *)v5 + 15);
  v5->RadarBlue = ArgRadarBlue;
  *(_WORD *)((char *)v5 + 15) = (32 * ArgRadarMode) & 0x60 | v6 & 0xFF9F;
}

//----- (0042DDF0) --------------------------------------------------------
void __fastcall CTheZones::FillZonesWithGangColours(bool bSwitchOff)
{
  int v1; // r9
  CZoneInfo *v2; // r5
  unsigned int v3; // r10
  unsigned int v4; // r11
  unsigned int v5; // r6
  unsigned int v6; // r8
  __int16 v7; // r0
  unsigned int v8; // r4
  unsigned int v9; // r0
  char v10; // r1
  _BOOL4 v11; // [sp+0h] [bp-30h]

  v11 = bSwitchOff;
  if ( CTheZones::TotalNumberOfZoneInfos )
  {
    v1 = 0;
    v2 = CTheZones::ZoneInfoArray;
    do
    {
      v3 = gaGangColoursG[2] * v2->aGangStrengths[2]
         + gaGangColoursG[0] * v2->aGangStrengths[0]
         + gaGangColoursG[1] * v2->aGangStrengths[1];
      v4 = gaGangColoursR[2] * v2->aGangStrengths[2]
         + gaGangColoursR[0] * v2->aGangStrengths[0]
         + gaGangColoursR[1] * v2->aGangStrengths[1];
      v5 = gaGangColoursB[2] * v2->aGangStrengths[2]
         + gaGangColoursB[0] * v2->aGangStrengths[0]
         + gaGangColoursB[1] * v2->aGangStrengths[1];
      v6 = v2->aGangStrengths[0] + v2->aGangStrengths[1] + v2->aGangStrengths[2];
      if ( v6 && !v11 && CGangWars::CanPlayerStartAGangWarHere(v2) )
        v7 = *(_WORD *)((char *)v2 + 15) & 0xFF9F | 0x20;
      else
        v7 = *(_WORD *)((char *)v2 + 15) & 0xFF9F;
      v8 = v6;
      *(_WORD *)((char *)v2 + 15) = v7;
      if ( v6 <= 1 )
        v8 = 1;
      v2->RadarRed = v4 / v8;
      v2->RadarGreen = v3 / v8;
      v2->RadarBlue = v5 / v8;
      v9 = 3 * v6;
      ++v1;
      if ( 3 * v6 >= 0x78 )
        v9 = 120;
      v10 = v9;
      if ( v9 <= 0x37 )
        v10 = 55;
      if ( !v6 )
        v10 = v9;
      v2->RadarAlpha = v10;
      ++v2;
    }
    while ( v1 < CTheZones::TotalNumberOfZoneInfos );
  }
}

//----- (0042DF1C) --------------------------------------------------------
CZone *__fastcall CTheZones::GetMapZone(const UInt16 Index)
{
  return &CTheZones::MapZoneArray[Index];
}

//----- (0042DF2C) --------------------------------------------------------
float __fastcall CTheZones::Calc2DDistanceBetween2Zones(CZone *pZone1, CZone *pZone2)
{
  int x2; // r2
  int x1; // r3
  int v4; // r2
  int v5; // r2
  int v6; // r3
  float v7; // s0
  int y2; // r2
  int y1; // r3
  int v10; // r0
  int v11; // r1
  int v12; // r0
  float v13; // s2

  x2 = pZone2->x2;
  x1 = pZone1->x1;
  if ( x1 > x2 )
  {
    v4 = x1 - x2;
LABEL_5:
    v7 = (float)v4;
    goto LABEL_7;
  }
  v5 = pZone2->x1;
  v6 = pZone1->x2;
  if ( v5 > v6 )
  {
    v4 = v5 - v6;
    goto LABEL_5;
  }
  v7 = 0.0;
LABEL_7:
  y2 = pZone2->y2;
  y1 = pZone1->y1;
  if ( y1 <= y2 )
  {
    v11 = pZone2->y1;
    v12 = pZone1->y2;
    if ( v11 <= v12 )
    {
      v13 = 0.0;
      return sqrtf((float)(v7 * v7) + (float)(v13 * v13));
    }
    v10 = v11 - v12;
  }
  else
  {
    v10 = y1 - y2;
  }
  v13 = (float)v10;
  return sqrtf((float)(v7 * v7) + (float)(v13 * v13));
}

//----- (0042DFA0) --------------------------------------------------------
void __fastcall CMenuManager::CMenuManager(CMenuManager *this)
{
  RwInt32 m_PrefsResolution; // r0

  CSprite2d::CSprite2d(this->FrontEndSprites);
  CSprite2d::CSprite2d(&this->FrontEndSprites[1]);
  CSprite2d::CSprite2d(&this->FrontEndSprites[2]);
  CSprite2d::CSprite2d(&this->FrontEndSprites[3]);
  CSprite2d::CSprite2d(&this->FrontEndSprites[4]);
  CSprite2d::CSprite2d(&this->FrontEndSprites[5]);
  CSprite2d::CSprite2d(&this->FrontEndSprites[6]);
  CSprite2d::CSprite2d(&this->FrontEndSprites[7]);
  CSprite2d::CSprite2d(&this->FrontEndSprites[8]);
  CSprite2d::CSprite2d(&this->FrontEndSprites[9]);
  CSprite2d::CSprite2d(&this->FrontEndSprites[10]);
  CSprite2d::CSprite2d(&this->FrontEndSprites[11]);
  CSprite2d::CSprite2d(&this->FrontEndSprites[12]);
  CSprite2d::CSprite2d(&this->FrontEndSprites[13]);
  CSprite2d::CSprite2d(&this->FrontEndSprites[14]);
  CSprite2d::CSprite2d(&this->FrontEndSprites[15]);
  CSprite2d::CSprite2d(&this->FrontEndSprites[16]);
  CSprite2d::CSprite2d(&this->FrontEndSprites[17]);
  CSprite2d::CSprite2d(&this->FrontEndSprites[18]);
  CSprite2d::CSprite2d(&this->FrontEndSprites[19]);
  CSprite2d::CSprite2d(&this->FrontEndSprites[20]);
  CSprite2d::CSprite2d(&this->FrontEndSprites[21]);
  CSprite2d::CSprite2d(&this->FrontEndSprites[22]);
  CSprite2d::CSprite2d(&this->FrontEndSprites[23]);
  CSprite2d::CSprite2d(&this->FrontEndSprites[24]);
  *(_WORD *)&this->m_DeleteAllBoundControls = 0;
  this->m_PrefsSubSystem = 0;
  Fx_c::SetFxQuality(&g_fx, FX_QUALITY_HIGH);
  this->m_PrefsLOD = 1.25;
  CRenderer::ms_lodDistScale = 1.25;
  this->m_PrefsShowLegend = 0;
  this->m_PrefsUseWideScreen = 0;
  this->m_PrefsResolutionDisp = this->m_PrefsResolution;
  this->m_PrefsFrameLimiter = 1;
  this->m_PrefsShowFPS = 0;
  this->m_PrefsDisplayHud = 1;
  this->m_PrefsSavePhotosToGallery = 1;
  this->m_PrefsMipMap = 1;
  this->m_PrefsAntiAliasing = 1;
  this->m_PrefsAntiAliasingDisp = 1;
  this->m_PrefsShowSubtitles = 1;
  this->m_PrefsMobileEffects = 2;
  this->m_ControlMethod = 2;
  CVehicle::m_bEnableMouseSteering = 0;
  MousePointerStateHelper.m_bUpAndDownInverted = 0;
  CVehicle::m_bEnableMouseFlying = 0;
  CCamera::m_fMouseAccelHorzntl = 0.0025;
  this->oldMousePosX = 0;
  this->oldMousePosY = 0;
  this->MouseInBounds = 16;
  this->m_PrefsSfxVolume = 64;
  this->m_PrefsMusicVolume = 64;
  *(_QWORD *)&this->MousePosX = *(_QWORD *)&this->WinMousePosX;
  this->pControlEdit = 0;
  this->OS_Language = 0;
  this->m_PrefsLastUserTrackID = 0;
  this->ListSelection = 0;
  *(_WORD *)&this->m_PrefsJoyLeftAxisInvert = 0;
  this->m_MainMenu = 1;
  this->DisplayTheMouse = 0;
  this->bPauseWhenInWidescreen = 0;
  this->m_PrefsAudioOutputMode = 1;
  *(_DWORD *)&this->m_PrefsJoyLeftXInvert = 0;
  this->m_PrefsAutoRetune = 1;
  this->m_PrefsUseBass = 1;
  this->m_PrefsAutoMediaScan = 0;
  this->m_PrefsPlayMode = 0;
  CAudioEngine::SetMusicMasterVolume(&AudioEngine, FrontEndMenuManager.m_PrefsMusicVolume);
  CAudioEngine::SetEffectsMasterVolume(&AudioEngine, FrontEndMenuManager.m_PrefsSfxVolume);
  CAudioEngine::SetBassEnhanceOnOff(&AudioEngine, FrontEndMenuManager.m_PrefsUseBass);
  CAudioEngine::SetRadioAutoRetuneOnOff(&AudioEngine, FrontEndMenuManager.m_PrefsAutoRetune);
  Fx_c::SetFxQuality(&g_fx, FX_QUALITY_HIGH);
  this->m_PrefsLOD = 1.25;
  CRenderer::ms_lodDistScale = 1.25;
  m_PrefsResolution = this->m_PrefsResolution;
  this->m_PrefsShowLegend = 0;
  this->m_PrefsUseWideScreen = 0;
  this->m_PrefsFrameLimiter = 1;
  this->m_PrefsShowFPS = 0;
  this->m_PrefsDisplayHud = 1;
  this->m_PrefsSavePhotosToGallery = 1;
  this->m_PrefsMipMap = 1;
  this->m_PrefsAntiAliasing = 1;
  this->m_PrefsAntiAliasingDisp = 1;
  this->m_PrefsShowSubtitles = 1;
  this->m_PrefsMobileEffects = 2;
  this->m_PrefsResolutionDisp = m_PrefsResolution;
  this->m_PrefsRadioStation = CAEAudioUtility::GetRandomNumberInRange(1, 13);
  this->m_KeyPressedCode = -1;
  this->bFrontEnd_ReloadObrTxtGxt = 0;
  this->m_PrefsLanguage = 0;
  this->m_PrefsKeyboardLanguage = LANGUAGE_ENGLISH;
  this->m_previousLanguage = 0;
  this->m_SystemLanguage = LANGUAGE_ENGLISH;
  this->m_PrefsUseVibration = 1;
  this->m_DisplayControllerOnFoot = 0;
  this->m_UseDebugScripts = 0;
  this->m_PrefsMarketing = 0;
}

//----- (0042E238) --------------------------------------------------------
void __fastcall CMenuManager::SetDefaultPreferences(CMenuManager *this, int8 ScreenToDefault)
{
  RwInt32 m_PrefsResolution; // r1

  switch ( ScreenToDefault )
  {
    case 3:
      this->m_PrefsUseBass = 1;
      *(_DWORD *)&this->m_PrefsAutoRetune = 1077936385;
      this->m_PrefsAutoMediaScan = 0;
      this->m_PrefsPlayMode = 0;
      CAudioEngine::SetMusicMasterVolume(&AudioEngine, FrontEndMenuManager.m_PrefsMusicVolume);
      CAudioEngine::SetEffectsMasterVolume(&AudioEngine, FrontEndMenuManager.m_PrefsSfxVolume);
      CAudioEngine::SetBassEnhanceOnOff(&AudioEngine, FrontEndMenuManager.m_PrefsUseBass);
      sub_18FC78(&AudioEngine, FrontEndMenuManager.m_PrefsAutoRetune);
      break;
    case 4:
    case 27:
      Fx_c::SetFxQuality(&g_fx, FX_QUALITY_HIGH);
      this->m_PrefsLOD = 1.25;
      CRenderer::ms_lodDistScale = 1.25;
      this->m_PrefsShowLegend = 0;
      this->m_PrefsUseWideScreen = 0;
      m_PrefsResolution = this->m_PrefsResolution;
      this->m_PrefsFrameLimiter = 1;
      this->m_PrefsShowFPS = 0;
      this->m_PrefsDisplayHud = 1;
      this->m_PrefsSavePhotosToGallery = 1;
      this->m_PrefsMipMap = 1;
      this->m_PrefsAntiAliasing = 1;
      this->m_PrefsAntiAliasingDisp = 1;
      this->m_PrefsShowSubtitles = 1;
      this->m_PrefsMobileEffects = 2;
      this->m_PrefsResolutionDisp = m_PrefsResolution;
      break;
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
      return;
    case 37:
      this->m_ControlMethod = 2;
      CVehicle::m_bEnableMouseSteering = 0;
      MousePointerStateHelper.m_bUpAndDownInverted = 0;
      CVehicle::m_bEnableMouseFlying = 0;
      CCamera::m_fMouseAccelHorzntl = 0.0025;
      *(_WORD *)&this->m_PrefsJoyLeftAxisInvert = 0;
      *(_DWORD *)&this->m_PrefsJoyLeftXInvert = 0;
      break;
  }
}

//----- (0042E36C) --------------------------------------------------------
void __fastcall CMenuManager::~CMenuManager(CMenuManager *this)
{
  CMenuManager::UnloadTextures(this);
  CSprite2d::~CSprite2d(&this->FrontEndSprites[24]);
  CSprite2d::~CSprite2d(&this->FrontEndSprites[23]);
  CSprite2d::~CSprite2d(&this->FrontEndSprites[22]);
  CSprite2d::~CSprite2d(&this->FrontEndSprites[21]);
  CSprite2d::~CSprite2d(&this->FrontEndSprites[20]);
  CSprite2d::~CSprite2d(&this->FrontEndSprites[19]);
  CSprite2d::~CSprite2d(&this->FrontEndSprites[18]);
  CSprite2d::~CSprite2d(&this->FrontEndSprites[17]);
  CSprite2d::~CSprite2d(&this->FrontEndSprites[16]);
  CSprite2d::~CSprite2d(&this->FrontEndSprites[15]);
  CSprite2d::~CSprite2d(&this->FrontEndSprites[14]);
  CSprite2d::~CSprite2d(&this->FrontEndSprites[13]);
  CSprite2d::~CSprite2d(&this->FrontEndSprites[12]);
  CSprite2d::~CSprite2d(&this->FrontEndSprites[11]);
  CSprite2d::~CSprite2d(&this->FrontEndSprites[10]);
  CSprite2d::~CSprite2d(&this->FrontEndSprites[9]);
  CSprite2d::~CSprite2d(&this->FrontEndSprites[8]);
  CSprite2d::~CSprite2d(&this->FrontEndSprites[7]);
  CSprite2d::~CSprite2d(&this->FrontEndSprites[6]);
  CSprite2d::~CSprite2d(&this->FrontEndSprites[5]);
  CSprite2d::~CSprite2d(&this->FrontEndSprites[4]);
  CSprite2d::~CSprite2d(&this->FrontEndSprites[3]);
  CSprite2d::~CSprite2d(&this->FrontEndSprites[2]);
  CSprite2d::~CSprite2d(&this->FrontEndSprites[1]);
  CSprite2d::~CSprite2d(this->FrontEndSprites);
}

//----- (0042E444) --------------------------------------------------------
void __fastcall CMenuManager::UnloadTextures(CMenuManager *this)
{
  int32 TxdSlot; // r5
  int32 v3; // r5
  int32 v4; // r5

  if ( this->TexturesLoaded )
  {
    CMenuManager::SwapTexturesRound(this, 0);
    TxdSlot = CTxdStore::FindTxdSlot("frontend1");
    CSprite2d::Delete(this->FrontEndSprites);
    CSprite2d::Delete(&this->FrontEndSprites[1]);
    CSprite2d::Delete(&this->FrontEndSprites[2]);
    CSprite2d::Delete(&this->FrontEndSprites[3]);
    CSprite2d::Delete(&this->FrontEndSprites[4]);
    CSprite2d::Delete(&this->FrontEndSprites[5]);
    CSprite2d::Delete(&this->FrontEndSprites[6]);
    CSprite2d::Delete(&this->FrontEndSprites[7]);
    CSprite2d::Delete(&this->FrontEndSprites[8]);
    CSprite2d::Delete(&this->FrontEndSprites[9]);
    CSprite2d::Delete(&this->FrontEndSprites[10]);
    CSprite2d::Delete(&this->FrontEndSprites[11]);
    CSprite2d::Delete(&this->FrontEndSprites[12]);
    CTxdStore::RemoveTxd(TxdSlot);
    v3 = CTxdStore::FindTxdSlot("frontend_pc");
    CSprite2d::Delete(&this->FrontEndSprites[23]);
    CSprite2d::Delete(&this->FrontEndSprites[24]);
    CTxdStore::RemoveTxd(v3);
    v4 = CTxdStore::FindTxdSlot("frontend2");
    CSprite2d::Delete(&this->FrontEndSprites[13]);
    CSprite2d::Delete(&this->FrontEndSprites[14]);
    CSprite2d::Delete(&this->FrontEndSprites[15]);
    CSprite2d::Delete(&this->FrontEndSprites[16]);
    CSprite2d::Delete(&this->FrontEndSprites[17]);
    CSprite2d::Delete(&this->FrontEndSprites[18]);
    CSprite2d::Delete(&this->FrontEndSprites[19]);
    CSprite2d::Delete(&this->FrontEndSprites[20]);
    CTxdStore::RemoveTxd(v4);
    this->TexturesLoaded = 0;
  }
}

//----- (0042E560) --------------------------------------------------------
void __fastcall CMenuManager::Initialise(CMenuManager *this)
{
  int Width; // r5
  void *Height; // r0

  bSaveSettings = 0;
  Width = OS_ScreenGetWidth();
  Height = OS_ScreenGetHeight();
  emu_SetAltRenderTarget(Width, (GLsizei)Height);
  this->TimeToStopPadShaking = 0;
  this->CurrentOption = 0;
  gMobileMenu.SelectedSlot = 0;
  this->BriefDisplay = 3;
  CPad::StopPadsShaking();
  this->oldMousePosX = 0;
  this->oldMousePosY = 0;
  this->InOptionsMenu = 1;
  this->CurrentScreen = 43;
  this->DisplayTheMouse = 0;
  this->m_PrefsRadioStation = CAudioEngine::GetCurrentRadioStationID(&AudioEngine);
  CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
  C_PcSave::PopulateSlotInfo(&PcSaveHelper);
  sub_196814();
}
// 61CADE: using guessed type char byte_61CADE;

//----- (0042E5FC) --------------------------------------------------------
void __fastcall CMenuManager::LoadAllTextures(CMenuManager *this)
{
  int32 TxdSlot; // r5
  int v3; // r6
  CSprite2d *FrontEndSprites; // r9
  int32 v5; // r5
  int32 v6; // r5

  if ( !this->TexturesLoaded )
  {
    CTimer::Stop();
    CStreaming::MakeSpaceFor(135168);
    CStreaming::ImGonnaUseStreamingMemory();
    CGame::TidyUpMemory(0, 1);
    CTxdStore::PushCurrentTxd();
    TxdSlot = CTxdStore::FindTxdSlot("frontend1");
    if ( TxdSlot == -1 )
      TxdSlot = CTxdStore::AddTxdSlot("frontend1", (const unsigned __int8 *)&off_42E838, 0);
    CTxdStore::LoadTxd(TxdSlot, "MODELS\\FRONTEN1.TXD");
    CTxdStore::AddRef(TxdSlot);
    v3 = 0;
    CTxdStore::SetCurrentTxd(TxdSlot, 0);
    FrontEndSprites = this->FrontEndSprites;
    do
    {
      CSprite2d::SetTexture(
        &FrontEndSprites[v3],
        FrontEndFilenames[v3].pBitmapFileName,
        FrontEndFilenames[v3].pMaskFileName);
      CSprite2d::SetAddressing(&FrontEndSprites[v3++], rwTEXTUREADDRESSCLAMP);
    }
    while ( v3 != 13 );
    CTxdStore::PopCurrentTxd();
    CStreaming::IHaveUsedStreamingMemory();
    CStreaming::MakeSpaceFor(12288);
    CStreaming::ImGonnaUseStreamingMemory();
    CGame::TidyUpMemory(0, 1);
    CTxdStore::PushCurrentTxd();
    v5 = CTxdStore::FindTxdSlot("frontend_pc");
    if ( v5 == -1 )
      v5 = CTxdStore::AddTxdSlot("frontend_pc", (const unsigned __int8 *)&off_42E838, 0);
    CTxdStore::LoadTxd(v5, "MODELS/FRONTEN_pc.TXD");
    CTxdStore::AddRef(v5);
    CTxdStore::SetCurrentTxd(v5, 0);
    CSprite2d::SetTexture(
      &this->FrontEndSprites[23],
      FrontEndFilenames[23].pBitmapFileName,
      FrontEndFilenames[23].pMaskFileName);
    CSprite2d::SetAddressing(&this->FrontEndSprites[23], rwTEXTUREADDRESSCLAMP);
    CSprite2d::SetTexture(
      &this->FrontEndSprites[24],
      FrontEndFilenames[24].pBitmapFileName,
      FrontEndFilenames[24].pMaskFileName);
    CSprite2d::SetAddressing(&this->FrontEndSprites[24], rwTEXTUREADDRESSCLAMP);
    CTxdStore::PopCurrentTxd();
    CStreaming::IHaveUsedStreamingMemory();
    CStreaming::MakeSpaceFor(311296);
    CStreaming::ImGonnaUseStreamingMemory();
    CTxdStore::PushCurrentTxd();
    v6 = CTxdStore::FindTxdSlot("frontend2");
    if ( v6 == -1 )
      v6 = CTxdStore::AddTxdSlot("frontend2", (const unsigned __int8 *)&off_42E838, 0);
    CTxdStore::LoadTxd(v6, "MODELS\\FRONTEN2.TXD");
    CTxdStore::AddRef(v6);
    CTxdStore::SetCurrentTxd(v6, 0);
    CSprite2d::SetTexture(
      &this->FrontEndSprites[13],
      FrontEndFilenames[13].pBitmapFileName,
      FrontEndFilenames[13].pMaskFileName);
    CSprite2d::SetAddressing(&this->FrontEndSprites[13], rwTEXTUREADDRESSCLAMP);
    CSprite2d::SetTexture(
      &this->FrontEndSprites[14],
      FrontEndFilenames[14].pBitmapFileName,
      FrontEndFilenames[14].pMaskFileName);
    CSprite2d::SetAddressing(&this->FrontEndSprites[14], rwTEXTUREADDRESSCLAMP);
    CSprite2d::SetTexture(
      &this->FrontEndSprites[15],
      FrontEndFilenames[15].pBitmapFileName,
      FrontEndFilenames[15].pMaskFileName);
    CSprite2d::SetAddressing(&this->FrontEndSprites[15], rwTEXTUREADDRESSCLAMP);
    CSprite2d::SetTexture(
      &this->FrontEndSprites[16],
      FrontEndFilenames[16].pBitmapFileName,
      FrontEndFilenames[16].pMaskFileName);
    CSprite2d::SetAddressing(&this->FrontEndSprites[16], rwTEXTUREADDRESSCLAMP);
    CSprite2d::SetTexture(
      &this->FrontEndSprites[17],
      FrontEndFilenames[17].pBitmapFileName,
      FrontEndFilenames[17].pMaskFileName);
    CSprite2d::SetAddressing(&this->FrontEndSprites[17], rwTEXTUREADDRESSCLAMP);
    CSprite2d::SetTexture(
      &this->FrontEndSprites[18],
      FrontEndFilenames[18].pBitmapFileName,
      FrontEndFilenames[18].pMaskFileName);
    CSprite2d::SetAddressing(&this->FrontEndSprites[18], rwTEXTUREADDRESSCLAMP);
    CSprite2d::SetTexture(
      &this->FrontEndSprites[19],
      FrontEndFilenames[19].pBitmapFileName,
      FrontEndFilenames[19].pMaskFileName);
    CSprite2d::SetAddressing(&this->FrontEndSprites[19], rwTEXTUREADDRESSCLAMP);
    CSprite2d::SetTexture(
      &this->FrontEndSprites[20],
      FrontEndFilenames[20].pBitmapFileName,
      FrontEndFilenames[20].pMaskFileName);
    CSprite2d::SetAddressing(&this->FrontEndSprites[20], rwTEXTUREADDRESSCLAMP);
    CTxdStore::PopCurrentTxd();
    CStreaming::IHaveUsedStreamingMemory();
    this->TexturesLoaded = 1;
    sub_1928E0();
  }
}
// 42E838: using guessed type void *off_42E838;

//----- (0042E898) --------------------------------------------------------
void __fastcall CMenuManager::SwapTexturesRound(CMenuManager *this, bool8 loadMap)
{
  int32 TxdSlot; // r5
  int32 v4; // r5
  unsigned __int8 *pBitmapFileName; // r1
  unsigned __int8 *pMaskFileName; // r2
  CSprite2d *v7; // r4
  int32 v8; // r5
  int32 v9; // r5

  if ( CMenuManager::SwapTexturesRound(unsigned char)::TexturesSwapped != loadMap )
  {
    CMenuManager::SwapTexturesRound(unsigned char)::TexturesSwapped = loadMap;
    if ( loadMap || !CTxdStore::FindTxdSlot("frontend3") )
    {
      TxdSlot = CTxdStore::FindTxdSlot("frontend2");
      CSprite2d::Delete(&this->FrontEndSprites[13]);
      CSprite2d::Delete(&this->FrontEndSprites[14]);
      CSprite2d::Delete(&this->FrontEndSprites[15]);
      CSprite2d::Delete(&this->FrontEndSprites[16]);
      CSprite2d::Delete(&this->FrontEndSprites[17]);
      CSprite2d::Delete(&this->FrontEndSprites[18]);
      CSprite2d::Delete(&this->FrontEndSprites[19]);
      CSprite2d::Delete(&this->FrontEndSprites[20]);
      CTxdStore::RemoveTxd(TxdSlot);
      CStreaming::MakeSpaceFor(26624);
      CStreaming::ImGonnaUseStreamingMemory();
      CTxdStore::PushCurrentTxd();
      v4 = CTxdStore::FindTxdSlot("frontend3");
      if ( v4 == -1 )
        v4 = CTxdStore::AddTxdSlot("frontend3", (const unsigned __int8 *)&off_42EABC, 0);
      CTxdStore::LoadTxd(v4, "MODELS/FRONTEN3.TXD");
      CTxdStore::AddRef(v4);
      CTxdStore::SetCurrentTxd(v4, 0);
      CSprite2d::SetTexture(
        &this->FrontEndSprites[21],
        FrontEndFilenames[21].pBitmapFileName,
        FrontEndFilenames[21].pMaskFileName);
      CSprite2d::SetAddressing(&this->FrontEndSprites[21], rwTEXTUREADDRESSCLAMP);
      pMaskFileName = FrontEndFilenames[22].pMaskFileName;
      pBitmapFileName = FrontEndFilenames[22].pBitmapFileName;
      v7 = &this->FrontEndSprites[22];
    }
    else
    {
      v8 = CTxdStore::FindTxdSlot("frontend3");
      CSprite2d::Delete(&this->FrontEndSprites[21]);
      CSprite2d::Delete(&this->FrontEndSprites[22]);
      CTxdStore::RemoveTxd(v8);
      CStreaming::MakeSpaceFor(311296);
      CStreaming::ImGonnaUseStreamingMemory();
      CTxdStore::PushCurrentTxd();
      v9 = CTxdStore::FindTxdSlot("frontend2");
      if ( v9 == -1 )
        v9 = CTxdStore::AddTxdSlot("frontend2", (const unsigned __int8 *)&off_42EABC, 0);
      CTxdStore::LoadTxd(v9, "MODELS/FRONTEN2.TXD");
      CTxdStore::AddRef(v9);
      CTxdStore::SetCurrentTxd(v9, 0);
      CSprite2d::SetTexture(
        &this->FrontEndSprites[13],
        FrontEndFilenames[13].pBitmapFileName,
        FrontEndFilenames[13].pMaskFileName);
      CSprite2d::SetAddressing(&this->FrontEndSprites[13], rwTEXTUREADDRESSCLAMP);
      CSprite2d::SetTexture(
        &this->FrontEndSprites[14],
        FrontEndFilenames[14].pBitmapFileName,
        FrontEndFilenames[14].pMaskFileName);
      CSprite2d::SetAddressing(&this->FrontEndSprites[14], rwTEXTUREADDRESSCLAMP);
      CSprite2d::SetTexture(
        &this->FrontEndSprites[15],
        FrontEndFilenames[15].pBitmapFileName,
        FrontEndFilenames[15].pMaskFileName);
      CSprite2d::SetAddressing(&this->FrontEndSprites[15], rwTEXTUREADDRESSCLAMP);
      CSprite2d::SetTexture(
        &this->FrontEndSprites[16],
        FrontEndFilenames[16].pBitmapFileName,
        FrontEndFilenames[16].pMaskFileName);
      CSprite2d::SetAddressing(&this->FrontEndSprites[16], rwTEXTUREADDRESSCLAMP);
      CSprite2d::SetTexture(
        &this->FrontEndSprites[17],
        FrontEndFilenames[17].pBitmapFileName,
        FrontEndFilenames[17].pMaskFileName);
      CSprite2d::SetAddressing(&this->FrontEndSprites[17], rwTEXTUREADDRESSCLAMP);
      CSprite2d::SetTexture(
        &this->FrontEndSprites[18],
        FrontEndFilenames[18].pBitmapFileName,
        FrontEndFilenames[18].pMaskFileName);
      CSprite2d::SetAddressing(&this->FrontEndSprites[18], rwTEXTUREADDRESSCLAMP);
      CSprite2d::SetTexture(
        &this->FrontEndSprites[19],
        FrontEndFilenames[19].pBitmapFileName,
        FrontEndFilenames[19].pMaskFileName);
      CSprite2d::SetAddressing(&this->FrontEndSprites[19], rwTEXTUREADDRESSCLAMP);
      pMaskFileName = FrontEndFilenames[20].pMaskFileName;
      pBitmapFileName = FrontEndFilenames[20].pBitmapFileName;
      v7 = &this->FrontEndSprites[20];
    }
    CSprite2d::SetTexture(v7, pBitmapFileName, pMaskFileName);
    CSprite2d::SetAddressing(v7, rwTEXTUREADDRESSCLAMP);
    CTxdStore::PopCurrentTxd();
    sub_19AFA0();
  }
}
// 42EABC: using guessed type void *off_42EABC;

//----- (0042EAF4) --------------------------------------------------------
void __fastcall CMenuManager::InitialiseChangedLanguageSettings(CMenuManager *this, bool ReInitControls)
{
  _BOOL4 v3; // r4
  unsigned __int8 pStringToFill[8]; // [sp+4h] [bp-14h] BYREF

  v3 = ReInitControls;
  if ( this->bFrontEnd_ReloadObrTxtGxt )
  {
    this->bFrontEnd_ReloadObrTxtGxt = 0;
    CTimer::Stop();
    CText::GetNameOfLoadedMissionText(&TheText, pStringToFill);
    CText::Load(&TheText, CGame::bMissionPackGame != 0);
    if ( pStringToFill[0] )
      CText::LoadMissionText(&TheText, pStringToFill);
    CTimer::Update();
    if ( (unsigned int)(this->m_SystemLanguage - 1) >= 2 )
    {
      switch ( this->m_PrefsLanguage )
      {
        case 0:
        case 2:
        case 3:
        case 4:
          CLocalisation::SetNormalGame();
          break;
        case 1:
          CLocalisation::SetFrenchGame();
          break;
        case 5:
          CFont::AddRussianTexture();
          break;
        case 6:
          CFont::AddJapaneseTexture();
          break;
        default:
          break;
      }
    }
    if ( (unsigned __int8)(this->m_PrefsLanguage - 5) >= 3u )
      CFont::AddEFIGSFont();
    if ( this->m_SystemLanguage == LANGUAGE_FRENCH )
      CLocalisation::SetFrenchGame();
    if ( v3 )
      CControllerConfigManager::ReinitControls(&ControlsManager);
  }
}

//----- (0042EBEC) --------------------------------------------------------
void __fastcall CMenuManager::DrawFrontEnd(CMenuManager *this)
{
  int CurrentScreen; // r0

  if ( emu_IsAltRenderTarget() )
    emu_FlushAltRenderTarget();
  SCCloudSaveStateUpdate();
  CFont::SetAlphaFade(255.0);
  CSprite2d::InitPerFrame();
  CFont::InitPerFrame();
  DefinedState2d();
  this->MenuIsAbleToQuit = 1;
  if ( CAudioEngine::IsRadioRetuneInProgress(&AudioEngine) )
    this->MenuIsAbleToQuit = 0;
  CurrentScreen = (unsigned __int8)this->CurrentScreen;
  if ( CurrentScreen == 43 )
  {
    LOBYTE(CurrentScreen) = 42;
    if ( this->m_MainMenu )
      LOBYTE(CurrentScreen) = 34;
    this->CurrentScreen = CurrentScreen;
  }
  if ( !this->CurrentOption && aScreens[226 * (char)CurrentScreen + 10] == 1 )
    this->CurrentOption = 1;
  CMenuManager::DrawBackground(this);
}

//----- (0042EC7C) --------------------------------------------------------
void __fastcall CMenuManager::DrawBackground(CMenuManager *this)
{
  int CurrentScreen; // r0
  float v3; // s0
  CRGBA v4; // r0
  float v5; // s2
  float v6; // s4
  int8 *p_DisplayWarningScreenForUnboundControls; // r5
  char v8; // r0
  int v9; // r0
  char *v10; // r1
  char v11; // r0
  int v12; // r3
  int v13; // r2
  int v14; // r0
  char v15; // r1
  char *v16; // r0
  CPad *Pad; // r0
  float v18; // s0
  float v19; // s2
  float v20; // s8
  float v21; // s4
  float v22; // s0
  float v23; // s6
  float v24; // s2
  float v25; // s4
  CRGBA v26; // [sp+8h] [bp-238h] BYREF
  CRect Rectangle; // [sp+Ch] [bp-234h] BYREF
  CRGBA v28; // [sp+20Ch] [bp-34h] BYREF

  if ( !this->TexturesLoaded )
    return;
  Rectangle.left = -5.0;
  Rectangle.bottom = -5.0;
  Rectangle.right = (float)(RsGlobal.screenWidth + 5);
  Rectangle.top = (float)(RsGlobal.screenHeight + 5);
  CRGBA::CRGBA(&v28, 0, 0, 0, 0xFFu);
  CSprite2d::DrawRect(&Rectangle, &v28);
  CurrentScreen = (unsigned __int8)this->CurrentScreen;
  if ( CurrentScreen == 34 )
  {
    AsciiToGxtChar((const Char *)"v1.01", (GxtChar *)&Rectangle);
    v3 = (float)RsGlobal.screenHeight * 0.0011161;
    if ( RsGlobal.screenHeight == 448 )
      v3 = 0.5;
    CFont::SetScale(v3);
    CRGBA::CRGBA(&v26, 0xFFu, 0xFFu, 0xFFu, 0x64u);
    CFont::SetColor(v4);
    v5 = (float)RsGlobal.screenHeight * 0.022321;
    if ( RsGlobal.screenHeight == 448 )
      v5 = 10.0;
    v6 = (float)RsGlobal.screenWidth * 0.92188;
    if ( RsGlobal.screenWidth == 640 )
      v6 = 590.0;
    CFont::PrintStringFromBottom(v6, (float)RsGlobal.screenHeight - v5, (GxtChar *)&Rectangle);
    CurrentScreen = (unsigned __int8)this->CurrentScreen;
  }
  if ( CurrentScreen == 44 )
  {
    CMenuManager::DrawQuitGameScreen(this);
  }
  else if ( (char)CurrentScreen == 39 )
  {
    CMenuManager::DrawControllerSetupScreen(this);
  }
  else
  {
    CMenuManager::DrawStandardMenus(this, 1u);
  }
  if ( this->DisplayWarningScreenForUnboundControls )
  {
    p_DisplayWarningScreenForUnboundControls = &this->DisplayWarningScreenForUnboundControls;
    v8 = `guard variable for'CMenuManager::DrawBackground(void)::LastFrame;
    __dmb(0xBu);
    if ( (v8 & 1) == 0
      && _cxa_guard_acquire((__guard *)&`guard variable for'CMenuManager::DrawBackground(void)::LastFrame) )
    {
      CMenuManager::DrawBackground(void)::LastFrame = CTimer::m_snTimeInMillisecondsPauseMode;
      _cxa_guard_release((__guard *)&`guard variable for'CMenuManager::DrawBackground(void)::LastFrame);
    }
    if ( CMenuManager::DrawBackground(void)::GetNewTime == 1 )
    {
      CMenuManager::DrawBackground(void)::GetNewTime = 0;
      CMenuManager::DrawBackground(void)::LastFrame = CTimer::m_snTimeInMillisecondsPauseMode;
    }
    v9 = *p_DisplayWarningScreenForUnboundControls;
    if ( v9 == 2 )
    {
      v10 = "FEC_ER2";
    }
    else if ( v9 == 1 )
    {
      v10 = "FEC_ER3";
    }
    else
    {
      v10 = "FEC_ERI";
    }
    CMenuManager::MessageScreen(this, (unsigned __int8 *)v10, 0, 0);
    CFont::RenderFontBuffer();
    if ( CTimer::m_snTimeInMillisecondsPauseMode - CMenuManager::DrawBackground(void)::LastFrame <= 0x1B58 )
    {
      Pad = CPad::GetPad(0);
      if ( !CPad::GetEscapeJustDown(Pad)
        || CTimer::m_snTimeInMillisecondsPauseMode - CMenuManager::DrawBackground(void)::LastFrame <= 0x3E8 )
      {
        return;
      }
    }
    *p_DisplayWarningScreenForUnboundControls = 0;
    v16 = &CMenuManager::DrawBackground(void)::GetNewTime;
LABEL_61:
    *v16 = 1;
    return;
  }
  if ( !this->DisplayWarningScreenForUserTrackScanning )
    return;
  v11 = `guard variable for'CMenuManager::DrawBackground(void)::LastFrame;
  __dmb(0xBu);
  if ( (v11 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'CMenuManager::DrawBackground(void)::LastFrame) )
  {
    _cxa_guard_release((__guard *)&`guard variable for'CMenuManager::DrawBackground(void)::LastFrame);
  }
  CMenuManager::MessageScreen(this, "FEA_SMP", 0, 0);
  if ( (CTimer::m_FrameCounter & 4) != 0 )
  {
    v12 = -1;
    v13 = CMenuManager::DrawBackground(void)::anim_x;
    if ( CMenuManager::DrawBackground(void)::dir )
      v12 = 1;
    v14 = CMenuManager::DrawBackground(void)::anim_x - v12;
    CMenuManager::DrawBackground(void)::anim_x -= v12;
    if ( v13 - v12 < 370 )
    {
      if ( v14 > 270 )
        goto LABEL_43;
      v15 = 0;
    }
    else
    {
      v15 = 1;
    }
    CMenuManager::DrawBackground(void)::dir = v15;
  }
LABEL_43:
  v18 = (float)RsGlobal.screenWidth * 0.42188;
  v19 = (float)RsGlobal.screenWidth * 0.58594;
  v20 = (float)RsGlobal.screenHeight * 0.54688;
  if ( RsGlobal.screenWidth == 640 )
    v18 = 270.0;
  if ( RsGlobal.screenHeight == 448 )
    v20 = 245.0;
  v21 = (float)RsGlobal.screenHeight * 0.55804;
  if ( RsGlobal.screenWidth == 640 )
    v19 = 375.0;
  if ( RsGlobal.screenHeight == 448 )
    v21 = 250.0;
  Rectangle.left = v18;
  Rectangle.bottom = v20;
  Rectangle.right = v19;
  Rectangle.top = v21;
  CRGBA::CRGBA(&v28, 0x32u, 0x32u, 0x32u, 0xFFu);
  CSprite2d::DrawRect(&Rectangle, &v28);
  v22 = (float)CMenuManager::DrawBackground(void)::anim_x;
  if ( RsGlobal.screenWidth != 640 )
    v22 = (float)(v22 / 640.0) * (float)RsGlobal.screenWidth;
  v23 = (float)(CMenuManager::DrawBackground(void)::anim_x + 5);
  v24 = (float)RsGlobal.screenHeight * 0.54688;
  if ( RsGlobal.screenHeight == 448 )
    v24 = 245.0;
  if ( RsGlobal.screenWidth != 640 )
    v23 = (float)(v23 / 640.0) * (float)RsGlobal.screenWidth;
  v25 = (float)RsGlobal.screenHeight * 0.55804;
  if ( RsGlobal.screenHeight == 448 )
    v25 = 250.0;
  Rectangle.bottom = v24;
  Rectangle.left = v22;
  Rectangle.right = v23;
  Rectangle.top = v25;
  CRGBA::CRGBA(&v28, 0xE1u, 0xE1u, 0xE1u, 0xFFu);
  CSprite2d::DrawRect(&Rectangle, &v28);
  CFont::RenderFontBuffer();
  CMenuManager::ResetHelperText(this);
  if ( !CMenuManager::DrawBackground(void)::GetNewTime )
  {
    v16 = &CMenuManager::DrawBackground(void)::GetNewTime;
    goto LABEL_61;
  }
}
// 42ED34: variable 'v4' is possibly undefined
// 990BE4: using guessed type char `guard variable for'CMenuManager::DrawBackground(void)::LastFrame;
// 990BE8: using guessed type char CMenuManager::DrawBackground(void)::GetNewTime;
// 990BEC: using guessed type char `guard variable for'CMenuManager::DrawBackground(void)::LastFrame;
// 990BF0: using guessed type char CMenuManager::DrawBackground(void)::GetNewTime;
// 990BF4: using guessed type char CMenuManager::DrawBackground(void)::dir;

//----- (0042F12C) --------------------------------------------------------
float __fastcall CMenuManager::StretchX(CMenuManager *this, float x)
{
  float v2; // s0

  v2 = x;
  if ( RsGlobal.screenWidth != 640 )
    return (float)(x / 640.0) * (float)RsGlobal.screenWidth;
  return v2;
}

//----- (0042F160) --------------------------------------------------------
float __fastcall CMenuManager::StretchY(CMenuManager *this, float y)
{
  float v2; // s0

  v2 = y;
  if ( RsGlobal.screenHeight != 448 )
    return (float)(y / 448.0) * (float)RsGlobal.screenHeight;
  return v2;
}

//----- (0042F198) --------------------------------------------------------
void __fastcall CMenuManager::DrawStandardMenus(CMenuManager *this, bool8 DrawingCurrentScreen)
{
  int v2; // r5
  float v4; // s0
  __int64 v5; // kr00_8
  GxtChar *v6; // r2
  float v7; // s0
  float v8; // s2
  char *CurrentScreen; // r0
  float v10; // s0
  CRGBA v11; // r0
  CRGBA v12; // r0
  char *v13; // r1
  const char *v14; // r3
  int32 v15; // r0
  GxtChar *v16; // r2
  float v17; // s0
  float v18; // s2
  int v19; // r11
  int m_EditingControlOptions; // r5
  float v21; // s27
  float v22; // s16
  unsigned __int8 *v23; // r10
  int v24; // r4
  GxtChar *v25; // r6
  const char *v26; // r1
  char v27; // r5
  float v28; // s0
  CRGBA v29; // r0
  float v30; // s0
  CRGBA v31; // r0
  int v32; // r0
  bool v33; // zf
  CRGBA v34; // r0
  int v35; // r0
  uint8 v36; // r0
  bool v37; // zf
  __int16 v38; // r1
  __int16 v39; // r2
  char *v40; // r1
  int v41; // r0
  int v42; // r9
  int v43; // r10
  int32 v44; // r0
  GxtChar *NameOfSavedGame; // r0
  GxtChar *v46; // r4
  GxtChar *SavedGameDateAndTime; // r5
  GxtChar *v48; // r0
  int v49; // r4
  GxtChar *v50; // r5
  bool v51; // zf
  int v52; // r5
  int m_ControlMethod; // r0
  char *v54; // r1
  CRGBA v55; // r0
  int v56; // r1
  CRGBA *v57; // r0
  GxtChar *v58; // r10
  int v59; // r0
  int v60; // r9
  GxtChar *v61; // r0
  char *v62; // r0
  int v63; // r0
  CRGBA v64; // r0
  int m_PrefsPlayMode; // r0
  const char *v66; // r1
  Char *v67; // r5
  RwInt32 m_PrefsAntiAliasingDisp; // r0
  const Char *v69; // r4
  Char *v70; // r1
  GxtChar *v71; // r0
  float v72; // s0
  float v73; // s2
  float screenHeight; // s0
  float v75; // s0
  float v76; // s4
  float v77; // s2
  int v78; // r0
  bool v79; // zf
  int v80; // r1
  int v81; // r0
  float v82; // s0
  float v83; // s0
  int v84; // r0
  float v85; // s0
  float v86; // s2
  float v87; // s27
  unsigned int v88; // r0
  float v89; // s4
  float v90; // s6
  float v91; // s2
  float v92; // s0
  RwInt32 m_PrefsAntiAliasing; // r5
  RwInt32 v94; // r6
  Int8 v95; // r6
  bool v96; // zf
  __int64 v97; // kr18_8
  Int8 v98; // r6
  bool v99; // zf
  GxtChar *v100; // r5
  float v101; // s6
  float v102; // s8
  float screenWidth; // s0
  float v104; // s4
  float v105; // s2
  float v106; // r3
  float v107; // s6
  float v108; // s0
  int seg_size; // r6
  int v110; // r0
  float v111; // s0
  float v112; // s27
  Int32 v113; // r2
  Int32 v114; // r3
  float v115; // s0
  float v116; // s6
  float v117; // s8
  float v118; // s0
  float v119; // s4
  float v120; // s2
  float v121; // r3
  float v122; // s6
  float v123; // s0
  int v124; // r6
  int v125; // r0
  float v126; // s0
  float v127; // s27
  Int32 v128; // r2
  Int32 v129; // r3
  float v130; // s0
  float v131; // s6
  float v132; // s8
  float v133; // s0
  float v134; // s4
  float v135; // s2
  float v136; // r1
  float v137; // s4
  float v138; // s0
  int v139; // r6
  int v140; // r0
  float v141; // s0
  float v142; // s27
  Int32 v143; // r2
  Int32 v144; // r3
  float v145; // s0
  float v146; // s6
  float v147; // s8
  float v148; // s0
  float v149; // s4
  float v150; // s2
  float v151; // r1
  float v152; // s4
  float v153; // s0
  CMenuManager *v154; // r0
  int v155; // r0
  float v156; // s0
  float v157; // s27
  Int32 v158; // r2
  Int32 v159; // r3
  float v160; // s0
  Int32 *v161; // r0
  int v162; // r1
  float v163; // s2
  float v164; // s0
  float v165; // s2
  float v166; // s0
  float v167; // s2
  float v168; // s0
  float v169; // s2
  float v170; // s0
  Int32 v171; // r1
  Int32 v172; // r3
  float v173; // s0
  Int32 v174; // r1
  Int32 v175; // r3
  float v176; // s0
  Int32 v177; // r1
  Int32 v178; // r3
  float v179; // s0
  Int32 v180; // r1
  Int32 v181; // r3
  float v182; // s0
  float v183; // s0
  float v184; // s4
  float MousePosY; // s0
  bool v186; // zf
  float v187; // s2
  int v188; // s4
  float v189; // s0
  float v190; // s0
  float v191; // s4
  float v192; // s0
  int *p_CurrentHelperMessage; // [sp+E8h] [bp-1C8h]
  Int32 *p_MouseInBounds; // [sp+ECh] [bp-1C4h]
  _BOOL4 v195; // [sp+130h] [bp-180h]
  GxtChar *v196; // [sp+134h] [bp-17Ch]
  int v197; // [sp+134h] [bp-17Ch]
  int v198; // [sp+164h] [bp-14Ch]
  unsigned __int8 *v199; // [sp+168h] [bp-148h]
  int v200; // [sp+16Ch] [bp-144h]
  CRGBA v201; // [sp+180h] [bp-130h] BYREF
  CRect Rectangle; // [sp+184h] [bp-12Ch] BYREF
  CRGBA v203; // [sp+194h] [bp-11Ch] BYREF
  CRGBA v204; // [sp+198h] [bp-118h] BYREF
  CRGBA v205; // [sp+19Ch] [bp-114h] BYREF
  CRGBA v206; // [sp+1A0h] [bp-110h] BYREF
  CRGBA v207; // [sp+1A4h] [bp-10Ch] BYREF
  CRGBA v208; // [sp+1A8h] [bp-108h] BYREF
  CRGBA v209; // [sp+1ACh] [bp-104h] BYREF
  CRGBA v210; // [sp+1B0h] [bp-100h] BYREF
  CRGBA v211; // [sp+1B4h] [bp-FCh] BYREF
  CRGBA v212; // [sp+1B8h] [bp-F8h] BYREF
  CRGBA v213; // [sp+1BCh] [bp-F4h] BYREF
  CRGBA v214; // [sp+1C0h] [bp-F0h] BYREF
  CRGBA v215; // [sp+1C4h] [bp-ECh] BYREF
  CRGBA v216; // [sp+1C8h] [bp-E8h] BYREF
  CRGBA v217; // [sp+1CCh] [bp-E4h] BYREF
  GxtChar v218[112]; // [sp+1D0h] [bp-E0h] BYREF

  v2 = DrawingCurrentScreen;
  CFont::SetBackground(0, 0);
  CFont::SetProportional(1u);
  CFont::SetOrientation(1u);
  CFont::SetWrapx((float)(RsGlobal.screenWidth - 10));
  CFont::SetRightJustifyWrap(10.0);
  CFont::SetCentreSize((float)RsGlobal.screenWidth);
  if ( v2 && aScreens[226 * this->CurrentScreen] && (this->CurrentScreen != 5 || !this->InOptionsMenu) )
  {
    CFont::SetOrientation(1u);
    CFont::SetFontStyle(0);
    v4 = (float)RsGlobal.screenHeight * 0.0046875;
    if ( RsGlobal.screenHeight == 448 )
      v4 = 2.1;
    CFont::SetScale(v4);
    CFont::SetEdge(1);
    CHudColours::GetRGBA(&v217, &HudColour, 3u);
    CFont::SetColor((CRGBA)&v217);
    CHudColours::GetRGBA(&v216, &HudColour, 6u);
    CFont::SetDropColor((CRGBA)&v216);
    v5 = *(_QWORD *)&RsGlobal.screenWidth;
    v6 = CText::Get(&TheText, (const unsigned __int8 *)&aScreens[226 * this->CurrentScreen]);
    v7 = (float)(int)v5 * 0.0625;
    v8 = (float)SHIDWORD(v5) * 0.0625;
    if ( (_DWORD)v5 == 640 )
      v7 = 40.0;
    if ( HIDWORD(v5) == 448 )
      v8 = 28.0;
    CFont::PrintString(v7, v8, v6);
  }
  LOBYTE(CurrentScreen) = this->CurrentScreen;
  if ( aScreens[226 * (char)CurrentScreen + 10] == 1 )
  {
    CFont::SetWrapx((float)(RsGlobal.screenWidth - 40));
    CFont::SetFontStyle(1u);
    v10 = (float)RsGlobal.screenHeight * 0.0026786;
    if ( RsGlobal.screenHeight == 448 )
      v10 = 1.2;
    CFont::SetScale(v10);
    CFont::SetOrientation(1u);
    CFont::SetEdge(2);
    CRGBA::CRGBA(&v215, 0, 0, 0, 0xFFu);
    CFont::SetDropColor(v11);
    CRGBA::CRGBA(&v214, 0x4Au, 0x5Au, 0x6Bu, 0xFFu);
    CFont::SetColor(v12);
    v13 = (char *)&unk_6ABF23;
    switch ( this->CurrentScreen )
    {
      case 6:
        v13 = "FESZ_QQ";
        if ( !this->m_MainMenu )
          v13 = (char *)&unk_6AB9D7;
        break;
      case 0xB:
        v13 = "FES_LCG";
        if ( !this->m_MainMenu )
          v13 = (char *)&unk_6ABE41;
        break;
      case 0xC:
        break;
      case 0x11:
        v14 = "FESZ_QC";
        v15 = CGenericGameStorage::ms_Slots[gMobileMenu.SelectedSlot];
        v13 = "FESZ_QO";
        if ( v15 != 2 )
          v14 = (const char *)&unk_6AC38D;
        if ( v15 )
          v13 = (char *)v14;
        break;
      case 0x23:
        v13 = "FEQ_SRW";
        if ( !this->m_MainMenu )
          v13 = (char *)&unk_6AD371;
        break;
      default:
        v13 = &aScreens[226 * this->CurrentScreen + 11];
        break;
    }
    v16 = CText::Get(&TheText, (const unsigned __int8 *)v13);
    v17 = (float)RsGlobal.screenWidth * 0.09375;
    v18 = (float)RsGlobal.screenHeight * 0.21652;
    if ( RsGlobal.screenWidth == 640 )
      v17 = 60.0;
    if ( RsGlobal.screenHeight == 448 )
      v18 = 97.0;
    CFont::PrintString(v17, v18, v16);
    CFont::SetWrapx((float)(RsGlobal.screenWidth - 10));
    CFont::SetRightJustifyWrap(10.0);
    CurrentScreen = (char *)(unsigned __int8)this->CurrentScreen;
  }
  else
  {
    CurrentScreen = (char *)(unsigned __int8)CurrentScreen;
  }
  v19 = 0;
  v195 = 0;
  if ( CurrentScreen == (_BYTE *)&dword_24 + 3 )
  {
    m_EditingControlOptions = this->m_EditingControlOptions;
    CMenuManager::DrawContollerScreenExtraText(this, -8);
    LOBYTE(CurrentScreen) = this->CurrentScreen;
    v195 = m_EditingControlOptions != 0;
  }
  v21 = 0.78125;
  v22 = 0.0;
  v23 = &this[-1].MissionPack[24].name[97];
  p_MouseInBounds = &this->MouseInBounds;
  p_CurrentHelperMessage = &this->CurrentHelperMessage;
  v24 = 0;
  v198 = (unsigned __int8)aScreens[226 * (char)CurrentScreen + 10] ^ 1;
  v25 = (GxtChar *)aScreens;
  do
  {
    v27 = aScreens[226 * (char)CurrentScreen + 19 + v19];
    CFont::SetFontStyle(2u);
    if ( (unsigned __int8)(v27 - 1) > 9u )
    {
      v30 = (float)RsGlobal.screenHeight * 0.0022321;
      if ( RsGlobal.screenHeight == 448 )
        v30 = 1.0;
      CFont::SetScale(v30);
      CFont::SetEdge(2);
      CRGBA::CRGBA(&v212, 0, 0, 0, 0xFFu);
    }
    else
    {
      CFont::SetEdge(1);
      v28 = (float)RsGlobal.screenHeight * 0.0021205;
      if ( RsGlobal.screenHeight == 448 )
        v28 = 0.95;
      CFont::SetScale(v28);
      CRGBA::CRGBA(&v213, 0, 0, 0, 0xFFu);
    }
    CFont::SetDropColor(v29);
    if ( v24 == this->CurrentOption && this->InOptionsMenu )
      CRGBA::CRGBA(&v211, 0xACu, 0xCBu, 0xF1u, 0xFFu);
    else
      CRGBA::CRGBA(&v210, 0x4Au, 0x5Au, 0x6Bu, 0xFFu);
    CFont::SetColor(v31);
    if ( this->CurrentScreen == 42 && !IsPlayingGame() )
    {
      v32 = (unsigned __int8)aScreens[226 * this->CurrentScreen + 20 + v19];
      v33 = v32 == 16;
      if ( v32 != 16 )
        v33 = v32 == 5;
      if ( v33 )
      {
        CRGBA::CRGBA(&v209, 0x32u, 0x32u, 0x32u, 0xFFu);
        CFont::SetColor(v34);
      }
    }
    v35 = aScreens[226 * this->CurrentScreen + 26 + v19];
    if ( v35 == 2 )
      v36 = 2;
    else
      v36 = v35 == 1;
    CFont::SetOrientation(v36);
    CurrentScreen = &aScreens[226 * this->CurrentScreen + v19];
    if ( (*((_WORD *)CurrentScreen + 11) || *(_WORD *)&aScreens[226 * this->CurrentScreen + 24 + v19])
      && aScreens[226 * this->CurrentScreen + 19 + v19] != 12 )
    {
      LOBYTE(CurrentScreen) = this->CurrentScreen;
    }
    else
    {
      v37 = v19 == 0;
      if ( v19 )
        v37 = (v19 ^ 0x12 | v198) == 0;
      if ( v37 )
      {
        *((_WORD *)CurrentScreen + 11) = 320;
        v38 = 130;
        LOWORD(CurrentScreen) = this->CurrentScreen;
      }
      else
      {
        *((_WORD *)CurrentScreen + 11) = *(_WORD *)&aScreens[226 * this->CurrentScreen + 4 + v19];
        LOWORD(CurrentScreen) = this->CurrentScreen;
        v38 = *(_WORD *)&aScreens[226 * this->CurrentScreen + 6 + v19] + 30;
      }
      *(_WORD *)&aScreens[226 * (__int16)CurrentScreen + 24 + v19] = v38;
      LOBYTE(CurrentScreen) = this->CurrentScreen;
    }
    v39 = (char)CurrentScreen;
    v40 = &aScreens[226 * (char)CurrentScreen + v19];
    if ( v40[10] == 1 || !aScreens[226 * (char)CurrentScreen + 11 + v19] )
      goto LABEL_408;
    v41 = (unsigned __int8)aScreens[226 * (char)CurrentScreen + 19 + v19];
    v199 = v23;
    v200 = v24;
    if ( (unsigned __int8)(v41 - 1) <= 9u )
    {
      *(_WORD *)&aScreens[226 * v39 + 22 + v19] = 80;
      CFont::SetOrientation(1u);
      v42 = v24 - 2;
      if ( v19 == 18 )
        v42 = 8;
      v43 = v42 | 1;
      if ( (v42 | 1) == 7 && IsSCCloudAvailable() && NewSCCloudSaveAvailable(v42 - 6) )
        C_PcSave::PopulateSlotInfo(&PcSaveHelper);
      v44 = CGenericGameStorage::ms_Slots[v42];
      if ( v44 == 2 )
      {
        v48 = CText::Get(&TheText, "FESZ_CS");
        SavedGameDateAndTime = 0;
      }
      else
      {
        if ( v44 )
        {
          SavedGameDateAndTime = 0;
          goto LABEL_103;
        }
        if ( this->CurrentScreen != 16
          || IsSCCloudAvailable()
          || (NameOfSavedGame = CMenuManager::DrawStandardMenus(unsigned char)::pEmpty, v43 != 7) )
        {
          NameOfSavedGame = CGenericGameStorage::GetNameOfSavedGame(v42);
        }
        v46 = NameOfSavedGame;
        if ( GxtCharStrlen(NameOfSavedGame) >= 0xFE )
        {
          v25 = gGxtString2;
          AsciiToGxtChar((const Char *)&loc_430228, gGxtString2);
          GxtCharStrcat(v46, gGxtString2);
        }
        SavedGameDateAndTime = GetSavedGameDateAndTime(v42);
        v48 = v46;
        v24 = v200;
      }
      v51 = v48 == 0;
      if ( v48 )
      {
        v25 = v48;
        v51 = *v48 == 0;
      }
      if ( !v51 )
      {
        v196 = SavedGameDateAndTime;
        v52 = 0;
        if ( v43 != 9 )
          goto LABEL_120;
        goto LABEL_119;
      }
LABEL_103:
      v196 = SavedGameDateAndTime;
      if ( v43 == 7 )
      {
        if ( IsSCCloudAvailable() )
          sprintf(gString, "FEM_CS%d", v42 + 1);
        else
          sprintf(gString, "FEM_NC");
        if ( v24 != this->CurrentOption )
        {
          CRGBA::CRGBA(&v208, 0x4Cu, 0xC4u, 0xE8u, 0xFFu);
          CFont::SetColor(v55);
        }
      }
      else
      {
        sprintf(gString, "FEM_SL%d", v42 + 1);
      }
      CFont::SetOrientation(0);
      *(_WORD *)&aScreens[226 * this->CurrentScreen + 22 + v19] = 320;
      v25 = CText::Get(&TheText, gString);
      v56 = (int)(float)((float)RsGlobal.screenWidth * 0.0625);
      if ( RsGlobal.screenWidth == 640 )
        v56 = 40;
      v52 = v56;
      if ( v43 != 9 )
        goto LABEL_120;
LABEL_119:
      if ( v24 != this->CurrentOption )
      {
        CRGBA::CRGBA(&v207, 0, 0xCCu, 0xFFu, 0xFFu);
        goto LABEL_124;
      }
LABEL_120:
      if ( v43 != 7 || v24 == this->CurrentOption )
        goto LABEL_125;
      v206 = CloudColor;
      v57 = &v206;
LABEL_124:
      CFont::SetColor((CRGBA)v57);
LABEL_125:
      v49 = v52;
      v50 = v196;
      goto LABEL_126;
    }
    if ( v41 != 13 )
    {
      if ( v41 == 12 )
      {
        if ( *v23 )
        {
          v25 = gGxtString;
          AsciiToGxtChar(v23 + 1, gGxtString);
          v49 = 0;
          v50 = 0;
          aScreens[226 * this->CurrentScreen + 10 + v19] = 11;
          goto LABEL_126;
        }
        v40[10] = 20;
        v62 = &aScreens[226 * this->CurrentScreen + v19];
        *((_WORD *)v62 + 12) = *((_WORD *)v62 + 3);
        goto LABEL_132;
      }
      v54 = &aScreens[226 * v39 + 11 + v19];
LABEL_111:
      v25 = CText::Get(&TheText, (const unsigned __int8 *)v54);
      v50 = 0;
      v49 = 0;
      goto LABEL_126;
    }
    m_ControlMethod = (unsigned __int8)this->m_ControlMethod;
    if ( m_ControlMethod == 2 )
    {
      v54 = "FEC_MOU";
      goto LABEL_111;
    }
    if ( m_ControlMethod == 1 )
    {
      v54 = "FEJ_TIT";
      goto LABEL_111;
    }
    if ( !this->m_ControlMethod )
    {
      v54 = "FEC_MOU";
      goto LABEL_111;
    }
LABEL_132:
    v50 = 0;
    v49 = 0;
    v25 = 0;
LABEL_126:
    v58 = v25;
    v59 = (unsigned __int8)aScreens[226 * this->CurrentScreen + 10 + v19];
    switch ( aScreens[226 * this->CurrentScreen + 10 + v19] )
    {
      case 24:
        if ( !this->m_PrefsFrameLimiter )
          goto LABEL_206;
        goto LABEL_198;
      case 25:
        if ( this->m_PrefsShowSubtitles )
          goto LABEL_198;
        goto LABEL_206;
      case 26:
        if ( this->m_PrefsUseWideScreen )
          goto LABEL_198;
        goto LABEL_206;
      case 30:
        if ( this->m_PrefsUseBass )
          goto LABEL_198;
        goto LABEL_206;
      case 31:
        if ( this->m_PrefsAutoRetune )
          goto LABEL_198;
        goto LABEL_206;
      case 33:
        if ( this->m_PrefsShowLegend )
          goto LABEL_198;
        goto LABEL_206;
      case 35:
        if ( this->m_PrefsDisplayHud )
          goto LABEL_198;
        goto LABEL_206;
      case 36:
        switch ( this->m_PrefsLanguage )
        {
          case 0:
            v26 = "FEL_ENG";
            goto LABEL_207;
          case 1:
            v26 = "FEL_FRE";
            goto LABEL_207;
          case 2:
            v26 = "FEL_GER";
            goto LABEL_207;
          case 3:
            v26 = "FEL_ITA";
            goto LABEL_207;
          case 4:
            v26 = "FEL_SPA";
            goto LABEL_207;
          case 5:
            v26 = "FEL_RUS";
            goto LABEL_207;
          case 6:
            v26 = "FEL_JPN";
            goto LABEL_207;
          case 7:
            v26 = "FEL_KOR";
            goto LABEL_207;
          default:
            goto LABEL_209;
        }
        goto LABEL_209;
      case 45:
        switch ( Fx_c::GetFxQuality(&g_fx) )
        {
          case FX_QUALITY_LOW:
            v26 = "FED_FXL";
            goto LABEL_207;
          case FX_QUALITY_MEDIUM:
            v26 = "FED_FXM";
            goto LABEL_207;
          case FX_QUALITY_HIGH:
            v26 = "FED_FXH";
            goto LABEL_207;
          case FX_QUALITY_VERY_HIGH:
            v26 = "FED_FXV";
            goto LABEL_207;
          default:
            goto LABEL_209;
        }
        goto LABEL_209;
      case 46:
        v66 = "FEM_OFF";
        if ( this->m_PrefsMipMap )
          v66 = "FEM_ON";
        v50 = CText::Get(&TheText, (const unsigned __int8 *)v66);
        if ( this->m_MainMenu )
          goto LABEL_209;
        CRGBA::CRGBA(&v205, 0xEu, 0x1Eu, 0x2Fu, 0xFFu);
        goto LABEL_201;
      case 47:
        v67 = (Char *)CMemoryMgr::Calloc(0x64u, 1u);
        m_PrefsAntiAliasingDisp = this->m_PrefsAntiAliasingDisp;
        if ( m_PrefsAntiAliasingDisp < 2 )
        {
          v71 = CText::Get(&TheText, "FEM_OFF");
          v70 = v67;
          v50 = v71;
        }
        else
        {
          v197 = v49;
          v69 = v67;
          (*((void (__fastcall **)(Char *, int *, int))RwEngineInstance + 60))(
            v67,
            &dword_43036C,
            m_PrefsAntiAliasingDisp - 1);
          v50 = v218;
          AsciiToGxtChar(v69, v218);
          v70 = (Char *)v69;
          v49 = v197;
        }
        CMemoryMgr::Free(v70);
        if ( !v25 )
          goto LABEL_215;
        goto LABEL_210;
      case 49:
        if ( MousePointerStateHelper.m_bUpAndDownInverted )
          goto LABEL_198;
        goto LABEL_206;
      case 50:
        if ( this->m_PrefsJoyLeftXInvert )
          goto LABEL_198;
        goto LABEL_206;
      case 51:
        if ( this->m_PrefsJoyLeftYInvert )
          goto LABEL_198;
        goto LABEL_206;
      case 52:
        if ( this->m_PrefsJoyRightXInvert )
          goto LABEL_198;
        goto LABEL_206;
      case 53:
        if ( this->m_PrefsJoyRightYInvert )
          goto LABEL_198;
        goto LABEL_206;
      case 54:
        if ( this->m_PrefsJoyLeftAxisInvert )
          goto LABEL_198;
        goto LABEL_206;
      case 55:
        if ( this->m_PrefsJoyRightAxisInvert )
          goto LABEL_198;
        goto LABEL_206;
      case 61:
        v63 = this->m_ControlMethod;
        if ( v63 == 2 )
        {
          v26 = "FET_TCH";
          goto LABEL_207;
        }
        if ( v63 == 1 )
        {
          v26 = "FET_CCN";
          goto LABEL_207;
        }
        if ( this->m_ControlMethod )
          goto LABEL_209;
        v26 = "FET_SCN";
        goto LABEL_207;
      case 62:
        v50 = CText::Get(&TheText, "FEM_OFF");
        if ( this->m_ControlMethod != 1 )
          goto LABEL_209;
        CRGBA::CRGBA(&v204, 0xEu, 0x1Eu, 0x2Fu, 0xFFu);
        goto LABEL_201;
      case 63:
        v50 = CText::Get(&TheText, "FEM_OFF");
        if ( this->m_ControlMethod != 1 )
          goto LABEL_209;
        CRGBA::CRGBA(&v203, 0xEu, 0x1Eu, 0x2Fu, 0xFFu);
LABEL_201:
        CFont::SetColor(v64);
        if ( !v25 )
          goto LABEL_215;
        goto LABEL_210;
      case 66:
        m_PrefsPlayMode = this->m_PrefsPlayMode;
        if ( m_PrefsPlayMode == 2 )
        {
          v26 = "FEA_PR3";
        }
        else if ( m_PrefsPlayMode == 1 )
        {
          v26 = "FEA_PR2";
        }
        else
        {
          if ( this->m_PrefsPlayMode )
            goto LABEL_209;
          v26 = "FEA_PR1";
        }
LABEL_207:
        v61 = CText::Get(&TheText, (const unsigned __int8 *)v26);
LABEL_208:
        v50 = v61;
LABEL_209:
        if ( v25 )
        {
LABEL_210:
          v72 = (float)*(__int16 *)&aScreens[226 * this->CurrentScreen + 22 + v19];
          if ( RsGlobal.screenWidth != 640 )
            v72 = (float)(v72 / 640.0) * (float)RsGlobal.screenWidth;
          v73 = (float)*(__int16 *)&aScreens[226 * this->CurrentScreen + 24 + v19];
          if ( RsGlobal.screenHeight != 448 )
            v73 = (float)(v73 / 448.0) * (float)RsGlobal.screenHeight;
          CFont::PrintString(v72, v73, v25);
        }
LABEL_215:
        if ( v50 )
        {
          CFont::SetFontStyle(2u);
          CFont::SetEdge(1);
          CFont::SetOrientation(2u);
          screenHeight = (float)RsGlobal.screenHeight;
          if ( (unsigned __int8)(aScreens[226 * this->CurrentScreen + 19 + v19] - 1) > 9u )
          {
            v75 = screenHeight * 0.0022321;
            if ( RsGlobal.screenHeight == 448 )
              v75 = 1.0;
          }
          else
          {
            v75 = screenHeight * 0.0021205;
            if ( RsGlobal.screenHeight == 448 )
              v75 = 0.95;
          }
          CFont::SetScale(v75);
          v76 = (float)RsGlobal.screenWidth * 0.0625;
          if ( RsGlobal.screenWidth == 640 )
            v76 = 40.0;
          v77 = (float)*(__int16 *)&aScreens[226 * this->CurrentScreen + 24 + v19];
          if ( RsGlobal.screenHeight != 448 )
            v77 = (float)(v77 / 448.0) * (float)RsGlobal.screenHeight;
          CFont::PrintString((float)RsGlobal.screenWidth - v76, v77, v50);
        }
        if ( !v25 || v200 != this->CurrentOption )
          goto LABEL_254;
        v78 = (unsigned __int8)this->CurrentScreen;
        v79 = v78 == 2;
        if ( v78 != 2 )
          v79 = v78 == 5;
        if ( v79 )
          goto LABEL_254;
        if ( v49 << 16 )
          goto LABEL_246;
        v80 = aScreens[226 * (char)v78 + 26 + v19];
        if ( v80 == 2 )
        {
          v84 = *(__int16 *)&aScreens[226 * (char)v78 + 22 + v19];
          v85 = (float)RsGlobal.screenWidth * 0.0625;
          if ( RsGlobal.screenWidth == 640 )
            v85 = 40.0;
          v86 = (float)((float)RsGlobal.screenWidth / 640.0) * (float)v84;
          goto LABEL_244;
        }
        if ( v80 != 1 )
        {
          v87 = (float)RsGlobal.screenWidth * 0.0625;
          if ( RsGlobal.screenWidth == 640 )
            v87 = 40.0;
          v86 = (float)((float)((float)RsGlobal.screenWidth / 640.0)
                      * (float)*(__int16 *)&aScreens[226 * (char)v78 + 22 + v19])
              - v87;
          v85 = CFont::GetStringWidth(v25, 1u, 0) * -0.5;
          v21 = 0.78125;
LABEL_244:
          v83 = v86 + v85;
          goto LABEL_245;
        }
        v81 = *(__int16 *)&aScreens[226 * (char)v78 + 22 + v19];
        v82 = (float)RsGlobal.screenWidth * 0.0625;
        if ( RsGlobal.screenWidth == 640 )
          v82 = 40.0;
        v83 = (float)((float)((float)RsGlobal.screenWidth / 640.0) * (float)v81) - v82;
LABEL_245:
        v49 = (int)v83;
LABEL_246:
        if ( this->InOptionsMenu )
        {
          v88 = (unsigned __int8)this->CurrentScreen;
          if ( v88 > 0x12 || ((1 << v88) & 0x46000) == 0 )
          {
            v89 = (float)RsGlobal.screenWidth * 0.0078125;
            v90 = (float)RsGlobal.screenWidth * 0.05;
            if ( RsGlobal.screenWidth == 640 )
            {
              v89 = 5.0;
              v90 = 32.0;
            }
            v91 = (float)RsGlobal.screenWidth * 0.073437;
            if ( RsGlobal.screenWidth == 640 )
              v91 = 47.0;
            v92 = (float)((float)RsGlobal.screenHeight / 448.0)
                * (float)*(__int16 *)&aScreens[226 * (char)v88 + 24 + v19];
            Rectangle.left = (float)(__int16)v49;
            Rectangle.right = v90 + Rectangle.left;
            Rectangle.bottom = v92 - v89;
            Rectangle.top = v92 + v91;
            CRGBA::CRGBA(&v201, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
            CSprite2d::Draw(this->FrontEndSprites, &Rectangle, &v201);
          }
        }
LABEL_254:
        if ( this->m_PrefsResolutionDisp == this->m_PrefsResolution
          && !strcmp(&aScreens[226 * this->CurrentScreen + 11 + 18 * this->CurrentOption], "FED_RES")
          && *p_CurrentHelperMessage == 1 )
        {
          CMenuManager::ResetHelperText(this);
        }
        if ( this->m_PrefsAntiAliasingDisp == this->m_PrefsAntiAliasing
          && !strcmp(&aScreens[226 * this->CurrentScreen + 11 + 18 * this->CurrentOption], "FED_AAS")
          && *p_CurrentHelperMessage == 1 )
        {
          CMenuManager::ResetHelperText(this);
        }
        if ( this->m_PrefsResolutionDisp != this->m_PrefsResolution
          && !strcmp(&aScreens[226 * this->CurrentScreen + 11 + 18 * this->CurrentOption], "FED_RES") )
        {
          CMenuManager::SetHelperText(this, 1);
        }
        v94 = this->m_PrefsAntiAliasingDisp;
        m_PrefsAntiAliasing = this->m_PrefsAntiAliasing;
        if ( v94 == m_PrefsAntiAliasing )
          goto LABEL_276;
        if ( !strcmp(&aScreens[226 * this->CurrentScreen + 11 + 18 * this->CurrentOption], "FED_AAS") )
        {
          CMenuManager::SetHelperText(this, 1);
          m_PrefsAntiAliasing = this->m_PrefsAntiAliasing;
          if ( this->m_PrefsAntiAliasingDisp == m_PrefsAntiAliasing )
            goto LABEL_276;
        }
        else if ( v94 == m_PrefsAntiAliasing )
        {
          goto LABEL_276;
        }
        v95 = this->CurrentScreen;
        if ( strcmp(&aScreens[226 * v95 + 11 + 18 * this->CurrentOption], "FED_AAS") )
        {
          v96 = v95 == 27;
          if ( v95 != 27 )
            v96 = v95 == 4;
          if ( v96 )
          {
            this->m_PrefsAntiAliasingDisp = m_PrefsAntiAliasing;
            CMenuManager::SetHelperText(this, 3);
          }
        }
LABEL_276:
        v97 = *(_QWORD *)&this->m_PrefsResolution;
        if ( HIDWORD(v97) != (_DWORD)v97 )
        {
          v98 = this->CurrentScreen;
          if ( strcmp(&aScreens[226 * v98 + 11 + 18 * this->CurrentOption], "FED_RES") )
          {
            v99 = v98 == 27;
            if ( v98 != 27 )
              v99 = v98 == 4;
            if ( v99 )
            {
              this->m_PrefsResolutionDisp = v97;
              CMenuManager::SetHelperText(this, 3);
            }
          }
        }
        v100 = v58;
        v25 = (GxtChar *)aScreens;
        v23 = v199;
        v24 = v200;
        switch ( aScreens[226 * this->CurrentScreen + 10 + v19] )
        {
          case 28:
            v101 = 4.0;
            v102 = 95.0;
            screenWidth = (float)RsGlobal.screenWidth;
            v104 = (float)RsGlobal.screenWidth * v21;
            if ( RsGlobal.screenWidth == 640 )
              v104 = 500.0;
            v105 = 20.0;
            if ( RsGlobal.screenHeight != 448 )
            {
              v105 = (float)RsGlobal.screenHeight * 0.044643;
              v102 = (float)RsGlobal.screenHeight * 0.21205;
              v101 = (float)RsGlobal.screenHeight * 0.0089286;
            }
            v106 = v101;
            v107 = screenWidth * 0.15625;
            v108 = screenWidth * 0.0046875;
            if ( RsGlobal.screenWidth == 640 )
              v107 = 100.0;
            seg_size = (int)v108;
            if ( RsGlobal.screenWidth == 640 )
              seg_size = 3;
            v110 = CMenuManager::DisplaySlider(
                     (CMenuManager *)RsGlobal.screenWidth,
                     v104,
                     v102,
                     v106,
                     v105,
                     v107,
                     (float)this->m_PrefsMusicVolume * 0.015625,
                     seg_size);
            v25 = (GxtChar *)aScreens;
            if ( v200 != this->CurrentOption || v195 )
              goto LABEL_404;
            v111 = (float)RsGlobal.screenWidth * 0.0046875;
            v112 = (float)v110;
            if ( RsGlobal.screenWidth == 640 )
              v111 = 3.0;
            v113 = (int)(float)(v112 - v111);
            if ( RsGlobal.screenHeight == 448 )
            {
              v114 = 95;
              v115 = 120.0;
            }
            else
            {
              v115 = (float)RsGlobal.screenHeight * 0.26786;
              v114 = (int)(float)((float)RsGlobal.screenHeight * 0.21205);
            }
            if ( CMenuManager::CheckHover(this, 0, v113, v114, (int)v115) )
            {
              v161 = &this->MouseInBounds;
              v162 = 11;
              goto LABEL_348;
            }
            if ( RsGlobal.screenWidth == 640 )
            {
              v163 = 640.0;
              v164 = v112 + 3.0;
            }
            else
            {
              v163 = (float)((float)RsGlobal.screenWidth / 640.0) * (float)RsGlobal.screenWidth;
              v164 = (float)((float)RsGlobal.screenWidth * 0.0046875) + v112;
            }
            v21 = 0.78125;
            v171 = (int)v164;
            if ( RsGlobal.screenHeight == 448 )
            {
              v172 = 95;
              v173 = 120.0;
            }
            else
            {
              v173 = (float)RsGlobal.screenHeight * 0.26786;
              v172 = (int)(float)((float)RsGlobal.screenHeight * 0.21205);
            }
            if ( !CMenuManager::CheckHover(this, v171, (int)v163, v172, (int)v173) )
              goto LABEL_403;
            *p_MouseInBounds = 10;
            v183 = (float)RsGlobal.screenWidth * 0.78125;
            if ( RsGlobal.screenWidth == 640 )
              v183 = 500.0;
            if ( v183 > (float)this->MousePosX )
              goto LABEL_403;
            v184 = (float)RsGlobal.screenHeight * 0.21205;
            MousePosY = (float)this->MousePosY;
            if ( RsGlobal.screenHeight == 448 )
              v184 = 95.0;
            if ( v184 > MousePosY )
              goto LABEL_403;
            v186 = RsGlobal.screenHeight == 448;
            v187 = (float)RsGlobal.screenHeight * 0.26786;
            *(float *)&v188 = 120.0;
            goto LABEL_394;
          case 29:
            v116 = 4.0;
            v117 = 125.0;
            v118 = (float)RsGlobal.screenWidth;
            v119 = (float)RsGlobal.screenWidth * v21;
            if ( RsGlobal.screenWidth == 640 )
              v119 = 500.0;
            v120 = 20.0;
            if ( RsGlobal.screenHeight != 448 )
            {
              v120 = (float)RsGlobal.screenHeight * 0.044643;
              v117 = (float)RsGlobal.screenHeight * 0.27902;
              v116 = (float)RsGlobal.screenHeight * 0.0089286;
            }
            v121 = v116;
            v122 = v118 * 0.15625;
            v123 = v118 * 0.0046875;
            if ( RsGlobal.screenWidth == 640 )
              v122 = 100.0;
            v124 = (int)v123;
            if ( RsGlobal.screenWidth == 640 )
              v124 = 3;
            v125 = CMenuManager::DisplaySlider(
                     (CMenuManager *)RsGlobal.screenWidth,
                     v119,
                     v117,
                     v121,
                     v120,
                     v122,
                     (float)this->m_PrefsSfxVolume * 0.015625,
                     v124);
            v25 = (GxtChar *)aScreens;
            if ( v200 != this->CurrentOption || v195 )
              goto LABEL_404;
            v126 = (float)RsGlobal.screenWidth * 0.0046875;
            v127 = (float)v125;
            if ( RsGlobal.screenWidth == 640 )
              v126 = 3.0;
            v128 = (int)(float)(v127 - v126);
            if ( RsGlobal.screenHeight == 448 )
            {
              v129 = 125;
              v130 = 150.0;
            }
            else
            {
              v130 = (float)RsGlobal.screenHeight * 0.33482;
              v129 = (int)(float)((float)RsGlobal.screenHeight * 0.27902);
            }
            if ( CMenuManager::CheckHover(this, 0, v128, v129, (int)v130) )
            {
              v161 = &this->MouseInBounds;
              v162 = 13;
              goto LABEL_348;
            }
            if ( RsGlobal.screenWidth == 640 )
            {
              v165 = 640.0;
              v166 = v127 + 3.0;
            }
            else
            {
              v165 = (float)((float)RsGlobal.screenWidth / 640.0) * (float)RsGlobal.screenWidth;
              v166 = (float)((float)RsGlobal.screenWidth * 0.0046875) + v127;
            }
            v21 = 0.78125;
            v174 = (int)v166;
            if ( RsGlobal.screenHeight == 448 )
            {
              v175 = 125;
              v176 = 150.0;
            }
            else
            {
              v176 = (float)RsGlobal.screenHeight * 0.33482;
              v175 = (int)(float)((float)RsGlobal.screenHeight * 0.27902);
            }
            if ( CMenuManager::CheckHover(this, v174, (int)v165, v175, (int)v176) )
            {
              *p_MouseInBounds = 12;
              v189 = (float)RsGlobal.screenWidth * 0.78125;
              if ( RsGlobal.screenWidth == 640 )
                v189 = 500.0;
              if ( v189 <= (float)this->MousePosX )
                goto LABEL_390;
            }
            goto LABEL_403;
          case 64:
            v131 = 4.0;
            v132 = 125.0;
            v133 = (float)RsGlobal.screenWidth;
            v134 = (float)RsGlobal.screenWidth * v21;
            if ( RsGlobal.screenWidth == 640 )
              v134 = 500.0;
            v135 = 20.0;
            if ( RsGlobal.screenHeight != 448 )
            {
              v135 = (float)RsGlobal.screenHeight * 0.044643;
              v132 = (float)RsGlobal.screenHeight * 0.27902;
              v131 = (float)RsGlobal.screenHeight * 0.0089286;
            }
            v136 = v134;
            v137 = v133 * 0.15625;
            v138 = v133 * 0.0046875;
            if ( RsGlobal.screenWidth == 640 )
              v137 = 100.0;
            v139 = (int)v138;
            if ( RsGlobal.screenWidth == 640 )
              v139 = 3;
            v140 = CMenuManager::DisplaySlider(
                     (CMenuManager *)RsGlobal.screenWidth,
                     v136,
                     v132,
                     v131,
                     v135,
                     v137,
                     (float)(this->m_PrefsLOD + -0.875) / 0.875,
                     v139);
            v25 = (GxtChar *)aScreens;
            if ( v200 != this->CurrentOption || v195 )
              goto LABEL_404;
            v141 = (float)RsGlobal.screenWidth * 0.0046875;
            v142 = (float)v140;
            if ( RsGlobal.screenWidth == 640 )
              v141 = 3.0;
            v143 = (int)(float)(v142 - v141);
            if ( RsGlobal.screenHeight == 448 )
            {
              v144 = 125;
              v145 = 150.0;
            }
            else
            {
              v145 = (float)RsGlobal.screenHeight * 0.33482;
              v144 = (int)(float)((float)RsGlobal.screenHeight * 0.27902);
            }
            if ( CMenuManager::CheckHover(this, 0, v143, v144, (int)v145) )
            {
              v161 = &this->MouseInBounds;
              v162 = 9;
              goto LABEL_348;
            }
            if ( RsGlobal.screenWidth == 640 )
            {
              v167 = 640.0;
              v168 = v142 + 3.0;
            }
            else
            {
              v167 = (float)((float)RsGlobal.screenWidth / 640.0) * (float)RsGlobal.screenWidth;
              v168 = (float)((float)RsGlobal.screenWidth * 0.0046875) + v142;
            }
            v21 = 0.78125;
            v177 = (int)v168;
            if ( RsGlobal.screenHeight == 448 )
            {
              v178 = 125;
              v179 = 150.0;
            }
            else
            {
              v179 = (float)RsGlobal.screenHeight * 0.33482;
              v178 = (int)(float)((float)RsGlobal.screenHeight * 0.27902);
            }
            if ( !CMenuManager::CheckHover(this, v177, (int)v167, v178, (int)v179) )
              goto LABEL_403;
            *p_MouseInBounds = 8;
            v190 = (float)RsGlobal.screenWidth * 0.78125;
            if ( RsGlobal.screenWidth == 640 )
              v190 = 500.0;
            if ( v190 > (float)this->MousePosX )
              goto LABEL_403;
LABEL_390:
            v191 = (float)RsGlobal.screenHeight * 0.27902;
            MousePosY = (float)this->MousePosY;
            if ( RsGlobal.screenHeight == 448 )
              v191 = 125.0;
            if ( v191 <= MousePosY )
            {
              v186 = RsGlobal.screenHeight == 448;
              v187 = (float)RsGlobal.screenHeight * 0.33482;
              *(float *)&v188 = 150.0;
LABEL_394:
              if ( v186 )
                v187 = *(float *)&v188;
              if ( v187 >= MousePosY )
                goto LABEL_404;
            }
            goto LABEL_403;
          case 65:
            v146 = 4.0;
            v147 = 125.0;
            v148 = (float)RsGlobal.screenWidth;
            v149 = (float)RsGlobal.screenWidth * v21;
            if ( RsGlobal.screenWidth == 640 )
              v149 = 500.0;
            v150 = 20.0;
            if ( RsGlobal.screenHeight != 448 )
            {
              v150 = (float)RsGlobal.screenHeight * 0.044643;
              v147 = (float)RsGlobal.screenHeight * 0.27902;
              v146 = (float)RsGlobal.screenHeight * 0.0089286;
            }
            v151 = v149;
            v152 = v148 * 0.15625;
            v153 = v148 * 0.0046875;
            if ( RsGlobal.screenWidth == 640 )
              v152 = 100.0;
            v154 = (CMenuManager *)(int)v153;
            if ( RsGlobal.screenWidth == 640 )
              v154 = (CMenuManager *)((char *)&dword_0 + 3);
            v155 = CMenuManager::DisplaySlider(
                     v154,
                     v151,
                     v147,
                     v146,
                     v150,
                     v152,
                     CCamera::m_fMouseAccelHorzntl / 0.005,
                     (int)v154);
            if ( v200 != this->CurrentOption || v195 )
              goto LABEL_404;
            v156 = (float)RsGlobal.screenWidth * 0.0046875;
            v157 = (float)v155;
            if ( RsGlobal.screenWidth == 640 )
              v156 = 3.0;
            v158 = (int)(float)(v157 - v156);
            if ( RsGlobal.screenHeight == 448 )
            {
              v159 = 125;
              v160 = 150.0;
            }
            else
            {
              v160 = (float)RsGlobal.screenHeight * 0.33482;
              v159 = (int)(float)((float)RsGlobal.screenHeight * 0.27902);
            }
            if ( CMenuManager::CheckHover(this, 0, v158, v159, (int)v160) )
            {
              v161 = &this->MouseInBounds;
              v162 = 15;
LABEL_348:
              *v161 = v162;
              v21 = 0.78125;
              if ( v100 )
                goto LABEL_405;
            }
            else
            {
              if ( RsGlobal.screenWidth == 640 )
              {
                v169 = 640.0;
                v170 = v157 + 3.0;
              }
              else
              {
                v169 = (float)((float)RsGlobal.screenWidth / 640.0) * (float)RsGlobal.screenWidth;
                v170 = (float)((float)RsGlobal.screenWidth * 0.0046875) + v157;
              }
              v21 = 0.78125;
              v180 = (int)v170;
              if ( RsGlobal.screenHeight == 448 )
              {
                v181 = 125;
                v182 = 150.0;
              }
              else
              {
                v182 = (float)RsGlobal.screenHeight * 0.33482;
                v181 = (int)(float)((float)RsGlobal.screenHeight * 0.27902);
              }
              if ( !CMenuManager::CheckHover(this, v180, (int)v169, v181, (int)v182) )
                goto LABEL_403;
              *p_MouseInBounds = 14;
              v192 = (float)RsGlobal.screenWidth * 0.78125;
              if ( RsGlobal.screenWidth == 640 )
                v192 = 500.0;
              if ( v192 > (float)this->MousePosX )
LABEL_403:
                *p_MouseInBounds = 16;
LABEL_404:
              if ( v100 )
LABEL_405:
                v22 = v22 + (float)(unsigned int)(29 * CFont::GetNumberLines(60.0, v22, v100));
            }
            LOBYTE(CurrentScreen) = this->CurrentScreen;
            if ( aScreens[226 * (char)CurrentScreen + 10 + v19] == 32 )
              v22 = v22 + 70.0;
            break;
          default:
            goto LABEL_404;
        }
        break;
      case 67:
        if ( this->m_PrefsAutoMediaScan )
          goto LABEL_198;
        goto LABEL_206;
      case 68:
        if ( this->m_PrefsSavePhotosToGallery )
          goto LABEL_198;
        goto LABEL_206;
      case 70:
        if ( FrontEndMenuManager.m_PrefsMarketing )
LABEL_198:
          v26 = "FEM_ON";
        else
LABEL_206:
          v26 = "FEM_OFF";
        goto LABEL_207;
      case 71:
      case 74:
      case 75:
      case 76:
      case 77:
      case 78:
      case 79:
      case 80:
      case 81:
      case 82:
        v60 = v59 - 71;
        v61 = CText::Get(
                &TheText,
                MobileSettings::settings[v59 - 71].values[MobileSettings::settings[v59 - 71].value
                                                        - MobileSettings::settings[v59 - 71].min]);
        if ( v60 != 3 )
          goto LABEL_208;
        v50 = v61;
        if ( MobileSettings::settings[3].value != -1 )
          goto LABEL_209;
        v26 = "FET_NOT";
        goto LABEL_207;
      default:
        goto LABEL_209;
    }
LABEL_408:
    v19 += 18;
    v23 += 261;
    ++v24;
  }
  while ( v19 != 216 );
}
// 42F37A: variable 'v11' is possibly undefined
// 42F38C: variable 'v12' is possibly undefined
// 42F9E6: variable 'v29' is possibly undefined
// 42FA16: variable 'v31' is possibly undefined
// 42FA4E: variable 'v34' is possibly undefined
// 42FCB8: variable 'v55' is possibly undefined
// 42FD44: variable 'v57' is possibly undefined
// 4304D6: variable 'v64' is possibly undefined
// 0: using guessed type int dword_0;
// 24: using guessed type int dword_24;
// 43036C: using guessed type int dword_43036C;

//----- (004314D0) --------------------------------------------------------
void __fastcall CMenuManager::MessageScreen(
        CMenuManager *this,
        unsigned __int8 *pMsg,
        bool bClearScreen,
        bool bLoadingScreen)
{
  _BOOL4 v4; // r5
  CMenuManager *v6; // r0
  CRGBA v7; // [sp+8h] [bp-28h] BYREF
  CRGBA v8; // [sp+Ch] [bp-24h] BYREF
  CRect Rectangle; // [sp+10h] [bp-20h] BYREF

  v4 = bClearScreen;
  if ( !bLoadingScreen )
  {
    if ( !RsCameraBeginUpdate(Scene.camera) )
      return;
    if ( v4 )
    {
      Rectangle.left = 0.0;
      Rectangle.bottom = 0.0;
      Rectangle.right = (float)RsGlobal.screenWidth;
      Rectangle.top = (float)RsGlobal.screenHeight;
      CRGBA::CRGBA(&v8, 0, 0, 0, 0xFFu);
      CSprite2d::DrawRect(&Rectangle, &v8);
    }
  }
  CSprite2d::SetRecipNearClip();
  CSprite2d::InitPerFrame();
  CFont::InitPerFrame();
  DefinedState2d();
  CRGBA::CRGBA(&v8, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
  if ( v4 )
  {
    Rectangle.left = 0.0;
    Rectangle.bottom = 0.0;
    Rectangle.right = (float)RsGlobal.screenWidth;
    Rectangle.top = (float)RsGlobal.screenHeight;
    CRGBA::CRGBA(&v7, 0, 0, 0, 0xFFu);
    CSprite2d::DrawRect(&Rectangle, &v7);
  }
  CMenuManager::SmallMessageScreen(v6, pMsg);
  CFont::RenderFontBuffer();
}
// 431594: variable 'v6' is possibly undefined

//----- (004315B0) --------------------------------------------------------
Int32 __fastcall CMenuManager::DisplaySlider(
        CMenuManager *this,
        float ScreenX,
        float ScreenY,
        float StartHeight,
        float EndHeight,
        float Length,
        float Value,
        int seg_size)
{
  float32x2_t v8; // d2
  float32x2_t v9; // d9
  float v10; // s20
  float v12; // s22
  int v13; // r9
  int v14; // r5
  int v15; // r10
  float v16; // s29
  float v17; // s0
  float v18; // s2
  CRGBA v20; // [sp+8h] [bp-78h] BYREF
  CRect v21; // [sp+Ch] [bp-74h] BYREF
  float left; // [sp+1Ch] [bp-64h] BYREF

  v8.n64_f32[0] = EndHeight;
  v9.n64_f32[0] = StartHeight;
  v10 = (float)seg_size;
  v12 = vmax_f32(v9, v8).n64_f32[0] + ScreenY;
  v13 = 0;
  v14 = 16;
  v15 = 0;
  do
  {
    v16 = (float)((float)((float)v15 * Length) * 0.0625) + ScreenX;
    if ( (float)((float)((float)v15 * 0.0625) + 0.03125) >= Value )
    {
      CRGBA::CRGBA((CRGBA *)&v21, 0x4Au, 0x5Au, 0x6Bu, 0xFFu);
      left = v21.left;
    }
    else
    {
      CRGBA::CRGBA((CRGBA *)&v21, 0xACu, 0xCBu, 0xF1u, 0xFFu);
      left = v21.left;
      v13 = (int)v16;
    }
    v17 = (float)RsGlobal.screenWidth * 0.003125;
    if ( RsGlobal.screenWidth == 640 )
      v17 = 2.0;
    v18 = (float)RsGlobal.screenHeight * 0.0044643;
    if ( RsGlobal.screenHeight == 448 )
      v18 = 2.0;
    v21.left = v16 + v17;
    v21.bottom = (float)(v12
                       - (float)((float)((float)((float)v15 * EndHeight) + (float)((float)v14 * v9.n64_f32[0])) * 0.0625))
               + v18;
    v21.right = (float)(v16 + v10) + v17;
    v21.top = v12 + v18;
    CRGBA::CRGBA(&v20, 0, 0, 0, 0xC8u);
    CSprite2d::DrawRect(&v21, &v20);
    v21.bottom = v12 - (float)((float)((float)((float)v15 * EndHeight) + (float)((float)v14 * v9.n64_f32[0])) * 0.0625);
    v21.left = (float)((float)((float)v15 * Length) * 0.0625) + ScreenX;
    v21.right = v16 + v10;
    v21.top = v12;
    CSprite2d::DrawRect(&v21, (const CRGBA *)&left);
    --v14;
    ++v15;
  }
  while ( v14 );
  return v13;
}
// 4315D0: variable 'v9' is possibly undefined
// 4315D0: variable 'v8' is possibly undefined

//----- (0043177C) --------------------------------------------------------
void __fastcall CMenuManager::PrintRadioStationList(CMenuManager *this)
{
  CSprite2d *v1; // r5
  int m_PrefsRadioStation; // r3
  int v3; // r4
  Int8 v4; // r1
  int v5; // r6
  float v6; // s28
  RwInt32 screenWidth; // r8
  float v8; // s30
  RwInt32 screenHeight; // r10
  float v10; // s2
  float v11; // s0
  float v12; // s4
  float v13; // s0
  float v14; // s18
  RwInt32 v15; // r5
  CSprite2d *v16; // r4
  float v17; // s16
  RwInt32 v18; // r6
  const CRGBA *v19; // r0
  float v20; // s0
  float v21; // s2
  float v22; // s4
  float v23; // s0
  CRGBA v25; // [sp+10h] [bp-68h] BYREF
  CRGBA rgba; // [sp+14h] [bp-64h] BYREF

  v1 = &this->FrontEndSprites[1];
  m_PrefsRadioStation = this->m_PrefsRadioStation;
  v3 = 1;
  v4 = this->m_PrefsRadioStation;
  v5 = 44;
  do
  {
    if ( v3 != m_PrefsRadioStation )
    {
      v6 = (float)v5;
      screenWidth = RsGlobal.screenWidth;
      if ( RsGlobal.screenWidth == 640 )
      {
        v8 = (float)640;
      }
      else
      {
        v8 = (float)RsGlobal.screenWidth;
        v6 = (float)(v6 / 640.0) * (float)RsGlobal.screenWidth;
      }
      screenHeight = RsGlobal.screenHeight;
      CRGBA::CRGBA(&rgba, 0xFFu, 0xFFu, 0xFFu, 0x1Eu);
      v10 = v8 * 0.054688;
      v11 = (float)screenHeight;
      if ( screenWidth == 640 )
        v10 = 35.0;
      v12 = v11 * 0.66964;
      if ( screenHeight == 448 )
        v12 = 300.0;
      v13 = v11 * 0.078125;
      if ( screenHeight == 448 )
        v13 = 35.0;
      CSprite2d::Draw(v1, v6, v12, v10, v13, &rgba);
      v4 = this->m_PrefsRadioStation;
    }
    ++v3;
    ++v1;
    v5 += 47;
    m_PrefsRadioStation = v4;
  }
  while ( v3 != 13 );
  if ( (unsigned __int8)(v4 - 1) < 0xCu )
  {
    v14 = (float)(47 * v4 - 15);
    v15 = RsGlobal.screenWidth;
    v16 = &this->FrontEndSprites[v4];
    v17 = (float)RsGlobal.screenWidth;
    if ( RsGlobal.screenWidth != 640 )
      v14 = (float)(v14 / 640.0) * (float)RsGlobal.screenWidth;
    v18 = RsGlobal.screenHeight;
    CRGBA::CRGBA(&v25, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
    v20 = (float)v18;
    v21 = v17 * 0.09375;
    if ( v15 == 640 )
      v21 = 60.0;
    v22 = v20 * 0.64732;
    if ( v18 == 448 )
      v22 = 290.0;
    v23 = v20 * 0.13393;
    if ( v18 == 448 )
      v23 = 60.0;
    CSprite2d::Draw(v16, v14, v22, v21, v23, v19);
  }
}
// 431928: variable 'v19' is possibly undefined

//----- (0043197C) --------------------------------------------------------
void __fastcall CMenuManager::JumpToGenericMessageScreen(
        CMenuManager *this,
        int8 NewScreen,
        const unsigned __int8 *HeadingText,
        const unsigned __int8 *ErrorText)
{
  int v6; // r4
  char v8; // r0

  v6 = NewScreen;
  CMenuManager::SwitchToNewScreen(this, NewScreen);
  if ( v6 == 20 )
  {
    v8 = 1;
    goto LABEL_5;
  }
  if ( v6 == 21 )
  {
    v8 = 16;
LABEL_5:
    aScreens[226 * this->CurrentScreen + 38] = v8;
  }
  strncpy(&aScreens[226 * this->CurrentScreen], (const char *)HeadingText, 8u);
  sub_19F6E8(&aScreens[226 * this->CurrentScreen + 11], (const char *)ErrorText, 8u);
}

//----- (004319F0) --------------------------------------------------------
void __fastcall CMenuManager::SwitchToNewScreen(CMenuManager *this, int8 newCurrentScreen)
{
  int v2; // r5
  bool v3; // zf
  bool v5; // zf
  Int8 CurrentScreen; // r1
  int v7; // r0
  RwInt32 m_PrefsResolution; // r2
  Int32 v9; // r1

  v2 = newCurrentScreen;
  v3 = newCurrentScreen == 16;
  if ( newCurrentScreen != 16 )
    v3 = newCurrentScreen == 5;
  if ( v3 )
  {
    if ( !IsPlayingGame() )
      return;
    v5 = v2 == 16;
    if ( v2 == 16 )
      v5 = this->CurrentScreen == 42;
    if ( v5 )
      SaveGameFromMenu = 1;
  }
  CurrentScreen = this->CurrentScreen;
  this->DisplayWarningScreenForUnboundControls = 0;
  this->PreviousScreen = CurrentScreen;
  CMenuManager::ResetHelperText(this);
  v7 = (unsigned __int8)this->CurrentScreen;
  if ( v7 == 4 )
  {
    m_PrefsResolution = this->m_PrefsResolution;
    this->m_PrefsAntiAliasingDisp = this->m_PrefsAntiAliasing;
    this->m_PrefsResolutionDisp = m_PrefsResolution;
  }
  if ( v2 != -2 && v2 )
  {
    this->CurrentScreen = v2;
    this->CurrentOption = 0;
    LOBYTE(v7) = v2;
  }
  if ( v2 != -2 )
  {
    if ( !v2 )
    {
      LOBYTE(v7) = aScreens[226 * (char)v7 + 20 + 18 * this->CurrentOption];
      this->CurrentScreen = v7;
      this->CurrentOption = 0;
    }
    goto LABEL_29;
  }
  v7 = (char)v7;
  if ( !this->m_MainMenu )
    goto LABEL_27;
  if ( v7 == 35 )
  {
    v9 = 2;
    goto LABEL_28;
  }
  if ( v7 == 33 )
  {
    v9 = 1;
    goto LABEL_28;
  }
  if ( v7 != 1 )
  {
LABEL_27:
    v9 = aScreens[226 * (__int16)v7 + 9];
    goto LABEL_28;
  }
  v9 = 0;
LABEL_28:
  this->CurrentOption = v9;
  LOBYTE(v7) = aScreens[226 * (__int16)v7 + 8];
  this->CurrentScreen = v7;
LABEL_29:
  if ( (unsigned __int8)v7 == 16 )
    this->CurrentOption = 9;
  if ( this->m_MainMenu )
  {
    if ( (unsigned __int8)v7 == 11 )
    {
      this->CurrentScreen = 13;
    }
    else
    {
      v7 = (char)v7;
      if ( (char)v7 == 8 )
      {
        CGame::bMissionPackGame = this->CurrentSelectedMissionPack;
      }
      else if ( v7 == 6 )
      {
        CGame::bMissionPackGame = 0;
      }
    }
  }
}

//----- (00431B30) --------------------------------------------------------
void __fastcall CMenuManager::ChangeLanguage(CMenuManager *this, int8 newLang)
{
  this->bFrontEnd_ReloadObrTxtGxt = 1;
  this->m_PrefsLanguage = newLang;
}

//----- (00431B3C) --------------------------------------------------------
void __fastcall CMenuManager::Process(CMenuManager *this)
{
  CMenuManager::InitialiseChangedLanguageSettings(this, 0);
  CMenuManager::UserInput(this);
  CMenuManager::ProcessFileActions(this);
  if ( this->CurrentScreen == 50 )
  {
    OS_ServiceOpenLink("http://www.rockstarwarehouse.com/");
    this->CurrentScreen = 43;
  }
}

//----- (00431B90) --------------------------------------------------------
void __fastcall CMenuManager::ProcessFileActions(CMenuManager *this)
{
  int CurrentScreen; // r0
  Int8 v3; // r1
  RwInt32 v4; // r1
  bool8 v5; // r5
  u_native v6; // r0
  int v7; // r10
  char *v8; // r0
  char v9; // r1
  Int8 v10; // r1
  RwInt32 m_PrefsResolution; // r1
  char *v12; // r0
  Int8 v13; // r1
  RwInt32 v14; // r1
  char *v15; // r1
  char *v16; // r0
  int v17; // r5
  int v18; // r6
  Int8 v19; // r1
  int v20; // r0
  RwInt32 v21; // r1
  __int16 v22; // r0
  int v23; // r1
  RwInt32 v24; // r1
  char *v25; // r0
  Int8 v26; // r2
  RwInt32 v27; // r1

  CurrentScreen = this->CurrentScreen;
  switch ( CurrentScreen )
  {
    case 13:
      if ( CMenuManager::ProcessFileActions(void)::CurrentlyLoading )
      {
        if ( CGenericGameStorage::CheckSlotDataValid(gMobileMenu.SelectedSlot, 1) )
        {
          gMobileMenu.WantsToLoad = 1;
          v5 = 0;
          CGame::bMissionPackGame = 0;
        }
        else
        {
          v5 = 0;
          v10 = this->CurrentScreen;
          this->DisplayWarningScreenForUnboundControls = 0;
          this->PreviousScreen = v10;
          CMenuManager::ResetHelperText(this);
          if ( this->CurrentScreen == 4 )
          {
            m_PrefsResolution = this->m_PrefsResolution;
            this->m_PrefsAntiAliasingDisp = this->m_PrefsAntiAliasing;
            this->m_PrefsResolutionDisp = m_PrefsResolution;
          }
          this->CurrentScreen = 20;
          this->CurrentOption = 0;
          byte_6AC64E = 1;
          strncpy(&aScreens[226 * this->CurrentScreen], "FET_LG", 8u);
          v12 = &aScreens[226 * this->CurrentScreen];
          *(_DWORD *)(v12 + 15) = &loc_45434C;
          *(_DWORD *)(v12 + 11) = 1599292742;
        }
      }
      else
      {
        v5 = 1;
      }
      CMenuManager::ProcessFileActions(void)::CurrentlyLoading = v5;
      return;
    case 18:
      if ( !CMenuManager::ProcessFileActions(void)::CurrentlySaving )
      {
        v8 = &CMenuManager::ProcessFileActions(void)::CurrentlySaving;
        goto LABEL_18;
      }
      if ( CGame::bMissionPackGame )
      {
        CFileMgr::SetDirMyDocuments();
        sprintf(gString, "MPACK//MPACK%d//SCR.SCM", CGame::bMissionPackGame);
        v6 = CFileMgr::OpenFile(gString, "rb");
        if ( v6 )
        {
          CFileMgr::CloseFile(v6);
          v7 = 1;
        }
        else
        {
          v7 = 0;
          v17 = CGame::bMissionPackGame;
          if ( CGame::bMissionPackGame )
            goto LABEL_32;
        }
      }
      else
      {
        v7 = 1;
      }
      v18 = C_PcSave::SaveSlot(&PcSaveHelper, gMobileMenu.SelectedSlot, SaveGameFromMenu);
      C_PcSave::PopulateSlotInfo(&PcSaveHelper);
      v17 = CGame::bMissionPackGame;
      if ( v18 )
      {
LABEL_34:
        v19 = this->CurrentScreen;
        this->DisplayWarningScreenForUnboundControls = 0;
        this->PreviousScreen = v19;
        CMenuManager::ResetHelperText(this);
        v20 = (unsigned __int8)this->CurrentScreen;
        if ( v7 || !v17 )
        {
          if ( v20 == 4 )
          {
            v24 = this->m_PrefsResolution;
            this->m_PrefsAntiAliasingDisp = this->m_PrefsAntiAliasing;
            this->m_PrefsResolutionDisp = v24;
          }
          this->CurrentScreen = 21;
          this->CurrentOption = 0;
          byte_6AC730 = 16;
          strncpy(&aScreens[226 * this->CurrentScreen], "FET_SG", 8u);
          v22 = this->CurrentScreen;
          v23 = 723447;
        }
        else
        {
          if ( v20 == 4 )
          {
            v21 = this->m_PrefsResolution;
            this->m_PrefsAntiAliasingDisp = this->m_PrefsAntiAliasing;
            this->m_PrefsResolutionDisp = v21;
          }
          this->CurrentScreen = 21;
          this->CurrentOption = 0;
          byte_6AC730 = 16;
          strncpy(&aScreens[226 * this->CurrentScreen], "FET_SG", 8u);
          v22 = this->CurrentScreen;
          v23 = 525826;
        }
        v25 = &aScreens[226 * v22];
        *(_DWORD *)(v25 + 15) = (char *)&loc_45434C + v23;
        *(_DWORD *)(v25 + 11) = 1599292742;
        v8 = &CMenuManager::ProcessFileActions(void)::CurrentlySaving;
        goto LABEL_46;
      }
LABEL_32:
      if ( v7 || (v7 = 0, !v17) )
      {
        v26 = this->CurrentScreen;
        this->DisplayWarningScreenForUnboundControls = 0;
        this->PreviousScreen = v26;
        CMenuManager::ResetHelperText(this);
        if ( this->CurrentScreen == 4 )
        {
          v27 = this->m_PrefsResolution;
          this->m_PrefsAntiAliasingDisp = this->m_PrefsAntiAliasing;
          this->m_PrefsResolutionDisp = v27;
        }
        this->CurrentScreen = 19;
        this->CurrentOption = 0;
        v8 = &CMenuManager::ProcessFileActions(void)::CurrentlySaving;
        goto LABEL_46;
      }
      goto LABEL_34;
    case 14:
      if ( CMenuManager::ProcessFileActions(void)::CurrentlyDeleting )
      {
        if ( C_PcSave::DeleteSlot(&PcSaveHelper, gMobileMenu.SelectedSlot) )
        {
          C_PcSave::PopulateSlotInfo(&PcSaveHelper);
          v3 = this->CurrentScreen;
          this->DisplayWarningScreenForUnboundControls = 0;
          this->PreviousScreen = v3;
          CMenuManager::ResetHelperText(this);
          if ( this->CurrentScreen == 4 )
          {
            v4 = this->m_PrefsResolution;
            this->m_PrefsAntiAliasingDisp = this->m_PrefsAntiAliasing;
            this->m_PrefsResolutionDisp = v4;
          }
          this->CurrentOption = 1;
          this->CurrentScreen = 15;
        }
        else
        {
          v13 = this->CurrentScreen;
          this->DisplayWarningScreenForUnboundControls = 0;
          this->PreviousScreen = v13;
          CMenuManager::ResetHelperText(this);
          if ( this->CurrentScreen == 4 )
          {
            v14 = this->m_PrefsResolution;
            this->m_PrefsAntiAliasingDisp = this->m_PrefsAntiAliasing;
            this->m_PrefsResolutionDisp = v14;
          }
          this->CurrentScreen = 20;
          this->CurrentOption = 0;
          byte_6AC64E = 1;
          v15 = &aScreens[226 * this->CurrentScreen];
          *(_DWORD *)v15 = 1599292742;
          *((_DWORD *)v15 + 1) = &off_4C4544;
          v16 = &aScreens[226 * this->CurrentScreen];
          *(_DWORD *)(v16 + 15) = &loc_454544;
          *(_DWORD *)(v16 + 11) = 1599292742;
        }
        v8 = &CMenuManager::ProcessFileActions(void)::CurrentlyDeleting;
LABEL_46:
        v9 = 0;
        goto LABEL_47;
      }
      v8 = &CMenuManager::ProcessFileActions(void)::CurrentlyDeleting;
LABEL_18:
      v9 = 1;
LABEL_47:
      *v8 = v9;
      break;
  }
}
// 4C4544: using guessed type float **off_4C4544;
// 6AC64E: using guessed type char byte_6AC64E;
// 6AC730: using guessed type char byte_6AC730;
// 990BF8: using guessed type char CMenuManager::ProcessFileActions(void)::CurrentlyDeleting;
// 990BF9: using guessed type char CMenuManager::ProcessFileActions(void)::CurrentlySaving;

//----- (00431FAC) --------------------------------------------------------
void __fastcall CMenuManager::ProcessUserInput(
        CMenuManager *this,
        int GoDownMenu,
        int GoUpMenu,
        int EnterMenuOption,
        bool8 GoBackOneMenu,
        int LeftRight)
{
  unsigned int NumberOfMenuOptions; // r0
  int CurrentScreen; // r1
  Int32 CurrentOption; // r0
  Int32 v13; // r0
  unsigned int v14; // r0
  __int16 v15; // r1
  int v16; // r3
  int v17; // r0
  int v18; // r2
  Int32 v19; // r0
  char *v20; // r1
  int v21; // t1
  char *v22; // r2
  int v23; // r3
  Int32 v24; // r0
  char *v25; // r1
  int v26; // t1
  bool8 v27[25]; // [sp+7h] [bp-19h] BYREF

  v27[0] = GoBackOneMenu;
  if ( this->CurrentScreen != 44 && !CMenuManager::CheckRedefineControlInput(this) )
  {
    NumberOfMenuOptions = CMenuManager::GetNumberOfMenuOptions(this);
    if ( GoDownMenu && NumberOfMenuOptions >= 2 )
    {
      CurrentScreen = (unsigned __int8)this->CurrentScreen;
      CurrentOption = this->CurrentOption;
      if ( CurrentScreen != 5 )
        goto LABEL_8;
      LOBYTE(CurrentScreen) = 5;
      while ( aScreens[226 * (char)CurrentScreen + 10 + 18 * CurrentOption] == 20 )
LABEL_8:
        this->CurrentOption = ++CurrentOption;
      if ( CurrentOption > 11 || !aScreens[226 * (char)CurrentScreen + 10 + 18 * CurrentOption] )
      {
        v13 = (unsigned __int8)aScreens[226 * (char)CurrentScreen + 10];
        if ( v13 != 1 )
          v13 = 0;
        this->CurrentOption = v13;
      }
    }
    v14 = CMenuManager::GetNumberOfMenuOptions(this);
    if ( GoUpMenu && v14 >= 2 )
    {
      v15 = this->CurrentScreen;
      v16 = (unsigned __int8)aScreens[226 * this->CurrentScreen + 10];
      v17 = this->CurrentOption;
      if ( v16 != 1 )
        v16 = 0;
      if ( v17 <= v16 )
      {
        if ( v17 <= 10 )
        {
          v22 = &aScreens[226 * this->CurrentScreen + 28 + 18 * v17];
          do
          {
            if ( !*v22 )
              break;
            ++v17;
            v22 += 18;
            this->CurrentOption = v17;
          }
          while ( v17 - 1 < 10 );
        }
        v23 = 9 * v17;
        if ( aScreens[226 * v15 + 10 + 18 * v17] == 20 )
        {
          v24 = v17 - 1;
          v25 = &aScreens[226 * v15 - 8 + 2 * v23];
          do
          {
            this->CurrentOption = v24--;
            v26 = (unsigned __int8)*v25;
            v25 -= 18;
          }
          while ( v26 == 20 );
        }
      }
      else
      {
        v18 = 9 * v17;
        v19 = v17 - 1;
        v20 = &aScreens[226 * this->CurrentScreen - 8 + 2 * v18];
        do
        {
          this->CurrentOption = v19--;
          v21 = (unsigned __int8)*v20;
          v20 -= 18;
        }
        while ( v21 == 20 );
      }
    }
    if ( EnterMenuOption )
    {
      if ( this->CurrentScreen == 39 )
      {
        *(_WORD *)&this->m_bJustEnteredOption = 257;
        this->MouseInBounds = 16;
        this->pControlEdit = &this->m_KeyPressedCode;
      }
      CMenuManager::ProcessMenuOptions(this, 0, v27, EnterMenuOption);
    }
    if ( LeftRight )
    {
      if ( aScreens[226 * this->CurrentScreen + 19 + 18 * this->CurrentOption] == 15 )
      {
        CMenuManager::ProcessMenuOptions(this, LeftRight, v27, 0);
        CMenuManager::CheckSliderMovement(this, LeftRight);
      }
    }
  }
}

//----- (00432184) --------------------------------------------------------
uint8 __fastcall CMenuManager::GetNumberOfMenuOptions(CMenuManager *this)
{
  int32 CurrentScreen; // r1
  uint8 result; // r0
  bool v3; // zf
  char *v4; // r3
  int v5; // r2
  bool v6; // zf
  int v7; // r3
  bool v8; // zf
  int v9; // r2
  bool v10; // zf
  int v11; // r2
  bool v12; // zf
  int v13; // r2
  bool v14; // zf
  int v15; // r2
  bool v16; // zf
  int v17; // r2
  bool v18; // zf
  int v19; // r2
  bool v20; // zf
  int v21; // r2
  bool v22; // zf
  int v23; // r2
  bool v24; // zf
  int v25; // r2
  bool v26; // zf
  unsigned int v27; // r2

  CurrentScreen = (unsigned __int8)this->CurrentScreen;
  result = 2;
  v3 = CurrentScreen == 2;
  if ( CurrentScreen != 2 )
    v3 = CurrentScreen == 5;
  if ( !v3 )
  {
    CurrentScreen = (char)CurrentScreen;
    if ( CMenuManager::GetNumberOfMenuOptions(void)::oldCurrentScreen == (char)CurrentScreen )
      return CMenuManager::GetNumberOfMenuOptions(void)::num_options;
    v4 = &aScreens[226 * (__int16)CurrentScreen];
    result = 0;
    CMenuManager::GetNumberOfMenuOptions(void)::num_options = 0;
    v5 = (unsigned __int8)v4[10];
    if ( !v4[10] )
      goto LABEL_64;
    v6 = v5 == 1;
    if ( v5 != 1 )
      v6 = v5 == 20;
    if ( !v6 )
    {
      result = 1;
      CMenuManager::GetNumberOfMenuOptions(void)::num_options = 1;
    }
    v7 = (unsigned __int8)aScreens[226 * (__int16)CurrentScreen + 28];
    v8 = v7 == 20;
    if ( v7 != 20 )
      v8 = v7 == 1;
    if ( !v8 )
    {
      if ( !aScreens[226 * (__int16)CurrentScreen + 28] )
      {
LABEL_64:
        CMenuManager::GetNumberOfMenuOptions(void)::oldCurrentScreen = CurrentScreen;
        return result;
      }
      CMenuManager::GetNumberOfMenuOptions(void)::num_options = ++result;
    }
    v9 = (unsigned __int8)aScreens[226 * (__int16)CurrentScreen + 46];
    if ( aScreens[226 * (__int16)CurrentScreen + 46] )
    {
      v10 = v9 == 1;
      if ( v9 != 1 )
        v10 = v9 == 20;
      if ( !v10 )
        CMenuManager::GetNumberOfMenuOptions(void)::num_options = ++result;
      v11 = (unsigned __int8)aScreens[226 * (__int16)CurrentScreen + 64];
      if ( aScreens[226 * (__int16)CurrentScreen + 64] )
      {
        v12 = v11 == 1;
        if ( v11 != 1 )
          v12 = v11 == 20;
        if ( !v12 )
          CMenuManager::GetNumberOfMenuOptions(void)::num_options = ++result;
        v13 = (unsigned __int8)aScreens[226 * (__int16)CurrentScreen + 82];
        if ( aScreens[226 * (__int16)CurrentScreen + 82] )
        {
          v14 = v13 == 1;
          if ( v13 != 1 )
            v14 = v13 == 20;
          if ( !v14 )
            CMenuManager::GetNumberOfMenuOptions(void)::num_options = ++result;
          v15 = (unsigned __int8)aScreens[226 * (__int16)CurrentScreen + 100];
          if ( aScreens[226 * (__int16)CurrentScreen + 100] )
          {
            v16 = v15 == 1;
            if ( v15 != 1 )
              v16 = v15 == 20;
            if ( !v16 )
              CMenuManager::GetNumberOfMenuOptions(void)::num_options = ++result;
            v17 = (unsigned __int8)aScreens[226 * (__int16)CurrentScreen + 118];
            if ( aScreens[226 * (__int16)CurrentScreen + 118] )
            {
              v18 = v17 == 1;
              if ( v17 != 1 )
                v18 = v17 == 20;
              if ( !v18 )
                CMenuManager::GetNumberOfMenuOptions(void)::num_options = ++result;
              v19 = (unsigned __int8)aScreens[226 * (__int16)CurrentScreen + 136];
              if ( aScreens[226 * (__int16)CurrentScreen + 136] )
              {
                v20 = v19 == 1;
                if ( v19 != 1 )
                  v20 = v19 == 20;
                if ( !v20 )
                  CMenuManager::GetNumberOfMenuOptions(void)::num_options = ++result;
                v21 = (unsigned __int8)aScreens[226 * (__int16)CurrentScreen + 154];
                if ( aScreens[226 * (__int16)CurrentScreen + 154] )
                {
                  v22 = v21 == 1;
                  if ( v21 != 1 )
                    v22 = v21 == 20;
                  if ( !v22 )
                    CMenuManager::GetNumberOfMenuOptions(void)::num_options = ++result;
                  v23 = (unsigned __int8)aScreens[226 * (__int16)CurrentScreen + 172];
                  if ( aScreens[226 * (__int16)CurrentScreen + 172] )
                  {
                    v24 = v23 == 1;
                    if ( v23 != 1 )
                      v24 = v23 == 20;
                    if ( !v24 )
                      CMenuManager::GetNumberOfMenuOptions(void)::num_options = ++result;
                    v25 = (unsigned __int8)aScreens[226 * (__int16)CurrentScreen + 190];
                    if ( aScreens[226 * (__int16)CurrentScreen + 190] )
                    {
                      v26 = v25 == 1;
                      if ( v25 != 1 )
                        v26 = v25 == 20;
                      if ( !v26 )
                        CMenuManager::GetNumberOfMenuOptions(void)::num_options = ++result;
                      v27 = (unsigned __int8)aScreens[226 * (__int16)CurrentScreen + 208];
                      if ( v27 > 0x14 || ((1 << v27) & 0x100003) == 0 )
                        CMenuManager::GetNumberOfMenuOptions(void)::num_options = ++result;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    goto LABEL_64;
  }
  return result;
}

//----- (004323E4) --------------------------------------------------------
void __fastcall CMenuManager::ProcessMenuOptions(
        CMenuManager *this,
        int8 LeftRight,
        bool8 *GoBackOneMenu,
        bool8 EnterMenuOption)
{
  int v7; // r5
  Int32 v8; // r3
  float v9; // s0
  int CurrentScreen; // r2
  Int32 CurrentOption; // r1
  Int8 v12; // r12
  uint8 v13; // r0
  RwInt32 m_PrefsResolution; // r1
  int m_MainMenu; // r0
  bool v16; // r1
  int8 v17; // r0
  char v18; // r2
  int m_PrefsLanguage; // r1
  int v20; // r3
  int v21; // r3
  RwInt32 v22; // r1
  int v23; // r0
  Int8 v24; // r1
  int v25; // r2
  RwInt32 v26; // r1
  Int8 v27; // r0
  bool v28; // r1
  int v29; // r0
  RwInt32 v30; // r1

  v7 = LeftRight;
  if ( !this->DisplayTheMouse
    || ((v8 = *(__int16 *)&aScreens[226 * this->CurrentScreen + 24 + 18 * this->CurrentOption],
         RsGlobal.screenHeight != 448) ? (v9 = (float)((float)(v8 + 25) / 448.0) * (float)RsGlobal.screenHeight,
                                          v8 = (int)(float)((float)((float)(__int16)v8 / 448.0)
                                                          * (float)RsGlobal.screenHeight)) : (v9 = (float)(v8 + 25)),
        CMenuManager::CheckHover(this, 0, (int)(float)RsGlobal.screenWidth, v8, (int)v9)) )
  {
    if ( !CMenuManager::ProcessPCMenuOptions(this, v7, EnterMenuOption) )
    {
      CurrentScreen = this->CurrentScreen;
      CurrentOption = this->CurrentOption;
      v12 = this->CurrentScreen;
      switch ( aScreens[226 * CurrentScreen + 10 + 18 * CurrentOption] )
      {
        case 2:
          *GoBackOneMenu = 1;
          return;
        case 3:
        case 4:
        case 5:
          CMenuManager::SwitchToNewScreen(this, aScreens[226 * this->CurrentScreen + 20 + 18 * CurrentOption]);
          return;
        case 10:
          sub_1A0660(this);
          return;
        case 11:
          v13 = *((_BYTE *)this + 261 * CurrentOption - 230);
          this->DisplayWarningScreenForUnboundControls = 0;
          this->PreviousScreen = v12;
          this->CurrentSelectedMissionPack = v13;
          CMenuManager::ResetHelperText(this);
          if ( this->CurrentScreen == 4 )
          {
            m_PrefsResolution = this->m_PrefsResolution;
            this->m_PrefsAntiAliasingDisp = this->m_PrefsAntiAliasing;
            this->m_PrefsResolutionDisp = m_PrefsResolution;
          }
          this->CurrentScreen = 8;
          m_MainMenu = this->m_MainMenu;
          this->CurrentOption = 0;
          if ( m_MainMenu )
            goto LABEL_30;
          return;
        case 12:
LABEL_30:
          CGame::bMissionPackGame = this->CurrentSelectedMissionPack;
          return;
        case 13:
          if ( (unsigned __int8)(aScreens[226 * (__int16)CurrentScreen + 19 + 18 * CurrentOption] - 1) <= 9u )
          {
            v21 = CurrentOption - 2;
            if ( CurrentOption == 1 )
              v21 = 8;
            gMobileMenu.SelectedSlot = v21;
            if ( CurrentScreen == 10 )
            {
              if ( CGenericGameStorage::ms_Slots[v21] != 1 )
              {
                this->DisplayWarningScreenForUnboundControls = 0;
                this->PreviousScreen = v12;
                CMenuManager::ResetHelperText(this);
                if ( this->CurrentScreen == 4 )
                {
                  v30 = this->m_PrefsResolution;
                  this->m_PrefsAntiAliasingDisp = this->m_PrefsAntiAliasing;
                  this->m_PrefsResolutionDisp = v30;
                }
                v27 = 12;
                goto LABEL_49;
              }
            }
            else if ( CurrentScreen == 9 && (unsigned int)(CGenericGameStorage::ms_Slots[v21] - 1) >= 2 )
            {
              this->DisplayWarningScreenForUnboundControls = 0;
              this->PreviousScreen = v12;
              CMenuManager::ResetHelperText(this);
              if ( this->CurrentScreen == 4 )
              {
                v22 = this->m_PrefsResolution;
                this->m_PrefsAntiAliasingDisp = this->m_PrefsAntiAliasing;
                this->m_PrefsResolutionDisp = v22;
              }
              v23 = this->m_MainMenu;
              v24 = 13;
              this->CurrentOption = 0;
              if ( !v23 )
                v24 = 11;
              this->CurrentScreen = v24;
            }
          }
          return;
        case 14:
          CGame::bMissionPackGame = 0;
          return;
        case 18:
          if ( (unsigned __int8)(aScreens[226 * (__int16)CurrentScreen + 19 + 18 * CurrentOption] - 1) <= 9u )
          {
            v25 = CurrentOption - 2;
            if ( CurrentOption == 1 )
              v25 = 8;
            gMobileMenu.SelectedSlot = v25;
            this->DisplayWarningScreenForUnboundControls = 0;
            this->PreviousScreen = v12;
            CMenuManager::ResetHelperText(this);
            if ( this->CurrentScreen == 4 )
            {
              v26 = this->m_PrefsResolution;
              this->m_PrefsAntiAliasingDisp = this->m_PrefsAntiAliasing;
              this->m_PrefsResolutionDisp = v26;
            }
            v27 = 17;
LABEL_49:
            this->CurrentScreen = v27;
            this->CurrentOption = 0;
          }
          return;
        case 23:
          this->m_DisplayControllerOnFoot = this->m_DisplayControllerOnFoot == 0;
          return;
        case 25:
          this->m_PrefsShowSubtitles = this->m_PrefsShowSubtitles == 0;
          goto LABEL_60;
        case 26:
          this->m_PrefsUseWideScreen = this->m_PrefsUseWideScreen == 0;
          goto LABEL_60;
        case 30:
          v16 = this->m_PrefsUseBass == 0;
          this->m_PrefsUseBass = v16;
          CAudioEngine::SetBassEnhanceOnOff(&AudioEngine, v16);
          goto LABEL_60;
        case 31:
          v28 = this->m_PrefsAutoRetune == 0;
          this->m_PrefsAutoRetune = v28;
          CAudioEngine::SetRadioAutoRetuneOnOff(&AudioEngine, v28);
          goto LABEL_60;
        case 32:
          if ( !this->m_PrefsRadioStation || CAudioEngine::IsCutsceneTrackActive(&AudioEngine) )
            return;
          v29 = (unsigned __int8)this->m_PrefsRadioStation + (unsigned __int8)v7;
          if ( v29 << 24 < 0x1000000 )
            LOBYTE(v29) = 13;
          if ( (char)v29 > 13 )
            LOBYTE(v29) = 1;
          this->m_PrefsRadioStation = v29;
LABEL_60:
          sub_18B0E0(this);
          break;
        case 33:
          this->m_PrefsShowLegend = this->m_PrefsShowLegend == 0;
          return;
        case 35:
          this->m_PrefsDisplayHud = this->m_PrefsDisplayHud == 0;
          goto LABEL_60;
        case 36:
          this->m_previousLanguage = -99;
          this->bFrontEnd_ReloadObrTxtGxt = 1;
          v17 = 4;
          v18 = -1;
          if ( v7 > 0 )
            v17 = 0;
          m_PrefsLanguage = (unsigned __int8)this->m_PrefsLanguage;
          if ( v7 > 0 )
            v18 = 1;
          v20 = 0;
          if ( v7 > 0 )
            v20 = 4;
          if ( m_PrefsLanguage != v20 )
            v17 = m_PrefsLanguage + v18;
          this->m_PrefsLanguage = v17;
          CMenuManager::InitialiseChangedLanguageSettings(this, 0);
          goto LABEL_60;
        case 70:
          this->m_PrefsMarketing = this->m_PrefsMarketing == 0;
          return;
        default:
          return;
      }
    }
  }
}

//----- (004328A4) --------------------------------------------------------
void __fastcall CMenuManager::CheckSliderMovement(CMenuManager *this, int8 LeftRight)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d2
  float32x2_t v5; // d3
  int8 v7; // r1
  int *v8; // r2
  float *v9; // r0
  unsigned __int32 v10; // s0
  int8 v11; // r1

  switch ( aScreens[226 * this->CurrentScreen + 10 + 18 * this->CurrentOption] )
  {
    case 28:
      v7 = this->m_PrefsMusicVolume + 4 * LeftRight;
      if ( (v7 & 0x80) != 0 )
        v7 = 0;
      if ( v7 >= 64 )
        v7 = 64;
      this->m_PrefsMusicVolume = v7;
      CAudioEngine::SetMusicMasterVolume(&AudioEngine, v7);
      goto LABEL_17;
    case 29:
      v11 = this->m_PrefsSfxVolume + 4 * LeftRight;
      if ( (v11 & 0x80) != 0 )
        v11 = 0;
      if ( v11 >= 64 )
        v11 = 64;
      this->m_PrefsSfxVolume = v11;
      CAudioEngine::SetEffectsMasterVolume(&AudioEngine, v11);
      goto LABEL_17;
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
      return;
    case 64:
      v8 = dword_4329D4;
      if ( LeftRight > 0 )
        v8 = &dword_4329D4[1];
      v4.n64_u32[0] = 1.75;
      v5.n64_u32[0] = 0.875;
      v2.n64_f32[0] = *(float *)v8 + this->m_PrefsLOD;
      v9 = &CRenderer::ms_lodDistScale;
      v10 = vmax_f32(vmin_f32(v2, v4), v5).n64_u32[0];
      LODWORD(this->m_PrefsLOD) = v10;
      goto LABEL_16;
    case 65:
      v3.n64_u32[0] = 1000593162;
      v5.n64_u32[0] = 967038730;
      v9 = &CCamera::m_fMouseAccelHorzntl;
      v2.n64_f32[0] = (float)((float)((float)LeftRight * 0.005) / 15.0) + CCamera::m_fMouseAccelHorzntl;
      v10 = vmin_f32(vmax_f32(v2, v5), v3).n64_u32[0];
LABEL_16:
      *(_DWORD *)v9 = v10;
LABEL_17:
      sub_18B0E0(this);
      return;
  }
}
// 432944: variable 'v2' is possibly undefined
// 432944: variable 'v4' is possibly undefined
// 432948: variable 'v5' is possibly undefined
// 4329AA: variable 'v3' is possibly undefined
// 4329D4: using guessed type int dword_4329D4[2];

//----- (004329E8) --------------------------------------------------------
void __fastcall CMenuManager::ScrollRadioStations(CMenuManager *this, Int8 direction)
{
  int v4; // r0

  if ( this->m_PrefsRadioStation && !CAudioEngine::IsCutsceneTrackActive(&AudioEngine) )
  {
    v4 = (unsigned __int8)this->m_PrefsRadioStation + (unsigned __int8)direction;
    if ( v4 << 24 < 0x1000000 )
      LOBYTE(v4) = 13;
    if ( (char)v4 > 13 )
      LOBYTE(v4) = 1;
    this->m_PrefsRadioStation = v4;
    sub_18B0E0(this);
  }
}

//----- (00432A34) --------------------------------------------------------
bool8 __fastcall CMenuManager::CheckFrontEndUpInput(CMenuManager *this)
{
  bool8 v2; // r4
  CPad *Pad; // r0

  CPad::GetPad(0);
  if ( LIB_KeyboardPressed(KK_ARROWUP) )
    return 1;
  v2 = 0;
  Pad = CPad::GetPad(0);
  if ( Pad->NewState.DPadUp )
  {
    if ( !Pad->OldState.DPadUp )
      return 1;
  }
  return v2;
}

//----- (00432A68) --------------------------------------------------------
bool8 __fastcall CMenuManager::CheckFrontEndDownInput(CMenuManager *this)
{
  bool8 v2; // r4
  CPad *Pad; // r0

  CPad::GetPad(0);
  if ( LIB_KeyboardPressed(KK_ARROWDOWN) )
    return 1;
  v2 = 0;
  Pad = CPad::GetPad(0);
  if ( Pad->NewState.DPadDown )
  {
    if ( !Pad->OldState.DPadDown )
      return 1;
  }
  return v2;
}

//----- (00432A9C) --------------------------------------------------------
bool8 __fastcall CMenuManager::CheckFrontEndLeftInput(CMenuManager *this)
{
  bool8 v2; // r4
  CPad *Pad; // r0

  CPad::GetPad(0);
  if ( LIB_KeyboardPressed(KK_ARROWLEFT) )
    return 1;
  v2 = 0;
  Pad = CPad::GetPad(0);
  if ( Pad->NewState.DPadLeft )
  {
    if ( !Pad->OldState.DPadLeft )
      return 1;
  }
  return v2;
}

//----- (00432AD0) --------------------------------------------------------
bool8 __fastcall CMenuManager::CheckFrontEndRightInput(CMenuManager *this)
{
  bool8 v2; // r4
  CPad *Pad; // r0

  CPad::GetPad(0);
  if ( LIB_KeyboardPressed(KK_ARROWRIGHT) )
    return 1;
  v2 = 0;
  Pad = CPad::GetPad(0);
  if ( Pad->NewState.DPadRight )
  {
    if ( !Pad->OldState.DPadRight )
      return 1;
  }
  return v2;
}

//----- (00432B04) --------------------------------------------------------
void __fastcall CMenuManager::AdditionalOptionInput(CMenuManager *this, bool8 *pGoUpMenu, bool8 *pGoDownMenu)
{
  unsigned int BriefDisplay; // r0
  CPad *Pad; // r0
  unsigned int v8; // r0
  CPad *v9; // r0

  if ( this->CurrentScreen == 2 )
  {
    CPad::GetPad(0);
    if ( LIB_KeyboardPressed(KK_ARROWUP) || (Pad = CPad::GetPad(0), Pad->NewState.DPadUp) && !Pad->OldState.DPadUp )
    {
      BriefDisplay = this->BriefDisplay;
      if ( BriefDisplay <= 0x12 )
      {
        if ( CMessages::PreviousBriefs[BriefDisplay + 1].pMessage )
        {
          this->BriefDisplay = BriefDisplay + 1;
          *pGoUpMenu = 1;
        }
      }
    }
    CPad::GetPad(0);
    if ( LIB_KeyboardPressed(KK_ARROWDOWN) || (v9 = CPad::GetPad(0), v9->NewState.DPadDown) && !v9->OldState.DPadDown )
    {
      v8 = this->BriefDisplay;
      if ( v8 >= 4 )
      {
        this->BriefDisplay = v8 - 1;
        *pGoDownMenu = 1;
      }
    }
  }
}

//----- (00432B9C) --------------------------------------------------------
bool8 __fastcall CMenuManager::HasLanguageChanged(CMenuManager *this)
{
  int m_PrefsLanguage; // r1

  m_PrefsLanguage = (unsigned __int8)this->m_PrefsLanguage;
  if ( (unsigned __int8)this->m_previousLanguage == m_PrefsLanguage )
    return 0;
  *((_BYTE *)&dword_48 + (_DWORD)this + 1) = m_PrefsLanguage;
  return 1;
}
// 48: using guessed type int dword_48;

//----- (00432BB4) --------------------------------------------------------
void __fastcall CMenuManager::DrawWindow(
        CMenuManager *this,
        const CRect *Rectangle,
        unsigned __int8 *Header,
        uint8 FadedAmount,
        CRGBA colour,
        uint8 swirls,
        int background)
{
  float32x2_t v7; // d3
  float32x2_t v8; // d4
  bool v12; // zf
  CRGBA v13; // r0
  CRGBA v14; // r0
  float v15; // s2
  float v16; // s18
  GxtChar *v17; // r0
  CRGBA v18; // [sp+8h] [bp-28h] BYREF
  CRGBA v19; // [sp+Ch] [bp-24h] BYREF

  if ( background )
    CSprite2d::DrawRect(Rectangle, *(const CRGBA **)&colour);
  v12 = Header == 0;
  if ( Header )
    v12 = *Header == 0;
  if ( !v12 )
  {
    CFont::SetWrapx(Rectangle->right);
    CRGBA::CRGBA(&v19, -31 - FadedAmount, -31 - FadedAmount, -31 - FadedAmount, 0xFFu);
    CFont::SetColor(v13);
    CRGBA::CRGBA(&v18, 0, 0, 0, 0xFFu);
    CFont::SetDropColor(v14);
    CFont::SetEdge(2);
    CFont::SetOrientation(1u);
    CFont::SetFontStyle(0);
    CFont::SetScale((float)((float)RsGlobal.screenHeight / 448.0) * 1.4);
    CFont::SetProportional(1u);
    v8.n64_u32[0] = LODWORD(Rectangle->bottom);
    v7.n64_u32[0] = LODWORD(Rectangle->top);
    v15 = (float)((float)RsGlobal.screenHeight / 448.0) * -16.0;
    v16 = Rectangle->left + (float)((float)((float)RsGlobal.screenWidth / 640.0) * 10.0);
    v17 = CText::Get(&TheText, Header);
    CFont::PrintString(v16, vmin_f32(v8, v7).n64_f32[0] + v15, v17);
  }
}
// 432BFE: variable 'v13' is possibly undefined
// 432C12: variable 'v14' is possibly undefined
// 432C8E: variable 'v8' is possibly undefined
// 432C8E: variable 'v7' is possibly undefined

//----- (00432CD4) --------------------------------------------------------
void __fastcall CMenuManager::DrawWindowedText(
        CMenuManager *this,
        float x,
        float y,
        float width,
        unsigned __int8 *Header,
        unsigned __int8 *Body,
        uint8 align)
{
  float v10; // s22
  float v12; // s24
  float v13; // s0
  GxtChar *v14; // r0
  float v15; // s0
  CRGBA v16; // r0
  CRGBA v17; // r0
  bool v18; // zf
  float v19; // s21
  float v20; // s19
  GxtChar *v21; // r0
  bool v22; // zf
  float v23; // s0
  CRGBA v24; // r0
  float v25; // s0
  GxtChar *v26; // r0
  CRGBA v27; // [sp+4h] [bp-84h] BYREF
  CRGBA v28; // [sp+8h] [bp-80h] BYREF
  CRGBA v29; // [sp+Ch] [bp-7Ch] BYREF
  CRGBA v30; // [sp+10h] [bp-78h] BYREF
  CRGBA v31; // [sp+14h] [bp-74h] BYREF
  CRect pRect; // [sp+18h] [bp-70h] BYREF

  v10 = x + width;
  pRect.bottom = 1000000.0;
  pRect.left = 1000000.0;
  pRect.top = -1000000.0;
  pRect.right = -1000000.0;
  CFont::SetWrapx((float)(x + width) - (float)((float)((float)RsGlobal.screenWidth / 640.0) * 10.0));
  v12 = x - width;
  CFont::SetRightJustifyWrap(v12 + (float)((float)((float)RsGlobal.screenWidth / 640.0) * 10.0));
  CFont::SetCentreSize(width + (float)((float)((float)((float)RsGlobal.screenWidth / 640.0) * 10.0) * -2.0));
  CFont::SetFontStyle(1u);
  CFont::SetOrientation(align);
  v13 = (float)RsGlobal.screenHeight * 0.0022321;
  if ( RsGlobal.screenHeight == 448 )
    v13 = 1.0;
  CFont::SetScale(v13);
  v14 = CText::Get(&TheText, Body);
  CFont::GetTextRect(&pRect, x, y, v14);
  v15 = (float)RsGlobal.screenHeight * 0.049107;
  if ( RsGlobal.screenHeight == 448 )
    v15 = 22.0;
  pRect.left = pRect.left + -4.0;
  pRect.bottom = pRect.bottom + v15;
  CRGBA::CRGBA(&v31, 0, 0, 0, 0xBEu);
  CSprite2d::DrawRect(&pRect, &v31);
  CRGBA::CRGBA(&v30, 0xE1u, 0xE1u, 0xE1u, 0xFFu);
  CFont::SetColor(v16);
  CRGBA::CRGBA(&v29, 0, 0, 0, 0xFFu);
  CFont::SetDropColor(v17);
  CFont::SetEdge(2);
  CFont::SetOrientation(1u);
  CFont::SetFontStyle(0);
  CFont::SetScale((float)((float)RsGlobal.screenHeight / 448.0) * 1.4);
  CFont::SetWrapx(pRect.right);
  v18 = Header == 0;
  if ( Header )
    v18 = *Header == 0;
  if ( !v18 )
  {
    v19 = pRect.top + (float)((float)((float)RsGlobal.screenHeight / -448.0) * 16.0);
    v20 = pRect.left + (float)((float)((float)RsGlobal.screenWidth / 640.0) * 20.0);
    v21 = CText::Get(&TheText, Header);
    CFont::PrintString(v20, v19, v21);
  }
  v22 = Body == 0;
  if ( Body )
    v22 = *Body == 0;
  if ( !v22 )
  {
    CFont::SetWrapx(v10 - (float)((float)((float)RsGlobal.screenWidth / 640.0) * 10.0));
    CFont::SetRightJustifyWrap(v12 + (float)((float)((float)RsGlobal.screenWidth / 640.0) * 10.0));
    CFont::SetCentreSize(width + (float)((float)((float)((float)RsGlobal.screenWidth / 640.0) * 10.0) * -2.0));
    CFont::SetFontStyle(1u);
    CFont::SetOrientation(align);
    v23 = (float)RsGlobal.screenHeight * 0.0022321;
    if ( RsGlobal.screenHeight == 448 )
      v23 = 1.0;
    CFont::SetScale(v23);
    CHudColours::GetRGBA(&v28, &HudColour, 3u);
    CFont::SetColor((CRGBA)&v28);
    CFont::SetDropShadowPosition(2);
    CRGBA::CRGBA(&v27, 0, 0, 0, 0xFFu);
    CFont::SetDropColor(v24);
    v25 = (float)((float)RsGlobal.screenHeight / 448.0) * 15.0;
    v26 = CText::Get(&TheText, Body);
    CFont::PrintString(x, v25 + y, v26);
  }
}
// 432E42: variable 'v16' is possibly undefined
// 432E54: variable 'v17' is possibly undefined
// 432FC6: variable 'v24' is possibly undefined

//----- (00433040) --------------------------------------------------------
void __fastcall CMenuManager::SmallMessageScreen(CMenuManager *this, const unsigned __int8 *pMsg)
{
  float v3; // s0
  float screenHeight; // s4
  float v5; // s0
  float v6; // s6
  float v7; // s8
  float v8; // s20
  float v9; // s22
  GxtChar *v10; // r0
  int NumberLines; // r0
  float v12; // s0
  float v13; // s2
  float v14; // s20
  int v15; // s20
  GxtChar *v16; // r5
  float v17; // s0
  CRGBA v18; // [sp+8h] [bp-48h] BYREF
  CRect Rectangle; // [sp+Ch] [bp-44h] BYREF
  CRGBA v20[13]; // [sp+1Ch] [bp-34h] BYREF

  CFont::SetBackground(0, 0);
  CFont::SetProportional(1u);
  CFont::SetFontStyle(1u);
  CFont::SetCentreSize((float)((float)RsGlobal.screenWidth / 640.0) * 430.0);
  CFont::SetOrientation(0);
  CHudColours::GetRGBA(v20, &HudColour, 5u);
  CFont::SetColor((CRGBA)v20);
  CFont::SetDropShadowPosition(0);
  v3 = (float)RsGlobal.screenHeight * 0.0022321;
  if ( RsGlobal.screenHeight == 448 )
    v3 = 1.0;
  CFont::SetScale(v3);
  screenHeight = (float)RsGlobal.screenHeight;
  v5 = (float)RsGlobal.screenWidth * 0.14844;
  if ( RsGlobal.screenWidth == 640 )
    v5 = 95.0;
  v6 = screenHeight * 0.3683;
  if ( RsGlobal.screenHeight == 448 )
    v6 = 165.0;
  v7 = screenHeight * 0.27902;
  if ( RsGlobal.screenHeight == 448 )
    v7 = 125.0;
  Rectangle.left = v5;
  Rectangle.bottom = v7;
  Rectangle.right = (float)RsGlobal.screenWidth - v5;
  Rectangle.top = screenHeight - v6;
  CRGBA::CRGBA(&v18, 0, 0, 0, 0xFFu);
  CSprite2d::DrawRect(&Rectangle, &v18);
  v8 = (float)RsGlobal.screenWidth * 0.5;
  if ( RsGlobal.screenWidth == 640 )
    v8 = 320.0;
  v9 = (float)RsGlobal.screenHeight * 0.30134;
  if ( RsGlobal.screenHeight == 448 )
    v9 = 135.0;
  v10 = CText::Get(&TheText, pMsg);
  NumberLines = CFont::GetNumberLines(v8, v9, v10);
  if ( NumberLines < 2 )
  {
    if ( RsGlobal.screenHeight == 448 )
      v14 = 190.0;
    else
      v14 = (float)RsGlobal.screenHeight * 0.42411;
  }
  else
  {
    if ( RsGlobal.screenHeight == 448 )
    {
      v12 = 9.0;
      v13 = 200.0;
    }
    else
    {
      v12 = (float)RsGlobal.screenHeight * 0.020089;
      v13 = (float)RsGlobal.screenHeight * 0.44643;
    }
    v14 = v13 - (float)(v12 * (float)NumberLines);
  }
  v15 = (int)v14;
  v16 = CText::Get(&TheText, pMsg);
  if ( !TheText.bTextIsLoaded
    && (strcasecmp("NOCD", (const char *)pMsg)
     || strcasecmp("OPENCD", (const char *)pMsg)
     || strcasecmp("WRONGCD", (const char *)pMsg)
     || strcasecmp("CDERROR", (const char *)pMsg)) )
  {
    AsciiToGxtChar(TheText.LoadedCDErrorText, v16);
  }
  v17 = (float)RsGlobal.screenWidth * 0.5;
  if ( RsGlobal.screenWidth == 640 )
    v17 = 320.0;
  CFont::PrintString(v17, (float)v15, v16);
}
// 20: using guessed type int dword_20;

//----- (0043331C) --------------------------------------------------------
void __fastcall CMenuManager::UserInput(CMenuManager *this)
{
  Int32 DisplayWarningScreenForUnboundControls; // r1
  Int32 oldMousePosX; // r0
  bool v4; // zf
  Int32 MousePosX; // r2
  bool v6; // zf
  char *v7; // r6
  Int32 *p_CurrentMouseOption; // r9
  Int32 v9; // r0
  Int32 v10; // r5
  char *v11; // r0
  GxtChar *v12; // r0
  float MousePosY; // s16
  float v14; // s16
  Int32 oldMousePosY; // r1
  Int32 v16; // r0
  Int32 CurrentOption; // r0
  RwInt32 WinMousePosY; // r0
  RwInt32 WinMousePosX; // r1
  char v20; // r0
  Int32 v21; // r0
  bool v22; // zf
  Int32 v23; // r2
  bool v24; // zf
  int v25; // r0
  bool v26; // cf
  Int32 v27; // r0
  bool v28; // zf
  Int32 v29; // r4
  CPad *v30; // r0
  CPad *Pad; // r0
  unsigned int MouseInBounds; // r0
  int v33; // r0
  CMenuManager *v34; // r0
  int8 v35; // r1
  int v36; // r0
  bool v37; // cf
  tAudioEvent v38; // r1
  CPad *v39; // r0
  CPad *v40; // r0
  unsigned int v41; // r0
  uint32 v42; // r0
  unsigned int v43; // r1
  char v44; // r5
  UInt32 *v45; // r1
  CPad *v46; // r0
  CPad *v47; // r0
  unsigned int v48; // r1
  char v49; // r4
  CPad *v50; // r0
  CPad *v51; // r0
  bool8 GoBackOneMenu; // [sp+Ch] [bp-2Ch] BYREF
  bool8 EnterMenuOption; // [sp+Dh] [bp-2Bh] BYREF
  bool8 pGoUpMenu; // [sp+Eh] [bp-2Ah] BYREF
  bool8 pGoDownMenu[41]; // [sp+Fh] [bp-29h] BYREF

  if ( this->DisplayWarningScreenForUserTrackScanning )
    return;
  DisplayWarningScreenForUnboundControls = (unsigned __int8)this->DisplayWarningScreenForUnboundControls;
  if ( this->DisplayWarningScreenForUnboundControls )
    return;
  GoBackOneMenu = 0;
  EnterMenuOption = 0;
  pGoUpMenu = 0;
  pGoDownMenu[0] = 0;
  if ( !this->DisplayTheMouse )
  {
    oldMousePosX = this->oldMousePosX;
    v4 = oldMousePosX == 0;
    if ( oldMousePosX )
    {
      DisplayWarningScreenForUnboundControls = this->oldMousePosY;
      v4 = DisplayWarningScreenForUnboundControls == 0;
    }
    if ( !v4 )
    {
      MousePosX = this->MousePosX;
      v6 = oldMousePosX == MousePosX;
      if ( oldMousePosX == MousePosX )
        v6 = DisplayWarningScreenForUnboundControls == this->MousePosY;
      if ( !v6 )
        this->DisplayTheMouse = 1;
    }
  }
  v7 = aScreens;
  CMenuManager::UserInput(void)::oldOption = this->CurrentOption;
  p_CurrentMouseOption = &this->CurrentMouseOption;
  v9 = 0;
  while ( 1 )
  {
    v10 = v9;
    v11 = &v7[226 * this->CurrentScreen];
    if ( (unsigned __int8)v11[10] >= 2u )
      break;
LABEL_17:
    v7 += 18;
    v9 = v10 + 1;
    if ( v10 >= 11 )
      goto LABEL_18;
  }
  v12 = CText::Get(&TheText, (const unsigned __int8 *)v11 + 11);
  CFont::GetStringWidth(v12, 1u, 0);
  MousePosY = (float)this->MousePosY;
  if ( CMenuManager::StretchY(this, (float)*(__int16 *)&v7[226 * this->CurrentScreen + 24]) >= MousePosY
    || (v14 = (float)this->MousePosY,
        CMenuManager::StretchY(this, (float)(*(__int16 *)&v7[226 * this->CurrentScreen + 24] + 26)) <= v14) )
  {
    if ( this->DisplayTheMouse )
    {
      v16 = CMenuManager::UserInput(void)::oldOption;
      *p_CurrentMouseOption = CMenuManager::UserInput(void)::oldOption;
      this->CurrentOption = v16;
    }
    goto LABEL_17;
  }
  v20 = `guard variable for'CMenuManager::UserInput(void)::oldScreen;
  __dmb(0xBu);
  if ( (v20 & 1) == 0 && _cxa_guard_acquire((__guard *)&`guard variable for'CMenuManager::UserInput(void)::oldScreen) )
    _cxa_guard_release((__guard *)&`guard variable for'CMenuManager::UserInput(void)::oldScreen);
  *p_CurrentMouseOption = v10;
  v21 = this->oldMousePosX;
  v22 = v21 == 0;
  if ( v21 )
  {
    oldMousePosY = this->oldMousePosY;
    v22 = oldMousePosY == 0;
  }
  if ( !v22 )
  {
    v23 = this->MousePosX;
    v24 = v21 == v23;
    if ( v21 == v23 )
      v24 = oldMousePosY == this->MousePosY;
    if ( !v24 )
    {
      this->DisplayTheMouse = 1;
      this->CurrentOption = v10;
    }
  }
  v25 = (unsigned __int8)v7[226 * this->CurrentScreen + 10];
  v26 = (unsigned int)(v25 - 27) >= 3;
  if ( (unsigned int)(v25 - 27) >= 3 )
    v26 = (unsigned int)(v25 - 64) >= 2;
  if ( v26 )
    this->MouseInBounds = 2;
LABEL_18:
  if ( this->DisplayTheMouse )
  {
    CurrentOption = this->CurrentOption;
    if ( CurrentOption != CMenuManager::UserInput(void)::oldOption )
    {
      if ( aScreens[226 * this->CurrentScreen + 10 + 18 * CurrentOption] == 1 )
      {
        this->CurrentOption = CurrentOption + 1;
        ++*p_CurrentMouseOption;
      }
      CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 3, 0.0, 1.0);
    }
  }
  WinMousePosY = this->WinMousePosY;
  WinMousePosX = this->WinMousePosX;
  *(_QWORD *)&this->oldMousePosX = *(_QWORD *)&this->MousePosX;
  *(_QWORD *)&this->MousePosX = __PAIR64__(WinMousePosY, WinMousePosX);
  if ( WinMousePosX <= -1 )
  {
    WinMousePosX = 0;
    this->MousePosX = 0;
  }
  if ( WinMousePosX > RsGlobal.screenWidth )
    this->MousePosX = RsGlobal.screenWidth;
  if ( WinMousePosY <= -1 )
  {
    WinMousePosY = 0;
    this->MousePosY = 0;
  }
  if ( WinMousePosY > RsGlobal.screenHeight )
    this->MousePosY = RsGlobal.screenHeight;
  if ( this->CurrentScreen == 39 )
  {
    if ( !this->DisplayWarningScreenForUnboundControls )
      CMenuManager::RedefineScreenUserInput(this, &EnterMenuOption, &GoBackOneMenu);
    goto LABEL_99;
  }
  if ( CMenuManager::GetNumberOfMenuOptions(this) >= 2u )
  {
    CMenuManager::AdditionalOptionInput(this, &pGoUpMenu, pGoDownMenu);
    if ( CMenuManager::CheckFrontEndDownInput(this) )
    {
      this->DisplayTheMouse = 0;
      pGoDownMenu[0] = 1;
    }
    else if ( CMenuManager::CheckFrontEndUpInput(this) )
    {
      this->DisplayTheMouse = 0;
      pGoUpMenu = 1;
    }
  }
  v27 = this->CurrentOption;
  v28 = v27 == 0;
  if ( !v27 )
    v28 = this->CurrentScreen == 42;
  if ( v28 )
  {
    CPad::GetPad(0);
    if ( LIB_KeyboardState(KK_ENTER) == OSPS_ButtonReleased
      || (Pad = CPad::GetPad(0), !Pad->NewState.ButtonCross) && Pad->OldState.ButtonCross )
    {
LABEL_58:
      this->DisplayTheMouse = 0;
      EnterMenuOption = 1;
    }
  }
  else
  {
    CPad::GetPad(0);
    if ( LIB_KeyboardPressed(KK_ENTER) )
      goto LABEL_58;
    v30 = CPad::GetPad(0);
    if ( v30->NewState.ButtonCross )
    {
      if ( !v30->OldState.ButtonCross )
        goto LABEL_58;
    }
  }
  CPad::GetPad(0);
  if ( !CPad::NewMouseControllerState.m_bLeftButton
    && CPad::OldMouseControllerState.m_bLeftButton
    && this->MouseInBounds == 2 )
  {
    if ( this->CurrentScreen == 5 )
    {
      v29 = this->MousePosY;
      if ( CMenuManager::StretchY(this, 388.0) >= (float)v29 )
        goto LABEL_74;
LABEL_73:
      EnterMenuOption = 1;
    }
    else if ( this->DisplayTheMouse )
    {
      goto LABEL_73;
    }
  }
LABEL_74:
  CPad::GetPad(0);
  if ( CPad::NewMouseControllerState.m_bLeftButton )
  {
    MouseInBounds = this->MouseInBounds;
    if ( MouseInBounds <= 0xF )
    {
      v33 = 1 << MouseInBounds;
      if ( (v33 & 0x5540) != 0 )
      {
        v34 = this;
        v35 = 1;
LABEL_80:
        CMenuManager::CheckSliderMovement(v34, v35);
      }
      else if ( (v33 & 0xAA80) != 0 )
      {
        v34 = this;
        v35 = -1;
        goto LABEL_80;
      }
    }
  }
  CPad::GetPad(0);
  if ( CPad::NewMouseControllerState.m_bLeftButton && !CPad::OldMouseControllerState.m_bLeftButton
    || (CPad::GetPad(0), LIB_KeyboardPressed(KK_ARROWLEFT))
    || (CPad::GetPad(0), LIB_KeyboardPressed(KK_ARROWRIGHT))
    || (v50 = CPad::GetPad(0), v50->NewState.DPadLeft) && !v50->OldState.DPadLeft
    || (v51 = CPad::GetPad(0), v51->NewState.DPadRight) && !v51->OldState.DPadRight
    || (CPad::GetPad(0), CPad::NewMouseControllerState.m_bWheelMovedUp)
    && !CPad::OldMouseControllerState.m_bWheelMovedUp
    || (CPad::GetPad(0), CPad::NewMouseControllerState.m_bWheelMovedDown)
    && !CPad::OldMouseControllerState.m_bWheelMovedDown )
  {
    v36 = (unsigned __int8)aScreens[226 * this->CurrentScreen + 10 + 18 * this->CurrentOption];
    v37 = (unsigned int)(v36 - 27) >= 2;
    if ( (unsigned int)(v36 - 27) >= 2 )
      v37 = (unsigned int)(v36 - 64) >= 2;
    if ( v37 )
    {
      if ( v36 != 29 )
        goto LABEL_92;
      v38 = 5;
    }
    else
    {
      v38 = 1;
    }
    CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, v38, 0.0, 1.0);
  }
LABEL_92:
  v39 = CPad::GetPad(0);
  if ( v39->NewState.ButtonTriangle && !v39->OldState.ButtonTriangle
    || (v40 = CPad::GetPad(0), CPad::GetEscapeJustDown(v40)) )
  {
    v41 = (unsigned __int8)(((unsigned __int8)(this->CurrentScreen - 14) >> 1) | ((this->CurrentScreen - 14) << 7));
    if ( v41 > 0xF || ((1 << v41) & 0xC417) == 0 )
    {
      this->DisplayTheMouse = 0;
      GoBackOneMenu = 1;
    }
  }
  if ( (pGoDownMenu[0] | pGoUpMenu | EnterMenuOption) << 24 )
    GoBackOneMenu = 0;
LABEL_99:
  if ( LIB_KeyboardIsDown(KK_ARROWLEFT)
    || (CPad::GetPad(0), v46 = CPad::GetPad(0), CPad::GetPedWalkLeftRight(v46) < 0)
    || CPad::GetPad(0)->NewState.DPadLeft )
  {
    v42 = CTimer::m_snTimeInMillisecondsPauseMode;
    if ( CTimer::m_snTimeInMillisecondsPauseMode - CMenuManager::UserInput(void)::LastKeyPress >= 0xC9 )
    {
      v43 = (unsigned __int8)aScreens[226 * this->CurrentScreen + 10 + 18 * this->CurrentOption];
      if ( v43 <= 0x1D && ((1 << v43) & 0x38200000) != 0 || v43 - 64 < 2 )
      {
        v44 = -1;
        v45 = &CMenuManager::UserInput(void)::LastKeyPress;
      }
      else
      {
        v44 = 0;
        v45 = &CMenuManager::UserInput(void)::LastKeyPress;
      }
      goto LABEL_105;
    }
    goto LABEL_117;
  }
  if ( !LIB_KeyboardIsDown(KK_ARROWRIGHT) )
  {
    CPad::GetPad(0);
    v47 = CPad::GetPad(0);
    if ( CPad::GetPedWalkLeftRight(v47) <= 0 )
    {
      v44 = 0;
      if ( !CPad::GetPad(0)->NewState.DPadRight )
        goto LABEL_118;
    }
  }
  v42 = CTimer::m_snTimeInMillisecondsPauseMode;
  if ( CTimer::m_snTimeInMillisecondsPauseMode - CMenuManager::UserInput(void)::LastKeyPress < 0xC9 )
  {
LABEL_117:
    v44 = 0;
    goto LABEL_118;
  }
  v48 = (unsigned __int8)aScreens[226 * this->CurrentScreen + 10 + 18 * this->CurrentOption];
  v44 = v48 <= 0x1D && ((1 << v48) & 0x38200000) != 0 || v48 - 64 < 2;
  v45 = &CMenuManager::UserInput(void)::LastKeyPress;
LABEL_105:
  *v45 = v42;
LABEL_118:
  CPad::GetPad(0);
  if ( !CPad::NewMouseControllerState.m_bWheelMovedUp || CPad::OldMouseControllerState.m_bWheelMovedUp )
  {
    CPad::GetPad(0);
    if ( CPad::NewMouseControllerState.m_bWheelMovedDown && !CPad::OldMouseControllerState.m_bWheelMovedDown )
    {
      v49 = -1;
      goto LABEL_124;
    }
    v49 = v44;
  }
  else
  {
    v49 = 1;
LABEL_124:
    if ( this->CurrentScreen == 5 )
      v49 = v44;
  }
  if ( CMenuManager::CheckFrontEndRightInput(this) )
  {
    v49 = 1;
    goto LABEL_132;
  }
  if ( CMenuManager::CheckFrontEndLeftInput(this) )
  {
    v49 = -1;
LABEL_132:
    this->DisplayTheMouse = 0;
  }
  CMenuManager::ProcessUserInput(this, pGoDownMenu[0], pGoUpMenu, EnterMenuOption, GoBackOneMenu, v49);
}
// 4335C4: variable 'oldMousePosY' is possibly undefined
// 990C00: using guessed type char `guard variable for'CMenuManager::UserInput(void)::oldScreen;
// 43331C: using guessed type bool8 pGoDownMenu[41];

//----- (00433AAC) --------------------------------------------------------
void __fastcall CMenuManager::RedefineScreenUserInput(CMenuManager *this, bool8 *EnterMenuOption, bool8 *GoBackOneMenu)
{
  unsigned __int8 v3; // r8
  bool8 v7; // r0
  int v8; // r2
  Int32 ListSelection; // r0
  CPad *Pad; // r0
  CPad *v11; // r0
  bool8 v12; // r0
  int v13; // r2
  int v14; // r1
  Int32 v15; // r0
  CPad *v16; // r0
  CPad *v17; // r0
  CPad *v18; // r0
  int m_bLeftButton; // r0
  bool v20; // zf
  uint8 *v21; // r5
  int8 v22; // r1

  if ( this->m_EditingControlOptions )
    return;
  if ( this->CurrentScreen == 39 )
  {
    if ( this->RedefiningControls )
    {
      v3 = 25;
    }
    else
    {
      v3 = 28;
      if ( !this->m_ControlMethod )
        v3 = 22;
    }
  }
  CPad::GetPad(0);
  if ( LIB_KeyboardPressed(KK_ENTER) || (Pad = CPad::GetPad(0), Pad->NewState.ButtonCross) && !Pad->OldState.ButtonCross )
  {
    this->DisplayTheMouse = 0;
    *EnterMenuOption = 1;
  }
  CPad::GetPad(0);
  if ( LIB_KeyboardPressed(KK_BACKSPACE) && this->CurrentScreen == 39 && !this->JustExitedRedefine )
  {
    this->MouseInBounds = 16;
    this->m_EditingControlOptions = 1;
    this->m_DeleteAllBoundControls = 1;
    this->m_bJustEnteredOption = 1;
    this->pControlEdit = &this->m_KeyPressedCode;
  }
  else
  {
    this->JustExitedRedefine = 0;
  }
  if ( CTimer::m_snTimeInMillisecondsPauseMode
     - CMenuManager::RedefineScreenUserInput(unsigned char *,unsigned char *)::LastPressed >= 0xC9 )
  {
    this->key_pressed[4] = 0;
    *(_DWORD *)this->key_pressed = 0;
    CMenuManager::RedefineScreenUserInput(unsigned char *,unsigned char *)::LastPressed = CTimer::m_snTimeInMillisecondsPauseMode;
  }
  if ( LIB_KeyboardIsDown(KK_ARROWUP) || (v11 = CPad::GetPad(0), v11->NewState.DPadUp) && !v11->OldState.DPadUp )
  {
    v7 = 0;
  }
  else
  {
    CPad::GetPad(0);
    if ( !CPad::NewMouseControllerState.m_bWheelMovedUp || CPad::OldMouseControllerState.m_bWheelMovedUp )
    {
      this->key_pressed[2] = 0;
      goto LABEL_34;
    }
    v7 = 1;
  }
  v8 = this->key_pressed[2];
  this->DisplayTheMouse = v7;
  if ( !v8 )
  {
    this->key_pressed[2] = 1;
    CMenuManager::RedefineScreenUserInput(unsigned char *,unsigned char *)::LastPressed = CTimer::m_snTimeInMillisecondsPauseMode;
    ListSelection = this->ListSelection;
    if ( ListSelection )
    {
      if ( ListSelection >= 1 )
        this->ListSelection = ListSelection - 1;
    }
    else
    {
      this->ListSelection = v3 - 1;
    }
  }
LABEL_34:
  if ( LIB_KeyboardIsDown(KK_ARROWDOWN) || (v16 = CPad::GetPad(0), v16->NewState.DPadDown) && !v16->OldState.DPadDown )
  {
    v12 = 0;
  }
  else
  {
    CPad::GetPad(0);
    if ( !CPad::NewMouseControllerState.m_bWheelMovedDown || CPad::OldMouseControllerState.m_bWheelMovedDown )
    {
      this->key_pressed[3] = 0;
      goto LABEL_48;
    }
    v12 = 1;
  }
  v13 = this->key_pressed[3];
  this->DisplayTheMouse = v12;
  if ( !v13 )
  {
    this->key_pressed[3] = 1;
    CMenuManager::RedefineScreenUserInput(unsigned char *,unsigned char *)::LastPressed = CTimer::m_snTimeInMillisecondsPauseMode;
    v14 = v3 - 1;
    v15 = this->ListSelection;
    if ( v15 == v14 )
    {
      this->ListSelection = 0;
    }
    else if ( v15 < v14 )
    {
      this->ListSelection = v15 + 1;
    }
  }
LABEL_48:
  v17 = CPad::GetPad(0);
  if ( CPad::GetEscapeJustDown(v17)
    || (v18 = CPad::GetPad(0), v18->NewState.ButtonTriangle) && !v18->OldState.ButtonTriangle )
  {
    this->DisplayTheMouse = 0;
    *GoBackOneMenu = 1;
  }
  CPad::GetPad(0);
  if ( CPad::NewMouseControllerState.m_bLeftButton
    && !CPad::OldMouseControllerState.m_bLeftButton
    && this->MouseInBounds == 3 )
  {
    *GoBackOneMenu = 1;
  }
  CPad::GetPad(0);
  if ( CPad::NewMouseControllerState.m_bLeftButton )
  {
    m_bLeftButton = CPad::OldMouseControllerState.m_bLeftButton;
    v20 = CPad::OldMouseControllerState.m_bLeftButton == 0;
    if ( !CPad::OldMouseControllerState.m_bLeftButton )
    {
      m_bLeftButton = 6852;
      v20 = this->MouseInBounds == 4;
    }
    if ( v20 )
    {
      v21 = &this->BriefDisplay + m_bLeftButton;
      CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 1, 0.0, 1.0);
      *(_DWORD *)v21 = 5;
    }
  }
  if ( *GoBackOneMenu )
  {
    if ( this->MenuIsAbleToQuit )
    {
      this->RedefiningControls = this->RedefiningControls == 0;
      CMenuManager::DrawControllerBound(this, 0x45u, 1);
      if ( this->MenuIsAbleToQuit )
        return;
      v22 = 2;
      if ( !this->RedefiningControls )
        v22 = 1;
    }
    else
    {
      v22 = 3;
    }
    this->DisplayWarningScreenForUnboundControls = v22;
  }
}
// 433C12: variable 'v3' is possibly undefined

//----- (00433DC4) --------------------------------------------------------
void __fastcall CMenuManager::DrawControllerBound(CMenuManager *this, uint16 StartingYPos, bool bOppositeScreen)
{
  int RedefiningControls; // r0
  unsigned int v5; // r6
  int v6; // r1
  int v7; // r0
  float v8; // r0
  int v9; // r2
  float v10; // s16
  unsigned int v11; // r5
  int v12; // r6
  int v13; // r10
  int v14; // r0
  CRGBA v15; // r0
  GxtChar *v16; // r2
  char *v17; // r1
  bool8 *p_CanBeDefined; // r0
  char v19; // r1
  CRGBA v20; // r0
  CRGBA v21; // r0
  GxtChar *v22; // r0
  int v23; // r1
  float v24; // r4
  CRGBA v25; // r0
  int v26; // s16
  int v27; // s18
  int v28; // r0
  int m_ControlMethod; // r0
  Int32 ListSelection; // r0
  bool v31; // zf
  float v32; // r4
  float v33; // r11
  float screenWidth; // s20
  float v35; // s20
  float v36; // r0
  CRGBA v37; // r0
  float v38; // r0
  RwInt32 v39; // r4
  float v40; // r0
  int v41; // r11
  int v42; // r9
  GxtChar *ControllerSettingTextWithOrderNumber; // r2
  float v44; // s18
  GxtChar *v45; // r2
  GxtChar *v46; // r2
  GxtChar *v47; // r2
  CRGBA v48; // r0
  GxtChar *v49; // r0
  bool8 *p_m_EditingControlOptions; // [sp+28h] [bp-98h]
  int v51; // [sp+48h] [bp-78h]
  int v52; // [sp+4Ch] [bp-74h]
  bool8 *p_m_DeleteAllNextDefine; // [sp+50h] [bp-70h]
  _BOOL4 v54; // [sp+54h] [bp-6Ch]
  Int32 Action; // [sp+58h] [bp-68h]
  CRGBA v56; // [sp+5Ch] [bp-64h] BYREF
  CRGBA v57; // [sp+60h] [bp-60h] BYREF
  CRGBA v58; // [sp+64h] [bp-5Ch] BYREF
  CRGBA v59; // [sp+68h] [bp-58h] BYREF
  CRGBA v60; // [sp+6Ch] [bp-54h] BYREF
  CRGBA v61; // [sp+70h] [bp-50h] BYREF
  CRect Rectangle; // [sp+74h] [bp-4Ch] BYREF
  CRGBA v63; // [sp+84h] [bp-3Ch] BYREF

  v54 = bOppositeScreen;
  RedefiningControls = this->RedefiningControls;
  v5 = StartingYPos;
  if ( RedefiningControls == 1 )
  {
    v7 = 13;
LABEL_8:
    v52 = v7;
    goto LABEL_9;
  }
  if ( RedefiningControls )
  {
    v7 = 0;
    goto LABEL_8;
  }
  v6 = 11;
  if ( !this->m_ControlMethod )
    v6 = 15;
  v52 = v6;
LABEL_9:
  v8 = CMenuManager::StretchY(this, (float)v5);
  if ( this->RedefiningControls == 1 )
  {
    v51 = 25;
LABEL_15:
    v10 = v8;
    CMenuManager::StretchY(this, (float)v5);
    v11 = v5 + 1;
    p_m_DeleteAllNextDefine = &this->m_DeleteAllNextDefine;
    v12 = (v5 << 16) + 0x10000;
    v13 = 0;
    p_m_EditingControlOptions = &this->m_EditingControlOptions;
    Action = 0;
    while ( 1 )
    {
      v24 = CMenuManager::StretchX(this, 270.0);
      CRGBA::CRGBA(&v63, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
      CFont::SetColor(v25);
      v26 = (int)v10;
      v27 = (int)v24;
      if ( this->RedefiningControls == 1 )
      {
        switch ( ControllerActionsAvailableInCar[v13] )
        {
          case 0:
            v28 = 18;
            goto LABEL_88;
          case 1:
            v28 = 19;
            goto LABEL_88;
          case 2:
          case 3:
          case 0xB:
          case 0xC:
          case 0xD:
          case 0xE:
          case 0xF:
          case 0x17:
          case 0x18:
          case 0x1A:
          case 0x1B:
          case 0x1C:
          case 0x1D:
          case 0x26:
          case 0x27:
          case 0x2A:
LABEL_87:
            v28 = -1;
            goto LABEL_88;
          case 4:
            v28 = 24;
            goto LABEL_88;
          case 5:
            v28 = 25;
            goto LABEL_88;
          case 6:
            v28 = 20;
            goto LABEL_88;
          case 7:
            v28 = 21;
            goto LABEL_88;
          case 8:
            v28 = 22;
            goto LABEL_88;
          case 9:
            v28 = 23;
            goto LABEL_88;
          case 0xA:
LABEL_78:
            v28 = 47;
            goto LABEL_88;
          case 0x10:
LABEL_77:
            v28 = 10;
            goto LABEL_88;
          case 0x11:
            v28 = 26;
            goto LABEL_88;
          case 0x12:
            v28 = 27;
            goto LABEL_88;
          case 0x13:
            v28 = 28;
            goto LABEL_88;
          case 0x14:
            v28 = 29;
            goto LABEL_88;
          case 0x15:
            v28 = 30;
            goto LABEL_88;
          case 0x16:
LABEL_71:
            v28 = 11;
            goto LABEL_88;
          case 0x19:
            v28 = 31;
            goto LABEL_88;
          case 0x1E:
            v28 = 38;
            goto LABEL_88;
          case 0x1F:
            v28 = 39;
            goto LABEL_88;
          case 0x20:
            v28 = 41;
            goto LABEL_88;
          case 0x21:
            v28 = 40;
            goto LABEL_88;
          case 0x22:
            v28 = 36;
            goto LABEL_88;
          case 0x23:
            v28 = 37;
            goto LABEL_88;
          case 0x24:
            v28 = 34;
            goto LABEL_88;
          case 0x25:
            v28 = 35;
LABEL_88:
            Action = v28;
            break;
          default:
            break;
        }
      }
      else if ( !this->RedefiningControls )
      {
        v28 = ControllerActionsAvailableOnFoot[v13];
        switch ( v13 )
        {
          case 0:
          case 1:
          case 2:
          case 7:
          case 8:
          case 9:
          case 10:
          case 27:
          case 28:
          case 29:
          case 30:
          case 31:
          case 32:
          case 33:
            goto LABEL_88;
          case 3:
            v28 = 49;
            goto LABEL_88;
          case 4:
            v28 = 50;
            goto LABEL_88;
          case 5:
            v28 = 48;
            goto LABEL_88;
          case 6:
          case 37:
            goto LABEL_78;
          case 11:
            v28 = 8;
            goto LABEL_88;
          case 12:
            v28 = 9;
            goto LABEL_88;
          case 13:
          case 36:
            goto LABEL_77;
          case 14:
          case 43:
            goto LABEL_71;
          case 15:
            v28 = 12;
            goto LABEL_88;
          case 16:
            v28 = 13;
            goto LABEL_88;
          case 17:
            v28 = 45;
            goto LABEL_88;
          case 18:
            v28 = 15;
            goto LABEL_88;
          case 19:
            v28 = 16;
            goto LABEL_88;
          case 20:
            v28 = 17;
            goto LABEL_88;
          case 21:
          case 45:
            v28 = 14;
            goto LABEL_88;
          case 22:
          case 47:
            m_ControlMethod = (unsigned __int8)this->m_ControlMethod;
            v23 = 32;
            goto LABEL_38;
          case 23:
          case 48:
            m_ControlMethod = (unsigned __int8)this->m_ControlMethod;
            v23 = 33;
LABEL_38:
            if ( !m_ControlMethod )
              v23 = -1;
            Action = v23;
            break;
          case 24:
            v28 = 51;
            goto LABEL_88;
          case 25:
            v28 = 52;
            goto LABEL_88;
          case 26:
            v28 = 44;
            goto LABEL_88;
          case 38:
          case 39:
          case 40:
          case 41:
          case 42:
          case 44:
          case 46:
          case 49:
          case 50:
          case 51:
          case 52:
            goto LABEL_87;
          default:
            break;
        }
      }
      ListSelection = this->ListSelection;
      v31 = v13 == ListSelection;
      if ( v13 == ListSelection )
        v31 = !v54;
      if ( v31 )
      {
        v32 = CMenuManager::StretchX(this, 260.0);
        v33 = CMenuManager::StretchY(this, (float)(__int16)v11);
        screenWidth = (float)RsGlobal.screenWidth;
        v35 = screenWidth - CMenuManager::StretchX(this, 20.0);
        v36 = CMenuManager::StretchY(this, (float)((v12 >> 16) + 10));
        Rectangle.bottom = v33;
        Rectangle.left = v32;
        Rectangle.top = v36;
        Rectangle.right = v35;
        CRGBA::CRGBA(&v61, 0xACu, 0xCBu, 0xF1u, 0xFFu);
        CSprite2d::DrawRect(&Rectangle, &v61);
        CRGBA::CRGBA(&v60, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
        CFont::SetColor(v37);
      }
      CFont::SetOrientation(1u);
      v38 = CMenuManager::StretchY(this, 0.6);
      CFont::SetScale(v38);
      CFont::SetFontStyle(1u);
      v39 = RsGlobal.screenWidth;
      v40 = CMenuManager::StretchX(this, 100.0);
      CFont::SetWrapx(v40 + (float)v39);
      if ( Action != -1 )
      {
        v41 = v27;
        if ( *p_m_DeleteAllNextDefine && v13 == this->ListSelection )
        {
          v42 = 0;
        }
        else
        {
          ControllerSettingTextWithOrderNumber = CControllerConfigManager::GetControllerSettingTextWithOrderNumber(
                                                   &ControlsManager,
                                                   (e_ControllerAction)Action,
                                                   FIRST);
          v42 = (int)ControllerSettingTextWithOrderNumber;
          if ( ControllerSettingTextWithOrderNumber )
          {
            v42 = 1;
            v44 = (float)v27;
            if ( !v54 )
              CFont::PrintString(v44, (float)v26, ControllerSettingTextWithOrderNumber);
            v41 = (int)(float)(CMenuManager::StretchX(this, 75.0) + v44);
          }
          if ( !*p_m_DeleteAllNextDefine || v13 != this->ListSelection )
          {
            v45 = CControllerConfigManager::GetControllerSettingTextWithOrderNumber(
                    &ControlsManager,
                    (e_ControllerAction)Action,
                    SECOND);
            if ( v45 )
            {
              ++v42;
              if ( !v54 )
                CFont::PrintString((float)v41, (float)v26, v45);
              v41 = (int)(float)(CMenuManager::StretchX(this, 75.0) + (float)v41);
            }
            if ( !*p_m_DeleteAllNextDefine || v13 != this->ListSelection )
            {
              v46 = CControllerConfigManager::GetControllerSettingTextWithOrderNumber(
                      &ControlsManager,
                      (e_ControllerAction)Action,
                      THIRD);
              if ( v46 )
              {
                ++v42;
                if ( !v54 )
                  CFont::PrintString((float)v41, (float)v26, v46);
                v41 = (int)(float)(CMenuManager::StretchX(this, 75.0) + (float)v41);
              }
              if ( !*p_m_DeleteAllNextDefine || v13 != this->ListSelection )
              {
                v47 = CControllerConfigManager::GetControllerSettingTextWithOrderNumber(
                        &ControlsManager,
                        (e_ControllerAction)Action,
                        FOURTH);
                if ( v47 )
                {
                  ++v42;
                  if ( !v54 )
                    CFont::PrintString((float)v41, (float)v26, v47);
                  v41 = (int)(float)(CMenuManager::StretchX(this, 75.0) + (float)v41);
                }
              }
            }
          }
        }
        if ( Action != -2 )
        {
          if ( v42 )
            goto LABEL_17;
          this->MenuIsAbleToQuit = 0;
          if ( v13 == this->ListSelection )
          {
            if ( !*p_m_EditingControlOptions )
            {
              CRGBA::CRGBA(&v57, 0xC8u, 0x32u, 0x32u, 0xFFu);
              CFont::SetColor(v20);
              if ( !v54 )
              {
LABEL_37:
                v22 = CText::Get(&TheText, "FEC_UNB");
                CFont::PrintString((float)v41, (float)v26, v22);
              }
            }
          }
          else
          {
            CRGBA::CRGBA(&v58, 0xC8u, 0x32u, 0x32u, 0xFFu);
            CFont::SetColor(v21);
            if ( !v54 )
              goto LABEL_37;
          }
LABEL_17:
          if ( v13 == this->ListSelection )
          {
            this->OptionToChange = Action;
            if ( *p_m_EditingControlOptions )
            {
              v14 = CMenuManager::DrawControllerBound(unsigned short,bool)::ColourSwitch;
              if ( CTimer::m_snTimeInMillisecondsPauseMode
                 - CMenuManager::DrawControllerBound(unsigned short,bool)::LastFlash >= 0x97 )
              {
                v14 = 0;
                CMenuManager::DrawControllerBound(unsigned short,bool)::LastFlash = CTimer::m_snTimeInMillisecondsPauseMode;
                if ( !CMenuManager::DrawControllerBound(unsigned short,bool)::ColourSwitch )
                  v14 = 1;
                CMenuManager::DrawControllerBound(unsigned short,bool)::ColourSwitch = v14;
              }
              if ( v14 )
              {
                CRGBA::CRGBA(&v56, 0, 0, 0, 0xFFu);
                CFont::SetColor(v15);
                v16 = CText::Get(&TheText, "FEC_QUE");
                if ( !v54 )
                  CFont::PrintString((float)v41, (float)v26, v16);
              }
              if ( this->m_DeleteAllBoundControls )
                v17 = "FET_CIG";
              else
                v17 = "FET_RIG";
              CMenuManager::DisplayHelperText(this, (unsigned __int8 *)v17);
              p_CanBeDefined = &this->CanBeDefined;
              v19 = 1;
            }
            else
            {
              CMenuManager::DisplayHelperText(this, "FET_CIG");
              v19 = 0;
              this->CanBeDefined = 0;
              p_CanBeDefined = &this->m_DeleteAllBoundControls;
            }
            *p_CanBeDefined = v19;
          }
          goto LABEL_133;
        }
        CRGBA::CRGBA(&v59, 0, 0, 0, 0xFFu);
        CFont::SetColor(v48);
        if ( !v54 )
        {
          v49 = CText::Get(&TheText, "FEC_CMP");
          CFont::PrintString((float)v41, (float)v26, v49);
        }
      }
      if ( v13 == this->ListSelection )
        CMenuManager::DisplayHelperText(this, "FET_EIG");
LABEL_133:
      v11 += v52;
      v10 = CMenuManager::StretchY(this, (float)(int)(v11 - 1));
      ++v13;
      v12 += v52 << 16;
      if ( v13 >= v51 )
        return;
    }
  }
  if ( !this->RedefiningControls )
  {
    v9 = 28;
    if ( !this->m_ControlMethod )
      v9 = 22;
    v51 = v9;
    goto LABEL_15;
  }
  sub_195BE8(this, (float)v5);
}
// 4342F4: conditional instruction was optimized away because %Action.4!=FFFFFFFF
// 43444A: conditional instruction was optimized away because %Action.4!=FFFFFFFF
// 433F5C: variable 'v15' is possibly undefined
// 433FCC: variable 'v20' is possibly undefined
// 434000: variable 'v21' is possibly undefined
// 43405C: variable 'v25' is possibly undefined
// 434286: variable 'v37' is possibly undefined
// 434464: variable 'v48' is possibly undefined
// 434548: using guessed type int *off_434548;

//----- (00434560) --------------------------------------------------------
void __fastcall CMenuManager::DrawQuitGameScreen(CMenuManager *this)
{
  CRGBA v1; // [sp+4h] [bp-1Ch] BYREF
  CRect Rectangle; // [sp+8h] [bp-18h] BYREF

  this->DisplayTheMouse = 0;
  Rectangle.left = 0.0;
  Rectangle.bottom = 0.0;
  Rectangle.right = (float)RsGlobal.screenWidth;
  Rectangle.top = (float)RsGlobal.screenHeight;
  CRGBA::CRGBA(&v1, 0, 0, 0, 0xFFu);
  CSprite2d::DrawRect(&Rectangle, &v1);
  Menu_SaveSettings();
  RsEventHandler(rsQUITAPP, 0);
}

//----- (004345C0) --------------------------------------------------------
void __fastcall CMenuManager::DrawControllerSetupScreen(CMenuManager *this)
{
  int RedefiningControls; // r6
  const char *v3; // r1
  const char *v4; // r1
  const char *v5; // r1
  float v6; // r0
  float screenWidth; // s16
  int m_ControlMethod; // r6
  float v9; // s16
  float v10; // r5
  const char *v11; // r1
  GxtChar *v12; // r0
  float v13; // r5
  float v14; // r6
  GxtChar *v15; // r0
  int v16; // r1
  float v17; // r5
  float v18; // r6
  GxtChar *v19; // r0
  int v20; // r0
  float v21; // r10
  float v22; // r5
  float v23; // s16
  float v24; // r0
  RwInt32 screenHeight; // s0
  int v26; // r1
  __int16 v27; // r9
  Int32 v28; // r8
  unsigned __int8 v29; // r11
  Int32 MousePosX; // r5
  Int32 v31; // r5
  Int32 MousePosY; // r6
  Int32 v33; // r5
  CRGBA *v34; // r0
  CRGBA v35; // r0
  float v36; // r0
  RwInt32 v37; // r6
  float v38; // r0
  float v39; // r0
  float v40; // r1
  float v41; // r9
  float v42; // r1
  GxtChar *v43; // r2
  float v44; // r0
  float v45; // r5
  float v46; // r0
  Int32 v47; // r5
  float v48; // s16
  GxtChar *v49; // r0
  float StringWidth; // r0
  Int32 v51; // r5
  float v52; // s16
  float v53; // s18
  float v54; // s16
  float v55; // s18
  int v56; // r0
  Int32 v57; // r5
  Int32 v58; // r5
  Int32 v59; // r5
  float v60; // s16
  float v61; // s18
  float v62; // r0
  Int32 *v63; // r1
  float v64; // r0
  CRGBA v65; // r0
  float v66; // r5
  float v67; // s16
  float v68; // s16
  GxtChar *v69; // r0
  Int32 *p_MouseInBounds; // [sp+18h] [bp-120h]
  int v71; // [sp+20h] [bp-118h]
  unsigned int v72; // [sp+24h] [bp-114h]
  bool8 *p_m_EditingControlOptions; // [sp+28h] [bp-110h]
  CRGBA v74; // [sp+2Ch] [bp-10Ch] BYREF
  char v75; // [sp+30h] [bp-108h] BYREF
  CRGBA v76; // [sp+34h] [bp-104h] BYREF
  CRGBA v77; // [sp+38h] [bp-100h] BYREF
  CRect Rectangle; // [sp+3Ch] [bp-FCh] BYREF
  CRGBA v79; // [sp+4Ch] [bp-ECh] BYREF
  int v80[58]; // [sp+50h] [bp-E8h]

  v80[0] = (int)CText::Get(&TheText, "FEC_FIR");
  v80[1] = (int)CText::Get(&TheText, "FEC_FIA");
  v80[2] = (int)CText::Get(&TheText, "FEC_NWE");
  v80[3] = (int)CText::Get(&TheText, "FEC_PWE");
  RedefiningControls = this->RedefiningControls;
  v3 = "FEC_FOR";
  if ( this->RedefiningControls )
    v3 = "FEC_ACC";
  v80[4] = (int)CText::Get(&TheText, (const unsigned __int8 *)v3);
  v4 = "FEC_BAC";
  if ( RedefiningControls )
    v4 = "FEC_BRA";
  v80[5] = (int)CText::Get(&TheText, (const unsigned __int8 *)v4);
  v5 = "FEC_COY";
  if ( RedefiningControls )
    v5 = "FEC_TSK";
  v80[10] = (int)CText::Get(&TheText, (const unsigned __int8 *)v5);
  v80[6] = (int)CText::Get(&TheText, "FEC_LEF");
  v80[7] = (int)CText::Get(&TheText, "FEC_RIG");
  v80[8] = (int)CText::Get(&TheText, "FEC_PLU");
  v80[9] = (int)CText::Get(&TheText, "FEC_PLD");
  v80[11] = (int)CText::Get(&TheText, "FEC_CON");
  v80[12] = (int)CText::Get(&TheText, "FEC_GPF");
  v80[13] = (int)CText::Get(&TheText, "FEC_GPB");
  v80[14] = (int)CText::Get(&TheText, "FEC_ZIN");
  v80[15] = (int)CText::Get(&TheText, "FEC_ZOT");
  v80[16] = (int)CText::Get(&TheText, "FEC_EEX");
  v80[17] = (int)CText::Get(&TheText, "FEC_RSC");
  v80[18] = (int)CText::Get(&TheText, "FEC_RSP");
  v80[19] = (int)CText::Get(&TheText, "FEC_RTS");
  v80[20] = (int)CText::Get(&TheText, "FEC_HRN");
  v80[21] = (int)CText::Get(&TheText, "FEC_SUB");
  v80[22] = (int)CText::Get(&TheText, "FEC_CMR");
  v80[23] = (int)CText::Get(&TheText, "FEC_JMP");
  v80[24] = (int)CText::Get(&TheText, "FEC_SPN");
  v80[25] = (int)CText::Get(&TheText, "FEC_HND");
  v80[26] = (int)CText::Get(&TheText, "FEC_TAR");
  v80[27] = (int)CText::Get(&TheText, "FEC_CRO");
  v80[28] = (int)CText::Get(&TheText, "FEC_ANS");
  v80[29] = (int)CText::Get(&TheText, "FEC_PDW");
  v80[30] = (int)CText::Get(&TheText, "FEC_TFL");
  v80[31] = (int)CText::Get(&TheText, "FEC_TFR");
  v80[32] = (int)CText::Get(&TheText, "FEC_TFU");
  v80[33] = (int)CText::Get(&TheText, "FEC_TFD");
  v80[34] = (int)CText::Get(&TheText, "FEC_LBA");
  v80[35] = (int)CText::Get(&TheText, "FEC_VML");
  v80[36] = (int)CText::Get(&TheText, "FEC_LOL");
  v80[37] = (int)CText::Get(&TheText, "FEC_LOR");
  v80[39] = (int)CText::Get(&TheText, "FEC_LUD");
  v80[38] = (int)CText::Get(&TheText, "FEC_LDU");
  v80[42] = (int)CText::Get(&TheText, "FEC_CEN");
  v80[43] = 0;
  CFont::SetFontStyle(0);
  v6 = CMenuManager::StretchY(this, 1.7);
  CFont::SetScale(v6);
  CFont::SetEdge(0);
  CHudColours::GetRGBA(&v79, &HudColour, 3u);
  CFont::SetColor((CRGBA)&v79);
  CFont::SetOrientation(2u);
  screenWidth = (float)RsGlobal.screenWidth;
  m_ControlMethod = (unsigned __int8)this->m_ControlMethod;
  v9 = screenWidth - CMenuManager::StretchX(this, 48.0);
  v10 = CMenuManager::StretchY(this, 11.0);
  if ( m_ControlMethod )
    v11 = "FET_CCN";
  else
    v11 = "FET_SCN";
  v12 = CText::Get(&TheText, (const unsigned __int8 *)v11);
  CFont::PrintString(v9, v10, v12);
  CFont::SetOrientation(1u);
  if ( this->RedefiningControls == 1 )
  {
    v17 = CMenuManager::StretchX(this, 48.0);
    v18 = CMenuManager::StretchY(this, 11.0);
    v19 = CText::Get(&TheText, "FET_CCR");
    CFont::PrintString(v17, v18, v19);
    v20 = 13;
  }
  else
  {
    if ( !this->RedefiningControls )
    {
      v13 = CMenuManager::StretchX(this, 48.0);
      v14 = CMenuManager::StretchY(this, 11.0);
      v15 = CText::Get(&TheText, "FET_CFT");
      CFont::PrintString(v13, v14, v15);
      v16 = 11;
      if ( !this->m_ControlMethod )
        v16 = 15;
      v71 = v16;
      goto LABEL_18;
    }
    v20 = 0;
  }
  v71 = v20;
LABEL_18:
  v21 = CMenuManager::StretchX(this, 20.0);
  v22 = CMenuManager::StretchY(this, 50.0);
  v23 = (float)RsGlobal.screenWidth;
  v24 = CMenuManager::StretchX(this, 20.0);
  screenHeight = RsGlobal.screenHeight;
  Rectangle.left = v21;
  Rectangle.bottom = v22;
  Rectangle.right = v23 - v24;
  Rectangle.top = (float)screenHeight - CMenuManager::StretchY(this, 50.0);
  CRGBA::CRGBA(&v77, 0x31u, 0x65u, 0x94u, 0x64u);
  CSprite2d::DrawRect(&Rectangle, &v77);
  if ( this->RedefiningControls )
  {
    v72 = 25;
  }
  else
  {
    v26 = 28;
    if ( !this->m_ControlMethod )
      v26 = 22;
    v72 = v26;
  }
  v27 = v71;
  v28 = 0;
  p_MouseInBounds = &this->MouseInBounds;
  v29 = 0;
  p_m_EditingControlOptions = &this->m_EditingControlOptions;
  do
  {
    if ( !*p_m_EditingControlOptions )
    {
      MousePosX = this->MousePosX;
      if ( CMenuManager::StretchX(this, 20.0) < (float)MousePosX )
      {
        v31 = this->MousePosX;
        if ( CMenuManager::StretchX(this, 600.0) > (float)v31 )
        {
          MousePosY = this->MousePosY;
          if ( CMenuManager::StretchY(this, (float)(v27 * v29 + 69)) < (float)MousePosY )
          {
            v33 = this->MousePosY;
            if ( CMenuManager::StretchY(this, (float)(v27 * v29 + v71 + 69)) > (float)v33 )
            {
              this->CurrentMouseOption = v28;
              if ( this->oldMousePosX == this->MousePosX )
              {
                if ( this->oldMousePosY != this->MousePosY )
                  this->ListSelection = v28;
              }
              else
              {
                this->ListSelection = v28;
              }
              if ( *p_MouseInBounds == 5 )
              {
                if ( this->ListSelection == v28 )
                {
                  *p_MouseInBounds = 16;
                  *p_m_EditingControlOptions = 1;
                  this->m_bJustEnteredOption = 1;
                  this->pControlEdit = &this->m_KeyPressedCode;
                }
              }
              else
              {
                *p_MouseInBounds = 16;
              }
            }
          }
        }
      }
    }
    if ( this->ListSelection == v29 )
      v34 = (CRGBA *)&v75;
    else
      v34 = &v76;
    CRGBA::CRGBA(v34, 0x4Au, 0x5Au, 0x6Bu, 0xFFu);
    CFont::SetColor(v35);
    v36 = CMenuManager::StretchY(this, 0.6);
    CFont::SetScale(v36);
    CFont::SetFontStyle(2u);
    v37 = RsGlobal.screenWidth;
    v38 = CMenuManager::StretchX(this, 100.0);
    CFont::SetWrapx(v38 + (float)v37);
    if ( this->RedefiningControls == 1 )
    {
      v45 = CMenuManager::StretchX(this, 40.0);
      v42 = CMenuManager::StretchY(this, (float)(v27 * v29 + 69));
      v43 = (GxtChar *)v80[ControllerActionsAvailableInCar[v28]];
      v44 = v45;
    }
    else
    {
      if ( this->RedefiningControls )
        goto LABEL_46;
      v39 = CMenuManager::StretchX(this, 40.0);
      v40 = (float)(v27 * v29 + 69);
      v41 = v39;
      v42 = CMenuManager::StretchY(this, v40);
      v43 = (GxtChar *)v80[ControllerActionsAvailableOnFoot[v28]];
      v44 = v41;
      v27 = v71;
    }
    CFont::PrintString(v44, v42, v43);
LABEL_46:
    v28 = ++v29;
  }
  while ( v72 > v29 );
  CMenuManager::DrawControllerBound(this, 0x45u, 0);
  if ( !*p_m_EditingControlOptions )
  {
    v46 = CMenuManager::StretchY(this, 1.0);
    CFont::SetScale(v46);
    v47 = this->MousePosX;
    v48 = CMenuManager::StretchX(this, 35.0);
    v49 = CText::Get(&TheText, "FEDS_TB");
    StringWidth = CFont::GetStringWidth(v49, 1u, 0);
    if ( (float)(v48 + CMenuManager::StretchX(this, StringWidth)) > (float)v47 )
    {
      v51 = this->MousePosX;
      if ( CMenuManager::StretchX(this, 15.0) < (float)v51 )
      {
        v52 = (float)RsGlobal.screenHeight;
        v53 = (float)this->MousePosY;
        if ( (float)(v52 - CMenuManager::StretchY(this, 33.0)) < v53 )
        {
          v54 = (float)RsGlobal.screenHeight;
          v55 = (float)this->MousePosY;
          if ( (float)(v54 - CMenuManager::StretchY(this, 10.0)) > v55 )
          {
            v56 = 3;
            goto LABEL_60;
          }
        }
      }
    }
    v57 = this->MousePosX;
    if ( CMenuManager::StretchX(this, 20.0) >= (float)v57
      || (v58 = this->MousePosX, CMenuManager::StretchX(this, 600.0) <= (float)v58)
      || (v59 = this->MousePosY, CMenuManager::StretchY(this, 48.0) >= (float)v59) )
    {
      v56 = 16;
LABEL_60:
      v63 = &this->MouseInBounds;
    }
    else
    {
      v60 = (float)RsGlobal.screenHeight;
      v61 = (float)this->MousePosY;
      v62 = CMenuManager::StretchY(this, 33.0);
      v63 = &this->MouseInBounds;
      if ( (float)(v60 - v62) <= v61 )
        v56 = 16;
      else
        v56 = 4;
    }
    *v63 = v56;
  }
  CFont::SetFontStyle(2u);
  v64 = CMenuManager::StretchY(this, 1.0);
  CFont::SetScale(v64);
  CFont::SetOrientation(1u);
  CFont::SetEdge(0);
  CRGBA::CRGBA(&v74, 0x4Au, 0x5Au, 0x6Bu, 0xFFu);
  CFont::SetColor(v65);
  v66 = CMenuManager::StretchX(this, 33.0);
  v67 = (float)RsGlobal.screenHeight;
  v68 = v67 - CMenuManager::StretchY(this, 38.0);
  v69 = CText::Get(&TheText, "FEDS_TB");
  CFont::PrintString(v66, v68, v69);
}
// 434B62: variable 'v35' is possibly undefined
// 434E24: variable 'v65' is possibly undefined

//----- (00435008) --------------------------------------------------------
void __fastcall CMenuManager::DrawContollerScreenExtraText(CMenuManager *this, int StartingYPos)
{
  int RedefiningControls; // r0
  int v5; // r1
  int v6; // r0
  e_ControllerAction i; // r6
  float v8; // r4
  GxtChar *ControllerSettingTextWithOrderNumber; // r10
  int v10; // r8
  float v11; // r0
  GxtChar *v12; // r4
  float v13; // r0
  GxtChar *v14; // r4
  float v15; // r0
  GxtChar *v16; // r4
  float v17; // r0
  _BOOL4 v18; // r0
  CRGBA v19; // r0
  GxtChar *v20; // r0
  CRGBA v21; // r0
  int v22; // [sp+20h] [bp-40h]
  int v23; // [sp+24h] [bp-3Ch]
  CRGBA v24; // [sp+28h] [bp-38h] BYREF
  CRGBA v25; // [sp+2Ch] [bp-34h] BYREF

  RedefiningControls = this->RedefiningControls;
  if ( RedefiningControls == 1 )
  {
    v23 = 25;
    v6 = 13;
  }
  else
  {
    if ( RedefiningControls )
      return;
    v5 = 28;
    v6 = 11;
    if ( !this->m_ControlMethod )
      v5 = 22;
    v23 = v5;
    if ( !this->m_ControlMethod )
      v6 = 15;
  }
  v22 = v6;
  for ( i = PED_FIREWEAPON; i != v23; ++i )
  {
    v8 = CMenuManager::StretchX(this, 240.0);
    ControllerSettingTextWithOrderNumber = CControllerConfigManager::GetControllerSettingTextWithOrderNumber(
                                             &ControlsManager,
                                             i,
                                             FIRST);
    v10 = (int)v8;
    if ( ControllerSettingTextWithOrderNumber )
    {
      v11 = CMenuManager::StretchY(this, (float)StartingYPos);
      CFont::PrintString((float)(int)v8, v11, ControllerSettingTextWithOrderNumber);
      v10 = (int)(float)(CMenuManager::StretchX(this, 75.0) + (float)(int)v8);
    }
    v12 = CControllerConfigManager::GetControllerSettingTextWithOrderNumber(&ControlsManager, i, SECOND);
    if ( v12 )
    {
      v13 = CMenuManager::StretchY(this, (float)StartingYPos);
      CFont::PrintString((float)v10, v13, v12);
      v10 = (int)(float)(CMenuManager::StretchX(this, 75.0) + (float)v10);
    }
    v14 = CControllerConfigManager::GetControllerSettingTextWithOrderNumber(&ControlsManager, i, THIRD);
    if ( v14 )
    {
      v15 = CMenuManager::StretchY(this, (float)StartingYPos);
      CFont::PrintString((float)v10, v15, v14);
      v10 = (int)(float)(CMenuManager::StretchX(this, 75.0) + (float)v10);
    }
    v16 = CControllerConfigManager::GetControllerSettingTextWithOrderNumber(&ControlsManager, i, FOURTH);
    if ( v16 )
    {
      v17 = CMenuManager::StretchY(this, (float)StartingYPos);
      CFont::PrintString((float)v10, v17, v16);
      v10 = (int)(float)(CMenuManager::StretchX(this, 75.0) + (float)v10);
    }
    if ( i == this->CurrentOption && this->m_EditingControlOptions )
    {
      v18 = CMenuManager::DrawContollerScreenExtraText(int)::ColourSwitch;
      if ( CTimer::m_snTimeInMillisecondsPauseMode - CMenuManager::DrawContollerScreenExtraText(int)::LastFlash >= 0x97 )
      {
        v18 = !CMenuManager::DrawContollerScreenExtraText(int)::ColourSwitch;
        CMenuManager::DrawContollerScreenExtraText(int)::LastFlash = CTimer::m_snTimeInMillisecondsPauseMode;
        CMenuManager::DrawContollerScreenExtraText(int)::ColourSwitch ^= 1u;
      }
      if ( v18 )
      {
        CRGBA::CRGBA(&v25, 0, 0, 0, 0xFFu);
        CFont::SetColor(v19);
        v20 = CText::Get(&TheText, "FEC_QUE");
        CFont::PrintString((float)v10, (float)StartingYPos, v20);
        CRGBA::CRGBA(&v24, 0x4Au, 0x5Au, 0x6Bu, 0xFFu);
        CFont::SetColor(v21);
      }
    }
    StartingYPos += v22;
  }
}
// 435202: variable 'v19' is possibly undefined
// 435234: variable 'v21' is possibly undefined

//----- (00435280) --------------------------------------------------------
void __fastcall CMenuManager::DisplayHelperText(CMenuManager *this, unsigned __int8 *passedHelper)
{
  int v4; // r1
  float v5; // r0
  GxtChar *v6; // r5
  CRGBA v7; // r0
  float v8; // r6
  float screenHeight; // s16
  float v10; // s0
  float v11; // r0
  GxtChar *v12; // r2
  int *p_CurrentHelperMessage; // r5
  int alpha; // r0
  CRGBA v15; // r0
  const char *v16; // r1
  GxtChar *v17; // r8
  int CurrentScreen; // r5
  float v19; // r6
  CMenuManager *v20; // r0
  int v21; // r1
  CRGBA v22; // [sp+8h] [bp-20h] BYREF
  CRGBA v23; // [sp+Ch] [bp-1Ch] BYREF

  if ( this->CurrentScreen == 5 )
    v4 = 1056964608;
  else
    v4 = 1058642330;
  v5 = CMenuManager::StretchY(this, *(float *)&v4);
  CFont::SetScale(v5);
  CFont::SetFontStyle(2u);
  CFont::SetOrientation(2u);
  CFont::SetEdge(0);
  if ( passedHelper )
  {
    v6 = CText::Get(&TheText, passedHelper);
    CRGBA::CRGBA(&v23, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
    CFont::SetColor(v7);
    v8 = CMenuManager::StretchX(this, 610.0);
LABEL_6:
    screenHeight = (float)RsGlobal.screenHeight;
    v10 = CMenuManager::StretchY(this, 10.0);
    v11 = v8;
    v12 = v6;
  }
  else
  {
    p_CurrentHelperMessage = &this->CurrentHelperMessage;
    if ( this->CurrentHelperMessage >= 2u )
    {
      if ( CTimer::m_snTimeInMillisecondsPauseMode - CMenuManager::DisplayHelperText(char *)::LastFlash <= 0xA )
      {
        alpha = this->DefaultsFadeCounter;
      }
      else
      {
        CMenuManager::DisplayHelperText(char *)::LastFlash = CTimer::m_snTimeInMillisecondsPauseMode;
        alpha = this->DefaultsFadeCounter - 2;
        this->DefaultsFadeCounter = alpha;
      }
      if ( alpha <= 0 )
      {
        *p_CurrentHelperMessage = 0;
        alpha = 300;
        this->DefaultsFadeCounter = 300;
      }
      if ( alpha > 255 )
        LOBYTE(alpha) = -1;
    }
    else
    {
      LOBYTE(alpha) = -1;
    }
    CRGBA::CRGBA(&v22, 0xFFu, 0xFFu, 0xFFu, alpha);
    CFont::SetColor(v15);
    switch ( *p_CurrentHelperMessage )
    {
      case 1:
        v6 = CText::Get(&TheText, "FET_APP");
        v8 = CMenuManager::StretchX(this, 610.0);
        goto LABEL_6;
      case 2:
        v6 = CText::Get(&TheText, "FET_HRD");
        v8 = CMenuManager::StretchX(this, 610.0);
        goto LABEL_6;
      case 3:
        v6 = CText::Get(&TheText, "FET_RSO");
        v8 = CMenuManager::StretchX(this, 610.0);
        goto LABEL_6;
      case 4:
        v6 = CText::Get(&TheText, "FEA_SCF");
        v8 = CMenuManager::StretchX(this, 610.0);
        goto LABEL_6;
      case 5:
        v6 = CText::Get(&TheText, "FEA_SCS");
        v8 = CMenuManager::StretchX(this, 610.0);
        goto LABEL_6;
      case 6:
        v6 = CText::Get(&TheText, "FET_STS");
        v8 = CMenuManager::StretchX(this, 610.0);
        goto LABEL_6;
      default:
        switch ( aScreens[226 * this->CurrentScreen + 10 + 18 * this->CurrentOption] )
        {
          case 2:
            v6 = CText::Get(&TheText, "FEH_BPO");
            v8 = CMenuManager::StretchX(this, 610.0);
            goto LABEL_6;
          case 5:
          case 7:
          case 8:
          case 9:
            v6 = CText::Get(&TheText, "FEH_JMP");
            v8 = CMenuManager::StretchX(this, 610.0);
            goto LABEL_6;
          case 6:
            v6 = CText::Get(&TheText, "FEH_SNC");
            v8 = CMenuManager::StretchX(this, 610.0);
            goto LABEL_6;
          case 59:
            v6 = CText::Get(&TheText, "FET_MIG");
            v8 = CMenuManager::StretchX(this, 610.0);
            goto LABEL_6;
          default:
            v16 = "FEH_SSA";
            if ( this->CurrentScreen )
              v16 = "FET_MIG";
            v17 = CText::Get(&TheText, (const unsigned __int8 *)v16);
            CurrentScreen = (unsigned __int8)this->CurrentScreen;
            v19 = CMenuManager::StretchX(this, 610.0);
            screenHeight = (float)RsGlobal.screenHeight;
            if ( CurrentScreen == 5 )
            {
              v20 = this;
              v21 = 0x40000000;
            }
            else
            {
              v21 = 1092616192;
              v20 = this;
            }
            v10 = CMenuManager::StretchY(v20, *(float *)&v21);
            v11 = v19;
            v12 = v17;
            break;
        }
        break;
    }
  }
  CFont::PrintStringFromBottom(v11, screenHeight - v10, v12);
}
// 4352E8: variable 'v7' is possibly undefined
// 43539C: variable 'v15' is possibly undefined

//----- (004356E0) --------------------------------------------------------
void __fastcall CMenuManager::CheckCodesForControls(CMenuManager *this, int WhereInputHasCameFrom)
{
  eControllerType v2; // r8
  Int32 OptionToChange; // r9
  RwInt32 v6; // r1
  int v7; // r6
  RwInt32 JoyButtonJustClicked; // r2
  e_ControllerAction v9; // r1
  eControllerType v10; // r3
  RwInt32 v11; // r2

  OptionToChange = this->OptionToChange;
  if ( WhereInputHasCameFrom )
  {
    if ( WhereInputHasCameFrom == 3 )
    {
      CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 1, 0.0, 1.0);
      v2 = JOY_STICK;
    }
    else if ( WhereInputHasCameFrom == 2 )
    {
      CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 1, 0.0, 1.0);
      v2 = MOUSE;
    }
  }
  else
  {
    v6 = *this->pControlEdit;
    switch ( v6 )
    {
      case 1000:
        CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 4, 0.0, 1.0);
        this->m_DeleteAllNextDefine = 0;
        *(_WORD *)&this->m_bJustEnteredOption = 0;
        this->pControlEdit = 0;
        this->m_KeyPressedCode = -1;
        return;
      case 1001:
      case 1002:
      case 1003:
      case 1009:
      case 1052:
      case 1053:
      case 1054:
        goto LABEL_6;
      case 1004:
      case 1005:
      case 1006:
      case 1007:
      case 1008:
      case 1010:
      case 1011:
      case 1012:
      case 1013:
      case 1014:
      case 1015:
      case 1016:
      case 1017:
      case 1018:
      case 1019:
      case 1020:
      case 1021:
      case 1022:
      case 1023:
      case 1024:
      case 1025:
      case 1026:
      case 1027:
      case 1028:
      case 1029:
      case 1030:
      case 1031:
      case 1032:
      case 1033:
      case 1034:
      case 1035:
      case 1036:
      case 1037:
      case 1038:
      case 1039:
      case 1040:
      case 1041:
      case 1042:
      case 1043:
      case 1044:
      case 1045:
      case 1046:
      case 1047:
      case 1048:
      case 1049:
      case 1050:
      case 1051:
        goto LABEL_20;
      default:
        if ( !v6 )
        {
LABEL_6:
          sub_18FDC4(&AudioEngine, 4, 0.0, 1.0);
          return;
        }
LABEL_20:
        v2 = KEYBOARD;
        CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 1, 0.0, 1.0);
        if ( CControllerConfigManager::GetControllerKeyAssociatedWithAction(
               &ControlsManager,
               (e_ControllerAction)OptionToChange,
               KEYBOARD) != 1056
          && CControllerConfigManager::GetControllerKeyAssociatedWithAction(
               &ControlsManager,
               (e_ControllerAction)OptionToChange,
               KEYBOARD) != *this->pControlEdit )
        {
          v2 = OPTIONAL_EXTRA_KEY;
        }
        break;
    }
  }
  if ( this->m_DeleteAllNextDefine )
  {
    CControllerConfigManager::ClearSettingsAssociatedWithAction(
      &ControlsManager,
      (e_ControllerAction)this->OptionToChange,
      KEYBOARD);
    CControllerConfigManager::ClearSettingsAssociatedWithAction(
      &ControlsManager,
      (e_ControllerAction)this->OptionToChange,
      OPTIONAL_EXTRA_KEY);
    CControllerConfigManager::ClearSettingsAssociatedWithAction(
      &ControlsManager,
      (e_ControllerAction)this->OptionToChange,
      MOUSE);
    CControllerConfigManager::ClearSettingsAssociatedWithAction(
      &ControlsManager,
      (e_ControllerAction)this->OptionToChange,
      JOY_STICK);
    this->m_DeleteAllNextDefine = 0;
  }
  CControllerConfigManager::ClearSettingsAssociatedWithAction(&ControlsManager, (e_ControllerAction)OptionToChange, v2);
  switch ( WhereInputHasCameFrom )
  {
    case 0:
      CControllerConfigManager::DeleteMatchingActionInitiators(
        &ControlsManager,
        (e_ControllerAction)OptionToChange,
        *this->pControlEdit,
        KEYBOARD);
      CControllerConfigManager::DeleteMatchingActionInitiators(
        &ControlsManager,
        (e_ControllerAction)OptionToChange,
        *this->pControlEdit,
        OPTIONAL_EXTRA_KEY);
      v11 = *this->pControlEdit;
LABEL_17:
      CControllerConfigManager::SetControllerKeyAssociatedWithAction(
        &ControlsManager,
        (e_ControllerAction)OptionToChange,
        v11,
        v2);
      break;
    case 3:
      v7 = 6824;
      JoyButtonJustClicked = this->JoyButtonJustClicked;
      v9 = OptionToChange;
      v10 = JOY_STICK;
      goto LABEL_16;
    case 2:
      v7 = 6820;
      JoyButtonJustClicked = this->MouseButtonJustClicked;
      v9 = OptionToChange;
      v10 = MOUSE;
LABEL_16:
      CControllerConfigManager::DeleteMatchingActionInitiators(&ControlsManager, v9, JoyButtonJustClicked, v10);
      v11 = *(_DWORD *)(&this->BriefDisplay + v7);
      goto LABEL_17;
  }
  *(_WORD *)&this->m_bJustEnteredOption = 0;
  this->pControlEdit = 0;
  this->m_KeyPressedCode = -1;
  sub_19F248();
}
// 435826: variable 'v2' is possibly undefined

//----- (00435968) --------------------------------------------------------
void __fastcall CMenuManager::SaveLoadFileError_SetUpErrorScreen(CMenuManager *this)
{
  int8 v1; // r1

  switch ( PcSaveHelper.ErrorCode )
  {
    case 1:
    case 2:
    case 3:
      v1 = 30;
      break;
    case 4:
    case 5:
    case 6:
      v1 = 31;
      break;
    case 7:
      v1 = 32;
      break;
    case 8:
    case 9:
    case 0xA:
      v1 = 29;
      break;
  }
  sub_19396C(this, v1);
}

//----- (004359A4) --------------------------------------------------------
bool __fastcall CMenuManager::CheckHover(CMenuManager *this, Int32 bleft, Int32 bright, Int32 btop, Int32 bbottom)
{
  Int32 MousePosX; // r12
  Int32 MousePosY; // r0
  _BOOL4 result; // r0

  MousePosX = this->MousePosX;
  result = 0;
  if ( MousePosX > bleft && MousePosX < bright )
  {
    MousePosY = this->MousePosY;
    if ( MousePosY > btop && MousePosY < bbottom )
      return 1;
  }
  return result;
}

//----- (004359CC) --------------------------------------------------------
void __fastcall CMenuManager::SaveStatsToFile(CMenuManager *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d9
  const unsigned __int8 *v4; // r1
  GxtChar *v5; // r8
  FILE *v6; // r0
  FILE *v7; // r5
  int (__fastcall *v8)(Char *); // r4
  GxtChar *v9; // r0
  int v10; // r6
  Char *v11; // r0
  const char *v12; // r0
  GxtChar *v13; // r0
  Char *v14; // r0
  GxtChar *v15; // r0
  Char *v16; // r0
  int (__fastcall *v17)(Char *); // r4
  Char *v18; // r0
  const char *v19; // r0
  GxtChar *v20; // r0
  Char *v21; // r0
  const GxtChar *CriminalRatingString; // r0
  Char *v23; // r4
  Int32 CriminalRatingNumber; // r0
  uint8 v25; // r11
  Int32 v26; // r4
  const char *v27; // r1
  GxtChar *v28; // r0
  Char *v29; // r0
  Int32 v30; // r8
  const char *v31; // r6
  Char *v32; // r9
  Char *i; // r0
  CMenuManager *v34; // [sp+4h] [bp-74h]
  int v35; // [sp+28h] [bp-50h]
  int v36[3]; // [sp+38h] [bp-40h] BYREF

  CFileMgr::SetDirMyDocuments();
  v36[1] = (int)&loc_455440;
  v36[0] = 1147096910;
  v4 = "ITBEG";
  if ( CStats::LastMissionPassedName[0] )
    v4 = CStats::LastMissionPassedName;
  v5 = CText::Get(&TheText, v4);
  v6 = fopen("stats.html", "w");
  v7 = v6;
  if ( v6 )
  {
    v34 = this;
    fwrite("<title>Grand Theft Auto San Andreas Stats</title>\n", 0x32u, 1u, v6);
    fwrite(
      "<body bgcolor=\"#000000\" leftmargin=\"10\" topmargin=\"10\" marginwidth=\"10\" marginheight=\"10\">\n",
      0x5Bu,
      1u,
      v7);
    fwrite("<table width=\"560\" align=\"center\" border=\"0\" cellpadding=\"5\" cellspacing=\"0\">\n", 0x4Eu, 1u, v7);
    fwrite("<tr align=\"center\" valign=\"top\"> \n", 0x22u, 1u, v7);
    fwrite(
      "<td height=\"59\" colspan=\"2\" bgcolor=\"#000000\"><div align=\"center\"><font color=\"#FFFFFF\" size=\"5\" face=\"Arial, \n",
      0x6Fu,
      1u,
      v7);
    fwrite(
      "Helvetica, sans-serif\">-------------------------------------------------------------------</font><font \n",
      0x68u,
      1u,
      v7);
    fwrite("size=\"5\" face=\"Arial, Helvetica, sans-serif\"><br>\n", 0x32u, 1u, v7);
    fwrite("<strong><font color=\"#FFFFFF\">GRAND THEFT AUTO SAN ANDREAS ", 0x3Bu, 1u, v7);
    v8 = (int (__fastcall *)(Char *))*((_DWORD *)RwEngineInstance + 71);
    v9 = CText::Get(&TheText, "FEH_STA");
    v10 = 0;
    v11 = GxtCharToAscii(v9, 0);
    v12 = (const char *)v8(v11);
    fprintf(v7, "%s</font></strong><br><font\n", v12);
    fwrite(
      "color=\"#FFFFFF\">-------------------------------------------------------------------</font></font></div></td> </tr>\n",
      0x73u,
      1u,
      v7);
    fwrite(
      "<tr align=\"center\" valign=\"top\" bgcolor=\"#000000\">     <td height=\"22\" colspan=\"2\">&nbsp;</td>  </tr>\n",
      0x66u,
      1u,
      v7);
    fwrite("<tr align=\"center\" valign=\"top\" bgcolor=\"#000000\"> \n", 0x34u, 1u, v7);
    v13 = CText::Get(&TheText, "FES_DAT");
    v14 = GxtCharToAscii(v13, 0);
    fprintf(
      v7,
      "<td height=\"40\" colspan=\"2\"> <p><font color=\"#F0000C\" size=\"2\" face=\"Arial, Helvetica, sans-serif\"><stro"
      "ng><font color=\"#F0000C\" size=\"1\">%s: \n",
      (const char *)v14);
    v15 = CText::Get(&TheText, "FES_CMI");
    v16 = GxtCharToAscii(v15, 0);
    fprintf(v7, "%s</font><br>        %s: </strong>", (const char *)v36, (const char *)v16);
    v17 = (int (__fastcall *)(Char *))*((_DWORD *)RwEngineInstance + 71);
    v18 = GxtCharToAscii(v5, 0);
    v19 = (const char *)v17(v18);
    fprintf(v7, "%s<strong><br></strong> </font></p></td></tr>\n", v19);
    fwrite(
      "<tr align=\"center\" valign=\"top\" bgcolor=\"#000000\"> <td height=\"5\" colspan=\"2\"></td> </tr> <tr align=\"ce"
      "nter\" valign=\"top\" bgcolor=\"#000000\"> \n",
      0x8Eu,
      1u,
      v7);
    fwrite(&unk_6180EB, 0x5Cu, 1u, v7);
    v20 = CText::Get(&TheText, "CRIMRA");
    v21 = GxtCharToAscii(v20, 0);
    fprintf(
      v7,
      "<td height=\"20\" colspan=\"2\"><font color=\"#F0000C\" size=\"2\" face=\"Arial, Helvetica, sans-serif\"><strong>%s</strong>\n",
      (const char *)v21);
    CriminalRatingString = CStats::FindCriminalRatingString();
    GxtCharStrcpy(gGxtString, CriminalRatingString);
    v23 = GxtCharToAscii(gGxtString, 0);
    CriminalRatingNumber = CStats::FindCriminalRatingNumber();
    fprintf(
      v7,
      "%s (%d)</font></td>  </tr>  <tr align=\"left\" valign=\"top\" bgcolor=\"#000000\"><td height=\"10\" colspan=\"2\"></td>  </tr>\n",
      (const char *)v23,
      CriminalRatingNumber);
    v2.n64_u32[0] = 1120403456;
    while ( 1 )
    {
      v25 = v10;
      v35 = v10;
      v26 = CStats::ConstructStatLine((Int32)&elf_hash_chain[8525] + 3, v10);
      fwrite(
        "</font></strong></div></td> </tr> <tr align=\"left\" valign=\"top\" bgcolor=\"#000000\">  <td height=\"25\" cols"
        "pan=\"2\"></td> </tr>\n",
        0x7Cu,
        1u,
        v7);
      fwrite(
        "<tr align=\"left\" valign=\"top\"><td height=\"30\" bgcolor=\"#000000\"><font color=\"#009900\" size=\"4\" face="
        "\"Arial, Helvetica, sans-serif\"><strong>\n",
        0x8Cu,
        1u,
        v7);
      switch ( (char)v10 )
      {
        case 0:
          v27 = "FES_PLA";
          goto LABEL_14;
        case 1:
          v27 = "FES_MON";
          goto LABEL_14;
        case 2:
          v27 = "FES_WEA";
          goto LABEL_14;
        case 3:
          v27 = "FES_GAN";
          goto LABEL_14;
        case 4:
          v27 = "FES_CRI";
          goto LABEL_14;
        case 5:
          v27 = "FES_ACH";
          goto LABEL_14;
        case 6:
          v27 = "FES_MIS";
          goto LABEL_14;
        case 7:
          v27 = "FES_MSC";
LABEL_14:
          v28 = CText::Get(&TheText, (const unsigned __int8 *)v27);
          v29 = GxtCharToAscii(v28, 0);
          fputs((const char *)v29, v7);
          break;
        default:
          break;
      }
      fwrite(
        "</strong></font></td> <td width=\"500\" align=\"right\" valign=\"middle\" bgcolor=\"#000000\"> <div align=\"righ"
        "t\"><strong><font color=\"#FF0CCC\">\n",
        0x89u,
        1u,
        v7);
      if ( v26 >= 1 )
        break;
LABEL_31:
      v10 = v35 + 1;
      if ( (unsigned __int8)(v35 + 1) >= 8u )
      {
        fwrite(
          "</font></strong></div></td> </tr> <tr align=\"left\" valign=\"top\" bgcolor=\"#000000\">  <td height=\"10\" co"
          "lspan=\"2\"></td> </tr>\n",
          0x7Cu,
          1u,
          v7);
        fwrite(
          "</table><br><table width=\"560\" border=\"0\"  align=\"center\" cellspacing=\"0\" cellpadding=\"5\"><tr align="
          "\"center\" valign=\"middle\" bgcolor=\"#000000\">",
          0x8Fu,
          1u,
          v7);
        fwrite(
          "<td><font color=\"#F0000C\" size=\"2\" face=\"Arial, Helvetica, sans-serif\"><a href=\"http://www.rockstargame"
          "s.com/sanandreas\">rockstargames.com/sanandreas</a></font></td>\n",
          0xA6u,
          1u,
          v7);
        fwrite(
          "<td><font color=\"#F0000C\" size=\"2\" face=\"Arial, Helvetica, sans-serif\"><a href=\"http://www.rockstargame"
          "s.com\">rockstargames.com</a></font></td>\n",
          0x90u,
          1u,
          v7);
        fwrite(
          "<td><font color=\"#F0000C\" size=\"2\" face=\"Arial, Helvetica, sans-serif\">&nbsp;<a href=\"http://www.rockst"
          "arnorth.com\">rockstarnorth.com</a></font></td></tr>\n",
          0x9Bu,
          1u,
          v7);
        fwrite("</table>\n</body>\n", 0x11u, 1u, v7);
        fclose(v7);
        this = v34;
        goto LABEL_33;
      }
    }
    v30 = 0;
LABEL_17:
    CStats::ConstructStatLine(v30, v25);
    v31 = (const char *)GxtCharToAscii(gGxtString, 0);
    if ( *v31 )
      fwrite(
        "</font></strong></div></td> </tr> <tr align=\"left\" valign=\"top\" bgcolor=\"#000000\">  <td height=\"10\" cols"
        "pan=\"2\"></td> </tr>\n",
        0x7Cu,
        1u,
        v7);
    fwrite(
      "<tr align=\"left\" valign=\"top\"><td width=\"500\" height=\"22\" bgcolor=\"#555555\"><font color=\"#FFFFFF\" size"
      "=\"2\" face=\"Arial, Helvetica, sans-serif\"><strong>\n",
      0x98u,
      1u,
      v7);
    if ( *v31 )
      fputs(v31, v7);
    else
      fputc(32, v7);
    fwrite(
      "</strong></font></td> <td width=\"500\" align=\"right\" valign=\"middle\" bgcolor=\"#555555\"> <div align=\"right\""
      "><strong><font color=\"#FFFFFF\">\n",
      0x89u,
      1u,
      v7);
    v32 = GxtCharToAscii(gGxtString2, 0);
    if ( CStats::m_ThisStatIsABarChart )
    {
      v1.n64_f32[0] = (float)((float)atoi((const char *)v32) / 1000.0) * 100.0;
      v1.n64_u64[0] = vmin_f32(v1, v2).n64_u64[0];
      sprintf(v32, "%0.0f%%", v1.n64_f32[0]);
    }
    for ( i = v32; ; ++i )
    {
      if ( *i == 124 )
      {
        *i = -70;
      }
      else if ( !*i )
      {
        fputs((const char *)v32, v7);
        if ( ++v30 == v26 )
          goto LABEL_31;
        goto LABEL_17;
      }
    }
  }
LABEL_33:
  CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
  this->DefaultsFadeCounter = 300;
  this->CurrentHelperMessage = 6;
}
// 435D7A: variable 'v1' is possibly undefined
// 435D7A: variable 'v2' is possibly undefined
// 10168: using guessed type int elf_hash_chain[22025];
// 61CADE: using guessed type char byte_61CADE;

//----- (00435FE4) --------------------------------------------------------
void __fastcall CMenuManager::SetHelperText(CMenuManager *this, int helper_type)
{
  this->DefaultsFadeCounter = 300;
  this->CurrentHelperMessage = helper_type;
}

//----- (00435FF6) --------------------------------------------------------
void __fastcall CMenuManager::ResetHelperText(CMenuManager *this)
{
  this->DefaultsFadeCounter = 300;
  this->CurrentHelperMessage = 0;
}

//----- (0043600C) --------------------------------------------------------
bool8 __fastcall CMenuManager::ProcessPCMenuOptions(CMenuManager *this, int8 LeftRight, bool8 EnterMenuOption)
{
  __int16 CurrentScreen; // r2
  Int32 CurrentOption; // r0
  int v6; // r3
  bool8 v7; // r8
  int v8; // r1
  MobileSettings::Setting *v9; // r0
  int32 *p_value; // r0
  int32 value; // t1
  int32 v12; // r3
  CMenuManager *v14; // r0
  int8 v15; // r1
  int8 v16; // r0
  FxQuality_e v17; // r1
  bool v18; // r0
  int8 v19; // r0

  CurrentScreen = this->CurrentScreen;
  CurrentOption = this->CurrentOption;
  v6 = (unsigned __int8)aScreens[226 * CurrentScreen + 10 + 18 * CurrentOption];
  v7 = 1;
  switch ( aScreens[226 * CurrentScreen + 10 + 18 * CurrentOption] )
  {
    case 6:
      v7 = 1;
      this->DisplayWarningScreenForUserTrackScanning = 1;
      return v7;
    case 7:
      v14 = this;
      if ( this->m_ControlMethod == 1 )
        v15 = 41;
      else
        v15 = 40;
      goto LABEL_50;
    case 8:
      this->RedefiningControls = 0;
      CMenuManager::SwitchToNewScreen(this, 39);
      this->ListSelection = 0;
      return 1;
    case 9:
      v7 = 1;
      this->RedefiningControls = 1;
      CMenuManager::SwitchToNewScreen(this, 39);
      this->ListSelection = 0;
      return v7;
    case 24:
      this->m_PrefsFrameLimiter = this->m_PrefsFrameLimiter == 0;
      goto LABEL_4;
    case 37:
      v7 = 1;
      if ( !this->m_PrefsLanguage )
        return v7;
      this->bFrontEnd_ReloadObrTxtGxt = 1;
      v16 = 0;
      goto LABEL_31;
    case 38:
      v7 = 1;
      if ( this->m_PrefsLanguage == 1 )
        return v7;
      this->bFrontEnd_ReloadObrTxtGxt = 1;
      this->m_PrefsLanguage = 1;
      goto LABEL_32;
    case 39:
      v7 = 1;
      if ( this->m_PrefsLanguage == 2 )
        return v7;
      v16 = 2;
      this->bFrontEnd_ReloadObrTxtGxt = 1;
      goto LABEL_31;
    case 40:
      v7 = 1;
      if ( this->m_PrefsLanguage == 3 )
        return v7;
      this->bFrontEnd_ReloadObrTxtGxt = 1;
      v16 = 3;
      goto LABEL_31;
    case 41:
      v7 = 1;
      if ( this->m_PrefsLanguage == 4 )
        return v7;
      this->bFrontEnd_ReloadObrTxtGxt = 1;
      v16 = 4;
      goto LABEL_31;
    case 42:
      v7 = 1;
      if ( this->m_PrefsLanguage == 5 )
        return v7;
      this->bFrontEnd_ReloadObrTxtGxt = 1;
      v16 = 5;
      goto LABEL_31;
    case 43:
      v7 = 1;
      if ( this->m_PrefsLanguage == 6 )
        return v7;
      this->bFrontEnd_ReloadObrTxtGxt = 1;
      v16 = 6;
      goto LABEL_31;
    case 44:
      v7 = 1;
      if ( this->m_PrefsLanguage == 7 )
        return v7;
      this->bFrontEnd_ReloadObrTxtGxt = 1;
      v16 = 7;
LABEL_31:
      this->m_PrefsLanguage = v16;
LABEL_32:
      CMenuManager::InitialiseChangedLanguageSettings(this, 0);
      Menu_SaveSettings();
      return v7;
    case 45:
      if ( Fx_c::GetFxQuality(&g_fx) == FX_QUALITY_VERY_HIGH )
      {
        v17 = FX_QUALITY_LOW;
      }
      else if ( Fx_c::GetFxQuality(&g_fx) == FX_QUALITY_HIGH )
      {
        v17 = FX_QUALITY_VERY_HIGH;
      }
      else if ( Fx_c::GetFxQuality(&g_fx) == FX_QUALITY_MEDIUM )
      {
        v17 = FX_QUALITY_HIGH;
      }
      else
      {
        if ( Fx_c::GetFxQuality(&g_fx) )
          goto LABEL_4;
        v17 = FX_QUALITY_MEDIUM;
      }
      Fx_c::SetFxQuality(&g_fx, v17);
LABEL_4:
      Menu_SaveSettings();
      return 1;
    case 46:
      if ( !this->m_MainMenu )
        return 1;
      v18 = !this->m_PrefsMipMap;
      this->m_PrefsMipMap = v18;
      RwTextureSetMipmapping(v18);
      goto LABEL_4;
    case 47:
    case 59:
    case 62:
    case 85:
      return v7;
    case 48:
      v7 = 1;
      this->CanBeDefined = 1;
      this->OptionToChange = CurrentOption;
      *(_WORD *)&this->m_bJustEnteredOption = 257;
      this->pControlEdit = &this->m_KeyPressedCode;
      return v7;
    case 49:
      MousePointerStateHelper.m_bUpAndDownInverted ^= 1u;
      goto LABEL_4;
    case 50:
      this->m_PrefsJoyLeftXInvert ^= 1u;
      goto LABEL_4;
    case 51:
      this->m_PrefsJoyLeftYInvert ^= 1u;
      goto LABEL_4;
    case 52:
      this->m_PrefsJoyRightXInvert ^= 1u;
      goto LABEL_4;
    case 53:
      this->m_PrefsJoyRightYInvert ^= 1u;
      goto LABEL_4;
    case 54:
      this->m_PrefsJoyLeftAxisInvert ^= 1u;
      goto LABEL_4;
    case 55:
      this->m_PrefsJoyRightAxisInvert ^= 1u;
      goto LABEL_4;
    case 56:
      v14 = this;
      v15 = 44;
      goto LABEL_50;
    case 57:
      if ( IsPlayingGame() )
        return 1;
      v7 = 1;
      if ( CGenericGameStorage::CheckSlotDataValid(9, 1) )
        goto LABEL_68;
      return v7;
    case 58:
      v14 = this;
      v15 = -2;
LABEL_50:
      CMenuManager::SwitchToNewScreen(v14, v15);
      return 1;
    case 60:
      CMenuManager::SetDefaultPreferences(this, aScreens[226 * CurrentScreen + 56]);
      if ( aScreens[226 * this->CurrentScreen + 56] == 37 )
        CControllerConfigManager::ReinitControls(&ControlsManager);
      Menu_SaveSettings();
      CMenuManager::SwitchToNewScreen(this, aScreens[226 * this->CurrentScreen + 56]);
      this->DefaultsFadeCounter = 300;
      this->CurrentHelperMessage = 2;
      return 1;
    case 61:
      goto LABEL_4;
    case 63:
      if ( !this->m_ControlMethod )
        goto LABEL_4;
      return 1;
    case 66:
      v19 = this->m_PrefsPlayMode + LeftRight;
      if ( (v19 & 0x80) != 0 )
        v19 = 2;
      if ( v19 > 2 )
        v19 = 0;
      this->m_PrefsPlayMode = v19;
      goto LABEL_4;
    case 67:
      this->m_PrefsAutoMediaScan ^= 1u;
      goto LABEL_4;
    case 68:
      this->m_PrefsSavePhotosToGallery ^= 1u;
      goto LABEL_4;
    case 69:
      CAdjustableHUD::Toggle();
      return 1;
    case 71:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
      v8 = v6 - 71;
      v9 = &MobileSettings::settings[v6 - 71];
      value = v9->value;
      p_value = &v9->value;
      v12 = p_value[3];
      *p_value = value + 1;
      if ( value >= v12 )
        *p_value = MobileSettings::settings[v8].min;
      goto LABEL_4;
    case 83:
      OS_ServiceRateApp((const unsigned __int8 *)&byte_61CADE);
      goto LABEL_65;
    case 84:
LABEL_65:
      this->CurrentScreen = this->PreviousScreen;
      if ( !WasDoingResumeBeforeRate )
      {
        CMenuManager::DoSettingsBeforeStartingAGame(this);
        return 1;
      }
      if ( IsPlayingGame() )
        return 1;
      v7 = 1;
      if ( CGenericGameStorage::CheckSlotDataValid(9, 1) )
      {
LABEL_68:
        v7 = 1;
        gMobileMenu.SelectedSlot = 9;
        this->CurrentScreen = 13;
      }
      return v7;
    default:
      return 0;
  }
}
// 61CADE: using guessed type char byte_61CADE;

//----- (004364C4) --------------------------------------------------------
bool8 __fastcall CMenuManager::CheckRedefineControlInput(CMenuManager *this)
{
  bool *p_m_bJustEnteredOption; // r11
  int v4; // r9
  RwInt32 *v5; // r0
  eMouseButtons *p_MouseButtonJustClicked; // r8
  eJOY_BUTTONS JoyButtonJustDown; // r0
  int v8; // r1
  RwInt32 v9; // r3
  bool v10; // zf
  int v11; // r0

  if ( !this->m_EditingControlOptions )
    return this->pControlEdit != 0;
  p_m_bJustEnteredOption = &this->m_bJustEnteredOption;
  if ( this->m_bJustEnteredOption )
  {
    *p_m_bJustEnteredOption = 0;
    return this->pControlEdit != 0;
  }
  v4 = 1;
  v5 = CPad::EditCodesForControls(this->pControlEdit, 1);
  this->MouseButtonJustClicked = NO_BUTTON;
  this->JoyButtonJustClicked = NO_JOYBUTTONS;
  this->pControlEdit = v5;
  CPad::GetPad(0);
  p_MouseButtonJustClicked = &this->MouseButtonJustClicked;
  if ( !CPad::NewMouseControllerState.m_bLeftButton || CPad::OldMouseControllerState.m_bLeftButton )
  {
    CPad::GetPad(0);
    if ( !CPad::NewMouseControllerState.m_bRightButton || CPad::OldMouseControllerState.m_bRightButton )
    {
      CPad::GetPad(0);
      if ( !CPad::NewMouseControllerState.m_bMiddleButton || CPad::OldMouseControllerState.m_bMiddleButton )
      {
        CPad::GetPad(0);
        if ( !CPad::NewMouseControllerState.m_bWheelMovedUp || CPad::OldMouseControllerState.m_bWheelMovedUp )
        {
          CPad::GetPad(0);
          if ( !CPad::NewMouseControllerState.m_bWheelMovedDown || CPad::OldMouseControllerState.m_bWheelMovedDown )
          {
            CPad::GetPad(0);
            if ( !CPad::NewMouseControllerState.m_bMsFirstXButton || CPad::OldMouseControllerState.m_bMsFirstXButton )
            {
              CPad::GetPad(0);
              if ( !CPad::NewMouseControllerState.m_bMsSecondXButton || CPad::OldMouseControllerState.m_bMsSecondXButton )
                goto LABEL_26;
              v4 = 7;
            }
            else
            {
              v4 = 6;
            }
          }
          else
          {
            v4 = 5;
          }
        }
        else
        {
          v4 = 4;
        }
      }
      else
      {
        v4 = 2;
      }
    }
    else
    {
      v4 = 3;
    }
  }
  *p_MouseButtonJustClicked = v4;
LABEL_26:
  JoyButtonJustDown = CControllerConfigManager::GetJoyButtonJustDown(&ControlsManager);
  this->JoyButtonJustClicked = JoyButtonJustDown;
  v8 = 2;
  v9 = *this->pControlEdit;
  if ( *p_MouseButtonJustClicked == NO_BUTTON )
    v8 = 3;
  if ( v9 != 1056 )
    v8 = 0;
  if ( this->CanBeDefined )
  {
    if ( this->m_DeleteAllBoundControls )
    {
      CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 1, 0.0, 1.0);
      this->CanBeDefined = 0;
      this->m_DeleteAllNextDefine = 1;
      this->m_DeleteAllBoundControls = 0;
    }
    else
    {
      v11 = JoyButtonJustDown | *p_MouseButtonJustClicked;
      v10 = v11 == 0;
      if ( !v11 )
        v10 = v9 == 1056;
      if ( !v10 )
        CMenuManager::CheckCodesForControls(this, v8);
      this->JustExitedRedefine = 1;
    }
  }
  else
  {
    this->pControlEdit = 0;
    this->m_EditingControlOptions = 0;
    this->m_KeyPressedCode = -1;
    *p_m_bJustEnteredOption = 0;
  }
  return this->pControlEdit != 0;
}

//----- (004366E0) --------------------------------------------------------
void __fastcall CMenuManager::ProcessMissionPackNewGame(CMenuManager *this)
{
  int v1; // r4
  int v2; // r6
  u_native v3; // r0
  u_native v4; // r8
  int32 TotalSize; // r9
  int v6; // r10
  int v7; // r11
  int v8; // r6
  bool v9; // zf
  int v10; // r5
  int v11; // r1
  int v12; // r0
  char *v13; // r1
  unsigned __int8 v15; // [sp+8h] [bp-128h]
  unsigned __int8 pData; // [sp+Fh] [bp-121h] BYREF
  char v17[256]; // [sp+10h] [bp-120h] BYREF

  v1 = 0;
  v2 = 0;
  this->MissionPack[15].id = 0;
  this->MissionPack[16].id = 0;
  this->MissionPack[17].id = 0;
  this->MissionPack[18].id = 0;
  this->MissionPack[19].id = 0;
  this->MissionPack[2].id = 0;
  this->MissionPack[1].id = 0;
  this->MissionPack[3].id = 0;
  this->MissionPack[4].id = 0;
  this->MissionPack[5].id = 0;
  this->MissionPack[6].id = 0;
  this->MissionPack[7].id = 0;
  this->MissionPack[8].id = 0;
  this->MissionPack[9].id = 0;
  this->MissionPack[10].id = 0;
  this->MissionPack[11].id = 0;
  this->MissionPack[12].id = 0;
  this->MissionPack[13].id = 0;
  this->MissionPack[14].id = 0;
  this->MissionPack[0].id = 0;
  this->MissionPack[21].id = 0;
  this->MissionPack[20].id = 0;
  this->MissionPack[22].id = 0;
  this->MissionPack[23].id = 0;
  this->MissionPack[24].id = 0;
  v15 = 0;
  do
  {
    CFileMgr::SetDirMyDocuments();
    sprintf(gString, "MPACK//MPACK%d//MPACK.DAT", v1);
    v3 = CFileMgr::OpenFile(gString, "rb");
    v4 = v3;
    if ( v3 )
    {
      TotalSize = CFileMgr::GetTotalSize(v3);
      if ( TotalSize >= 1 )
      {
        v6 = 1;
        v7 = 0;
        v8 = 0;
        do
        {
          CFileMgr::ReadBytes(v4, &pData, 1);
          v9 = pData == 10;
          if ( pData != 10 )
            v9 = pData == 13;
          if ( !v9 )
          {
            if ( pData == 35 )
            {
              if ( v8 << 24 )
              {
                v10 = v6 << 24;
                v17[(unsigned __int8)v8] = 0;
                if ( v6 << 24 )
                  this->MissionPack[v15].id = atoi(v17);
                else
                  strcpy((char *)this->MissionPack[v15++].name, v17);
                v6 = 0;
                v8 = 0;
                if ( !v10 )
                  v6 = 1;
              }
              else
              {
                v8 = 0;
              }
            }
            else
            {
              v11 = (unsigned __int8)v8++;
              v17[v11] = pData;
            }
          }
          ++v7;
        }
        while ( TotalSize > (unsigned __int8)v7 );
      }
      CFileMgr::CloseFile(v4);
      v2 = 1;
    }
    ++v1;
  }
  while ( v1 != 25 );
  if ( v2 << 24 )
  {
    CMenuManager::SwitchToNewScreen(this, 7);
  }
  else
  {
    CMenuManager::SwitchToNewScreen(this, 6);
    v12 = 5393759;
    v13 = &aScreens[226 * this->CurrentScreen + 11];
    v9 = CGame::bMissionPackGame == 0;
    *(_DWORD *)v13 = 1515406662;
    if ( v9 )
      v12 = 5394783;
    *((_DWORD *)v13 + 1) = v12;
  }
}
// 4366E0: using guessed type char var_120[256];

//----- (00436900) --------------------------------------------------------
bool8 __fastcall CMenuManager::CheckMissionPackValidMenu(CMenuManager *this)
{
  u_native v1; // r4
  u_native v2; // r5
  bool v3; // zf
  bool8 v4; // r4
  CPad *Pad; // r0

  CFileMgr::SetDirMyDocuments();
  sprintf(gString, "MPACK//MPACK%d//SCR.SCM", CGame::bMissionPackGame);
  v1 = CFileMgr::OpenFile(gString, "rb");
  sprintf(gString, "MPACK//MPACK%d//TEXT.GXT", CGame::bMissionPackGame);
  v2 = CFileMgr::OpenFile(gString, "rb");
  CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
  v3 = v1 == 0;
  if ( v1 )
    v3 = v2 == 0;
  if ( v3 )
  {
    if ( v1 )
      CFileMgr::CloseFile(v1);
    if ( v2 )
      CFileMgr::CloseFile(v2);
    CTimer::StartUserPause();
    while ( 1 )
    {
      CPad::UpdatePads();
      CMenuManager::MessageScreen(&FrontEndMenuManager, "NO_PAK", 1, 0);
      DoRWStuffStartOfFrame(0, 0, 0, 0, 0, 0, 0);
      DoRWStuffEndOfFrame(0);
      CPad::GetPad(0);
      if ( LIB_KeyboardPressed(KK_ENTER) )
        break;
      Pad = CPad::GetPad(0);
      if ( Pad->NewState.ButtonCross )
      {
        if ( !Pad->OldState.ButtonCross )
          break;
      }
    }
    CTimer::EndUserPause();
    v4 = 0;
    CGame::bMissionPackGame = 0;
    CMenuManager::DoSettingsBeforeStartingAGame(&FrontEndMenuManager);
  }
  else
  {
    CFileMgr::CloseFile(v1);
    CFileMgr::CloseFile(v2);
    return 1;
  }
  return v4;
}
// 61CADE: using guessed type char byte_61CADE;

//----- (00436A50) --------------------------------------------------------
void CHud::Shutdown()
{
  int32 TxdSlot; // r0

  CSprite2d::Delete(CHud::Sprites);
  CSprite2d::Delete(&CHud::Sprites[1]);
  CSprite2d::Delete(&CHud::Sprites[2]);
  CSprite2d::Delete(&CHud::Sprites[3]);
  CSprite2d::Delete(&CHud::Sprites[4]);
  CSprite2d::Delete(&CHud::Sprites[5]);
  TxdSlot = CTxdStore::FindTxdSlot((const unsigned __int8 *)&off_436A98);
  sub_197460(TxdSlot);
}
// 436A98: using guessed type void *off_436A98;

//----- (00436A9C) --------------------------------------------------------
void CHud::ReInitialise()
{
  CPlayerInfo *v0; // r1
  Int32 LastTimeEnergyLost; // r2
  Int32 DisplayScore; // r1

  CHud::m_Wants_To_Draw_3dMarkers = 1;
  CHud::m_Wants_To_Draw_Hud = 1;
  CHud::m_pZoneName = 0;
  CHud::m_pVehicleNameToPrint = 0;
  CHud::m_ZoneNameTimer = 0;
  CHud::m_pLastVehicleName = 0;
  CHud::m_pLastZoneName = 0;
  CHud::m_VehicleNameTimer = 0;
  CHud::m_VehicleFadeTimer = 0;
  CHud::m_VehicleState = 0;
  CHud::m_ZoneState = 0;
  CHud::m_pVehicleName = 0;
  memset(CHud::m_Message, 0, sizeof(CHud::m_Message));
  *(_QWORD *)BigMessageInUse = 0LL;
  *(_QWORD *)&BigMessageInUse[2] = 0LL;
  *(_QWORD *)&BigMessageInUse[4] = 0LL;
  *(_QWORD *)&BigMessageInUse[6] = 0LL;
  memset(CHud::m_BigMessage, 0, sizeof(CHud::m_BigMessage));
  CHud::bScriptForceDisplayWithCounters = 0;
  OddJob2Timer = 0;
  OddJob2OffTimer = 0.0;
  OddJob2XOffset = 0.0;
  CHud::bScriptDontDisplayRadar = 0;
  CHud::m_EnergyLostTimer = 0;
  CHud::bScriptDontDisplayVehicleName = 0;
  CHud::bScriptDontDisplayAreaName = 0;
  CHud::m_ItemToFlash = -1;
  PagerXOffset = 150.0;
  OddJob2On = 0;
  v0 = &CWorld::Players[CWorld::PlayerInFocus];
  LastTimeEnergyLost = v0->LastTimeEnergyLost;
  DisplayScore = v0->DisplayScore;
  CHud::m_EnergyLostFadeTimer = 0;
  CHud::m_LastTimeEnergyLost = LastTimeEnergyLost;
  CHud::m_EnergyLostState = 5;
  CHud::m_LastDisplayScore = DisplayScore;
  CHud::m_DisplayScoreFadeTimer = 0;
  CHud::m_DisplayScoreTimer = 0;
  CHud::m_WeaponTimer = 0;
  CHud::m_WeaponFadeTimer = 0;
  CHud::m_DisplayScoreState = 5;
  CHud::m_LastWeapon = 0;
  CHud::m_WeaponState = 5;
  CHud::m_LastBreathTime = 0;
  CHud::m_LastWanted = 0;
  CHud::m_WantedTimer = 0;
  CHud::m_WantedFadeTimer = 0;
  CHud::m_WantedState = 5;
}

//----- (00436D18) --------------------------------------------------------
void __fastcall CHud::GetRidOfAllHudMessages(bool8 bIgnoreMissionTitle)
{
  int v1; // r8
  bool v2; // zf
  bool v3; // zf

  v1 = bIgnoreMissionTitle;
  CHud::m_pZoneName = 0;
  CHud::m_ZoneNameTimer = 0;
  CHud::m_pVehicleNameToPrint = 0;
  CHud::m_pVehicleName = 0;
  CHud::m_VehicleNameTimer = 0;
  CHud::m_ZoneState = 0;
  CHud::m_VehicleFadeTimer = 0;
  CHud::m_VehicleState = 0;
  memset(CHud::m_Message, 0, sizeof(CHud::m_Message));
  if ( BigMessageInUse[0] == 0.0 )
    memset(CHud::m_BigMessage, 0, 0x100u);
  v2 = BigMessageInUse[1] == 0.0;
  if ( BigMessageInUse[1] == 0.0 )
    v2 = v1 == 0;
  if ( v2 )
    memset(CHud::m_BigMessage[1], 0, sizeof(GxtChar[128]));
  if ( BigMessageInUse[2] == 0.0 )
    memset(CHud::m_BigMessage[2], 0, sizeof(GxtChar[128]));
  if ( BigMessageInUse[3] == 0.0 )
    memset(CHud::m_BigMessage[3], 0, sizeof(GxtChar[128]));
  v3 = BigMessageInUse[4] == 0.0;
  if ( BigMessageInUse[4] == 0.0 )
    v3 = v1 == 0;
  if ( v3 )
    memset(CHud::m_BigMessage[4], 0, sizeof(GxtChar[128]));
  if ( BigMessageInUse[5] == 0.0 )
    memset(CHud::m_BigMessage[5], 0, sizeof(GxtChar[128]));
  if ( BigMessageInUse[6] == 0.0 )
    memset(CHud::m_BigMessage[6], 0, sizeof(GxtChar[128]));
  if ( BigMessageInUse[7] == 0.0 )
    memset(CHud::m_BigMessage[7], 0, sizeof(GxtChar[128]));
}

//----- (00436F28) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
float __fastcall CHud::GetYPosBasedOnHealth(uint8 player, float initial_pos, int8 adjuster)
{
  float v3; // s0

  v3 = initial_pos;
  if ( CWorld::Players[player].MaxHealth <= 0x64u )
    return initial_pos + (float)((float)((float)RsGlobal.screenHeight / -448.0) * (float)adjuster);
  return v3;
}
// 436F28: variables would overlap: r0.1 and r0.2

//----- (00436F7C) --------------------------------------------------------
void __fastcall CHud::SetZoneName(GxtChar *pZoneName, bool8 forced)
{
  if ( forced || !(CGame::currArea | CHud::m_ZoneState) )
    CHud::m_pZoneName = pZoneName;
}

//----- (00436FAC) --------------------------------------------------------
void __fastcall CHud::SetHelpMessage(
        const unsigned __int8 *helpLabel,
        GxtChar *pHelpMsg,
        bool bQuick,
        bool bDisplayForever,
        int bAddToBrief,
        unsigned int nConditionFlag)
{
  if ( !CTouchInterface::m_pWidgets[162] )
  {
LABEL_4:
    if ( bAddToBrief != 1 )
      return;
    goto LABEL_5;
  }
  if ( pHelpMsg )
  {
    CWidgetHelpText::AddMessageToQueue(
      (CWidgetHelpText *)CTouchInterface::m_pWidgets[162],
      pHelpMsg,
      bDisplayForever,
      0,
      0.0,
      0.0,
      nConditionFlag);
    goto LABEL_4;
  }
  CWidgetHelpText::ClearQueue((CWidgetHelpText *)CTouchInterface::m_pWidgets[162], 0);
  if ( bAddToBrief != 1 )
    return;
LABEL_5:
  CMessages::AddToPreviousBriefArray(helpLabel, pHelpMsg, -1, -1, -1, -1, -1, -1, 0);
}

//----- (0043701C) --------------------------------------------------------
void __fastcall CHud::SetHelpMessageStatUpdate(bool8 bIncrement, UInt16 nStatID, float fValue, float fMaxValue)
{
  CWidgetHelpText *v5; // r5
  __int16 v7; // r2
  GxtChar pOutput[416]; // [sp+10h] [bp-340h] BYREF

  v5 = (CWidgetHelpText *)CTouchInterface::m_pWidgets[162];
  if ( CTouchInterface::m_pWidgets[162] )
  {
    v7 = 45;
    if ( bIncrement )
      v7 = 43;
    *(_WORD *)gString = v7;
    AsciiToGxtChar(gString, pOutput);
    CWidgetHelpText::AddMessageToQueue(v5, pOutput, 0, nStatID, fValue, fMaxValue, 0);
  }
}

//----- (0043708C) --------------------------------------------------------
void __fastcall CHud::SetVehicleName(GxtChar *pVehName)
{
  CHud::m_pVehicleName = pVehName;
}

//----- (0043709C) --------------------------------------------------------
void __fastcall CHud::SetMessage(GxtChar *pMessage)
{
  GxtChar *v1; // r2
  unsigned __int16 i; // r1

  if ( pMessage )
  {
    v1 = CHud::m_Message;
    for ( i = 0; i < 0x190u; ++i )
    {
      if ( !*pMessage )
        break;
      *v1++ = *pMessage++;
    }
  }
  else
  {
    i = 0;
    CHud::m_Message[0] = 0;
  }
  CHud::m_Message[i] = 0;
}

//----- (004370E4) --------------------------------------------------------
void __fastcall CHud::SetBigMessage(GxtChar *pMessage, UInt16 Row)
{
  GxtChar *v2; // r12
  GxtChar *v3; // r3
  int v4; // r2
  int v5; // r6
  GxtChar v6; // t1
  int v7; // r5
  unsigned int v8; // r2

  if ( BigMessageInUse[Row] == 0.0 )
  {
    if ( Row == 5 )
    {
      v2 = CHud::m_BigMessage[5];
      v3 = LastBigMessage[5];
      v4 = 0;
      do
      {
        v5 = *pMessage;
        if ( !*pMessage )
          break;
        ++v4;
        if ( v5 != *v3 )
        {
          OddJob2On = 0;
          OddJob2OffTimer = 0.0;
          LOWORD(v5) = *pMessage;
        }
        *v2++ = v5;
        v6 = *pMessage++;
        *v3++ = v6;
      }
      while ( (unsigned __int16)v4 < 0x80u );
    }
    else
    {
      v7 = 0;
      v4 = 0;
      do
      {
        if ( !pMessage[v7] )
          break;
        ++v4;
        CHud::m_BigMessage[Row][v7] = pMessage[v7];
        ++v7;
      }
      while ( (unsigned __int16)v4 < 0x80u );
      *pMessage = 0;
    }
    v8 = ((unsigned int)&elf_hash_chain[16293] + 2) & (2 * v4);
    *(GxtChar *)((char *)CHud::m_BigMessage[Row] + v8) = 0;
    *(GxtChar *)((char *)LastBigMessage[Row] + v8) = 0;
  }
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (004371D0) --------------------------------------------------------
void CHud::ResetWastedText()
{
  CHud::m_BigMessage[2][0] = 0;
  BigMessageInUse[2] = 0.0;
  BigMessageInUse[0] = 0.0;
  CHud::m_BigMessage[0][0] = 0;
}

//----- (00437200) --------------------------------------------------------
void CHud::DrawCrossHairs()
{
  CPlayerPed *pPed; // r5
  _BOOL4 v1; // r4
  int Mode; // r9
  char *v3; // r0
  eWeaponType v4; // r8
  int v5; // r6
  bool v6; // zf
  bool v7; // cc
  int v8; // r2
  int v9; // r1
  EScriptCrossHair v10; // r0
  float screenWidth; // s20
  float screenHeight; // s18
  float32x4_t v13; // q5
  float WeaponRadiusOnScreen; // s18
  float32x4_t v15; // q8
  float v16; // s24
  float v17; // s4
  float v18; // s2
  float v19; // s20
  float v20; // s18
  float v21; // s16
  float v22; // s26
  float v23; // s22
  float v24; // s18
  float v25; // s20
  RwInt32 v26; // r3
  float v27; // s22
  EScriptCrossHair v28; // r4
  bool v29; // zf
  TextureDatabaseRuntime *Database; // r0
  int *v31; // r1
  float v32; // s0
  float v33; // s26
  const char *v34; // r0
  float v35; // s24
  RwTexture_0 *mpTexture; // r4
  float v37; // s22
  float v38; // s16
  float v39; // s22
  float v40; // s24
  CRGBA v41; // [sp+2Ch] [bp-7Ch] BYREF
  CRect Rectangle; // [sp+30h] [bp-78h] BYREF

  pPed = CWorld::Players[CWorld::PlayerInFocus].pPed;
  if ( pPed )
  {
    v1 = 0;
    Mode = (unsigned __int16)TheCamera.Cams[TheCamera.ActiveCam].Mode;
    v3 = (char *)pPed + 28 * pPed->m_nCurrentWeapon;
    v4 = *((_DWORD *)v3 + 361);
    switch ( TheCamera.Cams[TheCamera.ActiveCam].Mode )
    {
      case 7:
      case 8:
      case 0x22:
      case 0x2D:
      case 0x2E:
      case 0x33:
        v1 = !CWeapon::IsTypeMelee((const CWeapon *)(v3 + 1444));
        goto LABEL_4;
      case 0x10:
        v1 = 0;
        if ( FindPlayerVehicle(-1, 0) )
        {
          if ( FindPlayerVehicle(-1, 0)->m_nModelIndex == 520
            || (v1 = 0, v5 = 0, FindPlayerVehicle(-1, 0)->m_nModelIndex == 425) )
          {
            v5 = 0;
            v1 = 1;
          }
        }
        else
        {
          v5 = 0;
        }
        break;
      default:
LABEL_4:
        v5 = 0;
        if ( (unsigned int)(Mode - 39) <= 0xD && ((1 << (Mode - 39)) & 0x200B) != 0 )
          v5 = 1;
        break;
    }
    if ( !pPed->m_pEntLockOnTarget
      && (*((_BYTE *)pPed->m_pPlayerData + 52) & 8) != 0
      && (!CPedIntelligence::GetTaskUseGun(pPed->m_pPedIntelligence)
       || !CPedIntelligence::GetTaskUseGun(pPed->m_pPedIntelligence)->m_bSkipAim)
      && (unsigned int)(Mode - 53) <= 0xC )
    {
      v6 = ((1 << (Mode - 53)) & 0x1005) == 0;
      if ( ((1 << (Mode - 53)) & 0x1005) != 0 )
        v6 = (pPed->m_nPedState | 2) == 59;
      if ( !v6 )
      {
        v7 = (unsigned int)(v4 - 37) > 2;
        if ( (unsigned int)(v4 - 37) >= 2 )
          v7 = (unsigned int)(v4 - 22) > 0xB;
        if ( !v7 )
        {
          v8 = 0;
          v9 = 0;
          if ( Mode != 53 )
            v8 = 1;
          if ( !TheCamera.m_uiTransitionState )
            v9 = 1;
          v5 = v8 | v9;
        }
      }
    }
    if ( v1 )
      goto LABEL_27;
    v10 = CTheScripts::bDrawCrossHair;
    if ( CTheScripts::bDrawCrossHair )
      v10 = SCRIPT_CROSSHAIR_NORMAL;
    if ( v10 | v5 )
    {
LABEL_27:
      screenWidth = (float)RsGlobal.screenWidth;
      screenHeight = (float)RsGlobal.screenHeight;
      RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
      RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
      if ( v5 == 1 && (unsigned int)(Mode - 53) <= 0xC && ((1 << (Mode - 53)) & 0x1005) != 0 )
      {
        v13.n128_f32[1] = CCamera::m_f3rdPersonCHairMultY * (float)RsGlobal.screenHeight;
        v13.n128_f32[0] = CCamera::m_f3rdPersonCHairMultX * (float)RsGlobal.screenWidth;
        WeaponRadiusOnScreen = CPlayerPed::GetWeaponRadiusOnScreen(pPed);
        if ( WeaponRadiusOnScreen == 0.2 )
        {
          v13.n128_u64[1] = v13.n128_u64[0];
          v15.n128_u64[0] = 0x3F800000BF800000LL;
          v15.n128_u64[1] = 0xBF8000003F800000LL;
          Rectangle = (CRect)vaddq_f32(v13, v15);
          CRGBA::CRGBA(&v41, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
          CSprite2d::DrawRect(&Rectangle, &v41);
        }
        v16 = WeaponRadiusOnScreen * (float)((float)((float)RsGlobal.screenHeight / 448.0) * 64.0);
        v17 = v13.n128_f32[1] + (float)(v16 * 0.5);
        v18 = v13.n128_f32[0] + (float)(v16 * 0.5);
        v19 = v18 - v16;
        v20 = (float)(v16 * 0.5) + (float)(v17 - v16);
        Rectangle.bottom = v17 - v16;
        v21 = (float)(v16 * 0.5) + (float)(v18 - v16);
        Rectangle.left = v18 - v16;
        Rectangle.right = v21;
        Rectangle.top = v20;
        CRGBA::CRGBA(&v41, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
        CSprite2d::Draw(&CHud::Sprites[1], &Rectangle, &v41);
        v22 = v16 + (float)(v18 - v16);
        Rectangle.bottom = v17 - v16;
        Rectangle.left = v22;
        Rectangle.right = v21;
        Rectangle.top = v20;
        CRGBA::CRGBA(&v41, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
        CSprite2d::Draw(&CHud::Sprites[1], &Rectangle, &v41);
        v23 = v16 + (float)(v17 - v16);
      }
      else
      {
        v24 = screenHeight * 0.5;
        v25 = screenWidth * 0.5;
        if ( CTheScripts::bDrawCrossHair == SCRIPT_CROSSHAIR_CAMERA
          || (unsigned int)(Mode - 34) > 0xB
          || ((1 << (Mode - 34)) & 0x981) == 0 )
        {
          RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
          v26 = RsGlobal.screenWidth;
          if ( RsGlobal.screenWidth > RsGlobal.screenHeight )
            v26 = RsGlobal.screenHeight;
          v27 = (float)v26;
          v28 = CTheScripts::bDrawCrossHair;
          v29 = CTheScripts::bDrawCrossHair == SCRIPT_CROSSHAIR_CAMERA;
          if ( CTheScripts::bDrawCrossHair != SCRIPT_CROSSHAIR_CAMERA )
            v29 = v4 == WEAPONTYPE_CAMERA;
          if ( v29 || v4 == WEAPONTYPE_SNIPERRIFLE )
          {
            if ( CWeaponInfo::GetWeaponInfo(v4, 1)->m_modelId > 0
              || CTheScripts::bDrawCrossHair == SCRIPT_CROSSHAIR_CAMERA )
            {
              Database = TextureDatabaseRuntime::GetDatabase("gta3");
              TextureDatabaseRuntime::Register(Database);
              v31 = dword_437AB4;
              if ( v28 == SCRIPT_CROSSHAIR_CAMERA )
                v31 = &dword_437AB4[1];
              v32 = *(float *)v31;
              if ( v4 == WEAPONTYPE_CAMERA )
                v32 = 0.275;
              v33 = v32 * v27;
              v34 = "SNIPERcrosshair";
              if ( CTheScripts::bDrawCrossHair == SCRIPT_CROSSHAIR_CAMERA )
                v34 = "cameraCrosshair";
              if ( v4 == WEAPONTYPE_CAMERA )
                v34 = "cameraCrosshair";
              v35 = 0.0;
              mpTexture = RwTextureRead((const RwChar *)v34, (const RwChar *)&byte_61CADE);
              v37 = 0.0;
              if ( mpTexture )
              {
LABEL_51:
                if ( Mode == 7 )
                {
                  Rectangle.left = 0.0;
                  Rectangle.bottom = 0.0;
                  Rectangle.top = (float)(v24 - v33) + 1.0;
                  Rectangle.right = (float)RsGlobal.screenWidth;
                  CRGBA::CRGBA(&v41, 0, 0, 0, 0xFFu);
                  CSprite2d::DrawRect(&Rectangle, &v41);
                  Rectangle.left = 0.0;
                  Rectangle.bottom = (float)(v24 + v33) + -1.0;
                  Rectangle.right = (float)RsGlobal.screenWidth;
                  Rectangle.top = (float)RsGlobal.screenHeight;
                  CRGBA::CRGBA(&v41, 0, 0, 0, 0xFFu);
                  CSprite2d::DrawRect(&Rectangle, &v41);
                  Rectangle.bottom = v24 - v33;
                  Rectangle.left = 0.0;
                  Rectangle.right = (float)(v25 - v33) + 1.0;
                  Rectangle.top = v24 + v33;
                  CRGBA::CRGBA(&v41, 0, 0, 0, 0xFFu);
                  CSprite2d::DrawRect(&Rectangle, &v41);
                  Rectangle.left = (float)(v25 + v33) + -1.0;
                  Rectangle.bottom = v24 - v33;
                  Rectangle.top = v24 + v33;
                  Rectangle.right = (float)RsGlobal.screenWidth;
                  CRGBA::CRGBA(&v41, 0, 0, 0, 0xFFu);
                  CSprite2d::DrawRect(&Rectangle, &v41);
                }
                RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
                RwRenderStateSet(rwRENDERSTATETEXTUREADDRESS, (char *)&dword_0 + 3);
                RwRenderStateSet(rwRENDERSTATETEXTURERASTER, mpTexture->raster);
                v38 = v33 * 0.5;
                CSprite::RenderOneXLUSprite(
                  (float)(v25 - (float)(v33 * 0.5)) - v35,
                  (float)(v24 - (float)(v33 * 0.5)) - v37,
                  10.0,
                  v33 * 0.5,
                  v33 * 0.5,
                  255,
                  255,
                  255,
                  255,
                  0.01,
                  0xFFu,
                  0,
                  0,
                  0.0125,
                  0.0);
                CSprite::RenderOneXLUSprite(
                  v35 + (float)(v25 + v38),
                  (float)(v24 - v38) - v37,
                  10.0,
                  v38,
                  v38,
                  255,
                  255,
                  255,
                  255,
                  0.01,
                  0xFFu,
                  1,
                  0,
                  0.0125,
                  0.0);
                CSprite::RenderOneXLUSprite(
                  (float)(v25 - v38) - v35,
                  (float)(v24 + v38) + v37,
                  10.0,
                  v38,
                  v38,
                  255,
                  255,
                  255,
                  255,
                  0.01,
                  0xFFu,
                  0,
                  1,
                  0.0125,
                  0.0);
                CSprite::RenderOneXLUSprite(
                  v35 + (float)(v25 + v38),
                  (float)(v24 + v38) + v37,
                  10.0,
                  v38,
                  v38,
                  255,
                  255,
                  255,
                  255,
                  0.01,
                  0xFFu,
                  1,
                  1,
                  0.0125,
                  0.0);
                RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
              }
            }
          }
          else
          {
            switch ( Mode )
            {
              case 8:
              case 16:
              case 40:
              case 51:
              case 52:
                mpTexture = CHud::Sprites[2].mpTexture;
                v33 = v27 * 0.04;
                v37 = (float)((float)RsGlobal.screenHeight / 448.0) * 20.0;
                v35 = (float)((float)RsGlobal.screenWidth / 640.0) * 20.0;
                if ( CHud::Sprites[2].mpTexture )
                  goto LABEL_51;
                break;
              default:
                goto LABEL_64;
            }
          }
          goto LABEL_64;
        }
        v39 = (float)((float)RsGlobal.screenHeight / 448.0) * 64.0;
        v40 = v24 - (float)(v39 * 0.5);
        v19 = v25 - (float)(v39 * 0.5);
        v20 = (float)(v39 * 0.5) + v40;
        Rectangle.bottom = v40;
        v21 = (float)(v39 * 0.5) + v19;
        Rectangle.left = v19;
        Rectangle.right = v21;
        Rectangle.top = v20;
        CRGBA::CRGBA(&v41, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
        CSprite2d::Draw(&CHud::Sprites[1], &Rectangle, &v41);
        v22 = v39 + v19;
        Rectangle.bottom = v40;
        Rectangle.left = v39 + v19;
        Rectangle.right = v21;
        Rectangle.top = v20;
        CRGBA::CRGBA(&v41, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
        CSprite2d::Draw(&CHud::Sprites[1], &Rectangle, &v41);
        v23 = v39 + v40;
      }
      Rectangle.bottom = v23;
      Rectangle.left = v19;
      Rectangle.right = v21;
      Rectangle.top = v20;
      CRGBA::CRGBA(&v41, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
      CSprite2d::Draw(&CHud::Sprites[1], &Rectangle, &v41);
      Rectangle.bottom = v23;
      Rectangle.left = v22;
      Rectangle.right = v21;
      Rectangle.top = v20;
      CRGBA::CRGBA(&v41, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
      CSprite2d::Draw(&CHud::Sprites[1], &Rectangle, &v41);
LABEL_64:
      RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
      RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
      RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
    }
  }
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;
// 437AB4: using guessed type int dword_437AB4[2];
// 61CADE: using guessed type char byte_61CADE;

//----- (00437AE4) --------------------------------------------------------
void CHud::DrawVitalStats()
{
  if ( !TheCamera.m_WideScreenOn )
    CTouchInterface::IsReleased(WIDGET_VITAL_STATS, 0, 2);
}

//----- (00437B0C) --------------------------------------------------------
void CHud::DrawRadar()
{
  __int64 v0; // d8
  __int64 v1; // d9
  __int64 v2; // d10
  __int64 v3; // d11
  __int64 v4; // d12
  __int64 v5; // d13
  __int64 v6; // d14
  __int64 v7; // d15
  char *PlayerVehicle; // r4
  CWidget *v9; // r8
  float left; // s4
  float right; // s6
  float top; // s2
  float bottom; // s8
  float v14; // s10
  float v15; // s2
  float v16; // s8
  float v17; // s18
  float v18; // s6
  float v19; // s16
  RwUInt8 alpha; // r9
  float v21; // s20
  float v22; // s22
  int v23; // r0
  _WORD *v24; // r10
  float v25; // r5
  float v26; // s24
  float v27; // r6
  float v28; // s17
  float v29; // s21
  float v30; // r5
  float v31; // s23
  float v32; // r0
  CPlayerPed *PlayerPed; // r0
  int v34; // r0
  float *v35; // r1
  float v36; // s24
  float v37; // s17
  int *v38; // r0
  float v39; // s0
  float v40; // s24
  float v41; // s22
  float v42; // s20
  float v43; // s26
  float v44; // s20
  float v45; // s22
  CHoldEffect *m_pHoldEffect; // r0
  float v47; // [sp+1Ch] [bp-84h]
  float x; // [sp+20h] [bp-80h]
  CRGBA v49; // [sp+24h] [bp-7Ch] BYREF
  CRect rgba; // [sp+28h] [bp-78h] BYREF
  __int64 v51; // [sp+38h] [bp-68h]
  __int64 v52; // [sp+40h] [bp-60h]
  __int64 v53; // [sp+48h] [bp-58h]
  __int64 v54; // [sp+50h] [bp-50h]
  __int64 v55; // [sp+58h] [bp-48h]
  __int64 v56; // [sp+60h] [bp-40h]
  __int64 v57; // [sp+68h] [bp-38h]
  __int64 v58; // [sp+70h] [bp-30h]

  if ( (unsigned int)(CEntryExitManager::ms_exitEnterState - 1) >= 2
    && (CHud::m_ItemToFlash != 8 || CTimer::m_snTimeInMilliseconds % 0x15E >= 0x97) )
  {
    v51 = v0;
    v52 = v1;
    v53 = v2;
    v54 = v3;
    v55 = v4;
    v56 = v5;
    v57 = v6;
    v58 = v7;
    RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
    RwRenderStateSet(rwRENDERSTATESHADEMODE, (char *)&dword_0 + 1);
    CRadar::DrawMap();
    PlayerVehicle = (char *)FindPlayerVehicle(-1, 0);
    v9 = CTouchInterface::m_pWidgets[161];
    if ( !CTouchInterface::m_pWidgets[161] )
    {
LABEL_25:
      CRadar::DrawBlips(-1.0);
      return;
    }
    left = CTouchInterface::m_pWidgets[161]->m_RectScreen.left;
    right = CTouchInterface::m_pWidgets[161]->m_RectScreen.right;
    top = CTouchInterface::m_pWidgets[161]->m_RectScreen.top;
    bottom = CTouchInterface::m_pWidgets[161]->m_RectScreen.bottom;
    v14 = top - bottom;
    v15 = top + bottom;
    v16 = fabsf(right - left);
    v17 = (float)(left + right) * 0.5;
    v18 = fabsf(v14);
    v19 = v15 * 0.5;
    if ( FrontEndMenuManager.CurrentScreen == 5 )
      alpha = -1;
    else
      alpha = CTouchInterface::m_pWidgets[161]->m_Color._anon_0._anon_0.alpha;
    v21 = v16 * 0.5;
    v22 = v18 * 0.5;
    if ( !PlayerVehicle )
      goto LABEL_15;
    v23 = *((_DWORD *)PlayerVehicle + 361);
    if ( v23 == 4 )
    {
      v24 = PlayerVehicle + 38;
      if ( *((_WORD *)PlayerVehicle + 19) == 539 )
        goto LABEL_15;
      v25 = atan2f(
              COERCE_FLOAT(*(_DWORD *)(*((_DWORD *)PlayerVehicle + 5) + 8) ^ 0x80000000),
              *(float *)(*((_DWORD *)PlayerVehicle + 5) + 40));
      CRGBA::CRGBA((CRGBA *)&rgba, 0xFFu, 0xFFu, 0xFFu, alpha);
      v26 = -0.7854 - v25;
      v47 = sinf((float)(-0.7854 - v25) + 0.0);
      v27 = sinf((float)(-0.7854 - v25) + 1.5708);
      v28 = (float)(v22 * 1.6) * cosf((float)(-0.7854 - v25) + 1.5708);
      v29 = (float)(v21 * 1.6) * sinf((float)(-0.7854 - v25) + 4.7124);
      x = cosf((float)(-0.7854 - v25) + 0.0);
      v30 = cosf((float)(-0.7854 - v25) + 3.1416);
      v31 = (float)(v22 * 1.6) * cosf(v26 + 4.7124);
      v32 = sinf(v26 + 3.1416);
      CSprite2d::Draw(
        &CHud::Sprites[4],
        v17 + (float)((float)(v21 * 1.6) * v27),
        v19 + v28,
        v17 + (float)((float)(v21 * 1.6) * v47),
        v19 + (float)((float)(v22 * 1.6) * x),
        v17 + (float)((float)(v21 * 1.6) * v32),
        v19 + (float)((float)(v22 * 1.6) * v30),
        v17 + v29,
        v19 + v31,
        (const CRGBA *)&rgba);
      v23 = *((_DWORD *)PlayerVehicle + 361);
      if ( v23 == 4 )
        goto LABEL_14;
    }
    if ( v23 == 3 )
    {
      v24 = PlayerVehicle + 38;
LABEL_14:
      if ( *v24 != 539 )
        goto LABEL_18;
    }
LABEL_15:
    PlayerPed = FindPlayerPed(-1);
    if ( !CPedIntelligence::GetUsingParachute(PlayerPed->m_pPedIntelligence) )
    {
LABEL_23:
      v41 = v22 * 1.02;
      v42 = v21 * 1.02;
      rgba.right = v17;
      rgba.top = v15 * 0.5;
      v43 = v17 - v42;
      rgba.bottom = v19 - v41;
      rgba.left = v17 - v42;
      CRGBA::CRGBA(&v49, 0, 0, 0, alpha);
      CSprite2d::Draw(&CHud::Sprites[3], &rgba, &v49);
      v44 = v17 + v42;
      rgba.bottom = v19 - v41;
      rgba.left = v44;
      rgba.right = v17;
      rgba.top = v15 * 0.5;
      CRGBA::CRGBA(&v49, 0, 0, 0, alpha);
      CSprite2d::Draw(&CHud::Sprites[3], &rgba, &v49);
      v45 = v19 + v41;
      rgba.bottom = v45;
      rgba.left = v43;
      rgba.right = v17;
      rgba.top = v15 * 0.5;
      CRGBA::CRGBA(&v49, 0, 0, 0, alpha);
      CSprite2d::Draw(&CHud::Sprites[3], &rgba, &v49);
      rgba.bottom = v45;
      rgba.left = v44;
      rgba.right = v17;
      rgba.top = v15 * 0.5;
      CRGBA::CRGBA(&v49, 0, 0, 0, alpha);
      CSprite2d::Draw(&CHud::Sprites[3], &rgba, &v49);
      m_pHoldEffect = v9->m_pHoldEffect;
      if ( m_pHoldEffect )
        CHoldEffect::Draw(m_pHoldEffect);
      goto LABEL_25;
    }
    if ( !PlayerVehicle )
      PlayerVehicle = (char *)FindPlayerPed(-1);
LABEL_18:
    v34 = *((_DWORD *)PlayerVehicle + 5);
    v35 = (float *)(v34 + 48);
    if ( !v34 )
      v35 = (float *)(PlayerVehicle + 4);
    v36 = v35[2];
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
    v37 = v19 + (float)(v22 * 0.75);
    rgba.right = (float)(v17 + (float)(v21 * 1.35)) + 2.0;
    rgba.bottom = (float)(v19 - (float)(v22 * 0.75)) + -2.0;
    rgba.left = (float)(v17 + (float)(v21 * 1.25)) + -2.0;
    rgba.top = v37 + 2.0;
    CRGBA::CRGBA(&v49, 0, 0, 0, alpha);
    CSprite2d::DrawRect(&rgba, &v49);
    v38 = dword_438050;
    if ( v36 > 200.0 )
      v38 = &dword_438050[1];
    rgba.bottom = v19 - (float)(v22 * 0.75);
    v39 = *(float *)v38;
    rgba.left = v17 + (float)(v21 * 1.25);
    rgba.right = v17 + (float)(v21 * 1.35);
    v40 = v37 + (float)((float)(v22 * (float)(v36 / v39)) * -1.5);
    rgba.top = v40;
    CRGBA::CRGBA(&v49, 0x60u, 0x60u, 0x60u, alpha);
    CSprite2d::DrawRect(&rgba, &v49);
    rgba.bottom = v40;
    rgba.left = v17 + (float)(v21 * 1.25);
    rgba.right = v17 + (float)(v21 * 1.35);
    rgba.top = v19 + (float)(v22 * 0.75);
    CRGBA::CRGBA(&v49, 0xF0u, 0xF0u, 0xF0u, alpha);
    CSprite2d::DrawRect(&rgba, &v49);
    rgba.bottom = v40;
    rgba.left = v17 + (float)(v21 * 1.2);
    rgba.right = v17 + (float)(v21 * 1.4);
    rgba.top = v40 + (float)(int)(float)(v22 * 0.05);
    CRGBA::CRGBA(&v49, 0, 0, 0, alpha);
    CSprite2d::DrawRect(&rgba, &v49);
    rgba.bottom = v40 + 1.0;
    rgba.left = (float)(v17 + (float)(v21 * 1.2)) + 1.0;
    rgba.right = (float)(v17 + (float)(v21 * 1.4)) + -1.0;
    rgba.top = (float)(v40 + (float)(int)(float)(v22 * 0.05)) + -1.0;
    CRGBA::CRGBA(&v49, 0xFFu, 0xFFu, 0xFFu, alpha);
    CSprite2d::DrawRect(&rgba, &v49);
    goto LABEL_23;
  }
}
// 437B5C: variable 'v0' is possibly undefined
// 437B5C: variable 'v1' is possibly undefined
// 437B5C: variable 'v2' is possibly undefined
// 437B5C: variable 'v3' is possibly undefined
// 437B5C: variable 'v4' is possibly undefined
// 437B5C: variable 'v5' is possibly undefined
// 437B5C: variable 'v6' is possibly undefined
// 437B5C: variable 'v7' is possibly undefined
// 0: using guessed type int dword_0;
// 438050: using guessed type int dword_438050[2];

//----- (0043806C) --------------------------------------------------------
void CHud::DrawAreaName()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d1
  float32x2_t v2; // d2
  float32x2_t v3; // d3
  GxtChar *v4; // r0
  Int32 v5; // r1
  float v6; // s16
  int v7; // r1
  float v8; // s0
  CRGBA v9; // r0
  int RadarRed; // r1
  int RadarBlue; // r3
  bool v12; // zf
  int RadarGreen; // r2
  bool v14; // zf
  CRGBA *v15; // r0
  float screenHeight; // s18
  float v17; // s26
  float v18; // s24
  CRGBA v19; // [sp+4h] [bp-44h] BYREF
  CRGBA v20; // [sp+8h] [bp-40h] BYREF
  CRGBA v21; // [sp+Ch] [bp-3Ch] BYREF

  v4 = CHud::m_pZoneName;
  if ( CHud::m_pZoneName )
  {
    if ( CHud::m_pZoneName == CHud::m_pLastZoneName )
    {
      v5 = CHud::m_ZoneState;
      v4 = CHud::m_pLastZoneName;
    }
    else
    {
      v5 = CHud::m_ZoneState;
      switch ( CHud::m_ZoneState )
      {
        case 0:
          if ( (CTheScripts::bPlayerIsOffTheMap || !CTheScripts::bDisplayHud)
            && (unsigned int)(CEntryExitManager::ms_exitEnterState - 1) > 1 )
          {
            v5 = 0;
          }
          else
          {
            CHud::m_ZoneFadeTimer = 0;
            CHud::m_ZoneNameTimer = 0;
            v5 = 2;
            CHud::m_ZoneState = 2;
            CHud::m_ZoneToPrint = CHud::m_pZoneName;
            if ( (unsigned int)(CHud::m_VehicleState - 1) <= 1 )
            {
              CHud::m_VehicleState = 3;
              v5 = 2;
            }
          }
          break;
        case 1:
        case 2:
        case 3:
          CHud::m_ZoneNameTimer = 0;
          v5 = 4;
          CHud::m_ZoneState = 4;
          break;
        case 4:
          CHud::m_ZoneNameTimer = 0;
          v5 = 4;
          break;
        default:
          break;
      }
      CHud::m_pLastZoneName = CHud::m_pZoneName;
    }
    v6 = 255.0;
    switch ( v5 )
    {
      case 0:
        return;
      case 1:
        CHud::m_ZoneFadeTimer = 1000;
        if ( CHud::m_ZoneNameTimer >= 3001 )
        {
          CHud::m_ZoneFadeTimer = 1000;
          CHud::m_ZoneState = 3;
        }
        goto LABEL_33;
      case 2:
        if ( CCamera::GetFading(&TheCamera) || CCamera::GetScreenFadeStatus(&TheCamera) == 2 )
        {
          if ( CHud::m_ZoneFadeTimer <= 1000 )
            goto LABEL_20;
          goto LABEL_19;
        }
        CHud::m_ZoneFadeTimer += (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
        if ( CHud::m_ZoneFadeTimer > 1000 )
        {
LABEL_19:
          CHud::m_ZoneState = 1;
          CHud::m_ZoneFadeTimer = 1000;
        }
LABEL_20:
        if ( CCamera::GetScreenFadeStatus(&TheCamera) != 2 )
          goto LABEL_31;
        CHud::m_ZoneFadeTimer = 1000;
        CHud::m_ZoneState = 3;
        goto LABEL_33;
      case 3:
        if ( CCamera::GetFading(&TheCamera) || CCamera::GetScreenFadeStatus(&TheCamera) == 2 )
        {
          if ( CHud::m_ZoneFadeTimer > -1 )
            goto LABEL_26;
          goto LABEL_25;
        }
        CHud::m_ZoneFadeTimer -= (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
        if ( CHud::m_ZoneFadeTimer <= -1 )
        {
LABEL_25:
          CHud::m_ZoneState = 0;
          CHud::m_ZoneFadeTimer = 0;
        }
LABEL_26:
        if ( CCamera::GetScreenFadeStatus(&TheCamera) == 2 )
        {
          CHud::m_ZoneFadeTimer = 1000;
        }
        else
        {
LABEL_31:
          v8 = (float)CHud::m_ZoneFadeTimer / 1000.0;
LABEL_32:
          v6 = v8 * 255.0;
        }
LABEL_33:
        if ( CHud::m_Message[0] || BigMessageInUse[1] != 0.0 )
        {
          CHud::m_ZoneState = 3;
        }
        else
        {
          CHud::m_ZoneNameTimer += (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
          CFont::SetProportional(1u);
          CFont::SetBackground(0, 0);
          CFont::SetScale((float)((float)RsGlobal.screenHeight / 448.0) * 1.2);
          CFont::SetEdge(2);
          CFont::SetOrientation(2u);
          CFont::SetRightJustifyWrap((float)((float)RsGlobal.screenWidth / 640.0) * 180.0);
          CRGBA::CRGBA(&v21, 0, 0, 0, (unsigned int)v6);
          CFont::SetDropColor(v9);
          CFont::SetFontStyle(0);
          if ( !CGangWars::bGangWarsActive )
            goto LABEL_45;
          v12 = CPopCycle::m_pCurrZoneInfo == 0;
          if ( CPopCycle::m_pCurrZoneInfo )
          {
            RadarRed = CPopCycle::m_pCurrZoneInfo->RadarRed;
            v12 = RadarRed == 0;
          }
          if ( v12 )
            goto LABEL_45;
          RadarGreen = CPopCycle::m_pCurrZoneInfo->RadarGreen;
          v14 = RadarGreen == 0;
          if ( CPopCycle::m_pCurrZoneInfo->RadarGreen )
          {
            RadarBlue = CPopCycle::m_pCurrZoneInfo->RadarBlue;
            v14 = RadarBlue == 0;
          }
          if ( v14 )
          {
LABEL_45:
            CHudColours::GetRGB(&v19, &HudColour, 3u, (unsigned int)v6);
            v15 = &v19;
          }
          else
          {
            CRGBA::CRGBA(&v20, RadarRed, RadarGreen, RadarBlue, (unsigned int)v6);
          }
          CFont::SetColor((CRGBA)v15);
          screenHeight = (float)RsGlobal.screenHeight;
          v17 = (float)((float)RsGlobal.screenHeight / -448.0) * 30.0;
          v18 = (float)RsGlobal.screenHeight - (float)((float)RsGlobal.screenHeight * 0.0);
          v1.n64_f32[0] = (float)RsGlobal.screenWidth - (float)((float)RsGlobal.screenWidth * 0.0);
          v2.n64_f32[0] = (float)RsGlobal.screenWidth + (float)((float)((float)RsGlobal.screenWidth / -640.0) * 10.0);
          v0.n64_f32[0] = v18 - CFont::GetHeight(0);
          v3.n64_f32[0] = screenHeight + v17;
          CFont::PrintString(vmin_f32(v2, v1).n64_f32[0], vmin_f32(v3, v0).n64_f32[0], CHud::m_ZoneToPrint);
          CFont::SetSlant(0.0);
        }
        break;
      case 4:
        CHud::m_ZoneFadeTimer -= (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
        v7 = CHud::m_ZoneFadeTimer;
        if ( CHud::m_ZoneFadeTimer <= -1 )
        {
          CHud::m_ZoneState = 2;
          v7 = 0;
          CHud::m_ZoneFadeTimer = 0;
          CHud::m_ZoneToPrint = v4;
        }
        v8 = (float)v7 / 1000.0;
        goto LABEL_32;
      default:
        goto LABEL_33;
    }
  }
}
// 438400: variable 'v9' is possibly undefined
// 438436: variable 'RadarRed' is possibly undefined
// 438436: variable 'RadarBlue' is possibly undefined
// 438450: variable 'v15' is possibly undefined
// 4384BC: variable 'v2' is possibly undefined
// 4384BC: variable 'v1' is possibly undefined
// 4384C0: variable 'v3' is possibly undefined
// 4384C0: variable 'v0' is possibly undefined

//----- (00438684) --------------------------------------------------------
void CHud::DrawVehicleName()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d1
  float32x2_t v2; // d2
  float32x2_t v3; // d3
  float v4; // s16
  GxtChar *v5; // r0
  Int32 v6; // r1
  Int32 v7; // r0
  int v8; // s2
  Int32 v9; // r1
  CRGBA v10; // r0
  float screenHeight; // s18
  float v12; // s26
  float v13; // s24
  CRGBA v14; // [sp+8h] [bp-40h] BYREF
  CRGBA v15[15]; // [sp+Ch] [bp-3Ch] BYREF

  v5 = CHud::m_pVehicleName;
  if ( !CHud::m_pVehicleName )
  {
    CHud::m_VehicleNameTimer = 0;
    CHud::m_VehicleState = 0;
    CHud::m_VehicleFadeTimer = 0;
    CHud::m_pLastVehicleName = 0;
    return;
  }
  if ( CHud::m_pVehicleName != CHud::m_pLastVehicleName )
  {
    v6 = CHud::m_VehicleState;
    if ( (unsigned int)(CHud::m_VehicleState - 1) >= 4 )
    {
      if ( !CHud::m_VehicleState )
      {
        CHud::m_VehicleFadeTimer = 0;
        CHud::m_VehicleNameTimer = 0;
        v6 = 2;
        CHud::m_VehicleState = 2;
        CHud::m_pVehicleNameToPrint = CHud::m_pVehicleName;
        if ( (unsigned int)(CHud::m_ZoneState - 1) <= 1 )
        {
          CHud::m_ZoneState = 3;
          v6 = 2;
        }
      }
    }
    else
    {
      CHud::m_VehicleNameTimer = 0;
      v6 = 4;
      CHud::m_VehicleState = 4;
    }
    CHud::m_pLastVehicleName = CHud::m_pVehicleName;
    goto LABEL_12;
  }
  v6 = CHud::m_VehicleState;
  v5 = CHud::m_pLastVehicleName;
  if ( (unsigned int)CHud::m_VehicleState <= 4 )
  {
LABEL_12:
    switch ( v6 )
    {
      case 0:
        return;
      case 1:
        v4 = 255.0;
        if ( CHud::m_VehicleNameTimer >= 3001 )
        {
          CHud::m_VehicleFadeTimer = 1000;
          CHud::m_VehicleState = 3;
        }
        goto LABEL_25;
      case 2:
        CHud::m_VehicleFadeTimer += (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
        v7 = CHud::m_VehicleFadeTimer;
        if ( CHud::m_VehicleFadeTimer <= 1000 )
          goto LABEL_20;
        CHud::m_VehicleState = 1;
        v7 = 1000;
        break;
      case 3:
        CHud::m_VehicleFadeTimer -= (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
        v7 = CHud::m_VehicleFadeTimer;
        if ( CHud::m_VehicleFadeTimer > -1 )
          goto LABEL_20;
        v7 = 0;
        CHud::m_VehicleState = 0;
        break;
      case 4:
        CHud::m_VehicleFadeTimer -= (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
        v9 = CHud::m_VehicleFadeTimer;
        if ( CHud::m_VehicleFadeTimer <= -1 )
        {
          v9 = 0;
          CHud::m_VehicleFadeTimer = 0;
          CHud::m_VehicleNameTimer = 0;
          CHud::m_VehicleState = 2;
          CHud::m_pVehicleNameToPrint = v5;
        }
        v8 = v9;
        goto LABEL_24;
      default:
        goto LABEL_25;
    }
    CHud::m_VehicleFadeTimer = v7;
LABEL_20:
    v8 = v7;
LABEL_24:
    v4 = (float)((float)v8 / 1000.0) * 255.0;
  }
LABEL_25:
  if ( !CHud::m_Message[0] )
  {
    CHud::m_VehicleNameTimer += (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
    CFont::SetProportional(1u);
    CFont::SetBackground(0, 0);
    CFont::SetScale((float)((float)RsGlobal.screenHeight / 448.0) * 0.9);
    CFont::SetOrientation(2u);
    CFont::SetRightJustifyWrap(0.0);
    CFont::SetFontStyle(2u);
    CFont::SetEdge(1);
    CHudColours::GetRGB(v15, &HudColour, 1u, (unsigned int)v4);
    CFont::SetColor((CRGBA)v15);
    CRGBA::CRGBA(&v14, 0, 0, 0, (unsigned int)v4);
    CFont::SetDropColor(v10);
    if ( CTheScripts::bDisplayHud )
    {
      screenHeight = (float)RsGlobal.screenHeight;
      v12 = (float)((float)RsGlobal.screenHeight / -448.0) * 20.0;
      v13 = (float)RsGlobal.screenHeight - (float)((float)RsGlobal.screenHeight * 0.0);
      v1.n64_f32[0] = (float)RsGlobal.screenWidth - (float)((float)RsGlobal.screenWidth * 0.0);
      v2.n64_f32[0] = (float)RsGlobal.screenWidth + (float)((float)((float)RsGlobal.screenWidth / -640.0) * 10.0);
      v0.n64_f32[0] = v13 - CFont::GetHeight(0);
      v3.n64_f32[0] = screenHeight + v12;
      CFont::PrintString(vmin_f32(v2, v1).n64_f32[0], vmin_f32(v3, v0).n64_f32[0], CHud::m_pVehicleNameToPrint);
    }
    CFont::SetSlant(0.0);
  }
}
// 438932: variable 'v4' is possibly undefined
// 43894C: variable 'v10' is possibly undefined
// 4389C2: variable 'v2' is possibly undefined
// 4389C2: variable 'v1' is possibly undefined
// 4389C6: variable 'v3' is possibly undefined
// 4389C6: variable 'v0' is possibly undefined

//----- (00438AAC) --------------------------------------------------------
void CHud::DrawMissionTimers()
{
  if ( CUserDisplay::OnscnTimer.ClockOrCountersToDisplay
    && (CHud::m_BigMessage[4][0] == 0 || CHud::bScriptForceDisplayWithCounters != 0)
    && !CGarages::MessageIDString[0] )
  {
    CTouchInterface::IsReleased(WIDGET_MISSION_TIMERS, 0, 2);
  }
}

//----- (00438B10) --------------------------------------------------------
void CHud::DrawHelpText()
{
  if ( !((CCutsceneMgr::ms_running | CGarages::MessageIDString[0]) << 24) )
  {
    if ( CTouchInterface::m_pWidgets[162] )
      sub_194C00((CWidgetHelpText *)CTouchInterface::m_pWidgets[162]);
  }
}

//----- (00438B48) --------------------------------------------------------
void __fastcall CHud::DrawScriptText(Bool8 bBeforeFade)
{
  int v1; // r10
  int v2; // r8
  uint8 v3; // r0
  int8 ScriptTextEdge; // r0
  intro_text_line *v5; // r4
  GxtChar *v6; // r0
  int v7; // [sp+20h] [bp-380h]
  CRGBA ScriptTextDropShadowColour; // [sp+3Ch] [bp-364h] BYREF
  CRGBA ScriptTextBackgrndColor; // [sp+40h] [bp-360h] BYREF
  CRGBA ScriptTextColor; // [sp+44h] [bp-35Ch] BYREF
  GxtChar pNewString[428]; // [sp+48h] [bp-358h] BYREF

  v1 = bBeforeFade;
  CTheScripts::DrawScriptSpritesAndRectangles(bBeforeFade);
  v2 = 0;
  v7 = v1;
  do
  {
    if ( CTheScripts::IntroTextLines[v2].ScriptTextLabel[0]
      && CTheScripts::IntroTextLines[v2].ScriptTextBeforeFade == v1 )
    {
      CFont::SetScale((float)(CTheScripts::IntroTextLines[v2].ScriptTextYScale
                            * (float)((float)RsGlobal.screenHeight / 448.0)) * 0.5);
      ScriptTextColor = CTheScripts::IntroTextLines[v2].ScriptTextColor;
      CFont::SetColor((CRGBA)&ScriptTextColor);
      CFont::SetJustify(CTheScripts::IntroTextLines[v2].ScriptTextJustify);
      if ( CTheScripts::IntroTextLines[v2].ScriptTextRightJustify )
        v3 = 2;
      else
        v3 = CTheScripts::IntroTextLines[v2].ScriptTextCentre == 0;
      CFont::SetOrientation(v3);
      CFont::SetWrapx(CTheScripts::IntroTextLines[v2].ScriptTextWrapX * (float)((float)RsGlobal.screenWidth / 640.0));
      CFont::SetCentreSize(CTheScripts::IntroTextLines[v2].ScriptTextCentreSize * (float)((float)RsGlobal.screenWidth
                                                                                        / 640.0));
      CFont::SetBackground(CTheScripts::IntroTextLines[v2].ScriptTextBackgrnd, 0);
      ScriptTextBackgrndColor = CTheScripts::IntroTextLines[v2].ScriptTextBackgrndColor;
      CFont::SetBackgroundColor((CRGBA)&ScriptTextBackgrndColor);
      CFont::SetProportional(CTheScripts::IntroTextLines[v2].ScriptTextProportional);
      ScriptTextDropShadowColour = CTheScripts::IntroTextLines[v2].ScriptTextDropShadowColour;
      CFont::SetDropColor((CRGBA)&ScriptTextDropShadowColour);
      ScriptTextEdge = CTheScripts::IntroTextLines[v2].ScriptTextEdge;
      if ( ScriptTextEdge )
        CFont::SetEdge(ScriptTextEdge);
      else
        CFont::SetDropShadowPosition(CTheScripts::IntroTextLines[v2].ScriptTextDropShadow);
      v1 = v7;
      v5 = &CTheScripts::IntroTextLines[v2];
      CFont::SetFontStyle(CTheScripts::IntroTextLines[v2].ScriptTextFontStyle);
      v6 = CText::Get(&TheText, CTheScripts::IntroTextLines[v2].ScriptTextLabel);
      CMessages::InsertNumberInString(v6, v5->NumberToInsert1, v5->NumberToInsert2, -1, -1, -1, -1, pNewString);
      CFont::PrintString(
        (float)RsGlobal.screenWidth
      - (float)((float)(640.0 - v5->ScriptTextAtX) * (float)((float)RsGlobal.screenWidth / 640.0)),
        (float)RsGlobal.screenHeight
      - (float)((float)(448.0 - v5->ScriptTextAtY) * (float)((float)RsGlobal.screenHeight / 448.0)),
        pNewString);
      CFont::SetEdge(0);
    }
    ++v2;
  }
  while ( v2 != 96 );
}

//----- (00438D90) --------------------------------------------------------
void CHud::DrawSubtitles()
{
  float32x2_t v0; // d1
  float32x2_t v1; // d2
  float32x2_t v2; // d3
  CRGBA v3; // r0
  CRGBA v4; // r0
  CRGBA v5; // r0
  OSDeviceForm v6; // r0
  int *v7; // r1
  RwInt32 screenHeight; // r6
  float CutsceneBarHeight; // r10
  float v10; // s18
  float v11; // r8
  float v12; // s22
  float Height; // r9
  float v14; // s4
  int NumberLines; // r0
  float v16; // s16
  float v17; // r0
  float v18; // r1
  float v19; // r5
  float v20; // s0
  float v21; // s0
  float v22; // r5
  int v23; // s2
  CRGBA v24; // [sp+4h] [bp-44h] BYREF
  CRGBA v25; // [sp+8h] [bp-40h] BYREF
  CRGBA v26; // [sp+Ch] [bp-3Ch] BYREF

  if ( CHud::m_Message[0] && (!CHud::m_BigMessage[2][0] || CGameLogic::IsCoopGameGoingOn() == 1) )
  {
    if ( CHud::m_VehicleState )
      CHud::m_VehicleState = 3;
    if ( CHud::m_ZoneState )
      CHud::m_ZoneState = 3;
    CFont::SetBackground(0, 0);
    CRGBA::CRGBA(&v26, 0, 0, 0, 0x80u);
    CFont::SetBackgroundColor(v3);
    CFont::SetOrientation(0);
    CFont::SetProportional(1u);
    CFont::SetDropShadowPosition(0);
    CFont::SetFontStyle(1u);
    CRGBA::CRGBA(&v25, 0xE1u, 0xE1u, 0xE1u, 0xFFu);
    CFont::SetColor(v4);
    CFont::SetDropShadowPosition(2);
    CRGBA::CRGBA(&v24, 0, 0, 0, 0xFFu);
    CFont::SetDropColor(v5);
    CFont::SetEdge(1);
    if ( TheCamera.m_WideScreenOn )
    {
      CHud::DrawSubtitles(void)::AreWeInCutScene = 1;
      if ( !MobileSettings::settings[24].value )
      {
LABEL_28:
        CFont::SetDropShadowPosition(0);
        return;
      }
      v0.n64_f32[0] = (float)((float)RsGlobal.screenWidth / 640.0) * 40.0;
      v1.n64_f32[0] = (float)((float)RsGlobal.screenWidth * 0.0) + (float)((float)RsGlobal.screenWidth * 0.0);
      CFont::SetCentreSize((float)RsGlobal.screenWidth - vmax_f32(v0, v1).n64_f32[0]);
      v6 = OS_SystemForm();
      v7 = dword_439280;
      if ( v6 == OSDF_Phone )
        v7 = &dword_439280[1];
      CFont::SetScale(*(float *)v7 * (float)((float)RsGlobal.screenHeight / 448.0));
      screenHeight = RsGlobal.screenHeight;
      CutsceneBarHeight = CCamera::GetCutsceneBarHeight(&TheCamera);
      v10 = (float)RsGlobal.screenHeight;
      v11 = CCamera::GetCutsceneBarHeight(&TheCamera);
      v12 = (float)RsGlobal.screenHeight;
      v2.n64_f32[0] = v10 * 0.0;
      Height = CFont::GetHeight(0);
      v1.n64_f32[0] = CutsceneBarHeight;
      v14 = vmax_f32(v1, v2).n64_f32[0];
      NumberLines = CFont::GetNumberLines((float)RsGlobal.screenWidth * 0.5, (float)screenHeight - v14, CHud::m_Message);
      v16 = (float)RsGlobal.screenWidth * 0.5;
      if ( (float)(v11 - (float)(v12 * 0.0)) > (float)(Height * (float)NumberLines) )
      {
        v17 = (float)RsGlobal.screenWidth * 0.5;
        v18 = (float)screenHeight - v14;
LABEL_27:
        CFont::PrintString(v17, v18, CHud::m_Message);
        goto LABEL_28;
      }
      v19 = CFont::GetHeight(0);
      v20 = (float)CFont::GetNumberLines((float)RsGlobal.screenWidth * 0.5, (float)screenHeight - v14, CHud::m_Message);
      v17 = v16;
      v21 = (float)((float)screenHeight - v14) + (float)((float)(v19 * v20) * -1.1);
    }
    else
    {
      if ( CHud::DrawSubtitles(void)::AreWeInCutScene == 1 )
        CHud::m_Message[0] = 0;
      CHud::DrawSubtitles(void)::AreWeInCutScene = 0;
      CFont::SetScale((float)((float)RsGlobal.screenHeight / 448.0) * 1.22);
      if ( CTheScripts::bUseMessageFormatting )
      {
        CFont::SetCentreSize((float)((float)RsGlobal.screenWidth / 640.0) * (float)CTheScripts::MessageWidth);
        v17 = (float)((float)RsGlobal.screenWidth / 640.0) * (float)CTheScripts::MessageCentre;
        v18 = (float)((float)RsGlobal.screenHeight + (float)((float)((float)RsGlobal.screenHeight / 448.0) * -105.0))
            + (float)((float)((float)RsGlobal.screenHeight / 448.0) * -2.0);
        goto LABEL_27;
      }
      CFont::SetCentreSize((float)RsGlobal.screenWidth + (float)((float)((float)RsGlobal.screenWidth / -640.0) * 280.0));
      if ( CTouchInterface::m_pWidgets[180] && CWidget::GetEnabled(CTouchInterface::m_pWidgets[180]) )
        CFont::SetCentreSize(
          (float)RsGlobal.screenWidth
        + (float)(fabsf(
                    CTouchInterface::m_pWidgets[180]->m_RectScreen.right
                  - CTouchInterface::m_pWidgets[180]->m_RectScreen.left)
                * -2.5));
      if ( CTouchInterface::m_pWidgets[156] && CWidget::GetEnabled(CTouchInterface::m_pWidgets[156]) )
        CFont::SetCentreSize(
          (float)RsGlobal.screenWidth
        + (float)(fabsf(
                    CTouchInterface::m_pWidgets[156]->m_RectScreen.right
                  - CTouchInterface::m_pWidgets[156]->m_RectScreen.left)
                * -2.5));
      CFont::SetScale((float)RsGlobal.screenHeight / 448.0);
      v22 = CFont::GetHeight(0);
      v23 = RsGlobal.screenHeight
          - (int)(float)(v22 * (float)CFont::GetNumberLines((float)(RsGlobal.screenWidth / 2), 0.0, CHud::m_Message));
      v17 = (float)RsGlobal.screenWidth * 0.5;
      v21 = (float)v23 + (float)((float)((float)RsGlobal.screenHeight / 448.0) * -25.0);
    }
    v18 = v21;
    goto LABEL_27;
  }
}
// 438E0E: variable 'v3' is possibly undefined
// 438E3C: variable 'v4' is possibly undefined
// 438E54: variable 'v5' is possibly undefined
// 438EB8: variable 'v0' is possibly undefined
// 438EB8: variable 'v1' is possibly undefined
// 438F44: variable 'v2' is possibly undefined
// 439280: using guessed type int dword_439280[2];
// 992048: using guessed type char CHud::DrawSubtitles(void)::AreWeInCutScene;

//----- (004392F8) --------------------------------------------------------
void CHud::DrawSuccessFailedMessage()
{
  char v0; // r0
  float v1; // s0
  CRGBA v2; // r0
  float v3; // s0
  float v4; // s0
  float v5; // s0
  CRGBA v6; // [sp+8h] [bp-10h] BYREF
  CRGBA v7; // [sp+Ch] [bp-Ch] BYREF

  v0 = `guard variable for'CHud::DrawSuccessFailedMessage(void)::complete_y_position;
  __dmb(0xBu);
  if ( (v0 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'CHud::DrawSuccessFailedMessage(void)::complete_y_position) )
  {
    CHud::DrawSuccessFailedMessage(void)::complete_y_position = (float)(RsGlobal.screenHeight / 2)
                                                              + (float)((float)((float)RsGlobal.screenHeight / -448.0)
                                                                      * 10.0);
    _cxa_guard_release((__guard *)&`guard variable for'CHud::DrawSuccessFailedMessage(void)::complete_y_position);
  }
  if ( CHud::m_BigMessage[0][0] )
  {
    if ( BigMessageInUse[0] == 0.0 )
    {
      BigMessageInUse[0] = 1.0;
      BigMessageX[0] = -60.0;
      BigMessageAlpha[0] = 0.0;
      if ( (CHud::m_BigMessage[3][0] | CHud::m_BigMessage[5][0]) << 16 )
      {
        v4 = (float)((float)((float)RsGlobal.screenHeight / 448.0) * 25.0)
           + (float)((float)(RsGlobal.screenHeight / 2) + (float)((float)((float)RsGlobal.screenHeight / 448.0) * -10.0));
      }
      else if ( CHud::m_BigMessage[2][0]
             || CFont::GetNumberLines(
                  (float)(RsGlobal.screenWidth / 2),
                  (float)(RsGlobal.screenHeight / 2) + (float)((float)((float)RsGlobal.screenHeight / -448.0) * 10.0),
                  CHud::m_BigMessage[0]) < 2 )
      {
        v4 = (float)(RsGlobal.screenHeight / 2) + (float)((float)((float)RsGlobal.screenHeight / -448.0) * 10.0);
      }
      else
      {
        v4 = (float)((float)(RsGlobal.screenHeight / 2) + (float)((float)((float)RsGlobal.screenHeight / 448.0) * -10.0))
           + (float)((float)((float)RsGlobal.screenHeight / 448.0) * -15.0);
      }
      CHud::DrawSuccessFailedMessage(void)::complete_y_position = v4;
    }
    else
    {
      CFont::SetBackground(0, 0);
      v1 = (float)((float)RsGlobal.screenHeight / 448.0) * 1.8;
      CFont::SetScale(v1);
      CFont::SetProportional(1u);
      CFont::SetJustify(0);
      CFont::SetOrientation(0);
      CFont::SetCentreSize((float)((float)RsGlobal.screenWidth / 640.0) * 590.0);
      CFont::SetFontStyle(3u);
      CFont::SetEdge(2);
      CRGBA::CRGBA(&v7, 0, 0, 0, (unsigned int)BigMessageAlpha[0]);
      CFont::SetDropColor(v2);
      CHudColours::GetRGB(&v6, &HudColour, 7u, (unsigned int)BigMessageAlpha[0]);
      CFont::SetColor((CRGBA)&v6);
      if ( BigMessageX[0] >= (float)(RsGlobal.screenWidth - 20) )
      {
        BigMessageInUse[0] = CTimer::ms_fTimeStep + BigMessageInUse[0];
        if ( BigMessageInUse[0] < 120.0 )
        {
          v5 = BigMessageAlpha[0];
        }
        else
        {
          BigMessageInUse[0] = 120.0;
          v5 = BigMessageAlpha[0]
             + (float)((float)(unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0) * -0.3);
          BigMessageAlpha[0] = v5;
        }
        if ( v5 <= 0.0 )
        {
          CHud::m_BigMessage[0][0] = 0;
          BigMessageAlpha[0] = 0.0;
        }
      }
      else
      {
        v3 = (float)(unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0) * 0.3;
        BigMessageX[0] = BigMessageX[0] + v3;
        BigMessageAlpha[0] = BigMessageAlpha[0] + v3;
        if ( BigMessageAlpha[0] > 255.0 )
          BigMessageAlpha[0] = 255.0;
      }
      CFont::PrintString(
        (float)(RsGlobal.screenWidth / 2),
        CHud::DrawSuccessFailedMessage(void)::complete_y_position,
        CHud::m_BigMessage[0]);
    }
  }
  else
  {
    BigMessageInUse[0] = 0.0;
  }
}
// 439424: variable 'v2' is possibly undefined
// 992050: using guessed type char `guard variable for'CHud::DrawSuccessFailedMessage(void)::complete_y_position;

//----- (004397B4) --------------------------------------------------------
void CHud::DrawBustedWastedMessage()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d2
  char v2; // r0
  CRGBA v3; // r0
  CRGBA v4; // [sp+8h] [bp-10h] BYREF
  CRGBA v5; // [sp+Ch] [bp-Ch] BYREF

  if ( CHud::m_BigMessage[2][0] )
  {
    v2 = `guard variable for'CHud::DrawBustedWastedMessage(void)::wasted_y_position;
    __dmb(0xBu);
    if ( (v2 & 1) == 0
      && _cxa_guard_acquire((__guard *)&`guard variable for'CHud::DrawBustedWastedMessage(void)::wasted_y_position) )
    {
      CHud::DrawBustedWastedMessage(void)::wasted_y_position = (float)(RsGlobal.screenHeight / 2)
                                                             + (float)((float)((float)RsGlobal.screenHeight / -448.0)
                                                                     * 30.0);
      _cxa_guard_release((__guard *)&`guard variable for'CHud::DrawBustedWastedMessage(void)::wasted_y_position);
    }
    if ( BigMessageInUse[2] == 0.0 )
    {
      BigMessageAlpha[2] = 0.0;
      BigMessageInUse[2] = 1.0;
      if ( CHud::m_VehicleState )
        CHud::m_VehicleState = 0;
      if ( CHud::m_ZoneState )
        CHud::m_ZoneState = 0;
      CHud::DrawBustedWastedMessage(void)::wasted_y_position = (float)(RsGlobal.screenHeight / 2)
                                                             + (float)((float)((float)RsGlobal.screenHeight / -448.0)
                                                                     * 30.0);
    }
    else
    {
      v1.n64_u32[0] = 1132396544;
      v0.n64_f32[0] = BigMessageAlpha[2]
                    + (float)((float)(unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0) * 0.4);
      LODWORD(BigMessageAlpha[2]) = vmin_f32(v0, v1).n64_u32[0];
      CFont::SetBackground(0, 0);
      CFont::SetScale((float)((float)RsGlobal.screenHeight / 448.0) * 2.1);
      CFont::SetProportional(1u);
      CFont::SetJustify(0);
      CFont::SetOrientation(0);
      CFont::SetFontStyle(0);
      CFont::SetEdge(3);
      CRGBA::CRGBA(&v5, 0, 0, 0, (unsigned int)BigMessageAlpha[2]);
      CFont::SetDropColor(v3);
      CHudColours::GetRGB(&v4, &HudColour, 5u, (unsigned int)BigMessageAlpha[2]);
      CFont::SetColor((CRGBA)&v4);
      CFont::PrintStringFromBottom(
        (float)(RsGlobal.screenWidth / 2),
        CHud::DrawBustedWastedMessage(void)::wasted_y_position,
        CHud::m_BigMessage[2]);
    }
  }
  else
  {
    BigMessageInUse[2] = 0.0;
  }
}
// 439902: variable 'v0' is possibly undefined
// 439902: variable 'v1' is possibly undefined
// 43996E: variable 'v3' is possibly undefined
// 992058: using guessed type char `guard variable for'CHud::DrawBustedWastedMessage(void)::wasted_y_position;

//----- (00439A34) --------------------------------------------------------
void __fastcall CHud::DrawOddJobMessage(Bool8 bBeforeFade)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d2
  int v4; // r4
  CRGBA v5; // r0
  CRGBA v6; // r0
  CRGBA v7; // r0
  CRGBA v8; // r0
  float v9; // s0
  unsigned int v10; // r2
  unsigned int v11; // r1
  Int16 v12; // r0
  CRGBA v13; // r0
  CRGBA v14; // [sp+8h] [bp-40h] BYREF
  CRGBA v15; // [sp+Ch] [bp-3Ch] BYREF
  CRGBA v16; // [sp+10h] [bp-38h] BYREF
  CRGBA v17; // [sp+14h] [bp-34h] BYREF
  CRGBA v18; // [sp+18h] [bp-30h] BYREF
  CRGBA v19; // [sp+1Ch] [bp-2Ch] BYREF
  CRGBA v20; // [sp+20h] [bp-28h] BYREF
  CRGBA v21; // [sp+24h] [bp-24h] BYREF
  CRGBA v22; // [sp+28h] [bp-20h] BYREF
  CRGBA v23; // [sp+2Ch] [bp-1Ch] BYREF

  v4 = bBeforeFade;
  if ( CTheScripts::bDrawOddJobTitleBeforeFade == bBeforeFade && !CHud::m_BigMessage[1][0] && CHud::m_BigMessage[4][0] )
  {
    CFont::SetBackground(0, 0);
    CFont::SetJustify(0);
    CFont::SetScale((float)((float)RsGlobal.screenHeight / 448.0) * 1.35);
    CFont::SetOrientation(0);
    CFont::SetProportional(1u);
    CFont::SetCentreSize((float)((float)RsGlobal.screenWidth / 640.0) * 350.0);
    CFont::SetFontStyle(2u);
    CFont::SetEdge(2);
    CRGBA::CRGBA(&v23, 0, 0, 0, 0xFFu);
    CFont::SetDropColor(v5);
    CHudColours::GetRGBA(&v22, &HudColour, 7u);
    CFont::SetColor((CRGBA)&v22);
    CFont::PrintStringFromBottom(
      (float)(RsGlobal.screenWidth / 2),
      (float)((float)RsGlobal.screenHeight / 448.0) * 140.0,
      CHud::m_BigMessage[4]);
  }
  if ( v4 )
  {
    if ( CHud::m_BigMessage[6][0] )
    {
      CFont::SetBackground(0, 0);
      CFont::SetJustify(0);
      CFont::SetScale((float)((float)RsGlobal.screenHeight / 448.0) * 1.8);
      CFont::SetOrientation(0);
      CFont::SetProportional(1u);
      CFont::SetCentreSize((float)((float)RsGlobal.screenWidth / 640.0) * 500.0);
      CFont::SetFontStyle(3u);
      CFont::SetEdge(2);
      CRGBA::CRGBA(&v21, 0, 0, 0, 0xFFu);
      CFont::SetDropColor(v6);
      CHudColours::GetRGBA(&v20, &HudColour, 3u);
      CFont::SetColor((CRGBA)&v20);
      CFont::PrintString(
        (float)(RsGlobal.screenWidth / 2),
        (float)((float)RsGlobal.screenHeight / 448.0) * 60.0,
        CHud::m_BigMessage[6]);
    }
    if ( CHud::m_BigMessage[7][0] )
    {
      CFont::SetBackground(0, 0);
      CFont::SetJustify(1u);
      CFont::SetScale((float)((float)RsGlobal.screenHeight / 448.0) * 1.8);
      CFont::SetOrientation(0);
      CFont::SetProportional(1u);
      CFont::SetCentreSize((float)((float)RsGlobal.screenWidth / 640.0) * 500.0);
      CFont::SetFontStyle(3u);
      CFont::SetEdge(0);
      CRGBA::CRGBA(&v19, 0, 0, 0, 0xFFu);
      CFont::SetDropColor(v7);
      CHudColours::GetRGBA(&v18, &HudColour, 3u);
      CFont::SetColor((CRGBA)&v18);
      v3.n64_f32[0] = (float)RsGlobal.screenHeight * 0.0;
      v1.n64_f32[0] = (float)RsGlobal.screenHeight * 0.025;
      v1.n64_u64[0] = vmax_f32(v1, v3).n64_u64[0];
      CFont::PrintString((float)(RsGlobal.screenWidth / 2), v1.n64_f32[0], CHud::m_BigMessage[7]);
    }
    if ( CHud::m_BigMessage[3][0] )
    {
      CFont::SetBackground(0, 0);
      CFont::SetJustify(0);
      CFont::SetScale((float)((float)RsGlobal.screenHeight / 448.0) * 1.35);
      CFont::SetOrientation(0);
      CFont::SetProportional(1u);
      CFont::SetCentreSize((float)((float)RsGlobal.screenWidth / 640.0) * 500.0);
      CFont::SetFontStyle(2u);
      CFont::SetEdge(2);
      CRGBA::CRGBA(&v17, 0, 0, 0, 0xFFu);
      CFont::SetDropColor(v8);
      CHudColours::GetRGBA(&v16, &HudColour, 7u);
      CFont::SetColor((CRGBA)&v16);
      CFont::PrintString(
        (float)(RsGlobal.screenWidth / 2),
        (float)((float)RsGlobal.screenHeight / 448.0) * 155.0,
        CHud::m_BigMessage[3]);
    }
    v9 = OddJob2OffTimer;
    if ( OddJob2OffTimer > 0.0 )
    {
      v9 = OddJob2OffTimer - (float)(unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
      OddJob2OffTimer = v9;
    }
    if ( CHud::m_BigMessage[5][0] && v9 <= 0.0 )
    {
      switch ( OddJob2On )
      {
        case 0:
          OddJob2On = 1;
          OddJob2XOffset = 380.0;
          break;
        case 1:
          if ( OddJob2XOffset <= 2.0 )
          {
            OddJob2Timer = 0;
            v12 = 2;
            goto LABEL_25;
          }
          v3.n64_u32[0] = 1109393408;
          v2.n64_f32[0] = OddJob2XOffset / 6.0;
          OddJob2XOffset = OddJob2XOffset - vmin_f32(v2, v3).n64_f32[0];
          break;
        case 2:
          v10 = (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
          v11 = (unsigned __int16)OddJob2Timer + v10;
          OddJob2Timer += v10;
          if ( (int)(v11 << 16) >= 98304001 )
            OddJob2On = 3;
          break;
        case 3:
          v3.n64_u32[0] = 30.0;
          v1.n64_f32[0] = OddJob2XOffset / 5.0;
          OddJob2XOffset = OddJob2XOffset - vmax_f32(v1, v3).n64_f32[0];
          if ( OddJob2XOffset < -380.0 )
          {
            OddJob2OffTimer = 5000.0;
            v12 = 0;
LABEL_25:
            OddJob2On = v12;
          }
          break;
        default:
          break;
      }
      if ( !CHud::m_BigMessage[1][0] )
      {
        CFont::SetBackground(0, 0);
        CFont::SetScale((float)((float)RsGlobal.screenHeight / 448.0) * 1.35);
        CFont::SetOrientation(0);
        CFont::SetProportional(1u);
        CFont::SetCentreSize((float)((float)RsGlobal.screenWidth / 640.0) * 500.0);
        CFont::SetFontStyle(2u);
        CFont::SetEdge(2);
        CRGBA::CRGBA(&v15, 0, 0, 0, 0xFFu);
        CFont::SetDropColor(v13);
        CHudColours::GetRGBA(&v14, &HudColour, 5u);
        CFont::SetColor((CRGBA)&v14);
        CFont::PrintString(
          (float)(RsGlobal.screenWidth / 2),
          (float)((float)RsGlobal.screenHeight / 448.0) * 217.0,
          CHud::m_BigMessage[5]);
      }
    }
  }
}
// 439AF2: variable 'v5' is possibly undefined
// 439C0C: variable 'v6' is possibly undefined
// 439CF6: variable 'v7' is possibly undefined
// 439D46: variable 'v1' is possibly undefined
// 439D46: variable 'v3' is possibly undefined
// 439DE4: variable 'v8' is possibly undefined
// 439EF4: variable 'v2' is possibly undefined
// 43A02E: variable 'v13' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 679CA8: using guessed type char *CTheScripts::bDrawOddJobTitleBeforeFade;

//----- (0043A150) --------------------------------------------------------
void CHud::DrawMissionTitle()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d2
  float v2; // s0
  CRGBA v3; // r0
  CRGBA v4; // [sp+8h] [bp-10h] BYREF
  CRGBA v5; // [sp+Ch] [bp-Ch] BYREF

  if ( CHud::m_BigMessage[1][0] )
  {
    if ( BigMessageInUse[1] == 0.0 )
    {
      BigMessageInUse[1] = 1.0;
      BigMessageX[1] = -60.0;
      CHud::m_ZoneState = 0;
      CHud::m_ZoneFadeTimer = 0;
      if ( CTouchInterface::m_pWidgets[162] )
        sub_1913FC((CWidgetHelpText *)CTouchInterface::m_pWidgets[162], 0);
    }
    else
    {
      CFont::SetBackground(0, 0);
      CFont::SetProportional(1u);
      CFont::SetRightJustifyWrap(0.0);
      CFont::SetOrientation(2u);
      CFont::SetFontStyle(3u);
      CFont::SetScale((float)((float)RsGlobal.screenHeight / 448.0) * 1.3);
      if ( BigMessageX[1] >= (float)(RsGlobal.screenWidth - 20) )
      {
        BigMessageInUse[1] = CTimer::ms_fTimeStep + BigMessageInUse[1];
        if ( BigMessageInUse[1] < 120.0 )
        {
          v2 = BigMessageAlpha[1];
        }
        else
        {
          BigMessageInUse[1] = 120.0;
          v2 = BigMessageAlpha[1] - (float)(unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
          BigMessageAlpha[1] = v2;
        }
        if ( v2 <= 0.0 )
        {
          CHud::m_BigMessage[1][0] = 0;
          BigMessageAlpha[1] = 0.0;
          BigMessageInUse[1] = 0.0;
        }
      }
      else
      {
        BigMessageAlpha[1] = 255.0;
        BigMessageX[1] = BigMessageX[1]
                       + (float)((float)(unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0) * 0.3);
      }
      CFont::SetEdge(2);
      CRGBA::CRGBA(&v5, 0, 0, 0, (unsigned int)BigMessageAlpha[1]);
      CFont::SetDropColor(v3);
      CHudColours::GetRGB(&v4, &HudColour, 7u, (unsigned int)BigMessageAlpha[1]);
      CFont::SetColor((CRGBA)&v4);
      v1.n64_f32[0] = (float)RsGlobal.screenWidth + (float)((float)RsGlobal.screenWidth * -0.0);
      v0.n64_f32[0] = (float)RsGlobal.screenWidth + (float)((float)((float)RsGlobal.screenWidth / -640.0) * 20.0);
      CFont::PrintStringFromBottom(
        vmin_f32(v0, v1).n64_f32[0],
        (float)RsGlobal.screenHeight + (float)((float)((float)RsGlobal.screenHeight / -448.0) * 115.0),
        CHud::m_BigMessage[1]);
      CFont::SetEdge(0);
    }
  }
  else
  {
    BigMessageInUse[1] = 0.0;
  }
}
// 43A330: variable 'v3' is possibly undefined
// 43A3AE: variable 'v0' is possibly undefined
// 43A3AE: variable 'v1' is possibly undefined

//----- (0043A44C) --------------------------------------------------------
void CHud::Draw()
{
  bool v0; // zf
  CPad *Pad; // r0
  CPad *v2; // r4
  CPlayerPed *PlayerPed; // r0
  char v4; // r0

  if ( !CWeapon::ms_bTakePhoto )
  {
    v0 = gMobileMenu.screenStack.numEntries == 0;
    if ( !gMobileMenu.screenStack.numEntries )
      v0 = gMobileMenu.pendingScreen == 0;
    if ( v0 && gbCineyCamProcessedOnFrame != CTimer::m_FrameCounter )
    {
      RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 1);
      RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
      RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
      RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
      RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
      RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
      RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
      RwRenderStateSet(rwRENDERSTATETEXTUREADDRESS, (char *)&dword_0 + 3);
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
      RwRenderStateSet(rwRENDERSTATESHADEMODE, (char *)&dword_0 + 1);
      RwRenderStateSet(rwRENDERSTATEALPHATESTFUNCTION, &byte_5);
      RwRenderStateSet(rwRENDERSTATEALPHATESTFUNCTIONREF, 0);
      if ( !TheCamera.m_WideScreenOn )
      {
        CHud::DrawCrossHairs();
        if ( !CHud::bScriptDontDisplayVehicleName )
          CHud::DrawVehicleName();
        if ( !CHud::bDrawingVitalStats
          && CUserDisplay::OnscnTimer.ClockOrCountersToDisplay
          && (CHud::m_BigMessage[4][0] == 0 || CHud::bScriptForceDisplayWithCounters != 0)
          && !CGarages::MessageIDString[0] )
        {
          CTouchInterface::IsReleased(WIDGET_MISSION_TIMERS, 0, 2);
        }
      }
      if ( (CHud::bScriptDontDisplayRadar | TheCamera.m_WideScreenOn) << 24 )
        goto LABEL_25;
      Pad = CPad::GetPad(0);
      CPad::GetDisplayScreenRecord(Pad);
      v2 = CPad::GetPad(0);
      PlayerPed = FindPlayerPed(-1);
      CHud::bDrawingVitalStats = CPad::GetDisplayVitalStats(v2, PlayerPed);
      if ( CHud::bDrawingVitalStats && !TheCamera.m_WideScreenOn )
        CTouchInterface::IsReleased(WIDGET_VITAL_STATS, 0, 2);
      CHud::DrawRadar();
      if ( CGameLogic::SkipCanBeActivated() )
      {
        if ( CHud::Draw(void)::DisplayedHelperTextForTripSkip )
          goto LABEL_25;
        v4 = 1;
      }
      else
      {
        v4 = 0;
      }
      CHud::Draw(void)::DisplayedHelperTextForTripSkip = v4;
LABEL_25:
      if ( CHud::m_Wants_To_Draw_3dMarkers && !TheCamera.m_WideScreenOn )
        CRadar::Draw3dMarkers();
      if ( !CTimer::m_UserPause )
      {
        emu_GammaSet(1u);
        if ( !CHud::m_BigMessage[0][0] )
        {
          if ( CMenuSystem::num_menus_in_use )
            CMenuSystem::Process(-99);
          CHud::DrawScriptText(1u);
        }
        if ( CTheScripts::bDrawSubtitlesBeforeFade )
          CHud::DrawSubtitles();
        CHud::DrawOddJobMessage(1u);
        CHud::DrawSuccessFailedMessage();
        CHud::DrawBustedWastedMessage();
        sub_18ED4C(0);
      }
    }
  }
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;
// 6787E0: using guessed type char *CTheScripts::bDrawSubtitlesBeforeFade;

//----- (0043A6A8) --------------------------------------------------------
void CHud::DrawAfterFade()
{
  CVehicle *PlayerVehicle; // r0
  bool8 m_bLeftButton; // r0

  RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATETEXTUREADDRESS, (char *)&dword_0 + 3);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
  if ( (CTimer::m_UserPause || CWeapon::ms_bTakePhoto) << 24 )
    return;
  emu_GammaSet(1u);
  if ( !FindPlayerVehicle(-1, 0) )
  {
    if ( CCutsceneMgr::ms_cutsceneProcessing || gMobileMenu.screenStack.numEntries || gMobileMenu.pendingScreen )
      goto LABEL_15;
LABEL_12:
    if ( !((TheCamera.m_WideScreenOn | CHud::bScriptDontDisplayAreaName) << 24) && !CHud::m_VehicleState )
      CHud::DrawAreaName();
    goto LABEL_15;
  }
  if ( FindPlayerVehicle(-1, 0)->m_vehicleType != 4 )
  {
    PlayerVehicle = FindPlayerVehicle(-1, 0);
    if ( !gMobileMenu.pendingScreen
      && PlayerVehicle->m_vehicleType != 3
      && !CCutsceneMgr::ms_cutsceneProcessing
      && !gMobileMenu.screenStack.numEntries )
    {
      goto LABEL_12;
    }
  }
LABEL_15:
  if ( !CHud::m_BigMessage[0][0] )
    CHud::DrawScriptText(0);
  emu_GammaSet(0);
  CPad::GetPad(0);
  if ( CPad::NewMouseControllerState.m_bRightButton && CHID::GetInputType() != 2 )
  {
    CPad::GetPad(0);
    m_bLeftButton = CPad::NewMouseControllerState.m_bLeftButton;
    if ( CPad::NewMouseControllerState.m_bLeftButton )
      m_bLeftButton = 1;
    CTouchInterface::VisualizeAll(m_bLeftButton);
  }
  CTouchInterface::DrawAll(1);
  if ( !((CCutsceneMgr::ms_running | CGarages::MessageIDString[0]) << 24) && CTouchInterface::m_pWidgets[162] )
    CWidgetHelpText::Process((CWidgetHelpText *)CTouchInterface::m_pWidgets[162]);
  if ( CTouchInterface::m_pWidgets[41] )
    CWidgetButton::Draw((CWidgetButton *)CTouchInterface::m_pWidgets[41]);
  if ( !CTheScripts::bDrawSubtitlesBeforeFade )
    CHud::DrawSubtitles();
  CHud::DrawMissionTitle();
  CHud::DrawOddJobMessage(0);
}
// 0: using guessed type int dword_0;
// 6787E0: using guessed type char *CTheScripts::bDrawSubtitlesBeforeFade;

//----- (0043A858) --------------------------------------------------------
float __fastcall CHud::DrawFadeState(DRAW_FADE_STATE flag, RwBool change)
{
  int v2; // r3
  int v3; // r4
  int v4; // r12
  float32x2_t v5; // d0
  float32x2_t v6; // d1
  float32x2_t v7; // d2
  int *v8; // r2
  int **v9; // r3
  int **v10; // r12
  int *v11; // lr
  int v12; // r1
  int v13; // r2
  float v14; // s0
  int *v15; // r2
  int *v16; // r3
  int *v17; // r0
  float result; // r0
  bool v19; // cc
  unsigned int v20; // r1

  switch ( flag )
  {
    case DS_WANTED:
      v8 = (int *)&CHud::m_WantedFadeTimer;
      v9 = CHud::m_WantedTimer;
      v10 = &CHud::m_WantedState;
      goto LABEL_6;
    case DS_ENERGY_LOST:
      v8 = (int *)&CHud::m_EnergyLostFadeTimer;
      v9 = &CHud::m_EnergyLostTimer;
      v10 = (int **)&CHud::m_EnergyLostState;
      goto LABEL_6;
    case DS_DISPLAY_SCORE:
      v8 = &CHud::m_DisplayScoreFadeTimer;
      v9 = &CHud::m_DisplayScoreTimer;
      v10 = &CHud::m_DisplayScoreState;
      goto LABEL_6;
    case DS_WEAPON:
      v8 = &CHud::m_WeaponFadeTimer;
      v9 = &CHud::m_WeaponTimer;
      v10 = &CHud::m_WeaponState;
LABEL_6:
      v11 = *v10;
      v3 = *(_DWORD *)*v8;
      v4 = **v9;
      v2 = *v11;
      break;
    default:
      break;
  }
  v5.n64_u32[0] = 1132396544;
  if ( change )
  {
    v12 = 5;
    switch ( v2 )
    {
      case 0:
        v12 = 5;
        v3 = 0;
        goto LABEL_15;
      case 1:
      case 3:
        goto LABEL_15;
      case 2:
        goto LABEL_14;
      case 5:
        break;
      default:
        goto LABEL_20;
    }
  }
  else
  {
    v12 = v2;
    switch ( v2 )
    {
      case 0:
      case 5:
        goto LABEL_21;
      case 1:
        v3 = 1000;
        v2 = 1;
        if ( v4 > 10000 )
        {
          v3 = 3000;
          v2 = 3;
        }
        break;
      case 2:
LABEL_14:
        v12 = v4;
LABEL_15:
        v2 = 2;
        v4 = v12;
        v3 += (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
        v13 = v3;
        if ( v3 > 1000 )
          v3 = 1000;
        v14 = (float)v3;
        if ( v13 > 1000 )
          v2 = 1;
        goto LABEL_19;
      case 3:
        v19 = (int)(v3 - (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0)) <= 0;
        v3 -= (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
        v20 = (v3 >> 31) & 0xFFFFFFFD;
        if ( v19 )
          v3 = 0;
        v2 = v20 + 3;
        v14 = (float)v3;
LABEL_19:
        v5.n64_f32[0] = (float)(v14 / 1000.0) * 255.0;
        break;
      default:
        break;
    }
LABEL_20:
    v4 += (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
    v12 = v2;
  }
LABEL_21:
  if ( (unsigned int)flag <= DS_WEAPON )
  {
    v15 = (int *)off_667D5C[flag];
    v16 = (int *)off_667D6C[flag];
    v17 = (int *)off_667D7C[flag];
    *v15 = v12;
    *v16 = v4;
    *v17 = v3;
  }
  v6.n64_u32[0] = 0;
  v7.n64_u32[0] = 1132396544;
  LODWORD(result) = vmin_f32(vmax_f32(v5, v6), v7).n64_u32[0];
  return result;
}
// 43A8C6: variable 'v2' is possibly undefined
// 43A8F4: variable 'v4' is possibly undefined
// 43A92E: variable 'v3' is possibly undefined
// 43A9A6: variable 'v5' is possibly undefined
// 43A9A6: variable 'v6' is possibly undefined
// 43A9AA: variable 'v7' is possibly undefined
// 667D5C: using guessed type int off_667D5C[12];
// 667D6C: using guessed type int off_667D6C[8];
// 667D7C: using guessed type int off_667D7C[4];
// 67608C: using guessed type int CHud::m_DisplayScoreFadeTimer;
// 6769D0: using guessed type int *CHud::m_WantedTimer[4];
// 676AD0: using guessed type int *CHud::m_EnergyLostTimer;
// 677074: using guessed type int *CHud::m_DisplayScoreTimer;
// 677128: using guessed type int *CHud::m_WantedState;
// 6775C4: using guessed type int *CHud::m_WeaponTimer;
// 677728: using guessed type int CHud::m_WeaponFadeTimer;
// 677C50: using guessed type int *CHud::m_DisplayScoreState;
// 678108: using guessed type int *CHud::m_WantedFadeTimer;
// 678F44: using guessed type int *CHud::m_EnergyLostFadeTimer;
// 6792E4: using guessed type int CHud::m_EnergyLostState;
// 679D68: using guessed type int *CHud::m_WeaponState;

//----- (0043AA50) --------------------------------------------------------
void __fastcall CHudColours::CHudColours(CHudColours *this)
{
  *(_QWORD *)&this->value[0]._anon_0._anon_0.red = 0xFF2C6836FF1D19B4LL;
  *(_QWORD *)&this->value[2]._anon_0._anon_0.red = 0xFFF1CBACFF7F3C32LL;
  this->value[4]._anon_0._anon_0.red = 100;
  *(_QWORD *)&this->value[9]._anon_0._anon_0.green = loc_43AAF0;
  *(_QWORD *)&this->value[11]._anon_0._anon_0.green = loc_43AAF8;
  *(_WORD *)&this->value[4]._anon_0._anon_0.green = -13156;
  this->value[5]._anon_0._anon_0.alpha = -1;
  *(CRGBA *)((char *)&this->value[4] + 3) = (CRGBA)-1;
  this->value[6]._anon_0._anon_0.red = 0;
  this->value[6]._anon_0._anon_0.alpha = -1;
  *(_WORD *)&this->value[6]._anon_0._anon_0.green = 0;
  this->value[7]._anon_0._anon_0.red = -112;
  this->value[7]._anon_0._anon_0.alpha = -1;
  *(_WORD *)&this->value[7]._anon_0._anon_0.green = 4194;
  this->value[8]._anon_0._anon_0.red = -88;
  this->value[8]._anon_0._anon_0.alpha = -1;
  *(_WORD *)&this->value[8]._anon_0._anon_0.green = -914;
  this->value[9]._anon_0._anon_0.red = -106;
  this->value[13]._anon_0._anon_0.alpha = -1;
  *(_WORD *)&this->value[13]._anon_0._anon_0.green = 27482;
  this->value[14]._anon_0._anon_0.alpha = -1;
  *(_WORD *)&this->value[14]._anon_0._anon_0.green = -14311;
  this->value[14]._anon_0._anon_0.red = 20;
  this->value[15]._anon_0._anon_0.alpha = -1;
  *(_WORD *)&this->value[15]._anon_0._anon_0.green = 255;
  this->value[15]._anon_0._anon_0.red = -1;
}

//----- (0043AB00) --------------------------------------------------------
void __fastcall CHudColours::SetRGBAValue(CHudColours *this, int colour_id, uint8 r, uint8 g, uint8 b, uint8 a)
{
  CRGBA *v6; // r0

  this->value[colour_id]._anon_0._anon_0.red = r;
  v6 = &this->value[colour_id];
  v6->_anon_0._anon_0.green = g;
  v6->_anon_0._anon_0.blue = b;
  v6->_anon_0._anon_0.alpha = a;
}

//----- (0043AB1C) --------------------------------------------------------
void __fastcall CHudColours::GetRGBA(CRGBA *a1, CHudColours *this, int colour_id)
{
  CRGBA::CRGBA(
    a1,
    this->value[colour_id]._anon_0._anon_0.red,
    this->value[colour_id]._anon_0._anon_0.green,
    this->value[colour_id]._anon_0._anon_0.blue,
    this->value[colour_id]._anon_0._anon_0.alpha);
}

//----- (0043AB3C) --------------------------------------------------------
UInt32 __fastcall CHudColours::GetIntColour(CHudColours *this, uint8 colour_id)
{
  return ((this->value[colour_id]._anon_0._anon_0.blue << 8) | 0xFF)
       + ((this->value[colour_id]._anon_0._anon_0.green << 16) | 0xFF)
       + ((this->value[colour_id]._anon_0._anon_0.red << 24) | 0xFF);
}

//----- (0043AB5C) --------------------------------------------------------
void __fastcall CHudColours::GetRGB(CRGBA *a1, CHudColours *this, int colour_id, uint8 alpha)
{
  CRGBA::CRGBA(
    a1,
    this->value[colour_id]._anon_0._anon_0.red,
    this->value[colour_id]._anon_0._anon_0.green,
    this->value[colour_id]._anon_0._anon_0.blue,
    alpha);
}

//----- (0043AB80) --------------------------------------------------------
void __fastcall CLoadingScreen::Init(bool bLegalScreen, bool dont_reload)
{
  unsigned int v2; // r0

  if ( !CLoadingScreen::m_bActive )
  {
    if ( !dont_reload )
      CLoadingScreen::LoadSplashes(0, 0);
    CLoadingScreen::m_currDisplayedSplash = -1;
    v2 = RsTimer();
    CLoadingScreen::m_bActive = 1;
    CLoadingScreen::m_timeSinceLastScreen = (float)v2 / 1000.0;
  }
}

//----- (0043ABEC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CLoadingScreen::LoadSplashes(bool8 use_splash_id, uint8 id)
{
  int v2; // r9
  int v3; // r4
  int32 v4; // r6
  int v5; // r5
  TextureDatabaseRuntime *Database; // r10
  int v7; // r6
  int v8; // r2
  unsigned int v9; // lr
  int v10; // r0
  unsigned int v11; // r12
  _QWORD *v12; // r3
  unsigned int v13; // r2
  __int64 v14; // d17
  int v15; // [sp+4h] [bp-54h]
  int v16; // [sp+Ah] [bp-4Eh] BYREF
  __int16 v17; // [sp+Eh] [bp-4Ah]
  char v18; // [sp+10h] [bp-48h]
  _BYTE choices[13]; // [sp+12h] [bp-46h] OVERLAPPED BYREF

  v2 = use_splash_id;
  v15 = id;
  CFileMgr::SetDir("MODELS\\TXD\\");
  v3 = 0;
  v4 = CTxdStore::AddTxdSlot("loadscs", (const unsigned __int8 *)&off_43ADA8, 0);
  CTxdStore::LoadTxd(v4, "loadscs.txd");
  CTxdStore::AddRef(v4);
  CTxdStore::PushCurrentTxd();
  CTxdStore::SetCurrentTxd(v4, 0);
  v5 = 6;
  v16 = 50462976;
  v17 = 1284;
  v18 = 6;
  Database = TextureDatabaseRuntime::GetDatabase("menu");
  TextureDatabaseRuntime::Register(Database);
  v7 = 7;
  do
  {
    if ( v3 )
      v8 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * (float)v7);
    else
      v8 = 0;
    --v7;
    choices[v3 - 1] = *((_BYTE *)&v16 + v8);
    if ( v8 < v7 )
    {
      v9 = 6 - v3 - v8;
      if ( v9 < 0x10 )
      {
        v10 = v8;
        goto LABEL_14;
      }
      v11 = v9 & 0xFFFFFFF0;
      if ( (v9 & 0xFFFFFFF0) == 0 )
      {
        v10 = v8;
        do
        {
LABEL_14:
          *((_BYTE *)&v16 + v10) = *((_BYTE *)&v16 + v10 + 1);
          ++v10;
        }
        while ( v3 + v10 != 6 );
        goto LABEL_15;
      }
      v10 = v8 + v11;
      v12 = (_QWORD *)((char *)&v16 + v8);
      v13 = (v5 - v8) & 0xFFFFFFF0;
      do
      {
        v13 -= 16;
        v14 = *(_QWORD *)((char *)v12 + 9);
        *v12 = *(_QWORD *)((char *)v12 + 1);
        v12[1] = v14;
        v12 += 2;
      }
      while ( v13 );
      if ( v9 != v11 )
        goto LABEL_14;
    }
LABEL_15:
    ++v3;
    --v5;
  }
  while ( v3 != 7 );
  choices[5] = v16;
  if ( v2 )
  {
    if ( v15 == 1 )
      strcpy(&choices[6], "nvidia");
    else
      strcpy(&choices[6], "eax");
  }
  else
  {
    CSprite2d::SetTexture(CLoadingScreen::m_aSplashes, 0);
    sprintf(&choices[6], "mobilesc%d", choices[0]);
    CSprite2d::SetTexture(&CLoadingScreen::m_aSplashes[1], &choices[6]);
  }
  CTxdStore::PopCurrentTxd();
  TextureDatabaseRuntime::Unregister(Database);
  CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
}
// 43ABEC: variables would overlap: ^12.13 and stkvar "choices" ^12.7(has user info),stkvar "splashOrder" ^19.7(has user info)
// 43ADA8: using guessed type void *off_43ADA8;
// 61CADE: using guessed type char byte_61CADE;

//----- (0043ADD4) --------------------------------------------------------
float __fastcall CLoadingScreen::GetClockTime(bool bRealTime)
{
  _BOOL4 v1; // r4
  float v2; // s0
  float v3; // s2

  v1 = bRealTime;
  v2 = (float)RsTimer() / 1000.0;
  v3 = v2 - CLoadingScreen::m_PauseTime;
  if ( v1 )
    return v2;
  return v3;
}

//----- (0043AE14) --------------------------------------------------------
void __fastcall CLoadingScreen::Shutdown(bool bForce)
{
  int32 TxdSlot; // r4

  CLoadingScreen::m_bActive = 0;
  if ( CLoadingScreen::m_aSplashes[0].mpTexture )
    CSprite2d::Delete(CLoadingScreen::m_aSplashes);
  if ( CLoadingScreen::m_aSplashes[1].mpTexture )
    CSprite2d::Delete(&CLoadingScreen::m_aSplashes[1]);
  TxdSlot = CTxdStore::FindTxdSlot("loadscs");
  if ( TxdSlot != -1 )
  {
    CTxdStore::RemoveTxd(TxdSlot);
    sub_197460(TxdSlot);
  }
}

//----- (0043AE88) --------------------------------------------------------
void CLoadingScreen::Continue()
{
  if ( CLoadingScreen::m_bActive )
  {
    CLoadingScreen::m_bWantToPause = 0;
    if ( CLoadingScreen::m_bPaused )
    {
      CLoadingScreen::m_bPaused = 0;
      CLoadingScreen::m_PauseTime = CLoadingScreen::m_PauseTime
                                  + (float)((float)((float)RsTimer() / 1000.0) - CLoadingScreen::m_ClockTimeOnPause);
    }
  }
}

//----- (0043AF0C) --------------------------------------------------------
void CLoadingScreen::NewChunkLoaded()
{
  float v0; // s0

  if ( CLoadingScreen::m_bActive )
  {
    v0 = (float)CLoadingScreen::m_numChunksLoaded * 99.999;
    CLoadingScreen::m_chunkBarAppeared = 1;
    ++CLoadingScreen::m_numChunksLoaded;
    CLoadingScreen::m_PercentLoaded = v0 / (float)CLoadingScreen::m_nChunksToLoad;
    CLoadingScreen::DisplayPCScreen();
  }
}

//----- (0043AF78) --------------------------------------------------------
void CLoadingScreen::DisplayPCScreen()
{
  if ( RwCameraBeginUpdate(Scene.camera) )
  {
    DefinedState2d();
    RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
    emu_DropAltRenderTarget();
    CLoadingScreen::RenderSplash();
    if ( CLoadingScreen::m_currDisplayedSplash >= 1 )
    {
      if ( CLoadingScreen::m_currDisplayedSplash == 1 )
      {
        if ( !CLoadingScreen::m_bFading )
          CLoadingScreen::RenderLoadingBar();
      }
      else
      {
        CLoadingScreen::RenderLoadingBar();
      }
    }
    RwCameraEndUpdate(Scene.camera);
    sub_18EE7C(Scene.camera);
  }
}
// 0: using guessed type int dword_0;

//----- (0043AFF0) --------------------------------------------------------
void CLoadingScreen::RenderSplash()
{
  bool v0; // zf
  float v1; // s0
  float v2; // s0
  float v3; // s0
  float v4; // s0
  float v5; // s4
  float v6; // s2
  CRGBA rgba; // [sp+8h] [bp-20h] BYREF
  CRGBA v8; // [sp+Ch] [bp-1Ch] BYREF
  CRect Rectangle; // [sp+10h] [bp-18h] BYREF

  CSprite2d::InitPerFrame();
  Rectangle.left = 0.0;
  v0 = CLoadingScreen::m_currDisplayedSplash == 0;
  Rectangle.bottom = 0.0;
  Rectangle.right = (float)RsGlobal.screenWidth;
  Rectangle.top = (float)RsGlobal.screenHeight;
  if ( CLoadingScreen::m_currDisplayedSplash )
    v0 = CLoadingScreen::m_aSplashes[1].mpTexture == 0;
  if ( v0 )
  {
    CLoadingScreen::LoadSplashes(0, 0);
    CLoadingScreen::m_currDisplayedSplash = 1;
  }
  CRGBA::CRGBA(&v8, 0, 0, 0, 0xFFu);
  CSprite2d::DrawRect(&Rectangle, &v8);
  if ( CLoadingScreen::m_currDisplayedSplash
    && (v1 = (float)RsGlobal.screenWidth / (float)RsGlobal.screenHeight, v1 >= 1.3333)
    && v1 <= 1.8889 )
  {
    rgba = (CRGBA)-1;
    sscanf(
      (const char *)CLoadingScreen::m_aSplashes[CLoadingScreen::m_currDisplayedSplash].mpTexture->name,
      "mobilesc%d",
      &rgba);
    if ( *(unsigned int *)&rgba > 5 )
      v2 = 0.5;
    else
      v2 = *(float *)&dword_43B1E0[*(_DWORD *)&rgba];
    v5 = fabsf(Rectangle.top - Rectangle.bottom);
    v6 = v5 + (float)((float)(fabsf(Rectangle.right - Rectangle.left) * -3.0) * 0.25);
    Rectangle.bottom = v2 * v6;
    Rectangle.top = v5 + (float)((float)(v2 + -1.0) * v6);
  }
  else
  {
    v3 = fabsf(Rectangle.top - Rectangle.bottom);
    v4 = (float)(v3 + v3) / 3.0;
    Rectangle.left = (float)((float)RsGlobal.screenWidth * 0.5) - v4;
    Rectangle.right = (float)((float)RsGlobal.screenWidth * 0.5) + v4;
  }
  CRGBA::CRGBA(&rgba, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
  RwRenderStateSet(rwRENDERSTATETEXTUREADDRESS, (char *)&dword_0 + 3);
  emu_GammaSet(0);
  if ( !CLoadingScreen::m_bReadyToDelete )
    CSprite2d::Draw(&CLoadingScreen::m_aSplashes[CLoadingScreen::m_currDisplayedSplash], &Rectangle, &rgba);
}
// 0: using guessed type int dword_0;
// 43B1E0: using guessed type int dword_43B1E0[3];

//----- (0043B204) --------------------------------------------------------
void CLoadingScreen::DoPCTitleFadeIn()
{
  unsigned int v0; // r4

  v0 = 0;
  CLoadingScreen::m_currDisplayedSplash = 0;
  CLoadingScreen::m_bFadeInNextSplashFromBlack = 1;
  CLoadingScreen::m_bFading = 1;
  do
  {
    CLoadingScreen::m_FadeAlpha = (unsigned int)(float)((float)v0 * 5.0);
    CLoadingScreen::DisplayPCScreen();
    ++v0;
  }
  while ( v0 != 50 );
  CLoadingScreen::m_FadeAlpha = -1;
  CLoadingScreen::DisplayPCScreen();
  CLoadingScreen::m_bFading = 0;
}

//----- (0043B288) --------------------------------------------------------
void CLoadingScreen::DoPCTitleFadeOut()
{
  int v0; // r4
  unsigned int v1; // r4

  v0 = 200;
  CLoadingScreen::m_currDisplayedSplash = 0;
  CLoadingScreen::m_bFadeInNextSplashFromBlack = 1;
  CLoadingScreen::m_bFading = 1;
  do
  {
    CLoadingScreen::m_FadeAlpha = -1;
    CLoadingScreen::DisplayPCScreen();
    --v0;
  }
  while ( v0 );
  v1 = 50;
  do
  {
    CLoadingScreen::m_FadeAlpha = (unsigned int)(float)((float)v1 * 5.0);
    CLoadingScreen::DisplayPCScreen();
    --v1;
  }
  while ( v1 );
  CLoadingScreen::m_bFadeInNextSplashFromBlack = 1;
}

//----- (0043B31C) --------------------------------------------------------
void __fastcall CLoadingScreen::SetChunksToLoad(int num, bool AddTo)
{
  if ( AddTo )
    num += 140;
  CLoadingScreen::m_nChunksToLoad = num;
}

//----- (0043B330) --------------------------------------------------------
void __fastcall CLoadingScreen::DoPCScreenChange(Bool bLastOne, Bool change)
{
  int32 TxdSlot; // r4

  CLoadingScreen::m_bActive = 1;
  CLoadingScreen::m_bFading = 1;
  CLoadingScreen::m_PercentLoaded = 0.0;
  if ( bLastOne )
  {
    CLoadingScreen::m_bFadeOutCurrSplashToBlack = 1;
    CLoadingScreen::m_nChunksToLoad = 140;
  }
  else
  {
    CLoadingScreen::m_nChunksToLoad = 140;
    CLoadingScreen::m_numChunksLoaded = -1;
    if ( change && CLoadingScreen::m_currDisplayedSplash <= 0 )
      ++CLoadingScreen::m_currDisplayedSplash;
  }
  CLoadingScreen::m_FadeAlpha = -1;
  CLoadingScreen::DisplayPCScreen();
  CLoadingScreen::m_bFading = 0;
  CLoadingScreen::m_bFadeInNextSplashFromBlack = 0;
  if ( bLastOne )
  {
    CLoadingScreen::m_bActive = 0;
    if ( CLoadingScreen::m_aSplashes[0].mpTexture )
      CSprite2d::Delete(CLoadingScreen::m_aSplashes);
    if ( CLoadingScreen::m_aSplashes[1].mpTexture )
      CSprite2d::Delete(&CLoadingScreen::m_aSplashes[1]);
    TxdSlot = CTxdStore::FindTxdSlot("loadscs");
    if ( TxdSlot != -1 )
    {
      CTxdStore::RemoveTxd(TxdSlot);
      sub_197460(TxdSlot);
    }
  }
}

//----- (0043B460) --------------------------------------------------------
void CLoadingScreen::RenderLoadingBar()
{
  int red; // r5
  int green; // r6
  int blue; // r4
  float screenHeight; // s18
  float screenWidth; // s20
  float v5; // s16
  CRGBA c2; // r0
  CRGBA v7; // [sp+1Ch] [bp-54h] BYREF
  unsigned int c; // [sp+20h] [bp-50h] BYREF
  CRGBA v9[19]; // [sp+24h] [bp-4Ch] BYREF

  CHudColours::GetRGBA(v9, &HudColour, 5u);
  red = v9[0]._anon_0._anon_0.red;
  CHudColours::GetRGBA(v9, &HudColour, 5u);
  green = v9[0]._anon_0._anon_0.green;
  CHudColours::GetRGBA(v9, &HudColour, 5u);
  blue = v9[0]._anon_0._anon_0.blue;
  screenHeight = (float)RsGlobal.screenHeight;
  screenWidth = (float)RsGlobal.screenWidth;
  CWidget::DrawTitleSafeArea();
  v5 = CLoadingScreen::m_PercentLoaded;
  if ( CLoadingScreen::m_PercentLoaded <= 100.0
    && !CLoadingScreen::m_bLegalScreen
    && CLoadingScreen::m_PercentLoaded >= 0.0 )
  {
    c = red | (green << 8) | (blue << 16) | 0xFF000000;
    CRGBA::CRGBA(&v7, 0, 0, 0, 0);
    CSprite2d::DrawBarChart(
      (float)(screenWidth * 0.0) + (float)((float)(screenHeight / 448.0) * 10.0),
      (float)(screenHeight - (float)(screenHeight * 0.0)) + (float)((float)(screenHeight / 448.0) * -14.0),
      (int)(float)((float)((float)(screenWidth / 640.0) * 640.0)
                 + (float)((float)((float)(screenWidth * 0.0) + (float)((float)(screenHeight / 448.0) * 10.0)) * -2.0)),
      (int)(float)((float)(screenHeight / 448.0) * 10.0),
      v5,
      0,
      0,
      1,
      (CRGBA)&c,
      c2);
    if ( CLoadingScreen::m_TimeBarAppeared == 0.0 )
      CLoadingScreen::m_TimeBarAppeared = (float)((float)RsTimer() / 1000.0) - CLoadingScreen::m_PauseTime;
  }
}
// 43B57C: variable 'c2' is possibly undefined

//----- (0043B5FC) --------------------------------------------------------
void CLoadingScreen::DisplayNextSplash()
{
  if ( CLoadingScreen::m_currDisplayedSplash != 1 && !CLoadingScreen::m_bFading )
  {
    CLoadingScreen::m_FadeAlpha = -1;
    if ( RwCameraBeginUpdate(Scene.camera) )
    {
      DefinedState2d();
      CLoadingScreen::RenderSplash();
      CLoadingScreen::RenderLoadingBar();
      RwCameraEndUpdate(Scene.camera);
      RsCameraShowRaster(Scene.camera);
    }
    ++CLoadingScreen::m_currDisplayedSplash;
  }
}

//----- (0043B67C) --------------------------------------------------------
void __fastcall CLoadingScreen::DisplayMessage(const unsigned __int8 *pMsg)
{
  sub_19B9DC((char *)CLoadingScreen::m_PopUpMessage, (const char *)pMsg);
}

//----- (0043B68C) --------------------------------------------------------
void __fastcall CLoadingScreen::SetLoadingBarMsg(const unsigned __int8 *pMsg, const unsigned __int8 *pMsg2)
{
  if ( pMsg )
  {
    AsciiToGxtChar(pMsg, CLoadingScreen::m_LoadingGxtMsg1);
    if ( pMsg2 )
    {
LABEL_3:
      sub_196418(pMsg2, CLoadingScreen::m_LoadingGxtMsg2);
      return;
    }
  }
  else
  {
    CLoadingScreen::m_LoadingGxtMsg1[0] = 0;
    if ( pMsg2 )
      goto LABEL_3;
  }
  CLoadingScreen::m_LoadingGxtMsg2[0] = 0;
}

//----- (0043B6DC) --------------------------------------------------------
void CLoadingScreen::Update()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d3
  _BOOL4 v2; // r0
  float v3; // s0
  float v4; // s2
  unsigned int v5; // r1
  bool v6; // zf
  float v7; // s0
  float v8; // s0

  if ( CLoadingScreen::m_TimeBarAppeared > 0.0 )
  {
    v1.n64_u32[0] = 1120403456;
    v0.n64_f32[0] = (float)((float)((float)((float)((float)RsTimer() / 1000.0) - CLoadingScreen::m_PauseTime)
                                  - CLoadingScreen::m_TimeBarAppeared)
                          * 100.0)
                  / (float)(36.0 - (float)(CLoadingScreen::m_TimeBarAppeared - CLoadingScreen::m_TimeStartedLoading));
    LODWORD(CLoadingScreen::m_PercentLoaded) = vmin_f32(v0, v1).n64_u32[0];
  }
  if ( CLoadingScreen::m_bReadyToDelete )
    goto LABEL_4;
  if ( CLoadingScreen::m_bLegalScreen
    && (float)((float)((float)((float)RsTimer() / 1000.0) - CLoadingScreen::m_PauseTime)
             - CLoadingScreen::m_TimeStartedLoading) > 5.5 )
  {
    CLoadingScreen::DisplayNextSplash();
  }
  if ( !CLoadingScreen::m_bSignalDelete )
    goto LABEL_4;
  v2 = CLoadingScreen::m_bFading;
  if ( !CLoadingScreen::m_bFading && CLoadingScreen::m_PercentLoaded >= 100.0 )
  {
    CLoadingScreen::m_bFadeOutCurrSplashToBlack = 1;
    CLoadingScreen::m_bReadyToDelete = 1;
    CLoadingScreen::m_bFading = 1;
    CLoadingScreen::m_FadeAlpha = 0;
    CLoadingScreen::m_StartFadeTime = (float)((float)RsTimer() / 1000.0) - CLoadingScreen::m_PauseTime;
LABEL_4:
    v2 = CLoadingScreen::m_bFading;
  }
  if ( !v2 )
  {
    LOBYTE(v5) = -1;
LABEL_25:
    CLoadingScreen::m_FadeAlpha = v5;
    goto LABEL_26;
  }
  v3 = (float)((float)((float)RsTimer() / 1000.0) - CLoadingScreen::m_PauseTime) - CLoadingScreen::m_StartFadeTime;
  if ( CLoadingScreen::m_currDisplayedSplash < 0 )
  {
    v4 = 2.0;
  }
  else
  {
    v4 = 0.6;
    if ( !((CLoadingScreen::m_bLegalScreen || CLoadingScreen::m_bFadeInNextSplashFromBlack) << 24) )
      v4 = 2.0;
  }
  if ( v3 <= v4 )
  {
    v5 = (unsigned int)(float)((float)(v3 / v4) * 255.0);
    goto LABEL_25;
  }
  CLoadingScreen::m_FadeAlpha = -1;
  v6 = !CLoadingScreen::m_bLegalScreen;
  CLoadingScreen::m_bFading = 0;
  if ( CLoadingScreen::m_bLegalScreen )
    v6 = !CLoadingScreen::m_bFadeOutCurrSplashToBlack;
  if ( v6 )
  {
    CLoadingScreen::m_bFadeOutCurrSplashToBlack = 0;
    CLoadingScreen::m_bFadeInNextSplashFromBlack = 0;
  }
  else
  {
    CLoadingScreen::m_bFadeInNextSplashFromBlack = 1;
    CLoadingScreen::m_bFadeOutCurrSplashToBlack = 0;
    CLoadingScreen::m_bLegalScreen = 0;
    CLoadingScreen::DisplayNextSplash();
  }
LABEL_26:
  if ( CLoadingScreen::m_bLegalScreen )
    return;
  if ( CLoadingScreen::m_bFadeInNextSplashFromBlack )
  {
    v7 = (float)CLoadingScreen::m_FadeAlpha;
  }
  else
  {
    if ( !CLoadingScreen::m_bFadeOutCurrSplashToBlack )
    {
      v8 = 1.0;
      goto LABEL_32;
    }
    v7 = 255.0 - (float)CLoadingScreen::m_FadeAlpha;
  }
  v8 = v7 / 255.0;
LABEL_32:
  sub_18BB4C(&AudioEngine, v8);
}
// 43B74C: variable 'v0' is possibly undefined
// 43B74C: variable 'v1' is possibly undefined

//----- (0043BA60) --------------------------------------------------------
void CLoadingScreen::StartFading()
{
  CLoadingScreen::m_FadeAlpha = 0;
  CLoadingScreen::m_bFading = 1;
  CLoadingScreen::m_StartFadeTime = (float)((float)RsTimer() / 1000.0) - CLoadingScreen::m_PauseTime;
}

//----- (0043BAC0) --------------------------------------------------------
void CMenuSystem::Initialise()
{
  int v0; // r1
  char v1; // r2
  bool v2; // zf
  int8 v3; // r1
  int v4; // r0
  char v5; // r2
  int8 v6; // r1

  if ( CMenuSystem::MenuInUse[0] )
  {
    if ( MenuNumber[0] )
      operator delete(MenuNumber[0]);
    CMenuSystem::MenuInUse[0] = 0;
    --CMenuSystem::num_menus_in_use;
    v0 = 1;
    do
    {
      v1 = v0 + 1;
      if ( v0 > 1 )
        break;
      v2 = CMenuSystem::MenuInUse[v0++] == 0;
    }
    while ( v2 );
    v3 = v1 - 1;
    if ( (unsigned __int8)(v1 - 1) == 2 )
      v3 = 0;
    CMenuSystem::CurrentMenuInUse = v3;
  }
  if ( CMenuSystem::MenuInUse[1] )
  {
    if ( MenuNumber[1] )
      operator delete(MenuNumber[1]);
    v4 = 0;
    CMenuSystem::MenuInUse[1] = 0;
    --CMenuSystem::num_menus_in_use;
    do
    {
      v5 = v4 + 1;
      if ( v4 > 1 )
        break;
      v2 = CMenuSystem::MenuInUse[v4++] == 0;
    }
    while ( v2 );
    v6 = v5 - 1;
    if ( (unsigned __int8)(v5 - 1) == 2 )
      v6 = 0;
    CMenuSystem::CurrentMenuInUse = v6;
  }
  CMenuSystem::CurrentMenuInUse = 0;
}

//----- (0043BBB4) --------------------------------------------------------
void __fastcall CMenuSystem::SwitchOffMenu(uint8 id)
{
  int v1; // r4
  CSelectableMenu *v2; // r0
  int8 v3; // r2
  int8 v4; // r0

  v1 = id;
  if ( CMenuSystem::MenuInUse[id] )
  {
    v2 = MenuNumber[id];
    if ( v2 )
      operator delete(v2);
    --CMenuSystem::num_menus_in_use;
    v3 = 0;
    CMenuSystem::MenuInUse[v1] = 0;
    do
    {
      v4 = v3;
      if ( v3 > 1 )
        break;
    }
    while ( !CMenuSystem::MenuInUse[v3++] );
    if ( v4 == 2 )
      v4 = 0;
    CMenuSystem::CurrentMenuInUse = v4;
  }
}

//----- (0043BC30) --------------------------------------------------------
int __fastcall CMenuSystem::CreateNewMenu(
        int type,
        unsigned __int8 *Header,
        float x,
        float y,
        float column_size,
        unsigned int num_columns,
        bool8 input,
        int border,
        uint8 orientation)
{
  int v13; // r4
  CSelectableMenu *v14; // r0
  uint8 v15; // r2
  unsigned __int8 *MainHeader; // r0
  int v17; // r0
  int v18; // r9
  int v19; // r2
  int v20; // r3
  float *v21; // r1

  v13 = CMenuSystem::num_menus_in_use;
  v14 = (CSelectableMenu *)operator new(0x418u);
  v15 = num_columns;
  MenuNumber[v13] = v14;
  CMenuSystem::MenuInUse[v13] = 1;
  v14->type = type;
  if ( type == 1 )
  {
    v14->ColumnSize[0] = column_size;
    MenuNumber[v13]->border = border != 0;
    MenuNumber[v13]->InputEnabled = input;
    MenuNumber[v13]->UseDPad = 1;
    if ( num_columns >= 8 )
      v15 = 8;
    MenuNumber[v13]->TotalColumnsInThisMenu = v15;
    MenuNumber[v13]->x_pos = x;
    MenuNumber[v13]->y_pos = y;
    MenuNumber[v13]->CurrentOptionInUse = -99;
    MenuNumber[v13]->CurrentSelectedItem = 0;
    MenuNumber[v13]->TotalItemsInThisMenu = MenuNumber[v13]->TotalColumnsInThisMenu
                                          * MenuNumber[v13]->TotalColumnsInThisMenu;
    CMenuSystem::FillGridWithCarColours(v13);
  }
  else if ( !type )
  {
    v14->TotalItemsInThisMenu = 0;
    if ( num_columns >= 4 )
      v15 = 4;
    MenuNumber[v13]->TotalColumnsInThisMenu = v15;
    MenuNumber[v13]->CurrentSelectedItem = 0;
    MenuNumber[v13]->InputEnabled = input;
    MenuNumber[v13]->UseDPad = 1;
    MenuNumber[v13]->x_pos = x;
    MenuNumber[v13]->y_pos = y;
    MenuNumber[v13]->border = border != 0;
    MainHeader = MenuNumber[v13]->MainHeader;
    if ( Header )
      strcpy((char *)MainHeader, (const char *)Header);
    else
      *MainHeader = 0;
    MenuNumber[v13]->CurrentOptionInUse = -99;
    CMenuSystem::ActivateItems(v13, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u);
    v17 = 175;
    v18 = 932;
    v19 = 1010;
    v20 = 1020;
    do
    {
      v21 = (float *)&MenuNumber[v13]->CarColsNum[v20];
      v20 += 4;
      *v21 = column_size;
      MenuNumber[v13]->CarColsNum[v19 - 4] = orientation;
      MenuNumber[v13]->CarColsNum[v19++] = -1;
      MenuNumber[v13]->CarColsNum[v18] = 0;
      v18 += 10;
      MenuNumber[v13]->CarColsNum[v17 - 110] = 0;
      MenuNumber[v13]->ItemHighlight[0] = 0;
      MenuNumber[v13]->CarColsNum[v17 - 100] = 0;
      MenuNumber[v13]->ItemHighlight[1] = 0;
      MenuNumber[v13]->CarColsNum[v17 - 90] = 0;
      MenuNumber[v13]->ItemHighlight[2] = 0;
      MenuNumber[v13]->CarColsNum[v17 - 80] = 0;
      MenuNumber[v13]->ItemHighlight[3] = 0;
      MenuNumber[v13]->CarColsNum[v17 - 70] = 0;
      MenuNumber[v13]->ItemHighlight[4] = 0;
      MenuNumber[v13]->CarColsNum[v17 - 60] = 0;
      MenuNumber[v13]->ItemHighlight[5] = 0;
      MenuNumber[v13]->CarColsNum[v17 - 50] = 0;
      MenuNumber[v13]->ItemHighlight[6] = 0;
      MenuNumber[v13]->CarColsNum[v17 - 40] = 0;
      MenuNumber[v13]->ItemHighlight[7] = 0;
      MenuNumber[v13]->CarColsNum[v17 - 30] = 0;
      MenuNumber[v13]->ItemHighlight[8] = 0;
      MenuNumber[v13]->CarColsNum[v17 - 20] = 0;
      MenuNumber[v13]->ItemHighlight[9] = 0;
      MenuNumber[v13]->CarColsNum[v17 - 10] = 0;
      MenuNumber[v13]->ItemHighlight[10] = 0;
      MenuNumber[v13]->CarColsNum[v17] = 0;
      v17 += 120;
      MenuNumber[v13]->ItemHighlight[11] = 0;
    }
    while ( v17 != 655 );
  }
  ++CMenuSystem::num_menus_in_use;
  return v13;
}

//----- (0043BF0C) --------------------------------------------------------
void __fastcall CMenuSystem::ActivateItems(
        int id,
        bool8 active1,
        bool8 active2,
        bool8 active3,
        bool8 active4,
        bool8 active5,
        bool8 active6,
        bool8 active7,
        bool8 active8,
        bool8 active9,
        bool8 active10,
        bool8 active11,
        bool8 active12)
{
  CSelectableMenu *v13; // r1
  int CurrentSelectedItem; // r2
  int8 v15; // r12
  int TotalItemsInThisMenu; // r3
  int v17; // r2

  MenuNumber[id]->ItemActive[0] = active1;
  MenuNumber[id]->ItemActive[1] = active2;
  MenuNumber[id]->ItemActive[2] = active3;
  MenuNumber[id]->ItemActive[3] = active4;
  MenuNumber[id]->ItemActive[4] = active5;
  MenuNumber[id]->ItemActive[5] = active6;
  MenuNumber[id]->ItemActive[6] = active7;
  MenuNumber[id]->ItemActive[7] = active8;
  MenuNumber[id]->ItemActive[8] = active9;
  MenuNumber[id]->ItemActive[9] = active10;
  MenuNumber[id]->ItemActive[10] = active11;
  MenuNumber[id]->ItemActive[11] = active12;
  while ( 1 )
  {
    v13 = MenuNumber[id];
    CurrentSelectedItem = v13->CurrentSelectedItem;
    v15 = v13->CurrentSelectedItem;
    if ( v13->ItemActive[CurrentSelectedItem] )
    {
      if ( v13->Item[0][CurrentSelectedItem][0] )
        break;
    }
    if ( CurrentSelectedItem >= v13->TotalItemsInThisMenu )
      goto LABEL_8;
    v13->CurrentSelectedItem = v15 + 1;
  }
  TotalItemsInThisMenu = v13->TotalItemsInThisMenu;
  if ( CurrentSelectedItem < TotalItemsInThisMenu )
    goto LABEL_15;
LABEL_8:
  for ( v13->CurrentSelectedItem = 0; ; v13->CurrentSelectedItem = v15 + 1 )
  {
    v13 = MenuNumber[id];
    v17 = v13->CurrentSelectedItem;
    v15 = v13->CurrentSelectedItem;
    if ( v13->ItemActive[v17] )
    {
      if ( v13->Item[0][v17][0] )
        break;
    }
    TotalItemsInThisMenu = v13->TotalItemsInThisMenu;
    if ( v17 >= TotalItemsInThisMenu )
      goto LABEL_15;
  }
  TotalItemsInThisMenu = v13->TotalItemsInThisMenu;
LABEL_15:
  if ( v15 >= TotalItemsInThisMenu )
    v13->CurrentSelectedItem = 0;
}

//----- (0043C03C) --------------------------------------------------------
void __fastcall CMenuSystem::FillGridWithCarColours(uint8 id)
{
  CRGBA *v1; // r0
  int i; // r4
  CRGBA *v3; // r2
  int v4; // r2
  int v5; // r4
  CRGBA *v6; // r0
  int v7; // r1
  int v8; // r2
  RwUInt8 green; // lr
  int v10; // r5
  RwUInt8 blue; // r12
  int v12; // r9
  int v13; // r1
  unsigned __int8 *v14; // r11
  int v15; // r2
  int v16; // r3
  unsigned int v17; // r1
  int v18; // r6
  RwUInt8 alpha; // r2
  int v20; // [sp+8h] [bp-130h]
  int v21; // [sp+10h] [bp-128h]
  uint8 v22; // [sp+14h] [bp-124h]
  CRGBA v23; // [sp+18h] [bp-120h] BYREF
  unsigned __int8 v24[284]; // [sp+1Ch] [bp-11Ch] BYREF

  v20 = id;
  v1 = &v23;
  for ( i = 0; i != 64; ++i )
  {
    CRGBA::CRGBA(v1, 0, 0, 0, 0xFFu);
    v3 = (CRGBA *)&v24[4 * i];
    *v3 = v23;
  }
  v4 = 0;
  v5 = 0;
  v6 = &v23;
  LOBYTE(v7) = 0;
  do
  {
    v21 = v4;
    v22 = v7;
    CRGBA::CRGBA(
      v6,
      CVehicleModelInfo::ms_vehicleColourTable[(unsigned __int8)v7]._anon_0._anon_0.red,
      CVehicleModelInfo::ms_vehicleColourTable[(unsigned __int8)v7]._anon_0._anon_0.green,
      CVehicleModelInfo::ms_vehicleColourTable[(unsigned __int8)v7]._anon_0._anon_0.blue,
      0xFFu);
    v8 = 0;
    green = v23._anon_0._anon_0.green;
    v10 = 0;
    blue = v23._anon_0._anon_0.blue;
    v12 = 0;
    do
    {
      if ( v5 << 24 )
      {
        v13 = v24[4 * v8];
        if ( v13 - 15 < v23._anon_0._anon_0.red )
        {
          v14 = &v24[4 * v8];
          v15 = v14[1];
          if ( v15 - 15 < v23._anon_0._anon_0.green )
          {
            v16 = v14[2];
            v17 = v13 + 15;
            v18 = v12;
            if ( v16 - 15 < v23._anon_0._anon_0.blue )
              v18 = 1;
            if ( v17 <= v23._anon_0._anon_0.red )
              v18 = v12;
            if ( v15 + 15 <= (unsigned int)v23._anon_0._anon_0.green )
              v18 = v12;
            if ( v16 + 15 > (unsigned int)v23._anon_0._anon_0.blue )
              v12 = v18;
          }
        }
      }
      v8 = (unsigned __int8)++v10;
    }
    while ( (unsigned __int8)v10 <= (unsigned int)(unsigned __int8)v5 );
    if ( !(v12 << 24) || (v7 = (char)(v22 + 1), v7 <= -1) )
    {
      ++v5;
      alpha = v23._anon_0._anon_0.alpha;
      v7 = (int)&v24[4 * v21];
      *(_BYTE *)v7 = v23._anon_0._anon_0.red;
      *(_BYTE *)(v7 + 1) = green;
      *(_BYTE *)(v7 + 2) = blue;
      *(_BYTE *)(v7 + 3) = alpha;
      MenuNumber[v20]->CarColsNum[v21] = v22;
      LOBYTE(v7) = 0;
    }
    v4 = (unsigned __int8)v5;
  }
  while ( (unsigned __int8)v5 < 0x40u );
}
// 43C05A: variable 'v1' is possibly undefined
// 43C0B2: variable 'v6' is possibly undefined
// 43C03C: using guessed type unsigned __int8 var_11C[284];

//----- (0043C170) --------------------------------------------------------
void __fastcall CMenuSystem::Process(int8 menu_num)
{
  int v1; // r5
  int v2; // r0
  uint8 v3; // r0

  v1 = menu_num;
  if ( menu_num == -99 )
  {
    v2 = (unsigned __int8)CMenuSystem::CurrentMenuInUse;
    if ( !CMenuSystem::CurrentMenuInUse )
      goto LABEL_21;
    if ( CMenuSystem::MenuInUse[0] )
    {
      if ( MenuNumber[0]->type == 1 )
      {
        CMenuSystem::DisplayGridMenu(0, 0);
      }
      else if ( !MenuNumber[0]->type )
      {
        CMenuSystem::DisplayStandardMenu(0, 0);
      }
      v2 = (unsigned __int8)CMenuSystem::CurrentMenuInUse;
    }
    if ( v2 != 1 )
    {
LABEL_21:
      if ( CMenuSystem::MenuInUse[1] )
      {
        if ( MenuNumber[1]->type )
        {
          if ( MenuNumber[1]->type == 1 )
            CMenuSystem::DisplayGridMenu(1u, 0);
        }
        else
        {
          CMenuSystem::DisplayStandardMenu(1u, 0);
        }
      }
    }
    if ( CMenuSystem::MenuInUse[CMenuSystem::CurrentMenuInUse] )
    {
      if ( MenuNumber[(unsigned __int8)CMenuSystem::CurrentMenuInUse]->type == 1 )
      {
        CMenuSystem::DisplayGridMenu(CMenuSystem::CurrentMenuInUse, 1u);
      }
      else if ( !MenuNumber[(unsigned __int8)CMenuSystem::CurrentMenuInUse]->type )
      {
        CMenuSystem::DisplayStandardMenu(CMenuSystem::CurrentMenuInUse, 1u);
      }
      v3 = CMenuSystem::CurrentMenuInUse;
      if ( MenuNumber[CMenuSystem::CurrentMenuInUse]->InputEnabled )
      {
        if ( MenuNumber[(unsigned __int8)CMenuSystem::CurrentMenuInUse]->type != 1 )
        {
          if ( MenuNumber[(unsigned __int8)CMenuSystem::CurrentMenuInUse]->type )
            return;
LABEL_17:
          CMenuSystem::InputStandardMenu(v3);
          return;
        }
        goto LABEL_36;
      }
    }
  }
  else if ( CMenuSystem::MenuInUse[menu_num] )
  {
    if ( MenuNumber[(unsigned __int8)menu_num]->type == 1 )
    {
      CMenuSystem::DisplayGridMenu(menu_num, 1u);
    }
    else if ( !MenuNumber[(unsigned __int8)menu_num]->type )
    {
      CMenuSystem::DisplayStandardMenu(menu_num, 1u);
    }
    if ( MenuNumber[v1]->InputEnabled )
    {
      if ( MenuNumber[(unsigned __int8)v1]->type != 1 )
      {
        if ( MenuNumber[(unsigned __int8)v1]->type )
          return;
        v3 = v1;
        goto LABEL_17;
      }
      v3 = v1;
LABEL_36:
      CMenuSystem::InputGridMenu(v3);
    }
  }
}
// 0: using guessed type int dword_0;

//----- (0043C324) --------------------------------------------------------
void __fastcall CMenuSystem::Display(uint8 id, bool8 selected)
{
  if ( MenuNumber[id]->type == 1 )
  {
    CMenuSystem::DisplayGridMenu(id, selected);
  }
  else if ( !MenuNumber[id]->type )
  {
    CMenuSystem::DisplayStandardMenu(id, selected);
  }
}

//----- (0043C348) --------------------------------------------------------
void __fastcall CMenuSystem::Input(uint8 id)
{
  if ( MenuNumber[id]->type == 1 )
  {
    CMenuSystem::InputGridMenu(id);
  }
  else if ( !MenuNumber[id]->type )
  {
    CMenuSystem::InputStandardMenu(id);
  }
}

//----- (0043C368) --------------------------------------------------------
int8 __fastcall CMenuSystem::CheckForAccept(uint8 id)
{
  if ( CMenuSystem::MenuInUse[id] )
    return MenuNumber[id]->CurrentOptionInUse;
  else
    return -99;
}

//----- (0043C394) --------------------------------------------------------
int8 __fastcall CMenuSystem::CheckForSelected(uint8 id)
{
  if ( CMenuSystem::MenuInUse[id] )
    return MenuNumber[id]->CurrentSelectedItem;
  else
    return -99;
}

//----- (0043C3C0) --------------------------------------------------------
void __fastcall CMenuSystem::InputStandardMenu(uint8 id)
{
  int v1; // r5
  int8 i; // r0
  int v3; // r1
  CPad *Pad; // r0
  CPad *v5; // r0
  CSelectableMenu *v6; // r0
  int CurrentSelectedItem; // r1
  CSelectableMenu *v8; // r0
  float v9; // s0
  CSelectableMenu *v10; // r0
  int v11; // r2
  float v12; // s0
  CSelectableMenu *v13; // r0
  int8 v14; // r3
  int v15; // r2
  CSelectableMenu *v16; // r0
  int v17; // r1
  CSelectableMenu *v18; // r1
  int v19; // r2

  v1 = id;
  i = CMenuSystem::CurrentMenuInUse;
  if ( CMenuSystem::CurrentMenuInUse > -1 )
    goto LABEL_4;
  for ( i = 1; ; --i )
  {
    CMenuSystem::CurrentMenuInUse = i;
LABEL_4:
    v3 = CMenuSystem::MenuInUse[i];
    if ( i < 1 || CMenuSystem::MenuInUse[i] )
      break;
  }
  if ( i < 2 )
    goto LABEL_10;
  for ( i = 0; ; ++i )
  {
    CMenuSystem::CurrentMenuInUse = i;
    v3 = CMenuSystem::MenuInUse[i];
LABEL_10:
    if ( i > 1 || v3 )
      break;
  }
  Pad = CPad::GetPad(0);
  if ( Pad->NewState.ButtonTriangle
    && !Pad->OldState.ButtonTriangle
    && !((CTimer::m_UserPause || CTimer::m_CodePause) << 24) )
  {
    CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 2, 0.0, 1.0);
  }
  v5 = CPad::GetPad(0);
  if ( v5->NewState.ButtonCross && !v5->OldState.ButtonCross
    || (CTimer::m_UserPause || CTimer::m_CodePause) << 24 && LIB_KeyboardPressed(KK_ENTER) )
  {
    if ( !((CTimer::m_UserPause || CTimer::m_CodePause) << 24) )
      CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 1, 0.0, 1.0);
    v6 = MenuNumber[v1];
    CurrentSelectedItem = v6->CurrentSelectedItem;
    if ( v6->ItemActive[CurrentSelectedItem] )
      v6->CurrentOptionInUse = CurrentSelectedItem;
  }
  v8 = MenuNumber[v1];
  if ( v8->CurrentOptionInUse != v8->CurrentSelectedItem )
  {
    v8->CurrentOptionInUse = -99;
    v8 = MenuNumber[v1];
  }
  if ( v8->TotalItemsInThisMenu >= 2u )
  {
    if ( OS_TimeAccurate() - m_fLastAnalogTime > 0.150000006 )
    {
      if ( CHID::IsPressedNegative(HID_MAPPING_PED_MOVE_Y)
        || MenuNumber[v1]->UseDPad && CHID::IsPressed(HID_MAPPING_MENU_UP, 0) )
      {
        v9 = OS_TimeAccurate();
        m_fLastAnalogTime = v9;
        CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 3, 0.0, 1.0);
        v10 = MenuNumber[v1];
        LOBYTE(v11) = v10->CurrentSelectedItem;
        do
        {
          v10->CurrentSelectedItem = v11 - 1;
          v10 = MenuNumber[v1];
          v11 = v10->CurrentSelectedItem;
        }
        while ( (!v10->ItemActive[v11] || !v10->Item[0][v11][0]) && v11 > -1 );
      }
      if ( CHID::IsPressedPositive(HID_MAPPING_PED_MOVE_Y)
        || MenuNumber[v1]->UseDPad && CHID::IsPressed(HID_MAPPING_MENU_DOWN, 0) )
      {
        v12 = OS_TimeAccurate();
        m_fLastAnalogTime = v12;
        CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 3, 0.0, 1.0);
        v13 = MenuNumber[v1];
        v14 = v13->CurrentSelectedItem;
        do
        {
          v13->CurrentSelectedItem = v14 + 1;
          v13 = MenuNumber[v1];
          v15 = v13->CurrentSelectedItem;
          if ( v13->ItemActive[v15] && v13->Item[0][v15][0] )
            break;
          v14 = v13->CurrentSelectedItem;
        }
        while ( v15 < v13->TotalItemsInThisMenu );
      }
    }
    v16 = MenuNumber[v1];
    v17 = v16->CurrentSelectedItem;
    if ( v17 <= -1 )
    {
      for ( v16->CurrentSelectedItem = v16->TotalItemsInThisMenu - 1; ; v16->CurrentSelectedItem = v17 - 1 )
      {
        v16 = MenuNumber[v1];
        v17 = v16->CurrentSelectedItem;
        if ( v16->ItemActive[v17] )
        {
          if ( v16->Item[0][v17][0] || v17 <= -1 )
            break;
        }
        else if ( v17 < 0 )
        {
          break;
        }
      }
    }
    if ( v17 >= v16->TotalItemsInThisMenu )
    {
      v16->CurrentSelectedItem = 0;
      while ( 1 )
      {
        v18 = MenuNumber[v1];
        v19 = v18->CurrentSelectedItem;
        if ( v18->ItemActive[v19] )
        {
          if ( v18->Item[0][v19][0] )
            break;
        }
        if ( v19 >= v18->TotalItemsInThisMenu )
          break;
        v18->CurrentSelectedItem = v19 + 1;
      }
    }
  }
}

//----- (0043C758) --------------------------------------------------------
void __fastcall CMenuSystem::InputGridMenu(uint8 id)
{
  int v1; // r4
  CPad *Pad; // r0
  CSelectableMenu *v3; // r0
  int CurrentSelectedItem; // r1
  CSelectableMenu *v5; // r0
  float v6; // s0
  CSelectableMenu *v7; // r0
  int TotalColumnsInThisMenu; // r1
  int v9; // r2
  float v10; // s0
  CSelectableMenu *v11; // r0
  int v12; // r1
  int v13; // r2
  float v14; // s0
  CSelectableMenu *v15; // r0
  int v16; // r1
  float v17; // s0
  CSelectableMenu *v18; // r0
  int v19; // r1

  v1 = id;
  Pad = CPad::GetPad(0);
  if ( Pad->NewState.ButtonCross && !Pad->OldState.ButtonCross
    || (CTimer::m_UserPause || CTimer::m_CodePause) << 24 && LIB_KeyboardPressed(KK_ENTER) )
  {
    v3 = MenuNumber[v1];
    CurrentSelectedItem = v3->CurrentSelectedItem;
    if ( v3->ItemActive[CurrentSelectedItem] )
      v3->CurrentOptionInUse = CurrentSelectedItem;
  }
  v5 = MenuNumber[v1];
  if ( v5->CurrentOptionInUse != v5->CurrentSelectedItem )
    v5->CurrentOptionInUse = -99;
  if ( OS_TimeAccurate() - m_fLastAnalogTime > 0.150000006 )
  {
    if ( CHID::IsPressedNegative(HID_MAPPING_PED_MOVE_Y)
      || MenuNumber[v1]->UseDPad && CHID::IsPressed(HID_MAPPING_MENU_UP, 0) )
    {
      v6 = OS_TimeAccurate();
      v7 = MenuNumber[v1];
      m_fLastAnalogTime = v6;
      TotalColumnsInThisMenu = v7->TotalColumnsInThisMenu;
      v9 = v7->CurrentSelectedItem;
      if ( v9 >= TotalColumnsInThisMenu )
        v7->CurrentSelectedItem = v9 - TotalColumnsInThisMenu;
    }
    if ( CHID::IsPressedPositive(HID_MAPPING_PED_MOVE_Y)
      || MenuNumber[v1]->UseDPad && CHID::IsPressed(HID_MAPPING_MENU_DOWN, 0) )
    {
      v10 = OS_TimeAccurate();
      v11 = MenuNumber[v1];
      m_fLastAnalogTime = v10;
      v12 = v11->TotalColumnsInThisMenu;
      v13 = v11->CurrentSelectedItem;
      if ( v11->TotalItemsInThisMenu - v12 > v13 )
        v11->CurrentSelectedItem = v12 + v13;
    }
    if ( CHID::IsPressedNegative(HID_MAPPING_PED_MOVE_X)
      || MenuNumber[v1]->UseDPad && CHID::IsPressed(HID_MAPPING_MENU_LEFT, 0) )
    {
      v14 = OS_TimeAccurate();
      v15 = MenuNumber[v1];
      m_fLastAnalogTime = v14;
      v16 = v15->CurrentSelectedItem;
      if ( v16 >= 1 )
        v15->CurrentSelectedItem = v16 - 1;
    }
    if ( CHID::IsPressedPositive(HID_MAPPING_PED_MOVE_X)
      || MenuNumber[v1]->UseDPad && CHID::IsPressed(HID_MAPPING_MENU_RIGHT, 0) )
    {
      v17 = OS_TimeAccurate();
      v18 = MenuNumber[v1];
      m_fLastAnalogTime = v17;
      v19 = v18->CurrentSelectedItem;
      if ( v18->TotalItemsInThisMenu - 1 > v19 )
        v18->CurrentSelectedItem = v19 + 1;
    }
  }
}

//----- (0043C99C) --------------------------------------------------------
void __fastcall CMenuSystem::DisplayStandardMenu(uint8 id, bool8 selected)
{
  int v2; // r4
  uint8 v3; // r11
  CSelectableMenu *v4; // r9
  float v5; // s0
  unsigned int v6; // r10
  unsigned int TotalColumnsInThisMenu; // lr
  unsigned __int8 v8; // r0
  unsigned int v9; // r1
  float *v10; // r5
  unsigned __int8 *v11; // r6
  unsigned int v12; // r2
  float v13; // s4
  int v14; // t1
  bool v15; // zf
  float v16; // s4
  float y_pos; // s6
  CRGBA v18; // r0
  CRGBA v19; // r0
  CSelectableMenu *v20; // r0
  int v21; // r9
  int v22; // r8
  uint8 *v23; // r1
  int v24; // r0
  int v25; // r6
  CRGBA v26; // r0
  int v27; // r1
  float *ColumnSize; // r2
  unsigned int v29; // r0
  float v30; // s2
  CSelectableMenu *v31; // r1
  float v32; // s26
  float v33; // s0
  float v34; // s6
  const unsigned __int8 *v35; // r1
  float v36; // s28
  CSelectableMenu *v37; // r1
  float v38; // s4
  float v39; // s0
  float v40; // s6
  float v41; // s0
  GxtChar *v42; // r0
  unsigned int v43; // r2
  unsigned int v44; // r3
  char v45; // r6
  float v46; // s30
  int v47; // r11
  int v48; // r8
  int v49; // r5
  CRGBA v50; // r0
  uint8 *v51; // r0
  uint8 *v52; // r0
  CRGBA v53; // r0
  int v54; // r1
  const unsigned __int8 *v55; // r1
  int v56; // t1
  GxtChar *v57; // r0
  char *v58; // r2
  float StringWidth; // r0
  CSelectableMenu *v60; // r1
  float v61; // s0
  float v62; // s17
  float v63; // r0
  float *v64; // r3
  int v65; // r2
  unsigned int v66; // r0
  float v67; // s4
  unsigned int v68; // s6
  float v69; // s0
  float v70; // r1
  char v71; // [sp+28h] [bp-3E8h]
  int v72; // [sp+54h] [bp-3BCh]
  uint8 v73; // [sp+58h] [bp-3B8h]
  unsigned int v74; // [sp+60h] [bp-3B0h]
  CRect Rectangle; // [sp+64h] [bp-3ACh] BYREF
  CRGBA v76; // [sp+384h] [bp-8Ch] BYREF
  CRGBA v77; // [sp+388h] [bp-88h] BYREF
  CRGBA v78; // [sp+38Ch] [bp-84h] BYREF
  CRGBA v79; // [sp+390h] [bp-80h] BYREF
  CRGBA v80; // [sp+394h] [bp-7Ch] BYREF
  CRGBA v81; // [sp+398h] [bp-78h] BYREF
  CRGBA v82; // [sp+39Ch] [bp-74h] BYREF
  CRGBA v83; // [sp+3A0h] [bp-70h] BYREF
  CRGBA v84; // [sp+3A4h] [bp-6Ch] BYREF
  CRGBA v85; // [sp+3A8h] [bp-68h] BYREF

  v2 = id;
  v3 = 0;
  v4 = MenuNumber[id];
  v5 = (float)RsGlobal.screenHeight / 448.0;
  if ( !selected )
    v3 = 120;
  v6 = (unsigned int)(float)(v5 * 20.0);
  if ( v4->border )
  {
    TotalColumnsInThisMenu = v4->TotalColumnsInThisMenu;
    if ( v4->TotalColumnsInThisMenu )
    {
      v8 = 70;
      if ( v4->ColumnHeader[0][0] )
        v6 = (unsigned int)(float)(v5 * 40.0);
      if ( !v4->ColumnHeader[0][0] )
        v8 = 50;
      v9 = (unsigned int)(float)(v4->ColumnSize[0] + 0.0);
      if ( TotalColumnsInThisMenu != 1 )
      {
        v10 = &v4->ColumnSize[1];
        v11 = v4->ColumnHeader[1];
        v12 = 1;
        do
        {
          ++v12;
          v13 = *v10;
          v14 = *v11;
          v11 += 10;
          ++v10;
          v15 = v14 == 0;
          if ( v14 )
            v8 = 70;
          if ( !v15 )
            v6 = (unsigned int)(float)(v5 * 40.0);
          v9 = (unsigned int)(float)(v13 + (float)(unsigned __int16)v9);
        }
        while ( v12 < TotalColumnsInThisMenu );
      }
    }
    else
    {
      v8 = 50;
      v9 = 0;
    }
    v16 = (float)(v5 * 16.0) * (float)v4->TotalItemsInThisMenu;
    y_pos = v4->y_pos;
    Rectangle.left = v4->x_pos;
    Rectangle.bottom = y_pos;
    Rectangle.top = (float)(v5 * (float)v8) + (float)(y_pos + v16);
    Rectangle.right = (float)(Rectangle.left + (float)((float)((float)RsGlobal.screenWidth / 640.0) * 20.0)) + (float)v9;
    CRGBA::CRGBA(&v85, 0, 0, 0, 0xBEu);
    CMenuManager::DrawWindow(&FrontEndMenuManager, &Rectangle, v4->MainHeader, v3, v18, 0, 1);
  }
  CFont::SetFontStyle(1u);
  CFont::SetScale((float)RsGlobal.screenHeight / 448.0);
  CFont::SetDropShadowPosition(2);
  CRGBA::CRGBA(&v84, 0, 0, 0, 0xFFu);
  CFont::SetDropColor(v19);
  CFont::SetOrientation(0);
  v20 = MenuNumber[v2];
  if ( v20->TotalColumnsInThisMenu )
  {
    v21 = 0;
    v22 = 0;
    while ( !v20->ColumnHeader[v22][0] )
    {
LABEL_34:
      v20 = MenuNumber[v2];
      v22 = (unsigned __int8)++v21;
      if ( (unsigned __int8)v21 >= (unsigned int)v20->TotalColumnsInThisMenu )
        goto LABEL_35;
    }
    v23 = &v20->CarColsNum[v22];
    v24 = v20->HeaderOrientation[v22];
    if ( v24 <= -1 )
      LOBYTE(v24) = v23[1006];
    v25 = (unsigned __int8)v24;
    CFont::SetOrientation(v24);
    CRGBA::CRGBA(&v83, -31 - v3, -31 - v3, -31 - v3, 0xFFu);
    CFont::SetColor(v26);
    if ( v21 << 24 )
    {
      v27 = (unsigned __int8)v21;
      ColumnSize = MenuNumber[v2]->ColumnSize;
      LOWORD(v29) = 0;
      do
      {
        --v27;
        v30 = *ColumnSize++;
        v29 = (unsigned int)(float)(v30 + (float)(unsigned __int16)v29);
      }
      while ( v27 );
      if ( v25 )
        goto LABEL_28;
    }
    else
    {
      v29 = 0;
      if ( v25 )
      {
LABEL_28:
        v31 = MenuNumber[v2];
        if ( v25 == 2 )
        {
          v32 = v31->y_pos + (float)((float)((float)RsGlobal.screenHeight / 448.0) * 20.0);
          v33 = (float)(v31->x_pos + (float)((float)((float)RsGlobal.screenWidth / 640.0) * 10.0)) + (float)v29;
          v34 = v31->ColumnSize[v22];
          v35 = v31->ColumnHeader[v22];
          v36 = v34 + v33;
        }
        else
        {
          v41 = v31->x_pos + (float)((float)((float)RsGlobal.screenWidth / 640.0) * 10.0);
          v32 = v31->y_pos + (float)((float)((float)RsGlobal.screenHeight / 448.0) * 20.0);
          v35 = v31->ColumnHeader[v22];
          v36 = v41 + (float)v29;
        }
        goto LABEL_33;
      }
    }
    v37 = MenuNumber[v2];
    v38 = v37->ColumnSize[v22] * 0.5;
    v39 = (float)(v37->x_pos + (float)((float)((float)RsGlobal.screenWidth / 640.0) * 10.0)) + (float)v29;
    v40 = v37->y_pos;
    v35 = v37->ColumnHeader[v22];
    v32 = v40 + (float)((float)((float)RsGlobal.screenHeight / 448.0) * 20.0);
    v36 = v38 + v39;
LABEL_33:
    v42 = CText::Get(&TheText, v35);
    CFont::PrintString(v36, v32, v42);
    goto LABEL_34;
  }
LABEL_35:
  LOWORD(v43) = v6;
  if ( v20->TotalItemsInThisMenu )
  {
    v73 = v3;
    v44 = 0;
    v45 = 0;
    v72 = v2;
    while ( 1 )
    {
      v46 = (float)(unsigned __int16)v43;
      v71 = v45;
      if ( v20->TotalColumnsInThisMenu )
        break;
LABEL_73:
      ++v45;
      v44 = (unsigned __int8)(v71 + 1);
      v43 = (unsigned int)(float)((float)((float)((float)RsGlobal.screenHeight / 448.0) * 16.0) + v46);
      if ( v44 >= v20->TotalItemsInThisMenu )
        return;
    }
    v47 = 0;
    v48 = 0;
    v74 = v44;
    while ( 1 )
    {
      v49 = 5 * v44;
      if ( !v20->Item[v48][v44][0] )
        goto LABEL_72;
      if ( !v20->InputEnabled )
      {
        v52 = &v20->CarColsNum[v44];
        if ( v52[994] )
        {
          v2 = v72;
          CRGBA::CRGBA(
            &v78,
            HudColour.value[1]._anon_0._anon_0.red - v73,
            HudColour.value[1]._anon_0._anon_0.green - v73,
            HudColour.value[1]._anon_0._anon_0.blue - v73,
            0xFFu);
        }
        else
        {
          v2 = v72;
          if ( v52[982] )
            CRGBA::CRGBA(
              &v77,
              HudColour.value[3]._anon_0._anon_0.red - v73,
              HudColour.value[3]._anon_0._anon_0.green - v73,
              HudColour.value[3]._anon_0._anon_0.blue - v73,
              0xFFu);
          else
            CRGBA::CRGBA(
              &v76,
              HudColour.value[13]._anon_0._anon_0.red - v73,
              HudColour.value[13]._anon_0._anon_0.green - v73,
              HudColour.value[13]._anon_0._anon_0.blue - v73,
              0xFFu);
        }
        goto LABEL_55;
      }
      if ( v44 == v20->CurrentSelectedItem && v20->ItemActive[v44] )
        break;
      v51 = &v20->CarColsNum[v44];
      if ( v51[994] )
      {
        v2 = v72;
        CRGBA::CRGBA(
          &v81,
          HudColour.value[1]._anon_0._anon_0.red - v73,
          HudColour.value[1]._anon_0._anon_0.green - v73,
          HudColour.value[1]._anon_0._anon_0.blue - v73,
          0xFFu);
        goto LABEL_55;
      }
      if ( v51[982] )
        CRGBA::CRGBA(
          &v80,
          HudColour.value[13]._anon_0._anon_0.red - v73,
          HudColour.value[13]._anon_0._anon_0.green - v73,
          HudColour.value[13]._anon_0._anon_0.blue - v73,
          0xFFu);
      else
        CRGBA::CRGBA(
          &v79,
          HudColour.value[9]._anon_0._anon_0.red - v73,
          HudColour.value[9]._anon_0._anon_0.green - v73,
          HudColour.value[9]._anon_0._anon_0.blue - v73,
          0xFFu);
      CFont::SetColor(v53);
      v2 = v72;
LABEL_56:
      v44 = v74;
      v20 = MenuNumber[v2];
      v54 = (int)v20 + 120 * v48 + 2 * v49;
      v56 = *(unsigned __int8 *)(v54 + 65);
      v55 = (const unsigned __int8 *)(v54 + 65);
      if ( v56 )
      {
        v57 = CText::Get(&TheText, v55);
        v58 = (char *)MenuNumber[v2] + 48 * v48 + 4 * v74;
        CMessages::InsertNumberInString(
          v57,
          *((_DWORD *)v58 + 137),
          *((_DWORD *)v58 + 185),
          -1,
          -1,
          -1,
          -1,
          (GxtChar *)&Rectangle);
        CFont::SetOrientation(MenuNumber[v2]->ItemOrientation[v48]);
        CFont::SetScale((float)RsGlobal.screenHeight / 448.0);
        StringWidth = CFont::GetStringWidth((GxtChar *)&Rectangle, 1u, 0);
        v60 = MenuNumber[v2];
        v61 = v60->ColumnSize[v48];
        if ( StringWidth > v61 )
        {
          v62 = 1.0;
          do
          {
            v62 = v62 + -0.01;
            CFont::SetScale(v62 * (float)((float)RsGlobal.screenHeight / 448.0));
            v63 = CFont::GetStringWidth((GxtChar *)&Rectangle, 1u, 0);
            v60 = MenuNumber[v2];
            v61 = v60->ColumnSize[v48];
          }
          while ( v63 > v61 );
        }
        if ( v47 << 24 )
        {
          v64 = v60->ColumnSize;
          v65 = (unsigned __int8)v47;
          LOWORD(v66) = 0;
          do
          {
            --v65;
            v67 = *v64++;
            v66 = (unsigned int)(float)(v67 + (float)(unsigned __int16)v66);
          }
          while ( v65 );
        }
        else
        {
          v66 = 0;
        }
        if ( v60->ItemOrientation[v48] )
        {
          if ( v60->ItemOrientation[v48] == 2 )
          {
            v68 = v66;
            goto LABEL_69;
          }
          v69 = (float)(v60->x_pos + (float)((float)((float)RsGlobal.screenWidth / 640.0) * 10.0)) + (float)v66;
          v70 = v60->y_pos + v46;
        }
        else
        {
          v68 = v66;
          v61 = v61 * 0.5;
LABEL_69:
          v69 = v61
              + (float)((float)(v60->x_pos + (float)((float)((float)RsGlobal.screenWidth / 640.0) * 10.0)) + (float)v68);
          v70 = v60->y_pos + v46;
        }
        CFont::PrintString(v69, v70, (GxtChar *)&Rectangle);
        v44 = v74;
        v20 = MenuNumber[v2];
      }
LABEL_72:
      v48 = (unsigned __int8)++v47;
      if ( (unsigned __int8)v47 >= (unsigned int)v20->TotalColumnsInThisMenu )
        goto LABEL_73;
    }
    CRGBA::CRGBA(
      &v82,
      HudColour.value[3]._anon_0._anon_0.red - v73,
      HudColour.value[3]._anon_0._anon_0.green - v73,
      HudColour.value[3]._anon_0._anon_0.blue - v73,
      0xFFu);
LABEL_55:
    CFont::SetColor(v50);
    goto LABEL_56;
  }
}
// 43CB2E: variable 'v18' is possibly undefined
// 43CB70: variable 'v19' is possibly undefined
// 43CC5C: variable 'v26' is possibly undefined
// 43D01E: variable 'v53' is possibly undefined
// 43D04E: variable 'v50' is possibly undefined

//----- (0043D2F0) --------------------------------------------------------
void __fastcall CMenuSystem::DisplayGridMenu(uint8 id, bool8 selected)
{
  int v2; // r5
  int v3; // r4
  CSelectableMenu *v4; // r0
  float v5; // s0
  float x_pos; // s2
  CRGBA v7; // r0
  uint8 v8; // r3
  unsigned __int8 v9; // r8
  int v10; // r3
  unsigned __int8 v11; // r10
  float v12; // s22
  int v13; // r2
  RwUInt8 v14; // r6
  RwRGBA_0 *v15; // r2
  UInt8 green; // r6
  UInt8 blue; // r4
  float v18; // s24
  float v19; // s0
  float y_pos; // s2
  float v21; // s6
  float v22; // s4
  float v23; // s14
  float v24; // s6
  float v25; // s12
  float v26; // s10
  float v27; // s0
  float v28; // s2
  float v29; // s4
  float v30; // s8
  unsigned int TotalColumnsInThisMenu; // r1
  int v32; // [sp+10h] [bp-78h]
  UInt8 red; // [sp+24h] [bp-64h]
  CRGBA v34; // [sp+28h] [bp-60h] BYREF
  CRGBA v35; // [sp+2Ch] [bp-5Ch] BYREF
  CRect Rectangle; // [sp+30h] [bp-58h] BYREF

  v2 = id;
  v3 = selected;
  v4 = MenuNumber[id];
  if ( v4->border )
  {
    v5 = v4->ColumnSize[0] * (float)v4->TotalColumnsInThisMenu;
    x_pos = v4->x_pos;
    Rectangle.bottom = v4->y_pos;
    Rectangle.left = x_pos;
    Rectangle.right = x_pos + v5;
    Rectangle.top = Rectangle.bottom + v5;
    CRGBA::CRGBA(&v35, 0, 0, 0, 0xBEu);
    v8 = 0;
    if ( !v3 )
      v8 = 120;
    CMenuManager::DrawWindow(&FrontEndMenuManager, &Rectangle, 0, v8, v7, 0, 1);
    v4 = MenuNumber[v2];
  }
  if ( v4->TotalColumnsInThisMenu )
  {
    v9 = 0;
    v10 = 0;
    do
    {
      v32 = v10;
      v11 = 0;
      v12 = (float)(unsigned __int8)v10;
      do
      {
        v13 = v4->CarColsNum[v9];
        v14 = CVehicleModelInfo::ms_vehicleColourTable[v13]._anon_0._anon_0.red;
        v15 = &CVehicleModelInfo::ms_vehicleColourTable[v13];
        red = v14;
        green = v15->_anon_0._anon_0.green;
        blue = v15->_anon_0._anon_0.blue;
        v18 = (float)v11;
        if ( v9 == v4->CurrentSelectedItem )
        {
          v19 = v4->ColumnSize[0];
          y_pos = v4->y_pos;
          v21 = v4->x_pos;
          Rectangle.bottom = y_pos + (float)(v19 * v12);
          Rectangle.top = (float)(v19 * v12) + (float)(v19 + y_pos);
          Rectangle.left = v21 + (float)(v19 * v18);
          Rectangle.right = (float)(v21 + v19) + (float)(v19 * v18);
          CRGBA::CRGBA(&v34, 0xE1u, 0xE1u, 0xE1u, 0xFFu);
          CSprite2d::DrawRect(&Rectangle, &v34);
          v4 = MenuNumber[v2];
        }
        v22 = v4->ColumnSize[0];
        v23 = v22 * v18;
        v24 = v4->x_pos;
        v25 = v22 + v4->y_pos;
        v26 = v24 + v22;
        v27 = (float)((float)RsGlobal.screenWidth / 640.0) * 3.0;
        v28 = (float)((float)RsGlobal.screenHeight / 448.0) * 3.0;
        v29 = v22 * v12;
        v30 = v29 + (float)(v4->y_pos + v28);
        Rectangle.left = v23 + (float)(v24 + v27);
        Rectangle.bottom = v30;
        Rectangle.right = v23 + (float)(v26 - v27);
        Rectangle.top = v29 + (float)(v25 - v28);
        CRGBA::CRGBA(&v34, red, green, blue, 0xFFu);
        CSprite2d::DrawRect(&Rectangle, &v34);
        ++v11;
        ++v9;
        v4 = MenuNumber[v2];
        TotalColumnsInThisMenu = v4->TotalColumnsInThisMenu;
      }
      while ( v11 < TotalColumnsInThisMenu );
      v10 = v32 + 1;
    }
    while ( (unsigned __int8)(v32 + 1) < TotalColumnsInThisMenu );
  }
}
// 43D384: variable 'v7' is possibly undefined

//----- (0043D574) --------------------------------------------------------
void __fastcall CMenuSystem::ActivateOneItem(uint8 id, uint8 item, bool8 active)
{
  CSelectableMenu *v3; // r1
  int CurrentSelectedItem; // r2
  int8 v5; // r12
  int TotalItemsInThisMenu; // r3
  int v7; // r2

  MenuNumber[id]->ItemActive[item] = active;
  while ( 1 )
  {
    v3 = MenuNumber[id];
    CurrentSelectedItem = v3->CurrentSelectedItem;
    v5 = v3->CurrentSelectedItem;
    if ( v3->ItemActive[CurrentSelectedItem] )
    {
      if ( v3->Item[0][CurrentSelectedItem][0] )
        break;
    }
    if ( CurrentSelectedItem >= v3->TotalItemsInThisMenu )
      goto LABEL_8;
    v3->CurrentSelectedItem = v5 + 1;
  }
  TotalItemsInThisMenu = v3->TotalItemsInThisMenu;
  if ( CurrentSelectedItem < TotalItemsInThisMenu )
    goto LABEL_15;
LABEL_8:
  for ( v3->CurrentSelectedItem = 0; ; v3->CurrentSelectedItem = v5 + 1 )
  {
    v3 = MenuNumber[id];
    v7 = v3->CurrentSelectedItem;
    v5 = v3->CurrentSelectedItem;
    if ( v3->ItemActive[v7] )
    {
      if ( v3->Item[0][v7][0] )
        break;
    }
    TotalItemsInThisMenu = v3->TotalItemsInThisMenu;
    if ( v7 >= TotalItemsInThisMenu )
      goto LABEL_15;
  }
  TotalItemsInThisMenu = v3->TotalItemsInThisMenu;
LABEL_15:
  if ( v5 >= TotalItemsInThisMenu )
    v3->CurrentSelectedItem = 0;
}

//----- (0043D638) --------------------------------------------------------
void __fastcall CMenuSystem::HighlightOneItem(uint8 id, uint8 item, bool8 highlight)
{
  MenuNumber[id]->ItemHighlight[item] = highlight;
  MenuNumber[id]->ItemActive[item] = 1;
}

//----- (0043D65C) --------------------------------------------------------
void __fastcall CMenuSystem::SetColumnHeader(uint8 id, uint8 column, unsigned __int8 *Item)
{
  char *v3; // r0

  v3 = (char *)MenuNumber[id]->ColumnHeader[column];
  if ( Item )
    sub_19B9DC(v3, (const char *)Item);
  else
    *v3 = 0;
}

//----- (0043D688) --------------------------------------------------------
void __fastcall CMenuSystem::SetDPadInput(uint8 id, bool8 input)
{
  MenuNumber[id]->UseDPad = input;
}

//----- (0043D69C) --------------------------------------------------------
void __fastcall CMenuSystem::GetMenuPosition(uint8 id, float *x, float *y)
{
  *x = MenuNumber[id]->x_pos;
  *y = MenuNumber[id]->y_pos;
}

//----- (0043D6C0) --------------------------------------------------------
void __fastcall CMenuSystem::InsertOneMenuItem(uint8 id, uint8 column, uint8 item, unsigned __int8 *Item)
{
  int v4; // r4
  int v5; // r6
  int v6; // r5
  char *v7; // r0
  char v8; // r0
  int i; // r1
  CSelectableMenu *v10; // r3

  v4 = id;
  v5 = column;
  v6 = item;
  v7 = (char *)MenuNumber[id]->Item[column][item];
  if ( Item )
    strcpy(v7, (const char *)Item);
  else
    *v7 = 0;
  MenuNumber[v4]->FirstNumberToInsert[v5][v6] = -1;
  MenuNumber[v4]->SecondNumberToInsert[v5][v6] = -1;
  v8 = 0;
  MenuNumber[v4]->TotalItemsInThisMenu = 0;
  for ( i = 65; i != 185; i += 10 )
  {
    v10 = MenuNumber[v4];
    ++v8;
    if ( v10->CarColsNum[i] )
    {
      v10->TotalItemsInThisMenu += v8;
      v8 = 0;
    }
  }
}

//----- (0043D76C) --------------------------------------------------------
void __fastcall CMenuSystem::InsertOneMenuItemWithNumber(
        int MenuIndex,
        int ColumnIndex,
        int RowIndex,
        unsigned __int8 *String,
        Int32 a5,
        Int32 a6)
{
  char *v9; // r0
  char v10; // r0
  int i; // r1
  CSelectableMenu *v12; // r3

  v9 = (char *)MenuNumber[MenuIndex]->Item[ColumnIndex][RowIndex];
  if ( String )
    strcpy(v9, (const char *)String);
  else
    *v9 = 0;
  MenuNumber[MenuIndex]->FirstNumberToInsert[ColumnIndex][RowIndex] = a5;
  MenuNumber[MenuIndex]->SecondNumberToInsert[ColumnIndex][RowIndex] = a6;
  v10 = 0;
  MenuNumber[MenuIndex]->TotalItemsInThisMenu = 0;
  for ( i = 65; i != 185; i += 10 )
  {
    v12 = MenuNumber[MenuIndex];
    ++v10;
    if ( v12->CarColsNum[i] )
    {
      v12->TotalItemsInThisMenu += v10;
      v10 = 0;
    }
  }
}

//----- (0043D818) --------------------------------------------------------
void __fastcall CMenuSystem::InsertMenu(
        int id,
        int column,
        unsigned __int8 *Header,
        unsigned __int8 *Item1,
        unsigned __int8 *Item2,
        unsigned __int8 *Item3,
        unsigned __int8 *Item4,
        unsigned __int8 *Item5,
        unsigned __int8 *Item6,
        unsigned __int8 *Item7,
        unsigned __int8 *Item8,
        unsigned __int8 *Item9,
        unsigned __int8 *Item10,
        unsigned __int8 *Item11,
        unsigned __int8 *Item12)
{
  char *v18; // r0
  char *v19; // r0
  char *v20; // r0
  char *v21; // r0
  char *v22; // r0
  char *v23; // r0
  char *v24; // r0
  char *v25; // r0
  char *v26; // r0
  char *v27; // r0
  char *v28; // r0
  char *v29; // r0
  char *v30; // r0
  char v31; // r0
  int i; // r1
  CSelectableMenu *v33; // r3

  v18 = (char *)MenuNumber[id]->ColumnHeader[column];
  if ( Header )
    strcpy(v18, (const char *)Header);
  else
    *v18 = 0;
  v19 = (char *)MenuNumber[id]->Item[column];
  if ( Item1 )
    strcpy(v19, (const char *)Item1);
  else
    *v19 = 0;
  v20 = (char *)MenuNumber[id]->Item[column][1];
  if ( Item2 )
    strcpy(v20, (const char *)Item2);
  else
    *v20 = 0;
  v21 = (char *)MenuNumber[id]->Item[column][2];
  if ( Item3 )
    strcpy(v21, (const char *)Item3);
  else
    *v21 = 0;
  v22 = (char *)MenuNumber[id]->Item[column][3];
  if ( Item4 )
    strcpy(v22, (const char *)Item4);
  else
    *v22 = 0;
  v23 = (char *)MenuNumber[id]->Item[column][4];
  if ( Item5 )
    strcpy(v23, (const char *)Item5);
  else
    *v23 = 0;
  v24 = (char *)MenuNumber[id]->Item[column][5];
  if ( Item6 )
    strcpy(v24, (const char *)Item6);
  else
    *v24 = 0;
  v25 = (char *)MenuNumber[id]->Item[column][6];
  if ( Item7 )
    strcpy(v25, (const char *)Item7);
  else
    *v25 = 0;
  v26 = (char *)MenuNumber[id]->Item[column][7];
  if ( Item8 )
    strcpy(v26, (const char *)Item8);
  else
    *v26 = 0;
  v27 = (char *)MenuNumber[id]->Item[column][8];
  if ( Item9 )
    strcpy(v27, (const char *)Item9);
  else
    *v27 = 0;
  v28 = (char *)MenuNumber[id]->Item[column][9];
  if ( Item10 )
    strcpy(v28, (const char *)Item10);
  else
    *v28 = 0;
  v29 = (char *)MenuNumber[id]->Item[column][10];
  if ( Item11 )
    strcpy(v29, (const char *)Item11);
  else
    *v29 = 0;
  v30 = (char *)MenuNumber[id]->Item[column][11];
  if ( Item12 )
    strcpy(v30, (const char *)Item12);
  else
    *v30 = 0;
  MenuNumber[id]->FirstNumberToInsert[column][0] = -1;
  MenuNumber[id]->SecondNumberToInsert[column][0] = -1;
  MenuNumber[id]->FirstNumberToInsert[column][1] = -1;
  MenuNumber[id]->SecondNumberToInsert[column][1] = -1;
  MenuNumber[id]->FirstNumberToInsert[column][2] = -1;
  MenuNumber[id]->SecondNumberToInsert[column][2] = -1;
  MenuNumber[id]->FirstNumberToInsert[column][3] = -1;
  MenuNumber[id]->SecondNumberToInsert[column][3] = -1;
  MenuNumber[id]->FirstNumberToInsert[column][4] = -1;
  MenuNumber[id]->SecondNumberToInsert[column][4] = -1;
  MenuNumber[id]->FirstNumberToInsert[column][5] = -1;
  MenuNumber[id]->SecondNumberToInsert[column][5] = -1;
  MenuNumber[id]->FirstNumberToInsert[column][6] = -1;
  MenuNumber[id]->SecondNumberToInsert[column][6] = -1;
  MenuNumber[id]->FirstNumberToInsert[column][7] = -1;
  MenuNumber[id]->SecondNumberToInsert[column][7] = -1;
  MenuNumber[id]->FirstNumberToInsert[column][8] = -1;
  MenuNumber[id]->SecondNumberToInsert[column][8] = -1;
  MenuNumber[id]->FirstNumberToInsert[column][9] = -1;
  MenuNumber[id]->SecondNumberToInsert[column][9] = -1;
  MenuNumber[id]->FirstNumberToInsert[column][10] = -1;
  MenuNumber[id]->SecondNumberToInsert[column][10] = -1;
  MenuNumber[id]->FirstNumberToInsert[column][11] = -1;
  MenuNumber[id]->SecondNumberToInsert[column][11] = -1;
  if ( !column )
  {
    v31 = 0;
    MenuNumber[id]->TotalItemsInThisMenu = 0;
    for ( i = 65; i != 185; i += 10 )
    {
      v33 = MenuNumber[id];
      ++v31;
      if ( v33->CarColsNum[i] )
      {
        v33->TotalItemsInThisMenu += v31;
        v31 = 0;
      }
    }
  }
}

//----- (0043DBC8) --------------------------------------------------------
void __fastcall CMenuSystem::SetColumnWidth(uint8 id, uint8 column, uint16 size)
{
  MenuNumber[id]->ColumnSize[column] = (float)size;
}

//----- (0043DBE8) --------------------------------------------------------
void __fastcall CMenuSystem::SetColumnOrientation(uint8 id, uint8 column, uint8 orientation)
{
  MenuNumber[id]->ItemOrientation[column] = orientation;
}

//----- (0043DC00) --------------------------------------------------------
void __fastcall CMenuSystem::SetHeaderOrientation(uint8 id, uint8 column, uint8 orientation)
{
  MenuNumber[id]->HeaderOrientation[column] = orientation;
}

//----- (0043DC18) --------------------------------------------------------
void __fastcall CMenuSystem::SetActiveMenuItem(uint8 id, int8 item)
{
  MenuNumber[id]->CurrentSelectedItem = item;
}

//----- (0043DC2C) --------------------------------------------------------
uint8 __fastcall CMenuSystem::GetCarColourFromGrid(uint8 id, uint8 col_id)
{
  return MenuNumber[id]->CarColsNum[col_id];
}

//----- (0043DC40) --------------------------------------------------------
uint8 __fastcall CMenuSystem::FindCarColourFromGrid(uint8 id, uint8 col_id)
{
  int v2; // r2
  CSelectableMenu *v3; // r0

  v2 = 0;
  v3 = MenuNumber[id];
  while ( v3->CarColsNum[v2] != col_id )
  {
    if ( v2++ >= 63 )
    {
      LOBYTE(v2) = 0;
      return v2;
    }
  }
  return v2;
}

//----- (0043DC64) --------------------------------------------------------
bool __fastcall CMenuSystem::IsCarColourInGrid(uint8 id, uint8 col_id)
{
  int v2; // r2
  CSelectableMenu *v3; // r0

  v2 = 0;
  v3 = MenuNumber[id];
  do
  {
    if ( v3->CarColsNum[v2] == col_id )
      return 1;
  }
  while ( v2++ <= 62 );
  return 0;
}

//----- (0043DC90) --------------------------------------------------------
void CRadar::Initialise()
{
  UInt16 *p_ReferenceIndex; // r1
  int v1; // r2
  __int16 v2; // r5
  int v3; // r4
  unsigned __int8 s[16]; // [sp+4h] [bp-24h] BYREF

  CRadar::airstrip_blip = 0;
  p_ReferenceIndex = &CRadar::ms_RadarTrace[0].ReferenceIndex;
  CRadar::airstrip_location = 0;
  v1 = 250;
  do
  {
    p_ReferenceIndex[4] = 1;
    --v1;
    *((_DWORD *)p_ReferenceIndex + 1) = 1065353216;
    v2 = *(UInt16 *)((char *)p_ReferenceIndex + 17);
    *((_DWORD *)p_ReferenceIndex + 3) = 0;
    *((_BYTE *)p_ReferenceIndex + 16) = 0;
    *p_ReferenceIndex = 1;
    *(UInt16 *)((char *)p_ReferenceIndex + 17) = v2 & 0xC000 | 1;
    p_ReferenceIndex += 20;
  }
  while ( v1 );
  v3 = 0;
  CRadar::m_radarRange = 350.0;
  do
    sprintf(s, "radar%02d", v3++);
  while ( v3 != 144 );
}
// 43DC90: using guessed type unsigned __int8 s[16];

//----- (0043DD48) --------------------------------------------------------
void __fastcall CRadar::ClearActualBlip(int32 ActualIndex)
{
  sRadarTrace *v1; // r0
  __int16 v2; // r1

  if ( (unsigned int)ActualIndex <= 0xF9 )
  {
    v1 = &CRadar::ms_RadarTrace[ActualIndex];
    v1->nBlipScale = 1;
    v1->fBlipMarkerScale = 1.0;
    v2 = *(_WORD *)((char *)v1 + 37);
    v1->pEntryExit = 0;
    v1->nBlipSprite = 0;
    *(_WORD *)((char *)v1 + 37) = v2 & 0xC000 | 1;
  }
}

//----- (0043DD84) --------------------------------------------------------
void CRadar::Shutdown()
{
  int i; // r4
  int j; // r9
  RwTexture_0 *v2; // r0
  RwTexture_0 *v3; // r0
  RwTexture_0 *v4; // r0
  RwTexture_0 *v5; // r0
  RwTexture_0 *v6; // r0
  RwTexture_0 *v7; // r0
  RwTexture_0 *v8; // r0
  RwTexture_0 *v9; // r0
  RwTexture_0 *v10; // r0
  RwTexture_0 *v11; // r0
  RwTexture_0 *v12; // r0
  RwTexture_0 *v13; // r0

  for ( i = 0; i != 64; ++i )
    CSprite2d::Delete(&CRadar::RadarBlipSprites[i]);
  for ( j = 0; j != 12; ++j )
  {
    v2 = gRadarTextures[j];
    if ( v2 )
    {
      RwTextureDestroy(v2);
      gRadarTextures[j] = 0;
    }
    v3 = gRadarTextures[j + 12];
    if ( v3 )
    {
      RwTextureDestroy(v3);
      gRadarTextures[j + 12] = 0;
    }
    v4 = gRadarTextures[j + 24];
    if ( v4 )
    {
      RwTextureDestroy(v4);
      gRadarTextures[j + 24] = 0;
    }
    v5 = gRadarTextures[j + 36];
    if ( v5 )
    {
      RwTextureDestroy(v5);
      gRadarTextures[j + 36] = 0;
    }
    v6 = gRadarTextures[j + 48];
    if ( v6 )
    {
      RwTextureDestroy(v6);
      gRadarTextures[j + 48] = 0;
    }
    v7 = gRadarTextures[j + 60];
    if ( v7 )
    {
      RwTextureDestroy(v7);
      gRadarTextures[j + 60] = 0;
    }
    v8 = gRadarTextures[j + 72];
    if ( v8 )
    {
      RwTextureDestroy(v8);
      gRadarTextures[j + 72] = 0;
    }
    v9 = gRadarTextures[j + 84];
    if ( v9 )
    {
      RwTextureDestroy(v9);
      gRadarTextures[j + 84] = 0;
    }
    v10 = gRadarTextures[j + 96];
    if ( v10 )
    {
      RwTextureDestroy(v10);
      gRadarTextures[j + 96] = 0;
    }
    v11 = gRadarTextures[j + 108];
    if ( v11 )
    {
      RwTextureDestroy(v11);
      gRadarTextures[j + 108] = 0;
    }
    v12 = gRadarTextures[j + 120];
    if ( v12 )
    {
      RwTextureDestroy(v12);
      gRadarTextures[j + 120] = 0;
    }
    v13 = gRadarTextures[j + 132];
    if ( v13 )
    {
      RwTextureDestroy(v13);
      gRadarTextures[j + 132] = 0;
    }
  }
  sub_19CD8C(&circleTex);
}

//----- (0043DF44) --------------------------------------------------------
void CRadar::RemoveRadarSections()
{
  int i; // r9
  RwTexture_0 *v1; // r0
  RwTexture_0 *v2; // r0
  RwTexture_0 *v3; // r0
  RwTexture_0 *v4; // r0
  RwTexture_0 *v5; // r0
  RwTexture_0 *v6; // r0
  RwTexture_0 *v7; // r0
  RwTexture_0 *v8; // r0
  RwTexture_0 *v9; // r0
  RwTexture_0 *v10; // r0
  RwTexture_0 *v11; // r0
  RwTexture_0 *v12; // r0

  for ( i = 0; i != 12; ++i )
  {
    v1 = gRadarTextures[i];
    if ( v1 )
    {
      RwTextureDestroy(v1);
      gRadarTextures[i] = 0;
    }
    v2 = gRadarTextures[i + 12];
    if ( v2 )
    {
      RwTextureDestroy(v2);
      gRadarTextures[i + 12] = 0;
    }
    v3 = gRadarTextures[i + 24];
    if ( v3 )
    {
      RwTextureDestroy(v3);
      gRadarTextures[i + 24] = 0;
    }
    v4 = gRadarTextures[i + 36];
    if ( v4 )
    {
      RwTextureDestroy(v4);
      gRadarTextures[i + 36] = 0;
    }
    v5 = gRadarTextures[i + 48];
    if ( v5 )
    {
      RwTextureDestroy(v5);
      gRadarTextures[i + 48] = 0;
    }
    v6 = gRadarTextures[i + 60];
    if ( v6 )
    {
      RwTextureDestroy(v6);
      gRadarTextures[i + 60] = 0;
    }
    v7 = gRadarTextures[i + 72];
    if ( v7 )
    {
      RwTextureDestroy(v7);
      gRadarTextures[i + 72] = 0;
    }
    v8 = gRadarTextures[i + 84];
    if ( v8 )
    {
      RwTextureDestroy(v8);
      gRadarTextures[i + 84] = 0;
    }
    v9 = gRadarTextures[i + 96];
    if ( v9 )
    {
      RwTextureDestroy(v9);
      gRadarTextures[i + 96] = 0;
    }
    v10 = gRadarTextures[i + 108];
    if ( v10 )
    {
      RwTextureDestroy(v10);
      gRadarTextures[i + 108] = 0;
    }
    v11 = gRadarTextures[i + 120];
    if ( v11 )
    {
      RwTextureDestroy(v11);
      gRadarTextures[i + 120] = 0;
    }
    v12 = gRadarTextures[i + 132];
    if ( v12 )
    {
      RwTextureDestroy(v12);
      gRadarTextures[i + 132] = 0;
    }
  }
}

//----- (0043E0DC) --------------------------------------------------------
void CRadar::LoadTextures()
{
  int32 TxdSlot; // r0
  int v1; // r4

  CTxdStore::PushCurrentTxd();
  TxdSlot = CTxdStore::FindTxdSlot((const unsigned __int8 *)&off_43E12C);
  v1 = 0;
  CTxdStore::SetCurrentTxd(TxdSlot, 0);
  do
  {
    CSprite2d::SetTexture(&CRadar::RadarBlipSprites[v1], RadarBlipSpriteFilenames[v1].pBitmapFileName);
    ++v1;
  }
  while ( v1 != 64 );
  CSprite2d::SetTexture(&circleTex, "target256");
  sub_1979B0();
}
// 43E12C: using guessed type void *off_43E12C;

//----- (0043E148) --------------------------------------------------------
int32 __fastcall CRadar::GetNewUniqueBlipIndex(int32 ArrayIndex)
{
  int v1; // r3
  sRadarTrace *v2; // r12
  unsigned int ReferenceIndex; // r2
  int32 result; // r0

  v1 = 1;
  v2 = &CRadar::ms_RadarTrace[ArrayIndex];
  ReferenceIndex = v2->ReferenceIndex;
  if ( ReferenceIndex < 0xFFFE )
    v1 = ReferenceIndex + 1;
  result = ArrayIndex | (v1 << 16);
  v2->ReferenceIndex = v1;
  return result;
}

//----- (0043E174) --------------------------------------------------------
int32 __fastcall CRadar::GetActualBlipArrayIndex(int32 Index)
{
  unsigned int v1; // r1

  v1 = Index;
  if ( Index == -1 )
    return -1;
  Index = (unsigned __int16)Index;
  if ( CRadar::ms_RadarTrace[(unsigned __int16)v1].ReferenceIndex != HIWORD(v1) )
    return -1;
  if ( (*((_BYTE *)&CRadar::ms_RadarTrace[(unsigned __int16)v1] + 37) & 2) == 0 )
    return -1;
  return Index;
}

//----- (0043E1C0) --------------------------------------------------------
void CRadar::DrawMap()
{
  float v0; // s0
  const CVector *PlayerSpeed; // r0
  float v2; // s0
  CVehicle *PlayerVehicle; // r0
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  float v6; // s0
  CVector v7; // [sp+0h] [bp-20h] BYREF
  CVector v8; // [sp+Ch] [bp-14h] BYREF

  CRadar::CalculateCachedSinCos();
  if ( FindPlayerVehicle(-1, 0) && !CPlayerInfo::IsPlayerInRemoteMode(&CWorld::Players[CWorld::PlayerInFocus]) )
  {
    if ( FindPlayerVehicle(-1, 0)
      && FindPlayerVehicle(-1, 0)->m_vehicleType == 4
      && FindPlayerVehicle(-1, 0)->m_nModelIndex != 539 )
    {
      PlayerVehicle = FindPlayerVehicle(-1, 0);
      m_pMat = PlayerVehicle->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &PlayerVehicle->m_transform;
      v6 = p_tx->m_translate.z / 200.0;
      if ( v6 < 0.3 )
      {
        v0 = 340.0;
        goto LABEL_10;
      }
      if ( v6 < 0.9 )
      {
        v0 = (float)((float)((float)(v6 + -0.3) * 10.0) / 0.6) + 340.0;
        goto LABEL_10;
      }
    }
    else
    {
      PlayerSpeed = FindPlayerSpeed(-1);
      v2 = sqrtf(
             (float)((float)(PlayerSpeed->x * PlayerSpeed->x) + (float)(PlayerSpeed->y * PlayerSpeed->y))
           + (float)(PlayerSpeed->z * PlayerSpeed->z));
      if ( v2 < 0.3 )
        goto LABEL_9;
      if ( v2 < 0.9 )
      {
        v0 = (float)((float)((float)(v2 + -0.3) * 170.0) / 0.6) + 180.0;
        goto LABEL_10;
      }
    }
    v0 = 350.0;
    goto LABEL_10;
  }
  if ( !CTheScripts::RadarZoomValue )
  {
LABEL_9:
    v0 = 180.0;
    goto LABEL_10;
  }
  v0 = (float)(180 - CTheScripts::RadarZoomValue);
LABEL_10:
  CRadar::m_radarRange = v0;
  if ( !CGameLogic::IsCoopGameGoingOn() )
    goto LABEL_13;
  if ( CGameLogic::n2PlayerPedInFocus == 1 )
  {
    FindPlayerCentreOfWorldForMap(&v8, 1);
    goto LABEL_16;
  }
  if ( !CGameLogic::n2PlayerPedInFocus )
  {
LABEL_13:
    FindPlayerCentreOfWorldForMap(&v8, 0);
LABEL_16:
    CRadar::vec2DRadarOrigin.x = v8.x;
    CRadar::vec2DRadarOrigin.y = v8.y;
    goto LABEL_17;
  }
  FindPlayerCentreOfWorldForMap(&v8, 0);
  FindPlayerCentreOfWorldForMap(&v7, 1);
  CRadar::vec2DRadarOrigin.x = (float)(v8.x + v7.x) * 0.5;
  CRadar::vec2DRadarOrigin.y = (float)(v8.y + v7.y) * 0.5;
LABEL_17:
  if ( CGame::currArea == AREA_MAIN_MAP && !FindPlayerPed(-1)->m_areaCode )
    CRadar::DrawRadarMap();
}

//----- (0043E420) --------------------------------------------------------
void CRadar::CalculateCachedSinCos()
{
  float *v0; // r1
  float v1; // r0
  float m_heading; // s0
  char *v3; // r1
  CPlaceable *v4; // r4
  int v5; // r2
  CMatrix *m_pMat; // r1
  __int64 v7; // d16
  float *p_tx; // r3
  float *v9; // r0
  RwReal v10; // s0
  RwReal v11; // s4
  CEntity *CamTargetEntity; // r4
  CMatrix *v13; // r0
  __int64 v14; // d16
  float v15; // r4
  CVector v16[2]; // [sp+0h] [bp-18h] BYREF

  if ( gMobileMenu.DisplayingMap )
  {
    v0 = &gTransformSin;
    gTransformCos = 1.0;
    v1 = 0.0;
  }
  else if ( CCamera::GetLookDirection(&TheCamera) == 3 )
  {
    if ( TheCamera.m_pMat )
      m_heading = atan2f(COERCE_FLOAT(LODWORD(TheCamera.m_pMat->xy) ^ 0x80000000), TheCamera.m_pMat->yy);
    else
      m_heading = TheCamera.m_transform.m_heading;
    gTransformHeading = m_heading;
    gTransformSin = sinf(m_heading);
    v1 = cosf(m_heading);
    v0 = &gTransformCos;
  }
  else
  {
    v3 = (char *)&TheCamera + 528 * TheCamera.ActiveCam;
    v4 = (CPlaceable *)*((_DWORD *)v3 + 217);
    v5 = *((unsigned __int16 *)v3 + 191);
    m_pMat = v4->m_pMat;
    if ( v5 == 16 )
    {
      if ( !m_pMat )
      {
        CPlaceable::AllocateMatrix(v4);
        CSimpleTransform::UpdateMatrix(&v4->m_transform, v4->m_pMat);
        m_pMat = v4->m_pMat;
      }
      v7 = *(_QWORD *)&m_pMat->xy;
      v16[0].z = m_pMat->zy;
      *(_QWORD *)&v16[0].x = v7;
      CVector::Normalise(v16);
    }
    else
    {
      p_tx = &m_pMat->tx;
      if ( !m_pMat )
        p_tx = &v4->m_transform.m_translate.x;
      v9 = (float *)((char *)&TheCamera + 528 * TheCamera.ActiveCam);
      v10 = *p_tx - v9[188];
      v11 = p_tx[2] - v9[190];
      v16[0].y = p_tx[1] - v9[189];
      v16[0].x = v10;
      v16[0].z = v11;
    }
    if ( !CCamera::GetLookDirection(&TheCamera) )
    {
      CamTargetEntity = TheCamera.Cams[TheCamera.ActiveCam].CamTargetEntity;
      v13 = CamTargetEntity->m_pMat;
      if ( !v13 )
      {
        CPlaceable::AllocateMatrix(TheCamera.Cams[TheCamera.ActiveCam].CamTargetEntity);
        CSimpleTransform::UpdateMatrix(&CamTargetEntity->m_transform, CamTargetEntity->m_pMat);
        v13 = CamTargetEntity->m_pMat;
      }
      v14 = *(_QWORD *)&v13->xy;
      v16[0].z = v13->zy;
      *(_QWORD *)&v16[0].x = v14;
      CVector::Normalise(v16);
    }
    v15 = atan2f(
            COERCE_FLOAT(LODWORD(v16[0].x) ^ 0x80000000),
            COERCE_FLOAT((*(_QWORD *)&v16[0].x ^ 0x80000000uLL) >> 32));
    gTransformHeading = v15;
    gTransformSin = sinf(v15);
    v1 = cosf(v15);
    v0 = &gTransformCos;
  }
  *v0 = v1;
}

//----- (0043E5F0) --------------------------------------------------------
void CRadar::DrawRadarMap()
{
  float v0; // s18
  int32 v1; // s16
  int32 v2; // r9
  int32x4_t v3; // q8
  int32x4_t v4; // q9
  int alpha; // r10
  float v6; // r9
  float v7; // r5
  float zy; // r4
  CVehicle *PlayerVehicle; // r0
  float v10; // r0
  CRGBA v11; // [sp+8h] [bp-48h] BYREF
  CRect rect; // [sp+Ch] [bp-44h] BYREF
  CVector v13; // [sp+1Ch] [bp-34h] BYREF

  CRadar::DrawRadarMask();
  v0 = CRadar::vec2DRadarOrigin.y + 3000.0;
  v1 = (int)floorf((float)(CRadar::vec2DRadarOrigin.x + 3000.0) / 500.0);
  v2 = (int)ceilf(11.0 - (float)(v0 / 500.0));
  v3.n128_u32[0] = 500 * v1;
  v3.n128_u32[1] = 500 * (11 - v2);
  v3.n128_u64[1] = v3.n128_u64[0];
  v4.n128_u64[0] = 0xFFFFF830FFFFF254LL;
  v4.n128_u64[1] = 0xFFFFF254FFFFF830LL;
  CRadar::m_radarRect = (CRect)vcvtq_f32_s32(vaddq_s32(v3, v4));
  CRadar::StreamRadarSections(v1, v2);
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
  RwRenderStateSet(rwRENDERSTATESHADEMODE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
  RwRenderStateSet(rwRENDERSTATETEXTUREADDRESS, (char *)&dword_0 + 3);
  RwRenderStateSet(rwRENDERSTATETEXTUREPERSPECTIVE, 0);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
  if ( CTouchInterface::m_pWidgets[161] )
  {
    alpha = 255;
    if ( !gMobileMenu.screenStack.numEntries && !gMobileMenu.pendingScreen )
      alpha = CTouchInterface::m_pWidgets[161]->m_Color._anon_0._anon_0.alpha;
    CRadar::DrawRadarSection(v1 - 1, v2 - 1, alpha);
    CRadar::DrawRadarSection(v1, v2 - 1, alpha);
    CRadar::DrawRadarSection(v1 + 1, v2 - 1, alpha);
    CRadar::DrawRadarSection(v1 - 1, v2, alpha);
    CRadar::DrawRadarSection(v1, v2, alpha);
    CRadar::DrawRadarSection(v1 + 1, v2, alpha);
    CRadar::DrawRadarSection(v1 - 1, v2 + 1, alpha);
    CRadar::DrawRadarSection(v1, v2 + 1, alpha);
    CRadar::DrawRadarSection(v1 + 1, v2 + 1, alpha);
    CRadar::DrawRadarGangOverlay(0);
    if ( FindPlayerVehicle(-1, 0)
      && FindPlayerVehicle(-1, 0)->m_vehicleType == 4
      && FindPlayerVehicle(-1, 0)->m_nModelIndex != 539 )
    {
      FindPlayerCentreOfWorldForMap(&v13, 0);
      v6 = gTransformSin;
      gTransformSin = -0.000000087423;
      v7 = gTransformCos;
      gTransformCos = -1.0;
      zy = FindPlayerVehicle(-1, 0)->m_pMat->zy;
      PlayerVehicle = FindPlayerVehicle(-1, 0);
      v10 = atan2f(COERCE_FLOAT(LODWORD(zy) ^ 0x80000000), PlayerVehicle->m_pMat->zz);
      rect.left = v13.x + -1000.0;
      rect.right = v13.x + 1000.0;
      rect.top = v13.y + 2000.0;
      rect.bottom = v13.y + (float)((float)((float)(v10 * -180.0) / 3.1416) + (float)((float)(v10 * -180.0) / 3.1416));
      CRGBA::CRGBA(&v11, 0x14u, 0xAFu, 0x14u, (unsigned int)(float)((float)alpha * 0.8));
      CRadar::DrawAreaOnRadar(&rect, &v11, 0);
      gTransformCos = v7;
      gTransformSin = v6;
    }
  }
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (0043E8E8) --------------------------------------------------------
void CRadar::InitFrontEndMap()
{
  CRGBA *v0; // r0
  CRGBA *v1; // r0
  CRGBA *v2; // r0
  CRGBA *v3; // r0
  CRGBA *v4; // r0
  CRGBA v5; // [sp+4h] [bp-Ch] BYREF

  CRadar::CalculateCachedSinCos();
  CRadar::vec2DRadarOrigin.x = 0.0;
  CRadar::vec2DRadarOrigin.y = 0.0;
  CRadar::m_radarRange = 2990.0;
  memset(CRadar::MapLegendList, 0, sizeof(CRadar::MapLegendList));
  CRadar::MapLegendCounter = 0;
  CRGBA::CRGBA(&v5, 0, 0, 0, 0);
  CRadar::ArrowBlipColour[0] = v5;
  CRGBA::CRGBA(v0, 0, 0, 0, 0);
  CRadar::ArrowBlipColour[1] = v5;
  CRGBA::CRGBA(v1, 0, 0, 0, 0);
  CRadar::ArrowBlipColour[2] = v5;
  CRGBA::CRGBA(v2, 0, 0, 0, 0);
  CRadar::ArrowBlipColour[3] = v5;
  CRGBA::CRGBA(v3, 0, 0, 0, 0);
  CRadar::ArrowBlipColour[4] = v5;
  CRGBA::CRGBA(v4, 0, 0, 0, 0);
  CRadar::ArrowBlipColour[5] = v5;
}
// 43E944: variable 'v0' is possibly undefined
// 43E962: variable 'v1' is possibly undefined
// 43E980: variable 'v2' is possibly undefined
// 43E99E: variable 'v3' is possibly undefined
// 43E9BC: variable 'v4' is possibly undefined
// 12: using guessed type __int16 word_12;
// 14: using guessed type int dword_14;

//----- (0043E9EC) --------------------------------------------------------
void __fastcall CRadar::DrawBlips(float circleSize)
{
  float v1; // s16
  float v2; // s18
  bool v3; // zf
  int v4; // r0
  float v5; // s2
  float v6; // s0
  float v7; // s8
  float v8; // s2
  float v9; // s0
  float v10; // s6
  bool8 v11; // r8
  unsigned __int8 i; // r9
  int v13; // r5
  int32 v14; // r6
  Int8 *p_nBlipSprite; // r10
  int v16; // r4
  unsigned int v17; // r0
  unsigned int v18; // r0
  int v19; // r0
  bool v20; // zf
  int v21; // r3
  bool8 v22; // r1
  int32 v23; // r0
  int v24; // r2
  int v25; // r4
  int32 v26; // r6
  _WORD *v27; // r5
  int v28; // r0
  bool v29; // zf
  float v30; // s2
  float v31; // s0
  float v32; // s6
  float v33; // s0
  float v34; // s2
  float v35; // s6
  float MAP_OFFSET_X; // s8
  float MAP_OFFSET_Y; // s4
  float v38; // s2
  float v39; // s0
  float left; // s4
  float right; // s8
  float top; // s6
  float bottom; // s10
  float v44; // s12
  Int32 v45; // r5
  CPlayerInfo *v46; // r8
  float v47; // s2
  float v48; // s0
  float v49; // s4
  float v50; // s0
  float v51; // s2
  float v52; // s4
  float v53; // s4
  float v54; // s8
  float v55; // s4
  float v56; // s2
  float v57; // s0
  float v58; // s4
  float v59; // s8
  float v60; // s6
  float v61; // s10
  float v62; // s12
  float PlayerHeading; // r6
  int Alpha; // [sp+2Ch] [bp-64h]
  CRGBA v66; // [sp+30h] [bp-60h] BYREF
  CRGBA colour; // [sp+34h] [bp-5Ch] BYREF
  CRGBA v68; // [sp+38h] [bp-58h] BYREF
  CVector v69; // [sp+3Ch] [bp-54h] BYREF

  Alpha = 255;
  v3 = gMobileMenu.screenStack.numEntries == 0;
  if ( !gMobileMenu.screenStack.numEntries )
    v3 = gMobileMenu.pendingScreen == 0;
  if ( v3 )
  {
    if ( CTouchInterface::m_pWidgets[161] )
      v4 = CTouchInterface::m_pWidgets[161]->m_Color._anon_0._anon_0.alpha;
    else
      v4 = 255;
    Alpha = v4;
  }
  CRadar::SetupAirstripBlips();
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
  if ( gMobileMenu.DisplayingMap )
  {
    v2 = gMobileMenu.MAP_OFFSET_Y - (float)(gMobileMenu.NEW_MAP_SCALE * 0.0);
    v1 = gMobileMenu.MAP_OFFSET_X + (float)(gMobileMenu.NEW_MAP_SCALE * 0.0);
  }
  else
  {
    if ( CTouchInterface::m_pWidgets[161] )
    {
      v1 = (float)((float)(CTouchInterface::m_pWidgets[161]->m_RectScreen.left
                         + CTouchInterface::m_pWidgets[161]->m_RectScreen.right)
                 * 0.5)
         + (float)((float)(fabsf(
                             CTouchInterface::m_pWidgets[161]->m_RectScreen.right
                           - CTouchInterface::m_pWidgets[161]->m_RectScreen.left)
                         * 0.0)
                 * 0.5);
      v2 = (float)((float)(CTouchInterface::m_pWidgets[161]->m_RectScreen.top
                         + CTouchInterface::m_pWidgets[161]->m_RectScreen.bottom)
                 * 0.5)
         - (float)((float)(fabsf(
                             CTouchInterface::m_pWidgets[161]->m_RectScreen.top
                           - CTouchInterface::m_pWidgets[161]->m_RectScreen.bottom)
                         * 0.0)
                 * 0.5);
    }
    v5 = (float)(1.0 / CRadar::m_radarRange)
       * (float)((float)(CRadar::vec2DRadarOrigin.x + 0.0) - CRadar::vec2DRadarOrigin.x);
    v6 = (float)(1.0 / CRadar::m_radarRange)
       * (float)((float)((float)(CRadar::m_radarRange * 1.4142) + CRadar::vec2DRadarOrigin.y)
               - CRadar::vec2DRadarOrigin.y);
    v7 = gTransformCos * v5;
    v8 = (float)(gTransformCos * v6) - (float)(gTransformSin * v5);
    v9 = v7 + (float)(gTransformSin * v6);
    v10 = sqrtf((float)(v9 * v9) + (float)(v8 * v8));
    if ( v10 > 1.0 )
    {
      v8 = v8 * (float)(1.0 / v10);
      v9 = v9 * (float)(1.0 / v10);
    }
    if ( CTouchInterface::m_pWidgets[161] )
    {
      v1 = (float)((float)(CTouchInterface::m_pWidgets[161]->m_RectScreen.left
                         + CTouchInterface::m_pWidgets[161]->m_RectScreen.right)
                 * 0.5)
         + (float)((float)(v9
                         * fabsf(
                             CTouchInterface::m_pWidgets[161]->m_RectScreen.right
                           - CTouchInterface::m_pWidgets[161]->m_RectScreen.left))
                 * 0.5);
      v2 = (float)((float)(CTouchInterface::m_pWidgets[161]->m_RectScreen.top
                         + CTouchInterface::m_pWidgets[161]->m_RectScreen.bottom)
                 * 0.5)
         - (float)((float)(v8
                         * fabsf(
                             CTouchInterface::m_pWidgets[161]->m_RectScreen.top
                           - CTouchInterface::m_pWidgets[161]->m_RectScreen.bottom))
                 * 0.5);
    }
    CRadar::DrawRadarSprite(4u, v1, v2, Alpha);
  }
  v11 = 1;
  while ( 2 )
  {
    for ( i = 1; i < 4u; ++i )
    {
      v13 = 0;
      v14 = 0;
      if ( i == 3 )
        v13 = 1;
      p_nBlipSprite = &CRadar::ms_RadarTrace[0].nBlipSprite;
      do
      {
        v17 = *(unsigned __int16 *)(p_nBlipSprite + 1);
        if ( (v17 & 2) != 0 )
        {
          v18 = (v17 >> 10) & 0xF;
          if ( v18 <= 8 )
          {
            v19 = 1 << v18;
            if ( (v19 & 0x8E) != 0 )
            {
              v25 = *p_nBlipSprite;
              if ( CGame::currArea == AREA_MAIN_MAP && !FindPlayerPed(-1)->m_areaCode )
              {
LABEL_46:
                v21 = LODWORD(circleSize);
                v24 = Alpha;
                v22 = v11;
                v23 = v14;
                goto LABEL_47;
              }
              switch ( v25 )
              {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 25:
                case 36:
                case 41:
                case 44:
                case 52:
                  goto LABEL_46;
                default:
                  break;
              }
            }
            else if ( (v19 & 0x30) != 0 )
            {
              v16 = *p_nBlipSprite;
              if ( v16 == 41 )
                goto LABEL_48;
              if ( (unsigned int)(v16 - 8) > 0x26 )
              {
                if ( v13 )
                  goto LABEL_48;
              }
              else if ( dword_618C50[v16 - 8] != v13 )
              {
                goto LABEL_48;
              }
              if ( CGame::currArea || FindPlayerPed(-1)->m_areaCode )
              {
                switch ( v16 )
                {
                  case 0:
                  case 1:
                  case 2:
                  case 3:
                  case 4:
                  case 25:
                  case 36:
                  case 41:
                  case 44:
                  case 52:
                    goto LABEL_31;
                  default:
                    break;
                }
              }
              else
              {
LABEL_31:
                CRadar::DrawCoordBlip(v14, v11, Alpha, circleSize);
              }
            }
            else if ( (v19 & 0x140) != 0 && i == 3 )
            {
              v20 = CTheScripts::bPlayerIsOffTheMap == 0;
              if ( CTheScripts::bPlayerIsOffTheMap )
                v20 = !gMobileMenu.DisplayingMap;
              if ( v20 )
              {
                v21 = -1082130432;
                v22 = v11;
                v23 = v14;
                v24 = Alpha;
LABEL_47:
                CRadar::DrawEntityBlip(v23, v22, v24, *(float *)&v21);
              }
            }
          }
        }
LABEL_48:
        ++v14;
        p_nBlipSprite += 40;
      }
      while ( v14 != 250 );
    }
    v26 = 0;
    v27 = (_WORD *)((char *)CRadar::ms_RadarTrace + 37);
    do
    {
      v28 = *v27 & 0x3802;
      v29 = v28 == 4098;
      if ( v28 == 4098 )
        v29 = *((_BYTE *)v27 - 1) == 41;
      if ( v29 )
      {
        if ( CGame::currArea == AREA_MAIN_MAP )
        {
          FindPlayerPed(-1);
LABEL_60:
          CRadar::DrawCoordBlip(v26, v11, Alpha, circleSize);
          goto LABEL_61;
        }
        if ( gMobileMenu.screenStack.numEntries || gMobileMenu.pendingScreen )
          goto LABEL_60;
      }
LABEL_61:
      ++v26;
      v27 += 20;
    }
    while ( v26 != 250 );
    v3 = v11 == 0;
    v11 = 0;
    if ( !v3 )
      continue;
    break;
  }
  if ( !gMobileMenu.DisplayingMap )
    goto LABEL_74;
  FindPlayerCentreOfWorldForMap(&v69, 0);
  v30 = (float)(v69.x - CRadar::vec2DRadarOrigin.x) * (float)(1.0 / CRadar::m_radarRange);
  v31 = (float)(v69.y - CRadar::vec2DRadarOrigin.y) * (float)(1.0 / CRadar::m_radarRange);
  v32 = gTransformSin * v31;
  v33 = (float)(gTransformCos * v31) - (float)(gTransformSin * v30);
  v34 = (float)(gTransformCos * v30) + v32;
  if ( !gMobileMenu.DisplayingMap )
  {
    v35 = sqrtf((float)(v34 * v34) + (float)(v33 * v33));
    if ( v35 > 1.0 )
    {
      v33 = v33 * (float)(1.0 / v35);
      v34 = v34 * (float)(1.0 / v35);
    }
  }
  if ( gMobileMenu.DisplayingMap )
  {
    MAP_OFFSET_X = gMobileMenu.MAP_OFFSET_X;
    MAP_OFFSET_Y = gMobileMenu.MAP_OFFSET_Y;
    v38 = v34 * gMobileMenu.NEW_MAP_SCALE;
    v39 = v33 * gMobileMenu.NEW_MAP_SCALE;
    goto LABEL_72;
  }
  if ( CTouchInterface::m_pWidgets[161] )
  {
    left = CTouchInterface::m_pWidgets[161]->m_RectScreen.left;
    right = CTouchInterface::m_pWidgets[161]->m_RectScreen.right;
    top = CTouchInterface::m_pWidgets[161]->m_RectScreen.top;
    bottom = CTouchInterface::m_pWidgets[161]->m_RectScreen.bottom;
    v44 = fabsf(right - left);
    MAP_OFFSET_X = (float)(left + right) * 0.5;
    MAP_OFFSET_Y = (float)(top + bottom) * 0.5;
    v38 = (float)(v34 * v44) * 0.5;
    v39 = (float)(v33 * fabsf(top - bottom)) * 0.5;
LABEL_72:
    v1 = MAP_OFFSET_X + v38;
    v2 = MAP_OFFSET_Y - v39;
  }
  CRadar::DrawYouAreHereSprite(v1, v2);
  if ( !gMobileMenu.DisplayingMap )
  {
LABEL_74:
    v45 = 0;
    v46 = CWorld::Players;
    while ( !FindPlayerPed(v45)
         || FindPlayerVehicle(v45, 0)
         && FindPlayerVehicle(v45, 0)->m_vehicleType == 4
         && FindPlayerVehicle(v45, 0)->m_nModelIndex != 539 )
    {
LABEL_93:
      ++v45;
      ++v46;
      if ( v45 == 2 )
        return;
    }
    FindPlayerCentreOfWorldForMap(&v69, 0);
    v47 = (float)(v69.x - CRadar::vec2DRadarOrigin.x) * (float)(1.0 / CRadar::m_radarRange);
    v48 = (float)(v69.y - CRadar::vec2DRadarOrigin.y) * (float)(1.0 / CRadar::m_radarRange);
    v49 = gTransformSin * v48;
    v50 = (float)(gTransformCos * v48) - (float)(gTransformSin * v47);
    v51 = (float)(gTransformCos * v47) + v49;
    if ( !gMobileMenu.DisplayingMap )
    {
      v52 = sqrtf((float)(v51 * v51) + (float)(v50 * v50));
      if ( v52 > 1.0 )
      {
        v53 = 1.0 / v52;
        v50 = v50 * v53;
        v51 = v51 * v53;
      }
    }
    if ( gMobileMenu.DisplayingMap )
    {
      v54 = gMobileMenu.MAP_OFFSET_X;
      v55 = gMobileMenu.MAP_OFFSET_Y;
      v56 = v51 * gMobileMenu.NEW_MAP_SCALE;
      v57 = v50 * gMobileMenu.NEW_MAP_SCALE;
      goto LABEL_86;
    }
    if ( CTouchInterface::m_pWidgets[161] )
    {
      v58 = CTouchInterface::m_pWidgets[161]->m_RectScreen.left;
      v59 = CTouchInterface::m_pWidgets[161]->m_RectScreen.right;
      v60 = CTouchInterface::m_pWidgets[161]->m_RectScreen.top;
      v61 = CTouchInterface::m_pWidgets[161]->m_RectScreen.bottom;
      v62 = fabsf(v59 - v58);
      v54 = (float)(v58 + v59) * 0.5;
      v55 = (float)(v60 + v61) * 0.5;
      v56 = (float)(v51 * v62) * 0.5;
      v57 = (float)(v50 * fabsf(v60 - v61)) * 0.5;
LABEL_86:
      v1 = v54 + v56;
      v2 = v55 - v57;
    }
    PlayerHeading = FindPlayerHeading(v45);
    if ( CPlayerPed::IsHidden(v46->pPed) )
      CRGBA::CRGBA(&v68, 0x32u, 0x32u, 0x50u, Alpha);
    else
      CRGBA::CRGBA(&v68, 0xFFu, 0xFFu, 0xFFu, Alpha);
    if ( TheCamera.Cams[TheCamera.ActiveCam].Mode == 1 )
    {
      colour = v68;
      CRadar::DrawRotatingRadarSprite(&CRadar::RadarBlipSprites[2], v1, v2, PlayerHeading + 3.1416, 1.0, (CRGBA)&colour);
    }
    else
    {
      v66 = v68;
      CRadar::DrawRotatingRadarSprite(
        &CRadar::RadarBlipSprites[2],
        v1,
        v2,
        PlayerHeading - (float)(gTransformHeading + 3.1416),
        1.0,
        (CRGBA)&v66);
    }
    goto LABEL_93;
  }
}
// 43EBF6: variable 'v1' is possibly undefined
// 43EBF6: variable 'v2' is possibly undefined
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;
// 54: using guessed type int dword_54;
// 618C50: using guessed type _DWORD dword_618C50[40];

//----- (0043F2B0) --------------------------------------------------------
void CRadar::SetupAirstripBlips()
{
  sRadarTrace *v0; // r0
  _WORD *v1; // r0
  __int16 v2; // r1
  __int16 v3; // t1
  sRadarTrace *v4; // r2
  int v5; // r5
  float *p_pos_y; // r4
  float v7; // s16
  CVehicle *PlayerVehicle; // r0
  CMatrix *m_pMat; // r1
  float v10; // s18
  float *p_tx; // r2
  float v12; // s20
  CVehicle *v13; // r0
  CMatrix *v14; // r1
  float v15; // s22
  float *p_x; // r2
  float v17; // s24
  CVehicle *v18; // r0
  CMatrix *v19; // r1
  float v20; // s26
  CSimpleTransform *p_m_transform; // r2
  float y; // s28
  CVehicle *v23; // r0
  CMatrix *v24; // r1
  CSimpleTransform *v25; // r2
  float *v26; // r0
  uint8 v27; // r0
  int32 v28; // r1
  bool v29; // zf
  sRadarTrace *v30; // r1
  _WORD *v31; // r1
  __int16 v32; // r2
  __int16 v33; // t1
  sRadarTrace *v34; // r3
  float pos_x; // r2
  Int16 *v36; // r0
  float pos_y; // r3
  unsigned int v38; // r1
  __int16 v39; // r6
  int v40; // r2
  unsigned int v41; // r3
  int v42; // r0
  float v43; // [sp+0h] [bp-58h] BYREF
  float v44; // [sp+4h] [bp-54h]
  float v45; // [sp+8h] [bp-50h]
  float v46; // [sp+Ch] [bp-4Ch]

  if ( FindPlayerVehicle(-1, 0)
    && FindPlayerVehicle(-1, 0)->m_vehicleType == 4
    && FindPlayerVehicle(-1, 0)->m_nModelIndex != 539 )
  {
    if ( (CTimer::m_FrameCounter & 4) != 0 )
    {
      v5 = 0;
      p_pos_y = &airstrip_table[0].pos_y;
      do
      {
        v7 = *(p_pos_y - 1);
        PlayerVehicle = FindPlayerVehicle(-1, 0);
        m_pMat = PlayerVehicle->m_pMat;
        v10 = *(p_pos_y - 1);
        p_tx = &m_pMat->tx;
        if ( !m_pMat )
          p_tx = &PlayerVehicle->m_transform.m_translate.x;
        v12 = *p_tx;
        v13 = FindPlayerVehicle(-1, 0);
        v14 = v13->m_pMat;
        v15 = *p_pos_y;
        p_x = &v14->tx;
        if ( !v14 )
          p_x = &v13->m_transform.m_translate.x;
        v17 = *p_x;
        v18 = FindPlayerVehicle(-1, 0);
        v19 = v18->m_pMat;
        v20 = *p_pos_y;
        p_m_transform = (CSimpleTransform *)&v19->tx;
        if ( !v19 )
          p_m_transform = &v18->m_transform;
        y = p_m_transform->m_translate.y;
        v23 = FindPlayerVehicle(-1, 0);
        v24 = v23->m_pMat;
        p_pos_y += 4;
        v25 = (CSimpleTransform *)&v24->tx;
        if ( !v24 )
          v25 = &v23->m_transform;
        v26 = (float *)((char *)&v43 + v5);
        v5 += 4;
        *v26 = sqrtf(
                 (float)((float)(v7 - v12) * (float)(v10 - v17))
               + (float)((float)(v15 - y) * (float)(v20 - v25->m_translate.y)));
      }
      while ( v5 != 16 );
      if ( v43 >= v44 || v43 >= v45 || v43 >= v46 )
      {
        if ( v44 >= v43 || v44 >= v45 )
        {
          if ( v45 >= v43 || v45 >= v44 )
            v27 = 3;
          else
            v27 = 2;
        }
        else
        {
          v27 = 1;
        }
      }
      else
      {
        v27 = 0;
      }
      v28 = CRadar::airstrip_blip;
      v29 = CRadar::airstrip_location == v27;
      if ( CRadar::airstrip_location != v27 )
        v29 = CRadar::airstrip_blip == 0;
      if ( !v29 )
      {
        if ( CRadar::airstrip_blip != -1
          && CRadar::ms_RadarTrace[(unsigned __int16)CRadar::airstrip_blip].ReferenceIndex == HIWORD(CRadar::airstrip_blip)
          && (unsigned __int16)CRadar::airstrip_blip <= 0xF9u )
        {
          v30 = &CRadar::ms_RadarTrace[(unsigned __int16)CRadar::airstrip_blip];
          v33 = *(_WORD *)((char *)v30 + 37);
          v31 = (_WORD *)((char *)v30 + 37);
          v32 = v33;
          if ( (v33 & 2) != 0 )
          {
            v34 = &CRadar::ms_RadarTrace[(unsigned __int16)CRadar::airstrip_blip];
            v34->nBlipScale = 1;
            v34->fBlipMarkerScale = 1.0;
            v34->pEntryExit = 0;
            v34->nBlipSprite = 0;
            *v31 = v32 & 0xC000 | 1;
          }
        }
        CRadar::airstrip_location = v27;
        v28 = 0;
        CRadar::airstrip_blip = 0;
      }
      if ( v28 )
        return;
    }
    else if ( CRadar::airstrip_blip )
    {
      return;
    }
    pos_x = airstrip_table[CRadar::airstrip_location].pos_x;
    v36 = &CRadar::MapLegendList[244];
    pos_y = airstrip_table[CRadar::airstrip_location].pos_y;
    v38 = -1;
    do
    {
      v39 = *(Int16 *)((char *)v36 + 77);
      ++v38;
      v36 += 20;
    }
    while ( v38 <= 0xF9 && (v39 & 2) != 0 );
    if ( v38 > 0xF9 )
    {
      v42 = -1;
    }
    else
    {
      *((_DWORD *)v36 + 6) = 1065353216;
      *(_DWORD *)v36 = 8;
      *((_DWORD *)v36 + 1) = 0;
      *((float *)v36 + 2) = pos_x;
      *((float *)v36 + 3) = pos_y;
      *((_DWORD *)v36 + 4) = 0;
      v40 = 1;
      v36[14] = 1;
      *((_BYTE *)v36 + 36) = 0;
      *((_DWORD *)v36 + 8) = 0;
      v41 = (unsigned __int16)v36[10];
      *(Int16 *)((char *)v36 + 37) = v39 & 0xC000 | 0x2203;
      if ( v41 < 0xFFFE )
        v40 = v41 + 1;
      v36[10] = v40;
      v42 = v38 | (v40 << 16);
    }
    CRadar::airstrip_blip = v42;
    return;
  }
  if ( CRadar::airstrip_blip != -1 )
  {
    if ( !CRadar::airstrip_blip )
      return;
    if ( CRadar::ms_RadarTrace[(unsigned __int16)CRadar::airstrip_blip].ReferenceIndex == HIWORD(CRadar::airstrip_blip)
      && (unsigned __int16)CRadar::airstrip_blip <= 0xF9u )
    {
      v0 = &CRadar::ms_RadarTrace[(unsigned __int16)CRadar::airstrip_blip];
      v3 = *(_WORD *)((char *)v0 + 37);
      v1 = (_WORD *)((char *)v0 + 37);
      v2 = v3;
      if ( (v3 & 2) != 0 )
      {
        v4 = &CRadar::ms_RadarTrace[(unsigned __int16)CRadar::airstrip_blip];
        v4->nBlipScale = 1;
        v4->fBlipMarkerScale = 1.0;
        v4->pEntryExit = 0;
        v4->nBlipSprite = 0;
        *v1 = v2 & 0xC000 | 1;
      }
    }
  }
  CRadar::airstrip_blip = 0;
}

//----- (0043F62C) --------------------------------------------------------
void __fastcall CRadar::TransformRadarPointToScreenSpace(CVector2D *screenPt, const CVector2D *radarPt)
{
  float MAP_OFFSET_Y; // s0
  float v3; // s2
  CWidget *v4; // r2
  float top; // s0
  float bottom; // s2
  float v7; // s4

  if ( gMobileMenu.DisplayingMap )
  {
    screenPt->x = gMobileMenu.MAP_OFFSET_X + (float)(radarPt->x * gMobileMenu.NEW_MAP_SCALE);
    MAP_OFFSET_Y = gMobileMenu.MAP_OFFSET_Y;
    v3 = radarPt->y * gMobileMenu.NEW_MAP_SCALE;
  }
  else
  {
    v4 = CTouchInterface::m_pWidgets[161];
    if ( !CTouchInterface::m_pWidgets[161] )
      return;
    screenPt->x = (float)((float)(CTouchInterface::m_pWidgets[161]->m_RectScreen.left
                                + CTouchInterface::m_pWidgets[161]->m_RectScreen.right)
                        * 0.5)
                + (float)((float)(radarPt->x
                                * fabsf(
                                    CTouchInterface::m_pWidgets[161]->m_RectScreen.right
                                  - CTouchInterface::m_pWidgets[161]->m_RectScreen.left))
                        * 0.5);
    top = v4->m_RectScreen.top;
    bottom = v4->m_RectScreen.bottom;
    v7 = fabsf(top - bottom);
    MAP_OFFSET_Y = (float)(top + bottom) * 0.5;
    v3 = (float)(radarPt->y * v7) * 0.5;
  }
  screenPt->y = MAP_OFFSET_Y - v3;
}

//----- (0043F6E4) --------------------------------------------------------
void __fastcall CRadar::TransformRealWorldPointToRadarSpace(CVector2D *radarPt, const CVector2D *worldPt)
{
  float v2; // s2
  float v3; // s0
  float v4; // s4

  v2 = (float)(worldPt->x - CRadar::vec2DRadarOrigin.x) * (float)(1.0 / CRadar::m_radarRange);
  v3 = (float)(worldPt->y - CRadar::vec2DRadarOrigin.y) * (float)(1.0 / CRadar::m_radarRange);
  v4 = (float)(v3 * gTransformCos) - (float)(gTransformSin * v2);
  radarPt->x = (float)(gTransformCos * v2) + (float)(gTransformSin * v3);
  radarPt->y = v4;
}

//----- (0043F760) --------------------------------------------------------
float __fastcall CRadar::LimitRadarPoint(CVector2D *radarPt)
{
  float x; // s0
  float y; // s4
  float v3; // s2

  x = radarPt->x;
  y = radarPt->y;
  v3 = sqrtf((float)(x * x) + (float)(y * y));
  if ( !gMobileMenu.DisplayingMap && v3 > 1.0 )
  {
    radarPt->x = x * (float)(1.0 / v3);
    radarPt->y = (float)(1.0 / v3) * y;
  }
  return v3;
}

//----- (0043F7B4) --------------------------------------------------------
void __fastcall CRadar::DrawRadarSprite(UInt16 SpriteID, float fXPos, float fYPos, UInt8 Alpha)
{
  float32x2_t v4; // d1
  float32x2_t v5; // d2
  float32x2_t v6; // d3
  float32x2_t v7; // d8
  float32x2_t v8; // d10
  int v9; // r4
  float v10; // s18
  float v12; // s0
  bool v13; // zf
  float NEW_MAP_SCALE; // s0
  float v15; // s0
  CWidget *v16; // r6
  float v17; // s0
  int v18; // r1
  int v19; // r3
  int v20; // r6
  UInt16 v21; // r3
  CRGBA v22; // [sp+4h] [bp-44h] BYREF
  CRect Rectangle; // [sp+8h] [bp-40h] BYREF

  v9 = SpriteID;
  v10 = fYPos;
  v7.n64_f32[0] = fXPos;
  if ( gMobileMenu.DisplayingMap )
  {
    v12 = (float)RsGlobal.screenHeight / 448.0;
    v8.n64_f32[0] = v12 * fYPos;
    v7.n64_f32[0] = v12 * fXPos;
    if ( CHID::GetInputType() == 1 )
    {
      v10 = v12 * v10;
    }
    else
    {
      v13 = gMobileMenu.screenStack.numEntries == 0;
      if ( !gMobileMenu.screenStack.numEntries )
        v13 = gMobileMenu.pendingScreen == 0;
      if ( v13 )
        NEW_MAP_SCALE = 140.0;
      else
        NEW_MAP_SCALE = (float)(int)gMobileMenu.NEW_MAP_SCALE;
      v5.n64_f32[0] = (float)RsGlobal.screenHeight / 448.0;
      v4.n64_f32[0] = (float)RsGlobal.screenWidth / 640.0;
      v10 = (float)(NEW_MAP_SCALE + gMobileMenu.MAP_OFFSET_Y) * v5.n64_f32[0];
      v5.n64_f32[0] = (float)(gMobileMenu.MAP_OFFSET_Y - NEW_MAP_SCALE) * v5.n64_f32[0];
      v6.n64_f32[0] = (float)(gMobileMenu.MAP_OFFSET_X - NEW_MAP_SCALE) * v4.n64_f32[0];
      v4.n64_f32[0] = (float)(NEW_MAP_SCALE + gMobileMenu.MAP_OFFSET_X) * v4.n64_f32[0];
      v15 = vmax_f32(v8, v5).n64_f32[0];
      v7.n64_u32[0] = vmin_f32(vmax_f32(v7, v6), v4).n64_u32[0];
      if ( v15 <= v10 )
        v10 = v15;
    }
  }
  v16 = CTouchInterface::m_pWidgets[161];
  if ( CTouchInterface::m_pWidgets[161] )
  {
    if ( CGame::currArea || FindPlayerPed(-1)->m_areaCode )
    {
      switch ( v9 )
      {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 25:
        case 36:
        case 41:
        case 44:
        case 52:
          goto LABEL_15;
        default:
          return;
      }
    }
    else
    {
LABEL_15:
      v17 = fabsf(v16->m_RectScreen.right - v16->m_RectScreen.left) * 0.1;
      Rectangle.bottom = v10 - v17;
      Rectangle.left = v7.n64_f32[0] - v17;
      Rectangle.right = v7.n64_f32[0] + v17;
      Rectangle.top = v10 + v17;
      CRGBA::CRGBA(&v22, 0xFFu, 0xFFu, 0xFFu, Alpha);
      CSprite2d::Draw(&CRadar::RadarBlipSprites[v9], &Rectangle, &v22);
      if ( gMobileMenu.DisplayingMap )
      {
        v18 = 0;
        v19 = 0;
        do
        {
          v20 = CRadar::MapLegendList[v18++];
          if ( (char)v9 == v20 )
            v19 = 1;
        }
        while ( v18 != 250 );
        if ( !(v19 << 24) )
        {
          v21 = CRadar::MapLegendCounter;
          CRadar::MapLegendList[CRadar::MapLegendCounter] = (char)v9;
          CRadar::MapLegendCounter = v21 + 1;
        }
      }
    }
  }
}
// 43F884: variable 'v8' is possibly undefined
// 43F884: variable 'v5' is possibly undefined
// 43F888: variable 'v7' is possibly undefined
// 43F888: variable 'v6' is possibly undefined
// 43F894: variable 'v4' is possibly undefined

//----- (0043F9F8) --------------------------------------------------------
bool8 __fastcall CRadar::DisplayThisBlip(int32 nIndex, int8 force)
{
  bool8 result; // r0

  if ( CGame::currArea == AREA_MAIN_MAP && !FindPlayerPed(-1)->m_areaCode )
    return 1;
  result = 1;
  switch ( nIndex )
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 25:
    case 36:
    case 41:
    case 44:
    case 52:
      return result;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (0043FA68) --------------------------------------------------------
void __fastcall CRadar::DrawCoordBlip(int32 BlipIndex, bool8 bDrawSpriteBlip, int nWidgetAlpha, float circleSize)
{
  float32x2_t v4; // d3
  float32x2_t v5; // d5
  float v6; // s16
  float v7; // s18
  int32 v8; // r10
  int32 v9; // r4
  int v10; // r11
  sRadarTrace *v11; // r5
  unsigned __int16 *v12; // r5
  __int16 v13; // t1
  uint8 v14; // r1
  bool v15; // zf
  int v16; // r0
  sRadarTrace *v17; // r6
  float v18; // s0
  int v19; // r1
  sRadarTrace *v20; // r8
  Int8 *p_nBlipSprite; // r8
  int nBlipSprite; // t1
  UInt32 B; // r9
  unsigned int v24; // r0
  sRadarTrace *v25; // r0
  RwReal z; // r1
  __int64 v27; // d16
  CEntryExit *pEntryExit; // r0
  float v29; // s4
  float v30; // s2
  float v31; // s6
  float v32; // s2
  float v33; // s4
  float v34; // s8
  unsigned int v35; // r6
  float v36; // s6
  __int16 v37; // r1
  float MAP_OFFSET_X; // s12
  float MAP_OFFSET_Y; // s8
  float v40; // s4
  float v41; // s2
  float left; // s8
  float right; // s12
  float top; // s10
  float bottom; // s14
  float v46; // s1
  Int8 v47; // r5
  int v48; // r1
  bool v49; // zf
  float v50; // s22
  unsigned __int8 v51; // r5
  float v52; // s2
  float v53; // s4
  float v54; // s0
  float v55; // s2
  UInt8 v57; // [sp+14h] [bp-74h]
  CRGBA v58; // [sp+18h] [bp-70h] BYREF
  CRect Rectangle; // [sp+1Ch] [bp-6Ch] BYREF
  CVector v60; // [sp+2Ch] [bp-5Ch] BYREF
  CVector posn; // [sp+38h] [bp-50h] BYREF

  v8 = BlipIndex;
  v9 = BlipIndex;
  v57 = nWidgetAlpha;
  v10 = bDrawSpriteBlip;
  v11 = &CRadar::ms_RadarTrace[BlipIndex];
  v13 = *(_WORD *)((char *)v11 + 37);
  v12 = (unsigned __int16 *)((char *)v11 + 37);
  LOBYTE(BlipIndex) = v13;
  if ( (v13 & 0x3C00) == 5120 )
  {
    if ( CTheScripts::IsPlayerOnAMission() )
      return;
    LOWORD(BlipIndex) = *v12;
  }
  if ( (unsigned __int8)BlipIndex >> 6 )
  {
    v14 = 0;
    v15 = (unsigned __int8)BlipIndex >> 6 == 1;
LABEL_6:
    if ( v15 )
      v14 = 14;
LABEL_20:
    B = CHudColours::GetIntColour(&HudColour, v14);
    v24 = *v12;
  }
  else
  {
    B = CRadar::ms_RadarTrace[v9].nColour;
    v24 = BlipIndex & 1;
    v14 = 12;
    switch ( B )
    {
      case 0u:
      case 5u:
        v14 = 0;
        if ( !v24 )
          v14 = 10;
        goto LABEL_20;
      case 1u:
        v14 = 1;
        if ( !v24 )
          v14 = 11;
        goto LABEL_20;
      case 2u:
      case 6u:
        v14 = 3;
        v15 = v24 == 0;
        goto LABEL_6;
      case 3u:
        v14 = ((4 * v24) ^ 4) + 5;
        goto LABEL_20;
      case 4u:
        v14 = 12;
        if ( !v24 )
          v14 = 7;
        goto LABEL_20;
      case 7u:
        v14 = 0;
        goto LABEL_20;
      case 8u:
        goto LABEL_20;
      default:
        break;
    }
  }
  v16 = (v24 >> 8) & 3;
  if ( v16 == 3 || v16 == 1 )
  {
    if ( CTheScripts::DbgFlag )
    {
      v17 = &CRadar::ms_RadarTrace[v9];
      CRadar::ShowRadarMarker(v17->position, B, v17->fBlipMarkerScale);
      v18 = v17->fBlipMarkerScale + -0.1;
      v17->fBlipMarkerScale = v18;
      if ( v18 < 1.0 )
        v17->fBlipMarkerScale = 5.0;
    }
  }
  v19 = 0;
  v20 = &CRadar::ms_RadarTrace[v9];
  nBlipSprite = (unsigned __int8)v20->nBlipSprite;
  p_nBlipSprite = &v20->nBlipSprite;
  if ( !nBlipSprite )
    v19 = 1;
  if ( v10 == v19 || (*((_BYTE *)v12 + 1) & 2) == 0 )
    return;
  v25 = &CRadar::ms_RadarTrace[v9];
  z = v25->position.z;
  v27 = *(_QWORD *)&v25->position.x;
  pEntryExit = v25->pEntryExit;
  posn.z = z;
  *(_QWORD *)&posn.x = v27;
  if ( pEntryExit )
    CEntryExit::GetPositionRelativeToOutsideWorld(pEntryExit, &posn);
  v29 = (float)(posn.x - CRadar::vec2DRadarOrigin.x) * (float)(1.0 / CRadar::m_radarRange);
  v30 = (float)(posn.y - CRadar::vec2DRadarOrigin.y) * (float)(1.0 / CRadar::m_radarRange);
  v31 = gTransformSin * v30;
  v32 = (float)(gTransformCos * v30) - (float)(gTransformSin * v29);
  v33 = (float)(gTransformCos * v29) + v31;
  v34 = sqrtf((float)(v33 * v33) + (float)(v32 * v32));
  if ( !gMobileMenu.DisplayingMap && v34 > 1.0 )
  {
    v32 = v32 * (float)(1.0 / v34);
    v33 = v33 * (float)(1.0 / v34);
  }
  LOBYTE(v35) = -1;
  if ( v34 < 6.0 && !gMobileMenu.DisplayingMap )
  {
    v5.n64_u32[0] = 1116471296;
    v4.n64_f32[0] = (float)(255 - (unsigned int)(float)((float)(v34 / 6.0) * 255.0));
    v35 = (unsigned int)vmax_f32(v4, v5).n64_f32[0];
  }
  v36 = 255.0;
  if ( !CTheScripts::RadarZoomValue )
    v36 = v34;
  v37 = *v12;
  if ( (*v12 & 0x20) == 0 )
    LOBYTE(v35) = B;
  if ( gMobileMenu.DisplayingMap )
  {
    MAP_OFFSET_X = gMobileMenu.MAP_OFFSET_X;
    MAP_OFFSET_Y = gMobileMenu.MAP_OFFSET_Y;
    v40 = v33 * gMobileMenu.NEW_MAP_SCALE;
    v41 = v32 * gMobileMenu.NEW_MAP_SCALE;
LABEL_40:
    v6 = MAP_OFFSET_X + v40;
    v7 = MAP_OFFSET_Y - v41;
    goto LABEL_41;
  }
  if ( CTouchInterface::m_pWidgets[161] )
  {
    left = CTouchInterface::m_pWidgets[161]->m_RectScreen.left;
    right = CTouchInterface::m_pWidgets[161]->m_RectScreen.right;
    top = CTouchInterface::m_pWidgets[161]->m_RectScreen.top;
    bottom = CTouchInterface::m_pWidgets[161]->m_RectScreen.bottom;
    v46 = fabsf(right - left);
    MAP_OFFSET_X = (float)(left + right) * 0.5;
    MAP_OFFSET_Y = (float)(top + bottom) * 0.5;
    v40 = (float)(v33 * v46) * 0.5;
    v41 = (float)(v32 * fabsf(top - bottom)) * 0.5;
    goto LABEL_40;
  }
LABEL_41:
  v47 = *p_nBlipSprite;
  if ( v10 )
  {
    if ( *p_nBlipSprite )
    {
      v48 = v37 & 4;
      if ( gMobileMenu.DisplayingMap || v36 <= 1.0 || !v48 )
      {
        v49 = !gMobileMenu.DisplayingMap;
        if ( gMobileMenu.DisplayingMap )
          v49 = v48 == 0;
        if ( !v49 && CTheZones::ZonesRevealed <= 0x4F )
        {
          if ( !CTheZones::GetCurrentZoneLockedOrUnlocked(
                  CRadar::ms_RadarTrace[v9].position.x,
                  CRadar::ms_RadarTrace[v9].position.y) )
            return;
          v47 = *p_nBlipSprite;
        }
        CRadar::DrawRadarSprite(v47, v6, v7, v57);
      }
    }
  }
  else if ( !*p_nBlipSprite )
  {
    v50 = posn.z;
    v51 = 0;
    FindPlayerCentreOfWorldForMap(&v60, 0);
    if ( v60.z >= (float)(v50 + -2.0) )
    {
      v51 = 2;
      if ( v60.z > (float)(v50 + 4.0) )
        v51 = 1;
    }
    if ( circleSize > 0.0 )
    {
      v52 = (float)RsGlobal.screenHeight / 448.0;
      v53 = v7 * v52;
      v54 = (float)((float)RsGlobal.screenHeight / 25.0) * circleSize;
      v55 = v6 * v52;
      Rectangle.bottom = v53 + v54;
      Rectangle.left = v55 - v54;
      Rectangle.right = v55 + v54;
      Rectangle.top = v53 - v54;
      CRGBA::CRGBA(&v58, 0xFFu, 0, 0, 0x64u);
      CSprite2d::Draw(&circleTex, &Rectangle, &v58);
    }
    CRadar::ShowRadarTraceWithHeight(
      v6,
      v7,
      CRadar::ms_RadarTrace[v9].nBlipScale,
      HIBYTE(B),
      BYTE2(B),
      BYTE1(B),
      (unsigned __int8)v35,
      v51);
    CRadar::AddBlipToLegendList(1u, v8);
  }
}
// 43FC8A: variable 'v4' is possibly undefined
// 43FC8A: variable 'v5' is possibly undefined
// 43FD94: variable 'v6' is possibly undefined
// 43FD94: variable 'v7' is possibly undefined

//----- (0043FF24) --------------------------------------------------------
void __fastcall CRadar::DrawEntityBlip(int32 BlipIndex, bool8 bDrawSpriteBlip, int nWidgetAlpha, float circleSize)
{
  float v4; // s16
  float v5; // s18
  float v6; // s20
  int32 v7; // r11
  sRadarTrace *v8; // r8
  CPickup *v9; // r1
  _WORD *v10; // r8
  unsigned int v11; // t1
  script_searchlight_struct *v12; // r9
  uint8 *v13; // r5
  int32 PoolIndex; // r1
  int v15; // r3
  unsigned int v16; // r1
  CVehiclePool *v17; // r0
  int v18; // r2
  int32 v19; // r0
  int v20; // r3
  unsigned int v21; // r0
  int32 v22; // r1
  int v23; // r3
  int32 ActualScriptThingIndex; // r0
  int32 ActualPickupIndex; // r0
  float pos_x; // s16
  CVehicle *PlayerVehicle; // r0
  CMatrix *m_pMat; // r2
  float *p_tx; // r3
  CVehicle *v30; // r0
  CMatrix *v31; // r2
  float *p_x; // r3
  float pos_y; // s22
  float v34; // s24
  CVehicle *v35; // r0
  CMatrix *v36; // r2
  CSimpleTransform *p_m_transform; // r3
  float v38; // s26
  float y; // s28
  CVehicle *v40; // r0
  CMatrix *v41; // r1
  CSimpleTransform *v42; // r2
  char v43; // r0
  char v44; // r0
  int v45; // r9
  sRadarTrace *v46; // r0
  __int64 v47; // d16
  float v48; // r6
  float v49; // r5
  float v50; // r0
  float v51; // s0
  float v52; // s0
  float v53; // s0
  int v54; // r0
  float v55; // s6
  float length; // s4
  int v57; // r10
  bool v58; // zf
  int v59; // r0
  uint8 *v60; // r1
  __int64 v61; // d16
  CEntryExit *v62; // r0
  __int64 v63; // d16
  int CoorsX; // s4
  RwReal v65; // s0
  unsigned int v66; // r0
  UInt32 B; // r6
  int v68; // r1
  int v69; // r0
  sRadarTrace *v70; // r4
  float v71; // s0
  CEntryExit *pEntryExit; // r0
  float v73; // s2
  float v74; // s0
  float v75; // s26
  float v76; // s24
  float v77; // s0
  float MAP_OFFSET_Y; // s2
  float v79; // s4
  float left; // s2
  float right; // s6
  float top; // s4
  float v83; // s10
  float bottom; // s8
  float v85; // s2
  float v86; // s6
  float v87; // s10
  unsigned int v88; // r0
  sRadarTrace *v89; // r5
  int v90; // r0
  Int8 *p_nBlipSprite; // r5
  int nBlipSprite; // t1
  float v93; // s16
  float v94; // s22
  float Radius; // s24
  float v96; // s26
  float v97; // s16
  float screenWidth; // s20
  int v99; // r0
  float v100; // s16
  int v101; // r4
  int v102; // r5
  float v103; // s22
  unsigned __int8 v104; // r5
  float v105; // s2
  float v106; // s4
  float v107; // s0
  float v108; // s2
  _BOOL4 DisplayingMap; // r0
  CRGBA v110; // r0
  float v111; // s2
  float v112; // s0
  float v113; // s24
  float v114; // s16
  float v115; // s0
  float v116; // s0
  float v117; // s16
  float dir; // s22
  CRGBA v119; // r0
  int v120; // r5
  float NEW_MAP_SCALE; // s18
  float MAP_OFFSET_X; // s20
  float v123; // s22
  float v124; // s26
  CRGBA v125; // r0
  float v126; // s0
  int v127; // r1
  int v128; // r3
  int v129; // r6
  UInt16 v130; // r3
  float z; // s22
  float v132; // r0
  float v133; // r1
  int h; // r3
  CRGBA v135; // r0
  float v136; // r1
  float v137; // r2
  float v138; // s0
  float v139; // s22
  int v140; // [sp+14h] [bp-B4h]
  int v141; // [sp+18h] [bp-B0h]
  UInt8 alpha; // [sp+24h] [bp-A4h]
  int v145; // [sp+28h] [bp-A0h]
  CRGBA v146; // [sp+2Ch] [bp-9Ch] BYREF
  CRect CenterOfCircle; // [sp+30h] [bp-98h] BYREF
  CVector v148; // [sp+40h] [bp-88h] BYREF
  CRGBA v149; // [sp+4Ch] [bp-7Ch] BYREF
  CRGBA v150; // [sp+50h] [bp-78h] BYREF
  CRGBA v151; // [sp+54h] [bp-74h] BYREF
  CRGBA v152; // [sp+58h] [bp-70h] BYREF
  CRGBA v153; // [sp+5Ch] [bp-6Ch] BYREF
  CVector posn; // [sp+60h] [bp-68h] BYREF

  alpha = nWidgetAlpha;
  v7 = BlipIndex;
  v145 = bDrawSpriteBlip;
  v8 = &CRadar::ms_RadarTrace[BlipIndex];
  v9 = 0;
  v11 = *(unsigned __int16 *)((char *)v8 + 37);
  v10 = (_WORD *)((char *)v8 + 37);
  v12 = 0;
  v13 = 0;
  switch ( (v11 >> 10) & 0xF )
  {
    case 1u:
      PoolIndex = CRadar::ms_RadarTrace[BlipIndex].PoolIndex;
      if ( PoolIndex < 0 )
        goto LABEL_14;
      v15 = (unsigned __int8)PoolIndex;
      v16 = (unsigned int)PoolIndex >> 8;
      v17 = CPools::ms_pVehiclePool;
      if ( CPools::ms_pVehiclePool->m_aFlags[v16] != v15 )
        goto LABEL_14;
      v18 = 2604;
      goto LABEL_13;
    case 2u:
      v19 = CRadar::ms_RadarTrace[BlipIndex].PoolIndex;
      if ( v19 >= 0
        && (v20 = (unsigned __int8)v19, v21 = (unsigned int)v19 >> 8, CPools::ms_pPedPool->m_aFlags[v21] == v20)
        && (v13 = CPools::ms_pPedPool->m_aStorage[v21]) != 0 )
      {
        if ( v13[1157] << 31 )
          v13 = *(uint8 **)&CPools::ms_pPedPool->m_aStorage[v21][1424];
LABEL_15:
        v9 = 0;
        v12 = 0;
      }
      else
      {
        v9 = 0;
LABEL_48:
        v12 = 0;
LABEL_49:
        v13 = 0;
      }
LABEL_50:
      v57 = (int)v12;
      if ( v12 )
        v57 = 1;
      v58 = v9 == 0;
      if ( !v9 )
        v58 = v12 == 0;
      if ( v58 && !v13 )
        return;
      if ( v13 )
      {
        v59 = *((_DWORD *)v13 + 5);
        v60 = (uint8 *)(v59 + 48);
        if ( !v59 )
          v60 = v13 + 4;
        v61 = *(_QWORD *)v60;
        posn.z = *((RwReal *)v60 + 2);
        *(_QWORD *)&posn.x = v61;
        if ( (v13[58] & 7) == 3 )
        {
          v62 = (CEntryExit *)*((_DWORD *)v13 + 485);
          if ( v62 )
            CEntryExit::GetPositionRelativeToOutsideWorld(v62, &posn);
        }
        v140 = 1;
        v141 = 0;
      }
      else
      {
        if ( v12 )
        {
          v57 = 1;
          v63 = *(_QWORD *)&v12->SearchLightPointAt.x;
          v13 = 0;
          posn.z = v12->SearchLightPointAt.z;
          v141 = 0;
          *(_QWORD *)&posn.x = v63;
        }
        else
        {
          v13 = 0;
          v12 = 0;
          CoorsX = v9->CoorsX;
          v141 = 0;
          v65 = (float)v9->CoorsZ * 0.125;
          posn.y = (float)v9->CoorsY * 0.125;
          posn.x = (float)CoorsX * 0.125;
          posn.z = v65;
LABEL_69:
          v57 = 0;
        }
        v140 = 0;
      }
      v66 = (unsigned __int16)*v10;
      B = CRadar::ms_RadarTrace[v7].nColour;
      LOBYTE(v68) = 12;
      switch ( B )
      {
        case 0u:
        case 5u:
          LOBYTE(v68) = 0;
          if ( (v66 & 1) == 0 )
            LOBYTE(v68) = 10;
          goto LABEL_86;
        case 1u:
          LOBYTE(v68) = 1;
          if ( (v66 & 1) == 0 )
            LOBYTE(v68) = 11;
          goto LABEL_86;
        case 2u:
        case 6u:
          LOBYTE(v68) = 3;
          if ( (v66 & 1) == 0 )
            LOBYTE(v68) = 14;
          goto LABEL_86;
        case 3u:
          LOBYTE(v68) = ((4 * (v66 & 1)) ^ 4) + 5;
          goto LABEL_86;
        case 4u:
          LOBYTE(v68) = 12;
          if ( (v66 & 1) == 0 )
            LOBYTE(v68) = 7;
          goto LABEL_86;
        case 7u:
          v68 = ((int)(v66 << 28) >> 31) & 0xE;
          goto LABEL_86;
        case 8u:
LABEL_86:
          B = CHudColours::GetIntColour(&HudColour, v68);
          v66 = (unsigned __int16)*v10;
          break;
        default:
          break;
      }
      v69 = (v66 >> 8) & 3;
      if ( v69 == 3 || v69 == 1 )
      {
        if ( CTheScripts::DbgFlag )
        {
          v70 = &CRadar::ms_RadarTrace[v7];
          CRadar::ShowRadarMarker(posn, B, v70->fBlipMarkerScale);
          v71 = v70->fBlipMarkerScale + -0.1;
          v70->fBlipMarkerScale = v71;
          if ( v71 < 1.0 )
            v70->fBlipMarkerScale = 5.0;
        }
      }
      pEntryExit = CRadar::ms_RadarTrace[v7].pEntryExit;
      if ( pEntryExit )
        CEntryExit::GetPositionRelativeToOutsideWorld(pEntryExit, &posn);
      if ( (*v10 & 0x200) == 0 )
        return;
      v73 = (float)(posn.x - CRadar::vec2DRadarOrigin.x) * (float)(1.0 / CRadar::m_radarRange);
      v74 = (float)(posn.y - CRadar::vec2DRadarOrigin.y) * (float)(1.0 / CRadar::m_radarRange);
      v75 = (float)(gTransformCos * v74) - (float)(gTransformSin * v73);
      v76 = (float)(gTransformCos * v73) + (float)(gTransformSin * v74);
      v77 = sqrtf((float)(v76 * v76) + (float)(v75 * v75));
      if ( !gMobileMenu.DisplayingMap && v77 > 1.0 )
      {
        v75 = v75 * (float)(1.0 / v77);
        v76 = v76 * (float)(1.0 / v77);
      }
      if ( gMobileMenu.DisplayingMap )
      {
        MAP_OFFSET_Y = gMobileMenu.MAP_OFFSET_Y;
        v79 = v75 * gMobileMenu.NEW_MAP_SCALE;
        v5 = gMobileMenu.MAP_OFFSET_X + (float)(v76 * gMobileMenu.NEW_MAP_SCALE);
        goto LABEL_102;
      }
      if ( CTouchInterface::m_pWidgets[161] )
      {
        left = CTouchInterface::m_pWidgets[161]->m_RectScreen.left;
        right = CTouchInterface::m_pWidgets[161]->m_RectScreen.right;
        top = CTouchInterface::m_pWidgets[161]->m_RectScreen.top;
        v83 = right - left;
        bottom = CTouchInterface::m_pWidgets[161]->m_RectScreen.bottom;
        v85 = left + right;
        v86 = v76 * fabsf(v83);
        v87 = v85 * 0.5;
        MAP_OFFSET_Y = (float)(top + bottom) * 0.5;
        v79 = (float)(v75 * fabsf(top - bottom)) * 0.5;
        v5 = v87 + (float)(v86 * 0.5);
LABEL_102:
        v6 = MAP_OFFSET_Y - v79;
        if ( gMobileMenu.DisplayingMap )
          goto LABEL_107;
        goto LABEL_103;
      }
      if ( gMobileMenu.DisplayingMap )
        goto LABEL_107;
LABEL_103:
      if ( v77 > 1.0 && (*v10 & 4) != 0 )
        return;
LABEL_107:
      if ( CTheScripts::RadarZoomValue )
      {
        if ( !FindPlayerVehicle(-1, 0) )
        {
          v88 = (unsigned __int16)*v10;
          if ( ((v88 >> 10) & 0xB | 4) != 7 )
          {
            if ( v145 || (v88 & 0x10) == 0 && sqrtf((float)(v76 * v76) + (float)(v75 * v75)) > 1.0 )
              return;
            if ( v140 == 1 )
            {
              v99 = *((_DWORD *)v13 + 5);
              if ( v99 )
                v100 = atan2f(COERCE_FLOAT(*(_DWORD *)(v99 + 16) ^ 0x80000000), *(float *)(v99 + 20));
              else
                v100 = *((float *)v13 + 4);
            }
            else
            {
              v100 = 0.0;
            }
            z = posn.z;
            FindPlayerCentreOfWorldForMap((CVector *)&CenterOfCircle, 0);
            if ( CenterOfCircle.right >= (float)(z + -2.0) )
            {
              if ( CenterOfCircle.right <= (float)(z + 4.0) )
              {
                if ( TheCamera.Cams[TheCamera.ActiveCam].Mode == 1 )
                {
                  CRGBA::CRGBA(&v153, HIBYTE(B), BYTE2(B), BYTE1(B), 0xFFu);
                  v136 = v5;
                  v137 = v6;
                  v138 = v100 + 3.1416;
                }
                else
                {
                  v139 = gTransformHeading;
                  CRGBA::CRGBA(&v152, HIBYTE(B), BYTE2(B), BYTE1(B), 0xFFu);
                  v136 = v5;
                  v137 = v6;
                  v138 = v100 - (float)(v139 + 3.1416);
                }
                CRadar::DrawRotatingRadarSprite(&CRadar::RadarBlipSprites[2], v136, v137, v138, 1.0, v135);
                return;
              }
              if ( !CTheScripts::RadarShowBlipOnAllLevels )
                return;
              v132 = v5;
              v133 = v6;
              h = 1;
            }
            else
            {
              if ( !CTheScripts::RadarShowBlipOnAllLevels )
                return;
              v132 = v5;
              v133 = v6;
              h = 0;
            }
            CRadar::ShowRadarTraceWithHeight(
              v132,
              v133,
              CRadar::ms_RadarTrace[v7].nBlipScale,
              HIBYTE(B),
              BYTE2(B),
              BYTE1(B),
              (unsigned __int8)B,
              h);
            return;
          }
        }
      }
      v89 = &CRadar::ms_RadarTrace[v7];
      nBlipSprite = (unsigned __int8)v89->nBlipSprite;
      p_nBlipSprite = &v89->nBlipSprite;
      v90 = nBlipSprite;
      if ( v145 )
      {
        if ( !v90 )
          return;
        if ( gMobileMenu.DisplayingMap && (*(_BYTE *)v10 & 4) != 0 && CTheZones::ZonesRevealed <= 0x4F )
        {
          if ( !CTheZones::GetCurrentZoneLockedOrUnlocked(
                  CRadar::ms_RadarTrace[v7].position.x,
                  CRadar::ms_RadarTrace[v7].position.y) )
            return;
          LOBYTE(v90) = *p_nBlipSprite;
        }
        CRadar::DrawRadarSprite((char)v90, v5, v6, alpha);
        return;
      }
      if ( v90 )
        return;
      if ( v57 == 1 )
      {
        if ( sqrtf((float)(v76 * v76) + (float)(v75 * v75)) <= 0.9
          && !gMobileMenu.DisplayingMap
          && CTouchInterface::m_pWidgets[161] )
        {
          v93 = CTouchInterface::m_pWidgets[161]->m_RectScreen.left;
          v94 = CTouchInterface::m_pWidgets[161]->m_RectScreen.right;
          Radius = v12->Radius;
          CenterOfCircle.top = v6;
          v96 = CRadar::m_radarRange;
          CenterOfCircle.left = v5;
          CRGBA::CRGBA((CRGBA *)&v148, 0, 0, 0, 0x96u);
          v97 = (float)(Radius * (float)(fabsf(v94 - v93) / v96)) * 0.6;
          CSprite2d::DrawCircleAtNearClip((const CVector2D *)&CenterOfCircle, v97, (const CRGBA *)&v148, 15);
          CenterOfCircle.top = v6;
          screenWidth = (float)RsGlobal.screenWidth;
          CenterOfCircle.left = v5;
          CRGBA::CRGBA((CRGBA *)&v148, 0xDCu, 0xDCu, 0xDCu, 0xC8u);
          CSprite2d::DrawCircleAtNearClip(
            (const CVector2D *)&CenterOfCircle,
            v97 + (float)(screenWidth / -640.0),
            (const CRGBA *)&v148,
            15);
        }
        return;
      }
      v101 = v141;
      if ( v141 != 1 )
      {
        v103 = posn.z;
        v104 = 0;
        FindPlayerCentreOfWorldForMap(&v148, 0);
        if ( v148.z >= (float)(v103 + -2.0) )
        {
          v104 = 2;
          if ( v148.z > (float)(v103 + 4.0) )
            v104 = 1;
        }
        if ( circleSize > 0.0 )
        {
          v105 = (float)RsGlobal.screenHeight / 448.0;
          v106 = v6 * v105;
          v107 = (float)((float)RsGlobal.screenHeight / 25.0) * circleSize;
          v108 = v5 * v105;
          CenterOfCircle.bottom = v106 + v107;
          CenterOfCircle.left = v108 - v107;
          CenterOfCircle.right = v108 + v107;
          CenterOfCircle.top = v106 - v107;
          CRGBA::CRGBA(&v146, 0xFFu, 0, 0, 0x64u);
          CSprite2d::Draw(&circleTex, &CenterOfCircle, &v146);
        }
        CRadar::ShowRadarTraceWithHeight(
          v5,
          v6,
          CRadar::ms_RadarTrace[v7].nBlipScale,
          HIBYTE(B),
          BYTE2(B),
          BYTE1(B),
          (unsigned __int8)B,
          v104);
        DisplayingMap = gMobileMenu.DisplayingMap;
        goto LABEL_140;
      }
      if ( gMobileMenu.DisplayingMap )
      {
        v102 = 0;
      }
      else
      {
        v102 = 1;
        if ( v4 < 500.0 && sqrtf((float)(v76 * v76) + (float)(v75 * v75)) < 0.9 )
        {
          CRGBA::CRGBA(&v151, 0xFFu, 0xFFu, 0xFFu, alpha);
          v102 = 0;
          CRadar::DrawRotatingRadarSprite(&CRadar::RadarBlipSprites[56], v5, v6, 0.0, 1.0, v110);
          if ( !gMobileMenu.DisplayingMap )
            v102 = 1;
        }
      }
      posn = CRadar::ms_RadarTrace[v7].position;
      v111 = (float)(posn.x - CRadar::vec2DRadarOrigin.x) * (float)(1.0 / CRadar::m_radarRange);
      v112 = (float)(posn.y - CRadar::vec2DRadarOrigin.y) * (float)(1.0 / CRadar::m_radarRange);
      v113 = (float)(gTransformCos * v112) - (float)(gTransformSin * v111);
      v114 = (float)(gTransformCos * v111) + (float)(gTransformSin * v112);
      if ( v102 == 1 )
      {
        v115 = sqrtf((float)(v114 * v114) + (float)(v113 * v113));
        if ( v115 > 1.0 )
        {
          v116 = 1.0 / v115;
          v113 = v113 * v116;
          v114 = v114 * v116;
        }
      }
      if ( v102 == 1 )
      {
        if ( CTouchInterface::m_pWidgets[161] )
        {
          v5 = (float)((float)(CTouchInterface::m_pWidgets[161]->m_RectScreen.left
                             + CTouchInterface::m_pWidgets[161]->m_RectScreen.right)
                     * 0.5)
             + (float)((float)(v114
                             * fabsf(
                                 CTouchInterface::m_pWidgets[161]->m_RectScreen.right
                               - CTouchInterface::m_pWidgets[161]->m_RectScreen.left))
                     * 0.5);
          v6 = (float)((float)(CTouchInterface::m_pWidgets[161]->m_RectScreen.top
                             + CTouchInterface::m_pWidgets[161]->m_RectScreen.bottom)
                     * 0.5)
             - (float)((float)(v113
                             * fabsf(
                                 CTouchInterface::m_pWidgets[161]->m_RectScreen.top
                               - CTouchInterface::m_pWidgets[161]->m_RectScreen.bottom))
                     * 0.5);
        }
        if ( !CRadar::DrawEntityBlip(int,unsigned char,int,float)::dont_display )
        {
          v117 = gTransformHeading;
          dir = airstrip_table[CRadar::airstrip_location].dir;
          CRGBA::CRGBA(&v149, 0xFFu, 0xFFu, 0xFFu, alpha);
          CRadar::DrawRotatingRadarSprite(
            &CRadar::RadarBlipSprites[57],
            v5,
            v6,
            (float)((float)((float)(dir + -90.0) * -3.1416) / 180.0) - v117,
            2.0,
            v119);
        }
        return;
      }
      v120 = CRadar::airstrip_location;
      NEW_MAP_SCALE = gMobileMenu.NEW_MAP_SCALE;
      MAP_OFFSET_X = gMobileMenu.MAP_OFFSET_X;
      v123 = gMobileMenu.MAP_OFFSET_Y;
      v124 = airstrip_table[CRadar::airstrip_location].dir;
      CRGBA::CRGBA(&v150, 0xFFu, 0xFFu, 0xFFu, alpha);
      v126 = v124 + -90.0;
      if ( v120 == 1 )
        v126 = v124;
      CRadar::DrawRotatingRadarSprite(
        &CRadar::RadarBlipSprites[57],
        MAP_OFFSET_X + (float)(v114 * NEW_MAP_SCALE),
        v123 - (float)(v113 * NEW_MAP_SCALE),
        (float)(v126 * 3.1416) / 180.0,
        2.0,
        v125);
      DisplayingMap = gMobileMenu.DisplayingMap;
      if ( gMobileMenu.DisplayingMap )
      {
        v127 = 0;
        v128 = 0;
        do
        {
          v129 = (unsigned __int16)CRadar::MapLegendList[v127++];
          if ( v129 == 57 )
            v128 = 1;
        }
        while ( v127 != 250 );
        v101 = 1;
        if ( !(v128 << 24) )
        {
          v130 = CRadar::MapLegendCounter;
          CRadar::MapLegendList[CRadar::MapLegendCounter] = 57;
          CRadar::MapLegendCounter = v130 + 1;
        }
LABEL_140:
        if ( !(v101 | !DisplayingMap) )
          CRadar::AddBlipToLegendList(1u, BlipIndex);
      }
      return;
    case 3u:
      v22 = CRadar::ms_RadarTrace[BlipIndex].PoolIndex;
      if ( v22 >= 0
        && (v23 = (unsigned __int8)v22,
            v16 = (unsigned int)v22 >> 8,
            v17 = (CVehiclePool *)CPools::ms_pObjectPool,
            CPools::ms_pObjectPool->m_aFlags[v16] == v23) )
      {
        v18 = 420;
LABEL_13:
        v13 = &(*v17->m_aStorage)[v16 * v18];
      }
      else
      {
LABEL_14:
        v13 = 0;
      }
      goto LABEL_15;
    case 4u:
    case 5u:
      goto LABEL_50;
    case 6u:
      ActualScriptThingIndex = CTheScripts::GetActualScriptThingIndex(CRadar::ms_RadarTrace[BlipIndex].PoolIndex, 2u);
      v12 = 0;
      v9 = 0;
      if ( ActualScriptThingIndex > -1 )
        v12 = &CTheScripts::ScriptSearchLightArray[ActualScriptThingIndex];
      goto LABEL_49;
    case 7u:
      ActualPickupIndex = CPickups::GetActualPickupIndex(CRadar::ms_RadarTrace[BlipIndex].PoolIndex);
      v12 = 0;
      v9 = 0;
      if ( ActualPickupIndex > -1 )
        v9 = &CPickups::aPickUps[ActualPickupIndex];
      goto LABEL_49;
    case 8u:
      v13 = 0;
      pos_x = airstrip_table[CRadar::airstrip_location].pos_x;
      PlayerVehicle = FindPlayerVehicle(-1, 0);
      m_pMat = PlayerVehicle->m_pMat;
      p_tx = &m_pMat->tx;
      v5 = airstrip_table[CRadar::airstrip_location].pos_x;
      if ( !m_pMat )
        p_tx = &PlayerVehicle->m_transform.m_translate.x;
      v6 = *p_tx;
      v30 = FindPlayerVehicle(-1, 0);
      v31 = v30->m_pMat;
      p_x = &v31->tx;
      pos_y = airstrip_table[CRadar::airstrip_location].pos_y;
      if ( !v31 )
        p_x = &v30->m_transform.m_translate.x;
      v34 = *p_x;
      v35 = FindPlayerVehicle(-1, 0);
      v36 = v35->m_pMat;
      p_m_transform = (CSimpleTransform *)&v36->tx;
      v38 = airstrip_table[CRadar::airstrip_location].pos_y;
      if ( !v36 )
        p_m_transform = &v35->m_transform;
      y = p_m_transform->m_translate.y;
      v40 = FindPlayerVehicle(-1, 0);
      v41 = v40->m_pMat;
      v42 = (CSimpleTransform *)&v41->tx;
      if ( !v41 )
        v42 = &v40->m_transform;
      v4 = sqrtf(
             (float)((float)(pos_x - v6) * (float)(v5 - v34))
           + (float)((float)(pos_y - y) * (float)(v38 - v42->m_translate.y)));
      if ( v4 >= 500.0 )
      {
        CRadar::DrawEntityBlip(int,unsigned char,int,float)::dont_display = 0;
      }
      else
      {
        v43 = `guard variable for'CRadar::DrawEntityBlip(int,unsigned char,int,float)::offset_pos;
        __dmb(0xBu);
        if ( (v43 & 1) == 0
          && _cxa_guard_acquire((__guard *)&`guard variable for'CRadar::DrawEntityBlip(int,unsigned char,int,float)::offset_pos) )
        {
          CRadar::DrawEntityBlip(int,unsigned char,int,float)::offset_pos = (int)(float)-airstrip_table[CRadar::airstrip_location].length;
          _cxa_guard_release((__guard *)&`guard variable for'CRadar::DrawEntityBlip(int,unsigned char,int,float)::offset_pos);
        }
        v44 = `guard variable for'CRadar::DrawEntityBlip(int,unsigned char,int,float)::old_offset_pos;
        __dmb(0xBu);
        if ( (v44 & 1) == 0
          && _cxa_guard_acquire((__guard *)&`guard variable for'CRadar::DrawEntityBlip(int,unsigned char,int,float)::old_offset_pos) )
        {
          CRadar::DrawEntityBlip(int,unsigned char,int,float)::old_offset_pos = (int)(float)-airstrip_table[CRadar::airstrip_location].length;
          _cxa_guard_release((__guard *)&`guard variable for'CRadar::DrawEntityBlip(int,unsigned char,int,float)::old_offset_pos);
        }
        v45 = CRadar::airstrip_location;
        v46 = &CRadar::ms_RadarTrace[v7];
        v47 = *(_QWORD *)&v46->position.x;
        posn.z = v46->position.z;
        *(_QWORD *)&posn.x = v47;
        v48 = (float)(airstrip_table[CRadar::airstrip_location].dir * 3.1416) / 180.0;
        v49 = cosf(v48);
        v50 = sinf(v48);
        v51 = (float)CRadar::DrawEntityBlip(int,unsigned char,int,float)::offset_pos;
        posn.y = *((float *)&v47 + 1) - (float)(v50 * v51);
        posn.x = *(float *)&v47 + (float)(v49 * v51);
        v52 = (float)(posn.x - CRadar::vec2DRadarOrigin.x) * (float)(1.0 / CRadar::m_radarRange);
        v53 = sqrtf(
                (float)((float)((float)(gTransformCos * v52)
                              + (float)(gTransformSin
                                      * (float)((float)(posn.y - CRadar::vec2DRadarOrigin.y)
                                              * (float)(1.0 / CRadar::m_radarRange))))
                      * (float)((float)(gTransformCos * v52)
                              + (float)(gTransformSin
                                      * (float)((float)(posn.y - CRadar::vec2DRadarOrigin.y)
                                              * (float)(1.0 / CRadar::m_radarRange)))))
              + (float)((float)((float)(gTransformCos
                                      * (float)((float)(posn.y - CRadar::vec2DRadarOrigin.y)
                                              * (float)(1.0 / CRadar::m_radarRange)))
                              - (float)(gTransformSin * v52))
                      * (float)((float)(gTransformCos
                                      * (float)((float)(posn.y - CRadar::vec2DRadarOrigin.y)
                                              * (float)(1.0 / CRadar::m_radarRange)))
                              - (float)(gTransformSin * v52))));
        if ( v53 >= 0.9
          || CTimer::m_snTimeInMillisecondsPauseMode
           - CRadar::DrawEntityBlip(int,unsigned char,int,float)::RunwayLightCounter >= 4 )
        {
          LOWORD(v54) = CRadar::DrawEntityBlip(int,unsigned char,int,float)::offset_pos + 100;
          v55 = (float)(__int16)(CRadar::DrawEntityBlip(int,unsigned char,int,float)::offset_pos + 100);
          CRadar::DrawEntityBlip(int,unsigned char,int,float)::offset_pos += 100;
          length = airstrip_table[v45].length;
          if ( length < v55 )
          {
            v54 = (int)(float)-length;
            CRadar::DrawEntityBlip(int,unsigned char,int,float)::offset_pos = v54;
          }
          if ( (unsigned __int16)CRadar::DrawEntityBlip(int,unsigned char,int,float)::old_offset_pos == (unsigned __int16)v54 )
            CRadar::DrawEntityBlip(int,unsigned char,int,float)::dont_display = 0;
          if ( v53 < 0.9 )
          {
            CRadar::DrawEntityBlip(int,unsigned char,int,float)::dont_display = 1;
            CRadar::DrawEntityBlip(int,unsigned char,int,float)::old_offset_pos = v54;
          }
          CRadar::DrawEntityBlip(int,unsigned char,int,float)::RunwayLightCounter = CTimer::m_snTimeInMillisecondsPauseMode;
        }
        v13 = 0;
      }
      v12 = 0;
      v141 = 1;
      goto LABEL_69;
    default:
      goto LABEL_48;
  }
}
// 440796: variable 'v5' is possibly undefined
// 440796: variable 'v6' is possibly undefined
// 440A18: variable 'v4' is possibly undefined
// 440A6A: variable 'v110' is possibly undefined
// 440C02: variable 'v119' is possibly undefined
// 440C8C: variable 'v125' is possibly undefined
// 440E0C: variable 'v135' is possibly undefined
// 994ECC: using guessed type char CRadar::DrawEntityBlip(int,unsigned char,int,float)::dont_display;
// 994ED0: using guessed type char `guard variable for'CRadar::DrawEntityBlip(int,unsigned char,int,float)::offset_pos;
// 994ED8: using guessed type char `guard variable for'CRadar::DrawEntityBlip(int,unsigned char,int,float)::old_offset_pos;

//----- (00440FB4) --------------------------------------------------------
void __fastcall CRadar::DrawYouAreHereSprite(float fXPos, float fYPos)
{
  uint32 v2; // r3
  float PlayerHeading; // r5
  float v6; // s20
  float v7; // r5
  float v8; // s24
  float v9; // r0
  UInt16 v10; // r2
  CRGBA v11; // [sp+Ch] [bp-34h] BYREF

  v2 = CTimer::m_snTimeInMillisecondsPauseMode - CRadar::DrawYouAreHereSprite(float,float)::LastFlash;
  if ( !CRadar::DrawYouAreHereSprite(float,float)::ToDisplayPlayer )
  {
    if ( v2 < 0xC9 )
      goto LABEL_7;
    CRadar::DrawYouAreHereSprite(float,float)::ToDisplayPlayer = 1;
    CRadar::DrawYouAreHereSprite(float,float)::LastFlash = CTimer::m_snTimeInMillisecondsPauseMode;
LABEL_6:
    PlayerHeading = FindPlayerHeading(0);
    CRGBA::CRGBA(&v11, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
    v6 = PlayerHeading + 3.1416;
    v7 = (float)(PlayerHeading + 3.1416) + 1.5708;
    v8 = cosf(v7);
    v9 = sinf(v7);
    CRadar::DrawRotatingRadarSprite(
      &CRadar::RadarBlipSprites[3],
      (float)(v8 * 17.0) + fXPos,
      fYPos - (float)(v9 * 17.0),
      v6,
      3.0,
      (CRGBA)&v11);
    goto LABEL_7;
  }
  if ( v2 <= 0x1F4 )
    goto LABEL_6;
  CRadar::DrawYouAreHereSprite(float,float)::ToDisplayPlayer = 0;
  CRadar::DrawYouAreHereSprite(float,float)::LastFlash = CTimer::m_snTimeInMillisecondsPauseMode;
LABEL_7:
  v10 = CRadar::MapLegendCounter;
  CRadar::MapLegendList[CRadar::MapLegendCounter] = 3;
  CRadar::MapLegendCounter = v10 + 1;
}

//----- (004410D8) --------------------------------------------------------
void __fastcall CRadar::DrawRotatingRadarSprite(
        CSprite2d *pSprite,
        float fXPos,
        float fYPos,
        float angle,
        float fScalingFactor,
        CRGBA colour)
{
  float32x2_t v6; // d1
  float32x2_t v7; // d2
  float32x2_t v8; // d3
  float32x2_t v9; // d8
  float32x2_t v10; // d10
  float v12; // s18
  float v14; // s0
  bool v15; // zf
  float NEW_MAP_SCALE; // s0
  float v17; // s0
  CWidget *v18; // r6
  float v19; // s24
  float v20; // s26
  float v21; // r5
  float v22; // r4
  float v23; // r0
  float v24; // r5
  float v25; // s26
  float v26; // s30
  float v27; // r9
  float v28; // s0
  float v29; // r6
  float v30; // s19
  float v31; // s22
  float v32; // s24
  float v33; // s28
  float v34; // s23
  float v35; // r0

  v12 = fYPos;
  v9.n64_f32[0] = fXPos;
  if ( gMobileMenu.DisplayingMap )
  {
    v14 = (float)RsGlobal.screenHeight / 448.0;
    v10.n64_f32[0] = v14 * fYPos;
    v9.n64_f32[0] = v14 * fXPos;
    if ( CHID::GetInputType() == 1 )
    {
      v12 = v14 * v12;
    }
    else
    {
      v15 = gMobileMenu.screenStack.numEntries == 0;
      if ( !gMobileMenu.screenStack.numEntries )
        v15 = gMobileMenu.pendingScreen == 0;
      if ( v15 )
        NEW_MAP_SCALE = 140.0;
      else
        NEW_MAP_SCALE = (float)(int)gMobileMenu.NEW_MAP_SCALE;
      v7.n64_f32[0] = (float)RsGlobal.screenHeight / 448.0;
      v6.n64_f32[0] = (float)RsGlobal.screenWidth / 640.0;
      v12 = (float)(NEW_MAP_SCALE + gMobileMenu.MAP_OFFSET_Y) * v7.n64_f32[0];
      v7.n64_f32[0] = (float)(gMobileMenu.MAP_OFFSET_Y - NEW_MAP_SCALE) * v7.n64_f32[0];
      v8.n64_f32[0] = (float)(gMobileMenu.MAP_OFFSET_X - NEW_MAP_SCALE) * v6.n64_f32[0];
      v6.n64_f32[0] = (float)(NEW_MAP_SCALE + gMobileMenu.MAP_OFFSET_X) * v6.n64_f32[0];
      v17 = vmax_f32(v10, v7).n64_f32[0];
      v9.n64_u32[0] = vmin_f32(vmax_f32(v9, v8), v6).n64_u32[0];
      if ( v17 <= v12 )
        v12 = v17;
    }
  }
  v18 = CTouchInterface::m_pWidgets[161];
  if ( CTouchInterface::m_pWidgets[161] )
  {
    v19 = angle + -0.7854;
    v20 = (float)(angle + -0.7854) + 0.0;
    v21 = (float)(angle + -0.7854) + 4.7124;
    v22 = cosf(v21);
    v23 = sinf(v21);
    v24 = v20;
    v25 = v23;
    v26 = v22 - (float)(v23 * 0.0);
    v27 = sinf(v24);
    v28 = v18->m_RectScreen.right - v18->m_RectScreen.left;
    v29 = v19 + 1.5708;
    v30 = cosf(v19 + 3.1416);
    v31 = (float)(fabsf(v28) * 0.1) * fScalingFactor;
    v32 = sinf(v19 + 3.1416);
    v33 = cosf(v29);
    v34 = sinf(v29);
    v35 = cosf(v24);
    CSprite2d::Draw(
      pSprite,
      v9.n64_f32[0] + (float)(v31 * (float)((float)(v22 * 0.0) + v25)),
      v12 + (float)(v31 * v26),
      v9.n64_f32[0] + (float)(v31 * (float)((float)(v30 * 0.0) + v32)),
      v12 + (float)(v31 * (float)(v30 - (float)(v32 * 0.0))),
      v9.n64_f32[0] + (float)(v31 * (float)((float)(v35 * 0.0) + v27)),
      v12 + (float)(v31 * (float)(v35 - (float)(v27 * 0.0))),
      v9.n64_f32[0] + (float)(v31 * (float)((float)(v33 * 0.0) + v34)),
      v12 + (float)(v31 * (float)(v33 - (float)(v34 * 0.0))),
      *(const CRGBA **)&colour);
  }
}
// 4411A8: variable 'v10' is possibly undefined
// 4411A8: variable 'v7' is possibly undefined
// 4411AC: variable 'v9' is possibly undefined
// 4411AC: variable 'v8' is possibly undefined
// 4411B8: variable 'v6' is possibly undefined

//----- (0044137C) --------------------------------------------------------
UInt32 __fastcall CRadar::GetRadarTraceColour(UInt32 nColourIndex, bool8 bBrightness, bool8 bFriend)
{
  int v3; // r12
  uint8 v4; // r1

  v3 = bBrightness;
  v4 = 12;
  switch ( nColourIndex )
  {
    case 0u:
    case 5u:
      v4 = 0;
      if ( !v3 )
        v4 = 10;
      break;
    case 1u:
      v4 = 1;
      if ( !v3 )
        v4 = 11;
      break;
    case 2u:
    case 6u:
      v4 = 3;
      if ( !v3 )
        v4 = 14;
      break;
    case 3u:
      v4 = 5;
      if ( !v3 )
        v4 = 9;
      break;
    case 4u:
      v4 = 12;
      if ( !v3 )
        v4 = 7;
      break;
    case 7u:
      if ( bFriend )
        bFriend = 14;
      v4 = bFriend;
      break;
    case 8u:
      return sub_19A3A4(&HudColour, v4);
  }
  return sub_19A3A4(&HudColour, v4);
}

//----- (004413E8) --------------------------------------------------------
void __fastcall CRadar::ShowRadarMarker(CVector vecTargetPos, UInt32 nColour, float fScale)
{
  float x; // s24
  float y; // s20
  float z; // s22
  float v7; // s18
  float v8; // s16

  x = vecTargetPos.x;
  y = vecTargetPos.y;
  z = vecTargetPos.z;
  v7 = fScale * 1.4;
  v8 = fScale * 0.5;
  CTheScripts::ScriptDebugLine3D(
    (float)((float)(fScale * 1.4) * TheCamera.m_cameraMatrix.xz) + vecTargetPos.x,
    (float)((float)(fScale * 1.4) * TheCamera.m_cameraMatrix.yz) + vecTargetPos.y,
    (float)((float)(fScale * 1.4) * TheCamera.m_cameraMatrix.zz) + vecTargetPos.z,
    (float)((float)(fScale * 0.5) * TheCamera.m_cameraMatrix.xz) + vecTargetPos.x,
    (float)((float)(fScale * 0.5) * TheCamera.m_cameraMatrix.yz) + vecTargetPos.y,
    (float)((float)(fScale * 0.5) * TheCamera.m_cameraMatrix.zz) + vecTargetPos.z,
    nColour,
    nColour);
  CTheScripts::ScriptDebugLine3D(
    x - (float)(v7 * TheCamera.m_cameraMatrix.xz),
    y - (float)(v7 * TheCamera.m_cameraMatrix.yz),
    z - (float)(v7 * TheCamera.m_cameraMatrix.zz),
    x - (float)(v8 * TheCamera.m_cameraMatrix.xz),
    y - (float)(v8 * TheCamera.m_cameraMatrix.yz),
    z - (float)(v8 * TheCamera.m_cameraMatrix.zz),
    nColour,
    nColour);
  CTheScripts::ScriptDebugLine3D(
    (float)(v7 * TheCamera.m_cameraMatrix.xx) + x,
    (float)(v7 * TheCamera.m_cameraMatrix.yx) + y,
    (float)(v7 * TheCamera.m_cameraMatrix.zx) + z,
    (float)(v8 * TheCamera.m_cameraMatrix.xx) + x,
    (float)(v8 * TheCamera.m_cameraMatrix.yx) + y,
    (float)(v8 * TheCamera.m_cameraMatrix.zx) + z,
    nColour,
    nColour);
  CTheScripts::ScriptDebugLine3D(
    x - (float)(v7 * TheCamera.m_cameraMatrix.xx),
    y - (float)(v7 * TheCamera.m_cameraMatrix.yx),
    z - (float)(v7 * TheCamera.m_cameraMatrix.zx),
    x - (float)(v8 * TheCamera.m_cameraMatrix.xx),
    y - (float)(v8 * TheCamera.m_cameraMatrix.yx),
    z - (float)(v8 * TheCamera.m_cameraMatrix.zx),
    nColour,
    nColour);
}

//----- (004415BC) --------------------------------------------------------
UInt8 __fastcall CRadar::CalculateBlipAlpha(float AlphaMultiplier)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1

  v2.n64_f32[0] = AlphaMultiplier;
  LOBYTE(AlphaMultiplier) = -1;
  if ( v2.n64_f32[0] < 6.0 && !gMobileMenu.DisplayingMap )
  {
    v1.n64_f32[0] = (float)(v2.n64_f32[0] / 6.0) * 255.0;
    v2.n64_u32[0] = 1116471296;
    v1.n64_f32[0] = (float)(255 - (unsigned int)v1.n64_f32[0]);
    LODWORD(AlphaMultiplier) = (unsigned int)vmax_f32(v1, v2).n64_f32[0];
  }
  return LOBYTE(AlphaMultiplier);
}
// 441600: variable 'v1' is possibly undefined
// 441600: variable 'v2' is possibly undefined

//----- (0044161C) --------------------------------------------------------
bool8 __fastcall CRadar::HasThisBlipBeenRevealed(int32 nIndex)
{
  int32 v1; // r0
  bool8 result; // r0

  result = !gMobileMenu.DisplayingMap
        || (v1 = nIndex, (*((_BYTE *)&CRadar::ms_RadarTrace[v1] + 37) & 4) == 0)
        || CTheZones::ZonesRevealed > 0x4F
        || CTheZones::GetCurrentZoneLockedOrUnlocked(
             CRadar::ms_RadarTrace[v1].position.x,
             CRadar::ms_RadarTrace[v1].position.y) != 0;
  return result;
}

//----- (0044167C) --------------------------------------------------------
void __fastcall CRadar::ShowRadarTraceWithHeight(
        float fXPos,
        float fYPos,
        UInt32 Size,
        UInt8 R,
        UInt8 G,
        UInt8 B,
        unsigned int A,
        int h)
{
  float32x2_t v8; // d1
  float32x2_t v9; // d2
  float32x2_t v10; // d3
  float32x2_t v11; // d8
  float32x2_t v12; // d10
  float v15; // s18
  float v16; // s0
  bool v17; // zf
  float NEW_MAP_SCALE; // s0
  float v19; // s0
  unsigned int alpha; // r6
  float v21; // s2
  float v22; // s20
  float v23; // s22
  float v24; // s0
  float v25; // s0
  float v26; // s2
  float v27; // s0
  float v28; // s2
  float v29; // s0
  float v30; // s0
  CRGBA v31; // [sp+14h] [bp-54h] BYREF
  CRect rgba[5]; // [sp+18h] [bp-50h] BYREF

  v11.n64_f32[0] = fXPos;
  v15 = fYPos;
  if ( gMobileMenu.DisplayingMap )
  {
    v16 = (float)RsGlobal.screenHeight / 448.0;
    v12.n64_f32[0] = v16 * fYPos;
    v11.n64_f32[0] = v16 * fXPos;
    if ( CHID::GetInputType() == 1 )
    {
      v15 = v16 * v15;
    }
    else
    {
      v17 = gMobileMenu.screenStack.numEntries == 0;
      if ( !gMobileMenu.screenStack.numEntries )
        v17 = gMobileMenu.pendingScreen == 0;
      if ( v17 )
        NEW_MAP_SCALE = 140.0;
      else
        NEW_MAP_SCALE = (float)(int)gMobileMenu.NEW_MAP_SCALE;
      v9.n64_f32[0] = (float)RsGlobal.screenHeight / 448.0;
      v8.n64_f32[0] = (float)RsGlobal.screenWidth / 640.0;
      v15 = (float)(NEW_MAP_SCALE + gMobileMenu.MAP_OFFSET_Y) * v9.n64_f32[0];
      v9.n64_f32[0] = (float)(gMobileMenu.MAP_OFFSET_Y - NEW_MAP_SCALE) * v9.n64_f32[0];
      v10.n64_f32[0] = (float)(gMobileMenu.MAP_OFFSET_X - NEW_MAP_SCALE) * v8.n64_f32[0];
      v8.n64_f32[0] = (float)(NEW_MAP_SCALE + gMobileMenu.MAP_OFFSET_X) * v8.n64_f32[0];
      v19 = vmax_f32(v12, v9).n64_f32[0];
      v11.n64_u32[0] = vmin_f32(vmax_f32(v11, v10), v8).n64_u32[0];
      if ( v19 <= v15 )
        v15 = v19;
    }
  }
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
  if ( CTouchInterface::m_pWidgets[161] )
  {
    LOBYTE(alpha) = A;
    if ( !gMobileMenu.screenStack.numEntries )
    {
      v21 = 255.0;
      if ( !gMobileMenu.pendingScreen )
        v21 = (float)CTouchInterface::m_pWidgets[161]->m_Color._anon_0._anon_0.alpha;
      alpha = (unsigned int)(float)((float)(v21 / 255.0) * (float)A);
    }
    v22 = fabsf(CTouchInterface::m_pWidgets[161]->m_RectScreen.right - CTouchInterface::m_pWidgets[161]->m_RectScreen.left)
        * 0.01;
    v23 = fabsf(CTouchInterface::m_pWidgets[161]->m_RectScreen.top - CTouchInterface::m_pWidgets[161]->m_RectScreen.bottom)
        * 0.01;
    switch ( h )
    {
      case 2:
        v25 = (float)(Size + 1);
        v26 = v23 * v25;
        v27 = v22 * v25;
        rgba[0].bottom = v15 - v26;
        rgba[0].left = v11.n64_f32[0] - v27;
        rgba[0].right = v11.n64_f32[0] + v27;
        rgba[0].top = v15 + v26;
        CRGBA::CRGBA(&v31, 0, 0, 0, alpha);
        CSprite2d::DrawRect(rgba, &v31);
        v28 = v23 * (float)Size;
        v29 = v22 * (float)Size;
        rgba[0].bottom = v15 - v28;
        rgba[0].left = v11.n64_f32[0] - v29;
        rgba[0].right = v11.n64_f32[0] + v29;
        rgba[0].top = v15 + v28;
        CRGBA::CRGBA(&v31, R, G, B, alpha);
        CSprite2d::DrawRect(rgba, &v31);
        break;
      case 1:
        CRGBA::CRGBA((CRGBA *)rgba, 0, 0, 0, alpha);
        CSprite2d::Draw2DPolygon(
          v11.n64_f32[0],
          v15 + (float)(v23 * (float)(Size + 3)),
          v11.n64_f32[0],
          v15 + (float)(v23 * (float)(Size + 3)),
          v11.n64_f32[0] + (float)(v22 * (float)(Size + 3)),
          v15 - (float)(v23 * (float)(Size + 2)),
          v11.n64_f32[0] - (float)(v22 * (float)(Size + 3)),
          v15 - (float)(v23 * (float)(Size + 2)),
          (const CRGBA *)rgba);
        CRGBA::CRGBA((CRGBA *)rgba, R, G, B, alpha);
        v30 = (float)(Size + 1);
        CSprite2d::Draw2DPolygon(
          v11.n64_f32[0],
          v15 + (float)(v23 * v30),
          v11.n64_f32[0],
          v15 + (float)(v23 * v30),
          v11.n64_f32[0] + (float)(v22 * v30),
          v15 - (float)(v23 * v30),
          v11.n64_f32[0] - (float)(v22 * v30),
          v15 - (float)(v23 * v30),
          (const CRGBA *)rgba);
        break;
      case 0:
        CRGBA::CRGBA((CRGBA *)rgba, 0, 0, 0, alpha);
        CSprite2d::Draw2DPolygon(
          v11.n64_f32[0] + (float)(v22 * (float)(Size + 3)),
          v15 + (float)(v23 * (float)(Size + 2)),
          v11.n64_f32[0] - (float)(v22 * (float)(Size + 3)),
          v15 + (float)(v23 * (float)(Size + 2)),
          v11.n64_f32[0],
          v15 - (float)(v23 * (float)(Size + 3)),
          v11.n64_f32[0],
          v15 - (float)(v23 * (float)(Size + 3)),
          (const CRGBA *)rgba);
        CRGBA::CRGBA((CRGBA *)rgba, R, G, B, alpha);
        v24 = (float)(Size + 1);
        CSprite2d::Draw2DPolygon(
          v11.n64_f32[0] + (float)(v22 * v24),
          v15 + (float)(v23 * v24),
          v11.n64_f32[0] - (float)(v22 * v24),
          v15 + (float)(v23 * v24),
          v11.n64_f32[0],
          v15 - (float)(v23 * v24),
          v11.n64_f32[0],
          v15 - (float)(v23 * v24),
          (const CRGBA *)rgba);
        break;
    }
  }
}
// 44174E: variable 'v12' is possibly undefined
// 44174E: variable 'v9' is possibly undefined
// 441752: variable 'v11' is possibly undefined
// 441752: variable 'v10' is possibly undefined
// 44175E: variable 'v8' is possibly undefined
// 0: using guessed type int dword_0;

//----- (00441A58) --------------------------------------------------------
void __fastcall CRadar::AddBlipToLegendList(bool8 ArrowBlip, int32 BlipIndex)
{
  unsigned int v2; // r3
  int v3; // r2
  char v4; // r2
  int v5; // r6
  int v6; // r2
  int v7; // r4
  int v8; // r5
  UInt16 v9; // r5
  UInt32 IntColour; // r0
  int v11; // r3
  int v12; // r1
  CRGBA v13; // [sp+4h] [bp-14h] BYREF

  if ( gMobileMenu.DisplayingMap )
  {
    if ( ArrowBlip )
    {
      v2 = *(unsigned __int16 *)((char *)&CRadar::ms_RadarTrace[BlipIndex] + 37);
      v3 = (v2 >> 10) & 0xF;
      if ( (unsigned int)(v3 - 1) < 2 )
      {
        v4 = ((v2 & 8) != 0) | 0xFC;
      }
      else if ( v3 == 3 )
      {
        v4 = -2;
      }
      else if ( v3 == 4 )
      {
        v4 = -1;
      }
      else
      {
        v4 = -5;
      }
    }
    else
    {
      v4 = BlipIndex;
    }
    v5 = v4;
    v6 = 0;
    v7 = 0;
    do
    {
      v8 = CRadar::MapLegendList[v6++];
      if ( v5 == v8 )
        v7 = 1;
    }
    while ( v6 != 250 );
    if ( !(v7 << 24) )
    {
      v9 = CRadar::MapLegendCounter;
      CRadar::MapLegendList[CRadar::MapLegendCounter] = v5;
      CRadar::MapLegendCounter = v9 + 1;
      if ( ArrowBlip )
      {
        v12 = 5 * BlipIndex;
        IntColour = *(&CRadar::ms_RadarTrace[0].nColour + 2 * v12);
        v11 = *(unsigned __int16 *)((char *)CRadar::ms_RadarTrace + 8 * v12 + 37);
        LOBYTE(v12) = 12;
        switch ( IntColour )
        {
          case 0u:
          case 5u:
            LOBYTE(v12) = 0;
            if ( (v11 & 1) == 0 )
              LOBYTE(v12) = 10;
            goto LABEL_32;
          case 1u:
            LOBYTE(v12) = 1;
            if ( (v11 & 1) == 0 )
              LOBYTE(v12) = 11;
            goto LABEL_32;
          case 2u:
          case 6u:
            LOBYTE(v12) = 3;
            if ( (v11 & 1) == 0 )
              LOBYTE(v12) = 14;
            goto LABEL_32;
          case 3u:
            LOBYTE(v12) = ((4 * (v11 & 1)) ^ 4) + 5;
            goto LABEL_32;
          case 4u:
            LOBYTE(v12) = 12;
            if ( (v11 & 1) == 0 )
              LOBYTE(v12) = 7;
            goto LABEL_32;
          case 7u:
            v12 = (v11 << 28 >> 31) & 0xE;
            goto LABEL_32;
          case 8u:
LABEL_32:
            IntColour = CHudColours::GetIntColour(&HudColour, v12);
            break;
          default:
            break;
        }
        CRGBA::CRGBA(&v13, HIBYTE(IntColour), BYTE2(IntColour), BYTE1(IntColour), 0xFFu);
        CRadar::ArrowBlipColour[-v5] = v13;
      }
    }
  }
}

//----- (00441BC4) --------------------------------------------------------
void __fastcall CRadar::DrawLegend(Int32 x_position, Int32 y_position, Int32 legend_list_num)
{
  float v4; // s0
  UInt8 v5; // r2
  float v6; // s20
  float v7; // s22
  int v8; // s26
  int v9; // s24
  float v10; // s24
  const CRGBA *rgba; // r0
  float v12; // s26
  float v13; // s2
  float v14; // s0
  float v15; // s26
  float v16; // s24
  const CRGBA *v17; // r0
  CRGBA v18; // [sp+18h] [bp-50h] BYREF
  CRGBA v19; // [sp+1Ch] [bp-4Ch] BYREF
  CRect Rectangle; // [sp+20h] [bp-48h] BYREF

  if ( legend_list_num < 0 )
  {
    v19 = CRadar::ArrowBlipColour[-legend_list_num];
    if ( CTimer::m_snTimeInMillisecondsPauseMode - CRadar::DrawLegend(int,int,int)::LastFlash <= 0x258 )
    {
      v5 = CRadar::DrawLegend(int,int,int)::WhichToDisplay;
    }
    else
    {
      CRadar::DrawLegend(int,int,int)::LastFlash = CTimer::m_snTimeInMillisecondsPauseMode;
      v5 = CRadar::DrawLegend(int,int,int)::WhichToDisplay + 1;
      if ( CRadar::DrawLegend(int,int,int)::WhichToDisplay == 2 )
        v5 = 0;
      CRadar::DrawLegend(int,int,int)::WhichToDisplay = v5;
    }
    v6 = (float)RsGlobal.screenHeight / 448.0;
    v7 = (float)RsGlobal.screenWidth / 640.0;
    v8 = (int)(float)((float)(v6 * 8.0) + (float)y_position);
    v9 = (int)(float)((float)(v7 * 8.0) + (float)x_position);
    switch ( v5 )
    {
      case 2u:
        v12 = (float)v8;
        Rectangle.bottom = v12 - (float)(v6 * 5.0);
        Rectangle.left = (float)v9 - (float)(v7 * 5.0);
        Rectangle.right = (float)(v7 * 5.0) + (float)v9;
        Rectangle.top = (float)(v6 * 5.0) + v12;
        CRGBA::CRGBA(&v18, 0, 0, 0, 0xFFu);
        CSprite2d::DrawRect(&Rectangle, &v18);
        v13 = (float)((float)RsGlobal.screenHeight / 448.0) * 4.0;
        v14 = (float)((float)RsGlobal.screenWidth / 640.0) * 4.0;
        Rectangle.left = (float)v9 - v14;
        Rectangle.bottom = v12 - v13;
        Rectangle.right = v14 + (float)v9;
        Rectangle.top = v13 + v12;
        CSprite2d::DrawRect(&Rectangle, &v19);
        break;
      case 1u:
        CRGBA::CRGBA((CRGBA *)&Rectangle, 0, 0, 0, 0xFFu);
        v15 = (float)v8;
        v16 = (float)v9;
        CSprite2d::Draw2DPolygon(
          v16,
          (float)(v6 * 7.0) + v15,
          v16,
          (float)(v6 * 7.0) + v15,
          (float)(v7 * 7.0) + v16,
          v15 + (float)(v6 * -6.0),
          v16 - (float)(v7 * 7.0),
          v15 + (float)(v6 * -6.0),
          v17);
        CSprite2d::Draw2DPolygon(
          v16,
          (float)((float)((float)RsGlobal.screenHeight / 448.0) * 5.0) + v15,
          v16,
          (float)((float)((float)RsGlobal.screenHeight / 448.0) * 5.0) + v15,
          (float)((float)((float)RsGlobal.screenWidth / 640.0) * 5.0) + v16,
          v15 - (float)((float)((float)RsGlobal.screenHeight / 448.0) * 5.0),
          v16 - (float)((float)((float)RsGlobal.screenWidth / 640.0) * 5.0),
          v15 - (float)((float)((float)RsGlobal.screenHeight / 448.0) * 5.0),
          &v19);
        break;
      case 0u:
        CRGBA::CRGBA((CRGBA *)&Rectangle, 0, 0, 0, 0xFFu);
        v10 = (float)v9;
        CSprite2d::Draw2DPolygon(
          (float)(v7 * 7.0) + v10,
          (float)(v6 * 6.0) + (float)v8,
          v10 - (float)(v7 * 7.0),
          (float)(v6 * 6.0) + (float)v8,
          v10,
          (float)v8 - (float)(v6 * 7.0),
          v10,
          (float)v8 - (float)(v6 * 7.0),
          rgba);
        CSprite2d::Draw2DPolygon(
          (float)((float)((float)RsGlobal.screenWidth / 640.0) * 5.0) + v10,
          (float)((float)((float)RsGlobal.screenHeight / 448.0) * 5.0) + (float)v8,
          v10 - (float)((float)((float)RsGlobal.screenWidth / 640.0) * 5.0),
          (float)((float)((float)RsGlobal.screenHeight / 448.0) * 5.0) + (float)v8,
          v10,
          (float)v8 - (float)((float)((float)RsGlobal.screenHeight / 448.0) * 5.0),
          v10,
          (float)v8 - (float)((float)((float)RsGlobal.screenHeight / 448.0) * 5.0),
          &v19);
        break;
    }
  }
  else
  {
    v4 = (float)((float)RsGlobal.screenWidth / 640.0) * 16.0;
    Rectangle.left = (float)x_position;
    Rectangle.bottom = (float)y_position;
    Rectangle.right = v4 + (float)x_position;
    Rectangle.top = v4 + (float)y_position;
    CRGBA::CRGBA(&v19, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
    CSprite2d::Draw(&CRadar::RadarBlipSprites[legend_list_num], &Rectangle, &v19);
  }
}
// 441D44: variable 'rgba' is possibly undefined
// 441EA2: variable 'v17' is possibly undefined

//----- (00441F44) --------------------------------------------------------
void CRadar::SetMapCentreToPlayerCoords()
{
  float y; // s2
  float x; // s4
  float v2; // s4
  float v3; // s2
  float v4; // s6
  float v5; // s2
  float v6; // s4
  float v7; // s6
  CVector v8; // [sp+4h] [bp-14h] BYREF

  if ( FindPlayerPed(-1) )
  {
    gMobileMenu.DisplayingMap = 1;
    CRadar::InitFrontEndMap();
    FindPlayerCentreOfWorldForMap(&v8, 0);
    if ( (CTheScripts::HideAllFrontEndMapBlips | CTheScripts::bPlayerIsOffTheMap) << 24 )
    {
      y = 0.0;
      v8.x = 0.0;
      v8.y = 0.0;
      x = 0.0;
    }
    else
    {
      x = v8.x;
      y = v8.y;
    }
    v2 = (float)(x - CRadar::vec2DRadarOrigin.x) * (float)(1.0 / CRadar::m_radarRange);
    v3 = (float)(y - CRadar::vec2DRadarOrigin.y) * (float)(1.0 / CRadar::m_radarRange);
    v4 = gTransformSin * v3;
    v5 = (float)(gTransformCos * v3) - (float)(gTransformSin * v2);
    v6 = (float)(gTransformCos * v2) + v4;
    if ( !gMobileMenu.DisplayingMap )
    {
      v7 = sqrtf((float)(v6 * v6) + (float)(v5 * v5));
      if ( v7 > 1.0 )
      {
        v5 = v5 * (float)(1.0 / v7);
        v6 = v6 * (float)(1.0 / v7);
      }
    }
    gMobileMenu.DisplayingMap = 0;
    gMobileMenu.MAP_OFFSET_X = 320.0 - (float)(v6 * gMobileMenu.NEW_MAP_SCALE);
    gMobileMenu.MAP_OFFSET_Y = (float)(v5 * gMobileMenu.NEW_MAP_SCALE) + 224.0;
  }
}

//----- (00442090) --------------------------------------------------------
void CRadar::Draw3dMarkers()
{
  int v0; // r10
  unsigned __int16 *v1; // r5
  unsigned int v2; // r0
  UInt32 g; // r6
  int v4; // r1
  uint8 *v5; // r0
  int v6; // r2
  uint8 *v7; // r3
  __int64 v8; // d16
  float v9; // s26
  int v10; // r2
  int v11; // r4
  unsigned int v12; // r2
  CEntity *v13; // r4
  int v14; // r2
  int v15; // r4
  unsigned int v16; // r2
  uint8 *v17; // r1
  int v18; // r0
  UInt32 v19; // r3
  uint8 *v20; // r2
  __int64 v21; // d16
  int v22; // r2
  float v23; // s0
  int v24; // r0
  int v25; // r0
  float z; // s0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  __int64 v29; // d16
  int *v30; // r0
  float v31; // s0
  float v32; // s2
  float v33; // s0
  int32 ActualPickupIndex; // r0
  CPickup *v35; // r0
  RwReal v36; // s2
  RwReal v37; // s4
  float v38; // s0
  CVector vecPosition; // [sp+38h] [bp-60h] BYREF

  v0 = 0;
  v1 = (unsigned __int16 *)((char *)CRadar::ms_RadarTrace + 37);
  while ( 2 )
  {
    v2 = *v1;
    if ( (v2 & 2) == 0 )
      goto LABEL_62;
    g = *(_DWORD *)((char *)v1 - 37);
    LOBYTE(v4) = 12;
    switch ( g )
    {
      case 0u:
      case 5u:
        LOBYTE(v4) = 0;
        if ( (v2 & 1) == 0 )
          LOBYTE(v4) = 10;
        goto LABEL_18;
      case 1u:
        LOBYTE(v4) = 1;
        if ( (v2 & 1) == 0 )
          LOBYTE(v4) = 11;
        goto LABEL_18;
      case 2u:
      case 6u:
        LOBYTE(v4) = 3;
        if ( (v2 & 1) == 0 )
          LOBYTE(v4) = 14;
        goto LABEL_18;
      case 3u:
        LOBYTE(v4) = ((4 * (v2 & 1)) ^ 4) + 5;
        goto LABEL_18;
      case 4u:
        LOBYTE(v4) = 12;
        if ( (v2 & 1) == 0 )
          LOBYTE(v4) = 7;
        goto LABEL_18;
      case 7u:
        v4 = ((int)(v2 << 28) >> 31) & 0xE;
        goto LABEL_18;
      case 8u:
LABEL_18:
        g = CHudColours::GetIntColour(&HudColour, v4);
        v2 = *v1;
        break;
      default:
        break;
    }
    switch ( (v2 >> 10) & 0xF )
    {
      case 1u:
        v10 = *(_DWORD *)((char *)v1 - 33);
        if ( v10 >= 0
          && (v11 = (unsigned __int8)v10, v12 = (unsigned int)v10 >> 8, CPools::ms_pVehiclePool->m_aFlags[v12] == v11) )
        {
          v13 = (CEntity *)CPools::ms_pVehiclePool->m_aStorage[v12];
        }
        else
        {
          v13 = 0;
        }
        if ( ((v2 >> 8) & 1 | 2) == 3 )
        {
          z = CEntity::GetColModel(v13)->m_boxBound.m_vecMax.z;
          v19 = HIBYTE(g);
          m_pMat = v13->m_pMat;
          v22 = 0x40000000;
          p_tx = (CSimpleTransform *)&m_pMat->tx;
          if ( !m_pMat )
            p_tx = &v13->m_transform;
          v29 = *(_QWORD *)&p_tx->m_translate.x;
          vecPosition.z = p_tx->m_translate.z;
          *(_QWORD *)&vecPosition.x = v29;
          v30 = dword_4424C4;
          if ( v13->m_nModelIndex == 553 )
            v30 = &dword_4424C4[1];
          v31 = z * *(float *)v30;
          v32 = vecPosition.z;
          v25 = v0 | (*(unsigned __int16 *)((char *)v1 - 17) << 16);
          v33 = v31 + 2.0;
          goto LABEL_60;
        }
        goto LABEL_62;
      case 2u:
        v14 = *(_DWORD *)((char *)v1 - 33);
        if ( v14 >= 0
          && (v15 = (unsigned __int8)v14, v16 = (unsigned int)v14 >> 8, CPools::ms_pPedPool->m_aFlags[v16] == v15)
          && (v17 = CPools::ms_pPedPool->m_aStorage[v16]) != 0 )
        {
          if ( v17[1157] << 31 )
            v17 = (uint8 *)*((_DWORD *)v17 + 356);
        }
        else
        {
          v17 = 0;
        }
        if ( ((v2 >> 8) & 1 | 2) == 3 )
        {
          v18 = *((_DWORD *)v17 + 5);
          v19 = HIBYTE(g);
          v20 = (uint8 *)(v18 + 48);
          if ( !v18 )
            v20 = v17 + 4;
          vecPosition.z = *((RwReal *)v20 + 2);
          v21 = *(_QWORD *)v20;
          v22 = 1067030938;
          v23 = vecPosition.z + 2.7;
          v24 = *(unsigned __int16 *)((char *)v1 - 17);
          *(_QWORD *)&vecPosition.x = v21;
          v25 = v0 | (v24 << 16);
          goto LABEL_61;
        }
        goto LABEL_62;
      case 3u:
      case 7u:
        if ( ((v2 >> 8) & 1 | 2) == 3 )
        {
          memset(&vecPosition, 0, sizeof(vecPosition));
          if ( (v2 & 0x3C00) == 3072 )
          {
            v5 = CPools::ms_pObjectPool->m_aStorage[*(_DWORD *)((char *)v1 - 33) >> 8];
            v6 = *((_DWORD *)v5 + 5);
            v7 = (uint8 *)(v6 + 48);
            if ( !v6 )
              v7 = v5 + 4;
            v8 = *(_QWORD *)v7;
            v9 = CModelInfo::ms_modelInfoPtrs[*((__int16 *)v5 + 19)]->m_pColModel->m_boxBound.m_vecMax.z;
            vecPosition.z = *((RwReal *)v7 + 2);
            *(_QWORD *)&vecPosition.x = v8;
          }
          else
          {
            ActualPickupIndex = CPickups::GetActualPickupIndex(*(_DWORD *)((char *)v1 - 33));
            v9 = 2.0;
            if ( ActualPickupIndex >= 0 )
            {
              v9 = 2.0;
              v35 = &CPickups::aPickUps[ActualPickupIndex];
              v36 = (float)v35->CoorsX * 0.125;
              v37 = (float)v35->CoorsZ * 0.125;
              vecPosition.y = (float)v35->CoorsY * 0.125;
              vecPosition.x = v36;
              vecPosition.z = v37;
            }
          }
          v38 = 0.8;
          if ( CGame::currArea == AREA_MAIN_MAP )
          {
            v38 = 0.8;
            if ( !FindPlayerPed(-1)->m_areaCode )
              v38 = 1.0;
          }
          v32 = vecPosition.z;
          v22 = 1061997773;
          v33 = (float)(v9 + v38) + 0.8;
          v25 = v0 | (*(unsigned __int16 *)((char *)v1 - 17) << 16);
          v19 = HIBYTE(g);
LABEL_60:
          v23 = v32 + v33;
LABEL_61:
          vecPosition.z = v23;
          C3dMarkers::PlaceMarkerCone(
            v25,
            &vecPosition,
            *(float *)&v22,
            v19,
            BYTE2(g),
            BYTE1(g),
            0xFFu,
            0x400u,
            0.2,
            5,
            1);
        }
        goto LABEL_62;
      case 5u:
        if ( CTheScripts::IsPlayerOnAMission() || (*((_BYTE *)v1 + 1) & 1 | 2) != 3 || !FindPlayerPed(-1) )
          goto LABEL_62;
        if ( !*(_DWORD *)((char *)v1 - 5) )
          goto LABEL_40;
        if ( !FindPlayerPed(-1)->m_areaCode )
        {
          if ( *(_DWORD *)((char *)v1 - 5) )
            goto LABEL_62;
LABEL_40:
          if ( FindPlayerPed(-1)->m_areaCode )
            goto LABEL_62;
        }
        C3dMarkers::PlaceMarkerSet(
          v0 | (*(unsigned __int16 *)((char *)v1 - 17) << 16),
          1u,
          (CVector *)((char *)v1 - 29),
          2.0,
          COLMISSIONMARKER._anon_0._anon_0.red,
          COLMISSIONMARKER._anon_0._anon_0.green,
          COLMISSIONMARKER._anon_0._anon_0.blue,
          0xE4u,
          0x800u,
          0.2,
          0);
        goto LABEL_62;
      default:
LABEL_62:
        ++v0;
        v1 += 20;
        if ( v0 != 250 )
          continue;
        return;
    }
  }
}
// 4424C4: using guessed type int dword_4424C4[2];

//----- (004424E4) --------------------------------------------------------
void __fastcall CRadar::LimitToMap(float *pXPos, float *pYPos)
{
  bool v4; // zf
  float NEW_MAP_SCALE; // s0
  RwInt32 screenWidth; // r0
  float MAP_OFFSET_X; // s4
  float v8; // s6
  float v9; // s8
  float v10; // s2
  RwInt32 screenHeight; // r0
  float MAP_OFFSET_Y; // s4
  float v13; // s6
  float v14; // s8
  float v15; // s0

  if ( CHID::GetInputType() != 1 )
  {
    v4 = gMobileMenu.screenStack.numEntries == 0;
    if ( !gMobileMenu.screenStack.numEntries )
      v4 = gMobileMenu.pendingScreen == 0;
    if ( v4 )
      NEW_MAP_SCALE = 140.0;
    else
      NEW_MAP_SCALE = (float)(int)gMobileMenu.NEW_MAP_SCALE;
    screenWidth = RsGlobal.screenWidth;
    MAP_OFFSET_X = gMobileMenu.MAP_OFFSET_X;
    v8 = (float)(gMobileMenu.MAP_OFFSET_X - NEW_MAP_SCALE) * (float)((float)RsGlobal.screenWidth / 640.0);
    v9 = *pXPos;
    if ( *pXPos < v8 )
    {
      v9 = (float)(gMobileMenu.MAP_OFFSET_X - NEW_MAP_SCALE) * (float)((float)RsGlobal.screenWidth / 640.0);
      *pXPos = v8;
      screenWidth = RsGlobal.screenWidth;
      MAP_OFFSET_X = gMobileMenu.MAP_OFFSET_X;
    }
    v10 = (float)(NEW_MAP_SCALE + MAP_OFFSET_X) * (float)((float)screenWidth / 640.0);
    if ( v9 > v10 )
      *pXPos = v10;
    screenHeight = RsGlobal.screenHeight;
    MAP_OFFSET_Y = gMobileMenu.MAP_OFFSET_Y;
    v13 = (float)(gMobileMenu.MAP_OFFSET_Y - NEW_MAP_SCALE) * (float)((float)RsGlobal.screenHeight / 448.0);
    v14 = *pYPos;
    if ( *pYPos < v13 )
    {
      v14 = (float)(gMobileMenu.MAP_OFFSET_Y - NEW_MAP_SCALE) * (float)((float)RsGlobal.screenHeight / 448.0);
      *pYPos = v13;
      screenHeight = RsGlobal.screenHeight;
      MAP_OFFSET_Y = gMobileMenu.MAP_OFFSET_Y;
    }
    v15 = (float)(NEW_MAP_SCALE + MAP_OFFSET_Y) * (float)((float)screenHeight / 448.0);
    if ( v14 > v15 )
      *pYPos = v15;
  }
}

//----- (00442640) --------------------------------------------------------
void __fastcall CRadar::TransformScreenSpaceToRadarPoint(CVector2D *screenPt, CVector2D *radarPt)
{
  radarPt->x = (float)(screenPt->x - gMobileMenu.MAP_OFFSET_X) / gMobileMenu.NEW_MAP_SCALE;
  radarPt->y = (float)(screenPt->y - gMobileMenu.MAP_OFFSET_Y) / (float)-gMobileMenu.NEW_MAP_SCALE;
}

//----- (00442680) --------------------------------------------------------
void __fastcall CRadar::TransformRadarPointToRealWorldSpace(CVector2D *worldPt, const CVector2D *radar)
{
  float v2; // s4
  float v3; // s6
  float v4; // s0
  float v5; // s0
  float v6; // s2

  v2 = gTransformSin;
  v3 = gTransformCos;
  v4 = (float)(gTransformCos * radar->x) - (float)(gTransformSin * radar->y);
  worldPt->x = v4;
  v5 = CRadar::m_radarRange * v4;
  v6 = (float)((float)(v2 * radar->x) + (float)(v3 * radar->y)) * CRadar::m_radarRange;
  worldPt->x = v5;
  worldPt->y = v6;
  worldPt->x = v5 + CRadar::vec2DRadarOrigin.x;
  worldPt->y = v6 + CRadar::vec2DRadarOrigin.y;
}

//----- (00442708) --------------------------------------------------------
void __fastcall CRadar::TransformRealWorldToTexCoordSpace(
        CVector2D *texCoord,
        const CVector2D *worldPt,
        int32 tileX,
        int32 tileY)
{
  float v4; // s0
  float v5; // s2

  v4 = worldPt->x - (float)((float)(500 * tileX) + -3000.0);
  texCoord->x = v4;
  v5 = (float)(worldPt->y - (float)((float)(500 * (12 - tileY)) + -3000.0)) * -0.002;
  texCoord->x = v4 * 0.002;
  texCoord->y = v5;
}

//----- (00442770) --------------------------------------------------------
int __fastcall CRadar::SetCoordBlip(__int16 a1, int a2, int a3, int a4, int a5, __int16 a6)
{
  unsigned int v6; // lr
  Int16 *v7; // r12
  __int16 v8; // r5
  int v9; // r6
  unsigned int v10; // r4

  v6 = -1;
  v7 = &CRadar::MapLegendList[244];
  do
  {
    v8 = *(Int16 *)((char *)v7 + 77);
    ++v6;
    v7 += 20;
  }
  while ( v6 <= 0xF9 && (v8 & 2) != 0 );
  if ( v6 > 0xF9 )
    return -1;
  *((_DWORD *)v7 + 6) = 1065353216;
  v9 = 1;
  v7[14] = 1;
  *((_BYTE *)v7 + 36) = 0;
  *((_DWORD *)v7 + 8) = 0;
  v10 = (unsigned __int16)v7[10];
  *(_DWORD *)v7 = 8;
  *((_DWORD *)v7 + 1) = 0;
  *((_DWORD *)v7 + 2) = a2;
  *((_DWORD *)v7 + 3) = a3;
  *((_DWORD *)v7 + 4) = a4;
  *(Int16 *)((char *)v7 + 37) = (a1 << 10) & 0x3C00 | v8 & 0xC000 | (a6 << 8) & 0x300 | 3;
  if ( v10 < 0xFFFE )
    v9 = v10 + 1;
  v7[10] = v9;
  return v6 | (v9 << 16);
}

//----- (0044281C) --------------------------------------------------------
unsigned int __fastcall CRadar::SetShortRangeCoordBlip(
        eBlipType BlpType,
        CVector vecPosition,
        UInt32 nColour,
        eBlipDisplay DispFlag,
        Char *pScriptName)
{
  unsigned int v5; // r12
  Int16 *v6; // lr
  __int16 v7; // r5
  int v8; // r6
  unsigned int v9; // r4
  unsigned int result; // r0

  v5 = -1;
  v6 = &CRadar::MapLegendList[244];
  do
  {
    v7 = *(Int16 *)((char *)v6 + 77);
    ++v5;
    v6 += 20;
  }
  while ( v5 <= 0xF9 && (v7 & 2) != 0 );
  if ( v5 > 0xF9 )
    return -1;
  *((_DWORD *)v6 + 6) = 1065353216;
  v8 = 1;
  v6[14] = 1;
  *((_BYTE *)v6 + 36) = 0;
  *((_DWORD *)v6 + 8) = 0;
  v9 = (unsigned __int16)v6[10];
  *(_DWORD *)v6 = 8;
  *((_DWORD *)v6 + 1) = 0;
  *(CVector *)(v6 + 4) = vecPosition;
  *(Int16 *)((char *)v6 + 37) = v7 & 0xC000 | ((_WORD)DispFlag << 8) & 0x300 | ((BlpType & 0xF) << 10) | 3;
  if ( v9 < 0xFFFE )
    v8 = v9 + 1;
  result = v5 | (v8 << 16);
  v6[10] = v8;
  if ( result == -1 )
    return -1;
  if ( (unsigned __int16)v6[10] == HIWORD(result) )
  {
    if ( (*((_BYTE *)v6 + 37) & 2) == 0 )
      v5 = -1;
  }
  else
  {
    v5 = -1;
  }
  *(_WORD *)((char *)&CRadar::ms_RadarTrace[v5] + 37) |= 4u;
  return result;
}

//----- (00442900) --------------------------------------------------------
unsigned int __fastcall CRadar::SetEntityBlip(
        eBlipType BlpType,
        Int32 IndexInPool,
        UInt32 nColour,
        eBlipDisplay DispFlag,
        Char *pScriptName)
{
  unsigned int v5; // r12
  Int16 *v6; // r2
  __int16 v7; // lr
  unsigned int result; // r0
  int v9; // r1
  int v10; // r5
  unsigned int v11; // r4

  v5 = -1;
  v6 = &CRadar::MapLegendList[244];
  do
  {
    v7 = *(Int16 *)((char *)v6 + 77);
    ++v5;
    v6 += 20;
  }
  while ( v5 <= 0xF9 && (v7 & 2) != 0 );
  if ( v5 > 0xF9 )
    return -1;
  *((_DWORD *)v6 + 6) = 1065353216;
  *((_DWORD *)v6 + 1) = IndexInPool;
  v9 = 1;
  v6[14] = 1;
  *((_BYTE *)v6 + 36) = 0;
  v10 = 1;
  *((_DWORD *)v6 + 8) = 0;
  v11 = (unsigned __int16)v6[10];
  if ( (unsigned int)(BlpType - 1) < 2 )
    v10 = 7;
  *(_DWORD *)v6 = v10;
  *(Int16 *)((char *)v6 + 37) = ((_WORD)BlpType << 10) & 0x3C00 | v7 & 0xC000 | ((_WORD)DispFlag << 8) & 0x300 | 3;
  if ( v11 < 0xFFFE )
    v9 = v11 + 1;
  result = v5 | (v9 << 16);
  v6[10] = v9;
  return result;
}

//----- (00442990) --------------------------------------------------------
void __fastcall CRadar::ClearBlipForEntity(eBlipType BlpType, Int32 IndexInPool)
{
  int v2; // r3
  _WORD *v3; // r2
  unsigned int v4; // r5
  int v5; // r6
  bool v6; // zf

  v2 = 250;
  v3 = (_WORD *)((char *)CRadar::ms_RadarTrace + 37);
  do
  {
    v4 = (unsigned __int16)*v3;
    v5 = (v4 >> 10) & 0xF;
    v6 = v5 == BlpType;
    if ( v5 == BlpType )
      v6 = *(_DWORD *)((char *)v3 - 33) == IndexInPool;
    if ( v6 )
    {
      *(_WORD *)((char *)v3 - 9) = 1;
      *(_DWORD *)((char *)v3 - 13) = 1065353216;
      *(_DWORD *)((char *)v3 - 5) = 0;
      *((_BYTE *)v3 - 1) = 0;
      *v3 = v4 & 0xC000 | 1;
    }
    v3 += 20;
    --v2;
  }
  while ( v2 );
}

//----- (004429E8) --------------------------------------------------------
void __fastcall CRadar::ClearBlip(int32 nIndex)
{
  int v1; // r2
  sRadarTrace *v2; // r0
  _WORD *v3; // r0
  __int16 v4; // r1
  __int16 v5; // t1
  sRadarTrace *v6; // r2

  if ( nIndex != -1
    && CRadar::ms_RadarTrace[(unsigned __int16)nIndex].ReferenceIndex == HIWORD(nIndex)
    && (unsigned __int16)nIndex <= 0xF9u )
  {
    v1 = (unsigned __int16)nIndex;
    v2 = &CRadar::ms_RadarTrace[(unsigned __int16)nIndex];
    v5 = *(_WORD *)((char *)v2 + 37);
    v3 = (_WORD *)((char *)v2 + 37);
    v4 = v5;
    if ( (v5 & 2) != 0 )
    {
      v6 = &CRadar::ms_RadarTrace[v1];
      v6->nBlipScale = 1;
      v6->fBlipMarkerScale = 1.0;
      v6->pEntryExit = 0;
      v6->nBlipSprite = 0;
      *v3 = v4 & 0xC000 | 1;
    }
  }
}

//----- (00442A58) --------------------------------------------------------
void __fastcall CRadar::ChangeBlipColour(int32 nIndex, UInt32 nNewColour)
{
  if ( nIndex != -1
    && CRadar::ms_RadarTrace[(unsigned __int16)nIndex].ReferenceIndex == HIWORD(nIndex)
    && (*((_BYTE *)&CRadar::ms_RadarTrace[(unsigned __int16)nIndex] + 37) & 2) != 0 )
  {
    CRadar::ms_RadarTrace[(unsigned __int16)nIndex].nColour = nNewColour;
  }
}

//----- (00442AB4) --------------------------------------------------------
void __fastcall CRadar::ChangeBlipBrightness(int32 nIndex, int32 OnOrOff)
{
  sRadarTrace *v2; // r0
  _WORD *v3; // r0
  __int16 v4; // r2
  __int16 v5; // t1
  __int16 v6; // r3

  if ( nIndex != -1 && CRadar::ms_RadarTrace[(unsigned __int16)nIndex].ReferenceIndex == HIWORD(nIndex) )
  {
    v2 = &CRadar::ms_RadarTrace[(unsigned __int16)nIndex];
    v5 = *(_WORD *)((char *)v2 + 37);
    v3 = (_WORD *)((char *)v2 + 37);
    v4 = v5;
    if ( (v5 & 2) != 0 )
    {
      v6 = v4 | 1;
      if ( OnOrOff == 1 )
        v6 = v4 & 0xFFFE;
      *v3 = v6;
    }
  }
}

//----- (00442B10) --------------------------------------------------------
void __fastcall CRadar::ChangeBlipScale(int32 nIndex, int32 NewScale)
{
  if ( nIndex != -1
    && CRadar::ms_RadarTrace[(unsigned __int16)nIndex].ReferenceIndex == HIWORD(nIndex)
    && (*((_BYTE *)&CRadar::ms_RadarTrace[(unsigned __int16)nIndex] + 37) & 2) != 0 )
  {
    if ( gMobileMenu.DisplayingMap )
      LOWORD(NewScale) = 1;
    CRadar::ms_RadarTrace[(unsigned __int16)nIndex].nBlipScale = NewScale;
  }
}

//----- (00442B80) --------------------------------------------------------
void __fastcall CRadar::ChangeBlipDisplay(int32 nIndex, eBlipDisplay DispFlag)
{
  sRadarTrace *v2; // r0
  _WORD *v3; // r0
  __int16 v4; // r2
  __int16 v5; // t1

  if ( nIndex != -1 && CRadar::ms_RadarTrace[(unsigned __int16)nIndex].ReferenceIndex == HIWORD(nIndex) )
  {
    v2 = &CRadar::ms_RadarTrace[(unsigned __int16)nIndex];
    v5 = *(_WORD *)((char *)v2 + 37);
    v3 = (_WORD *)((char *)v2 + 37);
    v4 = v5;
    if ( (v5 & 2) != 0 )
      *v3 = ((_WORD)DispFlag << 8) & 0x300 | v4 & 0xFCFF;
  }
}

//----- (00442BE0) --------------------------------------------------------
void __fastcall CRadar::SetBlipSprite(int32 nIndex, int32 BlipSprite)
{
  if ( nIndex != -1
    && CRadar::ms_RadarTrace[(unsigned __int16)nIndex].ReferenceIndex == HIWORD(nIndex)
    && (*((_BYTE *)&CRadar::ms_RadarTrace[(unsigned __int16)nIndex] + 37) & 2) != 0 )
  {
    CRadar::ms_RadarTrace[(unsigned __int16)nIndex].nBlipSprite = BlipSprite;
  }
}

//----- (00442C40) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CRadar::SetBlipAlwaysDisplayInZoom(int32 nIndex, Bool8 bAlwaysDisplay)
{
  sRadarTrace *v2; // r0
  _WORD *v3; // r0
  __int16 v4; // r2
  __int16 v5; // t1

  if ( nIndex != -1 && CRadar::ms_RadarTrace[(unsigned __int16)nIndex].ReferenceIndex == HIWORD(nIndex) )
  {
    v2 = &CRadar::ms_RadarTrace[(unsigned __int16)nIndex];
    v5 = *(_WORD *)((char *)v2 + 37);
    v3 = (_WORD *)((char *)v2 + 37);
    v4 = v5;
    if ( (v5 & 2) != 0 )
      *v3 = (16 * bAlwaysDisplay) & 0x10 | v4 & 0xFFEF;
  }
}
// 442C40: variables would overlap: r1.1 and r1.2

//----- (00442C9C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CRadar::SetBlipFade(int32 nIndex, Bool8 bFade)
{
  sRadarTrace *v2; // r0
  _WORD *v3; // r0
  __int16 v4; // r2
  __int16 v5; // t1

  if ( nIndex != -1 && CRadar::ms_RadarTrace[(unsigned __int16)nIndex].ReferenceIndex == HIWORD(nIndex) )
  {
    v2 = &CRadar::ms_RadarTrace[(unsigned __int16)nIndex];
    v5 = *(_WORD *)((char *)v2 + 37);
    v3 = (_WORD *)((char *)v2 + 37);
    v4 = v5;
    if ( (v5 & 2) != 0 )
      *v3 = (32 * bFade) & 0x20 | v4 & 0xFFDF;
  }
}
// 442C9C: variables would overlap: r1.1 and r1.2

//----- (00442CF8) --------------------------------------------------------
void __fastcall CRadar::SetCoordBlipAppearance(int32 nIndex, UInt8 Appearance)
{
  sRadarTrace *v2; // r0
  _WORD *v3; // r0
  __int16 v4; // r2
  __int16 v5; // t1

  if ( nIndex != -1 && CRadar::ms_RadarTrace[(unsigned __int16)nIndex].ReferenceIndex == HIWORD(nIndex) )
  {
    v2 = &CRadar::ms_RadarTrace[(unsigned __int16)nIndex];
    v5 = *(_WORD *)((char *)v2 + 37);
    v3 = (_WORD *)((char *)v2 + 37);
    v4 = v5;
    if ( (v5 & 2) != 0 && Appearance <= 2u && (v4 & 0x3C00) == 4096 )
      *v3 = (unsigned __int8)(Appearance << 6) | v4 & 0xFF3F;
  }
}

//----- (00442D64) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CRadar::SetBlipFriendly(int32 nIndex, Bool8 bBlipIsFriendly)
{
  sRadarTrace *v2; // r0
  _WORD *v3; // r0
  __int16 v4; // r2
  __int16 v5; // t1

  if ( nIndex != -1 && CRadar::ms_RadarTrace[(unsigned __int16)nIndex].ReferenceIndex == HIWORD(nIndex) )
  {
    v2 = &CRadar::ms_RadarTrace[(unsigned __int16)nIndex];
    v5 = *(_WORD *)((char *)v2 + 37);
    v3 = (_WORD *)((char *)v2 + 37);
    v4 = v5;
    if ( (v5 & 2) != 0 )
      *v3 = (8 * bBlipIsFriendly) & 8 | v4 & 0xFFF7;
  }
}
// 442D64: variables would overlap: r1.1 and r1.2

//----- (00442DC0) --------------------------------------------------------
void __fastcall CRadar::SetBlipEntryExit(int32 nIndex, CEntryExit *pEntryExit)
{
  if ( nIndex != -1
    && CRadar::ms_RadarTrace[(unsigned __int16)nIndex].ReferenceIndex == HIWORD(nIndex)
    && (*((_BYTE *)&CRadar::ms_RadarTrace[(unsigned __int16)nIndex] + 37) & 2) != 0 )
  {
    CRadar::ms_RadarTrace[(unsigned __int16)nIndex].pEntryExit = pEntryExit;
  }
}

//----- (00442E1C) --------------------------------------------------------
void __fastcall CRadar::ShowRadarTrace(float fXPos, float fYPos, UInt32 Size, UInt8 R, UInt8 a5, UInt8 a6, UInt8 alpha)
{
  float32x2_t v7; // d1
  float32x2_t v8; // d2
  float32x2_t v9; // d3
  float32x2_t v10; // d8
  float32x2_t v11; // d10
  float v13; // s18
  float v15; // s0
  bool v16; // zf
  float NEW_MAP_SCALE; // s0
  float v18; // s0
  float v19; // s20
  float v20; // s22
  float v21; // s16
  float v22; // s18
  CRGBA v23; // [sp+4h] [bp-4Ch] BYREF
  CRect Rectangle; // [sp+8h] [bp-48h] BYREF

  v10.n64_f32[0] = fXPos;
  v13 = fYPos;
  if ( gMobileMenu.DisplayingMap )
  {
    v15 = (float)RsGlobal.screenHeight / 448.0;
    v11.n64_f32[0] = v15 * fYPos;
    v10.n64_f32[0] = v15 * fXPos;
    if ( CHID::GetInputType() == 1 )
    {
      v13 = v15 * v13;
    }
    else
    {
      v16 = gMobileMenu.screenStack.numEntries == 0;
      if ( !gMobileMenu.screenStack.numEntries )
        v16 = gMobileMenu.pendingScreen == 0;
      if ( v16 )
        NEW_MAP_SCALE = 140.0;
      else
        NEW_MAP_SCALE = (float)(int)gMobileMenu.NEW_MAP_SCALE;
      v8.n64_f32[0] = (float)RsGlobal.screenHeight / 448.0;
      v7.n64_f32[0] = (float)RsGlobal.screenWidth / 640.0;
      v13 = (float)(NEW_MAP_SCALE + gMobileMenu.MAP_OFFSET_Y) * v8.n64_f32[0];
      v8.n64_f32[0] = (float)(gMobileMenu.MAP_OFFSET_Y - NEW_MAP_SCALE) * v8.n64_f32[0];
      v9.n64_f32[0] = (float)(gMobileMenu.MAP_OFFSET_X - NEW_MAP_SCALE) * v7.n64_f32[0];
      v7.n64_f32[0] = (float)(NEW_MAP_SCALE + gMobileMenu.MAP_OFFSET_X) * v7.n64_f32[0];
      v18 = vmax_f32(v11, v8).n64_f32[0];
      v10.n64_u32[0] = vmin_f32(vmax_f32(v10, v9), v7).n64_u32[0];
      if ( v18 <= v13 )
        v13 = v18;
    }
  }
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  v19 = v13 - (float)Size;
  v20 = v10.n64_f32[0] - (float)Size;
  v21 = v10.n64_f32[0] + (float)Size;
  v22 = v13 + (float)Size;
  Rectangle.bottom = v19 + -1.0;
  Rectangle.left = v20 + -1.0;
  Rectangle.right = v21 + 1.0;
  Rectangle.top = v22 + 1.0;
  CRGBA::CRGBA(&v23, 0, 0, 0, alpha);
  CSprite2d::DrawRect(&Rectangle, &v23);
  Rectangle.bottom = v19;
  Rectangle.left = v20;
  Rectangle.right = v21;
  Rectangle.top = v22;
  CRGBA::CRGBA(&v23, R, a5, a6, alpha);
  CSprite2d::DrawRect(&Rectangle, &v23);
}
// 442EF2: variable 'v11' is possibly undefined
// 442EF2: variable 'v8' is possibly undefined
// 442EF6: variable 'v10' is possibly undefined
// 442EF6: variable 'v9' is possibly undefined
// 442F02: variable 'v7' is possibly undefined

//----- (00442FD0) --------------------------------------------------------
void __fastcall CRadar::SetupRadarRect(int32 x, int32 y)
{
  int32x4_t v2; // q8
  int32x4_t v3; // q9

  v2.n128_u32[0] = 500 * x;
  v3.n128_u64[0] = 0xFFFFF830FFFFF254LL;
  v3.n128_u64[1] = 0xFFFFF254FFFFF830LL;
  v2.n128_u32[1] = 500 * (11 - y);
  v2.n128_u64[1] = v2.n128_u64[0];
  CRadar::m_radarRect = (CRect)vcvtq_f32_s32(vaddq_s32(v2, v3));
}

//----- (00443024) --------------------------------------------------------
bool __fastcall ClipRadarTileCoords(int32 *x, int32 *y)
{
  int32 v2; // r2
  bool result; // r0
  int32 v4; // r0

  if ( *x < 0 )
  {
    v2 = 0;
    goto LABEL_5;
  }
  if ( *x >= 12 )
  {
    v2 = 11;
LABEL_5:
    *x = v2;
    result = 1;
    goto LABEL_7;
  }
  result = 0;
LABEL_7:
  if ( *y < 0 )
  {
    v4 = 0;
  }
  else
  {
    if ( *y < 12 )
      return result;
    v4 = 11;
  }
  *y = v4;
  return 1;
}

//----- (00443054) --------------------------------------------------------
void __fastcall CRadar::RequestMapSection(int32 x, int32 y)
{
  bool v2; // cc
  int v3; // r4
  TextureDatabaseRuntime *Database; // r0
  RwTexture *Texture; // r0
  unsigned __int8 s[32]; // [sp+4h] [bp-2Ch] BYREF

  v2 = (unsigned int)x > 0xB;
  if ( (unsigned int)x <= 0xB )
    v2 = (unsigned int)y > 0xB;
  if ( !v2 )
  {
    v3 = x + 12 * y;
    if ( !gRadarTextures[v3] )
    {
      Database = TextureDatabaseRuntime::GetDatabase("gta3");
      TextureDatabaseRuntime::Register(Database);
      snprintf(s, 0x20u, "radar%02d", v3);
      Texture = TextureDatabaseRuntime::GetTexture(s);
      gRadarTextures[v3] = Texture;
      ++Texture->refCount;
    }
  }
}

//----- (004430E0) --------------------------------------------------------
void __fastcall CRadar::RemoveMapSection(int32 x, int32 y)
{
  bool v2; // cc
  int v3; // r4
  RwTexture_0 *v4; // r0

  v2 = (unsigned int)x > 0xB;
  if ( (unsigned int)x <= 0xB )
    v2 = (unsigned int)y > 0xB;
  if ( !v2 )
  {
    v3 = x + 12 * y;
    v4 = gRadarTextures[v3];
    if ( v4 )
    {
      RwTextureDestroy(v4);
      gRadarTextures[v3] = 0;
    }
  }
}

//----- (00443120) --------------------------------------------------------
void __fastcall CRadar::StreamRadarSections(int32 x, int32 y)
{
  int v2; // r5
  int v3; // r6
  int v4; // r4
  int v5; // r9
  _BOOL4 v6; // r11
  RwTexture_0 *v7; // r0
  TextureDatabaseRuntime *Database; // r0
  RwTexture *Texture; // r0
  int v10; // [sp+4h] [bp-54h]
  int v11; // [sp+8h] [bp-50h]
  int v12; // [sp+Ch] [bp-4Ch]
  unsigned __int8 s[32]; // [sp+18h] [bp-40h] BYREF

  v2 = y + 1;
  v3 = y - 1;
  v4 = 0;
  v10 = x - 1;
  v11 = x + 1;
  do
  {
    v5 = 0;
    v12 = v4;
    v6 = v4 < v10 || v4 > v11;
    do
    {
      v7 = gRadarTextures[v4];
      if ( v5 > v2 || v5 < v3 || v6 )
      {
        if ( v7 )
        {
          RwTextureDestroy(v7);
          gRadarTextures[v4] = 0;
        }
      }
      else if ( !v7 )
      {
        Database = TextureDatabaseRuntime::GetDatabase("gta3");
        TextureDatabaseRuntime::Register(Database);
        snprintf(s, 0x20u, "radar%02d", v4);
        Texture = TextureDatabaseRuntime::GetTexture(s);
        gRadarTextures[v4] = Texture;
        ++Texture->refCount;
      }
      ++v5;
      v4 += 12;
    }
    while ( v5 != 12 );
    v4 = v12 + 1;
  }
  while ( v12 != 11 );
}

//----- (00443224) --------------------------------------------------------
bool __fastcall IsPointInsideRadar(const CVector2D *pt)
{
  float y; // s4
  char v2; // r1
  char v3; // r0

  if ( pt->x < -1.0 || pt->x > 1.0 )
    return 0;
  y = pt->y;
  v2 = 0;
  v3 = 0;
  if ( y >= -1.0 )
    v2 = 1;
  if ( y <= 1.0 )
    v3 = 1;
  return v3 & v2;
}

//----- (0044326C) --------------------------------------------------------
void __fastcall GetTextureCorners(int32 x, int32 y, CVector2D *pVerts)
{
  int v3; // r0
  int v4; // r1
  float v5; // s2
  float v6; // s4
  float v7; // s6

  v3 = 500 * x;
  v4 = 500 * (11 - y);
  v5 = (float)(v3 - 2500);
  v6 = (float)(v4 - 3000);
  v7 = (float)(v4 - 2500);
  pVerts->x = (float)(v3 - 3000);
  pVerts->y = v6;
  pVerts[1].x = v5;
  pVerts[1].y = v6;
  pVerts[2].x = v5;
  pVerts[2].y = v7;
  pVerts[3].x = (float)(v3 - 3000);
  pVerts[3].y = v7;
}

//----- (004432CA) --------------------------------------------------------
int32 __fastcall LineRadarBoxCollision(CVector2D *result, const CVector2D *start, const CVector2D *end)
{
  float x; // s4
  float v4; // s6
  float v5; // s8
  float v6; // s2
  int32 v7; // lr
  float v8; // s8
  float v9; // s2
  float v10; // s10
  float *v11; // r5
  float *p_y; // r4
  float v13; // s4
  float v14; // s6
  float v15; // s4
  float v16; // s6
  float v17; // s10
  float v18; // s8
  float v19; // s8
  float v20; // s10
  float v21; // s4
  float v22; // s2

  x = end->x;
  v4 = start->x;
  v5 = -1.0 - end->x;
  v6 = -1.0 - start->x;
  if ( (float)(v6 * v5) >= 0.0 )
  {
    v9 = 1.0;
    v7 = -1;
  }
  else
  {
    v7 = -1;
    v8 = v6 / (float)(v6 - v5);
    v9 = 1.0;
    if ( v8 <= 1.0 )
    {
      v10 = start->y + (float)(v8 * (float)(end->y - start->y));
      if ( v10 <= 1.0 && v10 >= -1.0 )
      {
        result->y = v10;
        result->x = -1.0;
        x = end->x;
        v4 = start->x;
        v7 = 3;
        v9 = v8;
      }
    }
  }
  if ( (float)((float)(v4 + -1.0) * (float)(x + -1.0)) >= 0.0 )
  {
    p_y = &end->y;
    v11 = &start->y;
  }
  else
  {
    v11 = &start->y;
    p_y = &end->y;
    v13 = (float)(v4 + -1.0) / (float)((float)(v4 + -1.0) - (float)(x + -1.0));
    if ( v13 <= v9 )
    {
      v14 = start->y + (float)(v13 * (float)(end->y - start->y));
      if ( v14 <= 1.0 && v14 >= -1.0 )
      {
        result->y = v14;
        result->x = 1.0;
        v7 = 1;
        v9 = v13;
      }
    }
  }
  v15 = *p_y;
  v16 = *v11;
  v17 = -1.0 - *p_y;
  v18 = -1.0 - *v11;
  if ( (float)(v18 * v17) < 0.0 )
  {
    v19 = v18 / (float)(v18 - v17);
    if ( v19 <= v9 )
    {
      v20 = start->x + (float)(v19 * (float)(end->x - start->x));
      if ( v20 <= 1.0 && v20 >= -1.0 )
      {
        result->y = -1.0;
        result->x = v20;
        v15 = *p_y;
        v16 = *v11;
        v7 = 0;
        v9 = v19;
      }
    }
  }
  if ( (float)((float)(v16 + -1.0) * (float)(v15 + -1.0)) < 0.0 )
  {
    v21 = (float)(v16 + -1.0) / (float)((float)(v16 + -1.0) - (float)(v15 + -1.0));
    if ( v21 <= v9 )
    {
      v22 = start->x + (float)(v21 * (float)(end->x - start->x));
      if ( v22 <= 1.0 && v22 >= -1.0 )
      {
        result->y = 1.0;
        result->x = v22;
        return 2;
      }
    }
  }
  return v7;
}

//----- (004434B0) --------------------------------------------------------
int32 __fastcall CRadar::ClipRadarPoly(CVector2D *pClipVerts, const CVector2D *pVerts)
{
  const CVector2D *v3; // r9
  int v4; // r0
  float y; // s4
  int v6; // r1
  int v7; // r0
  char v8; // r1
  float x; // s4
  float v10; // s4
  char v11; // r2
  char v12; // r1
  char v13; // r1
  float v14; // s4
  float v15; // s4
  char v16; // r2
  char v17; // r1
  char v18; // r1
  float v19; // s4
  float v20; // s4
  char v21; // r2
  char v22; // r1
  int32 v23; // lr
  int v24; // r11
  int32 v25; // r5
  const CVector2D *v26; // r4
  int32 v27; // r0
  const CVector2D *v28; // r1
  int32 v29; // r9
  bool v30; // zf
  CVector2D *v31; // r0
  int32 v32; // r8
  int32 v33; // r6
  int v34; // r10
  const CVector2D *v35; // r6
  int v36; // r0
  int v37; // r4
  int v38; // r0
  float v39; // r11
  float v40; // r12
  int v41; // r2
  _DWORD *p_x; // r5
  _QWORD *v43; // r3
  CVector2D *v44; // r1
  float v45; // s6
  float v46; // s0
  float v47; // s4
  float v48; // s8
  float v49; // s10
  CVector2D *v50; // r8
  CVector2D *start; // [sp+0h] [bp-88h]
  const CVector2D *v53; // [sp+4h] [bp-84h]
  CVector2D *v54; // [sp+8h] [bp-80h]
  CVector2D *v55; // [sp+Ch] [bp-7Ch]
  int32 v56; // [sp+10h] [bp-78h]
  int32 v57; // [sp+18h] [bp-70h]
  CVector2D result; // [sp+1Ch] [bp-6Ch] BYREF
  _QWORD v59[4]; // [sp+24h] [bp-64h] BYREF
  char v60[68]; // [sp+44h] [bp-44h]

  v3 = pVerts;
  v59[0] = 0xBF8000003F800000LL;
  v59[1] = 0x3F8000003F800000LL;
  v59[2] = 0x3F800000BF800000LL;
  v59[3] = 0xBF800000BF800000LL;
  v4 = 0;
  if ( pVerts->x >= -1.0 && pVerts->x <= 1.0 )
  {
    y = pVerts->y;
    v6 = 0;
    v7 = 0;
    if ( y >= -1.0 )
      v6 = 1;
    if ( y <= 1.0 )
      v7 = 1;
    v4 = v7 & v6;
  }
  v60[0] = v4;
  v8 = 0;
  x = v3[1].x;
  if ( x >= -1.0 && x <= 1.0 )
  {
    v10 = v3[1].y;
    v11 = 0;
    v12 = 0;
    if ( v10 >= -1.0 )
      v11 = 1;
    if ( v10 <= 1.0 )
      v12 = 1;
    v8 = v12 & v11;
  }
  v60[1] = v8;
  v13 = 0;
  v14 = v3[2].x;
  if ( v14 >= -1.0 && v14 <= 1.0 )
  {
    v15 = v3[2].y;
    v16 = 0;
    v17 = 0;
    if ( v15 >= -1.0 )
      v16 = 1;
    if ( v15 <= 1.0 )
      v17 = 1;
    v13 = v17 & v16;
  }
  v60[2] = v13;
  v18 = 0;
  v19 = v3[3].x;
  if ( v19 >= -1.0 && v19 <= 1.0 )
  {
    v20 = v3[3].y;
    v21 = 0;
    v22 = 0;
    if ( v20 >= -1.0 )
      v21 = 1;
    if ( v20 <= 1.0 )
      v22 = 1;
    v18 = v22 & v21;
  }
  v23 = -1;
  v24 = 0;
  v25 = 0;
  v60[3] = v18;
  start = (CVector2D *)&v3[3];
  v53 = v3;
  v54 = pClipVerts;
  if ( v4 << 24 )
    goto LABEL_55;
  while ( 1 )
  {
    v26 = &v3[v24];
    v27 = LineRadarBoxCollision(&pClipVerts[v25], v26, &v3[((_BYTE)v24 + 3) & 3]);
    v28 = v3;
    v29 = v27++;
    v30 = v27 == 0;
    v57 = v27;
    v31 = pClipVerts;
    v32 = v29;
    if ( v30 )
      v32 = v23;
    v33 = v25 + 1;
    v34 = v24 + 1;
    if ( !v30 )
      ++v25;
    v55 = &v31[v25];
    v56 = LineRadarBoxCollision(v55, v26, &v28[(v24 + 1) & 3]);
    if ( v56 == -1 )
      break;
    if ( v57 )
    {
      v23 = v29;
      v3 = v53;
      pClipVerts = v54;
    }
    else
    {
      v30 = v32 == -1;
      v3 = v53;
      pClipVerts = v54;
      if ( v30 )
      {
        v35 = start;
        v36 = 3;
        while ( v36 >= v24 )
        {
          v37 = v36 - 1;
          v30 = v36 == 0;
          v38 = v36 - 1;
          if ( v30 )
            v38 = 3;
          v23 = LineRadarBoxCollision(&result, v35--, &v53[v38]);
          v36 = v37;
          if ( v23 != -1 )
            goto LABEL_48;
        }
        v23 = -1;
      }
LABEL_48:
      v39 = v54[v25].x;
      result.x = v39;
      v40 = v55->y;
      result.y = v40;
      if ( v23 == v56 )
      {
        v33 = v25;
      }
      else
      {
        v41 = v23;
        v33 = v25;
        do
        {
          p_x = (_DWORD *)&v54[v33].x;
          *p_x = v59[v41];
          v43 = &v59[v41];
          v41 = ((_BYTE)v41 + 1) & 3;
          ++v33;
          p_x[1] = *((_DWORD *)v43 + 1);
        }
        while ( v41 != v56 );
      }
      v54[v33].x = v39;
      v54[v33].y = v40;
    }
    v25 = v33 + 1;
    if ( v34 == 4 )
      goto LABEL_56;
LABEL_54:
    while ( 1 )
    {
      v24 = v34;
      if ( !((unsigned __int8)v60[v34] << 24) )
        break;
LABEL_55:
      v44 = &pClipVerts[v25];
      v34 = v24 + 1;
      v44->x = v3[v24].x;
      ++v25;
      v44->y = v3[v24].y;
      if ( v24 == 3 )
        goto LABEL_56;
    }
  }
  v23 = v32;
  v3 = v53;
  pClipVerts = v54;
  if ( v24 != 3 )
    goto LABEL_54;
LABEL_56:
  if ( !v25 )
  {
    v45 = v3[1].x;
    v46 = v3->y;
    v47 = v3[1].y;
    v48 = v3[3].x;
    v49 = v3[3].y;
    if ( (float)((float)((float)(v3->x * (float)((float)(v46 - v47) / (float)(v3->x - v45))) - v46)
               * (float)((float)((float)((float)(v46 - v47) / (float)(v3->x - v45)) * v48) - v49)) >= 0.0
      || (float)((float)((float)(v3->x * (float)((float)(v46 - v49) / (float)(v3->x - v48))) - v46)
               * (float)((float)(v45 * (float)((float)(v46 - v49) / (float)(v3->x - v48))) - v47)) >= 0.0 )
    {
      return 0;
    }
    else
    {
      *pClipVerts = (CVector2D)0xBF8000003F800000LL;
      pClipVerts[1] = (CVector2D)0x3F8000003F800000LL;
      v50 = pClipVerts + 2;
      v25 = 4;
      *v50 = (CVector2D)0x3F800000BF800000LL;
      v50[1] = (CVector2D)0xBF800000BF800000LL;
    }
  }
  return v25;
}

//----- (00443800) --------------------------------------------------------
void __fastcall CRadar::DrawRadarSection(int32 x, int32 y, int nWidgetAlpha)
{
  UInt8 alpha; // r8
  int v5; // r5
  int v6; // r11
  int v7; // r1
  void **v8; // r9
  float v9; // s2
  float v10; // s6
  float v11; // s4
  float v12; // s0
  float v13; // s14
  float v14; // s8
  float v15; // s2
  float v16; // s6
  float v17; // s1
  float v18; // s12
  float v19; // s0
  float v20; // s4
  int32 v21; // r0
  int32 v22; // r10
  float v23; // s0
  float v24; // s2
  float *p_y; // r1
  float v26; // s12
  float *v27; // r0
  int32 v28; // r4
  float v29; // s6
  float v30; // s8
  float v31; // s10
  _BOOL4 DisplayingMap; // r2
  float *v33; // r3
  float v34; // s7
  float v35; // s5
  float v36; // s9
  float v37; // s5
  float MAP_OFFSET_Y; // s7
  CWidget *v39; // r6
  float top; // s7
  float bottom; // s9
  float v42; // s11
  CRGBA v43; // [sp+8h] [bp-100h] BYREF
  float pVert; // [sp+Ch] [bp-FCh] BYREF
  int v45; // [sp+10h] [bp-F8h] BYREF
  float pTc; // [sp+4Ch] [bp-BCh] BYREF
  int v47; // [sp+50h] [bp-B8h] BYREF
  CVector2D pClipVerts; // [sp+8Ch] [bp-7Ch] BYREF
  CVector2D pVerts; // [sp+CCh] [bp-3Ch] BYREF
  float v50; // [sp+D4h] [bp-34h]
  float v51; // [sp+D8h] [bp-30h]
  float v52; // [sp+DCh] [bp-2Ch]
  float v53; // [sp+E0h] [bp-28h]
  float v54; // [sp+E4h] [bp-24h]
  float v55; // [sp+E8h] [bp-20h]

  alpha = nWidgetAlpha;
  v5 = 500 * x;
  v6 = 0;
  v7 = 500 * (11 - y);
  v8 = 0;
  if ( (unsigned int)x > 0xB )
    v6 = 1;
  if ( (unsigned int)y <= 0xB )
  {
    v8 = 0;
    if ( (unsigned int)x <= 0xB && !CTheScripts::bPlayerIsOffTheMap )
    {
      v8 = (void **)*(&gRadarTextures[12 * y] + x);
      if ( !v8 )
        return;
      v6 = 0;
    }
  }
  else
  {
    v6 = 1;
  }
  v9 = (float)((float)(500 * x - 3000) - CRadar::vec2DRadarOrigin.x) * (float)(1.0 / CRadar::m_radarRange);
  v10 = (float)((float)(v7 - 3000) - CRadar::vec2DRadarOrigin.y) * (float)(1.0 / CRadar::m_radarRange);
  v11 = (float)((float)(v7 - 2500) - CRadar::vec2DRadarOrigin.y) * (float)(1.0 / CRadar::m_radarRange);
  v12 = (float)((float)(500 * x - 2500) - CRadar::vec2DRadarOrigin.x) * (float)(1.0 / CRadar::m_radarRange);
  v13 = gTransformCos * v9;
  v14 = gTransformSin * v10;
  v15 = gTransformSin * v9;
  v16 = gTransformCos * v10;
  v17 = gTransformCos * v12;
  v18 = gTransformCos * v11;
  v19 = gTransformSin * v12;
  v20 = gTransformSin * v11;
  pVerts.x = v13 + v14;
  pVerts.y = v16 - v15;
  v50 = v17 + v14;
  v51 = v16 - v19;
  v53 = v18 - v19;
  v52 = v17 + v20;
  v55 = v18 - v15;
  v54 = v13 + v20;
  v21 = CRadar::ClipRadarPoly(&pClipVerts, &pVerts);
  v22 = v21;
  if ( v21 )
  {
    if ( v21 >= 1 )
    {
      v23 = gTransformSin;
      v24 = gTransformCos;
      p_y = &pClipVerts.y;
      v26 = CRadar::m_radarRange;
      v27 = (float *)&v47;
      v28 = v22;
      v29 = (float)(500 * (12 - y)) + -3000.0;
      v30 = CRadar::vec2DRadarOrigin.x;
      v31 = CRadar::vec2DRadarOrigin.y;
      DisplayingMap = gMobileMenu.DisplayingMap;
      v33 = (float *)&v45;
      while ( 1 )
      {
        v34 = *(p_y - 1);
        v35 = *p_y;
        v36 = (float)((float)((float)(v26 * (float)((float)(v23 * v34) + (float)(v24 * *p_y))) + v31) - v29) * -0.002;
        *(v27 - 1) = (float)((float)((float)((float)((float)(v24 * v34) - (float)(v23 * *p_y)) * v26) + v30)
                           - (float)((float)v5 + -3000.0))
                   * 0.002;
        *v27 = v36;
        if ( DisplayingMap )
          break;
        v39 = CTouchInterface::m_pWidgets[161];
        if ( CTouchInterface::m_pWidgets[161] )
        {
          *(v33 - 1) = (float)((float)(CTouchInterface::m_pWidgets[161]->m_RectScreen.left
                                     + CTouchInterface::m_pWidgets[161]->m_RectScreen.right)
                             * 0.5)
                     + (float)((float)(v34
                                     * fabsf(
                                         CTouchInterface::m_pWidgets[161]->m_RectScreen.right
                                       - CTouchInterface::m_pWidgets[161]->m_RectScreen.left))
                             * 0.5);
          top = v39->m_RectScreen.top;
          bottom = v39->m_RectScreen.bottom;
          v42 = fabsf(top - bottom);
          MAP_OFFSET_Y = (float)(top + bottom) * 0.5;
          v37 = (float)(v35 * v42) * 0.5;
          goto LABEL_16;
        }
LABEL_17:
        v27 += 2;
        p_y += 2;
        v33 += 2;
        if ( !--v28 )
          goto LABEL_18;
      }
      v37 = v35 * gMobileMenu.NEW_MAP_SCALE;
      *(v33 - 1) = gMobileMenu.MAP_OFFSET_X + (float)(v34 * gMobileMenu.NEW_MAP_SCALE);
      MAP_OFFSET_Y = gMobileMenu.MAP_OFFSET_Y;
LABEL_16:
      *v33 = MAP_OFFSET_Y - v37;
      goto LABEL_17;
    }
LABEL_18:
    if ( v6 )
    {
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
      CRGBA::CRGBA(&v43, 0x6Fu, 0x89u, 0xAAu, alpha);
    }
    else if ( CTheScripts::bPlayerIsOffTheMap )
    {
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
      CRGBA::CRGBA(&v43, 0xCCu, 0xCCu, 0xCCu, alpha);
    }
    else
    {
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, *v8);
      CRGBA::CRGBA(&v43, 0xFFu, 0xFFu, 0xFFu, alpha);
    }
    CSprite2d::SetVertices(v22, &pVert, &pTc, &v43);
    if ( v22 >= 3 )
      RwIm2DRenderIndexedPrimitive_BUGFIX(rwPRIMTYPETRILIST, CSprite2d::maVertices, 8, fanIndices, 3 * v22 - 6);
  }
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (00443B90) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CRadar::DrawRadarSectionMap(int32 x, int32 y, CRect Pos, float opacity)
{
  bool v4; // cc
  void **v5; // r4
  const CRGBA *v6; // r0
  CRGBA v7; // [sp+8h] [bp-38h] BYREF
  CRGBA v8; // [sp+Ch] [bp-34h] BYREF
  CRGBA v9; // [sp+10h] [bp-30h] BYREF
  CRGBA v10; // [sp+14h] [bp-2Ch] BYREF
  CRect Rectangle; // [sp+18h] [bp-28h] BYREF

  v4 = (unsigned int)x > 0xB;
  Rectangle = Pos;
  if ( (unsigned int)x <= 0xB )
    v4 = (unsigned int)y > 0xB;
  if ( !v4 )
  {
    v5 = (void **)*(&gRadarTextures[12 * y] + x);
    if ( v5 )
    {
      RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, *v5);
      CRGBA::CRGBA(&v10, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)(opacity * 255.0));
      CRGBA::CRGBA(&v9, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)(opacity * 255.0));
      CRGBA::CRGBA(&v8, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)(opacity * 255.0));
      CRGBA::CRGBA(&v7, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)(opacity * 255.0));
      CSprite2d::SetVertices(&Rectangle, &v10, &v9, &v8, v6);
      RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, CSprite2d::maVertices, 4);
    }
  }
}
// 443B90: fragmented variable at 0:r2.8,8:^48.8 may be wrong
// 443B90: variables would overlap: 0:r2.8,8:^48.8 and ^48.8
// 0: using guessed type int dword_0;

//----- (00443C60) --------------------------------------------------------
void __fastcall CRadar::DrawAreaOnRadar(const CRect *rect, const CRGBA *rgba, bool bFullMap)
{
  float left; // r1
  float top; // r3
  float bottom; // r0
  float right; // r2
  __int64 v8; // kr08_8
  float32x4_t v9; // q1
  float32x4_t v10; // q0
  const float *v11; // r0
  const float *v12; // r1
  float32x4_t v13; // q2
  int32x4_t v14; // q8
  int32x4_t v15; // q9
  float32x4_t v16; // q10
  float32x4_t v17; // q8
  float32x4_t v18; // q13
  float32x4_t v19; // q9
  float32x4_t v20; // q10
  float32x4_t v21; // q11
  int32 v22; // r0
  int32 v23; // r9
  float *v24; // r1
  int32 v25; // r5
  float *p_y; // r0
  int DisplayingMap; // r6
  float *v28; // r2
  float v29; // s0
  int v30; // r3
  float v31; // s4
  float v32; // s6
  float v33; // s6
  float MAP_OFFSET_Y; // s8
  float v35; // s4
  CWidget *v36; // r3
  float v37; // s8
  float v38; // s10
  float v39; // s12
  float v40; // s6
  float v41; // s8
  CVector2D pVerts; // [sp+8h] [bp-F8h] BYREF
  __int64 v43; // [sp+10h] [bp-F0h]
  __int64 v44; // [sp+18h] [bp-E8h]
  __int64 v45; // [sp+20h] [bp-E0h]
  CVector2D pClipVerts; // [sp+28h] [bp-D8h] BYREF
  float pVert; // [sp+68h] [bp-98h] BYREF
  int v48; // [sp+6Ch] [bp-94h] BYREF
  float pTc; // [sp+A8h] [bp-58h] BYREF
  int v50; // [sp+ACh] [bp-54h] BYREF
  float32x4_t v51; // 0:d22.8,8:d23.8
  float32x4_t v52; // 0:d24.8,8:d25.8
  int32x4x2_t v53; // 0:q10.16,16:q8.16
  int32x4x2_t v54; // 0:q11.16,16:q9.16

  if ( bFullMap )
  {
    top = rect->top;
    left = rect->left;
    v8 = *(_QWORD *)&rect->right;
    bottom = rect->bottom;
    right = *(float *)&v8;
    v9.n128_f32[1] = top;
    v10.n128_u32[2] = v8;
    v10.n128_u64[0] = __PAIR64__(LODWORD(bottom), LODWORD(left));
  }
  else
  {
    v10.n128_u32[0] = LODWORD(rect->left);
    if ( rect->left > CRadar::m_radarRect.right )
      return;
    v10.n128_u32[2] = LODWORD(rect->right);
    if ( v10.n128_f32[2] < CRadar::m_radarRect.left )
      return;
    v10.n128_u32[1] = LODWORD(rect->bottom);
    if ( v10.n128_f32[1] > CRadar::m_radarRect.top )
      return;
    v9.n128_u32[1] = LODWORD(rect->top);
    if ( v9.n128_f32[1] < CRadar::m_radarRect.bottom )
      return;
    left = rect->left;
    right = rect->right;
    bottom = rect->bottom;
    top = v9.n128_f32[1];
  }
  v10.n128_f32[3] = bottom;
  v9.n128_u64[1] = __PAIR64__(LODWORD(top), LODWORD(left));
  v9.n128_f32[0] = right;
  v11 = &gTransformCos;
  v12 = &gTransformSin;
  v13.n128_u64[0] = (unsigned __int64)CRadar::vec2DRadarOrigin;
  v52 = (float32x4_t)vld1q_dup_f32(v12);
  *(CVector2D *)&v13.n128_i8[8] = CRadar::vec2DRadarOrigin;
  v51 = (float32x4_t)vld1q_dup_f32(v11);
  v14 = vmulq_n_f32(vsubq_f32(v10, v13), 1.0 / CRadar::m_radarRange);
  v15 = vmulq_n_f32(vsubq_f32(v9, v13), 1.0 / CRadar::m_radarRange);
  v16 = vrev64q_s32(v14);
  v17 = vmulq_f32(v51, v14);
  v18 = vrev64q_s32(v15);
  v19 = vmulq_f32(v51, v15);
  v20 = vmulq_f32(v52, v16);
  v21 = vmulq_f32(v52, v18);
  v53 = vtrnq_s32(vrev64q_s32(vaddq_f32(v17, v20)), vsubq_f32(v17, v20));
  v54 = vtrnq_s32(vrev64q_s32(vaddq_f32(v19, v21)), vsubq_f32(v19, v21));
  pVerts = (CVector2D)v53.val[1].n128_u64[0];
  v43 = v53.val[1].n128_i64[1];
  v44 = v54.val[1].n128_i64[0];
  v45 = v54.val[1].n128_i64[1];
  v22 = CRadar::ClipRadarPoly(&pClipVerts, &pVerts);
  v23 = v22;
  if ( v22 )
  {
    if ( v22 >= 1 )
    {
      v24 = (float *)&v50;
      v25 = v22;
      p_y = &pClipVerts.y;
      DisplayingMap = gMobileMenu.DisplayingMap;
      v28 = (float *)&v48;
      v29 = (float)RsGlobal.screenHeight / 448.0;
      v30 = gMobileMenu.DisplayingMap;
      do
      {
        v31 = *(p_y - 1);
        v32 = *p_y;
        if ( v30 << 24 )
        {
          v33 = v32 * gMobileMenu.NEW_MAP_SCALE;
          MAP_OFFSET_Y = gMobileMenu.MAP_OFFSET_Y;
          v35 = gMobileMenu.MAP_OFFSET_X + (float)(v31 * gMobileMenu.NEW_MAP_SCALE);
          *(v28 - 1) = v35;
        }
        else
        {
          v36 = CTouchInterface::m_pWidgets[161];
          if ( !CTouchInterface::m_pWidgets[161] )
            goto LABEL_13;
          v35 = (float)((float)(CTouchInterface::m_pWidgets[161]->m_RectScreen.left
                              + CTouchInterface::m_pWidgets[161]->m_RectScreen.right)
                      * 0.5)
              + (float)((float)(v31
                              * fabsf(
                                  CTouchInterface::m_pWidgets[161]->m_RectScreen.right
                                - CTouchInterface::m_pWidgets[161]->m_RectScreen.left))
                      * 0.5);
          *(v28 - 1) = v35;
          v37 = v36->m_RectScreen.top;
          v38 = v36->m_RectScreen.bottom;
          v39 = fabsf(v37 - v38);
          MAP_OFFSET_Y = (float)(v37 + v38) * 0.5;
          v33 = (float)(v32 * v39) * 0.5;
        }
        v40 = MAP_OFFSET_Y - v33;
        *v28 = v40;
        if ( !(DisplayingMap << 24) )
        {
          DisplayingMap = 0;
LABEL_13:
          v30 = 0;
          goto LABEL_14;
        }
        v30 = DisplayingMap;
        v41 = *(v24 - 1) * v29;
        *(v28 - 1) = v35 * v29;
        *v28 = v40 * v29;
        *(v24 - 1) = v41;
        *v24 = *v24 * v29;
LABEL_14:
        p_y += 2;
        v24 += 2;
        v28 += 2;
        --v25;
      }
      while ( v25 );
    }
    RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
    CSprite2d::SetVertices(v23, &pVert, &pTc, rgba);
    if ( v23 >= 3 )
      RwIm2DRenderIndexedPrimitive_BUGFIX(rwPRIMTYPETRILIST, CSprite2d::maVertices, 8, fanIndices, 3 * v23 - 6);
  }
}
// 0: using guessed type int dword_0;
// FC: using guessed type int elf_hash_bucket[16411];

//----- (00443F30) --------------------------------------------------------
void __fastcall CRadar::DrawRadarGangOverlay(bool bFullMap)
{
  char v1; // r0
  bool v2; // zf
  int v3; // r6
  Int16 *i; // r5
  int v5; // r0
  int v6; // r4
  CZoneInfo *v7; // r11
  unsigned __int16 *v8; // r11
  char v9; // t1
  int v10; // r0
  float v11; // s0
  int v12; // r0
  float v13; // s0
  int v14; // r0
  float v15; // s0
  unsigned int v16; // r0
  int v17; // r0
  CZoneInfo *v18; // r0
  CRGBA *v19; // r4
  uint32 *v20; // r0
  float v21; // s0
  CZoneInfo *v22; // r0
  CRGBA v24; // [sp+18h] [bp-38h] BYREF
  CRGBA v25; // [sp+1Ch] [bp-34h] BYREF

  v1 = `guard variable for'CRadar::DrawRadarGangOverlay(bool)::rect;
  __dmb(0xBu);
  if ( (v1 & 1) == 0 && _cxa_guard_acquire((__guard *)&`guard variable for'CRadar::DrawRadarGangOverlay(bool)::rect) )
  {
    *(_QWORD *)&CRadar::DrawRadarGangOverlay(bool)::rect.left = 0xC974240049742400LL;
    *(_QWORD *)&CRadar::DrawRadarGangOverlay(bool)::rect.right = 0x49742400C9742400LL;
    _cxa_guard_release((__guard *)&`guard variable for'CRadar::DrawRadarGangOverlay(bool)::rect);
  }
  if ( CGangWars::bGangWarsActive )
  {
    v2 = gMobileMenu.screenStack.numEntries == 0;
    if ( !gMobileMenu.screenStack.numEntries )
      v2 = gMobileMenu.pendingScreen == 0;
    if ( (!v2 || !CTouchInterface::m_pWidgets[161] || CTouchInterface::m_pWidgets[161]->m_Color._anon_0._anon_0.alpha)
      && CTheZones::TotalNumberOfNavigationZones )
    {
      v3 = 0;
      for ( i = &CTheZones::NavigationZoneArray[0].x1; ; i += 16 )
      {
        v5 = (unsigned __int16)i[6];
        if ( !i[6] )
          goto LABEL_23;
        v6 = v5;
        v7 = &CTheZones::ZoneInfoArray[v5];
        v9 = *((_BYTE *)v7 + 15);
        v8 = (unsigned __int16 *)((char *)v7 + 15);
        if ( (v9 & 0x60) == 0 || !CGangWars::CanPlayerStartAGangWarHere(&CTheZones::ZoneInfoArray[v6]) )
          goto LABEL_23;
        v10 = i[3];
        CRadar::DrawRadarGangOverlay(bool)::rect.left = (float)*i;
        v11 = (float)v10;
        v12 = i[4];
        CRadar::DrawRadarGangOverlay(bool)::rect.right = v11;
        v13 = (float)v12;
        v14 = i[1];
        CRadar::DrawRadarGangOverlay(bool)::rect.top = v13;
        v15 = (float)v14;
        v16 = *v8;
        CRadar::DrawRadarGangOverlay(bool)::rect.bottom = v15;
        v17 = (v16 >> 5) & 3;
        if ( v17 == 2 )
          break;
        if ( v17 == 1 )
        {
          v18 = &CTheZones::ZoneInfoArray[v6];
          v19 = &v25;
          CRGBA::CRGBA(&v25, v18->RadarRed, v18->RadarGreen, v18->RadarBlue, v18->RadarAlpha);
LABEL_22:
          CRadar::DrawAreaOnRadar(&CRadar::DrawRadarGangOverlay(bool)::rect, v19, bFullMap);
        }
LABEL_23:
        if ( ++v3 >= CTheZones::TotalNumberOfNavigationZones )
          return;
      }
      v20 = &CTimer::m_snTimeInMillisecondsPauseMode;
      if ( !gMobileMenu.DisplayingMap )
        v20 = &CTimer::m_snTimeInMilliseconds;
      v21 = sinf((float)(*v20 & 0x3FF) * 0.0061359);
      v22 = &CTheZones::ZoneInfoArray[v6];
      v19 = &v24;
      CRGBA::CRGBA(
        &v24,
        v22->RadarRed,
        v22->RadarGreen,
        v22->RadarBlue,
        (unsigned int)(float)((float)((float)(v21 * 0.5) + 0.5) * (float)v22->RadarAlpha));
      goto LABEL_22;
    }
  }
}
// 994F10: using guessed type char `guard variable for'CRadar::DrawRadarGangOverlay(bool)::rect;

//----- (004441A0) --------------------------------------------------------
void CRadar::DrawRadarMask()
{
  unsigned int v0; // r4
  _BOOL4 DisplayingMap; // r0
  float NEW_MAP_SCALE; // s6
  float MAP_OFFSET_Y; // s0
  float v4; // s4
  float v5; // s2
  CWidget *v6; // r3
  float v7; // s6
  float top; // s0
  float bottom; // s2
  float v10; // s4
  float v11; // r0
  int v12; // r1
  float *v13; // r0
  float v14; // s22
  float v15; // s24
  _BOOL4 v16; // r6
  float v17; // s0
  float v18; // s2
  float v19; // s2
  float v20; // s6
  float *v21; // r10
  int v22; // r11
  float v23; // r4
  float v24; // r0
  float v25; // s0
  float v26; // s2
  float v27; // s0
  float v28; // s2
  CWidget *v29; // r0
  float v30; // s2
  float v31; // s4
  float v32; // s6
  int v33; // [sp+1Ch] [bp-ACh]
  float pVert[2]; // [sp+20h] [bp-A8h] BYREF
  int v35; // [sp+28h] [bp-A0h] BYREF
  _QWORD v36[13]; // [sp+60h] [bp-68h] BYREF

  v0 = 0;
  v36[0] = 0x3F800000BF800000LL;
  v36[1] = 0x3F8000003F800000LL;
  v36[2] = 0xBF8000003F800000LL;
  v36[3] = 0xBF800000BF800000LL;
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
  RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
  RwRenderStateSet(rwRENDERSTATESHADEMODE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEALPHATESTFUNCTION, byte_8);
  DisplayingMap = gMobileMenu.DisplayingMap;
  do
  {
    if ( DisplayingMap )
    {
      NEW_MAP_SCALE = gMobileMenu.NEW_MAP_SCALE;
      MAP_OFFSET_Y = gMobileMenu.MAP_OFFSET_Y;
      v4 = *((float *)&v36[v0 / 8] + 1);
      pVert[v0 / 4] = gMobileMenu.MAP_OFFSET_X + (float)(*(float *)&v36[v0 / 8] * gMobileMenu.NEW_MAP_SCALE);
      v5 = v4 * NEW_MAP_SCALE;
    }
    else
    {
      v6 = CTouchInterface::m_pWidgets[161];
      if ( !CTouchInterface::m_pWidgets[161] )
        goto LABEL_7;
      v7 = *((float *)&v36[v0 / 8] + 1);
      pVert[v0 / 4] = (float)((float)(CTouchInterface::m_pWidgets[161]->m_RectScreen.left
                                    + CTouchInterface::m_pWidgets[161]->m_RectScreen.right)
                            * 0.5)
                    + (float)((float)(*(float *)&v36[v0 / 8]
                                    * fabsf(
                                        CTouchInterface::m_pWidgets[161]->m_RectScreen.right
                                      - CTouchInterface::m_pWidgets[161]->m_RectScreen.left))
                            * 0.5);
      top = v6->m_RectScreen.top;
      bottom = v6->m_RectScreen.bottom;
      v10 = fabsf(top - bottom);
      MAP_OFFSET_Y = (float)(top + bottom) * 0.5;
      v5 = (float)(v7 * v10) * 0.5;
    }
    pVert[v0 / 4 + 1] = MAP_OFFSET_Y - v5;
LABEL_7:
    v0 += 8;
  }
  while ( v0 != 32 );
  v11 = RwIm2DGetFarScreenZ();
  CSprite2d::SetMaskVertices(4, pVert, v11);
  RwIm2DRenderIndexedPrimitive_BUGFIX(rwPRIMTYPETRILIST, CSprite2d::maVertices, 4, fanIndices, 6);
  v12 = 0;
  do
  {
    v33 = v12;
    v13 = (float *)&v36[v12];
    v14 = *v13;
    v15 = v13[1];
    v16 = gMobileMenu.DisplayingMap;
    if ( gMobileMenu.DisplayingMap )
    {
      v17 = gMobileMenu.MAP_OFFSET_Y;
      v18 = gMobileMenu.NEW_MAP_SCALE * v15;
      pVert[0] = gMobileMenu.MAP_OFFSET_X + (float)(gMobileMenu.NEW_MAP_SCALE * v14);
LABEL_13:
      pVert[1] = v17 - v18;
      goto LABEL_14;
    }
    if ( CTouchInterface::m_pWidgets[161] )
    {
      v19 = CTouchInterface::m_pWidgets[161]->m_RectScreen.top;
      v20 = CTouchInterface::m_pWidgets[161]->m_RectScreen.bottom;
      pVert[0] = (float)((float)(CTouchInterface::m_pWidgets[161]->m_RectScreen.left
                               + CTouchInterface::m_pWidgets[161]->m_RectScreen.right)
                       * 0.5)
               + (float)((float)(fabsf(
                                   CTouchInterface::m_pWidgets[161]->m_RectScreen.right
                                 - CTouchInterface::m_pWidgets[161]->m_RectScreen.left)
                               * v14)
                       * 0.5);
      v17 = (float)(v19 + v20) * 0.5;
      v18 = (float)(fabsf(v19 - v20) * v15) * 0.5;
      goto LABEL_13;
    }
LABEL_14:
    v21 = (float *)&v35;
    v22 = 0;
    do
    {
      v23 = cosf((float)((float)v22 * 1.5708) / 6.0);
      v24 = sinf((float)((float)v22++ * 1.5708) / 6.0);
      v25 = v24 * v15;
      v26 = v23 * v14;
      if ( v16 )
      {
        v27 = v25 * gMobileMenu.NEW_MAP_SCALE;
        *v21 = gMobileMenu.MAP_OFFSET_X + (float)(v26 * gMobileMenu.NEW_MAP_SCALE);
        v28 = gMobileMenu.MAP_OFFSET_Y;
      }
      else
      {
        v29 = CTouchInterface::m_pWidgets[161];
        if ( !CTouchInterface::m_pWidgets[161] )
          goto LABEL_20;
        *v21 = (float)((float)(CTouchInterface::m_pWidgets[161]->m_RectScreen.left
                             + CTouchInterface::m_pWidgets[161]->m_RectScreen.right)
                     * 0.5)
             + (float)((float)(v26
                             * fabsf(
                                 CTouchInterface::m_pWidgets[161]->m_RectScreen.right
                               - CTouchInterface::m_pWidgets[161]->m_RectScreen.left))
                     * 0.5);
        v30 = v29->m_RectScreen.top;
        v31 = v29->m_RectScreen.bottom;
        v32 = fabsf(v30 - v31);
        v28 = (float)(v30 + v31) * 0.5;
        v27 = (float)(v25 * v32) * 0.5;
      }
      v21[1] = v28 - v27;
LABEL_20:
      v21 += 2;
    }
    while ( v22 != 7 );
    CSprite2d::SetMaskVertices(8, pVert, CSprite2d::NearScreenZ);
    RwIm2DRenderIndexedPrimitive_BUGFIX(rwPRIMTYPETRILIST, CSprite2d::maVertices, 8, fanIndices, 18);
    v12 = v33 + 1;
  }
  while ( v33 != 3 );
  RwRenderStateSet(rwRENDERSTATEALPHATESTFUNCTION, &byte_5);
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;
// FC: using guessed type int elf_hash_bucket[16411];
// 4441A0: using guessed type _QWORD var_68[13];

//----- (00444528) --------------------------------------------------------
void __fastcall CRadar::StreamRadarSections(const CVector *posn)
{
  float x; // s18
  float v2; // r4
  float v3; // r0

  if ( !CStreaming::ms_disableStreaming )
  {
    x = posn->x;
    v2 = ceilf(11.0 - (float)((float)(posn->y + 3000.0) / 500.0));
    v3 = floorf((float)(x + 3000.0) / 500.0);
    CRadar::StreamRadarSections((int)v3, (int)v2);
  }
}

//----- (004445A8) --------------------------------------------------------
Furniture_c *__fastcall FurnitureSubGroup_c::GetFurniture(FurnitureSubGroup_c *this, int16 refId, uint8 rating)
{
  unsigned int v3; // r4
  Furniture_c *result; // r0
  List_c *p_m_furnitureList; // r5
  ListItem_c *m_head; // r0
  int i; // r6
  int v8; // s0
  int v9; // r2
  int32 NumItems; // r4
  unsigned __int16 v11; // r0

  v3 = rating;
  if ( refId < 0 )
  {
    p_m_furnitureList = &this->m_furnitureList;
    if ( rating == 255 )
    {
      NumItems = List_c::GetNumItems(&this->m_furnitureList);
      v11 = rand();
      return (Furniture_c *)List_c::GetItemOffset(
                              p_m_furnitureList,
                              1u,
                              (int)(float)((float)((float)v11 * 0.000015259) * (float)NumItems));
    }
    m_head = p_m_furnitureList->m_head;
    for ( i = 0; m_head; m_head = m_head->m_next )
    {
      if ( (unsigned int)BYTE2(m_head[1].m_next) <= rating && (unsigned int)HIBYTE(m_head[1].m_next) >= rating )
        ++i;
    }
    v8 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * (float)i);
    result = (Furniture_c *)p_m_furnitureList->m_head;
    if ( p_m_furnitureList->m_head )
    {
      v9 = 0;
      do
      {
        if ( result->m_ratingMin <= v3 && result->m_ratingMax >= v3 )
        {
          if ( v9 == v8 )
            return result;
          ++v9;
        }
        result = (Furniture_c *)result->m_next;
      }
      while ( result );
    }
    return 0;
  }
  result = (Furniture_c *)this->m_furnitureList.m_head;
  if ( !result )
    return 0;
  while ( result->m_refId != refId )
  {
    result = (Furniture_c *)result->m_next;
    if ( !result )
      return 0;
  }
  return result;
}

//----- (00444684) --------------------------------------------------------
int32 __fastcall FurnitureSubGroup_c::GetRandomId(FurnitureSubGroup_c *this, uint8 rating)
{
  List_c *p_m_furnitureList; // r5
  unsigned int v3; // r4
  ListItem_c *m_head; // r0
  int i; // r6
  int v6; // s0
  ListItem_c *ItemOffset; // r0
  int v8; // r2
  int32 NumItems; // r4
  unsigned __int16 v11; // r0

  p_m_furnitureList = &this->m_furnitureList;
  v3 = rating;
  if ( rating == 255 )
  {
    NumItems = List_c::GetNumItems(&this->m_furnitureList);
    v11 = rand();
    ItemOffset = List_c::GetItemOffset(
                   p_m_furnitureList,
                   1u,
                   (int)(float)((float)((float)v11 * 0.000015259) * (float)NumItems));
    return SHIWORD(ItemOffset[1].m_prev);
  }
  else
  {
    m_head = p_m_furnitureList->m_head;
    for ( i = 0; m_head; m_head = m_head->m_next )
    {
      if ( (unsigned int)BYTE2(m_head[1].m_next) <= rating && (unsigned int)HIBYTE(m_head[1].m_next) >= rating )
        ++i;
    }
    v6 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * (float)i);
    ItemOffset = p_m_furnitureList->m_head;
    if ( p_m_furnitureList->m_head )
    {
      v8 = 0;
      do
      {
        if ( BYTE2(ItemOffset[1].m_next) <= v3 && HIBYTE(ItemOffset[1].m_next) >= v3 )
        {
          if ( v8 == v6 )
            return SHIWORD(ItemOffset[1].m_prev);
          ++v8;
        }
        ItemOffset = ItemOffset->m_next;
      }
      while ( ItemOffset );
    }
    return -1;
  }
}

//----- (0044474C) --------------------------------------------------------
int32 __fastcall FurnitureGroup_c::Init(FurnitureGroup_c *this)
{
  return 1;
}

//----- (00444750) --------------------------------------------------------
void __fastcall FurnitureGroup_c::Exit(FurnitureGroup_c *this)
{
  List_c *m_head; // r5

  m_head = (List_c *)this->m_subGroupList.m_head;
  if ( this->m_subGroupList.m_head )
  {
    do
    {
      List_c::RemoveAll(m_head + 1);
      m_head = (List_c *)m_head->m_tail;
    }
    while ( m_head );
  }
  sub_19CBF0(&this->m_subGroupList);
}

//----- (00444774) --------------------------------------------------------
int __fastcall FurnitureGroup_c::AddSubGroup(
        FurnitureGroup_c *this,
        int32 subGroupId,
        int32 minW,
        int32 minD,
        int32 maxW,
        int32 maxD,
        bool8 onWindow,
        bool8 isTall,
        bool8 isStealable)
{
  uint16 v9; // r6
  FurnitureSubGroup_c *v10; // r2

  if ( g_currSubGroupId > 0x7Fu )
    return 0;
  v9 = g_currSubGroupId + 1;
  v10 = &g_subGroupStore[g_currSubGroupId];
  v10->m_onWindowTile = onWindow;
  v10->m_id = subGroupId;
  v10->m_isTall = isTall;
  g_currSubGroupId = v9;
  v10->m_isStealable = isStealable;
  List_c::AddItem(&this->m_subGroupList, v10);
  return 1;
}

//----- (004447D8) --------------------------------------------------------
Furniture_c *__fastcall FurnitureGroup_c::GetFurniture(
        FurnitureGroup_c *this,
        int32 subGroupId,
        int16 refId,
        uint8 rating)
{
  FurnitureSubGroup_c *i; // r0

  for ( i = (FurnitureSubGroup_c *)this->m_subGroupList.m_head; ; i = (FurnitureSubGroup_c *)i->m_next )
  {
    if ( !i )
      return 0;
    if ( i->m_id == subGroupId )
      break;
  }
  return FurnitureSubGroup_c::GetFurniture(i, refId, rating);
}

//----- (004447F4) --------------------------------------------------------
int32 __fastcall FurnitureGroup_c::GetRandomId(FurnitureGroup_c *this, int32 subGroupId, uint8 rating)
{
  FurnitureSubGroup_c *i; // r0

  for ( i = (FurnitureSubGroup_c *)this->m_subGroupList.m_head; ; i = (FurnitureSubGroup_c *)i->m_next )
  {
    if ( !i )
      return -1;
    if ( i->m_id == subGroupId )
      break;
  }
  return FurnitureSubGroup_c::GetRandomId(i, rating);
}

//----- (0044480E) --------------------------------------------------------
void __fastcall FurnitureManager_c::Exit(FurnitureManager_c *this)
{
  List_c *m_head; // r5
  List_c *i; // r6
  List_c *j; // r6
  List_c *k; // r6
  List_c *m; // r6
  List_c *n; // r6
  List_c *ii; // r6
  List_c *jj; // r6
  FurnitureGroup_c *v10; // r4
  List_c *v11; // r5
  ListItem_c *v12; // t1

  List_c::RemoveAll(&this->m_furnitureEntityPool);
  m_head = (List_c *)this->m_groups[0].m_subGroupList.m_head;
  if ( this->m_groups[0].m_subGroupList.m_head )
  {
    do
    {
      List_c::RemoveAll(m_head + 1);
      m_head = (List_c *)m_head->m_tail;
    }
    while ( m_head );
  }
  List_c::RemoveAll((List_c *)this);
  for ( i = (List_c *)this->m_groups[1].m_subGroupList.m_head; i; i = (List_c *)i->m_tail )
    List_c::RemoveAll(i + 1);
  List_c::RemoveAll(&this->m_groups[1].m_subGroupList);
  for ( j = (List_c *)this->m_groups[2].m_subGroupList.m_head; j; j = (List_c *)j->m_tail )
    List_c::RemoveAll(j + 1);
  List_c::RemoveAll(&this->m_groups[2].m_subGroupList);
  for ( k = (List_c *)this->m_groups[3].m_subGroupList.m_head; k; k = (List_c *)k->m_tail )
    List_c::RemoveAll(k + 1);
  List_c::RemoveAll(&this->m_groups[3].m_subGroupList);
  for ( m = (List_c *)this->m_groups[4].m_subGroupList.m_head; m; m = (List_c *)m->m_tail )
    List_c::RemoveAll(m + 1);
  List_c::RemoveAll(&this->m_groups[4].m_subGroupList);
  for ( n = (List_c *)this->m_groups[5].m_subGroupList.m_head; n; n = (List_c *)n->m_tail )
    List_c::RemoveAll(n + 1);
  List_c::RemoveAll(&this->m_groups[5].m_subGroupList);
  for ( ii = (List_c *)this->m_groups[6].m_subGroupList.m_head; ii; ii = (List_c *)ii->m_tail )
    List_c::RemoveAll(ii + 1);
  List_c::RemoveAll(&this->m_groups[6].m_subGroupList);
  for ( jj = (List_c *)this->m_groups[7].m_subGroupList.m_head; jj; jj = (List_c *)jj->m_tail )
    List_c::RemoveAll(jj + 1);
  List_c::RemoveAll(&this->m_groups[7].m_subGroupList);
  v12 = this->m_groups[8].m_subGroupList.m_head;
  v10 = &this->m_groups[8];
  v11 = (List_c *)v12;
  if ( v12 )
  {
    do
    {
      List_c::RemoveAll(v11 + 1);
      v11 = (List_c *)v11->m_tail;
    }
    while ( v11 );
  }
  sub_19CBF0(&v10->m_subGroupList);
}

//----- (00444920) --------------------------------------------------------
Furniture_c *__fastcall FurnitureManager_c::GetFurniture(
        FurnitureManager_c *this,
        int32 groupId,
        int32 subGroupId,
        int16 refId,
        uint8 a5)
{
  FurnitureSubGroup_c *m_head; // r0

  m_head = (FurnitureSubGroup_c *)this->m_groups[groupId].m_subGroupList.m_head;
  if ( !m_head )
    return 0;
  while ( m_head->m_id != subGroupId )
  {
    m_head = (FurnitureSubGroup_c *)m_head->m_next;
    if ( !m_head )
      return 0;
  }
  return FurnitureSubGroup_c::GetFurniture(m_head, refId, a5);
}

//----- (00444944) --------------------------------------------------------
int32 __fastcall FurnitureManager_c::GetRandomId(
        FurnitureManager_c *this,
        int32 groupId,
        int32 subGroupId,
        uint8 rating)
{
  FurnitureSubGroup_c *i; // r0

  for ( i = (FurnitureSubGroup_c *)this->m_groups[groupId].m_subGroupList.m_head; ; i = (FurnitureSubGroup_c *)i->m_next )
  {
    if ( !i )
      return -1;
    if ( i->m_id == subGroupId )
      break;
  }
  return FurnitureSubGroup_c::GetRandomId(i, rating);
}

//----- (00444964) --------------------------------------------------------
void __fastcall FurnitureManager_c::FurnitureManager_c(FurnitureManager_c *this)
{
  int i; // r5

  List_c::List_c((List_c *)this);
  List_c::List_c(&this->m_groups[1].m_subGroupList);
  List_c::List_c(&this->m_groups[2].m_subGroupList);
  List_c::List_c(&this->m_groups[3].m_subGroupList);
  List_c::List_c(&this->m_groups[4].m_subGroupList);
  List_c::List_c(&this->m_groups[5].m_subGroupList);
  List_c::List_c(&this->m_groups[6].m_subGroupList);
  List_c::List_c(&this->m_groups[7].m_subGroupList);
  List_c::List_c(&this->m_groups[8].m_subGroupList);
  for ( i = 0; i != 512; ++i )
    ListItem_c::ListItem_c(&this->m_furnitureEntities[i]);
  List_c::List_c(&this->m_furnitureEntityPool);
}

//----- (004449CE) --------------------------------------------------------
void __fastcall FurnitureManager_c::~FurnitureManager_c(FurnitureManager_c *this)
{
  int i; // r5

  List_c::~List_c(&this->m_furnitureEntityPool);
  for ( i = 8284; i != 92; i -= 16 )
    ListItem_c::~ListItem_c((ListItem_c *)((char *)this + i));
  List_c::~List_c(&this->m_groups[8].m_subGroupList);
  List_c::~List_c(&this->m_groups[7].m_subGroupList);
  List_c::~List_c(&this->m_groups[6].m_subGroupList);
  List_c::~List_c(&this->m_groups[5].m_subGroupList);
  List_c::~List_c(&this->m_groups[4].m_subGroupList);
  List_c::~List_c(&this->m_groups[3].m_subGroupList);
  List_c::~List_c(&this->m_groups[2].m_subGroupList);
  List_c::~List_c(&this->m_groups[1].m_subGroupList);
  sub_192C04((List_c *)this);
}

//----- (00444A40) --------------------------------------------------------
void __fastcall Interior_c::Interior_c(Interior_c *this)
{
  ListItem_c::ListItem_c(this);
  List_c::List_c(&this->m_furnitureEntityList);
  this->m_doorAddr.Region = -1;
  this->m_exitAddr.Region = -1;
}

//----- (00444A62) --------------------------------------------------------
void __fastcall Interior_c::~Interior_c(Interior_c *this)
{
  List_c::~List_c(&this->m_furnitureEntityList);
  sub_198660(this);
}

//----- (00444A7C) --------------------------------------------------------
int32 __fastcall Interior_c::Init(Interior_c *this, RwV3d_0 *pos)
{
  CEntity *Entity; // r0
  CEntity *v4; // r5
  const CMatrix *m_pMat; // r1
  CInteriorAttr *m_box; // r0
  unsigned int v7; // r0
  CInteriorAttr *v8; // r0
  int32 m_numStealInfosIds; // r0
  CMatrix v11; // [sp+0h] [bp-50h] BYREF

  Interior_c::CalcMatrix(this, pos);
  Interior_c::ResetTiles(this);
  Entity = InteriorGroup_c::GetEntity(this->m_pInteriorGroup);
  v4 = Entity;
  m_pMat = Entity->m_pMat;
  if ( !m_pMat )
  {
    CPlaceable::AllocateMatrix(Entity);
    CSimpleTransform::UpdateMatrix(&v4->m_transform, v4->m_pMat);
    m_pMat = v4->m_pMat;
  }
  CMatrix::CMatrix(&v11, m_pMat);
  m_box = this->m_box;
  if ( m_box->m_type != 99 )
  {
    if ( g_interiorMan.m_pEntryExit )
      v7 = m_box->m_seed
         + (int)v11.tx * (int)v11.ty * (int)v11.tz
         + (int)g_interiorMan.m_pEntryExit->rect.left
         * (int)g_interiorMan.m_pEntryExit->rect.bottom
         * (int)g_interiorMan.m_pEntryExit->pz;
    else
      v7 = (unsigned int)(float)((float)((float)(v11.tx * v11.ty) * v11.tz) + (float)m_box->m_seed);
    srand(v7);
  }
  v8 = this->m_box;
  *(_WORD *)&this->m_numGotoPts = 0;
  switch ( v8->m_type )
  {
    case 0u:
      Interior_c::FurnishShop(this, 0);
      break;
    case 1u:
      Interior_c::FurnishOffice(this);
      break;
    case 2u:
      Interior_c::FurnishLounge(this);
      break;
    case 3u:
      Interior_c::FurnishBedroom(this);
      break;
    case 4u:
      Interior_c::FurnishKitchen(this);
      break;
    default:
      break;
  }
  Interior_c::CalcExitPts(this);
  if ( !InteriorManager_c::HasInteriorHadStealDataSetup(&g_interiorMan, this) )
  {
    m_numStealInfosIds = g_interiorMan.m_numStealInfosIds;
    if ( g_interiorMan.m_numStealInfosIds <= 63 )
    {
      g_interiorMan.m_stealInfoSetupIds[g_interiorMan.m_numStealInfosIds] = this->m_id;
      g_interiorMan.m_numStealInfosIds = m_numStealInfosIds + 1;
    }
  }
  if ( (this->m_box->m_type & 0xFE) == 2 )
    Interior_c::AddPickups(this);
  CMatrix::~CMatrix(&v11);
  return 1;
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (00444BEC) --------------------------------------------------------
void __fastcall Interior_c::CalcMatrix(Interior_c *this, RwV3d_0 *pos)
{
  const RwMatrix *v2; // r4
  RwV3d_0 *p_pos; // r6
  RwV3d_0 *p_up; // r9
  RwV3d_0 *p_at; // r10
  RwMatrix *p_m_mat; // r5
  __int64 v8; // d23
  __int64 v9; // d16
  __int64 v10; // d17
  __int64 v11; // d18
  __int64 v12; // d19
  __int64 v13; // d20
  __int64 v14; // d21
  RwObject_0 *m_pRwObject; // r0
  RwMatrix v16; // [sp+0h] [bp-68h] BYREF
  RwV3d_0 axis; // [sp+40h] [bp-28h] BYREF

  v2 = 0;
  axis.z = 1.0;
  *(_QWORD *)&axis.x = unk_618CF0;
  this->m_mat.pos.x = 0.0;
  p_pos = &this->m_mat.pos;
  this->m_mat.right.y = 0.0;
  this->m_mat.right.z = 0.0;
  this->m_mat.at.y = 0.0;
  this->m_mat.at.z = 1.0;
  this->m_mat.up.y = 1.0;
  this->m_mat.up.z = 0.0;
  this->m_mat.pos.y = 0.0;
  this->m_mat.pos.z = 0.0;
  this->m_mat.up.x = 0.0;
  p_up = &this->m_mat.up;
  this->m_mat.at.x = 0.0;
  p_at = &this->m_mat.at;
  this->m_mat.right.x = 1.0;
  p_m_mat = &this->m_mat;
  this->m_mat.flags |= 0x20003u;
  RwMatrixRotate(&this->m_mat, &axis, this->m_box->m_rot, rwCOMBINEREPLACE);
  RwMatrixTranslate(p_m_mat, pos, rwCOMBINEPOSTCONCAT);
  v8 = *(_QWORD *)&p_pos->z;
  v9 = *(_QWORD *)&p_at->x;
  v10 = *(_QWORD *)&p_at->z;
  v11 = *(_QWORD *)&p_m_mat->right.x;
  v12 = *(_QWORD *)&p_m_mat->right.z;
  v13 = *(_QWORD *)&p_up->x;
  v14 = *(_QWORD *)&p_up->z;
  *(_QWORD *)&v16.pos.x = *(_QWORD *)&p_pos->x;
  *(_QWORD *)&v16.pos.z = v8;
  *(_QWORD *)&v16.at.x = v9;
  *(_QWORD *)&v16.at.z = v10;
  *(_QWORD *)&v16.right.x = v11;
  *(_QWORD *)&v16.right.z = v12;
  *(_QWORD *)&v16.up.x = v13;
  *(_QWORD *)&v16.up.z = v14;
  m_pRwObject = InteriorGroup_c::GetEntity((InteriorGroup_c *)LODWORD(p_pos[-5].x))->m_pRwObject;
  if ( m_pRwObject )
    v2 = (const RwMatrix *)((char *)m_pRwObject->parent + 16);
  RwMatrixMultiply(p_m_mat, &v16, v2);
}

//----- (00444CC0) --------------------------------------------------------
void __fastcall Interior_c::ResetTiles(Interior_c *this)
{
  int v1; // r4
  unsigned int m_depth; // r2
  CInteriorAttr *m_box; // r6
  signed int m_lDoorStart; // r0
  int m_lDoorEnd; // r1
  bool v7; // cc
  unsigned int v8; // r12
  int32x4_t v9; // q13
  int32x4_t v10; // q8
  int32x4_t v11; // q9
  int32x4_t v12; // q10
  int32x4_t v13; // q11
  unsigned int v14; // r3
  int32x4_t v15; // q12
  int32x4_t v16; // q0
  int32x4_t v17; // q15
  uint8 *v18; // r5
  int32x4_t v24; // q0
  int32x4_t v25; // q15
  unsigned int v26; // r1
  uint8 *v27; // r0
  unsigned int m_rDoorStart; // r0
  int m_rDoorEnd; // r8
  unsigned int v30; // r10
  int m_width; // lr
  unsigned int v32; // r12
  int32x4_t v33; // q13
  int32x4_t v34; // q8
  int32x4_t v35; // q9
  int32x4_t v36; // q10
  int32x4_t v37; // q11
  int32x4_t v38; // q12
  int32x4_t v39; // q0
  int32x4_t v40; // q15
  char *v41; // r3
  char *v42; // r1
  int32x4_t v45; // q0
  int32x4_t v46; // q15
  unsigned int v47; // r1
  _BYTE *v48; // r0
  int m_tDoorStart; // r1
  int m_tDoorEnd; // r3
  int v51; // r0
  unsigned int v52; // r1
  _BYTE *v53; // r1
  signed int m_lWindowStart; // r0
  int m_lWindowEnd; // r1
  bool v56; // cc
  unsigned int v57; // r12
  int32x4_t v58; // q13
  int32x4_t v59; // q8
  int32x4_t v60; // q9
  int32x4_t v61; // q10
  int32x4_t v62; // q11
  unsigned int v63; // r3
  int32x4_t v64; // q12
  int32x4_t v65; // q0
  int32x4_t v66; // q15
  uint8 *v67; // r5
  int32x4_t v70; // q0
  int32x4_t v71; // q15
  unsigned int v72; // r1
  uint8 *v73; // r0
  unsigned int m_rWindowStart; // r0
  int m_rWindowEnd; // r8
  unsigned int v76; // r10
  int v77; // lr
  unsigned int v78; // r12
  int32x4_t v79; // q13
  int32x4_t v80; // q8
  unsigned int v81; // r2
  int32x4_t v82; // q9
  int32x4_t v83; // q10
  int32x4_t v84; // q11
  int32x4_t v85; // q12
  int32x4_t v86; // q0
  int32x4_t v87; // q15
  char *v88; // r3
  char *v89; // r1
  int32x4_t v92; // q0
  int32x4_t v93; // q15
  unsigned int v94; // r1
  _BYTE *v95; // r0
  int m_tWindowStart; // r1
  int m_tWindowEnd; // r2
  int v98; // r0
  int v99; // r3
  _BYTE *v100; // r1
  int32x4_t v101; // q12
  int32x4_t v102; // q8
  int v103; // lr
  int32x4_t v104; // q9
  int32x4_t v105; // q10
  unsigned int v106; // r2
  int32x4_t v107; // q11
  CInteriorAttr *v108; // r3
  char *v109; // r6
  int v110; // r12
  int v112; // r8
  int32x4_t v113; // q13
  unsigned int v114; // r10
  uint8 *v115; // r5
  char v116; // r11
  unsigned int v117; // r6
  int32x4_t v118; // q14
  int v119; // r3
  int32x4_t v120; // q15
  unsigned int v121; // r6
  int32x4_t v122; // q0
  int32x4_t v123; // q1
  int32x4_t v124; // q4
  int32x4_t v125; // q3
  char *v126; // r8
  char *v127; // r12
  int32x4_t v130; // q4
  int32x4_t v131; // q3
  int v132; // r3
  uint8 *v133; // r6
  uint8 (*m_tiles)[30]; // [sp+0h] [bp-40h]
  int v135; // [sp+4h] [bp-3Ch]
  int v136; // [sp+8h] [bp-38h]
  int v137; // [sp+Ch] [bp-34h]

  m_tiles = this->m_tiles;
  memset(this->m_tiles, 0, sizeof(this->m_tiles));
  m_box = this->m_box;
  m_lDoorStart = m_box->m_lDoorStart;
  m_lDoorEnd = m_lDoorStart + 1;
  if ( m_lDoorStart != -1 )
  {
    v7 = m_lDoorStart < 0;
    if ( m_lDoorStart >= 0 )
    {
      m_lDoorEnd = m_box->m_lDoorEnd;
      m_depth = m_lDoorEnd - m_lDoorStart;
      v7 = m_lDoorEnd - m_lDoorStart < 1;
    }
    if ( !v7 && m_box->m_width && m_lDoorEnd <= m_box->m_depth )
    {
      if ( m_depth >= 0x10 && (v8 = m_depth & 0xFFFFFFF0, (m_depth & 0xFFFFFFF0) != 0) )
      {
        v9.n128_u64[0] = 0x1000000010LL;
        v9.n128_u64[1] = 0x1000000010LL;
        v10.n128_u64[0] = 0xD0000000CLL;
        v10.n128_u64[1] = 0xF0000000ELL;
        v11.n128_u64[0] = 0x900000008LL;
        v11.n128_u64[1] = 0xB0000000ALL;
        v12.n128_u64[0] = 0x500000004LL;
        v12.n128_u64[1] = 0x700000006LL;
        v13.n128_u64[0] = 0x100000000LL;
        v13.n128_u64[1] = 0x300000002LL;
        v14 = m_depth & 0xFFFFFFF0;
        v15 = vdupq_n_s32(m_lDoorStart);
        do
        {
          v16 = vaddq_s32(v13, v15);
          v17 = vaddq_s32(v12, v15);
          v12 = vaddq_s32(v12, v9);
          v13 = vaddq_s32(v13, v9);
          v18 = &this->m_tiles[0][v16.n128_u32[0]];
          _Q14 = *(_OWORD *)v18;
          __asm { VCEQ.I8         Q14, Q14, #0 }
          LOBYTE(v1) = 0;
          if ( (unsigned __int8)_Q14 << 31 )
            *v18 = 8;
          if ( BYTE1(_Q14) << 31 )
            this->m_tiles[0][v16.n128_u32[1]] = 8;
          if ( BYTE2(_Q14) << 31 )
            this->m_tiles[0][v16.n128_u32[2]] = 8;
          if ( BYTE3(_Q14) << 31 )
            this->m_tiles[0][v16.n128_u32[3]] = 8;
          v24 = vaddq_s32(v11, v15);
          v11 = vaddq_s32(v11, v9);
          if ( BYTE4(_Q14) << 31 )
            this->m_tiles[0][v17.n128_u32[0]] = 8;
          if ( BYTE5(_Q14) << 31 )
            this->m_tiles[0][v17.n128_u32[1]] = 8;
          if ( BYTE6(_Q14) << 31 )
            this->m_tiles[0][v17.n128_u32[2]] = 8;
          if ( BYTE7(_Q14) << 31 )
            this->m_tiles[0][v17.n128_u32[3]] = 8;
          v25 = vaddq_s32(v10, v15);
          v10 = vaddq_s32(v10, v9);
          if ( BYTE8(_Q14) << 31 )
            this->m_tiles[0][v24.n128_u32[0]] = 8;
          if ( BYTE9(_Q14) << 31 )
            this->m_tiles[0][v24.n128_u32[1]] = 8;
          if ( BYTE10(_Q14) << 31 )
            this->m_tiles[0][v24.n128_u32[2]] = 8;
          if ( BYTE11(_Q14) << 31 )
            this->m_tiles[0][v24.n128_u32[3]] = 8;
          if ( BYTE12(_Q14) << 31 )
            this->m_tiles[0][v25.n128_u32[0]] = 8;
          if ( BYTE13(_Q14) << 31 )
            this->m_tiles[0][v25.n128_u32[1]] = 8;
          if ( BYTE14(_Q14) << 31 )
            this->m_tiles[0][v25.n128_u32[2]] = 8;
          if ( HIBYTE(_Q14) << 31 )
            this->m_tiles[0][v25.n128_u32[3]] = 8;
          v14 -= 16;
        }
        while ( v14 );
        if ( m_depth == v8 )
          goto LABEL_50;
      }
      else
      {
        v8 = 0;
      }
      m_depth = 8;
      v26 = m_lDoorEnd - v8 - m_lDoorStart;
      v27 = &this->m_tiles[0][m_lDoorStart + v8];
      do
      {
        if ( !*v27 )
          *v27 = 8;
        --v26;
        ++v27;
      }
      while ( v26 );
LABEL_50:
      m_box = this->m_box;
    }
  }
  m_rDoorStart = m_box->m_rDoorStart;
  if ( m_rDoorStart != -1 )
  {
    m_rDoorEnd = m_box->m_rDoorEnd;
    v30 = m_rDoorEnd - m_rDoorStart;
    if ( (int)(m_rDoorEnd - m_rDoorStart) >= 1 )
    {
      m_width = m_box->m_width;
      if ( (((m_width - 1) | m_rDoorStart) & 0x80000000) == 0 && m_rDoorEnd <= m_box->m_depth )
      {
        if ( v30 >= 0x10 && (v32 = v30 & 0xFFFFFFF0, (v30 & 0xFFFFFFF0) != 0) )
        {
          v33.n128_u64[0] = 0x1000000010LL;
          v33.n128_u64[1] = 0x1000000010LL;
          v34.n128_u64[0] = 0xD0000000CLL;
          v34.n128_u64[1] = 0xF0000000ELL;
          m_depth = v30 & 0xFFFFFFF0;
          v35.n128_u64[0] = 0x900000008LL;
          v35.n128_u64[1] = 0xB0000000ALL;
          v36.n128_u64[0] = 0x500000004LL;
          v36.n128_u64[1] = 0x700000006LL;
          v37.n128_u64[0] = 0x100000000LL;
          v37.n128_u64[1] = 0x300000002LL;
          v38 = vdupq_n_s32(m_rDoorStart);
          do
          {
            v39 = vaddq_s32(v37, v38);
            v40 = vaddq_s32(v36, v38);
            v41 = (char *)this + 30 * m_width - 30;
            v36 = vaddq_s32(v36, v33);
            v37 = vaddq_s32(v37, v33);
            v42 = &v41[v39.n128_u32[0] + 104];
            _Q14 = *(_OWORD *)v42;
            __asm { VCEQ.I8         Q14, Q14, #0 }
            LOBYTE(v1) = 0;
            if ( (unsigned __int8)_Q14 << 31 )
              *v42 = 8;
            if ( BYTE1(_Q14) << 31 )
              v41[v39.n128_u32[1] + 104] = 8;
            if ( BYTE2(_Q14) << 31 )
              v41[v39.n128_u32[2] + 104] = 8;
            if ( BYTE3(_Q14) << 31 )
              v41[v39.n128_u32[3] + 104] = 8;
            v45 = vaddq_s32(v35, v38);
            v35 = vaddq_s32(v35, v33);
            if ( BYTE4(_Q14) << 31 )
              v41[v40.n128_u32[0] + 104] = 8;
            if ( BYTE5(_Q14) << 31 )
              v41[v40.n128_u32[1] + 104] = 8;
            if ( BYTE6(_Q14) << 31 )
              v41[v40.n128_u32[2] + 104] = 8;
            if ( BYTE7(_Q14) << 31 )
              v41[v40.n128_u32[3] + 104] = 8;
            v46 = vaddq_s32(v34, v38);
            v34 = vaddq_s32(v34, v33);
            if ( BYTE8(_Q14) << 31 )
              v41[v45.n128_u32[0] + 104] = 8;
            if ( BYTE9(_Q14) << 31 )
              v41[v45.n128_u32[1] + 104] = 8;
            if ( BYTE10(_Q14) << 31 )
              v41[v45.n128_u32[2] + 104] = 8;
            if ( BYTE11(_Q14) << 31 )
              v41[v45.n128_u32[3] + 104] = 8;
            if ( BYTE12(_Q14) << 31 )
              v41[v46.n128_u32[0] + 104] = 8;
            if ( BYTE13(_Q14) << 31 )
              v41[v46.n128_u32[1] + 104] = 8;
            if ( BYTE14(_Q14) << 31 )
              v41[v46.n128_u32[2] + 104] = 8;
            if ( HIBYTE(_Q14) << 31 )
              v41[v46.n128_u32[3] + 104] = 8;
            m_depth -= 16;
          }
          while ( m_depth );
          if ( v30 == v32 )
            goto LABEL_98;
        }
        else
        {
          v32 = 0;
        }
        v47 = m_rDoorEnd - v32 - m_rDoorStart;
        m_depth = 8;
        v48 = (char *)&this->m_mat.pos.x + 30 * m_width + m_rDoorStart + v32 + 2;
        do
        {
          if ( !*v48 )
            *v48 = 8;
          --v47;
          ++v48;
        }
        while ( v47 );
LABEL_98:
        m_box = this->m_box;
      }
    }
  }
  m_tDoorStart = m_box->m_tDoorStart;
  if ( m_tDoorStart != -1 )
  {
    m_tDoorEnd = m_box->m_tDoorEnd;
    v51 = m_tDoorEnd - m_tDoorStart;
    if ( m_tDoorEnd - m_tDoorStart >= 1 )
    {
      m_depth = m_box->m_depth;
      if ( (((m_depth - 1) | m_tDoorStart) & 0x80000000) == 0 && m_tDoorEnd <= m_box->m_width )
      {
        v52 = m_depth + 30 * m_tDoorStart;
        m_depth = 8;
        v53 = (char *)&this->m_furnitureEntityList.m_numItems + v52 + 3;
        do
        {
          if ( !*v53 )
            *v53 = 8;
          --v51;
          v53 += 30;
        }
        while ( v51 );
        m_box = this->m_box;
      }
    }
  }
  m_lWindowStart = m_box->m_lWindowStart;
  m_lWindowEnd = m_lWindowStart + 1;
  if ( m_lWindowStart != -1 )
  {
    v56 = m_lWindowStart < 0;
    if ( m_lWindowStart >= 0 )
    {
      m_lWindowEnd = m_box->m_lWindowEnd;
      m_depth = m_lWindowEnd - m_lWindowStart;
      v56 = m_lWindowEnd - m_lWindowStart < 1;
    }
    if ( !v56 && m_box->m_width && m_lWindowEnd <= m_box->m_depth )
    {
      if ( m_depth >= 0x10 && (v57 = m_depth & 0xFFFFFFF0, (m_depth & 0xFFFFFFF0) != 0) )
      {
        v58.n128_u64[0] = 0x1000000010LL;
        v58.n128_u64[1] = 0x1000000010LL;
        v59.n128_u64[0] = 0xD0000000CLL;
        v59.n128_u64[1] = 0xF0000000ELL;
        v60.n128_u64[0] = 0x900000008LL;
        v60.n128_u64[1] = 0xB0000000ALL;
        v61.n128_u64[0] = 0x500000004LL;
        v61.n128_u64[1] = 0x700000006LL;
        v62.n128_u64[0] = 0x100000000LL;
        v62.n128_u64[1] = 0x300000002LL;
        v63 = m_depth & 0xFFFFFFF0;
        v64 = vdupq_n_s32(m_lWindowStart);
        do
        {
          v65 = vaddq_s32(v62, v64);
          v66 = vaddq_s32(v61, v64);
          v61 = vaddq_s32(v61, v58);
          v62 = vaddq_s32(v62, v58);
          v67 = &this->m_tiles[0][v65.n128_u32[0]];
          _Q14 = *(_OWORD *)v67;
          __asm { VCEQ.I8         Q14, Q14, #0 }
          LOBYTE(v1) = 0;
          if ( (unsigned __int8)_Q14 << 31 )
            *v67 = 9;
          if ( BYTE1(_Q14) << 31 )
            this->m_tiles[0][v65.n128_u32[1]] = 9;
          if ( BYTE2(_Q14) << 31 )
            this->m_tiles[0][v65.n128_u32[2]] = 9;
          if ( BYTE3(_Q14) << 31 )
            this->m_tiles[0][v65.n128_u32[3]] = 9;
          v70 = vaddq_s32(v60, v64);
          v60 = vaddq_s32(v60, v58);
          if ( BYTE4(_Q14) << 31 )
            this->m_tiles[0][v66.n128_u32[0]] = 9;
          if ( BYTE5(_Q14) << 31 )
            this->m_tiles[0][v66.n128_u32[1]] = 9;
          if ( BYTE6(_Q14) << 31 )
            this->m_tiles[0][v66.n128_u32[2]] = 9;
          if ( BYTE7(_Q14) << 31 )
            this->m_tiles[0][v66.n128_u32[3]] = 9;
          v71 = vaddq_s32(v59, v64);
          v59 = vaddq_s32(v59, v58);
          if ( BYTE8(_Q14) << 31 )
            this->m_tiles[0][v70.n128_u32[0]] = 9;
          if ( BYTE9(_Q14) << 31 )
            this->m_tiles[0][v70.n128_u32[1]] = 9;
          if ( BYTE10(_Q14) << 31 )
            this->m_tiles[0][v70.n128_u32[2]] = 9;
          if ( BYTE11(_Q14) << 31 )
            this->m_tiles[0][v70.n128_u32[3]] = 9;
          if ( BYTE12(_Q14) << 31 )
            this->m_tiles[0][v71.n128_u32[0]] = 9;
          if ( BYTE13(_Q14) << 31 )
            this->m_tiles[0][v71.n128_u32[1]] = 9;
          if ( BYTE14(_Q14) << 31 )
            this->m_tiles[0][v71.n128_u32[2]] = 9;
          if ( HIBYTE(_Q14) << 31 )
            this->m_tiles[0][v71.n128_u32[3]] = 9;
          v63 -= 16;
        }
        while ( v63 );
        if ( m_depth == v57 )
          goto LABEL_157;
      }
      else
      {
        v57 = 0;
      }
      v72 = m_lWindowEnd - v57 - m_lWindowStart;
      v73 = &this->m_tiles[0][m_lWindowStart + v57];
      do
      {
        if ( !*v73 )
          *v73 = 9;
        --v72;
        ++v73;
      }
      while ( v72 );
LABEL_157:
      m_box = this->m_box;
    }
  }
  m_rWindowStart = m_box->m_rWindowStart;
  if ( m_rWindowStart != -1 )
  {
    m_rWindowEnd = m_box->m_rWindowEnd;
    v76 = m_rWindowEnd - m_rWindowStart;
    if ( (int)(m_rWindowEnd - m_rWindowStart) >= 1 )
    {
      v77 = m_box->m_width;
      if ( (((v77 - 1) | m_rWindowStart) & 0x80000000) == 0 && m_rWindowEnd <= m_box->m_depth )
      {
        if ( v76 >= 0x10 && (v78 = v76 & 0xFFFFFFF0, (v76 & 0xFFFFFFF0) != 0) )
        {
          v79.n128_u64[0] = 0x1000000010LL;
          v79.n128_u64[1] = 0x1000000010LL;
          v80.n128_u64[0] = 0xD0000000CLL;
          v80.n128_u64[1] = 0xF0000000ELL;
          v81 = v76 & 0xFFFFFFF0;
          v82.n128_u64[0] = 0x900000008LL;
          v82.n128_u64[1] = 0xB0000000ALL;
          v83.n128_u64[0] = 0x500000004LL;
          v83.n128_u64[1] = 0x700000006LL;
          v84.n128_u64[0] = 0x100000000LL;
          v84.n128_u64[1] = 0x300000002LL;
          v85 = vdupq_n_s32(m_rWindowStart);
          do
          {
            v86 = vaddq_s32(v84, v85);
            v87 = vaddq_s32(v83, v85);
            v88 = (char *)this + 30 * v77 - 30;
            v83 = vaddq_s32(v83, v79);
            v84 = vaddq_s32(v84, v79);
            v89 = &v88[v86.n128_u32[0] + 104];
            _Q14 = *(_OWORD *)v89;
            __asm { VCEQ.I8         Q14, Q14, #0 }
            LOBYTE(v1) = 0;
            if ( (unsigned __int8)_Q14 << 31 )
              *v89 = 9;
            if ( BYTE1(_Q14) << 31 )
              v88[v86.n128_u32[1] + 104] = 9;
            if ( BYTE2(_Q14) << 31 )
              v88[v86.n128_u32[2] + 104] = 9;
            if ( BYTE3(_Q14) << 31 )
              v88[v86.n128_u32[3] + 104] = 9;
            v92 = vaddq_s32(v82, v85);
            v82 = vaddq_s32(v82, v79);
            if ( BYTE4(_Q14) << 31 )
              v88[v87.n128_u32[0] + 104] = 9;
            if ( BYTE5(_Q14) << 31 )
              v88[v87.n128_u32[1] + 104] = 9;
            if ( BYTE6(_Q14) << 31 )
              v88[v87.n128_u32[2] + 104] = 9;
            if ( BYTE7(_Q14) << 31 )
              v88[v87.n128_u32[3] + 104] = 9;
            v93 = vaddq_s32(v80, v85);
            v80 = vaddq_s32(v80, v79);
            if ( BYTE8(_Q14) << 31 )
              v88[v92.n128_u32[0] + 104] = 9;
            if ( BYTE9(_Q14) << 31 )
              v88[v92.n128_u32[1] + 104] = 9;
            if ( BYTE10(_Q14) << 31 )
              v88[v92.n128_u32[2] + 104] = 9;
            if ( BYTE11(_Q14) << 31 )
              v88[v92.n128_u32[3] + 104] = 9;
            if ( BYTE12(_Q14) << 31 )
              v88[v93.n128_u32[0] + 104] = 9;
            if ( BYTE13(_Q14) << 31 )
              v88[v93.n128_u32[1] + 104] = 9;
            if ( BYTE14(_Q14) << 31 )
              v88[v93.n128_u32[2] + 104] = 9;
            if ( HIBYTE(_Q14) << 31 )
              v88[v93.n128_u32[3] + 104] = 9;
            v81 -= 16;
          }
          while ( v81 );
          if ( v76 == v78 )
            goto LABEL_205;
        }
        else
        {
          v78 = 0;
        }
        v94 = m_rWindowEnd - v78 - m_rWindowStart;
        v95 = (char *)&this->m_mat.pos.x + 30 * v77 + m_rWindowStart + v78 + 2;
        do
        {
          if ( !*v95 )
            *v95 = 9;
          --v94;
          ++v95;
        }
        while ( v94 );
LABEL_205:
        m_box = this->m_box;
      }
    }
  }
  m_tWindowStart = m_box->m_tWindowStart;
  if ( m_tWindowStart != -1 )
  {
    m_tWindowEnd = m_box->m_tWindowEnd;
    v98 = m_tWindowEnd - m_tWindowStart;
    if ( m_tWindowEnd - m_tWindowStart >= 1 )
    {
      v99 = m_box->m_depth;
      if ( ((v99 - 1) | m_tWindowStart) >= 0 && m_tWindowEnd <= m_box->m_width )
      {
        v100 = (char *)&this->m_furnitureEntityList.m_numItems + 30 * m_tWindowStart + v99 + 3;
        do
        {
          if ( !*v100 )
            *v100 = 9;
          --v98;
          v100 += 30;
        }
        while ( v98 );
      }
    }
  }
  v101.n128_u64[0] = 0x1000000010LL;
  v101.n128_u64[1] = 0x1000000010LL;
  v102.n128_u64[0] = 0xD0000000CLL;
  v102.n128_u64[1] = 0xF0000000ELL;
  v103 = 0;
  v104.n128_u64[0] = 0x900000008LL;
  v104.n128_u64[1] = 0xB0000000ALL;
  v105.n128_u64[0] = 0x500000004LL;
  v105.n128_u64[1] = 0x700000006LL;
  v106 = (unsigned int)&dword_4457D0;
  v107.n128_u64[0] = 0x100000000LL;
  v107.n128_u64[1] = 0x300000002LL;
  do
  {
    v108 = this->m_box;
    v109 = (char *)(&v108->m_type + v103);
    v110 = v108->m_noGoLeft[v103];
    _ZF = (unsigned __int8)v110 == 255;
    if ( (unsigned __int8)v110 != 255 )
    {
      v106 = v109[21];
      LOBYTE(v1) = v106;
      _ZF = (unsigned __int8)v106 == 255;
    }
    if ( !_ZF && ((v110 | v1) & 0x80u) == 0 )
    {
      v112 = v109[24];
      LOBYTE(v1) = v112 + v110;
      if ( v112 + v110 <= v108->m_width && v112 >= 1 )
      {
        v1 = v109[27];
        v137 = v1;
        if ( (int)(v1 + v106) <= v108->m_depth )
        {
          v113 = vdupq_n_s32(v106);
          v114 = v1 & 0xFFFFFFF0;
          v115 = &m_tiles[v110][v106];
          v116 = v109[27];
          v106 = 0;
          v135 = v109[24];
          v136 = v108->m_noGoLeft[v103];
          do
          {
            if ( v116 >= 1 )
            {
              v117 = 0;
              if ( (unsigned __int8)v137 < 0x10u || !v114 )
                goto LABEL_261;
              v118 = v107;
              v119 = v106 + v110;
              v120 = v105;
              v121 = v114;
              v122 = v104;
              v123 = v102;
              do
              {
                v124 = vaddq_s32(v118, v113);
                v125 = vaddq_s32(v120, v113);
                v126 = (char *)this + 30 * v119;
                v120 = vaddq_s32(v120, v101);
                LOBYTE(v1) = v124.n128_u8[0];
                v118 = vaddq_s32(v118, v101);
                v127 = &v126[v124.n128_u32[0] + 104];
                _Q2 = *(_OWORD *)v127;
                __asm { VCEQ.I8         Q2, Q2, #0 }
                if ( (unsigned __int8)_Q2 << 31 )
                  *v127 = 11;
                if ( BYTE1(_Q2) << 31 )
                  v126[v124.n128_u32[1] + 104] = 11;
                if ( BYTE2(_Q2) << 31 )
                  v126[v124.n128_u32[2] + 104] = 11;
                if ( BYTE3(_Q2) << 31 )
                  v126[v124.n128_u32[3] + 104] = 11;
                v130 = vaddq_s32(v122, v113);
                v122 = vaddq_s32(v122, v101);
                if ( BYTE4(_Q2) << 31 )
                  v126[v125.n128_u32[0] + 104] = 11;
                if ( BYTE5(_Q2) << 31 )
                  v126[v125.n128_u32[1] + 104] = 11;
                if ( BYTE6(_Q2) << 31 )
                  v126[v125.n128_u32[2] + 104] = 11;
                if ( BYTE7(_Q2) << 31 )
                  v126[v125.n128_u32[3] + 104] = 11;
                v131 = vaddq_s32(v123, v113);
                v123 = vaddq_s32(v123, v101);
                if ( BYTE8(_Q2) << 31 )
                  v126[v130.n128_u32[0] + 104] = 11;
                if ( BYTE9(_Q2) << 31 )
                  v126[v130.n128_u32[1] + 104] = 11;
                if ( BYTE10(_Q2) << 31 )
                  v126[v130.n128_u32[2] + 104] = 11;
                if ( BYTE11(_Q2) << 31 )
                  v126[v130.n128_u32[3] + 104] = 11;
                if ( BYTE12(_Q2) << 31 )
                  v126[v131.n128_u32[0] + 104] = 11;
                if ( BYTE13(_Q2) << 31 )
                  v126[v131.n128_u32[1] + 104] = 11;
                if ( BYTE14(_Q2) << 31 )
                  v126[v131.n128_u32[2] + 104] = 11;
                if ( HIBYTE(_Q2) << 31 )
                  v126[v131.n128_u32[3] + 104] = 11;
                v121 -= 16;
              }
              while ( v121 );
              v117 = v114;
              v112 = v135;
              v110 = v136;
              if ( v114 != v137 )
              {
LABEL_261:
                v132 = v137 - v117;
                v133 = &v115[v117];
                do
                {
                  if ( !*v133 )
                    *v133 = 11;
                  --v132;
                  ++v133;
                }
                while ( v132 );
              }
            }
            ++v106;
            v115 += 30;
          }
          while ( v106 != v112 );
        }
      }
    }
    ++v103;
  }
  while ( v103 != 3 );
}
// 444D10: variable 'm_depth' is possibly undefined
// 44556A: variable 'v1' is possibly undefined
// 4457D0: using guessed type int dword_4457D0;

//----- (004457E0) --------------------------------------------------------
void __fastcall Interior_c::Furnish(Interior_c *this)
{
  switch ( this->m_box->m_type )
  {
    case 0u:
      sub_1954EC(this, 0);
      break;
    case 1u:
      j_Interior_c::FurnishOffice(this);
      break;
    case 2u:
      sub_19322C(this);
      break;
    case 3u:
      sub_19C7B4(this);
      break;
    case 4u:
      sub_1925A4(this);
      break;
  }
}

//----- (0044580C) --------------------------------------------------------
void __fastcall Interior_c::CalcExitPts(Interior_c *this)
{
  CInteriorAttr *m_box; // r0
  int m_door; // r1
  float v4; // s2
  int m_numGotoPts; // r1
  float v6; // s16
  GotoPt_t *m_gotoPts; // r3
  int v8; // r2
  float v9; // s0
  float v10; // s4
  float v11; // s2
  int8 v12; // r1
  int8 v13; // r1
  int tileY; // s4
  RwReal y; // r1
  RwReal z; // r0
  CInteriorAttr *v17; // r0
  RwReal v18; // r1
  RwReal v19; // r2
  int m_lDoorStart; // r1
  float v21; // s18
  int8 v22; // r1
  int8 v23; // r2
  float v24; // s2
  float v25; // s0
  RwReal v26; // r1
  RwReal v27; // r0
  CInteriorAttr *v28; // r0
  RwReal v29; // r1
  RwReal v30; // r2
  int m_tDoorStart; // r1
  float v32; // s0
  float v33; // s2
  int v34; // r1
  float v35; // s18
  GotoPt_t *v36; // r3
  int i; // r2
  int8 v38; // r3
  int v39; // s2
  float v40; // s0
  float v41; // s2
  int m_depth; // r2
  RwReal v43; // r1
  RwReal v44; // r0
  CInteriorAttr *v45; // r0
  int v46; // r2
  RwReal v47; // r1
  RwReal v48; // r2
  int m_rDoorStart; // r1
  int v50; // r2
  float v51; // s18
  char *v52; // r1
  int8 v53; // r2
  int m_width; // r1
  float v55; // s2
  float v56; // s0
  float v57; // s0
  RwReal v58; // r1
  RwReal v59; // r0
  CInteriorAttr *v60; // r0
  RwReal v61; // r1
  RwReal v62; // r2
  RwV3d_0 v63; // [sp+0h] [bp-38h] BYREF
  RwV3d_0 pointsOut; // [sp+Ch] [bp-2Ch] BYREF

  m_box = this->m_box;
  m_door = m_box->m_door;
  if ( m_door >= 0 )
  {
    v4 = (float)m_door;
    m_numGotoPts = this->m_numGotoPts;
    v6 = v4 + -0.5;
    if ( m_numGotoPts < 3 )
    {
      v9 = 0.5;
      *(_WORD *)&this->m_exitPts[0].link1 = -1;
      v10 = 0.0;
      pointsOut.x = (float)(v6 + (float)((float)-m_box->m_width * 0.5)) + 0.5;
      v11 = (float)-m_box->m_depth * 0.5;
    }
    else
    {
      m_gotoPts = this->m_gotoPts;
      v8 = 0;
      while ( v6 >= (float)m_gotoPts->tileX )
      {
        v8 += 2;
        m_gotoPts += 2;
        if ( v8 >= m_numGotoPts )
          goto LABEL_9;
      }
      if ( !v8 )
      {
        v12 = 0;
        goto LABEL_13;
      }
LABEL_9:
      if ( v8 != m_numGotoPts )
      {
        v13 = v8 - 2;
        this->m_exitPts[0].link1 = v8;
        goto LABEL_14;
      }
      v12 = m_numGotoPts - 2;
LABEL_13:
      this->m_exitPts[0].link1 = v12;
      v13 = -1;
LABEL_14:
      this->m_exitPts[0].link2 = v13;
      v9 = 0.5;
      tileY = this->m_gotoPts[0].tileY;
      pointsOut.x = (float)(v6 + (float)((float)-m_box->m_width * 0.5)) + 0.5;
      v11 = (float)tileY + -0.25;
      v10 = (float)-m_box->m_depth * 0.5;
    }
    pointsOut.y = (float)(v11 + v10) + v9;
    pointsOut.z = (float)-m_box->m_height * v9;
    RwV3dTransformPoints(&pointsOut, &pointsOut, 1, &this->m_mat);
    y = pointsOut.y;
    z = pointsOut.z;
    this->m_exitPts[0].pos.x = pointsOut.x;
    this->m_exitPts[0].pos.y = y;
    this->m_exitPts[0].pos.z = z;
    v17 = this->m_box;
    v63.x = (float)(v6 + (float)((float)-v17->m_width * 0.5)) + 0.5;
    v63.y = (float)((float)((float)-v17->m_depth * 0.5) + -0.25) + 0.5;
    v63.z = (float)-v17->m_height * 0.5;
    RwV3dTransformPoints(&v63, &v63, 1, &this->m_mat);
    v18 = v63.y;
    v19 = v63.z;
    this->m_exitPts[1].pos.x = v63.x;
    this->m_exitPts[1].pos.y = v18;
    this->m_exitPts[1].pos.z = v19;
    m_box = this->m_box;
  }
  m_lDoorStart = m_box->m_lDoorStart;
  if ( m_lDoorStart >= 0 )
  {
    v21 = (float)((float)((float)(m_box->m_lDoorEnd - m_lDoorStart) * 0.5) + (float)m_lDoorStart) + -0.5;
    if ( this->m_numGotoPts < 3 )
    {
      v24 = 0.0;
      *(_WORD *)&this->m_exitPts[2].link1 = -1;
      v25 = (float)-m_box->m_width * 0.5;
    }
    else
    {
      v22 = 0;
      if ( v21 >= (float)this->m_gotoPts[0].tileY )
      {
        v23 = 1;
        if ( v21 > (float)this->m_gotoPts[1].tileY )
        {
          v23 = -1;
          v22 = 1;
        }
      }
      else
      {
        v23 = -1;
      }
      this->m_exitPts[2].link2 = v23;
      this->m_exitPts[2].link1 = v22;
      v25 = (float)this->m_gotoPts[0].tileX + -0.25;
      v24 = (float)-m_box->m_width * 0.5;
    }
    pointsOut.x = (float)(v25 + v24) + 0.5;
    pointsOut.y = (float)(v21 + (float)((float)-m_box->m_depth * 0.5)) + 0.5;
    pointsOut.z = (float)-m_box->m_height * 0.5;
    RwV3dTransformPoints(&pointsOut, &pointsOut, 1, &this->m_mat);
    v26 = pointsOut.y;
    v27 = pointsOut.z;
    this->m_exitPts[2].pos.x = pointsOut.x;
    this->m_exitPts[2].pos.y = v26;
    this->m_exitPts[2].pos.z = v27;
    v28 = this->m_box;
    v63.x = (float)((float)((float)-v28->m_width * 0.5) + -0.25) + 0.5;
    v63.y = (float)(v21 + (float)((float)-v28->m_depth * 0.5)) + 0.5;
    v63.z = (float)-v28->m_height * 0.5;
    RwV3dTransformPoints(&v63, &v63, 1, &this->m_mat);
    v29 = v63.y;
    v30 = v63.z;
    this->m_exitPts[3].pos.x = v63.x;
    this->m_exitPts[3].pos.y = v29;
    this->m_exitPts[3].pos.z = v30;
    m_box = this->m_box;
  }
  m_tDoorStart = m_box->m_tDoorStart;
  if ( m_tDoorStart >= 0 )
  {
    v32 = (float)(m_box->m_tDoorEnd - m_tDoorStart);
    v33 = (float)m_tDoorStart;
    v34 = this->m_numGotoPts;
    v35 = (float)((float)(v32 * 0.5) + v33) + -0.5;
    if ( v34 < 3 )
    {
      *(_WORD *)&this->m_exitPts[4].link1 = -1;
      m_depth = m_box->m_depth;
      pointsOut.x = (float)(v35 + (float)((float)-m_box->m_width * 0.5)) + 0.5;
      v41 = (float)(m_depth - 1);
      v40 = (float)-m_box->m_depth * 0.5;
    }
    else
    {
      v36 = &this->m_gotoPts[1];
      for ( i = 1; i < v34; i += 2 )
      {
        if ( v35 < (float)v36->tileX )
          break;
        v36 += 2;
      }
      v38 = i - 2;
      if ( i == v34 )
        v38 = -1;
      this->m_exitPts[4].link2 = v38;
      if ( i == v34 )
        LOBYTE(i) = v34 - 1;
      this->m_exitPts[4].link1 = i;
      v39 = this->m_gotoPts[1].tileY;
      pointsOut.x = (float)(v35 + (float)((float)-m_box->m_width * 0.5)) + 0.5;
      v40 = (float)v39 + 0.25;
      v41 = (float)-m_box->m_depth * 0.5;
    }
    pointsOut.y = (float)(v40 + v41) + 0.5;
    pointsOut.z = (float)-m_box->m_height * 0.5;
    RwV3dTransformPoints(&pointsOut, &pointsOut, 1, &this->m_mat);
    v43 = pointsOut.y;
    v44 = pointsOut.z;
    this->m_exitPts[4].pos.x = pointsOut.x;
    this->m_exitPts[4].pos.y = v43;
    this->m_exitPts[4].pos.z = v44;
    v45 = this->m_box;
    v46 = v45->m_depth - 1;
    v63.x = (float)(v35 + (float)((float)-v45->m_width * 0.5)) + 0.5;
    v63.y = (float)((float)((float)v46 + 0.25) + (float)((float)-v45->m_depth * 0.5)) + 0.5;
    v63.z = (float)-v45->m_height * 0.5;
    RwV3dTransformPoints(&v63, &v63, 1, &this->m_mat);
    v47 = v63.y;
    v48 = v63.z;
    this->m_exitPts[5].pos.x = v63.x;
    this->m_exitPts[5].pos.y = v47;
    this->m_exitPts[5].pos.z = v48;
    m_box = this->m_box;
  }
  m_rDoorStart = m_box->m_rDoorStart;
  if ( m_rDoorStart >= 0 )
  {
    v50 = this->m_numGotoPts;
    v51 = (float)((float)((float)(m_box->m_rDoorEnd - m_rDoorStart) * 0.5) + (float)m_rDoorStart) + -0.5;
    if ( v50 < 3 )
    {
      *(_WORD *)&this->m_exitPts[6].link1 = -1;
      m_width = m_box->m_width;
      v55 = (float)(m_width - 1);
      v56 = (float)-m_width * 0.5;
    }
    else
    {
      v52 = (char *)this + 16 * v50 - 32;
      if ( v51 >= (float)v52[1041] )
      {
        v57 = (float)*((char *)&this->m_doorPos.x + 16 * v50 + 1);
        this->m_exitPts[6].link1 = v50 - 1;
        if ( v51 > v57 )
          v53 = -1;
        else
          v53 = v50 - 2;
      }
      else
      {
        this->m_exitPts[6].link1 = v50 - 2;
        v53 = -1;
      }
      this->m_exitPts[6].link2 = v53;
      v56 = (float)v52[1040] + 0.25;
      v55 = (float)-m_box->m_width * 0.5;
    }
    pointsOut.x = (float)(v56 + v55) + 0.5;
    pointsOut.y = (float)(v51 + (float)((float)-m_box->m_depth * 0.5)) + 0.5;
    pointsOut.z = (float)-m_box->m_height * 0.5;
    RwV3dTransformPoints(&pointsOut, &pointsOut, 1, &this->m_mat);
    v58 = pointsOut.y;
    v59 = pointsOut.z;
    this->m_exitPts[6].pos.x = pointsOut.x;
    this->m_exitPts[6].pos.y = v58;
    this->m_exitPts[6].pos.z = v59;
    v60 = this->m_box;
    v63.x = (float)((float)((float)-v60->m_width * 0.5) + (float)((float)(v60->m_width - 1) + 0.25)) + 0.5;
    v63.y = (float)(v51 + (float)((float)-v60->m_depth * 0.5)) + 0.5;
    v63.z = (float)-v60->m_height * 0.5;
    RwV3dTransformPoints(&v63, &v63, 1, &this->m_mat);
    v61 = v63.y;
    v62 = v63.z;
    this->m_exitPts[7].pos.x = v63.x;
    this->m_exitPts[7].pos.y = v61;
    this->m_exitPts[7].pos.z = v62;
  }
}

//----- (00445EE8) --------------------------------------------------------
void __fastcall Interior_c::AddPickups(Interior_c *this)
{
  int v2; // r9
  int v3; // r8
  int m_width; // r5
  unsigned __int16 v5; // r0
  int m_depth; // r6
  float v7; // s26
  int v8; // s0
  CInteriorAttr *m_box; // r0
  int v10; // r1
  int v11; // s0
  int v12; // r2
  unsigned int v13; // r2
  RwReal v14; // r5
  RwReal v15; // r6
  RwReal v16; // r10
  UInt32 v17; // r11
  unsigned __int16 v18; // r0
  int v19; // r0
  eWeaponType v20; // r10
  RwReal x; // r5
  RwReal y; // r6
  RwReal z; // r11
  unsigned __int16 v24; // r0
  bool v25; // cc
  int ArgMonetaryValue; // [sp+4h] [bp-74h]
  int ArgMonetaryValuea; // [sp+4h] [bp-74h]
  RwV3d_0 pointsIn; // [sp+1Ch] [bp-5Ch] BYREF
  CVector v29; // 0:r0.12
  CVector v30; // 0:r0.12

  if ( CTimer::m_snTimeInMilliseconds - g_interiorMan.m_timeLastPickupsGenerated >= (unsigned int)&stru_2BF1C.st_value )
  {
    v2 = 0;
    v3 = 0;
    do
    {
      m_width = this->m_box->m_width;
      v5 = rand();
      m_depth = this->m_box->m_depth;
      v7 = (float)v5;
      v8 = (unsigned __int16)rand();
      m_box = this->m_box;
      v10 = m_box->m_width;
      v11 = (int)(float)((float)((float)v8 * 0.000015259) * (float)(m_depth - 1));
      v12 = (int)(float)((float)(v7 * 0.000015259) * (float)(m_width - 1));
      if ( v10 > v12 && v12 >= 0 && m_box->m_depth > (unsigned int)v11 )
      {
        v13 = this->m_tiles[v12][v11];
        if ( v13 <= 4 && ((1 << v13) & 0x19) != 0 )
        {
          pointsIn.x = (float)((float)((float)-v10 * 0.5)
                             + (float)(int)(float)((float)(v7 * 0.000015259) * (float)(m_width - 1)))
                     + 0.5;
          pointsIn.y = (float)((float)((float)-m_box->m_depth * 0.5) + (float)v11) + 0.5;
          pointsIn.z = (float)-m_box->m_height * 0.5;
          RwV3dTransformPoints(&pointsIn, &pointsIn, 1, &this->m_mat);
          if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) > 74 )
          {
            pointsIn.z = pointsIn.z + 0.5;
            v19 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0);
            if ( v19 >= 40 )
            {
              if ( v19 >= 80 )
              {
                v20 = WEAPONTYPE_SHOTGUN;
                if ( v19 < 90 )
                  v20 = WEAPONTYPE_KNIFE;
              }
              else
              {
                v20 = WEAPONTYPE_PISTOL;
              }
            }
            else
            {
              v20 = WEAPONTYPE_BASEBALLBAT;
            }
            x = pointsIn.x;
            y = pointsIn.y;
            z = pointsIn.z;
            v24 = rand();
            v30.z = z;
            ArgMonetaryValuea = (int)(float)((float)((float)v24 * 0.000015259) * 15.0) + 3;
            *(_QWORD *)&v30.x = __PAIR64__(LODWORD(y), LODWORD(x));
            CPickups::GenerateNewOne_WeaponType(v30, v20, 3, ArgMonetaryValuea, 0, 0);
          }
          else
          {
            v15 = pointsIn.x;
            v14 = pointsIn.y;
            v16 = pointsIn.z;
            v17 = MI_MONEY;
            v18 = rand();
            v29.z = v16;
            ArgMonetaryValue = (int)(float)((float)((float)v18 * 0.000015259) * 40.0) + 10;
            *(_QWORD *)&v29.x = __PAIR64__(LODWORD(v14), LODWORD(v15));
            CPickups::GenerateNewOne(v29, v17, 8, ArgMonetaryValue, 0, 0, 0);
          }
          ++v2;
        }
      }
      v25 = v3 < 98;
      if ( v3 <= 98 )
      {
        ++v3;
        v25 = v2 < 1;
      }
    }
    while ( v25 );
  }
}
// FC: using guessed type int elf_hash_bucket[16411];
// 2BF1C: using guessed type Elf32_Sym stru_2BF1C;

//----- (0044616C) --------------------------------------------------------
void __fastcall Interior_c::Exit(Interior_c *this)
{
  CPickups::RemovePickUpsInArea(
    this->m_mat.pos.x + -50.0,
    this->m_mat.pos.x + 50.0,
    this->m_mat.pos.y + -50.0,
    this->m_mat.pos.y + 50.0,
    this->m_mat.pos.z + -50.0,
    this->m_mat.pos.z + 50.0);
  Interior_c::Unfurnish(this);
}

//----- (004461D0) --------------------------------------------------------
void __fastcall Interior_c::Unfurnish(Interior_c *this)
{
  List_c *p_m_furnitureEntityList; // r4
  ListItem_c *m_head; // r5
  ListItem_c *v3; // r6
  CPlayerPed *PlayerPed; // r0
  CEntity *EntityThatThisPedIsHolding; // r0
  ListItem_c *m_prev; // r0

  p_m_furnitureEntityList = &this->m_furnitureEntityList;
  m_head = this->m_furnitureEntityList.m_head;
  while ( m_head )
  {
    v3 = m_head;
    m_head = m_head->m_next;
    PlayerPed = FindPlayerPed(-1);
    if ( PlayerPed
      && (EntityThatThisPedIsHolding = CPed::GetEntityThatThisPedIsHolding(PlayerPed)) != 0
      && EntityThatThisPedIsHolding == (CEntity *)v3[1].m_prev
      && (*(_BYTE *)&EntityThatThisPedIsHolding->m_info & 7) == 4
      && (BYTE1(EntityThatThisPedIsHolding[5].m_pRwObject) & 0x20) != 0 )
    {
      ++CObject::nNoTempObjects;
      LOBYTE(EntityThatThisPedIsHolding[5].m_pMat) = 3;
      EntityThatThisPedIsHolding[5].pReferences = (CReference *)(CTimer::m_snTimeInMilliseconds + 99999999);
    }
    else
    {
      CWorld::Remove((CEntity *)v3[1].m_prev);
      m_prev = v3[1].m_prev;
      if ( m_prev )
        ((void (__fastcall *)(ListItem_c *))m_prev->m_prev->m_next)(m_prev);
    }
    v3[1].m_prev = 0;
    List_c::RemoveItem(p_m_furnitureEntityList, v3);
    List_c::AddItem(&g_furnitureMan.m_furnitureEntityPool, v3);
  }
}

//----- (00446298) --------------------------------------------------------
FurnitureEntity_c *__fastcall Interior_c::GetFurnitureEntity(Interior_c *this, CEntity *pEntity)
{
  FurnitureEntity_c *result; // r0

  result = (FurnitureEntity_c *)this->m_furnitureEntityList.m_head;
  if ( !result )
    return 0;
  while ( result->m_pData != pEntity )
  {
    result = (FurnitureEntity_c *)result->m_next;
    if ( !result )
      return 0;
  }
  return result;
}

//----- (004462B8) --------------------------------------------------------
bool8 __fastcall Interior_c::GetBoundingBox(Interior_c *this, FurnitureEntity_c *pFurnitureEntity, CVector *pCorner)
{
  CInteriorAttr *m_box; // r2
  bool8 result; // r0
  unsigned int m_type; // r2
  int32 m_tileX; // r6
  int32 m_tileY; // r5
  float v10; // s18
  float v11; // s2
  float v12; // s2
  float v13; // s2
  float v14; // s2
  __int64 v15; // [sp+8h] [bp-E60h]
  _QWORD v16[450]; // [sp+10h] [bp-E58h] BYREF
  int32 v17; // [sp+E24h] [bp-44h] BYREF
  int32 v18; // [sp+E28h] [bp-40h] BYREF
  int32 v19; // [sp+E2Ch] [bp-3Ch] BYREF
  int32 v20[14]; // [sp+E30h] [bp-38h] BYREF

  m_box = this->m_box;
  result = 0;
  m_type = m_box->m_type;
  if ( m_type <= 6 && ((1 << m_type) & 0x43) != 0 )
  {
    m_tileX = pFurnitureEntity->m_tileX;
    v19 = m_tileX;
    v20[0] = m_tileX;
    m_tileY = pFurnitureEntity->m_tileY;
    v17 = m_tileY;
    v18 = m_tileY;
    memset(v16, 0, sizeof(v16));
    *((_DWORD *)&v16[15 * m_tileX] + m_tileY) = 1;
    LODWORD(v15) = &v17;
    HIDWORD(v15) = v16;
    Interior_c::FindBoundingBox(this, m_tileX, m_tileY, v20, &v19, &v18, v15);
    v10 = CPedGeometryAnalyser::ms_fPedNominalRadius;
    v11 = (float)v17;
    pCorner->x = (float)((float)((float)((float)v20[0] + -0.5) - CPedGeometryAnalyser::ms_fPedNominalRadius)
                       + (float)((float)-this->m_box->m_width * 0.5))
               + 0.5;
    pCorner->y = (float)((float)(v10 + (float)(v11 + 0.5)) + (float)((float)-this->m_box->m_depth * 0.5)) + 0.5;
    pCorner->z = (float)-this->m_box->m_height * 0.5;
    RwV3dTransformPoints(pCorner, pCorner, 1, &this->m_mat);
    v12 = (float)v18;
    pCorner[1].x = (float)((float)((float)((float)v20[0] + -0.5) - v10) + (float)((float)-this->m_box->m_width * 0.5))
                 + 0.5;
    pCorner[1].y = (float)((float)((float)(v12 + -0.5) - v10) + (float)((float)-this->m_box->m_depth * 0.5)) + 0.5;
    pCorner[1].z = (float)-this->m_box->m_height * 0.5;
    RwV3dTransformPoints(pCorner + 1, pCorner + 1, 1, &this->m_mat);
    v13 = (float)v18;
    pCorner[2].x = (float)((float)(v10 + (float)((float)v19 + 0.5)) + (float)((float)-this->m_box->m_width * 0.5)) + 0.5;
    pCorner[2].y = (float)((float)((float)(v13 + -0.5) - v10) + (float)((float)-this->m_box->m_depth * 0.5)) + 0.5;
    pCorner[2].z = (float)-this->m_box->m_height * 0.5;
    RwV3dTransformPoints(pCorner + 2, pCorner + 2, 1, &this->m_mat);
    v14 = (float)v17;
    pCorner[3].x = (float)((float)(v10 + (float)((float)v19 + 0.5)) + (float)((float)-this->m_box->m_width * 0.5)) + 0.5;
    pCorner[3].y = (float)((float)(v10 + (float)(v14 + 0.5)) + (float)((float)-this->m_box->m_depth * 0.5)) + 0.5;
    pCorner[3].z = (float)-this->m_box->m_height * 0.5;
    RwV3dTransformPoints(pCorner + 3, pCorner + 3, 1, &this->m_mat);
    return 1;
  }
  return result;
}
// 4462B8: using guessed type int32 var_38[14];

//----- (00446578) --------------------------------------------------------
void __fastcall Interior_c::FindBoundingBox(
        Interior_c *this,
        int32 x,
        int32 y,
        int32 *minX,
        int32 *maxX,
        int32 *minY,
        __int64 maxY)
{
  int v9; // r0
  int v10; // r4
  int32 *v11; // r12
  int32 *v12; // lr
  CInteriorAttr *m_width; // r1
  char *v14; // r10
  int v15; // r9
  _DWORD *v16; // r11
  CInteriorAttr *m_box; // r0
  bool v18; // cc
  int v19; // r0
  bool v20; // zf
  CInteriorAttr *v21; // r0
  int32 v22; // r2
  int v23; // r0
  int32 *v24; // r9
  int32 *v25; // r9
  CInteriorAttr *v26; // r0
  int v27; // r0
  bool v28; // zf
  int32 *v29; // r9
  bool v30; // cc
  int v31; // r1
  bool v32; // zf
  int v33; // [sp+10h] [bp-28h]
  int v34; // [sp+10h] [bp-28h]
  int v35; // [sp+10h] [bp-28h]
  int v36; // [sp+14h] [bp-24h]
  int v37; // [sp+18h] [bp-20h]

  v9 = 15 * x;
  v10 = y;
  v12 = (int32 *)HIDWORD(maxY);
  v11 = (int32 *)maxY;
  m_width = (CInteriorAttr *)(30 * x);
  v14 = (char *)this + 2 * v9;
  v15 = HIDWORD(maxY) + 4 * (_DWORD)m_width;
  v16 = (_DWORD *)(HIDWORD(maxY) + 4 * (y + 2 * v9) + 120);
  v37 = x + 1;
  m_box = (CInteriorAttr *)(x - 1);
  v36 = x - 1;
  while ( 1 )
  {
    v18 = x < 1;
    if ( x >= 1 )
    {
      m_box = this->m_box;
      m_width = (CInteriorAttr *)m_box->m_width;
      v18 = (int)m_width < x;
    }
    if ( v18 || v10 >= (unsigned int)m_box->m_depth )
      goto LABEL_45;
    v19 = (unsigned __int8)v14[v10 + 74];
    v20 = v19 == 5;
    if ( v19 == 5 )
      v20 = *(v16 - 60) == 0;
    if ( v20 )
    {
      v34 = v15;
      *(v16 - 60) = 1;
      v25 = minX;
      if ( *minX >= x )
        *minX = v36;
      Interior_c::FindBoundingBox(this, v36, v10, minX, maxX, minY, v11, v12);
      v12 = (int32 *)HIDWORD(maxY);
      v11 = (int32 *)maxY;
      minX = v25;
      v15 = v34;
      if ( v10 > 28 )
      {
LABEL_24:
        if ( x > 28 )
          goto LABEL_35;
LABEL_25:
        v26 = this->m_box;
        m_width = (CInteriorAttr *)v26->m_width;
        if ( v37 < (int)m_width && x >= -1 && v10 < (unsigned int)v26->m_depth )
        {
          v27 = (unsigned __int8)v14[v10 + 134];
          v28 = v27 == 5;
          if ( v27 == 5 )
            v28 = *v16 == 0;
          if ( v28 )
          {
            v35 = v15;
            *v16 = 1;
            v29 = minX;
            if ( *maxX <= x )
              *maxX = v37;
            Interior_c::FindBoundingBox(this, v37, v10, minX, maxX, minY, v11, v12);
            v12 = (int32 *)HIDWORD(maxY);
            v11 = (int32 *)maxY;
            minX = v29;
            v15 = v35;
          }
        }
        goto LABEL_35;
      }
    }
    else
    {
LABEL_45:
      if ( v10 > 28 )
        goto LABEL_24;
    }
    v21 = this->m_box;
    m_width = (CInteriorAttr *)v21->m_width;
    if ( (int)m_width <= x )
      goto LABEL_24;
    if ( x < 0 )
      goto LABEL_24;
    v22 = v10 + 1;
    if ( v10 + 1 >= (unsigned int)v21->m_depth )
      goto LABEL_24;
    if ( v14[v10 + 105] != 5 )
      goto LABEL_24;
    v23 = v15 + 4 * v10;
    m_width = *(CInteriorAttr **)(v23 + 4);
    if ( m_width )
      goto LABEL_24;
    v33 = v15;
    *(_DWORD *)(v23 + 4) = 1;
    v24 = minX;
    if ( *v11 <= v10 )
      *v11 = v22;
    Interior_c::FindBoundingBox(this, x, v22, minX, maxX, minY, v11, v12);
    v12 = (int32 *)HIDWORD(maxY);
    v11 = (int32 *)maxY;
    minX = v24;
    v15 = v33;
    if ( x <= 28 )
      goto LABEL_25;
LABEL_35:
    v30 = v10 <= 1;
    if ( v10 >= 1 )
    {
      m_width = this->m_box;
      v30 = m_width->m_width <= x;
    }
    if ( v30 )
      break;
    if ( x < 0 )
      break;
    m_box = (CInteriorAttr *)(v10 - 1);
    if ( v10 - 1 >= (unsigned int)m_width->m_depth )
      break;
    v31 = (unsigned __int8)v14[v10 + 103];
    v32 = v31 == 5;
    if ( v31 == 5 )
      v32 = *(v16 - 31) == 0;
    if ( !v32 )
      break;
    *(v16 - 31) = 1;
    --v16;
    m_width = (CInteriorAttr *)*minY;
    v18 = *minY < v10--;
    if ( !v18 )
      *minY = (int32)m_box;
  }
}
// 4466F4: variable 'm_width' is possibly undefined

//----- (0044671A) --------------------------------------------------------
void __fastcall Interior_c::GetTileCentre(Interior_c *this, float x, float y, RwV3d_0 *centre)
{
  centre->x = (float)((float)((float)-this->m_box->m_width * 0.5) + x) + 0.5;
  centre->y = (float)((float)((float)-this->m_box->m_depth * 0.5) + y) + 0.5;
  centre->z = (float)-this->m_box->m_height * 0.5;
  sub_1A1678(centre, centre, 1, &this->m_mat);
}

//----- (0044678E) --------------------------------------------------------
int32 __fastcall Interior_c::GetTileStatus(Interior_c *this, int32 x, int32 y)
{
  CInteriorAttr *m_box; // r3
  int32 result; // r0

  m_box = this->m_box;
  if ( m_box->m_width <= x )
    return 1;
  result = 1;
  if ( x >= 0 && m_box->m_depth > (unsigned int)y )
    return this->m_tiles[x][y];
  return result;
}

//----- (004467BC) --------------------------------------------------------
bool __fastcall Interior_c::IsPtInside(
        Interior_c *this,
        RwV3d_0 *pos,
        float widthBias,
        float depthBias,
        float heightBias)
{
  float v5; // s0
  float v6; // s2
  CInteriorAttr *m_box; // r12
  float v8; // s6

  v5 = pos->x - this->m_mat.pos.x;
  v6 = pos->y - this->m_mat.pos.y;
  m_box = this->m_box;
  v8 = pos->z - this->m_mat.pos.z;
  return fabsf(
           (float)((float)(v5 * this->m_mat.right.x) + (float)(v6 * this->m_mat.right.y))
         + (float)(v8 * this->m_mat.right.z)) <= (float)((float)((float)m_box->m_width * 0.5) + widthBias)
      && fabsf((float)((float)(v5 * this->m_mat.up.x) + (float)(v6 * this->m_mat.up.y)) + (float)(v8 * this->m_mat.up.z)) <= (float)((float)((float)m_box->m_depth * 0.5) + depthBias)
      && fabsf((float)((float)(v5 * this->m_mat.at.x) + (float)(v6 * this->m_mat.at.y)) + (float)(v8 * this->m_mat.at.z)) <= (float)((float)((float)m_box->m_height * 0.5) + heightBias);
}

//----- (004468C4) --------------------------------------------------------
bool8 __fastcall Interior_c::IsVisible(Interior_c *this)
{
  CSimpleTransform *p_tx; // r3
  float y; // s2
  float v3; // s4
  float v4; // s6
  CInteriorAttr *m_box; // r1
  float v6; // s10

  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  y = p_tx->m_translate.y;
  v3 = p_tx->m_translate.x - this->m_mat.pos.x;
  v4 = y - this->m_mat.pos.y;
  m_box = this->m_box;
  v6 = p_tx->m_translate.z - this->m_mat.pos.z;
  return fabsf(
           (float)((float)(v3 * this->m_mat.right.x) + (float)(v4 * this->m_mat.right.y))
         + (float)(v6 * this->m_mat.right.z)) <= (float)((float)((float)m_box->m_width * 0.5) + 5.0)
      && fabsf((float)((float)(v3 * this->m_mat.up.x) + (float)(v4 * this->m_mat.up.y)) + (float)(v6 * this->m_mat.up.z)) <= (float)((float)((float)m_box->m_depth * 0.5) + 5.0)
      && fabsf((float)((float)(v3 * this->m_mat.at.x) + (float)(v4 * this->m_mat.at.y)) + (float)(v6 * this->m_mat.at.z)) <= (float)((float)((float)m_box->m_height * 0.5) + 0.0)
      || m_box->m_door >= 1
      && (float)((float)((float)((float)(p_tx->m_translate.x - this->m_doorPos.x)
                               * (float)(p_tx->m_translate.x - this->m_doorPos.x))
                       + (float)((float)(y - this->m_doorPos.y) * (float)(y - this->m_doorPos.y)))
               + 0.0) < 100.0;
}

//----- (00446A20) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
CEntity *__fastcall Interior_c::PlaceFurniture(
        Interior_c *this,
        Furniture_c *pFurn,
        int32 x,
        int32 y,
        float z,
        int32 heightInfo,
        int32 dir,
        int32 *w,
        int32 *d,
        int force)
{
  int32 *v12; // r9
  int32 *v13; // r10
  int m_depth; // lr
  uint8 *p_m_width; // r0
  int32 v16; // r8
  bool v17; // zf
  CInteriorAttr *m_box; // r0
  int v19; // r12
  uint8 *v20; // r1
  int v21; // r3
  int v22; // r2
  int v23; // r6
  int m_onWindowTile; // r0
  bool v25; // zf
  unsigned int m_width; // r5
  unsigned int v27; // r6
  float v28; // s0
  float v29; // r6
  int m_maxAngle; // r5
  unsigned __int16 v31; // r0
  int v32; // r6
  int v33; // r5
  int32 v34; // r2
  int v35; // r0
  CInteriorAttr *v36; // r1
  float v37; // s12
  float v38; // s2
  float v39; // s8
  float v40; // s4
  float v41; // s0
  CInteriorAttr *v42; // r1
  ListItem_c *v43; // r8
  CBuilding *v44; // r0
  ListItem_c *v45; // r0
  ListItem_c *m_prev; // r0
  __int64 v47; // kr18_8
  ListItem_c *v48; // r0
  __int64 v49; // kr20_8
  int v50; // r0
  CInteriorAttr *v51; // r0
  int v52; // r1
  uint8 *v53; // r4
  int32 v54; // r5
  uint8 *v55; // r0
  unsigned int v56; // r6
  int v57; // r5
  CInteriorAttr *v58; // r0
  int v59; // r1
  uint8 *v60; // r4
  int32 v61; // r5
  uint8 *v62; // r0
  int v63; // r2
  int32 v65; // [sp+8h] [bp-1E8h]
  int32 v66; // [sp+Ch] [bp-1E4h]
  CMatrix v69; // [sp+18h] [bp-1D8h] BYREF
  CMatrix v70; // [sp+60h] [bp-190h] BYREF
  CMatrix mat; // [sp+A8h] [bp-148h] BYREF
  CMatrix m2; // [sp+F0h] [bp-100h] BYREF
  CMatrix m1; // [sp+138h] [bp-B8h] BYREF
  CMatrix v74; // [sp+180h] [bp-70h] BYREF

  v12 = d;
  v13 = w;
  if ( List_c::GetNumItems(&g_furnitureMan.m_furnitureEntityPool) < 1 )
    goto LABEL_75;
  if ( (dir | 2) == 3 )
  {
    m_depth = pFurn->m_depth;
    p_m_width = &pFurn->m_width;
  }
  else
  {
    m_depth = pFurn->m_width;
    p_m_width = &pFurn->m_depth;
  }
  v16 = *p_m_width;
  v17 = heightInfo == 1;
  if ( heightInfo == 1 )
    v17 = force == 0;
  if ( !v17 )
    goto LABEL_26;
  if ( (x | y) < 0 || (m_box = this->m_box, x + m_depth > m_box->m_width) || v16 + y > m_box->m_depth )
  {
LABEL_75:
    y = 0;
    *v13 = 0;
    *v12 = 0;
    return (CEntity *)y;
  }
  if ( m_depth )
  {
    v19 = 0;
    v20 = &this->m_tiles[x][y];
    while ( !v16 )
    {
LABEL_25:
      ++v19;
      v20 += 30;
      if ( v19 >= m_depth )
        goto LABEL_26;
    }
    v21 = 0;
    while ( 1 )
    {
      v22 = v20[v21];
      v23 = 0;
      m_onWindowTile = pFurn->m_onWindowTile;
      if ( v22 == 9 )
        v23 = 1;
      if ( pFurn->m_onWindowTile )
        m_onWindowTile = 1;
      v25 = v22 == 0;
      if ( v20[v21] )
        v25 = (m_onWindowTile & v23) == 1;
      if ( !v25 )
        goto LABEL_75;
      if ( ++v21 >= v16 )
        goto LABEL_25;
    }
  }
LABEL_26:
  v65 = y;
  v74.m_pRwMat = 0;
  v74.m_owner = 0;
  v66 = v16;
  if ( pFurn->m_maxAngle )
  {
    y = (int32)&m1;
    m_width = pFurn->m_width;
    v27 = pFurn->m_depth;
    m1.m_pRwMat = 0;
    m1.m_owner = 0;
    m2.m_pRwMat = 0;
    m2.m_owner = 0;
    mat.m_pRwMat = 0;
    mat.m_owner = 0;
    CMatrix::SetUnity(&m1);
    v28 = 0.5 - (float)((float)v27 * 0.5);
    v29 = 0.5 - (float)((float)m_width * 0.5);
    CMatrix::SetTranslate(&m1, v29, v28, 0.0);
    CMatrix::SetUnity(&m2);
    m_maxAngle = pFurn->m_maxAngle;
    v31 = rand();
    CMatrix::RotateZ(
      &m2,
      (float)((int)(float)((float)((float)v31 * 0.000015259) * (float)(2 * m_maxAngle)) - m_maxAngle) * 0.017453);
    CMatrix::SetUnity(&mat);
    CMatrix::SetTranslate(&mat, COERCE_FLOAT(LODWORD(v29) ^ 0x80000000), COERCE_FLOAT(LODWORD(v28) ^ 0x80000000), -0.0);
    operator*(&v69, &mat, &m2);
    operator*(&v70, &v69, &m1);
    CMatrix::operator=(&v74, &v70);
    CMatrix::~CMatrix(&v70);
    CMatrix::~CMatrix(&v69);
    CMatrix::~CMatrix(&mat);
    CMatrix::~CMatrix(&m2);
    CMatrix::~CMatrix(&m1);
  }
  else
  {
    CMatrix::SetUnity(&v74);
  }
  v32 = 0;
  CMatrix::CMatrix(&m1, &this->m_mat, 0);
  m2.m_pRwMat = 0;
  m2.m_owner = 0;
  mat.m_pRwMat = 0;
  mat.m_owner = 0;
  CMatrix::SetUnity(&m2);
  CMatrix::RotateZ(&m2, (float)((float)dir * 3.1416) * 0.5);
  if ( dir == 3 )
  {
    v12 = d;
    v13 = w;
    v35 = v16 - 1;
    v33 = v65;
    v32 = 0;
    v34 = heightInfo;
  }
  else
  {
    v12 = d;
    v13 = w;
    v33 = v65;
    v34 = heightInfo;
    if ( dir == 2 )
    {
      v35 = v16 - 1;
      v32 = m_depth - 1;
    }
    else
    {
      v35 = 0;
      if ( dir == 1 )
      {
        v32 = m_depth - 1;
        v35 = 0;
      }
    }
  }
  if ( (unsigned int)(v34 - 1) > 1 )
  {
    if ( v34 )
      goto LABEL_41;
    v42 = this->m_box;
    v37 = (float)v35;
    v38 = (float)((float)-v42->m_depth * 0.5) + (float)v33;
    v39 = (float)v32;
    v40 = (float)((float)-v42->m_width * 0.5) + (float)x;
    v41 = (float)((float)v42->m_height * 0.5) - z;
  }
  else
  {
    v36 = this->m_box;
    v37 = (float)v35;
    v38 = (float)((float)-v36->m_depth * 0.5) + (float)v33;
    v39 = (float)v32;
    v40 = (float)((float)-v36->m_width * 0.5) + (float)x;
    v41 = (float)((float)-v36->m_height * 0.5) + z;
  }
  m2.tz = v41 + m2.tz;
  m2.tx = (float)((float)(v40 + v39) + 0.5) + m2.tx;
  m2.ty = (float)((float)(v38 + v37) + 0.5) + m2.ty;
LABEL_41:
  operator*(&v69, &m1, &m2);
  operator*(&v70, &v69, &v74);
  CMatrix::operator=(&mat, &v70);
  CMatrix::~CMatrix(&v70);
  CMatrix::~CMatrix(&v69);
  v43 = List_c::RemoveHead(&g_furnitureMan.m_furnitureEntityPool);
  if ( v43 )
  {
    v44 = (CBuilding *)CBuilding::operator new(0x3Cu);
    CBuilding::CBuilding(v44);
    v43[1].m_prev = v45;
    ((void (__fastcall *)(ListItem_c *, _DWORD))v45->m_prev[3].m_next)(v45, pFurn->m_modelIndex);
    CPlaceable::SetMatrix((CPlaceable *)v43[1].m_prev, &mat);
    HIBYTE(v43[1].m_prev[6].m_prev) = this->m_areaCode;
    m_prev = v43[1].m_prev;
    v47 = *(_QWORD *)&m_prev[3].m_next;
    m_prev[3].m_next = (ListItem_c *)(v47 | 0x10000);
    m_prev[4].m_prev = (ListItem_c *)HIDWORD(v47);
    v48 = v43[1].m_prev;
    v49 = *(_QWORD *)&v48[3].m_next;
    v48[3].m_next = (ListItem_c *)(v49 | 0x400000);
    v48[4].m_prev = (ListItem_c *)HIDWORD(v49);
    CWorld::Add((CEntity *)v43[1].m_prev);
    HIWORD(v43[1].m_next) = v65;
    LOWORD(v43[1].m_next) = x;
    List_c::AddItem(&this->m_furnitureEntityList, v43);
    if ( heightInfo == 1 )
    {
      v50 = v65 | x;
      if ( pFurn->m_isTall )
      {
        if ( v50 >= 0 )
        {
          v51 = this->m_box;
          if ( m_depth + x <= v51->m_width && m_depth && v66 + v65 <= v51->m_depth )
          {
            v52 = 0;
            v53 = &this->m_tiles[x][v65];
            do
            {
              if ( v66 )
              {
                v54 = v66;
                v55 = v53;
                do
                {
                  v56 = *v55;
                  if ( v56 > 8 )
                  {
                    *v55 = 6;
                  }
                  else if ( ((1 << v56) & 0x1A0) == 0 )
                  {
                    *v55 = 6;
                  }
                  --v54;
                  ++v55;
                }
                while ( v54 );
              }
              ++v52;
              v53 += 30;
            }
            while ( v52 < m_depth );
          }
        }
      }
      else if ( v50 >= 0 )
      {
        v58 = this->m_box;
        if ( m_depth + x <= v58->m_width && m_depth && v66 + v65 <= v58->m_depth )
        {
          v59 = 0;
          v60 = &this->m_tiles[x][v65];
          do
          {
            if ( v66 )
            {
              v61 = v66;
              v62 = v60;
              do
              {
                v63 = *v62;
                if ( (unsigned int)(v63 - 7) >= 2 && v63 != 5 )
                {
                  if ( v63 == 9 )
                    *v62 = 10;
                  else
                    *v62 = 5;
                }
                --v61;
                ++v62;
              }
              while ( v61 );
            }
            ++v59;
            v60 += 30;
          }
          while ( v59 < m_depth );
        }
      }
    }
    *v13 = m_depth;
    v57 = 0;
    *v12 = v66;
    y = (int32)v43[1].m_prev;
  }
  else
  {
    v57 = 1;
  }
  CMatrix::~CMatrix(&mat);
  CMatrix::~CMatrix(&m2);
  CMatrix::~CMatrix(&m1);
  CMatrix::~CMatrix(&v74);
  if ( v57 == 1 )
    goto LABEL_75;
  return (CEntity *)y;
}
// 446A20: variables would overlap: ^204.4 and ^204.8

//----- (00446FAC) --------------------------------------------------------
int __fastcall Interior_c::CheckTilesEmpty(Interior_c *this, int32 x, int32 y, int32 w, int a5, int a6)
{
  CInteriorAttr *m_box; // r5
  int result; // r0
  int32 v8; // r8
  uint8 *v9; // r1
  int v10; // r4
  int v11; // r2
  int v12; // r5
  int v13; // r6
  bool v14; // zf

  if ( (y | x) < 0 )
    return 0;
  m_box = this->m_box;
  if ( w + x > m_box->m_width || a5 + y > m_box->m_depth )
    return 0;
  if ( w < 1 )
    return 1;
  v8 = 0;
  v9 = &this->m_tiles[x][y];
  while ( a5 < 1 )
  {
LABEL_18:
    ++v8;
    v9 += 30;
    result = 1;
    if ( v8 >= w )
      return result;
  }
  result = 0;
  v10 = 0;
  while ( 1 )
  {
    v11 = v9[v10];
    v12 = 0;
    v13 = a6;
    if ( v11 == 9 )
      v12 = 1;
    if ( a6 )
      v13 = 1;
    v14 = v11 == 0;
    if ( v9[v10] )
      v14 = (v13 & v12) == 1;
    if ( !v14 )
      return result;
    if ( ++v10 >= a5 )
      goto LABEL_18;
  }
}

//----- (00447040) --------------------------------------------------------
void __fastcall Interior_c::SetTilesStatus(Interior_c *this, int32 x, int32 y, int32 w, int a5, int a6, int a7)
{
  CInteriorAttr *m_box; // r6
  char *v8; // r0
  int32 v9; // r1
  char *v10; // r0
  int v11; // r6
  unsigned int v12; // r5
  bool v13; // zf

  if ( (y | x) >= 0 )
  {
    m_box = this->m_box;
    if ( w + x <= m_box->m_width && a5 + y <= m_box->m_depth && w >= 1 )
    {
      v8 = (char *)this + 30 * x + y;
      v9 = 0;
      v10 = v8 + 104;
      while ( a5 < 1 )
      {
LABEL_24:
        ++v9;
        v10 += 30;
        if ( v9 >= w )
          return;
      }
      v11 = 0;
      while ( 1 )
      {
        v12 = (unsigned __int8)v10[v11];
        v13 = a6 == 5;
        if ( a6 == 5 )
          v13 = v12 == 9;
        if ( v13 )
        {
          v10[v11] = 10;
          goto LABEL_23;
        }
        if ( a7 )
          break;
        if ( !v10[v11] )
          goto LABEL_17;
        if ( v12 == 3 )
        {
          if ( a6 != 4 )
          {
            if ( a6 == 3 )
              return;
            goto LABEL_23;
          }
LABEL_17:
          v10[v11] = a6;
        }
LABEL_23:
        if ( ++v11 >= a5 )
          goto LABEL_24;
      }
      if ( v12 <= 8 && ((1 << v12) & 0x1A0) != 0 )
        goto LABEL_23;
      goto LABEL_17;
    }
  }
}

//----- (004470D8) --------------------------------------------------------
CEntity *__fastcall Interior_c::PlaceFurnitureOnWall(
        Interior_c *this,
        int32 interior,
        int32 subGroup,
        int32 type,
        float z,
        int32 heightInfo,
        __int64 wallId,
        int32 offset,
        int32 *retWallId,
        int32 *retPos,
        int32 *x,
        int32 *y,
        int32 *w,
        int32 *d)
{
  int32 v15; // r9
  int32 v16; // r10
  Furniture_c *Furniture; // r5
  int v18; // r1
  int v19; // r11
  int v20; // r4
  int v21; // r6
  int m_width; // r4
  int m_depth; // r6
  int v24; // r4
  int v25; // r6
  CEntity *result; // r0
  int v27; // [sp+1Ch] [bp-4Ch]
  int32 v28; // [sp+28h] [bp-40h] BYREF
  int32 v29[15]; // [sp+2Ch] [bp-3Ch] BYREF

  v15 = HIDWORD(wallId);
  v16 = wallId;
  Furniture = FurnitureManager_c::GetFurniture(&g_furnitureMan, interior, subGroup, type, this->m_box->m_status);
  v18 = 100;
  if ( HIDWORD(wallId) != -1 )
    v18 = 1;
  if ( (_DWORD)wallId == -1 )
    v18 = 100;
  v27 = v18;
  if ( !Furniture )
    return 0;
  v19 = 0;
  while ( 1 )
  {
    if ( (_DWORD)wallId == -1 )
      v16 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 4.0);
    if ( (v16 | 2) == 3 )
    {
      if ( HIDWORD(wallId) == -1 )
      {
        m_width = Furniture->m_width;
        m_depth = this->m_box->m_depth;
        v15 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * (float)(m_depth - m_width));
        if ( v16 == 1 )
        {
LABEL_12:
          v20 = offset;
          v21 = v15;
          goto LABEL_20;
        }
      }
      else if ( v16 == 1 )
      {
        goto LABEL_12;
      }
      v21 = v15;
      v20 = this->m_box->m_width - offset - Furniture->m_depth;
    }
    else
    {
      if ( HIDWORD(wallId) == -1 )
      {
        v24 = Furniture->m_width;
        v25 = this->m_box->m_width;
        v15 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * (float)(v25 - v24));
        if ( v16 == 2 )
        {
LABEL_15:
          v20 = v15;
          v21 = offset;
          goto LABEL_20;
        }
      }
      else if ( v16 == 2 )
      {
        goto LABEL_15;
      }
      v20 = v15;
      v21 = this->m_box->m_depth - offset - Furniture->m_depth;
    }
LABEL_20:
    result = Interior_c::PlaceFurniture(this, Furniture, v20, v21, z, heightInfo, v16, v29, &v28, 0);
    if ( result )
      break;
    if ( ++v19 >= v27 )
      return 0;
  }
  if ( retWallId )
    *retWallId = v16;
  if ( retPos )
    *retPos = v15;
  if ( x )
    *x = v20;
  if ( y )
    *y = v21;
  if ( w )
    *w = v29[0];
  if ( d )
    *d = v28;
  return result;
}
// 4470D8: using guessed type int32 var_3C[15];

//----- (00447298) --------------------------------------------------------
CEntity *__fastcall Interior_c::PlaceFurnitureInCorner(
        Interior_c *this,
        int32 interior,
        int32 subGroup,
        int32 type,
        float z,
        int32 heightInfo,
        int32 wallId,
        int32 offset,
        int32 *retWallId,
        int32 *x,
        int32 *y,
        int32 *w,
        int32 *d)
{
  int v14; // r9
  Furniture_c *Furniture; // r5
  int v16; // r11
  int v17; // r10
  int v18; // r6
  int v19; // r4
  CInteriorAttr *m_box; // r0
  CEntity *result; // r0
  int32 v22; // [sp+20h] [bp-40h] BYREF
  int32 v23[15]; // [sp+24h] [bp-3Ch] BYREF

  v14 = wallId;
  Furniture = FurnitureManager_c::GetFurniture(&g_furnitureMan, interior, subGroup, type, this->m_box->m_status);
  v16 = 20;
  if ( wallId != -1 )
    v16 = 1;
  if ( !Furniture )
    return 0;
  v17 = 0;
  while ( 1 )
  {
    if ( wallId == -1 )
      v14 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 4.0);
    v18 = 0;
    v19 = offset;
    switch ( v14 )
    {
      case 0:
        v19 = 0;
        v18 = this->m_box->m_depth - offset - Furniture->m_depth;
        break;
      case 2:
        v18 = offset;
        v19 = this->m_box->m_width - Furniture->m_width;
        break;
      case 3:
        m_box = this->m_box;
        v18 = m_box->m_depth - Furniture->m_width;
        v19 = m_box->m_width - offset - Furniture->m_depth;
        break;
      default:
        break;
    }
    result = Interior_c::PlaceFurniture(this, Furniture, v19, v18, z, heightInfo, v14, v23, &v22, 0);
    if ( result )
      break;
    if ( ++v17 >= v16 )
      return 0;
  }
  if ( retWallId )
    *retWallId = v14;
  if ( x )
    *x = v19;
  if ( y )
    *y = v18;
  if ( w )
    *w = v23[0];
  if ( d )
    *d = v22;
  return result;
}
// 447298: using guessed type int32 var_3C[15];

//----- (004473C4) --------------------------------------------------------
Interior_c *__fastcall Interior_c::PlaceObject(
        Interior_c *this,
        int isStealable,
        Furniture_c *pFurn,
        float x,
        float y,
        float z,
        float rot)
{
  Interior_c *v7; // r4
  CInteriorAttr *m_box; // r0
  float v12; // s16
  float v13; // s18
  float v14; // s20
  float v15; // s26
  float v16; // s22
  float v17; // s2
  float v18; // s16
  float v19; // s20
  float v20; // s18
  ListItem_c *v21; // r6
  CObject *v22; // r0
  CPlaceable *v23; // r0
  int StealableObjectId; // r0
  ListItem_c *m_prev; // r0
  int v26; // r5
  int32 m_numStealableObjects; // r2
  char *v28; // r5
  int v29; // r0
  CMatrix v31; // [sp+8h] [bp-170h] BYREF
  CMatrix mat; // [sp+50h] [bp-128h] BYREF
  CMatrix v33; // [sp+98h] [bp-E0h] BYREF
  CMatrix v34; // [sp+E0h] [bp-98h] BYREF

  v7 = this;
  m_box = this->m_box;
  v12 = (float)-m_box->m_height;
  v13 = (float)-m_box->m_depth;
  v14 = (float)-m_box->m_width;
  v15 = CModelInfo::ms_modelInfoPtrs[pFurn->m_modelIndex]->m_pColModel->m_boxBound.m_vecMin.z;
  if ( List_c::GetNumItems(&g_furnitureMan.m_furnitureEntityPool) < 1 )
    return 0;
  v16 = x;
  v17 = (float)(v12 * 0.5) + z;
  v18 = (float)(v13 * 0.5) + y;
  v19 = (float)(v14 * 0.5) + x;
  v20 = v17 - v15;
  CMatrix::CMatrix(&v34, &v7->m_mat, 0);
  v33.m_pRwMat = 0;
  v33.m_owner = 0;
  mat.m_pRwMat = 0;
  mat.m_owner = 0;
  CMatrix::SetUnity(&v33);
  CMatrix::RotateZ(&v33, (float)(rot * 3.1416) / 180.0);
  v33.tx = v19 + v33.tx;
  v33.ty = v18 + v33.ty;
  v33.tz = (float)(v17 - v15) + v33.tz;
  operator*(&v31, &v34, &v33);
  CMatrix::operator=(&mat, &v31);
  CMatrix::~CMatrix(&v31);
  v21 = List_c::RemoveHead(&g_furnitureMan.m_furnitureEntityPool);
  if ( v21 )
  {
    v22 = (CObject *)CObject::operator new(0x184u);
    CObject::CObject(v22, pFurn->m_modelIndex, 0);
    v21[1].m_prev = (ListItem_c *)v23;
    CPlaceable::SetMatrix(v23, &mat);
    HIBYTE(v21[1].m_prev[6].m_prev) = v7->m_areaCode;
    v21[1].m_prev[3].m_next = (ListItem_c *)((int)v21[1].m_prev[3].m_next | 0x10000);
    LOBYTE(v21[1].m_prev[40].m_prev) = 5;
    ((void (__fastcall *)(ListItem_c *, int))v21[1].m_prev->m_prev[2].m_next)(v21[1].m_prev, 1);
    CWorld::Add((CEntity *)v21[1].m_prev);
    HIWORD(v21[1].m_next) = (unsigned int)y;
    LOWORD(v21[1].m_next) = (unsigned int)v16;
    List_c::AddItem(&v7->m_furnitureEntityList, v21);
    if ( isStealable )
    {
      v21[1].m_prev[40].m_next = (ListItem_c *)((int)v21[1].m_prev[40].m_next | 0x2000);
      if ( InteriorManager_c::HasInteriorHadStealDataSetup(&g_interiorMan, v7) )
      {
        StealableObjectId = InteriorManager_c::FindStealableObjectId(
                              (int)&g_interiorMan,
                              v7->m_id,
                              pFurn->m_modelIndex,
                              v19,
                              v18,
                              v20);
        if ( StealableObjectId >= 0 && g_interiorMan.m_stealableInfos[StealableObjectId].isStolen )
        {
          CWorld::Remove((CEntity *)v21[1].m_prev);
          m_prev = v21[1].m_prev;
          if ( m_prev )
            ((void (__fastcall *)(ListItem_c *))m_prev->m_prev->m_next)(m_prev);
          v26 = 0;
          v21[1].m_prev = 0;
          List_c::RemoveItem(&v7->m_furnitureEntityList, v21);
          List_c::AddItem(&g_furnitureMan.m_furnitureEntityPool, v21);
          v7 = 0;
          goto LABEL_16;
        }
        v29 = InteriorManager_c::FindStealableObjectId(
                (int)&g_interiorMan,
                v7->m_id,
                pFurn->m_modelIndex,
                v19,
                v18,
                v20);
        if ( v29 >= 0 )
          g_interiorMan.m_stealableInfos[v29].pEntity = (CEntity *)v21[1].m_prev;
      }
      else
      {
        m_numStealableObjects = g_interiorMan.m_numStealableObjects;
        v28 = (char *)&g_interiorMan + 28 * g_interiorMan.m_numStealableObjects;
        *((_DWORD *)v28 + 4331) = v21[1].m_prev;
        *((_DWORD *)v28 + 4332) = pFurn->m_modelIndex;
        *((_DWORD *)v28 + 4333) = v7->m_id;
        v28[17348] = 0;
        *((float *)v28 + 4334) = v19;
        *((float *)v28 + 4336) = v20;
        *((float *)v28 + 4335) = v18;
        g_interiorMan.m_numStealableObjects = m_numStealableObjects + 1;
      }
    }
    v7 = (Interior_c *)v21[1].m_prev;
    v26 = 0;
  }
  else
  {
    v26 = 1;
  }
LABEL_16:
  CMatrix::~CMatrix(&mat);
  CMatrix::~CMatrix(&v33);
  CMatrix::~CMatrix(&v34);
  if ( v26 == 1 )
    return 0;
  return v7;
}
// 4474FC: variable 'v23' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];

//----- (004476D4) --------------------------------------------------------
void __fastcall Interior_c::SetCornerTiles(Interior_c *this, int32 wallId, int32 size, int32 status, int a5)
{
  CInteriorAttr *m_box; // r6
  bool v6; // cc
  int32 v7; // lr
  _BYTE *v8; // r1
  unsigned int v9; // r6
  bool v10; // zf
  CInteriorAttr *v11; // r6
  int m_depth; // r1
  char *v13; // r0
  int v14; // r1
  unsigned int v15; // r6
  bool v16; // zf
  CInteriorAttr *v17; // r1
  int32 m_width; // r6
  bool v19; // cc
  uint8 (*m_tiles)[30]; // r1
  int32 v21; // lr
  unsigned int v22; // r6
  bool v23; // zf
  CInteriorAttr *v24; // r1
  int32 v25; // r1
  bool v26; // cc
  uint8 (*v27)[30]; // r0
  int v28; // r1
  unsigned int v29; // r6
  bool v30; // zf
  CInteriorAttr *v31; // r6
  int v32; // r1
  bool v33; // cc
  int32 v34; // lr
  _BYTE *v35; // r1
  unsigned int v36; // r6
  bool v37; // zf
  CInteriorAttr *v38; // r6
  int v39; // r1
  int32 v40; // r6
  bool v41; // cc
  char *v42; // r0
  int v43; // r1
  char *v44; // r0
  unsigned int v45; // r6
  bool v46; // zf
  CInteriorAttr *v47; // r6
  int v48; // r1
  int v49; // r6
  int32 v50; // lr
  _BYTE *v51; // r1
  unsigned int v52; // r6
  bool v53; // zf
  CInteriorAttr *v54; // r6
  int v55; // r1
  int v56; // r6
  int v57; // r5
  bool v58; // cc
  char *v59; // r0
  int v60; // r1
  unsigned int v61; // r6
  bool v62; // zf

  switch ( wallId )
  {
    case 0:
      m_box = this->m_box;
      if ( !m_box->m_depth )
        goto LABEL_24;
      v6 = size < 1;
      if ( size >= 1 )
        v6 = m_box->m_width < size;
      if ( v6 )
        goto LABEL_24;
      v7 = 0;
      v8 = (char *)&this->m_furnitureEntityList.m_numItems + m_box->m_depth + 3;
      do
      {
        v9 = (unsigned __int8)*v8;
        v10 = status == 5;
        if ( status == 5 )
          v10 = v9 == 9;
        if ( v10 )
        {
          *v8 = 10;
          goto LABEL_23;
        }
        if ( a5 )
        {
          if ( v9 > 8 )
            goto LABEL_22;
          if ( ((1 << v9) & 0x1A0) == 0 )
            *v8 = status;
        }
        else
        {
          if ( !*v8 )
            goto LABEL_22;
          if ( v9 != 3 )
            goto LABEL_23;
          if ( status == 4 )
          {
LABEL_22:
            *v8 = status;
            goto LABEL_23;
          }
          if ( status == 3 )
            break;
        }
LABEL_23:
        ++v7;
        v8 += 30;
      }
      while ( v7 < size );
LABEL_24:
      v11 = this->m_box;
      m_depth = v11->m_depth;
      if ( m_depth - size >= 0 && v11->m_width && size >= 1 )
      {
        v13 = (char *)this + m_depth + 104 - size;
        v14 = 0;
        while ( 1 )
        {
          v15 = (unsigned __int8)v13[v14];
          v16 = status == 5;
          if ( status == 5 )
            v16 = v15 == 9;
          if ( v16 )
          {
            v13[v14] = 10;
            goto LABEL_43;
          }
          if ( a5 )
            break;
          if ( !v13[v14] )
            goto LABEL_37;
          if ( v15 == 3 )
          {
            if ( status != 4 )
            {
              if ( status == 3 )
                return;
              goto LABEL_43;
            }
LABEL_37:
            v13[v14] = status;
          }
LABEL_43:
          if ( ++v14 >= size )
            return;
        }
        if ( v15 <= 8 && ((1 << v15) & 0x1A0) != 0 )
          goto LABEL_43;
        goto LABEL_37;
      }
      return;
    case 1:
      v17 = this->m_box;
      m_width = v17->m_width;
      v19 = m_width < size;
      if ( m_width >= size )
        v19 = size < 1;
      if ( v19 || !v17->m_depth )
        goto LABEL_67;
      m_tiles = this->m_tiles;
      v21 = 0;
      while ( 1 )
      {
        v22 = *(_BYTE *)m_tiles;
        v23 = status == 5;
        if ( status == 5 )
          v23 = v22 == 9;
        if ( v23 )
        {
          *(_BYTE *)m_tiles = 10;
        }
        else
        {
          if ( a5 )
          {
            if ( v22 <= 8 )
            {
              if ( ((1 << v22) & 0x1A0) == 0 )
                *(_BYTE *)m_tiles = status;
              goto LABEL_66;
            }
            goto LABEL_65;
          }
          if ( !*(_BYTE *)m_tiles )
            goto LABEL_65;
          if ( v22 == 3 )
          {
            if ( status != 4 )
            {
              if ( status == 3 )
                goto LABEL_67;
              goto LABEL_66;
            }
LABEL_65:
            *(_BYTE *)m_tiles = status;
          }
        }
LABEL_66:
        ++v21;
        ++m_tiles;
        if ( v21 >= size )
        {
LABEL_67:
          v24 = this->m_box;
          if ( !v24->m_width )
            return;
          v25 = v24->m_depth;
          v26 = v25 < size;
          if ( v25 >= size )
            v26 = size < 1;
          if ( v26 )
            return;
          v27 = this->m_tiles;
          v28 = 0;
          while ( 2 )
          {
            v29 = (*v27)[v28];
            v30 = status == 5;
            if ( status == 5 )
              v30 = v29 == 9;
            if ( v30 )
            {
              (*v27)[v28] = 10;
            }
            else if ( a5 )
            {
              if ( v29 > 8 || ((1 << v29) & 0x1A0) == 0 )
LABEL_81:
                (*v27)[v28] = status;
            }
            else
            {
              if ( !(*v27)[v28] )
                goto LABEL_81;
              if ( v29 == 3 )
              {
                if ( status == 4 )
                  goto LABEL_81;
                if ( status == 3 )
                  return;
              }
            }
            if ( ++v28 >= size )
              return;
            continue;
          }
        }
      }
    case 2:
      v31 = this->m_box;
      v32 = v31->m_width;
      v33 = v32 - size < 0;
      if ( v32 - size >= 0 )
        v33 = size < 1;
      if ( v33 || !v31->m_depth )
        goto LABEL_111;
      v34 = 0;
      v35 = (char *)this + 30 * v32 + 104 - 30 * size;
      while ( 1 )
      {
        v36 = (unsigned __int8)*v35;
        v37 = status == 5;
        if ( status == 5 )
          v37 = v36 == 9;
        if ( v37 )
        {
          *v35 = 10;
        }
        else
        {
          if ( a5 )
          {
            if ( v36 <= 8 )
            {
              if ( ((1 << v36) & 0x1A0) == 0 )
                *v35 = status;
              goto LABEL_110;
            }
            goto LABEL_109;
          }
          if ( !*v35 )
            goto LABEL_109;
          if ( v36 == 3 )
          {
            if ( status != 4 )
            {
              if ( status == 3 )
                goto LABEL_111;
              goto LABEL_110;
            }
LABEL_109:
            *v35 = status;
          }
        }
LABEL_110:
        ++v34;
        v35 += 30;
        if ( v34 >= size )
        {
LABEL_111:
          v38 = this->m_box;
          v39 = v38->m_width;
          if ( !v38->m_width )
            return;
          v40 = v38->m_depth;
          v41 = v40 < size;
          if ( v40 >= size )
            v41 = size < 1;
          if ( v41 )
            return;
          v42 = (char *)this + 30 * v39;
          v43 = 0;
          v44 = v42 + 74;
          while ( 2 )
          {
            v45 = (unsigned __int8)v44[v43];
            v46 = status == 5;
            if ( status == 5 )
              v46 = v45 == 9;
            if ( v46 )
            {
              v44[v43] = 10;
            }
            else if ( a5 )
            {
              if ( v45 > 8 || ((1 << v45) & 0x1A0) == 0 )
LABEL_125:
                v44[v43] = status;
            }
            else
            {
              if ( !v44[v43] )
                goto LABEL_125;
              if ( v45 == 3 )
              {
                if ( status == 4 )
                  goto LABEL_125;
                if ( status == 3 )
                  return;
              }
            }
            if ( ++v43 >= size )
              return;
            continue;
          }
        }
      }
    case 3:
      if ( size < 1 )
        goto LABEL_153;
      v47 = this->m_box;
      v48 = v47->m_width;
      v49 = v47->m_depth;
      if ( ((v48 - size) | (v49 - 1)) < 0 )
        goto LABEL_153;
      v50 = 0;
      v51 = (char *)this + v49 + 30 * v48 + 103 - 30 * size;
      break;
    default:
      return;
  }
  while ( 1 )
  {
    v52 = (unsigned __int8)*v51;
    v53 = status == 5;
    if ( status == 5 )
      v53 = v52 == 9;
    if ( v53 )
    {
      *v51 = 10;
    }
    else
    {
      if ( a5 )
      {
        if ( v52 <= 8 )
        {
          if ( ((1 << v52) & 0x1A0) == 0 )
            *v51 = status;
          goto LABEL_152;
        }
        goto LABEL_151;
      }
      if ( !*v51 )
        goto LABEL_151;
      if ( v52 == 3 )
      {
        if ( status != 4 )
        {
          if ( status == 3 )
            goto LABEL_153;
          goto LABEL_152;
        }
LABEL_151:
        *v51 = status;
      }
    }
LABEL_152:
    ++v50;
    v51 += 30;
    if ( v50 >= size )
    {
LABEL_153:
      v54 = this->m_box;
      v55 = v54->m_width;
      v56 = v54->m_depth;
      v57 = (v56 - size) | (v55 - 1);
      v58 = v57 < 0;
      if ( v57 >= 0 )
        v58 = size < 1;
      if ( v58 )
        return;
      v59 = (char *)this + v56 + 30 * v55 + 74 - size;
      v60 = 0;
      while ( 2 )
      {
        v61 = (unsigned __int8)v59[v60];
        v62 = status == 5;
        if ( status == 5 )
          v62 = v61 == 9;
        if ( v62 )
        {
          v59[v60] = 10;
        }
        else if ( a5 )
        {
          if ( v61 > 8 || ((1 << v61) & 0x1A0) == 0 )
LABEL_166:
            v59[v60] = status;
        }
        else
        {
          if ( !v59[v60] )
            goto LABEL_166;
          if ( v61 == 3 )
          {
            if ( status == 4 )
              goto LABEL_166;
            if ( status == 3 )
              return;
          }
        }
        if ( ++v60 >= size )
          return;
        continue;
      }
    }
  }
}

//----- (00447A26) --------------------------------------------------------
int32 __fastcall Interior_c::GetNumEmptyTiles(Interior_c *this, int32 x, int32 y, int32 dir, int a5)
{
  CInteriorAttr *m_box; // r11
  int v6; // lr
  bool v7; // zf
  int32 m_width; // r10
  int v9; // r3
  uint8 *v10; // r9
  int32 result; // r0
  int v12; // r3
  uint8 *v13; // r8
  int v14; // r6
  uint8 *v15; // r3

  m_box = this->m_box;
  v6 = 1;
  if ( !dir )
    v6 = -1;
  v7 = dir == 3;
  m_width = m_box->m_width;
  v9 = dir | 2;
  if ( v7 )
    v6 = -1;
  if ( v9 == 3 )
  {
    v10 = this->m_tiles[x];
    for ( result = 0; a5 < 1; ++result )
    {
LABEL_7:
      v10 += 30 * v6;
      x += v6;
    }
    v12 = 0;
    while ( x < m_width && x >= 0 && y + v12 < (unsigned int)m_box->m_depth && !v10[y + v12] )
    {
      if ( ++v12 >= a5 )
        goto LABEL_7;
    }
  }
  else
  {
    v13 = &this->m_tiles[x][y];
    for ( result = 0; a5 < 1; ++result )
    {
LABEL_16:
      v13 += v6;
      y += v6;
    }
    v14 = 0;
    v15 = v13;
    while ( x + v14 < m_width && x + v14 >= 0 && y < (unsigned int)m_box->m_depth && !*v15 )
    {
      ++v14;
      v15 += 30;
      if ( v14 >= a5 )
        goto LABEL_16;
    }
  }
  return result;
}

//----- (00447AEE) --------------------------------------------------------
int32 __fastcall Interior_c::FindFirstEmptyTile(Interior_c *this, int32 x, int32 y, int32 dir)
{
  CInteriorAttr *m_box; // r4
  int v5; // r12
  bool v6; // zf
  unsigned int m_width; // lr
  int v8; // r3
  unsigned int m_depth; // r4
  uint8 *v10; // r0
  char *v12; // r0

  m_box = this->m_box;
  v5 = 1;
  if ( !dir )
    v5 = -1;
  v6 = dir == 3;
  m_width = m_box->m_width;
  v8 = dir | 2;
  m_depth = m_box->m_depth;
  if ( v6 )
    v5 = -1;
  if ( v8 == 3 )
  {
    v10 = &this->m_tiles[x][y];
    if ( x < m_width )
      goto LABEL_8;
    do
    {
      do
      {
        v10 += 30 * v5;
        x += v5;
      }
      while ( x >= m_width );
LABEL_8:
      ;
    }
    while ( m_depth <= y || *v10 );
    return x;
  }
  else
  {
    v12 = (char *)this + 30 * x;
    if ( m_width > x )
      goto LABEL_13;
    do
    {
      do
        y += v5;
      while ( m_width <= x );
LABEL_13:
      ;
    }
    while ( y >= m_depth || v12[y + 104] );
    return y;
  }
}

//----- (00447B68) --------------------------------------------------------
void __fastcall Interior_c::GetRandomTile(Interior_c *this, int32 status, int32 *x, int32 *y)
{
  int32 m_width; // r5
  unsigned __int16 v9; // r0
  unsigned int m_depth; // r6
  float v11; // s18
  unsigned __int16 v12; // r0
  int v13; // r2
  CInteriorAttr *m_box; // r3
  int32 v15; // s2
  unsigned int v16; // s0

  LOBYTE(m_width) = this->m_box->m_width;
  do
  {
    v9 = rand();
    m_depth = this->m_box->m_depth;
    v11 = (float)v9;
    v12 = rand();
    v13 = 1;
    m_box = this->m_box;
    v15 = (int)(float)((float)(v11 * 0.000015259) * (float)(unsigned __int8)m_width);
    v16 = (int)(float)((float)((float)v12 * 0.000015259) * (float)m_depth);
    m_width = m_box->m_width;
    if ( m_width > v15 && v15 >= 0 && m_box->m_depth > v16 )
      v13 = this->m_tiles[v15][v16];
  }
  while ( v13 != status );
  *x = v15;
  *y = v16;
}

//----- (00447C14) --------------------------------------------------------
int __fastcall Interior_c::FindEmptyTiles(Interior_c *this, int32 w, int32 h, int32 *x, int32 *y)
{
  uint8 (*m_tiles)[30]; // r10
  int v9; // r0
  int v10; // r8
  int m_width; // r4
  unsigned __int16 v12; // r0
  int m_depth; // r6
  float v14; // s18
  int32 v15; // s0
  int32 v16; // r0
  CInteriorAttr *m_box; // r2
  int32 v18; // r3
  uint8 *v19; // r2
  int v20; // r4
  int v21; // r6
  bool v22; // zf

  m_tiles = this->m_tiles;
  v9 = 0;
  while ( 1 )
  {
    v10 = v9;
    m_width = this->m_box->m_width;
    v12 = rand();
    m_depth = this->m_box->m_depth;
    v14 = (float)v12;
    v15 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * (float)(m_depth - h));
    v16 = (int)(float)((float)(v14 * 0.000015259) * (float)(m_width - w));
    if ( (v15 | v16) >= 0 )
    {
      m_box = this->m_box;
      if ( v16 + w <= m_box->m_width && v15 + h <= m_box->m_depth )
        break;
    }
LABEL_16:
    v9 = v10 + 1;
    if ( v10 >= 99 )
      return 0;
  }
  if ( w >= 1 )
  {
    v18 = 0;
    v19 = &m_tiles[v16][v15];
    while ( h < 1 )
    {
LABEL_14:
      ++v18;
      v19 += 30;
      if ( v18 >= w )
        goto LABEL_18;
    }
    v20 = 0;
    while ( 1 )
    {
      v21 = v19[v20];
      v22 = v21 == 9;
      if ( v21 != 9 )
        v22 = v21 == 0;
      if ( !v22 )
        goto LABEL_16;
      if ( ++v20 >= h )
        goto LABEL_14;
    }
  }
LABEL_18:
  *x = v16;
  *y = v15;
  return 1;
}

//----- (00447D10) --------------------------------------------------------
void __fastcall Interior_c::AddGotoPt(Interior_c *this, int32 tileX, int32 tileY, float offsetX, float offsetY)
{
  CInteriorAttr *m_box; // r0
  int32 m_width; // r1
  __int64 v10; // d16
  GotoPt_t *v11; // r0
  int8 m_numGotoPts; // r0
  CInteriorAttr *v13; // r1
  int32 v14; // r2
  bool v15; // cc
  char *v16; // r1
  _BYTE *v17; // r1
  int v18; // r2
  int v19; // t1
  bool v20; // zf
  RwV3d_0 v21[2]; // [sp+0h] [bp-20h] BYREF

  if ( this->m_numGotoPts <= 15 )
  {
    m_box = this->m_box;
    m_width = m_box->m_width;
    if ( m_width > tileX
      && (tileX >= 0 && m_box->m_depth > (unsigned int)tileY && this->m_tiles[tileX][tileY] == 3
       || tileX >= 0 && m_box->m_depth > (unsigned int)tileY && this->m_tiles[tileX][tileY] == 7) )
    {
      v21[0].x = (float)((float)((float)tileX + offsetX) + (float)((float)-m_width * 0.5)) + 0.5;
      v21[0].y = (float)((float)((float)tileY + offsetY) + (float)((float)-m_box->m_depth * 0.5)) + 0.5;
      v21[0].z = (float)-m_box->m_height * 0.5;
      RwV3dTransformPoints(v21, v21, 1, &this->m_mat);
      v10 = *(_QWORD *)&v21[0].x;
      v11 = &this->m_gotoPts[this->m_numGotoPts];
      v11->pos.z = v21[0].z;
      *(_QWORD *)&v11->pos.x = v10;
      m_numGotoPts = this->m_numGotoPts;
      this->m_gotoPts[m_numGotoPts].tileX = tileX;
      this->m_gotoPts[m_numGotoPts].tileY = tileY;
      if ( (tileY | tileX) >= 0 )
      {
        v13 = this->m_box;
        v14 = v13->m_width;
        v15 = v14 <= tileX;
        if ( v14 > tileX )
          v15 = v13->m_depth <= tileY;
        if ( !v15 )
        {
          v16 = (char *)this + 30 * tileX + tileY;
          v19 = (unsigned __int8)v16[104];
          v17 = v16 + 104;
          v18 = v19;
          v20 = v19 == 3;
          if ( v19 != 3 )
            v20 = v18 == 0;
          if ( v20 )
          {
            *v17 = 4;
            m_numGotoPts = this->m_numGotoPts;
          }
        }
      }
      this->m_numGotoPts = m_numGotoPts + 1;
    }
  }
}

//----- (00447E54) --------------------------------------------------------
int __fastcall Interior_c::AddInteriorInfo(Interior_c *this, int32 type, float tileX, float tileY, int a5, int a6)
{
  char v7; // r8
  int v8; // r6
  CInteriorAttr *m_box; // r0
  int v10; // r0
  int v11; // r0
  char *v12; // r0
  __int64 v13; // d16
  RwReal z; // r1
  __int64 v15; // d16
  RwV3d_0 v17; // [sp+0h] [bp-38h] BYREF
  RwV3d_0 pointsIn; // [sp+10h] [bp-28h] BYREF

  v7 = type;
  v8 = 0;
  if ( this->m_numInteriorInfos <= 15 )
  {
    m_box = this->m_box;
    pointsIn.x = (float)((float)((float)-m_box->m_width * 0.5) + tileX) + 0.5;
    pointsIn.y = (float)((float)((float)-m_box->m_depth * 0.5) + tileY) + 0.5;
    pointsIn.z = (float)-m_box->m_height * 0.5;
    RwV3dTransformPoints(&pointsIn, &pointsIn, 1, &this->m_mat);
    pointsIn.z = pointsIn.z + 0.8;
    memset(&v17, 0, sizeof(v17));
    switch ( a5 )
    {
      case -1:
        goto LABEL_10;
      case 0:
        v10 = -1082130432;
        goto LABEL_6;
      case 1:
        v11 = 1065353216;
        goto LABEL_8;
      case 2:
        v10 = 1065353216;
LABEL_6:
        LODWORD(v17.y) = v10;
        break;
      case 3:
        v11 = -1082130432;
LABEL_8:
        LODWORD(v17.x) = v11;
        break;
      default:
        break;
    }
    RwV3dTransformVectors(&v17, &v17, 1, &this->m_mat);
LABEL_10:
    v8 = 1;
    v12 = (char *)this + 32 * this->m_numInteriorInfos;
    v12[1424] = v7;
    v13 = *(_QWORD *)&pointsIn.x;
    *((_DWORD *)v12 + 359) = LODWORD(pointsIn.z);
    *(_QWORD *)(v12 + 1428) = v13;
    z = v17.z;
    v15 = *(_QWORD *)&v17.x;
    v12[1425] = 0;
    *((RwReal *)v12 + 362) = z;
    *((_DWORD *)v12 + 363) = a6;
    *((_QWORD *)v12 + 180) = v15;
    ++this->m_numInteriorInfos;
  }
  return v8;
}

//----- (00447F84) --------------------------------------------------------
void __fastcall Interior_c::FurnishBedroom(Interior_c *this)
{
  int32 v1; // r10
  int32 v2; // r11
  int32 v4; // r6
  int8 RandomId; // r0
  CInteriorAttr *m_box; // r1
  int32 v7; // r5
  CEntity *v8; // r8
  int32 v9; // r1
  int v10; // r2
  int v11; // r3
  int v12; // r0
  int m_depth; // r0
  int m_width; // r0
  int32 v15; // r1
  int v16; // r2
  int v17; // r3
  int v18; // r0
  int v19; // r0
  int v20; // r0
  int v21; // r0
  float v22; // s20
  float v23; // s22
  int v24; // r5
  float v25; // s20
  float v26; // s22
  int v27; // r11
  Furniture_c *Furniture; // r0
  Furniture_c *v29; // r0
  unsigned int m_status; // r5
  int v31; // r6
  float v32; // s0
  Furniture_c *v33; // r2
  Furniture_c *v34; // r2
  Furniture_c *v35; // r2
  Furniture_c *v36; // r2
  Furniture_c *v37; // r2
  Furniture_c *v38; // r0
  __int64 dir; // [sp+8h] [bp-80h]
  __int64 dira; // [sp+8h] [bp-80h]
  int32 y; // [sp+30h] [bp-58h] BYREF
  int32 x; // [sp+34h] [bp-54h] BYREF
  int32 v43; // [sp+38h] [bp-50h] BYREF
  int32 w; // [sp+3Ch] [bp-4Ch] BYREF
  int32 retPos; // [sp+40h] [bp-48h] BYREF
  int32 retWallId[17]; // [sp+44h] [bp-44h] BYREF

  v4 = 1;
  RandomId = FurnitureManager_c::GetRandomId(&g_furnitureMan, 3, 1, this->m_box->m_status);
  m_box = this->m_box;
  this->m_style = RandomId;
  v7 = 0;
  Interior_c::SetTilesStatus(this, m_box->m_door - 1, 0, 2, 2, 7, 0);
  v8 = Interior_c::PlaceFurnitureOnWall(this, 3, 0, -1, 0.0, 1, -1LL, 0, retWallId, &retPos, 0, 0, 0, 0);
  if ( retPos >= 1 )
  {
    LODWORD(dir) = retWallId[0];
    HIDWORD(dir) = retPos - 1;
    if ( Interior_c::PlaceFurnitureOnWall(this, 3, 1, this->m_style, 0.0, 1, dir, 0, 0, 0, 0, 0, 0, 0) )
    {
      v12 = retWallId[0];
      switch ( retWallId[0] )
      {
        case 0:
          m_depth = this->m_box->m_depth;
          v2 = retPos - 1;
          v9 = 3;
          v1 = m_depth - 3;
          v11 = m_depth - 2;
          goto LABEL_7;
        case 1:
          v9 = 3;
          v10 = 1;
          v2 = 2;
          v1 = retPos - 1;
          goto LABEL_9;
        case 2:
          v9 = 4;
          v1 = 2;
          v11 = 1;
          v2 = retPos - 1;
LABEL_7:
          v12 = 1;
          v10 = v2;
          break;
        case 3:
          m_width = this->m_box->m_width;
          v1 = retPos - 1;
          v9 = 4;
          v2 = m_width - 3;
          v10 = m_width - 2;
LABEL_9:
          v12 = 2;
          v11 = v1;
          break;
        default:
          break;
      }
      Interior_c::AddInteriorInfo(this, v9, (float)v10, (float)v11, v12, (int)v8);
      Interior_c::SetTilesStatus(this, v2, v1, 1, 1, 2, 0);
    }
  }
  LODWORD(dira) = retWallId[0];
  HIDWORD(dira) = retPos + 2;
  if ( Interior_c::PlaceFurnitureOnWall(this, 3, 1, this->m_style, 0.0, 1, dira, 0, 0, 0, 0, 0, 0, 0) )
  {
    v18 = retWallId[0];
    switch ( retWallId[0] )
    {
      case 0:
        v19 = this->m_box->m_depth;
        v7 = retPos + 2;
        v15 = 4;
        v4 = v19 - 3;
        v16 = v19 - 2;
        goto LABEL_16;
      case 1:
        v15 = 4;
        v17 = 1;
        v7 = 2;
        v4 = retPos + 2;
        goto LABEL_18;
      case 2:
        v16 = 1;
        v4 = 2;
        v15 = 3;
        v7 = retPos + 2;
LABEL_16:
        v18 = 3;
        v17 = v7;
        break;
      case 3:
        v20 = this->m_box->m_width;
        v4 = retPos + 2;
        v15 = 3;
        v7 = v20 - 3;
        v17 = v20 - 2;
LABEL_18:
        v18 = 0;
        v16 = v4;
        break;
      default:
        break;
    }
    Interior_c::AddInteriorInfo(this, v15, (float)v17, (float)v16, v18, (int)v8);
    Interior_c::SetTilesStatus(this, v7, v4, 1, 1, 2, 0);
  }
  Interior_c::PlaceFurnitureOnWall(this, 3, 3, this->m_style, 0.0, 1, -1LL, 0, 0, 0, 0, 0, 0, 0);
  Interior_c::PlaceFurnitureOnWall(this, 3, 2, this->m_style, 0.0, 1, -1LL, 0, 0, 0, 0, 0, 0, 0);
  v21 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0);
  if ( v21 <= 24 )
  {
    if ( !Interior_c::PlaceFurnitureOnWall(this, 2, 6, -1, 0.0, 1, -1LL, 0, retWallId, 0, &x, &y, 0, 0) )
      goto LABEL_48;
    v22 = (float)y;
    v23 = (float)x;
    v24 = retWallId[0];
    if ( (retWallId[0] | 2) == 2 )
    {
      v23 = v23 + 0.5;
    }
    else if ( (retWallId[0] | 2) == 3 )
    {
      v22 = v22 + 0.5;
    }
    Furniture = FurnitureManager_c::GetFurniture(&g_furnitureMan, 2, 8, -1, this->m_box->m_status);
    goto LABEL_47;
  }
  if ( v21 <= 49 )
  {
    if ( !Interior_c::PlaceFurnitureOnWall(this, 2, 6, -1, 0.0, 1, -1LL, 0, retWallId, 0, &x, &y, 0, 0) )
      goto LABEL_48;
    v22 = (float)y;
    v23 = (float)x;
    v24 = retWallId[0];
    if ( (retWallId[0] | 2) == 2 )
    {
      v23 = v23 + 0.5;
    }
    else if ( (retWallId[0] | 2) == 3 )
    {
      v22 = v22 + 0.5;
    }
    goto LABEL_46;
  }
  if ( v21 <= 74 )
  {
    if ( Interior_c::PlaceFurnitureOnWall(this, 2, 6, -1, 0.0, 1, -1LL, 0, retWallId, 0, &x, &y, 0, 0) )
    {
      v25 = (float)y;
      v26 = (float)x;
      v27 = retWallId[0];
      if ( (retWallId[0] | 2) == 2 )
      {
        v26 = v26 + 0.5;
      }
      else if ( (retWallId[0] | 2) == 3 )
      {
        v25 = v25 + 0.5;
      }
      v29 = FurnitureManager_c::GetFurniture(&g_furnitureMan, 2, 8, -1, this->m_box->m_status);
      Interior_c::PlaceObject(this, 1u, v29, v26 + 0.5, v25 + 0.5, 0.5, (float)v27 * 90.0);
    }
    if ( Interior_c::PlaceFurnitureOnWall(this, 2, 6, -1, 0.0, 1, -1LL, 0, retWallId, 0, &x, &y, 0, 0) )
    {
      v22 = (float)y;
      v23 = (float)x;
      v24 = retWallId[0];
      if ( (retWallId[0] | 2) == 2 )
      {
        v23 = v23 + 0.5;
      }
      else if ( (retWallId[0] | 2) == 3 )
      {
        v22 = v22 + 0.5;
      }
LABEL_46:
      Furniture = FurnitureManager_c::GetFurniture(&g_furnitureMan, 2, 3, -1, this->m_box->m_status);
LABEL_47:
      Interior_c::PlaceObject(this, 1u, Furniture, v23 + 0.5, v22 + 0.5, 0.5, (float)v24 * 90.0);
    }
  }
LABEL_48:
  m_status = this->m_box->m_status;
  if ( m_status < 0x4B )
  {
    v32 = (float)(unsigned __int16)rand() * 0.000015259;
    if ( m_status < 0x32 )
      v31 = (int)(float)(v32 * 50.0) + 50;
    else
      v31 = (int)(float)(v32 * 30.0) + 20;
  }
  else
  {
    v31 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 20.0);
  }
  if ( v31 > (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 60.0)
    && Interior_c::FindEmptyTiles(this, 2, 2, &w, &v43) )
  {
    v33 = FurnitureManager_c::GetFurniture(&g_furnitureMan, 8, 2, -1, this->m_box->m_status);
    Interior_c::PlaceObject(this, 0, v33, (float)w + 0.5, (float)v43 + 0.5, 0.05, 0.0);
    Interior_c::SetTilesStatus(this, w, v43, 2, 2, 2, 0);
  }
  if ( v31 > (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0)
    && Interior_c::FindEmptyTiles(this, 1, 1, &w, &v43) )
  {
    v34 = FurnitureManager_c::GetFurniture(&g_furnitureMan, 8, 5, -1, this->m_box->m_status);
    Interior_c::PlaceObject(this, 0, v34, (float)w + 0.5, (float)v43 + 0.5, 0.05, 0.0);
    Interior_c::SetTilesStatus(this, w, v43, 1, 1, 2, 0);
  }
  if ( v31 > (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0)
    && Interior_c::FindEmptyTiles(this, 1, 1, &w, &v43) )
  {
    v35 = FurnitureManager_c::GetFurniture(&g_furnitureMan, 8, 4, -1, this->m_box->m_status);
    Interior_c::PlaceObject(this, 0, v35, (float)w + 0.5, (float)v43 + 0.5, 0.05, 0.0);
    Interior_c::SetTilesStatus(this, w, v43, 1, 1, 2, 0);
  }
  if ( v31 > (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0)
    && Interior_c::FindEmptyTiles(this, 1, 1, &w, &v43) )
  {
    v36 = FurnitureManager_c::GetFurniture(&g_furnitureMan, 8, 3, -1, this->m_box->m_status);
    Interior_c::PlaceObject(this, 0, v36, (float)w + 0.5, (float)v43 + 0.5, 0.05, 0.0);
    Interior_c::SetTilesStatus(this, w, v43, 1, 1, 2, 0);
  }
  if ( v31 > (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0)
    && Interior_c::FindEmptyTiles(this, 2, 2, &w, &v43) )
  {
    v37 = FurnitureManager_c::GetFurniture(&g_furnitureMan, 8, 6, -1, this->m_box->m_status);
    Interior_c::PlaceObject(this, 0, v37, (float)w + 0.5, (float)v43 + 0.5, 0.05, 0.0);
    Interior_c::SetTilesStatus(this, w, v43, 1, 1, 2, 0);
  }
  v38 = FurnitureManager_c::GetFurniture(&g_furnitureMan, 8, 1, -1, this->m_box->m_status);
  Interior_c::PlaceFurniture(
    this,
    v38,
    (int)(float)((float)((float)this->m_box->m_width * 0.5) - (float)((float)v38->m_width * 0.5)),
    (int)(float)((float)((float)this->m_box->m_depth * 0.5) - (float)((float)v38->m_depth * 0.5)),
    0.0,
    0,
    0,
    &w,
    &v43,
    0);
}
// 4480AC: variable 'v9' is possibly undefined
// 4480A4: variable 'v10' is possibly undefined
// 4480A8: variable 'v11' is possibly undefined
// 4480C4: variable 'v2' is possibly undefined
// 4480C4: variable 'v1' is possibly undefined
// 448160: variable 'v15' is possibly undefined
// 448158: variable 'v17' is possibly undefined
// 44814E: variable 'v16' is possibly undefined

//----- (004488CC) --------------------------------------------------------
void __fastcall Interior_c::Bedroom_AddTableItem(
        Interior_c *this,
        int32 interior,
        int32 subGroup,
        int32 wallId,
        int32 x,
        int32 y,
        int32 xa)
{
  float v8; // s16
  float v9; // s18
  Furniture_c *Furniture; // r0

  v8 = (float)y;
  v9 = (float)x;
  if ( (wallId | 2) == 2 )
  {
    v9 = v9 + 0.5;
  }
  else if ( (wallId | 2) == 3 )
  {
    v8 = v8 + 0.5;
  }
  Furniture = FurnitureManager_c::GetFurniture(&g_furnitureMan, interior, subGroup, -1, this->m_box->m_status);
  Interior_c::PlaceObject(this, 1u, Furniture, v9 + 0.5, v8 + 0.5, 0.5, (float)xa * 90.0);
}

//----- (00448964) --------------------------------------------------------
void __fastcall InteriorGroup_c::Init(InteriorGroup_c *this, CEntity *pEntity, int32 groupId)
{
  CPed **v3; // r1
  CPed **m_pPeds; // r0

  this->m_pEntity = pEntity;
  this->m_groupId = groupId;
  this->m_numInteriors = 0;
  this->m_pathsSetup = 0;
  this->m_pedsSetup = 0;
  this->m_isVisible = 0;
  this->m_lastIsVisible = 0;
  this->m_animsReferenced = 0;
  *(_QWORD *)&this->m_pInteriors[4] = 0LL;
  *(_QWORD *)&this->m_pInteriors[6] = 0LL;
  *(_QWORD *)this->m_pInteriors = 0LL;
  *(_QWORD *)&this->m_pInteriors[2] = 0LL;
  *(_QWORD *)&this->m_pPedsToRemove[12] = 0LL;
  *(_QWORD *)&this->m_pPedsToRemove[14] = 0LL;
  *(_QWORD *)&this->m_pPedsToRemove[8] = 0LL;
  *(_QWORD *)&this->m_pPedsToRemove[10] = 0LL;
  *(_QWORD *)&this->m_pPedsToRemove[4] = 0LL;
  *(_QWORD *)&this->m_pPedsToRemove[6] = 0LL;
  *(_QWORD *)this->m_pPedsToRemove = 0LL;
  *(_QWORD *)&this->m_pPedsToRemove[2] = 0LL;
  *(_QWORD *)&this->m_pPeds[12] = 0LL;
  *(_QWORD *)&this->m_pPeds[14] = 0LL;
  *(_QWORD *)&this->m_pPeds[8] = 0LL;
  *(_QWORD *)&this->m_pPeds[10] = 0LL;
  v3 = &this->m_pPeds[4];
  m_pPeds = this->m_pPeds;
  *(_QWORD *)v3 = 0LL;
  *((_QWORD *)v3 + 1) = 0LL;
  *(_QWORD *)m_pPeds = 0LL;
  *((_QWORD *)m_pPeds + 1) = 0LL;
}

//----- (004489D4) --------------------------------------------------------
void __fastcall InteriorGroup_c::Exit(InteriorGroup_c *this)
{
  Interior_c *v2; // r0
  Interior_c *v3; // r0
  Interior_c *v4; // r0
  Interior_c *v5; // r0
  Interior_c *v6; // r0
  Interior_c *v7; // r0
  Interior_c *v8; // r0
  Interior_c *v9; // r0
  CPed **m_pPeds; // r5
  int i; // r4
  CPed *v12; // r0
  int32 m_animsReferenced; // r0
  unsigned int m_groupType; // r1

  v2 = this->m_pInteriors[0];
  if ( v2 )
  {
    Interior_c::Exit(v2);
    InteriorManager_c::ReturnInteriorToPool(&g_interiorMan, this->m_pInteriors[0]);
  }
  v3 = this->m_pInteriors[1];
  if ( v3 )
  {
    Interior_c::Exit(v3);
    InteriorManager_c::ReturnInteriorToPool(&g_interiorMan, this->m_pInteriors[1]);
  }
  v4 = this->m_pInteriors[2];
  if ( v4 )
  {
    Interior_c::Exit(v4);
    InteriorManager_c::ReturnInteriorToPool(&g_interiorMan, this->m_pInteriors[2]);
  }
  v5 = this->m_pInteriors[3];
  if ( v5 )
  {
    Interior_c::Exit(v5);
    InteriorManager_c::ReturnInteriorToPool(&g_interiorMan, this->m_pInteriors[3]);
  }
  v6 = this->m_pInteriors[4];
  if ( v6 )
  {
    Interior_c::Exit(v6);
    InteriorManager_c::ReturnInteriorToPool(&g_interiorMan, this->m_pInteriors[4]);
  }
  v7 = this->m_pInteriors[5];
  if ( v7 )
  {
    Interior_c::Exit(v7);
    InteriorManager_c::ReturnInteriorToPool(&g_interiorMan, this->m_pInteriors[5]);
  }
  v8 = this->m_pInteriors[6];
  if ( v8 )
  {
    Interior_c::Exit(v8);
    InteriorManager_c::ReturnInteriorToPool(&g_interiorMan, this->m_pInteriors[6]);
  }
  v9 = this->m_pInteriors[7];
  if ( v9 )
  {
    Interior_c::Exit(v9);
    InteriorManager_c::ReturnInteriorToPool(&g_interiorMan, this->m_pInteriors[7]);
  }
  m_pPeds = this->m_pPeds;
  for ( i = 0; i != 16; ++i )
  {
    v12 = m_pPeds[i];
    if ( v12 )
    {
      if ( CPed::IsPointerValid(v12) )
      {
        if ( !CPed::IsAlive(m_pPeds[i]) )
          g_interiorMan.m_pedsAlive[i] = 0;
        CPopulation::RemovePed(m_pPeds[i]);
      }
      else
      {
        g_interiorMan.m_pedsAlive[i] = 0;
      }
      m_pPeds[i] = 0;
    }
  }
  this->m_numPeds = 0;
  CPathFind::RemoveInterior(&ThePaths, this->m_id);
  m_animsReferenced = this->m_animsReferenced;
  if ( this->m_animsReferenced )
  {
    m_groupType = this->m_groupType;
    if ( m_groupType <= 2 )
      m_animsReferenced = CAnimManager::GetAnimationBlockIndex((const unsigned __int8 *)off_667D8C[m_groupType]);
    CAnimManager::RemoveAnimBlockRef(m_animsReferenced);
    this->m_animsReferenced = 0;
  }
}
// 667D8C: using guessed type char *off_667D8C[6];

//----- (00448B6C) --------------------------------------------------------
void __fastcall InteriorGroup_c::DereferenceAnims(InteriorGroup_c *this)
{
  int32 m_animsReferenced; // r0
  unsigned int m_groupType; // r1

  m_animsReferenced = this->m_animsReferenced;
  if ( m_animsReferenced )
  {
    m_groupType = this->m_groupType;
    if ( m_groupType <= 2 )
      m_animsReferenced = CAnimManager::GetAnimationBlockIndex((const unsigned __int8 *)off_667D8C[m_groupType]);
    CAnimManager::RemoveAnimBlockRef(m_animsReferenced);
    this->m_animsReferenced = 0;
  }
}
// 667D8C: using guessed type char *off_667D8C[6];

//----- (00448BA0) --------------------------------------------------------
void __fastcall InteriorGroup_c::Update(InteriorGroup_c *this)
{
  int m_numInteriors; // r0
  int v3; // r6
  int m_groupType; // r0
  int i; // r5
  CPed *v6; // r0
  int32 m_animsReferenced; // r0
  unsigned int v8; // r1

  m_numInteriors = this->m_numInteriors;
  this->m_lastIsVisible = this->m_isVisible;
  this->m_isVisible = 0;
  if ( m_numInteriors >= 1 )
  {
    v3 = 0;
    while ( !Interior_c::IsVisible(this->m_pInteriors[v3]) )
    {
      if ( ++v3 >= this->m_numInteriors )
        goto LABEL_7;
    }
    this->m_isVisible = 1;
  }
LABEL_7:
  if ( this->m_pathsSetup || (InteriorGroup_c::SetupPaths(this), this->m_pathsSetup) )
  {
    if ( !this->m_pedsSetup )
    {
      if ( !this->m_pEntryExit || !g_interiorMan.m_activePeds )
        goto LABEL_31;
      m_groupType = (unsigned __int8)this->m_groupType;
      if ( m_groupType == 2 )
      {
        CStreaming::StreamPedsForInterior(2);
        CStreaming::LoadAllRequestedModels(0);
        this->m_numPeds = 0;
      }
      else if ( m_groupType == 1 )
      {
        InteriorGroup_c::SetupShopPeds(this);
      }
      else if ( !this->m_groupType )
      {
        InteriorGroup_c::SetupHousePeds(this);
      }
      this->m_pedsSetup = 1;
    }
  }
  else if ( !this->m_pedsSetup )
  {
    goto LABEL_31;
  }
  if ( this->m_pEntryExit && g_interiorMan.m_activePeds )
  {
    for ( i = 30; i != 46; ++i )
    {
      v6 = (CPed *)*((_DWORD *)&this->m_prev + i);
      if ( v6 )
      {
        if ( CPed::IsPointerValid(v6) )
          InteriorGroup_c::RemovePed(this, *((CPed **)&this->m_prev + i));
        *((_DWORD *)&this->m_prev + i) = 0;
      }
    }
    if ( this->m_groupType == 2 )
      InteriorGroup_c::UpdateOfficePeds(this);
  }
LABEL_31:
  m_animsReferenced = this->m_animsReferenced;
  if ( !this->m_animsReferenced )
  {
    v8 = this->m_groupType;
    if ( v8 <= 2 )
      m_animsReferenced = CAnimManager::GetAnimationBlockIndex((const unsigned __int8 *)off_667D8C[v8]);
    if ( CAnimManager::ms_aAnimBlocks[m_animsReferenced].m_loaded )
    {
      CAnimManager::AddAnimBlockRef(m_animsReferenced);
      this->m_animsReferenced = 1;
    }
    else
    {
      sub_192918(m_animsReferenced + 25575, 8);
    }
  }
}
// FC: using guessed type int elf_hash_bucket[16411];
// 667D8C: using guessed type char *off_667D8C[6];

//----- (00448CF4) --------------------------------------------------------
void __fastcall InteriorGroup_c::CalcIsVisible(InteriorGroup_c *this)
{
  int m_numInteriors; // r0
  int v3; // r6

  m_numInteriors = this->m_numInteriors;
  this->m_lastIsVisible = this->m_isVisible;
  this->m_isVisible = 0;
  if ( m_numInteriors >= 1 )
  {
    v3 = 0;
    while ( !Interior_c::IsVisible(this->m_pInteriors[v3]) )
    {
      if ( ++v3 >= this->m_numInteriors )
        return;
    }
    this->m_isVisible = 1;
  }
}

//----- (00448D40) --------------------------------------------------------
void __fastcall InteriorGroup_c::SetupPaths(InteriorGroup_c *this)
{
  float32x2_t v1; // d1
  unsigned __int64 v2; // d8
  int16x4_t v3; // d16
  InteriorGroup_c *v4; // r11
  Int32 v5; // r5
  int v6; // r6
  Int32 v7; // r1
  Interior_c *v8; // r10
  int m_numGotoPts; // r0
  float *p_z; // r8
  int i; // r11
  Int32 v12; // r5
  char *v13; // r0
  float32x2_t *v14; // r9
  char *v15; // r0
  CNodeAddress v16; // r6
  int v17; // r0
  int v18; // r0
  float v19; // r1
  float v20; // r2
  float v21; // r3
  int8 m_groupType; // r0
  CNodeAddress NearestExteriorNodeToInteriorNode; // r2
  unsigned __int64 *v24; // r0
  char *v25; // r1
  int v26; // r4
  Int32 v27; // r8
  char *v28; // r3
  __int16 *v29; // r6
  float v30; // s0
  float v31; // s2
  int v32; // r3
  CNodeAddress v33; // r6
  int v34; // r0
  int v35; // r0
  CNodeAddress v36; // r2
  unsigned __int64 *v37; // r0
  char *v38; // r1
  Int32 v39; // r10
  char *v40; // r3
  __int16 *v41; // r6
  float v42; // s0
  float v43; // s2
  int v44; // r3
  CNodeAddress v45; // r5
  int v46; // r0
  int v47; // r0
  CNodeAddress v48; // r2
  unsigned __int64 *v49; // r0
  char *v50; // r1
  Int32 v51; // r8
  char *v52; // lr
  __int16 *v53; // r1
  int v54; // r3
  float v55; // s0
  int v56; // r3
  CNodeAddress v57; // r10
  int v58; // r0
  int v59; // r0
  CNodeAddress v60; // r2
  unsigned __int64 *v61; // r0
  char *v62; // r1
  unsigned __int32 v63; // r0
  char *v64; // lr
  __int16 *v65; // r1
  int v66; // r3
  float v67; // s0
  int v68; // r3
  int j; // r10
  float32x2_t v70; // d0
  int v71; // r3
  char *v72; // r1
  int v73; // r0
  float32x2_t v74; // d16
  unsigned __int64 v75; // d2
  bool v76; // nf
  int v77; // r5
  int v78; // r3
  float32x2_t *v79; // r5
  int v80; // r4
  Int32 Node2; // [sp+94h] [bp-19Ch]
  Int32 v82; // [sp+98h] [bp-198h]
  Int32 v83; // [sp+9Ch] [bp-194h]
  Int32 v84; // [sp+9Ch] [bp-194h]
  InteriorGroup_c *v85; // [sp+A0h] [bp-190h]
  Int32 Node1; // [sp+A4h] [bp-18Ch]
  CPathFind *m_pInteriors; // [sp+A8h] [bp-188h]
  int v88; // [sp+ACh] [bp-184h]
  Int32 v89; // [sp+B0h] [bp-180h]
  Int32 v90; // [sp+B0h] [bp-180h]
  char v91[304]; // [sp+C4h] [bp-16Ch] BYREF

  v4 = this;
  if ( InteriorGroup_c::ArePathsLoaded(this) )
  {
    CPathFind::StartNewInterior(&ThePaths, v4->m_id);
    v5 = 0;
    v6 = 0;
    v7 = 0;
    v85 = v4;
    do
    {
      v8 = v4->m_pInteriors[v7];
      if ( v8 )
      {
        *(_DWORD *)&v91[4 * v7 + 256] = v5;
        m_numGotoPts = v8->m_numGotoPts;
        if ( m_numGotoPts >= 3 )
        {
          v83 = v7;
          CPathFind::AddNodeToNewInterior(
            &ThePaths,
            v8->m_gotoPts[0].pos.x,
            v8->m_gotoPts[0].pos.y,
            v8->m_gotoPts[0].pos.z,
            0,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1);
          CPathFind::AddNodeToNewInterior(
            &ThePaths,
            v8->m_gotoPts[1].pos.x,
            v8->m_gotoPts[1].pos.y,
            v8->m_gotoPts[1].pos.z,
            0,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1);
          CPathFind::AddInteriorLink(&ThePaths, v6 + 1, v5);
          m_numGotoPts = v8->m_numGotoPts;
          if ( m_numGotoPts < 3 )
          {
            v6 += 2;
          }
          else
          {
            p_z = &v8->m_gotoPts[2].pos.z;
            for ( i = 2; i < m_numGotoPts; ++i )
            {
              CPathFind::AddNodeToNewInterior(&ThePaths, *(p_z - 2), *(p_z - 1), *p_z, 0, -1, -1, -1, -1, -1, -1);
              CPathFind::AddInteriorLink(&ThePaths, v6 + i, v5 + i - 2);
              if ( (i & 1) != 0 )
                CPathFind::AddInteriorLink(&ThePaths, v6 + i, v5 + i - 1);
              m_numGotoPts = v8->m_numGotoPts;
              p_z += 4;
            }
            v6 += i;
            v4 = v85;
          }
          v7 = v83;
        }
        v5 += (char)m_numGotoPts;
      }
      ++v7;
    }
    while ( v7 != 8 );
    m_pInteriors = (CPathFind *)v4->m_pInteriors;
    v89 = v5;
    v12 = 0;
    v88 = 0;
    Node1 = 0;
    Node2 = 0;
    v84 = 0;
    v82 = 0;
    do
    {
      v14 = *(float32x2_t **)&m_pInteriors->ColourGroups[4 * v12];
      if ( v14 )
      {
        v15 = (char *)v14[2].n64_u32[1];
        if ( v15[5] < 0 )
        {
          v26 = 0;
          v27 = v89;
        }
        else
        {
          v16 = CPathFind::AddNodeToNewInterior(
                  &ThePaths,
                  v14[162].n64_f32[1],
                  v14[163].n64_f32[0],
                  v14[163].n64_f32[1],
                  0,
                  -1,
                  -1,
                  -1,
                  -1,
                  -1,
                  -1);
          v17 = v14[162].n64_i8[2];
          if ( v17 >= 0 )
            CPathFind::AddInteriorLink(&ThePaths, v89, *(_DWORD *)&v91[4 * v12 + 256] + v17);
          v18 = v14[162].n64_i8[3];
          if ( v18 >= 0 )
            CPathFind::AddInteriorLink(&ThePaths, v89, *(_DWORD *)&v91[4 * v12 + 256] + v18);
          LODWORD(v14[126].n64_u64[0]) = v16;
          v3.n64_u64[0] = *(unsigned __int64 *)((char *)v14 + 1300);
          v19 = v14[164].n64_f32[1];
          v20 = v14[165].n64_f32[0];
          v21 = v14[165].n64_f32[1];
          v14[129].n64_u32[0] = v14[163].n64_u32[1];
          v14[128].n64_u64[0] = v3.n64_u64[0];
          m_groupType = v4->m_groupType;
          CPathFind::AddNodeToNewInterior(&ThePaths, v19, v20, v21, m_groupType != 0, -1, -1, -1, -1, -1, -1);
          CPathFind::AddInteriorLink(&ThePaths, v89 + 1, v89);
          NearestExteriorNodeToInteriorNode = CPathFind::FindNearestExteriorNodeToInteriorNode(&ThePaths, v89 + 1);
          v24 = (unsigned __int64 *)((char *)v14[164].n64_u64 + 4);
          if ( NearestExteriorNodeToInteriorNode.Region == 0xFFFF )
          {
            *(_DWORD *)&v91[4 * v88 + 192] = v89 + 1;
            v3.n64_u64[0] = *v24;
            v25 = &v91[12 * v88];
            *((_DWORD *)v25 + 2) = v14[165].n64_u32[1];
            v91[v88 + 288] = 0;
            *(int16x4_t *)v25 = v3;
            ++v88;
          }
          else
          {
            *(CNodeAddress *)&v14[125].n64_u8[4] = NearestExteriorNodeToInteriorNode;
            v28 = (char *)&ThePaths + 4 * NearestExteriorNodeToInteriorNode.Region;
            v29 = (__int16 *)(*((_DWORD *)v28 + 513) + 28 * HIWORD(*(unsigned int *)&NearestExteriorNodeToInteriorNode));
            v30 = (float)v29[6] * 0.125;
            v31 = (float)v29[5] * 0.125;
            v14[126].n64_f32[1] = (float)v29[4] * 0.125;
            v14[127].n64_f32[0] = v31;
            v14[127].n64_f32[1] = v30;
            if ( !v4->m_groupType )
            {
              v32 = *((_DWORD *)v28 + 513) + 28 * HIWORD(*(unsigned int *)&NearestExteriorNodeToInteriorNode);
              v3.n64_u32[0] = *(_DWORD *)(v32 + 10);
              v3.n64_u64[0] = vsub_f32(
                                vmul_f32(
                                  vcvt_f32_s32((int32x2_t)vmovl_s16(v3).n128_u64[0]),
                                  (float32x2_t)0x3E0000003E000000LL),
                                v14[165]).n64_u64[0];
              v1.n64_u64[0] = vmul_f32(v3, v3).n64_u64[0];
              if ( (float)((float)((float)((float)((float)((float)*(__int16 *)(v32 + 8) * 0.125) - *(float *)v24)
                                         * (float)((float)((float)*(__int16 *)(v32 + 8) * 0.125) - *(float *)v24))
                                 + v1.n64_f32[0])
                         + v1.n64_f32[1]) <= 9.0 )
                CPathFind::AddInteriorLinkToExternalNode(&ThePaths, v89 + 1, NearestExteriorNodeToInteriorNode);
            }
          }
          v26 = 1;
          v15 = (char *)v14[2].n64_u32[1];
          v27 = v89 + 2;
          Node1 = v89;
        }
        v90 = v12;
        if ( v15[6] < 0 )
        {
          v39 = v27;
        }
        else
        {
          v33 = CPathFind::AddNodeToNewInterior(
                  &ThePaths,
                  v14[166].n64_f32[1],
                  v14[167].n64_f32[0],
                  v14[167].n64_f32[1],
                  0,
                  -1,
                  -1,
                  -1,
                  -1,
                  -1,
                  -1);
          v34 = v14[166].n64_i8[2];
          if ( v34 != -1 )
            CPathFind::AddInteriorLink(&ThePaths, v27, *(_DWORD *)&v91[4 * v12 + 256] + v34);
          v35 = v14[166].n64_i8[3];
          if ( v35 != -1 )
            CPathFind::AddInteriorLink(&ThePaths, v27, *(_DWORD *)&v91[4 * v12 + 256] + v35);
          if ( !v26 )
          {
            LODWORD(v14[126].n64_u64[0]) = v33;
            v3.n64_u64[0] = *(unsigned __int64 *)((char *)v14 + 1332);
            v14[129].n64_u32[0] = v14[167].n64_u32[1];
            v14[128].n64_u64[0] = v3.n64_u64[0];
          }
          CPathFind::AddNodeToNewInterior(
            &ThePaths,
            v14[168].n64_f32[1],
            v14[169].n64_f32[0],
            v14[169].n64_f32[1],
            0,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1);
          CPathFind::AddInteriorLink(&ThePaths, v27 + 1, v27);
          v36 = CPathFind::FindNearestExteriorNodeToInteriorNode(&ThePaths, v27 + 1);
          v37 = (unsigned __int64 *)((char *)v14[168].n64_u64 + 4);
          if ( v36.Region == 0xFFFF )
          {
            *(_DWORD *)&v91[4 * v88 + 192] = v27 + 1;
            v3.n64_u64[0] = *v37;
            v38 = &v91[12 * v88];
            *((_DWORD *)v38 + 2) = v14[169].n64_u32[1];
            v91[v88 + 288] = 0;
            *(int16x4_t *)v38 = v3;
            ++v88;
          }
          else
          {
            *(CNodeAddress *)&v14[125].n64_u8[4] = v36;
            v40 = (char *)&ThePaths + 4 * v36.Region;
            v41 = (__int16 *)(*((_DWORD *)v40 + 513) + 28 * HIWORD(*(unsigned int *)&v36));
            v42 = (float)v41[6] * 0.125;
            v43 = (float)v41[5] * 0.125;
            v14[126].n64_f32[1] = (float)v41[4] * 0.125;
            v14[127].n64_f32[0] = v43;
            v14[127].n64_f32[1] = v42;
            if ( !v85->m_groupType )
            {
              v44 = *((_DWORD *)v40 + 513) + 28 * HIWORD(*(unsigned int *)&v36);
              v3.n64_u32[0] = *(_DWORD *)(v44 + 10);
              v3.n64_u64[0] = vsub_f32(
                                vmul_f32(
                                  vcvt_f32_s32((int32x2_t)vmovl_s16(v3).n128_u64[0]),
                                  (float32x2_t)0x3E0000003E000000LL),
                                v14[169]).n64_u64[0];
              v1.n64_u64[0] = vmul_f32(v3, v3).n64_u64[0];
              if ( (float)((float)((float)((float)((float)((float)*(__int16 *)(v44 + 8) * 0.125) - *(float *)v37)
                                         * (float)((float)((float)*(__int16 *)(v44 + 8) * 0.125) - *(float *)v37))
                                 + v1.n64_f32[0])
                         + v1.n64_f32[1]) <= 9.0 )
                CPathFind::AddInteriorLinkToExternalNode(&ThePaths, v27 + 1, v36);
            }
          }
          v15 = (char *)v14[2].n64_u32[1];
          v39 = v27 + 2;
          v26 = 1;
          Node2 = v27;
        }
        if ( v15[10] < 0 )
        {
          v51 = v39;
          v4 = v85;
        }
        else
        {
          v45 = CPathFind::AddNodeToNewInterior(
                  &ThePaths,
                  v14[170].n64_f32[1],
                  v14[171].n64_f32[0],
                  v14[171].n64_f32[1],
                  0,
                  -1,
                  -1,
                  -1,
                  -1,
                  -1,
                  -1);
          v46 = v14[170].n64_i8[2];
          if ( v46 != -1 )
            CPathFind::AddInteriorLink(&ThePaths, v39, *(_DWORD *)&v91[4 * v90 + 256] + v46);
          v47 = v14[170].n64_i8[3];
          if ( v47 != -1 )
            CPathFind::AddInteriorLink(&ThePaths, v39, *(_DWORD *)&v91[4 * v90 + 256] + v47);
          if ( !v26 )
          {
            LODWORD(v14[126].n64_u64[0]) = v45;
            v3.n64_u64[0] = *(unsigned __int64 *)((char *)v14 + 1364);
            v14[129].n64_u32[0] = v14[171].n64_u32[1];
            v14[128].n64_u64[0] = v3.n64_u64[0];
          }
          CPathFind::AddNodeToNewInterior(
            &ThePaths,
            v14[172].n64_f32[1],
            v14[173].n64_f32[0],
            v14[173].n64_f32[1],
            0,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1);
          CPathFind::AddInteriorLink(&ThePaths, v39 + 1, v39);
          v48 = CPathFind::FindNearestExteriorNodeToInteriorNode(&ThePaths, v39 + 1);
          v49 = (unsigned __int64 *)((char *)v14[172].n64_u64 + 4);
          if ( v48.Region == 0xFFFF )
          {
            v12 = v90;
            v4 = v85;
            *(_DWORD *)&v91[4 * v88 + 192] = v39 + 1;
            v3.n64_u64[0] = *v49;
            v50 = &v91[12 * v88];
            *((_DWORD *)v50 + 2) = v14[173].n64_u32[1];
            v91[v88 + 288] = 0;
            *(int16x4_t *)v50 = v3;
            ++v88;
          }
          else
          {
            *(CNodeAddress *)&v14[125].n64_u8[4] = v48;
            v4 = v85;
            v52 = (char *)&ThePaths + 4 * v48.Region;
            v53 = (__int16 *)(*((_DWORD *)v52 + 513) + 28 * HIWORD(*(unsigned int *)&v48));
            v54 = v53[5];
            v55 = (float)v53[6] * 0.125;
            v14[126].n64_f32[1] = (float)v53[4] * 0.125;
            v14[127].n64_f32[0] = (float)v54 * 0.125;
            v14[127].n64_f32[1] = v55;
            if ( v85->m_groupType )
            {
              v12 = v90;
            }
            else
            {
              v56 = *((_DWORD *)v52 + 513) + 28 * HIWORD(*(unsigned int *)&v48);
              v3.n64_u32[0] = *(_DWORD *)(v56 + 10);
              v12 = v90;
              v3.n64_u64[0] = vsub_f32(
                                vmul_f32(
                                  vcvt_f32_s32((int32x2_t)vmovl_s16(v3).n128_u64[0]),
                                  (float32x2_t)0x3E0000003E000000LL),
                                v14[173]).n64_u64[0];
              v1.n64_u64[0] = vmul_f32(v3, v3).n64_u64[0];
              if ( (float)((float)((float)((float)((float)((float)*(__int16 *)(v56 + 8) * 0.125) - *(float *)v49)
                                         * (float)((float)((float)*(__int16 *)(v56 + 8) * 0.125) - *(float *)v49))
                                 + v1.n64_f32[0])
                         + v1.n64_f32[1]) <= 9.0 )
                CPathFind::AddInteriorLinkToExternalNode(&ThePaths, v39 + 1, v48);
            }
          }
          v15 = (char *)v14[2].n64_u32[1];
          v51 = v39 + 2;
          v26 = 1;
          v84 = v39;
        }
        if ( v15[8] < 0 )
        {
          v89 = v51;
        }
        else
        {
          v57 = CPathFind::AddNodeToNewInterior(
                  &ThePaths,
                  v14[174].n64_f32[1],
                  v14[175].n64_f32[0],
                  v14[175].n64_f32[1],
                  0,
                  -1,
                  -1,
                  -1,
                  -1,
                  -1,
                  -1);
          v58 = v14[174].n64_i8[2];
          if ( v58 != -1 )
            CPathFind::AddInteriorLink(&ThePaths, v51, *(_DWORD *)&v91[4 * v12 + 256] + v58);
          v59 = v14[174].n64_i8[3];
          if ( v59 != -1 )
            CPathFind::AddInteriorLink(&ThePaths, v51, *(_DWORD *)&v91[4 * v12 + 256] + v59);
          if ( !v26 )
          {
            LODWORD(v14[126].n64_u64[0]) = v57;
            v3.n64_u64[0] = *(unsigned __int64 *)((char *)v14 + 1396);
            v14[129].n64_u32[0] = v14[175].n64_u32[1];
            v14[128].n64_u64[0] = v3.n64_u64[0];
          }
          CPathFind::AddNodeToNewInterior(
            &ThePaths,
            v14[176].n64_f32[1],
            v14[177].n64_f32[0],
            v14[177].n64_f32[1],
            0,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1);
          CPathFind::AddInteriorLink(&ThePaths, v51 + 1, v51);
          v60 = CPathFind::FindNearestExteriorNodeToInteriorNode(&ThePaths, v51 + 1);
          v61 = (unsigned __int64 *)((char *)v14[176].n64_u64 + 4);
          if ( v60.Region == 0xFFFF )
          {
            v12 = v90;
            *(_DWORD *)&v91[4 * v88 + 192] = v51 + 1;
            v62 = &v91[12 * v88];
            v3.n64_u64[0] = *v61;
            v63 = v14[177].n64_u32[1];
            v91[v88 + 288] = 0;
            v4 = v85;
            ++v88;
            *((_DWORD *)v62 + 2) = v63;
            *(int16x4_t *)v62 = v3;
          }
          else
          {
            *(CNodeAddress *)&v14[125].n64_u8[4] = v60;
            v64 = (char *)&ThePaths + 4 * v60.Region;
            v65 = (__int16 *)(*((_DWORD *)v64 + 513) + 28 * HIWORD(*(unsigned int *)&v60));
            v66 = v65[5];
            v67 = (float)v65[6] * 0.125;
            v14[126].n64_f32[1] = (float)v65[4] * 0.125;
            v14[127].n64_f32[0] = (float)v66 * 0.125;
            v14[127].n64_f32[1] = v67;
            v4 = v85;
            if ( v85->m_groupType )
            {
              v12 = v90;
            }
            else
            {
              v68 = *((_DWORD *)v64 + 513) + 28 * HIWORD(*(unsigned int *)&v60);
              v3.n64_u32[0] = *(_DWORD *)(v68 + 10);
              v12 = v90;
              v3.n64_u64[0] = vsub_f32(
                                vmul_f32(
                                  vcvt_f32_s32((int32x2_t)vmovl_s16(v3).n128_u64[0]),
                                  (float32x2_t)0x3E0000003E000000LL),
                                v14[177]).n64_u64[0];
              v1.n64_u64[0] = vmul_f32(v3, v3).n64_u64[0];
              if ( (float)((float)((float)((float)((float)((float)*(__int16 *)(v68 + 8) * 0.125) - *(float *)v61)
                                         * (float)((float)((float)*(__int16 *)(v68 + 8) * 0.125) - *(float *)v61))
                                 + v1.n64_f32[0])
                         + v1.n64_f32[1]) <= 9.0 )
                CPathFind::AddInteriorLinkToExternalNode(&ThePaths, v51 + 1, v60);
            }
          }
          v89 = v51 + 2;
          v82 = v51;
        }
        if ( !v14[129].n64_u8[4] )
        {
          v13 = (char *)v14[2].n64_u32[1];
          if ( v13[5] >= 0 )
          {
            if ( v13[6] >= 0 )
            {
              CPathFind::AddInteriorLink(&ThePaths, Node1, Node2);
              v13 = (char *)v14[2].n64_u32[1];
            }
            if ( v13[10] >= 0 )
            {
              CPathFind::AddInteriorLink(&ThePaths, Node1, v84);
              v13 = (char *)v14[2].n64_u32[1];
            }
            if ( v13[8] >= 0 )
            {
              CPathFind::AddInteriorLink(&ThePaths, Node1, v82);
              v13 = (char *)v14[2].n64_u32[1];
            }
          }
          if ( v13[10] >= 0 )
          {
            if ( v13[6] >= 0 )
            {
              CPathFind::AddInteriorLink(&ThePaths, v84, Node2);
              v13 = (char *)v14[2].n64_u32[1];
            }
            if ( v13[8] >= 0 )
              CPathFind::AddInteriorLink(&ThePaths, v84, v82);
          }
        }
      }
      ++v12;
    }
    while ( v12 != 8 );
    if ( v88 >= 1 )
    {
      LODWORD(v2) = 1315859240;
      for ( j = 0; j != v88; ++j )
      {
        if ( !v91[j + 288] )
        {
          v70.n64_u64[0] = v2;
          v71 = j;
          v72 = &v91[12 * j];
          v73 = -1;
LABEL_93:
          v77 = 3 * v71;
          v78 = v71 + 1;
          v79 = (float32x2_t *)&v91[4 * v77 + 4];
          while ( v78 < v88 )
          {
            v80 = (unsigned __int8)v91[v78 + 288];
            v79 = (float32x2_t *)((char *)v79 + 12);
            ++v78;
            if ( !v80 )
            {
              v71 = v78 - 1;
              v74.n64_u64[0] = vsub_f32(*(float32x2_t *)(v72 + 4), (float32x2_t)v79->n64_u64[0]).n64_u64[0];
              v75 = vmul_f32(v74, v74).n64_u64[0];
              v1.n64_f32[0] = (float)((float)((float)(*(float *)v72 - v79[-1].n64_f32[1])
                                            * (float)(*(float *)v72 - v79[-1].n64_f32[1]))
                                    + *(float *)&v75)
                            + *((float *)&v75 + 1);
              v76 = v1.n64_f32[0] < v70.n64_f32[0];
              v70.n64_u64[0] = vmin_f32(v1, v70).n64_u64[0];
              if ( v76 )
                v73 = v71;
              goto LABEL_93;
            }
          }
          if ( v70.n64_f32[0] >= 3.0 )
          {
            CPathFind::RemoveInteriorLinks(&ThePaths, *(_DWORD *)&v91[4 * j + 192]);
          }
          else
          {
            v91[j + 288] = 1;
            v91[v73 + 288] = 1;
            CPathFind::AddInteriorLink(&ThePaths, *(_DWORD *)&v91[4 * j + 192], *(_DWORD *)&v91[4 * v73 + 192]);
          }
        }
      }
    }
    CPathFind::CompleteNewInterior(&ThePaths, 0);
    v85->m_pathsSetup = 1;
  }
}
// 449406: variable 'v3' is possibly undefined
// 44987E: variable 'v2' is possibly undefined
// 4498BC: variable 'v1' is possibly undefined

//----- (004499F8) --------------------------------------------------------
void __fastcall InteriorGroup_c::SetupPeds(InteriorGroup_c *this)
{
  int m_groupType; // r0

  if ( this->m_pEntryExit && g_interiorMan.m_activePeds )
  {
    m_groupType = (unsigned __int8)this->m_groupType;
    if ( m_groupType == 2 )
    {
      CStreaming::StreamPedsForInterior(2);
      CStreaming::LoadAllRequestedModels(0);
      this->m_numPeds = 0;
    }
    else if ( m_groupType == 1 )
    {
      InteriorGroup_c::SetupShopPeds(this);
    }
    else if ( !this->m_groupType )
    {
      InteriorGroup_c::SetupHousePeds(this);
    }
    this->m_pedsSetup = 1;
  }
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (00449A50) --------------------------------------------------------
void __fastcall InteriorGroup_c::UpdatePeds(InteriorGroup_c *this)
{
  int i; // r5
  CPed *v3; // r0

  if ( this->m_pEntryExit && g_interiorMan.m_activePeds )
  {
    for ( i = 30; i != 46; ++i )
    {
      v3 = (CPed *)*((_DWORD *)&this->m_prev + i);
      if ( v3 )
      {
        if ( CPed::IsPointerValid(v3) )
          InteriorGroup_c::RemovePed(this, *((CPed **)&this->m_prev + i));
        *((_DWORD *)&this->m_prev + i) = 0;
      }
    }
    if ( this->m_groupType == 2 )
      InteriorGroup_c::UpdateOfficePeds(this);
  }
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (00449AB0) --------------------------------------------------------
void __fastcall InteriorGroup_c::ReferenceAnims(InteriorGroup_c *this)
{
  int32 m_animsReferenced; // r0
  unsigned int m_groupType; // r1

  m_animsReferenced = this->m_animsReferenced;
  if ( !m_animsReferenced )
  {
    m_groupType = this->m_groupType;
    if ( m_groupType <= 2 )
      m_animsReferenced = CAnimManager::GetAnimationBlockIndex((const unsigned __int8 *)off_667D8C[m_groupType]);
    if ( CAnimManager::ms_aAnimBlocks[m_animsReferenced].m_loaded )
    {
      CAnimManager::AddAnimBlockRef(m_animsReferenced);
      this->m_animsReferenced = 1;
    }
    else
    {
      sub_192918(m_animsReferenced + 25575, 8);
    }
  }
}
// 667D8C: using guessed type char *off_667D8C[6];

//----- (00449B08) --------------------------------------------------------
void __fastcall InteriorGroup_c::AddInterior(InteriorGroup_c *this, Interior_c *pInterior)
{
  Interior_c **m_pInteriors; // r2
  Interior_c *v3; // r3
  bool v4; // zf
  Interior_c *v5; // r3
  bool v6; // zf
  Interior_c *v7; // r3
  bool v8; // zf

  m_pInteriors = this->m_pInteriors;
  v3 = this->m_pInteriors[0];
  v4 = v3 == 0;
  if ( v3 )
  {
    m_pInteriors = &this->m_pInteriors[1];
    v4 = this->m_pInteriors[1] == 0;
  }
  if ( v4 )
    goto LABEL_5;
  m_pInteriors = &this->m_pInteriors[2];
  if ( !this->m_pInteriors[2] )
    goto LABEL_5;
  m_pInteriors = &this->m_pInteriors[3];
  v5 = this->m_pInteriors[3];
  v6 = v5 == 0;
  if ( v5 )
  {
    m_pInteriors = &this->m_pInteriors[4];
    v6 = this->m_pInteriors[4] == 0;
  }
  if ( v6 )
    goto LABEL_5;
  m_pInteriors = &this->m_pInteriors[5];
  v7 = this->m_pInteriors[5];
  v8 = v7 == 0;
  if ( v7 )
  {
    m_pInteriors = &this->m_pInteriors[6];
    v8 = this->m_pInteriors[6] == 0;
  }
  if ( v8 || (m_pInteriors = &this->m_pInteriors[7], !this->m_pInteriors[7]) )
  {
LABEL_5:
    *m_pInteriors = pInterior;
    ++this->m_numInteriors;
  }
}

//----- (00449B66) --------------------------------------------------------
bool8 __fastcall InteriorGroup_c::RemoveInterior(InteriorGroup_c *this, Interior_c *pInterior)
{
  Interior_c **m_pInteriors; // r3
  Interior_c *v3; // r12
  bool v4; // zf
  Interior_c *v5; // r1
  bool v6; // zf
  Interior_c *v8; // r2
  bool v9; // zf
  Interior_c *v10; // r2
  bool v11; // zf
  Interior_c *v12; // r1
  bool v13; // zf
  Interior_c *v14; // r1
  bool v15; // zf

  m_pInteriors = this->m_pInteriors;
  v3 = this->m_pInteriors[0];
  v4 = v3 == pInterior;
  if ( v3 != pInterior )
  {
    m_pInteriors = &this->m_pInteriors[1];
    v4 = this->m_pInteriors[1] == pInterior;
  }
  if ( v4 )
    goto LABEL_5;
  m_pInteriors = &this->m_pInteriors[2];
  if ( this->m_pInteriors[2] == pInterior )
    goto LABEL_5;
  m_pInteriors = &this->m_pInteriors[3];
  v8 = this->m_pInteriors[3];
  v9 = v8 == pInterior;
  if ( v8 != pInterior )
  {
    m_pInteriors = &this->m_pInteriors[4];
    v9 = this->m_pInteriors[4] == pInterior;
  }
  if ( v9 )
    goto LABEL_5;
  m_pInteriors = &this->m_pInteriors[5];
  v10 = this->m_pInteriors[5];
  v11 = v10 == pInterior;
  if ( v10 != pInterior )
  {
    m_pInteriors = &this->m_pInteriors[6];
    v11 = this->m_pInteriors[6] == pInterior;
  }
  if ( v11 || (m_pInteriors = &this->m_pInteriors[7], this->m_pInteriors[7] == pInterior) )
  {
LABEL_5:
    *m_pInteriors = 0;
    v3 = this->m_pInteriors[0];
    --this->m_numInteriors;
  }
  if ( v3 )
    return 0;
  v5 = this->m_pInteriors[1];
  v6 = v5 == 0;
  if ( !v5 )
    v6 = this->m_pInteriors[2] == 0;
  if ( !v6 )
    return 0;
  v12 = this->m_pInteriors[3];
  v13 = v12 == 0;
  if ( !v12 )
    v13 = this->m_pInteriors[4] == 0;
  if ( !v13 )
    return 0;
  v14 = this->m_pInteriors[5];
  v15 = v14 == 0;
  if ( !v14 )
    v15 = this->m_pInteriors[6] == 0;
  return v15 && this->m_pInteriors[7] == 0;
}

//----- (00449C00) --------------------------------------------------------
Interior_c *__fastcall InteriorGroup_c::GetRandomInterior(InteriorGroup_c *this)
{
  int m_numInteriors; // r5
  int v3; // s0
  Interior_c *result; // r0
  int v5; // r2

  m_numInteriors = this->m_numInteriors;
  v3 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * (float)m_numInteriors);
  result = this->m_pInteriors[0];
  if ( result )
  {
    if ( !v3 )
      return result;
    v5 = 1;
  }
  else
  {
    v5 = 0;
  }
  result = this->m_pInteriors[1];
  if ( result )
  {
    if ( v5 == v3 )
      return result;
    ++v5;
  }
  result = this->m_pInteriors[2];
  if ( result )
  {
    if ( v5 == v3 )
      return result;
    ++v5;
  }
  result = this->m_pInteriors[3];
  if ( result )
  {
    if ( v5 == v3 )
      return result;
    ++v5;
  }
  result = this->m_pInteriors[4];
  if ( result )
  {
    if ( v5 == v3 )
      return result;
    ++v5;
  }
  result = this->m_pInteriors[5];
  if ( result )
  {
    if ( v5 == v3 )
      return result;
    ++v5;
  }
  result = this->m_pInteriors[6];
  if ( result )
  {
    if ( v5 == v3 )
      return result;
    ++v5;
  }
  result = this->m_pInteriors[7];
  if ( v5 != v3 )
    result = 0;
  if ( !this->m_pInteriors[7] )
    return 0;
  return result;
}

//----- (00449C98) --------------------------------------------------------
int32 __fastcall InteriorGroup_c::GetNumInteriorInfos(InteriorGroup_c *this, int32 infoType)
{
  int v2; // r12
  int32 v3; // r2
  Interior_c *v4; // r3
  int m_numInteriorInfos; // lr
  InteriorInfo_t *v6; // r3
  int i; // r4
  int type; // t1

  v2 = 0;
  v3 = 0;
  do
  {
    v4 = this->m_pInteriors[v2];
    if ( v4 )
    {
      m_numInteriorInfos = v4->m_numInteriorInfos;
      if ( m_numInteriorInfos >= 1 )
      {
        if ( v4->m_interiorInfos[0].type == infoType )
          ++v3;
        if ( m_numInteriorInfos != 1 )
        {
          v6 = &v4->m_interiorInfos[1];
          for ( i = 1; i < m_numInteriorInfos; ++i )
          {
            type = v6->type;
            ++v6;
            if ( type == infoType )
              ++v3;
          }
        }
      }
    }
    ++v2;
  }
  while ( v2 != 8 );
  return v3;
}

//----- (00449CE8) --------------------------------------------------------
bool8 __fastcall InteriorGroup_c::FindInteriorInfo(
        InteriorGroup_c *this,
        int32 infoType,
        InteriorInfo_t **ppInteriorInfo,
        Interior_c **ppInterior)
{
  int v5; // lr
  int v6; // r8
  Interior_c *v7; // r12
  int m_numInteriorInfos; // r6
  int type; // r5
  bool v10; // zf
  InteriorInfo_t *v11; // r4
  int i; // r5
  int v13; // r2
  bool v14; // zf
  Interior_c **v15; // r4
  unsigned __int16 v16; // r0
  int v17; // r0
  Interior_c *v18; // r1
  bool8 result; // r0
  _DWORD v20[135]; // [sp+4h] [bp-21Ch]

  v5 = 0;
  v6 = 0;
  do
  {
    v7 = this->m_pInteriors[v5];
    if ( v7 )
    {
      m_numInteriorInfos = v7->m_numInteriorInfos;
      if ( m_numInteriorInfos >= 1 )
      {
        type = v7->m_interiorInfos[0].type;
        v10 = type == infoType;
        if ( type == infoType )
          v10 = v7->m_interiorInfos[0].beingUsed == 0;
        if ( v10 )
        {
          v20[v6 + 64] = v7->m_interiorInfos;
          v20[v6++] = v7;
          if ( m_numInteriorInfos < 2 )
            goto LABEL_17;
        }
        else if ( m_numInteriorInfos < 2 )
        {
          goto LABEL_17;
        }
        v11 = &v7->m_interiorInfos[1];
        for ( i = 1; i < m_numInteriorInfos; ++i )
        {
          v13 = v11->type;
          v14 = v13 == infoType;
          if ( v13 == infoType )
            v14 = v11->beingUsed == 0;
          if ( v14 )
          {
            v20[v6 + 64] = v11;
            v20[v6++] = v7;
          }
          ++v11;
        }
      }
    }
LABEL_17:
    ++v5;
  }
  while ( v5 != 8 );
  if ( v6 <= 0 )
  {
    v18 = 0;
    result = 0;
    *ppInteriorInfo = 0;
  }
  else
  {
    v15 = ppInterior;
    v16 = rand();
    ppInterior = v15;
    v17 = (int)(float)((float)((float)v16 * 0.000015259) * (float)v6);
    *ppInteriorInfo = (InteriorInfo_t *)v20[v17 + 64];
    v18 = (Interior_c *)v20[v17];
    result = 1;
  }
  *ppInterior = v18;
  return result;
}

//----- (00449DD4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall InteriorGroup_c::FindClosestInteriorInfo(
        InteriorGroup_c *this,
        int32 infoType,
        CVector pos,
        float range,
        InteriorInfo_t **ppInteriorInfo,
        Interior_c **ppInterior,
        float *distSq)
{
  float v8; // s16
  int v9; // r10
  float v10; // s18
  InteriorInfo_t *m_interiorInfos; // r11
  Interior_c *v12; // r9
  ListItem_c **v13; // r5
  Interior_c *v14; // r0
  char *v15; // r5
  Interior_c *v16; // t1
  Interior_c *v17; // r0
  int v18; // r1
  bool v19; // zf
  int v20; // r5
  int v21; // r3
  float v22; // s8
  float v23; // s10
  float v24; // s6
  float *p_type; // r3
  int i; // r5
  bool v27; // zf
  int v28; // r6
  int v29; // r4
  float v30; // s8
  float v31; // s10
  float v32; // s6
  RwV3d_0 posa; // [sp+Ch] [bp-3Ch] BYREF

  v8 = 1000000.0;
  v9 = 0;
  v10 = range * range;
  m_interiorInfos = 0;
  v12 = 0;
  posa = pos.RwV3d_0;
  do
  {
    v13 = &this->m_prev + v9;
    v16 = (Interior_c *)v13[4];
    v15 = (char *)(v13 + 4);
    v14 = v16;
    if ( !v16 )
      goto LABEL_32;
    if ( !Interior_c::IsPtInside(v14, &posa, 0.0, 0.0, 0.0) )
      goto LABEL_32;
    v17 = *(Interior_c **)v15;
    v18 = *(char *)(*(_DWORD *)v15 + 1037);
    if ( v18 < 1 )
      goto LABEL_32;
    v19 = infoType == -1;
    if ( infoType != -1 )
      v19 = v17->m_interiorInfos[0].type == infoType;
    if ( !v19 || v17->m_interiorInfos[0].beingUsed )
    {
      if ( v18 < 2 )
        goto LABEL_32;
LABEL_19:
      p_type = (float *)&v17->m_interiorInfos[1].type;
      for ( i = 1; i < v18; ++i )
      {
        v27 = infoType == -1;
        if ( infoType != -1 )
          v27 = *(char *)p_type == infoType;
        if ( v27 && !*((_BYTE *)p_type + 1) )
        {
          v28 = 0;
          v29 = 0;
          v30 = (float)(posa.y - p_type[2]) * (float)(posa.y - p_type[2]);
          v31 = (float)(posa.z - p_type[3]) * (float)(posa.z - p_type[3]);
          v32 = (float)((float)((float)(posa.x - p_type[1]) * (float)(posa.x - p_type[1])) + v30) + v31;
          if ( v32 < v8 )
            v28 = 1;
          if ( v32 < v10 )
            v29 = 1;
          if ( (v28 & v29) != 0 )
          {
            v8 = (float)((float)((float)(posa.x - p_type[1]) * (float)(posa.x - p_type[1])) + v30) + v31;
            m_interiorInfos = (InteriorInfo_t *)p_type;
            v12 = v17;
          }
        }
        p_type += 8;
      }
      goto LABEL_32;
    }
    v20 = 0;
    v21 = 0;
    v22 = (float)(posa.x - v17->m_interiorInfos[0].pos.x) * (float)(posa.x - v17->m_interiorInfos[0].pos.x);
    v23 = (float)(posa.z - v17->m_interiorInfos[0].pos.z) * (float)(posa.z - v17->m_interiorInfos[0].pos.z);
    v24 = (float)(v22
                + (float)((float)(posa.y - v17->m_interiorInfos[0].pos.y)
                        * (float)(posa.y - v17->m_interiorInfos[0].pos.y)))
        + v23;
    if ( v24 < v8 )
      v21 = 1;
    if ( v24 < v10 )
      v20 = 1;
    if ( (v21 & v20) != 0 )
    {
      v8 = (float)(v22
                 + (float)((float)(posa.y - v17->m_interiorInfos[0].pos.y)
                         * (float)(posa.y - v17->m_interiorInfos[0].pos.y)))
         + v23;
      m_interiorInfos = v17->m_interiorInfos;
      v12 = v17;
    }
    if ( v18 >= 2 )
      goto LABEL_19;
LABEL_32:
    ++v9;
  }
  while ( v9 != 8 );
  if ( !m_interiorInfos )
    return 0;
  *ppInteriorInfo = m_interiorInfos;
  *ppInterior = v12;
  *distSq = v8;
  return 1;
}
// 449DD4: fragmented variable at 0:r2.8,8:^50.4 may be wrong
// 449DD4: variables would overlap: 0:r2.8,8:^50.4 and ^50.4

//----- (00449F70) --------------------------------------------------------
CPed *__fastcall InteriorGroup_c::GetPed(InteriorGroup_c *this, int32 id)
{
  return this->m_pPeds[id];
}

//----- (00449F78) --------------------------------------------------------
void __fastcall InteriorGroup_c::MarkPedForRemoval(InteriorGroup_c *this, CPed *pPed)
{
  CPed **m_pPedsToRemove; // r2
  CPed *v3; // r3
  bool v4; // zf
  CPed *v5; // r3
  bool v6; // zf
  CPed *v7; // r3
  bool v8; // zf
  CPed *v9; // r3
  bool v10; // zf
  CPed *v11; // r3
  bool v12; // zf
  CPed *v13; // r3
  bool v14; // zf
  CPed *v15; // r3
  bool v16; // zf
  CPed **v17; // r0
  CPed *v18; // t1

  m_pPedsToRemove = this->m_pPedsToRemove;
  v3 = this->m_pPedsToRemove[0];
  v4 = v3 == 0;
  if ( v3 )
  {
    m_pPedsToRemove = &this->m_pPedsToRemove[1];
    v4 = this->m_pPedsToRemove[1] == 0;
  }
  if ( v4 )
    goto LABEL_5;
  m_pPedsToRemove = &this->m_pPedsToRemove[2];
  if ( !this->m_pPedsToRemove[2] )
    goto LABEL_5;
  m_pPedsToRemove = &this->m_pPedsToRemove[3];
  v5 = this->m_pPedsToRemove[3];
  v6 = v5 == 0;
  if ( v5 )
  {
    m_pPedsToRemove = &this->m_pPedsToRemove[4];
    v6 = this->m_pPedsToRemove[4] == 0;
  }
  if ( v6 )
    goto LABEL_5;
  m_pPedsToRemove = &this->m_pPedsToRemove[5];
  v7 = this->m_pPedsToRemove[5];
  v8 = v7 == 0;
  if ( v7 )
  {
    m_pPedsToRemove = &this->m_pPedsToRemove[6];
    v8 = this->m_pPedsToRemove[6] == 0;
  }
  if ( v8 )
    goto LABEL_5;
  m_pPedsToRemove = &this->m_pPedsToRemove[7];
  v9 = this->m_pPedsToRemove[7];
  v10 = v9 == 0;
  if ( v9 )
  {
    m_pPedsToRemove = &this->m_pPedsToRemove[8];
    v10 = this->m_pPedsToRemove[8] == 0;
  }
  if ( v10 )
    goto LABEL_5;
  m_pPedsToRemove = &this->m_pPedsToRemove[9];
  v11 = this->m_pPedsToRemove[9];
  v12 = v11 == 0;
  if ( v11 )
  {
    m_pPedsToRemove = &this->m_pPedsToRemove[10];
    v12 = this->m_pPedsToRemove[10] == 0;
  }
  if ( v12 )
    goto LABEL_5;
  m_pPedsToRemove = &this->m_pPedsToRemove[11];
  v13 = this->m_pPedsToRemove[11];
  v14 = v13 == 0;
  if ( v13 )
  {
    m_pPedsToRemove = &this->m_pPedsToRemove[12];
    v14 = this->m_pPedsToRemove[12] == 0;
  }
  if ( v14 )
    goto LABEL_5;
  m_pPedsToRemove = &this->m_pPedsToRemove[13];
  v15 = this->m_pPedsToRemove[13];
  v16 = v15 == 0;
  if ( v15 )
  {
    m_pPedsToRemove = &this->m_pPedsToRemove[14];
    v16 = this->m_pPedsToRemove[14] == 0;
  }
  if ( v16 )
  {
LABEL_5:
    *m_pPedsToRemove = pPed;
  }
  else
  {
    v18 = this->m_pPedsToRemove[15];
    v17 = &this->m_pPedsToRemove[15];
    if ( !v18 )
      *v17 = pPed;
  }
}

//----- (0044A020) --------------------------------------------------------
CEntity *__fastcall InteriorGroup_c::GetEntity(InteriorGroup_c *this)
{
  return this->m_pEntity;
}

//----- (0044A024) --------------------------------------------------------
CEntryExit *__fastcall InteriorGroup_c::GetEntryExitPtr(InteriorGroup_c *this)
{
  return this->m_pEntryExit;
}

//----- (0044A028) --------------------------------------------------------
void __fastcall InteriorGroup_c::Setup(InteriorGroup_c *this)
{
  unsigned __int8 v2; // r1
  int32 AnimationBlockIndex; // r0
  int v4; // r0

  if ( InteriorGroup_c::ContainsInteriorType(this, 2) )
  {
    v2 = 0;
  }
  else if ( InteriorGroup_c::ContainsInteriorType(this, 0) || InteriorGroup_c::ContainsInteriorType(this, 6) )
  {
    v2 = 1;
  }
  else
  {
    v4 = InteriorGroup_c::ContainsInteriorType(this, 1);
    v2 = -1;
    if ( v4 )
      v2 = 2;
  }
  this->m_groupType = v2;
  if ( !this->m_animsReferenced )
  {
    AnimationBlockIndex = v2;
    if ( v2 <= 2u )
      AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex((const unsigned __int8 *)off_667D8C[(char)v2]);
    if ( CAnimManager::ms_aAnimBlocks[AnimationBlockIndex].m_loaded )
    {
      CAnimManager::AddAnimBlockRef(AnimationBlockIndex);
      this->m_animsReferenced = 1;
    }
    else
    {
      sub_192918(AnimationBlockIndex + 25575, 8);
    }
  }
}
// 667D8C: using guessed type char *off_667D8C[6];

//----- (0044A0B8) --------------------------------------------------------
bool8 __fastcall InteriorGroup_c::ContainsInteriorType(InteriorGroup_c *this, int32 interiorType)
{
  Interior_c *v2; // r2
  Interior_c *v3; // r2
  Interior_c *v4; // r2
  Interior_c *v5; // r2
  Interior_c *v6; // r2
  Interior_c *v7; // r2
  Interior_c *v8; // r2
  Interior_c *v9; // r0
  bool8 result; // r0

  v2 = this->m_pInteriors[0];
  result = 1;
  if ( !v2 || v2->m_box->m_type != interiorType )
  {
    v3 = this->m_pInteriors[1];
    if ( !v3 || v3->m_box->m_type != interiorType )
    {
      v4 = this->m_pInteriors[2];
      if ( !v4 || v4->m_box->m_type != interiorType )
      {
        v5 = this->m_pInteriors[3];
        if ( !v5 || v5->m_box->m_type != interiorType )
        {
          v6 = this->m_pInteriors[4];
          if ( !v6 || v6->m_box->m_type != interiorType )
          {
            v7 = this->m_pInteriors[5];
            if ( !v7 || v7->m_box->m_type != interiorType )
            {
              v8 = this->m_pInteriors[6];
              if ( !v8 || v8->m_box->m_type != interiorType )
              {
                v9 = this->m_pInteriors[7];
                if ( !v9 || v9->m_box->m_type != interiorType )
                  return 0;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (0044A120) --------------------------------------------------------
bool8 __fastcall InteriorGroup_c::ArePathsLoaded(InteriorGroup_c *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d8
  float32x2_t v4; // d9
  float32x2_t v6; // d11
  float32x2_t v7; // d10
  CColModel *m_pColModel; // r0
  RwReal x; // r1
  int y_low; // r2
  RwReal z; // r3
  int x_low; // r6
  int z_low; // r0
  __int64 v14; // kr00_8
  int v15; // r5
  CEntity *m_pEntity; // r6
  const CMatrix *m_pMat; // r1
  _DWORD *v18; // r6
  __int64 v19; // d16
  CVector v21; // [sp+8h] [bp-A8h] BYREF
  _DWORD v22[16]; // [sp+18h] [bp-98h] BYREF
  unsigned __int64 v23; // [sp+58h] [bp-58h]
  int v24; // [sp+60h] [bp-50h]
  unsigned __int64 v25; // [sp+64h] [bp-4Ch]
  int v26; // [sp+6Ch] [bp-44h]
  int v27; // [sp+70h] [bp-40h]
  int v28; // [sp+74h] [bp-3Ch]

  v4.n64_u32[0] = 1232348144;
  v3.n64_u32[0] = -915135504;
  v6.n64_u64[0] = v4.n64_u64[0];
  v7.n64_u64[0] = v3.n64_u64[0];
  m_pColModel = CModelInfo::ms_modelInfoPtrs[this->m_pEntity->m_nModelIndex]->m_pColModel;
  x = m_pColModel->m_boxBound.m_vecMin.x;
  y_low = LODWORD(m_pColModel->m_boxBound.m_vecMin.y);
  z = m_pColModel->m_boxBound.m_vecMin.z;
  x_low = LODWORD(m_pColModel->m_boxBound.m_vecMax.x);
  v14 = *(_QWORD *)&m_pColModel->m_boxBound.m_vecMax.y;
  z_low = LODWORD(m_pColModel->m_boxBound.m_vecMax.z);
  v26 = x_low;
  v27 = y_low;
  v22[9] = x_low;
  v22[10] = y_low;
  *(RwReal *)&v22[15] = x;
  v23 = __PAIR64__(z_low, v14);
  *(RwReal *)&v22[3] = x;
  v22[4] = v14;
  *(RwReal *)&v22[11] = z;
  *(RwReal *)&v22[12] = x;
  v22[7] = v14;
  *(RwReal *)&v22[8] = z;
  *(RwReal *)&v22[5] = z;
  v22[6] = x_low;
  v28 = z_low;
  *(RwReal *)v22 = x;
  v22[1] = y_low;
  *(RwReal *)&v22[2] = z;
  v25 = __PAIR64__(z_low, v14);
  v15 = 0;
  v24 = x_low;
  v22[13] = y_low;
  v22[14] = z_low;
  do
  {
    m_pEntity = this->m_pEntity;
    m_pMat = m_pEntity->m_pMat;
    if ( !m_pMat )
    {
      CPlaceable::AllocateMatrix(this->m_pEntity);
      CSimpleTransform::UpdateMatrix(&m_pEntity->m_transform, m_pEntity->m_pMat);
      m_pMat = m_pEntity->m_pMat;
    }
    v18 = &v22[v15];
    operator*(&v21, m_pMat, (const CVector *)&v22[v15]);
    v19 = *(_QWORD *)&v21.x;
    v15 += 3;
    v18[2] = LODWORD(v21.z);
    *(_QWORD *)v18 = v19;
    v1.n64_u32[0] = *v18;
    v2.n64_u32[0] = v18[1];
    v3.n64_u64[0] = vmax_f32(v1, v3).n64_u64[0];
    v7.n64_u64[0] = vmax_f32(v2, v7).n64_u64[0];
    v6.n64_u64[0] = vmin_f32(v2, v6).n64_u64[0];
    v4.n64_u64[0] = vmin_f32(v1, v4).n64_u64[0];
  }
  while ( v15 != 24 );
  return CPathFind::AreNodesLoadedForArea(&ThePaths, v4.n64_f32[0], v3.n64_f32[0], v6.n64_f32[0], v7.n64_f32[0]);
}
// 44A14A: variable 'v4' is possibly undefined
// 44A150: variable 'v3' is possibly undefined
// 44A1D0: variable 'v1' is possibly undefined
// 44A1D4: variable 'v2' is possibly undefined

//----- (0044A218) --------------------------------------------------------
void __fastcall InteriorGroup_c::SetupHousePeds(InteriorGroup_c *this)
{
  CEntity *m_pEntity; // r5
  const CMatrix *m_pMat; // r1
  int v4; // r9
  int MembersOf; // r0
  int v6; // r0
  int v7; // r6
  _BOOL4 v8; // r0
  Int32 MIPedSlotForInterior; // r0
  int m_numPeds; // r5
  CPed *v11; // r0
  ListItem_c **v12; // r8
  CEntity **v13; // r8
  RwReal y; // r10
  CTaskInteriorBeInHouse *v15; // r5
  int32 gang; // [sp+0h] [bp-60h]
  int v17; // [sp+8h] [bp-58h]
  CVector v18; // [sp+10h] [bp-50h] BYREF
  CVector v; // [sp+20h] [bp-40h] BYREF

  CStreaming::StreamPedsForInterior(0);
  CStreaming::LoadAllRequestedModels(0);
  this->m_numPeds = 0;
  memset(&v, 0, sizeof(v));
  m_pEntity = this->m_pEntity;
  m_pMat = m_pEntity->m_pMat;
  if ( !m_pMat )
  {
    CPlaceable::AllocateMatrix(this->m_pEntity);
    CSimpleTransform::UpdateMatrix(&m_pEntity->m_transform, m_pEntity->m_pMat);
    m_pMat = m_pEntity->m_pMat;
  }
  operator*(&v18, m_pMat, &v);
  v = v18;
  v4 = 2;
  if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) > 50 )
    v4 = 1;
  if ( CPopCycle::m_pCurrZoneInfo )
  {
    MembersOf = CPopCycle::PickGangToCreateMembersOf();
    m_pEntity = (CEntity *)MembersOf;
    if ( MembersOf )
    {
      if ( CPopulation::ChooseGangOccupation(MembersOf - 7) >= 0
        && (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) <= 15 )
      {
        v4 = 4 - (rand() & 1);
        v6 = 0;
      }
      else
      {
        v6 = 1;
      }
    }
    else
    {
      m_pEntity = 0;
      v6 = 1;
    }
  }
  else
  {
    v6 = 1;
  }
  v17 = v6;
  gang = (int32)&m_pEntity[-1].m_pLod + 1;
  v7 = 0;
  do
  {
    if ( v17 )
    {
      if ( v4 == 1 )
        v8 = (rand() & 1) == 0;
      else
        v8 = v7;
      MIPedSlotForInterior = CStreaming::FindMIPedSlotForInterior(v8);
    }
    else
    {
      MIPedSlotForInterior = CPopulation::ChooseGangOccupation(gang);
    }
    m_numPeds = this->m_numPeds;
    v11 = CPopulation::AddPed(
            *(ePedType *)CModelInfo::ms_modelInfoPtrs[MIPedSlotForInterior][1].m_modelName,
            MIPedSlotForInterior,
            &v,
            0);
    v12 = &this->m_prev + m_numPeds;
    v12[14] = (ListItem_c *)v11;
    v13 = (CEntity **)(v12 + 14);
    if ( v11 )
    {
      ++this->m_numPeds;
      CScriptsForBrains::StartOrRequestNewStreamedScriptBrainWithThisName(
        &CTheScripts::ScriptsForBrains,
        (const Char *)"house",
        *v13,
        3);
      CPed::SetCharCreatedBy((CPed *)*v13, 2u);
      CPedIntelligence::SetPedDecisionMakerType((CPedIntelligence *)LODWORD((*v13)[18].m_transform.m_translate.y), 7);
      y = (*v13)[18].m_transform.m_translate.y;
      v15 = (CTaskInteriorBeInHouse *)CTask::operator new(0x18u);
      CTaskInteriorBeInHouse::CTaskInteriorBeInHouse(v15, this);
      CTaskManager::SetTask((CTaskManager *)(LODWORD(y) + 4), v15, 4, 0);
    }
    if ( !g_interiorMan.m_pedsAlive[v7] )
      InteriorGroup_c::RemovePed(this, (CPed *)*v13);
    ++v7;
  }
  while ( v4 != v7 );
}
// 44A2F6: conditional instruction was optimized away because r0.4<2u

//----- (0044A404) --------------------------------------------------------
void __fastcall InteriorGroup_c::SetupShopPeds(InteriorGroup_c *this)
{
  int m_numInteriors; // r4
  int v3; // r0
  int v4; // r9
  Int32 v5; // r0
  Int32 MIPedSlotForInterior; // r6
  ePedType v7; // r5
  Interior_c *RandomInterior; // r4
  int m_numPeds; // r4
  CPed *v10; // r0
  ListItem_c **v11; // r4
  CPed **v12; // r4
  CPedIntelligence *m_pPedIntelligence; // r5
  CTaskInteriorBeInShop *v14; // r4
  int v15; // [sp+8h] [bp-50h]
  RwV3d_0 v16; // [sp+Ch] [bp-4Ch] BYREF
  int32 y; // [sp+18h] [bp-40h] BYREF
  int32 x[15]; // [sp+1Ch] [bp-3Ch] BYREF

  CStreaming::StreamPedsForInterior(1);
  CStreaming::LoadAllRequestedModels(0);
  m_numInteriors = this->m_numInteriors;
  this->m_numPeds = 0;
  v3 = ((int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 3.0) + 2) * m_numInteriors;
  if ( v3 >= 0 )
  {
    v15 = ~v3;
    v4 = 0;
    do
    {
      if ( v4 )
        v5 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 7.0) + 1;
      else
        v5 = 0;
      MIPedSlotForInterior = CStreaming::FindMIPedSlotForInterior(v5);
      v7 = *(_DWORD *)CModelInfo::ms_modelInfoPtrs[MIPedSlotForInterior][1].m_modelName;
      memset(&v16, 0, sizeof(v16));
      RandomInterior = InteriorGroup_c::GetRandomInterior(this);
      Interior_c::GetRandomTile(RandomInterior, 3, x, &y);
      Interior_c::GetTileCentre(RandomInterior, (float)x[0], (float)y, &v16);
      v16.z = v16.z + 1.0;
      m_numPeds = this->m_numPeds;
      v10 = CPopulation::AddPed(v7, MIPedSlotForInterior, (const CVector *)&v16, 0);
      v11 = &this->m_prev + m_numPeds;
      v11[14] = (ListItem_c *)v10;
      v12 = (CPed **)(v11 + 14);
      if ( v10 )
      {
        ++this->m_numPeds;
        CPed::SetCharCreatedBy(*v12, 2u);
        CPedIntelligence::SetPedDecisionMakerType((*v12)->m_pPedIntelligence, 7);
        m_pPedIntelligence = (*v12)->m_pPedIntelligence;
        if ( v4 )
        {
          v14 = (CTaskInteriorBeInShop *)CTask::operator new(0x34u);
          CTaskInteriorBeInShop::CTaskInteriorBeInShop(v14, this);
        }
        else
        {
          v14 = (CTaskInteriorBeInShop *)CTask::operator new(0x20u);
          CTaskInteriorShopKeeper::CTaskInteriorShopKeeper((CTaskInteriorShopKeeper *)v14, this, 0);
        }
        CTaskManager::SetTask(&m_pPedIntelligence->m_taskManager, v14, 4, 0);
      }
      --v4;
    }
    while ( v15 != v4 );
  }
}
// 44A404: using guessed type int32 x[15];

//----- (0044A58C) --------------------------------------------------------
void __fastcall InteriorGroup_c::SetupOfficePeds(InteriorGroup_c *this)
{
  CStreaming::StreamPedsForInterior(2);
  CStreaming::LoadAllRequestedModels(0);
  this->m_numPeds = 0;
}

//----- (0044A5A6) --------------------------------------------------------
void __fastcall InteriorGroup_c::RemovePed(InteriorGroup_c *this, CPed *pPed)
{
  CPed *v3; // r0
  CPed **m_pPeds; // r5
  CPed *v5; // r0
  CPed *v6; // r0
  CPed *v7; // r0
  CPed *v8; // r0
  CPed *v9; // r0
  CPed *v10; // r0
  CPed *v11; // r0
  CPed *v12; // r0
  CPed *v13; // r0
  CPed *v14; // r0
  CPed *v15; // r0
  CPed *v16; // r0
  CPed *v17; // r0
  CPed *v18; // r0
  CPed *v19; // r0

  m_pPeds = this->m_pPeds;
  v3 = this->m_pPeds[0];
  if ( v3 && v3 == pPed )
    goto LABEL_33;
  m_pPeds = &this->m_pPeds[1];
  v5 = this->m_pPeds[1];
  if ( v5 )
  {
    if ( v5 == pPed )
      goto LABEL_33;
  }
  m_pPeds = &this->m_pPeds[2];
  v6 = this->m_pPeds[2];
  if ( v6 )
  {
    if ( v6 == pPed )
      goto LABEL_33;
  }
  m_pPeds = &this->m_pPeds[3];
  v7 = this->m_pPeds[3];
  if ( v7 )
  {
    if ( v7 == pPed )
      goto LABEL_33;
  }
  m_pPeds = &this->m_pPeds[4];
  v8 = this->m_pPeds[4];
  if ( v8 )
  {
    if ( v8 == pPed )
      goto LABEL_33;
  }
  m_pPeds = &this->m_pPeds[5];
  v9 = this->m_pPeds[5];
  if ( v9 )
  {
    if ( v9 == pPed )
      goto LABEL_33;
  }
  m_pPeds = &this->m_pPeds[6];
  v10 = this->m_pPeds[6];
  if ( v10 )
  {
    if ( v10 == pPed )
      goto LABEL_33;
  }
  m_pPeds = &this->m_pPeds[7];
  v11 = this->m_pPeds[7];
  if ( v11 )
  {
    if ( v11 == pPed )
      goto LABEL_33;
  }
  m_pPeds = &this->m_pPeds[8];
  v12 = this->m_pPeds[8];
  if ( v12 )
  {
    if ( v12 == pPed )
      goto LABEL_33;
  }
  m_pPeds = &this->m_pPeds[9];
  v13 = this->m_pPeds[9];
  if ( v13 )
  {
    if ( v13 == pPed )
      goto LABEL_33;
  }
  m_pPeds = &this->m_pPeds[10];
  v14 = this->m_pPeds[10];
  if ( v14 )
  {
    if ( v14 == pPed )
      goto LABEL_33;
  }
  m_pPeds = &this->m_pPeds[11];
  v15 = this->m_pPeds[11];
  if ( v15 )
  {
    if ( v15 == pPed )
      goto LABEL_33;
  }
  m_pPeds = &this->m_pPeds[12];
  v16 = this->m_pPeds[12];
  if ( v16 )
  {
    if ( v16 == pPed )
      goto LABEL_33;
  }
  if ( (m_pPeds = &this->m_pPeds[13], (v17 = this->m_pPeds[13]) != 0) && v17 == pPed
    || (m_pPeds = &this->m_pPeds[14], (v18 = this->m_pPeds[14]) != 0) && v18 == pPed
    || (m_pPeds = &this->m_pPeds[15], (v19 = this->m_pPeds[15]) != 0) && v19 == pPed )
  {
LABEL_33:
    CPopulation::RemovePed(pPed);
    *m_pPeds = 0;
    --this->m_numPeds;
  }
}

//----- (0044A688) --------------------------------------------------------
void __fastcall InteriorGroup_c::UpdateOfficePeds(InteriorGroup_c *this)
{
  int m_isVisible; // r1
  int m_lastIsVisible; // r0
  CEntity *m_pEntity; // r5
  const CMatrix *m_pMat; // r1
  int v6; // r5
  int i; // r0
  Interior_c *v8; // r2
  int m_numInteriorInfos; // r1
  InteriorInfo_t *v10; // r2
  int j; // r3
  int type; // t1
  int v13; // r5
  CPed **m_pPeds; // r5
  int k; // r6
  CPed *v16; // r0
  unsigned __int16 v17; // r0
  Int32 MIPedSlotForInterior; // r0
  int m_numPeds; // r6
  CPed *v20; // r0
  ListItem_c **v21; // r6
  CPed **v22; // r6
  CPedIntelligence *m_pPedIntelligence; // r4
  CTaskInteriorBeInOffice *v24; // r6
  CVector v25; // [sp+0h] [bp-48h] BYREF
  CVector v; // [sp+10h] [bp-38h] BYREF

  m_isVisible = this->m_isVisible;
  m_lastIsVisible = this->m_lastIsVisible;
  if ( m_isVisible )
  {
    if ( m_lastIsVisible )
      return;
    memset(&v, 0, sizeof(v));
    m_pEntity = this->m_pEntity;
    m_pMat = m_pEntity->m_pMat;
    if ( !m_pMat )
    {
      CPlaceable::AllocateMatrix(this->m_pEntity);
      CSimpleTransform::UpdateMatrix(&m_pEntity->m_transform, m_pEntity->m_pMat);
      m_pMat = m_pEntity->m_pMat;
    }
    operator*(&v25, m_pMat, &v);
    v6 = 0;
    v = v25;
    for ( i = 0; i != 8; ++i )
    {
      v8 = this->m_pInteriors[i];
      if ( v8 )
      {
        m_numInteriorInfos = v8->m_numInteriorInfos;
        if ( m_numInteriorInfos >= 1 )
        {
          if ( v8->m_interiorInfos[0].type == 6 )
            ++v6;
          if ( m_numInteriorInfos != 1 )
          {
            v10 = &v8->m_interiorInfos[1];
            for ( j = 1; j < m_numInteriorInfos; ++j )
            {
              type = (unsigned __int8)v10->type;
              ++v10;
              if ( type == 6 )
                ++v6;
            }
          }
        }
      }
    }
    if ( CClock::GetIsTimeInRange(9u, 0x12u) )
    {
      v13 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * (float)(v6 - v6 / 2)) + v6 / 2;
      if ( v13 < 16 )
      {
LABEL_18:
        if ( v13 < 1 )
          return;
        goto LABEL_32;
      }
    }
    else
    {
      if ( !CClock::GetIsTimeInRange(0x12u, 0x16u) && !CClock::GetIsTimeInRange(6u, 9u) )
        return;
      v13 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * (float)(v6 / 2));
      if ( v13 <= 15 )
        goto LABEL_18;
    }
    v13 = 16;
    do
    {
LABEL_32:
      v17 = rand();
      MIPedSlotForInterior = CStreaming::FindMIPedSlotForInterior((int)(float)((float)((float)v17 * 0.000015259) * 8.0));
      m_numPeds = this->m_numPeds;
      v20 = CPopulation::AddPed(
              *(ePedType *)CModelInfo::ms_modelInfoPtrs[MIPedSlotForInterior][1].m_modelName,
              MIPedSlotForInterior,
              &v,
              0);
      v21 = &this->m_prev + m_numPeds;
      v21[14] = (ListItem_c *)v20;
      v22 = (CPed **)(v21 + 14);
      if ( v20 )
      {
        ++this->m_numPeds;
        CPed::SetCharCreatedBy(*v22, 2u);
        CPedIntelligence::SetPedDecisionMakerType((*v22)->m_pPedIntelligence, 7);
        m_pPedIntelligence = (*v22)->m_pPedIntelligence;
        v24 = (CTaskInteriorBeInOffice *)CTask::operator new(0x18u);
        CTaskInteriorBeInOffice::CTaskInteriorBeInOffice(v24, this);
        CTaskManager::SetTask(&m_pPedIntelligence->m_taskManager, v24, 4, 0);
      }
      --v13;
    }
    while ( v13 );
    return;
  }
  if ( m_lastIsVisible )
  {
    m_pPeds = this->m_pPeds;
    for ( k = 0; k != 16; ++k )
    {
      v16 = m_pPeds[k];
      if ( v16 )
      {
        if ( CPed::IsPointerValid(v16) )
          CPopulation::RemovePed(m_pPeds[k]);
        m_pPeds[k] = 0;
      }
    }
    this->m_numPeds = 0;
  }
}

//----- (0044A8A0) --------------------------------------------------------
void __fastcall Interior_c::FurnishKitchen(Interior_c *this)
{
  CInteriorAttr *m_box; // r0
  unsigned int m_width; // r1
  unsigned int m_depth; // r0
  int32 v5; // r11
  int32 v6; // r8
  int32 v7; // r5
  int32 v8; // r5
  Furniture_c *Furniture; // r0
  unsigned int v10; // [sp+1Ch] [bp-2Ch]
  int32 d; // [sp+24h] [bp-24h] BYREF
  int32 w[8]; // [sp+28h] [bp-20h] BYREF

  Interior_c::SetTilesStatus(this, this->m_box->m_door - 1, 0, 2, 1, 7, 0);
  m_box = this->m_box;
  m_width = m_box->m_width;
  m_depth = m_box->m_depth;
  v5 = m_width - 2;
  v6 = m_depth - 2;
  v10 = m_depth;
  if ( m_width >= 3 )
  {
    v7 = 0;
    do
    {
      Interior_c::SetTilesStatus(this, ++v7, v6, 1, 1, 3, 0);
      Interior_c::SetTilesStatus(this, v7, 0, 1, 1, 3, 0);
    }
    while ( v5 != v7 );
  }
  if ( v10 >= 2 )
  {
    v8 = 0;
    do
    {
      Interior_c::SetTilesStatus(this, 1, v8, 1, 1, 3, 0);
      Interior_c::SetTilesStatus(this, v5, v8++, 1, 1, 3, 0);
    }
    while ( v10 - 1 != v8 );
  }
  Interior_c::AddGotoPt(this, 1, 1, 0.0, 0.0);
  Interior_c::AddGotoPt(this, 1, v6, 0.0, 0.0);
  Interior_c::AddGotoPt(this, v5, 1, 0.0, 0.0);
  Interior_c::AddGotoPt(this, v5, v6, 0.0, 0.0);
  this->m_style = FurnitureManager_c::GetRandomId(&g_furnitureMan, 4, 0, this->m_box->m_status);
  Interior_c::Kitchen_FurnishEdges(this);
  Furniture = FurnitureManager_c::GetFurniture(&g_furnitureMan, 8, 1, -1, this->m_box->m_status);
  Interior_c::PlaceFurniture(
    this,
    Furniture,
    (int)(float)((float)((float)this->m_box->m_width * 0.5) - (float)((float)Furniture->m_width * 0.5)),
    (int)(float)((float)((float)this->m_box->m_depth * 0.5) - (float)((float)Furniture->m_depth * 0.5)),
    0.0,
    0,
    0,
    w,
    &d,
    0);
}
// 44A8A0: using guessed type int32 var_20[8];

//----- (0044AA54) --------------------------------------------------------
void __fastcall Interior_c::Kitchen_FurnishEdges(Interior_c *this)
{
  CInteriorAttr *m_box; // r0
  unsigned int m_width; // r9
  int32 m_depth; // r4
  int v5; // r6
  Furniture_c *Furniture; // r5
  int32 v7; // r9
  CEntity *v8; // r0
  CInteriorAttr *v9; // r1
  int v10; // r5
  int m_lWindowEnd; // r2
  int v12; // r3
  int m_rWindowEnd; // r4
  int m_rDoorEnd; // r1
  bool v15; // cc
  Interior_c *v16; // r4
  Furniture_c *v17; // r0
  Furniture_c *v18; // r0
  Interior_c *v19; // r9
  Furniture_c *v20; // r8
  int v21; // r5
  Furniture_c *v22; // r4
  char v23; // r0
  bool v24; // zf
  int v25; // r6
  float v26; // s18
  int v27; // r6
  int v28; // r4
  int v29; // s0
  int v30; // r0
  unsigned int m_status; // r4
  int v32; // r0
  float v33; // s0
  float *v34; // r11
  float *v35; // r4
  float *v36; // r8
  float *v37; // r5
  int v38; // r10
  char v39; // r0
  Furniture_c *v40; // r2
  Furniture_c *v41; // r0
  Furniture_c *v42; // r0
  __int64 dir; // [sp+8h] [bp-288h]
  CEntity *v44; // [sp+2Ch] [bp-264h]
  unsigned int v45; // [sp+30h] [bp-260h]
  int32 v46; // [sp+34h] [bp-25Ch]
  CEntity *v47; // [sp+38h] [bp-258h]
  int v48; // [sp+38h] [bp-258h]
  int v49; // [sp+3Ch] [bp-254h]
  int v50; // [sp+40h] [bp-250h]
  int v51; // [sp+44h] [bp-24Ch]
  int32 v52; // [sp+44h] [bp-24Ch]
  float v53[32]; // [sp+48h] [bp-248h] BYREF
  float v54[32]; // [sp+C8h] [bp-1C8h] BYREF
  float v55[32]; // [sp+148h] [bp-148h] BYREF
  float v56[32]; // [sp+1C8h] [bp-C8h] BYREF
  int32 retPos; // [sp+248h] [bp-48h] BYREF
  int32 retWallId; // [sp+24Ch] [bp-44h] BYREF
  int32 d; // [sp+250h] [bp-40h] BYREF
  int32 w[15]; // [sp+254h] [bp-3Ch] BYREF

  m_box = this->m_box;
  m_width = m_box->m_width;
  m_depth = m_box->m_depth;
  v5 = 0;
  Furniture = FurnitureManager_c::GetFurniture(&g_furnitureMan, 4, 7, this->m_style, m_box->m_status);
  v46 = m_depth--;
  v47 = Interior_c::PlaceFurniture(this, Furniture, 0, m_depth, 0.0, 1, 1, w, &d, 0);
  v45 = m_width;
  v7 = m_width - 1;
  v51 = m_depth;
  v8 = Interior_c::PlaceFurniture(this, Furniture, v7, m_depth, 0.0, 1, 0, w, &d, 0);
  v9 = this->m_box;
  v10 = 0;
  m_lWindowEnd = v9->m_lWindowEnd;
  if ( v9->m_lDoorEnd > m_lWindowEnd )
    m_lWindowEnd = v9->m_lDoorEnd;
  v12 = 0;
  if ( m_lWindowEnd > 0 )
    v12 = (unsigned __int8)m_lWindowEnd;
  m_rWindowEnd = v9->m_rWindowEnd;
  m_rDoorEnd = v9->m_rDoorEnd;
  if ( m_rDoorEnd > m_rWindowEnd )
    m_rWindowEnd = m_rDoorEnd;
  if ( m_rWindowEnd > 0 )
    v10 = v12;
  if ( m_lWindowEnd <= 0 )
    v10 = 0;
  if ( m_rWindowEnd > 0 )
    v5 = (unsigned __int8)m_rWindowEnd;
  else
    v10 = v12;
  v15 = m_lWindowEnd <= 0;
  v44 = v8;
  if ( m_lWindowEnd <= 0 )
    v15 = (char)m_rWindowEnd <= 0;
  if ( v15 )
  {
    v10 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * (float)v51);
    v5 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * (float)v51);
  }
  if ( v10 >= 1 )
    Interior_c::SetTilesStatus(this, 0, 0, 1, v10, 2, 0);
  if ( v5 >= 1 )
    Interior_c::SetTilesStatus(this, v7, 0, 1, v5, 2, 0);
  v16 = this;
  v17 = FurnitureManager_c::GetFurniture(&g_furnitureMan, 4, 0, this->m_style, this->m_box->m_status);
  Interior_c::PlaceFurniture(this, v17, 0, v10, 0.0, 1, 1, w, &d, 0);
  v18 = FurnitureManager_c::GetFurniture(&g_furnitureMan, 4, 2, v16->m_style, v16->m_box->m_status);
  v49 = v7;
  Interior_c::PlaceFurniture(this, v18, v7, v5, 0.0, 1, 3, w, &d, 0);
  LODWORD(dir) = 0;
  HIDWORD(dir) = this->m_box->m_tWindowStart;
  if ( Interior_c::PlaceFurnitureOnWall(v16, 4, 3, v16->m_style, 0.0, 1, dir, 0, &retWallId, &retPos, 0, 0, 0, 0) )
    Interior_c::AddInteriorInfo(this, 5, (float)++retPos, (float)this->m_box->m_depth + -1.5, 2, 0);
  Interior_c::PlaceFurnitureOnWall(this, 4, 5, this->m_style, 0.0, 1, -1LL, 0, &retWallId, &retPos, 0, 0, 0, 0);
  Interior_c::PlaceFurnitureOnWall(this, 4, 4, this->m_style, 0.0, 1, -1LL, 0, &retWallId, &retPos, 0, 0, 0, 0);
  Interior_c::PlaceFurnitureOnWall(this, 4, 6, this->m_style, 0.0, 1, -1LL, 0, &retWallId, &retPos, 0, 0, 0, 0);
  v19 = this;
  v20 = FurnitureManager_c::GetFurniture(&g_furnitureMan, 4, 1, this->m_style, this->m_box->m_status);
  memset(v53, 0, sizeof(v53));
  v50 = 0;
  while ( ++v10 < v51 )
  {
    if ( Interior_c::PlaceFurniture(this, v20, 0, v10, 0.0, 1, 1, w, &d, 0) )
    {
      v56[v50] = 0.5;
      v55[v50] = (float)v10 + 0.5;
      v54[v50++] = 90.0;
    }
  }
  if ( v45 >= 3 )
  {
    v21 = 0;
    do
    {
      if ( Interior_c::PlaceFurniture(this, v20, ++v21, v51, 0.0, 1, 0, w, &d, 0) )
      {
        v56[v50] = (float)v21 + 0.5;
        v55[v50] = (float)v51 + 0.5;
        v54[v50++] = 0.0;
      }
    }
    while ( v45 - 2 != v21 );
  }
  while ( v5 < v46 - 2 )
  {
    if ( Interior_c::PlaceFurniture(this, v20, v49, ++v5, 0.0, 1, 3, w, &d, 0) )
    {
      v56[v50] = (float)v49 + 0.5;
      v55[v50] = (float)v5 + 0.5;
      v54[v50++] = 270.0;
    }
  }
  v22 = FurnitureManager_c::GetFurniture(&g_furnitureMan, 4, 10, -1, this->m_box->m_status);
  v23 = rand();
  v24 = v47 == 0;
  if ( v47 )
    v24 = (v23 & 1) == 0;
  if ( !v24 )
  {
    Interior_c::PlaceObject(this, 1u, v22, 0.5, (float)this->m_box->m_depth + -0.5, 1.05, 45.0);
    v25 = v50;
    if ( v50 < 1 )
      return;
    goto LABEL_45;
  }
  v25 = v50;
  if ( v44 )
    Interior_c::PlaceObject(
      this,
      1u,
      v22,
      (float)this->m_box->m_width + -0.5,
      (float)this->m_box->m_depth + -0.5,
      1.05,
      315.0);
  if ( v50 >= 1 )
  {
LABEL_45:
    v26 = (float)v25;
    v48 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * (float)v25);
    v53[v48] = 1.0;
    v27 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * (float)v25);
    if ( v53[v27] == 1.0 )
    {
      v28 = 0;
      do
      {
        v29 = (unsigned __int16)rand();
        v30 = v28 + 1;
        v27 = (int)(float)((float)((float)v29 * 0.000015259) * v26);
        if ( v28 > 28 )
          break;
        ++v28;
      }
      while ( v53[v27] == 1.0 );
      if ( v30 == 30 )
        v27 = -1;
    }
    m_status = this->m_box->m_status;
    if ( m_status < 0x4B )
    {
      v33 = (float)(unsigned __int16)rand() * 0.000015259;
      if ( m_status < 0x32 )
        v32 = (int)(float)(v33 * 50.0) + 50;
      else
        v32 = (int)(float)(v33 * 30.0) + 20;
    }
    else
    {
      v32 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 20.0);
    }
    v52 = v32;
    v34 = v53;
    v35 = v56;
    v36 = v55;
    v37 = v54;
    v38 = 0;
    do
    {
      if ( *v34 == 0.0 && v52 > (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) )
      {
        v39 = rand();
        v40 = FurnitureManager_c::GetFurniture(&g_furnitureMan, 8, 4 - (v39 & 1), -1, v19->m_box->m_status);
        if ( v40 )
          Interior_c::PlaceObject(v19, 0, v40, *v35, *v36, 1.05, *v37);
      }
      ++v38;
      ++v37;
      ++v36;
      ++v35;
      ++v34;
    }
    while ( v50 != v38 );
    if ( v48 != -1 )
    {
      v41 = FurnitureManager_c::GetFurniture(&g_furnitureMan, 4, 8, -1, v19->m_box->m_status);
      Interior_c::PlaceObject(v19, 1u, v41, v56[v48], v55[v48], 1.05, v54[v48]);
    }
    if ( v27 != -1 )
    {
      v42 = FurnitureManager_c::GetFurniture(&g_furnitureMan, 4, 9, -1, v19->m_box->m_status);
      Interior_c::PlaceObject(v19, 1u, v42, v56[v27], v55[v27], 1.05, v54[v27]);
    }
  }
}
// 44AA54: using guessed type float var_248[32];
// 44AA54: using guessed type float var_C8[32];
// 44AA54: using guessed type float var_148[32];
// 44AA54: using guessed type float var_1C8[32];

//----- (0044B240) --------------------------------------------------------
void __fastcall Interior_c::FurnishLounge(Interior_c *this)
{
  CInteriorAttr *m_box; // r0
  CEntity *v3; // r0
  int32 v4; // r2
  int32 v5; // r3
  int32 v6; // r1
  int32 v7; // r0
  CInteriorAttr *v8; // r0
  unsigned int v9; // r1
  unsigned int v10; // r0
  int32 v11; // r10
  int32 v12; // r11
  int32 v13; // r4
  int32 v14; // r4
  int8 RandomId; // r0
  CEntity *v16; // r3
  CEntity *v17; // r3
  CEntity *v18; // r3
  CEntity *v19; // r3
  float v20; // s16
  float v21; // s18
  int v22; // r4
  Furniture_c *Furniture; // r0
  unsigned int m_status; // r4
  int v25; // r5
  float v26; // s0
  Furniture_c *v27; // r2
  Furniture_c *v28; // r2
  Furniture_c *v29; // r2
  Furniture_c *v30; // r0
  CInteriorAttr *v31; // r0
  int32 v32; // r5
  int32 TileStatus; // r6
  int32 v34; // r4
  int32 v35; // r5
  int32 v36; // r6
  int32 v37; // r4
  int32 z; // [sp+0h] [bp-98h]
  unsigned int v39; // [sp+30h] [bp-68h]
  int m_depth; // [sp+34h] [bp-64h]
  int m_width; // [sp+38h] [bp-60h]
  int32 v42; // [sp+3Ch] [bp-5Ch]
  int32 v43; // [sp+40h] [bp-58h] BYREF
  int32 v44; // [sp+44h] [bp-54h] BYREF
  int32 v45; // [sp+48h] [bp-50h] BYREF
  int32 x; // [sp+4Ch] [bp-4Ch] BYREF
  int32 v47; // [sp+50h] [bp-48h] BYREF
  int32 retPos; // [sp+54h] [bp-44h] BYREF
  int32 v49; // [sp+58h] [bp-40h] BYREF
  int32 retWallId; // [sp+5Ch] [bp-3Ch] BYREF
  int32 d; // [sp+60h] [bp-38h] BYREF
  int32 v52[13]; // [sp+64h] [bp-34h] BYREF

  m_box = this->m_box;
  m_width = m_box->m_width;
  m_depth = m_box->m_depth;
  Interior_c::SetTilesStatus(this, m_box->m_door - 1, 0, 2, 1, 7, 0);
  Interior_c::SetTilesStatus(this, this->m_box->m_door - 2, 0, 1, 1, 2, 0);
  Interior_c::SetTilesStatus(this, this->m_box->m_door + 1, 0, 1, 1, 2, 0);
  v3 = Interior_c::PlaceFurnitureInCorner(this, 2, 2, -1, 0.0, 1, -1, 0, &retWallId, &v49, &retPos, v52, &d);
  v6 = retWallId;
  if ( v3 )
  {
    Interior_c::Lounge_AddTV(this, retWallId, v4, v5, z);
    v6 = retWallId;
    v7 = retWallId;
  }
  else
  {
    v7 = -1;
  }
  v42 = v7;
  Interior_c::SetCornerTiles(this, v6, 2, 2, 1);
  v8 = this->m_box;
  v9 = v8->m_width;
  v10 = v8->m_depth;
  v11 = v9 - 2;
  v12 = v10 - 2;
  v39 = v10;
  if ( v9 >= 3 )
  {
    v13 = 0;
    do
    {
      Interior_c::SetTilesStatus(this, ++v13, v12, 1, 1, 3, 0);
      Interior_c::SetTilesStatus(this, v13, 1, 1, 1, 3, 0);
    }
    while ( v11 != v13 );
  }
  if ( v39 >= 3 )
  {
    v14 = 0;
    do
    {
      Interior_c::SetTilesStatus(this, 1, ++v14, 1, 1, 3, 0);
      Interior_c::SetTilesStatus(this, v11, v14, 1, 1, 3, 0);
    }
    while ( v12 != v14 );
  }
  Interior_c::AddGotoPt(this, 1, 1, 0.0, 0.0);
  Interior_c::AddGotoPt(this, 1, v12, 0.0, 0.0);
  Interior_c::AddGotoPt(this, v11, 1, 0.0, 0.0);
  Interior_c::AddGotoPt(this, v11, v12, 0.0, 0.0);
  Interior_c::SetCornerTiles(this, 0, 2, 2, 0);
  Interior_c::SetCornerTiles(this, 2, 2, 2, 0);
  Interior_c::SetCornerTiles(this, 1, 2, 2, 0);
  Interior_c::SetCornerTiles(this, 3, 2, 2, 0);
  RandomId = FurnitureManager_c::GetRandomId(&g_furnitureMan, 2, 0, this->m_box->m_status);
  this->m_style = RandomId;
  v16 = Interior_c::PlaceFurnitureOnWall(this, 2, 0, RandomId, 0.0, 1, -1LL, 0, &retWallId, &v47, 0, 0, 0, 0);
  if ( v16 )
  {
    Interior_c::Lounge_AddSofaInfo(this, retWallId, v47, v16);
    if ( !Interior_c::PlaceFurnitureOnWall(this, 2, 4, -1, 0.0, 1, __SPAIR64__(v47, retWallId), 2, 0, 0, 0, 0, 0, 0) )
      Interior_c::PlaceFurnitureOnWall(this, 2, 4, -1, 0.0, 1, __SPAIR64__(v47, retWallId), 3, 0, 0, 0, 0, 0, 0);
  }
  v17 = Interior_c::PlaceFurnitureOnWall(this, 2, 1, this->m_style, 0.0, 1, -1LL, 0, &retWallId, &v47, 0, 0, 0, 0);
  if ( v17 )
    Interior_c::Lounge_AddChairInfo(this, retWallId, v47, v17);
  v18 = Interior_c::PlaceFurnitureOnWall(this, 2, 1, this->m_style, 0.0, 1, -1LL, 0, &retWallId, &v47, 0, 0, 0, 0);
  if ( v18 )
    Interior_c::Lounge_AddChairInfo(this, retWallId, v47, v18);
  if ( (unsigned int)(m_depth + m_width) >= 0xF )
  {
    v19 = Interior_c::PlaceFurnitureOnWall(this, 2, 1, this->m_style, 0.0, 1, -1LL, 0, &retWallId, &v47, 0, 0, 0, 0);
    if ( v19 )
      Interior_c::Lounge_AddChairInfo(this, retWallId, v47, v19);
  }
  if ( !v42 )
  {
    Interior_c::SetCornerTiles(this, 2, 2, 0, 0);
    goto LABEL_26;
  }
  Interior_c::SetCornerTiles(this, 0, 2, 0, 0);
  if ( v42 == 2 )
  {
LABEL_26:
    Interior_c::SetCornerTiles(this, 1, 2, 0, 0);
LABEL_27:
    Interior_c::SetCornerTiles(this, 3, 2, 0, 0);
    goto LABEL_28;
  }
  Interior_c::SetCornerTiles(this, 2, 2, 0, 0);
  if ( v42 == 1 )
    goto LABEL_27;
  Interior_c::SetCornerTiles(this, 1, 2, 0, 0);
  if ( v42 != 3 )
    goto LABEL_27;
LABEL_28:
  if ( Interior_c::PlaceFurnitureOnWall(this, 2, 6, -1, 0.0, 1, -1LL, 0, &retWallId, 0, &x, &v45, 0, 0) )
  {
    v20 = (float)v45;
    v21 = (float)x;
    v22 = retWallId & 3;
    if ( (retWallId | 2) == 2 )
    {
      v21 = v21 + 0.5;
    }
    else if ( (retWallId | 2) == 3 )
    {
      v20 = v20 + 0.5;
    }
    Furniture = FurnitureManager_c::GetFurniture(&g_furnitureMan, 2, 8, -1, this->m_box->m_status);
    Interior_c::PlaceObject(this, 1u, Furniture, v21 + 0.5, v20 + 0.5, 0.5, (float)v22 * 90.0);
  }
  Interior_c::PlaceFurnitureOnWall(this, 2, 5, -1, 0.0, 1, -1LL, 0, 0, 0, 0, 0, 0, 0);
  Interior_c::PlaceFurnitureOnWall(this, 8, 0, -1, 0.0, 1, -1LL, 0, 0, 0, 0, 0, 0, 0);
  Interior_c::PlaceFurnitureOnWall(this, 8, 0, -1, 0.0, 1, -1LL, 0, 0, 0, 0, 0, 0, 0);
  m_status = this->m_box->m_status;
  if ( m_status < 0x4B )
  {
    v26 = (float)(unsigned __int16)rand() * 0.000015259;
    if ( m_status < 0x32 )
      v25 = (int)(float)(v26 * 50.0) + 50;
    else
      v25 = (int)(float)(v26 * 30.0) + 20;
  }
  else
  {
    v25 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 20.0);
  }
  if ( v25 > (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 60.0)
    && Interior_c::FindEmptyTiles(this, 2, 2, &v44, &v43) )
  {
    v27 = FurnitureManager_c::GetFurniture(&g_furnitureMan, 8, 2, -1, this->m_box->m_status);
    Interior_c::PlaceObject(this, 0, v27, (float)v44 + 0.5, (float)v43 + 0.5, 0.05, 0.0);
    Interior_c::SetTilesStatus(this, v44, v43, 2, 2, 2, 0);
  }
  if ( v25 > (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0)
    && Interior_c::FindEmptyTiles(this, 1, 1, &v44, &v43) )
  {
    v28 = FurnitureManager_c::GetFurniture(&g_furnitureMan, 8, 5, -1, this->m_box->m_status);
    Interior_c::PlaceObject(this, 0, v28, (float)v44 + 0.5, (float)v43 + 0.5, 0.05, 0.0);
    Interior_c::SetTilesStatus(this, v44, v43, 1, 1, 2, 0);
  }
  if ( v25 > (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0)
    && Interior_c::FindEmptyTiles(this, 1, 1, &v44, &v43) )
  {
    v29 = FurnitureManager_c::GetFurniture(&g_furnitureMan, 8, 4, -1, this->m_box->m_status);
    Interior_c::PlaceObject(this, 0, v29, (float)v44 + 0.5, (float)v43 + 0.5, 0.05, 0.0);
    Interior_c::SetTilesStatus(this, v44, v43, 1, 1, 2, 0);
  }
  v30 = FurnitureManager_c::GetFurniture(&g_furnitureMan, 8, 1, -1, this->m_box->m_status);
  Interior_c::PlaceFurniture(
    this,
    v30,
    (int)(float)((float)((float)this->m_box->m_width * 0.5) - (float)((float)v30->m_width * 0.5)),
    (int)(float)((float)((float)this->m_box->m_depth * 0.5) - (float)((float)v30->m_depth * 0.5)),
    0.0,
    0,
    0,
    v52,
    &d,
    0);
  v31 = this->m_box;
  if ( v31->m_width >= 2u )
  {
    v32 = 0;
    do
    {
      TileStatus = Interior_c::GetTileStatus(this, v32, 0);
      v34 = Interior_c::GetTileStatus(this, v32, this->m_box->m_depth - 1);
      if ( (TileStatus | 2) == 2 )
        Interior_c::AddInteriorInfo(this, 2, (float)v32, 0.0, 2, 0);
      if ( (v34 | 2) == 2 )
        Interior_c::AddInteriorInfo(this, 2, (float)v32, (float)(this->m_box->m_depth - 1), 0, 0);
      v31 = this->m_box;
      ++v32;
    }
    while ( v32 < v31->m_width - 1 );
  }
  if ( v31->m_depth >= 4u )
  {
    v35 = 1;
    do
    {
      v36 = Interior_c::GetTileStatus(this, 0, v35);
      v37 = Interior_c::GetTileStatus(this, this->m_box->m_width - 1, v35);
      if ( (v36 | 2) == 2 )
        Interior_c::AddInteriorInfo(this, 2, 0.0, (float)v35, 1, 0);
      if ( (v37 | 2) == 2 )
        Interior_c::AddInteriorInfo(this, 2, (float)(this->m_box->m_width - 1), (float)v35, 3, 0);
      ++v35;
    }
    while ( v35 < this->m_box->m_depth - 2 );
  }
}
// 44B2E4: variable 'v4' is possibly undefined
// 44B2E4: variable 'v5' is possibly undefined
// 44B2E4: variable 'z' is possibly undefined

//----- (0044BB4C) --------------------------------------------------------
void __fastcall Interior_c::Lounge_AddTV(Interior_c *this, int32 wallId, int32 x, int32 y, int32 d)
{
  float v5; // s16
  float v6; // s18
  float v7; // s20
  float v8; // s22
  int v9; // r6
  float m_depth; // s16
  float m_width; // s16
  CInteriorAttr *m_box; // r0
  float v14; // s16
  float v15; // s18
  Furniture_c *Furniture; // r0
  float v17; // r3
  float v18; // s22
  Furniture_c *v19; // r0

  v9 = wallId & 3;
  switch ( wallId )
  {
    case 0:
      m_depth = (float)this->m_box->m_depth;
      Interior_c::AddInteriorInfo(this, 0, 1.0, m_depth + -2.0, -1, 0);
      v8 = 0.5;
      v6 = 1.5;
      v7 = m_depth + -0.5;
      v5 = m_depth + -0.5;
      break;
    case 1:
      Interior_c::AddInteriorInfo(this, 0, 1.0, 1.0, -1, 0);
      v7 = 0.5;
      v5 = 1.5;
      v6 = 0.5;
      v8 = 0.5;
      break;
    case 2:
      m_width = (float)this->m_box->m_width;
      Interior_c::AddInteriorInfo(this, 0, m_width + -2.0, 1.0, -1, 0);
      v7 = 0.5;
      v8 = m_width + -0.5;
      v5 = 0.5;
      v6 = v8 + -1.0;
      break;
    case 3:
      m_box = this->m_box;
      v14 = (float)m_box->m_width;
      v15 = (float)m_box->m_depth;
      Interior_c::AddInteriorInfo(this, 0, v14 + -2.0, v15 + -2.0, -1, 0);
      v7 = v15 + -0.5;
      v6 = v14 + -0.5;
      v5 = v7 + -1.0;
      v8 = v6;
      break;
    default:
      break;
  }
  Furniture = FurnitureManager_c::GetFurniture(&g_furnitureMan, 2, 3, -1, this->m_box->m_status);
  v17 = v8;
  v18 = (float)v9 * 90.0;
  Interior_c::PlaceObject(this, 1u, Furniture, v17, v7, 0.5, v18 + 45.0);
  if ( (rand() & 1) != 0 )
    v19 = FurnitureManager_c::GetFurniture(&g_furnitureMan, 2, 7, -1, this->m_box->m_status);
  else
    v19 = FurnitureManager_c::GetFurniture(&g_furnitureMan, 2, 9, -1, this->m_box->m_status);
  Interior_c::PlaceObject(this, 1u, v19, v6, v5, 0.5, v18);
}
// 44BC9E: variable 'v8' is possibly undefined
// 44BCC6: variable 'v7' is possibly undefined
// 44BD0A: variable 'v6' is possibly undefined
// 44BD0A: variable 'v5' is possibly undefined

//----- (0044BD30) --------------------------------------------------------
void __fastcall Interior_c::Lounge_AddSofaInfo(Interior_c *this, int32 wallId, int32 pos, CEntity *pSofaEntity)
{
  int v6; // r6
  float v7; // s16
  float v8; // s4
  float v9; // s0
  Interior_c *v10; // r0
  float v11; // r3
  float v12; // s16
  float v13; // s0
  float v14; // r2
  float v15; // s4
  int v16; // [sp+0h] [bp-20h]
  CEntity *v17; // [sp+4h] [bp-1Ch]

  v6 = (wallId + 2) & 3;
  switch ( wallId )
  {
    case 0:
      v7 = (float)pos + 0.5;
      v8 = (float)(this->m_box->m_depth - 2);
      Interior_c::AddInteriorInfo(this, 1, v7, v8, v6, (int)pSofaEntity);
      v9 = 1.0;
      v16 = v6;
      v17 = pSofaEntity;
      v10 = this;
      v11 = v8;
      goto LABEL_5;
    case 1:
      v12 = (float)pos + 0.5;
      Interior_c::AddInteriorInfo(this, 1, 1.0, v12, v6, (int)pSofaEntity);
      v13 = 1.0;
      v16 = v6;
      v17 = pSofaEntity;
      v10 = this;
      v14 = 1.0;
      goto LABEL_7;
    case 2:
      v7 = (float)pos + 0.5;
      Interior_c::AddInteriorInfo(this, 1, v7, 1.0, v6, (int)pSofaEntity);
      v9 = 1.0;
      v16 = v6;
      v17 = pSofaEntity;
      v10 = this;
      v11 = 1.0;
LABEL_5:
      v14 = v7 + v9;
      goto LABEL_8;
    case 3:
      v12 = (float)pos + 0.5;
      v15 = (float)(this->m_box->m_width - 2);
      Interior_c::AddInteriorInfo(this, 1, v15, v12, v6, (int)pSofaEntity);
      v13 = 1.0;
      v10 = this;
      v14 = v15;
      v16 = v6;
      v17 = pSofaEntity;
LABEL_7:
      v11 = v12 + v13;
LABEL_8:
      Interior_c::AddInteriorInfo(v10, 1, v14, v11, v16, (int)v17);
      break;
    default:
      return;
  }
}

//----- (0044BE68) --------------------------------------------------------
void __fastcall Interior_c::Lounge_AddChairInfo(Interior_c *this, int32 wallId, int32 pos, CEntity *pChairEntity)
{
  float v4; // r2
  float v5; // r12
  int v7; // [sp+0h] [bp-10h]
  CEntity *v8; // [sp+4h] [bp-Ch]

  switch ( wallId )
  {
    case 0:
      v4 = (float)pos + 0.5;
      v5 = (float)(this->m_box->m_depth - 2);
      goto LABEL_6;
    case 1:
      v4 = 1.0;
      v7 = (wallId + 2) & 3;
      v8 = pChairEntity;
      v5 = (float)pos + 0.5;
      goto LABEL_7;
    case 2:
      Interior_c::AddInteriorInfo(this, 1, (float)pos + 0.5, 1.0, (wallId + 2) & 3, (int)pChairEntity);
      return;
    case 3:
      v5 = (float)pos + 0.5;
      v4 = (float)(this->m_box->m_width - 2);
LABEL_6:
      v7 = (wallId + 2) & 3;
      v8 = pChairEntity;
LABEL_7:
      Interior_c::AddInteriorInfo(this, 1, v4, v5, v7, (int)v8);
      break;
    default:
      return;
  }
}

//----- (0044BF20) --------------------------------------------------------
void __fastcall Interior_c::Lounge_AddHifi(Interior_c *this, int32 wallId, int32 x, int32 y, int32 d)
{
  int v6; // r5
  float v7; // s16
  float v8; // s18
  Furniture_c *Furniture; // r0

  v6 = wallId & 3;
  v7 = (float)y;
  v8 = (float)x;
  if ( (wallId | 2) == 2 )
  {
    v8 = v8 + 0.5;
  }
  else if ( (wallId | 2) == 3 )
  {
    v7 = v7 + 0.5;
  }
  Furniture = FurnitureManager_c::GetFurniture(&g_furnitureMan, 2, 8, -1, this->m_box->m_status);
  Interior_c::PlaceObject(this, 1u, Furniture, v8 + 0.5, v7 + 0.5, 0.5, (float)v6 * 90.0);
}

//----- (0044BFC0) --------------------------------------------------------
void __fastcall InteriorManager_c::Exit(InteriorManager_c *this)
{
  InteriorGroup_c *i; // r6

  for ( i = (InteriorGroup_c *)this->m_interiorGroupList.m_head; i; i = (InteriorGroup_c *)i->m_next )
    InteriorGroup_c::Exit(i);
  List_c::RemoveAll(&this->m_interiorGroupList);
  List_c::RemoveAll(&this->m_interiorPool);
  List_c::RemoveAll(&this->m_interiorGroupPool);
  sub_19CA6C(&g_furnitureMan);
}

//----- (0044C010) --------------------------------------------------------
bool __fastcall InteriorManager_c::Update(InteriorManager_c *this)
{
  CPlayerPed *PlayerPed; // r4
  CTask *ActiveTask; // r0
  int VisibleEffects; // r4
  InteriorGroup_c *m_head; // r5
  InteriorGroup_c *m_next; // r11
  int v8; // r0
  bool8 *p_culled; // r2
  int m_groupId; // r6
  int v11; // r3
  bool v12; // zf
  int v13; // r3
  InteriorEffectInfo_t *v14; // r10
  InteriorEffectInfo_t *v15; // r9
  ListItem_c *v16; // r0
  int v17; // r2
  InteriorGroup_c *v18; // r6
  CEntity *pEntity; // r5
  int numEffects; // r11
  int i; // r8
  Interior_c *v22; // r9
  CMatrix *m_pMat; // r0
  float *p_tx; // r1
  CEntity **v25; // r0
  RwV3d_0 *v26; // r1
  int32 m_areaCode; // r0
  InteriorGroup_c *v28; // r4
  List_c *p_m_interiorGroupPool; // [sp+8h] [bp-A38h]
  CEntryExit **p_m_pEntryExit; // [sp+Ch] [bp-A34h]
  int32 *p_m_timeLastPickupsGenerated; // [sp+10h] [bp-A30h]
  int v32; // [sp+14h] [bp-A2Ch]
  List_c *p_m_interiorGroupList; // [sp+18h] [bp-A28h]
  bool v34; // [sp+1Ch] [bp-A24h]
  List_c *p_m_interiorPool; // [sp+20h] [bp-A20h]
  InteriorEffectInfo_t pInteriorEffectInfos[32]; // [sp+24h] [bp-A1Ch] BYREF

  if ( this->m_freeze )
    return 0;
  PlayerPed = FindPlayerPed(-1);
  if ( PlayerPed->m_areaCode
    && this->m_active
    && CTaskManager::GetActiveTask(&PlayerPed->m_pPedIntelligence->m_taskManager)
    && (ActiveTask = CTaskManager::GetActiveTask(&PlayerPed->m_pPedIntelligence->m_taskManager),
        (*((int (__fastcall **)(CTask *))ActiveTask->_vptr$CTask + 5))(ActiveTask) != 709) )
  {
    VisibleEffects = InteriorManager_c::GetVisibleEffects(this, pInteriorEffectInfos, 32);
  }
  else
  {
    VisibleEffects = 0;
  }
  InteriorManager_c::PruneVisibleEffects((InteriorManager_c *)0x41A00000, pInteriorEffectInfos, VisibleEffects, 8, 20.0);
  m_head = (InteriorGroup_c *)this->m_interiorGroupList.m_head;
  p_m_interiorGroupList = &this->m_interiorGroupList;
  if ( m_head )
  {
    do
    {
      m_next = (InteriorGroup_c *)m_head->m_next;
      if ( VisibleEffects < 1 )
      {
LABEL_16:
        InteriorGroup_c::Exit(m_head);
        List_c::RemoveItem(p_m_interiorGroupList, m_head);
        List_c::AddItem(&this->m_interiorGroupPool, m_head);
      }
      else
      {
        v8 = 0;
        p_culled = &pInteriorEffectInfos[0].culled;
        while ( 1 )
        {
          if ( m_head->m_pEntity == (CEntity *)*((_DWORD *)p_culled - 19) )
          {
            m_groupId = (unsigned __int8)m_head->m_groupId;
            v11 = *(unsigned __int8 *)(*((_DWORD *)p_culled - 17) + 17);
            v12 = m_groupId == v11;
            if ( m_groupId == v11 )
              v12 = *p_culled == 0;
            if ( v12 )
              break;
          }
          ++v8;
          p_culled += 80;
          if ( v8 >= VisibleEffects )
            goto LABEL_16;
        }
      }
      m_head = m_next;
    }
    while ( m_next );
  }
  if ( VisibleEffects < 1 )
  {
    v34 = 0;
  }
  else
  {
    p_m_interiorPool = &this->m_interiorPool;
    v13 = 0;
    p_m_timeLastPickupsGenerated = &this->m_timeLastPickupsGenerated;
    v14 = pInteriorEffectInfos;
    p_m_pEntryExit = &this->m_pEntryExit;
    p_m_interiorGroupPool = &this->m_interiorGroupPool;
    v34 = 0;
    do
    {
      v15 = &pInteriorEffectInfos[v13];
      if ( !v15->culled )
      {
        v16 = p_m_interiorGroupList->m_head;
        if ( !p_m_interiorGroupList->m_head )
          goto LABEL_28;
        v17 = 0;
        do
        {
          if ( v16[1].m_prev == (ListItem_c *)v15->pEntity
            && BYTE1(v16[1].m_next) == v15->pEffects[0]->attr.l.m_colour._anon_0._anon_0.green )
          {
            v17 = 1;
          }
          v16 = v16->m_next;
        }
        while ( v16 );
        if ( !(v17 << 24) )
        {
LABEL_28:
          v32 = v13;
          v18 = (InteriorGroup_c *)List_c::RemoveHead(p_m_interiorGroupPool);
          pEntity = v15->pEntity;
          InteriorGroup_c::Init(v18, v15->pEntity, v15->pEffects[0]->attr.i.m_group);
          v18->m_pEntryExit = *p_m_pEntryExit;
          List_c::AddItem(p_m_interiorGroupList, v18);
          numEffects = v15->numEffects;
          if ( numEffects >= 1 )
          {
            for ( i = 0; i < numEffects; ++i )
            {
              v22 = (Interior_c *)List_c::RemoveHead(p_m_interiorPool);
              if ( v22 )
              {
                m_pMat = pEntity->m_pMat;
                p_tx = &m_pMat->tx;
                if ( !m_pMat )
                  p_tx = &pEntity->m_transform.m_translate.x;
                v25 = &v14->pEntity + i;
                v22->m_id = (int32)v25[10] + (int)(float)((float)(*p_tx * p_tx[1]) * p_tx[2]);
                v26 = (RwV3d_0 *)v25[2];
                v22->m_box = (CInteriorAttr *)&v26[1].y;
                m_areaCode = pEntity->m_areaCode;
                v22->m_pInteriorGroup = v18;
                v22->m_areaCode = m_areaCode;
                Interior_c::Init(v22, v26);
                InteriorGroup_c::AddInterior(v18, v22);
                v34 = 1;
              }
            }
          }
          InteriorGroup_c::Setup(v18);
          *p_m_timeLastPickupsGenerated = CTimer::m_snTimeInMilliseconds;
          v13 = v32;
        }
      }
      ++v13;
      ++v14;
    }
    while ( v13 != VisibleEffects );
  }
  v28 = (InteriorGroup_c *)p_m_interiorGroupList->m_head;
  if ( p_m_interiorGroupList->m_head )
  {
    do
    {
      InteriorGroup_c::Update(v28);
      v28 = (InteriorGroup_c *)v28->m_next;
    }
    while ( v28 );
  }
  return v34;
}
// 44C246: masking with 0x1 was optimized away because r0.1 <= 0x1
// 44C010: using guessed type InteriorEffectInfo_t pInteriorEffectInfos[32];

//----- (0044C268) --------------------------------------------------------
int32 __fastcall InteriorManager_c::GetVisibleEffects(
        InteriorManager_c *this,
        InteriorEffectInfo_t *pInteriorEffectInfos,
        int32 maxSize)
{
  int32 v4; // r5
  CSimpleTransform *p_tx; // r0
  Int16 v6; // r0
  int v7; // r9
  CEntity *v8; // r1
  int m_nModelIndex; // r2
  int m_areaCode; // r1
  CBaseModelInfo *v11; // r10
  bool v12; // zf
  int32 v13; // r6
  C2dEffect *v14; // r1
  C2dEffect *v15; // r11
  int v16; // r0
  C2dEffect **pEffects; // r2
  int32 v18; // r12
  int32 v19; // r3
  InteriorEffectInfo_t *v20; // r0
  int v21; // r6
  CBaseModelInfo *v22; // r4
  int32 v23; // r5
  InteriorEffectInfo_t *v24; // r9
  int *p_numEffects; // r8
  C2dEffect *v26; // r0
  int32 v28; // [sp+24h] [bp-2034h]
  InteriorEffectInfo_t *v30; // [sp+30h] [bp-2028h]
  CEntity *v31[2048]; // [sp+34h] [bp-2024h] BYREF
  Int16 pNum[17]; // [sp+2036h] [bp-22h] BYREF

  v4 = 0;
  pNum[0] = -1;
  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  CWorld::FindObjectsInRange(&p_tx->m_translate, 100.0, 0, pNum, 2048, v31, 1, 0, 0, 0, 0);
  v6 = pNum[0];
  if ( pNum[0] >= 1 )
  {
    v4 = 0;
    v7 = 0;
    v30 = pInteriorEffectInfos;
    do
    {
      v8 = v31[v7];
      if ( v8->m_pRwObject )
      {
        m_nModelIndex = v8->m_nModelIndex;
        m_areaCode = v8->m_areaCode;
        v11 = CModelInfo::ms_modelInfoPtrs[m_nModelIndex];
        v12 = m_areaCode == 13;
        if ( m_areaCode != 13 )
          v12 = CGame::currArea == m_areaCode;
        if ( v12 && v11->m_num2dEffects )
        {
          v13 = 0;
          do
          {
            v15 = CBaseModelInfo::Get2dEffect(v11, v13);
            if ( v15->m_type == 5
              && InteriorManager_c::IsInteriorEffectVisible((InteriorManager_c *)&byte_5, v14, v31[v7]) )
            {
              if ( v4 < 1 )
              {
                v18 = v4;
                v16 = 0;
              }
              else
              {
                v16 = 0;
                pEffects = pInteriorEffectInfos->pEffects;
                v18 = v4;
                v19 = v4;
                do
                {
                  if ( *(pEffects - 2) == (C2dEffect *)v31[v7]
                    && (*pEffects)->attr.l.m_colour._anon_0._anon_0.green == v15->attr.l.m_colour._anon_0._anon_0.green )
                  {
                    v16 = 1;
                  }
                  pEffects += 20;
                  --v19;
                }
                while ( v19 );
              }
              v4 = v18;
              if ( v18 < maxSize && !(v16 << 24) )
              {
                v4 = v18 + 1;
                pInteriorEffectInfos[v18].pEntity = v31[v7];
                v20 = &pInteriorEffectInfos[v18];
                v20->effectIds[0] = v13;
                v20->numEffects = 1;
                v20->pEffects[0] = v15;
                v20->culled = 0;
              }
            }
            ++v13;
          }
          while ( v13 < v11->m_num2dEffects );
          v6 = pNum[0];
        }
      }
      ++v7;
    }
    while ( v7 < v6 );
    if ( v4 >= 1 )
    {
      v21 = 0;
      v28 = v4;
      do
      {
        v22 = CModelInfo::ms_modelInfoPtrs[v30[v21].pEntity->m_nModelIndex];
        if ( v22->m_num2dEffects )
        {
          v23 = 0;
          v24 = &v30[v21];
          p_numEffects = &v24->numEffects;
          do
          {
            if ( v23 != v24->effectIds[0] )
            {
              v26 = CBaseModelInfo::Get2dEffect(v22, v23);
              if ( v26->m_type == 5
                && v24->pEffects[0]->attr.l.m_colour._anon_0._anon_0.green == v26->attr.l.m_colour._anon_0._anon_0.green
                && *p_numEffects <= 7 )
              {
                v24->pEffects[*p_numEffects] = v26;
                v24->effectIds[(*p_numEffects)++] = v23;
              }
            }
            ++v23;
          }
          while ( v23 < v22->m_num2dEffects );
        }
        v4 = v28;
        ++v21;
      }
      while ( v21 != v28 );
    }
  }
  return v4;
}
// 44C328: variable 'v14' is possibly undefined
// 5: using guessed type char byte_5;
// 44C268: using guessed type Int16 pNum[17];

//----- (0044C45C) --------------------------------------------------------
void __fastcall InteriorManager_c::PruneVisibleEffects(
        InteriorManager_c *this,
        InteriorEffectInfo_t *pInteriorEffectInfos,
        int32 numInfos,
        int32 reqdNumInfos,
        float maxDist)
{
  int32 *p_numEffects; // r4
  int32 v6; // r0
  int32 v7; // r5
  int32 v8; // t1
  C2dEffect **pEffects; // r5
  int v10; // r1
  InteriorEffectInfo_t *v11; // r10
  float *p_distSq; // r9
  int32 v13; // r4
  CEntity *pEntity; // r6
  const CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r1
  float32x2_t v17; // d16
  unsigned __int64 v18; // d0
  float v19; // s0
  int32 v20; // r2
  int v21; // r9
  int v22; // r1
  float *v23; // r11
  int v24; // r10
  InteriorEffectInfo_t *v25; // r6
  bool8 *p_culled; // r0
  int32 v27; // r5
  int32 v28; // r3
  int v30; // [sp+8h] [bp-90h]
  int v33; // [sp+14h] [bp-84h]
  float *v34; // [sp+14h] [bp-84h]
  CVector v35[10]; // [sp+18h] [bp-80h] BYREF

  if ( numInfos < 1 )
  {
    if ( reqdNumInfos >= 0 )
      return;
  }
  else
  {
    p_numEffects = &pInteriorEffectInfos->numEffects;
    v6 = 0;
    v7 = numInfos;
    do
    {
      v8 = *p_numEffects;
      p_numEffects += 20;
      --v7;
      v6 += v8;
    }
    while ( v7 );
    if ( v6 <= reqdNumInfos )
      return;
  }
  if ( numInfos >= 1 )
  {
    pEffects = pInteriorEffectInfos->pEffects;
    v10 = 0;
    do
    {
      v33 = v10;
      v11 = &pInteriorEffectInfos[v10];
      v11->distSq = 100000000.0;
      p_distSq = &v11->distSq;
      if ( v11->numEffects >= 1 )
      {
        v13 = 0;
        do
        {
          pEntity = v11->pEntity;
          m_pMat = v11->pEntity->m_pMat;
          if ( !m_pMat )
          {
            CPlaceable::AllocateMatrix(v11->pEntity);
            CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
            m_pMat = pEntity->m_pMat;
          }
          operator*(v35, m_pMat, &pEffects[v13++]->m_posn);
          p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
          if ( !TheCamera.m_pMat )
            p_tx = &TheCamera.m_transform;
          v17.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.x, *(float32x2_t *)&v35[0].x).n64_u64[0];
          v18 = vmul_f32(v17, v17).n64_u64[0];
          v19 = (float)(*(float *)&v18 + *((float *)&v18 + 1)) + 0.0;
          if ( v19 < *p_distSq )
            *p_distSq = v19;
        }
        while ( v13 < v11->numEffects );
      }
      pEffects += 20;
      v20 = numInfos;
      v10 = v33 + 1;
    }
    while ( v33 + 1 != numInfos );
    if ( numInfos >= 2 )
    {
      v21 = numInfos - 1;
      v22 = 0;
      v34 = &pInteriorEffectInfos[1].distSq;
      do
      {
        v30 = v22 + 1;
        if ( v22 + 1 < v20 )
        {
          v23 = v34;
          v24 = v21;
          v25 = &pInteriorEffectInfos[v22];
          do
          {
            if ( *v23 < v25->distSq )
            {
              qmemcpy(v35, v25, 0x50u);
              qmemcpy(v25, v23 - 18, sizeof(InteriorEffectInfo_t));
              qmemcpy(v23 - 18, v35, 0x50u);
            }
            --v24;
            v23 += 20;
          }
          while ( v24 );
        }
        --v21;
        v34 += 20;
        v22 = v30;
        v20 = numInfos;
      }
      while ( v30 != numInfos - 1 );
    }
    p_culled = &pInteriorEffectInfos->culled;
    v27 = 0;
    do
    {
      v28 = *((_DWORD *)p_culled - 18) + v27;
      if ( v28 > reqdNumInfos || *((float *)p_culled - 1) > (float)(maxDist * maxDist) )
      {
        v28 = v27;
        *p_culled = 1;
      }
      p_culled += 80;
      --v20;
      v27 = v28;
    }
    while ( v20 );
  }
}
// 44C5D2: conditional instruction was optimized away because r2.4>=1

//----- (0044C620) --------------------------------------------------------
Interior_c *__fastcall InteriorManager_c::GetInteriorFromPool(InteriorManager_c *this)
{
  return (Interior_c *)sub_19049C(&this->m_interiorPool);
}

//----- (0044C62A) --------------------------------------------------------
void __fastcall InteriorManager_c::Freeze(InteriorManager_c *this, bool8 freeze)
{
  this->m_freeze = freeze;
}

//----- (0044C632) --------------------------------------------------------
void __fastcall InteriorManager_c::Activate(InteriorManager_c *this, bool8 active)
{
  this->m_active = active;
}

//----- (0044C63A) --------------------------------------------------------
void __fastcall InteriorManager_c::ActivatePeds(InteriorManager_c *this, bool8 active)
{
  this->m_activePeds = active;
}

//----- (0044C642) --------------------------------------------------------
bool8 __fastcall InteriorManager_c::GetBoundingBox(InteriorManager_c *this, CEntity *pEntity, CVector *pCorners)
{
  ListItem_c *m_head; // r4
  Interior_c *m_prev; // r0
  Interior_c **p_m_next; // r6
  FurnitureEntity_c *FurnitureEntity; // r1
  Interior_c *m_next; // r0
  Interior_c *v10; // r0
  Interior_c *v11; // r0
  Interior_c *v12; // r0
  Interior_c *v13; // r0
  Interior_c *v14; // r0
  Interior_c *v15; // r0

  m_head = this->m_interiorGroupList.m_head;
  if ( !m_head )
    return 0;
  while ( 1 )
  {
    p_m_next = (Interior_c **)&m_head[2];
    m_prev = (Interior_c *)m_head[2].m_prev;
    if ( m_prev )
    {
      FurnitureEntity = Interior_c::GetFurnitureEntity(m_prev, pEntity);
      if ( FurnitureEntity )
        break;
    }
    p_m_next = (Interior_c **)&m_head[2].m_next;
    m_next = (Interior_c *)m_head[2].m_next;
    if ( m_next )
    {
      FurnitureEntity = Interior_c::GetFurnitureEntity(m_next, pEntity);
      if ( FurnitureEntity )
        break;
    }
    p_m_next = (Interior_c **)&m_head[3];
    v10 = (Interior_c *)m_head[3].m_prev;
    if ( v10 )
    {
      FurnitureEntity = Interior_c::GetFurnitureEntity(v10, pEntity);
      if ( FurnitureEntity )
        break;
    }
    p_m_next = (Interior_c **)&m_head[3].m_next;
    v11 = (Interior_c *)m_head[3].m_next;
    if ( v11 )
    {
      FurnitureEntity = Interior_c::GetFurnitureEntity(v11, pEntity);
      if ( FurnitureEntity )
        break;
    }
    p_m_next = (Interior_c **)&m_head[4];
    v12 = (Interior_c *)m_head[4].m_prev;
    if ( v12 )
    {
      FurnitureEntity = Interior_c::GetFurnitureEntity(v12, pEntity);
      if ( FurnitureEntity )
        break;
    }
    p_m_next = (Interior_c **)&m_head[4].m_next;
    v13 = (Interior_c *)m_head[4].m_next;
    if ( v13 )
    {
      FurnitureEntity = Interior_c::GetFurnitureEntity(v13, pEntity);
      if ( FurnitureEntity )
        break;
    }
    p_m_next = (Interior_c **)&m_head[5];
    v14 = (Interior_c *)m_head[5].m_prev;
    if ( v14 )
    {
      FurnitureEntity = Interior_c::GetFurnitureEntity(v14, pEntity);
      if ( FurnitureEntity )
        break;
    }
    p_m_next = (Interior_c **)&m_head[5].m_next;
    v15 = (Interior_c *)m_head[5].m_next;
    if ( v15 )
    {
      FurnitureEntity = Interior_c::GetFurnitureEntity(v15, pEntity);
      if ( FurnitureEntity )
        break;
    }
    m_head = m_head->m_next;
    if ( !m_head )
      return 0;
  }
  return sub_199FB4(*p_m_next, FurnitureEntity, pCorners);
}

//----- (0044C70C) --------------------------------------------------------
bool8 __fastcall InteriorManager_c::AreAnimsLoaded(InteriorManager_c *this, int32 groupType)
{
  if ( (unsigned int)groupType <= 2 )
    this = (InteriorManager_c *)CAnimManager::GetAnimationBlockIndex((const unsigned __int8 *)off_667D98[groupType]);
  return CAnimManager::ms_aAnimBlocks[(_DWORD)this].m_loaded;
}
// 667D98: using guessed type char *off_667D98[3];

//----- (0044C73C) --------------------------------------------------------
void __fastcall InteriorManager_c::SetEntryExitPtr(InteriorManager_c *this, CEntryExit *pEntryExit)
{
  CEntryExit *pLink; // r2
  CRect *p_m_entryExitRect; // lr
  CRect *p_rect; // r4
  __int64 v5; // d17

  pLink = pEntryExit->pLink;
  if ( !pLink )
    pLink = pEntryExit;
  if ( pLink->areacode )
  {
    p_m_entryExitRect = &this->m_entryExitRect;
    p_rect = &pEntryExit->rect;
    if ( pEntryExit->rect.top != this->m_entryExitRect.top
      || pEntryExit->rect.bottom != this->m_entryExitRect.bottom
      || p_rect->left != p_m_entryExitRect->left
      || pEntryExit->rect.right != this->m_entryExitRect.right )
    {
      this->m_numStealInfosIds = 0;
      this->m_numStealableObjects = 0;
      *(_DWORD *)&this->m_pedsAlive[12] = 16843009;
      *(_DWORD *)&this->m_pedsAlive[8] = 16843009;
      *(_DWORD *)&this->m_pedsAlive[4] = 16843009;
      *(_DWORD *)this->m_pedsAlive = 16843009;
    }
    this->m_pEntryExit = pEntryExit;
    v5 = *(_QWORD *)&pEntryExit->rect.right;
    *(_QWORD *)&p_m_entryExitRect->left = *(_QWORD *)&p_rect->left;
    *(_QWORD *)&this->m_entryExitRect.right = v5;
  }
}

//----- (0044C7F6) --------------------------------------------------------
InteriorGroup_c *__fastcall InteriorManager_c::GetPedsInteriorGroup(InteriorManager_c *this, CPed *pPed)
{
  InteriorGroup_c *result; // r0
  int m_numPeds; // r12
  int v4; // r2

  result = (InteriorGroup_c *)this->m_interiorGroupList.m_head;
  if ( !result )
    return 0;
  while ( 1 )
  {
    m_numPeds = result->m_numPeds;
    if ( m_numPeds >= 1 )
      break;
LABEL_3:
    result = (InteriorGroup_c *)result->m_next;
    if ( !result )
      return 0;
  }
  v4 = 0;
  while ( result->m_pPeds[v4] != pPed )
  {
    if ( ++v4 >= m_numPeds )
      goto LABEL_3;
  }
  return result;
}

//----- (0044C82E) --------------------------------------------------------
bool8 __fastcall InteriorManager_c::IsGroupActive(InteriorManager_c *this, int32 groupId)
{
  ListItem_c *m_head; // r0

  m_head = this->m_interiorGroupList.m_head;
  if ( !m_head )
    return 0;
  while ( SBYTE2(m_head[1].m_next) != groupId )
  {
    m_head = m_head->m_next;
    if ( !m_head )
      return 0;
  }
  return 1;
}

//----- (0044C856) --------------------------------------------------------
bool8 __fastcall InteriorManager_c::HasInteriorHadStealDataSetup(InteriorManager_c *this, Interior_c *pInterior)
{
  int32 m_numStealInfosIds; // r12
  int32 m_id; // r1
  int32 *m_stealInfoSetupIds; // r0
  int32 i; // r3

  m_numStealInfosIds = this->m_numStealInfosIds;
  if ( m_numStealInfosIds < 1 )
    return 0;
  m_id = pInterior->m_id;
  m_stealInfoSetupIds = this->m_stealInfoSetupIds;
  for ( i = 0; i < m_numStealInfosIds; ++i )
  {
    if ( m_stealInfoSetupIds[i] == m_id )
      return 1;
  }
  return 0;
}

//----- (0044C88A) --------------------------------------------------------
int __fastcall InteriorManager_c::FindStealableObjectId(int a1, int a2, int a3, float a4, float a5, float a6)
{
  int v6; // r12
  float *v7; // lr
  int result; // r0
  int v10; // r3
  bool v11; // zf

  v6 = *(_DWORD *)(a1 + 17320);
  if ( v6 < 1 )
    return -1;
  v7 = (float *)(a1 + 17344);
  result = 0;
  while ( 1 )
  {
    v10 = *((_DWORD *)v7 - 3);
    v11 = v10 == a2;
    if ( v10 == a2 )
      v11 = *((_DWORD *)v7 - 4) == a3;
    if ( v11 && *(v7 - 2) == a4 && *v7 == a6 )
      break;
    ++result;
    v7 += 7;
    if ( result >= v6 )
      return -1;
  }
  return result;
}

//----- (0044C910) --------------------------------------------------------
int32 __fastcall InteriorManager_c::FindStealableObjectId(InteriorManager_c *this, CEntity *pEntity)
{
  int m_numStealableObjects; // r12
  StealableInfo_t *m_stealableInfos; // r3
  int32 result; // r0

  m_numStealableObjects = this->m_numStealableObjects;
  if ( m_numStealableObjects < 1 )
    return -1;
  m_stealableInfos = this->m_stealableInfos;
  result = 0;
  while ( m_stealableInfos->pEntity != pEntity )
  {
    ++result;
    ++m_stealableInfos;
    if ( result >= m_numStealableObjects )
      return -1;
  }
  return result;
}

//----- (0044C93C) --------------------------------------------------------
void __fastcall InteriorManager_c::SetStealableObjectStolen(InteriorManager_c *this, CEntity *pEntity, bool8 isStolen)
{
  int32 m_numStealableObjects; // r12
  bool8 *p_isStolen; // lr
  int32 v5; // r3

  m_numStealableObjects = this->m_numStealableObjects;
  if ( m_numStealableObjects >= 1 )
  {
    p_isStolen = &this->m_stealableInfos[0].isStolen;
    v5 = 0;
    while ( *((CEntity **)p_isStolen - 6) != pEntity )
    {
      ++v5;
      p_isStolen += 28;
      if ( v5 >= m_numStealableObjects )
        return;
    }
    *p_isStolen = isStolen;
  }
}

//----- (0044C974) --------------------------------------------------------
Interior_c *__fastcall InteriorManager_c::GetPedsInterior(InteriorManager_c *this, CPed *pPed)
{
  ListItem_c *m_head; // r5
  int v4; // r0
  int v5; // r2
  CSimpleTransform *p_m_transform; // r8
  Interior_c *m_prev; // r0
  Interior_c **p_m_next; // r9
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r1
  Interior_c *m_next; // r0
  CMatrix *v12; // r2
  CSimpleTransform *v13; // r1
  Interior_c *v14; // r0
  CMatrix *v15; // r2
  CSimpleTransform *v16; // r1
  Interior_c *v17; // r0
  CMatrix *v18; // r2
  CSimpleTransform *v19; // r1
  Interior_c *v20; // r0
  CMatrix *v21; // r2
  CSimpleTransform *v22; // r1
  Interior_c *v23; // r0
  CMatrix *v24; // r2
  CSimpleTransform *v25; // r1
  Interior_c *v26; // r0
  CMatrix *v27; // r2
  CSimpleTransform *v28; // r1
  Interior_c *v29; // r6
  Interior_c *v31; // r0
  Interior_c **v32; // r5
  Interior_c *v33; // t1
  CMatrix *v34; // r1

  m_head = this->m_interiorGroupList.m_head;
  if ( !m_head )
    return 0;
  while ( 1 )
  {
    v4 = SBYTE2(m_head[6].m_next);
    if ( v4 >= 1 )
      break;
LABEL_3:
    m_head = m_head->m_next;
    if ( !m_head )
      return 0;
  }
  v5 = 0;
  while ( *((CPed **)&m_head[7].m_prev + v5) != pPed )
  {
    if ( ++v5 >= v4 )
      goto LABEL_3;
  }
  p_m_transform = &pPed->m_transform;
  p_m_next = (Interior_c **)&m_head[2];
  m_prev = (Interior_c *)m_head[2].m_prev;
  if ( m_prev )
  {
    m_pMat = pPed->m_pMat;
    p_tx = &pPed->m_transform;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( Interior_c::IsPtInside(m_prev, &p_tx->m_translate, 0.0, 0.0, 0.0) )
      return *p_m_next;
  }
  p_m_next = (Interior_c **)&m_head[2].m_next;
  m_next = (Interior_c *)m_head[2].m_next;
  if ( m_next )
  {
    v12 = pPed->m_pMat;
    v13 = &pPed->m_transform;
    if ( v12 )
      v13 = (CSimpleTransform *)&v12->tx;
    if ( Interior_c::IsPtInside(m_next, &v13->m_translate, 0.0, 0.0, 0.0) )
      return *p_m_next;
  }
  p_m_next = (Interior_c **)&m_head[3];
  v14 = (Interior_c *)m_head[3].m_prev;
  if ( v14 )
  {
    v15 = pPed->m_pMat;
    v16 = &pPed->m_transform;
    if ( v15 )
      v16 = (CSimpleTransform *)&v15->tx;
    if ( Interior_c::IsPtInside(v14, &v16->m_translate, 0.0, 0.0, 0.0) )
      return *p_m_next;
  }
  p_m_next = (Interior_c **)&m_head[3].m_next;
  v17 = (Interior_c *)m_head[3].m_next;
  if ( v17 )
  {
    v18 = pPed->m_pMat;
    v19 = &pPed->m_transform;
    if ( v18 )
      v19 = (CSimpleTransform *)&v18->tx;
    if ( Interior_c::IsPtInside(v17, &v19->m_translate, 0.0, 0.0, 0.0) )
      return *p_m_next;
  }
  p_m_next = (Interior_c **)&m_head[4];
  v20 = (Interior_c *)m_head[4].m_prev;
  if ( v20 )
  {
    v21 = pPed->m_pMat;
    v22 = &pPed->m_transform;
    if ( v21 )
      v22 = (CSimpleTransform *)&v21->tx;
    if ( Interior_c::IsPtInside(v20, &v22->m_translate, 0.0, 0.0, 0.0) )
      return *p_m_next;
  }
  p_m_next = (Interior_c **)&m_head[4].m_next;
  v23 = (Interior_c *)m_head[4].m_next;
  if ( v23 )
  {
    v24 = pPed->m_pMat;
    v25 = &pPed->m_transform;
    if ( v24 )
      v25 = (CSimpleTransform *)&v24->tx;
    if ( Interior_c::IsPtInside(v23, &v25->m_translate, 0.0, 0.0, 0.0) )
      return *p_m_next;
  }
  p_m_next = (Interior_c **)&m_head[5];
  v26 = (Interior_c *)m_head[5].m_prev;
  if ( !v26 )
    goto LABEL_40;
  v27 = pPed->m_pMat;
  v28 = &pPed->m_transform;
  if ( v27 )
    v28 = (CSimpleTransform *)&v27->tx;
  if ( Interior_c::IsPtInside(v26, &v28->m_translate, 0.0, 0.0, 0.0) )
    return *p_m_next;
LABEL_40:
  v33 = (Interior_c *)m_head[5].m_next;
  v32 = (Interior_c **)&m_head[5].m_next;
  v31 = v33;
  v29 = 0;
  if ( v33 )
  {
    v34 = pPed->m_pMat;
    if ( v34 )
      p_m_transform = (CSimpleTransform *)&v34->tx;
    if ( Interior_c::IsPtInside(v31, &p_m_transform->m_translate, 0.0, 0.0, 0.0) )
      return *v32;
  }
  return v29;
}

//----- (0044CAF4) --------------------------------------------------------
Interior_c *__fastcall InteriorManager_c::GetVectorsInterior(InteriorManager_c *this, CVector *pVector)
{
  ListItem_c *m_head; // r5
  Interior_c *v4; // r4
  Interior_c *m_prev; // r0
  Interior_c **p_m_next; // r6
  Interior_c *m_next; // r0
  Interior_c *v8; // r0
  Interior_c *v9; // r0
  Interior_c *v10; // r0
  Interior_c *v11; // r0
  Interior_c *v12; // r0
  Interior_c *v13; // r0

  m_head = this->m_interiorGroupList.m_head;
  v4 = 0;
  if ( m_head )
  {
    while ( 1 )
    {
      p_m_next = (Interior_c **)&m_head[2];
      m_prev = (Interior_c *)m_head[2].m_prev;
      if ( m_prev )
      {
        if ( Interior_c::IsPtInside(m_prev, pVector, 0.0, 0.0, 0.0) )
          break;
      }
      p_m_next = (Interior_c **)&m_head[2].m_next;
      m_next = (Interior_c *)m_head[2].m_next;
      if ( m_next )
      {
        if ( Interior_c::IsPtInside(m_next, pVector, 0.0, 0.0, 0.0) )
          break;
      }
      p_m_next = (Interior_c **)&m_head[3];
      v8 = (Interior_c *)m_head[3].m_prev;
      if ( v8 )
      {
        if ( Interior_c::IsPtInside(v8, pVector, 0.0, 0.0, 0.0) )
          break;
      }
      p_m_next = (Interior_c **)&m_head[3].m_next;
      v9 = (Interior_c *)m_head[3].m_next;
      if ( v9 )
      {
        if ( Interior_c::IsPtInside(v9, pVector, 0.0, 0.0, 0.0) )
          break;
      }
      p_m_next = (Interior_c **)&m_head[4];
      v10 = (Interior_c *)m_head[4].m_prev;
      if ( v10 )
      {
        if ( Interior_c::IsPtInside(v10, pVector, 0.0, 0.0, 0.0) )
          break;
      }
      p_m_next = (Interior_c **)&m_head[4].m_next;
      v11 = (Interior_c *)m_head[4].m_next;
      if ( v11 )
      {
        if ( Interior_c::IsPtInside(v11, pVector, 0.0, 0.0, 0.0) )
          break;
      }
      p_m_next = (Interior_c **)&m_head[5];
      v12 = (Interior_c *)m_head[5].m_prev;
      if ( v12 )
      {
        if ( Interior_c::IsPtInside(v12, pVector, 0.0, 0.0, 0.0) )
          break;
      }
      p_m_next = (Interior_c **)&m_head[5].m_next;
      v13 = (Interior_c *)m_head[5].m_next;
      if ( v13 )
      {
        if ( Interior_c::IsPtInside(v13, pVector, 0.0, 0.0, 0.0) )
          break;
      }
      m_head = m_head->m_next;
      if ( !m_head )
        return 0;
    }
    return *p_m_next;
  }
  return v4;
}

//----- (0044CBD8) --------------------------------------------------------
bool8 __fastcall InteriorManager_c::IsInteriorEffectVisible(
        InteriorManager_c *this,
        C2dEffect *pEffect,
        CEntity *pEntity)
{
  float32x2_t v3; // d0
  float32x2_t v4; // d1
  float32x2_t v5; // d2
  float32x2_t v6; // d8
  float32x2_t v7; // d9
  CSimpleTransform *p_m_transform; // r8
  float32x2_t v10; // d11
  float32x2_t v11; // d12
  float32x2_t v12; // d10
  float32x2_t v13; // d13
  CColModel *m_pColModel; // r0
  RwReal x; // r1
  int y_low; // r2
  RwReal z; // r3
  __int64 v18; // kr00_8
  int v19; // r6
  CMatrix *m_pMat; // r1
  _DWORD *v21; // r5
  __int64 v22; // d16
  char v23; // r6
  char v24; // r4
  bool v25; // r8
  CSimpleTransform *p_tx; // r2
  char v27; // r0
  char v28; // r1
  float y; // s2
  float v30; // s28
  char v31; // r5
  CPlayerPed *PlayerPed; // r0
  CMatrix *v33; // r1
  float *p_x; // r3
  char v35; // r0
  char v36; // r1
  char v37; // r5
  char v38; // r6
  CPlayerPed *v39; // r0
  CMatrix *v40; // r2
  float *v41; // r1
  float v42; // s0
  float v43; // s2
  CVector v45; // [sp+0h] [bp-C0h] BYREF
  _DWORD v46[16]; // [sp+10h] [bp-B0h] BYREF
  __int64 v47; // [sp+50h] [bp-70h]
  RwReal v48; // [sp+58h] [bp-68h]
  __int64 v49; // [sp+5Ch] [bp-64h]
  RwReal v50; // [sp+64h] [bp-5Ch]
  int v51; // [sp+68h] [bp-58h]
  int v52; // [sp+6Ch] [bp-54h]

  v7.n64_u32[0] = 1232348144;
  v6.n64_u32[0] = -915135504;
  p_m_transform = &pEntity->m_transform;
  v10.n64_u64[0] = v7.n64_u64[0];
  v11.n64_u64[0] = v6.n64_u64[0];
  v12.n64_u64[0] = v6.n64_u64[0];
  v13.n64_u64[0] = v7.n64_u64[0];
  m_pColModel = CModelInfo::ms_modelInfoPtrs[pEntity->m_nModelIndex]->m_pColModel;
  x = m_pColModel->m_boxBound.m_vecMin.x;
  y_low = LODWORD(m_pColModel->m_boxBound.m_vecMin.y);
  z = m_pColModel->m_boxBound.m_vecMin.z;
  v18 = *(_QWORD *)&m_pColModel->m_boxBound.m_vecMax.y;
  v50 = m_pColModel->m_boxBound.m_vecMax.x;
  v51 = y_low;
  *(RwReal *)&v46[9] = v50;
  v46[10] = y_low;
  *(RwReal *)&v46[15] = x;
  v47 = v18;
  *(RwReal *)&v46[3] = x;
  v46[4] = v18;
  *(RwReal *)&v46[11] = z;
  *(RwReal *)&v46[12] = x;
  v46[7] = v18;
  *(RwReal *)&v46[8] = z;
  *(RwReal *)&v46[5] = z;
  *(RwReal *)&v46[6] = v50;
  v52 = HIDWORD(v18);
  *(RwReal *)v46 = x;
  v46[1] = y_low;
  *(RwReal *)&v46[2] = z;
  v49 = v18;
  v48 = v50;
  v19 = 0;
  v46[13] = y_low;
  v46[14] = HIDWORD(v18);
  do
  {
    m_pMat = pEntity->m_pMat;
    if ( !m_pMat )
    {
      CPlaceable::AllocateMatrix(pEntity);
      CSimpleTransform::UpdateMatrix(p_m_transform, pEntity->m_pMat);
      m_pMat = pEntity->m_pMat;
    }
    v21 = &v46[v19];
    operator*(&v45, m_pMat, (const CVector *)&v46[v19]);
    v22 = *(_QWORD *)&v45.x;
    v19 += 3;
    v21[2] = LODWORD(v45.z);
    *(_QWORD *)v21 = v22;
    v3.n64_u32[0] = *v21;
    v4.n64_u32[0] = v21[1];
    v5.n64_u32[0] = v21[2];
    v6.n64_u64[0] = vmax_f32(v3, v6).n64_u64[0];
    v11.n64_u64[0] = vmax_f32(v4, v11).n64_u64[0];
    v12.n64_u64[0] = vmax_f32(v5, v12).n64_u64[0];
    v13.n64_u64[0] = vmin_f32(v5, v13).n64_u64[0];
    v10.n64_u64[0] = vmin_f32(v4, v10).n64_u64[0];
    v7.n64_u64[0] = vmin_f32(v3, v7).n64_u64[0];
  }
  while ( v19 != 24 );
  v23 = 0;
  v24 = 0;
  v25 = 0;
  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  v27 = 0;
  v28 = 0;
  y = p_tx->m_translate.y;
  v30 = p_tx->m_translate.z;
  if ( p_tx->m_translate.x <= v6.n64_f32[0] )
    v27 = 1;
  if ( p_tx->m_translate.x >= v7.n64_f32[0] )
    v28 = 1;
  v31 = v28 & v27;
  if ( y <= v11.n64_f32[0] )
    v23 = 1;
  if ( y >= v10.n64_f32[0] )
    v24 = 1;
  PlayerPed = FindPlayerPed(0);
  v33 = PlayerPed->m_pMat;
  p_x = &v33->tx;
  if ( !v33 )
    p_x = &PlayerPed->m_transform.m_translate.x;
  v35 = 0;
  v36 = 0;
  if ( v30 <= v12.n64_f32[0] )
    v35 = 1;
  v37 = v35 & v31 & v24 & v23 & (v30 >= v13.n64_f32[0]);
  if ( *p_x >= v7.n64_f32[0] )
    v36 = 1;
  v38 = (p_x[2] <= v12.n64_f32[0]) & (*p_x <= v6.n64_f32[0]) & v36 & (p_x[1] >= v10.n64_f32[0]) & (p_x[1] <= v11.n64_f32[0]) & (p_x[2] >= v13.n64_f32[0]);
  if ( FindPlayerPed(1) )
  {
    v39 = FindPlayerPed(1);
    v40 = v39->m_pMat;
    v25 = 0;
    v41 = &v40->tx;
    if ( !v40 )
      v41 = &v39->m_transform.m_translate.x;
    v42 = v41[2];
    if ( v42 >= v13.n64_f32[0] )
    {
      v43 = v41[1];
      if ( v43 <= v11.n64_f32[0] && *v41 >= v7.n64_f32[0] && *v41 <= v6.n64_f32[0] && v43 >= v10.n64_f32[0] )
        v25 = v42 <= v12.n64_f32[0];
    }
  }
  return v37 | v38 | v25;
}
// 44CC02: variable 'v7' is possibly undefined
// 44CC06: variable 'v6' is possibly undefined
// 44CC92: variable 'v3' is possibly undefined
// 44CC96: variable 'v4' is possibly undefined
// 44CC9A: variable 'v5' is possibly undefined

//----- (0044CE60) --------------------------------------------------------
void __fastcall InteriorManager_c::AddSameGroupEffectInfos(
        InteriorManager_c *this,
        InteriorEffectInfo_t *pInteriorEffectInfo,
        int32 maxSize)
{
  CBaseModelInfo *v4; // r5
  int32 v5; // r6
  C2dEffect *v6; // r0
  int32 numEffects; // r1

  v4 = CModelInfo::ms_modelInfoPtrs[pInteriorEffectInfo->pEntity->m_nModelIndex];
  if ( v4->m_num2dEffects )
  {
    v5 = 0;
    do
    {
      if ( v5 != pInteriorEffectInfo->effectIds[0] )
      {
        v6 = CBaseModelInfo::Get2dEffect(v4, v5);
        if ( v6->m_type == 5
          && pInteriorEffectInfo->pEffects[0]->attr.l.m_colour._anon_0._anon_0.green == v6->attr.l.m_colour._anon_0._anon_0.green )
        {
          numEffects = pInteriorEffectInfo->numEffects;
          if ( numEffects <= 7 )
          {
            pInteriorEffectInfo->pEffects[numEffects] = v6;
            pInteriorEffectInfo->effectIds[pInteriorEffectInfo->numEffects++] = v5;
          }
        }
      }
      ++v5;
    }
    while ( v5 < v4->m_num2dEffects );
  }
}

//----- (0044CED0) --------------------------------------------------------
void __fastcall InteriorManager_c::ReturnInteriorToPool(InteriorManager_c *this, Interior_c *pInterior)
{
  sub_1955CC(&this->m_interiorPool, pInterior);
}

//----- (0044CEE0) --------------------------------------------------------
void __fastcall InteriorManager_c::InteriorManager_c(InteriorManager_c *this)
{
  Interior_c::Interior_c(this->m_interiors);
  Interior_c::Interior_c(&this->m_interiors[1]);
  Interior_c::Interior_c(&this->m_interiors[2]);
  Interior_c::Interior_c(&this->m_interiors[3]);
  Interior_c::Interior_c(&this->m_interiors[4]);
  Interior_c::Interior_c(&this->m_interiors[5]);
  Interior_c::Interior_c(&this->m_interiors[6]);
  Interior_c::Interior_c(&this->m_interiors[7]);
  List_c::List_c(&this->m_interiorPool);
  ListItem_c::ListItem_c(this->m_interiorGroups);
  ListItem_c::ListItem_c(&this->m_interiorGroups[1]);
  ListItem_c::ListItem_c(&this->m_interiorGroups[2]);
  ListItem_c::ListItem_c(&this->m_interiorGroups[3]);
  ListItem_c::ListItem_c(&this->m_interiorGroups[4]);
  ListItem_c::ListItem_c(&this->m_interiorGroups[5]);
  ListItem_c::ListItem_c(&this->m_interiorGroups[6]);
  ListItem_c::ListItem_c(&this->m_interiorGroups[7]);
  List_c::List_c(&this->m_interiorGroupList);
  List_c::List_c(&this->m_interiorGroupPool);
  *(_QWORD *)&this->m_entryExitRect.left = loc_44CFB0;
  *(_QWORD *)&this->m_entryExitRect.right = loc_44CFB8;
}

//----- (0044CFC0) --------------------------------------------------------
void __fastcall InteriorManager_c::~InteriorManager_c(InteriorManager_c *this)
{
  List_c::~List_c(&this->m_interiorGroupPool);
  List_c::~List_c(&this->m_interiorGroupList);
  ListItem_c::~ListItem_c(&this->m_interiorGroups[7]);
  ListItem_c::~ListItem_c(&this->m_interiorGroups[6]);
  ListItem_c::~ListItem_c(&this->m_interiorGroups[5]);
  ListItem_c::~ListItem_c(&this->m_interiorGroups[4]);
  ListItem_c::~ListItem_c(&this->m_interiorGroups[3]);
  ListItem_c::~ListItem_c(&this->m_interiorGroups[2]);
  ListItem_c::~ListItem_c(&this->m_interiorGroups[1]);
  ListItem_c::~ListItem_c(this->m_interiorGroups);
  List_c::~List_c(&this->m_interiorPool);
  Interior_c::~Interior_c(&this->m_interiors[7]);
  Interior_c::~Interior_c(&this->m_interiors[6]);
  Interior_c::~Interior_c(&this->m_interiors[5]);
  Interior_c::~Interior_c(&this->m_interiors[4]);
  Interior_c::~Interior_c(&this->m_interiors[3]);
  Interior_c::~Interior_c(&this->m_interiors[2]);
  Interior_c::~Interior_c(&this->m_interiors[1]);
  sub_1A0558(this->m_interiors);
}

//----- (0044D080) --------------------------------------------------------
void __fastcall Interior_c::FurnishOffice(Interior_c *this)
{
  int8 RandomId; // r0
  CInteriorAttr *m_box; // r1
  CInteriorAttr *v4; // r1
  unsigned int m_width; // r0
  bool v6; // cf
  signed int v7; // r0
  int v8; // r11
  int v9; // r10
  int32 v10; // r1
  int32 v11; // r6
  int v12; // r8
  int32 formation; // [sp+10h] [bp-28h]
  unsigned int m_depth; // [sp+18h] [bp-20h]

  Interior_c::SetTilesStatus(this, 0, 0, 2, 2, 2, 0);
  Interior_c::SetTilesStatus(this, 0, this->m_box->m_depth - 2, 2, 2, 2, 0);
  Interior_c::SetTilesStatus(this, this->m_box->m_width - 2, 0, 2, 2, 2, 0);
  Interior_c::SetTilesStatus(this, this->m_box->m_width - 2, this->m_box->m_depth - 2, 2, 2, 2, 0);
  RandomId = FurnitureManager_c::GetRandomId(&g_furnitureMan, 1, 0, this->m_box->m_status);
  m_box = this->m_box;
  this->m_style = RandomId;
  this->m_style2 = FurnitureManager_c::GetRandomId(&g_furnitureMan, 1, 1, m_box->m_status);
  Interior_c::Office_FurnishEdges(this);
  v4 = this->m_box;
  m_width = v4->m_width;
  v6 = m_width >= 0xC;
  if ( m_width >= 0xC )
  {
    m_depth = v4->m_depth;
    v6 = m_depth >= 7;
  }
  if ( v6 )
  {
    v7 = m_width - 6;
    v8 = 0;
    v9 = v7 / 6;
    formation = v7 % 6 / 2 + 6;
    do
    {
      if ( m_depth >= 0xC )
      {
        v10 = formation;
        v11 = (int)(m_depth - 6) % 6 / 2 + 6;
        v12 = 0;
        do
        {
          Interior_c::Office_PlaceDeskQuad(this, v10, formation + 6 * v8, v11, this->m_style);
          ++v12;
          v11 += 6;
        }
        while ( v12 < (int)(m_depth - 6) / 6 );
      }
      ++v8;
    }
    while ( v8 < v9 );
  }
  sub_1972AC(this);
}
// 44D17C: variable 'm_depth' is possibly undefined
// 44D19A: variable 'v10' is possibly undefined

//----- (0044D1C4) --------------------------------------------------------
void __fastcall Interior_c::Office_FurnishEdges(Interior_c *this)
{
  CInteriorAttr *m_box; // r1
  unsigned int m_width; // r0
  unsigned int v4; // r10
  int v5; // r11
  int v6; // r6
  CInteriorAttr *v7; // r0
  unsigned int v8; // r11
  unsigned int v9; // r5
  int32 v10; // r1
  int32 v11; // r8
  int32 v12; // r5
  int32 v13; // r6
  int32 v14; // r6
  int32 v15; // r10
  int32 v16; // r6
  int32 v17; // r6
  int32 v18; // r6
  int32 v19; // r6
  int32 v20; // r6
  int32 v21; // r6
  unsigned int m_depth; // [sp+10h] [bp-28h]
  int32 x; // [sp+14h] [bp-24h]
  int32 y; // [sp+18h] [bp-20h]
  unsigned int ya; // [sp+18h] [bp-20h]

  m_box = this->m_box;
  m_width = m_box->m_width;
  m_depth = m_box->m_depth;
  x = m_width - 3;
  y = m_depth - 3;
  if ( m_width >= 5 )
  {
    v4 = m_width - 4;
    v5 = 0;
    do
    {
      Interior_c::SetTilesStatus(this, v5 + 2, y, 1, 1, 3, 0);
      Interior_c::SetTilesStatus(this, v5 + 2, 2, 1, 1, 3, 0);
      ++v5;
    }
    while ( v4 != v5 );
  }
  if ( m_depth >= 5 )
  {
    v6 = 0;
    do
    {
      Interior_c::SetTilesStatus(this, 2, v6 + 2, 1, 1, 3, 0);
      Interior_c::SetTilesStatus(this, x, v6 + 2, 1, 1, 3, 0);
      ++v6;
    }
    while ( m_depth - 4 != v6 );
  }
  Interior_c::AddGotoPt(this, 2, 2, 0.5, 0.5);
  Interior_c::AddGotoPt(this, 2, y, 0.5, -0.5);
  Interior_c::AddGotoPt(this, x, 2, -0.5, 0.5);
  Interior_c::AddGotoPt(this, x, y, -0.5, -0.5);
  v7 = this->m_box;
  v8 = v7->m_width;
  v9 = v7->m_depth;
  Interior_c::SetTilesStatus(this, v7->m_door - 2, 0, 4, 2, 7, 0);
  ya = v9;
  v11 = v9 - 1;
  v12 = v8 - 1;
  if ( v8 >= 3 )
  {
    v13 = 1;
    do
      v13 += Interior_c::Office_PlaceEdgeDesks(this, v10, v13, 0, 2, 2);
    while ( v13 < v12 );
    v14 = 1;
    do
      v14 += Interior_c::Office_PlaceEdgeDesks(this, v10, v14, v11, 0, 0);
    while ( v14 < v12 );
  }
  v15 = ya - 2;
  if ( ya >= 3 )
  {
    v16 = 1;
    do
      v16 += Interior_c::Office_PlaceEdgeDesks(this, v10, 0, v16, 1, 1);
    while ( v16 <= v15 );
    v17 = 1;
    do
      v17 += Interior_c::Office_PlaceEdgeDesks(this, v10, v8 - 1, v17, 3, 3);
    while ( v17 <= v15 );
  }
  if ( v8 >= 3 )
  {
    v18 = 1;
    do
      v18 += Interior_c::Office_PlaceEdgeFillers(this, -1, v18, 0, 2);
    while ( v18 < v12 );
    v19 = 1;
    do
      v19 += Interior_c::Office_PlaceEdgeFillers(this, -1, v19, v11, 0);
    while ( v19 < v12 );
  }
  if ( ya >= 3 )
  {
    v20 = 1;
    do
      v20 += Interior_c::Office_PlaceEdgeFillers(this, -1, 0, v20, 1);
    while ( v20 <= v15 );
    v21 = 1;
    do
      v21 += Interior_c::Office_PlaceEdgeFillers(this, -1, v8 - 1, v21, 3);
    while ( v21 <= v15 );
  }
}
// 44D314: conditional instruction was optimized away because r11.4 is in (3..FF)
// 44D358: conditional instruction was optimized away because %y.4 is in (3..FF)
// 44D39C: conditional instruction was optimized away because r11.4 is in (3..FF)
// 44D3E4: conditional instruction was optimized away because %y.4 is in (3..FF)
// 44D306: variable 'v10' is possibly undefined

//----- (0044D40C) --------------------------------------------------------
void __fastcall Interior_c::Office_FurnishCenter(Interior_c *this)
{
  CInteriorAttr *m_box; // r1
  unsigned int m_width; // r0
  bool v4; // cf
  signed int v5; // r0
  int v6; // r11
  int v7; // r10
  int32 v8; // r1
  int32 v9; // r6
  int v10; // r8
  int32 formation; // [sp+8h] [bp-28h]
  unsigned int m_depth; // [sp+10h] [bp-20h]

  m_box = this->m_box;
  m_width = m_box->m_width;
  v4 = m_width >= 0xC;
  if ( m_width >= 0xC )
  {
    m_depth = m_box->m_depth;
    v4 = m_depth >= 7;
  }
  if ( v4 )
  {
    v5 = m_width - 6;
    v6 = 0;
    v7 = v5 / 6;
    formation = v5 % 6 / 2 + 6;
    do
    {
      if ( m_depth >= 0xC )
      {
        v8 = formation;
        v9 = (int)(m_depth - 6) % 6 / 2 + 6;
        v10 = 0;
        do
        {
          Interior_c::Office_PlaceDeskQuad(this, v8, formation + 6 * v6, v9, this->m_style);
          ++v10;
          v9 += 6;
        }
        while ( v10 < (int)(m_depth - 6) / 6 );
      }
      ++v6;
    }
    while ( v6 < v7 );
  }
}
// 44D474: variable 'm_depth' is possibly undefined
// 44D492: variable 'v8' is possibly undefined

//----- (0044D4B0) --------------------------------------------------------
int32 __fastcall Interior_c::Office_PlaceEdgeDesks(Interior_c *this, int32 type, int32 x, int32 y, int a5, int a6)
{
  float v9; // s18
  float v10; // s0
  int v11; // r4
  int32 v12; // r3
  float v13; // s0
  int32 NumEmptyTiles; // r5
  unsigned __int16 v15; // r0
  int v16; // r5
  unsigned __int16 v17; // r0
  int v18; // r10
  int v19; // r1
  int v20; // r2
  int32 pedChance; // [sp+0h] [bp-50h]

  v9 = (float)(unsigned __int16)rand();
  v10 = (float)(unsigned __int16)rand();
  v11 = 1;
  v12 = 2;
  v13 = (float)(v10 * 0.000015259) * 40.0;
  if ( (a5 | 2) == 2 )
    v12 = 1;
  NumEmptyTiles = Interior_c::GetNumEmptyTiles(this, x, y, v12, 1);
  if ( NumEmptyTiles >= 2 )
  {
    v15 = rand();
    v16 = (unsigned int)NumEmptyTiles >> 1;
    if ( v16 >= (int)(float)((float)((float)v15 * 0.000015259) + (float)((float)v15 * 0.000015259)) + 2 )
    {
      v17 = rand();
      v16 = (int)(float)((float)((float)v17 * 0.000015259) + (float)((float)v17 * 0.000015259)) + 2;
    }
    if ( (int)v13 + 30 >= (int)(float)((float)(v9 * 0.000015259) * 100.0) )
    {
      if ( v16 < 1 )
      {
        v18 = 0;
      }
      else
      {
        v18 = 0;
        do
        {
          switch ( a6 )
          {
            case 0:
              v19 = v18 + x;
              v20 = y - 1;
              goto LABEL_15;
            case 1:
              v20 = v18 + y;
              v19 = x;
              goto LABEL_15;
            case 2:
              v19 = v18 + x;
              v20 = y;
              goto LABEL_15;
            case 3:
              v20 = v18 + y;
              v19 = x - 1;
LABEL_15:
              v18 += Interior_c::Office_PlaceDesk(this, v19, v20, (a5 + 2) & 3, pedChance, 0, this->m_style);
              break;
            default:
              break;
          }
          --v16;
        }
        while ( v16 );
      }
      return v18 + 1;
    }
    else
    {
      return 1;
    }
  }
  return v11;
}
// 44D5DA: variable 'pedChance' is possibly undefined

//----- (0044D60C) --------------------------------------------------------
int32 __fastcall Interior_c::Office_PlaceDesk(
        Interior_c *this,
        int32 tileX,
        int32 tileY,
        int32 dir,
        int32 pedChance,
        bool8 lShape,
        int32 type)
{
  int v11; // r4
  Furniture_c *Furniture; // r1
  int v13; // r11
  int v14; // r2
  int v15; // r3
  int32 v16; // r6
  int v17; // r10
  int32 v18; // r8
  int v19; // r4
  Furniture_c *v20; // r0
  CEntity *v21; // r0
  float v22; // s0
  float v23; // s2
  float v24; // s4
  float v25; // s4
  int32 x; // [sp+18h] [bp-30h]
  int v28; // [sp+1Ch] [bp-2Ch]
  Interior_c *v29; // [sp+20h] [bp-28h]
  int32 d; // [sp+24h] [bp-24h] BYREF
  int32 w[8]; // [sp+28h] [bp-20h] BYREF

  v11 = 1;
  Furniture = FurnitureManager_c::GetFurniture(&g_furnitureMan, 1, 0, type, this->m_box->m_status);
  v13 = tileX + 1;
  v28 = ((_BYTE)dir + 2) & 3;
  v14 = tileX;
  if ( dir == 1 )
    v14 = tileX + 1;
  v15 = tileY;
  v16 = tileX;
  if ( dir == 2 )
    v15 = tileY + 1;
  v17 = tileY + 1;
  v29 = this;
  if ( Interior_c::PlaceFurniture(this, Furniture, v14, v15, 0.0, 1, ((_BYTE)dir + 2) & 3, w, &d, 0) )
  {
    switch ( dir )
    {
      case 2:
        v18 = v13;
        v19 = tileY;
        v17 = tileY;
        break;
      case 0:
        v18 = v16;
        v19 = tileY + 1;
        x = v13;
        goto LABEL_16;
      case 3:
        v19 = tileY + 1;
        v18 = v13;
        x = v13;
        v17 = tileY;
        goto LABEL_16;
      default:
        v18 = v16;
        if ( dir != 1 )
          v17 = tileY;
        v19 = tileY;
        break;
    }
    x = v16;
LABEL_16:
    v20 = FurnitureManager_c::GetFurniture(&g_furnitureMan, 1, 1, v29->m_style2, v29->m_box->m_status);
    v21 = Interior_c::PlaceFurniture(v29, v20, v18, v19, 0.0, 1, v28, w, &d, 1);
    v22 = (float)v19;
    v23 = (float)v18;
    if ( (((_BYTE)dir + 2) & 3) != 0 )
    {
      if ( v28 == 1 )
      {
        v24 = 0.5;
        goto LABEL_22;
      }
      if ( v28 == 3 )
      {
        v24 = -0.5;
LABEL_22:
        v23 = v23 + v24;
LABEL_25:
        Interior_c::AddInteriorInfo(v29, 6, v23, v22, dir & 3, (int)v21);
        v11 = 2;
        Interior_c::SetTilesStatus(v29, x, v17, 1, 1, 2, 1);
        return v11;
      }
      v25 = 0.5;
    }
    else
    {
      v25 = -0.5;
    }
    v22 = v22 + v25;
    goto LABEL_25;
  }
  return v11;
}

//----- (0044D784) --------------------------------------------------------
int32 __fastcall Interior_c::Office_PlaceEdgeFillers(Interior_c *this, int32 type, int32 x, int32 y, int32 wall)
{
  int v9; // r5
  int v10; // r4
  float v11; // s0
  int32 v12; // r3
  int v13; // s18
  int32 v14; // r11
  int32 v15; // r4
  Furniture_c *v16; // r6
  unsigned __int16 v17; // r4
  Furniture_c *Furniture; // r0
  int v19; // s2
  Furniture_c *v20; // r4
  int32 v22; // [sp+18h] [bp-38h] BYREF
  int32 w[13]; // [sp+1Ch] [bp-34h] BYREF

  v9 = wall;
  v10 = 1;
  v11 = (float)(unsigned __int16)rand();
  v12 = 2;
  v13 = (int)(float)((float)(v11 * 0.000015259) * 100.0);
  if ( (wall | 2) == 2 )
    v12 = 1;
  if ( Interior_c::GetNumEmptyTiles(this, x, y, v12, 1) >= 1 )
  {
    v14 = x;
    v15 = y;
    switch ( wall )
    {
      case 0:
        v15 = y - 1;
        v14 = x;
        break;
      case 1:
        v14 = x + 1;
        goto LABEL_9;
      case 2:
        v15 = y + 1;
        v14 = x;
        break;
      case 3:
        v14 = x - 1;
LABEL_9:
        v15 = y;
        break;
      default:
        break;
    }
    if ( type == -1 )
    {
      if ( v13 < 91 || Interior_c::Office_PlaceEdgeFillers(int,int,int,int,int)::placedWater )
      {
        if ( v13 < 76 )
        {
          if ( v13 < 26 )
            return 1;
          Furniture = FurnitureManager_c::GetFurniture(&g_furnitureMan, 1, 3, -1, this->m_box->m_status);
          v16 = 0;
          if ( Furniture )
          {
            v19 = v15;
            v20 = Furniture;
            Interior_c::AddInteriorInfo(this, 7, (float)v14, (float)v19, (wall + 2) & 3, 0);
            v16 = v20;
          }
        }
        else
        {
          v17 = rand();
          v16 = FurnitureManager_c::GetFurniture(&g_furnitureMan, 8, 0, -1, this->m_box->m_status);
          v9 = (int)(float)((float)((float)v17 * 0.000015259) * 5.0);
        }
      }
      else
      {
        v16 = FurnitureManager_c::GetFurniture(&g_furnitureMan, 1, 2, -1, this->m_box->m_status);
        if ( v16 )
          Interior_c::AddInteriorInfo(this, 7, (float)v14, (float)v15, ((_BYTE)wall + 2) & 3, 0);
        Interior_c::Office_PlaceEdgeFillers(int,int,int,int,int)::placedWater = 1;
      }
    }
    else
    {
      v16 = FurnitureManager_c::GetFurniture(&g_furnitureMan, 1, type, -1, this->m_box->m_status);
    }
    Interior_c::PlaceFurniture(this, v16, x, y, 0.0, 1, v9, w, &v22, 0);
    return w[0];
  }
  return v10;
}
// 99D8EC: using guessed type char Interior_c::Office_PlaceEdgeFillers(int,int,int,int,int)::placedWater;
// 44D784: using guessed type int32 var_34[13];

//----- (0044D97C) --------------------------------------------------------
int32 __fastcall Interior_c::Office_PlaceDeskQuad(
        Interior_c *this,
        int32 formation,
        int32 tileX,
        int32 tileY,
        int32 type)
{
  int32 v6; // r8
  int32 v10; // [sp+0h] [bp-28h]
  int32 v11; // [sp+0h] [bp-28h]
  int32 v12; // [sp+0h] [bp-28h]
  int32 v13; // [sp+0h] [bp-28h]

  v6 = tileY - 2;
  Interior_c::Office_PlaceDesk(this, tileX, tileY - 2, 2, v10, 0, type);
  Interior_c::Office_PlaceDesk(this, tileX, tileY, 0, v11, 0, type);
  Interior_c::Office_PlaceDesk(this, tileX - 2, tileY, 0, v12, 0, type);
  Interior_c::Office_PlaceDesk(this, tileX - 2, v6, 2, v13, 0, type);
  Interior_c::SetTilesStatus(this, tileX - 3, tileY - 3, 6, 1, 3, 0);
  Interior_c::SetTilesStatus(this, tileX - 3, tileY + 2, 6, 1, 3, 0);
  Interior_c::SetTilesStatus(this, tileX - 3, v6, 1, 4, 3, 0);
  Interior_c::SetTilesStatus(this, tileX + 2, v6, 1, 4, 3, 0);
  return 6;
}
// 44D9A2: variable 'v10' is possibly undefined
// 44D9B2: variable 'v11' is possibly undefined
// 44D9C6: variable 'v12' is possibly undefined
// 44D9D6: variable 'v13' is possibly undefined

//----- (0044DA44) --------------------------------------------------------
void __fastcall Interior_c::FurnishShop(Interior_c *this, int32 subType)
{
  CInteriorAttr *m_box; // r0
  int m_door; // r1
  bool v5; // cc

  m_box = this->m_box;
  this->m_shopSubType = subType;
  m_door = m_box->m_door;
  v5 = m_door < 6;
  if ( m_door <= 6 )
    v5 = m_box->m_width - m_door < 6;
  if ( !v5 )
  {
    Interior_c::SetTilesStatus(this, 0, 0, 1, 1, 2, 0);
    Interior_c::SetTilesStatus(this, 0, this->m_box->m_depth - 1, 1, 1, 2, 0);
    Interior_c::SetTilesStatus(this, this->m_box->m_width - 1, 0, 1, 1, 2, 0);
    Interior_c::SetTilesStatus(this, this->m_box->m_width - 1, this->m_box->m_depth - 1, 1, 1, 2, 0);
    Interior_c::Shop_PlaceFixedUnits(this);
    Interior_c::Shop_FurnishEdges(this);
    Interior_c::Shop_FurnishAisles(this);
  }
}

//----- (0044DAE0) --------------------------------------------------------
void __fastcall Interior_c::Shop_PlaceFixedUnits(Interior_c *this)
{
  int m_door; // r0
  bool8 v3; // r5
  CInteriorAttr *m_box; // r0
  int v5; // r1
  bool v6; // cc
  int v7; // r0
  float v8; // s0
  bool v9; // cc

  m_door = this->m_box->m_door;
  if ( m_door != -1 )
  {
    v3 = 0;
    Interior_c::SetTilesStatus(this, m_door - 1, 0, 2, 1, 7, 0);
    m_box = this->m_box;
    v5 = m_box->m_door;
    v6 = v5 < 8;
    v7 = m_box->m_width - v5;
    if ( v5 >= 8 )
      v6 = v7 < 8;
    if ( v6 )
    {
      if ( v7 < 8 )
        v3 = 1;
      v9 = v5 < 7;
      if ( v5 <= 7 )
        v9 = v7 < 8;
      if ( v9 )
      {
        v8 = 0.0;
        goto LABEL_14;
      }
    }
    else
    {
      v3 = rand() & 1;
    }
    v8 = (float)Interior_c::Shop_PlaceCounter(this, v3);
LABEL_14:
    Interior_c::AddInteriorInfo(this, 9, v8, 2.0, 0, 0);
    Interior_c::AddInteriorInfo(this, 10, v8, 0.0, 2, 0);
  }
}

//----- (0044DB84) --------------------------------------------------------
void __fastcall Interior_c::Shop_FurnishEdges(Interior_c *this)
{
  CInteriorAttr *m_box; // r0
  unsigned int m_depth; // r11
  int v4; // r0
  int32 v5; // r9
  int32 v6; // r8
  int32 v7; // r6
  int v8; // r0
  int32 v9; // r9
  int v10; // r6
  int32 v11; // r5
  int v12; // r0
  int32 v13; // r9
  int32 v14; // r5
  int v15; // r5
  float v16; // s0
  int32 v17; // r6
  CInteriorAttr *v18; // r0
  int32 m_tDoorStart; // r1
  int32 v20; // r8
  int v21; // r6
  float v22; // s20
  CInteriorAttr *v23; // r0
  int v24; // r8
  int m_lDoorStart; // r1
  int32 v26; // r9
  int m_rDoorStart; // r1
  int32 v28; // r5
  int v29; // r10
  int v30; // r8
  unsigned int m_width; // [sp+10h] [bp-40h]

  m_box = this->m_box;
  m_width = m_box->m_width;
  m_depth = m_box->m_depth;
  v4 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0);
  if ( v4 <= 50 )
  {
    if ( v4 <= 25 )
    {
      v5 = 9;
      if ( v4 > 10 )
        v5 = 6;
    }
    else
    {
      v5 = 3;
    }
  }
  else
  {
    v5 = 0;
  }
  v6 = m_width - 1;
  if ( m_width >= 3 )
  {
    v7 = 1;
    do
      v7 += Interior_c::Shop_PlaceEdgeUnits(this, v5, v7, m_depth - 1, 0);
    while ( v7 < v6 );
  }
  v8 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0);
  if ( v8 <= 50 )
  {
    if ( v8 <= 25 )
    {
      v9 = 9;
      if ( v8 > 10 )
        v9 = 6;
    }
    else
    {
      v9 = 3;
    }
  }
  else
  {
    v9 = 0;
  }
  v10 = m_depth - 2;
  if ( m_depth >= 3 )
  {
    v11 = 1;
    do
      v11 += Interior_c::Shop_PlaceEdgeUnits(this, v9, 0, v11, 1);
    while ( v11 <= v10 );
  }
  v12 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0);
  if ( v12 <= 50 )
  {
    if ( v12 <= 25 )
    {
      v13 = 9;
      if ( v12 > 10 )
        v13 = 6;
    }
    else
    {
      v13 = 3;
    }
  }
  else
  {
    v13 = 0;
  }
  if ( m_depth >= 3 )
  {
    v14 = 1;
    do
      v14 += Interior_c::Shop_PlaceEdgeUnits(this, v13, v6, v14, 3);
    while ( v14 <= v10 );
  }
  v15 = m_width - 2;
  if ( m_width >= 3 )
  {
    v16 = (float)v10;
    v17 = 0;
    do
    {
      v18 = this->m_box;
      ++v17;
      m_tDoorStart = v18->m_tDoorStart;
      if ( m_tDoorStart == -1 || v17 < m_tDoorStart || v17 > v18->m_tDoorEnd )
      {
        v20 = Interior_c::Shop_AddShelfInfo(int,int,int)::lastPlacement;
        if ( Interior_c::Shop_AddShelfInfo(int,int,int)::lastPlacement >= 2 )
        {
          if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) <= 60 )
          {
            v20 = Interior_c::Shop_AddShelfInfo(int,int,int)::lastPlacement;
          }
          else
          {
            v20 = 0;
            Interior_c::AddInteriorInfo(this, 8, (float)v17, v16, 2, 0);
            Interior_c::Shop_AddShelfInfo(int,int,int)::lastPlacement = 0;
          }
        }
        Interior_c::Shop_AddShelfInfo(int,int,int)::lastPlacement = v20 + 1;
      }
      if ( !Interior_c::GetTileStatus(this, v17, 1) )
        Interior_c::SetTilesStatus(this, v17, 1, 1, 1, 2, 0);
    }
    while ( v15 != v17 );
  }
  if ( m_depth >= 5 )
  {
    v21 = 0;
    v22 = (float)v15;
    do
    {
      v23 = this->m_box;
      v24 = v21 + 2;
      m_lDoorStart = v23->m_lDoorStart;
      if ( m_lDoorStart == -1 || v24 < m_lDoorStart || v24 > v23->m_lDoorEnd )
      {
        v26 = Interior_c::Shop_AddShelfInfo(int,int,int)::lastPlacement;
        if ( Interior_c::Shop_AddShelfInfo(int,int,int)::lastPlacement >= 2 )
        {
          if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) <= 60 )
          {
            v26 = Interior_c::Shop_AddShelfInfo(int,int,int)::lastPlacement;
          }
          else
          {
            v26 = 0;
            Interior_c::AddInteriorInfo(this, 8, 1.0, (float)v24, 3, 0);
            Interior_c::Shop_AddShelfInfo(int,int,int)::lastPlacement = 0;
          }
        }
        Interior_c::Shop_AddShelfInfo(int,int,int)::lastPlacement = v26 + 1;
        v23 = this->m_box;
      }
      m_rDoorStart = v23->m_rDoorStart;
      if ( m_rDoorStart == -1 || v24 < m_rDoorStart || v24 > v23->m_rDoorEnd )
      {
        v28 = Interior_c::Shop_AddShelfInfo(int,int,int)::lastPlacement;
        if ( Interior_c::Shop_AddShelfInfo(int,int,int)::lastPlacement >= 2 )
        {
          if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) <= 60 )
          {
            v28 = Interior_c::Shop_AddShelfInfo(int,int,int)::lastPlacement;
          }
          else
          {
            v28 = 0;
            Interior_c::AddInteriorInfo(this, 8, v22, (float)v24, 1, 0);
            Interior_c::Shop_AddShelfInfo(int,int,int)::lastPlacement = 0;
          }
        }
        Interior_c::Shop_AddShelfInfo(int,int,int)::lastPlacement = v28 + 1;
      }
      ++v21;
    }
    while ( m_depth - 4 != v21 );
  }
  if ( m_width >= 5 )
  {
    v29 = 0;
    do
    {
      if ( !Interior_c::GetTileStatus(this, v29 + 2, 2) )
        Interior_c::SetTilesStatus(this, v29 + 2, 2, 1, 1, 2, 0);
      Interior_c::SetTilesStatus(this, v29 + 2, m_depth - 3, 1, 1, 3, 0);
      ++v29;
    }
    while ( m_width - 4 != v29 );
  }
  if ( m_depth >= 7 )
  {
    v30 = 0;
    do
    {
      Interior_c::SetTilesStatus(this, 2, v30 + 3, 1, 1, 3, 0);
      Interior_c::SetTilesStatus(this, m_width - 3, v30 + 3, 1, 1, 3, 0);
      ++v30;
    }
    while ( m_depth - 6 != v30 );
  }
  Interior_c::SetTilesStatus(this, 3, 3, m_width - 6, 1, 3, 0);
}

//----- (0044DFDC) --------------------------------------------------------
void __fastcall Interior_c::Shop_FurnishAisles(Interior_c *this)
{
  unsigned int m_depth; // r5
  CInteriorAttr *m_box; // r0
  unsigned int m_width; // r4
  bool v5; // cf
  int32 v6; // r9
  int v7; // r0
  int v8; // r8
  int v9; // r0
  int32 v10; // r6
  int v11; // r5
  int32 v12; // r4
  int v13; // r11
  int32 v14; // r4
  int v15; // r4
  int v16; // r5
  unsigned int v17; // [sp+Ch] [bp-54h]
  int v18; // [sp+10h] [bp-50h]
  unsigned int v19; // [sp+14h] [bp-4Ch]
  int32 tileY; // [sp+18h] [bp-48h]
  unsigned int v21; // [sp+1Ch] [bp-44h]
  unsigned int v22; // [sp+20h] [bp-40h]
  int dir; // [sp+24h] [bp-3Ch]

  m_box = this->m_box;
  m_width = m_box->m_width;
  v5 = m_width >= 7;
  if ( m_width >= 7 )
  {
    m_depth = m_box->m_depth;
    v5 = m_depth >= 8;
  }
  if ( v5 )
  {
    v6 = 3;
    Interior_c::AddGotoPt(this, 2, 3, -0.5, -0.5);
    tileY = m_depth - 3;
    Interior_c::AddGotoPt(this, 2, m_depth - 3, -0.5, 0.5);
    if ( m_width >= 7 )
    {
      dir = m_depth - 7;
      v22 = m_width - 6;
      v19 = m_width - 7;
      v7 = 0;
      v8 = 0;
      v17 = m_width;
      v21 = m_depth;
      if ( m_depth < 8 )
        v7 = 1;
      v18 = v7;
      do
      {
        v9 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0);
        if ( v9 <= 50 )
        {
          if ( v9 <= 25 )
          {
            v10 = 9;
            if ( v9 > 10 )
              v10 = 6;
          }
          else
          {
            v10 = 3;
          }
        }
        else
        {
          v10 = 0;
        }
        switch ( v8 % 4 )
        {
          case 0:
            if ( !((v8 == v19) | v18) )
            {
              v11 = dir;
              v12 = 4;
              do
              {
                v12 += Interior_c::Shop_PlaceEdgeUnits(this, v10, v8 + 3, v12, 3);
                --v11;
              }
              while ( v11 );
            }
            break;
          case 1:
            if ( v21 >= 8 )
            {
              v13 = dir;
              v14 = 4;
              do
              {
                v14 += Interior_c::Shop_PlaceEdgeUnits(this, v10, v8 + 3, v14, 1);
                --v13;
              }
              while ( v13 );
            }
            break;
          case 2:
            if ( v21 >= 8 )
            {
              v15 = 0;
              v16 = Interior_c::Shop_AddShelfInfo(int,int,int)::lastPlacement;
              do
              {
                if ( v16 >= 2 )
                {
                  if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) <= 60 )
                  {
                    v16 = Interior_c::Shop_AddShelfInfo(int,int,int)::lastPlacement;
                  }
                  else
                  {
                    v16 = 0;
                    Interior_c::AddInteriorInfo(this, 8, (float)(v8 + 3), (float)(v15 + 4), 3, 0);
                    Interior_c::Shop_AddShelfInfo(int,int,int)::lastPlacement = 0;
                  }
                }
                ++v16;
                ++v15;
                Interior_c::Shop_AddShelfInfo(int,int,int)::lastPlacement = v16;
              }
              while ( dir != v15 );
            }
            break;
          case 3:
            Interior_c::SetTilesStatus(this, v8 + 3, 4, 1, dir, 3, 0);
            Interior_c::AddGotoPt(this, v8 + 3, 3, -0.5, -0.5);
            Interior_c::AddGotoPt(this, v8 + 3, tileY, -0.5, 0.5);
            break;
          default:
            break;
        }
        ++v8;
      }
      while ( v8 != v22 );
      v6 = v17 - 3;
    }
    Interior_c::AddGotoPt(this, v6, 3, 0.5, -0.5);
    Interior_c::AddGotoPt(this, v6, tileY, 0.5, 0.5);
  }
}
// 44E028: variable 'm_depth' is possibly undefined

//----- (0044E238) --------------------------------------------------------
int __fastcall Interior_c::Shop_Place3PieceUnit(Interior_c *this, int32 type, int32 x, int32 y, int32 a5, int a6)
{
  int32 m_shopSubType; // r1
  Furniture_c *Furniture; // r6
  CInteriorAttr *m_box; // r0
  int16 m_refId; // r3
  int v14; // r2
  Furniture_c *v15; // r10
  int32 v16; // r6
  int v17; // r4
  int32 v18; // r2
  int32 v19; // r6
  int v20; // r4
  int32 v21; // r5
  int32 v22; // r8
  Furniture_c *pFurn; // [sp+18h] [bp-28h]
  int32 v25; // [sp+1Ch] [bp-24h] BYREF
  int32 v26[8]; // [sp+20h] [bp-20h] BYREF

  m_shopSubType = this->m_shopSubType;
  if ( (a5 | 1) == 3 )
  {
    Furniture = FurnitureManager_c::GetFurniture(&g_furnitureMan, m_shopSubType, type + 1, -1, this->m_box->m_status);
    m_box = this->m_box;
    m_refId = Furniture->m_refId;
    v14 = type;
  }
  else
  {
    Furniture = FurnitureManager_c::GetFurniture(&g_furnitureMan, m_shopSubType, type, -1, this->m_box->m_status);
    m_box = this->m_box;
    m_refId = Furniture->m_refId;
    v14 = type + 1;
  }
  pFurn = FurnitureManager_c::GetFurniture(&g_furnitureMan, this->m_shopSubType, v14, m_refId, m_box->m_status);
  v15 = FurnitureManager_c::GetFurniture(
          &g_furnitureMan,
          this->m_shopSubType,
          type + 2,
          Furniture->m_refId,
          this->m_box->m_status);
  Interior_c::PlaceFurniture(this, Furniture, x, y, 0.0, 1, a5, v26, &v25, 0);
  if ( (a5 | 2) == 2 )
  {
    v16 = v26[0] + x;
    if ( a6 >= 3 )
    {
      v17 = a6 - 2;
      do
      {
        Interior_c::PlaceFurniture(this, v15, v16, y, 0.0, 1, a5, v26, &v25, 0);
        --v17;
        v16 += v26[0];
      }
      while ( v17 );
    }
    Interior_c::PlaceFurniture(this, pFurn, v16, y, 0.0, 1, a5, v26, &v25, 0);
  }
  else
  {
    v18 = x;
    v19 = v25 + y;
    if ( a6 < 3 )
    {
      v21 = a5;
      v22 = x;
    }
    else
    {
      v20 = a6 - 2;
      v21 = a5;
      v22 = v18;
      do
      {
        Interior_c::PlaceFurniture(this, v15, v22, v19, 0.0, 1, a5, v26, &v25, 0);
        --v20;
        v19 += v25;
      }
      while ( v20 );
    }
    Interior_c::PlaceFurniture(this, pFurn, v22, v19, 0.0, 1, v21, v26, &v25, 0);
  }
  return 1;
}

//----- (0044E3D8) --------------------------------------------------------
int32 __fastcall Interior_c::Shop_PlaceEdgeUnits(Interior_c *this, int32 type, int32 x, int32 y, int32 a5)
{
  int v8; // r5
  int32 v9; // r3
  int NumEmptyTiles; // r4
  int v12; // s0
  int v13; // r0
  int v14; // r2
  int32 v15; // r1

  v8 = 1;
  v9 = 2;
  if ( (a5 | 2) == 2 )
    v9 = 1;
  NumEmptyTiles = Interior_c::GetNumEmptyTiles(this, x, y, v9, 1);
  if ( NumEmptyTiles >= 2 )
  {
    v12 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 3.0);
    if ( NumEmptyTiles == 3 )
    {
      NumEmptyTiles = 3;
    }
    else
    {
      v13 = v12 + 2;
      v14 = NumEmptyTiles - (v12 + 2);
      if ( v14 >= 0 )
      {
        if ( v14 == 1 )
          v13 = v12 + 1;
        NumEmptyTiles = v13;
      }
    }
    if ( type == -1 )
      v15 = 9;
    else
      v15 = type;
    Interior_c::Shop_Place3PieceUnit(this, v15, x, y, a5, NumEmptyTiles);
    return NumEmptyTiles;
  }
  return v8;
}

//----- (0044E478) --------------------------------------------------------
int32 __fastcall Interior_c::Shop_PlaceCounter(Interior_c *this, bool8 onLeft)
{
  int v3; // r5
  Furniture_c *Furniture; // r9
  float v5; // s0
  int m_door; // r6
  int v7; // r0
  Furniture_c *pFurn; // [sp+18h] [bp-28h]
  int32 d; // [sp+1Ch] [bp-24h] BYREF
  int32 v11[8]; // [sp+20h] [bp-20h] BYREF

  v3 = onLeft;
  Furniture = FurnitureManager_c::GetFurniture(&g_furnitureMan, 0, 12, -1, this->m_box->m_status);
  pFurn = FurnitureManager_c::GetFurniture(&g_furnitureMan, 0, 13, -1, this->m_box->m_status);
  v5 = (float)(unsigned __int16)rand();
  m_door = this->m_box->m_door;
  if ( v3 )
  {
    Interior_c::PlaceFurniture(this, Furniture, m_door - 5, 1, 0.0, 1, 0, v11, &d, 0);
    Interior_c::SetTilesStatus(this, m_door - 6, 0, v11[0] + 1, 1, 2, 0);
    Interior_c::PlaceFurniture(
      this,
      pFurn,
      this->m_box->m_door + 1,
      0,
      0.0,
      1,
      (int)(float)((float)(v5 * 0.000015259) * 4.0),
      v11,
      &d,
      1);
    v7 = -3;
  }
  else
  {
    Interior_c::PlaceFurniture(this, Furniture, m_door + 2, 1, 0.0, 1, 0, v11, &d, 0);
    Interior_c::SetTilesStatus(this, m_door + 2, 0, v11[0] + 1, 1, 2, 0);
    Interior_c::PlaceFurniture(
      this,
      pFurn,
      this->m_box->m_door - 2,
      0,
      0.0,
      1,
      (int)(float)((float)(v5 * 0.000015259) * 4.0),
      v11,
      &d,
      1);
    v7 = 4;
  }
  return v7 + m_door;
}

//----- (0044E5BC) --------------------------------------------------------
int32 __fastcall Interior_c::Shop_GetRandomUnitType(Interior_c *this)
{
  int v1; // r1
  int32 result; // r0

  v1 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0);
  if ( v1 > 50 )
    return 0;
  if ( v1 > 25 )
    return 3;
  result = 9;
  if ( v1 > 10 )
    return 6;
  return result;
}

//----- (0044E608) --------------------------------------------------------
void __fastcall Interior_c::Shop_AddShelfInfo(Interior_c *this, int32 tileX, int32 tileY, int32 dir)
{
  int32 v8; // r5

  v8 = Interior_c::Shop_AddShelfInfo(int,int,int)::lastPlacement;
  if ( Interior_c::Shop_AddShelfInfo(int,int,int)::lastPlacement >= 2 )
  {
    if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) <= 60 )
    {
      v8 = Interior_c::Shop_AddShelfInfo(int,int,int)::lastPlacement;
    }
    else
    {
      v8 = 0;
      Interior_c::AddInteriorInfo(this, 8, (float)tileX, (float)tileY, dir, 0);
      Interior_c::Shop_AddShelfInfo(int,int,int)::lastPlacement = 0;
    }
  }
  Interior_c::Shop_AddShelfInfo(int,int,int)::lastPlacement = v8 + 1;
}

//----- (0044E6AC) --------------------------------------------------------
void __fastcall CMatrix::ConvertToEulerAngles(CMatrix *this, float *x, float *y, float *z, int32 order)
{
  float yx; // r2
  float zx; // r3
  int v7; // r4
  unsigned int v8; // r10
  __int64 v9; // kr00_8
  float zz; // r0
  int v11; // r11
  int v12; // r8
  _DWORD *v13; // r0
  float v14; // s16
  float v15; // s18
  float v16; // s20
  _DWORD *v17; // r6
  float *v18; // r5
  float v19; // r0
  float *v20; // r6
  float v21; // r1
  float v22; // r0
  _DWORD *v23; // r9
  float v24; // s16
  float v25; // s0
  float v26; // r0
  float v27; // r1
  float v28; // r0
  float v29; // r0
  _DWORD v33[6]; // [sp+Ch] [bp-5Ch] BYREF
  __int64 v34; // [sp+24h] [bp-44h]
  float v35; // [sp+2Ch] [bp-3Ch]

  yx = this->yx;
  zx = this->zx;
  v33[0] = LODWORD(this->xx);
  *(float *)&v33[1] = yx;
  *(float *)&v33[2] = zx;
  v33[3] = LODWORD(this->xy);
  v33[4] = LODWORD(this->yy);
  v7 = byte_618D1A[((unsigned int)order >> 3) & 3];
  v33[5] = LODWORD(this->zy);
  v8 = ((unsigned int)order >> 2) & 1;
  v9 = *(_QWORD *)&this->xz;
  zz = this->zz;
  v11 = byte_618D1F[((order & 4) == 0) + v7];
  v34 = v9;
  v12 = byte_618D1F[v8 + v7];
  v35 = zz;
  if ( (order & 2) != 0 )
  {
    v23 = &v33[3 * v7];
    v24 = sqrtf((float)(*(float *)&v23[v12] * *(float *)&v23[v12]) + (float)(*(float *)&v23[v11] * *(float *)&v23[v11]));
    if ( v24 > 0.0000019073 )
    {
      v18 = x;
      *x = atan2f(*(float *)&v23[v12], *(float *)&v23[v11]);
      v20 = y;
      *y = atan2f(v24, *(float *)&v23[v7]);
      v22 = *(float *)&v33[3 * v12 + v7];
      LODWORD(v21) = v33[3 * v11 + v7] ^ 0x80000000;
      goto LABEL_6;
    }
    v18 = x;
    *x = atan2f(COERCE_FLOAT(v33[3 * v12 + v11] ^ 0x80000000), *(float *)&v33[3 * v12 + v12]);
    v27 = *(float *)&v23[v7];
    v28 = v24;
  }
  else
  {
    v13 = &v33[3 * v12];
    v14 = *(float *)&v13[v7];
    v15 = *(float *)&v33[3 * v7 + v7];
    v16 = sqrtf((float)(v15 * v15) + (float)(v14 * v14));
    if ( v16 > 0.0000019073 )
    {
      v17 = &v33[3 * v11];
      v18 = x;
      *x = atan2f(*(float *)&v17[v12], *(float *)&v17[v11]);
      v19 = atan2f(COERCE_FLOAT(v17[v7] ^ 0x80000000), v16);
      v20 = y;
      v21 = v15;
      *y = v19;
      v22 = v14;
LABEL_6:
      v25 = atan2f(v22, v21);
      goto LABEL_10;
    }
    v26 = atan2f(COERCE_FLOAT(v13[v11] ^ 0x80000000), *(float *)&v13[v12]);
    v27 = v16;
    v18 = x;
    *x = v26;
    LODWORD(v28) = v33[3 * v11 + v7] ^ 0x80000000;
  }
  v20 = y;
  v25 = 0.0;
  *y = atan2f(v28, v27);
LABEL_10:
  *z = v25;
  if ( v8 )
  {
    *v18 = -*v18;
    *v20 = -*v20;
    v25 = -*z;
    *z = v25;
  }
  if ( (order & 1) != 0 )
  {
    v29 = *v18;
    *v18 = v25;
    *z = v29;
  }
}
// 618D1A: using guessed type unsigned __int8 byte_618D1A[5];
// 618D1F: using guessed type unsigned __int8 byte_618D1F[5];

//----- (0044E8C8) --------------------------------------------------------
void __fastcall CMatrix::ConvertFromEulerAngles(CMatrix *this, float z, float y, float x, int32 order)
{
  float v5; // s18
  float v6; // s16
  float v7; // s0
  unsigned int v8; // r3
  int v10; // r10
  int v11; // r11
  float v12; // r8
  float v13; // r4
  float v14; // r5
  float v15; // r6
  float v16; // s16
  float v17; // s28
  float v18; // s22
  float v19; // s18
  float v20; // s24
  float v21; // s20
  float v22; // r4
  float v23; // s1
  float v24; // s4
  float v25; // s0
  float v26; // s2
  float v27; // s12
  float v28; // s14
  float v29; // s10
  float v30; // s6
  float v31; // s8
  float v32; // s3
  _DWORD *v33; // r1
  _DWORD *v34; // r1
  _DWORD *v35; // r0
  float v36; // r1
  float v37; // r2
  float v38; // r1
  float v39; // r2
  float v40; // r1
  float v41; // r2
  int v42; // [sp+8h] [bp-88h]
  _DWORD v43[33]; // [sp+Ch] [bp-84h] BYREF

  v5 = z;
  v6 = y;
  v7 = x;
  if ( (order & 1) == 0 )
  {
    v7 = z;
    v5 = x;
  }
  v8 = ((unsigned int)order >> 2) & 1;
  v10 = byte_618D1A[((unsigned int)order >> 3) & 3];
  if ( v8 )
  {
    v5 = -v5;
    v6 = -y;
    v7 = -v7;
  }
  v11 = byte_618D1F[v8 + v10];
  v42 = byte_618D1F[((order & 4) == 0) + v10];
  v12 = cosf(v7);
  v13 = cosf(v5);
  v14 = sinf(v7);
  v15 = v6;
  v16 = sinf(v5);
  v17 = v13;
  v18 = v14 * v16;
  v19 = v13 * v14;
  v20 = v12 * v16;
  v21 = v12 * v13;
  v22 = cosf(v15);
  v23 = sinf(v15);
  v24 = v22;
  if ( (order & 2) != 0 )
  {
    v32 = v17 * v23;
    v27 = -(float)(v22 * v20);
    v28 = -(float)(v22 * v18);
    v29 = v22;
    v30 = v12 * v23;
    v31 = v14 * v23;
    v25 = (float)(v22 * v21) - v18;
    v26 = (float)(v22 * v19) + v20;
    v24 = v23;
  }
  else
  {
    v25 = v12 * v22;
    v26 = v22 * v14;
    v27 = v23 * v20;
    v28 = v23 * v18;
    v29 = v22 * v17;
    v30 = (float)(v21 * v23) + v18;
    v31 = (float)(v23 * v19) - v20;
    v32 = v23;
  }
  v33 = &v43[3 * v10];
  *(float *)&v33[v10] = v29;
  *(float *)&v33[v11] = v31;
  *(float *)&v33[v42] = v30;
  v34 = &v43[3 * v11];
  *(float *)&v34[v10] = v24 * v16;
  *(float *)&v34[v11] = v21 + v28;
  *(float *)&v34[v42] = v27 - v19;
  v35 = &v43[3 * v42];
  *(float *)&v35[v10] = -v32;
  *(float *)&v35[v11] = v26;
  *(float *)&v35[v42] = v25;
  v36 = *(float *)&v43[1];
  v37 = *(float *)&v43[2];
  LODWORD(this->xx) = v43[0];
  this->yx = v36;
  this->zx = v37;
  v38 = *(float *)&v43[4];
  v39 = *(float *)&v43[5];
  LODWORD(this->xy) = v43[3];
  this->yy = v38;
  this->zy = v39;
  v40 = *(float *)&v43[7];
  v41 = *(float *)&v43[8];
  LODWORD(this->xz) = v43[6];
  this->yz = v40;
  this->zz = v41;
}
// 618D1A: using guessed type unsigned __int8 byte_618D1A[5];
// 618D1F: using guessed type unsigned __int8 byte_618D1F[5];

//----- (0044EA98) --------------------------------------------------------
void CMaths::InitMathsTables()
{
  int v0; // r5
  float *v1; // r4
  float v2; // r0

  v0 = 0;
  v1 = CMaths::ms_SinTable;
  do
  {
    v2 = sinf((float)v0++ * 0.024544);
    *v1++ = v2;
  }
  while ( v0 != 256 );
}

//----- (0044EADC) --------------------------------------------------------
void __fastcall CMatrix::CMatrix(CMatrix *this, const CMatrix *m)
{
  float *p_xz; // r3
  const CMatrix *v3; // r2
  float *p_tx; // r1
  __int64 v5; // d16
  __int64 v6; // d17
  __int64 v7; // d21
  __int64 v8; // d18
  __int64 v9; // d19
  __int64 v10; // d22
  __int64 v11; // d23

  p_xz = &m->xz;
  this->m_pRwMat = 0;
  this->m_owner = 0;
  v3 = m;
  p_tx = &m->tx;
  v5 = *(_QWORD *)&v3->xx;
  v6 = *(_QWORD *)&v3->zx;
  v3 = (const CMatrix *)((char *)v3 + 16);
  v7 = *((_QWORD *)p_tx + 1);
  v8 = *(_QWORD *)p_xz;
  v9 = *((_QWORD *)p_xz + 1);
  v10 = *(_QWORD *)&v3->xx;
  v11 = *(_QWORD *)&v3->zx;
  *(_QWORD *)&this->tx = *(_QWORD *)p_tx;
  *(_QWORD *)&this->tz = v7;
  *(_QWORD *)&this->xz = v8;
  *(_QWORD *)&this->zz = v9;
  *(_QWORD *)&this->xx = v5;
  *(_QWORD *)&this->zx = v6;
  *(_QWORD *)&this->xy = v10;
  *(_QWORD *)&this->zy = v11;
}

//----- (0044EB16) --------------------------------------------------------
CMatrix *__fastcall CMatrix::operator=(CMatrix *this, const CMatrix *m)
{
  __int64 v3; // d16
  __int64 v4; // d17
  __int64 v5; // d18
  __int64 v6; // d19
  float *p_xz; // r0
  float *p_tx; // r1
  __int64 v9; // d23
  __int64 v10; // d20
  __int64 v11; // d21
  RwMatrix *m_pRwMat; // r0

  v3 = *(_QWORD *)&m->xx;
  v4 = *(_QWORD *)&m->zx;
  v5 = *(_QWORD *)&m->xy;
  v6 = *(_QWORD *)&m->zy;
  p_xz = &m->xz;
  p_tx = &m->tx;
  v9 = *((_QWORD *)p_tx + 1);
  v10 = *(_QWORD *)p_xz;
  v11 = *((_QWORD *)p_xz + 1);
  m_pRwMat = this->m_pRwMat;
  *(_QWORD *)&this->tx = *(_QWORD *)p_tx;
  *(_QWORD *)&this->tz = v9;
  *(_QWORD *)&this->xz = v10;
  *(_QWORD *)&this->zz = v11;
  *(_QWORD *)&this->xx = v3;
  *(_QWORD *)&this->zx = v4;
  *(_QWORD *)&this->xy = v5;
  *(_QWORD *)&this->zy = v6;
  if ( m_pRwMat )
  {
    m_pRwMat->right.x = this->xx;
    m_pRwMat->right.y = this->yx;
    m_pRwMat->right.z = this->zx;
    m_pRwMat->up.x = this->xy;
    m_pRwMat->up.y = this->yy;
    m_pRwMat->up.z = this->zy;
    m_pRwMat->at.x = this->xz;
    m_pRwMat->at.y = this->yz;
    m_pRwMat->at.z = this->zz;
    m_pRwMat->pos.x = this->tx;
    m_pRwMat->pos.y = this->ty;
    m_pRwMat->pos.z = this->tz;
    RwMatrixUpdate(m_pRwMat);
  }
  return this;
}

//----- (0044EB8C) --------------------------------------------------------
void __fastcall CMatrix::CMatrix(CMatrix *this, const CMatrixSerialize *m)
{
  float *p_xz; // r3
  const CMatrixSerialize *v3; // r2
  float *p_tx; // r1
  __int64 v5; // d16
  __int64 v6; // d17
  __int64 v7; // d21
  __int64 v8; // d18
  __int64 v9; // d19
  __int64 v10; // d22
  __int64 v11; // d23

  p_xz = &m->xz;
  this->m_pRwMat = 0;
  this->m_owner = 0;
  v3 = m;
  p_tx = &m->tx;
  v5 = *(_QWORD *)&v3->xx;
  v6 = *(_QWORD *)&v3->zx;
  v3 = (const CMatrixSerialize *)((char *)v3 + 16);
  v7 = *((_QWORD *)p_tx + 1);
  v8 = *(_QWORD *)p_xz;
  v9 = *((_QWORD *)p_xz + 1);
  v10 = *(_QWORD *)&v3->xx;
  v11 = *(_QWORD *)&v3->zx;
  *(_QWORD *)&this->tx = *(_QWORD *)p_tx;
  *(_QWORD *)&this->tz = v7;
  *(_QWORD *)&this->xz = v8;
  *(_QWORD *)&this->zz = v9;
  *(_QWORD *)&this->xx = v5;
  *(_QWORD *)&this->zx = v6;
  *(_QWORD *)&this->xy = v10;
  *(_QWORD *)&this->zy = v11;
}

//----- (0044EBC6) --------------------------------------------------------
CMatrix *__fastcall CMatrix::operator=(CMatrix *this, const CMatrixSerialize *m)
{
  __int64 v3; // d16
  __int64 v4; // d17
  __int64 v5; // d18
  __int64 v6; // d19
  float *p_xz; // r0
  float *p_tx; // r1
  __int64 v9; // d23
  __int64 v10; // d20
  __int64 v11; // d21
  RwMatrix *m_pRwMat; // r0

  v3 = *(_QWORD *)&m->xx;
  v4 = *(_QWORD *)&m->zx;
  v5 = *(_QWORD *)&m->xy;
  v6 = *(_QWORD *)&m->zy;
  p_xz = &m->xz;
  p_tx = &m->tx;
  v9 = *((_QWORD *)p_tx + 1);
  v10 = *(_QWORD *)p_xz;
  v11 = *((_QWORD *)p_xz + 1);
  m_pRwMat = this->m_pRwMat;
  *(_QWORD *)&this->tx = *(_QWORD *)p_tx;
  *(_QWORD *)&this->tz = v9;
  *(_QWORD *)&this->xz = v10;
  *(_QWORD *)&this->zz = v11;
  *(_QWORD *)&this->xx = v3;
  *(_QWORD *)&this->zx = v4;
  *(_QWORD *)&this->xy = v5;
  *(_QWORD *)&this->zy = v6;
  if ( m_pRwMat )
  {
    m_pRwMat->right.x = this->xx;
    m_pRwMat->right.y = this->yx;
    m_pRwMat->right.z = this->zx;
    m_pRwMat->up.x = this->xy;
    m_pRwMat->up.y = this->yy;
    m_pRwMat->up.z = this->zy;
    m_pRwMat->at.x = this->xz;
    m_pRwMat->at.y = this->yz;
    m_pRwMat->at.z = this->zz;
    m_pRwMat->pos.x = this->tx;
    m_pRwMat->pos.y = this->ty;
    m_pRwMat->pos.z = this->tz;
    RwMatrixUpdate(m_pRwMat);
  }
  return this;
}

//----- (0044EC3C) --------------------------------------------------------
CMatrixSerialize *__fastcall CMatrixSerialize::operator=(CMatrixSerialize *this, const CMatrix *m)
{
  __int64 v2; // d16
  __int64 v3; // d17
  __int64 v4; // d18
  __int64 v5; // d19
  float *p_xz; // r2
  float *p_tx; // r1
  __int64 v8; // d22
  __int64 v9; // d23
  __int64 v10; // d20
  __int64 v11; // d21

  v2 = *(_QWORD *)&m->xx;
  v3 = *(_QWORD *)&m->zx;
  v4 = *(_QWORD *)&m->xy;
  v5 = *(_QWORD *)&m->zy;
  p_xz = &m->xz;
  p_tx = &m->tx;
  v8 = *(_QWORD *)p_tx;
  v9 = *((_QWORD *)p_tx + 1);
  v10 = *(_QWORD *)p_xz;
  v11 = *((_QWORD *)p_xz + 1);
  this->m_pRwMat = 0;
  *(_QWORD *)&this->tx = v8;
  *(_QWORD *)&this->tz = v9;
  *(_QWORD *)&this->xz = v10;
  *(_QWORD *)&this->zz = v11;
  *(_QWORD *)&this->xx = v2;
  *(_QWORD *)&this->zx = v3;
  *(_QWORD *)&this->xy = v4;
  *(_QWORD *)&this->zy = v5;
  return this;
}

//----- (0044EC74) --------------------------------------------------------
void __fastcall CMatrix::CMatrix(CMatrix *this, RwMatrix *pRwMat, bool owner)
{
  this->m_pRwMat = pRwMat;
  this->m_owner = owner;
  this->xx = pRwMat->right.x;
  this->yx = pRwMat->right.y;
  this->zx = pRwMat->right.z;
  *(RwV3d_0 *)&this->xy = pRwMat->up;
  *(RwV3d_0 *)&this->xz = pRwMat->at;
  *(RwV3d_0 *)&this->tx = pRwMat->pos;
}

//----- (0044ECAA) --------------------------------------------------------
void __fastcall CMatrix::Attach(CMatrix *this, RwMatrix *pRwMat, bool owner)
{
  _BOOL4 v4; // r6
  RwMatrix *m_pRwMat; // r0

  v4 = owner;
  m_pRwMat = this->m_pRwMat;
  if ( m_pRwMat && this->m_owner )
    RwMatrixDestroy(m_pRwMat);
  this->m_pRwMat = pRwMat;
  this->m_owner = v4;
  this->xx = pRwMat->right.x;
  this->yx = pRwMat->right.y;
  this->zx = pRwMat->right.z;
  this->xy = pRwMat->up.x;
  this->yy = pRwMat->up.y;
  this->zy = pRwMat->up.z;
  this->xz = pRwMat->at.x;
  this->yz = pRwMat->at.y;
  this->zz = pRwMat->at.z;
  this->tx = pRwMat->pos.x;
  this->ty = pRwMat->pos.y;
  this->tz = pRwMat->pos.z;
}

//----- (0044ED00) --------------------------------------------------------
void __fastcall CMatrix::~CMatrix(CMatrix *this)
{
  RwMatrix *m_pRwMat; // r0

  if ( this->m_owner )
  {
    m_pRwMat = this->m_pRwMat;
    if ( m_pRwMat )
      RwMatrixDestroy(m_pRwMat);
  }
}

//----- (0044ED18) --------------------------------------------------------
void __fastcall CMatrix::Update(CMatrix *this)
{
  RwMatrix *m_pRwMat; // r1

  m_pRwMat = this->m_pRwMat;
  this->xx = m_pRwMat->right.x;
  this->yx = m_pRwMat->right.y;
  this->zx = m_pRwMat->right.z;
  *(RwV3d_0 *)&this->xy = m_pRwMat->up;
  *(RwV3d_0 *)&this->xz = m_pRwMat->at;
  *(RwV3d_0 *)&this->tx = m_pRwMat->pos;
}

//----- (0044ED4C) --------------------------------------------------------
void __fastcall CMatrix::AttachRW(CMatrix *this, RwMatrix *pRwMat, bool owner)
{
  _BOOL4 v4; // r6
  RwMatrix *m_pRwMat; // r0

  v4 = owner;
  m_pRwMat = this->m_pRwMat;
  if ( m_pRwMat && this->m_owner )
    RwMatrixDestroy(m_pRwMat);
  this->m_pRwMat = pRwMat;
  this->m_owner = v4;
  if ( pRwMat )
  {
    pRwMat->right.x = this->xx;
    pRwMat->right.y = this->yx;
    pRwMat->right.z = this->zx;
    pRwMat->up.x = this->xy;
    pRwMat->up.y = this->yy;
    pRwMat->up.z = this->zy;
    pRwMat->at.x = this->xz;
    pRwMat->at.y = this->yz;
    pRwMat->at.z = this->zz;
    pRwMat->pos.x = this->tx;
    pRwMat->pos.y = this->ty;
    pRwMat->pos.z = this->tz;
    sub_196158(pRwMat);
  }
}

//----- (0044EDB4) --------------------------------------------------------
void __fastcall CMatrix::UpdateRW(const CMatrix *this)
{
  RwMatrix *m_pRwMat; // r0

  m_pRwMat = this->m_pRwMat;
  if ( m_pRwMat )
  {
    m_pRwMat->right.x = this->xx;
    m_pRwMat->right.y = this->yx;
    m_pRwMat->right.z = this->zx;
    m_pRwMat->up.x = this->xy;
    m_pRwMat->up.y = this->yy;
    m_pRwMat->up.z = this->zy;
    m_pRwMat->at.x = this->xz;
    m_pRwMat->at.y = this->yz;
    m_pRwMat->at.z = this->zz;
    m_pRwMat->pos.x = this->tx;
    m_pRwMat->pos.y = this->ty;
    m_pRwMat->pos.z = this->tz;
    sub_196158(m_pRwMat);
  }
}

//----- (0044EDF2) --------------------------------------------------------
void __fastcall CMatrix::Detach(CMatrix *this)
{
  RwMatrix *m_pRwMat; // r0

  m_pRwMat = this->m_pRwMat;
  if ( m_pRwMat && this->m_owner )
    RwMatrixDestroy(m_pRwMat);
  this->m_pRwMat = 0;
}

//----- (0044EE0C) --------------------------------------------------------
void __fastcall CMatrix::UpdateMatrix(CMatrix *this, RwMatrix *pMatrix)
{
  this->xx = pMatrix->right.x;
  this->yx = pMatrix->right.y;
  this->zx = pMatrix->right.z;
  *(RwV3d_0 *)&this->xy = pMatrix->up;
  *(RwV3d_0 *)&this->xz = pMatrix->at;
  *(RwV3d_0 *)&this->tx = pMatrix->pos;
}

//----- (0044EE3E) --------------------------------------------------------
void __fastcall CMatrix::UpdateRwMatrix(const CMatrix *this, RwMatrix *pRwMatrix)
{
  pRwMatrix->right.x = this->xx;
  pRwMatrix->right.y = this->yx;
  pRwMatrix->right.z = this->zx;
  pRwMatrix->up = *(RwV3d_0 *)&this->xy;
  pRwMatrix->at = *(RwV3d_0 *)&this->xz;
  pRwMatrix->pos = *(RwV3d_0 *)&this->tx;
  sub_196158(pRwMatrix);
}

//----- (0044EE74) --------------------------------------------------------
void __fastcall CMatrix::CopyOnlyMatrix(CMatrix *this, const CMatrix *m)
{
  const CMatrix *v2; // r2
  float *p_xz; // r3
  float *p_tx; // r1
  __int64 v5; // d16
  __int64 v6; // d17
  __int64 v7; // d23
  __int64 v8; // d18
  __int64 v9; // d19
  __int64 v10; // d20
  __int64 v11; // d21
  float *p_xy; // r0

  v2 = m;
  p_xz = &m->xz;
  p_tx = &m->tx;
  v5 = *(_QWORD *)&v2->xx;
  v6 = *(_QWORD *)&v2->zx;
  v2 = (const CMatrix *)((char *)v2 + 16);
  v7 = *((_QWORD *)p_tx + 1);
  v8 = *(_QWORD *)p_xz;
  v9 = *((_QWORD *)p_xz + 1);
  v10 = *(_QWORD *)&v2->xx;
  v11 = *(_QWORD *)&v2->zx;
  *(_QWORD *)&this->tx = *(_QWORD *)p_tx;
  *(_QWORD *)&this->tz = v7;
  *(_QWORD *)&this->xz = v8;
  *(_QWORD *)&this->zz = v9;
  *(_QWORD *)&this->xx = v5;
  *(_QWORD *)&this->zx = v6;
  p_xy = &this->xy;
  *(_QWORD *)p_xy = v10;
  *((_QWORD *)p_xy + 1) = v11;
}

//----- (0044EEA6) --------------------------------------------------------
CMatrix *__fastcall CMatrix::operator+=(CMatrix *this, const CMatrix *m)
{
  float yx; // s2
  float xy; // s4
  float yy; // s6
  float v5; // s0
  float xz; // s4

  yx = this->yx;
  xy = this->xy;
  yy = this->yy;
  this->xx = m->xx + this->xx;
  v5 = m->xy + xy;
  xz = this->xz;
  this->xy = v5;
  this->xz = m->xz + xz;
  this->yx = m->yx + yx;
  this->yy = m->yy + yy;
  this->yz = m->yz + this->yz;
  this->zx = m->zx + this->zx;
  this->zy = m->zy + this->zy;
  this->zz = m->zz + this->zz;
  this->tx = m->tx + this->tx;
  this->ty = m->ty + this->ty;
  this->tz = m->tz + this->tz;
  return this;
}

//----- (0044EF68) --------------------------------------------------------
void __fastcall CMatrix::SetUnity(CMatrix *this)
{
  this->xx = 1.0;
  this->yx = 0.0;
  this->zx = 0.0;
  this->xy = 0.0;
  this->yy = 1.0;
  this->zy = 0.0;
  this->xz = 0.0;
  this->yz = 0.0;
  this->zz = 1.0;
  this->tx = 0.0;
  this->ty = 0.0;
  this->tz = 0.0;
}

//----- (0044EF88) --------------------------------------------------------
void __fastcall CMatrix::ResetOrientation(CMatrix *this)
{
  this->xx = 1.0;
  this->yx = 0.0;
  this->zx = 0.0;
  this->xy = 0.0;
  this->yy = 1.0;
  this->zy = 0.0;
  this->xz = 0.0;
  this->yz = 0.0;
  this->zz = 1.0;
}

//----- (0044EFA2) --------------------------------------------------------
void __fastcall CMatrix::SetScale(CMatrix *this, float s)
{
  this->xx = s;
  this->yx = 0.0;
  this->zx = 0.0;
  this->xy = 0.0;
  this->yy = s;
  this->zy = 0.0;
  this->xz = 0.0;
  this->yz = 0.0;
  this->zz = s;
  this->tx = 0.0;
  this->ty = 0.0;
  this->tz = 0.0;
}

//----- (0044EFBE) --------------------------------------------------------
void __fastcall CMatrix::SetScale(CMatrix *this, float sx, float sy, float sz)
{
  this->xx = sx;
  this->yx = 0.0;
  this->zx = 0.0;
  this->xy = 0.0;
  this->yy = sy;
  this->zy = 0.0;
  this->xz = 0.0;
  this->yz = 0.0;
  this->zz = sz;
  this->tx = 0.0;
  this->ty = 0.0;
  this->tz = 0.0;
}

//----- (0044EFE2) --------------------------------------------------------
void __fastcall CMatrix::SetTranslate(CMatrix *this, float tx, float ty, float tz)
{
  float *p_tx; // r0

  this->xx = 1.0;
  this->yx = 0.0;
  this->zx = 0.0;
  this->xy = 0.0;
  this->yy = 1.0;
  this->zy = 0.0;
  this->xz = 0.0;
  this->yz = 0.0;
  this->zz = 1.0;
  p_tx = &this->tx;
  *p_tx = tx;
  p_tx[1] = ty;
  p_tx[2] = tz;
}

//----- (0044F00C) --------------------------------------------------------
void __fastcall CMatrix::SetTranslateOnly(CMatrix *this, float tx, float ty, float tz)
{
  float *p_tx; // r0

  p_tx = &this->tx;
  *p_tx = tx;
  p_tx[1] = ty;
  p_tx[2] = tz;
}

//----- (0044F012) --------------------------------------------------------
void __fastcall CMatrix::SetRotateXOnly(CMatrix *this, float a)
{
  float v4; // s0
  float v5; // r0

  this->yx = 0.0;
  v4 = sinf(a);
  this->xx = 1.0;
  this->zx = 0.0;
  this->xy = 0.0;
  this->xz = 0.0;
  v5 = cosf(a);
  this->yy = v5;
  this->zy = v4;
  this->zz = v5;
  this->yz = -v4;
}

//----- (0044F066) --------------------------------------------------------
void __fastcall CMatrix::SetRotateYOnly(CMatrix *this, float a)
{
  float v4; // s0
  float v5; // r0

  this->yx = 0.0;
  v4 = sinf(a);
  this->xy = 0.0;
  this->yy = 1.0;
  this->zy = 0.0;
  this->yz = 0.0;
  v5 = cosf(a);
  this->xx = v5;
  this->xz = v4;
  this->zz = v5;
  this->zx = -v4;
}

//----- (0044F0B8) --------------------------------------------------------
void __fastcall CMatrix::SetRotateZOnly(CMatrix *this, float a)
{
  float v4; // r0
  float v5; // s16
  float v6; // r0

  v4 = sinf(a);
  this->zy = 0.0;
  this->xz = 0.0;
  this->yz = 0.0;
  v5 = -v4;
  this->zz = 1.0;
  *(_QWORD *)&this->yx = LODWORD(v4);
  v6 = cosf(a);
  this->xx = v6;
  this->yy = v6;
  this->xy = v5;
}

//----- (0044F0F8) --------------------------------------------------------
void __fastcall CMatrix::SetRotateX(CMatrix *this, float a)
{
  float v4; // r6
  float v5; // r0

  this->xx = 1.0;
  this->yx = 0.0;
  this->zx = 0.0;
  v4 = sinf(a);
  this->xy = 0.0;
  this->xz = 0.0;
  this->tx = 0.0;
  this->ty = 0.0;
  this->tz = 0.0;
  v5 = cosf(a);
  this->yy = v5;
  this->zy = v4;
  this->zz = v5;
  this->yz = -v4;
}

//----- (0044F148) --------------------------------------------------------
void __fastcall CMatrix::SetRotateY(CMatrix *this, float a)
{
  float v4; // r6
  float v5; // r0

  this->yx = 0.0;
  this->xy = 0.0;
  this->yy = 1.0;
  v4 = sinf(a);
  this->zy = 0.0;
  this->yz = 0.0;
  this->tx = 0.0;
  this->ty = 0.0;
  this->tz = 0.0;
  v5 = cosf(a);
  this->xx = v5;
  this->xz = v4;
  this->zz = v5;
  this->zx = -v4;
}

//----- (0044F198) --------------------------------------------------------
void __fastcall CMatrix::SetRotateZ(CMatrix *this, float a)
{
  float v4; // r0
  float v5; // s16
  float v6; // r0

  this->zx = 0.0;
  this->zy = 0.0;
  this->xz = 0.0;
  this->yz = 0.0;
  v4 = sinf(a);
  this->zz = 1.0;
  this->tx = 0.0;
  this->ty = 0.0;
  v5 = -v4;
  this->tz = 0.0;
  this->yx = v4;
  v6 = cosf(a);
  this->xx = v6;
  this->yy = v6;
  this->xy = v5;
}

//----- (0044F1E6) --------------------------------------------------------
void __fastcall CMatrix::SetRotate(CMatrix *this, float ax, float ay, float az)
{
  float v8; // r8
  float v9; // s16
  float v10; // s20
  float v11; // r5
  float v12; // s24
  float v13; // r0

  v8 = sinf(ax);
  v9 = cosf(az);
  v10 = sinf(az);
  v11 = cosf(ax);
  v12 = cosf(ay);
  v13 = sinf(ay);
  this->tx = 0.0;
  this->ty = 0.0;
  this->tz = 0.0;
  this->zy = v8;
  this->xy = -(float)(v11 * v10);
  this->yy = v11 * v9;
  this->xx = (float)(v12 * v9) - (float)(v13 * (float)(v8 * v10));
  this->yx = (float)(v12 * v10) + (float)(v13 * (float)(v8 * v9));
  this->zx = -(float)(v11 * v13);
  this->xz = (float)(v13 * v9) + (float)(v12 * (float)(v8 * v10));
  this->yz = (float)(v13 * v10) - (float)(v12 * (float)(v8 * v9));
  this->zz = v11 * v12;
}

//----- (0044F2B8) --------------------------------------------------------
void __fastcall CMatrix::SetRotate(CMatrix *this, const CQuaternion *q)
{
  float x; // s0
  float y; // s2
  float z; // s4
  float w; // s6
  float v6; // s8
  float v7; // s5
  float v8; // s14
  float v9; // s4
  float v10; // s3
  float v11; // s1
  float v12; // s10
  float v13; // s6
  float v14; // s0
  float v15; // s2

  x = q->x;
  y = q->y;
  z = q->z;
  w = q->w;
  v6 = z + z;
  v7 = x * (float)(x + x);
  v8 = y * (float)(y + y);
  v9 = z * (float)(z + z);
  v10 = q->x * (float)(y + y);
  v11 = w * v6;
  v12 = (float)(y + y) * w;
  v13 = (float)(x + x) * w;
  v14 = q->x * v6;
  v15 = y * v6;
  this->xx = 1.0 - (float)(v8 + v9);
  this->yx = v10 + v11;
  this->zx = v14 - v12;
  this->xy = v10 - v11;
  this->yy = 1.0 - (float)(v7 + v9);
  this->zy = v15 + v13;
  this->xz = v14 + v12;
  this->yz = v15 - v13;
  this->zz = 1.0 - (float)(v7 + v8);
}

//----- (0044F34E) --------------------------------------------------------
void __fastcall CMatrix::RotateX(CMatrix *this, float a)
{
  float v4; // r6
  float v5; // r0
  float yx; // s0
  float zx; // s2
  float yy; // s4
  float zy; // s6
  float yz; // s3
  float zz; // s5
  float ty; // s13
  float tz; // s15

  v4 = cosf(a);
  v5 = sinf(a);
  yx = this->yx;
  zx = this->zx;
  yy = this->yy;
  zy = this->zy;
  yz = this->yz;
  zz = this->zz;
  ty = this->ty;
  tz = this->tz;
  this->yx = (float)(v4 * yx) - (float)(v5 * zx);
  this->zx = (float)(v5 * yx) + (float)(v4 * zx);
  this->yy = (float)(v4 * yy) - (float)(v5 * zy);
  this->zy = (float)(v5 * yy) + (float)(v4 * zy);
  this->yz = (float)(v4 * yz) - (float)(v5 * zz);
  this->zz = (float)(v5 * yz) + (float)(v4 * zz);
  this->ty = (float)(v4 * ty) - (float)(v5 * tz);
  this->tz = (float)(v5 * ty) + (float)(v4 * tz);
}

//----- (0044F41E) --------------------------------------------------------
void __fastcall CMatrix::RotateY(CMatrix *this, float a)
{
  float v4; // r6
  float v5; // r0
  float zx; // s2
  float xy; // s4
  float zy; // s6
  float zz; // s3
  float xz; // s7
  float tz; // s13
  float tx; // s15
  float v13; // s0
  float v14; // s2

  v4 = cosf(a);
  v5 = sinf(a);
  zx = this->zx;
  xy = this->xy;
  zy = this->zy;
  zz = this->zz;
  xz = this->xz;
  tz = this->tz;
  tx = this->tx;
  v13 = (float)(v4 * this->xx) + (float)(v5 * zx);
  v14 = (float)(v4 * zx) - (float)(this->xx * v5);
  this->xx = v13;
  this->zx = v14;
  this->xy = (float)(v4 * xy) + (float)(v5 * zy);
  this->zy = (float)(v4 * zy) - (float)(xy * v5);
  this->xz = (float)(v4 * xz) + (float)(v5 * zz);
  this->zz = (float)(v4 * zz) - (float)(xz * v5);
  this->tx = (float)(v4 * tx) + (float)(v5 * tz);
  this->tz = (float)(v4 * tz) - (float)(tx * v5);
}

//----- (0044F4EE) --------------------------------------------------------
void __fastcall CMatrix::RotateZ(CMatrix *this, float a)
{
  float v4; // r6
  float v5; // r0
  float yx; // s2
  float xy; // s4
  float yy; // s6
  float xz; // s3
  float yz; // s5
  float tx; // s13
  float ty; // s15
  float v13; // s0

  v4 = cosf(a);
  v5 = sinf(a);
  yx = this->yx;
  xy = this->xy;
  yy = this->yy;
  xz = this->xz;
  yz = this->yz;
  tx = this->tx;
  ty = this->ty;
  v13 = (float)(v5 * this->xx) + (float)(v4 * yx);
  this->xx = (float)(v4 * this->xx) - (float)(v5 * yx);
  this->yx = v13;
  this->xy = (float)(v4 * xy) - (float)(v5 * yy);
  this->yy = (float)(v5 * xy) + (float)(v4 * yy);
  this->xz = (float)(v4 * xz) - (float)(v5 * yz);
  this->yz = (float)(v5 * xz) + (float)(v4 * yz);
  this->tx = (float)(v4 * tx) - (float)(v5 * ty);
  this->ty = (float)(v5 * tx) + (float)(v4 * ty);
}

//----- (0044F5BE) --------------------------------------------------------
void __fastcall CMatrix::Rotate(CMatrix *this, float ax, float ay, float az)
{
  float v8; // r5
  float v9; // s16
  float v10; // s18
  float v11; // s24
  float v12; // r5
  float v13; // s26
  float v14; // s22
  float v15; // r0
  float v16; // s8
  float yx; // s2
  float v18; // s4
  float yy; // s5
  float xy; // s3
  float ty; // s15
  float zx; // s6
  float zy; // s28
  float xz; // s21
  float v25; // s24
  float tx; // s7
  float v27; // s14
  float v28; // s10
  float v29; // s11
  float v30; // s12
  float v31; // s30
  float v32; // s9
  float zz; // s16
  float v34; // s26
  float v35; // s7
  float v36; // s17
  float yz; // s19
  float v38; // s0
  float v39; // s1
  float tz; // s18

  v8 = sinf(ax);
  v9 = sinf(az);
  v10 = v8;
  v11 = v8 * v9;
  v12 = cosf(ay);
  v13 = cosf(az);
  v14 = sinf(ay);
  v15 = cosf(ax);
  v16 = (float)(v12 * v13) - (float)(v14 * v11);
  yx = this->yx;
  v18 = v15 * v9;
  yy = this->yy;
  xy = this->xy;
  ty = this->ty;
  zx = this->zx;
  zy = this->zy;
  xz = this->xz;
  v25 = (float)(v14 * v13) + (float)(v12 * v11);
  tx = this->tx;
  v27 = v15 * v13;
  v28 = (float)(v16 * tx) - (float)(ty * (float)(v15 * v9));
  v29 = (float)(v25 * zx) + (float)((float)(this->xx * v16) - (float)(yx * (float)(v15 * v9)));
  v30 = (float)((float)(v10 * yy) - (float)(xy * (float)(v15 * v14))) + (float)((float)(v15 * v12) * zy);
  v31 = (float)(v12 * v9) + (float)(v14 * (float)(v10 * v13));
  v32 = (float)(v14 * v9) - (float)(v12 * (float)(v10 * v13));
  zz = this->zz;
  v34 = (float)(v31 * tx) + (float)((float)(v15 * v13) * ty);
  v35 = (float)(v10 * ty) - (float)(tx * (float)(v15 * v14));
  v36 = (float)((float)(v10 * yx) - (float)(this->xx * (float)(v15 * v14))) + (float)((float)(v15 * v12) * zx);
  yz = this->yz;
  v38 = (float)((float)(this->xx * v31) + (float)(v27 * yx)) + (float)(v32 * zx);
  v39 = (float)(v10 * yz) - (float)(xz * (float)(v15 * v14));
  tz = this->tz;
  this->xx = v29;
  this->yx = v38;
  this->zx = v36;
  this->xy = (float)((float)(v16 * xy) - (float)(yy * v18)) + (float)(v25 * zy);
  this->yy = (float)((float)(v31 * xy) + (float)(v27 * yy)) + (float)(v32 * zy);
  this->zy = v30;
  this->xz = (float)((float)(v16 * xz) - (float)(yz * v18)) + (float)(v25 * zz);
  this->yz = (float)((float)(v31 * xz) + (float)(v27 * yz)) + (float)(v32 * zz);
  this->zz = v39 + (float)((float)(v15 * v12) * zz);
  this->tx = v28 + (float)(v25 * tz);
  this->ty = v34 + (float)(v32 * tz);
  this->tz = v35 + (float)((float)(v15 * v12) * tz);
}

//----- (0044F7B4) --------------------------------------------------------
void __fastcall CMatrix::Reorthogonalise(CMatrix *this)
{
  float zy; // s10
  float yx; // s2
  float zx; // s4
  float yy; // s8
  float xy; // s6
  float v6; // s12
  float v7; // s4
  float v8; // s0
  float v9; // s2
  float v10; // s0
  float v11; // s12
  float v12; // s2
  float v13; // s4
  float v14; // s10
  float v15; // s6
  float v16; // s8
  float v17; // s6
  float v18; // s4
  float v19; // s8

  zy = this->zy;
  yx = this->yx;
  zx = this->zx;
  yy = this->yy;
  xy = this->xy;
  v6 = (float)(yx * zy) - (float)(zx * yy);
  v7 = (float)(zx * xy) - (float)(zy * this->xx);
  v8 = (float)(yy * this->xx) - (float)(yx * xy);
  v9 = 1.0 / sqrtf((float)(v8 * v8) + (float)((float)(v6 * v6) + (float)(v7 * v7)));
  v10 = v8 * v9;
  v11 = v6 * v9;
  v12 = v7 * v9;
  this->xz = v11;
  this->yz = v12;
  this->zz = v10;
  v13 = (float)(zy * v11) - (float)(xy * v10);
  v14 = (float)(yy * v10) - (float)(zy * v12);
  v15 = (float)(xy * v12) - (float)(yy * v11);
  v16 = 1.0 / sqrtf((float)(v15 * v15) + (float)((float)(v14 * v14) + (float)(v13 * v13)));
  v17 = v15 * v16;
  v18 = v13 * v16;
  v19 = v14 * v16;
  this->xx = v19;
  this->yx = v18;
  this->zx = v17;
  this->xy = (float)(v12 * v17) - (float)(v10 * v18);
  this->yy = (float)(v10 * v19) - (float)(v11 * v17);
  this->zy = (float)(v11 * v18) - (float)(v12 * v19);
}

//----- (0044F8B2) --------------------------------------------------------
void __fastcall CMatrix::ForceUpVector(CMatrix *this, CVector NewUp)
{
  float yy; // s4
  float zy; // s6
  float xy; // s2
  float v5; // s12
  float v6; // s2
  float v7; // s4

  yy = this->yy;
  zy = this->zy;
  xy = this->xy;
  *(CVector *)&this->xz = NewUp;
  v5 = (float)(zy * NewUp.x) - (float)(xy * NewUp.z);
  v6 = (float)(xy * NewUp.y) - (float)(yy * NewUp.x);
  v7 = (float)(yy * NewUp.z) - (float)(zy * NewUp.y);
  this->xx = v7;
  this->yx = v5;
  this->zx = v6;
  this->xy = (float)(v6 * NewUp.y) - (float)(v5 * NewUp.z);
  this->yy = (float)(v7 * NewUp.z) - (float)(v6 * NewUp.x);
  this->zy = (float)(v5 * NewUp.x) - (float)(v7 * NewUp.y);
}

//----- (0044F938) --------------------------------------------------------
CMatrix *__fastcall Invert(CMatrix *retstr, const CMatrix *m)
{
  __int64 v2; // kr00_8
  float zx; // r12
  float ty; // s2
  float tx; // s0
  float tz; // s4
  float v7; // s10
  __int64 v8; // kr08_8
  float v9; // s12
  float zz; // r8
  float yz; // s3
  __int64 v12; // kr10_8
  float zy; // r1

  v2 = *(_QWORD *)&m->xx;
  zx = m->zx;
  ty = m->ty;
  tx = m->tx;
  tz = m->tz;
  v7 = ty * m->yx;
  v8 = *(_QWORD *)&m->xz;
  v9 = tx * m->xx;
  zz = m->zz;
  yz = m->yz;
  v12 = *(_QWORD *)&m->xy;
  zy = m->zy;
  retstr->m_pRwMat = 0;
  retstr->m_owner = 0;
  LODWORD(retstr->yx) = v12;
  LODWORD(retstr->xx) = v2;
  LODWORD(retstr->zx) = v8;
  retstr->xy = *((float *)&v2 + 1);
  retstr->yy = *((float *)&v12 + 1);
  retstr->zy = *((float *)&v8 + 1);
  retstr->xz = zx;
  retstr->yz = zy;
  retstr->zz = zz;
  retstr->tx = -(float)((float)((float)(v9 + 0.0) + v7) + (float)(tz * zx));
  retstr->ty = -(float)((float)((float)((float)(tx * *(float *)&v12) + 0.0) + (float)(ty * *((float *)&v12 + 1)))
                      + (float)(tz * zy));
  retstr->tz = -(float)((float)((float)((float)(tx * *(float *)&v8) + 0.0) + (float)(ty * yz)) + (float)(tz * zz));
  return retstr;
}

//----- (0044FA10) --------------------------------------------------------
CMatrix *__fastcall Invert(const CMatrix *m, CMatrix *output)
{
  float xx; // r2
  float xy; // r3
  float v4; // s0
  float xz; // r4
  float yx; // r6
  float yy; // r5
  float yz; // r8
  float zx; // r2
  float zy; // lr
  float zz; // r12
  float v12; // s0
  float v13; // s2
  float v14; // s4
  float v15; // s0
  float v16; // s2
  float v17; // s4
  float v18; // s0
  float v19; // s2
  float tz; // s8
  CMatrix *result; // r0

  output->tx = 0.0;
  output->ty = 0.0;
  output->tz = 0.0;
  xx = m->xx;
  output->xx = m->xx;
  xy = m->xy;
  output->yx = xy;
  v4 = xx;
  xz = m->xz;
  output->zx = xz;
  yx = m->yx;
  output->xy = yx;
  yy = m->yy;
  output->yy = yy;
  yz = m->yz;
  output->zy = yz;
  zx = m->zx;
  output->xz = zx;
  zy = m->zy;
  output->yz = zy;
  zz = m->zz;
  output->zz = zz;
  v12 = (float)(m->tx * v4) + 0.0;
  output->tx = v12;
  v13 = (float)(m->tx * xy) + 0.0;
  output->ty = v13;
  v14 = (float)(m->tx * xz) + 0.0;
  output->tz = v14;
  v15 = v12 + (float)(m->ty * yx);
  output->tx = v15;
  v16 = v13 + (float)(m->ty * yy);
  output->ty = v16;
  v17 = v14 + (float)(m->ty * yz);
  output->tz = v17;
  v18 = v15 + (float)(m->tz * zx);
  output->tx = v18;
  v19 = v16 + (float)(m->tz * zy);
  output->ty = v19;
  tz = m->tz;
  result = output;
  output->tx = -v18;
  output->ty = -v19;
  output->tz = -(float)(v17 + (float)(tz * zz));
  return result;
}

//----- (0044FB28) --------------------------------------------------------
RwMatrix *__fastcall CMatrix::CopyToRwMatrix(const CMatrix *this, RwMatrix *pMatrix)
{
  __int64 v2; // d16
  __int64 v4; // d16
  __int64 v5; // d16
  __int64 v6; // d16

  v2 = *(_QWORD *)&this->xx;
  pMatrix->right.z = this->zx;
  *(_QWORD *)&pMatrix->right.x = v2;
  v4 = *(_QWORD *)&this->xy;
  pMatrix->up.z = this->zy;
  *(_QWORD *)&pMatrix->up.x = v4;
  v5 = *(_QWORD *)&this->xz;
  pMatrix->at.z = this->zz;
  *(_QWORD *)&pMatrix->at.x = v5;
  v6 = *(_QWORD *)&this->tx;
  pMatrix->pos.z = this->tz;
  *(_QWORD *)&pMatrix->pos.x = v6;
  RwMatrixUpdate(pMatrix);
  return pMatrix;
}

//----- (0044FB68) --------------------------------------------------------
CMatrix *__fastcall operator*(CMatrix *retstr, const CMatrix *m1, const CMatrix *m2)
{
  float xx; // s3
  float v4; // s0
  float yx; // s5
  float xy; // s4
  float zx; // s7
  float xz; // s2
  float v9; // s6
  float yy; // s14
  float yz; // s8
  float v12; // s12
  float zy; // s1
  float zz; // s10
  float v15; // s3
  float v16; // s5
  float v17; // s7
  float v18; // s3
  float v19; // s5
  float v20; // s7
  float tx; // s3
  float ty; // s5
  float tz; // s7
  float v24; // s0
  float v25; // s4
  float v26; // s14
  float v27; // s0
  float v28; // s2
  float v29; // s8

  retstr->m_pRwMat = 0;
  retstr->m_owner = 0;
  xx = m2->xx;
  v4 = m1->xx;
  yx = m2->yx;
  xy = m1->xy;
  zx = m2->zx;
  xz = m1->xz;
  retstr->xx = (float)((float)(m1->xx * m2->xx) + (float)(xy * yx)) + (float)(xz * zx);
  v9 = m1->yx;
  yy = m1->yy;
  yz = m1->yz;
  retstr->yx = (float)((float)(v9 * xx) + (float)(yy * yx)) + (float)(yz * zx);
  v12 = m1->zx;
  zy = m1->zy;
  zz = m1->zz;
  retstr->zx = (float)((float)(v12 * xx) + (float)(zy * yx)) + (float)(zz * zx);
  v15 = m2->xy;
  v16 = m2->yy;
  v17 = m2->zy;
  retstr->xy = (float)((float)(v4 * v15) + (float)(xy * v16)) + (float)(xz * v17);
  retstr->yy = (float)((float)(v9 * v15) + (float)(yy * v16)) + (float)(yz * v17);
  retstr->zy = (float)((float)(v12 * v15) + (float)(zy * v16)) + (float)(zz * v17);
  v18 = m2->xz;
  v19 = m2->yz;
  v20 = m2->zz;
  retstr->xz = (float)((float)(v4 * v18) + (float)(xy * v19)) + (float)(xz * v20);
  retstr->yz = (float)((float)(v9 * v18) + (float)(yy * v19)) + (float)(yz * v20);
  retstr->zz = (float)((float)(v12 * v18) + (float)(zy * v19)) + (float)(zz * v20);
  tx = m2->tx;
  ty = m2->ty;
  tz = m2->tz;
  v24 = (float)(v4 * tx) + (float)(xy * ty);
  v25 = yy * ty;
  v26 = m1->tz;
  v27 = v24 + (float)(xz * tz);
  v28 = yz * tz;
  v29 = m1->ty;
  retstr->tx = m1->tx + v27;
  retstr->ty = v29 + (float)((float)((float)(v9 * tx) + v25) + v28);
  retstr->tz = v26 + (float)((float)((float)(v12 * tx) + (float)(zy * ty)) + (float)(zz * tz));
  return retstr;
}

//----- (0044FD08) --------------------------------------------------------
CMatrix *__fastcall operator+(CMatrix *retstr, const CMatrix *m1, const CMatrix *m2)
{
  float v3; // s2
  float v4; // s4
  float v5; // s2
  float v6; // s4
  float v7; // s2
  float v8; // s4
  float v9; // s2
  float v10; // s4

  retstr->m_pRwMat = 0;
  retstr->m_owner = 0;
  v3 = m1->yx + m2->yx;
  v4 = m1->zx + m2->zx;
  retstr->xx = m1->xx + m2->xx;
  retstr->yx = v3;
  retstr->zx = v4;
  v5 = m1->yy + m2->yy;
  v6 = m1->zy + m2->zy;
  retstr->xy = m1->xy + m2->xy;
  retstr->yy = v5;
  retstr->zy = v6;
  v7 = m1->yz + m2->yz;
  v8 = m1->zz + m2->zz;
  retstr->xz = m1->xz + m2->xz;
  retstr->yz = v7;
  retstr->zz = v8;
  v9 = m1->ty + m2->ty;
  v10 = m1->tz + m2->tz;
  retstr->tx = m1->tx + m2->tx;
  retstr->ty = v9;
  retstr->tz = v10;
  return retstr;
}

//----- (0044FDD0) --------------------------------------------------------
void __fastcall CCompressedMatrixNotAligned::DecompressIntoFullMatrix(
        CCompressedMatrixNotAligned *this,
        CMatrix *Matrix)
{
  float y; // r1
  float z; // r2
  float xx; // s0
  float zy; // s10
  float yx; // s2
  float zx; // s4
  float v10; // s1
  float yy; // s8
  float xy; // s6
  float v13; // s12
  float v14; // s4
  float v15; // s0
  float v16; // s2
  float v17; // s0
  float v18; // s12
  float v19; // s2
  float v20; // s4
  float v21; // s10
  float v22; // s6
  float v23; // s8
  float v24; // s6
  float v25; // s4
  float v26; // s8
  CVector v27; // [sp+4h] [bp-14h] BYREF

  Matrix->xx = (float)this->Matrix_xx / 127.0;
  Matrix->yx = (float)this->Matrix_yx / 127.0;
  Matrix->zx = (float)this->Matrix_zx / 127.0;
  Matrix->xy = (float)this->Matrix_xy / 127.0;
  Matrix->yy = (float)this->Matrix_yy / 127.0;
  Matrix->zy = (float)this->Matrix_zy / 127.0;
  CrossProduct(&v27, (const CVector *)Matrix, (const CVector *)&Matrix->xy);
  y = v27.y;
  z = v27.z;
  xx = Matrix->xx;
  zy = Matrix->zy;
  yx = Matrix->yx;
  zx = Matrix->zx;
  v10 = zy * Matrix->xx;
  yy = Matrix->yy;
  xy = Matrix->xy;
  Matrix->xz = v27.x;
  Matrix->yz = y;
  Matrix->zz = z;
  Matrix->tx = this->CoorX;
  Matrix->ty = this->CoorY;
  v13 = (float)(yx * zy) - (float)(zx * yy);
  Matrix->tz = this->CoorZ;
  v14 = (float)(zx * xy) - v10;
  v15 = (float)(yy * xx) - (float)(yx * xy);
  v16 = 1.0 / sqrtf((float)(v15 * v15) + (float)((float)(v13 * v13) + (float)(v14 * v14)));
  v17 = v15 * v16;
  v18 = v13 * v16;
  v19 = v14 * v16;
  Matrix->xz = v18;
  Matrix->yz = v19;
  Matrix->zz = v17;
  v20 = (float)(zy * v18) - (float)(xy * v17);
  v21 = (float)(yy * v17) - (float)(zy * v19);
  v22 = (float)(xy * v19) - (float)(yy * v18);
  v23 = 1.0 / sqrtf((float)(v22 * v22) + (float)((float)(v21 * v21) + (float)(v20 * v20)));
  v24 = v22 * v23;
  v25 = v20 * v23;
  v26 = v21 * v23;
  Matrix->xx = v26;
  Matrix->yx = v25;
  Matrix->zx = v24;
  Matrix->xy = (float)(v19 * v24) - (float)(v17 * v25);
  Matrix->yy = (float)(v17 * v26) - (float)(v18 * v24);
  Matrix->zy = (float)(v18 * v25) - (float)(v19 * v26);
}

//----- (0044FF7C) --------------------------------------------------------
void __fastcall CCompressedMatrixNotAligned::CompressFromFullMatrix(CCompressedMatrixNotAligned *this, CMatrix *Matrix)
{
  this->Matrix_xx = (int)(float)(Matrix->xx * 127.0);
  this->Matrix_yx = (int)(float)(Matrix->yx * 127.0);
  this->Matrix_zx = (int)(float)(Matrix->zx * 127.0);
  this->Matrix_xy = (int)(float)(Matrix->xy * 127.0);
  this->Matrix_yy = (int)(float)(Matrix->yy * 127.0);
  this->Matrix_zy = (int)(float)(Matrix->zy * 127.0);
  this->CoorX = Matrix->tx;
  this->CoorY = Matrix->ty;
  this->CoorZ = Matrix->tz;
}

//----- (00450000) --------------------------------------------------------
void __fastcall CQuaternion::Set(CQuaternion *this, const RwMatrix *mat)
{
  float x; // s2
  float y; // s4
  float z; // s0
  float v5; // s6
  float v6; // s6
  float v7; // s6
  float v8; // s0
  float v9; // s0
  float v10; // s4
  float v11; // s0
  float v12; // s0
  float v13; // s0

  x = mat->right.x;
  y = mat->up.y;
  z = mat->at.z;
  v5 = (float)(mat->right.x + y) + z;
  if ( v5 >= 0.0 )
  {
    v9 = sqrtf(v5 + 1.0);
    v10 = 0.5 / v9;
    this->w = v9 * 0.5;
    this->x = (float)(0.5 / v9) * (float)(mat->up.z - mat->at.y);
    this->y = (float)(0.5 / v9) * (float)(mat->at.x - mat->right.z);
    v11 = mat->right.y - mat->up.x;
  }
  else
  {
    v6 = (float)(x - y) - z;
    if ( v6 >= 0.0 )
    {
      v12 = sqrtf(v6 + 1.0);
      this->x = v12 * 0.5;
      this->y = (float)(0.5 / v12) * (float)(mat->up.x + mat->right.y);
      this->z = (float)(0.5 / v12) * (float)(mat->at.x + mat->right.z);
      this->w = (float)(0.5 / v12) * (float)(mat->up.z - mat->at.y);
      return;
    }
    v7 = (float)(y - x) - z;
    if ( v7 < 0.0 )
    {
      v8 = sqrtf((float)((float)((float)-x - y) + z) + 1.0);
      this->z = v8 * 0.5;
      this->w = (float)(0.5 / v8) * (float)(mat->right.y - mat->up.x);
      this->x = (float)(0.5 / v8) * (float)(mat->at.x + mat->right.z);
      this->y = (float)(0.5 / v8) * (float)(mat->at.y + mat->up.z);
      return;
    }
    v13 = sqrtf(v7 + 1.0);
    v10 = 0.5 / v13;
    this->y = v13 * 0.5;
    this->w = (float)(0.5 / v13) * (float)(mat->at.x - mat->right.z);
    this->x = (float)(0.5 / v13) * (float)(mat->up.x - mat->right.y);
    v11 = mat->at.y + mat->up.z;
  }
  this->z = v10 * v11;
}

//----- (004501B0) --------------------------------------------------------
void __fastcall CQuaternion::Set(CQuaternion *this, float ax, float ay, float az)
{
  float v7; // r5
  float v8; // r9
  float v9; // r6
  float v10; // r10
  float v11; // r5
  float v12; // s16
  float v13; // s24
  float v14; // s28
  float v15; // s16
  float v16; // r0

  v7 = ax * 0.5;
  v8 = cosf(ax * 0.5);
  v9 = ay * 0.5;
  v10 = cosf(v9);
  v11 = sinf(v7);
  v12 = sinf(v9);
  v13 = v11 * v12;
  v14 = cosf(az * 0.5);
  v15 = v8 * v12;
  v16 = sinf(az * 0.5);
  this->x = (float)((float)(v8 * v10) * v16) - (float)(v14 * v13);
  this->y = (float)(v14 * (float)(v10 * v11)) + (float)(v16 * v15);
  this->z = (float)(v14 * v15) - (float)((float)(v10 * v11) * v16);
  this->w = (float)(v14 * (float)(v8 * v10)) + (float)(v16 * v13);
}

//----- (00450286) --------------------------------------------------------
void __fastcall CQuaternion::Set(CQuaternion *this, RwV3d_0 *pVec, float fRotation)
{
  float v5; // r6
  float v6; // s16
  float v7; // r0
  float z; // s0

  v5 = fRotation * 0.5;
  v6 = sinf(fRotation * 0.5);
  this->x = v6 * pVec->x;
  this->y = v6 * pVec->y;
  v7 = cosf(v5);
  z = pVec->z;
  this->w = v7;
  this->z = v6 * z;
}

//----- (004502E6) --------------------------------------------------------
void __fastcall CQuaternion::Get(const CQuaternion *this, RwMatrix *pmat)
{
  float x; // s0
  float y; // s2
  float z; // s4
  float w; // s6
  float v6; // s8
  float v7; // s5
  float v8; // s14
  float v9; // s4
  float v10; // s3
  float v11; // s1
  float v12; // s10
  float v13; // s6
  float v14; // s0
  float v15; // s2

  x = this->x;
  y = this->y;
  z = this->z;
  w = this->w;
  v6 = z + z;
  v7 = x * (float)(x + x);
  v8 = y * (float)(y + y);
  v9 = z * (float)(z + z);
  v10 = this->x * (float)(y + y);
  v11 = w * v6;
  v12 = (float)(y + y) * w;
  v13 = (float)(x + x) * w;
  v14 = this->x * v6;
  v15 = y * v6;
  pmat->right.x = 1.0 - (float)(v8 + v9);
  pmat->right.y = v10 + v11;
  pmat->right.z = v14 - v12;
  pmat->up.x = v10 - v11;
  pmat->up.y = 1.0 - (float)(v7 + v9);
  pmat->up.z = v15 + v13;
  pmat->at.x = v14 + v12;
  pmat->at.y = v15 - v13;
  pmat->at.z = 1.0 - (float)(v7 + v8);
}

//----- (00450380) --------------------------------------------------------
void __fastcall CQuaternion::Get(const CQuaternion *this, float *pax, float *pay, float *paz)
{
  float x; // s18
  float z; // s0
  float y; // s20
  float v8; // s24
  float w; // s22
  float v12; // s30
  float v13; // s17
  float v14; // s19
  float v15; // r0
  float v16; // s27
  float v17; // r5
  float v18; // s29
  float v19; // s26
  float v20; // s0
  float v21; // r0
  float v22; // s0

  x = this->x;
  z = this->z;
  y = this->y;
  v8 = z + z;
  w = this->w;
  v12 = z * (float)(z + z);
  v13 = w * (float)(z + z);
  v14 = this->x * (float)(y + y);
  v15 = atan2f(v14 + v13, 1.0 - (float)((float)(x * (float)(x + x)) + v12));
  v16 = v15;
  if ( v15 < 0.0 )
    v16 = v15 + 6.2832;
  v17 = sinf(v16);
  v18 = cosf(v16);
  *paz = v16;
  v19 = (float)(x + x) * w;
  v20 = atan2f(
          -(float)((float)(y * v8) - v19),
          (float)((float)(v14 + (float)(w * (float)(z + z))) * v17)
        + (float)((float)(1.0 - (float)((float)(x * (float)(x + x)) + v12)) * v18));
  if ( v20 < 0.0 )
    v20 = v20 + 6.2832;
  *pax = v20;
  v21 = atan2f(
          -(float)((float)((float)((float)(x * v8) - (float)((float)(y + y) * w)) * v18)
                 - (float)((float)((float)(y * v8) + v19) * v17)),
          (float)((float)(1.0 - (float)((float)(y * (float)(y + y)) + v12)) * v18) - (float)((float)(v14 - v13) * v17));
  v22 = v21;
  if ( v21 < 0.0 )
    v22 = v21 + 6.2832;
  *pay = v22;
}

//----- (004504C8) --------------------------------------------------------
void __fastcall CQuaternion::Get(const CQuaternion *this, RwV3d_0 *pVec, float *fRotation)
{
  float v6; // r4
  float v7; // r0

  v6 = acosf(this->w + this->w);
  v7 = sinf(v6);
  *fRotation = v6;
  pVec->x = this->x * (float)(1.0 / v7);
  pVec->y = (float)(1.0 / v7) * this->y;
  pVec->z = (float)(1.0 / v7) * this->z;
}

//----- (00450526) --------------------------------------------------------
void __fastcall CQuaternion::Multiply(CQuaternion *this, const CQuaternion *quat1, const CQuaternion *quat2)
{
  float v3; // s0
  float v4; // s2
  float v5; // s4

  v3 = (float)(quat1->y * quat2->z) - (float)(quat2->y * quat1->z);
  this->x = v3;
  v4 = (float)(quat1->z * quat2->x) - (float)(quat2->z * quat1->x);
  this->y = v4;
  v5 = (float)(quat1->x * quat2->y) - (float)(quat2->x * quat1->y);
  this->z = v5;
  this->x = v3 + (float)((float)(quat1->x * quat2->w) + (float)(quat2->x * quat1->w));
  this->y = v4 + (float)((float)(quat1->y * quat2->w) + (float)(quat2->y * quat1->w));
  this->z = v5 + (float)((float)(quat1->z * quat2->w) + (float)(quat2->z * quat1->w));
  this->w = (float)(quat1->w * quat2->w)
          - (float)((float)((float)(quat1->x * quat2->x) + (float)(quat1->y * quat2->y)) + (float)(quat1->z * quat2->z));
}

//----- (00450634) --------------------------------------------------------
void __fastcall CQuaternion::Slerp(
        CQuaternion *this,
        const CQuaternion *quatStart,
        const CQuaternion *quatEnd,
        float fTheta,
        float fOOSinTheta,
        float fInterpValue)
{
  float v10; // s20
  float v11; // r8
  float v12; // r0

  if ( fTheta == 0.0 )
  {
    *this = *quatEnd;
  }
  else
  {
    if ( fTheta <= 1.5708 )
    {
      v11 = sinf((float)(1.0 - fInterpValue) * fTheta);
      v12 = sinf(fTheta * fInterpValue);
    }
    else
    {
      v10 = 3.1416 - fTheta;
      v11 = sinf((float)(3.1416 - fTheta) * (float)(1.0 - fInterpValue));
      LODWORD(v12) = COERCE_UNSIGNED_INT(sinf(v10 * fInterpValue)) ^ 0x80000000;
    }
    this->x = (float)((float)(v11 * fOOSinTheta) * quatStart->x) + (float)((float)(v12 * fOOSinTheta) * quatEnd->x);
    this->y = (float)((float)(v11 * fOOSinTheta) * quatStart->y) + (float)((float)(v12 * fOOSinTheta) * quatEnd->y);
    this->z = (float)((float)(v11 * fOOSinTheta) * quatStart->z) + (float)((float)(v12 * fOOSinTheta) * quatEnd->z);
    this->w = (float)((float)(v11 * fOOSinTheta) * quatStart->w) + (float)((float)(v12 * fOOSinTheta) * quatEnd->w);
  }
}

//----- (0045074C) --------------------------------------------------------
void __fastcall CQuaternion::Slerp(
        CQuaternion *this,
        const CQuaternion *quatStart,
        const CQuaternion *quatEnd,
        float fInterpValue)
{
  float32x2_t v4; // d0
  float32x2_t v5; // d11
  float x; // s16
  float v11; // s18
  float v12; // r0
  float v13; // s24
  float v14; // s20
  float v15; // s26
  float v16; // s24
  float v17; // r8
  float v18; // r0

  x = quatEnd->x;
  v5.n64_u32[0] = 1.0;
  v11 = quatStart->x;
  v4.n64_f32[0] = (float)((float)((float)(quatStart->x * quatEnd->x) + (float)(quatStart->y * quatEnd->y))
                        + (float)(quatStart->z * quatEnd->z))
                + (float)(quatStart->w * quatEnd->w);
  v12 = acosf(vmin_f32(v4, v5).n64_f32[0]);
  v13 = v12;
  if ( v12 == 0.0 )
    v14 = 0.0;
  else
    v14 = 1.0 / sinf(v12);
  if ( v13 == 0.0 )
  {
    this->x = x;
    this->y = quatEnd->y;
    this->z = quatEnd->z;
    this->w = quatEnd->w;
  }
  else
  {
    v15 = fInterpValue;
    if ( v13 <= 1.5708 )
    {
      v17 = sinf((float)(1.0 - fInterpValue) * v13);
      v18 = sinf(v13 * v15);
    }
    else
    {
      v16 = 3.1416 - v13;
      v17 = sinf((float)(1.0 - fInterpValue) * v16);
      LODWORD(v18) = COERCE_UNSIGNED_INT(sinf(v16 * v15)) ^ 0x80000000;
    }
    this->x = (float)((float)(v14 * v17) * v11) + (float)((float)(v14 * v18) * x);
    this->y = (float)((float)(v14 * v17) * quatStart->y) + (float)((float)(v14 * v18) * quatEnd->y);
    this->z = (float)((float)(v14 * v17) * quatStart->z) + (float)((float)(v14 * v18) * quatEnd->z);
    this->w = (float)((float)(v14 * v17) * quatStart->w) + (float)((float)(v14 * v18) * quatEnd->w);
  }
}
// 4507A0: variable 'v4' is possibly undefined
// 4507A0: variable 'v5' is possibly undefined

//----- (004508C4) --------------------------------------------------------
CVector *__fastcall CrossProduct(CVector *retstr, const CVector *v1, const CVector *v2)
{
  float y; // s2
  float z; // s10
  float v5; // s4
  float v6; // s8
  RwReal v7; // s12
  RwReal v8; // s2
  RwReal v9; // s0

  y = v2->y;
  z = v1->z;
  v5 = v2->z;
  v6 = v1->y;
  v7 = (float)(v6 * v5) - (float)(z * y);
  v8 = (float)(v1->x * y) - (float)(v6 * v2->x);
  v9 = (float)(z * v2->x) - (float)(v1->x * v5);
  retstr->x = v7;
  retstr->y = v9;
  retstr->z = v8;
  return retstr;
}

//----- (0045090E) --------------------------------------------------------
CVector *__fastcall Multiply3x3(CVector *retstr, const CMatrix *m, const CVector *v)
{
  float x; // s0
  float y; // s2
  float z; // s4

  x = v->x;
  y = v->y;
  z = v->z;
  retstr->x = (float)((float)(m->xx * v->x) + (float)(m->xy * y)) + (float)(m->xz * z);
  retstr->y = (float)((float)(m->yx * x) + (float)(m->yy * y)) + (float)(m->yz * z);
  retstr->z = (float)((float)(m->zx * x) + (float)(m->zy * y)) + (float)(m->zz * z);
  return retstr;
}

//----- (00450988) --------------------------------------------------------
CVector *__fastcall Multiply3x3(CVector *retstr, const CVector *v, const CMatrix *m)
{
  float x; // s0
  float y; // s2
  float z; // s4

  x = v->x;
  y = v->y;
  z = v->z;
  retstr->x = (float)((float)(m->xx * v->x) + (float)(m->yx * y)) + (float)(m->zx * z);
  retstr->y = (float)((float)(m->xy * x) + (float)(m->yy * y)) + (float)(m->zy * z);
  retstr->z = (float)((float)(m->xz * x) + (float)(m->yz * y)) + (float)(m->zz * z);
  return retstr;
}

//----- (00450A02) --------------------------------------------------------
void __fastcall CVector::FromMultiply(CVector *this, const CMatrix *m, const CVector *v)
{
  this->x = (float)((float)(m->tx + (float)(m->xx * v->x)) + (float)(m->xy * v->y)) + (float)(m->xz * v->z);
  this->y = (float)((float)(m->ty + (float)(m->yx * v->x)) + (float)(m->yy * v->y)) + (float)(m->yz * v->z);
  this->z = (float)((float)(m->tz + (float)(m->zx * v->x)) + (float)(m->zy * v->y)) + (float)(m->zz * v->z);
}

//----- (00450AAC) --------------------------------------------------------
void __fastcall CVector::FromMultiply3X3(CVector *this, const CMatrix *m, const CVector *v)
{
  this->x = (float)((float)(m->xx * v->x) + (float)(m->xy * v->y)) + (float)(m->xz * v->z);
  this->y = (float)((float)(m->yx * v->x) + (float)(m->yy * v->y)) + (float)(m->yz * v->z);
  this->z = (float)((float)(m->zx * v->x) + (float)(m->zy * v->y)) + (float)(m->zz * v->z);
}

//----- (00450B3E) --------------------------------------------------------
CVector *__fastcall operator*(CVector *retstr, const CMatrix *m, const CVector *v)
{
  float x; // s8
  float y; // s10
  float z; // s12

  x = v->x;
  y = v->y;
  z = v->z;
  retstr->x = m->tx + (float)((float)((float)(m->xx * v->x) + (float)(m->xy * y)) + (float)(m->xz * z));
  retstr->y = m->ty + (float)((float)((float)(m->yx * x) + (float)(m->yy * y)) + (float)(m->yz * z));
  retstr->z = m->tz + (float)((float)((float)(m->zx * x) + (float)(m->zy * y)) + (float)(m->zz * z));
  return retstr;
}

//----- (00450BD0) --------------------------------------------------------
void __fastcall CVector::Normalise(CVector *this)
{
  float x; // s0
  float y; // s4
  float z; // s2
  float v4; // s6
  float v5; // s6

  x = this->x;
  y = this->y;
  z = this->z;
  v4 = (float)((float)(x * x) + (float)(y * y)) + (float)(z * z);
  if ( v4 > 0.0 )
  {
    v5 = 1.0 / sqrtf(v4);
    this->x = x * v5;
    this->y = v5 * y;
    this->z = v5 * z;
  }
  else
  {
    this->x = 1.0;
  }
}

//----- (00450C28) --------------------------------------------------------
float __fastcall CVector::NormaliseAndMag(CVector *this)
{
  float x; // s0
  float y; // s4
  float z; // s2
  float v4; // s6
  float v5; // s10

  x = this->x;
  y = this->y;
  z = this->z;
  v4 = (float)((float)(x * x) + (float)(y * y)) + (float)(z * z);
  if ( v4 <= 0.0 )
  {
    this->x = 1.0;
    return 1.0;
  }
  else
  {
    v5 = 1.0 / sqrtf(v4);
    this->x = x * v5;
    this->y = v5 * y;
    this->z = v5 * z;
    return 1.0 / v5;
  }
}

//----- (00450C90) --------------------------------------------------------
UInt8 __fastcall FindCBFunctionID(CAnimBlendAssocationCallback F)
{
  int v1; // r1

  v1 = 0;
  while ( CBArray[v1] != F )
  {
    if ( v1++ >= 44 )
    {
      LOBYTE(v1) = 0;
      return v1;
    }
  }
  return v1;
}

//----- (00450CB4) --------------------------------------------------------
CAnimBlendAssocationCallback __fastcall FindCBFunction(UInt8 ID)
{
  return CBArray[ID];
}

//----- (00450CC4) --------------------------------------------------------
void __fastcall ApplyPanelDamageToCar(UInt32 PanelDamage, CAutomobile *pVeh, bool bDontSpawnStuff)
{
  uint32 m_Panels; // r0

  m_Panels = pVeh->Damage.m_Panels;
  if ( (m_Panels & 0xF) != (PanelDamage & 0xF) )
  {
    pVeh->Damage.m_Panels = m_Panels & 0xFFFFFFF0 | PanelDamage & 0xF;
    CAutomobile::SetPanelDamage(pVeh, FRONT_LEFT_PANEL, bDontSpawnStuff);
    m_Panels = pVeh->Damage.m_Panels;
  }
  if ( ((m_Panels ^ PanelDamage) & 0xF0) != 0 )
  {
    pVeh->Damage.m_Panels = m_Panels & 0xFFFFFF0F | (16 * ((unsigned __int8)PanelDamage >> 4));
    CAutomobile::SetPanelDamage(pVeh, FRONT_RIGHT_PANEL, bDontSpawnStuff);
    m_Panels = pVeh->Damage.m_Panels;
  }
  if ( ((m_Panels ^ PanelDamage) & 0xF00) != 0 )
  {
    m_Panels = m_Panels & 0xFFFFF0FF | (((PanelDamage >> 8) & 0xF) << 8);
    pVeh->Damage.m_Panels = m_Panels;
  }
  if ( ((m_Panels ^ PanelDamage) & 0xF000) != 0 )
  {
    m_Panels = m_Panels & 0xFFFF0FFF | ((unsigned __int16)PanelDamage >> 12 << 12);
    pVeh->Damage.m_Panels = m_Panels;
  }
  if ( ((m_Panels ^ PanelDamage) & 0xF0000) != 0 )
  {
    pVeh->Damage.m_Panels = m_Panels & 0xFFF0FFFF | ((HIWORD(PanelDamage) & 0xF) << 16);
    CAutomobile::SetPanelDamage(pVeh, WINDSCREEN_PANEL, bDontSpawnStuff);
    m_Panels = pVeh->Damage.m_Panels;
  }
  if ( ((m_Panels ^ PanelDamage) & 0xF00000) != 0 )
  {
    pVeh->Damage.m_Panels = m_Panels & 0xFF0FFFFF | (((PanelDamage >> 20) & 0xF) << 20);
    CAutomobile::SetBumperDamage(pVeh, FRONT_BUMPER, bDontSpawnStuff);
    m_Panels = pVeh->Damage.m_Panels;
  }
  if ( ((m_Panels ^ PanelDamage) & 0xF000000) != 0 )
  {
    pVeh->Damage.m_Panels = m_Panels & 0xF0FFFFFF | ((HIBYTE(PanelDamage) & 0xF) << 24);
    sub_194190(pVeh, REAR_BUMPER, bDontSpawnStuff);
  }
}

//----- (00450DB8) --------------------------------------------------------
void __fastcall CNetworkPC::CNetworkPC(CNetworkPC *this)
{
  this->_vptr$CBugstarNetwork = (int (**)(void))&off_667DAC;
}
// 667DAC: using guessed type void *;

//----- (00450DD0) --------------------------------------------------------
void __fastcall CNetworkPC::SetNetworkUp(bool val)
{
  CNetworkPC::sm_network_up = val;
}

//----- (00450DE0) --------------------------------------------------------
bool CNetworkPC::IsNetworkUp()
{
  return CNetworkPC::sm_network_up;
}

//----- (00450DF0) --------------------------------------------------------
int CNetworkPC::InitNetwork()
{
  return 1;
}

//----- (00450DF4) --------------------------------------------------------
int __fastcall CNetworkPC::_CheckError(CNetworkPC *this)
{
  return 0;
}

//----- (00450DF8) --------------------------------------------------------
int CNetworkPC::ShutdownNetwork()
{
  return 1;
}

//----- (00450DFC) --------------------------------------------------------
unsigned int __fastcall CNetworkPC::Connect(CNetworkPC *this, unsigned int port, unsigned __int8 *host)
{
  return 0;
}

//----- (00450E00) --------------------------------------------------------
unsigned int __fastcall CNetworkPC::Disconnect(CNetworkPC *this, int socket_id)
{
  return 1;
}

//----- (00450E04) --------------------------------------------------------
int __fastcall CNetworkPC::SendBytes(CNetworkPC *this, int socket_id, void *buffer, unsigned int size)
{
  return 0;
}

//----- (00450E08) --------------------------------------------------------
int __fastcall CNetworkPC::RecvBytes(CNetworkPC *this, int socket_id, void *buffer, unsigned int size)
{
  return 0;
}

//----- (00450E10) --------------------------------------------------------
void *__fastcall BreakableConstructor(void *geom, RwInt32 offset, RwInt32 size)
{
  if ( g_BreakablePlugin >= 1 )
    *(_DWORD *)((char *)geom + g_BreakablePlugin) = 0;
  return geom;
}

//----- (00450E28) --------------------------------------------------------
void *__fastcall BreakableDestructor(void *geom, RwInt32 offset, RwInt32 size)
{
  int v4; // r5
  unsigned __int16 v5; // r1
  int v6; // r6
  RwTexture_0 *v7; // r0

  if ( g_BreakablePlugin >= 1 )
  {
    v4 = *(_DWORD *)((char *)geom + g_BreakablePlugin);
    if ( v4 )
    {
      v5 = *(_WORD *)(v4 + 32);
      if ( v5 )
      {
        v6 = 0;
        do
        {
          v7 = *(RwTexture_0 **)(*(_DWORD *)(v4 + 36) + 4 * v6);
          if ( v7 )
          {
            RwTextureDestroy(v7);
            v5 = *(_WORD *)(v4 + 32);
          }
          ++v6;
        }
        while ( v6 < v5 );
      }
      operator delete((void *)v4);
    }
  }
  return geom;
}

//----- (00450E70) --------------------------------------------------------
RwStream_0 *__fastcall BreakableStreamWrite(
        RwStream_0 *pStream,
        RwInt32 len,
        const void *pData,
        RwInt32 offset,
        RwInt32 size)
{
  RwInt32 v7; // r6
  int v8; // r5

  v7 = g_BreakablePlugin;
  RwStreamWrite(pStream, (char *)pData + g_BreakablePlugin, 4u);
  v8 = *(_DWORD *)((char *)pData + v7);
  if ( v8 )
  {
    RwStreamWrite(pStream, (const void *)v8, 0x34u);
    RwStreamWrite(pStream, *(const void **)(v8 + 8), 12 * *(unsigned __int16 *)(v8 + 4));
    RwStreamWrite(pStream, *(const void **)(v8 + 12), 8 * *(unsigned __int16 *)(v8 + 4));
    RwStreamWrite(pStream, *(const void **)(v8 + 16), 4 * *(unsigned __int16 *)(v8 + 4));
    RwStreamWrite(pStream, *(const void **)(v8 + 24), 6 * *(unsigned __int16 *)(v8 + 20));
    RwStreamWrite(pStream, *(const void **)(v8 + 28), 2 * *(unsigned __int16 *)(v8 + 20));
    RwStreamWrite(pStream, *(const void **)(v8 + 40), 32 * *(unsigned __int16 *)(v8 + 32));
    RwStreamWrite(pStream, *(const void **)(v8 + 44), 32 * *(unsigned __int16 *)(v8 + 32));
    RwStreamWrite(pStream, *(const void **)(v8 + 48), 12 * *(unsigned __int16 *)(v8 + 32));
  }
  return pStream;
}

//----- (00450F18) --------------------------------------------------------
RwStream_0 *__fastcall BreakableStreamRead(RwStream_0 *pStream, RwInt32 len, void *pData, RwInt32 offset, RwInt32 size)
{
  RwInt32 v7; // r5
  char *v8; // r6
  int v9; // r10
  int v10; // r9
  int v11; // r11
  int v12; // r5
  __int64 v13; // d17
  __int64 v14; // d16
  __int64 v15; // d17
  __int64 v16; // d19
  int v17; // r0
  int v18; // r4
  int v19; // r6
  __int64 v20; // kr00_8
  const RwChar *v21; // r1
  const RwChar *v22; // r0
  int v24; // [sp+4h] [bp-7Ch]
  int v25; // [sp+8h] [bp-78h]
  int v26; // [sp+Ch] [bp-74h]
  int v27; // [sp+10h] [bp-70h]
  int v28; // [sp+14h] [bp-6Ch]
  int v29; // [sp+18h] [bp-68h]
  int v30; // [sp+1Ch] [bp-64h]
  int v31; // [sp+20h] [bp-60h]
  int v32; // [sp+24h] [bp-5Ch]
  int v33; // [sp+28h] [bp-58h]
  int v34; // [sp+2Ch] [bp-54h]
  _QWORD buffer[2]; // [sp+30h] [bp-50h] BYREF
  __int64 v36; // [sp+40h] [bp-40h]
  __int64 v37; // [sp+48h] [bp-38h]
  __int64 v38; // [sp+50h] [bp-30h]
  __int64 v39; // [sp+58h] [bp-28h]
  int v40; // [sp+60h] [bp-20h]

  v7 = g_BreakablePlugin;
  v8 = (char *)pData + g_BreakablePlugin;
  RwStreamRead(pStream, (char *)pData + g_BreakablePlugin, 4u);
  if ( *(_DWORD *)((char *)pData + v7) )
  {
    RwStreamRead(pStream, buffer, 0x34u);
    v9 = WORD2(buffer[0]);
    v10 = 3 * WORD2(buffer[0]);
    v29 = WORD2(v36);
    v30 = (unsigned __int16)v38;
    v24 = 12 * WORD2(buffer[0]) + 52;
    v25 = v24 + 8 * WORD2(buffer[0]);
    v27 = 3 * WORD2(v36);
    v28 = v25 + 4 * WORD2(buffer[0]) + 6 * WORD2(v36);
    v31 = v28 + 2 * WORD2(v36);
    v32 = v31 + 32 * (unsigned __int16)v38;
    v34 = 3 * (unsigned __int16)v38;
    v11 = v32 + 32 * (unsigned __int16)v38 + 12 * (unsigned __int16)v38;
    v26 = v25 + 4 * WORD2(buffer[0]);
    v33 = v32 + 32 * (unsigned __int16)v38;
    v12 = operator new[](v11 + 4 * (unsigned __int16)v38);
    *(_DWORD *)v8 = v12;
    *(_DWORD *)(v12 + 48) = v40;
    v13 = v39;
    *(_QWORD *)(v12 + 32) = v38;
    *(_QWORD *)(v12 + 40) = v13;
    v14 = buffer[0];
    v15 = buffer[1];
    v16 = v37;
    *(_QWORD *)(v12 + 16) = v36;
    *(_QWORD *)(v12 + 24) = v16;
    *(_QWORD *)v12 = v14;
    *(_QWORD *)(v12 + 8) = v15;
    *(_DWORD *)(v12 + 8) = v12 + 52;
    RwStreamRead(pStream, (void *)(v12 + 52), 4 * v10);
    *(_DWORD *)(v12 + 12) = v24 + v12;
    RwStreamRead(pStream, *(void **)(*(_DWORD *)v8 + 12), 8 * v9);
    *(_DWORD *)(v12 + 16) = v25 + v12;
    RwStreamRead(pStream, *(void **)(*(_DWORD *)v8 + 16), 4 * v9);
    *(_DWORD *)(v12 + 24) = v26 + v12;
    RwStreamRead(pStream, *(void **)(*(_DWORD *)v8 + 24), 2 * v27);
    *(_DWORD *)(v12 + 28) = v28 + v12;
    RwStreamRead(pStream, *(void **)(*(_DWORD *)v8 + 28), 2 * v29);
    *(_DWORD *)(v12 + 40) = v31 + v12;
    RwStreamRead(pStream, *(void **)(*(_DWORD *)v8 + 40), 32 * v30);
    *(_DWORD *)(v12 + 44) = v32 + v12;
    RwStreamRead(pStream, *(void **)(*(_DWORD *)v8 + 44), 32 * v30);
    *(_DWORD *)(v12 + 48) = v33 + v12;
    RwStreamRead(pStream, *(void **)(*(_DWORD *)v8 + 48), 4 * v34);
    v17 = *(unsigned __int16 *)(v12 + 32);
    *(_DWORD *)(v12 + 36) = v12 + v11;
    if ( v17 )
    {
      v18 = 0;
      v19 = 0;
      do
      {
        v20 = *(_QWORD *)(v12 + 40);
        v21 = (const RwChar *)*(unsigned __int8 *)(HIDWORD(v20) + v18);
        v22 = (const RwChar *)(v20 + v18);
        if ( *(_BYTE *)(HIDWORD(v20) + v18) )
          v21 = (const RwChar *)(HIDWORD(v20) + v18);
        v18 += 32;
        *(_DWORD *)(*(_DWORD *)(v12 + 36) + 4 * v19++) = RwTextureRead(v22, v21);
      }
      while ( v19 < *(unsigned __int16 *)(v12 + 32) );
    }
  }
  return pStream;
}

//----- (004510B0) --------------------------------------------------------
RwInt32 __fastcall BreakableStreamGetSize(const void *pData, RwInt32 offset, RwInt32 size)
{
  int v3; // r1
  RwInt32 result; // r0

  v3 = *(_DWORD *)((char *)pData + g_BreakablePlugin);
  result = 52;
  if ( !v3 )
    return 4;
  return result;
}

//----- (004510C8) --------------------------------------------------------
void __fastcall BreakableTransfer(RpAtomic_0 *one, RpAtomic_0 *two)
{
  *(_DWORD *)(&two->geometry->object.type + g_BreakablePlugin) = *(_DWORD *)(&one->geometry->object.type
                                                                           + g_BreakablePlugin);
}

//----- (004510E0) --------------------------------------------------------
bool BreakablePluginAttach()
{
  int v0; // r4

  v0 = 0;
  g_BreakablePlugin = RpGeometryRegisterPlugin(4, 0x253F2FDu, BreakableConstructor, BreakableDestructor, 0);
  if ( g_BreakablePlugin != -1 )
  {
    if ( RpGeometryRegisterPluginStream(0x253F2FDu, BreakableStreamRead, BreakableStreamWrite, BreakableStreamGetSize) < 0 )
    {
      v0 = 0;
      g_BreakablePlugin = -1;
    }
    else
    {
      return g_BreakablePlugin != -1;
    }
  }
  return v0;
}

//----- (00451174) --------------------------------------------------------
void __fastcall BreakObject_c::BreakObject_c(BreakObject_c *this)
{
  this->m_groups = 0;
  *(_WORD *)&this->m_smashed = 0;
}

//----- (00451180) --------------------------------------------------------
void __fastcall BreakObject_c::CalcGroupCenter(BreakObject_c *this, BreakGroup_t *group)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d8
  float32x2_t v4; // d11
  int m_numTris; // r0
  int v7; // r2
  float32x2_t v8; // d10
  float32x2_t v9; // d9
  RwReal *p_y; // r1
  float32x2_t v11; // d16
  float32x2_t v12; // d17
  float32x2_t v13; // d19
  float32x2_t v14; // d20
  float32x2_t v15; // d16
  float32x2_t v16; // d18
  float32x2_t v17; // d19
  float32x2_t v18; // d20
  float32x2_t v19; // d14
  float x; // s26
  int v21; // r0
  int v22; // r2
  BreakTri_t *v23; // r3
  float y; // s2
  float z; // s4
  float v26; // s0
  unsigned __int64 v27; // d1
  uint8 v28; // r0
  RwV3d_0 v29; // [sp+0h] [bp-58h] BYREF
  RwV3d_0 vectorIn; // [sp+Ch] [bp-4Ch] BYREF

  m_numTris = group->m_numTris;
  if ( group->m_numTris )
  {
    v7 = 0;
    v8.n64_u64[0] = 0x4B18967F4B18967FLL;
    v9.n64_u64[0] = 0xCB18967FCB18967FLL;
    v4.n64_u32[0] = 1259902591;
    v3.n64_u32[0] = -887581057;
    p_y = &group->m_tris->m_verts[1].y;
    do
    {
      v2.n64_f32[0] = *(p_y - 4);
      v11.n64_u64[0] = *(unsigned __int64 *)(p_y - 3);
      ++v7;
      v12.n64_u64[0] = vmax_f32(v11, v9).n64_u64[0];
      v13.n64_u64[0] = vmax_f32(v2, v3).n64_u64[0];
      v14.n64_u64[0] = vmin_f32(v2, v4).n64_u64[0];
      v2.n64_f32[0] = *(p_y - 1);
      v15.n64_u64[0] = vmin_f32(*(float32x2_t *)p_y, vmin_f32(v11, v8)).n64_u64[0];
      v16.n64_u64[0] = vmax_f32(v2, v13).n64_u64[0];
      v17.n64_u64[0] = *(unsigned __int64 *)(p_y + 3);
      v18.n64_u64[0] = vmin_f32(v2, v14).n64_u64[0];
      v2.n64_f32[0] = p_y[2];
      v9.n64_u64[0] = vmax_f32(v17, vmax_f32(*(float32x2_t *)p_y, v12)).n64_u64[0];
      p_y += 18;
      v8.n64_u64[0] = vmin_f32(v17, v15).n64_u64[0];
      v3.n64_u64[0] = vmax_f32(v2, v16).n64_u64[0];
      v4.n64_u64[0] = vmin_f32(v2, v18).n64_u64[0];
    }
    while ( v7 < m_numTris );
  }
  else
  {
    v8.n64_u64[0] = 0x4B18967F4B18967FLL;
    v9.n64_u64[0] = 0xCB18967FCB18967FLL;
    v4.n64_u32[0] = 1259902591;
    v3.n64_u32[0] = -887581057;
  }
  v19.n64_u64[0] = vmul_f32(vadd_f32(v9, v8), (float32x2_t)0x3F0000003F000000LL).n64_u64[0];
  x = (float)(v3.n64_f32[0] + v4.n64_f32[0]) * 0.5;
  *(float32x2_t *)&vectorIn.y = v19;
  vectorIn.x = x;
  if ( m_numTris )
  {
    v21 = 0;
    v22 = 0;
    do
    {
      ++v22;
      group->m_tris[v21].m_verts[0].x = group->m_tris[v21].m_verts[0].x - x;
      group->m_tris[v21].m_verts[0].y = group->m_tris[v21].m_verts[0].y - vectorIn.y;
      group->m_tris[v21].m_verts[0].z = group->m_tris[v21].m_verts[0].z - vectorIn.z;
      group->m_tris[v21].m_verts[1].x = group->m_tris[v21].m_verts[1].x - vectorIn.x;
      group->m_tris[v21].m_verts[1].y = group->m_tris[v21].m_verts[1].y - vectorIn.y;
      group->m_tris[v21].m_verts[1].z = group->m_tris[v21].m_verts[1].z - vectorIn.z;
      group->m_tris[v21].m_verts[2].x = group->m_tris[v21].m_verts[2].x - vectorIn.x;
      group->m_tris[v21].m_verts[2].y = group->m_tris[v21].m_verts[2].y - vectorIn.y;
      v23 = &group->m_tris[v21++];
      v23->m_verts[2].z = v23->m_verts[2].z - vectorIn.z;
      x = vectorIn.x;
    }
    while ( v22 < group->m_numTris );
    v19.n64_u64[0] = *(unsigned __int64 *)&vectorIn.y;
  }
  RwV3dTransformVector(&v29, &vectorIn, &group->m_mat);
  y = group->m_mat.pos.y;
  z = group->m_mat.pos.z;
  group->m_mat.pos.x = group->m_mat.pos.x + v29.x;
  group->m_mat.pos.y = y + v29.y;
  v26 = (float)(v3.n64_f32[0] - x) - (float)(v4.n64_f32[0] - x);
  v27 = vsub_f32(vsub_f32(v9, v19), vsub_f32(v8, v19)).n64_u64[0];
  group->m_mat.pos.z = z + v29.z;
  if ( v26 <= *(float *)&v27 )
  {
    v28 = 0;
LABEL_17:
    group->m_restAxisId = v28;
    group->m_restHeight = v26 * 0.5;
    return;
  }
  if ( *(float *)&v27 <= v26 )
  {
    v28 = 1;
    v26 = *(float *)&v27;
    goto LABEL_17;
  }
  if ( *((float *)&v27 + 1) <= *(float *)&v27 )
  {
    v26 = *((float *)&v27 + 1);
    v28 = 2;
    goto LABEL_17;
  }
}
// 4511C6: variable 'v2' is possibly undefined
// 4511C6: variable 'v3' is possibly undefined
// 4511CA: variable 'v4' is possibly undefined

//----- (004513D8) --------------------------------------------------------
void __fastcall BreakObject_c::SetGroupData(BreakObject_c *this, RwMatrix *objMat, RwV3d_0 *vel, float error)
{
  float v8; // s18
  int v9; // r4
  int32 v10; // r5
  __int64 v11; // d16
  __int64 v12; // d17
  __int64 v13; // d20
  __int64 v14; // d21
  __int64 v15; // d23
  BreakGroup_t *v16; // r0
  __int64 v17; // d18
  __int64 v18; // d19
  __int64 v19; // d16
  BreakGroup_t *v20; // r0
  float v21; // s0
  BreakGroup_t *v22; // r0
  float v23; // s0
  float v24; // s0
  int v25; // r0
  int v26; // r0
  int v27; // r0
  BreakGroup_t *v28; // r0

  if ( this->m_numGroups >= 1 )
  {
    v8 = error + error;
    v9 = 0;
    v10 = 0;
    while ( 1 )
    {
      v11 = *(_QWORD *)&objMat->right.x;
      v12 = *(_QWORD *)&objMat->right.z;
      v13 = *(_QWORD *)&objMat->up.x;
      v14 = *(_QWORD *)&objMat->up.z;
      v15 = *(_QWORD *)&objMat->pos.z;
      v16 = &this->m_groups[v9];
      v17 = *(_QWORD *)&objMat->at.x;
      v18 = *(_QWORD *)&objMat->at.z;
      *(_QWORD *)&v16->m_mat.pos.x = *(_QWORD *)&objMat->pos.x;
      *(_QWORD *)&v16->m_mat.pos.z = v15;
      *(_QWORD *)&v16->m_mat.at.x = v17;
      *(_QWORD *)&v16->m_mat.at.z = v18;
      *(_QWORD *)&v16->m_mat.right.x = v11;
      *(_QWORD *)&v16->m_mat.right.z = v12;
      v16 = (BreakGroup_t *)((char *)v16 + 16);
      *(_QWORD *)&v16->m_mat.right.x = v13;
      *(_QWORD *)&v16->m_mat.right.z = v14;
      BreakObject_c::CalcGroupCenter((BreakObject_c *)this->m_groups, &this->m_groups[v9]);
      if ( !vel )
        break;
      v19 = *(_QWORD *)&vel->x;
      v20 = &this->m_groups[v9];
      v20->m_vel.z = vel->z;
      *(_QWORD *)&v20->m_vel.x = v19;
      if ( error != 0.0 )
      {
        this->m_groups[v9].m_vel.x = this->m_groups[v9].m_vel.x
                                   + (float)((float)(v8 * (float)((float)rand() * 4.6566e-10)) - error);
        this->m_groups[v9].m_vel.y = this->m_groups[v9].m_vel.y
                                   + (float)((float)(v8 * (float)((float)rand() * 4.6566e-10)) - error);
        v21 = (float)rand();
        v22 = &this->m_groups[v9];
        v23 = v22->m_vel.z + (float)((float)(v8 * (float)(v21 * 4.6566e-10)) - error);
LABEL_7:
        v22->m_vel.z = v23;
      }
      this->m_groups[v9].m_spinSpeed = (float)((float)((float)rand() * 4.6566e-10) * 3.0) + 3.0;
      v25 = rand();
      this->m_groups[v9].m_spinAxis.x = (float)((float)((float)v25 * 4.6566e-10) + (float)((float)v25 * 4.6566e-10))
                                      + -1.0;
      v26 = rand();
      this->m_groups[v9].m_spinAxis.y = (float)((float)((float)v26 * 4.6566e-10) + (float)((float)v26 * 4.6566e-10))
                                      + -1.0;
      v27 = rand();
      this->m_groups[v9].m_spinAxis.z = (float)((float)((float)v27 * 4.6566e-10) + (float)((float)v27 * 4.6566e-10))
                                      + -1.0;
      RwV3dNormalize(&this->m_groups[v9].m_spinAxis, &this->m_groups[v9].m_spinAxis);
      ++v10;
      v28 = &this->m_groups[v9++];
      v28->m_atRest = 0;
      if ( v10 >= this->m_numGroups )
        return;
    }
    this->m_groups[v9].m_vel.x = (float)(v8 * (float)((float)rand() * 4.6566e-10)) - error;
    this->m_groups[v9].m_vel.y = (float)(v8 * (float)((float)rand() * 4.6566e-10)) - error;
    v24 = (float)rand();
    v22 = &this->m_groups[v9];
    v23 = (float)(v8 * (float)(v24 * 4.6566e-10)) - error;
    goto LABEL_7;
  }
}

//----- (004515F4) --------------------------------------------------------
void __fastcall BreakObject_c::SetBreakInfo(BreakObject_c *this, BreakInfo_t *pInfo, int32 breakStyle)
{
  float32x2_t v3; // d0
  float32x2_t v4; // d1
  float32x2_t v5; // d2
  float32x2_t v6; // d3
  float32x2_t v7; // d8
  int32 v8; // r6
  uint16 *p_numTris; // r0
  int m_numGroups; // r8
  BreakGroup_t *m_groups; // r0
  signed int v13; // r10
  unsigned int v14; // r3
  unsigned int v15; // r0
  signed int v16; // r2
  int8x16_t v17; // q8
  int32x4_t v18; // q9
  BreakObject_c *v19; // lr
  unsigned int v20; // r3
  uint16 *groupId; // r1
  unsigned int v22; // r4
  unsigned int v23; // r6
  int32x4_t v24; // q8
  int v25; // r1
  __int64 v26; // r0
  float v27; // s0
  BreakGroup_t *v28; // r0
  BreakInfo_t *v29; // r5
  int v30; // r12
  int v31; // r1
  int v32; // r11
  uint16 *vtxIndices; // r3
  BreakGroup_t *v34; // r0
  int v35; // lr
  int v36; // r6
  BreakTri_t *m_tris; // r1
  int m_numTris; // r0
  int v39; // r9
  int v40; // r10
  int v41; // r0
  float *v42; // r0
  float v43; // s22
  float v44; // s20
  float v45; // s18
  float32x2_t v46; // d3
  float32x2_t v47; // d3
  float32x2_t v48; // d3
  float32x2_t v49; // d3
  float32x2_t v50; // d3
  int v51; // r0
  int v52; // r1
  int v53; // r2
  int v54; // [sp+8h] [bp-58h]
  int32 v56; // [sp+10h] [bp-50h]
  uint16 *v57; // [sp+14h] [bp-4Ch]
  int v58; // [sp+14h] [bp-4Ch]

  v8 = breakStyle;
  p_numTris = &pInfo->numTris;
  v57 = &pInfo->numTris;
  if ( breakStyle != 1 )
    p_numTris = &pInfo->numGroups;
  m_numGroups = *p_numTris;
  this->m_numGroups = m_numGroups;
  m_groups = (BreakGroup_t *)operator new[](116 * m_numGroups);
  this->m_groups = m_groups;
  v56 = v8;
  if ( m_numGroups )
  {
    v13 = 0;
    while ( 1 )
    {
      m_groups[v13].m_numTris = 0;
      this->m_groups[v13].m_pTexture = 0;
      if ( v8 == 1 )
      {
        v14 = 1;
        goto LABEL_21;
      }
      v15 = *v57;
      if ( !*v57 )
      {
        v14 = 0;
        goto LABEL_21;
      }
      if ( v15 < 4 || (v16 = v15 - (v15 & 3), v15 == (v15 & 3)) )
      {
        v14 = 0;
        v16 = 0;
      }
      else
      {
        v17 = 0uLL;
        v18 = vdupq_n_s32(v13);
        v19 = this;
        v20 = v15 - (v15 & 3);
        groupId = pInfo->groupId;
        do
        {
          v22 = *((_DWORD *)groupId + 1);
          v20 -= 4;
          v23 = *(_DWORD *)groupId;
          groupId += 4;
          v17 = vsubq_s32(v17, vceqq_s32(v18, vmovl_u16((uint16x4_t)__PAIR64__(v22, v23))));
        }
        while ( v20 );
        v8 = v56;
        this = v19;
        v24 = vaddq_s32(v17, vextq_s8(v17, v17, 8u));
        v14 = vaddq_s32(v24, vdupq_lane_s32((int32x2_t)v24.n128_u64[0], 1)).n128_u32[0];
        if ( (v15 & 3) == 0 )
          goto LABEL_21;
      }
      do
      {
        v25 = pInfo->groupId[v16++];
        if ( v13 == v25 )
          ++v14;
      }
      while ( v16 < (int)v15 );
LABEL_21:
      v26 = 72LL * v14;
      if ( !is_mul_ok(0x48u, v14) )
        HIDWORD(v26) = 1;
      if ( HIDWORD(v26) )
        LODWORD(v26) = -1;
      this->m_groups[v13].m_tris = (BreakTri_t *)operator new[](v26);
      v27 = (float)(unsigned __int16)rand();
      v28 = &this->m_groups[v13++];
      v28->m_timer = (int)(float)((float)(v27 * 0.000015259) * 32.0) + 256;
      m_numGroups = this->m_numGroups;
      if ( v13 >= m_numGroups )
        break;
      m_groups = this->m_groups;
    }
  }
  v29 = pInfo;
  if ( *v57 )
  {
    v30 = 0;
    v7.n64_u32[0] = 1132396544;
    v31 = 0;
    do
    {
      v32 = v31;
      if ( v8 != 1 )
        v32 = v29->groupId[v31];
      v58 = v31;
      vtxIndices = v29->vtxIndices;
      v34 = &this->m_groups[v32];
      v35 = *(uint16 *)((char *)vtxIndices + v30 + 4);
      v36 = *(uint16 *)((char *)vtxIndices + v30 + 2);
      m_tris = v34->m_tris;
      m_numTris = v34->m_numTris;
      v54 = v30;
      v39 = m_numTris;
      v40 = *(uint16 *)((char *)vtxIndices + v30);
      m_tris[m_numTris].m_verts[0].x = v29->verts[3 * v40];
      this->m_groups[v32].m_tris[m_numTris].m_verts[0].y = v29->verts[3 * v40 + 1];
      this->m_groups[v32].m_tris[m_numTris].m_verts[0].z = v29->verts[3 * v40 + 2];
      this->m_groups[v32].m_tris[m_numTris].m_verts[1].x = v29->verts[3 * v36];
      this->m_groups[v32].m_tris[m_numTris].m_verts[1].y = v29->verts[3 * v36 + 1];
      this->m_groups[v32].m_tris[m_numTris].m_verts[1].z = v29->verts[3 * v36 + 2];
      this->m_groups[v32].m_tris[v39].m_verts[2].x = v29->verts[3 * v35];
      this->m_groups[v32].m_tris[v39].m_verts[2].y = v29->verts[3 * v35 + 1];
      this->m_groups[v32].m_tris[v39].m_verts[2].z = v29->verts[3 * v35 + 2];
      v41 = v32;
      if ( v56 == 1 )
        v41 = v29->groupId[v58];
      this->m_groups[v32].m_pTexture = v29->pTexture[v41];
      v42 = &v29->matCols[3 * v41];
      v43 = *v42;
      v44 = v42[1];
      v45 = v42[2];
      if ( CPostEffects::IsVisionFXActive() )
      {
        v3.n64_f32[0] = BreakObject_c::SetBreakInfo(BreakInfo_t *,int)::lastNonFXAmbB;
        v4.n64_f32[0] = BreakObject_c::SetBreakInfo(BreakInfo_t *,int)::lastNonFXAmbG;
        v5.n64_f32[0] = BreakObject_c::SetBreakInfo(BreakInfo_t *,int)::lastNonFXAmbR;
      }
      else
      {
        v5.n64_f32[0] = AmbientLightColourForFrame.red * 255.0;
        v4.n64_f32[0] = AmbientLightColourForFrame.green * 255.0;
        v3.n64_f32[0] = AmbientLightColourForFrame.blue * 255.0;
        BreakObject_c::SetBreakInfo(BreakInfo_t *,int)::lastNonFXAmbR = AmbientLightColourForFrame.red * 255.0;
        BreakObject_c::SetBreakInfo(BreakInfo_t *,int)::lastNonFXAmbG = AmbientLightColourForFrame.green * 255.0;
        BreakObject_c::SetBreakInfo(BreakInfo_t *,int)::lastNonFXAmbB = AmbientLightColourForFrame.blue * 255.0;
      }
      v29 = pInfo;
      v30 = v54 + 6;
      v6.n64_f32[0] = v5.n64_f32[0] + (float)(v43 * (float)pInfo->preLitCols[4 * v40]);
      v46.n64_u64[0] = vmin_f32(v6, v7).n64_u64[0];
      this->m_groups[v32].m_tris[v39].m_col[0]._anon_0._anon_0.red = (unsigned int)v46.n64_f32[0];
      v46.n64_f32[0] = v4.n64_f32[0] + (float)(v44 * (float)pInfo->preLitCols[(4 * v40) | 1]);
      v47.n64_u64[0] = vmin_f32(v46, v7).n64_u64[0];
      this->m_groups[v32].m_tris[v39].m_col[0]._anon_0._anon_0.green = (unsigned int)v47.n64_f32[0];
      v47.n64_f32[0] = v3.n64_f32[0] + (float)(v45 * (float)pInfo->preLitCols[(4 * v40) | 2]);
      v48.n64_u64[0] = vmin_f32(v47, v7).n64_u64[0];
      this->m_groups[v32].m_tris[v39].m_col[0]._anon_0._anon_0.blue = (unsigned int)v48.n64_f32[0];
      v48.n64_f32[0] = v5.n64_f32[0] + (float)(v43 * (float)pInfo->preLitCols[4 * v36]);
      v49.n64_u64[0] = vmin_f32(v48, v7).n64_u64[0];
      this->m_groups[v32].m_tris[v39].m_col[1]._anon_0._anon_0.red = (unsigned int)v49.n64_f32[0];
      v49.n64_f32[0] = v4.n64_f32[0] + (float)(v44 * (float)pInfo->preLitCols[(4 * v36) | 1]);
      v50.n64_u64[0] = vmin_f32(v49, v7).n64_u64[0];
      this->m_groups[v32].m_tris[v39].m_col[1]._anon_0._anon_0.green = (unsigned int)v50.n64_f32[0];
      v50.n64_f32[0] = v3.n64_f32[0] + (float)(v45 * (float)pInfo->preLitCols[(4 * v36) | 2]);
      v6.n64_u64[0] = vmin_f32(v50, v7).n64_u64[0];
      this->m_groups[v32].m_tris[v39].m_col[1]._anon_0._anon_0.blue = (unsigned int)v6.n64_f32[0];
      v5.n64_f32[0] = v5.n64_f32[0] + (float)(v43 * (float)pInfo->preLitCols[4 * v35]);
      v5.n64_u64[0] = vmin_f32(v5, v7).n64_u64[0];
      this->m_groups[v32].m_tris[v39].m_col[2]._anon_0._anon_0.red = (unsigned int)v5.n64_f32[0];
      v4.n64_f32[0] = v4.n64_f32[0] + (float)(v44 * (float)pInfo->preLitCols[(4 * v35) | 1]);
      v4.n64_u64[0] = vmin_f32(v4, v7).n64_u64[0];
      this->m_groups[v32].m_tris[v39].m_col[2]._anon_0._anon_0.green = (unsigned int)v4.n64_f32[0];
      v3.n64_f32[0] = v3.n64_f32[0] + (float)(v45 * (float)pInfo->preLitCols[(4 * v35) | 2]);
      v3.n64_u64[0] = vmin_f32(v3, v7).n64_u64[0];
      this->m_groups[v32].m_tris[v39].m_col[2]._anon_0._anon_0.blue = (unsigned int)v3.n64_f32[0];
      this->m_groups[v32].m_tris[v39].m_texCoords[0].u = pInfo->texCoords[2 * v40];
      this->m_groups[v32].m_tris[v39].m_texCoords[0].v = *(RwReal *)((char *)pInfo->texCoords + ((8 * v40) | 4));
      this->m_groups[v32].m_tris[v39].m_texCoords[1].u = pInfo->texCoords[2 * v36];
      this->m_groups[v32].m_tris[v39].m_texCoords[1].v = *(RwReal *)((char *)pInfo->texCoords + ((8 * v36) | 4));
      this->m_groups[v32].m_tris[v39].m_texCoords[2].u = pInfo->texCoords[2 * v35];
      this->m_groups[v32].m_tris[v39].m_texCoords[2].v = *(RwReal *)((char *)pInfo->texCoords + ((8 * v35) | 4));
      ++this->m_groups[v32].m_numTris;
      v8 = v56;
      v31 = v58 + 1;
    }
    while ( v58 + 1 < pInfo->numTris );
    m_numGroups = this->m_numGroups;
  }
  if ( m_numGroups >= 1 )
  {
    v51 = 0;
    v52 = 84;
    do
    {
      ++v51;
      v53 = *(_DWORD *)((char *)&this->m_groups->m_mat.right.x + v52);
      v52 += 116;
      if ( v53 )
      {
        ++*(_DWORD *)(v53 + 84);
        m_numGroups = this->m_numGroups;
      }
    }
    while ( v51 < m_numGroups );
  }
}
// 451922: variable 'v6' is possibly undefined
// 451922: variable 'v7' is possibly undefined
// 451A58: variable 'v5' is possibly undefined
// 451A8E: variable 'v4' is possibly undefined
// 451AC4: variable 'v3' is possibly undefined

//----- (00451BD0) --------------------------------------------------------
int __fastcall BreakObject_c::Init(BreakObject_c *this, CObject *pObj, RwV3d_0 *vel, float error, int32 breakStyle)
{
  RwObject_0 *m_pRwObject; // r11
  int v10; // r6
  RwInt32 v11; // r10
  BreakInfo_t *v12; // r1
  RwMatrix *LTM; // r11
  CColModel *m_pColModel; // r0
  float z; // s4
  float x; // s0
  float v17; // s10
  float v18; // s6
  __int64 v19; // d16
  float v20; // s2
  int v22; // [sp+1Ch] [bp-5Ch]
  CVector v; // [sp+20h] [bp-58h] BYREF
  CEntity *refEntityPtr; // [sp+2Ch] [bp-4Ch] BYREF
  CColPoint v25; // [sp+30h] [bp-48h] BYREF

  m_pRwObject = pObj->m_pRwObject;
  if ( !m_pRwObject || m_pRwObject->type != 1 )
    return 0;
  v10 = 0;
  v11 = g_BreakablePlugin;
  v12 = *(BreakInfo_t **)(*(_DWORD *)&m_pRwObject[3].type + g_BreakablePlugin);
  if ( v12 )
  {
    v22 = *(_DWORD *)&m_pRwObject[3].type;
    BreakObject_c::SetBreakInfo(this, v12, breakStyle);
    LTM = RwFrameGetLTM((RwFrame_0 *)m_pRwObject->parent);
    BreakObject_c::SetGroupData(this, LTM, vel, error);
    this->m_active = 1;
    this->m_smashed = breakStyle;
    this->m_age = 0;
    this->m_produceSparks = pObj->m_pObjectInfo->m_produceSparks;
    this->m_drawLast = (*(_DWORD *)&pObj->m_nFlags & 0x4000) != 0;
    if ( **(_DWORD **)(v22 + v11) )
    {
      m_pColModel = CModelInfo::ms_modelInfoPtrs[pObj->m_nModelIndex]->m_pColModel;
      z = m_pColModel->m_boxBound.m_vecMin.z;
      x = m_pColModel->m_boxBound.m_vecMin.x;
      v17 = m_pColModel->m_boxBound.m_vecMax.z - z;
      v18 = m_pColModel->m_boxBound.m_vecMax.x - m_pColModel->m_boxBound.m_vecMin.x;
      v.y = m_pColModel->m_boxBound.m_vecMin.y
          + (float)((float)(m_pColModel->m_boxBound.m_vecMax.y - m_pColModel->m_boxBound.m_vecMin.y) * 0.5);
      v.x = x + (float)(v18 * 0.5);
      v.z = (float)(z + (float)(v17 * 0.5)) + 0.25;
      operator*(&v25.m_vecPosition, pObj->m_pMat, &v);
      v = v25.m_vecPosition;
    }
    else
    {
      v19 = *(_QWORD *)&LTM->pos.x;
      v.z = LTM->pos.z;
      *(_QWORD *)&v.x = v19;
      v.z = v.z + (float)(CModelInfo::ms_modelInfoPtrs[pObj->m_nModelIndex]->m_pColModel->m_boxBound.m_vecMin.z + 0.25);
    }
    if ( CWorld::ProcessVerticalLine(&v, -1000.0, &v25, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0) )
    {
      this->m_groundZ = v25.m_vecPosition.z;
      *(_QWORD *)&this->m_groundNormal.x = *(_QWORD *)&v25.m_vecNormal.x;
      v20 = fabsf(this->m_groundNormal.x);
      this->m_groundNormal.z = v25.m_vecNormal.z;
      if ( v20 < 0.01 && fabsf(this->m_groundNormal.y) < 0.01 && fabsf(this->m_groundNormal.z) < 0.01 )
      {
        this->m_groundNormal.x = 0.0;
        this->m_groundNormal.y = 0.0;
        this->m_groundNormal.z = 1.0;
      }
    }
    else
    {
      *(_QWORD *)&this->m_groundZ = 3296329728LL;
      *(_QWORD *)&this->m_groundNormal.y = 0x3F80000000000000LL;
    }
    return 1;
  }
  return v10;
}

//----- (00451DE0) --------------------------------------------------------
void __fastcall BreakObject_c::Exit(BreakObject_c *this)
{
  BreakGroup_t *m_groups; // r0
  int v3; // r6
  int32 v4; // r5

  m_groups = this->m_groups;
  if ( m_groups )
  {
    if ( this->m_numGroups < 1 )
    {
      operator delete[](m_groups);
    }
    else
    {
      v3 = 84;
      v4 = 0;
      do
      {
        if ( *(_DWORD *)((char *)&m_groups->m_mat.right.x + v3) )
        {
          RwTextureDestroy(*(RwTexture_0 **)((char *)&m_groups->m_mat.right.x + v3));
          *(RwReal *)((char *)&this->m_groups->m_mat.right.x + v3) = 0.0;
          m_groups = this->m_groups;
        }
        if ( *(_DWORD *)((char *)m_groups + v3 - 4) )
        {
          operator delete[](*(void **)((char *)m_groups + v3 - 4));
          m_groups = this->m_groups;
        }
        ++v4;
        v3 += 116;
      }
      while ( v4 < this->m_numGroups );
      if ( m_groups )
        operator delete[](m_groups);
    }
  }
  this->m_active = 0;
}

//----- (00451E40) --------------------------------------------------------
void __fastcall BreakObject_c::DoCollisionResponse(
        BreakObject_c *this,
        BreakGroup_t *group,
        float timeStep,
        RwV3d_0 *groundNormal,
        float groundZ)
{
  float x; // s0
  float y; // s2
  float v10; // s8
  float z; // s4
  float v12; // s10
  float v13; // s12
  float v14; // s12
  RwReal v15; // s0
  int v16; // r0
  int v17; // r0
  int v18; // r0
  float v19; // r6
  RwReal v20; // s2
  RwReal v21; // s4
  RwReal v22; // s6
  float m_restHeight; // s12
  RwV3d_0 *p_pos; // r6
  int v25; // r8
  __int64 v26; // d16
  int v27; // r0
  RwReal v28; // r0
  __int64 v29; // d16
  CVector vecMoveSpeed; // [sp+4h] [bp-ACh] BYREF
  BreakObject_c *v31; // [sp+20h] [bp-90h]
  CVector dir; // [sp+24h] [bp-8Ch] BYREF
  CVector pos; // [sp+30h] [bp-80h] BYREF
  FxPrtMult_c fxMults; // [sp+3Ch] [bp-74h] BYREF
  RwV3d_0 in; // [sp+58h] [bp-58h] BYREF
  RwV3d_0 v36; // [sp+64h] [bp-4Ch] BYREF

  x = group->m_vel.x;
  y = group->m_vel.y;
  v10 = groundNormal->y;
  z = group->m_vel.z;
  v12 = groundNormal->z;
  v13 = (float)((float)(groundNormal->x * x) + (float)(v10 * y)) + (float)(z * v12);
  v14 = (float)(v13 + v13) * 0.85;
  v15 = x - (float)(groundNormal->x * v14);
  v36.y = y - (float)(v10 * v14);
  v36.x = v15;
  v36.z = z - (float)(v14 * v12);
  v16 = rand();
  in.x = (float)((float)((float)v16 * 4.6566e-10) + (float)((float)v16 * 4.6566e-10)) + -1.0;
  v17 = rand();
  in.y = (float)((float)((float)v17 * 4.6566e-10) + (float)((float)v17 * 4.6566e-10)) + -1.0;
  v18 = rand();
  in.z = (float)((float)((float)v18 * 4.6566e-10) + (float)((float)v18 * 4.6566e-10)) + -1.0;
  RwV3dNormalize(&in, &in);
  in.x = (float)(timeStep * 0.05) * in.x;
  in.y = (float)(timeStep * 0.05) * in.y;
  in.z = (float)(timeStep * 0.05) * in.z;
  v19 = RwV3dLength(&v36);
  v36.x = v36.x + in.x;
  v36.y = v36.y + in.y;
  v36.z = v36.z + in.z;
  RwV3dNormalize(&v36, &v36);
  v36.x = v19 * v36.x;
  v20 = v36.x * 0.8;
  v36.y = v19 * v36.y;
  v21 = v36.y * 0.8;
  v36.z = v19 * v36.z;
  v22 = v36.z * 0.8;
  m_restHeight = group->m_restHeight;
  group->m_spinSpeed = 0.0;
  group->m_vel.x = v20;
  group->m_vel.y = v21;
  group->m_vel.z = v22;
  group->m_mat.pos.z = m_restHeight + groundZ;
  if ( v19 >= 0.05 )
  {
LABEL_4:
    if ( this->m_smashed )
      return;
    goto LABEL_5;
  }
  group->m_atRest = 1;
  if ( this->m_smashed )
  {
    group->m_timer = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 32.0) + 32;
    goto LABEL_4;
  }
LABEL_5:
  p_pos = &group->m_mat.pos;
  v31 = this;
  FxPrtMult_c::FxPrtMult_c(&fxMults, 1.0, 1.0, 1.0, 0.1, 0.3, 0.0, 0.15);
  v25 = 4;
  do
  {
    v26 = *(_QWORD *)&p_pos->x;
    pos.z = group->m_mat.pos.z;
    *(_QWORD *)&pos.x = v26;
    pos.x = *(float *)&v26 + (float)((float)((float)rand() * 4.6566e-10) + -0.5);
    pos.y = pos.y + (float)((float)((float)rand() * 4.6566e-10) + -0.5);
    dir.x = (float)((float)((float)rand() * 4.6566e-10) * 0.3) + -0.15;
    v27 = rand();
    dir.z = 0.0;
    dir.y = (float)((float)((float)v27 * 4.6566e-10) * 0.3) + -0.15;
    FxSystem_c::AddParticle(g_fx.m_fxSysSmoke2, &pos, &dir, 0.0, &fxMults, -1.0, 1.2, 0.6, 0);
    --v25;
  }
  while ( v25 );
  if ( v31->m_produceSparks )
  {
    v28 = RwV3dLength(&group->m_vel);
    v29 = *(_QWORD *)&p_pos->x;
    pos.z = group->m_mat.pos.z;
    *(_QWORD *)&pos.x = v29;
    dir.x = 0.0;
    dir.y = 0.0;
    dir.z = 1.0;
    memset(&vecMoveSpeed, 0, sizeof(vecMoveSpeed));
    Fx_c::AddSparks(&g_fx, &pos, &dir, 2.0, (int)(float)(v28 * 100.0), vecMoveSpeed, 1, 0.4, 1.0);
  }
}

//----- (004521E4) --------------------------------------------------------
void __fastcall BreakObject_c::DoCollision(BreakObject_c *this, BreakGroup_t *group, float timeStep)
{
  float m_groundZ; // s0

  m_groundZ = this->m_groundZ;
  if ( (float)(group->m_mat.pos.z - group->m_restHeight) < m_groundZ )
    BreakObject_c::DoCollisionResponse(this, group, timeStep, &this->m_groundNormal, m_groundZ);
}

//----- (00452218) --------------------------------------------------------
void __fastcall BreakObject_c::Update(BreakObject_c *this, float timeStep)
{
  int32 m_numGroups; // r1
  RwV3d_0 *p_m_groundNormal; // r6
  int v6; // r10
  int v7; // r5
  int32 i; // r8
  BreakGroup_t *m_groups; // r0
  __int64 v10; // r0
  int v11; // r1
  float *v12; // r9
  float x; // s28
  float v14; // s23
  float y; // s30
  float v16; // s17
  float z; // s21
  float v18; // s19
  char *v19; // r0
  char *v20; // r0
  BreakGroup_t *v21; // r0
  BreakGroup_t *v22; // r0
  int v23; // r6
  int32 v24; // r5
  __int64 v25; // [sp+8h] [bp-78h]
  int v26; // [sp+10h] [bp-70h]
  RwV3d_0 in; // [sp+14h] [bp-6Ch] BYREF

  m_numGroups = this->m_numGroups;
  if ( m_numGroups < 1 )
    goto LABEL_22;
  p_m_groundNormal = &this->m_groundNormal;
  v6 = 1;
  v7 = 112;
  for ( i = 0; i < m_numGroups; ++i )
  {
    m_groups = this->m_groups;
    if ( !*((_BYTE *)m_groups + v7 - 36) )
    {
      *(float *)((char *)m_groups + v7 - 40) = *(float *)((char *)m_groups + v7 - 40) - (float)(timeStep * 0.008);
      *(float *)((char *)this->m_groups + v7 - 64) = *(float *)((char *)this->m_groups + v7 - 64)
                                                   + (float)(*(float *)((char *)this->m_groups + v7 - 48) * timeStep);
      *(float *)((char *)this->m_groups + v7 - 60) = *(float *)((char *)this->m_groups + v7 - 60)
                                                   + (float)(*(float *)((char *)this->m_groups + v7 - 44) * timeStep);
      *(float *)((char *)this->m_groups + v7 - 56) = *(float *)((char *)this->m_groups + v7 - 56)
                                                   + (float)(*(float *)((char *)this->m_groups + v7 - 40) * timeStep);
      v10 = *(_QWORD *)&this->m_groups;
      if ( SHIDWORD(v10) > 4 )
      {
        v11 = *(unsigned __int8 *)(v10 + v7 - 24);
        if ( v11 == 2 )
        {
          v12 = (float *)(v10 + v7 - 80);
        }
        else if ( v11 == 1 )
        {
          v12 = (float *)(v10 + 116 * i + 16);
        }
        else if ( *(_BYTE *)(v10 + v7 - 24) )
        {
          v12 = 0;
        }
        else
        {
          v12 = (float *)(v10 + 116 * i);
        }
        x = this->m_groundNormal.x;
        v14 = v12[1];
        y = this->m_groundNormal.y;
        v16 = v12[2];
        z = this->m_groundNormal.z;
        v18 = acosf((float)((float)(x * *v12) + (float)(y * v14)) + (float)(z * v16));
        if ( fabsf(v18) > 0.01 )
        {
          in.x = (float)(z * v14) - (float)(y * v16);
          in.y = (float)(x * v16) - (float)(z * *v12);
          in.z = (float)(y * *v12) - (float)(x * v12[1]);
          RwV3dNormalize(&in, &in);
          v19 = (char *)this->m_groups + v7;
          v26 = *((_DWORD *)v19 - 14);
          v25 = *((_QWORD *)v19 - 8);
          RwMatrixRotate(
            (RwMatrix *)(v19 - 112),
            &in,
            (float)((float)((float)(v18 * 180.0) / 3.1416) * 0.05) * timeStep,
            rwCOMBINEPOSTCONCAT);
          v20 = (char *)this->m_groups + v7;
          *((_DWORD *)v20 - 14) = v26;
          *((_QWORD *)v20 - 8) = v25;
        }
      }
      else
      {
        RwMatrixRotate(
          (RwMatrix *)(v10 + v7 - 112),
          (const RwV3d_0 *)(v10 + v7 - 12),
          *(float *)(v10 + v7 - 16) * timeStep,
          rwCOMBINEPRECONCAT);
      }
      m_groups = this->m_groups;
      if ( (float)(*(float *)((char *)m_groups + v7 - 56) - *(float *)((char *)m_groups + v7 - 20)) < this->m_groundZ )
      {
        BreakObject_c::DoCollisionResponse(
          this,
          (BreakGroup_t *)((char *)m_groups + v7 - 112),
          timeStep,
          p_m_groundNormal,
          this->m_groundZ);
        m_groups = this->m_groups;
      }
    }
    --*(_DWORD *)((char *)&m_groups->m_mat.right.x + v7);
    v21 = this->m_groups;
    if ( *(int *)((char *)&v21->m_mat.right.x + v7) <= 0 )
      *(RwReal *)((char *)&v21->m_mat.right.x + v7) = 0.0;
    else
      v6 = 0;
    m_numGroups = this->m_numGroups;
    v7 += 116;
  }
  if ( v6 << 24 )
  {
LABEL_22:
    v22 = this->m_groups;
    if ( v22 )
    {
      if ( m_numGroups < 1 )
      {
        operator delete[](v22);
      }
      else
      {
        v23 = 84;
        v24 = 0;
        do
        {
          if ( *(_DWORD *)((char *)&v22->m_mat.right.x + v23) )
          {
            RwTextureDestroy(*(RwTexture_0 **)((char *)&v22->m_mat.right.x + v23));
            *(RwReal *)((char *)&this->m_groups->m_mat.right.x + v23) = 0.0;
            v22 = this->m_groups;
          }
          if ( *(_DWORD *)((char *)v22 + v23 - 4) )
          {
            operator delete[](*(void **)((char *)v22 + v23 - 4));
            v22 = this->m_groups;
          }
          ++v24;
          v23 += 116;
        }
        while ( v24 < this->m_numGroups );
        if ( v22 )
          operator delete[](v22);
      }
    }
    this->m_active = 0;
  }
  ++this->m_age;
}

//----- (004524B8) --------------------------------------------------------
void __fastcall BreakObject_c::Render(BreakObject_c *this, bool8 renderAlphas)
{
  unsigned int v3; // r5
  int32 v4; // r8
  RwTexture_0 *m_pTexture; // r0
  RwRaster_0 *raster; // r6
  BreakGroup_t *m_groups; // r0
  int v8; // r6
  int32 v9; // r2
  BreakGroup_t *v10; // r0
  int m_timer; // r5
  float *v12; // r0
  float v13; // s0
  float v14; // s2
  float v15; // s4
  float v16; // s6
  float v17; // s8
  float v18; // s10
  Int32 v19; // r9
  Int32 v20; // r10
  Int32 b1; // lr
  int v22; // r1
  Int32 r2; // r6
  Int32 v24; // r8
  Int32 r3; // r11
  char v26; // r0
  Int32 a2; // r0
  Int32 g2; // [sp+40h] [bp-80h]
  Int32 b3; // [sp+54h] [bp-6Ch]
  RwRaster_0 *v30; // [sp+60h] [bp-60h]
  RwMatrix *matrix; // [sp+64h] [bp-5Ch]
  int v32; // [sp+68h] [bp-58h]
  int i; // [sp+6Ch] [bp-54h]
  Int32 g1; // [sp+70h] [bp-50h]
  Int32 r1; // [sp+74h] [bp-4Ch]
  RwV3d_0 pointsOut; // [sp+80h] [bp-40h] BYREF
  float v37; // [sp+8Ch] [bp-34h]
  float v38; // [sp+90h] [bp-30h]
  float v39; // [sp+94h] [bp-2Ch]
  float v40; // [sp+98h] [bp-28h]
  float v41; // [sp+9Ch] [bp-24h]
  float v42; // [sp+A0h] [bp-20h]

  if ( this->m_drawLast == renderAlphas && this->m_numGroups >= 1 )
  {
    v3 = 0;
    v4 = 0;
    do
    {
      m_pTexture = this->m_groups[v4].m_pTexture;
      if ( m_pTexture )
        raster = m_pTexture->raster;
      else
        raster = 0;
      if ( (RwRaster_0 *)v3 != raster )
      {
        RenderEnd();
        RenderBegin(raster, 0, 1u);
        v3 = (unsigned int)raster;
      }
      if ( !((unsigned int)raster | v3) )
      {
        RenderEnd();
        v3 = 0;
        RenderBegin(0, 0, 1u);
      }
      v30 = (RwRaster_0 *)v3;
      m_groups = this->m_groups;
      matrix = &m_groups[v4].m_mat;
      if ( HIWORD(matrix[1].flags) )
      {
        v8 = 0;
        for ( i = HIWORD(matrix[1].flags) - 1; ; --i )
        {
          RwV3dTransformPoints(&pointsOut, (const RwV3d_0 *)((char *)m_groups[v4].m_tris->m_verts + v8), 3, matrix);
          v9 = v4;
          v10 = &this->m_groups[v4];
          m_timer = v10->m_timer;
          v12 = (float *)((char *)v10->m_tris + v8);
          v32 = v8;
          v13 = v12[9];
          v14 = v12[10];
          v15 = v12[11];
          v16 = v12[12];
          v17 = v12[13];
          v18 = v12[14];
          r1 = *((unsigned __int8 *)v12 + 60);
          g1 = *((unsigned __int8 *)v12 + 61);
          v19 = *((unsigned __int8 *)v12 + 66);
          v20 = *((unsigned __int8 *)v12 + 69);
          b1 = *((unsigned __int8 *)v12 + 62);
          v22 = 31;
          r2 = *((unsigned __int8 *)v12 + 64);
          v24 = *((unsigned __int8 *)v12 + 65);
          r3 = *((unsigned __int8 *)v12 + 68);
          b3 = *((unsigned __int8 *)v12 + 70);
          v26 = 3;
          g2 = v24;
          v4 = v9;
          if ( !this->m_smashed )
            v26 = 1;
          a2 = m_timer << v26;
          if ( !this->m_smashed )
            v22 = 127;
          a2 = (unsigned __int8)a2;
          if ( m_timer > v22 )
            a2 = 255;
          RenderAddTri(
            pointsOut.x,
            pointsOut.y,
            pointsOut.z,
            v37,
            v38,
            v39,
            v40,
            v41,
            v42,
            v13,
            v14,
            v15,
            v16,
            v17,
            v18,
            r1,
            g1,
            b1,
            a2,
            r2,
            g2,
            v19,
            a2,
            r3,
            v20,
            b3,
            a2);
          if ( !i )
            break;
          m_groups = this->m_groups;
          v8 = v32 + 72;
        }
      }
      ++v4;
      v3 = (unsigned int)v30;
    }
    while ( v4 < this->m_numGroups );
    RenderEnd();
  }
}

//----- (00452660) --------------------------------------------------------
void __fastcall BreakManager_c::BreakManager_c(BreakManager_c *this)
{
  BreakManager_c *v1; // r3

  v1 = this;
  do
  {
    v1->m_breakObjects[0].m_groups = 0;
    *(_WORD *)&v1->m_breakObjects[0].m_smashed = 0;
    v1 = (BreakManager_c *)((char *)v1 + 32);
  }
  while ( v1 != &this[1] );
}

//----- (00452676) --------------------------------------------------------
bool8 __fastcall BreakManager_c::Init(BreakManager_c *this)
{
  return 1;
}

//----- (0045267C) --------------------------------------------------------
void __fastcall BreakManager_c::Update(BreakManager_c *this, float timeStep)
{
  int i; // r6

  for ( i = 0; i != 64; ++i )
  {
    if ( this->m_breakObjects[i].m_active )
      BreakObject_c::Update(&this->m_breakObjects[i], timeStep);
  }
}

//----- (004526A6) --------------------------------------------------------
void __fastcall BreakManager_c::Render(BreakManager_c *this, bool8 renderAlphas)
{
  int v4; // r6

  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, (char *)&dword_0 + 1);
  v4 = 0;
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
  do
  {
    if ( this->m_breakObjects[v4].m_active )
      BreakObject_c::Render(&this->m_breakObjects[v4], renderAlphas);
    ++v4;
  }
  while ( v4 != 64 );
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (004526F8) --------------------------------------------------------
bool __fastcall BreakManager_c::Add(BreakManager_c *this, CObject *pObject, RwV3d_0 *vel, float error, int32 a5)
{
  int v5; // lr

  v5 = -1;
  while ( this->m_breakObjects[0].m_active )
  {
    ++v5;
    this = (BreakManager_c *)((char *)this + 32);
    if ( v5 >= 63 )
      return 0;
  }
  return this && BreakObject_c::Init(this->m_breakObjects, pObject, vel, error, a5);
}

//----- (00452732) --------------------------------------------------------
BreakObject_c *__fastcall BreakManager_c::GetFirstFreeSlot(BreakManager_c *this)
{
  int v1; // r1

  v1 = -1;
  while ( this->m_breakObjects[0].m_active )
  {
    ++v1;
    this = (BreakManager_c *)((char *)this + 32);
    if ( v1 >= 63 )
      return 0;
  }
  return this->m_breakObjects;
}

//----- (0045274A) --------------------------------------------------------
void __fastcall BreakManager_c::ResetAll(BreakManager_c *this)
{
  BreakManager_c *v1; // r6
  int i; // r11
  BreakObject_c *v3; // r5
  bool8 *p_m_active; // r10
  BreakGroup_t *m_groups; // r0
  BreakGroup_t **p_m_groups; // r4
  int32 *p_m_numGroups; // r5
  int m_numGroups; // t1
  int32 v9; // r6
  int v10; // r8

  v1 = this;
  for ( i = 0; i != 64; ++i )
  {
    v3 = &v1->m_breakObjects[i];
    p_m_active = &v3->m_active;
    if ( v3->m_active )
    {
      p_m_groups = &v3->m_groups;
      m_groups = v3->m_groups;
      if ( m_groups )
      {
        m_numGroups = v3->m_numGroups;
        p_m_numGroups = &v3->m_numGroups;
        if ( m_numGroups < 1 )
        {
          operator delete[](m_groups);
        }
        else
        {
          v9 = 0;
          v10 = 84;
          do
          {
            if ( *(_DWORD *)((char *)&m_groups->m_mat.right.x + v10) )
            {
              RwTextureDestroy(*(RwTexture_0 **)((char *)&m_groups->m_mat.right.x + v10));
              *(RwReal *)((char *)&(*p_m_groups)->m_mat.right.x + v10) = 0.0;
              m_groups = *p_m_groups;
            }
            if ( *(_DWORD *)((char *)m_groups + v10 - 4) )
            {
              operator delete[](*(void **)((char *)m_groups + v10 - 4));
              m_groups = *p_m_groups;
            }
            ++v9;
            v10 += 116;
          }
          while ( v9 < *p_m_numGroups );
          v1 = this;
          if ( m_groups )
            operator delete[](m_groups);
        }
      }
      *p_m_active = 0;
    }
  }
}

//----- (004527DC) --------------------------------------------------------
void __fastcall CDummyObject::CDummyObject(CDummyObject *this)
{
  _DWORD *v1; // r0

  CDummy::CDummy(this);
  *v1 = &off_667DCC;
}
// 4527EC: variable 'v1' is possibly undefined
// 667DCC: using guessed type void *;

//----- (004527F4) --------------------------------------------------------
void __fastcall CDummyObject::CDummyObject(CDummyObject *this, CObject *pObject)
{
  RwObject_0 *m_pRwObject; // r1
  int32 m_iplIndex; // r0

  CDummy::CDummy(this);
  this->_vptr$CPlaceable = (int (**)(void))&off_667DCC;
  CEntity::SetModelIndexNoCreate(this, pObject->m_nModelIndex);
  m_pRwObject = pObject->m_pRwObject;
  if ( m_pRwObject )
    CEntity::AttachToRwObject(this, m_pRwObject, 1);
  CEntity::DetachFromRwObject(pObject);
  m_iplIndex = pObject->m_iplIndex;
  this->m_iplIndex = m_iplIndex;
  this->m_areaCode = pObject->m_areaCode;
  CIplStore::IncludeEntity(m_iplIndex, this);
}
// 667DCC: using guessed type void *off_667DCC;

//----- (0045284C) --------------------------------------------------------
void __fastcall CDummyObject::~CDummyObject(CDummyObject *this)
{
  void *v1; // r0

  CDummy::~CDummy(this);
  sub_18C680(v1);
}
// 452858: variable 'v1' is possibly undefined

//----- (0045285C) --------------------------------------------------------
CObject *__fastcall CDummyObject::CreateObject(CDummyObject *this)
{
  CEntity::CFlags *p_m_nFlags; // r4
  CObject *v3; // r0
  CObject *v4; // r6
  CObject *v5; // r8

  p_m_nFlags = &this->m_nFlags;
  *(_DWORD *)&this->m_nFlags |= 0x2000u;
  v3 = CObject::Create(this);
  v4 = v3;
  v5 = 0;
  *(_DWORD *)p_m_nFlags &= ~0x2000u;
  if ( v3 )
  {
    CScriptsForBrains::CheckIfNewEntityNeedsScript(&CTheScripts::ScriptsForBrains, v3, 1, 0);
    *(_DWORD *)p_m_nFlags &= 0xFFFFFF7E;
    v4->m_pLod = this->m_pLod;
    this->m_pLod = 0;
    return v4;
  }
  return v5;
}

//----- (004528B8) --------------------------------------------------------
void __fastcall CDummyObject::UpdateFromObject(CDummyObject *this, CObject *pObject)
{
  CEntity::CFlags *p_m_nFlags; // r6
  int m_nFlags; // r0
  CEntity::CFlags *v6; // r4
  RwObject_0 *m_pRwObject; // r1
  RwObject_0 *v8; // r0
  char *parent; // r1
  CMatrix *m_pMat; // r0
  RwMatrix *v11; // r1
  CEntity::CFlags v12; // kr00_8
  unsigned int v13; // r1
  unsigned int v14; // r1

  p_m_nFlags = &this->m_nFlags;
  *(_DWORD *)&this->m_nFlags |= 0x81u;
  v6 = &pObject->m_nFlags;
  m_nFlags = (int)pObject->m_nFlags;
  m_pRwObject = pObject->m_pRwObject;
  *(_DWORD *)v6 = m_nFlags | 0x2000;
  CEntity::AttachToRwObject(this, m_pRwObject, 0);
  *(_DWORD *)v6 &= ~0x2000u;
  v8 = this->m_pRwObject;
  if ( v8 )
  {
    parent = (char *)v8->parent;
    m_pMat = this->m_pMat;
    v11 = (RwMatrix *)(parent + 16);
    if ( m_pMat )
      CMatrix::UpdateRwMatrix(m_pMat, v11);
    else
      CSimpleTransform::UpdateRwMatrix(&this->m_transform, v11);
  }
  CEntity::DetachFromRwObject(pObject);
  if ( pObject->m_iplIndex && CIplStore::ms_pPool->m_aStorage[pObject->m_iplIndex][47] )
  {
    v12 = *p_m_nFlags;
    v13 = *(_DWORD *)p_m_nFlags & 0xFFFFFDFF | (((*(_DWORD *)v6 >> 9) & 1) << 9);
    *(_DWORD *)p_m_nFlags = v13;
    p_m_nFlags->bdummy = v12.bdummy;
    v14 = v13 & 0xFFFFFF7F | (((*(_DWORD *)v6 >> 7) & 1) << 7);
    *(_DWORD *)p_m_nFlags = v14;
    p_m_nFlags->bdummy = v12.bdummy;
    *(_DWORD *)p_m_nFlags = v14 & 0xFFFFFFFE | *(_DWORD *)v6 & 1;
    p_m_nFlags->bdummy = v12.bdummy;
  }
  this->m_pLod = pObject->m_pLod;
  pObject->m_pLod = 0;
}

//----- (00452968) --------------------------------------------------------
void __fastcall CHandObject::CHandObject(CHandObject *this, int32 modelId, CPed *pPed, bool bLeft)
{
  _BOOL4 v5; // r9
  RpHAnimHierarchy_0 *AnimHierarchyFromSkinClump; // r5
  RwInt32 v9; // r1
  RwInt32 v10; // r0
  int (**v11)(void); // r1
  RwTexture_0 *v12; // r0
  CEntity::CEntityInfo m_info; // r3
  int (**v14)(void); // r0
  int m_nFlags; // r1
  char v16[64]; // [sp+4h] [bp-5Ch] BYREF

  v5 = bLeft;
  CObject::CObject(this);
  this->_vptr$CPlaceable = (int (**)(void))&off_667E30;
  AnimHierarchyFromSkinClump = GetAnimHierarchyFromSkinClump((RpClump_0 *)pPed->m_pRwObject);
  this->m_pOwner = pPed;
  CEntity::UpdateRpHAnim(pPed);
  v9 = 23;
  if ( v5 )
    v9 = 33;
  v10 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, v9);
  v11 = this->_vptr$CPlaceable;
  this->m_boneIndex = v10;
  ((void (__fastcall *)(CHandObject *, int32))v11[6])(this, modelId);
  RpAnimBlendClumpInit((RpClump_0 *)this->m_pRwObject);
  CTxdStore::SetCurrentTxd(CModelInfo::ms_modelInfoPtrs[pPed->m_nModelIndex]->m_txdIndex, 0);
  strcpy(v16, (const char *)CModelInfo::ms_modelInfoPtrs[pPed->m_nModelIndex]->m_modelName);
  v12 = RwTextureRead((const RwChar *)v16, 0);
  this->m_pTexture = v12;
  if ( !v12 )
  {
    (*((void (__fastcall **)(char *))RwEngineInstance + 72))(v16);
    this->m_pTexture = RwTextureRead((const RwChar *)v16, 0);
  }
  m_info = this->m_info;
  v14 = this->_vptr$CPlaceable;
  m_nFlags = (int)this->m_nFlags;
  this->ObjectCreatedBy = 5;
  this->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&m_info & 7 | 0x10);
  *(_DWORD *)&this->m_nFlags = m_nFlags & 0xEFFFFBFE | 0x10000400;
  ((void (__fastcall *)(CHandObject *, _DWORD))v14[5])(this, 0);
  CModelInfo::ms_modelInfoPtrs[modelId]->m_alpha = -1;
  this->m_firstFrame = 1;
}
// 667E30: using guessed type void *;

//----- (00452AA4) --------------------------------------------------------
void __fastcall CHandObject::ProcessControl(CHandObject *this)
{
  RpHAnimHierarchy_0 *AnimHierarchyFromSkinClump; // r0
  RwMatrix *MatrixArray; // r0
  CMatrix v4; // [sp+0h] [bp-50h] BYREF

  AnimHierarchyFromSkinClump = GetAnimHierarchyFromSkinClump((RpClump_0 *)this->m_pOwner->m_pRwObject);
  MatrixArray = RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump);
  CMatrix::CMatrix(&v4, &MatrixArray[this->m_boneIndex], 0);
  CMatrix::operator=(this->m_pMat, &v4);
  CMatrix::~CMatrix(&v4);
  *(_DWORD *)&this->m_nFlags |= 0x20u;
  CPhysical::RemoveAndAdd(this);
}

//----- (00452AEC) --------------------------------------------------------
void __fastcall CHandObject::PreRender(CHandObject *this)
{
  RpHAnimHierarchy_0 *AnimHierarchyFromSkinClump; // r11
  CPed *m_pOwner; // r0
  CEntity::CFlags m_nFlags; // kr00_8
  RwMatrix *v5; // r10
  int32 m_boneIndex; // lr
  int i; // r1
  int32 v8; // r2
  RwInt32 flags; // r6
  int v10; // r0
  _DWORD *p_x; // r3
  int v12; // r0
  RwObject_0 *m_pRwObject; // r0
  char *parent; // r1
  CMatrix *m_pMat; // r0
  RwMatrix *v16; // r1
  CMatrix v17; // [sp+4h] [bp-64h] BYREF

  AnimHierarchyFromSkinClump = GetAnimHierarchyFromSkinClump((RpClump_0 *)this->m_pOwner->m_pRwObject);
  CEntity::UpdateRpHAnim(this->m_pOwner);
  m_pOwner = this->m_pOwner;
  m_nFlags = m_pOwner->m_nFlags;
  *(_DWORD *)&m_pOwner->m_nFlags = *(_DWORD *)&m_nFlags | 0x800000;
  m_pOwner->m_nFlags.bdummy = m_nFlags.bdummy;
  v5 = &RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump)[this->m_boneIndex];
  CMatrix::CMatrix(&v17, v5, 0);
  CMatrix::operator=(this->m_pMat, &v17);
  CMatrix::~CMatrix(&v17);
  if ( this->m_firstFrame )
  {
    this->m_firstFrame = 0;
  }
  else
  {
    m_boneIndex = this->m_boneIndex;
    for ( i = 0; i > -1; i += v12 )
    {
      v8 = m_boneIndex + 1;
      v5[1].right.x = 0.0;
      v5[1].at.x = 0.0;
      v5[1].at.y = 0.0;
      v5[1].at.z = 0.0;
      v5[1].up.x = 0.0;
      v5[1].up.y = 0.0;
      v5[1].up.z = 0.0;
      v5[1].right.y = 0.0;
      v5[1].right.z = 0.0;
      flags = AnimHierarchyFromSkinClump->pNodeInfo[m_boneIndex + 1].flags;
      if ( (flags & 2) != 0 )
      {
        v12 = 1;
        ++m_boneIndex;
        ++v5;
      }
      else
      {
        v10 = 16 * m_boneIndex + 40;
        p_x = (_DWORD *)&v5[2].at.x;
        while ( !(flags << 31) )
        {
          *p_x = 0;
          p_x[1] = 0;
          p_x[2] = 0;
          ++v8;
          *(p_x - 8) = 0;
          *(p_x - 7) = 0;
          *(p_x - 6) = 0;
          *(p_x - 4) = 0;
          *(p_x - 3) = 0;
          *(p_x - 2) = 0;
          p_x += 16;
          flags = *(RwInt32 *)((char *)&AnimHierarchyFromSkinClump->pNodeInfo->nodeID + v10);
          v10 += 16;
          if ( (flags & 2) != 0 )
          {
            v5 = (RwMatrix *)(p_x - 24);
            v12 = 1;
            goto LABEL_11;
          }
        }
        v5 = (RwMatrix *)(p_x - 24);
        v12 = -1;
LABEL_11:
        m_boneIndex = v8;
      }
    }
  }
  m_pRwObject = this->m_pRwObject;
  this->m_lightingFromCollision = this->m_pOwner->m_lightingFromCollision;
  if ( m_pRwObject )
  {
    parent = (char *)m_pRwObject->parent;
    m_pMat = this->m_pMat;
    v16 = (RwMatrix *)(parent + 16);
    if ( m_pMat )
      CMatrix::UpdateRwMatrix(m_pMat, v16);
    else
      CSimpleTransform::UpdateRwMatrix(&this->m_transform, v16);
  }
  CEntity::UpdateRwFrame(this);
  CEntity::UpdateRpHAnim(this);
}

//----- (00452C24) --------------------------------------------------------
void __fastcall CHandObject::Render(CHandObject *this)
{
  RpAtomic_0 *FirstAtomic; // r0

  if ( CMirrors::TypeOfMirror != 3 )
  {
    FirstAtomic = GetFirstAtomic((RpClump_0 *)this->m_pRwObject);
    RpMaterialSetTexture(*FirstAtomic->geometry->matList.materials, this->m_pTexture);
    sub_1935D0(this);
  }
}

//----- (00452C5C) --------------------------------------------------------
void __fastcall CHandObject::~CHandObject(CHandObject *this)
{
  void *v1; // r0

  CObject::~CObject(this);
  sub_18BC44(v1);
}
// 452C68: variable 'v1' is possibly undefined

//----- (00452C6C) --------------------------------------------------------
void __fastcall CObject::CObject(CObject *this)
{
  CPhysical::CPhysical(this);
  this->m_pRelatedDummy = 0;
  this->_vptr$CPlaceable = (int (**)(void))&off_667E98;
  CObject::Init(this);
  this->ObjectCreatedBy = 0;
}
// 667E98: using guessed type void *off_667E98;

//----- (00452C98) --------------------------------------------------------
void __fastcall CObject::Init(CObject *this)
{
  CEntity::CEntityInfo m_info; // r1
  int (**v3)(void); // r2
  int32 m_nModelIndex; // r0
  unsigned int v5; // r1
  CBaseModelInfo *v6; // r0
  CColModel *m_pColModel; // r6
  int v8; // r1
  int v9; // r0
  int v10; // r2
  int v11; // r1
  int v12; // r0
  CCollisionData *m_pColData; // r0
  int v14; // r1
  int v15; // r0
  unsigned int v16; // r0
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r2
  Int32 v18; // r0
  CPtrNodeDoubleLink *v19; // r0
  CPtrNode *m_pHead; // r1
  CBaseModelInfo *v21; // r0
  int v22; // r0
  int v23; // r2
  int v24; // r1
  int v25; // r0

  this->m_nCollisionDamageEffect = 0;
  this->m_nStoredCollisionDamageEffect = 0;
  m_info = this->m_info;
  this->ObjectCreatedBy = 1;
  v3 = this->_vptr$CPlaceable;
  this->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&m_info & 0xF8 | 4);
  this->m_pObjectInfo = CObjectData::ms_aObjectInfo;
  ((void (__fastcall *)(CObject *, int))v3[5])(this, 1);
  m_nModelIndex = this->m_nModelIndex;
  v5 = *(_DWORD *)&this->m_nObjectFlags & 0xFC000000 | 0x40000;
  this->m_nObjectFlags = (CObject::CObjectFlags)v5;
  if ( m_nModelIndex == -1 || !CModelInfo::ms_modelInfoPtrs[m_nModelIndex]->m_pColModel )
  {
    this->m_nObjectFlags = (CObject::CObjectFlags)v5;
  }
  else
  {
    CObjectData::SetObjectData(m_nModelIndex, this);
    v6 = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
    m_pColModel = v6->m_pColModel;
    if ( *((unsigned __int8 *)m_pColModel + 41) << 31 )
    {
      CColStore::AddRef(m_pColModel->m_level);
      v8 = this->m_nModelIndex;
      *(_DWORD *)&this->m_nObjectFlags |= 0x10000u;
      v6 = CModelInfo::ms_modelInfoPtrs[v8];
    }
    v9 = (*((int (__fastcall **)(CBaseModelInfo *))v6->_vptr$CBaseModelInfo + 2))(v6);
    if ( v9 )
    {
      v10 = 0;
      v11 = 0;
      v12 = *(_WORD *)(v9 + 40) & 0x7800;
      if ( v12 != 2048 )
        v10 = 1;
      if ( v12 == 4096 )
        v11 = 1;
      if ( v11 == v10 && (*(_BYTE *)&this->m_nPhysicalFlags & 4) == 0 )
        this->m_vecCOM.z = m_pColModel->m_boxBound.m_vecMin.z
                         + (float)((float)(m_pColModel->m_boxBound.m_vecMax.z - m_pColModel->m_boxBound.m_vecMin.z) * 0.2);
    }
  }
  if ( (*(_BYTE *)&this->m_nPhysicalFlags & 0x20) != 0 )
  {
    m_pColData = CEntity::GetColModel(this)->m_pColData;
    if ( m_pColData )
      m_pColData->m_nNoOfSpheres = 0;
  }
  this->m_nEndOfLifeTime = 0;
  this->m_fHealth = 1000.0;
  this->m_fOriginalAngle = -1001.0;
  this->ObjectMessage = 0;
  this->ObjectMessageAmount = 0;
  this->m_colour2 = 0;
  this->m_colour1 = 0;
  this->m_nParentModelIndex = -1;
  v14 = (unsigned __int16)this->m_nModelIndex;
  this->m_Garage = -1;
  this->LastDamagedWeaponType = -1;
  this->m_pFire = 0;
  if ( (__int16)v14 == MI_BUOY )
    *(_DWORD *)&this->m_nPhysicalFlags |= 0x8000000u;
  if ( v14 != 0xFFFF
    && (*((int (__fastcall **)(CBaseModelInfo *))CModelInfo::ms_modelInfoPtrs[(__int16)v14]->_vptr$CBaseModelInfo + 5))(CModelInfo::ms_modelInfoPtrs[(__int16)v14]) == 4 )
  {
    *(_DWORD *)&this->m_nFlags |= 0x10000000u;
  }
  v15 = this->m_nModelIndex;
  if ( v15 == MI_TRAFFICLIGHTS_MIAMI
    || v15 == MI_MLAMPPOST
    || v15 == MI_SINGLESTREETLIGHTS1
    || v15 == MI_SINGLESTREETLIGHTS2
    || v15 == MI_SINGLESTREETLIGHTS3
    || v15 == MI_DOUBLESTREETLIGHTS
    || v15 == MI_TRAFFICLIGHTS_TWOVERTICAL
    || v15 == MI_TRAFFICLIGHTS_VEGAS )
  {
    goto LABEL_30;
  }
  if ( (unsigned __int16)v15 == 0xFFFF
    || !(*((int (__fastcall **)(CBaseModelInfo *))CModelInfo::ms_modelInfoPtrs[v15]->_vptr$CBaseModelInfo + 2))(CModelInfo::ms_modelInfoPtrs[v15]) )
  {
    goto LABEL_50;
  }
  v21 = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
  v22 = (*((int (__fastcall **)(CBaseModelInfo *))v21->_vptr$CBaseModelInfo + 2))(v21);
  v23 = 0;
  v24 = 0;
  v25 = *(_WORD *)(v22 + 40) & 0x7800;
  if ( v25 != 2048 )
    v23 = 1;
  if ( v25 == 4096 )
    v24 = 1;
  if ( v24 == v23 )
LABEL_30:
    v16 = *(_DWORD *)&this->m_nObjectFlags | 0x100;
  else
LABEL_50:
    v16 = *(_DWORD *)&this->m_nObjectFlags & 0xFFFFFEFF;
  this->m_nObjectFlags = (CObject::CObjectFlags)(v16 & 0xFFFFFDFF);
  this->m_areaCode = 13;
  m_nPhysicalFlags = this->m_nPhysicalFlags;
  this->m_remapTxdName = 0;
  this->m_pRemapTexture = 0;
  this->m_pControlListNode = 0;
  v18 = this->m_nModelIndex;
  this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags & 0xFDFFFFFF);
  if ( v18 == MI_SAMSITE
    || v18 == MI_SAMSITE2
    || v18 == MI_TRAINCROSSING
    || v18 == MI_TRAINCROSSING1
    || v18 == MI_MAGNOCRANE
    || v18 == MI_CRANETROLLEY
    || v18 == MI_QUARRYCRANE_ARM
    || CGarages::IsModelIndexADoor(v18) )
  {
    v19 = (CPtrNodeDoubleLink *)CPtrNodeDoubleLink::operator new(0xCu);
    v19->m_pVoid = this;
    this->m_pControlListNode = v19;
    v19->m_pPrevious = 0;
    m_pHead = CWorld::ms_listObjectsWithControlCode.m_pHead;
    v19->m_pNext = CWorld::ms_listObjectsWithControlCode.m_pHead;
    if ( m_pHead )
      m_pHead[1].m_pVoid = v19;
    CWorld::ms_listObjectsWithControlCode.m_pHead = v19;
  }
  this->m_fScale = 1.0;
  this->m_burnTimer = 0;
  this->m_storedCollisionLighting = 72;
  this->StreamedScriptBrainToLoad = -1;
}

//----- (00453010) --------------------------------------------------------
void __fastcall CObject::CObject(CObject *this, int32 nModelIndex, bool CreateRWObject)
{
  _BOOL4 v3; // r6

  v3 = CreateRWObject;
  CPhysical::CPhysical(this);
  this->m_pRelatedDummy = 0;
  this->_vptr$CPlaceable = (int (**)(void))&off_667E98;
  if ( v3 )
    CEntity::SetModelIndex(this, nModelIndex);
  else
    CEntity::SetModelIndexNoCreate(this, nModelIndex);
  CObject::Init(this);
}
// 667E98: using guessed type void *;

//----- (00453058) --------------------------------------------------------
void __fastcall CObject::CObject(CObject *this, CDummyObject *pDummy)
{
  RwObject_0 *m_pRwObject; // r1
  CMatrix *m_pMat; // r1
  int m_nFlags; // r1
  RpAtomic_0 *FirstAtomic; // r0

  CPhysical::CPhysical(this);
  this->_vptr$CPlaceable = (int (**)(void))&off_667E98;
  CEntity::SetModelIndexNoCreate(this, pDummy->m_nModelIndex);
  m_pRwObject = pDummy->m_pRwObject;
  if ( m_pRwObject )
  {
    CEntity::AttachToRwObject(this, m_pRwObject, 1);
  }
  else
  {
    m_pMat = pDummy->m_pMat;
    if ( !m_pMat )
    {
      CPlaceable::AllocateMatrix(pDummy);
      CSimpleTransform::UpdateMatrix(&pDummy->m_transform, pDummy->m_pMat);
      m_pMat = pDummy->m_pMat;
    }
    CPlaceable::SetMatrix(this, m_pMat);
  }
  CEntity::DetachFromRwObject(pDummy);
  CObject::Init(this);
  m_nFlags = (int)this->m_nFlags;
  this->m_iplIndex = pDummy->m_iplIndex;
  this->m_areaCode = pDummy->m_areaCode;
  FirstAtomic = (RpAtomic_0 *)this->m_pRwObject;
  *(_DWORD *)&this->m_nFlags = m_nFlags & 0xFFFFFDFF | (((*(_DWORD *)&pDummy->m_nFlags >> 9) & 1) << 9);
  if ( FirstAtomic )
  {
    if ( FirstAtomic->object.object.type != 1 )
      FirstAtomic = GetFirstAtomic((RpClump_0 *)FirstAtomic);
    if ( !CCustomBuildingRenderer::IsCBPCPipelineAttached(FirstAtomic) )
      *(_DWORD *)&this->m_nFlags |= 0x10000000u;
  }
}
// 667E98: using guessed type void *off_667E98;

//----- (004530FC) --------------------------------------------------------
void __fastcall CObject::~CObject(CObject *this)
{
  CObject::CObjectFlags m_nObjectFlags; // r0
  int StreamedScriptBrainToLoad; // r1
  int m_nParentModelIndex; // r0
  RwTexture_0 *m_pRemapTexture; // r0
  CPtrNodeDoubleLink *m_pControlListNode; // r0
  CPtrNodeDoubleLink *m_pPrevious; // r1
  CPtrNode *m_pNext; // r1
  CPtrNodeDoubleLink *v9; // r0
  CDummyObject *m_pRelatedDummy; // r0
  CMatrix *m_pMat; // r1
  float *p_tx; // r2
  CFire *m_pFire; // r0

  m_nObjectFlags = this->m_nObjectFlags;
  this->_vptr$CPlaceable = (int (**)(void))&off_667E98;
  if ( (*(_DWORD *)&m_nObjectFlags & 0x300000) != 0 )
  {
    StreamedScriptBrainToLoad = this->StreamedScriptBrainToLoad;
    if ( StreamedScriptBrainToLoad > -1 )
    {
      CStreaming::SetMissionDoesntRequireModel(CTheScripts::ScriptsForBrains.ScriptBrainArray[StreamedScriptBrainToLoad].StreamedScriptIndex + 26230);
      CTheScripts::RemoveFromWaitingForScriptBrainArray(this, this->StreamedScriptBrainToLoad);
      m_nObjectFlags = this->m_nObjectFlags;
    }
    m_nObjectFlags = (CObject::CObjectFlags)(*(_DWORD *)&m_nObjectFlags & 0xFFCFFFFF);
    this->StreamedScriptBrainToLoad = -1;
    this->m_nObjectFlags = m_nObjectFlags;
  }
  if ( (*(_DWORD *)&m_nObjectFlags & 0x10000) != 0 )
    CColStore::RemoveRef(CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel->m_level);
  CRadar::ClearBlipForEntity(
    BLIPTYPE_OBJECT,
    CPools::ms_pObjectPool->m_aFlags[-654471207 * (((char *)this - (char *)CPools::ms_pObjectPool->m_aStorage) >> 2)] | (-40904448 * (((char *)this - (char *)CPools::ms_pObjectPool->m_aStorage) >> 2)));
  m_nParentModelIndex = (unsigned __int16)this->m_nParentModelIndex;
  if ( m_nParentModelIndex != 0xFFFF )
    CBaseModelInfo::RemoveRef(CModelInfo::ms_modelInfoPtrs[(__int16)m_nParentModelIndex]);
  if ( this->m_remapTxdName )
  {
    m_pRemapTexture = this->m_pRemapTexture;
    if ( m_pRemapTexture )
      RwTextureDestroy(m_pRemapTexture);
  }
  if ( this->ObjectCreatedBy == 3 && CObject::nNoTempObjects )
    --CObject::nNoTempObjects;
  m_pControlListNode = this->m_pControlListNode;
  if ( m_pControlListNode )
  {
    if ( CWorld::ms_listObjectsWithControlCode.m_pHead == m_pControlListNode )
      CWorld::ms_listObjectsWithControlCode.m_pHead = m_pControlListNode->m_pNext;
    m_pPrevious = m_pControlListNode->m_pPrevious;
    if ( m_pPrevious )
      m_pPrevious->m_pNext = m_pControlListNode->m_pNext;
    m_pNext = m_pControlListNode->m_pNext;
    if ( m_pNext )
      m_pNext[1].m_pVoid = m_pControlListNode->m_pPrevious;
    v9 = this->m_pControlListNode;
    if ( v9 )
      CPtrNodeDoubleLink::operator delete(v9);
    this->m_pControlListNode = 0;
  }
  if ( this->m_nModelIndex == MI_TRAINCROSSING1 )
  {
    m_pRelatedDummy = this->m_pRelatedDummy;
    m_pMat = m_pRelatedDummy->m_pMat;
    p_tx = &m_pMat->tx;
    if ( !m_pMat )
      p_tx = &m_pRelatedDummy->m_transform.m_translate.x;
    CPathFind::SetLinksBridgeLights(&ThePaths, *p_tx + -12.0, *p_tx + 12.0, p_tx[1] + -12.0, p_tx[1] + 12.0, 0);
  }
  m_pFire = this->m_pFire;
  if ( m_pFire )
    CFire::Extinguish(m_pFire);
  sub_194468(this);
}
// 667E98: using guessed type void *off_667E98;

//----- (004532C4) --------------------------------------------------------
void __fastcall CObject::RemoveFromControlCodeList(CObject *this)
{
  CPtrNodeDoubleLink *m_pControlListNode; // r0
  CPtrNodeDoubleLink *m_pPrevious; // r1
  CPtrNode *m_pNext; // r1
  CPtrNodeDoubleLink *v5; // r0

  m_pControlListNode = this->m_pControlListNode;
  if ( m_pControlListNode )
  {
    if ( CWorld::ms_listObjectsWithControlCode.m_pHead == m_pControlListNode )
      CWorld::ms_listObjectsWithControlCode.m_pHead = m_pControlListNode->m_pNext;
    m_pPrevious = m_pControlListNode->m_pPrevious;
    if ( m_pPrevious )
      m_pPrevious->m_pNext = m_pControlListNode->m_pNext;
    m_pNext = m_pControlListNode->m_pNext;
    if ( m_pNext )
      m_pNext[1].m_pVoid = m_pControlListNode->m_pPrevious;
    v5 = this->m_pControlListNode;
    if ( v5 )
      CPtrNodeDoubleLink::operator delete(v5);
    this->m_pControlListNode = 0;
  }
}

//----- (0045331C) --------------------------------------------------------
void __fastcall CObject::~CObject(CObject *this)
{
  CObjectPool *v1; // r1
  int v2; // r0
  int v3; // r0

  CObject::~CObject(this);
  v1 = CPools::ms_pObjectPool;
  v3 = -654471207 * ((signed int)(v2 - (unsigned int)CPools::ms_pObjectPool->m_aStorage) >> 2);
  CPools::ms_pObjectPool->m_aFlags[v3] |= 0x80u;
  if ( v3 < v1->m_nFreeIndex )
    v1->m_nFreeIndex = v3;
}
// 453330: variable 'v2' is possibly undefined

//----- (00453354) --------------------------------------------------------
void __fastcall CObject::operator delete(void *pVoid)
{
  CObjectPool *v1; // r1
  int v2; // r0

  v1 = CPools::ms_pObjectPool;
  v2 = -654471207 * ((signed int)((int)pVoid - (unsigned int)CPools::ms_pObjectPool->m_aStorage) >> 2);
  CPools::ms_pObjectPool->m_aFlags[v2] |= 0x80u;
  if ( v2 < v1->m_nFreeIndex )
    v1->m_nFreeIndex = v2;
}

//----- (00453384) --------------------------------------------------------
void *__fastcall CObject::operator new(size_t nSize)
{
  int v1; // lr
  CObjectPool *v2; // r1
  void *result; // r0
  void *m_nSize; // r12
  uint8 *m_aFlags; // r2
  int v6; // r3

  v1 = 0;
  v2 = CPools::ms_pObjectPool;
  result = (void *)CPools::ms_pObjectPool->m_nFreeIndex;
  m_nSize = (void *)CPools::ms_pObjectPool->m_nSize;
  do
  {
    result = (char *)result + 1;
    v2->m_nFreeIndex = (int32)result;
    if ( result == m_nSize )
    {
      result = 0;
      v2->m_nFreeIndex = 0;
      if ( v1 << 31 )
        return result;
      v1 = 1;
    }
    m_aFlags = v2->m_aFlags;
    v6 = *((char *)result + (_DWORD)m_aFlags);
  }
  while ( v6 > -1 );
  *((_BYTE *)result + (_DWORD)m_aFlags) = v6 & 0x7F;
  v2->m_aFlags[v2->m_nFreeIndex] = (v2->m_aFlags[v2->m_nFreeIndex] + 1) & 0x7F | v2->m_aFlags[v2->m_nFreeIndex] & 0x80;
  return v2->m_aStorage[v2->m_nFreeIndex];
}

//----- (004533E8) --------------------------------------------------------
void *__fastcall CObject::operator new(size_t nSize, int32 index)
{
  int32 v2; // r4
  CObjectPool *v3; // r2
  __int64 v4; // kr00_8
  int32 v5; // r0
  uint8 *m_aFlags; // r1
  int v7; // r3

  v2 = index >> 8;
  v3 = CPools::ms_pObjectPool;
  v4 = *(_QWORD *)&CPools::ms_pObjectPool->m_aStorage;
  CPools::ms_pObjectPool->m_aFlags[v2] &= ~0x80u;
  v3->m_aFlags[v2] = v3->m_aFlags[index >> 8] & 0x80 | index & 0x7F;
  v5 = 0;
  m_aFlags = v3->m_aFlags;
  do
  {
    v3->m_nFreeIndex = v5;
    v7 = (char)m_aFlags[v5++];
  }
  while ( v7 > -1 );
  return (void *)(v4 + 420 * v2);
}

//----- (0045343C) --------------------------------------------------------
CObject *__fastcall CObject::Create(int32 nModelIndex, bool CreateRWObject)
{
  CObjectPool *v3; // r0
  int32 m_nSize; // r1
  CObject *m_nFreeIndex; // r5
  int v6; // r2
  uint8 *m_aFlags; // r3
  int v8; // r6
  CObjectPool *v9; // r11
  int32 v10; // r4
  int v11; // r9
  int v12; // r0
  int v13; // r6
  CPool<CObject,CCutsceneObject>::StorageType *m_aStorage; // r10
  uint8 *v15; // r5
  int v16; // r2
  CObjectPool *v17; // r0
  int32 v18; // r1
  uint8 *v19; // r3
  int v20; // r6

  v3 = CPools::ms_pObjectPool;
  m_nFreeIndex = (CObject *)CPools::ms_pObjectPool->m_nFreeIndex;
  m_nSize = CPools::ms_pObjectPool->m_nSize;
  CPools::ms_pObjectPool->m_bDealWithNoMemory = 1;
  v6 = 0;
  do
  {
    m_nFreeIndex = (CObject *)((char *)m_nFreeIndex + 1);
    v3->m_nFreeIndex = (int32)m_nFreeIndex;
    if ( m_nFreeIndex == (CObject *)m_nSize )
    {
      m_nFreeIndex = 0;
      v3->m_nFreeIndex = 0;
      if ( v6 << 31 )
        goto LABEL_7;
      v6 = 1;
    }
    m_aFlags = v3->m_aFlags;
    v8 = *((char *)&m_nFreeIndex->_vptr$CPlaceable + (_DWORD)m_aFlags);
  }
  while ( v8 > -1 );
  *((_BYTE *)&m_nFreeIndex->_vptr$CPlaceable + (_DWORD)m_aFlags) = v8 & 0x7F;
  v3->m_aFlags[v3->m_nFreeIndex] = (v3->m_aFlags[v3->m_nFreeIndex] + 1) & 0x7F | v3->m_aFlags[v3->m_nFreeIndex] & 0x80;
  m_nFreeIndex = (CObject *)v3->m_aStorage[v3->m_nFreeIndex];
LABEL_7:
  CPhysical::CPhysical(m_nFreeIndex);
  m_nFreeIndex->m_pRelatedDummy = 0;
  m_nFreeIndex->_vptr$CPlaceable = (int (**)(void))&off_667E98;
  CEntity::SetModelIndexNoCreate(m_nFreeIndex, nModelIndex);
  CObject::Init(m_nFreeIndex);
  v9 = CPools::ms_pObjectPool;
  CPools::ms_pObjectPool->m_bDealWithNoMemory = 0;
  if ( !m_nFreeIndex )
  {
    v10 = v9->m_nSize;
    if ( v10 )
    {
      v11 = 5;
      do
      {
        v12 = 420 * v10--;
        v13 = v12 - 420;
        while ( 1 )
        {
          if ( (v9->m_aFlags[v10] & 0x80u) == 0 )
          {
            m_aStorage = v9->m_aStorage;
            v15 = &(*v9->m_aStorage)[v13];
            if ( v15 )
            {
              if ( v15[320] == 3 && !CEntity::IsVisible((CEntity *)&(*v9->m_aStorage)[v13]) )
                break;
            }
          }
          --v10;
          v13 -= 420;
          if ( v10 == -1 )
            goto LABEL_19;
        }
        CWorld::Remove((CEntity *)v15);
        (*(void (__fastcall **)(uint8 *))(*(_DWORD *)&(*m_aStorage)[v13] + 4))(v15);
        if ( v11 < 2 )
          break;
        --v11;
      }
      while ( v10 );
    }
LABEL_19:
    WaterCreatureManager_c::TryToFreeUpWaterCreatures(&g_waterCreatureMan, 5);
    v16 = 0;
    v17 = CPools::ms_pObjectPool;
    m_nFreeIndex = (CObject *)CPools::ms_pObjectPool->m_nFreeIndex;
    v18 = CPools::ms_pObjectPool->m_nSize;
    do
    {
      m_nFreeIndex = (CObject *)((char *)m_nFreeIndex + 1);
      v17->m_nFreeIndex = (int32)m_nFreeIndex;
      if ( m_nFreeIndex == (CObject *)v18 )
      {
        m_nFreeIndex = 0;
        v17->m_nFreeIndex = 0;
        if ( v16 << 31 )
          goto LABEL_25;
        v16 = 1;
      }
      v19 = v17->m_aFlags;
      v20 = *((char *)&m_nFreeIndex->_vptr$CPlaceable + (_DWORD)v19);
    }
    while ( v20 > -1 );
    *((_BYTE *)&m_nFreeIndex->_vptr$CPlaceable + (_DWORD)v19) = v20 & 0x7F;
    v17->m_aFlags[v17->m_nFreeIndex] = (v17->m_aFlags[v17->m_nFreeIndex] + 1) & 0x7F | v17->m_aFlags[v17->m_nFreeIndex] & 0x80;
    m_nFreeIndex = (CObject *)v17->m_aStorage[v17->m_nFreeIndex];
LABEL_25:
    CPhysical::CPhysical(m_nFreeIndex);
    m_nFreeIndex->m_pRelatedDummy = 0;
    m_nFreeIndex->_vptr$CPlaceable = (int (**)(void))&off_667E98;
    CEntity::SetModelIndexNoCreate(m_nFreeIndex, nModelIndex);
    CObject::Init(m_nFreeIndex);
  }
  return m_nFreeIndex;
}
// 667E98: using guessed type void *off_667E98;

//----- (004535D8) --------------------------------------------------------
void __fastcall CObject::TryToFreeUpTempObjects(int32 num)
{
  int32 v1; // r8
  CObjectPool *v2; // r10
  int32 i; // r4
  int v4; // r0
  int j; // r6
  CPool<CObject,CCutsceneObject>::StorageType *m_aStorage; // r5
  uint8 *v7; // r11

  v1 = num;
  if ( num >= 1 )
  {
    v2 = CPools::ms_pObjectPool;
    for ( i = CPools::ms_pObjectPool->m_nSize; i; --v1 )
    {
      v4 = 420 * i--;
      for ( j = v4 - 420; ; j -= 420 )
      {
        if ( (v2->m_aFlags[i] & 0x80u) == 0 )
        {
          m_aStorage = v2->m_aStorage;
          v7 = &(*v2->m_aStorage)[j];
          if ( v7 )
          {
            if ( v7[320] == 3 && !CEntity::IsVisible((CEntity *)&(*v2->m_aStorage)[j]) )
              break;
          }
        }
        if ( --i == -1 )
          return;
      }
      CWorld::Remove((CEntity *)v7);
      (*(void (__fastcall **)(uint8 *))(*(_DWORD *)&(*m_aStorage)[j] + 4))(v7);
      if ( v1 < 2 )
        break;
    }
  }
}

//----- (00453660) --------------------------------------------------------
CObject *__fastcall CObject::Create(CDummyObject *pDummy)
{
  CObjectPool *v2; // r1
  CObject *m_nFreeIndex; // r0
  int32 m_nSize; // r2
  int v5; // r3
  uint8 *m_aFlags; // r6
  int v7; // r5
  CObject *result; // r0
  CObjectPool *v9; // r11
  int32 v10; // r4
  int v11; // r9
  int v12; // r0
  int v13; // r6
  CPool<CObject,CCutsceneObject>::StorageType *m_aStorage; // r10
  uint8 *v15; // r5
  int v16; // r3
  CObjectPool *v17; // r1
  CObject *v18; // r0
  int32 v19; // r2
  uint8 *v20; // r6
  int v21; // r5

  v2 = CPools::ms_pObjectPool;
  m_nFreeIndex = (CObject *)CPools::ms_pObjectPool->m_nFreeIndex;
  m_nSize = CPools::ms_pObjectPool->m_nSize;
  CPools::ms_pObjectPool->m_bDealWithNoMemory = 1;
  v5 = 0;
  do
  {
    m_nFreeIndex = (CObject *)((char *)m_nFreeIndex + 1);
    v2->m_nFreeIndex = (int32)m_nFreeIndex;
    if ( m_nFreeIndex == (CObject *)m_nSize )
    {
      m_nFreeIndex = 0;
      v2->m_nFreeIndex = 0;
      if ( v5 << 31 )
        goto LABEL_7;
      v5 = 1;
    }
    m_aFlags = v2->m_aFlags;
    v7 = *((char *)&m_nFreeIndex->_vptr$CPlaceable + (_DWORD)m_aFlags);
  }
  while ( v7 > -1 );
  *((_BYTE *)&m_nFreeIndex->_vptr$CPlaceable + (_DWORD)m_aFlags) = v7 & 0x7F;
  v2->m_aFlags[v2->m_nFreeIndex] = (v2->m_aFlags[v2->m_nFreeIndex] + 1) & 0x7F | v2->m_aFlags[v2->m_nFreeIndex] & 0x80;
  m_nFreeIndex = (CObject *)v2->m_aStorage[v2->m_nFreeIndex];
LABEL_7:
  CObject::CObject(m_nFreeIndex, pDummy);
  v9 = CPools::ms_pObjectPool;
  CPools::ms_pObjectPool->m_bDealWithNoMemory = 0;
  if ( !result )
  {
    v10 = v9->m_nSize;
    if ( v10 )
    {
      v11 = 5;
      do
      {
        v12 = 420 * v10--;
        v13 = v12 - 420;
        while ( 1 )
        {
          if ( (v9->m_aFlags[v10] & 0x80u) == 0 )
          {
            m_aStorage = v9->m_aStorage;
            v15 = &(*v9->m_aStorage)[v13];
            if ( v15 )
            {
              if ( v15[320] == 3 && !CEntity::IsVisible((CEntity *)&(*v9->m_aStorage)[v13]) )
                break;
            }
          }
          --v10;
          v13 -= 420;
          if ( v10 == -1 )
            goto LABEL_19;
        }
        CWorld::Remove((CEntity *)v15);
        (*(void (__fastcall **)(uint8 *))(*(_DWORD *)&(*m_aStorage)[v13] + 4))(v15);
        if ( v11 < 2 )
          break;
        --v11;
      }
      while ( v10 );
    }
LABEL_19:
    WaterCreatureManager_c::TryToFreeUpWaterCreatures(&g_waterCreatureMan, 5);
    v16 = 0;
    v17 = CPools::ms_pObjectPool;
    v18 = (CObject *)CPools::ms_pObjectPool->m_nFreeIndex;
    v19 = CPools::ms_pObjectPool->m_nSize;
    do
    {
      v18 = (CObject *)((char *)v18 + 1);
      v17->m_nFreeIndex = (int32)v18;
      if ( v18 == (CObject *)v19 )
      {
        v18 = 0;
        v17->m_nFreeIndex = 0;
        if ( v16 << 31 )
          goto LABEL_25;
        v16 = 1;
      }
      v20 = v17->m_aFlags;
      v21 = *((char *)&v18->_vptr$CPlaceable + (_DWORD)v20);
    }
    while ( v21 > -1 );
    *((_BYTE *)&v18->_vptr$CPlaceable + (_DWORD)v20) = v21 & 0x7F;
    v17->m_aFlags[v17->m_nFreeIndex] = (v17->m_aFlags[v17->m_nFreeIndex] + 1) & 0x7F | v17->m_aFlags[v17->m_nFreeIndex] & 0x80;
    v18 = (CObject *)v17->m_aStorage[v17->m_nFreeIndex];
LABEL_25:
    CObject::CObject(v18, pDummy);
  }
  return result;
}
// 4536DA: variable 'result' is possibly undefined

//----- (004537BC) --------------------------------------------------------
void __fastcall CObject::AddToControlCodeList(CObject *this)
{
  CPtrNodeDoubleLink *v2; // r0
  CPtrNode *m_pHead; // r1

  v2 = (CPtrNodeDoubleLink *)CPtrNodeDoubleLink::operator new(0xCu);
  v2->m_pVoid = this;
  this->m_pControlListNode = v2;
  v2->m_pPrevious = 0;
  m_pHead = CWorld::ms_listObjectsWithControlCode.m_pHead;
  v2->m_pNext = CWorld::ms_listObjectsWithControlCode.m_pHead;
  if ( m_pHead )
    m_pHead[1].m_pVoid = v2;
  CWorld::ms_listObjectsWithControlCode.m_pHead = v2;
}

//----- (004537F8) --------------------------------------------------------
Bool8 __fastcall CObject::CanBeDeleted(CObject *this)
{
  int v1; // r1
  Bool8 result; // r0

  v1 = this->ObjectCreatedBy - 2;
  result = 1;
  switch ( v1 )
  {
    case 0:
    case 2:
    case 3:
    case 4:
      result = 0;
      break;
    case 1:
      return result;
  }
  return result;
}

//----- (00453814) --------------------------------------------------------
void __fastcall CObject::SetRelatedDummy(CObject *this, CDummyObject *pDummy)
{
  this->m_pRelatedDummy = pDummy;
  sub_196050(pDummy, &this->m_pRelatedDummy);
}

//----- (00453824) --------------------------------------------------------
void __fastcall CObject::ProcessControl(CObject *this)
{
  unsigned __int8 *v2; // r5
  _BOOL4 v3; // r5
  int m_nModelIndex; // r0
  int m_nFlags; // r0
  CEntity::CFlags *p_m_nFlags; // r10
  bool v7; // zf
  CObject::CObjectFlags m_nPhysicalFlags; // r1
  int (**v9)(void); // r0
  float v10; // r0
  RwReal v11; // s2
  RwReal v12; // s0
  bool v13; // nf
  CPhysical::CPhysicalFlags v14; // r1
  int (**v15)(void); // r2
  float v16; // s0
  CMatrix *v17; // r0
  float x; // s16
  float y; // s18
  float v20; // s20
  float v21; // r0
  int v22; // r5
  uint32 bdummy; // r0
  float m_fOriginalAngle; // s16
  CMatrix *v25; // r0
  float m_heading; // s0
  float32x4_t v27; // q9
  float32x4_t v28; // q1
  float v29; // s0
  float v30; // s2
  float v31; // s8
  uint8 v32; // r2
  __int64 v33; // d16
  __int64 v34; // d16
  float v35; // s2
  float v36; // s0
  float v37; // s16
  float v38; // s0
  CObject::CObjectFlags m_nObjectFlags; // r0
  __int64 v40; // d16
  __int64 v41; // d17
  CPhysical::CPhysicalFlags v42; // r1
  CEntity *m_pDamageEntity; // r0
  int v44; // r0
  bool v45; // zf
  CPhysical *v46; // r6
  CMatrix *m_pMat; // r0
  CMatrix *v48; // r1
  CSimpleTransform *p_tx; // r2
  float *p_x; // r0
  float z; // s4
  RwReal v52; // s2
  float32x2_t v53; // d16
  unsigned __int64 v54; // d1
  CVector vecOffset; // [sp+0h] [bp-58h]
  CVector v56; // [sp+10h] [bp-48h] BYREF
  CVector pCentreOfBuoyancy; // [sp+1Ch] [bp-3Ch] BYREF
  CVector v58; // 0:r1.12
  CVector v59; // 0:r2.8,8:^0.4

  v2 = (unsigned __int8 *)CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
  v3 = (*(int (__fastcall **)(unsigned __int8 *))(*(_DWORD *)v2 + 40))(v2) == 2
    && v2[41] << 31
    && this->m_pRwObject != 0;
  if ( this->m_fDamageImpulseMagnitude > 0.0
    && (*((_BYTE *)&this->m_nObjectFlags + 2) & 8) != 0
    && !this->m_pAttachToEntity )
  {
    m_nModelIndex = this->m_nModelIndex;
    if ( MI_CRANE_MAGNET != m_nModelIndex
      && MI_CRANE_HARNESS != m_nModelIndex
      && MI_MINI_MAGNET != m_nModelIndex
      && MI_WRECKING_BALL != m_nModelIndex
      && (*(_BYTE *)&this->m_nPhysicalFlags & 0x60) == 0 )
    {
      m_pDamageEntity = this->m_pDamageEntity;
      if ( m_pDamageEntity )
      {
        v44 = m_pDamageEntity->m_nModelIndex;
        v45 = v44 == 530;
        if ( v44 != 530 )
          v45 = v44 == 406;
        if ( v45 && !CRopes::IsCarriedByRope(this) )
        {
          if ( this->m_nCollisionDamageEffect && this->m_fDamageImpulseMagnitude > 5.0 )
            CObject::ObjectDamage(
              this,
              this->m_fDamageImpulseMagnitude,
              &this->m_vecDamagePos,
              &this->m_vecDamageNormal,
              (int)this->m_pDamageEntity,
              WEAPONTYPE_RAMMEDBYCAR);
          if ( this->m_vecDamageNormal.z > 0.3 )
          {
            v46 = (CPhysical *)this->m_pDamageEntity;
            m_pMat = this->m_pMat;
            this->m_nNoOfStaticFrames = 0;
            v48 = v46->m_pMat;
            p_tx = (CSimpleTransform *)&m_pMat->tx;
            if ( !m_pMat )
              p_tx = &this->m_transform;
            p_x = &v48->tx;
            z = p_tx->m_translate.z;
            if ( !v48 )
              p_x = &v46->m_transform.m_translate.x;
            v52 = p_tx->m_translate.y - p_x[1];
            v59.x = p_tx->m_translate.x - *p_x;
            v59.y = v52;
            v59.z = z - p_x[2];
            CPhysical::GetSpeed(&pCentreOfBuoyancy, v46, v59);
            v53.n64_u64[0] = vsub_f32(*(float32x2_t *)&pCentreOfBuoyancy.y, *(float32x2_t *)&this->m_vecMoveSpeed.y).n64_u64[0];
            v54 = vmul_f32(v53, v53).n64_u64[0];
            if ( (float)((float)((float)((float)(pCentreOfBuoyancy.x - this->m_vecMoveSpeed.x)
                                       * (float)(pCentreOfBuoyancy.x - this->m_vecMoveSpeed.x))
                               + *(float *)&v54)
                       + *((float *)&v54 + 1)) < 0.0001
              && (float)((float)((float)(this->m_vecTurnSpeed.x * this->m_vecTurnSpeed.x)
                               + (float)(this->m_vecTurnSpeed.y * this->m_vecTurnSpeed.y))
                       + (float)(this->m_vecTurnSpeed.z * this->m_vecTurnSpeed.z)) < 0.0001 )
            {
              CPhysical::AttachEntityToEntity(this, v46, 0, 0);
              this->m_fElasticity = 0.2;
            }
          }
        }
      }
    }
  }
  p_m_nFlags = &this->m_nFlags;
  m_nFlags = (int)this->m_nFlags;
  v7 = (m_nFlags & (unsigned int)&stru_4000C.st_size) == 0;
  m_nPhysicalFlags = (CObject::CObjectFlags)(*(_DWORD *)&this->m_nObjectFlags & 0xFFF7FFFF);
  this->m_nObjectFlags = m_nPhysicalFlags;
  if ( (m_nFlags & (unsigned int)&stru_4000C.st_size) == 0 )
  {
    m_nPhysicalFlags = (CObject::CObjectFlags)this->m_nPhysicalFlags;
    v7 = (*(_BYTE *)&m_nPhysicalFlags & 0xE0) == 0;
  }
  if ( v7 )
  {
    v27.n128_u64[0] = 0x3F0000003F000000LL;
    v27.n128_u64[1] = 0x3F0000003F000000LL;
    v28 = vmulq_f32(
            vaddq_f32(*(float32x4_t *)&this->m_vecAverageMoveSpeed.x, *(float32x4_t *)&this->m_vecMoveSpeed.x),
            v27);
    v29 = (float)(this->m_vecAverageTurnSpeed.z + this->m_vecTurnSpeed.z) * 0.5;
    v30 = (float)(this->m_vecAverageTurnSpeed.y + this->m_vecTurnSpeed.y) * 0.5;
    *(float32x4_t *)&this->m_vecAverageMoveSpeed.x = v28;
    this->m_vecAverageTurnSpeed.y = v30;
    this->m_vecAverageTurnSpeed.z = v29;
    v31 = (float)(CTimer::ms_fTimeStep * 0.003) * (float)(CTimer::ms_fTimeStep * 0.003);
    if ( (float)((float)((float)(v28.n128_f32[0] * v28.n128_f32[0]) + (float)(v28.n128_f32[1] * v28.n128_f32[1]))
               + (float)(v28.n128_f32[2] * v28.n128_f32[2])) >= v31
      || (float)((float)((float)(v28.n128_f32[3] * v28.n128_f32[3]) + (float)(v30 * v30)) + (float)(v29 * v29)) >= v31 )
    {
      this->m_nNoOfStaticFrames = 0;
    }
    else
    {
      v32 = this->m_nNoOfStaticFrames + 1;
      this->m_nNoOfStaticFrames = v32;
      if ( v32 >= 0xBu && (*(_DWORD *)&m_nPhysicalFlags & 0x2000000) == 0 )
      {
        this->m_nNoOfStaticFrames = 10;
        if ( !v3 )
          (*((void (__fastcall **)(CObject *, int))this->_vptr$CPlaceable + 5))(this, 1);
        this->m_vecMoveSpeed.z = 0.0;
        this->m_vecMoveSpeed.x = 0.0;
        this->m_vecMoveSpeed.y = 0.0;
        v33 = *(_QWORD *)&this->m_vecMoveSpeed.x;
        this->m_vecMoveFriction.z = this->m_vecMoveSpeed.z;
        this->m_vecTurnSpeed.x = 0.0;
        this->m_vecTurnSpeed.y = 0.0;
        this->m_vecTurnSpeed.z = 0.0;
        *(_QWORD *)&this->m_vecMoveFriction.x = v33;
        v34 = *(_QWORD *)&this->m_vecTurnSpeed.x;
        this->m_vecTurnFriction.z = this->m_vecTurnSpeed.z;
        *(_QWORD *)&this->m_vecTurnFriction.x = v34;
        return;
      }
    }
  }
  if ( (m_nFlags & 0x40004) == 0 )
    CPhysical::ProcessControl(this);
  if ( v3 )
    (*((void (__fastcall **)(CObject *, _DWORD))this->_vptr$CPlaceable + 5))(this, 0);
  if ( cBuoyancy::ProcessBuoyancy(&mod_Buoyancy, this, this->m_fBuoyancyConstant, &pCentreOfBuoyancy, &v56) == 1 )
  {
    v9 = this->_vptr$CPlaceable;
    *(_DWORD *)&this->m_nPhysicalFlags |= 0x8000100u;
    ((void (__fastcall *)(CObject *, _DWORD))v9[5])(this, 0);
    CPhysical::ApplyMoveForce(this, v56);
    CPhysical::ApplyTurnForce(this, v56, pCentreOfBuoyancy);
    v10 = powf(0.97, CTimer::ms_fTimeStep);
    v11 = v10 * this->m_vecTurnSpeed.y;
    v12 = v10 * this->m_vecTurnSpeed.z;
    *(float32x4_t *)&this->m_vecMoveSpeed.x = vmulq_n_f32(*(float32x4_t *)&this->m_vecMoveSpeed.x, v10);
    this->m_vecTurnSpeed.y = v11;
    this->m_vecTurnSpeed.z = v12;
  }
  else if ( this->m_nModelIndex != MI_BUOY )
  {
    *(_DWORD *)&this->m_nPhysicalFlags &= ~0x8000000u;
  }
  if ( this->m_pObjectInfo->m_causesExplosion )
  {
    v13 = (*(_BYTE *)&this->m_nObjectFlags & 0x40) != 0;
    if ( (*(_BYTE *)&this->m_nObjectFlags & 0x40) != 0 )
      v13 = (*(_BYTE *)p_m_nFlags & 0x80) != 0;
    if ( v13 && (rand() & 0x1F) == 10 )
    {
      v14 = this->m_nPhysicalFlags;
      *(_DWORD *)p_m_nFlags &= 0xFFFFFF7E;
      v15 = this->_vptr$CPlaceable;
      this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&v14 & 0xFF7FFFFD | 0x800000);
      this->m_vecMoveSpeed.x = 0.0;
      this->m_vecMoveSpeed.y = 0.0;
      this->m_vecMoveSpeed.z = 0.0;
      ((void (__fastcall *)(CObject *))v15[9])(this);
    }
  }
  if ( this->m_nModelIndex == MI_RCBOMB )
  {
    v16 = this->m_fTurnMass * -0.05;
    v17 = this->m_pMat;
    v58.x = this->m_vecMoveSpeed.x * v16;
    v58.y = v16 * this->m_vecMoveSpeed.y;
    v58.z = v16 * this->m_vecMoveSpeed.z;
    vecOffset.x = -v17->xy;
    vecOffset.y = -v17->yy;
    vecOffset.z = -v17->zy;
    CPhysical::ApplyTurnForce(this, v58, vecOffset);
    x = this->m_vecMoveSpeed.x;
    y = this->m_vecMoveSpeed.y;
    v20 = this->m_vecMoveSpeed.z;
    v21 = powf(
            (float)((float)((float)((float)(x * x) + (float)(y * y)) + (float)(v20 * v20)) * -0.2) + 1.0,
            CTimer::ms_fTimeStep);
    this->m_vecMoveSpeed.x = x * v21;
    this->m_vecMoveSpeed.y = v21 * y;
    this->m_vecMoveSpeed.z = v21 * v20;
  }
  v22 = *(_DWORD *)p_m_nFlags;
  if ( (*(_DWORD *)p_m_nFlags & 0x100) != 0 )
  {
    bdummy = this->m_nFlags.bdummy;
    v22 |= 0x20u;
    *(_DWORD *)p_m_nFlags = v22;
    this->m_nFlags.bdummy = bdummy;
  }
  if ( (*(_BYTE *)&this->m_nPhysicalFlags & 0x20) != 0 )
  {
    m_fOriginalAngle = this->m_fOriginalAngle;
    if ( m_fOriginalAngle > -1000.0 )
    {
      v25 = this->m_pMat;
      if ( v25 )
        m_heading = atan2f(COERCE_FLOAT(LODWORD(v25->xy) ^ 0x80000000), v25->yy);
      else
        m_heading = this->m_transform.m_heading;
      if ( m_heading <= (float)(m_fOriginalAngle + 3.1416) )
      {
        if ( m_heading >= (float)(m_fOriginalAngle + -3.1416) )
        {
LABEL_53:
          v36 = m_fOriginalAngle - m_heading;
          v37 = 0.3;
          if ( fabsf(v36) > 0.5236 )
            *(_DWORD *)&this->m_nObjectFlags |= 0x8000u;
          if ( v36 > 0.3 )
            goto LABEL_56;
          v37 = -0.3;
          if ( v36 < -0.3 )
            goto LABEL_61;
          v37 = v36;
          if ( v36 > 0.0 )
          {
LABEL_56:
            v38 = this->m_vecTurnSpeed.z;
            if ( v38 < 0.02 )
            {
LABEL_62:
              this->m_vecTurnSpeed.z = v38 + (float)((float)(v37 * 0.002) * CTimer::ms_fTimeStep);
LABEL_63:
              if ( v37 != 0.0 && (*((_BYTE *)&this->m_nObjectFlags + 1) & 0x40) != 0 )
              {
                CAudioEngine::ReportDoorMovement(&AudioEngine, this);
                v22 = *(_DWORD *)p_m_nFlags;
              }
              if ( fabsf(v37) < 0.01
                && (v22 & (unsigned int)&stru_4000C.st_size) == 0
                && ((*((_BYTE *)&this->m_nObjectFlags + 1) & 0x40) != 0 || fabsf(this->m_vecTurnSpeed.z) < 0.01) )
              {
                (*((void (__fastcall **)(CObject *, int))this->_vptr$CPlaceable + 5))(this, 1);
                this->m_vecMoveSpeed.x = 0.0;
                this->m_vecMoveSpeed.y = 0.0;
                m_nObjectFlags = this->m_nObjectFlags;
                v40 = *(_QWORD *)&this->m_vecMoveSpeed.x;
                this->m_vecTurnSpeed.x = 0.0;
                this->m_vecTurnSpeed.y = 0.0;
                v41 = *(_QWORD *)&this->m_vecTurnSpeed.x;
                this->m_vecMoveFriction.z = 0.0;
                this->m_vecTurnFriction.z = 0.0;
                this->m_vecTurnSpeed.z = 0.0;
                this->m_vecMoveSpeed.z = 0.0;
                *(_QWORD *)&this->m_vecMoveFriction.x = v40;
                *(_QWORD *)&this->m_vecTurnFriction.x = v41;
                if ( (*(_WORD *)&m_nObjectFlags & 0xC000) == 49152 )
                {
                  v42 = this->m_nPhysicalFlags;
                  this->m_nObjectFlags = (CObject::CObjectFlags)(*(_DWORD *)&m_nObjectFlags & 0xFFFF7FFF);
                  this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&v42 | 0xC);
                  CObject::ResetDoorAngle(this);
                }
              }
              return;
            }
          }
          if ( v37 >= 0.0 )
            goto LABEL_63;
LABEL_61:
          v38 = this->m_vecTurnSpeed.z;
          if ( v38 <= -0.02 )
            goto LABEL_63;
          goto LABEL_62;
        }
        v35 = 6.2832;
      }
      else
      {
        v35 = -6.2832;
      }
      m_heading = m_heading + v35;
      goto LABEL_53;
    }
  }
}
// 4000C: using guessed type Elf32_Sym stru_4000C;

//----- (00453F70) --------------------------------------------------------
void __fastcall CObject::ObjectDamage(
        CObject *this,
        float fImpulse,
        CVector *colPos,
        CVector *colNormal,
        int a5,
        eWeaponType a6)
{
  float32x2_t v6; // d0
  float32x2_t v7; // d2
  CEntity::CFlags *p_m_nFlags; // r10
  eWeaponType v13; // r5
  int m_nCollisionDamageEffect; // r0
  int v15; // r0
  int v16; // r0
  CObjectInfo *m_pObjectInfo; // r1
  float v18; // s0
  unsigned int v19; // r2
  int v20; // r0
  bool v21; // zf
  float m_breakVelY; // r2
  float m_breakVelZ; // r3
  float m_breakVelRand; // r3
  _BOOL4 v25; // r1
  uint32 v26; // r0
  unsigned int v27; // r2
  unsigned int v28; // r1
  int (**v29)(void); // r0
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r1
  unsigned int v31; // r2
  uint32 v32; // r0
  unsigned int v33; // r1
  CObject::CObjectFlags m_nObjectFlags; // r2
  int v35; // r1
  unsigned int v36; // r1
  uint32 bdummy; // r2
  CObject::CObjectFlags v38; // r0
  int v39; // r0
  CObjectInfo *v40; // r1
  int m_fxMode; // r2
  FxSystem_c *FxSystem; // r4
  CObjectInfo *v43; // r0
  __int64 v44; // d16
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float y; // s8
  float z; // s10
  CVector v; // [sp+8h] [bp-A0h] BYREF
  CVector v50; // [sp+18h] [bp-90h] BYREF
  CMatrix vel; // [sp+28h] [bp-80h] BYREF
  RwV3d_0 offsetPos; // [sp+70h] [bp-38h] BYREF

  p_m_nFlags = &this->m_nFlags;
  if ( (*(_BYTE *)&this->m_nFlags & 1) == 0 )
    return;
  v13 = a6;
  if ( a5 )
  {
    if ( a6 == WEAPONTYPE_UNIDENTIFIED )
    {
      v13 = WEAPONTYPE_UNIDENTIFIED;
      if ( (*(_BYTE *)(a5 + 58) & 7) == 2 )
        v13 = WEAPONTYPE_RUNOVERBYCAR;
    }
  }
  if ( !CPhysical::CanPhysicalBeDamaged(this, v13, 0) )
    return;
  v7.n64_u32[0] = 0;
  m_nCollisionDamageEffect = this->m_nCollisionDamageEffect;
  v6.n64_f32[0] = this->m_fHealth - (float)(this->m_pObjectInfo->m_fCollisionDamageMultiplier * fImpulse);
  LODWORD(this->m_fHealth) = vmax_f32(v6, v7).n64_u32[0];
  if ( !m_nCollisionDamageEffect
    || (*((_BYTE *)&this->m_nPhysicalFlags + 2) & 0x40) != 0
    && FindPlayerPed(-1) != (CPlayerPed *)a5
    && FindPlayerVehicle(-1, 0) != (CVehicle *)a5 )
  {
    return;
  }
  if ( this->m_nModelIndex == MI_IMY_SHASH_WALL )
  {
    if ( !a5 )
      return;
    v15 = *(_BYTE *)(a5 + 58) & 7;
    if ( v15 == 3 )
    {
      if ( !(*(unsigned __int8 *)(a5 + 1157) << 31) )
        return;
      v16 = *(_DWORD *)(a5 + 1424);
      if ( !v16 )
        return;
    }
    else
    {
      v21 = v15 == 2;
      v16 = a5;
      if ( !v21 )
        return;
    }
    if ( *(_WORD *)(v16 + 38) != 601 )
      return;
  }
  else if ( !a5 )
  {
    goto LABEL_19;
  }
  if ( *(_WORD *)(a5 + 38) == 530 )
    return;
LABEL_19:
  m_pObjectInfo = this->m_pObjectInfo;
  this->LastDamagedWeaponType = v13;
  v18 = m_pObjectInfo->m_fCollisionDamageMultiplier * fImpulse;
  if ( v18 <= 150.0 && this->m_fHealth != 0.0 )
    goto LABEL_56;
  v19 = this->m_nCollisionDamageEffect;
  v20 = 0;
  if ( v19 <= 0x14 )
  {
    if ( v19 == 1 )
    {
      v36 = *(_DWORD *)p_m_nFlags;
      if ( (*(_DWORD *)p_m_nFlags & 0x200) != 0 )
      {
        bdummy = p_m_nFlags->bdummy;
        v20 = 0;
      }
      else
      {
        (*((void (__fastcall **)(CObject *))this->_vptr$CPlaceable + 9))(this);
        bdummy = p_m_nFlags->bdummy;
        v36 = *(_DWORD *)p_m_nFlags;
        v20 = 1;
      }
      *(_DWORD *)p_m_nFlags = v36 | 0x200;
      p_m_nFlags->bdummy = bdummy;
      goto LABEL_50;
    }
    if ( v19 != 20 )
      goto LABEL_50;
    v26 = p_m_nFlags->bdummy;
    v27 = *(_DWORD *)p_m_nFlags;
    v28 = *(_DWORD *)p_m_nFlags & 0xFFFFFF7E;
    *(_DWORD *)p_m_nFlags = v28;
    if ( (v27 & 0x40004) != 0 )
      goto LABEL_36;
LABEL_35:
    CPhysical::RemoveFromMovingList(this);
    v26 = p_m_nFlags->bdummy;
    v28 = *(_DWORD *)p_m_nFlags;
LABEL_36:
    *(_DWORD *)p_m_nFlags = v28 | 4;
    p_m_nFlags->bdummy = v26;
    *(_QWORD *)&this->m_vecMoveSpeed.x = 0LL;
    *(_QWORD *)&this->m_vecMoveSpeed.z = 0LL;
    v29 = this->_vptr$CPlaceable;
    m_nPhysicalFlags = this->m_nPhysicalFlags;
    this->m_vecTurnSpeed.y = 0.0;
    this->m_vecTurnSpeed.z = 0.0;
    this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags | 0x800000);
LABEL_43:
    ((void (__fastcall *)(CObject *))v29[9])(this);
    v20 = 1;
    goto LABEL_50;
  }
  if ( v19 == 21 )
  {
    v31 = *(_DWORD *)p_m_nFlags;
    if ( (*(_DWORD *)p_m_nFlags & 0x200) == 0 )
    {
      (*((void (__fastcall **)(CObject *))this->_vptr$CPlaceable + 9))(this);
      *(_DWORD *)p_m_nFlags |= 0x200u;
      v20 = 0;
      goto LABEL_50;
    }
    v26 = p_m_nFlags->bdummy;
    v28 = v31 & 0xFFFFFF7E;
    *(_DWORD *)p_m_nFlags = v31 & 0xFFFFFF7E;
    p_m_nFlags->bdummy = v26;
    if ( (v31 & 0x40004) != 0 )
      goto LABEL_36;
    goto LABEL_35;
  }
  v21 = v19 == 202;
  if ( v19 != 202 )
    v21 = v19 == 200;
  if ( v21 )
  {
    m_breakVelY = m_pObjectInfo->m_breakVelY;
    m_breakVelZ = m_pObjectInfo->m_breakVelZ;
    vel.xx = m_pObjectInfo->m_breakVelX;
    vel.yx = m_breakVelY;
    vel.zx = m_breakVelZ;
    m_breakVelRand = m_pObjectInfo->m_breakVelRand;
    v25 = v18 > (float)(m_pObjectInfo->m_smashMult * 150.0);
    BreakManager_c::Add(&g_breakMan, this, (RwV3d_0 *)&vel, m_breakVelRand, v25);
    v32 = p_m_nFlags->bdummy;
    v33 = *(_DWORD *)p_m_nFlags & 0xFFFFFF7E;
    v21 = (*(_DWORD *)p_m_nFlags & 0x40004) == 0;
    *(_DWORD *)p_m_nFlags = v33;
    if ( v21 )
    {
      CPhysical::RemoveFromMovingList(this);
      v32 = p_m_nFlags->bdummy;
      v33 = *(_DWORD *)p_m_nFlags;
    }
    *(_DWORD *)p_m_nFlags = v33 | 4;
    p_m_nFlags->bdummy = v32;
    m_nObjectFlags = this->m_nObjectFlags;
    v29 = this->_vptr$CPlaceable;
    v35 = *(_DWORD *)&this->m_nPhysicalFlags | 0x800000;
    *(_QWORD *)&this->m_vecMoveSpeed.x = 0LL;
    *(_QWORD *)&this->m_vecMoveSpeed.z = 0LL;
    this->m_vecTurnSpeed.y = 0.0;
    this->m_vecTurnSpeed.z = 0.0;
    this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)v35;
    this->m_nObjectFlags = (CObject::CObjectFlags)(*(_DWORD *)&m_nObjectFlags | 0x400);
    goto LABEL_43;
  }
LABEL_50:
  if ( (*(_BYTE *)p_m_nFlags & 0x81) == 0 )
    this->m_fHealth = 0.0;
  if ( v20 == 1 )
  {
    if ( this->m_pObjectInfo->m_causesExplosion )
    {
      v38 = this->m_nObjectFlags;
      if ( (*(_BYTE *)&v38 & 0x40) == 0 )
      {
        this->m_nObjectFlags = (CObject::CObjectFlags)(*(_DWORD *)&v38 | 0x40);
        CObject::Explode(this);
        CAudioEngine::ReportObjectDestruction(&AudioEngine, this);
        return;
      }
    }
    CAudioEngine::ReportObjectDestruction(&AudioEngine, this);
    v39 = 1;
    goto LABEL_58;
  }
LABEL_56:
  v39 = 0;
LABEL_58:
  v40 = this->m_pObjectInfo;
  m_fxMode = v40->m_fxMode;
  if ( !v40->m_fxMode )
    return;
  if ( m_fxMode != 3 )
  {
    if ( v39 )
    {
      if ( ((unsigned __int8)v39 & (m_fxMode == 2)) != 1 )
        return;
    }
    else
    {
      if ( m_fxMode != 1 )
        LOBYTE(m_fxMode) = 0;
      if ( ((fImpulse > 30.0) & (unsigned __int8)m_fxMode) == 0 )
        return;
    }
  }
  if ( v40->m_fxOffset.x >= -500.0 )
  {
    CMatrix::CMatrix(&vel, this->m_pMat);
    v43 = this->m_pObjectInfo;
    v44 = *(_QWORD *)&v43->m_fxOffset.x;
    v.z = v43->m_fxOffset.z;
    *(_QWORD *)&v.x = v44;
    Multiply3x3(&v50, &vel, &v);
    offsetPos = v50.RwV3d_0;
    m_pMat = this->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &this->m_transform;
    y = p_tx->m_translate.y;
    z = p_tx->m_translate.z;
    offsetPos.x = p_tx->m_translate.x + v50.x;
    offsetPos.y = y + v50.y;
    offsetPos.z = z + v50.z;
    FxSystem = FxManager_c::CreateFxSystem(&g_fxMan, this->m_pObjectInfo->m_pFxSysBP, &offsetPos, 0, 0);
    CMatrix::~CMatrix(&vel);
  }
  else
  {
    if ( !colPos )
      return;
    Fx_c::CreateMatFromVec(&g_fx, (RwMatrix *)&vel, colPos, colNormal);
    FxSystem = FxManager_c::CreateFxSystem(&g_fxMan, this->m_pObjectInfo->m_pFxSysBP, (RwMatrix *)&vel, 0, 0);
  }
  if ( FxSystem )
    FxSystem_c::PlayAndKill(FxSystem);
}
// 4540E2: conditional instruction was optimized away because r11.4!=0
// 453FE6: variable 'v6' is possibly undefined
// 453FE6: variable 'v7' is possibly undefined

//----- (004543BC) --------------------------------------------------------
void __fastcall CObject::LockDoor(CObject *this)
{
  CObject::CObjectFlags m_nObjectFlags; // r2

  m_nObjectFlags = this->m_nObjectFlags;
  *(_DWORD *)&this->m_nPhysicalFlags |= 0xCu;
  this->m_nObjectFlags = (CObject::CObjectFlags)(*(_DWORD *)&m_nObjectFlags & 0xFFFF7FFF);
  CObject::ResetDoorAngle(this);
}

//----- (004543D4) --------------------------------------------------------
void __fastcall CObject::ProcessControlLogic(CObject *this)
{
  int m_nModelIndex; // r0
  Int32 Rope; // r0
  unsigned int v4; // r6
  CRope *v5; // r0
  float m_fWinchHeight; // s6
  float v7; // s16
  int v8; // r0
  UInt32 v9; // r5
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  CVector v12; // [sp+18h] [bp-30h] BYREF
  CVector v; // [sp+24h] [bp-24h] BYREF

  m_nModelIndex = this->m_nModelIndex;
  if ( m_nModelIndex == MI_SAMSITE || m_nModelIndex == MI_SAMSITE2 )
  {
    CObject::ProcessSamSiteBehaviour(this);
    LOWORD(m_nModelIndex) = this->m_nModelIndex;
  }
  if ( (__int16)m_nModelIndex == MI_TRAINCROSSING || (__int16)m_nModelIndex == MI_TRAINCROSSING1 )
  {
    CObject::ProcessTrainCrossingBehaviour(this);
    LOWORD(m_nModelIndex) = this->m_nModelIndex;
  }
  if ( (__int16)m_nModelIndex == MI_MAGNOCRANE
    || (__int16)m_nModelIndex == MI_CRANETROLLEY
    || (__int16)m_nModelIndex == MI_QUARRYCRANE_ARM )
  {
    Rope = CRopes::FindRope((u_native)this);
    LOBYTE(v4) = 0;
    memset(&v, 0, sizeof(v));
    if ( Rope < 0 )
    {
      v7 = 0.0;
    }
    else
    {
      v5 = &CRopes::aRopes[Rope];
      m_fWinchHeight = v5->m_fWinchHeight;
      v4 = (unsigned int)(float)(m_fWinchHeight * 32.0);
      v7 = (float)((float)(m_fWinchHeight * v5->m_RopeLength)
                 - (float)(v5->m_SegmentLength * (float)(int)(float)(m_fWinchHeight * 32.0)))
         + 0.0;
    }
    v8 = this->m_nModelIndex;
    if ( v8 == MI_MAGNOCRANE )
    {
      v9 = 4;
      v.y = 36.64;
      v.z = -1.69;
      v.x = 0.0;
    }
    else if ( v8 == MI_CRANETROLLEY )
    {
      m_pMat = this->m_pMat;
      v9 = 7;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &this->m_transform;
      if ( p_tx->m_translate.x < 0.0 )
        v9 = 5;
    }
    else
    {
      v9 = 6;
      v.z = 59.0;
      v.x = 0.0;
      v.y = 0.0;
    }
    operator*(&v12, this->m_pMat, &v);
    v12.z = v7 + v12.z;
    CRopes::RegisterRope((u_native)this, v9, v12, 0, v4, 1, this, 20000);
    LOWORD(m_nModelIndex) = this->m_nModelIndex;
  }
  if ( CGarages::IsModelIndexADoor((__int16)m_nModelIndex) )
    CObject::ProcessGarageDoorBehaviour(this);
}

//----- (004545A4) --------------------------------------------------------
void __fastcall CObject::ProcessSamSiteBehaviour(CObject *this)
{
  float i; // s18
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_m_transform; // r5
  CSimpleTransform *p_tx; // r0
  char **v6; // r0
  float ATanOfXY; // r6
  float v8; // s16
  CVehicle *v9; // r0
  CVehicle *v10; // r0
  CPlayerPed *PlayerPed; // r0
  CEntity *PlayerVehicle; // r0
  CEntity *v13; // r8
  CMatrix *v14; // r1
  CSimpleTransform *v15; // r0
  CMatrix *v16; // r2
  float *p_x; // r1
  float v18; // s0
  int v19; // r6
  float v20; // s0
  RwObject_0 *m_pRwObject; // r0
  char *parent; // r1
  CMatrix *v23; // r0
  RwMatrix *v24; // r1
  CMatrix *v25; // r0
  CMatrix *v26; // r1
  float32x2_t *v27; // r2
  float32x2_t v28; // d16
  unsigned __int64 v29; // d0
  RwReal v30; // s0
  float zy; // s4
  float zz; // s10
  RwReal v33; // s2
  float v34; // s2
  CVector v; // [sp+14h] [bp-44h] BYREF
  CVector v36; // [sp+20h] [bp-38h] BYREF
  CVector pFireDirn; // [sp+2Ch] [bp-2Ch] BYREF

  if ( (*((_BYTE *)&this->m_nObjectFlags + 1) & 4) == 0 )
  {
    m_pMat = this->m_pMat;
    p_m_transform = &this->m_transform;
    p_tx = &this->m_transform;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    v6 = p_tx->m_translate.x >= -1000.0 ? CObject::bArea51SamSiteDisabled : CObject::bAircraftCarrierSamSiteDisabled;
    if ( !**v6 )
    {
      ATanOfXY = CGeneral::GetATanOfXY(m_pMat->xy, m_pMat->yy);
      v8 = ATanOfXY;
      if ( !FindPlayerVehicle(-1, 0)
        || (v9 = FindPlayerVehicle(-1, 0), CVehicle::GetVehicleAppearance(v9) == APR_BIKE)
        || (v10 = FindPlayerVehicle(-1, 0), CVehicle::GetVehicleAppearance(v10) == APR_CAR) )
      {
        PlayerPed = FindPlayerPed(-1);
        if ( !CPedIntelligence::GetTaskJetPack(PlayerPed->m_pPedIntelligence) )
          goto LABEL_21;
        PlayerVehicle = FindPlayerPed(-1);
      }
      else
      {
        PlayerVehicle = FindPlayerVehicle(-1, 0);
      }
      v13 = PlayerVehicle;
      if ( PlayerVehicle )
      {
        v14 = this->m_pMat;
        v15 = &this->m_transform;
        if ( v14 )
          v15 = (CSimpleTransform *)&v14->tx;
        v16 = v13->m_pMat;
        p_x = &v16->tx;
        if ( !v16 )
          p_x = &v13->m_transform.m_translate.x;
        if ( p_x[2] >= (float)(v15->m_translate.z + -2.0) )
        {
          v18 = p_x[1];
          if ( v18 <= 2100.0 )
          {
            v20 = CGeneral::GetATanOfXY(*p_x - v15->m_translate.x, v18 - v15->m_translate.y);
            for ( i = v20 - ATanOfXY; i > 3.1416; i = i + -6.2832 )
              ;
            for ( ; i < -3.1416; i = i + 6.2832 )
              ;
            v34 = CTimer::ms_fTimeStep * 0.05;
            if ( fabsf(i) <= (float)(CTimer::ms_fTimeStep * 0.05) )
            {
              v19 = 1;
            }
            else
            {
              v19 = 1;
              if ( i < 0.0 )
                v20 = v8 - v34;
              else
                v20 = v8 + v34;
            }
            goto LABEL_22;
          }
        }
      }
LABEL_21:
      v19 = 0;
      v13 = 0;
      v20 = v8 + (float)(CTimer::ms_fTimeStep * 0.005);
LABEL_22:
      CMatrix::SetRotateZOnly(this->m_pMat, v20 + -1.5708);
      m_pRwObject = this->m_pRwObject;
      if ( m_pRwObject )
      {
        parent = (char *)m_pRwObject->parent;
        v23 = this->m_pMat;
        v24 = (RwMatrix *)(parent + 16);
        if ( v23 )
          CMatrix::UpdateRwMatrix(v23, v24);
        else
          CSimpleTransform::UpdateRwMatrix(&this->m_transform, v24);
      }
      CEntity::UpdateRwFrame(this);
      if ( v19 == 1 )
      {
        v25 = v13->m_pMat;
        v26 = this->m_pMat;
        v27 = (float32x2_t *)&v25->tx;
        if ( !v25 )
          v27 = (float32x2_t *)&v13->m_transform;
        if ( v26 )
          p_m_transform = (CSimpleTransform *)&v26->tx;
        v28.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.x, (float32x2_t)v27->n64_u64[0]).n64_u64[0];
        v29 = vmul_f32(v28, v28).n64_u64[0];
        if ( sqrtf(*(float *)&v29 + *((float *)&v29 + 1)) < 120.0
          && fabsf(i) < 0.1
          && CTimer::m_snTimeInMilliseconds / 0xFA0 != CTimer::m_snPreviousTimeInMilliseconds / 0xFA0 )
        {
          v30 = v26->xy + v26->xz;
          zy = v26->zy;
          zz = v26->zz;
          v33 = v26->yy + v26->yz;
          v.y = 2.0;
          v.x = 0.0;
          v.z = 4.0;
          pFireDirn.y = v33;
          pFireDirn.x = v30;
          pFireDirn.z = zy + zz;
          operator*(&v36, v26, &v);
          CProjectileInfo::AddProjectile(this, WEAPONTYPE_ROCKET_HS, v36, 0.0, &pFireDirn, v13);
        }
      }
    }
  }
}
// 454738: variable 'i' is possibly undefined
// 678360: using guessed type char *CObject::bArea51SamSiteDisabled[2];
// 679D88: using guessed type char *CObject::bAircraftCarrierSamSiteDisabled[5];

//----- (004548C4) --------------------------------------------------------
void __fastcall CObject::ProcessTrainCrossingBehaviour(CObject *this)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r4
  CSimpleTransform *p_tx; // r2
  CTrain *NearestTrain; // r0
  CObject::CObjectFlags m_nObjectFlags; // r1
  __int16 v7; // r2
  CMatrix *v8; // r3
  CMatrix *v9; // r6
  float32x2_t *v10; // r3
  float32x2_t v11; // d16
  unsigned __int64 v12; // d0
  int16 *p_m_nModelIndex; // r4
  CDummyObject *v14; // r0
  float v15; // s0
  float v16; // s2
  __int16 Value; // r6
  CMatrix *v18; // r1
  float *v19; // r2
  float v20; // s4
  float v21; // s6
  CDummyObject *m_pRelatedDummy; // r0
  CMatrix *v23; // r1
  float *p_x; // r2
  CMatrix *v25; // r5
  float v26; // r0
  float v27; // s0
  float v28; // s0
  float v29; // s16
  float v30; // r4
  float v31; // r0
  RwReal y; // r1
  RwReal z; // r2
  RwObject_0 *m_pRwObject; // r0
  char *parent; // r1
  CMatrix *v36; // r0
  RwMatrix *v37; // r1
  CVector v38; // [sp+Ch] [bp-3Ch] BYREF
  CVector v1; // [sp+18h] [bp-30h] BYREF
  CVector v40; // [sp+24h] [bp-24h] BYREF

  if ( ((CTimer::m_FrameCounter + this->RandomSeed) & 0x10) != 0 )
  {
    p_m_nModelIndex = &this->m_nModelIndex;
    goto LABEL_23;
  }
  m_pMat = this->m_pMat;
  p_m_transform = &this->m_transform;
  p_tx = &this->m_transform;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  NearestTrain = CTrain::FindNearestTrain(p_tx->m_translate, 1);
  m_nObjectFlags = this->m_nObjectFlags;
  v7 = *(_WORD *)&m_nObjectFlags & 0xF7FF;
  this->m_nObjectFlags = (CObject::CObjectFlags)(*(_DWORD *)&m_nObjectFlags & 0xFFFFF7FF);
  if ( NearestTrain )
  {
    v8 = this->m_pMat;
    v9 = NearestTrain->m_pMat;
    if ( v8 )
      p_m_transform = (CSimpleTransform *)&v8->tx;
    v10 = (float32x2_t *)&v9->tx;
    if ( !v9 )
      v10 = (float32x2_t *)&NearestTrain->m_transform;
    v11.n64_u64[0] = vsub_f32((float32x2_t)v10->n64_u64[0], *(float32x2_t *)&p_m_transform->m_translate.x).n64_u64[0];
    v12 = vmul_f32(v11, v11).n64_u64[0];
    if ( sqrtf(*(float *)&v12 + *((float *)&v12 + 1)) < 120.0 )
    {
      v7 = *(_WORD *)&m_nObjectFlags | 0x800;
      this->m_nObjectFlags = (CObject::CObjectFlags)(*(_DWORD *)&m_nObjectFlags | 0x800);
    }
  }
  p_m_nModelIndex = &this->m_nModelIndex;
  if ( this->m_nModelIndex == MI_TRAINCROSSING1 )
  {
    if ( (*(_WORD *)&m_nObjectFlags & 0x800) != 0 )
    {
      if ( (v7 & 0x800) != 0 )
        goto LABEL_23;
      m_pRelatedDummy = this->m_pRelatedDummy;
      v15 = -12.0;
      v16 = 12.0;
      Value = 0;
      v23 = m_pRelatedDummy->m_pMat;
      p_x = &v23->tx;
      if ( !v23 )
        p_x = &m_pRelatedDummy->m_transform.m_translate.x;
      v20 = *p_x;
      v21 = p_x[1];
    }
    else
    {
      if ( (v7 & 0x800) == 0 )
        goto LABEL_23;
      v14 = this->m_pRelatedDummy;
      v15 = -12.0;
      v16 = 12.0;
      Value = 1;
      v18 = v14->m_pMat;
      v19 = &v18->tx;
      if ( !v18 )
        v19 = &v14->m_transform.m_translate.x;
      v20 = *v19;
      v21 = v19[1];
    }
    CPathFind::SetLinksBridgeLights(&ThePaths, v20 + v15, v20 + v16, v21 + v15, v21 + v16, Value);
  }
LABEL_23:
  if ( *p_m_nModelIndex != MI_TRAINCROSSING1 )
  {
    v25 = this->m_pMat;
    v26 = acosf(v25->zz);
    v27 = CTimer::ms_fTimeStep * 0.005;
    if ( (*((_BYTE *)&this->m_nObjectFlags + 1) & 8) != 0 )
    {
      v29 = v26 - v27;
      if ( (float)(v26 - v27) <= 0.0 )
        v29 = 0.0;
    }
    else
    {
      v28 = v26 + v27;
      v29 = 1.3509;
      if ( v28 < 1.3509 )
        v29 = v28;
    }
    v1.x = 0.0;
    v1.y = 0.0;
    v1.z = 1.0;
    CrossProduct(&v40, &v1, (const CVector *)v25);
    v30 = sinf(v29);
    v31 = cosf(v29);
    v1.x = (float)(v30 * 0.0) + (float)(v31 * v40.x);
    v1.y = (float)(v30 * 0.0) + (float)(v31 * v40.y);
    v1.z = v30 + (float)(v31 * v40.z);
    CrossProduct(&v38, (const CVector *)v25, &v1);
    *(CVector *)&v25->xz = v38;
    y = v1.y;
    z = v1.z;
    v25->xy = v1.x;
    v25->yy = y;
    v25->zy = z;
    m_pRwObject = this->m_pRwObject;
    if ( m_pRwObject )
    {
      parent = (char *)m_pRwObject->parent;
      v36 = this->m_pMat;
      v37 = (RwMatrix *)(parent + 16);
      if ( v36 )
        CMatrix::UpdateRwMatrix(v36, v37);
      else
        CSimpleTransform::UpdateRwMatrix(&this->m_transform, v37);
    }
    CEntity::UpdateRwFrame(this);
  }
}

//----- (00454B38) --------------------------------------------------------
void __fastcall CObject::DoBurnEffect(CObject *this)
{
  CColModel *m_pColModel; // r1
  float x; // s16
  float y; // s18
  float v4; // s24
  float z; // s20
  float v6; // s22
  float v7; // s26
  int v8; // r6
  FxPrtMult_c v10; // [sp+18h] [bp-A8h] BYREF
  FxPrtMult_c v11; // [sp+38h] [bp-88h] BYREF
  RwV3d_0 v12[8]; // [sp+58h] [bp-68h] BYREF

  m_pColModel = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel;
  x = m_pColModel->m_boxBound.m_vecMin.x;
  y = m_pColModel->m_boxBound.m_vecMin.y;
  v4 = m_pColModel->m_boxBound.m_vecMax.x - m_pColModel->m_boxBound.m_vecMin.x;
  z = m_pColModel->m_boxBound.m_vecMin.z;
  v6 = m_pColModel->m_boxBound.m_vecMax.y - y;
  v7 = m_pColModel->m_boxBound.m_vecMax.z - z;
  v8 = (int)(float)((float)(this->m_burnMult * (float)((float)(v4 * v6) * v7)) / 20.0);
  if ( v8 >= 1 )
  {
    do
    {
      v12[0].x = x + (float)(v4 * (float)((float)rand() * 4.6566e-10));
      v12[0].y = y + (float)(v6 * (float)((float)rand() * 4.6566e-10));
      v12[0].z = z + (float)(v7 * (float)((float)rand() * 4.6566e-10));
      operator*((CVector *)&v11, this->m_pMat, (const CVector *)v12);
      v12[0].z = v11.m_blue;
      *(_QWORD *)&v12[0].x = *(_QWORD *)&v11.m_red;
      FxPrtMult_c::FxPrtMult_c(&v11);
      FxPrtMult_c::FxPrtMult_c(&v10, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.4);
      v11 = v10;
      v10.m_red = 0.0;
      v10.m_green = 0.0;
      v10.m_blue = 0.02;
      FxSystem_c::AddParticle(g_fx.m_fxSysSmoke2, v12, (RwV3d_0 *)&v10, 0.0, &v11, -1.0, 1.2, 0.6, 0);
      --v8;
    }
    while ( v8 );
  }
}

//----- (00454CC4) --------------------------------------------------------
void __fastcall CObject::GetLightingFromCollisionBelow(CObject *this)
{
  bool v2; // zf
  CSimpleTransform *p_tx; // r0
  CMatrix *m_pMat; // r1
  CEntity *refEntityPtr; // [sp+20h] [bp-38h] BYREF
  CColPoint colPoint; // [sp+24h] [bp-34h] BYREF

  m_pMat = this->m_pMat;
  v2 = m_pMat == 0;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  LOWORD(m_pMat) = 0;
  if ( v2 )
    p_tx = &this->m_transform;
  HIWORD(m_pMat) = -15238;
  if ( CWorld::ProcessVerticalLine(&p_tx->m_translate, *(float *)&m_pMat, &colPoint, &refEntityPtr, 1, 0, 0, 0, 1, 0, 0) )
    this->m_storedCollisionLighting = colPoint.m_dataB.m_lighting;
}

//----- (00454D0C) --------------------------------------------------------
void __fastcall CObject::PreRender(CObject *this)
{
  CSimpleTransform *p_tx; // r0
  CMatrix *m_pMat; // r1
  int m_nModelIndex; // r0
  bool v5; // zf
  CMatrix *v6; // r1
  CSimpleTransform *p_m_transform; // r0
  CSimpleTransform *v8; // r1
  float32x2_t v9; // d16
  unsigned __int64 v10; // d1
  __int64 v11; // d16
  RpClump_0 *m_pRwObject; // r0
  int32 v13; // r1
  float m_fScale; // s0
  RwObject_0 *v15; // r0
  RwFrame_0 *parent; // r5
  CMatrix *v17; // r0
  RwObject_0 *v18; // r0
  CEntity *refEntityPtr; // [sp+34h] [bp-44h] BYREF
  CColPoint colPoint; // [sp+38h] [bp-40h] BYREF

  if ( (*((_BYTE *)&this->m_nObjectFlags + 2) & 0x80) != 0 )
  {
    m_pMat = this->m_pMat;
    v5 = m_pMat == 0;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    LOWORD(m_pMat) = 0;
    if ( v5 )
      p_tx = &this->m_transform;
    HIWORD(m_pMat) = -15238;
    if ( CWorld::ProcessVerticalLine(
           &p_tx->m_translate,
           *(float *)&m_pMat,
           &colPoint,
           &refEntityPtr,
           1,
           0,
           0,
           0,
           1,
           0,
           0) )
    {
      this->m_storedCollisionLighting = colPoint.m_dataB.m_lighting;
    }
  }
  if ( this->m_burnTimer > CTimer::m_snTimeInMilliseconds )
    CObject::DoBurnEffect(this);
  m_nModelIndex = (unsigned __int16)this->m_nModelIndex;
  v5 = m_nModelIndex == 1265;
  if ( m_nModelIndex != 1265 )
    v5 = m_nModelIndex == 1230;
  if ( v5 )
  {
    v6 = this->m_pMat;
    p_m_transform = (CSimpleTransform *)&v6->tx;
    if ( !v6 )
      p_m_transform = &this->m_transform;
    v8 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
    if ( !TheCamera.m_pMat )
      v8 = &TheCamera.m_transform;
    v9.n64_u64[0] = vsub_f32(*(float32x2_t *)&v8->m_translate.y, *(float32x2_t *)&p_m_transform->m_translate.y).n64_u64[0];
    v10 = vmul_f32(v9, v9).n64_u64[0];
    if ( sqrtf(
           (float)((float)((float)(v8->m_translate.x - p_m_transform->m_translate.x)
                         * (float)(v8->m_translate.x - p_m_transform->m_translate.x))
                 + *(float *)&v10)
         + *((float *)&v10 + 1)) < 50.0 )
    {
      v11 = *(_QWORD *)&p_m_transform->m_translate.x;
      colPoint.m_vecPosition.z = p_m_transform->m_translate.z;
      *(_QWORD *)&colPoint.m_vecPosition.x = v11;
      CShadows::StoreShadowToBeRendered(
        1u,
        gpShadowPedTex,
        &colPoint.m_vecPosition,
        0.6,
        0.0,
        0.0,
        -0.6,
        CTimeCycle::m_CurrentColours.m_nShadowStrength,
        CTimeCycle::m_CurrentColours.m_nShadowStrength,
        CTimeCycle::m_CurrentColours.m_nShadowStrength,
        CTimeCycle::m_CurrentColours.m_nShadowStrength,
        20.0,
        0,
        1.0,
        0,
        0);
    }
  }
  if ( !this->m_pAttachToEntity )
    this->m_lightingFromCollision = (float)(CCustomBuildingDNPipeline::m_fDNBalanceParam
                                          * (float)((float)((float)(this->m_storedCollisionLighting >> 4) * 0.5) / 15.0))
                                  + (float)((float)(1.0 - CCustomBuildingDNPipeline::m_fDNBalanceParam)
                                          * (float)((float)((float)(this->m_storedCollisionLighting & 0xF) * 0.5) / 15.0));
  m_pRwObject = (RpClump_0 *)this->m_pRwObject;
  if ( m_pRwObject && m_pRwObject->object.type == 2 && (*((_BYTE *)&this->m_nObjectFlags + 2) & 0x40) != 0 )
  {
    v13 = CVisibilityPlugins::GetClumpAlpha(m_pRwObject) - 16;
    if ( v13 <= 0 )
      v13 = 0;
    CVisibilityPlugins::SetClumpAlpha((RpClump_0 *)this->m_pRwObject, v13);
  }
  CEntity::PreRender(this);
  m_fScale = this->m_fScale;
  if ( m_fScale != 1.0 || (*((_BYTE *)&this->m_nObjectFlags + 2) & 2) != 0 )
  {
    colPoint.m_vecPosition.y = this->m_fScale;
    colPoint.m_vecPosition.x = m_fScale;
    colPoint.m_vecPosition.z = m_fScale;
    v15 = this->m_pRwObject;
    parent = (RwFrame_0 *)v15->parent;
    if ( v15 )
    {
      v17 = this->m_pMat;
      if ( v17 )
        CMatrix::UpdateRwMatrix(v17, &parent->modelling);
      else
        CSimpleTransform::UpdateRwMatrix(&this->m_transform, &parent->modelling);
    }
    RwMatrixScale(&parent->modelling, &colPoint.m_vecPosition, rwCOMBINEPRECONCAT);
    RwFrameUpdateObjects(parent);
    *(_DWORD *)&this->m_nObjectFlags &= ~0x20000u;
  }
  v18 = this->m_pRwObject;
  if ( v18 )
  {
    if ( v18->type == 2 )
      CEntity::UpdateRpHAnim(this);
  }
}

//----- (00454F54) --------------------------------------------------------
void __fastcall CObject::Render(CObject *this)
{
  CObject::CObjectFlags m_nObjectFlags; // r1
  int m_nParentModelIndex; // r0
  CVehicleModelInfo *v4; // r0
  RpAtomic_0 *m_pRwObject; // r0
  uint32 *v6; // [sp+4h] [bp-Ch] BYREF

  m_nObjectFlags = this->m_nObjectFlags;
  if ( (*(_DWORD *)&m_nObjectFlags & 0x2000000) == 0 )
  {
    m_nParentModelIndex = this->m_nParentModelIndex;
    if ( m_nParentModelIndex != -1 && (*(_BYTE *)&m_nObjectFlags & 0x80) != 0 && this->ObjectCreatedBy == 3 )
    {
      v4 = (CVehicleModelInfo *)CModelInfo::ms_modelInfoPtrs[m_nParentModelIndex];
      CVehicleModelInfo::ms_pRemapTexture = this->m_pRemapTexture;
      CVehicleModelInfo::SetVehicleColour(v4, this->m_colour1, this->m_colour2, this->m_colour3, this->m_colour4);
      m_pRwObject = (RpAtomic_0 *)this->m_pRwObject;
      if ( m_pRwObject->object.object.type == 1 )
      {
        v6 = CObject::Render(void)::gStoredMaterials;
        CVehicleModelInfo::SetEditableMaterialsCB(m_pRwObject, &v6);
      }
    }
    CEntity::Render(this);
  }
}

//----- (00454FD4) --------------------------------------------------------
void __fastcall CObject::SpecialEntityPreCollisionStuff(
        CObject *this,
        CPhysical *pPhysical,
        int bDoingShift,
        bool *bSkipTestEntirely,
        _BYTE *a5,
        _BYTE *a6,
        _BYTE *a7)
{
  CPhysical *v8; // r6
  CPhysical *m_pNOCollisionVehicle; // r0
  bool v11; // zf
  CPhysical *m_pAttachToEntity; // r0
  bool v13; // zf
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r2
  int m_nFlags; // r0
  bool v17; // nf
  CObject::CObjectFlags m_nObjectFlags; // lr
  int m_nModelIndex; // r2
  int v20; // r0
  int v21; // r0
  bool v22; // zf
  CColModel *ColModel; // r0
  RwReal v24; // s0
  float z; // s4
  float v26; // s10
  const CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  CMatrix *v29; // r0
  bool v30; // zf
  CVector v31; // [sp+0h] [bp-80h] BYREF
  CVector v; // [sp+10h] [bp-70h] BYREF
  CMatrix output; // [sp+20h] [bp-60h] BYREF

  v8 = pPhysical;
  m_pNOCollisionVehicle = (CPhysical *)this->m_pNOCollisionVehicle;
  v11 = m_pNOCollisionVehicle == pPhysical;
  if ( m_pNOCollisionVehicle != pPhysical )
    v11 = pPhysical->m_pNOCollisionVehicle == this;
  if ( v11 )
  {
    *a5 = 1;
    return;
  }
  m_pAttachToEntity = (CPhysical *)this->m_pAttachToEntity;
  v13 = m_pAttachToEntity == pPhysical;
  if ( m_pAttachToEntity != pPhysical )
  {
    pPhysical = (CPhysical *)pPhysical->m_pAttachToEntity;
    v13 = pPhysical == this;
  }
  if ( v13 || m_pAttachToEntity && m_pAttachToEntity == pPhysical )
    goto LABEL_11;
  m_nPhysicalFlags = this->m_nPhysicalFlags;
  if ( (*(_BYTE *)&m_nPhysicalFlags & 0x82) == 128 && (*(_BYTE *)&v8->m_nPhysicalFlags & 0x80) == 0 )
    goto LABEL_11;
  if ( (*(_BYTE *)&m_nPhysicalFlags & 0x80) != 0 )
  {
    if ( bDoingShift == 1 )
      goto LABEL_11;
LABEL_28:
    v17 = (*(_BYTE *)&this->m_nFlags & 0x10) != 0;
    if ( (*(_BYTE *)&this->m_nFlags & 0x10) == 0 )
      v17 = (*(_BYTE *)&v8->m_nFlags & 0x10) != 0;
    if ( v17 )
      *a7 = 1;
    goto LABEL_12;
  }
  if ( (*(_BYTE *)&m_nPhysicalFlags & 0x60) != 0 )
  {
    if ( !bDoingShift && (*(_BYTE *)&this->m_nFlags & 0x10) == 0 )
    {
      m_nFlags = (int)v8->m_nFlags;
      if ( (m_nFlags & 0x10) != 0 )
      {
        if ( (m_nFlags & 0x1000) == 0 )
          a6 = a7;
        goto LABEL_26;
      }
      goto LABEL_12;
    }
LABEL_11:
    *bSkipTestEntirely = 1;
    goto LABEL_12;
  }
  m_nObjectFlags = this->m_nObjectFlags;
  if ( (*(_WORD *)&m_nObjectFlags & 0x100) != 0
    && (this->m_pMat->zz < 0.66 || (*(_BYTE *)&this->m_nFlags & 0x10) != 0)
    && (*(_BYTE *)&v8->m_info & 6) == 2 )
  {
    *a5 = 1;
    if ( (*(_BYTE *)&v8->m_info & 7) != 2 )
      return;
    this->m_pNOCollisionVehicle = v8;
    goto LABEL_12;
  }
  m_nModelIndex = (unsigned __int16)this->m_nModelIndex;
  v20 = *(_BYTE *)&v8->m_info & 7;
  if ( v20 == 2 )
  {
    if ( (unsigned __int16)(m_nModelIndex - 374) <= 7u )
      goto LABEL_11;
    if ( this->ObjectCreatedBy != 3
      && (*(_BYTE *)&m_nObjectFlags & 0x40) == 0
      && (*(_DWORD *)&this->m_nFlags & 0x40004) != 0 )
    {
      goto LABEL_12;
    }
    v21 = v8->m_nModelIndex;
    if ( v21 != 406 )
    {
      v22 = v21 == 530;
      if ( v21 != 530 )
        v22 = v21 == 486;
      if ( !v22 )
      {
        if ( this->m_nCollisionDamageEffect <= 0x13u )
        {
          ColModel = CEntity::GetColModel(this);
          if ( ColModel->m_boxBound.m_vecMax.x < 1.0
            && ColModel->m_boxBound.m_vecMax.y < 1.0
            && ColModel->m_boxBound.m_vecMax.z < 1.0 )
          {
            output.m_pRwMat = 0;
            output.m_owner = 0;
            v24 = ColModel->m_boxBound.m_vecMax.x - ColModel->m_boxBound.m_vecMin.x;
            z = ColModel->m_boxBound.m_vecMin.z;
            v26 = ColModel->m_boxBound.m_vecMax.z;
            v.y = ColModel->m_boxBound.m_vecMax.y - ColModel->m_boxBound.m_vecMin.y;
            v.x = v24;
            v.z = v26 - z;
            operator*(&v31, this->m_pMat, &v);
            v = v31;
            m_pMat = v8->m_pMat;
            p_tx = (CSimpleTransform *)&m_pMat->tx;
            if ( !m_pMat )
              p_tx = &v8->m_transform;
            if ( v31.z < p_tx->m_translate.z
              || (v29 = Invert(m_pMat, &output),
                  CMatrix::operator=(&output, v29),
                  operator*(&v31, &output, &v),
                  v31.z < 0.0) )
            {
              *a5 = 1;
              this->m_pNOCollisionVehicle = v8;
            }
            CMatrix::~CMatrix(&output);
          }
        }
        goto LABEL_12;
      }
    }
    goto LABEL_28;
  }
  v30 = m_nModelIndex == 342;
  if ( m_nModelIndex == 342 )
    v30 = v20 == 3;
  if ( v30 )
  {
    if ( this->m_pMat->tz >= v8->m_pMat->tz )
      goto LABEL_12;
    goto LABEL_11;
  }
  if ( v20 == 4
    && *(float *)&v8[1].pReferences[2].ppReferenceAddress > 0.0
    && !pPhysical
    && (*(_DWORD *)&v8->m_nPhysicalFlags & 0xC) != 4
    && this->m_fMass < (float)(v8->m_fMass * 10.0) )
  {
LABEL_26:
    *a6 = 1;
  }
LABEL_12:
  if ( !*a5 && (bDoingShift || (*(_BYTE *)&this->m_nFlags & 0x10) != 0) )
    *a7 = 1;
}

//----- (00455284) --------------------------------------------------------
uint8 __fastcall CObject::SpecialEntityCalcCollisionSteps(
        CObject *this,
        bool *bDoPreCheckAtFullSpeed,
        bool *bDoPreCheckAtHalfSpeed)
{
  float32x2_t v3; // d1
  float32x2_t v4; // d3
  float32x2_t v5; // d4
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r1
  int m_nCollisionSpecial; // r0
  float m_fRadius; // s0
  float v10; // s2
  float v12; // s0
  CColModel *m_pColModel; // r0
  CVector *p_v; // r6
  float v15; // s0
  float v16; // s2
  float v17; // s4
  float v18; // s0
  float v19; // s0
  float v20; // s2
  float x; // s16
  float y; // s18
  CColModel *ColModel; // r0
  float *p_y; // r1
  float v25; // s16
  float v26; // s18
  float v27; // s20
  CColModel *v28; // r0
  CMatrix *m_pMat; // r5
  CColModel *v30; // r0
  float v31; // s0
  bool v33; // zf
  CColModel *v34; // r0
  float32x2_t v35; // d0
  float32x2_t v36; // d1
  float v37; // r0
  CVector v38; // [sp+8h] [bp-58h] BYREF
  CVector v39; // [sp+18h] [bp-48h] BYREF
  CVector v; // [sp+28h] [bp-38h] BYREF

  m_nPhysicalFlags = this->m_nPhysicalFlags;
  if ( (*(_BYTE *)&m_nPhysicalFlags & 0x80) != 0
    || (m_nCollisionSpecial = this->m_pObjectInfo->m_nCollisionSpecial, m_nCollisionSpecial == 5) )
  {
    m_fRadius = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel->m_sphereBound.m_fRadius;
    v10 = CTimer::ms_fTimeStep
        * (float)(CTimer::ms_fTimeStep
                * (float)((float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                                + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
                        + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z)));
    if ( v10 < (float)(m_fRadius * m_fRadius) )
      return 1;
    v12 = sqrtf(v10) / m_fRadius;
    return (unsigned int)ceilf(v12);
  }
  if ( (*(_BYTE *)&m_nPhysicalFlags & 0x20) != 0 )
  {
    x = CEntity::GetColModel(this)->m_boxBound.m_vecMax.x;
    y = CEntity::GetColModel(this)->m_boxBound.m_vecMax.y;
    ColModel = CEntity::GetColModel(this);
    p_y = &ColModel->m_boxBound.m_vecMax.y;
    if ( x > y )
      p_y = &ColModel->m_boxBound.m_vecMax.x;
    v25 = *p_y;
    v26 = CEntity::GetColModel(this)->m_boxBound.m_vecMin.x;
    v27 = CEntity::GetColModel(this)->m_boxBound.m_vecMin.y;
    v28 = CEntity::GetColModel(this);
    if ( v26 >= v27 )
      v28 = (CColModel *)((char *)v28 + 4);
    v20 = 0.1;
    if ( v25 < (float)-v28->m_boxBound.m_vecMin.x )
      v25 = v28->m_boxBound.m_vecMin.x;
    v19 = fabsf(this->m_vecTurnSpeed.z * v25);
    if ( v19 <= 0.1 )
      return 1;
LABEL_26:
    v12 = v19 / v20;
    return (unsigned int)ceilf(v12);
  }
  if ( (*(_BYTE *)&m_nPhysicalFlags & 0x40) != 0 )
  {
    m_pMat = this->m_pMat;
    v30 = CEntity::GetColModel(this);
    Multiply3x3(&v, m_pMat, &v30->m_boxBound.m_vecMin);
    CPhysical::GetSpeed(&v39, this, v);
    v = v39;
    v31 = CTimer::ms_fTimeStep
        * (float)(CTimer::ms_fTimeStep
                * (float)((float)((float)(v39.x * v39.x) + (float)(v39.y * v39.y)) + (float)(v39.z * v39.z)));
    if ( v31 < 0.0225 )
      return 1;
    v19 = sqrtf(v31);
    v20 = 0.15;
    goto LABEL_26;
  }
  if ( this->ObjectCreatedBy == 3 && (*((_BYTE *)&this->m_nObjectFlags + 1) & 0x20) == 0 )
    return 1;
  if ( m_nCollisionSpecial == 1 )
  {
    m_pColModel = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel;
    memset(&v, 0, sizeof(v));
    v39.z = 0.0;
    *(_QWORD *)&v39.x = 0LL;
    v.z = m_pColModel->m_boxBound.m_vecMax.z;
    v39.z = m_pColModel->m_boxBound.m_vecMin.z;
    Multiply3x3(&v38, this->m_pMat, &v);
    p_v = &v39;
    v = v38;
    Multiply3x3(&v38, this->m_pMat, &v39);
    v39 = v38;
    CPhysical::GetSpeed(&v38, this, v);
    v = v38;
    CPhysical::GetSpeed(&v38, this, v39);
    v39 = v38;
    if ( (float)((float)((float)(v.x * v.x) + (float)(v.y * v.y)) + (float)(v.z * v.z)) > (float)((float)((float)(v38.x * v38.x) + (float)(v38.y * v38.y))
                                                                                                + (float)(v38.z * v38.z)) )
      p_v = &v;
    v15 = p_v->x * p_v->x;
    v16 = p_v->y * p_v->y;
    v17 = p_v->z * p_v->z;
    goto LABEL_14;
  }
  if ( (*((_BYTE *)&this->m_nObjectFlags + 1) & 0x20) == 0 )
  {
    v33 = m_nCollisionSpecial == 4;
    if ( m_nCollisionSpecial != 4 )
      v33 = m_nCollisionSpecial == 2;
    if ( !v33 )
    {
      v15 = this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x;
      v16 = this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y;
      v17 = this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z;
LABEL_14:
      v18 = CTimer::ms_fTimeStep * (float)(CTimer::ms_fTimeStep * (float)((float)(v15 + v16) + v17));
      if ( v18 < 0.09 )
        return 1;
      v19 = sqrtf(v18);
      v20 = 0.3;
      goto LABEL_26;
    }
  }
  v34 = CEntity::GetColModel(this);
  v35.n64_u32[1] = 0.5;
  v4.n64_f32[0] = v34->m_boxBound.m_vecMax.y - v34->m_boxBound.m_vecMin.y;
  v5.n64_f32[0] = v34->m_boxBound.m_vecMax.z - v34->m_boxBound.m_vecMin.z;
  v3.n64_f32[0] = v34->m_boxBound.m_vecMax.x - v34->m_boxBound.m_vecMin.x;
  v36.n64_u64[0] = vmin_f32(v5, vmin_f32(v4, v3)).n64_u64[0];
  v35.n64_f32[0] = v36.n64_f32[0] * 0.5;
  v36.n64_f32[0] = CTimer::ms_fTimeStep
                 * (float)(CTimer::ms_fTimeStep
                         * (float)((float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                                         + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
                                 + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z)));
  if ( v36.n64_f32[0] < (float)(v35.n64_f32[0] * v35.n64_f32[0]) )
    return 1;
  v37 = ceilf(sqrtf(v36.n64_f32[0]) / v35.n64_f32[0]);
  v35.n64_u32[0] = 1132396544;
  v36.n64_f32[0] = v37;
  return (unsigned int)vmin_f32(v36, v35).n64_f32[0];
}
// 4555E8: variable 'v5' is possibly undefined
// 4555E0: variable 'v4' is possibly undefined
// 4555E0: variable 'v3' is possibly undefined

//----- (00455680) --------------------------------------------------------
void __fastcall CObject::SetIsStatic(CObject *this, bool bIsStatic)
{
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r5
  CMatrix *m_pMat; // r0
  float m_heading; // s0

  m_nPhysicalFlags = this->m_nPhysicalFlags;
  *(_DWORD *)&this->m_nFlags = *(_DWORD *)&this->m_nFlags & 0xFFFFFFFB | (4 * bIsStatic);
  if ( (*(_BYTE *)&m_nPhysicalFlags & 0x20) != 0 && !bIsStatic && this->m_fOriginalAngle < -1000.0 )
  {
    m_pMat = this->m_pMat;
    if ( m_pMat )
      m_heading = atan2f(COERCE_FLOAT(LODWORD(m_pMat->xy) ^ 0x80000000), m_pMat->yy);
    else
      m_heading = this->m_transform.m_heading;
    this->m_fOriginalAngle = m_heading;
  }
  this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags & 0xBFFFFFFF);
}

//----- (004556D8) --------------------------------------------------------
void __fastcall CObject::SetMatrixForTrainCrossing(CMatrix *pMatr, float Angle)
{
  float v4; // r6
  float v5; // r0
  float y; // r1
  float z; // r2
  float v8; // r1
  float v9; // r2
  CVector v10; // [sp+4h] [bp-34h] BYREF
  CVector v1; // [sp+10h] [bp-28h] BYREF
  CVector v12; // [sp+1Ch] [bp-1Ch] BYREF

  v1.x = 0.0;
  v1.y = 0.0;
  v1.z = 1.0;
  CrossProduct(&v12, &v1, (const CVector *)pMatr);
  v4 = sinf(Angle);
  v5 = cosf(Angle);
  v1.x = (float)(v4 * 0.0) + (float)(v5 * v12.x);
  v1.y = (float)(v4 * 0.0) + (float)(v5 * v12.y);
  v1.z = v4 + (float)(v5 * v12.z);
  CrossProduct(&v10, (const CVector *)pMatr, &v1);
  y = v10.y;
  z = v10.z;
  pMatr->xz = v10.x;
  pMatr->yz = y;
  pMatr->zz = z;
  v8 = v1.y;
  v9 = v1.z;
  pMatr->xy = v1.x;
  pMatr->yy = v8;
  pMatr->zy = v9;
}

//----- (00455774) --------------------------------------------------------
bool8 __fastcall CObject::TryToExplode(CObject *this)
{
  CObject::CObjectFlags m_nObjectFlags; // r1

  if ( !this->m_pObjectInfo->m_causesExplosion )
    return 0;
  m_nObjectFlags = this->m_nObjectFlags;
  if ( (*(_BYTE *)&m_nObjectFlags & 0x40) != 0 )
    return 0;
  this->m_nObjectFlags = (CObject::CObjectFlags)(*(_DWORD *)&m_nObjectFlags | 0x40);
  CObject::Explode(this);
  return 1;
}

//----- (004557A0) --------------------------------------------------------
void __fastcall CObject::Explode(CObject *this)
{
  CSimpleTransform *p_m_transform; // r8
  CMatrix *m_pMat; // r0
  CVector *p_m_translate; // r1
  CPlayerPed *PlayerPed; // r0
  CObjectInfo *m_pObjectInfo; // r0
  __int64 v7; // d16
  CMatrix *v8; // r0
  float y; // s8
  float z; // s10
  FxSystem_c *v11; // r0
  float v12; // s0
  int m_nFlags; // r0
  CVector v; // [sp+18h] [bp-B0h] BYREF
  CVector v15; // [sp+28h] [bp-A0h] BYREF
  CMatrix colNormal; // [sp+38h] [bp-90h] BYREF
  RwV3d_0 offsetPos; // [sp+80h] [bp-48h] BYREF
  CVector colPos; // [sp+90h] [bp-38h] BYREF

  p_m_transform = &this->m_transform;
  m_pMat = this->m_pMat;
  p_m_translate = &p_m_transform->m_translate;
  if ( m_pMat )
    p_m_translate = (CVector *)&m_pMat->tx;
  colPos = *p_m_translate;
  colPos.z = colPos.z + 0.5;
  PlayerPed = FindPlayerPed(-1);
  CExplosion::AddExplosion(this, PlayerPed, EXP_TYPE_OBJECT, colPos, 0x64u, 1u, -1.0, 0);
  if ( (this->m_nCollisionDamageEffect | 2) == 202 )
  {
    colPos.z = colPos.z + -1.0;
    colNormal.xx = 0.0;
    colNormal.yx = 0.0;
    colNormal.zx = 1.0;
    CObject::ObjectDamage(this, 10000.0, &colPos, (CVector *)&colNormal, (int)this, WEAPONTYPE_EXPLOSION);
  }
  else if ( (*(_BYTE *)&this->m_nPhysicalFlags & 4) == 0 )
  {
    this->m_vecMoveSpeed.z = this->m_vecMoveSpeed.z + 0.5;
    this->m_vecMoveSpeed.x = this->m_vecMoveSpeed.x + (float)((float)((unsigned __int8)rand() - 128) * 0.0002);
    v12 = (float)((unsigned __int8)rand() - 128);
    m_nFlags = (int)this->m_nFlags;
    this->m_vecMoveSpeed.y = this->m_vecMoveSpeed.y + (float)(v12 * 0.0002);
    if ( (m_nFlags & 0x40004) != 0 )
    {
      (*((void (__fastcall **)(CObject *, _DWORD))this->_vptr$CPlaceable + 5))(this, 0);
      CPhysical::AddToMovingList(this);
    }
  }
  if ( this->m_pObjectInfo->m_fxMode == 2 )
  {
    CMatrix::CMatrix(&colNormal, this->m_pMat);
    m_pObjectInfo = this->m_pObjectInfo;
    v7 = *(_QWORD *)&m_pObjectInfo->m_fxOffset.x;
    v.z = m_pObjectInfo->m_fxOffset.z;
    *(_QWORD *)&v.x = v7;
    Multiply3x3(&v15, &colNormal, &v);
    offsetPos = v15.RwV3d_0;
    v8 = this->m_pMat;
    if ( v8 )
      p_m_transform = (CSimpleTransform *)&v8->tx;
    y = p_m_transform->m_translate.y;
    z = p_m_transform->m_translate.z;
    offsetPos.x = p_m_transform->m_translate.x + v15.x;
    offsetPos.y = y + v15.y;
    offsetPos.z = z + v15.z;
    v11 = FxManager_c::CreateFxSystem(&g_fxMan, this->m_pObjectInfo->m_pFxSysBP, &offsetPos, 0, 0);
    if ( v11 )
      FxSystem_c::PlayAndKill(v11);
    CMatrix::~CMatrix(&colNormal);
  }
}

//----- (00455970) --------------------------------------------------------
void __fastcall CObject::ObjectFireDamage(CObject *this, float Amount, CEntity *pEntityResponsible)
{
  float32x2_t v3; // d0
  float32x2_t v4; // d2
  int m_nModelIndex; // r0
  int m_nCollisionDamageEffect; // r0
  float m_fHealth; // s0
  int v10; // r0
  bool v11; // zf
  int v12; // r1
  uint32 v13; // r2
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  __int64 v16; // d16
  CObjectInfo *m_pObjectInfo; // r0
  RwReal m_breakVelY; // r2
  RwReal m_breakVelZ; // r5
  float m_breakVelRand; // r3
  int m_nFlags; // r2
  CEntity::CFlags *p_m_nFlags; // r5
  uint32 bdummy; // r0
  unsigned int v24; // r1
  int (**v25)(void); // r0
  CObject::CObjectFlags m_nObjectFlags; // r2
  int v27; // r1
  CVector pCoors; // [sp+28h] [bp-18h] BYREF

  m_nModelIndex = this->m_nModelIndex;
  if ( m_nModelIndex == MI_GRASSPLANT || m_nModelIndex == MI_GRASSHOUSE )
  {
    v4.n64_u32[0] = 0;
    v3.n64_f32[0] = this->m_fHealth - Amount;
    m_nCollisionDamageEffect = this->m_nCollisionDamageEffect;
    LODWORD(this->m_fHealth) = vmax_f32(v3, v4).n64_u32[0];
    if ( m_nCollisionDamageEffect )
    {
      if ( (*((_BYTE *)&this->m_nPhysicalFlags + 2) & 0x40) == 0
        || FindPlayerPed(-1) == pEntityResponsible
        || FindPlayerVehicle(-1, 0) == pEntityResponsible )
      {
        m_fHealth = this->m_fHealth;
        if ( this->m_nModelIndex == MI_GRASSPLANT )
        {
          this->m_burnTimer = CTimer::m_snTimeInMilliseconds + 3000;
          this->m_burnMult = (float)(m_fHealth / -2000.0) + 1.0;
        }
        if ( m_fHealth == 0.0 )
        {
          v10 = this->m_nCollisionDamageEffect;
          this->m_burnTimer = 0;
          v11 = v10 == 202;
          if ( v10 != 202 )
            v11 = v10 == 200;
          if ( v11 )
          {
            if ( (*((_BYTE *)&this->m_nObjectFlags + 1) & 4) == 0 )
              CAudioEngine::ReportObjectDestruction(&AudioEngine, this);
            m_pObjectInfo = this->m_pObjectInfo;
            m_breakVelY = m_pObjectInfo->m_breakVelY;
            m_breakVelZ = m_pObjectInfo->m_breakVelZ;
            m_breakVelRand = m_pObjectInfo->m_breakVelRand;
            pCoors.x = m_pObjectInfo->m_breakVelX;
            pCoors.y = m_breakVelY;
            pCoors.z = m_breakVelZ;
            BreakManager_c::Add(&g_breakMan, this, &pCoors, m_breakVelRand, 1);
            p_m_nFlags = &this->m_nFlags;
            m_nFlags = (int)this->m_nFlags;
            bdummy = this->m_nFlags.bdummy;
            v24 = m_nFlags & 0xFFFFFF7E;
            *(_DWORD *)&this->m_nFlags = m_nFlags & 0xFFFFFF7E;
            if ( (m_nFlags & 0x40004) == 0 )
            {
              CPhysical::RemoveFromMovingList(this);
              bdummy = this->m_nFlags.bdummy;
              v24 = *(_DWORD *)p_m_nFlags;
            }
            *(_DWORD *)p_m_nFlags = v24 | 4;
            this->m_nFlags.bdummy = bdummy;
            v25 = this->_vptr$CPlaceable;
            m_nObjectFlags = this->m_nObjectFlags;
            v27 = *(_DWORD *)&this->m_nPhysicalFlags | 0x800000;
            *(_QWORD *)&this->m_vecMoveSpeed.x = 0LL;
            *(_QWORD *)&this->m_vecMoveSpeed.z = 0LL;
            this->m_vecTurnSpeed.y = 0.0;
            this->m_vecTurnSpeed.z = 0.0;
            this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)v27;
            this->m_nObjectFlags = (CObject::CObjectFlags)(*(_DWORD *)&m_nObjectFlags | 0x400);
            ((void (__fastcall *)(CObject *))v25[9])(this);
          }
          else if ( v10 == 1 )
          {
            v12 = (int)this->m_nFlags;
            if ( (v12 & 0x200) == 0 )
            {
              v13 = this->m_nFlags.bdummy;
              *(_DWORD *)&this->m_nFlags = v12 | 0x200;
              this->m_nFlags.bdummy = v13;
              (*((void (__fastcall **)(CObject *))this->_vptr$CPlaceable + 9))(this);
              m_pMat = this->m_pMat;
              p_tx = (CSimpleTransform *)&m_pMat->tx;
              if ( !m_pMat )
                p_tx = &this->m_transform;
              v16 = *(_QWORD *)&p_tx->m_translate.x;
              pCoors.z = p_tx->m_translate.z;
              *(_QWORD *)&pCoors.x = v16;
              CShadows::AddPermanentShadow(
                1u,
                gpShadowHeliTex,
                &pCoors,
                3.0,
                0.0,
                0.0,
                -3.0,
                200,
                0,
                0,
                0,
                10.0,
                0x7530u,
                1.0);
            }
          }
        }
      }
    }
  }
}
// 4559AE: variable 'v3' is possibly undefined
// 4559AE: variable 'v4' is possibly undefined

//----- (00455B70) --------------------------------------------------------
void __fastcall CObject::SetObjectTargettable(CObject *this, Bool8 bTargettable)
{
  this->m_nObjectFlags = (CObject::CObjectFlags)(*(_DWORD *)&this->m_nObjectFlags & 0xFFFFFDFF | ((bTargettable & 1) << 9));
}

//----- (00455B86) --------------------------------------------------------
Bool8 __fastcall CObject::CanBeTargetted(CObject *this)
{
  return (*(_DWORD *)&this->m_nObjectFlags >> 9) & 1;
}

//----- (00455B90) --------------------------------------------------------
void __fastcall CObject::RefModelInfo(CObject *this, int32 nModelIdx)
{
  this->m_nParentModelIndex = nModelIdx;
  sub_1A11D8(CModelInfo::ms_modelInfoPtrs[nModelIdx]);
}

//----- (00455BA8) --------------------------------------------------------
void __fastcall CObject::SetRemapTexture(CObject *this, RwTexture_0 *pTexture, const unsigned __int8 *txdName)
{
  this->m_remapTxdName = txdName;
  this->m_pRemapTexture = pTexture;
  if ( txdName )
    ++pTexture->refCount;
}

//----- (00455BB8) --------------------------------------------------------
void __fastcall CObject::Teleport(CObject *this, CVector NewCoors, Bool8 bClearOrientation)
{
  RwReal z; // r8
  float y; // r6
  RwReal x; // r5
  CMatrix *m_pMat; // r0
  float *p_tz; // r0
  RwObject_0 *m_pRwObject; // r0
  char *parent; // r1
  CMatrix *v11; // r0
  RwMatrix *v12; // r1

  z = NewCoors.z;
  y = NewCoors.y;
  x = NewCoors.x;
  CWorld::Remove(this);
  m_pMat = this->m_pMat;
  if ( m_pMat )
  {
    m_pMat->tx = x;
    this->m_pMat->ty = y;
    p_tz = &this->m_pMat->tz;
  }
  else
  {
    p_tz = &this->m_transform.m_translate.z;
    this->m_transform.m_translate.x = x;
    this->m_transform.m_translate.y = y;
  }
  *p_tz = z;
  m_pRwObject = this->m_pRwObject;
  if ( m_pRwObject )
  {
    parent = (char *)m_pRwObject->parent;
    v11 = this->m_pMat;
    v12 = (RwMatrix *)(parent + 16);
    if ( v11 )
      CMatrix::UpdateRwMatrix(v11, v12);
    else
      CSimpleTransform::UpdateRwMatrix(&this->m_transform, v12);
  }
  CEntity::UpdateRwFrame(this);
  sub_19B3E4(this);
}

//----- (00455C14) --------------------------------------------------------
void CObject::DeleteAllTempObjects()
{
  CObjectPool *v0; // r9
  int32 m_nSize; // r8
  int v2; // r6
  int i; // r5
  CPool<CObject,CCutsceneObject>::StorageType *m_aStorage; // r4
  uint8 *v5; // r10

  v0 = CPools::ms_pObjectPool;
  m_nSize = CPools::ms_pObjectPool->m_nSize;
  if ( m_nSize >= 1 )
  {
    v2 = 0;
    for ( i = 0; i != m_nSize; ++i )
    {
      if ( (v0->m_aFlags[i] & 0x80u) == 0 )
      {
        m_aStorage = v0->m_aStorage;
        v5 = v0->m_aStorage[v2];
        if ( v5 )
        {
          if ( v5[320] == 3 )
          {
            CWorld::Remove((CEntity *)v0->m_aStorage[v2]);
            (*(void (__fastcall **)(uint8 *))(*(_DWORD *)&m_aStorage[v2][0] + 4))(v5);
          }
        }
      }
      ++v2;
    }
  }
}

//----- (00455C74) --------------------------------------------------------
void CObject::DeleteAllMissionObjects()
{
  CObjectPool *v0; // r9
  int32 m_nSize; // r8
  int v2; // r6
  int i; // r5
  CPool<CObject,CCutsceneObject>::StorageType *m_aStorage; // r4
  uint8 *v5; // r10

  v0 = CPools::ms_pObjectPool;
  m_nSize = CPools::ms_pObjectPool->m_nSize;
  if ( m_nSize >= 1 )
  {
    v2 = 0;
    for ( i = 0; i != m_nSize; ++i )
    {
      if ( (v0->m_aFlags[i] & 0x80u) == 0 )
      {
        m_aStorage = v0->m_aStorage;
        v5 = v0->m_aStorage[v2];
        if ( v5 )
        {
          if ( (v5[320] | 4) == 6 )
          {
            CWorld::Remove((CEntity *)v0->m_aStorage[v2]);
            (*(void (__fastcall **)(uint8 *))(*(_DWORD *)&m_aStorage[v2][0] + 4))(v5);
          }
        }
      }
      ++v2;
    }
  }
}

//----- (00455CD8) --------------------------------------------------------
void __fastcall CObject::DeleteAllTempObjectsInArea(CVector Centre, float Radius)
{
  CObjectPool *v2; // r9
  int32 m_nSize; // r8
  int v4; // r6
  float x; // s18
  int v6; // r5
  float v7; // s16
  float y; // s20
  float z; // s22
  CPool<CObject,CCutsceneObject>::StorageType *m_aStorage; // r10
  uint8 *v11; // r4
  int v12; // r0
  float *v13; // r1

  v2 = CPools::ms_pObjectPool;
  m_nSize = CPools::ms_pObjectPool->m_nSize;
  if ( m_nSize >= 1 )
  {
    v4 = 0;
    x = Centre.x;
    v6 = 0;
    v7 = Radius * Radius;
    y = Centre.y;
    z = Centre.z;
    do
    {
      if ( (v2->m_aFlags[v6] & 0x80u) == 0 )
      {
        m_aStorage = v2->m_aStorage;
        v11 = v2->m_aStorage[v4];
        if ( v11 )
        {
          if ( v11[320] == 3 )
          {
            v12 = *((_DWORD *)v11 + 5);
            v13 = (float *)(v12 + 48);
            if ( !v12 )
              v13 = (float *)(v11 + 4);
            if ( (float)((float)((float)((float)(x - *v13) * (float)(x - *v13))
                               + (float)((float)(y - v13[1]) * (float)(y - v13[1])))
                       + (float)((float)(z - v13[2]) * (float)(z - v13[2]))) < v7 )
            {
              CWorld::Remove((CEntity *)v2->m_aStorage[v4]);
              (*(void (__fastcall **)(uint8 *))(*(_DWORD *)&m_aStorage[v4][0] + 4))(v11);
            }
          }
        }
      }
      ++v6;
      ++v4;
    }
    while ( m_nSize != v6 );
  }
}

//----- (00455D98) --------------------------------------------------------
float __fastcall CObject::GetRopeHeight(CObject *this)
{
  return CRopes::aRopes[CRopes::FindRope((u_native)this)].m_fWinchHeight;
}

//----- (00455DB8) --------------------------------------------------------
void __fastcall CObject::SetRopeHeight(CObject *this, float Val)
{
  CRopes::aRopes[CRopes::FindRope((u_native)this)].m_fWinchHeight = Val;
}

//----- (00455DDC) --------------------------------------------------------
CPhysical *__fastcall CObject::GetObjectCarriedWithRope(CObject *this)
{
  return CRopes::aRopes[CRopes::FindRope((u_native)this)].m_pWinchCarriedObject;
}

//----- (00455DFC) --------------------------------------------------------
void __fastcall CObject::ReleaseObjectCarriedWithRope(CObject *this)
{
  Int32 Rope; // r0

  Rope = CRopes::FindRope((u_native)this);
  sub_196658(&CRopes::aRopes[Rope]);
}

//----- (00455E20) --------------------------------------------------------
void __fastcall CObject::GrabObjectToCarryWithRope(CObject *this, CPhysical *pTarget)
{
  CRope *v3; // r4
  __int64 v4; // kr00_8
  const CMatrix *v5; // r8
  RwReal y; // r2
  CObject **p_m_pWinchHookObject; // r1
  int v8; // r5
  RwReal z; // r0
  RwReal *v10; // r2
  CObject *v11; // r0
  CEntity::CFlags m_nFlags; // kr08_8
  CVector v13; // [sp+0h] [bp-28h] BYREF
  CVector v14; // [sp+Ch] [bp-1Ch] BYREF

  v3 = &CRopes::aRopes[CRopes::FindRope((u_native)this)];
  CRope::ReleasePickedUpObject(v3);
  v3->m_pWinchCarriedObject = pTarget;
  CEntity::RegisterReference(pTarget, &v3->m_pWinchCarriedObject);
  v4 = *(_QWORD *)&v3->m_pWinchHookObject;
  v5 = *(const CMatrix **)(HIDWORD(v4) + 20);
  v13.x = 0.0;
  v13.y = 0.0;
  v13.z = CRopes::FindPickUpHeight(pTarget);
  operator*(&v14, v5, &v13);
  y = v14.y;
  p_m_pWinchHookObject = &v3->m_pWinchHookObject;
  v8 = *(_DWORD *)(v4 + 20);
  z = v14.z;
  if ( v8 )
  {
    *(RwReal *)(v8 + 48) = v14.x;
    *(RwReal *)(*(_DWORD *)(v4 + 20) + 52) = y;
    v10 = (RwReal *)(*(_DWORD *)(v4 + 20) + 56);
  }
  else
  {
    *(RwReal *)(v4 + 4) = v14.x;
    *(RwReal *)(v4 + 8) = y;
    v10 = (RwReal *)(v4 + 12);
  }
  *v10 = z;
  v11 = *p_m_pWinchHookObject;
  m_nFlags = (*p_m_pWinchHookObject)->m_nFlags;
  *(_DWORD *)&v11->m_nFlags = *(_DWORD *)&m_nFlags & 0xFFFFFFFE;
  v11->m_nFlags.bdummy = m_nFlags.bdummy;
}

//----- (00455EB0) --------------------------------------------------------
bool __fastcall CObject::CanBeUsedToTakeCoverBehind(CObject *this)
{
  bool result; // r0
  int m_nModelIndex; // r0
  CBaseModelInfo *v4; // r5
  CColModel *m_pColModel; // r0
  float v6; // s0

  result = 0;
  if ( this->ObjectCreatedBy != 2 )
  {
    m_nModelIndex = this->m_nModelIndex;
    if ( m_nModelIndex == MI_FIRE_HYDRANT )
      return 1;
    v4 = CModelInfo::ms_modelInfoPtrs[m_nModelIndex];
    if ( !(*((int (__fastcall **)(CBaseModelInfo *))v4->_vptr$CBaseModelInfo + 2))(v4)
      || (*(_WORD *)((*((int (__fastcall **)(CBaseModelInfo *))v4->_vptr$CBaseModelInfo + 2))(v4) + 40) & 0x7800) != 22528 )
    {
      m_pColModel = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel;
      v6 = m_pColModel->m_boxBound.m_vecMax.z - m_pColModel->m_boxBound.m_vecMin.z;
      if ( v6 < 1.25 && v6 > 0.75 && this->m_pMat->zz > 0.9 )
        return 1;
    }
  }
  return result;
}

//----- (00455F5C) --------------------------------------------------------
void __fastcall CObject::ResetDoorAngle(CObject *this)
{
  float m_fOriginalAngle; // s0
  CMatrix *m_pMat; // r0
  __int64 v4; // d16
  RwObject_0 *m_pRwObject; // r0
  __int64 v6; // d17
  char *parent; // r1
  CMatrix *v8; // r0
  RwMatrix *v9; // r1

  if ( (*(_BYTE *)&this->m_nPhysicalFlags & 0x20) != 0 )
  {
    m_fOriginalAngle = this->m_fOriginalAngle;
    if ( m_fOriginalAngle > -1000.0 )
    {
      m_pMat = this->m_pMat;
      if ( m_pMat )
        CMatrix::SetRotateZOnly(m_pMat, this->m_fOriginalAngle);
      else
        this->m_transform.m_heading = m_fOriginalAngle;
      (*((void (__fastcall **)(CObject *, int))this->_vptr$CPlaceable + 5))(this, 1);
      this->m_vecMoveSpeed.x = 0.0;
      this->m_vecMoveSpeed.y = 0.0;
      v4 = *(_QWORD *)&this->m_vecMoveSpeed.x;
      this->m_vecTurnSpeed.x = 0.0;
      this->m_vecTurnSpeed.y = 0.0;
      m_pRwObject = this->m_pRwObject;
      v6 = *(_QWORD *)&this->m_vecTurnSpeed.x;
      this->m_vecMoveFriction.z = 0.0;
      this->m_vecTurnSpeed.z = 0.0;
      this->m_vecTurnFriction.z = 0.0;
      this->m_vecMoveSpeed.z = 0.0;
      *(_QWORD *)&this->m_vecMoveFriction.x = v4;
      *(_QWORD *)&this->m_vecTurnFriction.x = v6;
      if ( m_pRwObject )
      {
        parent = (char *)m_pRwObject->parent;
        v8 = this->m_pMat;
        v9 = (RwMatrix *)(parent + 16);
        if ( v8 )
          CMatrix::UpdateRwMatrix(v8, v9);
        else
          CSimpleTransform::UpdateRwMatrix(&this->m_transform, v9);
      }
      j_CEntity::UpdateRwFrame(this);
    }
  }
}

//----- (00455FE8) --------------------------------------------------------
bool __fastcall IsObjectPointerValid(CObject *pObject)
{
  int v1; // r2
  int32 v2; // r2

  v1 = (char *)pObject - (char *)CPools::ms_pObjectPool->m_aStorage;
  if ( v1 < 0 )
    return 0;
  v2 = -654471207 * (v1 >> 2);
  if ( v2 >= CPools::ms_pObjectPool->m_nSize || (CPools::ms_pObjectPool->m_aFlags[v2] & 0x80u) != 0 )
    return 0;
  if ( *((unsigned __int8 *)&pObject->m_nFlags + 1) << 31 )
    return 1;
  return pObject->m_listEntryInfo.m_pHead != 0;
}

//----- (00456030) --------------------------------------------------------
bool __fastcall IsObjectPointerValid_NotInWorld(CObject *pObject)
{
  int v1; // r0
  bool result; // r0
  int32 v3; // r2

  v1 = (char *)pObject - (char *)CPools::ms_pObjectPool->m_aStorage;
  if ( v1 < 0 )
    return 0;
  v3 = -654471207 * (v1 >> 2);
  result = 0;
  if ( v3 < CPools::ms_pObjectPool->m_nSize && (char)CPools::ms_pObjectPool->m_aFlags[v3] > -1 )
    return 1;
  return result;
}

//----- (0045606C) --------------------------------------------------------
void __fastcall CObjectData::SetObjectData(int32 nModelIndex, CObject *obj)
{
  int m_dynamicIndex; // r2
  int v3; // r5
  int v4; // r4
  CObjectInfo *v5; // r2
  unsigned int v6; // lr
  CObject::CObjectFlags m_nObjectFlags; // r2
  CObject::CObjectFlags v8; // r2
  float z; // s2

  m_dynamicIndex = CModelInfo::ms_modelInfoPtrs[nModelIndex]->m_dynamicIndex;
  if ( m_dynamicIndex == -1 )
  {
    obj->m_fMass = 99999.0;
    obj->m_fTurnMass = 99999.0;
    obj->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&obj->m_nPhysicalFlags & 0xFF7FFFF1 | (unsigned int)&CTheScripts::ScriptSpace[272504]);
    obj->m_pObjectInfo = CObjectData::ms_aObjectInfo;
  }
  else
  {
    v3 = m_dynamicIndex;
    v4 = m_dynamicIndex;
    v5 = &CObjectData::ms_aObjectInfo[m_dynamicIndex];
    obj->m_pObjectInfo = v5;
    obj->m_fMass = CObjectData::ms_aObjectInfo[v4].m_fMass;
    obj->m_fTurnMass = v5->m_fTurnMass;
    obj->m_fAirResistance = v5->m_fAirResistance;
    obj->m_fElasticity = v5->m_fElasticity;
    obj->m_fBuoyancyConstant = v5->m_fBuoyancyConstant;
    obj->m_nCollisionDamageEffect = v5->m_nCollisionDamageEffect;
    if ( v5->m_fMass >= 99998.0 )
    {
      v6 = *(_DWORD *)&obj->m_nPhysicalFlags & 0xFFFFFFF1;
      obj->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(v6 | 0xC);
      if ( !v5->m_nCollisionDamageEffect )
        obj->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(v6 | (unsigned int)&CTheScripts::ScriptSpace[272504]);
    }
    switch ( CObjectData::ms_aObjectInfo[v3].m_nCollisionSpecial )
    {
      case 6u:
        m_nObjectFlags = obj->m_nObjectFlags;
        *(_DWORD *)&obj->m_nPhysicalFlags |= 0x20u;
        obj->m_nObjectFlags = (CObject::CObjectFlags)(*(_DWORD *)&m_nObjectFlags & 0xFFFF3FFF);
        break;
      case 7u:
        v8 = obj->m_nObjectFlags;
        *(_DWORD *)&obj->m_nPhysicalFlags |= 0x2Cu;
        obj->m_nObjectFlags = (CObject::CObjectFlags)(*(_DWORD *)&v8 & 0xFFFF3FFF | 0x4000);
        break;
      case 8u:
        *(_DWORD *)&obj->m_nPhysicalFlags |= 0x40u;
        z = CModelInfo::ms_modelInfoPtrs[nModelIndex]->m_pColModel->m_boxBound.m_vecMin.z;
        obj->m_vecCOM.x = 0.0;
        obj->m_vecCOM.y = 0.0;
        obj->m_vecCOM.z = z * 0.8;
        break;
      case 9u:
        obj->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&obj->m_nPhysicalFlags & 0xFFFFFF7D | 0x80);
        break;
    }
  }
}

//----- (004561C0) --------------------------------------------------------
void __fastcall ProcSurfaceInfo_c::ProcSurfaceInfo_c(ProcSurfaceInfo_c *this)
{
  List_c::List_c(&this->m_entityList);
}

//----- (004561D2) --------------------------------------------------------
void __fastcall ProcSurfaceInfo_c::~ProcSurfaceInfo_c(ProcSurfaceInfo_c *this)
{
  List_c::~List_c(&this->m_entityList);
}

//----- (004561E4) --------------------------------------------------------
int __fastcall ProcSurfaceInfo_c::Init(
        ProcSurfaceInfo_c *this,
        unsigned __int8 *surfaceName,
        unsigned __int8 *objName,
        float spacing,
        float minDist,
        int32 minRot,
        int32 maxRot,
        float minScale,
        float maxScale,
        float minScaleZ,
        float maxScaleZ,
        float zOffMin,
        float zOffMax,
        bool8 alignObj,
        unsigned int useGrid)
{
  float32x2_t v15; // d6
  float32x2_t v16; // d8
  float v20; // s10
  int result; // r0

  this->m_surfaceId = SurfaceInfos_c::GetSurfaceIdFromName(&g_surfaceInfos, surfaceName);
  if ( !CModelInfo::GetModelInfo(objName, &this->m_modelIndex) )
    return 0;
  v15.n64_f32[0] = minDist;
  v16.n64_u32[0] = 1117782016;
  this->m_spacing = spacing;
  this->m_minScale = minScale;
  v20 = vmin_f32(v15, v16).n64_f32[0];
  this->m_maxScale = maxScale;
  this->m_minScaleZ = minScaleZ;
  this->m_maxScaleZ = maxScaleZ;
  this->m_zOffMin = zOffMin;
  this->m_zOffMax = zOffMax;
  this->m_alignObj = alignObj;
  result = 1;
  this->m_useGrid = (float)useGrid;
  this->m_minDistSq = v20 * v20;
  this->m_density = 1.0 / (float)(spacing * spacing);
  this->m_minRot = (float)((float)minRot / 180.0) * 3.1416;
  this->m_maxRot = (float)((float)maxRot / 180.0) * 3.1416;
  return result;
}
// 456250: variable 'v15' is possibly undefined
// 456250: variable 'v16' is possibly undefined

//----- (004562D4) --------------------------------------------------------
void __fastcall ProcSurfaceInfo_c::Exit(ProcSurfaceInfo_c *this)
{
  ListItem_c *m_head; // r5
  List_c *p_m_entityList; // r9
  ListItem_c *m_next; // r4
  ListItem_c *m_prev; // r0

  p_m_entityList = &this->m_entityList;
  m_head = this->m_entityList.m_head;
  if ( m_head )
  {
    do
    {
      m_next = m_head->m_next;
      List_c::RemoveItem(p_m_entityList, m_head);
      List_c::AddItem(&g_procObjMan.m_entityPool, m_head);
      ((void (__fastcall *)(ListItem_c *))m_head[1].m_prev->m_prev[4].m_next)(m_head[1].m_prev);
      CWorld::Remove((CEntity *)m_head[1].m_prev);
      m_prev = m_head[1].m_prev;
      if ( m_prev )
        ((void (__fastcall *)(ListItem_c *))m_prev->m_prev->m_next)(m_prev);
      m_head[1].m_prev = 0;
      m_head = m_next;
    }
    while ( m_next );
  }
}

//----- (00456338) --------------------------------------------------------
void __fastcall ProcObjectMan_c::ReturnEntityToPool(ProcObjectMan_c *this, EntityItem_c *objItem)
{
  sub_1955CC(&this->m_entityPool, objItem);
}

//----- (00456344) --------------------------------------------------------
ListItem_c *__fastcall ProcSurfaceInfo_c::AddObject(
        ProcSurfaceInfo_c *this,
        CVector pos,
        CVector normal,
        uint8 lighting)
{
  float y; // r8
  float x; // r9
  float z; // r10
  ListItem_c *v8; // r4
  int m_dynamicIndex; // r11
  CBuilding *v11; // r0
  ListItem_c *v12; // r0
  CObject *v13; // r0
  int v14; // r0
  ListItem_c *m_prev; // r0
  ListItem_c *v16; // r0
  __int64 v17; // kr00_8
  ListItem_c *v18; // r0
  __int64 v19; // kr08_8
  float m_minScale; // s18
  float m_maxScale; // s22
  int v22; // r0
  float m_minScaleZ; // s20
  float m_maxScaleZ; // s24
  float v25; // s26
  int v26; // r0
  float m_minRot; // s16
  float m_maxRot; // s17
  float v29; // s28
  int v30; // r0
  float m_zOffMin; // s19
  float m_zOffMax; // s21
  float v33; // s23
  int v34; // r0
  float v35; // s0
  float v36; // s16
  float v37; // s17
  ListItem_c *v38; // r0
  ListItem_c *m_next; // r1
  float *p_m_next; // r0
  ListItem_c *v41; // r6
  CMatrix *v42; // r0
  float tx; // s17
  float ty; // s19
  float tz; // s21
  float *v46; // r0
  float v47; // s2
  float v48; // s4
  ListItem_c *v49; // r2
  ListItem_c *v50; // r0
  ListItem_c *v51; // r1
  const CMatrix *v52; // r0
  RwMatrix *v53; // r1
  float v54; // s18
  float v55; // s20
  ListItem_c *v56; // r0
  const CMatrix *v57; // r0
  CVector v58; // [sp+0h] [bp-D8h] BYREF
  CVector v59; // [sp+Ch] [bp-CCh] BYREF
  CVector v2; // [sp+18h] [bp-C0h] BYREF
  CMatrix mat; // [sp+24h] [bp-B4h] BYREF
  CVector v1; // [sp+6Ch] [bp-6Ch] BYREF

  y = pos.y;
  x = pos.x;
  v1 = normal;
  z = pos.z;
  v8 = List_c::RemoveHead(&g_procObjMan.m_entityPool);
  if ( !v8 )
    return 0;
  if ( this->m_alignObj && normal.z < 0.95 && g_procObjMan.m_numAllocatedMatrices >= 200 )
  {
    CDebug::DebugLog("Cannot create procedural object aligned to surface - no matrices left\n");
    return 0;
  }
  m_dynamicIndex = (unsigned __int16)CModelInfo::ms_modelInfoPtrs[this->m_modelIndex]->m_dynamicIndex;
  if ( m_dynamicIndex == 0xFFFF )
  {
    CPools::ms_pBuildingPool->m_bDealWithNoMemory = 1;
    v11 = (CBuilding *)CBuilding::operator new(0x3Cu);
    CBuilding::CBuilding(v11);
    v8[1].m_prev = v12;
    if ( !v12 )
    {
      v8 = 0;
      CPools::ms_pBuildingPool->m_bDealWithNoMemory = 0;
      return v8;
    }
    ((void (__fastcall *)(ListItem_c *, int32))v12->m_prev[3].m_next)(v12, this->m_modelIndex);
    CPools::ms_pBuildingPool->m_bDealWithNoMemory = 0;
  }
  else
  {
    if ( CObject::nNoTempObjects > 0x95u )
      return 0;
    CPools::ms_pObjectPool->m_bDealWithNoMemory = 1;
    v13 = (CObject *)CObject::operator new(0x184u);
    CObject::CObject(v13, this->m_modelIndex, 0);
    v8[1].m_prev = (ListItem_c *)v14;
    if ( !v14 )
    {
      v8 = 0;
      CPools::ms_pObjectPool->m_bDealWithNoMemory = 0;
      return v8;
    }
    *(_BYTE *)(v14 + 320) = 5;
    m_prev = v8[1].m_prev;
    m_prev[9].m_prev = 0;
    m_prev[9].m_next = 0;
    m_prev[10].m_prev = 0;
    CPools::ms_pObjectPool->m_bDealWithNoMemory = 0;
    ++CObject::nNoTempObjects;
  }
  if ( SurfaceInfos_c::IsWater(&g_surfaceInfos, this->m_surfaceId) )
  {
    v16 = v8[1].m_prev;
    v17 = *(_QWORD *)&v16[3].m_next;
    v16[3].m_next = (ListItem_c *)(v17 | 0x100000);
    v16[4].m_prev = (ListItem_c *)HIDWORD(v17);
  }
  v18 = v8[1].m_prev;
  v19 = *(_QWORD *)&v18[3].m_next;
  v18[3].m_next = (ListItem_c *)(v19 | 0x4000000);
  v18[4].m_prev = (ListItem_c *)HIDWORD(v19);
  m_minScale = this->m_minScale;
  m_maxScale = this->m_maxScale;
  v22 = rand();
  m_minScaleZ = this->m_minScaleZ;
  m_maxScaleZ = this->m_maxScaleZ;
  v25 = (float)v22;
  v26 = rand();
  m_minRot = this->m_minRot;
  m_maxRot = this->m_maxRot;
  v29 = (float)v26;
  v30 = rand();
  m_zOffMin = this->m_zOffMin;
  m_zOffMax = this->m_zOffMax;
  v33 = (float)v30;
  v34 = rand();
  v35 = m_minRot + (float)((float)(m_maxRot - m_minRot) * (float)(v33 * 4.6566e-10));
  v36 = CModelInfo::ms_modelInfoPtrs[this->m_modelIndex]->m_pColModel->m_boxBound.m_vecMin.z;
  v37 = m_zOffMin + (float)((float)(m_zOffMax - m_zOffMin) * (float)((float)v34 * 4.6566e-10));
  if ( this->m_alignObj && v1.z < 0.95 )
  {
    mat.m_pRwMat = 0;
    mat.m_owner = 0;
    v2.z = 0.0;
    v2.y = sinf(v35);
    v2.x = cosf(v35);
    CrossProduct(&v59, &v1, &v2);
    CVector::Normalise(&v59);
    CrossProduct(&v58, &v59, &v1);
    CVector::Normalise(&v58);
    mat.xx = v58.x;
    mat.yx = v58.y;
    mat.zx = v58.z;
    *(CVector *)&mat.xz = v1;
    *(CVector *)&mat.xy = v59;
    mat.tx = (float)((float)(v37 - v36) * v1.x) + x;
    mat.ty = (float)((float)(v37 - v36) * v1.y) + y;
    mat.tz = (float)((float)(v37 - v36) * v1.z) + z;
    CPlaceable::AllocateStaticMatrix((CPlaceable *)v8[1].m_prev);
    CPlaceable::SetMatrix((CPlaceable *)v8[1].m_prev, &mat);
    LOBYTE(v8[2].m_prev) = 1;
    ++g_procObjMan.m_numAllocatedMatrices;
    CMatrix::~CMatrix(&mat);
  }
  else
  {
    v38 = v8[1].m_prev;
    m_next = v38[2].m_next;
    if ( m_next )
    {
      *(float *)&m_next[6].m_prev = x;
      *(float *)&v38[2].m_next[6].m_next = y;
      p_m_next = (float *)&v38[2].m_next[7];
    }
    else
    {
      *(float *)&v38->m_next = x;
      *(float *)&v38[1].m_prev = y;
      p_m_next = (float *)&v38[1].m_next;
    }
    *p_m_next = v37 + (float)(z - v36);
    v41 = v8[1].m_prev;
    v42 = (CMatrix *)v41[2].m_next;
    if ( v42 )
    {
      tx = v42->tx;
      ty = v42->ty;
      tz = v42->tz;
      CMatrix::SetRotate(v42, 0.0, 0.0, v35);
      v46 = (float *)v41[2].m_next;
      v47 = ty + v46[13];
      v48 = tz + v46[14];
      v46[12] = tx + v46[12];
      v46[13] = v47;
      v46[14] = v48;
    }
    else
    {
      *(float *)&v41[2].m_prev = v35;
    }
    LOBYTE(v8[2].m_prev) = 0;
  }
  HIBYTE(v8[1].m_prev[6].m_prev) = CGame::currArea;
  ((void (__fastcall *)(ListItem_c *, int))v8[1].m_prev->m_prev[2].m_next)(v8[1].m_prev, 1);
  ((void (__fastcall *)(ListItem_c *))v8[1].m_prev->m_prev[4].m_prev)(v8[1].m_prev);
  v49 = v8[1].m_prev;
  v50 = v49[3].m_prev;
  if ( v50 )
  {
    v51 = v50->m_next;
    v52 = (const CMatrix *)v49[2].m_next;
    v53 = (RwMatrix *)&v51[2];
    if ( v52 )
      CMatrix::UpdateRwMatrix(v52, v53);
    else
      CSimpleTransform::UpdateRwMatrix((const CSimpleTransform *)&v49->m_next, v53);
  }
  CEntity::UpdateRwFrame((CEntity *)v8[1].m_prev);
  CWorld::Add((CEntity *)v8[1].m_prev);
  List_c::AddItem(&this->m_entityList, v8);
  if ( m_dynamicIndex == 0xFFFF )
  {
    v54 = m_minScale + (float)((float)(m_maxScale - m_minScale) * (float)(v25 * 4.6566e-10));
    v55 = m_minScaleZ + (float)((float)(m_maxScaleZ - m_minScaleZ) * (float)(v29 * 4.6566e-10));
    if ( v54 != 1.0 )
    {
      v56 = v8[1].m_prev[3].m_prev;
      if ( v56 )
      {
        CMatrix::CMatrix(&mat, (RwMatrix *)&v56->m_next[2], 0);
        mat.xx = v54 * mat.xx;
        mat.yx = v54 * mat.yx;
        mat.zx = v55 * mat.zx;
        mat.xy = v54 * mat.xy;
        mat.yy = v54 * mat.yy;
        mat.zy = v55 * mat.zy;
        mat.xz = v54 * mat.xz;
        mat.yz = v54 * mat.yz;
        mat.zz = v55 * mat.zz;
        mat.tx = mat.tx + 0.0;
        mat.ty = mat.ty + 0.0;
        mat.tz = mat.tz - (float)((float)(v55 * v36) - v36);
        CMatrix::UpdateRW(v57);
        CEntity::UpdateRwFrame((CEntity *)v8[1].m_prev);
        CMatrix::~CMatrix(&mat);
      }
    }
  }
  return v8;
}
// 456406: variable 'v12' is possibly undefined
// 456446: variable 'v14' is possibly undefined
// 4567EE: variable 'v57' is possibly undefined

//----- (0045684C) --------------------------------------------------------
EntityItem_c *__fastcall ProcObjectMan_c::GetEntityFromPool(ProcObjectMan_c *this)
{
  return (EntityItem_c *)sub_19049C(&this->m_entityPool);
}

//----- (00456856) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall ProcSurfaceInfo_c::IsPtInTriangle2D(
        ProcSurfaceInfo_c *this,
        float x,
        float y,
        CVector v1,
        CVector v2,
        CVector v3,
        CVector normal,
        float *z)
{
  int result; // r0

  result = 0;
  if ( (float)((float)((float)(v3.x - x) * (float)(v1.y - v3.y)) + (float)((float)(v3.y - y) * (float)(v3.x - v1.x))) <= 0.0
    && (float)((float)((float)(v1.x - x) * (float)(v2.y - v1.y)) + (float)((float)(v1.y - y) * (float)(v1.x - v2.x))) <= 0.0
    && (float)((float)((float)(v2.x - x) * (float)(v3.y - v2.y)) + (float)((float)(v2.y - y) * (float)(v2.x - v3.x))) <= 0.0 )
  {
    result = 1;
    *z = (float)((float)((float)-(float)(normal.x * x) - (float)(normal.y * y))
               + (float)((float)(v1.z * normal.z) + (float)((float)(v1.x * normal.x) + (float)(v1.y * normal.y))))
       / normal.z;
  }
  return result;
}
// 456856: fragmented variable at 0:r3.4,4:^0.8 may be wrong
// 456856: variables would overlap: 0:r3.4,4:^0.8 and ^0.4
// 456856: variables would overlap: 0:r3.4,4:^0.8 and ^4.4

//----- (00456938) --------------------------------------------------------
int32 __fastcall ProcSurfaceInfo_c::AddObjects(ProcSurfaceInfo_c *this, CPlantLocTri *pLocTri)
{
  float32x2_t d8_0; // d8
  float32x2_t v3; // d9
  float32x2_t v4; // d11
  float32x2_t v5; // d12
  float32x2_t v6; // d13
  float32x2_t v7; // d14
  float x; // s0
  float v11; // s18
  float y; // s4
  float v13; // s20
  float v14; // s22
  float v15; // s26
  float z; // s2
  float v17; // s24
  float v18; // s28
  CSimpleTransform *p_tx; // r2
  int32 v20; // r10
  CPlantLocTri *p_m_V2; // r0
  float v22; // s4
  float v23; // s2
  CPlantLocTri *v24; // r1
  float v25; // s6
  CPlantLocTri *v26; // r2
  float m_spacing; // s20
  CPlantLocTri *v28; // r2
  float v29; // s2
  float v30; // s16
  float v31; // s18
  int v32; // s2
  float v33; // s20
  float v34; // s22
  float v35; // s24
  float v36; // s4
  float v37; // s6
  float v38; // s0
  float v39; // s2
  float v40; // s8
  float v41; // s10
  ListItem_c *v42; // r0
  float v43; // s0
  float m_density; // s16
  float v45; // s30
  float v46; // s17
  float v47; // s19
  unsigned int v48; // r6
  float v49; // s16
  float v50; // s24
  float v51; // s20
  float v52; // s18
  float v53; // s0
  int v54; // r11
  int v55; // r6
  float v56; // s17
  float v57; // s19
  float v58; // s21
  float v59; // s23
  float v60; // s25
  float v61; // s27
  float v62; // s0
  float v63; // s2
  ListItem_c *v64; // r0
  int v66; // [sp+10h] [bp-88h]
  CVector v67; // [sp+14h] [bp-84h] BYREF
  CVector v1; // [sp+20h] [bp-78h] BYREF
  CVector v2; // [sp+2Ch] [bp-6Ch] BYREF
  CVector v70; // 0:r1.12
  CVector v71; // 0:r1.12

  x = pLocTri->m_V1.x;
  v11 = pLocTri->m_V2.x;
  y = pLocTri->m_V1.y;
  v13 = pLocTri->m_V2.y;
  v14 = pLocTri->m_V3.x;
  v15 = pLocTri->m_V3.y;
  z = pLocTri->m_V1.z;
  v17 = pLocTri->m_V2.z;
  v18 = pLocTri->m_V3.z;
  p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  if ( !TheCamera.m_pMat )
    p_tx = &TheCamera.m_transform;
  if ( (float)((float)((float)((float)(p_tx->m_translate.x
                                     - (float)((float)((float)(pLocTri->m_V1.x + v11) + v14) * 0.3333))
                             * (float)(p_tx->m_translate.x
                                     - (float)((float)((float)(pLocTri->m_V1.x + v11) + v14) * 0.3333)))
                     + (float)((float)(p_tx->m_translate.y - (float)((float)((float)(y + v13) + v15) * 0.3333))
                             * (float)(p_tx->m_translate.y - (float)((float)((float)(y + v13) + v15) * 0.3333))))
             + (float)((float)(p_tx->m_translate.z - (float)((float)((float)(z + v17) + v18) * 0.3333))
                     * (float)(p_tx->m_translate.z - (float)((float)((float)(z + v17) + v18) * 0.3333)))) < this->m_minDistSq )
    return 0;
  v2.y = v13 - y;
  v2.x = v11 - x;
  v2.z = v17 - z;
  v1.y = v15 - y;
  v1.x = v14 - x;
  v1.z = v18 - z;
  CrossProduct(&v67, &v1, &v2);
  if ( this->m_useGrid == 0.0 )
  {
    m_density = this->m_density;
    v45 = v67.x;
    v46 = v67.y;
    v47 = v67.z;
    v48 = (unsigned int)(float)((float)((float)((float)((float)(pLocTri->m_V1.x + pLocTri->m_V1.y) + pLocTri->m_V1.z)
                                              + (float)((float)(pLocTri->m_V2.x + pLocTri->m_V2.y) + pLocTri->m_V2.z))
                                      + (float)((float)(pLocTri->m_V3.x + pLocTri->m_V3.y) + pLocTri->m_V3.z))
                              + (float)this->m_modelIndex);
    v66 = rand();
    srand(v48);
    v20 = 0;
    v49 = m_density * (float)(sqrtf((float)((float)(v45 * v45) + (float)(v46 * v46)) + (float)(v47 * v47)) * 0.5);
    if ( v49 > 0.0 )
    {
      v50 = v18 - v17;
      v51 = v15 - v13;
      v52 = v14 - v11;
      v20 = 0;
      do
      {
        v53 = 1.0;
        if ( v49 < 1.0 )
          v53 = (float)((float)rand() * 4.6566e-10) + 0.0;
        if ( v53 < v49 )
        {
          v54 = rand();
          v55 = rand();
          v56 = pLocTri->m_V1.x;
          v57 = pLocTri->m_V1.y;
          v58 = pLocTri->m_V1.z;
          v59 = v2.x;
          v60 = v2.y;
          v61 = v2.z;
          CVector::Normalise(&v67);
          v62 = (float)((float)v54 * 4.6566e-10) + 0.0;
          v63 = v62 * (float)((float)((float)v55 * 4.6566e-10) + 0.0);
          v71.x = (float)((float)(v59 * v62) + v56) + (float)(v52 * v63);
          v71.y = (float)(v51 * v63) + (float)((float)(v60 * v62) + v57);
          v71.z = (float)(v50 * v63) + (float)((float)(v62 * v61) + v58);
          v64 = ProcSurfaceInfo_c::AddObject(this, v71, v67, 0);
          if ( v64 )
          {
            v64[1].m_next = (ListItem_c *)pLocTri;
            ++v20;
          }
        }
        v49 = v49 + -1.0;
      }
      while ( v49 > 0.0 );
    }
    srand(v66);
  }
  else
  {
    p_m_V2 = (CPlantLocTri *)&pLocTri->m_V2;
    v22 = pLocTri->m_V2.x;
    v23 = pLocTri->m_V1.y;
    v24 = (CPlantLocTri *)&pLocTri->m_V2;
    v25 = pLocTri->m_V2.y;
    v26 = (CPlantLocTri *)&pLocTri->m_V2;
    d8_0.n64_u32[0] = LODWORD(pLocTri->m_V3.x);
    v4.n64_u32[0] = LODWORD(pLocTri->m_V3.y);
    m_spacing = this->m_spacing;
    if ( pLocTri->m_V1.x > v22 )
      v24 = pLocTri;
    if ( v23 > v25 )
      v26 = pLocTri;
    v5.n64_u32[0] = LODWORD(v26->m_V1.y);
    v28 = (CPlantLocTri *)&pLocTri->m_V2;
    if ( v23 < v25 )
      v28 = pLocTri;
    v6.n64_u32[0] = LODWORD(v28->m_V1.y);
    v3.n64_u32[0] = LODWORD(v24->m_V1.x);
    if ( pLocTri->m_V1.x < v22 )
      p_m_V2 = pLocTri;
    v7.n64_u32[0] = LODWORD(p_m_V2->m_V1.x);
    CVector::Normalise(&v67);
    v29 = vmax_f32(v3, d8_0).n64_f32[0];
    v20 = 0;
    v30 = (float)(int)(float)(m_spacing * (float)(int)(float)(vmin_f32(v7, d8_0).n64_f32[0] / m_spacing));
    v31 = (float)(int)(float)(m_spacing * (float)((int)(float)(v29 / m_spacing) + 1));
    if ( v30 < v31 )
    {
      v20 = 0;
      v32 = (int)(float)(m_spacing * (float)((int)(float)(vmax_f32(v5, v4).n64_f32[0] / m_spacing) + 1));
      v33 = (float)(int)(float)(m_spacing * (float)(int)(float)(vmin_f32(v6, v4).n64_f32[0] / m_spacing));
      v34 = (float)v32;
      do
      {
        if ( v33 >= v34 )
        {
          v43 = this->m_spacing;
        }
        else
        {
          v35 = v33;
          do
          {
            v36 = pLocTri->m_V3.x;
            v37 = pLocTri->m_V3.y;
            v38 = pLocTri->m_V1.x;
            v39 = pLocTri->m_V1.y;
            if ( (float)((float)((float)(v36 - v30) * (float)(v39 - v37))
                       + (float)((float)(v36 - pLocTri->m_V1.x) * (float)(v37 - v35))) <= 0.0 )
            {
              v40 = pLocTri->m_V2.x;
              v41 = pLocTri->m_V2.y;
              if ( (float)((float)((float)(v39 - v35) * (float)(v38 - v40))
                         + (float)((float)(v38 - v30) * (float)(v41 - v39))) <= 0.0
                && (float)((float)((float)(v41 - v35) * (float)(v40 - v36))
                         + (float)((float)(v40 - v30) * (float)(v37 - v41))) <= 0.0 )
              {
                v70.y = v35;
                v70.x = v30;
                v70.z = (float)((float)((float)-(float)(v30 * v67.x) - (float)(v35 * v67.y))
                              + (float)((float)(v67.z * pLocTri->m_V1.z)
                                      + (float)((float)(v38 * v67.x) + (float)(v39 * v67.y))))
                      / v67.z;
                v42 = ProcSurfaceInfo_c::AddObject(this, v70, v67, 0);
                if ( v42 )
                {
                  v42[1].m_next = (ListItem_c *)pLocTri;
                  ++v20;
                }
              }
            }
            v43 = this->m_spacing;
            v35 = v35 + v43;
          }
          while ( v35 < v34 );
        }
        v30 = v30 + v43;
      }
      while ( v30 < v31 );
    }
  }
  return v20;
}
// 456AA2: variable 'v3' is possibly undefined
// 456AA2: variable 'd8_0' is possibly undefined
// 456A9A: variable 'v7' is possibly undefined
// 456AF8: variable 'v5' is possibly undefined
// 456AF8: variable 'v4' is possibly undefined
// 456AF0: variable 'v6' is possibly undefined

//----- (00456E40) --------------------------------------------------------
void __fastcall ProcObjectMan_c::ProcObjectMan_c(ProcObjectMan_c *this)
{
  int i; // r5
  int j; // r6

  for ( i = 0; i != 128; ++i )
    List_c::List_c(&this->m_procSurfaceInfos[i].m_entityList);
  for ( j = 0; j != 512; ++j )
    ListItem_c::ListItem_c(&this->m_entityItems[j]);
  List_c::List_c(&this->m_entityPool);
}

//----- (00456E84) --------------------------------------------------------
void __fastcall ProcObjectMan_c::~ProcObjectMan_c(ProcObjectMan_c *this)
{
  unsigned int i; // r6
  int j; // r5

  List_c::~List_c(&this->m_entityPool);
  for ( i = 0; i != -10240; i -= 20 )
    ListItem_c::~ListItem_c(&this->m_entityItems[i / 0x14 + 511]);
  for ( j = 9212; j != -4; j -= 72 )
    List_c::~List_c((List_c *)((char *)this + j));
}

//----- (00456EC6) --------------------------------------------------------
bool8 __fastcall ProcObjectMan_c::Init(ProcObjectMan_c *this)
{
  EntityItem_c *m_entityItems; // r6
  int i; // r4

  m_entityItems = this->m_entityItems;
  for ( i = 0; i != 512; ++i )
    List_c::AddItem(&this->m_entityPool, &m_entityItems[i]);
  this->m_numProcSurfaceInfos = 0;
  ProcObjectMan_c::LoadDataFile(this);
  this->m_numAllocatedMatrices = 0;
  return 1;
}

//----- (00456F0C) --------------------------------------------------------
void __fastcall ProcObjectMan_c::LoadDataFile(ProcObjectMan_c *this)
{
  float32x2_t v1; // d10
  float32x2_t v2; // d13
  u_native v4; // r4
  const char *Line; // r0
  int v6; // r1
  bool v7; // zf
  int v8; // r10
  int v9; // r11
  float v10; // s24
  char *v11; // r8
  float v12; // s6
  u_native v13; // [sp+38h] [bp-128h]
  unsigned __int8 v14; // [sp+3Ch] [bp-124h]
  int v15; // [sp+40h] [bp-120h]
  int v16; // [sp+44h] [bp-11Ch]
  int v17; // [sp+48h] [bp-118h]
  int v18; // [sp+4Ch] [bp-114h]
  int v19; // [sp+50h] [bp-110h]
  int v20; // [sp+54h] [bp-10Ch]
  char v21; // [sp+58h] [bp-108h]
  int v22; // [sp+5Ch] [bp-104h] BYREF
  int v23; // [sp+60h] [bp-100h] BYREF
  int v24; // [sp+64h] [bp-FCh] BYREF
  int v25; // [sp+68h] [bp-F8h] BYREF
  int v26; // [sp+6Ch] [bp-F4h] BYREF
  int v27; // [sp+70h] [bp-F0h] BYREF
  int v28; // [sp+74h] [bp-ECh] BYREF
  int v29; // [sp+78h] [bp-E8h] BYREF
  int v30; // [sp+7Ch] [bp-E4h] BYREF
  int v31; // [sp+80h] [bp-E0h] BYREF
  float v32; // [sp+84h] [bp-DCh] BYREF
  float v33; // [sp+88h] [bp-D8h] BYREF
  unsigned __int8 v34[64]; // [sp+8Ch] [bp-D4h] BYREF
  unsigned __int8 v35[64]; // [sp+CCh] [bp-94h] BYREF

  v4 = CFileMgr::OpenFile("data\\procobj.dat", "r");
  Line = (const char *)CFileLoader::LoadLine(v4);
  if ( Line )
  {
    v1.n64_u32[0] = 1117782016;
    v13 = v4;
    do
    {
      v6 = *(unsigned __int8 *)Line;
      v7 = v6 == 0;
      if ( *Line )
        v7 = v6 == 35;
      if ( !v7 )
      {
        sscanf(
          Line,
          "%s %s %f %f %d %d %f %f %f %f %f %f %d %d",
          v35,
          v34,
          &v33,
          &v32,
          &v31,
          &v30,
          &v29,
          &v28,
          &v27,
          &v26,
          &v25,
          &v24,
          &v23,
          &v22);
        v14 = v22;
        v21 = v23;
        v20 = v24;
        v19 = v25;
        v18 = v26;
        v17 = v27;
        v16 = v28;
        v15 = v29;
        v8 = v30;
        v9 = v31;
        v2.n64_f32[0] = v32;
        v10 = v33;
        v11 = (char *)this + 72 * this->m_numProcSurfaceInfos;
        v11[8] = SurfaceInfos_c::GetSurfaceIdFromName(&g_surfaceInfos, v35);
        if ( CModelInfo::GetModelInfo(v34, (int32 *)v11 + 3) )
        {
          v12 = vmin_f32(v2, v1).n64_f32[0];
          *((float *)v11 + 4) = v10;
          *((_DWORD *)v11 + 9) = v15;
          *((_DWORD *)v11 + 10) = v16;
          *((_DWORD *)v11 + 11) = v17;
          *((_DWORD *)v11 + 12) = v18;
          *((_DWORD *)v11 + 13) = v19;
          *((_DWORD *)v11 + 14) = v20;
          v11[60] = v21;
          *((float *)v11 + 6) = v12 * v12;
          *((float *)v11 + 16) = (float)v14;
          *((float *)v11 + 5) = 1.0 / (float)(v10 * v10);
          *((float *)v11 + 7) = (float)((float)v9 / 180.0) * 3.1416;
          *((float *)v11 + 8) = (float)((float)v8 / 180.0) * 3.1416;
        }
        ++this->m_numProcSurfaceInfos;
        v4 = v13;
      }
      Line = (const char *)CFileLoader::LoadLine(v4);
    }
    while ( Line );
  }
  CFileMgr::CloseFile(v4);
}
// 457008: variable 'v2' is possibly undefined
// 457008: variable 'v1' is possibly undefined
// 456F0C: using guessed type unsigned __int8 var_94[64];
// 456F0C: using guessed type unsigned __int8 var_D4[64];

//----- (0045710C) --------------------------------------------------------
void __fastcall ProcObjectMan_c::Exit(ProcObjectMan_c *this)
{
  int32 m_numProcSurfaceInfos; // r0
  int32 i; // r10
  char *v4; // r6
  int v5; // r4
  List_c *v6; // r6
  int v7; // t1
  int v8; // r5
  int v9; // r0

  m_numProcSurfaceInfos = this->m_numProcSurfaceInfos;
  if ( m_numProcSurfaceInfos >= 1 )
  {
    for ( i = 0; i < m_numProcSurfaceInfos; ++i )
    {
      v4 = (char *)this + 72 * i;
      v7 = *((_DWORD *)v4 + 17);
      v6 = (List_c *)(v4 + 68);
      v5 = v7;
      if ( v7 )
      {
        do
        {
          v8 = *(_DWORD *)(v5 + 4);
          List_c::RemoveItem(v6, (ListItem_c *)v5);
          List_c::AddItem(&g_procObjMan.m_entityPool, (ListItem_c *)v5);
          (*(void (__fastcall **)(_DWORD))(**(_DWORD **)(v5 + 8) + 36))(*(_DWORD *)(v5 + 8));
          CWorld::Remove(*(CEntity **)(v5 + 8));
          v9 = *(_DWORD *)(v5 + 8);
          if ( v9 )
            (*(void (__fastcall **)(int))(*(_DWORD *)v9 + 4))(v9);
          *(_DWORD *)(v5 + 8) = 0;
          v5 = v8;
        }
        while ( v8 );
        m_numProcSurfaceInfos = this->m_numProcSurfaceInfos;
      }
    }
  }
  sub_19CBF0(&this->m_entityPool);
}

//----- (004571A2) --------------------------------------------------------
bool8 __fastcall ProcObjectMan_c::ProcessTriangleAdded(ProcObjectMan_c *this, CPlantLocTri *pLocTri)
{
  int32 m_numProcSurfaceInfos; // r1
  ProcSurfaceInfo_c *m_procSurfaceInfos; // r6
  int32 v6; // r5
  bool8 v7; // r9
  char v8; // r0

  m_numProcSurfaceInfos = this->m_numProcSurfaceInfos;
  if ( m_numProcSurfaceInfos < 1 )
    return 0;
  m_procSurfaceInfos = this->m_procSurfaceInfos;
  v6 = 0;
  v7 = 0;
  do
  {
    if ( m_procSurfaceInfos->m_surfaceId == pLocTri->m_nSurfaceType )
    {
      v8 = ProcSurfaceInfo_c::AddObjects(m_procSurfaceInfos, pLocTri);
      m_numProcSurfaceInfos = this->m_numProcSurfaceInfos;
      v7 += v8;
    }
    ++v6;
    ++m_procSurfaceInfos;
  }
  while ( v6 < m_numProcSurfaceInfos );
  return v7;
}

//----- (004571F0) --------------------------------------------------------
void __fastcall ProcObjectMan_c::ProcessTriangleRemoved(ProcObjectMan_c *this, CPlantLocTri *pLocTri)
{
  int32 m_numProcSurfaceInfos; // r0
  int32 i; // r10
  char *v6; // r6
  List_c *v7; // r6
  int v8; // r11
  int v9; // t1
  int v10; // r5
  CPlantLocTri *v11; // r0
  int v12; // r0
  int v13; // r0

  m_numProcSurfaceInfos = this->m_numProcSurfaceInfos;
  if ( m_numProcSurfaceInfos >= 1 )
  {
    for ( i = 0; i < m_numProcSurfaceInfos; ++i )
    {
      v6 = (char *)this + 72 * i;
      if ( v6[8] == pLocTri->m_nSurfaceType )
      {
        v9 = *((_DWORD *)v6 + 17);
        v7 = (List_c *)(v6 + 68);
        v8 = v9;
        if ( v9 )
        {
          do
          {
            while ( 1 )
            {
              v10 = v8;
              v11 = *(CPlantLocTri **)(v8 + 12);
              v8 = *(_DWORD *)(v8 + 4);
              if ( v11 == pLocTri )
                break;
              if ( !v8 )
                goto LABEL_15;
            }
            if ( (*(_BYTE *)(*(_DWORD *)(v10 + 8) + 58) & 7) == 4 )
              --CObject::nNoTempObjects;
            List_c::RemoveItem(v7, (ListItem_c *)v10);
            List_c::AddItem(&g_procObjMan.m_entityPool, (ListItem_c *)v10);
            (*(void (__fastcall **)(_DWORD))(**(_DWORD **)(v10 + 8) + 36))(*(_DWORD *)(v10 + 8));
            CWorld::Remove(*(CEntity **)(v10 + 8));
            v12 = *(_DWORD *)(v10 + 8);
            if ( v12 )
              (*(void (__fastcall **)(int))(*(_DWORD *)v12 + 4))(v12);
            v13 = *(unsigned __int8 *)(v10 + 16);
            *(_DWORD *)(v10 + 8) = 0;
            if ( v13 )
            {
              --this->m_numAllocatedMatrices;
              *(_BYTE *)(v10 + 16) = 0;
            }
          }
          while ( v8 );
LABEL_15:
          m_numProcSurfaceInfos = this->m_numProcSurfaceInfos;
        }
      }
    }
  }
}

//----- (004572CC) --------------------------------------------------------
void __fastcall CProjectile::CProjectile(CProjectile *this, int32 nModelIndex)
{
  int m_nFlags; // r3
  int (**v5)(void); // r0

  CObject::CObject(this);
  this->m_fMass = 1.0;
  this->m_fTurnMass = 1.0;
  m_nFlags = (int)this->m_nFlags;
  this->m_fAirResistance = 0.99999;
  this->m_fElasticity = 0.75;
  this->m_fBuoyancyConstant = 0.0008;
  *(_DWORD *)&this->m_nFlags = m_nFlags | 0x80000000;
  this->_vptr$CPlaceable = (int (**)(void))&off_667F00;
  CObject::SetIsStatic(this, 0);
  v5 = this->_vptr$CPlaceable;
  *(_DWORD *)&this->m_nPhysicalFlags |= 0x800000u;
  ((void (__fastcall *)(CProjectile *, int32))v5[6])(this, nModelIndex);
  this->ObjectCreatedBy = 5;
}
// 667F00: using guessed type void *;

//----- (00457340) --------------------------------------------------------
void __fastcall CProjectile::~CProjectile(CProjectile *this)
{
  void *v1; // r0

  CObject::~CObject(this);
  sub_18BC44(v1);
}
// 45734C: variable 'v1' is possibly undefined

//----- (00457350) --------------------------------------------------------
void __fastcall CPedClothesDesc::CPedClothesDesc(CPedClothesDesc *this)
{
  this->m_fatStat = 0.0;
  this->m_strengthStat = 0.0;
  *(_QWORD *)&this->texturesKeyArray[14] = 0LL;
  *(_QWORD *)&this->texturesKeyArray[16] = 0LL;
  *(_QWORD *)&this->texturesKeyArray[10] = 0LL;
  *(_QWORD *)&this->texturesKeyArray[12] = 0LL;
  *(_QWORD *)&this->texturesKeyArray[6] = 0LL;
  *(_QWORD *)&this->texturesKeyArray[8] = 0LL;
  *(_QWORD *)&this->texturesKeyArray[2] = 0LL;
  *(_QWORD *)&this->texturesKeyArray[4] = 0LL;
  *(_QWORD *)&this->modelsKeyArray[8] = 0LL;
  *(_QWORD *)this->texturesKeyArray = 0LL;
  *(_QWORD *)this->modelsKeyArray = 0LL;
  *(_QWORD *)&this->modelsKeyArray[2] = 0LL;
  *(_QWORD *)&this->modelsKeyArray[4] = 0LL;
  *(_QWORD *)&this->modelsKeyArray[6] = 0LL;
}

//----- (0045738E) --------------------------------------------------------
void __fastcall CPedClothesDesc::Initialise(CPedClothesDesc *this)
{
  uint32 *v1; // r0

  this->m_fatStat = 0.0;
  this->m_strengthStat = 0.0;
  *(_QWORD *)&this->texturesKeyArray[14] = 0LL;
  *(_QWORD *)&this->texturesKeyArray[16] = 0LL;
  *(_QWORD *)&this->texturesKeyArray[10] = 0LL;
  *(_QWORD *)&this->texturesKeyArray[12] = 0LL;
  *(_QWORD *)&this->texturesKeyArray[6] = 0LL;
  *(_QWORD *)&this->texturesKeyArray[8] = 0LL;
  *(_QWORD *)&this->texturesKeyArray[2] = 0LL;
  *(_QWORD *)&this->texturesKeyArray[4] = 0LL;
  *(_QWORD *)&this->modelsKeyArray[8] = 0LL;
  *(_QWORD *)this->texturesKeyArray = 0LL;
  *(_QWORD *)this->modelsKeyArray = 0LL;
  *(_QWORD *)&this->modelsKeyArray[2] = 0LL;
  v1 = &this->modelsKeyArray[4];
  *(_QWORD *)v1 = 0LL;
  *((_QWORD *)v1 + 1) = 0LL;
}

//----- (004573CC) --------------------------------------------------------
void __fastcall CPedClothesDesc::SetTextureAndModel(CPedClothesDesc *this, uint32 tex, uint32 model, int32 texType)
{
  int v4; // r12

  if ( (unsigned int)texType < 0x12 && 0x3E00Fu >> texType << 31 )
  {
    v4 = dword_618DF0[texType];
    this->texturesKeyArray[texType] = tex;
    this->modelsKeyArray[v4] = model;
  }
  else
  {
    this->texturesKeyArray[texType] = tex;
  }
}
// 618DF0: using guessed type int dword_618DF0[18];

//----- (00457404) --------------------------------------------------------
ePlayerClothesModels __fastcall CClothes::GetTextureDependency(int32 tex)
{
  if ( (unsigned int)tex <= 0x11 )
    return dword_618DA0[tex];
  else
    return 10;
}
// 618DA0: using guessed type _DWORD dword_618DA0[20];

//----- (0045741C) --------------------------------------------------------
void __fastcall CPedClothesDesc::SetTextureAndModel(
        CPedClothesDesc *this,
        const unsigned __int8 *pTex,
        const unsigned __int8 *pModel,
        int32 texType)
{
  uint32 UppercaseKey; // r6
  uint32 v8; // r0

  if ( pTex )
  {
    UppercaseKey = CKeyGen::GetUppercaseKey(pTex);
    if ( pModel )
      goto LABEL_3;
  }
  else
  {
    UppercaseKey = 0;
    if ( pModel )
    {
LABEL_3:
      v8 = CKeyGen::GetUppercaseKey(pModel);
      if ( (unsigned int)texType >= 0x12 )
        goto LABEL_8;
      goto LABEL_7;
    }
  }
  v8 = 0;
  if ( (unsigned int)texType >= 0x12 )
  {
LABEL_8:
    this->texturesKeyArray[texType] = UppercaseKey;
    return;
  }
LABEL_7:
  if ( !(0x3E00Fu >> texType << 31) )
    goto LABEL_8;
  this->texturesKeyArray[texType] = UppercaseKey;
  this->modelsKeyArray[dword_618DF0[texType]] = v8;
}
// 618DF0: using guessed type int dword_618DF0[18];

//----- (00457484) --------------------------------------------------------
void __fastcall CPedClothesDesc::SetModel(CPedClothesDesc *this, uint32 model, int32 modelType)
{
  this->modelsKeyArray[modelType] = model;
}

//----- (0045748A) --------------------------------------------------------
void __fastcall CPedClothesDesc::SetModel(CPedClothesDesc *this, const unsigned __int8 *pModel, int32 modelType)
{
  uint32 UppercaseKey; // r0

  if ( pModel )
    UppercaseKey = CKeyGen::GetUppercaseKey(pModel);
  else
    UppercaseKey = 0;
  this->modelsKeyArray[modelType] = UppercaseKey;
}

//----- (004574A4) --------------------------------------------------------
bool __fastcall CPedClothesDesc::GetIsWearingBalaclava(CPedClothesDesc *this)
{
  uint32 v1; // r4

  v1 = this->modelsKeyArray[9];
  return v1 == CKeyGen::GetUppercaseKey("balaclava");
}

//----- (004574C4) --------------------------------------------------------
bool __fastcall CPedClothesDesc::HasVisibleNewHairCut(CPedClothesDesc *this, int nType)
{
  uint32 v4; // r6
  uint32 v5; // r6
  bool result; // r0
  uint32 v7; // r4

  v4 = this->modelsKeyArray[9];
  result = 0;
  if ( v4 != CKeyGen::GetUppercaseKey("balaclava") )
  {
    v5 = this->modelsKeyArray[1];
    if ( v5 != CKeyGen::GetUppercaseKey("head") && !this->modelsKeyArray[8] )
    {
      if ( nType != 1 )
        return 1;
      v7 = this->modelsKeyArray[1];
      if ( v7 == CKeyGen::GetUppercaseKey("afro") )
        return 1;
    }
  }
  return result;
}

//----- (00457520) --------------------------------------------------------
bool __fastcall CPedClothesDesc::HasVisibleTattoo(CPedClothesDesc *this)
{
  uint32 v1; // r1
  bool v2; // zf
  uint32 v4; // r1
  bool v5; // zf
  uint32 v6; // r1
  bool v7; // zf
  uint32 v8; // r1
  bool v9; // zf

  v1 = this->texturesKeyArray[4];
  v2 = v1 == 0;
  if ( !v1 )
    v2 = this->texturesKeyArray[5] == 0;
  if ( !v2 )
    return 1;
  v4 = this->texturesKeyArray[6];
  v5 = v4 == 0;
  if ( !v4 )
    v5 = this->texturesKeyArray[7] == 0;
  if ( !v5 )
    return 1;
  v6 = this->texturesKeyArray[8];
  v7 = v6 == 0;
  if ( !v6 )
    v7 = this->texturesKeyArray[9] == 0;
  if ( !v7 )
    return 1;
  v8 = this->texturesKeyArray[10];
  v9 = v8 == 0;
  if ( !v8 )
    v9 = this->texturesKeyArray[11] == 0;
  return !v9 || this->texturesKeyArray[12] != 0;
}

//----- (00457560) --------------------------------------------------------
void __fastcall SetFatStat(float fat)
{
  CStats::SetStatValue(0x15u, fat);
  CClothes::RebuildPlayer(CWorld::Players[0].pPed, 0);
}

//----- (00457580) --------------------------------------------------------
void __fastcall CClothes::RebuildPlayer(CPlayerPed *pPlayer, bool bForReplay)
{
  _BOOL4 v3; // r6
  CAnimBlendAssociation *Associations; // r8
  CTask *TaskSecondary; // r0
  CPedClothesDesc *m_pClothes; // r5
  CPedClothesDesc *v7; // r5

  v3 = bForReplay;
  Associations = RpAnimBlendClumpExtractAssociations((RpClump_0 *)pPlayer->m_pRwObject);
  TaskSecondary = CTaskManager::GetTaskSecondary(&pPlayer->m_pPedIntelligence->m_taskManager, 5);
  if ( TaskSecondary )
    (*((void (__fastcall **)(CTask *, CPlayerPed *, int, _DWORD))TaskSecondary->_vptr$CTask + 7))(
      TaskSecondary,
      pPlayer,
      2,
      0);
  (*((void (__fastcall **)(CPlayerPed *))pPlayer->_vptr$CPlaceable + 9))(pPlayer);
  CWorld::Remove(pPlayer);
  if ( !v3 )
  {
    m_pClothes = pPlayer->m_pPlayerData->m_pClothes;
    m_pClothes->m_fatStat = CStats::GetStatValue(0x15u);
    v7 = pPlayer->m_pPlayerData->m_pClothes;
    v7->m_strengthStat = CStats::GetStatValue(0x17u);
  }
  CClothes::ConstructPedModel(pPlayer->m_nModelIndex, pPlayer->m_pPlayerData->m_pClothes, &gOldClothesState, 0);
  CPed::Dress(pPlayer);
  RpAnimBlendClumpGiveAssociations((RpClump_0 *)pPlayer->m_pRwObject, Associations);
  qmemcpy(&gOldClothesState, pPlayer->m_pPlayerData->m_pClothes, sizeof(gOldClothesState));
}

//----- (00457618) --------------------------------------------------------
void __fastcall SetMuscleStat(float muscle)
{
  CStats::SetStatValue(0x17u, muscle);
  CClothes::RebuildPlayer(CWorld::Players[0].pPed, 0);
}

//----- (00457638) --------------------------------------------------------
void __fastcall TryClothes(const unsigned __int8 *pTex, const unsigned __int8 *pModel, const unsigned __int8 *pSection)
{
  CPlayerPedData *m_pPlayerData; // r6
  const unsigned __int8 *v7; // r10
  const unsigned __int8 *v8; // r9
  CPedClothesDesc *m_pClothes; // r4
  uint32 UppercaseKey; // r8
  uint32 v11; // r0
  CPedClothesDesc *v12; // r4
  uint32 v13; // r8
  uint32 v14; // r0
  CPedClothesDesc *v15; // r4
  uint32 v16; // r8
  uint32 v17; // r0
  CPedClothesDesc *v18; // r4
  uint32 v19; // r8
  uint32 v20; // r0
  CPedClothesDesc *v21; // r4
  uint32 v22; // r8
  uint32 v23; // r0
  CPedClothesDesc *v24; // r4
  uint32 v25; // r8
  uint32 v26; // r0
  CPedClothesDesc *v27; // r4
  uint32 v28; // r8
  uint32 v29; // r0
  CPedClothesDesc *v30; // r4
  uint32 v31; // r8
  uint32 v32; // r0
  CPedClothesDesc *v33; // r4
  uint32 v34; // r5
  uint32 v35; // r0

  m_pPlayerData = CWorld::Players[0].pPed->m_pPlayerData;
  v7 = (const unsigned __int8 *)strcmp((const char *)pTex, (const char *)&off_4578B4);
  if ( v7 )
    v7 = pTex;
  v8 = (const unsigned __int8 *)strcmp((const char *)pModel, (const char *)&off_4578B4);
  if ( v8 )
    v8 = pModel;
  if ( !strcmp((const char *)pSection, "torso") )
  {
    m_pClothes = m_pPlayerData->m_pClothes;
    if ( v7 )
    {
      UppercaseKey = CKeyGen::GetUppercaseKey(v7);
      if ( v8 )
      {
LABEL_8:
        v11 = CKeyGen::GetUppercaseKey(v8);
LABEL_11:
        m_pClothes->modelsKeyArray[0] = v11;
        m_pClothes->texturesKeyArray[0] = UppercaseKey;
        goto LABEL_12;
      }
    }
    else
    {
      UppercaseKey = 0;
      if ( v8 )
        goto LABEL_8;
    }
    v11 = 0;
    goto LABEL_11;
  }
LABEL_12:
  if ( strcmp((const char *)pSection, "legs") )
    goto LABEL_19;
  v12 = m_pPlayerData->m_pClothes;
  if ( !v7 )
  {
    v13 = 0;
    if ( v8 )
      goto LABEL_15;
LABEL_17:
    v14 = 0;
    goto LABEL_18;
  }
  v13 = CKeyGen::GetUppercaseKey(v7);
  if ( !v8 )
    goto LABEL_17;
LABEL_15:
  v14 = CKeyGen::GetUppercaseKey(v8);
LABEL_18:
  v12->modelsKeyArray[3] = v14;
  v12->texturesKeyArray[2] = v13;
LABEL_19:
  if ( strcmp((const char *)pSection, "feet") )
    goto LABEL_26;
  v15 = m_pPlayerData->m_pClothes;
  if ( !v7 )
  {
    v16 = 0;
    if ( v8 )
      goto LABEL_22;
LABEL_24:
    v17 = 0;
    goto LABEL_25;
  }
  v16 = CKeyGen::GetUppercaseKey(v7);
  if ( !v8 )
    goto LABEL_24;
LABEL_22:
  v17 = CKeyGen::GetUppercaseKey(v8);
LABEL_25:
  v15->modelsKeyArray[4] = v17;
  v15->texturesKeyArray[3] = v16;
LABEL_26:
  if ( strcmp((const char *)pSection, "head") )
    goto LABEL_33;
  v18 = m_pPlayerData->m_pClothes;
  if ( !v7 )
  {
    v19 = 0;
    if ( v8 )
      goto LABEL_29;
LABEL_31:
    v20 = 0;
    goto LABEL_32;
  }
  v19 = CKeyGen::GetUppercaseKey(v7);
  if ( !v8 )
    goto LABEL_31;
LABEL_29:
  v20 = CKeyGen::GetUppercaseKey(v8);
LABEL_32:
  v18->modelsKeyArray[1] = v20;
  v18->texturesKeyArray[1] = v19;
LABEL_33:
  if ( strcmp((const char *)pSection, "necklace") )
    goto LABEL_40;
  v21 = m_pPlayerData->m_pClothes;
  if ( !v7 )
  {
    v22 = 0;
    if ( v8 )
      goto LABEL_36;
LABEL_38:
    v23 = 0;
    goto LABEL_39;
  }
  v22 = CKeyGen::GetUppercaseKey(v7);
  if ( !v8 )
    goto LABEL_38;
LABEL_36:
  v23 = CKeyGen::GetUppercaseKey(v8);
LABEL_39:
  v21->modelsKeyArray[5] = v23;
  v21->texturesKeyArray[13] = v22;
LABEL_40:
  if ( strcmp((const char *)pSection, "watch") )
    goto LABEL_47;
  v24 = m_pPlayerData->m_pClothes;
  if ( !v7 )
  {
    v25 = 0;
    if ( v8 )
      goto LABEL_43;
LABEL_45:
    v26 = 0;
    goto LABEL_46;
  }
  v25 = CKeyGen::GetUppercaseKey(v7);
  if ( !v8 )
    goto LABEL_45;
LABEL_43:
  v26 = CKeyGen::GetUppercaseKey(v8);
LABEL_46:
  v24->modelsKeyArray[6] = v26;
  v24->texturesKeyArray[14] = v25;
LABEL_47:
  if ( strcmp((const char *)pSection, "glasses") )
    goto LABEL_54;
  v27 = m_pPlayerData->m_pClothes;
  if ( !v7 )
  {
    v28 = 0;
    if ( v8 )
      goto LABEL_50;
LABEL_52:
    v29 = 0;
    goto LABEL_53;
  }
  v28 = CKeyGen::GetUppercaseKey(v7);
  if ( !v8 )
    goto LABEL_52;
LABEL_50:
  v29 = CKeyGen::GetUppercaseKey(v8);
LABEL_53:
  v27->modelsKeyArray[7] = v29;
  v27->texturesKeyArray[15] = v28;
LABEL_54:
  if ( strcmp((const char *)pSection, (const char *)&off_4578D4) )
    goto LABEL_61;
  v30 = m_pPlayerData->m_pClothes;
  if ( !v7 )
  {
    v31 = 0;
    if ( v8 )
      goto LABEL_57;
LABEL_59:
    v32 = 0;
    goto LABEL_60;
  }
  v31 = CKeyGen::GetUppercaseKey(v7);
  if ( !v8 )
    goto LABEL_59;
LABEL_57:
  v32 = CKeyGen::GetUppercaseKey(v8);
LABEL_60:
  v30->modelsKeyArray[8] = v32;
  v30->texturesKeyArray[16] = v31;
LABEL_61:
  if ( !strcmp((const char *)pSection, "extra1") )
  {
    v33 = m_pPlayerData->m_pClothes;
    if ( v7 )
    {
      v34 = CKeyGen::GetUppercaseKey(v7);
      if ( v8 )
      {
LABEL_64:
        v35 = CKeyGen::GetUppercaseKey(v8);
LABEL_67:
        v33->modelsKeyArray[9] = v35;
        v33->texturesKeyArray[17] = v34;
        goto LABEL_68;
      }
    }
    else
    {
      v34 = 0;
      if ( v8 )
        goto LABEL_64;
    }
    v35 = 0;
    goto LABEL_67;
  }
LABEL_68:
  CClothes::RebuildPlayer(CWorld::Players[0].pPed, 0);
}
// 4578B4: using guessed type void *off_4578B4;
// 4578D4: using guessed type void *off_4578D4;

//----- (004578E0) --------------------------------------------------------
void __fastcall TryTattoo(const unsigned __int8 *pTex, const unsigned __int8 *pTattoo)
{
  const unsigned __int8 *v4; // r4
  int v5; // r1
  int v6; // r5
  CPlayerPed *pPed; // r0
  CPedClothesDesc *m_pClothes; // r6
  uint32 UppercaseKey; // r1

  v4 = (const unsigned __int8 *)strcmp((const char *)pTex, (const char *)&off_457948);
  if ( v4 )
    v4 = pTex;
  v5 = atoi((const char *)pTattoo);
  if ( (unsigned int)(v5 - 1) <= 7 )
  {
    v6 = v5 + 3;
    pPed = CWorld::Players[0].pPed;
    m_pClothes = CWorld::Players[0].pPed->m_pPlayerData->m_pClothes;
    if ( v4 )
    {
      UppercaseKey = CKeyGen::GetUppercaseKey(v4);
      pPed = CWorld::Players[0].pPed;
    }
    else
    {
      UppercaseKey = 0;
    }
    m_pClothes->texturesKeyArray[v6] = UppercaseKey;
    CClothes::RebuildPlayer(pPed, 0);
  }
}
// 457948: using guessed type void *off_457948;

//----- (00457954) --------------------------------------------------------
int32 __fastcall GetClothesModelFromName(const unsigned __int8 *pName)
{
  int v2; // r1
  int32 result; // r0

  if ( !strcmp((const char *)pName, "torso") )
    return 0;
  if ( !strcmp((const char *)pName, "head") )
    return 1;
  if ( !strcmp((const char *)pName, "hands") )
    return 2;
  if ( !strcmp((const char *)pName, "legs") )
    return 3;
  if ( !strcmp((const char *)pName, "feet") )
    return 4;
  if ( !strcmp((const char *)pName, "necklace") )
    return 5;
  if ( !strcmp((const char *)pName, "watch") )
    return 6;
  if ( !strcmp((const char *)pName, "glasses") )
    return 7;
  if ( !strcmp((const char *)pName, (const char *)&off_457A20) )
    return 8;
  v2 = strcmp((const char *)pName, "extra1");
  result = 0;
  if ( !v2 )
    return 9;
  return result;
}
// 457A20: using guessed type void *off_457A20;

//----- (00457A28) --------------------------------------------------------
void CClothes::Init()
{
  unsigned int v0; // r2
  int *v1; // r0
  uint32 *texturesKeyArray; // r1
  uint32 *v3; // r4
  int v4; // r4

  v0 = -18;
  v1 = dword_618DF0;
  texturesKeyArray = gOldClothesState.texturesKeyArray;
  do
  {
    v3 = texturesKeyArray;
    if ( v0 + 18 < v0 )
    {
      v3 = texturesKeyArray;
      if ( ((unsigned int)&stru_3E00C.st_name + 3) >> (v0 + 18) << 31 )
      {
        v4 = *v1;
        *texturesKeyArray = -1;
        v3 = &gOldClothesState.modelsKeyArray[v4];
      }
    }
    ++texturesKeyArray;
    ++v1;
    ++v0;
    *v3 = -1;
  }
  while ( v0 );
  CClothes::ms_numRuleTags = 0;
  CClothes::ms_clothesImageId = CStreaming::AddImageToList("TEXDB\\PLAYER.IMG", 0);
  CClothes::LoadClothesFile();
}
// 3E00C: using guessed type Elf32_Sym stru_3E00C;
// 618DF0: using guessed type int dword_618DF0[18];

//----- (00457AC4) --------------------------------------------------------
void CClothes::LoadClothesFile()
{
  _BOOL4 v0; // r8
  u_native v1; // r4
  char *Line; // r11
  uint32 v3; // r10
  uint32 v4; // r0
  char *v5; // r11
  char *v6; // r5
  const unsigned __int8 *v7; // r0
  uint32 v8; // r0
  uint32 v9; // r11
  int32 ClothesModelFromName; // r0
  uint32 v11; // r5
  uint32 v12; // r2
  const char *v13; // r10
  uint32 UppercaseKey; // r0
  uint32 v15; // r1
  uint32 v16; // r0
  uint32 v17; // r1
  uint32 v18; // r0
  uint32 v19; // r1
  int v20; // r0
  bool v21; // zf
  char *v22; // r0
  const char *v23; // r5
  char *v24; // [sp+0h] [bp-68h]
  uint32 v25; // [sp+4h] [bp-64h]
  char *v26; // [sp+8h] [bp-60h]
  uint32 *v27; // [sp+48h] [bp-20h]

  v0 = 0;
  CClothes::ms_numRuleTags = 0;
  v1 = CFileMgr::OpenFile("DATA\\CLOTHES.DAT", "r");
  Line = (char *)CFileLoader::LoadLine(v1);
  if ( Line )
  {
    v27 = CClothes::ms_clothesRules;
    do
    {
      v20 = (unsigned __int8)*Line;
      v21 = v20 == 0;
      if ( *Line )
        v21 = v20 == 35;
      if ( !v21 )
      {
        if ( v0 )
        {
          if ( !strncmp("end", Line, 3u) )
          {
            v0 = 0;
          }
          else
          {
            v22 = strtok(Line, (const char *)CClothes::LoadClothesFile(void)::whitespace);
            v23 = v22;
            if ( v22 )
            {
              if ( !strcasecmp(v22, "cuts") )
              {
                v3 = 0;
              }
              else if ( !strcasecmp(v23, "setc") )
              {
                v3 = 1;
              }
              else if ( !strcasecmp(v23, "tex") )
              {
                v3 = 2;
              }
              else if ( !strcasecmp(v23, "hide") )
              {
                v3 = 3;
              }
              else if ( !strcasecmp(v23, "ignore") )
              {
                v3 = 5;
              }
              else if ( !strcasecmp(v23, "endignore") )
              {
                v3 = 4;
              }
              else if ( !strcasecmp(v23, "exclusive") )
              {
                v3 = 7;
              }
              else
              {
                v3 = (uint32)v27;
                if ( !strcasecmp(v23, "endexclusive") )
                  v3 = 6;
              }
              v4 = CClothes::ms_numRuleTags++;
              CClothes::ms_clothesRules[v4] = v3;
              v5 = strtok(0, (const char *)CClothes::LoadClothesFile(void)::whitespace);
              v6 = strtok(0, (const char *)CClothes::LoadClothesFile(void)::whitespace);
              v27 = (uint32 *)v3;
              switch ( v3 )
              {
                case 0u:
                case 2u:
                  UppercaseKey = CKeyGen::GetUppercaseKey((const unsigned __int8 *)v5);
                  v15 = CClothes::ms_numRuleTags++;
                  CClothes::ms_clothesRules[v15] = UppercaseKey;
                  v7 = (const unsigned __int8 *)v6;
                  goto LABEL_31;
                case 1u:
                  v26 = strtok(0, (const char *)CClothes::LoadClothesFile(void)::whitespace);
                  v24 = strtok(0, (const char *)CClothes::LoadClothesFile(void)::whitespace);
                  v8 = CKeyGen::GetUppercaseKey((const unsigned __int8 *)v5);
                  v9 = CClothes::ms_numRuleTags++;
                  v25 = CClothes::ms_numRuleTags;
                  CClothes::ms_clothesRules[v9] = v8;
                  ClothesModelFromName = GetClothesModelFromName((const unsigned __int8 *)v6);
                  v11 = v9 + 2;
                  CClothes::ms_numRuleTags = v9 + 2;
                  CClothes::ms_clothesRules[v25] = ClothesModelFromName;
                  if ( !strcmp((const char *)&off_457E2C, v26) )
                  {
                    v13 = v24;
                    v12 = 0;
                  }
                  else
                  {
                    v12 = CKeyGen::GetUppercaseKey((const unsigned __int8 *)v26);
                    v13 = v24;
                    v11 = CClothes::ms_numRuleTags;
                  }
                  CClothes::ms_numRuleTags = v11 + 1;
                  CClothes::ms_clothesRules[v11] = v12;
                  if ( !strcmp((const char *)&off_457E2C, v13) )
                  {
                    v18 = 0;
                  }
                  else
                  {
                    v7 = (const unsigned __int8 *)v13;
LABEL_31:
                    v18 = CKeyGen::GetUppercaseKey(v7);
                  }
LABEL_32:
                  v19 = CClothes::ms_numRuleTags++;
                  CClothes::ms_clothesRules[v19] = v18;
                  break;
                case 3u:
                  v16 = CKeyGen::GetUppercaseKey((const unsigned __int8 *)v5);
                  v17 = CClothes::ms_numRuleTags++;
                  CClothes::ms_clothesRules[v17] = v16;
                  v18 = GetClothesModelFromName((const unsigned __int8 *)v6);
                  goto LABEL_32;
                case 4u:
                case 5u:
                case 6u:
                case 7u:
                  v7 = (const unsigned __int8 *)v5;
                  goto LABEL_31;
                default:
                  break;
              }
            }
          }
        }
        else
        {
          v0 = strncmp("rule", Line, 4u) == 0;
        }
      }
      Line = (char *)CFileLoader::LoadLine(v1);
    }
    while ( Line );
  }
  sub_19B258(v1);
}
// 457E2C: using guessed type void *off_457E2C;

//----- (00457E5C) --------------------------------------------------------
void __fastcall CClothes::RebuildCutscenePlayer(CPlayerPed *pPlayer, int32 modelId)
{
  CPedClothesDesc *m_pClothes; // r6
  CPedClothesDesc *v5; // r6

  m_pClothes = pPlayer->m_pPlayerData->m_pClothes;
  m_pClothes->m_fatStat = CStats::GetStatValue(0x15u);
  v5 = pPlayer->m_pPlayerData->m_pClothes;
  v5->m_strengthStat = CStats::GetStatValue(0x17u);
  CClothes::ConstructPedModel(modelId, pPlayer->m_pPlayerData->m_pClothes, 0, 1);
}

//----- (00457E9C) --------------------------------------------------------
void __fastcall CClothes::ConstructPedModel(
        uint32 modelId,
        CPedClothesDesc *clothesDesc,
        const CPedClothesDesc *pOldClothesDesc,
        bool bCutsceneVersion)
{
  _BOOL4 v4; // r5
  CBaseModelInfo *v8; // r4
  RpClump_0 *m_pRwObject; // r6
  RwTexDictionary_0 *v10; // r1
  RpClump_0 *SkinnedClump; // r5

  v4 = bCutsceneVersion;
  CTimer::Suspend();
  v8 = CModelInfo::ms_modelInfoPtrs[modelId];
  m_pRwObject = (RpClump_0 *)v8->m_pRwObject;
  v10 = *(RwTexDictionary_0 **)&CTxdStore::ms_pTxdPool->m_aStorage[v8->m_txdIndex][0];
  if ( !v10 )
  {
    v10 = RwTexDictionaryCreate();
    *(_DWORD *)&CTxdStore::ms_pTxdPool->m_aStorage[v8->m_txdIndex][0] = v10;
  }
  SkinnedClump = CClothesBuilder::CreateSkinnedClump(m_pRwObject, v10, clothesDesc, pOldClothesDesc, v4);
  if ( SkinnedClump )
  {
    CClothes::RequestMotionGroupAnims();
    CBaseModelInfo::AddTexDictionaryRef(v8);
    (*((void (__fastcall **)(CBaseModelInfo *))v8->_vptr$CBaseModelInfo + 9))(v8);
    (*((void (__fastcall **)(CBaseModelInfo *, RpClump_0 *))v8->_vptr$CBaseModelInfo + 17))(v8, SkinnedClump);
    CBaseModelInfo::RemoveTexDictionaryRef(v8);
    CStreaming::LoadAllRequestedModels(1);
  }
  sub_19F744();
}

//----- (00457F48) --------------------------------------------------------
void __fastcall CClothes::RebuildPlayerIfNeeded(CPlayerPed *pPlayer)
{
  float m_fatStat; // s16
  float m_strengthStat; // s16

  m_fatStat = pPlayer->m_pPlayerData->m_pClothes->m_fatStat;
  if ( m_fatStat != CStats::GetStatValue(0x15u)
    || (m_strengthStat = pPlayer->m_pPlayerData->m_pClothes->m_strengthStat,
        m_strengthStat != CStats::GetStatValue(0x17u)) )
  {
    CClothes::RebuildPlayer(pPlayer, 0);
  }
}

//----- (00457FA4) --------------------------------------------------------
void CClothes::RequestMotionGroupAnims()
{
  float v0; // s18
  int32 v1; // r4
  int32 v2; // r5
  int32 v3; // r0
  float StatValue; // s18
  int32 AnimationBlockIndex; // r4
  int32 v6; // r0

  if ( CStats::GetStatValue(0x15u) <= 500.0 || (v0 = CStats::GetStatValue(0x17u), v0 >= CStats::GetStatValue(0x15u)) )
  {
    StatValue = CStats::GetStatValue(0x17u);
    AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex((const unsigned __int8 *)&dword_458050);
    v6 = CAnimManager::GetAnimationBlockIndex("muscular") + 25575;
    if ( StatValue <= 500.0 )
      CStreaming::SetModelIsDeletable(v6);
    else
      CStreaming::RequestModel(v6, 18);
    v3 = AnimationBlockIndex + 25575;
  }
  else
  {
    v1 = CAnimManager::GetAnimationBlockIndex((const unsigned __int8 *)&dword_458050);
    v2 = CAnimManager::GetAnimationBlockIndex("muscular");
    CStreaming::RequestModel(v1 + 25575, 18);
    v3 = v2 + 25575;
  }
  sub_19BC38(v3);
}
// 458050: using guessed type int dword_458050;

//----- (00458060) --------------------------------------------------------
AssocGroupId CClothes::GetPlayerMotionGroupToLoad()
{
  float StatValue; // s18
  AssocGroupId result; // r0
  float v2; // s0

  if ( CStats::GetStatValue(0x15u) > 500.0 )
  {
    StatValue = CStats::GetStatValue(0x17u);
    if ( StatValue < CStats::GetStatValue(0x15u) )
      return 55;
  }
  v2 = CStats::GetStatValue(0x17u);
  result = ANIM_PLAYER_PED;
  if ( v2 > 500.0 )
    return 56;
  return result;
}

//----- (004580C8) --------------------------------------------------------
ePlayerClothesTextures __fastcall CClothes::GetDependentTexture(int32 model)
{
  if ( (unsigned int)model <= 9 )
    return dword_4580D8[model];
  else
    return 18;
}
// 4580D8: using guessed type int dword_4580D8[];

//----- (00458100) --------------------------------------------------------
AssocGroupId CClothes::GetDefaultPlayerMotionGroup()
{
  float StatValue; // s18
  AssocGroupId result; // r0
  CAnimBlock *m_pAnimBlock; // r1
  bool v3; // zf

  if ( CStats::GetStatValue(0x15u) <= 500.0
    || (StatValue = CStats::GetStatValue(0x17u), StatValue >= CStats::GetStatValue(0x15u)) )
  {
    if ( CStats::GetStatValue(0x17u) <= 500.0 )
      return 54;
    result = ANIM_PLAYER_MUSCLE_PED;
  }
  else
  {
    result = ANIM_PLAYER_FAT_PED;
  }
  m_pAnimBlock = CAnimManager::ms_aAnimAssocGroups[result].m_pAnimBlock;
  v3 = m_pAnimBlock == 0;
  if ( m_pAnimBlock )
    v3 = !m_pAnimBlock->m_loaded;
  if ( v3 )
    return 54;
  return result;
}

//----- (00458184) --------------------------------------------------------
void __fastcall WriteRaster(RwRaster_0 *pRaster, const unsigned __int8 *pFilename)
{
  RwImage_0 *v4; // r6

  v4 = RwImageCreate(pRaster->width, pRaster->height, pRaster->depth);
  RwImageAllocatePixels(v4);
  RwImageSetFromRaster(v4, pRaster);
  RtPNGImageWrite(v4, pFilename);
  sub_19ECC0(v4);
}

//----- (004581C0) --------------------------------------------------------
void CClothesBuilder::LoadCdDirectory()
{
  CDirectory::Init(&gPlayerImageDir, 550, directoryBuffer);
  sub_19019C(&gPlayerImageDir, "TEXDB\\PLAYER.IMG");
}

//----- (004581F0) --------------------------------------------------------
void __fastcall CClothesBuilder::RequestGeometry(int32 index, uint32 key)
{
  uint32 appended; // r0
  uint32 v4; // [sp+8h] [bp-10h] BYREF
  uint32 v5[3]; // [sp+Ch] [bp-Ch] BYREF

  CModelInfo::ms_modelInfoPtrs[index]->m_flags |= 0x200u;
  appended = CKeyGen::AppendStringToKey(key, ".DFF");
  CDirectory::FindItem(&gPlayerImageDir, appended, v5, &v4);
  CStreaming::RequestFile(index, v5[0], v4, CClothes::ms_clothesImageId, 18);
}
// 4581F0: using guessed type uint32 var_C[3];

//----- (00458250) --------------------------------------------------------
RpClump_0 *__fastcall PreInstanceClump(RpClump_0 *pClump)
{
  RwFrame_0 *parent; // r5
  RwStream_0 *v3; // r5
  RwStream_0 *v4; // r0
  RwStream_0 *v5; // r4
  RpClump_0 *v6; // r5
  int v8[2]; // [sp+0h] [bp-28h] BYREF
  RwV3d_0 scale; // [sp+8h] [bp-20h] BYREF

  parent = (RwFrame_0 *)pClump->object.parent;
  CStreaming::FlushChannels();
  memset(&scale, 0, sizeof(scale));
  RwFrameScale(parent, &scale, rwCOMBINEREPLACE);
  RwCameraBeginUpdate(Scene.camera);
  RpClumpForAllAtomics(pClump, InstanceAtomicCB, 0);
  RwCameraEndUpdate(Scene.camera);
  v8[0] = (int)CStreaming::ms_pStreamingBuffer[0];
  v8[1] = CStreaming::ms_streamingBufferSize << 12;
  v3 = RwStreamOpen(rwSTREAMMEMORY, rwSTREAMAPPEND, v8);
  if ( v3 )
  {
    v3->Type.memory.position = 0;
    RpClumpStreamWrite(pClump, v3);
    RwStreamClose(v3, v8);
  }
  RpClumpDestroy(pClump);
  v4 = RwStreamOpen(rwSTREAMMEMORY, rwSTREAMREAD, v8);
  v5 = v4;
  v6 = 0;
  if ( v4 )
  {
    if ( RwStreamFindChunk(v4, 0x10u, 0, 0) )
      v6 = RpClumpStreamRead(v5);
    RwStreamClose(v5, 0);
  }
  return v6;
}

//----- (00458318) --------------------------------------------------------
RpAtomic_0 *__fastcall InstanceAtomicCB(RpAtomic_0 *pAtomic, void *pData)
{
  RpAtomicInstance(pAtomic);
  return pAtomic;
}

//----- (00458328) --------------------------------------------------------
void __fastcall CClothesBuilder::PreprocessClothesDesc(CPedClothesDesc *clothesDesc, bool bCutscene)
{
  int v3; // r9
  uint32 v4; // r4
  int32 v5; // r8
  uint32 v6; // r0
  uint32 *v7; // r0
  uint32 v8; // r4
  __int64 v9; // r0
  uint32 *v10; // r0
  uint32 v11; // r2
  int *v12; // r1
  int v13; // r0
  int v14; // r1
  int *v15; // r2
  uint32 v16; // r2
  int *v17; // r1
  int v18; // r0
  int *v19; // r2
  int v20; // r1
  int32 v21; // r4
  int v22; // lr
  int v23; // r3
  int v24; // r2
  int v25; // r5
  int v26; // r10
  int v27; // r12
  uint32 v28; // r10
  int32 DependentTexture; // r0
  int32 v30; // r0
  int v31; // r6
  CPedClothesDesc *v32; // r0
  uint32 v33; // r1
  int32 v34; // r2
  int32 v35; // r0
  _BOOL4 v36; // [sp+3Ch] [bp-9Ch]
  __int64 tex; // [sp+40h] [bp-98h]
  uint32 *model; // [sp+50h] [bp-88h]
  uint32 v39; // [sp+54h] [bp-84h]
  int v40; // [sp+58h] [bp-80h]
  uint32 v41; // [sp+5Ch] [bp-7Ch]
  int v42; // [sp+60h] [bp-78h]
  int v43; // [sp+64h] [bp-74h]
  int v44; // [sp+68h] [bp-70h]
  int v45; // [sp+6Ch] [bp-6Ch]
  int v46; // [sp+70h] [bp-68h]
  int v47; // [sp+74h] [bp-64h]
  int v48; // [sp+78h] [bp-60h]
  int v49; // [sp+7Ch] [bp-5Ch]
  int v50; // [sp+80h] [bp-58h]
  int v51; // [sp+84h] [bp-54h]
  int v52; // [sp+88h] [bp-50h]
  int v53; // [sp+8Ch] [bp-4Ch]
  int v54; // [sp+90h] [bp-48h] BYREF
  int v55; // [sp+94h] [bp-44h] BYREF
  int v56; // [sp+98h] [bp-40h] BYREF
  int v57; // [sp+9Ch] [bp-3Ch] BYREF
  int v58; // [sp+A0h] [bp-38h] BYREF
  int v59; // [sp+A4h] [bp-34h] BYREF
  int v60; // [sp+A8h] [bp-30h] BYREF
  int v61; // [sp+ACh] [bp-2Ch] BYREF
  char v62[8]; // [sp+B0h] [bp-28h]

  v36 = bCutscene;
  v60 = -1;
  v61 = -1;
  v58 = -1;
  v59 = -1;
  v56 = -1;
  v57 = -1;
  v54 = -1;
  v55 = -1;
  if ( CClothes::ms_numRuleTags )
  {
    v3 = -1;
    v4 = 0;
    LODWORD(tex) = CClothes::ms_clothesRules;
    HIDWORD(tex) = CClothes::ms_clothesRules;
    model = CClothes::ms_clothesRules;
    while ( 2 )
    {
      v6 = v4 + 1;
      v41 = CClothes::ms_clothesRules[v4];
      switch ( v41 )
      {
        case 0u:
          v5 = -1;
          model = (uint32 *)CClothes::ms_clothesRules[v6];
          v39 = v4 + 3;
          HIDWORD(tex) = CClothes::ms_clothesRules[v4 + 2];
          goto LABEL_80;
        case 1u:
          model = (uint32 *)CClothes::ms_clothesRules[v6];
          v7 = &CClothes::ms_clothesRules[v4];
          v8 = v4 + 5;
          HIDWORD(v9) = v7[3];
          v5 = v7[2];
          LODWORD(v9) = v7[4];
          tex = v9;
          goto LABEL_9;
        case 2u:
          v5 = -1;
          model = (uint32 *)CClothes::ms_clothesRules[v6];
          v39 = v4 + 3;
          LODWORD(tex) = CClothes::ms_clothesRules[v4 + 2];
          goto LABEL_80;
        case 3u:
          model = (uint32 *)CClothes::ms_clothesRules[v6];
          v10 = &CClothes::ms_clothesRules[v4];
          v8 = v4 + 3;
          v5 = v10[2];
LABEL_9:
          v39 = v8;
          goto LABEL_80;
        case 4u:
          v11 = CClothes::ms_clothesRules[v6];
          model = (uint32 *)v11;
          v39 = v4 + 2;
          if ( v3 == v11 )
          {
            v12 = &v54;
            v13 = 0;
          }
          else if ( v55 == v11 )
          {
            v13 = 1;
            v12 = &v55;
          }
          else if ( v56 == v11 )
          {
            v13 = 2;
            v12 = &v56;
          }
          else if ( v57 == v11 )
          {
            v13 = 3;
            v12 = &v57;
          }
          else if ( v58 == v11 )
          {
            v13 = 4;
            v12 = &v58;
          }
          else if ( v59 == v11 )
          {
            v13 = 5;
            v12 = &v59;
          }
          else if ( v60 == v11 )
          {
            v13 = 6;
            v12 = &v60;
          }
          else
          {
            if ( v61 != v11 )
              goto LABEL_3;
            v13 = 7;
            v12 = &v61;
          }
          v5 = -1;
          *v12 = -1;
          v62[v13] = 1;
          goto LABEL_80;
        case 5u:
          if ( v3 == -1 )
          {
            v15 = &v54;
            v14 = 0;
          }
          else if ( v55 == -1 )
          {
            v14 = 1;
            v15 = &v55;
          }
          else if ( v56 == -1 )
          {
            v14 = 2;
            v15 = &v56;
          }
          else if ( v57 == -1 )
          {
            v14 = 3;
            v15 = &v57;
          }
          else if ( v58 == -1 )
          {
            v14 = 4;
            v15 = &v58;
          }
          else if ( v59 == -1 )
          {
            v14 = 5;
            v15 = &v59;
          }
          else if ( v60 == -1 )
          {
            v14 = 6;
            v15 = &v60;
          }
          else
          {
            if ( v61 != -1 )
              goto LABEL_29;
            v14 = 7;
            v15 = &v61;
          }
          *v15 = CClothes::ms_clothesRules[v6];
          v62[v14] = 1;
          goto LABEL_73;
        case 6u:
          v16 = CClothes::ms_clothesRules[v6];
          model = (uint32 *)v16;
          v39 = v4 + 2;
          if ( v3 == v16 )
          {
            v17 = &v54;
            v18 = 0;
          }
          else if ( v55 == v16 )
          {
            v18 = 1;
            v17 = &v55;
          }
          else if ( v56 == v16 )
          {
            v18 = 2;
            v17 = &v56;
          }
          else if ( v57 == v16 )
          {
            v18 = 3;
            v17 = &v57;
          }
          else if ( v58 == v16 )
          {
            v18 = 4;
            v17 = &v58;
          }
          else if ( v59 == v16 )
          {
            v18 = 5;
            v17 = &v59;
          }
          else if ( v60 == v16 )
          {
            v18 = 6;
            v17 = &v60;
          }
          else
          {
            if ( v61 != v16 )
            {
LABEL_3:
              v5 = -1;
              goto LABEL_80;
            }
            v18 = 7;
            v17 = &v61;
          }
          v5 = -1;
          *v17 = -1;
          v62[v18] = 0;
          goto LABEL_80;
        case 7u:
          if ( v3 == -1 )
          {
            v19 = &v54;
            v20 = 0;
          }
          else if ( v55 == -1 )
          {
            v20 = 1;
            v19 = &v55;
          }
          else if ( v56 == -1 )
          {
            v20 = 2;
            v19 = &v56;
          }
          else if ( v57 == -1 )
          {
            v20 = 3;
            v19 = &v57;
          }
          else if ( v58 == -1 )
          {
            v20 = 4;
            v19 = &v58;
          }
          else if ( v59 == -1 )
          {
            v20 = 5;
            v19 = &v59;
          }
          else if ( v60 == -1 )
          {
            v20 = 6;
            v19 = &v60;
          }
          else
          {
            if ( v61 != -1 )
            {
LABEL_29:
              v5 = -1;
              v39 = v4 + 1;
              goto LABEL_80;
            }
            v20 = 7;
            v19 = &v61;
          }
          *v19 = CClothes::ms_clothesRules[v6];
          v62[v20] = 0;
LABEL_73:
          v39 = v4 + 2;
          v5 = -1;
LABEL_80:
          v53 = (unsigned __int8)v62[1];
          v21 = 0;
          v48 = (unsigned __int8)v62[2];
          v46 = (unsigned __int8)v62[3];
          v44 = (unsigned __int8)v62[4];
          v43 = (unsigned __int8)v62[5];
          v42 = (unsigned __int8)v62[6];
          v40 = (unsigned __int8)v62[7];
          v22 = (unsigned __int8)v62[0];
          v3 = v54;
          v23 = v55;
          v24 = v56;
          v25 = v57;
          v26 = v60;
          v27 = v61;
          v45 = v59;
          v47 = v58;
          v49 = v61;
          v50 = (unsigned __int8)v62[0];
          v51 = v55;
          v52 = v56;
          do
          {
            v30 = v5;
            if ( v5 == -1 )
              v30 = v21;
            if ( (v3 == -1 || (clothesDesc->modelsKeyArray[v30] == v3) != v22)
              && (v23 == -1 || (clothesDesc->modelsKeyArray[v30] == v23) != v53) )
            {
              if ( v24 == -1 || (v27 = v49, v22 = v50, (clothesDesc->modelsKeyArray[v30] == v24) != v48) )
              {
                v31 = v26;
                if ( v25 != -1 && (clothesDesc->modelsKeyArray[v30] == v25) == v46
                  || v47 != -1 && (clothesDesc->modelsKeyArray[v30] == v47) == v44
                  || v45 != -1 && (clothesDesc->modelsKeyArray[v30] == v45) == v43 )
                {
LABEL_117:
                  v26 = v31;
                }
                else if ( (v26 == -1 || (clothesDesc->modelsKeyArray[v30] == v26) != v42)
                       && (v27 == -1 || (clothesDesc->modelsKeyArray[v30] == v27) != v40) )
                {
                  switch ( v41 )
                  {
                    case 0u:
                      if ( v36 && (uint32 *)clothesDesc->modelsKeyArray[v21] == model )
                      {
                        v32 = clothesDesc;
                        v33 = HIDWORD(tex);
                        v34 = v21;
                        goto LABEL_115;
                      }
                      break;
                    case 1u:
                      if ( (uint32 *)clothesDesc->modelsKeyArray[v21] == model )
                      {
                        if ( v5 == 2 )
                        {
                          v32 = clothesDesc;
                          v33 = HIDWORD(tex);
                          v34 = 2;
                          goto LABEL_115;
                        }
                        v28 = HIDWORD(tex);
                        if ( !(_DWORD)tex )
                        {
                          v28 = HIDWORD(tex);
                          LODWORD(tex) = clothesDesc->texturesKeyArray[CClothes::GetDependentTexture(v5)];
                        }
                        if ( !v28 )
                          v28 = clothesDesc->modelsKeyArray[v5];
                        DependentTexture = CClothes::GetDependentTexture(v5);
                        HIDWORD(tex) = v28;
                        CPedClothesDesc::SetTextureAndModel(clothesDesc, tex, v28, DependentTexture);
                        goto LABEL_116;
                      }
                      break;
                    case 2u:
                      if ( (uint32 *)clothesDesc->modelsKeyArray[v21] == model )
                      {
                        v35 = CClothes::GetDependentTexture(v21);
                        CPedClothesDesc::SetTextureAndModel(clothesDesc, tex, (uint32)model, v35);
                        goto LABEL_116;
                      }
                      break;
                    case 3u:
                      if ( (uint32 *)clothesDesc->modelsKeyArray[v21] == model )
                      {
                        v32 = clothesDesc;
                        v33 = 0;
                        v34 = v5;
LABEL_115:
                        CPedClothesDesc::SetModel(v32, v33, v34);
LABEL_116:
                        v27 = v49;
                        v22 = v50;
                        goto LABEL_117;
                      }
                      break;
                    default:
                      break;
                  }
                }
                v23 = v51;
                v24 = v52;
              }
            }
            ++v21;
          }
          while ( v21 != 10 );
          v4 = v39;
          if ( v39 >= CClothes::ms_numRuleTags )
            return;
          continue;
        default:
          goto LABEL_29;
      }
    }
  }
}

//----- (004588BC) --------------------------------------------------------
RpClump_0 *__fastcall CClothesBuilder::CreateSkinnedClump(
        RpClump_0 *pBones,
        RwTexDictionary_0 *pTxd,
        CPedClothesDesc *clothesDesc,
        const CPedClothesDesc *pOldClothesDesc,
        _BOOL4 a5)
{
  float32x2_t v5; // d0
  float32x2_t v6; // d1
  float32x2_t v7; // d2
  float32x2_t v8; // d8
  int v12; // r0
  int v13; // r1
  int v14; // r2
  int *v15; // r4
  float v16; // s20
  float32x2_t v17; // d0
  float v18; // s18
  float v19; // s20
  float v20; // s2
  RpClump_0 *v21; // r5
  int i; // r5
  RwTexture_0 *NamedTexture; // r4
  RpMaterial_0 *v24; // r6
  RpAtomic_0 *FirstAtomic; // r4
  RpSkin_0 *Skin; // r9
  RpHAnimHierarchy_0 *HAnimHierarchy; // r4
  RpGeometry_0 *v28; // r8
  RwInt32 numVertices; // r11
  RwUInt32 NumBones; // r10
  RwUInt32 *v31; // r5
  RwMatrixWeights_0 *v32; // r6
  RwMatrix *SkinToBoneMatrices; // r0
  RpSkin_0 *v34; // r0
  RpHAnimHierarchy_0 *v35; // r6
  RwFrame_0 *v36; // r5
  RpAtomic_0 *v37; // r4
  RwFrame_0 *v38; // r6
  __int64 alpha; // [sp+0h] [bp-120h]
  uint32 *ppIndices; // [sp+14h] [bp-10Ch] BYREF
  RwMatrixWeights_0 *ppWeights; // [sp+18h] [bp-108h] BYREF
  RpGeometry_0 *ppGeometry; // [sp+1Ch] [bp-104h] BYREF
  CPedClothesDesc v45; // [sp+20h] [bp-100h] BYREF
  RpGeometry_0 *geometry; // [sp+98h] [bp-88h] BYREF
  RpGeometry_0 *v47; // [sp+9Ch] [bp-84h]
  RpGeometry_0 *v48; // [sp+A0h] [bp-80h]
  RpGeometry_0 *v49; // [sp+A4h] [bp-7Ch]
  RpGeometry_0 *v50; // [sp+A8h] [bp-78h]
  RpGeometry_0 *v51; // [sp+ACh] [bp-74h]
  RpGeometry_0 *v52; // [sp+B0h] [bp-70h]
  RpGeometry_0 *v53; // [sp+B4h] [bp-6Ch]
  RpGeometry_0 *v54; // [sp+B8h] [bp-68h]
  RpGeometry_0 *v55; // [sp+BCh] [bp-64h]
  RpMaterial_0 *material; // [sp+C0h] [bp-60h] BYREF
  RpMaterial_0 *v57; // [sp+C4h] [bp-5Ch]
  RpMaterial_0 *v58; // [sp+C8h] [bp-58h]
  RpMaterial_0 *v59; // [sp+CCh] [bp-54h]
  RpMaterial_0 *v60; // [sp+D0h] [bp-50h]
  RpMaterial_0 *v61; // [sp+D4h] [bp-4Ch]
  RpMaterial_0 *v62; // [sp+D8h] [bp-48h]
  RpMaterial_0 *v63; // [sp+DCh] [bp-44h]
  RpMaterial_0 *v64; // [sp+E0h] [bp-40h]
  RpMaterial_0 *v65; // [sp+E4h] [bp-3Ch]

  CPedClothesDesc::CPedClothesDesc(&v45);
  CDirectory::Init(&gPlayerImageDir, 550, directoryBuffer);
  CDirectory::ReadDirFile(&gPlayerImageDir, "TEXDB\\PLAYER.IMG");
  if ( !clothesDesc->modelsKeyArray[0] )
    CPedClothesDesc::SetModel(clothesDesc, torsoDffName, 0);
  if ( !clothesDesc->modelsKeyArray[1] )
    CPedClothesDesc::SetModel(clothesDesc, headDffName, 1);
  if ( !clothesDesc->modelsKeyArray[2] )
    CPedClothesDesc::SetModel(clothesDesc, handsDffName, 2);
  if ( !clothesDesc->modelsKeyArray[3] )
    CPedClothesDesc::SetModel(clothesDesc, legsDffName, 3);
  if ( !clothesDesc->modelsKeyArray[4] )
    CPedClothesDesc::SetModel(clothesDesc, feetDffName, 4);
  CClothesBuilder::ms_pOldClothesState = pOldClothesDesc;
  if ( pOldClothesDesc )
  {
    CClothesBuilder::ms_textureHasChanged = 0;
    CClothesBuilder::ms_geometryHasChanged = 0;
    if ( clothesDesc->m_fatStat == pOldClothesDesc->m_fatStat
      && clothesDesc->m_strengthStat == pOldClothesDesc->m_strengthStat )
    {
      v12 = 0;
    }
    else
    {
      v12 = 1;
      CClothesBuilder::ms_geometryHasChanged = 1;
    }
    CClothesBuilder::ms_ratiosHaveChanged = v12;
    if ( clothesDesc->modelsKeyArray[0] != pOldClothesDesc->modelsKeyArray[0]
      || clothesDesc->modelsKeyArray[1] != pOldClothesDesc->modelsKeyArray[1]
      || clothesDesc->modelsKeyArray[2] != pOldClothesDesc->modelsKeyArray[2]
      || clothesDesc->modelsKeyArray[3] != pOldClothesDesc->modelsKeyArray[3]
      || clothesDesc->modelsKeyArray[4] != pOldClothesDesc->modelsKeyArray[4]
      || clothesDesc->modelsKeyArray[5] != pOldClothesDesc->modelsKeyArray[5]
      || clothesDesc->modelsKeyArray[6] != pOldClothesDesc->modelsKeyArray[6]
      || clothesDesc->modelsKeyArray[7] != pOldClothesDesc->modelsKeyArray[7]
      || clothesDesc->modelsKeyArray[8] != pOldClothesDesc->modelsKeyArray[8]
      || (v13 = v12, clothesDesc->modelsKeyArray[9] != pOldClothesDesc->modelsKeyArray[9]) )
    {
      v13 = 1;
      CClothesBuilder::ms_geometryHasChanged = 1;
    }
    if ( clothesDesc->texturesKeyArray[0] == pOldClothesDesc->texturesKeyArray[0]
      && clothesDesc->texturesKeyArray[1] == pOldClothesDesc->texturesKeyArray[1]
      && clothesDesc->texturesKeyArray[2] == pOldClothesDesc->texturesKeyArray[2]
      && clothesDesc->texturesKeyArray[3] == pOldClothesDesc->texturesKeyArray[3]
      && clothesDesc->texturesKeyArray[4] == pOldClothesDesc->texturesKeyArray[4]
      && clothesDesc->texturesKeyArray[5] == pOldClothesDesc->texturesKeyArray[5]
      && clothesDesc->texturesKeyArray[6] == pOldClothesDesc->texturesKeyArray[6]
      && clothesDesc->texturesKeyArray[7] == pOldClothesDesc->texturesKeyArray[7]
      && clothesDesc->texturesKeyArray[8] == pOldClothesDesc->texturesKeyArray[8]
      && clothesDesc->texturesKeyArray[9] == pOldClothesDesc->texturesKeyArray[9]
      && clothesDesc->texturesKeyArray[10] == pOldClothesDesc->texturesKeyArray[10]
      && clothesDesc->texturesKeyArray[11] == pOldClothesDesc->texturesKeyArray[11]
      && clothesDesc->texturesKeyArray[12] == pOldClothesDesc->texturesKeyArray[12]
      && clothesDesc->texturesKeyArray[13] == pOldClothesDesc->texturesKeyArray[13]
      && clothesDesc->texturesKeyArray[14] == pOldClothesDesc->texturesKeyArray[14]
      && clothesDesc->texturesKeyArray[15] == pOldClothesDesc->texturesKeyArray[15]
      && clothesDesc->texturesKeyArray[16] == pOldClothesDesc->texturesKeyArray[16]
      && clothesDesc->texturesKeyArray[17] == pOldClothesDesc->texturesKeyArray[17] )
    {
      v14 = 0;
      goto LABEL_47;
    }
  }
  else
  {
    v13 = 1;
    CClothesBuilder::ms_geometryHasChanged = 1;
    v12 = 1;
    CClothesBuilder::ms_ratiosHaveChanged = 1;
  }
  v14 = 1;
  CClothesBuilder::ms_textureHasChanged = 1;
LABEL_47:
  if ( !(v12 | v13 | v14) )
    return 0;
  qmemcpy(&v45, clothesDesc, sizeof(v45));
  CClothesBuilder::PreprocessClothesDesc(&v45, a5);
  v15 = dword_458E28;
  v8.n64_u32[0] = 0;
  v5.n64_f32[0] = v45.m_fatStat + -200.0;
  v16 = vmax_f32(v5, v8).n64_f32[0];
  v5.n64_u32[0] = CStats::GetStatValue(0x17u);
  v17.n64_u64[0] = vmax_f32(v5, v8).n64_u64[0];
  v7.n64_f32[0] = v17.n64_f32[0] / 1000.0;
  if ( v16 < 0.0 )
    v15 = &dword_458E28[1];
  v17.n64_u32[0] = 1.0;
  v6.n64_f32[0] = v16 / *(float *)v15;
  v18 = vmin_f32(v7, v17).n64_f32[0];
  v19 = vmin_f32(v6, v17).n64_f32[0];
  v20 = v18 + v19;
  if ( (float)(v18 + v19) <= 1.0 )
  {
    v8.n64_f32[0] = 1.0 - v20;
  }
  else
  {
    v18 = v18 / v20;
    v19 = v19 / v20;
  }
  if ( (CClothesBuilder::ms_textureHasChanged || CClothesBuilder::ms_ratiosHaveChanged) << 24 && !a5 )
  {
    RwTexDictionaryForAllTextures(pTxd, RemoveTexturesCB, 0);
    CClothesBuilder::ConstructTextures(pTxd, v45.texturesKeyArray, v8.n64_f32[0], v19, v18);
  }
  for ( i = 0; i != 10; ++i )
  {
    NamedTexture = RwTexDictionaryFindNamedTexture(pTxd, clothesTextureNames[i]);
    if ( NamedTexture )
    {
      CRGBA::CRGBA((CRGBA *)&geometry, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
      v24 = RpMaterialCreate();
      v24->color = (RwRGBA_0)geometry;
      RpMaterialSetTexture(v24, NamedTexture);
    }
    else
    {
      v24 = 0;
    }
    *(&material + i) = v24;
  }
  CClothesBuilder::ConstructGeometryArray(&geometry, v45.modelsKeyArray, v8.n64_f32[0], v19, v18);
  FirstAtomic = GetFirstAtomic(pBones);
  Skin = j_RpSkinGeometryGetSkin(FirstAtomic->geometry);
  HAnimHierarchy = j_RpSkinAtomicGetHAnimHierarchy(FirstAtomic);
  LODWORD(alpha) = 10;
  HIDWORD(alpha) = &geometry;
  CClothesBuilder::ConstructGeometryAndSkinArrays(HAnimHierarchy, &ppGeometry, &ppWeights, &ppIndices, alpha, &material);
  v28 = ppGeometry;
  numVertices = ppGeometry->numVertices;
  NumBones = j_RpSkinGetNumBones(Skin);
  v31 = ppIndices;
  v32 = ppWeights;
  SkinToBoneMatrices = (RwMatrix *)j_RpSkinGetSkinToBoneMatrices(Skin);
  v34 = j_RpSkinCreate(numVertices, NumBones, v32, v31, SkinToBoneMatrices);
  j_RpSkinGeometrySetSkin(v28, v34);
  if ( v32 )
    operator delete[](v32);
  if ( v31 )
    operator delete[](v31);
  v35 = RpHAnimHierarchyCreateFromHierarchy(
          HAnimHierarchy,
          (RpHAnimHierarchyFlag_0)HAnimHierarchy->flags,
          HAnimHierarchy->currentAnim->maxInterpKeyFrameSize);
  v36 = RwFrameCreate();
  RpHAnimFrameSetHierarchy(v36, v35);
  v37 = RpAtomicCreate();
  RpAtomicSetGeometry(v37, v28, 0);
  j_RpSkinAtomicSetHAnimHierarchy(v37, v35);
  RpAtomicSetFrame(v37, v36);
  j_RpSkinAtomicSetType(v37, rpSKINTYPEGENERIC);
  v38 = RwFrameCreate();
  RwFrameAddChild(v38, v36);
  v21 = RpClumpCreate();
  v21->object.parent = v38;
  RpClumpAddAtomic(v21, v37);
  RpGeometryDestroy(v28);
  v28->flags |= 2u;
  RwTexDictionarySetCurrent(pTxd);
  if ( geometry )
    RpGeometryDestroy(geometry);
  if ( material )
    RpMaterialDestroy(material);
  if ( v47 )
    RpGeometryDestroy(v47);
  if ( v57 )
    RpMaterialDestroy(v57);
  if ( v48 )
    RpGeometryDestroy(v48);
  if ( v58 )
    RpMaterialDestroy(v58);
  if ( v49 )
    RpGeometryDestroy(v49);
  if ( v59 )
    RpMaterialDestroy(v59);
  if ( v50 )
    RpGeometryDestroy(v50);
  if ( v60 )
    RpMaterialDestroy(v60);
  if ( v51 )
    RpGeometryDestroy(v51);
  if ( v61 )
    RpMaterialDestroy(v61);
  if ( v52 )
    RpGeometryDestroy(v52);
  if ( v62 )
    RpMaterialDestroy(v62);
  if ( v53 )
    RpGeometryDestroy(v53);
  if ( v63 )
    RpMaterialDestroy(v63);
  if ( v54 )
    RpGeometryDestroy(v54);
  if ( v64 )
    RpMaterialDestroy(v64);
  if ( v55 )
    RpGeometryDestroy(v55);
  if ( v65 )
    RpMaterialDestroy(v65);
  return v21;
}
// 458B12: variable 'v5' is possibly undefined
// 458B12: variable 'v8' is possibly undefined
// 458B3E: variable 'v7' is possibly undefined
// 458B42: variable 'v6' is possibly undefined
// 458E28: using guessed type int dword_458E28[2];

//----- (00458E40) --------------------------------------------------------
RwTexture_0 *__fastcall RemoveTexturesCB(RwTexture_0 *pTexture, void *data)
{
  RwTexDictionaryRemoveTexture(pTexture);
  RwTextureDestroy(pTexture);
  return pTexture;
}

//----- (00458E54) --------------------------------------------------------
void __fastcall CClothesBuilder::ConstructTextures(
        RwTexDictionary_0 *pTargetTxd,
        uint32 *pTextureKeys,
        float normal,
        float fatness,
        float strength)
{
  float32x2_t v5; // d10
  float32x2_t v6; // d11
  RwTexture_0 *v10; // r6
  int i; // r4
  RwTexture_0 *ClothesTexture; // r0
  uint32 UppercaseKey; // r0
  RwTexture_0 *v14; // r11
  float v15; // s20
  uint32 v16; // r0
  RwTexture_0 *v17; // r9
  uint32 v18; // r0
  RwTexture_0 *v19; // r10
  RwTexture_0 *v20; // r0
  RwTexture_0 *v21; // r4
  RwTexture_0 *v22; // r0
  uint32 v23; // r0
  RwTexture_0 *v24; // r4
  uint32 v25; // r0
  RwTexture_0 *v26; // r9
  uint32 v27; // r0
  RwTexture_0 *v28; // r6
  RwTexture_0 *v29; // r4
  RwTexture_0 *v30; // r0
  uint32 v31; // r4
  RwTexture_0 *v32; // r6
  RwTexture_0 *v33; // r9
  RwTexture_0 *v34; // r0
  RwTexture_0 *v35; // r4
  RwTexture_0 *v36; // r0
  uint32 v37; // r0
  RwTexture_0 *v38; // r4
  RwTexture_0 *v39; // r0
  RwTexture_0 *v40; // r0
  RwTexture_0 *v41; // r0
  RwTexture_0 *v42; // r4
  RwTexture_0 *v43; // r0
  RwTexture_0 *v44; // r0
  RwTexture_0 *v45; // r4
  RwTexture_0 *v46; // r0
  RwTexture_0 *v47; // r0
  RwTexture_0 *v48; // r4
  RwTexture_0 *v49; // r0
  RwTexture_0 *v50; // r0
  RwTexture_0 *v51; // r4
  RwTexture_0 *v52; // r0
  RwTexture_0 *v53; // r0
  RwTexture_0 *v54; // r4
  int32 v55; // [sp+0h] [bp-60h]
  int32 v56; // [sp+8h] [bp-58h]
  int32 v57; // [sp+8h] [bp-58h]

  v6.n64_f32[0] = fatness;
  v10 = 0;
  for ( i = 4; i != 13; ++i )
  {
    ClothesTexture = CClothesBuilder::GetClothesTexture(pTextureKeys[i], 0);
    if ( ClothesTexture )
    {
      if ( v10 )
        CClothesBuilder::PlaceTextureOnTopOfTexture(v10, ClothesTexture, 1);
      else
        v10 = CClothesBuilder::CopyTexture(ClothesTexture);
    }
  }
  v5.n64_u32[0] = 0;
  UppercaseKey = CKeyGen::GetUppercaseKey(torsoTxdName);
  v14 = CClothesBuilder::GetClothesTexture(UppercaseKey, torsoTex);
  LODWORD(v15) = vmax_f32(v6, v5).n64_u32[0];
  v16 = CKeyGen::GetUppercaseKey(torsoTxdName);
  v17 = CClothesBuilder::GetClothesTexture(v16, fatTorsoTex);
  v18 = CKeyGen::GetUppercaseKey(torsoTxdName);
  if ( v6.n64_f32[0] < 0.0 )
    normal = normal + v6.n64_f32[0];
  v19 = CClothesBuilder::GetClothesTexture(v18, rippedTorsoTex);
  v20 = CClothesBuilder::CopyTexture(v14);
  v21 = v20;
  if ( v10 )
  {
    CClothesBuilder::BlendTextures(v20, v17, v19, normal, v15, strength, v56, v10);
    RwTextureDestroy(v10);
  }
  else
  {
    CClothesBuilder::BlendTextures(v20, v17, v19, normal, v15, strength, v56);
  }
  v22 = CClothesBuilder::GetClothesTexture(*pTextureKeys, 0);
  if ( v22 )
  {
    if ( v21 )
      CClothesBuilder::PlaceTextureOnTopOfTexture(v21, v22, 0);
    else
      CClothesBuilder::CopyTexture(v22);
  }
  RwTextureSetName(v21, clothesTextureNames[0]);
  RwTexDictionaryAddTexture(pTargetTxd, v21);
  v23 = CKeyGen::GetUppercaseKey(legsTxdName);
  v24 = CClothesBuilder::GetClothesTexture(v23, legsTex);
  v25 = CKeyGen::GetUppercaseKey(legsTxdName);
  v26 = CClothesBuilder::GetClothesTexture(v25, fatLegsTex);
  v27 = CKeyGen::GetUppercaseKey(legsTxdName);
  v28 = CClothesBuilder::GetClothesTexture(v27, rippedLegsTex);
  v29 = CClothesBuilder::CopyTexture(v24);
  CClothesBuilder::BlendTextures(v29, v26, v28, normal, v15, strength, v57);
  v30 = CClothesBuilder::GetClothesTexture(pTextureKeys[2], 0);
  if ( v30 )
  {
    if ( v29 )
      CClothesBuilder::PlaceTextureOnTopOfTexture(v29, v30, 0);
    else
      CClothesBuilder::CopyTexture(v30);
  }
  RwTextureSetName(v29, clothesTextureNames[3]);
  RwTexDictionaryAddTexture(pTargetTxd, v29);
  v31 = pTextureKeys[1];
  if ( !v31 )
    v31 = CKeyGen::GetUppercaseKey(faceTxdName);
  v32 = CClothesBuilder::GetClothesTexture(v31, faceTex);
  v33 = CClothesBuilder::GetClothesTexture(v31, fatFaceTex);
  if ( v32 )
  {
    v34 = CClothesBuilder::CopyTexture(v32);
    v35 = v34;
    if ( v33 )
      CClothesBuilder::BlendTextures(
        v34,
        v33,
        (float)(normal + strength) / (float)(normal + (float)(v15 + strength)),
        v15 / (float)(v15 + (float)(normal + strength)),
        v55);
  }
  else
  {
    v36 = CClothesBuilder::GetClothesTexture(v31, 0);
    v35 = CClothesBuilder::CopyTexture(v36);
  }
  RwTextureSetName(v35, clothesTextureNames[1]);
  RwTexDictionaryAddTexture(pTargetTxd, v35);
  v37 = pTextureKeys[3];
  if ( !v37 )
    v37 = CKeyGen::GetUppercaseKey(feetTxdName);
  v38 = 0;
  v39 = CClothesBuilder::GetClothesTexture(v37, 0);
  if ( v39 )
    v38 = CClothesBuilder::CopyTexture(v39);
  RwTextureSetName(v38, clothesTextureNames[4]);
  RwTexDictionaryAddTexture(pTargetTxd, v38);
  v40 = CClothesBuilder::GetClothesTexture(pTextureKeys[13], 0);
  if ( v40 )
  {
    v41 = CClothesBuilder::CopyTexture(v40);
    v42 = v41;
    if ( v41 )
    {
      RwTextureSetName(v41, clothesTextureNames[5]);
      RwTexDictionaryAddTexture(pTargetTxd, v42);
    }
  }
  v43 = CClothesBuilder::GetClothesTexture(pTextureKeys[14], 0);
  if ( v43 )
  {
    v44 = CClothesBuilder::CopyTexture(v43);
    v45 = v44;
    if ( v44 )
    {
      RwTextureSetName(v44, clothesTextureNames[6]);
      RwTexDictionaryAddTexture(pTargetTxd, v45);
    }
  }
  v46 = CClothesBuilder::GetClothesTexture(pTextureKeys[15], 0);
  if ( v46 )
  {
    v47 = CClothesBuilder::CopyTexture(v46);
    v48 = v47;
    if ( v47 )
    {
      RwTextureSetName(v47, clothesTextureNames[7]);
      RwTexDictionaryAddTexture(pTargetTxd, v48);
    }
  }
  v49 = CClothesBuilder::GetClothesTexture(pTextureKeys[16], 0);
  if ( v49 )
  {
    v50 = CClothesBuilder::CopyTexture(v49);
    v51 = v50;
    if ( v50 )
    {
      RwTextureSetName(v50, clothesTextureNames[8]);
      RwTexDictionaryAddTexture(pTargetTxd, v51);
    }
  }
  v52 = CClothesBuilder::GetClothesTexture(pTextureKeys[17], 0);
  if ( v52 )
  {
    v53 = CClothesBuilder::CopyTexture(v52);
    v54 = v53;
    if ( v53 )
    {
      RwTextureSetName(v53, clothesTextureNames[9]);
      sub_19BFE8(pTargetTxd, v54);
    }
  }
}
// 458ED8: variable 'v6' is possibly undefined
// 458ED8: variable 'v5' is possibly undefined
// 458F30: variable 'v56' is possibly undefined
// 458FE0: variable 'v57' is possibly undefined
// 45907E: variable 'v55' is possibly undefined

//----- (0045921C) --------------------------------------------------------
void __fastcall CClothesBuilder::ConstructGeometryArray(
        RpGeometry_0 **ppGeometry,
        uint32 *pModelKeys,
        float normal,
        float fatness,
        float strength)
{
  int v8; // r8
  int16 (*v9)[64]; // r11
  uint32 v10; // r0
  uint32 appended; // r0
  uint32 v12; // r0
  uint32 v13; // r0
  CBaseModelInfo *v14; // r6
  RpClump_0 *m_pRwObject; // r0
  int v16; // r6
  RpHAnimHierarchy_0 *HAnimHierarchy; // r0
  int v18; // r1
  int v19; // r2
  RwInt32 v20; // r3
  uint32 size; // [sp+2Ch] [bp-44h] BYREF
  const char *v23; // [sp+30h] [bp-40h] BYREF
  RpAtomic_0 *atomic; // [sp+34h] [bp-3Ch]

  v8 = 0;
  v9 = gBoneIndices;
  do
  {
    v10 = pModelKeys[v8];
    if ( v10 )
    {
      CModelInfo::ms_modelInfoPtrs[v8 + 384]->m_flags |= 0x200u;
      appended = CKeyGen::AppendStringToKey(v10, ".DFF");
      CDirectory::FindItem(&gPlayerImageDir, appended, (uint32 *)&v23, &size);
      CStreaming::RequestFile(v8 + 384, (int32)v23, size, CClothes::ms_clothesImageId, 18);
      CStreaming::LoadAllRequestedModels(1);
      if ( v8 <= 8 )
      {
        v12 = pModelKeys[v8 + 1];
        if ( v12 )
        {
          CModelInfo::ms_modelInfoPtrs[v8 + 385]->m_flags |= 0x200u;
          v13 = CKeyGen::AppendStringToKey(v12, ".DFF");
          CDirectory::FindItem(&gPlayerImageDir, v13, (uint32 *)&v23, &size);
          CStreaming::RequestFile(v8 + 385, (int32)v23, size, CClothes::ms_clothesImageId, 18);
          CStreaming::LoadRequestedModels();
        }
      }
      v14 = CModelInfo::ms_modelInfoPtrs[v8 + 384];
      ppGeometry[v8] = CClothesBuilder::BlendGeometry(
                         (RpClump_0 *)v14->m_pRwObject,
                         "normal",
                         (const unsigned __int8 *)&dword_4593D8,
                         "ripped",
                         normal,
                         fatness,
                         strength);
      m_pRwObject = (RpClump_0 *)v14->m_pRwObject;
      v16 = 0;
      v23 = "normal";
      atomic = 0;
      RpClumpForAllAtomics(m_pRwObject, FindAtomicFromNameCB, &v23);
      HAnimHierarchy = j_RpSkinAtomicGetHAnimHierarchy(atomic);
      if ( HAnimHierarchy->numNodes >= 1 )
      {
        v18 = -1;
        v19 = 0;
        do
        {
          (*v9)[v19] = HAnimHierarchy->pNodeInfo[v19].nodeID;
          v20 = v18 + 2;
          ++v19;
          ++v18;
        }
        while ( v20 < HAnimHierarchy->numNodes );
        if ( v18 > 62 )
          goto LABEL_12;
        v16 = v18 + 1;
      }
      gBoneIndices[v8][v16] = -1;
LABEL_12:
      CStreaming::RemoveModel(v8 + 384);
      goto LABEL_14;
    }
    ppGeometry[v8] = 0;
LABEL_14:
    ++v8;
    ++v9;
  }
  while ( v8 != 10 );
}
// 4593D8: using guessed type int dword_4593D8;

//----- (00459400) --------------------------------------------------------
void __fastcall CClothesBuilder::ConstructGeometryAndSkinArrays(
        RpHAnimHierarchy_0 *pBoneHier,
        RpGeometry_0 **ppGeometry,
        RwMatrixWeights_0 **ppWeights,
        uint32 **ppIndices,
        __int64 numModels,
        RpMaterial_0 **pMaterials)
{
  int v7; // r9
  RwInt32 v8; // r4
  int *v9; // r2
  int v10; // r5
  RwInt32 v11; // r1
  int v12; // r3
  __int64 v13; // kr10_8
  RpGeometry_0 *v14; // r0
  RpGeometry_0 *v15; // r8
  int v16; // r5
  __int16 v17; // r10
  RpMaterial_0 **v18; // r1
  int v19; // r3
  RwV3d_0 *normals; // r4
  RwV3d_0 *verts; // r12
  RwTexCoords_0 *v22; // r0
  _DWORD *v23; // r11
  int v24; // r2
  int v25; // r6
  int v26; // lr
  int v27; // r3
  RwV3d_0 *v28; // r8
  int v29; // r6
  int v30; // r9
  int v31; // r4
  int v32; // r1
  RwV3d_0 *v33; // r5
  RwReal *v34; // r2
  __int64 v35; // d16
  RwV3d_0 *v36; // r5
  RwReal *v37; // r2
  __int64 v38; // d16
  int v39; // r2
  RwReal v40; // r5
  RwReal v41; // r2
  RwTexCoords_0 *v42; // r5
  int v43; // r4
  RpMaterial_0 **v44; // r5
  _WORD *v45; // r9
  RpGeometry_0 *v46; // r11
  RpTriangle_0 *v47; // r6
  int v48; // r8
  __int64 v49; // d17
  __int64 v50; // r0
  RwMatrixWeights_0 *v51; // r0
  unsigned int v52; // r1
  int v53; // r2
  uint32 *v54; // r11
  RpHAnimHierarchy_0 *v55; // r8
  int v56; // r2
  RwMatrixWeights_0 *v57; // r1
  int v58; // r10
  RpSkin_0 *Skin; // r0
  int v60; // r10
  RpSkin_0 *v61; // r6
  int v62; // r5
  RwInt32 v63; // r1
  unsigned __int8 v64; // r0
  bool v65; // cc
  unsigned int v66; // r9
  int v67; // r8
  const RwUInt32 *VertexBoneIndices; // r0
  int v69; // r1
  unsigned __int8 *v70; // r0
  uint32 *v71; // r2
  const RwMatrixWeights_0 *v72; // r0
  RpTriangle_0 v73; // d16
  RpTriangle_0 v74; // d17
  RpTriangle_0 *v75; // r0
  unsigned int v76; // [sp+8h] [bp-A0h]
  RpMorphTarget_0 *morphTarget; // [sp+14h] [bp-94h]
  RpGeometry_0 *v80; // [sp+18h] [bp-90h]
  __int16 v82; // [sp+20h] [bp-88h]
  RwV3d_0 *v83; // [sp+24h] [bp-84h]
  RwV3d_0 *v84; // [sp+28h] [bp-80h]
  RwTexCoords_0 *v85; // [sp+28h] [bp-80h]
  int v86; // [sp+2Ch] [bp-7Ch]
  RwV3d_0 *v87; // [sp+2Ch] [bp-7Ch]
  int v88; // [sp+2Ch] [bp-7Ch]
  RpTriangle_0 *triangle; // [sp+30h] [bp-78h]
  RpTriangle_0 *trianglea; // [sp+30h] [bp-78h]
  int v91; // [sp+34h] [bp-74h]
  int16 (*v92)[64]; // [sp+34h] [bp-74h]
  RwSphere_0 boundingSphere; // [sp+38h] [bp-70h] BYREF
  char v94[64]; // [sp+48h] [bp-60h]

  v7 = HIDWORD(numModels);
  if ( (_DWORD)numModels )
  {
    v8 = 0;
    v9 = (int *)HIDWORD(numModels);
    v10 = numModels;
    v11 = 0;
    do
    {
      v12 = *v9++;
      if ( v12 )
      {
        v13 = *(_QWORD *)(v12 + 16);
        v11 += v13;
        v8 += HIDWORD(v13);
      }
      --v10;
    }
    while ( v10 );
  }
  else
  {
    v11 = 0;
    v8 = 0;
  }
  v76 = v8;
  v14 = RpGeometryCreate(v8, v11, 0x35u);
  v15 = v14;
  v16 = numModels;
  *ppGeometry = v14;
  morphTarget = v14->morphTarget;
  if ( (_DWORD)numModels )
  {
    v17 = 0;
    v18 = pMaterials;
    v19 = 0;
    normals = morphTarget->normals;
    verts = morphTarget->verts;
    triangle = v14->triangles;
    v22 = v14->texCoords[0];
    v80 = v15;
    do
    {
      v23 = *(_DWORD **)(v7 + 4 * v19);
      if ( v23 )
      {
        v25 = v23[5];
        v24 = v23[4];
        v91 = v24;
        if ( v25 >= 1 )
        {
          v26 = 3 * v25;
          v86 = v19;
          v27 = v23[24];
          v28 = normals;
          v84 = &normals[v25];
          v29 = 0;
          v30 = v23[5];
          v31 = v30;
          v32 = 0;
          do
          {
            v33 = &verts[v32];
            --v31;
            v34 = (RwReal *)(*(_DWORD *)(v27 + 20) + v32 * 12);
            v35 = *(_QWORD *)v34;
            v33->z = v34[2];
            *(_QWORD *)&v33->x = v35;
            v36 = &v28[v32];
            v37 = (RwReal *)(*(_DWORD *)(v27 + 24) + v32 * 12);
            ++v32;
            v38 = *(_QWORD *)v37;
            v36->z = v37[2];
            *(_QWORD *)&v36->x = v38;
            v39 = v23[13];
            v40 = *(float *)(v39 + v29 * 8);
            v41 = *(float *)(v39 + v29 * 8 + 4);
            v22[v29].u = v40;
            v42 = &v22[v29++];
            v42->v = v41;
          }
          while ( v31 );
          v25 = v30;
          normals = v84;
          v7 = HIDWORD(numModels);
          v16 = numModels;
          v22 += v25;
          v18 = pMaterials;
          verts = (RwV3d_0 *)((char *)verts + 4 * v26);
          v19 = v86;
          v15 = v80;
          v24 = v91;
        }
        if ( v24 >= 1 )
        {
          v82 = v25;
          v83 = normals;
          v43 = v24;
          v85 = v22;
          v87 = verts;
          v44 = v18;
          v45 = (_WORD *)v23[11];
          v46 = v15;
          v47 = triangle;
          v48 = v19;
          do
          {
            RpGeometryTriangleSetVertexIndices(v46, v47, v17 + *v45, v17 + v45[1], v45[2] + v17);
            RpGeometryTriangleSetMaterial(v46, v47, v44[v48]);
            v45 += 4;
            --v43;
            ++v47;
          }
          while ( v43 );
          v19 = v48;
          v7 = HIDWORD(numModels);
          v15 = v46;
          triangle += v91;
          v18 = v44;
          v16 = numModels;
          verts = v87;
          v22 = v85;
          LOWORD(v25) = v82;
          normals = v83;
        }
        v17 += v25;
      }
      ++v19;
    }
    while ( v19 != v16 );
  }
  RpMorphTargetCalcBoundingSphere(morphTarget, &boundingSphere);
  v49 = *(_QWORD *)&boundingSphere.center.z;
  *(_QWORD *)&morphTarget->boundingSphere.center.x = *(_QWORD *)&boundingSphere.center.x;
  *(_QWORD *)&morphTarget->boundingSphere.center.z = v49;
  RpGeometryUnlock(v15);
  v50 = 16LL * v76;
  if ( !is_mul_ok(0x10u, v76) )
    HIDWORD(v50) = 1;
  if ( HIDWORD(v50) )
    LODWORD(v50) = -1;
  v51 = (RwMatrixWeights_0 *)operator new[](v50);
  v53 = (unsigned __int64)v76 >> 30;
  v52 = 4 * v76;
  *ppWeights = v51;
  if ( !is_mul_ok(4u, v76) )
    v53 = 1;
  if ( v53 )
    v52 = -1;
  v54 = (uint32 *)operator new[](v52);
  *ppIndices = v54;
  v55 = pBoneHier;
  if ( v16 )
  {
    v56 = 0;
    v57 = *ppWeights;
    v92 = gBoneIndices;
    do
    {
      v58 = *(_DWORD *)(v7 + 4 * v56);
      if ( v58 )
      {
        v88 = v56;
        trianglea = (RpTriangle_0 *)v57;
        Skin = j_RpSkinGeometryGetSkin(*(RpGeometry_0 **)(v7 + 4 * v56));
        v60 = *(_DWORD *)(v58 + 20);
        v61 = Skin;
        v62 = 0;
        do
        {
          v63 = (*v92)[v62];
          if ( v63 == -1 )
            break;
          v64 = RpHAnimIDGetIndex(v55, v63);
          if ( v64 == 255 )
            v64 = 0;
          v65 = v62 < 63;
          v94[v62++] = v64;
        }
        while ( v65 );
        v16 = numModels;
        if ( v60 < 1 )
        {
          v57 = (RwMatrixWeights_0 *)trianglea;
        }
        else
        {
          v66 = 0;
          v67 = 0;
          do
          {
            VertexBoneIndices = j_RpSkinGetVertexBoneIndices(v61);
            v69 = LOBYTE(VertexBoneIndices[v67]);
            v70 = (unsigned __int8 *)&VertexBoneIndices[v67];
            v71 = &v54[v67];
            *(_BYTE *)v71 = v94[v69];
            *((_BYTE *)v71 + 1) = v94[v70[1]];
            *((_BYTE *)v71 + 2) = v94[v70[2]];
            *((_BYTE *)v71 + 3) = v94[v70[3]];
            v72 = &j_RpSkinGetVertexBoneWeights(v61)[v66 / 2];
            ++v67;
            v73 = *(RpTriangle_0 *)&v72->w0;
            v74 = *(RpTriangle_0 *)&v72->w2;
            v75 = &trianglea[v66];
            v66 += 2;
            *v75 = v73;
            v75[1] = v74;
          }
          while ( v60 != v67 );
          v54 += v60;
          v55 = pBoneHier;
          v57 = (RwMatrixWeights_0 *)&trianglea[2 * v60];
          v7 = HIDWORD(numModels);
          v16 = numModels;
        }
        v56 = v88;
      }
      ++v56;
      ++v92;
    }
    while ( v56 != v16 );
  }
}
// 459400: using guessed type char var_60[64];

//----- (004596F8) --------------------------------------------------------
void __fastcall CClothesBuilder::DestroySkinArrays(RwMatrixWeights_0 *pWeights, uint32 *pBones)
{
  if ( pWeights )
    operator delete[](pWeights);
  if ( pBones )
    sub_18E8E0(pBones);
}

//----- (00459716) --------------------------------------------------------
void __fastcall CClothesBuilder::ReleaseGeometry(int32 num)
{
  int32 i; // r4

  for ( i = num; i; --i )
    CStreaming::SetModelIsDeletable(i + 383);
}

//----- (00459734) --------------------------------------------------------
RwTexture_0 *__fastcall CClothesBuilder::PutOnClothes(RwTexture_0 *pDest, RwTexture_0 *source, bool isTattoo)
{
  if ( !source )
    return pDest;
  if ( pDest )
  {
    CClothesBuilder::PlaceTextureOnTopOfTexture(pDest, source, isTattoo);
    return pDest;
  }
  return CClothesBuilder::CopyTexture(source);
}

//----- (00459750) --------------------------------------------------------
RwTexture_0 *__fastcall CClothesBuilder::GetClothesTexture(uint32 key, const unsigned __int8 *name)
{
  const unsigned __int8 *v4; // r0
  uint32 *p_key; // r6
  uint32 v6; // r1
  uint32 *v7; // r0
  uint32 v8; // t1
  const char *v9; // r9
  RwTexture_0 *Texture; // r4
  int v11; // r0
  const char *v12; // r1
  TextureDatabaseRuntime *Database; // r8
  unsigned __int8 *v14; // r0
  unsigned int numEntries; // r10
  const char **dataPtr; // r6
  size_t v17; // r11
  unsigned int v18; // r4
  const char *v19; // r5
  int v20; // r0
  bool v21; // zf
  unsigned __int8 s[256]; // [sp+8h] [bp-120h] BYREF

  if ( !clothesIDs[0].key )
  {
    v4 = clothesIDs[0].name;
    if ( clothesIDs[0].name )
    {
      p_key = &clothesIDs[0].key;
      do
      {
        *p_key = CKeyGen::GetUppercaseKey(v4);
        v4 = (const unsigned __int8 *)p_key[1];
        p_key += 2;
      }
      while ( v4 );
    }
  }
  if ( key )
  {
    v6 = clothesIDs[0].key;
    if ( clothesIDs[0].key )
    {
      v7 = &clothesIDs[1].key;
      while ( v6 != key )
      {
        v8 = *v7;
        v7 += 2;
        v6 = v8;
        if ( !v8 )
          goto LABEL_10;
      }
      v9 = (const char *)*(v7 - 3);
    }
    else
    {
LABEL_10:
      v9 = 0;
    }
    v11 = UseHiDetailPlayer();
    v12 = "playerhi";
    if ( !v11 )
      v12 = "player";
    Database = TextureDatabaseRuntime::GetDatabase(v12);
    TextureDatabaseRuntime::Register(Database);
    if ( name )
    {
      snprintf(s, 0x100u, "%s_%s", v9, (const char *)name);
      v14 = s;
    }
    else
    {
      numEntries = Database->entries.numEntries;
      if ( !numEntries )
      {
LABEL_24:
        Texture = 0;
        goto LABEL_25;
      }
      dataPtr = (const char **)Database->entries.dataPtr;
      v17 = strlen(v9);
      v18 = 0;
      while ( 1 )
      {
        v19 = *dataPtr;
        v20 = strncmp(*dataPtr, v9, v17);
        v21 = v20 == 0;
        if ( !v20 )
          v21 = v19[v17] == 95;
        if ( v21 )
          break;
        ++v18;
        dataPtr = (const char **)((char *)dataPtr + 23);
        if ( v18 >= numEntries )
          goto LABEL_24;
      }
      v14 = (unsigned __int8 *)v19;
    }
    Texture = TextureDatabaseRuntime::GetTexture(v14);
LABEL_25:
    TextureDatabaseRuntime::Unregister(Database);
    return Texture;
  }
  return 0;
}

//----- (00459894) --------------------------------------------------------
RwTexture_0 *__fastcall CClothesBuilder::CopyTexture(RwTexture_0 *pSrc)
{
  RwRaster_0 *raster; // r4
  int cFormat; // r5
  RwRaster_0 *v3; // r5
  RwUInt8 *v4; // r6
  RwTexture_0 *result; // r0

  raster = pSrc->raster;
  cFormat = pSrc->raster->cFormat;
  RwRasterSetKeepCPU(1);
  v3 = RwRasterCreate(raster->width, raster->height, raster->depth, (cFormat << 8) & 0x6F00 | 4);
  RwRasterSetKeepCPU(0);
  v4 = RwRasterLock(raster, 0, 2);
  qmemcpy(RwRasterLock(v3, 0, 1), v4, raster->stride * raster->height);
  RwRasterUnlock(raster);
  RwRasterUnlock(v3);
  result = RwTextureCreate(v3);
  LOBYTE(result->filterAddressing) = 2;
  return result;
}

//----- (00459908) --------------------------------------------------------
void __fastcall CClothesBuilder::BlendTextures(
        RwTexture_0 *pDest,
        RwTexture_0 *pSrc,
        RwTexture_0 *pSrc2,
        float r1,
        float r2,
        float r3,
        int32 numColours,
        RwTexture_0 *pTattoos)
{
  RwRaster_0 *v8; // r6
  RwRaster_0 *v9; // r4
  RwRaster_0 *v10; // r9
  RwRaster_0 *v11; // r5
  RwUInt8 *v12; // r11
  RwUInt8 *v13; // r10
  RwUInt8 *v14; // r8
  RwUInt8 *v15; // r0
  int v16; // r1
  RwUInt8 *v17; // r2
  unsigned int v18; // r5
  unsigned int v19; // r4
  unsigned __int8 *v20; // r2
  __int16 v21; // r12
  unsigned int v22; // s8
  __int16 v23; // lr
  __int16 v24; // r3
  RwUInt8 *v25; // r2
  RwUInt8 *v26; // r5
  unsigned int v27; // s10
  unsigned int v28; // s8
  RwRaster_0 *raster; // [sp+8h] [bp-28h]
  RwRaster_0 *v31; // [sp+10h] [bp-20h]

  v8 = pDest->raster;
  v9 = pSrc2->raster;
  v10 = pSrc->raster;
  v11 = pTattoos->raster;
  CTimer::Suspend();
  v12 = RwRasterLock(v10, 0, 2);
  raster = v9;
  v13 = RwRasterLock(v9, 0, 2);
  v14 = RwRasterLock(v8, 0, 3);
  v31 = v11;
  v15 = RwRasterLock(v11, 0, 2);
  if ( v10->width * v10->height >= 1 )
  {
    v16 = 0;
    do
    {
      v17 = &v13[4 * v16];
      v18 = v17[1];
      v19 = v17[2];
      v20 = &v15[4 * v16];
      v21 = v20[1];
      v22 = v18;
      v23 = v20[2];
      v24 = v20[3];
      v25 = &v14[4 * v16];
      v26 = &v12[4 * v16];
      v27 = (unsigned int)(float)((float)((float)((float)v25[2] * r1) + (float)((float)v26[2] * r2))
                                + (float)((float)v19 * r3));
      v28 = (unsigned int)(float)((float)((float)((float)v25[1] * r1) + (float)((float)v26[1] * r2))
                                + (float)((float)v22 * r3));
      *v25 = (unsigned int)(float)((float)((float)((__int16)(v15[4 * v16]
                                                           - (unsigned __int16)(unsigned int)(float)((float)((float)((float)*v25 * r1) + (float)((float)*v26 * r2)) + (float)((float)v13[4 * v16] * r3)))
                                                 * v24)
                                         / 255.0)
                                 + (float)(unsigned int)(float)((float)((float)((float)*v25 * r1)
                                                                      + (float)((float)*v26 * r2))
                                                              + (float)((float)v13[4 * v16] * r3)));
      ++v16;
      v25[1] = (unsigned int)(float)((float)((float)((__int16)(v21 - v28) * v24) / 255.0) + (float)v28);
      v25[2] = (unsigned int)(float)((float)((float)((__int16)(v23 - v27) * v24) / 255.0) + (float)v27);
    }
    while ( v16 < v10->width * v10->height );
  }
  RwRasterUnlock(v10);
  RwRasterUnlock(raster);
  RwRasterUnlock(v8);
  RwRasterUnlock(v31);
  sub_19F744();
}

//----- (00459AF4) --------------------------------------------------------
void __fastcall CClothesBuilder::BlendTextures(
        RwTexture_0 *pDest,
        RwTexture_0 *pSrc,
        RwTexture_0 *pSrc2,
        float r1,
        float r2,
        float r3,
        int32 numColours)
{
  RwRaster_0 *v9; // r5
  RwRaster_0 *v10; // r6
  RwRaster_0 *v11; // r9
  RwUInt8 *v12; // r8
  RwUInt8 *v13; // r10
  RwUInt8 *v14; // r0
  int v15; // r1
  RwUInt8 *v16; // r6
  RwUInt8 *v17; // r2
  RwUInt8 *v18; // r3
  float v19; // s4
  float v20; // s6
  RwRaster_0 *raster; // [sp+4h] [bp-3Ch]

  v9 = pDest->raster;
  v10 = pSrc2->raster;
  v11 = pSrc->raster;
  CTimer::Suspend();
  v12 = RwRasterLock(v11, 0, 2);
  v13 = v12;
  if ( pSrc != pSrc2 )
    v13 = RwRasterLock(v10, 0, 2);
  raster = v10;
  v14 = RwRasterLock(v9, 0, 3);
  if ( v11->width * v11->height >= 1 )
  {
    v15 = 0;
    do
    {
      v16 = &v12[4 * v15];
      v17 = &v14[4 * v15];
      v18 = &v13[4 * v15];
      v19 = (float)((float)((float)v17[1] * r1) + (float)((float)v16[1] * r2)) + (float)((float)v18[1] * r3);
      v20 = (float)((float)((float)v17[2] * r1) + (float)((float)v16[2] * r2)) + (float)((float)v18[2] * r3);
      *v17 = (unsigned int)(float)((float)((float)((float)*v17 * r1) + (float)((float)*v16 * r2))
                                 + (float)((float)*v18 * r3));
      ++v15;
      v17[1] = (unsigned int)v19;
      v17[2] = (unsigned int)v20;
    }
    while ( v15 < v11->width * v11->height );
  }
  RwRasterUnlock(v11);
  if ( pSrc != pSrc2 )
    RwRasterUnlock(raster);
  RwRasterUnlock(v9);
  sub_19F744();
}

//----- (00459C60) --------------------------------------------------------
void __fastcall CClothesBuilder::BlendTextures(
        RwTexture_0 *pDest,
        RwTexture_0 *pSrc,
        float r1,
        float r2,
        int32 numColours)
{
  RwRaster_0 *raster; // r8
  RwRaster_0 *v8; // r10
  RwUInt8 *v9; // r11
  RwUInt8 *v10; // r0
  int v11; // r1
  RwUInt8 *v12; // r5
  RwUInt8 *v13; // r2
  unsigned __int8 v14; // r3
  float v15; // s6
  float v16; // s8

  raster = pDest->raster;
  v8 = pSrc->raster;
  CTimer::Suspend();
  v9 = RwRasterLock(v8, 0, 2);
  v10 = RwRasterLock(raster, 0, 3);
  if ( v8->width * v8->height >= 1 )
  {
    v11 = 0;
    do
    {
      v12 = &v9[4 * v11];
      v13 = &v10[4 * v11];
      v14 = v10[3];
      v15 = (float)((float)v13[1] * r1) + (float)((float)v12[1] * r2);
      v16 = (float)((float)v13[2] * r1) + (float)((float)v12[2] * r2);
      *v13 = (unsigned int)(float)((float)((float)*v13 * r1) + (float)((float)*v12 * r2));
      ++v11;
      v13[3] = v14;
      v13[1] = (unsigned int)v15;
      v13[2] = (unsigned int)v16;
    }
    while ( v11 < v8->width * v8->height );
  }
  RwRasterUnlock(v8);
  RwRasterUnlock(raster);
  sub_19F744();
}

//----- (00459D5C) --------------------------------------------------------
RpAtomic_0 *__fastcall FindAtomicFromNameCB(RpAtomic_0 *pAtomic, void *pData)
{
  RpAtomic_0 *v2; // r4
  const char *v4; // r6
  const unsigned __int8 *FrameNodeName; // r0

  v2 = pAtomic;
  v4 = *(const char **)pData;
  FrameNodeName = GetFrameNodeName((RwFrame_0 *)pAtomic->object.object.parent);
  if ( !strcasecmp(v4, (const char *)FrameNodeName) )
  {
    *((_DWORD *)pData + 1) = v2;
    return 0;
  }
  return v2;
}

//----- (00459D88) --------------------------------------------------------
RpAtomic_0 *__fastcall GetAtomicWithName(RpClump_0 *pClump, const unsigned __int8 *pName)
{
  const unsigned __int8 *v3; // [sp+0h] [bp-10h] BYREF
  RpAtomic_0 *v4; // [sp+4h] [bp-Ch]

  v3 = pName;
  v4 = 0;
  RpClumpForAllAtomics(pClump, FindAtomicFromNameCB, &v3);
  return v4;
}

//----- (00459DAC) --------------------------------------------------------
void __fastcall CClothesBuilder::StoreBoneArray(RpClump_0 *pClump, int32 num)
{
  int v3; // r5
  RpHAnimHierarchy_0 *HAnimHierarchy; // r0
  int v5; // r3
  int v6; // r1
  RwInt32 v7; // r5
  const char *v8; // [sp+0h] [bp-18h] BYREF
  RpAtomic_0 *atomic; // [sp+4h] [bp-14h]

  v3 = 0;
  v8 = "normal";
  atomic = 0;
  RpClumpForAllAtomics(pClump, FindAtomicFromNameCB, &v8);
  HAnimHierarchy = j_RpSkinAtomicGetHAnimHierarchy(atomic);
  if ( HAnimHierarchy->numNodes < 1 )
    goto LABEL_6;
  v5 = 0;
  v6 = -1;
  do
  {
    gBoneIndices[num][v5] = HAnimHierarchy->pNodeInfo[v5].nodeID;
    v7 = v6 + 2;
    ++v5;
    ++v6;
  }
  while ( v7 < HAnimHierarchy->numNodes );
  if ( v6 <= 62 )
  {
    v3 = v6 + 1;
LABEL_6:
    gBoneIndices[num][v3] = -1;
  }
}

//----- (00459E30) --------------------------------------------------------
RpGeometry_0 *__fastcall CClothesBuilder::BlendGeometry(
        RpClump_0 *pClump,
        const unsigned __int8 *pName1,
        const unsigned __int8 *pName2,
        const unsigned __int8 *pName3,
        float r1,
        float r2,
        float r3)
{
  int v10; // r10
  int v11; // r9
  RpGeometry_0 *v12; // r5
  int v13; // r8
  RpMorphTarget_0 *morphTarget; // r6
  RpSkin_0 *Skin; // r4
  float *p_x; // r0
  float *v17; // r10
  RpGeometry_0 *v18; // r4
  RpMorphTarget_0 *v19; // r6
  RpSkin_0 *v20; // r9
  float *v21; // r0
  float *v22; // r11
  RpGeometry_0 *v23; // r4
  RpMorphTarget_0 *v24; // r6
  RpSkin_0 *v25; // r9
  float *v26; // r0
  float *v27; // r8
  int v28; // r1
  int v29; // r6
  int v30; // r6
  int v31; // r2
  int v32; // r2
  int v33; // r2
  int v34; // r2
  int v35; // r2
  int v36; // r2
  int v37; // r2
  int v38; // r2
  int v39; // r0
  int v40; // r1
  int v41; // r2
  float v42; // s2
  float *v43; // r2
  RwV3d_0 *v44; // r5
  float *v45; // r0
  float *v46; // r1
  float v47; // s6
  float v48; // s2
  float *v49; // r2
  float *v50; // r12
  float *v51; // r0
  float *v52; // r1
  float v53; // s2
  float v54; // s4
  int v55; // r1
  RwMatrixWeights_0 *v56; // r3
  RwUInt32 *v57; // r0
  float v58; // s2
  float v59; // s0
  float v60; // s2
  int v61; // r2
  int v62; // r1
  float v63; // s0
  int v64; // r1
  float v65; // s0
  int v66; // r1
  const RwMatrixWeights_0 *v67; // r1
  unsigned __int8 *v68; // r4
  float v69; // s0
  int v70; // r6
  float v71; // s0
  int v72; // r6
  float v73; // s0
  int v74; // r6
  float v75; // s0
  int v76; // r6
  const RwMatrixWeights_0 *v77; // r9
  unsigned __int8 *v78; // lr
  float v79; // s0
  int v80; // r6
  float v81; // s0
  int v82; // r6
  float v83; // s0
  int v84; // r6
  float v85; // s0
  int v86; // r6
  float v87; // r2
  float v88; // s0
  RwReal v89; // s4
  RwReal v90; // s6
  RpGeometry_0 *v91; // r6
  const RwMatrixWeights_0 *v92; // r0
  float *v94; // [sp+4h] [bp-E4h]
  float *v95; // [sp+8h] [bp-E0h]
  float *v96; // [sp+Ch] [bp-DCh]
  float *v97; // [sp+10h] [bp-D8h]
  int v98; // [sp+14h] [bp-D4h]
  __int64 pData; // [sp+18h] [bp-D0h] BYREF
  __int64 v100; // [sp+20h] [bp-C8h]
  float v101; // [sp+28h] [bp-C0h]
  float v102; // [sp+2Ch] [bp-BCh]
  float v103; // [sp+30h] [bp-B8h]
  float v104; // [sp+34h] [bp-B4h]
  const RwMatrixWeights_0 *VertexBoneWeights; // [sp+40h] [bp-A8h]
  const RwMatrixWeights_0 *v106; // [sp+44h] [bp-A4h]
  const RwMatrixWeights_0 *v107; // [sp+48h] [bp-A0h]
  const RwUInt32 *VertexBoneIndices; // [sp+4Ch] [bp-9Ch]
  const RwUInt32 *v109; // [sp+50h] [bp-98h]
  const RwUInt32 *v110; // [sp+54h] [bp-94h]
  float *p_u; // [sp+58h] [bp-90h]
  float *v112; // [sp+5Ch] [bp-8Ch]
  float *v113; // [sp+60h] [bp-88h]
  float *v114; // [sp+64h] [bp-84h]
  float *v115; // [sp+68h] [bp-80h]
  float *v116; // [sp+6Ch] [bp-7Ch]
  float *v117; // [sp+70h] [bp-78h]
  float *v118; // [sp+74h] [bp-74h]
  float *v119; // [sp+78h] [bp-70h]
  RpGeometry_0 *geometry; // [sp+7Ch] [bp-6Ch]
  RpGeometry_0 *v121; // [sp+80h] [bp-68h]
  RpGeometry_0 *v122; // [sp+84h] [bp-64h]
  int v123; // [sp+88h] [bp-60h] BYREF
  unsigned __int8 v124; // [sp+8Ch] [bp-5Ch]
  unsigned __int8 v125; // [sp+8Dh] [bp-5Bh]
  unsigned __int8 v126; // [sp+8Eh] [bp-5Ah]
  unsigned __int8 v127; // [sp+8Fh] [bp-59h]

  pData = (unsigned int)pName1;
  RpClumpForAllAtomics(pClump, FindAtomicFromNameCB, &pData);
  v10 = HIDWORD(pData);
  pData = (unsigned int)pName2;
  RpClumpForAllAtomics(pClump, FindAtomicFromNameCB, &pData);
  v11 = HIDWORD(pData);
  pData = (unsigned int)pName3;
  RpClumpForAllAtomics(pClump, FindAtomicFromNameCB, &pData);
  v12 = *(RpGeometry_0 **)(v10 + 24);
  geometry = v12;
  v13 = HIDWORD(pData);
  morphTarget = v12->morphTarget;
  Skin = j_RpSkinGeometryGetSkin(v12);
  p_x = &morphTarget->normals->x;
  v17 = &morphTarget->verts->x;
  v117 = v17;
  v114 = p_x;
  p_u = &v12->texCoords[0]->u;
  VertexBoneIndices = j_RpSkinGetVertexBoneIndices(Skin);
  VertexBoneWeights = j_RpSkinGetVertexBoneWeights(Skin);
  v18 = *(RpGeometry_0 **)(v11 + 24);
  v121 = v18;
  v19 = v18->morphTarget;
  v20 = j_RpSkinGeometryGetSkin(v18);
  v21 = &v19->normals->x;
  v22 = &v19->verts->x;
  v118 = v22;
  v115 = v21;
  v112 = &v18->texCoords[0]->u;
  v109 = j_RpSkinGetVertexBoneIndices(v20);
  v106 = j_RpSkinGetVertexBoneWeights(v20);
  v23 = *(RpGeometry_0 **)(v13 + 24);
  v122 = v23;
  v24 = v23->morphTarget;
  v25 = j_RpSkinGeometryGetSkin(v23);
  v26 = &v24->normals->x;
  v27 = &v24->verts->x;
  v119 = v27;
  v116 = v26;
  v113 = &v23->texCoords[0]->u;
  v110 = j_RpSkinGetVertexBoneIndices(v25);
  v107 = j_RpSkinGetVertexBoneWeights(v25);
  RpGeometryLock(v12, 4095);
  if ( v12->numVertices > 0 )
  {
    v28 = 0;
    while ( 1 )
    {
      v98 = v28;
      *v17 = (float)((float)(*v17 * r1) + (float)(*v22 * r2)) + (float)(*v27 * r3);
      v39 = (int)v117;
      v40 = (int)v118;
      v41 = (int)v119;
      v42 = v117[2] * r1;
      v117[1] = (float)((float)(v117[1] * r1) + (float)(v118[1] * r2)) + (float)(v119[1] * r3);
      *(float *)(v39 + 8) = (float)(v42 + (float)(*(float *)(v40 + 8) * r2)) + (float)(*(float *)(v41 + 8) * r3);
      v44 = (RwV3d_0 *)v114;
      v43 = v115;
      v45 = v115;
      v46 = v116;
      v47 = v114[2];
      v48 = v114[1] * r1;
      *v114 = (float)((float)(*v114 * r1) + (float)(*v115 * r2)) + (float)(*v116 * r3);
      v44->y = (float)(v48 + (float)(v45[1] * r2)) + (float)(v46[1] * r3);
      v96 = v45;
      v97 = v46;
      v44->z = (float)((float)(v47 * r1) + (float)(v43[2] * r2)) + (float)(v46[2] * r3);
      RwV3dNormalize(v44, v44);
      v50 = p_u;
      v49 = v112;
      v51 = v112;
      v52 = v113;
      v53 = p_u[1] * r1;
      *p_u = (float)((float)(*p_u * r1) + (float)(*v112 * r2)) + (float)(*v113 * r3);
      v94 = v51;
      v95 = v52;
      v54 = v52[1];
      v55 = 0;
      v50[1] = (float)(v53 + (float)(v49[1] * r2)) + (float)(v54 * r3);
      pData = 0LL;
      v100 = 0LL;
      v56 = (RwMatrixWeights_0 *)VertexBoneWeights;
      v101 = 0.0;
      v123 = 0;
      v57 = (RwUInt32 *)VertexBoneIndices;
      v58 = VertexBoneWeights->w0 * r1;
      v59 = 0.0;
      if ( v58 != 0.0 )
      {
        v59 = v58 + 0.0;
        v55 = *(unsigned __int8 *)VertexBoneIndices;
        HIDWORD(pData) = 0;
        LOBYTE(v123) = v55;
        *(float *)&pData = v58 + 0.0;
      }
      v60 = VertexBoneWeights->w1 * r1;
      if ( v60 != 0.0 )
        break;
LABEL_323:
      v63 = v56->w2 * r1;
      if ( v63 == 0.0 )
        goto LABEL_328;
      v64 = *((unsigned __int8 *)v57 + 2);
      if ( *(float *)&pData == 0.0 )
      {
        v29 = 0;
        goto LABEL_326;
      }
      if ( (unsigned __int8)v123 == v64 )
      {
        v29 = 0;
      }
      else
      {
        if ( *((float *)&pData + 1) == 0.0 )
        {
          v29 = 1;
LABEL_326:
          *((_BYTE *)&v123 + v29) = v64;
          *((_DWORD *)&pData + v29 + 1) = 0;
          goto LABEL_327;
        }
        if ( BYTE1(v123) == v64 )
        {
          v29 = 1;
        }
        else
        {
          if ( *(float *)&v100 == 0.0 )
          {
            v29 = 2;
            goto LABEL_326;
          }
          if ( BYTE2(v123) == v64 )
          {
            v29 = 2;
          }
          else
          {
            if ( *((float *)&v100 + 1) == 0.0 )
            {
              v29 = 3;
              goto LABEL_326;
            }
            if ( HIBYTE(v123) == v64 )
            {
              v29 = 3;
            }
            else
            {
              if ( v101 == 0.0 )
              {
                v29 = 4;
                goto LABEL_326;
              }
              if ( v124 == v64 )
              {
                v29 = 4;
              }
              else
              {
                if ( v102 == 0.0 )
                {
                  v29 = 5;
                  goto LABEL_326;
                }
                if ( v125 == v64 )
                {
                  v29 = 5;
                }
                else
                {
                  if ( v103 == 0.0 )
                  {
                    v29 = 6;
                    goto LABEL_326;
                  }
                  if ( v126 != v64 )
                  {
                    if ( v104 != 0.0 )
                    {
                      v29 = 8;
                      if ( v127 == v64 )
                        v29 = 7;
                      goto LABEL_327;
                    }
                    v29 = 7;
                    goto LABEL_326;
                  }
                  v29 = 6;
                }
              }
            }
          }
        }
      }
LABEL_327:
      *((float *)&pData + v29) = v63 + *((float *)&pData + v29);
LABEL_328:
      v65 = v56->w3 * r1;
      if ( v65 == 0.0 )
        goto LABEL_333;
      v66 = *((unsigned __int8 *)v57 + 3);
      if ( *(float *)&pData == 0.0 )
      {
        v30 = 0;
        goto LABEL_331;
      }
      if ( (unsigned __int8)v123 == v66 )
      {
        v30 = 0;
      }
      else
      {
        if ( *((float *)&pData + 1) == 0.0 )
        {
          v30 = 1;
LABEL_331:
          *((_BYTE *)&v123 + v30) = v66;
          *((_DWORD *)&pData + v30 + 1) = 0;
          goto LABEL_332;
        }
        if ( BYTE1(v123) == v66 )
        {
          v30 = 1;
        }
        else
        {
          if ( *(float *)&v100 == 0.0 )
          {
            v30 = 2;
            goto LABEL_331;
          }
          if ( BYTE2(v123) == v66 )
          {
            v30 = 2;
          }
          else
          {
            if ( *((float *)&v100 + 1) == 0.0 )
            {
              v30 = 3;
              goto LABEL_331;
            }
            if ( HIBYTE(v123) == v66 )
            {
              v30 = 3;
            }
            else
            {
              if ( v101 == 0.0 )
              {
                v30 = 4;
                goto LABEL_331;
              }
              if ( v124 == v66 )
              {
                v30 = 4;
              }
              else
              {
                if ( v102 == 0.0 )
                {
                  v30 = 5;
                  goto LABEL_331;
                }
                if ( v125 == v66 )
                {
                  v30 = 5;
                }
                else
                {
                  if ( v103 == 0.0 )
                  {
                    v30 = 6;
                    goto LABEL_331;
                  }
                  if ( v126 != v66 )
                  {
                    if ( v104 != 0.0 )
                    {
                      v30 = 8;
                      if ( v127 == v66 )
                        v30 = 7;
                      goto LABEL_332;
                    }
                    v30 = 7;
                    goto LABEL_331;
                  }
                  v30 = 6;
                }
              }
            }
          }
        }
      }
LABEL_332:
      *((float *)&pData + v30) = v65 + *((float *)&pData + v30);
LABEL_333:
      v67 = v106;
      v68 = (unsigned __int8 *)v109;
      v69 = v106->w0 * r2;
      if ( v69 == 0.0 )
        goto LABEL_338;
      v70 = *(unsigned __int8 *)v109;
      if ( *(float *)&pData == 0.0 )
      {
        v31 = 0;
        goto LABEL_336;
      }
      if ( (unsigned __int8)v123 == v70 )
      {
        v31 = 0;
      }
      else
      {
        if ( *((float *)&pData + 1) == 0.0 )
        {
          v31 = 1;
LABEL_336:
          *((_BYTE *)&v123 + v31) = v70;
          *((_DWORD *)&pData + v31 + 1) = 0;
          goto LABEL_337;
        }
        if ( BYTE1(v123) == v70 )
        {
          v31 = 1;
        }
        else
        {
          if ( *(float *)&v100 == 0.0 )
          {
            v31 = 2;
            goto LABEL_336;
          }
          if ( BYTE2(v123) == v70 )
          {
            v31 = 2;
          }
          else
          {
            if ( *((float *)&v100 + 1) == 0.0 )
            {
              v31 = 3;
              goto LABEL_336;
            }
            if ( HIBYTE(v123) == v70 )
            {
              v31 = 3;
            }
            else
            {
              if ( v101 == 0.0 )
              {
                v31 = 4;
                goto LABEL_336;
              }
              if ( v124 == v70 )
              {
                v31 = 4;
              }
              else
              {
                if ( v102 == 0.0 )
                {
                  v31 = 5;
                  goto LABEL_336;
                }
                if ( v125 == v70 )
                {
                  v31 = 5;
                }
                else
                {
                  if ( v103 == 0.0 )
                  {
                    v31 = 6;
                    goto LABEL_336;
                  }
                  if ( v126 != v70 )
                  {
                    if ( v104 != 0.0 )
                    {
                      v31 = 8;
                      if ( v127 == v70 )
                        v31 = 7;
                      goto LABEL_337;
                    }
                    v31 = 7;
                    goto LABEL_336;
                  }
                  v31 = 6;
                }
              }
            }
          }
        }
      }
LABEL_337:
      *((float *)&pData + v31) = v69 + *((float *)&pData + v31);
LABEL_338:
      v71 = v67->w1 * r2;
      if ( v71 == 0.0 )
        goto LABEL_343;
      v72 = v68[1];
      if ( *(float *)&pData == 0.0 )
      {
        v32 = 0;
        goto LABEL_341;
      }
      if ( (unsigned __int8)v123 == v72 )
      {
        v32 = 0;
      }
      else
      {
        if ( *((float *)&pData + 1) == 0.0 )
        {
          v32 = 1;
LABEL_341:
          *((_BYTE *)&v123 + v32) = v72;
          *((_DWORD *)&pData + v32 + 1) = 0;
          goto LABEL_342;
        }
        if ( BYTE1(v123) == v72 )
        {
          v32 = 1;
        }
        else
        {
          if ( *(float *)&v100 == 0.0 )
          {
            v32 = 2;
            goto LABEL_341;
          }
          if ( BYTE2(v123) == v72 )
          {
            v32 = 2;
          }
          else
          {
            if ( *((float *)&v100 + 1) == 0.0 )
            {
              v32 = 3;
              goto LABEL_341;
            }
            if ( HIBYTE(v123) == v72 )
            {
              v32 = 3;
            }
            else
            {
              if ( v101 == 0.0 )
              {
                v32 = 4;
                goto LABEL_341;
              }
              if ( v124 == v72 )
              {
                v32 = 4;
              }
              else
              {
                if ( v102 == 0.0 )
                {
                  v32 = 5;
                  goto LABEL_341;
                }
                if ( v125 == v72 )
                {
                  v32 = 5;
                }
                else
                {
                  if ( v103 == 0.0 )
                  {
                    v32 = 6;
                    goto LABEL_341;
                  }
                  if ( v126 != v72 )
                  {
                    if ( v104 != 0.0 )
                    {
                      v32 = 8;
                      if ( v127 == v72 )
                        v32 = 7;
                      goto LABEL_342;
                    }
                    v32 = 7;
                    goto LABEL_341;
                  }
                  v32 = 6;
                }
              }
            }
          }
        }
      }
LABEL_342:
      *((float *)&pData + v32) = v71 + *((float *)&pData + v32);
LABEL_343:
      v73 = v67->w2 * r2;
      if ( v73 == 0.0 )
        goto LABEL_348;
      v74 = v68[2];
      if ( *(float *)&pData == 0.0 )
      {
        v33 = 0;
        goto LABEL_346;
      }
      if ( (unsigned __int8)v123 == v74 )
      {
        v33 = 0;
      }
      else
      {
        if ( *((float *)&pData + 1) == 0.0 )
        {
          v33 = 1;
LABEL_346:
          *((_BYTE *)&v123 + v33) = v74;
          *((_DWORD *)&pData + v33 + 1) = 0;
          goto LABEL_347;
        }
        if ( BYTE1(v123) == v74 )
        {
          v33 = 1;
        }
        else
        {
          if ( *(float *)&v100 == 0.0 )
          {
            v33 = 2;
            goto LABEL_346;
          }
          if ( BYTE2(v123) == v74 )
          {
            v33 = 2;
          }
          else
          {
            if ( *((float *)&v100 + 1) == 0.0 )
            {
              v33 = 3;
              goto LABEL_346;
            }
            if ( HIBYTE(v123) == v74 )
            {
              v33 = 3;
            }
            else
            {
              if ( v101 == 0.0 )
              {
                v33 = 4;
                goto LABEL_346;
              }
              if ( v124 == v74 )
              {
                v33 = 4;
              }
              else
              {
                if ( v102 == 0.0 )
                {
                  v33 = 5;
                  goto LABEL_346;
                }
                if ( v125 == v74 )
                {
                  v33 = 5;
                }
                else
                {
                  if ( v103 == 0.0 )
                  {
                    v33 = 6;
                    goto LABEL_346;
                  }
                  if ( v126 != v74 )
                  {
                    if ( v104 != 0.0 )
                    {
                      v33 = 8;
                      if ( v127 == v74 )
                        v33 = 7;
                      goto LABEL_347;
                    }
                    v33 = 7;
                    goto LABEL_346;
                  }
                  v33 = 6;
                }
              }
            }
          }
        }
      }
LABEL_347:
      *((float *)&pData + v33) = v73 + *((float *)&pData + v33);
LABEL_348:
      v75 = v67->w3 * r2;
      if ( v75 == 0.0 )
        goto LABEL_353;
      v76 = v68[3];
      if ( *(float *)&pData == 0.0 )
      {
        v34 = 0;
        goto LABEL_351;
      }
      if ( (unsigned __int8)v123 == v76 )
      {
        v34 = 0;
      }
      else
      {
        if ( *((float *)&pData + 1) == 0.0 )
        {
          v34 = 1;
LABEL_351:
          *((_BYTE *)&v123 + v34) = v76;
          *((_DWORD *)&pData + v34 + 1) = 0;
          goto LABEL_352;
        }
        if ( BYTE1(v123) == v76 )
        {
          v34 = 1;
        }
        else
        {
          if ( *(float *)&v100 == 0.0 )
          {
            v34 = 2;
            goto LABEL_351;
          }
          if ( BYTE2(v123) == v76 )
          {
            v34 = 2;
          }
          else
          {
            if ( *((float *)&v100 + 1) == 0.0 )
            {
              v34 = 3;
              goto LABEL_351;
            }
            if ( HIBYTE(v123) == v76 )
            {
              v34 = 3;
            }
            else
            {
              if ( v101 == 0.0 )
              {
                v34 = 4;
                goto LABEL_351;
              }
              if ( v124 == v76 )
              {
                v34 = 4;
              }
              else
              {
                if ( v102 == 0.0 )
                {
                  v34 = 5;
                  goto LABEL_351;
                }
                if ( v125 == v76 )
                {
                  v34 = 5;
                }
                else
                {
                  if ( v103 == 0.0 )
                  {
                    v34 = 6;
                    goto LABEL_351;
                  }
                  if ( v126 != v76 )
                  {
                    if ( v104 != 0.0 )
                    {
                      v34 = 8;
                      if ( v127 == v76 )
                        v34 = 7;
                      goto LABEL_352;
                    }
                    v34 = 7;
                    goto LABEL_351;
                  }
                  v34 = 6;
                }
              }
            }
          }
        }
      }
LABEL_352:
      *((float *)&pData + v34) = v75 + *((float *)&pData + v34);
LABEL_353:
      v77 = v107;
      v78 = (unsigned __int8 *)v110;
      v79 = v107->w0 * r3;
      if ( v79 == 0.0 )
        goto LABEL_358;
      v80 = *(unsigned __int8 *)v110;
      if ( *(float *)&pData == 0.0 )
      {
        v35 = 0;
        goto LABEL_356;
      }
      if ( (unsigned __int8)v123 == v80 )
      {
        v35 = 0;
      }
      else
      {
        if ( *((float *)&pData + 1) == 0.0 )
        {
          v35 = 1;
LABEL_356:
          *((_BYTE *)&v123 + v35) = v80;
          *((_DWORD *)&pData + v35 + 1) = 0;
          goto LABEL_357;
        }
        if ( BYTE1(v123) == v80 )
        {
          v35 = 1;
        }
        else
        {
          if ( *(float *)&v100 == 0.0 )
          {
            v35 = 2;
            goto LABEL_356;
          }
          if ( BYTE2(v123) == v80 )
          {
            v35 = 2;
          }
          else
          {
            if ( *((float *)&v100 + 1) == 0.0 )
            {
              v35 = 3;
              goto LABEL_356;
            }
            if ( HIBYTE(v123) == v80 )
            {
              v35 = 3;
            }
            else
            {
              if ( v101 == 0.0 )
              {
                v35 = 4;
                goto LABEL_356;
              }
              if ( v124 == v80 )
              {
                v35 = 4;
              }
              else
              {
                if ( v102 == 0.0 )
                {
                  v35 = 5;
                  goto LABEL_356;
                }
                if ( v125 == v80 )
                {
                  v35 = 5;
                }
                else
                {
                  if ( v103 == 0.0 )
                  {
                    v35 = 6;
                    goto LABEL_356;
                  }
                  if ( v126 != v80 )
                  {
                    if ( v104 != 0.0 )
                    {
                      v35 = 8;
                      if ( v127 == v80 )
                        v35 = 7;
                      goto LABEL_357;
                    }
                    v35 = 7;
                    goto LABEL_356;
                  }
                  v35 = 6;
                }
              }
            }
          }
        }
      }
LABEL_357:
      *((float *)&pData + v35) = v79 + *((float *)&pData + v35);
LABEL_358:
      v81 = v77->w1 * r3;
      if ( v81 == 0.0 )
        goto LABEL_363;
      v82 = v78[1];
      if ( *(float *)&pData == 0.0 )
      {
        v36 = 0;
        goto LABEL_361;
      }
      if ( (unsigned __int8)v123 == v82 )
      {
        v36 = 0;
      }
      else
      {
        if ( *((float *)&pData + 1) == 0.0 )
        {
          v36 = 1;
LABEL_361:
          *((_BYTE *)&v123 + v36) = v82;
          *((_DWORD *)&pData + v36 + 1) = 0;
          goto LABEL_362;
        }
        if ( BYTE1(v123) == v82 )
        {
          v36 = 1;
        }
        else
        {
          if ( *(float *)&v100 == 0.0 )
          {
            v36 = 2;
            goto LABEL_361;
          }
          if ( BYTE2(v123) == v82 )
          {
            v36 = 2;
          }
          else
          {
            if ( *((float *)&v100 + 1) == 0.0 )
            {
              v36 = 3;
              goto LABEL_361;
            }
            if ( HIBYTE(v123) == v82 )
            {
              v36 = 3;
            }
            else
            {
              if ( v101 == 0.0 )
              {
                v36 = 4;
                goto LABEL_361;
              }
              if ( v124 == v82 )
              {
                v36 = 4;
              }
              else
              {
                if ( v102 == 0.0 )
                {
                  v36 = 5;
                  goto LABEL_361;
                }
                if ( v125 == v82 )
                {
                  v36 = 5;
                }
                else
                {
                  if ( v103 == 0.0 )
                  {
                    v36 = 6;
                    goto LABEL_361;
                  }
                  if ( v126 != v82 )
                  {
                    if ( v104 != 0.0 )
                    {
                      v36 = 8;
                      if ( v127 == v82 )
                        v36 = 7;
                      goto LABEL_362;
                    }
                    v36 = 7;
                    goto LABEL_361;
                  }
                  v36 = 6;
                }
              }
            }
          }
        }
      }
LABEL_362:
      *((float *)&pData + v36) = v81 + *((float *)&pData + v36);
LABEL_363:
      v83 = v77->w2 * r3;
      if ( v83 == 0.0 )
        goto LABEL_368;
      v84 = v78[2];
      if ( *(float *)&pData == 0.0 )
      {
        v37 = 0;
        goto LABEL_366;
      }
      if ( (unsigned __int8)v123 == v84 )
      {
        v37 = 0;
      }
      else
      {
        if ( *((float *)&pData + 1) == 0.0 )
        {
          v37 = 1;
LABEL_366:
          *((_BYTE *)&v123 + v37) = v84;
          *((_DWORD *)&pData + v37 + 1) = 0;
          goto LABEL_367;
        }
        if ( BYTE1(v123) == v84 )
        {
          v37 = 1;
        }
        else
        {
          if ( *(float *)&v100 == 0.0 )
          {
            v37 = 2;
            goto LABEL_366;
          }
          if ( BYTE2(v123) == v84 )
          {
            v37 = 2;
          }
          else
          {
            if ( *((float *)&v100 + 1) == 0.0 )
            {
              v37 = 3;
              goto LABEL_366;
            }
            if ( HIBYTE(v123) == v84 )
            {
              v37 = 3;
            }
            else
            {
              if ( v101 == 0.0 )
              {
                v37 = 4;
                goto LABEL_366;
              }
              if ( v124 == v84 )
              {
                v37 = 4;
              }
              else
              {
                if ( v102 == 0.0 )
                {
                  v37 = 5;
                  goto LABEL_366;
                }
                if ( v125 == v84 )
                {
                  v37 = 5;
                }
                else
                {
                  if ( v103 == 0.0 )
                  {
                    v37 = 6;
                    goto LABEL_366;
                  }
                  if ( v126 != v84 )
                  {
                    if ( v104 != 0.0 )
                    {
                      v37 = 8;
                      if ( v127 == v84 )
                        v37 = 7;
                      goto LABEL_367;
                    }
                    v37 = 7;
                    goto LABEL_366;
                  }
                  v37 = 6;
                }
              }
            }
          }
        }
      }
LABEL_367:
      *((float *)&pData + v37) = v83 + *((float *)&pData + v37);
LABEL_368:
      v85 = v77->w3 * r3;
      if ( v85 != 0.0 )
      {
        v86 = v78[3];
        if ( *(float *)&pData == 0.0 )
        {
          v38 = 0;
LABEL_371:
          *((_BYTE *)&v123 + v38) = v86;
          *((_DWORD *)&pData + v38 + 1) = 0;
        }
        else if ( (unsigned __int8)v123 == v86 )
        {
          v38 = 0;
        }
        else
        {
          if ( *((float *)&pData + 1) == 0.0 )
          {
            v38 = 1;
            goto LABEL_371;
          }
          if ( BYTE1(v123) == v86 )
          {
            v38 = 1;
          }
          else
          {
            if ( *(float *)&v100 == 0.0 )
            {
              v38 = 2;
              goto LABEL_371;
            }
            if ( BYTE2(v123) == v86 )
            {
              v38 = 2;
            }
            else
            {
              if ( *((float *)&v100 + 1) == 0.0 )
              {
                v38 = 3;
                goto LABEL_371;
              }
              if ( HIBYTE(v123) == v86 )
              {
                v38 = 3;
              }
              else
              {
                if ( v101 == 0.0 )
                {
                  v38 = 4;
                  goto LABEL_371;
                }
                if ( v124 == v86 )
                {
                  v38 = 4;
                }
                else
                {
                  if ( v102 == 0.0 )
                  {
                    v38 = 5;
                    goto LABEL_371;
                  }
                  if ( v125 == v86 )
                  {
                    v38 = 5;
                  }
                  else
                  {
                    if ( v103 == 0.0 )
                    {
                      v38 = 6;
                      goto LABEL_371;
                    }
                    if ( v126 == v86 )
                    {
                      v38 = 6;
                    }
                    else
                    {
                      if ( v104 == 0.0 )
                      {
                        v38 = 7;
                        goto LABEL_371;
                      }
                      v38 = 8;
                      if ( v127 == v86 )
                        v38 = 7;
                    }
                  }
                }
              }
            }
          }
        }
        *((float *)&pData + v38) = v85 + *((float *)&pData + v38);
      }
      *(_BYTE *)v57 = v123;
      LODWORD(v56->w0) = pData;
      *((_BYTE *)v57 + 1) = BYTE1(v123);
      v56->w1 = *((RwReal *)&pData + 1);
      *((_BYTE *)v57 + 2) = BYTE2(v123);
      LODWORD(v56->w2) = v100;
      *((_BYTE *)v57 + 3) = HIBYTE(v123);
      v87 = *((float *)&v100 + 1);
      v56->w3 = *((RwReal *)&v100 + 1);
      if ( v101 != 0.0 )
      {
        v88 = (float)((float)(*(float *)&pData + *((float *)&pData + 1)) + *(float *)&v100) + *((float *)&v100 + 1);
        v89 = v56->w1 / v88;
        v90 = v56->w2 / v88;
        v56->w0 = v56->w0 / v88;
        v56->w1 = v89;
        v56->w2 = v90;
        v56->w3 = v87 / v88;
      }
      VertexBoneIndices = v57 + 1;
      v22 = v118 + 3;
      v17 = v117 + 3;
      v114 = &v44[1].x;
      v115 = v96 + 3;
      v109 = (const RwUInt32 *)(v68 + 4);
      v116 = v97 + 3;
      p_u = v50 + 2;
      v112 = v94 + 2;
      v27 = v119 + 3;
      v110 = (const RwUInt32 *)(v78 + 4);
      v91 = geometry;
      VertexBoneWeights = v56 + 1;
      v92 = v67 + 1;
      v117 += 3;
      v12 = geometry;
      v118 += 3;
      v28 = v98 + 1;
      v106 = v92;
      v119 += 3;
      v113 = v95 + 2;
      v107 = v77 + 1;
      if ( v98 + 1 >= geometry->numVertices )
        goto LABEL_378;
    }
    v61 = *((unsigned __int8 *)VertexBoneIndices + 1);
    if ( v59 == 0.0 )
    {
      v62 = 0;
    }
    else
    {
      if ( v55 == v61 )
      {
        v62 = 0;
LABEL_322:
        *(float *)((unsigned int)&pData | (4 * v62)) = v60 + v59;
        goto LABEL_323;
      }
      v62 = 1;
      v59 = 0.0;
    }
    *(_BYTE *)((unsigned int)&v123 | v62) = v61;
    *(_DWORD *)&byte_4[(unsigned int)&pData | (4 * v62)] = 0;
    goto LABEL_322;
  }
  v91 = geometry;
LABEL_378:
  RpGeometryUnlock(v12);
  _rpGeometryAddRef(v91);
  return v91;
}

//----- (0045AE68) --------------------------------------------------------
RpGeometry_0 *__fastcall CClothesBuilder::BlendGeometry(
        RpClump_0 *pClump,
        const unsigned __int8 *pName1,
        const unsigned __int8 *pName2,
        float r1,
        float r2)
{
  int v7; // r4
  RpGeometry_0 *v8; // r11
  int v9; // r8
  RpMorphTarget_0 *morphTarget; // r4
  RpSkin_0 *Skin; // r5
  float *p_u; // r10
  RpGeometry_0 *v13; // r5
  RpMorphTarget_0 *v14; // r4
  RpSkin_0 *v15; // r8
  float *v16; // r9
  const RwMatrixWeights_0 *v17; // r5
  const RwMatrixWeights_0 *v18; // r4
  int v19; // r6
  int v20; // r11
  float v21; // s16
  int v22; // r1
  int v23; // r3
  int v24; // r3
  int v25; // r3
  int v26; // r4
  int v27; // r4
  int v28; // r3
  const RwMatrixWeights_0 *v29; // r1
  const RwMatrixWeights_0 *v30; // r1
  const RwMatrixWeights_0 *v31; // r1
  const RwMatrixWeights_0 *v32; // lr
  float *p_x; // r1
  float z; // s6
  float v35; // s2
  float *v36; // r0
  float y; // s4
  float v38; // s6
  float v39; // s4
  float *p_w0; // r0
  unsigned __int8 *v41; // r8
  float v42; // s2
  float v43; // s0
  unsigned __int8 v44; // r2
  float v45; // s2
  int v46; // r3
  int v47; // r2
  float v48; // s0
  int v49; // r2
  float v50; // s0
  int v51; // r2
  float v52; // s0
  int v53; // r2
  float v54; // s0
  unsigned __int8 *v55; // r12
  int v56; // r3
  float *v57; // r3
  float v58; // s0
  int v59; // r3
  float *v60; // r3
  float v61; // s0
  int v62; // r2
  float v63; // r1
  float v64; // s0
  const RwMatrixWeights_0 *VertexBoneWeights; // [sp+4h] [bp-ACh]
  RwV3d_0 *v67; // [sp+8h] [bp-A8h]
  RwV3d_0 *v68; // [sp+Ch] [bp-A4h]
  const RwUInt32 *VertexBoneIndices; // [sp+10h] [bp-A0h]
  RwV3d_0 *normals; // [sp+14h] [bp-9Ch]
  RwV3d_0 *verts; // [sp+18h] [bp-98h]
  RpGeometry_0 *geometry; // [sp+1Ch] [bp-94h]
  const RwUInt32 *v73; // [sp+20h] [bp-90h]
  int v75; // [sp+24h] [bp-8Ch]
  __int64 pData; // [sp+28h] [bp-88h] BYREF
  __int64 v77; // [sp+30h] [bp-80h]
  float v78; // [sp+38h] [bp-78h]
  float v79; // [sp+3Ch] [bp-74h]
  float v80; // [sp+40h] [bp-70h]
  float v81; // [sp+44h] [bp-6Ch]
  RpGeometry_0 *v82; // [sp+50h] [bp-60h]
  RpGeometry_0 *v83; // [sp+54h] [bp-5Ch]
  unsigned __int8 v84; // [sp+5Bh] [bp-55h]
  unsigned __int8 v85; // [sp+5Ch] [bp-54h]
  unsigned __int8 v86; // [sp+5Dh] [bp-53h]
  unsigned __int8 v87; // [sp+5Eh] [bp-52h]
  unsigned __int8 v88; // [sp+5Fh] [bp-51h]
  unsigned __int8 v89; // [sp+60h] [bp-50h]
  unsigned __int8 v90; // [sp+61h] [bp-4Fh]
  unsigned __int8 v91; // [sp+62h] [bp-4Eh]

  pData = (unsigned int)pName1;
  RpClumpForAllAtomics(pClump, FindAtomicFromNameCB, &pData);
  v7 = HIDWORD(pData);
  pData = (unsigned int)pName2;
  RpClumpForAllAtomics(pClump, FindAtomicFromNameCB, &pData);
  v8 = *(RpGeometry_0 **)(v7 + 24);
  v82 = v8;
  v9 = HIDWORD(pData);
  morphTarget = v8->morphTarget;
  Skin = j_RpSkinGeometryGetSkin(v8);
  verts = morphTarget->verts;
  normals = morphTarget->normals;
  p_u = &v8->texCoords[0]->u;
  VertexBoneIndices = j_RpSkinGetVertexBoneIndices(Skin);
  VertexBoneWeights = j_RpSkinGetVertexBoneWeights(Skin);
  v13 = *(RpGeometry_0 **)(v9 + 24);
  v83 = v13;
  v14 = v13->morphTarget;
  v15 = j_RpSkinGeometryGetSkin(v13);
  v68 = v14->verts;
  v67 = v14->normals;
  v16 = &v13->texCoords[0]->u;
  v73 = j_RpSkinGetVertexBoneIndices(v15);
  v17 = j_RpSkinGetVertexBoneWeights(v15);
  RpGeometryLock(v8, 4095);
  geometry = v8;
  if ( v8->numVertices >= 1 )
  {
    v18 = VertexBoneWeights;
    v19 = 0;
    v20 = 0;
    v21 = r1;
    v22 = 0;
    while ( 1 )
    {
      v75 = v22;
      p_x = &verts[v19].x;
      z = verts[v19].z;
      v35 = verts[v19].y * v21;
      *p_x = (float)(verts[v19].x * v21) + (float)(v68[v19].x * r2);
      p_x[1] = v35 + (float)(v68[v19].y * r2);
      p_x[2] = (float)(z * v21) + (float)(v68[v19].z * r2);
      v36 = &normals[v19].x;
      y = normals[v19].y;
      v38 = normals[v19].z;
      *v36 = (float)(normals[v19].x * v21) + (float)(v67[v19].x * r2);
      v36[1] = (float)(y * v21) + (float)(v67[v19].y * r2);
      v36[2] = (float)(v38 * v21) + (float)(v67[v19].z * r2);
      RwV3dNormalize(&normals[v19], &normals[v19]);
      v39 = p_u[1];
      *p_u = (float)(*p_u * v21) + (float)(*v16 * r2);
      p_u[1] = (float)(v39 * v21) + (float)(v16[1] * r2);
      pData = 0LL;
      v77 = 0LL;
      v78 = 0.0;
      p_w0 = &v18[v20].w0;
      v41 = (unsigned __int8 *)&VertexBoneIndices[v20];
      v42 = *p_w0 * v21;
      v43 = 0.0;
      if ( v42 != 0.0 )
      {
        v43 = v42 + 0.0;
        v44 = *v41;
        HIDWORD(pData) = 0;
        v84 = v44;
        *(float *)&pData = v42 + 0.0;
      }
      v45 = p_w0[1] * v21;
      if ( v45 != 0.0 )
        break;
LABEL_199:
      v48 = p_w0[2] * v21;
      if ( v48 == 0.0 )
        goto LABEL_205;
      v49 = v41[2];
      if ( *(float *)&pData == 0.0 )
      {
        v29 = v18;
        v23 = 0;
LABEL_202:
        *(&v84 + v23) = v49;
        *((_DWORD *)&pData + v23 + 1) = 0;
        goto LABEL_203;
      }
      if ( v84 == v49 )
      {
        v23 = 0;
      }
      else
      {
        if ( *((float *)&pData + 1) == 0.0 )
        {
          v29 = v18;
          v23 = 1;
          goto LABEL_202;
        }
        if ( v85 == v49 )
        {
          v23 = 1;
        }
        else
        {
          if ( *(float *)&v77 == 0.0 )
          {
            v29 = v18;
            v23 = 2;
            goto LABEL_202;
          }
          if ( v86 == v49 )
          {
            v23 = 2;
          }
          else
          {
            if ( *((float *)&v77 + 1) == 0.0 )
            {
              v29 = v18;
              v23 = 3;
              goto LABEL_202;
            }
            if ( v87 == v49 )
            {
              v23 = 3;
            }
            else
            {
              if ( v78 == 0.0 )
              {
                v29 = v18;
                v23 = 4;
                goto LABEL_202;
              }
              if ( v88 == v49 )
              {
                v23 = 4;
              }
              else
              {
                if ( v79 == 0.0 )
                {
                  v29 = v18;
                  v23 = 5;
                  goto LABEL_202;
                }
                if ( v89 == v49 )
                {
                  v23 = 5;
                }
                else
                {
                  if ( v80 == 0.0 )
                  {
                    v29 = v18;
                    v23 = 6;
                    goto LABEL_202;
                  }
                  if ( v90 != v49 )
                  {
                    v29 = v18;
                    if ( v81 == 0.0 )
                    {
                      v23 = 7;
                      goto LABEL_202;
                    }
                    v23 = 8;
                    if ( v91 == v49 )
                      v23 = 7;
LABEL_203:
                    v18 = v29;
                    goto LABEL_204;
                  }
                  v23 = 6;
                }
              }
            }
          }
        }
      }
LABEL_204:
      *((float *)&pData + v23) = v48 + *((float *)&pData + v23);
LABEL_205:
      v50 = p_w0[3] * v21;
      if ( v50 == 0.0 )
        goto LABEL_211;
      v51 = v41[3];
      if ( *(float *)&pData == 0.0 )
      {
        v30 = v18;
        v24 = 0;
LABEL_208:
        *(&v84 + v24) = v51;
        *((_DWORD *)&pData + v24 + 1) = 0;
        goto LABEL_209;
      }
      if ( v84 == v51 )
      {
        v24 = 0;
      }
      else
      {
        if ( *((float *)&pData + 1) == 0.0 )
        {
          v30 = v18;
          v24 = 1;
          goto LABEL_208;
        }
        if ( v85 == v51 )
        {
          v24 = 1;
        }
        else
        {
          if ( *(float *)&v77 == 0.0 )
          {
            v30 = v18;
            v24 = 2;
            goto LABEL_208;
          }
          if ( v86 == v51 )
          {
            v24 = 2;
          }
          else
          {
            if ( *((float *)&v77 + 1) == 0.0 )
            {
              v30 = v18;
              v24 = 3;
              goto LABEL_208;
            }
            if ( v87 == v51 )
            {
              v24 = 3;
            }
            else
            {
              if ( v78 == 0.0 )
              {
                v30 = v18;
                v24 = 4;
                goto LABEL_208;
              }
              if ( v88 == v51 )
              {
                v24 = 4;
              }
              else
              {
                if ( v79 == 0.0 )
                {
                  v30 = v18;
                  v24 = 5;
                  goto LABEL_208;
                }
                if ( v89 == v51 )
                {
                  v24 = 5;
                }
                else
                {
                  if ( v80 == 0.0 )
                  {
                    v30 = v18;
                    v24 = 6;
                    goto LABEL_208;
                  }
                  if ( v90 != v51 )
                  {
                    v30 = v18;
                    if ( v81 == 0.0 )
                    {
                      v24 = 7;
                      goto LABEL_208;
                    }
                    v24 = 8;
                    if ( v91 == v51 )
                      v24 = 7;
LABEL_209:
                    v18 = v30;
                    goto LABEL_210;
                  }
                  v24 = 6;
                }
              }
            }
          }
        }
      }
LABEL_210:
      *((float *)&pData + v24) = v50 + *((float *)&pData + v24);
LABEL_211:
      v52 = v17->w0 * r2;
      if ( v52 == 0.0 )
        goto LABEL_217;
      v53 = LOBYTE(v73[v20]);
      if ( *(float *)&pData == 0.0 )
      {
        v31 = v18;
        v25 = 0;
LABEL_214:
        *(&v84 + v25) = v53;
        *((_DWORD *)&pData + v25 + 1) = 0;
        goto LABEL_215;
      }
      if ( v84 == v53 )
      {
        v25 = 0;
      }
      else
      {
        if ( *((float *)&pData + 1) == 0.0 )
        {
          v31 = v18;
          v25 = 1;
          goto LABEL_214;
        }
        if ( v85 == v53 )
        {
          v25 = 1;
        }
        else
        {
          if ( *(float *)&v77 == 0.0 )
          {
            v31 = v18;
            v25 = 2;
            goto LABEL_214;
          }
          if ( v86 == v53 )
          {
            v25 = 2;
          }
          else
          {
            if ( *((float *)&v77 + 1) == 0.0 )
            {
              v31 = v18;
              v25 = 3;
              goto LABEL_214;
            }
            if ( v87 == v53 )
            {
              v25 = 3;
            }
            else
            {
              if ( v78 == 0.0 )
              {
                v31 = v18;
                v25 = 4;
                goto LABEL_214;
              }
              if ( v88 == v53 )
              {
                v25 = 4;
              }
              else
              {
                if ( v79 == 0.0 )
                {
                  v31 = v18;
                  v25 = 5;
                  goto LABEL_214;
                }
                if ( v89 == v53 )
                {
                  v25 = 5;
                }
                else
                {
                  if ( v80 == 0.0 )
                  {
                    v31 = v18;
                    v25 = 6;
                    goto LABEL_214;
                  }
                  if ( v90 != v53 )
                  {
                    v31 = v18;
                    if ( v81 == 0.0 )
                    {
                      v25 = 7;
                      goto LABEL_214;
                    }
                    v25 = 8;
                    if ( v91 == v53 )
                      v25 = 7;
LABEL_215:
                    v18 = v31;
                    goto LABEL_216;
                  }
                  v25 = 6;
                }
              }
            }
          }
        }
      }
LABEL_216:
      *((float *)&pData + v25) = v52 + *((float *)&pData + v25);
LABEL_217:
      v54 = v17->w1 * r2;
      v55 = (unsigned __int8 *)&v73[v20];
      if ( v54 == 0.0 )
        goto LABEL_222;
      v56 = v55[1];
      if ( *(float *)&pData == 0.0 )
      {
        v26 = 0;
        goto LABEL_220;
      }
      if ( v84 == v56 )
      {
        v26 = 0;
      }
      else
      {
        if ( *((float *)&pData + 1) == 0.0 )
        {
          v26 = 1;
LABEL_220:
          *(&v84 + v26) = v56;
          *((_DWORD *)&pData + v26 + 1) = 0;
          goto LABEL_221;
        }
        if ( v85 == v56 )
        {
          v26 = 1;
        }
        else
        {
          if ( *(float *)&v77 == 0.0 )
          {
            v26 = 2;
            goto LABEL_220;
          }
          if ( v86 == v56 )
          {
            v26 = 2;
          }
          else
          {
            if ( *((float *)&v77 + 1) == 0.0 )
            {
              v26 = 3;
              goto LABEL_220;
            }
            if ( v87 == v56 )
            {
              v26 = 3;
            }
            else
            {
              if ( v78 == 0.0 )
              {
                v26 = 4;
                goto LABEL_220;
              }
              if ( v88 == v56 )
              {
                v26 = 4;
              }
              else
              {
                if ( v79 == 0.0 )
                {
                  v26 = 5;
                  goto LABEL_220;
                }
                if ( v89 == v56 )
                {
                  v26 = 5;
                }
                else
                {
                  if ( v80 == 0.0 )
                  {
                    v26 = 6;
                    goto LABEL_220;
                  }
                  if ( v90 != v56 )
                  {
                    if ( v81 != 0.0 )
                    {
                      v26 = 8;
                      if ( v91 == v56 )
                        v26 = 7;
                      goto LABEL_221;
                    }
                    v26 = 7;
                    goto LABEL_220;
                  }
                  v26 = 6;
                }
              }
            }
          }
        }
      }
LABEL_221:
      v57 = (float *)&pData + v26;
      v18 = VertexBoneWeights;
      *v57 = v54 + *v57;
LABEL_222:
      v58 = v17->w2 * r2;
      if ( v58 == 0.0 )
        goto LABEL_227;
      v59 = v55[2];
      if ( *(float *)&pData == 0.0 )
      {
        v27 = 0;
        goto LABEL_225;
      }
      if ( v84 == v59 )
      {
        v27 = 0;
      }
      else
      {
        if ( *((float *)&pData + 1) == 0.0 )
        {
          v27 = 1;
LABEL_225:
          *(&v84 + v27) = v59;
          *((_DWORD *)&pData + v27 + 1) = 0;
          goto LABEL_226;
        }
        if ( v85 == v59 )
        {
          v27 = 1;
        }
        else
        {
          if ( *(float *)&v77 == 0.0 )
          {
            v27 = 2;
            goto LABEL_225;
          }
          if ( v86 == v59 )
          {
            v27 = 2;
          }
          else
          {
            if ( *((float *)&v77 + 1) == 0.0 )
            {
              v27 = 3;
              goto LABEL_225;
            }
            if ( v87 == v59 )
            {
              v27 = 3;
            }
            else
            {
              if ( v78 == 0.0 )
              {
                v27 = 4;
                goto LABEL_225;
              }
              if ( v88 == v59 )
              {
                v27 = 4;
              }
              else
              {
                if ( v79 == 0.0 )
                {
                  v27 = 5;
                  goto LABEL_225;
                }
                if ( v89 == v59 )
                {
                  v27 = 5;
                }
                else
                {
                  if ( v80 == 0.0 )
                  {
                    v27 = 6;
                    goto LABEL_225;
                  }
                  if ( v90 != v59 )
                  {
                    if ( v81 != 0.0 )
                    {
                      v27 = 8;
                      if ( v91 == v59 )
                        v27 = 7;
                      goto LABEL_226;
                    }
                    v27 = 7;
                    goto LABEL_225;
                  }
                  v27 = 6;
                }
              }
            }
          }
        }
      }
LABEL_226:
      v60 = (float *)&pData + v27;
      v18 = VertexBoneWeights;
      *v60 = v58 + *v60;
LABEL_227:
      v61 = v17->w3 * r2;
      if ( v61 != 0.0 )
      {
        v62 = v55[3];
        if ( *(float *)&pData == 0.0 )
        {
          v32 = v18;
          v28 = 0;
LABEL_230:
          *(&v84 + v28) = v62;
          *((_DWORD *)&pData + v28 + 1) = 0;
          goto LABEL_231;
        }
        if ( v84 == v62 )
        {
          v28 = 0;
        }
        else
        {
          if ( *((float *)&pData + 1) == 0.0 )
          {
            v32 = v18;
            v28 = 1;
            goto LABEL_230;
          }
          if ( v85 == v62 )
          {
            v28 = 1;
          }
          else
          {
            if ( *(float *)&v77 == 0.0 )
            {
              v32 = v18;
              v28 = 2;
              goto LABEL_230;
            }
            if ( v86 == v62 )
            {
              v28 = 2;
            }
            else
            {
              if ( *((float *)&v77 + 1) == 0.0 )
              {
                v32 = v18;
                v28 = 3;
                goto LABEL_230;
              }
              if ( v87 == v62 )
              {
                v28 = 3;
              }
              else
              {
                if ( v78 == 0.0 )
                {
                  v32 = v18;
                  v28 = 4;
                  goto LABEL_230;
                }
                if ( v88 == v62 )
                {
                  v28 = 4;
                }
                else
                {
                  if ( v79 == 0.0 )
                  {
                    v32 = v18;
                    v28 = 5;
                    goto LABEL_230;
                  }
                  if ( v89 == v62 )
                  {
                    v28 = 5;
                  }
                  else
                  {
                    if ( v80 == 0.0 )
                    {
                      v32 = v18;
                      v28 = 6;
                      goto LABEL_230;
                    }
                    if ( v90 == v62 )
                    {
                      v28 = 6;
                    }
                    else
                    {
                      v32 = v18;
                      if ( v81 == 0.0 )
                      {
                        v28 = 7;
                        goto LABEL_230;
                      }
                      v28 = 8;
                      if ( v91 == v62 )
                        v28 = 7;
LABEL_231:
                      v18 = v32;
                    }
                  }
                }
              }
            }
          }
        }
        *((float *)&pData + v28) = v61 + *((float *)&pData + v28);
      }
      *v41 = v84;
      LODWORD(v18[v20].w0) = pData;
      v41[1] = v85;
      p_w0[1] = *((float *)&pData + 1);
      v41[2] = v86;
      *((_DWORD *)p_w0 + 2) = v77;
      v41[3] = v87;
      v63 = *((float *)&v77 + 1);
      p_w0[3] = *((float *)&v77 + 1);
      if ( v78 != 0.0 )
      {
        v64 = (float)((float)(*(float *)&pData + *((float *)&pData + 1)) + *(float *)&v77) + *((float *)&v77 + 1);
        *p_w0 = *p_w0 / v64;
        p_w0[1] = p_w0[1] / v64;
        p_w0[2] = p_w0[2] / v64;
        p_w0[3] = v63 / v64;
      }
      v16 += 2;
      p_u += 2;
      ++v19;
      ++v20;
      v22 = v75 + 1;
      ++v17;
      if ( v75 + 1 >= geometry->numVertices )
      {
        v8 = v82;
        goto LABEL_237;
      }
    }
    v46 = v41[1];
    if ( v43 == 0.0 )
    {
      v47 = 0;
    }
    else
    {
      if ( v84 == v46 )
      {
        v47 = 0;
LABEL_198:
        *(float *)((unsigned int)&pData | (4 * v47)) = v45 + v43;
        goto LABEL_199;
      }
      v47 = 1;
      v43 = 0.0;
    }
    *(&v84 + v47) = v46;
    *(_DWORD *)&byte_4[(unsigned int)&pData | (4 * v47)] = 0;
    goto LABEL_198;
  }
LABEL_237:
  RpGeometryUnlock(geometry);
  _rpGeometryAddRef(v8);
  return v8;
}

//----- (0045B914) --------------------------------------------------------
RpGeometry_0 *__fastcall CClothesBuilder::CopyGeometry(
        RpClump_0 *pClump,
        const unsigned __int8 *pName1,
        const unsigned __int8 *pName2)
{
  int v5; // r4
  int v6; // r5
  RpGeometry_0 *v7; // r8
  RpMorphTarget_0 *morphTarget; // r6
  RpSkin_0 *Skin; // r10
  _DWORD *p_x; // r0
  unsigned __int8 *verts; // r4
  const RwUInt32 *VertexBoneIndices; // r9
  RwMatrixWeights_0 *VertexBoneWeights; // r6
  RpGeometry_0 *v14; // r5
  RpMorphTarget_0 *v15; // r10
  RpSkin_0 *v16; // r0
  _DWORD *v17; // r1
  _DWORD *v18; // r11
  RwTexCoords_0 *v19; // r1
  RpSkin_0 *v20; // r5
  const RwUInt32 *v21; // r10
  const RwMatrixWeights_0 *v22; // r5
  RwInt32 v23; // r0
  RwUInt32 *v24; // r3
  const RwUInt32 *v25; // r1
  RwReal w3; // r1
  RpGeometry_0 *v27; // r9
  RpMorphTarget_0 *v28; // r6
  RpSkin_0 *v29; // r0
  __int64 v30; // kr10_8
  RpSkin_0 *v31; // r5
  RpGeometry_0 *v32; // r5
  RpMorphTarget_0 *v33; // r4
  RpSkin_0 *v34; // r0
  __int64 v35; // kr18_8
  RpSkin_0 *v36; // r6
  int numVertices; // r0
  int v39; // [sp+4h] [bp-44h]
  int v40; // [sp+8h] [bp-40h]
  _DWORD *p_u; // [sp+Ch] [bp-3Ch]
  _DWORD *v42; // [sp+10h] [bp-38h]
  _DWORD *v43; // [sp+14h] [bp-34h]
  _DWORD *v44; // [sp+18h] [bp-30h]
  int v45; // [sp+1Ch] [bp-2Ch]
  int v46; // [sp+20h] [bp-28h]
  const unsigned __int8 *pData; // [sp+24h] [bp-24h] BYREF
  _DWORD *v48; // [sp+28h] [bp-20h]

  pData = pName1;
  v48 = 0;
  RpClumpForAllAtomics(pClump, FindAtomicFromNameCB, &pData);
  v5 = (int)v48;
  v45 = (int)v48;
  pData = pName2;
  v48 = 0;
  RpClumpForAllAtomics(pClump, FindAtomicFromNameCB, &pData);
  v6 = (int)v48;
  v46 = (int)v48;
  v39 = v5;
  v7 = *(RpGeometry_0 **)(v5 + 24);
  morphTarget = v7->morphTarget;
  Skin = j_RpSkinGeometryGetSkin(v7);
  p_x = (_DWORD *)&morphTarget->normals->x;
  verts = (unsigned __int8 *)morphTarget->verts;
  pData = verts;
  v43 = p_x;
  p_u = (_DWORD *)&v7->texCoords[0]->u;
  VertexBoneIndices = j_RpSkinGetVertexBoneIndices(Skin);
  v40 = v6;
  VertexBoneWeights = (RwMatrixWeights_0 *)j_RpSkinGetVertexBoneWeights(Skin);
  v14 = *(RpGeometry_0 **)(v6 + 24);
  v15 = v14->morphTarget;
  v16 = j_RpSkinGeometryGetSkin(v14);
  v17 = (_DWORD *)&v15->normals->x;
  v18 = (_DWORD *)&v15->verts->x;
  v48 = v18;
  v44 = v17;
  v19 = v14->texCoords[0];
  v20 = v16;
  v42 = (_DWORD *)&v19->u;
  v21 = j_RpSkinGetVertexBoneIndices(v16);
  v22 = j_RpSkinGetVertexBoneWeights(v20);
  RpGeometryLock(v7, 4095);
  if ( v7->numVertices >= 1 )
  {
    v23 = 0;
    do
    {
      *(_DWORD *)verts = *v18;
      *((_DWORD *)verts + 1) = v18[1];
      *((_DWORD *)pData + 2) = v48[2];
      *v43 = *v44;
      v43[1] = v44[1];
      v43[2] = v44[2];
      *p_u = *v42;
      v24 = (RwUInt32 *)&VertexBoneIndices[v23];
      p_u[1] = v42[1];
      *(_BYTE *)v24 = v21[v23];
      VertexBoneWeights->w0 = v22->w0;
      v25 = &v21[v23++];
      *((_BYTE *)v24 + 1) = *((_BYTE *)v25 + 1);
      VertexBoneWeights->w1 = v22->w1;
      *((_BYTE *)v24 + 2) = *((_BYTE *)v25 + 2);
      VertexBoneWeights->w2 = v22->w2;
      *((_BYTE *)v24 + 3) = *((_BYTE *)v25 + 3);
      w3 = v22->w3;
      ++v22;
      VertexBoneWeights->w3 = w3;
      ++VertexBoneWeights;
      v18 = v48 + 3;
      verts = (unsigned __int8 *)(pData + 12);
      pData += 12;
      v43 += 3;
      v44 += 3;
      p_u += 2;
      v48 += 3;
      v42 += 2;
    }
    while ( v23 < v7->numVertices );
    v39 = v45;
    v40 = v46;
  }
  RpGeometryUnlock(v7);
  v27 = *(RpGeometry_0 **)(v39 + 24);
  v28 = v27->morphTarget;
  v29 = j_RpSkinGeometryGetSkin(v27);
  v30 = *(_QWORD *)&v28->verts;
  v31 = v29;
  pData = (const unsigned __int8 *)v28->verts;
  j_RpSkinGetVertexBoneIndices(v29);
  j_RpSkinGetVertexBoneWeights(v31);
  v32 = *(RpGeometry_0 **)(v40 + 24);
  v33 = v32->morphTarget;
  v34 = j_RpSkinGeometryGetSkin(v32);
  v35 = *(_QWORD *)&v33->verts;
  v36 = v34;
  v48 = (_DWORD *)&v33->verts->x;
  j_RpSkinGetVertexBoneIndices(v34);
  j_RpSkinGetVertexBoneWeights(v36);
  numVertices = v27->numVertices;
  if ( numVertices >= 1 )
  {
    v48 = (_DWORD *)(v35 + 12 * numVertices);
    pData = (const unsigned __int8 *)(v30 + 12 * numVertices);
  }
  _rpGeometryAddRef(v27);
  return v27;
}

//----- (0045BB0C) --------------------------------------------------------
void __fastcall CClothesBuilder::BuildBoneIndexConversionTable(
        uint8 *pTable,
        RpHAnimHierarchy_0 *pSkinHier,
        int32 index)
{
  int v5; // r4
  int16 *v6; // r6
  RwInt32 v7; // r1
  uint8 v8; // r0
  bool v9; // cc

  v5 = 0;
  v6 = gBoneIndices[index];
  do
  {
    v7 = v6[v5];
    if ( v7 == -1 )
      break;
    v8 = RpHAnimIDGetIndex(pSkinHier, v7);
    if ( v8 == 255 )
      v8 = 0;
    v9 = v5 < 63;
    pTable[v5++] = v8;
  }
  while ( v9 );
}

//----- (0045BB50) --------------------------------------------------------
void __fastcall CClothesBuilder::PlaceTextureOnTopOfTexture(RwTexture_0 *pDest, RwTexture_0 *pSrc, bool isTattoo)
{
  float32x2_t v3; // d0
  float32x2_t v4; // d3
  float32x2_t v5; // d4
  RwRaster_0 *raster; // r6
  _BOOL4 v7; // r9
  RwRaster_0 *v8; // r8
  int v9; // r5
  RwUInt8 *v10; // r10
  RwUInt8 *v11; // r0
  unsigned int v12; // r1
  int v13; // r2
  RwUInt8 *v14; // r1
  RwUInt8 *v15; // r4
  unsigned int v16; // r3
  float32x2_t v17; // d4
  float v18; // s10

  raster = pSrc->raster;
  v7 = isTattoo;
  v8 = pDest->raster;
  v9 = 0;
  v10 = RwRasterLock(pSrc->raster, 0, 3);
  v11 = RwRasterLock(v8, 0, 3);
  if ( raster->width * raster->height >= 1 )
  {
    v3.n64_u32[0] = 1132396544;
    do
    {
      v12 = *(_DWORD *)&v10[4 * v9];
      v13 = 0;
      v4.n64_f32[0] = (float)HIBYTE(v12) / 255.0;
      if ( v4.n64_f32[0] > 0.0 )
        v13 = 1;
      if ( v4.n64_f32[0] > 0.98 || (v13 & v7) == 1 )
      {
        *(_DWORD *)&v11[4 * v9] = v12;
      }
      else if ( v4.n64_f32[0] != 0.0 )
      {
        v5.n64_u32[0] = (unsigned __int8)v12;
        v14 = &v11[4 * v9];
        v15 = &v10[4 * v9];
        v16 = v14[2];
        v5.n64_f32[0] = (float)((float)(1.0 - v4.n64_f32[0]) * (float)*v14)
                      + (float)(v4.n64_f32[0] * (float)v5.n64_u32[0]);
        v17.n64_u64[0] = vmin_f32(v5, v3).n64_u64[0];
        v18 = (float)(1.0 - v4.n64_f32[0]) * (float)v14[1];
        *v14 = (unsigned int)v17.n64_f32[0];
        v17.n64_f32[0] = v18 + (float)(v4.n64_f32[0] * (float)v15[1]);
        v5.n64_u64[0] = vmin_f32(v17, v3).n64_u64[0];
        v14[1] = (unsigned int)v5.n64_f32[0];
        v4.n64_f32[0] = (float)((float)(1.0 - v4.n64_f32[0]) * (float)v16) + (float)(v4.n64_f32[0] * (float)v15[2]);
        v4.n64_u64[0] = vmin_f32(v4, v3).n64_u64[0];
        v14[2] = (unsigned int)v4.n64_f32[0];
      }
      ++v9;
    }
    while ( v9 < raster->width * raster->height );
  }
  RwRasterUnlock(raster);
  sub_19A0A8(v8);
}
// 45BC00: variable 'v5' is possibly undefined
// 45BC00: variable 'v3' is possibly undefined
// 45BC56: variable 'v4' is possibly undefined

//----- (0045BC94) --------------------------------------------------------
void __fastcall CClothesBuilder::ReducePaletteSize(RwTexture_0 *pTex, int32 size)
{
  RwRaster_0 *raster; // r4
  RwUInt8 *v3; // r10
  RwUInt8 *v4; // r5
  int v5; // r6
  int v6; // r1
  UInt8 *v7; // r0
  int v8; // r6
  int v9; // r1
  UInt8 *v10; // r0
  RwUInt8 NearestColour; // r0
  int j; // r0
  int i; // r0
  __int64 v14; // d16
  __int64 v15; // d17
  RwUInt8 *v16; // r2

  raster = pTex->raster;
  CTimer::Suspend();
  CMemoryMgr::LockScratchPad();
  v3 = RwRasterLock(raster, 0, 2);
  v4 = RwRasterLockPalette(raster, 2);
  COctTree::InitPool(&PC_Scratch[1024], 15360);
  COctTreeBase::Init(&gOctTree, 256);
  if ( raster->height * raster->stride >= 1 )
  {
    v5 = 0;
    do
    {
      v6 = v3[v5];
      v7 = &v4[4 * v6];
      if ( !v7[3] )
        gOctTree.includeAlpha = 1;
      COctTreeBase::Insert(&gOctTree, v4[4 * v6], v7[1], v7[2]);
      ++v5;
    }
    while ( v5 < raster->height * raster->stride );
  }
  COctTreeBase::ReduceBranches(&gOctTree, 256 - size);
  COctTreeBase::FillPalette(&gOctTree, (UInt8 *)PC_Scratch);
  if ( raster->height * raster->stride >= 1 )
  {
    v8 = 0;
    do
    {
      v9 = v3[v8];
      v10 = &v4[4 * v9];
      if ( v10[3] )
        NearestColour = COctTree::FindNearestColour(&gOctTree, v4[4 * v9], v10[1], v10[2]);
      else
        NearestColour = 0;
      v3[v8++] = NearestColour;
    }
    while ( v8 < raster->height * raster->stride );
  }
  if ( v4 >= (RwUInt8 *)&PC_Scratch[256] || v4 + 1024 <= (RwUInt8 *)PC_Scratch )
  {
    for ( i = 0; i != 256; i += 4 )
    {
      v14 = *(_QWORD *)&PC_Scratch[i];
      v15 = *(_QWORD *)&PC_Scratch[i + 2];
      v16 = &v4[i * 4];
      *(_QWORD *)v16 = v14;
      *((_QWORD *)v16 + 1) = v15;
    }
  }
  else
  {
    for ( j = 0; j != 256; ++j )
      *(_DWORD *)&v4[4 * j] = PC_Scratch[j];
  }
  RwRasterUnlock(raster);
  RwRasterUnlockPalette(raster);
  COctTree::ShutdownPool();
  CMemoryMgr::ReleaseScratchPad();
  sub_19F744();
}

//----- (0045BE24) --------------------------------------------------------
void __fastcall CClothesBuilder::InitPaletteOctTree(int32 size)
{
  COctTree::InitPool(&PC_Scratch[1024], 15360);
  sub_19A7A4(&gOctTree, size);
}

//----- (0045BE54) --------------------------------------------------------
void __fastcall CClothesBuilder::AddColour(RwRGBA_0 *pRGBA)
{
  if ( !pRGBA->_anon_0._anon_0.alpha )
    gOctTree.includeAlpha = 1;
  sub_192500(&gOctTree, pRGBA->_anon_0._anon_0.red, pRGBA->_anon_0._anon_0.green, pRGBA->_anon_0._anon_0.blue);
}

//----- (0045BE7C) --------------------------------------------------------
void __fastcall CClothesBuilder::ReducePaletteOctTree(int32 size)
{
  sub_1939E0(&gOctTree, size);
}

//----- (0045BE8C) --------------------------------------------------------
void __fastcall CClothesBuilder::FillPalette(RwRGBA_0 *pRGBA)
{
  sub_18E1A0(&gOctTree, (UInt8 *)pRGBA);
}

//----- (0045BE9C) --------------------------------------------------------
int32 __fastcall CClothesBuilder::FindNearestColour(RwRGBA_0 *pRGBA)
{
  if ( pRGBA->_anon_0._anon_0.alpha )
    return sub_192850(&gOctTree, pRGBA->_anon_0._anon_0.red, pRGBA->_anon_0._anon_0.green, pRGBA->_anon_0._anon_0.blue);
  else
    return 0;
}

//----- (0045BEC0) --------------------------------------------------------
void ResolveClothesIDs()
{
  const unsigned __int8 *name; // r0
  uint32 *p_key; // r4

  name = clothesIDs[0].name;
  if ( clothesIDs[0].name )
  {
    p_key = &clothesIDs[0].key;
    do
    {
      *p_key = CKeyGen::GetUppercaseKey(name);
      name = (const unsigned __int8 *)p_key[1];
      p_key += 2;
    }
    while ( name );
  }
}

//----- (0045BEF4) --------------------------------------------------------
void __fastcall COctTree::COctTree(COctTree *this)
{
  this->cc = 0;
  this->red = 0;
  this->green = 0;
  this->blue = 0;
  *(_DWORD *)this->nextIndex = -1;
  *(_DWORD *)&this->nextIndex[6] = -1;
  *(_DWORD *)&this->nextIndex[4] = -1;
  *(_DWORD *)&this->nextIndex[2] = -1;
  this->leaf = 0;
  this->_vptr$COctTree = (int (**)(void))&off_667F68;
}
// 667F68: using guessed type void *;

//----- (0045BF24) --------------------------------------------------------
void __fastcall COctTree::~COctTree(COctTree *this)
{
  int v2; // r5
  int v3; // r0
  COctTree *v4; // r0
  int v5; // r0
  int v6; // r0

  v2 = 5;
  this->red = 0;
  this->green = 0;
  this->blue = 0;
  *(_QWORD *)&this->_vptr$COctTree = (unsigned int)&off_667F68;
  do
  {
    v3 = *((__int16 *)&this->_vptr$COctTree + v2);
    if ( v3 > -1 )
    {
      if ( (gOctTreePool.m_aFlags[v3] & 0x80u) == 0 )
      {
        v4 = (COctTree *)gOctTreePool.m_aStorage[v3];
        if ( v4 )
        {
          COctTree::~COctTree(v4);
          v6 = -858993459 * ((signed int)(v5 - (unsigned int)gOctTreePool.m_aStorage) >> 3);
          gOctTreePool.m_aFlags[v6] |= 0x80u;
          if ( v6 < gOctTreePool.m_nFreeIndex )
            gOctTreePool.m_nFreeIndex = v6;
        }
      }
      *((_WORD *)&this->_vptr$COctTree + v2) = -1;
    }
    ++v2;
  }
  while ( v2 != 13 );
  this->leaf = 0;
}
// 45BF8C: variable 'v5' is possibly undefined
// 667F68: using guessed type void *off_667F68;

//----- (0045BFD8) --------------------------------------------------------
void __fastcall COctTree::empty(COctTree *this)
{
  int16 *nextIndex; // r6
  int v3; // r5
  int v4; // r0
  COctTree *v5; // r0
  int v6; // r0
  int v7; // r0

  nextIndex = this->nextIndex;
  v3 = 0;
  this->cc = 0;
  this->red = 0;
  this->green = 0;
  this->blue = 0;
  do
  {
    v4 = nextIndex[v3];
    if ( v4 > -1 )
    {
      if ( (gOctTreePool.m_aFlags[v4] & 0x80u) == 0 )
      {
        v5 = (COctTree *)gOctTreePool.m_aStorage[v4];
        if ( v5 )
        {
          COctTree::~COctTree(v5);
          v7 = -858993459 * ((signed int)(v6 - (unsigned int)gOctTreePool.m_aStorage) >> 3);
          gOctTreePool.m_aFlags[v7] |= 0x80u;
          if ( v7 < gOctTreePool.m_nFreeIndex )
            gOctTreePool.m_nFreeIndex = v7;
        }
      }
      nextIndex[v3] = -1;
    }
    ++v3;
  }
  while ( v3 != 8 );
  this->leaf = 0;
}
// 45C034: variable 'v6' is possibly undefined

//----- (0045C080) --------------------------------------------------------
void *__fastcall COctTree::operator new(size_t nSize)
{
  int v1; // r3
  void *result; // r0
  int v3; // r5

  v1 = 0;
  result = (void *)gOctTreePool.m_nFreeIndex;
  do
  {
    result = (char *)result + 1;
    gOctTreePool.m_nFreeIndex = (int32)result;
    if ( result == (void *)gOctTreePool.m_nSize )
    {
      result = 0;
      gOctTreePool.m_nFreeIndex = 0;
      if ( v1 << 31 )
        return result;
      v1 = 1;
    }
    v3 = (char)gOctTreePool.m_aFlags[(unsigned int)result];
  }
  while ( v3 > -1 );
  gOctTreePool.m_aFlags[(unsigned int)result] = v3 & 0x7F;
  gOctTreePool.m_aFlags[gOctTreePool.m_nFreeIndex] = (gOctTreePool.m_aFlags[gOctTreePool.m_nFreeIndex] + 1) & 0x7F | gOctTreePool.m_aFlags[gOctTreePool.m_nFreeIndex] & 0x80;
  return gOctTreePool.m_aStorage[gOctTreePool.m_nFreeIndex];
}

//----- (0045C100) --------------------------------------------------------
void __fastcall COctTree::operator delete(void *pMem)
{
  int v1; // r0

  v1 = -858993459 * ((signed int)((int)pMem - (unsigned int)gOctTreePool.m_aStorage) >> 3);
  gOctTreePool.m_aFlags[v1] |= 0x80u;
  if ( v1 < gOctTreePool.m_nFreeIndex )
    gOctTreePool.m_nFreeIndex = v1;
}

//----- (0045C138) --------------------------------------------------------
void __fastcall COctTree::InitPool(void *pMem, int32 size)
{
  unsigned int v2; // r2
  int v3; // r0

  gOctTreePool.m_bOwnsArrays = 0;
  v2 = size / 0x29u;
  gOctTreePool.m_aStorage = (CPool<COctTree,COctTree>::StorageType *)pMem;
  gOctTreePool.m_aFlags = (uint8 *)pMem + 40 * (size / 0x29u);
  gOctTreePool.m_nSize = size / 0x29u;
  gOctTreePool.m_nFreeIndex = -1;
  if ( (unsigned int)size >= 0x29 )
  {
    *((_BYTE *)pMem + 40 * v2) |= 0x80u;
    *gOctTreePool.m_aFlags &= 0x80u;
    if ( (unsigned int)(size - 41) >= 0x29 )
    {
      v3 = 1;
      do
      {
        gOctTreePool.m_aFlags[v3] |= 0x80u;
        gOctTreePool.m_aFlags[v3++] &= 0x80u;
      }
      while ( v2 != v3 );
    }
  }
  gOctTreePool.m_bDealWithNoMemory = 1;
}

//----- (0045C1C8) --------------------------------------------------------
void COctTree::ShutdownPool()
{
  if ( gOctTreePool.m_nSize >= 1 )
  {
    if ( gOctTreePool.m_bOwnsArrays )
    {
      if ( gOctTreePool.m_aStorage )
        operator delete[](gOctTreePool.m_aStorage);
      if ( gOctTreePool.m_aFlags )
        operator delete[](gOctTreePool.m_aFlags);
    }
    *(_QWORD *)&gOctTreePool.m_aStorage = 0LL;
    *(_QWORD *)&gOctTreePool.m_nSize = 0LL;
  }
}

//----- (0045C224) --------------------------------------------------------
void __fastcall COctTree::RemoveChildren(COctTree *this)
{
  int16 *nextIndex; // r4
  int i; // r5
  int v3; // r0
  COctTree *v4; // r0
  int v5; // r0
  int v6; // r0

  nextIndex = this->nextIndex;
  for ( i = 0; i != 8; ++i )
  {
    v3 = nextIndex[i];
    if ( v3 > -1 )
    {
      if ( (gOctTreePool.m_aFlags[v3] & 0x80u) == 0 )
      {
        v4 = (COctTree *)gOctTreePool.m_aStorage[v3];
        if ( v4 )
        {
          COctTree::~COctTree(v4);
          v6 = -858993459 * ((signed int)(v5 - (unsigned int)gOctTreePool.m_aStorage) >> 3);
          gOctTreePool.m_aFlags[v6] |= 0x80u;
          if ( v6 < gOctTreePool.m_nFreeIndex )
            gOctTreePool.m_nFreeIndex = v6;
        }
      }
      nextIndex[i] = -1;
    }
  }
}
// 45C27A: variable 'v5' is possibly undefined

//----- (0045C2BC) --------------------------------------------------------
Int32 __fastcall COctTree::NoOfChildren(COctTree *this)
{
  return (((unsigned __int16)this->nextIndex[6] >> 15) ^ 1)
       + (unsigned __int16)((this->nextIndex[3] >= 0)
                          + (this->nextIndex[1] >= 0)
                          + (this->nextIndex[0] >= 0)
                          + (this->nextIndex[2] >= 0)
                          + (this->nextIndex[4] >= 0)
                          + (this->nextIndex[5] >= 0))
       + (((unsigned __int16)this->nextIndex[7] >> 15) ^ 1);
}

//----- (0045C308) --------------------------------------------------------
void __fastcall COctTree::ReduceTree(COctTree *this)
{
  int v2; // r0
  COctTree *v3; // r5
  Int32 v4; // r8
  int v5; // r6
  int v6; // r0
  COctTree *v7; // r5
  int v8; // r0
  COctTree *v9; // r5
  int v10; // r0
  COctTree *v11; // r5
  int v12; // r0
  COctTree *v13; // r5
  int v14; // r0
  COctTree *v15; // r5
  int v16; // r0
  COctTree *v17; // r5
  int v18; // r0
  COctTree *v19; // r5

  if ( !this->leaf )
  {
    ++COctTree::ms_level;
    v2 = this->nextIndex[0];
    if ( v2 < 0 )
    {
      v4 = 0;
      v5 = 0;
    }
    else
    {
      v3 = (COctTree *)gOctTreePool.m_aStorage[v2];
      if ( (gOctTreePool.m_aFlags[v2] & 0x80u) != 0 )
        v3 = 0;
      COctTree::ReduceTree(v3);
      v4 = *(_DWORD *)&byte_4[(_DWORD)v3];
      v5 = 1;
    }
    v6 = this->nextIndex[1];
    if ( v6 > -1 )
    {
      v7 = (COctTree *)gOctTreePool.m_aStorage[v6];
      if ( (gOctTreePool.m_aFlags[v6] & 0x80u) != 0 )
        v7 = 0;
      COctTree::ReduceTree(v7);
      ++v5;
      v4 += *(_DWORD *)&byte_4[(_DWORD)v7];
    }
    v8 = this->nextIndex[2];
    if ( v8 > -1 )
    {
      v9 = (COctTree *)gOctTreePool.m_aStorage[v8];
      if ( (gOctTreePool.m_aFlags[v8] & 0x80u) != 0 )
        v9 = 0;
      COctTree::ReduceTree(v9);
      ++v5;
      v4 += *(_DWORD *)&byte_4[(_DWORD)v9];
    }
    v10 = this->nextIndex[3];
    if ( v10 > -1 )
    {
      v11 = (COctTree *)gOctTreePool.m_aStorage[v10];
      if ( (gOctTreePool.m_aFlags[v10] & 0x80u) != 0 )
        v11 = 0;
      COctTree::ReduceTree(v11);
      ++v5;
      v4 += *(_DWORD *)&byte_4[(_DWORD)v11];
    }
    v12 = this->nextIndex[4];
    if ( v12 > -1 )
    {
      v13 = (COctTree *)gOctTreePool.m_aStorage[v12];
      if ( (gOctTreePool.m_aFlags[v12] & 0x80u) != 0 )
        v13 = 0;
      COctTree::ReduceTree(v13);
      ++v5;
      v4 += *(_DWORD *)&byte_4[(_DWORD)v13];
    }
    v14 = this->nextIndex[5];
    if ( v14 > -1 )
    {
      v15 = (COctTree *)gOctTreePool.m_aStorage[v14];
      if ( (gOctTreePool.m_aFlags[v14] & 0x80u) != 0 )
        v15 = 0;
      COctTree::ReduceTree(v15);
      ++v5;
      v4 += *(_DWORD *)&byte_4[(_DWORD)v15];
    }
    v16 = this->nextIndex[6];
    if ( v16 > -1 )
    {
      v17 = (COctTree *)gOctTreePool.m_aStorage[v16];
      if ( (gOctTreePool.m_aFlags[v16] & 0x80u) != 0 )
        v17 = 0;
      COctTree::ReduceTree(v17);
      ++v5;
      v4 += *(_DWORD *)&byte_4[(_DWORD)v17];
    }
    v18 = this->nextIndex[7];
    if ( v18 > -1 )
    {
      v19 = (COctTree *)gOctTreePool.m_aStorage[v18];
      if ( (gOctTreePool.m_aFlags[v18] & 0x80u) != 0 )
        v19 = 0;
      COctTree::ReduceTree(v19);
      ++v5;
      v4 += *(_DWORD *)&byte_4[(_DWORD)v19];
    }
    if ( v5 >= 2 && (v4 < octNumber || !octReducible) )
    {
      octReducible = this;
      octNumber = v4;
    }
    --COctTree::ms_level;
  }
}

//----- (0045C504) --------------------------------------------------------
bool __fastcall COctTree::InsertTree(COctTree *this, UInt8 r, UInt8 g, UInt8 b)
{
  char v5; // lr
  Int32 cc; // r12
  bool v7; // zf
  __int64 v8; // kr00_8
  UInt32 blue; // r5
  int v10; // r6
  int16 *nextIndex; // r5
  int v12; // r0
  COctTree *v13; // r0
  int v14; // r0
  int v15; // r0
  Int32 v16; // r0
  char *v17; // r9
  int v18; // r0
  _WORD *v19; // r9
  int v20; // t1
  uint8 *m_nFreeIndex; // r4
  int v22; // r6
  int v23; // r0
  int v24; // r0

  v5 = COctTree::ms_level++;
  cc = this->cc;
  v7 = COctTree::ms_level == 8;
  v8 = *(_QWORD *)&this->red;
  blue = this->blue;
  this->red = (_DWORD)v8 + r;
  this->green = HIDWORD(v8) + g;
  this->blue = blue + b;
  this->cc = cc + 1;
  if ( !v7 && !this->leaf )
  {
    v17 = (char *)this
        + 2
        * (((unsigned int)(r << v5) >> 5) & 4 | ((unsigned int)(g << v5) >> 6) & 2 | ((unsigned int)(b << v5) >> 7) & 1);
    v20 = *((__int16 *)v17 + 5);
    v19 = v17 + 10;
    v18 = v20;
    if ( v20 <= -1 )
    {
      v22 = 0;
      m_nFreeIndex = (uint8 *)gOctTreePool.m_nFreeIndex;
      do
      {
        gOctTreePool.m_nFreeIndex = (int32)++m_nFreeIndex;
        if ( m_nFreeIndex == (uint8 *)gOctTreePool.m_nSize )
        {
          m_nFreeIndex = 0;
          gOctTreePool.m_nFreeIndex = 0;
          if ( v22 << 31 )
            goto LABEL_23;
          v22 = 1;
        }
        v23 = (char)gOctTreePool.m_aFlags[(unsigned int)m_nFreeIndex];
      }
      while ( v23 > -1 );
      gOctTreePool.m_aFlags[(unsigned int)m_nFreeIndex] = v23 & 0x7F;
      gOctTreePool.m_aFlags[gOctTreePool.m_nFreeIndex] = gOctTreePool.m_aFlags[gOctTreePool.m_nFreeIndex] & 0x80 | (gOctTreePool.m_aFlags[gOctTreePool.m_nFreeIndex] + 1) & 0x7F;
      m_nFreeIndex = gOctTreePool.m_aStorage[gOctTreePool.m_nFreeIndex];
LABEL_23:
      *((_DWORD *)m_nFreeIndex + 1) = 0;
      *((_DWORD *)m_nFreeIndex + 7) = 0;
      *((_DWORD *)m_nFreeIndex + 8) = 0;
      *((_DWORD *)m_nFreeIndex + 9) = 0;
      *(_DWORD *)(m_nFreeIndex + 10) = -1;
      *(_DWORD *)(m_nFreeIndex + 22) = -1;
      *(_DWORD *)(m_nFreeIndex + 18) = -1;
      *(_DWORD *)(m_nFreeIndex + 14) = -1;
      m_nFreeIndex[8] = 0;
      *(_DWORD *)m_nFreeIndex = &off_667F68;
      if ( !m_nFreeIndex )
      {
        COctTree::ms_bFailed = 1;
        goto LABEL_32;
      }
      *v19 = -13107 * ((unsigned int)(m_nFreeIndex - (uint8 *)gOctTreePool.m_aStorage) >> 3);
    }
    else if ( (gOctTreePool.m_aFlags[v18] & 0x80u) != 0 )
    {
      m_nFreeIndex = 0;
    }
    else
    {
      m_nFreeIndex = gOctTreePool.m_aStorage[v18];
    }
    LOBYTE(v16) = (**(int (__fastcall ***)(uint8 *))m_nFreeIndex)(m_nFreeIndex);
    if ( !COctTree::ms_bFailed || *((int *)m_nFreeIndex + 1) > 1 )
      return v16;
    COctTree::~COctTree((COctTree *)m_nFreeIndex);
    v24 = -858993459 * ((m_nFreeIndex - (uint8 *)gOctTreePool.m_aStorage) >> 3);
    gOctTreePool.m_aFlags[v24] = gOctTreePool.m_aFlags[-858993459
                                                     * ((m_nFreeIndex - (uint8 *)gOctTreePool.m_aStorage) >> 3)] | 0x80;
    if ( v24 < gOctTreePool.m_nFreeIndex )
      gOctTreePool.m_nFreeIndex = v24;
    *v19 = -1;
LABEL_32:
    LOBYTE(v16) = 0;
    return v16;
  }
  v10 = 0;
  nextIndex = this->nextIndex;
  COctTree::ms_level = 0;
  this->leaf = 1;
  do
  {
    v12 = nextIndex[v10];
    if ( v12 > -1 )
    {
      if ( (gOctTreePool.m_aFlags[v12] & 0x80u) == 0 )
      {
        v13 = (COctTree *)gOctTreePool.m_aStorage[v12];
        if ( v13 )
        {
          COctTree::~COctTree(v13);
          v15 = -858993459 * ((signed int)(v14 - (unsigned int)gOctTreePool.m_aStorage) >> 3);
          gOctTreePool.m_aFlags[v15] |= 0x80u;
          if ( v15 < gOctTreePool.m_nFreeIndex )
            gOctTreePool.m_nFreeIndex = v15;
        }
      }
      nextIndex[v10] = -1;
    }
    ++v10;
  }
  while ( v10 != 8 );
  v16 = this->cc;
  if ( v16 != 1 )
    LOBYTE(v16) = 0;
  return v16;
}
// 45C5A2: variable 'v14' is possibly undefined
// 667F68: using guessed type void *off_667F68;

//----- (0045C790) --------------------------------------------------------
void __fastcall COctTree::FillPalette(COctTree *this, UInt8 *pPalette)
{
  Int32 v4; // r1
  int v5; // r0
  int v6; // r0
  int v7; // r0
  int v8; // r0
  int v9; // r0
  int v10; // r0
  int v11; // r0
  int v12; // r0

  if ( this->leaf )
  {
    pPalette[4 * COctTree::ms_level] = (unsigned int)(float)((float)this->red / (float)this->cc);
    pPalette[4 * COctTree::ms_level + 1] = (unsigned int)(float)((float)this->green / (float)this->cc);
    pPalette[4 * COctTree::ms_level + 2] = (unsigned int)(float)((float)this->blue / (float)this->cc);
    pPalette[4 * COctTree::ms_level + 3] = 0x80;
    v4 = COctTree::ms_level;
    this->cc = COctTree::ms_level;
    COctTree::ms_level = v4 + 1;
  }
  else
  {
    v5 = this->nextIndex[0];
    if ( v5 > -1 )
      (*(void (__fastcall **)(uint8 *, UInt8 *))(*(_DWORD *)&gOctTreePool.m_aStorage[v5][0] + 4))(
        gOctTreePool.m_aStorage[v5],
        pPalette);
    v6 = this->nextIndex[1];
    if ( v6 > -1 )
      (*(void (__fastcall **)(uint8 *, UInt8 *))(*(_DWORD *)&gOctTreePool.m_aStorage[v6][0] + 4))(
        gOctTreePool.m_aStorage[v6],
        pPalette);
    v7 = this->nextIndex[2];
    if ( v7 > -1 )
      (*(void (__fastcall **)(uint8 *, UInt8 *))(*(_DWORD *)&gOctTreePool.m_aStorage[v7][0] + 4))(
        gOctTreePool.m_aStorage[v7],
        pPalette);
    v8 = this->nextIndex[3];
    if ( v8 > -1 )
      (*(void (__fastcall **)(uint8 *, UInt8 *))(*(_DWORD *)&gOctTreePool.m_aStorage[v8][0] + 4))(
        gOctTreePool.m_aStorage[v8],
        pPalette);
    v9 = this->nextIndex[4];
    if ( v9 > -1 )
      (*(void (__fastcall **)(uint8 *, UInt8 *))(*(_DWORD *)&gOctTreePool.m_aStorage[v9][0] + 4))(
        gOctTreePool.m_aStorage[v9],
        pPalette);
    v10 = this->nextIndex[5];
    if ( v10 > -1 )
      (*(void (__fastcall **)(uint8 *, UInt8 *))(*(_DWORD *)&gOctTreePool.m_aStorage[v10][0] + 4))(
        gOctTreePool.m_aStorage[v10],
        pPalette);
    v11 = this->nextIndex[6];
    if ( v11 > -1 )
      (*(void (__fastcall **)(uint8 *, UInt8 *))(*(_DWORD *)&gOctTreePool.m_aStorage[v11][0] + 4))(
        gOctTreePool.m_aStorage[v11],
        pPalette);
    v12 = this->nextIndex[7];
    if ( v12 > -1 )
      (*(void (__fastcall **)(uint8 *, UInt8 *))(*(_DWORD *)&gOctTreePool.m_aStorage[v12][0] + 4))(
        gOctTreePool.m_aStorage[v12],
        pPalette);
  }
}

//----- (0045C960) --------------------------------------------------------
int32 __fastcall COctTree::FindNearestColour(COctTree *this, UInt8 r, UInt8 g, UInt8 b)
{
  int v4; // r4
  int v5; // r0
  int v6; // r4

  if ( !this->leaf )
  {
    do
    {
      v4 = (g >> 6) & 2 | (b >> 7) | (r >> 5) & 4;
      b *= 2;
      g *= 2;
      r *= 2;
      v5 = this->nextIndex[v4];
      v6 = (char)gOctTreePool.m_aFlags[v5];
      this = (COctTree *)gOctTreePool.m_aStorage[v5];
      if ( v6 < 0 )
        this = 0;
    }
    while ( !byte_8[(_DWORD)this] );
  }
  return this->cc;
}

//----- (0045C9C0) --------------------------------------------------------
void __fastcall COctTreeBase::COctTreeBase(COctTreeBase *this)
{
  this->cc = 0;
  this->red = 0;
  this->green = 0;
  this->blue = 0;
  *(_DWORD *)&this->nextIndex[6] = -1;
  *(_DWORD *)&this->nextIndex[4] = -1;
  *(_DWORD *)&this->nextIndex[2] = -1;
  *(_DWORD *)this->nextIndex = -1;
  this->leaf = 0;
  this->_vptr$COctTree = (int (**)(void))&off_667F78;
}
// 667F78: using guessed type void *;

//----- (0045C9F0) --------------------------------------------------------
void __fastcall COctTreeBase::Init(COctTreeBase *this, int32 numColours)
{
  int16 *nextIndex; // r6
  int v4; // r5
  int v5; // r0
  COctTree *v6; // r0
  int v7; // r0
  int v8; // r0

  nextIndex = this->nextIndex;
  v4 = 0;
  COctTree::ms_level = 0;
  this->cc = 0;
  this->red = 0;
  this->green = 0;
  this->blue = 0;
  this->noOfColsLeft = numColours;
  this->includeAlpha = 0;
  do
  {
    v5 = nextIndex[v4];
    if ( v5 > -1 )
    {
      if ( (gOctTreePool.m_aFlags[v5] & 0x80u) == 0 )
      {
        v6 = (COctTree *)gOctTreePool.m_aStorage[v5];
        if ( v6 )
        {
          COctTree::~COctTree(v6);
          v8 = -858993459 * ((signed int)(v7 - (unsigned int)gOctTreePool.m_aStorage) >> 3);
          gOctTreePool.m_aFlags[v8] |= 0x80u;
          if ( v8 < gOctTreePool.m_nFreeIndex )
            gOctTreePool.m_nFreeIndex = v8;
        }
      }
      nextIndex[v4] = -1;
    }
    ++v4;
  }
  while ( v4 != 8 );
  this->leaf = 0;
}
// 45CA58: variable 'v7' is possibly undefined

//----- (0045CAA8) --------------------------------------------------------
bool __fastcall COctTreeBase::InsertTree(COctTreeBase *this, UInt8 r, UInt8 g, UInt8 b)
{
  bool v5; // r5

  v5 = 0;
  COctTree::ms_level = 0;
  if ( COctTree::InsertTree(this, r, g, b) )
  {
    --this->noOfColsLeft;
    return 1;
  }
  return v5;
}

//----- (0045CAD4) --------------------------------------------------------
bool __fastcall COctTreeBase::Insert(COctTreeBase *this, UInt8 r, UInt8 g, UInt8 b)
{
  COctTreeBase *v4; // r4
  int v5; // r5
  COctTreeBase *v6; // r12
  int16 *nextIndex; // r4
  int v8; // r0
  COctTree *v9; // r0
  int v10; // r0
  int v11; // r0
  COctTreeBase *v12; // r9
  COctTree *v13; // r0
  int v14; // r4
  int16 *v15; // r8
  int v16; // r0
  COctTree *v17; // r0
  int v18; // r0
  int v19; // r0
  int v22; // [sp+10h] [bp-28h]
  int v23; // [sp+14h] [bp-24h]
  int v24; // [sp+18h] [bp-20h]

  v4 = this;
  v22 = r;
  v23 = g;
  v24 = b;
  while ( 1 )
  {
    COctTree::ms_bFailed = 0;
    if ( ((int (__fastcall *)(COctTreeBase *, int, int, int))*v4->_vptr$COctTree)(v4, v22, v23, v24) == 1 )
      break;
    v5 = 0;
    if ( !COctTree::ms_bFailed )
      return v5;
    octReducible = 0;
    COctTree::ReduceTree(v4);
    v6 = v4;
    nextIndex = octReducible->nextIndex;
    v6->noOfColsLeft = (((unsigned __int16)octReducible->nextIndex[6] >> 15) ^ 1)
                     + v6->noOfColsLeft
                     + (unsigned __int16)((octReducible->nextIndex[0] >= 0)
                                        + (octReducible->nextIndex[1] >= 0)
                                        + (octReducible->nextIndex[2] >= 0)
                                        + (octReducible->nextIndex[3] >= 0)
                                        + (octReducible->nextIndex[4] >= 0)
                                        + (octReducible->nextIndex[5] >= 0))
                     + (((unsigned __int16)octReducible->nextIndex[7] >> 15) ^ 1)
                     - 1;
    *((_BYTE *)nextIndex - 2) = 1;
    do
    {
      v8 = nextIndex[v5];
      if ( v8 > -1 )
      {
        if ( (gOctTreePool.m_aFlags[v8] & 0x80u) == 0 )
        {
          v9 = (COctTree *)gOctTreePool.m_aStorage[v8];
          if ( v9 )
          {
            COctTree::~COctTree(v9);
            v11 = -858993459 * ((signed int)(v10 - (unsigned int)gOctTreePool.m_aStorage) >> 3);
            gOctTreePool.m_aFlags[v11] |= 0x80u;
            if ( v11 < gOctTreePool.m_nFreeIndex )
              gOctTreePool.m_nFreeIndex = v11;
          }
        }
        nextIndex[v5] = -1;
      }
      ++v5;
    }
    while ( v5 != 8 );
    v4 = this;
    if ( !COctTree::ms_bFailed )
    {
      LOBYTE(v5) = 0;
      return v5;
    }
  }
  LOBYTE(v5) = 1;
  if ( v4->noOfColsLeft <= 0 )
  {
    v12 = v4;
    v13 = v4;
    v14 = 0;
    octReducible = 0;
    COctTree::ReduceTree(v13);
    v15 = octReducible->nextIndex;
    v12->noOfColsLeft = (((unsigned __int16)v15[6] >> 15) ^ 1)
                      + v12->noOfColsLeft
                      + (unsigned __int16)((octReducible->nextIndex[0] >= 0)
                                         + (v15[1] >= 0)
                                         + (v15[2] >= 0)
                                         + (v15[3] >= 0)
                                         + (v15[4] >= 0)
                                         + (v15[5] >= 0))
                      + (((unsigned __int16)octReducible->nextIndex[7] >> 15) ^ 1)
                      - 1;
    *((_BYTE *)v15 - 2) = 1;
    do
    {
      v16 = v15[v14];
      if ( v16 > -1 )
      {
        if ( (gOctTreePool.m_aFlags[v16] & 0x80u) == 0 )
        {
          v17 = (COctTree *)gOctTreePool.m_aStorage[v16];
          if ( v17 )
          {
            COctTree::~COctTree(v17);
            v19 = -858993459 * ((signed int)(v18 - (unsigned int)gOctTreePool.m_aStorage) >> 3);
            gOctTreePool.m_aFlags[v19] |= 0x80u;
            if ( v19 < gOctTreePool.m_nFreeIndex )
              gOctTreePool.m_nFreeIndex = v19;
          }
        }
        v15[v14] = -1;
      }
      ++v14;
    }
    while ( v14 != 8 );
    LOBYTE(v5) = 1;
  }
  return v5;
}
// 45CBCE: variable 'v10' is possibly undefined
// 45CCC0: variable 'v18' is possibly undefined

//----- (0045CD30) --------------------------------------------------------
void __fastcall COctTreeBase::ReduceBranches(COctTreeBase *this, int32 num)
{
  COctTreeBase *v2; // r6
  __int64 v3; // kr00_8
  int v4; // r9
  int16 *nextIndex; // r10
  int v6; // r0
  COctTree *v7; // r0
  int v8; // r0
  int v9; // r0
  int32 v11; // [sp+8h] [bp-20h]

  v2 = this;
  v3 = *(_QWORD *)&this->noOfColsLeft;
  if ( HIDWORD(v3) )
    ++num;
  v11 = num;
  if ( (int)v3 < num )
  {
    do
    {
      v4 = 0;
      octReducible = 0;
      COctTree::ReduceTree(v2);
      nextIndex = octReducible->nextIndex;
      v2->noOfColsLeft = (((unsigned __int16)nextIndex[6] >> 15) ^ 1)
                       + v2->noOfColsLeft
                       + (unsigned __int16)((octReducible->nextIndex[0] >= 0)
                                          + (nextIndex[1] >= 0)
                                          + (nextIndex[2] >= 0)
                                          + (nextIndex[3] >= 0)
                                          + (nextIndex[4] >= 0)
                                          + (nextIndex[5] >= 0))
                       + (((unsigned __int16)octReducible->nextIndex[7] >> 15) ^ 1)
                       - 1;
      *((_BYTE *)nextIndex - 2) = 1;
      do
      {
        v6 = nextIndex[v4];
        if ( v6 > -1 )
        {
          if ( (gOctTreePool.m_aFlags[v6] & 0x80u) == 0 )
          {
            v7 = (COctTree *)gOctTreePool.m_aStorage[v6];
            if ( v7 )
            {
              COctTree::~COctTree(v7);
              v9 = -858993459 * ((signed int)(v8 - (unsigned int)gOctTreePool.m_aStorage) >> 3);
              gOctTreePool.m_aFlags[v9] |= 0x80u;
              if ( v9 < gOctTreePool.m_nFreeIndex )
                gOctTreePool.m_nFreeIndex = v9;
            }
          }
          nextIndex[v4] = -1;
        }
        ++v4;
      }
      while ( v4 != 8 );
      v2 = this;
    }
    while ( this->noOfColsLeft < v11 );
  }
}
// 45CE08: variable 'v8' is possibly undefined

//----- (0045CE58) --------------------------------------------------------
void __fastcall COctTreeBase::FillPalette(COctTreeBase *this, UInt8 *pPalette)
{
  COctTree::ms_level = 0;
  if ( this->includeAlpha )
  {
    *(_DWORD *)pPalette = 0;
    COctTree::ms_level = 1;
  }
  COctTree::FillPalette(this, pPalette);
}

//----- (0045CE80) --------------------------------------------------------
void __fastcall CPool<COctTree,COctTree>::~CPool(CPool<COctTree,COctTree> *this)
{
  uint8 *m_aFlags; // r0
  uint8 **p_m_aFlags; // r5

  if ( this->m_nSize >= 1 )
  {
    if ( this->m_bOwnsArrays )
    {
      if ( this->m_aStorage )
        operator delete[](this->m_aStorage);
      p_m_aFlags = &this->m_aFlags;
      m_aFlags = this->m_aFlags;
      if ( m_aFlags )
        operator delete[](m_aFlags);
    }
    else
    {
      p_m_aFlags = &this->m_aFlags;
    }
    this->m_aStorage = 0;
    *p_m_aFlags = 0;
    this->m_nSize = 0;
    this->m_nFreeIndex = 0;
  }
}

//----- (0045CEBC) --------------------------------------------------------
void CCredits::Render()
{
  bool v0; // zf

  if ( CCredits::bCreditsGoing )
  {
    v0 = gMobileMenu.screenStack.numEntries == 0;
    if ( !gMobileMenu.screenStack.numEntries )
      v0 = gMobileMenu.pendingScreen == 0;
    if ( v0 )
    {
      printingCredits = 1;
      CCredits::RenderCredits();
      printingCredits = 0;
    }
  }
}

//----- (0045CF04) --------------------------------------------------------
void CCredits::RenderCredits()
{
  UInt32 v0; // r4
  uint32 v1; // r5
  CRGBA v2; // r0
  float v3; // s16
  GxtChar *v4; // r0
  GxtChar *v5; // r0
  GxtChar *v6; // r0
  GxtChar *v7; // r0
  GxtChar *v8; // r0
  GxtChar *v9; // r0
  GxtChar *v10; // r0
  GxtChar *v11; // r0
  GxtChar *v12; // r0
  GxtChar *v13; // r0
  GxtChar *v14; // r0
  GxtChar *v15; // r0
  GxtChar *v16; // r0
  GxtChar *v17; // r0
  GxtChar *v18; // r0
  GxtChar *v19; // r0
  GxtChar *v20; // r0
  GxtChar *v21; // r0
  GxtChar *v22; // r0
  GxtChar *v23; // r0
  GxtChar *v24; // r0
  GxtChar *v25; // r0
  GxtChar *v26; // r0
  GxtChar *v27; // r0
  GxtChar *v28; // r0
  GxtChar *v29; // r0
  GxtChar *v30; // r0
  GxtChar *v31; // r0
  GxtChar *v32; // r0
  GxtChar *v33; // r0
  GxtChar *v34; // r0
  GxtChar *v35; // r0
  GxtChar *v36; // r0
  GxtChar *v37; // r0
  GxtChar *v38; // r0
  GxtChar *v39; // r0
  GxtChar *v40; // r0
  GxtChar *v41; // r0
  GxtChar *v42; // r0
  GxtChar *v43; // r0
  GxtChar *v44; // r0
  GxtChar *v45; // r0
  GxtChar *v46; // r0
  GxtChar *v47; // r0
  GxtChar *v48; // r0
  GxtChar *v49; // r0
  GxtChar *v50; // r0
  GxtChar *v51; // r0
  GxtChar *v52; // r0
  GxtChar *v53; // r0
  GxtChar *v54; // r0
  GxtChar *v55; // r0
  GxtChar *v56; // r0
  GxtChar *v57; // r0
  GxtChar *v58; // r0
  GxtChar *v59; // r0
  GxtChar *v60; // r0
  GxtChar *v61; // r0
  GxtChar *v62; // r0
  GxtChar *v63; // r0
  GxtChar *v64; // r0
  GxtChar *v65; // r0
  GxtChar *v66; // r0
  GxtChar *v67; // r0
  GxtChar *v68; // r0
  GxtChar *v69; // r0
  GxtChar *v70; // r0
  GxtChar *v71; // r0
  GxtChar *v72; // r0
  GxtChar *v73; // r0
  GxtChar *v74; // r0
  GxtChar *v75; // r0
  GxtChar *v76; // r0
  GxtChar *v77; // r0
  GxtChar *v78; // r0
  GxtChar *v79; // r0
  GxtChar *v80; // r0
  GxtChar *v81; // r0
  GxtChar *v82; // r0
  GxtChar *v83; // r0
  GxtChar *v84; // r0
  GxtChar *v85; // r0
  GxtChar *v86; // r0
  GxtChar *v87; // r0
  GxtChar *v88; // r0
  GxtChar *v89; // r0
  GxtChar *v90; // r0
  GxtChar *v91; // r0
  GxtChar *v92; // r0
  GxtChar *v93; // r0
  GxtChar *v94; // r0
  GxtChar *v95; // r0
  GxtChar *v96; // r0
  GxtChar *v97; // r0
  GxtChar *v98; // r0
  GxtChar *v99; // r0
  GxtChar *v100; // r0
  GxtChar *v101; // r0
  GxtChar *v102; // r0
  GxtChar *v103; // r0
  GxtChar *v104; // r0
  GxtChar *v105; // r0
  GxtChar *v106; // r0
  GxtChar *v107; // r0
  GxtChar *v108; // r0
  GxtChar *v109; // r0
  GxtChar *v110; // r0
  GxtChar *v111; // r0
  GxtChar *v112; // r0
  GxtChar *v113; // r0
  GxtChar *v114; // r0
  GxtChar *v115; // r0
  GxtChar *v116; // r0
  GxtChar *v117; // r0
  GxtChar *v118; // r0
  GxtChar *v119; // r0
  GxtChar *v120; // r0
  GxtChar *v121; // r0
  GxtChar *v122; // r0
  GxtChar *v123; // r0
  GxtChar *v124; // r0
  GxtChar *v125; // r0
  GxtChar *v126; // r0
  GxtChar *v127; // r0
  GxtChar *v128; // r0
  GxtChar *v129; // r0
  GxtChar *v130; // r0
  GxtChar *v131; // r0
  GxtChar *v132; // r0
  GxtChar *v133; // r0
  GxtChar *v134; // r0
  GxtChar *v135; // r0
  GxtChar *v136; // r0
  GxtChar *v137; // r0
  GxtChar *v138; // r0
  GxtChar *v139; // r0
  GxtChar *v140; // r0
  GxtChar *v141; // r0
  GxtChar *v142; // r0
  GxtChar *v143; // r0
  GxtChar *v144; // r0
  GxtChar *v145; // r0
  GxtChar *v146; // r0
  GxtChar *v147; // r0
  GxtChar *v148; // r0
  GxtChar *v149; // r0
  GxtChar *v150; // r0
  GxtChar *v151; // r0
  GxtChar *v152; // r0
  GxtChar *v153; // r0
  GxtChar *v154; // r0
  GxtChar *v155; // r0
  GxtChar *v156; // r0
  GxtChar *v157; // r0
  GxtChar *v158; // r0
  GxtChar *v159; // r0
  GxtChar *v160; // r0
  GxtChar *v161; // r0
  GxtChar *v162; // r0
  GxtChar *v163; // r0
  GxtChar *v164; // r0
  GxtChar *v165; // r0
  GxtChar *v166; // r0
  GxtChar *v167; // r0
  GxtChar *v168; // r0
  GxtChar *v169; // r0
  GxtChar *v170; // r0
  GxtChar *v171; // r0
  GxtChar *v172; // r0
  GxtChar *v173; // r0
  GxtChar *v174; // r0
  GxtChar *v175; // r0
  GxtChar *v176; // r0
  GxtChar *v177; // r0
  GxtChar *v178; // r0
  GxtChar *v179; // r0
  GxtChar *v180; // r0
  GxtChar *v181; // r0
  GxtChar *v182; // r0
  GxtChar *v183; // r0
  GxtChar *v184; // r0
  GxtChar *v185; // r0
  GxtChar *v186; // r0
  GxtChar *v187; // r0
  GxtChar *v188; // r0
  GxtChar *v189; // r0
  GxtChar *v190; // r0
  GxtChar *v191; // r0
  GxtChar *v192; // r0
  GxtChar *v193; // r0
  GxtChar *v194; // r0
  GxtChar *v195; // r0
  GxtChar *v196; // r0
  GxtChar *v197; // r0
  GxtChar *v198; // r0
  GxtChar *v199; // r0
  GxtChar *v200; // r0
  GxtChar *v201; // r0
  GxtChar *v202; // r0
  GxtChar *v203; // r0
  GxtChar *v204; // r0
  GxtChar *v205; // r0
  GxtChar *v206; // r0
  GxtChar *v207; // r0
  GxtChar *v208; // r0
  GxtChar *v209; // r0
  GxtChar *v210; // r0
  GxtChar *v211; // r0
  GxtChar *v212; // r0
  GxtChar *v213; // r0
  GxtChar *v214; // r0
  GxtChar *v215; // r0
  GxtChar *v216; // r0
  GxtChar *v217; // r0
  GxtChar *v218; // r0
  GxtChar *v219; // r0
  GxtChar *v220; // r0
  GxtChar *v221; // r0
  GxtChar *v222; // r0
  GxtChar *v223; // r0
  GxtChar *v224; // r0
  GxtChar *v225; // r0
  GxtChar *v226; // r0
  GxtChar *v227; // r0
  GxtChar *v228; // r0
  GxtChar *v229; // r0
  GxtChar *v230; // r0
  GxtChar *v231; // r0
  GxtChar *v232; // r0
  GxtChar *v233; // r0
  GxtChar *v234; // r0
  GxtChar *v235; // r0
  GxtChar *v236; // r0
  GxtChar *v237; // r0
  GxtChar *v238; // r0
  GxtChar *v239; // r0
  GxtChar *v240; // r0
  GxtChar *v241; // r0
  GxtChar *v242; // r0
  GxtChar *v243; // r0
  GxtChar *v244; // r0
  GxtChar *v245; // r0
  GxtChar *v246; // r0
  GxtChar *v247; // r0
  GxtChar *v248; // r0
  GxtChar *v249; // r0
  GxtChar *v250; // r0
  GxtChar *v251; // r0
  GxtChar *v252; // r0
  GxtChar *v253; // r0
  GxtChar *v254; // r0
  GxtChar *v255; // r0
  GxtChar *v256; // r0
  GxtChar *v257; // r0
  GxtChar *v258; // r0
  GxtChar *v259; // r0
  GxtChar *v260; // r0
  GxtChar *v261; // r0
  GxtChar *v262; // r0
  GxtChar *v263; // r0
  GxtChar *v264; // r0
  GxtChar *v265; // r0
  GxtChar *v266; // r0
  GxtChar *v267; // r0
  GxtChar *v268; // r0
  GxtChar *v269; // r0
  GxtChar *v270; // r0
  GxtChar *v271; // r0
  GxtChar *v272; // r0
  GxtChar *v273; // r0
  GxtChar *v274; // r0
  GxtChar *v275; // r0
  GxtChar *v276; // r0
  GxtChar *v277; // r0
  GxtChar *v278; // r0
  GxtChar *v279; // r0
  GxtChar *v280; // r0
  GxtChar *v281; // r0
  GxtChar *v282; // r0
  GxtChar *v283; // r0
  GxtChar *v284; // r0
  GxtChar *v285; // r0
  GxtChar *v286; // r0
  GxtChar *v287; // r0
  GxtChar *v288; // r0
  GxtChar *v289; // r0
  GxtChar *v290; // r0
  GxtChar *v291; // r0
  GxtChar *v292; // r0
  GxtChar *v293; // r0
  GxtChar *v294; // r0
  GxtChar *v295; // r0
  GxtChar *v296; // r0
  GxtChar *v297; // r0
  GxtChar *v298; // r0
  GxtChar *v299; // r0
  GxtChar *v300; // r0
  GxtChar *v301; // r0
  GxtChar *v302; // r0
  GxtChar *v303; // r0
  GxtChar *v304; // r0
  GxtChar *v305; // r0
  GxtChar *v306; // r0
  GxtChar *v307; // r0
  GxtChar *v308; // r0
  GxtChar *v309; // r0
  GxtChar *v310; // r0
  GxtChar *v311; // r0
  GxtChar *v312; // r0
  GxtChar *v313; // r0
  GxtChar *v314; // r0
  GxtChar *v315; // r0
  GxtChar *v316; // r0
  GxtChar *v317; // r0
  GxtChar *v318; // r0
  GxtChar *v319; // r0
  GxtChar *v320; // r0
  GxtChar *v321; // r0
  GxtChar *v322; // r0
  GxtChar *v323; // r0
  GxtChar *v324; // r0
  GxtChar *v325; // r0
  GxtChar *v326; // r0
  GxtChar *v327; // r0
  GxtChar *v328; // r0
  GxtChar *v329; // r0
  GxtChar *v330; // r0
  GxtChar *v331; // r0
  GxtChar *v332; // r0
  GxtChar *v333; // r0
  GxtChar *v334; // r0
  GxtChar *v335; // r0
  GxtChar *v336; // r0
  GxtChar *v337; // r0
  GxtChar *v338; // r0
  GxtChar *v339; // r0
  GxtChar *v340; // r0
  GxtChar *v341; // r0
  GxtChar *v342; // r0
  GxtChar *v343; // r0
  GxtChar *v344; // r0
  GxtChar *v345; // r0
  GxtChar *v346; // r0
  GxtChar *v347; // r0
  GxtChar *v348; // r0
  GxtChar *v349; // r0
  GxtChar *v350; // r0
  GxtChar *v351; // r0
  GxtChar *v352; // r0
  GxtChar *v353; // r0
  GxtChar *v354; // r0
  GxtChar *v355; // r0
  GxtChar *v356; // r0
  GxtChar *v357; // r0
  GxtChar *v358; // r0
  GxtChar *v359; // r0
  GxtChar *v360; // r0
  GxtChar *v361; // r0
  GxtChar *v362; // r0
  GxtChar *v363; // r0
  GxtChar *v364; // r0
  GxtChar *v365; // r0
  GxtChar *v366; // r0
  GxtChar *v367; // r0
  GxtChar *v368; // r0
  GxtChar *v369; // r0
  GxtChar *v370; // r0
  GxtChar *v371; // r0
  GxtChar *v372; // r0
  GxtChar *v373; // r0
  GxtChar *v374; // r0
  GxtChar *v375; // r0
  GxtChar *v376; // r0
  GxtChar *v377; // r0
  GxtChar *v378; // r0
  GxtChar *v379; // r0
  GxtChar *v380; // r0
  GxtChar *v381; // r0
  GxtChar *v382; // r0
  GxtChar *v383; // r0
  GxtChar *v384; // r0
  GxtChar *v385; // r0
  GxtChar *v386; // r0
  GxtChar *v387; // r0
  GxtChar *v388; // r0
  GxtChar *v389; // r0
  GxtChar *v390; // r0
  GxtChar *v391; // r0
  GxtChar *v392; // r0
  GxtChar *v393; // r0
  GxtChar *v394; // r0
  GxtChar *v395; // r0
  GxtChar *v396; // r0
  GxtChar *v397; // r0
  GxtChar *v398; // r0
  GxtChar *v399; // r0
  GxtChar *v400; // r0
  GxtChar *v401; // r0
  GxtChar *v402; // r0
  GxtChar *v403; // r0
  GxtChar *v404; // r0
  GxtChar *v405; // r0
  GxtChar *v406; // r0
  GxtChar *v407; // r0
  GxtChar *v408; // r0
  GxtChar *v409; // r0
  GxtChar *v410; // r0
  GxtChar *v411; // r0
  GxtChar *v412; // r0
  GxtChar *v413; // r0
  GxtChar *v414; // r0
  GxtChar *v415; // r0
  GxtChar *v416; // r0
  GxtChar *v417; // r0
  GxtChar *v418; // r0
  GxtChar *v419; // r0
  GxtChar *v420; // r0
  GxtChar *v421; // r0
  GxtChar *v422; // r0
  GxtChar *v423; // r0
  GxtChar *v424; // r0
  GxtChar *v425; // r0
  GxtChar *v426; // r0
  GxtChar *v427; // r0
  GxtChar *v428; // r0
  GxtChar *v429; // r0
  GxtChar *v430; // r0
  GxtChar *v431; // r0
  GxtChar *v432; // r0
  GxtChar *v433; // r0
  GxtChar *v434; // r0
  GxtChar *v435; // r0
  GxtChar *v436; // r0
  GxtChar *v437; // r0
  GxtChar *v438; // r0
  GxtChar *v439; // r0
  GxtChar *v440; // r0
  GxtChar *v441; // r0
  GxtChar *v442; // r0
  GxtChar *v443; // r0
  GxtChar *v444; // r0
  GxtChar *v445; // r0
  GxtChar *v446; // r0
  GxtChar *v447; // r0
  GxtChar *v448; // r0
  GxtChar *v449; // r0
  GxtChar *v450; // r0
  GxtChar *v451; // r0
  GxtChar *v452; // r0
  GxtChar *v453; // r0
  GxtChar *v454; // r0
  GxtChar *v455; // r0
  GxtChar *v456; // r0
  GxtChar *v457; // r0
  GxtChar *v458; // r0
  GxtChar *v459; // r0
  GxtChar *v460; // r0
  GxtChar *v461; // r0
  GxtChar *v462; // r0
  GxtChar *v463; // r0
  GxtChar *v464; // r0
  GxtChar *v465; // r0
  GxtChar *v466; // r0
  GxtChar *v467; // r0
  GxtChar *v468; // r0
  GxtChar *v469; // r0
  GxtChar *v470; // r0
  GxtChar *v471; // r0
  GxtChar *v472; // r0
  GxtChar *v473; // r0
  GxtChar *v474; // r0
  GxtChar *v475; // r0
  GxtChar *v476; // r0
  GxtChar *v477; // r0
  GxtChar *v478; // r0
  GxtChar *v479; // r0
  GxtChar *v480; // r0
  GxtChar *v481; // r0
  GxtChar *v482; // r0
  GxtChar *v483; // r0
  GxtChar *v484; // r0
  GxtChar *v485; // r0
  GxtChar *v486; // r0
  GxtChar *v487; // r0
  GxtChar *v488; // r0
  GxtChar *v489; // r0
  GxtChar *v490; // r0
  GxtChar *v491; // r0
  GxtChar *v492; // r0
  GxtChar *v493; // r0
  GxtChar *v494; // r0
  GxtChar *v495; // r0
  GxtChar *v496; // r0
  GxtChar *v497; // r0
  GxtChar *v498; // r0
  GxtChar *v499; // r0
  GxtChar *v500; // r0
  GxtChar *v501; // r0
  GxtChar *v502; // r0
  GxtChar *v503; // r0
  GxtChar *v504; // r0
  GxtChar *v505; // r0
  GxtChar *v506; // r0
  GxtChar *v507; // r0
  GxtChar *v508; // r0
  GxtChar *v509; // r0
  GxtChar *v510; // r0
  GxtChar *v511; // r0
  GxtChar *v512; // r0
  GxtChar *v513; // r0
  GxtChar *v514; // r0
  GxtChar *v515; // r0
  GxtChar *v516; // r0
  GxtChar *v517; // r0
  GxtChar *v518; // r0
  GxtChar *v519; // r0
  GxtChar *v520; // r0
  GxtChar *v521; // r0
  GxtChar *v522; // r0
  GxtChar *v523; // r0
  GxtChar *v524; // r0
  GxtChar *v525; // r0
  GxtChar *v526; // r0
  GxtChar *v527; // r0
  GxtChar *v528; // r0
  GxtChar *v529; // r0
  GxtChar *v530; // r0
  GxtChar *v531; // r0
  GxtChar *v532; // r0
  GxtChar *v533; // r0
  GxtChar *v534; // r0
  GxtChar *v535; // r0
  GxtChar *v536; // r0
  GxtChar *v537; // r0
  GxtChar *v538; // r0
  GxtChar *v539; // r0
  GxtChar *v540; // r0
  GxtChar *v541; // r0
  GxtChar *v542; // r0
  GxtChar *v543; // r0
  GxtChar *v544; // r0
  GxtChar *v545; // r0
  GxtChar *v546; // r0
  GxtChar *v547; // r0
  GxtChar *v548; // r0
  GxtChar *v549; // r0
  GxtChar *v550; // r0
  GxtChar *v551; // r0
  GxtChar *v552; // r0
  GxtChar *v553; // r0
  GxtChar *v554; // r0
  GxtChar *v555; // r0
  GxtChar *v556; // r0
  GxtChar *v557; // r0
  GxtChar *v558; // r0
  GxtChar *v559; // r0
  GxtChar *v560; // r0
  GxtChar *v561; // r0
  GxtChar *v562; // r0
  GxtChar *v563; // r0
  GxtChar *v564; // r0
  GxtChar *v565; // r0
  GxtChar *v566; // r0
  GxtChar *v567; // r0
  GxtChar *v568; // r0
  GxtChar *v569; // r0
  GxtChar *v570; // r0
  GxtChar *v571; // r0
  GxtChar *v572; // r0
  GxtChar *v573; // r0
  GxtChar *v574; // r0
  GxtChar *v575; // r0
  GxtChar *v576; // r0
  GxtChar *v577; // r0
  GxtChar *v578; // r0
  GxtChar *v579; // r0
  GxtChar *v580; // r0
  GxtChar *v581; // r0
  GxtChar *v582; // r0
  GxtChar *v583; // r0
  GxtChar *v584; // r0
  GxtChar *v585; // r0
  GxtChar *v586; // r0
  GxtChar *v587; // r0
  GxtChar *v588; // r0
  GxtChar *v589; // r0
  GxtChar *v590; // r0
  GxtChar *v591; // r0
  GxtChar *v592; // r0
  GxtChar *v593; // r0
  GxtChar *v594; // r0
  GxtChar *v595; // r0
  GxtChar *v596; // r0
  GxtChar *v597; // r0
  GxtChar *v598; // r0
  GxtChar *v599; // r0
  GxtChar *v600; // r0
  GxtChar *v601; // r0
  GxtChar *v602; // r0
  GxtChar *v603; // r0
  GxtChar *v604; // r0
  GxtChar *v605; // r0
  GxtChar *v606; // r0
  GxtChar *v607; // r0
  GxtChar *v608; // r0
  GxtChar *v609; // r0
  GxtChar *v610; // r0
  GxtChar *v611; // r0
  GxtChar *v612; // r0
  GxtChar *v613; // r0
  GxtChar *v614; // r0
  GxtChar *v615; // r0
  GxtChar *v616; // r0
  GxtChar *v617; // r0
  GxtChar *v618; // r0
  GxtChar *v619; // r0
  CRGBA v620; // [sp+8h] [bp-40h] BYREF
  UInt32 v621[15]; // [sp+Ch] [bp-3Ch] BYREF

  DefinedState2d();
  v621[0] = 0;
  v0 = CCredits::CreditsStartTime;
  v1 = CTimer::m_snTimeInMilliseconds;
  CFont::SetBackground(0, 0);
  CFont::SetCentreSize((float)RsGlobal.screenWidth * 0.92);
  CFont::SetOrientation(0);
  CFont::SetProportional(1u);
  CFont::SetFontStyle(1u);
  CFont::SetEdge(0);
  CRGBA::CRGBA(&v620, 0, 0, 0, 0xFFu);
  CFont::SetDropColor(v2);
  v3 = (float)(v1 - v0) / 23.0;
  v4 = CText::Get(&TheText, "CRED000");
  CCredits::PrintCreditText(*(float *)&v4, 1.1, v4, v621, v3, 1);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v5 = CText::Get(&TheText, "CRED001");
  CCredits::PrintCreditText(*(float *)&v5, 1.1, v5, v621, v3, 1);
  v6 = CText::Get(&TheText, "CRED002");
  CCredits::PrintCreditText(*(float *)&v6, 1.1, v6, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v7 = CText::Get(&TheText, "CRED003");
  CCredits::PrintCreditText(*(float *)&v7, 1.1, v7, v621, v3, 1);
  v8 = CText::Get(&TheText, "CRED004");
  CCredits::PrintCreditText(*(float *)&v8, 1.1, v8, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v9 = CText::Get(&TheText, "CRED005");
  CCredits::PrintCreditText(*(float *)&v9, 1.1, v9, v621, v3, 1);
  v10 = CText::Get(&TheText, "CRED006");
  CCredits::PrintCreditText(*(float *)&v10, 1.1, v10, v621, v3, 0);
  v11 = CText::Get(&TheText, "CRED007");
  CCredits::PrintCreditText(*(float *)&v11, 1.1, v11, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v12 = CText::Get(&TheText, "CRED008");
  CCredits::PrintCreditText(*(float *)&v12, 1.1, v12, v621, v3, 1);
  v13 = CText::Get(&TheText, "CRED009");
  CCredits::PrintCreditText(*(float *)&v13, 1.1, v13, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v14 = CText::Get(&TheText, "CRD009A");
  CCredits::PrintCreditText(*(float *)&v14, 1.1, v14, v621, v3, 1);
  v15 = CText::Get(&TheText, "CRD009B");
  CCredits::PrintCreditText(*(float *)&v15, 1.1, v15, v621, v3, 0);
  v16 = CText::Get(&TheText, "CRD009C");
  CCredits::PrintCreditText(*(float *)&v16, 1.1, v16, v621, v3, 0);
  v17 = CText::Get(&TheText, "CRD009D");
  CCredits::PrintCreditText(*(float *)&v17, 1.1, v17, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v18 = CText::Get(&TheText, "CRED019");
  CCredits::PrintCreditText(*(float *)&v18, 1.1, v18, v621, v3, 1);
  v19 = CText::Get(&TheText, "CRED020");
  CCredits::PrintCreditText(*(float *)&v19, 1.1, v19, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v20 = CText::Get(&TheText, "CRED010");
  CCredits::PrintCreditText(*(float *)&v20, 1.1, v20, v621, v3, 1);
  v21 = CText::Get(&TheText, "CRED011");
  CCredits::PrintCreditText(*(float *)&v21, 1.1, v21, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v22 = CText::Get(&TheText, "CRED012");
  CCredits::PrintCreditText(*(float *)&v22, 1.1, v22, v621, v3, 1);
  v23 = CText::Get(&TheText, "CRED013");
  CCredits::PrintCreditText(*(float *)&v23, 1.1, v23, v621, v3, 0);
  v24 = CText::Get(&TheText, "CRED014");
  CCredits::PrintCreditText(*(float *)&v24, 1.1, v24, v621, v3, 0);
  v25 = CText::Get(&TheText, "CRD014A");
  CCredits::PrintCreditText(*(float *)&v25, 1.1, v25, v621, v3, 0);
  v26 = CText::Get(&TheText, "CRED015");
  CCredits::PrintCreditText(*(float *)&v26, 1.1, v26, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v27 = CText::Get(&TheText, "CRED016");
  CCredits::PrintCreditText(*(float *)&v27, 1.1, v27, v621, v3, 1);
  v28 = CText::Get(&TheText, "CRD016A");
  CCredits::PrintCreditText(*(float *)&v28, 1.1, v28, v621, v3, 0);
  v29 = CText::Get(&TheText, "CRED017");
  CCredits::PrintCreditText(*(float *)&v29, 1.1, v29, v621, v3, 0);
  v30 = CText::Get(&TheText, "CRED018");
  CCredits::PrintCreditText(*(float *)&v30, 1.1, v30, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v31 = CText::Get(&TheText, "CRED028");
  CCredits::PrintCreditText(*(float *)&v31, 1.1, v31, v621, v3, 1);
  v32 = CText::Get(&TheText, "CRED029");
  CCredits::PrintCreditText(*(float *)&v32, 1.1, v32, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v33 = CText::Get(&TheText, "CRED030");
  CCredits::PrintCreditText(*(float *)&v33, 1.1, v33, v621, v3, 1);
  v34 = CText::Get(&TheText, "CRED031");
  CCredits::PrintCreditText(*(float *)&v34, 1.1, v34, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v35 = CText::Get(&TheText, "CRED032");
  CCredits::PrintCreditText(*(float *)&v35, 1.1, v35, v621, v3, 1);
  v36 = CText::Get(&TheText, "CRED033");
  CCredits::PrintCreditText(*(float *)&v36, 1.1, v36, v621, v3, 0);
  v37 = CText::Get(&TheText, "CRED034");
  CCredits::PrintCreditText(*(float *)&v37, 1.1, v37, v621, v3, 0);
  v38 = CText::Get(&TheText, "CRED035");
  CCredits::PrintCreditText(*(float *)&v38, 1.1, v38, v621, v3, 0);
  v39 = CText::Get(&TheText, "CRED036");
  CCredits::PrintCreditText(*(float *)&v39, 1.1, v39, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v40 = CText::Get(&TheText, "CRED047");
  CCredits::PrintCreditText(*(float *)&v40, 1.1, v40, v621, v3, 1);
  v41 = CText::Get(&TheText, "CRED048");
  CCredits::PrintCreditText(*(float *)&v41, 1.1, v41, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v42 = CText::Get(&TheText, "CRED049");
  CCredits::PrintCreditText(*(float *)&v42, 1.1, v42, v621, v3, 1);
  v43 = CText::Get(&TheText, "CRED050");
  CCredits::PrintCreditText(*(float *)&v43, 1.1, v43, v621, v3, 0);
  v44 = CText::Get(&TheText, "CRED051");
  CCredits::PrintCreditText(*(float *)&v44, 1.1, v44, v621, v3, 0);
  v45 = CText::Get(&TheText, "CRED052");
  CCredits::PrintCreditText(*(float *)&v45, 1.1, v45, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v46 = CText::Get(&TheText, "CRED053");
  CCredits::PrintCreditText(*(float *)&v46, 1.1, v46, v621, v3, 1);
  v47 = CText::Get(&TheText, "CRED054");
  CCredits::PrintCreditText(*(float *)&v47, 1.1, v47, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v48 = CText::Get(&TheText, "CRED055");
  CCredits::PrintCreditText(*(float *)&v48, 1.1, v48, v621, v3, 1);
  v49 = CText::Get(&TheText, "CRED056");
  CCredits::PrintCreditText(*(float *)&v49, 1.1, v49, v621, v3, 0);
  v50 = CText::Get(&TheText, "CRED057");
  CCredits::PrintCreditText(*(float *)&v50, 1.1, v50, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v51 = CText::Get(&TheText, "CRED058");
  CCredits::PrintCreditText(*(float *)&v51, 1.1, v51, v621, v3, 1);
  v52 = CText::Get(&TheText, "CRED059");
  CCredits::PrintCreditText(*(float *)&v52, 1.1, v52, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v53 = CText::Get(&TheText, "CRED060");
  CCredits::PrintCreditText(*(float *)&v53, 1.1, v53, v621, v3, 1);
  v54 = CText::Get(&TheText, "CRED061");
  CCredits::PrintCreditText(*(float *)&v54, 1.1, v54, v621, v3, 0);
  v55 = CText::Get(&TheText, "CRED062");
  CCredits::PrintCreditText(*(float *)&v55, 1.1, v55, v621, v3, 0);
  v56 = CText::Get(&TheText, "CRED063");
  CCredits::PrintCreditText(*(float *)&v56, 1.1, v56, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v57 = CText::Get(&TheText, "CRED021");
  CCredits::PrintCreditText(*(float *)&v57, 1.1, v57, v621, v3, 1);
  v58 = CText::Get(&TheText, "CRED022");
  CCredits::PrintCreditText(*(float *)&v58, 1.1, v58, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v59 = CText::Get(&TheText, "CRED023");
  CCredits::PrintCreditText(*(float *)&v59, 1.1, v59, v621, v3, 1);
  v60 = CText::Get(&TheText, "CRED024");
  CCredits::PrintCreditText(*(float *)&v60, 1.1, v60, v621, v3, 0);
  v61 = CText::Get(&TheText, "CRED025");
  CCredits::PrintCreditText(*(float *)&v61, 1.1, v61, v621, v3, 0);
  v62 = CText::Get(&TheText, "CRED026");
  CCredits::PrintCreditText(*(float *)&v62, 1.1, v62, v621, v3, 0);
  v63 = CText::Get(&TheText, "CRED027");
  CCredits::PrintCreditText(*(float *)&v63, 1.1, v63, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v64 = CText::Get(&TheText, "CRED064");
  CCredits::PrintCreditText(*(float *)&v64, 1.1, v64, v621, v3, 1);
  v65 = CText::Get(&TheText, "CRED065");
  CCredits::PrintCreditText(*(float *)&v65, 1.1, v65, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v66 = CText::Get(&TheText, "CRED066");
  CCredits::PrintCreditText(*(float *)&v66, 1.1, v66, v621, v3, 1);
  v67 = CText::Get(&TheText, "CRED067");
  CCredits::PrintCreditText(*(float *)&v67, 1.1, v67, v621, v3, 0);
  v68 = CText::Get(&TheText, "CRED068");
  CCredits::PrintCreditText(*(float *)&v68, 1.1, v68, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v69 = CText::Get(&TheText, "CRED069");
  CCredits::PrintCreditText(*(float *)&v69, 1.1, v69, v621, v3, 1);
  v70 = CText::Get(&TheText, "CRED070");
  CCredits::PrintCreditText(*(float *)&v70, 1.1, v70, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v71 = CText::Get(&TheText, "CRED071");
  CCredits::PrintCreditText(*(float *)&v71, 1.1, v71, v621, v3, 1);
  v72 = CText::Get(&TheText, "CRED072");
  CCredits::PrintCreditText(*(float *)&v72, 1.1, v72, v621, v3, 0);
  v73 = CText::Get(&TheText, "CRED073");
  CCredits::PrintCreditText(*(float *)&v73, 1.1, v73, v621, v3, 0);
  v74 = CText::Get(&TheText, "CRED074");
  CCredits::PrintCreditText(*(float *)&v74, 1.1, v74, v621, v3, 0);
  v75 = CText::Get(&TheText, "CRED075");
  CCredits::PrintCreditText(*(float *)&v75, 1.1, v75, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v76 = CText::Get(&TheText, "CRED037");
  CCredits::PrintCreditText(*(float *)&v76, 1.1, v76, v621, v3, 1);
  v77 = CText::Get(&TheText, "CRED038");
  CCredits::PrintCreditText(*(float *)&v77, 1.1, v77, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v78 = CText::Get(&TheText, "CRED039");
  CCredits::PrintCreditText(*(float *)&v78, 1.1, v78, v621, v3, 1);
  v79 = CText::Get(&TheText, "CRED040");
  CCredits::PrintCreditText(*(float *)&v79, 1.1, v79, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v80 = CText::Get(&TheText, "CRED041");
  CCredits::PrintCreditText(*(float *)&v80, 1.1, v80, v621, v3, 1);
  v81 = CText::Get(&TheText, "CRED042");
  CCredits::PrintCreditText(*(float *)&v81, 1.1, v81, v621, v3, 0);
  v82 = CText::Get(&TheText, "CRED043");
  CCredits::PrintCreditText(*(float *)&v82, 1.1, v82, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v83 = CText::Get(&TheText, "CRED044");
  CCredits::PrintCreditText(*(float *)&v83, 1.1, v83, v621, v3, 1);
  v84 = CText::Get(&TheText, "CRED991");
  CCredits::PrintCreditText(*(float *)&v84, 1.1, v84, v621, v3, 0);
  v85 = CText::Get(&TheText, "CRED045");
  CCredits::PrintCreditText(*(float *)&v85, 1.1, v85, v621, v3, 0);
  v86 = CText::Get(&TheText, "CRED046");
  CCredits::PrintCreditText(*(float *)&v86, 1.1, v86, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v87 = CText::Get(&TheText, "CRED076");
  CCredits::PrintCreditText(*(float *)&v87, 1.1, v87, v621, v3, 1);
  v88 = CText::Get(&TheText, "CRED077");
  CCredits::PrintCreditText(*(float *)&v88, 1.1, v88, v621, v3, 0);
  v89 = CText::Get(&TheText, "CRED078");
  CCredits::PrintCreditText(*(float *)&v89, 1.1, v89, v621, v3, 0);
  v90 = CText::Get(&TheText, "CRED079");
  CCredits::PrintCreditText(*(float *)&v90, 1.1, v90, v621, v3, 0);
  v91 = CText::Get(&TheText, "CRED080");
  CCredits::PrintCreditText(*(float *)&v91, 1.1, v91, v621, v3, 0);
  v92 = CText::Get(&TheText, "CRED081");
  CCredits::PrintCreditText(*(float *)&v92, 1.1, v92, v621, v3, 0);
  v93 = CText::Get(&TheText, "CRED100");
  CCredits::PrintCreditText(*(float *)&v93, 1.1, v93, v621, v3, 0);
  v94 = CText::Get(&TheText, "CRED082");
  CCredits::PrintCreditText(*(float *)&v94, 1.1, v94, v621, v3, 0);
  v95 = CText::Get(&TheText, "CRED083");
  CCredits::PrintCreditText(*(float *)&v95, 1.1, v95, v621, v3, 0);
  v96 = CText::Get(&TheText, "CRED084");
  CCredits::PrintCreditText(*(float *)&v96, 1.1, v96, v621, v3, 0);
  v97 = CText::Get(&TheText, "CRED085");
  CCredits::PrintCreditText(*(float *)&v97, 1.1, v97, v621, v3, 0);
  v98 = CText::Get(&TheText, "CRED086");
  CCredits::PrintCreditText(*(float *)&v98, 1.1, v98, v621, v3, 0);
  v99 = CText::Get(&TheText, "CRED087");
  CCredits::PrintCreditText(*(float *)&v99, 1.1, v99, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v100 = CText::Get(&TheText, "CRED088");
  CCredits::PrintCreditText(*(float *)&v100, 1.1, v100, v621, v3, 1);
  v101 = CText::Get(&TheText, "CRED089");
  CCredits::PrintCreditText(*(float *)&v101, 1.1, v101, v621, v3, 0);
  v102 = CText::Get(&TheText, "CRED090");
  CCredits::PrintCreditText(*(float *)&v102, 1.1, v102, v621, v3, 0);
  v103 = CText::Get(&TheText, "CRED091");
  CCredits::PrintCreditText(*(float *)&v103, 1.1, v103, v621, v3, 0);
  v104 = CText::Get(&TheText, "CRED092");
  CCredits::PrintCreditText(*(float *)&v104, 1.1, v104, v621, v3, 0);
  v105 = CText::Get(&TheText, "CRED093");
  CCredits::PrintCreditText(*(float *)&v105, 1.1, v105, v621, v3, 0);
  v106 = CText::Get(&TheText, "CRED094");
  CCredits::PrintCreditText(*(float *)&v106, 1.1, v106, v621, v3, 0);
  v107 = CText::Get(&TheText, "CRED095");
  CCredits::PrintCreditText(*(float *)&v107, 1.1, v107, v621, v3, 0);
  v108 = CText::Get(&TheText, "CRED096");
  CCredits::PrintCreditText(*(float *)&v108, 1.1, v108, v621, v3, 0);
  v109 = CText::Get(&TheText, "CRED097");
  CCredits::PrintCreditText(*(float *)&v109, 1.1, v109, v621, v3, 0);
  v110 = CText::Get(&TheText, "CRED098");
  CCredits::PrintCreditText(*(float *)&v110, 1.1, v110, v621, v3, 0);
  v111 = CText::Get(&TheText, "CRED099");
  CCredits::PrintCreditText(*(float *)&v111, 1.1, v111, v621, v3, 0);
  v112 = CText::Get(&TheText, "CRED101");
  CCredits::PrintCreditText(*(float *)&v112, 1.1, v112, v621, v3, 0);
  v113 = CText::Get(&TheText, "CRED102");
  CCredits::PrintCreditText(*(float *)&v113, 1.1, v113, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v114 = CText::Get(&TheText, "CRED103");
  CCredits::PrintCreditText(*(float *)&v114, 1.1, v114, v621, v3, 1);
  v115 = CText::Get(&TheText, "CRED104");
  CCredits::PrintCreditText(*(float *)&v115, 1.1, v115, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v116 = CText::Get(&TheText, "CRED105");
  CCredits::PrintCreditText(*(float *)&v116, 1.1, v116, v621, v3, 1);
  v117 = CText::Get(&TheText, "CRED106");
  CCredits::PrintCreditText(*(float *)&v117, 1.1, v117, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v118 = CText::Get(&TheText, "CRED107");
  CCredits::PrintCreditText(*(float *)&v118, 1.1, v118, v621, v3, 1);
  v119 = CText::Get(&TheText, "CRED108");
  CCredits::PrintCreditText(*(float *)&v119, 1.1, v119, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v120 = CText::Get(&TheText, "CRED109");
  CCredits::PrintCreditText(*(float *)&v120, 1.1, v120, v621, v3, 1);
  v121 = CText::Get(&TheText, "CRED110");
  CCredits::PrintCreditText(*(float *)&v121, 1.1, v121, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v122 = CText::Get(&TheText, "CRED111");
  CCredits::PrintCreditText(*(float *)&v122, 1.1, v122, v621, v3, 1);
  v621[0] = (unsigned int)(float)((float)v621[0] + 25.0);
  v123 = CText::Get(&TheText, "CRED112");
  CCredits::PrintCreditText(*(float *)&v123, 1.1, v123, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v124 = CText::Get(&TheText, "CRED113");
  CCredits::PrintCreditText(*(float *)&v124, 1.1, v124, v621, v3, 1);
  v125 = CText::Get(&TheText, "CRED114");
  CCredits::PrintCreditText(*(float *)&v125, 1.1, v125, v621, v3, 0);
  v126 = CText::Get(&TheText, "CRED115");
  CCredits::PrintCreditText(*(float *)&v126, 1.1, v126, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v127 = CText::Get(&TheText, "CRED116");
  CCredits::PrintCreditText(*(float *)&v127, 1.1, v127, v621, v3, 1);
  v128 = CText::Get(&TheText, "CRED117");
  CCredits::PrintCreditText(*(float *)&v128, 1.1, v128, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v129 = CText::Get(&TheText, "CRED118");
  CCredits::PrintCreditText(*(float *)&v129, 1.1, v129, v621, v3, 1);
  v130 = CText::Get(&TheText, "CRED997");
  CCredits::PrintCreditText(*(float *)&v130, 1.1, v130, v621, v3, 0);
  v131 = CText::Get(&TheText, "CRD118A");
  CCredits::PrintCreditText(*(float *)&v131, 1.1, v131, v621, v3, 0);
  v132 = CText::Get(&TheText, "CRED119");
  CCredits::PrintCreditText(*(float *)&v132, 1.1, v132, v621, v3, 0);
  v133 = CText::Get(&TheText, "CRED120");
  CCredits::PrintCreditText(*(float *)&v133, 1.1, v133, v621, v3, 0);
  v134 = CText::Get(&TheText, "CRED996");
  CCredits::PrintCreditText(*(float *)&v134, 1.1, v134, v621, v3, 0);
  v135 = CText::Get(&TheText, "CRD120A");
  CCredits::PrintCreditText(*(float *)&v135, 1.1, v135, v621, v3, 0);
  v136 = CText::Get(&TheText, "CRED121");
  CCredits::PrintCreditText(*(float *)&v136, 1.1, v136, v621, v3, 0);
  v137 = CText::Get(&TheText, "CRD121A");
  CCredits::PrintCreditText(*(float *)&v137, 1.1, v137, v621, v3, 0);
  v138 = CText::Get(&TheText, "CRED995");
  CCredits::PrintCreditText(*(float *)&v138, 1.1, v138, v621, v3, 0);
  v139 = CText::Get(&TheText, "CRED122");
  CCredits::PrintCreditText(*(float *)&v139, 1.1, v139, v621, v3, 0);
  v140 = CText::Get(&TheText, "CRED994");
  CCredits::PrintCreditText(*(float *)&v140, 1.1, v140, v621, v3, 0);
  v141 = CText::Get(&TheText, "CRED123");
  CCredits::PrintCreditText(*(float *)&v141, 1.1, v141, v621, v3, 0);
  v142 = CText::Get(&TheText, "CRED124");
  CCredits::PrintCreditText(*(float *)&v142, 1.1, v142, v621, v3, 0);
  v143 = CText::Get(&TheText, "CRED125");
  CCredits::PrintCreditText(*(float *)&v143, 1.1, v143, v621, v3, 0);
  v144 = CText::Get(&TheText, "CRED126");
  CCredits::PrintCreditText(*(float *)&v144, 1.1, v144, v621, v3, 0);
  v145 = CText::Get(&TheText, "CRD126A");
  CCredits::PrintCreditText(*(float *)&v145, 1.1, v145, v621, v3, 0);
  v146 = CText::Get(&TheText, "CRD126B");
  CCredits::PrintCreditText(*(float *)&v146, 1.1, v146, v621, v3, 0);
  v147 = CText::Get(&TheText, "CRED127");
  CCredits::PrintCreditText(*(float *)&v147, 1.1, v147, v621, v3, 0);
  v148 = CText::Get(&TheText, "CRED128");
  CCredits::PrintCreditText(*(float *)&v148, 1.1, v148, v621, v3, 0);
  v149 = CText::Get(&TheText, "CRED129");
  CCredits::PrintCreditText(*(float *)&v149, 1.1, v149, v621, v3, 0);
  v150 = CText::Get(&TheText, "CRD129A");
  CCredits::PrintCreditText(*(float *)&v150, 1.1, v150, v621, v3, 0);
  v151 = CText::Get(&TheText, "CRED130");
  CCredits::PrintCreditText(*(float *)&v151, 1.1, v151, v621, v3, 0);
  v152 = CText::Get(&TheText, "CRED131");
  CCredits::PrintCreditText(*(float *)&v152, 1.1, v152, v621, v3, 0);
  v153 = CText::Get(&TheText, "CRED132");
  CCredits::PrintCreditText(*(float *)&v153, 1.1, v153, v621, v3, 0);
  v154 = CText::Get(&TheText, "CRED133");
  CCredits::PrintCreditText(*(float *)&v154, 1.1, v154, v621, v3, 0);
  v155 = CText::Get(&TheText, "CRED134");
  CCredits::PrintCreditText(*(float *)&v155, 1.1, v155, v621, v3, 0);
  v156 = CText::Get(&TheText, "CRED992");
  CCredits::PrintCreditText(*(float *)&v156, 1.1, v156, v621, v3, 0);
  v157 = CText::Get(&TheText, "CRD134A");
  CCredits::PrintCreditText(*(float *)&v157, 1.1, v157, v621, v3, 0);
  v158 = CText::Get(&TheText, "CRED135");
  CCredits::PrintCreditText(*(float *)&v158, 1.1, v158, v621, v3, 0);
  v159 = CText::Get(&TheText, "CRED136");
  CCredits::PrintCreditText(*(float *)&v159, 1.1, v159, v621, v3, 0);
  v160 = CText::Get(&TheText, "CRD136A");
  CCredits::PrintCreditText(*(float *)&v160, 1.1, v160, v621, v3, 0);
  v161 = CText::Get(&TheText, "CRED137");
  CCredits::PrintCreditText(*(float *)&v161, 1.1, v161, v621, v3, 0);
  v162 = CText::Get(&TheText, "CRED138");
  CCredits::PrintCreditText(*(float *)&v162, 1.1, v162, v621, v3, 0);
  v163 = CText::Get(&TheText, "CRD138A");
  CCredits::PrintCreditText(*(float *)&v163, 1.1, v163, v621, v3, 0);
  v164 = CText::Get(&TheText, "CRED139");
  CCredits::PrintCreditText(*(float *)&v164, 1.1, v164, v621, v3, 0);
  v165 = CText::Get(&TheText, "CRED140");
  CCredits::PrintCreditText(*(float *)&v165, 1.1, v165, v621, v3, 0);
  v166 = CText::Get(&TheText, "CRED141");
  CCredits::PrintCreditText(*(float *)&v166, 1.1, v166, v621, v3, 0);
  v167 = CText::Get(&TheText, "CRED993");
  CCredits::PrintCreditText(*(float *)&v167, 1.1, v167, v621, v3, 0);
  v168 = CText::Get(&TheText, "CRED142");
  CCredits::PrintCreditText(*(float *)&v168, 1.1, v168, v621, v3, 0);
  v169 = CText::Get(&TheText, "CRED143");
  CCredits::PrintCreditText(*(float *)&v169, 1.1, v169, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v170 = CText::Get(&TheText, "CRED144");
  CCredits::PrintCreditText(*(float *)&v170, 1.1, v170, v621, v3, 1);
  v171 = CText::Get(&TheText, "CRED145");
  CCredits::PrintCreditText(*(float *)&v171, 1.1, v171, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v172 = CText::Get(&TheText, "CRED146");
  CCredits::PrintCreditText(*(float *)&v172, 1.1, v172, v621, v3, 1);
  v173 = CText::Get(&TheText, "CRED147");
  CCredits::PrintCreditText(*(float *)&v173, 1.1, v173, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v174 = CText::Get(&TheText, "CRED148");
  CCredits::PrintCreditText(*(float *)&v174, 1.1, v174, v621, v3, 1);
  v175 = CText::Get(&TheText, "CRED149");
  CCredits::PrintCreditText(*(float *)&v175, 1.1, v175, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v176 = CText::Get(&TheText, "CRED150");
  CCredits::PrintCreditText(*(float *)&v176, 1.1, v176, v621, v3, 1);
  v177 = CText::Get(&TheText, "CRED151");
  CCredits::PrintCreditText(*(float *)&v177, 1.1, v177, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v178 = CText::Get(&TheText, "CRED152");
  CCredits::PrintCreditText(*(float *)&v178, 1.1, v178, v621, v3, 1);
  v179 = CText::Get(&TheText, "CRED153");
  CCredits::PrintCreditText(*(float *)&v179, 1.1, v179, v621, v3, 0);
  v180 = CText::Get(&TheText, "CRD153A");
  CCredits::PrintCreditText(*(float *)&v180, 1.1, v180, v621, v3, 0);
  v181 = CText::Get(&TheText, "CRED154");
  CCredits::PrintCreditText(*(float *)&v181, 1.1, v181, v621, v3, 0);
  v182 = CText::Get(&TheText, "CRD154A");
  CCredits::PrintCreditText(*(float *)&v182, 1.1, v182, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v183 = CText::Get(&TheText, "CRED155");
  CCredits::PrintCreditText(*(float *)&v183, 1.1, v183, v621, v3, 1);
  v184 = CText::Get(&TheText, "CRED156");
  CCredits::PrintCreditText(*(float *)&v184, 1.1, v184, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v185 = CText::Get(&TheText, "CRED157");
  CCredits::PrintCreditText(*(float *)&v185, 1.1, v185, v621, v3, 1);
  v186 = CText::Get(&TheText, "CRED158");
  CCredits::PrintCreditText(*(float *)&v186, 1.1, v186, v621, v3, 0);
  v187 = CText::Get(&TheText, "CRED159");
  CCredits::PrintCreditText(*(float *)&v187, 1.1, v187, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)(unsigned int)(float)((float)v621[0] + 37.5) + 37.5);
  v188 = CText::Get(&TheText, "CRED199");
  CCredits::PrintCreditText(*(float *)&v188, 1.1, v188, v621, v3, 1);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v189 = CText::Get(&TheText, "CRED200");
  CCredits::PrintCreditText(*(float *)&v189, 1.1, v189, v621, v3, 1);
  v190 = CText::Get(&TheText, "CRED201");
  CCredits::PrintCreditText(*(float *)&v190, 1.1, v190, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v191 = CText::Get(&TheText, "CRED202");
  CCredits::PrintCreditText(*(float *)&v191, 1.1, v191, v621, v3, 1);
  v192 = CText::Get(&TheText, "CRED203");
  CCredits::PrintCreditText(*(float *)&v192, 1.1, v192, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v193 = CText::Get(&TheText, "CRED204");
  CCredits::PrintCreditText(*(float *)&v193, 1.1, v193, v621, v3, 1);
  v194 = CText::Get(&TheText, "CRED205");
  CCredits::PrintCreditText(*(float *)&v194, 1.1, v194, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v195 = CText::Get(&TheText, "CRED206");
  CCredits::PrintCreditText(*(float *)&v195, 1.1, v195, v621, v3, 1);
  v196 = CText::Get(&TheText, "CRED207");
  CCredits::PrintCreditText(*(float *)&v196, 1.1, v196, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v197 = CText::Get(&TheText, "CRED208");
  CCredits::PrintCreditText(*(float *)&v197, 1.1, v197, v621, v3, 1);
  v198 = CText::Get(&TheText, "CRED209");
  CCredits::PrintCreditText(*(float *)&v198, 1.1, v198, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v199 = CText::Get(&TheText, "CRED210");
  CCredits::PrintCreditText(*(float *)&v199, 1.1, v199, v621, v3, 1);
  v200 = CText::Get(&TheText, "CRED211");
  CCredits::PrintCreditText(*(float *)&v200, 1.1, v200, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v201 = CText::Get(&TheText, "CRED212");
  CCredits::PrintCreditText(*(float *)&v201, 1.1, v201, v621, v3, 1);
  v202 = CText::Get(&TheText, "CRED213");
  CCredits::PrintCreditText(*(float *)&v202, 1.1, v202, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v203 = CText::Get(&TheText, "CRED214");
  CCredits::PrintCreditText(*(float *)&v203, 1.1, v203, v621, v3, 1);
  v204 = CText::Get(&TheText, "CRED215");
  CCredits::PrintCreditText(*(float *)&v204, 1.1, v204, v621, v3, 0);
  v205 = CText::Get(&TheText, "CRED216");
  CCredits::PrintCreditText(*(float *)&v205, 1.1, v205, v621, v3, 0);
  v206 = CText::Get(&TheText, "CRED217");
  CCredits::PrintCreditText(*(float *)&v206, 1.1, v206, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v207 = CText::Get(&TheText, "CRED218");
  CCredits::PrintCreditText(*(float *)&v207, 1.1, v207, v621, v3, 1);
  v208 = CText::Get(&TheText, "CRED219");
  CCredits::PrintCreditText(*(float *)&v208, 1.1, v208, v621, v3, 0);
  v209 = CText::Get(&TheText, "CRED220");
  CCredits::PrintCreditText(*(float *)&v209, 1.1, v209, v621, v3, 0);
  v210 = CText::Get(&TheText, "CRED221");
  CCredits::PrintCreditText(*(float *)&v210, 1.1, v210, v621, v3, 0);
  v211 = CText::Get(&TheText, "CRED222");
  CCredits::PrintCreditText(*(float *)&v211, 1.1, v211, v621, v3, 0);
  v212 = CText::Get(&TheText, "CRED223");
  CCredits::PrintCreditText(*(float *)&v212, 1.1, v212, v621, v3, 0);
  v213 = CText::Get(&TheText, "CRED224");
  CCredits::PrintCreditText(*(float *)&v213, 1.1, v213, v621, v3, 0);
  v214 = CText::Get(&TheText, "CRED225");
  CCredits::PrintCreditText(*(float *)&v214, 1.1, v214, v621, v3, 0);
  v215 = CText::Get(&TheText, "CRED226");
  CCredits::PrintCreditText(*(float *)&v215, 1.1, v215, v621, v3, 0);
  v216 = CText::Get(&TheText, "CRED227");
  CCredits::PrintCreditText(*(float *)&v216, 1.1, v216, v621, v3, 0);
  v217 = CText::Get(&TheText, "CRED228");
  CCredits::PrintCreditText(*(float *)&v217, 1.1, v217, v621, v3, 0);
  v218 = CText::Get(&TheText, "CRED229");
  CCredits::PrintCreditText(*(float *)&v218, 1.1, v218, v621, v3, 0);
  v219 = CText::Get(&TheText, "CRED230");
  CCredits::PrintCreditText(*(float *)&v219, 1.1, v219, v621, v3, 0);
  v220 = CText::Get(&TheText, "CRED231");
  CCredits::PrintCreditText(*(float *)&v220, 1.1, v220, v621, v3, 0);
  v221 = CText::Get(&TheText, "CRED232");
  CCredits::PrintCreditText(*(float *)&v221, 1.1, v221, v621, v3, 0);
  v222 = CText::Get(&TheText, "CRED233");
  CCredits::PrintCreditText(*(float *)&v222, 1.1, v222, v621, v3, 0);
  v223 = CText::Get(&TheText, "CRED234");
  CCredits::PrintCreditText(*(float *)&v223, 1.1, v223, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v224 = CText::Get(&TheText, "CRED235");
  CCredits::PrintCreditText(*(float *)&v224, 1.1, v224, v621, v3, 1);
  v225 = CText::Get(&TheText, "CRED236");
  CCredits::PrintCreditText(*(float *)&v225, 1.1, v225, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v226 = CText::Get(&TheText, "CRED237");
  CCredits::PrintCreditText(*(float *)&v226, 1.1, v226, v621, v3, 1);
  v227 = CText::Get(&TheText, "CRED238");
  CCredits::PrintCreditText(*(float *)&v227, 1.1, v227, v621, v3, 0);
  v228 = CText::Get(&TheText, "CRED239");
  CCredits::PrintCreditText(*(float *)&v228, 1.1, v228, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v229 = CText::Get(&TheText, "CRED240");
  CCredits::PrintCreditText(*(float *)&v229, 1.1, v229, v621, v3, 1);
  v230 = CText::Get(&TheText, "CRED241");
  CCredits::PrintCreditText(*(float *)&v230, 1.1, v230, v621, v3, 0);
  v231 = CText::Get(&TheText, "CRED242");
  CCredits::PrintCreditText(*(float *)&v231, 1.1, v231, v621, v3, 0);
  v232 = CText::Get(&TheText, "CRED243");
  CCredits::PrintCreditText(*(float *)&v232, 1.1, v232, v621, v3, 0);
  v233 = CText::Get(&TheText, "CRED244");
  CCredits::PrintCreditText(*(float *)&v233, 1.1, v233, v621, v3, 0);
  v234 = CText::Get(&TheText, "CRED245");
  CCredits::PrintCreditText(*(float *)&v234, 1.1, v234, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v235 = CText::Get(&TheText, "CRED246");
  CCredits::PrintCreditText(*(float *)&v235, 1.1, v235, v621, v3, 1);
  v236 = CText::Get(&TheText, "CRED247");
  CCredits::PrintCreditText(*(float *)&v236, 1.1, v236, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v237 = CText::Get(&TheText, "CRED248");
  CCredits::PrintCreditText(*(float *)&v237, 1.1, v237, v621, v3, 1);
  v238 = CText::Get(&TheText, "CRED249");
  CCredits::PrintCreditText(*(float *)&v238, 1.1, v238, v621, v3, 0);
  v239 = CText::Get(&TheText, "CRED250");
  CCredits::PrintCreditText(*(float *)&v239, 1.1, v239, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v240 = CText::Get(&TheText, "CRED251");
  CCredits::PrintCreditText(*(float *)&v240, 1.1, v240, v621, v3, 1);
  v241 = CText::Get(&TheText, "CRED252");
  CCredits::PrintCreditText(*(float *)&v241, 1.1, v241, v621, v3, 0);
  v242 = CText::Get(&TheText, "CRED253");
  CCredits::PrintCreditText(*(float *)&v242, 1.1, v242, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v243 = CText::Get(&TheText, "CRED254");
  CCredits::PrintCreditText(*(float *)&v243, 1.1, v243, v621, v3, 1);
  v244 = CText::Get(&TheText, "CRED255");
  CCredits::PrintCreditText(*(float *)&v244, 1.1, v244, v621, v3, 0);
  v245 = CText::Get(&TheText, "CRED256");
  CCredits::PrintCreditText(*(float *)&v245, 1.1, v245, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v246 = CText::Get(&TheText, "CRED257");
  CCredits::PrintCreditText(*(float *)&v246, 1.1, v246, v621, v3, 1);
  v247 = CText::Get(&TheText, "CRED258");
  CCredits::PrintCreditText(*(float *)&v247, 1.1, v247, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v248 = CText::Get(&TheText, "CRED259");
  CCredits::PrintCreditText(*(float *)&v248, 1.1, v248, v621, v3, 1);
  v249 = CText::Get(&TheText, "CRED260");
  CCredits::PrintCreditText(*(float *)&v249, 1.1, v249, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v250 = CText::Get(&TheText, "CRED261");
  CCredits::PrintCreditText(*(float *)&v250, 1.1, v250, v621, v3, 1);
  v621[0] = (unsigned int)(float)((float)v621[0] + 25.0);
  v251 = CText::Get(&TheText, "CRED262");
  CCredits::PrintCreditText(*(float *)&v251, 1.1, v251, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v252 = CText::Get(&TheText, "CRED263");
  CCredits::PrintCreditText(*(float *)&v252, 1.1, v252, v621, v3, 1);
  v253 = CText::Get(&TheText, "CRED264");
  CCredits::PrintCreditText(*(float *)&v253, 1.1, v253, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v254 = CText::Get(&TheText, "CRED265");
  CCredits::PrintCreditText(*(float *)&v254, 1.1, v254, v621, v3, 1);
  v255 = CText::Get(&TheText, "CRED266");
  CCredits::PrintCreditText(*(float *)&v255, 1.1, v255, v621, v3, 0);
  v256 = CText::Get(&TheText, "CRED267");
  CCredits::PrintCreditText(*(float *)&v256, 1.1, v256, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v257 = CText::Get(&TheText, "CRED999");
  CCredits::PrintCreditText(*(float *)&v257, 1.1, v257, v621, v3, 1);
  v621[0] = (unsigned int)(float)((float)v621[0] + 25.0);
  v258 = CText::Get(&TheText, "CRED998");
  CCredits::PrintCreditText(*(float *)&v258, 1.1, v258, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v259 = CText::Get(&TheText, "CRED268");
  CCredits::PrintCreditText(*(float *)&v259, 1.1, v259, v621, v3, 1);
  v260 = CText::Get(&TheText, "CRED269");
  CCredits::PrintCreditText(*(float *)&v260, 1.1, v260, v621, v3, 0);
  v261 = CText::Get(&TheText, "CRED270");
  CCredits::PrintCreditText(*(float *)&v261, 1.1, v261, v621, v3, 0);
  v262 = CText::Get(&TheText, "CRED271");
  CCredits::PrintCreditText(*(float *)&v262, 1.1, v262, v621, v3, 0);
  v263 = CText::Get(&TheText, "CRED272");
  CCredits::PrintCreditText(*(float *)&v263, 1.1, v263, v621, v3, 0);
  v264 = CText::Get(&TheText, "CRED273");
  CCredits::PrintCreditText(*(float *)&v264, 1.1, v264, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v265 = CText::Get(&TheText, "CRED274");
  CCredits::PrintCreditText(*(float *)&v265, 1.1, v265, v621, v3, 1);
  v266 = CText::Get(&TheText, "CRED275");
  CCredits::PrintCreditText(*(float *)&v266, 1.1, v266, v621, v3, 0);
  v267 = CText::Get(&TheText, "CRED276");
  CCredits::PrintCreditText(*(float *)&v267, 1.1, v267, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)(unsigned int)(float)((float)v621[0] + 37.5) + 37.5);
  v268 = CText::Get(&TheText, "CRED277");
  CCredits::PrintCreditText(*(float *)&v268, 1.1, v268, v621, v3, 1);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v269 = CText::Get(&TheText, "CRED278");
  CCredits::PrintCreditText(*(float *)&v269, 1.1, v269, v621, v3, 1);
  v270 = CText::Get(&TheText, "CRED279");
  CCredits::PrintCreditText(*(float *)&v270, 0.78, v270, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 12.5);
  v271 = CText::Get(&TheText, "CRED280");
  CCredits::PrintCreditText(*(float *)&v271, 0.78, v271, v621, v3, 0);
  v272 = CText::Get(&TheText, "CRED281");
  CCredits::PrintCreditText(*(float *)&v272, 0.78, v272, v621, v3, 0);
  v273 = CText::Get(&TheText, "CRED282");
  CCredits::PrintCreditText(*(float *)&v273, 0.78, v273, v621, v3, 0);
  v274 = CText::Get(&TheText, "CRED283");
  CCredits::PrintCreditText(*(float *)&v274, 0.78, v274, v621, v3, 0);
  v275 = CText::Get(&TheText, "CRED284");
  CCredits::PrintCreditText(*(float *)&v275, 0.78, v275, v621, v3, 0);
  v276 = CText::Get(&TheText, "CRED285");
  CCredits::PrintCreditText(*(float *)&v276, 0.78, v276, v621, v3, 0);
  v277 = CText::Get(&TheText, "CRED286");
  CCredits::PrintCreditText(*(float *)&v277, 0.78, v277, v621, v3, 0);
  v278 = CText::Get(&TheText, "CRED287");
  CCredits::PrintCreditText(*(float *)&v278, 0.78, v278, v621, v3, 0);
  v279 = CText::Get(&TheText, "CRED288");
  CCredits::PrintCreditText(*(float *)&v279, 0.78, v279, v621, v3, 0);
  v280 = CText::Get(&TheText, "CRED289");
  CCredits::PrintCreditText(*(float *)&v280, 0.78, v280, v621, v3, 0);
  v281 = CText::Get(&TheText, "CRED290");
  CCredits::PrintCreditText(*(float *)&v281, 0.78, v281, v621, v3, 0);
  v282 = CText::Get(&TheText, "CRED291");
  CCredits::PrintCreditText(*(float *)&v282, 0.78, v282, v621, v3, 0);
  v283 = CText::Get(&TheText, "CRED292");
  CCredits::PrintCreditText(*(float *)&v283, 0.78, v283, v621, v3, 0);
  v284 = CText::Get(&TheText, "CRED293");
  CCredits::PrintCreditText(*(float *)&v284, 0.78, v284, v621, v3, 0);
  v285 = CText::Get(&TheText, "CRED294");
  CCredits::PrintCreditText(*(float *)&v285, 0.78, v285, v621, v3, 0);
  v286 = CText::Get(&TheText, "CRED295");
  CCredits::PrintCreditText(*(float *)&v286, 0.78, v286, v621, v3, 0);
  v287 = CText::Get(&TheText, "CRED296");
  CCredits::PrintCreditText(*(float *)&v287, 0.78, v287, v621, v3, 0);
  v288 = CText::Get(&TheText, "CRED297");
  CCredits::PrintCreditText(*(float *)&v288, 0.78, v288, v621, v3, 0);
  v289 = CText::Get(&TheText, "CRED298");
  CCredits::PrintCreditText(*(float *)&v289, 0.78, v289, v621, v3, 0);
  v290 = CText::Get(&TheText, "CRED299");
  CCredits::PrintCreditText(*(float *)&v290, 0.78, v290, v621, v3, 0);
  v291 = CText::Get(&TheText, "CRED300");
  CCredits::PrintCreditText(*(float *)&v291, 0.78, v291, v621, v3, 0);
  v292 = CText::Get(&TheText, "CRED301");
  CCredits::PrintCreditText(*(float *)&v292, 0.78, v292, v621, v3, 0);
  v293 = CText::Get(&TheText, "CRED302");
  CCredits::PrintCreditText(*(float *)&v293, 0.78, v293, v621, v3, 0);
  v294 = CText::Get(&TheText, "CRED303");
  CCredits::PrintCreditText(*(float *)&v294, 0.78, v294, v621, v3, 0);
  v295 = CText::Get(&TheText, "CRED304");
  CCredits::PrintCreditText(*(float *)&v295, 0.78, v295, v621, v3, 0);
  v296 = CText::Get(&TheText, "CRED305");
  CCredits::PrintCreditText(*(float *)&v296, 0.78, v296, v621, v3, 0);
  v297 = CText::Get(&TheText, "CRED306");
  CCredits::PrintCreditText(*(float *)&v297, 0.78, v297, v621, v3, 0);
  v298 = CText::Get(&TheText, "CRED307");
  CCredits::PrintCreditText(*(float *)&v298, 0.78, v298, v621, v3, 0);
  v299 = CText::Get(&TheText, "CRED308");
  CCredits::PrintCreditText(*(float *)&v299, 0.78, v299, v621, v3, 0);
  v300 = CText::Get(&TheText, "CRD308A");
  CCredits::PrintCreditText(*(float *)&v300, 0.78, v300, v621, v3, 0);
  v301 = CText::Get(&TheText, "CRD308B");
  CCredits::PrintCreditText(*(float *)&v301, 0.78, v301, v621, v3, 0);
  v302 = CText::Get(&TheText, "CRD308C");
  CCredits::PrintCreditText(*(float *)&v302, 0.78, v302, v621, v3, 0);
  v303 = CText::Get(&TheText, "CRD308D");
  CCredits::PrintCreditText(*(float *)&v303, 0.78, v303, v621, v3, 0);
  v304 = CText::Get(&TheText, "CRD308E");
  CCredits::PrintCreditText(*(float *)&v304, 0.78, v304, v621, v3, 0);
  v305 = CText::Get(&TheText, "CRD308F");
  CCredits::PrintCreditText(*(float *)&v305, 0.78, v305, v621, v3, 0);
  v306 = CText::Get(&TheText, "CRD308G");
  CCredits::PrintCreditText(*(float *)&v306, 0.78, v306, v621, v3, 0);
  v307 = CText::Get(&TheText, "CRD308H");
  CCredits::PrintCreditText(*(float *)&v307, 0.78, v307, v621, v3, 0);
  v308 = CText::Get(&TheText, "CRD308I");
  CCredits::PrintCreditText(*(float *)&v308, 0.78, v308, v621, v3, 0);
  v309 = CText::Get(&TheText, "CRD308J");
  CCredits::PrintCreditText(*(float *)&v309, 0.78, v309, v621, v3, 0);
  v310 = CText::Get(&TheText, "CRD308K");
  CCredits::PrintCreditText(*(float *)&v310, 0.78, v310, v621, v3, 0);
  v311 = CText::Get(&TheText, "CRD308L");
  CCredits::PrintCreditText(*(float *)&v311, 0.78, v311, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 12.5);
  v312 = CText::Get(&TheText, "CRD308M");
  CCredits::PrintCreditText(*(float *)&v312, 0.78, v312, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)(unsigned int)(float)((float)v621[0] + 37.5) + 12.5);
  v313 = CText::Get(&TheText, "CRD308N");
  CCredits::PrintCreditText(*(float *)&v313, 0.78, v313, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v314 = CText::Get(&TheText, "CRED309");
  CCredits::PrintCreditText(*(float *)&v314, 1.1, v314, v621, v3, 1);
  v315 = CText::Get(&TheText, "CRED310");
  CCredits::PrintCreditText(*(float *)&v315, 1.1, v315, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v316 = CText::Get(&TheText, "CRED311");
  CCredits::PrintCreditText(*(float *)&v316, 1.1, v316, v621, v3, 1);
  v317 = CText::Get(&TheText, "CRED312");
  CCredits::PrintCreditText(*(float *)&v317, 1.1, v317, v621, v3, 0);
  v318 = CText::Get(&TheText, "CRED313");
  CCredits::PrintCreditText(*(float *)&v318, 1.1, v318, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v319 = CText::Get(&TheText, "CRED314");
  CCredits::PrintCreditText(*(float *)&v319, 1.1, v319, v621, v3, 1);
  v320 = CText::Get(&TheText, "CRED315");
  CCredits::PrintCreditText(*(float *)&v320, 0.78, v320, v621, v3, 0);
  v321 = CText::Get(&TheText, "CRED316");
  CCredits::PrintCreditText(*(float *)&v321, 0.78, v321, v621, v3, 0);
  v322 = CText::Get(&TheText, "CRED317");
  CCredits::PrintCreditText(*(float *)&v322, 0.78, v322, v621, v3, 0);
  v323 = CText::Get(&TheText, "CRED318");
  CCredits::PrintCreditText(*(float *)&v323, 0.78, v323, v621, v3, 0);
  v324 = CText::Get(&TheText, "CRED319");
  CCredits::PrintCreditText(*(float *)&v324, 0.78, v324, v621, v3, 0);
  v325 = CText::Get(&TheText, "CRED320");
  CCredits::PrintCreditText(*(float *)&v325, 0.78, v325, v621, v3, 0);
  v326 = CText::Get(&TheText, "CRED321");
  CCredits::PrintCreditText(*(float *)&v326, 0.78, v326, v621, v3, 0);
  v327 = CText::Get(&TheText, "CRED322");
  CCredits::PrintCreditText(*(float *)&v327, 0.78, v327, v621, v3, 0);
  v328 = CText::Get(&TheText, "CRED323");
  CCredits::PrintCreditText(*(float *)&v328, 0.78, v328, v621, v3, 0);
  v329 = CText::Get(&TheText, "CRED324");
  CCredits::PrintCreditText(*(float *)&v329, 0.78, v329, v621, v3, 0);
  v330 = CText::Get(&TheText, "CRED325");
  CCredits::PrintCreditText(*(float *)&v330, 0.78, v330, v621, v3, 0);
  v331 = CText::Get(&TheText, "CRED326");
  CCredits::PrintCreditText(*(float *)&v331, 0.78, v331, v621, v3, 0);
  v332 = CText::Get(&TheText, "CRED327");
  CCredits::PrintCreditText(*(float *)&v332, 0.78, v332, v621, v3, 0);
  v333 = CText::Get(&TheText, "CRED328");
  CCredits::PrintCreditText(*(float *)&v333, 0.78, v333, v621, v3, 0);
  v334 = CText::Get(&TheText, "CRED329");
  CCredits::PrintCreditText(*(float *)&v334, 0.78, v334, v621, v3, 0);
  v335 = CText::Get(&TheText, "CRED330");
  CCredits::PrintCreditText(*(float *)&v335, 0.78, v335, v621, v3, 0);
  v336 = CText::Get(&TheText, "CRED331");
  CCredits::PrintCreditText(*(float *)&v336, 0.78, v336, v621, v3, 0);
  v337 = CText::Get(&TheText, "CRED332");
  CCredits::PrintCreditText(*(float *)&v337, 0.78, v337, v621, v3, 0);
  v338 = CText::Get(&TheText, "CRED333");
  CCredits::PrintCreditText(*(float *)&v338, 0.78, v338, v621, v3, 0);
  v339 = CText::Get(&TheText, "CRED334");
  CCredits::PrintCreditText(*(float *)&v339, 0.78, v339, v621, v3, 0);
  v340 = CText::Get(&TheText, "CRED335");
  CCredits::PrintCreditText(*(float *)&v340, 0.78, v340, v621, v3, 0);
  v341 = CText::Get(&TheText, "CRED336");
  CCredits::PrintCreditText(*(float *)&v341, 0.78, v341, v621, v3, 0);
  v342 = CText::Get(&TheText, "CRED337");
  CCredits::PrintCreditText(*(float *)&v342, 0.78, v342, v621, v3, 0);
  v343 = CText::Get(&TheText, "CRED338");
  CCredits::PrintCreditText(*(float *)&v343, 0.78, v343, v621, v3, 0);
  v344 = CText::Get(&TheText, "CRED339");
  CCredits::PrintCreditText(*(float *)&v344, 0.78, v344, v621, v3, 0);
  v345 = CText::Get(&TheText, "CRED340");
  CCredits::PrintCreditText(*(float *)&v345, 0.78, v345, v621, v3, 0);
  v346 = CText::Get(&TheText, "CRED341");
  CCredits::PrintCreditText(*(float *)&v346, 0.78, v346, v621, v3, 0);
  v347 = CText::Get(&TheText, "CRED342");
  CCredits::PrintCreditText(*(float *)&v347, 0.78, v347, v621, v3, 0);
  v348 = CText::Get(&TheText, "CRED343");
  CCredits::PrintCreditText(*(float *)&v348, 0.78, v348, v621, v3, 0);
  v349 = CText::Get(&TheText, "CRED344");
  CCredits::PrintCreditText(*(float *)&v349, 0.78, v349, v621, v3, 0);
  v350 = CText::Get(&TheText, "CRED345");
  CCredits::PrintCreditText(*(float *)&v350, 0.78, v350, v621, v3, 0);
  v351 = CText::Get(&TheText, "CRED346");
  CCredits::PrintCreditText(*(float *)&v351, 0.78, v351, v621, v3, 0);
  v352 = CText::Get(&TheText, "CRED347");
  CCredits::PrintCreditText(*(float *)&v352, 0.78, v352, v621, v3, 0);
  v353 = CText::Get(&TheText, "CRED348");
  CCredits::PrintCreditText(*(float *)&v353, 0.78, v353, v621, v3, 0);
  v354 = CText::Get(&TheText, "CRED349");
  CCredits::PrintCreditText(*(float *)&v354, 0.78, v354, v621, v3, 0);
  v355 = CText::Get(&TheText, "CRED350");
  CCredits::PrintCreditText(*(float *)&v355, 0.78, v355, v621, v3, 0);
  v356 = CText::Get(&TheText, "CRED351");
  CCredits::PrintCreditText(*(float *)&v356, 0.78, v356, v621, v3, 0);
  v357 = CText::Get(&TheText, "CRED352");
  CCredits::PrintCreditText(*(float *)&v357, 0.78, v357, v621, v3, 0);
  v358 = CText::Get(&TheText, "CRED353");
  CCredits::PrintCreditText(*(float *)&v358, 0.78, v358, v621, v3, 0);
  v359 = CText::Get(&TheText, "CRED354");
  CCredits::PrintCreditText(*(float *)&v359, 0.78, v359, v621, v3, 0);
  v360 = CText::Get(&TheText, "CRED355");
  CCredits::PrintCreditText(*(float *)&v360, 0.78, v360, v621, v3, 0);
  v361 = CText::Get(&TheText, "CRED356");
  CCredits::PrintCreditText(*(float *)&v361, 0.78, v361, v621, v3, 0);
  v362 = CText::Get(&TheText, "CRED357");
  CCredits::PrintCreditText(*(float *)&v362, 0.78, v362, v621, v3, 0);
  v363 = CText::Get(&TheText, "CRED358");
  CCredits::PrintCreditText(*(float *)&v363, 0.78, v363, v621, v3, 0);
  v364 = CText::Get(&TheText, "CRED359");
  CCredits::PrintCreditText(*(float *)&v364, 0.78, v364, v621, v3, 0);
  v365 = CText::Get(&TheText, "CRED360");
  CCredits::PrintCreditText(*(float *)&v365, 0.78, v365, v621, v3, 0);
  v366 = CText::Get(&TheText, "CRED361");
  CCredits::PrintCreditText(*(float *)&v366, 0.78, v366, v621, v3, 0);
  v367 = CText::Get(&TheText, "CRED362");
  CCredits::PrintCreditText(*(float *)&v367, 0.78, v367, v621, v3, 0);
  v368 = CText::Get(&TheText, "CRED363");
  CCredits::PrintCreditText(*(float *)&v368, 0.78, v368, v621, v3, 0);
  v369 = CText::Get(&TheText, "CRED364");
  CCredits::PrintCreditText(*(float *)&v369, 0.78, v369, v621, v3, 0);
  v370 = CText::Get(&TheText, "CRED365");
  CCredits::PrintCreditText(*(float *)&v370, 0.78, v370, v621, v3, 0);
  v371 = CText::Get(&TheText, "CRED366");
  CCredits::PrintCreditText(*(float *)&v371, 0.78, v371, v621, v3, 0);
  v372 = CText::Get(&TheText, "CRED367");
  CCredits::PrintCreditText(*(float *)&v372, 0.78, v372, v621, v3, 0);
  v373 = CText::Get(&TheText, "CRED368");
  CCredits::PrintCreditText(*(float *)&v373, 0.78, v373, v621, v3, 0);
  v374 = CText::Get(&TheText, "CRED369");
  CCredits::PrintCreditText(*(float *)&v374, 0.78, v374, v621, v3, 0);
  v375 = CText::Get(&TheText, "CRED370");
  CCredits::PrintCreditText(*(float *)&v375, 0.78, v375, v621, v3, 0);
  v376 = CText::Get(&TheText, "CRED371");
  CCredits::PrintCreditText(*(float *)&v376, 0.78, v376, v621, v3, 0);
  v377 = CText::Get(&TheText, "CRED372");
  CCredits::PrintCreditText(*(float *)&v377, 0.78, v377, v621, v3, 0);
  v378 = CText::Get(&TheText, "CRED373");
  CCredits::PrintCreditText(*(float *)&v378, 0.78, v378, v621, v3, 0);
  v379 = CText::Get(&TheText, "CRED374");
  CCredits::PrintCreditText(*(float *)&v379, 0.78, v379, v621, v3, 0);
  v380 = CText::Get(&TheText, "CRED375");
  CCredits::PrintCreditText(*(float *)&v380, 0.78, v380, v621, v3, 0);
  v381 = CText::Get(&TheText, "CRED376");
  CCredits::PrintCreditText(*(float *)&v381, 0.78, v381, v621, v3, 0);
  v382 = CText::Get(&TheText, "CRED377");
  CCredits::PrintCreditText(*(float *)&v382, 0.78, v382, v621, v3, 0);
  v383 = CText::Get(&TheText, "CRED378");
  CCredits::PrintCreditText(*(float *)&v383, 0.78, v383, v621, v3, 0);
  v384 = CText::Get(&TheText, "CRED379");
  CCredits::PrintCreditText(*(float *)&v384, 0.78, v384, v621, v3, 0);
  v385 = CText::Get(&TheText, "CRED380");
  CCredits::PrintCreditText(*(float *)&v385, 0.78, v385, v621, v3, 0);
  v386 = CText::Get(&TheText, "CRED381");
  CCredits::PrintCreditText(*(float *)&v386, 0.78, v386, v621, v3, 0);
  v387 = CText::Get(&TheText, "CRED382");
  CCredits::PrintCreditText(*(float *)&v387, 0.78, v387, v621, v3, 0);
  v388 = CText::Get(&TheText, "CRED383");
  CCredits::PrintCreditText(*(float *)&v388, 0.78, v388, v621, v3, 0);
  v389 = CText::Get(&TheText, "CRED384");
  CCredits::PrintCreditText(*(float *)&v389, 0.78, v389, v621, v3, 0);
  v390 = CText::Get(&TheText, "CRED385");
  CCredits::PrintCreditText(*(float *)&v390, 0.78, v390, v621, v3, 0);
  v391 = CText::Get(&TheText, "CRED386");
  CCredits::PrintCreditText(*(float *)&v391, 0.78, v391, v621, v3, 0);
  v392 = CText::Get(&TheText, "CRED387");
  CCredits::PrintCreditText(*(float *)&v392, 0.78, v392, v621, v3, 0);
  v393 = CText::Get(&TheText, "CRED388");
  CCredits::PrintCreditText(*(float *)&v393, 0.78, v393, v621, v3, 0);
  v394 = CText::Get(&TheText, "CRED389");
  CCredits::PrintCreditText(*(float *)&v394, 0.78, v394, v621, v3, 0);
  v395 = CText::Get(&TheText, "CRED390");
  CCredits::PrintCreditText(*(float *)&v395, 0.78, v395, v621, v3, 0);
  v396 = CText::Get(&TheText, "CRED391");
  CCredits::PrintCreditText(*(float *)&v396, 0.78, v396, v621, v3, 0);
  v397 = CText::Get(&TheText, "CRED392");
  CCredits::PrintCreditText(*(float *)&v397, 0.78, v397, v621, v3, 0);
  v398 = CText::Get(&TheText, "CRED393");
  CCredits::PrintCreditText(*(float *)&v398, 0.78, v398, v621, v3, 0);
  v399 = CText::Get(&TheText, "CRED394");
  CCredits::PrintCreditText(*(float *)&v399, 0.78, v399, v621, v3, 0);
  v400 = CText::Get(&TheText, "CRED395");
  CCredits::PrintCreditText(*(float *)&v400, 0.78, v400, v621, v3, 0);
  v401 = CText::Get(&TheText, "CRED396");
  CCredits::PrintCreditText(*(float *)&v401, 0.78, v401, v621, v3, 0);
  v402 = CText::Get(&TheText, "CRED397");
  CCredits::PrintCreditText(*(float *)&v402, 0.78, v402, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v403 = CText::Get(&TheText, "CRED398");
  CCredits::PrintCreditText(*(float *)&v403, 1.1, v403, v621, v3, 1);
  v404 = CText::Get(&TheText, "CRED399");
  CCredits::PrintCreditText(*(float *)&v404, 1.1, v404, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v405 = CText::Get(&TheText, "CRED400");
  CCredits::PrintCreditText(*(float *)&v405, 1.1, v405, v621, v3, 1);
  v406 = CText::Get(&TheText, "CRED401");
  CCredits::PrintCreditText(*(float *)&v406, 1.1, v406, v621, v3, 0);
  v407 = CText::Get(&TheText, "CRED402");
  CCredits::PrintCreditText(*(float *)&v407, 1.1, v407, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v408 = CText::Get(&TheText, "CRED403");
  CCredits::PrintCreditText(*(float *)&v408, 1.1, v408, v621, v3, 1);
  v409 = CText::Get(&TheText, "CRED404");
  CCredits::PrintCreditText(*(float *)&v409, 1.1, v409, v621, v3, 0);
  v410 = CText::Get(&TheText, "CRED405");
  CCredits::PrintCreditText(*(float *)&v410, 1.1, v410, v621, v3, 0);
  v411 = CText::Get(&TheText, "CRED406");
  CCredits::PrintCreditText(*(float *)&v411, 1.1, v411, v621, v3, 0);
  v412 = CText::Get(&TheText, "CRED407");
  CCredits::PrintCreditText(*(float *)&v412, 1.1, v412, v621, v3, 0);
  v413 = CText::Get(&TheText, "CRED408");
  CCredits::PrintCreditText(*(float *)&v413, 1.1, v413, v621, v3, 0);
  v414 = CText::Get(&TheText, "CRED409");
  CCredits::PrintCreditText(*(float *)&v414, 1.1, v414, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 12.5);
  v415 = CText::Get(&TheText, "CRED410");
  CCredits::PrintCreditText(*(float *)&v415, 1.1, v415, v621, v3, 1);
  v416 = CText::Get(&TheText, "CRED411");
  CCredits::PrintCreditText(*(float *)&v416, 1.1, v416, v621, v3, 0);
  v417 = CText::Get(&TheText, "CRED412");
  CCredits::PrintCreditText(*(float *)&v417, 1.1, v417, v621, v3, 0);
  v418 = CText::Get(&TheText, "CRED413");
  CCredits::PrintCreditText(*(float *)&v418, 1.1, v418, v621, v3, 0);
  v419 = CText::Get(&TheText, "CRED414");
  CCredits::PrintCreditText(*(float *)&v419, 1.1, v419, v621, v3, 0);
  v420 = CText::Get(&TheText, "CRED415");
  CCredits::PrintCreditText(*(float *)&v420, 1.1, v420, v621, v3, 0);
  v421 = CText::Get(&TheText, "CRED416");
  CCredits::PrintCreditText(*(float *)&v421, 1.1, v421, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v422 = CText::Get(&TheText, "CRED417");
  CCredits::PrintCreditText(*(float *)&v422, 1.1, v422, v621, v3, 1);
  v423 = CText::Get(&TheText, "CRED418");
  CCredits::PrintCreditText(*(float *)&v423, 0.78, v423, v621, v3, 0);
  v424 = CText::Get(&TheText, "CRED419");
  CCredits::PrintCreditText(*(float *)&v424, 0.78, v424, v621, v3, 0);
  v425 = CText::Get(&TheText, "CRED420");
  CCredits::PrintCreditText(*(float *)&v425, 0.78, v425, v621, v3, 0);
  v426 = CText::Get(&TheText, "CRED421");
  CCredits::PrintCreditText(*(float *)&v426, 0.78, v426, v621, v3, 0);
  v427 = CText::Get(&TheText, "CRED422");
  CCredits::PrintCreditText(*(float *)&v427, 0.78, v427, v621, v3, 0);
  v428 = CText::Get(&TheText, "CRED423");
  CCredits::PrintCreditText(*(float *)&v428, 0.78, v428, v621, v3, 0);
  v429 = CText::Get(&TheText, "CRED424");
  CCredits::PrintCreditText(*(float *)&v429, 0.78, v429, v621, v3, 0);
  v430 = CText::Get(&TheText, "CRED425");
  CCredits::PrintCreditText(*(float *)&v430, 0.78, v430, v621, v3, 0);
  v431 = CText::Get(&TheText, "CRED426");
  CCredits::PrintCreditText(*(float *)&v431, 0.78, v431, v621, v3, 0);
  v432 = CText::Get(&TheText, "CRED427");
  CCredits::PrintCreditText(*(float *)&v432, 0.78, v432, v621, v3, 0);
  v433 = CText::Get(&TheText, "CRED428");
  CCredits::PrintCreditText(*(float *)&v433, 0.78, v433, v621, v3, 0);
  v434 = CText::Get(&TheText, "CRED429");
  CCredits::PrintCreditText(*(float *)&v434, 0.78, v434, v621, v3, 0);
  v435 = CText::Get(&TheText, "CRED430");
  CCredits::PrintCreditText(*(float *)&v435, 0.78, v435, v621, v3, 0);
  v436 = CText::Get(&TheText, "CRED431");
  CCredits::PrintCreditText(*(float *)&v436, 0.78, v436, v621, v3, 0);
  v437 = CText::Get(&TheText, "CRED432");
  CCredits::PrintCreditText(*(float *)&v437, 0.78, v437, v621, v3, 0);
  v438 = CText::Get(&TheText, "CRED433");
  CCredits::PrintCreditText(*(float *)&v438, 0.78, v438, v621, v3, 0);
  v439 = CText::Get(&TheText, "CRED434");
  CCredits::PrintCreditText(*(float *)&v439, 0.78, v439, v621, v3, 0);
  v440 = CText::Get(&TheText, "CRED435");
  CCredits::PrintCreditText(*(float *)&v440, 0.78, v440, v621, v3, 0);
  v441 = CText::Get(&TheText, "CRED436");
  CCredits::PrintCreditText(*(float *)&v441, 0.78, v441, v621, v3, 0);
  v442 = CText::Get(&TheText, "CRED437");
  CCredits::PrintCreditText(*(float *)&v442, 0.78, v442, v621, v3, 0);
  v443 = CText::Get(&TheText, "CRED438");
  CCredits::PrintCreditText(*(float *)&v443, 0.78, v443, v621, v3, 0);
  v444 = CText::Get(&TheText, "CRED439");
  CCredits::PrintCreditText(*(float *)&v444, 0.78, v444, v621, v3, 0);
  v445 = CText::Get(&TheText, "CRED440");
  CCredits::PrintCreditText(*(float *)&v445, 0.78, v445, v621, v3, 0);
  v446 = CText::Get(&TheText, "CRED441");
  CCredits::PrintCreditText(*(float *)&v446, 0.78, v446, v621, v3, 0);
  v447 = CText::Get(&TheText, "CRED442");
  CCredits::PrintCreditText(*(float *)&v447, 0.78, v447, v621, v3, 0);
  v448 = CText::Get(&TheText, "CRED443");
  CCredits::PrintCreditText(*(float *)&v448, 0.78, v448, v621, v3, 0);
  v449 = CText::Get(&TheText, "CRED444");
  CCredits::PrintCreditText(*(float *)&v449, 0.78, v449, v621, v3, 0);
  v450 = CText::Get(&TheText, "CRED445");
  CCredits::PrintCreditText(*(float *)&v450, 0.78, v450, v621, v3, 0);
  v451 = CText::Get(&TheText, "CRED446");
  CCredits::PrintCreditText(*(float *)&v451, 0.78, v451, v621, v3, 0);
  v452 = CText::Get(&TheText, "CRED447");
  CCredits::PrintCreditText(*(float *)&v452, 0.78, v452, v621, v3, 0);
  v453 = CText::Get(&TheText, "CRED448");
  CCredits::PrintCreditText(*(float *)&v453, 0.78, v453, v621, v3, 0);
  v454 = CText::Get(&TheText, "CRED449");
  CCredits::PrintCreditText(*(float *)&v454, 0.78, v454, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v455 = CText::Get(&TheText, "CRED450");
  CCredits::PrintCreditText(*(float *)&v455, 1.1, v455, v621, v3, 1);
  v456 = CText::Get(&TheText, "CRED451");
  CCredits::PrintCreditText(*(float *)&v456, 1.1, v456, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v457 = CText::Get(&TheText, "CRED452");
  CCredits::PrintCreditText(*(float *)&v457, 1.1, v457, v621, v3, 1);
  v458 = CText::Get(&TheText, "CRED453");
  CCredits::PrintCreditText(*(float *)&v458, 1.1, v458, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v459 = CText::Get(&TheText, "CRED454");
  CCredits::PrintCreditText(*(float *)&v459, 1.1, v459, v621, v3, 1);
  v460 = CText::Get(&TheText, "CRED455");
  CCredits::PrintCreditText(*(float *)&v460, 1.1, v460, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v461 = CText::Get(&TheText, "CRD455A");
  CCredits::PrintCreditText(*(float *)&v461, 1.1, v461, v621, v3, 1);
  v462 = CText::Get(&TheText, "CRD455B");
  CCredits::PrintCreditText(*(float *)&v462, 1.1, v462, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v463 = CText::Get(&TheText, "CRD455C");
  CCredits::PrintCreditText(*(float *)&v463, 1.1, v463, v621, v3, 1);
  v464 = CText::Get(&TheText, "CRD455D");
  CCredits::PrintCreditText(*(float *)&v464, 1.1, v464, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v465 = CText::Get(&TheText, "CRED456");
  CCredits::PrintCreditText(*(float *)&v465, 1.1, v465, v621, v3, 1);
  v466 = CText::Get(&TheText, "CRED457");
  CCredits::PrintCreditText(*(float *)&v466, 0.78, v466, v621, v3, 0);
  v467 = CText::Get(&TheText, "CRED458");
  CCredits::PrintCreditText(*(float *)&v467, 0.78, v467, v621, v3, 0);
  v468 = CText::Get(&TheText, "CRED459");
  CCredits::PrintCreditText(*(float *)&v468, 0.78, v468, v621, v3, 0);
  v469 = CText::Get(&TheText, "CRED460");
  CCredits::PrintCreditText(*(float *)&v469, 0.78, v469, v621, v3, 0);
  v470 = CText::Get(&TheText, "CRED461");
  CCredits::PrintCreditText(*(float *)&v470, 0.78, v470, v621, v3, 0);
  v471 = CText::Get(&TheText, "CRED462");
  CCredits::PrintCreditText(*(float *)&v471, 0.78, v471, v621, v3, 0);
  v472 = CText::Get(&TheText, "CRED463");
  CCredits::PrintCreditText(*(float *)&v472, 0.78, v472, v621, v3, 0);
  v473 = CText::Get(&TheText, "CRED464");
  CCredits::PrintCreditText(*(float *)&v473, 0.78, v473, v621, v3, 0);
  v474 = CText::Get(&TheText, "CRED465");
  CCredits::PrintCreditText(*(float *)&v474, 0.78, v474, v621, v3, 0);
  v475 = CText::Get(&TheText, "CRED466");
  CCredits::PrintCreditText(*(float *)&v475, 0.78, v475, v621, v3, 0);
  v476 = CText::Get(&TheText, "CRED467");
  CCredits::PrintCreditText(*(float *)&v476, 0.78, v476, v621, v3, 0);
  v477 = CText::Get(&TheText, "CRED468");
  CCredits::PrintCreditText(*(float *)&v477, 0.78, v477, v621, v3, 0);
  v478 = CText::Get(&TheText, "CRED469");
  CCredits::PrintCreditText(*(float *)&v478, 0.78, v478, v621, v3, 0);
  v479 = CText::Get(&TheText, "CRED470");
  CCredits::PrintCreditText(*(float *)&v479, 0.78, v479, v621, v3, 0);
  v480 = CText::Get(&TheText, "CRED471");
  CCredits::PrintCreditText(*(float *)&v480, 0.78, v480, v621, v3, 0);
  v481 = CText::Get(&TheText, "CRED472");
  CCredits::PrintCreditText(*(float *)&v481, 0.78, v481, v621, v3, 0);
  v482 = CText::Get(&TheText, "CRED473");
  CCredits::PrintCreditText(*(float *)&v482, 0.78, v482, v621, v3, 0);
  v483 = CText::Get(&TheText, "CRED474");
  CCredits::PrintCreditText(*(float *)&v483, 0.78, v483, v621, v3, 0);
  v484 = CText::Get(&TheText, "CRED475");
  CCredits::PrintCreditText(*(float *)&v484, 0.78, v484, v621, v3, 0);
  v485 = CText::Get(&TheText, "CRED476");
  CCredits::PrintCreditText(*(float *)&v485, 0.78, v485, v621, v3, 0);
  v486 = CText::Get(&TheText, "CRED477");
  CCredits::PrintCreditText(*(float *)&v486, 0.78, v486, v621, v3, 0);
  v487 = CText::Get(&TheText, "CRED478");
  CCredits::PrintCreditText(*(float *)&v487, 0.78, v487, v621, v3, 0);
  v488 = CText::Get(&TheText, "CRED479");
  CCredits::PrintCreditText(*(float *)&v488, 0.78, v488, v621, v3, 0);
  v489 = CText::Get(&TheText, "CRED480");
  CCredits::PrintCreditText(*(float *)&v489, 0.78, v489, v621, v3, 0);
  v490 = CText::Get(&TheText, "CRED481");
  CCredits::PrintCreditText(*(float *)&v490, 0.78, v490, v621, v3, 0);
  v491 = CText::Get(&TheText, "CRED482");
  CCredits::PrintCreditText(*(float *)&v491, 0.78, v491, v621, v3, 0);
  v492 = CText::Get(&TheText, "CRED483");
  CCredits::PrintCreditText(*(float *)&v492, 0.78, v492, v621, v3, 0);
  v493 = CText::Get(&TheText, "CRED484");
  CCredits::PrintCreditText(*(float *)&v493, 0.78, v493, v621, v3, 0);
  v494 = CText::Get(&TheText, "CRED485");
  CCredits::PrintCreditText(*(float *)&v494, 0.78, v494, v621, v3, 0);
  v495 = CText::Get(&TheText, "CRED486");
  CCredits::PrintCreditText(*(float *)&v495, 0.78, v495, v621, v3, 0);
  v496 = CText::Get(&TheText, "CRED487");
  CCredits::PrintCreditText(*(float *)&v496, 0.78, v496, v621, v3, 0);
  v497 = CText::Get(&TheText, "CRED488");
  CCredits::PrintCreditText(*(float *)&v497, 0.78, v497, v621, v3, 0);
  v498 = CText::Get(&TheText, "CRED489");
  CCredits::PrintCreditText(*(float *)&v498, 0.78, v498, v621, v3, 0);
  v499 = CText::Get(&TheText, "CRED490");
  CCredits::PrintCreditText(*(float *)&v499, 0.78, v499, v621, v3, 0);
  v500 = CText::Get(&TheText, "CRED491");
  CCredits::PrintCreditText(*(float *)&v500, 0.78, v500, v621, v3, 0);
  v501 = CText::Get(&TheText, "CRED492");
  CCredits::PrintCreditText(*(float *)&v501, 0.78, v501, v621, v3, 0);
  v502 = CText::Get(&TheText, "CRED493");
  CCredits::PrintCreditText(*(float *)&v502, 0.78, v502, v621, v3, 0);
  v503 = CText::Get(&TheText, "CRED494");
  CCredits::PrintCreditText(*(float *)&v503, 0.78, v503, v621, v3, 0);
  v504 = CText::Get(&TheText, "CRED495");
  CCredits::PrintCreditText(*(float *)&v504, 0.78, v504, v621, v3, 0);
  v505 = CText::Get(&TheText, "CRED496");
  CCredits::PrintCreditText(*(float *)&v505, 0.78, v505, v621, v3, 0);
  v506 = CText::Get(&TheText, "CRED497");
  CCredits::PrintCreditText(*(float *)&v506, 0.78, v506, v621, v3, 0);
  v507 = CText::Get(&TheText, "CRED498");
  CCredits::PrintCreditText(*(float *)&v507, 0.78, v507, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v508 = CText::Get(&TheText, "CRED499");
  CCredits::PrintCreditText(*(float *)&v508, 1.1, v508, v621, v3, 1);
  v509 = CText::Get(&TheText, "CRED500");
  CCredits::PrintCreditText(*(float *)&v509, 1.1, v509, v621, v3, 0);
  v510 = CText::Get(&TheText, "CRED501");
  CCredits::PrintCreditText(*(float *)&v510, 1.1, v510, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v511 = CText::Get(&TheText, "CRED502");
  CCredits::PrintCreditText(*(float *)&v511, 1.1, v511, v621, v3, 1);
  v512 = CText::Get(&TheText, "CRED503");
  CCredits::PrintCreditText(*(float *)&v512, 1.1, v512, v621, v3, 0);
  v513 = CText::Get(&TheText, "CRED504");
  CCredits::PrintCreditText(*(float *)&v513, 1.1, v513, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v514 = CText::Get(&TheText, "CRED505");
  CCredits::PrintCreditText(*(float *)&v514, 1.1, v514, v621, v3, 1);
  v515 = CText::Get(&TheText, "CRED506");
  CCredits::PrintCreditText(*(float *)&v515, 1.1, v515, v621, v3, 0);
  v516 = CText::Get(&TheText, "CRED507");
  CCredits::PrintCreditText(*(float *)&v516, 1.1, v516, v621, v3, 0);
  v517 = CText::Get(&TheText, "CRED508");
  CCredits::PrintCreditText(*(float *)&v517, 1.1, v517, v621, v3, 0);
  v518 = CText::Get(&TheText, "CRED509");
  CCredits::PrintCreditText(*(float *)&v518, 1.1, v518, v621, v3, 0);
  v519 = CText::Get(&TheText, "CRED510");
  CCredits::PrintCreditText(*(float *)&v519, 1.1, v519, v621, v3, 0);
  v520 = CText::Get(&TheText, "CRED511");
  CCredits::PrintCreditText(*(float *)&v520, 1.1, v520, v621, v3, 0);
  v521 = CText::Get(&TheText, "CRED512");
  CCredits::PrintCreditText(*(float *)&v521, 1.1, v521, v621, v3, 0);
  v522 = CText::Get(&TheText, "CRED515");
  CCredits::PrintCreditText(*(float *)&v522, 1.1, v522, v621, v3, 0);
  v523 = CText::Get(&TheText, "CRED516");
  CCredits::PrintCreditText(*(float *)&v523, 1.1, v523, v621, v3, 0);
  v524 = CText::Get(&TheText, "CRED517");
  CCredits::PrintCreditText(*(float *)&v524, 1.1, v524, v621, v3, 0);
  v525 = CText::Get(&TheText, "CRED518");
  CCredits::PrintCreditText(*(float *)&v525, 1.1, v525, v621, v3, 0);
  v526 = CText::Get(&TheText, "CRED519");
  CCredits::PrintCreditText(*(float *)&v526, 1.1, v526, v621, v3, 0);
  v527 = CText::Get(&TheText, "CRED520");
  CCredits::PrintCreditText(*(float *)&v527, 1.1, v527, v621, v3, 0);
  v528 = CText::Get(&TheText, "CRED521");
  CCredits::PrintCreditText(*(float *)&v528, 1.1, v528, v621, v3, 0);
  v529 = CText::Get(&TheText, "CRED522");
  CCredits::PrintCreditText(*(float *)&v529, 1.1, v529, v621, v3, 0);
  v530 = CText::Get(&TheText, "CRED523");
  CCredits::PrintCreditText(*(float *)&v530, 1.1, v530, v621, v3, 0);
  v531 = CText::Get(&TheText, "CRED524");
  CCredits::PrintCreditText(*(float *)&v531, 1.1, v531, v621, v3, 0);
  v532 = CText::Get(&TheText, "CRED525");
  CCredits::PrintCreditText(*(float *)&v532, 1.1, v532, v621, v3, 0);
  v533 = CText::Get(&TheText, "CRED526");
  CCredits::PrintCreditText(*(float *)&v533, 1.1, v533, v621, v3, 0);
  v534 = CText::Get(&TheText, "CRED527");
  CCredits::PrintCreditText(*(float *)&v534, 1.1, v534, v621, v3, 0);
  v535 = CText::Get(&TheText, "CRED529");
  CCredits::PrintCreditText(*(float *)&v535, 1.1, v535, v621, v3, 0);
  v536 = CText::Get(&TheText, "CRED530");
  CCredits::PrintCreditText(*(float *)&v536, 1.1, v536, v621, v3, 0);
  v537 = CText::Get(&TheText, "CRED531");
  CCredits::PrintCreditText(*(float *)&v537, 1.1, v537, v621, v3, 0);
  v538 = CText::Get(&TheText, "CRED532");
  CCredits::PrintCreditText(*(float *)&v538, 1.1, v538, v621, v3, 0);
  v539 = CText::Get(&TheText, "CRED533");
  CCredits::PrintCreditText(*(float *)&v539, 1.1, v539, v621, v3, 0);
  v540 = CText::Get(&TheText, "CRED534");
  CCredits::PrintCreditText(*(float *)&v540, 1.1, v540, v621, v3, 0);
  v541 = CText::Get(&TheText, "CRED535");
  CCredits::PrintCreditText(*(float *)&v541, 1.1, v541, v621, v3, 0);
  v542 = CText::Get(&TheText, "CRED536");
  CCredits::PrintCreditText(*(float *)&v542, 1.1, v542, v621, v3, 0);
  v543 = CText::Get(&TheText, "CRED537");
  CCredits::PrintCreditText(*(float *)&v543, 1.1, v543, v621, v3, 0);
  v544 = CText::Get(&TheText, "CRED538");
  CCredits::PrintCreditText(*(float *)&v544, 1.1, v544, v621, v3, 0);
  v545 = CText::Get(&TheText, "CRED539");
  CCredits::PrintCreditText(*(float *)&v545, 1.1, v545, v621, v3, 0);
  v546 = CText::Get(&TheText, "CRED540");
  CCredits::PrintCreditText(*(float *)&v546, 1.1, v546, v621, v3, 0);
  v547 = CText::Get(&TheText, "CRED541");
  CCredits::PrintCreditText(*(float *)&v547, 1.1, v547, v621, v3, 0);
  v548 = CText::Get(&TheText, "CRD541A");
  CCredits::PrintCreditText(*(float *)&v548, 1.1, v548, v621, v3, 0);
  v549 = CText::Get(&TheText, "CRD541B");
  CCredits::PrintCreditText(*(float *)&v549, 1.1, v549, v621, v3, 0);
  v550 = CText::Get(&TheText, "CRD541C");
  CCredits::PrintCreditText(*(float *)&v550, 1.1, v550, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v551 = CText::Get(&TheText, "CRED542");
  CCredits::PrintCreditText(*(float *)&v551, 1.1, v551, v621, v3, 1);
  v552 = CText::Get(&TheText, "CRED543");
  CCredits::PrintCreditText(*(float *)&v552, 1.1, v552, v621, v3, 0);
  v553 = CText::Get(&TheText, "CRED544");
  CCredits::PrintCreditText(*(float *)&v553, 1.1, v553, v621, v3, 0);
  v554 = CText::Get(&TheText, "CRED545");
  CCredits::PrintCreditText(*(float *)&v554, 1.1, v554, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)(unsigned int)(float)((float)v621[0] + 37.5) + 37.5);
  v555 = CText::Get(&TheText, "CREWD0");
  CCredits::PrintCreditText(*(float *)&v555, 1.1, v555, v621, v3, 1);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v556 = CText::Get(&TheText, "CREWD1");
  CCredits::PrintCreditText(*(float *)&v556, 1.1, v556, v621, v3, 1);
  v557 = CText::Get(&TheText, "CREWD2");
  CCredits::PrintCreditText(*(float *)&v557, 1.1, v557, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v558 = CText::Get(&TheText, "CREWD3");
  CCredits::PrintCreditText(*(float *)&v558, 1.1, v558, v621, v3, 1);
  v559 = CText::Get(&TheText, "CREWD4");
  CCredits::PrintCreditText(*(float *)&v559, 1.1, v559, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v560 = CText::Get(&TheText, "CRED088");
  CCredits::PrintCreditText(*(float *)&v560, 1.1, v560, v621, v3, 1);
  v561 = CText::Get(&TheText, "CREWD5");
  CCredits::PrintCreditText(*(float *)&v561, 1.1, v561, v621, v3, 0);
  v562 = CText::Get(&TheText, "CREWD6");
  CCredits::PrintCreditText(*(float *)&v562, 1.1, v562, v621, v3, 0);
  v563 = CText::Get(&TheText, "CREWD13");
  CCredits::PrintCreditText(*(float *)&v563, 1.1, v563, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v564 = CText::Get(&TheText, "CREWD7");
  CCredits::PrintCreditText(*(float *)&v564, 1.1, v564, v621, v3, 1);
  v565 = CText::Get(&TheText, "CREWD8");
  CCredits::PrintCreditText(*(float *)&v565, 1.1, v565, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v566 = CText::Get(&TheText, "CRED107");
  CCredits::PrintCreditText(*(float *)&v566, 1.1, v566, v621, v3, 1);
  v567 = CText::Get(&TheText, "CREWD9");
  CCredits::PrintCreditText(*(float *)&v567, 1.1, v567, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v568 = CText::Get(&TheText, "CRED609");
  CCredits::PrintCreditText(*(float *)&v568, 1.1, v568, v621, v3, 1);
  v569 = CText::Get(&TheText, "CREWD10");
  CCredits::PrintCreditText(*(float *)&v569, 1.1, v569, v621, v3, 0);
  v570 = CText::Get(&TheText, "CREWD11");
  CCredits::PrintCreditText(*(float *)&v570, 1.1, v570, v621, v3, 0);
  v571 = CText::Get(&TheText, "CREWD12");
  CCredits::PrintCreditText(*(float *)&v571, 1.1, v571, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)(unsigned int)(float)((float)v621[0] + 37.5) + 37.5);
  v572 = CText::Get(&TheText, "CRED600");
  CCredits::PrintCreditText(*(float *)&v572, 1.1, v572, v621, v3, 1);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v573 = CText::Get(&TheText, "CRED601");
  CCredits::PrintCreditText(*(float *)&v573, 1.1, v573, v621, v3, 1);
  v574 = CText::Get(&TheText, "CRED602");
  CCredits::PrintCreditText(*(float *)&v574, 1.1, v574, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v575 = CText::Get(&TheText, "CRED603");
  CCredits::PrintCreditText(*(float *)&v575, 1.1, v575, v621, v3, 1);
  v576 = CText::Get(&TheText, "CRED604");
  CCredits::PrintCreditText(*(float *)&v576, 1.1, v576, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v577 = CText::Get(&TheText, "CRED605");
  CCredits::PrintCreditText(*(float *)&v577, 1.1, v577, v621, v3, 1);
  v578 = CText::Get(&TheText, "CRED606");
  CCredits::PrintCreditText(*(float *)&v578, 1.1, v578, v621, v3, 0);
  v579 = CText::Get(&TheText, "CRED607");
  CCredits::PrintCreditText(*(float *)&v579, 1.1, v579, v621, v3, 0);
  v580 = CText::Get(&TheText, "CRED608");
  CCredits::PrintCreditText(*(float *)&v580, 1.1, v580, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v581 = CText::Get(&TheText, "CRED609");
  CCredits::PrintCreditText(*(float *)&v581, 1.1, v581, v621, v3, 1);
  v582 = CText::Get(&TheText, "CRED610");
  CCredits::PrintCreditText(*(float *)&v582, 1.1, v582, v621, v3, 0);
  v583 = CText::Get(&TheText, "CRED611");
  CCredits::PrintCreditText(*(float *)&v583, 1.1, v583, v621, v3, 0);
  v584 = CText::Get(&TheText, "CRED612");
  CCredits::PrintCreditText(*(float *)&v584, 1.1, v584, v621, v3, 0);
  v585 = CText::Get(&TheText, "CRED613");
  CCredits::PrintCreditText(*(float *)&v585, 1.1, v585, v621, v3, 0);
  v586 = CText::Get(&TheText, "CRED614");
  CCredits::PrintCreditText(*(float *)&v586, 1.1, v586, v621, v3, 0);
  v587 = CText::Get(&TheText, "CRED615");
  CCredits::PrintCreditText(*(float *)&v587, 1.1, v587, v621, v3, 0);
  v588 = CText::Get(&TheText, "CRED616");
  CCredits::PrintCreditText(*(float *)&v588, 1.1, v588, v621, v3, 0);
  v589 = CText::Get(&TheText, "CRED617");
  CCredits::PrintCreditText(*(float *)&v589, 1.1, v589, v621, v3, 0);
  v590 = CText::Get(&TheText, "CRED618");
  CCredits::PrintCreditText(*(float *)&v590, 1.1, v590, v621, v3, 0);
  v591 = CText::Get(&TheText, "CRED619");
  CCredits::PrintCreditText(*(float *)&v591, 1.1, v591, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v592 = CText::Get(&TheText, "CRED620");
  CCredits::PrintCreditText(*(float *)&v592, 1.1, v592, v621, v3, 1);
  v593 = CText::Get(&TheText, "CRED621");
  CCredits::PrintCreditText(*(float *)&v593, 1.1, v593, v621, v3, 0);
  v594 = CText::Get(&TheText, "CRED622");
  CCredits::PrintCreditText(*(float *)&v594, 1.1, v594, v621, v3, 0);
  v595 = CText::Get(&TheText, "CRED623");
  CCredits::PrintCreditText(*(float *)&v595, 1.1, v595, v621, v3, 0);
  v596 = CText::Get(&TheText, "CRED624");
  CCredits::PrintCreditText(*(float *)&v596, 1.1, v596, v621, v3, 0);
  v597 = CText::Get(&TheText, "CRED625");
  CCredits::PrintCreditText(*(float *)&v597, 1.1, v597, v621, v3, 0);
  v598 = CText::Get(&TheText, "CRED626");
  CCredits::PrintCreditText(*(float *)&v598, 1.1, v598, v621, v3, 0);
  v599 = CText::Get(&TheText, "CRED627");
  CCredits::PrintCreditText(*(float *)&v599, 1.1, v599, v621, v3, 0);
  v600 = CText::Get(&TheText, "CRED628");
  CCredits::PrintCreditText(*(float *)&v600, 1.1, v600, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v601 = CText::Get(&TheText, "CRED629");
  CCredits::PrintCreditText(*(float *)&v601, 1.1, v601, v621, v3, 1);
  v602 = CText::Get(&TheText, "CRED630");
  CCredits::PrintCreditText(*(float *)&v602, 1.1, v602, v621, v3, 0);
  v621[0] = (unsigned int)(float)((float)v621[0] + 37.5);
  v603 = CText::Get(&TheText, "CRED700");
  CCredits::PrintCreditText(*(float *)&v603, 1.1, v603, v621, v3, 1);
  v604 = CText::Get(&TheText, "CRED701");
  CCredits::PrintCreditText(*(float *)&v604, 1.1, v604, v621, v3, 0);
  v605 = CText::Get(&TheText, "CRED702");
  CCredits::PrintCreditText(*(float *)&v605, 1.1, v605, v621, v3, 0);
  v606 = CText::Get(&TheText, "CRED703");
  CCredits::PrintCreditText(*(float *)&v606, 1.1, v606, v621, v3, 0);
  v607 = CText::Get(&TheText, "CRED704");
  CCredits::PrintCreditText(*(float *)&v607, 1.1, v607, v621, v3, 0);
  v608 = CText::Get(&TheText, "CRED705");
  CCredits::PrintCreditText(*(float *)&v608, 1.1, v608, v621, v3, 0);
  v609 = CText::Get(&TheText, "CRED706");
  CCredits::PrintCreditText(*(float *)&v609, 1.1, v609, v621, v3, 0);
  v610 = CText::Get(&TheText, "CRED707");
  CCredits::PrintCreditText(*(float *)&v610, 1.1, v610, v621, v3, 0);
  v611 = CText::Get(&TheText, "CRED708");
  CCredits::PrintCreditText(*(float *)&v611, 1.1, v611, v621, v3, 0);
  v612 = CText::Get(&TheText, "CRED709");
  CCredits::PrintCreditText(*(float *)&v612, 1.1, v612, v621, v3, 0);
  v613 = CText::Get(&TheText, "CRED710");
  CCredits::PrintCreditText(*(float *)&v613, 1.1, v613, v621, v3, 0);
  v614 = CText::Get(&TheText, "CRED711");
  CCredits::PrintCreditText(*(float *)&v614, 1.1, v614, v621, v3, 0);
  v615 = CText::Get(&TheText, "CRED712");
  CCredits::PrintCreditText(*(float *)&v615, 1.1, v615, v621, v3, 0);
  v616 = CText::Get(&TheText, "CRED713");
  CCredits::PrintCreditText(*(float *)&v616, 1.1, v616, v621, v3, 0);
  v617 = CText::Get(&TheText, "CRED714");
  CCredits::PrintCreditText(*(float *)&v617, 1.1, v617, v621, v3, 0);
  v618 = CText::Get(&TheText, "CRED715");
  CCredits::PrintCreditText(*(float *)&v618, 1.1, v618, v621, v3, 0);
  v619 = CText::Get(&TheText, "CRED716");
  CCredits::PrintCreditText(*(float *)&v619, 1.1, v619, v621, v3, 0);
  CFont::RenderFontBuffer();
  if ( TheCamera.m_WideScreenOn )
    CCamera::DrawBordersForWideScreen(&TheCamera);
  if ( CTouchInterface::m_pWidgets[41] )
    CWidgetButton::Draw((CWidgetButton *)CTouchInterface::m_pWidgets[41]);
  if ( (float)((float)(RsGlobal.screenHeight + v621[0]) - v3) < -10.0 )
    CCredits::bCreditsGoing = 0;
}
// 45CF8A: variable 'v2' is possibly undefined

//----- (00462AEC) --------------------------------------------------------
void __fastcall CCredits::PrintCreditText(
        float ScaleX,
        float ScaleY,
        GxtChar *pString,
        UInt32 *PixelsDown,
        float PixelsScrolled,
        int a6)
{
  float v10; // s18
  CRGBA v11; // r0
  CRGBA v12; // r0
  CRGBA v13; // [sp+4h] [bp-2Ch] BYREF
  CRGBA v14; // [sp+8h] [bp-28h] BYREF
  CRGBA v15; // [sp+Ch] [bp-24h] BYREF

  v10 = (float)((float)RsGlobal.screenHeight + (float)*PixelsDown) - PixelsScrolled;
  if ( v10 > COERCE_FLOAT(COERCE_UNSIGNED_INT(CFont::GetHeight(0)) ^ 0x80000000) && v10 < (float)RsGlobal.screenHeight )
  {
    CFont::SetScale(ScaleY);
    CRGBA::CRGBA(&v15, 0, 0, 0, 0xFFu);
    CFont::SetColor(v11);
    CFont::PrintString((float)(RsGlobal.screenWidth / 2), v10, pString);
    if ( a6 == 1 )
      CRGBA::CRGBA(&v14, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
    else
      CRGBA::CRGBA(&v13, 0xD2u, 0xD2u, 0xD2u, 0xD2u);
    CFont::SetColor(v12);
    CFont::PrintString((float)(RsGlobal.screenWidth / 2 - 1), v10 + -1.0, pString);
  }
  *PixelsDown = (unsigned int)(float)((float)(ScaleY * 20.0) + (float)*PixelsDown);
}
// 462B70: variable 'v11' is possibly undefined
// 462BBA: variable 'v12' is possibly undefined

//----- (00462C28) --------------------------------------------------------
void __fastcall CCredits::PrintCreditSpace(float ScaleY, UInt32 *PixelsDown)
{
  *PixelsDown = (unsigned int)(float)((float)(ScaleY * 25.0) + (float)*PixelsDown);
}

//----- (00462C4C) --------------------------------------------------------
void __fastcall CCamera::LoadPathSplines(CCamera *this, u_native fid)
{
  float *m_arr_PathData; // r0
  float *v5; // r0
  float *v6; // r0
  float *v7; // r0
  float *v8; // r5
  unsigned __int8 *Line; // r0
  int v10; // r8
  int v11; // r10
  int v12; // r1
  bool v13; // zf
  char *i; // r0
  float v15; // s0
  int v16; // r8
  int v17; // r5
  int v18; // r0
  __int64 v19; // r0
  int v20; // kr00_4
  float *v21; // r0
  int (***v22)(void); // r1
  int v23; // [sp+0h] [bp-20h] BYREF

  m_arr_PathData = this->m_arrPathArray[0].m_arr_PathData;
  if ( m_arr_PathData )
  {
    operator delete[](m_arr_PathData);
    this->m_arrPathArray[0].m_arr_PathData = 0;
  }
  v5 = this->m_arrPathArray[1].m_arr_PathData;
  if ( v5 )
  {
    operator delete[](v5);
    this->m_arrPathArray[1].m_arr_PathData = 0;
  }
  v6 = this->m_arrPathArray[2].m_arr_PathData;
  if ( v6 )
  {
    operator delete[](v6);
    this->m_arrPathArray[2].m_arr_PathData = 0;
  }
  v7 = this->m_arrPathArray[3].m_arr_PathData;
  if ( v7 )
  {
    operator delete[](v7);
    this->m_arrPathArray[3].m_arr_PathData = 0;
  }
  v8 = 0;
  v23 = 0;
  Line = CFileLoader::LoadLine(fid);
  if ( Line )
  {
    v10 = 1;
    v11 = -1;
    while ( 1 )
    {
      v12 = *Line;
      v13 = v12 == 35;
      if ( v12 != 35 )
        v13 = v12 == 0;
      if ( v13 )
        goto LABEL_15;
      if ( v23 )
        break;
      if ( v10 << 31 )
      {
        if ( v11 > 2 )
          return;
        v16 = v11 + 1;
        sscanf((const char *)Line, (const char *)&dword_462D90, &v23);
        v17 = v23;
        v18 = 10 * v23;
        if ( v11 == -1 )
          v18 = 4 * v23;
        if ( !v11 )
          v18 = 4 * v23;
        v20 = v18 | 1;
        v19 = 4LL * (v18 | 1u);
        if ( !is_mul_ok(v20, 4u) )
          HIDWORD(v19) = 1;
        if ( HIDWORD(v19) )
          LODWORD(v19) = -1;
        v21 = (float *)operator new[](v19);
        ++v11;
        v22 = &this->_vptr$CPlaceable + v16;
        v22[569] = (int (**)(void))v21;
        *v21 = (float)v17;
        v8 = (float *)(v22[569] + 1);
        Line = CFileLoader::LoadLine(fid);
        v10 = 0;
        if ( !Line )
          return;
      }
      else
      {
        v10 = v12 == 59;
LABEL_15:
        Line = CFileLoader::LoadLine(fid);
        if ( !Line )
          return;
      }
    }
    --v23;
    for ( i = strtok((char *)Line, (const char *)&off_462D8C); i; ++v8 )
    {
      v15 = atof(i);
      *v8 = v15;
      i = strtok(0, (const char *)&off_462D8C);
    }
    goto LABEL_15;
  }
}
// 462D8C: using guessed type void *off_462D8C;
// 462D90: using guessed type int dword_462D90;

//----- (00462D94) --------------------------------------------------------
void __fastcall CCamera::DeleteCutSceneCamDataMemory(CCamera *this)
{
  float *m_arr_PathData; // r0
  float *v3; // r0
  float *v4; // r0
  float *v5; // r0

  m_arr_PathData = this->m_arrPathArray[0].m_arr_PathData;
  if ( m_arr_PathData )
  {
    operator delete[](m_arr_PathData);
    this->m_arrPathArray[0].m_arr_PathData = 0;
  }
  v3 = this->m_arrPathArray[1].m_arr_PathData;
  if ( v3 )
  {
    operator delete[](v3);
    this->m_arrPathArray[1].m_arr_PathData = 0;
  }
  v4 = this->m_arrPathArray[2].m_arr_PathData;
  if ( v4 )
  {
    operator delete[](v4);
    this->m_arrPathArray[2].m_arr_PathData = 0;
  }
  v5 = this->m_arrPathArray[3].m_arr_PathData;
  if ( v5 )
  {
    operator delete[](v5);
    this->m_arrPathArray[3].m_arr_PathData = 0;
  }
}

//----- (00462DE0) --------------------------------------------------------
void __fastcall FindSplinePathPositionVector(CVector *pResult, float *pPath, float Timer, UInt32 *ArrayMarker)
{
  UInt32 v4; // lr
  unsigned int v5; // r4
  float v6; // s0
  int v7; // r12
  float v8; // s2
  float *v9; // r4
  float v10; // s6
  float v11; // s0
  __int64 v12; // kr00_8
  __int64 v13; // kr08_8
  float v14; // s10
  __int64 v15; // kr10_8
  float v16; // s2
  float v17; // r12
  float v18; // s4
  float v19; // s14
  float v20; // s1
  float v21; // s6
  float v22; // s8
  float v23; // s0
  float v24; // s4
  float v25; // s2
  float v26; // s1
  float v27; // s7
  float v28; // s3
  float v29; // s0
  float v30; // s7
  float v31; // s9
  RwReal v32; // s0

  v4 = *ArrayMarker;
  v5 = (unsigned int)*pPath;
  v6 = (float)(pPath[*ArrayMarker] - pPath[*ArrayMarker - 10]) * 1000.0;
  v7 = 10 * v5 - 9;
  v8 = pPath[v7] * 1000.0;
  if ( v8 <= Timer )
    goto LABEL_4;
  if ( (v4 - 1) / 0xA > v5 )
  {
LABEL_7:
    *ArrayMarker = v7;
    goto LABEL_8;
  }
  if ( v6 <= MAX_CUTJUMP_TIME )
  {
    if ( (v4 + 9) / 0xA <= v5 )
      v7 = v4 + 10;
    goto LABEL_7;
  }
LABEL_4:
  v7 = *ArrayMarker;
LABEL_8:
  v9 = &pPath[v7];
  v10 = (float)(Timer + (float)(*(v9 - 10) * -1000.0)) / v6;
  v11 = 1.0;
  if ( v10 <= 1.0 )
  {
    v11 = v10;
    if ( v10 < 0.0 )
      v11 = 0.0;
  }
  v12 = *((_QWORD *)v9 - 4);
  v13 = *((_QWORD *)v9 - 1);
  v14 = *(v9 - 3);
  if ( v8 < Timer )
    v11 = 1.0;
  v15 = *(_QWORD *)(v9 + 1);
  v16 = *(v9 - 9);
  v17 = v9[3];
  if ( v14 != v16 )
  {
    v19 = *(v9 - 2);
    v18 = *(v9 - 8);
LABEL_18:
    v26 = 1.0 - v11;
    v27 = v11 * 3.0;
    v28 = (float)(v11 * v11) * 3.0;
    v29 = v11 * (float)(v11 * v11);
    v30 = v27 * (float)(v26 * v26);
    v31 = v26 * (float)(v26 * v26);
    v24 = (float)(v29 * *((float *)&v15 + 1))
        + (float)((float)((float)(v31 * v18) + (float)(v30 * v19)) + (float)(v26 * (float)(v28 * v9[5])));
    v25 = (float)(v29 * *(float *)&v15)
        + (float)((float)((float)(v16 * v31) + (float)(v30 * v14)) + (float)(v26 * (float)(v28 * v9[4])));
    v23 = v29 * v17;
    v20 = (float)((float)(v31 * *((float *)&v12 + 1)) + (float)(v30 * *((float *)&v13 + 1)))
        + (float)(v26 * (float)(v28 * v9[6]));
    goto LABEL_19;
  }
  v18 = *(v9 - 8);
  v19 = *(v9 - 2);
  if ( *(float *)&v13 != *(float *)&v12 )
    goto LABEL_18;
  v20 = *(v9 - 7);
  if ( *((float *)&v13 + 1) != *((float *)&v12 + 1) )
    goto LABEL_18;
  v21 = v11 * (float)(*((float *)&v15 + 1) - *(float *)&v12);
  v22 = v11 * (float)(*(float *)&v15 - v16);
  v23 = v11 * (float)(v17 - *((float *)&v12 + 1));
  v24 = v21 + *(float *)&v12;
  v25 = v16 + v22;
LABEL_19:
  v32 = v23 + v20;
  pResult->x = v25;
  pResult->y = v24;
  pResult->z = v32;
  pResult->x = TheCamera.m_vecCutSceneOffset.x + v25;
  pResult->y = TheCamera.m_vecCutSceneOffset.y + v24;
  pResult->z = TheCamera.m_vecCutSceneOffset.z + v32;
}

//----- (00463044) --------------------------------------------------------
void __fastcall FindSplinePathPositionFloat(float *pResult, float *pPath, float Timer, UInt32 *ArrayMarker)
{
  float32x2_t v4; // d2
  float32x2_t v5; // d5
  float32x2_t v6; // d6
  UInt32 v7; // lr
  unsigned int v8; // r5
  int v9; // r12
  float v10; // s0
  float *v11; // r1
  float v12; // s8
  float v13; // s6
  float v14; // s4
  float v15; // s0

  v7 = *ArrayMarker;
  v8 = (unsigned int)*pPath;
  v9 = 4 * v8 - 3;
  v10 = pPath[v9] * 1000.0;
  if ( v10 <= Timer )
    goto LABEL_4;
  if ( (v7 - 1) >> 2 <= v8 )
  {
    if ( (float)((float)(pPath[v7] - pPath[v7 - 4]) * 1000.0) > MAX_CUTJUMP_TIME )
    {
LABEL_4:
      v9 = *ArrayMarker;
      goto LABEL_8;
    }
    if ( (v7 + 3) >> 2 <= v8 )
      v9 = v7 + 4;
  }
  *ArrayMarker = v9;
LABEL_8:
  v11 = &pPath[v9];
  v6.n64_f32[0] = *(v11 - 4);
  v12 = *(v11 - 1);
  v13 = *(v11 - 3);
  v4.n64_f32[0] = (float)(*v11 - v6.n64_f32[0]) * 1000.0;
  v5.n64_f32[0] = Timer - (float)(v6.n64_f32[0] * 1000.0);
  v6.n64_u32[0] = 0;
  v4.n64_f32[0] = v5.n64_f32[0] / v4.n64_f32[0];
  v5.n64_u32[0] = 1.0;
  LODWORD(v14) = vmax_f32(vmin_f32(v4, v5), v6).n64_u32[0];
  if ( v10 < Timer )
    v14 = 1.0;
  if ( v12 == v13 )
  {
    v15 = v14 * (float)(v11[1] - v13);
  }
  else
  {
    v15 = (float)(v14 * (float)(v14 * v14)) * v11[1];
    v13 = (float)((float)(v13 * (float)((float)(1.0 - v14) * (float)((float)(1.0 - v14) * (float)(1.0 - v14))))
                + (float)(v12 * (float)((float)(v14 * 3.0) * (float)((float)(1.0 - v14) * (float)(1.0 - v14)))))
        + (float)((float)(1.0 - v14) * (float)((float)(v14 * (float)(v14 * 3.0)) * v11[2]));
  }
  *pResult = v15 + v13;
}
// 463102: variable 'v4' is possibly undefined
// 463102: variable 'v5' is possibly undefined
// 463106: variable 'v6' is possibly undefined

//----- (00463184) --------------------------------------------------------
void __fastcall CCam::Process_FlyBy(
        CCam *this,
        const CVector *ThisCamsTarget,
        float TargetOrientation,
        float SpeedVar,
        float SpeedVarDesired)
{
  float v6; // s0
  float v7; // s16
  float m_uiFinishTime; // s0
  float v9; // s0
  UInt32 v10; // r0
  float *v11; // r2
  float v12; // s2
  float v13; // s0
  UInt32 v14; // r0
  float *v15; // r2
  float v16; // s2
  float v17; // s0
  UInt32 v18; // r0
  float *v19; // r2
  float v20; // s2
  float v21; // s0
  float v22; // r0
  float v23; // s0
  UInt32 v24; // r0
  float *v25; // r2
  float v26; // s2
  RwReal v27; // s0
  RwReal v28; // s2
  __int64 v29; // d16
  RwReal v30; // s4
  __int64 v31; // d16
  RwReal z; // r0
  CVector *p_Front; // r1
  float v34; // s0
  RwReal v35; // s0
  RwReal v36; // s2
  __int64 v37; // d16
  RwReal v38; // s4
  __int64 v39; // d16
  CVector v40; // [sp+0h] [bp-58h] BYREF
  float pResult; // [sp+Ch] [bp-4Ch] BYREF
  CVector v2; // [sp+10h] [bp-48h] BYREF

  pResult = 0.0;
  if ( !TheCamera.m_bcutsceneFinished )
  {
    this->Up.z = 1.0;
    this->Up.x = 0.0;
    this->Up.y = 0.0;
    if ( TheCamera.m_bStartingSpline )
    {
      v6 = this->m_fTimeElapsedFloat + (float)((float)(CTimer::ms_fTimeStepNonClipped / 50.0) * 1000.0);
      v7 = (float)(unsigned int)v6;
      this->m_fTimeElapsedFloat = v6;
    }
    else
    {
      this->m_fTimeElapsedFloat = 0.0;
      v7 = 0.0;
      this->m_uiFinishTime = (unsigned int)(float)(TheCamera.m_arrPathArray[2].m_arr_PathData[10
                                                                                            * (int)*TheCamera.m_arrPathArray[2].m_arr_PathData
                                                                                            - 9]
                                                 * 1000.0);
      CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerSource = 11;
      TheCamera.m_bStartingSpline = 1;
      CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerFront = 11;
      CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerUp = 5;
      CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerFOV = 5;
      CCam::Process_FlyBy(CVector const&,float,float,float)::PsuedoFOV = TheCamera.m_arrPathArray[0].m_arr_PathData[2];
    }
    m_uiFinishTime = (float)this->m_uiFinishTime;
    if ( v7 >= m_uiFinishTime )
    {
      CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerSource = 10
                                                                               * (int)*TheCamera.m_arrPathArray[2].m_arr_PathData
                                                                               - 9;
      CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerFront = 10
                                                                              * (int)*TheCamera.m_arrPathArray[3].m_arr_PathData
                                                                              - 9;
      CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerUp = 4
                                                                           * (int)*TheCamera.m_arrPathArray[1].m_arr_PathData
                                                                           - 3;
      CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerFOV = 4
                                                                            * (int)*TheCamera.m_arrPathArray[0].m_arr_PathData
                                                                            - 3;
      FindSplinePathPositionVector(
        &this->Source,
        TheCamera.m_arrPathArray[2].m_arr_PathData,
        v7,
        &CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerSource);
      FindSplinePathPositionVector(
        &this->Front,
        TheCamera.m_arrPathArray[3].m_arr_PathData,
        v7,
        &CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerFront);
      FindSplinePathPositionFloat(
        &pResult,
        TheCamera.m_arrPathArray[1].m_arr_PathData,
        v7,
        &CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerUp);
      pResult = (float)((float)(pResult * 3.1416) / 180.0) + 1.5708;
      v34 = pResult;
      this->Up.z = sinf(pResult);
      this->Up.x = cosf(v34);
      FindSplinePathPositionFloat(
        &CCam::Process_FlyBy(CVector const&,float,float,float)::PsuedoFOV,
        TheCamera.m_arrPathArray[0].m_arr_PathData,
        v7,
        &CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerFOV);
      CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerFOV = 0;
      CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerFront = 0;
      CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerSource = 0;
      TheCamera.m_fPositionAlongSpline = 1.0;
      CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerUp = 0;
      v35 = this->Front.x - this->Source.x;
      v36 = this->Front.y - this->Source.y;
      v37 = *(_QWORD *)&this->Front.x;
      v38 = this->Front.z - this->Source.z;
      this->m_cvecTargetCoorsForFudgeInter.z = this->Front.z;
      *(_QWORD *)&this->m_cvecTargetCoorsForFudgeInter.x = v37;
      this->Front.x = v35;
      this->Front.y = v36;
      this->Front.z = v38;
      CVector::Normalise(&this->Front);
      CrossProduct(&v40, &this->Up, &this->Front);
      z = v40.z;
      v31 = *(_QWORD *)&v40.x;
      p_Front = &this->Front;
    }
    else
    {
      TheCamera.m_fPositionAlongSpline = v7 / m_uiFinishTime;
      v9 = TheCamera.m_arrPathArray[2].m_arr_PathData[1];
      if ( (float)((float)(TheCamera.m_arrPathArray[2].m_arr_PathData[CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerSource]
                         - v9)
                 * 1000.0) <= v7 )
      {
        v10 = CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerSource + 10;
        v11 = &TheCamera.m_arrPathArray[2].m_arr_PathData[CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerSource
                                                        + 10];
        do
        {
          CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerSource = v10;
          v10 += 10;
          v12 = *v11;
          v11 += 10;
        }
        while ( (float)((float)(v12 - v9) * 1000.0) <= v7 );
      }
      FindSplinePathPositionVector(
        &this->Source,
        TheCamera.m_arrPathArray[2].m_arr_PathData,
        v7,
        &CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerSource);
      v13 = TheCamera.m_arrPathArray[3].m_arr_PathData[1];
      if ( (float)((float)(TheCamera.m_arrPathArray[3].m_arr_PathData[CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerFront]
                         - v13)
                 * 1000.0) <= v7 )
      {
        v14 = CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerFront + 10;
        v15 = &TheCamera.m_arrPathArray[3].m_arr_PathData[CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerFront
                                                        + 10];
        do
        {
          CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerFront = v14;
          v14 += 10;
          v16 = *v15;
          v15 += 10;
        }
        while ( (float)((float)(v16 - v13) * 1000.0) <= v7 );
      }
      FindSplinePathPositionVector(
        &this->Front,
        TheCamera.m_arrPathArray[3].m_arr_PathData,
        v7,
        &CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerFront);
      v17 = TheCamera.m_arrPathArray[1].m_arr_PathData[1];
      if ( (float)((float)(TheCamera.m_arrPathArray[1].m_arr_PathData[CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerUp]
                         - v17)
                 * 1000.0) <= v7 )
      {
        v18 = CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerUp + 4;
        v19 = &TheCamera.m_arrPathArray[1].m_arr_PathData[CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerUp
                                                        + 4];
        do
        {
          CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerUp = v18;
          v18 += 4;
          v20 = *v19;
          v19 += 4;
        }
        while ( (float)((float)(v20 - v17) * 1000.0) <= v7 );
      }
      FindSplinePathPositionFloat(
        &pResult,
        TheCamera.m_arrPathArray[1].m_arr_PathData,
        v7,
        &CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerUp);
      v21 = (float)(pResult * 3.1416) / 180.0;
      v22 = sinf(v21 + 1.5708);
      pResult = v21 + 1.5708;
      this->Up.z = v22;
      this->Up.x = cosf(v21 + 1.5708);
      v23 = TheCamera.m_arrPathArray[0].m_arr_PathData[1];
      if ( (float)((float)(TheCamera.m_arrPathArray[0].m_arr_PathData[CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerFOV]
                         - v23)
                 * 1000.0) <= v7 )
      {
        v24 = CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerFOV + 4;
        v25 = &TheCamera.m_arrPathArray[0].m_arr_PathData[CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerFOV
                                                        + 4];
        do
        {
          CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerFOV = v24;
          v24 += 4;
          v26 = *v25;
          v25 += 4;
        }
        while ( (float)((float)(v26 - v23) * 1000.0) <= v7 );
      }
      FindSplinePathPositionFloat(
        &CCam::Process_FlyBy(CVector const&,float,float,float)::PsuedoFOV,
        TheCamera.m_arrPathArray[0].m_arr_PathData,
        v7,
        &CCam::Process_FlyBy(CVector const&,float,float,float)::ArrayMarkerFOV);
      v27 = this->Front.x - this->Source.x;
      v28 = this->Front.y - this->Source.y;
      v29 = *(_QWORD *)&this->Front.x;
      v30 = this->Front.z - this->Source.z;
      this->m_cvecTargetCoorsForFudgeInter.z = this->Front.z;
      *(_QWORD *)&this->m_cvecTargetCoorsForFudgeInter.x = v29;
      this->Front.x = v27;
      this->Front.y = v28;
      this->Front.z = v30;
      CVector::Normalise(&this->Front);
      CrossProduct(&v40, &this->Up, &this->Front);
      v31 = *(_QWORD *)&v40.x;
      z = v40.z;
      p_Front = &this->Front;
    }
    v2.z = z;
    *(_QWORD *)&v2.x = v31;
    CrossProduct(&v40, p_Front, &v2);
    v39 = *(_QWORD *)&v40.x;
    this->Up.z = v40.z;
    *(_QWORD *)&this->Up.x = v39;
    CVector::Normalise(&this->Up);
    this->FOV = CCam::Process_FlyBy(CVector const&,float,float,float)::PsuedoFOV;
  }
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (00463724) --------------------------------------------------------
Int16 __fastcall FindCutsceneAudioTrackId(const unsigned __int8 *pName)
{
  const char *v2; // r1
  int32 *p_id; // r5

  v2 = "BCESAR2";
  p_id = &musicNameIdAssoc[0].id;
  while ( strcasecmp((const char *)pName, v2) )
  {
    v2 = (const char *)p_id[1];
    p_id += 2;
    if ( !v2 )
      return -1;
  }
  return *p_id;
}

//----- (00463760) --------------------------------------------------------
const unsigned __int8 *__fastcall GetNextLine(
        const unsigned __int8 *p_cSource,
        unsigned __int8 *p_cTarget,
        uint32 uMax)
{
  char *v3; // r2
  bool v4; // zf
  const unsigned __int8 *result; // r0
  int v6; // r3

  while ( 1 )
  {
    v3 = (char *)*p_cSource;
    v4 = v3 == &byte_9[1];
    if ( v3 != &byte_9[1] )
      v4 = v3 == &byte_9[4];
    if ( !v4 )
      break;
    ++p_cSource;
  }
  if ( !*p_cSource )
    return 0;
  v6 = 0;
  while ( (unsigned __int8)v3 > 0xDu || ((1 << (char)v3) & 0x2401) == 0 )
  {
    p_cTarget[v6] = (unsigned __int8)v3;
    v3 = (char *)&p_cSource[v6++];
    LOBYTE(v3) = v3[1];
  }
  result = &p_cSource[v6];
  p_cTarget[v6] = 0;
  return result;
}

//----- (004637A8) --------------------------------------------------------
void CCutsceneMgr::LoadCutsceneData_preload()
{
  int32 *p_id; // r5
  const char *v1; // r1
  int32 v2; // r4
  uint8 *p_m_status; // r6
  CBaseModelInfo *v4; // r5
  CWanted *v5; // r4
  char v6; // r6
  CPlayerPed *PlayerPed; // r6
  CPlayerInfo *v8; // r5
  CWanted **p_m_Wanted; // r0
  CPad *Pad; // r0
  _BYTE *v11; // r4
  RwStream_0 *v12; // r5
  int v13; // r8
  unsigned __int8 (*v14)[32]; // r3
  int32 *v15; // r5
  unsigned __int8 (*v16)[32]; // r12
  int v17; // r6
  char *v18; // r0
  bool v19; // zf
  int v20; // r1
  int v21; // r0
  int v22; // r0
  int v23; // r0
  CVehicle *m_pMyVehicle; // r1
  CPlayerPed *v25; // r5
  bool v26; // zf
  CTaskSimpleCarSetPedOut *v27; // r0
  char *v28; // r0
  char *v29; // r0
  char *v30; // r5
  int32 v31; // r0
  int32 v32; // r0
  char *v33; // r1
  int v34; // r5
  unsigned __int8 v35; // r6
  char v36; // r0
  int32 v37; // r0
  char *v38; // r0
  int32 v39; // r2
  int v40; // r0
  int32 *v41; // r2
  CTask *v42; // r3
  CutsceneRemove *v43; // r0
  CVehicle *v44; // r2
  char *v45; // r0
  char *v46; // r0
  char *v47; // r0
  char *v48; // r0
  char *v49; // r0
  char *v50; // r0
  double v51; // r0
  char *v52; // r0
  double v53; // r0
  char *v54; // r0
  double v55; // r0
  char *v56; // r0
  double v57; // r0
  char *v58; // r0
  double v59; // r0
  char *v60; // r0
  double v61; // r0
  float v62; // s4
  float v63; // s2
  float v64; // s0
  float v65; // s6
  float v66; // s8
  float v67; // s10
  CutscenePEffect *v68; // r0
  int v69; // r0
  int v70; // r9
  int32 v71; // r6
  const char *v72; // r4
  const char *v73; // r5
  int v74; // r4
  int i; // r11
  int32 v76; // r0
  int (**v77)(void); // r0
  uint8 *v78; // r0
  int v79; // t1
  unsigned int v80; // [sp+8h] [bp-530h]
  unsigned int v81; // [sp+Ch] [bp-52Ch]
  unsigned int v82; // [sp+10h] [bp-528h]
  unsigned int v83; // [sp+14h] [bp-524h]
  unsigned int v84; // [sp+18h] [bp-520h]
  unsigned int v85; // [sp+1Ch] [bp-51Ch]
  unsigned int v86; // [sp+20h] [bp-518h]
  unsigned int v87; // [sp+24h] [bp-514h]
  unsigned int v88; // [sp+28h] [bp-510h]
  unsigned int v89; // [sp+2Ch] [bp-50Ch]
  unsigned int v90; // [sp+30h] [bp-508h]
  unsigned int v91; // [sp+34h] [bp-504h]
  int v92; // [sp+38h] [bp-500h]
  int v93; // [sp+3Ch] [bp-4FCh]
  int v94; // [sp+40h] [bp-4F8h]
  void *v95; // [sp+98h] [bp-4A0h]
  int v96; // [sp+9Ch] [bp-49Ch]
  int32 *v97; // [sp+A0h] [bp-498h]
  unsigned __int8 (*v98)[32]; // [sp+A8h] [bp-490h]
  unsigned __int8 (*v99)[32]; // [sp+ACh] [bp-48Ch]
  CVehicle *v100; // [sp+B0h] [bp-488h] BYREF
  CTask *v101; // [sp+B4h] [bp-484h] BYREF
  uint32 offset; // [sp+B8h] [bp-480h] BYREF
  uint32 v103; // [sp+BCh] [bp-47Ch] BYREF
  __int64 v104[4]; // [sp+C0h] [bp-478h] BYREF
  CTaskSimpleCarSetPedOut v105; // [sp+E0h] [bp-458h] BYREF
  __int64 v106; // [sp+F8h] [bp-440h]
  char v107[7]; // [sp+104h] [bp-434h] BYREF
  char v108[1017]; // [sp+10Bh] [bp-42Dh] BYREF

  if ( strcasecmp((const char *)CCutsceneMgr::ms_cutsceneName, "finale") )
  {
    p_id = &musicNameIdAssoc[0].id;
    v1 = "BCESAR2";
    while ( strcasecmp((const char *)CCutsceneMgr::ms_cutsceneName, v1) )
    {
      v1 = (const char *)p_id[1];
      p_id += 2;
      if ( !v1 )
        goto LABEL_8;
    }
    if ( (unsigned __int16)*p_id != 0xFFFF )
      CAudioEngine::PreloadCutsceneTrack(&AudioEngine, *p_id, 1u);
  }
LABEL_8:
  v2 = 300;
  p_m_status = &CStreaming::ms_aInfoForModel[300].m_status;
  do
  {
    v4 = CModelInfo::ms_modelInfoPtrs[v2];
    if ( v4->m_numRefs <= 0 )
    {
      if ( *p_m_status == 1 )
      {
        CStreaming::RemoveModel(v2);
        v4 = CModelInfo::ms_modelInfoPtrs[v2];
      }
      v4->m_hashKey = CKeyGen::GetUppercaseKey((const unsigned __int8 *)&dword_4642E0);
      *(_DWORD *)v4->m_modelName = (char *)&loc_252A24 + 2;
    }
    ++v2;
    p_m_status += 20;
  }
  while ( v2 != 320 );
  v5 = 0;
  v6 = CTimeCycle::m_bExtraColourOn;
  g_bCutSceneFinishing = 0;
  CCutsceneMgr::ms_cutsceneOffset.x = 0.0;
  CCutsceneMgr::ms_cutsceneOffset.y = 0.0;
  CCutsceneMgr::ms_cutsceneOffset.z = 0.0;
  CCutsceneMgr::m_fPrevCarDensity = CCarCtrl::CarDensityMultiplier;
  CCutsceneMgr::ms_numTextOutput = 0;
  CCutsceneMgr::ms_currTextOutput = 0;
  CCutsceneMgr::ms_numLoadObjectNames = 0;
  CCutsceneMgr::ms_numUncompressedCutsceneAnims = 0;
  CCutsceneMgr::ms_numAttachObjectToBones = 0;
  CCutsceneMgr::ms_iNumHiddenEntities = 0;
  CCutsceneMgr::ms_iNumParticleEffects = 0;
  CCutsceneMgr::m_PrevExtraColour = CTimeCycle::m_ExtraColour;
  CCutsceneMgr::m_fPrevPedDensity = CPopulation::PedDensityMultiplier;
  if ( CTimeCycle::m_bExtraColourOn )
    v6 = 1;
  CCutsceneMgr::ms_aUncompressedCutsceneAnims[1][0] = 0;
  CCutsceneMgr::ms_aUncompressedCutsceneAnims[0][0] = 0;
  CCutsceneMgr::ms_aUncompressedCutsceneAnims[2][0] = 0;
  CCutsceneMgr::ms_aUncompressedCutsceneAnims[3][0] = 0;
  CCutsceneMgr::ms_aUncompressedCutsceneAnims[4][0] = 0;
  CCutsceneMgr::ms_aUncompressedCutsceneAnims[5][0] = 0;
  CCutsceneMgr::ms_aUncompressedCutsceneAnims[6][0] = 0;
  CCutsceneMgr::ms_aUncompressedCutsceneAnims[7][0] = 0;
  CCutsceneMgr::m_PrevExtraColourOn = v6;
  memset(CCutsceneMgr::ms_iModelIndex, 0, sizeof(CCutsceneMgr::ms_iModelIndex));
  CCamera::SetNearClipScript(&TheCamera, 0.1);
  CRubbish::SetVisibility(0);
  PlayerPed = FindPlayerPed(-1);
  v8 = &CWorld::Players[CWorld::PlayerInFocus];
  p_m_Wanted = &PlayerPed->m_pPlayerData->m_Wanted;
  if ( p_m_Wanted )
    v5 = *p_m_Wanted;
  CWanted::ClearQdCrimes(v5);
  *(_DWORD *)&PlayerPed->m_nFlags &= ~0x80u;
  CPlayerPed::ResetSprintEnergy(PlayerPed);
  Pad = CPad::GetPad(0);
  Pad->DisablePlayerControls |= 0x80u;
  CPlayerInfo::MakePlayerSafe(v8, 1, 10000.0);
  sprintf(gString, "%s.CUT", (const char *)CCutsceneMgr::ms_cutsceneName);
  if ( !CDirectory::FindItem(CCutsceneMgr::ms_pCutsceneDir, gString, &offset, &v103) )
    goto LABEL_96;
  offset <<= 11;
  v103 <<= 11;
  v11 = (_BYTE *)operator new[](v103);
  v12 = RwStreamOpen(rwSTREAMFILENAME, rwSTREAMREAD, "ANIM\\CUTS.IMG");
  RwStreamSkip(v12, offset);
  RwStreamRead(v12, v11, v103);
  RwStreamClose(v12, 0);
  v13 = 0;
  v14 = CCutsceneMgr::ms_cLoadObjectName;
  v15 = CCutsceneMgr::ms_iModelIndex;
  v16 = CCutsceneMgr::ms_cLoadAnimName;
  v95 = v11;
  v96 = 0;
  while ( 1 )
  {
    v17 = v13;
    while ( 1 )
    {
      v18 = (char *)(unsigned __int8)*v11;
      v19 = v18 == &byte_9[1];
      if ( v18 != &byte_9[1] )
        v19 = v18 == &byte_9[4];
      if ( !v19 )
        break;
      ++v11;
    }
    if ( !*v11 )
      break;
    v20 = 0;
    while ( (unsigned __int8)v18 > 0xDu || ((1 << (char)v18) & 0x2401) == 0 )
    {
      v107[v20] = (char)v18;
      v18 = &v11[v20++];
      LOBYTE(v18) = v18[1];
    }
    v11 += v20;
    v107[v20] = 0;
    if ( !v11 )
      break;
    v98 = v16;
    v99 = v14;
    v97 = v15;
    v21 = strcmp(v107, (const char *)&off_464354);
    v16 = v98;
    v14 = v99;
    v13 = 0;
    if ( v21 )
    {
      v13 = v17;
      switch ( v17 )
      {
        case 0:
          v13 = strcmp(v107, "info") == 0;
          if ( !strcmp(v107, "model") )
            v13 = 2;
          if ( !strcmp(v107, "text") )
            v13 = 3;
          if ( !strcmp(v107, "uncompress") )
            v13 = 4;
          if ( !strcmp(v107, "attach") )
            v13 = 5;
          if ( !strcmp(v107, "remove") )
            v13 = 6;
          if ( !strcmp(v107, "peffect") )
            v13 = 7;
          v22 = strcmp(v107, "extracol");
          v16 = v98;
          v14 = v99;
          if ( !v22 )
            v13 = 8;
          continue;
        case 1:
          v23 = strncmp(v107, "offset", 6u);
          v13 = 1;
          v16 = v98;
          v14 = v99;
          if ( !v23 )
          {
            sscanf(v108, "%f %f %f", v104, &v101, &v100);
            v25 = FindPlayerPed(-1);
            v26 = *((unsigned __int8 *)&v25->m_nPedFlags + 1) << 31 == 0;
            if ( *((unsigned __int8 *)&v25->m_nPedFlags + 1) << 31 )
            {
              m_pMyVehicle = v25->m_pMyVehicle;
              v26 = m_pMyVehicle == 0;
            }
            if ( !v26 )
            {
              CTaskSimpleCarSetPedOut::CTaskSimpleCarSetPedOut(&v105, m_pMyVehicle, 0, 1);
              v105.m_bWarpingOutOfCar = 1;
              CTaskSimpleCarSetPedOut::ProcessPed(v27, v25);
              CTaskSimpleCarSetPedOut::~CTaskSimpleCarSetPedOut(&v105);
            }
            CCutsceneMgr::ms_cutsceneOffset.x = *(RwReal *)v104;
            LODWORD(CCutsceneMgr::ms_cutsceneOffset.y) = v101;
            LODWORD(CCutsceneMgr::ms_cutsceneOffset.z) = v100;
            CIplStore::AddIplsNeededAtPosn(&CCutsceneMgr::ms_cutsceneOffset);
            CStreaming::SetLoadVehiclesInLoadScene(0);
            v105._vptr$CTask = (int (**)(void))v104[0];
            v105.m_pParent = v101;
            v105.m_pTargetVehicle = v100;
            CStreaming::LoadScene((const CVector *)&v105);
            v13 = 1;
            CStreaming::SetLoadVehiclesInLoadScene(1);
            goto LABEL_20;
          }
          continue;
        case 2:
          v28 = strtok(v107, (const char *)&off_46438C);
          sscanf(v28, (const char *)&dword_4643AC, &v101);
          v29 = strtok(0, (const char *)&off_46438C);
          strcpy((char *)&v105, v29);
          v30 = strtok(0, (const char *)&off_46438C);
          (*((void (__fastcall **)(CTaskSimpleCarSetPedOut *))RwEngineInstance + 72))(&v105);
          if ( v30 )
          {
            LOBYTE(v104[0]) = 0;
            strcpy((char *)v104, v30);
            (*((void (__fastcall **)(__int64 *))RwEngineInstance + 72))(v104);
            strcpy((char *)CCutsceneMgr::ms_cLoadObjectName[CCutsceneMgr::ms_numLoadObjectNames], (const char *)&v105);
            strcpy((char *)CCutsceneMgr::ms_cLoadAnimName[CCutsceneMgr::ms_numLoadObjectNames], (const char *)v104);
            v31 = CCutsceneMgr::ms_numLoadObjectNames;
            CCutsceneMgr::ms_iModelIndex[CCutsceneMgr::ms_numLoadObjectNames] = 2;
            CCutsceneMgr::ms_bRepeatObject[v31] = 0;
            for ( CCutsceneMgr::ms_numLoadObjectNames = v31 + 1; ; CCutsceneMgr::ms_numLoadObjectNames = v32 + 1 )
            {
              v33 = strtok(0, (const char *)&off_46438C);
              if ( !v33 )
                break;
              LOBYTE(v104[0]) = 0;
              strcpy((char *)v104, v33);
              (*((void (__fastcall **)(__int64 *))RwEngineInstance + 72))(v104);
              strcpy((char *)v99[CCutsceneMgr::ms_numLoadObjectNames], (const char *)&v105);
              strcpy((char *)v98[CCutsceneMgr::ms_numLoadObjectNames], (const char *)v104);
              v32 = CCutsceneMgr::ms_numLoadObjectNames;
              CCutsceneMgr::ms_bRepeatObject[CCutsceneMgr::ms_numLoadObjectNames] = 1;
              v97[v32] = 3;
            }
          }
          v13 = 2;
          goto LABEL_20;
        case 3:
          sscanf(v107, "%d,%d,%s", v104, &v101, &v105);
          if ( strlen((const char *)&v105) )
          {
            v34 = 0;
            v35 = 0;
            do
            {
              v36 = *((_BYTE *)&v105._vptr$CTask + v34);
              ++v35;
              if ( (unsigned __int8)(v36 - 97) <= 0x19u )
                *((_BYTE *)&v105._vptr$CTask + v34) = v36 - 32;
              v34 = v35;
            }
            while ( strlen((const char *)&v105) > v35 );
          }
          strcpy((char *)CCutsceneMgr::ms_cTextOutput[CCutsceneMgr::ms_numTextOutput], (const char *)&v105);
          v37 = CCutsceneMgr::ms_numTextOutput;
          v13 = 3;
          CCutsceneMgr::ms_iTextStartTime[CCutsceneMgr::ms_numTextOutput] = v104[0];
          CCutsceneMgr::ms_iTextDuration[v37] = (int32)v101;
          CCutsceneMgr::ms_numTextOutput = v37 + 1;
          goto LABEL_20;
        case 4:
          v38 = strtok(v107, (const char *)&off_46438C);
          CCutsceneMgr::LoadAnimationUncompressed((const unsigned __int8 *)v38);
          v13 = 4;
          v16 = v98;
          v14 = v99;
          continue;
        case 5:
          sscanf(v107, "%d,%d,%d", &v105, v104, &v101);
          v13 = 5;
          v16 = v98;
          v39 = CCutsceneMgr::ms_numAttachObjectToBones;
          v40 = CCutsceneMgr::ms_numAttachObjectToBones + 1;
          CCutsceneMgr::ms_iAttachObjectToBone[CCutsceneMgr::ms_numAttachObjectToBones][0] = (int32)v105._vptr$CTask;
          v41 = CCutsceneMgr::ms_iAttachObjectToBone[v39];
          v42 = v101;
          v41[1] = v104[0];
          v41[2] = (int32)v42;
          v14 = v99;
          CCutsceneMgr::ms_numAttachObjectToBones = v40;
          continue;
        case 6:
          sscanf(v107, "%f,%f,%f,%s", v104, &v101, &v100, &v105);
          v43 = &CCutsceneMgr::ms_crToHideItems[CCutsceneMgr::ms_iNumHiddenEntities];
          v43->m_fX = *(float *)v104;
          v44 = v100;
          LODWORD(v43->m_fY) = v101;
          LODWORD(v43->m_fZ) = v44;
          strcpy((char *)v43->m_cObjectName, (const char *)&v105);
          v13 = 6;
          v16 = v98;
          v14 = v99;
          ++CCutsceneMgr::ms_iNumHiddenEntities;
          continue;
        case 7:
          memset(&v105, 0, sizeof(v105));
          v106 = 0LL;
          memset(v104, 0, sizeof(v104));
          v45 = strtok(v107, (const char *)&off_464358);
          strncpy((char *)&v105, v45, 0x1Fu);
          v46 = strtok(0, (const char *)&off_464358);
          v94 = atoi(v46);
          v47 = strtok(0, (const char *)&off_464358);
          v93 = atoi(v47);
          v48 = strtok(0, (const char *)&off_464358);
          v92 = atoi(v48);
          v49 = strtok(0, (const char *)&off_464358);
          strncpy((char *)v104, v49, 0x1Fu);
          v50 = strtok(0, (const char *)&off_464358);
          v51 = atof(v50);
          v90 = HIDWORD(v51);
          v91 = LODWORD(v51);
          v52 = strtok(0, (const char *)&off_464358);
          v53 = atof(v52);
          v88 = HIDWORD(v53);
          v89 = LODWORD(v53);
          v54 = strtok(0, (const char *)&off_464358);
          v55 = atof(v54);
          v86 = HIDWORD(v55);
          v87 = LODWORD(v55);
          v56 = strtok(0, (const char *)&off_464358);
          v57 = atof(v56);
          v84 = HIDWORD(v57);
          v85 = LODWORD(v57);
          v58 = strtok(0, (const char *)&off_464358);
          v59 = atof(v58);
          v82 = HIDWORD(v59);
          v83 = LODWORD(v59);
          v60 = strtok(0, (const char *)&off_464358);
          v61 = atof(v60);
          v80 = HIDWORD(v61);
          v81 = LODWORD(v61);
          LODWORD(v61) = &CCutsceneMgr::ms_pParticleEffects[CCutsceneMgr::ms_iNumParticleEffects];
          *(_DWORD *)(LODWORD(v61) + 32) = 0;
          *(_DWORD *)(LODWORD(v61) + 36) = v94;
          *(_DWORD *)(LODWORD(v61) + 40) = v93;
          *(_DWORD *)(LODWORD(v61) + 44) = v92;
          strcpy((char *)(LODWORD(v61) + 48), (const char *)v104);
          v62 = COERCE_DOUBLE(__PAIR64__(v86, v87));
          v63 = COERCE_DOUBLE(__PAIR64__(v90, v91));
          v64 = COERCE_DOUBLE(__PAIR64__(v88, v89));
          v65 = COERCE_DOUBLE(__PAIR64__(v84, v85));
          v66 = COERCE_DOUBLE(__PAIR64__(v82, v83));
          v67 = COERCE_DOUBLE(__PAIR64__(v80, v81));
          v68 = &CCutsceneMgr::ms_pParticleEffects[CCutsceneMgr::ms_iNumParticleEffects];
          v68->m_fPosX = v63;
          v68->m_fPosY = v64;
          v68->m_fPosZ = v62;
          v68->m_fDirX = v65;
          v68->m_fDirY = v66;
          v68->m_fDirZ = v67;
          *(_WORD *)&v68->m_bPlaying = 0;
          strcpy((char *)v68, (const char *)&v105);
          v13 = 7;
          v16 = v98;
          v14 = v99;
          ++CCutsceneMgr::ms_iNumParticleEffects;
          continue;
        case 8:
          v13 = 8;
          v19 = v96 << 31 == 0;
          v96 = 1;
          if ( !v19 )
            continue;
          sscanf(v107, (const char *)&dword_4643AC, &v105, v99);
          if ( v105._vptr$CTask )
          {
            CTimeCycle::StartExtraColour((Int32)--v105._vptr$CTask, 0);
            v69 = 1;
          }
          else
          {
            v69 = 0;
          }
          v13 = 8;
          v96 = v69;
LABEL_20:
          v16 = v98;
          v14 = v99;
          v15 = v97;
          break;
        default:
          continue;
      }
    }
  }
  operator delete[](v95);
  if ( !(v96 << 31) )
    CTimeCycle::StopExtraColour(0);
  v70 = CCutsceneMgr::ms_numLoadObjectNames;
  if ( CCutsceneMgr::ms_numAppendObjectNames >= 1 )
  {
    v71 = 0;
    v72 = (const char *)CCutsceneMgr::ms_cAppendObjectName;
    v73 = (const char *)CCutsceneMgr::ms_cAppendAnimName;
    do
    {
      strcpy((char *)CCutsceneMgr::ms_cLoadObjectName[v70], v72);
      strcpy((char *)CCutsceneMgr::ms_cLoadAnimName[CCutsceneMgr::ms_numLoadObjectNames], v73);
      v73 += 32;
      v72 += 32;
      v70 = CCutsceneMgr::ms_numLoadObjectNames + 1;
      ++v71;
      CCutsceneMgr::ms_iModelIndex[CCutsceneMgr::ms_numLoadObjectNames] = 2;
      CCutsceneMgr::ms_numLoadObjectNames = v70;
    }
    while ( v71 < CCutsceneMgr::ms_numAppendObjectNames );
  }
  CCutsceneMgr::ms_numAppendObjectNames = 0;
  if ( v70 )
  {
    if ( v70 >= 1 )
    {
      v74 = 0;
      for ( i = 0; i < v70; ++i )
      {
        if ( !strcasecmp((const char *)CCutsceneMgr::ms_cLoadObjectName[i], "csplay") )
        {
          CCutsceneMgr::ms_iModelIndex[i] = 1;
        }
        else
        {
          v76 = CCutsceneMgr::ms_iModelIndex[i];
          if ( v76 == 3 )
          {
            CCutsceneMgr::ms_iModelIndex[i] = CCutsceneMgr::ms_iModelIndex[i - 1];
          }
          else if ( v76 == 2 )
          {
            if ( CModelInfo::GetModelInfo(CCutsceneMgr::ms_cLoadObjectName[i], (int32 *)&v105) )
            {
              v77 = v105._vptr$CTask;
              CCutsceneMgr::ms_iModelIndex[i] = (int32)v105._vptr$CTask;
              CStreaming::RequestModel((int32)v77, 28);
            }
            else
            {
              CCutsceneMgr::ms_iModelIndex[i] = v74 + 300;
              CStreaming::RequestSpecialModel(v74 + 300, CCutsceneMgr::ms_cLoadObjectName[i], 28);
              v78 = &CStreaming::ms_aInfoForModel[v74 + 301].m_status;
              do
              {
                v79 = *v78;
                v78 += 20;
                ++v74;
              }
              while ( v79 == 1 );
            }
            v70 = CCutsceneMgr::ms_numLoadObjectNames;
          }
        }
      }
    }
    CStreaming::LoadAllRequestedModels(1);
    CCutsceneMgr::ms_cutsceneLoadStatus = 1;
  }
  else
  {
LABEL_96:
    CCutsceneMgr::LoadCutsceneData_postload();
  }
}
// 463CEA: variable 'm_pMyVehicle' is possibly undefined
// 463CF4: variable 'v27' is possibly undefined
// 4642E0: using guessed type int dword_4642E0;
// 464354: using guessed type void *off_464354;
// 464358: using guessed type __int16 *off_464358;
// 46438C: using guessed type void *off_46438C;
// 4643AC: using guessed type int dword_4643AC;
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];
// 9AE230: using guessed type char g_bCutSceneFinishing;
// 4637A8: using guessed type char var_434[7];
// 4637A8: using guessed type char anonymous_4[1017];

//----- (0046449C) --------------------------------------------------------
void CCutsceneMgr::LoadCutsceneData_postload()
{
  RwStream_0 *v0; // r4
  RwUInt32 v1; // r5
  RwStream_0 *v2; // r5
  CWanted *m_Wanted; // r5
  u_native v4; // r4
  bool Item; // zf
  char v6; // r0
  CPlayerPedData *m_pPlayerData; // r0
  void *pData[2]; // [sp+8h] [bp-20h] BYREF
  uint32 v9; // [sp+10h] [bp-18h] BYREF
  uint32 v10[5]; // [sp+14h] [bp-14h] BYREF

  CMessages::ClearThisBigPrintNow(0);
  CCarCtrl::CarDensityMultiplier = 0.0;
  CPopulation::PedDensityMultiplier = 0.0;
  CStreaming::ms_disableStreaming = 0;
  v0 = RwStreamOpen(rwSTREAMFILENAME, rwSTREAMREAD, "ANIM\\CUTS.IMG");
  sprintf(gString, "%s.IFP", (const char *)CCutsceneMgr::ms_cutsceneName);
  if ( CDirectory::FindItem(CCutsceneMgr::ms_pCutsceneDir, gString, &v9, v10) )
  {
    CStreaming::MakeSpaceFor(v10[0] << 10);
    CStreaming::ImGonnaUseStreamingMemory();
    RwStreamSkip(v0, v9 << 11);
    v1 = v10[0] << 11;
    pData[1] = (void *)(v10[0] << 11);
    pData[0] = malloc(v10[0] << 11);
    RwStreamRead(v0, pData[0], v1);
    v2 = RwStreamOpen(rwSTREAMMEMORY, rwSTREAMREAD, pData);
    CAnimManager::LoadAnimFile(v2, 1, CCutsceneMgr::ms_aUncompressedCutsceneAnims);
    RwStreamClose(v2, 0);
    free(pData[0]);
    CAnimBlendAssocGroup::CreateAssociations(
      &CCutsceneMgr::ms_cutsceneAssociations,
      CCutsceneMgr::ms_cutsceneName,
      CCutsceneMgr::ms_cLoadAnimName[0],
      CCutsceneMgr::ms_cLoadObjectName[0],
      32);
    CStreaming::IHaveUsedStreamingMemory();
    CCutsceneMgr::ms_animLoaded = 1;
  }
  else
  {
    CCutsceneMgr::ms_animLoaded = 0;
  }
  m_Wanted = 0;
  RwStreamClose(v0, 0);
  v4 = CFileMgr::OpenFile("ANIM\\CUTS.IMG", (const unsigned __int8 *)&dword_464674);
  sprintf(gString, "%s.DAT", (const char *)CCutsceneMgr::ms_cutsceneName);
  Item = CDirectory::FindItem(CCutsceneMgr::ms_pCutsceneDir, gString, &v9, v10);
  v6 = 0;
  if ( Item )
  {
    CStreaming::ImGonnaUseStreamingMemory();
    CFileMgr::Seek(v4, v9 << 11, 0);
    CCamera::LoadPathSplines(&TheCamera, v4);
    CStreaming::IHaveUsedStreamingMemory();
    v6 = 1;
  }
  bCameraAvailable = v6;
  CCutsceneMgr::ms_cutsceneLoadStatus = 2;
  CCutsceneMgr::ms_cutsceneTimer = 0.0;
  m_pPlayerData = FindPlayerPed(-1)->m_pPlayerData;
  if ( m_pPlayerData )
    m_Wanted = m_pPlayerData->m_Wanted;
  CWanted::ClearQdCrimes(m_Wanted);
}
// 464674: using guessed type int dword_464674;

//----- (0046469C) --------------------------------------------------------
void CCutsceneMgr::HideRequestedObjects()
{
  int v0; // r1
  int v1; // r11
  __int64 v2; // kr00_8
  Int16 v3; // r1
  int v4; // r5
  CEntity *v5; // r0
  int32 v6; // r1
  int v7; // r0
  int v8; // [sp+24h] [bp-B4h]
  CVector Coors; // [sp+28h] [bp-B0h] BYREF
  CEntity *v10[32]; // [sp+34h] [bp-A4h] BYREF
  Int16 pNum; // [sp+B6h] [bp-22h] BYREF
  int32 pIndex[8]; // [sp+B8h] [bp-20h] BYREF

  v0 = CCutsceneMgr::ms_iNumHiddenEntities;
  CCutsceneMgr::ms_iNumHiddenEntities = 0;
  v8 = v0;
  if ( v0 >= 1 )
  {
    v1 = 0;
    do
    {
      if ( CModelInfo::GetModelInfo(CCutsceneMgr::ms_crToHideItems[v1].m_cObjectName, pIndex) )
      {
        v2 = *(_QWORD *)&CCutsceneMgr::ms_crToHideItems[v1].m_fY;
        Coors.x = CCutsceneMgr::ms_crToHideItems[v1].m_fX;
        *(_QWORD *)&Coors.y = v2;
        CWorld::FindObjectsOfTypeInRange(pIndex[0], &Coors, 1.5, 1, &pNum, 32, v10, 1, 0, 0, 1, 1);
        v3 = pNum;
        if ( pNum >= 1 )
        {
          v4 = 0;
          do
          {
            v5 = v10[v4];
            if ( (*(_BYTE *)&v5->m_nFlags & 0x80) != 0 )
            {
              v6 = CCutsceneMgr::ms_iNumHiddenEntities;
              CCutsceneMgr::ms_pHiddenEntities[CCutsceneMgr::ms_iNumHiddenEntities] = v5;
              CEntity::RegisterReference(v5, &CCutsceneMgr::ms_pHiddenEntities[v6]);
              v7 = CCutsceneMgr::ms_iNumHiddenEntities + 1;
              *(_DWORD *)&CCutsceneMgr::ms_pHiddenEntities[CCutsceneMgr::ms_iNumHiddenEntities]->m_nFlags &= ~0x80u;
              v3 = pNum;
              CCutsceneMgr::ms_iNumHiddenEntities = v7;
            }
            ++v4;
          }
          while ( v4 < v3 );
        }
      }
      ++v1;
    }
    while ( v1 != v8 );
  }
}
// 46469C: using guessed type int32 pIndex[8];

//----- (0046479C) --------------------------------------------------------
void CCutsceneMgr::LoadCutsceneData_loading()
{
  int v0; // r1
  int32 v1; // r6
  int32 v2; // r6
  CObject *CutsceneObject; // r5
  const unsigned __int8 *v4; // r4
  RwMatrix *p_resMat; // r4
  CVector *p_pos; // r11
  int v7; // r9
  float *p_m_fPosX; // r8
  RwReal v9; // r1
  RwReal v10; // r2
  RwReal v11; // r1
  RwReal v12; // r2
  int v13; // r0
  RwMatrix *LTM; // r5
  RpClump_0 *m_pRwObject; // r5
  RpAtomic_0 *FirstAtomic; // r0
  RpSkin_0 *Skin; // r0
  unsigned __int8 *m_cItemAttach; // r1
  CVector *v19; // r10
  RwMatrix *v20; // r11
  int v21; // r4
  RpHAnimHierarchy_0 *v22; // r5
  RwInt32 v23; // r4
  RwFrame_0 *FrameFromName; // r0
  int32 v25; // r6
  int32 *v26; // r5
  __int64 v27; // kr00_8
  CObject *v28; // r11
  CObject *v29; // r4
  RpHAnimHierarchy_0 *AnimHierarchyFromSkinClump; // r0
  CVector dir; // [sp+1Ch] [bp-74h] BYREF
  CVector pos; // [sp+28h] [bp-68h] BYREF
  RwMatrix resMat; // [sp+34h] [bp-5Ch] BYREF

  if ( CCutsceneMgr::ms_numLoadObjectNames < 1 )
  {
LABEL_6:
    CCutsceneMgr::LoadCutsceneData_postload();
    if ( CCutsceneMgr::ms_numLoadObjectNames >= 1 )
    {
      v2 = 0;
      CutsceneObject = 0;
      v4 = CCutsceneMgr::ms_cLoadAnimName[0];
      do
      {
        if ( !CCutsceneMgr::ms_bRepeatObject[v2] )
          CutsceneObject = CCutsceneMgr::CreateCutsceneObject(CCutsceneMgr::ms_iModelIndex[v2]);
        if ( *v4 )
          CCutsceneMgr::SetCutsceneAnim(v4, CutsceneObject);
        ++v2;
        v4 += 32;
      }
      while ( v2 < CCutsceneMgr::ms_numLoadObjectNames );
    }
    if ( CCutsceneMgr::ms_iNumParticleEffects < 1 )
    {
LABEL_26:
      if ( CCutsceneMgr::ms_numAttachObjectToBones >= 1 )
      {
        v25 = 0;
        v26 = &CCutsceneMgr::ms_iAttachObjectToBone[0][1];
        do
        {
          v27 = *(_QWORD *)v26;
          v28 = CCutsceneMgr::ms_pCutsceneObjects[*(v26 - 1)];
          v29 = CCutsceneMgr::ms_pCutsceneObjects[*v26];
          AnimHierarchyFromSkinClump = GetAnimHierarchyFromSkinClump((RpClump_0 *)v28->m_pRwObject);
          v29[1]._vptr$CPlaceable = (int (**)(void))RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, SHIDWORD(v27));
          LODWORD(v29[1].m_transform.m_translate.x) = v28;
          v26 += 3;
          ++v25;
        }
        while ( v25 < CCutsceneMgr::ms_numAttachObjectToBones );
      }
      return;
    }
    p_resMat = &resMat;
    p_pos = &pos;
    v7 = 0;
    p_m_fPosX = &CCutsceneMgr::ms_pParticleEffects[0].m_fPosX;
    while ( 1 )
    {
      v9 = p_m_fPosX[1];
      v10 = p_m_fPosX[2];
      pos.x = *p_m_fPosX;
      pos.y = v9;
      pos.z = v10;
      v11 = p_m_fPosX[4];
      v12 = p_m_fPosX[5];
      dir.x = p_m_fPosX[3];
      dir.y = v11;
      dir.z = v12;
      Fx_c::CreateMatFromVec(&g_fx, p_resMat, p_pos, &dir);
      v13 = *((_DWORD *)p_m_fPosX - 9);
      LTM = 0;
      if ( v13 < 1 || v13 > CCutsceneMgr::ms_numCutsceneObjs )
        goto LABEL_25;
      m_pRwObject = (RpClump_0 *)CCutsceneMgr::ms_pCutsceneObjects[v13 - 1]->m_pRwObject;
      FirstAtomic = GetFirstAtomic(m_pRwObject);
      if ( FirstAtomic )
      {
        Skin = j_RpSkinGeometryGetSkin(FirstAtomic->geometry);
        m_cItemAttach = (unsigned __int8 *)(p_m_fPosX - 8);
        if ( Skin )
        {
          v19 = p_pos;
          v20 = p_resMat;
          v21 = atoi((const char *)p_m_fPosX - 32);
          v22 = GetAnimHierarchyFromSkinClump(m_pRwObject);
          v23 = RpHAnimIDGetIndex(v22, v21);
          LTM = &RpHAnimHierarchyGetMatrixArray(v22)[v23];
          p_resMat = v20;
          p_pos = v19;
          goto LABEL_23;
        }
      }
      else
      {
        m_cItemAttach = CCutsceneMgr::ms_pParticleEffects[v7].m_cItemAttach;
      }
      FrameFromName = CClumpModelInfo::GetFrameFromName(m_pRwObject, m_cItemAttach);
      if ( !FrameFromName )
      {
        LTM = 0;
        goto LABEL_25;
      }
      LTM = RwFrameGetLTM(FrameFromName);
LABEL_23:
      TestMatrix(LTM);
LABEL_25:
      *((_DWORD *)p_m_fPosX - 12) = FxManager_c::CreateFxSystem(
                                      &g_fxMan,
                                      (unsigned __int8 *)p_m_fPosX - 80,
                                      p_resMat,
                                      LTM,
                                      1);
      p_m_fPosX += 27;
      if ( ++v7 >= CCutsceneMgr::ms_iNumParticleEffects )
        goto LABEL_26;
    }
  }
  v0 = 0;
  while ( 1 )
  {
    v1 = CCutsceneMgr::ms_iModelIndex[v0];
    if ( (unsigned int)(v1 - 300) <= 0x13 && CStreaming::ms_aInfoForModel[v1].m_status != 1 )
      break;
    if ( ++v0 >= CCutsceneMgr::ms_numLoadObjectNames )
      goto LABEL_6;
  }
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (00464A08) --------------------------------------------------------
CObject *__fastcall CCutsceneMgr::CreateCutsceneObject(int32 id)
{
  CColModel *v2; // r5
  RpClump_0 *m_pRwObject; // r0
  float *p_m_fRadius; // r5
  float v5; // s0
  CColModel *v6; // r0
  CCutsceneObject *v7; // r5
  int32 v8; // r2
  float pData[7]; // [sp+4h] [bp-1Ch] BYREF

  CStreaming::ImGonnaUseStreamingMemory();
  if ( (unsigned int)(id - 300) <= 0x13 )
  {
    v2 = &CTempColModels::ms_colModelCutObj[id - 300];
    CBaseModelInfo::SetColModel(CModelInfo::ms_modelInfoPtrs[id], v2, 0);
    m_pRwObject = (RpClump_0 *)CModelInfo::ms_modelInfoPtrs[id]->m_pRwObject;
    v2->m_sphereBound.m_fRadius = 0.0;
    p_m_fRadius = &v2->m_sphereBound.m_fRadius;
    pData[0] = 0.0;
    RpClumpForAllAtomics(m_pRwObject, CalculateBoundingSphereRadiusCB, pData);
    v5 = pData[0];
    if ( pData[0] > 20.0 )
    {
      pData[0] = 20.0;
      v5 = 20.0;
    }
    *p_m_fRadius = v5;
    v6 = &CTempColModels::ms_colModelCutObj[id - 300];
    v6->m_boxBound.m_vecMin.x = -v5;
    v6->m_boxBound.m_vecMin.y = -v5;
    v6->m_boxBound.m_vecMin.z = -v5;
    v6->m_boxBound.m_vecMax.x = v5;
    v6->m_boxBound.m_vecMax.y = v5;
    v6->m_boxBound.m_vecMax.z = v5;
  }
  v7 = (CCutsceneObject *)CObject::operator new(0x1A4u);
  CCutsceneObject::CCutsceneObject(v7);
  (*((void (__fastcall **)(CCutsceneObject *, int32))v7->_vptr$CPlaceable + 6))(v7, id);
  v8 = CCutsceneMgr::ms_numCutsceneObjs;
  CCutsceneMgr::ms_pCutsceneObjects[CCutsceneMgr::ms_numCutsceneObjs] = v7;
  CCutsceneMgr::ms_numCutsceneObjs = v8 + 1;
  CStreaming::IHaveUsedStreamingMemory();
  return v7;
}
// 464A08: using guessed type float pData[7];

//----- (00464AFC) --------------------------------------------------------
void __fastcall CCutsceneMgr::SetCutsceneAnim(const unsigned __int8 *pName, CObject *pObject)
{
  RwObject_0 *m_pRwObject; // r5
  CAnimBlendStaticAssociation *Animation; // r0
  CAnimBlendHierarchy *m_pAnimBlendHierarchy; // r0
  CAnimBlendAssociation *v6; // r4
  ListLink *pNext; // r6
  ListLink_0 *p_m_list; // r1
  ListLink *v9; // r0

  m_pRwObject = pObject->m_pRwObject;
  Animation = CAnimBlendAssocGroup::GetAnimation(&CCutsceneMgr::ms_cutsceneAssociations, pName);
  if ( Animation )
  {
    m_pAnimBlendHierarchy = Animation->m_pAnimBlendHierarchy;
    if ( m_pAnimBlendHierarchy->m_bIsCompressed )
      m_pAnimBlendHierarchy->m_bRunCompressed = 1;
    CStreaming::ImGonnaUseStreamingMemory();
    v6 = CAnimBlendAssocGroup::CopyAnimation(&CCutsceneMgr::ms_cutsceneAssociations, pName);
    CStreaming::IHaveUsedStreamingMemory();
    pNext = 0;
    CAnimBlendAssociation::SetCurrentTime(v6, 0.0);
    v6->m_bitsFlag = v6->m_bitsFlag & 0xFFBE | 0x40;
    p_m_list = &v6->m_list;
    v9 = *(ListLink **)(&m_pRwObject->type + ClumpOffset);
    if ( v9->pNext )
    {
      v9->pNext->pPrev = p_m_list;
      pNext = v9->pNext;
    }
    v6->m_list.pNext = pNext;
    v6->m_list.pPrev = v9;
    v9->pNext = p_m_list;
    if ( v6->m_pAnimBlendHierarchy->m_bRunCompressed )
      LOBYTE(v9[2].pNext->pNext) |= 0x40u;
  }
}

//----- (00464B90) --------------------------------------------------------
void __fastcall CCutsceneMgr::AttachObjectToBone(CObject *pObject, CObject *pParent, int32 boneId)
{
  RpHAnimHierarchy_0 *AnimHierarchyFromSkinClump; // r0

  AnimHierarchyFromSkinClump = GetAnimHierarchyFromSkinClump((RpClump_0 *)pParent->m_pRwObject);
  pObject[1]._vptr$CPlaceable = (int (**)(void))RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, boneId);
  LODWORD(pObject[1].m_transform.m_translate.x) = pParent;
}

//----- (00464BB4) --------------------------------------------------------
void __fastcall CCutsceneMgr::LoadCutsceneData_overlay(const unsigned __int8 *pName)
{
  CDirectory *v2; // r0

  CTimer::Suspend();
  CCutsceneMgr::ms_wasCutsceneSkipped = 0;
  CCutsceneMgr::ms_cutsceneProcessing = 1;
  CStreaming::RemoveCurrentZonesModels();
  v2 = CCutsceneMgr::ms_pCutsceneDir;
  CCutsceneMgr::ms_pCutsceneDir->m_number = 0;
  CDirectory::ReadDirFile(v2, "ANIM\\CUTS.IMG");
  CStreaming::RemoveUnusedModelsInLoadedList();
  CGame::DrasticTidyUpMemory(1);
  strcpy((char *)CCutsceneMgr::ms_cutsceneName, (const char *)pName);
  CCutsceneMgr::LoadCutsceneData_preload();
  sub_19F744();
}

//----- (00464C20) --------------------------------------------------------
void CCutsceneMgr::DeleteCutsceneData_overlay()
{
  int32 v0; // r1
  int32 v1; // r5
  CEntity **v2; // r4
  int32 v3; // r0
  int32 v4; // r4
  FxSystem_c **p_mp_fxSystem; // r6
  int v6; // r0
  bool v7; // zf
  int32 v8; // r1
  CObject *v9; // r0
  CPlayerPed *PlayerPed; // r0
  CEntity::CFlags m_nFlags; // kr00_8
  __int16 v12; // r4
  CPad *Pad; // r0
  bool v14; // r0
  CPad *v15; // r0
  int32 v16; // r5
  CVector v17; // [sp+4h] [bp-2Ch] BYREF

  if ( CCutsceneMgr::ms_cutsceneLoadStatus )
  {
    CTimer::Suspend();
    CPopulation::PedDensityMultiplier = CCutsceneMgr::m_fPrevPedDensity;
    CCarCtrl::CarDensityMultiplier = CCutsceneMgr::m_fPrevCarDensity;
    if ( CCutsceneMgr::m_PrevExtraColourOn )
      CTimeCycle::StartExtraColour(CCutsceneMgr::m_PrevExtraColour, 0);
    else
      CTimeCycle::StopExtraColour(0);
    v0 = CCutsceneMgr::ms_iNumHiddenEntities;
    if ( CCutsceneMgr::ms_iNumHiddenEntities >= 1 )
    {
      v1 = 0;
      v2 = CCutsceneMgr::ms_pHiddenEntities;
      do
      {
        if ( *v2 )
        {
          CEntity::CleanUpOldReference(*v2, v2);
          *(_DWORD *)&(*v2)->m_nFlags |= 0x80u;
          v0 = CCutsceneMgr::ms_iNumHiddenEntities;
        }
        ++v1;
        ++v2;
      }
      while ( v1 < v0 );
    }
    v3 = CCutsceneMgr::ms_iNumParticleEffects;
    CCutsceneMgr::ms_iNumHiddenEntities = 0;
    if ( CCutsceneMgr::ms_iNumParticleEffects >= 1 )
    {
      v4 = 0;
      p_mp_fxSystem = &CCutsceneMgr::ms_pParticleEffects[0].mp_fxSystem;
      do
      {
        if ( *p_mp_fxSystem )
        {
          FxManager_c::DestroyFxSystem(&g_fxMan, *p_mp_fxSystem);
          v3 = CCutsceneMgr::ms_iNumParticleEffects;
        }
        ++v4;
        *p_mp_fxSystem = 0;
        p_mp_fxSystem += 27;
      }
      while ( v4 < v3 );
    }
    CCutsceneMgr::ms_iNumParticleEffects = 0;
    CMessages::ClearMessages(0);
    CRubbish::SetVisibility(1);
    CCutsceneMgr::ms_useLodMultiplier = 0;
    v6 = CCutsceneMgr::ms_numCutsceneObjs - 1;
    v7 = CCutsceneMgr::ms_numCutsceneObjs == 0;
    CCutsceneMgr::ms_cutsceneProcessing = 0;
    CCutsceneMgr::ms_useCutsceneShadows = 1;
    --CCutsceneMgr::ms_numCutsceneObjs;
    if ( !v7 )
    {
      do
      {
        CWorld::Remove(CCutsceneMgr::ms_pCutsceneObjects[v6]);
        (*((void (__fastcall **)(CObject *))CCutsceneMgr::ms_pCutsceneObjects[CCutsceneMgr::ms_numCutsceneObjs]->_vptr$CPlaceable
         + 9))(CCutsceneMgr::ms_pCutsceneObjects[CCutsceneMgr::ms_numCutsceneObjs]);
        v8 = CCutsceneMgr::ms_numCutsceneObjs;
        v9 = CCutsceneMgr::ms_pCutsceneObjects[CCutsceneMgr::ms_numCutsceneObjs];
        if ( v9 )
        {
          (*((void (__fastcall **)(CObject *))v9->_vptr$CPlaceable + 1))(v9);
          v8 = CCutsceneMgr::ms_numCutsceneObjs;
        }
        v6 = v8 - 1;
        CCutsceneMgr::ms_pCutsceneObjects[v8] = 0;
        CCutsceneMgr::ms_numCutsceneObjs = v8 - 1;
      }
      while ( v8 );
    }
    CCutsceneMgr::ms_numCutsceneObjs = 0;
    if ( CCutsceneMgr::ms_animLoaded )
      CAnimManager::RemoveLastAnimFile();
    CCutsceneMgr::ms_animLoaded = 0;
    CAnimBlendAssocGroup::DestroyAssociations(&CCutsceneMgr::ms_cutsceneAssociations);
    CCutsceneMgr::ms_numUncompressedCutsceneAnims = 0;
    CCutsceneMgr::ms_aUncompressedCutsceneAnims[0][0] = 0;
    if ( bCameraAvailable )
    {
      CCamera::RestoreWithJumpCut(&TheCamera);
      CCamera::SetWideScreenOff(&TheCamera);
      CCamera::DeleteCutSceneCamDataMemory(&TheCamera);
    }
    CIplStore::ClearIplsNeededAtPosn();
    CCutsceneMgr::ms_running = 0;
    CCutsceneMgr::ms_cutsceneLoadStatus = 0;
    PlayerPed = FindPlayerPed(-1);
    m_nFlags = PlayerPed->m_nFlags;
    v12 = CWorld::PlayerInFocus;
    *(_DWORD *)&PlayerPed->m_nFlags = *(_DWORD *)&m_nFlags | 0x80;
    PlayerPed->m_nFlags.bdummy = m_nFlags.bdummy;
    Pad = CPad::GetPad(0);
    Pad->DisablePlayerControls &= ~0x80u;
    CPlayerInfo::MakePlayerSafe(&CWorld::Players[v12], 0, 10000.0);
    if ( strcasecmp((const char *)CCutsceneMgr::ms_cutsceneName, "finale") )
    {
      CAudioEngine::StopCutsceneTrack(&AudioEngine, 1u);
      CAudioEngine::EnableEffectsLoading(&AudioEngine);
      CAEPedSpeechAudioEntity::EnableAllPedSpeech();
    }
    CWorld::bProcessCutsceneOnly = 0;
    CStreaming::ms_disableStreaming = 0;
    if ( bCameraAvailable )
    {
      v14 = CCamera::GetScreenFadeStatus(&TheCamera) == 2;
      CGame::DrasticTidyUpMemory(v14);
    }
    v15 = CPad::GetPad(0);
    CPad::Clear(v15, 0, 0);
    if ( CCutsceneMgr::ms_numLoadObjectNames >= 1 )
    {
      v16 = 0;
      do
      {
        if ( !CScriptResourceManager::HasResourceBeenRequested(
                &CTheScripts::ScriptResourceManager,
                CCutsceneMgr::ms_iModelIndex[v16],
                2u) )
          CStreaming::SetMissionDoesntRequireModel(CCutsceneMgr::ms_iModelIndex[v16]);
        ++v16;
      }
      while ( v16 < CCutsceneMgr::ms_numLoadObjectNames );
    }
    CStreaming::SetMissionDoesntRequireModel(1);
    FindPlayerCoors(&v17, -1);
    CStreaming::StreamZoneModels(&v17);
    CTimer::Resume();
    CStreaming::ForceLayerToRead(1);
  }
}

//----- (00465008) --------------------------------------------------------
RpAtomic_0 *__fastcall CalculateBoundingSphereRadiusCB(RpAtomic_0 *pAtomic, void *data)
{
  RwInt32 flags; // r0
  float radius; // s16
  __int64 v6; // d16
  char *parent; // r0
  char **v8; // r5
  char *v9; // r5
  int v10; // t1
  float v11; // s0
  RpAtomic_0 *result; // r0
  float v13; // s0
  RwV3d_0 v14[3]; // [sp+0h] [bp-28h] BYREF

  flags = pAtomic->interpolator.flags;
  if ( (flags & 2) != 0 )
  {
    _rpAtomicResyncInterpolatedSphere(pAtomic);
    flags = pAtomic->interpolator.flags;
  }
  radius = pAtomic->boundingSphere.radius;
  if ( (flags & 2) != 0 )
    _rpAtomicResyncInterpolatedSphere(pAtomic);
  v6 = *(_QWORD *)&pAtomic->boundingSphere.center.x;
  v14[0].z = pAtomic->boundingSphere.center.z;
  *(_QWORD *)&v14[0].x = v6;
  parent = (char *)pAtomic->object.object.parent;
  v8 = (char **)(parent + 4);
  if ( *((_DWORD *)parent + 1) )
  {
    do
    {
      RwV3dTransformPoints(v14, v14, 1, (const RwMatrix *)(parent + 16));
      parent = *v8;
      v9 = *v8;
      v10 = *((_DWORD *)v9 + 1);
      v8 = (char **)(v9 + 4);
    }
    while ( v10 );
  }
  v11 = RwV3dLength(v14);
  result = pAtomic;
  v13 = radius + v11;
  if ( v13 > *(float *)data )
    *(float *)data = v13;
  return result;
}

//----- (00465098) --------------------------------------------------------
void __fastcall UpdateCutsceneObjectBoundingBox(RpClump_0 *pClump, int32 modelIndex)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d8
  int v4; // r4
  CColModel *v5; // r5
  float v6; // s2
  float v7; // s0
  CColModel *v8; // r0
  float pData[5]; // [sp+4h] [bp-14h] BYREF

  v4 = modelIndex - 300;
  v5 = &CTempColModels::ms_colModelCutObj[modelIndex - 300];
  pData[0] = v5->m_sphereBound.m_fRadius;
  v3.n64_f32[0] = pData[0];
  RpClumpForAllAtomics(pClump, CalculateBoundingSphereRadiusCB, pData);
  v2.n64_u32[0] = 20.0;
  v6 = vmax_f32(v3, v2).n64_f32[0];
  v7 = pData[0];
  if ( pData[0] > v6 )
  {
    pData[0] = v6;
    v7 = v6;
  }
  v5->m_sphereBound.m_fRadius = v7;
  v8 = &CTempColModels::ms_colModelCutObj[v4];
  v8->m_boxBound.m_vecMin.x = -v7;
  v8->m_boxBound.m_vecMin.y = -v7;
  v8->m_boxBound.m_vecMin.z = -v7;
  v8->m_boxBound.m_vecMax.x = v7;
  v8->m_boxBound.m_vecMax.y = v7;
  v8->m_boxBound.m_vecMax.z = v7;
}
// 4650D4: variable 'v3' is possibly undefined
// 4650D4: variable 'v2' is possibly undefined
// 465098: using guessed type float pData[5];

//----- (00465128) --------------------------------------------------------
CObject *__fastcall CCutsceneMgr::AddCutsceneHead(CObject *pPed, int32 headId)
{
  return 0;
}

//----- (0046512C) --------------------------------------------------------
void __fastcall CCutsceneMgr::SetCutsceneAnimToLoop(const unsigned __int8 *pName)
{
  CAnimBlendStaticAssociation *Animation; // r0

  Animation = CAnimBlendAssocGroup::GetAnimation(&CCutsceneMgr::ms_cutsceneAssociations, pName);
  Animation->m_bitsFlag |= 2u;
}

//----- (0046514E) --------------------------------------------------------
void __fastcall CCutsceneMgr::AttachObjectToFrame(CObject *pObject, CEntity *pParent, const unsigned __int8 *pName)
{
  *(_QWORD *)&pObject[1]._vptr$CPlaceable = (unsigned int)RpAnimBlendClumpFindFrame(
                                                            (RpClump_0 *)pParent->m_pRwObject,
                                                            pName)->_anon_1.pFrame;
}

//----- (00465166) --------------------------------------------------------
void __fastcall CCutsceneMgr::AttachObjectToParent(CObject *pObject, CEntity *pParent)
{
  pObject[1]._vptr$CPlaceable = (int (**)(void))pParent->m_pRwObject->parent;
  pObject[1].m_transform.m_translate.x = 0.0;
}

//----- (00465174) --------------------------------------------------------
void CCutsceneMgr::StartCutscene()
{
  CSimpleTransform *p_tx; // r0

  CCutsceneMgr::ms_cutscenePlayStatus = 1;
  if ( bCameraAvailable )
  {
    CCamera::SetCamCutSceneOffSet(&TheCamera, &CCutsceneMgr::ms_cutsceneOffset);
    CCamera::TakeControlWithSpline(&TheCamera, 2);
    CCamera::SetWideScreenOn(&TheCamera);
    CHud::SetHelpMessage(0, 0, 1, 0, 0, 0);
    p_tx = (CSimpleTransform *)&TheCamera.m_pMat->tx;
    if ( !TheCamera.m_pMat )
      p_tx = &TheCamera.m_transform;
    CPlantMgr::PreUpdateOnceForNewCameraPos(&p_tx->m_translate);
  }
}

//----- (004651EC) --------------------------------------------------------
void CCutsceneMgr::SetupCutsceneToStart()
{
  int32 v0; // r8
  CObject **v1; // r4
  CAnimBlendAssociation *FirstAssociation; // r0
  int v3; // r1
  uint16 *p_m_bitsFlag; // r0
  uint16 m_bitsFlag; // t1
  __int16 v6; // r1
  int v7; // r4
  RwReal v8; // r2
  RwReal v9; // r0
  RwReal *v10; // r1
  CAnimBlendHierarchy *m_pAnimBlendHierarchy; // r2
  _BOOL4 m_bIsCompressed; // r4
  uint8 *m_pKeyFrames; // r2
  float v14; // s2
  float v15; // s0
  float v16; // s4
  __int64 v17; // d16
  CObject *v18; // r0
  float y; // s8
  float z; // s10
  float v21; // s4
  float v22; // s12
  int v23; // r2
  float v24; // s6
  float *v25; // r1
  CObject *v26; // r1
  uint16 v27; // t1
  CObject **v28; // r4
  int v29; // r11
  CEntity *v30; // r0

  v0 = CCutsceneMgr::ms_numCutsceneObjs;
  CCutsceneMgr::ms_cutsceneOffset.z = CCutsceneMgr::ms_cutsceneOffset.z + 1.0;
  if ( CCutsceneMgr::ms_numCutsceneObjs )
  {
    do
    {
      v1 = &CCutsceneMgr::ms_pCutsceneObjects[v0];
      FirstAssociation = RpAnimBlendClumpGetFirstAssociation((RpClump_0 *)(*(v1 - 1))->m_pRwObject);
      v3 = (int)*(v1 - 1);
      if ( FirstAssociation )
      {
        if ( *(_DWORD *)(v3 + 388) )
        {
          m_bitsFlag = FirstAssociation->m_bitsFlag;
          p_m_bitsFlag = &FirstAssociation->m_bitsFlag;
          v6 = m_bitsFlag & 0xFFBF;
          *p_m_bitsFlag = m_bitsFlag & 0xFFBF;
        }
        else
        {
          m_pAnimBlendHierarchy = FirstAssociation->m_pAnimBlendHierarchy;
          m_bIsCompressed = m_pAnimBlendHierarchy->m_bIsCompressed;
          m_pKeyFrames = m_pAnimBlendHierarchy->m_pSequences->m_pKeyFrames;
          if ( m_bIsCompressed )
          {
            v14 = (float)*((__int16 *)m_pKeyFrames + 7) * 0.00097656;
            v15 = (float)*((__int16 *)m_pKeyFrames + 6) * 0.00097656;
            v16 = (float)*((__int16 *)m_pKeyFrames + 5) * 0.00097656;
          }
          else
          {
            v16 = *((float *)m_pKeyFrames + 5);
            v15 = *((float *)m_pKeyFrames + 6);
            v14 = *((float *)m_pKeyFrames + 7);
          }
          y = CCutsceneMgr::ms_cutsceneOffset.y;
          z = CCutsceneMgr::ms_cutsceneOffset.z;
          v21 = v16 + CCutsceneMgr::ms_cutsceneOffset.x;
          v22 = v15 + CCutsceneMgr::ms_cutsceneOffset.y;
          v23 = *(_DWORD *)(v3 + 20);
          v24 = v14 + CCutsceneMgr::ms_cutsceneOffset.z;
          if ( v23 )
          {
            *(float *)(v23 + 48) = v21;
            *(float *)(*(_DWORD *)(v3 + 20) + 52) = v22;
            v25 = (float *)(*(_DWORD *)(v3 + 20) + 56);
          }
          else
          {
            *(float *)(v3 + 4) = v21;
            *(float *)(v3 + 8) = v22;
            v25 = (float *)(v3 + 12);
            y = CCutsceneMgr::ms_cutsceneOffset.y;
            z = CCutsceneMgr::ms_cutsceneOffset.z;
          }
          *v25 = v24;
          v26 = CCutsceneMgr::ms_pCutsceneObjects[v0 - 1];
          v26[1].m_transform.m_translate.y = v21;
          v26[1].m_transform.m_translate.z = v15 + y;
          v26[1].m_transform.m_heading = v14 + z;
          v27 = FirstAssociation->m_bitsFlag;
          p_m_bitsFlag = &FirstAssociation->m_bitsFlag;
          v6 = v27;
        }
        *p_m_bitsFlag = v6 | 1;
      }
      else
      {
        v7 = *(_DWORD *)(v3 + 20);
        v8 = CCutsceneMgr::ms_cutsceneOffset.y;
        v9 = CCutsceneMgr::ms_cutsceneOffset.z;
        if ( v7 )
        {
          *(RwReal *)(v7 + 48) = CCutsceneMgr::ms_cutsceneOffset.x;
          *(RwReal *)(*(_DWORD *)(v3 + 20) + 52) = v8;
          v10 = (RwReal *)(*(_DWORD *)(v3 + 20) + 56);
        }
        else
        {
          *(_QWORD *)(v3 + 4) = *(_QWORD *)&CCutsceneMgr::ms_cutsceneOffset.x;
          v10 = (RwReal *)(v3 + 12);
        }
        *v10 = v9;
        v17 = *(_QWORD *)&CCutsceneMgr::ms_cutsceneOffset.x;
        v18 = CCutsceneMgr::ms_pCutsceneObjects[v0 - 1];
        v18[1].m_transform.m_heading = CCutsceneMgr::ms_cutsceneOffset.z;
        *(_QWORD *)&v18[1].m_transform.m_translate.y = v17;
      }
      v28 = &CCutsceneMgr::ms_pCutsceneObjects[v0];
      v29 = v0 - 1;
      CWorld::Add(*(v28 - 1));
      v30 = *(v28 - 1);
      if ( v30->m_pRwObject->type == 2 )
        CEntity::UpdateRpHAnim(v30);
      --v0;
    }
    while ( v29 );
  }
  CTimer::Update();
  CTimer::Update();
  CCutsceneMgr::ms_running = 1;
  CCutsceneMgr::ms_cutsceneTimer = 0.0;
}

//----- (00465404) --------------------------------------------------------
void CCutsceneMgr::Update_overlay()
{
  float32x2_t v0; // d9
  float32x2_t v1; // d10
  int32 v2; // r0
  int32 v3; // r0
  unsigned int v4; // s2
  int32 v5; // r5
  bool *p_m_bPlaying; // r4
  int v7; // r1
  FxSystem_c *v8; // r0
  int v9; // r1
  FxSystem_c *v10; // r0
  GxtChar *v11; // r0
  int32 v12; // r0
  int32 v13; // r6
  CObject *v14; // r1
  unsigned int v15; // r2
  RpClump_0 *m_pRwObject; // r0
  unsigned int v17; // r8
  CColModel *v18; // r10
  float v19; // s2
  float v20; // s0
  CColModel *v21; // r0
  CPlayerPed *PlayerPed; // r0
  CEntity::CFlags m_nFlags; // kr00_8
  __int16 v24; // r1
  unsigned int v25; // [sp+4h] [bp-44h]
  float pData[15]; // [sp+Ch] [bp-3Ch] BYREF

  CIplStore::AddIplsNeededAtPosn(&CCutsceneMgr::ms_cutsceneOffset);
  if ( CCutsceneMgr::ms_cutsceneLoadStatus != 2 )
  {
    if ( CCutsceneMgr::ms_cutsceneLoadStatus == 1 )
    {
      CTimer::Suspend();
      OS_TimeMS();
      CCutsceneMgr::LoadCutsceneData_loading();
      sub_19F744();
    }
    return;
  }
  v2 = CCutsceneMgr::ms_cutscenePlayStatus;
  if ( (unsigned int)(CCutsceneMgr::ms_cutscenePlayStatus - 2) >= 2 )
  {
    if ( CCutsceneMgr::ms_cutscenePlayStatus == 4 )
    {
      v3 = 0;
      goto LABEL_12;
    }
    if ( CCutsceneMgr::ms_cutscenePlayStatus != 1 )
      goto LABEL_13;
    CCutsceneMgr::SetupCutsceneToStart();
    CCutsceneMgr::HideRequestedObjects();
    if ( strcasecmp((const char *)CCutsceneMgr::ms_cutsceneName, "finale") )
    {
      CAudioEngine::DisableEffectsLoading(&AudioEngine);
      CAEPedSpeechAudioEntity::DisableAllPedSpeech();
      CAudioEngine::PlayPreloadedCutsceneTrack(&AudioEngine);
    }
    v2 = CCutsceneMgr::ms_cutscenePlayStatus;
  }
  v3 = v2 + 1;
LABEL_12:
  CCutsceneMgr::ms_cutscenePlayStatus = v3;
LABEL_13:
  if ( !CCutsceneMgr::ms_running )
    return;
  v4 = (unsigned int)(float)((float)(CCutsceneMgr::ms_cutsceneTimer + (float)(CTimer::ms_fTimeStepNonClipped / 50.0))
                           * 1000.0);
  CCutsceneMgr::ms_cutsceneTimer = CCutsceneMgr::ms_cutsceneTimer + (float)(CTimer::ms_fTimeStepNonClipped / 50.0);
  if ( CCutsceneMgr::ms_iNumParticleEffects >= 1 )
  {
    v5 = 0;
    p_m_bPlaying = &CCutsceneMgr::ms_pParticleEffects[0].m_bPlaying;
    while ( 1 )
    {
      if ( !*p_m_bPlaying )
        goto LABEL_21;
      v7 = *((_DWORD *)p_m_bPlaying - 16);
      if ( v7 != -1 )
      {
        v8 = (FxSystem_c *)*((_DWORD *)p_m_bPlaying - 18);
        if ( v8 )
        {
          if ( v7 + *((_DWORD *)p_m_bPlaying - 17) < v4 )
            break;
        }
      }
      v9 = 0;
LABEL_23:
      v10 = (FxSystem_c *)*((_DWORD *)p_m_bPlaying - 18);
      if ( v10 && v9 == 1 && *((_DWORD *)p_m_bPlaying - 17) <= v4 && !p_m_bPlaying[1] )
      {
        FxSystem_c::Play(v10);
        *p_m_bPlaying = 1;
      }
      ++v5;
      p_m_bPlaying += 108;
      if ( v5 >= CCutsceneMgr::ms_iNumParticleEffects )
        goto LABEL_29;
    }
    FxSystem_c::Stop(v8);
    *(_WORD *)p_m_bPlaying = 256;
LABEL_21:
    v9 = 1;
    goto LABEL_23;
  }
LABEL_29:
  if ( CCutsceneMgr::ms_currTextOutput < CCutsceneMgr::ms_numTextOutput
    && CCutsceneMgr::ms_iTextStartTime[CCutsceneMgr::ms_currTextOutput] < v4 )
  {
    v11 = CText::Get(&TheText, CCutsceneMgr::ms_cTextOutput[CCutsceneMgr::ms_currTextOutput]);
    CMessages::AddMessageJumpQ(
      CCutsceneMgr::ms_cTextOutput[CCutsceneMgr::ms_currTextOutput],
      v11,
      CCutsceneMgr::ms_iTextDuration[CCutsceneMgr::ms_currTextOutput],
      1u,
      1);
    ++CCutsceneMgr::ms_currTextOutput;
  }
  v25 = v4;
  v12 = CCutsceneMgr::ms_numCutsceneObjs;
  if ( CCutsceneMgr::ms_numCutsceneObjs >= 1 )
  {
    v0.n64_u32[0] = 20.0;
    v13 = 0;
    do
    {
      v14 = CCutsceneMgr::ms_pCutsceneObjects[v13];
      v15 = v14->m_nModelIndex - 300;
      if ( v15 <= 0x13 )
      {
        m_pRwObject = (RpClump_0 *)v14->m_pRwObject;
        v17 = v15;
        v18 = &CTempColModels::ms_colModelCutObj[v15];
        pData[0] = v18->m_sphereBound.m_fRadius;
        v1.n64_f32[0] = pData[0];
        RpClumpForAllAtomics(m_pRwObject, CalculateBoundingSphereRadiusCB, pData);
        v19 = vmax_f32(v1, v0).n64_f32[0];
        v20 = pData[0];
        if ( pData[0] > v19 )
        {
          pData[0] = v19;
          v20 = v19;
        }
        v18->m_sphereBound.m_fRadius = v20;
        v21 = &CTempColModels::ms_colModelCutObj[v17];
        v21->m_boxBound.m_vecMin.x = -v20;
        v21->m_boxBound.m_vecMin.y = -v20;
        v21->m_boxBound.m_vecMin.z = -v20;
        v21->m_boxBound.m_vecMax.x = v20;
        v21->m_boxBound.m_vecMax.y = v20;
        v21->m_boxBound.m_vecMax.z = v20;
        v12 = CCutsceneMgr::ms_numCutsceneObjs;
      }
      ++v13;
    }
    while ( v13 < v12 );
  }
  if ( bCameraAvailable
    && strcasecmp((const char *)CCutsceneMgr::ms_cutsceneName, "finale")
    && TheCamera.Cams[TheCamera.ActiveCam].Mode == 17
    && CCutsceneMgr::ms_cutsceneLoadStatus == 2 )
  {
    if ( v25 + 1000 > CCamera::GetCutSceneFinishTime(&TheCamera) && !g_bCutSceneFinishing )
    {
      g_bCutSceneFinishing = 1;
      CCamera::Fade(&TheCamera, 1.0, 0);
    }
    if ( CCutsceneMgr::IsCutsceneSkipButtonBeingPressed() )
    {
      CCutsceneMgr::ms_wasCutsceneSkipped = 1;
      CHud::m_BigMessage[1][0] = 0;
      if ( bCameraAvailable )
      {
        CCutsceneMgr::ms_cutsceneTimer = (float)CCamera::GetCutSceneFinishTime(&TheCamera) / 1000.0;
        CCamera::FinishCutscene(&TheCamera);
      }
      PlayerPed = FindPlayerPed(-1);
      m_nFlags = PlayerPed->m_nFlags;
      v24 = CWorld::PlayerInFocus;
      *(_DWORD *)&PlayerPed->m_nFlags = *(_DWORD *)&m_nFlags | 0x80;
      PlayerPed->m_nFlags.bdummy = m_nFlags.bdummy;
      CPlayerInfo::MakePlayerSafe(&CWorld::Players[v24], 0, 10000.0);
    }
  }
}
// 46562C: variable 'v1' is possibly undefined
// 46562C: variable 'v0' is possibly undefined
// 9AE230: using guessed type char g_bCutSceneFinishing;
// 465404: using guessed type float pData[15];

//----- (0046583C) --------------------------------------------------------
uint32 CCutsceneMgr::GetCutsceneTimeInMilleseconds()
{
  return (unsigned int)(float)(CCutsceneMgr::ms_cutsceneTimer * 1000.0);
}

//----- (00465860) --------------------------------------------------------
void CCutsceneMgr::SkipCutscene()
{
  CPlayerPed *PlayerPed; // r0
  CEntity::CFlags m_nFlags; // kr00_8
  __int16 v2; // r1

  CCutsceneMgr::ms_wasCutsceneSkipped = 1;
  CHud::m_BigMessage[1][0] = 0;
  if ( bCameraAvailable )
  {
    CCutsceneMgr::ms_cutsceneTimer = (float)CCamera::GetCutSceneFinishTime(&TheCamera) / 1000.0;
    CCamera::FinishCutscene(&TheCamera);
  }
  PlayerPed = FindPlayerPed(-1);
  m_nFlags = PlayerPed->m_nFlags;
  v2 = CWorld::PlayerInFocus;
  *(_DWORD *)&PlayerPed->m_nFlags = *(_DWORD *)&m_nFlags | 0x80;
  PlayerPed->m_nFlags.bdummy = m_nFlags.bdummy;
  sub_1917F8(&CWorld::Players[v2], 0, 10000.0);
}

//----- (00465914) --------------------------------------------------------
void CCutsceneMgr::FinishCutscene()
{
  CPlayerPed *PlayerPed; // r0
  CEntity::CFlags m_nFlags; // kr00_8
  __int16 v2; // r1

  if ( bCameraAvailable )
  {
    CCutsceneMgr::ms_cutsceneTimer = (float)CCamera::GetCutSceneFinishTime(&TheCamera) / 1000.0;
    CCamera::FinishCutscene(&TheCamera);
  }
  PlayerPed = FindPlayerPed(-1);
  m_nFlags = PlayerPed->m_nFlags;
  v2 = CWorld::PlayerInFocus;
  *(_DWORD *)&PlayerPed->m_nFlags = *(_DWORD *)&m_nFlags | 0x80;
  PlayerPed->m_nFlags.bdummy = m_nFlags.bdummy;
  sub_1917F8(&CWorld::Players[v2], 0, 10000.0);
}

//----- (004659A8) --------------------------------------------------------
bool CCutsceneMgr::HasCutsceneFinished()
{
  return !bCameraAvailable || CCamera::GetPositionAlongSpline(&TheCamera) == 1.0;
}

//----- (004659E4) --------------------------------------------------------
void __fastcall CCutsceneObject::CCutsceneObject(CCutsceneObject *this)
{
  CEntity::CEntityInfo m_info; // r2
  int m_nFlags; // r3
  int v4; // r0

  CObject::CObject(this);
  this->m_vecAddPos.y = 0.0;
  this->m_vecAddPos.z = 0.0;
  *(_QWORD *)&this->m_vecInitialPos.x = 0LL;
  *(_QWORD *)&this->m_vecInitialPos.z = 0LL;
  this->_anon_0.m_boneIndex = 0;
  this->m_pObj = 0;
  m_info = this->m_info;
  this->ObjectCreatedBy = 4;
  m_nFlags = (int)this->m_nFlags;
  this->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&m_info & 7 | 0x10);
  *(_DWORD *)&this->m_nFlags = m_nFlags & 0xEFFFFBFE | 0x10000400;
  this->_vptr$CPlaceable = (int (**)(void))&off_668448;
  CObject::SetIsStatic(this, 0);
  v4 = (int)this->m_nFlags;
  this->m_lightingFromCollision = 0.5;
  *(_DWORD *)&this->m_nFlags = v4 & 0xF7FFFFFF;
}
// 668448: using guessed type void *;

//----- (00465A58) --------------------------------------------------------
void __fastcall CCutsceneObject::~CCutsceneObject(CCutsceneObject *this)
{
  this->_vptr$CPlaceable = (int (**)(void))&off_668448;
  j_CObject::~CObject(this);
}
// 668448: using guessed type void *off_668448;

//----- (00465A6C) --------------------------------------------------------
void __fastcall CCutsceneObject::~CCutsceneObject(CCutsceneObject *this)
{
  void *v1; // r0

  this->_vptr$CPlaceable = (int (**)(void))&off_668448;
  CObject::~CObject(this);
  sub_18BC44(v1);
}
// 465A82: variable 'v1' is possibly undefined
// 668448: using guessed type void *off_668448;

//----- (00465A8C) --------------------------------------------------------
void __fastcall CCutsceneObject::SetModelIndex(CCutsceneObject *this, uint32 index)
{
  RpClump_0 *m_pRwObject; // r0
  RwInt32 v5; // r0
  _BYTE *v6; // r0
  RpClump_0 *v7; // r5
  uint32 UppercaseKey; // r0
  CBaseModelInfo **v9; // r4
  CBaseModelInfo *v10; // r1
  uint32 m_hashKey; // r1
  bool v12; // zf
  bool v13; // zf

  CEntity::SetModelIndex(this, index);
  m_pRwObject = (RpClump_0 *)this->m_pRwObject;
  if ( m_pRwObject->object.type == 2 )
  {
    RpAnimBlendClumpInit(m_pRwObject);
    v5 = ClumpOffset;
    *(_DWORD *)(*(_DWORD *)(&this->m_pRwObject->type + ClumpOffset) + 12) = &this->m_vecMoveSpeed;
    v6 = *(_BYTE **)(*(_DWORD *)(&this->m_pRwObject->type + v5) + 16);
    *v6 |= 0x10u;
    v7 = (RpClump_0 *)this->m_pRwObject;
    if ( FixCutsceneVehiclePipe(int,RpClump *)::bWantedCsVehiclesHashTabInitialized == 1 )
    {
      UppercaseKey = dword_9AE24C;
    }
    else
    {
      FixCutsceneVehiclePipe(int,RpClump *)::bWantedCsVehiclesHashTabInitialized = 1;
      FixCutsceneVehiclePipe(int,RpClump *)::WantedCsVehiclesHashTab = CKeyGen::GetUppercaseKey("cscopcarla92");
      dword_9AE23C = CKeyGen::GetUppercaseKey("cscopcarsf");
      dword_9AE240 = CKeyGen::GetUppercaseKey("csbravura");
      dword_9AE244 = CKeyGen::GetUppercaseKey("CsFireLa");
      dword_9AE248 = CKeyGen::GetUppercaseKey("csmothership");
      UppercaseKey = CKeyGen::GetUppercaseKey("CsVoodoo");
      dword_9AE24C = UppercaseKey;
    }
    v10 = CModelInfo::ms_modelInfoPtrs[index];
    v9 = &CModelInfo::ms_modelInfoPtrs[index];
    m_hashKey = v10->m_hashKey;
    if ( m_hashKey == FixCutsceneVehiclePipe(int,RpClump *)::WantedCsVehiclesHashTab )
      goto LABEL_14;
    v12 = m_hashKey == dword_9AE23C;
    if ( m_hashKey != dword_9AE23C )
      v12 = m_hashKey == dword_9AE240;
    if ( v12 )
      goto LABEL_14;
    v13 = m_hashKey == dword_9AE244;
    if ( m_hashKey != dword_9AE244 )
      v13 = m_hashKey == dword_9AE248;
    if ( v13 || m_hashKey == UppercaseKey )
LABEL_14:
      RpClumpForAllAtomics(v7, ForceVehiclePipeOnAtomicCB, 0);
  }
  else
  {
    v9 = &CModelInfo::ms_modelInfoPtrs[index];
  }
  (*v9)->m_alpha = -1;
}
// 9AE234: using guessed type char FixCutsceneVehiclePipe(int,RpClump *)::bWantedCsVehiclesHashTabInitialized;
// 9AE238: using guessed type int FixCutsceneVehiclePipe(int,RpClump *)::WantedCsVehiclesHashTab;
// 9AE23C: using guessed type int dword_9AE23C;
// 9AE240: using guessed type int dword_9AE240;
// 9AE244: using guessed type int dword_9AE244;
// 9AE248: using guessed type int dword_9AE248;
// 9AE24C: using guessed type int dword_9AE24C;

//----- (00465BE8) --------------------------------------------------------
void __fastcall CCutsceneObject::ProcessControl(CCutsceneObject *this)
{
  int32 m_boneIndex; // r0
  bool v3; // zf
  int m_nFlags; // r1
  uint32 bdummy; // r2
  RwFrame_0 *m_pFrame; // r0
  RpHAnimHierarchy_0 *AnimHierarchyFromClump; // r0
  RwMatrix *MatrixArray; // r0
  float v9; // s0
  float v10; // s2
  __int16 m_nPhysicalFlags; // r0
  float v12; // s4
  float v13; // s6
  float v14; // s2
  float v15; // s4
  float v16; // s6
  float v17; // s0
  float y; // s10
  CMatrix *m_pMat; // r0
  float z; // s12
  RwReal v21; // s2
  RwReal v22; // s4
  RwReal v23; // s0
  float v24; // s6
  RwMatrix *LTM; // r0
  CMatrix v26; // [sp+0h] [bp-50h] BYREF

  m_boneIndex = this->_anon_0.m_boneIndex;
  v3 = m_boneIndex == 0;
  if ( m_boneIndex )
    v3 = this->m_pObj == 0;
  if ( v3 || (m_nFlags = (int)this->m_nFlags, (m_nFlags & 0x40) != 0) )
  {
    CPhysical::ProcessControl(this);
    m_pFrame = this->_anon_0.m_pFrame;
    if ( m_pFrame )
    {
      if ( this->m_pObj )
      {
        CEntity::UpdateRpHAnim(this->m_pObj);
        AnimHierarchyFromClump = GetAnimHierarchyFromClump((RpClump_0 *)this->m_pObj->m_pRwObject);
        MatrixArray = RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromClump);
        CMatrix::CMatrix(&v26, &MatrixArray[this->_anon_0.m_boneIndex], 0);
        CMatrix::operator=(this->m_pMat, &v26);
        CMatrix::~CMatrix(&v26);
        *(_DWORD *)&this->m_nFlags &= ~0x40u;
      }
      else
      {
        LTM = RwFrameGetLTM(m_pFrame);
        CMatrix::CMatrix(&v26, LTM, 0);
        CMatrix::operator=(this->m_pMat, &v26);
        CMatrix::~CMatrix(&v26);
      }
    }
    else
    {
      v9 = CTimer::ms_fTimeStep;
      v10 = 1.0 / CTimer::ms_fTimeStep;
      if ( CTimer::ms_fTimeStep < 0.01 )
        v10 = 100.0;
      m_nPhysicalFlags = (__int16)this->m_nPhysicalFlags;
      v12 = this->m_vecMoveSpeed.x * v10;
      v13 = v10 * this->m_vecMoveSpeed.y;
      v14 = v10 * this->m_vecMoveSpeed.z;
      this->m_vecMoveSpeed.x = v12;
      this->m_vecMoveSpeed.y = v13;
      this->m_vecMoveSpeed.z = v14;
      if ( (m_nPhysicalFlags & 0x2020) != 0 )
      {
        this->m_vecMoveSpeed.x = 0.0;
        this->m_vecMoveSpeed.y = 0.0;
        this->m_vecMoveSpeed.z = 0.0;
      }
      else
      {
        v15 = v9 * v12;
        v16 = v9 * v13;
        v17 = v9 * v14;
        y = this->m_vecInitialPos.y;
        m_pMat = this->m_pMat;
        z = this->m_vecInitialPos.z;
        v21 = v15 + this->m_vecAddPos.x;
        v22 = v16 + this->m_vecAddPos.y;
        v23 = v17 + this->m_vecAddPos.z;
        v24 = this->m_vecInitialPos.x + v21;
        this->m_vecAddPos.x = v21;
        this->m_vecAddPos.y = v22;
        this->m_vecAddPos.z = v23;
        m_pMat->tx = v24;
        this->m_pMat->ty = y + v22;
        this->m_pMat->tz = v23 + z;
      }
    }
  }
  else
  {
    bdummy = this->m_nFlags.bdummy;
    *(_DWORD *)&this->m_nFlags = m_nFlags | 0x40;
    this->m_nFlags.bdummy = bdummy;
  }
}

//----- (00465D64) --------------------------------------------------------
void __fastcall CCutsceneObject::PreRender(CCutsceneObject *this)
{
  RwFrame_0 *m_pFrame; // r0
  CCutsceneObject *m_pObj; // r1
  RpHAnimHierarchy_0 *AnimHierarchyFromClump; // r0
  RwMatrix *LTM; // r1
  RpClump_0 **p_m_pRwObject; // r9
  RpClump_0 *m_pRwObject; // r5
  RpAtomic_0 *FirstAtomic; // r0
  RpMorphTarget_0 *morphTarget; // r0
  int v10; // r1
  __int64 v11; // d16
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  __int64 v14; // d16
  float v15; // s2
  CEntity *refEntityPtr; // [sp+1Ch] [bp-7Ch] BYREF
  CVector vecStart; // [sp+20h] [bp-78h] BYREF
  CMatrix v18; // [sp+30h] [bp-68h] BYREF

  m_pFrame = this->_anon_0.m_pFrame;
  if ( m_pFrame )
  {
    m_pObj = this->m_pObj;
    if ( m_pObj )
    {
      AnimHierarchyFromClump = GetAnimHierarchyFromClump((RpClump_0 *)m_pObj->m_pRwObject);
      LTM = &RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromClump)[this->_anon_0.m_boneIndex];
    }
    else
    {
      LTM = RwFrameGetLTM(m_pFrame);
    }
    CMatrix::CMatrix(&v18, LTM, 0);
    CMatrix::operator=(this->m_pMat, &v18);
    CMatrix::~CMatrix(&v18);
    p_m_pRwObject = (RpClump_0 **)&this->m_pRwObject;
    m_pRwObject = (RpClump_0 *)this->m_pRwObject;
    if ( m_pRwObject->object.type == 2 )
    {
      FirstAtomic = GetFirstAtomic((RpClump_0 *)this->m_pRwObject);
      if ( FirstAtomic )
      {
        if ( j_RpSkinGeometryGetSkin(FirstAtomic->geometry) )
        {
          morphTarget = GetFirstAtomic(m_pRwObject)->geometry->morphTarget;
          v10 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(&m_pRwObject->object.type + ClumpOffset) + 16) + 16);
          v11 = *(_QWORD *)(v10 + 16);
          morphTarget->boundingSphere.center.z = *(RwReal *)(v10 + 24);
          *(_QWORD *)&morphTarget->boundingSphere.center.x = v11;
        }
      }
    }
  }
  else
  {
    p_m_pRwObject = (RpClump_0 **)&this->m_pRwObject;
  }
  if ( (*p_m_pRwObject)->object.type == 2 )
    CEntity::UpdateRpHAnim(this);
  CRealTimeShadowManager::DoShadowThisFrame(&g_realTimeShadowMan, this);
  if ( !this->m_pRealTimeShadow )
    CShadows::StoreShadowForPedObject(
      this,
      CTimeCycle::m_fShadowDisplacementX[CTimeCycle::m_CurrentStoredValue],
      CTimeCycle::m_fShadowDisplacementY[CTimeCycle::m_CurrentStoredValue],
      CTimeCycle::m_fShadowFrontX[CTimeCycle::m_CurrentStoredValue],
      CTimeCycle::m_fShadowFrontY[CTimeCycle::m_CurrentStoredValue],
      CTimeCycle::m_fShadowSideX[CTimeCycle::m_CurrentStoredValue],
      CTimeCycle::m_fShadowSideY[CTimeCycle::m_CurrentStoredValue]);
  if ( this->m_nModelIndex == 1 )
  {
    CPed::ShoulderBoneRotation(*p_m_pRwObject);
    *(_DWORD *)&this->m_nFlags |= 0x800000u;
  }
  m_pMat = this->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &this->m_transform;
  v14 = *(_QWORD *)&p_tx->m_translate.x;
  vecStart.z = p_tx->m_translate.z;
  *(_QWORD *)&vecStart.x = v14;
  v15 = (float)(vecStart.z + 0.5) + -5.0;
  vecStart.z = vecStart.z + 0.5;
  if ( CWorld::ProcessVerticalLine(&vecStart, v15, (CColPoint *)&v18, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0) )
    this->m_lightingFromCollision = (float)(this->m_lightingFromCollision
                                          * (float)(1.0 - (float)(CTimer::ms_fTimeStep * 0.1)))
                                  + (float)((float)(CTimer::ms_fTimeStep * 0.1)
                                          * (float)((float)(CCustomBuildingDNPipeline::m_fDNBalanceParam
                                                          * (float)((float)((float)(BYTE1(v18.yz) >> 4) * 0.5) / 15.0))
                                                  + (float)((float)(1.0 - CCustomBuildingDNPipeline::m_fDNBalanceParam)
                                                          * (float)((float)((float)(BYTE1(v18.yz) & 0xF) * 0.5) / 15.0))));
}

//----- (00465FA4) --------------------------------------------------------
RpAtomic_0 *__fastcall ForceVehiclePipeOnAtomicCB(RpAtomic_0 *pAtomic, void *data)
{
  CCarFXRenderer::CustomCarPipeAtomicSetup(pAtomic);
  return pAtomic;
}

//----- (00465FC0) --------------------------------------------------------
void CColAccel::startCache()
{
  IplDef *v0; // r0
  int i; // r1
  _QWORD *p_left; // r2
  CColDefAccelItem *v3; // r0
  int j; // r1
  _QWORD *v5; // r2
  void *v6; // r4
  int32 v7; // r6
  __int64 v8; // r0
  CBoundingBox *v9; // r0
  CColAccelItem *v10; // r5
  int v11; // r6
  int v12; // r0
  int v13; // r2
  int32 v14; // r6
  __int64 v15; // r0
  CBoundingBox *v16; // r0
  CColAccelItem *v17; // r5
  int v18; // r6
  int v19; // r0
  unsigned int v20; // r0
  int v21; // r2
  int v22; // r0
  int v23; // r6
  bool v24; // zf
  unsigned int v25; // r0

  CColAccel::m_iCachingColSize = CPools::ms_pColModelPool->m_nSize;
  CColAccel::m_iSectionSize = (int32 *)operator new[](0x100u);
  v0 = (IplDef *)operator new[](0x3400u);
  for ( i = 0; i != 256; ++i )
  {
    p_left = (_QWORD *)&v0[i].bb.left;
    *p_left = 0xC974240049742400LL;
    p_left[1] = 0x49742400C9742400LL;
  }
  CColAccel::m_iplDefs = v0;
  v3 = (CColDefAccelItem *)operator new[](0x1800u);
  for ( j = 0; j != 256; ++j )
  {
    v5 = (_QWORD *)&v3[j].bb.left;
    *v5 = 0xC974240049742400LL;
    v5[1] = 0x49742400C9742400LL;
  }
  CColAccel::m_colBounds = v3;
  v6 = (void *)CFileMgr::OpenFile(CColAccel::mp_cCacheName, (const unsigned __int8 *)&dword_466248);
  if ( v6 && bDontBuildPaths )
  {
    OS_FileRead(v6, &CColAccel::m_iNumColItems, 4);
    v7 = CColAccel::m_iNumColItems;
    v8 = 48LL * (unsigned int)CColAccel::m_iNumColItems;
    if ( !is_mul_ok(0x30u, CColAccel::m_iNumColItems) )
      HIDWORD(v8) = 1;
    if ( HIDWORD(v8) )
      LODWORD(v8) = -1;
    v9 = (CBoundingBox *)operator new[](v8);
    v10 = (CColAccelItem *)v9;
    if ( v7 )
    {
      v11 = 48 * v7;
      do
      {
        CBoundingBox::CBoundingBox(v9);
        v11 -= 48;
        v9 = (CBoundingBox *)(v12 + 48);
      }
      while ( v11 );
      v13 = 48 * CColAccel::m_iNumColItems;
    }
    else
    {
      v13 = 0;
    }
    CColAccel::mp_caccColItems = v10;
    OS_FileRead(v6, v10, v13);
    OS_FileRead(v6, &CColAccel::m_iNumSections, 4);
    OS_FileRead(v6, CColAccel::m_iSectionSize, 4 * CColAccel::m_iNumSections);
    OS_FileRead(v6, CColAccel::m_iplDefs, 13312);
    OS_FileRead(v6, &CColAccel::m_iNumColBounds, 4);
    OS_FileRead(v6, CColAccel::m_colBounds, 24 * CColAccel::m_iNumColBounds);
    OS_FileRead(v6, &CColAccel::m_iNumIPLItems, 4);
    v22 = (20 * (unsigned __int64)(unsigned int)CColAccel::m_iNumIPLItems) >> 32;
    v23 = 20 * CColAccel::m_iNumIPLItems;
    if ( !is_mul_ok(0x14u, CColAccel::m_iNumIPLItems) )
      v22 = 1;
    v24 = v22 == 0;
    v25 = 20 * CColAccel::m_iNumIPLItems;
    if ( !v24 )
      v25 = -1;
    CColAccel::mp_caccIPLItems = (CIplAccelItem *)operator new[](v25);
    OS_FileRead(v6, CColAccel::mp_caccIPLItems, v23);
    CColAccel::m_iNumSections = 0;
    CColAccel::m_iNumIPLItems = 0;
    CColAccel::m_iNumColBounds = 0;
    CFileMgr::CloseFile((u_native)v6);
    CColAccel::m_iCacheState = STATE_LOADING;
  }
  else
  {
    v14 = CColAccel::m_iCachingColSize;
    v15 = 48LL * (unsigned int)CColAccel::m_iCachingColSize;
    if ( !is_mul_ok(0x30u, CColAccel::m_iCachingColSize) )
      HIDWORD(v15) = 1;
    if ( HIDWORD(v15) )
      LODWORD(v15) = -1;
    v16 = (CBoundingBox *)operator new[](v15);
    v17 = (CColAccelItem *)v16;
    if ( v14 )
    {
      v18 = 48 * v14;
      do
      {
        CBoundingBox::CBoundingBox(v16);
        v18 -= 48;
        v16 = (CBoundingBox *)(v19 + 48);
      }
      while ( v18 );
    }
    CColAccel::mp_caccColItems = v17;
    v21 = (20 * (unsigned __int64)(unsigned int)CColAccel::m_iCachingIPLSize) >> 32;
    v20 = 20 * CColAccel::m_iCachingIPLSize;
    if ( !is_mul_ok(0x14u, CColAccel::m_iCachingIPLSize) )
      v21 = 1;
    if ( v21 )
      v20 = -1;
    CColAccel::mp_caccIPLItems = (CIplAccelItem *)operator new[](v20);
    CColAccel::m_iNumIPLItems = 0;
    CColAccel::m_iCacheState = STATE_SAVING;
    if ( v6 )
      sub_19B258((u_native)v6);
  }
}
// 466094: variable 'v12' is possibly undefined
// 4660DC: variable 'v19' is possibly undefined
// 466248: using guessed type int dword_466248;

//----- (00466294) --------------------------------------------------------
bool CColAccel::isCacheLoading()
{
  return CColAccel::m_iCacheState == STATE_LOADING;
}

//----- (004662AC) --------------------------------------------------------
void CColAccel::endCache()
{
  u_native v0; // r4

  if ( CColAccel::m_iCacheState == STATE_SAVING )
  {
    v0 = CFileMgr::OpenFileForWriting(CColAccel::mp_cCacheName);
    CFileMgr::Write(v0, (unsigned __int8 *)&CColAccel::m_iNumColItems, 4);
    CFileMgr::Write(v0, (unsigned __int8 *)CColAccel::mp_caccColItems, 48 * CColAccel::m_iNumColItems);
    CFileMgr::Write(v0, (unsigned __int8 *)&CColAccel::m_iNumSections, 4);
    CFileMgr::Write(v0, (unsigned __int8 *)CColAccel::m_iSectionSize, 4 * CColAccel::m_iNumSections);
    CFileMgr::Write(v0, (unsigned __int8 *)CColAccel::m_iplDefs, 13312);
    CFileMgr::Write(v0, (unsigned __int8 *)&CColAccel::m_iNumColBounds, 4);
    CFileMgr::Write(v0, (unsigned __int8 *)CColAccel::m_colBounds, 24 * CColAccel::m_iNumColBounds);
    CFileMgr::Write(v0, (unsigned __int8 *)&CColAccel::m_iNumIPLItems, 4);
    CFileMgr::Write(v0, (unsigned __int8 *)CColAccel::mp_caccIPLItems, 20 * CColAccel::m_iNumIPLItems);
    CFileMgr::CloseFile(v0);
  }
  if ( CColAccel::mp_caccIPLItems )
  {
    operator delete[](CColAccel::mp_caccIPLItems);
    CColAccel::mp_caccIPLItems = 0;
  }
  if ( CColAccel::mp_caccColItems )
  {
    operator delete[](CColAccel::mp_caccColItems);
    CColAccel::mp_caccColItems = 0;
  }
  if ( CColAccel::m_iSectionSize )
    operator delete[](CColAccel::m_iSectionSize);
  CColAccel::m_iSectionSize = 0;
  if ( CColAccel::m_iplDefs )
    operator delete[](CColAccel::m_iplDefs);
  CColAccel::m_iplDefs = 0;
  if ( CColAccel::m_colBounds )
    operator delete[](CColAccel::m_colBounds);
  CColAccel::m_iCacheState = STATE_NONE;
  CColAccel::m_colBounds = 0;
}

//----- (00466454) --------------------------------------------------------
void __fastcall CColAccel::addCacheCol(int32 iModelIndex, const CColModel *r_colModel)
{
  int32 v2; // lr
  CColAccelItem *v3; // r2
  __int64 v4; // d16
  __int64 v5; // d17
  __int64 v6; // d20
  __int64 v7; // d21
  __int16 m_level; // r0

  if ( CColAccel::m_iCacheState == STATE_SAVING )
  {
    v2 = CColAccel::m_iNumColItems;
    v3 = &CColAccel::mp_caccColItems[CColAccel::m_iNumColItems];
    v3->m_iModelIndex = iModelIndex;
    v4 = *(_QWORD *)&r_colModel->m_boxBound.m_vecMin.x;
    v5 = *(_QWORD *)&r_colModel->m_boxBound.m_vecMin.z;
    v6 = *(_QWORD *)&r_colModel->m_boxBound.m_vecMax.y;
    v7 = *(_QWORD *)&r_colModel->m_sphereBound.m_vecCentre.x;
    *(_QWORD *)&v3->m_bounds.m_sphereBound.m_vecCentre.z = *(_QWORD *)&r_colModel->m_sphereBound.m_vecCentre.z;
    *(_QWORD *)&v3->m_bounds.m_boxBound.m_vecMin.x = v4;
    *(_QWORD *)&v3->m_bounds.m_boxBound.m_vecMin.z = v5;
    *(_QWORD *)&v3->m_bounds.m_boxBound.m_vecMax.y = v6;
    *(_QWORD *)&v3->m_bounds.m_sphereBound.m_vecCentre.x = v7;
    m_level = r_colModel->m_level;
    *((_BYTE *)v3 + 44) = m_level;
    *((_WORD *)v3 + 22) = m_level | ((*((_BYTE *)r_colModel + 41) & 1) << 8);
    CColAccel::m_iNumColItems = v2 + 1;
  }
}

//----- (004664D0) --------------------------------------------------------
void CColAccel::cacheLoadCol()
{
  int v0; // r6
  int32 v1; // r4
  CBaseModelInfo *v2; // r11
  CColModel *v3; // r5
  CColAccelItem *v4; // r0
  __int64 v5; // d16
  __int64 v6; // d17
  __int64 v7; // d20
  __int64 v8; // d21
  char v9; // r2

  if ( CColAccel::m_iCacheState == STATE_LOADING && CColAccel::m_iNumColItems >= 1 )
  {
    v0 = 0;
    v1 = 0;
    do
    {
      v2 = CModelInfo::ms_modelInfoPtrs[CColAccel::mp_caccColItems[v0].m_iModelIndex];
      v3 = (CColModel *)CColModel::operator new(0x30u);
      CColModel::CColModel(v3);
      v4 = &CColAccel::mp_caccColItems[v0];
      v5 = *(_QWORD *)&CColAccel::mp_caccColItems[v0].m_bounds.m_boxBound.m_vecMin.x;
      v6 = *(_QWORD *)&CColAccel::mp_caccColItems[v0].m_bounds.m_boxBound.m_vecMin.z;
      v7 = *(_QWORD *)&CColAccel::mp_caccColItems[v0].m_bounds.m_boxBound.m_vecMax.y;
      v8 = *(_QWORD *)&CColAccel::mp_caccColItems[v0].m_bounds.m_sphereBound.m_vecCentre.x;
      *(_QWORD *)&v3->m_sphereBound.m_vecCentre.z = *(_QWORD *)&CColAccel::mp_caccColItems[v0].m_bounds.m_sphereBound.m_vecCentre.z;
      *(_QWORD *)&v3->m_boxBound.m_vecMin.x = v5;
      *(_QWORD *)&v3->m_boxBound.m_vecMin.z = v6;
      *(_QWORD *)&v3->m_boxBound.m_vecMax.y = v7;
      *(_QWORD *)&v3->m_sphereBound.m_vecCentre.x = v8;
      v9 = *((_BYTE *)v3 + 41);
      v3->m_level = *((_BYTE *)v4 + 44);
      *((_BYTE *)v3 + 41) = *((_BYTE *)v4 + 45) & 1 | v9 & 0xFE;
      CBaseModelInfo::SetColModel(v2, v3, 1);
      CColStore::IncludeModelIndex(
        *((unsigned __int8 *)&CColAccel::mp_caccColItems[v0] + 44),
        CColAccel::mp_caccColItems[v0].m_iModelIndex);
      ++v1;
      ++v0;
    }
    while ( v1 < CColAccel::m_iNumColItems );
  }
}

//----- (004665A8) --------------------------------------------------------
int __fastcall CColAccel::addColDef(
        float a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int16 a10,
        int a11)
{
  CColDefAccelItem *v11; // r5
  int v12; // r4
  _DWORD *p_top; // r0
  int result; // r0
  CColDefAccelItem *v15; // r5

  v11 = CColAccel::m_colBounds;
  v12 = CColAccel::m_iNumColBounds;
  CColAccel::m_colBounds[CColAccel::m_iNumColBounds].bb.left = a1;
  p_top = (_DWORD *)&v11[v12].bb.top;
  *p_top = a2;
  p_top[1] = a3;
  p_top[2] = a4;
  result = CColAccel::m_iNumColBounds + 1;
  v15 = &CColAccel::m_colBounds[CColAccel::m_iNumColBounds];
  v15->lastModel = a10;
  v15->firstModel = HIWORD(a9);
  v15->inMemoryAlways = BYTE2(a11) & 1;
  v15->interior = HIBYTE(a11) & 1;
  CColAccel::m_iNumColBounds = result;
  return result;
}

//----- (00466610) --------------------------------------------------------
void __fastcall CColAccel::getColDef(ColDef *colDef)
{
  int32 v1; // r3
  CColDefAccelItem *v2; // r1
  bool inMemoryAlways; // lr
  int16 *p_firstModel; // r2
  __int64 v5; // d16
  __int64 v6; // d17
  int v7; // r2

  v1 = CColAccel::m_iNumColBounds;
  v2 = &CColAccel::m_colBounds[CColAccel::m_iNumColBounds];
  inMemoryAlways = v2->inMemoryAlways;
  v5 = *(_QWORD *)&v2->bb.left;
  v6 = *(_QWORD *)&v2->bb.right;
  p_firstModel = &v2->firstModel;
  LOBYTE(v2) = v2->interior;
  v7 = *(_DWORD *)p_firstModel;
  *(_QWORD *)&colDef->bb.left = v5;
  *(_QWORD *)&colDef->bb.right = v6;
  *(_DWORD *)&colDef->firstModel = v7;
  colDef->inMemoryAlways = inMemoryAlways;
  colDef->interior = (unsigned __int8)v2 & 1;
  CColAccel::m_iNumColBounds = v1 + 1;
}

//----- (00466668) --------------------------------------------------------
IplDef *__fastcall CColAccel::setIplDef(
        int a1,
        float a2,
        __int64 a3,
        float a4,
        int a5,
        int a6,
        int a7,
        __int64 a8,
        int a9,
        int a10,
        int a11,
        __int16 a12)
{
  IplDef *result; // r0

  result = &CColAccel::m_iplDefs[a1];
  result->bb.left = a2;
  *(_QWORD *)&result->bb.top = a3;
  result->bb.bottom = a4;
  *(_DWORD *)result->name = a5;
  *(_DWORD *)&result->name[8] = a7;
  *(_DWORD *)&result->name[4] = a6;
  *(_QWORD *)&result->name[12] = a8;
  *(_DWORD *)&result->lastBuilding = a9;
  *(_DWORD *)&result->lastDummy = a10;
  *(_DWORD *)&result->interior = a11;
  *(_WORD *)&result->ignoreWhenDeleted = a12;
  return result;
}
// 466668: using guessed type _QWORD arg_10;

//----- (004666CC) --------------------------------------------------------
IplDef *__fastcall CColAccel::getIplDef(IplDef *retstr, int32 index)
{
  IplDef *v2; // r1
  __int64 v3; // d16
  __int64 v4; // d17
  __int64 v5; // d18
  __int64 v6; // d19
  __int64 v7; // d20
  __int64 v8; // d21
  IplDef *result; // r0

  v2 = &CColAccel::m_iplDefs[index];
  v3 = *(_QWORD *)&v2->bb.left;
  v4 = *(_QWORD *)&v2->bb.right;
  v5 = *(_QWORD *)&v2->name[16];
  v6 = *(_QWORD *)&v2->lastDummy;
  v7 = *(_QWORD *)v2->name;
  v8 = *(_QWORD *)&v2->name[8];
  *(_DWORD *)&retstr->ignoreWhenDeleted = *(_DWORD *)&v2->ignoreWhenDeleted;
  *(_QWORD *)&retstr->name[16] = v5;
  *(_QWORD *)&retstr->lastDummy = v6;
  *(_QWORD *)&retstr->bb.left = v3;
  *(_QWORD *)&retstr->bb.right = v4;
  result = (IplDef *)retstr->name;
  *(_QWORD *)&result->bb.left = v7;
  *(_QWORD *)&result->bb.right = v8;
  return result;
}

//----- (00466708) --------------------------------------------------------
void __fastcall CColAccel::cacheIPLSection(CEntity **ppListIn, int32 iListSize)
{
  int32 v2; // r0
  int32 *v3; // r1
  int32 v4; // r2
  CEntity *v5; // r4
  int32 v6; // r4
  CBaseModelInfo *v7; // r6
  CIplAccelItem *v8; // r5
  int32 *p_m_iActions; // r3
  __int64 v10; // r0
  CBaseModelInfo *v11; // r5
  CBaseModelInfo *v12; // r4

  if ( CColAccel::m_iCacheState == STATE_SAVING )
  {
    CColAccel::m_iSectionSize[CColAccel::m_iNumSections] = CColAccel::m_iNumIPLItems;
    v2 = CColAccel::m_iNumSections;
  }
  else
  {
    if ( CColAccel::m_iCacheState != STATE_LOADING )
      return;
    v2 = CColAccel::m_iNumSections;
    v3 = CColAccel::m_iSectionSize;
    v4 = CColAccel::m_iNumIPLItems;
    if ( CColAccel::m_iNumIPLItems < CColAccel::m_iSectionSize[CColAccel::m_iNumSections] )
    {
      do
      {
        v8 = &CColAccel::mp_caccIPLItems[v4];
        p_m_iActions = &v8->m_iActions;
        LOBYTE(v6) = v8->m_iActions;
        if ( (v8->m_iActions & 1) != 0 )
        {
          v5 = ppListIn[v8->m_iLodIndex];
          *(_DWORD *)&v5->m_nFlags |= 0x100000u;
          v6 = *p_m_iActions;
          if ( (*p_m_iActions & 8) != 0 )
            goto LABEL_6;
        }
        else if ( (v8->m_iActions & 8) != 0 )
        {
LABEL_6:
          v7 = CModelInfo::ms_modelInfoPtrs[v8->m_iModelIndex];
          v7->m_flags |= 0x20u;
          v6 = *p_m_iActions;
          if ( (*p_m_iActions & 4) != 0 )
            goto LABEL_7;
          goto LABEL_12;
        }
        if ( (v6 & 4) != 0 )
        {
LABEL_7:
          CModelInfo::ms_modelInfoPtrs[v8->m_iModelIndex]->m_lodDistance = 400.0;
          if ( (*p_m_iActions & 2) == 0 )
            goto LABEL_14;
LABEL_13:
          v10 = *(_QWORD *)&v8->m_iModelIndex;
          v11 = CModelInfo::ms_modelInfoPtrs[HIDWORD(v10)];
          v12 = CModelInfo::ms_modelInfoPtrs[(_DWORD)v10];
          CBaseModelInfo::DeleteCollisionModel(v11);
          CBaseModelInfo::SetColModel(v11, v12->m_pColModel, 0);
          v2 = CColAccel::m_iNumSections;
          v3 = CColAccel::m_iSectionSize;
          v4 = CColAccel::m_iNumIPLItems;
          goto LABEL_14;
        }
LABEL_12:
        if ( (v6 & 2) != 0 )
          goto LABEL_13;
LABEL_14:
        CColAccel::m_iNumIPLItems = ++v4;
      }
      while ( v4 < v3[v2] );
    }
  }
  CColAccel::m_iNumSections = v2 + 1;
}

//----- (00466898) --------------------------------------------------------
void __fastcall CColAccel::addIPLEntity(CEntity **ppListIn, int32 iListSize, int32 iEntityIndex)
{
  int v3; // r4
  CEntity *v4; // r5
  CEntity *m_pLod; // r6
  int32 m_nModelIndex; // lr
  int32 v7; // r12
  int v8; // r8
  CBaseModelInfo *v9; // r1
  CColModel *m_pColModel; // r1
  CColModel *v11; // r0
  CIplAccelItem *v12; // r1
  int v13; // r3
  CIplAccelItem *v14; // r1

  if ( CColAccel::m_iCacheState == STATE_SAVING )
  {
    v4 = ppListIn[iEntityIndex];
    m_pLod = v4->m_pLod;
    m_nModelIndex = v4->m_nModelIndex;
    v7 = m_pLod->m_nModelIndex;
    if ( v4->numLodChildren
      || (v3 = (int)&TheCamera,
          (float)(CModelInfo::ms_modelInfoPtrs[m_nModelIndex]->m_lodDistance * TheCamera.LODDistMultiplier) > 300.0) )
    {
      v8 = 8;
      if ( !m_pLod )
        goto LABEL_18;
    }
    else
    {
      v8 = 0;
      if ( !m_pLod )
        goto LABEL_18;
    }
    if ( iListSize < 1 )
    {
LABEL_9:
      v3 = -1;
    }
    else
    {
      v3 = 0;
      while ( ppListIn[v3] != m_pLod )
      {
        if ( ++v3 >= iListSize )
          goto LABEL_9;
      }
    }
    v9 = CModelInfo::ms_modelInfoPtrs[m_nModelIndex];
    if ( m_pLod->numLodChildren == 1 )
    {
      m_pColModel = v9->m_pColModel;
      v8 |= (*(_DWORD *)&v4->m_nFlags >> 20) & 1;
      if ( m_pColModel )
      {
        v11 = CModelInfo::ms_modelInfoPtrs[v7]->m_pColModel;
        if ( !v11 || v11 != m_pColModel )
        {
          v8 |= 2u;
LABEL_19:
          v12 = CColAccel::mp_caccIPLItems;
          v13 = CColAccel::m_iNumIPLItems;
          CColAccel::mp_caccIPLItems[CColAccel::m_iNumIPLItems].m_iIndex = iEntityIndex;
          v14 = &v12[v13];
          v14->m_iLodIndex = v3;
          v14->m_iModelIndex = m_nModelIndex;
          v14->m_iLodModelIndex = v7;
          v14->m_iActions = v8;
          ++CColAccel::m_iNumIPLItems;
          return;
        }
      }
    }
    else if ( (v9->m_flags & 0x20) != 0 )
    {
      v8 |= 4u;
      goto LABEL_19;
    }
LABEL_18:
    if ( !v8 )
      return;
    goto LABEL_19;
  }
}
// 466974: variable 'v3' is possibly undefined

//----- (004669B0) --------------------------------------------------------
const unsigned __int8 *__fastcall GetFilename(const unsigned __int8 *pPath)
{
  const unsigned __int8 *v1; // r4
  char *v2; // r0

  v1 = pPath;
  v2 = strrchr((const char *)pPath, 92);
  if ( v2 )
    return (const unsigned __int8 *)(v2 + 1);
  return v1;
}

//----- (004669C8) --------------------------------------------------------
void __fastcall LoadingScreenLoadingFile(const unsigned __int8 *pFilename)
{
  const unsigned __int8 *v1; // r4
  char *v2; // r0

  v1 = pFilename;
  v2 = strrchr((const char *)pFilename, 92);
  if ( v2 )
    v1 = (const unsigned __int8 *)(v2 + 1);
  sprintf(gString, "Loading %s", (const char *)v1);
  sub_198DD4("Loading the Game", gString, 0);
}

//----- (00466A0C) --------------------------------------------------------
void __fastcall CFileLoader::LoadLevel(const unsigned __int8 *pDatFilename)
{
  RwTexDictionary_0 *Current; // r8
  u_native v3; // r11
  unsigned __int8 *Line; // r10
  char *v5; // r0
  const char *v6; // r2
  CBaseModelInfo **v7; // r4
  int v8; // r6
  char *v9; // r0
  char *v10; // r2
  char *v11; // r0
  char *v12; // r2
  RwTexDictionary_0 *TexDictionary; // r6
  RwTexDictionary_0 *v14; // r5
  const char *v15; // r8
  const unsigned __int8 *v16; // r0
  char *v17; // r0
  const char *v18; // r2
  char *v19; // r0
  const char *v20; // r2
  char *v21; // r0
  const char *v22; // r2
  int v23; // [sp+1Ch] [bp-6Ch]
  char v24[64]; // [sp+28h] [bp-60h] BYREF

  Current = RwTexDictionaryGetCurrent();
  if ( !Current )
  {
    Current = RwTexDictionaryCreate();
    RwTexDictionarySetCurrent(Current);
  }
  v3 = CFileMgr::OpenFile(pDatFilename, (const unsigned __int8 *)&dword_466DF4);
  Line = CFileLoader::LoadLine(v3);
  if ( Line )
  {
    v23 = 0;
    do
    {
      if ( *Line != 35 )
      {
        if ( !strncmp("EXIT", (const char *)Line, 4u) )
          break;
        if ( !strncmp("TEXDICTION", (const char *)Line, 0xAu) )
        {
          strcpy(v24, (const char *)Line + 11);
          v11 = strrchr(v24, 92);
          v12 = v24;
          if ( v11 )
            v12 = v11 + 1;
          sprintf(gString, "Loading %s", v12);
          LoadingScreen("Loading the Game", gString, 0);
          TexDictionary = CFileLoader::LoadTexDictionary((const unsigned __int8 *)v24);
          RwTexDictionaryForAllTextures(TexDictionary, MoveTexturesCB, Current);
          RwTexDictionaryDestroy(TexDictionary);
        }
        else if ( !strncmp("IMG", (const char *)Line, 3u) )
        {
          v14 = Current;
          v15 = (const char *)(Line + 4);
          if ( strcmp((const char *)Line + 4, "MODELS\\GTA_INT.IMG") )
          {
            if ( !strncmp((const char *)Line + 4, "MODELS", 6u) )
            {
              *(_DWORD *)(Line + 5) = 1146635604;
              v15 = (const char *)(Line + 5);
              Line[9] = 66;
            }
            if ( !strcmp(v15, "DATA\\SCRIPT\\SCRIPT.IMG") )
              v16 = "DATA\\SCRIPT\\SCRIPTV1.IMG";
            else
              v16 = (const unsigned __int8 *)v15;
            CStreaming::AddImageToList(v16, 1);
          }
          Current = v14;
        }
        else if ( !strncmp("COLFILE", (const char *)Line, 7u) )
        {
          v17 = strrchr((const char *)Line + 10, 92);
          v18 = (const char *)(Line + 10);
          if ( v17 )
            v18 = v17 + 1;
          sprintf(gString, "Loading %s", v18);
          LoadingScreen("Loading the Game", gString, 0);
          CFileLoader::LoadCollisionFile(Line + 10, 0);
        }
        else if ( !strncmp("MODELFILE", (const char *)Line, 9u) )
        {
          v19 = strrchr((const char *)Line + 10, 92);
          v20 = (const char *)(Line + 10);
          if ( v19 )
            v20 = v19 + 1;
          sprintf(gString, "Loading %s", v20);
          LoadingScreen("Loading the Game", gString, 0);
          CFileLoader::LoadAtomicFile(Line + 10);
        }
        else if ( !strncmp("HIERFILE", (const char *)Line, 8u) )
        {
          v21 = strrchr((const char *)Line + 9, 92);
          v22 = (const char *)(Line + 9);
          if ( v21 )
            v22 = v21 + 1;
          sprintf(gString, "Loading %s", v22);
          LoadingScreen("Loading the Game", gString, 0);
          CFileLoader::LoadClumpFile(Line + 9);
        }
        else if ( !strncmp("IDE", (const char *)Line, 3u) )
        {
          v5 = strrchr((const char *)Line + 4, 92);
          v6 = (const char *)(Line + 4);
          if ( v5 )
            v6 = v5 + 1;
          sprintf(gString, "Loading %s", v6);
          LoadingScreen("Loading the Game", gString, 0);
          CFileLoader::LoadObjectTypes(Line + 4);
        }
        else if ( !strncmp("IPL", (const char *)Line, 3u) )
        {
          if ( v23 << 31 )
          {
            strcpy(v24, (const char *)Line + 4);
          }
          else
          {
            MatchAllModelStrings();
            strcpy(v24, (const char *)Line + 4);
            sprintf(gString, "Loading %s", "Object Data");
            LoadingScreen("Loading the Game", gString, 0);
            CObjectData::Initialise("DATA\\OBJECT.DAT", 0);
            sprintf(gString, "Loading %s", "Setup vehicle info data");
            LoadingScreen("Loading the Game", gString, 0);
            CVehicleModelInfo::SetupCommonData();
            sprintf(gString, "Loading %s", "Streaming Init");
            LoadingScreen("Loading the Game", gString, 0);
            CStreaming::Init2();
            CLoadingScreen::NewChunkLoaded();
            sprintf(gString, "Loading %s", "Collision");
            LoadingScreen("Loading the Game", gString, 0);
            CColStore::LoadAllBoundingBoxes();
            v7 = CModelInfo::ms_modelInfoPtrs;
            v8 = 20000;
            do
            {
              if ( *v7 )
                (*((void (__fastcall **)(CBaseModelInfo *))(*v7)->_vptr$CBaseModelInfo + 14))(*v7);
              ++v7;
              --v8;
            }
            while ( v8 );
          }
          v9 = strrchr(v24, 92);
          v10 = v24;
          if ( v9 )
            v10 = v9 + 1;
          sprintf(gString, "Loading %s", v10);
          LoadingScreen("Loading the Game", gString, 0);
          CFileLoader::LoadScene((const unsigned __int8 *)v24);
          v23 = 1;
        }
      }
      Line = CFileLoader::LoadLine(v3);
    }
    while ( Line );
    CFileMgr::CloseFile(v3);
    RwTexDictionarySetCurrent(Current);
    if ( v23 << 31 )
    {
      CIplStore::LoadAllRemainingIpls();
      CColStore::BoundingBoxesPostProcess();
      CTrain::InitTrains();
      CColStore::RemoveAllCollision();
    }
  }
  else
  {
    CFileMgr::CloseFile(v3);
    RwTexDictionarySetCurrent(Current);
  }
}
// 466DF4: using guessed type int dword_466DF4;

//----- (00466F0C) --------------------------------------------------------
RwTexDictionary_0 *__fastcall CFileLoader::LoadTexDictionary(const unsigned __int8 *pFilename)
{
  RwStream_0 *v1; // r0
  RwStream_0 *v2; // r4
  RwTexDictionary_0 *v3; // r5

  v1 = RwStreamOpen(rwSTREAMFILENAME, rwSTREAMREAD, pFilename);
  v2 = v1;
  if ( v1 )
  {
    if ( RwStreamFindChunk(v1, 0x16u, 0, 0) )
    {
      v3 = RwTexDictionaryGtaStreamRead(v2);
      RwStreamClose(v2, 0);
      if ( v3 )
        return v3;
    }
    else
    {
      RwStreamClose(v2, 0);
    }
  }
  return sub_18B03C();
}

//----- (00466F5C) --------------------------------------------------------
void __fastcall CFileLoader::AddTexDictionaries(RwTexDictionary_0 *pMasterTxd, RwTexDictionary_0 *pTxd)
{
  sub_19DCA8(pTxd, MoveTexturesCB, pMasterTxd);
}

//----- (00466F70) --------------------------------------------------------
void __fastcall CFileLoader::LoadCollisionFile(const unsigned __int8 *pFilename, uint8 level)
{
  int v2; // r9
  void *v3; // r5
  CBaseModelInfo *ModelInfo; // r0
  CBaseModelInfo *v5; // r10
  CColModel *m_pColModel; // r11
  CColModel *v7; // r4
  int buffer; // [sp+8h] [bp-40h] BYREF
  int v10; // [sp+Ch] [bp-3Ch]
  unsigned __int8 pData[24]; // [sp+10h] [bp-38h] BYREF

  v3 = (void *)CFileMgr::OpenFile(pFilename, (const unsigned __int8 *)&dword_4670BC);
  while ( OS_FileRead(v3, &buffer, 8) == OSFE_NoError )
  {
    switch ( buffer )
    {
      case 843861827:
        v2 = 1;
        break;
      case 860639043:
        v2 = 2;
        break;
      case 1280069443:
        v2 = 0;
        break;
    }
    CFileMgr::ReadBytes((u_native)v3, pData, 24);
    CFileMgr::Read_old((u_native)v3, CFileLoader::LoadCollisionFile(char const*,unsigned char)::tempBuffer, v10 - 24);
    ModelInfo = CModelInfo::GetModelInfo(pData, 0);
    v5 = ModelInfo;
    if ( !ModelInfo || (ModelInfo->m_flags & 0x80) == 0 )
      continue;
    m_pColModel = ModelInfo->m_pColModel;
    if ( m_pColModel )
    {
      if ( v2 != 2 )
        goto LABEL_13;
    }
    else
    {
      v7 = (CColModel *)CColModel::operator new(0x30u);
      CColModel::CColModel(v7);
      CBaseModelInfo::SetColModel(v5, v7, 1);
      m_pColModel = 0;
      if ( v2 != 2 )
      {
LABEL_13:
        if ( v2 == 1 )
        {
          CFileLoader::LoadCollisionModelVer2(
            CFileLoader::LoadCollisionFile(char const*,unsigned char)::tempBuffer,
            v10 - 24,
            m_pColModel,
            pData);
        }
        else if ( !v2 )
        {
          CFileLoader::LoadCollisionModel(
            CFileLoader::LoadCollisionFile(char const*,unsigned char)::tempBuffer,
            m_pColModel,
            pData);
        }
        goto LABEL_19;
      }
    }
    CFileLoader::LoadCollisionModelVer3(
      CFileLoader::LoadCollisionFile(char const*,unsigned char)::tempBuffer,
      v10 - 24,
      m_pColModel,
      pData);
LABEL_19:
    m_pColModel->m_level = level;
  }
  CFileMgr::CloseFile((u_native)v3);
}
// 467018: variable 'v2' is possibly undefined
// 4670BC: using guessed type int dword_4670BC;

//----- (004670D8) --------------------------------------------------------
void __fastcall CFileLoader::LoadAtomicFile(const unsigned __int8 *pFilename)
{
  RwStream_0 *v1; // r4
  RpClump_0 *v2; // r0
  RpClump_0 *v3; // r5

  v1 = RwStreamOpen(rwSTREAMFILENAME, rwSTREAMREAD, pFilename);
  if ( RwStreamFindChunk(v1, 0x10u, 0, 0) )
  {
    v2 = RpClumpStreamRead(v1);
    v3 = v2;
    if ( v2 )
    {
      RpClumpForAllAtomics(v2, CFileLoader::FindRelatedModelInfoCB, v2);
      RpClumpDestroy(v3);
    }
  }
  sub_1962A8(v1, 0);
}

//----- (00467124) --------------------------------------------------------
void __fastcall CFileLoader::LoadClumpFile(const unsigned __int8 *pFilename)
{
  RwStream_0 *v1; // r4
  RpClump_0 *v2; // r0
  RpClump_0 *v3; // r5
  const unsigned __int8 *FrameNodeName; // r0
  CBaseModelInfo *ModelInfo; // r0

  v1 = RwStreamOpen(rwSTREAMFILENAME, rwSTREAMREAD, pFilename);
  while ( RwStreamFindChunk(v1, 0x10u, 0, 0) )
  {
    v2 = RpClumpStreamRead(v1);
    v3 = v2;
    if ( v2 )
    {
      FrameNodeName = GetFrameNodeName((RwFrame_0 *)v2->object.parent);
      ModelInfo = CModelInfo::GetModelInfo(FrameNodeName, 0);
      if ( ModelInfo )
        (*((void (__fastcall **)(CBaseModelInfo *, RpClump_0 *))ModelInfo->_vptr$CBaseModelInfo + 17))(ModelInfo, v3);
      else
        RpClumpDestroy(v3);
    }
  }
  sub_1962A8(v1, 0);
}

//----- (0046717C) --------------------------------------------------------
void __fastcall CFileLoader::LoadObjectTypes(const unsigned __int8 *pFilename)
{
  int32 v1; // r11
  u_native v3; // r4
  unsigned __int8 *Line; // r0
  int v5; // r9
  int32 v6; // r2
  int32 v7; // r1
  bool v8; // r3
  int v9; // r6
  int v10; // r1
  bool v11; // zf
  bool v12; // zf
  int v13; // r1
  bool v14; // zf
  int v15; // r1
  bool v16; // zf
  int v17; // r1
  bool v18; // zf
  int v19; // r1
  bool v20; // zf
  int v21; // r1
  bool v22; // zf
  int v23; // r1
  int v24; // r1
  bool v25; // zf
  int v26; // r1
  bool v27; // zf
  int v28; // r1
  bool v29; // zf
  int v30; // r1
  bool v31; // zf
  int v32; // r1
  bool v33; // zf
  int32 nodeId; // [sp+8h] [bp-180h]
  int v35; // [sp+Ch] [bp-17Ch] BYREF
  int32 v36; // [sp+10h] [bp-178h] BYREF
  char v37; // [sp+14h] [bp-174h] BYREF
  char v38[255]; // [sp+69h] [bp-11Fh] BYREF

  v3 = CFileMgr::OpenFile(pFilename, (const unsigned __int8 *)&dword_467468);
  strcpy(v38, (const char *)pFilename);
  Line = CFileLoader::LoadLine(v3);
  if ( Line )
  {
    v5 = 0;
    nodeId = -1;
    do
    {
      v10 = *Line;
      v11 = v10 == 0;
      if ( *Line )
        v11 = v10 == 35;
      if ( v11 )
        goto LABEL_95;
      if ( !v5 )
      {
        switch ( *Line )
        {
          case '2':
            if ( Line[1] != 100 )
              goto LABEL_94;
            v13 = Line[2];
            v14 = v13 == 102;
            if ( v13 == 102 )
              v14 = Line[3] == 120;
            if ( !v14 )
              goto LABEL_94;
            v5 = 10;
            goto LABEL_95;
          case 'a':
            if ( Line[1] != 110 )
              goto LABEL_94;
            v15 = Line[2];
            v16 = v15 == 105;
            if ( v15 == 105 )
              v16 = Line[3] == 109;
            if ( !v16 )
              goto LABEL_94;
            v5 = 6;
            goto LABEL_95;
          case 'c':
            if ( Line[1] != 97 )
              goto LABEL_94;
            v17 = Line[2];
            v18 = v17 == 114;
            if ( v17 == 114 )
              v18 = Line[3] == 115;
            if ( !v18 )
              goto LABEL_94;
            v5 = 7;
            goto LABEL_95;
          case 'h':
            if ( Line[1] != 105 )
              goto LABEL_94;
            v19 = Line[2];
            v20 = v19 == 101;
            if ( v19 == 101 )
              v20 = Line[3] == 114;
            if ( !v20 )
              goto LABEL_94;
            v5 = 5;
            goto LABEL_95;
          case 'o':
            if ( Line[1] != 98 )
              goto LABEL_94;
            v21 = Line[2];
            v22 = v21 == 106;
            if ( v21 == 106 )
              v22 = Line[3] == 115;
            if ( !v22 )
              goto LABEL_94;
            v5 = 1;
            goto LABEL_95;
          case 'p':
            v23 = Line[1];
            if ( v23 == 97 )
            {
              v32 = Line[2];
              v33 = v32 == 116;
              if ( v32 == 116 )
                v33 = Line[3] == 104;
              if ( v33 )
              {
                v5 = 9;
                goto LABEL_95;
              }
            }
            else if ( v23 == 101 )
            {
              v24 = Line[2];
              v25 = v24 == 100;
              if ( v24 == 100 )
                v25 = Line[3] == 115;
              if ( v25 )
              {
                v5 = 8;
                goto LABEL_95;
              }
            }
            goto LABEL_94;
          case 't':
            if ( Line[1] == 111 )
            {
              v26 = Line[2];
              v27 = v26 == 98;
              if ( v26 == 98 )
                v27 = Line[3] == 106;
              if ( v27 )
              {
                v5 = 3;
                goto LABEL_95;
              }
            }
            v28 = Line[1];
            v29 = v28 == 120;
            if ( v28 == 120 )
              v29 = Line[2] == 100;
            if ( !v29 )
              goto LABEL_94;
            v5 = 0;
            if ( Line[3] == 112 )
              v5 = 11;
            break;
          case 'w':
            if ( Line[1] != 101 )
              goto LABEL_94;
            v30 = Line[2];
            v31 = v30 == 97;
            if ( v30 == 97 )
              v31 = Line[3] == 112;
            if ( !v31 )
              goto LABEL_94;
            v5 = 4;
            goto LABEL_95;
          default:
            goto LABEL_94;
        }
        goto LABEL_95;
      }
      v12 = v10 == 101;
      if ( v10 == 101 )
        v12 = Line[1] == 110;
      if ( v12 && Line[2] == 100 )
      {
LABEL_94:
        v5 = 0;
      }
      else
      {
        switch ( v5 & 0xF )
        {
          case 1:
            CFileLoader::LoadObject(Line);
            break;
          case 3:
            CFileLoader::LoadTimeObject(Line);
            break;
          case 4:
            CFileLoader::LoadWeaponObject(Line);
            break;
          case 5:
            CFileLoader::LoadClumpObject(Line);
            break;
          case 6:
            CFileLoader::LoadAnimatedClumpObject(Line);
            break;
          case 7:
            CFileLoader::LoadVehicleObject(Line);
            break;
          case 8:
            CFileLoader::LoadPedObject(Line);
            break;
          case 9:
            v9 = nodeId + 1;
            if ( nodeId != -1 )
            {
              if ( v35 == 2 )
              {
                v6 = nodeId;
                v7 = v1;
                v8 = 1;
              }
              else
              {
                if ( v35 != 1 )
                {
                  if ( !v35 )
                    CFileLoader::LoadPedPathNode(Line, v1, nodeId);
                  goto LABEL_6;
                }
                v7 = v1;
                v6 = nodeId;
                v8 = 0;
              }
              CFileLoader::LoadCarPathNode(Line, v7, v6, v8);
LABEL_6:
              if ( nodeId == 11 )
                v9 = -1;
              nodeId = v9;
              break;
            }
            sscanf((const char *)Line, "%d %d %s", &v35, &v36, &v37);
            v1 = v36;
            nodeId = 0;
            break;
          case 0xA:
            CFileLoader::Load2dEffect(Line);
            break;
          case 0xB:
            CFileLoader::LoadTXDParent(Line);
            break;
          default:
            break;
        }
      }
LABEL_95:
      Line = CFileLoader::LoadLine(v3);
    }
    while ( Line );
  }
  CFileMgr::CloseFile(v3);
}
// 4671CA: variable 'v1' is possibly undefined
// 467468: using guessed type int dword_467468;
// 46717C: using guessed type char var_11F[255];

//----- (00467474) --------------------------------------------------------
void MatchAllModelStrings()
{
  CModelInfo::GetModelInfoUInt16("fire_hydrant", &MI_FIRE_HYDRANT);
  CModelInfo::GetModelInfoUInt16("phonesign", &MI_PHONESIGN);
  CModelInfo::GetModelInfoUInt16("noparkingsign1", &MI_NOPARKINGSIGN1);
  CModelInfo::GetModelInfoUInt16("bussign1", &MI_BUSSIGN1);
  CModelInfo::GetModelInfoUInt16("DYN_ROADBARRIER_6", &MI_ROADWORKBARRIER1);
  CModelInfo::GetModelInfoUInt16("la_fuckcar1", &MI_ROADBLOCKFUCKEDCAR1);
  CModelInfo::GetModelInfoUInt16("la_fuckcar2", &MI_ROADBLOCKFUCKEDCAR2);
  CModelInfo::GetModelInfoUInt16("dump1", &MI_DUMP1);
  CModelInfo::GetModelInfoUInt16("trafficcone", &MI_TRAFFICCONE);
  CModelInfo::GetModelInfoUInt16("newsstand1", &MI_NEWSSTAND);
  CModelInfo::GetModelInfoUInt16("postbox1", &MI_POSTBOX1);
  CModelInfo::GetModelInfoUInt16("bin1", &MI_BIN);
  CModelInfo::GetModelInfoUInt16("wastebin", &MI_WASTEBIN);
  CModelInfo::GetModelInfoUInt16("phonebooth1", &MI_PHONEBOOTH1);
  CModelInfo::GetModelInfoUInt16("parkingmeter", &MI_PARKINGMETER);
  CModelInfo::GetModelInfoUInt16("parkingmeterg", &MI_PARKINGMETER2);
  CModelInfo::GetModelInfoUInt16("mall_fans", &MI_MALLFAN);
  CModelInfo::GetModelInfoUInt16("htl_fan_rotate_nt", &MI_HOTELFAN_NIGHT);
  CModelInfo::GetModelInfoUInt16("htl_fan_rotate_dy", &MI_HOTELFAN_DAY);
  CModelInfo::GetModelInfoUInt16("hotroomfan", &MI_HOTROOMFAN);
  CModelInfo::GetModelInfoUInt16("trafficlight1", &MI_TRAFFICLIGHTS);
  CModelInfo::GetModelInfoUInt16("MTraffic4", &MI_TRAFFICLIGHTS_VERTICAL);
  CModelInfo::GetModelInfoUInt16("MTraffic1", &MI_TRAFFICLIGHTS_MIAMI);
  CModelInfo::GetModelInfoUInt16("vgsstriptlights1", &MI_TRAFFICLIGHTS_VEGAS);
  CModelInfo::GetModelInfoUInt16("MTraffic2", &MI_TRAFFICLIGHTS_TWOVERTICAL);
  CModelInfo::GetModelInfoUInt16("lamppost1", &MI_SINGLESTREETLIGHTS1);
  CModelInfo::GetModelInfoUInt16("lamppost2", &MI_SINGLESTREETLIGHTS2);
  CModelInfo::GetModelInfoUInt16("lamppost3", &MI_SINGLESTREETLIGHTS3);
  CModelInfo::GetModelInfoUInt16("doublestreetlght1", &MI_DOUBLESTREETLIGHTS);
  CModelInfo::GetModelInfoUInt16("Streetlamp1", &MI_STREETLAMP1);
  CModelInfo::GetModelInfoUInt16("Streetlamp2", &MI_STREETLAMP2);
  CModelInfo::GetModelInfoUInt16("doc_crane_cab0", &MODELID_CRANE_1);
  CModelInfo::GetModelInfoUInt16("doc_crane_cab01", &MODELID_CRANE_2);
  CModelInfo::GetModelInfoUInt16("doc_crane_cab02", &MODELID_CRANE_3);
  CModelInfo::GetModelInfoUInt16("doc_crane_cab03", &MODELID_CRANE_4);
  CModelInfo::GetModelInfoUInt16("boatcranelg0", &MODELID_CRANE_5);
  CModelInfo::GetModelInfoUInt16("LODnetopa0", &MODELID_CRANE_6);
  CModelInfo::GetModelInfoUInt16("package1", &MI_COLLECTABLE1);
  CModelInfo::GetModelInfoUInt16("Money", &MI_MONEY);
  CModelInfo::GetModelInfoUInt16("barrel1", &MI_CARMINE);
  CModelInfo::GetModelInfoUInt16("barrel2", &MI_NAUTICALMINE);
  CModelInfo::GetModelInfoUInt16("DYN_TV_2", &MI_TELLY);
  CModelInfo::GetModelInfoUInt16("briefcase", &MI_BRIEFCASE);
  CModelInfo::GetModelInfoUInt16("wglasssmash", &MI_GLASS1);
  CModelInfo::GetModelInfoUInt16("glassfx_composh", &MI_GLASS8);
  CModelInfo::GetModelInfoUInt16("adrenaline", &MI_PICKUP_ADRENALINE);
  CModelInfo::GetModelInfoUInt16("bodyarmour", &MI_PICKUP_BODYARMOUR);
  CModelInfo::GetModelInfoUInt16((const unsigned __int8 *)"info", &MI_PICKUP_INFO);
  CModelInfo::GetModelInfoUInt16("health", &MI_PICKUP_HEALTH);
  CModelInfo::GetModelInfoUInt16("bonus", &MI_PICKUP_BONUS);
  CModelInfo::GetModelInfoUInt16("bribe", &MI_PICKUP_BRIBE);
  CModelInfo::GetModelInfoUInt16("killfrenzy", &MI_PICKUP_KILLFRENZY);
  CModelInfo::GetModelInfoUInt16("camerapickup", &MI_PICKUP_CAMERA);
  CModelInfo::GetModelInfoUInt16("gun_para", &MI_PICKUP_PARACHUTE);
  CModelInfo::GetModelInfoUInt16("para_pack", &MI_PARACHUTE_BACKPACK);
  CModelInfo::GetModelInfoUInt16("bigdollar", &MI_PICKUP_REVENUE);
  CModelInfo::GetModelInfoUInt16("pickupsave", &MI_PICKUP_SAVEGAME);
  CModelInfo::GetModelInfoUInt16("property_locked", &MI_PICKUP_PROPERTY);
  CModelInfo::GetModelInfoUInt16("property_fsale", &MI_PICKUP_PROPERTY_FORSALE);
  CModelInfo::GetModelInfoUInt16("clothesp", &MI_PICKUP_CLOTHES);
  CModelInfo::GetModelInfoUInt16("killfrenzy2plyr", &MI_PICKUP_2P_KILLFRENZY);
  CModelInfo::GetModelInfoUInt16("2player", &MI_PICKUP_2P_COOP);
  CModelInfo::GetModelInfoUInt16("bollardlight", &MI_BOLLARDLIGHT);
  CModelInfo::GetModelInfoUInt16("bar_barrier10", &MI_FENCE);
  CModelInfo::GetModelInfoUInt16("bar_barrier12", &MI_FENCE2);
  CModelInfo::GetModelInfoUInt16("bouy", &MI_BUOY);
  CModelInfo::GetModelInfoUInt16("parktable1", &MI_PARKTABLE);
  CModelInfo::GetModelInfoUInt16("CJ_OYSTER", &MI_OYSTER);
  CModelInfo::GetModelInfoUInt16("cj_horse_Shoe", &MI_HORSESHOE);
  CModelInfo::GetModelInfoUInt16("wheel_or1", &MI_OFFROAD_WHEEL);
  CModelInfo::GetModelInfoUInt16("nto_b_s", &MI_NITRO_BOTTLE_SMALL);
  CModelInfo::GetModelInfoUInt16("nto_b_l", &MI_NITRO_BOTTLE_LARGE);
  CModelInfo::GetModelInfoUInt16("nto_b_tw", &MI_NITRO_BOTTLE_DOUBLE);
  CModelInfo::GetModelInfoUInt16("lamppost1", &MI_LAMPPOST1);
  CModelInfo::GetModelInfoUInt16("veg_palm04", &MI_VEG_PALM01);
  CModelInfo::GetModelInfoUInt16("veg_palwee02", &MI_VEG_PALM02);
  CModelInfo::GetModelInfoUInt16("veg_palmkbb11", &MI_VEG_PALM03);
  CModelInfo::GetModelInfoUInt16("veg_palmkb4", &MI_VEG_PALM04);
  CModelInfo::GetModelInfoUInt16("veg_palm02", &MI_VEG_PALM05);
  CModelInfo::GetModelInfoUInt16("veg_palmkb3", &MI_VEG_PALM06);
  CModelInfo::GetModelInfoUInt16("veg_palmbig14", &MI_VEG_PALM07);
  CModelInfo::GetModelInfoUInt16("veg_palm01", &MI_VEG_PALM08);
  CModelInfo::GetModelInfoUInt16("mlamppost", &MI_MLAMPPOST);
  CModelInfo::GetModelInfoUInt16("roadworkbarrier1", &MI_BARRIER1);
  CModelInfo::GetModelInfoUInt16("littleha_police", &MI_LITTLEHA_POLICE);
  CModelInfo::GetModelInfoUInt16("telgrphpole02", &MI_TELPOLE02);
  CModelInfo::GetModelInfoUInt16("trafficlight1", &MI_TRAFFICLIGHT01);
  CModelInfo::GetModelInfoUInt16("parkbench1", &MI_PARKBENCH);
  CModelInfo::GetModelInfoUInt16("Money", &MI_MONEY);
  CModelInfo::GetModelInfoUInt16("od_lightbeam", &MI_LIGHTBEAM);
  CModelInfo::GetModelInfoUInt16("ap_radar1_01", &MI_AIRPORTRADAR);
  CModelInfo::GetModelInfoUInt16("rcbomb", &MI_RCBOMB);
  CModelInfo::GetModelInfoUInt16("beachball", &MI_BEACHBALL);
  CModelInfo::GetModelInfoUInt16("sandcastle1", &MI_SANDCASTLE1);
  CModelInfo::GetModelInfoUInt16("sandcastle2", &MI_SANDCASTLE2);
  CModelInfo::GetModelInfoUInt16("jellyfish", &MI_JELLYFISH);
  CModelInfo::GetModelInfoUInt16("jellyfish01", &MI_JELLYFISH01);
  CModelInfo::GetModelInfoUInt16("fish1single", &MI_FISH1SINGLE);
  CModelInfo::GetModelInfoUInt16("fish1s", &MI_FISH1S);
  CModelInfo::GetModelInfoUInt16("fish2single", &MI_FISH2SINGLE);
  CModelInfo::GetModelInfoUInt16("fish2s", &MI_FISH2S);
  CModelInfo::GetModelInfoUInt16("fish3single", &MI_FISH3SINGLE);
  CModelInfo::GetModelInfoUInt16("fish3s", &MI_FISH3S);
  CModelInfo::GetModelInfoUInt16("turtle", &MI_TURTLE);
  CModelInfo::GetModelInfoUInt16("dolphin", &MI_DOLPHIN);
  CModelInfo::GetModelInfoUInt16("shark", &MI_SHARK);
  CModelInfo::GetModelInfoUInt16("submarine", &MI_SUBMARINE);
  CModelInfo::GetModelInfoUInt16("Esc_step", &MI_ESCALATORSTEP);
  CModelInfo::GetModelInfoUInt16("Esc_step8", &MI_ESCALATORSTEP8);
  CModelInfo::GetModelInfoUInt16("lounge_wood_up", &MI_LOUNGE_WOOD_UP);
  CModelInfo::GetModelInfoUInt16("lounge_towel_up", &MI_LOUNGE_TOWEL_UP);
  CModelInfo::GetModelInfoUInt16("lounge_wood_dn", &MI_LOUNGE_WOOD_DN);
  CModelInfo::GetModelInfoUInt16("lotion", &MI_LOTION);
  CModelInfo::GetModelInfoUInt16("beachtowel01", &MI_BEACHTOWEL01);
  CModelInfo::GetModelInfoUInt16("beachtowel02", &MI_BEACHTOWEL02);
  CModelInfo::GetModelInfoUInt16("beachtowel03", &MI_BEACHTOWEL03);
  CModelInfo::GetModelInfoUInt16("beachtowel04", &MI_BEACHTOWEL04);
  CModelInfo::GetModelInfoUInt16("blimp_night", &MI_BLIMP_NIGHT);
  CModelInfo::GetModelInfoUInt16("blimp_day", &MI_BLIMP_DAY);
  CModelInfo::GetModelInfoUInt16("yt_main_body", &MI_YT_MAIN_BODY);
  CModelInfo::GetModelInfoUInt16("yt_main_body2", &MI_YT_MAIN_BODY2);
  CModelInfo::GetModelInfoUInt16("mil_samsite", &MI_SAMSITE);
  CModelInfo::GetModelInfoUInt16("samsite_SFXRF", &MI_SAMSITE2);
  CModelInfo::GetModelInfoUInt16("traincross2", &MI_TRAINCROSSING);
  CModelInfo::GetModelInfoUInt16("traincross1", &MI_TRAINCROSSING1);
  CModelInfo::GetModelInfoUInt16("MagnoCrane_03", &MI_MAGNOCRANE);
  CModelInfo::GetModelInfoUInt16("TwrCrane_M_02", &MI_CRANETROLLEY);
  CModelInfo::GetModelInfoUInt16("quarry_cranearm", &MI_QUARRYCRANE_ARM);
  CModelInfo::GetModelInfoUInt16("kmb_container_red", &MI_OBJECTFORMAGNOCRANE1);
  CModelInfo::GetModelInfoUInt16("kmb_container_yel", &MI_OBJECTFORMAGNOCRANE2);
  CModelInfo::GetModelInfoUInt16("kmb_container_blue", &MI_OBJECTFORMAGNOCRANE3);
  CModelInfo::GetModelInfoUInt16("barrel4", &MI_OBJECTFORMAGNOCRANE4);
  CModelInfo::GetModelInfoUInt16("kmb_container_open", &MI_OBJECTFORMAGNOCRANE5);
  CModelInfo::GetModelInfoUInt16("blockpallet", &MI_OBJECTFORBUILDINGSITECRANE1);
  CModelInfo::GetModelInfoUInt16("magnocrane5_SFS", &MI_MAGNOCRANE_HOOK);
  CModelInfo::GetModelInfoUInt16("kmb_deadarm", &MI_HARVESTERBODYPART1);
  CModelInfo::GetModelInfoUInt16("kmb_deadleg", &MI_HARVESTERBODYPART2);
  CModelInfo::GetModelInfoUInt16("kmb_deadhead", &MI_HARVESTERBODYPART3);
  CModelInfo::GetModelInfoUInt16("kmb_deadtorso", &MI_HARVESTERBODYPART4);
  CModelInfo::GetModelInfoUInt16("grasshouse", &MI_GRASSHOUSE);
  CModelInfo::GetModelInfoUInt16("sw_gas01", &MI_GASSTATION);
  CModelInfo::GetModelInfoUInt16("grassplant", &MI_GRASSPLANT);
  CModelInfo::GetModelInfoUInt16("INDUS_MAGNET", &MI_CRANE_MAGNET);
  CModelInfo::GetModelInfoUInt16("CJ_PLAYER_HARNESS", &MI_CRANE_HARNESS);
  CModelInfo::GetModelInfoUInt16("dyn_quarryrock01", &MI_QUARY_ROCK1);
  CModelInfo::GetModelInfoUInt16("dyn_quarryrock02", &MI_QUARY_ROCK2);
  CModelInfo::GetModelInfoUInt16("dyn_quarryrock03", &MI_QUARY_ROCK3);
  CModelInfo::GetModelInfoUInt16("KMB_ATM3", &MI_ATM);
  CModelInfo::GetModelInfoUInt16("dead_tied_cop", &MI_DEAD_TIED_COP);
  CModelInfo::GetModelInfoUInt16("bonyrd_windsock", &MI_WINDSOCK);
  CModelInfo::GetModelInfoUInt16("DYN_WREKING_BALL", &MI_WRECKING_BALL);
  CModelInfo::GetModelInfoUInt16((const unsigned __int8 *)"bomb", &MI_FREEFALL_BOMB);
  CModelInfo::GetModelInfoUInt16("mini_magnet", &MI_MINI_MAGNET);
  CModelInfo::GetModelInfoUInt16("ab_carcass", &MI_HANGING_CARCASS);
  CModelInfo::GetModelInfoUInt16("wong_dish", &MI_WONG_DISH);
  CModelInfo::GetModelInfoUInt16("CJ_BEAR_BOTTLE", &MI_GANG_DRINK);
  CModelInfo::GetModelInfoUInt16("CJ_CIGGY", &MI_GANG_SMOKE);
  CModelInfo::GetModelInfoUInt16("CJ_TRAFFIC_LIGHT3", &MI_TRAFFICLIGHTS_3);
  CModelInfo::GetModelInfoUInt16("CJ_TRAFFIC_LIGHT4", &MI_TRAFFICLIGHTS_4);
  CModelInfo::GetModelInfoUInt16("CJ_TRAFFIC_LIGHT5", &MI_TRAFFICLIGHTS_5);
  CModelInfo::GetModelInfoUInt16("GAY_TRAFFIC_LIGHT", &MI_TRAFFICLIGHTS_GAY);
  CModelInfo::GetModelInfoUInt16("imy_shash_wall", &MI_IMY_SHASH_WALL);
  CModelInfo::GetModelInfoUInt16("flare", &MI_FLARE);
  CModelInfo::GetModelInfoUInt16("hydralics", &MI_HYDRAULICS);
  CModelInfo::GetModelInfoUInt16("stereo", &MI_STEREO_UPGRADE);
  CModelInfo::GetModelInfoUInt16("BBALL_COL", &MI_BASKETBALL);
  CModelInfo::GetModelInfoUInt16("k_poolballcue", &MI_POOL_CUE_BALL);
  CModelInfo::GetModelInfoUInt16("punchbagnu", &MI_PUNCHBAG);
  sub_19FCB0("imy_bbox", &MI_IMY_GRAY_CRATE);
}
// 468318: using guessed type __int16 **off_468318;
// 6767A0: using guessed type __int16 *MI_HYDRAULICS_ptr[3];
// 6768C8: using guessed type __int16 *MI_BEACHTOWEL02_ptr;
// 676964: using guessed type __int16 *MI_NITRO_BOTTLE_SMALL_ptr[2];
// 676A94: using guessed type __int16 *MI_LOUNGE_WOOD_UP_ptr[2];
// 6778F8: using guessed type __int16 *MI_GANG_DRINK_ptr;
// 677998: using guessed type __int16 *MI_BEACHTOWEL04_ptr;
// 677BB8: using guessed type __int16 *MI_LOUNGE_TOWEL_UP_ptr[3];
// 678190: using guessed type __int16 *MI_BEACHBALL_ptr[2];
// 6781D4: using guessed type __int16 *MI_BEACHTOWEL03_ptr;
// 678200: using guessed type __int16 *MI_LOTION_ptr;
// 679000: using guessed type __int16 *MI_GANG_SMOKE_ptr;

//----- (00468600) --------------------------------------------------------
void __fastcall CObjectData::Initialise(unsigned __int8 *pFilename, bool bReload)
{
  u_native v3; // r4
  const char *Line; // r0
  unsigned int v5; // r9
  CObjectInfo *v6; // r6
  _QWORD *p_m_fMass; // r6
  int v8; // r0
  CObjectInfo *v9; // r8
  uint8 v10; // r0
  CBaseModelInfo *ModelInfo; // r0
  uint8 *p_m_CamAvoidThis; // r11
  float v13; // s0
  uint8 *p_m_nCollisionSpecial; // r2
  uint8 *p_m_nCollisionDamageEffect; // r3
  float m_fMass; // s2
  int v17; // r6
  bool v18; // zf
  float *v19; // r5
  int v20; // r12
  RwReal *i; // lr
  int v22; // r1
  bool v23; // zf
  _DWORD *v24; // [sp+5Ch] [bp-2C4h]
  float *v25; // [sp+60h] [bp-2C0h]
  float *v26; // [sp+64h] [bp-2BCh]
  float *v27; // [sp+68h] [bp-2B8h]
  float *v28; // [sp+6Ch] [bp-2B4h]
  float *v29; // [sp+70h] [bp-2B0h]
  _DWORD *v30; // [sp+74h] [bp-2ACh]
  float *v31; // [sp+78h] [bp-2A8h]
  float *v32; // [sp+7Ch] [bp-2A4h]
  float *v33; // [sp+80h] [bp-2A0h]
  unsigned __int8 *v34; // [sp+84h] [bp-29Ch]
  CObjectInfo *v35; // [sp+88h] [bp-298h]
  float *v36; // [sp+90h] [bp-290h]
  float *v37; // [sp+94h] [bp-28Ch]
  float *v38; // [sp+98h] [bp-288h]
  float *v39; // [sp+B8h] [bp-268h]
  float *v40; // [sp+BCh] [bp-264h]
  int v41; // [sp+C0h] [bp-260h] BYREF
  int v42; // [sp+C4h] [bp-25Ch] BYREF
  int v43; // [sp+C8h] [bp-258h] BYREF
  int v44; // [sp+CCh] [bp-254h] BYREF
  float v45; // [sp+D0h] [bp-250h] BYREF
  int v46; // [sp+D4h] [bp-24Ch] BYREF
  int v47; // [sp+D8h] [bp-248h] BYREF
  unsigned __int8 v48[256]; // [sp+DCh] [bp-244h] BYREF
  unsigned __int8 v49[256]; // [sp+1DCh] [bp-144h] BYREF

  CObjectData::ms_aObjectInfo[0].m_fUprootLimit = 0.0;
  CObjectData::ms_aObjectInfo[0].m_fCollisionDamageMultiplier = 1.0;
  *(_WORD *)&CObjectData::ms_aObjectInfo[0].m_nCollisionDamageEffect = 0;
  CObjectData::ms_aObjectInfo[0].m_CamAvoidThis = 2;
  *(_QWORD *)&CObjectData::ms_aObjectInfo[0].m_fMass = 0x47C34F8047C34F80LL;
  *(_QWORD *)&CObjectData::ms_aObjectInfo[0].m_fAirResistance = 0x3DCCCCCD3F7D70A4LL;
  CObjectData::ms_aObjectInfo[0].m_fBuoyancyConstant = 1600.0;
  qmemcpy(&CObjectData::ms_aObjectInfo[1], CObjectData::ms_aObjectInfo, sizeof(CObjectInfo));
  CObjectData::ms_aObjectInfo[1].m_CamAvoidThis = 0;
  qmemcpy(&CObjectData::ms_aObjectInfo[2], CObjectData::ms_aObjectInfo, sizeof(CObjectInfo));
  CObjectData::ms_aObjectInfo[2].m_nCollisionSpecial = 4;
  qmemcpy(&CObjectData::ms_aObjectInfo[3], CObjectData::ms_aObjectInfo, sizeof(CObjectInfo));
  *(_WORD *)&CObjectData::ms_aObjectInfo[3].m_nCollisionSpecial = 4;
  qmemcpy(&CObjectData::ms_aObjectInfo[4], CObjectData::ms_aObjectInfo, sizeof(CObjectInfo));
  CObjectData::ms_aObjectInfo[4].m_nCollisionSpecial = 5;
  CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
  v3 = CFileMgr::OpenFile(pFilename, (const unsigned __int8 *)&dword_468B3C);
  Line = (const char *)CFileLoader::LoadLine(v3);
  if ( Line )
  {
    v5 = 5;
    v6 = CObjectData::ms_aObjectInfo;
    do
    {
      v22 = *(unsigned __int8 *)Line;
      v23 = v22 == 0;
      if ( *Line )
        v23 = v22 == 59;
      if ( v23 )
        goto LABEL_55;
      if ( v22 == 42 )
        break;
      v35 = v6;
      p_m_fMass = (_QWORD *)&v6[v5].m_fMass;
      v34 = (unsigned __int8 *)(p_m_fMass + 4);
      p_m_fMass[8] = 0LL;
      p_m_fMass[9] = 0LL;
      p_m_fMass[6] = 0LL;
      p_m_fMass[7] = 0LL;
      p_m_fMass[4] = 0LL;
      p_m_fMass[5] = 0LL;
      *p_m_fMass = 0LL;
      p_m_fMass[1] = 0LL;
      p_m_fMass[2] = 0LL;
      p_m_fMass[3] = 0LL;
      v24 = p_m_fMass + 9;
      v41 = 0;
      v25 = (float *)p_m_fMass + 17;
      v26 = (float *)(p_m_fMass + 8);
      v27 = (float *)p_m_fMass + 15;
      v28 = (float *)(p_m_fMass + 7);
      v29 = (float *)p_m_fMass + 13;
      v31 = (float *)p_m_fMass + 11;
      v32 = (float *)(p_m_fMass + 5);
      v33 = (float *)p_m_fMass + 9;
      v36 = (float *)(p_m_fMass + 3);
      v37 = (float *)p_m_fMass + 5;
      v38 = (float *)p_m_fMass + 3;
      v39 = (float *)(p_m_fMass + 1);
      v40 = (float *)p_m_fMass + 1;
      sscanf(
        Line,
        "%s %f %f %f %f %f %f %f %d %d %d %d %d %f %f %f %s %f %f %f %f %f %d %d",
        v49,
        p_m_fMass,
        (char *)p_m_fMass + 4,
        p_m_fMass + 1,
        (char *)p_m_fMass + 12,
        &v45,
        (char *)p_m_fMass + 20,
        p_m_fMass + 3,
        &v44,
        &v43,
        &v42,
        &v46,
        &v47,
        (char *)p_m_fMass + 36,
        p_m_fMass + 5,
        (char *)p_m_fMass + 44,
        v48,
        (char *)p_m_fMass + 52,
        p_m_fMass + 7,
        (char *)p_m_fMass + 60,
        p_m_fMass + 8,
        (char *)p_m_fMass + 68,
        p_m_fMass + 9,
        &v41);
      v8 = v47;
      *((_DWORD *)p_m_fMass + 12) = 0;
      *((_BYTE *)p_m_fMass + 32) = v8;
      if ( v8 >= 1 )
        *((_DWORD *)p_m_fMass + 12) = FxManager_c::FindFxSystemBP(&g_fxMan, v48);
      v30 = p_m_fMass + 6;
      v9 = &CObjectData::ms_aObjectInfo[v5];
      v10 = v44;
      v9->m_fBuoyancyConstant = (float)(*(float *)p_m_fMass * 0.008) * (float)(100.0 / v45);
      v9->m_nCollisionDamageEffect = v10;
      v9->m_nCollisionSpecial = v43;
      v9->m_CamAvoidThis = v42;
      v9->m_causesExplosion = v46;
      v9->m_produceSparks = v41;
      ModelInfo = CModelInfo::GetModelInfo(v49, 0);
      if ( ModelInfo )
      {
        p_m_CamAvoidThis = &v9->m_CamAvoidThis;
        v13 = *(float *)p_m_fMass;
        p_m_nCollisionSpecial = &v9->m_nCollisionSpecial;
        p_m_nCollisionDamageEffect = &v9->m_nCollisionDamageEffect;
        m_fMass = CObjectData::ms_aObjectInfo[0].m_fMass;
        if ( *(float *)p_m_fMass == CObjectData::ms_aObjectInfo[0].m_fMass
          && *v36 == CObjectData::ms_aObjectInfo[0].m_fCollisionDamageMultiplier
          && *p_m_nCollisionDamageEffect == CObjectData::ms_aObjectInfo[0].m_nCollisionDamageEffect )
        {
          v17 = *p_m_nCollisionSpecial;
          v18 = v17 == CObjectData::ms_aObjectInfo[0].m_nCollisionSpecial;
          if ( v17 != CObjectData::ms_aObjectInfo[0].m_nCollisionSpecial )
            v18 = v17 == CObjectData::ms_aObjectInfo[2].m_nCollisionSpecial;
          if ( v18 )
          {
            if ( v17 == CObjectData::ms_aObjectInfo[0].m_nCollisionSpecial )
            {
              v6 = v35;
              if ( *p_m_CamAvoidThis )
                ModelInfo->m_dynamicIndex = 0;
              else
                ModelInfo->m_dynamicIndex = 1;
            }
            else
            {
              v6 = v35;
              if ( *p_m_CamAvoidThis )
                ModelInfo->m_dynamicIndex = 2;
              else
                ModelInfo->m_dynamicIndex = 3;
            }
            goto LABEL_55;
          }
        }
        v19 = v38;
        if ( v5 )
        {
          v20 = 0;
          for ( i = &CObjectData::ms_aObjectInfo[0].m_fxOffset.y; ; i += 20 )
          {
            if ( v13 == m_fMass
              && *v40 == *(i - 9)
              && *v39 == *(i - 8)
              && *v19 == *(i - 7)
              && v9->m_fBuoyancyConstant == *(i - 6)
              && *v37 == *(i - 5)
              && *v36 == *(i - 4) )
            {
              v19 = v38;
              if ( *p_m_nCollisionDamageEffect == *((unsigned __int8 *)i - 12) )
              {
                v19 = v38;
                if ( *p_m_nCollisionSpecial == *((unsigned __int8 *)i - 11) )
                {
                  v19 = v38;
                  if ( *p_m_CamAvoidThis == *((unsigned __int8 *)i - 10) )
                  {
                    v19 = v38;
                    if ( v9->m_causesExplosion == *((unsigned __int8 *)i - 9) )
                    {
                      v19 = v38;
                      if ( *v34 == *((unsigned __int8 *)i - 8) && *v33 == *(i - 1) && *v32 == *i && *v31 == i[1] )
                      {
                        v19 = v38;
                        if ( *v30 == *((_DWORD *)i + 2)
                          && *v29 == i[3]
                          && *v28 == i[4]
                          && *v27 == i[5]
                          && *v26 == i[6]
                          && *v25 == i[7] )
                        {
                          v19 = v38;
                          if ( *v24 == *((_DWORD *)i + 8) )
                          {
                            v19 = v38;
                            if ( v9->m_produceSparks == *((unsigned __int8 *)i + 36) )
                              break;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            if ( ++v20 >= v5 )
              goto LABEL_45;
            m_fMass = i[10];
          }
          ModelInfo->m_dynamicIndex = v20;
        }
        else
        {
LABEL_45:
          ModelInfo->m_dynamicIndex = v5++;
        }
      }
      v6 = v35;
LABEL_55:
      Line = (const char *)CFileLoader::LoadLine(v3);
    }
    while ( Line );
  }
  CFileMgr::CloseFile(v3);
}
// 6C: using guessed type int dword_6C;
// BC: using guessed type int dword_BC;
// FC: using guessed type int elf_hash_bucket[16411];
// 468B3C: using guessed type int dword_468B3C;
// 61CADE: using guessed type char byte_61CADE;
// 468600: using guessed type unsigned __int8 var_244[256];
// 468600: using guessed type unsigned __int8 var_144[256];

//----- (00468B68) --------------------------------------------------------
void CVehicleModelInfo::SetupCommonData()
{
  int32 TxdSlot; // r4
  CPool<CVehicleModelInfo::CVehicleStructure,CVehicleModelInfo::CVehicleStructure> *v1; // r4
  uint8 *v2; // r0
  uint8 v3; // r1
  int i; // r0
  int j; // r4
  CVehicleModelInfo *ModelInfo; // r0

  CVehicleModelInfo::LoadVehicleColours();
  CLoadingScreen::NewChunkLoaded();
  CVehicleModelInfo::LoadVehicleUpgrades();
  CLoadingScreen::NewChunkLoaded();
  CVehicleModelInfo::LoadEnvironmentMaps();
  CLoadingScreen::NewChunkLoaded();
  TxdSlot = CTxdStore::FindTxdSlot("vehicle");
  if ( TxdSlot == -1 )
    TxdSlot = CTxdStore::AddTxdSlot("vehicle", (const unsigned __int8 *)&off_468C80, 1);
  CTxdStore::LoadTxd(TxdSlot, "MODELS\\GENERIC\\VEHICLE.TXD");
  CTxdStore::AddRef(TxdSlot);
  CTxdStore::PushCurrentTxd();
  CTxdStore::SetCurrentTxd(TxdSlot, 0);
  CVehicleModelInfo::ms_pLightsTexture = RwTextureRead((const RwChar *)"vehiclelights128", 0);
  CVehicleModelInfo::ms_pLightsOnTexture = RwTextureRead((const RwChar *)"vehiclelightson128", 0);
  CTxdStore::PopCurrentTxd();
  CLoadingScreen::NewChunkLoaded();
  v1 = (CPool<CVehicleModelInfo::CVehicleStructure,CVehicleModelInfo::CVehicleStructure> *)operator new(0x14u);
  v1->m_aStorage = (CPool<CVehicleModelInfo::CVehicleStructure,CVehicleModelInfo::CVehicleStructure>::StorageType *)operator new[](0x9E98u);
  v2 = (uint8 *)operator new[](0x32u);
  v1->m_bOwnsArrays = 1;
  v1->m_aFlags = v2;
  v1->m_nSize = 50;
  v1->m_nFreeIndex = -1;
  v3 = v2[1];
  *v2 = 0x80;
  v2[1] = v3 | 0x80;
  v1->m_aFlags[1] &= 0x80u;
  for ( i = 2; i != 50; ++i )
  {
    v1->m_aFlags[i] |= 0x80u;
    v1->m_aFlags[i] &= 0x80u;
  }
  CVehicleModelInfo::CVehicleStructure::m_pInfoPool = v1;
  CCarFXRenderer::InitialiseDirtTexture();
  for ( j = 0; j != 36; ++j )
  {
    ModelInfo = (CVehicleModelInfo *)CModelInfo::GetModelInfo((const unsigned __int8 *)off_6684A8[2 * j], 400, 630);
    CVehicleModelInfo::AddRemap(ModelInfo, (const unsigned __int8 *)off_6684A8[2 * j + 1]);
  }
}
// 468C80: using guessed type void *off_468C80;
// 6684A8: using guessed type char *off_6684A8[73];

//----- (00468CDC) --------------------------------------------------------
void __fastcall CFileLoader::LoadScene(const unsigned __int8 *pFilename)
{
  const unsigned __int8 *v1; // r4
  int v2; // r8
  u_native v3; // r5
  unsigned __int8 *Line; // r0
  int32 *p_m_maxDelay; // r11
  int32 *p_m_minDelay; // r9
  int32 *p_m_lockedChance; // r10
  int v8; // r1
  bool v9; // zf
  CEntity *ObjectInstance; // r0
  int32 v11; // r1
  int v12; // r2
  bool v13; // zf
  int v14; // r2
  bool v15; // zf
  int v16; // r1
  bool v17; // zf
  int v18; // r2
  bool v19; // zf
  int v20; // r2
  bool v21; // zf
  int v22; // r2
  bool v23; // zf
  int v24; // r2
  bool v25; // zf
  int v26; // r2
  bool v27; // zf
  int v28; // r1
  bool v29; // zf
  int v30; // r1
  bool v31; // zf
  int32 *v32; // r4
  int32 *v33; // r10
  int32 *v34; // r9
  int v35; // r11
  bool v36; // r3
  int v37; // r1
  bool v38; // zf
  int32 v39; // r0
  int32 NewIplEntityIndexArray; // r8
  CEntity **IplEntityIndexArray; // r5
  signed int v42; // r2
  int32 v43; // r10
  int32 v44; // r1
  int32 v45; // r6
  CEntity **v46; // r0
  CEntity *v47; // r5
  CEntity *m_pLod; // r4
  CEntity *v49; // r2
  int32 v50; // r5
  _BOOL4 isCacheLoading; // r0
  CEntity *v52; // r6
  CEntity *v53; // r0
  int numLodChildren; // r1
  CBaseModelInfo *v55; // r11
  CBaseModelInfo *v56; // r4
  CColModel *m_pColModel; // r0
  CColModel *v58; // r1
  int32 v59; // r4
  unsigned int v60; // r6
  CEntity **v61; // r1
  CEntity **v62; // r3
  __int64 v63; // d16
  __int64 v64; // d17
  const unsigned __int8 *v65; // [sp+28h] [bp-E8h]
  int32 nodeId; // [sp+5Ch] [bp-B4h]
  int v67; // [sp+60h] [bp-B0h] BYREF
  eLevelName level; // [sp+64h] [bp-ACh] BYREF
  eZoneType NewZoneType; // [sp+68h] [bp-A8h] BYREF
  float NewX2; // [sp+6Ch] [bp-A4h] BYREF
  float NewY2; // [sp+70h] [bp-A0h] BYREF
  float NewZ2; // [sp+74h] [bp-9Ch] BYREF
  float v73; // [sp+78h] [bp-98h] BYREF
  float v74; // [sp+7Ch] [bp-94h] BYREF
  float NewZ1; // [sp+80h] [bp-90h] BYREF
  Char pTextLabel[10]; // [sp+86h] [bp-8Ah] BYREF
  CFileCarGenerator v77; // [sp+90h] [bp-80h] BYREF

  v1 = pFilename;
  v2 = 0;
  gNumLoadedBuildings = 0;
  v3 = CFileMgr::OpenFile(pFilename, (const unsigned __int8 *)&dword_469334);
  Line = CFileLoader::LoadLine(v3);
  if ( Line )
  {
    p_m_maxDelay = &v77.m_maxDelay;
    p_m_minDelay = &v77.m_minDelay;
    p_m_lockedChance = &v77.m_lockedChance;
    nodeId = -1;
    do
    {
      v37 = *Line;
      v38 = v37 == 0;
      if ( *Line )
        v38 = v37 == 35;
      if ( !v38 )
      {
        if ( v2 )
        {
          if ( v37 != 101 )
            goto LABEL_8;
          v8 = Line[1];
          v9 = v8 == 110;
          if ( v8 == 110 )
            v9 = Line[2] == 100;
          if ( v9 )
          {
            v2 = 0;
          }
          else
          {
LABEL_8:
            switch ( v2 )
            {
              case 1:
                goto LABEL_121;
              case 2:
                ObjectInstance = CFileLoader::LoadObjectInstance(Line);
                v2 = 2;
                v11 = gNumLoadedBuildings++;
                gpLoadedBuildings[v11] = ObjectInstance;
                break;
              case 4:
                if ( sscanf(
                       (const char *)Line,
                       "%s %d %f %f %f %f %f %f %d %s",
                       &v77,
                       &NewZoneType,
                       &v73,
                       &v74,
                       &NewZ1,
                       &NewX2,
                       &NewY2,
                       &NewZ2,
                       &level,
                       pTextLabel) == 10 )
                  CTheZones::CreateZone(
                    (Char *)&v77,
                    NewZoneType,
                    v73,
                    v74,
                    NewZ1,
                    NewX2,
                    NewY2,
                    NewZ2,
                    level,
                    pTextLabel);
                goto LABEL_88;
              case 5:
                CFileLoader::LoadCullZone(Line);
                v2 = 5;
                break;
              case 6:
                CFileLoader::LoadOcclusionVolume(Line, v1);
                v2 = 6;
                break;
              case 7:
                v65 = v1;
                v32 = p_m_lockedChance;
                v33 = p_m_minDelay;
                v34 = p_m_maxDelay;
                v35 = nodeId + 1;
                if ( nodeId == -1 )
                {
                  sscanf((const char *)Line, "%d %d %s", &v67, &v73, &v77);
                  v2 = 7;
                  nodeId = 0;
                  goto LABEL_115;
                }
                switch ( v67 )
                {
                  case 2:
                    v36 = 1;
LABEL_111:
                    CFileLoader::LoadCarPathNode(Line, -1, nodeId, v36);
                    break;
                  case 1:
                    v36 = 0;
                    goto LABEL_111;
                  case 0:
                    CFileLoader::LoadPedPathNode(Line, -1, nodeId);
                    break;
                }
                v2 = 7;
                if ( nodeId == 11 )
                  v35 = -1;
                nodeId = v35;
LABEL_115:
                p_m_maxDelay = v34;
                p_m_minDelay = v33;
                p_m_lockedChance = v32;
                v1 = v65;
                break;
              case 8:
                CFileLoader::LoadGarage(Line);
                v2 = 8;
                break;
              case 9:
                CFileLoader::LoadEntryExit(Line);
                v2 = 9;
                break;
              case 10:
                CFileLoader::LoadPickup(Line);
                v2 = 10;
                break;
              case 11:
                if ( sscanf(
                       (const char *)Line,
                       "%f %f %f %f %d %d %d %d %d %d %d %d",
                       &v77,
                       &v77.m_y,
                       &v77.m_z,
                       &v77.m_r,
                       &v77.m_modelID,
                       &v77.m_col1,
                       &v77.m_col2,
                       &v77.m_flagVal,
                       &v77.m_alarmChance,
                       p_m_lockedChance,
                       p_m_minDelay,
                       p_m_maxDelay) == 12 )
                  CFileLoader::LoadCarGenerator(&v77, 0);
                goto LABEL_101;
              case 12:
                CFileLoader::LoadStuntJump(Line);
                v2 = 12;
                break;
              case 13:
                CFileLoader::LoadTimeCyclesModifier(Line);
                v2 = 13;
                break;
              case 14:
                CFileLoader::LoadAudioZone(Line);
                v2 = 14;
                break;
              default:
                break;
            }
          }
        }
        else
        {
          v2 = 0;
          switch ( *Line )
          {
            case 'c':
              if ( Line[1] != 117 )
                goto LABEL_15;
              v12 = Line[2];
              v13 = v12 == 108;
              if ( v12 == 108 )
                v13 = Line[3] == 108;
              if ( v13 )
              {
                v2 = 5;
              }
              else
              {
LABEL_15:
                v14 = Line[1];
                v15 = v14 == 97;
                if ( v14 == 97 )
                  v15 = Line[2] == 114;
                if ( v15 && Line[3] == 115 )
                {
LABEL_101:
                  v2 = 11;
                }
                else
                {
                  v2 = 0;
                  if ( v37 == 97 )
                  {
LABEL_21:
                    v16 = Line[1];
                    v17 = v16 == 117;
                    if ( v16 == 117 )
                      v17 = Line[2] == 122;
                    if ( v17 && Line[3] == 111 )
                      v2 = 14;
                  }
                  else
                  {
LABEL_70:
                    if ( v37 == 116 )
                    {
                      v30 = Line[1];
                      v31 = v30 == 99;
                      if ( v30 == 99 )
                        v31 = Line[2] == 121;
                      if ( v31 && Line[3] == 99 )
                        v2 = 13;
                    }
                    else if ( v37 == 106 )
                    {
                      v28 = Line[1];
                      v29 = v28 == 117;
                      if ( v28 == 117 )
                        v29 = Line[2] == 109;
                      if ( v29 && Line[3] == 112 )
                        v2 = 12;
                    }
                  }
                }
              }
              break;
            case 'i':
              if ( Line[1] != 110 || Line[2] != 115 )
                goto LABEL_41;
              v2 = 0;
              if ( Line[3] == 116 )
                v2 = 2;
              goto LABEL_42;
            case 'm':
              if ( Line[1] != 117 || Line[2] != 108 || Line[3] != 116 )
                goto LABEL_41;
              v2 = 3;
              break;
            case 'z':
              if ( Line[1] == 111 && Line[2] == 110 && Line[3] == 101 )
              {
LABEL_88:
                v2 = 4;
              }
              else
              {
LABEL_41:
                v2 = 0;
LABEL_42:
                switch ( *Line )
                {
                  case 'e':
                    if ( Line[1] != 110 )
                      goto LABEL_69;
                    v18 = Line[2];
                    v19 = v18 == 101;
                    if ( v18 == 101 )
                      v19 = Line[3] == 120;
                    if ( !v19 )
                      goto LABEL_69;
                    v2 = 9;
                    break;
                  case 'g':
                    if ( Line[1] != 114 )
                      goto LABEL_69;
                    v20 = Line[2];
                    v21 = v20 == 103;
                    if ( v20 == 103 )
                      v21 = Line[3] == 101;
                    if ( !v21 )
                      goto LABEL_69;
                    v2 = 8;
                    break;
                  case 'o':
                    if ( Line[1] != 99 )
                      goto LABEL_69;
                    v22 = Line[2];
                    v23 = v22 == 99;
                    if ( v22 == 99 )
                      v23 = Line[3] == 108;
                    if ( !v23 )
                      goto LABEL_69;
                    v2 = 6;
                    break;
                  case 'p':
                    if ( Line[1] != 97 )
                      goto LABEL_68;
                    v24 = Line[2];
                    v25 = v24 == 116;
                    if ( v24 == 116 )
                      v25 = Line[3] == 104;
                    if ( v25 )
                    {
                      v2 = 1;
                    }
                    else
                    {
LABEL_68:
                      if ( Line[1] != 105 )
                        goto LABEL_69;
                      v26 = Line[2];
                      v27 = v26 == 99;
                      if ( v26 == 99 )
                        v27 = Line[3] == 107;
                      if ( !v27 )
                        goto LABEL_69;
                      v2 = 10;
                    }
                    break;
                  default:
LABEL_69:
                    if ( v37 != 97 )
                      goto LABEL_70;
                    goto LABEL_21;
                }
              }
              break;
            default:
              goto LABEL_42;
          }
        }
      }
      Line = CFileLoader::LoadLine(v3);
    }
    while ( Line );
  }
LABEL_121:
  CFileMgr::CloseFile(v3);
  v39 = gNumLoadedBuildings;
  if ( gNumLoadedBuildings < 1 )
  {
    NewIplEntityIndexArray = -1;
    goto LABEL_131;
  }
  NewIplEntityIndexArray = CIplStore::GetNewIplEntityIndexArray(gNumLoadedBuildings);
  IplEntityIndexArray = CIplStore::GetIplEntityIndexArray(NewIplEntityIndexArray);
  v39 = gNumLoadedBuildings;
  if ( gNumLoadedBuildings < 1 )
    goto LABEL_131;
  if ( (unsigned int)gNumLoadedBuildings < 4
    || (v42 = gNumLoadedBuildings & 0xFFFFFFFC, (gNumLoadedBuildings & 0xFFFFFFFC) == 0)
    || IplEntityIndexArray < &gpLoadedBuildings[gNumLoadedBuildings]
    && &IplEntityIndexArray[gNumLoadedBuildings] > gpLoadedBuildings )
  {
    v42 = 0;
    do
    {
LABEL_128:
      IplEntityIndexArray[v42] = gpLoadedBuildings[v42];
      ++v42;
    }
    while ( v42 < v39 );
    goto LABEL_131;
  }
  v60 = gNumLoadedBuildings & 0xFFFFFFFC;
  v61 = IplEntityIndexArray;
  v62 = gpLoadedBuildings;
  do
  {
    v63 = *(_QWORD *)v62;
    v64 = *((_QWORD *)v62 + 1);
    v62 += 4;
    v60 -= 4;
    *(_QWORD *)v61 = v63;
    *((_QWORD *)v61 + 1) = v64;
    v61 += 4;
  }
  while ( v60 );
  if ( v39 != v42 )
    goto LABEL_128;
LABEL_131:
  v43 = CIplStore::SetupRelatedIpls(v1, NewIplEntityIndexArray, &gpLoadedBuildings[v39]);
  v44 = gNumLoadedBuildings;
  if ( gNumLoadedBuildings >= 1 )
  {
    v45 = gNumLoadedBuildings;
    v46 = gpLoadedBuildings;
    do
    {
      v47 = *v46;
      m_pLod = (*v46)->m_pLod;
      if ( m_pLod == (CEntity *)-1 )
      {
        v47->m_pLod = 0;
      }
      else
      {
        v49 = gpLoadedBuildings[(_DWORD)m_pLod];
        v47->m_pLod = v49;
        ++v49->numLodChildren;
      }
      ++v46;
      --v45;
    }
    while ( v45 );
  }
  if ( v44 + v43 )
  {
    v50 = 0;
    do
    {
      isCacheLoading = CColAccel::isCacheLoading();
      if ( v50 < gNumLoadedBuildings || !isCacheLoading )
      {
        if ( v50 >= gNumLoadedBuildings )
          CColAccel::addIPLEntity(gpLoadedBuildings, gNumLoadedBuildings, v50);
        v52 = gpLoadedBuildings[v50];
        if ( v52->numLodChildren
          || (float)(CModelInfo::ms_modelInfoPtrs[v52->m_nModelIndex]->m_lodDistance * TheCamera.LODDistMultiplier) > 300.0 )
        {
          CEntity::SetupBigBuilding(gpLoadedBuildings[v50]);
        }
        v53 = v52->m_pLod;
        if ( v53 )
        {
          numLodChildren = v53->numLodChildren;
          v55 = CModelInfo::ms_modelInfoPtrs[v52->m_nModelIndex];
          if ( numLodChildren == 1 )
          {
            v56 = CModelInfo::ms_modelInfoPtrs[v53->m_nModelIndex];
            if ( (*((_BYTE *)&v52->m_nFlags + 2) & 0x10) != 0 )
              *(_DWORD *)&v53->m_nFlags |= 0x100000u;
            m_pColModel = v55->m_pColModel;
            if ( m_pColModel )
            {
              v58 = v56->m_pColModel;
              if ( !v58 || v58 != m_pColModel )
              {
                CBaseModelInfo::DeleteCollisionModel(v56);
                CBaseModelInfo::SetColModel(v56, v55->m_pColModel, 0);
              }
            }
          }
          else if ( (v55->m_flags & 0x20) != 0 )
          {
            v55->m_lodDistance = 400.0;
          }
          else
          {
            v53->numLodChildren = numLodChildren - 1;
            v52->m_pLod = 0;
          }
        }
      }
      v44 = gNumLoadedBuildings;
      ++v50;
    }
    while ( v50 < (unsigned int)(gNumLoadedBuildings + v43) );
  }
  CColAccel::cacheIPLSection(gpLoadedBuildings, v44);
  if ( gNumLoadedBuildings >= 1 )
  {
    v59 = 0;
    do
      CWorld::Add(gpLoadedBuildings[v59++]);
    while ( v59 < gNumLoadedBuildings );
  }
  CIplStore::RemoveRelatedIpls(NewIplEntityIndexArray);
}
// 469334: using guessed type int dword_469334;
// 468CDC: using guessed type CFileCarGenerator var_80;
// 468CDC: using guessed type float var_98;
// 468CDC: using guessed type Char var_8A[10];

//----- (004693A8) --------------------------------------------------------
void __fastcall CFileLoader::SaveTexDictionary(RwTexDictionary_0 *pTxd, const unsigned __int8 *pFilename)
{
  RwStream_0 *v3; // r5

  v3 = RwStreamOpen(rwSTREAMFILENAME, rwSTREAMWRITE, pFilename);
  if ( v3 )
  {
    RwTexDictionaryStreamWrite(pTxd, v3);
    sub_1962A8(v3, 0);
  }
}

//----- (004693D4) --------------------------------------------------------
RwTexture_0 *__fastcall MoveTexturesCB(RwTexture_0 *pTexture, void *pData)
{
  RwTexDictionaryAddTexture((RwTexDictionary_0 *)pData, pTexture);
  return pTexture;
}

//----- (004693E8) --------------------------------------------------------
RpAtomic_0 *__fastcall CFileLoader::FindRelatedModelInfoCB(RpAtomic_0 *pAtomic, void *data)
{
  const unsigned __int8 *FrameNodeName; // r0
  CBaseModelInfo *ModelInfo; // r0
  int v6; // r6
  CDamageAtomicModelInfo *v7; // r0
  RwFrame_0 *v8; // r0
  bool bIsDamageModel; // [sp+7h] [bp-31h] BYREF
  int32 pIndex; // [sp+8h] [bp-30h] BYREF
  unsigned __int8 pObjName[8]; // [sp+Fh] [bp-29h] BYREF

  FrameNodeName = GetFrameNodeName((RwFrame_0 *)pAtomic->object.object.parent);
  GetNameAndDamage(FrameNodeName, pObjName, &bIsDamageModel);
  ModelInfo = CModelInfo::GetModelInfo(pObjName, &pIndex);
  if ( ModelInfo )
  {
    v6 = (*((int (__fastcall **)(CBaseModelInfo *))ModelInfo->_vptr$CBaseModelInfo + 2))(ModelInfo);
    CVisibilityPlugins::SetAtomicRenderCallback(pAtomic, 0);
    if ( bIsDamageModel )
    {
      v7 = (CDamageAtomicModelInfo *)(*(int (__fastcall **)(int))(*(_DWORD *)v6 + 12))(v6);
      CDamageAtomicModelInfo::SetDamagedAtomic(v7, pAtomic);
    }
    else
    {
      (*(void (__fastcall **)(int, RpAtomic_0 *))(*(_DWORD *)v6 + 64))(v6, pAtomic);
    }
    RpClumpRemoveAtomic((RpClump_0 *)data, pAtomic);
    v8 = RwFrameCreate();
    RpAtomicSetFrame(pAtomic, v8);
    CVisibilityPlugins::SetModelInfoIndex(pAtomic, pIndex);
  }
  return pAtomic;
}

//----- (00469490) --------------------------------------------------------
int32 __fastcall CFileLoader::LoadObject(const unsigned __int8 *pLine)
{
  CDamageAtomicModelInfo *v3; // r0
  CAtomicModelInfo *v4; // r4
  const unsigned __int8 *ModelCDName; // r0
  char v6; // [sp+18h] [bp-60h] BYREF
  char v7; // [sp+1Ch] [bp-5Ch] BYREF
  int v8; // [sp+20h] [bp-58h] BYREF
  uint32 v9; // [sp+24h] [bp-54h] BYREF
  float v10; // [sp+28h] [bp-50h] BYREF
  int32 index; // [sp+2Ch] [bp-4Ch] BYREF
  unsigned __int8 pName[8]; // [sp+32h] [bp-46h] BYREF
  unsigned __int8 txdName[21]; // [sp+3Ah] [bp-3Eh] BYREF

  if ( sscanf((const char *)pLine, "%d %s %s %f %d", &index, &txdName[13], pName, &v10, &v9) != 5 || v10 < 4.0 )
  {
    if ( sscanf((const char *)pLine, "%d %s %s %d", &index, &txdName[13], pName, &v8) != 4 )
      return -1;
    switch ( v8 )
    {
      case 3:
        sscanf((const char *)pLine, "%d %s %s %d %f %f %f %d", &index, &txdName[13], pName, &v8, &v10, &v6, &v7, &v9);
        break;
      case 2:
        sscanf((const char *)pLine, "%d %s %s %d %f %f %d", &index, &txdName[13], pName, &v8, &v10, &v6, &v9);
        break;
      case 1:
        sscanf((const char *)pLine, "%d %s %s %d %f %d", &index, &txdName[13], pName, &v8, &v10, &v9);
        break;
    }
  }
  if ( (v9 & 0x1000) != 0 )
    v3 = CModelInfo::AddDamageAtomicModel(index);
  else
    v3 = (CDamageAtomicModelInfo *)CModelInfo::AddAtomicModel(index);
  v4 = v3;
  v3->m_lodDistance = v10;
  v3->m_hashKey = CKeyGen::GetUppercaseKey(&txdName[13]);
  strcpy((char *)v4->m_modelName, (const char *)&txdName[13]);
  ModelCDName = CStreaming::GetModelCDName(index);
  CBaseModelInfo::SetTexDictionary(v4, pName, ModelCDName);
  SetAtomicModelInfoFlags(v4, v9);
  return index;
}
// 469490: using guessed type unsigned __int8 pName[8];

//----- (0046960C) --------------------------------------------------------
int32 __fastcall CFileLoader::LoadTimeObject(const unsigned __int8 *pLine)
{
  CTimeModelInfo *v3; // r4
  CTimeInfo *v4; // r5
  const unsigned __int8 *ModelCDName; // r0
  char v6; // r0
  CTimeInfo *OtherTimeModel; // r0
  char v8; // [sp+24h] [bp-6Ch] BYREF
  char v9; // [sp+28h] [bp-68h] BYREF
  int v10; // [sp+2Ch] [bp-64h] BYREF
  uint8 v11; // [sp+30h] [bp-60h] BYREF
  char v12; // [sp+34h] [bp-5Ch] BYREF
  uint32 v13; // [sp+38h] [bp-58h] BYREF
  float v14; // [sp+3Ch] [bp-54h] BYREF
  int32 index; // [sp+40h] [bp-50h] BYREF
  unsigned __int8 pName[8]; // [sp+46h] [bp-4Ah] BYREF
  unsigned __int8 txdName[21]; // [sp+4Eh] [bp-42h] BYREF

  if ( sscanf((const char *)pLine, "%d %s %s %f %d %d %d", &index, &txdName[13], pName, &v14, &v13, &v12, &v11) != 7
    || v14 < 4.0 )
  {
    if ( sscanf((const char *)pLine, "%d %s %s %d", &index, &txdName[13], pName, &v10) != 4 )
      return -1;
    switch ( v10 )
    {
      case 3:
        sscanf(
          (const char *)pLine,
          "%d %s %s %d %f %f %f %d %d %d",
          &index,
          &txdName[13],
          pName,
          &v10,
          &v14,
          &v8,
          &v9,
          &v13,
          &v12,
          &v11);
        break;
      case 2:
        sscanf(
          (const char *)pLine,
          "%d %s %s %d %f %f %d %d %d",
          &index,
          &txdName[13],
          pName,
          &v10,
          &v14,
          &v8,
          &v13,
          &v12,
          &v11);
        break;
      case 1:
        sscanf(
          (const char *)pLine,
          "%d %s %s %d %f %d %d %d",
          &index,
          &txdName[13],
          pName,
          &v10,
          &v14,
          &v13,
          &v12,
          &v11);
        break;
    }
  }
  v3 = CModelInfo::AddTimeModel(index);
  v4 = (CTimeInfo *)(*((int (__fastcall **)(CTimeModelInfo *))v3->_vptr$CBaseModelInfo + 6))(v3);
  v3->m_lodDistance = v14;
  v3->m_hashKey = CKeyGen::GetUppercaseKey(&txdName[13]);
  strcpy((char *)v3->m_modelName, (const char *)&txdName[13]);
  ModelCDName = CStreaming::GetModelCDName(index);
  CBaseModelInfo::SetTexDictionary(v3, pName, ModelCDName);
  v6 = v12;
  v4->m_off = v11;
  v4->m_on = v6;
  SetAtomicModelInfoFlags(v3, v13);
  OtherTimeModel = CTimeInfo::FindOtherTimeModel(v4, &txdName[13]);
  if ( OtherTimeModel )
    OtherTimeModel->m_otherModel = index;
  return index;
}
// 46960C: using guessed type unsigned __int8 pName[8];

//----- (004697CC) --------------------------------------------------------
int32 __fastcall CFileLoader::LoadWeaponObject(const unsigned __int8 *pLine)
{
  CWeaponModelInfo *v1; // r6
  const unsigned __int8 *ModelCDName; // r0
  float v4; // [sp+14h] [bp-5Ch] BYREF
  char v5; // [sp+18h] [bp-58h] BYREF
  int32 v6; // [sp+1Ch] [bp-54h] BYREF
  char v7[8]; // [sp+22h] [bp-4Eh] BYREF
  unsigned __int8 animFileName[16]; // [sp+2Ah] [bp-46h] BYREF
  unsigned __int8 txdName[21]; // [sp+3Ah] [bp-36h] BYREF

  sscanf((const char *)pLine, "%d %s %s %s %d %f", &v6, &txdName[13], &animFileName[8], v7, &v5, &v4);
  v1 = CModelInfo::AddWeaponModel(v6);
  v1->m_hashKey = CKeyGen::GetUppercaseKey(&txdName[13]);
  strcpy((char *)v1->m_modelName, (const char *)&txdName[13]);
  v1->m_lodDistance = v4;
  ModelCDName = CStreaming::GetModelCDName(v6);
  CBaseModelInfo::SetTexDictionary(v1, &animFileName[8], ModelCDName);
  (*((void (__fastcall **)(CWeaponModelInfo *, char *))v1->_vptr$CBaseModelInfo + 13))(v1, v7);
  CBaseModelInfo::SetColModel(v1, &CTempColModels::ms_colModelWeapon, 0);
  return v6;
}
// 4697CC: using guessed type char var_4E[8];

//----- (00469884) --------------------------------------------------------
int32 __fastcall CFileLoader::LoadClumpObject(const unsigned __int8 *pLine)
{
  int32 v1; // r4
  CClumpModelInfo *v2; // r4
  const unsigned __int8 *ModelCDName; // r0
  int32 index; // [sp+8h] [bp-40h] BYREF
  unsigned __int8 pName[24]; // [sp+Ch] [bp-3Ch] BYREF
  unsigned __int8 pString[24]; // [sp+24h] [bp-24h] BYREF

  v1 = -1;
  index = -1;
  if ( sscanf((const char *)pLine, "%d %s %s", &index, pString, pName) == 3 )
  {
    v2 = CModelInfo::AddClumpModel(index);
    v2->m_hashKey = CKeyGen::GetUppercaseKey(pString);
    strcpy((char *)v2->m_modelName, (const char *)pString);
    ModelCDName = CStreaming::GetModelCDName(index);
    CBaseModelInfo::SetTexDictionary(v2, pName, ModelCDName);
    CBaseModelInfo::SetColModel(v2, &CTempColModels::ms_colModelBBox, 0);
    return index;
  }
  return v1;
}
// 469884: using guessed type unsigned __int8 pName[24];

//----- (00469918) --------------------------------------------------------
int32 __fastcall CFileLoader::LoadAnimatedClumpObject(const unsigned __int8 *pLine)
{
  int32 v1; // r4
  CClumpModelInfo *v2; // r4
  const unsigned __int8 *ModelCDName; // r0
  int (**v4)(void); // r0
  uint16 m_flags; // r0
  __int16 v6; // r2
  __int16 v7; // r0
  __int16 v8; // r2
  __int16 v9; // r0
  __int16 v10; // r2
  uint16 v11; // r6
  int v13; // [sp+14h] [bp-64h] BYREF
  int v14; // [sp+18h] [bp-60h] BYREF
  int32 index; // [sp+1Ch] [bp-5Ch] BYREF
  _QWORD v16[2]; // [sp+20h] [bp-58h] BYREF
  unsigned __int8 pName[24]; // [sp+34h] [bp-44h] BYREF
  unsigned __int8 pString[24]; // [sp+4Ch] [bp-2Ch] BYREF

  v1 = -1;
  v14 = 1157234688;
  index = -1;
  v16[0] = *(_QWORD *)"null";
  v16[1] = 0LL;
  if ( sscanf((const char *)pLine, "%d %s %s %s %f %d", &index, pString, pName, v16, &v14, &v13) == 6 )
  {
    v2 = CModelInfo::AddClumpModel(index);
    v2->m_hashKey = CKeyGen::GetUppercaseKey(pString);
    strcpy((char *)v2->m_modelName, (const char *)pString);
    ModelCDName = CStreaming::GetModelCDName(index);
    CBaseModelInfo::SetTexDictionary(v2, pName, ModelCDName);
    v4 = v2->_vptr$CBaseModelInfo;
    LODWORD(v2->m_lodDistance) = v14;
    ((void (__fastcall *)(CClumpModelInfo *, _QWORD *))v4[13])(v2, v16);
    m_flags = v2->m_flags;
    v6 = m_flags & 0xFFFD;
    if ( (v13 & 0xC) != 0 )
      v6 = m_flags | 2;
    v7 = v6 & 0xFFFB;
    if ( (v13 & 8) != 0 )
      v7 = v6 | 4;
    v8 = v7 & 0xFFF7;
    if ( (v13 & 0x40) != 0 )
      v8 = v7 | 8;
    v9 = v8 & 0xFFEF;
    if ( (v13 & 0x80) != 0 )
      v9 = v8 | 0x10;
    v10 = v9 & 0xFFBF;
    if ( (v13 & 0x200000) == 0 )
      v10 = v9 | 0x40;
    v11 = v10 & 0xFBFF;
    if ( (v13 & 0x20) != 0 )
      v11 = v10 | 0x400;
    v2->m_flags = v11;
    if ( strcmp((const char *)v16, "null") )
      v2->m_flags = v11 | 0x100;
    return index;
  }
  return v1;
}
// 469918: using guessed type unsigned __int8 pName[24];

//----- (00469A5C) --------------------------------------------------------
int32 __fastcall CFileLoader::LoadVehicleObject(const unsigned __int8 *pLine)
{
  int32 TxdSlot; // r0
  __int16 v3; // r5
  CVehicleModelInfo *v4; // r4
  const unsigned __int8 *ModelCDName; // r0
  _BYTE *i; // r0
  int v7; // r0
  int v8; // r2
  int v9; // r0
  int v10; // r0
  int v11; // r2
  int v12; // r0
  int v13; // r2
  int v14; // r0
  int v15; // r2
  int v16; // r0
  int v17; // r2
  int v18; // r0
  int v19; // r2
  float v20; // s0
  int v21; // r0
  int v22; // r0
  char v23; // r0
  uint32 v25; // [sp+34h] [bp-C4h] BYREF
  int v26; // [sp+38h] [bp-C0h] BYREF
  int v27; // [sp+3Ch] [bp-BCh] BYREF
  int v28; // [sp+40h] [bp-B8h] BYREF
  int v29; // [sp+44h] [bp-B4h] BYREF
  float v30; // [sp+48h] [bp-B0h] BYREF
  int v31; // [sp+4Ch] [bp-ACh] BYREF
  int32 index; // [sp+50h] [bp-A8h] BYREF
  char v33[16]; // [sp+54h] [bp-A4h] BYREF
  char v34; // [sp+64h] [bp-94h] BYREF
  _BYTE v35[3]; // [sp+65h] [bp-93h] BYREF
  char v36[16]; // [sp+84h] [bp-74h] BYREF
  unsigned __int8 pName[16]; // [sp+94h] [bp-64h] BYREF
  char v38[8]; // [sp+A4h] [bp-54h] BYREF
  unsigned __int8 v39[24]; // [sp+ACh] [bp-4Ch] BYREF
  unsigned __int8 v40[24]; // [sp+C4h] [bp-34h] BYREF

  v31 = 0;
  index = -1;
  v30 = 1.0;
  v28 = -1;
  v29 = 1065353216;
  TxdSlot = CTxdStore::FindTxdSlot("vehicle");
  v3 = TxdSlot;
  if ( TxdSlot == -1 )
    v3 = CTxdStore::AddTxdSlot("vehicle", (const unsigned __int8 *)&off_469DC8, 1);
  sscanf(
    (const char *)pLine,
    "%d %s %s %s %s %s %s %s %d %d %x %d %f %f %d",
    &index,
    v40,
    v39,
    v38,
    pName,
    &v34,
    v36,
    v33,
    &v27,
    &v26,
    &v25,
    &v31,
    &v30,
    &v29,
    &v28);
  v4 = CModelInfo::AddVehicleModel(index);
  v4->m_hashKey = CKeyGen::GetUppercaseKey(v40);
  strcpy((char *)v4->m_modelName, (const char *)v40);
  ModelCDName = CStreaming::GetModelCDName(index);
  CBaseModelInfo::SetTexDictionary(v4, v39, ModelCDName);
  *(_WORD *)&CTxdStore::ms_pTxdPool->m_aStorage[v4->m_txdIndex][6] = v3;
  (*((void (__fastcall **)(CVehicleModelInfo *, char *))v4->_vptr$CBaseModelInfo + 13))(v4, v36);
  if ( v34 )
  {
    for ( i = v35; ; ++i )
    {
      if ( *i == 95 )
      {
        *i = 32;
      }
      else if ( !*i )
      {
        break;
      }
    }
  }
  strncpy((char *)v4->m_gameName, &v34, 8u);
  v4->m_flags = v26;
  v4->m_compRules = v25;
  if ( !strcmp(v38, (const char *)&dword_469E00) )
  {
    v10 = v29;
    v11 = LODWORD(v30);
    v4->m_wheelId = v31;
    LODWORD(v4->m_wheelScale) = v11;
    LODWORD(v4->m_wheelScaleRear) = v10;
    v9 = 0;
    goto LABEL_35;
  }
  if ( !strcmp(v38, "mtruck") )
  {
    v12 = v29;
    v13 = LODWORD(v30);
    v4->m_wheelId = v31;
    LODWORD(v4->m_wheelScale) = v13;
    LODWORD(v4->m_wheelScaleRear) = v12;
    v9 = 1;
    goto LABEL_35;
  }
  if ( !strcmp(v38, "quad") )
  {
    v14 = v29;
    v15 = LODWORD(v30);
    v4->m_wheelId = v31;
    LODWORD(v4->m_wheelScale) = v15;
    LODWORD(v4->m_wheelScaleRear) = v14;
    v9 = 2;
    goto LABEL_35;
  }
  if ( !strcmp(v38, "heli") )
  {
    v16 = v29;
    v17 = LODWORD(v30);
    v4->m_wheelId = v31;
    LODWORD(v4->m_wheelScale) = v17;
    LODWORD(v4->m_wheelScaleRear) = v16;
    v9 = 3;
    goto LABEL_35;
  }
  if ( !strcmp(v38, "plane") )
  {
    v18 = v29;
    v19 = LODWORD(v30);
    v4->m_wheelId = v31;
    LODWORD(v4->m_wheelScale) = v19;
    LODWORD(v4->m_wheelScaleRear) = v18;
    v9 = 4;
    goto LABEL_35;
  }
  if ( !strcmp(v38, "boat") )
  {
    v9 = 5;
    goto LABEL_35;
  }
  if ( !strcmp(v38, "train") )
  {
    v9 = 6;
    goto LABEL_35;
  }
  if ( !strcmp(v38, "f_heli") )
  {
    v9 = 3;
    goto LABEL_35;
  }
  if ( !strcmp(v38, "f_plane") )
  {
    v4->m_wheelId = v31;
    v9 = 8;
    v4->m_wheelScale = 1.0;
    v4->m_wheelScaleRear = 1.0;
    goto LABEL_35;
  }
  if ( !strcmp(v38, "bike") )
  {
    v20 = (float)v31;
    v21 = v29;
    v4->m_wheelScale = v30;
    LODWORD(v4->m_wheelScaleRear) = v21;
    v9 = 9;
LABEL_34:
    v4->m_steerAngle = v20;
    goto LABEL_35;
  }
  if ( !strcmp(v38, "bmx") )
  {
    v20 = (float)v31;
    v22 = v29;
    v4->m_wheelScale = v30;
    LODWORD(v4->m_wheelScaleRear) = v22;
    v9 = 10;
    goto LABEL_34;
  }
  if ( strcmp(v38, "trailer") )
    goto LABEL_36;
  v7 = v29;
  v8 = LODWORD(v30);
  v4->m_wheelId = v31;
  LODWORD(v4->m_wheelScale) = v8;
  LODWORD(v4->m_wheelScaleRear) = v7;
  v9 = 11;
LABEL_35:
  v4->m_vehicleType = v9;
LABEL_36:
  v4->m_handlingId = cHandlingDataMgr::GetHandlingId(&mod_HandlingManager, pName);
  v4->m_wheelUpgradeClass = v28;
  if ( !strcmp(v33, "normal") )
  {
    v23 = 0;
LABEL_62:
    v4->m_inList = v23;
    goto LABEL_63;
  }
  if ( !strcmp(v33, "poorfamily") )
  {
    v23 = 1;
    goto LABEL_62;
  }
  if ( !strcmp(v33, "richfamily") )
  {
    v23 = 2;
    goto LABEL_62;
  }
  if ( !strcmp(v33, "executive") )
  {
    v23 = 3;
    goto LABEL_62;
  }
  if ( !strcmp(v33, "worker") )
  {
    v23 = 4;
    goto LABEL_62;
  }
  if ( !strcmp(v33, "big") )
  {
    v23 = 5;
    goto LABEL_62;
  }
  if ( !strcmp(v33, "taxi") )
  {
    v23 = 6;
    goto LABEL_62;
  }
  if ( !strcmp(v33, "moped") )
  {
    v23 = 7;
    goto LABEL_62;
  }
  if ( !strcmp(v33, "motorbike") )
  {
    v23 = 8;
    goto LABEL_62;
  }
  if ( !strcmp(v33, "leisureboat") )
  {
    v23 = 9;
    goto LABEL_62;
  }
  if ( !strcmp(v33, "workerboat") )
  {
    v23 = 10;
    goto LABEL_62;
  }
  if ( !strcmp(v33, "bicycle") )
  {
    v23 = 11;
    goto LABEL_62;
  }
  if ( strcmp(v33, "ignore") )
  {
LABEL_63:
    v4->m_freq = v27;
    return index;
  }
  v4->m_inList = -1;
  return index;
}
// 469DC8: using guessed type void *off_469DC8;
// 469E00: using guessed type int dword_469E00;
// 469A5C: using guessed type unsigned __int8 var_4C[24];
// 469A5C: using guessed type unsigned __int8 pName[16];
// 469A5C: using guessed type char var_74[16];

//----- (00469EBC) --------------------------------------------------------
int32 __fastcall CFileLoader::LoadPedObject(const unsigned __int8 *pLine)
{
  CPedModelInfo *v1; // r8
  const unsigned __int8 *ModelCDName; // r0
  AssocGroupId v3; // r5
  const unsigned __int8 *AnimGroupName; // r0
  char v5; // r1
  unsigned __int8 v6; // r0
  int v7; // r3
  char v8; // r0
  char v9; // r2
  unsigned __int8 v10; // r0
  int v11; // r1
  Int16 AudioPedType; // r5
  Int16 Voice; // r0
  Int16 m_FirstVoice; // r1
  int32 v16; // [sp+34h] [bp-14Ch]
  char v17; // [sp+38h] [bp-148h] BYREF
  char v18; // [sp+3Ch] [bp-144h] BYREF
  int v19; // [sp+40h] [bp-140h] BYREF
  int v20; // [sp+44h] [bp-13Ch] BYREF
  int32 index; // [sp+48h] [bp-138h] BYREF
  unsigned __int8 v22[60]; // [sp+4Ch] [bp-134h] BYREF
  unsigned __int8 v23[60]; // [sp+88h] [bp-F8h] BYREF
  unsigned __int8 pString[20]; // [sp+C4h] [bp-BCh] BYREF
  unsigned __int8 v25[24]; // [sp+D8h] [bp-A8h] BYREF
  unsigned __int8 v26[24]; // [sp+F0h] [bp-90h] BYREF
  char v27[16]; // [sp+108h] [bp-78h] BYREF
  char v28[24]; // [sp+118h] [bp-68h] BYREF
  unsigned __int8 v29[24]; // [sp+130h] [bp-50h] BYREF
  unsigned __int8 v30; // [sp+148h] [bp-38h] BYREF
  unsigned __int8 v31; // [sp+149h] [bp-37h]

  index = -1;
  v16 = CAnimManager::ms_numAnimAssocDefinitions;
  sscanf(
    (const char *)pLine,
    "%d %s %s %s %s %s %x %x %s %d %d %s %s %s",
    &index,
    &v30,
    v29,
    v26,
    v25,
    v28,
    &v20,
    &v19,
    v27,
    &v18,
    &v17,
    pString,
    v23,
    v22);
  v1 = CModelInfo::AddPedModel(index);
  v1->m_hashKey = CKeyGen::GetUppercaseKey(&v30);
  strcpy((char *)v1->m_modelName, (const char *)&v30);
  ModelCDName = CStreaming::GetModelCDName(index);
  CBaseModelInfo::SetTexDictionary(v1, v29, ModelCDName);
  (*((void (__fastcall **)(CPedModelInfo *, char *))v1->_vptr$CBaseModelInfo + 13))(v1, v27);
  CBaseModelInfo::SetColModel(v1, &CTempColModels::ms_colModelPed1, 0);
  v1->m_defaultPedType = CPedType::FindPedType(v26);
  v1->m_defaultPedStats = CPedStats::GetPedStatType(v25);
  if ( CAnimManager::ms_numAnimAssocDefinitions < 1 )
  {
LABEL_5:
    v3 = v16;
  }
  else
  {
    v3 = ANIM_STD_PED;
    while ( 1 )
    {
      AnimGroupName = CAnimManager::GetAnimGroupName(v3);
      if ( !strcmp(v28, (const char *)AnimGroupName) )
        break;
      if ( ++v3 >= CAnimManager::ms_numAnimAssocDefinitions )
        goto LABEL_5;
    }
  }
  v1->m_motionAnimGroup = v3;
  v1->m_drivesWhichCars = v20;
  v1->m_flags = v19;
  v5 = v18;
  v1->m_radio2 = v17 + 1;
  v1->m_radio1 = v5 + 1;
  v6 = v30;
  if ( (unsigned __int8)(v30 - 97) < 0x1Au )
    v6 = v30 - 32;
  v7 = v6 - 66;
  v8 = 3;
  v9 = 1;
  switch ( v7 )
  {
    case 0:
LABEL_9:
      v8 = v9;
      break;
    case 6:
LABEL_13:
      v8 = 4;
      break;
    case 7:
    case 13:
      break;
    case 21:
LABEL_14:
      v8 = 2;
      break;
    default:
      v10 = v31;
      if ( (unsigned __int8)(v31 - 97) < 0x1Au )
        v10 = v31 - 32;
      v11 = v10 - 66;
      v8 = 3;
      v9 = 1;
      switch ( v11 )
      {
        case 0:
          goto LABEL_9;
        case 6:
          goto LABEL_13;
        case 7:
        case 13:
          goto LABEL_15;
        case 21:
          goto LABEL_14;
        default:
          v9 = 0;
          goto LABEL_9;
      }
  }
LABEL_15:
  v1->m_Race = v8;
  AudioPedType = CAEPedSpeechAudioEntity::GetAudioPedType(pString);
  v1->m_AudioPedType = AudioPedType;
  v1->m_FirstVoice = CAEPedSpeechAudioEntity::GetVoice(v23, AudioPedType);
  Voice = CAEPedSpeechAudioEntity::GetVoice(v22, AudioPedType);
  m_FirstVoice = v1->m_FirstVoice;
  v1->m_LastVoice = Voice;
  v1->m_NextVoice = m_FirstVoice;
  return index;
}
// 469EBC: using guessed type unsigned __int8 pString[20];
// 469EBC: using guessed type char var_68[24];
// 469EBC: using guessed type unsigned __int8 var_90[24];
// 469EBC: using guessed type unsigned __int8 var_A8[24];
// 469EBC: using guessed type unsigned __int8 var_F8[60];
// 469EBC: using guessed type char var_78[16];
// 469EBC: using guessed type unsigned __int8 var_134[60];
// 469EBC: using guessed type unsigned __int8 var_50[24];

//----- (0046A0D8) --------------------------------------------------------
int32 __fastcall CFileLoader::LoadPathHeader(const unsigned __int8 *pLine, int32 *type)
{
  int32 v3; // [sp+8h] [bp-60h] BYREF
  char v4; // [sp+Ch] [bp-5Ch] BYREF

  sscanf((const char *)pLine, "%d %d %s", type, &v3, &v4);
  return v3;
}

//----- (0046A0F8) --------------------------------------------------------
void __fastcall CFileLoader::LoadPedPathNode(const unsigned __int8 *pLine, int32 pathId, int32 nodeId)
{
  UInt8 bDontWanderHere; // r2
  char v6; // r1
  float v7; // [sp+30h] [bp-50h] BYREF
  float v8; // [sp+34h] [bp-4Ch] BYREF
  float v9; // [sp+38h] [bp-48h] BYREF
  float v10; // [sp+3Ch] [bp-44h] BYREF
  float v11; // [sp+40h] [bp-40h] BYREF
  UInt8 ArgSpecialFunction[4]; // [sp+44h] [bp-3Ch] BYREF
  int v13; // [sp+48h] [bp-38h] BYREF
  char v14; // [sp+4Ch] [bp-34h] BYREF
  char v15; // [sp+50h] [bp-30h] BYREF
  char v16; // [sp+54h] [bp-2Ch] BYREF
  int v17; // [sp+58h] [bp-28h] BYREF
  Int8 v18[4]; // [sp+5Ch] [bp-24h] BYREF
  Int8 TypeOfNode; // [sp+60h] [bp-20h] BYREF

  v7 = 1.0;
  *(_DWORD *)ArgSpecialFunction = 0;
  sscanf(
    (const char *)pLine,
    "%d %d %d %f %f %f %f %d %d %d %d %f %d",
    &TypeOfNode,
    v18,
    &v17,
    &v11,
    &v10,
    &v9,
    &v8,
    &v16,
    &v15,
    &v14,
    &v13,
    &v7,
    ArgSpecialFunction);
  if ( pathId == -1 )
  {
    v6 = v17;
    if ( v17 )
      v6 = 1;
    CPathFind::StoreDetachedNodeInfoPed(
      &ThePaths,
      nodeId,
      TypeOfNode,
      *(Int32 *)v18,
      (float)(int)v11,
      (float)(int)v10,
      (float)(int)v9,
      v8,
      v6,
      v13 & 1,
      (v13 & 4) != 0,
      (unsigned int)(float)(v7 * 15.0),
      (v13 & 0x800) != 0,
      ArgSpecialFunction[0],
      0);
  }
  else
  {
    bDontWanderHere = ArgSpecialFunction[0];
    if ( *(_DWORD *)ArgSpecialFunction )
      bDontWanderHere = 1;
    CPathFind::StoreNodeInfoPed(
      &ThePaths,
      pathId,
      nodeId,
      TypeOfNode,
      v18[0],
      (int)v11,
      (int)v10,
      (int)v9,
      v8,
      v17 != 0,
      (unsigned int)(float)(v7 * 15.0),
      bDontWanderHere,
      0);
  }
}

//----- (0046A274) --------------------------------------------------------
void __fastcall CFileLoader::LoadCarPathNode(const unsigned __int8 *pLine, int32 pathId, int32 nodeId, bool bOnWater)
{
  float v7; // [sp+40h] [bp-50h] BYREF
  float v8; // [sp+44h] [bp-4Ch] BYREF
  float v9; // [sp+48h] [bp-48h] BYREF
  float v10; // [sp+4Ch] [bp-44h] BYREF
  float v11; // [sp+50h] [bp-40h] BYREF
  UInt8 SpecialFunction[4]; // [sp+54h] [bp-3Ch] BYREF
  int v13; // [sp+58h] [bp-38h] BYREF
  UInt8 Speed; // [sp+5Ch] [bp-34h] BYREF
  Int8 v15; // [sp+60h] [bp-30h] BYREF
  Int8 LanesIn; // [sp+64h] [bp-2Ch] BYREF
  char v17; // [sp+68h] [bp-28h] BYREF
  Int8 v18[4]; // [sp+6Ch] [bp-24h] BYREF
  Int8 TypeOfNode; // [sp+70h] [bp-20h] BYREF

  v7 = 1.0;
  *(_DWORD *)SpecialFunction = 0;
  sscanf(
    (const char *)pLine,
    "%d %d %d %f %f %f %f %d %d %d %d %f %d",
    &TypeOfNode,
    v18,
    &v17,
    &v11,
    &v10,
    &v9,
    &v8,
    &LanesIn,
    &v15,
    &Speed,
    &v13,
    &v7,
    SpecialFunction);
  if ( pathId == -1 )
    CPathFind::StoreDetachedNodeInfoCar(
      &ThePaths,
      nodeId,
      TypeOfNode,
      *(Int32 *)v18,
      (float)(int)v11,
      (float)(int)v10,
      (float)(int)v9,
      v8,
      LanesIn,
      v15,
      v13 & 1,
      (v13 & 4) != 0,
      Speed,
      (v13 & 2) != 0,
      bOnWater,
      (unsigned int)(float)(v7 * 15.0),
      0,
      SpecialFunction[0]);
  else
    CPathFind::StoreNodeInfoCar(
      &ThePaths,
      pathId,
      nodeId,
      TypeOfNode,
      v18[0],
      (int)v11,
      (int)v10,
      (int)v9,
      v8,
      LanesIn,
      v15,
      v13 & 1,
      (v13 & 4) != 0,
      Speed,
      (v13 & 2) != 0,
      bOnWater,
      (unsigned int)(float)(v7 * 15.0),
      SpecialFunction[0]);
}

//----- (0046A418) --------------------------------------------------------
void __fastcall CFileLoader::Load2dEffect(const unsigned __int8 *pLine)
{
  int32 TxdSlot; // r0
  CBaseModelInfo *v3; // r5
  CStore<C2dEffect,100> *v4; // r0
  int32 v5; // r1
  char *v6; // r6
  int v7; // r1
  int v8; // r2
  int v9; // r0
  const unsigned __int8 *v10; // r1
  int v11; // r0
  int v12; // r2
  RwChar *v13; // r0
  int v14; // r3
  unsigned __int8 *v15; // r0
  int v16; // t1
  int v17; // r1
  _BYTE *v18; // r2
  float v19; // r1
  float v20; // r2
  int v21; // r3
  int v22; // r4
  _QWORD *v23; // r0
  __int64 v24; // d17
  __int64 v25; // d17
  _QWORD *v26; // r1
  __int64 v27; // d17
  __int64 v28; // d17
  int v29; // r1
  int v30; // r2
  int v31; // r3
  int v32; // r4
  int v33; // r5
  int v34; // r12
  int v35; // lr
  char v36; // r0
  unsigned __int8 *v37; // r0
  int v38; // t1
  int v39; // [sp+94h] [bp-1B4h] BYREF
  int v40; // [sp+98h] [bp-1B0h] BYREF
  int v41; // [sp+9Ch] [bp-1ACh] BYREF
  int v42; // [sp+A0h] [bp-1A8h] BYREF
  int v43; // [sp+A4h] [bp-1A4h] BYREF
  int v44; // [sp+A8h] [bp-1A0h] BYREF
  int v45; // [sp+ACh] [bp-19Ch] BYREF
  int v46; // [sp+B0h] [bp-198h] BYREF
  int v47; // [sp+B4h] [bp-194h] BYREF
  int v48; // [sp+B8h] [bp-190h] BYREF
  unsigned int v49; // [sp+BCh] [bp-18Ch] BYREF
  unsigned int v50; // [sp+C0h] [bp-188h] BYREF
  int v51; // [sp+C4h] [bp-184h] BYREF
  int v52; // [sp+C8h] [bp-180h] BYREF
  int v53; // [sp+CCh] [bp-17Ch] BYREF
  int v54; // [sp+D0h] [bp-178h] BYREF
  int v55; // [sp+D4h] [bp-174h] BYREF
  int v56; // [sp+D8h] [bp-170h] BYREF
  int v57; // [sp+DCh] [bp-16Ch] BYREF
  int v58; // [sp+E0h] [bp-168h] BYREF
  int v59; // [sp+E4h] [bp-164h] BYREF
  int v60; // [sp+E8h] [bp-160h] BYREF
  int v61; // [sp+ECh] [bp-15Ch] BYREF
  int v62; // [sp+F0h] [bp-158h] BYREF
  int v63; // [sp+F4h] [bp-154h] BYREF
  int v64; // [sp+F8h] [bp-150h] BYREF
  int v65; // [sp+FCh] [bp-14Ch] BYREF
  int v66; // [sp+100h] [bp-148h] BYREF
  int v67; // [sp+104h] [bp-144h] BYREF
  int v68; // [sp+108h] [bp-140h] BYREF
  int v69; // [sp+10Ch] [bp-13Ch] BYREF
  float v70; // [sp+110h] [bp-138h] BYREF
  float v71; // [sp+114h] [bp-134h] BYREF
  float v72; // [sp+118h] [bp-130h] BYREF
  int v73; // [sp+11Ch] [bp-12Ch] BYREF
  int v74; // [sp+120h] [bp-128h] BYREF
  int v75; // [sp+124h] [bp-124h] BYREF
  int v76; // [sp+128h] [bp-120h] BYREF
  int v77; // [sp+12Ch] [bp-11Ch] BYREF
  RwChar name[17]; // [sp+130h] [bp-118h] BYREF
  __int64 v79; // [sp+141h] [bp-107h]
  __int64 v80; // [sp+149h] [bp-FFh]
  _QWORD v81[10]; // [sp+1B0h] [bp-98h] BYREF
  _BYTE v82[17]; // [sp+200h] [bp-48h] BYREF
  __int64 v83; // [sp+211h] [bp-37h]
  __int64 v84; // [sp+219h] [bp-2Fh]

  sscanf((const char *)pLine, "%d %f %f %f %d", &v77, &v75, &v74, &v73, &v76);
  CTxdStore::PushCurrentTxd();
  TxdSlot = CTxdStore::FindTxdSlot("particle");
  CTxdStore::SetCurrentTxd(TxdSlot, 0);
  v3 = CModelInfo::ms_modelInfoPtrs[v77];
  v4 = CModelInfo::Get2dEffectStore();
  v5 = v4->m_nextItem++;
  v6 = (char *)v4 + 64 * v5;
  CBaseModelInfo::Add2dEffect(v3, (C2dEffect *)(v6 + 4));
  v8 = v73;
  v7 = v74;
  *((_DWORD *)v6 + 1) = v75;
  *((_DWORD *)v6 + 2) = v7;
  *((_DWORD *)v6 + 3) = v8;
  v9 = v76;
  v6[16] = v76;
  switch ( v9 )
  {
    case 0:
      sscanf((const char *)pLine, "%d %f %f %f %d %d %d %d %d", &v77, &v75, &v74, &v73, &v76, &v69, &v68, &v67, &v66);
      v10 = pLine + 1;
      do
        v11 = *(v10++ - 1);
      while ( v11 != 34 );
      v12 = *(v10 - 1);
      v13 = name;
      if ( v12 != 34 )
      {
        v14 = 0;
        do
        {
          name[v14] = v12;
          v12 = v10[v14++];
        }
        while ( v12 != 34 );
        v13 = &name[v14];
        v10 += v14;
      }
      *v13 = 0;
      v15 = (unsigned __int8 *)(v10 - 1);
      do
        v16 = *++v15;
      while ( v16 != 34 );
      v17 = v15[1];
      if ( v17 == 34 )
      {
        v18 = v82;
      }
      else
      {
        v37 = v15 + 2;
        v18 = v82;
        do
        {
          *v18++ = v17;
          v38 = *v37++;
          LOBYTE(v17) = v38;
        }
        while ( v38 != 34 );
        v15 = v37 - 2;
      }
      *v18 = 0;
      sscanf(
        (const char *)v15 + 2,
        "%f %f %f %f %d %d %d %d %d %d %d %d %d",
        v6 + 24,
        v6 + 28,
        v6 + 32,
        v6 + 36,
        &v81[5],
        v81,
        &v72,
        &v71,
        &v70,
        &v65,
        &v64,
        &v63,
        &v62);
      v6[20] = v69;
      v6[21] = v68;
      v6[22] = v67;
      v6[23] = v66;
      v6[45] = v81[5];
      v6[42] = v81[0];
      v6[43] = LOBYTE(v72);
      v6[44] = LOBYTE(v71);
      *((_WORD *)v6 + 20) = LOWORD(v70);
      v6[46] = v65;
      v6[47] = v64;
      v6[48] = v63;
      v6[49] = v62;
      *((_DWORD *)v6 + 13) = RwTextureRead(name, 0);
      *((_DWORD *)v6 + 14) = RwTextureRead(v82, 0);
      if ( (LOBYTE(v70) & 4) != 0 )
        *((_WORD *)v6 + 20) &= ~2u;
      break;
    case 1:
      sscanf((const char *)pLine, "%d %f %f %f %d %s", &v77, &v75, &v74, &v73, &v76, v6 + 20);
      break;
    case 3:
      sscanf(
        (const char *)pLine,
        "%d %f %f %f %d %d %f %f %f %f %f %f %f %f %f %d %d %s",
        &v77,
        &v75,
        &v74,
        &v73,
        &v76,
        v82,
        v6 + 20,
        v6 + 24,
        v6 + 28,
        v6 + 32,
        v6 + 36,
        v6 + 40,
        v6 + 44,
        v6 + 48,
        v6 + 52,
        &v81[5],
        v81,
        name);
      v6[56] = v82[0];
      strcpy(v6 + 60, (const char *)name);
      v6[57] = v81[5];
      v6[58] = v81[0];
      break;
    case 5:
      v66 = 50;
      v67 = -1;
      v64 = -1;
      v65 = -1;
      v62 = -1;
      v63 = -1;
      v60 = -1;
      v61 = -1;
      v58 = -1;
      v59 = -1;
      v56 = -1;
      v57 = -1;
      v54 = -1;
      v55 = -1;
      v53 = 0;
      memset(name, 255, 12);
      memset(v82, 255, 12);
      memset(&v81[5], 255, 12);
      memset(v81, 255, 12);
      sscanf(
        (const char *)pLine,
        "%d %f %f %f %d %d %f %f %f %f %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d  %d %d %d %d  %d %d %d %d  %d %d %d %d",
        &v77,
        &v75,
        &v74,
        &v73,
        &v76,
        &v53,
        &v72,
        &v71,
        &v70,
        v6 + 52,
        &v68,
        &v69,
        &v67,
        &v66,
        &v65,
        &v64,
        &v63,
        &v62,
        &v61,
        &v60,
        &v59,
        &v58,
        &v57,
        &v56,
        &v55,
        &v54,
        name,
        v82,
        &v81[5],
        v81,
        &name[4],
        &v82[4],
        (char *)&v81[5] + 4,
        (char *)v81 + 4,
        &name[8],
        &v82[8],
        &v81[6],
        &v81[1]);
      v6[20] = v53;
      v6[22] = (unsigned int)v72;
      v6[23] = (unsigned int)v71;
      v6[24] = (unsigned int)v70;
      v6[25] = v68;
      v6[50] = v69;
      v6[21] = v67;
      v6[51] = v66;
      v6[26] = v65;
      v6[27] = v64;
      v6[30] = v63;
      v6[31] = v62;
      v6[28] = v61;
      v6[29] = v60;
      v6[32] = v59;
      v6[33] = v58;
      v6[36] = v57;
      v6[37] = v56;
      v6[34] = v55;
      v6[35] = v54;
      v6[38] = name[0];
      v6[41] = v82[0];
      v6[44] = v81[5];
      v6[47] = v81[0];
      v6[39] = name[4];
      v6[42] = v82[4];
      v6[45] = BYTE4(v81[5]);
      v6[48] = BYTE4(v81[0]);
      v6[40] = name[8];
      v6[43] = v82[8];
      v6[46] = v81[6];
      v6[49] = v81[1];
      break;
    case 6:
      sscanf(
        (const char *)pLine,
        "%d %f %f %f %d %f %f %f %f %f %f %f %d %d %s %d",
        &v77,
        &v75,
        &v74,
        &v73,
        &v76,
        v6 + 20,
        v6 + 24,
        v6 + 28,
        v6 + 32,
        v6 + 36,
        v6 + 40,
        v6 + 44,
        v82,
        &v81[5],
        name,
        v81);
      *((_WORD *)v6 + 24) = *(_WORD *)v82;
      v6[50] = v81[5];
      v6[51] = v81[0];
      strncpy(v6 + 52, (const char *)name, 8u);
      break;
    case 7:
      v79 = 0LL;
      v80 = 0LL;
      memset(&name[1], 0, 16);
      v83 = 0LL;
      v84 = 0LL;
      memset(&v82[1], 0, 16);
      *(_QWORD *)((char *)&v81[7] + 1) = 0LL;
      *(_QWORD *)((char *)&v81[8] + 1) = 0LL;
      memset((char *)&v81[5] + 1, 0, 16);
      *(_QWORD *)((char *)&v81[2] + 1) = 0LL;
      *(_QWORD *)((char *)&v81[3] + 1) = 0LL;
      memset((char *)v81 + 1, 0, 16);
      name[0] = 32;
      v82[0] = 32;
      LOBYTE(v81[5]) = 32;
      LOBYTE(v81[0]) = 32;
      sscanf(
        (const char *)pLine,
        "%d %f %f %f %d %f %f %f %f %f %d %s %s %s %s",
        &v77,
        &v75,
        &v74,
        &v73,
        &v76,
        &v72,
        &v71,
        &v70,
        &v69,
        &v68,
        &v67,
        name,
        v82,
        &v81[5],
        v81);
      v20 = v70;
      v19 = v71;
      v22 = v68;
      v21 = v69;
      *((float *)v6 + 5) = v72;
      *((float *)v6 + 6) = v19;
      *((float *)v6 + 7) = v20;
      *((_DWORD *)v6 + 8) = v21;
      *((_DWORD *)v6 + 9) = v22;
      *((_WORD *)v6 + 20) = v67;
      v23 = CMemoryMgr::Malloc(0x40u);
      *((_DWORD *)v6 + 11) = v23;
      v24 = *(_QWORD *)&name[8];
      *v23 = *(_QWORD *)name;
      v23[1] = v24;
      v25 = *(_QWORD *)&v82[8];
      v23[2] = *(_QWORD *)v82;
      v23[3] = v25;
      v26 = v23 + 4;
      v23 += 6;
      v27 = v81[6];
      *v26 = v81[5];
      v26[1] = v27;
      v28 = v81[1];
      *v23 = v81[0];
      v23[1] = v28;
      *((_DWORD *)v6 + 12) = 0;
      break;
    case 8:
      sscanf((const char *)pLine, "%d %f %f %f %d %d", &v77, &v75, &v74, &v73, &v76, &v52);
      *((_DWORD *)v6 + 5) = v52;
      break;
    case 9:
      sscanf((const char *)pLine, "%d %f %f %f %d %f %f %d", &v77, &v75, &v74, &v73, &v76, &v50, &v49, &v51);
      *(_QWORD *)(v6 + 20) = __PAIR64__(v49, v50);
      v6[28] = v51;
      break;
    case 10:
      sscanf(
        (const char *)pLine,
        "%d %f %f %f %d %f %f %f %f %f %f %f %f %f %d",
        &v77,
        &v75,
        &v74,
        &v73,
        &v76,
        &v48,
        &v47,
        &v46,
        &v45,
        &v44,
        &v43,
        &v42,
        &v41,
        &v40,
        &v39);
      v29 = v47;
      v31 = v45;
      v30 = v46;
      v32 = v43;
      v33 = v44;
      v35 = v41;
      v34 = v42;
      *((_DWORD *)v6 + 5) = v48;
      *((_DWORD *)v6 + 6) = v29;
      *((_DWORD *)v6 + 7) = v30;
      *((_DWORD *)v6 + 8) = v31;
      *((_DWORD *)v6 + 9) = v33;
      *((_DWORD *)v6 + 10) = v32;
      *((_DWORD *)v6 + 11) = v34;
      *((_DWORD *)v6 + 12) = v35;
      *((_DWORD *)v6 + 13) = v40;
      v36 = v39;
      if ( v39 )
        v36 = 1;
      v6[56] = v36;
      break;
    default:
      break;
  }
  CTxdStore::PopCurrentTxd();
}

//----- (0046AB48) --------------------------------------------------------
void __fastcall CFileLoader::LoadTXDParent(const unsigned __int8 *pLine)
{
  int32 TxdSlot; // r4
  int32 v2; // r0
  unsigned __int8 v3[32]; // [sp+4h] [bp-4Ch] BYREF
  unsigned __int8 pName[32]; // [sp+24h] [bp-2Ch] BYREF

  sscanf((const char *)pLine, "%s %s", pName, v3);
  TxdSlot = CTxdStore::FindTxdSlot(pName);
  if ( TxdSlot == -1 )
    TxdSlot = CTxdStore::AddTxdSlot(pName, "cutscene", 0);
  v2 = CTxdStore::FindTxdSlot(v3);
  if ( v2 == -1 )
    LOWORD(v2) = CTxdStore::AddTxdSlot(v3, "gta3", 0);
  *(_WORD *)&CTxdStore::ms_pTxdPool->m_aStorage[TxdSlot][6] = v2;
}

//----- (0046ABE8) --------------------------------------------------------
void __fastcall CFileLoader::ReloadPaths(const unsigned __int8 *pFilename)
{
  int32 v1; // r6
  u_native v2; // r4
  unsigned __int8 *Line; // r0
  int v4; // r8
  int v5; // r5
  int32 v6; // r1
  int32 v7; // r2
  bool v8; // r3
  int v9; // r1
  int32 v10; // r9
  bool v11; // zf
  bool v12; // zf
  bool v13; // zf
  int v14; // r1
  bool v15; // zf
  int v16; // [sp+8h] [bp-78h] BYREF
  int32 v17; // [sp+Ch] [bp-74h] BYREF
  char v18; // [sp+10h] [bp-70h] BYREF

  v2 = CFileMgr::OpenFile(pFilename, (const unsigned __int8 *)&dword_46ACD8);
  Line = CFileLoader::LoadLine(v2);
  if ( Line )
  {
    v4 = 0;
    v5 = -1;
    do
    {
      v9 = *Line;
      v10 = v5;
      v11 = v9 == 0;
      if ( *Line )
        v11 = v9 == 35;
      if ( v11 )
        goto LABEL_33;
      if ( v4 )
      {
        v12 = v9 == 101;
        if ( v9 == 101 )
          v12 = Line[1] == 110;
        if ( v12 && Line[2] == 100 )
          goto LABEL_32;
        ++v5;
        if ( v10 != -1 )
        {
          if ( v16 == 2 )
          {
            v6 = v1;
            v7 = v10;
            v8 = 1;
          }
          else
          {
            if ( v16 != 1 )
            {
              if ( !v16 )
                CFileLoader::LoadPedPathNode(Line, v1, v10);
              goto LABEL_7;
            }
            v6 = v1;
            v7 = v10;
            v8 = 0;
          }
          CFileLoader::LoadCarPathNode(Line, v6, v7, v8);
LABEL_7:
          v4 = 1;
          if ( v10 == 11 )
            v5 = -1;
          goto LABEL_33;
        }
        sscanf((const char *)Line, "%d %d %s", &v16, &v17, &v18);
        v1 = v17;
        v5 = 0;
        v4 = 1;
      }
      else
      {
        v13 = v9 == 112;
        if ( v9 == 112 )
          v13 = Line[1] == 97;
        if ( !v13 )
          goto LABEL_32;
        v14 = Line[2];
        v15 = v14 == 116;
        if ( v14 == 116 )
          v15 = Line[3] == 104;
        if ( !v15 )
        {
LABEL_32:
          v4 = 0;
          goto LABEL_33;
        }
        CPathFind::AllocatePathFindInfoMem(&ThePaths);
        v4 = 1;
      }
LABEL_33:
      Line = CFileLoader::LoadLine(v2);
    }
    while ( Line );
  }
  CFileMgr::CloseFile(v2);
}
// 46AC72: conditional instruction was optimized away because r8.4==1
// 46AC32: variable 'v1' is possibly undefined
// 46ACD8: using guessed type int dword_46ACD8;

//----- (0046ACE4) --------------------------------------------------------
void __fastcall SetBaseModelInfoFlags(CBaseModelInfo *pModelInfo, uint32 flags)
{
  uint16 m_flags; // r2
  __int16 v3; // r3
  __int16 v4; // r2
  __int16 v5; // r3
  __int16 v6; // r2
  uint16 v7; // r3

  m_flags = pModelInfo->m_flags;
  v3 = m_flags & 0xFFFD;
  if ( (flags & 0xC) != 0 )
    v3 = m_flags | 2;
  v4 = v3 & 0xFFFB;
  if ( (flags & 8) != 0 )
    v4 = v3 | 4;
  v5 = v4 & 0xFFF7;
  if ( (flags & 0x40) != 0 )
    v5 = v4 | 8;
  v6 = v5 & 0xFFEF;
  if ( (flags & 0x80) != 0 )
    v6 = v5 | 0x10;
  v7 = v6 & 0xFFBF;
  if ( (flags & 0x200000) == 0 )
    v7 = v6 | 0x40;
  pModelInfo->m_flags = v7;
}

//----- (0046AD34) --------------------------------------------------------
void __fastcall SetAtomicModelInfoFlags(CAtomicModelInfo *pModelInfo, uint32 flags)
{
  uint16 m_flags; // r2
  __int16 v3; // r3
  __int16 v4; // r2
  __int16 v5; // r3
  __int16 v6; // r2
  uint16 v7; // r3
  uint16 v8; // r2
  __int16 v9; // r3
  __int16 v10; // r3
  uint16 v11; // r3
  uint16 v12; // r12
  uint16 v13; // r3
  __int16 v14; // lr
  uint16 v15; // r2
  uint16 v16; // r3
  __int16 v17; // r2

  m_flags = pModelInfo->m_flags;
  v3 = m_flags & 0xFFFD;
  if ( (flags & 0xC) != 0 )
    v3 = m_flags | 2;
  v4 = v3 & 0xFFFB;
  if ( (flags & 8) != 0 )
    v4 = v3 | 4;
  v5 = v4 & 0xFFF7;
  if ( (flags & 0x40) != 0 )
    v5 = v4 | 8;
  v6 = v5 & 0xFFEF;
  if ( (flags & 0x80) != 0 )
    v6 = v5 | 0x10;
  v7 = v6 & 0xFFBF;
  if ( (flags & 0x200000) == 0 )
    v7 = v6 | 0x40;
  v8 = v7 & 0xFEFF;
  pModelInfo->m_flags = v7;
  if ( (flags & 1) != 0 )
    v8 = v7 | 0x100;
  v9 = v8 & 0x87FF;
  if ( (flags & 0x200) != 0 )
    v8 = v9 | 0x2000;
  if ( (flags & 0x400) != 0 )
    v8 = v9 | 0x2800;
  v10 = v8 & 0x87FF;
  if ( (flags & 0x800) != 0 )
    v8 = v10 | 0x3800;
  if ( (flags & 0x2000) != 0 )
    v8 = v10 | 0x800;
  v11 = v8 & 0x87FF | 0x1000;
  if ( (flags & 0x4000) == 0 )
    v11 = v8;
  pModelInfo->m_flags = v11;
  v12 = v11 & 0xFBFF;
  v13 = v11 | 0x400;
  if ( (flags & 0x8000) != 0 )
    v12 = v13;
  v14 = v12 & 0x87FF;
  v15 = v12;
  if ( (flags & 0x100000) != 0 )
    v15 = v14 | 0x3000;
  v16 = v15;
  if ( (flags & 0x400000) != 0 )
  {
    v16 = v14 | 0x5800;
    v15 = v12;
  }
  v17 = v15 & 0x87FF;
  if ( (flags & 0x80000) != 0 )
    v16 = v17 | 0x5000;
  pModelInfo->m_flags = v16;
}
// 46ADF4: mask 0xFFFF87FF is shortened because r12.4 <= 0xFFFF

//----- (0046AE20) --------------------------------------------------------
void __fastcall SetClumpModelInfoFlags(CClumpModelInfo *pModelInfo, uint32 flags)
{
  uint16 m_flags; // r2
  __int16 v3; // r3
  __int16 v4; // r2
  __int16 v5; // r3
  __int16 v6; // r2
  __int16 v7; // r3
  uint16 v8; // r2

  m_flags = pModelInfo->m_flags;
  v3 = m_flags & 0xFFFD;
  if ( (flags & 0xC) != 0 )
    v3 = m_flags | 2;
  v4 = v3 & 0xFFFB;
  if ( (flags & 8) != 0 )
    v4 = v3 | 4;
  v5 = v4 & 0xFFF7;
  if ( (flags & 0x40) != 0 )
    v5 = v4 | 8;
  v6 = v5 & 0xFFEF;
  if ( (flags & 0x80) != 0 )
    v6 = v5 | 0x10;
  v7 = v6 & 0xFFBF;
  if ( (flags & 0x200000) == 0 )
    v7 = v6 | 0x40;
  v8 = v7 & 0xFBFF;
  if ( (flags & 0x20) != 0 )
    v8 = v7 | 0x400;
  pModelInfo->m_flags = v8;
}

//----- (0046AE80) --------------------------------------------------------
Int32 __fastcall CPopulation::FindPedRaceFromName(unsigned __int8 *NameString)
{
  unsigned __int8 v2; // r0
  int v3; // r2
  Int32 result; // r0
  unsigned __int8 v5; // r0
  int v6; // r1

  v2 = *NameString;
  if ( (unsigned __int8)(v2 - 97) < 0x1Au )
    v2 -= 32;
  v3 = v2 - 66;
  result = 3;
  switch ( v3 )
  {
    case 0:
LABEL_4:
      result = 1;
      break;
    case 6:
LABEL_8:
      result = 4;
      break;
    case 7:
    case 13:
      return result;
    case 21:
LABEL_9:
      result = 2;
      break;
    default:
      v5 = NameString[1];
      if ( (unsigned __int8)(v5 - 97) < 0x1Au )
        v5 -= 32;
      v6 = v5 - 66;
      result = 3;
      switch ( v6 )
      {
        case 0:
          goto LABEL_4;
        case 6:
          goto LABEL_8;
        case 7:
        case 13:
          return result;
        case 21:
          goto LABEL_9;
        default:
          result = 0;
          break;
      }
      break;
  }
  return result;
}

//----- (0046AF10) --------------------------------------------------------
void __fastcall CFileLoader::LoadZone(const unsigned __int8 *pLine)
{
  eLevelName v1; // [sp+24h] [bp-54h] BYREF
  eZoneType NewZoneType; // [sp+28h] [bp-50h] BYREF
  float v3; // [sp+2Ch] [bp-4Ch] BYREF
  float v4; // [sp+30h] [bp-48h] BYREF
  float v5; // [sp+34h] [bp-44h] BYREF
  float v6; // [sp+38h] [bp-40h] BYREF
  float v7; // [sp+3Ch] [bp-3Ch] BYREF
  float NewZ1; // [sp+40h] [bp-38h] BYREF
  Char v9[8]; // [sp+45h] [bp-33h] BYREF
  unsigned __int8 text_label[10]; // [sp+4Dh] [bp-2Bh] BYREF

  if ( sscanf(
         (const char *)pLine,
         "%s %d %f %f %f %f %f %f %d %s",
         &text_label[2],
         &NewZoneType,
         &v6,
         &v7,
         &NewZ1,
         &v3,
         &v4,
         &v5,
         &v1,
         v9) == 10 )
    CTheZones::CreateZone(&text_label[2], NewZoneType, v6, v7, NewZ1, v3, v4, v5, v1, v9);
}
// 46AF10: using guessed type float var_40;
// 46AF10: using guessed type Char var_33[8];

//----- (0046AFB8) --------------------------------------------------------
void __fastcall CFileLoader::LoadCullZone(const unsigned __int8 *pLine)
{
  float ArgMirrorV; // [sp+30h] [bp-58h] BYREF
  float v3; // [sp+34h] [bp-54h] BYREF
  float ArgMirrorNormalY; // [sp+38h] [bp-50h] BYREF
  float v5; // [sp+3Ch] [bp-4Ch] BYREF
  int v6; // [sp+40h] [bp-48h] BYREF
  UInt16 ArgFlags; // [sp+44h] [bp-44h] BYREF
  float ArgMaxZ; // [sp+48h] [bp-40h] BYREF
  float v9; // [sp+4Ch] [bp-3Ch] BYREF
  float ArgVec2X; // [sp+50h] [bp-38h] BYREF
  float v11; // [sp+54h] [bp-34h] BYREF
  float v12; // [sp+58h] [bp-30h] BYREF
  float ArgVec1X; // [sp+5Ch] [bp-2Ch] BYREF
  CVector posn; // [sp+60h] [bp-28h] BYREF

  v6 = 0;
  if ( sscanf(
         (const char *)pLine,
         "%f %f %f %f %f %f %f %f %f %d %f %f %f %f",
         &posn,
         &posn.y,
         &posn.z,
         &ArgVec1X,
         &v12,
         &v11,
         &ArgVec2X,
         &v9,
         &ArgMaxZ,
         &ArgFlags,
         &v5,
         &ArgMirrorNormalY,
         &v3,
         &ArgMirrorV) == 14 )
  {
    CCullZones::AddMirrorAttributeZone(
      &posn,
      ArgVec1X,
      v12,
      v11,
      ArgVec2X,
      v9,
      ArgMaxZ,
      ArgFlags,
      ArgMirrorV,
      v5,
      ArgMirrorNormalY,
      v3);
  }
  else
  {
    sscanf(
      (const char *)pLine,
      "%f %f %f %f %f %f %f %f %f %d %d",
      &posn,
      &posn.y,
      &posn.z,
      &ArgVec1X,
      &v12,
      &v11,
      &ArgVec2X,
      &v9,
      &ArgMaxZ,
      &ArgFlags,
      &v6);
    CCullZones::AddCullZone(&posn, ArgVec1X, v12, v11, ArgVec2X, v9, ArgMaxZ, ArgFlags, v6);
  }
}
// 46AFB8: using guessed type float var_34;
// 46AFB8: using guessed type float var_30;

//----- (0046B110) --------------------------------------------------------
void __fastcall CFileLoader::LoadOcclusionVolume(const unsigned __int8 *pLine, const unsigned __int8 *pFilename)
{
  int bInterior; // r5
  float v4; // s18
  const unsigned __int8 *v5; // r0
  UInt32 v6; // [sp+20h] [bp-50h] BYREF
  float XRot; // [sp+24h] [bp-4Ch] BYREF
  float v8; // [sp+28h] [bp-48h] BYREF
  float ZRot; // [sp+2Ch] [bp-44h] BYREF
  float v10; // [sp+30h] [bp-40h] BYREF
  float ArgLength; // [sp+34h] [bp-3Ch] BYREF
  float v12; // [sp+38h] [bp-38h] BYREF
  float v13; // [sp+3Ch] [bp-34h] BYREF
  float Y; // [sp+40h] [bp-30h] BYREF
  float v15; // [sp+44h] [bp-2Ch] BYREF

  bInterior = 0;
  v8 = 0.0;
  v6 = 0;
  XRot = 0.0;
  sscanf(
    (const char *)pLine,
    "%f %f %f %f %f %f %f %f %f %d ",
    &v13,
    &Y,
    &v15,
    &v12,
    &ArgLength,
    &v10,
    &ZRot,
    &v8,
    &XRot,
    &v6);
  v4 = v15 + (float)(v10 * 0.5);
  v15 = v4;
  v5 = &pFilename[strlen((const char *)pFilename)];
  if ( *(v5 - 7) == 105 )
  {
    bInterior = 0;
    if ( *(v5 - 6) == 110 && *(v5 - 5) == 116 )
      bInterior = 1;
  }
  COcclusion::AddOne(v13, Y, v4, v12, ArgLength, v10, ZRot, v8, XRot, v6, bInterior);
}
// 46B110: using guessed type float var_38;
// 46B110: using guessed type float var_34;

//----- (0046B200) --------------------------------------------------------
void __fastcall CFileLoader::LoadAudioZone(const unsigned __int8 *pLine)
{
  char v2; // r2
  char v3; // r2
  float v4; // [sp+20h] [bp-50h] BYREF
  float MaxCoorsZ; // [sp+24h] [bp-4Ch] BYREF
  float v6; // [sp+28h] [bp-48h] BYREF
  float MaxCoorsX; // [sp+2Ch] [bp-44h] BYREF
  float v8; // [sp+30h] [bp-40h] BYREF
  float MinCoorsY; // [sp+34h] [bp-3Ch] BYREF
  float CoorsX; // [sp+38h] [bp-38h] BYREF
  int v11; // [sp+3Ch] [bp-34h] BYREF
  Int32 v12; // [sp+40h] [bp-30h] BYREF
  unsigned __int8 pName[16]; // [sp+44h] [bp-2Ch] BYREF

  if ( sscanf(
         (const char *)pLine,
         "%s %d %d %f %f %f %f %f %f",
         pName,
         &v12,
         &v11,
         &CoorsX,
         &MinCoorsY,
         &v8,
         &MaxCoorsX,
         &v6,
         &MaxCoorsZ) == 9 )
  {
    v2 = v11;
    if ( v11 )
      v2 = 1;
    CAudioZones::RegisterAudioBox(pName, v12, v2, CoorsX, MinCoorsY, v8, MaxCoorsX, v6, MaxCoorsZ);
  }
  else
  {
    sscanf((const char *)pLine, "%s %d %d %f %f %f %f", pName, &v12, &v11, &CoorsX, &MinCoorsY, &v8, &v4);
    v3 = v11;
    if ( v11 )
      v3 = 1;
    CAudioZones::RegisterAudioSphere(pName, v12, v3, CoorsX, MinCoorsY, v8, v4);
  }
}

//----- (0046B31C) --------------------------------------------------------
void __fastcall CFileLoader::LoadEntryExit(const unsigned __int8 *pLine)
{
  const unsigned __int8 *v1; // r10
  char *v2; // r0
  int32 v3; // r0
  uint8 *v4; // r0
  char v5; // r1
  int32 v6; // [sp+40h] [bp-80h] BYREF
  int32 v7; // [sp+44h] [bp-7Ch] BYREF
  Int32 ArgNumRandomPedsToCreate; // [sp+48h] [bp-78h] BYREF
  int32 v9; // [sp+4Ch] [bp-74h] BYREF
  int32 v10; // [sp+50h] [bp-70h] BYREF
  int32 v11; // [sp+54h] [bp-6Ch] BYREF
  float v12; // [sp+58h] [bp-68h] BYREF
  float v13; // [sp+5Ch] [bp-64h] BYREF
  float v14; // [sp+60h] [bp-60h] BYREF
  float v15; // [sp+64h] [bp-5Ch] BYREF
  float v16; // [sp+68h] [bp-58h] BYREF
  float v17; // [sp+6Ch] [bp-54h] BYREF
  float wx; // [sp+70h] [bp-50h] BYREF
  float v19; // [sp+74h] [bp-4Ch] BYREF
  float v20; // [sp+78h] [bp-48h] BYREF
  float v21; // [sp+7Ch] [bp-44h] BYREF
  float v22; // [sp+80h] [bp-40h] BYREF
  char v23; // [sp+84h] [bp-3Ch] BYREF
  _BYTE v24[3]; // [sp+85h] [bp-3Bh] BYREF

  v1 = 0;
  ArgNumRandomPedsToCreate = 2;
  v6 = 24;
  v7 = 0;
  sscanf(
    (const char *)pLine,
    "%f %f %f %f %f %f %f %f %f %f %f %d %d %s %d %d %d %d",
    &v22,
    &v21,
    &v20,
    &v19,
    &wx,
    &v17,
    &v16,
    &v15,
    &v14,
    &v13,
    &v12,
    &v11,
    &v10,
    &v23,
    &v9,
    &ArgNumRandomPedsToCreate,
    &v7,
    &v6);
  v2 = strrchr(&v23, 34);
  if ( v2 )
  {
    *v2 = 0;
    v1 = v24;
  }
  v3 = CEntryExitManager::AddOne(
         v22,
         v21,
         v20,
         v19,
         wx,
         v17,
         v16,
         v15,
         v14,
         v13,
         v12,
         v11,
         v10,
         v9,
         v7,
         v6,
         ArgNumRandomPedsToCreate,
         v1);
  if ( (CEntryExitManager::mp_poolEntryExits->m_aFlags[v3] & 0x80u) != 0 )
    v4 = 0;
  else
    v4 = CEntryExitManager::mp_poolEntryExits->m_aStorage[v3];
  v5 = v10;
  if ( (v10 & 1) != 0 )
    *((_WORD *)v4 + 24) |= 1u;
  if ( (v5 & 2) != 0 )
    *((_WORD *)v4 + 24) |= 2u;
  if ( (v5 & 4) != 0 )
    *((_WORD *)v4 + 24) |= 4u;
  if ( (v5 & 8) != 0 )
    *((_WORD *)v4 + 24) |= 8u;
  if ( (v5 & 0x10) != 0 )
    *((_WORD *)v4 + 24) |= 0x10u;
  if ( (v5 & 0x20) != 0 )
    *((_WORD *)v4 + 24) |= 0x20u;
  if ( (v5 & 0x40) != 0 )
    *((_WORD *)v4 + 24) |= 0x40u;
  if ( (v5 & 0x80) != 0 )
    *((_WORD *)v4 + 24) |= 0x80u;
}
// 46B31C: using guessed type float var_4C;
// 46B31C: using guessed type float var_48;
// 46B31C: using guessed type float var_40;
// 46B31C: using guessed type float var_44;

//----- (0046B4E8) --------------------------------------------------------
void __fastcall CFileLoader::LoadGarage(const unsigned __int8 *pLine)
{
  UInt8 Type; // [sp+24h] [bp-44h] BYREF
  UInt32 v2; // [sp+28h] [bp-40h] BYREF
  float v3; // [sp+2Ch] [bp-3Ch] BYREF
  float Point2Y; // [sp+30h] [bp-38h] BYREF
  float v5; // [sp+34h] [bp-34h] BYREF
  float Point1Y; // [sp+38h] [bp-30h] BYREF
  float v7; // [sp+3Ch] [bp-2Ch] BYREF
  float v8; // [sp+40h] [bp-28h] BYREF
  float v9; // [sp+44h] [bp-24h] BYREF
  float v10; // [sp+48h] [bp-20h] BYREF
  unsigned __int8 pName[8]; // [sp+4Ch] [bp-1Ch] BYREF

  if ( sscanf(
         (const char *)pLine,
         "%f %f %f %f %f %f %f %f %d %d %s",
         &v10,
         &v9,
         &v8,
         &v7,
         &Point1Y,
         &v5,
         &Point2Y,
         &v3,
         &v2,
         &Type,
         pName) == 11 )
    CGarages::AddOne(v10, v9, v8, v7, Point1Y, v5, Point2Y, v3, Type, 0, pName, v2);
}
// 46B4E8: using guessed type float var_28;
// 46B4E8: using guessed type unsigned __int8 var_1C[8];
// 46B4E8: using guessed type float var_2C;
// 46B4E8: using guessed type float var_20;
// 46B4E8: using guessed type float var_24;

//----- (0046B5B8) --------------------------------------------------------
void __fastcall CFileLoader::LoadPickup(const unsigned __int8 *pLine)
{
  UInt32 v1; // r3
  int v2; // [sp+18h] [bp-18h] BYREF
  RwReal v3; // [sp+1Ch] [bp-14h] BYREF
  RwReal v4; // [sp+20h] [bp-10h] BYREF
  CVector Coors; // [sp+24h] [bp-Ch] BYREF
  CVector v6; // 0:r0.12

  if ( sscanf((const char *)pLine, "%d %f %f %f", &v2, &Coors, &v4, &v3) == 4 )
  {
    v6.z = v3;
    v6.y = v4;
    v1 = 331;
    v6.x = Coors.x;
    switch ( v2 )
    {
      case 4:
        goto LABEL_48;
      case 5:
        v1 = 334;
        goto LABEL_48;
      case 6:
        v1 = 335;
        goto LABEL_48;
      case 9:
        v1 = 333;
        goto LABEL_48;
      case 10:
        v1 = 336;
        goto LABEL_48;
      case 11:
        v1 = 337;
        goto LABEL_48;
      case 12:
        v1 = 338;
        goto LABEL_48;
      case 13:
        v1 = 339;
        goto LABEL_48;
      case 14:
        v1 = 341;
        goto LABEL_48;
      case 15:
        v1 = 344;
        goto LABEL_48;
      case 16:
        v1 = 342;
        goto LABEL_48;
      case 17:
        v1 = 363;
        goto LABEL_48;
      case 18:
        v1 = 346;
        goto LABEL_48;
      case 19:
        v1 = 347;
        goto LABEL_48;
      case 20:
        v1 = 348;
        goto LABEL_48;
      case 21:
        v1 = 349;
        goto LABEL_48;
      case 22:
      case 45:
        v1 = 351;
        goto LABEL_48;
      case 23:
        v1 = 372;
        goto LABEL_48;
      case 24:
        v1 = 352;
        goto LABEL_48;
      case 25:
        v1 = 353;
        goto LABEL_48;
      case 26:
        v1 = 355;
        goto LABEL_48;
      case 27:
        v1 = 356;
        goto LABEL_48;
      case 28:
        v1 = 357;
        goto LABEL_48;
      case 29:
        v1 = 358;
        goto LABEL_48;
      case 31:
        v1 = 361;
        goto LABEL_48;
      case 32:
      case 44:
        v1 = 362;
        goto LABEL_48;
      case 33:
        v1 = 321;
        goto LABEL_48;
      case 34:
        v1 = 322;
        goto LABEL_48;
      case 35:
        v1 = 323;
        goto LABEL_48;
      case 36:
        v1 = 324;
        goto LABEL_48;
      case 37:
        v1 = 325;
        goto LABEL_48;
      case 38:
        v1 = 326;
        goto LABEL_48;
      case 39:
        v1 = 327;
        goto LABEL_48;
      case 40:
        v1 = 328;
        goto LABEL_48;
      case 41:
        v1 = 330;
        goto LABEL_48;
      case 43:
        v1 = 343;
        goto LABEL_48;
      case 46:
        v1 = 359;
        goto LABEL_48;
      case 47:
        v1 = 360;
        goto LABEL_48;
      case 48:
        v1 = 364;
        goto LABEL_48;
      case 49:
        v1 = 365;
        goto LABEL_48;
      case 50:
        v1 = 366;
        goto LABEL_48;
      case 51:
        v1 = 367;
        goto LABEL_48;
      case 52:
        v1 = 368;
        goto LABEL_48;
      case 53:
        v1 = 369;
        goto LABEL_48;
      case 54:
        v1 = 370;
        goto LABEL_48;
      case 55:
        v1 = 371;
LABEL_48:
        CPickups::GenerateNewOne(v6, v1, 2, 0, 0, 0, 0);
        break;
      default:
        return;
    }
  }
}

//----- (0046B75C) --------------------------------------------------------
void __fastcall CFileLoader::LoadCarGenerator(const unsigned __int8 *pLine, int32 level)
{
  CFileCarGenerator pFileCarGen; // [sp+28h] [bp-48h] BYREF

  if ( sscanf(
         (const char *)pLine,
         "%f %f %f %f %d %d %d %d %d %d %d %d",
         &pFileCarGen,
         &pFileCarGen.m_y,
         &pFileCarGen.m_z,
         &pFileCarGen.m_r,
         &pFileCarGen.m_modelID,
         &pFileCarGen.m_col1,
         &pFileCarGen.m_col2,
         &pFileCarGen.m_flagVal,
         &pFileCarGen.m_alarmChance,
         &pFileCarGen.m_lockedChance,
         &pFileCarGen.m_minDelay,
         &pFileCarGen.m_maxDelay) == 12 )
    CFileLoader::LoadCarGenerator(&pFileCarGen, level);
}

//----- (0046B7C8) --------------------------------------------------------
void __fastcall CFileLoader::LoadStuntJump(const unsigned __int8 *pLine)
{
  CVector r_vecCamera; // [sp+3Ch] [bp-8Ch] BYREF
  CBoundBox r_bbEnd; // [sp+48h] [bp-80h] BYREF
  CBoundBox r_bbStart; // [sp+60h] [bp-68h] BYREF
  int32 v4; // [sp+78h] [bp-50h] BYREF
  RwReal v5; // [sp+7Ch] [bp-4Ch] BYREF
  RwReal v6; // [sp+80h] [bp-48h] BYREF
  RwReal v7; // [sp+84h] [bp-44h] BYREF
  RwReal v8; // [sp+88h] [bp-40h] BYREF
  RwReal v9; // [sp+8Ch] [bp-3Ch] BYREF
  RwReal v10; // [sp+90h] [bp-38h] BYREF
  RwReal v11; // [sp+94h] [bp-34h] BYREF
  RwReal v12; // [sp+98h] [bp-30h] BYREF
  RwReal v13; // [sp+9Ch] [bp-2Ch] BYREF
  RwReal v14; // [sp+A0h] [bp-28h] BYREF
  RwReal v15; // [sp+A4h] [bp-24h] BYREF
  RwReal v16; // [sp+A8h] [bp-20h] BYREF
  RwReal v17; // [sp+ACh] [bp-1Ch] BYREF
  RwReal v18; // [sp+B0h] [bp-18h] BYREF
  RwReal v19; // [sp+B4h] [bp-14h] BYREF

  if ( sscanf(
         (const char *)pLine,
         "%f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %d",
         &v16,
         &v15,
         &v14,
         &v13,
         &v12,
         &v11,
         &v10,
         &v9,
         &v8,
         &v7,
         &v6,
         &v5,
         &v19,
         &v18,
         &v17,
         &v4) == 16 )
  {
    r_bbStart.m_vecMin.x = v16;
    r_bbStart.m_vecMin.y = v15;
    r_bbStart.m_vecMin.z = v14;
    r_bbStart.m_vecMax.x = v13;
    r_bbStart.m_vecMax.y = v12;
    r_bbStart.m_vecMax.z = v11;
    r_bbEnd.m_vecMin.x = v10;
    r_bbEnd.m_vecMin.y = v9;
    r_bbEnd.m_vecMin.z = v8;
    r_bbEnd.m_vecMax.x = v7;
    r_bbEnd.m_vecMax.y = v6;
    r_bbEnd.m_vecMax.z = v5;
    r_vecCamera.x = v19;
    r_vecCamera.y = v18;
    r_vecCamera.z = v17;
    CStuntJumpManager::AddOne(&r_bbStart, &r_bbEnd, &r_vecCamera, v4);
  }
}

//----- (0046B8A0) --------------------------------------------------------
void __fastcall CFileLoader::LoadTimeCyclesModifier(const unsigned __int8 *pLine)
{
  CVector vecMax; // [sp+28h] [bp-70h] BYREF
  CVector vecMin; // [sp+34h] [bp-64h] BYREF
  RwReal v3; // [sp+40h] [bp-58h] BYREF
  RwReal v4; // [sp+44h] [bp-54h] BYREF
  RwReal v5; // [sp+48h] [bp-50h] BYREF
  RwReal v6; // [sp+4Ch] [bp-4Ch] BYREF
  RwReal v7; // [sp+50h] [bp-48h] BYREF
  RwReal v8; // [sp+54h] [bp-44h] BYREF
  int v9; // [sp+58h] [bp-40h] BYREF
  int v10; // [sp+5Ch] [bp-3Ch] BYREF
  int range; // [sp+60h] [bp-38h] BYREF
  float v12; // [sp+64h] [bp-34h] BYREF
  Int32 v13; // [sp+68h] [bp-30h] BYREF
  Int16 farClip; // [sp+6Ch] [bp-2Ch] BYREF
  CBox v15; // [sp+70h] [bp-28h] BYREF

  range = 1120403456;
  v9 = 1065353216;
  v10 = 1065353216;
  if ( sscanf(
         (const char *)pLine,
         "%f %f %f %f %f %f %d %d %f %f %f %f",
         &v8,
         &v7,
         &v6,
         &v5,
         &v4,
         &v3,
         &farClip,
         &v13,
         &v12,
         &range,
         &v10,
         &v9) <= 11 )
    v9 = v10;
  vecMin.x = v8;
  vecMin.y = v7;
  vecMin.z = v6;
  vecMax.x = v5;
  vecMax.y = v4;
  vecMax.z = v3;
  CBox::Set(&v15, &vecMin, &vecMax);
  CTimeCycle::AddOne(&v15, farClip, v13, v12, *(float *)&range, *(float *)&v9);
}
// 46B8A0: using guessed type float var_34;

//----- (0046B968) --------------------------------------------------------
bool __fastcall CFileLoader::LoadCollisionFileFirstTime(uint8 *pBuffer, uint32 size, uint8 level)
{
  CBaseModelInfo *ModelInfo; // r6
  int v4; // r2
  int v5; // r11
  char v6; // r9
  __int64 v7; // d17
  uint8 *v8; // r4
  uint32 v9; // r8
  unsigned int v10; // r2
  uint32 m_hashKey; // r5
  CColModel *v12; // r5
  int32 v14; // [sp+8h] [bp-40h]
  int32 pIndex; // [sp+Ch] [bp-3Ch] BYREF
  __int64 pString; // [sp+10h] [bp-38h] BYREF
  _QWORD v17[2]; // [sp+18h] [bp-30h]

  v14 = level;
  if ( size >= 9 )
  {
    ModelInfo = 0;
    do
    {
      v4 = *(_DWORD *)pBuffer;
      v5 = *((_DWORD *)pBuffer + 1);
      if ( *(_DWORD *)pBuffer == 1280069443 )
      {
        v6 = 0;
      }
      else if ( v4 == 860639043 )
      {
        v6 = 2;
      }
      else
      {
        if ( v4 != 843861827 )
          return 1;
        v6 = 1;
      }
      v7 = *((_QWORD *)pBuffer + 2);
      v8 = pBuffer + 32;
      v9 = size - 32;
      pString = *((_QWORD *)pBuffer + 1);
      v17[0] = v7;
      *(_QWORD *)((char *)v17 + 6) = *(_QWORD *)(pBuffer + 22);
      v10 = *((unsigned __int16 *)pBuffer + 15);
      pIndex = v10;
      if ( v10 <= 0x4E1F )
        ModelInfo = CModelInfo::ms_modelInfoPtrs[v10];
      if ( ModelInfo
        && (m_hashKey = ModelInfo->m_hashKey, m_hashKey == CKeyGen::GetUppercaseKey((const unsigned __int8 *)&pString))
        || (ModelInfo = CModelInfo::GetModelInfo((const unsigned __int8 *)&pString, &pIndex)) != 0 )
      {
        CColStore::IncludeModelIndex(v14, pIndex);
        if ( (ModelInfo->m_flags & 0x80) != 0 )
        {
          v12 = (CColModel *)CColModel::operator new(0x30u);
          CColModel::CColModel(v12);
          switch ( v6 & 3 )
          {
            case 2:
              CFileLoader::LoadCollisionModelVer3(v8, v5 - 24, v12, (const unsigned __int8 *)&pString);
              break;
            case 1:
              CFileLoader::LoadCollisionModelVer2(v8, v5 - 24, v12, (const unsigned __int8 *)&pString);
              break;
            case 0:
              CFileLoader::LoadCollisionModel(v8, v12, (const unsigned __int8 *)&pString);
              break;
          }
          v12->m_level = v14;
          CBaseModelInfo::SetColModel(ModelInfo, v12, 1);
          CColAccel::addCacheCol(pIndex, v12);
        }
      }
      else
      {
        ModelInfo = 0;
      }
      size = v9 + 24 - v5;
      pBuffer = &v8[v5 - 24];
    }
    while ( size > 8 );
  }
  return 1;
}
// 46B968: using guessed type _QWORD anonymous_0[2];

//----- (0046BAC8) --------------------------------------------------------
void __fastcall ScaleLODDistance(UInt16 index)
{
  CBaseModelInfo *v1; // r0

  v1 = CModelInfo::ms_modelInfoPtrs[index];
  if ( v1 )
    v1->m_lodDistance = (float)(v1->m_lodDistance * TheCamera.LODDistMultiplier) * 1.5;
}

//----- (0046BB04) --------------------------------------------------------
void CStreaming::Init2()
{
  int v0; // r5
  CStreamingInfo *v1; // r4
  uint8 *p_m_status; // r6
  int v3; // r5
  CBaseModelInfo **v4; // r4
  CBaseModelInfo *v5; // r0
  bool v6; // zf
  int v7; // r0
  int v8; // r5
  CPool<TxdDef,TxdDef> *v9; // r1
  uint8 *v10; // r0
  Elf32_Sym *v11; // r2
  CDirectory *v12; // r0
  CDirectory *v13; // r0
  int32 v14; // r5
  CStreamingFile *v15; // r4
  int v16; // t1
  int32 v17; // r0
  __int64 v18; // r0
  int v19; // r0
  bool v20; // zf
  uint32 v21; // r1
  int32 v22; // r0
  CLink<CEntity *> *v23; // r0
  CLink<CEntity *> *v24; // r2
  int v25; // r0
  unsigned int v26; // r1
  CLink<CEntity *> *m_pStore; // r6
  CLink<CEntity *> *v28; // r5

  v0 = 26316;
  v1 = CStreaming::ms_aInfoForModel;
  do
  {
    CStreamingInfo::Init(v1);
    --v0;
    ++v1;
  }
  while ( v0 );
  *(_DWORD *)&CStreaming::ms_aInfoForModel[26312].m_nextIndex = -39223;
  *(_DWORD *)&CStreaming::ms_aInfoForModel[26313].m_nextIndex = 1724448767;
  *(_DWORD *)&CStreaming::ms_aInfoForModel[26314].m_nextIndex = -39221;
  *(_DWORD *)&CStreaming::ms_aInfoForModel[26315].m_nextIndex = 1724579839;
  CStreaming::ms_aInfoForModel[374].m_status = 1;
  CStreaming::ms_aInfoForModel[375].m_status = 1;
  CStreaming::ms_aInfoForModel[376].m_status = 1;
  CStreaming::ms_aInfoForModel[377].m_status = 1;
  CStreaming::ms_aInfoForModel[378].m_status = 1;
  CStreaming::ms_aInfoForModel[379].m_status = 1;
  CStreaming::ms_aInfoForModel[380].m_status = 1;
  CStreaming::ms_aInfoForModel[381].m_status = 1;
  CStreaming::ms_pStartLoadedList = &CStreaming::ms_aInfoForModel[26312];
  CStreamingInfo::ms_pArrayBase = CStreaming::ms_aInfoForModel;
  CStreaming::ms_pEndLoadedList = &CStreaming::ms_aInfoForModel[26313];
  CStreaming::ms_pStartRequestedList = &CStreaming::ms_aInfoForModel[26314];
  CStreaming::ms_bEnableRequestListPurge = 1;
  CStreaming::ms_pEndRequestedList = &CStreaming::ms_aInfoForModel[26315];
  CStreaming::ms_oldSectorY = 0;
  CStreaming::m_bHarvesterModelsRequested = 0;
  CStreaming::ms_channel[0].status = STATUS_IDLE;
  CStreaming::m_bStreamHarvesterModelsThisFrame = 0;
  CStreaming::ms_channel[1].status = STATUS_IDLE;
  CStreaming::ms_oldSectorX = 0;
  CStreaming::ms_disableStreaming = 0;
  CStreaming::ms_streamingBufferSize = 0;
  CStreaming::ms_memoryUsed = 0;
  CStreaming::ms_channelError = -1;
  CStreaming::ms_bLoadingBigModel = 0;
  memset(CStreaming::ms_channel, 255, 0x40u);
  memset(&CStreaming::ms_channel[1], 255, 0x40u);
  p_m_status = &CStreaming::ms_aInfoForModel[0].m_status;
  v3 = 20000;
  v4 = CModelInfo::ms_modelInfoPtrs;
  do
  {
    v5 = *v4;
    v6 = *v4 == 0;
    if ( *v4 )
      v6 = v5->m_pRwObject == 0;
    if ( !v6 )
    {
      v7 = (*((int (__fastcall **)(CBaseModelInfo *))v5->_vptr$CBaseModelInfo + 2))(v5);
      *(p_m_status - 10) = 2;
      *p_m_status = 1;
      if ( v7 )
        *(_BYTE *)(v7 + 34) = -1;
    }
    p_m_status += 20;
    ++v4;
    --v3;
  }
  while ( v3 );
  v8 = 0;
  v9 = CTxdStore::ms_pTxdPool;
  v10 = &CStreaming::ms_aInfoForModel[20000].m_status;
  v11 = 0;
  do
  {
    if ( (v9->m_aFlags[v8] & 0x80u) == 0
      && (Elf32_Sym *)((char *)v11 + (unsigned int)v9->m_aStorage)
      && *(unsigned __int32 *)((char *)&v11->st_name + (unsigned int)v9->m_aStorage) )
    {
      *v10 = 1;
    }
    v11 = (Elf32_Sym *)((char *)v11 + 56);
    v10 += 20;
    ++v8;
  }
  while ( v11 != (Elf32_Sym *)&stru_445BC.st_value );
  CLoadedCarGroup::Clear(&CStreaming::ms_vehiclesLoaded);
  CStreaming::ms_pedsLoaded[0] = -1;
  CStreaming::ms_pedsLoaded[1] = -1;
  CStreaming::ms_pedsLoaded[2] = -1;
  CStreaming::ms_pedsLoaded[3] = -1;
  CStreaming::ms_pedsLoaded[4] = -1;
  CStreaming::ms_pedsLoaded[5] = -1;
  CStreaming::ms_pedsLoaded[6] = -1;
  CStreaming::ms_pedsLoaded[7] = -1;
  CStreaming::ms_numPedsLoaded = 0;
  CStreaming::ms_NextPedToLoadFromGroup[16] = 0;
  CStreaming::ms_NextPedToLoadFromGroup[17] = 0;
  *(_QWORD *)&CStreaming::ms_NextPedToLoadFromGroup[12] = 0LL;
  *(_QWORD *)&CStreaming::ms_NextPedToLoadFromGroup[14] = 0LL;
  *(_QWORD *)&CStreaming::ms_NextPedToLoadFromGroup[8] = 0LL;
  *(_QWORD *)&CStreaming::ms_NextPedToLoadFromGroup[10] = 0LL;
  *(_QWORD *)CStreaming::ms_NextPedToLoadFromGroup = 0LL;
  *(_QWORD *)&CStreaming::ms_NextPedToLoadFromGroup[2] = 0LL;
  *(_QWORD *)&CStreaming::ms_NextPedToLoadFromGroup[4] = 0LL;
  *(_QWORD *)&CStreaming::ms_NextPedToLoadFromGroup[6] = 0LL;
  v12 = (CDirectory *)operator new(0x10u);
  CDirectory::CDirectory(v12, 550);
  CStreaming::ms_loadedGangs = 0;
  CStreaming::ms_lastCullZone = -1;
  CStreaming::ms_numPriorityRequests = 0;
  CStreaming::ms_currentZoneType = -1;
  CStreaming::ms_pExtraObjectsDir = v13;
  CStreamedScripts::Initialise(&CTheScripts::StreamedScripts);
  CModelInfoAccelerator::Begin(&gModelInfoAccelerator, "MODELS\\MINFO.BIN");
  CStreaming::ms_imageOffsets[0] = 0;
  CStreaming::ms_imageOffsets[1] = -1;
  CStreaming::ms_imageOffsets[2] = -1;
  CStreaming::ms_imageOffsets[3] = -1;
  CStreaming::ms_imageOffsets[4] = -1;
  CStreaming::ms_imageOffsets[5] = -1;
  if ( CStreaming::ms_files[0].m_name[0] )
  {
    v14 = 0;
    v15 = CStreaming::ms_files;
    do
    {
      if ( v15->m_bRegister )
        CStreaming::LoadCdDirectory(v15->m_name, v14);
      if ( CLoadingScreen::m_bActive )
      {
        CLoadingScreen::DisplayPCScreen();
        if ( v14 > 6 )
          break;
      }
      else
      {
        if ( bLoadingScene )
          Pump_SwapBuffers();
        if ( v14 > 6 )
          break;
      }
      v16 = v15[1].m_name[0];
      ++v15;
      ++v14;
    }
    while ( v16 );
  }
  CStreaming::ms_lastImageRead = 0;
  CStreaming::ms_imageSize >>= 11;
  CModelInfoAccelerator::End(&gModelInfoAccelerator, "MODELS\\MINFO.BIN");
  v17 = CStreaming::ms_streamingBufferSize;
  if ( (CStreaming::ms_streamingBufferSize & 1) != 0 )
    v17 = ++CStreaming::ms_streamingBufferSize;
  LODWORD(v18) = CMemoryMgr::MallocAlign(v17 << 11, 0x800u);
  CStreaming::ms_streamingBufferSize /= 2;
  HIDWORD(v18) = v18 + (CStreaming::ms_streamingBufferSize << 11);
  *(_QWORD *)CStreaming::ms_pStreamingBuffer = v18;
  v19 = IsLowSpecDevice();
  v20 = v19 == 0;
  v21 = 52428800;
  if ( v19 )
    v21 = 15728640;
  v22 = 22;
  CStreaming::ms_memoryAvailable = v21;
  if ( !v20 )
    v22 = 16;
  CStreaming::desiredNumVehiclesLoaded = v22;
  v23 = (CLink<CEntity *> *)operator new[](0x4650u);
  CStreaming::ms_rwObjectInstances.m_pStore = v23;
  CStreaming::ms_rwObjectInstances.m_firstLink.m_pNext = &CStreaming::ms_rwObjectInstances.m_lastLink;
  v23[1499].m_pNext = &CStreaming::ms_rwObjectInstances.m_lastFreeLink;
  v23[1499].m_pPrev = &CStreaming::ms_rwObjectInstances.m_firstFreeLink;
  CStreaming::ms_rwObjectInstances.m_lastLink.m_pPrev = (CLink<CEntity *> *)&CStreaming::ms_rwObjectInstances;
  CStreaming::ms_rwObjectInstances.m_lastFreeLink.m_pPrev = v23 + 1499;
  CStreaming::ms_rwObjectInstances.m_firstFreeLink.m_pNext = v23 + 1499;
  v23[1498].m_pNext = v23 + 1499;
  v24 = v23 + 1498;
  CStreaming::ms_rwObjectInstances.m_firstFreeLink.m_pNext->m_pPrev = v23 + 1498;
  v23[1498].m_pPrev = &CStreaming::ms_rwObjectInstances.m_firstFreeLink;
  v25 = 1498;
  CStreaming::ms_rwObjectInstances.m_firstFreeLink.m_pNext = v24;
  v26 = 17964;
  do
  {
    m_pStore = CStreaming::ms_rwObjectInstances.m_pStore;
    --v25;
    v28 = &CStreaming::ms_rwObjectInstances.m_pStore[v26 / 0xC];
    v26 -= 12;
    v28->m_pNext = v24;
    CStreaming::ms_rwObjectInstances.m_firstFreeLink.m_pNext->m_pPrev = v28;
    v28->m_pPrev = &CStreaming::ms_rwObjectInstances.m_firstFreeLink;
    CStreaming::ms_rwObjectInstances.m_firstFreeLink.m_pNext = v28;
    v24 = &m_pStore[v25];
  }
  while ( v26 != -12 );
  CStreaming::ms_bIsInitialised = 1;
}
// 46BD88: variable 'v13' is possibly undefined
// 445BC: using guessed type Elf32_Sym stru_445BC;
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (0046BFF8) --------------------------------------------------------
void CStreaming::LoadCdDirectory()
{
  int32 v0; // r5
  CStreamingFile *v1; // r4
  int v2; // t1

  CStreaming::ms_imageOffsets[0] = 0;
  CStreaming::ms_imageOffsets[1] = -1;
  CStreaming::ms_imageOffsets[2] = -1;
  CStreaming::ms_imageOffsets[3] = -1;
  CStreaming::ms_imageOffsets[4] = -1;
  CStreaming::ms_imageOffsets[5] = -1;
  if ( CStreaming::ms_files[0].m_name[0] )
  {
    v0 = 0;
    v1 = CStreaming::ms_files;
    do
    {
      if ( v1->m_bRegister )
        CStreaming::LoadCdDirectory(v1->m_name, v0);
      if ( CLoadingScreen::m_bActive )
      {
        CLoadingScreen::DisplayPCScreen();
        if ( v0 > 6 )
          break;
      }
      else
      {
        if ( bLoadingScene )
          Pump_SwapBuffers();
        if ( v0 > 6 )
          break;
      }
      v2 = v1[1].m_name[0];
      ++v1;
      ++v0;
    }
    while ( v2 );
  }
  CStreaming::ms_lastImageRead = 0;
  CStreaming::ms_imageSize >>= 11;
}

//----- (0046C0AC) --------------------------------------------------------
void __fastcall CStreaming::LoadCdDirectory(const unsigned __int8 *pDirName, int32 imgIndex)
{
  u_native v3; // r0
  void *v4; // r6
  unsigned int v5; // r4
  int v6; // r8
  bool v7; // zf
  int32 v8; // r6
  const CDirectory::DirectoryInfo *v9; // r11
  int32 v10; // r0
  int32 TxdSlot; // r0
  int v12; // r1
  int32 IplSlot; // r0
  int32 v14; // r8
  int32 v15; // r0
  uint32 realSize; // r2
  int16 v17; // r0
  char *v18; // r8
  unsigned __int8 *dbName; // [sp+Ch] [bp-6Ch]
  CDirectory::DirectoryInfo *p; // [sp+14h] [bp-64h]
  int buffer; // [sp+40h] [bp-38h] BYREF
  unsigned __int8 pData[4]; // [sp+44h] [bp-34h] BYREF
  char v24; // [sp+48h] [bp-30h]
  CBaseModelInfo *ppModelInfo; // [sp+4Ch] [bp-2Ch] BYREF
  int32 pIndex; // [sp+50h] [bp-28h] BYREF
  uint32 size; // [sp+54h] [bp-24h] BYREF
  uint32 posn[8]; // [sp+58h] [bp-20h] BYREF

  v3 = CFileMgr::OpenFile(pDirName, (const unsigned __int8 *)&dword_46C3DC);
  v4 = (void *)v3;
  if ( v3 )
  {
    v24 = 0;
    dbName = (unsigned __int8 *)pDirName;
    *(_DWORD *)pData = 0;
    CFileMgr::ReadBytes(v3, pData, 4);
    OS_FileRead(v4, &buffer, 4);
    v5 = OS_TimeMS();
    v6 = 32 * buffer;
    p = (CDirectory::DirectoryInfo *)malloc(32 * buffer);
    OS_FileRead(v4, p, v6);
    CFileMgr::CloseFile((u_native)v4);
    v7 = buffer-- == 0;
    if ( !v7 )
    {
      v8 = -1;
      v9 = p;
      while ( 1 )
      {
        if ( OS_TimeMS() - v5 >= 0x22 )
        {
          if ( CLoadingScreen::m_bActive )
          {
            CLoadingScreen::DisplayPCScreen();
          }
          else if ( bLoadingScene )
          {
            Pump_SwapBuffers();
          }
          v5 = OS_TimeMS();
        }
        if ( CStreaming::ms_streamingBufferSize < v9->size )
          CStreaming::ms_streamingBufferSize = v9->size;
        v9->name[23] = 0;
        v18 = strchr((const char *)v9->name, 46);
        if ( !v18 || v18 - (char *)v9->name >= 21 )
          break;
        *v18 = 0;
        if ( !strncasecmp(v18 + 1, (const char *)&off_46C3F0, 3u) )
        {
          CModelInfoAccelerator::GetEntry(&gModelInfoAccelerator, &ppModelInfo, &pIndex, v9->name);
          if ( ppModelInfo )
          {
            v10 = pIndex;
            goto LABEL_22;
          }
          v9->posn |= imgIndex << 24;
          CDirectory::AddItem(CStreaming::ms_pExtraObjectsDir, v9);
        }
        else
        {
          if ( !strncasecmp(v18 + 1, (const char *)&dword_46C3F4, 3u) )
          {
            TxdSlot = CTxdStore::FindTxdSlot(v9->name);
            pIndex = TxdSlot;
            if ( TxdSlot == -1 )
            {
              TxdSlot = CTxdStore::AddTxdSlot(v9->name, dbName, 0);
              pIndex = TxdSlot;
            }
            v12 = 20000;
LABEL_21:
            v10 = TxdSlot + v12;
            pIndex = v10;
LABEL_22:
            v14 = v8;
LABEL_23:
            if ( !CStreamingInfo::GetCdPosnAndSize(&CStreaming::ms_aInfoForModel[v10], posn, &size) )
            {
              v15 = pIndex;
              CStreaming::ms_aInfoForModel[pIndex].m_image = imgIndex;
              realSize = v9->realSize;
              if ( v9->realSize )
                v9->size = realSize;
              else
                realSize = v9->size;
              CStreamingInfo::SetCdPosnAndSize(&CStreaming::ms_aInfoForModel[v15], v9->posn, realSize);
              v17 = pIndex;
              v8 = pIndex;
              CStreaming::ms_aInfoForModel[pIndex].m_flags = 0;
              if ( v14 != -1 )
                CStreaming::ms_aInfoForModel[v14].m_nextModelOnCd = v17;
              goto LABEL_51;
            }
LABEL_50:
            v8 = -1;
            goto LABEL_51;
          }
          if ( !strncasecmp(v18 + 1, (const char *)&dword_46C3F8, 3u) )
          {
            TxdSlot = CColStore::FindColSlot(v9->name);
            pIndex = TxdSlot;
            if ( TxdSlot == -1 )
            {
              TxdSlot = CColStore::AddColSlot(v9->name);
              pIndex = TxdSlot;
            }
            v12 = 25000;
            goto LABEL_21;
          }
          if ( !strncasecmp(v18 + 1, (const char *)&dword_46C3FC, 3u) )
          {
            IplSlot = CIplStore::FindIplSlot(v9->name);
            v14 = v8;
            pIndex = IplSlot;
            if ( IplSlot == -1 )
            {
              IplSlot = CIplStore::AddIplSlot(v9->name);
              pIndex = IplSlot;
            }
            v10 = IplSlot + 25255;
            pIndex = v10;
            goto LABEL_23;
          }
          if ( !strncasecmp(v18 + 1, (const char *)&dword_46C400, 3u) )
          {
            sscanf((const char *)&v9->name[5], (const char *)&dword_46C414, &pIndex);
            TxdSlot = pIndex;
            v12 = 25511;
            goto LABEL_21;
          }
          if ( !strncasecmp(v18 + 1, (const char *)&dword_46C404, 3u) )
          {
            TxdSlot = CAnimManager::RegisterAnimBlock(v9->name);
            v12 = 25575;
            goto LABEL_21;
          }
          if ( !strncasecmp(v18 + 1, (const char *)&dword_46C408, 3u) )
          {
            TxdSlot = CVehicleRecording::RegisterRecordingFile(v9->name);
            v12 = 25755;
            goto LABEL_21;
          }
          if ( !strncasecmp(v18 + 1, (const char *)&dword_46C40C, 3u) )
          {
            TxdSlot = CStreamedScripts::RegisterScript(&CTheScripts::StreamedScripts, v9->name);
            v12 = 26230;
            goto LABEL_21;
          }
          *v18 = 46;
        }
        v8 = -1;
LABEL_51:
        ++v9;
        v7 = buffer-- == 0;
        if ( v7 )
          goto LABEL_53;
      }
      v9->name[23] = 0;
      goto LABEL_50;
    }
LABEL_53:
    free(p);
  }
}
// 46C3DC: using guessed type int dword_46C3DC;
// 46C3F0: using guessed type char (***off_46C3F0)[8];
// 46C3F4: using guessed type int dword_46C3F4;
// 46C3F8: using guessed type int dword_46C3F8;
// 46C3FC: using guessed type int dword_46C3FC;
// 46C400: using guessed type int dword_46C400;
// 46C404: using guessed type int dword_46C404;
// 46C408: using guessed type int dword_46C408;
// 46C40C: using guessed type int dword_46C40C;
// 46C414: using guessed type int dword_46C414;
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];
// 46C0AC: using guessed type uint32 posn[8];

//----- (0046C430) --------------------------------------------------------
void CVehicleModelInfo::LoadVehicleColours()
{
  u_native v0; // r4
  int v1; // r9
  unsigned __int8 *v2; // r11
  int v3; // r0
  int v4; // r3
  unsigned __int8 *v5; // r2
  unsigned __int8 *v6; // r1
  char v7; // t1
  bool v8; // zf
  int v9; // r2
  bool v10; // zf
  int v11; // r0
  bool v12; // zf
  RwRGBA_0 *v13; // r1
  RwUInt8 v14; // r0
  int v15; // r0
  int v16; // r1
  int v17; // r2
  bool v18; // zf
  int v19; // r2
  bool v20; // zf
  int v21; // kr00_4
  CBaseModelInfo *ModelInfo; // r0
  int v23; // r1
  _DWORD *v24; // r2
  _BYTE *v25; // r6
  int v26; // r3
  int v27; // kr04_4
  CBaseModelInfo *v28; // r0
  int v29; // r1
  char *v30; // r2
  _BYTE *v31; // r6
  int v32; // r3
  u_native v33; // [sp+C0h] [bp-530h]
  int v34; // [sp+C4h] [bp-52Ch]
  char v35; // [sp+104h] [bp-4ECh] BYREF
  char v36; // [sp+108h] [bp-4E8h] BYREF
  _BYTE v37[8]; // [sp+10Ch] [bp-4E4h] BYREF
  char v38; // [sp+114h] [bp-4DCh] BYREF
  char v39; // [sp+118h] [bp-4D8h] BYREF
  char v40; // [sp+11Ch] [bp-4D4h] BYREF
  char v41; // [sp+120h] [bp-4D0h] BYREF
  char v42; // [sp+124h] [bp-4CCh] BYREF
  char v43; // [sp+128h] [bp-4C8h] BYREF
  char v44; // [sp+12Ch] [bp-4C4h] BYREF
  char v45; // [sp+130h] [bp-4C0h] BYREF
  char v46; // [sp+134h] [bp-4BCh] BYREF
  char v47; // [sp+138h] [bp-4B8h] BYREF
  char v48; // [sp+13Ch] [bp-4B4h] BYREF
  char v49; // [sp+140h] [bp-4B0h] BYREF
  char v50; // [sp+144h] [bp-4ACh] BYREF
  char v51; // [sp+148h] [bp-4A8h] BYREF
  char v52; // [sp+14Ch] [bp-4A4h] BYREF
  char v53; // [sp+150h] [bp-4A0h] BYREF
  char v54; // [sp+154h] [bp-49Ch] BYREF
  char v55; // [sp+158h] [bp-498h] BYREF
  char v56; // [sp+15Ch] [bp-494h] BYREF
  char v57; // [sp+160h] [bp-490h] BYREF
  char v58; // [sp+164h] [bp-48Ch] BYREF
  char v59; // [sp+168h] [bp-488h] BYREF
  char v60; // [sp+16Ch] [bp-484h] BYREF
  char v61; // [sp+170h] [bp-480h] BYREF
  char v62; // [sp+174h] [bp-47Ch] BYREF
  char v63; // [sp+178h] [bp-478h] BYREF
  char v64; // [sp+17Ch] [bp-474h] BYREF
  char v65; // [sp+180h] [bp-470h] BYREF
  int v66; // [sp+184h] [bp-46Ch] BYREF
  int v67; // [sp+188h] [bp-468h] BYREF
  int v68; // [sp+18Ch] [bp-464h] BYREF
  unsigned __int8 v69[64]; // [sp+190h] [bp-460h] BYREF
  char pLine[1024]; // [sp+1D0h] [bp-420h] BYREF

  v0 = CFileMgr::OpenFile("DATA\\CARCOLS.DAT", "r");
  if ( !CFileMgr::ReadLine(v0, (unsigned __int8 *)pLine, 1024) )
    goto LABEL_57;
  v1 = 0;
  v33 = v0;
  v34 = 0;
  do
  {
    v2 = (unsigned __int8 *)pLine;
    v3 = 0;
    do
    {
      v4 = (unsigned __int8)pLine[v3];
      v5 = v2++;
      ++v3;
    }
    while ( v4 != 10 && (unsigned __int8)(v4 - 1) < 0x20u );
    v6 = (unsigned __int8 *)&pLine[v3];
    while ( 1 )
    {
      if ( (unsigned __int8)v4 > 0x2Bu )
      {
        if ( (unsigned __int8)v4 == 44 )
          *v5 = 32;
        goto LABEL_7;
      }
      if ( (unsigned __int8)v4 == 13 )
      {
        *v5 = 32;
        goto LABEL_7;
      }
      v8 = (unsigned __int8)v4 == 0;
      if ( (_BYTE)v4 )
        v8 = (unsigned __int8)v4 == 10;
      if ( v8 )
        break;
LABEL_7:
      v7 = *++v5;
      LOBYTE(v4) = v7;
    }
    *v5 = 0;
    v9 = *(v6 - 1);
    v10 = v9 == 0;
    if ( *(v6 - 1) )
      v10 = v9 == 35;
    if ( v10 )
      continue;
    if ( !v1 )
    {
      if ( v9 == 99 )
      {
        v17 = (unsigned __int8)pLine[v3];
        v18 = v17 == 111;
        if ( v17 == 111 )
          v18 = v6[1] == 108;
        if ( v18 )
        {
LABEL_44:
          v1 = 1;
          continue;
        }
        if ( pLine[v3] == 97 )
        {
          v19 = v6[1];
          v20 = v19 == 114;
          if ( v19 == 114 )
            v20 = v6[2] == 52;
          if ( v20 )
          {
            v1 = 3;
            continue;
          }
        }
        if ( pLine[v3] == 97 )
        {
          v1 = 0;
          if ( v6[1] == 114 )
            v1 = 2;
          continue;
        }
      }
LABEL_43:
      v1 = 0;
      continue;
    }
    if ( v9 == 101 )
    {
      v11 = (unsigned __int8)pLine[v3];
      v12 = v11 == 110;
      if ( v11 == 110 )
        v12 = v6[1] == 100;
      if ( v12 )
        goto LABEL_43;
    }
    if ( v1 == 3 )
    {
      v21 = sscanf(
              pLine,
              "%s %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d",
              v69,
              &v35,
              &v36,
              v37,
              &v37[4],
              &v38,
              &v39,
              &v40,
              &v41,
              &v42,
              &v43,
              &v44,
              &v45,
              &v46,
              &v47,
              &v48,
              &v49,
              &v50,
              &v51,
              &v52,
              &v53,
              &v54,
              &v55,
              &v56,
              &v57,
              &v58,
              &v59,
              &v60,
              &v61,
              &v62,
              &v63,
              &v64,
              &v65)
          - 1;
      ModelInfo = CModelInfo::GetModelInfo(v69, 0);
      LOBYTE(ModelInfo[15].m_txdIndex) = v21 / 4;
      if ( (unsigned __int8)(v21 / 4) )
      {
        v0 = v33;
        v23 = 0;
        v24 = v37;
        do
        {
          v25 = (char *)ModelInfo + v23++;
          v1 = 3;
          v25[840] = *(v24 - 2);
          v25[848] = *(v24 - 1);
          v25[856] = *v24;
          v26 = v24[1];
          v24 += 4;
          v25[864] = v26;
        }
        while ( v23 < LOBYTE(ModelInfo[15].m_txdIndex) );
      }
      else
      {
        v1 = 3;
        v0 = v33;
      }
    }
    else
    {
      if ( v1 != 2 )
      {
        sscanf(pLine, "%d %d %d", &v68, &v67, &v66);
        CVehicleModelInfo::ms_vehicleColourTable[v34]._anon_0._anon_0.red = v68;
        v13 = &CVehicleModelInfo::ms_vehicleColourTable[v34];
        v13->_anon_0._anon_0.green = v67;
        v14 = v66;
        v13->_anon_0._anon_0.alpha = -1;
        v13->_anon_0._anon_0.blue = v14;
        v15 = -1;
        do
          v16 = v2[v15++];
        while ( v16 != 35 );
        ++v34;
        goto LABEL_44;
      }
      v27 = sscanf(
              pLine,
              "%s %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d",
              v69,
              &v35,
              &v36,
              &v38,
              &v39,
              &v42,
              &v43,
              &v46,
              &v47,
              &v50,
              &v51,
              &v54,
              &v55,
              &v58,
              &v59,
              &v62,
              &v63)
          - 1;
      v28 = CModelInfo::GetModelInfo(v69, 0);
      LOBYTE(v28[15].m_txdIndex) = v27 / 2;
      if ( (unsigned __int8)(v27 / 2) )
      {
        v0 = v33;
        v29 = 0;
        v30 = &v36;
        do
        {
          v31 = (char *)v28 + v29++;
          v1 = 2;
          v31[840] = *((_DWORD *)v30 - 1);
          v32 = *(_DWORD *)v30;
          v30 += 16;
          v31[856] = 0;
          v31[848] = v32;
          v31[864] = 0;
        }
        while ( v29 < LOBYTE(v28[15].m_txdIndex) );
      }
      else
      {
        v1 = 2;
        v0 = v33;
      }
    }
  }
  while ( CFileMgr::ReadLine(v0, (unsigned __int8 *)pLine, 1024) );
LABEL_57:
  CFileMgr::CloseFile(v0);
}
// 46C5BE: conditional instruction was optimized away because r9.4==1
// 46C430: using guessed type char pLine[1024];

//----- (0046C87C) --------------------------------------------------------
void CVehicleModelInfo::LoadVehicleUpgrades()
{
  u_native v0; // r8
  int v1; // r6
  char *Line; // r11
  int v3; // r0
  bool v4; // zf
  char *v5; // r0
  CBaseModelInfo *v6; // r5
  int v7; // r11
  char *v8; // r6
  CAtomicModelInfo *v9; // r0
  CAtomicModelInfo *v10; // r0
  char *v11; // r9
  CAtomicModelInfo *v12; // r0
  char *v13; // r0
  const unsigned __int8 *v14; // r6
  CAtomicModelInfo *ModelInfo; // r0
  char *v16; // r6
  CAtomicModelInfo *v17; // r0
  CAtomicModelInfo *v18; // r0
  char *v19; // r0
  const unsigned __int8 *v20; // r6
  int16 m2[2]; // [sp+4h] [bp-24h] BYREF
  int32 pIndex[8]; // [sp+8h] [bp-20h] BYREF

  v0 = CFileMgr::OpenFile("DATA\\CARMODS.DAT", "r");
  v1 = 0;
  *(_DWORD *)&CVehicleModelInfo::ms_numWheelUpgrades[2] = 0;
  *(_DWORD *)CVehicleModelInfo::ms_numWheelUpgrades = 0;
  Line = (char *)CFileLoader::LoadLine(v0);
  if ( Line )
  {
    while ( 1 )
    {
      v3 = (unsigned __int8)*Line;
      v4 = v3 == 0;
      if ( *Line )
        v4 = v3 == 35;
      if ( v4 )
        goto LABEL_29;
      if ( !v1 )
        break;
      if ( !strncmp((const char *)&off_46CA9C, Line, 3u) )
        v1 = 0;
      switch ( v1 )
      {
        case 1:
          *(_DWORD *)m2 = -1;
          pIndex[0] = -1;
          v13 = strtok(Line, (const char *)CVehicleModelInfo::LoadVehicleUpgrades(void)::whitespace);
          v14 = (const unsigned __int8 *)v13;
          if ( v13 )
          {
            ModelInfo = (CAtomicModelInfo *)CModelInfo::GetModelInfo((const unsigned __int8 *)v13, pIndex);
            CAtomicModelInfo::SetupVehicleUpgradeFlags(ModelInfo, v14);
            v16 = strtok(0, (const char *)CVehicleModelInfo::LoadVehicleUpgrades(void)::whitespace);
            v17 = (CAtomicModelInfo *)CModelInfo::GetModelInfo((const unsigned __int8 *)v16, (int32 *)m2);
            CAtomicModelInfo::SetupVehicleUpgradeFlags(v17, (const unsigned __int8 *)v16);
            CVehicleModelInfo::CLinkedUpgradeList::AddUpgradeLink(
              &CVehicleModelInfo::ms_linkedUpgrades,
              pIndex[0],
              m2[0]);
          }
LABEL_23:
          v1 = 1;
          break;
        case 3:
          *(_DWORD *)m2 = -1;
          sscanf(Line, (const char *)&dword_46CAA0, pIndex);
          strtok(Line, (const char *)CVehicleModelInfo::LoadVehicleUpgrades(void)::whitespace);
          while ( 1 )
          {
            v19 = strtok(0, (const char *)CVehicleModelInfo::LoadVehicleUpgrades(void)::whitespace);
            v20 = (const unsigned __int8 *)v19;
            if ( !v19 )
              break;
            v18 = (CAtomicModelInfo *)CModelInfo::GetModelInfo((const unsigned __int8 *)v19, (int32 *)m2);
            CAtomicModelInfo::SetupVehicleUpgradeFlags(v18, v20);
            CVehicleModelInfo::AddWheelUpgrade(pIndex[0], *(int32 *)m2);
          }
          v1 = 3;
          break;
        case 2:
          v5 = strtok(Line, (const char *)CVehicleModelInfo::LoadVehicleUpgrades(void)::whitespace);
          if ( v5 )
          {
            pIndex[0] = -1;
            v6 = CModelInfo::GetModelInfo((const unsigned __int8 *)v5, pIndex);
            v7 = 0;
            v8 = strtok(0, (const char *)CVehicleModelInfo::LoadVehicleUpgrades(void)::whitespace);
            if ( v8 )
            {
              v7 = 0;
              do
              {
                v9 = (CAtomicModelInfo *)CModelInfo::GetModelInfo((const unsigned __int8 *)v8, pIndex);
                CAtomicModelInfo::SetupVehicleUpgradeFlags(v9, (const unsigned __int8 *)v8);
                *(&v6[15].m_dynamicIndex + v7++) = pIndex[0];
                v8 = strtok(0, (const char *)CVehicleModelInfo::LoadVehicleUpgrades(void)::whitespace);
              }
              while ( v8 );
            }
            v10 = (CAtomicModelInfo *)CModelInfo::GetModelInfo("hydralics", pIndex);
            CAtomicModelInfo::SetupVehicleUpgradeFlags(v10, "hydralics");
            v11 = (char *)v6 + 2 * v7;
            *((_WORD *)v11 + 439) = pIndex[0];
            v12 = (CAtomicModelInfo *)CModelInfo::GetModelInfo("stereo", pIndex);
            CAtomicModelInfo::SetupVehicleUpgradeFlags(v12, "stereo");
            v1 = 2;
            *((_WORD *)v11 + 440) = pIndex[0];
            break;
          }
          goto LABEL_28;
      }
LABEL_29:
      Line = (char *)CFileLoader::LoadLine(v0);
      if ( !Line )
        goto LABEL_30;
    }
    if ( strncmp("link", Line, 4u) )
    {
      if ( strncmp("mods", Line, 4u) )
      {
        v1 = 0;
        if ( !strncmp("wheel", Line, 5u) )
          v1 = 3;
        goto LABEL_29;
      }
LABEL_28:
      v1 = 2;
      goto LABEL_29;
    }
    goto LABEL_23;
  }
LABEL_30:
  CFileMgr::CloseFile(v0);
}
// 46CA9C: using guessed type void *off_46CA9C;
// 46CAA0: using guessed type int dword_46CAA0;

//----- (0046CAE8) --------------------------------------------------------
RwTexture_0 *__fastcall CreateCarColourTexture(uint8 r, uint8 g, uint8 b)
{
  RwImage_0 *v6; // r8
  RwUInt8 *v7; // r5
  RwRaster_0 *v8; // r4
  RwInt32 v10; // [sp+8h] [bp-28h] BYREF
  RwInt32 npDepth; // [sp+Ch] [bp-24h] BYREF
  RwInt32 npHeight; // [sp+10h] [bp-20h] BYREF
  RwInt32 npWidth[7]; // [sp+14h] [bp-1Ch] BYREF

  v6 = RwImageCreate(2, 2, 32);
  v7 = (RwUInt8 *)CMemoryMgr::Malloc(0x10u);
  *v7 = r;
  v7[1] = g;
  v7[2] = b;
  v7[3] = -1;
  v7[4] = r;
  v7[5] = g;
  v7[6] = b;
  v7[7] = -1;
  v7[8] = r;
  v7[9] = g;
  v7[10] = b;
  v7[11] = -1;
  v7[12] = r;
  v7[13] = g;
  v7[14] = b;
  v7[15] = -1;
  v6->stride = 8;
  v6->cpPixels = v7;
  RwImageFindRasterFormat(v6, 4, npWidth, &npHeight, &npDepth, &v10);
  v8 = RwRasterCreate(npWidth[0], npHeight, npDepth, v10);
  RwRasterSetFromImage(v8, v6);
  RwImageDestroy(v6);
  CMemoryMgr::Free(v7);
  return RwTextureCreate(v8);
}
// 46CAE8: using guessed type RwInt32 npWidth[7];

//----- (0046CB80) --------------------------------------------------------
Bool8 __fastcall CAudioEngine::Initialise(CAudioEngine *this)
{
  UInt16 m_nAvailableChannels; // r1
  int v3; // r0
  char *v4; // r3
  _WORD *v5; // r3
  int v6; // r5
  int v7; // t1
  Bool8 v8; // r5
  __int64 v9; // r2
  u_native v10; // r0
  u_native v11; // r5
  int32 Bytes; // r6
  int v13; // r4
  float *v14; // r6
  float v15; // r0
  UInt8 *p_SurfaceB; // r0
  int v17; // r1

  CLoadingScreen::Pause();
  if ( !CAEAudioHardware::Initialise(&AEAudioHardware) )
    return 0;
  m_nAvailableChannels = AEAudioHardware.m_nAvailableChannels;
  if ( AEAudioHardware.m_nAvailableChannels )
  {
    v3 = 0;
    while ( 1 )
    {
      v4 = (char *)&AEAudioHardware + 2 * v3;
      v7 = *((unsigned __int16 *)v4 + 38);
      v5 = v4 + 76;
      v6 = v7;
      if ( !v7 )
        break;
      v3 += v6;
      if ( v3 > 29 )
        goto LABEL_6;
    }
    *v5 = 1;
    AEAudioHardware.m_nAvailableChannels = m_nAvailableChannels - 1;
  }
  else
  {
LABEL_6:
    LOWORD(v3) = -1;
  }
  this->m_nAudioStreamClientHandle = (__int16)v3;
  CAERadioTrackManager::Initialise(&AERadioTrackManager, (__int16)v3);
  v8 = 0;
  AECutsceneTrackManager.m_nHardwareClientHandle = this->m_nAudioStreamClientHandle;
  AECutsceneTrackManager.m_RequestedSettings.TrackLengthMs = 0;
  *(_WORD *)&AECutsceneTrackManager.m_bStartCutscenePlayback = 0;
  AECutsceneTrackManager.m_RequestedSettings.TrackFlags = 0;
  HIDWORD(v9) = 8;
  *(_QWORD *)&AECutsceneTrackManager.m_nCutsceneStatus = 0xFFFFFFFF00000008LL;
  *(_QWORD *)&AECutsceneTrackManager.m_RequestedSettings.PlayingTrackID = 0xFFFFFFFFLL;
  LODWORD(v9) = this->m_nAudioStreamClientHandle;
  *(_QWORD *)&AEAmbienceTrackManager.m_nHardwareClientHandle = v9;
  AEAmbienceTrackManager.m_RequestedSettings.TrackFlags = 3;
  AEAmbienceTrackManager.m_fAmbienceVolume = -100.0;
  AEAmbienceTrackManager.m_fAmbienceFrequencyScalingFactor = 1.0;
  AEAmbienceTrackManager.m_RequestedSettings.TrackID = -1;
  AEAmbienceTrackManager.m_RequestedSettings.PlayingTrackID = -1;
  if ( CAESoundManager::Initialise(&AESoundManager) )
  {
    CAEAudioEntity::m_pAudioEventVolumes = (char *)operator new[](0xB159u);
    v10 = CFileMgr::OpenFile("AUDIO\\CONFIG\\EVENTVOL.DAT", "r");
    v11 = v10;
    if ( v10 )
    {
      Bytes = CFileMgr::ReadBytes(v10, (unsigned __int8 *)CAEAudioEntity::m_pAudioEventVolumes, 45401);
      CFileMgr::CloseFile(v11);
      if ( Bytes == 45401 )
      {
        CAEFrontendAudioEntity::Initialise(&this->m_FrontendAudioEntity);
        CAudioEngine::SetEffectsFaderScalingFactor(this, 0.0);
        v13 = 47;
        *(_QWORD *)&CAEAudioUtility::m_sfLogLookup[0][0] = 0xC2C8000000000000LL;
        *(_QWORD *)&CAEAudioUtility::m_sfLogLookup[1][0] = 0xC2C800003727C5ACLL;
        v14 = CAEAudioUtility::m_sfLogLookup[2];
        do
        {
          v15 = powf(1.2, (float)v13--);
          *v14 = 10.0 / v15;
          v14 += 2;
        }
        while ( v13 != -1 );
        CAEAudioUtility::m_sfLogLookup[1][1] = log10f(10.0 / v15);
        CAEAudioHardware::LoadSoundBank(&AEAudioHardware, 0, 41);
        CAEAudioHardware::LoadSoundBank(&AEAudioHardware, 0x80u, 32);
        CAEPedSpeechAudioEntity::StaticInitialise();
        CAEVehicleAudioEntity::s_DummyEngineSlots[8] = (tDummyEngineSlot)0xFFFF;
        CAEVehicleAudioEntity::s_DummyEngineSlots[9] = (tDummyEngineSlot)0xFFFF;
        *(_QWORD *)&CAEVehicleAudioEntity::s_DummyEngineSlots[0].BankId = 0xFFFF0000FFFFLL;
        *(_QWORD *)&CAEVehicleAudioEntity::s_DummyEngineSlots[2].BankId = 0xFFFF0000FFFFLL;
        *(_QWORD *)&CAEVehicleAudioEntity::s_DummyEngineSlots[4].BankId = 0xFFFF0000FFFFLL;
        *(_QWORD *)&CAEVehicleAudioEntity::s_DummyEngineSlots[6].BankId = 0xFFFF0000FFFFLL;
        CAEAudioHardware::LoadSoundBank(&AEAudioHardware, 0x8Au, 19);
        CAEAudioHardware::LoadSoundBank(&AEAudioHardware, 0xDu, 18);
        CAEAudioHardware::LoadSoundBank(&AEAudioHardware, 0x4Au, 17);
        CAEVehicleAudioEntity::s_pPlayerAttachedForRadio = 0;
        CAEVehicleAudioEntity::s_pVehicleAudioSettingsForRadio = 0;
        CAEVehicleAudioEntity::s_pPlayerDriver = 0;
        CAEVehicleAudioEntity::s_NextDummyEngineSlot = 0;
        CAEVehicleAudioEntity::s_HelicoptorsDisabled = 0;
        CAEAudioHardware::LoadSoundBank(&AEAudioHardware, 0x34u, 4);
        CAEAudioHardware::LoadSoundBank(&AEAudioHardware, 0x69u, 6);
        CAEAudioHardware::LoadSoundBank(&AEAudioHardware, 0x33u, 31);
        CAEAudioHardware::LoadSoundBank(&AEAudioHardware, 0x34u, 4);
        CAEPoliceScannerAudioEntity::s_NextNewScannerDialogueTime = 0;
        CAEPoliceScannerAudioEntity::s_bScannerDisabled = 0;
        CAEPoliceScannerAudioEntity::s_nScannerPlaybackState = 0;
        CAEPoliceScannerAudioEntity::s_pPSControlling = 0;
        CAEPoliceScannerAudioEntity::s_pCurrentSlots = 0;
        CAEPoliceScannerAudioEntity::s_fVolumeOffset = 0.0;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[0].vAudioPosition.x = -1000.0;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[0].vAudioPosition.y = -1000.0;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[0].vAudioPosition.z = -1000.0;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[0].pAttachedPhysical = 0;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[0].pSound = 0;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[0].AudioEvent = -1;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[0].BankID = -1;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[0].SoundID = -1;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[1].vAudioPosition.x = -1000.0;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[1].vAudioPosition.y = -1000.0;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[1].vAudioPosition.z = -1000.0;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[1].pAttachedPhysical = 0;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[1].pSound = 0;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[1].AudioEvent = -1;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[1].BankID = -1;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[1].SoundID = -1;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[2].vAudioPosition.x = -1000.0;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[2].vAudioPosition.y = -1000.0;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[2].vAudioPosition.z = -1000.0;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[2].pAttachedPhysical = 0;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[2].pSound = 0;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[2].AudioEvent = -1;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[2].BankID = -1;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[2].SoundID = -1;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[3].vAudioPosition.x = -1000.0;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[3].vAudioPosition.y = -1000.0;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[3].vAudioPosition.z = -1000.0;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[3].pAttachedPhysical = 0;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[3].pSound = 0;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[3].AudioEvent = -1;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[3].BankID = -1;
        this->m_ScriptAudioEntity.m_MissionSlotSettings[3].SoundID = -1;
        CAEPedlessSpeechAudioEntity::Initialise(&this->m_PedlessSpeechAudioEntity);
        p_SurfaceB = &this->m_CollisionAudioEntity.m_CollisionSoundList[0].SurfaceB;
        v17 = 300;
        this->m_CollisionAudioEntity.m_nActiveCollisionSounds = 0;
        do
        {
          *(_WORD *)(p_SurfaceB - 1) = -15421;
          --v17;
          *(_DWORD *)(p_SurfaceB - 18) = 0;
          *(_DWORD *)(p_SurfaceB - 14) = 0;
          *(_DWORD *)(p_SurfaceB - 10) = 0;
          *(_DWORD *)(p_SurfaceB - 6) = 0;
          *(p_SurfaceB - 2) = 0;
          p_SurfaceB += 20;
        }
        while ( v17 );
        memset(this->m_CollisionAudioEntity.m_CollisionSoundIDHistory, 255, 0x188u);
        this->m_nActiveRadioStationBeforeCutscene = -1;
        *(_WORD *)&this->m_bPlayingMissionCompleteTrack = 0;
        CLoadingScreen::Continue();
        return 1;
      }
    }
    return 0;
  }
  return v8;
}

//----- (0046CF34) --------------------------------------------------------
Int16 __fastcall CAEAudioHardware::AllocateChannels(CAEAudioHardware *this, UInt16 NumChannels)
{
  int v2; // r12
  char *v3; // r3
  int v4; // r2
  UInt16 *v5; // r3
  int v6; // t1

  if ( (unsigned __int16)(NumChannels - 1) >= (unsigned int)this->m_nAvailableChannels )
    return -1;
  v2 = 0;
  while ( 1 )
  {
    v3 = (char *)this + 2 * v2;
    v6 = *((unsigned __int16 *)v3 + 38);
    v5 = (UInt16 *)(v3 + 76);
    v4 = v6;
    if ( !v6 )
      break;
    v2 += v4;
    if ( v2 > 29 )
      return -1;
  }
  *v5 = NumChannels;
  this->m_nAvailableChannels -= NumChannels;
  return v2;
}

//----- (0046CF80) --------------------------------------------------------
Bool8 __fastcall CAERadioTrackManager::Initialise(CAERadioTrackManager *this, int HardwareClientHandle)
{
  Int32 (*v3)[15]; // r10
  Int32 (*v4)[40]; // r11
  Int32 (*v5)[8]; // r4
  Int8 *v6; // r5
  Int32 *FullFavoriteRadioStationList; // r1
  __int64 v8; // d20
  __int64 *v9; // r0
  __int64 v10; // d16
  __int64 v11; // d17
  __int64 v12; // d22
  __int64 v13; // d23
  int v14; // r9
  __int64 v15; // d18
  __int64 v16; // d19
  Int32 *v17; // r0
  int v18; // r6
  Bool8 *v19; // r0
  __int64 v20; // d18
  __int64 v21; // d19
  __int64 v22; // d20
  __int64 v23; // d21
  __int64 v24; // d16
  __int64 v25; // d17
  __int64 v26; // d18
  __int64 v27; // d19
  CAERadioTrackManager *v29; // [sp+4h] [bp-44h]

  v3 = CAERadioTrackManager::m_nDJBanterIndexHistory;
  this->m_nHardwareClientHandle = HardwareClientHandle;
  this->m_nRadioStatus = 7;
  v4 = CAERadioTrackManager::m_nAdvertIndexHistory;
  *(_WORD *)&this->m_bStationChangePending = 0;
  v5 = CAERadioTrackManager::m_nIdentIndexHistory;
  v6 = CAERadioTrackManager::m_nMusicTrackIndexHistory;
  FullFavoriteRadioStationList = CStats::GetFullFavoriteRadioStationList();
  v8 = *((_QWORD *)FullFavoriteRadioStationList + 6);
  v9 = (__int64 *)(FullFavoriteRadioStationList + 8);
  v10 = *(_QWORD *)FullFavoriteRadioStationList;
  v11 = *((_QWORD *)FullFavoriteRadioStationList + 1);
  FullFavoriteRadioStationList += 4;
  v12 = *v9;
  v13 = v9[1];
  v14 = 0;
  v15 = *(_QWORD *)FullFavoriteRadioStationList;
  v16 = *((_QWORD *)FullFavoriteRadioStationList + 1);
  *(_QWORD *)this->m_nStationListenTimes = v10;
  *(_QWORD *)&this->m_nStationListenTimes[2] = v11;
  *(_QWORD *)&this->m_nStationListenTimes[12] = v8;
  *(_QWORD *)&this->m_nStationListenTimes[8] = v12;
  *(_QWORD *)&this->m_nStationListenTimes[10] = v13;
  v17 = &this->m_nStationListenTimes[4];
  v29 = this;
  v18 = 8;
  *(_QWORD *)v17 = v15;
  *((_QWORD *)v17 + 1) = v16;
  do
  {
    *((_DWORD *)v6 + 4) = -1;
    *((_DWORD *)v6 + 3) = -1;
    *((_DWORD *)v6 + 2) = -1;
    *((_DWORD *)v6 + 1) = -1;
    *(_DWORD *)v6 = -1;
    (*v5)[0] = -1;
    (*v5)[1] = -1;
    (*v5)[2] = -1;
    (*v5)[3] = -1;
    (*v5)[4] = -1;
    (*v5)[5] = -1;
    (*v5)[6] = -1;
    (*v5)[7] = -1;
    memset(v4, 255, sizeof(Int32[40]));
    memset(v3, 255, sizeof(Int32[15]));
    v6 += 20;
    ++v5;
    ++v4;
    v19 = &v29->m_bStationChangePending + v14;
    v14 += 44;
    ++v3;
    *((_QWORD *)v19 + 34) = -1LL;
    *((_QWORD *)v19 + 35) = -1LL;
    *((_QWORD *)v19 + 32) = 0LL;
    *((_QWORD *)v19 + 33) = 0xFFFFFFFF00000000LL;
    v19[296] = -1;
    *((_DWORD *)v19 + 72) = -1;
    *((_DWORD *)v19 + 73) = -16382458;
    *(&v29->m_bStationChangePending + v18++) = 0;
  }
  while ( v14 != 616 );
  v29->m_RequestedSettings.StationID = CAEAudioUtility::GetRandomNumberInRange(1, 13);
  v29->m_RequestedSettings.BassSetting = 0;
  v29->m_RequestedSettings.TrackFlags = 2;
  v29->m_RequestedSettings.MusicTrackIndices[0] = -1;
  v29->m_RequestedSettings.MusicTrackIndices[1] = -1;
  v29->m_RequestedSettings.TrackTypes[1] = 6;
  v29->m_RequestedSettings.MusicTrackIndices[2] = -1;
  v29->m_RequestedSettings.TrackTypes[2] = 6;
  v29->m_RequestedSettings.MusicTrackIndices[3] = -1;
  v29->m_RequestedSettings.TrackTypes[3] = 6;
  v29->m_RequestedSettings.MusicTrackIndices[4] = -1;
  v29->m_RequestedSettings.TrackTypes[4] = 6;
  *(_QWORD *)v29->m_RequestedSettings.TrackIDs = -1LL;
  *(_QWORD *)&v29->m_RequestedSettings.TrackIDs[2] = -1LL;
  v29->m_RequestedSettings.TrackTypes[0] = 6;
  v29->m_RequestedSettings.TrackLengthMs = 0;
  *(_WORD *)&v29->m_RequestedSettings.PlayingTrackType = 1542;
  *(_WORD *)&v29->m_RequestedSettings.PlayingTrackMusicTrackIndex = -1;
  v20 = *(_QWORD *)&v29->m_RequestedSettings.TrackLengthMs;
  v21 = *(_QWORD *)&v29->m_RequestedSettings.BassFactor;
  v22 = *(_QWORD *)v29->m_RequestedSettings.TrackTypes;
  v23 = *(_QWORD *)&v29->m_RequestedSettings.MusicTrackIndices[1];
  *(_QWORD *)&v29->m_RequestedSettings.TrackIDs[4] = -1LL;
  *(_QWORD *)&v29->m_RequestedSettings.PreviousTrackID = 0xFFFFFFFFLL;
  v24 = *(_QWORD *)&v29->m_RequestedSettings.TrackIDs[4];
  v25 = *(_QWORD *)&v29->m_RequestedSettings.PreviousTrackID;
  *(_QWORD *)&v29->m_ActiveSettings.TrackLengthMs = v20;
  *(_QWORD *)&v29->m_ActiveSettings.BassFactor = v21;
  v26 = *(_QWORD *)v29->m_RequestedSettings.TrackIDs;
  v27 = *(_QWORD *)&v29->m_RequestedSettings.TrackIDs[2];
  *(_QWORD *)v29->m_ActiveSettings.TrackTypes = v22;
  *(_QWORD *)&v29->m_ActiveSettings.MusicTrackIndices[1] = v23;
  *(_QWORD *)&v29->m_ActiveSettings.TrackIDs[4] = v24;
  *(_QWORD *)&v29->m_ActiveSettings.PreviousTrackID = v25;
  *(_QWORD *)v29->m_ActiveSettings.TrackIDs = v26;
  *(_QWORD *)&v29->m_ActiveSettings.TrackIDs[2] = v27;
  v29->m_nLastVehicleStationID = -1;
  v29->m_nRetuneStationID = -1;
  v29->m_nScriptRetuneStationID = -1;
  v29->m_nRetunesPending = 0;
  v29->m_nPreviousRetunesPending = 0;
  v29->m_nLastVehicleExitGameClockDays = -1;
  v29->m_nLastVehicleExitGameClockHours = -1;
  v29->m_nLastRetuneTimeMs = 0;
  v29->m_nStationNameDisplayEndTimeMs = 0;
  v29->m_nLastVehicleExitTimeMs = 0;
  v29->m_nRetuneTimeMs = 0;
  v29->m_nLastPlayStartTimeMs = 0;
  *(_WORD *)&v29->m_bReadyToRetune = 0;
  v29->m_bUseRadioAutoRetune = 1;
  v29->m_bUseBassEnhance = 1;
  CAERadioTrackManager::m_nSpecialDJBanterIndex = -1;
  CAERadioTrackManager::m_nSpecialDJBanterPending = 3;
  v29->m_fDialogueRadioDuckingVolume = 0.0;
  v29->m_fDialogueRadioDuckingReleaseStep = 0.0;
  *(_WORD *)&v29->m_bPausedLastFrame = 0;
  CAERadioTrackManager::m_nStatsStartedBadlands = 0;
  CAERadioTrackManager::m_nStatsStartedCat2 = 0;
  CAERadioTrackManager::m_nStatsStartedCrash1 = 0;
  CAERadioTrackManager::m_nStatsLastHitGameClockHours = -1;
  CAERadioTrackManager::m_nStatsLastHitGameClockDays = -1;
  CAERadioTrackManager::m_nStatsCitiesPassed = 0;
  CAERadioTrackManager::m_nStatsPassedVCrash2 = 0;
  CAERadioTrackManager::m_nStatsLastHitTimeOutHours = -1;
  CAERadioTrackManager::m_nStatsPassedCasino3 = 0;
  CAERadioTrackManager::m_nStatsPassedCasino6 = 0;
  CAERadioTrackManager::m_nStatsPassedCasino10 = 0;
  CAERadioTrackManager::m_nStatsPassedCat1 = 0;
  CAERadioTrackManager::m_nStatsPassedDesert1 = 0;
  CAERadioTrackManager::m_nStatsPassedDesert3 = 0;
  CAERadioTrackManager::m_nStatsPassedDesert5 = 0;
  CAERadioTrackManager::m_nStatsPassedDesert8 = 0;
  CAERadioTrackManager::m_nStatsPassedDesert10 = 0;
  CAERadioTrackManager::m_nStatsPassedFarlie3 = 0;
  CAERadioTrackManager::m_nStatsPassedLAFin2 = 0;
  CAERadioTrackManager::m_nStatsPassedMansion2 = 0;
  CAERadioTrackManager::m_nStatsPassedRyder2 = 0;
  CAERadioTrackManager::m_nStatsPassedRiot1 = 0;
  CAERadioTrackManager::m_nStatsPassedSCrash1 = 0;
  CAERadioTrackManager::m_nStatsPassedSweet2 = 0;
  CAERadioTrackManager::m_nStatsPassedStrap4 = 0;
  CAERadioTrackManager::m_nStatsPassedTruth2 = 0;
  v29->m_numInvalidTracks = 0;
  return 1;
}

//----- (0046D310) --------------------------------------------------------
Bool8 __fastcall CAECutsceneTrackManager::Initialise(CAECutsceneTrackManager *this, int HardwareClientHandle)
{
  int *p_m_nCutsceneStatus; // r0

  this->m_nHardwareClientHandle = HardwareClientHandle;
  *(_WORD *)&this->m_bStartCutscenePlayback = 0;
  this->m_RequestedSettings.TrackFlags = 0;
  this->m_RequestedSettings.TrackLengthMs = 0;
  p_m_nCutsceneStatus = &this->m_nCutsceneStatus;
  *(_QWORD *)p_m_nCutsceneStatus = 0xFFFFFFFF00000008LL;
  *((_QWORD *)p_m_nCutsceneStatus + 1) = 0xFFFFFFFFLL;
  return 1;
}

//----- (0046D340) --------------------------------------------------------
Bool8 __fastcall CAEAmbienceTrackManager::Initialise(CAEAmbienceTrackManager *this, int HardwareClientHandle)
{
  this->m_nHardwareClientHandle = HardwareClientHandle;
  this->m_nAmbienceStatus = 8;
  this->m_RequestedSettings.TrackFlags = 3;
  this->m_fAmbienceVolume = -100.0;
  this->m_fAmbienceFrequencyScalingFactor = 1.0;
  this->m_RequestedSettings.TrackID = -1;
  this->m_RequestedSettings.PlayingTrackID = -1;
  return 1;
}

//----- (0046D368) --------------------------------------------------------
Bool8 __fastcall CAESoundManager::Initialise(CAESoundManager *this)
{
  unsigned int NumAvailableChannels; // r0
  UInt16 m_nAvailableChannels; // r1
  int v4; // r2
  char *v5; // r5
  int v6; // r4
  _WORD *v7; // r5
  int v8; // t1
  Bool8 v9; // r5
  Bool16 *p_m_bCurrentlyInUse; // r4
  unsigned int m_AllocatedPhysicalChannels; // r8
  int v13; // r0
  int v14; // r1
  int v15; // r1
  int v16; // r2

  NumAvailableChannels = CAEAudioHardware::GetNumAvailableChannels(&AEAudioHardware);
  if ( NumAvailableChannels < 0xB )
    return 0;
  if ( NumAvailableChannels >= 0x12C )
    LOWORD(NumAvailableChannels) = 300;
  this->m_AllocatedPhysicalChannels = NumAvailableChannels;
  m_nAvailableChannels = AEAudioHardware.m_nAvailableChannels;
  if ( (unsigned __int16)(NumAvailableChannels - 1) >= (unsigned int)AEAudioHardware.m_nAvailableChannels )
  {
LABEL_8:
    this->m_AudioHardwareHandle = -1;
    return 0;
  }
  v4 = 0;
  while ( 1 )
  {
    v5 = (char *)&AEAudioHardware + 2 * v4;
    v8 = *((unsigned __int16 *)v5 + 38);
    v7 = v5 + 76;
    v6 = v8;
    if ( !v8 )
      break;
    v4 += v6;
    if ( v4 > 29 )
      goto LABEL_8;
  }
  *v7 = NumAvailableChannels;
  v9 = 0;
  AEAudioHardware.m_nAvailableChannels = m_nAvailableChannels - NumAvailableChannels;
  this->m_AudioHardwareHandle = v4;
  if ( (unsigned __int16)v4 != 0xFFFF )
  {
    p_m_bCurrentlyInUse = &this->m_VirtuallyPlayingSoundList[0].m_bCurrentlyInUse;
    m_AllocatedPhysicalChannels = this->m_AllocatedPhysicalChannels;
    v13 = operator new[](2 * m_AllocatedPhysicalChannels + 8);
    *(_DWORD *)v13 = 2;
    *(_DWORD *)(v13 + 4) = m_AllocatedPhysicalChannels;
    m_AllocatedPhysicalChannels *= 2;
    this->m_PhysicallyPlayingSoundList = (CAEPhysicallyPlayingSound *)(v13 + 8);
    this->m_ChannelPosition = (Int16 *)operator new[](m_AllocatedPhysicalChannels);
    this->m_PrioritisedSoundList = (tSoundReference *)operator new[](m_AllocatedPhysicalChannels);
    v14 = 300;
    do
    {
      p_m_bCurrentlyInUse[3] = 0;
      --v14;
      *p_m_bCurrentlyInUse = 0;
      p_m_bCurrentlyInUse += 58;
    }
    while ( v14 );
    if ( this->m_AllocatedPhysicalChannels )
    {
      v15 = 0;
      v16 = 0;
      do
      {
        ++v16;
        this->m_PhysicallyPlayingSoundList[v15].m_SoundReference = -1;
        v15 = (__int16)v16;
      }
      while ( (__int16)v16 < (int)this->m_AllocatedPhysicalChannels );
    }
    v9 = 1;
    this->m_TimeLastCalled = CTimer::m_snTimeInMilliseconds;
    this->m_TimeLastCalledUnpaused = 0;
    *(_WORD *)&this->m_GamePausedLastFrame = 0;
  }
  return v9;
}

//----- (0046D47C) --------------------------------------------------------
void __fastcall CAEFrontendAudioEntity::Initialise(CAEFrontendAudioEntity *this)
{
  __int16 RandomNumberInRange; // r0

  this->m_BulletPassBank = 28;
  *(_DWORD *)&this->m_nLastRetuneSoundID = 0xFFFF;
  this->m_bWakeupAmplifierEventTriggered = 0;
  *(_QWORD *)&this->m_LastPickupEventFrame = 0LL;
  *(_QWORD *)&this->m_LastBulletPassEventFrame = 0LL;
  this->m_nLastFrontendTimerCountTimeMs = 0;
  this->m_pWakeupAmplifierSound = 0;
  CAEAudioHardware::LoadSoundBank(&AEAudioHardware, 0x3Cu, 1);
  CAEAudioHardware::LoadSoundBank(&AEAudioHardware, 0x3Bu, 0);
  CAEAudioHardware::LoadSoundBank(&AEAudioHardware, 0x1Cu, 42);
  RandomNumberInRange = CAEAudioUtility::GetRandomNumberInRange(0, 3);
  this->m_nLoadingTrackIndex = RandomNumberInRange;
  CAEAudioHardware::LoadSound(&AEAudioHardware, 0x52u, (__int16)(RandomNumberInRange << 8) >> 7, 2);
  sub_193430(&AEAudioHardware, 0x52u, (2 * this->m_nLoadingTrackIndex) | 1, 5);
}

//----- (0046D510) --------------------------------------------------------
void CAEAudioUtility::StaticInitialise()
{
  int v0; // r6
  float *v1; // r5
  float v2; // r0

  v0 = 47;
  *(_QWORD *)&CAEAudioUtility::m_sfLogLookup[0][0] = 0xC2C8000000000000LL;
  *(_QWORD *)&CAEAudioUtility::m_sfLogLookup[1][0] = 0xC2C800003727C5ACLL;
  v1 = CAEAudioUtility::m_sfLogLookup[2];
  do
  {
    v2 = powf(1.2, (float)v0--);
    *v1 = 10.0 / v2;
    v1 += 2;
  }
  while ( v0 != -1 );
  CAEAudioUtility::m_sfLogLookup[1][1] = log10f(10.0 / v2);
}

//----- (0046D598) --------------------------------------------------------
void CAEPedAudioEntity::StaticInitialise()
{
  CAEAudioHardware::LoadSoundBank(&AEAudioHardware, 0, 41);
  sub_18AFEC(&AEAudioHardware, 0x80u, 32);
}

//----- (0046D5C0) --------------------------------------------------------
void CAEPedSpeechAudioEntity::StaticInitialise()
{
  int v0; // r5
  uint32 v1; // r6

  v0 = 0;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[0].m_InUse = 0;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[0].m_pAudioEntity = 0;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[0].m_pSound = 0;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[0].m_SoundID = -1;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[0].m_BankID = -1;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[0].m_StartPlaybackTime = 0;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[0].m_GlobalSpeechContext = -1;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[0].m_PedType = -1;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[0].m_ReservedForPlayerConversation = 0;
  *(_WORD *)&CAEPedSpeechAudioEntity::s_PedSpeechSlots[0].m_bForceAudible = 0;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[1].m_InUse = 0;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[1].m_pAudioEntity = 0;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[1].m_pSound = 0;
  *(_DWORD *)&CAEPedSpeechAudioEntity::s_PedSpeechSlots[1].m_SoundID = -1;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[1].m_StartPlaybackTime = 0;
  *(_DWORD *)&CAEPedSpeechAudioEntity::s_PedSpeechSlots[1].m_GlobalSpeechContext = -1;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[1].m_ReservedForPlayerConversation = 0;
  *(_WORD *)&CAEPedSpeechAudioEntity::s_PedSpeechSlots[1].m_bForceAudible = 0;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[2].m_pAudioEntity = 0;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[2].m_pSound = 0;
  *(_DWORD *)&CAEPedSpeechAudioEntity::s_PedSpeechSlots[2].m_SoundID = -1;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[2].m_StartPlaybackTime = 0;
  *(_DWORD *)&CAEPedSpeechAudioEntity::s_PedSpeechSlots[2].m_GlobalSpeechContext = -1;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[2].m_ReservedForPlayerConversation = 0;
  *(_WORD *)&CAEPedSpeechAudioEntity::s_PedSpeechSlots[2].m_bForceAudible = 0;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[2].m_InUse = 0;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[3].m_pAudioEntity = 0;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[3].m_pSound = 0;
  *(_DWORD *)&CAEPedSpeechAudioEntity::s_PedSpeechSlots[3].m_SoundID = -1;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[3].m_StartPlaybackTime = 0;
  *(_DWORD *)&CAEPedSpeechAudioEntity::s_PedSpeechSlots[3].m_GlobalSpeechContext = -1;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[3].m_ReservedForPlayerConversation = 0;
  *(_WORD *)&CAEPedSpeechAudioEntity::s_PedSpeechSlots[3].m_bForceAudible = 0;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[3].m_InUse = 0;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[4].m_pAudioEntity = 0;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[4].m_pSound = 0;
  *(_DWORD *)&CAEPedSpeechAudioEntity::s_PedSpeechSlots[4].m_SoundID = -1;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[4].m_StartPlaybackTime = 0;
  *(_DWORD *)&CAEPedSpeechAudioEntity::s_PedSpeechSlots[4].m_GlobalSpeechContext = -1;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[4].m_ReservedForPlayerConversation = 0;
  *(_WORD *)&CAEPedSpeechAudioEntity::s_PedSpeechSlots[4].m_bForceAudible = 0;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[4].m_InUse = 0;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[5].m_pAudioEntity = 0;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[5].m_pSound = 0;
  *(_DWORD *)&CAEPedSpeechAudioEntity::s_PedSpeechSlots[5].m_SoundID = -1;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[5].m_StartPlaybackTime = 0;
  *(_DWORD *)&CAEPedSpeechAudioEntity::s_PedSpeechSlots[5].m_GlobalSpeechContext = -1;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[5].m_ReservedForPlayerConversation = 0;
  *(_WORD *)&CAEPedSpeechAudioEntity::s_PedSpeechSlots[5].m_bForceAudible = 0;
  CAEPedSpeechAudioEntity::s_PedSpeechSlots[5].m_InUse = 0;
  memset(CAEPedSpeechAudioEntity::s_PhraseMemory, 255, sizeof(CAEPedSpeechAudioEntity::s_PhraseMemory));
  CAEPedSpeechAudioEntity::s_NextSpeechSlot = 0;
  CAEPedSpeechAudioEntity::Reset();
  do
  {
    v1 = CTimer::m_snTimeInMilliseconds;
    gGlobalSpeechContextNextPlayTime[v0++] = CAEAudioUtility::GetRandomNumberInRange(3000, 7000) + v1;
  }
  while ( v0 != 360 );
  *(_DWORD *)&CAEPedSpeechAudioEntity::s_Conversation[3][0] = -1;
  *(_DWORD *)&CAEPedSpeechAudioEntity::s_Conversation[2][0] = -1;
  *(_DWORD *)&CAEPedSpeechAudioEntity::s_Conversation[1][0] = -1;
  *(_DWORD *)&CAEPedSpeechAudioEntity::s_Conversation[0][0] = -1;
  CAEPedSpeechAudioEntity::s_pConversationPed2 = 0;
  CAEPedSpeechAudioEntity::s_pConversationPedSlot1 = -1;
  CAEPedSpeechAudioEntity::s_nCJMoodOverrideTime = 0;
  CAEPedSpeechAudioEntity::s_nCJBasicMood = -1;
  CAEPedSpeechAudioEntity::s_pConversationPed1 = 0;
  CAEPedSpeechAudioEntity::s_nCJGangBanging = -1;
  CAEPedSpeechAudioEntity::s_nCJFat = -1;
  CAEPedSpeechAudioEntity::s_nCJWellDressed = -1;
  CAEPedSpeechAudioEntity::s_pConversationPedSlot2 = -1;
  CAEPedSpeechAudioEntity::s_pPlayerConversationPed = 0;
  CAEPedSpeechAudioEntity::s_bPedConversationHappening = 0;
  CAEPedSpeechAudioEntity::s_bPlayerConversationHappening = 0;
  CAEPedSpeechAudioEntity::s_NextSpeechSlot = 0;
  CAEPedSpeechAudioEntity::s_bAllSpeechDisabled = 0;
  CAEPedSpeechAudioEntity::s_bAPlayerSpeaking = 0;
  CAEPedSpeechAudioEntity::s_bForceAudible = 0;
}
// 676364: using guessed type __int16 *CAEPedSpeechAudioEntity::s_pConversationPedSlot1;
// 676D90: using guessed type __int16 *CAEPedSpeechAudioEntity::s_pConversationPedSlot2;

//----- (0046D7B4) --------------------------------------------------------
void CAEVehicleAudioEntity::StaticInitialise()
{
  CAEVehicleAudioEntity::s_DummyEngineSlots[8] = (tDummyEngineSlot)0xFFFF;
  CAEVehicleAudioEntity::s_DummyEngineSlots[9] = (tDummyEngineSlot)0xFFFF;
  *(_QWORD *)&CAEVehicleAudioEntity::s_DummyEngineSlots[0].BankId = 0xFFFF0000FFFFLL;
  *(_QWORD *)&CAEVehicleAudioEntity::s_DummyEngineSlots[2].BankId = 0xFFFF0000FFFFLL;
  *(_QWORD *)&CAEVehicleAudioEntity::s_DummyEngineSlots[4].BankId = 0xFFFF0000FFFFLL;
  *(_QWORD *)&CAEVehicleAudioEntity::s_DummyEngineSlots[6].BankId = 0xFFFF0000FFFFLL;
  CAEAudioHardware::LoadSoundBank(&AEAudioHardware, 0x8Au, 19);
  CAEAudioHardware::LoadSoundBank(&AEAudioHardware, 0xDu, 18);
  CAEAudioHardware::LoadSoundBank(&AEAudioHardware, 0x4Au, 17);
  CAEVehicleAudioEntity::s_pPlayerAttachedForRadio = 0;
  CAEVehicleAudioEntity::s_pVehicleAudioSettingsForRadio = 0;
  CAEVehicleAudioEntity::s_pPlayerDriver = 0;
  CAEVehicleAudioEntity::s_NextDummyEngineSlot = 0;
  CAEVehicleAudioEntity::s_HelicoptorsDisabled = 0;
}

//----- (0046D844) --------------------------------------------------------
void CAEExplosionAudioEntity::StaticInitialise()
{
  sub_18AFEC(&AEAudioHardware, 0x34u, 4);
}

//----- (0046D858) --------------------------------------------------------
void CAEWeatherAudioEntity::StaticInitialise()
{
  sub_18AFEC(&AEAudioHardware, 0x69u, 6);
}

//----- (0046D86C) --------------------------------------------------------
void CAEDoorAudioEntity::StaticInitialise()
{
  sub_18AFEC(&AEAudioHardware, 0x33u, 31);
}

//----- (0046D880) --------------------------------------------------------
void CAEFireAudioEntity::StaticInitialise()
{
  sub_18AFEC(&AEAudioHardware, 0x34u, 4);
}

//----- (0046D898) --------------------------------------------------------
void CAEPoliceScannerAudioEntity::StaticInitialise()
{
  CAEPoliceScannerAudioEntity::s_bScannerDisabled = 0;
  CAEPoliceScannerAudioEntity::s_NextNewScannerDialogueTime = 0;
  CAEPoliceScannerAudioEntity::s_nScannerPlaybackState = 0;
  CAEPoliceScannerAudioEntity::s_pPSControlling = 0;
  CAEPoliceScannerAudioEntity::s_pCurrentSlots = 0;
  CAEPoliceScannerAudioEntity::s_fVolumeOffset = 0.0;
}

//----- (0046D8F8) --------------------------------------------------------
void __fastcall CAEScriptAudioEntity::Initialise(CAEScriptAudioEntity *this)
{
  this->m_MissionSlotSettings[0].vAudioPosition.x = -1000.0;
  this->m_MissionSlotSettings[0].vAudioPosition.y = -1000.0;
  this->m_MissionSlotSettings[0].vAudioPosition.z = -1000.0;
  this->m_MissionSlotSettings[0].pAttachedPhysical = 0;
  this->m_MissionSlotSettings[0].pSound = 0;
  this->m_MissionSlotSettings[0].AudioEvent = -1;
  this->m_MissionSlotSettings[0].BankID = -1;
  this->m_MissionSlotSettings[0].SoundID = -1;
  this->m_MissionSlotSettings[1].vAudioPosition.x = -1000.0;
  this->m_MissionSlotSettings[1].vAudioPosition.y = -1000.0;
  this->m_MissionSlotSettings[1].vAudioPosition.z = -1000.0;
  this->m_MissionSlotSettings[1].pAttachedPhysical = 0;
  this->m_MissionSlotSettings[1].pSound = 0;
  this->m_MissionSlotSettings[1].AudioEvent = -1;
  this->m_MissionSlotSettings[1].BankID = -1;
  this->m_MissionSlotSettings[1].SoundID = -1;
  this->m_MissionSlotSettings[2].vAudioPosition.x = -1000.0;
  this->m_MissionSlotSettings[2].vAudioPosition.y = -1000.0;
  this->m_MissionSlotSettings[2].vAudioPosition.z = -1000.0;
  this->m_MissionSlotSettings[2].pAttachedPhysical = 0;
  this->m_MissionSlotSettings[2].pSound = 0;
  this->m_MissionSlotSettings[2].AudioEvent = -1;
  this->m_MissionSlotSettings[2].BankID = -1;
  this->m_MissionSlotSettings[2].SoundID = -1;
  this->m_MissionSlotSettings[3].vAudioPosition.x = -1000.0;
  this->m_MissionSlotSettings[3].vAudioPosition.y = -1000.0;
  this->m_MissionSlotSettings[3].vAudioPosition.z = -1000.0;
  this->m_MissionSlotSettings[3].pAttachedPhysical = 0;
  this->m_MissionSlotSettings[3].pSound = 0;
  this->m_MissionSlotSettings[3].AudioEvent = -1;
  this->m_MissionSlotSettings[3].BankID = -1;
  this->m_MissionSlotSettings[3].SoundID = -1;
}

//----- (0046D946) --------------------------------------------------------
void __fastcall CAECollisionAudioEntity::Initialise(CAECollisionAudioEntity *this)
{
  UInt8 *p_SurfaceB; // r2
  int v2; // r3

  p_SurfaceB = &this->m_CollisionSoundList[0].SurfaceB;
  v2 = 300;
  this->m_nActiveCollisionSounds = 0;
  do
  {
    *(_WORD *)(p_SurfaceB - 1) = -15421;
    --v2;
    *(_DWORD *)(p_SurfaceB - 18) = 0;
    *(_DWORD *)(p_SurfaceB - 14) = 0;
    *(_DWORD *)(p_SurfaceB - 10) = 0;
    *(_DWORD *)(p_SurfaceB - 6) = 0;
    *(p_SurfaceB - 2) = 0;
    p_SurfaceB += 20;
  }
  while ( v2 );
  memset(this->m_CollisionSoundIDHistory, 255, 0x188u);
}

//----- (0046D98C) --------------------------------------------------------
bool8 __fastcall FxManager_c::LoadFxProject(FxManager_c *this, unsigned __int8 *filename)
{
  size_t v4; // r0
  char *v5; // r0
  bool8 v6; // r6
  int32 v7; // r0
  u_native v8; // r0
  u_native v9; // r5
  FxSystemBP_c *v10; // r10
  FxSystemBP_c *v11; // r0
  unsigned __int8 *v12; // r1
  int32 version; // [sp+4h] [bp-324h] BYREF
  char v15[128]; // [sp+8h] [bp-320h] BYREF
  unsigned __int8 pLine[256]; // [sp+88h] [bp-2A0h] BYREF
  char v17[128]; // [sp+188h] [bp-1A0h] BYREF
  unsigned __int8 v18[256]; // [sp+208h] [bp-120h] BYREF

  strcpy(v17, (const char *)filename);
  v4 = strlen(v17);
  v17[v4] = 120;
  v5 = &v17[v4];
  *(v5 - 2) = 46;
  *((_WORD *)v5 - 2) = 17232;
  *(v5 - 1) = 116;
  *(_WORD *)(v5 + 1) = 100;
  v6 = 0;
  v7 = CTxdStore::AddTxdSlot((const unsigned __int8 *)&dword_46DAC8, (const unsigned __int8 *)&off_46DACC, 0);
  this->m_txdIndex = v7;
  CTxdStore::LoadTxd(v7, (const unsigned __int8 *)v17);
  CTxdStore::AddRef(this->m_txdIndex);
  CTxdStore::PushCurrentTxd();
  CTxdStore::SetCurrentTxd(this->m_txdIndex, 0);
  v8 = OpenFile(filename, (const unsigned __int8 *)&dword_46DAD0);
  v9 = v8;
  if ( v8 )
  {
    ReadLine(v8, pLine, 256);
    sscanf((const char *)pLine, (const char *)&dword_46DAD4, v15);
    while ( 1 )
    {
      ReadLine(v9, pLine, 256);
      ReadLine(v9, pLine, 256);
      sscanf((const char *)pLine, (const char *)&dword_46DAD4, v15);
      if ( strcmp(v15, "FX_SYSTEM_DATA:") )
        break;
      ReadLine(v9, v18, 256);
      sscanf((const char *)v18, "%d", &version);
      v10 = (FxSystemBP_c *)FxSystemBP_c::operator new(0x24u);
      FxSystemBP_c::FxSystemBP_c(v10);
      FxSystemBP_c::Load(v11, v12, v9, version);
      List_c::AddItem(&this->m_fxSystemBPList, v10);
    }
    CloseFile(v9);
    CTxdStore::PopCurrentTxd();
    FxMemoryPool_c::Optimise(&this->m_fxMemPool);
    return 1;
  }
  return v6;
}
// 46DA58: variable 'v11' is possibly undefined
// 46DA58: variable 'v12' is possibly undefined
// 46DAC8: using guessed type int dword_46DAC8;
// 46DACC: using guessed type void *off_46DACC;
// 46DAD0: using guessed type int dword_46DAD0;
// 46DAD4: using guessed type int dword_46DAD4;
// 46D98C: using guessed type char var_1A0[128];
// 46D98C: using guessed type char var_320[128];

//----- (0046DAF0) --------------------------------------------------------
FxSystemBP_c *__fastcall FxManager_c::LoadFxSystemBP(FxManager_c *this, unsigned __int8 *filename, u_native fileId)
{
  FxSystemBP_c *v5; // r6
  FxSystemBP_c *v6; // r0
  unsigned __int8 *v7; // r1
  int32 v9; // [sp+0h] [bp-118h] BYREF
  unsigned __int8 pLine[256]; // [sp+4h] [bp-114h] BYREF

  ReadLine(fileId, pLine, 256);
  sscanf((const char *)pLine, (const char *)&dword_46DB5C, &v9);
  v5 = (FxSystemBP_c *)FxSystemBP_c::operator new(0x24u);
  FxSystemBP_c::FxSystemBP_c(v5);
  FxSystemBP_c::Load(v6, v7, fileId, v9);
  List_c::AddItem(&this->m_fxSystemBPList, v5);
  return v5;
}
// 46DB30: variable 'v6' is possibly undefined
// 46DB30: variable 'v7' is possibly undefined
// 46DB5C: using guessed type int dword_46DB5C;

//----- (0046DB64) --------------------------------------------------------
bool8 __fastcall FxSystemBP_c::Load(FxSystemBP_c *this, unsigned __int8 *filename, u_native fileId, int32 version)
{
  int v7; // r1
  RwV3d_0 *v8; // r4
  int v9; // r10
  FxEmitterBP_c *v10; // r0
  FxPrimBP_c *v11; // r0
  RwV3d_0 *v12; // r4
  int v13; // r6
  FxPrimBP_c *v14; // r0
  int32 v16; // [sp+Ch] [bp-5F4h]
  RwV3d_0 v17; // [sp+10h] [bp-5F0h] BYREF
  float radius; // [sp+410h] [bp-1F0h] BYREF
  float v19; // [sp+414h] [bp-1ECh] BYREF
  int v20; // [sp+418h] [bp-1E8h] BYREF
  unsigned __int8 v21[32]; // [sp+41Ch] [bp-1E4h] BYREF
  char v22; // [sp+43Ch] [bp-1C4h] BYREF
  char v23[32]; // [sp+4BCh] [bp-144h] BYREF
  unsigned __int8 pLine[256]; // [sp+4DCh] [bp-124h] BYREF

  ReadLine(fileId, pLine, 256);
  if ( version >= 101 )
  {
    ReadLine(fileId, pLine, 256);
    sscanf((const char *)pLine, "%s %s", v23, &v22);
  }
  ReadLine(fileId, pLine, 256);
  sscanf((const char *)pLine, "%s %s", v23, v21);
  this->m_hashName = CKeyGen::GetUppercaseKey(v21);
  ReadLine(fileId, pLine, 256);
  sscanf((const char *)pLine, "%s %f", v23, &this->m_length);
  if ( version < 106 )
  {
    this->m_loopIntervalMin = 0.0;
    this->m_loopIntervalMax = 0.0;
  }
  else
  {
    ReadLine(fileId, pLine, 256);
    sscanf((const char *)pLine, "%s %f", v23, &this->m_loopIntervalMin);
    ReadLine(fileId, pLine, 256);
    sscanf((const char *)pLine, "%s %f", v23, &this->m_loopIntervalMax);
  }
  ReadLine(fileId, pLine, 256);
  sscanf((const char *)pLine, "%s %d", v23, &v20);
  this->m_playMode = v20;
  ReadLine(fileId, pLine, 256);
  sscanf((const char *)pLine, "%s %f", v23, &v19);
  this->m_cullDist_ui16 = (unsigned int)(float)(v19 * 256.0);
  v16 = version;
  if ( version >= 104 )
  {
    ReadLine(fileId, pLine, 256);
    sscanf((const char *)pLine, "%s %f %f %f %f", v23, &v17, &v17.y, &v17.z, &radius);
    this->m_boundingSphere = 0;
    FxSystemBP_c::SetBoundingSphere(this, &v17, radius);
  }
  ReadLine(fileId, pLine, 256);
  sscanf((const char *)pLine, "%s %d", v23, &v20);
  v7 = v20;
  this->m_numFxPrimBPs = v20;
  this->m_fxPrimBPPtrs = (FxPrimBP_c **)FxMemoryPool_c::GetMem(&g_fxMan.m_fxMemPool, v7 << 24 >> 22, 4);
  if ( this->m_numFxPrimBPs >= 1 )
  {
    v8 = &v17;
    v9 = 0;
    do
    {
      ReadLine(fileId, pLine, 256);
      sscanf((const char *)pLine, (const char *)&dword_46DEF4, v23);
      if ( !strcmp(v23, "FX_PRIM_EMITTER_DATA:") )
      {
        v10 = (FxEmitterBP_c *)FxEmitterBP_c::operator new(0x40u);
        FxEmitterBP_c::FxEmitterBP_c(v10);
        this->m_fxPrimBPPtrs[v9] = v11;
        this->m_fxPrimBPPtrs[v9][1].m_type = 0;
        this->m_fxPrimBPPtrs[v9][1].m_srcBlendId = 0;
        ReadLine(fileId, pLine, 256);
        (*((void (__fastcall **)(FxPrimBP_c *, u_native, int32, RwV3d_0 *))this->m_fxPrimBPPtrs[v9]->_vptr$FxPrimBP_c + 2))(
          this->m_fxPrimBPPtrs[v9],
          fileId,
          v16,
          v8);
        this->m_fxPrimBPPtrs[v9][1].m_type = FxEmitterBP_c::IsFxInfoPresent(
                                               (FxEmitterBP_c *)this->m_fxPrimBPPtrs[v9],
                                               16416);
        this->m_fxPrimBPPtrs[v9][1].m_srcBlendId = FxEmitterBP_c::IsFxInfoPresent(
                                                     (FxEmitterBP_c *)this->m_fxPrimBPPtrs[v9],
                                                     16392);
      }
      ++v9;
      v8 = (RwV3d_0 *)((char *)v8 + 128);
    }
    while ( v9 < this->m_numFxPrimBPs );
  }
  if ( v16 > 107 )
  {
    ReadLine(fileId, pLine, 256);
    sscanf((const char *)pLine, "%s %d", v23, &radius);
    if ( v16 != 108 )
    {
      ReadLine(fileId, pLine, 256);
      sscanf((const char *)pLine, "%s %s", v23, &v22);
    }
  }
  if ( this->m_numFxPrimBPs >= 1 )
  {
    v12 = &v17;
    v13 = 0;
    do
    {
      v14 = this->m_fxPrimBPPtrs[v13];
      (*((void (__fastcall **)(FxPrimBP_c *, RwV3d_0 *, int32))v14->_vptr$FxPrimBP_c + 3))(v14, v12, v16);
      ++v13;
      v12 = (RwV3d_0 *)((char *)v12 + 128);
    }
    while ( v13 < this->m_numFxPrimBPs );
  }
  return 0;
}
// 46DD92: variable 'v11' is possibly undefined
// 46DEF4: using guessed type int dword_46DEF4;
// 46DB64: using guessed type char var_144[32];
// 46DB64: using guessed type unsigned __int8 var_1E4[32];
// 46DB64: using guessed type float var_1EC;
// 46DB64: using guessed type RwV3d_0 var_5F0;

//----- (0046DF1C) --------------------------------------------------------
bool8 __fastcall FxEmitterBP_c::LoadTextures(FxEmitterBP_c *this, FxName32_t *textureInfo, int32 version)
{
  RwTexture_0 *v6; // r0
  RwTexture_0 *v7; // r0
  RwTexture_0 *v8; // r0
  FxName32_t *v9; // r5
  RwTexture_0 *v10; // r0
  unsigned __int8 s[64]; // [sp+4h] [bp-54h] BYREF

  sprintf(s, (const unsigned __int8 *)&dword_46E028, textureInfo);
  v6 = RwTextureRead(textureInfo->txt, s);
  this->m_texturePtr = v6;
  if ( v6 )
  {
    if ( version < 102 )
      return 1;
  }
  else
  {
    this->m_texturePtr = RwTextureRead(textureInfo->txt, 0);
    if ( version < 102 )
      return 1;
  }
  if ( strcmp((const char *)&textureInfo[1], "NULL") )
  {
    sprintf(s, (const unsigned __int8 *)&dword_46E028, &textureInfo[1]);
    v7 = RwTextureRead(textureInfo[1].txt, s);
    this->m_texturePtr2 = v7;
    if ( !v7 )
      this->m_texturePtr2 = RwTextureRead(textureInfo[1].txt, 0);
  }
  if ( strcmp((const char *)&textureInfo[2], "NULL") )
  {
    sprintf(s, (const unsigned __int8 *)&dword_46E028, &textureInfo[2]);
    v8 = RwTextureRead(textureInfo[2].txt, s);
    this->m_texturePtr3 = v8;
    if ( !v8 )
      this->m_texturePtr3 = RwTextureRead(textureInfo[2].txt, 0);
  }
  v9 = textureInfo + 3;
  if ( strcmp((const char *)v9, "NULL") )
  {
    sprintf(s, (const unsigned __int8 *)&dword_46E028, v9);
    v10 = RwTextureRead(v9->txt, s);
    this->m_texturePtr4 = v10;
    if ( !v10 )
      this->m_texturePtr4 = RwTextureRead(v9->txt, 0);
  }
  return 1;
}
// 46E028: using guessed type int dword_46E028;

//----- (0046E038) --------------------------------------------------------
bool8 __fastcall FxEmitterBP_c::Load(FxEmitterBP_c *this, u_native fileId, int32 version, FxName32_t *textureInfo)
{
  float v7; // [sp+0h] [bp-1A8h] BYREF
  char v8; // [sp+4h] [bp-1A4h] BYREF
  unsigned __int8 pLine[256]; // [sp+84h] [bp-124h] BYREF

  FxPrimBP_c::Load(this, fileId, version, textureInfo);
  ReadLine(fileId, pLine, 256);
  sscanf((const char *)pLine, "%s %f", &v8, &v7);
  this->m_lodStart_ui16 = (unsigned int)(float)(v7 * 64.0);
  ReadLine(fileId, pLine, 256);
  sscanf((const char *)pLine, "%s %f", &v8, &v7);
  this->m_lodEnd_ui16 = (unsigned int)(float)(v7 * 64.0);
  return 1;
}

//----- (0046E0F4) --------------------------------------------------------
bool8 __fastcall FxPrimBP_c::Load(FxPrimBP_c *this, u_native fileId, int32 version, FxName32_t *textureInfo)
{
  uint8 *Mem; // r0
  float v10; // [sp+34h] [bp-1D4h] BYREF
  float v11; // [sp+38h] [bp-1D0h] BYREF
  float v12; // [sp+3Ch] [bp-1CCh] BYREF
  float v13; // [sp+40h] [bp-1C8h] BYREF
  float v14; // [sp+44h] [bp-1C4h] BYREF
  float v15; // [sp+48h] [bp-1C0h] BYREF
  float v16; // [sp+4Ch] [bp-1BCh] BYREF
  float v17; // [sp+50h] [bp-1B8h] BYREF
  float v18; // [sp+54h] [bp-1B4h] BYREF
  float v19; // [sp+58h] [bp-1B0h] BYREF
  float v20; // [sp+5Ch] [bp-1ACh] BYREF
  float v21; // [sp+60h] [bp-1A8h] BYREF
  int v22; // [sp+64h] [bp-1A4h] BYREF
  char v23; // [sp+68h] [bp-1A0h] BYREF
  unsigned __int8 pLine[256]; // [sp+E8h] [bp-120h] BYREF

  ReadLine(fileId, pLine, 256);
  sscanf((const char *)pLine, (const char *)&dword_46E484, &v23);
  ReadLine(fileId, pLine, 256);
  sscanf((const char *)pLine, "%s %s", &v23, &v23);
  ReadLine(fileId, pLine, 256);
  sscanf(
    (const char *)pLine,
    "%s %f %f %f %f %f %f %f %f %f %f %f %f",
    &v23,
    &v10,
    &v11,
    &v12,
    &v13,
    &v14,
    &v15,
    &v16,
    &v17,
    &v18,
    &v19,
    &v20,
    &v21);
  if ( v10 == 1.0 && v12 == 0.0 && v14 == 1.0 && v16 == 0.0 && v18 == 1.0 && v20 == 0.0 )
  {
    this->m_matVals_i16 = 0;
  }
  else
  {
    Mem = FxMemoryPool_c::GetMem(&g_fxMan.m_fxMemPool, 24, 2);
    this->m_matVals_i16 = (int16 *)Mem;
    *(_WORD *)Mem = (int)(float)(v10 * 32767.0);
    this->m_matVals_i16[1] = (int)(float)(v11 * 32767.0);
    this->m_matVals_i16[2] = (int)(float)(v12 * 32767.0);
    this->m_matVals_i16[3] = (int)(float)(v13 * 32767.0);
    this->m_matVals_i16[4] = (int)(float)(v14 * 32767.0);
    this->m_matVals_i16[5] = (int)(float)(v15 * 32767.0);
    this->m_matVals_i16[6] = (int)(float)(v16 * 32767.0);
    this->m_matVals_i16[7] = (int)(float)(v17 * 32767.0);
    this->m_matVals_i16[8] = (int)(float)(v18 * 32767.0);
    this->m_matVals_i16[9] = (int)(float)(v19 * 32767.0);
    this->m_matVals_i16[10] = (int)(float)(v20 * 32767.0);
    this->m_matVals_i16[11] = (int)(float)(v21 * 32767.0);
  }
  ReadLine(fileId, pLine, 256);
  sscanf((const char *)pLine, "%s %s", &v23, textureInfo);
  if ( version >= 102 )
  {
    ReadLine(fileId, pLine, 256);
    sscanf((const char *)pLine, "%s %s", &v23, &textureInfo[1]);
    ReadLine(fileId, pLine, 256);
    sscanf((const char *)pLine, "%s %s", &v23, &textureInfo[2]);
    ReadLine(fileId, pLine, 256);
    sscanf((const char *)pLine, "%s %s", &v23, &textureInfo[3]);
  }
  ReadLine(fileId, pLine, 256);
  sscanf((const char *)pLine, "%s %d", &v23, &v22);
  this->m_alphaOn = v22;
  ReadLine(fileId, pLine, 256);
  sscanf((const char *)pLine, "%s %d", &v23, &v22);
  this->m_srcBlendId = v22;
  ReadLine(fileId, pLine, 256);
  sscanf((const char *)pLine, "%s %d", &v23, &v22);
  this->m_dstBlendId = v22;
  FxInfoManager_c::Load(&this->m_fxInfoMan, fileId, version);
  return 1;
}
// 46E484: using guessed type int dword_46E484;

//----- (0046E4CC) --------------------------------------------------------
void __fastcall FxInfoManager_c::Load(FxInfoManager_c *this, u_native fileId, int32 version)
{
  int32 m_numFxInfos; // r1
  FxInfo_c **Mem; // r0
  int32 v8; // r1
  int v9; // r9
  FxInfoManager_c *v10; // r0
  int32 v11; // r1
  FxInfo_c *v12; // r0
  int m_renderOffset; // r0
  int v14; // [sp+4h] [bp-1A4h] BYREF
  char v15[128]; // [sp+8h] [bp-1A0h] BYREF
  unsigned __int8 pLine[256]; // [sp+88h] [bp-120h] BYREF

  ReadLine(fileId, pLine, 256);
  ReadLine(fileId, pLine, 256);
  sscanf((const char *)pLine, "%s %d", v15, this);
  m_numFxInfos = this->m_numFxInfos;
  *(_WORD *)&this->m_movementOffset = -1;
  Mem = (FxInfo_c **)FxMemoryPool_c::GetMem(&g_fxMan.m_fxMemPool, 4 * m_numFxInfos, 4);
  v8 = this->m_numFxInfos;
  this->m_fxInfoPtrs = Mem;
  if ( v8 >= 1 )
  {
    v9 = 0;
    while ( 1 )
    {
      v14 = 1;
      ReadLine(fileId, pLine, 256);
      sscanf((const char *)pLine, (const char *)&dword_46EC24, v15);
      if ( !strcmp(v15, "FX_INFO_EMRATE_DATA:") )
        break;
      if ( !strcmp(v15, "FX_INFO_EMSIZE_DATA:") )
      {
        v10 = this;
        v11 = 4100;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_EMSPEED_DATA:") )
      {
        v10 = this;
        v11 = 4104;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_EMDIR_DATA:") )
      {
        v10 = this;
        v11 = 4112;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_EMANGLE_DATA:") )
      {
        v10 = this;
        v11 = 4128;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_EMLIFE_DATA:") )
      {
        v10 = this;
        v11 = 4160;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_EMPOS_DATA:") )
      {
        v10 = this;
        v11 = 4224;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_EMWEATHER_DATA:") )
      {
        v10 = this;
        v11 = 4352;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_EMROTATION_DATA:") )
      {
        v10 = this;
        v11 = 4608;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_NOISE_DATA:") )
      {
        if ( version >= 1 )
        {
          ReadLine(fileId, pLine, 256);
          sscanf((const char *)pLine, "%s %d", v15, &v14);
        }
        v10 = this;
        v11 = 8193;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_FORCE_DATA:") )
      {
        if ( version >= 1 )
        {
          ReadLine(fileId, pLine, 256);
          sscanf((const char *)pLine, "%s %d", v15, &v14);
        }
        v10 = this;
        v11 = 8194;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_FRICTION_DATA:") )
      {
        if ( version >= 1 )
        {
          ReadLine(fileId, pLine, 256);
          sscanf((const char *)pLine, "%s %d", v15, &v14);
        }
        v10 = this;
        v11 = 8196;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_ATTRACTPT_DATA:") )
      {
        if ( version >= 1 )
        {
          ReadLine(fileId, pLine, 256);
          sscanf((const char *)pLine, "%s %d", v15, &v14);
        }
        v10 = this;
        v11 = 8200;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_ATTRACTLINE_DATA:") )
      {
        if ( version >= 1 )
        {
          ReadLine(fileId, pLine, 256);
          sscanf((const char *)pLine, "%s %d", v15, &v14);
        }
        v10 = this;
        v11 = 8208;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_GROUNDCOLLIDE_DATA:") )
      {
        if ( version >= 1 )
        {
          ReadLine(fileId, pLine, 256);
          sscanf((const char *)pLine, "%s %d", v15, &v14);
        }
        v10 = this;
        v11 = 8224;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_WIND_DATA:") )
      {
        if ( version >= 1 )
        {
          ReadLine(fileId, pLine, 256);
          sscanf((const char *)pLine, "%s %d", v15, &v14);
        }
        v10 = this;
        v11 = 8256;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_JITTER_DATA:") )
      {
        if ( version >= 1 )
        {
          ReadLine(fileId, pLine, 256);
          sscanf((const char *)pLine, "%s %d", v15, &v14);
        }
        v10 = this;
        v11 = 8320;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_ROTSPEED_DATA:") )
      {
        if ( version >= 1 )
        {
          ReadLine(fileId, pLine, 256);
          sscanf((const char *)pLine, "%s %d", v15, &v14);
        }
        v10 = this;
        v11 = 8448;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_FLOAT_DATA:") )
      {
        if ( version >= 1 )
        {
          ReadLine(fileId, pLine, 256);
          sscanf((const char *)pLine, "%s %d", v15, &v14);
        }
        v10 = this;
        v11 = 8704;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_UNDERWATER_DATA:") )
      {
        if ( version >= 1 )
        {
          ReadLine(fileId, pLine, 256);
          sscanf((const char *)pLine, "%s %d", v15, &v14);
        }
        v10 = this;
        v11 = 9216;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_COLOUR_DATA:") )
      {
        if ( version >= 1 )
        {
          ReadLine(fileId, pLine, 256);
          sscanf((const char *)pLine, "%s %d", v15, &v14);
        }
        v10 = this;
        v11 = 16385;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_SIZE_DATA:") )
      {
        if ( version >= 1 )
        {
          ReadLine(fileId, pLine, 256);
          sscanf((const char *)pLine, "%s %d", v15, &v14);
        }
        v10 = this;
        v11 = 16386;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_SPRITERECT_DATA:") )
      {
        if ( version >= 1 )
        {
          ReadLine(fileId, pLine, 256);
          sscanf((const char *)pLine, "%s %d", v15, &v14);
        }
        v10 = this;
        v11 = 16388;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_HEATHAZE_DATA:") )
      {
        if ( version >= 1 )
        {
          ReadLine(fileId, pLine, 256);
          sscanf((const char *)pLine, "%s %d", v15, &v14);
        }
        v10 = this;
        v11 = 16392;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_TRAIL_DATA:") )
      {
        if ( version >= 1 )
        {
          ReadLine(fileId, pLine, 256);
          sscanf((const char *)pLine, "%s %d", v15, &v14);
        }
        v10 = this;
        v11 = 16400;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_FLAT_DATA:") )
      {
        if ( version >= 1 )
        {
          ReadLine(fileId, pLine, 256);
          sscanf((const char *)pLine, "%s %d", v15, &v14);
        }
        v10 = this;
        v11 = 16416;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_DIR_DATA:") )
      {
        if ( version >= 1 )
        {
          ReadLine(fileId, pLine, 256);
          sscanf((const char *)pLine, "%s %d", v15, &v14);
        }
        v10 = this;
        v11 = 16448;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_ANIMTEX_DATA:") )
      {
        if ( version >= 1 )
        {
          ReadLine(fileId, pLine, 256);
          sscanf((const char *)pLine, "%s %d", v15, &v14);
        }
        v10 = this;
        v11 = 16512;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_COLOURRANGE_DATA:") )
      {
        if ( version >= 1 )
        {
          ReadLine(fileId, pLine, 256);
          sscanf((const char *)pLine, "%s %d", v15, &v14);
        }
        v10 = this;
        v11 = 16640;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_SELFLIT_DATA:") )
      {
        if ( version >= 1 )
        {
          ReadLine(fileId, pLine, 256);
          sscanf((const char *)pLine, "%s %d", v15, &v14);
        }
        v10 = this;
        v11 = 16896;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_COLOURBRIGHT_DATA:") )
      {
        if ( version >= 1 )
        {
          ReadLine(fileId, pLine, 256);
          sscanf((const char *)pLine, "%s %d", v15, &v14);
        }
        v10 = this;
        v11 = 17408;
        goto LABEL_113;
      }
      if ( !strcmp(v15, "FX_INFO_SMOKE_DATA:") )
      {
        if ( version >= 1 )
        {
          ReadLine(fileId, pLine, 256);
          sscanf((const char *)pLine, "%s %d", v15, &v14);
        }
        v10 = this;
        v11 = 32769;
        goto LABEL_113;
      }
LABEL_114:
      this->m_fxInfoPtrs[v9]->m_timeModeParticle = v14;
      if ( (this->m_fxInfoPtrs[v9]->m_type & 0x1000) == 0 )
      {
        if ( (this->m_fxInfoPtrs[v9]->m_type & 0x2000) != 0 )
        {
          if ( (unsigned __int8)this->m_movementOffset == 255 )
            this->m_movementOffset = v9;
        }
        else if ( (this->m_fxInfoPtrs[v9]->m_type & 0xC000) != 0 && (unsigned __int8)this->m_renderOffset == 255 )
        {
          this->m_renderOffset = v9;
        }
      }
      v8 = this->m_numFxInfos;
      if ( ++v9 >= this->m_numFxInfos )
        goto LABEL_123;
    }
    v10 = this;
    v11 = 4097;
LABEL_113:
    this->m_fxInfoPtrs[v9] = FxInfoManager_c::AddFxInfo(v10, v11);
    v12 = this->m_fxInfoPtrs[v9];
    (*((void (__fastcall **)(FxInfo_c *, u_native, int32))v12->_vptr$FxInfo_c + 2))(v12, fileId, version);
    ReadLine(fileId, pLine, 256);
    goto LABEL_114;
  }
LABEL_123:
  m_renderOffset = (unsigned __int8)this->m_renderOffset;
  if ( m_renderOffset == 255 )
  {
    this->m_renderOffset = v8;
    LOBYTE(m_renderOffset) = v8;
  }
  if ( (unsigned __int8)this->m_movementOffset == 255 )
    this->m_movementOffset = m_renderOffset;
}
// 46EC24: using guessed type int dword_46EC24;

//----- (0046ED7C) --------------------------------------------------------
void __fastcall FxInterpInfoFloat_c::Load(FxInterpInfoFloat_c *this, u_native fileId)
{
  int v4; // r11
  int v5; // r1
  uint16 *Mem; // r0
  int v7; // r8
  int v8; // r11
  int v9; // [sp+8h] [bp-1B8h]
  float v10; // [sp+Ch] [bp-1B4h] BYREF
  int v11; // [sp+10h] [bp-1B0h] BYREF
  char v12; // [sp+14h] [bp-1ACh] BYREF
  unsigned __int8 pLine[256]; // [sp+94h] [bp-12Ch] BYREF

  if ( this->m_numAttribs >= 1 )
  {
    v4 = 0;
    do
    {
      ReadLine(fileId, pLine, 256);
      sscanf((const char *)pLine, (const char *)&dword_46EF30, &v12);
      ReadLine(fileId, pLine, 256);
      sscanf((const char *)pLine, (const char *)&dword_46EF30, &v12);
      ReadLine(fileId, pLine, 256);
      sscanf((const char *)pLine, "%s %d", &v12, &v11);
      this->m_looped = v11;
      ReadLine(fileId, pLine, 256);
      sscanf((const char *)pLine, "%s %d", &v12, &v11);
      v5 = v11;
      this->m_numKeys = v11;
      if ( !v4 )
      {
        Mem = (uint16 *)FxMemoryPool_c::GetMem(&g_fxMan.m_fxMemPool, v5 << 24 >> 23, 2);
        LOBYTE(v5) = this->m_numKeys;
        this->m_times = Mem;
      }
      this->m_keys[v4] = (float *)FxMemoryPool_c::GetMem(&g_fxMan.m_fxMemPool, 4 * (char)v5, 4);
      v9 = v4;
      if ( this->m_numKeys >= 1 )
      {
        v7 = 0;
        v8 = 0;
        do
        {
          ReadLine(fileId, pLine, 256);
          sscanf((const char *)pLine, (const char *)&dword_46EF30, &v12);
          ReadLine(fileId, pLine, 256);
          sscanf((const char *)pLine, "%s %f", &v12, &v10);
          this->m_times[v8] = (unsigned int)(float)(v10 * 256.0);
          ReadLine(fileId, pLine, 256);
          sscanf((const char *)pLine, "%s %f", &v12, &this->m_keys[v9][v7]);
          ++v8;
          ++v7;
        }
        while ( v8 < this->m_numKeys );
      }
      v4 = v9 + 1;
    }
    while ( v9 + 1 < this->m_numAttribs );
  }
}
// 46EF30: using guessed type int dword_46EF30;

//----- (0046EF4C) --------------------------------------------------------
void __fastcall FxInterpInfoU255_c::Load(FxInterpInfoU255_c *this, u_native fileId)
{
  FxInterpInfoU255_c *v2; // r11
  u_native v3; // r4
  int v4; // r8
  int v5; // r1
  uint8 *Mem; // r0
  uint8 *v7; // r0
  int v8; // r9
  FxInterpInfoU255_c *v9; // r2
  u_native v10; // r0
  int v11; // r11
  u_native v12; // r6
  float v15; // [sp+14h] [bp-1B4h] BYREF
  int v16; // [sp+18h] [bp-1B0h] BYREF
  char v17; // [sp+1Ch] [bp-1ACh] BYREF
  unsigned __int8 pLine[256]; // [sp+9Ch] [bp-12Ch] BYREF

  v2 = this;
  v3 = fileId;
  if ( this->m_numAttribs >= 1 )
  {
    v4 = 0;
    do
    {
      ReadLine(v3, pLine, 256);
      sscanf((const char *)pLine, (const char *)&dword_46F128, &v17);
      ReadLine(v3, pLine, 256);
      sscanf((const char *)pLine, (const char *)&dword_46F128, &v17);
      ReadLine(v3, pLine, 256);
      sscanf((const char *)pLine, "%s %d", &v17, &v16);
      v2->m_looped = v16;
      ReadLine(v3, pLine, 256);
      sscanf((const char *)pLine, "%s %d", &v17, &v16);
      v5 = v16;
      v2->m_numKeys = v16;
      if ( !v4 )
      {
        Mem = FxMemoryPool_c::GetMem(&g_fxMan.m_fxMemPool, v5 << 24 >> 23, 2);
        LOBYTE(v5) = v2->m_numKeys;
        v2->m_times = (uint16 *)Mem;
      }
      v7 = FxMemoryPool_c::GetMem(&g_fxMan.m_fxMemPool, 2 * (char)v5, 2);
      v8 = v4;
      v9 = v2;
      v2->m_keys[v4] = (uint16 *)v7;
      v10 = fileId;
      if ( v2->m_numKeys >= 1 )
      {
        v11 = 0;
        do
        {
          v12 = v10;
          ReadLine(v10, pLine, 256);
          sscanf((const char *)pLine, (const char *)&dword_46F128, &v17);
          ReadLine(v12, pLine, 256);
          sscanf((const char *)pLine, "%s %f", &v17, &v15);
          this->m_times[v11] = (unsigned int)(float)(v15 * 256.0);
          ReadLine(v12, pLine, 256);
          sscanf((const char *)pLine, "%s %f", &v17, &v15);
          this->m_keys[v4][v11++] = (unsigned int)(float)(v15 * 256.0);
          v10 = v12;
          v9 = this;
        }
        while ( v11 < this->m_numKeys );
      }
      v3 = v10;
      v2 = v9;
      ++v4;
    }
    while ( v8 + 1 < v9->m_numAttribs );
  }
}
// 46F128: using guessed type int dword_46F128;

//----- (0046F144) --------------------------------------------------------
void __fastcall FxInterpInfo32_c::Load(FxInterpInfo32_c *this, u_native fileId)
{
  FxInterpInfo32_c *v2; // r11
  u_native v3; // r4
  int v4; // r8
  int v5; // r1
  uint8 *Mem; // r0
  uint8 *v7; // r0
  int v8; // r9
  FxInterpInfo32_c *v9; // r2
  u_native v10; // r0
  int v11; // r11
  u_native v12; // r6
  float v15; // [sp+14h] [bp-1BCh] BYREF
  int v16; // [sp+18h] [bp-1B8h] BYREF
  char v17; // [sp+1Ch] [bp-1B4h] BYREF
  unsigned __int8 pLine[256]; // [sp+9Ch] [bp-134h] BYREF

  v2 = this;
  v3 = fileId;
  if ( this->m_numAttribs >= 1 )
  {
    v4 = 0;
    do
    {
      ReadLine(v3, pLine, 256);
      sscanf((const char *)pLine, (const char *)&dword_46F324, &v17);
      ReadLine(v3, pLine, 256);
      sscanf((const char *)pLine, (const char *)&dword_46F324, &v17);
      ReadLine(v3, pLine, 256);
      sscanf((const char *)pLine, "%s %d", &v17, &v16);
      v2->m_looped = v16;
      ReadLine(v3, pLine, 256);
      sscanf((const char *)pLine, "%s %d", &v17, &v16);
      v5 = v16;
      v2->m_numKeys = v16;
      if ( !v4 )
      {
        Mem = FxMemoryPool_c::GetMem(&g_fxMan.m_fxMemPool, v5 << 24 >> 23, 2);
        LOBYTE(v5) = v2->m_numKeys;
        v2->m_times = (uint16 *)Mem;
      }
      v7 = FxMemoryPool_c::GetMem(&g_fxMan.m_fxMemPool, 2 * (char)v5, 2);
      v8 = v4;
      v9 = v2;
      v2->m_keys[v4] = (int16 *)v7;
      v10 = fileId;
      if ( v2->m_numKeys >= 1 )
      {
        v11 = 0;
        do
        {
          v12 = v10;
          ReadLine(v10, pLine, 256);
          sscanf((const char *)pLine, (const char *)&dword_46F324, &v17);
          ReadLine(v12, pLine, 256);
          sscanf((const char *)pLine, "%s %f", &v17, &v15);
          this->m_times[v11] = (unsigned int)(float)(v15 * 256.0);
          ReadLine(v12, pLine, 256);
          sscanf((const char *)pLine, "%s %f", &v17, &v15);
          this->m_keys[v4][v11++] = (int)(float)(v15 * 1000.0);
          v10 = v12;
          v9 = this;
        }
        while ( v11 < this->m_numKeys );
      }
      v3 = v10;
      v2 = v9;
      ++v4;
    }
    while ( v8 + 1 < v9->m_numAttribs );
  }
}
// 46F324: using guessed type int dword_46F324;

//----- (0046F344) --------------------------------------------------------
void __fastcall FxInterpInfo255_c::Load(FxInterpInfo255_c *this, u_native fileId)
{
  FxInterpInfo255_c *v2; // r11
  u_native v3; // r4
  int v4; // r8
  int v5; // r1
  uint8 *Mem; // r0
  uint8 *v7; // r0
  int v8; // r9
  FxInterpInfo255_c *v9; // r2
  u_native v10; // r0
  int v11; // r11
  u_native v12; // r6
  float v15; // [sp+14h] [bp-1BCh] BYREF
  int v16; // [sp+18h] [bp-1B8h] BYREF
  char v17; // [sp+1Ch] [bp-1B4h] BYREF
  unsigned __int8 pLine[256]; // [sp+9Ch] [bp-134h] BYREF

  v2 = this;
  v3 = fileId;
  if ( this->m_numAttribs >= 1 )
  {
    v4 = 0;
    do
    {
      ReadLine(v3, pLine, 256);
      sscanf((const char *)pLine, (const char *)&dword_46F524, &v17);
      ReadLine(v3, pLine, 256);
      sscanf((const char *)pLine, (const char *)&dword_46F524, &v17);
      ReadLine(v3, pLine, 256);
      sscanf((const char *)pLine, "%s %d", &v17, &v16);
      v2->m_looped = v16;
      ReadLine(v3, pLine, 256);
      sscanf((const char *)pLine, "%s %d", &v17, &v16);
      v5 = v16;
      v2->m_numKeys = v16;
      if ( !v4 )
      {
        Mem = FxMemoryPool_c::GetMem(&g_fxMan.m_fxMemPool, v5 << 24 >> 23, 2);
        LOBYTE(v5) = v2->m_numKeys;
        v2->m_times = (uint16 *)Mem;
      }
      v7 = FxMemoryPool_c::GetMem(&g_fxMan.m_fxMemPool, 2 * (char)v5, 2);
      v8 = v4;
      v9 = v2;
      v2->m_keys[v4] = (int16 *)v7;
      v10 = fileId;
      if ( v2->m_numKeys >= 1 )
      {
        v11 = 0;
        do
        {
          v12 = v10;
          ReadLine(v10, pLine, 256);
          sscanf((const char *)pLine, (const char *)&dword_46F524, &v17);
          ReadLine(v12, pLine, 256);
          sscanf((const char *)pLine, "%s %f", &v17, &v15);
          this->m_times[v11] = (unsigned int)(float)(v15 * 256.0);
          ReadLine(v12, pLine, 256);
          sscanf((const char *)pLine, "%s %f", &v17, &v15);
          this->m_keys[v4][v11++] = (int)(float)(v15 * 128.0);
          v10 = v12;
          v9 = this;
        }
        while ( v11 < this->m_numKeys );
      }
      v3 = v10;
      v2 = v9;
      ++v4;
    }
    while ( v8 + 1 < v9->m_numAttribs );
  }
}
// 46F524: using guessed type int dword_46F524;

//----- (0046F550) --------------------------------------------------------
RwBool __fastcall Initialise3D(void *param)
{
  if ( RsRwInitialize(param) )
    return CGame::InitialiseRender