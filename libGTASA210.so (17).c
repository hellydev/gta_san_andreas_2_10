nt v9; // r5
  int v10; // r0
  _DWORD *v11; // r5
  void *v12; // r0
  _DWORD *v13; // r6
  _DWORD *v14; // r5
  __int64 v15; // d16
  _DWORD *v16; // r5
  __int64 v17; // d16

  v2 = (*((int (__fastcall **)(CTaskSimpleGunControl *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleGunControl *))this->_vptr$CTask + 5))(this) != 1020 )
  {
    v10 = (*((int (__fastcall **)(CTaskSimpleGunControl *))this->_vptr$CTask + 5))(this);
    sub_1941C4(1020, v10);
    return;
  }
  m_pTargetEntity = this->m_pTargetEntity;
  if ( !m_pTargetEntity )
  {
    if ( UseDataFence )
      AddDataFence();
    v11 = malloc(4u);
    *v11 = 0;
    CGenericGameStorage::_SaveDataToWorkBuffer(v11, 4);
    v12 = v11;
    goto LABEL_18;
  }
  v5 = *(_BYTE *)&m_pTargetEntity->m_info & 7;
  if ( UseDataFence )
    AddDataFence();
  v6 = malloc(4u);
  *v6 = v5;
  CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
  free(v6);
  v7 = this->m_pTargetEntity;
  v8 = *(_BYTE *)&v7->m_info & 7;
  if ( v8 == 2 )
  {
    v9 = GettPoolVehicleRef((CVehicle *)v7);
    goto LABEL_15;
  }
  if ( v8 == 3 )
  {
    v9 = GettPoolPedRef((CPed *)v7);
LABEL_15:
    if ( UseDataFence )
      AddDataFence();
    v13 = malloc(4u);
    *v13 = v9;
    CGenericGameStorage::_SaveDataToWorkBuffer(v13, 4);
    v12 = v13;
LABEL_18:
    free(v12);
  }
  if ( UseDataFence )
    AddDataFence();
  v14 = malloc(0xCu);
  v15 = *(_QWORD *)&this->m_vecTargetPos.x;
  v14[2] = LODWORD(this->m_vecTargetPos.z);
  *(_QWORD *)v14 = v15;
  CGenericGameStorage::_SaveDataToWorkBuffer(v14, 12);
  free(v14);
  if ( UseDataFence )
    AddDataFence();
  v16 = malloc(0xCu);
  v17 = *(_QWORD *)&this->m_vecMoveTarget.x;
  v16[2] = LODWORD(this->m_vecMoveTarget.z);
  *(_QWORD *)v16 = v17;
  CGenericGameStorage::_SaveDataToWorkBuffer(v16, 12);
  j_free(v16);
}

//----- (004E9A2C) --------------------------------------------------------
CTask *__fastcall CTaskSimpleThrowProjectile::Clone(const CTaskSimpleThrowProjectile *this)
{
  char *v2; // r4
  CEntity *m_pTargetEntity; // r5
  __int64 v4; // r8
  RwReal z; // r6

  v2 = (char *)CTask::operator new(0x24u);
  m_pTargetEntity = this->m_pTargetEntity;
  v4 = *(_QWORD *)&this->m_vecTargetPos.x;
  z = this->m_vecTargetPos.z;
  CTaskSimple::CTaskSimple((CTaskSimple *)v2);
  *((_WORD *)v2 + 4) = 0;
  v2[10] = 0;
  *((_DWORD *)v2 + 3) = 0;
  *(_QWORD *)(v2 + 20) = v4;
  *((RwReal *)v2 + 7) = z;
  *(_DWORD *)v2 = &off_6696CC;
  *((_DWORD *)v2 + 4) = m_pTargetEntity;
  if ( m_pTargetEntity )
    CEntity::RegisterReference(m_pTargetEntity, (CEntity **)v2 + 4);
  *((_DWORD *)v2 + 8) = CTimer::m_snTimeInMilliseconds;
  return (CTask *)v2;
}
// 6696CC: using guessed type void *off_6696CC;

//----- (004E9A90) --------------------------------------------------------
int __fastcall CTaskSimpleThrowProjectile::GetTaskType(const CTaskSimpleThrowProjectile *this)
{
  return 1018;
}

//----- (004E9A98) --------------------------------------------------------
CTask *__fastcall CTaskSimpleThrowControl::Clone(const CTaskSimpleThrowControl *this)
{
  void *v2; // r4
  CEntity *m_pTargetEntity; // r9
  __int64 v4; // d16
  CTask *result; // r0

  v2 = CTask::operator new(0x1Cu);
  m_pTargetEntity = this->m_pTargetEntity;
  CTaskSimple::CTaskSimple((CTaskSimple *)v2);
  *((_DWORD *)v2 + 5) = 0;
  *((_DWORD *)v2 + 6) = 0;
  *((_WORD *)v2 + 4) = 0;
  *(_DWORD *)v2 = &off_669700;
  *((_DWORD *)v2 + 4) = 0;
  *((_DWORD *)v2 + 3) = m_pTargetEntity;
  if ( m_pTargetEntity )
    CEntity::RegisterReference(m_pTargetEntity, (CEntity **)v2 + 3);
  v4 = *(_QWORD *)&this->m_vecTargetPos.x;
  *((_DWORD *)v2 + 6) = LODWORD(this->m_vecTargetPos.z);
  result = (CTask *)v2;
  *((_QWORD *)v2 + 2) = v4;
  return result;
}
// 669700: using guessed type void *off_669700;

//----- (004E9AFC) --------------------------------------------------------
int __fastcall CTaskSimpleThrowControl::GetTaskType(const CTaskSimpleThrowControl *this)
{
  return 1021;
}

//----- (004E9B04) --------------------------------------------------------
CTask *__fastcall CTaskSimpleBeKickedOnGround::Clone(const CTaskSimpleBeKickedOnGround *this)
{
  CTaskSimple *v1; // r0
  CTask *result; // r0

  v1 = (CTaskSimple *)CTask::operator new(0x10u);
  CTaskSimple::CTaskSimple(v1);
  LOBYTE(result[1]._vptr$CTask) = 0;
  result[1].m_pParent = 0;
  result->_vptr$CTask = (int (**)(void))&off_669734;
  return result;
}
// 4E9B16: variable 'result' is possibly undefined
// 669734: using guessed type void *off_669734;

//----- (004E9B28) --------------------------------------------------------
int __fastcall CTaskSimpleBeKickedOnGround::GetTaskType(const CTaskSimpleBeKickedOnGround *this)
{
  return 1007;
}

//----- (004E9B30) --------------------------------------------------------
CTask *__fastcall CTaskSimpleBeHitWhileMoving::Clone(const CTaskSimpleBeHitWhileMoving *this)
{
  CTaskSimple *v2; // r0
  __int64 v3; // kr00_8
  CTask *result; // r0

  v2 = (CTaskSimple *)CTask::operator new(0x18u);
  v3 = *(_QWORD *)&this->m_nHitLevel;
  CTaskSimple::CTaskSimple(v2);
  LOBYTE(result[1]._vptr$CTask) = 0;
  *(_QWORD *)&result[1].m_pParent = v3;
  result[2].m_pParent = 0;
  result->_vptr$CTask = (int (**)(void))&off_669768;
  return result;
}
// 4E9B48: variable 'result' is possibly undefined
// 669768: using guessed type void *off_669768;

//----- (004E9B60) --------------------------------------------------------
int __fastcall CTaskSimpleBeHitWhileMoving::GetTaskType(const CTaskSimpleBeHitWhileMoving *this)
{
  return 1009;
}

//----- (004E9B68) --------------------------------------------------------
CTask *__fastcall CTaskSimpleChoking::Clone(const CTaskSimpleChoking *this)
{
  CTaskSimple *v2; // r0
  CPed *m_pAttacker; // r5
  CTaskSimple *v4; // r4
  int v5; // s0
  uint32 v6; // r0

  v2 = (CTaskSimple *)CTask::operator new(0x1Cu);
  m_pAttacker = this->m_pAttacker;
  v4 = v2;
  LOBYTE(this) = this->m_bIsTeargas;
  CTaskSimple::CTaskSimple(v2);
  v4[1].m_pParent = 0;
  LOBYTE(v4[3]._vptr$CTask) = (_BYTE)this;
  BYTE1(v4[3]._vptr$CTask) = 0;
  v4->_vptr$CTask = (int (**)(void))&off_66979C;
  v4[1]._vptr$CTask = (int (**)(void))m_pAttacker;
  if ( m_pAttacker )
    CEntity::RegisterReference(m_pAttacker, (CEntity **)&v4[1]);
  v5 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 1000.0);
  v6 = CTimer::m_snTimeInMilliseconds;
  v4[2]._vptr$CTask = (int (**)(void))(v5 + 1000);
  v4[2].m_pParent = (CTask *)v6;
  return v4;
}
// 66979C: using guessed type void *off_66979C;

//----- (004E9BF4) --------------------------------------------------------
int __fastcall CTaskSimpleChoking::GetTaskType(const CTaskSimpleChoking *this)
{
  return 263;
}

//----- (004E9BFC) --------------------------------------------------------
void __fastcall CTaskSimpleChoking::Serialize(CTaskSimpleChoking *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CPed *m_pAttacker; // r0
  int v5; // r5
  _DWORD *v6; // r6
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r5

  v2 = (*((int (__fastcall **)(CTaskSimpleChoking *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleChoking *))this->_vptr$CTask + 5))(this) == 263 )
  {
    m_pAttacker = this->m_pAttacker;
    if ( m_pAttacker )
    {
      v5 = GettPoolPedRef(m_pAttacker);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    free(v7);
    if ( UseDataFence )
      AddDataFence();
    sub_19E9A8(&this->m_bIsTeargas, 1);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskSimpleChoking *))this->_vptr$CTask + 5))(this);
    sub_1941C4(263, v8);
  }
}

//----- (004E9CEC) --------------------------------------------------------
CTask *__fastcall CTaskSimpleBeHit::Clone(const CTaskSimpleBeHit *this)
{
  CTaskSimple *v2; // r0
  CPed *m_pAttacker; // r6
  CTaskSimple *v4; // r5
  ePedPieceTypes m_eHitZone; // r8
  int m_nHitPower; // r9
  int m_nDirn; // r10
  bool m_bAnimAdded; // r0

  v2 = (CTaskSimple *)CTask::operator new(0x28u);
  m_pAttacker = this->m_pAttacker;
  v4 = v2;
  m_eHitZone = this->m_eHitZone;
  m_nHitPower = this->m_nHitPower;
  m_nDirn = this->m_nDirn;
  CTaskSimple::CTaskSimple(v2);
  LOWORD(v4[1].m_pParent) = 0;
  v4[2]._vptr$CTask = (int (**)(void))(&dword_BC + 3);
  v4[2].m_pParent = 0;
  v4[3]._vptr$CTask = (int (**)(void))m_eHitZone;
  v4[3].m_pParent = (CTask *)m_nHitPower;
  v4[4]._vptr$CTask = (int (**)(void))m_nDirn;
  v4[4].m_pParent = 0;
  v4->_vptr$CTask = (int (**)(void))&off_6697D0;
  v4[1]._vptr$CTask = (int (**)(void))m_pAttacker;
  if ( m_pAttacker )
    CEntity::RegisterReference(m_pAttacker, (CEntity **)&v4[1]);
  m_bAnimAdded = this->m_bAnimAdded;
  v4[2] = *(CTaskSimple *)&this->m_nAnimId;
  BYTE1(v4[1].m_pParent) = m_bAnimAdded;
  return v4;
}
// BC: using guessed type int dword_BC;
// 6697D0: using guessed type void *off_6697D0;

//----- (004E9D54) --------------------------------------------------------
int __fastcall CTaskSimpleBeHit::GetTaskType(const CTaskSimpleBeHit *this)
{
  return 1008;
}

//----- (004E9D5C) --------------------------------------------------------
CTask *__fastcall CTaskComplexReactToAttack::Clone(const CTaskComplexReactToAttack *this)
{
  CTaskComplex *v2; // r0
  __int64 v3; // kr00_8
  CTaskComplex *v4; // r4
  CTask v5; // kr08_8
  ePedPieceTypes m_eHitZone; // r6

  v2 = (CTaskComplex *)CTask::operator new(0x24u);
  v3 = *(_QWORD *)&this->m_eWeaponUsed;
  v4 = v2;
  v5 = *(CTask *)&this->m_fDamage;
  m_eHitZone = this->m_eHitZone;
  CTaskComplex::CTaskComplex(v2);
  LOWORD(v4[1]._vptr$CTask) = 0;
  v4[1].m_pParent = (CTask *)v3;
  v4[2].CTask = v5;
  v4[2].m_pSubTask = (CTask *)m_eHitZone;
  v4->_vptr$CTask = (int (**)(void))&off_669804;
  v4[1].m_pSubTask = (CTask *)HIDWORD(v3);
  if ( HIDWORD(v3) )
    CEntity::RegisterReference((CEntity *)HIDWORD(v3), (CEntity **)&v4[1].m_pSubTask);
  return v4;
}
// 669804: using guessed type void *off_669804;

//----- (004E9DB4) --------------------------------------------------------
int __fastcall CTaskComplexReactToAttack::GetTaskType(const CTaskComplexReactToAttack *this)
{
  return 1006;
}

//----- (004E9DBC) --------------------------------------------------------
CTask *__fastcall CTaskComplexKillPedOnFoot::Clone(const CTaskComplexKillPedOnFoot *this)
{
  void *v2; // r5
  CPed *m_pTargetPed; // r6
  uint32 m_nDuckingConditions; // r8
  uint32 m_nTimeToDuck; // r9
  uint32 m_nPercentageDuckChance; // r10
  int8 m_nCompetence; // r11
  char v8; // r2
  char v9; // r0
  uint32 v10; // r1
  char v11; // r0
  int32 m_nDuration; // [sp+0h] [bp-20h]

  v2 = CTask::operator new(0x38u);
  m_pTargetPed = this->m_pTargetPed;
  m_nDuckingConditions = this->m_nDuckingConditions;
  m_nTimeToDuck = this->m_nTimeToDuck;
  m_nPercentageDuckChance = this->m_nPercentageDuckChance;
  m_nDuration = this->m_nDuration;
  m_nCompetence = this->m_nCompetence;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_DWORD *)v2 + 5) = m_nDuckingConditions;
  *((_DWORD *)v2 + 6) = m_nTimeToDuck;
  *((_DWORD *)v2 + 7) = m_nPercentageDuckChance;
  *((_BYTE *)v2 + 32) = m_nCompetence;
  *((_DWORD *)v2 + 10) = m_nDuration;
  *((_WORD *)v2 + 26) = 0;
  *((_DWORD *)v2 + 12) = 0;
  v8 = *((_BYTE *)v2 + 12);
  *((_DWORD *)v2 + 11) = 0;
  *(_DWORD *)v2 = &off_669840;
  v9 = v8 & 0x8B | 4;
  *((_BYTE *)v2 + 12) = v9;
  *((_DWORD *)v2 + 4) = m_pTargetPed;
  if ( m_pTargetPed )
  {
    CEntity::RegisterReference(m_pTargetPed, (CEntity **)v2 + 4);
    v9 = *((_BYTE *)v2 + 12);
  }
  v10 = CTimer::m_snTimeInMilliseconds;
  *((_BYTE *)v2 + 12) = v9 & 0xF7;
  *((_DWORD *)v2 + 9) = v10;
  v11 = v9 & 0xE7 | *((_BYTE *)this + 12) & 0x10;
  *((_BYTE *)v2 + 12) = v11;
  *((_BYTE *)v2 + 12) = v11 & 0xD7 | *((_BYTE *)this + 12) & 0x20;
  return (CTask *)v2;
}
// 669840: using guessed type void *off_669840;

//----- (004E9E68) --------------------------------------------------------
int __fastcall CTaskComplexKillPedOnFoot::GetTaskType(const CTaskComplexKillPedOnFoot *this)
{
  return 1000;
}

//----- (004E9E70) --------------------------------------------------------
void __fastcall CTaskComplexKillPedOnFoot::Serialize(CTaskComplexKillPedOnFoot *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r4
  _DWORD *v5; // r5
  int v6; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexKillPedOnFoot *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexKillPedOnFoot *))this->_vptr$CTask + 5))(this) == 1000 )
  {
    v4 = GettPoolPedRef(this->m_pTargetPed);
    if ( UseDataFence )
      AddDataFence();
    v5 = malloc(4u);
    *v5 = v4;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 4);
    j_free(v5);
  }
  else
  {
    v6 = (*((int (__fastcall **)(CTaskComplexKillPedOnFoot *))this->_vptr$CTask + 5))(this);
    sub_1941C4(1000, v6);
  }
}

//----- (004E9F10) --------------------------------------------------------
CTask *__fastcall CTaskComplexKillPedOnFootStealth::Clone(const CTaskComplexKillPedOnFootStealth *this)
{
  void *v2; // r4
  CPed *m_pTargetPed; // r5
  char v4; // r1
  char v5; // r0
  uint32 v6; // r1
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  __int64 v9; // d16

  v2 = CTask::operator new(0x48u);
  m_pTargetPed = this->m_pTargetPed;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_DWORD *)v2 + 5) = 0;
  *((_DWORD *)v2 + 6) = 0;
  *((_DWORD *)v2 + 7) = 0;
  *((_BYTE *)v2 + 32) = 1;
  *((_DWORD *)v2 + 10) = -1;
  *((_WORD *)v2 + 26) = 0;
  *((_DWORD *)v2 + 12) = 0;
  v4 = *((_BYTE *)v2 + 12);
  *((_DWORD *)v2 + 11) = 0;
  *(_DWORD *)v2 = &off_669840;
  v5 = v4 & 0x8B | 4;
  *((_BYTE *)v2 + 12) = v5;
  *((_DWORD *)v2 + 4) = m_pTargetPed;
  if ( m_pTargetPed )
  {
    CEntity::RegisterReference(m_pTargetPed, (CEntity **)v2 + 4);
    v5 = *((_BYTE *)v2 + 12);
  }
  v6 = CTimer::m_snTimeInMilliseconds;
  *((_BYTE *)v2 + 12) = v5 & 0xF7;
  *((_DWORD *)v2 + 9) = v6;
  *(_DWORD *)v2 = &off_66987C;
  *((_DWORD *)v2 + 15) = 0;
  *((_DWORD *)v2 + 16) = -971227238;
  *((_DWORD *)v2 + 17) = -1;
  *((_DWORD *)v2 + 14) = 0;
  if ( m_pTargetPed )
  {
    m_pMat = m_pTargetPed->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &m_pTargetPed->m_transform;
    v9 = *(_QWORD *)&p_tx->m_translate.x;
    *((_DWORD *)v2 + 16) = LODWORD(p_tx->m_translate.z);
    *((_QWORD *)v2 + 7) = v9;
  }
  return (CTask *)v2;
}
// 669840: using guessed type void *off_669840;
// 66987C: using guessed type void *off_66987C;

//----- (004E9FD0) --------------------------------------------------------
int __fastcall CTaskComplexKillPedOnFootStealth::GetTaskType(const CTaskComplexKillPedOnFootStealth *this)
{
  return 1028;
}

//----- (004E9FD8) --------------------------------------------------------
CTask *__fastcall CTaskComplexKillPedOnFootMelee::Clone(const CTaskComplexKillPedOnFootMelee *this)
{
  void *v2; // r4
  CPed *m_pTargetPed; // r5

  v2 = CTask::operator new(0x38u);
  m_pTargetPed = this->m_pTargetPed;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_QWORD *)v2 + 2) = 0LL;
  *((_QWORD *)v2 + 3) = 0LL;
  *((_DWORD *)v2 + 8) = 0;
  *((_DWORD *)v2 + 9) = 0;
  *((_DWORD *)v2 + 10) = -1;
  *((_DWORD *)v2 + 11) = 0;
  *((_DWORD *)v2 + 13) = -1;
  *((_WORD *)v2 + 24) = 0;
  *(_DWORD *)v2 = &off_6698B8;
  *((_DWORD *)v2 + 3) = m_pTargetPed;
  if ( m_pTargetPed )
    CEntity::RegisterReference(m_pTargetPed, (CEntity **)v2 + 3);
  return (CTask *)v2;
}
// 6698B8: using guessed type void *off_6698B8;

//----- (004EA030) --------------------------------------------------------
int __fastcall CTaskComplexKillPedOnFootMelee::GetTaskType(const CTaskComplexKillPedOnFootMelee *this)
{
  return 1001;
}

//----- (004EA040) --------------------------------------------------------
CTask *__fastcall CTaskComplexKillPedOnFootArmed::Clone(const CTaskComplexKillPedOnFootArmed *this)
{
  CTaskComplex *v2; // r0
  CPed *m_pTargetPed; // r6
  CTaskComplex *v4; // r5
  uint32 m_nDuckingConditions; // r8
  uint32 m_nTimeToDuck; // r9
  uint32 m_nPercentageDuckChance; // r10
  int8 m_nCompetence; // r11

  v2 = (CTaskComplex *)CTask::operator new(0x5Cu);
  m_pTargetPed = this->m_pTargetPed;
  v4 = v2;
  m_nDuckingConditions = this->m_nDuckingConditions;
  m_nTimeToDuck = this->m_nTimeToDuck;
  m_nPercentageDuckChance = this->m_nPercentageDuckChance;
  m_nCompetence = this->m_nCompetence;
  CTaskComplex::CTaskComplex(v2);
  *(_QWORD *)&v4[4].m_pSubTask = 0LL;
  *(_QWORD *)&v4[5].m_pParent = 3323739136LL;
  v4[1].m_pParent = 0;
  v4[1].m_pSubTask = 0;
  v4[2]._vptr$CTask = 0;
  v4[2].m_pParent = (CTask *)m_nDuckingConditions;
  v4[2].m_pSubTask = (CTask *)m_nTimeToDuck;
  v4[3]._vptr$CTask = (int (**)(void))m_nPercentageDuckChance;
  v4[3].m_pParent = 0;
  v4[3].m_pSubTask = 0;
  LOBYTE(v4[4]._vptr$CTask) = m_nCompetence;
  *(int (***)(void))((char *)&v4[4]._vptr$CTask + 2) = 0;
  v4[6]._vptr$CTask = 0;
  v4[6].m_pParent = (CTask *)-971228160;
  v4[6].m_pSubTask = 0;
  v4[7]._vptr$CTask = 0;
  v4[7].m_pParent = 0;
  v4->_vptr$CTask = (int (**)(void))&off_6698F4;
  v4[1]._vptr$CTask = (int (**)(void))m_pTargetPed;
  if ( m_pTargetPed )
    CEntity::RegisterReference(m_pTargetPed, (CEntity **)&v4[1]);
  BYTE1(v4[4].m_pParent) = this->m_bAimImmediate;
  return v4;
}
// 6698F4: using guessed type void *off_6698F4;

//----- (004EA0E4) --------------------------------------------------------
int __fastcall CTaskComplexKillPedOnFootArmed::GetTaskType(const CTaskComplexKillPedOnFootArmed *this)
{
  return 1002;
}

//----- (004EA0EC) --------------------------------------------------------
CTask *__fastcall CTaskSimpleGangDriveBy::Clone(const CTaskSimpleGangDriveBy *this)
{
  char *v2; // r5
  bool m_bSeatRHS; // r6
  int8 m_nDrivebyStyle; // r9
  int8 m_nFrequencyPercentage; // r10
  CEntity *m_pTargetEntity; // r8
  float m_fAbortRange; // r11
  __int64 v8; // d16

  v2 = (char *)CTask::operator new(0x44u);
  m_bSeatRHS = this->m_bSeatRHS;
  m_nDrivebyStyle = this->m_nDrivebyStyle;
  m_nFrequencyPercentage = this->m_nFrequencyPercentage;
  m_pTargetEntity = this->m_pTargetEntity;
  m_fAbortRange = this->m_fAbortRange;
  CTaskSimple::CTaskSimple((CTaskSimple *)v2);
  v2[10] = m_bSeatRHS;
  *((_WORD *)v2 + 4) = 0;
  *(_DWORD *)(v2 + 11) = 0;
  v2[18] = m_nDrivebyStyle;
  v2[19] = m_nFrequencyPercentage;
  *((_DWORD *)v2 + 15) = 0;
  *((_DWORD *)v2 + 16) = 0;
  *(_WORD *)(v2 + 15) = 1;
  v2[17] = -1;
  v2[20] = -1;
  *((_WORD *)v2 + 11) = -1;
  *((_DWORD *)v2 + 6) = 0;
  v2[28] = 1;
  *(_DWORD *)v2 = &off_669930;
  *((_DWORD *)v2 + 13) = m_pTargetEntity;
  *((_DWORD *)v2 + 14) = 0;
  *((float *)v2 + 8) = m_fAbortRange;
  *((_DWORD *)v2 + 9) = 191;
  *((_DWORD *)v2 + 10) = 0;
  *((_DWORD *)v2 + 11) = 0;
  *((_DWORD *)v2 + 12) = 0;
  if ( m_pTargetEntity )
    CEntity::RegisterReference(m_pTargetEntity, (CEntity **)v2 + 13);
  v8 = *(_QWORD *)&this->m_vecCoords.x;
  *((_DWORD *)v2 + 16) = LODWORD(this->m_vecCoords.z);
  *((_QWORD *)v2 + 7) = v8;
  v2[14] = this->m_bFromScriptCommand;
  return (CTask *)v2;
}
// 669930: using guessed type void *off_669930;

//----- (004EA198) --------------------------------------------------------
int __fastcall CTaskSimpleGangDriveBy::GetTaskType(const CTaskSimpleGangDriveBy *this)
{
  return 1022;
}

//----- (004EA1A0) --------------------------------------------------------
void __fastcall CTaskSimpleGangDriveBy::Serialize(CTaskSimpleGangDriveBy *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CEntity *m_pTargetEntity; // r0
  int v5; // r6
  _DWORD *v6; // r5
  CEntity *v7; // r0
  int v8; // r1
  int v9; // r5
  int v10; // r0
  _DWORD *v11; // r5
  void *v12; // r0
  _DWORD *v13; // r6
  _DWORD *v14; // r5
  __int64 v15; // d16
  float m_fAbortRange; // r6
  float *v17; // r5

  v2 = (*((int (__fastcall **)(CTaskSimpleGangDriveBy *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleGangDriveBy *))this->_vptr$CTask + 5))(this) != 1022 )
  {
    v10 = (*((int (__fastcall **)(CTaskSimpleGangDriveBy *))this->_vptr$CTask + 5))(this);
    sub_1941C4(1022, v10);
    return;
  }
  m_pTargetEntity = this->m_pTargetEntity;
  if ( !m_pTargetEntity )
  {
    if ( UseDataFence )
      AddDataFence();
    v11 = malloc(4u);
    *v11 = 0;
    CGenericGameStorage::_SaveDataToWorkBuffer(v11, 4);
    v12 = v11;
    goto LABEL_18;
  }
  v5 = *(_BYTE *)&m_pTargetEntity->m_info & 7;
  if ( UseDataFence )
    AddDataFence();
  v6 = malloc(4u);
  *v6 = v5;
  CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
  free(v6);
  v7 = this->m_pTargetEntity;
  v8 = *(_BYTE *)&v7->m_info & 7;
  if ( v8 == 2 )
  {
    v9 = GettPoolVehicleRef((CVehicle *)v7);
    goto LABEL_15;
  }
  if ( v8 == 3 )
  {
    v9 = GettPoolPedRef((CPed *)v7);
LABEL_15:
    if ( UseDataFence )
      AddDataFence();
    v13 = malloc(4u);
    *v13 = v9;
    CGenericGameStorage::_SaveDataToWorkBuffer(v13, 4);
    v12 = v13;
LABEL_18:
    free(v12);
  }
  if ( UseDataFence )
    AddDataFence();
  v14 = malloc(0xCu);
  v15 = *(_QWORD *)&this->m_vecCoords.x;
  v14[2] = LODWORD(this->m_vecCoords.z);
  *(_QWORD *)v14 = v15;
  CGenericGameStorage::_SaveDataToWorkBuffer(v14, 12);
  free(v14);
  m_fAbortRange = this->m_fAbortRange;
  if ( UseDataFence )
    AddDataFence();
  v17 = (float *)malloc(4u);
  *v17 = m_fAbortRange;
  CGenericGameStorage::_SaveDataToWorkBuffer(v17, 4);
  free(v17);
  if ( UseDataFence )
    AddDataFence();
  CGenericGameStorage::_SaveDataToWorkBuffer(&this->m_nFrequencyPercentage, 1);
  if ( UseDataFence )
    AddDataFence();
  CGenericGameStorage::_SaveDataToWorkBuffer(&this->m_nDrivebyStyle, 1);
  if ( UseDataFence )
    AddDataFence();
  sub_19E9A8(&this->m_bSeatRHS, 1);
}

//----- (004EA384) --------------------------------------------------------
CTask *__fastcall CTaskComplexDestroyCar::Clone(const CTaskComplexDestroyCar *this)
{
  char *v2; // r4
  CVehicle *m_pTargetVehicle; // r5
  __int64 v4; // r8
  uint32 m_nPercentageDuckChance; // r6

  v2 = (char *)CTask::operator new(0x20u);
  m_pTargetVehicle = this->m_pTargetVehicle;
  v4 = *(_QWORD *)&this->m_nDuckingConditions;
  m_nPercentageDuckChance = this->m_nPercentageDuckChance;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *(_QWORD *)(v2 + 20) = v4;
  *((_DWORD *)v2 + 7) = m_nPercentageDuckChance;
  *(_DWORD *)v2 = &off_669964;
  *((_DWORD *)v2 + 4) = m_pTargetVehicle;
  if ( m_pTargetVehicle )
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v2 + 4);
  return (CTask *)v2;
}
// 669964: using guessed type void *off_669964;

//----- (004EA3D4) --------------------------------------------------------
int __fastcall CTaskComplexDestroyCar::GetTaskType(const CTaskComplexDestroyCar *this)
{
  return 1003;
}

//----- (004EA3DC) --------------------------------------------------------
void __fastcall CTaskComplexDestroyCar::Serialize(CTaskComplexDestroyCar *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CVehicle *m_pTargetVehicle; // r0
  int v5; // r5
  _DWORD *v6; // r6
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r5
  _DWORD *v10; // r5
  _DWORD *v11; // r5
  _DWORD *v12; // r5

  v2 = (*((int (__fastcall **)(CTaskComplexDestroyCar *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexDestroyCar *))this->_vptr$CTask + 5))(this) == 1003 )
  {
    m_pTargetVehicle = this->m_pTargetVehicle;
    if ( m_pTargetVehicle )
    {
      v5 = GettPoolVehicleRef(m_pTargetVehicle);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    free(v7);
    if ( UseDataFence )
      AddDataFence();
    v10 = malloc(4u);
    *v10 = this->m_nDuckingConditions;
    CGenericGameStorage::_SaveDataToWorkBuffer(v10, 4);
    free(v10);
    if ( UseDataFence )
      AddDataFence();
    v11 = malloc(4u);
    *v11 = this->m_nTimeToDuck;
    CGenericGameStorage::_SaveDataToWorkBuffer(v11, 4);
    free(v11);
    if ( UseDataFence )
      AddDataFence();
    v12 = malloc(4u);
    *v12 = this->m_nPercentageDuckChance;
    CGenericGameStorage::_SaveDataToWorkBuffer(v12, 4);
    j_free(v12);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexDestroyCar *))this->_vptr$CTask + 5))(this);
    sub_1941C4(1003, v8);
  }
}

//----- (004EA538) --------------------------------------------------------
CTask *__fastcall CTaskComplexDestroyCarMelee::Clone(const CTaskComplexDestroyCarMelee *this)
{
  char *v2; // r4
  CVehicle *m_pTargetVehicle; // r5

  v2 = (char *)CTask::operator new(0x34u);
  m_pTargetVehicle = this->m_pTargetVehicle;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *(_QWORD *)(v2 + 20) = 0LL;
  *(_QWORD *)(v2 + 28) = 0LL;
  *((_WORD *)v2 + 6) = 0;
  *((_DWORD *)v2 + 10) = 0;
  *((_DWORD *)v2 + 11) = 0;
  *((_DWORD *)v2 + 12) = -1;
  *(_DWORD *)v2 = &off_6699A0;
  *((_DWORD *)v2 + 4) = m_pTargetVehicle;
  if ( m_pTargetVehicle )
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v2 + 4);
  return (CTask *)v2;
}
// 6699A0: using guessed type void *off_6699A0;

//----- (004EA58C) --------------------------------------------------------
int __fastcall CTaskComplexDestroyCarMelee::GetTaskType(const CTaskComplexDestroyCarMelee *this)
{
  return 1004;
}

//----- (004EA594) --------------------------------------------------------
CTask *__fastcall CTaskComplexDestroyCarArmed::Clone(const CTaskComplexDestroyCarArmed *this)
{
  CTaskComplex *v2; // r0
  CVehicle *m_pTargetVehicle; // r5
  CTaskComplex *v4; // r4
  __int64 v5; // r8
  uint32 m_nPercentageDuckChance; // r6

  v2 = (CTaskComplex *)CTask::operator new(0x64u);
  m_pTargetVehicle = this->m_pTargetVehicle;
  v4 = v2;
  v5 = *(_QWORD *)&this->m_nDuckingConditions;
  m_nPercentageDuckChance = this->m_nPercentageDuckChance;
  CTaskComplex::CTaskComplex(v2);
  *(_QWORD *)((char *)&v4[5].m_pParent + 1) = 0LL;
  *(CTask *)((char *)&v4[6].CTask + 1) = 0LL;
  *(_QWORD *)&v4[4].m_pParent = 0LL;
  v4[5].CTask = 0LL;
  v4[3].CTask = 0LL;
  *(_QWORD *)&v4[3].m_pSubTask = 0LL;
  *(_QWORD *)&v4[1].m_pSubTask = 0LL;
  *(_QWORD *)&v4[2].m_pParent = 0LL;
  v4[7]._vptr$CTask = (int (**)(void))-1;
  *(_QWORD *)&v4[7].m_pParent = v5;
  v4[8]._vptr$CTask = (int (**)(void))m_nPercentageDuckChance;
  v4->_vptr$CTask = (int (**)(void))&off_6699DC;
  v4[1].m_pParent = (CTask *)m_pTargetVehicle;
  if ( m_pTargetVehicle )
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)&v4[1].m_pParent);
  return v4;
}
// 6699DC: using guessed type void *off_6699DC;

//----- (004EA60C) --------------------------------------------------------
int __fastcall CTaskComplexDestroyCarArmed::GetTaskType(const CTaskComplexDestroyCarArmed *this)
{
  return 1005;
}

//----- (004EA614) --------------------------------------------------------
CTask *__fastcall CTaskComplexRoadRage::Clone(const CTaskComplexRoadRage *this)
{
  void *v2; // r4
  CPed *m_pTargetPed; // r5

  v2 = CTask::operator new(0x10u);
  m_pTargetPed = this->m_pTargetPed;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *(_DWORD *)v2 = &off_669A18;
  *((_DWORD *)v2 + 3) = m_pTargetPed;
  if ( m_pTargetPed )
    CEntity::RegisterReference(m_pTargetPed, (CEntity **)v2 + 3);
  return (CTask *)v2;
}
// 669A18: using guessed type void *off_669A18;

//----- (004EA64C) --------------------------------------------------------
int __fastcall CTaskComplexRoadRage::GetTaskType(const CTaskComplexRoadRage *this)
{
  return 1031;
}

//----- (004EA654) --------------------------------------------------------
CTask *__fastcall CTaskComplexKillAllThreats::Clone(const CTaskComplexKillAllThreats *this)
{
  CTaskComplex *v2; // r0
  __int64 v3; // kr00_8
  CTask *m_nPercentageDuckChance; // r4
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x18u);
  v3 = *(_QWORD *)&this->m_nDuckingConditions;
  m_nPercentageDuckChance = (CTask *)this->m_nPercentageDuckChance;
  CTaskComplex::CTaskComplex(v2);
  *(_QWORD *)&result[1].m_pParent = v3;
  result[2].m_pParent = m_nPercentageDuckChance;
  result->_vptr$CTask = (int (**)(void))&off_669A54;
  return result;
}
// 4EA670: variable 'result' is possibly undefined
// 669A54: using guessed type void *off_669A54;

//----- (004EA688) --------------------------------------------------------
int __fastcall CTaskComplexKillAllThreats::GetTaskType(const CTaskComplexKillAllThreats *this)
{
  return 1014;
}

//----- (004EA690) --------------------------------------------------------
CTask *__fastcall CTaskComplexKillPedGroupOnFoot::Clone(const CTaskComplexKillPedGroupOnFoot *this)
{
  void *v2; // r4
  __int64 v3; // kr00_8

  v2 = CTask::operator new(0x14u);
  v3 = *(_QWORD *)&this->m_iGroupID;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_DWORD *)v2 + 3) = v3;
  *(_DWORD *)v2 = &off_669A90;
  *((_DWORD *)v2 + 4) = HIDWORD(v3);
  if ( HIDWORD(v3) )
    CEntity::RegisterReference((CEntity *)HIDWORD(v3), (CEntity **)v2 + 4);
  return (CTask *)v2;
}
// 669A90: using guessed type void *off_669A90;

//----- (004EA6D4) --------------------------------------------------------
int __fastcall CTaskComplexKillPedGroupOnFoot::GetTaskType(const CTaskComplexKillPedGroupOnFoot *this)
{
  return 1015;
}

//----- (004EA6DC) --------------------------------------------------------
CTask *__fastcall CTaskSimpleStealthKill::Clone(const CTaskSimpleStealthKill *this)
{
  CTaskSimple *v2; // r0
  __int64 v3; // kr00_8
  CTaskSimple *v4; // r4

  v2 = (CTaskSimple *)CTask::operator new(0x20u);
  v3 = *(_QWORD *)&this->m_pOtherPed;
  v4 = v2;
  LOBYTE(this) = this->m_bAttacker;
  CTaskSimple::CTaskSimple(v2);
  LOBYTE(v4[1]._vptr$CTask) = (_BYTE)this;
  v4[2]._vptr$CTask = (int (**)(void))HIDWORD(v3);
  LOWORD(v4[2].m_pParent) = 0;
  v4[3]._vptr$CTask = 0;
  v4[3].m_pParent = 0;
  v4->_vptr$CTask = (int (**)(void))&off_669ACC;
  v4[1].m_pParent = (CTask *)v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)&v4[1].m_pParent);
  return v4;
}
// 669ACC: using guessed type void *off_669ACC;

//----- (004EA730) --------------------------------------------------------
int __fastcall CTaskSimpleStealthKill::GetTaskType(const CTaskSimpleStealthKill *this)
{
  return 1027;
}

//----- (004EA738) --------------------------------------------------------
CTask *__fastcall CTaskComplexKillPedFromBoat::Clone(const CTaskComplexKillPedFromBoat *this)
{
  void *v2; // r4
  CPed *m_pTargetPed; // r5

  v2 = CTask::operator new(0x10u);
  m_pTargetPed = this->m_pTargetPed;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *(_DWORD *)v2 = &off_669B00;
  *((_DWORD *)v2 + 3) = m_pTargetPed;
  if ( m_pTargetPed )
    CEntity::RegisterReference(m_pTargetPed, (CEntity **)v2 + 3);
  return (CTask *)v2;
}
// 669B00: using guessed type void *off_669B00;

//----- (004EA770) --------------------------------------------------------
int __fastcall CTaskComplexKillPedFromBoat::GetTaskType(const CTaskComplexKillPedFromBoat *this)
{
  return 1032;
}

//----- (004EA778) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekCoverUntilTargetDead::Clone(const CTaskComplexSeekCoverUntilTargetDead *this)
{
  int m_iGroupId; // r6
  CTaskComplex *v3; // r0
  CTaskComplex *v4; // r4
  int v5; // r5
  CPed *m_pTargetPed; // r5

  m_iGroupId = this->m_iGroupId;
  v3 = (CTaskComplex *)CTask::operator new(0x18u);
  v4 = v3;
  if ( m_iGroupId < 0 )
  {
    m_pTargetPed = this->m_pTargetPed;
    CTaskComplex::CTaskComplex(v3);
    v4[1]._vptr$CTask = (int (**)(void))-1;
    v4[1].m_pSubTask = 0;
    v4->_vptr$CTask = (int (**)(void))&off_669B3C;
    v4[1].m_pParent = (CTask *)m_pTargetPed;
    if ( m_pTargetPed )
      CEntity::RegisterReference(m_pTargetPed, (CEntity **)&v4[1].m_pParent);
  }
  else
  {
    v5 = this->m_iGroupId;
    CTaskComplex::CTaskComplex(v3);
    v4[1]._vptr$CTask = (int (**)(void))v5;
    v4[1].m_pParent = 0;
    v4[1].m_pSubTask = 0;
    v4->_vptr$CTask = (int (**)(void))&off_669B3C;
  }
  return v4;
}
// 669B3C: using guessed type void *off_669B3C;

//----- (004EA7EC) --------------------------------------------------------
int __fastcall CTaskComplexSeekCoverUntilTargetDead::GetTaskType(const CTaskComplexSeekCoverUntilTargetDead *this)
{
  return 1034;
}

//----- (004EA7F2) --------------------------------------------------------
void __fastcall CEventVehicleDamageWeapon::~CEventVehicleDamageWeapon(CEventVehicleDamageWeapon *this)
{
  void *v1; // r0

  CEventVehicleDamage::~CEventVehicleDamage(this);
  sub_1978E4(v1);
}
// 4EA7FE: variable 'v1' is possibly undefined

//----- (004EA802) --------------------------------------------------------
int __fastcall CEventVehicleDamageWeapon::GetEventType(const CEventVehicleDamageWeapon *this)
{
  return 41;
}

//----- (004EA808) --------------------------------------------------------
CEvent *__fastcall CEventVehicleDamageWeapon::CloneEditable(const CEventVehicleDamageWeapon *this)
{
  CEventVehicleDamage *v2; // r0
  CEvent *result; // r0

  v2 = (CEventVehicleDamage *)CEvent::operator new(0x1Cu);
  CEventVehicleDamage::CEventVehicleDamage(
    v2,
    this->m_pVehicle,
    this->m_pInflictor,
    (const eWeaponType)this->m_eWeaponUsed);
  result->_vptr$CEvent = (int (**)(void))&off_669BAC;
  return result;
}
// 4EA826: variable 'result' is possibly undefined
// 669BAC: using guessed type void *off_669BAC;

//----- (004EA830) --------------------------------------------------------
void __fastcall CTaskSimpleStandStill::CTaskSimpleStandStill(
        CTaskSimpleStandStill *this,
        const int iDuration,
        const bool bForever,
        const bool bTillStopped,
        float fIdleBlendDelta)
{
  int v8; // r0

  CTaskSimple::CTaskSimple(this);
  *(_DWORD *)(v8 + 8) = iDuration;
  *(_WORD *)(v8 + 20) = 0;
  *(float *)(v8 + 28) = fIdleBlendDelta;
  *(_BYTE *)(v8 + 24) = bForever;
  *(_BYTE *)(v8 + 25) = bTillStopped;
  *(_DWORD *)(v8 + 12) = 0;
  *(_DWORD *)(v8 + 16) = 0;
  *(_DWORD *)v8 = &off_669BFC;
}
// 4EA84C: variable 'v8' is possibly undefined
// 669BFC: using guessed type void *;

//----- (004EA86C) --------------------------------------------------------
void __fastcall CTaskSimpleStandStill::~CTaskSimpleStandStill(CTaskSimpleStandStill *this)
{
  void *v1; // r0

  CTask::~CTask(this);
  sub_197118(v1);
}
// 4EA878: variable 'v1' is possibly undefined

//----- (004EA87C) --------------------------------------------------------
bool __fastcall CTaskSimpleStandStill::ProcessPed(CTaskSimpleStandStill *this, CPed *pPed)
{
  CTaskSimpleDuck *v4; // r0
  CAnimBlendAssociation *Association; // r0
  int m_iDuration; // r0
  CTaskSimpleDuck *TaskDuck; // r0
  unsigned int v9; // r1
  int m_iStartTime; // r0
  CPlayerPedData *m_pPlayerData; // r0

  if ( !this->m_timer.m_bIsActive )
  {
    m_iDuration = this->m_iDuration;
    if ( m_iDuration >= 0 )
    {
      this->m_timer.m_iStartTime = CTimer::m_snTimeInMilliseconds;
      this->m_timer.m_iDuration = m_iDuration;
      this->m_timer.m_bIsActive = 1;
      if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
      {
        CPed::SetMoveState(pPed, PEDMOVE_STILL);
        pPed->m_eMoveStateAnim = PEDMOVE_STILL;
        if ( (*((_BYTE *)&pPed->m_nPedFlags + 3) & 4) != 0 && CPedIntelligence::GetTaskDuck(pPed->m_pPedIntelligence, 0) )
        {
          TaskDuck = CPedIntelligence::GetTaskDuck(pPed->m_pPedIntelligence, 0);
          CTaskSimpleDuck::ControlDuckMove(TaskDuck, 0LL);
        }
        else
        {
          CAnimManager::BlendAnimation(
            (RpClump_0 *)pPed->m_pRwObject,
            pPed->m_motionAnimGroup,
            ANIM_STD_IDLE,
            this->m_fIdleBlendDelta);
        }
        m_pPlayerData = pPed->m_pPlayerData;
        if ( m_pPlayerData )
          m_pPlayerData->m_moveBlendRatio = 0.0;
      }
    }
  }
  if ( (*((_BYTE *)&pPed->m_nPedFlags + 3) & 4) != 0 && CPedIntelligence::GetTaskDuck(pPed->m_pPedIntelligence, 0) )
  {
    v4 = CPedIntelligence::GetTaskDuck(pPed->m_pPedIntelligence, 0);
    CTaskSimpleDuck::ControlDuckMove(v4, 0LL);
  }
  else
  {
    CPed::SetMoveState(pPed, PEDMOVE_STILL);
  }
  if ( this->m_bTillStopped )
  {
    Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 3u);
    if ( Association )
    {
      if ( Association->m_fBlendAmount > 0.99 )
        return 1;
    }
  }
  if ( this->m_bForever || !this->m_timer.m_bIsActive )
    return 0;
  if ( this->m_timer.m_bIsStopped )
  {
    v9 = CTimer::m_snTimeInMilliseconds;
    this->m_timer.m_bIsStopped = 0;
    this->m_timer.m_iStartTime = v9;
    m_iStartTime = v9;
  }
  else
  {
    m_iStartTime = this->m_timer.m_iStartTime;
    v9 = CTimer::m_snTimeInMilliseconds;
  }
  return this->m_timer.m_iDuration + m_iStartTime <= v9;
}

//----- (004EA9AC) --------------------------------------------------------
bool __fastcall CTaskSimpleOnEscalator::ProcessPed(CTaskSimpleOnEscalator *this, CPed *pPed)
{
  CEntity *m_pEntityStandingOn; // r1
  int m_nModelIndex; // r0
  float RadianAngleBetweenPoints; // r0

  CTaskSimpleStandStill::ProcessPed(this, pPed);
  m_pEntityStandingOn = pPed->m_pEntityStandingOn;
  if ( !m_pEntityStandingOn )
    return 1;
  m_nModelIndex = m_pEntityStandingOn->m_nModelIndex;
  if ( m_nModelIndex != MI_ESCALATORSTEP && m_nModelIndex != MI_ESCALATORSTEP8 )
    return 1;
  RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                               m_pEntityStandingOn[1].m_transform.m_translate.z,
                               m_pEntityStandingOn[1].m_transform.m_heading,
                               0.0,
                               0.0);
  pPed->m_fDesiredHeading = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
  return 0;
}

//----- (004EAA00) --------------------------------------------------------
void __fastcall CTaskSimpleSetStayInSamePlace::CTaskSimpleSetStayInSamePlace(
        CTaskSimpleSetStayInSamePlace *this,
        const bool bStayInSamePlace)
{
  int v3; // r0

  CTaskSimple::CTaskSimple(this);
  *(_BYTE *)(v3 + 8) = bStayInSamePlace;
  *(_DWORD *)v3 = &off_669C30;
}
// 4EAA0C: variable 'v3' is possibly undefined
// 669C30: using guessed type void *;

//----- (004EAA20) --------------------------------------------------------
void __fastcall CTaskSimpleSetStayInSamePlace::~CTaskSimpleSetStayInSamePlace(CTaskSimpleSetStayInSamePlace *this)
{
  void *v1; // r0

  CTask::~CTask(this);
  sub_197118(v1);
}
// 4EAA2C: variable 'v1' is possibly undefined

//----- (004EAA30) --------------------------------------------------------
bool __fastcall CTaskSimpleSetStayInSamePlace::ProcessPed(CTaskSimpleSetStayInSamePlace *this, CPed *pPed)
{
  int v2; // r3
  int v3; // r12
  int v4; // lr
  bool result; // r0

  v2 = *((_DWORD *)&pPed->m_nPedFlags + 1);
  v3 = *((_DWORD *)&pPed->m_nPedFlags + 2);
  v4 = *((_DWORD *)&pPed->m_nPedFlags + 3);
  *(_DWORD *)&pPed->m_nPedFlags = *(_DWORD *)&pPed->m_nPedFlags & 0xFFDFFFFF | (this->m_bStayInSamePlace << 21);
  result = 1;
  *((_DWORD *)&pPed->m_nPedFlags + 1) = v2;
  *((_DWORD *)&pPed->m_nPedFlags + 2) = v3;
  *((_DWORD *)&pPed->m_nPedFlags + 3) = v4;
  return result;
}

//----- (004EAA64) --------------------------------------------------------
void __fastcall CTaskSimpleSetKindaStayInSamePlace::CTaskSimpleSetKindaStayInSamePlace(
        CTaskSimpleSetKindaStayInSamePlace *this,
        const bool bKindaStayInSamePlace)
{
  int v3; // r0

  CTaskSimple::CTaskSimple(this);
  *(_BYTE *)(v3 + 8) = bKindaStayInSamePlace;
  *(_DWORD *)v3 = &off_669C64;
}
// 4EAA70: variable 'v3' is possibly undefined
// 669C64: using guessed type void *;

//----- (004EAA84) --------------------------------------------------------
void __fastcall CTaskSimpleSetKindaStayInSamePlace::~CTaskSimpleSetKindaStayInSamePlace(
        CTaskSimpleSetKindaStayInSamePlace *this)
{
  void *v1; // r0

  CTask::~CTask(this);
  sub_197118(v1);
}
// 4EAA90: variable 'v1' is possibly undefined

//----- (004EAA94) --------------------------------------------------------
bool __fastcall CTaskSimpleSetKindaStayInSamePlace::ProcessPed(CTaskSimpleSetKindaStayInSamePlace *this, CPed *pPed)
{
  int v2; // r3
  int v3; // r12
  int v4; // lr
  bool result; // r0

  v2 = *((_DWORD *)&pPed->m_nPedFlags + 1);
  v3 = *((_DWORD *)&pPed->m_nPedFlags + 2);
  v4 = *((_DWORD *)&pPed->m_nPedFlags + 3);
  *(_DWORD *)&pPed->m_nPedFlags = *(_DWORD *)&pPed->m_nPedFlags & 0xFFBFFFFF | (this->m_bKindaStayInSamePlace << 22);
  result = 1;
  *((_DWORD *)&pPed->m_nPedFlags + 1) = v2;
  *((_DWORD *)&pPed->m_nPedFlags + 2) = v3;
  *((_DWORD *)&pPed->m_nPedFlags + 3) = v4;
  return result;
}

//----- (004EAAC8) --------------------------------------------------------
void __fastcall CTaskSimpleDuckToggle::CTaskSimpleDuckToggle(CTaskSimpleDuckToggle *this, int nSwitchOn)
{
  _DWORD *v3; // r0

  CTaskSimple::CTaskSimple(this);
  v3[2] = nSwitchOn;
  *v3 = &off_669C98;
}
// 4EAAD4: variable 'v3' is possibly undefined
// 669C98: using guessed type void *;

//----- (004EAAE8) --------------------------------------------------------
void __fastcall CTaskSimpleDuckToggle::~CTaskSimpleDuckToggle(CTaskSimpleDuckToggle *this)
{
  void *v1; // r0

  CTask::~CTask(this);
  sub_197118(v1);
}
// 4EAAF4: variable 'v1' is possibly undefined

//----- (004EAAF8) --------------------------------------------------------
bool __fastcall CTaskSimpleDuckToggle::ProcessPed(CTaskSimpleDuckToggle *this, CPed *pPed)
{
  int m_nToggleType; // r0
  CTaskSimpleDuck *TaskDuck; // r0
  bool v6; // zf
  CTask *v7; // r0
  CTaskSimpleDuck *SimplestActiveTask; // r5
  CTaskSimpleDuck *v9; // r0
  CTaskSimpleDuck *v10; // r0
  CPedIntelligence *v11; // r5
  CTaskSimpleDuck *v12; // r4
  CPedIntelligence *m_pPedIntelligence; // r6
  CTaskSimpleDuck *v14; // r5
  CTaskSimpleUseGun *TaskUseGun; // r0

  m_nToggleType = this->m_nToggleType;
  if ( (unsigned int)(m_nToggleType + 1) <= 1 )
  {
    if ( CPedIntelligence::GetTaskDuck(pPed->m_pPedIntelligence, 0) )
    {
      TaskDuck = CPedIntelligence::GetTaskDuck(pPed->m_pPedIntelligence, 0);
      (*((void (__fastcall **)(CTaskSimpleDuck *, CPed *, _DWORD, _DWORD))TaskDuck->_vptr$CTask + 7))(
        TaskDuck,
        pPed,
        0,
        0);
LABEL_22:
      if ( CPedIntelligence::GetTaskUseGun(pPed->m_pPedIntelligence) )
      {
        TaskUseGun = CPedIntelligence::GetTaskUseGun(pPed->m_pPedIntelligence);
        CTaskSimpleUseGun::ClearAnim(TaskUseGun, pPed);
      }
      return 1;
    }
    m_nToggleType = this->m_nToggleType;
  }
  v6 = m_nToggleType == 1;
  if ( m_nToggleType != 1 )
    v6 = m_nToggleType == -1;
  if ( v6 )
  {
    if ( CTaskManager::GetSimplestActiveTask(&pPed->m_pPedIntelligence->m_taskManager)
      && (v7 = CTaskManager::GetSimplestActiveTask(&pPed->m_pPedIntelligence->m_taskManager),
          (*((int (__fastcall **)(CTask *))v7->_vptr$CTask + 5))(v7) == 415) )
    {
      SimplestActiveTask = (CTaskSimpleDuck *)CTaskManager::GetSimplestActiveTask(&pPed->m_pPedIntelligence->m_taskManager);
    }
    else
    {
      SimplestActiveTask = 0;
    }
    if ( !CPedIntelligence::GetTaskDuck(pPed->m_pPedIntelligence, 1) )
    {
      if ( SimplestActiveTask )
        (*((void (__fastcall **)(CTaskSimpleDuck *, CPed *, int, _DWORD))SimplestActiveTask->_vptr$CTask + 7))(
          SimplestActiveTask,
          pPed,
          1,
          0);
      m_pPedIntelligence = pPed->m_pPedIntelligence;
      v14 = (CTaskSimpleDuck *)CTask::operator new(0x28u);
      CTaskSimpleDuck::CTaskSimpleDuck(v14, 4u, 0, -1);
      CTaskManager::SetTaskSecondary(&m_pPedIntelligence->m_taskManager, v14, 1);
      goto LABEL_22;
    }
    if ( CPedIntelligence::GetTaskDuck(pPed->m_pPedIntelligence, 1)->m_nDuckControlType != 4 )
    {
      if ( SimplestActiveTask )
        CTaskSimpleDuck::AbortBecauseOfOtherDuck(SimplestActiveTask, pPed);
      v9 = CPedIntelligence::GetTaskDuck(pPed->m_pPedIntelligence, 1);
      if ( !CTaskSimpleDuck::SetControlType(v9, 4u) )
      {
        v10 = CPedIntelligence::GetTaskDuck(pPed->m_pPedIntelligence, 1);
        CTaskSimpleDuck::AbortBecauseOfOtherDuck(v10, pPed);
        v11 = pPed->m_pPedIntelligence;
        v12 = (CTaskSimpleDuck *)CTask::operator new(0x28u);
        CTaskSimpleDuck::CTaskSimpleDuck(v12, 4u, 0, -1);
        CTaskManager::SetTaskSecondary(&v11->m_taskManager, v12, 1);
      }
    }
  }
  return 1;
}

//----- (004EAC36) --------------------------------------------------------
CTask *__fastcall CTaskComplexBeStill::CreateNextSubTask(CTaskComplexBeStill *this, CPed *pPed)
{
  int v4; // r0
  bool v5; // zf

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  v5 = v4 == 709;
  if ( v4 != 709 )
    v5 = v4 == 203;
  if ( v5 )
    return (CTask *)(*((int (__fastcall **)(CTaskComplexBeStill *, CPed *))this->_vptr$CTask + 11))(this, pPed);
  else
    return 0;
}

//----- (004EAC64) --------------------------------------------------------
CTask *__fastcall CTaskComplexBeStill::CreateFirstSubTask(CTaskComplexBeStill *this, CPed *pPed)
{
  CTaskSimple *v3; // r0
  CTask *result; // r0
  CTaskSimpleCarDrive *v5; // r0

  if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
  {
    v5 = (CTaskSimpleCarDrive *)CTask::operator new(0x60u);
    CTaskSimpleCarDrive::CTaskSimpleCarDrive(v5, pPed->m_pMyVehicle, 0, 0);
  }
  else
  {
    v3 = (CTaskSimple *)CTask::operator new(0x20u);
    CTaskSimple::CTaskSimple(v3);
    *(int (***)(void))((char *)&result[2]._vptr$CTask + 2) = 0;
    *(CTask **)((char *)&result[1].m_pParent + 2) = 0;
    result[3].m_pParent = (CTask *)1090519040;
    LOWORD(result[3]._vptr$CTask) = 1;
    result[1]._vptr$CTask = 0;
    result[1].m_pParent = 0;
    result->_vptr$CTask = (int (**)(void))&off_669BFC;
  }
  return result;
}
// 4EAC84: variable 'result' is possibly undefined
// 669BFC: using guessed type void *off_669BFC;

//----- (004EACB8) --------------------------------------------------------
CTask *__fastcall CTaskComplexBeStill::ControlSubTask(CTaskComplexBeStill *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (004EACBC) --------------------------------------------------------
void __fastcall CTaskSimpleDie::CTaskSimpleDie(
        CTaskSimpleDie *this,
        const AssocGroupId animGroup,
        const AnimationId animID,
        const float fBlendDelta,
        const float fAnimSpeed)
{
  int v8; // r0
  char v9; // r3

  CTaskSimple::CTaskSimple(this);
  v9 = *(_BYTE *)(v8 + 32);
  *(_DWORD *)(v8 + 8) = animGroup;
  *(_DWORD *)(v8 + 12) = animID;
  *(_DWORD *)(v8 + 16) = 0;
  *(_DWORD *)(v8 + 20) = 0;
  *(const float *)(v8 + 24) = fBlendDelta;
  *(const float *)(v8 + 28) = fAnimSpeed;
  *(_DWORD *)(v8 + 36) = 0;
  *(_BYTE *)(v8 + 32) = v9 & 0xFC;
  *(_DWORD *)v8 = &off_669CCC;
}
// 4EACD2: variable 'v8' is possibly undefined
// 669CCC: using guessed type void *off_669CCC;

//----- (004EAD04) --------------------------------------------------------
void __fastcall CTaskSimpleDie::CTaskSimpleDie(
        CTaskSimpleDie *this,
        const unsigned __int8 *pAnimName,
        const unsigned __int8 *pAnimGroupName,
        const int32 flags,
        const float fBlendDelta,
        const float fAnimSpeed)
{
  char v10; // r3
  CAnimBlock *AnimationBlock; // r0

  CTaskSimple::CTaskSimple(this);
  v10 = *((_BYTE *)this + 32);
  this->m_animGroup = ANIM_STD_PED;
  this->m_animID = ANIM_STD_KO_FRONT;
  this->m_pAnimHierarchy = 0;
  this->m_flags = flags;
  this->m_fBlendDelta = fBlendDelta;
  this->m_fAnimSpeed = fAnimSpeed;
  this->m_pAnim = 0;
  *((_BYTE *)this + 32) = v10 & 0xFC;
  this->_vptr$CTask = (int (**)(void))&off_669CCC;
  AnimationBlock = CAnimManager::GetAnimationBlock(pAnimGroupName);
  this->m_pAnimHierarchy = CAnimManager::GetAnimation(pAnimName, AnimationBlock);
}
// 669CCC: using guessed type void *;

//----- (004EAD68) --------------------------------------------------------
void __fastcall CTaskSimpleDie::CTaskSimpleDie(
        CTaskSimpleDie *this,
        CAnimBlendHierarchy *pAnimHierarchy,
        const int32 flags,
        const float fBlendDelta,
        const float fAnimSpeed)
{
  int v8; // r0
  char v9; // r1

  CTaskSimple::CTaskSimple(this);
  v9 = *(_BYTE *)(v8 + 32);
  *(_DWORD *)(v8 + 8) = 0;
  *(_DWORD *)(v8 + 12) = 15;
  *(_DWORD *)(v8 + 16) = pAnimHierarchy;
  *(_DWORD *)(v8 + 20) = flags;
  *(const float *)(v8 + 24) = fBlendDelta;
  *(const float *)(v8 + 28) = fAnimSpeed;
  *(_DWORD *)(v8 + 36) = 0;
  *(_BYTE *)(v8 + 32) = v9 & 0xFC;
  *(_DWORD *)v8 = &off_669CCC;
}
// 4EAD88: variable 'v8' is possibly undefined
// 669CCC: using guessed type void *off_669CCC;

//----- (004EADBC) --------------------------------------------------------
void __fastcall CTaskSimpleDieInCar::~CTaskSimpleDieInCar(CTaskSimpleDie *this)
{
  CAnimBlendAssociation *m_pAnim; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_669CCC;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  sub_1A01F4(this);
}
// 669CCC: using guessed type void *off_669CCC;

//----- (004EADF0) --------------------------------------------------------
void __fastcall CTaskSimpleDie::~CTaskSimpleDie(CTaskSimpleDie *this)
{
  CAnimBlendAssociation *m_pAnim; // r0
  void *v3; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_669CCC;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v3);
}
// 4EAE1A: variable 'v3' is possibly undefined
// 669CCC: using guessed type void *off_669CCC;

//----- (004EAE28) --------------------------------------------------------
bool __fastcall CTaskSimpleDie::MakeAbortable(
        CTaskSimpleDie *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0
  bool v6; // r5
  int m_nPedFlags; // r0
  int v8; // r2
  int v9; // r3
  int v10; // r1

  if ( iPriority == 2 )
  {
    m_pAnim = this->m_pAnim;
    v6 = 1;
    if ( m_pAnim )
      m_pAnim->m_fBlendDelta = -1000.0;
    CPed::SetPedState(pPed, PED_IDLE);
    CPed::SetMoveState(pPed, PEDMOVE_STILL);
    (*((void (__fastcall **)(CPed *))pPed->_vptr$CPlaceable + 24))(pPed);
    m_nPedFlags = (int)pPed->m_nPedFlags;
  }
  else
  {
    if ( !pEvent || (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 10 )
      return 0;
    m_nPedFlags = (int)pPed->m_nPedFlags;
    v6 = 1;
  }
  v8 = *((_DWORD *)&pPed->m_nPedFlags + 2);
  v9 = *((_DWORD *)&pPed->m_nPedFlags + 3);
  v10 = *((_DWORD *)&pPed->m_nPedFlags + 1);
  *(_DWORD *)&pPed->m_nPedFlags = m_nPedFlags;
  *((_DWORD *)&pPed->m_nPedFlags + 1) = v10;
  *((_DWORD *)&pPed->m_nPedFlags + 2) = v8;
  *((_DWORD *)&pPed->m_nPedFlags + 3) = v9 & 0xFFFFFFDF;
  return v6;
}

//----- (004EAEB2) --------------------------------------------------------
bool __fastcall CTaskSimpleDie::ProcessPed(CTaskSimpleDie *this, CPed *pPed)
{
  int m_nPedFlags; // r0
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r1
  CEventDeath v7[2]; // [sp+0h] [bp-20h] BYREF

  pPed->m_ik.m_flags |= 8u;
  if ( *((unsigned __int8 *)this + 32) << 31 || this->m_animID == ANIM_STD_NUM )
  {
    m_nPedFlags = (int)pPed->m_nPedFlags;
    *((_DWORD *)&pPed->m_nPedFlags + 3) |= 0x20u;
    if ( (*((_BYTE *)this + 32) & 2) == 0 )
    {
      m_nPhysicalFlags = pPed->m_nPhysicalFlags;
      if ( (*(_WORD *)&m_nPhysicalFlags & 0x100) != 0
        || (*(_WORD *)&m_nPhysicalFlags & 0x2000) != 0
        || (*(_DWORD *)&pPed->m_nFlags & 1) == 0
        || m_nPedFlags << 31
        && (!pPed->m_pGroundPhysical
         || CPed::IsPlayer(pPed)
         || (*(_BYTE *)&pPed->m_pGroundPhysical->m_nPhysicalFlags & 4) != 0) )
      {
        CEventDeath::CEventDeath(v7, this->m_animID == ANIM_STD_DROWN);
        CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, (CEvent *)v7, 0);
        *((_BYTE *)this + 32) |= 2u;
        *((_DWORD *)&pPed->m_nPedFlags + 3) &= ~0x20u;
        CEvent::~CEvent((CEvent *)v7);
      }
    }
  }
  else if ( !this->m_pAnim )
  {
    CTaskSimpleDie::StartAnim(this, pPed);
    CPed::SetPedState(pPed, PED_DIE);
  }
  return 0;
}

//----- (004EAF84) --------------------------------------------------------
void __fastcall CTaskSimpleDie::StartAnim(CTaskSimpleDie *this, CPed *pPed)
{
  CAnimBlendHierarchy *m_pAnimHierarchy; // r1
  RpClump_0 *m_pRwObject; // r0
  CAnimBlendAssociation *v6; // r0
  float m_fAnimSpeed; // s0

  m_pAnimHierarchy = this->m_pAnimHierarchy;
  m_pRwObject = (RpClump_0 *)pPed->m_pRwObject;
  if ( m_pAnimHierarchy )
    v6 = CAnimManager::BlendAnimation(m_pRwObject, m_pAnimHierarchy, this->m_flags, this->m_fBlendDelta);
  else
    v6 = CAnimManager::BlendAnimation(m_pRwObject, this->m_animGroup, this->m_animID, this->m_fBlendDelta);
  this->m_pAnim = v6;
  CAnimBlendAssociation::SetFinishCallback(v6, CTaskSimpleDie::FinishAnimDieCB, this);
  this->m_pAnim->m_bitsFlag &= ~8u;
  m_fAnimSpeed = this->m_fAnimSpeed;
  if ( m_fAnimSpeed > 0.0 )
    this->m_pAnim->m_fSpeed = m_fAnimSpeed;
  CPed::ClearAll(pPed);
  pPed->m_nHealth = 0.0;
  CPed::StopNonPartialAnims(pPed);
  pPed->m_nTimeOfDeath = CTimer::m_snTimeInMilliseconds;
}

//----- (004EAFFC) --------------------------------------------------------
void __fastcall CTaskSimpleDie::FinishAnimDieCB(CAnimBlendAssociation *pAnim, void *pData)
{
  char v2; // r0

  v2 = *((_BYTE *)pData + 32);
  *((_DWORD *)pData + 9) = 0;
  *((_BYTE *)pData + 32) = v2 | 1;
}

//----- (004EB010) --------------------------------------------------------
void __fastcall CTaskSimpleDieInCar::CTaskSimpleDieInCar(
        CTaskSimpleDieInCar *this,
        const AssocGroupId group,
        const AnimationId anim)
{
  int v5; // r0
  char v6; // r3

  CTaskSimple::CTaskSimple(this);
  v6 = *(_BYTE *)(v5 + 32);
  *(_DWORD *)(v5 + 8) = group;
  *(_DWORD *)(v5 + 12) = anim;
  *(_DWORD *)(v5 + 16) = 0;
  *(_DWORD *)(v5 + 20) = 0;
  *(_DWORD *)(v5 + 24) = 1082130432;
  *(_DWORD *)(v5 + 28) = 0;
  *(_DWORD *)(v5 + 36) = 0;
  *(_BYTE *)(v5 + 32) = v6 & 0xFC;
  *(_DWORD *)v5 = &off_669D00;
}
// 4EB026: variable 'v5' is possibly undefined
// 669D00: using guessed type void *off_669D00;

//----- (004EB050) --------------------------------------------------------
void __fastcall CTaskSimpleDieInCar::~CTaskSimpleDieInCar(CTaskSimpleDieInCar *this)
{
  CAnimBlendAssociation *m_pAnim; // r0
  void *v3; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_669CCC;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v3);
}
// 4EB07A: variable 'v3' is possibly undefined
// 669CCC: using guessed type void *off_669CCC;

//----- (004EB088) --------------------------------------------------------
bool __fastcall CTaskSimpleDieInCar::ProcessPed(CTaskSimpleDieInCar *this, CPed *pPed)
{
  CTaskSimpleDie::ProcessPed(this, pPed);
  return 0;
}

//----- (004EB094) --------------------------------------------------------
void __fastcall CTaskComplexDieInCar::CTaskComplexDieInCar(CTaskComplexDieInCar *this, const eWeaponType eMeansOfDeath)
{
  int v3; // r0

  CTaskComplex::CTaskComplex(this);
  *(_DWORD *)(v3 + 12) = eMeansOfDeath;
  *(_WORD *)(v3 + 24) = 0;
  *(_DWORD *)(v3 + 16) = 0;
  *(_DWORD *)(v3 + 20) = 0;
  *(_DWORD *)v3 = &off_669D34;
}
// 4EB0A2: variable 'v3' is possibly undefined
// 669D34: using guessed type void *off_669D34;

//----- (004EB0BC) --------------------------------------------------------
void __fastcall CTaskComplexDieInCar::~CTaskComplexDieInCar(CTaskComplexDieInCar *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 4EB0C8: variable 'v1' is possibly undefined

//----- (004EB0CC) --------------------------------------------------------
void __fastcall CTaskComplexDieInCar::PreparePedVehicleForPedDeath(
        const CTaskComplexDieInCar *this,
        CVehicle *pVehicle)
{
  if ( (*(_BYTE *)&pVehicle->m_info & 0xF8) == 16 )
    CCarCtrl::SwitchVehicleToRealPhysics(pVehicle);
  pVehicle->AutoPilot.CruiseSpeed = 0;
  *(_WORD *)&pVehicle->AutoPilot.Mission = 1536;
  pVehicle->AutoPilot.TempActionFinish = CTimer::m_snTimeInMilliseconds + 2000;
}

//----- (004EB108) --------------------------------------------------------
CTask *__fastcall CTaskComplexDieInCar::CreateFirstSubTask(CTaskComplexDieInCar *this, CPed *pPed)
{
  CEvent *CurrentEvent; // r0
  CEvent *v5; // r11
  CVehicle *m_pMyVehicle; // r0
  CPed *pDriver; // r4
  bool v8; // zf
  int v9; // r5
  int v10; // r4
  CPed *v11; // r6
  bool v12; // zf
  int v13; // r5
  __int64 v14; // r0
  CVehicle *v16; // r6

  CPed::SetPedState(pPed, PED_DIE);
  CurrentEvent = CEventHandlerHistory::GetCurrentEvent(&pPed->m_pPedIntelligence->m_eventHandler.m_history);
  v5 = CurrentEvent;
  if ( CurrentEvent && (*((int (__fastcall **)(CEvent *))CurrentEvent->_vptr$CEvent + 2))(CurrentEvent) == 9 )
  {
    m_pMyVehicle = pPed->m_pMyVehicle;
    pDriver = m_pMyVehicle->pDriver;
    v8 = pDriver == 0;
    if ( pDriver )
      v8 = pDriver == pPed;
    if ( !v8 )
    {
      v9 = (*((int (__fastcall **)(CEvent *))v5->_vptr$CEvent + 5))(v5);
      *(_BYTE *)(v9 + 9) = 0;
      CEventGroup::Add(&pDriver->m_pPedIntelligence->m_eventGroup, (CEvent *)v9, 0);
      (*(void (__fastcall **)(int))(*(_DWORD *)v9 + 4))(v9);
      m_pMyVehicle = pPed->m_pMyVehicle;
    }
    if ( m_pMyVehicle->m_nMaxPassengers )
    {
      v10 = 0;
      do
      {
        v11 = m_pMyVehicle->pPassengers[v10];
        v12 = v11 == 0;
        if ( v11 )
          v12 = v11 == pPed;
        if ( !v12 )
        {
          v13 = (*((int (__fastcall **)(CEvent *))v5->_vptr$CEvent + 5))(v5);
          *(_BYTE *)(v13 + 9) = 0;
          CEventGroup::Add(&v11->m_pPedIntelligence->m_eventGroup, (CEvent *)v13, 0);
          (*(void (__fastcall **)(int))(*(_DWORD *)v13 + 4))(v13);
          m_pMyVehicle = pPed->m_pMyVehicle;
        }
        ++v10;
      }
      while ( v10 < m_pMyVehicle->m_nMaxPassengers );
    }
  }
  LODWORD(v14) = *((unsigned __int8 *)&pPed->m_nPedFlags + 12);
  if ( (unsigned int)v14 >> 7 )
    goto LABEL_17;
  LODWORD(v14) = this->m_eMeansOfDeath;
  if ( (_DWORD)v14 == 51 )
    goto LABEL_17;
  LODWORD(v14) = pPed->m_pMyVehicle;
  if ( (unsigned int)(*(_DWORD *)(v14 + 1444) - 3) < 2 )
    goto LABEL_17;
  LODWORD(v14) = (*(int (__fastcall **)(_DWORD, _DWORD))(*(_DWORD *)v14 + 232))(v14, 0);
  if ( (_DWORD)v14 )
  {
    HIDWORD(v14) = 705;
    return CTaskComplexDieInCar::CreateSubTask((const CTaskComplexDieInCar *)v14, SHIDWORD(v14), pPed);
  }
  LODWORD(v14) = CVehicle::GetVehicleAppearance(pPed->m_pMyVehicle);
  if ( (_DWORD)v14 != 1 || (v16 = pPed->m_pMyVehicle, LODWORD(v14) = v16->pDriver, (CPed *)v14 != pPed) )
  {
LABEL_17:
    HIDWORD(v14) = 214;
  }
  else
  {
    if ( (*(_BYTE *)&v16->m_info & 0xF8) == 16 )
      CCarCtrl::SwitchVehicleToRealPhysics(pPed->m_pMyVehicle);
    v16->AutoPilot.CruiseSpeed = 0;
    *(_WORD *)&v16->AutoPilot.Mission = 1536;
    v14 = CTimer::m_snTimeInMilliseconds | 0x7D000000000LL;
    v16->AutoPilot.TempActionFinish = CTimer::m_snTimeInMilliseconds + 2000;
    this->m_pauseTimer.m_bIsActive = 1;
    *(_QWORD *)&this->m_pauseTimer.m_iStartTime = v14;
    HIDWORD(v14) = 709;
  }
  return CTaskComplexDieInCar::CreateSubTask((const CTaskComplexDieInCar *)v14, SHIDWORD(v14), pPed);
}

//----- (004EB26C) --------------------------------------------------------
CTask *__fastcall CTaskComplexDieInCar::CreateSubTask(
        const CTaskComplexDieInCar *this,
        const int iSubTaskType,
        CPed *pPed)
{
  CTaskComplexLeaveCar *v4; // r4
  _BOOL4 IsDriver; // r5
  CTaskSimple *v6; // r0
  int v7; // r0
  int v8; // r3
  char v9; // r5

  v4 = 0;
  switch ( iSubTaskType )
  {
    case 214:
      IsDriver = CVehicle::IsDriver(pPed->m_pMyVehicle, pPed);
      v6 = (CTaskSimple *)CTask::operator new(0x28u);
      CTaskSimple::CTaskSimple(v6);
      *(_DWORD *)(v7 + 8) = 0;
      if ( IsDriver )
        v8 = 187;
      else
        v8 = 188;
      v9 = *(_BYTE *)(v7 + 32);
      *(_DWORD *)(v7 + 12) = v8;
      *(_DWORD *)(v7 + 16) = 0;
      *(_DWORD *)(v7 + 20) = 0;
      *(_DWORD *)(v7 + 24) = 1082130432;
      v4 = (CTaskComplexLeaveCar *)v7;
      *(_DWORD *)(v7 + 28) = 0;
      *(_DWORD *)(v7 + 36) = 0;
      *(_BYTE *)(v7 + 32) = v9 & 0xFC;
      *(_DWORD *)v7 = &off_669D00;
      break;
    case 705:
      v4 = (CTaskComplexLeaveCar *)CTask::operator new(0x34u);
      CTaskComplexLeaveCar::CTaskComplexLeaveCar(v4, pPed->m_pMyVehicle, 0, 0, 0, 1);
      v4->m_bDie = 1;
      v4->_vptr$CTask = (int (**)(void))&off_66AF44;
      break;
    case 709:
      v4 = (CTaskComplexLeaveCar *)CTask::operator new(0x60u);
      CTaskSimpleCarDrive::CTaskSimpleCarDrive((CTaskSimpleCarDrive *)v4, pPed->m_pMyVehicle, 0, 0);
      break;
  }
  return v4;
}
// 4EB2E4: variable 'v7' is possibly undefined
// 669D00: using guessed type void *;
// 66AF44: using guessed type void *;

//----- (004EB330) --------------------------------------------------------
CTask *__fastcall CTaskComplexDieInCar::ControlSubTask(CTaskComplexDieInCar *this, CPed *pPed)
{
  CTaskComplexLeaveCar *m_pSubTask; // r4
  unsigned int v5; // r0
  int m_iStartTime; // r1
  char *v7; // r0
  _BOOL4 IsDriver; // r5
  int v9; // r2
  uint8 m_nDoorFlagsSet; // r3

  m_pSubTask = (CTaskComplexLeaveCar *)this->m_pSubTask;
  if ( (*((int (__fastcall **)(CTaskComplexLeaveCar *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) == 709
    && this->m_pauseTimer.m_bIsActive )
  {
    if ( this->m_pauseTimer.m_bIsStopped )
    {
      v5 = CTimer::m_snTimeInMilliseconds;
      this->m_pauseTimer.m_bIsStopped = 0;
      this->m_pauseTimer.m_iStartTime = v5;
      m_iStartTime = v5;
    }
    else
    {
      m_iStartTime = this->m_pauseTimer.m_iStartTime;
      v5 = CTimer::m_snTimeInMilliseconds;
    }
    if ( m_iStartTime + this->m_pauseTimer.m_iDuration <= v5 )
    {
      if ( pPed->CharCreatedBy == 2
        || (*((int (__fastcall **)(CVehicle *, _DWORD))pPed->m_pMyVehicle->_vptr$CPlaceable + 58))(
             pPed->m_pMyVehicle,
             0) == 1 )
      {
        m_pSubTask = (CTaskComplexLeaveCar *)CTask::operator new(0x34u);
        CTaskComplexLeaveCar::CTaskComplexLeaveCar(m_pSubTask, pPed->m_pMyVehicle, 0, 0, 0, 1);
        m_pSubTask->m_bDie = 1;
        v7 = (char *)&`vtable for'CTaskComplexLeaveCarAndDie;
      }
      else
      {
        IsDriver = CVehicle::IsDriver(pPed->m_pMyVehicle, pPed);
        m_pSubTask = (CTaskComplexLeaveCar *)CTask::operator new(0x28u);
        CTaskSimple::CTaskSimple((CTaskSimple *)m_pSubTask);
        m_pSubTask->m_pSubTask = 0;
        if ( IsDriver )
          v9 = 187;
        else
          v9 = 188;
        v7 = (char *)&`vtable for'CTaskSimpleDieInCar;
        m_nDoorFlagsSet = m_pSubTask->m_nDoorFlagsSet;
        m_pSubTask->m_pTargetVehicle = (CVehicle *)v9;
        m_pSubTask->m_iTargetDoor = 0;
        m_pSubTask->m_iDelayTime = 0;
        *(_DWORD *)&m_pSubTask->m_bSensibleLeaveCar = 1082130432;
        m_pSubTask->m_pTaskUtilityLineUpPedWithCar = 0;
        m_pSubTask->m_dieAnim = ANIM_STD_WALK;
        m_pSubTask->m_nDoorFlagsSet = m_nDoorFlagsSet & 0xFC;
      }
      m_pSubTask->_vptr$CTask = (int (**)(void))(v7 + 8);
    }
  }
  return m_pSubTask;
}

//----- (004EB434) --------------------------------------------------------
CTask *__fastcall CTaskComplexDieInCar::CreateNextSubTask(CTaskComplexDieInCar *this, CPed *pPed)
{
  CVehicle *m_pMyVehicle; // r0
  int v5; // r1

  m_pMyVehicle = (CVehicle *)(*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( m_pMyVehicle == (CVehicle *)((char *)&dword_D4 + 2) )
    goto LABEL_8;
  if ( m_pMyVehicle != (CVehicle *)((char *)&elf_hash_bucket[113] + 1) )
    return 0;
  m_pMyVehicle = pPed->m_pMyVehicle;
  if ( !m_pMyVehicle )
  {
LABEL_8:
    v5 = 1302;
  }
  else
  {
    v5 = 214;
    m_pMyVehicle = (CVehicle *)(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31);
    if ( !m_pMyVehicle )
      v5 = 1302;
  }
  return CTaskComplexDieInCar::CreateSubTask((const CTaskComplexDieInCar *)m_pMyVehicle, v5, pPed);
}
// D4: using guessed type int;
// FC: using guessed type int elf_hash_bucket[16411];

//----- (004EB474) --------------------------------------------------------
void __fastcall CTaskSimpleDrown::CTaskSimpleDrown(CTaskSimpleDrown *this)
{
  int v1; // r0
  char v2; // r1

  CTaskSimple::CTaskSimple(this);
  *(_DWORD *)(v1 + 8) = 0;
  *(_DWORD *)(v1 + 12) = 140;
  *(_DWORD *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 20) = 0;
  *(_DWORD *)(v1 + 24) = 1082130432;
  *(_DWORD *)(v1 + 28) = 0;
  *(_DWORD *)(v1 + 36) = 0;
  v2 = *(_BYTE *)(v1 + 32);
  *(_BYTE *)(v1 + 40) = 1;
  *(_BYTE *)(v1 + 32) = v2 & 0xFC;
  *(_DWORD *)v1 = &off_669D70;
}
// 4EB488: variable 'v1' is possibly undefined
// 669D70: using guessed type void *off_669D70;

//----- (004EB4BC) --------------------------------------------------------
void __fastcall CTaskSimpleDrown::~CTaskSimpleDrown(CTaskSimpleDrown *this)
{
  CAnimBlendAssociation *m_pAnim; // r0
  void *v3; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_669CCC;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v3);
}
// 4EB4E6: variable 'v3' is possibly undefined
// 669CCC: using guessed type void *off_669CCC;

//----- (004EB4F4) --------------------------------------------------------
bool __fastcall CTaskSimpleDrown::ProcessPed(CTaskSimpleDrown *this, CPed *pPed)
{
  if ( this->m_bFirstTime )
  {
    CPed::SetPedState(pPed, PED_DIE);
    *(_DWORD *)&pPed->m_nPedFlags &= ~0x200u;
    if ( FindPlayerPed(-1) == pPed )
      CStats::IncrementStat(0xAAu, 1.0);
    this->m_bFirstTime = 0;
  }
  CTaskSimpleDie::ProcessPed(this, pPed);
  return 0;
}

//----- (004EB540) --------------------------------------------------------
void __fastcall CTaskSimpleDrownInCar::CTaskSimpleDrownInCar(CTaskSimpleDrownInCar *this)
{
  _DWORD *v1; // r0

  CTaskSimple::CTaskSimple(this);
  *v1 = &off_669DA4;
}
// 4EB550: variable 'v1' is possibly undefined
// 669DA4: using guessed type void *off_669DA4;

//----- (004EB55C) --------------------------------------------------------
void __fastcall CTaskSimpleDrownInCar::~CTaskSimpleDrownInCar(CTaskSimpleDrownInCar *this)
{
  void *v1; // r0

  CTask::~CTask(this);
  sub_197118(v1);
}
// 4EB568: variable 'v1' is possibly undefined

//----- (004EB56C) --------------------------------------------------------
bool __fastcall CTaskSimpleDrownInCar::ProcessPed(CTaskSimpleDrownInCar *this, CPed *pPed)
{
  CEventDeath v4; // [sp+0h] [bp-18h] BYREF

  CPed::SetPedState(pPed, PED_DIE);
  *(_DWORD *)&pPed->m_nPedFlags &= ~0x200u;
  if ( FindPlayerPed(-1) == pPed )
    CStats::IncrementStat(0xAAu, 1.0);
  if ( FindPlayerPed(-1) == pPed )
    pPed->m_pMyVehicle->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&pPed->m_pMyVehicle->m_info & 7 | 0x48);
  CEventDeath::CEventDeath(&v4, 1);
  CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, (CEvent *)&v4, 0);
  CEvent::~CEvent((CEvent *)&v4);
  return 1;
}

//----- (004EB5E0) --------------------------------------------------------
void __fastcall CTaskComplexDie::CTaskComplexDie(
        CTaskComplexDie *this,
        const eWeaponType eMeansOfDeath,
        const AssocGroupId animGroup,
        const AnimationId animID,
        const float fBlendDelta,
        const float fAnimSpeed,
        const bool bBeingKilledByStealth,
        const bool bFallingToDeath,
        const int iFallToDeathDir,
        const bool bFallToDeathOverRailing)
{
  int v13; // r0

  CTaskComplex::CTaskComplex(this);
  *(_DWORD *)(v13 + 12) = eMeansOfDeath;
  *(_DWORD *)(v13 + 16) = animGroup;
  *(_DWORD *)(v13 + 20) = animID;
  *(const float *)(v13 + 24) = fBlendDelta;
  *(const float *)(v13 + 28) = fAnimSpeed;
  *(_DWORD *)(v13 + 36) = iFallToDeathDir;
  *(_BYTE *)(v13 + 32) = *(_BYTE *)(v13 + 32) & 0xF8 | bBeingKilledByStealth | (2 * bFallingToDeath) | (4 * bFallToDeathOverRailing);
  *(_DWORD *)v13 = &off_669DD8;
}
// 4EB60A: variable 'v13' is possibly undefined
// 669DD8: using guessed type void *;

//----- (004EB648) --------------------------------------------------------
void __fastcall CTaskComplexDie::~CTaskComplexDie(CTaskComplexDie *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 4EB654: variable 'v1' is possibly undefined

//----- (004EB658) --------------------------------------------------------
bool __fastcall CTaskComplexDie::MakeAbortable(
        CTaskComplexDie *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  if ( (unsigned int)(iPriority - 1) <= 1 )
    return (*((int (__fastcall **)(CTask *, CPed *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
             this->m_pSubTask,
             pPed);
  else
    return 0;
}

//----- (004EB674) --------------------------------------------------------
void __fastcall CTaskComplexDie::SayDeathSample(const CTaskComplexDie *this, CPed *pPed)
{
  UInt16 v3; // r1

  switch ( this->m_eMeansOfDeath )
  {
    case WEAPONTYPE_RAMMEDBYCAR:
    case WEAPONTYPE_RUNOVERBYCAR:
      v3 = 342;
      goto LABEL_5;
    case WEAPONTYPE_EXPLOSION:
      return;
    case WEAPONTYPE_DROWNING:
      v3 = 341;
      goto LABEL_5;
    case WEAPONTYPE_FALL:
      CPed::Say(pPed, 0x156u, 0, 1.0, 0, 0, 0);
      if ( CLocalisation::Blood() )
        CAEPedAudioEntity::AddAudioEvent(&pPed->m_PedAudioEntity, 119, 0.0, 1.0, pPed, 0, 0, 0);
      return;
    default:
      v3 = 343;
LABEL_5:
      CPed::Say(pPed, v3, 0, 1.0, 0, 0, 0);
      return;
  }
}

//----- (004EB6F8) --------------------------------------------------------
CTask *__fastcall CTaskComplexDie::CreateNextSubTask(CTaskComplexDie *this, CPed *pPed)
{
  int v4; // r0
  CTask *result; // r0
  CTaskSimple *v6; // r0

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( (unsigned int)(v4 - 212) > 4 || v4 == 214 )
  {
    if ( v4 == 704 )
    {
      if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
      {
        v6 = (CTaskSimple *)CTask::operator new(8u);
        CTaskSimple::CTaskSimple(v6);
        result->_vptr$CTask = (int (**)(void))&off_669DA4;
      }
      else
      {
        return (CTask *)(*((int (__fastcall **)(CTaskComplexDie *, CPed *))this->_vptr$CTask + 11))(this, pPed);
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *((_DWORD *)&pPed->m_nPedFlags + 2) |= 0x100u;
    return 0;
  }
  return result;
}
// 4EB758: variable 'result' is possibly undefined
// 669DA4: using guessed type void *;

//----- (004EB760) --------------------------------------------------------
CTask *__fastcall CTaskComplexDie::CreateFirstSubTask(CTaskComplexDie *this, CPed *pPed)
{
  CVehicle *m_pMyVehicle; // r0
  CTaskSimple *v5; // r0
  CTask *result; // r0
  char v7; // r2
  char *v8; // r1
  CTaskComplex *v9; // r0
  CTask *m_eMeansOfDeath; // r4
  CTaskSimple *v11; // r0
  int (**m_animGroup)(void); // r5
  CTask *m_animID; // r6
  float m_fBlendDelta; // r8
  float m_fAnimSpeed; // r4
  char v16; // r2
  CTaskComplexLeaveCar *v17; // r0
  CMatrix *m_pMat; // r0
  __int64 v19; // d16
  RwReal zy; // r0
  float xx; // s0
  float yx; // s2
  float zx; // s4
  CTaskComplexFallToDeath *v24; // r0
  CVector vNudgeVec; // [sp+8h] [bp-20h] BYREF

  CTaskComplexDie::SayDeathSample(this, pPed);
  if ( this->m_eMeansOfDeath != WEAPONTYPE_DROWNING
    || ~*(_DWORD *)&pPed->m_nPedFlags & 0x100 | *((_DWORD *)&pPed->m_nPedFlags + 3) & 0x80
    || (m_pMyVehicle = pPed->m_pMyVehicle) != 0 && (unsigned int)(m_pMyVehicle->m_vehicleType - 3) < 2 )
  {
    CPed::SetPedState(pPed, PED_DIE);
    CPedIntelligence::ClearTasks(pPed->m_pPedIntelligence, 0, 1);
    if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
    {
      v9 = (CTaskComplex *)CTask::operator new(0x1Cu);
      m_eMeansOfDeath = (CTask *)this->m_eMeansOfDeath;
      CTaskComplex::CTaskComplex(v9);
      result[1].m_pParent = m_eMeansOfDeath;
      LOWORD(result[3]._vptr$CTask) = 0;
      result[2]._vptr$CTask = 0;
      result[2].m_pParent = 0;
      v8 = (char *)&`vtable for'CTaskComplexDieInCar;
      goto LABEL_9;
    }
    if ( this->m_eMeansOfDeath == WEAPONTYPE_DROWNING )
    {
      v5 = (CTaskSimple *)CTask::operator new(0x2Cu);
      CTaskSimple::CTaskSimple(v5);
      result[1]._vptr$CTask = 0;
      result[1].m_pParent = (CTask *)&dword_8C;
      result[2]._vptr$CTask = 0;
      result[2].m_pParent = 0;
      result[3]._vptr$CTask = (int (**)(void))1082130432;
      result[3].m_pParent = 0;
      result[4].m_pParent = 0;
      v7 = (char)result[4]._vptr$CTask;
      LOBYTE(result[5]._vptr$CTask) = 1;
      v8 = (char *)&`vtable for'CTaskSimpleDrown;
      LOBYTE(result[4]._vptr$CTask) = v7 & 0xFC;
LABEL_9:
      result->_vptr$CTask = (int (**)(void))(v8 + 8);
      return result;
    }
    if ( (*((_BYTE *)this + 32) & 2) != 0 )
    {
      m_pMat = pPed->m_pMat;
      switch ( this->m_iFallToDeathDir )
      {
        case 0:
          v19 = *(_QWORD *)&m_pMat->xy;
          zy = m_pMat->zy;
          goto LABEL_19;
        case 1:
          xx = m_pMat->xx;
          yx = m_pMat->yx;
          zx = m_pMat->zx;
          goto LABEL_17;
        case 2:
          xx = m_pMat->xy;
          yx = m_pMat->yy;
          zx = m_pMat->zy;
LABEL_17:
          vNudgeVec.y = -yx;
          vNudgeVec.x = -xx;
          vNudgeVec.z = -zx;
          break;
        case 3:
          v19 = *(_QWORD *)&m_pMat->xx;
          zy = m_pMat->zx;
LABEL_19:
          vNudgeVec.z = zy;
          *(_QWORD *)&vNudgeVec.x = v19;
          break;
        default:
          break;
      }
      v24 = (CTaskComplexFallToDeath *)CTask::operator new(0x24u);
      CTaskComplexFallToDeath::CTaskComplexFallToDeath(
        v24,
        this->m_iFallToDeathDir,
        &vNudgeVec,
        (*((_BYTE *)this + 32) & 4) != 0,
        0);
    }
    else
    {
      v11 = (CTaskSimple *)CTask::operator new(0x28u);
      m_animGroup = (int (**)(void))this->m_animGroup;
      m_animID = (CTask *)this->m_animID;
      m_fBlendDelta = this->m_fBlendDelta;
      m_fAnimSpeed = this->m_fAnimSpeed;
      CTaskSimple::CTaskSimple(v11);
      result[1]._vptr$CTask = m_animGroup;
      result[1].m_pParent = m_animID;
      result[2]._vptr$CTask = 0;
      result[2].m_pParent = 0;
      *(float *)&result[3]._vptr$CTask = m_fBlendDelta;
      *(float *)&result[3].m_pParent = m_fAnimSpeed;
      result[4].m_pParent = 0;
      v16 = (char)result[4]._vptr$CTask;
      result->_vptr$CTask = (int (**)(void))&off_669CCC;
      LOBYTE(result[4]._vptr$CTask) = v16 & 0xFC;
    }
  }
  else
  {
    v17 = (CTaskComplexLeaveCar *)CTask::operator new(0x34u);
    CTaskComplexLeaveCar::CTaskComplexLeaveCar(v17, pPed->m_pMyVehicle, 0, 0, 0, 1);
  }
  return result;
}
// 4EB7DA: variable 'result' is possibly undefined
// 8C: using guessed type int dword_8C;
// 669CCC: using guessed type void *off_669CCC;

//----- (004EB908) --------------------------------------------------------
CTask *__fastcall CTaskComplexDie::ControlSubTask(CTaskComplexDie *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (004EB90C) --------------------------------------------------------
void __fastcall CTaskSimpleDead::CTaskSimpleDead(CTaskSimpleDead *this, const int iTimeOfDeath, const bool bHasDrowned)
{
  int v5; // r0
  char v6; // r2

  CTaskSimple::CTaskSimple(this);
  v6 = *(_BYTE *)(v5 + 12);
  *(_DWORD *)(v5 + 8) = iTimeOfDeath;
  *(_DWORD *)v5 = &off_669E14;
  *(_BYTE *)(v5 + 12) = v6 & 0xF8 | (2 * bHasDrowned) | 1;
}
// 4EB91A: variable 'v5' is possibly undefined
// 669E14: using guessed type void *;

//----- (004EB940) --------------------------------------------------------
void __fastcall CTaskSimpleDead::~CTaskSimpleDead(CTaskSimpleDead *this)
{
  void *v1; // r0

  CTask::~CTask(this);
  sub_197118(v1);
}
// 4EB94C: variable 'v1' is possibly undefined

//----- (004EB950) --------------------------------------------------------
bool __fastcall CTaskSimpleDead::ProcessPed(CTaskSimpleDead *this, CPed *pPed)
{
  float32x2_t v2; // d1
  float32x2_t v3; // d8
  float32x2_t v4; // d9
  float32x2_t v5; // d10
  char v8; // r0
  _BOOL4 v9; // r5
  _BOOL4 v10; // r9
  AnimationId v11; // r2
  _BOOL4 v12; // r5
  int m_nCurrentWeapon; // r0
  CWeaponInfo *WeaponInfo; // r0
  CEventGlobalGroup *EventGlobalGroup; // r0
  CAccidentManager *AccidentManager; // r0
  CAnimBlendAssociation *v17; // r0
  CMatrix *m_pMat; // r1
  float y; // s0
  float x; // s10
  float z; // s12
  uint32 v22; // r12
  uint32 v23; // lr
  float v24; // s0
  float v25; // s0
  CSimpleTransform *p_m_transform; // r4
  int v27; // r3
  CEntity **m_entities; // r2
  CEntity *v29; // r0
  CMatrix *v30; // r1
  CSimpleTransform *p_tx; // r5
  CMatrix *v32; // r6
  _DWORD *p_x; // r1
  float32x2_t v34; // d16
  unsigned __int64 v35; // d2
  float m_heading; // r1
  char v37; // r0
  CSimpleTransform *v38; // r2
  CMatrix *v39; // r3
  unsigned int v40; // r6
  __int64 v41; // d16
  CMatrix *v42; // r0
  uint32 m_flags; // r0
  float pWaterZ; // [sp+34h] [bp-54h] BYREF
  CEventDeadPed v46; // [sp+38h] [bp-50h] BYREF

  v8 = *((_BYTE *)this + 12);
  if ( (v8 & 1) != 0 )
  {
    if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
    {
      if ( (CCarEnterExit::ComputeTargetDoorToExit(pPed->m_pMyVehicle, pPed) | 1) == 11 )
        v11 = ANIM_STD_DEAD_IN_CAR_LHS;
      else
        v11 = ANIM_STD_DEAD_IN_CAR_RHS;
      CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, v11, 4.0);
    }
    CPed::SetPedState(pPed, PED_DEAD);
    *((_BYTE *)this + 12) &= ~1u;
    v10 = (*(_DWORD *)&pPed->m_nPedFlags & 3) != 0;
    v12 = FindPlayerPed(0)->m_pEntLockOnTarget == pPed
       || FindPlayerPed(1) && FindPlayerPed(1)->m_pEntLockOnTarget == pPed;
    if ( (*((_BYTE *)this + 12) & 2) == 0 && !v12 && !pPed->m_pGroundPhysical )
      *(_DWORD *)&pPed->m_nFlags &= ~1u;
    m_nCurrentWeapon = pPed->m_nCurrentWeapon;
    pPed->m_nHealth = 0.0;
    WeaponInfo = CWeaponInfo::GetWeaponInfo(pPed->m_WeaponSlots[m_nCurrentWeapon].m_eWeaponType, 1);
    CPed::RemoveWeaponModel(pPed, WeaponInfo->m_modelId);
    pPed->m_nCurrentWeapon = 0;
    if ( !CPed::IsPlayer(pPed) )
    {
      CPed::RemoveWeaponAnims(pPed, 0, -1000.0);
      CPed::CreateDeadPedWeaponPickups(pPed);
      CPed::CreateDeadPedMoney(pPed);
    }
    CEventDeadPed::CEventDeadPed(&v46, pPed, (*((_BYTE *)this + 12) & 2) != 0, this->m_iTimeOfDeath);
    EventGlobalGroup = GetEventGlobalGroup();
    CEventGroup::Add(EventGlobalGroup, (CEvent *)&v46, 0);
    AccidentManager = GetAccidentManager();
    CAccidentManager::ReportAccident(AccidentManager, pPed);
    CEventDeadPed::~CEventDeadPed(&v46);
    v8 = *((_BYTE *)this + 12);
    v9 = v12;
  }
  else
  {
    v9 = 0;
    v10 = 0;
  }
  if ( (v8 & 3) != 2 || !(*(_BYTE *)&pPed->m_nPedFlags << 31) )
  {
    if ( (*(_DWORD *)&pPed->m_nFlags & 1) != 0
      && (v8 & 2) == 0
      && *(_BYTE *)&pPed->m_nPedFlags << 31
      && !pPed->m_pGroundPhysical
      && FindPlayerPed(0)->m_pEntLockOnTarget != pPed )
    {
      if ( FindPlayerPed(1) )
      {
        if ( !(v9 | (FindPlayerPed(1)->m_pEntLockOnTarget == pPed)) )
          goto LABEL_66;
      }
      else if ( !v9 )
      {
LABEL_66:
        *(_DWORD *)&pPed->m_nFlags &= ~1u;
        goto LABEL_29;
      }
    }
    if ( !v10 )
      goto LABEL_30;
    goto LABEL_29;
  }
  *(_DWORD *)&pPed->m_nFlags &= ~1u;
  *((_BYTE *)this + 12) &= ~2u;
  v17 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, ANIM_STD_HIT_FLOOR_FRONT, 8.0);
  v17->m_bitsFlag &= ~8u;
LABEL_29:
  m_pMat = pPed->m_pMat;
  v3.n64_u32[0] = -1.0;
  y = pPed->m_vecGroundNormal.y;
  v4.n64_u32[0] = 1.0;
  x = pPed->m_vecGroundNormal.x;
  z = pPed->m_vecGroundNormal.z;
  v2.n64_f32[0] = (float)((float)(x * m_pMat->xx) + (float)(y * m_pMat->yx)) + (float)(z * m_pMat->zx);
  v5.n64_f32[0] = (float)((float)(x * m_pMat->xy) + (float)(y * m_pMat->yy)) + (float)(z * m_pMat->zy);
  pPed->m_ik.m_fSlopeRoll = asinf(vmin_f32(vmax_f32(v2, v3), v4).n64_f32[0]);
  pPed->m_ik.m_fSlopePitch = asinf(vmin_f32(vmax_f32(v5, v3), v4).n64_f32[0]);
LABEL_30:
  CPed::DeadPedMakesTyresBloody(pPed);
  if ( CLocalisation::Blood() && (*((_BYTE *)this + 12) & 2) == 0 )
  {
    v22 = CTimer::m_snTimeInMilliseconds;
    v23 = CTimer::m_snTimeInMilliseconds - this->m_iTimeOfDeath;
    if ( v23 >= 0x7D0 )
    {
      if ( v23 <= 0x1B58 )
        v24 = (float)(v23 - 2000) * 0.00015;
      else
        v24 = 0.75;
    }
    else
    {
      v24 = 0.0;
    }
    v25 = v24 * v24;
    p_m_transform = &pPed->m_transform;
    v27 = 0;
    m_entities = pPed->m_pPedIntelligence->m_pedScanner.m_entities;
    do
    {
      v29 = m_entities[v27];
      if ( v29 )
      {
        v30 = pPed->m_pMat;
        p_tx = &pPed->m_transform;
        v32 = v29->m_pMat;
        if ( v30 )
          p_tx = (CSimpleTransform *)&v30->tx;
        p_x = (_DWORD *)&v32->tx;
        if ( !v32 )
          p_x = (_DWORD *)&v29->m_transform.m_translate.x;
        v34.n64_u64[0] = vsub_f32(*(float32x2_t *)(p_x + 1), *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
        v35 = vmul_f32(v34, v34).n64_u64[0];
        if ( (float)((float)((float)((float)(*(float *)p_x - p_tx->m_translate.x)
                                   * (float)(*(float *)p_x - p_tx->m_translate.x))
                           + *(float *)&v35)
                   + *((float *)&v35 + 1)) < v25 )
        {
          m_heading = v29[19].m_transform.m_heading;
          v29[31].m_pMat = (CMatrix *)&dword_C8;
          LODWORD(v29[19].m_transform.m_heading) = LODWORD(m_heading) | 0x10000000;
        }
      }
      ++v27;
    }
    while ( v27 != 16 );
    if ( v23 > 0x7D0 )
    {
      v37 = *((_BYTE *)this + 12);
      if ( (v37 & 4) == 0 )
      {
        v38 = &pPed->m_transform;
        v39 = pPed->m_pMat;
        v40 = v23 - 2000;
        if ( v39 )
          v38 = (CSimpleTransform *)&v39->tx;
        v41 = *(_QWORD *)&v38->m_translate.x;
        *(RwReal *)&v46.m_bIsPersistent = v38->m_translate.z;
        *(_QWORD *)&v46._vptr$CEvent = v41;
        if ( v40 <= v22 - CTimer::m_snPreviousTimeInMilliseconds )
        {
          if ( CWaterLevel::GetWaterLevelNoWaves(
                 v38->m_translate.x,
                 v38->m_translate.y,
                 v38->m_translate.z,
                 &pWaterZ,
                 0,
                 0) )
          {
            v42 = pPed->m_pMat;
            if ( v42 )
              p_m_transform = (CSimpleTransform *)&v42->tx;
            if ( p_m_transform->m_translate.z <= pWaterZ )
              *((_BYTE *)this + 12) |= 4u;
          }
          v37 = *((_BYTE *)this + 12);
        }
        if ( (v37 & 4) == 0 && CLocalisation::Blood() )
        {
          if ( v40 > 0x1387 )
          {
            CShadows::AddPermanentShadow(
              1u,
              gpBloodPoolTex,
              (CVector *)&v46,
              0.75,
              0.0,
              0.0,
              -0.75,
              255,
              0xC8u,
              0,
              0,
              4.0,
              0x9C40u,
              1.0);
            *((_BYTE *)this + 12) |= 4u;
          }
          else
          {
            CShadows::StoreStaticShadow(
              (u_native)&this[1]._vptr$CTask + 1,
              1u,
              gpBloodPoolTex,
              (CVector *)&v46,
              (float)v40 * 0.00015,
              0.0,
              0.0,
              (float)v40 * -0.00015,
              0xC8000000FFLL,
              0LL,
              4.0,
              1.0,
              40.0,
              0,
              0.0);
          }
        }
      }
    }
  }
  if ( (*((_BYTE *)this + 12) & 2) != 0 )
  {
    *(_DWORD *)&pPed->m_nPedFlags &= 0xFFFFFFFC;
  }
  else
  {
    m_flags = pPed->m_ik.m_flags;
    pPed->m_vecMoveSpeed.x = 0.0;
    pPed->m_vecMoveSpeed.y = 0.0;
    pPed->m_vecMoveSpeed.z = 0.0;
    pPed->m_ik.m_flags = m_flags | 8;
  }
  return 0;
}
// 4EBB5E: variable 'v2' is possibly undefined
// 4EBB5E: variable 'v3' is possibly undefined
// 4EBB62: variable 'v4' is possibly undefined
// 4EBB7A: variable 'v5' is possibly undefined
// C8: using guessed type int dword_C8;

//----- (004EBE50) --------------------------------------------------------
void __fastcall CTaskSimpleTired::CTaskSimpleTired(CTaskSimpleTired *this, const int iDuration)
{
  int v3; // r0

  CTaskSimple::CTaskSimple(this);
  *(_DWORD *)(v3 + 8) = iDuration;
  *(_WORD *)(v3 + 20) = 0;
  *(_DWORD *)(v3 + 24) = 0;
  *(_DWORD *)(v3 + 12) = 0;
  *(_DWORD *)(v3 + 16) = 0;
  *(_DWORD *)v3 = &off_669E48;
}
// 4EBE5E: variable 'v3' is possibly undefined
// 669E48: using guessed type void *;

//----- (004EBE7C) --------------------------------------------------------
void __fastcall CTaskSimpleTired::~CTaskSimpleTired(CTaskSimpleTired *this)
{
  void *v1; // r0

  CTask::~CTask(this);
  sub_197118(v1);
}
// 4EBE88: variable 'v1' is possibly undefined

//----- (004EBE8C) --------------------------------------------------------
bool __fastcall CTaskSimpleTired::ProcessPed(CTaskSimpleTired *this, CPed *pPed)
{
  __int64 v4; // r0
  AssocGroupId v5; // r1
  unsigned int v6; // r0
  int m_iStartTime; // r1

  if ( !this->m_pAnim )
  {
    CPed::SetMoveState(pPed, PEDMOVE_STILL);
    (*((void (__fastcall **)(CPed *))pPed->_vptr$CPlaceable + 24))(pPed);
    HIDWORD(v4) = this->m_iDuration;
    LODWORD(v4) = CTimer::m_snTimeInMilliseconds;
    this->m_timer.m_bIsActive = 1;
    *(_QWORD *)&this->m_timer.m_iStartTime = v4;
    if ( FindPlayerPed(-1) == pPed && CClothes::GetDefaultPlayerMotionGroup() == ANIM_PLAYER_FAT_PED )
      v5 = ANIM_PLAYER_FAT_TIRED_PED;
    else
      v5 = ANIM_STD_PED;
    this->m_pAnim = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, v5, ANIM_STD_IDLE_TIRED, 4.0);
  }
  if ( !this->m_timer.m_bIsActive )
    return 0;
  if ( this->m_timer.m_bIsStopped )
  {
    v6 = CTimer::m_snTimeInMilliseconds;
    this->m_timer.m_bIsStopped = 0;
    this->m_timer.m_iStartTime = v6;
    m_iStartTime = v6;
  }
  else
  {
    m_iStartTime = this->m_timer.m_iStartTime;
    v6 = CTimer::m_snTimeInMilliseconds;
  }
  if ( m_iStartTime + this->m_timer.m_iDuration > v6 )
    return 0;
  (*((void (__fastcall **)(CTaskSimpleTired *, CPed *, _DWORD, _DWORD))this->_vptr$CTask + 7))(this, pPed, 0, 0);
  return 1;
}

//----- (004EBF3C) --------------------------------------------------------
void __fastcall CTaskSimpleTired::StartAnim(CTaskSimpleTired *this, CPed *pPed)
{
  __int64 v4; // r0
  AssocGroupId v5; // r1

  CPed::SetMoveState(pPed, PEDMOVE_STILL);
  (*((void (__fastcall **)(CPed *))pPed->_vptr$CPlaceable + 24))(pPed);
  HIDWORD(v4) = this->m_iDuration;
  LODWORD(v4) = CTimer::m_snTimeInMilliseconds;
  this->m_timer.m_bIsActive = 1;
  *(_QWORD *)&this->m_timer.m_iStartTime = v4;
  if ( FindPlayerPed(-1) == pPed && CClothes::GetDefaultPlayerMotionGroup() == ANIM_PLAYER_FAT_PED )
    v5 = ANIM_PLAYER_FAT_TIRED_PED;
  else
    v5 = ANIM_STD_PED;
  this->m_pAnim = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, v5, ANIM_STD_IDLE_TIRED, 4.0);
}

//----- (004EBF9C) --------------------------------------------------------
bool __fastcall CTaskSimpleTired::MakeAbortable(
        CTaskSimpleTired *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r5

  m_pAnim = this->m_pAnim;
  if ( !m_pAnim || m_pAnim != RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0xAu) )
    return 1;
  this->m_pAnim->m_fBlendDelta = -4.0;
  return 1;
}

//----- (004EBFC4) --------------------------------------------------------
void __fastcall CTaskSimpleSitDown::CTaskSimpleSitDown(CTaskSimpleSitDown *this, bool8 sitOnStep)
{
  int v3; // r0

  CTaskSimple::CTaskSimple(this);
  *(_BYTE *)(v3 + 8) = sitOnStep;
  *(_BYTE *)(v3 + 9) = 0;
  *(_DWORD *)(v3 + 12) = 0;
  *(_DWORD *)v3 = &off_669E7C;
}
// 4EBFD2: variable 'v3' is possibly undefined
// 669E7C: using guessed type void *off_669E7C;

//----- (004EBFE8) --------------------------------------------------------
void __fastcall CTaskSimpleSitDown::~CTaskSimpleSitDown(CTaskSimpleSitDown *this)
{
  CAnimBlendAssociation *m_pAnim; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_669E7C;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  sub_1A01F4(this);
}
// 669E7C: using guessed type void *;

//----- (004EC01C) --------------------------------------------------------
void __fastcall CTaskSimpleSitDown::~CTaskSimpleSitDown(CTaskSimpleSitDown *this)
{
  CAnimBlendAssociation *m_pAnim; // r0
  void *v3; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_669E7C;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v3);
}
// 4EC046: variable 'v3' is possibly undefined
// 669E7C: using guessed type void *off_669E7C;

//----- (004EC054) --------------------------------------------------------
bool __fastcall CTaskSimpleSitDown::MakeAbortable(
        CTaskSimpleSitDown *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0
  CAnimBlendAssociation *v6; // r0
  bool result; // r0

  if ( iPriority == 2 )
  {
    m_pAnim = this->m_pAnim;
    if ( m_pAnim )
    {
      m_pAnim->m_fBlendDelta = -1000.0;
      v6 = this->m_pAnim;
LABEL_6:
      CAnimBlendAssociation::SetFinishCallback(v6, CDefaultAnimCallback::DefaultAnimCB, 0);
      result = 1;
      this->m_pAnim = 0;
      return result;
    }
    return 1;
  }
  v6 = this->m_pAnim;
  if ( iPriority == 1 )
  {
    if ( v6 )
      goto LABEL_6;
    return 1;
  }
  if ( v6 )
  {
    v6->m_bitsFlag |= 4u;
    this->m_pAnim->m_fBlendDelta = -4.0;
  }
  return 0;
}

//----- (004EC0B4) --------------------------------------------------------
bool __fastcall CTaskSimpleSitDown::ProcessPed(CTaskSimpleSitDown *this, CPed *pPed)
{
  RpClump_0 *m_pRwObject; // r0
  AssocGroupId v5; // r1
  AnimationId v6; // r2
  CAnimBlendAssociation *v7; // r0

  if ( this->m_bIsFinished )
    return 1;
  if ( this->m_pAnim )
    return 0;
  m_pRwObject = (RpClump_0 *)pPed->m_pRwObject;
  if ( this->m_sitOnStep )
  {
    v5 = ANIM_ATTR_PED;
    v6 = ANIM_ATTR_SEATSTEP_DOWN;
  }
  else
  {
    v5 = ANIM_STD_PED;
    v6 = ANIM_STD_SEAT_DOWN;
  }
  v7 = CAnimManager::BlendAnimation(m_pRwObject, v5, v6, 4.0);
  this->m_pAnim = v7;
  CAnimBlendAssociation::SetFinishCallback(v7, CTaskSimpleSitDown::FinishAnimSitDownCB, this);
  return 0;
}

//----- (004EC0FC) --------------------------------------------------------
void __fastcall CTaskSimpleSitDown::StartAnim(CTaskSimpleSitDown *this, CPed *pPed)
{
  RpClump_0 *m_pRwObject; // r0
  AssocGroupId v4; // r1
  AnimationId v5; // r2
  CAnimBlendAssociation *v6; // r0

  m_pRwObject = (RpClump_0 *)pPed->m_pRwObject;
  if ( this->m_sitOnStep )
  {
    v4 = ANIM_ATTR_PED;
    v5 = ANIM_ATTR_SEATSTEP_DOWN;
  }
  else
  {
    v4 = ANIM_STD_PED;
    v5 = ANIM_STD_SEAT_DOWN;
  }
  v6 = CAnimManager::BlendAnimation(m_pRwObject, v4, v5, 4.0);
  this->m_pAnim = v6;
  sub_18C19C(v6, CTaskSimpleSitDown::FinishAnimSitDownCB, this);
}

//----- (004EC134) --------------------------------------------------------
void __fastcall CTaskSimpleSitDown::FinishAnimSitDownCB(CAnimBlendAssociation *pAnim, void *pData)
{
  *((_BYTE *)pData + 9) = 1;
  *((_DWORD *)pData + 3) = 0;
}

//----- (004EC140) --------------------------------------------------------
void __fastcall CTaskSimpleSitIdle::CTaskSimpleSitIdle(CTaskSimpleSitIdle *this, const int iDuration, bool8 sitOnStep)
{
  int v5; // r0

  CTaskSimple::CTaskSimple(this);
  *(_BYTE *)(v5 + 8) = sitOnStep;
  *(_DWORD *)(v5 + 12) = iDuration;
  *(_DWORD *)(v5 + 26) = 0;
  *(_DWORD *)(v5 + 22) = 0;
  *(_DWORD *)(v5 + 16) = 0;
  *(_DWORD *)(v5 + 20) = 0;
  *(_DWORD *)v5 = &off_669EB0;
}
// 4EC150: variable 'v5' is possibly undefined
// 669EB0: using guessed type void *off_669EB0;

//----- (004EC174) --------------------------------------------------------
void __fastcall CTaskSimpleSitIdle::~CTaskSimpleSitIdle(CTaskSimpleSitIdle *this)
{
  void *v1; // r0

  CTask::~CTask(this);
  sub_197118(v1);
}
// 4EC180: variable 'v1' is possibly undefined

//----- (004EC184) --------------------------------------------------------
void __fastcall CTaskSimpleSitIdle::SetTimer(CTaskSimpleSitIdle *this, const int iDuration)
{
  int v2; // r2

  this->m_iDuration = iDuration;
  v2 = CTimer::m_snTimeInMilliseconds;
  this->m_timer.m_bIsActive = 1;
  this->m_timer.m_iStartTime = v2;
  this->m_timer.m_iDuration = iDuration;
}

//----- (004EC19C) --------------------------------------------------------
bool __fastcall CTaskSimpleSitIdle::MakeAbortable(
        CTaskSimpleSitIdle *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0
  unsigned __int64 v8; // r0

  if ( iPriority == 2 )
  {
    m_pAnim = this->m_pAnim;
    if ( m_pAnim )
    {
      m_pAnim->m_fBlendDelta = -1000.0;
      CAnimBlendAssociation::SetFinishCallback(this->m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
      this->m_pAnim = 0;
    }
    if ( IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
      IKChainManager_c::AbortLookAt(&g_ikChainMan, pPed, 750);
    return 1;
  }
  else
  {
    this->m_iDuration = -1;
    v8 = CTimer::m_snTimeInMilliseconds | 0xFFFFFFFF00000000LL;
    this->m_timer.m_bIsActive = 1;
    *(_QWORD *)&this->m_timer.m_iStartTime = v8;
    return 0;
  }
}

//----- (004EC220) --------------------------------------------------------
bool __fastcall CTaskSimpleSitIdle::ProcessPed(CTaskSimpleSitIdle *this, CPed *pPed)
{
  int m_iDuration; // r2
  int m_sitOnStep; // r1
  int v6; // r0
  AssocGroupId v7; // r1
  AnimationId v8; // r2
  CAnimBlendAssociation *v9; // r6
  CPed *ClosestPedInRange; // r11
  float v11; // s16
  CMatrix *m_pMat; // r1
  CMatrix *v13; // r0
  CMatrix **p_m_pMat; // r10
  CSimpleTransform *p_m_transform; // r6
  float *p_tx; // r3
  CSimpleTransform *v17; // r2
  float v18; // s24
  float v19; // s26
  float v20; // s22
  float xy; // s2
  float yy; // s4
  float zy; // s0
  float m_heading; // r8
  float v25; // r9
  float *v26; // r0
  __int64 v27; // d16
  float v28; // s24
  float v29; // s22
  float v30; // s20
  float v31; // r6
  float v32; // r8
  float v33; // s0
  float v34; // s4
  float v35; // s22
  float v36; // s24
  float v37; // s20
  float *v38; // r0
  float v39; // s30
  float v40; // s26
  float v41; // s28
  float v42; // r6
  float v43; // r8
  float v44; // s0
  unsigned int v45; // r0
  int m_iStartTime; // r1
  RwV3d_0 v48; // [sp+20h] [bp-70h] BYREF

  if ( !this->m_pAnim )
  {
    m_iDuration = this->m_iDuration;
    m_sitOnStep = this->m_sitOnStep;
    v6 = CTimer::m_snTimeInMilliseconds;
    this->m_timer.m_bIsActive = 1;
    this->m_timer.m_iStartTime = v6;
    this->m_timer.m_iDuration = m_iDuration;
    if ( m_sitOnStep )
    {
      v7 = ANIM_ATTR_PED;
      v8 = ANIM_ATTR_SEATSTEP_IDLE;
    }
    else
    {
      v7 = ANIM_STD_PED;
      v8 = ANIM_STD_SEAT_IDLE;
    }
    v9 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, v7, v8, 256.0);
    this->m_pAnim = v9;
    if ( v9 )
      v9->m_fSpeed = (float)((float)((float)rand() * 4.6566e-10) * 0.6) + 0.9;
  }
  if ( !IKChainManager_c::IsLooking(&g_ikChainMan, pPed)
    && (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) <= 4 )
  {
    ClosestPedInRange = CPedScanner::GetClosestPedInRange(&pPed->m_pPedIntelligence->m_pedScanner);
    v11 = (float)((int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 5000.0) + 3000);
    if ( ClosestPedInRange )
    {
      m_pMat = ClosestPedInRange->m_pMat;
      p_m_pMat = &pPed->m_pMat;
      v13 = pPed->m_pMat;
      p_m_transform = &pPed->m_transform;
      p_tx = &m_pMat->tx;
      v17 = &pPed->m_transform;
      if ( v13 )
        v17 = (CSimpleTransform *)&v13->tx;
      if ( !m_pMat )
        p_tx = &ClosestPedInRange->m_transform.m_translate.x;
      v18 = *p_tx - v17->m_translate.x;
      v19 = p_tx[1] - v17->m_translate.y;
      v20 = p_tx[2] - v17->m_translate.z;
      if ( v13 )
      {
        xy = v13->xy;
        yy = v13->yy;
        zy = v13->zy;
      }
      else
      {
        m_heading = pPed->m_transform.m_heading;
        v25 = sinf(m_heading);
        yy = cosf(m_heading);
        zy = 0.0;
        LODWORD(xy) = LODWORD(v25) ^ 0x80000000;
      }
      if ( (float)((float)((float)(v18 * xy) + (float)(v19 * yy)) + (float)(v20 * zy)) > 0.2
        && (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) <= 24 )
      {
        IKChainManager_c::LookAt(
          &g_ikChainMan,
          "TaskSitIdle",
          pPed,
          ClosestPedInRange,
          (int)v11,
          5,
          0,
          0,
          0.25,
          750,
          3,
          0);
        goto LABEL_30;
      }
    }
    else
    {
      p_m_transform = &pPed->m_transform;
      p_m_pMat = &pPed->m_pMat;
    }
    v26 = (float *)*p_m_pMat;
    if ( *p_m_pMat )
      p_m_transform = (CSimpleTransform *)(v26 + 12);
    v27 = *(_QWORD *)&p_m_transform->m_translate.x;
    v48.z = p_m_transform->m_translate.z;
    *(_QWORD *)&v48.x = v27;
    if ( v26 )
    {
      v28 = v26[4];
      v29 = v26[5];
      v30 = v26[6];
    }
    else
    {
      v31 = pPed->m_transform.m_heading;
      v32 = sinf(v31);
      v29 = cosf(v31);
      v30 = 0.0;
      LODWORD(v28) = LODWORD(v32) ^ 0x80000000;
    }
    v33 = (float)((float)((float)rand() * 4.6566e-10) * 4.0) + 1.0;
    v34 = v29 * v33;
    v35 = v48.x + (float)(v28 * v33);
    v36 = v48.y + v34;
    v37 = (float)(v30 * v33) + v48.z;
    v48.x = v35;
    v48.y = v48.y + v34;
    v48.z = v37;
    v38 = (float *)*p_m_pMat;
    if ( *p_m_pMat )
    {
      v39 = *v38;
      v40 = v38[1];
      v41 = v38[2];
    }
    else
    {
      v42 = pPed->m_transform.m_heading;
      v43 = cosf(v42);
      v40 = sinf(v42);
      v41 = 0.0;
      v39 = v43;
    }
    v44 = (float)((float)((float)rand() * 4.6566e-10) * 8.0) + -4.0;
    v48.x = v35 + (float)(v39 * v44);
    v48.y = v36 + (float)(v40 * v44);
    v48.z = (float)(v41 * v44) + v37;
    IKChainManager_c::LookAt(&g_ikChainMan, "TaskSitIdle", pPed, 0, (int)v11, -1, &v48, 0, 0.25, 750, 3, 0);
  }
LABEL_30:
  if ( !this->m_timer.m_bIsActive )
    return 0;
  if ( this->m_timer.m_bIsStopped )
  {
    v45 = CTimer::m_snTimeInMilliseconds;
    this->m_timer.m_bIsStopped = 0;
    this->m_timer.m_iStartTime = v45;
    m_iStartTime = v45;
  }
  else
  {
    m_iStartTime = this->m_timer.m_iStartTime;
    v45 = CTimer::m_snTimeInMilliseconds;
  }
  if ( m_iStartTime + this->m_timer.m_iDuration > v45 )
    return 0;
  if ( IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
    IKChainManager_c::AbortLookAt(&g_ikChainMan, pPed, 750);
  return 1;
}

//----- (004EC608) --------------------------------------------------------
void __fastcall CTaskSimpleSitIdle::StartAnim(CTaskSimpleSitIdle *this, CPed *pPed)
{
  int m_iDuration; // r3
  int m_sitOnStep; // r2
  int v5; // r0
  RpClump_0 *m_pRwObject; // r0
  AssocGroupId v7; // r1
  AnimationId v8; // r2
  CAnimBlendAssociation *v9; // r5

  m_iDuration = this->m_iDuration;
  m_sitOnStep = this->m_sitOnStep;
  v5 = CTimer::m_snTimeInMilliseconds;
  this->m_timer.m_bIsActive = 1;
  this->m_timer.m_iStartTime = v5;
  this->m_timer.m_iDuration = m_iDuration;
  m_pRwObject = (RpClump_0 *)pPed->m_pRwObject;
  if ( m_sitOnStep )
  {
    v7 = ANIM_ATTR_PED;
    v8 = ANIM_ATTR_SEATSTEP_IDLE;
  }
  else
  {
    v7 = ANIM_STD_PED;
    v8 = ANIM_STD_SEAT_IDLE;
  }
  v9 = CAnimManager::BlendAnimation(m_pRwObject, v7, v8, 256.0);
  this->m_pAnim = v9;
  if ( v9 )
    v9->m_fSpeed = (float)((float)((float)rand() * 4.6566e-10) * 0.6) + 0.9;
}

//----- (004EC680) --------------------------------------------------------
void __fastcall CTaskSimpleStandUp::CTaskSimpleStandUp(CTaskSimpleStandUp *this, bool8 sitOnStep)
{
  int v3; // r0

  CTaskSimple::CTaskSimple(this);
  *(_BYTE *)(v3 + 8) = sitOnStep;
  *(_BYTE *)(v3 + 9) = 0;
  *(_DWORD *)(v3 + 12) = 0;
  *(_DWORD *)v3 = &off_669EE4;
}
// 4EC68E: variable 'v3' is possibly undefined
// 669EE4: using guessed type void *off_669EE4;

//----- (004EC6A4) --------------------------------------------------------
void __fastcall CTaskSimpleStandUp::~CTaskSimpleStandUp(CTaskSimpleStandUp *this)
{
  CAnimBlendAssociation *m_pAnim; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_669EE4;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  sub_1A01F4(this);
}
// 669EE4: using guessed type void *;

//----- (004EC6D8) --------------------------------------------------------
void __fastcall CTaskSimpleStandUp::~CTaskSimpleStandUp(CTaskSimpleStandUp *this)
{
  CAnimBlendAssociation *m_pAnim; // r0
  void *v3; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_669EE4;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v3);
}
// 4EC702: variable 'v3' is possibly undefined
// 669EE4: using guessed type void *off_669EE4;

//----- (004EC710) --------------------------------------------------------
bool __fastcall CTaskSimpleStandUp::MakeAbortable(
        CTaskSimpleStandUp *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0
  CAnimBlendAssociation *v6; // r0
  bool result; // r0

  if ( iPriority == 2 )
  {
    m_pAnim = this->m_pAnim;
    if ( m_pAnim )
    {
      m_pAnim->m_fBlendDelta = -1000.0;
      v6 = this->m_pAnim;
LABEL_6:
      CAnimBlendAssociation::SetFinishCallback(v6, CDefaultAnimCallback::DefaultAnimCB, 0);
      result = 1;
      this->m_pAnim = 0;
      return result;
    }
    return 1;
  }
  v6 = this->m_pAnim;
  if ( iPriority == 1 )
  {
    if ( v6 )
      goto LABEL_6;
    return 1;
  }
  if ( v6 )
  {
    v6->m_bitsFlag |= 4u;
    this->m_pAnim->m_fBlendDelta = -4.0;
  }
  return 0;
}

//----- (004EC770) --------------------------------------------------------
bool __fastcall CTaskSimpleStandUp::ProcessPed(CTaskSimpleStandUp *this, CPed *pPed)
{
  RpClump_0 *m_pRwObject; // r0
  AssocGroupId v5; // r1
  AnimationId v6; // r2
  CAnimBlendAssociation *v7; // r0

  if ( this->m_bIsFinished )
    return 1;
  if ( this->m_pAnim )
    return 0;
  m_pRwObject = (RpClump_0 *)pPed->m_pRwObject;
  if ( this->m_sitOnStep )
  {
    v5 = ANIM_ATTR_PED;
    v6 = ANIM_ATTR_SEATSTEP_UP;
  }
  else
  {
    v5 = ANIM_STD_PED;
    v6 = ANIM_STD_SEAT_UP;
  }
  v7 = CAnimManager::BlendAnimation(m_pRwObject, v5, v6, 4.0);
  this->m_pAnim = v7;
  CAnimBlendAssociation::SetFinishCallback(v7, CTaskSimpleStandUp::FinishAnimStandUpCB, this);
  return 0;
}

//----- (004EC7B8) --------------------------------------------------------
void __fastcall CTaskSimpleStandUp::StartAnim(CTaskSimpleStandUp *this, CPed *pPed)
{
  RpClump_0 *m_pRwObject; // r0
  AssocGroupId v4; // r1
  AnimationId v5; // r2
  CAnimBlendAssociation *v6; // r0

  m_pRwObject = (RpClump_0 *)pPed->m_pRwObject;
  if ( this->m_sitOnStep )
  {
    v4 = ANIM_ATTR_PED;
    v5 = ANIM_ATTR_SEATSTEP_UP;
  }
  else
  {
    v4 = ANIM_STD_PED;
    v5 = ANIM_STD_SEAT_UP;
  }
  v6 = CAnimManager::BlendAnimation(m_pRwObject, v4, v5, 4.0);
  this->m_pAnim = v6;
  sub_18C19C(v6, CTaskSimpleStandUp::FinishAnimStandUpCB, this);
}

//----- (004EC7F0) --------------------------------------------------------
void __fastcall CTaskSimpleStandUp::FinishAnimStandUpCB(CAnimBlendAssociation *pAnim, void *pData)
{
  *((_BYTE *)pData + 9) = 1;
  *((_DWORD *)pData + 3) = 0;
}

//----- (004EC7FC) --------------------------------------------------------
void __fastcall CTaskComplexSitDownThenIdleThenStandUp::CTaskComplexSitDownThenIdleThenStandUp(
        CTaskComplexSitDownThenIdleThenStandUp *this,
        const int iDuration,
        bool8 sitOnStep,
        bool8 doInstantly)
{
  int v7; // r0

  CTaskComplex::CTaskComplex(this);
  *(_DWORD *)(v7 + 12) = iDuration;
  *(_BYTE *)(v7 + 16) = sitOnStep;
  *(_BYTE *)(v7 + 17) = doInstantly;
  *(_BYTE *)(v7 + 18) = 0;
  *(_DWORD *)v7 = &off_669F18;
}
// 4EC812: variable 'v7' is possibly undefined
// 669F18: using guessed type void *;

//----- (004EC82C) --------------------------------------------------------
void __fastcall CTaskComplexSitDownThenIdleThenStandUp::~CTaskComplexSitDownThenIdleThenStandUp(
        CTaskComplexSitDownThenIdleThenStandUp *this)
{
  int m_animsReferenced; // r1
  int32 AnimationBlockIndex; // r0

  m_animsReferenced = this->m_animsReferenced;
  this->_vptr$CTask = (int (**)(void))&off_669F18;
  if ( m_animsReferenced )
  {
    AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("attractors");
    CAnimManager::RemoveAnimBlockRef(AnimationBlockIndex);
    this->m_animsReferenced = 0;
  }
  sub_18EDB4(this);
}
// 669F18: using guessed type void *off_669F18;

//----- (004EC868) --------------------------------------------------------
void __fastcall CTaskComplexSitDownThenIdleThenStandUp::~CTaskComplexSitDownThenIdleThenStandUp(
        CTaskComplexSitDownThenIdleThenStandUp *this)
{
  int m_animsReferenced; // r1
  int32 AnimationBlockIndex; // r0
  void *v4; // r0

  m_animsReferenced = this->m_animsReferenced;
  this->_vptr$CTask = (int (**)(void))&off_669F18;
  if ( m_animsReferenced )
  {
    AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("attractors");
    CAnimManager::RemoveAnimBlockRef(AnimationBlockIndex);
    this->m_animsReferenced = 0;
  }
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 4EC89A: variable 'v4' is possibly undefined
// 669F18: using guessed type void *off_669F18;

//----- (004EC8A8) --------------------------------------------------------
bool __fastcall CTaskComplexSitDownThenIdleThenStandUp::MakeAbortable(
        CTaskComplexSitDownThenIdleThenStandUp *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CTask *m_pSubTask; // r12

  if ( iPriority == 2 )
    return (*((int (__fastcall **)(CTask *, CPed *, int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
             this->m_pSubTask,
             pPed,
             2,
             pEvent);
  m_pSubTask = this->m_pSubTask;
  this->m_iDuration = 0;
  (*((void (__fastcall **)(CTask *, CPed *, _DWORD, const CEvent *))m_pSubTask->_vptr$CTask + 7))(
    m_pSubTask,
    pPed,
    0,
    pEvent);
  return 0;
}

//----- (004EC8D8) --------------------------------------------------------
CTask *__fastcall CTaskComplexSitDownThenIdleThenStandUp::CreateNextSubTask(
        CTaskComplexSitDownThenIdleThenStandUp *this,
        CPed *pPed)
{
  int v3; // r2
  CTask *result; // r0
  int v5; // r1
  CTaskSimple *v6; // r0
  CTask *m_iDuration; // r5
  bool8 m_sitOnStep; // r4
  char *v9; // r1
  CTaskSimple *v10; // r0
  CTaskSimple *v11; // r0
  bool8 v12; // r4

  v3 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) - 203;
  result = 0;
  v5 = 222;
  switch ( v3 )
  {
    case 0:
      if ( this->m_sitOnStep )
      {
        if ( !this->m_animsReferenced )
        {
          v10 = (CTaskSimple *)CTask::operator new(0x20u);
          CTaskSimple::CTaskSimple(v10);
          result[1]._vptr$CTask = (int (**)(void))&dword_64;
          LOWORD(result[2].m_pParent) = 0;
          result[3].m_pParent = (CTask *)1090519040;
          LOWORD(result[3]._vptr$CTask) = 0;
          v9 = (char *)&`vtable for'CTaskSimpleStandStill;
          result[2]._vptr$CTask = 0;
          goto LABEL_13;
        }
        if ( this->m_doInstantly )
          goto LABEL_10;
      }
      else if ( this->m_doInstantly )
      {
LABEL_10:
        v6 = (CTaskSimple *)CTask::operator new(0x20u);
        m_iDuration = (CTask *)this->m_iDuration;
        m_sitOnStep = this->m_sitOnStep;
        CTaskSimple::CTaskSimple(v6);
        LOBYTE(result[1]._vptr$CTask) = m_sitOnStep;
        result[1].m_pParent = m_iDuration;
        *(int (***)(void))((char *)&result[3]._vptr$CTask + 2) = 0;
        *(CTask **)((char *)&result[2].m_pParent + 2) = 0;
        result[2].m_pParent = 0;
        v9 = (char *)&`vtable for'CTaskSimpleSitIdle;
        result[2]._vptr$CTask = 0;
        goto LABEL_14;
      }
      v11 = (CTaskSimple *)CTask::operator new(0x10u);
      v12 = this->m_sitOnStep;
      CTaskSimple::CTaskSimple(v11);
      v9 = (char *)&`vtable for'CTaskSimpleSitDown;
      LOBYTE(result[1]._vptr$CTask) = v12;
      BYTE1(result[1]._vptr$CTask) = 0;
LABEL_13:
      result[1].m_pParent = 0;
LABEL_14:
      result->_vptr$CTask = (int (**)(void))(v9 + 8);
      return result;
    case 17:
      v5 = 221;
      return CTaskComplexSitDownThenIdleThenStandUp::CreateSubTask(this, v5);
    case 18:
      return CTaskComplexSitDownThenIdleThenStandUp::CreateSubTask(this, v5);
    case 19:
      v5 = 1302;
      return CTaskComplexSitDownThenIdleThenStandUp::CreateSubTask(this, v5);
    default:
      return result;
  }
}
// 4EC954: variable 'result' is possibly undefined
// 64: using guessed type int dword_64;

//----- (004EC9D4) --------------------------------------------------------
CTask *__fastcall CTaskComplexSitDownThenIdleThenStandUp::CreateSubTask(
        CTaskComplexSitDownThenIdleThenStandUp *this,
        const int iSubTaskType)
{
  char *v3; // r4
  bool8 v4; // r5
  char *v5; // r0
  CTaskSimple *v6; // r0
  bool8 m_sitOnStep; // r5
  _DWORD *v8; // r0
  CTaskSimple *v9; // r0
  int m_iDuration; // r6
  bool8 v11; // r5

  v3 = 0;
  switch ( iSubTaskType )
  {
    case 222:
      v6 = (CTaskSimple *)CTask::operator new(0x10u);
      m_sitOnStep = this->m_sitOnStep;
      CTaskSimple::CTaskSimple(v6);
      *((_BYTE *)v8 + 8) = m_sitOnStep;
      *((_BYTE *)v8 + 9) = 0;
      v8[3] = 0;
      v3 = (char *)v8;
      *v8 = &off_669EE4;
      break;
    case 221:
      v9 = (CTaskSimple *)CTask::operator new(0x20u);
      m_iDuration = this->m_iDuration;
      v3 = (char *)v9;
      v11 = this->m_sitOnStep;
      CTaskSimple::CTaskSimple(v9);
      v3[8] = v11;
      *((_DWORD *)v3 + 3) = m_iDuration;
      *(_DWORD *)(v3 + 26) = 0;
      *(_DWORD *)(v3 + 22) = 0;
      v5 = (char *)&`vtable for'CTaskSimpleSitIdle;
      *((_DWORD *)v3 + 4) = 0;
      *((_DWORD *)v3 + 5) = 0;
      goto LABEL_7;
    case 220:
      v3 = (char *)CTask::operator new(0x10u);
      v4 = this->m_sitOnStep;
      CTaskSimple::CTaskSimple((CTaskSimple *)v3);
      v3[8] = v4;
      v3[9] = 0;
      *((_DWORD *)v3 + 3) = 0;
      v5 = (char *)&`vtable for'CTaskSimpleSitDown;
LABEL_7:
      *(_DWORD *)v3 = v5 + 8;
      break;
  }
  return (CTask *)v3;
}
// 4ECA18: variable 'v8' is possibly undefined
// 669EE4: using guessed type void *off_669EE4;

//----- (004ECA6C) --------------------------------------------------------
CTask *__fastcall CTaskComplexSitDownThenIdleThenStandUp::CreateFirstSubTask(
        CTaskComplexSitDownThenIdleThenStandUp *this,
        CPed *pPed)
{
  CTaskSimple *v2; // r0
  CTask *result; // r0

  v2 = (CTaskSimple *)CTask::operator new(0x20u);
  CTaskSimple::CTaskSimple(v2);
  result[1]._vptr$CTask = (int (**)(void))&dword_64;
  LOWORD(result[2].m_pParent) = 0;
  result[3].m_pParent = (CTask *)1090519040;
  LOWORD(result[3]._vptr$CTask) = 0;
  result[1].m_pParent = 0;
  result[2]._vptr$CTask = 0;
  result->_vptr$CTask = (int (**)(void))&off_669BFC;
  return result;
}
// 4ECA7E: variable 'result' is possibly undefined
// 64: using guessed type int dword_64;
// 669BFC: using guessed type void *off_669BFC;

//----- (004ECAA0) --------------------------------------------------------
CTask *__fastcall CTaskComplexSitDownThenIdleThenStandUp::ControlSubTask(
        CTaskComplexSitDownThenIdleThenStandUp *this,
        CPed *pPed)
{
  int32 AnimationBlockIndex; // r0

  if ( this->m_animsReferenced || !this->m_sitOnStep )
    return this->m_pSubTask;
  AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("attractors");
  if ( CAnimManager::ms_aAnimBlocks[AnimationBlockIndex].m_loaded )
  {
    CAnimManager::AddAnimBlockRef(AnimationBlockIndex);
    this->m_animsReferenced = 1;
  }
  else
  {
    CStreaming::RequestModel(AnimationBlockIndex + 25575, 8);
  }
  return this->m_pSubTask;
}

//----- (004ECAF0) --------------------------------------------------------
void __fastcall CTaskComplexObserveTrafficLights::CTaskComplexObserveTrafficLights(
        CTaskComplexObserveTrafficLights *this)
{
  int v1; // r0

  CTaskComplex::CTaskComplex(this);
  *(_WORD *)(v1 + 20) = 0;
  *(_DWORD *)(v1 + 12) = 0;
  *(_DWORD *)(v1 + 16) = 0;
  *(_DWORD *)v1 = &off_669F54;
}
// 4ECAFC: variable 'v1' is possibly undefined
// 669F54: using guessed type void *off_669F54;

//----- (004ECB14) --------------------------------------------------------
void __fastcall CTaskComplexObserveTrafficLights::~CTaskComplexObserveTrafficLights(
        CTaskComplexObserveTrafficLights *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 4ECB20: variable 'v1' is possibly undefined

//----- (004ECB24) --------------------------------------------------------
bool __fastcall CTaskComplexObserveTrafficLights::MakeAbortable(
        CTaskComplexObserveTrafficLights *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 1;
}

//----- (004ECB28) --------------------------------------------------------
CTask *__fastcall CTaskComplexObserveTrafficLights::CreateNextSubTask(
        CTaskComplexObserveTrafficLights *this,
        CPed *pPed)
{
  CTask *m_pSubTask; // r0
  CTaskSimpleRunAnim *v5; // r4
  int v7; // r0
  unsigned __int16 v8; // r5
  CTaskSimple *v9; // r0
  int v10; // r0

  m_pSubTask = this->m_pSubTask;
  if ( m_pSubTask && (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) != 203 )
  {
    v7 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
    v5 = 0;
    if ( v7 == 400 )
    {
      v8 = rand();
      v9 = (CTaskSimple *)CTask::operator new(0x20u);
      CTaskSimple::CTaskSimple(v9);
      *(_DWORD *)v10 = &off_669BFC;
      *(_WORD *)(v10 + 20) = 0;
      *(_DWORD *)(v10 + 28) = 1090519040;
      *(_WORD *)(v10 + 24) = 0;
      *(_DWORD *)(v10 + 8) = (int)(float)((float)((float)v8 * 0.000015259) * 2000.0) + 3000;
      *(_DWORD *)(v10 + 12) = 0;
      *(_DWORD *)(v10 + 16) = 0;
      return (CTask *)v10;
    }
  }
  else
  {
    v5 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
    CTaskSimpleRunAnim::CTaskSimpleRunAnim(v5, (const AssocGroupId)pPed->m_motionAnimGroup, ANIM_STD_ROADCROSS, 4.0, 0);
  }
  return v5;
}
// 4ECB98: variable 'v10' is possibly undefined
// 669BFC: using guessed type void *off_669BFC;

//----- (004ECBD4) --------------------------------------------------------
CTask *__fastcall CTaskComplexObserveTrafficLights::CreateFirstSubTask(
        CTaskComplexObserveTrafficLights *this,
        CPed *pPed)
{
  return (CTask *)(*((int (__fastcall **)(CTaskComplexObserveTrafficLights *, CPed *))this->_vptr$CTask + 10))(
                    this,
                    pPed);
}

//----- (004ECBDA) --------------------------------------------------------
CTask *__fastcall CTaskComplexObserveTrafficLights::ControlSubTask(CTaskComplexObserveTrafficLights *this, CPed *pPed)
{
  CTask *v4; // r5

  if ( CTrafficLights::LightForPeds() )
    return this->m_pSubTask;
  v4 = 0;
  if ( !(*((int (__fastcall **)(CTask *, CPed *, _DWORD, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
          this->m_pSubTask,
          pPed,
          0,
          0) )
    return this->m_pSubTask;
  return v4;
}

//----- (004ECC10) --------------------------------------------------------
void __fastcall CTaskComplexObserveTrafficLightsAndAchieveHeading::CTaskComplexObserveTrafficLightsAndAchieveHeading(
        CTaskComplexObserveTrafficLightsAndAchieveHeading *this,
        const int iDuration,
        const float fTargetHeading)
{
  int v5; // r0

  CTaskComplex::CTaskComplex(this);
  *(_DWORD *)(v5 + 12) = iDuration;
  *(const float *)(v5 + 16) = fTargetHeading;
  *(_DWORD *)v5 = &off_669F90;
}
// 4ECC1E: variable 'v5' is possibly undefined
// 669F90: using guessed type void *off_669F90;

//----- (004ECC34) --------------------------------------------------------
void __fastcall CTaskComplexObserveTrafficLightsAndAchieveHeading::~CTaskComplexObserveTrafficLightsAndAchieveHeading(
        CTaskComplexObserveTrafficLightsAndAchieveHeading *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 4ECC40: variable 'v1' is possibly undefined

//----- (004ECC44) --------------------------------------------------------
CTask *__fastcall CTaskComplexObserveTrafficLightsAndAchieveHeading::CreateSubTask(
        const CTaskComplexObserveTrafficLightsAndAchieveHeading *this,
        const int iSubTaskType)
{
  CTask *v3; // r4
  CTaskSimpleAchieveHeading *v4; // r0
  CTask *result; // r0
  CTaskComplex *v6; // r0
  int v7; // r0

  v3 = 0;
  if ( iSubTaskType == 224 )
  {
    v6 = (CTaskComplex *)CTask::operator new(0x18u);
    CTaskComplex::CTaskComplex(v6);
    *(_WORD *)(v7 + 20) = 0;
    *(_DWORD *)(v7 + 12) = 0;
    *(_DWORD *)(v7 + 16) = 0;
    v3 = (CTask *)v7;
    *(_DWORD *)v7 = &off_669F54;
  }
  else if ( iSubTaskType == 902 )
  {
    v4 = (CTaskSimpleAchieveHeading *)CTask::operator new(0x18u);
    CTaskSimpleAchieveHeading::CTaskSimpleAchieveHeading(v4, this->m_fTargetHeading, 0.5, 0.2);
    return result;
  }
  return v3;
}
// 4ECC86: variable 'v7' is possibly undefined
// 669F54: using guessed type void *;

//----- (004ECCA8) --------------------------------------------------------
CTask *__fastcall CTaskComplexObserveTrafficLightsAndAchieveHeading::CreateNextSubTask(
        CTaskComplexObserveTrafficLightsAndAchieveHeading *this,
        CPed *pPed)
{
  CTask *v2; // r4
  CTaskComplex *v3; // r0
  int v4; // r0

  v2 = 0;
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 902 )
  {
    v3 = (CTaskComplex *)CTask::operator new(0x18u);
    CTaskComplex::CTaskComplex(v3);
    *(_WORD *)(v4 + 20) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
    v2 = (CTask *)v4;
    *(_DWORD *)v4 = &off_669F54;
  }
  return v2;
}
// 4ECCCA: variable 'v4' is possibly undefined
// 669F54: using guessed type void *off_669F54;

//----- (004ECCE4) --------------------------------------------------------
CTask *__fastcall CTaskComplexObserveTrafficLightsAndAchieveHeading::CreateFirstSubTask(
        CTaskComplexObserveTrafficLightsAndAchieveHeading *this,
        CPed *pPed)
{
  CTaskSimpleAchieveHeading *v3; // r0
  CTask *result; // r0

  v3 = (CTaskSimpleAchieveHeading *)CTask::operator new(0x18u);
  sub_19DE08(v3, this->m_fTargetHeading, 0.5, 0.2);
  return result;
}

//----- (004ECD14) --------------------------------------------------------
CTask *__fastcall CTaskComplexObserveTrafficLightsAndAchieveHeading::ControlSubTask(
        CTaskComplexObserveTrafficLightsAndAchieveHeading *this,
        CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (004ECD18) --------------------------------------------------------
void __fastcall CTaskComplexCrossRoadLookAndAchieveHeading::CTaskComplexCrossRoadLookAndAchieveHeading(
        CTaskComplexCrossRoadLookAndAchieveHeading *this,
        const int iDuration,
        const float fTargetHeading)
{
  int v5; // r0

  CTaskComplex::CTaskComplex(this);
  *(_DWORD *)(v5 + 12) = iDuration;
  *(const float *)(v5 + 16) = fTargetHeading;
  *(_DWORD *)v5 = &off_669FCC;
}
// 4ECD26: variable 'v5' is possibly undefined
// 669FCC: using guessed type void *off_669FCC;

//----- (004ECD3C) --------------------------------------------------------
void __fastcall CTaskComplexCrossRoadLookAndAchieveHeading::~CTaskComplexCrossRoadLookAndAchieveHeading(
        CTaskComplexCrossRoadLookAndAchieveHeading *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 4ECD48: variable 'v1' is possibly undefined

//----- (004ECD4C) --------------------------------------------------------
CTask *__fastcall CTaskComplexCrossRoadLookAndAchieveHeading::CreateSubTask(
        const CTaskComplexCrossRoadLookAndAchieveHeading *this,
        const int iSubTaskType,
        CPed *pPed)
{
  CTaskSimpleAchieveHeading *v5; // r4
  CTaskSimpleRunAnim *v6; // r0
  CTask *v7; // r0

  v5 = 0;
  if ( iSubTaskType == 400 )
  {
    v6 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
    CTaskSimpleRunAnim::CTaskSimpleRunAnim(v6, (const AssocGroupId)pPed->m_motionAnimGroup, ANIM_STD_ROADCROSS, 4.0, 0);
    return v7;
  }
  else if ( iSubTaskType == 902 )
  {
    v5 = (CTaskSimpleAchieveHeading *)CTask::operator new(0x18u);
    CTaskSimpleAchieveHeading::CTaskSimpleAchieveHeading(v5, this->m_fTargetHeading, 0.5, 0.2);
  }
  return v5;
}
// 4ECDA2: variable 'v7' is possibly undefined

//----- (004ECDB8) --------------------------------------------------------
CTask *__fastcall CTaskComplexCrossRoadLookAndAchieveHeading::CreateNextSubTask(
        CTaskComplexCrossRoadLookAndAchieveHeading *this,
        CPed *pPed)
{
  CTask *v3; // r5
  CTaskSimpleRunAnim *v4; // r0
  CTask *v5; // r0

  v3 = 0;
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 902 )
  {
    v4 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
    CTaskSimpleRunAnim::CTaskSimpleRunAnim(v4, (const AssocGroupId)pPed->m_motionAnimGroup, ANIM_STD_ROADCROSS, 4.0, 0);
    return v5;
  }
  return v3;
}
// 4ECDE8: variable 'v5' is possibly undefined

//----- (004ECDF0) --------------------------------------------------------
CTask *__fastcall CTaskComplexCrossRoadLookAndAchieveHeading::CreateFirstSubTask(
        CTaskComplexCrossRoadLookAndAchieveHeading *this,
        CPed *pPed)
{
  CTaskSimpleAchieveHeading *v3; // r0
  CTask *result; // r0

  v3 = (CTaskSimpleAchieveHeading *)CTask::operator new(0x18u);
  sub_19DE08(v3, this->m_fTargetHeading, 0.5, 0.2);
  return result;
}

//----- (004ECE20) --------------------------------------------------------
CTask *__fastcall CTaskComplexCrossRoadLookAndAchieveHeading::ControlSubTask(
        CTaskComplexCrossRoadLookAndAchieveHeading *this,
        CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (004ECE24) --------------------------------------------------------
void __fastcall CTaskSimpleTurn180::CTaskSimpleTurn180(CTaskSimpleTurn180 *this)
{
  int v1; // r0

  CTaskSimple::CTaskSimple(this);
  *(_BYTE *)(v1 + 8) = 0;
  *(_DWORD *)(v1 + 12) = 0;
  *(_DWORD *)v1 = &off_66A008;
}
// 4ECE30: variable 'v1' is possibly undefined
// 66A008: using guessed type void *off_66A008;

//----- (004ECE44) --------------------------------------------------------
void __fastcall CTaskSimpleTurn180::~CTaskSimpleTurn180(CTaskSimpleTurn180 *this)
{
  CAnimBlendAssociation *m_pAnim; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_66A008;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  sub_1A01F4(this);
}
// 66A008: using guessed type void *;

//----- (004ECE78) --------------------------------------------------------
void __fastcall CTaskSimpleTurn180::~CTaskSimpleTurn180(CTaskSimpleTurn180 *this)
{
  CAnimBlendAssociation *m_pAnim; // r0
  void *v3; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_66A008;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v3);
}
// 4ECEA2: variable 'v3' is possibly undefined
// 66A008: using guessed type void *off_66A008;

//----- (004ECEB0) --------------------------------------------------------
bool __fastcall CTaskSimpleTurn180::ProcessPed(CTaskSimpleTurn180 *this, CPed *pPed)
{
  RpClump_0 *m_pRwObject; // r0
  CAnimBlendAssociation *v5; // r0

  if ( this->m_bIsFinished )
  {
    CPed::RestoreHeadingRate(pPed);
    return 1;
  }
  else
  {
    if ( !this->m_pAnim )
    {
      m_pRwObject = (RpClump_0 *)pPed->m_pRwObject;
      pPed->m_fHeadingChangeRate = 0.0;
      v5 = CAnimManager::BlendAnimation(m_pRwObject, ANIM_STD_PED, ANIM_STD_TURN180, 4.0);
      this->m_pAnim = v5;
      CAnimBlendAssociation::SetFinishCallback(v5, CTaskSimpleTurn180::FinishAnimTurn180CB, this);
    }
    return 0;
  }
}

//----- (004ECEF8) --------------------------------------------------------
void __fastcall CTaskSimpleTurn180::StartAnim(CTaskSimpleTurn180 *this, CPed *pPed)
{
  CAnimBlendAssociation *v3; // r0

  v3 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, ANIM_STD_TURN180, 4.0);
  this->m_pAnim = v3;
  sub_18C19C(v3, CTaskSimpleTurn180::FinishAnimTurn180CB, this);
}

//----- (004ECF24) --------------------------------------------------------
void __fastcall CTaskSimpleTurn180::FinishAnimTurn180CB(CAnimBlendAssociation *pAnim, void *pData)
{
  *((_DWORD *)pData + 3) = 0;
  *((_BYTE *)pData + 8) = 1;
}

//----- (004ECF30) --------------------------------------------------------
void __fastcall CTaskComplexHitResponse::CTaskComplexHitResponse(CTaskComplexHitResponse *this, const int iHitSide)
{
  _DWORD *v3; // r0

  CTaskComplex::CTaskComplex(this);
  v3[3] = iHitSide;
  *v3 = &off_66A03C;
}
// 4ECF3C: variable 'v3' is possibly undefined
// 66A03C: using guessed type void *;

//----- (004ECF50) --------------------------------------------------------
void __fastcall CTaskComplexHitResponse::~CTaskComplexHitResponse(CTaskComplexHitResponse *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 4ECF5C: variable 'v1' is possibly undefined

//----- (004ECF60) --------------------------------------------------------
CTask *__fastcall CTaskComplexHitResponse::CreateNextSubTask(CTaskComplexHitResponse *this, CPed *pPed)
{
  return 0;
}

//----- (004ECF64) --------------------------------------------------------
CTask *__fastcall CTaskComplexHitResponse::CreateFirstSubTask(CTaskComplexHitResponse *this, CPed *pPed)
{
  int m_iHitSide; // r0
  CTask *result; // r0
  CTaskSimpleRunAnim *v4; // r0
  void **v5; // r1
  CTaskSimpleRunAnim *v6; // r0
  CTaskSimpleRunAnim *v7; // r0
  CTaskSimpleRunAnim *v8; // r0

  m_iHitSide = this->m_iHitSide;
  switch ( m_iHitSide )
  {
    case 0:
      v4 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(v4, ANIM_STD_PED, ANIM_STD_HIT_FRONT, 4.0, 404, "HitFromFront", 0);
      v5 = &`vtable for'CTaskSimpleHitFromFront;
      goto LABEL_8;
    case 1:
      v8 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(v8, ANIM_STD_PED, ANIM_STD_HIT_LEFT, 4.0, 405, "HitFromLeft", 0);
      v5 = &`vtable for'CTaskSimpleHitFromLeft;
      goto LABEL_8;
    case 2:
      v6 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(v6, ANIM_STD_PED, ANIM_STD_HIT_BACK, 4.0, 403, "HitFromBack", 0);
      v5 = &`vtable for'CTaskSimpleHitFromBack;
      goto LABEL_8;
    case 3:
      v7 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(v7, ANIM_STD_PED, ANIM_STD_HIT_RIGHT, 4.0, 406, "HitFromRight", 0);
      v5 = &`vtable for'CTaskSimpleHitFromRight;
LABEL_8:
      result->_vptr$CTask = (int (**)(void))((char *)*v5 + 8);
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 4ED01E: variable 'result' is possibly undefined
// 6778C4: using guessed type void *`vtable for'CTaskSimpleHitFromLeft;
// 677F24: using guessed type void *`vtable for'CTaskSimpleHitFromBack;
// 678748: using guessed type void *`vtable for'CTaskSimpleHitFromRight;
// 678CDC: using guessed type void *`vtable for'CTaskSimpleHitFromFront;

//----- (004ED044) --------------------------------------------------------
CTask *__fastcall CTaskComplexHitResponse::ControlSubTask(CTaskComplexHitResponse *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (004ED048) --------------------------------------------------------
void __fastcall CTaskComplexHitByGunResponse::CTaskComplexHitByGunResponse(
        CTaskComplexHitByGunResponse *this,
        const int iHitSide)
{
  _DWORD *v3; // r0

  CTaskComplex::CTaskComplex(this);
  v3[3] = iHitSide;
  *v3 = &off_66A078;
}
// 4ED054: variable 'v3' is possibly undefined
// 66A078: using guessed type void *off_66A078;

//----- (004ED068) --------------------------------------------------------
void __fastcall CTaskComplexHitByGunResponse::~CTaskComplexHitByGunResponse(CTaskComplexHitByGunResponse *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 4ED074: variable 'v1' is possibly undefined

//----- (004ED078) --------------------------------------------------------
CTask *__fastcall CTaskComplexHitByGunResponse::CreateNextSubTask(CTaskComplexHitByGunResponse *this, CPed *pPed)
{
  return 0;
}

//----- (004ED07C) --------------------------------------------------------
CTask *__fastcall CTaskComplexHitByGunResponse::CreateFirstSubTask(CTaskComplexHitByGunResponse *this, CPed *pPed)
{
  int m_iHitSide; // r0
  CTask *result; // r0
  CTaskSimpleRunAnim *v4; // r0
  void **v5; // r1
  CTaskSimpleRunAnim *v6; // r0
  CTaskSimpleRunAnim *v7; // r0
  CTaskSimpleRunAnim *v8; // r0

  m_iHitSide = this->m_iHitSide;
  switch ( m_iHitSide )
  {
    case 0:
      v4 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        v4,
        ANIM_STD_PED,
        ANIM_STD_HITBYGUN_FRONT,
        4.0,
        408,
        "HitByGunFromFront",
        0);
      v5 = &`vtable for'CTaskSimpleHitByGunFromFront;
      goto LABEL_8;
    case 1:
      v8 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(v8, ANIM_STD_PED, ANIM_STD_HITBYGUN_LEFT, 4.0, 409, "HitByGunFromLeft", 0);
      v5 = &`vtable for'CTaskSimpleHitByGunFromLeft;
      goto LABEL_8;
    case 2:
      v6 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(v6, ANIM_STD_PED, ANIM_STD_HITBYGUN_BACK, 4.0, 407, "HitByGunFromRear", 0);
      v5 = &`vtable for'CTaskSimpleHitByGunFromRear;
      goto LABEL_8;
    case 3:
      v7 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        v7,
        ANIM_STD_PED,
        ANIM_STD_HITBYGUN_RIGHT,
        4.0,
        410,
        "HitByGunFromRight",
        0);
      v5 = &`vtable for'CTaskSimpleHitByGunFromRight;
LABEL_8:
      result->_vptr$CTask = (int (**)(void))((char *)*v5 + 8);
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 4ED136: variable 'result' is possibly undefined
// 676894: using guessed type void *`vtable for'CTaskSimpleHitByGunFromFront;
// 676A48: using guessed type void *`vtable for'CTaskSimpleHitByGunFromRear;
// 676AF8: using guessed type void *`vtable for'CTaskSimpleHitByGunFromLeft;
// 67998C: using guessed type void *`vtable for'CTaskSimpleHitByGunFromRight;

//----- (004ED15C) --------------------------------------------------------
CTask *__fastcall CTaskComplexHitByGunResponse::ControlSubTask(CTaskComplexHitByGunResponse *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (004ED160) --------------------------------------------------------
void __fastcall CTaskComplexSunbathe::CTaskComplexSunbathe(
        CTaskComplexSunbathe *this,
        CObject *pTowel,
        const bool bStartStanding)
{
  CTaskComplex::CTaskComplex(this);
  this->m_bStartStanding = bStartStanding;
  *(_WORD *)&this->m_BathingTimer.m_bIsActive = 0;
  *(_DWORD *)&this->m_bBathing = 0;
  this->m_BathingTimer.m_iStartTime = 0;
  this->m_BathingTimer.m_iDuration = 0;
  this->_vptr$CTask = (int (**)(void))&off_66A0B4;
  this->m_pTowel = pTowel;
  if ( pTowel )
  {
    CEntity::RegisterReference(pTowel, &this->m_pTowel);
    this->m_pTowel->ObjectCreatedBy = 5;
  }
  this->m_pBeachAnimBlock = CAnimManager::GetAnimationBlock("beach");
  this->m_BeachAnimBlockIndex = CAnimManager::GetAnimationBlockIndex("beach");
  this->m_pSunbatheAnimBlock = CAnimManager::GetAnimationBlock("sunbathe");
  this->m_SunbatheAnimBlockIndex = CAnimManager::GetAnimationBlockIndex("sunbathe");
}
// 66A0B4: using guessed type void *;

//----- (004ED1E4) --------------------------------------------------------
void __fastcall CTaskComplexSunbathe::~CTaskComplexSunbathe(CTaskComplexSunbathe *this)
{
  CObject *m_pTowel; // r0
  CEntity **p_m_pTowel; // r5

  p_m_pTowel = &this->m_pTowel;
  m_pTowel = this->m_pTowel;
  this->_vptr$CTask = (int (**)(void))&off_66A0B4;
  if ( m_pTowel )
  {
    CEntity::CleanUpOldReference(m_pTowel, p_m_pTowel);
    LOBYTE((*p_m_pTowel)[5].m_pMat) = 3;
  }
  if ( this->m_bBeachAnimsReferenced )
  {
    CAnimManager::RemoveAnimBlockRef(this->m_BeachAnimBlockIndex);
    this->m_bBeachAnimsReferenced = 0;
  }
  if ( this->m_bSunbatheAnimsReferenced )
  {
    CAnimManager::RemoveAnimBlockRef(this->m_SunbatheAnimBlockIndex);
    this->m_bSunbatheAnimsReferenced = 0;
  }
  sub_18EDB4(this);
}
// 66A0B4: using guessed type void *off_66A0B4;

//----- (004ED234) --------------------------------------------------------
void __fastcall CTaskComplexSunbathe::~CTaskComplexSunbathe(CTaskComplexSunbathe *this)
{
  CObject *m_pTowel; // r0
  CEntity **p_m_pTowel; // r5
  void *v4; // r0

  p_m_pTowel = &this->m_pTowel;
  m_pTowel = this->m_pTowel;
  this->_vptr$CTask = (int (**)(void))&off_66A0B4;
  if ( m_pTowel )
  {
    CEntity::CleanUpOldReference(m_pTowel, p_m_pTowel);
    LOBYTE((*p_m_pTowel)[5].m_pMat) = 3;
  }
  if ( this->m_bBeachAnimsReferenced )
  {
    CAnimManager::RemoveAnimBlockRef(this->m_BeachAnimBlockIndex);
    this->m_bBeachAnimsReferenced = 0;
  }
  if ( this->m_bSunbatheAnimsReferenced )
  {
    CAnimManager::RemoveAnimBlockRef(this->m_SunbatheAnimBlockIndex);
    this->m_bSunbatheAnimsReferenced = 0;
  }
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 4ED280: variable 'v4' is possibly undefined
// 66A0B4: using guessed type void *off_66A0B4;

//----- (004ED288) --------------------------------------------------------
bool __fastcall CTaskComplexSunbathe::MakeAbortable(
        CTaskComplexSunbathe *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  bool result; // r0

  if ( pEvent
    && ((*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 2
     || (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 3)
    || (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
        + 7))(
         this->m_pSubTask,
         pPed,
         iPriority,
         pEvent) != 1 )
  {
    return 0;
  }
  result = 1;
  this->m_bAborted = 1;
  return result;
}

//----- (004ED2D8) --------------------------------------------------------
CTask *__fastcall CTaskComplexSunbathe::CreateNextSubTask(CTaskComplexSunbathe *this, CPed *pPed)
{
  int32 m_nPedType; // r0
  bool v4; // zf
  int v5; // r1
  CPed *v6; // r2
  CTask *result; // r0
  unsigned int v8; // r0
  int m_iStartTime; // r1
  CPlayerPed *v10; // r1
  float *m_pMyVehicle; // r0
  bool v12; // zf
  CTask *v13; // r0
  int v14; // r5
  unsigned __int16 v15; // r0
  CPed *v16; // r2
  CTaskComplexSunbathe *v17; // r0
  int v18; // r1
  CTask *v19; // r0
  bool v20; // zf
  CTask *v21; // r0
  CTaskComplexSunbathe::eSunbatherType v22; // r4
  CTaskSimpleRunAnim *v23; // r0
  AnimationId v24; // r2
  CTask *v25; // r0
  CTaskComplexSunbathe::eSunbatherType m_SunbatherType; // r1
  CTask *v27; // r0
  int v28; // r4
  CTask *m_pSubTask; // r0
  CTaskComplexSunbathe::eSunbatherType v30; // r4
  CTaskSimpleRunAnim *v31; // r0
  int iTaskType; // [sp+0h] [bp-18h]
  const char *v33; // [sp+4h] [bp-14h]
  bool bHoldLastFrame; // [sp+8h] [bp-10h]

  m_nPedType = pPed->m_nPedType;
  v4 = m_nPedType == 22;
  if ( m_nPedType != 22 )
    v4 = m_nPedType == 5;
  if ( v4 )
    CInterestingEvents::Add(&g_InterestingEvents, EPedSunbathing, pPed);
  v5 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  v6 = (CPed *)(v5 - 418);
  result = 0;
  switch ( v5 )
  {
    case 418:
      if ( !this->m_pSunbatheAnimBlock->m_loaded )
      {
        v17 = this;
        v18 = 202;
        return CTaskComplexSunbathe::CreateSubTask(v17, v18, v6);
      }
      if ( (unsigned __int8)(CClock::ms_nGameClockHours - 10) > 7u
        || (unsigned __int16)CWeather::NewWeatherType > 0x12u
        || ((1 << CWeather::NewWeatherType) & 0x66C6F) == 0
        || this->m_BathingTimer.m_bIsActive
        && (!this->m_BathingTimer.m_bIsStopped ? (m_iStartTime = this->m_BathingTimer.m_iStartTime,
                                                  v8 = CTimer::m_snTimeInMilliseconds) : (v8 = CTimer::m_snTimeInMilliseconds,
                                                                                          this->m_BathingTimer.m_bIsStopped = 0,
                                                                                          this->m_BathingTimer.m_iStartTime = v8,
                                                                                          m_iStartTime = v8),
            m_iStartTime + this->m_BathingTimer.m_iDuration <= v8)
        || (m_SunbatherType = this->m_SunbatherType, (m_SunbatherType | 2) != 2) )
      {
        m_pSubTask = this->m_pSubTask;
        if ( !m_pSubTask || (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) != 430 )
          goto LABEL_58;
        return this->m_pSubTask;
      }
      v27 = this->m_pSubTask;
      if ( v27 )
      {
        if ( (*((int (__fastcall **)(CTask *))v27->_vptr$CTask + 5))(v27) == 429 )
          return this->m_pSubTask;
        m_SunbatherType = this->m_SunbatherType;
      }
      if ( m_SunbatherType == SUNBATHER_FEMALE_1 )
      {
        v28 = 257;
      }
      else
      {
        if ( m_SunbatherType )
          goto LABEL_62;
        v28 = 254;
      }
      this = (CTaskComplexSunbathe *)(v28 + (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 3.0));
LABEL_62:
      v31 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        v31,
        ANIM_SUNBATHE_PED,
        (const AnimationId)this,
        4.0,
        429,
        "idle sunbathing",
        1);
      return result;
    case 419:
    case 420:
    case 421:
    case 422:
    case 423:
    case 424:
    case 425:
    case 426:
    case 427:
      return result;
    case 428:
      if ( !this->m_pBeachAnimBlock->m_loaded )
        goto LABEL_43;
      v14 = CTimer::m_snTimeInMilliseconds;
      v15 = rand();
      this->m_BathingTimer.m_iStartTime = v14;
      this->m_BathingTimer.m_bIsActive = 1;
      this->m_BathingTimer.m_iDuration = (int)(float)((float)((float)v15 * 0.000015259) * 80000.0) + 20000;
      result = CTaskComplexSunbathe::CreateSubTask(this, 418, v16);
      this->m_bBathing = 1;
      return result;
    case 429:
      if ( !this->m_pBeachAnimBlock->m_loaded )
        goto LABEL_43;
      v17 = this;
      v18 = 418;
      return CTaskComplexSunbathe::CreateSubTask(v17, v18, v6);
    case 430:
      v19 = this->m_pSubTask;
      if ( v19 )
      {
        if ( (*((int (__fastcall **)(CTask *))v19->_vptr$CTask + 5))(v19) == 1302 )
          result = this->m_pSubTask;
        else
          result = 0;
      }
      else
      {
        result = 0;
      }
      this->m_bBathing = 0;
      return result;
    default:
      if ( v5 != 202 )
        return result;
      if ( this->m_bBathing )
      {
        v10 = CWorld::Players[CWorld::PlayerInFocus].pPed;
        m_pMyVehicle = (float *)v10->m_pMyVehicle;
        v12 = m_pMyVehicle == 0;
        if ( m_pMyVehicle )
          v12 = (*(_DWORD *)&v10->m_nPedFlags & 0x100) == 0;
        if ( (v12
           || (float)((float)((float)(m_pMyVehicle[18] * m_pMyVehicle[18]) + (float)(m_pMyVehicle[19] * m_pMyVehicle[19]))
                    + (float)(m_pMyVehicle[20] * m_pMyVehicle[20])) <= 0.04)
          && this->m_pSunbatheAnimBlock->m_loaded )
        {
          v13 = this->m_pSubTask;
          if ( !v13 || (*((int (__fastcall **)(CTask *))v13->_vptr$CTask + 5))(v13) != 430 )
          {
LABEL_58:
            v30 = this->m_SunbatherType;
            v23 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
            iTaskType = 430;
            v33 = "stop sunbathing";
            bHoldLastFrame = 0;
            v24 = v30 + 249;
            goto LABEL_59;
          }
          return this->m_pSubTask;
        }
LABEL_43:
        v25 = this->m_pSubTask;
        if ( !v25 || (*((int (__fastcall **)(CTask *))v25->_vptr$CTask + 5))(v25) != 1302 )
          return 0;
        return this->m_pSubTask;
      }
      v20 = !this->m_pSunbatheAnimBlock->m_loaded;
      if ( this->m_pSunbatheAnimBlock->m_loaded )
        v20 = !this->m_pBeachAnimBlock->m_loaded;
      if ( v20 )
        goto LABEL_43;
      v21 = this->m_pSubTask;
      if ( v21 && (*((int (__fastcall **)(CTask *))v21->_vptr$CTask + 5))(v21) == 428 )
        return this->m_pSubTask;
      v22 = this->m_SunbatherType;
      v23 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
      iTaskType = 428;
      v33 = "start sunbathing";
      bHoldLastFrame = 1;
      v24 = v22 + 244;
LABEL_59:
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        v23,
        ANIM_SUNBATHE_PED,
        v24,
        4.0,
        iTaskType,
        (const unsigned __int8 *)v33,
        bHoldLastFrame);
      return result;
  }
}
// 4ED458: variable 'v16' is possibly undefined

//----- (004ED5F4) --------------------------------------------------------
bool __fastcall CTaskComplexSunbathe::ShouldLoadSunbatheAnims(CTaskComplexSunbathe *this)
{
  CPlayerPed *pPed; // r1
  float *m_pMyVehicle; // r0
  bool v3; // zf

  pPed = CWorld::Players[CWorld::PlayerInFocus].pPed;
  m_pMyVehicle = (float *)pPed->m_pMyVehicle;
  v3 = m_pMyVehicle == 0;
  if ( m_pMyVehicle )
    v3 = (*(_DWORD *)&pPed->m_nPedFlags & 0x100) == 0;
  return v3
      || (float)((float)((float)(m_pMyVehicle[18] * m_pMyVehicle[18]) + (float)(m_pMyVehicle[19] * m_pMyVehicle[19]))
               + (float)(m_pMyVehicle[20] * m_pMyVehicle[20])) <= 0.04;
}

//----- (004ED660) --------------------------------------------------------
CTask *__fastcall CTaskComplexSunbathe::CreateSubTask(CTaskComplexSunbathe *this, const int iSubTaskType, CPed *pPed)
{
  CTaskComplexSunbathe *v3; // r5
  CTask *m_pSubTask; // r0
  CTaskSimpleRunTimedAnim *v6; // r4
  CTaskComplexSunbathe::eSunbatherType m_SunbatherType; // r0
  AnimationId v8; // r6
  int v9; // r1
  float v10; // s16
  unsigned __int16 v11; // r5
  CTaskComplexSunbathe::eSunbatherType v12; // r5
  bool bHoldLastFrame; // r1
  AnimationId v14; // r2
  CTaskComplexSunbathe::eSunbatherType v15; // r0
  int v16; // r4
  CTaskComplexSunbathe::eSunbatherType v17; // r5
  int v18; // r5
  CPlayerPed *v19; // r1
  float *m_pMyVehicle; // r0
  bool v21; // zf
  int iTaskType; // [sp+0h] [bp-30h]
  const char *v24; // [sp+4h] [bp-2Ch]

  v3 = this;
  m_pSubTask = this->m_pSubTask;
  if ( m_pSubTask && (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) == iSubTaskType )
    return v3->m_pSubTask;
  v6 = 0;
  switch ( iSubTaskType )
  {
    case 418:
      m_SunbatherType = v3->m_SunbatherType;
      v8 = m_SunbatherType + 239;
      if ( v3->m_pSunbatheAnimBlock->m_loaded && (m_SunbatherType | 2) == 2 )
      {
        if ( v3->m_BathingTimer.m_bIsActive )
        {
          v9 = v3->m_BathingTimer.m_iStartTime + v3->m_BathingTimer.m_iDuration;
          if ( (int)(v9 - CTimer::m_snTimeInMilliseconds) <= 11000 )
            v10 = (float)(int)(v9 + 1000 - CTimer::m_snTimeInMilliseconds - 3000);
          else
            v10 = 9000.0;
        }
        else
        {
          v10 = -2000.0;
        }
        v18 = (int)(float)(v10 * (float)((float)(unsigned __int16)rand() * 0.000015259)) + 3000;
      }
      else if ( v3->m_BathingTimer.m_bIsActive )
      {
        v18 = v3->m_BathingTimer.m_iStartTime + v3->m_BathingTimer.m_iDuration + 1000 - CTimer::m_snTimeInMilliseconds;
      }
      else
      {
        v18 = 1000;
      }
      v6 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x34u);
      CTaskSimpleRunTimedAnim::CTaskSimpleRunTimedAnim(v6, ANIM_BEACH_PED, v8, 4.0, -4.0, v18, 418, "sunbathe", 1);
      return v6;
    case 419:
    case 420:
    case 421:
    case 422:
    case 423:
    case 424:
    case 425:
    case 426:
    case 427:
      return v6;
    case 428:
      v12 = v3->m_SunbatherType;
      v6 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x20u);
      bHoldLastFrame = 1;
      iTaskType = 428;
      v24 = "start sunbathing";
      v14 = v12 + 244;
      goto LABEL_19;
    case 429:
      v15 = v3->m_SunbatherType;
      if ( v15 == SUNBATHER_FEMALE_1 )
      {
        v16 = 257;
      }
      else
      {
        if ( v15 )
          goto LABEL_24;
        v16 = 254;
      }
      v3 = (CTaskComplexSunbathe *)(v16 + (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 3.0));
LABEL_24:
      v6 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        (CTaskSimpleRunAnim *)v6,
        ANIM_SUNBATHE_PED,
        (const AnimationId)v3,
        4.0,
        429,
        "idle sunbathing",
        1);
      break;
    case 430:
      v17 = v3->m_SunbatherType;
      v6 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x20u);
      bHoldLastFrame = 0;
      iTaskType = 430;
      v24 = "stop sunbathing";
      v14 = v17 + 249;
LABEL_19:
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        (CTaskSimpleRunAnim *)v6,
        ANIM_SUNBATHE_PED,
        v14,
        4.0,
        iTaskType,
        (const unsigned __int8 *)v24,
        bHoldLastFrame);
      return v6;
    default:
      if ( iSubTaskType == 202 )
      {
        if ( !v3->m_pSunbatheAnimBlock->m_loaded )
        {
          v19 = CWorld::Players[CWorld::PlayerInFocus].pPed;
          m_pMyVehicle = (float *)v19->m_pMyVehicle;
          v21 = m_pMyVehicle == 0;
          if ( m_pMyVehicle )
            v21 = (*(_DWORD *)&v19->m_nPedFlags & 0x100) == 0;
          if ( v21
            || (float)((float)((float)(m_pMyVehicle[18] * m_pMyVehicle[18])
                             + (float)(m_pMyVehicle[19] * m_pMyVehicle[19]))
                     + (float)(m_pMyVehicle[20] * m_pMyVehicle[20])) <= 0.04 )
          {
            goto LABEL_30;
          }
        }
        if ( v3->m_pBeachAnimBlock->m_loaded )
        {
          v6 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x18u);
          v11 = rand();
          CTaskSimple::CTaskSimple(v6);
          LOWORD(v6->m_animGroup) = 0;
          v6->_vptr$CTask = (int (**)(void))&off_665750;
          v6->m_pAnim = 0;
          *((_DWORD *)&v6->CTaskSimpleAnim + 3) = 0;
          v6->m_animID = (int)(float)((float)((float)v11 * 0.000015259) * 4000.0) + 1000;
        }
        else
        {
LABEL_30:
          v6 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x18u);
          CTaskSimple::CTaskSimple(v6);
          LOWORD(v6->m_animGroup) = 0;
          v6->m_animID = 10000;
          v6->m_pAnim = 0;
          *((_DWORD *)&v6->CTaskSimpleAnim + 3) = 0;
          v6->_vptr$CTask = (int (**)(void))&off_665750;
        }
      }
      return v6;
  }
  return v6;
}
// 665750: using guessed type void *off_665750;

//----- (004ED954) --------------------------------------------------------
unsigned int CTaskComplexSunbathe::CanSunbathe()
{
  if ( (unsigned __int8)(CClock::ms_nGameClockHours - 10) > 7u || (unsigned __int16)CWeather::NewWeatherType > 0x12u )
    return 0;
  else
    return (0x66C6Fu >> CWeather::NewWeatherType) & 1;
}

//----- (004ED990) --------------------------------------------------------
CTask *__fastcall CTaskComplexSunbathe::CreateFirstSubTask(CTaskComplexSunbathe *this, CPed *pPed)
{
  int v4; // r0
  CAnimBlock *m_pBeachAnimBlock; // r1
  CPed *v6; // r2
  CPlayerPed *v7; // r1
  float *m_pMyVehicle; // r0
  bool v9; // zf
  CTask *result; // r0
  CTask *m_pSubTask; // r0
  int v12; // r5
  unsigned __int16 v13; // r0
  CTaskComplexSunbathe *v14; // r0
  int v15; // r1
  CTaskComplexSunbathe::eSunbatherType m_SunbatherType; // r4
  CTaskSimpleRunAnim *v17; // r0

  rand();
  if ( pPed->m_nPedType == 5 )
  {
    v4 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 3.0) + 2;
  }
  else if ( CPopulation::IsSunbather(pPed->m_nModelIndex) )
  {
    v4 = rand() & 1;
  }
  else
  {
    v4 = 1;
  }
  m_pBeachAnimBlock = this->m_pBeachAnimBlock;
  this->m_SunbatherType = v4;
  if ( !m_pBeachAnimBlock->m_loaded )
    CStreaming::RequestModel(this->m_BeachAnimBlockIndex + 25575, 8);
  if ( !this->m_pSunbatheAnimBlock->m_loaded )
    CStreaming::RequestModel(this->m_SunbatheAnimBlockIndex + 25575, 8);
  this->m_bBathing = 0;
  v6 = (CPed *)(elf_hash_bucket + 152);
  v7 = CWorld::Players[CWorld::PlayerInFocus].pPed;
  m_pMyVehicle = (float *)v7->m_pMyVehicle;
  v9 = m_pMyVehicle == 0;
  if ( m_pMyVehicle )
    v9 = (*(_DWORD *)&v7->m_nPedFlags & 0x100) == 0;
  if ( !v9
    && (float)((float)((float)(m_pMyVehicle[18] * m_pMyVehicle[18]) + (float)(m_pMyVehicle[19] * m_pMyVehicle[19]))
             + (float)(m_pMyVehicle[20] * m_pMyVehicle[20])) > 0.04 )
  {
    if ( !this->m_pBeachAnimBlock->m_loaded )
      return 0;
    goto LABEL_23;
  }
  if ( !this->m_bStartStanding )
  {
    if ( this->m_pBeachAnimBlock->m_loaded )
    {
LABEL_23:
      v12 = CTimer::m_snTimeInMilliseconds;
      v13 = rand();
      this->m_BathingTimer.m_iStartTime = v12;
      this->m_BathingTimer.m_bIsActive = 1;
      this->m_bBathing = 1;
      this->m_BathingTimer.m_iDuration = (int)(float)((float)((float)v13 * 0.000015259) * 80000.0) + 20000;
      v14 = this;
      v15 = 418;
      return CTaskComplexSunbathe::CreateSubTask(v14, v15, v6);
    }
LABEL_24:
    v14 = this;
    v15 = 202;
    return CTaskComplexSunbathe::CreateSubTask(v14, v15, v6);
  }
  if ( this->m_pTowel || !this->m_pSunbatheAnimBlock->m_loaded )
    goto LABEL_24;
  m_pSubTask = this->m_pSubTask;
  if ( m_pSubTask && (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) == 428 )
    return this->m_pSubTask;
  m_SunbatherType = this->m_SunbatherType;
  v17 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
  CTaskSimpleRunAnim::CTaskSimpleRunAnim(
    v17,
    ANIM_SUNBATHE_PED,
    (const AnimationId)(m_SunbatherType + 244),
    4.0,
    428,
    "start sunbathing",
    1);
  return result;
}
// 4EDAF4: variable 'v6' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];

//----- (004EDB3C) --------------------------------------------------------
CTask *__fastcall CTaskComplexSunbathe::ControlSubTask(CTaskComplexSunbathe *this, CPed *pPed)
{
  int32 m_BeachAnimBlockIndex; // r0
  CPlayerPed *v6; // r1
  float *m_pMyVehicle; // r0
  bool v8; // zf
  int32 m_SunbatheAnimBlockIndex; // r0
  int v10; // r0
  __int64 v11; // kr00_8

  if ( this->m_bAborted )
    return 0;
  if ( !this->m_bBeachAnimsReferenced )
  {
    m_BeachAnimBlockIndex = this->m_BeachAnimBlockIndex;
    if ( this->m_pBeachAnimBlock->m_loaded )
    {
      CAnimManager::AddAnimBlockRef(m_BeachAnimBlockIndex);
      this->m_bBeachAnimsReferenced = 1;
    }
    else
    {
      CStreaming::RequestModel(m_BeachAnimBlockIndex + 25575, 8);
    }
  }
  if ( !this->m_bSunbatheAnimsReferenced )
  {
    v6 = CWorld::Players[CWorld::PlayerInFocus].pPed;
    m_pMyVehicle = (float *)v6->m_pMyVehicle;
    v8 = m_pMyVehicle == 0;
    if ( m_pMyVehicle )
      v8 = (*(_DWORD *)&v6->m_nPedFlags & 0x100) == 0;
    if ( v8
      || (float)((float)((float)(m_pMyVehicle[18] * m_pMyVehicle[18]) + (float)(m_pMyVehicle[19] * m_pMyVehicle[19]))
               + (float)(m_pMyVehicle[20] * m_pMyVehicle[20])) <= 0.04 )
    {
      m_SunbatheAnimBlockIndex = this->m_SunbatheAnimBlockIndex;
      if ( this->m_pSunbatheAnimBlock->m_loaded )
      {
        CAnimManager::AddAnimBlockRef(m_SunbatheAnimBlockIndex);
        this->m_bSunbatheAnimsReferenced = 1;
      }
      else
      {
        CStreaming::RequestModel(m_SunbatheAnimBlockIndex + 25575, 8);
      }
    }
  }
  if ( this->m_bBathing )
  {
    v10 = *((_DWORD *)&pPed->m_nPedFlags + 2);
    pPed->m_ik.m_flags |= 8u;
    *((_DWORD *)&pPed->m_nPedFlags + 2) = v10 | 0x100000;
  }
  if ( (unsigned __int8)(CClock::ms_nGameClockHours - 10) > 7u
    || (unsigned __int16)CWeather::NewWeatherType > 0x12u
    || ((1 << CWeather::NewWeatherType) & 0x66C6F) == 0 )
  {
    if ( this->m_BathingTimer.m_bIsActive )
    {
      v11 = *(_QWORD *)&this->m_BathingTimer.m_iStartTime;
      this->m_BathingTimer.m_bIsStopped = 1;
      this->m_BathingTimer.m_iDuration = HIDWORD(v11) - CTimer::m_snTimeInMilliseconds + v11;
    }
    if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 418 )
      (*((void (__fastcall **)(CTask *, CPed *, _DWORD, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
        this->m_pSubTask,
        pPed,
        0,
        0);
  }
  return this->m_pSubTask;
}

//----- (004EDC8C) --------------------------------------------------------
void __fastcall CTaskComplexUseEffect::CTaskComplexUseEffect(
        CTaskComplexUseEffect *this,
        C2dEffect *pEffect,
        CEntity *pEntity)
{
  CTaskComplex::CTaskComplex(this);
  this->m_pEffect = pEffect;
  this->m_pAttractor = 0;
  this->m_pPed = 0;
  this->m_iMoveState = 4;
  this->m_bAbort = 0;
  this->_vptr$CTask = (int (**)(void))&off_66A0F0;
  this->m_pEntity = pEntity;
  if ( pEntity )
    CEntity::RegisterReference(pEntity, &this->m_pEntity);
}
// 66A0F0: using guessed type void *;

//----- (004EDCD8) --------------------------------------------------------
void __fastcall CTaskComplexUseEffect::~CTaskComplexUseEffect(CTaskComplexUseEffect *this)
{
  CPed *m_pPed; // r1
  bool v3; // zf
  CPedAttractorManager *PedAttractorManager; // r0
  CEntity *m_pEntity; // r0
  void *v6; // r0

  m_pPed = this->m_pPed;
  v3 = m_pPed == 0;
  this->_vptr$CTask = (int (**)(void))&off_66A0F0;
  if ( m_pPed )
    v3 = this->m_pAttractor == 0;
  if ( !v3 )
  {
    PedAttractorManager = GetPedAttractorManager();
    CPedAttractorManager::DeRegisterPed(PedAttractorManager, this->m_pPed, this->m_pAttractor);
  }
  m_pEntity = this->m_pEntity;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, &this->m_pEntity);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v6);
}
// 4EDD1A: variable 'v6' is possibly undefined
// 66A0F0: using guessed type void *off_66A0F0;

//----- (004EDD24) --------------------------------------------------------
bool __fastcall CTaskComplexUseEffect::MakeAbortable(
        CTaskComplexUseEffect *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  bool v7; // r5
  CPedAttractorManager *PedAttractorManager; // r0
  CTask *m_pSubTask; // r5
  CMatrix *m_pMat; // r0
  float v11; // s0
  CSimpleTransform *p_tx; // r1
  float v13; // s2
  int m_iAccumulatedTime; // r0
  int v15; // r1
  float *v16; // r2

  v7 = 0;
  if ( (*((int (__fastcall **)(CTask *, CPed *, const int))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
         this->m_pSubTask,
         pPed,
         iPriority) == 1 )
  {
    PedAttractorManager = GetPedAttractorManager();
    CPedAttractorManager::DeRegisterPed(PedAttractorManager, pPed, this->m_pAttractor);
    this->m_pAttractor = 0;
    this->m_pPed = 0;
    if ( !pEvent )
      return 1;
    if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 915 )
      return 1;
    m_pSubTask = this->m_pSubTask;
    if ( ((*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) | 1) != 3 )
      return 1;
    m_pMat = pPed->m_pMat;
    v11 = *(float *)&m_pSubTask[2]._vptr$CTask;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    v13 = *(float *)&m_pSubTask[2].m_pParent;
    if ( !m_pMat )
      p_tx = &pPed->m_transform;
    if ( (float)((float)((float)((float)(p_tx->m_translate.x - v11) * (float)(p_tx->m_translate.x - v11))
                       + (float)((float)(p_tx->m_translate.y - v13) * (float)(p_tx->m_translate.y - v13)))
               + 0.0) >= 2.25 )
      return 1;
    m_iAccumulatedTime = pEvent[1].m_iAccumulatedTime;
    if ( !m_iAccumulatedTime )
      return 1;
    v15 = *(_DWORD *)(m_iAccumulatedTime + 20);
    v16 = (float *)(v15 + 48);
    if ( !v15 )
      v16 = (float *)(m_iAccumulatedTime + 4);
    if ( (float)((float)((float)((float)(*v16 - v11) * (float)(*v16 - v11))
                       + (float)((float)(v16[1] - v13) * (float)(v16[1] - v13)))
               + 0.0) < 2.25 )
    {
      v7 = 1;
      if ( *(_DWORD *)(m_iAccumulatedTime + 1104) == 1 )
        this->m_bAbort = 1;
    }
    else
    {
      return 1;
    }
  }
  return v7;
}

//----- (004EDE1C) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseEffect::CreateNextSubTask(CTaskComplexUseEffect *this, CPed *pPed)
{
  const CPedAttractorManager *PedAttractorManager; // r0
  const CPedAttractor *RelevantAttractor; // r0

  if ( this->m_pAttractor
    && (PedAttractorManager = GetPedAttractorManager(),
        RelevantAttractor = CPedAttractorManager::GetRelevantAttractor(
                              PedAttractorManager,
                              pPed,
                              this->m_pEffect,
                              this->m_pEntity),
        RelevantAttractor == this->m_pAttractor) )
  {
    return sub_19DBB8(RelevantAttractor, pPed);
  }
  else
  {
    return 0;
  }
}

//----- (004EDE4C) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseEffect::CreateFirstSubTask(CTaskComplexUseEffect *this, CPed *pPed)
{
  CPed *m_pPed; // r0
  CEntity **p_m_pPed; // r6
  CTaskSimple *v6; // r0
  CTask *result; // r0
  CPedAttractorManager *PedAttractorManager; // r0
  C2dEffect *m_pEffect; // r2
  CEntity *m_pEntity; // r3
  CPedAttractor *v11; // r0
  CEntity *v12; // r6

  p_m_pPed = &this->m_pPed;
  m_pPed = this->m_pPed;
  if ( m_pPed )
    CEntity::CleanUpOldReference(m_pPed, p_m_pPed);
  *p_m_pPed = pPed;
  if ( pPed )
    CEntity::RegisterReference(pPed, p_m_pPed);
  if ( this->m_bAbort )
    goto LABEL_6;
  if ( this->m_pEntity )
  {
    PedAttractorManager = GetPedAttractorManager();
    m_pEffect = this->m_pEffect;
LABEL_10:
    m_pEntity = this->m_pEntity;
    goto LABEL_11;
  }
  if ( CScripted2dEffects::GetIndex(this->m_pEffect) < 0 )
  {
LABEL_6:
    this->m_pAttractor = 0;
LABEL_7:
    v6 = (CTaskSimple *)CTask::operator new(8u);
    CTaskSimple::CTaskSimple(v6);
    result->_vptr$CTask = (int (**)(void))&off_668FF0;
    return result;
  }
  v12 = this->m_pEntity;
  PedAttractorManager = GetPedAttractorManager();
  m_pEffect = this->m_pEffect;
  if ( v12 )
    goto LABEL_10;
  m_pEntity = 0;
LABEL_11:
  v11 = CPedAttractorManager::RegisterPedWithAttractor(
          PedAttractorManager,
          pPed,
          m_pEffect,
          m_pEntity,
          this->m_iMoveState);
  this->m_pAttractor = v11;
  if ( !v11 )
    goto LABEL_7;
  return sub_19DBB8(v11, pPed);
}
// 4EDE94: variable 'result' is possibly undefined
// 668FF0: using guessed type void *off_668FF0;
// 678150: using guessed type void *`vtable for'CTaskSimpleNone;

//----- (004EDEE8) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseEffect::ControlSubTask(CTaskComplexUseEffect *this, CPed *pPed)
{
  CWanted *PlayerWanted; // r0
  CPedAttractorManager *PedAttractorManager; // r0
  CPedAttractor *m_pAttractor; // r0

  if ( pPed->m_nPedType == 6
    && FindPlayerWanted(-1)->m_WantedLevel
    && (PlayerWanted = FindPlayerWanted(-1), CWanted::CanCopJoinPursuit(PlayerWanted, (CCopPed *)pPed))
    && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
         this->m_pSubTask,
         pPed,
         1,
         0) )
  {
    PedAttractorManager = GetPedAttractorManager();
    CPedAttractorManager::DeRegisterPed(PedAttractorManager, pPed, this->m_pAttractor);
    return 0;
  }
  else
  {
    m_pAttractor = this->m_pAttractor;
    if ( m_pAttractor )
      return sub_19DBB8(m_pAttractor, pPed);
    else
      return (CTask *)(*((int (__fastcall **)(CTaskComplexUseEffect *, CPed *))this->_vptr$CTask + 11))(this, pPed);
  }
}

//----- (004EDF54) --------------------------------------------------------
void __fastcall CTaskComplexWaitAtAttractor::CTaskComplexWaitAtAttractor(
        CTaskComplexWaitAtAttractor *this,
        CPedAttractor *pAttractor,
        const int iSlot)
{
  _DWORD *v5; // r0

  CTaskComplex::CTaskComplex(this);
  v5[3] = pAttractor;
  v5[4] = iSlot;
  *v5 = &off_66A12C;
}
// 4EDF62: variable 'v5' is possibly undefined
// 66A12C: using guessed type void *;

//----- (004EDF78) --------------------------------------------------------
void __fastcall CTaskComplexWaitAtAttractor::~CTaskComplexWaitAtAttractor(CTaskComplexWaitAtAttractor *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 4EDF84: variable 'v1' is possibly undefined

//----- (004EDF88) --------------------------------------------------------
CTask *__fastcall CTaskComplexWaitAtAttractor::CreateNextSubTask(CTaskComplexWaitAtAttractor *this, CPed *pPed)
{
  return 0;
}

//----- (004EDF8C) --------------------------------------------------------
CTask *__fastcall CTaskComplexWaitAtAttractor::CreateFirstSubTask(CTaskComplexWaitAtAttractor *this, CPed *pPed)
{
  CTaskSimple *v2; // r0
  CTask *result; // r0

  v2 = (CTaskSimple *)CTask::operator new(0x20u);
  CTaskSimple::CTaskSimple(v2);
  result[1]._vptr$CTask = (int (**)(void))(elf_hash_bucket + 9748);
  LOWORD(result[2].m_pParent) = 0;
  result[3].m_pParent = (CTask *)1090519040;
  LOWORD(result[3]._vptr$CTask) = 0;
  result[1].m_pParent = 0;
  result[2]._vptr$CTask = 0;
  result->_vptr$CTask = (int (**)(void))&off_669BFC;
  return result;
}
// 4EDFA0: variable 'result' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 669BFC: using guessed type void *off_669BFC;

//----- (004EDFC0) --------------------------------------------------------
CTask *__fastcall CTaskComplexWaitAtAttractor::ControlSubTask(CTaskComplexWaitAtAttractor *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (004EDFC4) --------------------------------------------------------
void __fastcall CTaskComplexUseAttractor::CTaskComplexUseAttractor(
        CTaskComplexUseAttractor *this,
        CPedAttractor *pAttractor)
{
  _DWORD *v3; // r0

  CTaskComplex::CTaskComplex(this);
  v3[3] = pAttractor;
  *v3 = &off_66A168;
}
// 4EDFD0: variable 'v3' is possibly undefined
// 66A168: using guessed type void *;

//----- (004EDFE4) --------------------------------------------------------
void __fastcall CTaskComplexUseAttractor::~CTaskComplexUseAttractor(CTaskComplexUseAttractor *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 4EDFF0: variable 'v1' is possibly undefined

//----- (004EDFF4) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseAttractor::CreateNextSubTask(CTaskComplexUseAttractor *this, CPed *pPed)
{
  int v4; // r0
  UInt16 v5; // r0
  unsigned int m_MoneyCarried; // r0
  CPedAttractorManager *PedAttractorManager; // r0

  v4 = ((int (__fastcall *)(CPedAttractor *))*this->m_pAttractor->_vptr$CPedAttractor)(this->m_pAttractor);
  if ( v4 == 3 )
  {
    m_MoneyCarried = pPed->m_MoneyCarried;
    if ( m_MoneyCarried < 0xB )
      v5 = 0;
    else
      v5 = m_MoneyCarried - 10;
    goto LABEL_7;
  }
  if ( !v4 )
  {
    v5 = pPed->m_MoneyCarried + 20 * (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 50.0) + 20;
LABEL_7:
    pPed->m_MoneyCarried = v5;
  }
  PedAttractorManager = GetPedAttractorManager();
  CPedAttractorManager::BroadcastDeparture(PedAttractorManager, pPed, this->m_pAttractor);
  return 0;
}

//----- (004EE06C) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseAttractor::CreateFirstSubTask(CTaskComplexUseAttractor *this, CPed *pPed)
{
  int v4; // r9
  char *v5; // r6
  void **v6; // r0
  unsigned __int16 v7; // r5
  CPedAttractor *HasAttractorScriptBrainWithThisNameLoaded; // r0
  CEntity *m_pEntity; // r1
  bool v10; // zf
  int v11; // r2
  bool v12; // zf
  CScriptedBrainTaskStoreEntry *v13; // r6
  int v14; // r0
  unsigned __int16 v15; // r5
  CPedAttractor *m_pAttractor; // r5
  CPedAttractorManager *PedAttractorManager; // r0
  int v19; // r5
  int v20; // r10
  char v21; // r1
  CTask *m_pTask; // r1
  CPed *m_pPed; // r0
  CPedAttractor *v24; // r5

  CInterestingEvents::Add(&g_InterestingEvents, EPedUsingAttractor, pPed);
  switch ( ((int (__fastcall *)(CPedAttractor *))*this->m_pAttractor->_vptr$CPedAttractor)(this->m_pAttractor) )
  {
    case 0:
      v5 = (char *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        (CTaskSimpleRunAnim *)v5,
        ANIM_STD_PED,
        ANIM_STD_ATM,
        4.0,
        420,
        "UseAtm",
        0);
      v6 = &`vtable for'CTaskSimpleUseAtm;
      goto LABEL_24;
    case 1:
    case 9:
      if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) <= 40 )
        v4 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 45000.0) + 15000;
      else
        v4 = 9999999;
      v5 = (char *)CTask::operator new(0x14u);
      v19 = ((int (__fastcall *)(CPedAttractor *))*this->m_pAttractor->_vptr$CPedAttractor)(this->m_pAttractor);
      v20 = *((_DWORD *)&pPed->m_nPedFlags + 2);
      CTaskComplex::CTaskComplex((CTaskComplex *)v5);
      v21 = 0;
      *((_DWORD *)v5 + 3) = v4;
      *(_DWORD *)v5 = &off_669F18;
      if ( v19 == 9 )
        v21 = 1;
      v5[16] = v21;
      v5[17] = (v20 & 0x200000) != 0;
      v5[18] = 0;
      if ( !v5 )
        goto LABEL_25;
      goto LABEL_26;
    case 2:
      v5 = (char *)CTask::operator new(0x10u);
      CTaskComplex::CTaskComplex((CTaskComplex *)v5);
      *((_DWORD *)v5 + 3) = 0;
      v6 = &`vtable for'CTaskComplexWaitForBus;
      goto LABEL_24;
    case 3:
      v7 = rand();
      v5 = (char *)CTask::operator new(0x20u);
      CTaskSimple::CTaskSimple((CTaskSimple *)v5);
      *(_DWORD *)v5 = &off_669BFC;
      *((_WORD *)v5 + 10) = 0;
      *((_DWORD *)v5 + 7) = 1090519040;
      *((_WORD *)v5 + 12) = 0;
      *((_DWORD *)v5 + 4) = 0;
      *((_DWORD *)v5 + 3) = 0;
      *((_DWORD *)v5 + 2) = (int)(float)((float)((float)v7 * 0.000015259) * 6000.0) + 6000;
      if ( !v5 )
        goto LABEL_25;
      goto LABEL_26;
    case 4:
      v5 = (char *)CTask::operator new(0xCu);
      CTaskComplex::CTaskComplex((CTaskComplex *)v5);
      v6 = &`vtable for'CTaskComplexWaitForDryWeather;
      goto LABEL_24;
    case 5:
      if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 10) >> 7 )
        goto LABEL_25;
      HasAttractorScriptBrainWithThisNameLoaded = (CPedAttractor *)CScriptsForBrains::HasAttractorScriptBrainWithThisNameLoaded(
                                                                     &CTheScripts::ScriptsForBrains,
                                                                     this->m_pAttractor->m_scriptName);
      v10 = HasAttractorScriptBrainWithThisNameLoaded == 0;
      if ( HasAttractorScriptBrainWithThisNameLoaded )
      {
        HasAttractorScriptBrainWithThisNameLoaded = this->m_pAttractor;
        m_pEntity = HasAttractorScriptBrainWithThisNameLoaded->m_pEntity;
        v10 = m_pEntity == 0;
      }
      if ( v10 )
        goto LABEL_25;
      v11 = *(_BYTE *)&m_pEntity->m_info & 7;
      v12 = v11 == 4;
      if ( v11 == 4 )
        v12 = HIBYTE(m_pEntity[5].m_pRwObject) << 31 == 0;
      if ( !v12 )
        CScriptsForBrains::StartAttractorScriptBrainWithThisName(
          &CTheScripts::ScriptsForBrains,
          HasAttractorScriptBrainWithThisNameLoaded->m_scriptName,
          pPed,
          (*((_DWORD *)&pPed->m_nPedFlags + 2) & 0x200000) != 0);
      v13 = CScriptedBrainTaskStore::ms_entries;
      v14 = -1;
      break;
    case 6:
      v15 = rand();
      v5 = (char *)CTask::operator new(0x20u);
      CTaskSimple::CTaskSimple((CTaskSimple *)v5);
      *(_DWORD *)v5 = &off_669BFC;
      *((_WORD *)v5 + 10) = 0;
      *((_DWORD *)v5 + 7) = 1090519040;
      *((_WORD *)v5 + 12) = 0;
      *((_DWORD *)v5 + 2) = (int)(float)((float)((float)v15 * 0.000015259) * 3000.0) + 3000;
      *((_DWORD *)v5 + 3) = 0;
      *((_DWORD *)v5 + 4) = 0;
      if ( !v5 )
        goto LABEL_25;
      goto LABEL_26;
    case 7:
      v5 = (char *)CTask::operator new(0x10u);
      m_pAttractor = this->m_pAttractor;
      CTaskComplex::CTaskComplex((CTaskComplex *)v5);
      *((_DWORD *)v5 + 3) = m_pAttractor;
      v6 = &`vtable for'CTaskComplexUseScriptedAttractor;
LABEL_24:
      *(_DWORD *)v5 = (char *)*v6 + 8;
      if ( !v5 )
        goto LABEL_25;
      goto LABEL_26;
    case 8:
      v5 = (char *)CTask::operator new(0x38u);
      CTaskComplex::CTaskComplex((CTaskComplex *)v5);
      v5[12] = 1;
      *((_WORD *)v5 + 14) = 0;
      *(_DWORD *)(v5 + 13) = 0;
      *((_DWORD *)v5 + 13) = 0;
      *((_DWORD *)v5 + 5) = 0;
      *((_DWORD *)v5 + 6) = 0;
      *(_DWORD *)v5 = &off_66A0B4;
      *((_DWORD *)v5 + 9) = CAnimManager::GetAnimationBlock("beach");
      *((_DWORD *)v5 + 11) = CAnimManager::GetAnimationBlockIndex("beach");
      *((_DWORD *)v5 + 10) = CAnimManager::GetAnimationBlock("sunbathe");
      *((_DWORD *)v5 + 12) = CAnimManager::GetAnimationBlockIndex("sunbathe");
      if ( !v5 )
        goto LABEL_25;
      goto LABEL_26;
    default:
      goto LABEL_25;
  }
  while ( v13->m_pPed != pPed )
  {
    ++v14;
    ++v13;
    if ( v14 >= 47 )
      goto LABEL_38;
  }
  m_pTask = v13->m_pTask;
  m_pPed = pPed;
  if ( m_pTask )
  {
    (*((void (__fastcall **)(CTask *))m_pTask->_vptr$CTask + 1))(v13->m_pTask);
    m_pPed = v13->m_pPed;
  }
  v13->m_pTask = 0;
  if ( m_pPed )
  {
    CEntity::CleanUpOldReference(m_pPed, &v13->m_pPed);
    v13->m_pPed = 0;
  }
LABEL_38:
  v5 = (char *)CTask::operator new(0x1Cu);
  v24 = this->m_pAttractor;
  CTaskComplex::CTaskComplex((CTaskComplex *)v5);
  v5[12] = 0;
  *((_DWORD *)v5 + 6) = 0;
  *(_DWORD *)v5 = &off_66A700;
  strcpy(v5 + 13, (const char *)v24->m_scriptName);
  if ( !v5 )
  {
LABEL_25:
    PedAttractorManager = GetPedAttractorManager();
    CPedAttractorManager::BroadcastDeparture(PedAttractorManager, pPed, this->m_pAttractor);
    v5 = 0;
  }
LABEL_26:
  *((_DWORD *)&pPed->m_nPedFlags + 2) &= ~0x200000u;
  return (CTask *)v5;
}
// 4EE1C6: variable 'm_pEntity' is possibly undefined
// 669BFC: using guessed type void *off_669BFC;
// 669F18: using guessed type void *off_669F18;
// 66A0B4: using guessed type void *off_66A0B4;
// 66A700: using guessed type void *;
// 676780: using guessed type void *`vtable for'CTaskComplexWaitForDryWeather;
// 678A54: using guessed type void *`vtable for'CTaskComplexUseScriptedAttractor;
// 6796A8: using guessed type void *`vtable for'CTaskComplexWaitForBus;
// 679BB0: using guessed type void *`vtable for'CTaskSimpleUseAtm;

//----- (004EE424) --------------------------------------------------------
void __fastcall CScriptedBrainTaskStore::Clear(CPed *pPed)
{
  CScriptedBrainTaskStoreEntry *v1; // r4
  int v2; // r1
  CTask *m_pTask; // r1

  v1 = CScriptedBrainTaskStore::ms_entries;
  v2 = -1;
  while ( v1->m_pPed != pPed )
  {
    ++v2;
    ++v1;
    if ( v2 >= 47 )
      return;
  }
  m_pTask = v1->m_pTask;
  if ( m_pTask )
  {
    (*((void (__fastcall **)(CTask *))m_pTask->_vptr$CTask + 1))(v1->m_pTask);
    pPed = v1->m_pPed;
  }
  v1->m_pTask = 0;
  if ( pPed )
  {
    CEntity::CleanUpOldReference(pPed, &v1->m_pPed);
    v1->m_pPed = 0;
  }
}

//----- (004EE468) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseAttractor::ControlSubTask(CTaskComplexUseAttractor *this, CPed *pPed)
{
  CPedAttractor *m_pAttractor; // r0
  bool v4; // zf

  m_pAttractor = this->m_pAttractor;
  v4 = m_pAttractor == 0;
  if ( m_pAttractor )
  {
    m_pAttractor = (CPedAttractor *)m_pAttractor->m_pEntity;
    v4 = m_pAttractor == 0;
  }
  if ( !v4 && (BYTE2(m_pAttractor->m_fAchieveQueueTime) & 7) == 4 && (m_pAttractor[1].m_scriptName[21] & 4) != 0 )
    (*((void (__fastcall **)(CTask *, CPed *, _DWORD, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
      this->m_pSubTask,
      pPed,
      0,
      0);
  return this->m_pSubTask;
}

//----- (004EE4A0) --------------------------------------------------------
void __fastcall CTaskComplexWaitForDryWeather::CTaskComplexWaitForDryWeather(CTaskComplexWaitForDryWeather *this)
{
  _DWORD *v1; // r0

  CTaskComplex::CTaskComplex(this);
  *v1 = &off_66A1A4;
}
// 4EE4B0: variable 'v1' is possibly undefined
// 66A1A4: using guessed type void *off_66A1A4;
// 676780: using guessed type void *`vtable for'CTaskComplexWaitForDryWeather;

//----- (004EE4BC) --------------------------------------------------------
void __fastcall CTaskComplexWaitForDryWeather::~CTaskComplexWaitForDryWeather(CTaskComplexWaitForDryWeather *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 4EE4C8: variable 'v1' is possibly undefined

//----- (004EE4CC) --------------------------------------------------------
CTask *__fastcall CTaskComplexWaitForDryWeather::CreateNextSubTask(CTaskComplexWaitForDryWeather *this, CPed *pPed)
{
  if ( CWeather::Rain >= 0.2 )
    return (CTask *)(*((int (__fastcall **)(CTaskComplexWaitForDryWeather *, CPed *))this->_vptr$CTask + 11))(
                      this,
                      pPed);
  else
    return 0;
}

//----- (004EE4F8) --------------------------------------------------------
CTask *__fastcall CTaskComplexWaitForDryWeather::CreateFirstSubTask(CTaskComplexWaitForDryWeather *this, CPed *pPed)
{
  CTaskSimple *v2; // r0
  CTask *result; // r0

  v2 = (CTaskSimple *)CTask::operator new(0x20u);
  CTaskSimple::CTaskSimple(v2);
  result[1]._vptr$CTask = (int (**)(void))(elf_hash_bucket + 748);
  LOWORD(result[2].m_pParent) = 0;
  result[3].m_pParent = (CTask *)1090519040;
  LOWORD(result[3]._vptr$CTask) = 0;
  result[1].m_pParent = 0;
  result[2]._vptr$CTask = 0;
  result->_vptr$CTask = (int (**)(void))&off_669BFC;
  return result;
}
// 4EE50C: variable 'result' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 669BFC: using guessed type void *off_669BFC;

//----- (004EE52C) --------------------------------------------------------
CTask *__fastcall CTaskComplexWaitForDryWeather::ControlSubTask(CTaskComplexWaitForDryWeather *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (004EE530) --------------------------------------------------------
void __fastcall CTaskComplexWaitForBus::CTaskComplexWaitForBus(CTaskComplexWaitForBus *this)
{
  _DWORD *v1; // r0

  CTaskComplex::CTaskComplex(this);
  v1[3] = 0;
  *v1 = &off_66A1E0;
}
// 4EE53C: variable 'v1' is possibly undefined
// 66A1E0: using guessed type void *off_66A1E0;
// 6796A8: using guessed type void *`vtable for'CTaskComplexWaitForBus;

//----- (004EE550) --------------------------------------------------------
void __fastcall CTaskComplexWaitForBus::~CTaskComplexWaitForBus(CTaskComplexWaitForBus *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 4EE55C: variable 'v1' is possibly undefined

//----- (004EE560) --------------------------------------------------------
CTask *__fastcall CTaskComplexWaitForBus::CreateFirstSubTask(CTaskComplexWaitForBus *this, CPed *pPed)
{
  CTaskSimple *v2; // r0
  CTask *result; // r0

  v2 = (CTaskSimple *)CTask::operator new(0xCu);
  CTaskSimple::CTaskSimple(v2);
  result[1]._vptr$CTask = 0;
  result->_vptr$CTask = (int (**)(void))&off_66A21C;
  return result;
}
// 4EE572: variable 'result' is possibly undefined
// 66A21C: using guessed type void *;

//----- (004EE584) --------------------------------------------------------
CTask *__fastcall CTaskComplexWaitForBus::CreateNextSubTask(CTaskComplexWaitForBus *this, CPed *pPed)
{
  int v4; // r0
  CTaskComplexEnterCarAsPassenger *v5; // r0
  CTask *result; // r0
  int m_nPedFlags; // r1
  CPlayerPed *PlayerPed; // r5

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v4 == 700 )
  {
    m_nPedFlags = (int)pPed->m_nPedFlags;
    *(_DWORD *)&pPed->m_nFlags |= 0x800u;
    *(_DWORD *)&pPed->m_nPedFlags = m_nPedFlags | 0x20000000;
    PlayerPed = FindPlayerPed(-1);
    if ( PlayerPed && (CVehicle::IsPassenger(this->m_pBus, PlayerPed) || CVehicle::IsDriver(this->m_pBus, PlayerPed)) )
      PlayerPed->m_pPlayerData->m_busFaresCollected += 5;
  }
  else if ( v4 == 238 )
  {
    this->m_pBus = (CVehicle *)this->m_pSubTask[1]._vptr$CTask;
    v5 = (CTaskComplexEnterCarAsPassenger *)CTask::operator new(0x50u);
    CTaskComplexEnterCarAsPassenger::CTaskComplexEnterCarAsPassenger(v5, this->m_pBus, 0, 0);
    return result;
  }
  return 0;
}

//----- (004EE5FE) --------------------------------------------------------
CTask *__fastcall CTaskComplexWaitForBus::ControlSubTask(CTaskComplexWaitForBus *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (004EE604) --------------------------------------------------------
void __fastcall CTaskSimpleWaitForBus::CTaskSimpleWaitForBus(CTaskSimpleWaitForBus *this)
{
  _DWORD *v1; // r0

  CTaskSimple::CTaskSimple(this);
  v1[2] = 0;
  *v1 = &off_66A21C;
}
// 4EE610: variable 'v1' is possibly undefined
// 66A21C: using guessed type void *off_66A21C;

//----- (004EE624) --------------------------------------------------------
void __fastcall CTaskSimpleWaitForBus::~CTaskSimpleWaitForBus(CTaskSimpleWaitForBus *this)
{
  void *v1; // r0

  CTask::~CTask(this);
  sub_197118(v1);
}
// 4EE630: variable 'v1' is possibly undefined

//----- (004EE634) --------------------------------------------------------
bool __fastcall CTaskSimpleWaitForBus::ProcessPed(CTaskSimpleWaitForBus *this, CPed *pPed)
{
  int v2; // r3
  int v3; // r2
  int v4; // r3

  v2 = 56;
  while ( 1 )
  {
    v3 = v2;
    v4 = *((_DWORD *)&pPed->m_pPedIntelligence->m_pPed + v2);
    if ( v4 )
    {
      if ( (*(_BYTE *)(v4 + 1069) & 2) != 0
        && (float)((float)((float)(*(float *)(v4 + 72) * *(float *)(v4 + 72))
                         + (float)(*(float *)(v4 + 76) * *(float *)(v4 + 76)))
                 + (float)(*(float *)(v4 + 80) * *(float *)(v4 + 80))) < 0.000025
        && *(unsigned __int8 *)(v4 + 1164) - 1 > *(unsigned __int8 *)(v4 + 1160) )
      {
        break;
      }
    }
    v2 = v3 + 1;
    if ( v3 - 56 >= 15 )
      return 0;
  }
  this->m_pBus = (CVehicle *)v4;
  return 1;
}

//----- (004EE6A4) --------------------------------------------------------
void __fastcall CTaskSimpleWaitForPizza::CTaskSimpleWaitForPizza(CTaskSimpleWaitForPizza *this)
{
  int v1; // r0

  CTaskSimple::CTaskSimple(this);
  *(_WORD *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 8) = 0;
  *(_DWORD *)(v1 + 12) = 0;
  *(_DWORD *)v1 = &off_66A250;
}
// 4EE6B0: variable 'v1' is possibly undefined
// 66A250: using guessed type void *off_66A250;

//----- (004EE6C8) --------------------------------------------------------
void __fastcall CTaskSimpleWaitForPizza::~CTaskSimpleWaitForPizza(CTaskSimpleWaitForPizza *this)
{
  void *v1; // r0

  CTask::~CTask(this);
  sub_197118(v1);
}
// 4EE6D4: variable 'v1' is possibly undefined

//----- (004EE6D8) --------------------------------------------------------
bool __fastcall CTaskSimpleWaitForPizza::ProcessPed(CTaskSimpleWaitForPizza *this, CPed *pPed)
{
  unsigned int v2; // r1
  int m_iStartTime; // r2

  if ( !this->m_timer.m_bIsActive )
  {
    this->m_timer.m_iStartTime = CTimer::m_snTimeInMilliseconds;
    this->m_timer.m_iDuration = 2000;
    this->m_timer.m_bIsActive = 1;
  }
  if ( this->m_timer.m_bIsStopped )
  {
    v2 = CTimer::m_snTimeInMilliseconds;
    this->m_timer.m_bIsStopped = 0;
    this->m_timer.m_iStartTime = v2;
    m_iStartTime = v2;
  }
  else
  {
    m_iStartTime = this->m_timer.m_iStartTime;
    v2 = CTimer::m_snTimeInMilliseconds;
  }
  return m_iStartTime + this->m_timer.m_iDuration <= v2;
}

//----- (004EE72C) --------------------------------------------------------
void __fastcall CTaskComplexSequence::CTaskComplexSequence(CTaskComplexSequence *this)
{
  int v1; // r0

  CTaskComplex::CTaskComplex(this);
  *(_QWORD *)(v1 + 41) = 0LL;
  *(_QWORD *)(v1 + 49) = 0LL;
  *(_QWORD *)(v1 + 28) = 0LL;
  *(_QWORD *)(v1 + 36) = 0LL;
  *(_QWORD *)(v1 + 12) = 0LL;
  *(_QWORD *)(v1 + 20) = 0LL;
  *(_DWORD *)(v1 + 60) = 0;
  *(_DWORD *)v1 = &off_66A284;
}
// 4EE738: variable 'v1' is possibly undefined
// 66A284: using guessed type void *;

//----- (004EE764) --------------------------------------------------------
void __fastcall CTaskComplexSequence::~CTaskComplexSequence(CTaskComplexSequence *this)
{
  this->_vptr$CTask = (int (**)(void))&off_66A284;
  CTaskComplexSequence::Flush(this);
  sub_18EDB4(this);
}
// 66A284: using guessed type void *off_66A284;

//----- (004EE788) --------------------------------------------------------
void __fastcall CTaskComplexSequence::Flush(CTaskComplexSequence *this)
{
  CTask *v2; // r0
  CTask *v3; // r0
  CTask *v4; // r0
  CTask *v5; // r0
  CTask *v6; // r0
  CTask *v7; // r0
  CTask *v8; // r0
  CTask *v9; // r0

  v2 = this->m_tasks[0];
  if ( v2 )
    (*((void (__fastcall **)(CTask *))v2->_vptr$CTask + 1))(v2);
  v3 = this->m_tasks[1];
  this->m_tasks[0] = 0;
  if ( v3 )
    (*((void (__fastcall **)(CTask *))v3->_vptr$CTask + 1))(v3);
  v4 = this->m_tasks[2];
  this->m_tasks[1] = 0;
  if ( v4 )
    (*((void (__fastcall **)(CTask *))v4->_vptr$CTask + 1))(v4);
  v5 = this->m_tasks[3];
  this->m_tasks[2] = 0;
  if ( v5 )
    (*((void (__fastcall **)(CTask *))v5->_vptr$CTask + 1))(v5);
  v6 = this->m_tasks[4];
  this->m_tasks[3] = 0;
  if ( v6 )
    (*((void (__fastcall **)(CTask *))v6->_vptr$CTask + 1))(v6);
  v7 = this->m_tasks[5];
  this->m_tasks[4] = 0;
  if ( v7 )
    (*((void (__fastcall **)(CTask *))v7->_vptr$CTask + 1))(v7);
  v8 = this->m_tasks[6];
  this->m_tasks[5] = 0;
  if ( v8 )
    (*((void (__fastcall **)(CTask *))v8->_vptr$CTask + 1))(v8);
  v9 = this->m_tasks[7];
  this->m_tasks[6] = 0;
  if ( v9 )
    (*((void (__fastcall **)(CTask *))v9->_vptr$CTask + 1))(v9);
  this->m_iProgress = 0;
  this->m_tasks[7] = 0;
  this->m_iRepeatMode = 0;
  this->m_iRepeatProgress = 0;
}

//----- (004EE810) --------------------------------------------------------
void __fastcall CTaskComplexSequence::~CTaskComplexSequence(CTaskComplexSequence *this)
{
  void *v2; // r0

  this->_vptr$CTask = (int (**)(void))&off_66A284;
  CTaskComplexSequence::Flush(this);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v2);
}
// 4EE830: variable 'v2' is possibly undefined
// 66A284: using guessed type void *off_66A284;

//----- (004EE838) --------------------------------------------------------
int __fastcall CTaskComplexSequence::GetTaskType(const CTaskComplexSequence *this)
{
  return 244;
}

//----- (004EE83C) --------------------------------------------------------
CTask *__fastcall CTaskComplexSequence::CreateNextSubTask(CTaskComplexSequence *this, CPed *pPed)
{
  int m_iRepeatMode; // r2
  int v3; // r1
  int m_iRepeatProgress; // r3
  CTask *v6; // r0

  m_iRepeatMode = this->m_iRepeatMode;
  v3 = this->m_iProgress + 1;
  this->m_iProgress = v3;
  if ( m_iRepeatMode )
  {
    if ( v3 == 8 || !this->m_tasks[v3] )
    {
      m_iRepeatProgress = this->m_iRepeatProgress;
      v3 = 0;
      this->m_iProgress = 0;
      this->m_iRepeatProgress = m_iRepeatProgress + 1;
      if ( m_iRepeatMode == 1 )
        return (CTask *)(*((int (__fastcall **)(CTask *))this->m_tasks[v3]->_vptr$CTask + 2))(this->m_tasks[v3]);
    }
    else if ( m_iRepeatMode == 1 )
    {
      return (CTask *)(*((int (__fastcall **)(CTask *))this->m_tasks[v3]->_vptr$CTask + 2))(this->m_tasks[v3]);
    }
    if ( this->m_iRepeatProgress != m_iRepeatMode )
      return (CTask *)(*((int (__fastcall **)(CTask *))this->m_tasks[v3]->_vptr$CTask + 2))(this->m_tasks[v3]);
  }
  else if ( v3 != 8 )
  {
    v6 = this->m_tasks[v3];
    if ( v6 )
      return (CTask *)(*((int (__fastcall **)(CTask *))v6->_vptr$CTask + 2))(v6);
  }
  return 0;
}

//----- (004EE88A) --------------------------------------------------------
CTask *__fastcall CTaskComplexSequence::CreateNextSubTask(
        CTaskComplexSequence *this,
        CPed *pPed,
        int *iProgress,
        int *iRepeatProgress)
{
  int v4; // r1
  int m_iRepeatMode; // r12
  CTask *v6; // r0
  CTask *v8; // r0

  v4 = *iProgress + 1;
  *iProgress = v4;
  m_iRepeatMode = this->m_iRepeatMode;
  if ( m_iRepeatMode )
  {
    if ( v4 == 8 || !this->m_tasks[v4] )
    {
      *iProgress = 0;
      ++*iRepeatProgress;
      m_iRepeatMode = this->m_iRepeatMode;
      if ( m_iRepeatMode == 1 )
      {
LABEL_8:
        v6 = this->m_tasks[*iProgress];
        return (CTask *)(*((int (__fastcall **)(CTask *))v6->_vptr$CTask + 2))(v6);
      }
    }
    else if ( m_iRepeatMode == 1 )
    {
      goto LABEL_8;
    }
    if ( *iRepeatProgress != m_iRepeatMode )
      goto LABEL_8;
  }
  else if ( v4 != 8 )
  {
    v8 = this->m_tasks[v4];
    if ( v8 )
      return (CTask *)(*((int (__fastcall **)(CTask *))v8->_vptr$CTask + 2))(v8);
  }
  return 0;
}

//----- (004EE8E8) --------------------------------------------------------
CTask *__fastcall CTaskComplexSequence::CreateFirstSubTask(CTaskComplexSequence *this, CPed *pPed)
{
  CTask *v2; // r0

  v2 = this->m_tasks[this->m_iProgress];
  if ( v2 )
    return (CTask *)(*((int (__fastcall **)(CTask *))v2->_vptr$CTask + 2))(v2);
  else
    return 0;
}

//----- (004EE8FE) --------------------------------------------------------
CTask *__fastcall CTaskComplexSequence::CreateFirstSubTask(
        CTaskComplexSequence *this,
        CPed *pPed,
        int *iProgress,
        int *iRepeatProgress)
{
  CTask *v4; // r0

  v4 = this->m_tasks[*iProgress];
  if ( v4 )
    return (CTask *)(*((int (__fastcall **)(CTask *))v4->_vptr$CTask + 2))(v4);
  else
    return 0;
}

//----- (004EE914) --------------------------------------------------------
CTask *__fastcall CTaskComplexSequence::ControlSubTask(CTaskComplexSequence *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (004EE918) --------------------------------------------------------
bool __fastcall CTaskComplexSequence::AddTask(CTaskComplexSequence *this, CTask *pTask)
{
  CTask **m_tasks; // r2
  CTask *v3; // r3
  bool v4; // zf
  bool result; // r0
  CTask *v6; // r3
  bool v7; // zf
  CTask *v8; // r3
  bool v9; // zf

  m_tasks = this->m_tasks;
  v3 = this->m_tasks[0];
  v4 = v3 == 0;
  if ( v3 )
  {
    m_tasks = &this->m_tasks[1];
    v4 = this->m_tasks[1] == 0;
  }
  if ( v4 )
    goto LABEL_5;
  m_tasks = &this->m_tasks[2];
  if ( !this->m_tasks[2] )
    goto LABEL_5;
  m_tasks = &this->m_tasks[3];
  v6 = this->m_tasks[3];
  v7 = v6 == 0;
  if ( v6 )
  {
    m_tasks = &this->m_tasks[4];
    v7 = this->m_tasks[4] == 0;
  }
  if ( v7 )
    goto LABEL_5;
  m_tasks = &this->m_tasks[5];
  v8 = this->m_tasks[5];
  v9 = v8 == 0;
  if ( v8 )
  {
    m_tasks = &this->m_tasks[6];
    v9 = this->m_tasks[6] == 0;
  }
  if ( v9 || (m_tasks = &this->m_tasks[7], !this->m_tasks[7]) )
  {
LABEL_5:
    result = 1;
    *m_tasks = pTask;
  }
  else
  {
    if ( pTask )
      (*((void (__fastcall **)(CTask *))pTask->_vptr$CTask + 1))(pTask);
    return 0;
  }
  return result;
}

//----- (004EE986) --------------------------------------------------------
void __fastcall CTaskComplexSequence::AddTask(CTaskComplexSequence *this, const int index, CTask *pTask)
{
  int (***v4)(void); // r5
  int (**v5)(void); // r0
  CTask **v6; // r5
  int (**v7)(void); // t1

  if ( index > 7 )
  {
    if ( pTask )
      (*((void (__fastcall **)(CTask *))pTask->_vptr$CTask + 1))(pTask);
  }
  else
  {
    v4 = &this->_vptr$CTask + index;
    v7 = v4[4];
    v6 = (CTask **)(v4 + 4);
    v5 = v7;
    if ( v7 )
      (*((void (__fastcall **)(int (**)(void)))*v5 + 1))(v5);
    *v6 = pTask;
  }
}

//----- (004EE9B8) --------------------------------------------------------
void CTaskSequences::Save()
{
  script_unique_thing_struct *v0; // r4
  int v1; // r9
  CTask **m_tasks; // r8
  int i; // r5
  CTask *v4; // r4
  int v5; // r11
  _DWORD *v6; // r6
  _DWORD *v7; // r4

  v0 = (script_unique_thing_struct *)malloc(0x100u);
  qmemcpy(v0, CTheScripts::ScriptSequenceTaskArray, 0x100u);
  CGenericGameStorage::_SaveDataToWorkBuffer(v0, 256);
  free(v0);
  CGenericGameStorage::_SaveDataToWorkBuffer(CTaskSequences::ms_bIsOpened, 64);
  v1 = 0;
  m_tasks = CTaskSequences::ms_taskSequence[0].m_tasks;
  do
  {
    for ( i = 0; i != 8; ++i )
    {
      v4 = m_tasks[i];
      if ( v4 )
      {
        v5 = (*((int (__fastcall **)(CTask *))v4->_vptr$CTask + 5))(m_tasks[i]);
        v6 = malloc(4u);
        *v6 = v5;
        CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
        free(v6);
        (*((void (__fastcall **)(CTask *))v4->_vptr$CTask + 8))(v4);
      }
      else
      {
        v7 = malloc(4u);
        *v7 = -1;
        CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
        free(v7);
      }
    }
    ++v1;
    m_tasks += 16;
  }
  while ( v1 != 64 );
}

//----- (004EEA80) --------------------------------------------------------
void CTaskSequences::Load()
{
  int v0; // r9
  CTask **m_tasks; // r6
  int i; // r4
  CTask *Task; // r5
  CTask *v4; // r0
  int pData[7]; // [sp+4h] [bp-1Ch] BYREF

  CGenericGameStorage::_LoadDataFromWorkBuffer(CTheScripts::ScriptSequenceTaskArray, 256);
  CGenericGameStorage::_LoadDataFromWorkBuffer(CTaskSequences::ms_bIsOpened, 64);
  v0 = 0;
  m_tasks = CTaskSequences::ms_taskSequence[0].m_tasks;
  do
  {
    for ( i = 0; i != 8; ++i )
    {
      pData[0] = 0;
      CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
      if ( pData[0] != -1 )
      {
        Task = CTask::CreateTask();
        if ( Task )
        {
          v4 = m_tasks[i];
          if ( v4 )
            (*((void (__fastcall **)(CTask *))v4->_vptr$CTask + 1))(v4);
          m_tasks[i] = Task;
        }
      }
    }
    ++v0;
    m_tasks += 16;
  }
  while ( v0 != 64 );
}
// 4EEA80: using guessed type int pData[7];

//----- (004EEB10) --------------------------------------------------------
void CTaskSequences::Init()
{
  int v0; // r5
  CTaskComplexSequence *v1; // r4

  v0 = 0;
  v1 = CTaskSequences::ms_taskSequence;
  CTaskSequences::ms_iActiveSequence = -1;
  do
  {
    CTaskSequences::ms_bIsOpened[v0] = 0;
    CTaskComplexSequence::Flush(v1);
    ++v0;
    ++v1;
  }
  while ( v0 != 64 );
}

//----- (004EEB5C) --------------------------------------------------------
void CTaskSequences::CleanUpForShutdown()
{
  int v0; // r5
  CTaskComplexSequence *v1; // r4

  v0 = 0;
  v1 = CTaskSequences::ms_taskSequence;
  do
  {
    CTaskSequences::ms_bIsOpened[v0] = 0;
    CTaskComplexSequence::Flush(v1);
    ++v0;
    ++v1;
  }
  while ( v0 != 64 );
}

//----- (004EEB98) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int32 __fastcall CTaskSequences::GetAvailableSlot(Bool8 bSequenceForMission)
{
  int v1; // r12
  CTask **m_tasks; // r2
  bool v3; // zf
  int32 result; // r0

  v1 = 64;
  if ( bSequenceForMission )
    *(_DWORD *)&bSequenceForMission = 32;
  else
    v1 = 32;
  if ( bSequenceForMission >= (unsigned int)v1 )
  {
LABEL_10:
    *(_DWORD *)&bSequenceForMission = -1;
  }
  else
  {
    m_tasks = CTaskSequences::ms_taskSequence[bSequenceForMission].m_tasks;
    while ( 1 )
    {
      v3 = !CTaskSequences::ms_bIsOpened[bSequenceForMission];
      if ( !CTaskSequences::ms_bIsOpened[bSequenceForMission] )
        v3 = *m_tasks == 0;
      if ( v3 )
        break;
      *(_DWORD *)&bSequenceForMission = bSequenceForMission + 1;
      m_tasks += 16;
      if ( bSequenceForMission >= v1 )
        goto LABEL_10;
    }
  }
  LOBYTE(result) = bSequenceForMission;
  return result;
}
// 4EEB98: bad return variable

//----- (004EEBE4) --------------------------------------------------------
void __fastcall CTaskComplexBeInGroup::CTaskComplexBeInGroup(
        CTaskComplexBeInGroup *this,
        const int iGroupID,
        const bool bIsLeader)
{
  int v5; // r0

  CTaskComplex::CTaskComplex(this);
  *(_DWORD *)(v5 + 12) = iGroupID;
  *(_BYTE *)(v5 + 16) = bIsLeader;
  *(_DWORD *)(v5 + 20) = 0;
  *(_DWORD *)(v5 + 24) = 0;
  *(_DWORD *)(v5 + 28) = 200;
  *(_DWORD *)(v5 + 32) = 0;
  *(_DWORD *)(v5 + 36) = -1;
  *(_DWORD *)v5 = &off_66A2C0;
}
// 4EEBF6: variable 'v5' is possibly undefined
// 66A2C0: using guessed type void *;

//----- (004EEC1C) --------------------------------------------------------
void __fastcall CTaskComplexBeInGroup::~CTaskComplexBeInGroup(CTaskComplexBeInGroup *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 4EEC28: variable 'v1' is possibly undefined

//----- (004EEC2C) --------------------------------------------------------
bool __fastcall CTaskComplexBeInGroup::MakeAbortable(
        CTaskComplexBeInGroup *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  int m_iGroupID; // r2
  CTask *m_pTaskMainGroup; // r0
  CPedGroupIntelligence *p_m_intelligence; // r9
  CTask *m_pTaskSecondaryGroup; // r0

  if ( iPriority == 2 )
  {
    m_iGroupID = this->m_iGroupID;
    m_pTaskMainGroup = (CTask *)this->m_pTaskMainGroup;
    p_m_intelligence = &CPedGroups::ms_groups[m_iGroupID].m_intelligence;
    if ( m_pTaskMainGroup )
    {
      if ( CTask::IsTaskPtr(m_pTaskMainGroup) )
        CPedGroupIntelligence::ReportFinishedTask(p_m_intelligence, pPed, this->m_pTaskMainGroup);
      this->m_pTaskMainGroup = 0;
    }
    m_pTaskSecondaryGroup = (CTask *)this->m_pTaskSecondaryGroup;
    if ( m_pTaskSecondaryGroup )
    {
      if ( CTask::IsTaskPtr(m_pTaskSecondaryGroup) )
        CPedGroupIntelligence::ReportFinishedTask(p_m_intelligence, pPed, this->m_pTaskSecondaryGroup);
      this->m_pTaskSecondaryGroup = 0;
    }
  }
  return (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
          + 7))(
           this->m_pSubTask,
           pPed,
           iPriority,
           pEvent);
}

//----- (004EECA8) --------------------------------------------------------
CTask *__fastcall CTaskComplexBeInGroup::CreateNextSubTask(CTaskComplexBeInGroup *this, CPed *pPed)
{
  __int64 v4; // kr00_8
  CPedGroupIntelligence *p_m_intelligence; // r6
  const CTask *TaskMain; // r0
  const CTask *v7; // r5

  v4 = *(_QWORD *)&this->m_pSubTask;
  p_m_intelligence = &CPedGroups::ms_groups[HIDWORD(v4)].m_intelligence;
  CPedGroupIntelligence::ReportFinishedTask(p_m_intelligence, pPed, (const CTask *)v4);
  TaskMain = CPedGroupIntelligence::GetTaskMain(p_m_intelligence, pPed);
  v7 = TaskMain;
  if ( TaskMain )
  {
    this->m_pTaskMainGroup = TaskMain;
    this->m_iTaskMainGroupType = (*((int (__fastcall **)(const CTask *))TaskMain->_vptr$CTask + 5))(TaskMain);
    return (CTask *)(*((int (__fastcall **)(const CTask *))v7->_vptr$CTask + 2))(v7);
  }
  else
  {
    this->m_pTaskMainGroup = 0;
    this->m_iTaskMainGroupType = 200;
    return 0;
  }
}

//----- (004EED10) --------------------------------------------------------
CTask *__fastcall CTaskComplexBeInGroup::CreateFirstSubTask(CTaskComplexBeInGroup *this, CPed *pPed)
{
  CPed **p_m_pPed; // r6
  const CTask *TaskMain; // r0
  const CTask *v6; // r5

  this->m_pPed = pPed;
  p_m_pPed = &this->m_pPed;
  CEntity::RegisterReference(pPed, &this->m_pPed);
  TaskMain = CPedGroupIntelligence::GetTaskMain(&CPedGroups::ms_groups[(_DWORD)*(p_m_pPed - 2)].m_intelligence, pPed);
  v6 = TaskMain;
  if ( TaskMain )
  {
    this->m_pTaskMainGroup = TaskMain;
    this->m_iTaskMainGroupType = (*((int (__fastcall **)(const CTask *))TaskMain->_vptr$CTask + 5))(TaskMain);
    return (CTask *)(*((int (__fastcall **)(const CTask *))v6->_vptr$CTask + 2))(v6);
  }
  else
  {
    this->m_pTaskMainGroup = 0;
    this->m_iTaskMainGroupType = 200;
    return 0;
  }
}

//----- (004EED78) --------------------------------------------------------
CTask *__fastcall CTaskComplexBeInGroup::ControlSubTask(CTaskComplexBeInGroup *this, CPed *pPed)
{
  CTaskComplexBeInGroup::MonitorSecondaryGroupTask(this, pPed);
  return CTaskComplexBeInGroup::MonitorMainGroupTask(this, pPed);
}

//----- (004EED90) --------------------------------------------------------
void __fastcall CTaskComplexBeInGroup::MonitorSecondaryGroupTask(CTaskComplexBeInGroup *this, CPed *pPed)
{
  CPedGroupIntelligence *p_m_intelligence; // r6
  const CTask *TaskSecondary; // r9
  int TaskSecondarySlot; // r8
  CTask *v7; // r10
  const CTask *m_pTaskSecondaryGroup; // r0
  bool v9; // zf
  CTask *v10; // r0
  CPedIntelligence *m_pPedIntelligence; // r4
  CTask *v12; // r1

  p_m_intelligence = &CPedGroups::ms_groups[this->m_iGroupID].m_intelligence;
  TaskSecondary = CPedGroupIntelligence::GetTaskSecondary(p_m_intelligence, pPed);
  TaskSecondarySlot = CPedGroupIntelligence::GetTaskSecondarySlot(p_m_intelligence, pPed);
  if ( TaskSecondarySlot < 0 )
    v7 = 0;
  else
    v7 = CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, TaskSecondarySlot);
  m_pTaskSecondaryGroup = this->m_pTaskSecondaryGroup;
  if ( !m_pTaskSecondaryGroup )
    goto LABEL_8;
  v9 = v7 == 0;
  if ( !v7 )
    v9 = m_pTaskSecondaryGroup == TaskSecondary;
  if ( v9 )
  {
    CPedGroupIntelligence::ReportFinishedTask(p_m_intelligence, pPed, TaskSecondary);
    *(_QWORD *)&this->m_pTaskSecondaryGroup = 0xFFFFFFFF00000000LL;
  }
  else
  {
LABEL_8:
    if ( TaskSecondary != m_pTaskSecondaryGroup )
    {
      if ( CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, this->m_iTaskSecondaryGroupSlot) )
      {
        v10 = CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, this->m_iTaskSecondaryGroupSlot);
        (*((void (__fastcall **)(CTask *, CPed *, _DWORD, _DWORD))v10->_vptr$CTask + 7))(v10, pPed, 0, 0);
      }
      if ( !v7 || (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))v7->_vptr$CTask + 7))(v7, pPed, 1, 0) == 1 )
      {
        this->m_pTaskSecondaryGroup = TaskSecondary;
        this->m_iTaskSecondaryGroupSlot = TaskSecondarySlot;
        if ( TaskSecondary )
        {
          m_pPedIntelligence = pPed->m_pPedIntelligence;
          v12 = (CTask *)(*((int (__fastcall **)(const CTask *))TaskSecondary->_vptr$CTask + 2))(TaskSecondary);
          sub_18E570(&m_pPedIntelligence->m_taskManager, v12, TaskSecondarySlot);
        }
      }
    }
  }
}

//----- (004EEE78) --------------------------------------------------------
CTask *__fastcall CTaskComplexBeInGroup::MonitorMainGroupTask(CTaskComplexBeInGroup *this, CPed *pPed)
{
  CTask *m_pSubTask; // r8
  const CTask *TaskMain; // r5

  m_pSubTask = this->m_pSubTask;
  TaskMain = CPedGroupIntelligence::GetTaskMain(&CPedGroups::ms_groups[this->m_iGroupID].m_intelligence, pPed);
  if ( TaskMain )
  {
    if ( (TaskMain != this->m_pTaskMainGroup
       || (*((int (__fastcall **)(const CTask *))TaskMain->_vptr$CTask + 5))(TaskMain) != this->m_iTaskMainGroupType)
      && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
           this->m_pSubTask,
           pPed,
           1,
           0) == 1 )
    {
      this->m_pTaskMainGroup = TaskMain;
      this->m_iTaskMainGroupType = (*((int (__fastcall **)(const CTask *))TaskMain->_vptr$CTask + 5))(TaskMain);
      return (CTask *)(*((int (__fastcall **)(const CTask *))TaskMain->_vptr$CTask + 2))(TaskMain);
    }
  }
  else if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
              this->m_pSubTask,
              pPed,
              1,
              0) == 1 )
  {
    this->m_pTaskMainGroup = 0;
    this->m_iTaskMainGroupType = 200;
    return 0;
  }
  return m_pSubTask;
}

//----- (004EEF14) --------------------------------------------------------
void __fastcall CTaskComplexUsePairedAttractor::CTaskComplexUsePairedAttractor(
        CTaskComplexUsePairedAttractor *this,
        CPedAttractor *pPedAttractor)
{
  int v3; // r0

  CTaskComplex::CTaskComplex(this);
  *(_DWORD *)(v3 + 12) = pPedAttractor;
  *(_DWORD *)(v3 + 16) = 0;
  *(_BYTE *)(v3 + 20) = 0;
  *(_DWORD *)(v3 + 24) = 0;
  *(_DWORD *)(v3 + 28) = 0;
  *(_DWORD *)(v3 + 32) = 0;
  *(_DWORD *)v3 = &off_66A2FC;
}
// 4EEF22: variable 'v3' is possibly undefined
// 66A2FC: using guessed type void *;

//----- (004EEF40) --------------------------------------------------------
void __fastcall CTaskComplexUsePairedAttractor::~CTaskComplexUsePairedAttractor(CTaskComplexUsePairedAttractor *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 4EEF4C: variable 'v1' is possibly undefined

//----- (004EEF50) --------------------------------------------------------
void __fastcall CTaskComplexUsePairedAttractor::SeekPartnership(CTaskComplexUsePairedAttractor *this, CPed *pPed)
{
  int i; // r8
  int v4; // r10
  char *v5; // r0
  const CScriptedEffectPair *v6; // r9
  bool v7; // zf
  const C2dEffect *v8; // r4
  CPedAttractorManager *PedAttractorManager; // r0
  CPed *PedUsingEffect; // r0
  CPed *v11; // r4
  CTask *ActiveTaskByType; // r0
  CTask *v13; // r6
  CPed **ppAddress; // [sp+8h] [bp-28h]
  const CScriptedEffectPairs *EffectPairs; // [sp+10h] [bp-20h]

  EffectPairs = CScripted2dEffects::GetEffectPairs(this->m_pPedAttractor->m_pEffect);
  if ( EffectPairs->m_iNoOfPairs >= 1 )
  {
    ppAddress = &this->m_pPartnerPed;
    for ( i = 4; i != 8; ++i )
    {
      v4 = (this->m_iPartnerProgress + i) % 4;
      v5 = (char *)EffectPairs + 36 * v4;
      v6 = (const CScriptedEffectPair *)(v5 + 4);
      v7 = *((_DWORD *)v5 + 1) == -1;
      if ( *((_DWORD *)v5 + 1) != -1 )
      {
        v5 = (char *)*((_DWORD *)v5 + 5);
        v7 = v5 + 1 == 0;
      }
      if ( !v7 )
      {
        v8 = &CScripted2dEffects::ms_effects[(_DWORD)v5];
        PedAttractorManager = GetPedAttractorManager();
        PedUsingEffect = CPedAttractorManager::GetPedUsingEffect(PedAttractorManager, v8, 0);
        v11 = PedUsingEffect;
        if ( PedUsingEffect )
        {
          ActiveTaskByType = CTaskManager::FindActiveTaskByType(&PedUsingEffect->m_pPedIntelligence->m_taskManager, 246);
          v13 = ActiveTaskByType;
          if ( ActiveTaskByType )
          {
            if ( !ActiveTaskByType[2]._vptr$CTask && !*ppAddress )
            {
              this->m_pPartnerPed = v11;
              this->m_iPartnerProgress = v4;
              CEntity::RegisterReference(v11, ppAddress);
              this->m_pCurrentEffectPair = v6;
              this->m_bIsLeader = 1;
              v13[2]._vptr$CTask = (int (**)(void))pPed;
              CEntity::RegisterReference(pPed, (CEntity **)&v13[2]);
              v13[3]._vptr$CTask = (int (**)(void))v6;
              LOBYTE(v13[2].m_pParent) = 0;
            }
          }
        }
      }
    }
  }
}
// 6786D8: using guessed type C2dEffect (*CScripted2dEffects::ms_effects)[64];

//----- (004EF02C) --------------------------------------------------------
void __fastcall CTaskComplexUsePairedAttractor::SetPartnership(
        CTaskComplexUsePairedAttractor *this,
        CPed *pPartnerPed,
        const bool bIsLeader,
        const CScriptedEffectPair *pCurrentEffectPair)
{
  CPed **p_m_pPartnerPed; // r6

  this->m_pPartnerPed = pPartnerPed;
  p_m_pPartnerPed = &this->m_pPartnerPed;
  CEntity::RegisterReference(pPartnerPed, &this->m_pPartnerPed);
  p_m_pPartnerPed[2] = (CPed *)pCurrentEffectPair;
  *((_BYTE *)p_m_pPartnerPed + 4) = bIsLeader;
}

//----- (004EF050) --------------------------------------------------------
void __fastcall CTaskComplexUsePairedAttractor::ClearPartnership(CTaskComplexUsePairedAttractor *this)
{
  CPed *m_pPartnerPed; // r0
  CEntity **p_m_pPartnerPed; // r5

  p_m_pPartnerPed = &this->m_pPartnerPed;
  m_pPartnerPed = this->m_pPartnerPed;
  if ( m_pPartnerPed )
  {
    CEntity::CleanUpOldReference(m_pPartnerPed, p_m_pPartnerPed);
    *p_m_pPartnerPed = 0;
  }
  this->m_pCurrentEffectPair = 0;
  this->m_bIsLeader = 0;
}

//----- (004EF070) --------------------------------------------------------
CTask *__fastcall CTaskComplexUsePairedAttractor::CreateNextSubTask(CTaskComplexUsePairedAttractor *this, CPed *pPed)
{
  int v4; // r0
  CPed *m_pPartnerPed; // r0
  CEntity **p_m_pPartnerPed; // r6
  CTaskComplex *v7; // r0
  const CScriptedEffectPair *m_pCurrentEffectPair; // r6
  CTaskComplex *SubTask; // r5
  bool m_bIsLeader; // r4
  void **v11; // r0
  _BOOL4 v12; // r0
  const CScriptedEffectPair *v13; // r1
  int *p_m_iPartnerUseMode1; // r2
  int v15; // r1
  CPed *v16; // r0
  CTaskComplex *v17; // r0
  char *v18; // r0
  CPedAttractor *m_pPedAttractor; // r4
  CPed *v20; // r0
  CTaskComplex *v21; // r0
  const CScriptedEffectPair *v22; // r6
  bool v23; // r4
  void **v24; // r0
  CTaskComplex *v25; // r0
  char *v26; // r0
  CPedAttractorManager *PedAttractorManager; // r0

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v4 != 247 )
  {
    if ( v4 != 248 )
    {
      if ( v4 == 249 )
      {
        p_m_pPartnerPed = &this->m_pPartnerPed;
        m_pPartnerPed = this->m_pPartnerPed;
        ++this->m_iSoloProgress;
        if ( m_pPartnerPed )
        {
          if ( this->m_bIsLeader )
          {
            v7 = (CTaskComplex *)CTask::operator new(0x14u);
            m_pCurrentEffectPair = this->m_pCurrentEffectPair;
            SubTask = v7;
            m_bIsLeader = this->m_bIsLeader;
            CTaskComplex::CTaskComplex(v7);
            v11 = &`vtable for'CTaskComplexAttractorPartnerWait;
LABEL_17:
            LOBYTE(SubTask[1]._vptr$CTask) = m_bIsLeader;
            v18 = (char *)*v11;
            SubTask[1].m_pParent = (CTask *)m_pCurrentEffectPair;
LABEL_22:
            SubTask->_vptr$CTask = (int (**)(void))(v18 + 8);
            return SubTask;
          }
          CTaskManager::FindActiveTaskByType(&m_pPartnerPed->m_pPedIntelligence->m_taskManager, 246);
          v21 = (CTaskComplex *)CTask::operator new(0x14u);
          v22 = this->m_pCurrentEffectPair;
          SubTask = v21;
          v23 = this->m_bIsLeader;
          CTaskComplex::CTaskComplex(v21);
          v24 = &`vtable for'CTaskComplexAttractorPartnerWait;
          goto LABEL_31;
        }
        if ( CScripted2dEffects::ms_useAgainFlags[CScripted2dEffects::GetIndex(this->m_pPedAttractor->m_pEffect)] )
        {
          if ( *p_m_pPartnerPed )
          {
            CEntity::CleanUpOldReference(*p_m_pPartnerPed, &this->m_pPartnerPed);
            *p_m_pPartnerPed = 0;
          }
          goto LABEL_21;
        }
        PedAttractorManager = GetPedAttractorManager();
        CPedAttractorManager::BroadcastDeparture(PedAttractorManager, pPed, this->m_pPedAttractor);
      }
      return 0;
    }
    v16 = this->m_pPartnerPed;
    if ( v16 )
    {
      if ( this->m_bIsLeader )
      {
        v17 = (CTaskComplex *)CTask::operator new(0x14u);
        m_pCurrentEffectPair = this->m_pCurrentEffectPair;
        SubTask = v17;
        m_bIsLeader = this->m_bIsLeader;
        CTaskComplex::CTaskComplex(v17);
        v11 = &`vtable for'CTaskComplexUseAttractorPartner;
        goto LABEL_17;
      }
      CTaskManager::FindActiveTaskByType(&v16->m_pPedIntelligence->m_taskManager, 246);
      v25 = (CTaskComplex *)CTask::operator new(0x14u);
      v22 = this->m_pCurrentEffectPair;
      SubTask = v25;
      v23 = this->m_bIsLeader;
      CTaskComplex::CTaskComplex(v25);
      v24 = &`vtable for'CTaskComplexUseAttractorPartner;
LABEL_31:
      v26 = (char *)*v24;
      LOBYTE(SubTask[1]._vptr$CTask) = v23;
      SubTask->_vptr$CTask = (int (**)(void))(v26 + 8);
      SubTask[1].m_pParent = (CTask *)v22;
      return SubTask;
    }
LABEL_21:
    this->m_pCurrentEffectPair = 0;
    this->m_bIsLeader = 0;
    SubTask = (CTaskComplex *)CTask::operator new(0x10u);
    m_pPedAttractor = this->m_pPedAttractor;
    CTaskComplex::CTaskComplex(SubTask);
    v18 = (char *)&`vtable for'CTaskComplexUseScriptedAttractor;
    SubTask[1]._vptr$CTask = (int (**)(void))m_pPedAttractor;
    goto LABEL_22;
  }
  v12 = this->m_bIsLeader;
  if ( this->m_bIsLeader )
    this->m_iPartnerProgress = (this->m_iPartnerProgress + 5) % 4;
  v13 = this->m_pCurrentEffectPair;
  p_m_iPartnerUseMode1 = &v13->m_iPartnerUseMode1;
  if ( !v12 )
    p_m_iPartnerUseMode1 = &v13->m_iPartnerUseMode2;
  if ( *p_m_iPartnerUseMode1 == 1 )
  {
    v15 = 249;
  }
  else
  {
    if ( *p_m_iPartnerUseMode1 )
    {
      SubTask = 0;
      goto LABEL_26;
    }
    v15 = 1302;
  }
  SubTask = (CTaskComplex *)CTaskComplexUsePairedAttractor::CreateSubTask(this, v15, pPed);
LABEL_26:
  v20 = this->m_pPartnerPed;
  if ( v20 )
  {
    CEntity::CleanUpOldReference(v20, &this->m_pPartnerPed);
    this->m_pPartnerPed = 0;
  }
  this->m_pCurrentEffectPair = 0;
  this->m_bIsLeader = 0;
  return SubTask;
}
// 675FE0: using guessed type void *`vtable for'CTaskComplexUseAttractorPartner;
// 6788D8: using guessed type void *`vtable for'CTaskComplexAttractorPartnerWait;
// 678A54: using guessed type void *`vtable for'CTaskComplexUseScriptedAttractor;

//----- (004EF224) --------------------------------------------------------
CTask *__fastcall CTaskComplexUsePairedAttractor::CreateSubTask(
        CTaskComplexUsePairedAttractor *this,
        const int iSubTaskType,
        CPed *pPed)
{
  CTask *result; // r0
  CTaskComplex *v6; // r0
  int (**m_pCurrentEffectPair)(void); // r5
  bool m_bIsLeader; // r4
  void **v9; // r1
  CPed *m_pPartnerPed; // r0
  CTaskComplex *v11; // r0
  CTask *m_pPedAttractor; // r4
  char *v13; // r1
  CTaskComplex *v14; // r0
  CPedAttractorManager *PedAttractorManager; // r0
  CTaskComplex *v16; // r0
  int (**v17)(void); // r5
  bool v18; // r4
  void **v19; // r1
  CTaskComplex *v20; // r0
  char *v21; // r1

  result = 0;
  if ( iSubTaskType > 248 )
  {
    if ( iSubTaskType != 1302 )
    {
      if ( iSubTaskType != 249 )
        return result;
      m_pPartnerPed = this->m_pPartnerPed;
      if ( m_pPartnerPed )
      {
        CEntity::CleanUpOldReference(m_pPartnerPed, &this->m_pPartnerPed);
        this->m_pPartnerPed = 0;
      }
      this->m_pCurrentEffectPair = 0;
      this->m_bIsLeader = 0;
      v11 = (CTaskComplex *)CTask::operator new(0x10u);
      m_pPedAttractor = (CTask *)this->m_pPedAttractor;
      CTaskComplex::CTaskComplex(v11);
      result[1].m_pParent = m_pPedAttractor;
      v13 = (char *)&`vtable for'CTaskComplexUseScriptedAttractor;
      goto LABEL_14;
    }
    PedAttractorManager = GetPedAttractorManager();
    CPedAttractorManager::BroadcastDeparture(PedAttractorManager, pPed, this->m_pPedAttractor);
    return 0;
  }
  else
  {
    if ( iSubTaskType == 247 )
    {
      if ( this->m_bIsLeader )
      {
        v14 = (CTaskComplex *)CTask::operator new(0x14u);
        m_pCurrentEffectPair = (int (**)(void))this->m_pCurrentEffectPair;
        m_bIsLeader = this->m_bIsLeader;
        CTaskComplex::CTaskComplex(v14);
        v9 = &`vtable for'CTaskComplexUseAttractorPartner;
        goto LABEL_13;
      }
      CTaskManager::FindActiveTaskByType(&this->m_pPartnerPed->m_pPedIntelligence->m_taskManager, 246);
      v20 = (CTaskComplex *)CTask::operator new(0x14u);
      v17 = (int (**)(void))this->m_pCurrentEffectPair;
      v18 = this->m_bIsLeader;
      CTaskComplex::CTaskComplex(v20);
      v19 = &`vtable for'CTaskComplexUseAttractorPartner;
      goto LABEL_19;
    }
    if ( iSubTaskType == 248 )
    {
      if ( this->m_bIsLeader )
      {
        v6 = (CTaskComplex *)CTask::operator new(0x14u);
        m_pCurrentEffectPair = (int (**)(void))this->m_pCurrentEffectPair;
        m_bIsLeader = this->m_bIsLeader;
        CTaskComplex::CTaskComplex(v6);
        v9 = &`vtable for'CTaskComplexAttractorPartnerWait;
LABEL_13:
        LOBYTE(result[1].m_pParent) = m_bIsLeader;
        v13 = (char *)*v9;
        result[2]._vptr$CTask = m_pCurrentEffectPair;
LABEL_14:
        result->_vptr$CTask = (int (**)(void))(v13 + 8);
        return result;
      }
      CTaskManager::FindActiveTaskByType(&this->m_pPartnerPed->m_pPedIntelligence->m_taskManager, 246);
      v16 = (CTaskComplex *)CTask::operator new(0x14u);
      v17 = (int (**)(void))this->m_pCurrentEffectPair;
      v18 = this->m_bIsLeader;
      CTaskComplex::CTaskComplex(v16);
      v19 = &`vtable for'CTaskComplexAttractorPartnerWait;
LABEL_19:
      v21 = (char *)*v19;
      LOBYTE(result[1].m_pParent) = v18;
      result->_vptr$CTask = (int (**)(void))(v21 + 8);
      result[2]._vptr$CTask = v17;
    }
  }
  return result;
}
// 4EF288: variable 'result' is possibly undefined
// 675FE0: using guessed type void *`vtable for'CTaskComplexUseAttractorPartner;
// 6788D8: using guessed type void *`vtable for'CTaskComplexAttractorPartnerWait;
// 678A54: using guessed type void *`vtable for'CTaskComplexUseScriptedAttractor;

//----- (004EF324) --------------------------------------------------------
CTask *__fastcall CTaskComplexUsePairedAttractor::CreateFirstSubTask(CTaskComplexUsePairedAttractor *this, CPed *pPed)
{
  CPed *m_pPartnerPed; // r0
  CEntity **p_m_pPartnerPed; // r5
  CTaskComplex *v5; // r0
  CTask *m_pPedAttractor; // r4
  CTask *result; // r0

  p_m_pPartnerPed = &this->m_pPartnerPed;
  m_pPartnerPed = this->m_pPartnerPed;
  if ( m_pPartnerPed )
  {
    CEntity::CleanUpOldReference(m_pPartnerPed, p_m_pPartnerPed);
    *p_m_pPartnerPed = 0;
  }
  this->m_pCurrentEffectPair = 0;
  this->m_bIsLeader = 0;
  v5 = (CTaskComplex *)CTask::operator new(0x10u);
  m_pPedAttractor = (CTask *)this->m_pPedAttractor;
  CTaskComplex::CTaskComplex(v5);
  result[1].m_pParent = m_pPedAttractor;
  result->_vptr$CTask = (int (**)(void))&off_66A3B0;
  return result;
}
// 4EF350: variable 'result' is possibly undefined
// 66A3B0: using guessed type void *;
// 678A54: using guessed type void *`vtable for'CTaskComplexUseScriptedAttractor;

//----- (004EF360) --------------------------------------------------------
CTask *__fastcall CTaskComplexUsePairedAttractor::ControlSubTask(CTaskComplexUsePairedAttractor *this, CPed *pPed)
{
  CTask *m_pSubTask; // r4
  int v5; // r0
  CTask *m_bUsePartnerImmediately; // r0
  CPed *m_pPartnerPed; // r0
  CPed *v8; // r0
  CEntity **p_m_pPartnerPed; // r5
  int v10; // r1
  CTask *v11; // r0

  m_pSubTask = this->m_pSubTask;
  v5 = (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask);
  if ( v5 == 247 )
  {
    m_pPartnerPed = this->m_pPartnerPed;
    if ( !m_pPartnerPed
      || !CTaskManager::FindActiveTaskByType(&m_pPartnerPed->m_pPedIntelligence->m_taskManager, 246)
      || !CTaskManager::FindActiveTaskByType(&this->m_pPartnerPed->m_pPedIntelligence->m_taskManager, 247)
      && !CTaskManager::FindActiveTaskByType(&this->m_pPartnerPed->m_pPedIntelligence->m_taskManager, 248) )
    {
      goto LABEL_19;
    }
    return m_pSubTask;
  }
  if ( v5 != 248 )
  {
    if ( v5 != 249 )
      return m_pSubTask;
    if ( !this->m_pPartnerPed )
    {
      CTaskComplexUsePairedAttractor::SeekPartnership(this, pPed);
      if ( !this->m_pPartnerPed )
        return m_pSubTask;
    }
    m_bUsePartnerImmediately = (CTask *)this->m_pCurrentEffectPair->m_bUsePartnerImmediately;
    goto LABEL_18;
  }
  p_m_pPartnerPed = &this->m_pPartnerPed;
  v8 = this->m_pPartnerPed;
  if ( !v8 )
  {
LABEL_22:
    v11 = this->m_pSubTask;
    this->m_pCurrentEffectPair = 0;
    this->m_bIsLeader = 0;
    goto LABEL_23;
  }
  if ( !CTaskManager::FindActiveTaskByType(&v8->m_pPedIntelligence->m_taskManager, 246) )
  {
    if ( *p_m_pPartnerPed )
    {
      CEntity::CleanUpOldReference(*p_m_pPartnerPed, &this->m_pPartnerPed);
      *p_m_pPartnerPed = 0;
    }
    goto LABEL_22;
  }
  if ( this->m_bIsLeader )
    v10 = 248;
  else
    v10 = 247;
  m_bUsePartnerImmediately = CTaskManager::FindActiveTaskByType(
                               &this->m_pPartnerPed->m_pPedIntelligence->m_taskManager,
                               v10);
LABEL_18:
  if ( m_bUsePartnerImmediately )
  {
LABEL_19:
    v11 = this->m_pSubTask;
LABEL_23:
    (*((void (__fastcall **)(CTask *, CPed *, _DWORD, _DWORD))v11->_vptr$CTask + 7))(v11, pPed, 0, 0);
  }
  return m_pSubTask;
}

//----- (004EF42C) --------------------------------------------------------
void __fastcall CTaskComplexAttractorPartnerWait::CTaskComplexAttractorPartnerWait(
        CTaskComplexAttractorPartnerWait *this,
        const bool bIsLeader,
        const CScriptedEffectPair *pCurrentPair)
{
  int v5; // r0

  CTaskComplex::CTaskComplex(this);
  *(_BYTE *)(v5 + 12) = bIsLeader;
  *(_DWORD *)(v5 + 16) = pCurrentPair;
  *(_DWORD *)v5 = &off_66A338;
}
// 4EF43A: variable 'v5' is possibly undefined
// 66A338: using guessed type void *;
// 6788D8: using guessed type void *`vtable for'CTaskComplexAttractorPartnerWait;

//----- (004EF450) --------------------------------------------------------
void __fastcall CTaskComplexAttractorPartnerWait::~CTaskComplexAttractorPartnerWait(
        CTaskComplexAttractorPartnerWait *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 4EF45C: variable 'v1' is possibly undefined

//----- (004EF460) --------------------------------------------------------
CTask *__fastcall CTaskComplexAttractorPartnerWait::CreateNextSubTask(
        CTaskComplexAttractorPartnerWait *this,
        CPed *pPed)
{
  return 0;
}

//----- (004EF464) --------------------------------------------------------
CTask *__fastcall CTaskComplexAttractorPartnerWait::CreateFirstSubTask(
        CTaskComplexAttractorPartnerWait *this,
        CPed *pPed)
{
  const CScriptedEffectPair *m_pCurrentPair; // r1
  CTask **p_m_iWaitingTask1; // r2
  CTask *v4; // r4
  CTaskComplex *v5; // r0
  CTask *result; // r0

  m_pCurrentPair = this->m_pCurrentPair;
  p_m_iWaitingTask1 = (CTask **)&m_pCurrentPair->m_iWaitingTask1;
  if ( !this->m_bIsLeader )
    p_m_iWaitingTask1 = (CTask **)&m_pCurrentPair->m_iWaitingTask2;
  v4 = *p_m_iWaitingTask1;
  v5 = (CTaskComplex *)CTask::operator new(0x1Cu);
  CTaskComplex::CTaskComplex(v5);
  result->_vptr$CTask = (int (**)(void))&off_66A690;
  result[1].m_pParent = v4;
  result[2]._vptr$CTask = 0;
  result[2].m_pParent = (CTask *)-1;
  result[3]._vptr$CTask = 0;
  ++CTaskSequences::ms_taskSequence[(_DWORD)v4].m_iRefCount;
  return result;
}
// 4EF496: variable 'result' is possibly undefined
// 66A690: using guessed type void *off_66A690;

//----- (004EF4B8) --------------------------------------------------------
CTask *__fastcall CTaskComplexAttractorPartnerWait::ControlSubTask(CTaskComplexAttractorPartnerWait *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (004EF4BC) --------------------------------------------------------
void __fastcall CTaskComplexUseAttractorPartner::CTaskComplexUseAttractorPartner(
        CTaskComplexUseAttractorPartner *this,
        const bool bIsLeader,
        const CScriptedEffectPair *pCurrentPair)
{
  int v5; // r0

  CTaskComplex::CTaskComplex(this);
  *(_BYTE *)(v5 + 12) = bIsLeader;
  *(_DWORD *)(v5 + 16) = pCurrentPair;
  *(_DWORD *)v5 = &off_66A374;
}
// 4EF4CA: variable 'v5' is possibly undefined
// 66A374: using guessed type void *;
// 675FE0: using guessed type void *`vtable for'CTaskComplexUseAttractorPartner;

//----- (004EF4E0) --------------------------------------------------------
void __fastcall CTaskComplexUseAttractorPartner::~CTaskComplexUseAttractorPartner(
        CTaskComplexUseAttractorPartner *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 4EF4EC: variable 'v1' is possibly undefined

//----- (004EF4F0) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseAttractorPartner::CreateNextSubTask(CTaskComplexUseAttractorPartner *this, CPed *pPed)
{
  return 0;
}

//----- (004EF4F4) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseAttractorPartner::CreateFirstSubTask(
        CTaskComplexUseAttractorPartner *this,
        CPed *pPed)
{
  const CScriptedEffectPair *m_pCurrentPair; // r1
  CTask **p_m_iPartnerTask1; // r2
  CTask *v4; // r4
  CTaskComplex *v5; // r0
  CTask *result; // r0

  m_pCurrentPair = this->m_pCurrentPair;
  p_m_iPartnerTask1 = (CTask **)&m_pCurrentPair->m_iPartnerTask1;
  if ( !this->m_bIsLeader )
    p_m_iPartnerTask1 = (CTask **)&m_pCurrentPair->m_iPartnerTask2;
  v4 = *p_m_iPartnerTask1;
  v5 = (CTaskComplex *)CTask::operator new(0x1Cu);
  CTaskComplex::CTaskComplex(v5);
  result->_vptr$CTask = (int (**)(void))&off_66A690;
  result[1].m_pParent = v4;
  result[2]._vptr$CTask = 0;
  result[2].m_pParent = (CTask *)-1;
  result[3]._vptr$CTask = 0;
  ++CTaskSequences::ms_taskSequence[(_DWORD)v4].m_iRefCount;
  return result;
}
// 4EF528: variable 'result' is possibly undefined
// 66A690: using guessed type void *off_66A690;

//----- (004EF548) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseAttractorPartner::ControlSubTask(CTaskComplexUseAttractorPartner *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (004EF54C) --------------------------------------------------------
void __fastcall CTaskComplexUseScriptedAttractor::CTaskComplexUseScriptedAttractor(
        CTaskComplexUseScriptedAttractor *this,
        const CPedAttractor *pPedAttractor)
{
  _DWORD *v3; // r0

  CTaskComplex::CTaskComplex(this);
  v3[3] = pPedAttractor;
  *v3 = &off_66A3B0;
}
// 4EF558: variable 'v3' is possibly undefined
// 66A3B0: using guessed type void *off_66A3B0;
// 678A54: using guessed type void *`vtable for'CTaskComplexUseScriptedAttractor;

//----- (004EF56C) --------------------------------------------------------
void __fastcall CTaskComplexUseScriptedAttractor::~CTaskComplexUseScriptedAttractor(
        CTaskComplexUseScriptedAttractor *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 4EF578: variable 'v1' is possibly undefined

//----- (004EF57C) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseScriptedAttractor::CreateNextSubTask(
        CTaskComplexUseScriptedAttractor *this,
        CPed *pPed)
{
  return 0;
}

//----- (004EF580) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseScriptedAttractor::CreateFirstSubTask(
        CTaskComplexUseScriptedAttractor *this,
        CPed *pPed)
{
  int v2; // r1
  int v3; // r0
  int v4; // r1
  CTask *result; // r0
  CTask *v7; // r4
  CTaskComplex *v8; // r0

  v2 = (char *)this->m_pPedAttractor->m_pEffect - (char *)CScripted2dEffects::ms_effects + 64;
  v3 = 0;
  v4 = v2 - 64;
  if ( v4 )
  {
    while ( v3++ < 63 )
    {
      v4 -= 64;
      if ( !v4 )
        goto LABEL_5;
    }
    return 0;
  }
  else
  {
LABEL_5:
    v7 = (CTask *)CScripted2dEffects::ms_effectSequenceTaskIDs[v3];
    v8 = (CTaskComplex *)CTask::operator new(0x1Cu);
    CTaskComplex::CTaskComplex(v8);
    result->_vptr$CTask = (int (**)(void))&off_66A690;
    result[1].m_pParent = v7;
    result[2]._vptr$CTask = 0;
    result[2].m_pParent = (CTask *)-1;
    result[3]._vptr$CTask = 0;
    ++CTaskSequences::ms_taskSequence[(_DWORD)v7].m_iRefCount;
  }
  return result;
}
// 4EF5D0: variable 'result' is possibly undefined
// 66A690: using guessed type void *off_66A690;
// 6786D8: using guessed type C2dEffect (*CScripted2dEffects::ms_effects)[64];

//----- (004EF5F8) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseScriptedAttractor::ControlSubTask(CTaskComplexUseScriptedAttractor *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (004EF5FC) --------------------------------------------------------
void __fastcall CTaskComplexOnFire::CTaskComplexOnFire(CTaskComplexOnFire *this)
{
  _DWORD *v1; // r0

  CTaskComplex::CTaskComplex(this);
  *v1 = &off_66A3EC;
}
// 4EF60C: variable 'v1' is possibly undefined
// 66A3EC: using guessed type void *;

//----- (004EF618) --------------------------------------------------------
void __fastcall CTaskComplexOnFire::~CTaskComplexOnFire(CTaskComplexOnFire *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 4EF624: variable 'v1' is possibly undefined

//----- (004EF628) --------------------------------------------------------
CTask *__fastcall CTaskComplexOnFire::CreateNextSubTask(CTaskComplexOnFire *this, CPed *pPed)
{
  (*((void (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  return 0;
}

//----- (004EF638) --------------------------------------------------------
CTask *__fastcall CTaskComplexOnFire::CreateSubTask(const CTaskComplexOnFire *this, const int iSubTaskType)
{
  CTaskComplexSmartFleeEntity *v2; // r4
  CPlayerPed *PlayerPed; // r0
  CTaskComplex *v4; // r0
  int v5; // r0
  char v6; // r2

  v2 = 0;
  if ( iSubTaskType == 217 )
  {
    v4 = (CTaskComplex *)CTask::operator new(0x28u);
    CTaskComplex::CTaskComplex(v4);
    *(_DWORD *)(v5 + 12) = 0;
    *(_DWORD *)(v5 + 16) = 0;
    *(_DWORD *)(v5 + 20) = 15;
    *(_DWORD *)(v5 + 24) = 1082130432;
    *(_DWORD *)(v5 + 28) = 0;
    *(_DWORD *)(v5 + 36) = 0;
    v2 = (CTaskComplexSmartFleeEntity *)v5;
    v6 = *(_BYTE *)(v5 + 32);
    *(_DWORD *)v5 = &off_669DD8;
    *(_BYTE *)(v5 + 32) = v6 & 0xF8;
  }
  else if ( iSubTaskType == 911 )
  {
    v2 = (CTaskComplexSmartFleeEntity *)CTask::operator new(0x40u);
    PlayerPed = FindPlayerPed(-1);
    CTaskComplexSmartFleeEntity::CTaskComplexSmartFleeEntity(
      v2,
      PlayerPed,
      0,
      1000.0,
      (const int)&elf_hash_chain[8526],
      (const int)&elf_hash_bucket[187],
      1.0);
  }
  return v2;
}
// 4EF69E: variable 'v5' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 10168: using guessed type int elf_hash_chain[22025];
// 669DD8: using guessed type void *off_669DD8;

//----- (004EF6D8) --------------------------------------------------------
CTask *__fastcall CTaskComplexOnFire::CreateFirstSubTask(CTaskComplexOnFire *this, CPed *pPed)
{
  CTaskComplexSmartFleeEntity *v2; // r4
  CPlayerPed *PlayerPed; // r0
  CTask *result; // r0

  v2 = (CTaskComplexSmartFleeEntity *)CTask::operator new(0x40u);
  PlayerPed = FindPlayerPed(-1);
  CTaskComplexSmartFleeEntity::CTaskComplexSmartFleeEntity(
    v2,
    PlayerPed,
    0,
    1000.0,
    (const int)&elf_hash_chain[8526],
    (const int)&elf_hash_bucket[187],
    1.0);
  return result;
}
// FC: using guessed type int elf_hash_bucket[16411];
// 10168: using guessed type int elf_hash_chain[22025];

//----- (004EF72C) --------------------------------------------------------
CTask *__fastcall CTaskComplexOnFire::ControlSubTask(CTaskComplexOnFire *this, CPed *pPed)
{
  CTaskComplex *m_pSubTask; // r4
  CTask *v5; // r0
  CFire *m_pFire; // r1
  const CEntity *m_pEntityStartedFire; // r1
  CPedDamageResponseCalculator *v8; // r0
  char v9; // r1
  CPedDamageResponse damageResponse; // [sp+10h] [bp-30h] BYREF
  CPedDamageResponseCalculator v12; // [sp+1Ch] [bp-24h] BYREF

  m_pSubTask = (CTaskComplex *)this->m_pSubTask;
  v5 = m_pSubTask;
  if ( *((unsigned __int8 *)&pPed->m_nPhysicalFlags + 1) << 31 )
  {
    v5 = this->m_pSubTask;
    if ( pPed->m_pFire )
    {
      CFire::Extinguish(pPed->m_pFire);
      v5 = this->m_pSubTask;
    }
  }
  if ( (*((int (__fastcall **)(CTask *))v5->_vptr$CTask + 5))(v5) == 911 )
  {
    if ( pPed->m_pFire )
    {
      if ( CLocalisation::PedsOnFire() )
        CPed::Say(pPed, 0x15Au, 0, 0.1, 0, 0, 0);
      memset(&damageResponse, 0, sizeof(damageResponse));
      if ( (*((_BYTE *)&pPed->m_nPhysicalFlags + 2) & 8) == 0 )
      {
        m_pFire = pPed->m_pFire;
        if ( m_pFire )
          m_pEntityStartedFire = m_pFire->m_pEntityStartedFire;
        else
          m_pEntityStartedFire = 0;
        CPedDamageResponseCalculator::CPedDamageResponseCalculator(
          &v12,
          m_pEntityStartedFire,
          (float)((float)(pPed->FireDamageMultiplier * 500.0) * CTimer::ms_fTimeStep) / 1000.0,
          WEAPONTYPE_FLAMETHROWER,
          PED_SPHERE_CHEST,
          0);
        CPedDamageResponseCalculator::ComputeDamageResponse(v8, pPed, &damageResponse, 0);
        CPedDamageResponseCalculator::~CPedDamageResponseCalculator(&v12);
        if ( damageResponse.m_bKilled
          && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
               this->m_pSubTask,
               pPed,
               1,
               0) == 1 )
        {
          m_pSubTask = (CTaskComplex *)CTask::operator new(0x28u);
          CTaskComplex::CTaskComplex(m_pSubTask);
          m_pSubTask[1]._vptr$CTask = 0;
          m_pSubTask[1].m_pParent = 0;
          m_pSubTask[1].m_pSubTask = (CTask *)(byte_9 + 6);
          m_pSubTask[2]._vptr$CTask = (int (**)(void))1082130432;
          m_pSubTask[2].m_pParent = 0;
          m_pSubTask[3]._vptr$CTask = 0;
          v9 = (char)m_pSubTask[2].m_pSubTask;
          m_pSubTask->_vptr$CTask = (int (**)(void))&off_669DD8;
          LOBYTE(m_pSubTask[2].m_pSubTask) = v9 & 0xF8;
          CEventHandler::RegisterKill(pPed, pPed->m_pFire->m_pEntityStartedFire, WEAPONTYPE_MOLOTOV, 0);
        }
      }
    }
    else if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
                this->m_pSubTask,
                pPed,
                1,
                0) )
    {
      return 0;
    }
  }
  return m_pSubTask;
}
// 4EF7F0: variable 'v8' is possibly undefined
// 187F44: using guessed type Elf32_Rel;
// 669DD8: using guessed type void *off_669DD8;

//----- (004EF88C) --------------------------------------------------------
void __fastcall CTaskComplexOnFire::ComputeFireDamage(CPed *pPed, CPedDamageResponse *damageResponse)
{
  CFire *m_pFire; // r1
  const CEntity *m_pEntityStartedFire; // r1
  CPedDamageResponseCalculator *v6; // r0
  CPedDamageResponseCalculator v7; // [sp+Ch] [bp-24h] BYREF

  if ( (*((_BYTE *)&pPed->m_nPhysicalFlags + 2) & 8) == 0 )
  {
    m_pFire = pPed->m_pFire;
    if ( m_pFire )
      m_pEntityStartedFire = m_pFire->m_pEntityStartedFire;
    else
      m_pEntityStartedFire = 0;
    CPedDamageResponseCalculator::CPedDamageResponseCalculator(
      &v7,
      m_pEntityStartedFire,
      (float)((float)(pPed->FireDamageMultiplier * 500.0) * CTimer::ms_fTimeStep) / 1000.0,
      WEAPONTYPE_FLAMETHROWER,
      PED_SPHERE_CHEST,
      0);
    CPedDamageResponseCalculator::ComputeDamageResponse(v6, pPed, damageResponse, 0);
    CPedDamageResponseCalculator::~CPedDamageResponseCalculator(&v7);
  }
}
// 4EF8F0: variable 'v6' is possibly undefined
// 187E44: using guessed type Elf32_Rel;

//----- (004EF910) --------------------------------------------------------
void __fastcall CTaskSimplePlayerOnFire::CTaskSimplePlayerOnFire(CTaskSimplePlayerOnFire *this)
{
  int v1; // r0

  CTaskSimple::CTaskSimple(this);
  *(_WORD *)(v1 + 16) = 0;
  *(_BYTE *)(v1 + 20) = 0;
  *(_DWORD *)(v1 + 8) = 0;
  *(_DWORD *)(v1 + 12) = 0;
  *(_DWORD *)v1 = &off_66A428;
}
// 4EF91C: variable 'v1' is possibly undefined
// 66A428: using guessed type void *;

//----- (004EF938) --------------------------------------------------------
void __fastcall CTaskSimplePlayerOnFire::~CTaskSimplePlayerOnFire(CTaskSimplePlayerOnFire *this)
{
  void *v1; // r0

  CTask::~CTask(this);
  sub_197118(v1);
}
// 4EF944: variable 'v1' is possibly undefined

//----- (004EF948) --------------------------------------------------------
bool __fastcall CTaskSimplePlayerOnFire::ProcessPed(CTaskSimplePlayerOnFire *this, CPed *pPed)
{
  unsigned int v4; // r0
  int m_iStartTime; // r1
  bool v6; // r6
  CFire *m_pFire; // r1
  const CEntity *m_pEntityStartedFire; // r1
  CPedDamageResponseCalculator *v10; // r0
  CEventDamage v11; // [sp+10h] [bp-60h] BYREF
  CPedDamageResponse damageResponse; // [sp+50h] [bp-20h] BYREF

  if ( !this->m_timer.m_bIsActive )
  {
    *(_QWORD *)&this->m_timer.m_iStartTime = CTimer::m_snTimeInMilliseconds | 0x138800000000LL;
    this->m_timer.m_bIsActive = 1;
  }
  if ( !pPed->m_pFire )
    return 1;
  if ( this->m_timer.m_bIsStopped )
  {
    v4 = CTimer::m_snTimeInMilliseconds;
    this->m_timer.m_bIsStopped = 0;
    this->m_timer.m_iStartTime = v4;
    m_iStartTime = v4;
  }
  else
  {
    m_iStartTime = this->m_timer.m_iStartTime;
    v4 = CTimer::m_snTimeInMilliseconds;
  }
  if ( m_iStartTime + this->m_timer.m_iDuration <= v4 || CPedIntelligence::GetTaskSwim(pPed->m_pPedIntelligence) )
  {
    CFire::Extinguish(pPed->m_pFire);
    return 1;
  }
  v6 = 0;
  if ( CWorld::Players[0].pPed != pPed || !CWorld::Players[0].FireProof )
  {
    memset(&damageResponse, 0, sizeof(damageResponse));
    if ( (*((_BYTE *)&pPed->m_nPhysicalFlags + 2) & 8) != 0
      || ((m_pFire = pPed->m_pFire) == 0 ? (m_pEntityStartedFire = 0) : (m_pEntityStartedFire = m_pFire->m_pEntityStartedFire),
          CPedDamageResponseCalculator::CPedDamageResponseCalculator(
            (CPedDamageResponseCalculator *)&v11,
            m_pEntityStartedFire,
            (float)((float)(pPed->FireDamageMultiplier * 500.0) * CTimer::ms_fTimeStep) / 1000.0,
            WEAPONTYPE_FLAMETHROWER,
            PED_SPHERE_CHEST,
            0),
          CPedDamageResponseCalculator::ComputeDamageResponse(v10, pPed, &damageResponse, 0),
          CPedDamageResponseCalculator::~CPedDamageResponseCalculator((CPedDamageResponseCalculator *)&v11),
          !damageResponse.m_bKilled) )
    {
      if ( CLocalisation::PedsOnFire() )
        CPed::Say(pPed, 0x15Au, 0, 0.1, 0, 0, 0);
      return 0;
    }
    else
    {
      if ( this->m_bAddedDamageEvent )
        return 1;
      if ( CLocalisation::PedsOnFire() )
        CPed::Say(pPed, 0x15Au, 0, 0.1, 0, 0, 0);
      v6 = 0;
      CEventDamage::CEventDamage(
        &v11,
        0,
        CTimer::m_snTimeInMilliseconds,
        WEAPONTYPE_FLAMETHROWER,
        PED_SPHERE_CHEST,
        0,
        0,
        *(_DWORD *)&pPed->m_nPedFlags & 0x100);
      v11.m_pedDamageResponse = damageResponse;
      CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, (CEvent *)&v11, 0);
      this->m_bAddedDamageEvent = 1;
      CEventDamage::~CEventDamage(&v11);
    }
  }
  return v6;
}
// 4EFA2C: variable 'v10' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 187D0C: using guessed type Elf32_Rel;

//----- (004EFAFC) --------------------------------------------------------
bool __fastcall CTaskSimpleTogglePedThreatScanner::ProcessPed(CTaskSimpleTogglePedThreatScanner *this, CPed *pPed)
{
  CPedIntelligence *m_pPedIntelligence; // r1
  bool m_bActivatedDuringScriptCommands; // r2
  bool result; // r0

  m_pPedIntelligence = pPed->m_pPedIntelligence;
  m_bActivatedDuringScriptCommands = this->m_bActivatedDuringScriptCommands;
  *(_WORD *)&m_pPedIntelligence->m_eventScanner.m_acquaintanceScanner.m_bActivatedEverywhere = *(_WORD *)&this->m_bActivatedEverywhere;
  result = 1;
  m_pPedIntelligence->m_eventScanner.m_acquaintanceScanner.m_bActivatedDuringScriptCommands = m_bActivatedDuringScriptCommands;
  return result;
}

//----- (004EFB10) --------------------------------------------------------
bool __fastcall CTaskSimpleTriggerEvent::ProcessPed(CTaskSimpleTriggerEvent *this, CPed *pPed)
{
  CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, this->m_pEvent, 0);
  return 1;
}

//----- (004EFB28) --------------------------------------------------------
void __fastcall CTaskSimpleIKManager::CTaskSimpleIKManager(CTaskSimpleIKManager *this)
{
  int v1; // r0

  CTaskSimple::CTaskSimple(this);
  *(_QWORD *)(v1 + 8) = 0LL;
  *(_QWORD *)(v1 + 16) = 0LL;
  *(_BYTE *)(v1 + 24) = 0;
  *(_DWORD *)v1 = &off_66A45C;
}
// 4EFB36: variable 'v1' is possibly undefined
// 66A45C: using guessed type void *off_66A45C;

//----- (004EFB50) --------------------------------------------------------
void __fastcall CTaskSimpleIKManager::~CTaskSimpleIKManager(CTaskSimpleIKManager *this)
{
  CTaskSimpleIKChain *v2; // r0
  CTaskSimpleIKChain *v3; // r0
  CTaskSimpleIKChain *v4; // r0
  CTaskSimpleIKChain *v5; // r0

  v2 = this->m_pIKChainTasks[0];
  this->_vptr$CTask = (int (**)(void))&off_66A45C;
  if ( v2 )
    (*((void (__fastcall **)(CTaskSimpleIKChain *))v2->_vptr$CTask + 1))(v2);
  v3 = this->m_pIKChainTasks[1];
  if ( v3 )
    (*((void (__fastcall **)(CTaskSimpleIKChain *))v3->_vptr$CTask + 1))(v3);
  v4 = this->m_pIKChainTasks[2];
  if ( v4 )
    (*((void (__fastcall **)(CTaskSimpleIKChain *))v4->_vptr$CTask + 1))(v4);
  v5 = this->m_pIKChainTasks[3];
  if ( v5 )
    (*((void (__fastcall **)(CTaskSimpleIKChain *))v5->_vptr$CTask + 1))(v5);
  sub_1A01F4(this);
}
// 66A45C: using guessed type void *;

//----- (004EFBA0) --------------------------------------------------------
void __fastcall CTaskSimpleIKManager::~CTaskSimpleIKManager(CTaskSimpleIKManager *this)
{
  CTaskSimpleIKChain *v2; // r0
  CTaskSimpleIKChain *v3; // r0
  CTaskSimpleIKChain *v4; // r0
  CTaskSimpleIKChain *v5; // r0
  void *v6; // r0

  v2 = this->m_pIKChainTasks[0];
  this->_vptr$CTask = (int (**)(void))&off_66A45C;
  if ( v2 )
    (*((void (__fastcall **)(CTaskSimpleIKChain *))v2->_vptr$CTask + 1))(v2);
  v3 = this->m_pIKChainTasks[1];
  if ( v3 )
    (*((void (__fastcall **)(CTaskSimpleIKChain *))v3->_vptr$CTask + 1))(v3);
  v4 = this->m_pIKChainTasks[2];
  if ( v4 )
    (*((void (__fastcall **)(CTaskSimpleIKChain *))v4->_vptr$CTask + 1))(v4);
  v5 = this->m_pIKChainTasks[3];
  if ( v5 )
    (*((void (__fastcall **)(CTaskSimpleIKChain *))v5->_vptr$CTask + 1))(v5);
  CTask::~CTask(this);
  sub_197118(v6);
}
// 4EFBEA: variable 'v6' is possibly undefined
// 66A45C: using guessed type void *off_66A45C;

//----- (004EFBF4) --------------------------------------------------------
CTask *__fastcall CTaskSimpleIKManager::Clone(const CTaskSimpleIKManager *this)
{
  CTaskSimple *v2; // r4
  CTaskSimpleIKChain *v3; // r0
  CTaskSimpleIKChain *v4; // r0
  CTaskSimpleIKChain *v5; // r0
  CTaskSimpleIKChain *v6; // r0

  v2 = (CTaskSimple *)CTask::operator new(0x1Cu);
  CTaskSimple::CTaskSimple(v2);
  v2[1] = 0LL;
  v2[2] = 0LL;
  LOBYTE(v2[3]._vptr$CTask) = 0;
  v2->_vptr$CTask = (int (**)(void))&off_66A45C;
  v3 = this->m_pIKChainTasks[0];
  if ( v3 )
    v2[1]._vptr$CTask = (int (**)(void))(*((int (__fastcall **)(CTaskSimpleIKChain *))v3->_vptr$CTask + 2))(v3);
  v4 = this->m_pIKChainTasks[1];
  if ( v4 )
    v2[1].m_pParent = (CTask *)(*((int (__fastcall **)(CTaskSimpleIKChain *))v4->_vptr$CTask + 2))(v4);
  v5 = this->m_pIKChainTasks[2];
  if ( v5 )
    v2[2]._vptr$CTask = (int (**)(void))(*((int (__fastcall **)(CTaskSimpleIKChain *))v5->_vptr$CTask + 2))(v5);
  v6 = this->m_pIKChainTasks[3];
  if ( v6 )
    v2[2].m_pParent = (CTask *)(*((int (__fastcall **)(CTaskSimpleIKChain *))v6->_vptr$CTask + 2))(v6);
  return v2;
}
// 66A45C: using guessed type void *off_66A45C;

//----- (004EFC58) --------------------------------------------------------
int32 __fastcall CTaskSimpleIKManager::AddIKChainTask(
        CTaskSimpleIKManager *this,
        CTaskSimpleIKChain *pIKChainTask,
        int32 slotID)
{
  int32 result; // r0
  CTaskSimpleIKChain **v5; // r3

  if ( slotID <= -1 )
  {
    if ( this->m_pIKChainTasks[0] )
    {
      if ( this->m_pIKChainTasks[1] )
      {
        if ( this->m_pIKChainTasks[2] )
        {
          v5 = &this->m_pIKChainTasks[3];
          if ( this->m_pIKChainTasks[3] )
          {
            return 0;
          }
          else
          {
            result = 3;
            *v5 = pIKChainTask;
          }
        }
        else
        {
          result = 2;
          this->m_pIKChainTasks[2] = pIKChainTask;
        }
      }
      else
      {
        result = 1;
        this->m_pIKChainTasks[1] = pIKChainTask;
      }
    }
    else
    {
      result = 0;
      this->m_pIKChainTasks[0] = pIKChainTask;
    }
  }
  else
  {
    this->m_pIKChainTasks[slotID] = pIKChainTask;
    return slotID;
  }
  return result;
}

//----- (004EFCAC) --------------------------------------------------------
bool __fastcall CTaskSimpleIKManager::MakeAbortable(
        CTaskSimpleIKManager *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CTaskSimpleIKChain *v5; // r0
  CTaskSimpleIKChain *v6; // r0
  CTaskSimpleIKChain *v7; // r0
  CTaskSimpleIKChain *v8; // r0

  if ( iPriority == 2 )
  {
    v5 = this->m_pIKChainTasks[0];
    if ( v5 )
    {
      (*((void (__fastcall **)(CTaskSimpleIKChain *))v5->_vptr$CTask + 1))(v5);
      this->m_pIKChainTasks[0] = 0;
    }
    v6 = this->m_pIKChainTasks[1];
    if ( v6 )
    {
      (*((void (__fastcall **)(CTaskSimpleIKChain *))v6->_vptr$CTask + 1))(v6);
      this->m_pIKChainTasks[1] = 0;
    }
    v7 = this->m_pIKChainTasks[2];
    if ( v7 )
    {
      (*((void (__fastcall **)(CTaskSimpleIKChain *))v7->_vptr$CTask + 1))(v7);
      this->m_pIKChainTasks[2] = 0;
    }
    v8 = this->m_pIKChainTasks[3];
    if ( v8 )
    {
      (*((void (__fastcall **)(CTaskSimpleIKChain *))v8->_vptr$CTask + 1))(v8);
      this->m_pIKChainTasks[3] = 0;
    }
    return 1;
  }
  else
  {
    this->m_aborting = 1;
    return 0;
  }
}

//----- (004EFCFE) --------------------------------------------------------
bool __fastcall CTaskSimpleIKManager::ProcessPed(CTaskSimpleIKManager *this, CPed *pPed)
{
  CTaskSimpleIKChain *v5; // r0
  CTaskSimpleIKChain *v6; // r0
  int v7; // r5
  CTaskSimpleIKChain *v8; // r0
  CTaskSimpleIKChain *v9; // r0
  CTaskSimpleIKChain *v10; // r0
  CTaskSimpleIKChain *v11; // r0
  CTaskSimpleIKChain *v12; // r0
  CTaskSimpleIKChain *v13; // r0

  if ( this->m_aborting )
    return 1;
  v5 = this->m_pIKChainTasks[0];
  if ( v5 )
  {
    if ( (*((int (__fastcall **)(CTaskSimpleIKChain *, CPed *))v5->_vptr$CTask + 9))(v5, pPed) != 1 )
    {
      v7 = 0;
      goto LABEL_10;
    }
    v6 = this->m_pIKChainTasks[0];
    if ( v6 )
      (*((void (__fastcall **)(CTaskSimpleIKChain *))v6->_vptr$CTask + 1))(v6);
    this->m_pIKChainTasks[0] = 0;
  }
  v7 = 1;
LABEL_10:
  v8 = this->m_pIKChainTasks[1];
  if ( v8 )
  {
    if ( (*((int (__fastcall **)(CTaskSimpleIKChain *, CPed *))v8->_vptr$CTask + 9))(v8, pPed) == 1 )
    {
      v9 = this->m_pIKChainTasks[1];
      if ( v9 )
        (*((void (__fastcall **)(CTaskSimpleIKChain *))v9->_vptr$CTask + 1))(v9);
      this->m_pIKChainTasks[1] = 0;
    }
    else
    {
      v7 = 0;
    }
  }
  v10 = this->m_pIKChainTasks[2];
  if ( v10 )
  {
    if ( (*((int (__fastcall **)(CTaskSimpleIKChain *, CPed *))v10->_vptr$CTask + 9))(v10, pPed) == 1 )
    {
      v11 = this->m_pIKChainTasks[2];
      if ( v11 )
        (*((void (__fastcall **)(CTaskSimpleIKChain *))v11->_vptr$CTask + 1))(v11);
      this->m_pIKChainTasks[2] = 0;
    }
    else
    {
      v7 = 0;
    }
  }
  v12 = this->m_pIKChainTasks[3];
  if ( v12 )
  {
    if ( (*((int (__fastcall **)(CTaskSimpleIKChain *, CPed *))v12->_vptr$CTask + 9))(v12, pPed) == 1 )
    {
      v13 = this->m_pIKChainTasks[3];
      if ( v13 )
        (*((void (__fastcall **)(CTaskSimpleIKChain *))v13->_vptr$CTask + 1))(v13);
      this->m_pIKChainTasks[3] = 0;
    }
    else
    {
      v7 = 0;
    }
  }
  return v7 != 0;
}

//----- (004EFDB2) --------------------------------------------------------
void __fastcall CTaskSimpleIKManager::RemoveIKChainTask(CTaskSimpleIKManager *this, int32 slotID)
{
  int (***v2)(void); // r4
  int (**v3)(void); // r0
  _DWORD *v4; // r4
  int (**v5)(void); // t1

  v2 = &this->_vptr$CTask + slotID;
  v5 = v2[2];
  v4 = v2 + 2;
  v3 = v5;
  if ( v5 )
    (*((void (__fastcall **)(int (**)(void)))*v3 + 1))(v3);
  *v4 = 0;
}

//----- (004EFDD0) --------------------------------------------------------
void __fastcall CTaskSimpleIKManager::BlendOut(CTaskSimpleIKManager *this, int32 slotID, int32 blendOutTime)
{
  CTaskSimpleIKChain *v3; // r0
  uint32 v4; // r1

  v3 = this->m_pIKChainTasks[slotID];
  if ( !v3->m_isBlendingOut )
  {
    if ( v3->m_time == -1 )
      v3->m_time = 0;
    v4 = CTimer::m_snTimeInMilliseconds;
    v3->m_isBlendingOut = 1;
    v3->m_endTime = v4 + blendOutTime;
  }
}

//----- (004EFE00) --------------------------------------------------------
void __fastcall CTaskSimpleIKChain::BlendOut(CTaskSimpleIKChain *this, int32 blendOutTime)
{
  uint32 v2; // r2

  if ( !this->m_isBlendingOut )
  {
    if ( this->m_time == -1 )
      this->m_time = 0;
    v2 = CTimer::m_snTimeInMilliseconds;
    this->m_isBlendingOut = 1;
    this->m_endTime = blendOutTime + v2;
  }
}

//----- (004EFE28) --------------------------------------------------------
bool8 __fastcall CTaskSimpleIKManager::IsSlotEmpty(CTaskSimpleIKManager *this, int32 slotID)
{
  return this->m_pIKChainTasks[slotID] == 0;
}

//----- (004EFE38) --------------------------------------------------------
CTaskSimpleIKChain *__fastcall CTaskSimpleIKManager::GetTaskAtSlot(CTaskSimpleIKManager *this, int32 slotID)
{
  return this->m_pIKChainTasks[slotID];
}

//----- (004EFE40) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CTaskSimpleIKChain::CTaskSimpleIKChain(
        CTaskSimpleIKChain *this,
        unsigned __int8 *idString,
        int32 effectorBoneTag,
        RwV3d_0 effectorVec,
        int32 pivotBoneTag,
        CEntity *pEntity,
        int32 offsetBoneTag,
        RwV3d_0 offsetPos,
        float speed,
        int32 time,
        int32 blendTime)
{
  RwReal x; // r5
  int16 v12; // r6
  bool8 v14; // r0

  x = effectorVec.x;
  v12 = effectorBoneTag;
  CTaskSimple::CTaskSimple(this);
  *(_QWORD *)&this->m_time = *(_QWORD *)&time;
  this->m_effectorBoneTag = v12;
  this->m_effectorVec.x = x;
  this->m_effectorVec.z = effectorVec.z;
  this->m_effectorVec.y = effectorVec.y;
  this->m_pivotBoneTag = pivotBoneTag;
  this->m_pIKChain = 0;
  *(_QWORD *)&this->m_offsetBoneTag = __PAIR64__(LODWORD(offsetPos.x), offsetBoneTag);
  this->m_offsetPos.y = offsetPos.y;
  this->m_offsetPos.z = offsetPos.z;
  this->_vptr$CTask = (int (**)(void))&off_66A490;
  this->m_pEntity = pEntity;
  this->m_speed = speed;
  if ( pEntity )
  {
    CEntity::RegisterReference(pEntity, &this->m_pEntity);
    v14 = 1;
  }
  else
  {
    v14 = 0;
  }
  this->m_isBlendingOut = 0;
  this->m_nonNullEntity = v14;
}
// 4EFE40: fragmented variable at 0:r3.4,4:^20.8 may be wrong
// 4EFE40: variables would overlap: 0:r3.4,4:^20.8 and ^20.4
// 4EFE40: variables would overlap: 0:r3.4,4:^20.8 and ^24.4
// 4EFE40: variables would overlap: ^44.4 and ^44.8
// 66A490: using guessed type void *;

//----- (004EFEC8) --------------------------------------------------------
void __fastcall CTaskSimpleIKPointArm::~CTaskSimpleIKPointArm(CTaskSimpleIKChain *this)
{
  IKChain_c *m_pIKChain; // r1
  CEntity *m_pEntity; // r0

  m_pIKChain = this->m_pIKChain;
  this->_vptr$CTask = (int (**)(void))&off_66A490;
  if ( m_pIKChain )
    IKChainManager_c::RemoveIKChain(&g_ikChainMan, m_pIKChain);
  m_pEntity = this->m_pEntity;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, &this->m_pEntity);
  sub_1A01F4(this);
}
// 66A490: using guessed type void *off_66A490;

//----- (004EFF0C) --------------------------------------------------------
void __fastcall CTaskSimpleIKChain::~CTaskSimpleIKChain(CTaskSimpleIKChain *this)
{
  IKChain_c *m_pIKChain; // r1
  CEntity *m_pEntity; // r0
  void *v4; // r0

  m_pIKChain = this->m_pIKChain;
  this->_vptr$CTask = (int (**)(void))&off_66A490;
  if ( m_pIKChain )
    IKChainManager_c::RemoveIKChain(&g_ikChainMan, m_pIKChain);
  m_pEntity = this->m_pEntity;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, &this->m_pEntity);
  CTask::~CTask(this);
  sub_197118(v4);
}
// 4EFF46: variable 'v4' is possibly undefined
// 66A490: using guessed type void *off_66A490;

//----- (004EFF54) --------------------------------------------------------
CTask *__fastcall CTaskSimpleIKChain::Clone(const CTaskSimpleIKChain *this)
{
  char *v2; // r5
  __int64 v3; // r8
  __int64 v4; // kr00_8
  CEntity *m_pEntity; // r6
  __int64 v6; // d8
  __int64 v7; // d9
  char v8; // r0
  RwReal z; // [sp+4h] [bp-3Ch]
  float m_speed; // [sp+8h] [bp-38h]
  int v12; // [sp+Ch] [bp-34h]

  v2 = (char *)CTask::operator new(0x58u);
  v3 = *(_QWORD *)&this->m_time;
  v12 = *(_DWORD *)&this->m_pivotBoneTag;
  v4 = *(_QWORD *)&this->m_effectorVec.x;
  z = this->m_effectorVec.z;
  m_pEntity = this->m_pEntity;
  m_speed = this->m_speed;
  v6 = *(_QWORD *)&this->m_offsetBoneTag;
  v7 = *(_QWORD *)&this->m_offsetPos.y;
  CTaskSimple::CTaskSimple((CTaskSimple *)v2);
  *(_QWORD *)(v2 + 44) = v6;
  *(_QWORD *)(v2 + 52) = v7;
  *((_QWORD *)v2 + 1) = v3;
  *((_DWORD *)v2 + 4) = 0;
  *(_QWORD *)(v2 + 28) = v4;
  *((RwReal *)v2 + 9) = z;
  *(_DWORD *)(v2 + 22) = v12;
  *((float *)v2 + 15) = m_speed;
  *(_DWORD *)v2 = &off_66A490;
  *((_DWORD *)v2 + 10) = m_pEntity;
  if ( m_pEntity )
  {
    CEntity::RegisterReference(m_pEntity, (CEntity **)v2 + 10);
    v8 = 1;
  }
  else
  {
    v8 = 0;
  }
  *((_DWORD *)v2 + 21) = 0;
  v2[64] = v8;
  if ( this->m_pIKChain )
  {
    *((_DWORD *)v2 + 17) = LODWORD(this->m_blend);
    *((_DWORD *)v2 + 18) = this->m_endTime;
    *((_DWORD *)v2 + 19) = LODWORD(this->m_targetBlend);
    *((_DWORD *)v2 + 20) = this->m_targetTime;
  }
  return (CTask *)v2;
}
// 66A490: using guessed type void *off_66A490;

//----- (004F000C) --------------------------------------------------------
bool __fastcall CTaskSimpleIKChain::MakeAbortable(
        CTaskSimpleIKChain *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  uint32 v5; // r1

  if ( iPriority == 2 )
    return 1;
  if ( this->m_isBlendingOut )
    return 0;
  if ( this->m_time == -1 )
    this->m_time = 0;
  v5 = CTimer::m_snTimeInMilliseconds;
  this->m_isBlendingOut = 1;
  this->m_endTime = v5 + 250;
  return 0;
}

//----- (004F0040) --------------------------------------------------------
bool8 __fastcall CTaskSimpleIKChain::CreateIKChain(CTaskSimpleIKChain *this, CPed *pPed)
{
  IKChain_c *v3; // r0

  v3 = (IKChain_c *)IKChainManager_c::AddIKChain(
                      &g_ikChainMan,
                      (unsigned __int8 *)&byte_61CADE,
                      3,
                      pPed,
                      this->m_effectorBoneTag,
                      this->m_effectorVec,
                      this->m_pivotBoneTag,
                      this->m_pEntity,
                      this->m_offsetBoneTag,
                      this->m_offsetPos,
                      this->m_speed,
                      3);
  this->m_pIKChain = v3;
  return v3 != 0;
}
// 61CADE: using guessed type char byte_61CADE;

//----- (004F00B4) --------------------------------------------------------
IKChain_c *__fastcall CTaskSimpleIKChain::GetIKChain(CTaskSimpleIKChain *this)
{
  return this->m_pIKChain;
}

//----- (004F00B8) --------------------------------------------------------
bool __fastcall CTaskSimpleIKChain::ProcessPed(CTaskSimpleIKChain *this, CPed *pPed)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d3
  IKChain_c *m_pIKChain; // r1
  int v7; // s16
  signed int v8; // r5
  int32 m_time; // r0
  int32 m_endTime; // r0
  int32 m_targetTime; // r0
  float m_targetBlend; // r0
  float v13; // s0
  int32 v14; // r3
  float m_blend; // r1
  IKChain_c *v16; // r0
  int32 v17; // lr
  uint32 v19; // r0

  m_pIKChain = this->m_pIKChain;
  v7 = (int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
  if ( m_pIKChain )
  {
    v8 = CTimer::m_snTimeInMilliseconds;
    m_time = this->m_time;
    if ( m_time != -1 && (signed int)CTimer::m_snTimeInMilliseconds > this->m_endTime )
    {
      IKChainManager_c::RemoveIKChain(&g_ikChainMan, m_pIKChain);
      this->m_pIKChain = 0;
      return 1;
    }
    if ( !this->m_nonNullEntity
      || this->m_pEntity
      || (this->m_nonNullEntity = 0, IKChain_c::UpdateTarget(m_pIKChain, 0),
                                     m_time = this->m_time,
                                     this->m_isBlendingOut) )
    {
      if ( m_time == -1 )
      {
LABEL_11:
        m_targetTime = this->m_targetTime;
        if ( m_targetTime >= v8 )
        {
          v3.n64_u32[0] = 1.0;
          v2.n64_f32[0] = (float)v7 / (float)(m_targetTime - (v7 + v8));
          v13 = this->m_blend + (float)(vmin_f32(v2, v3).n64_f32[0] * (float)(this->m_targetBlend - this->m_blend));
          this->m_blend = v13;
        }
        else
        {
          m_targetBlend = this->m_targetBlend;
          this->m_blend = m_targetBlend;
          v13 = m_targetBlend;
        }
        m_blend = v13;
        v16 = this->m_pIKChain;
        goto LABEL_22;
      }
    }
    else
    {
      if ( m_time == -1 )
        this->m_time = 0;
      v19 = CTimer::m_snTimeInMilliseconds;
      this->m_isBlendingOut = 1;
      this->m_endTime = v19 + 250;
    }
    m_endTime = this->m_endTime;
    if ( v8 >= m_endTime - this->m_blendTime )
    {
      this->m_targetBlend = 0.0;
      this->m_targetTime = m_endTime;
    }
    goto LABEL_11;
  }
  if ( this->m_nonNullEntity && !this->m_pEntity
    || !(*((int (__fastcall **)(CTaskSimpleIKChain *, CPed *))this->_vptr$CTask + 11))(this, pPed) )
  {
    return 1;
  }
  v14 = this->m_time;
  m_blend = this->m_blend;
  v16 = this->m_pIKChain;
  v17 = this->m_blendTime + CTimer::m_snTimeInMilliseconds;
  if ( v14 != -1 )
    v14 += CTimer::m_snTimeInMilliseconds;
  this->m_endTime = v14;
  this->m_targetBlend = 1.0;
  this->m_targetTime = v17;
LABEL_22:
  IKChain_c::SetBlend(v16, m_blend);
  return 0;
}
// 4F01BA: variable 'v2' is possibly undefined
// 4F01BA: variable 'v3' is possibly undefined

//----- (004F0218) --------------------------------------------------------
void __fastcall CTaskSimpleIKLookAt::CTaskSimpleIKLookAt(
        CTaskSimpleIKLookAt *this,
        unsigned __int8 *idString,
        CEntity *pEntity,
        int32 time,
        int32 offsetBoneTag,
        RwV3d_0 offsetPos,
        bool8 useTorso,
        float speed,
        int32 blendTime,
        int32 priority)
{
  bool8 v13; // r0

  CTaskSimple::CTaskSimple(this);
  v13 = 0;
  this->m_time = time;
  this->m_blendTime = blendTime;
  this->m_pIKChain = 0;
  this->m_effectorBoneTag = 5;
  this->_vptr$CTask = (int (**)(void))&off_66A4C8;
  this->m_pEntity = pEntity;
  this->m_effectorVec.z = 0.0;
  this->m_offsetBoneTag = offsetBoneTag;
  *(_QWORD *)&this->m_effectorVec.x = unk_61E348;
  this->m_offsetPos = offsetPos;
  this->m_useTorso = useTorso;
  this->m_speed = speed;
  this->m_blend = 0.0;
  this->m_priority = priority;
  this->m_isBlendingOut = 0;
  if ( pEntity )
  {
    CEntity::RegisterReference(pEntity, &this->m_pEntity);
    v13 = 1;
  }
  this->m_nonNullEntity = v13;
}
// 66A4C8: using guessed type void *;

//----- (004F02AC) --------------------------------------------------------
void __fastcall CTaskSimpleIKLookAt::~CTaskSimpleIKLookAt(CTaskSimpleIKLookAt *this)
{
  IKChain_c *m_pIKChain; // r1
  CEntity *m_pEntity; // r0
  void *v4; // r0

  m_pIKChain = this->m_pIKChain;
  this->_vptr$CTask = (int (**)(void))&off_66A490;
  if ( m_pIKChain )
    IKChainManager_c::RemoveIKChain(&g_ikChainMan, m_pIKChain);
  m_pEntity = this->m_pEntity;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, &this->m_pEntity);
  CTask::~CTask(this);
  sub_197118(v4);
}
// 4F02E6: variable 'v4' is possibly undefined
// 66A490: using guessed type void *off_66A490;

//----- (004F02F4) --------------------------------------------------------
CTask *__fastcall CTaskSimpleIKLookAt::Clone(const CTaskSimpleIKLookAt *this)
{
  char *v2; // r5
  __int64 v3; // r8
  __int64 v4; // d8
  __int64 v5; // d9
  CEntity *m_pEntity; // r6
  float m_speed; // r10
  __int16 v8; // r11
  char v9; // r0

  v2 = (char *)CTask::operator new(0x5Cu);
  v3 = *(_QWORD *)&this->m_time;
  v4 = *(_QWORD *)&this->m_offsetBoneTag;
  v5 = *(_QWORD *)&this->m_offsetPos.y;
  m_pEntity = this->m_pEntity;
  m_speed = this->m_speed;
  v8 = *(_WORD *)&this->m_useTorso;
  CTaskSimple::CTaskSimple((CTaskSimple *)v2);
  *((_WORD *)v2 + 12) = 5;
  *(_DWORD *)v2 = &off_66A4C8;
  v9 = 0;
  *((_QWORD *)v2 + 1) = v3;
  *((_DWORD *)v2 + 4) = 0;
  *(_QWORD *)(v2 + 44) = v4;
  *(_QWORD *)(v2 + 52) = v5;
  *((_DWORD *)v2 + 9) = 0;
  *((float *)v2 + 15) = m_speed;
  *((_DWORD *)v2 + 17) = 0;
  *((_DWORD *)v2 + 21) = 0;
  *((_WORD *)v2 + 44) = v8;
  *(_QWORD *)(v2 + 28) = unk_61E348;
  *((_DWORD *)v2 + 10) = m_pEntity;
  if ( m_pEntity )
  {
    CEntity::RegisterReference(m_pEntity, (CEntity **)v2 + 10);
    v9 = 1;
  }
  v2[64] = v9;
  if ( this->m_pIKChain )
  {
    *((_DWORD *)v2 + 17) = LODWORD(this->m_blend);
    *((_DWORD *)v2 + 18) = this->m_endTime;
    *((_DWORD *)v2 + 19) = LODWORD(this->m_targetBlend);
    *((_DWORD *)v2 + 20) = this->m_targetTime;
    *((_WORD *)v2 + 11) = this->m_pivotBoneTag;
  }
  return (CTask *)v2;
}
// 66A4C8: using guessed type void *off_66A4C8;

//----- (004F03AC) --------------------------------------------------------
bool8 __fastcall CTaskSimpleIKLookAt::CreateIKChain(CTaskSimpleIKLookAt *this, CPed *pPed)
{
  int32 effectorBoneTag; // lr
  __int64 v4; // r8
  RwReal z; // r10
  __int64 pEntity; // kr00_8
  __int64 v7; // kr08_8
  RwReal v8; // r5
  int32 priority; // r3
  float m_speed; // s0
  bool8 v11; // r5
  IKChain_c *v12; // r0
  RwV3d_0 v14; // [sp+4h] [bp-4Ch]
  RwV3d_0 offsetPos; // [sp+1Ch] [bp-34h]

  effectorBoneTag = this->m_effectorBoneTag;
  v4 = *(_QWORD *)&this->m_effectorVec.x;
  z = this->m_effectorVec.z;
  pEntity = *(_QWORD *)&this->m_pEntity;
  v7 = *(_QWORD *)&this->m_offsetPos.x;
  v8 = this->m_offsetPos.z;
  priority = this->m_priority;
  m_speed = this->m_speed;
  this->m_pivotBoneTag = 4;
  offsetPos.z = v8;
  v11 = 0;
  *(_QWORD *)&offsetPos.x = v7;
  v14.z = z;
  *(_QWORD *)&v14.x = v4;
  v12 = (IKChain_c *)IKChainManager_c::AddIKChain(
                       &g_ikChainMan,
                       (unsigned __int8 *)&byte_61CADE,
                       0,
                       pPed,
                       effectorBoneTag,
                       v14,
                       4,
                       (CEntity *)pEntity,
                       SHIDWORD(pEntity),
                       offsetPos,
                       m_speed,
                       priority);
  this->m_pIKChain = v12;
  if ( v12 )
  {
    IKChain_c::ClampLimits(v12, 5, 0, 1u, 0, 1);
    return 1;
  }
  return v11;
}
// 61CADE: using guessed type char byte_61CADE;

//----- (004F043C) --------------------------------------------------------
void __fastcall CTaskSimpleIKLookAt::UpdateLookAtInfo(
        CTaskSimpleIKLookAt *this,
        unsigned __int8 *idString,
        CPed *pPed,
        CEntity *pEntity,
        int32 time,
        int32 offsetBoneTag,
        RwV3d_0 offsetPos,
        bool8 useTorso,
        float speed,
        int32 blendTime,
        int32 priority)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r6
  bool8 v15; // r0
  IKChain_c *m_pIKChain; // r0
  int32 v17; // r1

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  *p_m_pEntity = pEntity;
  if ( pEntity )
  {
    CEntity::RegisterReference(pEntity, p_m_pEntity);
    v15 = 1;
  }
  else
  {
    v15 = 0;
  }
  this->m_nonNullEntity = v15;
  this->m_offsetBoneTag = offsetBoneTag;
  this->m_offsetPos = offsetPos;
  this->m_useTorso = useTorso;
  this->m_speed = speed;
  this->m_time = time;
  this->m_blendTime = blendTime;
  m_pIKChain = this->m_pIKChain;
  v17 = CTimer::m_snTimeInMilliseconds + blendTime;
  this->m_endTime = CTimer::m_snTimeInMilliseconds + time;
  this->m_targetBlend = 1.0;
  this->m_targetTime = v17;
  this->m_isBlendingOut = 0;
  if ( m_pIKChain )
  {
    IKChain_c::UpdateEntity(m_pIKChain, this->m_pEntity);
    IKChain_c::UpdateOffset(
      this->m_pIKChain,
      this->m_offsetBoneTag,
      LODWORD(this->m_offsetPos.x),
      LODWORD(this->m_offsetPos.y),
      LODWORD(this->m_offsetPos.z));
    sub_197BE4(this->m_pIKChain, 1u);
  }
}

//----- (004F0518) --------------------------------------------------------
CEntity *__fastcall CTaskSimpleIKLookAt::GetLookAtEntity(CTaskSimpleIKLookAt *this)
{
  return this->m_pEntity;
}

//----- (004F051C) --------------------------------------------------------
CVector *__fastcall CTaskSimpleIKLookAt::GetLookAtOffset(CVector *retstr, CTaskSimpleIKLookAt *this)
{
  __int64 v2; // d16

  v2 = *(_QWORD *)&this->m_offsetPos.x;
  retstr->z = this->m_offsetPos.z;
  *(_QWORD *)&retstr->x = v2;
  return retstr;
}

//----- (004F052C) --------------------------------------------------------
int __fastcall CTaskSimpleIKPointArm::CTaskSimpleIKPointArm(
        int a1,
        int a2,
        int a3,
        CEntity *a4,
        __int64 a5,
        int32 offsetBoneTag,
        int a7,
        int a8,
        int a9)
{
  char v12; // r0
  __int16 v13; // r3

  CTaskSimple::CTaskSimple((CTaskSimple *)a1);
  v12 = 0;
  *(_DWORD *)(a1 + 88) = a3;
  *(_DWORD *)(a1 + 12) = a9;
  *(_DWORD *)(a1 + 16) = 0;
  v13 = 34;
  if ( !a3 )
    v13 = 24;
  *(_WORD *)(a1 + 24) = v13;
  *(_DWORD *)a1 = &off_66A500;
  *(_DWORD *)(a1 + 40) = a4;
  *(_DWORD *)(a1 + 36) = 0;
  *(_QWORD *)(a1 + 28) = unk_61E358;
  *(_QWORD *)(a1 + 44) = a5;
  *(_DWORD *)(a1 + 52) = offsetBoneTag;
  *(_DWORD *)(a1 + 56) = a7;
  *(_DWORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 60) = a8;
  *(_DWORD *)(a1 + 8) = "List_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly";
  *(_DWORD *)(a1 + 84) = 0;
  if ( a4 )
  {
    CEntity::RegisterReference(a4, (CEntity **)(a1 + 40));
    v12 = 1;
  }
  *(_BYTE *)(a1 + 64) = v12;
  return a1;
}
// 66A500: using guessed type void *;
// 4F052C: using guessed type _QWORD arg_0;

//----- (004F05C0) --------------------------------------------------------
void __fastcall CTaskSimpleIKPointArm::~CTaskSimpleIKPointArm(CTaskSimpleIKPointArm *this)
{
  IKChain_c *m_pIKChain; // r1
  CEntity *m_pEntity; // r0
  void *v4; // r0

  m_pIKChain = this->m_pIKChain;
  this->_vptr$CTask = (int (**)(void))&off_66A490;
  if ( m_pIKChain )
    IKChainManager_c::RemoveIKChain(&g_ikChainMan, m_pIKChain);
  m_pEntity = this->m_pEntity;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, &this->m_pEntity);
  CTask::~CTask(this);
  sub_197118(v4);
}
// 4F05FA: variable 'v4' is possibly undefined
// 66A490: using guessed type void *off_66A490;

//----- (004F0608) --------------------------------------------------------
CTask *__fastcall CTaskSimpleIKPointArm::Clone(const CTaskSimpleIKPointArm *this)
{
  char *v2; // r5
  __int64 v3; // d8
  __int64 v4; // d9
  int32 m_blendTime; // r8
  CEntity *m_pEntity; // r10
  float m_speed; // r9
  int32 m_armId; // r6
  __int16 v9; // r1
  char v10; // r0

  v2 = (char *)CTask::operator new(0x5Cu);
  v3 = *(_QWORD *)&this->m_offsetBoneTag;
  v4 = *(_QWORD *)&this->m_offsetPos.y;
  m_blendTime = this->m_blendTime;
  m_pEntity = this->m_pEntity;
  m_speed = this->m_speed;
  m_armId = this->m_armId;
  CTaskSimple::CTaskSimple((CTaskSimple *)v2);
  v9 = 34;
  if ( !m_armId )
    v9 = 24;
  *((_DWORD *)v2 + 22) = m_armId;
  *((_WORD *)v2 + 12) = v9;
  v10 = 0;
  *((_DWORD *)v2 + 3) = m_blendTime;
  *((_DWORD *)v2 + 4) = 0;
  *(_DWORD *)v2 = &off_66A500;
  *(_QWORD *)(v2 + 44) = v3;
  *(_QWORD *)(v2 + 52) = v4;
  *((_DWORD *)v2 + 9) = 0;
  *((float *)v2 + 15) = m_speed;
  *((_DWORD *)v2 + 17) = 0;
  *((_DWORD *)v2 + 2) = 999999;
  *((_DWORD *)v2 + 21) = 0;
  *(_QWORD *)(v2 + 28) = unk_61E358;
  *((_DWORD *)v2 + 10) = m_pEntity;
  if ( m_pEntity )
  {
    CEntity::RegisterReference(m_pEntity, (CEntity **)v2 + 10);
    v10 = 1;
  }
  v2[64] = v10;
  if ( this->m_pIKChain )
  {
    *((_DWORD *)v2 + 17) = LODWORD(this->m_blend);
    *((_DWORD *)v2 + 18) = this->m_endTime;
    *((_DWORD *)v2 + 19) = LODWORD(this->m_targetBlend);
    *((_DWORD *)v2 + 20) = this->m_targetTime;
  }
  return (CTask *)v2;
}
// 66A500: using guessed type void *off_66A500;

//----- (004F06C4) --------------------------------------------------------
bool8 __fastcall CTaskSimpleIKPointArm::CreateIKChain(CTaskSimpleIKPointArm *this, CPed *pPed)
{
  int32 m_armId; // lr
  int32 m_effectorBoneTag; // r8
  __int64 v5; // kr00_8
  RwReal z; // r1
  CEntity *m_pEntity; // r5
  int32 offsetBoneTag; // r6
  __int64 v9; // r2
  RwReal v10; // r0
  float m_speed; // s0
  int32 v12; // r2
  IKChain_c *v13; // r0
  RwV3d_0 v15; // [sp+4h] [bp-4Ch]
  RwV3d_0 v16; // [sp+1Ch] [bp-34h]

  m_armId = this->m_armId;
  m_effectorBoneTag = this->m_effectorBoneTag;
  v5 = *(_QWORD *)&this->m_effectorVec.x;
  z = this->m_effectorVec.z;
  m_pEntity = this->m_pEntity;
  offsetBoneTag = this->m_offsetBoneTag;
  v9 = *(_QWORD *)&this->m_offsetPos.x;
  v10 = this->m_offsetPos.z;
  m_speed = this->m_speed;
  this->m_pivotBoneTag = 4;
  v16.z = v10;
  *(_QWORD *)&v16.x = v9;
  v12 = 2;
  v15.z = z;
  *(_QWORD *)&v15.x = v5;
  if ( !m_armId )
    v12 = 1;
  v13 = (IKChain_c *)IKChainManager_c::AddIKChain(
                       &g_ikChainMan,
                       (unsigned __int8 *)&byte_61CADE,
                       v12,
                       pPed,
                       m_effectorBoneTag,
                       v15,
                       4,
                       m_pEntity,
                       offsetBoneTag,
                       v16,
                       m_speed,
                       3);
  this->m_pIKChain = v13;
  return v13 != 0;
}
// 61CADE: using guessed type char byte_61CADE;
// 4F06C4: using guessed type RwV3d_0 anonymous_1;

//----- (004F0748) --------------------------------------------------------
void __fastcall CTaskSimpleIKPointArm::UpdatePointArmInfo(
        CTaskSimpleIKPointArm *this,
        unsigned __int8 *idString,
        CEntity *pEntity,
        int32 offsetBoneTag,
        RwV3d_0 offsetPos,
        float speed,
        int32 blendTime)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r5
  bool8 v12; // r0
  IKChain_c *m_pIKChain; // r0
  int32 v14; // r1

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  *p_m_pEntity = pEntity;
  if ( pEntity )
  {
    CEntity::RegisterReference(pEntity, p_m_pEntity);
    v12 = 1;
  }
  else
  {
    v12 = 0;
  }
  this->m_nonNullEntity = v12;
  this->m_offsetBoneTag = offsetBoneTag;
  this->m_offsetPos = offsetPos;
  this->m_blendTime = blendTime;
  this->m_speed = speed;
  m_pIKChain = this->m_pIKChain;
  v14 = CTimer::m_snTimeInMilliseconds + blendTime;
  this->m_endTime = (int32)&aZn6cworld48pro[CTimer::m_snTimeInMilliseconds + 37];
  this->m_targetBlend = 1.0;
  this->m_targetTime = v14;
  this->m_isBlendingOut = 0;
  if ( m_pIKChain )
  {
    IKChain_c::UpdateEntity(m_pIKChain, this->m_pEntity);
    IKChain_c::UpdateOffset(
      this->m_pIKChain,
      this->m_offsetBoneTag,
      LODWORD(this->m_offsetPos.x),
      LODWORD(this->m_offsetPos.y),
      LODWORD(this->m_offsetPos.z));
    sub_197BE4(this->m_pIKChain, 1u);
  }
}

//----- (004F0814) --------------------------------------------------------
CEntity *__fastcall CTaskSimpleIKPointArm::GetPointAtEntity(CTaskSimpleIKPointArm *this)
{
  return this->m_pEntity;
}

//----- (004F0818) --------------------------------------------------------
void __fastcall CTaskSimpleTriggerLookAt::CTaskSimpleTriggerLookAt(
        CTaskSimpleTriggerLookAt *this,
        CEntity *pEntity,
        int32 time,
        int32 offsetBoneTag,
        RwV3d_0 offsetPos,
        bool8 useTorso,
        float speed,
        int32 blendTime,
        int32 priority)
{
  bool8 v13; // r0

  CTaskSimple::CTaskSimple(this);
  this->m_time = time;
  this->m_offsetBoneTag = offsetBoneTag;
  this->m_offsetPos = offsetPos;
  this->m_speed = speed;
  this->m_useTorso = useTorso;
  this->m_blendTime = blendTime;
  this->m_priority = priority;
  this->_vptr$CTask = (int (**)(void))&off_66A538;
  this->m_pEntity = pEntity;
  if ( pEntity )
  {
    CEntity::RegisterReference(pEntity, &this->m_pEntity);
    v13 = 1;
  }
  else
  {
    v13 = 0;
  }
  this->m_nonNullEntity = v13;
}
// 66A538: using guessed type void *;

//----- (004F0890) --------------------------------------------------------
void __fastcall CTaskSimpleTriggerLookAt::~CTaskSimpleTriggerLookAt(CTaskSimpleTriggerLookAt *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CTask = (int (**)(void))&off_66A538;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  sub_1A01F4(this);
}
// 66A538: using guessed type void *off_66A538;

//----- (004F08BC) --------------------------------------------------------
void __fastcall CTaskSimpleTriggerLookAt::~CTaskSimpleTriggerLookAt(CTaskSimpleTriggerLookAt *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1
  void *v4; // r0

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CTask = (int (**)(void))&off_66A538;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  CTask::~CTask(this);
  sub_197118(v4);
}
// 4F08E4: variable 'v4' is possibly undefined
// 66A538: using guessed type void *off_66A538;

//----- (004F08EC) --------------------------------------------------------
CTask *__fastcall CTaskSimpleTriggerLookAt::Clone(const CTaskSimpleTriggerLookAt *this)
{
  int32 m_time; // r1
  int32 m_offsetBoneTag; // r9
  char *v4; // r4
  bool8 m_useTorso; // r10
  CEntity *m_pEntity; // r6
  __int64 v7; // kr08_8
  RwReal z; // r5
  char v9; // r0
  float m_speed; // [sp+4h] [bp-2Ch]
  int32 m_blendTime; // [sp+8h] [bp-28h]
  int8 m_priority; // [sp+Ch] [bp-24h]
  int32 v14; // [sp+10h] [bp-20h]

  m_offsetBoneTag = this->m_offsetBoneTag;
  m_time = this->m_time;
  if ( m_offsetBoneTag >= 0 && !this->m_pEntity )
  {
    m_offsetBoneTag = -1;
    m_time = 100;
  }
  v14 = m_time;
  v4 = (char *)CTask::operator new(0x30u);
  m_priority = this->m_priority;
  m_speed = this->m_speed;
  m_blendTime = this->m_blendTime;
  m_useTorso = this->m_useTorso;
  m_pEntity = this->m_pEntity;
  v7 = *(_QWORD *)&this->m_offsetPos.x;
  z = this->m_offsetPos.z;
  CTaskSimple::CTaskSimple((CTaskSimple *)v4);
  *((_DWORD *)v4 + 3) = v14;
  *((_DWORD *)v4 + 4) = m_offsetBoneTag;
  *(_QWORD *)(v4 + 20) = v7;
  *((RwReal *)v4 + 7) = z;
  v4[32] = m_useTorso;
  *((float *)v4 + 9) = m_speed;
  *((_DWORD *)v4 + 10) = m_blendTime;
  v4[45] = m_priority;
  *(_DWORD *)v4 = &off_66A538;
  *((_DWORD *)v4 + 2) = m_pEntity;
  if ( m_pEntity )
  {
    CEntity::RegisterReference(m_pEntity, (CEntity **)v4 + 2);
    v9 = 1;
  }
  else
  {
    v9 = 0;
  }
  v4[44] = v9;
  return (CTask *)v4;
}
// 66A538: using guessed type void *off_66A538;

//----- (004F098C) --------------------------------------------------------
bool __fastcall CTaskSimpleTriggerLookAt::MakeAbortable(
        CTaskSimpleTriggerLookAt *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 1;
}

//----- (004F0990) --------------------------------------------------------
bool __fastcall CTaskSimpleTriggerLookAt::ProcessPed(CTaskSimpleTriggerLookAt *this, CPed *pPed)
{
  CEntity *m_pEntity; // r3

  m_pEntity = this->m_pEntity;
  if ( this->m_nonNullEntity && !m_pEntity )
    return 1;
  IKChainManager_c::LookAt(
    &g_ikChainMan,
    "TaskTriggerLookAt",
    pPed,
    m_pEntity,
    this->m_time,
    this->m_offsetBoneTag,
    &this->m_offsetPos,
    this->m_useTorso,
    this->m_speed,
    this->m_blendTime,
    this->m_priority,
    0);
  return 1;
}

//----- (004F0A08) --------------------------------------------------------
void __fastcall CTaskSimpleClearLookAt::CTaskSimpleClearLookAt(CTaskSimpleClearLookAt *this)
{
  _DWORD *v1; // r0

  CTaskSimple::CTaskSimple(this);
  *v1 = &off_66A56C;
}
// 4F0A18: variable 'v1' is possibly undefined
// 66A56C: using guessed type void *;

//----- (004F0A24) --------------------------------------------------------
void __fastcall CTaskSimpleClearLookAt::~CTaskSimpleClearLookAt(CTaskSimpleClearLookAt *this)
{
  void *v1; // r0

  CTask::~CTask(this);
  sub_197118(v1);
}
// 4F0A30: variable 'v1' is possibly undefined

//----- (004F0A34) --------------------------------------------------------
bool __fastcall CTaskSimpleClearLookAt::MakeAbortable(
        CTaskSimpleClearLookAt *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 1;
}

//----- (004F0A38) --------------------------------------------------------
bool __fastcall CTaskSimpleClearLookAt::ProcessPed(CTaskSimpleClearLookAt *this, CPed *pPed)
{
  if ( IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
    IKChainManager_c::AbortLookAt(&g_ikChainMan, pPed, 500);
  return 1;
}

//----- (004F0A68) --------------------------------------------------------
void __fastcall CTaskComplexUseClosestFreeScriptedAttractor::CTaskComplexUseClosestFreeScriptedAttractor(
        CTaskComplexUseClosestFreeScriptedAttractor *this,
        const bool bUseCoverNodesOnly)
{
  _DWORD *v2; // r0

  CTaskComplex::CTaskComplex(this);
  v2[3] = 4;
  *v2 = &off_66A5A0;
}
// 4F0A74: variable 'v2' is possibly undefined
// 66A5A0: using guessed type void *;

//----- (004F0A88) --------------------------------------------------------
void __fastcall CTaskComplexUseClosestFreeScriptedAttractor::~CTaskComplexUseClosestFreeScriptedAttractor(
        CTaskComplexUseClosestFreeScriptedAttractor *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 4F0A94: variable 'v1' is possibly undefined

//----- (004F0A98) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseClosestFreeScriptedAttractor::CreateNextSubTask(
        CTaskComplexUseClosestFreeScriptedAttractor *this,
        CPed *pPed)
{
  return 0;
}

//----- (004F0A9C) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseClosestFreeScriptedAttractor::CreateFirstSubTask(
        CTaskComplexUseClosestFreeScriptedAttractor *this,
        CPed *pPed)
{
  CTask *v4; // r4
  int m_iMoveState; // r0
  CTaskComplex *v6; // r0
  CTask *result; // r0
  CTaskComplex *v8; // r0
  void **v9; // r1
  CTask *v10; // r2
  CTaskComplex *v11; // r0
  char *v12; // r1

  v4 = (CTask *)CTaskComplexUseClosestFreeScriptedAttractor::ComputeClosestFreeScriptedEffect(this, pPed);
  if ( !v4 )
    return 0;
  CInterestingEvents::Add(&g_InterestingEvents, EPedUsingAttractor, pPed);
  m_iMoveState = this->m_iMoveState;
  if ( m_iMoveState == 7 )
  {
    v8 = (CTaskComplex *)CTask::operator new(0x24u);
    CTaskComplex::CTaskComplex(v8);
    result[1].m_pParent = v4;
    result[2]._vptr$CTask = 0;
    v9 = &`vtable for'CTaskComplexUseEffectSprinting;
    result[2].m_pParent = 0;
    result[3]._vptr$CTask = 0;
    LOBYTE(result[4]._vptr$CTask) = 0;
    v10 = (CTask *)&byte_7;
LABEL_8:
    v12 = (char *)*v9;
    result[3].m_pParent = v10;
    goto LABEL_9;
  }
  if ( m_iMoveState == 6 )
  {
    v11 = (CTaskComplex *)CTask::operator new(0x24u);
    CTaskComplex::CTaskComplex(v11);
    result[1].m_pParent = v4;
    result[2]._vptr$CTask = 0;
    v9 = &`vtable for'CTaskComplexUseEffectRunning;
    result[2].m_pParent = 0;
    result[3]._vptr$CTask = 0;
    LOBYTE(result[4]._vptr$CTask) = 0;
    v10 = (CTask *)&byte_6;
    goto LABEL_8;
  }
  v6 = (CTaskComplex *)CTask::operator new(0x24u);
  CTaskComplex::CTaskComplex(v6);
  v12 = (char *)&`vtable for'CTaskComplexUseEffect;
  result[1].m_pParent = v4;
  result[2]._vptr$CTask = 0;
  result[2].m_pParent = 0;
  result[3]._vptr$CTask = 0;
  result[3].m_pParent = (CTask *)byte_4;
  LOBYTE(result[4]._vptr$CTask) = 0;
LABEL_9:
  result->_vptr$CTask = (int (**)(void))(v12 + 8);
  return result;
}
// 4F0B3C: variable 'result' is possibly undefined
// 6: using guessed type char byte_6;
// 7: using guessed type char byte_7;
// 6778C8: using guessed type void *`vtable for'CTaskComplexUseEffectRunning;
// 679400: using guessed type void *`vtable for'CTaskComplexUseEffectSprinting;

//----- (004F0B68) --------------------------------------------------------
C2dEffect *__fastcall CTaskComplexUseClosestFreeScriptedAttractor::ComputeClosestFreeScriptedEffect(
        const CTaskComplexUseClosestFreeScriptedAttractor *this,
        const CPed *ped)
{
  int v3; // r8
  float v4; // s16
  C2dEffect *v5; // r10
  bool *v6; // r4
  C2dEffect *v7; // r5
  CEffectUserList *v8; // r12
  int m_nModelIndex; // r1
  int v10; // r6
  int v11; // r3
  int v12; // r2
  int v13; // r0
  int32 m_nPedType; // r1
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float32x2_t v17; // d16
  unsigned __int64 v18; // d1
  float v19; // s18
  const CPed *v20; // r11
  CEffectUserList *v21; // r9
  const CPedAttractorManager *PedAttractorManager; // r0
  _BOOL4 HasEmptySlot; // r6
  CMatrix v25; // [sp+20h] [bp-78h] BYREF

  v3 = 0;
  v4 = 3.4028e38;
  v5 = 0;
  v6 = CScripted2dEffects::ms_activated;
  v7 = CScripted2dEffects::ms_effects;
  v8 = CScripted2dEffects::ms_userLists;
  do
  {
    if ( *v6 )
    {
      if ( !v8[v3].m_bUseList
        || (m_nModelIndex = ped->m_nModelIndex,
            v10 = CScripted2dEffects::ms_userLists[v3].m_userTypes[0],
            v10 == m_nModelIndex)
        || (v11 = CScripted2dEffects::ms_userLists[v3].m_userTypes[1], v11 == m_nModelIndex)
        || (v12 = CScripted2dEffects::ms_userLists[v3].m_userTypes[2], v12 == m_nModelIndex)
        || (v13 = CScripted2dEffects::ms_userLists[v3].m_userTypes[3], v13 == m_nModelIndex)
        || (m_nPedType = ped->m_nPedType, v10 == -2)
        && CScripted2dEffects::ms_userLists[v3].m_userTypesByPedType[0] == m_nPedType
        || v11 == -2 && CScripted2dEffects::ms_userLists[v3].m_userTypesByPedType[1] == m_nPedType
        || v12 == -2 && CScripted2dEffects::ms_userLists[v3].m_userTypesByPedType[2] == m_nPedType
        || v13 == -2 && CScripted2dEffects::ms_userLists[v3].m_userTypesByPedType[3] == m_nPedType )
      {
        m_pMat = ped->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &ped->m_transform;
        v17.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.y, *(float32x2_t *)&v7->m_posn.y).n64_u64[0];
        v18 = vmul_f32(v17, v17).n64_u64[0];
        v19 = (float)((float)((float)(p_tx->m_translate.x - v7->m_posn.x) * (float)(p_tx->m_translate.x - v7->m_posn.x))
                    + *(float *)&v18)
            + *((float *)&v18 + 1);
        if ( v19 < v4 )
        {
          v25.m_pRwMat = 0;
          v25.m_owner = 0;
          v20 = ped;
          v21 = v8;
          CMatrix::SetScale(&v25, 1.0);
          PedAttractorManager = GetPedAttractorManager();
          HasEmptySlot = CPedAttractorManager::HasEmptySlot(PedAttractorManager, v7, 0);
          CMatrix::~CMatrix(&v25);
          v8 = v21;
          if ( HasEmptySlot )
          {
            v4 = v19;
            v5 = v7;
          }
          ped = v20;
        }
      }
    }
    ++v3;
    ++v7;
    ++v6;
  }
  while ( v3 != 64 );
  return v5;
}
// 6760D4: using guessed type char (*CScripted2dEffects::ms_activated)[64];
// 6786D8: using guessed type C2dEffect (*CScripted2dEffects::ms_effects)[64];

//----- (004F0D20) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseClosestFreeScriptedAttractor::ControlSubTask(
        CTaskComplexUseClosestFreeScriptedAttractor *this,
        CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (004F0D24) --------------------------------------------------------
void __fastcall CTaskComplexUseMobilePhone::CTaskComplexUseMobilePhone(
        CTaskComplexUseMobilePhone *this,
        const int iDuration)
{
  int v3; // r0

  CTaskComplex::CTaskComplex(this);
  *(_DWORD *)(v3 + 12) = iDuration;
  *(_WORD *)(v3 + 24) = 0;
  *(_WORD *)(v3 + 28) = 0;
  *(_DWORD *)(v3 + 16) = 0;
  *(_DWORD *)(v3 + 20) = 0;
  *(_DWORD *)v3 = &off_66A5DC;
}
// 4F0D32: variable 'v3' is possibly undefined
// 66A5DC: using guessed type void *;

//----- (004F0D50) --------------------------------------------------------
void __fastcall CTaskComplexUseMobilePhone::~CTaskComplexUseMobilePhone(CTaskComplexUseMobilePhone *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 4F0D5C: variable 'v1' is possibly undefined

//----- (004F0D60) --------------------------------------------------------
void __fastcall CTaskComplexUseMobilePhone::RemovePhoneModel(CTaskComplexUseMobilePhone *this, CPed *pPed)
{
  CPlayerPedData *m_pPlayerData; // r0

  CPed::RemoveWeaponModel(pPed, 330);
  CPed::SetCurrentWeapon(pPed, pPed->m_eStoredWeapon);
  m_pPlayerData = pPed->m_pPlayerData;
  pPed->m_eStoredWeapon = WEAPONTYPE_UNIDENTIFIED;
  if ( m_pPlayerData )
    m_pPlayerData->m_bDontAllowWeaponChange = 0;
}

//----- (004F0D90) --------------------------------------------------------
bool __fastcall CTaskComplexUseMobilePhone::MakeAbortable(
        CTaskComplexUseMobilePhone *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CTask *m_pSubTask; // r0
  eWeaponType m_eStoredWeapon; // r6
  int v10; // r2
  int v11; // r3
  int v12; // r1
  CPlayerPedData *m_pPlayerData; // r0
  bool result; // r0
  int v15; // r2
  int v16; // r3
  int v17; // r1
  __int64 v18; // kr00_8
  int v19; // r1

  m_pSubTask = this->m_pSubTask;
  if ( iPriority != 2 )
  {
    if ( (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) == 202 )
    {
      v15 = *((_DWORD *)&pPed->m_nPedFlags + 2);
      v16 = *((_DWORD *)&pPed->m_nPedFlags + 3);
      v17 = *((_DWORD *)&pPed->m_nPedFlags + 1);
      *(_DWORD *)&pPed->m_nPedFlags = pPed->m_nPedFlags;
      *((_DWORD *)&pPed->m_nPedFlags + 1) = v17;
      *((_DWORD *)&pPed->m_nPedFlags + 2) = v15 & 0xFFBFFFFF;
      result = 1;
      *((_DWORD *)&pPed->m_nPedFlags + 3) = v16 & 0xFFFFFFFD;
      return result;
    }
    if ( pEvent )
    {
      if ( (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 58 && CPed::IsPlayer(pPed) )
        return 1;
      this->m_bIsAborting = 1;
    }
    v18 = *(_QWORD *)&this->m_pSubTask;
    v19 = CTimer::m_snTimeInMilliseconds;
    this->m_timer.m_bIsActive = 1;
    this->m_timer.m_iStartTime = v19;
    this->m_timer.m_iDuration = HIDWORD(v18);
    if ( (*(int (__fastcall **)(_DWORD))(*(_DWORD *)v18 + 20))(v18) == 1603 )
      (*((void (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
       + 7))(
        this->m_pSubTask,
        pPed,
        iPriority,
        pEvent);
    return 0;
  }
  if ( (*((int (__fastcall **)(CTask *, CPed *, int, const CEvent *))m_pSubTask->_vptr$CTask + 7))(
         m_pSubTask,
         pPed,
         2,
         pEvent) != 1 )
    return 0;
  m_eStoredWeapon = pPed->m_eStoredWeapon;
  v10 = *((_DWORD *)&pPed->m_nPedFlags + 2);
  v11 = *((_DWORD *)&pPed->m_nPedFlags + 3);
  v12 = *((_DWORD *)&pPed->m_nPedFlags + 1);
  *(_DWORD *)&pPed->m_nPedFlags = pPed->m_nPedFlags;
  *((_DWORD *)&pPed->m_nPedFlags + 1) = v12;
  *((_DWORD *)&pPed->m_nPedFlags + 2) = v10 & 0xFFBFFFFF;
  *((_DWORD *)&pPed->m_nPedFlags + 3) = v11 & 0xFFFFFFFD;
  if ( m_eStoredWeapon == WEAPONTYPE_UNIDENTIFIED )
    return 1;
  CPed::RemoveWeaponModel(pPed, 330);
  CPed::SetCurrentWeapon(pPed, pPed->m_eStoredWeapon);
  pPed->m_eStoredWeapon = WEAPONTYPE_UNIDENTIFIED;
  m_pPlayerData = pPed->m_pPlayerData;
  if ( m_pPlayerData )
    m_pPlayerData->m_bDontAllowWeaponChange = 0;
  return 1;
}

//----- (004F0EC8) --------------------------------------------------------
void __fastcall CTaskComplexUseMobilePhone::Stop(CTaskComplexUseMobilePhone *this, CPed *pPed)
{
  int (**v2)(void); // r2

  if ( !this->m_bQuit )
  {
    v2 = this->_vptr$CTask;
    this->m_bQuit = 1;
    ((void (__fastcall *)(CTaskComplexUseMobilePhone *, CPed *, _DWORD, _DWORD))v2[7])(this, pPed, 0, 0);
  }
}

//----- (004F0EEC) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseMobilePhone::CreateNextSubTask(CTaskComplexUseMobilePhone *this, CPed *pPed)
{
  int v4; // r1
  CTask *result; // r0
  CTaskSimpleRunAnim *v6; // r0
  int m_iDuration; // r0
  int v8; // r1
  CTaskSimpleRunAnim *v9; // r0
  _BOOL4 m_bQuit; // r0
  int v11; // r3
  int v12; // r5
  int v13; // r1
  CTaskSimple *v14; // r0

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  result = 0;
  if ( v4 <= 1601 )
  {
    if ( v4 != 202 )
    {
      if ( v4 == 1601 )
      {
        v6 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
        CTaskSimpleRunAnim::CTaskSimpleRunAnim(v6, ANIM_STD_PED, ANIM_STD_PHONE_OUT, 4.0, 1603, "PhoneOut", 0);
      }
      return result;
    }
    m_bQuit = this->m_bQuit;
    this->m_timer.m_bIsActive = 0;
    this->m_bIsAborting = 0;
    if ( !m_bQuit )
      return (CTask *)(*((int (__fastcall **)(CTaskComplexUseMobilePhone *, CPed *))this->_vptr$CTask + 11))(this, pPed);
LABEL_13:
    v11 = *((_DWORD *)&pPed->m_nPedFlags + 2);
    v12 = *((_DWORD *)&pPed->m_nPedFlags + 3);
    v13 = *((_DWORD *)&pPed->m_nPedFlags + 1);
    *(_DWORD *)&pPed->m_nPedFlags = pPed->m_nPedFlags;
    result = 0;
    *((_DWORD *)&pPed->m_nPedFlags + 1) = v13;
    *((_DWORD *)&pPed->m_nPedFlags + 2) = v11 & 0xFFBFFFFF;
    *((_DWORD *)&pPed->m_nPedFlags + 3) = v12 & 0xFFFFFFFD;
    return result;
  }
  if ( v4 == 1603 )
  {
    if ( !this->m_bQuit && this->m_bIsAborting )
    {
      v14 = (CTaskSimple *)CTask::operator new(0x18u);
      CTaskSimple::CTaskSimple(v14);
      LOWORD(result[2]._vptr$CTask) = 0;
      result[2].m_pParent = (CTask *)(elf_hash_bucket + 748);
      result[1]._vptr$CTask = 0;
      result[1].m_pParent = 0;
      result->_vptr$CTask = (int (**)(void))&off_665750;
      return result;
    }
    goto LABEL_13;
  }
  if ( v4 == 1602 )
  {
    m_iDuration = this->m_iDuration;
    if ( m_iDuration >= 0 )
    {
      v8 = CTimer::m_snTimeInMilliseconds;
      this->m_timer.m_bIsActive = 1;
      this->m_timer.m_iStartTime = v8;
      this->m_timer.m_iDuration = m_iDuration;
    }
    v9 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
    CTaskSimpleRunAnim::CTaskSimpleRunAnim(v9, ANIM_STD_PED, ANIM_STD_PHONE_TALK, 4.0, 1601, "PhoneChat", 0);
  }
  return result;
}
// 4F0FF2: variable 'result' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 665750: using guessed type void *off_665750;

//----- (004F1020) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseMobilePhone::CreateFirstSubTask(CTaskComplexUseMobilePhone *this, CPed *pPed)
{
  int v3; // r0
  int v4; // r1
  CPlayerPedData *m_pPlayerData; // r0
  CTaskSimpleRunAnim *v6; // r4
  CTaskSimpleStandStill v8; // [sp+10h] [bp-30h] BYREF

  v3 = *((_DWORD *)&pPed->m_nPedFlags + 2);
  v4 = *((_DWORD *)&pPed->m_nPedFlags + 3);
  *((_DWORD *)&pPed->m_nPedFlags + 2) = v3 | 0x400000;
  *((_DWORD *)&pPed->m_nPedFlags + 3) = v4 | 2;
  if ( CPed::IsPlayer(pPed) )
    CPlayerPed::ClearWeaponTarget((CPlayerPed *)pPed);
  if ( pPed->m_eStoredWeapon == WEAPONTYPE_UNIDENTIFIED )
  {
    pPed->m_eStoredWeapon = pPed->m_WeaponSlots[pPed->m_nCurrentWeapon].m_eWeaponType;
    CPed::SetCurrentWeapon(pPed, WEAPONTYPE_UNARMED);
  }
  m_pPlayerData = pPed->m_pPlayerData;
  if ( m_pPlayerData )
    m_pPlayerData->m_bDontAllowWeaponChange = 1;
  if ( CPed::IsPlayer(pPed) )
    CCamera::ClearPlayerWeaponMode(&TheCamera);
  CTaskSimple::CTaskSimple(&v8);
  *(_WORD *)&v8.m_bForever = 0;
  v8.m_fIdleBlendDelta = 8.0;
  memset(&v8.m_iDuration, 0, 14);
  v8._vptr$CTask = (int (**)(void))&off_669BFC;
  CTaskSimpleStandStill::ProcessPed(&v8, pPed);
  v6 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
  CTaskSimpleRunAnim::CTaskSimpleRunAnim(v6, ANIM_STD_PED, ANIM_STD_PHONE_IN, 4.0, 1602, "PhoneIn", 0);
  CTask::~CTask(&v8);
  return v6;
}
// 669BFC: using guessed type void *off_669BFC;

//----- (004F1110) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseMobilePhone::ControlSubTask(CTaskComplexUseMobilePhone *this, CPed *pPed)
{
  CPlayerPedData *m_pPlayerData; // r1
  CTaskSimpleRunAnim *m_pSubTask; // r8
  CTask *v6; // r0
  CAnimBlendAssociation *Association; // r4
  CAnimBlendAssociation *v8; // r0
  float m_fCurrentTime; // s0
  CPlayerPedData *v10; // r0
  unsigned int v11; // r0
  int m_iStartTime; // r1
  CPlayerPedData *v13; // r0
  CPlayerPedData *v14; // r0
  CTaskSimplePlayerOnFoot *TaskByType; // r0

  m_pPlayerData = pPed->m_pPlayerData;
  m_pSubTask = (CTaskSimpleRunAnim *)this->m_pSubTask;
  v6 = m_pSubTask;
  if ( m_pPlayerData )
  {
    m_pPlayerData->m_bDontAllowWeaponChange = 1;
    v6 = this->m_pSubTask;
  }
  if ( (*((int (__fastcall **)(CTask *))v6->_vptr$CTask + 5))(v6) != 202 )
  {
    Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x91u);
    v8 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x92u);
    if ( Association )
    {
      if ( Association->m_fCurrentTime >= 0.85 )
        CPed::AddWeaponModel(pPed, 330);
    }
    else if ( v8 )
    {
      m_fCurrentTime = v8->m_fCurrentTime;
      if ( m_fCurrentTime >= 1.566 && (float)(m_fCurrentTime - v8->m_fTimeStep) < 1.566 )
      {
        CPed::RemoveWeaponModel(pPed, 330);
        CPed::SetCurrentWeapon(pPed, pPed->m_eStoredWeapon);
        v10 = pPed->m_pPlayerData;
        pPed->m_eStoredWeapon = WEAPONTYPE_UNIDENTIFIED;
        if ( !v10 )
          return m_pSubTask;
        v10->m_bDontAllowWeaponChange = 0;
      }
    }
    else if ( this->m_timer.m_bIsActive )
    {
      if ( this->m_timer.m_bIsStopped )
      {
        v11 = CTimer::m_snTimeInMilliseconds;
        this->m_timer.m_bIsStopped = 0;
        this->m_timer.m_iStartTime = v11;
        m_iStartTime = v11;
      }
      else
      {
        m_iStartTime = this->m_timer.m_iStartTime;
        v11 = CTimer::m_snTimeInMilliseconds;
      }
      if ( m_iStartTime + this->m_timer.m_iDuration <= v11 )
      {
        m_pSubTask = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
        CTaskSimpleRunAnim::CTaskSimpleRunAnim(m_pSubTask, ANIM_STD_PED, ANIM_STD_PHONE_OUT, 4.0, 1603, "PhoneOut", 0);
      }
    }
  }
  v13 = pPed->m_pPlayerData;
  if ( v13 )
  {
    v13->m_bPlayerSprintDisabled = 1;
    v14 = pPed->m_pPlayerData;
    if ( v14->m_fSprintEnergy < 0.0 )
      v14->m_fSprintEnergy = 0.0;
    TaskByType = (CTaskSimplePlayerOnFoot *)CPedIntelligence::FindTaskByType(pPed->m_pPedIntelligence, 0);
    if ( TaskByType )
      CTaskSimplePlayerOnFoot::PlayerControlZelda(TaskByType, (CPlayerPed *)pPed, 1);
    pPed->m_pPlayerData->m_bPlayerSprintDisabled = 0;
  }
  return m_pSubTask;
}

//----- (004F1280) --------------------------------------------------------
void __fastcall CTaskComplexUseGoggles::CTaskComplexUseGoggles(CTaskComplexUseGoggles *this)
{
  _DWORD *v1; // r0

  CTaskComplex::CTaskComplex(this);
  *v1 = &off_66A618;
}
// 4F1290: variable 'v1' is possibly undefined
// 66A618: using guessed type void *;

//----- (004F129C) --------------------------------------------------------
void __fastcall CTaskComplexUseGoggles::~CTaskComplexUseGoggles(CTaskComplexUseGoggles *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 4F12A8: variable 'v1' is possibly undefined

//----- (004F12AC) --------------------------------------------------------
bool __fastcall CTaskComplexUseGoggles::MakeAbortable(
        CTaskComplexUseGoggles *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
          + 7))(
           this->m_pSubTask,
           pPed,
           iPriority,
           pEvent);
}

//----- (004F12B8) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseGoggles::CreateNextSubTask(CTaskComplexUseGoggles *this, CPed *pPed)
{
  int v3; // r0

  v3 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v3 == 1606 )
  {
    CPed::TakeOffGoggles(pPed);
  }
  else if ( v3 == 1605 )
  {
    CPed::PutOnGoggles(pPed);
    CAEPedWeaponAudioEntity::AddAudioEvent(&pPed->m_PedWeaponAudioEntity, 145);
    return 0;
  }
  return 0;
}

//----- (004F12F4) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseGoggles::CreateFirstSubTask(CTaskComplexUseGoggles *this, CPed *pPed)
{
  RpClump_0 *m_pGogglesClump; // r4
  CTaskSimpleRunAnim *v3; // r0
  const char *v4; // r2
  int iTaskType; // r3
  CTask *result; // r0

  pPed->m_pPlayerData->m_bDontAllowWeaponChange = 1;
  m_pGogglesClump = pPed->m_pGogglesClump;
  v3 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
  if ( m_pGogglesClump )
  {
    v4 = "GogglesOff";
    iTaskType = 1606;
  }
  else
  {
    v4 = "GogglesOn";
    iTaskType = 1605;
  }
  CTaskSimpleRunAnim::CTaskSimpleRunAnim(
    v3,
    ANIM_ATTACK_GOGGLES,
    ANIM_WEAPON_ATTACK,
    4.0,
    iTaskType,
    (const unsigned __int8 *)v4,
    0);
  return result;
}

//----- (004F1350) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseGoggles::ControlSubTask(CTaskComplexUseGoggles *this, CPed *pPed)
{
  CTask *m_pSubTask; // r4
  CPlayerPedData *m_pPlayerData; // r1
  CPlayerPedData *v5; // r0
  CTaskSimplePlayerOnFoot *TaskByType; // r0

  m_pSubTask = this->m_pSubTask;
  pPed->m_pPlayerData->m_bDontAllowWeaponChange = 1;
  m_pPlayerData = pPed->m_pPlayerData;
  if ( m_pPlayerData )
  {
    m_pPlayerData->m_bPlayerSprintDisabled = 1;
    v5 = pPed->m_pPlayerData;
    if ( v5->m_fSprintEnergy < 0.0 )
      v5->m_fSprintEnergy = 0.0;
    TaskByType = (CTaskSimplePlayerOnFoot *)CPedIntelligence::FindTaskByType(pPed->m_pPedIntelligence, 0);
    if ( TaskByType )
      CTaskSimplePlayerOnFoot::PlayerControlZelda(TaskByType, (CPlayerPed *)pPed, 1);
    pPed->m_pPlayerData->m_bPlayerSprintDisabled = 0;
  }
  return m_pSubTask;
}

//----- (004F13B0) --------------------------------------------------------
void __fastcall CTaskComplexInWater::CTaskComplexInWater(CTaskComplexInWater *this)
{
  _DWORD *v1; // r0

  CTaskComplex::CTaskComplex(this);
  *v1 = &off_66A654;
}
// 4F13C0: variable 'v1' is possibly undefined
// 66A654: using guessed type void *;

//----- (004F13CC) --------------------------------------------------------
void __fastcall CTaskComplexInWater::~CTaskComplexInWater(CTaskComplexInWater *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 4F13D8: variable 'v1' is possibly undefined

//----- (004F13DC) --------------------------------------------------------
CTask *__fastcall CTaskComplexInWater::CreateNextSubTask(CTaskComplexInWater *this, CPed *pPed)
{
  CTask *m_pSubTask; // r6
  CTask *v5; // r4
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r0
  float v8; // s16
  float v9; // s18
  CTaskSimpleClimb *v10; // r0
  int8 v11; // r5
  CTask *v12; // r0

  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 1304 )
    return 0;
  m_pSubTask = this->m_pSubTask;
  v5 = 0;
  if ( m_pSubTask[7].m_pParent )
  {
    m_pMat = pPed->m_pMat;
    *(_DWORD *)&pPed->m_nPedFlags |= 0x200u;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pPed->m_transform;
    v8 = CTaskSimpleClimb::ms_fMinForStretchGrab;
    v9 = *(float *)&m_pSubTask[9]._vptr$CTask - p_tx->m_translate.z;
    v10 = (CTaskSimpleClimb *)CTask::operator new(0x30u);
    v11 = 1;
    if ( v9 < v8 )
      v11 = 2;
    CTaskSimpleClimb::CTaskSimpleClimb(
      v10,
      (CEntity *)m_pSubTask[7].m_pParent,
      (const CVector *)&m_pSubTask[8],
      *(float *)&m_pSubTask[9].m_pParent,
      (uint8)m_pSubTask[10]._vptr$CTask,
      v11,
      0);
    return v12;
  }
  return v5;
}
// 4F145C: variable 'v12' is possibly undefined

//----- (004F1474) --------------------------------------------------------
CTask *__fastcall CTaskComplexInWater::CreateFirstSubTask(CTaskComplexInWater *this, CPed *pPed)
{
  CTaskSimpleSwim *v3; // r0
  CTaskComplex *v4; // r4
  const CVector *v5; // r1
  CPed *Leader; // r2
  CPedGroup *PedsGroup; // r0
  const CPedGroupMembership *p_m_membership; // r5
  char m_pSubTask; // r1
  CTask *TaskByType; // r0
  double v12; // d16
  double v13; // [sp+8h] [bp-18h] BYREF
  CTask *m_pParent; // [sp+10h] [bp-10h]

  if ( CPed::IsPlayer(pPed) || CPopulation::IsSunbather(pPed->m_nModelIndex) )
  {
    v3 = (CTaskSimpleSwim *)CTask::operator new(0x68u);
    v4 = (CTaskComplex *)v3;
    v5 = 0;
  }
  else
  {
    if ( (*((_BYTE *)&pPed->m_nPedFlags + 6) & 0x10) != 0 )
    {
      v4 = (CTaskComplex *)CTask::operator new(0x28u);
      CTaskComplex::CTaskComplex(v4);
      v4[1]._vptr$CTask = (int (**)(void))(&dword_34 + 1);
      v4[1].m_pParent = 0;
      v4[1].m_pSubTask = (CTask *)&dword_8C;
      v4[2]._vptr$CTask = (int (**)(void))1082130432;
      v4[2].m_pParent = 0;
      v4[3]._vptr$CTask = 0;
      m_pSubTask = (char)v4[2].m_pSubTask;
      v4->_vptr$CTask = (int (**)(void))&off_669DD8;
      LOBYTE(v4[2].m_pSubTask) = m_pSubTask & 0xF8;
      return v4;
    }
    PedsGroup = CPedGroups::GetPedsGroup(pPed);
    if ( PedsGroup )
    {
      p_m_membership = &PedsGroup->m_membership;
      if ( CPedGroupMembership::GetLeader(&PedsGroup->m_membership) )
      {
        if ( CPedGroupMembership::GetLeader(p_m_membership)->m_pPlayerData )
        {
          v4 = (CTaskComplex *)CTask::operator new(0x68u);
          Leader = CPedGroupMembership::GetLeader(p_m_membership);
          v3 = (CTaskSimpleSwim *)v4;
          v5 = 0;
          goto LABEL_5;
        }
      }
    }
    if ( pPed->CharCreatedBy != 2 || !CPedIntelligence::FindTaskByType(pPed->m_pPedIntelligence, 900) )
    {
      v4 = (CTaskComplex *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim((CTaskSimpleRunAnim *)v4, ANIM_STD_PED, ANIM_STD_IDLE_SWIM, 8.0, 0);
      return v4;
    }
    TaskByType = CPedIntelligence::FindTaskByType(pPed->m_pPedIntelligence, 900);
    v12 = *(double *)&TaskByType[1].m_pParent;
    m_pParent = TaskByType[2].m_pParent;
    v13 = v12;
    v3 = (CTaskSimpleSwim *)CTask::operator new(0x68u);
    v4 = (CTaskComplex *)v3;
    v5 = (const CVector *)&v13;
  }
  Leader = 0;
LABEL_5:
  CTaskSimpleSwim::CTaskSimpleSwim(v3, v5, Leader);
  return v4;
}
// 34: using guessed type int dword_34;
// 8C: using guessed type int dword_8C;
// 669DD8: using guessed type void *off_669DD8;

//----- (004F1578) --------------------------------------------------------
CTask *__fastcall CTaskComplexInWater::ControlSubTask(CTaskComplexInWater *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (004F157C) --------------------------------------------------------
bool __fastcall CTaskSimpleSetCharDecisionMaker::ProcessPed(CTaskSimpleSetCharDecisionMaker *this, CPed *pPed)
{
  CPedIntelligence::SetPedDecisionMakerType(pPed->m_pPedIntelligence, this->m_iDM);
  return 1;
}

//----- (004F1590) --------------------------------------------------------
void __fastcall CTaskComplexUseSequence::CTaskComplexUseSequence(CTaskComplexUseSequence *this, const int id)
{
  _DWORD *v3; // r0

  CTaskComplex::CTaskComplex(this);
  v3[3] = id;
  v3[4] = 0;
  v3[5] = -1;
  v3[6] = 0;
  *v3 = &off_66A690;
  ++CTaskSequences::ms_taskSequence[id].m_iRefCount;
}
// 4F15A8: variable 'v3' is possibly undefined
// 66A690: using guessed type void *;

//----- (004F15D0) --------------------------------------------------------
void __fastcall CTaskComplexUseSequence::~CTaskComplexUseSequence(CTaskComplexUseSequence *this)
{
  int m_id; // r1
  CTaskComplexSequence *v3; // r0
  int v4; // r2
  CTaskComplexSequence *v5; // r1
  bool *p_m_bCanBeEmptied; // r1
  _BOOL4 m_bCanBeEmptied; // t1

  m_id = this->m_id;
  this->_vptr$CTask = (int (**)(void))&off_66A690;
  if ( m_id != -1 )
  {
    v3 = &CTaskSequences::ms_taskSequence[m_id];
    v4 = v3->m_iRefCount - 1;
    v3->m_iRefCount = v4;
    if ( !v4 )
    {
      v5 = &CTaskSequences::ms_taskSequence[m_id];
      m_bCanBeEmptied = v5->m_bCanBeEmptied;
      p_m_bCanBeEmptied = &v5->m_bCanBeEmptied;
      if ( m_bCanBeEmptied )
      {
        *p_m_bCanBeEmptied = 0;
        CTaskComplexSequence::Flush(v3);
      }
    }
  }
  sub_18EDB4(this);
}
// 66A690: using guessed type void *off_66A690;

//----- (004F1628) --------------------------------------------------------
void __fastcall CTaskComplexUseSequence::~CTaskComplexUseSequence(CTaskComplexUseSequence *this)
{
  int m_id; // r1
  CTaskComplexSequence *v3; // r0
  int v4; // r2
  CTaskComplexSequence *v5; // r1
  bool *p_m_bCanBeEmptied; // r1
  _BOOL4 m_bCanBeEmptied; // t1
  void *v8; // r0

  m_id = this->m_id;
  this->_vptr$CTask = (int (**)(void))&off_66A690;
  if ( m_id != -1 )
  {
    v3 = &CTaskSequences::ms_taskSequence[m_id];
    v4 = v3->m_iRefCount - 1;
    v3->m_iRefCount = v4;
    if ( !v4 )
    {
      v5 = &CTaskSequences::ms_taskSequence[m_id];
      m_bCanBeEmptied = v5->m_bCanBeEmptied;
      p_m_bCanBeEmptied = &v5->m_bCanBeEmptied;
      if ( m_bCanBeEmptied )
      {
        *p_m_bCanBeEmptied = 0;
        CTaskComplexSequence::Flush(v3);
      }
    }
  }
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v8);
}
// 4F1674: variable 'v8' is possibly undefined
// 66A690: using guessed type void *off_66A690;

//----- (004F1684) --------------------------------------------------------
bool __fastcall CTaskComplexUseSequence::MakeAbortable(
        CTaskComplexUseSequence *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  int v6; // r0
  bool v7; // r5
  bool v8; // zf
  int m_id; // r1
  CTaskComplexSequence *v10; // r0
  int v11; // r2
  CTaskComplexSequence *v12; // r1
  bool *p_m_bCanBeEmptied; // r1
  _BOOL4 m_bCanBeEmptied; // t1

  v6 = (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
        + 7))(
         this->m_pSubTask,
         pPed,
         iPriority,
         pEvent);
  v7 = v6;
  if ( pEvent && v6 == 1 && (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 9 )
  {
    v8 = LOBYTE(pEvent[5]._vptr$CEvent) == 0;
    if ( LOBYTE(pEvent[5]._vptr$CEvent) )
      v8 = !*(&pEvent->m_bIsPersistent + 1);
    if ( !v8 )
    {
      m_id = this->m_id;
      v10 = &CTaskSequences::ms_taskSequence[m_id];
      v11 = v10->m_iRefCount - 1;
      v10->m_iRefCount = v11;
      if ( !v11 )
      {
        v12 = &CTaskSequences::ms_taskSequence[m_id];
        m_bCanBeEmptied = v12->m_bCanBeEmptied;
        p_m_bCanBeEmptied = &v12->m_bCanBeEmptied;
        if ( m_bCanBeEmptied )
        {
          *p_m_bCanBeEmptied = 0;
          CTaskComplexSequence::Flush(v10);
        }
      }
      this->m_id = -1;
    }
  }
  return v7;
}

//----- (004F1700) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseSequence::CreateNextSubTask(CTaskComplexUseSequence *this, CPed *pPed)
{
  int m_id; // r12
  int m_iProgress1; // r2
  int v4; // lr
  CTaskComplexSequence *v5; // r1
  int *p_m_iRepeatMode; // r1
  int v7; // r3
  int m_iRepeatMode; // t1
  int m_iRepeatProgress; // r2
  CTask *v10; // r0

  m_id = this->m_id;
  if ( m_id != -1 )
  {
    m_iProgress1 = this->m_iProgress1;
    v4 = m_iProgress1 + 1;
    this->m_iProgress1 = m_iProgress1 + 1;
    v5 = &CTaskSequences::ms_taskSequence[m_id];
    m_iRepeatMode = v5->m_iRepeatMode;
    p_m_iRepeatMode = &v5->m_iRepeatMode;
    v7 = m_iRepeatMode;
    if ( m_iRepeatMode )
    {
      if ( m_iProgress1 == 7 || !CTaskSequences::ms_taskSequence[m_id].m_tasks[v4] )
      {
        m_iRepeatProgress = this->m_iRepeatProgress;
        v4 = 0;
        this->m_iProgress1 = 0;
        this->m_iRepeatProgress = m_iRepeatProgress + 1;
        v7 = *p_m_iRepeatMode;
        if ( *p_m_iRepeatMode == 1 )
          goto LABEL_9;
      }
      else if ( v7 == 1 )
      {
        goto LABEL_9;
      }
      if ( this->m_iRepeatProgress != v7 )
      {
LABEL_9:
        v10 = CTaskSequences::ms_taskSequence[m_id].m_tasks[v4];
        return (CTask *)(*((int (__fastcall **)(CTask *))v10->_vptr$CTask + 2))(v10);
      }
    }
    else if ( m_iProgress1 != 7 )
    {
      v10 = CTaskSequences::ms_taskSequence[m_id].m_tasks[v4];
      if ( v10 )
        return (CTask *)(*((int (__fastcall **)(CTask *))v10->_vptr$CTask + 2))(v10);
    }
  }
  return 0;
}

//----- (004F17B0) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseSequence::CreateFirstSubTask(CTaskComplexUseSequence *this, CPed *pPed)
{
  int m_id; // r0
  CTask *v4; // r0
  CTask *v5; // r4
  bool v6; // zf

  m_id = this->m_id;
  if ( m_id == -1 )
    return 0;
  v4 = CTaskSequences::ms_taskSequence[m_id].m_tasks[this->m_iProgress1];
  if ( !v4 )
    return 0;
  v5 = (CTask *)(*((int (__fastcall **)(CTask *))v4->_vptr$CTask + 2))(v4);
  v6 = v5 == 0;
  if ( v5 )
    v6 = this->m_iProgress2 == -1;
  if ( !v6 && (*((int (__fastcall **)(CTask *))v5->_vptr$CTask + 5))(v5) == 275 )
  {
    v5[2]._vptr$CTask = (int (**)(void))this->m_iProgress2;
    v5[2].m_pParent = (CTask *)-1;
  }
  return v5;
}

//----- (004F180C) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseSequence::ControlSubTask(CTaskComplexUseSequence *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (004F1810) --------------------------------------------------------
void __fastcall CTaskSimpleWaitUntilAreaCodesMatch::CTaskSimpleWaitUntilAreaCodesMatch(
        CTaskSimpleWaitUntilAreaCodesMatch *this,
        CPed *pTargetPed)
{
  CTaskSimple::CTaskSimple(this);
  *(_WORD *)&this->m_timer.m_bIsActive = 0;
  this->m_iDuration = 1000;
  this->m_fIdleBlendDelta = 8.0;
  *(_WORD *)&this->m_bForever = 1;
  this->m_timer.m_iStartTime = 0;
  this->m_timer.m_iDuration = 0;
  this->_vptr$CTask = (int (**)(void))&off_66A6CC;
  this->m_pTargetPed = pTargetPed;
  if ( pTargetPed )
    CEntity::RegisterReference(pTargetPed, &this->m_pTargetPed);
}
// 66A6CC: using guessed type void *;

//----- (004F185C) --------------------------------------------------------
void __fastcall CTaskSimpleWaitUntilAreaCodesMatch::~CTaskSimpleWaitUntilAreaCodesMatch(
        CTaskSimpleWaitUntilAreaCodesMatch *this)
{
  CPed *m_pTargetPed; // r0
  CEntity **p_m_pTargetPed; // r1
  void *v4; // r0

  p_m_pTargetPed = &this->m_pTargetPed;
  m_pTargetPed = this->m_pTargetPed;
  this->_vptr$CTask = (int (**)(void))&off_66A6CC;
  if ( m_pTargetPed )
    CEntity::CleanUpOldReference(m_pTargetPed, p_m_pTargetPed);
  CTask::~CTask(this);
  sub_197118(v4);
}
// 4F1884: variable 'v4' is possibly undefined
// 66A6CC: using guessed type void *off_66A6CC;

//----- (004F188C) --------------------------------------------------------
bool __fastcall CTaskSimpleWaitUntilAreaCodesMatch::ProcessPed(CTaskSimpleWaitUntilAreaCodesMatch *this, CPed *pPed)
{
  CPed *m_pTargetPed; // r2

  m_pTargetPed = this->m_pTargetPed;
  if ( !m_pTargetPed )
    return 1;
  if ( !CEntryExitManager::ms_exitEnterState )
  {
    if ( m_pTargetPed->m_areaCode != pPed->m_areaCode )
    {
      if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
        return CTaskSimpleStandStill::ProcessPed(this, pPed);
      return 0;
    }
    return 1;
  }
  if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
    return CTaskSimpleStandStill::ProcessPed(this, pPed);
  return 0;
}

//----- (004F18D0) --------------------------------------------------------
bool __fastcall CTaskSimpleWaitUntilLeaderAreaCodesMatch::MakeAbortable(
        CTaskSimpleWaitUntilLeaderAreaCodesMatch *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  if ( iPriority != 2 )
    return 0;
  *(_DWORD *)&pPed->m_nFlags |= 1u;
  return 1;
}

//----- (004F18E4) --------------------------------------------------------
bool __fastcall CTaskSimpleWaitUntilLeaderAreaCodesMatch::ProcessPed(
        CTaskSimpleWaitUntilLeaderAreaCodesMatch *this,
        CPed *pPed)
{
  CPed *m_pTargetPed; // r0
  CPedIntelligence *m_pPedIntelligence; // r6
  int v7; // r0

  m_pTargetPed = this->m_pTargetPed;
  if ( !m_pTargetPed )
    goto LABEL_7;
  if ( !CEntryExitManager::ms_exitEnterState )
  {
    if ( m_pTargetPed->m_areaCode != pPed->m_areaCode
      && (*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 || !CTaskSimpleStandStill::ProcessPed(this, pPed)) )
    {
      goto LABEL_10;
    }
LABEL_7:
    *(_DWORD *)&pPed->m_nFlags |= 1u;
    return 1;
  }
  if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) && CTaskSimpleStandStill::ProcessPed(this, pPed) )
    goto LABEL_7;
LABEL_10:
  if ( !this->m_b )
  {
    m_pPedIntelligence = pPed->m_pPedIntelligence;
    v7 = (*((int (__fastcall **)(CTaskSimpleWaitUntilLeaderAreaCodesMatch *))this->_vptr$CTask + 5))(this);
    if ( CTaskManager::FindActiveTaskByType(&m_pPedIntelligence->m_taskManager, v7) )
    {
      this->m_b = 1;
      *(_DWORD *)&pPed->m_nFlags &= ~1u;
    }
  }
  return 0;
}

//----- (004F197C) --------------------------------------------------------
CTask *__fastcall CScriptedBrainTaskStore::SetTask(CPed *pPed, CTask *pTask)
{
  int v3; // r2
  CTask **p_m_pTask; // r5
  int v5; // r1
  CPed *v6; // r3
  CScriptedBrainTaskStoreEntry *v7; // r5
  CTask *v8; // r0
  CTask *m_pTask; // t1
  CTask *result; // r0

  v3 = -1;
  p_m_pTask = &CScriptedBrainTaskStore::ms_entries[0].m_pTask;
  v5 = -1;
  do
  {
    v6 = (CPed *)*(p_m_pTask - 3);
    if ( v6 == pPed )
    {
      v8 = *p_m_pTask;
      goto LABEL_9;
    }
    ++v3;
    p_m_pTask += 4;
    if ( !((unsigned int)v6 | ~v5) )
      v5 = v3;
  }
  while ( v3 < 47 );
  if ( v5 != -1 )
  {
    v7 = &CScriptedBrainTaskStore::ms_entries[v5];
    v7->m_pPed = pPed;
    CEntity::RegisterReference(pPed, &v7->m_pPed);
    m_pTask = v7->m_pTask;
    p_m_pTask = &v7->m_pTask;
    v8 = m_pTask;
LABEL_9:
    if ( v8 )
      (*((void (__fastcall **)(CTask *))v8->_vptr$CTask + 1))(v8);
    result = pTask;
    *p_m_pTask = pTask;
    return result;
  }
  if ( pTask )
    (*((void (__fastcall **)(CTask *))pTask->_vptr$CTask + 1))(pTask);
  return 0;
}

//----- (004F19F8) --------------------------------------------------------
CTask *__fastcall CScriptedBrainTaskStore::GetTask(const CPed *pPed)
{
  int v1; // r2
  CTask **p_m_pTask; // r1

  v1 = -1;
  p_m_pTask = &CScriptedBrainTaskStore::ms_entries[0].m_pTask;
  do
  {
    if ( *(p_m_pTask - 3) == (CTask *)pPed )
      return *p_m_pTask;
    ++v1;
    p_m_pTask += 4;
  }
  while ( v1 < 47 );
  return 0;
}

//----- (004F1A24) --------------------------------------------------------
void __fastcall CScriptedBrainTaskStore::Clear(CTask *pTask)
{
  CScriptedBrainTaskStoreEntry *v1; // r4
  int v2; // r1
  CEntity *m_pPed; // r0

  v1 = CScriptedBrainTaskStore::ms_entries;
  v2 = -1;
  while ( v1->m_pTask != pTask )
  {
    ++v2;
    ++v1;
    if ( v2 >= 47 )
      return;
  }
  if ( pTask )
    (*((void (__fastcall **)(CTask *))pTask->_vptr$CTask + 1))(pTask);
  m_pPed = v1->m_pPed;
  v1->m_pTask = 0;
  if ( m_pPed )
  {
    CEntity::CleanUpOldReference(m_pPed, &v1->m_pPed);
    v1->m_pPed = 0;
  }
}

//----- (004F1A68) --------------------------------------------------------
void __fastcall CTaskComplexUseScriptedBrain::CTaskComplexUseScriptedBrain(
        CTaskComplexUseScriptedBrain *this,
        const unsigned __int8 *pName)
{
  CTaskComplex::CTaskComplex(this);
  this->m_bIsAborting = 0;
  this->m_pTaskBeingPerformed = 0;
  this->_vptr$CTask = (int (**)(void))&off_66A700;
  strcpy((char *)this->m_name, (const char *)pName);
}
// 66A700: using guessed type void *off_66A700;

//----- (004F1A98) --------------------------------------------------------
void __fastcall CTaskComplexUseScriptedBrain::~CTaskComplexUseScriptedBrain(CTaskComplexUseScriptedBrain *this)
{
  CTask *m_pTaskBeingPerformed; // r0
  CScriptedBrainTaskStoreEntry *v3; // r5
  int v4; // r1
  CEntity *m_pPed; // r0

  m_pTaskBeingPerformed = this->m_pTaskBeingPerformed;
  this->_vptr$CTask = (int (**)(void))&off_66A700;
  if ( m_pTaskBeingPerformed )
  {
    v3 = CScriptedBrainTaskStore::ms_entries;
    v4 = -1;
    while ( v3->m_pTask != m_pTaskBeingPerformed )
    {
      ++v4;
      ++v3;
      if ( v4 >= 47 )
        goto LABEL_8;
    }
    (*((void (__fastcall **)(CTask *))m_pTaskBeingPerformed->_vptr$CTask + 1))(m_pTaskBeingPerformed);
    m_pPed = v3->m_pPed;
    v3->m_pTask = 0;
    if ( m_pPed )
    {
      CEntity::CleanUpOldReference(m_pPed, &v3->m_pPed);
      v3->m_pPed = 0;
    }
LABEL_8:
    this->m_pTaskBeingPerformed = 0;
  }
  sub_18EDB4(this);
}
// 66A700: using guessed type void *off_66A700;

//----- (004F1AFC) --------------------------------------------------------
void __fastcall CTaskComplexUseScriptedBrain::~CTaskComplexUseScriptedBrain(CTaskComplexUseScriptedBrain *this)
{
  CTask *m_pTaskBeingPerformed; // r0
  CScriptedBrainTaskStoreEntry *v3; // r5
  int v4; // r1
  CEntity *m_pPed; // r0
  void *v6; // r0

  m_pTaskBeingPerformed = this->m_pTaskBeingPerformed;
  this->_vptr$CTask = (int (**)(void))&off_66A700;
  if ( m_pTaskBeingPerformed )
  {
    v3 = CScriptedBrainTaskStore::ms_entries;
    v4 = -1;
    while ( v3->m_pTask != m_pTaskBeingPerformed )
    {
      ++v4;
      ++v3;
      if ( v4 >= 47 )
        goto LABEL_8;
    }
    (*((void (__fastcall **)(CTask *))m_pTaskBeingPerformed->_vptr$CTask + 1))(m_pTaskBeingPerformed);
    m_pPed = v3->m_pPed;
    v3->m_pTask = 0;
    if ( m_pPed )
    {
      CEntity::CleanUpOldReference(m_pPed, &v3->m_pPed);
      v3->m_pPed = 0;
    }
LABEL_8:
    this->m_pTaskBeingPerformed = 0;
  }
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v6);
}
// 4F1B56: variable 'v6' is possibly undefined
// 66A700: using guessed type void *off_66A700;

//----- (004F1B64) --------------------------------------------------------
bool __fastcall CTaskComplexUseScriptedBrain::MakeAbortable(
        CTaskComplexUseScriptedBrain *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  int m_iAccumulatedTime; // r0

  if ( !pEvent )
    return (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
            + 7))(
             this->m_pSubTask,
             pPed,
             iPriority,
             pEvent);
  if ( (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 32 )
    return (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
            + 7))(
             this->m_pSubTask,
             pPed,
             iPriority,
             pEvent);
  m_iAccumulatedTime = pEvent[1].m_iAccumulatedTime;
  if ( !m_iAccumulatedTime
    || (*(int (__fastcall **)(int))(*(_DWORD *)m_iAccumulatedTime + 20))(m_iAccumulatedTime) != 233 )
  {
    return (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
            + 7))(
             this->m_pSubTask,
             pPed,
             iPriority,
             pEvent);
  }
  this->m_bIsAborting = 1;
  return 0;
}

//----- (004F1BB4) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseScriptedBrain::CreateNextSubTask(CTaskComplexUseScriptedBrain *this, CPed *pPed)
{
  CTask *m_pTaskBeingPerformed; // r0
  CScriptedBrainTaskStoreEntry *v5; // r6
  int v6; // r1
  CEntity *m_pPed; // r0
  CTask *result; // r0
  int v9; // r1
  CTask **p_m_pTask; // r0
  CTask *v11; // r0
  CTaskSimple *v12; // r0

  m_pTaskBeingPerformed = this->m_pTaskBeingPerformed;
  if ( m_pTaskBeingPerformed )
  {
    v5 = CScriptedBrainTaskStore::ms_entries;
    v6 = -1;
    while ( v5->m_pTask != m_pTaskBeingPerformed )
    {
      ++v6;
      ++v5;
      if ( v6 >= 47 )
        goto LABEL_8;
    }
    (*((void (__fastcall **)(CTask *))m_pTaskBeingPerformed->_vptr$CTask + 1))(m_pTaskBeingPerformed);
    m_pPed = v5->m_pPed;
    v5->m_pTask = 0;
    if ( m_pPed )
    {
      CEntity::CleanUpOldReference(m_pPed, &v5->m_pPed);
      v5->m_pPed = 0;
    }
LABEL_8:
    this->m_pTaskBeingPerformed = 0;
  }
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 1801 )
    return 0;
  v9 = -1;
  p_m_pTask = &CScriptedBrainTaskStore::ms_entries[0].m_pTask;
  while ( *(p_m_pTask - 3) != (CTask *)pPed )
  {
    ++v9;
    p_m_pTask += 4;
    if ( v9 >= 47 )
    {
      this->m_pTaskBeingPerformed = 0;
      goto LABEL_17;
    }
  }
  v11 = *p_m_pTask;
  this->m_pTaskBeingPerformed = v11;
  if ( v11 )
    return (CTask *)(*((int (__fastcall **)(CTask *))v11->_vptr$CTask + 2))(v11);
LABEL_17:
  v12 = (CTaskSimple *)CTask::operator new(0x18u);
  CTaskSimple::CTaskSimple(v12);
  LOWORD(result[2]._vptr$CTask) = 0;
  result[2].m_pParent = (CTask *)(elf_hash_bucket + 1748);
  result[1]._vptr$CTask = 0;
  result[1].m_pParent = 0;
  result->_vptr$CTask = (int (**)(void))&off_665750;
  return result;
}
// 4F1C5E: variable 'result' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 665750: using guessed type void *off_665750;

//----- (004F1C80) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseScriptedBrain::CreateFirstSubTask(CTaskComplexUseScriptedBrain *this, CPed *pPed)
{
  int v2; // r3
  CTask **p_m_pTask; // r12
  CTask *v4; // r1
  CTask *result; // r0
  CTaskSimple *v6; // r0

  v2 = -1;
  p_m_pTask = &CScriptedBrainTaskStore::ms_entries[0].m_pTask;
  while ( *(p_m_pTask - 3) != (CTask *)pPed )
  {
    ++v2;
    p_m_pTask += 4;
    if ( v2 >= 47 )
    {
      this->m_pTaskBeingPerformed = 0;
      goto LABEL_7;
    }
  }
  v4 = *p_m_pTask;
  this->m_pTaskBeingPerformed = *p_m_pTask;
  if ( v4 )
    return (CTask *)(*((int (__fastcall **)(CTask *))v4->_vptr$CTask + 2))(v4);
LABEL_7:
  v6 = (CTaskSimple *)CTask::operator new(0x18u);
  CTaskSimple::CTaskSimple(v6);
  LOWORD(result[2]._vptr$CTask) = 0;
  result[2].m_pParent = (CTask *)(elf_hash_bucket + 1748);
  result[1]._vptr$CTask = 0;
  result[1].m_pParent = 0;
  result->_vptr$CTask = (int (**)(void))&off_665750;
  return result;
}
// 4F1CCC: variable 'result' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 665750: using guessed type void *off_665750;

//----- (004F1CE8) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseScriptedBrain::ControlSubTask(CTaskComplexUseScriptedBrain *this, CPed *pPed)
{
  int v3; // r2
  CTask **p_m_pTask; // r0
  CTask *v5; // r5
  CTask *result; // r0

  v3 = -1;
  p_m_pTask = &CScriptedBrainTaskStore::ms_entries[0].m_pTask;
  while ( *(p_m_pTask - 3) != (CTask *)pPed )
  {
    ++v3;
    p_m_pTask += 4;
    if ( v3 >= 47 )
    {
      v5 = 0;
      goto LABEL_6;
    }
  }
  v5 = *p_m_pTask;
LABEL_6:
  result = this->m_pSubTask;
  if ( v5 != this->m_pTaskBeingPerformed )
  {
    if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))result->_vptr$CTask + 7))(result, pPed, 1, 0) == 1 )
    {
      this->m_pTaskBeingPerformed = v5;
      if ( v5 )
        return (CTask *)(*((int (__fastcall **)(CTask *))v5->_vptr$CTask + 2))(v5);
      else
        return 0;
    }
    else
    {
      return this->m_pSubTask;
    }
  }
  return result;
}

//----- (004F1D4C) --------------------------------------------------------
void __fastcall CTaskSimpleWaitUntilAreaCodesMatch::~CTaskSimpleWaitUntilAreaCodesMatch(
        CTaskSimpleWaitUntilAreaCodesMatch *this)
{
  CPed *m_pTargetPed; // r0
  CEntity **p_m_pTargetPed; // r1

  p_m_pTargetPed = &this->m_pTargetPed;
  m_pTargetPed = this->m_pTargetPed;
  this->_vptr$CTask = (int (**)(void))&off_66A6CC;
  if ( m_pTargetPed )
    CEntity::CleanUpOldReference(m_pTargetPed, p_m_pTargetPed);
  sub_1A01F4(this);
}
// 66A6CC: using guessed type void *off_66A6CC;

//----- (004F1D78) --------------------------------------------------------
void __fastcall CTaskComplexUseEffect::~CTaskComplexUseEffect(CTaskComplexUseEffect *this)
{
  CPed *m_pPed; // r1
  bool v3; // zf
  CPedAttractorManager *PedAttractorManager; // r0
  CEntity *m_pEntity; // r0

  m_pPed = this->m_pPed;
  v3 = m_pPed == 0;
  this->_vptr$CTask = (int (**)(void))&off_66A0F0;
  if ( m_pPed )
    v3 = this->m_pAttractor == 0;
  if ( !v3 )
  {
    PedAttractorManager = GetPedAttractorManager();
    CPedAttractorManager::DeRegisterPed(PedAttractorManager, this->m_pPed, this->m_pAttractor);
  }
  m_pEntity = this->m_pEntity;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, &this->m_pEntity);
  sub_18EDB4(this);
}
// 66A0F0: using guessed type void *off_66A0F0;

//----- (004F1DC0) --------------------------------------------------------
void __fastcall CTaskSimpleOnEscalator::~CTaskSimpleOnEscalator(CTaskSimpleOnEscalator *this)
{
  void *v1; // r0

  CTask::~CTask(this);
  sub_197118(v1);
}
// 4F1DCC: variable 'v1' is possibly undefined

//----- (004F1DD0) --------------------------------------------------------
CTask *__fastcall CTaskSimpleOnEscalator::Clone(const CTaskSimpleOnEscalator *this)
{
  CTaskSimple *v1; // r0
  CTask *result; // r0

  v1 = (CTaskSimple *)CTask::operator new(0x20u);
  CTaskSimple::CTaskSimple(v1);
  *(int (***)(void))((char *)&result[2]._vptr$CTask + 2) = 0;
  *(CTask **)((char *)&result[1].m_pParent + 2) = 0;
  result[3].m_pParent = (CTask *)1090519040;
  LOWORD(result[3]._vptr$CTask) = 1;
  result[1]._vptr$CTask = 0;
  result[1].m_pParent = 0;
  result->_vptr$CTask = (int (**)(void))&off_66A73C;
  return result;
}
// 4F1DE6: variable 'result' is possibly undefined
// 66A73C: using guessed type void *off_66A73C;
// 6777B8: using guessed type void *`vtable for'CTaskSimpleOnEscalator;

//----- (004F1E08) --------------------------------------------------------
int __fastcall CTaskSimpleOnEscalator::GetTaskType(const CTaskSimpleOnEscalator *this)
{
  return 1308;
}

//----- (004F1E10) --------------------------------------------------------
bool __fastcall CTaskSimpleStandStill::MakeAbortable(
        CTaskSimpleStandStill *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  int v5; // r1

  if ( !iPriority )
  {
    v5 = CTimer::m_snTimeInMilliseconds;
    this->m_timer.m_bIsActive = 1;
    this->m_timer.m_iStartTime = v5;
    this->m_timer.m_iDuration = -1;
  }
  return 1;
}

//----- (004F1E34) --------------------------------------------------------
void __fastcall CTaskSimpleOnEscalator::Serialize(CTaskSimpleOnEscalator *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleOnEscalator *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleOnEscalator *))this->_vptr$CTask + 5))(this) != 1308 )
  {
    v4 = (*((int (__fastcall **)(CTaskSimpleOnEscalator *))this->_vptr$CTask + 5))(this);
    sub_1941C4(1308, v4);
  }
}

//----- (004F1EA4) --------------------------------------------------------
void __fastcall CTaskComplexBeStill::~CTaskComplexBeStill(CTaskComplexBeStill *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 4F1EB0: variable 'v1' is possibly undefined

//----- (004F1EB4) --------------------------------------------------------
CTask *__fastcall CTaskComplexBeStill::Clone(const CTaskComplexBeStill *this)
{
  CTaskComplex *v1; // r0
  CTask *result; // r0

  v1 = (CTaskComplex *)CTask::operator new(0xCu);
  CTaskComplex::CTaskComplex(v1);
  result->_vptr$CTask = (int (**)(void))&off_66A770;
  return result;
}
// 4F1ECA: variable 'result' is possibly undefined
// 66A770: using guessed type void *off_66A770;

//----- (004F1ED4) --------------------------------------------------------
int __fastcall CTaskComplexBeStill::GetTaskType(const CTaskComplexBeStill *this)
{
  return 274;
}

//----- (004F1EDC) --------------------------------------------------------
void __fastcall CTaskComplexBeStill::Serialize(CTaskComplexBeStill *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexBeStill *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexBeStill *))this->_vptr$CTask + 5))(this) != 274 )
  {
    v4 = (*((int (__fastcall **)(CTaskComplexBeStill *))this->_vptr$CTask + 5))(this);
    sub_1941C4(274, v4);
  }
}

//----- (004F1F48) --------------------------------------------------------
void __fastcall CTaskSimpleTogglePedThreatScanner::~CTaskSimpleTogglePedThreatScanner(
        CTaskSimpleTogglePedThreatScanner *this)
{
  void *v1; // r0

  CTask::~CTask(this);
  sub_197118(v1);
}
// 4F1F54: variable 'v1' is possibly undefined

//----- (004F1F58) --------------------------------------------------------
CTask *__fastcall CTaskSimpleTogglePedThreatScanner::Clone(const CTaskSimpleTogglePedThreatScanner *this)
{
  CTaskSimple *v2; // r0
  bool m_bActivatedDuringScriptCommands; // r5
  CTask *result; // r0

  v2 = (CTaskSimple *)CTask::operator new(0xCu);
  m_bActivatedDuringScriptCommands = this->m_bActivatedDuringScriptCommands;
  LOWORD(this) = *(_WORD *)&this->m_bActivatedEverywhere;
  CTaskSimple::CTaskSimple(v2);
  LOWORD(result[1]._vptr$CTask) = (_WORD)this;
  BYTE2(result[1]._vptr$CTask) = m_bActivatedDuringScriptCommands;
  result->_vptr$CTask = (int (**)(void))&off_66A7AC;
  return result;
}
// 4F1F6E: variable 'result' is possibly undefined
// 66A7AC: using guessed type void *off_66A7AC;

//----- (004F1F80) --------------------------------------------------------
int __fastcall CTaskSimpleTogglePedThreatScanner::GetTaskType(const CTaskSimpleTogglePedThreatScanner *this)
{
  return 1301;
}

//----- (004F1F86) --------------------------------------------------------
bool __fastcall CTaskSimpleTogglePedThreatScanner::MakeAbortable(
        CTaskSimpleTogglePedThreatScanner *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 0;
}

//----- (004F1F8C) --------------------------------------------------------
void __fastcall CTaskSimpleTogglePedThreatScanner::Serialize(CTaskSimpleTogglePedThreatScanner *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleTogglePedThreatScanner *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleTogglePedThreatScanner *))this->_vptr$CTask + 5))(this) == 1301 )
  {
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(&this->m_bActivatedEverywhere, 1);
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(&this->m_bActivatedInVehicle, 1);
    if ( UseDataFence )
      AddDataFence();
    sub_19E9A8(&this->m_bActivatedDuringScriptCommands, 1);
  }
  else
  {
    v4 = (*((int (__fastcall **)(CTaskSimpleTogglePedThreatScanner *))this->_vptr$CTask + 5))(this);
    sub_1941C4(1301, v4);
  }
}

//----- (004F2058) --------------------------------------------------------
void __fastcall CTaskSimpleTriggerEvent::~CTaskSimpleTriggerEvent(CTaskSimpleTriggerEvent *this)
{
  CEvent *m_pEvent; // r0

  m_pEvent = this->m_pEvent;
  this->_vptr$CTask = (int (**)(void))&off_66A7E0;
  if ( m_pEvent )
    (*((void (__fastcall **)(CEvent *))m_pEvent->_vptr$CEvent + 1))(m_pEvent);
  sub_1A01F4(this);
}
// 66A7E0: using guessed type void *;

//----- (004F2084) --------------------------------------------------------
void __fastcall CTaskSimpleTriggerEvent::~CTaskSimpleTriggerEvent(CTaskSimpleTriggerEvent *this)
{
  CEvent *m_pEvent; // r0
  void *v3; // r0

  m_pEvent = this->m_pEvent;
  this->_vptr$CTask = (int (**)(void))&off_66A7E0;
  if ( m_pEvent )
    (*((void (__fastcall **)(CEvent *))m_pEvent->_vptr$CEvent + 1))(m_pEvent);
  CTask::~CTask(this);
  sub_197118(v3);
}
// 4F20AA: variable 'v3' is possibly undefined
// 66A7E0: using guessed type void *off_66A7E0;

//----- (004F20B4) --------------------------------------------------------
CTask *__fastcall CTaskSimpleTriggerEvent::Clone(const CTaskSimpleTriggerEvent *this)
{
  CTaskSimple *v2; // r5
  int v3; // r4

  v2 = (CTaskSimple *)CTask::operator new(0xCu);
  v3 = (*((int (__fastcall **)(CEvent *))this->m_pEvent->_vptr$CEvent + 5))(this->m_pEvent);
  CTaskSimple::CTaskSimple(v2);
  v2[1]._vptr$CTask = (int (**)(void))v3;
  v2->_vptr$CTask = (int (**)(void))&off_66A7E0;
  return v2;
}
// 66A7E0: using guessed type void *off_66A7E0;

//----- (004F20E8) --------------------------------------------------------
int __fastcall CTaskSimpleTriggerEvent::GetTaskType(const CTaskSimpleTriggerEvent *this)
{
  return 252;
}

//----- (004F20EC) --------------------------------------------------------
bool __fastcall CTaskSimpleTriggerEvent::MakeAbortable(
        CTaskSimpleTriggerEvent *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 0;
}

//----- (004F20F0) --------------------------------------------------------
int __fastcall CTaskSimpleIKChain::GetTaskType(const CTaskSimpleIKChain *this)
{
  return 264;
}

//----- (004F20F6) --------------------------------------------------------
void __fastcall CTaskSimpleSetCharDecisionMaker::~CTaskSimpleSetCharDecisionMaker(
        CTaskSimpleSetCharDecisionMaker *this)
{
  void *v1; // r0

  CTask::~CTask(this);
  sub_197118(v1);
}
// 4F2102: variable 'v1' is possibly undefined

//----- (004F2108) --------------------------------------------------------
CTask *__fastcall CTaskSimpleSetCharDecisionMaker::Clone(const CTaskSimpleSetCharDecisionMaker *this)
{
  CTaskSimple *v2; // r0
  int (**m_iDM)(void); // r4
  CTask *result; // r0

  v2 = (CTaskSimple *)CTask::operator new(0xCu);
  m_iDM = (int (**)(void))this->m_iDM;
  CTaskSimple::CTaskSimple(v2);
  result[1]._vptr$CTask = m_iDM;
  result->_vptr$CTask = (int (**)(void))&off_66A814;
  return result;
}
// 4F211C: variable 'result' is possibly undefined
// 66A814: using guessed type void *;
// 67678C: using guessed type void *`vtable for'CTaskSimpleSetCharDecisionMaker;

//----- (004F212C) --------------------------------------------------------
int __fastcall CTaskSimpleSetCharDecisionMaker::GetTaskType(const CTaskSimpleSetCharDecisionMaker *this)
{
  return 271;
}

//----- (004F2132) --------------------------------------------------------
bool __fastcall CTaskSimpleSetCharDecisionMaker::MakeAbortable(
        CTaskSimpleSetCharDecisionMaker *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 0;
}

//----- (004F2138) --------------------------------------------------------
void __fastcall CTaskSimpleSetCharDecisionMaker::Serialize(CTaskSimpleSetCharDecisionMaker *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  int v5; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleSetCharDecisionMaker *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleSetCharDecisionMaker *))this->_vptr$CTask + 5))(this) == 271 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(4u);
    *v4 = this->m_iDM;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    j_free(v4);
  }
  else
  {
    v5 = (*((int (__fastcall **)(CTaskSimpleSetCharDecisionMaker *))this->_vptr$CTask + 5))(this);
    sub_1941C4(271, v5);
  }
}

//----- (004F21D8) --------------------------------------------------------
void __fastcall CTaskSimpleWaitUntilLeaderAreaCodesMatch::~CTaskSimpleWaitUntilLeaderAreaCodesMatch(
        CTaskSimpleWaitUntilLeaderAreaCodesMatch *this)
{
  CPed *m_pTargetPed; // r0
  CEntity **p_m_pTargetPed; // r1
  void *v4; // r0

  p_m_pTargetPed = &this->m_pTargetPed;
  m_pTargetPed = this->m_pTargetPed;
  this->_vptr$CTask = (int (**)(void))&off_66A6CC;
  if ( m_pTargetPed )
    CEntity::CleanUpOldReference(m_pTargetPed, p_m_pTargetPed);
  CTask::~CTask(this);
  sub_197118(v4);
}
// 4F2200: variable 'v4' is possibly undefined
// 66A6CC: using guessed type void *off_66A6CC;

//----- (004F2208) --------------------------------------------------------
CTask *__fastcall CTaskSimpleWaitUntilLeaderAreaCodesMatch::Clone(const CTaskSimpleWaitUntilLeaderAreaCodesMatch *this)
{
  void *v2; // r4
  CPed *m_pTargetPed; // r5

  v2 = CTask::operator new(0x38u);
  m_pTargetPed = this->m_pTargetPed;
  CTaskSimple::CTaskSimple((CTaskSimple *)v2);
  *((_WORD *)v2 + 10) = 0;
  *((_DWORD *)v2 + 7) = 1090519040;
  *((_WORD *)v2 + 12) = 1;
  *((_DWORD *)v2 + 2) = 1000;
  *((_DWORD *)v2 + 3) = 0;
  *((_DWORD *)v2 + 4) = 0;
  *(_DWORD *)v2 = &off_66A6CC;
  *((_DWORD *)v2 + 8) = m_pTargetPed;
  if ( m_pTargetPed )
    CEntity::RegisterReference(m_pTargetPed, (CEntity **)v2 + 8);
  *((_BYTE *)v2 + 36) = 0;
  *((_BYTE *)v2 + 52) = 0;
  *(_DWORD *)v2 = &off_66A848;
  return (CTask *)v2;
}
// 66A6CC: using guessed type void *off_66A6CC;
// 66A848: using guessed type void *off_66A848;

//----- (004F2278) --------------------------------------------------------
int __fastcall CTaskSimpleWaitUntilLeaderAreaCodesMatch::GetTaskType(
        const CTaskSimpleWaitUntilLeaderAreaCodesMatch *this)
{
  return 278;
}

//----- (004F2280) --------------------------------------------------------
void __fastcall CTaskSimpleWaitUntilLeaderAreaCodesMatch::Serialize(CTaskSimpleWaitUntilLeaderAreaCodesMatch *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CPed *m_pTargetPed; // r0
  int v5; // r4
  _DWORD *v6; // r5
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r4

  v2 = (*((int (__fastcall **)(CTaskSimpleWaitUntilLeaderAreaCodesMatch *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleWaitUntilLeaderAreaCodesMatch *))this->_vptr$CTask + 5))(this) == 278 )
  {
    m_pTargetPed = this->m_pTargetPed;
    if ( m_pTargetPed )
    {
      v5 = GettPoolPedRef(m_pTargetPed);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    j_free(v7);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskSimpleWaitUntilLeaderAreaCodesMatch *))this->_vptr$CTask + 5))(this);
    sub_1941C4(278, v8);
  }
}

//----- (004F2350) --------------------------------------------------------
CTask *__fastcall CTaskSimpleStandStill::Clone(const CTaskSimpleStandStill *this)
{
  CTaskSimple *v2; // r0
  int (**m_iDuration)(void); // r5
  float m_fIdleBlendDelta; // r6
  CTask *result; // r0

  v2 = (CTaskSimple *)CTask::operator new(0x20u);
  m_iDuration = (int (**)(void))this->m_iDuration;
  m_fIdleBlendDelta = this->m_fIdleBlendDelta;
  LOWORD(this) = *(_WORD *)&this->m_bForever;
  CTaskSimple::CTaskSimple(v2);
  result[1]._vptr$CTask = m_iDuration;
  LOWORD(result[2].m_pParent) = 0;
  *(float *)&result[3].m_pParent = m_fIdleBlendDelta;
  LOWORD(result[3]._vptr$CTask) = (_WORD)this;
  result[1].m_pParent = 0;
  result[2]._vptr$CTask = 0;
  result->_vptr$CTask = (int (**)(void))&off_669BFC;
  return result;
}
// 4F236E: variable 'result' is possibly undefined
// 669BFC: using guessed type void *off_669BFC;

//----- (004F238C) --------------------------------------------------------
int __fastcall CTaskSimpleStandStill::GetTaskType(const CTaskSimpleStandStill *this)
{
  return 203;
}

//----- (004F2390) --------------------------------------------------------
void __fastcall CTaskSimpleStandStill::Serialize(CTaskSimpleStandStill *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleStandStill *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleStandStill *))this->_vptr$CTask + 5))(this) != 203 )
  {
    v4 = (*((int (__fastcall **)(CTaskSimpleStandStill *))this->_vptr$CTask + 5))(this);
    sub_1941C4(203, v4);
  }
}

//----- (004F23F8) --------------------------------------------------------
CTask *__fastcall CTaskSimpleSetStayInSamePlace::Clone(const CTaskSimpleSetStayInSamePlace *this)
{
  CTaskSimple *v2; // r0
  CTask *result; // r0

  v2 = (CTaskSimple *)CTask::operator new(0xCu);
  LOBYTE(this) = this->m_bStayInSamePlace;
  CTaskSimple::CTaskSimple(v2);
  LOBYTE(result[1]._vptr$CTask) = (_BYTE)this;
  result->_vptr$CTask = (int (**)(void))&off_669C30;
  return result;
}
// 4F240C: variable 'result' is possibly undefined
// 669C30: using guessed type void *off_669C30;

//----- (004F241C) --------------------------------------------------------
int __fastcall CTaskSimpleSetStayInSamePlace::GetTaskType(const CTaskSimpleSetStayInSamePlace *this)
{
  return 204;
}

//----- (004F2420) --------------------------------------------------------
bool __fastcall CTaskSimpleSetStayInSamePlace::MakeAbortable(
        CTaskSimpleSetStayInSamePlace *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 1;
}

//----- (004F2424) --------------------------------------------------------
void __fastcall CTaskSimpleSetStayInSamePlace::Serialize(CTaskSimpleSetStayInSamePlace *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleSetStayInSamePlace *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleSetStayInSamePlace *))this->_vptr$CTask + 5))(this) == 204 )
  {
    if ( UseDataFence )
      AddDataFence();
    sub_19E9A8(&this->m_bStayInSamePlace, 1);
  }
  else
  {
    v4 = (*((int (__fastcall **)(CTaskSimpleSetStayInSamePlace *))this->_vptr$CTask + 5))(this);
    sub_1941C4(204, v4);
  }
}

//----- (004F24AC) --------------------------------------------------------
CTask *__fastcall CTaskSimpleSetKindaStayInSamePlace::Clone(const CTaskSimpleSetKindaStayInSamePlace *this)
{
  CTaskSimple *v2; // r0
  CTask *result; // r0

  v2 = (CTaskSimple *)CTask::operator new(0xCu);
  LOBYTE(this) = this->m_bKindaStayInSamePlace;
  CTaskSimple::CTaskSimple(v2);
  LOBYTE(result[1]._vptr$CTask) = (_BYTE)this;
  result->_vptr$CTask = (int (**)(void))&off_669C64;
  return result;
}
// 4F24C0: variable 'result' is possibly undefined
// 669C64: using guessed type void *off_669C64;

//----- (004F24D0) --------------------------------------------------------
int __fastcall CTaskSimpleSetKindaStayInSamePlace::GetTaskType(const CTaskSimpleSetKindaStayInSamePlace *this)
{
  return 276;
}

//----- (004F24D6) --------------------------------------------------------
bool __fastcall CTaskSimpleSetKindaStayInSamePlace::MakeAbortable(
        CTaskSimpleSetKindaStayInSamePlace *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 1;
}

//----- (004F24DC) --------------------------------------------------------
void __fastcall CTaskSimpleSetKindaStayInSamePlace::Serialize(CTaskSimpleSetKindaStayInSamePlace *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleSetKindaStayInSamePlace *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleSetKindaStayInSamePlace *))this->_vptr$CTask + 5))(this) == 276 )
  {
    if ( UseDataFence )
      AddDataFence();
    sub_19E9A8(&this->m_bKindaStayInSamePlace, 1);
  }
  else
  {
    v4 = (*((int (__fastcall **)(CTaskSimpleSetKindaStayInSamePlace *))this->_vptr$CTask + 5))(this);
    sub_1941C4(276, v4);
  }
}

//----- (004F2568) --------------------------------------------------------
CTask *__fastcall CTaskSimpleDuckToggle::Clone(const CTaskSimpleDuckToggle *this)
{
  CTaskSimple *v2; // r0
  int (**m_nToggleType)(void); // r4
  CTask *result; // r0

  v2 = (CTaskSimple *)CTask::operator new(0xCu);
  m_nToggleType = (int (**)(void))this->m_nToggleType;
  CTaskSimple::CTaskSimple(v2);
  result[1]._vptr$CTask = m_nToggleType;
  result->_vptr$CTask = (int (**)(void))&off_669C98;
  return result;
}
// 4F257C: variable 'result' is possibly undefined
// 669C98: using guessed type void *off_669C98;

//----- (004F258C) --------------------------------------------------------
int __fastcall CTaskSimpleDuckToggle::GetTaskType(const CTaskSimpleDuckToggle *this)
{
  return 1306;
}

//----- (004F2592) --------------------------------------------------------
bool __fastcall CTaskSimpleDuckToggle::MakeAbortable(
        CTaskSimpleDuckToggle *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 1;
}

//----- (004F2598) --------------------------------------------------------
void __fastcall CTaskSimpleDuckToggle::Serialize(CTaskSimpleDuckToggle *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  int v5; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleDuckToggle *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleDuckToggle *))this->_vptr$CTask + 5))(this) == 1306 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(4u);
    *v4 = this->m_nToggleType;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    j_free(v4);
  }
  else
  {
    v5 = (*((int (__fastcall **)(CTaskSimpleDuckToggle *))this->_vptr$CTask + 5))(this);
    sub_1941C4(1306, v5);
  }
}

//----- (004F2638) --------------------------------------------------------
CTask *__fastcall CTaskSimpleDie::Clone(const CTaskSimpleDie *this)
{
  CAnimBlendHierarchy *m_pAnimHierarchy; // r5
  CTaskSimple *v3; // r0
  float m_fBlendDelta; // s16
  float m_fAnimSpeed; // s18
  CTask *m_flags; // r5
  int (**v7)(void); // r8
  CTask *result; // r0
  CTask *m_animID; // r4
  int (**v10)(void); // r6
  __int64 v11; // kr08_8
  char v12; // r2

  m_pAnimHierarchy = this->m_pAnimHierarchy;
  v3 = (CTaskSimple *)CTask::operator new(0x28u);
  m_fBlendDelta = this->m_fBlendDelta;
  m_fAnimSpeed = this->m_fAnimSpeed;
  if ( m_pAnimHierarchy )
  {
    m_flags = (CTask *)this->m_flags;
    v7 = (int (**)(void))this->m_pAnimHierarchy;
    CTaskSimple::CTaskSimple(v3);
    m_animID = (CTask *)(byte_9 + 6);
    v10 = 0;
  }
  else
  {
    v11 = *(_QWORD *)&this->m_animGroup;
    m_animID = (CTask *)this->m_animID;
    v10 = (int (**)(void))v11;
    CTaskSimple::CTaskSimple(v3);
    v7 = 0;
    m_flags = 0;
  }
  result[1]._vptr$CTask = v10;
  result[1].m_pParent = m_animID;
  result[2]._vptr$CTask = v7;
  result[2].m_pParent = m_flags;
  *(float *)&result[3]._vptr$CTask = m_fBlendDelta;
  *(float *)&result[3].m_pParent = m_fAnimSpeed;
  v12 = (char)result[4]._vptr$CTask;
  result[4].m_pParent = 0;
  LOBYTE(result[4]._vptr$CTask) = v12 & 0xFC;
  result->_vptr$CTask = (int (**)(void))&off_669CCC;
  return result;
}
// 4F2680: variable 'result' is possibly undefined
// 669CCC: using guessed type void *off_669CCC;

//----- (004F26B4) --------------------------------------------------------
int __fastcall CTaskSimpleDie::GetTaskType(const CTaskSimpleDie *this)
{
  return 212;
}

//----- (004F26B8) --------------------------------------------------------
CTask *__fastcall CTaskSimpleDieInCar::Clone(const CTaskSimpleDieInCar *this)
{
  CTaskSimple *v2; // r0
  CTask v3; // kr00_8
  CTask *result; // r0
  char v5; // r2

  v2 = (CTaskSimple *)CTask::operator new(0x28u);
  v3 = *(CTask *)&this->m_animGroup;
  CTaskSimple::CTaskSimple(v2);
  result[1] = v3;
  result[2]._vptr$CTask = 0;
  result[2].m_pParent = 0;
  result[3]._vptr$CTask = (int (**)(void))1082130432;
  result[3].m_pParent = 0;
  result[4].m_pParent = 0;
  v5 = (char)result[4]._vptr$CTask;
  result->_vptr$CTask = (int (**)(void))&off_669D00;
  LOBYTE(result[4]._vptr$CTask) = v5 & 0xFC;
  return result;
}
// 4F26D4: variable 'result' is possibly undefined
// 669D00: using guessed type void *off_669D00;

//----- (004F26FC) --------------------------------------------------------
int __fastcall CTaskSimpleDieInCar::GetTaskType(const CTaskSimpleDieInCar *this)
{
  return 214;
}

//----- (004F2700) --------------------------------------------------------
void __fastcall CTaskSimpleDieInCar::Serialize(CTaskSimpleDieInCar *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  AssocGroupId m_animGroup; // r6
  _DWORD *v5; // r5
  AnimationId m_animID; // r5
  _DWORD *v7; // r4
  int v8; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleDieInCar *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleDieInCar *))this->_vptr$CTask + 5))(this) == 214 )
  {
    m_animGroup = this->m_animGroup;
    if ( UseDataFence )
      AddDataFence();
    v5 = malloc(4u);
    *v5 = m_animGroup;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 4);
    free(v5);
    m_animID = this->m_animID;
    if ( UseDataFence )
      AddDataFence();
    v7 = malloc(4u);
    *v7 = m_animID;
    CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
    j_free(v7);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskSimpleDieInCar *))this->_vptr$CTask + 5))(this);
    sub_1941C4(214, v8);
  }
}

//----- (004F27C4) --------------------------------------------------------
CTask *__fastcall CTaskComplexDieInCar::Clone(const CTaskComplexDieInCar *this)
{
  CTaskComplex *v2; // r0
  CTask *m_eMeansOfDeath; // r4
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x1Cu);
  m_eMeansOfDeath = (CTask *)this->m_eMeansOfDeath;
  CTaskComplex::CTaskComplex(v2);
  result[1].m_pParent = m_eMeansOfDeath;
  LOWORD(result[3]._vptr$CTask) = 0;
  result[2]._vptr$CTask = 0;
  result[2].m_pParent = 0;
  result->_vptr$CTask = (int (**)(void))&off_669D34;
  return result;
}
// 4F27DA: variable 'result' is possibly undefined
// 669D34: using guessed type void *;

//----- (004F27F0) --------------------------------------------------------
int __fastcall CTaskComplexDieInCar::GetTaskType(const CTaskComplexDieInCar *this)
{
  return 215;
}

//----- (004F27F4) --------------------------------------------------------
bool __fastcall CTaskComplexDieInCar::MakeAbortable(
        CTaskComplexDieInCar *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  if ( (unsigned int)(iPriority - 1) <= 1 )
    return (*((int (__fastcall **)(CTask *, CPed *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
             this->m_pSubTask,
             pPed);
  else
    return 0;
}

//----- (004F2810) --------------------------------------------------------
void __fastcall CTaskComplexDieInCar::Serialize(CTaskComplexDieInCar *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  int v5; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexDieInCar *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexDieInCar *))this->_vptr$CTask + 5))(this) == 215 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(4u);
    *v4 = this->m_eMeansOfDeath;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    j_free(v4);
  }
  else
  {
    v5 = (*((int (__fastcall **)(CTaskComplexDieInCar *))this->_vptr$CTask + 5))(this);
    sub_1941C4(215, v5);
  }
}

//----- (004F28A8) --------------------------------------------------------
CTask *__fastcall CTaskSimpleDrown::Clone(const CTaskSimpleDrown *this)
{
  CTaskSimple *v1; // r0
  CTask *result; // r0
  char v3; // r1

  v1 = (CTaskSimple *)CTask::operator new(0x2Cu);
  CTaskSimple::CTaskSimple(v1);
  result[1]._vptr$CTask = 0;
  result[1].m_pParent = (CTask *)&dword_8C;
  result[2]._vptr$CTask = 0;
  result[2].m_pParent = 0;
  result[3]._vptr$CTask = (int (**)(void))1082130432;
  result[3].m_pParent = 0;
  result[4].m_pParent = 0;
  v3 = (char)result[4]._vptr$CTask;
  LOBYTE(result[5]._vptr$CTask) = 1;
  LOBYTE(result[4]._vptr$CTask) = v3 & 0xFC;
  result->_vptr$CTask = (int (**)(void))&off_669D70;
  return result;
}
// 4F28C2: variable 'result' is possibly undefined
// 8C: using guessed type int dword_8C;
// 669D70: using guessed type void *;

//----- (004F28F4) --------------------------------------------------------
int __fastcall CTaskSimpleDrown::GetTaskType(const CTaskSimpleDrown *this)
{
  return 213;
}

//----- (004F28F8) --------------------------------------------------------
void __fastcall CTaskSimpleDrown::Serialize(CTaskSimpleDrown *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleDrown *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleDrown *))this->_vptr$CTask + 5))(this) != 213 )
  {
    v4 = (*((int (__fastcall **)(CTaskSimpleDrown *))this->_vptr$CTask + 5))(this);
    sub_1941C4(213, v4);
  }
}

//----- (004F2960) --------------------------------------------------------
CTask *__fastcall CTaskSimpleDrownInCar::Clone(const CTaskSimpleDrownInCar *this)
{
  CTaskSimple *v1; // r0
  CTask *result; // r0

  v1 = (CTaskSimple *)CTask::operator new(8u);
  CTaskSimple::CTaskSimple(v1);
  result->_vptr$CTask = (int (**)(void))&off_669DA4;
  return result;
}
// 4F2976: variable 'result' is possibly undefined
// 669DA4: using guessed type void *off_669DA4;

//----- (004F2980) --------------------------------------------------------
int __fastcall CTaskSimpleDrownInCar::GetTaskType(const CTaskSimpleDrownInCar *this)
{
  return 216;
}

//----- (004F2984) --------------------------------------------------------
bool __fastcall CTaskSimpleDrownInCar::MakeAbortable(
        CTaskSimpleDrownInCar *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 0;
}

//----- (004F2988) --------------------------------------------------------
void __fastcall CTaskSimpleDrownInCar::Serialize(CTaskSimpleDrownInCar *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleDrownInCar *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleDrownInCar *))this->_vptr$CTask + 5))(this) != 216 )
  {
    v4 = (*((int (__fastcall **)(CTaskSimpleDrownInCar *))this->_vptr$CTask + 5))(this);
    sub_1941C4(216, v4);
  }
}

//----- (004F29F0) --------------------------------------------------------
CTask *__fastcall CTaskComplexDie::Clone(const CTaskComplexDie *this)
{
  CTaskComplex *v2; // r0
  char v3; // r5
  __int64 v4; // d8
  __int64 v5; // d9
  CTask *m_iFallToDeathDir; // r6
  float m_fAnimSpeed; // r4
  CTask *result; // r0
  char v9; // r2

  v2 = (CTaskComplex *)CTask::operator new(0x28u);
  v3 = *((_BYTE *)this + 32);
  v4 = *(_QWORD *)&this->m_eMeansOfDeath;
  v5 = *(_QWORD *)&this->m_animID;
  m_iFallToDeathDir = (CTask *)this->m_iFallToDeathDir;
  m_fAnimSpeed = this->m_fAnimSpeed;
  CTaskComplex::CTaskComplex(v2);
  *(_QWORD *)&result[1].m_pParent = v4;
  *(_QWORD *)&result[2].m_pParent = v5;
  *(float *)&result[3].m_pParent = m_fAnimSpeed;
  result[4].m_pParent = m_iFallToDeathDir;
  v9 = (char)result[4]._vptr$CTask;
  result->_vptr$CTask = (int (**)(void))&off_669DD8;
  LOBYTE(result[4]._vptr$CTask) = v3 & 7 | v9 & 0xF8;
  return result;
}
// 4F2A1A: variable 'result' is possibly undefined
// 669DD8: using guessed type void *off_669DD8;

//----- (004F2A50) --------------------------------------------------------
int __fastcall CTaskComplexDie::GetTaskType(const CTaskComplexDie *this)
{
  return 217;
}

//----- (004F2A54) --------------------------------------------------------
void __fastcall CTaskComplexDie::Serialize(CTaskComplexDie *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  _DWORD *v5; // r5
  _DWORD *v6; // r5
  float m_fBlendDelta; // r6
  float *v8; // r5
  float m_fAnimSpeed; // r6
  float *v10; // r5
  _DWORD *v11; // r5
  int v12; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexDie *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexDie *))this->_vptr$CTask + 5))(this) == 217 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(4u);
    *v4 = this->m_eMeansOfDeath;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    free(v4);
    if ( UseDataFence )
      AddDataFence();
    v5 = malloc(4u);
    *v5 = this->m_animGroup;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 4);
    free(v5);
    if ( UseDataFence )
      AddDataFence();
    v6 = malloc(4u);
    *v6 = this->m_animID;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
    free(v6);
    m_fBlendDelta = this->m_fBlendDelta;
    if ( UseDataFence )
      AddDataFence();
    v8 = (float *)malloc(4u);
    *v8 = m_fBlendDelta;
    CGenericGameStorage::_SaveDataToWorkBuffer(v8, 4);
    free(v8);
    m_fAnimSpeed = this->m_fAnimSpeed;
    if ( UseDataFence )
      AddDataFence();
    v10 = (float *)malloc(4u);
    *v10 = m_fAnimSpeed;
    CGenericGameStorage::_SaveDataToWorkBuffer(v10, 4);
    free(v10);
    if ( UseDataFence )
      AddDataFence();
    v11 = malloc(4u);
    *v11 = this->m_iFallToDeathDir;
    CGenericGameStorage::_SaveDataToWorkBuffer(v11, 4);
    j_free(v11);
  }
  else
  {
    v12 = (*((int (__fastcall **)(CTaskComplexDie *))this->_vptr$CTask + 5))(this);
    sub_1941C4(217, v12);
  }
}

//----- (004F2BD0) --------------------------------------------------------
CTask *__fastcall CTaskSimpleDead::Clone(const CTaskSimpleDead *this)
{
  CTaskSimple *v2; // r0
  char v3; // r5
  int (**m_iTimeOfDeath)(void); // r4
  CTask *result; // r0
  char v6; // r2

  v2 = (CTaskSimple *)CTask::operator new(0x10u);
  v3 = *((_BYTE *)this + 12);
  m_iTimeOfDeath = (int (**)(void))this->m_iTimeOfDeath;
  CTaskSimple::CTaskSimple(v2);
  result[1]._vptr$CTask = m_iTimeOfDeath;
  v6 = (int)result[1].m_pParent & 0xF8;
  result->_vptr$CTask = (int (**)(void))&off_669E14;
  LOBYTE(result[1].m_pParent) = v3 & 2 | v6 | 1;
  return result;
}
// 4F2BE6: variable 'result' is possibly undefined
// 669E14: using guessed type void *off_669E14;

//----- (004F2C08) --------------------------------------------------------
int __fastcall CTaskSimpleDead::GetTaskType(const CTaskSimpleDead *this)
{
  return 218;
}

//----- (004F2C0C) --------------------------------------------------------
bool __fastcall CTaskSimpleDead::MakeAbortable(
        CTaskSimpleDead *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 1;
}

//----- (004F2C10) --------------------------------------------------------
void __fastcall CTaskSimpleDead::Serialize(CTaskSimpleDead *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  int v5; // r0
  char pData[17]; // [sp+7h] [bp-11h] BYREF

  v2 = (*((int (__fastcall **)(CTaskSimpleDead *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleDead *))this->_vptr$CTask + 5))(this) == 218 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(4u);
    *v4 = this->m_iTimeOfDeath;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    free(v4);
    pData[0] = (*((_BYTE *)this + 12) & 2) != 0;
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(pData, 1);
  }
  else
  {
    v5 = (*((int (__fastcall **)(CTaskSimpleDead *))this->_vptr$CTask + 5))(this);
    sub_1941C4(218, v5);
  }
}
// 4F2C10: using guessed type char pData[17];

//----- (004F2CD4) --------------------------------------------------------
CTask *__fastcall CTaskSimpleTired::Clone(const CTaskSimpleTired *this)
{
  CTaskSimple *v2; // r0
  int (**m_iDuration)(void); // r4
  CTask *result; // r0

  v2 = (CTaskSimple *)CTask::operator new(0x1Cu);
  m_iDuration = (int (**)(void))this->m_iDuration;
  CTaskSimple::CTaskSimple(v2);
  result[1]._vptr$CTask = m_iDuration;
  LOWORD(result[2].m_pParent) = 0;
  result[3]._vptr$CTask = 0;
  result[1].m_pParent = 0;
  result[2]._vptr$CTask = 0;
  result->_vptr$CTask = (int (**)(void))&off_669E48;
  return result;
}
// 4F2CEA: variable 'result' is possibly undefined
// 669E48: using guessed type void *off_669E48;

//----- (004F2D04) --------------------------------------------------------
int __fastcall CTaskSimpleTired::GetTaskType(const CTaskSimpleTired *this)
{
  return 219;
}

//----- (004F2D08) --------------------------------------------------------
void __fastcall CTaskSimpleTired::Serialize(CTaskSimpleTired *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  int v5; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleTired *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleTired *))this->_vptr$CTask + 5))(this) == 219 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(4u);
    *v4 = this->m_iDuration;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    j_free(v4);
  }
  else
  {
    v5 = (*((int (__fastcall **)(CTaskSimpleTired *))this->_vptr$CTask + 5))(this);
    sub_1941C4(219, v5);
  }
}

//----- (004F2DA0) --------------------------------------------------------
CTask *__fastcall CTaskSimpleSitDown::Clone(const CTaskSimpleSitDown *this)
{
  CTaskSimple *v2; // r0
  CTask *result; // r0

  v2 = (CTaskSimple *)CTask::operator new(0x10u);
  LOBYTE(this) = this->m_sitOnStep;
  CTaskSimple::CTaskSimple(v2);
  LOBYTE(result[1]._vptr$CTask) = (_BYTE)this;
  BYTE1(result[1]._vptr$CTask) = 0;
  result[1].m_pParent = 0;
  result->_vptr$CTask = (int (**)(void))&off_669E7C;
  return result;
}
// 4F2DB6: variable 'result' is possibly undefined
// 669E7C: using guessed type void *off_669E7C;

//----- (004F2DCC) --------------------------------------------------------
int __fastcall CTaskSimpleSitDown::GetTaskType(const CTaskSimpleSitDown *this)
{
  return 220;
}

//----- (004F2DD0) --------------------------------------------------------
void __fastcall CTaskSimpleSitDown::Serialize(CTaskSimpleSitDown *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleSitDown *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleSitDown *))this->_vptr$CTask + 5))(this) == 220 )
  {
    if ( UseDataFence )
      AddDataFence();
    sub_19E9A8(&this->m_sitOnStep, 1);
  }
  else
  {
    v4 = (*((int (__fastcall **)(CTaskSimpleSitDown *))this->_vptr$CTask + 5))(this);
    sub_1941C4(220, v4);
  }
}

//----- (004F2E58) --------------------------------------------------------
CTask *__fastcall CTaskSimpleSitIdle::Clone(const CTaskSimpleSitIdle *this)
{
  CTaskSimple *v2; // r0
  CTask *m_iDuration; // r5
  CTask *result; // r0

  v2 = (CTaskSimple *)CTask::operator new(0x20u);
  m_iDuration = (CTask *)this->m_iDuration;
  LOBYTE(this) = this->m_sitOnStep;
  CTaskSimple::CTaskSimple(v2);
  LOBYTE(result[1]._vptr$CTask) = (_BYTE)this;
  result[1].m_pParent = m_iDuration;
  *(int (***)(void))((char *)&result[3]._vptr$CTask + 2) = 0;
  *(CTask **)((char *)&result[2].m_pParent + 2) = 0;
  result[2]._vptr$CTask = 0;
  result[2].m_pParent = 0;
  result->_vptr$CTask = (int (**)(void))&off_669EB0;
  return result;
}
// 4F2E70: variable 'result' is possibly undefined
// 669EB0: using guessed type void *;

//----- (004F2E90) --------------------------------------------------------
int __fastcall CTaskSimpleSitIdle::GetTaskType(const CTaskSimpleSitIdle *this)
{
  return 221;
}

//----- (004F2E94) --------------------------------------------------------
void __fastcall CTaskSimpleSitIdle::Serialize(CTaskSimpleSitIdle *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  int v5; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleSitIdle *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleSitIdle *))this->_vptr$CTask + 5))(this) == 221 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(4u);
    *v4 = this->m_iDuration;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    free(v4);
    if ( UseDataFence )
      AddDataFence();
    sub_19E9A8(&this->m_sitOnStep, 1);
  }
  else
  {
    v5 = (*((int (__fastcall **)(CTaskSimpleSitIdle *))this->_vptr$CTask + 5))(this);
    sub_1941C4(221, v5);
  }
}

//----- (004F2F4C) --------------------------------------------------------
CTask *__fastcall CTaskSimpleStandUp::Clone(const CTaskSimpleStandUp *this)
{
  CTaskSimple *v2; // r0
  CTask *result; // r0

  v2 = (CTaskSimple *)CTask::operator new(0x10u);
  LOBYTE(this) = this->m_sitOnStep;
  CTaskSimple::CTaskSimple(v2);
  LOBYTE(result[1]._vptr$CTask) = (_BYTE)this;
  BYTE1(result[1]._vptr$CTask) = 0;
  result[1].m_pParent = 0;
  result->_vptr$CTask = (int (**)(void))&off_669EE4;
  return result;
}
// 4F2F62: variable 'result' is possibly undefined
// 669EE4: using guessed type void *off_669EE4;

//----- (004F2F78) --------------------------------------------------------
int __fastcall CTaskSimpleStandUp::GetTaskType(const CTaskSimpleStandUp *this)
{
  return 222;
}

//----- (004F2F7C) --------------------------------------------------------
void __fastcall CTaskSimpleStandUp::Serialize(CTaskSimpleStandUp *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleStandUp *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleStandUp *))this->_vptr$CTask + 5))(this) == 222 )
  {
    if ( UseDataFence )
      AddDataFence();
    sub_19E9A8(&this->m_sitOnStep, 1);
  }
  else
  {
    v4 = (*((int (__fastcall **)(CTaskSimpleStandUp *))this->_vptr$CTask + 5))(this);
    sub_1941C4(222, v4);
  }
}

//----- (004F3004) --------------------------------------------------------
CTask *__fastcall CTaskComplexSitDownThenIdleThenStandUp::Clone(const CTaskComplexSitDownThenIdleThenStandUp *this)
{
  CTaskComplex *v2; // r0
  __int16 v3; // r5
  CTask *m_iDuration; // r4
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x14u);
  v3 = *(_WORD *)&this->m_sitOnStep;
  m_iDuration = (CTask *)this->m_iDuration;
  CTaskComplex::CTaskComplex(v2);
  result[1].m_pParent = m_iDuration;
  LOWORD(result[2]._vptr$CTask) = v3;
  BYTE2(result[2]._vptr$CTask) = 0;
  result->_vptr$CTask = (int (**)(void))&off_669F18;
  return result;
}
// 4F301C: variable 'result' is possibly undefined
// 669F18: using guessed type void *off_669F18;

//----- (004F3030) --------------------------------------------------------
int __fastcall CTaskComplexSitDownThenIdleThenStandUp::GetTaskType(const CTaskComplexSitDownThenIdleThenStandUp *this)
{
  return 223;
}

//----- (004F3034) --------------------------------------------------------
void __fastcall CTaskComplexSitDownThenIdleThenStandUp::Serialize(CTaskComplexSitDownThenIdleThenStandUp *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  int v5; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexSitDownThenIdleThenStandUp *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexSitDownThenIdleThenStandUp *))this->_vptr$CTask + 5))(this) == 223 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(4u);
    *v4 = this->m_iDuration;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    free(v4);
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(&this->m_sitOnStep, 1);
    if ( UseDataFence )
      AddDataFence();
    sub_19E9A8(&this->m_doInstantly, 1);
  }
  else
  {
    v5 = (*((int (__fastcall **)(CTaskComplexSitDownThenIdleThenStandUp *))this->_vptr$CTask + 5))(this);
    sub_1941C4(223, v5);
  }
}

//----- (004F3108) --------------------------------------------------------
CTask *__fastcall CTaskComplexObserveTrafficLights::Clone(const CTaskComplexObserveTrafficLights *this)
{
  CTaskComplex *v1; // r0
  CTask *result; // r0

  v1 = (CTaskComplex *)CTask::operator new(0x18u);
  CTaskComplex::CTaskComplex(v1);
  LOWORD(result[2].m_pParent) = 0;
  result[1].m_pParent = 0;
  result[2]._vptr$CTask = 0;
  result->_vptr$CTask = (int (**)(void))&off_669F54;
  return result;
}
// 4F311A: variable 'result' is possibly undefined
// 669F54: using guessed type void *off_669F54;

//----- (004F3130) --------------------------------------------------------
int __fastcall CTaskComplexObserveTrafficLights::GetTaskType(const CTaskComplexObserveTrafficLights *this)
{
  return 224;
}

//----- (004F3134) --------------------------------------------------------
void __fastcall CTaskComplexObserveTrafficLights::Serialize(CTaskComplexObserveTrafficLights *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexObserveTrafficLights *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexObserveTrafficLights *))this->_vptr$CTask + 5))(this) != 224 )
  {
    v4 = (*((int (__fastcall **)(CTaskComplexObserveTrafficLights *))this->_vptr$CTask + 5))(this);
    sub_1941C4(224, v4);
  }
}

//----- (004F319C) --------------------------------------------------------
CTask *__fastcall CTaskComplexObserveTrafficLightsAndAchieveHeading::Clone(
        const CTaskComplexObserveTrafficLightsAndAchieveHeading *this)
{
  CTaskComplex *v2; // r0
  __int64 v3; // kr00_8
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x14u);
  v3 = *(_QWORD *)&this->m_iDuration;
  CTaskComplex::CTaskComplex(v2);
  *(_QWORD *)&result[1].m_pParent = v3;
  result->_vptr$CTask = (int (**)(void))&off_669F90;
  return result;
}
// 4F31B2: variable 'result' is possibly undefined
// 669F90: using guessed type void *;

//----- (004F31C4) --------------------------------------------------------
int __fastcall CTaskComplexObserveTrafficLightsAndAchieveHeading::GetTaskType(
        const CTaskComplexObserveTrafficLightsAndAchieveHeading *this)
{
  return 225;
}

//----- (004F31C8) --------------------------------------------------------
bool __fastcall CTaskComplexObserveTrafficLightsAndAchieveHeading::MakeAbortable(
        CTaskComplexObserveTrafficLightsAndAchieveHeading *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  if ( (unsigned int)(iPriority - 1) <= 1 )
    return (*((int (__fastcall **)(CTask *, CPed *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
             this->m_pSubTask,
             pPed);
  else
    return 0;
}

//----- (004F31E4) --------------------------------------------------------
void __fastcall CTaskComplexObserveTrafficLightsAndAchieveHeading::Serialize(
        CTaskComplexObserveTrafficLightsAndAchieveHeading *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  float *v5; // r5
  int v6; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexObserveTrafficLightsAndAchieveHeading *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexObserveTrafficLightsAndAchieveHeading *))this->_vptr$CTask + 5))(this) == 225 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(4u);
    *v4 = this->m_iDuration;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    free(v4);
    if ( UseDataFence )
      AddDataFence();
    v5 = (float *)malloc(4u);
    *v5 = this->m_fTargetHeading;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 4);
    j_free(v5);
  }
  else
  {
    v6 = (*((int (__fastcall **)(CTaskComplexObserveTrafficLightsAndAchieveHeading *))this->_vptr$CTask + 5))(this);
    sub_1941C4(225, v6);
  }
}

//----- (004F32AC) --------------------------------------------------------
CTask *__fastcall CTaskComplexCrossRoadLookAndAchieveHeading::Clone(
        const CTaskComplexCrossRoadLookAndAchieveHeading *this)
{
  CTaskComplex *v2; // r0
  __int64 v3; // kr00_8
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x14u);
  v3 = *(_QWORD *)&this->m_iDuration;
  CTaskComplex::CTaskComplex(v2);
  *(_QWORD *)&result[1].m_pParent = v3;
  result->_vptr$CTask = (int (**)(void))&off_669FCC;
  return result;
}
// 4F32C2: variable 'result' is possibly undefined
// 669FCC: using guessed type void *;

//----- (004F32D4) --------------------------------------------------------
int __fastcall CTaskComplexCrossRoadLookAndAchieveHeading::GetTaskType(
        const CTaskComplexCrossRoadLookAndAchieveHeading *this)
{
  return 227;
}

//----- (004F32D8) --------------------------------------------------------
bool __fastcall CTaskComplexCrossRoadLookAndAchieveHeading::MakeAbortable(
        CTaskComplexCrossRoadLookAndAchieveHeading *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  if ( (unsigned int)(iPriority - 1) <= 1 )
    return (*((int (__fastcall **)(CTask *, CPed *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
             this->m_pSubTask,
             pPed);
  else
    return 0;
}

//----- (004F32F4) --------------------------------------------------------
void __fastcall CTaskComplexCrossRoadLookAndAchieveHeading::Serialize(CTaskComplexCrossRoadLookAndAchieveHeading *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  float *v5; // r5
  int v6; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexCrossRoadLookAndAchieveHeading *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexCrossRoadLookAndAchieveHeading *))this->_vptr$CTask + 5))(this) == 227 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(4u);
    *v4 = this->m_iDuration;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    free(v4);
    if ( UseDataFence )
      AddDataFence();
    v5 = (float *)malloc(4u);
    *v5 = this->m_fTargetHeading;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 4);
    j_free(v5);
  }
  else
  {
    v6 = (*((int (__fastcall **)(CTaskComplexCrossRoadLookAndAchieveHeading *))this->_vptr$CTask + 5))(this);
    sub_1941C4(227, v6);
  }
}

//----- (004F33BC) --------------------------------------------------------
CTask *__fastcall CTaskSimpleTurn180::Clone(const CTaskSimpleTurn180 *this)
{
  CTaskSimple *v1; // r0
  CTask *result; // r0

  v1 = (CTaskSimple *)CTask::operator new(0x10u);
  CTaskSimple::CTaskSimple(v1);
  LOBYTE(result[1]._vptr$CTask) = 0;
  result[1].m_pParent = 0;
  result->_vptr$CTask = (int (**)(void))&off_66A008;
  return result;
}
// 4F33CE: variable 'result' is possibly undefined
// 66A008: using guessed type void *off_66A008;

//----- (004F33E0) --------------------------------------------------------
int __fastcall CTaskSimpleTurn180::GetTaskType(const CTaskSimpleTurn180 *this)
{
  return 228;
}

//----- (004F33E4) --------------------------------------------------------
bool __fastcall CTaskSimpleTurn180::MakeAbortable(
        CTaskSimpleTurn180 *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 0;
}

//----- (004F33E8) --------------------------------------------------------
void __fastcall CTaskSimpleTurn180::Serialize(CTaskSimpleTurn180 *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleTurn180 *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleTurn180 *))this->_vptr$CTask + 5))(this) != 228 )
  {
    v4 = (*((int (__fastcall **)(CTaskSimpleTurn180 *))this->_vptr$CTask + 5))(this);
    sub_1941C4(228, v4);
  }
}

//----- (004F3450) --------------------------------------------------------
CTask *__fastcall CTaskComplexHitResponse::Clone(const CTaskComplexHitResponse *this)
{
  CTaskComplex *v2; // r0
  CTask *m_iHitSide; // r4
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x10u);
  m_iHitSide = (CTask *)this->m_iHitSide;
  CTaskComplex::CTaskComplex(v2);
  result[1].m_pParent = m_iHitSide;
  result->_vptr$CTask = (int (**)(void))&off_66A03C;
  return result;
}
// 4F3464: variable 'result' is possibly undefined
// 66A03C: using guessed type void *off_66A03C;

//----- (004F3474) --------------------------------------------------------
int __fastcall CTaskComplexHitResponse::GetTaskType(const CTaskComplexHitResponse *this)
{
  return 230;
}

//----- (004F3478) --------------------------------------------------------
void __fastcall CTaskComplexHitResponse::Serialize(CTaskComplexHitResponse *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  int v5; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexHitResponse *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexHitResponse *))this->_vptr$CTask + 5))(this) == 230 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(4u);
    *v4 = this->m_iHitSide;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    j_free(v4);
  }
  else
  {
    v5 = (*((int (__fastcall **)(CTaskComplexHitResponse *))this->_vptr$CTask + 5))(this);
    sub_1941C4(230, v5);
  }
}

//----- (004F3510) --------------------------------------------------------
CTask *__fastcall CTaskComplexHitByGunResponse::Clone(const CTaskComplexHitByGunResponse *this)
{
  CTaskComplex *v2; // r0
  CTask *m_iHitSide; // r4
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x10u);
  m_iHitSide = (CTask *)this->m_iHitSide;
  CTaskComplex::CTaskComplex(v2);
  result[1].m_pParent = m_iHitSide;
  result->_vptr$CTask = (int (**)(void))&off_66A078;
  return result;
}
// 4F3524: variable 'result' is possibly undefined
// 66A078: using guessed type void *;

//----- (004F3534) --------------------------------------------------------
int __fastcall CTaskComplexHitByGunResponse::GetTaskType(const CTaskComplexHitByGunResponse *this)
{
  return 231;
}

//----- (004F3538) --------------------------------------------------------
bool __fastcall CTaskComplexHitByGunResponse::MakeAbortable(
        CTaskComplexHitByGunResponse *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  if ( (unsigned int)(iPriority - 1) <= 1 )
    return (*((int (__fastcall **)(CTask *, CPed *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
             this->m_pSubTask,
             pPed);
  else
    return 0;
}

//----- (004F3554) --------------------------------------------------------
void __fastcall CTaskComplexHitByGunResponse::Serialize(CTaskComplexHitByGunResponse *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  int v5; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexHitByGunResponse *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexHitByGunResponse *))this->_vptr$CTask + 5))(this) == 231 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(4u);
    *v4 = this->m_iHitSide;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    j_free(v4);
  }
  else
  {
    v5 = (*((int (__fastcall **)(CTaskComplexHitByGunResponse *))this->_vptr$CTask + 5))(this);
    sub_1941C4(231, v5);
  }
}

//----- (004F35EC) --------------------------------------------------------
CTask *__fastcall CTaskComplexSunbathe::Clone(const CTaskComplexSunbathe *this)
{
  CTaskComplexSunbathe *v2; // r0
  CTask *result; // r0

  v2 = (CTaskComplexSunbathe *)CTask::operator new(0x38u);
  sub_19A70C(v2, this->m_pTowel, this->m_bStartStanding);
  return result;
}

//----- (004F3604) --------------------------------------------------------
int __fastcall CTaskComplexSunbathe::GetTaskType(const CTaskComplexSunbathe *this)
{
  return 417;
}

//----- (004F360C) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseEffect::Clone(const CTaskComplexUseEffect *this)
{
  void *v2; // r4
  __int64 v3; // kr00_8

  v2 = CTask::operator new(0x24u);
  v3 = *(_QWORD *)&this->m_pEffect;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_DWORD *)v2 + 3) = v3;
  *((_DWORD *)v2 + 5) = 0;
  *((_DWORD *)v2 + 6) = 0;
  *((_DWORD *)v2 + 7) = 4;
  *((_BYTE *)v2 + 32) = 0;
  *(_DWORD *)v2 = &off_66A0F0;
  *((_DWORD *)v2 + 4) = HIDWORD(v3);
  if ( HIDWORD(v3) )
    CEntity::RegisterReference((CEntity *)HIDWORD(v3), (CEntity **)v2 + 4);
  return (CTask *)v2;
}
// 66A0F0: using guessed type void *off_66A0F0;

//----- (004F3660) --------------------------------------------------------
int __fastcall CTaskComplexUseEffect::GetTaskType(const CTaskComplexUseEffect *this)
{
  return 233;
}

//----- (004F3664) --------------------------------------------------------
CTask *__fastcall CTaskComplexWaitAtAttractor::Clone(const CTaskComplexWaitAtAttractor *this)
{
  CTaskComplex *v2; // r0
  __int64 v3; // kr00_8
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x14u);
  v3 = *(_QWORD *)&this->m_pAttractor;
  CTaskComplex::CTaskComplex(v2);
  *(_QWORD *)&result[1].m_pParent = v3;
  result->_vptr$CTask = (int (**)(void))&off_66A12C;
  return result;
}
// 4F367A: variable 'result' is possibly undefined
// 66A12C: using guessed type void *off_66A12C;

//----- (004F368C) --------------------------------------------------------
int __fastcall CTaskComplexWaitAtAttractor::GetTaskType(const CTaskComplexWaitAtAttractor *this)
{
  return 234;
}

//----- (004F3690) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseAttractor::Clone(const CTaskComplexUseAttractor *this)
{
  CTaskComplex *v2; // r0
  CTask *m_pAttractor; // r4
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x10u);
  m_pAttractor = (CTask *)this->m_pAttractor;
  CTaskComplex::CTaskComplex(v2);
  result[1].m_pParent = m_pAttractor;
  result->_vptr$CTask = (int (**)(void))&off_66A168;
  return result;
}
// 4F36A4: variable 'result' is possibly undefined
// 66A168: using guessed type void *off_66A168;

//----- (004F36B4) --------------------------------------------------------
int __fastcall CTaskComplexUseAttractor::GetTaskType(const CTaskComplexUseAttractor *this)
{
  return 235;
}

//----- (004F36B8) --------------------------------------------------------
CTask *__fastcall CTaskComplexWaitForDryWeather::Clone(const CTaskComplexWaitForDryWeather *this)
{
  CTaskComplex *v1; // r0
  CTask *result; // r0

  v1 = (CTaskComplex *)CTask::operator new(0xCu);
  CTaskComplex::CTaskComplex(v1);
  result->_vptr$CTask = (int (**)(void))&off_66A1A4;
  return result;
}
// 4F36CE: variable 'result' is possibly undefined
// 66A1A4: using guessed type void *;
// 676780: using guessed type void *`vtable for'CTaskComplexWaitForDryWeather;

//----- (004F36D8) --------------------------------------------------------
int __fastcall CTaskComplexWaitForDryWeather::GetTaskType(const CTaskComplexWaitForDryWeather *this)
{
  return 236;
}

//----- (004F36DC) --------------------------------------------------------
void __fastcall CTaskComplexWaitForDryWeather::Serialize(CTaskComplexWaitForDryWeather *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexWaitForDryWeather *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexWaitForDryWeather *))this->_vptr$CTask + 5))(this) != 236 )
  {
    v4 = (*((int (__fastcall **)(CTaskComplexWaitForDryWeather *))this->_vptr$CTask + 5))(this);
    sub_1941C4(236, v4);
  }
}

//----- (004F3744) --------------------------------------------------------
CTask *__fastcall CTaskComplexWaitForBus::Clone(const CTaskComplexWaitForBus *this)
{
  CTaskComplex *v1; // r0
  CTask *result; // r0

  v1 = (CTaskComplex *)CTask::operator new(0x10u);
  CTaskComplex::CTaskComplex(v1);
  result[1].m_pParent = 0;
  result->_vptr$CTask = (int (**)(void))&off_66A1E0;
  return result;
}
// 4F3756: variable 'result' is possibly undefined
// 66A1E0: using guessed type void *;
// 6796A8: using guessed type void *`vtable for'CTaskComplexWaitForBus;

//----- (004F3768) --------------------------------------------------------
int __fastcall CTaskComplexWaitForBus::GetTaskType(const CTaskComplexWaitForBus *this)
{
  return 237;
}

//----- (004F376C) --------------------------------------------------------
void __fastcall CTaskComplexWaitForBus::Serialize(CTaskComplexWaitForBus *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexWaitForBus *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexWaitForBus *))this->_vptr$CTask + 5))(this) != 237 )
  {
    v4 = (*((int (__fastcall **)(CTaskComplexWaitForBus *))this->_vptr$CTask + 5))(this);
    sub_1941C4(237, v4);
  }
}

//----- (004F37D4) --------------------------------------------------------
CTask *__fastcall CTaskSimpleWaitForBus::Clone(const CTaskSimpleWaitForBus *this)
{
  CTaskSimple *v1; // r0
  CTask *result; // r0

  v1 = (CTaskSimple *)CTask::operator new(0xCu);
  CTaskSimple::CTaskSimple(v1);
  result[1]._vptr$CTask = 0;
  result->_vptr$CTask = (int (**)(void))&off_66A21C;
  return result;
}
// 4F37E6: variable 'result' is possibly undefined
// 66A21C: using guessed type void *off_66A21C;

//----- (004F37F8) --------------------------------------------------------
int __fastcall CTaskSimpleWaitForBus::GetTaskType(const CTaskSimpleWaitForBus *this)
{
  return 238;
}

//----- (004F37FC) --------------------------------------------------------
bool __fastcall CTaskSimpleWaitForBus::MakeAbortable(
        CTaskSimpleWaitForBus *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 1;
}

//----- (004F3800) --------------------------------------------------------
void __fastcall CTaskSimpleWaitForBus::Serialize(CTaskSimpleWaitForBus *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleWaitForBus *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleWaitForBus *))this->_vptr$CTask + 5))(this) != 238 )
  {
    v4 = (*((int (__fastcall **)(CTaskSimpleWaitForBus *))this->_vptr$CTask + 5))(this);
    sub_1941C4(238, v4);
  }
}

//----- (004F3868) --------------------------------------------------------
CTask *__fastcall CTaskSimpleWaitForPizza::Clone(const CTaskSimpleWaitForPizza *this)
{
  CTaskSimple *v1; // r0
  CTask *result; // r0

  v1 = (CTaskSimple *)CTask::operator new(0x14u);
  CTaskSimple::CTaskSimple(v1);
  LOWORD(result[2]._vptr$CTask) = 0;
  result[1]._vptr$CTask = 0;
  result[1].m_pParent = 0;
  result->_vptr$CTask = (int (**)(void))&off_66A250;
  return result;
}
// 4F387A: variable 'result' is possibly undefined
// 66A250: using guessed type void *;

//----- (004F3890) --------------------------------------------------------
int __fastcall CTaskSimpleWaitForPizza::GetTaskType(const CTaskSimpleWaitForPizza *this)
{
  return 239;
}

//----- (004F3894) --------------------------------------------------------
bool __fastcall CTaskSimpleWaitForPizza::MakeAbortable(
        CTaskSimpleWaitForPizza *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 1;
}

//----- (004F3898) --------------------------------------------------------
void __fastcall CTaskSimpleWaitForPizza::Serialize(CTaskSimpleWaitForPizza *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleWaitForPizza *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleWaitForPizza *))this->_vptr$CTask + 5))(this) != 239 )
  {
    v4 = (*((int (__fastcall **)(CTaskSimpleWaitForPizza *))this->_vptr$CTask + 5))(this);
    sub_1941C4(239, v4);
  }
}

//----- (004F3900) --------------------------------------------------------
CTask *__fastcall CTaskComplexSequence::Clone(const CTaskComplexSequence *this)
{
  char *v2; // r5
  int v3; // r0
  CTask *v4; // r1
  CTask *v5; // r0
  int v6; // r0
  CTask *v7; // r0
  int v8; // r0
  CTask *v9; // r0
  int v10; // r0
  CTask *v11; // r0
  int v12; // r0
  CTask *v13; // r0
  int v14; // r0
  CTask *v15; // r0
  int v16; // r0
  CTask *v17; // r0
  int v18; // r0

  v2 = (char *)CTask::operator new(0x40u);
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *(_QWORD *)(v2 + 41) = 0LL;
  *(_QWORD *)(v2 + 49) = 0LL;
  *(_QWORD *)(v2 + 28) = 0LL;
  *(_QWORD *)(v2 + 36) = 0LL;
  *(_QWORD *)(v2 + 12) = 0LL;
  *(_QWORD *)(v2 + 20) = 0LL;
  v3 = 0;
  *((_DWORD *)v2 + 15) = 0;
  *(_DWORD *)v2 = &off_66A284;
  v4 = this->m_tasks[0];
  if ( v4 )
    v3 = (*((int (__fastcall **)(CTask *))v4->_vptr$CTask + 2))(this->m_tasks[0]);
  *((_DWORD *)v2 + 4) = v3;
  v5 = this->m_tasks[1];
  if ( v5 )
    v6 = (*((int (__fastcall **)(CTask *))v5->_vptr$CTask + 2))(v5);
  else
    v6 = 0;
  *((_DWORD *)v2 + 5) = v6;
  v7 = this->m_tasks[2];
  if ( v7 )
    v8 = (*((int (__fastcall **)(CTask *))v7->_vptr$CTask + 2))(v7);
  else
    v8 = 0;
  *((_DWORD *)v2 + 6) = v8;
  v9 = this->m_tasks[3];
  if ( v9 )
    v10 = (*((int (__fastcall **)(CTask *))v9->_vptr$CTask + 2))(v9);
  else
    v10 = 0;
  *((_DWORD *)v2 + 7) = v10;
  v11 = this->m_tasks[4];
  if ( v11 )
    v12 = (*((int (__fastcall **)(CTask *))v11->_vptr$CTask + 2))(v11);
  else
    v12 = 0;
  *((_DWORD *)v2 + 8) = v12;
  v13 = this->m_tasks[5];
  if ( v13 )
    v14 = (*((int (__fastcall **)(CTask *))v13->_vptr$CTask + 2))(v13);
  else
    v14 = 0;
  *((_DWORD *)v2 + 9) = v14;
  v15 = this->m_tasks[6];
  if ( v15 )
    v16 = (*((int (__fastcall **)(CTask *))v15->_vptr$CTask + 2))(v15);
  else
    v16 = 0;
  *((_DWORD *)v2 + 10) = v16;
  v17 = this->m_tasks[7];
  if ( v17 )
    v18 = (*((int (__fastcall **)(CTask *))v17->_vptr$CTask + 2))(v17);
  else
    v18 = 0;
  *((_DWORD *)v2 + 11) = v18;
  *((_DWORD *)v2 + 12) = this->m_iRepeatMode;
  *((_DWORD *)v2 + 3) = this->m_iProgress;
  return (CTask *)v2;
}
// 66A284: using guessed type void *off_66A284;

//----- (004F39CC) --------------------------------------------------------
bool __fastcall CTaskComplexSequence::MakeAbortable(
        CTaskComplexSequence *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
          + 7))(
           this->m_pSubTask,
           pPed,
           iPriority,
           pEvent);
}

//----- (004F39D8) --------------------------------------------------------
CTask *__fastcall CTaskComplexBeInGroup::Clone(const CTaskComplexBeInGroup *this)
{
  CTaskComplex *v2; // r0
  bool m_bIsLeader; // r5
  CTask *m_iGroupID; // r4
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x28u);
  m_bIsLeader = this->m_bIsLeader;
  m_iGroupID = (CTask *)this->m_iGroupID;
  CTaskComplex::CTaskComplex(v2);
  result[1].m_pParent = m_iGroupID;
  LOBYTE(result[2]._vptr$CTask) = m_bIsLeader;
  result[2].m_pParent = 0;
  result[3]._vptr$CTask = 0;
  result[3].m_pParent = (CTask *)&dword_C8;
  result[4]._vptr$CTask = 0;
  result[4].m_pParent = (CTask *)-1;
  result->_vptr$CTask = (int (**)(void))&off_66A2C0;
  return result;
}
// 4F39F0: variable 'result' is possibly undefined
// C8: using guessed type int dword_C8;
// 66A2C0: using guessed type void *off_66A2C0;

//----- (004F3A14) --------------------------------------------------------
int __fastcall CTaskComplexBeInGroup::GetTaskType(const CTaskComplexBeInGroup *this)
{
  return 243;
}

//----- (004F3A18) --------------------------------------------------------
void __fastcall CTaskComplexBeInGroup::Serialize(CTaskComplexBeInGroup *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r5
  _DWORD *v5; // r6
  _DWORD *v6; // r5
  int v7; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexBeInGroup *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexBeInGroup *))this->_vptr$CTask + 5))(this) == 243 )
  {
    v4 = GettPoolPedRef(this->m_pPed);
    if ( UseDataFence )
      AddDataFence();
    v5 = malloc(4u);
    *v5 = v4;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 4);
    free(v5);
    if ( UseDataFence )
      AddDataFence();
    v6 = malloc(4u);
    *v6 = this->m_iGroupID;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
    free(v6);
    if ( UseDataFence )
      AddDataFence();
    sub_19E9A8(&this->m_bIsLeader, 1);
  }
  else
  {
    v7 = (*((int (__fastcall **)(CTaskComplexBeInGroup *))this->_vptr$CTask + 5))(this);
    sub_1941C4(243, v7);
  }
}

//----- (004F3B00) --------------------------------------------------------
CTask *__fastcall CTaskComplexUsePairedAttractor::Clone(const CTaskComplexUsePairedAttractor *this)
{
  CTaskComplex *v2; // r0
  CTask *m_pPedAttractor; // r4
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x24u);
  m_pPedAttractor = (CTask *)this->m_pPedAttractor;
  CTaskComplex::CTaskComplex(v2);
  result[1].m_pParent = m_pPedAttractor;
  result[2]._vptr$CTask = 0;
  LOBYTE(result[2].m_pParent) = 0;
  result[3]._vptr$CTask = 0;
  result[3].m_pParent = 0;
  result[4]._vptr$CTask = 0;
  result->_vptr$CTask = (int (**)(void))&off_66A2FC;
  return result;
}
// 4F3B16: variable 'result' is possibly undefined
// 66A2FC: using guessed type void *off_66A2FC;

//----- (004F3B30) --------------------------------------------------------
int __fastcall CTaskComplexUsePairedAttractor::GetTaskType(const CTaskComplexUsePairedAttractor *this)
{
  return 246;
}

//----- (004F3B34) --------------------------------------------------------
CTask *__fastcall CTaskComplexAttractorPartnerWait::Clone(const CTaskComplexAttractorPartnerWait *this)
{
  CTaskComplex *v2; // r0
  int (**m_pCurrentPair)(void); // r5
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x14u);
  m_pCurrentPair = (int (**)(void))this->m_pCurrentPair;
  LOBYTE(this) = this->m_bIsLeader;
  CTaskComplex::CTaskComplex(v2);
  LOBYTE(result[1].m_pParent) = (_BYTE)this;
  result[2]._vptr$CTask = m_pCurrentPair;
  result->_vptr$CTask = (int (**)(void))&off_66A338;
  return result;
}
// 4F3B4A: variable 'result' is possibly undefined
// 66A338: using guessed type void *off_66A338;
// 6788D8: using guessed type void *`vtable for'CTaskComplexAttractorPartnerWait;

//----- (004F3B5C) --------------------------------------------------------
int __fastcall CTaskComplexAttractorPartnerWait::GetTaskType(const CTaskComplexAttractorPartnerWait *this)
{
  return 248;
}

//----- (004F3B60) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseAttractorPartner::Clone(const CTaskComplexUseAttractorPartner *this)
{
  CTaskComplex *v2; // r0
  int (**m_pCurrentPair)(void); // r5
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x14u);
  m_pCurrentPair = (int (**)(void))this->m_pCurrentPair;
  LOBYTE(this) = this->m_bIsLeader;
  CTaskComplex::CTaskComplex(v2);
  LOBYTE(result[1].m_pParent) = (_BYTE)this;
  result[2]._vptr$CTask = m_pCurrentPair;
  result->_vptr$CTask = (int (**)(void))&off_66A374;
  return result;
}
// 4F3B76: variable 'result' is possibly undefined
// 66A374: using guessed type void *off_66A374;
// 675FE0: using guessed type void *`vtable for'CTaskComplexUseAttractorPartner;

//----- (004F3B88) --------------------------------------------------------
int __fastcall CTaskComplexUseAttractorPartner::GetTaskType(const CTaskComplexUseAttractorPartner *this)
{
  return 247;
}

//----- (004F3B8C) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseScriptedAttractor::Clone(const CTaskComplexUseScriptedAttractor *this)
{
  CTaskComplex *v2; // r0
  CTask *m_pPedAttractor; // r4
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x10u);
  m_pPedAttractor = (CTask *)this->m_pPedAttractor;
  CTaskComplex::CTaskComplex(v2);
  result[1].m_pParent = m_pPedAttractor;
  result->_vptr$CTask = (int (**)(void))&off_66A3B0;
  return result;
}
// 4F3BA0: variable 'result' is possibly undefined
// 66A3B0: using guessed type void *off_66A3B0;
// 678A54: using guessed type void *`vtable for'CTaskComplexUseScriptedAttractor;

//----- (004F3BB0) --------------------------------------------------------
int __fastcall CTaskComplexUseScriptedAttractor::GetTaskType(const CTaskComplexUseScriptedAttractor *this)
{
  return 249;
}

//----- (004F3BB4) --------------------------------------------------------
CTask *__fastcall CTaskComplexOnFire::Clone(const CTaskComplexOnFire *this)
{
  CTaskComplex *v1; // r0
  CTask *result; // r0

  v1 = (CTaskComplex *)CTask::operator new(0xCu);
  CTaskComplex::CTaskComplex(v1);
  result->_vptr$CTask = (int (**)(void))&off_66A3EC;
  return result;
}
// 4F3BCA: variable 'result' is possibly undefined
// 66A3EC: using guessed type void *off_66A3EC;

//----- (004F3BD4) --------------------------------------------------------
int __fastcall CTaskComplexOnFire::GetTaskType(const CTaskComplexOnFire *this)
{
  return 250;
}

//----- (004F3BD8) --------------------------------------------------------
void __fastcall CTaskComplexOnFire::Serialize(CTaskComplexOnFire *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexOnFire *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexOnFire *))this->_vptr$CTask + 5))(this) != 250 )
  {
    v4 = (*((int (__fastcall **)(CTaskComplexOnFire *))this->_vptr$CTask + 5))(this);
    sub_1941C4(250, v4);
  }
}

//----- (004F3C40) --------------------------------------------------------
CTask *__fastcall CTaskSimplePlayerOnFire::Clone(const CTaskSimplePlayerOnFire *this)
{
  CTaskSimple *v1; // r0
  CTask *result; // r0

  v1 = (CTaskSimple *)CTask::operator new(0x18u);
  CTaskSimple::CTaskSimple(v1);
  LOWORD(result[2]._vptr$CTask) = 0;
  LOBYTE(result[2].m_pParent) = 0;
  result[1]._vptr$CTask = 0;
  result[1].m_pParent = 0;
  result->_vptr$CTask = (int (**)(void))&off_66A428;
  return result;
}
// 4F3C52: variable 'result' is possibly undefined
// 66A428: using guessed type void *off_66A428;

//----- (004F3C68) --------------------------------------------------------
int __fastcall CTaskSimplePlayerOnFire::GetTaskType(const CTaskSimplePlayerOnFire *this)
{
  return 255;
}

//----- (004F3C6C) --------------------------------------------------------
bool __fastcall CTaskSimplePlayerOnFire::MakeAbortable(
        CTaskSimplePlayerOnFire *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 0;
}

//----- (004F3C70) --------------------------------------------------------
void __fastcall CTaskSimplePlayerOnFire::Serialize(CTaskSimplePlayerOnFire *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskSimplePlayerOnFire *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimplePlayerOnFire *))this->_vptr$CTask + 5))(this) != 255 )
  {
    v4 = (*((int (__fastcall **)(CTaskSimplePlayerOnFire *))this->_vptr$CTask + 5))(this);
    sub_1941C4(255, v4);
  }
}

//----- (004F3CD8) --------------------------------------------------------
int __fastcall CTaskSimpleIKManager::GetTaskType(const CTaskSimpleIKManager *this)
{
  return 265;
}

//----- (004F3CDE) --------------------------------------------------------
int __fastcall CTaskSimpleIKLookAt::GetTaskType(const CTaskSimpleIKLookAt *this)
{
  return 266;
}

//----- (004F3CE4) --------------------------------------------------------
int __fastcall CTaskSimpleIKPointArm::GetTaskType(const CTaskSimpleIKPointArm *this)
{
  return 272;
}

//----- (004F3CEA) --------------------------------------------------------
int __fastcall CTaskSimpleTriggerLookAt::GetTaskType(const CTaskSimpleTriggerLookAt *this)
{
  return 269;
}

//----- (004F3CF0) --------------------------------------------------------
void __fastcall CTaskSimpleTriggerLookAt::Serialize(CTaskSimpleTriggerLookAt *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CEntity *m_pEntity; // r0
  int v5; // r5
  int v6; // r0
  _DWORD *v7; // r6
  _DWORD *v8; // r5
  _DWORD *v9; // r5
  _DWORD *v10; // r5
  __int64 v11; // d16
  float m_speed; // r6
  float *v13; // r5
  _DWORD *v14; // r5

  v2 = (*((int (__fastcall **)(CTaskSimpleTriggerLookAt *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleTriggerLookAt *))this->_vptr$CTask + 5))(this) == 269 )
  {
    m_pEntity = this->m_pEntity;
    if ( m_pEntity && (*(_BYTE *)&m_pEntity->m_info & 7) == 3 )
      v5 = GettPoolPedRef((CPed *)m_pEntity);
    else
      v5 = -1;
    if ( UseDataFence )
      AddDataFence();
    v7 = malloc(4u);
    *v7 = v5;
    CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
    free(v7);
    if ( UseDataFence )
      AddDataFence();
    v8 = malloc(4u);
    *v8 = this->m_time;
    CGenericGameStorage::_SaveDataToWorkBuffer(v8, 4);
    free(v8);
    if ( UseDataFence )
      AddDataFence();
    v9 = malloc(4u);
    *v9 = this->m_offsetBoneTag;
    CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
    free(v9);
    if ( UseDataFence )
      AddDataFence();
    v10 = malloc(0xCu);
    v11 = *(_QWORD *)&this->m_offsetPos.x;
    v10[2] = LODWORD(this->m_offsetPos.z);
    *(_QWORD *)v10 = v11;
    CGenericGameStorage::_SaveDataToWorkBuffer(v10, 12);
    free(v10);
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(&this->m_useTorso, 1);
    m_speed = this->m_speed;
    if ( UseDataFence )
      AddDataFence();
    v13 = (float *)malloc(4u);
    *v13 = m_speed;
    CGenericGameStorage::_SaveDataToWorkBuffer(v13, 4);
    free(v13);
    if ( UseDataFence )
      AddDataFence();
    v14 = malloc(4u);
    *v14 = this->m_blendTime;
    CGenericGameStorage::_SaveDataToWorkBuffer(v14, 4);
    free(v14);
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(&this->m_nonNullEntity, 1);
    if ( UseDataFence )
      AddDataFence();
    sub_19E9A8(&this->m_priority, 1);
  }
  else
  {
    v6 = (*((int (__fastcall **)(CTaskSimpleTriggerLookAt *))this->_vptr$CTask + 5))(this);
    sub_1941C4(269, v6);
  }
}

//----- (004F3EF0) --------------------------------------------------------
CTask *__fastcall CTaskSimpleClearLookAt::Clone(const CTaskSimpleClearLookAt *this)
{
  CTaskSimple *v1; // r0
  CTask *result; // r0

  v1 = (CTaskSimple *)CTask::operator new(8u);
  CTaskSimple::CTaskSimple(v1);
  result->_vptr$CTask = (int (**)(void))&off_66A56C;
  return result;
}
// 4F3F06: variable 'result' is possibly undefined
// 66A56C: using guessed type void *off_66A56C;

//----- (004F3F10) --------------------------------------------------------
int __fastcall CTaskSimpleClearLookAt::GetTaskType(const CTaskSimpleClearLookAt *this)
{
  return 270;
}

//----- (004F3F18) --------------------------------------------------------
void __fastcall CTaskSimpleClearLookAt::Serialize(CTaskSimpleClearLookAt *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleClearLookAt *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleClearLookAt *))this->_vptr$CTask + 5))(this) != 270 )
  {
    v4 = (*((int (__fastcall **)(CTaskSimpleClearLookAt *))this->_vptr$CTask + 5))(this);
    sub_1941C4(270, v4);
  }
}

//----- (004F3F84) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseClosestFreeScriptedAttractor::Clone(
        const CTaskComplexUseClosestFreeScriptedAttractor *this)
{
  CTaskComplex *v1; // r0
  CTask *result; // r0

  v1 = (CTaskComplex *)CTask::operator new(0x10u);
  CTaskComplex::CTaskComplex(v1);
  result[1].m_pParent = (CTask *)byte_4;
  result->_vptr$CTask = (int (**)(void))&off_66A5A0;
  return result;
}
// 4F3F96: variable 'result' is possibly undefined
// 66A5A0: using guessed type void *off_66A5A0;

//----- (004F3FA8) --------------------------------------------------------
int __fastcall CTaskComplexUseClosestFreeScriptedAttractor::GetTaskType(
        const CTaskComplexUseClosestFreeScriptedAttractor *this)
{
  return 258;
}

//----- (004F3FB0) --------------------------------------------------------
void __fastcall CTaskComplexUseClosestFreeScriptedAttractor::Serialize(
        CTaskComplexUseClosestFreeScriptedAttractor *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexUseClosestFreeScriptedAttractor *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexUseClosestFreeScriptedAttractor *))this->_vptr$CTask + 5))(this) != 258 )
  {
    v4 = (*((int (__fastcall **)(CTaskComplexUseClosestFreeScriptedAttractor *))this->_vptr$CTask + 5))(this);
    sub_1941C4(258, v4);
  }
}

//----- (004F401C) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseMobilePhone::Clone(const CTaskComplexUseMobilePhone *this)
{
  CTaskComplex *v2; // r0
  CTask *m_iDuration; // r4
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x20u);
  m_iDuration = (CTask *)this->m_iDuration;
  CTaskComplex::CTaskComplex(v2);
  result[1].m_pParent = m_iDuration;
  LOWORD(result[3]._vptr$CTask) = 0;
  LOWORD(result[3].m_pParent) = 0;
  result[2]._vptr$CTask = 0;
  result[2].m_pParent = 0;
  result->_vptr$CTask = (int (**)(void))&off_66A5DC;
  return result;
}
// 4F4032: variable 'result' is possibly undefined
// 66A5DC: using guessed type void *off_66A5DC;

//----- (004F404C) --------------------------------------------------------
int __fastcall CTaskComplexUseMobilePhone::GetTaskType(const CTaskComplexUseMobilePhone *this)
{
  return 1600;
}

//----- (004F4054) --------------------------------------------------------
void __fastcall CTaskComplexUseMobilePhone::Serialize(CTaskComplexUseMobilePhone *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  int v5; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexUseMobilePhone *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexUseMobilePhone *))this->_vptr$CTask + 5))(this) == 1600 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(4u);
    *v4 = this->m_iDuration;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    j_free(v4);
  }
  else
  {
    v5 = (*((int (__fastcall **)(CTaskComplexUseMobilePhone *))this->_vptr$CTask + 5))(this);
    sub_1941C4(1600, v5);
  }
}

//----- (004F40F0) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseGoggles::Clone(const CTaskComplexUseGoggles *this)
{
  CTaskComplex *v1; // r0
  CTask *result; // r0

  v1 = (CTaskComplex *)CTask::operator new(0xCu);
  CTaskComplex::CTaskComplex(v1);
  result->_vptr$CTask = (int (**)(void))&off_66A618;
  return result;
}
// 4F4106: variable 'result' is possibly undefined
// 66A618: using guessed type void *off_66A618;

//----- (004F4110) --------------------------------------------------------
int __fastcall CTaskComplexUseGoggles::GetTaskType(const CTaskComplexUseGoggles *this)
{
  return 1604;
}

//----- (004F4118) --------------------------------------------------------
void __fastcall CTaskComplexUseGoggles::Serialize(CTaskComplexUseGoggles *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexUseGoggles *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexUseGoggles *))this->_vptr$CTask + 5))(this) != 1604 )
  {
    v4 = (*((int (__fastcall **)(CTaskComplexUseGoggles *))this->_vptr$CTask + 5))(this);
    sub_1941C4(1604, v4);
  }
}

//----- (004F4188) --------------------------------------------------------
CTask *__fastcall CTaskComplexInWater::Clone(const CTaskComplexInWater *this)
{
  CTaskComplex *v1; // r0
  CTask *result; // r0

  v1 = (CTaskComplex *)CTask::operator new(0xCu);
  CTaskComplex::CTaskComplex(v1);
  result->_vptr$CTask = (int (**)(void))&off_66A654;
  return result;
}
// 4F419E: variable 'result' is possibly undefined
// 66A654: using guessed type void *off_66A654;

//----- (004F41A8) --------------------------------------------------------
int __fastcall CTaskComplexInWater::GetTaskType(const CTaskComplexInWater *this)
{
  return 268;
}

//----- (004F41B0) --------------------------------------------------------
void __fastcall CTaskComplexInWater::Serialize(CTaskComplexInWater *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexInWater *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexInWater *))this->_vptr$CTask + 5))(this) != 268 )
  {
    v4 = (*((int (__fastcall **)(CTaskComplexInWater *))this->_vptr$CTask + 5))(this);
    sub_1941C4(268, v4);
  }
}

//----- (004F421C) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseSequence::Clone(const CTaskComplexUseSequence *this)
{
  CTaskComplex *v2; // r0
  int m_id; // r5
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x1Cu);
  m_id = this->m_id;
  CTaskComplex::CTaskComplex(v2);
  result[1].m_pParent = (CTask *)m_id;
  result[2]._vptr$CTask = 0;
  result[2].m_pParent = (CTask *)-1;
  result[3]._vptr$CTask = 0;
  result->_vptr$CTask = (int (**)(void))&off_66A690;
  ++CTaskSequences::ms_taskSequence[m_id].m_iRefCount;
  result[2]._vptr$CTask = (int (**)(void))this->m_iProgress1;
  result[2].m_pParent = (CTask *)this->m_iProgress2;
  return result;
}
// 4F423A: variable 'result' is possibly undefined
// 66A690: using guessed type void *off_66A690;

//----- (004F4268) --------------------------------------------------------
int __fastcall CTaskComplexUseSequence::GetTaskType(const CTaskComplexUseSequence *this)
{
  return 275;
}

//----- (004F4270) --------------------------------------------------------
void __fastcall CTaskComplexUseSequence::Serialize(CTaskComplexUseSequence *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  _DWORD *v5; // r5
  _DWORD *v6; // r5
  int v7; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexUseSequence *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexUseSequence *))this->_vptr$CTask + 5))(this) == 275 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(4u);
    *v4 = this->m_id;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    free(v4);
    if ( UseDataFence )
      AddDataFence();
    v5 = malloc(4u);
    *v5 = this->m_iProgress1;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 4);
    free(v5);
    if ( UseDataFence )
      AddDataFence();
    v6 = malloc(4u);
    *v6 = this->m_iProgress2;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
    j_free(v6);
  }
  else
  {
    v7 = (*((int (__fastcall **)(CTaskComplexUseSequence *))this->_vptr$CTask + 5))(this);
    sub_1941C4(275, v7);
  }
}

//----- (004F436C) --------------------------------------------------------
CTask *__fastcall CTaskSimpleWaitUntilAreaCodesMatch::Clone(const CTaskSimpleWaitUntilAreaCodesMatch *this)
{
  void *v2; // r4
  CPed *m_pTargetPed; // r5

  v2 = CTask::operator new(0x24u);
  m_pTargetPed = this->m_pTargetPed;
  CTaskSimple::CTaskSimple((CTaskSimple *)v2);
  *((_WORD *)v2 + 10) = 0;
  *((_DWORD *)v2 + 7) = 1090519040;
  *((_WORD *)v2 + 12) = 1;
  *((_DWORD *)v2 + 2) = 1000;
  *((_DWORD *)v2 + 3) = 0;
  *((_DWORD *)v2 + 4) = 0;
  *(_DWORD *)v2 = &off_66A6CC;
  *((_DWORD *)v2 + 8) = m_pTargetPed;
  if ( m_pTargetPed )
    CEntity::RegisterReference(m_pTargetPed, (CEntity **)v2 + 8);
  return (CTask *)v2;
}
// 66A6CC: using guessed type void *off_66A6CC;

//----- (004F43BC) --------------------------------------------------------
int __fastcall CTaskSimpleWaitUntilAreaCodesMatch::GetTaskType(const CTaskSimpleWaitUntilAreaCodesMatch *this)
{
  return 1307;
}

//----- (004F43C2) --------------------------------------------------------
bool __fastcall CTaskSimpleWaitUntilAreaCodesMatch::MakeAbortable(
        CTaskSimpleWaitUntilAreaCodesMatch *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return iPriority == 2;
}

//----- (004F43CC) --------------------------------------------------------
void __fastcall CTaskSimpleWaitUntilAreaCodesMatch::Serialize(CTaskSimpleWaitUntilAreaCodesMatch *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CPed *m_pTargetPed; // r0
  int v5; // r4
  _DWORD *v6; // r5
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r4

  v2 = (*((int (__fastcall **)(CTaskSimpleWaitUntilAreaCodesMatch *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleWaitUntilAreaCodesMatch *))this->_vptr$CTask + 5))(this) == 1307 )
  {
    m_pTargetPed = this->m_pTargetPed;
    if ( m_pTargetPed )
    {
      v5 = GettPoolPedRef(m_pTargetPed);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    j_free(v7);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskSimpleWaitUntilAreaCodesMatch *))this->_vptr$CTask + 5))(this);
    sub_1941C4(1307, v8);
  }
}

//----- (004F44A0) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseScriptedBrain::Clone(const CTaskComplexUseScriptedBrain *this)
{
  void *v2; // r5

  v2 = CTask::operator new(0x1Cu);
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_BYTE *)v2 + 12) = 0;
  *((_DWORD *)v2 + 6) = 0;
  *(_DWORD *)v2 = &off_66A700;
  strcpy((char *)v2 + 13, (const char *)this->m_name);
  return (CTask *)v2;
}
// 66A700: using guessed type void *off_66A700;

//----- (004F44D8) --------------------------------------------------------
int __fastcall CTaskComplexUseScriptedBrain::GetTaskType(const CTaskComplexUseScriptedBrain *this)
{
  return 1800;
}

//----- (004F44E0) --------------------------------------------------------
void __fastcall CTaskComplexUseScriptedBrain::Serialize(CTaskComplexUseScriptedBrain *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexUseScriptedBrain *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexUseScriptedBrain *))this->_vptr$CTask + 5))(this) == 1800 )
  {
    if ( UseDataFence )
      AddDataFence();
    sub_19E9A8(this->m_name, 8);
  }
  else
  {
    v4 = (*((int (__fastcall **)(CTaskComplexUseScriptedBrain *))this->_vptr$CTask + 5))(this);
    sub_1941C4(1800, v4);
  }
}

//----- (004F456C) --------------------------------------------------------
void __fastcall CTaskComplexUseEffectRunning::~CTaskComplexUseEffectRunning(CTaskComplexUseEffectRunning *this)
{
  CPed *m_pPed; // r1
  bool v3; // zf
  CPedAttractorManager *PedAttractorManager; // r0
  CEntity *m_pEntity; // r0
  void *v6; // r0

  m_pPed = this->m_pPed;
  v3 = m_pPed == 0;
  this->_vptr$CTask = (int (**)(void))&off_66A0F0;
  if ( m_pPed )
    v3 = this->m_pAttractor == 0;
  if ( !v3 )
  {
    PedAttractorManager = GetPedAttractorManager();
    CPedAttractorManager::DeRegisterPed(PedAttractorManager, this->m_pPed, this->m_pAttractor);
  }
  m_pEntity = this->m_pEntity;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, &this->m_pEntity);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v6);
}
// 4F45AE: variable 'v6' is possibly undefined
// 66A0F0: using guessed type void *off_66A0F0;

//----- (004F45B8) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseEffectRunning::Clone(const CTaskComplexUseEffectRunning *this)
{
  void *v2; // r4
  __int64 v3; // kr00_8

  v2 = CTask::operator new(0x24u);
  v3 = *(_QWORD *)&this->m_pEffect;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_DWORD *)v2 + 3) = v3;
  *((_DWORD *)v2 + 5) = 0;
  *((_DWORD *)v2 + 6) = 0;
  *((_DWORD *)v2 + 7) = 4;
  *((_BYTE *)v2 + 32) = 0;
  *(_DWORD *)v2 = &off_66A0F0;
  *((_DWORD *)v2 + 4) = HIDWORD(v3);
  if ( HIDWORD(v3) )
    CEntity::RegisterReference((CEntity *)HIDWORD(v3), (CEntity **)v2 + 4);
  *((_DWORD *)v2 + 7) = 6;
  *(_DWORD *)v2 = &off_66A87C;
  return (CTask *)v2;
}
// 66A0F0: using guessed type void *off_66A0F0;
// 66A87C: using guessed type void *;
// 6778C8: using guessed type void *`vtable for'CTaskComplexUseEffectRunning;

//----- (004F461C) --------------------------------------------------------
int __fastcall CTaskComplexUseEffectRunning::GetTaskType(const CTaskComplexUseEffectRunning *this)
{
  return 259;
}

//----- (004F4624) --------------------------------------------------------
void __fastcall CTaskComplexUseEffectSprinting::~CTaskComplexUseEffectSprinting(CTaskComplexUseEffectSprinting *this)
{
  CPed *m_pPed; // r1
  bool v3; // zf
  CPedAttractorManager *PedAttractorManager; // r0
  CEntity *m_pEntity; // r0
  void *v6; // r0

  m_pPed = this->m_pPed;
  v3 = m_pPed == 0;
  this->_vptr$CTask = (int (**)(void))&off_66A0F0;
  if ( m_pPed )
    v3 = this->m_pAttractor == 0;
  if ( !v3 )
  {
    PedAttractorManager = GetPedAttractorManager();
    CPedAttractorManager::DeRegisterPed(PedAttractorManager, this->m_pPed, this->m_pAttractor);
  }
  m_pEntity = this->m_pEntity;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, &this->m_pEntity);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v6);
}
// 4F4666: variable 'v6' is possibly undefined
// 66A0F0: using guessed type void *off_66A0F0;

//----- (004F4670) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseEffectSprinting::Clone(const CTaskComplexUseEffectSprinting *this)
{
  void *v2; // r4
  __int64 v3; // kr00_8

  v2 = CTask::operator new(0x24u);
  v3 = *(_QWORD *)&this->m_pEffect;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_DWORD *)v2 + 3) = v3;
  *((_DWORD *)v2 + 5) = 0;
  *((_DWORD *)v2 + 6) = 0;
  *((_DWORD *)v2 + 7) = 4;
  *((_BYTE *)v2 + 32) = 0;
  *(_DWORD *)v2 = &off_66A0F0;
  *((_DWORD *)v2 + 4) = HIDWORD(v3);
  if ( HIDWORD(v3) )
    CEntity::RegisterReference((CEntity *)HIDWORD(v3), (CEntity **)v2 + 4);
  *((_DWORD *)v2 + 7) = 7;
  *(_DWORD *)v2 = &off_66A8B8;
  return (CTask *)v2;
}
// 66A0F0: using guessed type void *off_66A0F0;
// 66A8B8: using guessed type void *;
// 679400: using guessed type void *`vtable for'CTaskComplexUseEffectSprinting;

//----- (004F46D4) --------------------------------------------------------
int __fastcall CTaskComplexUseEffectSprinting::GetTaskType(const CTaskComplexUseEffectSprinting *this)
{
  return 260;
}

//----- (004F46DC) --------------------------------------------------------
void __fastcall CTaskComplexEnterCar::CTaskComplexEnterCar(
        CTaskComplexEnterCar *this,
        CVehicle *pTargetVehicle,
        const bool bAsDriver,
        const bool bQuitAfterOpeningDoor,
        const bool bQuitAfterDraggingPedOut,
        const bool bCarryOnAfterFallingOff)
{
  char v10; // r3

  CTaskComplex::CTaskComplex(this);
  this->m_iMoveState = 6;
  *(_WORD *)&this->m_nNumGettingInSet = 0;
  this->m_pTaskUtilityLineUpPedWithCar = 0;
  this->m_bIsAborting = 0;
  this->m_pDraggedPed = 0;
  this->m_nDoorFlagsSet = 0;
  this->m_fCruiseSpeed = -1.0;
  v10 = *((_BYTE *)this + 16);
  *(_QWORD *)&this->m_iTargetDoor = 0LL;
  *(_QWORD *)&this->m_iTargetSeat = 0LL;
  *((_BYTE *)this + 16) = bAsDriver | (2 * bQuitAfterOpeningDoor) | (4 * bQuitAfterDraggingPedOut) | (8 * bCarryOnAfterFallingOff) | v10 & 0xF0;
  this->_vptr$CTask = (int (**)(void))&off_66A8F4;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66A8F4: using guessed type void *off_66A8F4;

//----- (004F4764) --------------------------------------------------------
void __fastcall CTaskComplexEnterCarAsPassenger::~CTaskComplexEnterCarAsPassenger(CTaskComplexEnterCar *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r5
  CTaskUtilityLineUpPedWithCar *m_pTaskUtilityLineUpPedWithCar; // r0
  void *v5; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66A8F4;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pTaskUtilityLineUpPedWithCar = this->m_pTaskUtilityLineUpPedWithCar;
  if ( m_pTaskUtilityLineUpPedWithCar )
  {
    CTaskUtilityLineUpPedWithCar::~CTaskUtilityLineUpPedWithCar(m_pTaskUtilityLineUpPedWithCar);
    operator delete(v5);
  }
  if ( *p_m_pTargetVehicle )
  {
    BYTE1((*p_m_pTargetVehicle)[19].m_pMat) -= this->m_nNumGettingInSet;
    CVehicle::ClearGettingInFlags(this->m_pTargetVehicle, this->m_nDoorFlagsSet);
  }
  sub_18EDB4(this);
}
// 4F478C: variable 'v5' is possibly undefined
// 66A8F4: using guessed type void *off_66A8F4;

//----- (004F47BE) --------------------------------------------------------
CVector *__fastcall CTaskComplexEnterCar::GetTargetPos(CVector *retstr, CTaskComplexEnterCar *this)
{
  CVector *result; // r0
  CTask v5; // d16
  CTask *m_pSubTask; // r0
  CTask *v7; // r0

  if ( this->m_iTargetDoor )
  {
    result = (CVector *)LODWORD(this->m_vTargetDoorPos.z);
    v5 = *(CTask *)&this->m_vTargetDoorPos.x;
LABEL_3:
    LODWORD(retstr->z) = result;
    *(CTask *)&retstr->x = v5;
    return result;
  }
  m_pSubTask = this->m_pSubTask;
  if ( m_pSubTask && (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) == 800 )
  {
    v7 = this->m_pSubTask;
    v5 = v7[7];
    result = (CVector *)v7[8]._vptr$CTask;
    goto LABEL_3;
  }
  result = 0;
  retstr->x = 0.0;
  retstr->y = 0.0;
  retstr->z = 0.0;
  return result;
}

//----- (004F47FC) --------------------------------------------------------
void __fastcall CTaskComplexEnterCar::GetCameraStickModifier(
        CTaskComplexEnterCar *this,
        CPed *pPed,
        float fCamDist,
        float *fAlpha,
        float *fBeta,
        float *fStickAlpha,
        float *fStickBeta)
{
  CVehicle *m_pTargetVehicle; // r0
  bool v12; // zf
  CPad *Pad; // r10
  int v14; // r0
  int v15; // r0
  int v16; // r0
  int v17; // r0
  int v18; // r0
  int v19; // r0
  int v20; // r0
  uint8 *p_m_nCamMovementChoice; // r11
  CVehicle *v22; // r4
  CMatrix *m_pMat; // r5
  float m_heading; // s20
  int v25; // r0
  CMatrix *v26; // r1
  CSimpleTransform *p_tx; // r0
  CSimpleTransform *p_m_transform; // r2
  CMatrix *v29; // r1
  unsigned __int64 v30; // d1
  float v31; // s18
  float v32; // s22
  float y; // s0
  int *v34; // r0
  float v35; // s0
  float v36; // s4
  float v37; // s0
  int v38; // r0
  float v39; // s8
  float v40; // s4
  float v41; // s8
  float v42; // s6
  float v43; // s0
  float v44; // s2
  float v45; // s4

  m_pTargetVehicle = this->m_pTargetVehicle;
  v12 = m_pTargetVehicle == 0;
  if ( m_pTargetVehicle )
    v12 = m_pTargetVehicle->m_vehicleType == 3;
  if ( !v12 )
  {
    Pad = CPad::GetPad(0);
    if ( pPed->m_nPedType == 1 )
      Pad = CPad::GetPad(1);
    if ( (*((int (__fastcall **)(CTaskComplexEnterCar *))this->_vptr$CTask + 3))(this) )
    {
      v14 = (*((int (__fastcall **)(CTaskComplexEnterCar *))this->_vptr$CTask + 3))(this);
      if ( (*(int (__fastcall **)(int))(*(_DWORD *)v14 + 20))(v14) == 802
        || (v15 = (*((int (__fastcall **)(CTaskComplexEnterCar *))this->_vptr$CTask + 3))(this),
            (*(int (__fastcall **)(int))(*(_DWORD *)v15 + 20))(v15) == 802)
        || (v16 = (*((int (__fastcall **)(CTaskComplexEnterCar *))this->_vptr$CTask + 3))(this),
            (*(int (__fastcall **)(int))(*(_DWORD *)v16 + 20))(v16) == 804)
        || (v17 = (*((int (__fastcall **)(CTaskComplexEnterCar *))this->_vptr$CTask + 3))(this),
            (*(int (__fastcall **)(int))(*(_DWORD *)v17 + 20))(v17) == 820)
        || (v18 = (*((int (__fastcall **)(CTaskComplexEnterCar *))this->_vptr$CTask + 3))(this),
            (*(int (__fastcall **)(int))(*(_DWORD *)v18 + 20))(v18) == 807)
        || (v19 = (*((int (__fastcall **)(CTaskComplexEnterCar *))this->_vptr$CTask + 3))(this),
            (*(int (__fastcall **)(int))(*(_DWORD *)v19 + 20))(v19) == 808) )
      {
        if ( COERCE_FLOAT(COERCE_UNSIGNED_INT(CPad::AimWeaponLeftRight(Pad, pPed, 0)) & 0x7FFFFFFF) <= 20.0
          && fabsf((float)CPad::AimWeaponUpDown(Pad, pPed, 0)) <= 20.0 )
        {
          if ( CPad::GetAccelerate(Pad) )
          {
            v20 = 2;
          }
          else
          {
            if ( !CPad::GetBrake(Pad) )
            {
              p_m_nCamMovementChoice = &this->m_nCamMovementChoice;
              if ( this->m_nCamMovementChoice == 3 )
                return;
              goto LABEL_19;
            }
            v20 = 1;
          }
        }
        else
        {
          v20 = 3;
        }
        this->m_nCamMovementChoice = v20;
        p_m_nCamMovementChoice = &this->m_nCamMovementChoice;
        if ( v20 == 3 )
          return;
LABEL_19:
        v22 = this->m_pTargetVehicle;
        m_pMat = v22->m_pMat;
        if ( m_pMat )
          m_heading = atan2f(COERCE_FLOAT(LODWORD(m_pMat->xy) ^ 0x80000000), m_pMat->yy);
        else
          m_heading = v22->m_transform.m_heading;
        v26 = pPed->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &v22->m_transform;
        p_m_transform = (CSimpleTransform *)&v26->tx;
        if ( !v26 )
          p_m_transform = &pPed->m_transform;
        v29 = v22->m_pMat;
        v30 = vmul_f32(
                vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.y, *(float32x2_t *)&p_tx->m_translate.y),
                *(float32x2_t *)&v29->yx).n64_u64[0];
        v31 = (float)((float)((float)(p_m_transform->m_translate.x - p_tx->m_translate.x) * v29->xx) + *(float *)&v30)
            + *((float *)&v30 + 1);
        v32 = atan2f(v31, fCamDist) * 0.7;
        y = CEntity::GetColModel(v22)->m_boxBound.m_vecMin.y;
        v34 = dword_4F4B30;
        v35 = -y;
        v36 = m_heading + -1.5708;
        if ( v32 > 0.0 )
          v34 = &dword_4F4B30[1];
        if ( v35 > fCamDist )
          v32 = *(float *)v34;
        v37 = v36 - v32;
        v38 = *p_m_nCamMovementChoice;
        v39 = v36 + 3.1416;
        v40 = *fBeta;
        v41 = v39 + v32;
        if ( v38 == 1 )
          v37 = v41;
        if ( v37 <= (float)(*fBeta + 3.1416) )
        {
          if ( v37 >= (float)(v40 + -3.1416) )
            goto LABEL_42;
          v42 = 6.2832;
        }
        else
        {
          v42 = -6.2832;
        }
        v37 = v37 + v42;
LABEL_42:
        v43 = v37 - v40;
        if ( v31 <= 0.0 )
        {
          if ( v38 == 1 )
          {
LABEL_44:
            if ( v43 >= 1.5708 )
              v43 = -v43;
LABEL_50:
            v44 = MOVEMENT_RATES[v38];
            v45 = v44;
            if ( v43 <= v44 )
            {
              v45 = v43;
              if ( v43 < (float)-v44 )
                v45 = -v44;
            }
            *fStickBeta = *fStickBeta + (float)(v45 * v44);
            if ( *fAlpha > -0.17453 )
              *fStickAlpha = *fStickAlpha
                           - (float)(MOVEMENT_RATES[*p_m_nCamMovementChoice] * MOVEMENT_RATES[*p_m_nCamMovementChoice]);
            return;
          }
        }
        else if ( v38 != 1 )
        {
          goto LABEL_44;
        }
        if ( v43 <= -1.5708 )
          v43 = -v43;
        goto LABEL_50;
      }
    }
    if ( (*((int (__fastcall **)(CTaskComplexEnterCar *))this->_vptr$CTask + 3))(this) )
    {
      v25 = (*((int (__fastcall **)(CTaskComplexEnterCar *))this->_vptr$CTask + 3))(this);
      if ( (*(int (__fastcall **)(int))(*(_DWORD *)v25 + 20))(v25) == 805 )
      {
        CPad::GetAccelerate(Pad);
        CPad::GetBrake(Pad);
      }
    }
  }
}
// 4F4B30: using guessed type int dword_4F4B30[2];

//----- (004F4B5C) --------------------------------------------------------
CVehicle *__fastcall CTaskComplexEnterCar::GetCameraAvoidVehicle(CTaskComplexEnterCar *this)
{
  int v2; // r0
  int v3; // r1
  CVehicle *result; // r0

  if ( !this->m_pTargetVehicle || !(*((int (__fastcall **)(CTaskComplexEnterCar *))this->_vptr$CTask + 3))(this) )
    return 0;
  v2 = (*((int (__fastcall **)(CTaskComplexEnterCar *))this->_vptr$CTask + 3))(this);
  v3 = (*(int (__fastcall **)(int))(*(_DWORD *)v2 + 20))(v2);
  result = 0;
  switch ( v3 )
  {
    case 704:
    case 715:
    case 719:
    case 801:
    case 802:
    case 803:
    case 804:
    case 805:
    case 807:
    case 808:
    case 811:
    case 812:
    case 816:
    case 817:
    case 820:
      result = this->m_pTargetVehicle;
      break;
    case 705:
    case 706:
    case 707:
    case 708:
    case 709:
    case 710:
    case 711:
    case 712:
    case 713:
    case 714:
    case 716:
    case 717:
    case 718:
    case 720:
    case 721:
    case 722:
    case 723:
    case 724:
    case 725:
    case 726:
    case 727:
    case 728:
    case 729:
    case 730:
    case 731:
    case 732:
    case 733:
    case 734:
    case 735:
    case 736:
    case 737:
    case 738:
    case 739:
    case 740:
    case 741:
    case 742:
    case 743:
    case 744:
    case 745:
    case 746:
    case 747:
    case 748:
    case 749:
    case 750:
    case 751:
    case 752:
    case 753:
    case 754:
    case 755:
    case 756:
    case 757:
    case 758:
    case 759:
    case 760:
    case 761:
    case 762:
    case 763:
    case 764:
    case 765:
    case 766:
    case 767:
    case 768:
    case 769:
    case 770:
    case 771:
    case 772:
    case 773:
    case 774:
    case 775:
    case 776:
    case 777:
    case 778:
    case 779:
    case 780:
    case 781:
    case 782:
    case 783:
    case 784:
    case 785:
    case 786:
    case 787:
    case 788:
    case 789:
    case 790:
    case 791:
    case 792:
    case 793:
    case 794:
    case 795:
    case 796:
    case 797:
    case 798:
    case 799:
    case 800:
    case 806:
    case 809:
    case 810:
    case 813:
    case 814:
    case 815:
    case 818:
    case 819:
      return result;
    default:
      if ( v3 == 203 )
        result = this->m_pTargetVehicle;
      break;
  }
  return result;
}

//----- (004F4C1E) --------------------------------------------------------
bool __fastcall CTaskComplexEnterCar::MakeAbortable(
        CTaskComplexEnterCar *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CTask *m_pSubTask; // r0
  CTaskSimpleStandStill *v9; // r0
  int m_iTargetDoor; // r2
  CTaskSimpleCarSetPedOut *v11; // r0
  int v12; // r1
  CTaskSimpleCarCloseDoorFromOutside *v13; // r0
  CTaskSimpleCarCloseDoorFromOutside v15; // [sp+4h] [bp-4Ch] BYREF
  CTaskSimpleStandStill v16; // [sp+20h] [bp-30h] BYREF

  if ( !this->m_pTargetVehicle )
    return 1;
  m_pSubTask = this->m_pSubTask;
  if ( iPriority == 2 )
  {
    (*((void (__fastcall **)(CTask *, CPed *, int, const CEvent *))m_pSubTask->_vptr$CTask + 7))(
      m_pSubTask,
      pPed,
      2,
      pEvent);
    CTaskSimpleStandStill::CTaskSimpleStandStill(&v16, -1, 0, 0, 8.0);
    CTaskSimpleStandStill::ProcessPed(v9, pPed);
    m_iTargetDoor = this->m_iTargetDoor;
    if ( m_iTargetDoor )
    {
      CTaskSimpleCarSetPedOut::CTaskSimpleCarSetPedOut(
        (CTaskSimpleCarSetPedOut *)&v15,
        this->m_pTargetVehicle,
        m_iTargetDoor,
        0);
      CTaskSimpleCarSetPedOut::ProcessPed(v11, pPed);
      CTaskSimpleCarSetPedOut::~CTaskSimpleCarSetPedOut((CTaskSimpleCarSetPedOut *)&v15);
      v12 = this->m_iTargetDoor;
      if ( v12 )
      {
        if ( CCarEnterExit::CarHasDoorToClose(this->m_pTargetVehicle, v12) )
        {
          CTaskSimpleCarCloseDoorFromOutside::CTaskSimpleCarCloseDoorFromOutside(
            &v15,
            this->m_pTargetVehicle,
            this->m_iTargetDoor,
            0);
          CTaskSimpleCarCloseDoorFromOutside::MakeAbortable(v13, pPed, 2, pEvent);
          CTaskSimpleCarCloseDoorFromOutside::~CTaskSimpleCarCloseDoorFromOutside(&v15);
        }
      }
    }
    CTaskSimpleStandStill::~CTaskSimpleStandStill(&v16);
    return 1;
  }
  if ( (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) == 800 )
    return (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
            + 7))(
             this->m_pSubTask,
             pPed,
             iPriority,
             pEvent);
  else
    return 0;
}
// 4F4C5C: variable 'v9' is possibly undefined
// 4F4C72: variable 'v11' is possibly undefined
// 4F4C9E: variable 'v13' is possibly undefined

//----- (004F4CE4) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterCar::CreateFirstSubTask(CTaskComplexEnterCar *this, CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r0
  CVehicle *v5; // r0
  bool v6; // zf
  CPedGroup *PedsGroup; // r6
  void *v8; // r8
  CVehicle *v9; // r9
  char *v10; // r6
  CVehicle *m_pMyVehicle; // r4
  CEntity **v12; // r1
  CVehicle *v14; // r1
  int m_nModelIndex; // r0
  CVehicle *v16; // r4
  char v17; // r0
  char v18; // r0
  bool v19; // zf
  CVector *p_m_vTargetDoorPos; // r8
  int *p_m_iTargetDoor; // r5
  __int64 v22; // d16
  CEventGroupEvent v23; // [sp+14h] [bp-2Ch] BYREF

  m_pTargetVehicle = this->m_pTargetVehicle;
  this->m_iEnterCarStartTime = CTimer::m_snTimeInMilliseconds;
  if ( !m_pTargetVehicle
    || m_pTargetVehicle->m_pFire
    || !CCarEnterExit::IsVehicleHealthy(m_pTargetVehicle)
    || !CCarEnterExit::IsPedHealthy(pPed) )
  {
    return CTaskComplexEnterCar::CreateSubTask(this, 1302, pPed);
  }
  v5 = this->m_pTargetVehicle;
  v6 = *((unsigned __int8 *)this + 16) << 31 == 0;
  if ( !(*((unsigned __int8 *)this + 16) << 31) )
    v6 = v5->m_nMaxPassengers == 0;
  if ( v6 || v5->m_baseVehicleType == 6 && BYTE1(v5[1].m_pRwObject) << 31 )
    return CTaskComplexEnterCar::CreateSubTask(this, 1302, pPed);
  PedsGroup = CPedGroups::GetPedsGroup(pPed);
  if ( (*((_BYTE *)this + 16) & 3) == 1
    && PedsGroup
    && (*((_BYTE *)this + 16) & 4) == 0
    && CPedGroupMembership::IsLeader(&PedsGroup->m_membership, pPed) )
  {
    v8 = CEvent::operator new(0x14u);
    v9 = this->m_pTargetVehicle;
    CEventEditableResponse::CEventEditableResponse((CEventEditableResponse *)v8);
    *(_DWORD *)v8 = &off_666E48;
    *((_DWORD *)v8 + 4) = v9;
    if ( v9 )
      CEntity::RegisterReference(v9, (CEntity **)v8 + 4);
    CEventGroupEvent::CEventGroupEvent(&v23, pPed, (CEvent *)v8);
    CPedGroupIntelligence::AddEvent(&PedsGroup->m_intelligence, &v23);
    CEventGroupEvent::~CEventGroupEvent(&v23);
  }
  if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
  {
    if ( pPed->m_pMyVehicle == this->m_pTargetVehicle )
    {
      v10 = (char *)CTask::operator new(0x70u);
      v16 = this->m_pTargetVehicle;
      CTaskSimple::CTaskSimple((CTaskSimple *)v10);
      *(_QWORD *)(v10 + 12) = 0LL;
      *(_QWORD *)(v10 + 20) = 0LL;
      *((_WORD *)v10 + 14) = 0;
      *(_DWORD *)(v10 + 86) = 0;
      *(_DWORD *)(v10 + 82) = 0;
      *((_DWORD *)v10 + 19) = 0;
      *((_DWORD *)v10 + 20) = 0;
      v17 = v10[92];
      *(_DWORD *)v10 = &off_66AD08;
      v18 = v17 & 0xC3 | 8;
      v10[92] = v18;
      *((_DWORD *)v10 + 2) = v16;
      if ( v16 )
      {
        CEntity::RegisterReference(v16, (CEntity **)v10 + 2);
        v18 = v10[92];
      }
      *((_DWORD *)v10 + 8) = -1;
      v10[92] = v18 & 0xFC;
      *((_DWORD *)v10 + 15) = 0;
      *((_DWORD *)v10 + 16) = 0;
      *((_DWORD *)v10 + 17) = 0;
      *((_DWORD *)v10 + 24) = -1;
      *((_WORD *)v10 + 54) = 0;
      *((_DWORD *)v10 + 25) = 0;
      *((_DWORD *)v10 + 26) = 0;
      *(_DWORD *)v10 = &off_66571C;
      return (CTask *)v10;
    }
    v10 = (char *)CTask::operator new(0x34u);
    m_pMyVehicle = pPed->m_pMyVehicle;
    CTaskComplex::CTaskComplex((CTaskComplex *)v10);
    *((_DWORD *)v10 + 4) = 0;
    *((_DWORD *)v10 + 5) = 0;
    *((_WORD *)v10 + 12) = 1;
    v10[26] = 0;
    *((_DWORD *)v10 + 7) = 0;
    v10[32] = 0;
    v10[33] = 0;
    *((_DWORD *)v10 + 9) = 15;
    *((_DWORD *)v10 + 10) = 1082130432;
    *((_DWORD *)v10 + 11) = 1065353216;
    v10[48] = 0;
    *(_DWORD *)v10 = &off_66ABDC;
    *((_DWORD *)v10 + 3) = m_pMyVehicle;
    v12 = (CEntity **)(v10 + 12);
    if ( m_pMyVehicle )
LABEL_24:
      CEntity::RegisterReference(m_pMyVehicle, v12);
  }
  else
  {
    if ( this->m_pTargetVehicle->m_baseVehicleType == 5 )
    {
      v10 = (char *)CTask::operator new(0x10u);
      m_pMyVehicle = this->m_pTargetVehicle;
      CTaskComplex::CTaskComplex((CTaskComplex *)v10);
      *(_DWORD *)v10 = &off_66AB64;
      v12 = (CEntity **)(v10 + 12);
      *((_DWORD *)v10 + 3) = m_pMyVehicle;
      if ( !m_pMyVehicle )
        return (CTask *)v10;
      goto LABEL_24;
    }
    v10 = (char *)CTask::operator new(0x50u);
    CTaskComplexGoToCarDoorAndStandStill::CTaskComplexGoToCarDoorAndStandStill(
      (CTaskComplexGoToCarDoorAndStandStill *)v10,
      this->m_pTargetVehicle,
      this->m_iMoveState,
      *((_BYTE *)this + 16) & 1,
      this->m_iTargetSeat,
      0.5,
      4.0,
      50.0,
      (const int)&elf_hash_bucket[7437]);
    if ( v10 )
    {
      if ( !(*((unsigned __int8 *)&pPed->m_nPhysicalFlags + 1) << 31) || *(_BYTE *)&pPed->m_nPedFlags << 31 )
        return (CTask *)v10;
      v14 = this->m_pTargetVehicle;
      m_nModelIndex = v14->m_nModelIndex;
      if ( m_nModelIndex >= 460 )
      {
        v19 = m_nModelIndex == 539;
        if ( m_nModelIndex != 539 )
          v19 = m_nModelIndex == 460;
        if ( !v19 )
          return (CTask *)v10;
      }
      else if ( m_nModelIndex != 417 && m_nModelIndex != 447 )
      {
        return (CTask *)v10;
      }
      p_m_vTargetDoorPos = &this->m_vTargetDoorPos;
      p_m_iTargetDoor = &this->m_iTargetDoor;
      if ( CCarEnterExit::GetNearestCarDoor(pPed, v14, p_m_vTargetDoorPos, p_m_iTargetDoor) )
      {
        *((_DWORD *)v10 + 13) = *p_m_iTargetDoor;
        v22 = *(_QWORD *)&p_m_vTargetDoorPos->x;
        *((_DWORD *)v10 + 16) = LODWORD(p_m_vTargetDoorPos->z);
        v10[72] = 1;
        *((_QWORD *)v10 + 7) = v22;
      }
    }
    else
    {
      return 0;
    }
  }
  return (CTask *)v10;
}
// FC: using guessed type int elf_hash_bucket[16411];
// 66571C: using guessed type void *off_66571C;
// 666E48: using guessed type void *off_666E48;
// 66AB64: using guessed type void *off_66AB64;
// 66ABDC: using guessed type void *off_66ABDC;
// 66AD08: using guessed type void *off_66AD08;
// 676B38: using guessed type void *`vtable for'CTaskSimpleCarDriveTimed;

//----- (004F4FE4) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterCar::CreateSubTask(CTaskComplexEnterCar *this, const int iSubTaskType, CPed *pPed)
{
  char *v5; // r4
  CVehicle *m_pMyVehicle; // r5
  CEntity **v7; // r1
  unsigned int v8; // r8
  CTaskComplexFallAndGetUp *v9; // r0
  AnimationId v10; // r1
  CVehicle *m_pTargetVehicle; // r1
  CVehicle *v12; // r0
  CVehicle *v13; // r0
  uint8 m_nDoorFlagsSet; // r1
  CVehicle *v15; // r0
  int m_iTargetDoor; // r1
  CVehicle *v17; // r0
  uint32 DoorStatus; // r0
  CEntity::CFlags *p_m_nFlags; // r0
  int m_nFlags; // r1
  uint32 bdummy; // r2
  CVehicle *v22; // r1
  int v23; // r2
  CVehicle *v24; // r0
  CEventGlobalGroup *EventGlobalGroup; // r0
  CPedGroup *PedsGroup; // r0
  CPedGroup *v27; // r10
  CEvent *v28; // r8
  _BOOL4 IsPlayer; // r0
  bool v30; // zf
  CVehicle *v31; // r0
  CVehicle *v32; // r5
  char v33; // r0
  char v34; // r0
  char *v35; // r0
  GxtChar *v36; // r0
  CMatrix *m_pMat; // r0
  __int64 v38; // d16
  bool v39; // zf
  float m_fCruiseSpeed; // s0
  CEventCopCarBeingStolen v42; // [sp+18h] [bp-30h] BYREF

  v5 = 0;
  if ( iSubTaskType < 704 )
  {
    switch ( iSubTaskType )
    {
      case 200:
        v5 = (char *)CTask::operator new(8u);
        CTaskSimple::CTaskSimple((CTaskSimple *)v5);
        v35 = (char *)&`vtable for'CTaskSimpleNone;
LABEL_75:
        *(_DWORD *)v5 = v35 + 8;
        break;
      case 203:
        v5 = (char *)CTask::operator new(0x20u);
        CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v5, 0, 0, 0, 8.0);
        break;
      case 208:
        v8 = this->m_iTargetDoor & 0xFFFFFFFE;
        v9 = (CTaskComplexFallAndGetUp *)CTask::operator new(0x18u);
        if ( v8 == 10 )
          v10 = ANIM_STD_HIGHIMPACT_RIGHT;
        else
          v10 = ANIM_STD_HIGHIMPACT_LEFT;
        v5 = (char *)v9;
        CTaskComplexFallAndGetUp::CTaskComplexFallAndGetUp(v9, v10, ANIM_STD_PED, 2000);
        if ( FindPlayerPed(-1) == pPed )
          CPlayerInfo::SetLastTargetVehicle(&CWorld::Players[CWorld::PlayerInFocus], this->m_pTargetVehicle);
        if ( pPed && !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
          *(_DWORD *)&pPed->m_nFlags |= 1u;
        m_pTargetVehicle = this->m_pTargetVehicle;
        if ( m_pTargetVehicle )
        {
          CTaskSimpleCarSetPedOut::PositionPedOutOfCollision(pPed, m_pTargetVehicle, this->m_iTargetDoor);
          v12 = this->m_pTargetVehicle;
          if ( v12 )
          {
            v12->m_nNumGettingIn -= this->m_nNumGettingInSet;
            v13 = this->m_pTargetVehicle;
            m_nDoorFlagsSet = this->m_nDoorFlagsSet;
            this->m_nNumGettingInSet = 0;
            CVehicle::ClearGettingInFlags(v13, m_nDoorFlagsSet);
            v15 = this->m_pTargetVehicle;
            m_iTargetDoor = this->m_iTargetDoor;
            this->m_nDoorFlagsSet = 0;
            if ( !(*((int (__fastcall **)(CVehicle *, int))v15->_vptr$CPlaceable + 39))(v15, m_iTargetDoor) )
            {
              v17 = this->m_pTargetVehicle;
              if ( !v17->m_baseVehicleType
                && (!CDamageManager::GetDoorStatus((const CDamageManager *)&v17[1], this->m_iTargetDoor)
                 || CDamageManager::GetDoorStatus(
                      (const CDamageManager *)&this->m_pTargetVehicle[1],
                      this->m_iTargetDoor) == 2) )
              {
                DoorStatus = CDamageManager::GetDoorStatus(
                               (const CDamageManager *)&this->m_pTargetVehicle[1],
                               this->m_iTargetDoor);
                CDamageManager::SetDoorStatus(
                  (CDamageManager *)&this->m_pTargetVehicle[1],
                  this->m_iTargetDoor,
                  DoorStatus + 1);
              }
            }
          }
        }
        break;
    }
  }
  else
  {
    switch ( iSubTaskType )
    {
      case 704:
        v5 = (char *)CTask::operator new(0x34u);
        m_pMyVehicle = pPed->m_pMyVehicle;
        CTaskComplex::CTaskComplex((CTaskComplex *)v5);
        *((_DWORD *)v5 + 4) = 0;
        *((_DWORD *)v5 + 5) = 0;
        *((_WORD *)v5 + 12) = 1;
        v5[26] = 0;
        *((_DWORD *)v5 + 7) = 0;
        v5[32] = 0;
        v5[33] = 0;
        *((_DWORD *)v5 + 9) = 15;
        *((_DWORD *)v5 + 10) = 1082130432;
        *((_DWORD *)v5 + 11) = 1065353216;
        v5[48] = 0;
        *(_DWORD *)v5 = &off_66ABDC;
        *((_DWORD *)v5 + 3) = m_pMyVehicle;
        v7 = (CEntity **)(v5 + 12);
        if ( !m_pMyVehicle )
          return (CTask *)v5;
        goto LABEL_49;
      case 705:
      case 706:
      case 707:
      case 708:
      case 709:
      case 710:
      case 711:
      case 712:
      case 713:
      case 714:
      case 716:
      case 717:
      case 718:
      case 720:
      case 721:
      case 722:
      case 723:
      case 724:
      case 725:
      case 726:
      case 727:
      case 728:
      case 729:
      case 730:
      case 731:
      case 732:
      case 733:
      case 734:
      case 735:
      case 736:
      case 737:
      case 738:
      case 739:
      case 740:
      case 741:
      case 742:
      case 743:
      case 744:
      case 745:
      case 746:
      case 747:
      case 748:
      case 749:
      case 750:
      case 751:
      case 752:
      case 753:
      case 754:
      case 755:
      case 756:
      case 757:
      case 758:
      case 759:
      case 760:
      case 761:
      case 762:
      case 763:
      case 764:
      case 765:
      case 766:
      case 767:
      case 768:
      case 769:
      case 770:
      case 771:
      case 772:
      case 773:
      case 774:
      case 775:
      case 776:
      case 777:
      case 778:
      case 779:
      case 780:
      case 781:
      case 782:
      case 783:
      case 784:
      case 785:
      case 786:
      case 787:
      case 788:
      case 789:
      case 790:
      case 791:
      case 792:
      case 793:
      case 794:
      case 795:
      case 796:
      case 797:
      case 798:
      case 799:
      case 809:
      case 813:
      case 814:
      case 815:
      case 817:
      case 818:
      case 819:
      case 821:
      case 822:
      case 823:
      case 824:
      case 825:
      case 826:
      case 827:
      case 828:
        return (CTask *)v5;
      case 715:
        v5 = (char *)CTask::operator new(0x10u);
        m_pMyVehicle = this->m_pTargetVehicle;
        CTaskComplex::CTaskComplex((CTaskComplex *)v5);
        *(_DWORD *)v5 = &off_66AB64;
        v7 = (CEntity **)(v5 + 12);
        *((_DWORD *)v5 + 3) = m_pMyVehicle;
        if ( m_pMyVehicle )
LABEL_49:
          CEntity::RegisterReference(m_pMyVehicle, v7);
        break;
      case 719:
        v5 = (char *)CTask::operator new(0x70u);
        v32 = this->m_pTargetVehicle;
        CTaskSimple::CTaskSimple((CTaskSimple *)v5);
        *(_QWORD *)(v5 + 12) = 0LL;
        *(_QWORD *)(v5 + 20) = 0LL;
        *((_WORD *)v5 + 14) = 0;
        *(_DWORD *)(v5 + 86) = 0;
        *(_DWORD *)(v5 + 82) = 0;
        *((_DWORD *)v5 + 19) = 0;
        *((_DWORD *)v5 + 20) = 0;
        v33 = v5[92];
        *(_DWORD *)v5 = &off_66AD08;
        v34 = v33 & 0xC3 | 8;
        v5[92] = v34;
        *((_DWORD *)v5 + 2) = v32;
        if ( v32 )
        {
          CEntity::RegisterReference(v32, (CEntity **)v5 + 2);
          v34 = v5[92];
        }
        *((_DWORD *)v5 + 8) = -1;
        v5[92] = v34 & 0xFC;
        *((_DWORD *)v5 + 15) = 0;
        *((_DWORD *)v5 + 16) = 0;
        *((_DWORD *)v5 + 17) = 0;
        *((_DWORD *)v5 + 24) = -1;
        *((_WORD *)v5 + 54) = 0;
        v35 = (char *)&`vtable for'CTaskSimpleCarDriveTimed;
        *((_DWORD *)v5 + 25) = 0;
        *((_DWORD *)v5 + 26) = 0;
        goto LABEL_75;
      case 800:
        v5 = (char *)CTask::operator new(0x50u);
        CTaskComplexGoToCarDoorAndStandStill::CTaskComplexGoToCarDoorAndStandStill(
          (CTaskComplexGoToCarDoorAndStandStill *)v5,
          this->m_pTargetVehicle,
          this->m_iMoveState,
          *((_BYTE *)this + 16) & 1,
          this->m_iTargetSeat,
          0.5,
          4.0,
          50.0,
          (const int)&elf_hash_bucket[7437]);
        break;
      case 801:
        v5 = (char *)CTask::operator new(0x28u);
        CTaskSimpleCarAlign::CTaskSimpleCarAlign(
          (CTaskSimpleCarAlign *)v5,
          this->m_pTargetVehicle,
          &this->m_vTargetDoorPos,
          this->m_iTargetDoor,
          this->m_pTaskUtilityLineUpPedWithCar);
        break;
      case 802:
        v5 = (char *)CTask::operator new(0x24u);
        CTaskSimpleCarOpenDoorFromOutside::CTaskSimpleCarOpenDoorFromOutside(
          (CTaskSimpleCarOpenDoorFromOutside *)v5,
          this->m_pTargetVehicle,
          this->m_iTargetDoor,
          this->m_pTaskUtilityLineUpPedWithCar,
          (*((_BYTE *)this + 16) & 2) != 0);
        break;
      case 803:
        v5 = (char *)CTask::operator new(0x1Cu);
        CTaskSimpleCarOpenLockedDoorFromOutside::CTaskSimpleCarOpenLockedDoorFromOutside(
          (CTaskSimpleCarOpenLockedDoorFromOutside *)v5,
          this->m_pTargetVehicle,
          this->m_iTargetDoor,
          this->m_pTaskUtilityLineUpPedWithCar);
        break;
      case 804:
        v5 = (char *)CTask::operator new(0x1Cu);
        CTaskSimplePickUpBike::CTaskSimplePickUpBike(
          (CTaskSimplePickUpBike *)v5,
          this->m_pTargetVehicle,
          this->m_iTargetDoor,
          this->m_pTaskUtilityLineUpPedWithCar);
        break;
      case 805:
        v5 = (char *)CTask::operator new(0x1Cu);
        CTaskSimpleCarCloseDoorFromInside::CTaskSimpleCarCloseDoorFromInside(
          (CTaskSimpleCarCloseDoorFromInside *)v5,
          this->m_pTargetVehicle,
          this->m_iTargetDoor,
          this->m_pTaskUtilityLineUpPedWithCar);
        break;
      case 806:
        v5 = (char *)CTask::operator new(0x1Cu);
        CTaskSimpleCarCloseDoorFromOutside::CTaskSimpleCarCloseDoorFromOutside(
          (CTaskSimpleCarCloseDoorFromOutside *)v5,
          this->m_pTargetVehicle,
          this->m_iTargetDoor,
          this->m_pTaskUtilityLineUpPedWithCar);
        break;
      case 807:
        v5 = (char *)CTask::operator new(0x24u);
        CTaskSimpleCarGetIn::CTaskSimpleCarGetIn(
          (CTaskSimpleCarGetIn *)v5,
          this->m_pTargetVehicle,
          this->m_iTargetDoor,
          this->m_pTaskUtilityLineUpPedWithCar);
        break;
      case 808:
        v5 = (char *)CTask::operator new(0x1Cu);
        CTaskSimpleCarShuffle::CTaskSimpleCarShuffle(
          (CTaskSimpleCarShuffle *)v5,
          this->m_pTargetVehicle,
          this->m_iTargetDoor,
          this->m_pTaskUtilityLineUpPedWithCar);
        break;
      case 810:
        v5 = (char *)CTask::operator new(0x14u);
        CTaskSimpleCarWaitForDoorNotToBeInUse::CTaskSimpleCarWaitForDoorNotToBeInUse(
          (CTaskSimpleCarWaitForDoorNotToBeInUse *)v5,
          this->m_pTargetVehicle,
          this->m_iTargetDoor,
          this->m_iTargetDoorOppositeToFlag);
        break;
      case 811:
        v5 = (char *)CTask::operator new(0x20u);
        CTaskSimpleCarSetPedInAsPassenger::CTaskSimpleCarSetPedInAsPassenger(
          (CTaskSimpleCarSetPedInAsPassenger *)v5,
          this->m_pTargetVehicle,
          this->m_iTargetDoor,
          this->m_pTaskUtilityLineUpPedWithCar);
        break;
      case 812:
        v5 = (char *)CTask::operator new(0x1Cu);
        CTaskSimpleCarSetPedInAsDriver::CTaskSimpleCarSetPedInAsDriver(
          (CTaskSimpleCarSetPedInAsDriver *)v5,
          this->m_pTargetVehicle,
          this->m_pTaskUtilityLineUpPedWithCar);
        break;
      case 816:
        v5 = (char *)CTask::operator new(0x18u);
        CTaskSimpleCarSetPedOut::CTaskSimpleCarSetPedOut(
          (CTaskSimpleCarSetPedOut *)v5,
          this->m_pTargetVehicle,
          this->m_iTargetDoor,
          1);
        break;
      case 820:
        if ( pPed && CPed::IsPlayer(pPed) && !CPlayerPed::bHasDisplayedPlayerQuitEnterCarHelpText )
        {
          CPlayerPed::bHasDisplayedPlayerQuitEnterCarHelpText = 1;
          v36 = CText::Get(&TheText, "JCK_HLP");
          CHud::SetHelpMessage("JCK_HLP", v36, 0, 0, 0, 0);
        }
        v5 = (char *)CTask::operator new(0x20u);
        CTaskSimpleCarSlowDragPedOut::CTaskSimpleCarSlowDragPedOut(
          (CTaskSimpleCarSlowDragPedOut *)v5,
          this->m_pTargetVehicle,
          this->m_iTargetDoor,
          this->m_pTaskUtilityLineUpPedWithCar,
          (*((_BYTE *)this + 16) & 4) != 0);
        break;
      case 829:
        m_pMat = this->m_pTargetVehicle->m_pMat;
        v38 = *(_QWORD *)&m_pMat->xx;
        *(float *)&v42.m_bIsPersistent = m_pMat->zx;
        *(_QWORD *)&v42._vptr$CEvent = v38;
        if ( (this->m_iTargetDoor & 0xFFFFFFFE) == 10 )
        {
          *(float *)&v42._vptr$CEvent = -*(float *)&v42._vptr$CEvent;
          *(float *)&v42.m_iAccumulatedTime = -*(float *)&v42.m_iAccumulatedTime;
          *(float *)&v42.m_bIsPersistent = -*(float *)&v42.m_bIsPersistent;
        }
        v5 = (char *)CTask::operator new(0x1Cu);
        CTaskSimpleWaitUntilPedIsOutCar::CTaskSimpleWaitUntilPedIsOutCar(
          (CTaskSimpleWaitUntilPedIsOutCar *)v5,
          this->m_pDraggedPed,
          (const CVector *)&v42);
        break;
      default:
        if ( iSubTaskType == 1302 )
        {
          if ( !pPed )
            goto LABEL_82;
          if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
          {
            p_m_nFlags = &pPed->m_nFlags;
            m_nFlags = (int)pPed->m_nFlags;
            if ( (m_nFlags & 1) == 0 )
            {
              bdummy = pPed->m_nFlags.bdummy;
              *(_DWORD *)p_m_nFlags = m_nFlags | 1;
              pPed->m_nFlags.bdummy = bdummy;
              v22 = this->m_pTargetVehicle;
              if ( v22 )
              {
                v23 = this->m_iTargetDoor;
                if ( v23 )
                  CTaskSimpleCarSetPedOut::PositionPedOutOfCollision(pPed, v22, v23);
              }
            }
          }
          if ( CPed::IsPlayer(pPed) )
          {
            v24 = this->m_pTargetVehicle;
            if ( v24 )
            {
              if ( CVehicle::IsLawEnforcementVehicle(v24) && (*((_BYTE *)this + 16) & 7) == 1 && this->m_nDoorFlagsSet )
              {
                CEventCopCarBeingStolen::CEventCopCarBeingStolen(&v42, pPed, this->m_pTargetVehicle);
                EventGlobalGroup = GetEventGlobalGroup();
                CEventGroup::Add(EventGlobalGroup, &v42, 0);
                CEventCopCarBeingStolen::~CEventCopCarBeingStolen(&v42);
              }
            }
          }
          if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) && (*((_BYTE *)this + 16) & 7) == 1 )
          {
            PedsGroup = CPedGroups::GetPedsGroup(pPed);
            v27 = PedsGroup;
            if ( PedsGroup )
            {
              if ( CPedGroupMembership::IsLeader(&PedsGroup->m_membership, pPed) )
              {
                v28 = (CEvent *)CEvent::operator new(0xCu);
                CEvent::CEvent(v28);
                v28->_vptr$CEvent = (int (**)(void))&off_666EE8;
                CEventGroupEvent::CEventGroupEvent((CEventGroupEvent *)&v42, pPed, v28);
                CPedGroupIntelligence::AddEvent(&v27->m_intelligence, &v42);
                CEventGroupEvent::~CEventGroupEvent((CEventGroupEvent *)&v42);
              }
            }
          }
          IsPlayer = CPed::IsPlayer(pPed);
          v30 = IsPlayer;
          if ( IsPlayer )
            v30 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
          if ( !v30 )
            goto LABEL_87;
          v31 = this->m_pTargetVehicle;
          v39 = v31 == 0;
          if ( v31 )
            v39 = v31->pDriver == 0;
          if ( v39 || (*((_BYTE *)this + 16) & 2) != 0 )
          {
LABEL_87:
            if ( CPed::IsPlayer(pPed) )
              goto LABEL_82;
            if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
              goto LABEL_82;
            v31 = this->m_pTargetVehicle;
            if ( !v31 )
              goto LABEL_82;
          }
          m_fCruiseSpeed = this->m_fCruiseSpeed;
          if ( m_fCruiseSpeed >= 0.0 )
          {
            v5 = 0;
            v31->AutoPilot.CruiseSpeed = (unsigned int)m_fCruiseSpeed;
          }
          else
          {
LABEL_82:
            v5 = 0;
          }
        }
        break;
    }
  }
  return (CTask *)v5;
}
// FC: using guessed type int elf_hash_bucket[16411];
// 666EE8: using guessed type void *off_666EE8;
// 66AB64: using guessed type void *;
// 66ABDC: using guessed type void *off_66ABDC;
// 66AD08: using guessed type void *off_66AD08;
// 676B38: using guessed type void *`vtable for'CTaskSimpleCarDriveTimed;
// 678150: using guessed type void *`vtable for'CTaskSimpleNone;

//----- (004F56E4) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterCar::CreateNextSubTask(CTaskComplexEnterCar *this, CPed *pPed)
{
  int v4; // r0
  void *SubTask; // r6
  CVehicle *m_pTargetVehicle; // r0
  int v8; // r0
  CTaskComplexEnterCar *v9; // r0
  int v10; // r1
  unsigned int v11; // r0
  bool v12; // zf
  char v13; // r8
  int *p_m_iTargetDoor; // r9
  CVehicle *v15; // r4
  CTask *m_pSubTask; // r2
  int m_pParent; // r1
  char v18; // r3
  CTask v19; // d16
  int v20; // r3
  CVehicle *v21; // r0
  int v22; // r2
  int v23; // r2
  CVehicle *v24; // r0
  float m_fCruiseSpeed; // s0
  CVehicle *v26; // r0
  CVehicle *v27; // r0
  int v28; // r6
  _BOOL4 HasDoorToClose; // r0
  int v30; // r1
  CPed *v31; // r1
  UInt8 v32; // r0
  CPedIntelligence *v33; // r0
  CTaskSimpleDuck *v34; // r0
  CMatrix *v35; // r0
  CSimpleTransform *p_m_transform; // r1
  float v37; // s8
  float v38; // s10
  CTaskUtilityLineUpPedWithCar *v39; // r0
  CTaskUtilityLineUpPedWithCar *v40; // r0
  CVehicle *v41; // r0
  int32 v42; // r1
  bool v43; // zf
  CPed *v44; // r1
  CMatrix *v45; // r0
  __int64 v46; // d16
  CPed *v47; // r1
  UInt8 CruiseSpeed; // r0
  CPed *v49; // r0
  CPed **p_m_pDraggedPed; // r8
  CPed *m_pDraggedPed; // r6
  _BOOL4 v52; // r0
  CPedGroup *PedsGroup; // r0
  CPedGroup *v54; // r4
  CEvent *v55; // r5
  CVehicle *v56; // r1
  _BOOL4 v57; // r9
  CPedIntelligence *v58; // r8
  void *v59; // r0
  CVehicle *v60; // r10
  void *v61; // r6
  int v62; // r11
  CPedIntelligence *m_pPedIntelligence; // r0
  CTaskSimpleDuck *TaskDuck; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float y; // s8
  float z; // s10
  CTaskUtilityLineUpPedWithCar *v69; // r0
  CTaskUtilityLineUpPedWithCar *v70; // r0
  CVehicle *v71; // r0
  int32 m_baseVehicleType; // r1
  bool v73; // zf
  CVehicle *v74; // r8
  CVehicle *v75; // r1
  _BOOL4 IsAlive; // r0
  CPed *v77; // r1
  CPedIntelligence *v78; // r8
  void *v79; // r0
  CVehicle *v80; // r5
  void *v81; // r6
  int v82; // r9
  CPedIntelligence *v83; // r9
  CTaskComplexCarSlowBeDraggedOutAndStandUp *v84; // r10
  CPed *pDriver; // r0
  CVehicle *v86; // r0
  uint32 DoorStatus; // r0
  uint32 v88; // r0
  void *v89; // r0
  CVehicle *v90; // r5
  int v91; // r9
  uint32 mFlags; // r5
  CTaskSimpleCarShuffle *v93; // r0
  CPedGroup *v94; // r0
  CPedGroup *v95; // r4
  CEventEditableResponse *v96; // r5
  CEventGroupEvent v97; // [sp+14h] [bp-4Ch] BYREF
  CEventDraggedOutCar vInitialBlendVector[2]; // [sp+28h] [bp-38h] BYREF

  if ( this->m_bIsAborting )
  {
    v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
    SubTask = 0;
    switch ( v4 )
    {
      case 704:
      case 715:
      case 719:
      case 800:
      case 801:
      case 802:
      case 803:
      case 804:
      case 805:
      case 806:
      case 807:
      case 808:
      case 810:
      case 816:
      case 817:
      case 820:
      case 829:
        goto LABEL_17;
      case 705:
      case 706:
      case 707:
      case 708:
      case 709:
      case 710:
      case 711:
      case 712:
      case 713:
      case 714:
      case 716:
      case 717:
      case 718:
      case 720:
      case 721:
      case 722:
      case 723:
      case 724:
      case 725:
      case 726:
      case 727:
      case 728:
      case 729:
      case 730:
      case 731:
      case 732:
      case 733:
      case 734:
      case 735:
      case 736:
      case 737:
      case 738:
      case 739:
      case 740:
      case 741:
      case 742:
      case 743:
      case 744:
      case 745:
      case 746:
      case 747:
      case 748:
      case 749:
      case 750:
      case 751:
      case 752:
      case 753:
      case 754:
      case 755:
      case 756:
      case 757:
      case 758:
      case 759:
      case 760:
      case 761:
      case 762:
      case 763:
      case 764:
      case 765:
      case 766:
      case 767:
      case 768:
      case 769:
      case 770:
      case 771:
      case 772:
      case 773:
      case 774:
      case 775:
      case 776:
      case 777:
      case 778:
      case 779:
      case 780:
      case 781:
      case 782:
      case 783:
      case 784:
      case 785:
      case 786:
      case 787:
      case 788:
      case 789:
      case 790:
      case 791:
      case 792:
      case 793:
      case 794:
      case 795:
      case 796:
      case 797:
      case 798:
      case 799:
      case 809:
      case 813:
      case 814:
      case 815:
      case 818:
      case 819:
      case 821:
      case 822:
      case 823:
      case 824:
      case 825:
      case 826:
      case 827:
      case 828:
        return (CTask *)SubTask;
      case 811:
      case 812:
        SubTask = CTask::operator new(0x18u);
        CTaskSimpleCarSetPedOut::CTaskSimpleCarSetPedOut(
          (CTaskSimpleCarSetPedOut *)SubTask,
          this->m_pTargetVehicle,
          this->m_iTargetDoor,
          1);
        return (CTask *)SubTask;
      default:
        v11 = v4 - 200;
        if ( v11 <= 8 && ((1 << v11) & 0x109) != 0 )
          goto LABEL_17;
        return (CTask *)SubTask;
    }
  }
  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( !m_pTargetVehicle || !CCarEnterExit::IsVehicleHealthy(m_pTargetVehicle) )
    goto LABEL_17;
  v8 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  SubTask = 0;
  if ( v8 >= 704 )
  {
    switch ( v8 )
    {
      case 704:
        if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
          goto LABEL_17;
        if ( *((unsigned __int8 *)this + 16) << 31 && this->m_pTargetVehicle->m_baseVehicleType == 5 )
        {
          SubTask = CTask::operator new(0x10u);
          v15 = this->m_pTargetVehicle;
          CTaskComplex::CTaskComplex((CTaskComplex *)SubTask);
          *(_DWORD *)SubTask = &off_66AB64;
          *((_DWORD *)SubTask + 3) = v15;
          if ( v15 )
            CEntity::RegisterReference(v15, (CEntity **)SubTask + 3);
        }
        else
        {
          SubTask = CTask::operator new(0x50u);
          CTaskComplexGoToCarDoorAndStandStill::CTaskComplexGoToCarDoorAndStandStill(
            (CTaskComplexGoToCarDoorAndStandStill *)SubTask,
            this->m_pTargetVehicle,
            this->m_iMoveState,
            *((_BYTE *)this + 16) & 1,
            this->m_iTargetSeat,
            0.5,
            4.0,
            50.0,
            (const int)&elf_hash_bucket[7437]);
        }
        return (CTask *)SubTask;
      case 715:
      case 719:
      case 806:
      case 811:
      case 812:
      case 829:
        goto LABEL_17;
      case 800:
        m_pSubTask = this->m_pSubTask;
        if ( !BYTE1(m_pSubTask[9]._vptr$CTask) )
          goto LABEL_17;
        m_pParent = (int)m_pSubTask[6].m_pParent;
        v18 = *((_BYTE *)this + 16);
        this->m_iTargetDoor = m_pParent;
        v19 = m_pSubTask[7];
        v20 = -(v18 & 1);
        v21 = this->m_pTargetVehicle;
        LODWORD(this->m_vTargetDoorPos.z) = m_pSubTask[8]._vptr$CTask;
        v22 = 0;
        if ( m_pParent == 8 )
          v22 = 10;
        v23 = v22 & v20;
        this->m_iTargetDoorOppositeToFlag = v23;
        *(CTask *)&this->m_vTargetDoorPos.x = v19;
        if ( CCarEnterExit::IsCarDoorInUse(v21, m_pParent, v23) )
        {
          if ( CPed::IsPlayer(pPed) )
          {
            pPed->m_pPlayerData->m_moveBlendRatio = 0.0;
            CPed::SetMoveState(pPed, PEDMOVE_STILL);
            CPlayerPed::SetRealMoveAnim((CPlayerPed *)pPed);
          }
          else
          {
            CPed::SetMoveState(pPed, PEDMOVE_STILL);
            (*((void (__fastcall **)(CPed *))pPed->_vptr$CPlaceable + 24))(pPed);
          }
          SubTask = CTask::operator new(0x14u);
          CTaskSimpleCarWaitForDoorNotToBeInUse::CTaskSimpleCarWaitForDoorNotToBeInUse(
            (CTaskSimpleCarWaitForDoorNotToBeInUse *)SubTask,
            this->m_pTargetVehicle,
            this->m_iTargetDoor,
            this->m_iTargetDoorOppositeToFlag);
          return (CTask *)SubTask;
        }
        if ( !CCarEnterExit::IsCarDoorReady(this->m_pTargetVehicle, this->m_iTargetDoor)
          && !CCarEnterExit::CarHasPartiallyOpenDoor(this->m_pTargetVehicle, this->m_iTargetDoor) )
        {
          goto LABEL_17;
        }
        CTaskComplexEnterCar::SetVehicleFlags(this, v47);
        if ( this->m_pTargetVehicle->AutoPilot.CruiseSpeed )
          this->m_fCruiseSpeed = (float)this->m_pTargetVehicle->AutoPilot.CruiseSpeed;
        if ( CPed::IsPlayer(pPed) && CCarEnterExit::CarHasDoorToOpen(this->m_pTargetVehicle, this->m_iTargetDoor) )
        {
          if ( CCarEnterExit::CarHasOpenableDoor(this->m_pTargetVehicle, this->m_iTargetDoor, pPed) )
            CruiseSpeed = 0;
          else
            CruiseSpeed = this->m_pTargetVehicle->AutoPilot.CruiseSpeed;
        }
        else
        {
          CruiseSpeed = 0;
        }
        this->m_pTargetVehicle->AutoPilot.CruiseSpeed = CruiseSpeed;
        m_pPedIntelligence = pPed->m_pPedIntelligence;
        *(_DWORD *)&pPed->m_nFlags &= ~1u;
        if ( CPedIntelligence::GetTaskDuck(m_pPedIntelligence, 1) )
        {
          TaskDuck = CPedIntelligence::GetTaskDuck(pPed->m_pPedIntelligence, 1);
          (*((void (__fastcall **)(CTaskSimpleDuck *, CPed *, int, _DWORD))TaskDuck->_vptr$CTask + 7))(
            TaskDuck,
            pPed,
            1,
            0);
        }
        CCarEnterExit::GetPositionToOpenCarDoor((CVector *)&v97, this->m_pTargetVehicle, this->m_iTargetDoor);
        m_pMat = pPed->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &pPed->m_transform;
        y = p_tx->m_translate.y;
        z = p_tx->m_translate.z;
        *(float *)&vInitialBlendVector[0]._vptr$CEvent = *(float *)&v97._vptr$CEvent - p_tx->m_translate.x;
        *(float *)&vInitialBlendVector[0].m_iAccumulatedTime = *(float *)&v97.m_iAccumulatedTime - y;
        *(float *)&vInitialBlendVector[0].m_bIsPersistent = *(float *)&v97.m_bIsPersistent - z;
        v69 = (CTaskUtilityLineUpPedWithCar *)operator new(0x1Cu);
        CTaskUtilityLineUpPedWithCar::CTaskUtilityLineUpPedWithCar(
          v69,
          (const CVector *)vInitialBlendVector,
          600,
          0,
          this->m_iTargetDoor);
        this->m_pTaskUtilityLineUpPedWithCar = v70;
        v71 = this->m_pTargetVehicle;
        m_baseVehicleType = v71->m_baseVehicleType;
        v73 = m_baseVehicleType == 9;
        if ( m_baseVehicleType != 9 )
          v73 = v71->m_vehicleType == 2;
        if ( !v73 )
          goto LABEL_82;
        return (CTask *)(*((int (__fastcall **)(CTaskComplexEnterCar *, CPed *))this->_vptr$CTask + 13))(this, pPed);
      case 801:
        return (CTask *)(*((int (__fastcall **)(CTaskComplexEnterCar *, CPed *))this->_vptr$CTask + 13))(this, pPed);
      case 802:
      case 804:
        if ( !CPed::IsPlayer(pPed)
          && sqrtf(
               (float)(this->m_pTargetVehicle->m_vecMoveSpeed.x * this->m_pTargetVehicle->m_vecMoveSpeed.x)
             + (float)(this->m_pTargetVehicle->m_vecMoveSpeed.y * this->m_pTargetVehicle->m_vecMoveSpeed.y)) > 0.1
          || CPed::IsPlayer(pPed)
          && sqrtf(
               (float)(this->m_pTargetVehicle->m_vecMoveSpeed.x * this->m_pTargetVehicle->m_vecMoveSpeed.x)
             + (float)(this->m_pTargetVehicle->m_vecMoveSpeed.y * this->m_pTargetVehicle->m_vecMoveSpeed.y)) > 0.2 )
        {
          *(_DWORD *)&pPed->m_nFlags |= 1u;
          if ( CPed::IsPlayer(pPed) )
            goto LABEL_17;
          v9 = this;
          v10 = 208;
          return CTaskComplexEnterCar::CreateSubTask(v9, v10, pPed);
        }
        if ( (*((_BYTE *)this + 16) & 2) != 0 )
        {
          *((_BYTE *)this + 16) &= ~2u;
          goto LABEL_17;
        }
        if ( (*((_BYTE *)this + 16) & 4) != 0 )
        {
          p_m_iTargetDoor = &this->m_iTargetDoor;
        }
        else
        {
          p_m_iTargetDoor = &this->m_iTargetDoor;
          if ( !CCarEnterExit::IsCarSlowJackRequired(this->m_pTargetVehicle, this->m_iTargetDoor, pPed) )
            goto LABEL_72;
        }
        v49 = CCarEnterExit::ComputeSlowJackedPed(this->m_pTargetVehicle, this->m_iTargetDoor);
        p_m_pDraggedPed = &this->m_pDraggedPed;
        this->m_pDraggedPed = v49;
        if ( v49 )
          CEntity::RegisterReference(v49, &this->m_pDraggedPed);
        m_pDraggedPed = this->m_pDraggedPed;
        if ( (*((_BYTE *)this + 16) & 4) != 0 )
          goto LABEL_106;
        if ( !m_pDraggedPed )
          goto LABEL_72;
        v52 = CPedGroups::AreInSameGroup(this->m_pDraggedPed, pPed);
        m_pDraggedPed = *p_m_pDraggedPed;
        if ( !v52 && (*((_BYTE *)&m_pDraggedPed->m_nPedFlags + 3) & 0x20) == 0 )
        {
LABEL_106:
          if ( m_pDraggedPed )
          {
            if ( CPed::IsPlayer(m_pDraggedPed) && CGameLogic::SkipState == 2 )
            {
              SubTask = CTaskComplexEnterCar::CreateSubTask(this, 1302, pPed);
              PedsGroup = CPedGroups::GetPedsGroup(this->m_pDraggedPed);
              v54 = PedsGroup;
              if ( PedsGroup && CPedGroupMembership::IsLeader(&PedsGroup->m_membership, *p_m_pDraggedPed) )
              {
                v55 = (CEvent *)CEvent::operator new(0xCu);
                CEvent::CEvent(v55);
                v55->_vptr$CEvent = (int (**)(void))&off_666EE8;
                CEventGroupEvent::CEventGroupEvent((CEventGroupEvent *)vInitialBlendVector, *p_m_pDraggedPed, v55);
                CPedGroupIntelligence::AddEvent(&v54->m_intelligence, (CEvent *)vInitialBlendVector);
                CEventGroupEvent::~CEventGroupEvent((CEventGroupEvent *)vInitialBlendVector);
              }
              return (CTask *)SubTask;
            }
            if ( *p_m_pDraggedPed )
            {
              SubTask = CTaskComplexEnterCar::CreateSubTask(this, 820, pPed);
              v83 = this->m_pDraggedPed->m_pPedIntelligence;
              v84 = (CTaskComplexCarSlowBeDraggedOutAndStandUp *)CTask::operator new(0x14u);
              CTaskComplexCarSlowBeDraggedOutAndStandUp::CTaskComplexCarSlowBeDraggedOutAndStandUp(
                v84,
                this->m_pTargetVehicle,
                this->m_iTargetDoor);
              CPedIntelligence::AddTaskPrimaryMaybeInGroup(v83, v84, 1);
              CEventDraggedOutCar::CEventDraggedOutCar(
                vInitialBlendVector,
                this->m_pTargetVehicle,
                pPed,
                this->m_pTargetVehicle->pDriver == this->m_pDraggedPed);
              CEventGroup::Add(&this->m_pDraggedPed->m_pPedIntelligence->m_eventGroup, (CEvent *)vInitialBlendVector, 1);
              pDriver = this->m_pTargetVehicle->pDriver;
              if ( pDriver == this->m_pDraggedPed )
              {
                v94 = CPedGroups::GetPedsGroup(pDriver);
                v95 = v94;
                if ( v94 )
                {
                  if ( CPedGroupMembership::IsLeader(&v94->m_membership, *p_m_pDraggedPed) )
                  {
                    v96 = (CEventEditableResponse *)CEvent::operator new(0x10u);
                    CEventEditableResponse::CEventEditableResponse(v96);
                    v96->_vptr$CEvent = (int (**)(void))&off_666E98;
                    CEventGroupEvent::CEventGroupEvent(&v97, *p_m_pDraggedPed, (CEvent *)v96);
                    CPedGroupIntelligence::AddEvent(&v95->m_intelligence, &v97);
                    CEventGroupEvent::~CEventGroupEvent(&v97);
                  }
                }
              }
              CEventDraggedOutCar::~CEventDraggedOutCar(vInitialBlendVector);
              return (CTask *)SubTask;
            }
          }
          if ( (*((_BYTE *)this + 16) & 4) != 0 )
          {
            v86 = this->m_pTargetVehicle;
            if ( !v86->m_baseVehicleType
              && (!CDamageManager::GetDoorStatus((const CDamageManager *)&v86[1], *p_m_iTargetDoor)
               || CDamageManager::GetDoorStatus((const CDamageManager *)&this->m_pTargetVehicle[1], this->m_iTargetDoor) == 2) )
            {
              DoorStatus = CDamageManager::GetDoorStatus(
                             (const CDamageManager *)&this->m_pTargetVehicle[1],
                             this->m_iTargetDoor);
              CDamageManager::SetDoorStatus(
                (CDamageManager *)&this->m_pTargetVehicle[1],
                this->m_iTargetDoor,
                DoorStatus + 1);
            }
            goto LABEL_17;
          }
LABEL_72:
          SubTask = CTask::operator new(0x24u);
          CTaskSimpleCarGetIn::CTaskSimpleCarGetIn(
            (CTaskSimpleCarGetIn *)SubTask,
            this->m_pTargetVehicle,
            this->m_iTargetDoor,
            this->m_pTaskUtilityLineUpPedWithCar);
          return (CTask *)SubTask;
        }
        if ( !m_pDraggedPed )
          goto LABEL_72;
        if ( !(*((unsigned __int8 *)this + 16) << 31) )
          goto LABEL_139;
        if ( !CVehicle::IsDriver(this->m_pTargetVehicle, *p_m_pDraggedPed) )
        {
          m_pDraggedPed = *p_m_pDraggedPed;
          if ( !*p_m_pDraggedPed )
            goto LABEL_72;
LABEL_139:
          if ( *((unsigned __int8 *)this + 16) << 31 )
            goto LABEL_72;
          v74 = this->m_pTargetVehicle;
          if ( m_pDraggedPed != v74->pPassengers[CCarEnterExit::ComputePassengerIndexFromCarDoor(
                                                   v74,
                                                   this->m_iTargetDoor)] )
            goto LABEL_72;
        }
        if ( CCarEnterExit::CarHasDoorToClose(this->m_pTargetVehicle, this->m_iTargetDoor) )
        {
          SubTask = CTask::operator new(0x1Cu);
          CTaskSimpleCarCloseDoorFromOutside::CTaskSimpleCarCloseDoorFromOutside(
            (CTaskSimpleCarCloseDoorFromOutside *)SubTask,
            this->m_pTargetVehicle,
            this->m_iTargetDoor,
            this->m_pTaskUtilityLineUpPedWithCar);
          return (CTask *)SubTask;
        }
LABEL_17:
        v9 = this;
        v10 = 1302;
        return CTaskComplexEnterCar::CreateSubTask(v9, v10, pPed);
      case 803:
        v24 = this->m_pTargetVehicle;
        if ( v24 )
        {
          m_fCruiseSpeed = this->m_fCruiseSpeed;
          if ( m_fCruiseSpeed >= 0.0 )
            v24->AutoPilot.CruiseSpeed = (unsigned int)m_fCruiseSpeed;
        }
        SubTask = CTask::operator new(0x20u);
        CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)SubTask, 0, 0, 0, 8.0);
        return (CTask *)SubTask;
      case 805:
        v26 = this->m_pTargetVehicle;
        if ( !v26 || !CCarEnterExit::IsVehicleHealthy(v26) || !CCarEnterExit::IsPedHealthy(pPed) )
          goto LABEL_17;
        if ( !(*((unsigned __int8 *)this + 16) << 31) )
        {
          SubTask = CTask::operator new(0x20u);
          CTaskSimpleCarSetPedInAsPassenger::CTaskSimpleCarSetPedInAsPassenger(
            (CTaskSimpleCarSetPedInAsPassenger *)SubTask,
            this->m_pTargetVehicle,
            this->m_iTargetDoor,
            this->m_pTaskUtilityLineUpPedWithCar);
          return (CTask *)SubTask;
        }
        if ( this->m_iTargetDoor == 8 )
        {
          v75 = this->m_pTargetVehicle;
          if ( v75->pDriver )
          {
            CEventDraggedOutCar::CEventDraggedOutCar(vInitialBlendVector, v75, pPed, 1);
            CEventGroup::Add(
              &this->m_pTargetVehicle->pDriver->m_pPedIntelligence->m_eventGroup,
              (CEvent *)vInitialBlendVector,
              1);
            IsAlive = CPed::IsAlive(this->m_pTargetVehicle->pDriver);
            v77 = this->m_pTargetVehicle->pDriver;
            if ( IsAlive && v77->m_nHealth > 0.0 )
            {
              v78 = v77->m_pPedIntelligence;
              v79 = CTask::operator new(0x34u);
              v80 = this->m_pTargetVehicle;
              v81 = v79;
              v82 = CCarEnterExit::ComputeTargetDoorToExit(v80, v80->pDriver);
              CTaskComplex::CTaskComplex((CTaskComplex *)v81);
              *(_DWORD *)v81 = &off_66ABDC;
              *((_DWORD *)v81 + 4) = v82;
              *((_DWORD *)v81 + 5) = 0;
              *((_WORD *)v81 + 12) = 256;
              *((_BYTE *)v81 + 26) = 0;
              *((_DWORD *)v81 + 7) = 0;
              *((_BYTE *)v81 + 32) = 0;
              *((_BYTE *)v81 + 33) = 0;
              *((_DWORD *)v81 + 9) = 15;
              *((_DWORD *)v81 + 10) = 1082130432;
              *((_DWORD *)v81 + 11) = 1065353216;
              *((_BYTE *)v81 + 48) = 0;
              *((_DWORD *)v81 + 3) = v80;
              CEntity::RegisterReference(v80, (CEntity **)v81 + 3);
            }
            else
            {
              v78 = v77->m_pPedIntelligence;
              v89 = CTask::operator new(0x34u);
              v90 = this->m_pTargetVehicle;
              v81 = v89;
              v91 = CCarEnterExit::ComputeTargetDoorToExit(v90, v90->pDriver);
              CTaskComplex::CTaskComplex((CTaskComplex *)v81);
              *(_DWORD *)v81 = &off_66ABDC;
              *((_DWORD *)v81 + 4) = v91;
              *((_DWORD *)v81 + 5) = 0;
              *((_WORD *)v81 + 12) = 256;
              *((_BYTE *)v81 + 26) = 0;
              *((_DWORD *)v81 + 7) = 0;
              *((_BYTE *)v81 + 32) = 0;
              *((_BYTE *)v81 + 33) = 0;
              *((_DWORD *)v81 + 9) = 15;
              *((_DWORD *)v81 + 10) = 1082130432;
              *((_DWORD *)v81 + 11) = 1065353216;
              *((_BYTE *)v81 + 48) = 0;
              *((_DWORD *)v81 + 3) = v90;
              CEntity::RegisterReference(v90, (CEntity **)v81 + 3);
              *((_BYTE *)v81 + 26) = 1;
              *(_DWORD *)v81 = &off_66AF44;
            }
            CPedIntelligence::AddTaskPrimaryMaybeInGroup(v78, (CTask *)v81, 1);
            CEventDraggedOutCar::~CEventDraggedOutCar(vInitialBlendVector);
            v75 = this->m_pTargetVehicle;
          }
          mFlags = v75->pHandling->mFlags;
          v93 = (CTaskSimpleCarShuffle *)CTask::operator new(0x1Cu);
          SubTask = v93;
          if ( (mFlags & 0x200) == 0 )
          {
            CTaskSimpleCarShuffle::CTaskSimpleCarShuffle(
              v93,
              this->m_pTargetVehicle,
              this->m_iTargetDoor,
              this->m_pTaskUtilityLineUpPedWithCar);
            return (CTask *)SubTask;
          }
        }
        else
        {
LABEL_69:
          SubTask = CTask::operator new(0x1Cu);
        }
        CTaskSimpleCarSetPedInAsDriver::CTaskSimpleCarSetPedInAsDriver(
          (CTaskSimpleCarSetPedInAsDriver *)SubTask,
          this->m_pTargetVehicle,
          this->m_pTaskUtilityLineUpPedWithCar);
        return (CTask *)SubTask;
      case 807:
        CCarEnterExit::MakeUndraggedPassengerPedsLeaveCar(this->m_pTargetVehicle, this->m_pDraggedPed, pPed);
        if ( *((unsigned __int8 *)this + 16) << 31
          && CPed::IsPlayer(pPed)
          && (v27 = this->m_pTargetVehicle, !v27->m_baseVehicleType)
          && (unsigned int)(v27->m_vehicleType - 3) >= 2
          && (CPad::GetAccelerate(Pads) > 254 || CPad::GetBrake(Pads) >= 255) )
        {
          if ( (!CDamageManager::GetDoorStatus((const CDamageManager *)&this->m_pTargetVehicle[1], this->m_iTargetDoor)
             || CDamageManager::GetDoorStatus((const CDamageManager *)&this->m_pTargetVehicle[1], this->m_iTargetDoor) == 2)
            && CCarEnterExit::CarHasDoorToClose(this->m_pTargetVehicle, this->m_iTargetDoor) )
          {
            v88 = CDamageManager::GetDoorStatus((const CDamageManager *)&this->m_pTargetVehicle[1], this->m_iTargetDoor);
            CDamageManager::SetDoorStatus((CDamageManager *)&this->m_pTargetVehicle[1], this->m_iTargetDoor, v88 + 1);
          }
          v28 = 1;
        }
        else
        {
          v28 = 0;
        }
        HasDoorToClose = CCarEnterExit::CarHasDoorToClose(this->m_pTargetVehicle, this->m_iTargetDoor);
        if ( v28 || !HasDoorToClose )
        {
          if ( *((unsigned __int8 *)this + 16) << 31 )
          {
            if ( this->m_iTargetDoor != 8
              || (v56 = this->m_pTargetVehicle, v56->m_baseVehicleType)
              || (v56->pHandling->mFlags & 0x200) != 0 )
            {
              v30 = 812;
            }
            else
            {
              if ( v56->pDriver )
              {
                CEventDraggedOutCar::CEventDraggedOutCar(vInitialBlendVector, v56, pPed, 1);
                CEventGroup::Add(
                  &this->m_pTargetVehicle->pDriver->m_pPedIntelligence->m_eventGroup,
                  (CEvent *)vInitialBlendVector,
                  1);
                v57 = CPed::IsAlive(this->m_pTargetVehicle->pDriver);
                v58 = this->m_pTargetVehicle->pDriver->m_pPedIntelligence;
                v59 = CTask::operator new(0x34u);
                v60 = this->m_pTargetVehicle;
                v61 = v59;
                v62 = CCarEnterExit::ComputeTargetDoorToExit(v60, v60->pDriver);
                CTaskComplex::CTaskComplex((CTaskComplex *)v61);
                *(_DWORD *)v61 = &off_66ABDC;
                *((_DWORD *)v61 + 4) = v62;
                *((_DWORD *)v61 + 5) = 0;
                *((_WORD *)v61 + 12) = 256;
                *((_BYTE *)v61 + 26) = 0;
                *((_DWORD *)v61 + 7) = 0;
                *((_BYTE *)v61 + 32) = 0;
                *((_BYTE *)v61 + 33) = 0;
                *((_DWORD *)v61 + 9) = 15;
                *((_DWORD *)v61 + 10) = 1082130432;
                *((_DWORD *)v61 + 11) = 1065353216;
                *((_BYTE *)v61 + 48) = 0;
                *((_DWORD *)v61 + 3) = v60;
                CEntity::RegisterReference(v60, (CEntity **)v61 + 3);
                if ( v57 )
                {
                  *((_BYTE *)v61 + 26) = 1;
                  *(_DWORD *)v61 = &off_66AF44;
                }
                CPedIntelligence::AddTaskPrimaryMaybeInGroup(v58, (CTask *)v61, 1);
                CEventDraggedOutCar::~CEventDraggedOutCar(vInitialBlendVector);
              }
              v30 = 808;
            }
          }
          else
          {
            v30 = 811;
          }
        }
        else
        {
          v30 = 805;
        }
        return CTaskComplexEnterCar::CreateSubTask(this, v30, pPed);
      case 808:
        goto LABEL_69;
      case 810:
        if ( !CCarEnterExit::IsCarDoorReady(this->m_pTargetVehicle, this->m_iTargetDoor)
          && !CCarEnterExit::CarHasPartiallyOpenDoor(this->m_pTargetVehicle, this->m_iTargetDoor) )
        {
          return 0;
        }
        CTaskComplexEnterCar::SetVehicleFlags(this, v31);
        if ( this->m_pTargetVehicle->AutoPilot.CruiseSpeed )
          this->m_fCruiseSpeed = (float)this->m_pTargetVehicle->AutoPilot.CruiseSpeed;
        if ( CPed::IsPlayer(pPed) && CCarEnterExit::CarHasDoorToOpen(this->m_pTargetVehicle, this->m_iTargetDoor) )
        {
          if ( CCarEnterExit::CarHasOpenableDoor(this->m_pTargetVehicle, this->m_iTargetDoor, pPed) )
            v32 = 0;
          else
            v32 = this->m_pTargetVehicle->AutoPilot.CruiseSpeed;
        }
        else
        {
          v32 = 0;
        }
        this->m_pTargetVehicle->AutoPilot.CruiseSpeed = v32;
        v33 = pPed->m_pPedIntelligence;
        *(_DWORD *)&pPed->m_nFlags &= ~1u;
        if ( CPedIntelligence::GetTaskDuck(v33, 1) )
        {
          v34 = CPedIntelligence::GetTaskDuck(pPed->m_pPedIntelligence, 1);
          (*((void (__fastcall **)(CTaskSimpleDuck *, CPed *, int, _DWORD))v34->_vptr$CTask + 7))(v34, pPed, 1, 0);
        }
        CCarEnterExit::GetPositionToOpenCarDoor((CVector *)&v97, this->m_pTargetVehicle, this->m_iTargetDoor);
        v35 = pPed->m_pMat;
        p_m_transform = (CSimpleTransform *)&v35->tx;
        if ( !v35 )
          p_m_transform = &pPed->m_transform;
        v37 = p_m_transform->m_translate.y;
        v38 = p_m_transform->m_translate.z;
        *(float *)&vInitialBlendVector[0]._vptr$CEvent = *(float *)&v97._vptr$CEvent - p_m_transform->m_translate.x;
        *(float *)&vInitialBlendVector[0].m_iAccumulatedTime = *(float *)&v97.m_iAccumulatedTime - v37;
        *(float *)&vInitialBlendVector[0].m_bIsPersistent = *(float *)&v97.m_bIsPersistent - v38;
        v39 = (CTaskUtilityLineUpPedWithCar *)operator new(0x1Cu);
        CTaskUtilityLineUpPedWithCar::CTaskUtilityLineUpPedWithCar(
          v39,
          (const CVector *)vInitialBlendVector,
          600,
          0,
          this->m_iTargetDoor);
        this->m_pTaskUtilityLineUpPedWithCar = v40;
        v41 = this->m_pTargetVehicle;
        v42 = v41->m_baseVehicleType;
        v43 = v42 == 9;
        if ( v42 != 9 )
          v43 = v41->m_vehicleType == 2;
        if ( v43 )
          return (CTask *)(*((int (__fastcall **)(CTaskComplexEnterCar *, CPed *))this->_vptr$CTask + 13))(this, pPed);
LABEL_82:
        SubTask = CTask::operator new(0x28u);
        CTaskSimpleCarAlign::CTaskSimpleCarAlign(
          (CTaskSimpleCarAlign *)SubTask,
          this->m_pTargetVehicle,
          &this->m_vTargetDoorPos,
          this->m_iTargetDoor,
          this->m_pTaskUtilityLineUpPedWithCar);
        return (CTask *)SubTask;
      case 817:
        CCarEnterExit::MakeUndraggedPassengerPedsLeaveCar(this->m_pTargetVehicle, this->m_pDraggedPed, pPed);
        goto LABEL_69;
      case 820:
        if ( (*((_BYTE *)this + 16) & 4) == 0 )
          goto LABEL_72;
        v44 = this->m_pDraggedPed;
        *((_BYTE *)this + 16) &= ~4u;
        if ( !v44 )
          goto LABEL_17;
        v45 = this->m_pTargetVehicle->m_pMat;
        v46 = *(_QWORD *)&v45->xx;
        *(float *)&vInitialBlendVector[0].m_bIsPersistent = v45->zx;
        *(_QWORD *)&vInitialBlendVector[0]._vptr$CEvent = v46;
        if ( (this->m_iTargetDoor & 0xFFFFFFFE) == 10 )
        {
          *(float *)&vInitialBlendVector[0]._vptr$CEvent = -*(float *)&vInitialBlendVector[0]._vptr$CEvent;
          *(float *)&vInitialBlendVector[0].m_iAccumulatedTime = -*(float *)&vInitialBlendVector[0].m_iAccumulatedTime;
          *(float *)&vInitialBlendVector[0].m_bIsPersistent = -*(float *)&vInitialBlendVector[0].m_bIsPersistent;
        }
        SubTask = CTask::operator new(0x1Cu);
        CTaskSimpleWaitUntilPedIsOutCar::CTaskSimpleWaitUntilPedIsOutCar(
          (CTaskSimpleWaitUntilPedIsOutCar *)SubTask,
          this->m_pDraggedPed,
          (const CVector *)vInitialBlendVector);
        return (CTask *)SubTask;
      default:
        return (CTask *)SubTask;
    }
  }
  v12 = v8 == 200;
  if ( v8 != 200 )
    v12 = v8 == 203;
  if ( v12 )
    goto LABEL_17;
  if ( v8 != 208 )
    return (CTask *)SubTask;
  if ( FindPlayerPed(-1) == pPed )
    CPlayerInfo::SetLastTargetVehicle(&CWorld::Players[CWorld::PlayerInFocus], 0);
  v13 = *((_BYTE *)this + 16);
  SubTask = CTaskComplexEnterCar::CreateSubTask(this, 1302, pPed);
  if ( (v13 & 8) == 0 )
    return (CTask *)SubTask;
  return (CTask *)(*((int (__fastcall **)(CTaskComplexEnterCar *, CPed *))this->_vptr$CTask + 11))(this, pPed);
}
// 4F5C2A: variable 'v31' is possibly undefined
// 4F5D44: variable 'v40' is possibly undefined
// 4F5E4E: variable 'v47' is possibly undefined
// 4F60FE: variable 'v70' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 666E98: using guessed type void *off_666E98;
// 666EE8: using guessed type void *off_666EE8;
// 66AB64: using guessed type void *off_66AB64;
// 66ABDC: using guessed type void *off_66ABDC;
// 66AF44: using guessed type void *off_66AF44;

//----- (004F651C) --------------------------------------------------------
int __fastcall CTaskComplexEnterCar::ComputeTargetDoorOppositeToFlag(CTaskComplexEnterCar *this)
{
  int result; // r0
  int m_iTargetDoor; // r1

  if ( !(*((unsigned __int8 *)this + 16) << 31) )
    return 0;
  m_iTargetDoor = this->m_iTargetDoor;
  result = 0;
  if ( m_iTargetDoor == 8 )
    return 10;
  return result;
}

//----- (004F6532) --------------------------------------------------------
void __fastcall CTaskComplexEnterCar::SetVehicleFlags(CTaskComplexEnterCar *this, CPed *pPed)
{
  int v3; // r5
  CVehicle *m_pTargetVehicle; // r0
  int m_iTargetDoorOppositeToFlag; // r1
  uint8 v6; // r6

  v3 = CCarEnterExit::ComputeDoorFlag(this->m_pTargetVehicle, this->m_iTargetDoor, 1);
  CVehicle::SetGettingInFlags(this->m_pTargetVehicle, v3);
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->m_nNumGettingInSet = 1;
  this->m_nDoorFlagsSet = v3;
  ++m_pTargetVehicle->m_nNumGettingIn;
  m_iTargetDoorOppositeToFlag = this->m_iTargetDoorOppositeToFlag;
  if ( m_iTargetDoorOppositeToFlag )
  {
    v6 = CCarEnterExit::ComputeDoorFlag(this->m_pTargetVehicle, m_iTargetDoorOppositeToFlag, 1);
    if ( v6 != v3 )
    {
      CVehicle::SetGettingInFlags(this->m_pTargetVehicle, v6);
      this->m_nDoorFlagsSet |= v6;
    }
  }
}

//----- (004F6590) --------------------------------------------------------
void __fastcall CTaskComplexEnterCar::PrepareVehicleForPedEnter(CTaskComplexEnterCar *this, CPed *pPed)
{
  unsigned int CruiseSpeed; // r0
  UInt8 v5; // r0

  CruiseSpeed = this->m_pTargetVehicle->AutoPilot.CruiseSpeed;
  if ( CruiseSpeed )
    this->m_fCruiseSpeed = (float)CruiseSpeed;
  if ( CPed::IsPlayer(pPed) && CCarEnterExit::CarHasDoorToOpen(this->m_pTargetVehicle, this->m_iTargetDoor) )
  {
    if ( CCarEnterExit::CarHasOpenableDoor(this->m_pTargetVehicle, this->m_iTargetDoor, pPed) )
      v5 = 0;
    else
      v5 = this->m_pTargetVehicle->AutoPilot.CruiseSpeed;
  }
  else
  {
    v5 = 0;
  }
  this->m_pTargetVehicle->AutoPilot.CruiseSpeed = v5;
}

//----- (004F65E6) --------------------------------------------------------
void __fastcall CTaskComplexEnterCar::PreparePedForVehicleEnter(CTaskComplexEnterCar *this, CPed *pPed)
{
  CPedIntelligence *m_pPedIntelligence; // r0
  CTaskSimpleDuck *TaskDuck; // r0

  m_pPedIntelligence = pPed->m_pPedIntelligence;
  *(_DWORD *)&pPed->m_nFlags &= ~1u;
  if ( CPedIntelligence::GetTaskDuck(m_pPedIntelligence, 1) )
  {
    TaskDuck = CPedIntelligence::GetTaskDuck(pPed->m_pPedIntelligence, 1);
    (*((void (__fastcall **)(CTaskSimpleDuck *, CPed *, int, _DWORD))TaskDuck->_vptr$CTask + 7))(TaskDuck, pPed, 1, 0);
  }
}

//----- (004F661E) --------------------------------------------------------
void __fastcall CTaskComplexEnterCar::CreateTaskUtilityLineUpPedWithCar(CTaskComplexEnterCar *this, CPed *pPed)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float y; // s8
  float z; // s10
  CTaskUtilityLineUpPedWithCar *v8; // r0
  CTaskUtilityLineUpPedWithCar *v9; // r0
  CVector v10; // [sp+8h] [bp-20h] BYREF
  CVector vInitialBlendVector; // [sp+14h] [bp-14h] BYREF

  CCarEnterExit::GetPositionToOpenCarDoor(&v10, this->m_pTargetVehicle, this->m_iTargetDoor);
  m_pMat = pPed->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  y = p_tx->m_translate.y;
  z = p_tx->m_translate.z;
  vInitialBlendVector.x = v10.x - p_tx->m_translate.x;
  vInitialBlendVector.y = v10.y - y;
  vInitialBlendVector.z = v10.z - z;
  v8 = (CTaskUtilityLineUpPedWithCar *)operator new(0x1Cu);
  CTaskUtilityLineUpPedWithCar::CTaskUtilityLineUpPedWithCar(v8, &vInitialBlendVector, 600, 0, this->m_iTargetDoor);
  this->m_pTaskUtilityLineUpPedWithCar = v9;
}
// 4F6686: variable 'v9' is possibly undefined

//----- (004F668C) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterCar::ControlSubTask(CTaskComplexEnterCar *this, CPed *pPed)
{
  CTask *m_pSubTask; // r11
  CVehicle *m_pTargetVehicle; // r1
  CPedGroup *PedsGroup; // r0
  CPedGroup *v7; // r8
  CEvent *v8; // r9
  int m_iTargetDoor; // r1
  CPed *v10; // r0
  char v11; // r1
  char v12; // r0
  CVehicle *v13; // r0
  int v14; // r0
  CTask *v15; // r0
  CTask *v16; // r0
  CTask v17; // d16
  bool v19; // zf
  CPedGroup *v20; // r0
  CPedGroup *v21; // r5
  CEvent *v22; // r8
  CEventGroupEvent v23[2]; // [sp+0h] [bp-30h] BYREF

  m_pSubTask = this->m_pSubTask;
  if ( CPed::IsPlayer(pPed) && (*((_BYTE *)this + 16) & 4) == 0 )
  {
    m_pTargetVehicle = this->m_pTargetVehicle;
    if ( m_pTargetVehicle )
    {
      if ( CCarEnterExit::IsPlayerToQuitCarEnter(pPed, m_pTargetVehicle, this->m_iEnterCarStartTime, this->m_pSubTask) )
      {
        if ( (*((_BYTE *)this + 16) & 7) == 1
          && CPedGroups::IsGroupLeader(pPed)
          && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 807 )
        {
          PedsGroup = CPedGroups::GetPedsGroup(pPed);
          v7 = PedsGroup;
          if ( PedsGroup )
          {
            if ( CPedGroupMembership::IsLeader(&PedsGroup->m_membership, pPed) )
            {
              v8 = (CEvent *)CEvent::operator new(0xCu);
              CEvent::CEvent(v8);
              v8->_vptr$CEvent = (int (**)(void))&off_666EE8;
              CEventGroupEvent::CEventGroupEvent(v23, pPed, v8);
              CPedGroupIntelligence::AddEvent(&v7->m_intelligence, v23);
              CEventGroupEvent::~CEventGroupEvent(v23);
            }
          }
        }
        m_iTargetDoor = this->m_iTargetDoor;
        if ( m_iTargetDoor < 1 )
        {
          v11 = 4;
        }
        else
        {
          v10 = CCarEnterExit::ComputeSlowJackedPed(this->m_pTargetVehicle, m_iTargetDoor);
          v11 = 4;
          if ( v10 )
          {
            v19 = (*((_BYTE *)&v10->m_nPedFlags + 3) & 0x20) == 0;
            v12 = -5;
            if ( !v19 )
            {
              v11 = 2;
              v12 = -3;
            }
            goto LABEL_18;
          }
        }
        v12 = -5;
LABEL_18:
        *((_BYTE *)this + 16) = v12 & *((_BYTE *)this + 16) | v11;
      }
    }
  }
  v13 = this->m_pTargetVehicle;
  if ( !v13 || !CCarEnterExit::IsVehicleHealthy(v13) || !CCarEnterExit::IsPedHealthy(pPed) )
  {
    v15 = this->m_pSubTask;
    this->m_bIsAborting = 1;
    (*((void (__fastcall **)(CTask *, CPed *, _DWORD, _DWORD))v15->_vptr$CTask + 7))(v15, pPed, 0, 0);
    goto LABEL_29;
  }
  if ( *((unsigned __int8 *)this + 16) << 31 || CPed::IsPlayer(pPed) )
  {
    v14 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
    if ( v14 < 800 )
    {
      if ( v14 != 200 && v14 != 715 )
        goto LABEL_29;
      goto LABEL_37;
    }
    v19 = v14 == 810;
    if ( v14 != 810 )
      v19 = v14 == 800;
    if ( v19 )
    {
LABEL_37:
      if ( CPed::IsPlayer(pPed)
        && CCarEnterExit::IsPlayerToQuitCarEnter(
             pPed,
             this->m_pTargetVehicle,
             this->m_iEnterCarStartTime,
             this->m_pSubTask) )
      {
        if ( (*((_BYTE *)this + 16) & 7) == 1 && CPedGroups::IsGroupLeader(pPed) )
        {
          v20 = CPedGroups::GetPedsGroup(pPed);
          v21 = v20;
          if ( v20 )
          {
            if ( CPedGroupMembership::IsLeader(&v20->m_membership, pPed) )
            {
              v22 = (CEvent *)CEvent::operator new(0xCu);
              CEvent::CEvent(v22);
              v22->_vptr$CEvent = (int (**)(void))&off_666EE8;
              CEventGroupEvent::CEventGroupEvent(v23, pPed, v22);
              CPedGroupIntelligence::AddEvent(&v21->m_intelligence, v23);
              CEventGroupEvent::~CEventGroupEvent(v23);
            }
          }
        }
        m_pSubTask = 0;
      }
    }
  }
LABEL_29:
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 800 )
  {
    v16 = this->m_pSubTask;
    if ( v16[6].m_pParent )
    {
      v17 = v16[7];
      LODWORD(this->m_vTargetDoorPos.z) = v16[8]._vptr$CTask;
      *(CTask *)&this->m_vTargetDoorPos.x = v17;
    }
  }
  return m_pSubTask;
}
// 666EE8: using guessed type void *off_666EE8;
// 678BD4: using guessed type void *`vtable for'CEventLeaderQuitEnteringCarAsDriver;

//----- (004F6880) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterCar::CreateNextSubTask_AfterSimpleCarAlign(CTaskComplexEnterCar *this, CPed *pPed)
{
  CPed *v2; // r10
  CTaskComplexEnterCar *v4; // r0
  int v5; // r1
  CTaskSimpleCarOpenDoorFromOutside *SubTask; // r6
  CVehicle *m_pTargetVehicle; // r0
  int32 m_baseVehicleType; // r1
  bool v9; // zf
  CPed *v10; // r0
  CPed **p_m_pDraggedPed; // r8
  CPedGroup *v12; // r0
  CPedGroup *v13; // r4
  CEvent *v14; // r5
  CVehicle *v15; // r0
  int v16; // r1
  bool v17; // zf
  int v18; // r1
  CTask *v19; // r9
  int v20; // r11
  CPedIntelligence *v21; // r6
  CTaskSimpleBikeJacked *v22; // r4
  CVehicle *v23; // r0
  _BOOL4 HasDoorToOpen; // r0
  _BOOL4 v25; // r2
  CVehicle *v26; // r0
  int m_iTargetDoor; // r1
  CVehicle *v28; // r0
  int AnimGroup; // r1
  bool v30; // zf
  CPed *v31; // r0
  CPedGroup *PedsGroup; // r0
  CPedGroup *v33; // r4
  CEvent *v34; // r9
  void **v35; // r0
  CPed *v36; // r0
  CPedIntelligence *v37; // r9
  CTaskSimpleBikeJacked *v38; // r4
  CPed *v39; // r0
  CPedGroup *v40; // r0
  float zx; // s0
  CVehicle *v42; // r0
  CTaskComplexEnterCar *v43; // r11
  int v44; // r5
  CEntity *v45; // r8
  const CPed *v46; // r1
  float v47; // s22
  int v48; // r10
  int32 v49; // r0
  const CPed *v50; // r1
  float v51; // s18
  int v52; // r4
  unsigned __int16 v53; // r0
  char v55; // r0
  _BOOL4 v56; // r0
  CPed *v57; // r4
  CPedIntelligence *m_pPedIntelligence; // r9
  CTaskComplexCarSlowBeDraggedOutAndStandUp *v59; // r4
  CPed *pDriver; // r0
  CVehicle *v61; // r6
  CPedGroup *v62; // r0
  CPedGroup *v63; // r4
  CEventEditableResponse *v64; // r9
  CEventGroupEvent v65; // [sp+28h] [bp-70h] BYREF
  CEventDraggedOutCar v66[3]; // [sp+3Ch] [bp-5Ch] BYREF

  v2 = pPed;
  if ( !CPed::IsPlayer(pPed)
    && sqrtf(
         (float)(this->m_pTargetVehicle->m_vecMoveSpeed.x * this->m_pTargetVehicle->m_vecMoveSpeed.x)
       + (float)(this->m_pTargetVehicle->m_vecMoveSpeed.y * this->m_pTargetVehicle->m_vecMoveSpeed.y)) > 0.1
    || CPed::IsPlayer(v2)
    && sqrtf(
         (float)(this->m_pTargetVehicle->m_vecMoveSpeed.x * this->m_pTargetVehicle->m_vecMoveSpeed.x)
       + (float)(this->m_pTargetVehicle->m_vecMoveSpeed.y * this->m_pTargetVehicle->m_vecMoveSpeed.y)) > 0.2 )
  {
    *(_DWORD *)&v2->m_nFlags |= 1u;
    if ( !CPed::IsPlayer(v2) )
    {
      v4 = this;
      v5 = 208;
LABEL_70:
      SubTask = (CTaskSimpleCarOpenDoorFromOutside *)CTaskComplexEnterCar::CreateSubTask(v4, v5, v2);
      goto LABEL_71;
    }
LABEL_69:
    v4 = this;
    v5 = 1302;
    goto LABEL_70;
  }
  if ( (*((_BYTE *)this + 16) & 2) != 0 )
  {
    if ( !CCarEnterExit::CarHasDoorToOpen(this->m_pTargetVehicle, this->m_iTargetDoor) )
    {
      *((_BYTE *)this + 16) &= ~2u;
      goto LABEL_69;
    }
    if ( CCarEnterExit::CarHasOpenableDoor(this->m_pTargetVehicle, this->m_iTargetDoor, v2) )
      goto LABEL_13;
    goto LABEL_49;
  }
  if ( (*((_BYTE *)this + 16) & 4) == 0
    && CCarEnterExit::IsCarQuickJackPossible(this->m_pTargetVehicle, this->m_iTargetDoor, v2) )
  {
    SubTask = 0;
    goto LABEL_71;
  }
  m_pTargetVehicle = this->m_pTargetVehicle;
  m_baseVehicleType = m_pTargetVehicle->m_baseVehicleType;
  v9 = m_baseVehicleType == 9;
  if ( m_baseVehicleType != 9 )
    v9 = m_pTargetVehicle->m_vehicleType == 2;
  if ( !v9 )
  {
    HasDoorToOpen = CCarEnterExit::CarHasDoorToOpen(m_pTargetVehicle, this->m_iTargetDoor);
    v25 = HasDoorToOpen;
    v26 = this->m_pTargetVehicle;
    m_iTargetDoor = this->m_iTargetDoor;
    if ( v25 )
    {
      if ( CCarEnterExit::CarHasOpenableDoor(v26, m_iTargetDoor, v2) )
      {
        if ( (*((_BYTE *)this + 16) & 6) == 0 )
        {
          v28 = this->m_pTargetVehicle;
          AnimGroup = v28->pHandling->AnimGroup;
          v30 = AnimGroup == 19;
          if ( AnimGroup == 19 )
            v30 = this->m_iTargetDoor == 10;
          if ( v30 && !v28->pDriver )
            goto LABEL_31;
        }
LABEL_13:
        SubTask = (CTaskSimpleCarOpenDoorFromOutside *)CTask::operator new(0x24u);
        CTaskSimpleCarOpenDoorFromOutside::CTaskSimpleCarOpenDoorFromOutside(
          SubTask,
          this->m_pTargetVehicle,
          this->m_iTargetDoor,
          this->m_pTaskUtilityLineUpPedWithCar,
          (*((_BYTE *)this + 16) & 2) != 0);
        goto LABEL_71;
      }
LABEL_49:
      SubTask = (CTaskSimpleCarOpenDoorFromOutside *)CTask::operator new(0x1Cu);
      CTaskSimpleCarOpenLockedDoorFromOutside::CTaskSimpleCarOpenLockedDoorFromOutside(
        (CTaskSimpleCarOpenLockedDoorFromOutside *)SubTask,
        this->m_pTargetVehicle,
        this->m_iTargetDoor,
        this->m_pTaskUtilityLineUpPedWithCar);
      goto LABEL_71;
    }
    if ( CCarEnterExit::IsCarSlowJackRequired(v26, m_iTargetDoor, v2) )
    {
      v31 = CCarEnterExit::ComputeSlowJackedPed(this->m_pTargetVehicle, this->m_iTargetDoor);
      p_m_pDraggedPed = &this->m_pDraggedPed;
      this->m_pDraggedPed = v31;
      if ( v31 )
      {
        CEntity::RegisterReference(v31, &this->m_pDraggedPed);
        if ( *p_m_pDraggedPed )
        {
          if ( CPed::IsPlayer(*p_m_pDraggedPed) && CGameLogic::SkipState == 2 )
          {
            SubTask = (CTaskSimpleCarOpenDoorFromOutside *)CTaskComplexEnterCar::CreateSubTask(this, 1302, v2);
            PedsGroup = CPedGroups::GetPedsGroup(this->m_pDraggedPed);
            v33 = PedsGroup;
            if ( PedsGroup && CPedGroupMembership::IsLeader(&PedsGroup->m_membership, *p_m_pDraggedPed) )
            {
              v34 = (CEvent *)CEvent::operator new(0xCu);
              CEvent::CEvent(v34);
              v35 = &`vtable for'CEventLeaderQuitEnteringCarAsDriver;
LABEL_63:
              v34->_vptr$CEvent = (int (**)(void))((char *)*v35 + 8);
              CEventGroupEvent::CEventGroupEvent((CEventGroupEvent *)v66, *p_m_pDraggedPed, v34);
              CPedGroupIntelligence::AddEvent(&v33->m_intelligence, (CEvent *)v66);
              CEventGroupEvent::~CEventGroupEvent((CEventGroupEvent *)v66);
              goto LABEL_71;
            }
            goto LABEL_71;
          }
        }
      }
      v55 = *((_BYTE *)this + 16);
      if ( (v55 & 4) != 0 )
      {
LABEL_94:
        if ( (v55 & 4) == 0 || *p_m_pDraggedPed )
        {
          SubTask = (CTaskSimpleCarOpenDoorFromOutside *)CTaskComplexEnterCar::CreateSubTask(this, 820, v2);
          m_pPedIntelligence = this->m_pDraggedPed->m_pPedIntelligence;
          v59 = (CTaskComplexCarSlowBeDraggedOutAndStandUp *)CTask::operator new(0x14u);
          CTaskComplexCarSlowBeDraggedOutAndStandUp::CTaskComplexCarSlowBeDraggedOutAndStandUp(
            v59,
            this->m_pTargetVehicle,
            this->m_iTargetDoor);
          CPedIntelligence::AddTaskPrimaryMaybeInGroup(m_pPedIntelligence, v59, 1);
          CEventDraggedOutCar::CEventDraggedOutCar(
            v66,
            this->m_pTargetVehicle,
            v2,
            this->m_pTargetVehicle->pDriver == this->m_pDraggedPed);
          CEventGroup::Add(&this->m_pDraggedPed->m_pPedIntelligence->m_eventGroup, (CEvent *)v66, 1);
          pDriver = this->m_pTargetVehicle->pDriver;
          if ( pDriver == this->m_pDraggedPed )
          {
            v62 = CPedGroups::GetPedsGroup(pDriver);
            v63 = v62;
            if ( v62 )
            {
              if ( CPedGroupMembership::IsLeader(&v62->m_membership, *p_m_pDraggedPed) )
              {
                v64 = (CEventEditableResponse *)CEvent::operator new(0x10u);
                CEventEditableResponse::CEventEditableResponse(v64);
                v64->_vptr$CEvent = (int (**)(void))&off_666E98;
                CEventGroupEvent::CEventGroupEvent(&v65, *p_m_pDraggedPed, (CEvent *)v64);
                CPedGroupIntelligence::AddEvent(&v63->m_intelligence, &v65);
                CEventGroupEvent::~CEventGroupEvent(&v65);
              }
            }
          }
          CEventDraggedOutCar::~CEventDraggedOutCar(v66);
          goto LABEL_71;
        }
        goto LABEL_69;
      }
      if ( *p_m_pDraggedPed )
      {
        v56 = CPedGroups::AreInSameGroup(*p_m_pDraggedPed, v2);
        v57 = *p_m_pDraggedPed;
        if ( !v56 && (*((_BYTE *)&v57->m_nPedFlags + 3) & 0x20) == 0 )
        {
          v55 = *((_BYTE *)this + 16);
          goto LABEL_94;
        }
        if ( v57 )
        {
          if ( !(*((unsigned __int8 *)this + 16) << 31) )
            goto LABEL_111;
          if ( CVehicle::IsDriver(this->m_pTargetVehicle, *p_m_pDraggedPed) )
          {
LABEL_104:
            if ( !CCarEnterExit::CarHasDoorToClose(this->m_pTargetVehicle, this->m_iTargetDoor) )
              goto LABEL_69;
            SubTask = (CTaskSimpleCarOpenDoorFromOutside *)CTask::operator new(0x1Cu);
            CTaskSimpleCarCloseDoorFromOutside::CTaskSimpleCarCloseDoorFromOutside(
              (CTaskSimpleCarCloseDoorFromOutside *)SubTask,
              this->m_pTargetVehicle,
              this->m_iTargetDoor,
              this->m_pTaskUtilityLineUpPedWithCar);
            goto LABEL_71;
          }
          v57 = *p_m_pDraggedPed;
          if ( *p_m_pDraggedPed )
          {
LABEL_111:
            if ( !(*((unsigned __int8 *)this + 16) << 31) )
            {
              v61 = this->m_pTargetVehicle;
              if ( v57 == v61->pPassengers[CCarEnterExit::ComputePassengerIndexFromCarDoor(v61, this->m_iTargetDoor)] )
                goto LABEL_104;
            }
          }
        }
      }
    }
    else if ( (*((_BYTE *)this + 16) & 4) != 0 )
    {
      goto LABEL_69;
    }
LABEL_31:
    SubTask = (CTaskSimpleCarOpenDoorFromOutside *)CTask::operator new(0x24u);
    CTaskSimpleCarGetIn::CTaskSimpleCarGetIn(
      (CTaskSimpleCarGetIn *)SubTask,
      this->m_pTargetVehicle,
      this->m_iTargetDoor,
      this->m_pTaskUtilityLineUpPedWithCar);
    goto LABEL_71;
  }
  if ( !CCarEnterExit::IsCarSlowJackRequired(m_pTargetVehicle, this->m_iTargetDoor, v2) )
  {
    if ( (*((_BYTE *)this + 16) & 4) != 0 )
      goto LABEL_69;
    v15 = this->m_pTargetVehicle;
    v16 = *(_BYTE *)&v15->m_info & 0xF8;
    v17 = v16 == 32;
    if ( v16 == 32 )
      v17 = v15->m_baseVehicleType == 9;
    if ( v17 )
    {
      zx = v15->m_pMat->zx;
      if ( zx >= 0.5 || zx <= -0.5 )
      {
        SubTask = (CTaskSimpleCarOpenDoorFromOutside *)CTask::operator new(0x1Cu);
        CTaskSimplePickUpBike::CTaskSimplePickUpBike(
          (CTaskSimplePickUpBike *)SubTask,
          this->m_pTargetVehicle,
          this->m_iTargetDoor,
          this->m_pTaskUtilityLineUpPedWithCar);
      }
      else
      {
        SubTask = (CTaskSimpleCarOpenDoorFromOutside *)CTask::operator new(0x24u);
        CTaskSimpleCarGetIn::CTaskSimpleCarGetIn(
          (CTaskSimpleCarGetIn *)SubTask,
          this->m_pTargetVehicle,
          this->m_iTargetDoor,
          this->m_pTaskUtilityLineUpPedWithCar);
        LOBYTE(this->m_pTargetVehicle[1].m_vecTurnFriction.z) |= 8u;
      }
      goto LABEL_71;
    }
    goto LABEL_31;
  }
  v10 = CCarEnterExit::ComputeSlowJackedPed(this->m_pTargetVehicle, this->m_iTargetDoor);
  p_m_pDraggedPed = &this->m_pDraggedPed;
  this->m_pDraggedPed = v10;
  if ( !v10
    || (CEntity::RegisterReference(v10, &this->m_pDraggedPed), !*p_m_pDraggedPed)
    || !CPed::IsPlayer(*p_m_pDraggedPed)
    || CGameLogic::SkipState != 2 )
  {
    v18 = 820;
    if ( (*((_BYTE *)this + 16) & 4) == 0 && this->m_iTargetDoor == 18 )
      v18 = 807;
    v19 = CTaskComplexEnterCar::CreateSubTask(this, v18, v2);
    if ( this->m_iTargetDoor == 18 && !this->m_pTargetVehicle->pPassengers[0] )
      v20 = 11;
    else
      v20 = 10;
    v21 = this->m_pDraggedPed->m_pPedIntelligence;
    v22 = (CTaskSimpleBikeJacked *)CTask::operator new(0x2Cu);
    CTaskSimpleBikeJacked::CTaskSimpleBikeJacked(v22, this->m_pTargetVehicle, v20, this->m_iDraggedPedDownTime, v2, 1);
    CPedIntelligence::AddTaskPrimaryMaybeInGroup(v21, v22, 1);
    v23 = this->m_pTargetVehicle;
    if ( this->m_pDraggedPed != v23->pDriver )
    {
      SubTask = (CTaskSimpleCarOpenDoorFromOutside *)v19;
      goto LABEL_71;
    }
    v36 = v23->pPassengers[0];
    SubTask = (CTaskSimpleCarOpenDoorFromOutside *)v19;
    if ( v36 )
    {
      v37 = v36->m_pPedIntelligence;
      v38 = (CTaskSimpleBikeJacked *)CTask::operator new(0x2Cu);
      CTaskSimpleBikeJacked::CTaskSimpleBikeJacked(
        v38,
        this->m_pTargetVehicle,
        11,
        this->m_iDraggedPedDownTime + 200,
        v2,
        0);
      CPedIntelligence::AddTaskPrimaryMaybeInGroup(v37, v38, 1);
      v39 = this->m_pTargetVehicle->pDriver;
      if ( v39 == this->m_pDraggedPed )
      {
        v40 = CPedGroups::GetPedsGroup(v39);
        v33 = v40;
        if ( v40 )
        {
          if ( CPedGroupMembership::IsLeader(&v40->m_membership, *p_m_pDraggedPed) )
          {
            v34 = (CEvent *)CEvent::operator new(0x10u);
            CEventEditableResponse::CEventEditableResponse((CEventEditableResponse *)v34);
            v35 = &`vtable for'CEventLeaderExitedCarAsDriver;
            goto LABEL_63;
          }
        }
      }
    }
LABEL_71:
    v42 = this->m_pTargetVehicle;
    if ( (*((_BYTE *)&v42->m_nVehicleFlags + 1) & 2) == 0 )
    {
      v43 = this;
      v44 = 282;
      v45 = v2;
      do
      {
        v46 = (const CPed *)*((_DWORD *)&v42->_vptr$CPlaceable + v44);
        if ( v46 )
        {
          if ( CPedIntelligence::IsFriendlyWith(v2->m_pPedIntelligence, v46)
            || CPedGroups::AreInSameGroup(v2, *((const CPed **)&v43->m_pTargetVehicle->_vptr$CPlaceable + v44)) )
          {
            v47 = 1000.0;
            v48 = 2000;
          }
          else
          {
            v48 = 6000;
            v47 = 2000.0;
          }
          v49 = (int)(float)(v47 * (float)((float)(unsigned __int16)rand() * 0.000015259)) + v48;
          v2 = (CPed *)v45;
          IKChainManager_c::LookAt(
            &g_ikChainMan,
            "TaskEnterCar",
            *((CPed **)&v43->m_pTargetVehicle->_vptr$CPlaceable + v44),
            v45,
            v49,
            5,
            0,
            0,
            0.5,
            350,
            3,
            0);
          v42 = v43->m_pTargetVehicle;
        }
        ++v44;
      }
      while ( v44 != 290 );
      v50 = v42->pDriver;
      if ( v50 )
      {
        if ( CPedIntelligence::IsFriendlyWith(v2->m_pPedIntelligence, v50)
          || CPedGroups::AreInSameGroup(v2, v43->m_pTargetVehicle->pDriver) )
        {
          v51 = 1000.0;
          v52 = 2000;
        }
        else
        {
          v51 = 2000.0;
          v52 = 6000;
        }
        v53 = rand();
        IKChainManager_c::LookAt(
          &g_ikChainMan,
          "TaskEnterCar",
          v43->m_pTargetVehicle->pDriver,
          v2,
          v52 + (int)(float)(v51 * (float)((float)v53 * 0.000015259)),
          5,
          0,
          0,
          0.5,
          350,
          3,
          0);
      }
    }
    return SubTask;
  }
  SubTask = (CTaskSimpleCarOpenDoorFromOutside *)CTaskComplexEnterCar::CreateSubTask(this, 1302, v2);
  v12 = CPedGroups::GetPedsGroup(this->m_pDraggedPed);
  v13 = v12;
  if ( v12 && CPedGroupMembership::IsLeader(&v12->m_membership, *p_m_pDraggedPed) )
  {
    v14 = (CEvent *)CEvent::operator new(0xCu);
    CEvent::CEvent(v14);
    v14->_vptr$CEvent = (int (**)(void))&off_666EE8;
    CEventGroupEvent::CEventGroupEvent((CEventGroupEvent *)v66, *p_m_pDraggedPed, v14);
    CPedGroupIntelligence::AddEvent(&v13->m_intelligence, (CEvent *)v66);
    CEventGroupEvent::~CEventGroupEvent((CEventGroupEvent *)v66);
  }
  return SubTask;
}
// 666E98: using guessed type void *off_666E98;
// 666EE8: using guessed type void *off_666EE8;
// 678BD4: using guessed type void *`vtable for'CEventLeaderQuitEnteringCarAsDriver;
// 6794B8: using guessed type void *`vtable for'CEventLeaderExitedCarAsDriver;

//----- (004F6FE0) --------------------------------------------------------
void __fastcall CTaskComplexEnterCarAsDriver::CTaskComplexEnterCarAsDriver(
        CTaskComplexEnterCarAsDriver *this,
        CVehicle *pTargetVehicle)
{
  int v4; // r1

  CTaskComplex::CTaskComplex(this);
  this->m_iMoveState = 6;
  *(_WORD *)&this->m_nNumGettingInSet = 0;
  this->m_pTaskUtilityLineUpPedWithCar = 0;
  this->m_bIsAborting = 0;
  this->m_pDraggedPed = 0;
  this->m_nDoorFlagsSet = 0;
  v4 = *((unsigned __int8 *)&this->CTaskComplexEnterCar + 16);
  *(_QWORD *)&this->m_iTargetDoor = 0LL;
  *(_QWORD *)&this->m_iTargetSeat = 0LL;
  this->m_fCruiseSpeed = -1.0;
  *((_BYTE *)&this->CTaskComplexEnterCar + 16) = v4 & 0xF0 | 1;
  this->_vptr$CTask = (int (**)(void))&off_66A8F4;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
  this->_vptr$CTask = (int (**)(void))&off_66A934;
}
// 66A8F4: using guessed type void *off_66A8F4;
// 66A934: using guessed type void *;

//----- (004F7054) --------------------------------------------------------
void __fastcall CTaskComplexEnterCarAsDriver::~CTaskComplexEnterCarAsDriver(CTaskComplexEnterCarAsDriver *this)
{
  void *v1; // r0

  CTaskComplexEnterCarAsPassenger::~CTaskComplexEnterCarAsPassenger(this);
  sub_197118(v1);
}
// 4F7060: variable 'v1' is possibly undefined

//----- (004F7064) --------------------------------------------------------
void __fastcall CTaskComplexEnterCarAsPassenger::CTaskComplexEnterCarAsPassenger(
        CTaskComplexEnterCarAsPassenger *this,
        CVehicle *pTargetVehicle,
        const int iTargetSeat,
        const bool bCarryOnAfterFallingOff)
{
  int v8; // r1

  CTaskComplex::CTaskComplex(this);
  this->m_iMoveState = 6;
  *(_WORD *)&this->m_nNumGettingInSet = 0;
  this->m_pTaskUtilityLineUpPedWithCar = 0;
  this->m_bIsAborting = 0;
  this->m_pDraggedPed = 0;
  this->m_nDoorFlagsSet = 0;
  v8 = *((unsigned __int8 *)&this->CTaskComplexEnterCar + 16);
  *(_QWORD *)&this->m_iTargetDoor = 0LL;
  *(_QWORD *)&this->m_iTargetSeat = 0LL;
  this->m_fCruiseSpeed = -1.0;
  *((_BYTE *)&this->CTaskComplexEnterCar + 16) = v8 & 0xF0 | (8 * bCarryOnAfterFallingOff);
  this->_vptr$CTask = (int (**)(void))&off_66A8F4;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
  this->m_iTargetSeat = iTargetSeat;
  this->_vptr$CTask = (int (**)(void))&off_66A974;
}
// 66A8F4: using guessed type void *;
// 66A974: using guessed type void *;

//----- (004F70E8) --------------------------------------------------------
void __fastcall CTaskComplexEnterCarAsPassenger::~CTaskComplexEnterCarAsPassenger(
        CTaskComplexEnterCarAsPassenger *this)
{
  void *v1; // r0

  CTaskComplexEnterCarAsPassenger::~CTaskComplexEnterCarAsPassenger(this);
  sub_197118(v1);
}
// 4F70F4: variable 'v1' is possibly undefined

//----- (004F70F8) --------------------------------------------------------
void __fastcall CTaskComplexOpenDriverDoor::CTaskComplexOpenDriverDoor(
        CTaskComplexOpenDriverDoor *this,
        CVehicle *pTargetVehicle)
{
  int v4; // r1

  CTaskComplex::CTaskComplex(this);
  this->m_iMoveState = 6;
  *(_WORD *)&this->m_nNumGettingInSet = 0;
  this->m_pTaskUtilityLineUpPedWithCar = 0;
  this->m_bIsAborting = 0;
  this->m_pDraggedPed = 0;
  this->m_nDoorFlagsSet = 0;
  v4 = *((unsigned __int8 *)&this->CTaskComplexEnterCar + 16);
  *(_QWORD *)&this->m_iTargetDoor = 0LL;
  *(_QWORD *)&this->m_iTargetSeat = 0LL;
  this->m_fCruiseSpeed = -1.0;
  *((_BYTE *)&this->CTaskComplexEnterCar + 16) = v4 & 0xF0 | 3;
  this->_vptr$CTask = (int (**)(void))&off_66A8F4;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
  this->m_iTargetSeat = 10;
  this->_vptr$CTask = (int (**)(void))&off_66A9B4;
}
// 66A8F4: using guessed type void *off_66A8F4;
// 66A9B4: using guessed type void *off_66A9B4;

//----- (004F7170) --------------------------------------------------------
void __fastcall CTaskComplexOpenDriverDoor::~CTaskComplexOpenDriverDoor(CTaskComplexOpenDriverDoor *this)
{
  void *v1; // r0

  CTaskComplexEnterCarAsPassenger::~CTaskComplexEnterCarAsPassenger(this);
  sub_197118(v1);
}
// 4F717C: variable 'v1' is possibly undefined

//----- (004F7180) --------------------------------------------------------
void __fastcall CTaskComplexOpenPassengerDoor::CTaskComplexOpenPassengerDoor(
        CTaskComplexOpenPassengerDoor *this,
        CVehicle *pTargetVehicle,
        const int iTargetSeat)
{
  int v6; // r1

  CTaskComplex::CTaskComplex(this);
  this->m_iMoveState = 6;
  *(_WORD *)&this->m_nNumGettingInSet = 0;
  this->m_pTaskUtilityLineUpPedWithCar = 0;
  this->m_bIsAborting = 0;
  this->m_pDraggedPed = 0;
  this->m_nDoorFlagsSet = 0;
  v6 = *((unsigned __int8 *)&this->CTaskComplexEnterCar + 16);
  *(_QWORD *)&this->m_iTargetDoor = 0LL;
  *(_QWORD *)&this->m_iTargetSeat = 0LL;
  this->m_fCruiseSpeed = -1.0;
  *((_BYTE *)&this->CTaskComplexEnterCar + 16) = v6 & 0xF0 | 2;
  this->_vptr$CTask = (int (**)(void))&off_66A8F4;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
  this->m_iTargetSeat = iTargetSeat;
  this->_vptr$CTask = (int (**)(void))&off_66A9F4;
}
// 66A8F4: using guessed type void *off_66A8F4;
// 66A9F4: using guessed type void *off_66A9F4;

//----- (004F7200) --------------------------------------------------------
void __fastcall CTaskComplexOpenPassengerDoor::~CTaskComplexOpenPassengerDoor(CTaskComplexOpenPassengerDoor *this)
{
  void *v1; // r0

  CTaskComplexEnterCarAsPassenger::~CTaskComplexEnterCarAsPassenger(this);
  sub_197118(v1);
}
// 4F720C: variable 'v1' is possibly undefined

//----- (004F7210) --------------------------------------------------------
void __fastcall CTaskComplexDragPedFromCar::CTaskComplexDragPedFromCar(
        CTaskComplexDragPedFromCar *this,
        CPed *pTargetPed,
        const int iDraggedPedDownTime)
{
  int v6; // r1

  CTaskComplex::CTaskComplex(this);
  this->m_pTargetVehicle = 0;
  this->m_iMoveState = 6;
  *(_WORD *)&this->m_nNumGettingInSet = 0;
  this->m_pTaskUtilityLineUpPedWithCar = 0;
  this->m_bIsAborting = 0;
  this->m_pDraggedPed = 0;
  this->m_nDoorFlagsSet = 0;
  v6 = *((unsigned __int8 *)&this->CTaskComplexEnterCar + 16);
  *(_QWORD *)&this->m_iTargetDoor = 0LL;
  *(_QWORD *)&this->m_iTargetSeat = 0LL;
  this->m_fCruiseSpeed = -1.0;
  *((_BYTE *)&this->CTaskComplexEnterCar + 16) = v6 & 0xF0 | 4;
  this->_vptr$CTask = (int (**)(void))&off_66AA34;
  this->m_pTargetPed = pTargetPed;
  if ( pTargetPed )
    CEntity::RegisterReference(pTargetPed, &this->m_pTargetPed);
  this->m_iDraggedPedDownTime = iDraggedPedDownTime;
}
// 66AA34: using guessed type void *;

//----- (004F7284) --------------------------------------------------------
void __fastcall CTaskComplexDragPedFromCar::~CTaskComplexDragPedFromCar(CTaskComplexDragPedFromCar *this)
{
  CPed *m_pTargetPed; // r0
  CEntity **p_m_pTargetPed; // r1

  p_m_pTargetPed = &this->m_pTargetPed;
  m_pTargetPed = this->m_pTargetPed;
  this->_vptr$CTask = (int (**)(void))&off_66AA34;
  if ( m_pTargetPed )
    CEntity::CleanUpOldReference(m_pTargetPed, p_m_pTargetPed);
  CTaskComplexEnterCarAsPassenger::~CTaskComplexEnterCarAsPassenger(this);
}
// 66AA34: using guessed type void *off_66AA34;

//----- (004F72B0) --------------------------------------------------------
void __fastcall CTaskComplexDragPedFromCar::~CTaskComplexDragPedFromCar(CTaskComplexDragPedFromCar *this)
{
  CPed *m_pTargetPed; // r0
  CEntity **p_m_pTargetPed; // r1
  void *v4; // r0

  p_m_pTargetPed = &this->m_pTargetPed;
  m_pTargetPed = this->m_pTargetPed;
  this->_vptr$CTask = (int (**)(void))&off_66AA34;
  if ( m_pTargetPed )
    CEntity::CleanUpOldReference(m_pTargetPed, p_m_pTargetPed);
  CTaskComplexEnterCarAsPassenger::~CTaskComplexEnterCarAsPassenger(this);
  sub_197118(v4);
}
// 4F72D8: variable 'v4' is possibly undefined
// 66AA34: using guessed type void *off_66AA34;

//----- (004F72E0) --------------------------------------------------------
CTask *__fastcall CTaskComplexDragPedFromCar::CreateFirstSubTask(CTaskComplexDragPedFromCar *this, CPed *pPed)
{
  CPed *m_pTargetPed; // r1
  const CVehicle *m_pMyVehicle; // r0
  bool v6; // zf
  CTaskSimple *v7; // r0
  CTask *result; // r0
  _BOOL4 IsPassenger; // r0
  CVehicle *m_pTargetVehicle; // r0
  CVehicle *v11; // r0
  CVehicle *v12; // r0
  char v13; // r2
  CPed *v14; // r1
  char v15; // r6
  CVehicle *v16; // r2
  int v17; // r0

  m_pTargetPed = this->m_pTargetPed;
  if ( !m_pTargetPed )
    goto LABEL_6;
  m_pMyVehicle = m_pTargetPed->m_pMyVehicle;
  v6 = m_pMyVehicle == 0;
  if ( m_pMyVehicle )
    v6 = *((unsigned __int8 *)&m_pTargetPed->m_nPedFlags + 1) << 31 == 0;
  if ( !v6
    && (IsPassenger = CVehicle::IsPassenger(m_pMyVehicle, m_pTargetPed),
        IsPassenger || CVehicle::IsDriver(this->m_pTargetPed->m_pMyVehicle, this->m_pTargetPed)) )
  {
    m_pTargetVehicle = this->m_pTargetVehicle;
    if ( m_pTargetVehicle )
      CEntity::CleanUpOldReference(m_pTargetVehicle, &this->m_pTargetVehicle);
    v11 = this->m_pTargetPed->m_pMyVehicle;
    this->m_pTargetVehicle = v11;
    CEntity::RegisterReference(v11, &this->m_pTargetVehicle);
    v12 = this->m_pTargetVehicle;
    v13 = *((_BYTE *)&this->CTaskComplexEnterCar + 16);
    v14 = this->m_pTargetPed;
    v15 = v13 & 0xF8;
    if ( v12->pDriver == v14 )
      v15 = v13 | 1;
    *((_BYTE *)&this->CTaskComplexEnterCar + 16) = v15 & 0xF9 | 4;
    if ( v12 )
    {
      if ( (v12->pHandling->mFlags & 0x200) != 0
        || (v16 = v14->m_pMyVehicle, v16->m_baseVehicleType == 9)
        || v16->m_vehicleType == 2 )
      {
        v17 = 0;
      }
      else
      {
        v17 = CCarEnterExit::ComputeTargetDoorToExit(v12, v14);
      }
      this->m_iTargetSeat = v17;
    }
    return CTaskComplexEnterCar::CreateFirstSubTask(this, pPed);
  }
  else
  {
LABEL_6:
    v7 = (CTaskSimple *)CTask::operator new(8u);
    CTaskSimple::CTaskSimple(v7);
    result->_vptr$CTask = (int (**)(void))&off_668FF0;
  }
  return result;
}
// 4F7314: variable 'result' is possibly undefined
// 668FF0: using guessed type void *off_668FF0;
// 678150: using guessed type void *`vtable for'CTaskSimpleNone;

//----- (004F73B0) --------------------------------------------------------
CTask *__fastcall CTaskComplexDragPedFromCar::ControlSubTask(CTaskComplexDragPedFromCar *this, CPed *pPed)
{
  CTask *result; // r0
  CPed *m_pTargetPed; // r0
  CTaskSimple *v6; // r0

  if ( this->m_nNumGettingInSet )
    return CTaskComplexEnterCar::ControlSubTask(this, pPed);
  m_pTargetPed = this->m_pTargetPed;
  if ( !m_pTargetPed
    || *((unsigned __int8 *)&m_pTargetPed->m_nPedFlags + 1) << 31
    || !(*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplexEnterCar::CTaskComplex::_vptr$CTask
         + 7))(
          this->m_pSubTask,
          pPed,
          1,
          0) )
  {
    return CTaskComplexEnterCar::ControlSubTask(this, pPed);
  }
  v6 = (CTaskSimple *)CTask::operator new(8u);
  CTaskSimple::CTaskSimple(v6);
  result->_vptr$CTask = (int (**)(void))&off_668FF0;
  return result;
}
// 4F73FE: variable 'result' is possibly undefined
// 668FF0: using guessed type void *off_668FF0;
// 678150: using guessed type void *`vtable for'CTaskSimpleNone;

//----- (004F7408) --------------------------------------------------------
void __fastcall CTaskComplexEnterCarAsDriverTimed::CTaskComplexEnterCarAsDriverTimed(
        CTaskComplexEnterCarAsDriverTimed *this,
        CVehicle *pTargetVehicle,
        const int iTime)
{
  CTaskComplex::CTaskComplex(this);
  this->m_iTime = iTime;
  this->m_iMoveState = 6;
  *(_WORD *)&this->m_timer.m_bIsActive = 0;
  this->m_timer.m_iStartTime = 0;
  this->m_timer.m_iDuration = 0;
  this->_vptr$CTask = (int (**)(void))&off_66AA74;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66AA74: using guessed type void *;

//----- (004F7454) --------------------------------------------------------
void __fastcall CTaskComplexEnterCarAsDriverTimed::~CTaskComplexEnterCarAsDriverTimed(
        CTaskComplexEnterCarAsDriverTimed *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AA74;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  sub_18EDB4(this);
}
// 66AA74: using guessed type void *off_66AA74;

//----- (004F7480) --------------------------------------------------------
void __fastcall CTaskComplexEnterCarAsDriverTimed::~CTaskComplexEnterCarAsDriverTimed(
        CTaskComplexEnterCarAsDriverTimed *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  void *v4; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AA74;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 4F74A8: variable 'v4' is possibly undefined
// 66AA74: using guessed type void *off_66AA74;

//----- (004F74B0) --------------------------------------------------------
bool __fastcall CTaskComplexEnterCarAsDriverTimed::MakeAbortable(
        CTaskComplexEnterCarAsDriverTimed *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  int v7; // r8
  __int64 v8; // kr00_8

  v7 = (*((int (__fastcall **)(CTask *, CPed *, const int))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
         this->m_pSubTask,
         pPed,
         iPriority);
  if ( (unsigned int)(iPriority - 1) <= 1 && v7 == 1 && (!pEvent || !CEventHandler::IsTemporaryEvent(pEvent)) )
  {
    if ( this->m_timer.m_bIsActive )
    {
      v8 = *(_QWORD *)&this->m_timer.m_iStartTime;
      this->m_timer.m_bIsStopped = 1;
      this->m_timer.m_iDuration = HIDWORD(v8) - CTimer::m_snTimeInMilliseconds + v8;
    }
  }
  return v7;
}

//----- (004F7510) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterCarAsDriverTimed::CreateNextSubTask(
        CTaskComplexEnterCarAsDriverTimed *this,
        CPed *pPed)
{
  return 0;
}

//----- (004F7514) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterCarAsDriverTimed::CreateFirstSubTask(
        CTaskComplexEnterCarAsDriverTimed *this,
        CPed *pPed)
{
  int m_iTime; // r0
  int v4; // r1
  char *v5; // r5
  CVehicle *m_pTargetVehicle; // r6
  char v7; // r2

  m_iTime = this->m_iTime;
  if ( m_iTime >= 0 )
  {
    v4 = CTimer::m_snTimeInMilliseconds;
    this->m_timer.m_bIsActive = 1;
    this->m_timer.m_iStartTime = v4;
    this->m_timer.m_iDuration = m_iTime;
  }
  v5 = (char *)CTask::operator new(0x50u);
  m_pTargetVehicle = this->m_pTargetVehicle;
  CTaskComplex::CTaskComplex((CTaskComplex *)v5);
  *(_QWORD *)(v5 + 20) = 0LL;
  *(_QWORD *)(v5 + 28) = 0LL;
  *((_DWORD *)v5 + 9) = 6;
  *((_WORD *)v5 + 20) = 0;
  *((_DWORD *)v5 + 14) = 0;
  v5[60] = 0;
  *((_DWORD *)v5 + 16) = 0;
  v5[68] = 0;
  v7 = v5[16];
  *((_DWORD *)v5 + 18) = -1082130432;
  *(_DWORD *)v5 = &off_66A8F4;
  v5[16] = v7 & 0xF0 | 1;
  *((_DWORD *)v5 + 3) = m_pTargetVehicle;
  if ( m_pTargetVehicle )
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v5 + 3);
  *(_DWORD *)v5 = &off_66A934;
  *((_DWORD *)v5 + 9) = this->m_iMoveState;
  return (CTask *)v5;
}
// 66A8F4: using guessed type void *off_66A8F4;
// 66A934: using guessed type void *off_66A934;

//----- (004F75BC) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterCarAsDriverTimed::ControlSubTask(
        CTaskComplexEnterCarAsDriverTimed *this,
        CPed *pPed)
{
  unsigned int v4; // r0
  int m_iStartTime; // r1
  CTask *result; // r0
  int v7; // r0
  bool v8; // zf
  CTaskSimpleCarSetPedInAsDriver *v9; // r0

  if ( !this->m_pTargetVehicle )
    return 0;
  if ( !this->m_timer.m_bIsActive )
    return this->m_pSubTask;
  if ( this->m_timer.m_bIsStopped )
  {
    v4 = CTimer::m_snTimeInMilliseconds;
    this->m_timer.m_bIsStopped = 0;
    this->m_timer.m_iStartTime = v4;
    m_iStartTime = v4;
  }
  else
  {
    m_iStartTime = this->m_timer.m_iStartTime;
    v4 = CTimer::m_snTimeInMilliseconds;
  }
  if ( m_iStartTime + this->m_timer.m_iDuration > v4 )
    return this->m_pSubTask;
  v7 = (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
         this->m_pSubTask,
         pPed,
         1,
         0);
  v8 = v7 == 1;
  if ( v7 == 1 )
    v8 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
  if ( !v8 || this->m_pTargetVehicle->pDriver )
    return this->m_pSubTask;
  v9 = (CTaskSimpleCarSetPedInAsDriver *)CTask::operator new(0x1Cu);
  CTaskSimpleCarSetPedInAsDriver::CTaskSimpleCarSetPedInAsDriver(v9, this->m_pTargetVehicle, 0);
  LOBYTE(result[3]._vptr$CTask) = 1;
  return result;
}
// 4F7638: variable 'result' is possibly undefined

//----- (004F7644) --------------------------------------------------------
void __fastcall CTaskComplexEnterCarAsDriverTimed::StopTimer(
        CTaskComplexEnterCarAsDriverTimed *this,
        const CEvent *pEvent)
{
  __int64 v3; // kr00_8

  if ( !CEventHandler::IsTemporaryEvent(pEvent) )
  {
    if ( this->m_timer.m_bIsActive )
    {
      v3 = *(_QWORD *)&this->m_timer.m_iStartTime;
      this->m_timer.m_bIsStopped = 1;
      this->m_timer.m_iDuration = HIDWORD(v3) - CTimer::m_snTimeInMilliseconds + v3;
    }
  }
}

//----- (004F767C) --------------------------------------------------------
void __fastcall CTaskComplexEnterCarAsPassengerTimed::CTaskComplexEnterCarAsPassengerTimed(
        CTaskComplexEnterCarAsPassengerTimed *this,
        CVehicle *pTargetVehicle,
        const int iTargetSeat,
        const int iTime,
        const bool bCarryOnAfterFallingOff)
{
  CTaskComplex::CTaskComplex(this);
  this->m_iTime = iTime;
  this->m_iTargetSeat = iTargetSeat;
  this->m_bCarryOnAfterFallingOff = bCarryOnAfterFallingOff;
  this->m_iMoveState = 6;
  *(_WORD *)&this->m_timer.m_bIsActive = 0;
  this->m_timer.m_iStartTime = 0;
  this->m_timer.m_iDuration = 0;
  this->_vptr$CTask = (int (**)(void))&off_66AAB0;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66AAB0: using guessed type void *;

//----- (004F76D0) --------------------------------------------------------
void __fastcall CTaskComplexEnterCarAsPassengerTimed::~CTaskComplexEnterCarAsPassengerTimed(
        CTaskComplexEnterCarAsPassengerTimed *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AAB0;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  sub_18EDB4(this);
}
// 66AAB0: using guessed type void *off_66AAB0;

//----- (004F76FC) --------------------------------------------------------
void __fastcall CTaskComplexEnterCarAsPassengerTimed::~CTaskComplexEnterCarAsPassengerTimed(
        CTaskComplexEnterCarAsPassengerTimed *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  void *v4; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AAB0;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 4F7724: variable 'v4' is possibly undefined
// 66AAB0: using guessed type void *off_66AAB0;

//----- (004F772C) --------------------------------------------------------
bool __fastcall CTaskComplexEnterCarAsPassengerTimed::MakeAbortable(
        CTaskComplexEnterCarAsPassengerTimed *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  int v7; // r8
  __int64 v8; // kr00_8

  v7 = (*((int (__fastcall **)(CTask *, CPed *, const int))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
         this->m_pSubTask,
         pPed,
         iPriority);
  if ( (unsigned int)(iPriority - 1) <= 1 && v7 == 1 && (!pEvent || !CEventHandler::IsTemporaryEvent(pEvent)) )
  {
    if ( this->m_timer.m_bIsActive )
    {
      v8 = *(_QWORD *)&this->m_timer.m_iStartTime;
      this->m_timer.m_bIsStopped = 1;
      this->m_timer.m_iDuration = HIDWORD(v8) - CTimer::m_snTimeInMilliseconds + v8;
    }
  }
  return v7;
}

//----- (004F778C) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterCarAsPassengerTimed::CreateNextSubTask(
        CTaskComplexEnterCarAsPassengerTimed *this,
        CPed *pPed)
{
  return 0;
}

//----- (004F7790) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterCarAsPassengerTimed::CreateFirstSubTask(
        CTaskComplexEnterCarAsPassengerTimed *this,
        CPed *pPed)
{
  int m_iTime; // r0
  int v4; // r1
  char *v5; // r5
  CVehicle *m_pTargetVehicle; // r6
  int m_iTargetSeat; // r8
  bool m_bCarryOnAfterFallingOff; // r9
  char v9; // r2

  if ( !this->m_pTargetVehicle )
    return 0;
  m_iTime = this->m_iTime;
  if ( m_iTime >= 0 )
  {
    v4 = CTimer::m_snTimeInMilliseconds;
    this->m_timer.m_bIsActive = 1;
    this->m_timer.m_iStartTime = v4;
    this->m_timer.m_iDuration = m_iTime;
  }
  v5 = (char *)CTask::operator new(0x50u);
  m_pTargetVehicle = this->m_pTargetVehicle;
  m_iTargetSeat = this->m_iTargetSeat;
  m_bCarryOnAfterFallingOff = this->m_bCarryOnAfterFallingOff;
  CTaskComplex::CTaskComplex((CTaskComplex *)v5);
  *(_QWORD *)(v5 + 20) = 0LL;
  *(_QWORD *)(v5 + 28) = 0LL;
  *((_DWORD *)v5 + 9) = 6;
  *((_WORD *)v5 + 20) = 0;
  *((_DWORD *)v5 + 14) = 0;
  v5[60] = 0;
  *((_DWORD *)v5 + 16) = 0;
  v5[68] = 0;
  v9 = v5[16];
  *((_DWORD *)v5 + 18) = -1082130432;
  *(_DWORD *)v5 = &off_66A8F4;
  v5[16] = v9 & 0xF0 | (8 * m_bCarryOnAfterFallingOff);
  *((_DWORD *)v5 + 3) = m_pTargetVehicle;
  if ( m_pTargetVehicle )
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v5 + 3);
  *((_DWORD *)v5 + 7) = m_iTargetSeat;
  *(_DWORD *)v5 = &off_66A974;
  *((_DWORD *)v5 + 9) = this->m_iMoveState;
  return (CTask *)v5;
}
// 66A8F4: using guessed type void *off_66A8F4;
// 66A974: using guessed type void *off_66A974;

//----- (004F7850) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterCarAsPassengerTimed::ControlSubTask(
        CTaskComplexEnterCarAsPassengerTimed *this,
        CPed *pPed)
{
  unsigned int v4; // r0
  int m_iStartTime; // r1
  CTask *result; // r0
  int v7; // r0
  bool v8; // zf
  int m_iTargetSeat; // r1
  CVehicle *m_pTargetVehicle; // r5
  CTaskSimpleCarSetPedInAsPassenger *v11; // r0

  if ( !this->m_pTargetVehicle )
    return 0;
  if ( !this->m_timer.m_bIsActive )
    return this->m_pSubTask;
  if ( this->m_timer.m_bIsStopped )
  {
    v4 = CTimer::m_snTimeInMilliseconds;
    this->m_timer.m_bIsStopped = 0;
    this->m_timer.m_iStartTime = v4;
    m_iStartTime = v4;
  }
  else
  {
    m_iStartTime = this->m_timer.m_iStartTime;
    v4 = CTimer::m_snTimeInMilliseconds;
  }
  if ( m_iStartTime + this->m_timer.m_iDuration > v4 )
    return this->m_pSubTask;
  v7 = (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
         this->m_pSubTask,
         pPed,
         1,
         0);
  v8 = v7 == 1;
  if ( v7 == 1 )
    v8 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
  if ( !v8 )
    return this->m_pSubTask;
  m_iTargetSeat = this->m_iTargetSeat;
  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( m_iTargetSeat || m_pTargetVehicle->m_nNumPassengers >= (unsigned int)m_pTargetVehicle->m_nMaxPassengers )
  {
    if ( m_pTargetVehicle->pPassengers[CCarEnterExit::ComputePassengerIndexFromCarDoor(
                                         this->m_pTargetVehicle,
                                         m_iTargetSeat)] )
      return this->m_pSubTask;
  }
  v11 = (CTaskSimpleCarSetPedInAsPassenger *)CTask::operator new(0x20u);
  CTaskSimpleCarSetPedInAsPassenger::CTaskSimpleCarSetPedInAsPassenger(
    v11,
    this->m_pTargetVehicle,
    this->m_iTargetSeat,
    0);
  LOBYTE(result[3].m_pParent) = 1;
  return result;
}
// 4F78EA: variable 'result' is possibly undefined

//----- (004F78F8) --------------------------------------------------------
void __fastcall CTaskComplexEnterCarAsPassengerTimed::StopTimer(
        CTaskComplexEnterCarAsPassengerTimed *this,
        const CEvent *pEvent)
{
  __int64 v3; // kr00_8

  if ( !CEventHandler::IsTemporaryEvent(pEvent) )
  {
    if ( this->m_timer.m_bIsActive )
    {
      v3 = *(_QWORD *)&this->m_timer.m_iStartTime;
      this->m_timer.m_bIsStopped = 1;
      this->m_timer.m_iDuration = HIDWORD(v3) - CTimer::m_snTimeInMilliseconds + v3;
    }
  }
}

//----- (004F7930) --------------------------------------------------------
void __fastcall CTaskComplexEnterCarAsPassengerWait::CTaskComplexEnterCarAsPassengerWait(
        CTaskComplexEnterCarAsPassengerWait *this,
        CVehicle *pTargetVehicle,
        CPed *pWaitForPed,
        const bool bForceFrontSeat,
        const int iMoveState)
{
  CTaskComplex::CTaskComplex(this);
  this->m_iEnterCarFails = 0;
  this->m_bForceFrontSeat = bForceFrontSeat;
  this->m_iMoveState = iMoveState;
  this->m_bPlayedSample = 0;
  this->_vptr$CTask = (int (**)(void))&off_66AAEC;
  this->m_pWaitForPed = pWaitForPed;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
  {
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
    pWaitForPed = this->m_pWaitForPed;
  }
  if ( pWaitForPed )
    CEntity::RegisterReference(pWaitForPed, &this->m_pWaitForPed);
}
// 66AAEC: using guessed type void *;

//----- (004F7990) --------------------------------------------------------
void __fastcall CTaskComplexEnterCarAsPassengerWait::~CTaskComplexEnterCarAsPassengerWait(
        CTaskComplexEnterCarAsPassengerWait *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CPed *m_pWaitForPed; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AAEC;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pWaitForPed = this->m_pWaitForPed;
  if ( m_pWaitForPed )
    CEntity::CleanUpOldReference(m_pWaitForPed, &this->m_pWaitForPed);
  sub_18EDB4(this);
}
// 66AAEC: using guessed type void *off_66AAEC;

//----- (004F79CC) --------------------------------------------------------
void __fastcall CTaskComplexEnterCarAsPassengerWait::~CTaskComplexEnterCarAsPassengerWait(
        CTaskComplexEnterCarAsPassengerWait *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CPed *m_pWaitForPed; // r0
  void *v5; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AAEC;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pWaitForPed = this->m_pWaitForPed;
  if ( m_pWaitForPed )
    CEntity::CleanUpOldReference(m_pWaitForPed, &this->m_pWaitForPed);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v5);
}
// 4F7A02: variable 'v5' is possibly undefined
// 66AAEC: using guessed type void *off_66AAEC;

//----- (004F7A0C) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterCarAsPassengerWait::CreateNextSubTask(
        CTaskComplexEnterCarAsPassengerWait *this,
        CPed *pPed)
{
  int v4; // r0
  void *m_pTargetVehicle; // r0
  int v6; // r1
  int m_iEnterCarFails; // r0

  if ( !this->m_pTargetVehicle )
    goto LABEL_11;
  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v4 <= 718 )
  {
    if ( v4 == 244 )
      goto LABEL_12;
    if ( v4 != 712 )
      return 0;
    if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
    {
      m_iEnterCarFails = this->m_iEnterCarFails;
      this->m_iEnterCarFails = m_iEnterCarFails + 1;
      if ( m_iEnterCarFails <= 14 )
      {
        m_pTargetVehicle = this->m_pTargetVehicle;
        v6 = 244;
LABEL_13:
        if ( !m_pTargetVehicle )
          v6 = 1302;
        return CTaskComplexEnterCarAsPassengerWait::CreateSubTask(this, v6, pPed);
      }
    }
LABEL_11:
    v6 = 1302;
    return CTaskComplexEnterCarAsPassengerWait::CreateSubTask(this, v6, pPed);
  }
  switch ( v4 )
  {
    case 719:
      goto LABEL_11;
    case 833:
LABEL_12:
      m_pTargetVehicle = this->m_pTargetVehicle;
      v6 = 712;
      goto LABEL_13;
    case 903:
      m_pTargetVehicle = this->m_pWaitForPed;
      v6 = 833;
      goto LABEL_13;
  }
  return 0;
}

//----- (004F7A90) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterCarAsPassengerWait::CreateSubTask(
        const CTaskComplexEnterCarAsPassengerWait *this,
        const int iSubTaskType,
        CPed *pPed)
{
  char *v4; // r4
  CVehicle *v5; // r5
  char v6; // r0
  char v7; // r0
  int v8; // r8
  CVehicle *m_pTargetVehicle; // r6
  CTaskComplexTurnToFaceEntityOrCoord *v10; // r6
  CTaskSimpleStandStill *v11; // r5
  float m_fRadius; // s2
  CTaskComplexGoToPointAndStandStill *v13; // r0
  CVehicle *v14; // r6
  int m_iMoveState; // r1
  CMatrix *m_pMat; // r5
  const CVector *p_tx; // r2
  CVector vClosestPoint; // [sp+Ch] [bp-2Ch] BYREF

  v4 = 0;
  if ( iSubTaskType <= 718 )
  {
    if ( iSubTaskType == 244 )
    {
      v4 = (char *)CTask::operator new(0x40u);
      CTaskComplexSequence::CTaskComplexSequence((CTaskComplexSequence *)v4);
      v10 = (CTaskComplexTurnToFaceEntityOrCoord *)CTask::operator new(0x28u);
      CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(v10, this->m_pTargetVehicle, 0.5, 0.2);
      CTaskComplexSequence::AddTask((CTaskComplexSequence *)v4, v10);
      v11 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(v11, 1000, 0, 0, 8.0);
      CTaskComplexSequence::AddTask((CTaskComplexSequence *)v4, v11);
    }
    else if ( iSubTaskType == 712 )
    {
      if ( this->m_bForceFrontSeat )
      {
        v8 = CCarEnterExit::ComputeTargetDoorToEnterAsPassenger(this->m_pTargetVehicle, 0);
        v4 = (char *)CTask::operator new(0x2Cu);
        m_pTargetVehicle = this->m_pTargetVehicle;
        CTaskComplex::CTaskComplex((CTaskComplex *)v4);
        *(_DWORD *)v4 = &off_66AAB0;
        *((_DWORD *)v4 + 4) = -1;
        *((_DWORD *)v4 + 5) = v8;
        v4[24] = 1;
        *((_DWORD *)v4 + 7) = 6;
        *((_WORD *)v4 + 20) = 0;
        *((_DWORD *)v4 + 8) = 0;
        *((_DWORD *)v4 + 9) = 0;
      }
      else
      {
        v4 = (char *)CTask::operator new(0x2Cu);
        m_pTargetVehicle = this->m_pTargetVehicle;
        CTaskComplex::CTaskComplex((CTaskComplex *)v4);
        *((_DWORD *)v4 + 4) = -1;
        *((_DWORD *)v4 + 5) = 0;
        v4[24] = 1;
        *((_DWORD *)v4 + 7) = 6;
        *((_WORD *)v4 + 20) = 0;
        *((_DWORD *)v4 + 8) = 0;
        *((_DWORD *)v4 + 9) = 0;
        *(_DWORD *)v4 = &off_66AAB0;
      }
      *((_DWORD *)v4 + 3) = m_pTargetVehicle;
      if ( m_pTargetVehicle )
        CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v4 + 3);
      *((_DWORD *)v4 + 7) = this->m_iMoveState;
    }
  }
  else
  {
    switch ( iSubTaskType )
    {
      case 903:
        if ( CPedGeometryAnalyser::ComputeClosestSurfacePoint(pPed, this->m_pTargetVehicle, &vClosestPoint) )
        {
          v4 = (char *)CTask::operator new(0x28u);
          CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(
            (CTaskComplexGoToPointAndStandStill *)v4,
            this->m_iMoveState,
            &vClosestPoint,
            1.5,
            2.0,
            0,
            0);
        }
        else
        {
          m_fRadius = CModelInfo::ms_modelInfoPtrs[this->m_pTargetVehicle->m_nModelIndex]->m_pColModel->m_sphereBound.m_fRadius;
          v13 = (CTaskComplexGoToPointAndStandStill *)CTask::operator new(0x28u);
          v4 = (char *)v13;
          v14 = this->m_pTargetVehicle;
          m_iMoveState = this->m_iMoveState;
          m_pMat = v14->m_pMat;
          p_tx = (const CVector *)&m_pMat->tx;
          if ( !m_pMat )
            p_tx = &v14->m_transform.m_translate;
          CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(
            v13,
            m_iMoveState,
            p_tx,
            m_fRadius + 1.5,
            2.0,
            0,
            0);
        }
        break;
      case 833:
        v4 = (char *)CTask::operator new(0x10u);
        CTaskSimpleWaitUntilPedIsInCar::CTaskSimpleWaitUntilPedIsInCar(
          (CTaskSimpleWaitUntilPedIsInCar *)v4,
          this->m_pWaitForPed);
        break;
      case 719:
        v4 = (char *)CTask::operator new(0x70u);
        v5 = this->m_pTargetVehicle;
        CTaskSimple::CTaskSimple((CTaskSimple *)v4);
        *(_QWORD *)(v4 + 12) = 0LL;
        *(_QWORD *)(v4 + 20) = 0LL;
        *((_WORD *)v4 + 14) = 0;
        *(_DWORD *)(v4 + 86) = 0;
        *(_DWORD *)(v4 + 82) = 0;
        *((_DWORD *)v4 + 19) = 0;
        *((_DWORD *)v4 + 20) = 0;
        v6 = v4[92];
        *(_DWORD *)v4 = &off_66AD08;
        v7 = v6 & 0xC3 | 8;
        v4[92] = v7;
        *((_DWORD *)v4 + 2) = v5;
        if ( v5 )
        {
          CEntity::RegisterReference(v5, (CEntity **)v4 + 2);
          v7 = v4[92];
        }
        *((_DWORD *)v4 + 8) = -1;
        v4[92] = v7 & 0xFC;
        *((_DWORD *)v4 + 15) = 0;
        *((_DWORD *)v4 + 16) = 0;
        *((_DWORD *)v4 + 17) = 0;
        *(_DWORD *)(v4 + 106) = 0;
        *(_DWORD *)(v4 + 102) = 0;
        *((_DWORD *)v4 + 24) = 0;
        *((_DWORD *)v4 + 25) = 0;
        *(_DWORD *)v4 = &off_66571C;
        break;
    }
  }
  return (CTask *)v4;
}
// 66571C: using guessed type void *off_66571C;
// 66AAB0: using guessed type void *off_66AAB0;
// 66AD08: using guessed type void *off_66AD08;
// 676B38: using guessed type void *`vtable for'CTaskSimpleCarDriveTimed;

//----- (004F7D14) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterCarAsPassengerWait::CreateFirstSubTask(
        CTaskComplexEnterCarAsPassengerWait *this,
        CPed *pPed)
{
  bool v4; // zf
  CVehicle *m_pMyVehicle; // r0
  int v6; // r1
  __int64 v7; // r0

  m_pMyVehicle = (CVehicle *)(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31);
  v4 = m_pMyVehicle == 0;
  if ( m_pMyVehicle )
  {
    m_pMyVehicle = pPed->m_pMyVehicle;
    v4 = m_pMyVehicle == 0;
  }
  if ( !v4 && m_pMyVehicle == this->m_pTargetVehicle && CVehicle::IsPassenger(m_pMyVehicle, pPed) )
  {
    v6 = 719;
  }
  else
  {
    v7 = *(_QWORD *)&this->m_pTargetVehicle;
    if ( HIDWORD(v7) )
    {
      v6 = 903;
      if ( !(_DWORD)v7 )
        v6 = 1302;
    }
    else if ( (_DWORD)v7 )
    {
      v6 = 712;
    }
    else
    {
      v6 = 1302;
    }
  }
  return CTaskComplexEnterCarAsPassengerWait::CreateSubTask(this, v6, pPed);
}

//----- (004F7D6C) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterCarAsPassengerWait::ControlSubTask(
        CTaskComplexEnterCarAsPassengerWait *this,
        CPed *pPed)
{
  _BOOL4 v4; // r0
  CTask *m_pSubTask; // r1
  CTask *v6; // lr
  float v7; // s2
  float v8; // s4
  float v9; // s12
  CTask v10; // d16
  char m_pParent; // r0
  CPed *m_pWaitForPed; // r0
  UInt16 v13; // r1
  CVehicle *m_pTargetVehicle; // r3
  CMatrix *m_pMat; // r5
  float m_fRadius; // s8
  CSimpleTransform *p_tx; // r0
  CTask v18; // d16
  bool v20; // zf
  CPedGroup *PedsGroup; // r0
  CPed *Leader; // r0
  CVector vClosestPoint; // [sp+10h] [bp-18h] BYREF

  if ( this->m_bPlayedSample )
    goto LABEL_2;
  m_pWaitForPed = this->m_pWaitForPed;
  if ( !m_pWaitForPed )
    goto LABEL_27;
  if ( CPed::IsPlayer(m_pWaitForPed) )
  {
    if ( !CTaskManager::FindActiveTaskByType(&pPed->m_pPedIntelligence->m_taskManager, 807) )
      goto LABEL_2;
    v13 = 35;
    goto LABEL_32;
  }
  v20 = !this->m_bPlayedSample;
  if ( !this->m_bPlayedSample )
    v20 = this->m_pWaitForPed == 0;
  if ( v20 )
  {
LABEL_27:
    PedsGroup = CPedGroups::GetPedsGroup(pPed);
    if ( !PedsGroup )
      goto LABEL_2;
    Leader = CPedGroupMembership::GetLeader(&PedsGroup->m_membership);
    if ( !Leader
      || !CPed::IsPlayer(Leader)
      || !CTaskManager::FindActiveTaskByType(&pPed->m_pPedIntelligence->m_taskManager, 807) )
    {
      goto LABEL_2;
    }
    v13 = 40;
LABEL_32:
    this->m_bPlayedSample = 1;
    CPed::Say(pPed, v13, 0, 1.0, 0, 0, 0);
  }
LABEL_2:
  if ( this->m_pTargetVehicle
    && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 903 )
  {
    v4 = CPedGeometryAnalyser::ComputeClosestSurfacePoint(pPed, this->m_pTargetVehicle, &vClosestPoint);
    m_pSubTask = this->m_pSubTask;
    v6 = m_pSubTask + 2;
    v7 = *(float *)&m_pSubTask[2]._vptr$CTask;
    v8 = *(float *)&m_pSubTask[2].m_pParent;
    v9 = (float)((float)((float)(vClosestPoint.x - v7) * (float)(vClosestPoint.x - v7))
               + (float)((float)(vClosestPoint.y - v8) * (float)(vClosestPoint.y - v8)))
       + (float)((float)(vClosestPoint.z - *(float *)&m_pSubTask[3]._vptr$CTask)
               * (float)(vClosestPoint.z - *(float *)&m_pSubTask[3]._vptr$CTask));
    if ( v4 )
    {
      if ( v9 > 0.025 && (v8 != vClosestPoint.y || v7 != vClosestPoint.x || *(float *)&m_pSubTask[4]._vptr$CTask != 2.0) )
      {
        v10 = *(CTask *)&vClosestPoint.x;
        m_pSubTask[3]._vptr$CTask = (int (**)(void))LODWORD(vClosestPoint.z);
        *v6 = v10;
        m_pSubTask[4]._vptr$CTask = (int (**)(void))0x40000000;
        m_pParent = (char)m_pSubTask[4].m_pParent;
        m_pSubTask[3].m_pParent = (CTask *)1069547520;
LABEL_21:
        LOBYTE(m_pSubTask[4].m_pParent) = m_pParent | 4;
      }
    }
    else if ( v9 > 0.025 )
    {
      m_pTargetVehicle = this->m_pTargetVehicle;
      m_pMat = m_pTargetVehicle->m_pMat;
      m_fRadius = CModelInfo::ms_modelInfoPtrs[m_pTargetVehicle->m_nModelIndex]->m_pColModel->m_sphereBound.m_fRadius;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &m_pTargetVehicle->m_transform;
      if ( v7 != p_tx->m_translate.x || v8 != p_tx->m_translate.y || *(float *)&m_pSubTask[4]._vptr$CTask != 2.0 )
      {
        v18 = *(CTask *)&p_tx->m_translate.x;
        m_pSubTask[3]._vptr$CTask = (int (**)(void))LODWORD(p_tx->m_translate.z);
        *v6 = v18;
        m_pParent = (char)m_pSubTask[4].m_pParent;
        *(float *)&m_pSubTask[3].m_pParent = m_fRadius + 1.5;
        m_pSubTask[4]._vptr$CTask = (int (**)(void))0x40000000;
        goto LABEL_21;
      }
    }
  }
  return this->m_pSubTask;
}

//----- (004F7F88) --------------------------------------------------------
void __fastcall CTaskComplexLeaveCarAsPassengerWait::CTaskComplexLeaveCarAsPassengerWait(
        CTaskComplexLeaveCarAsPassengerWait *this,
        CVehicle *pTargetVehicle)
{
  CTaskComplex::CTaskComplex(this);
  this->_vptr$CTask = (int (**)(void))&off_66AB28;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66AB28: using guessed type void *off_66AB28;

//----- (004F7FB8) --------------------------------------------------------
void __fastcall CTaskComplexLeaveCarAsPassengerWait::~CTaskComplexLeaveCarAsPassengerWait(
        CTaskComplexLeaveCarAsPassengerWait *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AB28;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  sub_18EDB4(this);
}
// 66AB28: using guessed type void *;

//----- (004F7FE4) --------------------------------------------------------
void __fastcall CTaskComplexLeaveCarAsPassengerWait::~CTaskComplexLeaveCarAsPassengerWait(
        CTaskComplexLeaveCarAsPassengerWait *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  void *v4; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AB28;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 4F800C: variable 'v4' is possibly undefined
// 66AB28: using guessed type void *off_66AB28;

//----- (004F8014) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveCarAsPassengerWait::CreateNextSubTask(
        CTaskComplexLeaveCarAsPassengerWait *this,
        CPed *pPed)
{
  int v4; // r0
  bool v5; // zf
  int v6; // r1

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  v5 = v4 == 900;
  v6 = 1302;
  if ( v4 != 900 )
    v5 = v4 == 709;
  if ( !v5 )
  {
    if ( v4 != 704 )
      return 0;
    v6 = 900;
    if ( !this->m_pTargetVehicle )
      v6 = 1302;
  }
  return CTaskComplexLeaveCarAsPassengerWait::CreateSubTask(this, v6, pPed);
}

//----- (004F8058) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveCarAsPassengerWait::CreateSubTask(
        const CTaskComplexLeaveCarAsPassengerWait *this,
        const int iTaskType,
        CPed *pPed)
{
  char *v5; // r4
  CTaskSimpleCarSetPedOut *v6; // r0
  CTaskSimpleCarSetPedInAsPassenger *v7; // r0
  CVehicle *v8; // r5
  CMatrix *m_pMat; // r0
  float xx; // s16
  float yx; // s18
  float zx; // s20
  float xy; // s22
  float yy; // s24
  float zy; // s26
  int v16; // r6
  float v17; // s17
  float v18; // s10
  float v19; // s4
  float v20; // s0
  float v21; // s8
  float v22; // s2
  float v23; // s4
  float v24; // s6
  CMatrix *v25; // r0
  float v26; // s0
  CSimpleTransform *p_tx; // r1
  float y; // s10
  float z; // s12
  CTaskSimpleGoToPoint *v30; // r0
  CTask *v31; // r0
  CVehicle *m_pTargetVehicle; // r5
  char v33; // r0
  char v34; // r0
  CTaskSimpleCarSetPedInAsPassenger v36; // [sp+8h] [bp-90h] BYREF
  CTaskSimpleCarSetPedOut v37; // [sp+28h] [bp-70h] BYREF

  v5 = 0;
  switch ( iTaskType )
  {
    case 900:
      m_pMat = this->m_pTargetVehicle->m_pMat;
      xx = m_pMat->xx;
      yx = m_pMat->yx;
      zx = m_pMat->zx;
      xy = m_pMat->xy;
      yy = m_pMat->yy;
      zy = m_pMat->zy;
      v16 = rand();
      v17 = (float)rand() * 4.6566e-10;
      v18 = -1.0;
      v19 = (float)((float)v16 * 4.6566e-10) + 1.0;
      v20 = (float)((float)rand() * 4.6566e-10) + 1.0;
      if ( (float)(v17 + 0.0) > 0.5 )
        v18 = 1.0;
      v21 = xy * (float)(v19 * v18);
      v22 = yy * (float)(v19 * v18);
      v23 = (float)(zx * v20) + (float)(zy * (float)(v19 * v18));
      *(float *)&v36.m_bIsFinished = v23;
      v24 = (float)(xx * v20) + v21;
      v25 = pPed->m_pMat;
      v26 = (float)(yx * v20) + v22;
      p_tx = (CSimpleTransform *)&v25->tx;
      if ( !v25 )
        p_tx = &pPed->m_transform;
      y = p_tx->m_translate.y;
      z = p_tx->m_translate.z;
      *(float *)&v36._vptr$CTask = p_tx->m_translate.x + v24;
      *(float *)&v36.m_pParent = y + v26;
      *(float *)&v36.m_bIsFinished = z + v23;
      v30 = (CTaskSimpleGoToPoint *)CTask::operator new(0x2Cu);
      CTaskSimpleGoToPoint::CTaskSimpleGoToPoint(v30, 4, (const CVector *)&v36, 1.5, 0, 0);
      return v31;
    case 709:
      v5 = (char *)CTask::operator new(0x60u);
      m_pTargetVehicle = this->m_pTargetVehicle;
      CTaskSimple::CTaskSimple((CTaskSimple *)v5);
      *(_QWORD *)(v5 + 12) = 0LL;
      *(_QWORD *)(v5 + 20) = 0LL;
      *((_WORD *)v5 + 14) = 0;
      *(_DWORD *)(v5 + 86) = 0;
      *(_DWORD *)(v5 + 82) = 0;
      *((_DWORD *)v5 + 19) = 0;
      *((_DWORD *)v5 + 20) = 0;
      v33 = v5[92];
      *(_DWORD *)v5 = &off_66AD08;
      v34 = v33 & 0xC3 | 8;
      v5[92] = v34;
      *((_DWORD *)v5 + 2) = m_pTargetVehicle;
      if ( m_pTargetVehicle )
      {
        CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v5 + 2);
        v34 = v5[92];
      }
      *((_DWORD *)v5 + 8) = -1;
      v5[92] = v34 & 0xFC;
      *((_DWORD *)v5 + 15) = 0;
      *((_DWORD *)v5 + 16) = 0;
      *((_DWORD *)v5 + 17) = 0;
      break;
    case 704:
      CTaskSimpleCarSetPedOut::CTaskSimpleCarSetPedOut(&v37, this->m_pTargetVehicle, 8, 1);
      v37.m_bWarpingOutOfCar = 1;
      CTaskSimpleCarSetPedOut::ProcessPed(v6, pPed);
      CTaskSimpleCarSetPedInAsPassenger::CTaskSimpleCarSetPedInAsPassenger(&v36, this->m_pTargetVehicle, 8, 0);
      v36.m_bWarpingInToCar = 1;
      CTaskSimpleCarSetPedInAsPassenger::ProcessPed(v7, pPed);
      CTaskSimpleCarSetPedInAsPassenger::~CTaskSimpleCarSetPedInAsPassenger(&v36);
      CTaskSimpleCarSetPedOut::~CTaskSimpleCarSetPedOut(&v37);
      v5 = (char *)CTask::operator new(0x34u);
      v8 = this->m_pTargetVehicle;
      CTaskComplex::CTaskComplex((CTaskComplex *)v5);
      *(_DWORD *)v5 = &off_66ABDC;
      *((_DWORD *)v5 + 4) = 0;
      *((_DWORD *)v5 + 5) = 0;
      *((_WORD *)v5 + 12) = 1;
      v5[26] = 0;
      *((_DWORD *)v5 + 7) = 0;
      v5[32] = 0;
      v5[33] = 0;
      *((_DWORD *)v5 + 9) = 15;
      *((_DWORD *)v5 + 10) = 1082130432;
      *((_DWORD *)v5 + 11) = 1065353216;
      v5[48] = 0;
      *((_DWORD *)v5 + 3) = v8;
      if ( v8 )
        CEntity::RegisterReference(v8, (CEntity **)v5 + 3);
      break;
  }
  return (CTask *)v5;
}
// 4F809E: variable 'v6' is possibly undefined
// 4F80BA: variable 'v7' is possibly undefined
// 4F8214: variable 'v31' is possibly undefined
// 66ABDC: using guessed type void *off_66ABDC;
// 66AD08: using guessed type void *off_66AD08;

//----- (004F82A4) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveCarAsPassengerWait::CreateFirstSubTask(
        CTaskComplexLeaveCarAsPassengerWait *this,
        CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r2
  int m_nMaxPassengers; // r1
  CPed **pPassengers; // lr
  int v7; // r2
  CPed *v8; // r3
  int v9; // r1

  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( !m_pTargetVehicle )
    return 0;
  m_nMaxPassengers = m_pTargetVehicle->m_nMaxPassengers;
  if ( m_pTargetVehicle->m_nMaxPassengers )
  {
    pPassengers = m_pTargetVehicle->pPassengers;
    v7 = 0;
    while ( 1 )
    {
      v8 = pPassengers[v7];
      if ( v8 )
        break;
      if ( ++v7 >= m_nMaxPassengers )
        goto LABEL_7;
    }
  }
  else
  {
LABEL_7:
    v8 = 0;
  }
  v9 = 709;
  if ( v8 == pPed )
    v9 = 704;
  return CTaskComplexLeaveCarAsPassengerWait::CreateSubTask(this, v9, pPed);
}

//----- (004F82E2) --------------------------------------------------------
CPed *__fastcall CTaskComplexLeaveCarAsPassengerWait::GetNextPassengerToLeave(
        const CTaskComplexLeaveCarAsPassengerWait *this)
{
  CVehicle *m_pTargetVehicle; // r0
  int m_nMaxPassengers; // r1
  CPed *result; // r0
  CPed **pPassengers; // r2
  int v5; // r3

  m_pTargetVehicle = this->m_pTargetVehicle;
  m_nMaxPassengers = m_pTargetVehicle->m_nMaxPassengers;
  if ( !m_pTargetVehicle->m_nMaxPassengers )
    return 0;
  pPassengers = m_pTargetVehicle->pPassengers;
  v5 = 0;
  while ( 1 )
  {
    result = pPassengers[v5];
    if ( result )
      break;
    if ( ++v5 >= m_nMaxPassengers )
      return 0;
  }
  return result;
}

//----- (004F830C) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveCarAsPassengerWait::ControlSubTask(
        CTaskComplexLeaveCarAsPassengerWait *this,
        CPed *pPed)
{
  CTask *m_pSubTask; // r6
  CVehicle *m_pTargetVehicle; // r1
  int m_nMaxPassengers; // r0
  CPed **pPassengers; // r1
  int v8; // r2
  CPed *v9; // r3

  m_pSubTask = this->m_pSubTask;
  if ( (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) != 709 )
    return m_pSubTask;
  m_pTargetVehicle = this->m_pTargetVehicle;
  m_nMaxPassengers = m_pTargetVehicle->m_nMaxPassengers;
  if ( m_pTargetVehicle->m_nMaxPassengers )
  {
    pPassengers = m_pTargetVehicle->pPassengers;
    v8 = 0;
    while ( 1 )
    {
      v9 = pPassengers[v8];
      if ( v9 )
        break;
      if ( ++v8 >= m_nMaxPassengers )
      {
        v9 = 0;
        break;
      }
    }
    if ( v9 != pPed )
      return m_pSubTask;
  }
  else if ( pPed )
  {
    return m_pSubTask;
  }
  if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
         this->m_pSubTask,
         pPed,
         1,
         0) == 1 )
    return CTaskComplexLeaveCarAsPassengerWait::CreateSubTask(this, 704, pPed);
  return m_pSubTask;
}

//----- (004F8380) --------------------------------------------------------
void __fastcall CTaskComplexLeaveCarAsPassengerWait::SetPedInZerothPassengerSeat(
        const CTaskComplexLeaveCarAsPassengerWait *this,
        CPed *pPed)
{
  CTaskSimpleCarSetPedOut *v4; // r0
  CTaskSimpleCarSetPedInAsPassenger *v5; // r0
  CTaskSimpleCarSetPedInAsPassenger v6; // [sp+0h] [bp-48h] BYREF
  CTaskSimpleCarSetPedOut v7; // [sp+20h] [bp-28h] BYREF

  CTaskSimpleCarSetPedOut::CTaskSimpleCarSetPedOut(&v7, this->m_pTargetVehicle, 8, 1);
  v7.m_bWarpingOutOfCar = 1;
  CTaskSimpleCarSetPedOut::ProcessPed(v4, pPed);
  CTaskSimpleCarSetPedInAsPassenger::CTaskSimpleCarSetPedInAsPassenger(&v6, this->m_pTargetVehicle, 8, 0);
  v6.m_bWarpingInToCar = 1;
  CTaskSimpleCarSetPedInAsPassenger::ProcessPed(v5, pPed);
  CTaskSimpleCarSetPedInAsPassenger::~CTaskSimpleCarSetPedInAsPassenger(&v6);
  CTaskSimpleCarSetPedOut::~CTaskSimpleCarSetPedOut(&v7);
}
// 4F83A6: variable 'v4' is possibly undefined
// 4F83BE: variable 'v5' is possibly undefined

//----- (004F83D8) --------------------------------------------------------
void __fastcall CTaskComplexEnterBoatAsDriver::CTaskComplexEnterBoatAsDriver(
        CTaskComplexEnterBoatAsDriver *this,
        CVehicle *pVehicle)
{
  CTaskComplex::CTaskComplex(this);
  this->_vptr$CTask = (int (**)(void))&off_66AB64;
  this->m_pTargetVehicle = pVehicle;
  if ( pVehicle )
    CEntity::RegisterReference(pVehicle, &this->m_pTargetVehicle);
}
// 66AB64: using guessed type void *off_66AB64;

//----- (004F8408) --------------------------------------------------------
void __fastcall CTaskComplexEnterBoatAsDriver::~CTaskComplexEnterBoatAsDriver(CTaskComplexEnterBoatAsDriver *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AB64;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  sub_18EDB4(this);
}
// 66AB64: using guessed type void *off_66AB64;

//----- (004F8434) --------------------------------------------------------
void __fastcall CTaskComplexEnterBoatAsDriver::~CTaskComplexEnterBoatAsDriver(CTaskComplexEnterBoatAsDriver *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  void *v4; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AB64;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 4F845C: variable 'v4' is possibly undefined
// 66AB64: using guessed type void *off_66AB64;

//----- (004F8464) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterBoatAsDriver::CreateNextSubTask(CTaskComplexEnterBoatAsDriver *this, CPed *pPed)
{
  int v3; // r0
  int v5; // r1

  v3 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  switch ( v3 )
  {
    case 831:
      v5 = 812;
      break;
    case 830:
      v5 = 1302;
      if ( LOBYTE(this->m_pSubTask[3].m_pParent) )
        v5 = 831;
      break;
    case 812:
      v5 = 1302;
      break;
    default:
      return 0;
  }
  return CTaskComplexEnterBoatAsDriver::CreateSubTask(this, v5);
}

//----- (004F84B0) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterBoatAsDriver::CreateSubTask(
        const CTaskComplexEnterBoatAsDriver *this,
        const int iSubTaskType)
{
  CTask *result; // r0
  CTaskSimpleCarSetPedInAsDriver *v4; // r0
  CTaskComplexGetOnBoatSeat *v5; // r0
  CTaskComplexGoToBoatSteeringWheel *v6; // r0

  switch ( iSubTaskType )
  {
    case 831:
      v5 = (CTaskComplexGetOnBoatSeat *)CTask::operator new(0x10u);
      CTaskComplexGetOnBoatSeat::CTaskComplexGetOnBoatSeat(v5, this->m_pTargetVehicle);
      break;
    case 830:
      v6 = (CTaskComplexGoToBoatSteeringWheel *)CTask::operator new(0x24u);
      CTaskComplexGoToBoatSteeringWheel::CTaskComplexGoToBoatSteeringWheel(v6, this->m_pTargetVehicle);
      break;
    case 812:
      v4 = (CTaskSimpleCarSetPedInAsDriver *)CTask::operator new(0x1Cu);
      CTaskSimpleCarSetPedInAsDriver::CTaskSimpleCarSetPedInAsDriver(v4, this->m_pTargetVehicle, 0);
      break;
    default:
      return 0;
  }
  return result;
}

//----- (004F84FC) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterBoatAsDriver::CreateFirstSubTask(CTaskComplexEnterBoatAsDriver *this, CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r2
  int v3; // r1
  CPhysical *m_pGroundPhysical; // r3

  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( pPed->m_pEntityStandingOn == m_pTargetVehicle )
  {
    v3 = 830;
  }
  else
  {
    m_pGroundPhysical = pPed->m_pGroundPhysical;
    v3 = 1302;
    if ( m_pGroundPhysical == m_pTargetVehicle )
      v3 = 830;
  }
  return CTaskComplexEnterBoatAsDriver::CreateSubTask(this, v3);
}

//----- (004F851E) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterBoatAsDriver::ControlSubTask(CTaskComplexEnterBoatAsDriver *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (004F8524) --------------------------------------------------------
void __fastcall CTaskComplexStealCar::CTaskComplexStealCar(CTaskComplexStealCar *this, CVehicle *pTargetVehicle)
{
  CTaskComplex::CTaskComplex(this);
  *(_WORD *)&this->m_timer.m_bIsActive = 0;
  this->m_pOriginalDriver = 0;
  this->m_timer.m_iStartTime = 0;
  this->m_timer.m_iDuration = 0;
  this->_vptr$CTask = (int (**)(void))&off_66ABA0;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66ABA0: using guessed type void *;

//----- (004F8560) --------------------------------------------------------
void __fastcall CTaskComplexStealCar::~CTaskComplexStealCar(CTaskComplexStealCar *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CPed *m_pOriginalDriver; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66ABA0;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pOriginalDriver = this->m_pOriginalDriver;
  if ( m_pOriginalDriver )
    CEntity::CleanUpOldReference(m_pOriginalDriver, &this->m_pOriginalDriver);
  sub_18EDB4(this);
}
// 66ABA0: using guessed type void *off_66ABA0;

//----- (004F859C) --------------------------------------------------------
void __fastcall CTaskComplexStealCar::~CTaskComplexStealCar(CTaskComplexStealCar *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CPed *m_pOriginalDriver; // r0
  void *v5; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66ABA0;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pOriginalDriver = this->m_pOriginalDriver;
  if ( m_pOriginalDriver )
    CEntity::CleanUpOldReference(m_pOriginalDriver, &this->m_pOriginalDriver);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v5);
}
// 4F85D2: variable 'v5' is possibly undefined
// 66ABA0: using guessed type void *off_66ABA0;

//----- (004F85DC) --------------------------------------------------------
CTask *__fastcall CTaskComplexStealCar::CreateNextSubTask(CTaskComplexStealCar *this, CPed *pPed)
{
  int v4; // r0
  CTaskSimpleSetPedAsAutoDriver *v5; // r4
  CVehicle *m_pMyVehicle; // r0
  bool v7; // zf
  CPed *m_pOriginalDriver; // r0
  CTaskComplex *v9; // r0
  CVehicle *m_pTargetVehicle; // r6
  int v11; // r0

  if ( !this->m_pTargetVehicle )
    return 0;
  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  v5 = 0;
  if ( v4 != 827 )
  {
    if ( v4 == 726 )
    {
      if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
      {
        pPed->m_pMyVehicle->AutoPilot.Mission = 1;
        pPed->m_pMyVehicle->AutoPilot.CruiseSpeed = 10;
      }
    }
    else
    {
      if ( v4 != 701 )
        return v5;
      m_pMyVehicle = pPed->m_pMyVehicle;
      v7 = m_pMyVehicle == 0;
      if ( m_pMyVehicle )
        v7 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
      if ( !v7 )
      {
        v5 = (CTaskSimpleSetPedAsAutoDriver *)CTask::operator new(0xCu);
        CTaskSimpleSetPedAsAutoDriver::CTaskSimpleSetPedAsAutoDriver(v5, this->m_pTargetVehicle);
        if ( pPed->m_nPedType == 20 )
          CPed::Say(pPed, 0x92u, 0, 1.0, 0, 0, 0);
        m_pOriginalDriver = this->m_pOriginalDriver;
        if ( m_pOriginalDriver && !CPed::IsPlayer(m_pOriginalDriver) )
          CPed::Say(this->m_pOriginalDriver, 0x91u, 0, 1.0, 0, 0, 0);
        return v5;
      }
    }
    return 0;
  }
  v9 = (CTaskComplex *)CTask::operator new(0x2Cu);
  m_pTargetVehicle = this->m_pTargetVehicle;
  CTaskComplex::CTaskComplex(v9);
  *(_DWORD *)(v11 + 16) = 1109393408;
  *(_DWORD *)(v11 + 20) = -1;
  *(_DWORD *)(v11 + 24) = 2;
  *(_BYTE *)(v11 + 28) = 1;
  *(_BYTE *)(v11 + 32) = 0;
  v5 = (CTaskSimpleSetPedAsAutoDriver *)v11;
  *(_DWORD *)v11 = &off_66AD3C;
  *(_DWORD *)(v11 + 12) = m_pTargetVehicle;
  if ( m_pTargetVehicle )
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)(v11 + 12));
  v5[3].m_pParent = (CTask *)(&dword_0 + 1);
  v5[3]._vptr$CTask = 0;
  v5->_vptr$CTask = (int (**)(void))&off_667284;
  if ( pPed->m_nPedType == 20 )
  {
    *((_DWORD *)&pPed->m_pMyVehicle->m_nVehicleFlags + 1) |= 0x80000u;
    *((_DWORD *)&pPed->m_nPedFlags + 3) |= 0x800u;
  }
  return v5;
}
// 4F869C: variable 'v11' is possibly undefined
// 0: using guessed type int dword_0;
// 667284: using guessed type void *off_667284;
// 66AD3C: using guessed type void *off_66AD3C;
// 677E30: using guessed type void *`vtable for'CTaskComplexCarDriveMissionFleeScene;

//----- (004F872C) --------------------------------------------------------
CTask *__fastcall CTaskComplexStealCar::CreateSubTask(CTaskComplexStealCar *this, const int iSubTaskType, CPed *pPed)
{
  char *v4; // r4
  CPed *m_pOriginalDriver; // r0
  CPed **p_m_pOriginalDriver; // r4
  CVehicle *m_pTargetVehicle; // r0
  CEntity *pDriver; // r0
  CVehicle *v9; // r5
  char v10; // r2
  void **v11; // r0
  CVehicle *v12; // r5

  v4 = 0;
  if ( iSubTaskType <= 725 )
  {
    if ( iSubTaskType == 202 )
    {
      v4 = (char *)CTask::operator new(0x18u);
      CTaskSimple::CTaskSimple((CTaskSimple *)v4);
      *((_WORD *)v4 + 8) = 0;
      v11 = &`vtable for'CTaskSimplePause;
      *((_DWORD *)v4 + 5) = 0;
      *((_DWORD *)v4 + 2) = 0;
      *((_DWORD *)v4 + 3) = 0;
    }
    else
    {
      if ( iSubTaskType != 701 )
        return (CTask *)v4;
      p_m_pOriginalDriver = &this->m_pOriginalDriver;
      m_pOriginalDriver = this->m_pOriginalDriver;
      if ( m_pOriginalDriver )
        CEntity::CleanUpOldReference(m_pOriginalDriver, &this->m_pOriginalDriver);
      m_pTargetVehicle = this->m_pTargetVehicle;
      if ( m_pTargetVehicle )
      {
        pDriver = m_pTargetVehicle->pDriver;
        if ( pDriver )
        {
          *p_m_pOriginalDriver = (CPed *)pDriver;
          CEntity::RegisterReference(pDriver, &this->m_pOriginalDriver);
        }
      }
      v4 = (char *)CTask::operator new(0x50u);
      v9 = this->m_pTargetVehicle;
      CTaskComplex::CTaskComplex((CTaskComplex *)v4);
      *(_QWORD *)(v4 + 20) = 0LL;
      *(_QWORD *)(v4 + 28) = 0LL;
      *((_DWORD *)v4 + 9) = 6;
      *((_WORD *)v4 + 20) = 0;
      *((_DWORD *)v4 + 14) = 0;
      v4[60] = 0;
      *((_DWORD *)v4 + 16) = 0;
      v4[68] = 0;
      v10 = v4[16];
      *((_DWORD *)v4 + 18) = -1082130432;
      *(_DWORD *)v4 = &off_66A8F4;
      v4[16] = v10 & 0xF0 | 1;
      *((_DWORD *)v4 + 3) = v9;
      if ( v9 )
        CEntity::RegisterReference(v9, (CEntity **)v4 + 3);
      v11 = &`vtable for'CTaskComplexEnterCarAsDriver;
    }
LABEL_24:
    *(_DWORD *)v4 = (char *)*v11 + 8;
    return (CTask *)v4;
  }
  switch ( iSubTaskType )
  {
    case 726:
      v4 = (char *)CTask::operator new(0x2Cu);
      v12 = this->m_pTargetVehicle;
      CTaskComplex::CTaskComplex((CTaskComplex *)v4);
      *((_DWORD *)v4 + 4) = 1109393408;
      *((_DWORD *)v4 + 5) = -1;
      *((_DWORD *)v4 + 6) = 2;
      v4[28] = 1;
      v4[32] = 0;
      *(_DWORD *)v4 = &off_66AD3C;
      *((_DWORD *)v4 + 3) = v12;
      if ( v12 )
        CEntity::RegisterReference(v12, (CEntity **)v4 + 3);
      *((_DWORD *)v4 + 10) = 1;
      v11 = &`vtable for'CTaskComplexCarDriveMissionFleeScene;
      *((_DWORD *)v4 + 9) = 0;
      goto LABEL_24;
    case 827:
      v4 = (char *)CTask::operator new(0xCu);
      CTaskSimpleSetPedAsAutoDriver::CTaskSimpleSetPedAsAutoDriver(
        (CTaskSimpleSetPedAsAutoDriver *)v4,
        this->m_pTargetVehicle);
      break;
    case 1302:
      if ( pPed && !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
        *(_DWORD *)&pPed->m_nFlags |= 1u;
      return 0;
  }
  return (CTask *)v4;
}
// 66A8F4: using guessed type void *off_66A8F4;
// 66AD3C: using guessed type void *off_66AD3C;
// 6762B0: using guessed type void *`vtable for'CTaskComplexEnterCarAsDriver;
// 677E30: using guessed type void *`vtable for'CTaskComplexCarDriveMissionFleeScene;
// 678E00: using guessed type void *`vtable for'CTaskSimplePause;

//----- (004F88B0) --------------------------------------------------------
CTask *__fastcall CTaskComplexStealCar::CreateFirstSubTask(CTaskComplexStealCar *this, CPed *pPed)
{
  int v2; // r1
  int v3; // r1

  if ( this->m_pTargetVehicle )
  {
    v2 = CTimer::m_snTimeInMilliseconds;
    this->m_timer.m_bIsActive = 1;
    this->m_timer.m_iStartTime = v2;
    this->m_timer.m_iDuration = 10000;
    v3 = 701;
  }
  else
  {
    v3 = 202;
  }
  return CTaskComplexStealCar::CreateSubTask(this, v3, 0);
}

//----- (004F88DC) --------------------------------------------------------
CTask *__fastcall CTaskComplexStealCar::ControlSubTask(CTaskComplexStealCar *this, CPed *pPed)
{
  CTaskSimple *m_pSubTask; // r4
  unsigned int v5; // r0
  int m_iStartTime; // r1

  m_pSubTask = (CTaskSimple *)this->m_pSubTask;
  if ( (*((int (__fastcall **)(CTaskSimple *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) == 701
    && this->m_timer.m_bIsActive )
  {
    if ( this->m_timer.m_bIsStopped )
    {
      v5 = CTimer::m_snTimeInMilliseconds;
      this->m_timer.m_bIsStopped = 0;
      this->m_timer.m_iStartTime = v5;
      m_iStartTime = v5;
    }
    else
    {
      m_iStartTime = this->m_timer.m_iStartTime;
      v5 = CTimer::m_snTimeInMilliseconds;
    }
    if ( m_iStartTime + this->m_timer.m_iDuration <= v5
      && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
           this->m_pSubTask,
           pPed,
           1,
           0) == 1 )
    {
      m_pSubTask = (CTaskSimple *)CTask::operator new(0x18u);
      CTaskSimple::CTaskSimple(m_pSubTask);
      LOWORD(m_pSubTask[2]._vptr$CTask) = 0;
      m_pSubTask[2].m_pParent = 0;
      m_pSubTask[1]._vptr$CTask = 0;
      m_pSubTask[1].m_pParent = 0;
      m_pSubTask->_vptr$CTask = (int (**)(void))&off_665750;
    }
  }
  return m_pSubTask;
}
// 665750: using guessed type void *off_665750;
// 678E00: using guessed type void *`vtable for'CTaskSimplePause;

//----- (004F8974) --------------------------------------------------------
void __fastcall CTaskComplexLeaveCar::CTaskComplexLeaveCar(
        CTaskComplexLeaveCar *this,
        CVehicle *pTargetVehicle,
        const int iTargetDoor,
        const int iDelayTime,
        const bool bSensibleLeaveCar,
        const bool bForceGetOut)
{
  CTaskComplex::CTaskComplex(this);
  this->m_iTargetDoor = iTargetDoor;
  this->m_iDelayTime = iDelayTime;
  this->m_bSensibleLeaveCar = bSensibleLeaveCar;
  this->m_bForceGetOut = bForceGetOut;
  this->m_bDie = 0;
  this->m_pTaskUtilityLineUpPedWithCar = 0;
  this->m_nDoorFlagsSet = 0;
  this->m_nNumGettingInSet = 0;
  this->m_dieAnim = ANIM_STD_KO_FRONT;
  this->m_fDieAnimBlendDelta = 4.0;
  this->m_fDieAnimSpeed = 1.0;
  this->m_bIsInAir = 0;
  this->_vptr$CTask = (int (**)(void))&off_66ABDC;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66ABDC: using guessed type void *;

//----- (004F89E4) --------------------------------------------------------
void __fastcall CTaskComplexLeaveCar::~CTaskComplexLeaveCar(CTaskComplexLeaveCar *this)
{
  void *v1; // r0

  CTaskComplexLeaveCar::~CTaskComplexLeaveCar(this);
  sub_197118(v1);
}
// 4F89F0: variable 'v1' is possibly undefined

//----- (004F89F4) --------------------------------------------------------
bool __fastcall CTaskComplexLeaveCar::MakeAbortable(
        CTaskComplexLeaveCar *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  int m_iTargetDoor; // r2
  CTaskSimpleCarCloseDoorFromOutside *v8; // r0
  CTaskSimpleCarSetPedOut *v9; // r0
  CVehicle *m_pTargetVehicle; // r0
  uint8 m_nNumGettingInSet; // r1
  bool v12; // r5
  int v13; // r5
  int v14; // r0
  CVehicle *v15; // r0
  uint8 v16; // r1
  bool v17; // zf
  int v18; // r0
  bool v19; // zf
  int v20; // r0
  float v21; // s0
  CVehicle *v23; // r0
  CSimpleTransform *p_tx; // r0
  CMatrix *m_pMat; // r1
  CColPoint v26; // [sp+1Ch] [bp-5Ch] BYREF
  CTaskSimpleCarSetPedOut v27; // [sp+48h] [bp-30h] BYREF

  if ( !this->m_pTargetVehicle )
    return 1;
  if ( iPriority != 1 )
  {
    if ( iPriority == 2 )
    {
      (*((void (__fastcall **)(CTask *, CPed *, int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
        this->m_pSubTask,
        pPed,
        2,
        pEvent);
      if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
      {
        m_iTargetDoor = this->m_iTargetDoor;
        if ( !m_iTargetDoor )
        {
          m_iTargetDoor = CCarEnterExit::ComputeTargetDoorToExit(this->m_pTargetVehicle, pPed);
          this->m_iTargetDoor = m_iTargetDoor;
        }
        CTaskSimpleCarCloseDoorFromOutside::CTaskSimpleCarCloseDoorFromOutside(
          (CTaskSimpleCarCloseDoorFromOutside *)&v26,
          this->m_pTargetVehicle,
          m_iTargetDoor,
          0);
        CTaskSimpleCarCloseDoorFromOutside::MakeAbortable(v8, pPed, 2, pEvent);
        CTaskSimpleCarSetPedOut::CTaskSimpleCarSetPedOut(
          &v27,
          this->m_pTargetVehicle,
          this->m_iTargetDoor,
          this->m_bSensibleLeaveCar);
        CTaskSimpleCarSetPedOut::ProcessPed(v9, pPed);
        CTaskSimpleCarSetPedOut::~CTaskSimpleCarSetPedOut(&v27);
        CTaskSimpleCarCloseDoorFromOutside::~CTaskSimpleCarCloseDoorFromOutside((CTaskSimpleCarCloseDoorFromOutside *)&v26);
      }
      CVehicle::ClearGettingOutFlags(this->m_pTargetVehicle, this->m_nDoorFlagsSet);
      m_pTargetVehicle = this->m_pTargetVehicle;
      m_nNumGettingInSet = this->m_nNumGettingInSet;
      v12 = 1;
      this->m_nDoorFlagsSet = 0;
      m_pTargetVehicle->m_nNumGettingIn -= m_nNumGettingInSet;
      this->m_nNumGettingInSet = 0;
      return v12;
    }
    return 0;
  }
  v13 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  v14 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v13 == 212 )
  {
    if ( v14 != 719 )
    {
LABEL_12:
      v12 = 0;
      if ( (*((int (__fastcall **)(CTask *, CPed *, int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
             this->m_pSubTask,
             pPed,
             1,
             pEvent) == 1 )
      {
        CVehicle::ClearGettingOutFlags(this->m_pTargetVehicle, this->m_nDoorFlagsSet);
        v15 = this->m_pTargetVehicle;
        v16 = this->m_nNumGettingInSet;
        this->m_nDoorFlagsSet = 0;
        v15->m_nNumGettingIn -= v16;
        this->m_nNumGettingInSet = 0;
        return 1;
      }
      return v12;
    }
    return 0;
  }
  if ( pEvent && v14 == 809 && (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 9 )
  {
    v17 = LOBYTE(pEvent[5]._vptr$CEvent) == 0;
    if ( LOBYTE(pEvent[5]._vptr$CEvent) )
      v17 = !*(&pEvent->m_bIsPersistent + 1);
    if ( !v17 )
      goto LABEL_12;
  }
  v18 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( pEvent && v18 == 206 && (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 9 )
  {
    v19 = LOBYTE(pEvent[5]._vptr$CEvent) == 0;
    if ( LOBYTE(pEvent[5]._vptr$CEvent) )
      v19 = !*(&pEvent->m_bIsPersistent + 1);
    if ( !v19 )
      goto LABEL_12;
  }
  v20 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( !pEvent
    || v20 != 814
    || (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 33
    && (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 66 )
  {
    if ( pEvent
      && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 719 )
    {
      return (*((int (__fastcall **)(CTask *, CPed *, int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
              + 7))(
               this->m_pSubTask,
               pPed,
               1,
               pEvent);
    }
    return 0;
  }
  if ( (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 33 )
    this->m_bIsInAir = 1;
  if ( (*((int (__fastcall **)(CTask *, CPed *, int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
         this->m_pSubTask,
         pPed,
         1,
         pEvent) != 1 )
    return 0;
  if ( pPed->m_WeaponSlots[pPed->m_nCurrentWeapon].m_eWeaponType == WEAPONTYPE_PARACHUTE
    && (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 33
    && !(*((int (__fastcall **)(CVehicle *))this->m_pTargetVehicle->_vptr$CPlaceable + 56))(this->m_pTargetVehicle) )
  {
    v23 = this->m_pTargetVehicle;
    if ( v23->m_vehicleType != 4
      || sqrtf(
           (float)((float)(v23->m_vecMoveSpeed.x * v23->m_vecMoveSpeed.x)
                 + (float)(v23->m_vecMoveSpeed.y * v23->m_vecMoveSpeed.y))
         + (float)(v23->m_vecMoveSpeed.z * v23->m_vecMoveSpeed.z)) <= 0.2 )
    {
      if ( !CPed::IsPlayer(pPed) )
        return 0;
      m_pMat = pPed->m_pMat;
      v17 = m_pMat == 0;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      LOWORD(m_pMat) = 0;
      if ( v17 )
        p_tx = &pPed->m_transform;
      HIWORD(m_pMat) = -16096;
      if ( CWorld::ProcessVerticalLine(
             &p_tx->m_translate,
             *(float *)&m_pMat,
             &v26,
             (CEntity **)&v27,
             1,
             0,
             0,
             0,
             1,
             0,
             0) )
      {
        return 0;
      }
    }
    v21 = 8.0;
  }
  else
  {
    if ( (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 66
      || pPed->m_vecMoveSpeed.z >= -0.3 )
    {
      return 0;
    }
    v21 = 16.0;
  }
  v12 = 0;
  CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, ANIM_STD_FALL_ONFRONT, v21);
  return v12;
}
// 4F8A4E: variable 'v8' is possibly undefined
// 4F8A62: variable 'v9' is possibly undefined

//----- (004F8CC0) --------------------------------------------------------
void __fastcall CTaskComplexLeaveCar::ComputeTargetDoor(CTaskComplexLeaveCar *this, CPed *pPed)
{
  if ( !this->m_iTargetDoor )
    this->m_iTargetDoor = CCarEnterExit::ComputeTargetDoorToExit(this->m_pTargetVehicle, pPed);
}

//----- (004F8CD8) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveCar::CreateSubTask(CTaskComplexLeaveCar *this, const int iSubTaskType, CPed *pPed)
{
  char *v4; // r4
  CVehicle *v5; // r6
  int m_iDelayTime; // r8
  char v7; // r0
  char v8; // r0
  char *v9; // r0
  CTaskSimpleCarWaitToSlowDown *v10; // r0
  CVehicle *m_pTargetVehicle; // r1
  int v12; // r2
  CVehicle *v13; // r5
  _BOOL4 IsPlayer; // r6

  v4 = 0;
  if ( iSubTaskType < 716 )
  {
    switch ( iSubTaskType )
    {
      case 202:
        v4 = (char *)CTask::operator new(0x18u);
        CTaskSimple::CTaskSimple((CTaskSimple *)v4);
        *((_WORD *)v4 + 8) = 0;
        *((_DWORD *)v4 + 5) = -1;
        *((_DWORD *)v4 + 2) = 0;
        *((_DWORD *)v4 + 3) = 0;
        v9 = (char *)&`vtable for'CTaskSimplePause;
LABEL_14:
        *(_DWORD *)v4 = v9 + 8;
        break;
      case 206:
        v4 = (char *)CTask::operator new(0xCu);
        CTaskComplexGetUpAndStandStill::CTaskComplexGetUpAndStandStill((CTaskComplexGetUpAndStandStill *)v4);
        break;
      case 212:
        v4 = (char *)CTask::operator new(0x28u);
        CTaskSimpleDie::CTaskSimpleDie(
          (CTaskSimpleDie *)v4,
          ANIM_STD_PED,
          (const AnimationId)this->m_dieAnim,
          this->m_fDieAnimBlendDelta,
          this->m_fDieAnimSpeed);
        break;
    }
  }
  else
  {
    switch ( iSubTaskType )
    {
      case 806:
        v4 = (char *)CTask::operator new(0x1Cu);
        CTaskSimpleCarCloseDoorFromOutside::CTaskSimpleCarCloseDoorFromOutside(
          (CTaskSimpleCarCloseDoorFromOutside *)v4,
          this->m_pTargetVehicle,
          this->m_iTargetDoor,
          this->m_pTaskUtilityLineUpPedWithCar);
        break;
      case 807:
      case 808:
      case 811:
      case 812:
      case 817:
      case 818:
      case 819:
      case 820:
      case 821:
      case 822:
        return (CTask *)v4;
      case 809:
        if ( this->m_bDie || !this->m_bSensibleLeaveCar )
        {
          v10 = (CTaskSimpleCarWaitToSlowDown *)CTask::operator new(0x14u);
          m_pTargetVehicle = this->m_pTargetVehicle;
          v12 = 2;
        }
        else
        {
          IsPlayer = CPed::IsPlayer(pPed);
          v10 = (CTaskSimpleCarWaitToSlowDown *)CTask::operator new(0x14u);
          m_pTargetVehicle = this->m_pTargetVehicle;
          v12 = !IsPlayer;
        }
        v4 = (char *)v10;
        CTaskSimpleCarWaitToSlowDown::CTaskSimpleCarWaitToSlowDown(v10, m_pTargetVehicle, v12);
        break;
      case 810:
        v4 = (char *)CTask::operator new(0x14u);
        CTaskSimpleCarWaitForDoorNotToBeInUse::CTaskSimpleCarWaitForDoorNotToBeInUse(
          (CTaskSimpleCarWaitForDoorNotToBeInUse *)v4,
          this->m_pTargetVehicle,
          this->m_iTargetDoor,
          0);
        break;
      case 813:
        v4 = (char *)CTask::operator new(0x20u);
        CTaskSimpleCarGetOut::CTaskSimpleCarGetOut(
          (CTaskSimpleCarGetOut *)v4,
          this->m_pTargetVehicle,
          this->m_iTargetDoor,
          this->m_pTaskUtilityLineUpPedWithCar);
        break;
      case 814:
        v4 = (char *)CTask::operator new(0x24u);
        CTaskSimpleCarJumpOut::CTaskSimpleCarJumpOut(
          (CTaskSimpleCarJumpOut *)v4,
          this->m_pTargetVehicle,
          this->m_iTargetDoor,
          this->m_pTaskUtilityLineUpPedWithCar);
        break;
      case 815:
        v4 = (char *)CTask::operator new(0x10u);
        CTaskSimpleCarForcePedOut::CTaskSimpleCarForcePedOut(
          (CTaskSimpleCarForcePedOut *)v4,
          this->m_pTargetVehicle,
          this->m_iTargetDoor);
        break;
      case 816:
        v4 = (char *)CTask::operator new(0x18u);
        CTaskSimpleCarSetPedOut::CTaskSimpleCarSetPedOut(
          (CTaskSimpleCarSetPedOut *)v4,
          this->m_pTargetVehicle,
          this->m_iTargetDoor,
          this->m_bSensibleLeaveCar);
        break;
      case 823:
        v4 = (char *)CTask::operator new(0x1Cu);
        CTaskComplexCarSlowBeDraggedOut::CTaskComplexCarSlowBeDraggedOut(
          (CTaskComplexCarSlowBeDraggedOut *)v4,
          this->m_pTargetVehicle,
          this->m_iTargetDoor,
          1);
        break;
      default:
        if ( iSubTaskType == 716 )
        {
          v4 = (char *)CTask::operator new(0x14u);
          v13 = this->m_pTargetVehicle;
          CTaskComplex::CTaskComplex((CTaskComplex *)v4);
          *((_DWORD *)v4 + 4) = 0;
          *(_DWORD *)v4 = &off_66AC18;
          *((_DWORD *)v4 + 3) = v13;
          if ( v13 )
            CEntity::RegisterReference(v13, (CEntity **)v4 + 3);
        }
        else if ( iSubTaskType == 719 )
        {
          v4 = (char *)CTask::operator new(0x70u);
          v5 = this->m_pTargetVehicle;
          m_iDelayTime = this->m_iDelayTime;
          CTaskSimple::CTaskSimple((CTaskSimple *)v4);
          *(_QWORD *)(v4 + 12) = 0LL;
          *(_QWORD *)(v4 + 20) = 0LL;
          *((_WORD *)v4 + 14) = 0;
          *(_DWORD *)(v4 + 86) = 0;
          *(_DWORD *)(v4 + 82) = 0;
          *((_DWORD *)v4 + 19) = 0;
          *((_DWORD *)v4 + 20) = 0;
          v7 = v4[92];
          *(_DWORD *)v4 = &off_66AD08;
          v8 = v7 & 0xC3 | 8;
          v4[92] = v8;
          *((_DWORD *)v4 + 2) = v5;
          if ( v5 )
          {
            CEntity::RegisterReference(v5, (CEntity **)v4 + 2);
            v8 = v4[92];
          }
          *((_DWORD *)v4 + 8) = -1;
          v4[92] = v8 & 0xFC;
          *((_DWORD *)v4 + 15) = 0;
          *((_DWORD *)v4 + 16) = 0;
          *((_DWORD *)v4 + 17) = 0;
          *((_DWORD *)v4 + 24) = m_iDelayTime;
          *((_WORD *)v4 + 54) = 0;
          v9 = (char *)&`vtable for'CTaskSimpleCarDriveTimed;
          *((_DWORD *)v4 + 25) = 0;
          *((_DWORD *)v4 + 26) = 0;
          goto LABEL_14;
        }
        break;
    }
  }
  return (CTask *)v4;
}
// 66AC18: using guessed type void *;
// 66AD08: using guessed type void *off_66AD08;
// 676B38: using guessed type void *`vtable for'CTaskSimpleCarDriveTimed;
// 678E00: using guessed type void *`vtable for'CTaskSimplePause;

//----- (004F8F1C) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveCar::CreateNextSubTask(CTaskComplexLeaveCar *this, CPed *pPed)
{
  int v4; // r1
  CTask *result; // r0
  int m_iTargetDoor; // r1
  int v7; // r1
  CTaskComplexCarSlowBeDraggedOut *v8; // r0
  CVehicle *v9; // r0
  CTaskSimpleCarCloseDoorFromOutside *v10; // r0
  CVehicle *v11; // r0
  CTaskSimpleDie *v12; // r0
  CTaskSimpleCarJumpOut *v13; // r0
  CVehicle *v14; // r0
  int32 m_baseVehicleType; // r1
  bool v16; // zf
  CVehicle *v17; // r0
  uint8 m_nNumGettingInSet; // r1
  CTaskComplexGetUpAndStandStill *v19; // r0
  uint32 DoorStatus; // r0
  CTaskSimpleCarSetPedOut *v21; // r0
  CVehicle *m_pTargetVehicle; // r0
  CPed *pDriver; // r1
  bool v24; // zf
  int v25; // r6
  CTaskUtilityLineUpPedWithCar *v26; // r0
  CTaskUtilityLineUpPedWithCar *v27; // r0
  CTaskSimpleCarGetOut *v28; // r0
  CVehicle *v29; // r0
  CTaskUtilityLineUpPedWithCar *v30; // r0
  CTaskUtilityLineUpPedWithCar *v31; // r0
  CTaskUtilityLineUpPedWithCar *v32; // r0
  CTaskUtilityLineUpPedWithCar *v33; // r0
  bool bWait; // [sp+Bh] [bp-1Dh] BYREF
  CVector bQuit[2]; // [sp+Ch] [bp-1Ch] BYREF

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  result = 0;
  if ( v4 > 805 )
  {
    switch ( v4 )
    {
      case 806:
        this->m_dieAnim = ANIM_STD_KO_FRONT;
        goto LABEL_48;
      case 809:
        if ( (*((int (__fastcall **)(CVehicle *, _DWORD))this->m_pTargetVehicle->_vptr$CPlaceable + 58))(
               this->m_pTargetVehicle,
               0) != 1 )
        {
          CTaskComplexLeaveCar::PrepareVehicleForPedExit(this, pPed);
          CPed::SetPedState(pPed, PED_NONE);
          v13 = (CTaskSimpleCarJumpOut *)CTask::operator new(0x24u);
          CTaskSimpleCarJumpOut::CTaskSimpleCarJumpOut(
            v13,
            this->m_pTargetVehicle,
            this->m_iTargetDoor,
            this->m_pTaskUtilityLineUpPedWithCar);
          return result;
        }
        if ( CCarEnterExit::IsRoomForPedToLeaveCar(this->m_pTargetVehicle, this->m_iTargetDoor, 0) )
        {
          CTaskComplexLeaveCar::PrepareVehicleForPedExit(this, pPed);
          CPed::SetPedState(pPed, PED_NONE);
          if ( this->m_bDie )
          {
            v8 = (CTaskComplexCarSlowBeDraggedOut *)CTask::operator new(0x1Cu);
            CTaskComplexCarSlowBeDraggedOut::CTaskComplexCarSlowBeDraggedOut(
              v8,
              this->m_pTargetVehicle,
              this->m_iTargetDoor,
              1);
          }
          else
          {
            memset(bQuit, 0, 12);
            v26 = (CTaskUtilityLineUpPedWithCar *)operator new(0x1Cu);
            CTaskUtilityLineUpPedWithCar::CTaskUtilityLineUpPedWithCar(v26, bQuit, 0, 0, this->m_iTargetDoor);
            this->m_pTaskUtilityLineUpPedWithCar = v27;
            v28 = (CTaskSimpleCarGetOut *)CTask::operator new(0x20u);
            CTaskSimpleCarGetOut::CTaskSimpleCarGetOut(
              v28,
              this->m_pTargetVehicle,
              this->m_iTargetDoor,
              this->m_pTaskUtilityLineUpPedWithCar);
          }
          return result;
        }
        switch ( this->m_iTargetDoor )
        {
          case 8:
            m_pTargetVehicle = this->m_pTargetVehicle;
            pDriver = m_pTargetVehicle->pDriver;
            v24 = pDriver == 0;
            if ( !pDriver )
              v24 = m_pTargetVehicle->m_nGettingInFlags << 31 == 0;
            if ( !v24 )
              goto LABEL_83;
            v25 = 10;
            break;
          case 9:
            m_pTargetVehicle = this->m_pTargetVehicle;
            if ( m_pTargetVehicle->pPassengers[1] || (m_pTargetVehicle->m_nGettingInFlags & 2) != 0 )
              goto LABEL_83;
            v25 = 11;
            break;
          case 0xA:
            m_pTargetVehicle = this->m_pTargetVehicle;
            if ( m_pTargetVehicle->m_baseVehicleType != 9
              && (m_pTargetVehicle->pHandling->mFlags & 0x200) == 0
              && (m_pTargetVehicle->pPassengers[0] || (m_pTargetVehicle->m_nGettingInFlags & 4) != 0) )
            {
              goto LABEL_83;
            }
            v25 = 8;
            break;
          case 0xB:
            m_pTargetVehicle = this->m_pTargetVehicle;
            if ( m_pTargetVehicle->m_baseVehicleType != 9
              && (m_pTargetVehicle->pHandling->mFlags & 0x200) == 0
              && (m_pTargetVehicle->pPassengers[2] || (m_pTargetVehicle->m_nGettingInFlags & 8) != 0) )
            {
              goto LABEL_83;
            }
            v25 = 9;
            break;
          default:
            m_pTargetVehicle = this->m_pTargetVehicle;
            v25 = 0;
            break;
        }
        if ( CCarEnterExit::IsRoomForPedToLeaveCar(m_pTargetVehicle, v25, 0)
          && ((v29 = this->m_pTargetVehicle, (v29->pHandling->mFlags & 0x8000) == 0)
           || v29->m_baseVehicleType
           || *((_DWORD *)&v29[1].m_vecCOM.x + v25)) )
        {
          this->m_iTargetDoor = v25;
          CTaskComplexLeaveCar::PrepareVehicleForPedExit(this, pPed);
          CPed::SetPedState(pPed, PED_NONE);
          if ( this->m_bDie )
          {
            v7 = 823;
          }
          else
          {
            memset(bQuit, 0, 12);
            v32 = (CTaskUtilityLineUpPedWithCar *)operator new(0x1Cu);
            CTaskUtilityLineUpPedWithCar::CTaskUtilityLineUpPedWithCar(v32, bQuit, 0, 0, this->m_iTargetDoor);
            this->m_pTaskUtilityLineUpPedWithCar = v33;
            v7 = 813;
          }
        }
        else
        {
LABEL_83:
          CTaskComplexLeaveCar::PrepareVehicleForPedExit(this, pPed);
          CPed::SetPedState(pPed, PED_NONE);
          memset(bQuit, 0, 12);
          v30 = (CTaskUtilityLineUpPedWithCar *)operator new(0x1Cu);
          CTaskUtilityLineUpPedWithCar::CTaskUtilityLineUpPedWithCar(v30, bQuit, 0, 0, this->m_iTargetDoor);
          this->m_pTaskUtilityLineUpPedWithCar = v31;
          v7 = 815;
        }
        return CTaskComplexLeaveCar::CreateSubTask(this, v7, pPed);
      case 810:
        return CTaskComplexLeaveCar::CreateSubTask(this, 809, pPed);
      case 813:
        this->m_pTaskUtilityLineUpPedWithCar->m_nZFlag = 2;
        v9 = this->m_pTargetVehicle;
        if ( this->m_bForceGetOut && v9->m_eDoorLockState == CARLOCK_UNLOCKED )
          goto LABEL_43;
        if ( CCarEnterExit::CarHasDoorToClose(v9, this->m_iTargetDoor) )
        {
          v10 = (CTaskSimpleCarCloseDoorFromOutside *)CTask::operator new(0x1Cu);
          CTaskSimpleCarCloseDoorFromOutside::CTaskSimpleCarCloseDoorFromOutside(
            v10,
            this->m_pTargetVehicle,
            this->m_iTargetDoor,
            this->m_pTaskUtilityLineUpPedWithCar);
          return result;
        }
        v9 = this->m_pTargetVehicle;
LABEL_43:
        if ( !v9->m_baseVehicleType
          && CCarEnterExit::CarHasDoorToClose(v9, this->m_iTargetDoor)
          && (!CDamageManager::GetDoorStatus((const CDamageManager *)&this->m_pTargetVehicle[1], this->m_iTargetDoor)
           || CDamageManager::GetDoorStatus((const CDamageManager *)&this->m_pTargetVehicle[1], this->m_iTargetDoor) == 2) )
        {
          DoorStatus = CDamageManager::GetDoorStatus(
                         (const CDamageManager *)&this->m_pTargetVehicle[1],
                         this->m_iTargetDoor);
          CDamageManager::SetDoorStatus(
            (CDamageManager *)&this->m_pTargetVehicle[1],
            this->m_iTargetDoor,
            DoorStatus + 1);
        }
        goto LABEL_48;
      case 814:
        if ( this->m_bDie )
        {
          this->m_dieAnim = ANIM_STD_KO_FRONT;
          this->m_fDieAnimBlendDelta = 1000.0;
          this->m_fDieAnimSpeed = 0.5;
          goto LABEL_31;
        }
        v14 = this->m_pTargetVehicle;
        if ( !v14 )
          return 0;
        m_baseVehicleType = v14->m_baseVehicleType;
        v16 = m_baseVehicleType == 9;
        if ( m_baseVehicleType != 9 )
          v16 = v14->m_vehicleType == 2;
        if ( v16 )
          return 0;
        if ( this->m_bIsInAir || (*((_BYTE *)&pPed->m_nPedFlags + 6) & 8) != 0 )
          goto LABEL_48;
        CVehicle::ClearGettingOutFlags(v14, this->m_nDoorFlagsSet);
        v17 = this->m_pTargetVehicle;
        m_nNumGettingInSet = this->m_nNumGettingInSet;
        this->m_nDoorFlagsSet = 0;
        v17->m_nNumGettingIn -= m_nNumGettingInSet;
        this->m_nNumGettingInSet = 0;
        v19 = (CTaskComplexGetUpAndStandStill *)CTask::operator new(0xCu);
        CTaskComplexGetUpAndStandStill::CTaskComplexGetUpAndStandStill(v19);
        break;
      case 815:
        goto LABEL_48;
      case 816:
        goto LABEL_15;
      case 823:
        v11 = this->m_pTargetVehicle;
        this->m_dieAnim = ANIM_STD_HIT_FLOOR;
        this->m_fDieAnimBlendDelta = 1000.0;
        this->m_fDieAnimSpeed = 0.5;
        if ( v11 && v11->m_eDoorLockState == CARLOCK_LOCKED_INITIALLY )
          v11->m_eDoorLockState = CARLOCK_UNLOCKED;
        goto LABEL_31;
      default:
        return result;
    }
    return result;
  }
  if ( v4 == 206 )
  {
    if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
    {
LABEL_48:
      v21 = (CTaskSimpleCarSetPedOut *)CTask::operator new(0x18u);
      CTaskSimpleCarSetPedOut::CTaskSimpleCarSetPedOut(
        v21,
        this->m_pTargetVehicle,
        this->m_iTargetDoor,
        this->m_bSensibleLeaveCar);
      return result;
    }
    return 0;
  }
  if ( v4 == 716 )
  {
LABEL_15:
    if ( this->m_bDie )
    {
LABEL_31:
      v12 = (CTaskSimpleDie *)CTask::operator new(0x28u);
      CTaskSimpleDie::CTaskSimpleDie(
        v12,
        ANIM_STD_PED,
        (const AnimationId)this->m_dieAnim,
        this->m_fDieAnimBlendDelta,
        this->m_fDieAnimSpeed);
      return result;
    }
    return 0;
  }
  if ( v4 != 719 )
    return result;
  if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
    return 0;
  if ( !CVehicle::IsPassenger(pPed->m_pMyVehicle, pPed) && !CVehicle::IsDriver(pPed->m_pMyVehicle, pPed) )
  {
    *(_DWORD *)&pPed->m_nPedFlags &= ~0x100u;
    return 0;
  }
  m_iTargetDoor = this->m_iTargetDoor;
  if ( !m_iTargetDoor )
  {
    m_iTargetDoor = CCarEnterExit::ComputeTargetDoorToExit(this->m_pTargetVehicle, pPed);
    this->m_iTargetDoor = m_iTargetDoor;
  }
  LOBYTE(bQuit[0].x) = 0;
  bWait = 0;
  CTaskSimpleCarWaitForDoorNotToBeInUse::CheckDoorsFreeOfPeds(
    this->m_pTargetVehicle,
    m_iTargetDoor,
    (bool *)bQuit,
    &bWait);
  if ( this->m_bForceGetOut || !bWait )
  {
    v7 = 1302;
    if ( !LOBYTE(bQuit[0].x) )
      v7 = 809;
    if ( this->m_bForceGetOut )
      v7 = 809;
  }
  else
  {
    v7 = 810;
  }
  return CTaskComplexLeaveCar::CreateSubTask(this, v7, pPed);
}
// 4F9230: variable 'v27' is possibly undefined
// 4F9320: variable 'v31' is possibly undefined
// 4F9350: variable 'v33' is possibly undefined

//----- (004F9358) --------------------------------------------------------
void __fastcall CTaskComplexLeaveCar::PrepareVehicleForPedExit(CTaskComplexLeaveCar *this, CPed *pPed)
{
  uint8 v4; // r0
  CVehicle *m_pTargetVehicle; // r0
  CPed *pDriver; // r0
  CVehicle *v7; // r0
  CVehicle *v8; // r0

  v4 = CCarEnterExit::ComputeDoorFlag(this->m_pTargetVehicle, this->m_iTargetDoor, 1);
  this->m_nDoorFlagsSet = v4;
  CVehicle::SetGettingOutFlags(this->m_pTargetVehicle, v4);
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->m_nNumGettingInSet = 1;
  ++m_pTargetVehicle->m_nNumGettingIn;
  pDriver = this->m_pTargetVehicle->pDriver;
  if ( pDriver )
  {
    if ( !CPed::IsPlayer(pDriver) )
    {
      v7 = this->m_pTargetVehicle;
      if ( v7->pDriver == pPed && this->m_bSensibleLeaveCar )
      {
        v7->AutoPilot.CruiseSpeed = 0;
        this->m_pTargetVehicle->AutoPilot.Mission = 0;
      }
    }
  }
  if ( CPed::IsPlayer(pPed) )
  {
    v8 = this->m_pTargetVehicle;
    if ( v8->pDriver == pPed )
      v8->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&v8->m_info & 7 | 0x48);
  }
}

//----- (004F93E6) --------------------------------------------------------
void __fastcall CTaskComplexLeaveCar::PreparePedForVehicleExit(CTaskComplexLeaveCar *this, CPed *pPed)
{
  sub_18D8EC(pPed, PED_NONE);
}

//----- (004F93EE) --------------------------------------------------------
void __fastcall CTaskComplexLeaveCar::CreateTaskUtilityLineUpPedWithCar(CTaskComplexLeaveCar *this, CPed *pPed)
{
  CTaskUtilityLineUpPedWithCar *v3; // r0
  CTaskUtilityLineUpPedWithCar *v4; // r0
  CVector vInitialBlendVector; // [sp+4h] [bp-14h] BYREF

  memset(&vInitialBlendVector, 0, sizeof(vInitialBlendVector));
  v3 = (CTaskUtilityLineUpPedWithCar *)operator new(0x1Cu);
  CTaskUtilityLineUpPedWithCar::CTaskUtilityLineUpPedWithCar(v3, &vInitialBlendVector, 0, 0, this->m_iTargetDoor);
  this->m_pTaskUtilityLineUpPedWithCar = v4;
}
// 4F9412: variable 'v4' is possibly undefined

//----- (004F9418) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveCar::CreateFirstSubTask(CTaskComplexLeaveCar *this, CPed *pPed)
{
  int v4; // r1
  CPedGroup *PedsGroup; // r0
  CPedGroup *v6; // r6
  CEventEditableResponse *v7; // r8
  CVehicle *m_pMyVehicle; // r0
  CEventGroupEvent v10; // [sp+4h] [bp-2Ch] BYREF

  if ( (pPed->m_nPedState == PED_ARRESTED || (*((_DWORD *)&pPed->m_nPedFlags + 2) & 0x40) != 0) && CPed::IsPlayer(pPed)
    || (*(_DWORD *)&pPed->m_nPedFlags & 0x100) == 0 )
  {
    v4 = 202;
  }
  else
  {
    if ( this->m_pTargetVehicle->pDriver == pPed )
    {
      PedsGroup = CPedGroups::GetPedsGroup(pPed);
      v6 = PedsGroup;
      if ( PedsGroup && CPedGroupMembership::IsLeader(&PedsGroup->m_membership, pPed) )
      {
        v7 = (CEventEditableResponse *)CEvent::operator new(0x10u);
        CEventEditableResponse::CEventEditableResponse(v7);
        v7->_vptr$CEvent = (int (**)(void))&off_666E98;
        CEventGroupEvent::CEventGroupEvent(&v10, pPed, (CEvent *)v7);
        CPedGroupIntelligence::AddEvent(&v6->m_intelligence, &v10);
        CEventGroupEvent::~CEventGroupEvent(&v10);
      }
      if ( CPed::IsPlayer(pPed) )
      {
        m_pMyVehicle = pPed->m_pMyVehicle;
        if ( m_pMyVehicle )
          CAEVehicleAudioEntity::PlayerAboutToExitVehicleAsDriver(&m_pMyVehicle->m_VehicleAudioEntity);
      }
      else
      {
        CPed::SetRadioStation(pPed);
      }
    }
    v4 = 719;
    if ( this->m_pTargetVehicle->m_baseVehicleType == 5 )
      v4 = 716;
  }
  return CTaskComplexLeaveCar::CreateSubTask(this, v4, pPed);
}
// 666E98: using guessed type void *off_666E98;
// 6794B8: using guessed type void *`vtable for'CEventLeaderExitedCarAsDriver;

//----- (004F94EC) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveCar::ControlSubTask(CTaskComplexLeaveCar *this, CPed *pPed)
{
  CTask *result; // r0
  CTaskSimpleCarSetPedOut *v5; // r0

  if ( !this->m_pTargetVehicle )
    return 0;
  if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31
    || (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 816
    || (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 814
    || (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 206
    || (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 212 )
  {
    if ( !this->m_bSensibleLeaveCar
      && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 809 )
    {
      (*((void (__fastcall **)(CTask *, CPed *, _DWORD, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
        this->m_pSubTask,
        pPed,
        0,
        0);
    }
    return this->m_pSubTask;
  }
  else
  {
    v5 = (CTaskSimpleCarSetPedOut *)CTask::operator new(0x18u);
    CTaskSimpleCarSetPedOut::CTaskSimpleCarSetPedOut(
      v5,
      this->m_pTargetVehicle,
      this->m_iTargetDoor,
      this->m_bSensibleLeaveCar);
  }
  return result;
}

//----- (004F9574) --------------------------------------------------------
void __fastcall CTaskComplexLeaveBoat::CTaskComplexLeaveBoat(
        CTaskComplexLeaveBoat *this,
        CVehicle *pTargetVehicle,
        const int iDelayTime)
{
  CTaskComplex::CTaskComplex(this);
  this->m_iDelayTime = iDelayTime;
  this->_vptr$CTask = (int (**)(void))&off_66AC18;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66AC18: using guessed type void *off_66AC18;

//----- (004F95B0) --------------------------------------------------------
void __fastcall CTaskComplexLeaveBoat::~CTaskComplexLeaveBoat(CTaskComplexLeaveBoat *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AC18;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  sub_18EDB4(this);
}
// 66AC18: using guessed type void *off_66AC18;

//----- (004F95DC) --------------------------------------------------------
void __fastcall CTaskComplexLeaveBoat::~CTaskComplexLeaveBoat(CTaskComplexLeaveBoat *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  void *v4; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AC18;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 4F9604: variable 'v4' is possibly undefined
// 66AC18: using guessed type void *off_66AC18;

//----- (004F960C) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveBoat::CreateNextSubTask(CTaskComplexLeaveBoat *this, CPed *pPed)
{
  return 0;
}

//----- (004F9610) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveBoat::CreateFirstSubTask(CTaskComplexLeaveBoat *this, CPed *pPed)
{
  CTaskSimpleCarSetPedOut *v3; // r0
  CTask *result; // r0

  v3 = (CTaskSimpleCarSetPedOut *)CTask::operator new(0x18u);
  sub_1926F0(v3, this->m_pTargetVehicle, 0, 1);
  return result;
}

//----- (004F962A) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveBoat::CreateSubTask(const CTaskComplexLeaveBoat *this, const int iSubTaskType)
{
  CTask *result; // r0
  CTaskSimpleCarSetPedOut *v4; // r0

  if ( iSubTaskType != 816 )
    return 0;
  v4 = (CTaskSimpleCarSetPedOut *)CTask::operator new(0x18u);
  CTaskSimpleCarSetPedOut::CTaskSimpleCarSetPedOut(v4, this->m_pTargetVehicle, 0, 1);
  return result;
}

//----- (004F964C) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveBoat::ControlSubTask(CTaskComplexLeaveBoat *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (004F9650) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveCarAndDie::CreateFirstSubTask(CTaskComplexLeaveCarAndDie *this, CPed *pPed)
{
  CPed::SetPedState(pPed, PED_DIE);
  return CTaskComplexLeaveCar::CreateFirstSubTask(this, pPed);
}

//----- (004F966A) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveAnyCar::CreateNextSubTask(CTaskComplexLeaveAnyCar *this, CPed *pPed)
{
  return 0;
}

//----- (004F9670) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveAnyCar::CreateFirstSubTask(CTaskComplexLeaveAnyCar *this, CPed *pPed)
{
  CVehicle *m_pMyVehicle; // r0
  bool v5; // zf
  CTaskComplex *v6; // r0
  __int16 v7; // r8
  void *v8; // r4
  CVehicle *v9; // r5
  int m_iDelayTime; // r6

  m_pMyVehicle = pPed->m_pMyVehicle;
  v5 = m_pMyVehicle == 0;
  if ( m_pMyVehicle )
    v5 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
  if ( v5 )
  {
    v8 = CTask::operator new(8u);
    CTaskSimple::CTaskSimple((CTaskSimple *)v8);
    *(_DWORD *)v8 = &off_668FF0;
  }
  else
  {
    v6 = (CTaskComplex *)CTask::operator new(0x34u);
    v7 = *(_WORD *)&this->m_bSensibleLeaveCar;
    v8 = v6;
    v9 = pPed->m_pMyVehicle;
    m_iDelayTime = this->m_iDelayTime;
    CTaskComplex::CTaskComplex(v6);
    *((_DWORD *)v8 + 4) = 0;
    *((_DWORD *)v8 + 5) = m_iDelayTime;
    *((_WORD *)v8 + 12) = v7;
    *((_BYTE *)v8 + 26) = 0;
    *((_DWORD *)v8 + 7) = 0;
    *((_BYTE *)v8 + 32) = 0;
    *((_BYTE *)v8 + 33) = 0;
    *((_DWORD *)v8 + 9) = 15;
    *((_DWORD *)v8 + 10) = 1082130432;
    *((_DWORD *)v8 + 11) = 1065353216;
    *((_BYTE *)v8 + 48) = 0;
    *(_DWORD *)v8 = &off_66ABDC;
    *((_DWORD *)v8 + 3) = v9;
    if ( v9 )
      CEntity::RegisterReference(v9, (CEntity **)v8 + 3);
  }
  return (CTask *)v8;
}
// 668FF0: using guessed type void *off_668FF0;
// 66ABDC: using guessed type void *off_66ABDC;
// 678150: using guessed type void *`vtable for'CTaskSimpleNone;

//----- (004F9714) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveAnyCar::ControlSubTask(CTaskComplexLeaveAnyCar *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (004F9718) --------------------------------------------------------
void __fastcall CTaskComplexLeaveCarAndWander::CTaskComplexLeaveCarAndWander(
        CTaskComplexLeaveCarAndWander *this,
        CVehicle *pTargetVehicle,
        const int iTargetDoor,
        const int iDelayTime,
        const bool bSensibleLeaveCar)
{
  CTaskComplex::CTaskComplex(this);
  this->m_iTargetDoor = iTargetDoor;
  this->m_iDelayTime = iDelayTime;
  this->m_bSensibleLeaveCar = bSensibleLeaveCar;
  this->_vptr$CTask = (int (**)(void))&off_66AC54;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66AC54: using guessed type void *;

//----- (004F9760) --------------------------------------------------------
void __fastcall CTaskComplexLeaveCarAndWander::~CTaskComplexLeaveCarAndWander(CTaskComplexLeaveCarAndWander *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AC54;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  sub_18EDB4(this);
}
// 66AC54: using guessed type void *off_66AC54;

//----- (004F978C) --------------------------------------------------------
void __fastcall CTaskComplexLeaveCarAndWander::~CTaskComplexLeaveCarAndWander(CTaskComplexLeaveCarAndWander *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  void *v4; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AC54;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 4F97B4: variable 'v4' is possibly undefined
// 66AC54: using guessed type void *off_66AC54;

//----- (004F97BC) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveCarAndWander::CreateNextSubTask(CTaskComplexLeaveCarAndWander *this, CPed *pPed)
{
  int v3; // r0
  bool v4; // zf
  CPedIntelligence *m_pPedIntelligence; // r5
  CTask *v6; // r0
  CTaskComplexWander *WanderTaskByPedType; // r0

  v3 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  v4 = v3 == 704;
  if ( v3 != 704 )
    v4 = v3 == 200;
  if ( v4 )
  {
    m_pPedIntelligence = pPed->m_pPedIntelligence;
    v6 = m_pPedIntelligence->m_taskManager.m_tasks[4];
    if ( v6 )
    {
      if ( (*((int (__fastcall **)(CTask *))v6->_vptr$CTask + 5))(v6) == 912 )
        return 0;
      m_pPedIntelligence = pPed->m_pPedIntelligence;
    }
    WanderTaskByPedType = CTaskComplexWander::GetWanderTaskByPedType(pPed);
    CTaskManager::SetTask(&m_pPedIntelligence->m_taskManager, WanderTaskByPedType, 4, 0);
  }
  return 0;
}

//----- (004F9804) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveCarAndWander::CreateSubTask(
        const CTaskComplexLeaveCarAndWander *this,
        const int iSubTaskType)
{
  char *v3; // r4
  CVehicle *m_pTargetVehicle; // r5
  __int64 v5; // r8
  bool m_bSensibleLeaveCar; // r6

  if ( iSubTaskType == 200 )
  {
    v3 = (char *)CTask::operator new(8u);
    CTaskSimple::CTaskSimple((CTaskSimple *)v3);
    *(_DWORD *)v3 = &off_668FF0;
  }
  else if ( iSubTaskType == 704 )
  {
    v3 = (char *)CTask::operator new(0x34u);
    m_pTargetVehicle = this->m_pTargetVehicle;
    v5 = *(_QWORD *)&this->m_iTargetDoor;
    m_bSensibleLeaveCar = this->m_bSensibleLeaveCar;
    CTaskComplex::CTaskComplex((CTaskComplex *)v3);
    *((_QWORD *)v3 + 2) = v5;
    v3[24] = m_bSensibleLeaveCar;
    *(_WORD *)(v3 + 25) = 0;
    *((_DWORD *)v3 + 7) = 0;
    *((_WORD *)v3 + 16) = 0;
    *((_DWORD *)v3 + 9) = 15;
    *((_DWORD *)v3 + 10) = 1082130432;
    *((_DWORD *)v3 + 11) = 1065353216;
    v3[48] = 0;
    *(_DWORD *)v3 = &off_66ABDC;
    *((_DWORD *)v3 + 3) = m_pTargetVehicle;
    if ( m_pTargetVehicle )
      CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v3 + 3);
  }
  else
  {
    return 0;
  }
  return (CTask *)v3;
}
// 668FF0: using guessed type void *off_668FF0;
// 66ABDC: using guessed type void *off_66ABDC;
// 678150: using guessed type void *`vtable for'CTaskSimpleNone;

//----- (004F989C) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveCarAndWander::CreateFirstSubTask(CTaskComplexLeaveCarAndWander *this, CPed *pPed)
{
  int m_nPedFlags; // r2
  int v3; // r1

  m_nPedFlags = (int)pPed->m_nPedFlags;
  v3 = 704;
  if ( (m_nPedFlags & 0x100) == 0 )
    v3 = 200;
  return CTaskComplexLeaveCarAndWander::CreateSubTask(this, v3);
}

//----- (004F98AE) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveCarAndWander::ControlSubTask(CTaskComplexLeaveCarAndWander *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (004F98B4) --------------------------------------------------------
void __fastcall CTaskComplexLeaveCarAndFlee::CTaskComplexLeaveCarAndFlee(
        CTaskComplexLeaveCarAndFlee *this,
        CVehicle *pTargetVehicle,
        const CVector *vFleePoint,
        const int iTargetDoor,
        const int iDelayTime,
        bool bWaitUntilSlowedDown)
{
  __int64 v10; // d16

  CTaskComplex::CTaskComplex(this);
  this->m_iTargetDoor = iTargetDoor;
  this->_vptr$CTask = (int (**)(void))&off_66AC90;
  this->m_pTargetVehicle = pTargetVehicle;
  v10 = *(_QWORD *)&vFleePoint->x;
  this->m_vFleePoint.z = vFleePoint->z;
  this->m_iDelayTime = iDelayTime;
  this->m_bWaitUntilCarHasSlowedDown = bWaitUntilSlowedDown;
  *(_QWORD *)&this->m_vFleePoint.x = v10;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66AC90: using guessed type void *;

//----- (004F990C) --------------------------------------------------------
void __fastcall CTaskComplexLeaveCarAndFlee::~CTaskComplexLeaveCarAndFlee(CTaskComplexLeaveCarAndFlee *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AC90;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  sub_18EDB4(this);
}
// 66AC90: using guessed type void *off_66AC90;

//----- (004F9938) --------------------------------------------------------
void __fastcall CTaskComplexLeaveCarAndFlee::~CTaskComplexLeaveCarAndFlee(CTaskComplexLeaveCarAndFlee *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  void *v4; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AC90;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 4F9960: variable 'v4' is possibly undefined
// 66AC90: using guessed type void *off_66AC90;

//----- (004F9968) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveCarAndFlee::CreateNextSubTask(CTaskComplexLeaveCarAndFlee *this, CPed *pPed)
{
  int v4; // r0
  CVehicle *m_pMyVehicle; // r0
  float *p_xx; // r1
  float v7; // s0
  float *p_x; // r2
  float v9; // s6
  float v10; // s4
  CTaskComplexSmartFleePoint *v11; // r4
  CPedIntelligence *m_pPedIntelligence; // r5
  CTaskComplexWander *WanderTaskByPedType; // r0
  _BOOL4 m_bWaitUntilCarHasSlowedDown; // r6
  _BOOL4 v15; // r6
  CVehicle *m_pTargetVehicle; // r2
  CMatrix *m_pMat; // r6
  CVector *p_tx; // r1

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v4 == 910 )
  {
    m_pPedIntelligence = pPed->m_pPedIntelligence;
    WanderTaskByPedType = CTaskComplexWander::GetWanderTaskByPedType(pPed);
    v11 = 0;
    CTaskManager::SetTask(&m_pPedIntelligence->m_taskManager, WanderTaskByPedType, 4, 0);
    return v11;
  }
  if ( v4 == 900 )
  {
    m_bWaitUntilCarHasSlowedDown = this->m_bWaitUntilCarHasSlowedDown;
    v11 = (CTaskComplexSmartFleePoint *)CTask::operator new(0x44u);
    if ( m_bWaitUntilCarHasSlowedDown )
    {
LABEL_14:
      m_pTargetVehicle = this->m_pTargetVehicle;
      m_pMat = m_pTargetVehicle->m_pMat;
      p_tx = (CVector *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &m_pTargetVehicle->m_transform.m_translate;
      goto LABEL_18;
    }
LABEL_17:
    p_tx = &this->m_vFleePoint;
LABEL_18:
    CTaskComplexSmartFleePoint::CTaskComplexSmartFleePoint(
      v11,
      p_tx,
      0,
      60.0,
      (const int)"ist_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly");
    return v11;
  }
  if ( v4 != 704 )
    return 0;
  m_pMyVehicle = pPed->m_pMyVehicle;
  if ( !m_pMyVehicle || m_pMyVehicle->m_baseVehicleType != 5 )
  {
    v15 = this->m_bWaitUntilCarHasSlowedDown;
    v11 = (CTaskComplexSmartFleePoint *)CTask::operator new(0x44u);
    if ( v15 )
      goto LABEL_14;
    goto LABEL_17;
  }
  p_xx = &m_pMyVehicle->m_pMat->xx;
  v7 = CModelInfo::ms_modelInfoPtrs[m_pMyVehicle->m_nModelIndex]->m_pColModel->m_sphereBound.m_fRadius * -2.0;
  p_x = p_xx + 12;
  v9 = p_xx[6];
  if ( !p_xx )
    p_x = &m_pMyVehicle->m_transform.m_translate.x;
  v10 = p_xx[5] * v7;
  this->m_vFleePoint.x = (float)(p_xx[4] * v7) + *p_x;
  this->m_vFleePoint.y = v10 + p_x[1];
  this->m_vFleePoint.z = (float)(v9 * v7) + p_x[2];
  v11 = (CTaskComplexSmartFleePoint *)CTask::operator new(0x2Cu);
  CTaskSimpleGoToPoint::CTaskSimpleGoToPoint((CTaskSimpleGoToPoint *)v11, 6, &this->m_vFleePoint, 0.5, 0, 0);
  return v11;
}

//----- (004F9AEC) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveCarAndFlee::CreateSubTask(
        const CTaskComplexLeaveCarAndFlee *this,
        const int iSubTaskType)
{
  CTaskComplex *v3; // r0
  CVehicle *v4; // r6
  __int64 v5; // r8
  char *v6; // r4
  bool v7; // r5
  _BOOL4 m_bWaitUntilCarHasSlowedDown; // r6
  CVehicle *m_pTargetVehicle; // r2
  CMatrix *m_pMat; // r6
  CVector *p_tx; // r1

  switch ( iSubTaskType )
  {
    case 910:
      m_bWaitUntilCarHasSlowedDown = this->m_bWaitUntilCarHasSlowedDown;
      v6 = (char *)CTask::operator new(0x44u);
      if ( m_bWaitUntilCarHasSlowedDown )
      {
        m_pTargetVehicle = this->m_pTargetVehicle;
        m_pMat = m_pTargetVehicle->m_pMat;
        p_tx = (CVector *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &m_pTargetVehicle->m_transform.m_translate;
      }
      else
      {
        p_tx = &this->m_vFleePoint;
      }
      CTaskComplexSmartFleePoint::CTaskComplexSmartFleePoint(
        (CTaskComplexSmartFleePoint *)v6,
        p_tx,
        0,
        60.0,
        (const int)"ist_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly");
      break;
    case 900:
      v6 = (char *)CTask::operator new(0x2Cu);
      CTaskSimpleGoToPoint::CTaskSimpleGoToPoint((CTaskSimpleGoToPoint *)v6, 6, &this->m_vFleePoint, 0.5, 0, 0);
      break;
    case 704:
      v3 = (CTaskComplex *)CTask::operator new(0x34u);
      LODWORD(v5) = this->m_iTargetDoor;
      v4 = this->m_pTargetVehicle;
      v6 = (char *)v3;
      HIDWORD(v5) = this->m_iDelayTime;
      v7 = this->m_bWaitUntilCarHasSlowedDown;
      CTaskComplex::CTaskComplex(v3);
      *((_QWORD *)v6 + 2) = v5;
      v6[24] = v7;
      *(_WORD *)(v6 + 25) = 1;
      *((_DWORD *)v6 + 7) = 0;
      *((_WORD *)v6 + 16) = 0;
      *((_DWORD *)v6 + 9) = 15;
      *((_DWORD *)v6 + 10) = 1082130432;
      *((_DWORD *)v6 + 11) = 1065353216;
      v6[48] = 0;
      *(_DWORD *)v6 = &off_66ABDC;
      *((_DWORD *)v6 + 3) = v4;
      if ( v4 )
        CEntity::RegisterReference(v4, (CEntity **)v6 + 3);
      break;
    default:
      return 0;
  }
  return (CTask *)v6;
}
// 66ABDC: using guessed type void *off_66ABDC;

//----- (004F9C00) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveCarAndFlee::CreateFirstSubTask(CTaskComplexLeaveCarAndFlee *this, CPed *pPed)
{
  int m_nPedFlags; // r2
  int v3; // r1

  m_nPedFlags = (int)pPed->m_nPedFlags;
  v3 = 704;
  if ( (m_nPedFlags & 0x100) == 0 )
    v3 = 910;
  return CTaskComplexLeaveCarAndFlee::CreateSubTask(this, v3);
}

//----- (004F9C14) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveCarAndFlee::ControlSubTask(CTaskComplexLeaveCarAndFlee *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (004F9C18) --------------------------------------------------------
void __fastcall CTaskComplexScreamInCarThenLeave::CTaskComplexScreamInCarThenLeave(
        CTaskComplexScreamInCarThenLeave *this,
        CVehicle *pTargetVehicle,
        const int iTargetDoor)
{
  CTaskComplex::CTaskComplex(this);
  this->m_iTargetDoor = iTargetDoor;
  *(_WORD *)&this->m_timer.m_bIsActive = 0;
  this->m_timer.m_iStartTime = 0;
  this->m_timer.m_iDuration = 0;
  this->_vptr$CTask = (int (**)(void))&off_66ACCC;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66ACCC: using guessed type void *;

//----- (004F9C5C) --------------------------------------------------------
void __fastcall CTaskComplexScreamInCarThenLeave::~CTaskComplexScreamInCarThenLeave(
        CTaskComplexScreamInCarThenLeave *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66ACCC;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  sub_18EDB4(this);
}
// 66ACCC: using guessed type void *off_66ACCC;

//----- (004F9C88) --------------------------------------------------------
void __fastcall CTaskComplexScreamInCarThenLeave::~CTaskComplexScreamInCarThenLeave(
        CTaskComplexScreamInCarThenLeave *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  void *v4; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66ACCC;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 4F9CB0: variable 'v4' is possibly undefined
// 66ACCC: using guessed type void *off_66ACCC;

//----- (004F9CB8) --------------------------------------------------------
bool __fastcall CTaskComplexScreamInCarThenLeave::MakeAbortable(
        CTaskComplexScreamInCarThenLeave *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  if ( iPriority == 2 )
    return (*((int (__fastcall **)(CTask *, CPed *, int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
             this->m_pSubTask,
             pPed,
             2,
             pEvent);
  else
    return 0;
}

//----- (004F9CCC) --------------------------------------------------------
CTask *__fastcall CTaskComplexScreamInCarThenLeave::CreateNextSubTask(
        CTaskComplexScreamInCarThenLeave *this,
        CPed *pPed)
{
  int v4; // r0
  int v6; // r1

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v4 == 706 )
  {
    v6 = 1302;
  }
  else
  {
    if ( v4 != 709 )
      return 0;
    v6 = 706;
  }
  return CTaskComplexScreamInCarThenLeave::CreateSubTask(this, v6, pPed);
}

//----- (004F9D04) --------------------------------------------------------
CTask *__fastcall CTaskComplexScreamInCarThenLeave::CreateSubTask(
        CTaskComplexScreamInCarThenLeave *this,
        const int iSubTaskType,
        CPed *pPed)
{
  __int64 v4; // r0
  char *v5; // r4
  CVehicle *v6; // r5
  char v7; // r0
  char v8; // r0
  CTaskComplex *v9; // r0
  CVehicle *m_pTargetVehicle; // r5
  CMatrix *m_pMat; // r6
  CSimpleTransform *p_tx; // r2
  CEntity **v13; // r1
  __int64 v14; // d16
  CPedIntelligence *m_pPedIntelligence; // r4
  CTaskComplexWander *WanderTaskByPedType; // r1
  CTaskManager *p_m_taskManager; // r0
  __int16 v18; // r8
  CTaskComplex *v19; // r0
  CMatrix *v20; // r6
  CSimpleTransform *p_m_transform; // r2
  unsigned int v22; // r8
  char v23; // r0
  __int64 v24; // d16

  switch ( iSubTaskType )
  {
    case 706:
      if ( CTheScripts::IsPlayerOnAMission() )
      {
        v9 = (CTaskComplex *)CTask::operator new(0x28u);
        m_pTargetVehicle = this->m_pTargetVehicle;
        v5 = (char *)v9;
        m_pMat = m_pTargetVehicle->m_pMat;
        CTaskComplex::CTaskComplex(v9);
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        *(_DWORD *)v5 = &off_66AC90;
        *((_DWORD *)v5 + 4) = 0;
        if ( !m_pMat )
          p_tx = &m_pTargetVehicle->m_transform;
        *((_DWORD *)v5 + 3) = m_pTargetVehicle;
        v13 = (CEntity **)(v5 + 12);
        v14 = *(_QWORD *)&p_tx->m_translate.x;
        *((_DWORD *)v5 + 7) = LODWORD(p_tx->m_translate.z);
        *((_DWORD *)v5 + 8) = 0;
        v5[36] = 0;
        *(_QWORD *)(v5 + 20) = v14;
      }
      else
      {
        v18 = rand();
        v19 = (CTaskComplex *)CTask::operator new(0x28u);
        m_pTargetVehicle = this->m_pTargetVehicle;
        v5 = (char *)v19;
        v20 = m_pTargetVehicle->m_pMat;
        CTaskComplex::CTaskComplex(v19);
        p_m_transform = (CSimpleTransform *)&v20->tx;
        v22 = v18 & 0x3FF;
        v23 = 0;
        *((_DWORD *)v5 + 4) = 0;
        *(_DWORD *)v5 = &off_66AC90;
        if ( !v20 )
          p_m_transform = &m_pTargetVehicle->m_transform;
        *((_DWORD *)v5 + 3) = m_pTargetVehicle;
        v13 = (CEntity **)(v5 + 12);
        v24 = *(_QWORD *)&p_m_transform->m_translate.x;
        *((_DWORD *)v5 + 7) = LODWORD(p_m_transform->m_translate.z);
        *((_DWORD *)v5 + 8) = 0;
        *(_QWORD *)(v5 + 20) = v24;
        if ( v22 <= 0x200 )
          v23 = 1;
        v5[36] = v23;
      }
      if ( m_pTargetVehicle )
        CEntity::RegisterReference(m_pTargetVehicle, v13);
      break;
    case 1302:
      m_pPedIntelligence = pPed->m_pPedIntelligence;
      WanderTaskByPedType = CTaskComplexWander::GetWanderTaskByPedType(pPed);
      p_m_taskManager = &m_pPedIntelligence->m_taskManager;
      v5 = 0;
      CTaskManager::SetTask(p_m_taskManager, WanderTaskByPedType, 4, 0);
      break;
    case 709:
      v4 = CTimer::m_snTimeInMilliseconds | 0x138800000000LL;
      this->m_timer.m_bIsActive = 1;
      *(_QWORD *)&this->m_timer.m_iStartTime = v4;
      v5 = (char *)CTask::operator new(0x60u);
      v6 = this->m_pTargetVehicle;
      CTaskSimple::CTaskSimple((CTaskSimple *)v5);
      *(_QWORD *)(v5 + 12) = 0LL;
      *(_QWORD *)(v5 + 20) = 0LL;
      *(_DWORD *)v5 = &off_66AD08;
      *((_WORD *)v5 + 14) = 0;
      *(_DWORD *)(v5 + 86) = 0;
      *(_DWORD *)(v5 + 82) = 0;
      v7 = v5[92];
      *((_DWORD *)v5 + 19) = 0;
      *((_DWORD *)v5 + 20) = 0;
      v8 = v7 & 0xC3 | 8;
      v5[92] = v8;
      *((_DWORD *)v5 + 2) = v6;
      if ( v6 )
      {
        CEntity::RegisterReference(v6, (CEntity **)v5 + 2);
        v8 = v5[92];
      }
      *((_DWORD *)v5 + 8) = -1;
      v5[92] = v8 & 0xFC;
      *((_DWORD *)v5 + 15) = 0;
      *((_DWORD *)v5 + 16) = 0;
      *((_DWORD *)v5 + 17) = 0;
      break;
    default:
      return 0;
  }
  return (CTask *)v5;
}
// 66AC90: using guessed type void *off_66AC90;
// 66AD08: using guessed type void *off_66AD08;

//----- (004F9E8C) --------------------------------------------------------
CTask *__fastcall CTaskComplexScreamInCarThenLeave::CreateFirstSubTask(
        CTaskComplexScreamInCarThenLeave *this,
        CPed *pPed)
{
  _BOOL4 IsPlayerOnAMission; // r0
  int v5; // r1

  IsPlayerOnAMission = CTheScripts::IsPlayerOnAMission();
  v5 = 706;
  if ( !IsPlayerOnAMission )
    v5 = 709;
  return CTaskComplexScreamInCarThenLeave::CreateSubTask(this, v5, pPed);
}

//----- (004F9EB0) --------------------------------------------------------
CTask *__fastcall CTaskComplexScreamInCarThenLeave::ControlSubTask(CTaskComplexScreamInCarThenLeave *this, CPed *pPed)
{
  unsigned int v4; // r0
  int m_iStartTime; // r1
  CVehicle *m_pTargetVehicle; // r0
  int v8; // r0
  CTask *m_pSubTask; // r5

  if ( this->m_timer.m_bIsActive
    && (!this->m_timer.m_bIsStopped ? (m_iStartTime = this->m_timer.m_iStartTime, v4 = CTimer::m_snTimeInMilliseconds) : (v4 = CTimer::m_snTimeInMilliseconds, this->m_timer.m_bIsStopped = 0, this->m_timer.m_iStartTime = v4, m_iStartTime = v4),
        m_iStartTime + this->m_timer.m_iDuration <= v4
     && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 709
     && (m_pTargetVehicle = this->m_pTargetVehicle) != 0) )
  {
    if ( !m_pTargetVehicle->pDriver
      || (*((int (__fastcall **)(CVehicle *, _DWORD))m_pTargetVehicle->_vptr$CPlaceable + 58))(m_pTargetVehicle, 0)
      || (*((int (__fastcall **)(CVehicle *, CPed *))this->m_pTargetVehicle->_vptr$CPlaceable + 59))(
           this->m_pTargetVehicle,
           pPed) == 1 )
    {
      return CTaskComplexScreamInCarThenLeave::CreateSubTask(this, 706, pPed);
    }
    m_pSubTask = this->m_pSubTask;
    CPed::Say(pPed, 0x15Bu, 0, 1.0, 0, 0, 0);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
    m_pSubTask = this->m_pSubTask;
    if ( v8 == 709 )
      CPed::Say(pPed, 0xE3u, 0, 1.0, 0, 0, 0);
  }
  return m_pSubTask;
}

//----- (004F9F70) --------------------------------------------------------
void __fastcall CTaskSimpleCarDrive::CTaskSimpleCarDrive(
        CTaskSimpleCarDrive *this,
        CVehicle *pTargetVehicle,
        CTaskUtilityLineUpPedWithCar *pUtility,
        const bool bDriveAnyCar)
{
  char v8; // r2
  CTaskUtilityLineUpPedWithCar *v9; // r0
  CTaskUtilityLineUpPedWithCar *v10; // r0
  char v11; // r0
  CVector vInitialBlendVector; // [sp+4h] [bp-1Ch] BYREF

  CTaskSimple::CTaskSimple(this);
  *(_WORD *)&this->m_passengerTimer.m_bIsActive = 0;
  *(int *)((char *)&this->m_broadcastStolenCarTimer.m_iDuration + 2) = 0;
  this->m_broadcastStolenCarTimer.m_iStartTime = 0;
  v8 = *((_BYTE *)this + 92);
  *(_QWORD *)&this->m_pAnimCloseDoor = 0LL;
  *(_QWORD *)&this->m_passengerTimer.m_iStartTime = 0LL;
  *(int *)((char *)&this->m_broadcastStolenCarTimer.m_iStartTime + 2) = 0;
  this->m_nUpsideDownCounter = 0;
  this->_vptr$CTask = (int (**)(void))&off_66AD08;
  *((_BYTE *)this + 92) = v8 & 0xC3 | (4 * bDriveAnyCar) | 8;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
  if ( pUtility )
  {
    v9 = (CTaskUtilityLineUpPedWithCar *)operator new(0x1Cu);
    memset(&vInitialBlendVector, 0, sizeof(vInitialBlendVector));
    CTaskUtilityLineUpPedWithCar::CTaskUtilityLineUpPedWithCar(
      v9,
      &vInitialBlendVector,
      0,
      pUtility->m_nZFlag,
      pUtility->m_iTargetDoor);
    this->m_pUtility = v10;
  }
  this->m_bopStartTime = -1;
  v11 = *((_BYTE *)this + 92);
  this->m_currHeadBop = 0.0;
  this->m_headBopDepth = 0.0;
  this->m_headBopBlend = 0.0;
  *((_BYTE *)this + 92) = v11 & 0xFC;
}
// 4F9FF0: variable 'v10' is possibly undefined
// 66AD08: using guessed type void *;

//----- (004FA01C) --------------------------------------------------------
void __fastcall CTaskSimpleCarDrive::~CTaskSimpleCarDrive(CTaskSimpleCarDrive *this)
{
  void *v1; // r0

  CTaskSimpleCarSetTempAction::~CTaskSimpleCarSetTempAction(this);
  sub_197118(v1);
}
// 4FA028: variable 'v1' is possibly undefined

//----- (004FA02C) --------------------------------------------------------
void __fastcall CTaskSimpleCarDrive::TriggerIK(CTaskSimpleCarDrive *this, CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r0
  int Mission; // r0
  CPlayerPed *pTargetEntity; // r3
  CEntity *y_low; // r5
  int32 v8; // [sp+4h] [bp-2Ch]

  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( m_pTargetVehicle )
  {
    Mission = (unsigned __int8)m_pTargetVehicle->AutoPilot.Mission;
    if ( (unsigned int)(Mission - 2) >= 5 )
    {
      if ( (unsigned int)(Mission - 15) < 2
        && !IKChainManager_c::IsLooking(&g_ikChainMan, pPed)
        && (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) <= 4 )
      {
        pTargetEntity = (CPlayerPed *)this->m_pTargetVehicle->AutoPilot.pTargetEntity;
        if ( pTargetEntity )
        {
          if ( (*(_BYTE *)&pTargetEntity->m_info & 7) == 2 )
          {
            y_low = (CEntity *)LODWORD(pTargetEntity->m_storedCollPoly.V2.y);
            if ( !y_low )
            {
              v8 = -1;
              goto LABEL_6;
            }
            IKChainManager_c::LookAt(&g_ikChainMan, "DriveCar", pPed, y_low, 3000, 5, 0, 0, 0.25, 500, 3, 0);
          }
        }
      }
    }
    else if ( !IKChainManager_c::IsLooking(&g_ikChainMan, pPed)
           && (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) <= 4 )
    {
      pTargetEntity = FindPlayerPed(0);
      v8 = 5;
LABEL_6:
      IKChainManager_c::LookAt(&g_ikChainMan, "DriveCar", pPed, pTargetEntity, 3000, v8, 0, 0, 0.25, 500, 3, 0);
    }
  }
}

//----- (004FA1B4) --------------------------------------------------------
void __fastcall CTaskSimpleCarDrive::AbortIK(CTaskSimpleCarDrive *this, CPed *pPed)
{
  if ( IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
    sub_1A0E80(&g_ikChainMan, pPed, 250);
}

//----- (004FA1E4) --------------------------------------------------------
bool __fastcall CTaskSimpleCarDrive::MakeAbortable(
        CTaskSimpleCarDrive *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  bool v7; // zf
  CVehicle *m_pMyVehicle; // r0
  int v9; // r0
  char v11; // r1
  CTaskSimpleCarSetPedOut v12; // [sp+0h] [bp-28h] BYREF

  if ( iPriority == 2 )
  {
    m_pMyVehicle = (CVehicle *)(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31);
    v7 = m_pMyVehicle == 0;
    if ( m_pMyVehicle )
    {
      m_pMyVehicle = pPed->m_pMyVehicle;
      v7 = m_pMyVehicle == 0;
    }
    if ( !v7 )
    {
      v9 = CCarEnterExit::ComputeTargetDoorToExit(m_pMyVehicle, pPed);
      CTaskSimpleCarSetPedOut::CTaskSimpleCarSetPedOut(&v12, this->m_pTargetVehicle, v9, 0);
      if ( pEvent && pPed->m_pMyVehicle->m_baseVehicleType == 9 )
        v12.m_bFallingOutOfCar = 1;
      CTaskSimpleCarSetPedOut::ProcessPed(&v12, pPed);
      CTaskSimpleCarSetPedOut::~CTaskSimpleCarSetPedOut(&v12);
    }
    if ( IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
      IKChainManager_c::AbortLookAt(&g_ikChainMan, pPed, 250);
    return 1;
  }
  else
  {
    v11 = *((_BYTE *)this + 92);
    *((_BYTE *)this + 92) = v11 | 8;
    return (v11 & 0x20) == 0;
  }
}

//----- (004FA284) --------------------------------------------------------
bool __fastcall CTaskSimpleCarDrive::ProcessPed(CTaskSimpleCarDrive *this, CPed *pPed)
{
  CEntity **p_m_pTargetVehicle; // r6
  CVehicle *m_pTargetVehicle; // r1
  int HasRadioRetuneJustStarted; // r9
  CVehicle *m_pMyVehicle; // r0
  bool v8; // zf
  int v9; // r0
  int v10; // r1
  int v11; // r2
  CVehicle *v12; // r6
  bool v13; // zf
  bool v14; // r6
  CPedGroup *PedsGroup; // r6
  uint32 v17; // r0
  __int64 v18; // r0
  CEventGlobalGroup *EventGlobalGroup; // r0
  CVehicle *v20; // r0
  int32 m_baseVehicleType; // r1
  bool v22; // zf
  _BOOL4 IsPlayer; // r1
  CVehicle *v24; // r0
  bool v25; // zf
  CPed *pDriver; // r2
  CPad *PadFromPlayer; // r8
  bool v28; // zf
  CTaskSimpleGangDriveBy *v29; // r6
  CVehicle *v30; // r0
  CAnimBlendAssociation *Association; // r6
  CVehicle *v32; // r0
  bool v33; // zf
  int Group; // r0
  CTaskSimpleCarDrive *v35; // r0
  CPed *v36; // r1
  bool8 v37; // r2
  RpClump_0 *m_pRwObject; // r6
  AssocGroupId *v39; // r0
  bool v40; // r5
  CTaskSimpleGangDriveBy *v41; // r6
  CEntity *EntityThatThisPedIsHolding; // r0
  CTaskSimpleHoldEntity *ActiveTaskByType; // r6
  AnimationId v44; // r1
  CVehicle *v45; // r0
  CPed *v46; // r1
  bool v47; // zf
  CPed *v49; // r0
  bool v50; // zf
  CVehicle *v51; // r0
  float x; // s0
  float y; // s2
  CVehicle *v54; // r0
  int v55; // r0
  unsigned int v56; // r0
  int m_iStartTime; // r1
  CTaskComplexSequence *v58; // r8
  void *v59; // r6
  CVehicle *v60; // r9
  void *v61; // r6
  CVehicle *v62; // r9
  int v63; // r0
  CAnimBlendAssociation *v64; // r0
  CEventScriptCommand v65[2]; // [sp+Ch] [bp-34h] BYREF

  HasRadioRetuneJustStarted = CAudioEngine::HasRadioRetuneJustStarted(&AudioEngine);
  if ( (*((_BYTE *)this + 92) & 4) != 0 && *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
  {
    m_pMyVehicle = pPed->m_pMyVehicle;
    v8 = m_pMyVehicle == 0;
    if ( m_pMyVehicle )
    {
      p_m_pTargetVehicle = &this->m_pTargetVehicle;
      m_pTargetVehicle = this->m_pTargetVehicle;
      v8 = m_pMyVehicle == m_pTargetVehicle;
    }
    if ( !v8 )
    {
      if ( m_pTargetVehicle )
      {
        CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
        m_pMyVehicle = pPed->m_pMyVehicle;
        *p_m_pTargetVehicle = m_pMyVehicle;
        if ( !m_pMyVehicle )
          goto LABEL_11;
      }
      else
      {
        *p_m_pTargetVehicle = m_pMyVehicle;
      }
      CEntity::RegisterReference(m_pMyVehicle, p_m_pTargetVehicle);
    }
  }
LABEL_11:
  v9 = *((_DWORD *)&pPed->m_nPedFlags + 1);
  v10 = *((_DWORD *)&pPed->m_nPedFlags + 2);
  v11 = *((_DWORD *)&pPed->m_nPedFlags + 3);
  v12 = this->m_pTargetVehicle;
  v13 = v12 == 0;
  if ( v12 )
    v13 = (*(_DWORD *)&pPed->m_nPedFlags & 0x100) == 0;
  if ( v13 )
  {
    *(_DWORD *)&pPed->m_nPedFlags &= ~0x100u;
    *((_DWORD *)&pPed->m_nPedFlags + 1) = v9;
    *((_DWORD *)&pPed->m_nPedFlags + 2) = v10;
    *((_DWORD *)&pPed->m_nPedFlags + 3) = v11;
    if ( IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
      IKChainManager_c::AbortLookAt(&g_ikChainMan, pPed, 250);
    return 1;
  }
  PedsGroup = CPedGroups::GetPedsGroup(pPed);
  if ( CUpsideDownCarCheck::IsCarUpsideDown(&CTheScripts::UpsideDownCars, this->m_pTargetVehicle) )
  {
    if ( FindPlayerPed(-1) != pPed
      && *((unsigned __int8 *)&FindPlayerPed(-1)->m_nPedFlags + 1) << 31
      && FindPlayerPed(-1)->m_pMyVehicle == this->m_pTargetVehicle )
    {
      CPed::Say(pPed, 0x22u, 0, 1.0, 0, 0, 0);
    }
    if ( !PedsGroup || CPedGroupMembership::IsLeader(&PedsGroup->m_membership, pPed) )
    {
      v17 = this->m_nUpsideDownCounter + (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
      this->m_nUpsideDownCounter = v17;
      if ( v17 > 0x7D0 )
      {
        CEventCarUpsideDown::CEventCarUpsideDown((CEventCarUpsideDown *)v65, this->m_pTargetVehicle);
        CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, v65, 0);
        CEventCarUpsideDown::~CEventCarUpsideDown((CEventCarUpsideDown *)v65);
      }
    }
  }
  else
  {
    this->m_nUpsideDownCounter = 0;
  }
  if ( CPed::IsPlayer(pPed) && CVehicle::IsLawEnforcementVehicle(this->m_pTargetVehicle) )
  {
    if ( !this->m_broadcastStolenCarTimer.m_bIsActive )
    {
      LODWORD(v18) = CTimer::m_snTimeInMilliseconds;
LABEL_37:
      HIDWORD(v18) = 2000;
      *(_QWORD *)&this->m_broadcastStolenCarTimer.m_iStartTime = v18;
      this->m_broadcastStolenCarTimer.m_bIsActive = 1;
      CEventCopCarBeingStolen::CEventCopCarBeingStolen((CEventCopCarBeingStolen *)v65, pPed, this->m_pTargetVehicle);
      EventGlobalGroup = GetEventGlobalGroup();
      CEventGroup::Add(EventGlobalGroup, v65, 0);
      CEventCopCarBeingStolen::~CEventCopCarBeingStolen((CEventCopCarBeingStolen *)v65);
      goto LABEL_38;
    }
    if ( this->m_broadcastStolenCarTimer.m_bIsStopped )
    {
      LODWORD(v18) = CTimer::m_snTimeInMilliseconds;
      this->m_broadcastStolenCarTimer.m_bIsStopped = 0;
      this->m_broadcastStolenCarTimer.m_iStartTime = v18;
      HIDWORD(v18) = v18;
    }
    else
    {
      HIDWORD(v18) = this->m_broadcastStolenCarTimer.m_iStartTime;
      LODWORD(v18) = CTimer::m_snTimeInMilliseconds;
    }
    if ( HIDWORD(v18) + this->m_broadcastStolenCarTimer.m_iDuration <= (unsigned int)v18 )
      goto LABEL_37;
  }
LABEL_38:
  v20 = this->m_pTargetVehicle;
  m_baseVehicleType = v20->m_baseVehicleType;
  v22 = m_baseVehicleType == 9;
  if ( m_baseVehicleType != 9 )
    v22 = v20->m_vehicleType == 2;
  if ( v22 || v20->m_nModelIndex == 531 )
    *((_DWORD *)&pPed->m_nPedFlags + 3) |= 0x100000u;
  IsPlayer = CPed::IsPlayer(pPed);
  v24 = this->m_pTargetVehicle;
  v25 = IsPlayer;
  pDriver = v24->pDriver;
  if ( IsPlayer )
    v25 = pDriver == pPed;
  if ( !v25 )
  {
    if ( pDriver != pPed )
    {
      if ( CVehicle::IsPassenger(v24, pPed) )
      {
        if ( (*((_BYTE *)this + 92) & 0x18) == 0 )
        {
          if ( (*((int (__fastcall **)(CVehicle *))this->m_pTargetVehicle->_vptr$CPlaceable + 48))(this->m_pTargetVehicle) )
          {
            m_pRwObject = (RpClump_0 *)pPed->m_pRwObject;
            v39 = (AssocGroupId *)(*((int (__fastcall **)(CVehicle *))this->m_pTargetVehicle->_vptr$CPlaceable + 48))(this->m_pTargetVehicle);
            CAnimManager::BlendAnimation(m_pRwObject, *v39, ANIM_BIKE_RIDE_P, 8.0);
          }
          *((_BYTE *)this + 92) |= 0x10u;
        }
        CTaskSimpleCarDrive::ProcessBopping(this, pPed, 1u);
        if ( CPed::IsPlayer(pPed)
          && CGameLogic::IsCoopGameGoingOn() == 1
          && pPed->m_WeaponSlots[4].m_eWeaponType
          && pPed->m_WeaponSlots[4].m_nAmmoTotal >= 1
          && CVehicle::CanPedLeanOut(this->m_pTargetVehicle, pPed)
          && TheCamera.Cams[TheCamera.ActiveCam].Mode == 49 )
        {
          v40 = this->m_pTargetVehicle->pPassengers[1] != pPed;
          v41 = (CTaskSimpleGangDriveBy *)CTask::operator new(0x44u);
          CTaskSimpleGangDriveBy::CTaskSimpleGangDriveBy(v41, 0, 0, 100.0, 100, 8, v40);
          CEventScriptCommand::CEventScriptCommand(v65, 3, v41, 0);
          CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, v65, 0);
          CEventScriptCommand::~CEventScriptCommand(v65);
        }
      }
      goto LABEL_88;
    }
    goto LABEL_86;
  }
  PadFromPlayer = CPlayerPed::GetPadFromPlayer((CPlayerPed *)pPed);
  v28 = CCheat::m_aCheatsActive[81] == 0;
  if ( CCheat::m_aCheatsActive[81] )
    v28 = pPed->m_WeaponSlots[4].m_eWeaponType == WEAPONTYPE_UNARMED;
  if ( !v28 && pPed->m_WeaponSlots[4].m_nAmmoTotal >= 1 && CVehicle::CanPedLeanOut(this->m_pTargetVehicle, pPed) )
  {
    v29 = (CTaskSimpleGangDriveBy *)CTask::operator new(0x44u);
    CTaskSimpleGangDriveBy::CTaskSimpleGangDriveBy(v29, 0, 0, 100.0, 100, 8, 0);
    CEventScriptCommand::CEventScriptCommand(v65, 3, v29, 0);
    CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, v65, 0);
    CEventScriptCommand::~CEventScriptCommand(v65);
  }
  v30 = pPed->m_pMyVehicle;
  if ( v30->m_nModelIndex == 570 || v30->m_baseVehicleType != 6 )
  {
LABEL_57:
    if ( v30->m_baseVehicleType
      || CDamageManager::GetDoorStatus((const CDamageManager *)&v30[1], FRONT_LEFT_DOOR_0) != 1 )
    {
      v24 = this->m_pTargetVehicle;
LABEL_86:
      (*((void (__fastcall **)(CVehicle *, CPed *, int))v24->_vptr$CPlaceable + 47))(
        v24,
        pPed,
        HasRadioRetuneJustStarted);
      v35 = this;
      v36 = pPed;
      v37 = 1;
LABEL_87:
      CTaskSimpleCarDrive::ProcessBopping(v35, v36, v37);
      goto LABEL_88;
    }
    if ( (*((int (__fastcall **)(CVehicle *, int))pPed->m_pMyVehicle->_vptr$CPlaceable + 34))(pPed->m_pMyVehicle, 2) )
      goto LABEL_88;
    Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x182u);
    v32 = pPed->m_pMyVehicle;
    if ( v32->m_nGettingOutFlags << 31 )
      goto LABEL_69;
    v33 = Association == 0;
    if ( !Association )
      v33 = (v32->m_nGettingInFlags & 1) == 0;
    if ( !v33 )
    {
LABEL_69:
      if ( Association )
      {
        Group = CVehicleAnimGroup::GetGroup(
                  &CVehicleAnimGroupData::m_vehicleAnimGroups[this->m_pTargetVehicle->pHandling->AnimGroup],
                  Association->m_animId);
        (*((void (__fastcall **)(CVehicle *, CPed *, int, int, int, _DWORD))pPed->m_pMyVehicle->_vptr$CPlaceable + 29))(
          pPed->m_pMyVehicle,
          pPed,
          10,
          Group,
          386,
          LODWORD(Association->m_fCurrentTime));
      }
      v35 = this;
      v36 = pPed;
      v37 = 0;
      goto LABEL_87;
    }
    if ( PadFromPlayer )
    {
      if ( CPad::GetAccelerate(PadFromPlayer)
        || CPad::GetSteeringLeftRight(PadFromPlayer)
        || CPad::GetBrake(PadFromPlayer) )
      {
        goto LABEL_69;
      }
      v32 = pPed->m_pMyVehicle;
    }
    CVehicle::SetGettingOutFlags(v32, 1u);
    *((_BYTE *)this + 92) |= 0x20u;
    v63 = CVehicleAnimGroup::GetGroup(
            &CVehicleAnimGroupData::m_vehicleAnimGroups[pPed->m_pMyVehicle->pHandling->AnimGroup],
            386);
    v64 = CAnimManager::AddAnimation((RpClump_0 *)pPed->m_pRwObject, (AssocGroupId)v63, ANIM_VEH_CLOSE_DOOR_ROLLING);
    this->m_pAnimCloseDoor = v64;
    CAnimBlendAssociation::SetFinishCallback(v64, CTaskSimpleCarDrive::FinishAnimCloseDoorRollingCB, this);
    return 0;
  }
  if ( CDoor::IsClosed((const CDoor *)&v30[1].m_vecMoveFriction.z) )
  {
    v30 = pPed->m_pMyVehicle;
    goto LABEL_57;
  }
  if ( !PadFromPlayer
    || !CPad::GetAccelerate(PadFromPlayer)
    && !CPad::GetSteeringLeftRight(PadFromPlayer)
    && !CPad::GetBrake(PadFromPlayer) )
  {
    v55 = CVehicleAnimGroup::GetGroup(
            &CVehicleAnimGroupData::m_vehicleAnimGroups[this->m_pTargetVehicle->pHandling->AnimGroup],
            386);
    (*((void (__fastcall **)(CVehicle *, CPed *, int, int, int, int))pPed->m_pMyVehicle->_vptr$CPlaceable + 29))(
      pPed->m_pMyVehicle,
      pPed,
      10,
      v55,
      386,
      1065353216);
  }
LABEL_88:
  EntityThatThisPedIsHolding = CPed::GetEntityThatThisPedIsHolding(pPed);
  if ( EntityThatThisPedIsHolding )
  {
    if ( EntityThatThisPedIsHolding->m_nModelIndex == MI_GANG_SMOKE
      && !IKChainManager_c::IsLooking(&g_ikChainMan, pPed)
      && (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 60.0) == 15 )
    {
      ActiveTaskByType = (CTaskSimpleHoldEntity *)CTaskManager::FindActiveTaskByType(
                                                    &pPed->m_pPedIntelligence->m_taskManager,
                                                    307);
      if ( ActiveTaskByType )
      {
        if ( CVehicle::IsPassenger(this->m_pTargetVehicle, pPed) )
          v44 = ANIM_STD_CAR_SMOKING_PASS;
        else
          v44 = ANIM_STD_CAR_SMOKING;
        CTaskSimpleHoldEntity::PlayAnim(ActiveTaskByType, v44, ANIM_STD_PED);
      }
    }
  }
  if ( RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0xA9u) )
  {
    if ( IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
      IKChainManager_c::AbortLookAt(&g_ikChainMan, pPed, 250);
    if ( this->m_bopStartTime != -1 )
      this->m_bopStartTime = -1;
  }
  else
  {
    CTaskSimpleCarDrive::TriggerIK(this, pPed);
  }
  if ( pPed->CharCreatedBy == 1 && !CPedGroups::GetPedsGroup(pPed) )
  {
    v45 = this->m_pTargetVehicle;
    v46 = v45->pDriver;
    v47 = v46 == 0;
    if ( !v46 )
      v47 = v45->pPassengers[0] == pPed;
    if ( v47 )
    {
      if ( !this->m_passengerTimer.m_bIsActive )
      {
        *(_QWORD *)&this->m_passengerTimer.m_iStartTime = CTimer::m_snTimeInMilliseconds | 0xFA000000000LL;
        this->m_passengerTimer.m_bIsActive = 1;
      }
      if ( this->m_passengerTimer.m_bIsStopped )
      {
        v56 = CTimer::m_snTimeInMilliseconds;
        this->m_passengerTimer.m_bIsStopped = 0;
        this->m_passengerTimer.m_iStartTime = v56;
        m_iStartTime = v56;
      }
      else
      {
        m_iStartTime = this->m_passengerTimer.m_iStartTime;
        v56 = CTimer::m_snTimeInMilliseconds;
      }
      if ( m_iStartTime + this->m_passengerTimer.m_iDuration <= v56 )
      {
        v58 = (CTaskComplexSequence *)CTask::operator new(0x40u);
        CTaskComplexSequence::CTaskComplexSequence(v58);
        v59 = CTask::operator new(0x34u);
        v60 = this->m_pTargetVehicle;
        CTaskComplex::CTaskComplex((CTaskComplex *)v59);
        *(_DWORD *)v59 = &off_66ABDC;
        *((_DWORD *)v59 + 4) = 0;
        *((_DWORD *)v59 + 5) = 0;
        *((_WORD *)v59 + 12) = 1;
        *((_BYTE *)v59 + 26) = 0;
        *((_DWORD *)v59 + 7) = 0;
        *((_BYTE *)v59 + 32) = 0;
        *((_BYTE *)v59 + 33) = 0;
        *((_DWORD *)v59 + 9) = 15;
        *((_DWORD *)v59 + 10) = 1082130432;
        *((_DWORD *)v59 + 11) = 1065353216;
        *((_BYTE *)v59 + 48) = 0;
        *((_DWORD *)v59 + 3) = v60;
        if ( v60 )
          CEntity::RegisterReference(v60, (CEntity **)v59 + 3);
        CTaskComplexSequence::AddTask(v58, (CTask *)v59);
        v61 = CTask::operator new(0x24u);
        v62 = this->m_pTargetVehicle;
        CTaskComplex::CTaskComplex((CTaskComplex *)v61);
        *(_DWORD *)v61 = &off_66AD3C;
        *((_DWORD *)v61 + 4) = 1092616192;
        *((_DWORD *)v61 + 5) = -1;
        *((_DWORD *)v61 + 6) = 0;
        *((_BYTE *)v61 + 28) = 1;
        *((_BYTE *)v61 + 32) = 0;
        *((_DWORD *)v61 + 3) = v62;
        if ( v62 )
          CEntity::RegisterReference(v62, (CEntity **)v61 + 3);
        *(_DWORD *)v61 = &off_66AD84;
        CTaskComplexSequence::AddTask(v58, (CTask *)v61);
        CEventScriptCommand::CEventScriptCommand(v65, 3, v58, 0);
        CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, v65, 0);
        CEventScriptCommand::~CEventScriptCommand(v65);
      }
    }
    else
    {
      this->m_passengerTimer.m_bIsActive = 0;
    }
  }
  if ( (CTimer::m_FrameCounter + pPed->RandomSeed) << 18 )
    return 0;
  v14 = 0;
  v49 = this->m_pTargetVehicle->pDriver;
  v50 = v49 == 0;
  if ( v49 )
    v50 = v49 == pPed;
  if ( !v50 )
  {
    if ( CPed::IsPlayer(v49) )
    {
      v51 = this->m_pTargetVehicle;
      x = v51->m_vecMoveSpeed.x;
      y = v51->m_vecMoveSpeed.y;
      if ( sqrtf((float)(x * x) + (float)(y * y)) > 0.7 )
      {
        CPed::Say(pPed, 0x20u, 0, 1.0, 0, 0, 0);
        v54 = this->m_pTargetVehicle;
        x = v54->m_vecMoveSpeed.x;
        y = v54->m_vecMoveSpeed.y;
      }
      if ( sqrtf((float)(x * x) + (float)(y * y)) < 0.1 )
        CPed::Say(pPed, 0x27u, 0, 1.0, 0, 0, 0);
      v14 = 0;
      CPed::Say(pPed, 0x29u, 0, 1.0, 0, 0, 0);
      return v14;
    }
    return 0;
  }
  return v14;
}
// 4FA2C2: variable 'm_pTargetVehicle' is possibly undefined
// 4FA2C8: variable 'p_m_pTargetVehicle' is possibly undefined
// 66ABDC: using guessed type void *off_66ABDC;
// 66AD3C: using guessed type void *off_66AD3C;
// 66AD84: using guessed type void *off_66AD84;
// 679000: using guessed type __int16 *MI_GANG_SMOKE_ptr;

//----- (004FAB7C) --------------------------------------------------------
void __fastcall CTaskSimpleCarDrive::StartAnimDoorCloseRolling(CTaskSimpleCarDrive *this, const CPed *pPed)
{
  int Group; // r0
  CAnimBlendAssociation *v5; // r0

  Group = CVehicleAnimGroup::GetGroup(
            &CVehicleAnimGroupData::m_vehicleAnimGroups[pPed->m_pMyVehicle->pHandling->AnimGroup],
            386);
  v5 = CAnimManager::AddAnimation((RpClump_0 *)pPed->m_pRwObject, (AssocGroupId)Group, ANIM_VEH_CLOSE_DOOR_ROLLING);
  this->m_pAnimCloseDoor = v5;
  sub_18C19C(v5, CTaskSimpleCarDrive::FinishAnimCloseDoorRollingCB, this);
}

//----- (004FABCC) --------------------------------------------------------
void __fastcall CTaskSimpleCarDrive::ProcessBopping(CTaskSimpleCarDrive *this, CPed *pPed, bool8 active)
{
  CPed *pDriver; // r4
  CPlayerPed *PlayerPed; // r0
  bool v8; // zf
  CVehicle *m_pMyVehicle; // r0
  int32 m_vehicleType; // r0
  bool v11; // zf
  int32 m_bopStartTime; // r0
  int32 m_bopPhase; // r8
  signed int v14; // r0
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  CSimpleTransform *p_m_transform; // r1
  float v18; // s0

  pDriver = pPed->m_pMyVehicle->pDriver;
  PlayerPed = FindPlayerPed(0);
  v8 = pDriver == PlayerPed;
  if ( pDriver != PlayerPed )
    v8 = pPed->m_nPedType == 6;
  if ( !v8 && !CTaskManager::FindActiveTaskByType(&pPed->m_pPedIntelligence->m_taskManager, 824) )
  {
    m_pMyVehicle = pPed->m_pMyVehicle;
    if ( !m_pMyVehicle->m_baseVehicleType )
    {
      m_vehicleType = m_pMyVehicle->m_vehicleType;
      v11 = m_vehicleType == 2;
      if ( m_vehicleType != 2 )
        v11 = pPed->CharCreatedBy == 2;
      if ( !v11 )
      {
        m_bopStartTime = this->m_bopStartTime;
        if ( m_bopStartTime != -1 )
        {
          m_bopPhase = this->m_bopPhase;
          v14 = CTimer::m_snTimeInMilliseconds - m_bopStartTime;
          this->m_currBopSide = v14 / m_bopPhase % 2;
          this->m_currBop = (float)(v14 % m_bopPhase) / (float)m_bopPhase;
        }
        m_pMat = pPed->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &pPed->m_transform;
        p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
        if ( !TheCamera.m_pMat )
          p_m_transform = &TheCamera.m_transform;
        v18 = (float)((float)((float)(p_tx->m_translate.x - p_m_transform->m_translate.x)
                            * (float)(p_tx->m_translate.x - p_m_transform->m_translate.x))
                    + (float)((float)(p_tx->m_translate.y - p_m_transform->m_translate.y)
                            * (float)(p_tx->m_translate.y - p_m_transform->m_translate.y)))
            + (float)((float)(p_tx->m_translate.z - p_m_transform->m_translate.z)
                    * (float)(p_tx->m_translate.z - p_m_transform->m_translate.z));
        CTaskSimpleCarDrive::ProcessHeadBopping(this, pPed, active, v18);
        CTaskSimpleCarDrive::ProcessArmBopping(this, pPed, active, v18);
        if ( this->m_bopStartTime != -1 && !(*((unsigned __int8 *)this + 92) << 30) )
          this->m_bopStartTime = -1;
      }
    }
  }
}

//----- (004FACFC) --------------------------------------------------------
bool8 __fastcall CTaskSimpleCarDrive::IsBopping(CTaskSimpleCarDrive *this)
{
  return this->m_bopStartTime != -1;
}

//----- (004FAD0A) --------------------------------------------------------
void __fastcall CTaskSimpleCarDrive::StopBopping(CTaskSimpleCarDrive *this)
{
  this->m_bopStartTime = -1;
}

//----- (004FAD14) --------------------------------------------------------
bool __fastcall CTaskSimpleCarDrive::SetPedPosition(CTaskSimpleCarDrive *this, CPed *pPed)
{
  CTaskSimpleCarDrive *TaskByType; // r0
  bool v5; // zf
  CTaskUtilityLineUpPedWithCar *m_pUtility; // r1
  CAnimBlendAssociation *Association; // r3
  CTaskUtilityLineUpPedWithCar *v8; // r0
  void *v9; // r0
  CVehicle *m_pTargetVehicle; // r0

  if ( (*((_BYTE *)this + 92) & 8) != 0 )
  {
    TaskByType = (CTaskSimpleCarDrive *)CTaskManager::FindTaskByType(&pPed->m_pPedIntelligence->m_taskManager, 4, 709);
    v5 = TaskByType == 0;
    if ( TaskByType )
      v5 = TaskByType == this;
    if ( !v5 )
    {
      m_pUtility = TaskByType->m_pUtility;
      if ( m_pUtility )
      {
        this->m_pUtility = m_pUtility;
        TaskByType->m_pUtility = 0;
      }
    }
    *((_BYTE *)this + 92) &= ~8u;
  }
  if ( this->m_pUtility )
  {
    Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, aTestAnimList[0]);
    if ( !Association )
    {
      Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, aTestAnimList[1]);
      if ( !Association )
      {
        Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, aTestAnimList[2]);
        if ( !Association )
        {
          Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, aTestAnimList[3]);
          if ( !Association )
          {
            Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, aTestAnimList[4]);
            if ( !Association )
            {
              Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, aTestAnimList[5]);
              if ( !Association )
              {
                Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, aTestAnimList[6]);
                if ( !Association )
                {
                  Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, aTestAnimList[7]);
                  if ( !Association )
                  {
                    Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, aTestAnimList[8]);
                    if ( !Association )
                    {
                      Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, aTestAnimList[9]);
                      if ( !Association )
                      {
                        Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, aTestAnimList[10]);
                        if ( !Association )
                          Association = RpAnimBlendClumpGetAssociation(
                                          (RpClump_0 *)pPed->m_pRwObject,
                                          aTestAnimList[11]);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    CTaskUtilityLineUpPedWithCar::ProcessPed(this->m_pUtility, pPed, this->m_pTargetVehicle, Association);
    v8 = this->m_pUtility;
    if ( v8 )
    {
      CTaskUtilityLineUpPedWithCar::~CTaskUtilityLineUpPedWithCar(v8);
      operator delete(v9);
    }
    this->m_pUtility = 0;
    return 1;
  }
  else
  {
    m_pTargetVehicle = this->m_pTargetVehicle;
    if ( m_pTargetVehicle && pPed->m_pMyVehicle == m_pTargetVehicle )
    {
      if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
        CPed::SetPedPositionInCar(pPed);
      return 1;
    }
    else
    {
      return 1;
    }
  }
}
// 4FAE4A: variable 'v9' is possibly undefined

//----- (004FAEA8) --------------------------------------------------------
void __fastcall CTaskSimpleCarDrive::FinishAnimCloseDoorRollingCB(CAnimBlendAssociation *pAnim, void *pData)
{
  char v3; // r1
  CVehicle *v4; // r0
  int v5; // r0
  int Group; // r0

  v3 = *((_BYTE *)pData + 92);
  *((_DWORD *)pData + 3) = 0;
  v4 = (CVehicle *)*((_DWORD *)pData + 2);
  *((_BYTE *)pData + 92) = v3 & 0xDF;
  if ( v4 )
  {
    CVehicle::ClearGettingOutFlags(v4, 1u);
    v5 = *((_DWORD *)pData + 2);
    if ( *(_DWORD *)(v5 + 1124) )
    {
      Group = CVehicleAnimGroup::GetGroup(
                &CVehicleAnimGroupData::m_vehicleAnimGroups[*(unsigned __int8 *)(*(_DWORD *)(v5 + 904) + 222)],
                386);
      (*(void (__fastcall **)(_DWORD, _DWORD, int, int, int, int))(**((_DWORD **)pData + 2) + 116))(
        *((_DWORD *)pData + 2),
        *(_DWORD *)(*((_DWORD *)pData + 2) + 1124),
        10,
        Group,
        386,
        1065353216);
    }
  }
}

//----- (004FAF14) --------------------------------------------------------
void __fastcall CTaskSimpleCarDrive::GetPedsBopInfo(
        CTaskSimpleCarDrive *this,
        CPed *pPed,
        int32 *startTime,
        int32 *bopPhase)
{
  CTask *ActiveTaskByType; // r0

  ActiveTaskByType = CTaskManager::FindActiveTaskByType(&pPed->m_pPedIntelligence->m_taskManager, 709);
  if ( ActiveTaskByType )
  {
    *bopPhase = (int32)ActiveTaskByType[5]._vptr$CTask;
    *startTime = (int32)ActiveTaskByType[4]._vptr$CTask;
  }
}

//----- (004FAF38) --------------------------------------------------------
void __fastcall CTaskSimpleCarDrive::StartBopping(CTaskSimpleCarDrive *this, CPed *pPed)
{
  CPed *pDriver; // r0
  bool v5; // zf
  CTask *ActiveTaskByType; // r0
  int32 v7; // r1
  bool v8; // zf
  CVehicle *m_pMyVehicle; // r0
  CPed *v10; // r1
  bool v11; // zf
  bool v12; // zf
  CPed *v13; // r1
  bool v14; // zf
  bool v15; // zf
  CPed *v16; // r0
  bool v17; // zf
  bool v18; // zf
  unsigned __int16 v19; // r0
  int32 v20; // r5
  signed int v21; // r0
  int v22; // r1

  pDriver = pPed->m_pMyVehicle->pDriver;
  v5 = pDriver == 0;
  if ( pDriver )
    v5 = pDriver == pPed;
  if ( !v5 )
  {
    ActiveTaskByType = CTaskManager::FindActiveTaskByType(&pDriver->m_pPedIntelligence->m_taskManager, 709);
    v8 = ActiveTaskByType == 0;
    if ( ActiveTaskByType )
    {
      v7 = (int32)ActiveTaskByType[4]._vptr$CTask;
      v8 = v7 == -1;
    }
    if ( !v8 )
      goto LABEL_32;
  }
  m_pMyVehicle = pPed->m_pMyVehicle;
  v10 = m_pMyVehicle->pPassengers[0];
  v11 = v10 == 0;
  if ( v10 )
    v11 = v10 == pPed;
  if ( !v11 )
  {
    ActiveTaskByType = CTaskManager::FindActiveTaskByType(&v10->m_pPedIntelligence->m_taskManager, 709);
    v12 = ActiveTaskByType == 0;
    if ( ActiveTaskByType )
    {
      v7 = (int32)ActiveTaskByType[4]._vptr$CTask;
      v12 = v7 == -1;
    }
    if ( !v12 )
      goto LABEL_32;
    m_pMyVehicle = pPed->m_pMyVehicle;
  }
  v13 = m_pMyVehicle->pPassengers[1];
  v14 = v13 == 0;
  if ( v13 )
    v14 = v13 == pPed;
  if ( !v14 )
  {
    ActiveTaskByType = CTaskManager::FindActiveTaskByType(&v13->m_pPedIntelligence->m_taskManager, 709);
    v15 = ActiveTaskByType == 0;
    if ( ActiveTaskByType )
    {
      v7 = (int32)ActiveTaskByType[4]._vptr$CTask;
      v15 = v7 == -1;
    }
    if ( !v15 )
      goto LABEL_32;
    m_pMyVehicle = pPed->m_pMyVehicle;
  }
  v16 = m_pMyVehicle->pPassengers[2];
  v17 = v16 == 0;
  if ( v16 )
    v17 = v16 == pPed;
  if ( v17 )
    goto LABEL_31;
  ActiveTaskByType = CTaskManager::FindActiveTaskByType(&v16->m_pPedIntelligence->m_taskManager, 709);
  v18 = ActiveTaskByType == 0;
  if ( ActiveTaskByType )
  {
    v7 = (int32)ActiveTaskByType[4]._vptr$CTask;
    v18 = v7 == -1;
  }
  if ( v18 )
  {
LABEL_31:
    this->m_bopStartTime = CTimer::m_snTimeInMilliseconds;
    v19 = rand();
    this->m_currBop = 0.0;
    this->m_bopPhase = (int)(float)((float)(1.0
                                          / (float)((float)((int)(float)((float)((float)v19 * 0.000015259) * 60.0) + 60)
                                                  / 60.0))
                                  * 1000.0);
    return;
  }
LABEL_32:
  v20 = (int32)ActiveTaskByType[5]._vptr$CTask;
  this->m_bopPhase = v20;
  this->m_bopStartTime = v7;
  v21 = CTimer::m_snTimeInMilliseconds - v7;
  v22 = (int)(CTimer::m_snTimeInMilliseconds - v7) % v20;
  this->m_currBopSide = v21 / v20 % 2;
  this->m_currBop = (float)v22 / (float)v20;
}
// 4FB050: variable 'v7' is possibly undefined

//----- (004FB098) --------------------------------------------------------
void __fastcall CTaskSimpleCarDrive::UpdateBopping(CTaskSimpleCarDrive *this)
{
  int32 m_bopPhase; // r5
  signed int v3; // r0

  m_bopPhase = this->m_bopPhase;
  v3 = CTimer::m_snTimeInMilliseconds - this->m_bopStartTime;
  this->m_currBopSide = v3 / m_bopPhase % 2;
  this->m_currBop = (float)(v3 % m_bopPhase) / (float)m_bopPhase;
}

//----- (004FB0DC) --------------------------------------------------------
void __fastcall CTaskSimpleCarDrive::ProcessHeadBopping(
        CTaskSimpleCarDrive *this,
        CPed *pPed,
        bool8 active,
        float distSqr)
{
  float v4; // s16
  bool8 v5; // r4
  int32 *p_m_bopStartTime; // r9
  unsigned __int16 v10; // r0
  int v11; // r0
  float m_headBopBlend; // s2
  float v13; // s2
  float v14; // s16
  RwFrame_0 *pFrame; // r4
  float v16; // r2
  unsigned int v17; // r2

  v4 = 0.0;
  v5 = active;
  if ( !active )
    goto LABEL_7;
  if ( !(*((unsigned __int8 *)this + 92) << 31) )
  {
    if ( this->m_headBopBlend == 0.0
      && (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 1000.0) >= 996 )
    {
      p_m_bopStartTime = &this->m_bopStartTime;
      if ( this->m_bopStartTime == -1 )
        CTaskSimpleCarDrive::StartBopping(this, pPed);
      else
        p_m_bopStartTime = (int32 *)&CTimer::m_snTimeInMilliseconds;
      this->m_headBopStartTime = *p_m_bopStartTime;
      v10 = rand();
      this->m_headBopType = (int)(float)((float)((float)v10 * 0.000015259) + (float)((float)v10 * 0.000015259)) + 1;
      v11 = rand();
      this->m_headBopBlend = 0.0;
      this->m_currHeadBop = 0.0;
      this->m_headBopDepth = (float)((float)((float)v11 * 4.6566e-10) * 5.0) + 3.0;
      goto LABEL_14;
    }
LABEL_7:
    v5 = 0;
    goto LABEL_14;
  }
  v4 = sinf(this->m_currBop * 3.1416);
  if ( CTimer::m_snTimeInMilliseconds - this->m_headBopStartTime >= 0x1389
    && (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 1000.0) >= 996 )
  {
    v5 = 0;
  }
LABEL_14:
  m_headBopBlend = this->m_headBopBlend;
  *((_BYTE *)this + 92) = *((_BYTE *)this + 92) & 0xFE | v5 & 1;
  if ( (v5 & 1) != 0 )
  {
    if ( m_headBopBlend < 1.0 )
    {
      m_headBopBlend = m_headBopBlend + 0.05;
      this->m_headBopBlend = m_headBopBlend;
    }
    if ( m_headBopBlend > 1.0 )
    {
      this->m_headBopBlend = 1.0;
      m_headBopBlend = 1.0;
    }
  }
  else
  {
    if ( m_headBopBlend > 0.0 )
    {
      m_headBopBlend = m_headBopBlend + -0.05;
      this->m_headBopBlend = m_headBopBlend;
    }
    if ( m_headBopBlend < 0.0 )
    {
      m_headBopBlend = 0.0;
      this->m_headBopBlend = 0.0;
    }
    m_headBopBlend = 1.0 - m_headBopBlend;
  }
  v13 = (float)((float)(v4 - this->m_currHeadBop) * m_headBopBlend) + this->m_currHeadBop;
  this->m_currHeadBop = v13;
  if ( distSqr < 64.0 && v13 > 0.0 )
  {
    v14 = v13 * this->m_headBopDepth;
    pFrame = pPed->m_aPedFrames[2]->_anon_1.pFrame;
    if ( this->m_headBopType > 0
      && (!this->m_currBopSide ? (v16 = v13 * this->m_headBopDepth) : (v16 = -(float)(v13 * this->m_headBopDepth)),
          RtQuatRotate(
            (RtQuat_0 *)pPed->m_aPedFrames[2]->_anon_1.pFrame,
            &CTaskSimpleCarDrive::ProcessHeadBopping(CPed *,unsigned char,float)::xAxis,
            v16,
            rwCOMBINEPRECONCAT),
          this->m_headBopType == 2) )
    {
      v17 = LODWORD(v14);
    }
    else
    {
      v17 = LODWORD(v14) ^ 0x80000000;
    }
    RtQuatRotate(
      (RtQuat_0 *)pFrame,
      &CTaskSimpleCarDrive::ProcessHeadBopping(CPed *,unsigned char,float)::zAxis,
      *(RwReal *)&v17,
      rwCOMBINEPRECONCAT);
    *((_DWORD *)&pPed->m_nPedFlags + 1) |= 0x4000u;
  }
}

//----- (004FB35C) --------------------------------------------------------
void __fastcall CTaskSimpleCarDrive::ProcessArmBopping(
        CTaskSimpleCarDrive *this,
        CPed *pPed,
        bool8 active,
        float distSqr)
{
  int v7; // r4
  CVehicle *m_pMyVehicle; // r0
  uint8 v9; // r1
  CVehicle *v10; // r0
  CPed *v11; // r1
  bool v12; // zf
  signed int v13; // r8
  CAnimBlendAssociation *Association; // r0
  CAnimBlendAssociation *v15; // r6
  char v16; // r0
  CVehicle *m_pTargetVehicle; // r0
  int32 *p_m_bopStartTime; // r4
  float m_currBop; // s2
  int v20; // r0
  float v21; // s0
  char v22; // r0
  int v23; // r4
  _BOOL4 v24; // r0
  CVehicle *v25; // r1
  float *m_hashKey; // r2
  float v27; // s0
  int v28; // r6
  int v29; // r3
  float v30; // s0
  float v31; // s2
  char v32; // r0

  v7 = active;
  if ( CPed::IsPlayer(pPed) )
    return;
  m_pMyVehicle = pPed->m_pMyVehicle;
  if ( CWeather::Rain > 0.0 )
  {
    CVehicle::ClearWindowOpenFlag(m_pMyVehicle, 0xAu);
    CVehicle::ClearWindowOpenFlag(pPed->m_pMyVehicle, 8u);
    CVehicle::ClearWindowOpenFlag(pPed->m_pMyVehicle, 0xBu);
    CVehicle::ClearWindowOpenFlag(pPed->m_pMyVehicle, 9u);
    v7 = 0;
    goto LABEL_13;
  }
  if ( m_pMyVehicle->pDriver == pPed )
  {
    v9 = 10;
  }
  else if ( m_pMyVehicle->pPassengers[0] == pPed )
  {
    v9 = 8;
  }
  else if ( m_pMyVehicle->pPassengers[1] == pPed )
  {
    v9 = 11;
  }
  else
  {
    if ( m_pMyVehicle->pPassengers[2] != pPed )
      goto LABEL_13;
    v9 = 9;
  }
  CVehicle::SetWindowOpenFlag(m_pMyVehicle, v9);
LABEL_13:
  v10 = pPed->m_pMyVehicle;
  v11 = v10->pPassengers[0];
  v12 = v11 == pPed;
  if ( v11 != pPed )
    v12 = v10->pPassengers[2] == pPed;
  if ( v12 )
    v13 = 163;
  else
    v13 = 162;
  Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, v13);
  v15 = Association;
  if ( !v7 )
  {
    if ( !Association )
    {
LABEL_26:
      v16 = *((_BYTE *)this + 92);
LABEL_37:
      v22 = v16 & 0xFD;
LABEL_38:
      *((_BYTE *)this + 92) = v22;
      return;
    }
LABEL_25:
    v15->m_fBlendDelta = -4.0;
    goto LABEL_26;
  }
  v16 = *((_BYTE *)this + 92);
  if ( (v16 & 2) != 0 )
  {
    if ( !v15 )
      goto LABEL_37;
    if ( distSqr < 64.0 )
    {
      m_currBop = this->m_currBop;
      v20 = 6;
      v21 = (float)(m_currBop + -0.75) * -45.0;
      if ( m_currBop < 0.75 )
        v21 = -0.0;
      if ( v13 == 162 )
        v20 = 5;
      RtQuatRotate(
        (RtQuat_0 *)pPed->m_aPedFrames[v20]->_anon_1.pFrame,
        &CTaskSimpleCarDrive::ProcessArmBopping(CPed *,unsigned char,float)::zAxis,
        v21,
        rwCOMBINEPRECONCAT);
      *((_DWORD *)&pPed->m_nPedFlags + 1) |= 0x4000u;
    }
    if ( CTimer::m_snTimeInMilliseconds - this->m_armBopStartTime < 0x1389
      || (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 1000.0) < 996 )
    {
      return;
    }
    goto LABEL_25;
  }
  if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 1000.0) < 996 )
    return;
  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( m_pTargetVehicle->m_vehicleType )
    goto LABEL_22;
  v23 = CCarEnterExit::ComputeTargetDoorToExit(m_pTargetVehicle, pPed);
  v24 = !CDamageManager::GetDoorStatus((const CDamageManager *)&this->m_pTargetVehicle[1], v23)
     && !CCarEnterExit::CarHasDoorToClose(this->m_pTargetVehicle, v23)
     && CVehicle::CanPedLeanOut(this->m_pTargetVehicle, pPed);
  v25 = this->m_pTargetVehicle;
  m_hashKey = (float *)CModelInfo::ms_modelInfoPtrs[v25->m_nModelIndex][2].m_hashKey;
  v27 = m_hashKey[32];
  if ( m_hashKey[30] != 0.0 )
    goto LABEL_49;
  v28 = 0;
  v29 = 0;
  if ( v27 == 0.0 )
    v28 = 1;
  if ( m_hashKey[31] == 0.0 )
    v29 = 1;
  if ( (v28 & v29) == 0 )
  {
LABEL_49:
    if ( (*((_BYTE *)&v25->m_nVehicleFlags + 1) & 8) == 0 )
    {
      v30 = v27 - m_hashKey[14];
      if ( (CVehicleAnimGroupData::m_vehicleAnimGroups[v25->pHandling->AnimGroup].m_specialFlags & 8) != 0 )
      {
        if ( v24 && v30 >= 0.4 )
        {
          v31 = 0.44;
LABEL_60:
          if ( v30 > v31 )
            return;
LABEL_22:
          CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, (AnimationId)v13, 4.0);
          p_m_bopStartTime = &this->m_bopStartTime;
          if ( this->m_bopStartTime == -1 )
            CTaskSimpleCarDrive::StartBopping(this, pPed);
          else
            p_m_bopStartTime = (int32 *)&CTimer::m_snTimeInMilliseconds;
          v32 = *((_BYTE *)this + 92);
          this->m_armBopStartTime = *p_m_bopStartTime;
          v22 = v32 | 2;
          goto LABEL_38;
        }
      }
      else if ( v24 && v30 >= 0.39 )
      {
        v31 = 0.46;
        goto LABEL_60;
      }
    }
  }
}

//----- (004FB688) --------------------------------------------------------
void __fastcall CTaskComplexCarDrive::CTaskComplexCarDrive(
        CTaskComplexCarDrive *this,
        CVehicle *pVehicle,
        const float fCruiseSpeed,
        const int iDesiredCarModel,
        const int iDrivingStyle)
{
  CTaskComplex::CTaskComplex(this);
  this->m_fCruiseSpeed = fCruiseSpeed;
  this->m_iDesiredCarModel = iDesiredCarModel;
  this->m_iDrivingStyle = iDrivingStyle;
  this->m_bAsDriver = 1;
  this->m_bIsCarSetUp = 0;
  this->_vptr$CTask = (int (**)(void))&off_66AD3C;
  this->m_pVehicle = pVehicle;
  if ( pVehicle )
    CEntity::RegisterReference(pVehicle, &this->m_pVehicle);
}
// 66AD3C: using guessed type void *off_66AD3C;

//----- (004FB6DC) --------------------------------------------------------
void __fastcall CTaskComplexCarDrive::CTaskComplexCarDrive(CTaskComplexCarDrive *this, CVehicle *pVehicle)
{
  CTaskComplex::CTaskComplex(this);
  this->m_fCruiseSpeed = 0.0;
  this->m_iDesiredCarModel = -1;
  this->m_iDrivingStyle = 0;
  this->m_bAsDriver = 1;
  this->m_bIsCarSetUp = 0;
  this->_vptr$CTask = (int (**)(void))&off_66AD3C;
  this->m_pVehicle = pVehicle;
  if ( pVehicle )
    CEntity::RegisterReference(pVehicle, &this->m_pVehicle);
}
// 66AD3C: using guessed type void *off_66AD3C;

//----- (004FB724) --------------------------------------------------------
void __fastcall CTaskComplexCarDriveWander::~CTaskComplexCarDriveWander(CTaskComplexCarDrive *this)
{
  CVehicle *m_pVehicle; // r0
  CEntity **p_m_pVehicle; // r1
  CVehicle *v4; // r0

  p_m_pVehicle = &this->m_pVehicle;
  m_pVehicle = this->m_pVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AD3C;
  if ( m_pVehicle )
  {
    if ( this->m_bIsCarSetUp )
    {
      m_pVehicle->AutoPilot.DrivingMode = this->m_origDrivingMode;
      this->m_pVehicle->AutoPilot.Mission = this->m_origMission;
      this->m_pVehicle->AutoPilot.CruiseSpeed = this->m_origCruiseSpeed;
      v4 = this->m_pVehicle;
      if ( v4 )
        CEntity::CleanUpOldReference(v4, p_m_pVehicle);
    }
    else
    {
      CEntity::CleanUpOldReference(m_pVehicle, p_m_pVehicle);
    }
  }
  sub_18EDB4(this);
}
// 66AD3C: using guessed type void *off_66AD3C;

//----- (004FB778) --------------------------------------------------------
void __fastcall CTaskComplexCarDrive::~CTaskComplexCarDrive(CTaskComplexCarDrive *this)
{
  CVehicle *m_pVehicle; // r0
  CEntity **p_m_pVehicle; // r1
  CVehicle *v4; // r0
  void *v5; // r0

  p_m_pVehicle = &this->m_pVehicle;
  m_pVehicle = this->m_pVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AD3C;
  if ( m_pVehicle )
  {
    if ( this->m_bIsCarSetUp )
    {
      m_pVehicle->AutoPilot.DrivingMode = this->m_origDrivingMode;
      this->m_pVehicle->AutoPilot.Mission = this->m_origMission;
      this->m_pVehicle->AutoPilot.CruiseSpeed = this->m_origCruiseSpeed;
      v4 = this->m_pVehicle;
      if ( v4 )
        CEntity::CleanUpOldReference(v4, p_m_pVehicle);
    }
    else
    {
      CEntity::CleanUpOldReference(m_pVehicle, p_m_pVehicle);
    }
  }
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v5);
}
// 4FB7C6: variable 'v5' is possibly undefined
// 66AD3C: using guessed type void *off_66AD3C;

//----- (004FB7D0) --------------------------------------------------------
CTask *__fastcall CTaskComplexCarDrive::CreateNextSubTask(CTaskComplexCarDrive *this, CPed *pPed)
{
  int v4; // r0
  char *v5; // r4
  CVehicle *m_pVehicle; // r5
  char v7; // r0
  char v8; // r0
  CVehicle *m_pMyVehicle; // r0
  bool v10; // zf
  bool v11; // zf
  int (__fastcall *v12)(CTaskComplexCarDrive *, CPed *); // r2
  _BOOL4 m_bAsDriver; // r6
  CVehicle *v14; // r5
  char v15; // r2
  CEntity **v16; // r1
  char v17; // r0
  void **v18; // r0
  bool v19; // zf
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  CVehicle *v23; // r5
  char v24; // r0
  char v25; // r0

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  v5 = 0;
  switch ( v4 )
  {
    case 700:
      if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) || !pPed->m_pMyVehicle )
        return 0;
      (*((void (__fastcall **)(CTaskComplexCarDrive *))this->_vptr$CTask + 13))(this);
      v5 = (char *)CTask::operator new(0x60u);
      m_pVehicle = this->m_pVehicle;
      CTaskSimple::CTaskSimple((CTaskSimple *)v5);
      *(_QWORD *)(v5 + 12) = 0LL;
      *(_QWORD *)(v5 + 20) = 0LL;
      *(_DWORD *)v5 = &off_66AD08;
      *((_WORD *)v5 + 14) = 0;
      *(_DWORD *)(v5 + 86) = 0;
      *(_DWORD *)(v5 + 82) = 0;
      v7 = v5[92];
      *((_DWORD *)v5 + 19) = 0;
      *((_DWORD *)v5 + 20) = 0;
      v8 = v7 & 0xC3 | 8;
      v5[92] = v8;
      *((_DWORD *)v5 + 2) = m_pVehicle;
      if ( m_pVehicle )
      {
        CEntity::RegisterReference(m_pVehicle, (CEntity **)v5 + 2);
        v8 = v5[92];
      }
      *((_DWORD *)v5 + 8) = -1;
      v5[92] = v8 & 0xFC;
      *((_DWORD *)v5 + 15) = 0;
      *((_DWORD *)v5 + 16) = 0;
      *((_DWORD *)v5 + 17) = 0;
      return (CTask *)v5;
    case 701:
      v11 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
      if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
        v11 = pPed->m_pMyVehicle == 0;
      if ( v11 )
        goto LABEL_34;
      (*((void (__fastcall **)(CTaskComplexCarDrive *))this->_vptr$CTask + 13))(this);
      v5 = (char *)CTask::operator new(0x60u);
      v23 = this->m_pVehicle;
      CTaskSimple::CTaskSimple((CTaskSimple *)v5);
      goto LABEL_39;
    case 702:
    case 703:
    case 704:
    case 705:
    case 706:
    case 707:
    case 708:
    case 710:
    case 711:
    case 712:
    case 713:
    case 715:
    case 716:
      return (CTask *)v5;
    case 709:
      v12 = (int (__fastcall *)(CTaskComplexCarDrive *, CPed *))*((_DWORD *)this->_vptr$CTask + 11);
      return (CTask *)v12(this, pPed);
    case 714:
      m_bAsDriver = this->m_bAsDriver;
      if ( this->m_pVehicle )
      {
        v5 = (char *)CTask::operator new(0x50u);
        v14 = this->m_pVehicle;
        CTaskComplex::CTaskComplex((CTaskComplex *)v5);
        v15 = v5[16];
        *(_DWORD *)v5 = &off_66A8F4;
        *((_DWORD *)v5 + 3) = v14;
        v16 = (CEntity **)(v5 + 12);
        v17 = v15 & 0xF0;
        if ( m_bAsDriver )
        {
          v5[16] = v17 | 1;
          *((_DWORD *)v5 + 9) = 6;
          *((_WORD *)v5 + 20) = 0;
          *((_DWORD *)v5 + 14) = 0;
          v5[60] = 0;
          *((_DWORD *)v5 + 16) = 0;
          v5[68] = 0;
          *((_DWORD *)v5 + 18) = -1082130432;
          *(_QWORD *)(v5 + 20) = 0LL;
          *(_QWORD *)(v5 + 28) = 0LL;
          if ( v14 )
            CEntity::RegisterReference(v14, v16);
          v18 = &`vtable for'CTaskComplexEnterCarAsDriver;
        }
        else
        {
          v5[16] = v17;
          *((_DWORD *)v5 + 9) = 6;
          *((_WORD *)v5 + 20) = 0;
          *((_DWORD *)v5 + 14) = 0;
          v5[60] = 0;
          *((_DWORD *)v5 + 16) = 0;
          v5[68] = 0;
          *((_DWORD *)v5 + 18) = -1082130432;
          *(_QWORD *)(v5 + 20) = 0LL;
          *(_QWORD *)(v5 + 28) = 0LL;
          if ( v14 )
            CEntity::RegisterReference(v14, v16);
          *((_DWORD *)v5 + 7) = 0;
          v18 = &`vtable for'CTaskComplexEnterCarAsPassenger;
        }
      }
      else
      {
        if ( !this->m_bAsDriver )
          return 0;
LABEL_34:
        v5 = (char *)CTask::operator new(0xCu);
        CTaskComplex::CTaskComplex((CTaskComplex *)v5);
        v18 = &`vtable for'CTaskComplexEnterAnyCarAsDriver;
      }
      *(_DWORD *)v5 = (char *)*v18 + 8;
      return (CTask *)v5;
    case 717:
      m_pMyVehicle = (CVehicle *)(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31);
      v19 = m_pMyVehicle == 0;
      if ( m_pMyVehicle )
      {
        m_pMyVehicle = pPed->m_pMyVehicle;
        v19 = m_pMyVehicle == 0;
      }
      if ( !v19 )
      {
        if ( this->m_pVehicle )
        {
          CEntity::CleanUpOldReference(this->m_pVehicle, &this->m_pVehicle);
          m_pMyVehicle = pPed->m_pMyVehicle;
        }
LABEL_38:
        this->m_pVehicle = m_pMyVehicle;
        CEntity::RegisterReference(m_pMyVehicle, &this->m_pVehicle);
        (*((void (__fastcall **)(CTaskComplexCarDrive *))this->_vptr$CTask + 13))(this);
        v5 = (char *)CTask::operator new(0x60u);
        v23 = this->m_pVehicle;
        CTaskSimple::CTaskSimple((CTaskSimple *)v5);
LABEL_39:
        *(_QWORD *)(v5 + 12) = 0LL;
        *(_QWORD *)(v5 + 20) = 0LL;
        *(_DWORD *)v5 = &off_66AD08;
        *((_WORD *)v5 + 14) = 0;
        *(_DWORD *)(v5 + 86) = 0;
        *(_DWORD *)(v5 + 82) = 0;
        v24 = v5[92];
        *((_DWORD *)v5 + 19) = 0;
        v25 = v24 & 0xC3 | 8;
        *((_DWORD *)v5 + 20) = 0;
        v5[92] = v25;
        *((_DWORD *)v5 + 2) = v23;
        if ( v23 )
        {
          CEntity::RegisterReference(v23, (CEntity **)v5 + 2);
          v25 = v5[92];
        }
        *((_DWORD *)v5 + 8) = -1;
        v5[92] = v25 & 0xFC;
        *((_DWORD *)v5 + 15) = 0;
        *((_DWORD *)v5 + 16) = 0;
        *((_DWORD *)v5 + 17) = 0;
        return (CTask *)v5;
      }
      if ( this->m_iDesiredCarModel >= 0 )
      {
        v5 = (char *)CTask::operator new(0x34u);
        m_pMat = pPed->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &pPed->m_transform;
        CTaskSimpleCreateCarAndGetIn::CTaskSimpleCreateCarAndGetIn(
          (CTaskSimpleCreateCarAndGetIn *)v5,
          &p_tx->m_translate,
          this->m_iDesiredCarModel);
        return (CTask *)v5;
      }
LABEL_31:
      v12 = (int (__fastcall *)(CTaskComplexCarDrive *, CPed *))*((_DWORD *)this->_vptr$CTask + 14);
      return (CTask *)v12(this, pPed);
    default:
      if ( v4 != 832 )
        return (CTask *)v5;
      m_pMyVehicle = pPed->m_pMyVehicle;
      v10 = m_pMyVehicle == 0;
      if ( m_pMyVehicle )
        v10 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
      if ( !v10 )
        goto LABEL_38;
      goto LABEL_31;
  }
}
// 66A8F4: using guessed type void *off_66A8F4;
// 66AD08: using guessed type void *off_66AD08;
// 6762B0: using guessed type void *`vtable for'CTaskComplexEnterCarAsDriver;
// 6769E0: using guessed type void *`vtable for'CTaskComplexEnterCarAsPassenger;
// 677740: using guessed type void *`vtable for'CTaskComplexEnterAnyCarAsDriver;

//----- (004FBAF8) --------------------------------------------------------
CTask *__fastcall CTaskComplexCarDrive::CreateSubTask(
        const CTaskComplexCarDrive *this,
        const int iSubTaskType,
        CPed *pPed)
{
  char *WanderTaskByPedType; // r4
  CVehicle *m_pVehicle; // r5
  char v7; // r1
  void **v8; // r0
  CVehicle *v9; // r5
  char v10; // r2
  CVehicle *v11; // r5
  char v12; // r0
  char v13; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1

  WanderTaskByPedType = 0;
  switch ( iSubTaskType )
  {
    case 700:
      WanderTaskByPedType = (char *)CTask::operator new(0x50u);
      m_pVehicle = this->m_pVehicle;
      CTaskComplex::CTaskComplex((CTaskComplex *)WanderTaskByPedType);
      *(_QWORD *)(WanderTaskByPedType + 20) = 0LL;
      *(_QWORD *)(WanderTaskByPedType + 28) = 0LL;
      *((_DWORD *)WanderTaskByPedType + 9) = 6;
      *((_WORD *)WanderTaskByPedType + 20) = 0;
      *((_DWORD *)WanderTaskByPedType + 14) = 0;
      WanderTaskByPedType[60] = 0;
      *((_DWORD *)WanderTaskByPedType + 16) = 0;
      WanderTaskByPedType[68] = 0;
      *((_DWORD *)WanderTaskByPedType + 18) = -1082130432;
      v7 = WanderTaskByPedType[16];
      *(_DWORD *)WanderTaskByPedType = &off_66A8F4;
      WanderTaskByPedType[16] = v7 & 0xF0;
      *((_DWORD *)WanderTaskByPedType + 3) = m_pVehicle;
      if ( m_pVehicle )
        CEntity::RegisterReference(m_pVehicle, (CEntity **)WanderTaskByPedType + 3);
      *((_DWORD *)WanderTaskByPedType + 7) = 0;
      v8 = &`vtable for'CTaskComplexEnterCarAsPassenger;
      goto LABEL_16;
    case 701:
      WanderTaskByPedType = (char *)CTask::operator new(0x50u);
      v9 = this->m_pVehicle;
      CTaskComplex::CTaskComplex((CTaskComplex *)WanderTaskByPedType);
      *(_QWORD *)(WanderTaskByPedType + 20) = 0LL;
      *(_QWORD *)(WanderTaskByPedType + 28) = 0LL;
      *((_DWORD *)WanderTaskByPedType + 9) = 6;
      *((_WORD *)WanderTaskByPedType + 20) = 0;
      *((_DWORD *)WanderTaskByPedType + 14) = 0;
      WanderTaskByPedType[60] = 0;
      *((_DWORD *)WanderTaskByPedType + 16) = 0;
      WanderTaskByPedType[68] = 0;
      v10 = WanderTaskByPedType[16];
      *((_DWORD *)WanderTaskByPedType + 18) = -1082130432;
      *(_DWORD *)WanderTaskByPedType = &off_66A8F4;
      WanderTaskByPedType[16] = v10 & 0xF0 | 1;
      *((_DWORD *)WanderTaskByPedType + 3) = v9;
      if ( v9 )
        CEntity::RegisterReference(v9, (CEntity **)WanderTaskByPedType + 3);
      v8 = &`vtable for'CTaskComplexEnterCarAsDriver;
      goto LABEL_16;
    case 702:
    case 703:
    case 704:
    case 705:
    case 706:
    case 707:
    case 708:
    case 710:
    case 711:
    case 712:
    case 713:
    case 715:
    case 716:
      return (CTask *)WanderTaskByPedType;
    case 709:
      (*((void (__fastcall **)(const CTaskComplexCarDrive *))this->_vptr$CTask + 13))(this);
      WanderTaskByPedType = (char *)CTask::operator new(0x60u);
      v11 = this->m_pVehicle;
      CTaskSimple::CTaskSimple((CTaskSimple *)WanderTaskByPedType);
      *(_QWORD *)(WanderTaskByPedType + 12) = 0LL;
      *(_QWORD *)(WanderTaskByPedType + 20) = 0LL;
      *(_DWORD *)WanderTaskByPedType = &off_66AD08;
      *((_WORD *)WanderTaskByPedType + 14) = 0;
      *(_DWORD *)(WanderTaskByPedType + 86) = 0;
      *(_DWORD *)(WanderTaskByPedType + 82) = 0;
      v12 = WanderTaskByPedType[92];
      *((_DWORD *)WanderTaskByPedType + 19) = 0;
      *((_DWORD *)WanderTaskByPedType + 20) = 0;
      v13 = v12 & 0xC3 | 8;
      WanderTaskByPedType[92] = v13;
      *((_DWORD *)WanderTaskByPedType + 2) = v11;
      if ( v11 )
      {
        CEntity::RegisterReference(v11, (CEntity **)WanderTaskByPedType + 2);
        v13 = WanderTaskByPedType[92];
      }
      *((_DWORD *)WanderTaskByPedType + 8) = -1;
      WanderTaskByPedType[92] = v13 & 0xFC;
      *((_DWORD *)WanderTaskByPedType + 15) = 0;
      *((_DWORD *)WanderTaskByPedType + 16) = 0;
      *((_DWORD *)WanderTaskByPedType + 17) = 0;
      return (CTask *)WanderTaskByPedType;
    case 714:
      WanderTaskByPedType = (char *)CTask::operator new(0x14u);
      CTaskComplex::CTaskComplex((CTaskComplex *)WanderTaskByPedType);
      *((_DWORD *)WanderTaskByPedType + 3) = 0;
      v8 = &`vtable for'CTaskComplexLeaveAnyCar;
      *((_WORD *)WanderTaskByPedType + 8) = 1;
      goto LABEL_16;
    case 717:
      WanderTaskByPedType = (char *)CTask::operator new(0xCu);
      CTaskComplex::CTaskComplex((CTaskComplex *)WanderTaskByPedType);
      v8 = &`vtable for'CTaskComplexEnterAnyCarAsDriver;
LABEL_16:
      *(_DWORD *)WanderTaskByPedType = (char *)*v8 + 8;
      break;
    default:
      if ( iSubTaskType == 832 )
      {
        WanderTaskByPedType = (char *)CTask::operator new(0x34u);
        m_pMat = pPed->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &pPed->m_transform;
        CTaskSimpleCreateCarAndGetIn::CTaskSimpleCreateCarAndGetIn(
          (CTaskSimpleCreateCarAndGetIn *)WanderTaskByPedType,
          &p_tx->m_translate,
          this->m_iDesiredCarModel);
      }
      else if ( iSubTaskType == 912 )
      {
        WanderTaskByPedType = (char *)CTaskComplexWander::GetWanderTaskByPedType(pPed);
      }
      break;
  }
  return (CTask *)WanderTaskByPedType;
}
// 66A8F4: using guessed type void *off_66A8F4;
// 66AD08: using guessed type void *off_66AD08;
// 6762B0: using guessed type void *`vtable for'CTaskComplexEnterCarAsDriver;
// 6769E0: using guessed type void *`vtable for'CTaskComplexEnterCarAsPassenger;
// 677740: using guessed type void *`vtable for'CTaskComplexEnterAnyCarAsDriver;
// 677A98: using guessed type void *`vtable for'CTaskComplexLeaveAnyCar;

//----- (004FBCF8) --------------------------------------------------------
CTask *__fastcall CTaskComplexCarDrive::CreateFirstSubTask(CTaskComplexCarDrive *this, CPed *pPed)
{
  CVehicle *m_pMyVehicle; // r0
  const CVehicle *v6; // r1
  CEntity **p_m_pVehicle; // r2
  CVehicle *m_pVehicle; // t1
  bool v9; // zf
  _BOOL4 m_bAsDriver; // r6
  char *v11; // r4
  CVehicle *v12; // r5
  char v13; // r2
  CEntity **v14; // r1
  char v15; // r0
  void **v16; // r0
  bool v17; // zf
  int v18; // r1
  CVehicle *v19; // r5
  char v20; // r0
  char v21; // r0
  CUpsideDownCarCheck v23; // [sp+0h] [bp-40h] BYREF

  m_pMyVehicle = pPed->m_pMyVehicle;
  m_pVehicle = this->m_pVehicle;
  p_m_pVehicle = &this->m_pVehicle;
  v6 = m_pVehicle;
  if ( m_pVehicle )
  {
    v9 = m_pMyVehicle == 0;
    if ( m_pMyVehicle )
      v9 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
    if ( !v9 )
    {
      if ( m_pMyVehicle != v6 )
      {
        v11 = (char *)CTask::operator new(0x14u);
        CTaskComplex::CTaskComplex((CTaskComplex *)v11);
        *((_DWORD *)v11 + 3) = 0;
        v16 = &`vtable for'CTaskComplexLeaveAnyCar;
        *((_WORD *)v11 + 8) = 1;
        goto LABEL_30;
      }
      (*((void (__fastcall **)(CTaskComplexCarDrive *))this->_vptr$CTask + 13))(this);
      v11 = (char *)CTask::operator new(0x60u);
      v19 = this->m_pVehicle;
      CTaskSimple::CTaskSimple((CTaskSimple *)v11);
      goto LABEL_24;
    }
    if ( v6->m_baseVehicleType == 9 )
    {
      m_bAsDriver = this->m_bAsDriver;
      v11 = (char *)CTask::operator new(0x50u);
      v12 = this->m_pVehicle;
      CTaskComplex::CTaskComplex((CTaskComplex *)v11);
      v13 = v11[16];
      *(_DWORD *)v11 = &off_66A8F4;
      *((_DWORD *)v11 + 3) = v12;
      v14 = (CEntity **)(v11 + 12);
      v15 = v13 & 0xF0;
      if ( m_bAsDriver )
      {
        v11[16] = v15 | 1;
        *((_DWORD *)v11 + 9) = 6;
        *((_WORD *)v11 + 20) = 0;
        *((_DWORD *)v11 + 14) = 0;
        v11[60] = 0;
        *((_DWORD *)v11 + 16) = 0;
        v11[68] = 0;
        *((_DWORD *)v11 + 18) = -1082130432;
        *(_QWORD *)(v11 + 20) = 0LL;
        *(_QWORD *)(v11 + 28) = 0LL;
        if ( v12 )
          CEntity::RegisterReference(v12, v14);
        v16 = &`vtable for'CTaskComplexEnterCarAsDriver;
      }
      else
      {
        v11[16] = v15;
        *((_DWORD *)v11 + 9) = 6;
        *((_WORD *)v11 + 20) = 0;
        *((_DWORD *)v11 + 14) = 0;
        v11[60] = 0;
        *((_DWORD *)v11 + 16) = 0;
        v11[68] = 0;
        *((_DWORD *)v11 + 18) = -1082130432;
        *(_QWORD *)(v11 + 20) = 0LL;
        *(_QWORD *)(v11 + 28) = 0LL;
        if ( v12 )
          CEntity::RegisterReference(v12, v14);
        *((_DWORD *)v11 + 7) = 0;
        v16 = &`vtable for'CTaskComplexEnterCarAsPassenger;
      }
      goto LABEL_30;
    }
    if ( !CUpsideDownCarCheck::IsCarUpsideDown(&v23, v6) )
    {
      v18 = 700;
      if ( this->m_bAsDriver )
        v18 = 701;
      return CTaskComplexCarDrive::CreateSubTask(this, v18, pPed);
    }
    if ( this->m_bAsDriver )
    {
      v18 = 717;
      return CTaskComplexCarDrive::CreateSubTask(this, v18, pPed);
    }
    return 0;
  }
  v17 = m_pMyVehicle == 0;
  if ( m_pMyVehicle )
    v17 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
  if ( v17 )
  {
    if ( this->m_bAsDriver )
    {
      v11 = (char *)CTask::operator new(0xCu);
      CTaskComplex::CTaskComplex((CTaskComplex *)v11);
      v16 = &`vtable for'CTaskComplexEnterAnyCarAsDriver;
LABEL_30:
      *(_DWORD *)v11 = (char *)*v16 + 8;
      return (CTask *)v11;
    }
    return 0;
  }
  this->m_pVehicle = m_pMyVehicle;
  CEntity::RegisterReference(m_pMyVehicle, p_m_pVehicle);
  (*((void (__fastcall **)(CTaskComplexCarDrive *))this->_vptr$CTask + 13))(this);
  v11 = (char *)CTask::operator new(0x60u);
  v19 = this->m_pVehicle;
  CTaskSimple::CTaskSimple((CTaskSimple *)v11);
LABEL_24:
  *(_QWORD *)(v11 + 12) = 0LL;
  *(_QWORD *)(v11 + 20) = 0LL;
  *(_DWORD *)v11 = &off_66AD08;
  *((_WORD *)v11 + 14) = 0;
  *(_DWORD *)(v11 + 86) = 0;
  *(_DWORD *)(v11 + 82) = 0;
  v20 = v11[92];
  *((_DWORD *)v11 + 19) = 0;
  v21 = v20 & 0xC3 | 8;
  *((_DWORD *)v11 + 20) = 0;
  v11[92] = v21;
  *((_DWORD *)v11 + 2) = v19;
  if ( v19 )
  {
    CEntity::RegisterReference(v19, (CEntity **)v11 + 2);
    v21 = v11[92];
  }
  *((_DWORD *)v11 + 8) = -1;
  v11[92] = v21 & 0xFC;
  *((_DWORD *)v11 + 15) = 0;
  *((_DWORD *)v11 + 16) = 0;
  *((_DWORD *)v11 + 17) = 0;
  return (CTask *)v11;
}
// 66A8F4: using guessed type void *off_66A8F4;
// 66AD08: using guessed type void *off_66AD08;
// 6762B0: using guessed type void *`vtable for'CTaskComplexEnterCarAsDriver;
// 6769E0: using guessed type void *`vtable for'CTaskComplexEnterCarAsPassenger;
// 677740: using guessed type void *`vtable for'CTaskComplexEnterAnyCarAsDriver;
// 677A98: using guessed type void *`vtable for'CTaskComplexLeaveAnyCar;
// 4FBCF8: using guessed type CUpsideDownCarCheck anonymous_0;

//----- (004FBF08) --------------------------------------------------------
CTask *__fastcall CTaskComplexCarDrive::ControlSubTask(CTaskComplexCarDrive *this, CPed *pPed)
{
  CVehicle *m_pMyVehicle; // r0
  char *m_pSubTask; // r4
  bool v6; // zf
  int v7; // r0
  CVehicle *v9; // r0
  bool v10; // zf
  CVehicle *m_pVehicle; // r5
  char v12; // r0
  char v13; // r0

  m_pMyVehicle = pPed->m_pMyVehicle;
  m_pSubTask = (char *)this->m_pSubTask;
  v6 = m_pMyVehicle == 0;
  if ( m_pMyVehicle )
    v6 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
  if ( !v6 )
  {
    v7 = (*(int (__fastcall **)(CTask *))(*(_DWORD *)m_pSubTask + 20))(this->m_pSubTask);
    if ( v7 == 918 )
    {
      v9 = pPed->m_pMyVehicle;
      v10 = v9 == 0;
      if ( v9 )
        v10 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
      if ( !v10 )
      {
        this->m_pVehicle = v9;
        CEntity::RegisterReference(v9, &this->m_pVehicle);
        (*((void (__fastcall **)(CTaskComplexCarDrive *))this->_vptr$CTask + 13))(this);
        m_pSubTask = (char *)CTask::operator new(0x60u);
        m_pVehicle = this->m_pVehicle;
        CTaskSimple::CTaskSimple((CTaskSimple *)m_pSubTask);
        *(_QWORD *)(m_pSubTask + 12) = 0LL;
        *(_QWORD *)(m_pSubTask + 20) = 0LL;
        *(_DWORD *)m_pSubTask = &off_66AD08;
        *((_WORD *)m_pSubTask + 14) = 0;
        *(_DWORD *)(m_pSubTask + 86) = 0;
        *(_DWORD *)(m_pSubTask + 82) = 0;
        v12 = m_pSubTask[92];
        *((_DWORD *)m_pSubTask + 19) = 0;
        *((_DWORD *)m_pSubTask + 20) = 0;
        v13 = v12 & 0xC3 | 8;
        m_pSubTask[92] = v13;
        *((_DWORD *)m_pSubTask + 2) = m_pVehicle;
        if ( m_pVehicle )
        {
          CEntity::RegisterReference(m_pVehicle, (CEntity **)m_pSubTask + 2);
          v13 = m_pSubTask[92];
        }
        *((_DWORD *)m_pSubTask + 8) = -1;
        m_pSubTask[92] = v13 & 0xFC;
        *((_DWORD *)m_pSubTask + 15) = 0;
        *((_DWORD *)m_pSubTask + 16) = 0;
        *((_DWORD *)m_pSubTask + 17) = 0;
      }
    }
    else if ( v7 == 709 )
    {
      return (CTask *)(*((int (__fastcall **)(CTaskComplexCarDrive *, CPed *))this->_vptr$CTask + 15))(this, pPed);
    }
  }
  return (CTask *)m_pSubTask;
}
// 66AD08: using guessed type void *off_66AD08;

//----- (004FBFF4) --------------------------------------------------------
CTask *__fastcall CTaskComplexCarDrive::CreateSubTaskCannotGetInCar(const CTaskComplexCarDrive *this, CPed *pPed)
{
  return 0;
}

//----- (004FBFF8) --------------------------------------------------------
CTask *__fastcall CTaskComplexCarDrive::Drive(CTaskComplexCarDrive *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (004FBFFC) --------------------------------------------------------
void __fastcall CTaskComplexCarDrive::SetUpCar(const CTaskComplexCarDrive *this)
{
  CVehicle *m_pVehicle; // r1

  m_pVehicle = this->m_pVehicle;
  this->m_origDrivingMode = m_pVehicle->AutoPilot.DrivingMode;
  this->m_origMission = m_pVehicle->AutoPilot.Mission;
  LOBYTE(m_pVehicle) = m_pVehicle->AutoPilot.CruiseSpeed;
  this->m_bIsCarSetUp = 1;
  this->m_origCruiseSpeed = (unsigned __int8)m_pVehicle;
}

//----- (004FC018) --------------------------------------------------------
void __fastcall CTaskComplexCarDriveWander::CTaskComplexCarDriveWander(
        CTaskComplexCarDriveWander *this,
        CVehicle *pVehicle,
        const int iDrivingStyle,
        const float fCruiseSpeed)
{
  CTaskComplex::CTaskComplex(this);
  this->m_fCruiseSpeed = fCruiseSpeed;
  this->m_iDesiredCarModel = -1;
  this->m_iDrivingStyle = iDrivingStyle;
  this->m_bAsDriver = 1;
  this->m_bIsCarSetUp = 0;
  this->_vptr$CTask = (int (**)(void))&off_66AD3C;
  this->m_pVehicle = pVehicle;
  if ( pVehicle )
    CEntity::RegisterReference(pVehicle, &this->m_pVehicle);
  this->_vptr$CTask = (int (**)(void))&off_66AD84;
}
// 66AD3C: using guessed type void *;
// 66AD84: using guessed type void *;

//----- (004FC078) --------------------------------------------------------
void __fastcall CTaskComplexCarDriveWander::~CTaskComplexCarDriveWander(CTaskComplexCarDriveWander *this)
{
  CVehicle *m_pVehicle; // r0
  CEntity **p_m_pVehicle; // r1
  CVehicle *v4; // r0
  void *v5; // r0

  p_m_pVehicle = &this->m_pVehicle;
  m_pVehicle = this->m_pVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AD3C;
  if ( m_pVehicle )
  {
    if ( this->m_bIsCarSetUp )
    {
      m_pVehicle->AutoPilot.DrivingMode = this->m_origDrivingMode;
      this->m_pVehicle->AutoPilot.Mission = this->m_origMission;
      this->m_pVehicle->AutoPilot.CruiseSpeed = this->m_origCruiseSpeed;
      v4 = this->m_pVehicle;
      if ( v4 )
        CEntity::CleanUpOldReference(v4, p_m_pVehicle);
    }
    else
    {
      CEntity::CleanUpOldReference(m_pVehicle, p_m_pVehicle);
    }
  }
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v5);
}
// 4FC0C6: variable 'v5' is possibly undefined
// 66AD3C: using guessed type void *off_66AD3C;

//----- (004FC0D0) --------------------------------------------------------
void __fastcall CTaskComplexCarDriveWander::SetUpCar(const CTaskComplexCarDriveWander *this)
{
  CVehicle *m_pVehicle; // r0
  UInt8 CruiseSpeed; // r2
  int m_nVehicleFlags; // r2
  unsigned int v5; // r5

  m_pVehicle = this->m_pVehicle;
  this->m_origDrivingMode = m_pVehicle->AutoPilot.DrivingMode;
  this->m_origMission = m_pVehicle->AutoPilot.Mission;
  CruiseSpeed = m_pVehicle->AutoPilot.CruiseSpeed;
  this->m_bIsCarSetUp = 1;
  this->m_origCruiseSpeed = CruiseSpeed;
  if ( !CCarCtrl::bCarIsBeingCreated )
  {
    CCarCtrl::JoinCarWithRoadSystem(m_pVehicle);
    this->m_pVehicle->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&this->m_pVehicle->m_info & 7 | 0x18);
    this->m_pVehicle->AutoPilot.Mission = 1;
    this->m_pVehicle->AutoPilot.CruiseSpeed = (unsigned int)this->m_fCruiseSpeed;
    this->m_pVehicle->AutoPilot.ActualSpeed = (float)this->m_pVehicle->AutoPilot.CruiseSpeed;
    this->m_pVehicle->AutoPilot.DrivingMode = this->m_iDrivingStyle;
    m_pVehicle = this->m_pVehicle;
  }
  m_nVehicleFlags = (int)m_pVehicle->m_nVehicleFlags;
  v5 = m_nVehicleFlags & 0xFFFFFFEF;
  if ( (*((_DWORD *)&m_pVehicle->m_nVehicleFlags + 1) & 0x200) == 0 )
    v5 = m_nVehicleFlags | 0x10;
  *(_DWORD *)&m_pVehicle->m_nVehicleFlags = v5;
  this->m_pVehicle->AutoPilot.LastTimeNotStuck = CTimer::m_snTimeInMilliseconds;
}

//----- (004FC174) --------------------------------------------------------
CTask *__fastcall CTaskComplexCarDriveWander::CreateSubTaskCannotGetInCar(
        const CTaskComplexCarDriveWander *this,
        CPed *pPed)
{
  return sub_190340(pPed);
}

//----- (004FC17C) --------------------------------------------------------
void __fastcall CTaskComplexCarDriveMission::CTaskComplexCarDriveMission(
        CTaskComplexCarDriveMission *this,
        CVehicle *pVehicle,
        CEntity *pTargetEntity,
        const int iMission,
        const int iDrivingStyle,
        const float fCruiseSpeed)
{
  CTaskComplex::CTaskComplex(this);
  this->m_fCruiseSpeed = fCruiseSpeed;
  this->m_iDesiredCarModel = -1;
  this->m_iDrivingStyle = iDrivingStyle;
  this->m_bAsDriver = 1;
  this->m_bIsCarSetUp = 0;
  this->_vptr$CTask = (int (**)(void))&off_66AD3C;
  this->m_pVehicle = pVehicle;
  if ( pVehicle )
    CEntity::RegisterReference(pVehicle, &this->m_pVehicle);
  this->m_iMission = iMission;
  this->_vptr$CTask = (int (**)(void))&off_66ADCC;
  this->m_pTargetEntity = pTargetEntity;
  if ( pTargetEntity )
    CEntity::RegisterReference(pTargetEntity, &this->m_pTargetEntity);
}
// 66AD3C: using guessed type void *off_66AD3C;
// 66ADCC: using guessed type void *;

//----- (004FC1FC) --------------------------------------------------------
void __fastcall CTaskComplexCarDriveMission::~CTaskComplexCarDriveMission(CTaskComplexCarDriveMission *this)
{
  CEntity *m_pTargetEntity; // r0
  CEntity **p_m_pTargetEntity; // r1
  CVehicle *m_pVehicle; // r0
  CEntity **p_m_pVehicle; // r1
  CVehicle *v6; // r0
  void *v7; // r0

  p_m_pTargetEntity = &this->m_pTargetEntity;
  m_pTargetEntity = this->m_pTargetEntity;
  this->_vptr$CTask = (int (**)(void))&off_66ADCC;
  if ( m_pTargetEntity )
    CEntity::CleanUpOldReference(m_pTargetEntity, p_m_pTargetEntity);
  p_m_pVehicle = &this->m_pVehicle;
  m_pVehicle = this->m_pVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AD3C;
  if ( m_pVehicle )
  {
    if ( this->m_bIsCarSetUp )
    {
      m_pVehicle->AutoPilot.DrivingMode = this->m_origDrivingMode;
      this->m_pVehicle->AutoPilot.Mission = this->m_origMission;
      this->m_pVehicle->AutoPilot.CruiseSpeed = this->m_origCruiseSpeed;
      v6 = this->m_pVehicle;
      if ( v6 )
        CEntity::CleanUpOldReference(v6, p_m_pVehicle);
    }
    else
    {
      CEntity::CleanUpOldReference(m_pVehicle, p_m_pVehicle);
    }
  }
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v7);
}
// 4FC262: variable 'v7' is possibly undefined
// 66AD3C: using guessed type void *off_66AD3C;
// 66ADCC: using guessed type void *off_66ADCC;

//----- (004FC270) --------------------------------------------------------
void __fastcall CTaskComplexCarDriveMission::SetUpCar(const CTaskComplexCarDriveMission *this)
{
  CVehicle *m_pVehicle; // r0
  UInt8 CruiseSpeed; // r1
  CEntity *m_pTargetEntity; // r0
  CVehicle *v5; // r0
  int m_nVehicleFlags; // r1
  int v7; // r2
  unsigned int v8; // r3

  m_pVehicle = this->m_pVehicle;
  this->m_origDrivingMode = m_pVehicle->AutoPilot.DrivingMode;
  this->m_origMission = m_pVehicle->AutoPilot.Mission;
  CruiseSpeed = m_pVehicle->AutoPilot.CruiseSpeed;
  this->m_bIsCarSetUp = 1;
  this->m_origCruiseSpeed = CruiseSpeed;
  CCarCtrl::JoinCarWithRoadSystem(m_pVehicle);
  this->m_pVehicle->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&this->m_pVehicle->m_info & 7 | 0x18);
  this->m_pVehicle->AutoPilot.Mission = this->m_iMission;
  this->m_pVehicle->AutoPilot.CruiseSpeed = (unsigned int)this->m_fCruiseSpeed;
  this->m_pVehicle->AutoPilot.ActualSpeed = (float)this->m_pVehicle->AutoPilot.CruiseSpeed;
  this->m_pVehicle->AutoPilot.DrivingMode = this->m_iDrivingStyle;
  this->m_pVehicle->AutoPilot.pTargetEntity = this->m_pTargetEntity;
  this->m_pVehicle->AutoPilot.LastTimeNotStuck = CTimer::m_snTimeInMilliseconds;
  m_pTargetEntity = this->m_pTargetEntity;
  if ( m_pTargetEntity )
    CEntity::RegisterReference(m_pTargetEntity, &this->m_pVehicle->AutoPilot.pTargetEntity);
  v5 = this->m_pVehicle;
  m_nVehicleFlags = (int)v5->m_nVehicleFlags;
  v7 = *((_DWORD *)&v5->m_nVehicleFlags + 1);
  v8 = m_nVehicleFlags & 0xFFFFFFEF;
  if ( (v7 & 0x200) == 0 )
    v8 = m_nVehicleFlags | 0x10;
  *(_DWORD *)&v5->m_nVehicleFlags = v8;
  *((_DWORD *)&v5->m_nVehicleFlags + 1) = v7;
}

//----- (004FC324) --------------------------------------------------------
void __fastcall CTaskComplexDriveToPoint::CTaskComplexDriveToPoint(
        CTaskComplexDriveToPoint *this,
        CVehicle *pVehicle,
        const CVector *vTarget,
        const float fCruiseSpeed,
        const int iMode,
        const int iDesiredCarModel,
        const float fTargetRadius,
        const int iDrivingStyle)
{
  __int64 v12; // d16

  CTaskComplex::CTaskComplex(this);
  this->m_fCruiseSpeed = fCruiseSpeed;
  this->m_iDesiredCarModel = iDesiredCarModel;
  this->m_iDrivingStyle = iDrivingStyle;
  this->m_bAsDriver = 1;
  this->m_bIsCarSetUp = 0;
  this->_vptr$CTask = (int (**)(void))&off_66AD3C;
  this->m_pVehicle = pVehicle;
  if ( pVehicle )
    CEntity::RegisterReference(pVehicle, &this->m_pVehicle);
  this->_vptr$CTask = (int (**)(void))&off_66AE14;
  v12 = *(_QWORD *)&vTarget->x;
  this->m_vTarget.z = vTarget->z;
  this->m_iMode = iMode;
  this->m_fTargetRadius = fTargetRadius;
  this->m_bAchievedTarget = 0;
  *(_QWORD *)&this->m_vTarget.x = v12;
}
// 66AD3C: using guessed type void *off_66AD3C;
// 66AE14: using guessed type void *;

//----- (004FC3AC) --------------------------------------------------------
void __fastcall CTaskComplexDriveToPoint::~CTaskComplexDriveToPoint(CTaskComplexDriveToPoint *this)
{
  CVehicle *m_pVehicle; // r0
  CEntity **p_m_pVehicle; // r1
  CVehicle *v4; // r0
  void *v5; // r0

  p_m_pVehicle = &this->m_pVehicle;
  m_pVehicle = this->m_pVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AD3C;
  if ( m_pVehicle )
  {
    if ( this->m_bIsCarSetUp )
    {
      m_pVehicle->AutoPilot.DrivingMode = this->m_origDrivingMode;
      this->m_pVehicle->AutoPilot.Mission = this->m_origMission;
      this->m_pVehicle->AutoPilot.CruiseSpeed = this->m_origCruiseSpeed;
      v4 = this->m_pVehicle;
      if ( v4 )
        CEntity::CleanUpOldReference(v4, p_m_pVehicle);
    }
    else
    {
      CEntity::CleanUpOldReference(m_pVehicle, p_m_pVehicle);
    }
  }
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v5);
}
// 4FC3FA: variable 'v5' is possibly undefined
// 66AD3C: using guessed type void *off_66AD3C;

//----- (004FC404) --------------------------------------------------------
CTask *__fastcall CTaskComplexDriveToPoint::CreateSubTaskCannotGetInCar(
        const CTaskComplexDriveToPoint *this,
        CPed *pPed)
{
  CTaskComplexGoToPointAnyMeans *v3; // r0
  CTask *result; // r0

  v3 = (CTaskComplexGoToPointAnyMeans *)CTask::operator new(0x34u);
  CTaskComplexGoToPointAnyMeans::CTaskComplexGoToPointAnyMeans(v3, 6, &this->m_vTarget, 0.5, this->m_iDesiredCarModel);
  return result;
}

//----- (004FC430) --------------------------------------------------------
void __fastcall CTaskComplexDriveToPoint::SetUpCar(const CTaskComplexDriveToPoint *this)
{
  CVehicle *m_pVehicle; // r1
  float m_fCruiseSpeed; // s0
  UInt8 CruiseSpeed; // r2

  m_pVehicle = this->m_pVehicle;
  this->m_origDrivingMode = m_pVehicle->AutoPilot.DrivingMode;
  m_fCruiseSpeed = this->m_fCruiseSpeed;
  this->m_origMission = m_pVehicle->AutoPilot.Mission;
  CruiseSpeed = m_pVehicle->AutoPilot.CruiseSpeed;
  this->m_bIsCarSetUp = 1;
  this->m_origCruiseSpeed = CruiseSpeed;
  if ( m_fCruiseSpeed > 0.0 )
  {
    m_pVehicle->AutoPilot.CruiseSpeed = (unsigned int)m_fCruiseSpeed;
    m_pVehicle = this->m_pVehicle;
  }
  m_pVehicle->AutoPilot.DrivingMode = this->m_iDrivingStyle;
  this->m_pVehicle->AutoPilot.LastTimeNotStuck = CTimer::m_snTimeInMilliseconds;
}

//----- (004FC480) --------------------------------------------------------
CTask *__fastcall CTaskComplexDriveToPoint::Drive(CTaskComplexDriveToPoint *this, CPed *pPed)
{
  CVehicle *m_pVehicle; // r0
  float x; // s0
  float y; // s4
  CMatrix *m_pMat; // r1
  float z; // s2
  float *p_tx; // r2
  float v10; // s6
  CTask *m_pSubTask; // r4
  CMatrix *v12; // r0
  CSimpleTransform *p_m_transform; // r1
  CVector *p_m_vTarget; // r1
  CPedIntelligence *m_pPedIntelligence; // r8

  m_pVehicle = this->m_pVehicle;
  x = this->m_vTarget.x;
  y = this->m_vTarget.y;
  m_pMat = m_pVehicle->m_pMat;
  z = this->m_vTarget.z;
  p_tx = &m_pMat->tx;
  if ( !m_pMat )
    p_tx = &m_pVehicle->m_transform.m_translate.x;
  v10 = sqrtf(
          (float)((float)((float)(x - *p_tx) * (float)(x - *p_tx)) + (float)((float)(y - p_tx[1]) * (float)(y - p_tx[1])))
        + (float)((float)(z - p_tx[2]) * (float)(z - p_tx[2])));
  if ( v10 < this->m_fTargetRadius )
  {
    m_pSubTask = 0;
    m_pVehicle->AutoPilot.Mission = 0;
LABEL_17:
    this->m_bAchievedTarget = 1;
    return m_pSubTask;
  }
  m_pSubTask = this->m_pSubTask;
  if ( v10 < 3.0 && !m_pVehicle->AutoPilot.Mission )
    goto LABEL_16;
  if ( !m_pVehicle->AutoPilot.CruiseSpeed )
  {
    m_pVehicle->AutoPilot.CruiseSpeed = (unsigned int)this->m_fCruiseSpeed;
    x = this->m_vTarget.x;
    y = this->m_vTarget.y;
    z = this->m_vTarget.z;
  }
  v12 = pPed->m_pMat;
  p_m_transform = (CSimpleTransform *)&v12->tx;
  if ( !v12 )
    p_m_transform = &pPed->m_transform;
  if ( (float)((float)((float)((float)(p_m_transform->m_translate.x - x) * (float)(p_m_transform->m_translate.x - x))
                     + (float)((float)(p_m_transform->m_translate.y - y) * (float)(p_m_transform->m_translate.y - y)))
             + (float)((float)(p_m_transform->m_translate.z - z) * (float)(p_m_transform->m_translate.z - z))) <= 36.0 )
  {
    m_pPedIntelligence = pPed->m_pPedIntelligence;
    if ( CTaskComplexDriveToPoint::IsTargetBlocked(this, pPed, m_pPedIntelligence->m_pedScanner.m_entities, 16)
      || CTaskComplexDriveToPoint::IsTargetBlocked(this, pPed, m_pPedIntelligence->m_vehicleScanner.m_entities, 16) )
    {
LABEL_16:
      m_pSubTask = 0;
      goto LABEL_17;
    }
  }
  p_m_vTarget = &this->m_vTarget;
  switch ( this->m_iMode )
  {
    case 0:
      CCarAI::GetCarToGoToCoors(this->m_pVehicle, p_m_vTarget, this->m_iDrivingStyle, 0);
      break;
    case 1:
      CCarAI::GetCarToGoToCoorsAccurate(this->m_pVehicle, p_m_vTarget, this->m_iDrivingStyle, 0);
      break;
    case 2:
      CCarAI::GetCarToGoToCoorsStraightLine(this->m_pVehicle, p_m_vTarget, this->m_iDrivingStyle, 0);
      break;
    case 3:
      CCarAI::GetCarToGoToCoorsRacing(this->m_pVehicle, p_m_vTarget, this->m_iDrivingStyle, 0);
      break;
    default:
      return m_pSubTask;
  }
  return m_pSubTask;
}

//----- (004FC5EC) --------------------------------------------------------
bool __fastcall CTaskComplexDriveToPoint::IsTargetBlocked(const CTaskComplexDriveToPoint *this, CPed *pPed)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float32x2_t v6; // d16
  unsigned __int64 v7; // d1
  CPedIntelligence *m_pPedIntelligence; // r6

  m_pMat = pPed->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  v6.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.y, *(float32x2_t *)&this->m_vTarget.y).n64_u64[0];
  v7 = vmul_f32(v6, v6).n64_u64[0];
  if ( (float)((float)((float)((float)(p_tx->m_translate.x - this->m_vTarget.x)
                             * (float)(p_tx->m_translate.x - this->m_vTarget.x))
                     + *(float *)&v7)
             + *((float *)&v7 + 1)) > 36.0 )
    return 0;
  m_pPedIntelligence = pPed->m_pPedIntelligence;
  return CTaskComplexDriveToPoint::IsTargetBlocked(this, pPed, m_pPedIntelligence->m_pedScanner.m_entities, 16)
      || CTaskComplexDriveToPoint::IsTargetBlocked(this, pPed, m_pPedIntelligence->m_vehicleScanner.m_entities, 16);
}

//----- (004FC678) --------------------------------------------------------
bool __fastcall CTaskComplexDriveToPoint::IsTargetBlocked(
        const CTaskComplexDriveToPoint *this,
        CPed *pPed,
        CEntity **ppEntities,
        const int N)
{
  CVehicle *m_pMyVehicle; // lr
  CMatrix *m_pMat; // r12
  float *p_tx; // r1
  float x; // s0
  float y; // s2
  float z; // s4
  float v10; // s6
  int v11; // r0
  double v12; // d16
  CEntity *v13; // r1
  bool v14; // zf
  CMatrix *v15; // r4
  float *p_x; // r5
  float m_fRadius; // s8

  m_pMyVehicle = pPed->m_pMyVehicle;
  if ( !m_pMyVehicle )
    return 0;
  m_pMat = m_pMyVehicle->m_pMat;
  p_tx = &m_pMat->tx;
  if ( !m_pMat )
    p_tx = &m_pMyVehicle->m_transform.m_translate.x;
  if ( N < 1 )
    return 0;
  x = this->m_vTarget.x;
  y = this->m_vTarget.y;
  z = this->m_vTarget.z;
  v11 = 0;
  v12 = (float)((float)((float)((float)(*p_tx - x) * (float)(*p_tx - x))
                      + (float)((float)(p_tx[1] - y) * (float)(p_tx[1] - y)))
              + (float)((float)(p_tx[2] - z) * (float)(p_tx[2] - z)));
  while ( 1 )
  {
    v13 = ppEntities[v11];
    v14 = v13 == 0;
    if ( v13 )
      v14 = v13 == m_pMyVehicle;
    if ( !v14 )
    {
      v15 = v13->m_pMat;
      p_x = &v15->tx;
      if ( !v15 )
        p_x = &v13->m_transform.m_translate.x;
      m_fRadius = CModelInfo::ms_modelInfoPtrs[v13->m_nModelIndex]->m_pColModel->m_sphereBound.m_fRadius;
      if ( (float)((float)((float)((float)(*p_x - x) * (float)(*p_x - x))
                         + (float)((float)(p_x[1] - y) * (float)(p_x[1] - y)))
                 + (float)((float)(p_x[2] - z) * (float)(p_x[2] - z))) < (float)(m_fRadius * m_fRadius) )
      {
        v10 = CModelInfo::ms_modelInfoPtrs[m_pMyVehicle->m_nModelIndex]->m_pColModel->m_sphereBound.m_fRadius;
        if ( (float)((float)(v10 + m_fRadius) * (float)(v10 + m_fRadius)) * 1.5 > v12 )
          break;
      }
    }
    if ( ++v11 >= N )
      return 0;
  }
  return 1;
}

//----- (004FC790) --------------------------------------------------------
void __fastcall CTaskComplexDrivePointRoute::CTaskComplexDrivePointRoute(
        CTaskComplexDrivePointRoute *this,
        CVehicle *pVehicle,
        const CPointRoute *route,
        const float fCruiseSpeed,
        const int iMode,
        const int iDesiredCarModel,
        const float fTargetRadius,
        const int iDrivingStyle)
{
  float v12; // s18
  CPointRoute *v13; // r0
  int m_iRouteSize; // r1
  CVector *m_routePoints; // r1
  CVector *v16; // r2
  int v17; // r3
  __int64 v18; // d16
  RwReal z; // r6

  CTaskComplex::CTaskComplex(this);
  v12 = fCruiseSpeed;
  this->m_pVehicle = pVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AE5C;
  v13 = (CPointRoute *)CPointRoute::operator new(0x64u);
  m_iRouteSize = route->m_iRouteSize;
  v13->m_iRouteSize = route->m_iRouteSize;
  if ( m_iRouteSize >= 1 )
  {
    m_routePoints = route->m_routePoints;
    v16 = v13->m_routePoints;
    v17 = 0;
    do
    {
      v18 = *(_QWORD *)&m_routePoints->x;
      ++v17;
      z = m_routePoints->z;
      ++m_routePoints;
      v16->z = z;
      *(_QWORD *)&v16->x = v18;
      ++v16;
    }
    while ( v17 < v13->m_iRouteSize );
  }
  this->m_fCruiseSpeed = v12;
  this->m_pRoute = v13;
  this->m_iMode = iMode;
  this->m_iDesiredCarModel = iDesiredCarModel;
  this->m_fTargetRadius = fTargetRadius;
  this->m_iDrivingStyle = iDrivingStyle;
  this->m_iProgress = 0;
}
// 66AE5C: using guessed type void *;

//----- (004FC81C) --------------------------------------------------------
void __fastcall CTaskComplexDrivePointRoute::~CTaskComplexDrivePointRoute(CTaskComplexDrivePointRoute *this)
{
  CPointRoute *m_pRoute; // r0

  m_pRoute = this->m_pRoute;
  this->_vptr$CTask = (int (**)(void))&off_66AE5C;
  if ( m_pRoute )
    CPointRoute::operator delete(m_pRoute);
  sub_18EDB4(this);
}
// 66AE5C: using guessed type void *off_66AE5C;

//----- (004FC844) --------------------------------------------------------
void __fastcall CTaskComplexDrivePointRoute::~CTaskComplexDrivePointRoute(CTaskComplexDrivePointRoute *this)
{
  CPointRoute *m_pRoute; // r0
  void *v3; // r0

  m_pRoute = this->m_pRoute;
  this->_vptr$CTask = (int (**)(void))&off_66AE5C;
  if ( m_pRoute )
    CPointRoute::operator delete(m_pRoute);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v3);
}
// 4FC868: variable 'v3' is possibly undefined
// 66AE5C: using guessed type void *off_66AE5C;

//----- (004FC870) --------------------------------------------------------
CTask *__fastcall CTaskComplexDrivePointRoute::CreateNextSubTask(CTaskComplexDrivePointRoute *this, CPed *pPed)
{
  char *v3; // r4
  int m_iProgress; // r1
  CPointRoute *m_pRoute; // r0
  __int64 v6; // kr00_8
  __int64 v7; // kr08_8
  __int64 v8; // r8
  int v9; // r6
  __int64 v10; // kr18_8
  int v11; // r6
  __int64 v12; // d16
  float m_fTargetRadius; // [sp+4h] [bp-24h]
  int m_iMode; // [sp+8h] [bp-20h]

  v3 = 0;
  m_iProgress = this->m_iProgress;
  m_pRoute = this->m_pRoute;
  this->m_iProgress = ++m_iProgress;
  if ( m_iProgress != m_pRoute->m_iRouteSize )
  {
    v3 = (char *)CTask::operator new(0x3Cu);
    v6 = *(_QWORD *)&this->m_pVehicle;
    v7 = *(_QWORD *)&this->m_fCruiseSpeed;
    m_iMode = this->m_iMode;
    LODWORD(v8) = this->m_iDesiredCarModel;
    m_fTargetRadius = this->m_fTargetRadius;
    v10 = *(_QWORD *)&this->m_iDrivingStyle;
    v9 = this->m_iProgress;
    HIDWORD(v8) = v10;
    CTaskComplex::CTaskComplex((CTaskComplex *)v3);
    *(_QWORD *)(v3 + 20) = v8;
    v3[28] = 1;
    v3[32] = 0;
    *((_DWORD *)v3 + 4) = v7;
    *(_DWORD *)v3 = &off_66AD3C;
    *((_DWORD *)v3 + 3) = v6;
    v11 = HIDWORD(v6) + 12 * v9 + 4;
    if ( (_DWORD)v6 )
      CEntity::RegisterReference((CEntity *)v6, (CEntity **)v3 + 3);
    *(_DWORD *)v3 = &off_66AE14;
    v12 = *(_QWORD *)v11;
    *((_DWORD *)v3 + 11) = *(_DWORD *)(v11 + 8);
    *((_DWORD *)v3 + 12) = m_iMode;
    *((float *)v3 + 13) = m_fTargetRadius;
    v3[56] = 0;
    *(_QWORD *)(v3 + 36) = v12;
  }
  return (CTask *)v3;
}
// 66AD3C: using guessed type void *off_66AD3C;
// 66AE14: using guessed type void *off_66AE14;

//----- (004FC920) --------------------------------------------------------
CTask *__fastcall CTaskComplexDrivePointRoute::CreateFirstSubTask(CTaskComplexDrivePointRoute *this, CPed *pPed)
{
  char *v3; // r4
  __int64 v4; // kr00_8
  __int64 v5; // kr08_8
  __int64 v6; // r8
  int m_iProgress; // r6
  __int64 v8; // kr18_8
  int v9; // r6
  __int64 v10; // d16
  CTask *result; // r0
  float m_fTargetRadius; // [sp+4h] [bp-24h]
  int m_iMode; // [sp+8h] [bp-20h]

  v3 = (char *)CTask::operator new(0x3Cu);
  v4 = *(_QWORD *)&this->m_pVehicle;
  v5 = *(_QWORD *)&this->m_fCruiseSpeed;
  m_iMode = this->m_iMode;
  LODWORD(v6) = this->m_iDesiredCarModel;
  m_fTargetRadius = this->m_fTargetRadius;
  v8 = *(_QWORD *)&this->m_iDrivingStyle;
  m_iProgress = this->m_iProgress;
  HIDWORD(v6) = v8;
  CTaskComplex::CTaskComplex((CTaskComplex *)v3);
  *(_QWORD *)(v3 + 20) = v6;
  v3[28] = 1;
  v3[32] = 0;
  *((_DWORD *)v3 + 4) = v5;
  *(_DWORD *)v3 = &off_66AD3C;
  *((_DWORD *)v3 + 3) = v4;
  v9 = HIDWORD(v4) + 12 * m_iProgress + 4;
  if ( (_DWORD)v4 )
    CEntity::RegisterReference((CEntity *)v4, (CEntity **)v3 + 3);
  *(_DWORD *)v3 = &off_66AE14;
  v10 = *(_QWORD *)v9;
  *((_DWORD *)v3 + 11) = *(_DWORD *)(v9 + 8);
  *((_DWORD *)v3 + 12) = m_iMode;
  *((float *)v3 + 13) = m_fTargetRadius;
  result = (CTask *)v3;
  v3[56] = 0;
  *(_QWORD *)(v3 + 36) = v10;
  return result;
}
// 66AD3C: using guessed type void *off_66AD3C;
// 66AE14: using guessed type void *off_66AE14;

//----- (004FC9C0) --------------------------------------------------------
CTask *__fastcall CTaskComplexDrivePointRoute::ControlSubTask(CTaskComplexDrivePointRoute *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (004FC9C4) --------------------------------------------------------
void __fastcall CTaskComplexEnterAnyCarAsDriver::CTaskComplexEnterAnyCarAsDriver(CTaskComplexEnterAnyCarAsDriver *this)
{
  _DWORD *v1; // r0

  CTaskComplex::CTaskComplex(this);
  *v1 = &off_66AE98;
}
// 4FC9D4: variable 'v1' is possibly undefined
// 66AE98: using guessed type void *off_66AE98;
// 677740: using guessed type void *`vtable for'CTaskComplexEnterAnyCarAsDriver;

//----- (004FC9E0) --------------------------------------------------------
void __fastcall CTaskComplexEnterAnyCarAsDriver::~CTaskComplexEnterAnyCarAsDriver(
        CTaskComplexEnterAnyCarAsDriver *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 4FC9EC: variable 'v1' is possibly undefined

//----- (004FC9F0) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterAnyCarAsDriver::CreateNextSubTask(CTaskComplexEnterAnyCarAsDriver *this, CPed *pPed)
{
  return 0;
}

//----- (004FC9F4) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterAnyCarAsDriver::CreateFirstSubTask(
        CTaskComplexEnterAnyCarAsDriver *this,
        CPed *pPed)
{
  CVehicle *ClosestVehicleInRange; // r0
  CEntity *v4; // r4
  char *v5; // r5
  char v6; // r2
  void **v7; // r0
  CEntity *v8; // r8
  float v9; // s16
  int v10; // r4
  CEntity **m_entities; // r9
  CEntity *v12; // r6
  CMatrix *m_pMat; // r0
  CMatrix *v14; // r1
  CSimpleTransform *p_tx; // r2
  CSimpleTransform *p_m_transform; // r0
  float32x2_t v17; // d16
  unsigned __int64 v18; // d1
  float v19; // s18
  char v20; // r2

  ClosestVehicleInRange = CVehicleScanner::GetClosestVehicleInRange(&pPed->m_pPedIntelligence->m_vehicleScanner);
  v4 = ClosestVehicleInRange;
  if ( ClosestVehicleInRange && CCarEnterExit::IsVehicleStealable(ClosestVehicleInRange, pPed) )
  {
    v5 = (char *)CTask::operator new(0x50u);
    CTaskComplex::CTaskComplex((CTaskComplex *)v5);
    *(_QWORD *)(v5 + 20) = 0LL;
    *(_QWORD *)(v5 + 28) = 0LL;
    *((_DWORD *)v5 + 9) = 6;
    *((_WORD *)v5 + 20) = 0;
    *((_DWORD *)v5 + 14) = 0;
    v5[60] = 0;
    *((_DWORD *)v5 + 16) = 0;
    v5[68] = 0;
    v6 = v5[16];
    *((_DWORD *)v5 + 18) = -1082130432;
    *(_DWORD *)v5 = &off_66A8F4;
    v5[16] = v6 & 0xF0 | 1;
    *((_DWORD *)v5 + 3) = v4;
    CEntity::RegisterReference(v4, (CEntity **)v5 + 3);
    v7 = &`vtable for'CTaskComplexEnterCarAsDriver;
  }
  else
  {
    v8 = 0;
    v9 = 3.4028e38;
    v10 = 0;
    m_entities = pPed->m_pPedIntelligence->m_vehicleScanner.m_entities;
    do
    {
      v12 = m_entities[v10];
      if ( v12 )
      {
        m_pMat = v12->m_pMat;
        v14 = pPed->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &v12->m_transform;
        p_m_transform = (CSimpleTransform *)&v14->tx;
        if ( !v14 )
          p_m_transform = &pPed->m_transform;
        v17.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
        v18 = vmul_f32(v17, v17).n64_u64[0];
        v19 = (float)((float)((float)(p_m_transform->m_translate.x - p_tx->m_translate.x)
                            * (float)(p_m_transform->m_translate.x - p_tx->m_translate.x))
                    + *(float *)&v18)
            + *((float *)&v18 + 1);
        if ( v19 < v9 && CCarEnterExit::IsVehicleStealable((const CVehicle *)m_entities[v10], pPed) )
        {
          v9 = v19;
          v8 = v12;
        }
      }
      ++v10;
    }
    while ( v10 != 16 );
    if ( v8 )
    {
      v5 = (char *)CTask::operator new(0x50u);
      CTaskComplex::CTaskComplex((CTaskComplex *)v5);
      *(_QWORD *)(v5 + 20) = 0LL;
      *(_QWORD *)(v5 + 28) = 0LL;
      *((_DWORD *)v5 + 9) = 6;
      *((_WORD *)v5 + 20) = 0;
      *((_DWORD *)v5 + 14) = 0;
      v5[60] = 0;
      *((_DWORD *)v5 + 16) = 0;
      v5[68] = 0;
      v20 = v5[16];
      *((_DWORD *)v5 + 18) = -1082130432;
      *(_DWORD *)v5 = &off_66A8F4;
      v5[16] = v20 & 0xF0 | 1;
      *((_DWORD *)v5 + 3) = v8;
      CEntity::RegisterReference(v8, (CEntity **)v5 + 3);
      v7 = &`vtable for'CTaskComplexEnterCarAsDriver;
    }
    else
    {
      v5 = (char *)CTask::operator new(8u);
      CTaskSimple::CTaskSimple((CTaskSimple *)v5);
      v7 = &`vtable for'CTaskSimpleNone;
    }
  }
  *(_DWORD *)v5 = (char *)*v7 + 8;
  return (CTask *)v5;
}
// 66A8F4: using guessed type void *off_66A8F4;
// 6762B0: using guessed type void *`vtable for'CTaskComplexEnterCarAsDriver;
// 678150: using guessed type void *`vtable for'CTaskSimpleNone;

//----- (004FCB90) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterAnyCarAsDriver::ControlSubTask(CTaskComplexEnterAnyCarAsDriver *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (004FCB94) --------------------------------------------------------
void __fastcall CTaskComplexShuffleSeats::CTaskComplexShuffleSeats(
        CTaskComplexShuffleSeats *this,
        CVehicle *pTargetVehicle)
{
  CTaskComplex::CTaskComplex(this);
  this->m_pTaskUtilityLineUpPedWithCar = 0;
  this->m_bIsAborting = 0;
  this->_vptr$CTask = (int (**)(void))&off_66AED4;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66AED4: using guessed type void *;

//----- (004FCBCC) --------------------------------------------------------
void __fastcall CTaskComplexShuffleSeats::~CTaskComplexShuffleSeats(CTaskComplexShuffleSeats *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CTaskUtilityLineUpPedWithCar *m_pTaskUtilityLineUpPedWithCar; // r0
  void *v5; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AED4;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pTaskUtilityLineUpPedWithCar = this->m_pTaskUtilityLineUpPedWithCar;
  if ( m_pTaskUtilityLineUpPedWithCar )
  {
    CTaskUtilityLineUpPedWithCar::~CTaskUtilityLineUpPedWithCar(m_pTaskUtilityLineUpPedWithCar);
    operator delete(v5);
  }
  sub_18EDB4(this);
}
// 4FCBF2: variable 'v5' is possibly undefined
// 66AED4: using guessed type void *off_66AED4;

//----- (004FCC04) --------------------------------------------------------
void __fastcall CTaskComplexShuffleSeats::~CTaskComplexShuffleSeats(CTaskComplexShuffleSeats *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CTaskUtilityLineUpPedWithCar *m_pTaskUtilityLineUpPedWithCar; // r0
  void *v5; // r0
  void *v6; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AED4;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pTaskUtilityLineUpPedWithCar = this->m_pTaskUtilityLineUpPedWithCar;
  if ( m_pTaskUtilityLineUpPedWithCar )
  {
    CTaskUtilityLineUpPedWithCar::~CTaskUtilityLineUpPedWithCar(m_pTaskUtilityLineUpPedWithCar);
    operator delete(v5);
  }
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v6);
}
// 4FCC2A: variable 'v5' is possibly undefined
// 4FCC38: variable 'v6' is possibly undefined
// 66AED4: using guessed type void *off_66AED4;

//----- (004FCC40) --------------------------------------------------------
bool __fastcall CTaskComplexShuffleSeats::MakeAbortable(
        CTaskComplexShuffleSeats *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  if ( iPriority == 2 )
    return (*((int (__fastcall **)(CTask *, CPed *, int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
             this->m_pSubTask,
             pPed,
             2,
             pEvent);
  else
    return 0;
}

//----- (004FCC54) --------------------------------------------------------
CTask *__fastcall CTaskComplexShuffleSeats::CreateSubTask(
        CTaskComplexShuffleSeats *this,
        const int iSubTaskType,
        CPed *pPed)
{
  CTask *result; // r0
  CTaskSimpleCarShuffle *v6; // r0
  CVehicle *m_pTargetVehicle; // r0
  CTaskSimpleCarSetPedInAsDriver *v8; // r0
  int v9; // r4
  CTaskSimpleCarSetPedOut *v10; // r0
  CTaskSimpleCarSetPedInAsPassenger *v11; // r0

  result = 0;
  switch ( iSubTaskType )
  {
    case 808:
      v6 = (CTaskSimpleCarShuffle *)CTask::operator new(0x1Cu);
      CTaskSimpleCarShuffle::CTaskSimpleCarShuffle(
        v6,
        this->m_pTargetVehicle,
        this->m_iStartDoor,
        this->m_pTaskUtilityLineUpPedWithCar);
      break;
    case 809:
    case 810:
    case 813:
    case 814:
    case 815:
      return result;
    case 811:
      m_pTargetVehicle = this->m_pTargetVehicle;
      if ( m_pTargetVehicle->pDriver == pPed )
        CVehicle::RemoveDriver(m_pTargetVehicle, 1);
      else
        CVehicle::RemovePassenger(m_pTargetVehicle, pPed);
      v11 = (CTaskSimpleCarSetPedInAsPassenger *)CTask::operator new(0x20u);
      CTaskSimpleCarSetPedInAsPassenger::CTaskSimpleCarSetPedInAsPassenger(
        v11,
        this->m_pTargetVehicle,
        this->m_iDestinationDoor,
        this->m_pTaskUtilityLineUpPedWithCar);
      break;
    case 812:
      CVehicle::RemovePassenger(this->m_pTargetVehicle, pPed);
      v8 = (CTaskSimpleCarSetPedInAsDriver *)CTask::operator new(0x1Cu);
      CTaskSimpleCarSetPedInAsDriver::CTaskSimpleCarSetPedInAsDriver(
        v8,
        this->m_pTargetVehicle,
        this->m_pTaskUtilityLineUpPedWithCar);
      break;
    case 816:
      v9 = CCarEnterExit::ComputeTargetDoorToExit(pPed->m_pMyVehicle, pPed);
      v10 = (CTaskSimpleCarSetPedOut *)CTask::operator new(0x18u);
      CTaskSimpleCarSetPedOut::CTaskSimpleCarSetPedOut(v10, pPed->m_pMyVehicle, v9, 1);
      break;
    default:
      if ( iSubTaskType == 1302 )
      {
        if ( pPed )
        {
          if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
            *(_DWORD *)&pPed->m_nFlags |= 1u;
          result = 0;
        }
        else
        {
          result = 0;
        }
      }
      break;
  }
  return result;
}

//----- (004FCD10) --------------------------------------------------------
CTask *__fastcall CTaskComplexShuffleSeats::CreateNextSubTask(CTaskComplexShuffleSeats *this, CPed *pPed)
{
  _BOOL4 m_bIsAborting; // r6
  int v5; // r1
  CTask *result; // r0
  int v7; // r5
  CTaskSimpleCarSetPedOut *v8; // r0
  unsigned int v9; // r0
  int m_iDestinationDoor; // r1
  CVehicle *m_pTargetVehicle; // r0
  CTaskSimpleCarSetPedInAsDriver *v12; // r0
  int v13; // r0
  int v14; // r1

  m_bIsAborting = this->m_bIsAborting;
  v5 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  result = 0;
  if ( m_bIsAborting )
  {
    switch ( v5 )
    {
      case 808:
      case 811:
      case 812:
        v7 = CCarEnterExit::ComputeTargetDoorToExit(pPed->m_pMyVehicle, pPed);
        v8 = (CTaskSimpleCarSetPedOut *)CTask::operator new(0x18u);
        CTaskSimpleCarSetPedOut::CTaskSimpleCarSetPedOut(v8, pPed->m_pMyVehicle, v7, 1);
        break;
      case 809:
      case 810:
      case 813:
      case 814:
      case 815:
        return result;
      case 816:
        goto LABEL_8;
      default:
        goto LABEL_7;
    }
  }
  else
  {
    switch ( v5 )
    {
      case 808:
        v9 = this->m_iStartDoor - 8;
        if ( v9 >= 4 )
        {
          m_iDestinationDoor = this->m_iDestinationDoor;
        }
        else
        {
          m_iDestinationDoor = dword_4FCE00[v9];
          this->m_iDestinationDoor = m_iDestinationDoor;
        }
        m_pTargetVehicle = this->m_pTargetVehicle;
        if ( m_iDestinationDoor == 10 )
        {
          if ( m_pTargetVehicle->pDriver )
            goto LABEL_8;
          CVehicle::RemovePassenger(m_pTargetVehicle, pPed);
          v12 = (CTaskSimpleCarSetPedInAsDriver *)CTask::operator new(0x1Cu);
          CTaskSimpleCarSetPedInAsDriver::CTaskSimpleCarSetPedInAsDriver(
            v12,
            this->m_pTargetVehicle,
            this->m_pTaskUtilityLineUpPedWithCar);
        }
        else
        {
          v13 = CCarEnterExit::ComputePassengerIndexFromCarDoor(m_pTargetVehicle, m_iDestinationDoor);
          v14 = 1302;
          if ( !this->m_pTargetVehicle->pPassengers[v13] )
            v14 = 811;
          result = CTaskComplexShuffleSeats::CreateSubTask(this, v14, pPed);
        }
        break;
      case 809:
      case 810:
      case 813:
      case 814:
      case 815:
        return result;
      case 811:
      case 812:
      case 816:
        goto LABEL_8;
      default:
LABEL_7:
        if ( v5 == 200 )
        {
LABEL_8:
          if ( pPed )
          {
            if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
              *(_DWORD *)&pPed->m_nFlags |= 1u;
          }
          result = 0;
        }
        break;
    }
  }
  return result;
}
// 4FCE00: using guessed type int dword_4FCE00[4];

//----- (004FCE10) --------------------------------------------------------
CTask *__fastcall CTaskComplexShuffleSeats::CreateFirstSubTask(CTaskComplexShuffleSeats *this, CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r0
  CTaskSimpleCarShuffle *v5; // r0
  CTask *result; // r0

  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( !m_pTargetVehicle || !CCarEnterExit::IsVehicleHealthy(m_pTargetVehicle) || !CCarEnterExit::IsPedHealthy(pPed) )
    return 0;
  CTaskComplexShuffleSeats::CreateTaskUtilityLineUpPedWithCar(this, pPed);
  v5 = (CTaskSimpleCarShuffle *)CTask::operator new(0x1Cu);
  CTaskSimpleCarShuffle::CTaskSimpleCarShuffle(
    v5,
    this->m_pTargetVehicle,
    this->m_iStartDoor,
    this->m_pTaskUtilityLineUpPedWithCar);
  return result;
}

//----- (004FCE4C) --------------------------------------------------------
void __fastcall CTaskComplexShuffleSeats::CreateTaskUtilityLineUpPedWithCar(CTaskComplexShuffleSeats *this, CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r1
  int v5; // r2
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float y; // s8
  float z; // s10
  CTaskUtilityLineUpPedWithCar *v10; // r0
  CTaskUtilityLineUpPedWithCar *v11; // r0
  CVector v12; // [sp+8h] [bp-20h] BYREF
  CVector vInitialBlendVector; // [sp+14h] [bp-14h] BYREF

  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( m_pTargetVehicle->pDriver == pPed )
  {
    v5 = 10;
  }
  else if ( m_pTargetVehicle->pPassengers[0] == pPed )
  {
    v5 = 8;
  }
  else
  {
    v5 = 9;
    if ( m_pTargetVehicle->pPassengers[1] == pPed )
      v5 = 11;
  }
  this->m_iStartDoor = v5;
  CCarEnterExit::GetPositionToOpenCarDoor(&v12, m_pTargetVehicle, v5);
  m_pMat = pPed->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  y = p_tx->m_translate.y;
  z = p_tx->m_translate.z;
  vInitialBlendVector.x = v12.x - p_tx->m_translate.x;
  vInitialBlendVector.y = v12.y - y;
  vInitialBlendVector.z = v12.z - z;
  v10 = (CTaskUtilityLineUpPedWithCar *)operator new(0x1Cu);
  CTaskUtilityLineUpPedWithCar::CTaskUtilityLineUpPedWithCar(v10, &vInitialBlendVector, 600, 0, this->m_iStartDoor);
  this->m_pTaskUtilityLineUpPedWithCar = v11;
}
// 4FCED8: variable 'v11' is possibly undefined

//----- (004FCEDE) --------------------------------------------------------
CTask *__fastcall CTaskComplexShuffleSeats::ControlSubTask(CTaskComplexShuffleSeats *this, CPed *pPed)
{
  CTask *m_pSubTask; // r4
  CVehicle *m_pTargetVehicle; // r0
  CTask *v6; // r0

  m_pSubTask = this->m_pSubTask;
  (*((void (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask);
  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( !m_pTargetVehicle || !CCarEnterExit::IsVehicleHealthy(m_pTargetVehicle) || !CCarEnterExit::IsPedHealthy(pPed) )
  {
    v6 = this->m_pSubTask;
    this->m_bIsAborting = 1;
    (*((void (__fastcall **)(CTask *, CPed *, _DWORD, _DWORD))v6->_vptr$CTask + 7))(v6, pPed, 0, 0);
  }
  return m_pSubTask;
}

//----- (004FCF24) --------------------------------------------------------
void __fastcall CTaskSimpleCarSetTempAction::CTaskSimpleCarSetTempAction(
        CTaskSimpleCarSetTempAction *this,
        CVehicle *pVehicle,
        const int iAction,
        const int iTime)
{
  char v8; // r0

  CTaskSimple::CTaskSimple(this);
  *(_WORD *)&this->m_passengerTimer.m_bIsActive = 0;
  *(int *)((char *)&this->m_broadcastStolenCarTimer.m_iDuration + 2) = 0;
  *(int *)((char *)&this->m_broadcastStolenCarTimer.m_iStartTime + 2) = 0;
  this->m_nUpsideDownCounter = 0;
  this->m_broadcastStolenCarTimer.m_iStartTime = 0;
  *(_QWORD *)&this->m_pAnimCloseDoor = 0LL;
  *(_QWORD *)&this->m_passengerTimer.m_iStartTime = 0LL;
  v8 = *((_BYTE *)&this->CTaskSimpleCarDrive + 92) & 0xC3 | 8;
  *((_BYTE *)&this->CTaskSimpleCarDrive + 92) = v8;
  this->_vptr$CTask = (int (**)(void))&off_66AD08;
  this->m_pTargetVehicle = pVehicle;
  if ( pVehicle )
  {
    CEntity::RegisterReference(pVehicle, &this->m_pTargetVehicle);
    v8 = *((_BYTE *)&this->CTaskSimpleCarDrive + 92);
  }
  this->m_bopStartTime = -1;
  *((_BYTE *)&this->CTaskSimpleCarDrive + 92) = v8 & 0xFC;
  this->m_currHeadBop = 0.0;
  this->m_headBopDepth = 0.0;
  this->m_headBopBlend = 0.0;
  this->m_iAction = iAction;
  this->m_iTime = iTime;
  this->_vptr$CTask = (int (**)(void))&off_66AF10;
}
// 66AD08: using guessed type void *off_66AD08;
// 66AF10: using guessed type void *;

//----- (004FCFB8) --------------------------------------------------------
void __fastcall CTaskSimpleCarSetTempAction::~CTaskSimpleCarSetTempAction(CTaskSimpleCarSetTempAction *this)
{
  void *v1; // r0

  CTaskSimpleCarSetTempAction::~CTaskSimpleCarSetTempAction(this);
  sub_197118(v1);
}
// 4FCFC4: variable 'v1' is possibly undefined

//----- (004FCFC8) --------------------------------------------------------
bool __fastcall CTaskSimpleCarSetTempAction::MakeAbortable(
        CTaskSimpleCarSetTempAction *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  _BOOL4 Abortable; // r0
  CVehicle *m_pTargetVehicle; // r1

  Abortable = CTaskSimpleCarDrive::MakeAbortable(this, pPed, iPriority, pEvent);
  if ( Abortable )
  {
    m_pTargetVehicle = this->m_pTargetVehicle;
    if ( m_pTargetVehicle )
    {
      m_pTargetVehicle->AutoPilot.TempAction = 0;
      this->m_pTargetVehicle->AutoPilot.TempActionFinish = CTimer::m_snTimeInMilliseconds;
    }
  }
  return Abortable;
}

//----- (004FCFF8) --------------------------------------------------------
bool __fastcall CTaskSimpleCarSetTempAction::ProcessPed(CTaskSimpleCarSetTempAction *this, CPed *pPed)
{
  CVehicle **p_m_pTargetVehicle; // r5
  CVehicle *m_pMyVehicle; // r0
  _BOOL4 v6; // r0
  CVehicle *m_pTargetVehicle; // r1
  bool result; // r0
  int m_iAction; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  if ( !this->m_pTargetVehicle )
  {
    m_pMyVehicle = pPed->m_pMyVehicle;
    *p_m_pTargetVehicle = m_pMyVehicle;
    if ( m_pMyVehicle )
      CEntity::RegisterReference(m_pMyVehicle, p_m_pTargetVehicle);
  }
  v6 = CTaskSimpleCarDrive::ProcessPed(this, pPed);
  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( v6 )
  {
    if ( m_pTargetVehicle )
    {
      m_pTargetVehicle->AutoPilot.TempAction = 0;
      (*p_m_pTargetVehicle)->AutoPilot.TempActionFinish = CTimer::m_snTimeInMilliseconds;
      return 1;
    }
  }
  else if ( m_pTargetVehicle )
  {
    m_iAction = this->m_iAction;
    if ( m_iAction )
    {
      m_pTargetVehicle->AutoPilot.TempAction = m_iAction;
      this->m_pTargetVehicle->AutoPilot.TempActionFinish = this->m_iTime + CTimer::m_snTimeInMilliseconds;
      result = 0;
      this->m_iAction = 0;
      return result;
    }
    if ( !m_pTargetVehicle->AutoPilot.TempAction )
      return 1;
  }
  return 0;
}

//----- (004FD088) --------------------------------------------------------
void __fastcall CTaskComplexLeaveCar::~CTaskComplexLeaveCar(CTaskComplexLeaveCar *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r5
  CTaskUtilityLineUpPedWithCar *m_pTaskUtilityLineUpPedWithCar; // r0
  void *v5; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66ABDC;
  if ( m_pTargetVehicle )
  {
    CVehicle::ClearGettingOutFlags(m_pTargetVehicle, this->m_nDoorFlagsSet);
    this->m_pTargetVehicle->m_nNumGettingIn -= this->m_nNumGettingInSet;
    CEntity::CleanUpOldReference(this->m_pTargetVehicle, p_m_pTargetVehicle);
  }
  m_pTaskUtilityLineUpPedWithCar = this->m_pTaskUtilityLineUpPedWithCar;
  if ( m_pTaskUtilityLineUpPedWithCar )
  {
    CTaskUtilityLineUpPedWithCar::~CTaskUtilityLineUpPedWithCar(m_pTaskUtilityLineUpPedWithCar);
    operator delete(v5);
  }
  sub_18EDB4(this);
}
// 4FD0C8: variable 'v5' is possibly undefined
// 66ABDC: using guessed type void *off_66ABDC;

//----- (004FD0DC) --------------------------------------------------------
void __fastcall CTaskSimpleCarSetTempAction::~CTaskSimpleCarSetTempAction(CTaskSimpleCarDrive *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CTaskUtilityLineUpPedWithCar *m_pUtility; // r0
  void *v5; // r0
  CVehicle *v6; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AD08;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pUtility = this->m_pUtility;
  if ( m_pUtility )
  {
    CTaskUtilityLineUpPedWithCar::~CTaskUtilityLineUpPedWithCar(m_pUtility);
    operator delete(v5);
    this->m_pUtility = 0;
  }
  if ( (*((_BYTE *)this + 92) & 0x20) != 0 )
  {
    CAnimBlendAssociation::SetFinishCallback(this->m_pAnimCloseDoor, CDefaultAnimCallback::DefaultAnimCB, 0);
    v6 = this->m_pTargetVehicle;
    if ( v6 )
      CVehicle::ClearGettingOutFlags(v6, 1u);
  }
  sub_1A01F4(this);
}
// 4FD102: variable 'v5' is possibly undefined
// 66AD08: using guessed type void *off_66AD08;

//----- (004FD140) --------------------------------------------------------
void __fastcall CTaskComplexCarDriveMission::~CTaskComplexCarDriveMission(CTaskComplexCarDriveMission *this)
{
  CEntity *m_pTargetEntity; // r0
  CEntity **p_m_pTargetEntity; // r1
  CVehicle *m_pVehicle; // r0
  CEntity **p_m_pVehicle; // r1
  CVehicle *v6; // r0

  p_m_pTargetEntity = &this->m_pTargetEntity;
  m_pTargetEntity = this->m_pTargetEntity;
  this->_vptr$CTask = (int (**)(void))&off_66ADCC;
  if ( m_pTargetEntity )
    CEntity::CleanUpOldReference(m_pTargetEntity, p_m_pTargetEntity);
  p_m_pVehicle = &this->m_pVehicle;
  m_pVehicle = this->m_pVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AD3C;
  if ( m_pVehicle )
  {
    if ( this->m_bIsCarSetUp )
    {
      m_pVehicle->AutoPilot.DrivingMode = this->m_origDrivingMode;
      this->m_pVehicle->AutoPilot.Mission = this->m_origMission;
      this->m_pVehicle->AutoPilot.CruiseSpeed = this->m_origCruiseSpeed;
      v6 = this->m_pVehicle;
      if ( v6 )
        CEntity::CleanUpOldReference(v6, p_m_pVehicle);
    }
    else
    {
      CEntity::CleanUpOldReference(m_pVehicle, p_m_pVehicle);
    }
  }
  sub_18EDB4(this);
}
// 66AD3C: using guessed type void *off_66AD3C;
// 66ADCC: using guessed type void *off_66ADCC;

//----- (004FD1B0) --------------------------------------------------------
void __fastcall CTaskComplexLeaveCarAndDie::~CTaskComplexLeaveCarAndDie(CTaskComplexLeaveCarAndDie *this)
{
  void *v1; // r0

  CTaskComplexLeaveCar::~CTaskComplexLeaveCar(this);
  sub_197118(v1);
}
// 4FD1BC: variable 'v1' is possibly undefined

//----- (004FD1C0) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveCarAndDie::Clone(const CTaskComplexLeaveCarAndDie *this)
{
  CTaskComplex *v2; // r0
  __int64 v3; // kr00_8
  CTaskComplex *v4; // r4
  int m_iDelayTime; // r6

  v2 = (CTaskComplex *)CTask::operator new(0x34u);
  v3 = *(_QWORD *)&this->m_pTargetVehicle;
  v4 = v2;
  m_iDelayTime = this->m_iDelayTime;
  CTaskComplex::CTaskComplex(v2);
  v4[1].m_pParent = (CTask *)HIDWORD(v3);
  v4[1].m_pSubTask = (CTask *)m_iDelayTime;
  LOWORD(v4[2]._vptr$CTask) = 256;
  BYTE2(v4[2]._vptr$CTask) = 0;
  v4[2].m_pParent = 0;
  LOBYTE(v4[2].m_pSubTask) = 0;
  BYTE1(v4[2].m_pSubTask) = 0;
  v4[3]._vptr$CTask = (int (**)(void))(byte_9 + 6);
  v4[3].m_pParent = (CTask *)1082130432;
  v4[3].m_pSubTask = (CTask *)1065353216;
  LOBYTE(v4[4]._vptr$CTask) = 0;
  v4->_vptr$CTask = (int (**)(void))&off_66ABDC;
  v4[1]._vptr$CTask = (int (**)(void))v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)&v4[1]);
  BYTE2(v4[2]._vptr$CTask) = 1;
  v4->_vptr$CTask = (int (**)(void))&off_66AF44;
  return v4;
}
// 66ABDC: using guessed type void *off_66ABDC;
// 66AF44: using guessed type void *off_66AF44;

//----- (004FD244) --------------------------------------------------------
int __fastcall CTaskComplexLeaveCarAndDie::GetTaskType(const CTaskComplexLeaveCarAndDie *this)
{
  return 705;
}

//----- (004FD24C) --------------------------------------------------------
void __fastcall CTaskComplexLeaveCarAndDie::Serialize(CTaskComplexLeaveCarAndDie *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CVehicle *m_pTargetVehicle; // r0
  int v5; // r5
  _DWORD *v6; // r6
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r5
  _DWORD *v10; // r5
  _DWORD *v11; // r5

  v2 = (*((int (__fastcall **)(CTaskComplexLeaveCarAndDie *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexLeaveCarAndDie *))this->_vptr$CTask + 5))(this) == 705 )
  {
    m_pTargetVehicle = this->m_pTargetVehicle;
    if ( m_pTargetVehicle )
    {
      v5 = GettPoolVehicleRef(m_pTargetVehicle);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    free(v7);
    if ( UseDataFence )
      AddDataFence();
    v10 = malloc(4u);
    *v10 = this->m_iTargetDoor;
    CGenericGameStorage::_SaveDataToWorkBuffer(v10, 4);
    free(v10);
    if ( UseDataFence )
      AddDataFence();
    v11 = malloc(4u);
    *v11 = this->m_iDelayTime;
    CGenericGameStorage::_SaveDataToWorkBuffer(v11, 4);
    j_free(v11);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexLeaveCarAndDie *))this->_vptr$CTask + 5))(this);
    sub_1941C4(705, v8);
  }
}

//----- (004FD37C) --------------------------------------------------------
void __fastcall CTaskComplexLeaveAnyCar::~CTaskComplexLeaveAnyCar(CTaskComplexLeaveAnyCar *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 4FD388: variable 'v1' is possibly undefined

//----- (004FD38C) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveAnyCar::Clone(const CTaskComplexLeaveAnyCar *this)
{
  CTaskComplex *v2; // r0
  __int16 v3; // r5
  CTask *m_iDelayTime; // r4
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x14u);
  v3 = *(_WORD *)&this->m_bSensibleLeaveCar;
  m_iDelayTime = (CTask *)this->m_iDelayTime;
  CTaskComplex::CTaskComplex(v2);
  result[1].m_pParent = m_iDelayTime;
  LOWORD(result[2]._vptr$CTask) = v3;
  result->_vptr$CTask = (int (**)(void))&off_66AF80;
  return result;
}
// 4FD3A2: variable 'result' is possibly undefined
// 66AF80: using guessed type void *off_66AF80;
// 677A98: using guessed type void *`vtable for'CTaskComplexLeaveAnyCar;

//----- (004FD3B4) --------------------------------------------------------
int __fastcall CTaskComplexLeaveAnyCar::GetTaskType(const CTaskComplexLeaveAnyCar *this)
{
  return 714;
}

//----- (004FD3BC) --------------------------------------------------------
void __fastcall CTaskComplexLeaveAnyCar::Serialize(CTaskComplexLeaveAnyCar *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  int v5; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexLeaveAnyCar *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexLeaveAnyCar *))this->_vptr$CTask + 5))(this) == 714 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(4u);
    *v4 = this->m_iDelayTime;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    free(v4);
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(&this->m_bSensibleLeaveCar, 1);
    if ( UseDataFence )
      AddDataFence();
    sub_19E9A8(&this->m_bForcePedOut, 1);
  }
  else
  {
    v5 = (*((int (__fastcall **)(CTaskComplexLeaveAnyCar *))this->_vptr$CTask + 5))(this);
    sub_1941C4(714, v5);
  }
}

//----- (004FD498) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterCarAsDriver::Clone(const CTaskComplexEnterCarAsDriver *this)
{
  char *v2; // r5
  CVehicle *m_pTargetVehicle; // r6
  char v4; // r2

  v2 = (char *)CTask::operator new(0x50u);
  m_pTargetVehicle = this->m_pTargetVehicle;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *(_QWORD *)(v2 + 20) = 0LL;
  *(_QWORD *)(v2 + 28) = 0LL;
  *((_DWORD *)v2 + 9) = 6;
  *((_WORD *)v2 + 20) = 0;
  *((_DWORD *)v2 + 14) = 0;
  v2[60] = 0;
  *((_DWORD *)v2 + 16) = 0;
  v2[68] = 0;
  v4 = v2[16];
  *((_DWORD *)v2 + 18) = -1082130432;
  *(_DWORD *)v2 = &off_66A8F4;
  v2[16] = v4 & 0xF0 | 1;
  *((_DWORD *)v2 + 3) = m_pTargetVehicle;
  if ( m_pTargetVehicle )
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v2 + 3);
  *(_DWORD *)v2 = &off_66A934;
  *((_DWORD *)v2 + 9) = this->m_iMoveState;
  return (CTask *)v2;
}
// 66A8F4: using guessed type void *off_66A8F4;
// 66A934: using guessed type void *off_66A934;
// 6762B0: using guessed type void *`vtable for'CTaskComplexEnterCarAsDriver;

//----- (004FD524) --------------------------------------------------------
int __fastcall CTaskComplexEnterCarAsDriver::GetTaskType(const CTaskComplexEnterCarAsDriver *this)
{
  return 701;
}

//----- (004FD52C) --------------------------------------------------------
void __fastcall CTaskComplexEnterCarAsDriver::Serialize(CTaskComplexEnterCarAsDriver *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CVehicle *m_pTargetVehicle; // r0
  int v5; // r4
  _DWORD *v6; // r5
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r4

  v2 = (*((int (__fastcall **)(CTaskComplexEnterCarAsDriver *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexEnterCarAsDriver *))this->_vptr$CTask + 5))(this) == 701 )
  {
    m_pTargetVehicle = this->m_pTargetVehicle;
    if ( m_pTargetVehicle )
    {
      v5 = GettPoolVehicleRef(m_pTargetVehicle);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    j_free(v7);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexEnterCarAsDriver *))this->_vptr$CTask + 5))(this);
    sub_1941C4(701, v8);
  }
}

//----- (004FD600) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterCarAsPassenger::Clone(const CTaskComplexEnterCarAsPassenger *this)
{
  char *v2; // r5
  int m_iTargetSeat; // r8
  CVehicle *m_pTargetVehicle; // r6
  char v5; // r9
  char v6; // r1

  v2 = (char *)CTask::operator new(0x50u);
  m_iTargetSeat = this->m_iTargetSeat;
  m_pTargetVehicle = this->m_pTargetVehicle;
  v5 = *((_BYTE *)&this->CTaskComplexEnterCar + 16);
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *(_QWORD *)(v2 + 20) = 0LL;
  *(_QWORD *)(v2 + 28) = 0LL;
  *((_DWORD *)v2 + 9) = 6;
  *((_WORD *)v2 + 20) = 0;
  *((_DWORD *)v2 + 14) = 0;
  v2[60] = 0;
  *((_DWORD *)v2 + 16) = 0;
  v2[68] = 0;
  *((_DWORD *)v2 + 18) = -1082130432;
  v6 = v2[16];
  *(_DWORD *)v2 = &off_66A8F4;
  v2[16] = v5 & 8 | v6 & 0xF0;
  *((_DWORD *)v2 + 3) = m_pTargetVehicle;
  if ( m_pTargetVehicle )
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v2 + 3);
  *((_DWORD *)v2 + 7) = m_iTargetSeat;
  *(_DWORD *)v2 = &off_66A974;
  *((_DWORD *)v2 + 9) = this->m_iMoveState;
  return (CTask *)v2;
}
// 66A8F4: using guessed type void *off_66A8F4;
// 66A974: using guessed type void *off_66A974;
// 6769E0: using guessed type void *`vtable for'CTaskComplexEnterCarAsPassenger;

//----- (004FD69C) --------------------------------------------------------
int __fastcall CTaskComplexEnterCarAsPassenger::GetTaskType(const CTaskComplexEnterCarAsPassenger *this)
{
  return 700;
}

//----- (004FD6A4) --------------------------------------------------------
void __fastcall CTaskComplexEnterCarAsPassenger::Serialize(CTaskComplexEnterCarAsPassenger *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CVehicle *m_pTargetVehicle; // r0
  int v5; // r5
  _DWORD *v6; // r6
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r5
  _DWORD *v10; // r5
  char pData[17]; // [sp+7h] [bp-11h] BYREF

  v2 = (*((int (__fastcall **)(CTaskComplexEnterCarAsPassenger *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexEnterCarAsPassenger *))this->_vptr$CTask + 5))(this) == 700 )
  {
    m_pTargetVehicle = this->m_pTargetVehicle;
    if ( m_pTargetVehicle )
    {
      v5 = GettPoolVehicleRef(m_pTargetVehicle);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    free(v7);
    if ( UseDataFence )
      AddDataFence();
    v10 = malloc(4u);
    *v10 = this->m_iTargetSeat;
    CGenericGameStorage::_SaveDataToWorkBuffer(v10, 4);
    free(v10);
    pData[0] = (*((_BYTE *)&this->CTaskComplexEnterCar + 16) & 8) != 0;
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(pData, 1);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexEnterCarAsPassenger *))this->_vptr$CTask + 5))(this);
    sub_1941C4(700, v8);
  }
}
// 4FD6A4: using guessed type char pData[17];

//----- (004FD7D0) --------------------------------------------------------
CTask *__fastcall CTaskComplexOpenDriverDoor::Clone(const CTaskComplexOpenDriverDoor *this)
{
  char *v2; // r5
  CVehicle *m_pTargetVehicle; // r6
  char v4; // r2

  v2 = (char *)CTask::operator new(0x50u);
  m_pTargetVehicle = this->m_pTargetVehicle;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *(_QWORD *)(v2 + 20) = 0LL;
  *(_QWORD *)(v2 + 28) = 0LL;
  *((_DWORD *)v2 + 9) = 6;
  *((_WORD *)v2 + 20) = 0;
  *((_DWORD *)v2 + 14) = 0;
  v2[60] = 0;
  *((_DWORD *)v2 + 16) = 0;
  v2[68] = 0;
  v4 = v2[16];
  *((_DWORD *)v2 + 18) = -1082130432;
  *(_DWORD *)v2 = &off_66A8F4;
  v2[16] = v4 & 0xF0 | 3;
  *((_DWORD *)v2 + 3) = m_pTargetVehicle;
  if ( m_pTargetVehicle )
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v2 + 3);
  *((_DWORD *)v2 + 7) = 10;
  *(_DWORD *)v2 = &off_66A9B4;
  *((_DWORD *)v2 + 9) = this->m_iMoveState;
  return (CTask *)v2;
}
// 66A8F4: using guessed type void *off_66A8F4;
// 66A9B4: using guessed type void *;

//----- (004FD860) --------------------------------------------------------
int __fastcall CTaskComplexOpenDriverDoor::GetTaskType(const CTaskComplexOpenDriverDoor *this)
{
  return 722;
}

//----- (004FD868) --------------------------------------------------------
void __fastcall CTaskComplexOpenDriverDoor::Serialize(CTaskComplexOpenDriverDoor *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CVehicle *m_pTargetVehicle; // r0
  int v5; // r4
  _DWORD *v6; // r5
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r4

  v2 = (*((int (__fastcall **)(CTaskComplexOpenDriverDoor *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexOpenDriverDoor *))this->_vptr$CTask + 5))(this) == 722 )
  {
    m_pTargetVehicle = this->m_pTargetVehicle;
    if ( m_pTargetVehicle )
    {
      v5 = GettPoolVehicleRef(m_pTargetVehicle);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    j_free(v7);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexOpenDriverDoor *))this->_vptr$CTask + 5))(this);
    sub_1941C4(722, v8);
  }
}

//----- (004FD93C) --------------------------------------------------------
CTask *__fastcall CTaskComplexOpenPassengerDoor::Clone(const CTaskComplexOpenPassengerDoor *this)
{
  char *v2; // r5
  CVehicle *m_pTargetVehicle; // r6
  int m_iTargetSeat; // r8
  char v5; // r2

  v2 = (char *)CTask::operator new(0x50u);
  m_pTargetVehicle = this->m_pTargetVehicle;
  m_iTargetSeat = this->m_iTargetSeat;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *(_QWORD *)(v2 + 20) = 0LL;
  *(_QWORD *)(v2 + 28) = 0LL;
  *((_DWORD *)v2 + 9) = 6;
  *((_WORD *)v2 + 20) = 0;
  *((_DWORD *)v2 + 14) = 0;
  v2[60] = 0;
  *((_DWORD *)v2 + 16) = 0;
  v2[68] = 0;
  v5 = v2[16];
  *((_DWORD *)v2 + 18) = -1082130432;
  *(_DWORD *)v2 = &off_66A8F4;
  v2[16] = v5 & 0xF0 | 2;
  *((_DWORD *)v2 + 3) = m_pTargetVehicle;
  if ( m_pTargetVehicle )
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v2 + 3);
  *((_DWORD *)v2 + 7) = m_iTargetSeat;
  *(_DWORD *)v2 = &off_66A9F4;
  *((_DWORD *)v2 + 9) = this->m_iMoveState;
  return (CTask *)v2;
}
// 66A8F4: using guessed type void *off_66A8F4;
// 66A9F4: using guessed type void *;

//----- (004FD9D0) --------------------------------------------------------
int __fastcall CTaskComplexOpenPassengerDoor::GetTaskType(const CTaskComplexOpenPassengerDoor *this)
{
  return 728;
}

//----- (004FD9D8) --------------------------------------------------------
void __fastcall CTaskComplexOpenPassengerDoor::Serialize(CTaskComplexOpenPassengerDoor *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CVehicle *m_pTargetVehicle; // r0
  int v5; // r5
  _DWORD *v6; // r6
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r5
  _DWORD *v10; // r5

  v2 = (*((int (__fastcall **)(CTaskComplexOpenPassengerDoor *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexOpenPassengerDoor *))this->_vptr$CTask + 5))(this) == 728 )
  {
    m_pTargetVehicle = this->m_pTargetVehicle;
    if ( m_pTargetVehicle )
    {
      v5 = GettPoolVehicleRef(m_pTargetVehicle);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    free(v7);
    if ( UseDataFence )
      AddDataFence();
    v10 = malloc(4u);
    *v10 = this->m_iTargetSeat;
    CGenericGameStorage::_SaveDataToWorkBuffer(v10, 4);
    j_free(v10);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexOpenPassengerDoor *))this->_vptr$CTask + 5))(this);
    sub_1941C4(728, v8);
  }
}

//----- (004FDAD8) --------------------------------------------------------
CTask *__fastcall CTaskComplexDragPedFromCar::Clone(const CTaskComplexDragPedFromCar *this)
{
  CTaskComplex *v2; // r0
  int m_iDraggedPedDownTime; // r6
  CTaskComplex *v4; // r4
  CPed *m_pTargetPed; // r5
  char m_pParent; // r2

  v2 = (CTaskComplex *)CTask::operator new(0x54u);
  m_iDraggedPedDownTime = this->m_iDraggedPedDownTime;
  v4 = v2;
  m_pTargetPed = this->m_pTargetPed;
  CTaskComplex::CTaskComplex(v2);
  *(_QWORD *)&v4[1].m_pSubTask = 0LL;
  *(_QWORD *)&v4[2].m_pParent = 0LL;
  v4[1]._vptr$CTask = 0;
  v4[3]._vptr$CTask = (int (**)(void))&byte_6;
  LOWORD(v4[3].m_pParent) = 0;
  v4[4].m_pSubTask = 0;
  LOBYTE(v4[5]._vptr$CTask) = 0;
  v4[5].m_pParent = 0;
  LOBYTE(v4[5].m_pSubTask) = 0;
  m_pParent = (char)v4[1].m_pParent;
  v4[6]._vptr$CTask = (int (**)(void))-1082130432;
  v4->_vptr$CTask = (int (**)(void))&off_66AA34;
  LOBYTE(v4[1].m_pParent) = m_pParent & 0xF0 | 4;
  v4[6].m_pSubTask = (CTask *)m_pTargetPed;
  if ( m_pTargetPed )
    CEntity::RegisterReference(m_pTargetPed, (CEntity **)&v4[6].m_pSubTask);
  v4[2].m_pSubTask = (CTask *)m_iDraggedPedDownTime;
  return v4;
}
// 6: using guessed type char byte_6;
// 66AA34: using guessed type void *off_66AA34;

//----- (004FDB58) --------------------------------------------------------
int __fastcall CTaskComplexDragPedFromCar::GetTaskType(const CTaskComplexDragPedFromCar *this)
{
  return 703;
}

//----- (004FDB60) --------------------------------------------------------
void __fastcall CTaskComplexDragPedFromCar::Serialize(CTaskComplexDragPedFromCar *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CPed *m_pTargetPed; // r0
  int v5; // r5
  _DWORD *v6; // r6
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r5
  _DWORD *v10; // r5

  v2 = (*((int (__fastcall **)(CTaskComplexDragPedFromCar *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexDragPedFromCar *))this->_vptr$CTask + 5))(this) == 703 )
  {
    m_pTargetPed = this->m_pTargetPed;
    if ( m_pTargetPed )
    {
      v5 = GettPoolPedRef(m_pTargetPed);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    free(v7);
    if ( UseDataFence )
      AddDataFence();
    v10 = malloc(4u);
    *v10 = this->m_iDraggedPedDownTime;
    CGenericGameStorage::_SaveDataToWorkBuffer(v10, 4);
    j_free(v10);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexDragPedFromCar *))this->_vptr$CTask + 5))(this);
    sub_1941C4(703, v8);
  }
}

//----- (004FDC60) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterCarAsDriverTimed::Clone(const CTaskComplexEnterCarAsDriverTimed *this)
{
  void *v2; // r5
  __int64 v3; // kr00_8

  v2 = CTask::operator new(0x24u);
  v3 = *(_QWORD *)&this->m_pTargetVehicle;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_DWORD *)v2 + 4) = HIDWORD(v3);
  *((_DWORD *)v2 + 5) = 6;
  *((_WORD *)v2 + 16) = 0;
  *((_DWORD *)v2 + 6) = 0;
  *((_DWORD *)v2 + 7) = 0;
  *(_DWORD *)v2 = &off_66AA74;
  *((_DWORD *)v2 + 3) = v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)v2 + 3);
  *((_DWORD *)v2 + 5) = this->m_iMoveState;
  return (CTask *)v2;
}
// 66AA74: using guessed type void *off_66AA74;

//----- (004FDCB8) --------------------------------------------------------
int __fastcall CTaskComplexEnterCarAsDriverTimed::GetTaskType(const CTaskComplexEnterCarAsDriverTimed *this)
{
  return 713;
}

//----- (004FDCC0) --------------------------------------------------------
void __fastcall CTaskComplexEnterCarAsDriverTimed::Serialize(CTaskComplexEnterCarAsDriverTimed *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r4
  _DWORD *v5; // r5
  int v6; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexEnterCarAsDriverTimed *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexEnterCarAsDriverTimed *))this->_vptr$CTask + 5))(this) == 713 )
  {
    v4 = GettPoolVehicleRef(this->m_pTargetVehicle);
    if ( UseDataFence )
      AddDataFence();
    v5 = malloc(4u);
    *v5 = v4;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 4);
    j_free(v5);
  }
  else
  {
    v6 = (*((int (__fastcall **)(CTaskComplexEnterCarAsDriverTimed *))this->_vptr$CTask + 5))(this);
    sub_1941C4(713, v6);
  }
}

//----- (004FDD64) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterCarAsPassengerTimed::Clone(const CTaskComplexEnterCarAsPassengerTimed *this)
{
  void *v2; // r5
  CVehicle *m_pTargetVehicle; // r6
  __int64 v4; // r8
  bool m_bCarryOnAfterFallingOff; // r10

  v2 = CTask::operator new(0x2Cu);
  m_pTargetVehicle = this->m_pTargetVehicle;
  v4 = *(_QWORD *)&this->m_iTime;
  m_bCarryOnAfterFallingOff = this->m_bCarryOnAfterFallingOff;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_QWORD *)v2 + 2) = v4;
  *((_BYTE *)v2 + 24) = m_bCarryOnAfterFallingOff;
  *((_DWORD *)v2 + 7) = 6;
  *((_WORD *)v2 + 20) = 0;
  *((_DWORD *)v2 + 8) = 0;
  *((_DWORD *)v2 + 9) = 0;
  *(_DWORD *)v2 = &off_66AAB0;
  *((_DWORD *)v2 + 3) = m_pTargetVehicle;
  if ( m_pTargetVehicle )
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v2 + 3);
  *((_DWORD *)v2 + 7) = this->m_iMoveState;
  return (CTask *)v2;
}
// 66AAB0: using guessed type void *off_66AAB0;

//----- (004FDDC8) --------------------------------------------------------
int __fastcall CTaskComplexEnterCarAsPassengerTimed::GetTaskType(const CTaskComplexEnterCarAsPassengerTimed *this)
{
  return 712;
}

//----- (004FDDD0) --------------------------------------------------------
void __fastcall CTaskComplexEnterCarAsPassengerTimed::Serialize(CTaskComplexEnterCarAsPassengerTimed *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r4
  _DWORD *v5; // r5
  int v6; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexEnterCarAsPassengerTimed *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexEnterCarAsPassengerTimed *))this->_vptr$CTask + 5))(this) == 712 )
  {
    v4 = GettPoolVehicleRef(this->m_pTargetVehicle);
    if ( UseDataFence )
      AddDataFence();
    v5 = malloc(4u);
    *v5 = v4;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 4);
    j_free(v5);
  }
  else
  {
    v6 = (*((int (__fastcall **)(CTaskComplexEnterCarAsPassengerTimed *))this->_vptr$CTask + 5))(this);
    sub_1941C4(712, v6);
  }
}

//----- (004FDE70) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterCarAsPassengerWait::Clone(const CTaskComplexEnterCarAsPassengerWait *this)
{
  CTaskComplex *v2; // r0
  CPed *m_pWaitForPed; // r5
  CVehicle *m_pTargetVehicle; // r8
  CTaskComplex *v5; // r4
  int m_iMoveState; // r9

  v2 = (CTaskComplex *)CTask::operator new(0x24u);
  m_pWaitForPed = this->m_pWaitForPed;
  m_pTargetVehicle = this->m_pTargetVehicle;
  v5 = v2;
  m_iMoveState = this->m_iMoveState;
  LOBYTE(this) = this->m_bForceFrontSeat;
  CTaskComplex::CTaskComplex(v2);
  v5[1].m_pSubTask = 0;
  LOBYTE(v5[2]._vptr$CTask) = (_BYTE)this;
  v5[2].m_pParent = (CTask *)m_iMoveState;
  LOBYTE(v5[2].m_pSubTask) = 0;
  v5->_vptr$CTask = (int (**)(void))&off_66AAEC;
  v5[1].CTask = (CTask)__PAIR64__((unsigned int)m_pWaitForPed, (unsigned int)m_pTargetVehicle);
  if ( m_pTargetVehicle )
  {
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)&v5[1]);
    m_pWaitForPed = (CPed *)v5[1].m_pParent;
  }
  if ( m_pWaitForPed )
    CEntity::RegisterReference(m_pWaitForPed, (CEntity **)&v5[1].m_pParent);
  return v5;
}
// 66AAEC: using guessed type void *off_66AAEC;

//----- (004FDEDC) --------------------------------------------------------
int __fastcall CTaskComplexEnterCarAsPassengerWait::GetTaskType(const CTaskComplexEnterCarAsPassengerWait *this)
{
  return 718;
}

//----- (004FDEE4) --------------------------------------------------------
void __fastcall CTaskComplexEnterCarAsPassengerWait::Serialize(CTaskComplexEnterCarAsPassengerWait *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CVehicle *m_pTargetVehicle; // r0
  int v5; // r5
  _DWORD *v6; // r6
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r5
  CPed *m_pWaitForPed; // r0
  int v11; // r5
  _DWORD *v12; // r6
  void *v13; // r0
  _DWORD *v14; // r5
  _DWORD *v15; // r5

  v2 = (*((int (__fastcall **)(CTaskComplexEnterCarAsPassengerWait *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexEnterCarAsPassengerWait *))this->_vptr$CTask + 5))(this) == 718 )
  {
    m_pTargetVehicle = this->m_pTargetVehicle;
    if ( m_pTargetVehicle )
    {
      v5 = GettPoolVehicleRef(m_pTargetVehicle);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    free(v7);
    m_pWaitForPed = this->m_pWaitForPed;
    if ( m_pWaitForPed )
    {
      v11 = GettPoolPedRef(m_pWaitForPed);
      if ( UseDataFence )
        AddDataFence();
      v12 = malloc(4u);
      *v12 = v11;
      CGenericGameStorage::_SaveDataToWorkBuffer(v12, 4);
      v13 = v12;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v14 = malloc(4u);
      *v14 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v14, 4);
      v13 = v14;
    }
    free(v13);
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(&this->m_bForceFrontSeat, 1);
    if ( UseDataFence )
      AddDataFence();
    v15 = malloc(4u);
    *v15 = this->m_iMoveState;
    CGenericGameStorage::_SaveDataToWorkBuffer(v15, 4);
    j_free(v15);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexEnterCarAsPassengerWait *))this->_vptr$CTask + 5))(this);
    sub_1941C4(718, v8);
  }
}

//----- (004FE064) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveCarAsPassengerWait::Clone(const CTaskComplexLeaveCarAsPassengerWait *this)
{
  void *v2; // r4
  CVehicle *m_pTargetVehicle; // r5

  v2 = CTask::operator new(0x10u);
  m_pTargetVehicle = this->m_pTargetVehicle;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *(_DWORD *)v2 = &off_66AB28;
  *((_DWORD *)v2 + 3) = m_pTargetVehicle;
  if ( m_pTargetVehicle )
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v2 + 3);
  return (CTask *)v2;
}
// 66AB28: using guessed type void *off_66AB28;

//----- (004FE09C) --------------------------------------------------------
int __fastcall CTaskComplexLeaveCarAsPassengerWait::GetTaskType(const CTaskComplexLeaveCarAsPassengerWait *this)
{
  return 730;
}

//----- (004FE0A4) --------------------------------------------------------
void __fastcall CTaskComplexLeaveCarAsPassengerWait::Serialize(CTaskComplexLeaveCarAsPassengerWait *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CVehicle *m_pTargetVehicle; // r0
  int v5; // r4
  _DWORD *v6; // r5
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r4

  v2 = (*((int (__fastcall **)(CTaskComplexLeaveCarAsPassengerWait *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexLeaveCarAsPassengerWait *))this->_vptr$CTask + 5))(this) == 730 )
  {
    m_pTargetVehicle = this->m_pTargetVehicle;
    if ( m_pTargetVehicle )
    {
      v5 = GettPoolVehicleRef(m_pTargetVehicle);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    j_free(v7);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexLeaveCarAsPassengerWait *))this->_vptr$CTask + 5))(this);
    sub_1941C4(730, v8);
  }
}

//----- (004FE178) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterBoatAsDriver::Clone(const CTaskComplexEnterBoatAsDriver *this)
{
  void *v2; // r4
  CVehicle *m_pTargetVehicle; // r5

  v2 = CTask::operator new(0x10u);
  m_pTargetVehicle = this->m_pTargetVehicle;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *(_DWORD *)v2 = &off_66AB64;
  *((_DWORD *)v2 + 3) = m_pTargetVehicle;
  if ( m_pTargetVehicle )
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v2 + 3);
  return (CTask *)v2;
}
// 66AB64: using guessed type void *off_66AB64;

//----- (004FE1B0) --------------------------------------------------------
int __fastcall CTaskComplexEnterBoatAsDriver::GetTaskType(const CTaskComplexEnterBoatAsDriver *this)
{
  return 715;
}

//----- (004FE1B8) --------------------------------------------------------
void __fastcall CTaskComplexEnterBoatAsDriver::Serialize(CTaskComplexEnterBoatAsDriver *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CVehicle *m_pTargetVehicle; // r0
  int v5; // r4
  _DWORD *v6; // r5
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r4

  v2 = (*((int (__fastcall **)(CTaskComplexEnterBoatAsDriver *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexEnterBoatAsDriver *))this->_vptr$CTask + 5))(this) == 715 )
  {
    m_pTargetVehicle = this->m_pTargetVehicle;
    if ( m_pTargetVehicle )
    {
      v5 = GettPoolVehicleRef(m_pTargetVehicle);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    j_free(v7);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexEnterBoatAsDriver *))this->_vptr$CTask + 5))(this);
    sub_1941C4(715, v8);
  }
}

//----- (004FE28C) --------------------------------------------------------
CTask *__fastcall CTaskComplexStealCar::Clone(const CTaskComplexStealCar *this)
{
  void *v2; // r4
  CVehicle *m_pTargetVehicle; // r5

  v2 = CTask::operator new(0x20u);
  m_pTargetVehicle = this->m_pTargetVehicle;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_WORD *)v2 + 12) = 0;
  *((_DWORD *)v2 + 7) = 0;
  *((_DWORD *)v2 + 4) = 0;
  *((_DWORD *)v2 + 5) = 0;
  *(_DWORD *)v2 = &off_66ABA0;
  *((_DWORD *)v2 + 3) = m_pTargetVehicle;
  if ( m_pTargetVehicle )
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v2 + 3);
  return (CTask *)v2;
}
// 66ABA0: using guessed type void *off_66ABA0;

//----- (004FE2D0) --------------------------------------------------------
int __fastcall CTaskComplexStealCar::GetTaskType(const CTaskComplexStealCar *this)
{
  return 702;
}

//----- (004FE2D8) --------------------------------------------------------
void __fastcall CTaskComplexStealCar::Serialize(CTaskComplexStealCar *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CVehicle *m_pTargetVehicle; // r0
  int v5; // r4
  _DWORD *v6; // r5
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r4

  v2 = (*((int (__fastcall **)(CTaskComplexStealCar *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexStealCar *))this->_vptr$CTask + 5))(this) == 702 )
  {
    m_pTargetVehicle = this->m_pTargetVehicle;
    if ( m_pTargetVehicle )
    {
      v5 = GettPoolVehicleRef(m_pTargetVehicle);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    j_free(v7);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexStealCar *))this->_vptr$CTask + 5))(this);
    sub_1941C4(702, v8);
  }
}

//----- (004FE3AC) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveCar::Clone(const CTaskComplexLeaveCar *this)
{
  void *v2; // r4
  CVehicle *m_pTargetVehicle; // r5
  __int64 v4; // r8

  v2 = CTask::operator new(0x34u);
  m_pTargetVehicle = this->m_pTargetVehicle;
  v4 = *(_QWORD *)&this->m_iTargetDoor;
  LOWORD(this) = *(_WORD *)&this->m_bSensibleLeaveCar;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_QWORD *)v2 + 2) = v4;
  *((_WORD *)v2 + 12) = (_WORD)this;
  *((_BYTE *)v2 + 26) = 0;
  *((_DWORD *)v2 + 7) = 0;
  *((_BYTE *)v2 + 32) = 0;
  *((_BYTE *)v2 + 33) = 0;
  *((_DWORD *)v2 + 9) = 15;
  *((_DWORD *)v2 + 10) = 1082130432;
  *((_DWORD *)v2 + 11) = 1065353216;
  *((_BYTE *)v2 + 48) = 0;
  *(_DWORD *)v2 = &off_66ABDC;
  *((_DWORD *)v2 + 3) = m_pTargetVehicle;
  if ( m_pTargetVehicle )
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v2 + 3);
  return (CTask *)v2;
}
// 66ABDC: using guessed type void *off_66ABDC;

//----- (004FE420) --------------------------------------------------------
int __fastcall CTaskComplexLeaveCar::GetTaskType(const CTaskComplexLeaveCar *this)
{
  return 704;
}

//----- (004FE428) --------------------------------------------------------
void __fastcall CTaskComplexLeaveCar::Serialize(CTaskComplexLeaveCar *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r5
  _DWORD *v5; // r6
  _DWORD *v6; // r5
  _DWORD *v7; // r5
  int v8; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexLeaveCar *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexLeaveCar *))this->_vptr$CTask + 5))(this) == 704 )
  {
    v4 = GettPoolVehicleRef(this->m_pTargetVehicle);
    if ( UseDataFence )
      AddDataFence();
    v5 = malloc(4u);
    *v5 = v4;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 4);
    free(v5);
    if ( UseDataFence )
      AddDataFence();
    v6 = malloc(4u);
    *v6 = this->m_iTargetDoor;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
    free(v6);
    if ( UseDataFence )
      AddDataFence();
    v7 = malloc(4u);
    *v7 = this->m_iDelayTime;
    CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
    free(v7);
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(&this->m_bSensibleLeaveCar, 1);
    if ( UseDataFence )
      AddDataFence();
    sub_19E9A8(&this->m_bForceGetOut, 1);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexLeaveCar *))this->_vptr$CTask + 5))(this);
    sub_1941C4(704, v8);
  }
}

//----- (004FE560) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveBoat::Clone(const CTaskComplexLeaveBoat *this)
{
  void *v2; // r4
  __int64 v3; // kr00_8

  v2 = CTask::operator new(0x14u);
  v3 = *(_QWORD *)&this->m_pTargetVehicle;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_DWORD *)v2 + 4) = HIDWORD(v3);
  *(_DWORD *)v2 = &off_66AC18;
  *((_DWORD *)v2 + 3) = v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)v2 + 3);
  return (CTask *)v2;
}
// 66AC18: using guessed type void *off_66AC18;

//----- (004FE5A4) --------------------------------------------------------
int __fastcall CTaskComplexLeaveBoat::GetTaskType(const CTaskComplexLeaveBoat *this)
{
  return 716;
}

//----- (004FE5AC) --------------------------------------------------------
void __fastcall CTaskComplexLeaveBoat::Serialize(CTaskComplexLeaveBoat *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CVehicle *m_pTargetVehicle; // r0
  int v5; // r5
  _DWORD *v6; // r6
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r5
  _DWORD *v10; // r5

  v2 = (*((int (__fastcall **)(CTaskComplexLeaveBoat *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexLeaveBoat *))this->_vptr$CTask + 5))(this) == 716 )
  {
    m_pTargetVehicle = this->m_pTargetVehicle;
    if ( m_pTargetVehicle )
    {
      v5 = GettPoolVehicleRef(m_pTargetVehicle);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    free(v7);
    if ( UseDataFence )
      AddDataFence();
    v10 = malloc(4u);
    *v10 = this->m_iDelayTime;
    CGenericGameStorage::_SaveDataToWorkBuffer(v10, 4);
    j_free(v10);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexLeaveBoat *))this->_vptr$CTask + 5))(this);
    sub_1941C4(716, v8);
  }
}

//----- (004FE6AC) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveCarAndWander::Clone(const CTaskComplexLeaveCarAndWander *this)
{
  void *v2; // r4
  CVehicle *m_pTargetVehicle; // r5
  __int64 v4; // r8

  v2 = CTask::operator new(0x1Cu);
  m_pTargetVehicle = this->m_pTargetVehicle;
  v4 = *(_QWORD *)&this->m_iTargetDoor;
  LOBYTE(this) = this->m_bSensibleLeaveCar;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_QWORD *)v2 + 2) = v4;
  *((_BYTE *)v2 + 24) = (_BYTE)this;
  *(_DWORD *)v2 = &off_66AC54;
  *((_DWORD *)v2 + 3) = m_pTargetVehicle;
  if ( m_pTargetVehicle )
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v2 + 3);
  return (CTask *)v2;
}
// 66AC54: using guessed type void *off_66AC54;

//----- (004FE6FC) --------------------------------------------------------
int __fastcall CTaskComplexLeaveCarAndWander::GetTaskType(const CTaskComplexLeaveCarAndWander *this)
{
  return 707;
}

//----- (004FE704) --------------------------------------------------------
void __fastcall CTaskComplexLeaveCarAndWander::Serialize(CTaskComplexLeaveCarAndWander *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CVehicle *m_pTargetVehicle; // r0
  int v5; // r5
  _DWORD *v6; // r6
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r5
  _DWORD *v10; // r5
  _DWORD *v11; // r5

  v2 = (*((int (__fastcall **)(CTaskComplexLeaveCarAndWander *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexLeaveCarAndWander *))this->_vptr$CTask + 5))(this) == 707 )
  {
    m_pTargetVehicle = this->m_pTargetVehicle;
    if ( m_pTargetVehicle )
    {
      v5 = GettPoolVehicleRef(m_pTargetVehicle);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    free(v7);
    if ( UseDataFence )
      AddDataFence();
    v10 = malloc(4u);
    *v10 = this->m_iTargetDoor;
    CGenericGameStorage::_SaveDataToWorkBuffer(v10, 4);
    free(v10);
    if ( UseDataFence )
      AddDataFence();
    v11 = malloc(4u);
    *v11 = this->m_iDelayTime;
    CGenericGameStorage::_SaveDataToWorkBuffer(v11, 4);
    free(v11);
    if ( UseDataFence )
      AddDataFence();
    sub_19E9A8(&this->m_bSensibleLeaveCar, 1);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexLeaveCarAndWander *))this->_vptr$CTask + 5))(this);
    sub_1941C4(707, v8);
  }
}

//----- (004FE850) --------------------------------------------------------
CTask *__fastcall CTaskComplexLeaveCarAndFlee::Clone(const CTaskComplexLeaveCarAndFlee *this)
{
  CTaskComplex *v2; // r0
  __int64 v3; // kr00_8
  CTaskComplex *v4; // r4
  int m_iDelayTime; // r9
  __int64 v6; // d16

  v2 = (CTaskComplex *)CTask::operator new(0x28u);
  v3 = *(_QWORD *)&this->m_pTargetVehicle;
  v4 = v2;
  m_iDelayTime = this->m_iDelayTime;
  CTaskComplex::CTaskComplex(v2);
  v4[1].m_pParent = (CTask *)HIDWORD(v3);
  v4->_vptr$CTask = (int (**)(void))&off_66AC90;
  v4[1]._vptr$CTask = (int (**)(void))v3;
  v6 = *(_QWORD *)&this->m_vFleePoint.x;
  v4[2].m_pParent = (CTask *)LODWORD(this->m_vFleePoint.z);
  v4[2].m_pSubTask = (CTask *)m_iDelayTime;
  LOBYTE(v4[3]._vptr$CTask) = 0;
  *(_QWORD *)&v4[1].m_pSubTask = v6;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)&v4[1]);
  return v4;
}
// 66AC90: using guessed type void *off_66AC90;

//----- (004FE8B0) --------------------------------------------------------
int __fastcall CTaskComplexLeaveCarAndFlee::GetTaskType(const CTaskComplexLeaveCarAndFlee *this)
{
  return 706;
}

//----- (004FE8B8) --------------------------------------------------------
void __fastcall CTaskComplexLeaveCarAndFlee::Serialize(CTaskComplexLeaveCarAndFlee *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CVehicle *m_pTargetVehicle; // r0
  int v5; // r5
  _DWORD *v6; // r6
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r5
  _DWORD *v10; // r5
  __int64 v11; // d16
  _DWORD *v12; // r5
  _DWORD *v13; // r5

  v2 = (*((int (__fastcall **)(CTaskComplexLeaveCarAndFlee *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexLeaveCarAndFlee *))this->_vptr$CTask + 5))(this) == 706 )
  {
    m_pTargetVehicle = this->m_pTargetVehicle;
    if ( m_pTargetVehicle )
    {
      v5 = GettPoolVehicleRef(m_pTargetVehicle);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    free(v7);
    if ( UseDataFence )
      AddDataFence();
    v10 = malloc(0xCu);
    v11 = *(_QWORD *)&this->m_vFleePoint.x;
    v10[2] = LODWORD(this->m_vFleePoint.z);
    *(_QWORD *)v10 = v11;
    CGenericGameStorage::_SaveDataToWorkBuffer(v10, 12);
    free(v10);
    if ( UseDataFence )
      AddDataFence();
    v12 = malloc(4u);
    *v12 = this->m_iTargetDoor;
    CGenericGameStorage::_SaveDataToWorkBuffer(v12, 4);
    free(v12);
    if ( UseDataFence )
      AddDataFence();
    v13 = malloc(4u);
    *v13 = this->m_iDelayTime;
    CGenericGameStorage::_SaveDataToWorkBuffer(v13, 4);
    free(v13);
    if ( UseDataFence )
      AddDataFence();
    sub_19E9A8(&this->m_bWaitUntilCarHasSlowedDown, 1);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexLeaveCarAndFlee *))this->_vptr$CTask + 5))(this);
    sub_1941C4(706, v8);
  }
}

//----- (004FEA40) --------------------------------------------------------
CTask *__fastcall CTaskComplexScreamInCarThenLeave::Clone(const CTaskComplexScreamInCarThenLeave *this)
{
  void *v2; // r4
  __int64 v3; // kr00_8

  v2 = CTask::operator new(0x20u);
  v3 = *(_QWORD *)&this->m_pTargetVehicle;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_DWORD *)v2 + 4) = HIDWORD(v3);
  *((_WORD *)v2 + 14) = 0;
  *((_DWORD *)v2 + 5) = 0;
  *((_DWORD *)v2 + 6) = 0;
  *(_DWORD *)v2 = &off_66ACCC;
  *((_DWORD *)v2 + 3) = v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)v2 + 3);
  return (CTask *)v2;
}
// 66ACCC: using guessed type void *off_66ACCC;

//----- (004FEA8C) --------------------------------------------------------
int __fastcall CTaskComplexScreamInCarThenLeave::GetTaskType(const CTaskComplexScreamInCarThenLeave *this)
{
  return 708;
}

//----- (004FEA94) --------------------------------------------------------
void __fastcall CTaskComplexScreamInCarThenLeave::Serialize(CTaskComplexScreamInCarThenLeave *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CVehicle *m_pTargetVehicle; // r0
  int v5; // r5
  _DWORD *v6; // r6
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r5
  _DWORD *v10; // r5

  v2 = (*((int (__fastcall **)(CTaskComplexScreamInCarThenLeave *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexScreamInCarThenLeave *))this->_vptr$CTask + 5))(this) == 708 )
  {
    m_pTargetVehicle = this->m_pTargetVehicle;
    if ( m_pTargetVehicle )
    {
      v5 = GettPoolVehicleRef(m_pTargetVehicle);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    free(v7);
    if ( UseDataFence )
      AddDataFence();
    v10 = malloc(4u);
    *v10 = this->m_iTargetDoor;
    CGenericGameStorage::_SaveDataToWorkBuffer(v10, 4);
    j_free(v10);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexScreamInCarThenLeave *))this->_vptr$CTask + 5))(this);
    sub_1941C4(708, v8);
  }
}

//----- (004FEB94) --------------------------------------------------------
CTask *__fastcall CTaskSimpleCarDrive::Clone(const CTaskSimpleCarDrive *this)
{
  char *v2; // r5
  CVehicle *m_pTargetVehicle; // r6
  char v4; // r0
  char v5; // r0

  v2 = (char *)CTask::operator new(0x60u);
  m_pTargetVehicle = this->m_pTargetVehicle;
  CTaskSimple::CTaskSimple((CTaskSimple *)v2);
  *(_QWORD *)(v2 + 12) = 0LL;
  *(_QWORD *)(v2 + 20) = 0LL;
  *((_WORD *)v2 + 14) = 0;
  *(_DWORD *)(v2 + 86) = 0;
  *(_DWORD *)(v2 + 82) = 0;
  *((_DWORD *)v2 + 19) = 0;
  *((_DWORD *)v2 + 20) = 0;
  v4 = v2[92];
  *(_DWORD *)v2 = &off_66AD08;
  v5 = v4 & 0xC3 | 8;
  v2[92] = v5;
  *((_DWORD *)v2 + 2) = m_pTargetVehicle;
  if ( m_pTargetVehicle )
  {
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v2 + 2);
    v5 = v2[92];
  }
  *((_DWORD *)v2 + 8) = -1;
  v2[92] = v5 & 0xFC;
  *((_DWORD *)v2 + 15) = 0;
  *((_DWORD *)v2 + 16) = 0;
  *((_DWORD *)v2 + 17) = 0;
  v2[92] = v5 & 0xF8 | *((_BYTE *)this + 92) & 4;
  return (CTask *)v2;
}
// 66AD08: using guessed type void *off_66AD08;

//----- (004FEC2C) --------------------------------------------------------
int __fastcall CTaskSimpleCarDrive::GetTaskType(const CTaskSimpleCarDrive *this)
{
  return 709;
}

//----- (004FEC34) --------------------------------------------------------
void __fastcall CTaskSimpleCarDrive::Serialize(CTaskSimpleCarDrive *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r4
  _DWORD *v5; // r5
  int v6; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleCarDrive *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleCarDrive *))this->_vptr$CTask + 5))(this) == 709 )
  {
    v4 = GettPoolVehicleRef(this->m_pTargetVehicle);
    if ( UseDataFence )
      AddDataFence();
    v5 = malloc(4u);
    *v5 = v4;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 4);
    j_free(v5);
  }
  else
  {
    v6 = (*((int (__fastcall **)(CTaskSimpleCarDrive *))this->_vptr$CTask + 5))(this);
    sub_1941C4(709, v6);
  }
}

//----- (004FECD8) --------------------------------------------------------
CTask *__fastcall CTaskComplexCarDrive::Clone(const CTaskComplexCarDrive *this)
{
  void *v2; // r5
  CVehicle *m_pVehicle; // r6
  float m_fCruiseSpeed; // r8
  int m_iDesiredCarModel; // r9
  int m_iDrivingStyle; // r10

  v2 = CTask::operator new(0x24u);
  m_pVehicle = this->m_pVehicle;
  m_fCruiseSpeed = this->m_fCruiseSpeed;
  m_iDesiredCarModel = this->m_iDesiredCarModel;
  m_iDrivingStyle = this->m_iDrivingStyle;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((float *)v2 + 4) = m_fCruiseSpeed;
  *((_DWORD *)v2 + 5) = m_iDesiredCarModel;
  *((_DWORD *)v2 + 6) = m_iDrivingStyle;
  *((_BYTE *)v2 + 28) = 1;
  *((_BYTE *)v2 + 32) = 0;
  *(_DWORD *)v2 = &off_66AD3C;
  *((_DWORD *)v2 + 3) = m_pVehicle;
  if ( m_pVehicle )
    CEntity::RegisterReference(m_pVehicle, (CEntity **)v2 + 3);
  *((_BYTE *)v2 + 28) = this->m_bAsDriver;
  return (CTask *)v2;
}
// 66AD3C: using guessed type void *off_66AD3C;

//----- (004FED34) --------------------------------------------------------
int __fastcall CTaskComplexCarDrive::GetTaskType(const CTaskComplexCarDrive *this)
{
  return 725;
}

//----- (004FED3C) --------------------------------------------------------
void __fastcall CTaskComplexCarDrive::Serialize(CTaskComplexCarDrive *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CVehicle *m_pVehicle; // r0
  int v5; // r5
  _DWORD *v6; // r6
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r5
  float *v10; // r5
  _DWORD *v11; // r5
  _DWORD *v12; // r5

  v2 = (*((int (__fastcall **)(CTaskComplexCarDrive *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexCarDrive *))this->_vptr$CTask + 5))(this) == 725 )
  {
    m_pVehicle = this->m_pVehicle;
    if ( m_pVehicle )
    {
      v5 = GettPoolVehicleRef(m_pVehicle);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    free(v7);
    if ( UseDataFence )
      AddDataFence();
    v10 = (float *)malloc(4u);
    *v10 = this->m_fCruiseSpeed;
    CGenericGameStorage::_SaveDataToWorkBuffer(v10, 4);
    free(v10);
    if ( UseDataFence )
      AddDataFence();
    v11 = malloc(4u);
    *v11 = this->m_iDesiredCarModel;
    CGenericGameStorage::_SaveDataToWorkBuffer(v11, 4);
    free(v11);
    if ( UseDataFence )
      AddDataFence();
    v12 = malloc(4u);
    *v12 = this->m_iDrivingStyle;
    CGenericGameStorage::_SaveDataToWorkBuffer(v12, 4);
    j_free(v12);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexCarDrive *))this->_vptr$CTask + 5))(this);
    sub_1941C4(725, v8);
  }
}

//----- (004FEE98) --------------------------------------------------------
CTask *__fastcall CTaskComplexCarDriveWander::Clone(const CTaskComplexCarDriveWander *this)
{
  CTaskComplex *v2; // r0
  __int64 v3; // kr00_8
  CTaskComplex *v4; // r4
  int m_iDrivingStyle; // r6

  v2 = (CTaskComplex *)CTask::operator new(0x24u);
  v3 = *(_QWORD *)&this->m_pVehicle;
  v4 = v2;
  m_iDrivingStyle = this->m_iDrivingStyle;
  CTaskComplex::CTaskComplex(v2);
  v4[1].m_pParent = (CTask *)HIDWORD(v3);
  v4[1].m_pSubTask = (CTask *)-1;
  v4[2]._vptr$CTask = (int (**)(void))m_iDrivingStyle;
  LOBYTE(v4[2].m_pParent) = 1;
  LOBYTE(v4[2].m_pSubTask) = 0;
  v4->_vptr$CTask = (int (**)(void))&off_66AD3C;
  v4[1]._vptr$CTask = (int (**)(void))v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)&v4[1]);
  v4->_vptr$CTask = (int (**)(void))&off_66AD84;
  return v4;
}
// 66AD3C: using guessed type void *off_66AD3C;
// 66AD84: using guessed type void *off_66AD84;

//----- (004FEF00) --------------------------------------------------------
int __fastcall CTaskComplexCarDriveWander::GetTaskType(const CTaskComplexCarDriveWander *this)
{
  return 711;
}

//----- (004FEF08) --------------------------------------------------------
void __fastcall CTaskComplexCarDriveWander::Serialize(CTaskComplexCarDriveWander *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r5
  _DWORD *v5; // r6
  _DWORD *v6; // r5
  float *v7; // r5
  int v8; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexCarDriveWander *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexCarDriveWander *))this->_vptr$CTask + 5))(this) == 711 )
  {
    v4 = GettPoolVehicleRef(this->m_pVehicle);
    if ( UseDataFence )
      AddDataFence();
    v5 = malloc(4u);
    *v5 = v4;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 4);
    free(v5);
    if ( UseDataFence )
      AddDataFence();
    v6 = malloc(4u);
    *v6 = this->m_iDrivingStyle;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
    free(v6);
    if ( UseDataFence )
      AddDataFence();
    v7 = (float *)malloc(4u);
    *v7 = this->m_fCruiseSpeed;
    CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
    j_free(v7);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexCarDriveWander *))this->_vptr$CTask + 5))(this);
    sub_1941C4(711, v8);
  }
}

//----- (004FF008) --------------------------------------------------------
CTask *__fastcall CTaskComplexCarDriveMission::Clone(const CTaskComplexCarDriveMission *this)
{
  CTaskComplex *v2; // r0
  __int64 v3; // kr00_8
  CTaskComplex *v4; // r4
  int m_iDrivingStyle; // r10
  __int64 v6; // kr08_8

  v2 = (CTaskComplex *)CTask::operator new(0x2Cu);
  v3 = *(_QWORD *)&this->m_pVehicle;
  v4 = v2;
  m_iDrivingStyle = this->m_iDrivingStyle;
  v6 = *(_QWORD *)&this->m_pTargetEntity;
  CTaskComplex::CTaskComplex(v2);
  v4[1].m_pParent = (CTask *)HIDWORD(v3);
  v4[1].m_pSubTask = (CTask *)-1;
  v4[2]._vptr$CTask = (int (**)(void))m_iDrivingStyle;
  LOBYTE(v4[2].m_pParent) = 1;
  LOBYTE(v4[2].m_pSubTask) = 0;
  v4->_vptr$CTask = (int (**)(void))&off_66AD3C;
  v4[1]._vptr$CTask = (int (**)(void))v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)&v4[1]);
  v4[3].m_pParent = (CTask *)HIDWORD(v6);
  v4->_vptr$CTask = (int (**)(void))&off_66ADCC;
  v4[3]._vptr$CTask = (int (**)(void))v6;
  if ( (_DWORD)v6 )
    CEntity::RegisterReference((CEntity *)v6, (CEntity **)&v4[3]);
  return v4;
}
// 66AD3C: using guessed type void *off_66AD3C;
// 66ADCC: using guessed type void *off_66ADCC;

//----- (004FF08C) --------------------------------------------------------
int __fastcall CTaskComplexCarDriveMission::GetTaskType(const CTaskComplexCarDriveMission *this)
{
  return 724;
}

//----- (004FF094) --------------------------------------------------------
void __fastcall CTaskComplexCarDriveMission::Serialize(CTaskComplexCarDriveMission *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r5
  _DWORD *v5; // r6
  CEntity *m_pTargetEntity; // r0
  int v7; // r6
  _DWORD *v8; // r5
  CEntity *v9; // r0
  int v10; // r1
  int v11; // r5
  int v12; // r0
  _DWORD *v13; // r5
  void *v14; // r0
  _DWORD *v15; // r6
  _DWORD *v16; // r5

  v2 = (*((int (__fastcall **)(CTaskComplexCarDriveMission *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexCarDriveMission *))this->_vptr$CTask + 5))(this) != 724 )
  {
    v12 = (*((int (__fastcall **)(CTaskComplexCarDriveMission *))this->_vptr$CTask + 5))(this);
    sub_1941C4(724, v12);
    return;
  }
  v4 = GettPoolVehicleRef(this->m_pVehicle);
  if ( UseDataFence )
    AddDataFence();
  v5 = malloc(4u);
  *v5 = v4;
  CGenericGameStorage::_SaveDataToWorkBuffer(v5, 4);
  free(v5);
  m_pTargetEntity = this->m_pTargetEntity;
  if ( !m_pTargetEntity )
  {
    if ( UseDataFence )
      AddDataFence();
    v13 = malloc(4u);
    *v13 = 0;
    CGenericGameStorage::_SaveDataToWorkBuffer(v13, 4);
    v14 = v13;
    goto LABEL_22;
  }
  v7 = *(_BYTE *)&m_pTargetEntity->m_info & 7;
  if ( UseDataFence )
    AddDataFence();
  v8 = malloc(4u);
  *v8 = v7;
  CGenericGameStorage::_SaveDataToWorkBuffer(v8, 4);
  free(v8);
  v9 = this->m_pTargetEntity;
  v10 = *(_BYTE *)&v9->m_info & 7;
  switch ( v10 )
  {
    case 2:
      v11 = GettPoolVehicleRef((CVehicle *)v9);
      goto LABEL_19;
    case 4:
      v11 = GettPoolObjRef((CObject *)v9);
      goto LABEL_19;
    case 3:
      v11 = GettPoolPedRef((CPed *)v9);
LABEL_19:
      if ( UseDataFence )
        AddDataFence();
      v15 = malloc(4u);
      *v15 = v11;
      CGenericGameStorage::_SaveDataToWorkBuffer(v15, 4);
      v14 = v15;
LABEL_22:
      free(v14);
      break;
  }
  if ( UseDataFence )
    AddDataFence();
  v16 = malloc(4u);
  *v16 = this->m_iMission;
  CGenericGameStorage::_SaveDataToWorkBuffer(v16, 4);
  j_free(v16);
}

//----- (004FF22C) --------------------------------------------------------
CTask *__fastcall CTaskComplexDriveToPoint::Clone(const CTaskComplexDriveToPoint *this)
{
  char *v2; // r4
  CVehicle *m_pVehicle; // r5
  __int64 v4; // r10
  int m_iDrivingStyle; // r8
  float m_fTargetRadius; // r9
  CVector *p_m_vTarget; // r6
  __int64 v8; // d16
  CTask *result; // r0
  int m_iMode; // [sp+0h] [bp-20h]

  v2 = (char *)CTask::operator new(0x3Cu);
  m_pVehicle = this->m_pVehicle;
  v4 = *(_QWORD *)&this->m_fCruiseSpeed;
  m_iDrivingStyle = this->m_iDrivingStyle;
  m_iMode = this->m_iMode;
  m_fTargetRadius = this->m_fTargetRadius;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_QWORD *)v2 + 2) = v4;
  *((_DWORD *)v2 + 6) = m_iDrivingStyle;
  v2[28] = 1;
  v2[32] = 0;
  p_m_vTarget = &this->m_vTarget;
  *(_DWORD *)v2 = &off_66AD3C;
  *((_DWORD *)v2 + 3) = m_pVehicle;
  if ( m_pVehicle )
    CEntity::RegisterReference(m_pVehicle, (CEntity **)v2 + 3);
  *(_DWORD *)v2 = &off_66AE14;
  v8 = *(_QWORD *)&p_m_vTarget->x;
  *((_DWORD *)v2 + 11) = LODWORD(p_m_vTarget->z);
  *((_DWORD *)v2 + 12) = m_iMode;
  *((float *)v2 + 13) = m_fTargetRadius;
  result = (CTask *)v2;
  v2[56] = 0;
  *(_QWORD *)(v2 + 36) = v8;
  return result;
}
// 66AD3C: using guessed type void *off_66AD3C;
// 66AE14: using guessed type void *off_66AE14;

//----- (004FF2C0) --------------------------------------------------------
int __fastcall CTaskComplexDriveToPoint::GetTaskType(const CTaskComplexDriveToPoint *this)
{
  return 710;
}

//----- (004FF2C8) --------------------------------------------------------
void __fastcall CTaskComplexDriveToPoint::Serialize(CTaskComplexDriveToPoint *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r5
  _DWORD *v5; // r6
  _DWORD *v6; // r5
  __int64 v7; // d16
  float m_fCruiseSpeed; // r6
  float *v9; // r5
  _DWORD *v10; // r5
  _DWORD *v11; // r5
  float m_fTargetRadius; // r6
  float *v13; // r5
  _DWORD *v14; // r5
  int v15; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexDriveToPoint *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexDriveToPoint *))this->_vptr$CTask + 5))(this) == 710 )
  {
    v4 = GettPoolVehicleRef(this->m_pVehicle);
    if ( UseDataFence )
      AddDataFence();
    v5 = malloc(4u);
    *v5 = v4;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 4);
    free(v5);
    if ( UseDataFence )
      AddDataFence();
    v6 = malloc(0xCu);
    v7 = *(_QWORD *)&this->m_vTarget.x;
    v6[2] = LODWORD(this->m_vTarget.z);
    *(_QWORD *)v6 = v7;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 12);
    free(v6);
    m_fCruiseSpeed = this->m_fCruiseSpeed;
    if ( UseDataFence )
      AddDataFence();
    v9 = (float *)malloc(4u);
    *v9 = m_fCruiseSpeed;
    CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
    free(v9);
    if ( UseDataFence )
      AddDataFence();
    v10 = malloc(4u);
    *v10 = this->m_iMode;
    CGenericGameStorage::_SaveDataToWorkBuffer(v10, 4);
    free(v10);
    if ( UseDataFence )
      AddDataFence();
    v11 = malloc(4u);
    *v11 = this->m_iDesiredCarModel;
    CGenericGameStorage::_SaveDataToWorkBuffer(v11, 4);
    free(v11);
    m_fTargetRadius = this->m_fTargetRadius;
    if ( UseDataFence )
      AddDataFence();
    v13 = (float *)malloc(4u);
    *v13 = m_fTargetRadius;
    CGenericGameStorage::_SaveDataToWorkBuffer(v13, 4);
    free(v13);
    if ( UseDataFence )
      AddDataFence();
    v14 = malloc(4u);
    *v14 = this->m_iDrivingStyle;
    CGenericGameStorage::_SaveDataToWorkBuffer(v14, 4);
    j_free(v14);
  }
  else
  {
    v15 = (*((int (__fastcall **)(CTaskComplexDriveToPoint *))this->_vptr$CTask + 5))(this);
    sub_1941C4(710, v15);
  }
}

//----- (004FF488) --------------------------------------------------------
CTask *__fastcall CTaskComplexDrivePointRoute::Clone(const CTaskComplexDrivePointRoute *this)
{
  char *v2; // r4
  __int64 v3; // kr00_8
  __int64 v4; // d8
  __int64 v5; // d9
  int m_iDrivingStyle; // r8
  _DWORD *v7; // r0
  int v8; // r1
  int v9; // r1
  _DWORD *v10; // r2
  int v11; // r3
  __int64 v12; // d16
  int v13; // r6

  v2 = (char *)CTask::operator new(0x2Cu);
  v3 = *(_QWORD *)&this->m_pVehicle;
  v4 = *(_QWORD *)&this->m_fCruiseSpeed;
  v5 = *(_QWORD *)&this->m_iDesiredCarModel;
  m_iDrivingStyle = this->m_iDrivingStyle;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_DWORD *)v2 + 3) = v3;
  *(_DWORD *)v2 = &off_66AE5C;
  v7 = CPointRoute::operator new(0x64u);
  v8 = *(_DWORD *)HIDWORD(v3);
  *v7 = *(_DWORD *)HIDWORD(v3);
  if ( v8 >= 1 )
  {
    v9 = HIDWORD(v3) + 4;
    v10 = v7 + 1;
    v11 = 0;
    do
    {
      v12 = *(_QWORD *)v9;
      ++v11;
      v13 = *(_DWORD *)(v9 + 8);
      v9 += 12;
      v10[2] = v13;
      *(_QWORD *)v10 = v12;
      v10 += 3;
    }
    while ( v11 < *v7 );
  }
  *((_DWORD *)v2 + 4) = v7;
  *((_DWORD *)v2 + 9) = m_iDrivingStyle;
  *((_DWORD *)v2 + 10) = 0;
  *(_QWORD *)(v2 + 20) = v4;
  *(_QWORD *)(v2 + 28) = v5;
  return (CTask *)v2;
}
// 66AE5C: using guessed type void *off_66AE5C;

//----- (004FF510) --------------------------------------------------------
int __fastcall CTaskComplexDrivePointRoute::GetTaskType(const CTaskComplexDrivePointRoute *this)
{
  return 721;
}

//----- (004FF518) --------------------------------------------------------
void __fastcall CTaskComplexDrivePointRoute::Serialize(CTaskComplexDrivePointRoute *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CVehicle *m_pVehicle; // r0
  int v5; // r5
  _DWORD *v6; // r6
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r5
  CPointRoute *m_pRoute; // r5
  CPointRoute *v11; // r6
  float *v12; // r5
  _DWORD *v13; // r5
  _DWORD *v14; // r5
  float *v15; // r5
  _DWORD *v16; // r5

  v2 = (*((int (__fastcall **)(CTaskComplexDrivePointRoute *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexDrivePointRoute *))this->_vptr$CTask + 5))(this) == 721 )
  {
    m_pVehicle = this->m_pVehicle;
    if ( m_pVehicle )
    {
      v5 = GettPoolVehicleRef(m_pVehicle);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    free(v7);
    if ( UseDataFence )
      AddDataFence();
    m_pRoute = this->m_pRoute;
    v11 = (CPointRoute *)malloc(0x64u);
    qmemcpy(v11, m_pRoute, sizeof(CPointRoute));
    CGenericGameStorage::_SaveDataToWorkBuffer(v11, 100);
    free(v11);
    if ( UseDataFence )
      AddDataFence();
    v12 = (float *)malloc(4u);
    *v12 = this->m_fCruiseSpeed;
    CGenericGameStorage::_SaveDataToWorkBuffer(v12, 4);
    free(v12);
    if ( UseDataFence )
      AddDataFence();
    v13 = malloc(4u);
    *v13 = this->m_iMode;
    CGenericGameStorage::_SaveDataToWorkBuffer(v13, 4);
    free(v13);
    if ( UseDataFence )
      AddDataFence();
    v14 = malloc(4u);
    *v14 = this->m_iDesiredCarModel;
    CGenericGameStorage::_SaveDataToWorkBuffer(v14, 4);
    free(v14);
    if ( UseDataFence )
      AddDataFence();
    v15 = (float *)malloc(4u);
    *v15 = this->m_fTargetRadius;
    CGenericGameStorage::_SaveDataToWorkBuffer(v15, 4);
    free(v15);
    if ( UseDataFence )
      AddDataFence();
    v16 = malloc(4u);
    *v16 = this->m_iDrivingStyle;
    CGenericGameStorage::_SaveDataToWorkBuffer(v16, 4);
    j_free(v16);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexDrivePointRoute *))this->_vptr$CTask + 5))(this);
    sub_1941C4(721, v8);
  }
}

//----- (004FF704) --------------------------------------------------------
CTask *__fastcall CTaskComplexEnterAnyCarAsDriver::Clone(const CTaskComplexEnterAnyCarAsDriver *this)
{
  CTaskComplex *v1; // r0
  CTask *result; // r0

  v1 = (CTaskComplex *)CTask::operator new(0xCu);
  CTaskComplex::CTaskComplex(v1);
  result->_vptr$CTask = (int (**)(void))&off_66AE98;
  return result;
}
// 4FF71A: variable 'result' is possibly undefined
// 66AE98: using guessed type void *;
// 677740: using guessed type void *`vtable for'CTaskComplexEnterAnyCarAsDriver;

//----- (004FF724) --------------------------------------------------------
int __fastcall CTaskComplexEnterAnyCarAsDriver::GetTaskType(const CTaskComplexEnterAnyCarAsDriver *this)
{
  return 717;
}

//----- (004FF72C) --------------------------------------------------------
void __fastcall CTaskComplexEnterAnyCarAsDriver::Serialize(CTaskComplexEnterAnyCarAsDriver *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexEnterAnyCarAsDriver *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexEnterAnyCarAsDriver *))this->_vptr$CTask + 5))(this) != 717 )
  {
    v4 = (*((int (__fastcall **)(CTaskComplexEnterAnyCarAsDriver *))this->_vptr$CTask + 5))(this);
    sub_1941C4(717, v4);
  }
}

//----- (004FF79C) --------------------------------------------------------
CTask *__fastcall CTaskComplexShuffleSeats::Clone(const CTaskComplexShuffleSeats *this)
{
  void *v2; // r4
  CVehicle *m_pTargetVehicle; // r5

  v2 = CTask::operator new(0x2Cu);
  m_pTargetVehicle = this->m_pTargetVehicle;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_DWORD *)v2 + 9) = 0;
  *((_BYTE *)v2 + 40) = 0;
  *(_DWORD *)v2 = &off_66AED4;
  *((_DWORD *)v2 + 3) = m_pTargetVehicle;
  if ( m_pTargetVehicle )
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v2 + 3);
  return (CTask *)v2;
}
// 66AED4: using guessed type void *off_66AED4;

//----- (004FF7DC) --------------------------------------------------------
int __fastcall CTaskComplexShuffleSeats::GetTaskType(const CTaskComplexShuffleSeats *this)
{
  return 720;
}

//----- (004FF7E4) --------------------------------------------------------
void __fastcall CTaskComplexShuffleSeats::Serialize(CTaskComplexShuffleSeats *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CVehicle *m_pTargetVehicle; // r0
  int v5; // r4
  _DWORD *v6; // r5
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r4

  v2 = (*((int (__fastcall **)(CTaskComplexShuffleSeats *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexShuffleSeats *))this->_vptr$CTask + 5))(this) == 720 )
  {
    m_pTargetVehicle = this->m_pTargetVehicle;
    if ( m_pTargetVehicle )
    {
      v5 = GettPoolVehicleRef(m_pTargetVehicle);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    j_free(v7);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexShuffleSeats *))this->_vptr$CTask + 5))(this);
    sub_1941C4(720, v8);
  }
}

//----- (004FF8B4) --------------------------------------------------------
CTask *__fastcall CTaskSimpleCarSetTempAction::Clone(const CTaskSimpleCarSetTempAction *this)
{
  CTaskSimple *v2; // r0
  CVehicle *m_pTargetVehicle; // r5
  CTaskSimple *v4; // r4
  CTaskSimple v5; // r8
  char m_pParent; // r0
  char v7; // r0

  v2 = (CTaskSimple *)CTask::operator new(0x68u);
  m_pTargetVehicle = this->m_pTargetVehicle;
  v4 = v2;
  v5 = *(CTaskSimple *)&this->m_iAction;
  CTaskSimple::CTaskSimple(v2);
  *(_QWORD *)&v4[1].m_pParent = 0LL;
  *(_QWORD *)&v4[2].m_pParent = 0LL;
  LOWORD(v4[3].m_pParent) = 0;
  *(CTask **)((char *)&v4[10].m_pParent + 2) = 0;
  *(int (***)(void))((char *)&v4[10]._vptr$CTask + 2) = 0;
  v4[9].m_pParent = 0;
  v4[10]._vptr$CTask = 0;
  m_pParent = (char)v4[11].m_pParent;
  v4->_vptr$CTask = (int (**)(void))&off_66AD08;
  v7 = m_pParent & 0xC3 | 8;
  LOBYTE(v4[11].m_pParent) = v7;
  v4[1]._vptr$CTask = (int (**)(void))m_pTargetVehicle;
  if ( m_pTargetVehicle )
  {
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)&v4[1]);
    v7 = (char)v4[11].m_pParent;
  }
  v4[4]._vptr$CTask = (int (**)(void))-1;
  LOBYTE(v4[11].m_pParent) = v7 & 0xFC;
  v4[7].m_pParent = 0;
  v4[8]._vptr$CTask = 0;
  v4[8].m_pParent = 0;
  v4[12] = v5;
  v4->_vptr$CTask = (int (**)(void))&off_66AF10;
  return v4;
}
// 66AD08: using guessed type void *off_66AD08;
// 66AF10: using guessed type void *off_66AF10;

//----- (004FF954) --------------------------------------------------------
int __fastcall CTaskSimpleCarSetTempAction::GetTaskType(const CTaskSimpleCarSetTempAction *this)
{
  return 723;
}

//----- (004FF95C) --------------------------------------------------------
void __fastcall CTaskSimpleCarSetTempAction::Serialize(CTaskSimpleCarSetTempAction *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r5
  _DWORD *v5; // r6
  _DWORD *v6; // r5
  _DWORD *v7; // r5
  int v8; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleCarSetTempAction *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleCarSetTempAction *))this->_vptr$CTask + 5))(this) == 723 )
  {
    v4 = GettPoolVehicleRef(this->m_pTargetVehicle);
    if ( UseDataFence )
      AddDataFence();
    v5 = malloc(4u);
    *v5 = v4;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 4);
    free(v5);
    if ( UseDataFence )
      AddDataFence();
    v6 = malloc(4u);
    *v6 = this->m_iAction;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
    free(v6);
    if ( UseDataFence )
      AddDataFence();
    v7 = malloc(4u);
    *v7 = this->m_iTime;
    CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
    j_free(v7);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskSimpleCarSetTempAction *))this->_vptr$CTask + 5))(this);
    sub_1941C4(723, v8);
  }
}

//----- (004FFA60) --------------------------------------------------------
void __fastcall CTaskComplexGoToCarDoorAndStandStill::CTaskComplexGoToCarDoorAndStandStill(
        CTaskComplexGoToCarDoorAndStandStill *this,
        CVehicle *pTargetVehicle,
        const int iMoveState,
        const bool bIsDriver,
        const int iTargetSeat,
        const float fTargetRadius,
        const float fSlowDownDistance,
        const float fMaxSeekDistance,
        const int iMaxSeekTime)
{
  CTaskComplex::CTaskComplex(this);
  this->m_iMoveState = iMoveState;
  this->m_bIsDriver = bIsDriver;
  this->m_fTargetRadius = fTargetRadius;
  this->m_fSlowDownDistance = fSlowDownDistance;
  this->m_fMaxSeekDistance = fMaxSeekDistance;
  this->m_iMaxSeekTime = iMaxSeekTime;
  *(_WORD *)&this->m_timer.m_bIsActive = 0;
  this->m_iTargetSeat = iTargetSeat;
  *(_WORD *)&this->m_bTryingToEnterInWater = 0;
  this->m_RouteToDoor = 0;
  this->m_timer.m_iDuration = 0;
  *(_QWORD *)&this->m_iTargetDoor = 0LL;
  *(_QWORD *)&this->m_vTarget.y = 0LL;
  this->m_timer.m_iStartTime = 0;
  this->_vptr$CTask = (int (**)(void))&off_66AFBC;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66AFBC: using guessed type void *;

//----- (004FFAE0) --------------------------------------------------------
void __fastcall CTaskComplexGoToCarDoorAndStandStill::~CTaskComplexGoToCarDoorAndStandStill(
        CTaskComplexGoToCarDoorAndStandStill *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CPointRoute *m_RouteToDoor; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AFBC;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_RouteToDoor = this->m_RouteToDoor;
  if ( m_RouteToDoor )
    CPointRoute::operator delete(m_RouteToDoor);
  sub_18EDB4(this);
}
// 66AFBC: using guessed type void *off_66AFBC;

//----- (004FFB18) --------------------------------------------------------
void __fastcall CTaskComplexGoToCarDoorAndStandStill::~CTaskComplexGoToCarDoorAndStandStill(
        CTaskComplexGoToCarDoorAndStandStill *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CPointRoute *m_RouteToDoor; // r0
  void *v5; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AFBC;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_RouteToDoor = this->m_RouteToDoor;
  if ( m_RouteToDoor )
    CPointRoute::operator delete(m_RouteToDoor);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v5);
}
// 4FFB4A: variable 'v5' is possibly undefined
// 66AFBC: using guessed type void *off_66AFBC;

//----- (004FFB54) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToCarDoorAndStandStill::CreateNextSubTask(
        CTaskComplexGoToCarDoorAndStandStill *this,
        CPed *pPed)
{
  int v4; // r0
  void *v5; // r5
  __int64 v6; // d16
  CTaskSimple *v8; // r0
  CVehicle *m_pTargetVehicle; // r6
  int m_iTargetDoor; // r4
  CMatrix *m_pMat; // r1
  CTask *m_pSubTask; // r0
  CSimpleTransform *p_tx; // r2
  CMatrix *v14; // r0
  CSimpleTransform *p_m_transform; // r1
  float32x2_t v16; // d16
  unsigned __int64 v17; // d0
  CVector v18; // [sp+8h] [bp-20h] BYREF

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  v5 = 0;
  if ( v4 >= 828 )
  {
    if ( v4 == 828 )
    {
      v8 = (CTaskSimple *)CTask::operator new(0x14u);
      m_pTargetVehicle = this->m_pTargetVehicle;
      v5 = v8;
      m_iTargetDoor = this->m_iTargetDoor;
      CTaskSimple::CTaskSimple(v8);
      *((_DWORD *)v5 + 3) = m_iTargetDoor;
      *((_DWORD *)v5 + 4) = 0;
      *(_DWORD *)v5 = &off_66B1CC;
      *((_DWORD *)v5 + 2) = m_pTargetVehicle;
      if ( m_pTargetVehicle )
        CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v5 + 2);
      return (CTask *)v5;
    }
    if ( v4 != 900 )
    {
      if ( v4 == 905 )
      {
        CCarEnterExit::GetPositionToOpenCarDoor(&v18, this->m_pTargetVehicle, this->m_iTargetDoor);
        v6 = *(_QWORD *)&v18.x;
        this->m_vTarget.z = v18.z;
        *(_QWORD *)&this->m_vTarget.x = v6;
        *((_DWORD *)&pPed->m_nPedFlags + 2) |= 8u;
        v5 = CTask::operator new(0x2Cu);
        CTaskSimpleGoToPoint::CTaskSimpleGoToPoint(
          (CTaskSimpleGoToPoint *)v5,
          this->m_iMoveState,
          &this->m_vTarget,
          this->m_fTargetRadius,
          1,
          0);
      }
      return (CTask *)v5;
    }
    m_pMat = pPed->m_pMat;
    v5 = 0;
    m_pSubTask = this->m_pSubTask;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pPed->m_transform;
    if ( fabsf(*(float *)&m_pSubTask[2].m_pParent - p_tx->m_translate.z) >= 3.0
      || (BYTE1(m_pSubTask[3].m_pParent) & 4) == 0 )
    {
      return (CTask *)v5;
    }
LABEL_20:
    this->m_bAchievedTargetDoor = 1;
    return 0;
  }
  if ( v4 == 202 )
  {
    if ( !this->m_bTryingToEnterInWater )
      return 0;
    v14 = pPed->m_pMat;
    p_m_transform = (CSimpleTransform *)&v14->tx;
    if ( !v14 )
      p_m_transform = &pPed->m_transform;
    v16.n64_u64[0] = vsub_f32(*(float32x2_t *)&this->m_vTarget.x, *(float32x2_t *)&p_m_transform->m_translate.x).n64_u64[0];
    v17 = vmul_f32(v16, v16).n64_u64[0];
    if ( sqrtf(*(float *)&v17 + *((float *)&v17 + 1)) >= 0.5 )
      return 0;
    goto LABEL_20;
  }
  if ( v4 == 810 )
    return (CTask *)(*((int (__fastcall **)(CTaskComplexGoToCarDoorAndStandStill *, CPed *))this->_vptr$CTask + 11))(
                      this,
                      pPed);
  return (CTask *)v5;
}
// 66B1CC: using guessed type void *off_66B1CC;

//----- (004FFCA0) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToCarDoorAndStandStill::CreateSubTask(
        const CTaskComplexGoToCarDoorAndStandStill *this,
        const int iSubTaskType,
        CPed *pPed)
{
  void *v4; // r4
  CTaskSimple *v5; // r0
  CVehicle *m_pTargetVehicle; // r6
  int m_iTargetDoor; // r5

  v4 = 0;
  if ( iSubTaskType >= 828 )
  {
    switch ( iSubTaskType )
    {
      case 828:
        *((_DWORD *)&pPed->m_nPedFlags + 2) |= 8u;
        v4 = CTask::operator new(0x10u);
        CTaskSimpleCarGoToPointNearDoorUntilDoorNotInUse::CTaskSimpleCarGoToPointNearDoorUntilDoorNotInUse(
          (CTaskSimpleCarGoToPointNearDoorUntilDoorNotInUse *)v4,
          this->m_pTargetVehicle,
          this->m_iTargetDoor,
          &this->m_vTarget,
          this->m_iMoveState);
        break;
      case 905:
        v4 = CTask::operator new(0x3Cu);
        CTaskComplexFollowPointRoute::CTaskComplexFollowPointRoute(
          (CTaskComplexFollowPointRoute *)v4,
          this->m_iMoveState,
          this->m_RouteToDoor,
          0,
          0.5,
          5.0,
          0,
          0,
          0);
        break;
      case 900:
        *((_DWORD *)&pPed->m_nPedFlags + 2) |= 8u;
        v4 = CTask::operator new(0x2Cu);
        CTaskSimpleGoToPoint::CTaskSimpleGoToPoint(
          (CTaskSimpleGoToPoint *)v4,
          this->m_iMoveState,
          &this->m_vTarget,
          this->m_fTargetRadius,
          1,
          0);
        break;
    }
  }
  else
  {
    switch ( iSubTaskType )
    {
      case 202:
        v4 = CTask::operator new(0x18u);
        CTaskSimple::CTaskSimple((CTaskSimple *)v4);
        *((_WORD *)v4 + 8) = 0;
        *((_DWORD *)v4 + 5) = 1;
        *((_DWORD *)v4 + 2) = 0;
        *((_DWORD *)v4 + 3) = 0;
        *(_DWORD *)v4 = &off_665750;
        break;
      case 203:
        v4 = CTask::operator new(0x20u);
        CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v4, 1, 0, 0, 8.0);
        break;
      case 810:
        v5 = (CTaskSimple *)CTask::operator new(0x14u);
        m_pTargetVehicle = this->m_pTargetVehicle;
        v4 = v5;
        m_iTargetDoor = this->m_iTargetDoor;
        CTaskSimple::CTaskSimple(v5);
        *((_DWORD *)v4 + 3) = m_iTargetDoor;
        *((_DWORD *)v4 + 4) = 0;
        *(_DWORD *)v4 = &off_66B1CC;
        *((_DWORD *)v4 + 2) = m_pTargetVehicle;
        if ( m_pTargetVehicle )
          CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v4 + 2);
        break;
    }
  }
  return (CTask *)v4;
}
// 665750: using guessed type void *off_665750;
// 66B1CC: using guessed type void *off_66B1CC;
// 678E00: using guessed type void *`vtable for'CTaskSimplePause;

//----- (004FFDF0) --------------------------------------------------------
bool __fastcall CTaskComplexGoToCarDoorAndStandStill::MakeAbortable(
        CTaskComplexGoToCarDoorAndStandStill *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CTask *m_bTryingToEnterInWater; // r0
  bool v9; // zf
  int v10; // r0

  m_bTryingToEnterInWater = (CTask *)this->m_bTryingToEnterInWater;
  v9 = m_bTryingToEnterInWater == 0;
  if ( m_bTryingToEnterInWater )
  {
    m_bTryingToEnterInWater = this->m_pSubTask;
    v9 = m_bTryingToEnterInWater == 0;
  }
  if ( !v9
    && (v10 = (*((int (__fastcall **)(CTask *))m_bTryingToEnterInWater->_vptr$CTask + 5))(m_bTryingToEnterInWater),
        pEvent)
    && v10 == 202
    && ((*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 66
     || (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 33) )
  {
    return 0;
  }
  else
  {
    return (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
            + 7))(
             this->m_pSubTask,
             pPed,
             iPriority,
             pEvent);
  }
}

//----- (004FFE52) --------------------------------------------------------
bool __fastcall CTaskComplexGoToCarDoorAndStandStill::IsVehicleInRange(
        const CTaskComplexGoToCarDoorAndStandStill *this,
        const CPed *ped)
{
  CVehicle *m_pTargetVehicle; // r12
  CMatrix *m_pMat; // r3
  CMatrix *v4; // lr
  CSimpleTransform *p_tx; // r2
  CSimpleTransform *p_m_transform; // r1
  float m_fMaxSeekDistance; // s4
  float32x2_t v8; // d16
  bool result; // r0
  unsigned __int64 v10; // d1

  m_pTargetVehicle = this->m_pTargetVehicle;
  m_pMat = ped->m_pMat;
  v4 = m_pTargetVehicle->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &ped->m_transform;
  p_m_transform = (CSimpleTransform *)&v4->tx;
  if ( !v4 )
    p_m_transform = &m_pTargetVehicle->m_transform;
  m_fMaxSeekDistance = this->m_fMaxSeekDistance;
  v8.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
  result = 0;
  v10 = vmul_f32(v8, v8).n64_u64[0];
  if ( (float)((float)((float)((float)(p_m_transform->m_translate.x - p_tx->m_translate.x)
                             * (float)(p_m_transform->m_translate.x - p_tx->m_translate.x))
                     + *(float *)&v10)
             + *((float *)&v10 + 1)) < (float)(m_fMaxSeekDistance * m_fMaxSeekDistance) )
    return 1;
  return result;
}

//----- (004FFEB8) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToCarDoorAndStandStill::CreateFirstSubTask(
        CTaskComplexGoToCarDoorAndStandStill *this,
        CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r1
  CMatrix *m_pMat; // r0
  CMatrix *v6; // r2
  CSimpleTransform *p_tx; // r3
  CSimpleTransform *p_m_transform; // r0
  float32x2_t v9; // d16
  unsigned __int64 v10; // d1
  CTaskSimple *v11; // r0
  CTask *result; // r0
  int m_iTargetSeat; // r2
  __int64 v14; // d16
  CVector *p_m_vTarget; // r2
  CPed *v16; // r0
  CVehicle *v17; // r1
  int v18; // r0
  CVehicle *v19; // r1
  CPed *v20; // r0
  int v21; // r2
  __int64 v22; // d16
  int m_iMaxSeekTime; // r2
  int v24; // r0
  int v25; // r1
  int v26; // r2
  CVehicle *v27; // r1
  int v28; // r0
  CTaskComplexFollowPointRoute *v29; // r0
  CTaskSimpleStandStill *v30; // r0
  int v31; // r2
  CVehicle *v32; // r1
  int v33; // r0
  int v34; // r1
  CTaskSimpleGoToPoint *v35; // r0
  CVector v36; // [sp+18h] [bp-28h] BYREF

  m_pTargetVehicle = this->m_pTargetVehicle;
  m_pMat = pPed->m_pMat;
  v6 = m_pTargetVehicle->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  p_m_transform = (CSimpleTransform *)&v6->tx;
  if ( !v6 )
    p_m_transform = &m_pTargetVehicle->m_transform;
  v9.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
  v10 = vmul_f32(v9, v9).n64_u64[0];
  if ( (float)((float)((float)((float)(p_m_transform->m_translate.x - p_tx->m_translate.x)
                             * (float)(p_m_transform->m_translate.x - p_tx->m_translate.x))
                     + *(float *)&v10)
             + *((float *)&v10 + 1)) >= (float)(this->m_fMaxSeekDistance * this->m_fMaxSeekDistance) )
    goto LABEL_22;
  if ( this->m_bTryingToEnterInWater )
  {
    v11 = (CTaskSimple *)CTask::operator new(0x18u);
    CTaskSimple::CTaskSimple(v11);
    LOWORD(result[2]._vptr$CTask) = 0;
    result[2].m_pParent = (CTask *)(&dword_0 + 1);
    result[1]._vptr$CTask = 0;
    result[1].m_pParent = 0;
    result->_vptr$CTask = (int (**)(void))&off_665750;
    return result;
  }
  m_iTargetSeat = this->m_iTargetSeat;
  if ( !this->m_bIsDriver )
  {
    if ( m_iTargetSeat )
    {
      v18 = CCarEnterExit::ComputePassengerIndexFromCarDoor(m_pTargetVehicle, this->m_iTargetSeat);
      v19 = this->m_pTargetVehicle;
      v20 = v19->pPassengers[v18];
      if ( !v20 || (*((_BYTE *)&v20->m_nPedFlags + 3) & 0x20) == 0 )
      {
        v21 = this->m_iTargetSeat;
        this->m_iTargetDoor = v21;
        CCarEnterExit::GetPositionToOpenCarDoor(&v36, v19, v21);
        v22 = *(_QWORD *)&v36.x;
        this->m_vTarget.z = v36.z;
        *(_QWORD *)&this->m_vTarget.x = v22;
        m_iMaxSeekTime = this->m_iMaxSeekTime;
        v17 = this->m_pTargetVehicle;
        v24 = CTimer::m_snTimeInMilliseconds;
        this->m_timer.m_bIsActive = 1;
        this->m_timer.m_iStartTime = v24;
        this->m_timer.m_iDuration = m_iMaxSeekTime;
        p_m_vTarget = &this->m_vTarget;
        v16 = pPed;
        goto LABEL_15;
      }
LABEL_22:
      v30 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(v30, 1, 0, 0, 8.0);
      return result;
    }
    if ( CCarEnterExit::GetNearestCarPassengerDoor(
           pPed,
           m_pTargetVehicle,
           &this->m_vTarget,
           &this->m_iTargetDoor,
           1,
           1,
           1) == 1 )
    {
      v31 = this->m_iMaxSeekTime;
      v32 = this->m_pTargetVehicle;
      v33 = CTimer::m_snTimeInMilliseconds;
      this->m_timer.m_bIsActive = 1;
      this->m_timer.m_iStartTime = v33;
      this->m_timer.m_iDuration = v31;
      if ( !CCarEnterExit::IsPathToDoorBlockedByVehicleCollisionModel(pPed, v32, &this->m_vTarget) )
      {
        v34 = 900;
        return CTaskComplexGoToCarDoorAndStandStill::CreateSubTask(this, v34, pPed);
      }
    }
    else
    {
      if ( CCarEnterExit::GetNearestCarPassengerDoor(
             pPed,
             this->m_pTargetVehicle,
             &this->m_vTarget,
             &this->m_iTargetDoor,
             1,
             0,
             1) != 1 )
      {
        v34 = 203;
        return CTaskComplexGoToCarDoorAndStandStill::CreateSubTask(this, v34, pPed);
      }
      if ( !CCarEnterExit::IsPathToDoorBlockedByVehicleCollisionModel(pPed, this->m_pTargetVehicle, &this->m_vTarget) )
      {
        v34 = 828;
        return CTaskComplexGoToCarDoorAndStandStill::CreateSubTask(this, v34, pPed);
      }
    }
    CTaskComplexGoToCarDoorAndStandStill::ComputeRouteToDoor(this, pPed);
    v34 = 905;
    return CTaskComplexGoToCarDoorAndStandStill::CreateSubTask(this, v34, pPed);
  }
  if ( !m_iTargetSeat )
  {
    if ( CCarEnterExit::GetNearestCarDoor(pPed, m_pTargetVehicle, &this->m_vTarget, &this->m_iTargetDoor) )
    {
      v26 = this->m_iMaxSeekTime;
      v27 = this->m_pTargetVehicle;
      v28 = CTimer::m_snTimeInMilliseconds;
      this->m_timer.m_bIsActive = 1;
      this->m_timer.m_iStartTime = v28;
      this->m_timer.m_iDuration = v26;
      if ( CCarEnterExit::IsPathToDoorBlockedByVehicleCollisionModel(pPed, v27, &this->m_vTarget) )
      {
        CTaskComplexGoToCarDoorAndStandStill::ComputeRouteToDoor(this, pPed);
        v29 = (CTaskComplexFollowPointRoute *)CTask::operator new(0x3Cu);
        CTaskComplexFollowPointRoute::CTaskComplexFollowPointRoute(
          v29,
          this->m_iMoveState,
          this->m_RouteToDoor,
          0,
          0.5,
          5.0,
          0,
          0,
          0);
      }
      else
      {
        *((_DWORD *)&pPed->m_nPedFlags + 2) |= 8u;
        v35 = (CTaskSimpleGoToPoint *)CTask::operator new(0x2Cu);
        CTaskSimpleGoToPoint::CTaskSimpleGoToPoint(
          v35,
          this->m_iMoveState,
          &this->m_vTarget,
          this->m_fTargetRadius,
          1,
          0);
      }
      return result;
    }
    goto LABEL_22;
  }
  this->m_iTargetDoor = m_iTargetSeat;
  CCarEnterExit::GetPositionToOpenCarDoor(&v36, m_pTargetVehicle, m_iTargetSeat);
  v14 = *(_QWORD *)&v36.x;
  p_m_vTarget = &this->m_vTarget;
  this->m_vTarget.z = v36.z;
  v16 = pPed;
  *(_QWORD *)&this->m_vTarget.x = v14;
  v17 = this->m_pTargetVehicle;
LABEL_15:
  if ( CCarEnterExit::IsPathToDoorBlockedByVehicleCollisionModel(v16, v17, p_m_vTarget) )
  {
    CTaskComplexGoToCarDoorAndStandStill::ComputeRouteToDoor(this, pPed);
    v25 = 905;
  }
  else
  {
    v25 = 900;
  }
  return CTaskComplexGoToCarDoorAndStandStill::CreateSubTask(this, v25, pPed);
}
// 4FFF32: variable 'result' is possibly undefined
// 0: using guessed type int dword_0;
// 665750: using guessed type void *off_665750;
// 678E00: using guessed type void *`vtable for'CTaskSimplePause;

//----- (0050014C) --------------------------------------------------------
void __fastcall CTaskComplexGoToCarDoorAndStandStill::ComputeRouteToDoor(
        CTaskComplexGoToCarDoorAndStandStill *this,
        const CPed *ped)
{
  CPointRoute *m_RouteToDoor; // r0
  int v5; // r5
  CSimpleTransform *p_m_transform; // r8
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r0
  int v9; // r6
  int v10; // r9
  CMatrix *v11; // r0
  CSimpleTransform *v12; // r1
  CVector *v13; // r0
  float x; // s0
  float y; // s2
  float z; // s4
  CMatrix *v17; // r0
  float v18; // s6
  float v19; // s8
  float v20; // s10
  CVector *v21; // r0
  float v22; // s12
  float v23; // s0
  float v24; // s6
  float v25; // s2
  float v26; // s8
  float v27; // s14
  float v28; // s4
  float v29; // s10
  float v30; // s12
  CPointRoute *v31; // r0
  int m_iRouteSize; // r1
  __int64 v33; // d16
  char *v34; // r1
  int v35; // r6
  CVector *m_routePoints; // r2
  int v37; // r3
  __int64 v38; // d16
  char *v39; // r1
  __int64 v40; // d16
  char *v41; // r1
  CPointRoute route; // [sp+Ch] [bp-DCh] BYREF
  CVector vTargetPos; // [sp+70h] [bp-78h] BYREF
  CVector vStartPos; // [sp+80h] [bp-68h] BYREF
  float out_ds[4]; // [sp+8Ch] [bp-5Ch] BYREF
  CVector out_normals[6]; // [sp+9Ch] [bp-4Ch] BYREF

  m_RouteToDoor = this->m_RouteToDoor;
  if ( !m_RouteToDoor )
  {
    m_RouteToDoor = (CPointRoute *)CPointRoute::operator new(0x64u);
    m_RouteToDoor->m_iRouteSize = 0;
    this->m_RouteToDoor = m_RouteToDoor;
  }
  v5 = 0;
  p_m_transform = &ped->m_transform;
  m_RouteToDoor->m_iRouteSize = 0;
  m_pMat = ped->m_pMat;
  p_tx = &ped->m_transform;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  v9 = CPedGeometryAnalyser::ComputeEntityHitSide(&p_tx->m_translate, this->m_pTargetVehicle);
  v10 = CPedGeometryAnalyser::ComputeEntityHitSide(&this->m_vTarget, this->m_pTargetVehicle);
  v11 = ped->m_pMat;
  v12 = &ped->m_transform;
  if ( v11 )
    v12 = (CSimpleTransform *)&v11->tx;
  CPedGeometryAnalyser::ComputeEntityBoundingBoxPlanes(v12->m_translate.z, this->m_pTargetVehicle, out_normals, out_ds);
  v13 = &out_normals[v9];
  x = v13->x;
  y = v13->y;
  z = v13->z;
  v17 = ped->m_pMat;
  if ( v17 )
    p_m_transform = (CSimpleTransform *)&v17->tx;
  v18 = p_m_transform->m_translate.x;
  v19 = p_m_transform->m_translate.y;
  v20 = p_m_transform->m_translate.z;
  v21 = &out_normals[v10];
  v22 = out_ds[v9] + (float)((float)((float)(x * p_m_transform->m_translate.x) + (float)(y * v19)) + (float)(z * v20));
  vStartPos.y = v19 - (float)(y * v22);
  vStartPos.x = v18 - (float)(x * v22);
  vStartPos.z = v20 - (float)(z * v22);
  v23 = v21->x;
  v24 = this->m_vTarget.x;
  v25 = v21->y;
  v26 = this->m_vTarget.y;
  v27 = v21->x * v24;
  v28 = v21->z;
  v29 = this->m_vTarget.z;
  route.m_iRouteSize = 0;
  v30 = out_ds[v10] + (float)((float)(v27 + (float)(v25 * v26)) + (float)(v28 * v29));
  vTargetPos.y = v26 - (float)(v25 * v30);
  vTargetPos.x = v24 - (float)(v23 * v30);
  vTargetPos.z = v29 - (float)(v28 * v30);
  CPedGeometryAnalyser::ComputeRouteRoundEntityBoundingBox(
    ped,
    &vStartPos,
    this->m_pTargetVehicle,
    &vTargetPos,
    &route,
    0);
  v31 = this->m_RouteToDoor;
  m_iRouteSize = v31->m_iRouteSize;
  if ( v31->m_iRouteSize <= 7 )
  {
    v33 = *(_QWORD *)&vStartPos.x;
    v34 = (char *)v31 + 12 * m_iRouteSize;
    *((_DWORD *)v34 + 3) = LODWORD(vStartPos.z);
    *(_QWORD *)(v34 + 4) = v33;
    ++v31->m_iRouteSize;
    v31 = this->m_RouteToDoor;
    m_iRouteSize = v31->m_iRouteSize;
  }
  v35 = route.m_iRouteSize;
  if ( m_iRouteSize < 8 )
    v5 = 1;
  if ( route.m_iRouteSize >= 1 )
  {
    m_routePoints = route.m_routePoints;
    v37 = 0;
    do
    {
      if ( v5 << 31 )
      {
        v38 = *(_QWORD *)&m_routePoints->x;
        v39 = (char *)v31 + 12 * m_iRouteSize;
        *((_DWORD *)v39 + 3) = LODWORD(m_routePoints->z);
        *(_QWORD *)(v39 + 4) = v38;
        ++v31->m_iRouteSize;
        v31 = this->m_RouteToDoor;
        v35 = route.m_iRouteSize;
      }
      m_iRouteSize = v31->m_iRouteSize;
      v5 = 0;
      ++m_routePoints;
      ++v37;
      if ( v31->m_iRouteSize < 8 )
        v5 = 1;
    }
    while ( v37 < v35 );
  }
  if ( v5 == 1 )
  {
    v40 = *(_QWORD *)&vTargetPos.x;
    v41 = (char *)v31 + 12 * m_iRouteSize;
    *((_DWORD *)v41 + 3) = LODWORD(vTargetPos.z);
    *(_QWORD *)(v41 + 4) = v40;
    ++v31->m_iRouteSize;
  }
}
// 50014C: using guessed type CVector out_normals[6];
// 50014C: using guessed type float out_ds[4];

//----- (00500330) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToCarDoorAndStandStill::ControlSubTask(
        CTaskComplexGoToCarDoorAndStandStill *this,
        CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r0
  int32 m_nPedType; // r1
  bool v6; // zf
  int v7; // r1
  CTask *result; // r0
  CVehicle *v9; // r1
  CMatrix *m_pMat; // r0
  CMatrix *v11; // r2
  CSimpleTransform *p_tx; // r3
  CSimpleTransform *p_m_transform; // r0
  float32x2_t v14; // d16
  unsigned __int64 v15; // d1
  CVector *p_m_vTarget; // r6
  float32x2_t v17; // d16
  unsigned __int64 v18; // d1
  __int64 v19; // d16
  int m_iTargetDoor; // r2
  __int64 v21; // d16
  CVehicle *v22; // r1
  CMatrix *v23; // r0
  CMatrix *v24; // r2
  CSimpleTransform *v25; // r3
  CSimpleTransform *v26; // r0
  float32x2_t v27; // d16
  unsigned __int64 v28; // d1
  __int64 v29; // d16
  float m_fTargetRadius; // s0
  char m_pParent; // r2
  __int64 v32; // d16
  __int64 v33; // d16
  CTaskSimpleStandStill *v34; // r0
  __int64 v35; // d16
  CTaskSimpleStandStill *v36; // r0
  __int64 v37; // d16
  int v38; // r1
  int v39; // r2
  int v40; // r3
  CTaskSimpleGoToPoint *v41; // r0
  CVector *v42; // r6
  __int64 v43; // d16
  float v44; // s0
  float x; // s2
  __int64 v46; // d16
  char v47; // r1
  __int64 v48; // d16
  int v49; // r1
  __int64 v50; // d16
  CVector v51; // [sp+10h] [bp-30h] BYREF
  CVector door_pos; // [sp+20h] [bp-20h] BYREF

  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( !m_pTargetVehicle )
    return 0;
  m_nPedType = pPed->m_nPedType;
  v6 = m_nPedType == 6;
  if ( m_nPedType != 6 )
  {
    m_pTargetVehicle = (CVehicle *)m_pTargetVehicle->pDriver;
    v6 = m_pTargetVehicle == 0;
  }
  if ( !v6
    && CPed::IsPlayer((const CPed *)m_pTargetVehicle)
    && this->m_pTargetVehicle->pDriver->m_nPedState == PED_ARRESTED )
  {
    goto LABEL_38;
  }
  v7 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  result = 0;
  if ( v7 >= 828 )
  {
    if ( v7 == 828 )
    {
LABEL_23:
      m_iTargetDoor = this->m_iTargetDoor;
      if ( m_iTargetDoor )
      {
        CCarEnterExit::GetPositionToOpenCarDoor(&door_pos, this->m_pTargetVehicle, m_iTargetDoor);
        v21 = *(_QWORD *)&door_pos.x;
        this->m_vTarget.z = door_pos.z;
        *(_QWORD *)&this->m_vTarget.x = v21;
      }
      return this->m_pSubTask;
    }
    if ( v7 != 900 )
    {
      if ( v7 != 905 )
        return result;
      CCarEnterExit::GetPositionToOpenCarDoor(&v51, this->m_pTargetVehicle, this->m_iTargetDoor);
      door_pos = v51;
      v9 = this->m_pTargetVehicle;
      m_pMat = pPed->m_pMat;
      v11 = v9->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      p_m_transform = (CSimpleTransform *)&v11->tx;
      if ( !v11 )
        p_m_transform = &v9->m_transform;
      v14.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
      v15 = vmul_f32(v14, v14).n64_u64[0];
      if ( (float)((float)((float)((float)(p_m_transform->m_translate.x - p_tx->m_translate.x)
                                 * (float)(p_m_transform->m_translate.x - p_tx->m_translate.x))
                         + *(float *)&v15)
                 + *((float *)&v15 + 1)) < (float)(this->m_fMaxSeekDistance * this->m_fMaxSeekDistance) )
      {
        p_m_vTarget = &this->m_vTarget;
        if ( !CCarEnterExit::IsPathToDoorBlockedByVehicleCollisionModel(pPed, v9, &door_pos) )
        {
          v37 = *(_QWORD *)&door_pos.x;
          this->m_vTarget.z = door_pos.z;
          *(_QWORD *)&p_m_vTarget->x = v37;
          v38 = *((_DWORD *)&pPed->m_nPedFlags + 1);
          v39 = *((_DWORD *)&pPed->m_nPedFlags + 2) | 8;
          v40 = *((_DWORD *)&pPed->m_nPedFlags + 3);
          *(_DWORD *)&pPed->m_nPedFlags = pPed->m_nPedFlags;
          *((_DWORD *)&pPed->m_nPedFlags + 1) = v38;
          *((_DWORD *)&pPed->m_nPedFlags + 2) = v39;
          *((_DWORD *)&pPed->m_nPedFlags + 3) = v40;
          v41 = (CTaskSimpleGoToPoint *)CTask::operator new(0x2Cu);
          CTaskSimpleGoToPoint::CTaskSimpleGoToPoint(v41, this->m_iMoveState, p_m_vTarget, this->m_fTargetRadius, 1, 0);
          return result;
        }
        v17.n64_u64[0] = vsub_f32(*(float32x2_t *)&this->m_vTarget.y, *(float32x2_t *)&door_pos.y).n64_u64[0];
        v18 = vmul_f32(v17, v17).n64_u64[0];
        if ( (float)((float)((float)((float)(this->m_vTarget.x - door_pos.x) * (float)(this->m_vTarget.x - door_pos.x))
                           + *(float *)&v18)
                   + *((float *)&v18 + 1)) > 0.01 )
        {
          v19 = *(_QWORD *)&door_pos.x;
          this->m_vTarget.z = door_pos.z;
          *(_QWORD *)&p_m_vTarget->x = v19;
          return (CTask *)(*((int (__fastcall **)(CTaskComplexGoToCarDoorAndStandStill *, CPed *))this->_vptr$CTask + 11))(
                            this,
                            pPed);
        }
        return this->m_pSubTask;
      }
      v33 = *(_QWORD *)&door_pos.x;
      this->m_vTarget.z = door_pos.z;
      *(_QWORD *)&this->m_vTarget.x = v33;
LABEL_38:
      v34 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(v34, 1, 0, 0, 8.0);
      return result;
    }
    CCarEnterExit::GetPositionToOpenCarDoor(&v51, this->m_pTargetVehicle, this->m_iTargetDoor);
    door_pos = v51;
    v22 = this->m_pTargetVehicle;
    v23 = pPed->m_pMat;
    v24 = v22->m_pMat;
    v25 = (CSimpleTransform *)&v23->tx;
    if ( !v23 )
      v25 = &pPed->m_transform;
    v26 = (CSimpleTransform *)&v24->tx;
    if ( !v24 )
      v26 = &v22->m_transform;
    v27.n64_u64[0] = vsub_f32(*(float32x2_t *)&v26->m_translate.y, *(float32x2_t *)&v25->m_translate.y).n64_u64[0];
    v28 = vmul_f32(v27, v27).n64_u64[0];
    if ( (float)((float)((float)((float)(v26->m_translate.x - v25->m_translate.x)
                               * (float)(v26->m_translate.x - v25->m_translate.x))
                       + *(float *)&v28)
               + *((float *)&v28 + 1)) >= (float)(this->m_fMaxSeekDistance * this->m_fMaxSeekDistance) )
    {
      v35 = *(_QWORD *)&door_pos.x;
      this->m_vTarget.z = door_pos.z;
      *(_QWORD *)&this->m_vTarget.x = v35;
    }
    else
    {
      if ( this->m_iTargetSeat )
      {
        CCarEnterExit::GetPositionToOpenCarDoor(&v51, v22, this->m_iTargetDoor);
        door_pos = v51;
        v29 = *(_QWORD *)&v51.x;
        result = this->m_pSubTask;
        m_fTargetRadius = this->m_fTargetRadius;
        this->m_vTarget.z = v51.z;
        *(_QWORD *)&this->m_vTarget.x = v29;
        if ( *(float *)&result[1].m_pParent != this->m_vTarget.x
          || *(float *)&result[2]._vptr$CTask != this->m_vTarget.y
          || *(float *)&result[2].m_pParent != this->m_vTarget.z
          || *(float *)&result[3]._vptr$CTask != m_fTargetRadius )
        {
          m_pParent = (char)result[3].m_pParent;
          v32 = *(_QWORD *)&this->m_vTarget.x;
          result[2].m_pParent = (CTask *)LODWORD(this->m_vTarget.z);
          *(float *)&result[3]._vptr$CTask = m_fTargetRadius;
          *(_QWORD *)&result[1].m_pParent = v32;
          LOBYTE(result[3].m_pParent) = m_pParent & 0xD0 | 0x20;
          result = this->m_pSubTask;
        }
        goto LABEL_41;
      }
      v42 = &this->m_vTarget;
      v51.x = 0.0;
      if ( this->m_bIsDriver )
      {
        if ( CCarEnterExit::GetNearestCarDoor(pPed, v22, &door_pos, (int *)&v51) )
        {
LABEL_46:
          v43 = *(_QWORD *)&door_pos.x;
          result = this->m_pSubTask;
          this->m_vTarget.z = door_pos.z;
          *(_QWORD *)&v42->x = v43;
          v44 = this->m_fTargetRadius;
          x = this->m_vTarget.x;
          this->m_iTargetDoor = LODWORD(v51.x);
          if ( *(float *)&result[1].m_pParent != x
            || *(float *)&result[2]._vptr$CTask != this->m_vTarget.y
            || *(float *)&result[2].m_pParent != this->m_vTarget.z
            || *(float *)&result[3]._vptr$CTask != v44 )
          {
            v46 = *(_QWORD *)&v42->x;
            result[2].m_pParent = (CTask *)LODWORD(this->m_vTarget.z);
            *(_QWORD *)&result[1].m_pParent = v46;
            v47 = (char)result[3].m_pParent;
            *(float *)&result[3]._vptr$CTask = v44;
            LOBYTE(result[3].m_pParent) = v47 & 0xD0 | 0x20;
          }
          goto LABEL_41;
        }
      }
      else if ( CCarEnterExit::GetNearestCarPassengerDoor(pPed, v22, &door_pos, (int *)&v51, 1, 1, 1) == 1 )
      {
        goto LABEL_46;
      }
      if ( !this->m_bIsDriver )
      {
        if ( CCarEnterExit::GetNearestCarPassengerDoor(pPed, this->m_pTargetVehicle, &door_pos, (int *)&v51, 1, 0, 1) == 1 )
        {
          v49 = 828;
          this->m_iTargetDoor = LODWORD(v51.x);
          v50 = *(_QWORD *)&door_pos.x;
        }
        else
        {
          v50 = *(_QWORD *)&door_pos.x;
          v49 = 203;
        }
        this->m_vTarget.z = door_pos.z;
        *(_QWORD *)&v42->x = v50;
        result = CTaskComplexGoToCarDoorAndStandStill::CreateSubTask(this, v49, pPed);
        goto LABEL_41;
      }
      v48 = *(_QWORD *)&door_pos.x;
      this->m_vTarget.z = door_pos.z;
      *(_QWORD *)&v42->x = v48;
    }
    v36 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill(v36, 1, 0, 0, 8.0);
LABEL_41:
    *((_DWORD *)&pPed->m_nPedFlags + 2) |= 0x80000000;
    return result;
  }
  if ( (unsigned int)(v7 - 202) < 2 || v7 == 810 )
    goto LABEL_23;
  return result;
}

//----- (00500734) --------------------------------------------------------
void __fastcall CTaskSimpleCarAlign::CTaskSimpleCarAlign(
        CTaskSimpleCarAlign *this,
        CVehicle *pTargetVehicle,
        const CVector *vTargetDoorPos,
        const int iTargetDoor,
        CTaskUtilityLineUpPedWithCar *pUtility)
{
  __int64 v9; // d16

  CTaskSimple::CTaskSimple(this);
  this->m_bIsFinished = 0;
  this->m_pAnim = 0;
  this->_vptr$CTask = (int (**)(void))&off_66AFF8;
  this->m_pTargetVehicle = pTargetVehicle;
  v9 = *(_QWORD *)&vTargetDoorPos->x;
  this->m_vTargetDoorPos.z = vTargetDoorPos->z;
  this->m_iTargetDoor = iTargetDoor;
  this->m_pUtility = pUtility;
  *(_QWORD *)&this->m_vTargetDoorPos.x = v9;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66AFF8: using guessed type void *;

//----- (00500788) --------------------------------------------------------
void __fastcall CTaskSimpleCarAlign::~CTaskSimpleCarAlign(CTaskSimpleCarAlign *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CAnimBlendAssociation *m_pAnim; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AFF8;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  sub_1A01F4(this);
}
// 66AFF8: using guessed type void *off_66AFF8;

//----- (005007C8) --------------------------------------------------------
void __fastcall CTaskSimpleCarAlign::~CTaskSimpleCarAlign(CTaskSimpleCarAlign *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CAnimBlendAssociation *m_pAnim; // r0
  void *v5; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66AFF8;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v5);
}
// 500800: variable 'v5' is possibly undefined
// 66AFF8: using guessed type void *off_66AFF8;

//----- (0050080C) --------------------------------------------------------
bool __fastcall CTaskSimpleCarAlign::MakeAbortable(
        CTaskSimpleCarAlign *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0

  if ( iPriority != 2 )
    return 0;
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    m_pAnim->m_fBlendDelta = -1000.0;
  return 1;
}

//----- (00500828) --------------------------------------------------------
bool __fastcall CTaskSimpleCarAlign::ProcessPed(CTaskSimpleCarAlign *this, CPed *pPed)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d3
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r6
  bool v9; // zf
  int v10; // r2
  int v11; // r6
  int Group; // r0
  CAnimBlendAssociation *v13; // r0
  CVector v14; // [sp+4h] [bp-1Ch] BYREF

  if ( this->m_bIsFinished || !this->m_pTargetVehicle )
    return 1;
  if ( !this->m_pAnim )
  {
    CTaskSimpleCarAlign::FixHeading(this, pPed);
    CCarEnterExit::GetPositionToOpenCarDoor(&v14, this->m_pTargetVehicle, this->m_iTargetDoor);
    m_pMat = pPed->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    v9 = m_pMat == 0;
    v10 = 351;
    if ( v9 )
      p_tx = &pPed->m_transform;
    v3.n64_u32[0] = 0;
    v2.n64_f32[0] = v14.z - p_tx->m_translate.z;
    v11 = 352;
    if ( vmax_f32(v2, v3).n64_f32[0] > 4.4 )
    {
      v10 = 353;
      v11 = 354;
    }
    if ( (this->m_iTargetDoor & 0xFFFFFFFE) == 10 )
      v11 = v10;
    Group = CVehicleAnimGroup::GetGroup(
              &CVehicleAnimGroupData::m_vehicleAnimGroups[this->m_pTargetVehicle->pHandling->AnimGroup],
              v11);
    v13 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, (AssocGroupId)Group, (AnimationId)v11, 4.0);
    this->m_pAnim = v13;
    CAnimBlendAssociation::SetFinishCallback(v13, CTaskSimpleCarAlign::FinishAnimCarAlignCB, this);
  }
  return 0;
}
// 500898: variable 'v2' is possibly undefined
// 500898: variable 'v3' is possibly undefined

//----- (005008FC) --------------------------------------------------------
void __fastcall CTaskSimpleCarAlign::FixHeading(CTaskSimpleCarAlign *this, CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r1
  float *p_xx; // r1
  float v5; // s16
  float v6; // s18
  float v7; // s20
  CMatrix *m_pMat; // r6
  float xy; // s2
  float yy; // s4
  float zy; // s0
  float m_heading; // r5
  float v13; // r8
  float v14; // s0
  float v15; // s4
  float v16; // s2
  float v17; // s0
  float v18; // r5
  float v19; // r8
  float v20; // s0
  float v21; // s18
  float v22; // s16
  float v23; // s2
  float v24; // s0
  float v25; // r5
  float v26; // r6
  float RadianAngleBetweenPoints; // r0
  float v28; // r0

  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( m_pTargetVehicle && !m_pTargetVehicle->m_baseVehicleType )
  {
    p_xx = &m_pTargetVehicle->m_pMat->xx;
    v5 = *p_xx;
    v6 = p_xx[1];
    v7 = p_xx[2];
    if ( (this->m_iTargetDoor & 0xFFFFFFFE) == 10 )
    {
      v7 = -v7;
      v6 = -v6;
      v5 = -v5;
    }
    m_pMat = pPed->m_pMat;
    if ( m_pMat )
    {
      xy = m_pMat->xy;
      yy = m_pMat->yy;
      zy = m_pMat->zy;
    }
    else
    {
      m_heading = pPed->m_transform.m_heading;
      v13 = sinf(m_heading);
      yy = cosf(m_heading);
      zy = 0.0;
      LODWORD(xy) = LODWORD(v13) ^ 0x80000000;
    }
    v14 = (float)((float)(v5 * xy) + (float)(v6 * yy)) + (float)(v7 * zy);
    if ( v14 > 0.0 && v14 < 0.1 )
    {
      if ( m_pMat )
      {
        v15 = m_pMat->xy;
        v16 = m_pMat->yy;
        v17 = m_pMat->zy;
      }
      else
      {
        v18 = pPed->m_transform.m_heading;
        v19 = sinf(v18);
        v16 = cosf(v18);
        v17 = 0.0;
        LODWORD(v15) = LODWORD(v19) ^ 0x80000000;
      }
      v20 = (float)(v7 * v17) + (float)((float)(v6 * v16) + (float)(v5 * v15));
      v21 = v6 * v20;
      v22 = v5 * v20;
      if ( m_pMat )
      {
        v23 = m_pMat->xy;
        v24 = m_pMat->yy;
      }
      else
      {
        v25 = pPed->m_transform.m_heading;
        v26 = sinf(v25);
        v24 = cosf(v25);
        LODWORD(v23) = LODWORD(v26) ^ 0x80000000;
      }
      RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                                   (float)(v23 - v22) - v22,
                                   (float)(v24 - v21) - v21,
                                   0.0,
                                   0.0);
      v28 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
      pPed->m_fCurrentHeading = v28;
      pPed->m_fDesiredHeading = v28;
    }
  }
}

//----- (00500A54) --------------------------------------------------------
void __fastcall CTaskSimpleCarAlign::StartAnim(CTaskSimpleCarAlign *this, const CPed *pPed)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d3
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r6
  bool v8; // zf
  int v9; // r2
  int v10; // r6
  int Group; // r0
  CAnimBlendAssociation *v12; // r0
  CVector v13; // [sp+4h] [bp-1Ch] BYREF

  CCarEnterExit::GetPositionToOpenCarDoor(&v13, this->m_pTargetVehicle, this->m_iTargetDoor);
  m_pMat = pPed->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  v8 = m_pMat == 0;
  v9 = 351;
  if ( v8 )
    p_tx = &pPed->m_transform;
  v3.n64_u32[0] = 0;
  v2.n64_f32[0] = v13.z - p_tx->m_translate.z;
  v10 = 352;
  if ( vmax_f32(v2, v3).n64_f32[0] > 4.4 )
  {
    v9 = 353;
    v10 = 354;
  }
  if ( (this->m_iTargetDoor & 0xFFFFFFFE) == 10 )
    v10 = v9;
  Group = CVehicleAnimGroup::GetGroup(
            &CVehicleAnimGroupData::m_vehicleAnimGroups[this->m_pTargetVehicle->pHandling->AnimGroup],
            v10);
  v12 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, (AssocGroupId)Group, (AnimationId)v10, 4.0);
  this->m_pAnim = v12;
  CAnimBlendAssociation::SetFinishCallback(v12, CTaskSimpleCarAlign::FinishAnimCarAlignCB, this);
}
// 500AA8: variable 'v2' is possibly undefined
// 500AA8: variable 'v3' is possibly undefined

//----- (00500B08) --------------------------------------------------------
bool __fastcall CTaskSimpleCarAlign::SetPedPosition(CTaskSimpleCarAlign *this, CPed *pPed)
{
  CVector v5; // [sp+4h] [bp-14h] BYREF

  CCarEnterExit::GetPositionToOpenCarDoor(&v5, this->m_pTargetVehicle, this->m_iTargetDoor);
  CTaskUtilityLineUpPedWithCar::ProcessPed(this->m_pUtility, pPed, this->m_pTargetVehicle, this->m_pAnim);
  return 1;
}

//----- (00500B2E) --------------------------------------------------------
void __fastcall CTaskSimpleCarAlign::FinishAnimCarAlignCB(CAnimBlendAssociation *pAnim, void *pData)
{
  *((_BYTE *)pData + 8) = 1;
  *((_DWORD *)pData + 3) = 0;
}

//----- (00500B38) --------------------------------------------------------
void __fastcall CTaskSimpleCarOpenDoorFromOutside::CTaskSimpleCarOpenDoorFromOutside(
        CTaskSimpleCarOpenDoorFromOutside *this,
        CVehicle *pTargetVehicle,
        const int iTargetDoor,
        CTaskUtilityLineUpPedWithCar *pUtility,
        const bool bQuitAfterOpeningDoor)
{
  CTaskSimple::CTaskSimple(this);
  this->m_bIsFinished = 0;
  this->m_pAnim = 0;
  this->m_iTargetDoor = iTargetDoor;
  this->m_bQuitAfterOpeningDoor = bQuitAfterOpeningDoor;
  this->m_bHasSetCanPlayerExitCarFlag = 0;
  this->m_pUtility = pUtility;
  this->m_fDoorStartRatio = 0.0;
  this->_vptr$CTask = (int (**)(void))&off_66B02C;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66B02C: using guessed type void *;

//----- (00500B88) --------------------------------------------------------
void __fastcall CTaskSimpleCarOpenDoorFromOutside::~CTaskSimpleCarOpenDoorFromOutside(
        CTaskSimpleCarOpenDoorFromOutside *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CAnimBlendAssociation *m_pAnim; // r0
  CPlayerPed *PlayerPed; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B02C;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  if ( this->m_bHasSetCanPlayerExitCarFlag )
  {
    this->m_bHasSetCanPlayerExitCarFlag = 0;
    PlayerPed = FindPlayerPed(-1);
    *((_DWORD *)&PlayerPed->m_nPedFlags + 2) |= 0x4000000u;
  }
  sub_1A01F4(this);
}
// 66B02C: using guessed type void *off_66B02C;

//----- (00500BE4) --------------------------------------------------------
void __fastcall CTaskSimpleCarOpenDoorFromOutside::~CTaskSimpleCarOpenDoorFromOutside(
        CTaskSimpleCarOpenDoorFromOutside *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CAnimBlendAssociation *m_pAnim; // r0
  CPlayerPed *PlayerPed; // r0
  void *v6; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B02C;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  if ( this->m_bHasSetCanPlayerExitCarFlag )
  {
    this->m_bHasSetCanPlayerExitCarFlag = 0;
    PlayerPed = FindPlayerPed(-1);
    *((_DWORD *)&PlayerPed->m_nPedFlags + 2) |= 0x4000000u;
  }
  CTask::~CTask(this);
  sub_197118(v6);
}
// 500C38: variable 'v6' is possibly undefined
// 66B02C: using guessed type void *off_66B02C;

//----- (00500C44) --------------------------------------------------------
bool __fastcall CTaskSimpleCarOpenDoorFromOutside::MakeAbortable(
        CTaskSimpleCarOpenDoorFromOutside *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0
  CVehicle *m_pTargetVehicle; // r0
  unsigned int v8; // r1
  int v9; // r6
  int Group; // r0
  CPlayerPed *PlayerPed; // r0

  if ( iPriority != 2 )
    return 0;
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    m_pAnim->m_fBlendDelta = -1000.0;
  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( m_pTargetVehicle )
  {
    v8 = this->m_iTargetDoor - 8;
    if ( v8 > 2 )
      v9 = 357;
    else
      v9 = (int)*(&off_61E408 + v8);
    Group = CVehicleAnimGroup::GetGroup(
              &CVehicleAnimGroupData::m_vehicleAnimGroups[m_pTargetVehicle->pHandling->AnimGroup],
              v9);
    (*((void (__fastcall **)(CVehicle *, CPed *, int, int, int, int))this->m_pTargetVehicle->_vptr$CPlaceable + 29))(
      this->m_pTargetVehicle,
      pPed,
      this->m_iTargetDoor,
      Group,
      v9,
      1065353216);
  }
  if ( this->m_bHasSetCanPlayerExitCarFlag )
  {
    this->m_bHasSetCanPlayerExitCarFlag = 0;
    PlayerPed = FindPlayerPed(-1);
    *((_DWORD *)&PlayerPed->m_nPedFlags + 2) |= 0x4000000u;
  }
  return 1;
}
// 61E408: using guessed type void *off_61E408;

//----- (00500CE0) --------------------------------------------------------
void __fastcall CTaskSimpleCarOpenDoorFromOutside::ComputeAnimID(
        const CTaskSimpleCarOpenDoorFromOutside *this,
        int *animGroup,
        int *animID)
{
  unsigned int v4; // r1
  int v5; // r1

  v4 = this->m_iTargetDoor - 8;
  if ( v4 >= 4 )
  {
    v5 = *animID;
  }
  else
  {
    v5 = (int)*(&off_500D18 + v4);
    *animID = v5;
  }
  *animGroup = CVehicleAnimGroup::GetGroup(
                 &CVehicleAnimGroupData::m_vehicleAnimGroups[this->m_pTargetVehicle->pHandling->AnimGroup],
                 v5);
}
// 500D18: using guessed type void *off_500D18;

//----- (00500D2C) --------------------------------------------------------
bool __fastcall CTaskSimpleCarOpenDoorFromOutside::ProcessPed(CTaskSimpleCarOpenDoorFromOutside *this, CPed *pPed)
{
  bool v4; // r5
  CVehicle *m_pTargetVehicle; // r0
  __int16 AnimGroup; // r1
  float v8; // r0
  int m_iTargetDoor; // r1
  int v10; // r6
  unsigned int v11; // r0
  int v12; // r6
  int Group; // r0
  int v14; // r0
  CAnimBlendAssociation *v15; // r0
  CVehicle *v16; // r0
  bool v17; // zf
  CPed *pDriver; // r0
  int v19; // r2
  unsigned int v20; // r3
  int v21; // r6
  __int64 v22; // kr00_8
  float v23; // s0
  float v24; // s2
  int v25; // r0
  float v26; // s0
  int v27; // r2
  int v28; // r3
  float m_fDoorStartRatio; // s2

  if ( this->m_bIsFinished )
    return 1;
  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( !m_pTargetVehicle )
    return 1;
  AnimGroup = m_pTargetVehicle->pHandling->AnimGroup;
  if ( (CVehicleAnimGroupData::m_vehicleAnimGroups[m_pTargetVehicle->pHandling->AnimGroup].m_specialFlags & 0x40) != 0 )
  {
    v11 = this->m_iTargetDoor - 8;
    if ( v11 > 2 )
      v12 = 357;
    else
      v12 = (int)*(&off_61E408 + v11);
    Group = CVehicleAnimGroup::GetGroup(&CVehicleAnimGroupData::m_vehicleAnimGroups[AnimGroup], v12);
    (*((void (__fastcall **)(CVehicle *, CPed *, int, int, int, int))this->m_pTargetVehicle->_vptr$CPlaceable + 29))(
      this->m_pTargetVehicle,
      pPed,
      this->m_iTargetDoor,
      Group,
      v12,
      1065353216);
    return 1;
  }
  if ( !this->m_pAnim )
  {
    v8 = COERCE_FLOAT(
           (*((int (__fastcall **)(CVehicle *, int))m_pTargetVehicle->_vptr$CPlaceable + 35))(
             m_pTargetVehicle,
             this->m_iTargetDoor));
    m_iTargetDoor = this->m_iTargetDoor;
    this->m_fDoorStartRatio = v8;
    if ( (unsigned int)(m_iTargetDoor - 8) > 2 )
      v10 = 357;
    else
      v10 = (int)*(&off_61E408 + m_iTargetDoor - 8);
    v14 = CVehicleAnimGroup::GetGroup(
            &CVehicleAnimGroupData::m_vehicleAnimGroups[this->m_pTargetVehicle->pHandling->AnimGroup],
            v10);
    v15 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, (AssocGroupId)v14, (AnimationId)v10, 4.0);
    this->m_pAnim = v15;
    CAnimBlendAssociation::SetFinishCallback(
      v15,
      CTaskSimpleCarOpenDoorFromOutside::FinishAnimCarOpenDoorFromOutsideCB,
      this);
    v16 = this->m_pTargetVehicle;
    v17 = v16 == 0;
    if ( v16 )
    {
      v16 = (CVehicle *)v16->pDriver;
      v17 = v16 == 0;
    }
    if ( !v17 && CPed::IsPlayer((const CPed *)v16) && this->m_bQuitAfterOpeningDoor && pPed->m_nPedType == 6 )
    {
      pDriver = this->m_pTargetVehicle->pDriver;
      v19 = *((_DWORD *)&pDriver->m_nPedFlags + 1);
      v20 = *((_DWORD *)&pDriver->m_nPedFlags + 2) & 0xFBFFFFFF;
      v21 = *((_DWORD *)&pDriver->m_nPedFlags + 3);
      *(_DWORD *)&pDriver->m_nPedFlags = pDriver->m_nPedFlags;
      *((_DWORD *)&pDriver->m_nPedFlags + 1) = v19;
      *((_DWORD *)&pDriver->m_nPedFlags + 2) = v20;
      *((_DWORD *)&pDriver->m_nPedFlags + 3) = v21;
      this->m_bHasSetCanPlayerExitCarFlag = 1;
    }
  }
  v22 = *(_QWORD *)&this->m_pAnim;
  v23 = *(float *)(v22 + 32);
  v24 = CVehicleAnimGroupData::m_vehicleAnimGroups[*(unsigned __int8 *)(*(_DWORD *)(HIDWORD(v22) + 904) + 222)].m_processDoorStartTimes[0];
  if ( v23 >= v24 || *(_DWORD *)(HIDWORD(v22) + 1440) )
  {
    v25 = CVehicleAnimGroup::GetGroup(
            &CVehicleAnimGroupData::m_vehicleAnimGroups[*(unsigned __int8 *)(*(_DWORD *)(HIDWORD(v22) + 904) + 222)],
            *(__int16 *)(v22 + 44));
    (*((void (__fastcall **)(CVehicle *, CPed *, int, int, _DWORD, _DWORD))this->m_pTargetVehicle->_vptr$CPlaceable + 29))(
      this->m_pTargetVehicle,
      pPed,
      this->m_iTargetDoor,
      v25,
      this->m_pAnim->m_animId,
      LODWORD(this->m_pAnim->m_fCurrentTime));
    return 0;
  }
  else
  {
    v26 = v23 / v24;
    v27 = this->m_iTargetDoor;
    if ( (unsigned int)(v27 - 8) > 3 )
      v28 = 2;
    else
      v28 = dword_500F18[v27 - 8];
    m_fDoorStartRatio = this->m_fDoorStartRatio;
    v4 = 0;
    (*(void (__fastcall **)(_DWORD, CPed *, int, int, _DWORD, _DWORD))(*(_DWORD *)HIDWORD(v22) + 112))(
      HIDWORD(v22),
      pPed,
      v27,
      v28,
      (float)(1.0 - v26) * m_fDoorStartRatio,
      0);
  }
  return v4;
}
// 500F18: using guessed type int dword_500F18[4];
// 61E408: using guessed type void *off_61E408;

//----- (00500F28) --------------------------------------------------------
void __fastcall CTaskSimpleCarOpenDoorFromOutside::StartAnim(CTaskSimpleCarOpenDoorFromOutside *this, const CPed *pPed)
{
  unsigned int v4; // r0
  int v5; // r6
  int Group; // r0
  CAnimBlendAssociation *v7; // r0

  v4 = this->m_iTargetDoor - 8;
  if ( v4 > 2 )
    v5 = 357;
  else
    v5 = (int)*(&off_61E408 + v4);
  Group = CVehicleAnimGroup::GetGroup(
            &CVehicleAnimGroupData::m_vehicleAnimGroups[this->m_pTargetVehicle->pHandling->AnimGroup],
            v5);
  v7 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, (AssocGroupId)Group, (AnimationId)v5, 4.0);
  this->m_pAnim = v7;
  sub_18C19C(v7, CTaskSimpleCarOpenDoorFromOutside::FinishAnimCarOpenDoorFromOutsideCB, this);
}
// 61E408: using guessed type void *off_61E408;

//----- (00500F98) --------------------------------------------------------
bool __fastcall CTaskSimpleCarOpenDoorFromOutside::SetPedPosition(CTaskSimpleCarOpenDoorFromOutside *this, CPed *pPed)
{
  CTaskUtilityLineUpPedWithCar::ProcessPed(this->m_pUtility, pPed, this->m_pTargetVehicle, this->m_pAnim);
  return 1;
}

//----- (00500FAC) --------------------------------------------------------
void __fastcall CTaskSimpleCarOpenDoorFromOutside::FinishAnimCarOpenDoorFromOutsideCB(
        CAnimBlendAssociation *pAnim,
        void *pData)
{
  int v3; // r0
  unsigned int v4; // r0
  int v5; // r5
  int Group; // r0

  *((_BYTE *)pData + 8) = 1;
  v3 = *((_DWORD *)pData + 5);
  *((_DWORD *)pData + 3) = 0;
  v4 = v3 - 8;
  if ( v4 > 2 )
    v5 = 357;
  else
    v5 = (int)*(&off_61E408 + v4);
  Group = CVehicleAnimGroup::GetGroup(
            &CVehicleAnimGroupData::m_vehicleAnimGroups[*(unsigned __int8 *)(*(_DWORD *)(*((_DWORD *)pData + 4) + 904)
                                                                           + 222)],
            v5);
  (*(void (__fastcall **)(_DWORD, _DWORD, _DWORD, int, int, int))(**((_DWORD **)pData + 4) + 116))(
    *((_DWORD *)pData + 4),
    0,
    *((_DWORD *)pData + 5),
    Group,
    v5,
    1065353216);
}
// 61E408: using guessed type void *off_61E408;

//----- (00501010) --------------------------------------------------------
void __fastcall CTaskSimpleCarOpenLockedDoorFromOutside::CTaskSimpleCarOpenLockedDoorFromOutside(
        CTaskSimpleCarOpenLockedDoorFromOutside *this,
        CVehicle *pTargetVehicle,
        const int iTargetDoor,
        CTaskUtilityLineUpPedWithCar *pUtility)
{
  CTaskSimple::CTaskSimple(this);
  this->m_bIsFinished = 0;
  this->m_pAnim = 0;
  this->m_iTargetDoor = iTargetDoor;
  this->m_pUtility = pUtility;
  this->_vptr$CTask = (int (**)(void))&off_66B060;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66B060: using guessed type void *;

//----- (00501058) --------------------------------------------------------
void __fastcall CTaskSimpleCarOpenLockedDoorFromOutside::~CTaskSimpleCarOpenLockedDoorFromOutside(
        CTaskSimpleCarOpenLockedDoorFromOutside *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CAnimBlendAssociation *m_pAnim; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B060;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  sub_1A01F4(this);
}
// 66B060: using guessed type void *off_66B060;

//----- (00501098) --------------------------------------------------------
void __fastcall CTaskSimpleCarOpenLockedDoorFromOutside::~CTaskSimpleCarOpenLockedDoorFromOutside(
        CTaskSimpleCarOpenLockedDoorFromOutside *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CAnimBlendAssociation *m_pAnim; // r0
  void *v5; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B060;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v5);
}
// 5010D0: variable 'v5' is possibly undefined
// 66B060: using guessed type void *off_66B060;

//----- (005010DC) --------------------------------------------------------
bool __fastcall CTaskSimpleCarOpenLockedDoorFromOutside::MakeAbortable(
        CTaskSimpleCarOpenLockedDoorFromOutside *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0

  if ( iPriority != 2 )
    return 0;
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    m_pAnim->m_fBlendDelta = -1000.0;
  return 1;
}

//----- (005010F8) --------------------------------------------------------
bool __fastcall CTaskSimpleCarOpenLockedDoorFromOutside::ProcessPed(
        CTaskSimpleCarOpenLockedDoorFromOutside *this,
        CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r0
  int v6; // r6
  CVehicleAnimGroup *v7; // r0
  int Group; // r0
  CAnimBlendAssociation *v9; // r0

  if ( this->m_bIsFinished )
    return 1;
  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( !m_pTargetVehicle )
    return 1;
  if ( !this->m_pAnim )
  {
    v6 = 390;
    v7 = &CVehicleAnimGroupData::m_vehicleAnimGroups[m_pTargetVehicle->pHandling->AnimGroup];
    if ( (this->m_iTargetDoor & 0xFFFFFFFE) == 10 )
      v6 = 389;
    Group = CVehicleAnimGroup::GetGroup(v7, v6);
    v9 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, (AssocGroupId)Group, (AnimationId)v6, 4.0);
    this->m_pAnim = v9;
    CAnimBlendAssociation::SetFinishCallback(
      v9,
      CTaskSimpleCarOpenLockedDoorFromOutside::FinishAnimCarOpenLockedDoorFromOutsideCB,
      this);
  }
  return 0;
}

//----- (00501174) --------------------------------------------------------
void __fastcall CTaskSimpleCarOpenLockedDoorFromOutside::StartAnim(
        CTaskSimpleCarOpenLockedDoorFromOutside *this,
        const CPed *pPed)
{
  __int64 v4; // r0
  int v5; // r6
  __int16 v6; // r0
  int Group; // r0
  CAnimBlendAssociation *v8; // r0

  v4 = *(_QWORD *)&this->m_pTargetVehicle;
  v5 = 390;
  v6 = *(unsigned __int8 *)(*(_DWORD *)(v4 + 904) + 222);
  if ( (HIDWORD(v4) & 0xFFFFFFFE) == 10 )
    v5 = 389;
  Group = CVehicleAnimGroup::GetGroup(&CVehicleAnimGroupData::m_vehicleAnimGroups[v6], v5);
  v8 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, (AssocGroupId)Group, (AnimationId)v5, 4.0);
  this->m_pAnim = v8;
  sub_18C19C(v8, CTaskSimpleCarOpenLockedDoorFromOutside::FinishAnimCarOpenLockedDoorFromOutsideCB, this);
}

//----- (005011DC) --------------------------------------------------------
bool __fastcall CTaskSimpleCarOpenLockedDoorFromOutside::SetPedPosition(
        CTaskSimpleCarOpenLockedDoorFromOutside *this,
        CPed *pPed)
{
  CTaskUtilityLineUpPedWithCar::ProcessPed(this->m_pUtility, pPed, this->m_pTargetVehicle, this->m_pAnim);
  return 1;
}

//----- (005011EE) --------------------------------------------------------
void __fastcall CTaskSimpleCarOpenLockedDoorFromOutside::FinishAnimCarOpenLockedDoorFromOutsideCB(
        CAnimBlendAssociation *pAnim,
        void *pData)
{
  *((_BYTE *)pData + 8) = 1;
  *((_DWORD *)pData + 3) = 0;
}

//----- (005011F8) --------------------------------------------------------
void __fastcall CTaskSimplePickUpBike::CTaskSimplePickUpBike(
        CTaskSimplePickUpBike *this,
        CVehicle *pTargetVehicle,
        const int iTargetDoor,
        CTaskUtilityLineUpPedWithCar *pUtility)
{
  CTaskSimple::CTaskSimple(this);
  this->m_bIsFinished = 0;
  this->m_pAnim = 0;
  this->m_iTargetDoor = iTargetDoor;
  this->m_pUtility = pUtility;
  this->_vptr$CTask = (int (**)(void))&off_66B094;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66B094: using guessed type void *;

//----- (00501240) --------------------------------------------------------
void __fastcall CTaskSimplePickUpBike::~CTaskSimplePickUpBike(CTaskSimplePickUpBike *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CAnimBlendAssociation *m_pAnim; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B094;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  sub_1A01F4(this);
}
// 66B094: using guessed type void *off_66B094;

//----- (00501280) --------------------------------------------------------
void __fastcall CTaskSimplePickUpBike::~CTaskSimplePickUpBike(CTaskSimplePickUpBike *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CAnimBlendAssociation *m_pAnim; // r0
  void *v5; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B094;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v5);
}
// 5012B8: variable 'v5' is possibly undefined
// 66B094: using guessed type void *off_66B094;

//----- (005012C4) --------------------------------------------------------
bool __fastcall CTaskSimplePickUpBike::MakeAbortable(
        CTaskSimplePickUpBike *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r1

  if ( iPriority != 2 )
    return 0;
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    m_pAnim->m_fBlendDelta = -1000.0;
  LOBYTE(this->m_pTargetVehicle[1].m_vecTurnFriction.z) &= ~8u;
  return 1;
}

//----- (005012EC) --------------------------------------------------------
bool __fastcall CTaskSimplePickUpBike::ProcessPed(CTaskSimplePickUpBike *this, CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r0
  int v6; // r6
  float zx; // s0
  int v8; // r1
  CVehicleAnimGroup *v9; // r0
  int Group; // r0
  CAnimBlendAssociation *v11; // r0
  CAnimBlendAssociation *m_pAnim; // r0
  int m_animId; // r1

  if ( this->m_bIsFinished )
    return 1;
  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( !m_pTargetVehicle )
    return 1;
  if ( !this->m_pAnim )
  {
    v6 = 354;
    zx = m_pTargetVehicle->m_pMat->zx;
    v8 = 353;
    v9 = &CVehicleAnimGroupData::m_vehicleAnimGroups[m_pTargetVehicle->pHandling->AnimGroup];
    if ( zx > 0.0 )
      v8 = 351;
    if ( zx < 0.0 )
      v6 = 352;
    if ( (this->m_iTargetDoor & 0xFFFFFFFE) == 10 )
      v6 = v8;
    Group = CVehicleAnimGroup::GetGroup(v9, v6);
    v11 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, (AssocGroupId)Group, (AnimationId)v6, 8.0);
    this->m_pAnim = v11;
    CAnimBlendAssociation::SetFinishCallback(v11, CTaskSimplePickUpBike::FinishAnimPickUpBikeCB, this);
    m_pTargetVehicle = this->m_pTargetVehicle;
  }
  if ( (LOBYTE(m_pTargetVehicle[1].m_vecTurnFriction.z) & 8) == 0 )
  {
    m_pAnim = this->m_pAnim;
    if ( m_pAnim )
    {
      if ( (m_animId = m_pAnim->m_animId, (unsigned int)(m_animId - 351) <= 1) && m_pAnim->m_fCurrentTime > 0.4667
        || (unsigned int)(m_animId - 353) <= 1 && m_pAnim->m_fCurrentTime > 0.4667 )
      {
        LOBYTE(this->m_pTargetVehicle[1].m_vecTurnFriction.z) |= 8u;
      }
    }
  }
  return 0;
}

//----- (005013E8) --------------------------------------------------------
void __fastcall CTaskSimplePickUpBike::StartAnim(CTaskSimplePickUpBike *this, const CPed *pPed)
{
  __int64 v4; // r0
  int v5; // r6
  unsigned int v6; // r1
  float v7; // s0
  int v8; // r2
  CVehicleAnimGroup *v9; // r0
  int Group; // r0
  CAnimBlendAssociation *v11; // r0

  v4 = *(_QWORD *)&this->m_pTargetVehicle;
  v5 = 354;
  v6 = HIDWORD(v4) & 0xFFFFFFFE;
  v7 = *(float *)(*(_DWORD *)(v4 + 20) + 8);
  v8 = 353;
  v9 = &CVehicleAnimGroupData::m_vehicleAnimGroups[*(unsigned __int8 *)(*(_DWORD *)(v4 + 904) + 222)];
  if ( v7 > 0.0 )
    v8 = 351;
  if ( v7 < 0.0 )
    v5 = 352;
  if ( v6 == 10 )
    v5 = v8;
  Group = CVehicleAnimGroup::GetGroup(v9, v5);
  v11 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, (AssocGroupId)Group, (AnimationId)v5, 8.0);
  this->m_pAnim = v11;
  sub_18C19C(v11, CTaskSimplePickUpBike::FinishAnimPickUpBikeCB, this);
}

//----- (00501478) --------------------------------------------------------
bool __fastcall CTaskSimplePickUpBike::SetPedPosition(CTaskSimplePickUpBike *this, CPed *pPed)
{
  CTaskUtilityLineUpPedWithCar::ProcessPed(this->m_pUtility, pPed, this->m_pTargetVehicle, this->m_pAnim);
  return 1;
}

//----- (0050148A) --------------------------------------------------------
void __fastcall CTaskSimplePickUpBike::FinishAnimPickUpBikeCB(CAnimBlendAssociation *pAnim, void *pData)
{
  *((_BYTE *)pData + 8) = 1;
  *((_DWORD *)pData + 3) = 0;
}

//----- (00501494) --------------------------------------------------------
void __fastcall CTaskSimpleCarCloseDoorFromInside::CTaskSimpleCarCloseDoorFromInside(
        CTaskSimpleCarCloseDoorFromInside *this,
        CVehicle *pTargetVehicle,
        const int iTargetDoor,
        CTaskUtilityLineUpPedWithCar *pUtility)
{
  CTaskSimple::CTaskSimple(this);
  this->m_bIsFinished = 0;
  this->m_pAnim = 0;
  this->m_iTargetDoor = iTargetDoor;
  this->m_pUtility = pUtility;
  this->_vptr$CTask = (int (**)(void))&off_66B0C8;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66B0C8: using guessed type void *;

//----- (005014DC) --------------------------------------------------------
void __fastcall CTaskSimpleCarCloseDoorFromInside::~CTaskSimpleCarCloseDoorFromInside(
        CTaskSimpleCarCloseDoorFromInside *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CAnimBlendAssociation *m_pAnim; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B0C8;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  sub_1A01F4(this);
}
// 66B0C8: using guessed type void *off_66B0C8;

//----- (0050151C) --------------------------------------------------------
void __fastcall CTaskSimpleCarCloseDoorFromInside::~CTaskSimpleCarCloseDoorFromInside(
        CTaskSimpleCarCloseDoorFromInside *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CAnimBlendAssociation *m_pAnim; // r0
  void *v5; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B0C8;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v5);
}
// 501554: variable 'v5' is possibly undefined
// 66B0C8: using guessed type void *off_66B0C8;

//----- (00501560) --------------------------------------------------------
bool __fastcall CTaskSimpleCarCloseDoorFromInside::MakeAbortable(
        CTaskSimpleCarCloseDoorFromInside *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0
  CVehicle *m_pTargetVehicle; // r0
  unsigned int v8; // r1
  int v9; // r6
  int Group; // r0

  if ( iPriority == 2 )
  {
    m_pAnim = this->m_pAnim;
    if ( m_pAnim )
      m_pAnim->m_fBlendDelta = -1000.0;
    m_pTargetVehicle = this->m_pTargetVehicle;
    if ( m_pTargetVehicle )
    {
      v8 = this->m_iTargetDoor - 8;
      if ( v8 > 2 )
        v9 = 369;
      else
        v9 = (int)*(&off_61E414 + v8);
      Group = CVehicleAnimGroup::GetGroup(
                &CVehicleAnimGroupData::m_vehicleAnimGroups[m_pTargetVehicle->pHandling->AnimGroup],
                v9);
      (*((void (__fastcall **)(CVehicle *, CPed *, int, int, int, int))this->m_pTargetVehicle->_vptr$CPlaceable + 29))(
        this->m_pTargetVehicle,
        pPed,
        this->m_iTargetDoor,
        Group,
        v9,
        1065353216);
    }
  }
  return 0;
}
// 61E414: using guessed type void *off_61E414;

//----- (005015DC) --------------------------------------------------------
void __fastcall CTaskSimpleCarCloseDoorFromInside::ComputeAnimID(
        const CTaskSimpleCarCloseDoorFromInside *this,
        int *animGroupId,
        int *animId)
{
  unsigned int v4; // r1
  int v5; // r1

  v4 = this->m_iTargetDoor - 8;
  if ( v4 >= 4 )
  {
    v5 = *animId;
  }
  else
  {
    v5 = (int)*(&off_501614 + v4);
    *animId = v5;
  }
  *animGroupId = CVehicleAnimGroup::GetGroup(
                   &CVehicleAnimGroupData::m_vehicleAnimGroups[this->m_pTargetVehicle->pHandling->AnimGroup],
                   v5);
}
// 501614: using guessed type void *off_501614;

//----- (00501628) --------------------------------------------------------
bool __fastcall CTaskSimpleCarCloseDoorFromInside::ProcessPed(CTaskSimpleCarCloseDoorFromInside *this, CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r0
  __int16 AnimGroup; // r0
  CAnimBlendAssociation *m_pAnim; // r1
  unsigned int v8; // r1
  int v9; // r6
  unsigned int v10; // r1
  int v11; // r6
  int Group; // r0
  int v13; // r0
  CAnimBlendAssociation *v14; // r0
  int v15; // r0

  if ( this->m_bIsFinished )
    return 1;
  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( !m_pTargetVehicle )
    return 1;
  AnimGroup = m_pTargetVehicle->pHandling->AnimGroup;
  if ( (CVehicleAnimGroupData::m_vehicleAnimGroups[AnimGroup].m_specialFlags & 2) != 0 )
  {
    v10 = this->m_iTargetDoor - 8;
    if ( v10 > 2 )
      v11 = 369;
    else
      v11 = (int)*(&off_61E414 + v10);
    Group = CVehicleAnimGroup::GetGroup(&CVehicleAnimGroupData::m_vehicleAnimGroups[AnimGroup], v11);
    (*((void (__fastcall **)(CVehicle *, CPed *, int, int, int, int))this->m_pTargetVehicle->_vptr$CPlaceable + 29))(
      this->m_pTargetVehicle,
      pPed,
      this->m_iTargetDoor,
      Group,
      v11,
      1065353216);
    return 1;
  }
  m_pAnim = this->m_pAnim;
  if ( !m_pAnim )
  {
    if ( pPed->m_nPedState != PED_ARRESTED )
    {
      v8 = this->m_iTargetDoor - 8;
      if ( v8 > 2 )
        v9 = 369;
      else
        v9 = (int)*(&off_61E414 + v8);
      v13 = CVehicleAnimGroup::GetGroup(&CVehicleAnimGroupData::m_vehicleAnimGroups[AnimGroup], v9);
      v14 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, (AssocGroupId)v13, (AnimationId)v9, 1000.0);
      this->m_pAnim = v14;
      CAnimBlendAssociation::SetFinishCallback(
        v14,
        CTaskSimpleCarCloseDoorFromInside::FinishAnimCarCloseDoorFromInsideCB,
        this);
      m_pAnim = this->m_pAnim;
      AnimGroup = this->m_pTargetVehicle->pHandling->AnimGroup;
      goto LABEL_15;
    }
    return 1;
  }
LABEL_15:
  v15 = CVehicleAnimGroup::GetGroup(&CVehicleAnimGroupData::m_vehicleAnimGroups[AnimGroup], m_pAnim->m_animId);
  (*((void (__fastcall **)(CVehicle *, CPed *, int, int, _DWORD, _DWORD))this->m_pTargetVehicle->_vptr$CPlaceable + 29))(
    this->m_pTargetVehicle,
    pPed,
    this->m_iTargetDoor,
    v15,
    this->m_pAnim->m_animId,
    LODWORD(this->m_pAnim->m_fCurrentTime));
  return 0;
}
// 61E414: using guessed type void *off_61E414;

//----- (00501758) --------------------------------------------------------
void __fastcall CTaskSimpleCarCloseDoorFromInside::StartAnim(CTaskSimpleCarCloseDoorFromInside *this, const CPed *pPed)
{
  unsigned int v4; // r0
  int v5; // r6
  int Group; // r0
  CAnimBlendAssociation *v7; // r0

  v4 = this->m_iTargetDoor - 8;
  if ( v4 > 2 )
    v5 = 369;
  else
    v5 = (int)*(&off_61E414 + v4);
  Group = CVehicleAnimGroup::GetGroup(
            &CVehicleAnimGroupData::m_vehicleAnimGroups[this->m_pTargetVehicle->pHandling->AnimGroup],
            v5);
  v7 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, (AssocGroupId)Group, (AnimationId)v5, 1000.0);
  this->m_pAnim = v7;
  sub_18C19C(v7, CTaskSimpleCarCloseDoorFromInside::FinishAnimCarCloseDoorFromInsideCB, this);
}
// 61E414: using guessed type void *off_61E414;

//----- (005017C8) --------------------------------------------------------
bool __fastcall CTaskSimpleCarCloseDoorFromInside::SetPedPosition(CTaskSimpleCarCloseDoorFromInside *this, CPed *pPed)
{
  CTaskUtilityLineUpPedWithCar::ProcessPed(this->m_pUtility, pPed, this->m_pTargetVehicle, this->m_pAnim);
  return 1;
}

//----- (005017DC) --------------------------------------------------------
void __fastcall CTaskSimpleCarCloseDoorFromInside::FinishAnimCarCloseDoorFromInsideCB(
        CAnimBlendAssociation *pAnim,
        void *pData)
{
  int v3; // r0
  unsigned int v4; // r1
  int v5; // r5
  int Group; // r0
  int v7; // r0

  v3 = *((_DWORD *)pData + 4);
  *((_BYTE *)pData + 8) = 1;
  if ( v3 )
  {
    v4 = *((_DWORD *)pData + 5) - 8;
    if ( v4 > 2 )
      v5 = 369;
    else
      v5 = (int)*(&off_61E414 + v4);
    Group = CVehicleAnimGroup::GetGroup(
              &CVehicleAnimGroupData::m_vehicleAnimGroups[*(unsigned __int8 *)(*(_DWORD *)(v3 + 904) + 222)],
              v5);
    (*(void (__fastcall **)(_DWORD, _DWORD, _DWORD, int, int, int))(**((_DWORD **)pData + 4) + 116))(
      *((_DWORD *)pData + 4),
      0,
      *((_DWORD *)pData + 5),
      Group,
      v5,
      1065353216);
  }
  v7 = *((_DWORD *)pData + 3);
  if ( v7 )
    *(_DWORD *)(v7 + 28) = -998637568;
  *((_DWORD *)pData + 3) = 0;
}
// 61E414: using guessed type void *off_61E414;

//----- (00501854) --------------------------------------------------------
void __fastcall CTaskSimpleCarCloseDoorFromOutside::CTaskSimpleCarCloseDoorFromOutside(
        CTaskSimpleCarCloseDoorFromOutside *this,
        CVehicle *pTargetVehicle,
        const int iTargetDoor,
        CTaskUtilityLineUpPedWithCar *pUtility)
{
  CTaskSimple::CTaskSimple(this);
  this->m_bIsFinished = 0;
  this->m_pAnim = 0;
  this->m_iTargetDoor = iTargetDoor;
  this->m_pUtility = pUtility;
  this->_vptr$CTask = (int (**)(void))&off_66B0FC;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66B0FC: using guessed type void *;

//----- (0050189C) --------------------------------------------------------
void __fastcall CTaskSimpleCarCloseDoorFromOutside::~CTaskSimpleCarCloseDoorFromOutside(
        CTaskSimpleCarCloseDoorFromOutside *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CAnimBlendAssociation *m_pAnim; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B0FC;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  sub_1A01F4(this);
}
// 66B0FC: using guessed type void *off_66B0FC;

//----- (005018DC) --------------------------------------------------------
void __fastcall CTaskSimpleCarCloseDoorFromOutside::~CTaskSimpleCarCloseDoorFromOutside(
        CTaskSimpleCarCloseDoorFromOutside *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CAnimBlendAssociation *m_pAnim; // r0
  void *v5; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B0FC;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v5);
}
// 501914: variable 'v5' is possibly undefined
// 66B0FC: using guessed type void *off_66B0FC;

//----- (00501920) --------------------------------------------------------
bool __fastcall CTaskSimpleCarCloseDoorFromOutside::MakeAbortable(
        CTaskSimpleCarCloseDoorFromOutside *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0
  CVehicle *m_pTargetVehicle; // r0
  unsigned int v8; // r1
  int v9; // r6
  int Group; // r0

  if ( iPriority != 2 )
    return 0;
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    m_pAnim->m_fBlendDelta = -1000.0;
  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( m_pTargetVehicle )
  {
    v8 = this->m_iTargetDoor - 8;
    if ( v8 > 2 )
      v9 = 382;
    else
      v9 = dword_61E420[v8];
    Group = CVehicleAnimGroup::GetGroup(
              &CVehicleAnimGroupData::m_vehicleAnimGroups[m_pTargetVehicle->pHandling->AnimGroup],
              v9);
    (*((void (__fastcall **)(CVehicle *, CPed *, int, int, int, int))this->m_pTargetVehicle->_vptr$CPlaceable + 29))(
      this->m_pTargetVehicle,
      pPed,
      this->m_iTargetDoor,
      Group,
      v9,
      1065353216);
  }
  return 1;
}
// 61E420: using guessed type _DWORD dword_61E420[3];

//----- (005019A0) --------------------------------------------------------
void __fastcall CTaskSimpleCarCloseDoorFromOutside::ComputeAnimID(
        CTaskSimpleCarCloseDoorFromOutside *this,
        int *animGroupId,
        int *animId)
{
  unsigned int v4; // r1
  int v5; // r1

  v4 = this->m_iTargetDoor - 8;
  if ( v4 >= 4 )
  {
    v5 = *animId;
  }
  else
  {
    v5 = dword_5019D8[v4];
    *animId = v5;
  }
  *animGroupId = CVehicleAnimGroup::GetGroup(
                   &CVehicleAnimGroupData::m_vehicleAnimGroups[this->m_pTargetVehicle->pHandling->AnimGroup],
                   v5);
}
// 5019D8: using guessed type int dword_5019D8[2];

//----- (005019EC) --------------------------------------------------------
bool __fastcall CTaskSimpleCarCloseDoorFromOutside::ProcessPed(CTaskSimpleCarCloseDoorFromOutside *this, CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r0
  unsigned int v6; // r0
  int v7; // r6
  int Group; // r0

  if ( this->m_bIsFinished )
    return 1;
  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( !m_pTargetVehicle )
    return 1;
  if ( LOBYTE(CVehicleAnimGroupData::m_vehicleAnimGroups[m_pTargetVehicle->pHandling->AnimGroup].m_specialFlags) << 31 )
    return 1;
  if ( !this->m_pAnim )
  {
    CTaskSimpleCarCloseDoorFromOutside::StartAnim(this, pPed);
    if ( !this->m_pAnim )
      return 1;
  }
  v6 = this->m_iTargetDoor - 8;
  if ( v6 > 2 )
    v7 = 382;
  else
    v7 = dword_61E420[v6];
  Group = CVehicleAnimGroup::GetGroup(
            &CVehicleAnimGroupData::m_vehicleAnimGroups[this->m_pTargetVehicle->pHandling->AnimGroup],
            v7);
  (*((void (__fastcall **)(CVehicle *, CPed *, int, int, int, _DWORD))this->m_pTargetVehicle->_vptr$CPlaceable + 29))(
    this->m_pTargetVehicle,
    pPed,
    this->m_iTargetDoor,
    Group,
    v7,
    LODWORD(this->m_pAnim->m_fCurrentTime));
  return 0;
}
// 61E420: using guessed type _DWORD dword_61E420[3];

//----- (00501A98) --------------------------------------------------------
void __fastcall CTaskSimpleCarCloseDoorFromOutside::StartAnim(
        CTaskSimpleCarCloseDoorFromOutside *this,
        const CPed *pPed)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r6
  CSimpleTransform *p_tx; // r1
  __int64 v7; // d16
  CMatrix *v8; // r0
  CVehicle *m_pTargetVehicle; // r0
  RwReal v10; // s4
  RwReal v11; // s6
  CVehicle *v12; // r0
  RwReal v13; // s4
  RwReal v14; // s0
  int32 m_nPedType; // r0
  int32 v16; // r0
  CPad *Pad; // r8
  CVehicle *v18; // r0
  int v19; // r6
  CVehicle *v20; // r0
  uint32 DoorStatus; // r0
  unsigned int v22; // r0
  int v23; // r6
  int Group; // r0
  CAnimBlendAssociation *v25; // r0
  bool v26; // zf
  bool v27; // zf
  bool v28; // zf
  CVector v29; // [sp+0h] [bp-20h] BYREF

  m_pMat = pPed->m_pMat;
  p_m_transform = &pPed->m_transform;
  p_tx = &pPed->m_transform;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  v7 = *(_QWORD *)&p_tx->m_translate.x;
  v29.z = p_tx->m_translate.z;
  *(_QWORD *)&v29.x = v7;
  CPedPlacement::FindZCoorForPed(&v29);
  v8 = pPed->m_pMat;
  if ( v8 )
    p_m_transform = (CSimpleTransform *)&v8->tx;
  if ( v29.z < (float)(p_m_transform->m_translate.z + -1.0) )
    goto LABEL_6;
  this->m_pTargetVehicle->m_nNoOfStaticFrames = 0;
  m_pTargetVehicle = this->m_pTargetVehicle;
  v10 = m_pTargetVehicle->m_vecMoveSpeed.y + 0.001;
  v11 = m_pTargetVehicle->m_vecMoveSpeed.z + 0.001;
  m_pTargetVehicle->m_vecMoveSpeed.x = m_pTargetVehicle->m_vecMoveSpeed.x + 0.001;
  m_pTargetVehicle->m_vecMoveSpeed.y = v10;
  m_pTargetVehicle->m_vecMoveSpeed.z = v11;
  v12 = this->m_pTargetVehicle;
  v13 = v12->m_vecTurnSpeed.y + 0.001;
  v14 = v12->m_vecTurnSpeed.z + 0.001;
  v12->m_vecTurnSpeed.x = v12->m_vecTurnSpeed.x + 0.001;
  v12->m_vecTurnSpeed.y = v13;
  v12->m_vecTurnSpeed.z = v14;
  if ( CPed::IsPlayer(pPed) )
  {
    m_nPedType = pPed->m_nPedType;
    if ( m_nPedType == 1 )
    {
      v16 = 1;
    }
    else
    {
      if ( m_nPedType )
      {
        Pad = 0;
        goto LABEL_14;
      }
      v16 = 0;
    }
    Pad = CPad::GetPad(v16);
LABEL_14:
    v18 = this->m_pTargetVehicle;
    v19 = 0;
    if ( !v18->m_baseVehicleType && CDamageManager::GetEngineStatus((const CDamageManager *)&v18[1]) > 0xE0 )
      v19 = 1;
    if ( !Pad->DisablePlayerControls && this->m_pTargetVehicle->m_eDoorLockState != CARLOCK_FORCE_SHUT_DOORS )
    {
      if ( CPad::GetTarget(Pad, 0) )
        goto LABEL_20;
      v26 = Pad->NewState.LeftStickX == 0;
      if ( !Pad->NewState.LeftStickX )
        v26 = Pad->NewState.LeftStickY == 0;
      if ( !v26 )
        goto LABEL_20;
      v27 = Pad->NewState.DPadUp == 0;
      if ( !Pad->NewState.DPadUp )
        v27 = Pad->NewState.DPadDown == 0;
      if ( !v27 )
        goto LABEL_20;
      v28 = Pad->NewState.DPadLeft == 0;
      if ( !Pad->NewState.DPadLeft )
        v28 = Pad->NewState.DPadRight == 0;
      if ( !v28 )
        goto LABEL_20;
    }
    if ( (this->m_pTargetVehicle->m_pFire != 0) | v19 )
    {
LABEL_20:
      v20 = this->m_pTargetVehicle;
      if ( !v20->m_baseVehicleType
        && (!CDamageManager::GetDoorStatus((const CDamageManager *)&v20[1], this->m_iTargetDoor)
         || CDamageManager::GetDoorStatus((const CDamageManager *)&this->m_pTargetVehicle[1], this->m_iTargetDoor) == 2) )
      {
        DoorStatus = CDamageManager::GetDoorStatus(
                       (const CDamageManager *)&this->m_pTargetVehicle[1],
                       this->m_iTargetDoor);
        CDamageManager::SetDoorStatus((CDamageManager *)&this->m_pTargetVehicle[1], this->m_iTargetDoor, DoorStatus + 1);
      }
LABEL_6:
      this->m_bIsFinished = 1;
      return;
    }
  }
  v22 = this->m_iTargetDoor - 8;
  if ( v22 > 2 )
    v23 = 382;
  else
    v23 = dword_61E420[v22];
  Group = CVehicleAnimGroup::GetGroup(
            &CVehicleAnimGroupData::m_vehicleAnimGroups[this->m_pTargetVehicle->pHandling->AnimGroup],
            v23);
  v25 = CAnimManager::AddAnimation((RpClump_0 *)pPed->m_pRwObject, (AssocGroupId)Group, (AnimationId)v23);
  this->m_pAnim = v25;
  CAnimBlendAssociation::SetFinishCallback(
    v25,
    CTaskSimpleCarCloseDoorFromOutside::FinishAnimCarCloseDoorFromOutsideCB,
    this);
}
// 61E420: using guessed type _DWORD dword_61E420[3];

//----- (00501C8C) --------------------------------------------------------
bool __fastcall CTaskSimpleCarCloseDoorFromOutside::SetPedPosition(
        CTaskSimpleCarCloseDoorFromOutside *this,
        CPed *pPed)
{
  CTaskUtilityLineUpPedWithCar::ProcessPed(this->m_pUtility, pPed, this->m_pTargetVehicle, this->m_pAnim);
  return 1;
}

//----- (00501C9E) --------------------------------------------------------
void __fastcall CTaskSimpleCarCloseDoorFromOutside::FinishAnimCarCloseDoorFromOutsideCB(
        CAnimBlendAssociation *pAnim,
        void *pData)
{
  *((_BYTE *)pData + 8) = 1;
  *((_DWORD *)pData + 3) = 0;
}

//----- (00501CA8) --------------------------------------------------------
void __fastcall CTaskSimpleCarGetIn::CTaskSimpleCarGetIn(
        CTaskSimpleCarGetIn *this,
        CVehicle *pTargetVehicle,
        const int iTargetDoor,
        CTaskUtilityLineUpPedWithCar *pUtility)
{
  CTaskSimple::CTaskSimple(this);
  this->m_bIsFinished = 0;
  this->m_pAnim = 0;
  this->m_iTargetDoor = iTargetDoor;
  this->m_pUtility = pUtility;
  this->_vptr$CTask = (int (**)(void))&off_66B130;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66B130: using guessed type void *;

//----- (00501CF0) --------------------------------------------------------
void __fastcall CTaskSimpleCarGetIn::~CTaskSimpleCarGetIn(CTaskSimpleCarGetIn *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CAnimBlendAssociation *m_pAnim; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B130;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  sub_1A01F4(this);
}
// 66B130: using guessed type void *off_66B130;

//----- (00501D30) --------------------------------------------------------
void __fastcall CTaskSimpleCarGetIn::~CTaskSimpleCarGetIn(CTaskSimpleCarGetIn *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CAnimBlendAssociation *m_pAnim; // r0
  void *v5; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B130;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v5);
}
// 501D68: variable 'v5' is possibly undefined
// 66B130: using guessed type void *off_66B130;

//----- (00501D74) --------------------------------------------------------
bool __fastcall CTaskSimpleCarGetIn::MakeAbortable(
        CTaskSimpleCarGetIn *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0

  if ( iPriority != 2 )
    return 0;
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    m_pAnim->m_fBlendDelta = -1000.0;
  return 1;
}

//----- (00501D90) --------------------------------------------------------
bool __fastcall CTaskSimpleCarGetIn::ProcessPed(CTaskSimpleCarGetIn *this, CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r0
  CVehicle *v5; // r0
  CAnimBlendAssociation *m_pAnim; // r1
  bool v8; // zf
  float *p_xx; // r1
  float v10; // s0
  RwReal v11; // s2
  unsigned int v12; // s4
  unsigned int v13; // s0
  CVector v14; // 0:r1.12

  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( !m_pTargetVehicle )
    return 1;
  if ( this->m_bIsFinished )
  {
    CPed::RemoveWeaponWhenEnteringVehicle(pPed, 0);
    if ( CCheat::m_aCheatsActive[60] )
    {
      if ( CPed::IsPlayer(pPed) )
      {
        v5 = this->m_pTargetVehicle;
        if ( v5 )
        {
          *(_DWORD *)&v5->m_nPhysicalFlags |= 0x800000u;
          *(_DWORD *)&this->m_pTargetVehicle->m_nPhysicalFlags |= 0x40000u;
          *(_DWORD *)&this->m_pTargetVehicle->m_nVehicleFlags &= ~0x200000u;
          return 1;
        }
      }
    }
    return 1;
  }
  if ( !this->m_pAnim )
  {
    CTaskSimpleCarGetIn::StartAnim(this, pPed);
    m_pTargetVehicle = this->m_pTargetVehicle;
  }
  if ( m_pTargetVehicle->m_vehicleType == 10 )
  {
    m_pAnim = this->m_pAnim;
    v8 = m_pAnim == 0;
    if ( m_pAnim )
      v8 = LOBYTE(m_pAnim->m_bitsFlag) << 31 == 0;
    if ( !v8
      && (unsigned int)(m_pAnim->m_animId - 359) <= 3
      && m_pAnim->m_fCurrentTime > (float)(BMX_PUSHOFF_START_FRAME / 30.0) )
    {
      p_xx = &m_pTargetVehicle->m_pMat->xx;
      v10 = (float)(BMX_PUSHOFF_FORCE_MULT * m_pTargetVehicle->m_fMass) * CTimer::ms_fTimeStep;
      v11 = v10 * p_xx[4];
      *(float *)&v12 = v10 * p_xx[5];
      *(float *)&v13 = v10 * p_xx[6];
      v14.x = v11;
      *(_QWORD *)&v14.y = __PAIR64__(v13, v12);
      CPhysical::ApplyMoveForce(m_pTargetVehicle, v14);
    }
  }
  return 0;
}

//----- (00501E9C) --------------------------------------------------------
void __fastcall CTaskSimpleCarGetIn::StartAnim(CTaskSimpleCarGetIn *this, const CPed *pPed)
{
  int v4; // r6
  int Group; // r1
  CAnimBlendAssociation *v6; // r0

  v4 = 359;
  switch ( this->m_iTargetDoor )
  {
    case 8:
      v4 = 360;
      break;
    case 9:
      v4 = 362;
      break;
    case 0xB:
      v4 = 361;
      break;
    case 0x12:
      v4 = 363;
      break;
    default:
      break;
  }
  Group = CVehicleAnimGroup::GetGroup(
            &CVehicleAnimGroupData::m_vehicleAnimGroups[this->m_pTargetVehicle->pHandling->AnimGroup],
            v4);
  if ( Group == 107 )
  {
    if ( this->m_iTargetDoor == 10
      && ((*((int (__fastcall **)(CVehicle *, int))this->m_pTargetVehicle->_vptr$CPlaceable + 39))(
            this->m_pTargetVehicle,
            10)
       || !(*((int (__fastcall **)(CVehicle *, int))this->m_pTargetVehicle->_vptr$CPlaceable + 38))(
             this->m_pTargetVehicle,
             this->m_iTargetDoor)) )
    {
      Group = 88;
    }
    else
    {
      Group = 107;
    }
  }
  v6 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, (AssocGroupId)Group, (AnimationId)v4, 4.0);
  this->m_pAnim = v6;
  sub_18C19C(v6, CTaskSimpleCarGetIn::FinishAnimCarGetInCB, this);
}

//----- (00501F50) --------------------------------------------------------
bool __fastcall CTaskSimpleCarGetIn::SetPedPosition(CTaskSimpleCarGetIn *this, CPed *pPed)
{
  CTaskUtilityLineUpPedWithCar::ProcessPed(this->m_pUtility, pPed, this->m_pTargetVehicle, this->m_pAnim);
  return 1;
}

//----- (00501F62) --------------------------------------------------------
void __fastcall CTaskSimpleCarGetIn::FinishAnimCarGetInCB(CAnimBlendAssociation *pAnim, void *pData)
{
  int v2; // r0

  v2 = *((_DWORD *)pData + 3);
  *((_BYTE *)pData + 8) = 1;
  if ( v2 )
    *(_DWORD *)(v2 + 28) = -998637568;
  *((_DWORD *)pData + 3) = 0;
}

//----- (00501F7C) --------------------------------------------------------
float __fastcall CTaskSimpleCarGetIn::GetPositionInAnim(CTaskSimpleCarGetIn *this)
{
  CAnimBlendAssociation *m_pAnim; // r0

  if ( this->m_bIsFinished )
    return 1.0;
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    return m_pAnim->m_fCurrentTime / m_pAnim->m_pAnimBlendHierarchy->m_fTotalTime;
  else
    return 0.0;
}

//----- (00501FB4) --------------------------------------------------------
void __fastcall CTaskSimpleCarShuffle::CTaskSimpleCarShuffle(
        CTaskSimpleCarShuffle *this,
        CVehicle *pTargetVehicle,
        const int iTargetDoor,
        CTaskUtilityLineUpPedWithCar *pUtility)
{
  CTaskSimple::CTaskSimple(this);
  this->m_bIsFinished = 0;
  this->m_pAnim = 0;
  this->m_iTargetDoor = iTargetDoor;
  this->m_pUtility = pUtility;
  this->_vptr$CTask = (int (**)(void))&off_66B164;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66B164: using guessed type void *;

//----- (00501FFC) --------------------------------------------------------
void __fastcall CTaskSimpleCarShuffle::~CTaskSimpleCarShuffle(CTaskSimpleCarShuffle *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CAnimBlendAssociation *m_pAnim; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B164;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  sub_1A01F4(this);
}
// 66B164: using guessed type void *off_66B164;

//----- (0050203C) --------------------------------------------------------
void __fastcall CTaskSimpleCarShuffle::~CTaskSimpleCarShuffle(CTaskSimpleCarShuffle *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CAnimBlendAssociation *m_pAnim; // r0
  void *v5; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B164;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v5);
}
// 502074: variable 'v5' is possibly undefined
// 66B164: using guessed type void *off_66B164;

//----- (00502080) --------------------------------------------------------
bool __fastcall CTaskSimpleCarShuffle::MakeAbortable(
        CTaskSimpleCarShuffle *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0

  if ( iPriority != 2 )
    return 0;
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    m_pAnim->m_fBlendDelta = -1000.0;
  return 1;
}

//----- (0050209C) --------------------------------------------------------
bool __fastcall CTaskSimpleCarShuffle::ProcessPed(CTaskSimpleCarShuffle *this, CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r0
  int Group; // r0
  CAnimBlendAssociation *v7; // r0

  if ( this->m_bIsFinished )
    return 1;
  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( !m_pTargetVehicle )
    return 1;
  if ( !this->m_pAnim )
  {
    Group = CVehicleAnimGroup::GetGroup(
              &CVehicleAnimGroupData::m_vehicleAnimGroups[m_pTargetVehicle->pHandling->AnimGroup],
              372);
    v7 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, (AssocGroupId)Group, ANIM_VEH_SHUFFLE_RHS, 1000.0);
    this->m_pAnim = v7;
    CAnimBlendAssociation::SetFinishCallback(v7, CTaskSimpleCarShuffle::FinishAnimCarShuffleCB, this);
  }
  return 0;
}

//----- (00502104) --------------------------------------------------------
void __fastcall CTaskSimpleCarShuffle::StartAnim(CTaskSimpleCarShuffle *this, const CPed *pPed)
{
  int Group; // r0
  CAnimBlendAssociation *v5; // r0

  Group = CVehicleAnimGroup::GetGroup(
            &CVehicleAnimGroupData::m_vehicleAnimGroups[this->m_pTargetVehicle->pHandling->AnimGroup],
            372);
  v5 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, (AssocGroupId)Group, ANIM_VEH_SHUFFLE_RHS, 1000.0);
  this->m_pAnim = v5;
  sub_18C19C(v5, CTaskSimpleCarShuffle::FinishAnimCarShuffleCB, this);
}

//----- (00502158) --------------------------------------------------------
bool __fastcall CTaskSimpleCarShuffle::SetPedPosition(CTaskSimpleCarShuffle *this, CPed *pPed)
{
  CAnimBlendAssociation *m_pAnim; // r3

  if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
  {
    m_pAnim = this->m_pAnim;
LABEL_5:
    CTaskUtilityLineUpPedWithCar::ProcessPed(this->m_pUtility, pPed, this->m_pTargetVehicle, m_pAnim);
    return 1;
  }
  m_pAnim = this->m_pAnim;
  if ( m_pAnim && m_pAnim->m_fBlendAmount > 0.9 )
    goto LABEL_5;
  CPed::SetPedPositionInCar(pPed);
  return 1;
}

//----- (00502198) --------------------------------------------------------
void __fastcall CTaskSimpleCarShuffle::FinishAnimCarShuffleCB(CAnimBlendAssociation *pAnim, void *pData)
{
  int v2; // r0

  v2 = *((_DWORD *)pData + 3);
  if ( v2 )
    *(_DWORD *)(v2 + 28) = -998637568;
  *((_BYTE *)pData + 8) = 1;
  *((_DWORD *)pData + 3) = 0;
}

//----- (005021B0) --------------------------------------------------------
void __fastcall CTaskSimpleCarWaitToSlowDown::CTaskSimpleCarWaitToSlowDown(
        CTaskSimpleCarWaitToSlowDown *this,
        CVehicle *pTargetVehicle,
        const int iSlowType)
{
  CTaskSimple::CTaskSimple(this);
  this->m_iSlowType = iSlowType;
  this->_vptr$CTask = (int (**)(void))&off_66B198;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66B198: using guessed type void *;

//----- (005021EC) --------------------------------------------------------
void __fastcall CTaskSimpleCarWaitToSlowDown::~CTaskSimpleCarWaitToSlowDown(CTaskSimpleCarWaitToSlowDown *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B198;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  sub_1A01F4(this);
}
// 66B198: using guessed type void *off_66B198;

//----- (00502218) --------------------------------------------------------
void __fastcall CTaskSimpleCarWaitToSlowDown::~CTaskSimpleCarWaitToSlowDown(CTaskSimpleCarWaitToSlowDown *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  void *v4; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B198;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  CTask::~CTask(this);
  sub_197118(v4);
}
// 502240: variable 'v4' is possibly undefined
// 66B198: using guessed type void *off_66B198;

//----- (00502248) --------------------------------------------------------
bool __fastcall CTaskSimpleCarWaitToSlowDown::MakeAbortable(
        CTaskSimpleCarWaitToSlowDown *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  bool v7; // zf

  if ( iPriority == 2 )
    return 1;
  if ( iPriority == 1 && pEvent && (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 9 )
  {
    v7 = LOBYTE(pEvent[5]._vptr$CEvent) == 0;
    if ( LOBYTE(pEvent[5]._vptr$CEvent) )
      v7 = !*(&pEvent->m_bIsPersistent + 1);
    if ( !v7 )
      return 1;
  }
  this->m_iSlowType = 2;
  return 0;
}

//----- (00502280) --------------------------------------------------------
bool __fastcall CTaskSimpleCarWaitToSlowDown::SetPedPosition(CTaskSimpleCarWaitToSlowDown *this, CPed *pPed)
{
  if ( this->m_pTargetVehicle )
    CPed::SetPedPositionInCar(pPed);
  return 1;
}

//----- (00502296) --------------------------------------------------------
bool __fastcall CTaskSimpleCarWaitToSlowDown::ProcessPed(CTaskSimpleCarWaitToSlowDown *this, CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r0
  bool v5; // zf
  const CPed *pDriver; // r0
  CVehicle *v7; // r0
  int m_iSlowType; // r0

  m_pTargetVehicle = this->m_pTargetVehicle;
  v5 = m_pTargetVehicle == 0;
  if ( m_pTargetVehicle )
    v5 = this->m_iSlowType == 2;
  if ( v5 )
    return 1;
  pDriver = m_pTargetVehicle->pDriver;
  if ( pDriver && !CPed::IsPlayer(pDriver) )
  {
    v7 = this->m_pTargetVehicle;
    if ( v7->pDriver == pPed )
    {
      v7->AutoPilot.CruiseSpeed = 0;
      this->m_pTargetVehicle->AutoPilot.Mission = 0;
    }
  }
  m_iSlowType = this->m_iSlowType;
  if ( m_iSlowType == 1 )
    return (*((int (__fastcall **)(CVehicle *, _DWORD))this->m_pTargetVehicle->_vptr$CPlaceable + 58))(
             this->m_pTargetVehicle,
             0);
  if ( m_iSlowType )
    return 0;
  if ( (*((int (__fastcall **)(CVehicle *, _DWORD))this->m_pTargetVehicle->_vptr$CPlaceable + 58))(
         this->m_pTargetVehicle,
         0) )
  {
    return 1;
  }
  return (*((int (__fastcall **)(CVehicle *, CPed *))this->m_pTargetVehicle->_vptr$CPlaceable + 59))(
           this->m_pTargetVehicle,
           pPed);
}

//----- (0050230C) --------------------------------------------------------
void __fastcall CTaskSimpleCarWaitForDoorNotToBeInUse::CTaskSimpleCarWaitForDoorNotToBeInUse(
        CTaskSimpleCarWaitForDoorNotToBeInUse *this,
        CVehicle *pTargetVehicle,
        const int iTargetDoor,
        const int iTargetDoorOpposite)
{
  CTaskSimple::CTaskSimple(this);
  this->m_iTargetDoor = iTargetDoor;
  this->m_iTargetDoorOpposite = iTargetDoorOpposite;
  this->_vptr$CTask = (int (**)(void))&off_66B1CC;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66B1CC: using guessed type void *;

//----- (00502350) --------------------------------------------------------
void __fastcall CTaskSimpleCarWaitForDoorNotToBeInUse::~CTaskSimpleCarWaitForDoorNotToBeInUse(
        CTaskSimpleCarWaitForDoorNotToBeInUse *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B1CC;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  sub_1A01F4(this);
}
// 66B1CC: using guessed type void *off_66B1CC;

//----- (0050237C) --------------------------------------------------------
void __fastcall CTaskSimpleCarWaitForDoorNotToBeInUse::~CTaskSimpleCarWaitForDoorNotToBeInUse(
        CTaskSimpleCarWaitForDoorNotToBeInUse *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  void *v4; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B1CC;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  CTask::~CTask(this);
  sub_197118(v4);
}
// 5023A4: variable 'v4' is possibly undefined
// 66B1CC: using guessed type void *off_66B1CC;

//----- (005023AC) --------------------------------------------------------
bool __fastcall CTaskSimpleCarWaitForDoorNotToBeInUse::IsValidTargetDoor(const int iTargetDoor)
{
  unsigned int v1; // r0
  _BOOL4 v2; // r0

  v1 = iTargetDoor - 8;
  if ( v1 <= 0xA )
    return (0x40Fu >> v1) & 1;
  else
    LOBYTE(v2) = 0;
  return v2;
}

//----- (005023C8) --------------------------------------------------------
bool __fastcall CTaskSimpleCarWaitForDoorNotToBeInUse::ProcessPed(
        CTaskSimpleCarWaitForDoorNotToBeInUse *this,
        CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r0
  _BOOL4 v4; // r0

  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( m_pTargetVehicle )
    LOBYTE(v4) = !CCarEnterExit::IsCarDoorInUse(m_pTargetVehicle, this->m_iTargetDoor, this->m_iTargetDoorOpposite);
  else
    return (char)&dword_0 + 1;
  return v4;
}
// 0: using guessed type int dword_0;

//----- (005023E6) --------------------------------------------------------
bool __fastcall CTaskSimpleCarWaitForDoorNotToBeInUse::SetPedPosition(
        CTaskSimpleCarWaitForDoorNotToBeInUse *this,
        CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r0

  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( m_pTargetVehicle && m_pTargetVehicle == pPed->m_pMyVehicle && *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
    CPed::SetPedPositionInCar(pPed);
  return 1;
}

//----- (0050240C) --------------------------------------------------------
void __fastcall CTaskSimpleCarWaitForDoorNotToBeInUse::CheckDoorsFreeOfPeds(
        const CVehicle *vehicle,
        const int iTargetDoor,
        bool *bQuit,
        bool *bWait)
{
  switch ( iTargetDoor )
  {
    case 8:
      if ( (vehicle->m_nGettingInFlags & 4) != 0 )
        *bQuit = 1;
      if ( (vehicle->m_nGettingOutFlags & 4) != 0 )
        goto LABEL_17;
      break;
    case 9:
      if ( (vehicle->m_nGettingInFlags & 8) != 0 )
        *bQuit = 1;
      if ( (vehicle->m_nGettingOutFlags & 8) != 0 )
        goto LABEL_17;
      break;
    case 10:
      if ( vehicle->m_nGettingInFlags << 31 )
        *bQuit = 1;
      if ( vehicle->m_nGettingOutFlags << 31 )
        goto LABEL_17;
      break;
    case 11:
      if ( (vehicle->m_nGettingInFlags & 2) != 0 )
        *bQuit = 1;
      if ( (vehicle->m_nGettingOutFlags & 2) != 0 )
LABEL_17:
        *bWait = 1;
      break;
    default:
      return;
  }
}

//----- (0050247C) --------------------------------------------------------
void __fastcall CTaskSimpleCarGoToPointNearDoorUntilDoorNotInUse::CTaskSimpleCarGoToPointNearDoorUntilDoorNotInUse(
        CTaskSimpleCarGoToPointNearDoorUntilDoorNotInUse *this,
        CVehicle *pTargetVehicle,
        const int iTargetDoor,
        const CVector *vTargetPos,
        const int iMoveState)
{
  __int64 v6; // r8
  CTaskSimpleGoToPoint *v9; // r0
  CTaskSimpleGoToPoint *v10; // r0
  char *v11; // r6

  v6 = (unsigned int)iTargetDoor;
  CTaskSimple::CTaskSimple(this);
  this->_vptr$CTask = (int (**)(void))&off_66B200;
  v9 = (CTaskSimpleGoToPoint *)CTask::operator new(0x2Cu);
  CTaskSimpleGoToPoint::CTaskSimpleGoToPoint(v9, iMoveState, vTargetPos, 0.5, 0, 0);
  this->m_pTaskGoToPoint = v10;
  v11 = (char *)CTask::operator new(0x14u);
  CTaskSimple::CTaskSimple((CTaskSimple *)v11);
  *(_DWORD *)v11 = &off_66B1CC;
  *(_QWORD *)(v11 + 12) = v6;
  *((_DWORD *)v11 + 2) = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, (CEntity **)v11 + 2);
  this->m_pTaskWaitForDoor = (CTaskSimpleCarWaitForDoorNotToBeInUse *)v11;
}
// 5024BA: variable 'v10' is possibly undefined
// 66B1CC: using guessed type void *off_66B1CC;
// 66B200: using guessed type void *off_66B200;

//----- (00502500) --------------------------------------------------------
void __fastcall CTaskSimpleCarGoToPointNearDoorUntilDoorNotInUse::~CTaskSimpleCarGoToPointNearDoorUntilDoorNotInUse(
        CTaskSimpleCarGoToPointNearDoorUntilDoorNotInUse *this)
{
  CTaskSimpleGoToPoint *m_pTaskGoToPoint; // r0
  CTaskSimpleCarWaitForDoorNotToBeInUse *m_pTaskWaitForDoor; // r0

  m_pTaskGoToPoint = this->m_pTaskGoToPoint;
  this->_vptr$CTask = (int (**)(void))&off_66B200;
  if ( m_pTaskGoToPoint )
    (*((void (__fastcall **)(CTaskSimpleGoToPoint *))m_pTaskGoToPoint->_vptr$CTask + 1))(m_pTaskGoToPoint);
  m_pTaskWaitForDoor = this->m_pTaskWaitForDoor;
  if ( m_pTaskWaitForDoor )
    (*((void (__fastcall **)(CTaskSimpleCarWaitForDoorNotToBeInUse *))m_pTaskWaitForDoor->_vptr$CTask + 1))(m_pTaskWaitForDoor);
  sub_1A01F4(this);
}
// 66B200: using guessed type void *;

//----- (00502538) --------------------------------------------------------
void __fastcall CTaskSimpleCarGoToPointNearDoorUntilDoorNotInUse::~CTaskSimpleCarGoToPointNearDoorUntilDoorNotInUse(
        CTaskSimpleCarGoToPointNearDoorUntilDoorNotInUse *this)
{
  CTaskSimpleGoToPoint *m_pTaskGoToPoint; // r0
  CTaskSimpleCarWaitForDoorNotToBeInUse *m_pTaskWaitForDoor; // r0
  void *v4; // r0

  m_pTaskGoToPoint = this->m_pTaskGoToPoint;
  this->_vptr$CTask = (int (**)(void))&off_66B200;
  if ( m_pTaskGoToPoint )
    (*((void (__fastcall **)(CTaskSimpleGoToPoint *))m_pTaskGoToPoint->_vptr$CTask + 1))(m_pTaskGoToPoint);
  m_pTaskWaitForDoor = this->m_pTaskWaitForDoor;
  if ( m_pTaskWaitForDoor )
    (*((void (__fastcall **)(CTaskSimpleCarWaitForDoorNotToBeInUse *))m_pTaskWaitForDoor->_vptr$CTask + 1))(m_pTaskWaitForDoor);
  CTask::~CTask(this);
  sub_197118(v4);
}
// 50256A: variable 'v4' is possibly undefined
// 66B200: using guessed type void *off_66B200;

//----- (00502574) --------------------------------------------------------
CTask *__fastcall CTaskSimpleCarGoToPointNearDoorUntilDoorNotInUse::Clone(
        const CTaskSimpleCarGoToPointNearDoorUntilDoorNotInUse *this)
{
  CTaskSimpleCarGoToPointNearDoorUntilDoorNotInUse *v2; // r0
  CTask *result; // r0

  v2 = (CTaskSimpleCarGoToPointNearDoorUntilDoorNotInUse *)CTask::operator new(0x10u);
  CTaskSimpleCarGoToPointNearDoorUntilDoorNotInUse::CTaskSimpleCarGoToPointNearDoorUntilDoorNotInUse(
    v2,
    this->m_pTaskWaitForDoor->m_pTargetVehicle,
    this->m_pTaskWaitForDoor->m_iTargetDoor,
    &this->m_pTaskGoToPoint->m_vTarget,
    this->m_pTaskGoToPoint->m_iMoveState);
  return result;
}

//----- (00502598) --------------------------------------------------------
bool __fastcall CTaskSimpleCarGoToPointNearDoorUntilDoorNotInUse::ProcessPed(
        CTaskSimpleCarGoToPointNearDoorUntilDoorNotInUse *this,
        CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r0
  CMatrix *m_pMat; // r1
  float *p_tx; // r2
  CTaskSimpleGoToPoint *m_pTaskGoToPoint; // r0
  float v8; // s0
  float v9; // s6
  float v10; // s2
  char v11; // r1
  CTaskSimpleStandStill *v12; // r0
  CTaskSimpleStandStill v14; // [sp+8h] [bp-28h] BYREF

  CCarEnterExit::GetPositionToOpenCarDoor(
    (CVector *)&v14,
    this->m_pTaskWaitForDoor->m_pTargetVehicle,
    this->m_pTaskWaitForDoor->m_iTargetDoor);
  m_pTargetVehicle = this->m_pTaskWaitForDoor->m_pTargetVehicle;
  m_pMat = m_pTargetVehicle->m_pMat;
  p_tx = &m_pMat->tx;
  if ( !m_pMat )
    p_tx = &m_pTargetVehicle->m_transform.m_translate.x;
  m_pTaskGoToPoint = this->m_pTaskGoToPoint;
  v8 = *p_tx + (float)((float)(*(float *)&v14._vptr$CTask - *p_tx) + (float)(*(float *)&v14._vptr$CTask - *p_tx));
  v9 = p_tx[1] + (float)((float)(*(float *)&v14.m_pParent - p_tx[1]) + (float)(*(float *)&v14.m_pParent - p_tx[1]));
  v10 = p_tx[2] + (float)((float)(*(float *)&v14.m_iDuration - p_tx[2]) + (float)(*(float *)&v14.m_iDuration - p_tx[2]));
  if ( m_pTaskGoToPoint->m_vTarget.x != v8
    || m_pTaskGoToPoint->m_vTarget.y != v9
    || m_pTaskGoToPoint->m_fTargetRadius != 0.5 )
  {
    v11 = *((_BYTE *)&m_pTaskGoToPoint->CTaskSimpleGoTo:232 + 28);
    m_pTaskGoToPoint->m_vTarget.x = v8;
    m_pTaskGoToPoint->m_vTarget.y = v9;
    m_pTaskGoToPoint->m_vTarget.z = v10;
    m_pTaskGoToPoint->m_fTargetRadius = 0.5;
    *((_BYTE *)&m_pTaskGoToPoint->CTaskSimpleGoTo:232 + 28) = v11 & 0xD0 | 0x20;
    m_pTaskGoToPoint = this->m_pTaskGoToPoint;
  }
  if ( (*((int (__fastcall **)(CTaskSimpleGoToPoint *, CPed *))m_pTaskGoToPoint->_vptr$CTask + 9))(
         m_pTaskGoToPoint,
         pPed) != 1 )
    return (*((int (__fastcall **)(CTaskSimpleCarWaitForDoorNotToBeInUse *, CPed *))this->m_pTaskWaitForDoor->_vptr$CTask
            + 9))(
             this->m_pTaskWaitForDoor,
             pPed);
  CTaskSimpleStandStill::CTaskSimpleStandStill(&v14, -1, 0, 0, 8.0);
  CTaskSimpleStandStill::ProcessPed(v12, pPed);
  CTaskSimpleStandStill::~CTaskSimpleStandStill(&v14);
  return 1;
}
// 502680: variable 'v12' is possibly undefined

//----- (005026A4) --------------------------------------------------------
void __fastcall CTaskSimpleCarGoToPointNearDoorUntilDoorNotInUse::ComputeTarget(
        const CTaskSimpleCarGoToPointNearDoorUntilDoorNotInUse *this,
        CVector *vTarget)
{
  CVehicle *m_pTargetVehicle; // r0
  CMatrix *m_pMat; // r1
  float *p_tx; // r2
  RwReal v7; // s2
  RwReal v8; // s4
  CVector v9; // [sp+4h] [bp-14h] BYREF

  CCarEnterExit::GetPositionToOpenCarDoor(
    &v9,
    this->m_pTaskWaitForDoor->m_pTargetVehicle,
    this->m_pTaskWaitForDoor->m_iTargetDoor);
  m_pTargetVehicle = this->m_pTaskWaitForDoor->m_pTargetVehicle;
  m_pMat = m_pTargetVehicle->m_pMat;
  p_tx = &m_pMat->tx;
  if ( !m_pMat )
    p_tx = &m_pTargetVehicle->m_transform.m_translate.x;
  v7 = p_tx[1] + (float)((float)(v9.y - p_tx[1]) + (float)(v9.y - p_tx[1]));
  v8 = p_tx[2] + (float)((float)(v9.z - p_tx[2]) + (float)(v9.z - p_tx[2]));
  vTarget->x = *p_tx + (float)((float)(v9.x - *p_tx) + (float)(v9.x - *p_tx));
  vTarget->y = v7;
  vTarget->z = v8;
}

//----- (00502718) --------------------------------------------------------
void __fastcall CTaskSimpleCarSetPedInAsPassenger::CTaskSimpleCarSetPedInAsPassenger(
        CTaskSimpleCarSetPedInAsPassenger *this,
        CVehicle *pTargetVehicle,
        const int iTargetDoor,
        CTaskUtilityLineUpPedWithCar *pUtility)
{
  CTaskSimple::CTaskSimple(this);
  this->m_bIsFinished = 0;
  this->m_pAnim = 0;
  this->m_iTargetDoor = iTargetDoor;
  this->m_pUtility = pUtility;
  this->m_bWarpingInToCar = 0;
  this->m_nDoorFlagsToClear = 0;
  this->m_nNumGettingInToClear = 0;
  this->_vptr$CTask = (int (**)(void))&off_66B234;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66B234: using guessed type void *off_66B234;

//----- (00502768) --------------------------------------------------------
void __fastcall CTaskSimpleCarSetPedInAsPassenger::~CTaskSimpleCarSetPedInAsPassenger(
        CTaskSimpleCarSetPedInAsPassenger *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B234;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  sub_1A01F4(this);
}
// 66B234: using guessed type void *;

//----- (00502794) --------------------------------------------------------
void __fastcall CTaskSimpleCarSetPedInAsPassenger::~CTaskSimpleCarSetPedInAsPassenger(
        CTaskSimpleCarSetPedInAsPassenger *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  void *v4; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B234;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  CTask::~CTask(this);
  sub_197118(v4);
}
// 5027BC: variable 'v4' is possibly undefined
// 66B234: using guessed type void *off_66B234;

//----- (005027C4) --------------------------------------------------------
bool __fastcall CTaskSimpleCarSetPedInAsPassenger::ProcessPed(CTaskSimpleCarSetPedInAsPassenger *this, CPed *pPed)
{
  CPedFlags *p_m_nPedFlags; // r11
  CTask *m_pParent; // r0
  CVehicle *m_pMyVehicle; // r0
  CVehicle *m_pTargetVehicle; // r0
  CVehicle *v8; // r1
  int m_nVehicleFlags; // r0
  int v10; // r2
  _DWORD *p_m_nVehicleFlags; // r1
  CVehicle *v12; // r6
  CPlayerPed *PlayerPed; // r0
  CVehicle *v14; // r0
  int v15; // r8
  CPed *v16; // r0
  bool v17; // zf
  CVehicle *v18; // r9
  int v19; // r6
  CVehicle *v20; // r0
  CMatrix *m_pMat; // r1
  CMatrix *v22; // r2
  CSimpleTransform *p_tx; // r6
  __int64 v24; // kr00_8
  RwReal z; // r0
  float *p_tz; // r1
  CVehicle *v27; // r0
  CVehicle *v28; // r0
  int v29; // r2
  int v30; // r3
  int v31; // r6
  unsigned int v32; // r4
  CPedIntelligence *m_pPedIntelligence; // r4
  CTaskSimpleCarDrive *v34; // r5
  CTaskSimpleCarSetPedOut v36[2]; // [sp+4h] [bp-34h] BYREF

  p_m_nPedFlags = &pPed->m_nPedFlags;
  if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
  {
    m_pParent = this->m_pParent;
    if ( m_pParent )
      (*((void (__fastcall **)(CTask *))m_pParent->_vptr$CTask + 5))(m_pParent);
  }
  m_pMyVehicle = pPed->m_pMyVehicle;
  if ( m_pMyVehicle )
    CEntity::CleanUpOldReference(m_pMyVehicle, &pPed->m_pMyVehicle);
  m_pTargetVehicle = this->m_pTargetVehicle;
  pPed->m_pMyVehicle = m_pTargetVehicle;
  CEntity::RegisterReference(m_pTargetVehicle, &pPed->m_pMyVehicle);
  *(_DWORD *)p_m_nPedFlags |= 0x100u;
  pPed->m_fDesiredHeading = pPed->m_fCurrentHeading;
  if ( CPed::IsPlayer(pPed) )
  {
    pPed->m_pPlayerData->m_playersGangActive = 1;
    CPlayerPed::ClearAdrenaline((CPlayerPed *)pPed);
  }
  if ( CPed::IsPlayer(pPed) )
  {
    v8 = this->m_pTargetVehicle;
    m_nVehicleFlags = (int)v8->m_nVehicleFlags;
    if ( (m_nVehicleFlags & 0x20000) == 0 )
    {
      v10 = *((_DWORD *)&v8->m_nVehicleFlags + 1);
      p_m_nVehicleFlags = &v8->m_nVehicleFlags;
      *p_m_nVehicleFlags = m_nVehicleFlags | 0x20000;
      p_m_nVehicleFlags[1] = v10;
      v12 = this->m_pTargetVehicle;
      PlayerPed = FindPlayerPed(-1);
      CCrime::ReportCrime(CRIME_STEAL_CAR, v12, PlayerPed);
    }
  }
  v14 = this->m_pTargetVehicle;
  if ( (*((_BYTE *)&v14->m_nVehicleFlags + 1) & 2) != 0
    || (v15 = CCarEnterExit::ComputePassengerIndexFromCarDoor(v14, this->m_iTargetDoor), v15 == -1) )
  {
    v15 = -1;
  }
  else
  {
    v16 = this->m_pTargetVehicle->pPassengers[v15];
    v17 = v16 == pPed;
    if ( v16 != pPed )
      v17 = v16 == 0;
    if ( !v17
      && !CTaskManager::FindActiveTaskByType(&v16->m_pPedIntelligence->m_taskManager, 704)
      && !CTaskManager::FindActiveTaskByType(
            &this->m_pTargetVehicle->pPassengers[v15]->m_pPedIntelligence->m_taskManager,
            824)
      && !CTaskManager::FindActiveTaskByType(
            &this->m_pTargetVehicle->pPassengers[v15]->m_pPedIntelligence->m_taskManager,
            705)
      && !CTaskManager::FindActiveTaskByType(
            &this->m_pTargetVehicle->pPassengers[v15]->m_pPedIntelligence->m_taskManager,
            826) )
    {
      v18 = this->m_pTargetVehicle;
      v19 = CCarEnterExit::ComputeTargetDoorToExit(v18, v18->pPassengers[v15]);
      CTaskSimple::CTaskSimple(v36);
      v36[0].m_pTargetVehicle = v18;
      v36[0]._vptr$CTask = (int (**)(void))&off_66B338;
      v36[0].m_iTargetDoor = v19;
      v36[0].m_bSwitchOffEngine = 1;
      v36[0].m_nNumGettingInToClear = 0;
      *(_DWORD *)&v36[0].m_bWarpingOutOfCar = 0;
      CEntity::RegisterReference(v18, &v36[0].m_pTargetVehicle);
      v36[0].m_bWarpingOutOfCar = 1;
      CTaskSimpleCarSetPedOut::ProcessPed(v36, this->m_pTargetVehicle->pPassengers[v15]);
      v36[0]._vptr$CTask = (int (**)(void))&off_66B338;
      if ( v36[0].m_pTargetVehicle )
        CEntity::CleanUpOldReference(v36[0].m_pTargetVehicle, &v36[0].m_pTargetVehicle);
      CTask::~CTask(v36);
    }
  }
  if ( this->m_bWarpingInToCar )
  {
    v20 = this->m_pTargetVehicle;
    m_pMat = pPed->m_pMat;
    v22 = v20->m_pMat;
    p_tx = (CSimpleTransform *)&v22->tx;
    if ( !v22 )
      p_tx = &v20->m_transform;
    v24 = *(_QWORD *)&p_tx->m_translate.x;
    z = p_tx->m_translate.z;
    if ( m_pMat )
    {
      LODWORD(m_pMat->tx) = v24;
      pPed->m_pMat->ty = *((float *)&v24 + 1);
      p_tz = &pPed->m_pMat->tz;
    }
    else
    {
      p_tz = &pPed->m_transform.m_translate.z;
      *(_QWORD *)&pPed->m_transform.m_translate.x = v24;
    }
    *p_tz = z;
  }
  v27 = this->m_pTargetVehicle;
  if ( v15 == -1 )
    CVehicle::AddPassenger(v27, pPed);
  else
    CVehicle::AddPassenger(v27, pPed, v15);
  CPed::UpdateStatEnteringVehicle(pPed);
  CPed::SetMoveState(pPed, PEDMOVE_NONE);
  (*((void (__fastcall **)(CPed *))pPed->_vptr$CPlaceable + 24))(pPed);
  *(_DWORD *)&pPed->m_nFlags &= ~1u;
  v28 = this->m_pTargetVehicle;
  if ( v28->CarAlarmState == 0xFFFF )
    v28->CarAlarmState = 15000;
  CPed::SetPedState(pPed, PED_DRIVING);
  if ( this->m_nDoorFlagsToClear )
    CVehicle::ClearGettingInFlags(this->m_pTargetVehicle, this->m_nDoorFlagsToClear);
  if ( this->m_nNumGettingInToClear )
    this->m_pTargetVehicle->m_nNumGettingIn -= this->m_nNumGettingInToClear;
  CPed::RemoveWeaponWhenEnteringVehicle(pPed, 0);
  v29 = *((_DWORD *)p_m_nPedFlags + 1);
  v30 = *((_DWORD *)p_m_nPedFlags + 2);
  v31 = *((_DWORD *)p_m_nPedFlags + 3);
  v32 = *(_DWORD *)p_m_nPedFlags | 0x2000;
  if ( (*(_DWORD *)&this->m_pTargetVehicle->m_nVehicleFlags & 0x200) != 0 )
    v32 = *(_DWORD *)p_m_nPedFlags & 0xFFFFDFFF;
  *(_DWORD *)p_m_nPedFlags = v32;
  *((_DWORD *)p_m_nPedFlags + 1) = v29;
  *((_DWORD *)p_m_nPedFlags + 2) = v30;
  *((_DWORD *)p_m_nPedFlags + 3) = v31;
  CCarEnterExit::RemoveGetInAnims(pPed);
  CCarEnterExit::AddInCarAnim(this->m_pTargetVehicle, pPed, 0);
  if ( !this->m_bWarpingInToCar )
    CTaskUtilityLineUpPedWithCar::ProcessPed(this->m_pUtility, pPed, this->m_pTargetVehicle, 0);
  m_pPedIntelligence = pPed->m_pPedIntelligence;
  v34 = (CTaskSimpleCarDrive *)CTask::operator new(0x60u);
  CTaskSimpleCarDrive::CTaskSimpleCarDrive(v34, this->m_pTargetVehicle, this->m_pUtility, 0);
  CTaskManager::SetTask(&m_pPedIntelligence->m_taskManager, v34, 4, 0);
  return 1;
}
// 66B338: using guessed type void *off_66B338;

//----- (00502AD0) --------------------------------------------------------
bool __fastcall CTaskSimpleCarSetPedOut::ProcessPed(CTaskSimpleCarSetPedOut *this, CPed *pPed)
{
  int m_nPedFlags; // r0
  int m_nFlags; // r1
  CVehicle *m_pMyVehicle; // r0
  CVehicle *v7; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  __int64 v10; // d16
  CVehicle *v11; // r0
  int v12; // r2
  bool v13; // zf
  CPedIntelligence *m_pPedIntelligence; // r5
  CTaskSimplePlayerOnFoot *v15; // r6
  CTaskManager *p_m_taskManager; // r0
  CTaskComplexWander *WanderTaskByPedType; // r1
  CPedIntelligence *v18; // r9
  CTaskSimpleStandStill *v19; // r6
  CVehicle *m_pTargetVehicle; // r0
  CVehicle *v22; // r0
  CVector Point; // [sp+8h] [bp-28h] BYREF

  m_nPedFlags = (int)pPed->m_nPedFlags;
  m_nFlags = (int)pPed->m_nFlags;
  *(_DWORD *)&pPed->m_nPedFlags = m_nPedFlags & 0xFFFFFEFF;
  *(_DWORD *)&pPed->m_nFlags = m_nFlags | 1;
  CPed::UpdateStatLeavingVehicle(pPed);
  if ( !this->m_bKnockedOffBike )
    CTaskSimpleCarSetPedOut::PositionPedOutOfCollision(pPed, 0, this->m_iTargetDoor);
  CCarEnterExit::RemoveCarSitAnim(pPed);
  CPed::RestartNonPartialAnims(pPed);
  if ( !*(_WORD *)&this->m_bFallingOutOfCar && this->m_pTargetVehicle->m_vehicleType != 5 )
  {
    pPed->m_vecMoveSpeed.x = 0.0;
    pPed->m_vecMoveSpeed.y = 0.0;
    pPed->m_vecMoveSpeed.z = 0.0;
  }
  if ( pPed->m_pMyVehicle )
  {
    if ( this->m_nDoorFlagsToClear )
      CVehicle::ClearGettingOutFlags(this->m_pTargetVehicle, this->m_nDoorFlagsToClear);
    if ( this->m_nNumGettingInToClear )
      this->m_pTargetVehicle->m_nNumGettingIn -= this->m_nNumGettingInToClear;
    m_pMyVehicle = pPed->m_pMyVehicle;
    if ( m_pMyVehicle->pDriver == pPed )
    {
      CVehicle::RemoveDriver(m_pMyVehicle, !this->m_bSwitchOffEngine);
      pPed->m_pMyVehicle->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&pPed->m_pMyVehicle->m_info & 7 | 0x20);
      v7 = pPed->m_pMyVehicle;
      if ( v7->m_eDoorLockState == CARLOCK_LOCKED_INITIALLY )
        v7->m_eDoorLockState = CARLOCK_UNLOCKED;
      if ( pPed->m_nPedType == 6 && CVehicle::IsLawEnforcementVehicle(pPed->m_pMyVehicle) )
        CVehicle::ChangeLawEnforcerState(pPed->m_pMyVehicle, 0);
    }
    else
    {
      CVehicle::RemovePassenger(m_pMyVehicle, pPed);
    }
    m_pMat = pPed->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pPed->m_transform;
    v10 = *(_QWORD *)&p_tx->m_translate.x;
    Point.z = p_tx->m_translate.z;
    *(_QWORD *)&Point.x = v10;
    if ( CGarages::IsPointWithinAnyGarage(&Point) )
    {
      *((_BYTE *)pPed->m_pMyVehicle + 1202) &= 0xE7u;
      v11 = pPed->m_pMyVehicle;
      v12 = *((_DWORD *)&v11->m_nVehicleFlags + 1);
      *(_DWORD *)&v11->m_nVehicleFlags &= ~0x40u;
      *((_DWORD *)&v11->m_nVehicleFlags + 1) = v12;
    }
  }
  v13 = !this->m_bFallingOutOfCar;
  if ( !this->m_bFallingOutOfCar )
    v13 = !this->m_bKnockedOffBike;
  if ( v13 )
  {
    v22 = pPed->m_pMyVehicle;
    if ( v22 )
    {
      if ( v22->m_baseVehicleType == 9 && fabsf(v22->m_vecMoveSpeed.x) < 0.1 && fabsf(v22->m_vecMoveSpeed.y) < 0.1 )
        LOBYTE(v22[1].m_vecTurnFriction.z) |= 0x10u;
    }
  }
  if ( CPed::IsPlayer(pPed) )
  {
    m_pPedIntelligence = pPed->m_pPedIntelligence;
    v15 = (CTaskSimplePlayerOnFoot *)CTask::operator new(0x34u);
    CTaskSimplePlayerOnFoot::CTaskSimplePlayerOnFoot(v15);
    p_m_taskManager = &m_pPedIntelligence->m_taskManager;
    WanderTaskByPedType = (CTaskComplexWander *)v15;
  }
  else
  {
    v18 = pPed->m_pPedIntelligence;
    if ( pPed->CharCreatedBy == 2 )
    {
      v19 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(
        v19,
        (const int)"List_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly",
        1,
        0,
        8.0);
      p_m_taskManager = &v18->m_taskManager;
      WanderTaskByPedType = (CTaskComplexWander *)v19;
    }
    else
    {
      WanderTaskByPedType = CTaskComplexWander::GetWanderTaskByPedType(pPed);
      p_m_taskManager = &v18->m_taskManager;
    }
  }
  CTaskManager::SetTask(p_m_taskManager, WanderTaskByPedType, 4, 0);
  CPed::ReplaceWeaponWhenExitingVehicle(pPed);
  *((_DWORD *)&pPed->m_nPedFlags + 2) |= 8u;
  CPed::SetPedState(pPed, PED_IDLE);
  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( m_pTargetVehicle && (*((_BYTE *)&m_pTargetVehicle->m_nPhysicalFlags + 3) & 8) != 0 )
    *(_DWORD *)&pPed->m_nPhysicalFlags |= 0x8000000u;
  return 1;
}

//----- (00502D28) --------------------------------------------------------
void __fastcall CTaskSimpleCarSetPedInAsDriver::CTaskSimpleCarSetPedInAsDriver(
        CTaskSimpleCarSetPedInAsDriver *this,
        CVehicle *pTargetVehicle,
        CTaskUtilityLineUpPedWithCar *pUtility)
{
  CTaskSimple::CTaskSimple(this);
  this->m_bIsFinished = 0;
  this->m_pAnim = 0;
  this->m_pUtility = pUtility;
  this->m_bWarpingInToCar = 0;
  this->m_nDoorFlagsToClear = 0;
  this->m_nNumGettingInToClear = 0;
  this->_vptr$CTask = (int (**)(void))&off_66B268;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66B268: using guessed type void *off_66B268;

//----- (00502D70) --------------------------------------------------------
void __fastcall CTaskSimpleCarSetPedInAsDriver::~CTaskSimpleCarSetPedInAsDriver(CTaskSimpleCarSetPedInAsDriver *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B268;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  sub_1A01F4(this);
}
// 66B268: using guessed type void *;

//----- (00502D9C) --------------------------------------------------------
void __fastcall CTaskSimpleCarSetPedInAsDriver::~CTaskSimpleCarSetPedInAsDriver(CTaskSimpleCarSetPedInAsDriver *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  void *v4; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B268;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  CTask::~CTask(this);
  sub_197118(v4);
}
// 502DC4: variable 'v4' is possibly undefined
// 66B268: using guessed type void *off_66B268;

//----- (00502DCC) --------------------------------------------------------
bool __fastcall CTaskSimpleCarSetPedInAsDriver::ProcessPed(CTaskSimpleCarSetPedInAsDriver *this, CPed *pPed)
{
  CVehicle *m_pMyVehicle; // r0
  CEntity **p_m_pMyVehicle; // r6
  CVehicle *m_pTargetVehicle; // r0
  CPed *pDriver; // r0
  bool v8; // zf
  CVehicle *v9; // r6
  int v10; // r8
  CVehicle *v11; // r0
  CMatrix *m_pMat; // r1
  CMatrix *v13; // r2
  CSimpleTransform *p_tx; // r6
  __int64 v15; // kr00_8
  RwReal z; // r0
  float *p_tz; // r1
  CPedGroup *PedsGroup; // r0
  CPedGroup *v19; // r6
  _BOOL4 IsLeader; // r0
  bool v21; // zf
  CPedGroupIntelligence *p_m_intelligence; // r8
  void *v23; // r9
  CVehicle *v24; // r6
  CVehicle *v25; // r1
  int m_nVehicleFlags; // r0
  int v27; // r2
  _DWORD *p_m_nVehicleFlags; // r1
  CVehicle *v29; // r6
  CPlayerPed *PlayerPed; // r0
  CVehicle *v31; // r0
  int v32; // r1
  unsigned int v33; // r3
  _BOOL4 IsPlayer; // r0
  CVehicle *v35; // r1
  CEntity::CEntityInfo m_info; // r2
  CEntity::CEntityInfo v37; // r0
  char v38; // r0
  CPedFlags *p_m_nPedFlags; // r6
  CVehicle *v40; // r0
  int v41; // r0
  int v42; // r1
  int v43; // r2
  unsigned int v44; // r3
  CPedIntelligence *m_pPedIntelligence; // r8
  _BOOL4 m_bWarpingInToCar; // r5
  CTaskSimpleCarDrive *v47; // r0
  CTask *v48; // r6
  CTaskUtilityLineUpPedWithCar *m_pUtility; // r2
  CVehicle *v50; // r0
  CEventGlobalGroup *EventGlobalGroup; // r0
  CTaskSimpleCarSetPedOut v53[2]; // [sp+4h] [bp-34h] BYREF

  m_pMyVehicle = pPed->m_pMyVehicle;
  p_m_pMyVehicle = &pPed->m_pMyVehicle;
  if ( m_pMyVehicle )
    CEntity::CleanUpOldReference(m_pMyVehicle, &pPed->m_pMyVehicle);
  m_pTargetVehicle = this->m_pTargetVehicle;
  pPed->m_pMyVehicle = m_pTargetVehicle;
  CEntity::RegisterReference(m_pTargetVehicle, p_m_pMyVehicle);
  pDriver = this->m_pTargetVehicle->pDriver;
  v8 = pDriver == pPed;
  if ( pDriver != pPed )
    v8 = pDriver == 0;
  if ( !v8
    && !CTaskManager::FindActiveTaskByType(&pDriver->m_pPedIntelligence->m_taskManager, 704)
    && !CTaskManager::FindActiveTaskByType(&this->m_pTargetVehicle->pDriver->m_pPedIntelligence->m_taskManager, 824)
    && !CTaskManager::FindActiveTaskByType(&this->m_pTargetVehicle->pDriver->m_pPedIntelligence->m_taskManager, 705)
    && !CTaskManager::FindActiveTaskByType(&this->m_pTargetVehicle->pDriver->m_pPedIntelligence->m_taskManager, 826) )
  {
    v9 = this->m_pTargetVehicle;
    v10 = CCarEnterExit::ComputeTargetDoorToExit(v9, v9->pDriver);
    CTaskSimple::CTaskSimple(v53);
    v53[0].m_pTargetVehicle = v9;
    v53[0]._vptr$CTask = (int (**)(void))&off_66B338;
    v53[0].m_iTargetDoor = v10;
    v53[0].m_bSwitchOffEngine = 1;
    v53[0].m_nNumGettingInToClear = 0;
    *(_DWORD *)&v53[0].m_bWarpingOutOfCar = 0;
    CEntity::RegisterReference(v9, &v53[0].m_pTargetVehicle);
    v53[0].m_bWarpingOutOfCar = 1;
    CTaskSimpleCarSetPedOut::ProcessPed(v53, this->m_pTargetVehicle->pDriver);
    v53[0]._vptr$CTask = (int (**)(void))&off_66B338;
    if ( v53[0].m_pTargetVehicle )
      CEntity::CleanUpOldReference(v53[0].m_pTargetVehicle, &v53[0].m_pTargetVehicle);
    CTask::~CTask(v53);
  }
  pPed->m_fDesiredHeading = pPed->m_fCurrentHeading;
  if ( this->m_bWarpingInToCar )
  {
    v11 = this->m_pTargetVehicle;
    m_pMat = pPed->m_pMat;
    v13 = v11->m_pMat;
    p_tx = (CSimpleTransform *)&v13->tx;
    if ( !v13 )
      p_tx = &v11->m_transform;
    v15 = *(_QWORD *)&p_tx->m_translate.x;
    z = p_tx->m_translate.z;
    if ( m_pMat )
    {
      LODWORD(m_pMat->tx) = v15;
      pPed->m_pMat->ty = *((float *)&v15 + 1);
      p_tz = &pPed->m_pMat->tz;
    }
    else
    {
      p_tz = &pPed->m_transform.m_translate.z;
      *(_QWORD *)&pPed->m_transform.m_translate.x = v15;
    }
    *p_tz = z;
  }
  PedsGroup = CPedGroups::GetPedsGroup(pPed);
  v19 = PedsGroup;
  if ( PedsGroup )
  {
    IsLeader = CPedGroupMembership::IsLeader(&PedsGroup->m_membership, pPed);
    v21 = IsLeader;
    if ( IsLeader )
      v21 = v19->m_intelligence.m_pCurrentEvent == 0;
    if ( v21 )
    {
      p_m_intelligence = &v19->m_intelligence;
      v23 = CEvent::operator new(0x14u);
      v24 = this->m_pTargetVehicle;
      CEventEditableResponse::CEventEditableResponse((CEventEditableResponse *)v23);
      *(_DWORD *)v23 = &off_666E48;
      *((_DWORD *)v23 + 4) = v24;
      if ( v24 )
        CEntity::RegisterReference(v24, (CEntity **)v23 + 4);
      CEventGroupEvent::CEventGroupEvent((CEventGroupEvent *)v53, pPed, (CEvent *)v23);
      CPedGroupIntelligence::AddEvent(p_m_intelligence, (CEvent *)v53);
      CEventGroupEvent::~CEventGroupEvent((CEventGroupEvent *)v53);
    }
  }
  CVehicle::SetDriver(this->m_pTargetVehicle, pPed);
  *(_DWORD *)&pPed->m_nPedFlags |= 0x100u;
  if ( CPed::IsPlayer(pPed) )
  {
    pPed->m_pPlayerData->m_playersGangActive = 1;
    CPlayerPed::ClearAdrenaline((CPlayerPed *)pPed);
  }
  if ( CPed::IsPlayer(pPed) )
  {
    v25 = this->m_pTargetVehicle;
    m_nVehicleFlags = (int)v25->m_nVehicleFlags;
    if ( (m_nVehicleFlags & 0x20000) == 0 )
    {
      v27 = *((_DWORD *)&v25->m_nVehicleFlags + 1);
      p_m_nVehicleFlags = &v25->m_nVehicleFlags;
      *p_m_nVehicleFlags = m_nVehicleFlags | 0x20000;
      p_m_nVehicleFlags[1] = v27;
      v29 = this->m_pTargetVehicle;
      PlayerPed = FindPlayerPed(-1);
      CCrime::ReportCrime(CRIME_STEAL_CAR, v29, PlayerPed);
    }
  }
  CPed::UpdateStatEnteringVehicle(pPed);
  CPed::SetMoveState(pPed, PEDMOVE_NONE);
  (*((void (__fastcall **)(CPed *))pPed->_vptr$CPlaceable + 24))(pPed);
  *(_DWORD *)&pPed->m_nFlags &= ~1u;
  v31 = this->m_pTargetVehicle;
  if ( v31->CarAlarmState == 0xFFFF )
  {
    v31->CarAlarmState = 15000;
    v31 = this->m_pTargetVehicle;
  }
  v32 = (int)v31->m_nVehicleFlags;
  v33 = v32 & 0xFFFFFFEF;
  if ( (*((_DWORD *)&v31->m_nVehicleFlags + 1) & 0x200) == 0 )
    v33 = v32 | 0x10;
  *(_DWORD *)&v31->m_nVehicleFlags = v33;
  CPed::SetPedState(pPed, PED_DRIVING);
  IsPlayer = CPed::IsPlayer(pPed);
  v35 = this->m_pTargetVehicle;
  m_info = v35->m_info;
  if ( IsPlayer )
  {
    v37 = (CEntity::CEntityInfo)(*(_BYTE *)&m_info & 7);
LABEL_44:
    v35->m_info = v37;
    goto LABEL_45;
  }
  if ( (*(_BYTE *)&m_info & 0xF8) != 16 || pPed->CharCreatedBy == 2 )
  {
    v38 = *(_BYTE *)&v35->m_info & 7;
    if ( v35->m_vehicleType == 6 )
      v37 = (CEntity::CEntityInfo)(v38 | 0x38);
    else
      v37 = (CEntity::CEntityInfo)(v38 | 0x18);
    goto LABEL_44;
  }
LABEL_45:
  if ( this->m_nDoorFlagsToClear )
    CVehicle::ClearGettingInFlags(this->m_pTargetVehicle, this->m_nDoorFlagsToClear);
  p_m_nPedFlags = &pPed->m_nPedFlags;
  if ( this->m_nNumGettingInToClear )
    this->m_pTargetVehicle->m_nNumGettingIn -= this->m_nNumGettingInToClear;
  CCarEnterExit::RemoveGetInAnims(pPed);
  CCarEnterExit::AddInCarAnim(this->m_pTargetVehicle, pPed, 1);
  CPed::RemoveWeaponWhenEnteringVehicle(pPed, 0);
  v40 = this->m_pTargetVehicle;
  if ( (*((_BYTE *)&v40->m_nVehicleFlags + 1) & 2) != 0 && v40->m_nModelIndex != 431 )
  {
    v41 = *((_DWORD *)&pPed->m_nPedFlags + 1);
    v43 = *((_DWORD *)&pPed->m_nPedFlags + 3);
    v42 = *((_DWORD *)&pPed->m_nPedFlags + 2);
    v44 = *(_DWORD *)p_m_nPedFlags & 0xFFFFDFFF;
  }
  else
  {
    v41 = *((_DWORD *)&pPed->m_nPedFlags + 1);
    v43 = *((_DWORD *)&pPed->m_nPedFlags + 3);
    v42 = *((_DWORD *)&pPed->m_nPedFlags + 2);
    v44 = *(_DWORD *)p_m_nPedFlags | 0x2000;
  }
  *(_DWORD *)p_m_nPedFlags = v44;
  *((_DWORD *)&pPed->m_nPedFlags + 1) = v41;
  *((_DWORD *)&pPed->m_nPedFlags + 2) = v42;
  *((_DWORD *)&pPed->m_nPedFlags + 3) = v43;
  m_pPedIntelligence = pPed->m_pPedIntelligence;
  m_bWarpingInToCar = this->m_bWarpingInToCar;
  v47 = (CTaskSimpleCarDrive *)CTask::operator new(0x60u);
  v48 = v47;
  if ( m_bWarpingInToCar )
    m_pUtility = 0;
  else
    m_pUtility = this->m_pUtility;
  CTaskSimpleCarDrive::CTaskSimpleCarDrive(v47, this->m_pTargetVehicle, m_pUtility, 0);
  CTaskManager::SetTask(&m_pPedIntelligence->m_taskManager, v48, 4, 0);
  if ( CPed::IsPlayer(pPed) )
  {
    v50 = this->m_pTargetVehicle;
    if ( v50 )
    {
      if ( CVehicle::IsLawEnforcementVehicle(v50) )
      {
        CEventCopCarBeingStolen::CEventCopCarBeingStolen((CEventCopCarBeingStolen *)v53, pPed, this->m_pTargetVehicle);
        EventGlobalGroup = GetEventGlobalGroup();
        CEventGroup::Add(EventGlobalGroup, (CEvent *)v53, 0);
        CEventCopCarBeingStolen::~CEventCopCarBeingStolen((CEventCopCarBeingStolen *)v53);
      }
    }
  }
  return 1;
}
// 666E48: using guessed type void *;
// 66B338: using guessed type void *;

//----- (00503188) --------------------------------------------------------
void __fastcall CTaskSimpleCarGetOut::CTaskSimpleCarGetOut(
        CTaskSimpleCarGetOut *this,
        CVehicle *pTargetVehicle,
        const int iTargetDoor,
        CTaskUtilityLineUpPedWithCar *pUtility)
{
  CTaskSimple::CTaskSimple(this);
  *(_WORD *)&this->m_bIsFinished = 0;
  this->m_pAnim = 0;
  this->m_bIsUpsideDown = 0;
  this->m_iTargetDoor = iTargetDoor;
  this->m_pUtility = pUtility;
  this->_vptr$CTask = (int (**)(void))&off_66B29C;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66B29C: using guessed type void *;

//----- (005031D4) --------------------------------------------------------
void __fastcall CTaskSimpleCarGetOut::~CTaskSimpleCarGetOut(CTaskSimpleCarGetOut *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CAnimBlendAssociation *m_pAnim; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B29C;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  sub_1A01F4(this);
}
// 66B29C: using guessed type void *off_66B29C;

//----- (00503214) --------------------------------------------------------
void __fastcall CTaskSimpleCarGetOut::~CTaskSimpleCarGetOut(CTaskSimpleCarGetOut *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CAnimBlendAssociation *m_pAnim; // r0
  void *v5; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B29C;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v5);
}
// 50324C: variable 'v5' is possibly undefined
// 66B29C: using guessed type void *off_66B29C;

//----- (00503258) --------------------------------------------------------
bool __fastcall CTaskSimpleCarGetOut::MakeAbortable(
        CTaskSimpleCarGetOut *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0

  if ( iPriority != 2 )
    return 0;
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    m_pAnim->m_fBlendDelta = -1000.0;
  return 1;
}

//----- (00503274) --------------------------------------------------------
bool __fastcall CTaskSimpleCarGetOut::ProcessPed(CTaskSimpleCarGetOut *this, CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r0
  CAnimBlendAssociation *m_pAnim; // r0
  CVehicle *v7; // r1
  int m_iTargetDoor; // r2
  int *p_m_iTargetDoor; // r6
  int v10; // r1
  int Group; // r3
  CVehicle *v12; // r0
  int IsCarUpsideDown; // r0
  float zx; // s0
  CUpsideDownCarCheck v15; // [sp+8h] [bp-40h] BYREF

  if ( !this->m_pTargetVehicle )
    return 1;
  if ( this->m_bIsFinished )
  {
    if ( CCheat::m_aCheatsActive[60] && CPed::IsPlayer(pPed) )
    {
      m_pTargetVehicle = this->m_pTargetVehicle;
      if ( m_pTargetVehicle )
      {
        *(_DWORD *)&m_pTargetVehicle->m_nPhysicalFlags &= ~0x800000u;
        *(_DWORD *)&this->m_pTargetVehicle->m_nPhysicalFlags &= ~0x40000u;
        *(_DWORD *)&this->m_pTargetVehicle->m_nVehicleFlags |= 0x200000u;
      }
    }
    return 1;
  }
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
  {
    if ( m_pAnim->m_fBlendAmount == 1.0 )
      *(_DWORD *)&pPed->m_nPedFlags |= 0x2000u;
    if ( !this->m_bHasDoorToOpen || this->m_bIsUpsideDown )
      return 0;
    v7 = this->m_pTargetVehicle;
    if ( v7->m_baseVehicleType )
    {
      p_m_iTargetDoor = &this->m_iTargetDoor;
      m_iTargetDoor = this->m_iTargetDoor;
LABEL_15:
      if ( (unsigned int)(m_iTargetDoor - 8) > 2 )
        v10 = 375;
      else
        v10 = dword_61E42C[m_iTargetDoor - 8];
      Group = CVehicleAnimGroup::GetGroup(
                &CVehicleAnimGroupData::m_vehicleAnimGroups[this->m_pTargetVehicle->pHandling->AnimGroup],
                v10);
      m_iTargetDoor = *p_m_iTargetDoor;
      v12 = this->m_pTargetVehicle;
      goto LABEL_20;
    }
    IsCarUpsideDown = CUpsideDownCarCheck::IsCarUpsideDown(&v15, v7);
    this->m_bIsUpsideDown = IsCarUpsideDown != 0;
    p_m_iTargetDoor = &this->m_iTargetDoor;
    m_iTargetDoor = this->m_iTargetDoor;
    if ( !IsCarUpsideDown )
      goto LABEL_15;
    v12 = this->m_pTargetVehicle;
    zx = v12->m_pMat->zx;
    if ( (m_iTargetDoor & 0xFFFFFFFE) == 10 )
    {
      if ( zx >= -0.5 )
      {
LABEL_26:
        Group = 0;
LABEL_20:
        (*((void (__fastcall **)(CVehicle *, CPed *, int, int, _DWORD, _DWORD))v12->_vptr$CPlaceable + 29))(
          v12,
          pPed,
          m_iTargetDoor,
          Group,
          this->m_pAnim->m_animId,
          LODWORD(this->m_pAnim->m_fCurrentTime));
        return 0;
      }
    }
    else if ( zx <= 0.5 )
    {
      goto LABEL_26;
    }
    this->m_bIsUpsideDown = 0;
    goto LABEL_15;
  }
  CTaskSimpleCarGetOut::StartAnim(this, pPed);
  CPed::SetPedPositionInCar(pPed);
  CPed::ReplaceWeaponWhenExitingVehicle(pPed);
  this->m_bHasDoorToOpen = CCarEnterExit::CarHasDoorToOpen(this->m_pTargetVehicle, this->m_iTargetDoor);
  return 0;
}
// 61E42C: using guessed type _DWORD dword_61E42C[5];

//----- (005033D4) --------------------------------------------------------
void __fastcall CTaskSimpleCarGetOut::StartAnim(CTaskSimpleCarGetOut *this, const CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r1
  _BOOL4 m_bIsUpsideDown; // r0
  bool *p_m_bIsUpsideDown; // r1
  int m_iTargetDoor; // r2
  float zx; // s0
  int v9; // r6
  int Group; // r1
  CAnimBlendAssociation *v11; // r0
  CUpsideDownCarCheck v12; // [sp+0h] [bp-40h] BYREF

  CCarEnterExit::RemoveCarSitAnim(pPed);
  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( m_pTargetVehicle->m_baseVehicleType )
  {
    p_m_bIsUpsideDown = &this->m_bIsUpsideDown;
    m_bIsUpsideDown = this->m_bIsUpsideDown;
  }
  else
  {
    m_bIsUpsideDown = CUpsideDownCarCheck::IsCarUpsideDown(&v12, m_pTargetVehicle) != 0;
    this->m_bIsUpsideDown = m_bIsUpsideDown;
    p_m_bIsUpsideDown = &this->m_bIsUpsideDown;
  }
  m_iTargetDoor = this->m_iTargetDoor;
  if ( !m_bIsUpsideDown )
  {
LABEL_12:
    if ( (unsigned int)(m_iTargetDoor - 8) > 2 )
      v9 = 375;
    else
      v9 = dword_61E42C[m_iTargetDoor - 8];
    Group = CVehicleAnimGroup::GetGroup(
              &CVehicleAnimGroupData::m_vehicleAnimGroups[this->m_pTargetVehicle->pHandling->AnimGroup],
              v9);
    goto LABEL_16;
  }
  zx = this->m_pTargetVehicle->m_pMat->zx;
  if ( (m_iTargetDoor & 0xFFFFFFFE) != 10 )
  {
    if ( zx <= 0.5 )
      goto LABEL_7;
    goto LABEL_11;
  }
  if ( zx < -0.5 )
  {
LABEL_11:
    *p_m_bIsUpsideDown = 0;
    goto LABEL_12;
  }
LABEL_7:
  v9 = 109;
  if ( (m_iTargetDoor & 0xFFFFFFFE) == 10 )
    v9 = 108;
  Group = 0;
LABEL_16:
  v11 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, (AssocGroupId)Group, (AnimationId)v9, 1000.0);
  this->m_pAnim = v11;
  CAnimBlendAssociation::SetFinishCallback(v11, CTaskSimpleCarGetOut::FinishAnimCarGetOutCB, this);
}
// 61E42C: using guessed type _DWORD dword_61E42C[5];
// 5033D4: using guessed type CUpsideDownCarCheck anonymous_0;

//----- (005034B0) --------------------------------------------------------
void __fastcall CTaskSimpleCarGetOut::ComputeAnimID(CTaskSimpleCarGetOut *this, int *animGroupId, int *animId)
{
  CVehicle *m_pTargetVehicle; // r1
  _BOOL4 m_bIsUpsideDown; // r0
  bool *p_m_bIsUpsideDown; // r1
  int m_iTargetDoor; // r2
  float zx; // s0
  int Group; // r0
  int v12; // r1
  CUpsideDownCarCheck v13; // [sp+0h] [bp-40h] BYREF

  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( m_pTargetVehicle->m_baseVehicleType )
  {
    p_m_bIsUpsideDown = &this->m_bIsUpsideDown;
    m_bIsUpsideDown = this->m_bIsUpsideDown;
  }
  else
  {
    m_bIsUpsideDown = CUpsideDownCarCheck::IsCarUpsideDown(&v13, m_pTargetVehicle) != 0;
    this->m_bIsUpsideDown = m_bIsUpsideDown;
    p_m_bIsUpsideDown = &this->m_bIsUpsideDown;
  }
  m_iTargetDoor = this->m_iTargetDoor;
  if ( !m_bIsUpsideDown )
  {
LABEL_12:
    if ( (unsigned int)(m_iTargetDoor - 8) >= 4 )
    {
      v12 = *animId;
    }
    else
    {
      v12 = dword_503578[m_iTargetDoor - 8];
      *animId = v12;
    }
    Group = CVehicleAnimGroup::GetGroup(
              &CVehicleAnimGroupData::m_vehicleAnimGroups[this->m_pTargetVehicle->pHandling->AnimGroup],
              v12);
    goto LABEL_16;
  }
  zx = this->m_pTargetVehicle->m_pMat->zx;
  if ( (m_iTargetDoor & 0xFFFFFFFE) != 10 )
  {
    if ( zx <= 0.5 )
      goto LABEL_7;
    goto LABEL_11;
  }
  if ( zx < -0.5 )
  {
LABEL_11:
    *p_m_bIsUpsideDown = 0;
    goto LABEL_12;
  }
LABEL_7:
  if ( (unsigned int)(m_iTargetDoor - 8) <= 3 )
    *animId = (int)*(&off_503568 + m_iTargetDoor - 8);
  Group = 0;
LABEL_16:
  *animGroupId = Group;
}
// 503568: using guessed type void *off_503568;
// 503578: using guessed type int dword_503578[];
// 5034B0: using guessed type CUpsideDownCarCheck anonymous_0;

//----- (0050358C) --------------------------------------------------------
bool __fastcall CTaskSimpleCarGetOut::SetPedPosition(CTaskSimpleCarGetOut *this, CPed *pPed)
{
  CAnimBlendAssociation *m_pAnim; // r3

  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CTaskUtilityLineUpPedWithCar::ProcessPed(this->m_pUtility, pPed, this->m_pTargetVehicle, m_pAnim);
  else
    CPed::SetPedPositionInCar(pPed);
  return 1;
}

//----- (005035BA) --------------------------------------------------------
void __fastcall CTaskSimpleCarGetOut::FinishAnimCarGetOutCB(CAnimBlendAssociation *pAnim, void *pData)
{
  *((_BYTE *)pData + 8) = 1;
  *((_DWORD *)pData + 3) = 0;
}

//----- (005035C4) --------------------------------------------------------
void __fastcall CTaskSimpleCarJumpOut::CTaskSimpleCarJumpOut(
        CTaskSimpleCarJumpOut *this,
        CVehicle *pTargetVehicle,
        const int iTargetDoor,
        CTaskUtilityLineUpPedWithCar *pUtility)
{
  CVehicle *m_pTargetVehicle; // r0

  CTaskSimple::CTaskSimple(this);
  this->m_bIsFinished = 0;
  this->m_pAnim = 0;
  this->m_fStartCarSpeed = 0.0;
  this->m_iTargetDoor = iTargetDoor;
  this->m_nDoorFlagsToClear = 0;
  this->m_nNumGettingInToClear = 0;
  this->m_pUtility = pUtility;
  this->_vptr$CTask = (int (**)(void))&off_66B2D0;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
  {
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
    m_pTargetVehicle = this->m_pTargetVehicle;
    this->m_fStartCarSpeed = sqrtf(
                               (float)((float)(m_pTargetVehicle->m_vecMoveSpeed.x * m_pTargetVehicle->m_vecMoveSpeed.x)
                                     + (float)(m_pTargetVehicle->m_vecMoveSpeed.y * m_pTargetVehicle->m_vecMoveSpeed.y))
                             + (float)(m_pTargetVehicle->m_vecMoveSpeed.z * m_pTargetVehicle->m_vecMoveSpeed.z));
  }
}
// 66B2D0: using guessed type void *;

//----- (0050363C) --------------------------------------------------------
void __fastcall CTaskSimpleCarJumpOut::~CTaskSimpleCarJumpOut(CTaskSimpleCarJumpOut *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CAnimBlendAssociation *m_pAnim; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B2D0;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  sub_1A01F4(this);
}
// 66B2D0: using guessed type void *off_66B2D0;

//----- (0050367C) --------------------------------------------------------
void __fastcall CTaskSimpleCarJumpOut::~CTaskSimpleCarJumpOut(CTaskSimpleCarJumpOut *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CAnimBlendAssociation *m_pAnim; // r0
  void *v5; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B2D0;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v5);
}
// 5036B4: variable 'v5' is possibly undefined
// 66B2D0: using guessed type void *off_66B2D0;

//----- (005036C0) --------------------------------------------------------
bool __fastcall CTaskSimpleCarJumpOut::MakeAbortable(
        CTaskSimpleCarJumpOut *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0
  bool result; // r0
  CAnimBlendAssociation *v9; // r0

  if ( iPriority == 2 )
  {
    m_pAnim = this->m_pAnim;
    if ( m_pAnim )
      m_pAnim->m_fBlendDelta = -1000.0;
    return 1;
  }
  else
  {
    result = 0;
    if ( iPriority == 1 && pEvent )
    {
      if ( ((*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 33
         || (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 66)
        && (v9 = this->m_pAnim) != 0
        && !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
      {
        v9->m_fBlendDelta = -2.0;
        result = 1;
        this->m_bIsFinished = 1;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

//----- (0050372C) --------------------------------------------------------
bool __fastcall CTaskSimpleCarJumpOut::ProcessPed(CTaskSimpleCarJumpOut *this, CPed *pPed)
{
  int32 m_vehicleType; // r2
  CVehicle *m_pTargetVehicle; // r0
  CAnimBlendAssociation *m_pAnim; // r1
  float m_fCurrentTime; // s0
  int32 m_baseVehicleType; // r1
  bool v10; // zf
  float v11; // s16
  float v12; // s0
  int m_nPedFlags; // r0
  CVehicle *v14; // r1
  int v15; // r1
  int v16; // r3
  int v17; // r2
  CAnimBlendAssociation *v18; // r0
  CVehicle *v19; // r6
  float v20; // s0
  int32 v21; // r1
  bool v22; // zf
  int *v23; // r3
  int m_iTargetDoor; // r8
  int v25; // r0
  CEntity **v26; // r8
  CVehicle *v27; // r0
  CMatrix *m_pMat; // r1
  float zz; // s16
  float m_heading; // s0
  int v31; // r6
  int v32; // r0
  CAnimBlendAssociation *v33; // r0
  tHandlingData *pHandling; // r0
  int v35; // r6
  CVehicleAnimGroup *v36; // r0
  int Group; // r0
  CMatrix *v38; // r0
  CVehicle *v39; // r0
  __int64 v40; // d16
  CVehicle *v41; // r0
  uint32 DoorStatus; // r0
  CTaskSimpleCarSetPedOut v43[2]; // [sp+8h] [bp-38h] BYREF

  if ( this->m_bIsFinished )
    return 1;
  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( !m_pTargetVehicle )
    return 1;
  m_pAnim = this->m_pAnim;
  if ( !m_pAnim )
    goto LABEL_11;
  m_fCurrentTime = m_pAnim->m_fCurrentTime;
  if ( m_fCurrentTime < 0.73333 )
  {
    m_baseVehicleType = m_pTargetVehicle->m_baseVehicleType;
    v10 = m_baseVehicleType == 9;
    if ( m_baseVehicleType != 9 )
      v10 = m_pTargetVehicle->m_vehicleType == 2;
    if ( v10 )
      goto LABEL_11;
  }
  if ( m_fCurrentTime < 0.45 && !m_pTargetVehicle->m_baseVehicleType )
  {
LABEL_11:
    v11 = CTimer::ms_fTimeStep;
    v12 = powf(0.96, CTimer::ms_fTimeStep) * this->m_fStartCarSpeed;
    this->m_fStartCarSpeed = v12;
    pPed->m_extractedVelocity.y = pPed->m_extractedVelocity.y + (float)(v11 * v12);
  }
  m_nPedFlags = (int)pPed->m_nPedFlags;
  if ( (m_nPedFlags & 0x100) != 0 )
  {
    v18 = this->m_pAnim;
    if ( v18 )
    {
      v19 = this->m_pTargetVehicle;
      v20 = 0.35;
      v21 = v19->m_baseVehicleType;
      v22 = v21 == 9;
      if ( v21 != 9 )
      {
        m_vehicleType = v19->m_vehicleType;
        v22 = m_vehicleType == 2;
      }
      if ( !v22 )
      {
        v23 = dword_503A24;
        if ( m_vehicleType == 4 )
          v23 = &dword_503A24[1];
        v20 = *(float *)v23;
      }
      if ( v18->m_fCurrentTime <= v20 )
      {
        if ( !v21 )
        {
          pHandling = v19->pHandling;
          v35 = 385;
          v36 = &CVehicleAnimGroupData::m_vehicleAnimGroups[pHandling->AnimGroup];
          if ( (this->m_iTargetDoor & 0xFFFFFFFE) == 10 )
            v35 = 384;
          Group = CVehicleAnimGroup::GetGroup(v36, v35);
          (*((void (__fastcall **)(CVehicle *, CPed *, int, int, int, _DWORD))this->m_pTargetVehicle->_vptr$CPlaceable
           + 29))(
            this->m_pTargetVehicle,
            pPed,
            this->m_iTargetDoor,
            Group,
            v35,
            LODWORD(this->m_pAnim->m_fCurrentTime));
        }
      }
      else
      {
        m_iTargetDoor = this->m_iTargetDoor;
        CTaskSimple::CTaskSimple(v43);
        v43[0].m_pTargetVehicle = v19;
        v43[0].m_iTargetDoor = m_iTargetDoor;
        v26 = (CEntity **)(v25 + 8);
        v43[0].m_bSwitchOffEngine = 1;
        v43[0].m_nNumGettingInToClear = 0;
        *(_DWORD *)&v43[0].m_bWarpingOutOfCar = 0;
        v43[0]._vptr$CTask = (int (**)(void))&off_66B338;
        if ( v19 )
          CEntity::RegisterReference(v19, v26);
        v43[0].m_nDoorFlagsToClear = this->m_nDoorFlagsToClear;
        v43[0].m_nNumGettingInToClear = this->m_nNumGettingInToClear;
        CTaskSimpleCarSetPedOut::ProcessPed(v43, pPed);
        CCarEnterExit::RemoveCarSitAnim(pPed);
        v27 = this->m_pTargetVehicle;
        m_pMat = v27->m_pMat;
        zz = m_pMat->zz;
        if ( m_pMat )
          m_heading = atan2f(COERCE_FLOAT(LODWORD(m_pMat->xy) ^ 0x80000000), m_pMat->yy);
        else
          m_heading = v27->m_transform.m_heading;
        if ( zz < 0.0 )
          m_heading = CGeneral::LimitRadianAngle(m_heading + 3.1416);
        v38 = pPed->m_pMat;
        pPed->m_fCurrentHeading = m_heading;
        pPed->m_fDesiredHeading = m_heading;
        if ( v38 )
          CMatrix::SetRotateZOnly(v38, m_heading);
        else
          pPed->m_transform.m_heading = m_heading;
        v39 = this->m_pTargetVehicle;
        v40 = *(_QWORD *)&v39->m_vecMoveSpeed.x;
        pPed->m_vecMoveSpeed.z = v39->m_vecMoveSpeed.z;
        *(_QWORD *)&pPed->m_vecMoveSpeed.x = v40;
        pPed->m_pNOCollisionVehicle = this->m_pTargetVehicle;
        *((_DWORD *)&pPed->m_nPedFlags + 1) |= 0x80000000;
        v41 = this->m_pTargetVehicle;
        if ( !v41->m_baseVehicleType
          && (!CDamageManager::GetDoorStatus((const CDamageManager *)&v41[1], this->m_iTargetDoor)
           || CDamageManager::GetDoorStatus((const CDamageManager *)&this->m_pTargetVehicle[1], this->m_iTargetDoor) == 2) )
        {
          DoorStatus = CDamageManager::GetDoorStatus(
                         (const CDamageManager *)&this->m_pTargetVehicle[1],
                         this->m_iTargetDoor);
          CDamageManager::SetDoorStatus(
            (CDamageManager *)&this->m_pTargetVehicle[1],
            this->m_iTargetDoor,
            DoorStatus + 1);
        }
        v43[0]._vptr$CTask = (int (**)(void))&off_66B338;
        if ( v43[0].m_pTargetVehicle )
          CEntity::CleanUpOldReference(v43[0].m_pTargetVehicle, v26);
        CTask::~CTask(v43);
      }
    }
    else
    {
      v31 = 385;
      if ( (this->m_iTargetDoor & 0xFFFFFFFE) == 10 )
        v31 = 384;
      v32 = CVehicleAnimGroup::GetGroup(
              &CVehicleAnimGroupData::m_vehicleAnimGroups[this->m_pTargetVehicle->pHandling->AnimGroup],
              v31);
      v33 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, (AssocGroupId)v32, (AnimationId)v31, 8.0);
      this->m_pAnim = v33;
      CAnimBlendAssociation::SetFinishCallback(v33, CTaskSimpleCarJumpOut::FinishAnimCarJumpOutCB, this);
    }
    return 0;
  }
  else
  {
    v14 = this->m_pTargetVehicle;
    if ( v14 )
    {
      if ( !v14->m_baseVehicleType )
      {
        v15 = *((_DWORD *)&pPed->m_nPedFlags + 1);
        v16 = *((_DWORD *)&pPed->m_nPedFlags + 3);
        v17 = *((_DWORD *)&pPed->m_nPedFlags + 2) | 0x100000;
        pPed->m_ik.m_flags |= 8u;
        *(_DWORD *)&pPed->m_nPedFlags = m_nPedFlags;
        *((_DWORD *)&pPed->m_nPedFlags + 1) = v15;
        *((_DWORD *)&pPed->m_nPedFlags + 2) = v17;
        *((_DWORD *)&pPed->m_nPedFlags + 3) = v16;
      }
    }
    return this->m_pAnim == 0;
  }
}
// 50382C: variable 'm_vehicleType' is possibly undefined
// 503854: variable 'v25' is possibly undefined
// 503A24: using guessed type int dword_503A24[2];
// 66B338: using guessed type void *off_66B338;

//----- (00503A44) --------------------------------------------------------
void __fastcall CTaskSimpleCarJumpOut::StartAnim(CTaskSimpleCarJumpOut *this, const CPed *pPed)
{
  int v4; // r6
  unsigned int v5; // r1
  __int16 AnimGroup; // r0
  int Group; // r0
  CAnimBlendAssociation *v8; // r0

  v4 = 385;
  v5 = this->m_iTargetDoor & 0xFFFFFFFE;
  AnimGroup = this->m_pTargetVehicle->pHandling->AnimGroup;
  if ( v5 == 10 )
    v4 = 384;
  Group = CVehicleAnimGroup::GetGroup(&CVehicleAnimGroupData::m_vehicleAnimGroups[AnimGroup], v4);
  v8 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, (AssocGroupId)Group, (AnimationId)v4, 8.0);
  this->m_pAnim = v8;
  sub_18C19C(v8, CTaskSimpleCarJumpOut::FinishAnimCarJumpOutCB, this);
}

//----- (00503AAC) --------------------------------------------------------
void __fastcall CTaskSimpleCarJumpOut::ComputeAnimID(CTaskSimpleCarJumpOut *this, int *animGroupId, int *animId)
{
  unsigned int v4; // r1
  int v5; // r1

  v4 = this->m_iTargetDoor - 8;
  if ( v4 >= 4 )
  {
    v5 = *animId;
  }
  else
  {
    v5 = dword_503AE4[v4];
    *animId = v5;
  }
  *animGroupId = CVehicleAnimGroup::GetGroup(
                   &CVehicleAnimGroupData::m_vehicleAnimGroups[this->m_pTargetVehicle->pHandling->AnimGroup],
                   v5);
}
// 503AE4: using guessed type int dword_503AE4[2];

//----- (00503AF8) --------------------------------------------------------
bool __fastcall CTaskSimpleCarJumpOut::SetPedPosition(CTaskSimpleCarJumpOut *this, CPed *pPed)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r8
  CSimpleTransform *p_tx; // r2
  __int64 v8; // d16
  CVehicle *m_pTargetVehicle; // r0
  int32 m_baseVehicleType; // r1
  bool v11; // zf
  float v12; // s0
  CAnimBlendAssociation *m_pAnim; // r0
  CMatrix *v14; // r1
  CVector v15; // [sp+0h] [bp-20h] BYREF

  if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
    return 0;
  CPed::SetPedPositionInCar(pPed);
  if ( this->m_pAnim )
  {
    m_pMat = pPed->m_pMat;
    p_m_transform = &pPed->m_transform;
    p_tx = &pPed->m_transform;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    v8 = *(_QWORD *)&p_tx->m_translate.x;
    v15.z = p_tx->m_translate.z;
    *(_QWORD *)&v15.x = v8;
    CWorld::pIgnoreEntity = this->m_pTargetVehicle;
    CPedPlacement::FindZCoorForPed(&v15);
    CWorld::pIgnoreEntity = 0;
    m_pTargetVehicle = this->m_pTargetVehicle;
    m_baseVehicleType = m_pTargetVehicle->m_baseVehicleType;
    v11 = m_baseVehicleType == 9;
    if ( m_baseVehicleType != 9 )
      v11 = m_pTargetVehicle->m_vehicleType == 2;
    if ( v11 )
      v12 = 0.27;
    else
      v12 = 0.07;
    m_pAnim = this->m_pAnim;
    if ( m_pAnim && (m_pAnim->m_animId & 0xFFFFFFFE) == 384 )
    {
      v14 = pPed->m_pMat;
      if ( v14 )
        p_m_transform = (CSimpleTransform *)&v14->tx;
      if ( v15.z > p_m_transform->m_translate.z )
        v14->tz = v14->tz + (float)((float)(v15.z - v14->tz) * (float)(m_pAnim->m_fCurrentTime / v12));
    }
  }
  return 1;
}

//----- (00503BCC) --------------------------------------------------------
void __fastcall CTaskSimpleCarJumpOut::FinishAnimCarJumpOutCB(CAnimBlendAssociation *pAnim, void *pData)
{
  *((_BYTE *)pData + 8) = 1;
  *((_DWORD *)pData + 3) = 0;
}

//----- (00503BD8) --------------------------------------------------------
void __fastcall CTaskSimpleCarForcePedOut::CTaskSimpleCarForcePedOut(
        CTaskSimpleCarForcePedOut *this,
        CVehicle *pTargetVehicle,
        const int iTargetDoor)
{
  CTaskSimple::CTaskSimple(this);
  this->m_iTargetDoor = iTargetDoor;
  this->_vptr$CTask = (int (**)(void))&off_66B304;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66B304: using guessed type void *;

//----- (00503C14) --------------------------------------------------------
void __fastcall CTaskSimpleCarForcePedOut::~CTaskSimpleCarForcePedOut(CTaskSimpleCarForcePedOut *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B304;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  sub_1A01F4(this);
}
// 66B304: using guessed type void *off_66B304;

//----- (00503C40) --------------------------------------------------------
void __fastcall CTaskSimpleCarForcePedOut::~CTaskSimpleCarForcePedOut(CTaskSimpleCarForcePedOut *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  void *v4; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B304;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  CTask::~CTask(this);
  sub_197118(v4);
}
// 503C68: variable 'v4' is possibly undefined
// 66B304: using guessed type void *off_66B304;

//----- (00503C70) --------------------------------------------------------
bool __fastcall CTaskSimpleCarForcePedOut::ProcessPed(CTaskSimpleCarForcePedOut *this, CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r0
  CVehicle *v5; // r2
  unsigned __int8 v7; // r0
  int v8; // r0
  int v9; // r1

  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( !m_pTargetVehicle )
    return 1;
  if ( CVehicle::IsDriver(m_pTargetVehicle, pPed) )
  {
    v5 = this->m_pTargetVehicle;
  }
  else
  {
    v7 = CCarEnterExit::ComputeOppositeDoorFlag(this->m_pTargetVehicle, this->m_iTargetDoor, 0);
    v5 = this->m_pTargetVehicle;
    if ( (v7 & v5->m_nGettingOutFlags) != 0 )
    {
      if ( !v5->pDriver )
      {
        v8 = CCarEnterExit::ComputePassengerIndexFromCarDoor(this->m_pTargetVehicle, this->m_iTargetDoor);
        v5 = this->m_pTargetVehicle;
        if ( v8 < 1 )
          goto LABEL_12;
        v9 = 0;
        while ( !v5->pPassengers[v9] )
        {
          if ( ++v9 >= v8 )
            goto LABEL_12;
        }
      }
      return 0;
    }
  }
LABEL_12:
  CPed::PositionPedOutOfCollision(pPed, this->m_iTargetDoor, v5, 1);
  return 1;
}

//----- (00503CE4) --------------------------------------------------------
void __fastcall CTaskSimpleCarSetPedOut::CTaskSimpleCarSetPedOut(
        CTaskSimpleCarSetPedOut *this,
        CVehicle *pTargetVehicle,
        const int iTargetDoor,
        const bool bSwitchOffEngine)
{
  CTaskSimple::CTaskSimple(this);
  this->m_iTargetDoor = iTargetDoor;
  this->m_bSwitchOffEngine = bSwitchOffEngine;
  this->m_nNumGettingInToClear = 0;
  *(_DWORD *)&this->m_bWarpingOutOfCar = 0;
  this->_vptr$CTask = (int (**)(void))&off_66B338;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66B338: using guessed type void *off_66B338;

//----- (00503D30) --------------------------------------------------------
void __fastcall CTaskSimpleCarSetPedOut::~CTaskSimpleCarSetPedOut(CTaskSimpleCarSetPedOut *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B338;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  sub_1A01F4(this);
}
// 66B338: using guessed type void *off_66B338;

//----- (00503D5C) --------------------------------------------------------
void __fastcall CTaskSimpleCarSetPedOut::~CTaskSimpleCarSetPedOut(CTaskSimpleCarSetPedOut *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  void *v4; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B338;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  CTask::~CTask(this);
  sub_197118(v4);
}
// 503D84: variable 'v4' is possibly undefined
// 66B338: using guessed type void *off_66B338;

//----- (00503D8C) --------------------------------------------------------
void __fastcall CTaskSimpleCarSetPedOut::PositionPedOutOfCollision(CPed *pPed, CVehicle *pVehicle, int nDoor)
{
  CVehicle *pException; // r4
  bool v5; // zf
  CMatrix *m_pMat; // r0
  float m_heading; // s0
  CMatrix *v9; // r0
  float *p_xx; // r0
  float v11; // s2
  float v12; // s4
  float v13; // s6
  CMatrix *v14; // r0
  float v15; // s4
  float v16; // s0
  CMatrix *v17; // r0
  float v18; // s2
  float v19; // s4
  CMatrix *v20; // r0
  float v21; // s2
  float v22; // s4
  CSimpleTransform *p_m_transform; // r10
  CSimpleTransform *p_tx; // r1
  CMatrix *v25; // r0
  float z; // s2
  CEntity *v27; // r0
  int v28; // r9
  float v29; // s6
  RwReal v30; // s4
  RwReal v31; // s0
  CPhysical *m_pGroundPhysical; // r1
  CMatrix *v33; // r0
  CSimpleTransform *v34; // r1
  float v35; // r3
  RwReal v36; // s4
  CEntity *v37; // r0
  CMatrix *v38; // r2
  CMatrix *v39; // r1
  const CVector *p_m_translate; // r0
  _BOOL4 IsLineOfSightClear; // r0
  CVector v42; // 0:r0.12
  CVector v43; // 0:r0.12

  pException = pVehicle;
  v5 = pVehicle == 0;
  if ( !pVehicle )
  {
    pException = pPed->m_pMyVehicle;
    v5 = pException == 0;
  }
  if ( !v5 )
  {
    m_pMat = pException->m_pMat;
    if ( m_pMat )
      m_heading = atan2f(COERCE_FLOAT(LODWORD(m_pMat->xy) ^ 0x80000000), m_pMat->yy);
    else
      m_heading = pException->m_transform.m_heading;
    v9 = pPed->m_pMat;
    pPed->m_fCurrentHeading = m_heading;
    pPed->m_fDesiredHeading = m_heading;
    if ( v9 )
      CMatrix::SetRotateZOnly(v9, m_heading);
    else
      pPed->m_transform.m_heading = m_heading;
    if ( pException->m_baseVehicleType == 5 )
    {
      if ( (pException->pHandling->mFlags & 0x400) != 0 )
      {
        p_xx = &pException->m_pMat->xx;
        v11 = p_xx[8];
        v12 = p_xx[9];
        v13 = p_xx[10];
        v14 = pPed->m_pMat;
        v15 = (float)(v12 * 0.5) + v14->ty;
        v16 = (float)(v13 * 0.5) + v14->tz;
        v14->tx = (float)(v11 * 0.5) + v14->tx;
        v14->ty = v15;
        v14->tz = v16;
      }
      if ( (*((int (__fastcall **)(CPed *, _DWORD))pPed->_vptr$CPlaceable + 14))(pPed, 0) != 1 )
      {
LABEL_21:
        v29 = pException->m_vecMoveSpeed.z * 0.9;
        v30 = pException->m_vecMoveSpeed.y * 0.9;
        v31 = pException->m_vecMoveSpeed.x * 0.9;
        m_pGroundPhysical = pPed->m_pGroundPhysical;
        *(_DWORD *)&pPed->m_nPedFlags |= 1u;
        pPed->m_vecMoveSpeed.x = v31;
        pPed->m_vecMoveSpeed.y = v30;
        pPed->m_vecMoveSpeed.z = v29 + -0.1;
        if ( !m_pGroundPhysical )
        {
          pPed->m_pGroundPhysical = pException;
          sub_196050(pException, &pPed->m_pGroundPhysical);
        }
        return;
      }
      v17 = pPed->m_pMat;
      if ( (*((_BYTE *)&pException->m_nVehicleFlags + 3) & 0x40) == 0 )
      {
        v18 = v17->ty - (float)(v17->yy * 0.3);
        v19 = v17->tz - (float)(v17->zy * 0.3);
        v17->tx = v17->tx - (float)(v17->xy * 0.3);
        v17->ty = v18;
        v17->tz = v19;
        if ( (*((int (__fastcall **)(CPed *, _DWORD))pPed->_vptr$CPlaceable + 14))(pPed, 0) == 1 )
        {
          v20 = pPed->m_pMat;
          v21 = (float)(v20->yy * 0.3) + v20->ty;
          v22 = (float)(v20->zy * 0.3) + v20->tz;
          v20->tx = (float)(v20->xy * 0.3) + v20->tx;
          v20->ty = v21;
          v20->tz = v22;
LABEL_39:
          CPed::PositionPedOutOfCollision(pPed, nDoor, pException, 1);
          return;
        }
        goto LABEL_21;
      }
      v17->tz = v17->tz + -0.3;
      if ( (*((int (__fastcall **)(CPed *, _DWORD))pPed->_vptr$CPlaceable + 14))(pPed, 0) == 1 )
      {
        pPed->m_pMat->tz = pPed->m_pMat->tz + 0.3;
        goto LABEL_39;
      }
    }
    else
    {
      p_m_transform = &pPed->m_transform;
      p_tx = &pPed->m_transform;
      CWorld::pIgnoreEntity = pException;
      v25 = pPed->m_pMat;
      if ( v25 )
        p_tx = (CSimpleTransform *)&v25->tx;
      z = p_tx->m_translate.z;
      *(_QWORD *)&v42.x = *(_QWORD *)&p_tx->m_translate.x;
      v42.z = z + -0.2;
      v27 = CWorld::TestSphereAgainstWorld(v42, 0.4, pException, 1, 1, 0, 0, 0, 0);
      if ( v27 )
        v28 = v27 != pException->m_pAttachToEntity;
      else
        v28 = 0;
      v33 = pPed->m_pMat;
      v34 = &pPed->m_transform;
      LOWORD(v35) = -13107;
      if ( v33 )
        v34 = (CSimpleTransform *)&v33->tx;
      HIWORD(v35) = 16076;
      v36 = v34->m_translate.z + 0.2;
      v43.x = v34->m_translate.x + 0.0;
      v43.y = v34->m_translate.y + 0.0;
      v43.z = v36;
      v37 = CWorld::TestSphereAgainstWorld(v43, v35, pException, 1, 1, 0, 0, 0, 0);
      if ( v37 )
        v28 |= v37 != pException->m_pAttachToEntity;
      v38 = pException->m_pMat;
      v39 = pPed->m_pMat;
      p_m_translate = (const CVector *)&v38->tx;
      if ( !v38 )
        p_m_translate = &pException->m_transform.m_translate;
      if ( v39 )
        p_m_transform = (CSimpleTransform *)&v39->tx;
      IsLineOfSightClear = CWorld::GetIsLineOfSightClear(
                             p_m_translate,
                             &p_m_transform->m_translate,
                             1,
                             0,
                             0,
                             1,
                             0,
                             0,
                             0);
      if ( v28 || !IsLineOfSightClear )
        CPed::PositionPedOutOfCollision(pPed, nDoor, pException, 1);
      CWorld::pIgnoreEntity = 0;
    }
  }
}

//----- (005040D4) --------------------------------------------------------
void __fastcall CTaskSimpleCarSlowDragPedOut::CTaskSimpleCarSlowDragPedOut(
        CTaskSimpleCarSlowDragPedOut *this,
        CVehicle *pTargetVehicle,
        const int iTargetDoor,
        CTaskUtilityLineUpPedWithCar *pUtility,
        const bool bQuitAfterDraggingPedOut)
{
  CTaskSimple::CTaskSimple(this);
  this->m_bIsFinished = 0;
  this->m_pAnim = 0;
  this->m_iTargetDoor = iTargetDoor;
  this->m_pUtility = pUtility;
  this->m_bQuitAfterDraggingPedOut = bQuitAfterDraggingPedOut;
  this->_vptr$CTask = (int (**)(void))&off_66B36C;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66B36C: using guessed type void *;

//----- (00504120) --------------------------------------------------------
void __fastcall CTaskSimpleCarSlowDragPedOut::~CTaskSimpleCarSlowDragPedOut(CTaskSimpleCarSlowDragPedOut *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CAnimBlendAssociation *m_pAnim; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B36C;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  sub_1A01F4(this);
}
// 66B36C: using guessed type void *off_66B36C;

//----- (00504160) --------------------------------------------------------
void __fastcall CTaskSimpleCarSlowDragPedOut::~CTaskSimpleCarSlowDragPedOut(CTaskSimpleCarSlowDragPedOut *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CAnimBlendAssociation *m_pAnim; // r0
  void *v5; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B36C;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v5);
}
// 504198: variable 'v5' is possibly undefined
// 66B36C: using guessed type void *off_66B36C;

//----- (005041A4) --------------------------------------------------------
bool __fastcall CTaskSimpleCarSlowDragPedOut::MakeAbortable(
        CTaskSimpleCarSlowDragPedOut *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0
  CVehicle *m_pTargetVehicle; // r0
  int m_iTargetDoor; // r1
  int v9; // r6
  int Group; // r0

  if ( iPriority != 2 )
    return 0;
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    m_pAnim->m_fBlendDelta = -1000.0;
  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( m_pTargetVehicle )
  {
    m_iTargetDoor = this->m_iTargetDoor;
    if ( (unsigned int)(m_iTargetDoor - 10) >= 2 )
    {
      if ( m_iTargetDoor == 18 )
        v9 = 366;
      else
        v9 = 365;
    }
    else
    {
      v9 = 364;
    }
    Group = CVehicleAnimGroup::GetGroup(
              &CVehicleAnimGroupData::m_vehicleAnimGroups[m_pTargetVehicle->pHandling->AnimGroup],
              v9);
    (*((void (__fastcall **)(CVehicle *, CPed *, int, int, int, int))this->m_pTargetVehicle->_vptr$CPlaceable + 29))(
      this->m_pTargetVehicle,
      pPed,
      this->m_iTargetDoor,
      Group,
      v9,
      1065353216);
  }
  return 1;
}

//----- (00504228) --------------------------------------------------------
void __fastcall CTaskSimpleCarSlowDragPedOut::ComputeAnimID(
        const CTaskSimpleCarSlowDragPedOut *this,
        int *animGroup,
        int *animID)
{
  unsigned int v4; // r1
  int v5; // r1

  v4 = this->m_iTargetDoor - 8;
  if ( v4 < 0xB && 0x40Fu >> v4 << 31 )
  {
    v5 = dword_504270[v4];
    *animID = v5;
  }
  else
  {
    v5 = *animID;
  }
  *animGroup = CVehicleAnimGroup::GetGroup(
                 &CVehicleAnimGroupData::m_vehicleAnimGroups[this->m_pTargetVehicle->pHandling->AnimGroup],
                 v5);
}
// 504270: using guessed type int dword_504270[2];

//----- (005042A0) --------------------------------------------------------
bool __fastcall CTaskSimpleCarSlowDragPedOut::ProcessPed(CTaskSimpleCarSlowDragPedOut *this, CPed *pPed)
{
  __int64 v4; // r0
  bool v5; // zf
  int v6; // r0
  int v7; // r6
  int v8; // r0
  int v9; // r6
  int Group; // r0
  CAnimBlendAssociation *v11; // r0
  CVehicle *m_pTargetVehicle; // r0
  int m_iTargetDoor; // r1
  CPed **v14; // r0
  CPed *v15; // r8
  unsigned int v16; // r6
  CAEVehicleAudioEntity *p_m_VehicleAudioEntity; // r9
  int VehicleTypeForAudio; // r0
  UInt16 v19; // r1
  UInt16 v20; // r1
  CAEVehicleAudioEntity *v21; // r6
  UInt16 v22; // r1
  int v23; // r0
  CPed *v24; // r0
  int IsPedFemaleForAudio; // r0

  if ( this->m_bIsFinished )
    goto LABEL_2;
  LODWORD(v4) = this->m_pTargetVehicle;
  if ( !(_DWORD)v4 )
    goto LABEL_2;
  HIDWORD(v4) = *(unsigned __int8 *)(*(_DWORD *)(v4 + 904) + 222);
  LOBYTE(v4) = 1;
  v5 = HIDWORD(v4) == 15;
  if ( HIDWORD(v4) != 15 )
    v5 = HIDWORD(v4) == 24;
  if ( !v5 )
  {
    LODWORD(v4) = this->m_iTargetDoor;
    if ( v4 != 0x1000000008LL )
    {
      if ( !this->m_pAnim )
      {
        if ( (unsigned int)(v4 - 10) >= 2 )
          v9 = (_DWORD)v4 == 18 ? 366 : 365;
        else
          v9 = 364;
        Group = CVehicleAnimGroup::GetGroup(&CVehicleAnimGroupData::m_vehicleAnimGroups[SWORD2(v4)], v9);
        v11 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, (AssocGroupId)Group, (AnimationId)v9, 1000.0);
        this->m_pAnim = v11;
        CAnimBlendAssociation::SetFinishCallback(v11, CTaskSimpleCarSlowDragPedOut::FinishAnimCarSlowDragPedOutCB, this);
        m_pTargetVehicle = this->m_pTargetVehicle;
        if ( m_pTargetVehicle )
        {
          m_iTargetDoor = this->m_iTargetDoor;
          v14 = m_iTargetDoor == 10 ? &m_pTargetVehicle->pDriver : &this->m_pTargetVehicle->pPassengers[CCarEnterExit::ComputePassengerIndexFromCarDoor(m_pTargetVehicle, m_iTargetDoor)];
          v15 = *v14;
          if ( *v14 )
          {
            v16 = rand() & 0x3FF;
            p_m_VehicleAudioEntity = &this->m_pTargetVehicle->m_VehicleAudioEntity;
            VehicleTypeForAudio = CAEVehicleAudioEntity::GetVehicleTypeForAudio(p_m_VehicleAudioEntity);
            if ( v16 <= 0x200 )
            {
              v20 = 119;
              if ( !VehicleTypeForAudio )
                v20 = 118;
              if ( (unsigned __int16)CPed::Say(v15, v20, 0, 1.0, 0, 0, 0) != 0xFFFF )
                goto LABEL_10;
              v21 = &this->m_pTargetVehicle->m_VehicleAudioEntity;
              if ( CAEVehicleAudioEntity::GetVehicleTypeForAudio(v21) == 1 )
              {
                v22 = 121;
              }
              else if ( CAEVehicleAudioEntity::GetVehicleTypeForAudio(v21) )
              {
                v22 = 124;
              }
              else
              {
                IsPedFemaleForAudio = CAEPedSpeechAudioEntity::IsPedFemaleForAudio(&v15->m_PedSpeechAudioEntity);
                v22 = 122;
                if ( !IsPedFemaleForAudio )
                  v22 = 123;
              }
              v24 = pPed;
            }
            else
            {
              if ( VehicleTypeForAudio == 1 )
              {
                v19 = 121;
              }
              else if ( CAEVehicleAudioEntity::GetVehicleTypeForAudio(p_m_VehicleAudioEntity) )
              {
                v19 = 124;
              }
              else
              {
                v23 = CAEPedSpeechAudioEntity::IsPedFemaleForAudio(&v15->m_PedSpeechAudioEntity);
                v19 = 122;
                if ( !v23 )
                  v19 = 123;
              }
              if ( (unsigned __int16)CPed::Say(pPed, v19, 0, 1.0, 0, 0, 0) != 0xFFFF )
                goto LABEL_10;
              v5 = CAEVehicleAudioEntity::GetVehicleTypeForAudio(&this->m_pTargetVehicle->m_VehicleAudioEntity) == 0;
              v22 = 119;
              v24 = v15;
              if ( v5 )
                v22 = 118;
            }
            CPed::Say(v24, v22, 0, 1.0, 0, 0, 0);
          }
        }
      }
LABEL_10:
      v6 = this->m_iTargetDoor;
      if ( (unsigned int)(v6 - 10) >= 2 )
      {
        if ( v6 == 18 )
          v7 = 366;
        else
          v7 = 365;
      }
      else
      {
        v7 = 364;
      }
      v8 = CVehicleAnimGroup::GetGroup(
             &CVehicleAnimGroupData::m_vehicleAnimGroups[this->m_pTargetVehicle->pHandling->AnimGroup],
             v7);
      (*((void (__fastcall **)(CVehicle *, CPed *, int, int, int, _DWORD))this->m_pTargetVehicle->_vptr$CPlaceable + 29))(
        this->m_pTargetVehicle,
        pPed,
        this->m_iTargetDoor,
        v8,
        v7,
        LODWORD(this->m_pAnim->m_fCurrentTime));
      LOBYTE(v4) = 0;
      return v4;
    }
LABEL_2:
    LOBYTE(v4) = 1;
  }
  return v4;
}

//----- (005044A8) --------------------------------------------------------
void __fastcall CTaskSimpleCarSlowDragPedOut::StartAnim(CTaskSimpleCarSlowDragPedOut *this, const CPed *pPed)
{
  int m_iTargetDoor; // r0
  int v5; // r6
  int Group; // r0
  CAnimBlendAssociation *v7; // r0

  m_iTargetDoor = this->m_iTargetDoor;
  if ( (unsigned int)(m_iTargetDoor - 10) >= 2 )
  {
    if ( m_iTargetDoor == 18 )
      v5 = 366;
    else
      v5 = 365;
  }
  else
  {
    v5 = 364;
  }
  Group = CVehicleAnimGroup::GetGroup(
            &CVehicleAnimGroupData::m_vehicleAnimGroups[this->m_pTargetVehicle->pHandling->AnimGroup],
            v5);
  v7 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, (AssocGroupId)Group, (AnimationId)v5, 1000.0);
  this->m_pAnim = v7;
  sub_18C19C(v7, CTaskSimpleCarSlowDragPedOut::FinishAnimCarSlowDragPedOutCB, this);
}

//----- (0050451C) --------------------------------------------------------
Bool8 __fastcall SayJacking(CPed *pJacker, CPed *pJackee, CVehicle *pVehicle, UInt32 StartTimeDelay)
{
  CAEVehicleAudioEntity *p_m_VehicleAudioEntity; // r4
  UInt16 v8; // r1
  int IsPedFemaleForAudio; // r0

  p_m_VehicleAudioEntity = &pVehicle->m_VehicleAudioEntity;
  if ( CAEVehicleAudioEntity::GetVehicleTypeForAudio(&pVehicle->m_VehicleAudioEntity) == 1 )
  {
    v8 = 121;
  }
  else if ( CAEVehicleAudioEntity::GetVehicleTypeForAudio(p_m_VehicleAudioEntity) )
  {
    v8 = 124;
  }
  else
  {
    IsPedFemaleForAudio = CAEPedSpeechAudioEntity::IsPedFemaleForAudio(&pJackee->m_PedSpeechAudioEntity);
    v8 = 122;
    if ( !IsPedFemaleForAudio )
      v8 = 123;
  }
  return CPed::Say(pJacker, v8, StartTimeDelay, 1.0, 0, 0, 0) != -1;
}

//----- (00504580) --------------------------------------------------------
Bool8 __fastcall SayJacked(CPed *pJackee, CVehicle *pVehicle, UInt32 StartTimeDelay)
{
  int VehicleTypeForAudio; // r0
  Bool8 v6; // r6
  UInt16 v7; // r1

  VehicleTypeForAudio = CAEVehicleAudioEntity::GetVehicleTypeForAudio(&pVehicle->m_VehicleAudioEntity);
  v6 = 0;
  v7 = 119;
  if ( !VehicleTypeForAudio )
    v7 = 118;
  if ( CPed::Say(pJackee, v7, StartTimeDelay, 1.0, 0, 0, 0) != -1 )
    return 1;
  return v6;
}

//----- (005045C4) --------------------------------------------------------
bool __fastcall CTaskSimpleCarSlowDragPedOut::SetPedPosition(CTaskSimpleCarSlowDragPedOut *this, CPed *pPed)
{
  CTaskUtilityLineUpPedWithCar::ProcessPed(this->m_pUtility, pPed, this->m_pTargetVehicle, this->m_pAnim);
  return 1;
}

//----- (005045D8) --------------------------------------------------------
void __fastcall CTaskSimpleCarSlowDragPedOut::FinishAnimCarSlowDragPedOutCB(CAnimBlendAssociation *pAnim, void *pData)
{
  int v3; // r0
  int v4; // r1
  int v5; // r6
  int Group; // r0
  int v7; // r0
  uint32 DoorStatus; // r0

  *((_DWORD *)pData + 3) = 0;
  v3 = *((_DWORD *)pData + 4);
  *((_BYTE *)pData + 8) = 1;
  if ( v3 )
  {
    v4 = *((_DWORD *)pData + 5);
    if ( (unsigned int)(v4 - 10) >= 2 )
    {
      if ( v4 == 18 )
        v5 = 366;
      else
        v5 = 365;
    }
    else
    {
      v5 = 364;
    }
    Group = CVehicleAnimGroup::GetGroup(
              &CVehicleAnimGroupData::m_vehicleAnimGroups[*(unsigned __int8 *)(*(_DWORD *)(v3 + 904) + 222)],
              v5);
    (*(void (__fastcall **)(_DWORD, _DWORD, _DWORD, int, int, int))(**((_DWORD **)pData + 4) + 116))(
      *((_DWORD *)pData + 4),
      0,
      *((_DWORD *)pData + 5),
      Group,
      v5,
      1065353216);
    v7 = *((_DWORD *)pData + 4);
    if ( v7
      && !*(_DWORD *)(v7 + 1440)
      && (!CDamageManager::GetDoorStatus((const CDamageManager *)(v7 + 1460), *((_DWORD *)pData + 5))
       || CDamageManager::GetDoorStatus((const CDamageManager *)(*((_DWORD *)pData + 4) + 1460), *((_DWORD *)pData + 5)) == 2) )
    {
      DoorStatus = CDamageManager::GetDoorStatus(
                     (const CDamageManager *)(*((_DWORD *)pData + 4) + 1460),
                     *((_DWORD *)pData + 5));
      sub_19FDAC((CDamageManager *)(*((_DWORD *)pData + 4) + 1460), *((_DWORD *)pData + 5), DoorStatus + 1);
    }
  }
}

//----- (00504694) --------------------------------------------------------
void __fastcall CTaskSimpleCarSlowBeDraggedOut::CTaskSimpleCarSlowBeDraggedOut(
        CTaskSimpleCarSlowBeDraggedOut *this,
        CVehicle *pTargetVehicle,
        const int iTargetDoor,
        CTaskUtilityLineUpPedWithCar *pUtility,
        const bool bDraggedBySelf)
{
  CTaskSimple::CTaskSimple(this);
  this->m_bIsFinished = 0;
  this->m_pAnim = 0;
  this->m_iTargetDoor = iTargetDoor;
  this->m_bDraggedBySelf = bDraggedBySelf;
  this->m_bFrontAnim = 0;
  this->m_pUtility = pUtility;
  this->_vptr$CTask = (int (**)(void))&off_66B3A0;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66B3A0: using guessed type void *;

//----- (005046E4) --------------------------------------------------------
void __fastcall CTaskSimpleCarSlowBeDraggedOut::~CTaskSimpleCarSlowBeDraggedOut(CTaskSimpleCarSlowBeDraggedOut *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CAnimBlendAssociation *m_pAnim; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B3A0;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  sub_1A01F4(this);
}
// 66B3A0: using guessed type void *off_66B3A0;

//----- (00504724) --------------------------------------------------------
void __fastcall CTaskSimpleCarSlowBeDraggedOut::~CTaskSimpleCarSlowBeDraggedOut(CTaskSimpleCarSlowBeDraggedOut *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CAnimBlendAssociation *m_pAnim; // r0
  void *v5; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B3A0;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v5);
}
// 50475C: variable 'v5' is possibly undefined
// 66B3A0: using guessed type void *off_66B3A0;

//----- (00504768) --------------------------------------------------------
bool __fastcall CTaskSimpleCarSlowBeDraggedOut::MakeAbortable(
        CTaskSimpleCarSlowBeDraggedOut *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0
  CVehicle *m_pTargetVehicle; // r0
  int v8; // r6
  CVehicleAnimGroup *v9; // r0
  int Group; // r0

  if ( iPriority != 2 )
    return 0;
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    m_pAnim->m_fBlendDelta = -1000.0;
  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( m_pTargetVehicle )
  {
    v8 = 379;
    v9 = &CVehicleAnimGroupData::m_vehicleAnimGroups[m_pTargetVehicle->pHandling->AnimGroup];
    if ( (this->m_iTargetDoor & 0xFFFFFFFE) == 10 )
      v8 = 378;
    Group = CVehicleAnimGroup::GetGroup(v9, v8);
    (*((void (__fastcall **)(CVehicle *, CPed *, int, int, int, int))this->m_pTargetVehicle->_vptr$CPlaceable + 29))(
      this->m_pTargetVehicle,
      pPed,
      this->m_iTargetDoor,
      Group,
      v8,
      1065353216);
  }
  return 1;
}

//----- (005047E0) --------------------------------------------------------
void __fastcall CTaskSimpleCarSlowBeDraggedOut::ComputeAnimID(
        const CTaskSimpleCarSlowBeDraggedOut *this,
        int *animGroup,
        int *animID)
{
  unsigned int v4; // r1
  int v5; // r1

  v4 = this->m_iTargetDoor - 8;
  if ( v4 >= 4 )
  {
    v5 = *animID;
  }
  else
  {
    v5 = dword_504818[v4];
    *animID = v5;
  }
  *animGroup = CVehicleAnimGroup::GetGroup(
                 &CVehicleAnimGroupData::m_vehicleAnimGroups[this->m_pTargetVehicle->pHandling->AnimGroup],
                 v5);
}
// 504818: using guessed type int dword_504818[4];

//----- (0050482C) --------------------------------------------------------
bool __fastcall CTaskSimpleCarSlowBeDraggedOut::ProcessPed(CTaskSimpleCarSlowBeDraggedOut *this, CPed *pPed)
{
  AnimationId v4; // r2
  bool v5; // r4
  CAnimBlendAssociation *m_pAnim; // r0
  __int64 v8; // r0
  int v9; // r6
  __int16 v10; // r0
  int v11; // r0
  CAnimBlendAssociation *v12; // r0
  __int64 v13; // r0
  int v14; // r6
  __int16 v15; // r0
  int Group; // r0

  if ( !this->m_pTargetVehicle )
    return 1;
  if ( !this->m_bIsFinished )
  {
    m_pAnim = this->m_pAnim;
    if ( m_pAnim )
    {
      if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
        return 1;
      if ( m_pAnim->m_fCurrentTime > 1.7 )
        this->m_pUtility->m_nZFlag = 2;
      if ( this->m_bDraggedBySelf )
      {
        v13 = *(_QWORD *)&this->m_pTargetVehicle;
        v14 = 379;
        v15 = *(unsigned __int8 *)(*(_DWORD *)(v13 + 904) + 222);
        if ( (HIDWORD(v13) & 0xFFFFFFFE) == 10 )
          v14 = 378;
        Group = CVehicleAnimGroup::GetGroup(&CVehicleAnimGroupData::m_vehicleAnimGroups[v15], v14);
        (*((void (__fastcall **)(CVehicle *, CPed *, int, int, int, _DWORD))this->m_pTargetVehicle->_vptr$CPlaceable + 29))(
          this->m_pTargetVehicle,
          pPed,
          this->m_iTargetDoor,
          Group,
          v14,
          LODWORD(this->m_pAnim->m_fCurrentTime));
      }
    }
    else
    {
      CCarEnterExit::RemoveCarSitAnim(pPed);
      v8 = *(_QWORD *)&this->m_pTargetVehicle;
      v9 = 379;
      v10 = *(unsigned __int8 *)(*(_DWORD *)(v8 + 904) + 222);
      if ( (HIDWORD(v8) & 0xFFFFFFFE) == 10 )
        v9 = 378;
      v11 = CVehicleAnimGroup::GetGroup(&CVehicleAnimGroupData::m_vehicleAnimGroups[v10], v9);
      v12 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, (AssocGroupId)v11, (AnimationId)v9, 1000.0);
      this->m_pAnim = v12;
      CAnimBlendAssociation::SetFinishCallback(
        v12,
        CTaskSimpleCarSlowBeDraggedOut::FinishAnimCarSlowBeDraggedOutCB,
        this);
      this->m_bFrontAnim = (this->m_pAnim->m_bitsFlag & 0x800) != 0;
    }
    return 0;
  }
  if ( RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x27u)
    || RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x24u) )
  {
    return 1;
  }
  if ( this->m_bFrontAnim )
    v4 = ANIM_STD_HIT_FLOOR_FRONT;
  else
    v4 = ANIM_STD_HIT_FLOOR;
  v5 = 0;
  CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, v4, 1000.0);
  return v5;
}

//----- (00504964) --------------------------------------------------------
void __fastcall CTaskSimpleCarSlowBeDraggedOut::StartAnim(CTaskSimpleCarSlowBeDraggedOut *this, const CPed *pPed)
{
  __int64 v4; // r0
  int v5; // r6
  __int16 v6; // r0
  int Group; // r0
  CAnimBlendAssociation *v8; // r0

  CCarEnterExit::RemoveCarSitAnim(pPed);
  v4 = *(_QWORD *)&this->m_pTargetVehicle;
  v5 = 379;
  v6 = *(unsigned __int8 *)(*(_DWORD *)(v4 + 904) + 222);
  if ( (HIDWORD(v4) & 0xFFFFFFFE) == 10 )
    v5 = 378;
  Group = CVehicleAnimGroup::GetGroup(&CVehicleAnimGroupData::m_vehicleAnimGroups[v6], v5);
  v8 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, (AssocGroupId)Group, (AnimationId)v5, 1000.0);
  this->m_pAnim = v8;
  CAnimBlendAssociation::SetFinishCallback(v8, CTaskSimpleCarSlowBeDraggedOut::FinishAnimCarSlowBeDraggedOutCB, this);
  this->m_bFrontAnim = (this->m_pAnim->m_bitsFlag & 0x800) != 0;
}

//----- (005049DC) --------------------------------------------------------
bool __fastcall CTaskSimpleCarSlowBeDraggedOut::SetPedPosition(CTaskSimpleCarSlowBeDraggedOut *this, CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r2
  CAnimBlendAssociation *m_pAnim; // r3
  uint32 v6; // r6
  CAnimBlendAssociation *Association; // r3

  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( m_pTargetVehicle )
  {
    m_pAnim = this->m_pAnim;
    if ( !this->m_bIsFinished )
    {
      if ( !m_pAnim )
      {
        CPed::SetPedPositionInCar(pPed);
        return 1;
      }
      goto LABEL_4;
    }
    if ( m_pAnim )
    {
LABEL_4:
      CTaskUtilityLineUpPedWithCar::ProcessPed(this->m_pUtility, pPed, m_pTargetVehicle, m_pAnim);
      return 1;
    }
    v6 = 379;
    if ( (this->m_iTargetDoor & 0xFFFFFFFE) == 10 )
      v6 = 378;
    CVehicleAnimGroup::GetGroup(&CVehicleAnimGroupData::m_vehicleAnimGroups[m_pTargetVehicle->pHandling->AnimGroup], v6);
    Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, v6);
    this->m_pAnim = Association;
    if ( Association )
      CTaskUtilityLineUpPedWithCar::ProcessPed(this->m_pUtility, pPed, this->m_pTargetVehicle, Association);
    this->m_pAnim = 0;
  }
  return 1;
}

//----- (00504A70) --------------------------------------------------------
void __fastcall CTaskSimpleCarSlowBeDraggedOut::FinishAnimCarSlowBeDraggedOutCB(
        CAnimBlendAssociation *pAnim,
        void *pData)
{
  *((_DWORD *)pData + 3) = 0;
  *((_BYTE *)pData + 8) = 1;
}

//----- (00504A7C) --------------------------------------------------------
void __fastcall CTaskSimpleCarSetPedSlowDraggedOut::CTaskSimpleCarSetPedSlowDraggedOut(
        CTaskSimpleCarSetPedSlowDraggedOut *this,
        CVehicle *pTargetVehicle,
        const int iTargetDoor)
{
  CTaskSimple::CTaskSimple(this);
  this->m_iTargetDoor = iTargetDoor;
  this->_vptr$CTask = (int (**)(void))&off_66B3D4;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66B3D4: using guessed type void *;

//----- (00504AB8) --------------------------------------------------------
void __fastcall CTaskSimpleCarSetPedSlowDraggedOut::~CTaskSimpleCarSetPedSlowDraggedOut(
        CTaskSimpleCarSetPedSlowDraggedOut *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B3D4;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  sub_1A01F4(this);
}
// 66B3D4: using guessed type void *off_66B3D4;

//----- (00504AE4) --------------------------------------------------------
void __fastcall CTaskSimpleCarSetPedSlowDraggedOut::~CTaskSimpleCarSetPedSlowDraggedOut(
        CTaskSimpleCarSetPedSlowDraggedOut *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  void *v4; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B3D4;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  CTask::~CTask(this);
  sub_197118(v4);
}
// 504B0C: variable 'v4' is possibly undefined
// 66B3D4: using guessed type void *off_66B3D4;

//----- (00504B14) --------------------------------------------------------
bool __fastcall CTaskSimpleCarSetPedSlowDraggedOut::ProcessPed(CTaskSimpleCarSetPedSlowDraggedOut *this, CPed *pPed)
{
  CVehicle *m_pMyVehicle; // r0
  bool v5; // zf
  CVehicle *m_pTargetVehicle; // r0
  int v7; // r6
  CVehicle *v8; // r0
  CPedIntelligence *m_pPedIntelligence; // r8
  CTaskSimplePlayerOnFoot *v10; // r6
  CTaskManager *p_m_taskManager; // r0
  CTaskComplexWander *WanderTaskByPedType; // r1
  CMatrix *m_pMat; // r8
  float x; // s16
  float y; // s18
  int v16; // r2
  CMatrix *v17; // r0
  CSimpleTransform *p_tx; // r1
  float v19; // s8
  float z; // s10
  CMatrix *v21; // r1
  float v22; // r2
  RwReal v23; // r0
  float *p_tz; // r1
  CVehicle *v25; // r0
  CMatrix *v26; // r1
  float m_heading; // s0
  int (**v28)(void); // r0
  CVector v30; // [sp+8h] [bp-48h] BYREF
  CVector v; // [sp+18h] [bp-38h] BYREF

  m_pMyVehicle = pPed->m_pMyVehicle;
  v5 = m_pMyVehicle == 0;
  if ( m_pMyVehicle )
  {
    m_pMyVehicle = this->m_pTargetVehicle;
    v5 = m_pMyVehicle == 0;
  }
  if ( !v5 )
  {
    CCarEnterExit::ComputeDoorFlag(m_pMyVehicle, this->m_iTargetDoor, 1);
    m_pTargetVehicle = this->m_pTargetVehicle;
    if ( m_pTargetVehicle->pDriver == pPed )
    {
      CVehicle::RemoveDriver(m_pTargetVehicle, 1);
      v8 = this->m_pTargetVehicle;
      if ( v8->m_eDoorLockState == CARLOCK_LOCKED_INITIALLY )
        v8->m_eDoorLockState = CARLOCK_UNLOCKED;
      if ( pPed->m_nPedType == 6 && CVehicle::IsLawEnforcementVehicle(this->m_pTargetVehicle) )
        CVehicle::ChangeLawEnforcerState(this->m_pTargetVehicle, 0);
    }
    else if ( m_pTargetVehicle->m_nMaxPassengers )
    {
      v7 = 0;
      do
      {
        if ( m_pTargetVehicle->pPassengers[v7] == pPed )
        {
          CVehicle::RemovePassenger(m_pTargetVehicle, pPed);
          m_pTargetVehicle = this->m_pTargetVehicle;
        }
        ++v7;
      }
      while ( v7 < m_pTargetVehicle->m_nMaxPassengers );
    }
    *(_DWORD *)&pPed->m_nPedFlags &= ~0x100u;
    if ( CPed::IsPlayer(pPed) )
    {
      m_pPedIntelligence = pPed->m_pPedIntelligence;
      v10 = (CTaskSimplePlayerOnFoot *)CTask::operator new(0x34u);
      CTaskSimplePlayerOnFoot::CTaskSimplePlayerOnFoot(v10);
    }
    else
    {
      m_pPedIntelligence = pPed->m_pPedIntelligence;
      if ( pPed->CharCreatedBy != 2 )
      {
        WanderTaskByPedType = CTaskComplexWander::GetWanderTaskByPedType(pPed);
        p_m_taskManager = &m_pPedIntelligence->m_taskManager;
        goto LABEL_22;
      }
      v10 = (CTaskSimplePlayerOnFoot *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(
        (CTaskSimpleStandStill *)v10,
        (const int)"List_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly",
        1,
        0,
        8.0);
    }
    p_m_taskManager = &m_pPedIntelligence->m_taskManager;
    WanderTaskByPedType = (CTaskComplexWander *)v10;
LABEL_22:
    CTaskManager::SetTask(p_m_taskManager, WanderTaskByPedType, 4, 0);
    CPed::RestartNonPartialAnims(pPed);
    *(_DWORD *)&pPed->m_nFlags |= 1u;
    CPed::UpdateStatLeavingVehicle(pPed);
    CPed::ReplaceWeaponWhenExitingVehicle(pPed);
    m_pMat = pPed->m_pMat;
    x = CCarEnterExit::ms_vecPedGetUpAnimOffset.x;
    y = CCarEnterExit::ms_vecPedGetUpAnimOffset.y;
    if ( (this->m_iTargetDoor & 0xFFFFFFFE) == 8 )
      v16 = 6;
    else
      v16 = 5;
    CVehicleAnimGroup::ComputeAnimDoorOffsets(
      &v30,
      &CVehicleAnimGroupData::m_vehicleAnimGroups[this->m_pTargetVehicle->pHandling->AnimGroup],
      v16);
    v.x = v30.x - x;
    v.z = 0.0;
    v.y = v30.y - y;
    Multiply3x3(&v30, m_pMat, &v);
    v17 = pPed->m_pMat;
    p_tx = (CSimpleTransform *)&v17->tx;
    if ( !v17 )
      p_tx = &pPed->m_transform;
    v19 = p_tx->m_translate.y;
    z = p_tx->m_translate.z;
    v30.x = p_tx->m_translate.x + v30.x;
    v30.y = v19 + v30.y;
    v30.z = z + v30.z;
    CPedPlacement::FindZCoorForPed(&v30);
    v21 = pPed->m_pMat;
    pPed->m_vecMoveSpeed.x = 0.0;
    pPed->m_vecMoveSpeed.y = 0.0;
    pPed->m_vecMoveSpeed.z = 0.0;
    v22 = v30.y;
    v23 = v30.z;
    if ( v21 )
    {
      v21->tx = v30.x;
      pPed->m_pMat->ty = v22;
      p_tz = &pPed->m_pMat->tz;
    }
    else
    {
      p_tz = &pPed->m_transform.m_translate.z;
      pPed->m_transform.m_translate.x = v30.x;
      pPed->m_transform.m_translate.y = v22;
    }
    *p_tz = v23;
    v25 = this->m_pTargetVehicle;
    v26 = v25->m_pMat;
    if ( v26 )
      m_heading = atan2f(COERCE_FLOAT(LODWORD(v26->xy) ^ 0x80000000), v26->yy);
    else
      m_heading = v25->m_transform.m_heading;
    pPed->m_fCurrentHeading = m_heading;
    pPed->m_fDesiredHeading = m_heading;
    CPed::CalculateNewOrientation(pPed);
    if ( !CCarEnterExit::IsRoomForPedToLeaveCar(this->m_pTargetVehicle, this->m_iTargetDoor, &v) )
      CPed::PositionPedOutOfCollision(pPed, this->m_iTargetDoor, this->m_pTargetVehicle, 1);
    *((_DWORD *)&pPed->m_nPedFlags + 2) |= 8u;
    CPed::SetPedState(pPed, PED_IDLE);
    v28 = pPed->_vptr$CPlaceable;
    pPed->m_eMoveStateAnim = PEDMOVE_STILL;
    ((void (__fastcall *)(CPed *))v28[24])(pPed);
  }
  return 1;
}

//----- (00504DA8) --------------------------------------------------------
void __fastcall CTaskComplexCarSlowBeDraggedOut::CTaskComplexCarSlowBeDraggedOut(
        CTaskComplexCarSlowBeDraggedOut *this,
        CVehicle *pTargetVehicle,
        const int iTargetDoor,
        const bool bDraggedBySelf)
{
  CTaskComplex::CTaskComplex(this);
  this->m_iTargetDoor = iTargetDoor;
  this->m_bDraggedBySelf = bDraggedBySelf;
  this->m_pTaskUtilityLineUpPedWithCar = 0;
  this->_vptr$CTask = (int (**)(void))&off_66B408;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66B408: using guessed type void *;

//----- (00504DF0) --------------------------------------------------------
void __fastcall CTaskComplexCarSlowBeDraggedOut::~CTaskComplexCarSlowBeDraggedOut(
        CTaskComplexCarSlowBeDraggedOut *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CTaskUtilityLineUpPedWithCar *m_pTaskUtilityLineUpPedWithCar; // r0
  void *v5; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B408;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pTaskUtilityLineUpPedWithCar = this->m_pTaskUtilityLineUpPedWithCar;
  if ( m_pTaskUtilityLineUpPedWithCar )
  {
    CTaskUtilityLineUpPedWithCar::~CTaskUtilityLineUpPedWithCar(m_pTaskUtilityLineUpPedWithCar);
    operator delete(v5);
  }
  sub_18EDB4(this);
}
// 504E16: variable 'v5' is possibly undefined
// 66B408: using guessed type void *off_66B408;

//----- (00504E28) --------------------------------------------------------
void __fastcall CTaskComplexCarSlowBeDraggedOut::~CTaskComplexCarSlowBeDraggedOut(
        CTaskComplexCarSlowBeDraggedOut *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CTaskUtilityLineUpPedWithCar *m_pTaskUtilityLineUpPedWithCar; // r0
  void *v5; // r0
  void *v6; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B408;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pTaskUtilityLineUpPedWithCar = this->m_pTaskUtilityLineUpPedWithCar;
  if ( m_pTaskUtilityLineUpPedWithCar )
  {
    CTaskUtilityLineUpPedWithCar::~CTaskUtilityLineUpPedWithCar(m_pTaskUtilityLineUpPedWithCar);
    operator delete(v5);
  }
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v6);
}
// 504E4E: variable 'v5' is possibly undefined
// 504E5C: variable 'v6' is possibly undefined
// 66B408: using guessed type void *off_66B408;

//----- (00504E64) --------------------------------------------------------
bool __fastcall CTaskComplexCarSlowBeDraggedOut::MakeAbortable(
        CTaskComplexCarSlowBeDraggedOut *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  __int64 v6; // kr00_8
  int v7; // r0
  CEntity **v8; // r5
  CTaskSimpleCarSetPedSlowDraggedOut v10[2]; // [sp+0h] [bp-20h] BYREF

  if ( iPriority != 2 )
    return 0;
  (*((void (__fastcall **)(CTask *, CPed *, int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
    this->m_pSubTask,
    pPed,
    2,
    pEvent);
  v6 = *(_QWORD *)&this->m_pTargetVehicle;
  CTaskSimple::CTaskSimple(v10);
  *(_QWORD *)&v10[0].m_pTargetVehicle = v6;
  v10[0]._vptr$CTask = (int (**)(void))&off_66B3D4;
  v8 = (CEntity **)(v7 + 8);
  if ( (_DWORD)v6 )
    CEntity::RegisterReference((CEntity *)v6, v8);
  CTaskSimpleCarSetPedSlowDraggedOut::ProcessPed(v10, pPed);
  v10[0]._vptr$CTask = (int (**)(void))&off_66B3D4;
  if ( v10[0].m_pTargetVehicle )
    CEntity::CleanUpOldReference(v10[0].m_pTargetVehicle, v8);
  CTask::~CTask(v10);
  return 1;
}
// 504E9E: variable 'v7' is possibly undefined
// 66B3D4: using guessed type void *off_66B3D4;

//----- (00504EE8) --------------------------------------------------------
CTask *__fastcall CTaskComplexCarSlowBeDraggedOut::CreateSubTask(
        CTaskComplexCarSlowBeDraggedOut *this,
        const int iSubTaskType)
{
  char *v3; // r4
  CTaskSimple *v4; // r0
  CVehicle *m_pTargetVehicle; // r6
  int m_iTargetDoor; // r8
  bool m_bDraggedBySelf; // r5
  char *v8; // r0
  CTaskSimple *v9; // r0
  int v10; // r8
  CTaskUtilityLineUpPedWithCar *m_pTaskUtilityLineUpPedWithCar; // r9
  bool v12; // r5
  char *v13; // r0
  int v14; // r5
  __int64 v15; // kr10_8
  CEntity **v16; // r1
  CTaskSimple *v17; // r0
  int v18; // r8
  CTaskUtilityLineUpPedWithCar *v19; // r5

  v3 = 0;
  switch ( iSubTaskType )
  {
    case 816:
      v4 = (CTaskSimple *)CTask::operator new(0x18u);
      m_iTargetDoor = this->m_iTargetDoor;
      m_pTargetVehicle = this->m_pTargetVehicle;
      v3 = (char *)v4;
      m_bDraggedBySelf = this->m_bDraggedBySelf;
      CTaskSimple::CTaskSimple(v4);
      *((_DWORD *)v3 + 3) = m_iTargetDoor;
      v3[16] = !m_bDraggedBySelf;
      v8 = (char *)&`vtable for'CTaskSimpleCarSetPedOut;
      v3[21] = 0;
      *(_DWORD *)(v3 + 17) = 0;
      goto LABEL_5;
    case 821:
      v9 = (CTaskSimple *)CTask::operator new(0x20u);
      v10 = this->m_iTargetDoor;
      m_pTargetVehicle = this->m_pTargetVehicle;
      v3 = (char *)v9;
      m_pTaskUtilityLineUpPedWithCar = this->m_pTaskUtilityLineUpPedWithCar;
      v12 = this->m_bDraggedBySelf;
      CTaskSimple::CTaskSimple(v9);
      v3[8] = 0;
      *((_DWORD *)v3 + 3) = 0;
      *((_DWORD *)v3 + 5) = v10;
      v3[24] = v12;
      v3[25] = 0;
      v13 = (char *)&`vtable for'CTaskSimpleCarSlowBeDraggedOut;
      *((_DWORD *)v3 + 7) = m_pTaskUtilityLineUpPedWithCar;
      goto LABEL_7;
    case 822:
      v3 = (char *)CTask::operator new(0x10u);
      v15 = *(_QWORD *)&this->m_pTargetVehicle;
      v14 = this->m_iTargetDoor;
      m_pTargetVehicle = (CVehicle *)v15;
      CTaskSimple::CTaskSimple((CTaskSimple *)v3);
      *((_DWORD *)v3 + 3) = v14;
      v8 = (char *)&`vtable for'CTaskSimpleCarSetPedSlowDraggedOut;
LABEL_5:
      *(_DWORD *)v3 = v8 + 8;
      *((_DWORD *)v3 + 2) = m_pTargetVehicle;
      v16 = (CEntity **)(v3 + 8);
      goto LABEL_8;
    case 834:
      v17 = (CTaskSimple *)CTask::operator new(0x1Cu);
      v18 = this->m_iTargetDoor;
      m_pTargetVehicle = this->m_pTargetVehicle;
      v3 = (char *)v17;
      v19 = this->m_pTaskUtilityLineUpPedWithCar;
      CTaskSimple::CTaskSimple(v17);
      v3[8] = 0;
      *((_DWORD *)v3 + 3) = 0;
      *((_DWORD *)v3 + 5) = v18;
      *((_DWORD *)v3 + 6) = v19;
      v13 = (char *)&`vtable for'CTaskSimpleCarFallOut;
LABEL_7:
      *(_DWORD *)v3 = v13 + 8;
      *((_DWORD *)v3 + 4) = m_pTargetVehicle;
      v16 = (CEntity **)(v3 + 16);
LABEL_8:
      if ( m_pTargetVehicle )
        CEntity::RegisterReference(m_pTargetVehicle, v16);
      break;
    default:
      return (CTask *)v3;
  }
  return (CTask *)v3;
}

//----- (00504FE4) --------------------------------------------------------
CTask *__fastcall CTaskComplexCarSlowBeDraggedOut::CreateNextSubTask(CTaskComplexCarSlowBeDraggedOut *this, CPed *pPed)
{
  int v3; // r0
  void *v4; // r4
  __int64 v5; // kr00_8
  CTaskSimple *v7; // r0
  __int64 v8; // r8
  CTaskSimple *v9; // r6
  bool m_bDraggedBySelf; // r5

  if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) || !pPed->m_pMyVehicle )
    return 0;
  v3 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  v4 = 0;
  if ( v3 == 834 )
  {
    v7 = (CTaskSimple *)CTask::operator new(0x18u);
    v8 = *(_QWORD *)&this->m_pTargetVehicle;
    v9 = v7;
    m_bDraggedBySelf = this->m_bDraggedBySelf;
    CTaskSimple::CTaskSimple(v7);
    v9[1].m_pParent = (CTask *)HIDWORD(v8);
    LOBYTE(v9[2]._vptr$CTask) = !m_bDraggedBySelf;
    BYTE1(v9[2].m_pParent) = 0;
    *(int (***)(void))((char *)&v9[2]._vptr$CTask + 1) = 0;
    v9->_vptr$CTask = (int (**)(void))&off_66B338;
    v9[1]._vptr$CTask = (int (**)(void))v8;
    if ( (_DWORD)v8 )
      CEntity::RegisterReference((CEntity *)v8, (CEntity **)&v9[1]);
    return v9;
  }
  else if ( v3 == 821 )
  {
    v4 = CTask::operator new(0x10u);
    v5 = *(_QWORD *)&this->m_pTargetVehicle;
    CTaskSimple::CTaskSimple((CTaskSimple *)v4);
    *((_DWORD *)v4 + 3) = HIDWORD(v5);
    *(_DWORD *)v4 = &off_66B3D4;
    *((_DWORD *)v4 + 2) = v5;
    if ( (_DWORD)v5 )
      CEntity::RegisterReference((CEntity *)v5, (CEntity **)v4 + 2);
  }
  return (CTask *)v4;
}
// 66B338: using guessed type void *off_66B338;
// 66B3D4: using guessed type void *off_66B3D4;

//----- (0050509C) --------------------------------------------------------
CTask *__fastcall CTaskComplexCarSlowBeDraggedOut::CreateFirstSubTask(
        CTaskComplexCarSlowBeDraggedOut *this,
        CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r1
  const CPed *pDriver; // r0
  _BOOL4 IsPlayer; // r0
  char v7; // r2
  CTaskSimple *v8; // r5
  CMatrix *m_pMat; // r0
  float tx; // s16
  float ty; // s18
  float tz; // s20
  CMatrix *v13; // r0
  float v14; // s2
  float v15; // s4
  CTaskUtilityLineUpPedWithCar *v16; // r0
  CTaskUtilityLineUpPedWithCar *v17; // r0
  CTaskSimple *v18; // r0
  CVehicle *v19; // r6
  int m_iTargetDoor; // r9
  CTaskUtilityLineUpPedWithCar *m_pTaskUtilityLineUpPedWithCar; // r4
  char *v22; // r0
  CTaskSimple *v23; // r0
  int v24; // r9
  CTaskUtilityLineUpPedWithCar *v25; // r10
  bool m_bDraggedBySelf; // r4
  CVector vInitialBlendVector; // [sp+4h] [bp-3Ch] BYREF

  if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) || !pPed->m_pMyVehicle )
    return 0;
  if ( this->m_iTargetDoor == 10 )
  {
    m_pTargetVehicle = this->m_pTargetVehicle;
    pDriver = m_pTargetVehicle->pDriver;
    if ( pDriver )
    {
      IsPlayer = CPed::IsPlayer(pDriver);
      m_pTargetVehicle = this->m_pTargetVehicle;
      v7 = 32;
      if ( IsPlayer )
        v7 = 72;
    }
    else
    {
      v7 = 32;
    }
    m_pTargetVehicle->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&m_pTargetVehicle->m_info & 7 | v7);
  }
  m_pMat = pPed->m_pMat;
  if ( m_pMat )
  {
    tx = m_pMat->tx;
    ty = m_pMat->ty;
    tz = m_pMat->tz;
    CMatrix::SetRotate(m_pMat, 0.0, 0.0, pPed->m_fCurrentHeading);
    v13 = pPed->m_pMat;
    v14 = ty + v13->ty;
    v15 = tz + v13->tz;
    v13->tx = tx + v13->tx;
    v13->ty = v14;
    v13->tz = v15;
  }
  else
  {
    pPed->m_transform.m_heading = pPed->m_fCurrentHeading;
  }
  CPed::SetPedState(pPed, PED_NONE);
  memset(&vInitialBlendVector, 0, sizeof(vInitialBlendVector));
  v16 = (CTaskUtilityLineUpPedWithCar *)operator new(0x1Cu);
  CTaskUtilityLineUpPedWithCar::CTaskUtilityLineUpPedWithCar(v16, &vInitialBlendVector, 0, 0, this->m_iTargetDoor);
  this->m_pTaskUtilityLineUpPedWithCar = v17;
  if ( this->m_bDraggedBySelf )
  {
    v18 = (CTaskSimple *)CTask::operator new(0x1Cu);
    m_iTargetDoor = this->m_iTargetDoor;
    v19 = this->m_pTargetVehicle;
    v8 = v18;
    m_pTaskUtilityLineUpPedWithCar = this->m_pTaskUtilityLineUpPedWithCar;
    CTaskSimple::CTaskSimple(v18);
    LOBYTE(v8[1]._vptr$CTask) = 0;
    v8[1].m_pParent = 0;
    v8[2].m_pParent = (CTask *)m_iTargetDoor;
    v8[3]._vptr$CTask = (int (**)(void))m_pTaskUtilityLineUpPedWithCar;
    v22 = (char *)&`vtable for'CTaskSimpleCarFallOut;
  }
  else
  {
    v23 = (CTaskSimple *)CTask::operator new(0x20u);
    v24 = this->m_iTargetDoor;
    v19 = this->m_pTargetVehicle;
    v8 = v23;
    v25 = this->m_pTaskUtilityLineUpPedWithCar;
    m_bDraggedBySelf = this->m_bDraggedBySelf;
    CTaskSimple::CTaskSimple(v23);
    LOBYTE(v8[1]._vptr$CTask) = 0;
    v8[1].m_pParent = 0;
    v8[2].m_pParent = (CTask *)v24;
    v22 = (char *)&`vtable for'CTaskSimpleCarSlowBeDraggedOut;
    LOBYTE(v8[3]._vptr$CTask) = m_bDraggedBySelf;
    BYTE1(v8[3]._vptr$CTask) = 0;
    v8[3].m_pParent = (CTask *)v25;
  }
  v8->_vptr$CTask = (int (**)(void))(v22 + 8);
  v8[2]._vptr$CTask = (int (**)(void))v19;
  if ( v19 )
    CEntity::RegisterReference(v19, (CEntity **)&v8[2]);
  return v8;
}
// 505166: variable 'v17' is possibly undefined

//----- (005051F0) --------------------------------------------------------
void __fastcall CTaskComplexCarSlowBeDraggedOut::PrepareVehicleForPedExit(
        CTaskComplexCarSlowBeDraggedOut *this,
        CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r1
  const CPed *pDriver; // r0
  _BOOL4 IsPlayer; // r0
  char v6; // r2

  if ( this->m_iTargetDoor == 10 )
  {
    m_pTargetVehicle = this->m_pTargetVehicle;
    pDriver = m_pTargetVehicle->pDriver;
    if ( pDriver )
    {
      IsPlayer = CPed::IsPlayer(pDriver);
      m_pTargetVehicle = this->m_pTargetVehicle;
      v6 = 32;
      if ( IsPlayer )
        v6 = 72;
    }
    else
    {
      v6 = 32;
    }
    m_pTargetVehicle->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&m_pTargetVehicle->m_info & 7 | v6);
  }
}

//----- (00505228) --------------------------------------------------------
void __fastcall CTaskComplexCarSlowBeDraggedOut::PreparePedForVehicleExit(
        CTaskComplexCarSlowBeDraggedOut *this,
        CPed *pPed)
{
  CMatrix *m_pMat; // r0
  float tx; // s16
  float ty; // s18
  float tz; // s20
  CMatrix *v7; // r0
  float v8; // s2
  float v9; // s4

  m_pMat = pPed->m_pMat;
  if ( m_pMat )
  {
    tx = m_pMat->tx;
    ty = m_pMat->ty;
    tz = m_pMat->tz;
    CMatrix::SetRotate(m_pMat, 0.0, 0.0, pPed->m_fCurrentHeading);
    v7 = pPed->m_pMat;
    v8 = ty + v7->ty;
    v9 = tz + v7->tz;
    v7->tx = tx + v7->tx;
    v7->ty = v8;
    v7->tz = v9;
  }
  else
  {
    pPed->m_transform.m_heading = pPed->m_fCurrentHeading;
  }
  sub_18D8EC(pPed, PED_NONE);
}

//----- (00505292) --------------------------------------------------------
void __fastcall CTaskComplexCarSlowBeDraggedOut::CreateTaskUtilityLineUpPedWithCar(
        CTaskComplexCarSlowBeDraggedOut *this,
        CPed *pPed)
{
  CTaskUtilityLineUpPedWithCar *v3; // r0
  CTaskUtilityLineUpPedWithCar *v4; // r0
  CVector vInitialBlendVector; // [sp+4h] [bp-14h] BYREF

  memset(&vInitialBlendVector, 0, sizeof(vInitialBlendVector));
  v3 = (CTaskUtilityLineUpPedWithCar *)operator new(0x1Cu);
  CTaskUtilityLineUpPedWithCar::CTaskUtilityLineUpPedWithCar(v3, &vInitialBlendVector, 0, 0, this->m_iTargetDoor);
  this->m_pTaskUtilityLineUpPedWithCar = v4;
}
// 5052B6: variable 'v4' is possibly undefined

//----- (005052BC) --------------------------------------------------------
CTask *__fastcall CTaskComplexCarSlowBeDraggedOut::ControlSubTask(CTaskComplexCarSlowBeDraggedOut *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (005052C0) --------------------------------------------------------
void __fastcall CTaskComplexCarSlowBeDraggedOutAndStandUp::CTaskComplexCarSlowBeDraggedOutAndStandUp(
        CTaskComplexCarSlowBeDraggedOutAndStandUp *this,
        CVehicle *pTargetVehicle,
        const int iTargetDoor)
{
  CTaskComplex::CTaskComplex(this);
  this->m_iTargetDoor = iTargetDoor;
  this->_vptr$CTask = (int (**)(void))&off_66B444;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66B444: using guessed type void *;

//----- (005052FC) --------------------------------------------------------
void __fastcall CTaskComplexCarSlowBeDraggedOutAndStandUp::~CTaskComplexCarSlowBeDraggedOutAndStandUp(
        CTaskComplexCarSlowBeDraggedOutAndStandUp *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B444;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  sub_18EDB4(this);
}
// 66B444: using guessed type void *off_66B444;

//----- (00505328) --------------------------------------------------------
void __fastcall CTaskComplexCarSlowBeDraggedOutAndStandUp::~CTaskComplexCarSlowBeDraggedOutAndStandUp(
        CTaskComplexCarSlowBeDraggedOutAndStandUp *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  void *v4; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B444;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 505350: variable 'v4' is possibly undefined
// 66B444: using guessed type void *off_66B444;

//----- (00505358) --------------------------------------------------------
bool __fastcall CTaskComplexCarSlowBeDraggedOutAndStandUp::MakeAbortable(
        CTaskComplexCarSlowBeDraggedOutAndStandUp *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  if ( iPriority == 2 )
    return (*((int (__fastcall **)(CTask *, CPed *, int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
             this->m_pSubTask,
             pPed,
             2,
             pEvent);
  else
    return 0;
}

//----- (0050536C) --------------------------------------------------------
CTask *__fastcall CTaskComplexCarSlowBeDraggedOutAndStandUp::CreateSubTask(
        CTaskComplexCarSlowBeDraggedOutAndStandUp *this,
        const int iSubTaskType,
        CPed *pPed)
{
  char *v5; // r4
  int AnimGroup; // r0
  CVehicle *m_pMyVehicle; // r5
  int v8; // r6
  __int64 v9; // kr00_8
  CEntity **v10; // r1
  int m_iTargetDoor; // r6

  v5 = 0;
  if ( iSubTaskType >= 816 )
  {
    if ( iSubTaskType == 816 )
    {
      v5 = (char *)CTask::operator new(0x18u);
      m_pMyVehicle = pPed->m_pMyVehicle;
      m_iTargetDoor = this->m_iTargetDoor;
      CTaskSimple::CTaskSimple((CTaskSimple *)v5);
      *((_DWORD *)v5 + 3) = m_iTargetDoor;
      v5[16] = 1;
      v5[21] = 0;
      *(_DWORD *)(v5 + 17) = 0;
      *(_DWORD *)v5 = &off_66B338;
      *((_DWORD *)v5 + 2) = m_pMyVehicle;
      v10 = (CEntity **)(v5 + 8);
    }
    else
    {
      if ( iSubTaskType != 823 )
        return (CTask *)v5;
      v5 = (char *)CTask::operator new(0x1Cu);
      v9 = *(_QWORD *)&this->m_pTargetVehicle;
      v8 = this->m_iTargetDoor;
      m_pMyVehicle = (CVehicle *)v9;
      CTaskComplex::CTaskComplex((CTaskComplex *)v5);
      *((_DWORD *)v5 + 4) = v8;
      v5[20] = 0;
      *((_DWORD *)v5 + 6) = 0;
      *(_DWORD *)v5 = &off_66B408;
      *((_DWORD *)v5 + 3) = v9;
      v10 = (CEntity **)(v5 + 12);
    }
    if ( m_pMyVehicle )
      CEntity::RegisterReference(m_pMyVehicle, v10);
  }
  else if ( iSubTaskType == 206 )
  {
    v5 = (char *)CTask::operator new(0xCu);
    CTaskComplexGetUpAndStandStill::CTaskComplexGetUpAndStandStill((CTaskComplexGetUpAndStandStill *)v5);
  }
  else if ( iSubTaskType == 704 )
  {
    AnimGroup = this->m_pTargetVehicle->pHandling->AnimGroup;
    if ( AnimGroup == 24 )
    {
      v5 = (char *)CTask::operator new(0x34u);
      CTaskComplexLeaveCar::CTaskComplexLeaveCar((CTaskComplexLeaveCar *)v5, pPed->m_pMyVehicle, 10, 0, 0, 1);
    }
    else if ( AnimGroup == 15 || (v5 = 0, AnimGroup == 16) && this->m_iTargetDoor == 8 )
    {
      v5 = (char *)CTask::operator new(0x34u);
      CTaskComplexLeaveCar::CTaskComplexLeaveCar((CTaskComplexLeaveCar *)v5, pPed->m_pMyVehicle, 8, 0, 0, 1);
    }
  }
  return (CTask *)v5;
}
// 66B338: using guessed type void *off_66B338;
// 66B408: using guessed type void *off_66B408;

//----- (00505474) --------------------------------------------------------
CTask *__fastcall CTaskComplexCarSlowBeDraggedOutAndStandUp::CreateNextSubTask(
        CTaskComplexCarSlowBeDraggedOutAndStandUp *this,
        CPed *pPed)
{
  int v3; // r0
  CTaskComplexGetUpAndStandStill *v4; // r5
  CEventDeath v6[2]; // [sp+0h] [bp-20h] BYREF

  v3 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v3 == 206 )
  {
    CPed::IsPlayer(pPed);
    return 0;
  }
  if ( v3 != 823 )
    return 0;
  if ( CPed::IsAlive(pPed) && pPed->m_nHealth > 0.0 )
  {
    v4 = (CTaskComplexGetUpAndStandStill *)CTask::operator new(0xCu);
    CTaskComplexGetUpAndStandStill::CTaskComplexGetUpAndStandStill(v4);
  }
  else
  {
    v4 = 0;
    CEventDeath::CEventDeath(v6, 0);
    CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, (CEvent *)v6, 0);
    CEvent::~CEvent((CEvent *)v6);
  }
  return v4;
}

//----- (005054F2) --------------------------------------------------------
CTask *__fastcall CTaskComplexCarSlowBeDraggedOutAndStandUp::CreateFirstSubTask(
        CTaskComplexCarSlowBeDraggedOutAndStandUp *this,
        CPed *pPed)
{
  CPlayerPed *PlayerPed; // r0
  CVehicle *m_pMyVehicle; // r2
  __int64 v6; // r0
  bool v7; // zf
  int m_iTargetDoor; // r0
  tAudioEvent v9; // r1

  PlayerPed = FindPlayerPed(0);
  m_pMyVehicle = pPed->m_pMyVehicle;
  if ( PlayerPed == pPed )
  {
    CAEVehicleAudioEntity::PlayerAboutToExitVehicleAsDriver(&m_pMyVehicle->m_VehicleAudioEntity);
  }
  else
  {
    if ( m_pMyVehicle->pDriver != pPed )
      goto LABEL_6;
    CPed::SetRadioStation(pPed);
  }
  m_pMyVehicle = pPed->m_pMyVehicle;
LABEL_6:
  HIDWORD(v6) = 704;
  LODWORD(v6) = m_pMyVehicle->pHandling->AnimGroup;
  v7 = (_DWORD)v6 == 15;
  if ( (_DWORD)v6 != 15 )
    v7 = (_DWORD)v6 == 24;
  if ( !v7 )
  {
    HIDWORD(v6) = this->m_iTargetDoor;
    if ( v6 == 0x800000010LL )
    {
      HIDWORD(v6) = 704;
      return CTaskComplexCarSlowBeDraggedOutAndStandUp::CreateSubTask(this, SHIDWORD(v6), pPed);
    }
    HIDWORD(v6) = 823;
    LODWORD(v6) = m_pMyVehicle->pHandling->AnimGroup;
    if ( (unsigned int)v6 > 0x1C )
      return CTaskComplexCarSlowBeDraggedOutAndStandUp::CreateSubTask(this, SHIDWORD(v6), pPed);
    if ( ((1 << v6) & 0x10CC6001) != 0 )
    {
      m_iTargetDoor = this->m_iTargetDoor;
      if ( m_iTargetDoor == 8 )
      {
        v9 = 70;
      }
      else
      {
        if ( m_iTargetDoor != 10 )
        {
LABEL_22:
          HIDWORD(v6) = 823;
          return CTaskComplexCarSlowBeDraggedOutAndStandUp::CreateSubTask(this, SHIDWORD(v6), pPed);
        }
        v9 = 69;
      }
    }
    else if ( (_DWORD)v6 == 1 )
    {
      v9 = 71;
    }
    else
    {
      if ( (_DWORD)v6 != 17 )
        return CTaskComplexCarSlowBeDraggedOutAndStandUp::CreateSubTask(this, SHIDWORD(v6), pPed);
      v9 = 73;
    }
    CAEPedAudioEntity::AddAudioEvent(&pPed->m_PedAudioEntity, v9, 0.0, 1.0, 0, 0, 0, 0);
    goto LABEL_22;
  }
  return CTaskComplexCarSlowBeDraggedOutAndStandUp::CreateSubTask(this, SHIDWORD(v6), pPed);
}

//----- (005055B8) --------------------------------------------------------
CTask *__fastcall CTaskComplexCarSlowBeDraggedOutAndStandUp::ControlSubTask(
        CTaskComplexCarSlowBeDraggedOutAndStandUp *this,
        CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (005055BC) --------------------------------------------------------
void __fastcall CTaskSimpleBikeJacked::CTaskSimpleBikeJacked(
        CTaskSimpleBikeJacked *this,
        CVehicle *pTargetVehicle,
        const int iTargetDoor,
        const int iDownTime,
        CPed *pDraggingPed,
        const bool bWasDriver)
{
  CPed *m_pDraggingPed; // r0

  CTaskSimple::CTaskSimple(this);
  m_pDraggingPed = pDraggingPed;
  this->m_bIsFinished = 0;
  this->m_pAnim = 0;
  this->m_nFinishAnim = ANIM_STD_NUM;
  this->m_iTargetDoor = iTargetDoor;
  this->m_iDownTime = iDownTime;
  this->m_bWasDriver = bWasDriver;
  this->m_pUtility = 0;
  this->_vptr$CTask = (int (**)(void))&off_66B480;
  this->m_pDraggingPed = pDraggingPed;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
  {
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
    m_pDraggingPed = this->m_pDraggingPed;
  }
  if ( m_pDraggingPed )
    CEntity::RegisterReference(m_pDraggingPed, &this->m_pDraggingPed);
}
// 66B480: using guessed type void *;

//----- (00505628) --------------------------------------------------------
void __fastcall CTaskSimpleBikeJacked::~CTaskSimpleBikeJacked(CTaskSimpleBikeJacked *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CPed *m_pDraggingPed; // r0
  CTaskUtilityLineUpPedWithCar *m_pUtility; // r0
  void *v6; // r0
  CAnimBlendAssociation *m_pAnim; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B480;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pDraggingPed = this->m_pDraggingPed;
  if ( m_pDraggingPed )
    CEntity::CleanUpOldReference(m_pDraggingPed, &this->m_pDraggingPed);
  m_pUtility = this->m_pUtility;
  if ( m_pUtility )
  {
    CTaskUtilityLineUpPedWithCar::~CTaskUtilityLineUpPedWithCar(m_pUtility);
    operator delete(v6);
  }
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  sub_1A01F4(this);
}
// 50565C: variable 'v6' is possibly undefined
// 66B480: using guessed type void *off_66B480;

//----- (00505684) --------------------------------------------------------
void __fastcall CTaskSimpleBikeJacked::~CTaskSimpleBikeJacked(CTaskSimpleBikeJacked *this)
{
  void *v1; // r0

  CTaskSimpleBikeJacked::~CTaskSimpleBikeJacked(this);
  sub_197118(v1);
}
// 505690: variable 'v1' is possibly undefined

//----- (00505694) --------------------------------------------------------
bool __fastcall CTaskSimpleBikeJacked::MakeAbortable(
        CTaskSimpleBikeJacked *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0

  if ( iPriority != 2 )
    return 0;
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    m_pAnim->m_fBlendDelta = -1000.0;
  return 1;
}

//----- (005056B0) --------------------------------------------------------
bool __fastcall CTaskSimpleBikeJacked::ProcessPed(CTaskSimpleBikeJacked *this, CPed *pPed)
{
  bool v4; // zf
  AnimationId m_nFinishAnim; // r2
  bool v6; // r6
  CVehicle *m_pMyVehicle; // r0
  CPed *m_pDraggingPed; // r0
  CAnimBlendAssociation *Association; // r0
  CPed *v11; // r1
  bool v12; // zf
  UInt16 v13; // r1
  CPed *v14; // r8
  CAEVehicleAudioEntity *v15; // r6
  UInt16 v16; // r1
  CPed *v17; // r8
  CAEVehicleAudioEntity *p_m_VehicleAudioEntity; // r6
  UInt16 v19; // r1
  int IsPedFemaleForAudio; // r0
  CPed *v21; // r0
  int v22; // r0
  RpClump_0 *m_pRwObject; // r6
  AssocGroupId *v24; // r0
  CAnimBlendAssociation *v25; // r0
  CTaskUtilityLineUpPedWithCar *v26; // r0
  CTaskUtilityLineUpPedWithCar *v27; // r0
  CEventKnockOffBike v28; // [sp+24h] [bp-54h] BYREF

  if ( !this->m_pTargetVehicle )
    return 1;
  v4 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
  if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
    v4 = this->m_pAnim == 0;
  if ( v4 )
    return 1;
  if ( this->m_bIsFinished )
  {
    m_nFinishAnim = this->m_nFinishAnim;
    v6 = 1;
    if ( m_nFinishAnim != ANIM_STD_NUM )
    {
      CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, m_nFinishAnim, 100.0);
      CEventKnockOffBike::CEventKnockOffBike(
        &v28,
        this->m_pTargetVehicle,
        &this->m_pTargetVehicle->m_vecMoveSpeed,
        &this->m_pTargetVehicle->m_vecDamageNormal,
        0.0,
        0.0,
        WEAPONTYPE_UNIDENTIFIED,
        0,
        this->m_iDownTime,
        this->m_pDraggingPed,
        this->m_bWasDriver,
        1);
      *((_BYTE *)&v28 + 53) |= 2u;
      CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, &v28, 1);
      this->m_nFinishAnim = ANIM_STD_NUM;
      CEventKnockOffBike::~CEventKnockOffBike(&v28);
      return 0;
    }
    return v6;
  }
  if ( !CPed::IsPlayer(pPed) && CVehicle::IsDriver(this->m_pTargetVehicle, pPed) )
    CPed::SetRadioStation(pPed);
  if ( CPed::IsPlayer(pPed) )
  {
    m_pMyVehicle = pPed->m_pMyVehicle;
    if ( m_pMyVehicle )
      CAEVehicleAudioEntity::PlayerAboutToExitVehicleAsDriver(&m_pMyVehicle->m_VehicleAudioEntity);
  }
  if ( !this->m_pAnim )
  {
    m_pDraggingPed = this->m_pDraggingPed;
    if ( m_pDraggingPed )
    {
      Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)m_pDraggingPed->m_pRwObject, 0x16Du);
      if ( !Association )
      {
        Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)this->m_pDraggingPed->m_pRwObject, 0x16Cu);
        if ( !Association )
          Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)this->m_pDraggingPed->m_pRwObject, 0x16Bu);
      }
      v11 = this->m_pDraggingPed;
      v12 = Association == 0;
      if ( Association )
        v12 = v11 == 0;
      if ( v12 )
      {
        if ( !v11 )
          goto LABEL_49;
      }
      else if ( Association->m_fCurrentTime <= 0.3 )
      {
        goto LABEL_50;
      }
      if ( (rand() & 0x3FFu) <= 0x200 )
      {
        v17 = this->m_pDraggingPed;
        p_m_VehicleAudioEntity = &this->m_pTargetVehicle->m_VehicleAudioEntity;
        if ( CAEVehicleAudioEntity::GetVehicleTypeForAudio(p_m_VehicleAudioEntity) == 1 )
        {
          v19 = 121;
        }
        else if ( CAEVehicleAudioEntity::GetVehicleTypeForAudio(p_m_VehicleAudioEntity) )
        {
          v19 = 124;
        }
        else
        {
          IsPedFemaleForAudio = CAEPedSpeechAudioEntity::IsPedFemaleForAudio(&pPed->m_PedSpeechAudioEntity);
          v19 = 122;
          if ( !IsPedFemaleForAudio )
            v19 = 123;
        }
        if ( (unsigned __int16)CPed::Say(v17, v19, 0, 1.0, 0, 0, 0) != 0xFFFF )
          goto LABEL_49;
        v4 = CAEVehicleAudioEntity::GetVehicleTypeForAudio(&this->m_pTargetVehicle->m_VehicleAudioEntity) == 0;
        v16 = 119;
        v21 = pPed;
        if ( v4 )
          v16 = 118;
      }
      else
      {
        v4 = CAEVehicleAudioEntity::GetVehicleTypeForAudio(&this->m_pTargetVehicle->m_VehicleAudioEntity) == 0;
        v13 = 119;
        if ( v4 )
          v13 = 118;
        if ( (unsigned __int16)CPed::Say(pPed, v13, 0, 1.0, 0, 0, 0) != 0xFFFF )
          goto LABEL_49;
        v14 = this->m_pDraggingPed;
        v15 = &this->m_pTargetVehicle->m_VehicleAudioEntity;
        if ( CAEVehicleAudioEntity::GetVehicleTypeForAudio(v15) == 1 )
        {
          v16 = 121;
        }
        else if ( CAEVehicleAudioEntity::GetVehicleTypeForAudio(v15) )
        {
          v16 = 124;
        }
        else
        {
          v22 = CAEPedSpeechAudioEntity::IsPedFemaleForAudio(&pPed->m_PedSpeechAudioEntity);
          v16 = 122;
          if ( !v22 )
            v16 = 123;
        }
        v21 = v14;
      }
      CPed::Say(v21, v16, 0, 1.0, 0, 0, 0);
    }
LABEL_49:
    m_pRwObject = (RpClump_0 *)pPed->m_pRwObject;
    v24 = (AssocGroupId *)(*((int (__fastcall **)(CVehicle *))this->m_pTargetVehicle->_vptr$CPlaceable + 48))(this->m_pTargetVehicle);
    v25 = CAnimManager::BlendAnimation(m_pRwObject, *v24, ANIM_BIKE_HIT, 8.0);
    this->m_pAnim = v25;
    CAnimBlendAssociation::SetFinishCallback(v25, CTaskSimpleBikeJacked::FinishAnimBikeHitCB, this);
    CAEPedAudioEntity::AddAudioEvent(&pPed->m_PedAudioEntity, 72, 0.0, 1.0, 0, 0, 0, 0);
  }
LABEL_50:
  v6 = 0;
  if ( !this->m_pUtility )
  {
    v26 = (CTaskUtilityLineUpPedWithCar *)operator new(0x1Cu);
    memset(&v28, 0, 12);
    CTaskUtilityLineUpPedWithCar::CTaskUtilityLineUpPedWithCar(v26, (const CVector *)&v28, 0, 0, this->m_iTargetDoor);
    this->m_pUtility = v27;
  }
  return v6;
}
// 50593E: variable 'v27' is possibly undefined

//----- (0050594C) --------------------------------------------------------
void __fastcall CTaskSimpleBikeJacked::FinishAnimBikeHitCB(CAnimBlendAssociation *pAnim, void *pData)
{
  int v2; // r0
  int v3; // r0

  *((_BYTE *)pData + 8) = 1;
  v2 = *((_DWORD *)pData + 6);
  *((_DWORD *)pData + 3) = 0;
  if ( (v2 | 2) == 10 )
    v3 = 105;
  else
    v3 = 106;
  *((_DWORD *)pData + 4) = v3;
}

//----- (00505966) --------------------------------------------------------
bool __fastcall CTaskSimpleBikeJacked::SetPedPosition(CTaskSimpleBikeJacked *this, CPed *pPed)
{
  CVehicle *m_pMyVehicle; // r0
  bool v3; // zf

  m_pMyVehicle = pPed->m_pMyVehicle;
  v3 = m_pMyVehicle == 0;
  if ( m_pMyVehicle )
    v3 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
  if ( !v3 )
    CPed::SetPedPositionInCar(pPed);
  return 1;
}

//----- (00505990) --------------------------------------------------------
void __fastcall CTaskSimpleCarFallOut::CTaskSimpleCarFallOut(
        CTaskSimpleCarFallOut *this,
        CVehicle *pTargetVehicle,
        const int iTargetDoor,
        CTaskUtilityLineUpPedWithCar *pUtility)
{
  CTaskSimple::CTaskSimple(this);
  this->m_bIsFinished = 0;
  this->m_pAnim = 0;
  this->m_iTargetDoor = iTargetDoor;
  this->m_pUtility = pUtility;
  this->_vptr$CTask = (int (**)(void))&off_66B4B4;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66B4B4: using guessed type void *;

//----- (005059D8) --------------------------------------------------------
void __fastcall CTaskSimpleCarFallOut::~CTaskSimpleCarFallOut(CTaskSimpleCarFallOut *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B4B4;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  sub_1A01F4(this);
}
// 66B4B4: using guessed type void *off_66B4B4;

//----- (00505A04) --------------------------------------------------------
void __fastcall CTaskSimpleCarFallOut::~CTaskSimpleCarFallOut(CTaskSimpleCarFallOut *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  void *v4; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B4B4;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  CTask::~CTask(this);
  sub_197118(v4);
}
// 505A2C: variable 'v4' is possibly undefined
// 66B4B4: using guessed type void *off_66B4B4;

//----- (00505A34) --------------------------------------------------------
bool __fastcall CTaskSimpleCarFallOut::MakeAbortable(
        CTaskSimpleCarFallOut *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0
  CVehicle *m_pTargetVehicle; // r0
  int v8; // r6
  CVehicleAnimGroup *v9; // r0
  int Group; // r0

  if ( iPriority != 2 )
    return 0;
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
  {
    m_pAnim->m_fBlendDelta = -1000.0;
    CAnimBlendAssociation::SetFinishCallback(this->m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
    this->m_pAnim = 0;
  }
  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( m_pTargetVehicle )
  {
    v8 = 388;
    v9 = &CVehicleAnimGroupData::m_vehicleAnimGroups[m_pTargetVehicle->pHandling->AnimGroup];
    if ( (this->m_iTargetDoor & 0xFFFFFFFE) == 10 )
      v8 = 387;
    Group = CVehicleAnimGroup::GetGroup(v9, v8);
    (*((void (__fastcall **)(CVehicle *, CPed *, int, int, int, int))this->m_pTargetVehicle->_vptr$CPlaceable + 29))(
      this->m_pTargetVehicle,
      pPed,
      this->m_iTargetDoor,
      Group,
      v8,
      1065353216);
  }
  return 1;
}

//----- (00505AC0) --------------------------------------------------------
void __fastcall CTaskSimpleCarFallOut::ComputeAnimID(const CTaskSimpleCarFallOut *this, int *animGroup, int *animID)
{
  int v4; // r1

  v4 = 388;
  if ( (this->m_iTargetDoor & 0xFFFFFFFE) == 10 )
    v4 = 387;
  *animID = v4;
  *animGroup = CVehicleAnimGroup::GetGroup(
                 &CVehicleAnimGroupData::m_vehicleAnimGroups[this->m_pTargetVehicle->pHandling->AnimGroup],
                 v4);
}

//----- (00505B00) --------------------------------------------------------
bool __fastcall CTaskSimpleCarFallOut::ProcessPed(CTaskSimpleCarFallOut *this, CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r0
  int v6; // r6
  CVehicleAnimGroup *v7; // r0
  int Group; // r0
  __int64 v9; // r0
  int v10; // r6
  __int16 v11; // r0
  int v12; // r0
  CAnimBlendAssociation *v13; // r0

  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( !m_pTargetVehicle || this->m_bIsFinished )
    return 1;
  if ( this->m_pAnim )
  {
    if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
      return 1;
    v6 = 388;
    v7 = &CVehicleAnimGroupData::m_vehicleAnimGroups[m_pTargetVehicle->pHandling->AnimGroup];
    if ( (this->m_iTargetDoor & 0xFFFFFFFE) == 10 )
      v6 = 387;
    Group = CVehicleAnimGroup::GetGroup(v7, v6);
    (*((void (__fastcall **)(CVehicle *, CPed *, int, int, int, _DWORD))this->m_pTargetVehicle->_vptr$CPlaceable + 29))(
      this->m_pTargetVehicle,
      pPed,
      this->m_iTargetDoor,
      Group,
      v6,
      LODWORD(this->m_pAnim->m_fCurrentTime));
  }
  else
  {
    CCarEnterExit::RemoveCarSitAnim(pPed);
    v9 = *(_QWORD *)&this->m_pTargetVehicle;
    v10 = 388;
    v11 = *(unsigned __int8 *)(*(_DWORD *)(v9 + 904) + 222);
    if ( (HIDWORD(v9) & 0xFFFFFFFE) == 10 )
      v10 = 387;
    v12 = CVehicleAnimGroup::GetGroup(&CVehicleAnimGroupData::m_vehicleAnimGroups[v11], v10);
    v13 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, (AssocGroupId)v12, (AnimationId)v10, 1000.0);
    this->m_pAnim = v13;
    CAnimBlendAssociation::SetFinishCallback(v13, CTaskSimpleCarFallOut::FinishAnimFallOutCB, this);
  }
  return 0;
}

//----- (00505BD8) --------------------------------------------------------
void __fastcall CTaskSimpleCarFallOut::StartAnim(CTaskSimpleCarFallOut *this, const CPed *pPed)
{
  __int64 v4; // r0
  int v5; // r6
  __int16 v6; // r0
  int Group; // r0
  CAnimBlendAssociation *v8; // r0

  CCarEnterExit::RemoveCarSitAnim(pPed);
  v4 = *(_QWORD *)&this->m_pTargetVehicle;
  v5 = 388;
  v6 = *(unsigned __int8 *)(*(_DWORD *)(v4 + 904) + 222);
  if ( (HIDWORD(v4) & 0xFFFFFFFE) == 10 )
    v5 = 387;
  Group = CVehicleAnimGroup::GetGroup(&CVehicleAnimGroupData::m_vehicleAnimGroups[v6], v5);
  v8 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, (AssocGroupId)Group, (AnimationId)v5, 1000.0);
  this->m_pAnim = v8;
  sub_18C19C(v8, CTaskSimpleCarFallOut::FinishAnimFallOutCB, this);
}

//----- (00505C48) --------------------------------------------------------
bool __fastcall CTaskSimpleCarFallOut::SetPedPosition(CTaskSimpleCarFallOut *this, CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r2
  CAnimBlendAssociation *m_pAnim; // r3

  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( !m_pTargetVehicle )
    return 1;
  m_pAnim = this->m_pAnim;
  if ( this->m_bIsFinished || m_pAnim )
  {
    CTaskUtilityLineUpPedWithCar::ProcessPed(this->m_pUtility, pPed, m_pTargetVehicle, m_pAnim);
    return 1;
  }
  CPed::SetPedPositionInCar(pPed);
  return 1;
}

//----- (00505C82) --------------------------------------------------------
void __fastcall CTaskSimpleCarFallOut::FinishAnimFallOutCB(CAnimBlendAssociation *pAnim, void *pData)
{
  int v2; // r0
  int32 v3; // r4
  CDamageManager *v4; // r5
  uint32 v5; // r2

  *((_DWORD *)pData + 3) = 0;
  v2 = *((_DWORD *)pData + 4);
  *((_BYTE *)pData + 8) = 1;
  if ( v2 )
  {
    if ( !*(_DWORD *)(v2 + 1440) )
    {
      v3 = *((_DWORD *)pData + 5);
      v4 = (CDamageManager *)(v2 + 1460);
      if ( !CDamageManager::GetDoorStatus((const CDamageManager *)(v2 + 1460), v3)
        || CDamageManager::GetDoorStatus(v4, v3) == 2 )
      {
        v5 = CDamageManager::GetDoorStatus(v4, v3) + 1;
        sub_19FDAC(v4, v3, v5);
      }
    }
  }
}

//----- (00505CD0) --------------------------------------------------------
void __fastcall CTaskSimpleSetPedAsAutoDriver::CTaskSimpleSetPedAsAutoDriver(
        CTaskSimpleSetPedAsAutoDriver *this,
        CVehicle *pTargetVehicle)
{
  CTaskSimple::CTaskSimple(this);
  this->_vptr$CTask = (int (**)(void))&off_66B4E8;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66B4E8: using guessed type void *;

//----- (00505D00) --------------------------------------------------------
void __fastcall CTaskSimpleSetPedAsAutoDriver::~CTaskSimpleSetPedAsAutoDriver(CTaskSimpleSetPedAsAutoDriver *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B4E8;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  sub_1A01F4(this);
}
// 66B4E8: using guessed type void *off_66B4E8;

//----- (00505D2C) --------------------------------------------------------
void __fastcall CTaskSimpleSetPedAsAutoDriver::~CTaskSimpleSetPedAsAutoDriver(CTaskSimpleSetPedAsAutoDriver *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  void *v4; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B4E8;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  CTask::~CTask(this);
  sub_197118(v4);
}
// 505D54: variable 'v4' is possibly undefined
// 66B4E8: using guessed type void *off_66B4E8;

//----- (00505D5C) --------------------------------------------------------
bool __fastcall CTaskSimpleSetPedAsAutoDriver::ProcessPed(CTaskSimpleSetPedAsAutoDriver *this, CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r0
  int m_nVehicleFlags; // r1
  int v5; // r2
  unsigned int v6; // r3

  CCarCtrl::JoinCarWithRoadSystem(this->m_pTargetVehicle);
  this->m_pTargetVehicle->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&this->m_pTargetVehicle->m_info & 7 | 0x18);
  this->m_pTargetVehicle->AutoPilot.Mission = 1;
  this->m_pTargetVehicle->AutoPilot.CruiseSpeed = 10;
  m_pTargetVehicle = this->m_pTargetVehicle;
  m_nVehicleFlags = (int)m_pTargetVehicle->m_nVehicleFlags;
  v5 = *((_DWORD *)&m_pTargetVehicle->m_nVehicleFlags + 1);
  v6 = m_nVehicleFlags & 0xFFFFFFEF;
  if ( (v5 & 0x200) == 0 )
    v6 = m_nVehicleFlags | 0x10;
  *(_DWORD *)&m_pTargetVehicle->m_nVehicleFlags = v6;
  *((_DWORD *)&m_pTargetVehicle->m_nVehicleFlags + 1) = v5;
  return 1;
}

//----- (00505DAC) --------------------------------------------------------
void __fastcall CTaskComplexGoToBoatSteeringWheel::CTaskComplexGoToBoatSteeringWheel(
        CTaskComplexGoToBoatSteeringWheel *this,
        CVehicle *pVehicle)
{
  CTaskComplex::CTaskComplex(this);
  this->m_bAchievedPoint = 0;
  this->m_iStartTime = 0;
  this->_vptr$CTask = (int (**)(void))&off_66B51C;
  this->m_pTargetVehicle = pVehicle;
  if ( pVehicle )
    CEntity::RegisterReference(pVehicle, &this->m_pTargetVehicle);
}
// 66B51C: using guessed type void *;

//----- (00505DE4) --------------------------------------------------------
void __fastcall CTaskComplexGoToBoatSteeringWheel::~CTaskComplexGoToBoatSteeringWheel(
        CTaskComplexGoToBoatSteeringWheel *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B51C;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  sub_18EDB4(this);
}
// 66B51C: using guessed type void *off_66B51C;

//----- (00505E10) --------------------------------------------------------
void __fastcall CTaskComplexGoToBoatSteeringWheel::~CTaskComplexGoToBoatSteeringWheel(
        CTaskComplexGoToBoatSteeringWheel *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  void *v4; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B51C;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 505E38: variable 'v4' is possibly undefined
// 66B51C: using guessed type void *off_66B51C;

//----- (00505E40) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToBoatSteeringWheel::CreateNextSubTask(
        CTaskComplexGoToBoatSteeringWheel *this,
        CPed *pPed)
{
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 903 )
    this->m_bAchievedPoint = 1;
  return 0;
}

//----- (00505E60) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToBoatSteeringWheel::CreateSubTask(
        CTaskComplexGoToBoatSteeringWheel *this,
        const int iSubTaskType)
{
  CTaskSimpleStandStill *v3; // r4
  CVehicle *m_pTargetVehicle; // r1
  CBaseModelInfo *v5; // r0
  int v6; // r2
  uint32 m_hashKey; // r0
  __int64 v8; // d16
  CVehicle *v9; // r0
  CMatrix *m_pMat; // r1
  float *p_tx; // r2
  RwReal z; // r0
  CTaskComplexGoToPointAndStandStill *v13; // r0
  CTask *v14; // r0
  CVector v16; // [sp+10h] [bp-28h] BYREF
  CVector v; // [sp+20h] [bp-18h] BYREF

  v3 = 0;
  if ( iSubTaskType == 903 )
  {
    m_pTargetVehicle = this->m_pTargetVehicle;
    v5 = CModelInfo::ms_modelInfoPtrs[m_pTargetVehicle->m_nModelIndex];
    v6 = *(_DWORD *)&v5[1].m_modelName[20];
    m_hashKey = v5[2].m_hashKey;
    if ( v6 != 5 )
      m_hashKey += 48;
    v8 = *(_QWORD *)m_hashKey;
    v.z = *(RwReal *)(m_hashKey + 8);
    *(_QWORD *)&v.x = v8;
    Multiply3x3(&v16, m_pTargetVehicle->m_pMat, &v);
    v = v16;
    v9 = this->m_pTargetVehicle;
    m_pMat = v9->m_pMat;
    p_tx = &m_pMat->tx;
    if ( !m_pMat )
      p_tx = &v9->m_transform.m_translate.x;
    v.x = *p_tx + v16.x;
    v.y = p_tx[1] + v16.y;
    v.z = p_tx[2] + v16.z;
    z = v.z;
    *(_QWORD *)&this->m_vTargetPos.x = *(_QWORD *)&v.x;
    this->m_vTargetPos.z = z;
    v13 = (CTaskComplexGoToPointAndStandStill *)CTask::operator new(0x28u);
    CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(v13, 4, &this->m_vTargetPos, 0.5, 2.0, 0, 0);
    return v14;
  }
  else if ( iSubTaskType == 203 )
  {
    v3 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill(v3, -1, 0, 0, 8.0);
  }
  return v3;
}
// 505F44: variable 'v14' is possibly undefined

//----- (00505F58) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToBoatSteeringWheel::CreateFirstSubTask(
        CTaskComplexGoToBoatSteeringWheel *this,
        CPed *pPed)
{
  CVehicle *m_pTargetVehicle; // r2
  CBaseModelInfo *v4; // r0
  int v5; // r1
  uint32 m_hashKey; // r0
  __int64 v7; // d16
  CVehicle *v8; // r0
  CMatrix *m_pMat; // r1
  float *p_tx; // r2
  RwReal z; // r0
  CTaskComplexGoToPointAndStandStill *v12; // r0
  CTask *result; // r0
  CVector v14; // [sp+10h] [bp-28h] BYREF
  CVector v; // [sp+20h] [bp-18h] BYREF

  m_pTargetVehicle = this->m_pTargetVehicle;
  this->m_iStartTime = CTimer::m_snTimeInMilliseconds;
  v4 = CModelInfo::ms_modelInfoPtrs[m_pTargetVehicle->m_nModelIndex];
  v5 = *(_DWORD *)&v4[1].m_modelName[20];
  m_hashKey = v4[2].m_hashKey;
  if ( v5 != 5 )
    m_hashKey += 48;
  v7 = *(_QWORD *)m_hashKey;
  v.z = *(RwReal *)(m_hashKey + 8);
  *(_QWORD *)&v.x = v7;
  Multiply3x3(&v14, m_pTargetVehicle->m_pMat, &v);
  v = v14;
  v8 = this->m_pTargetVehicle;
  m_pMat = v8->m_pMat;
  p_tx = &m_pMat->tx;
  if ( !m_pMat )
    p_tx = &v8->m_transform.m_translate.x;
  v.x = *p_tx + v14.x;
  v.y = p_tx[1] + v14.y;
  v.z = p_tx[2] + v14.z;
  z = v.z;
  *(_QWORD *)&this->m_vTargetPos.x = *(_QWORD *)&v.x;
  this->m_vTargetPos.z = z;
  v12 = (CTaskComplexGoToPointAndStandStill *)CTask::operator new(0x28u);
  CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(v12, 4, &this->m_vTargetPos, 0.5, 2.0, 0, 0);
  return result;
}

//----- (00506034) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToBoatSteeringWheel::ControlSubTask(
        CTaskComplexGoToBoatSteeringWheel *this,
        CPed *pPed)
{
  CVehicle *v4; // r1
  CTaskSimpleStandStill *v5; // r0
  CTask *result; // r0
  CTask *m_pSubTask; // r5
  int v8; // r0
  CVehicle *m_pTargetVehicle; // r1
  CBaseModelInfo *v10; // r0
  int v11; // r2
  uint32 m_hashKey; // r0
  __int64 v13; // d16
  CVehicle *v14; // r0
  CMatrix *m_pMat; // r1
  float *p_tx; // r2
  RwReal z; // r0
  float x; // s4
  float v19; // s8
  float y; // s10
  float v21; // s12
  CTask v22; // d16
  char m_pParent; // r0
  CVector v24; // [sp+8h] [bp-28h] BYREF
  CVector v; // [sp+18h] [bp-18h] BYREF

  if ( CPed::IsPlayer(pPed)
    && (v4 = this->m_pTargetVehicle) != 0
    && CCarEnterExit::IsPlayerToQuitCarEnter(pPed, v4, this->m_iStartTime, this->m_pSubTask) )
  {
    v5 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill(v5, -1, 0, 0, 8.0);
  }
  else
  {
    m_pSubTask = this->m_pSubTask;
    if ( (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 3))(m_pSubTask) )
    {
      v8 = (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 3))(m_pSubTask);
      if ( (*(int (__fastcall **)(int))(*(_DWORD *)v8 + 20))(v8) != 203 )
      {
        m_pTargetVehicle = this->m_pTargetVehicle;
        v10 = CModelInfo::ms_modelInfoPtrs[m_pTargetVehicle->m_nModelIndex];
        v11 = *(_DWORD *)&v10[1].m_modelName[20];
        m_hashKey = v10[2].m_hashKey;
        if ( v11 != 5 )
          m_hashKey += 48;
        v13 = *(_QWORD *)m_hashKey;
        v.z = *(RwReal *)(m_hashKey + 8);
        *(_QWORD *)&v.x = v13;
        Multiply3x3(&v24, m_pTargetVehicle->m_pMat, &v);
        v = v24;
        v14 = this->m_pTargetVehicle;
        m_pMat = v14->m_pMat;
        p_tx = &m_pMat->tx;
        if ( !m_pMat )
          p_tx = &v14->m_transform.m_translate.x;
        v.x = *p_tx + v24.x;
        v.y = p_tx[1] + v24.y;
        v.z = p_tx[2] + v24.z;
        z = v.z;
        *(_QWORD *)&this->m_vTargetPos.x = *(_QWORD *)&v.x;
        this->m_vTargetPos.z = z;
        x = this->m_vTargetPos.x;
        v19 = *(float *)&m_pSubTask[2]._vptr$CTask;
        y = this->m_vTargetPos.y;
        v21 = *(float *)&m_pSubTask[2].m_pParent;
        if ( (float)((float)((float)((float)(v19 - x) * (float)(v19 - x)) + (float)((float)(v21 - y) * (float)(v21 - y)))
                   + (float)((float)(*(float *)&m_pSubTask[3]._vptr$CTask - this->m_vTargetPos.z)
                           * (float)(*(float *)&m_pSubTask[3]._vptr$CTask - this->m_vTargetPos.z))) > 0.04
          && (v21 != y || v19 != x || *(float *)&m_pSubTask[4]._vptr$CTask != 2.0) )
        {
          v22 = *(CTask *)&this->m_vTargetPos.x;
          m_pSubTask[3]._vptr$CTask = (int (**)(void))LODWORD(this->m_vTargetPos.z);
          m_pSubTask[2] = v22;
          m_pSubTask[4]._vptr$CTask = (int (**)(void))0x40000000;
          m_pParent = (char)m_pSubTask[4].m_pParent;
          m_pSubTask[3].m_pParent = (CTask *)1056964608;
          LOBYTE(m_pSubTask[4].m_pParent) = m_pParent | 4;
        }
      }
    }
    return this->m_pSubTask;
  }
  return result;
}

//----- (005061E0) --------------------------------------------------------
void __fastcall CTaskComplexGoToBoatSteeringWheel::ComputeTargetPos(CTaskComplexGoToBoatSteeringWheel *this)
{
  CVehicle *m_pTargetVehicle; // r1
  CBaseModelInfo *v3; // r0
  int v4; // r2
  uint32 m_hashKey; // r0
  __int64 v6; // d16
  CVehicle *v7; // r0
  CMatrix *m_pMat; // r1
  float *p_tx; // r2
  RwReal z; // r0
  CVector v11; // [sp+0h] [bp-28h] BYREF
  CVector v; // [sp+10h] [bp-18h] BYREF

  m_pTargetVehicle = this->m_pTargetVehicle;
  v3 = CModelInfo::ms_modelInfoPtrs[m_pTargetVehicle->m_nModelIndex];
  v4 = *(_DWORD *)&v3[1].m_modelName[20];
  m_hashKey = v3[2].m_hashKey;
  if ( v4 != 5 )
    m_hashKey += 48;
  v6 = *(_QWORD *)m_hashKey;
  v.z = *(RwReal *)(m_hashKey + 8);
  *(_QWORD *)&v.x = v6;
  Multiply3x3(&v11, m_pTargetVehicle->m_pMat, &v);
  v = v11;
  v7 = this->m_pTargetVehicle;
  m_pMat = v7->m_pMat;
  p_tx = &m_pMat->tx;
  if ( !m_pMat )
    p_tx = &v7->m_transform.m_translate.x;
  v.x = *p_tx + v11.x;
  v.y = p_tx[1] + v11.y;
  v.z = p_tx[2] + v11.z;
  z = v.z;
  *(_QWORD *)&this->m_vTargetPos.x = *(_QWORD *)&v.x;
  this->m_vTargetPos.z = z;
}

//----- (00506278) --------------------------------------------------------
void __fastcall CTaskComplexGetOnBoatSeat::CTaskComplexGetOnBoatSeat(
        CTaskComplexGetOnBoatSeat *this,
        CVehicle *pVehicle)
{
  CTaskComplex::CTaskComplex(this);
  this->_vptr$CTask = (int (**)(void))&off_66B558;
  this->m_pTargetVehicle = pVehicle;
  if ( pVehicle )
    CEntity::RegisterReference(pVehicle, &this->m_pTargetVehicle);
}
// 66B558: using guessed type void *;

//----- (005062A8) --------------------------------------------------------
void __fastcall CTaskComplexGetOnBoatSeat::~CTaskComplexGetOnBoatSeat(CTaskComplexGetOnBoatSeat *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B558;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  sub_18EDB4(this);
}
// 66B558: using guessed type void *off_66B558;

//----- (005062D4) --------------------------------------------------------
void __fastcall CTaskComplexGetOnBoatSeat::~CTaskComplexGetOnBoatSeat(CTaskComplexGetOnBoatSeat *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  void *v4; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B558;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 5062FC: variable 'v4' is possibly undefined
// 66B558: using guessed type void *off_66B558;

//----- (00506304) --------------------------------------------------------
bool __fastcall CTaskComplexGetOnBoatSeat::MakeAbortable(
        CTaskComplexGetOnBoatSeat *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  if ( iPriority == 2 )
    return (*((int (__fastcall **)(CTask *, CPed *, int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
             this->m_pSubTask,
             pPed,
             2,
             pEvent);
  else
    return 0;
}

//----- (00506318) --------------------------------------------------------
CTask *__fastcall CTaskComplexGetOnBoatSeat::CreateNextSubTask(CTaskComplexGetOnBoatSeat *this, CPed *pPed)
{
  return 0;
}

//----- (0050631C) --------------------------------------------------------
CTask *__fastcall CTaskComplexGetOnBoatSeat::CreateFirstSubTask(CTaskComplexGetOnBoatSeat *this, CPed *pPed)
{
  uint32 mFlags; // r4
  CTaskSimpleRunAnim *v3; // r0
  AnimationId v4; // r2
  CTask *result; // r0

  mFlags = this->m_pTargetVehicle->pHandling->mFlags;
  v3 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
  if ( (mFlags & 0x400) != 0 )
    v4 = ANIM_STD_CAR_SIT;
  else
    v4 = ANIM_STD_BOAT_DRIVE;
  CTaskSimpleRunAnim::CTaskSimpleRunAnim(v3, ANIM_STD_PED, v4, 1.0, 0);
  return result;
}

//----- (0050634E) --------------------------------------------------------
CTask *__fastcall CTaskComplexGetOnBoatSeat::ControlSubTask(CTaskComplexGetOnBoatSeat *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (00506354) --------------------------------------------------------
void __fastcall CTaskSimpleCreateCarAndGetIn::CTaskSimpleCreateCarAndGetIn(
        CTaskSimpleCreateCarAndGetIn *this,
        const CVector *vPedPos,
        const int iDesiredCarModel)
{
  int v5; // r0
  __int64 v6; // d16

  CTaskSimple::CTaskSimple(this);
  *(_DWORD *)v5 = &off_66B594;
  v6 = *(_QWORD *)&vPedPos->x;
  *(RwReal *)(v5 + 16) = vPedPos->z;
  *(_DWORD *)(v5 + 20) = iDesiredCarModel;
  *(_DWORD *)(v5 + 24) = 0;
  *(_DWORD *)(v5 + 40) = 0;
  *(_DWORD *)(v5 + 44) = 0;
  *(_WORD *)(v5 + 48) = 0;
  *(_QWORD *)(v5 + 8) = v6;
}
// 50636A: variable 'v5' is possibly undefined
// 66B594: using guessed type void *;

//----- (00506388) --------------------------------------------------------
void __fastcall CTaskSimpleCreateCarAndGetIn::~CTaskSimpleCreateCarAndGetIn(CTaskSimpleCreateCarAndGetIn *this)
{
  CVehicle *m_pVehicle; // r0

  m_pVehicle = this->m_pVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B594;
  if ( m_pVehicle )
  {
    CTheScripts::CleanUpThisVehicle(m_pVehicle);
    CMissionCleanup::RemoveEntityFromList(
      &CTheScripts::MissionCleanUp,
      CPools::ms_pVehiclePool->m_aFlags[-1075391197
                                      * (((char *)this->m_pVehicle - (char *)CPools::ms_pVehiclePool->m_aStorage) >> 2)] | (-422239488 * (((char *)this->m_pVehicle - (char *)CPools::ms_pVehiclePool->m_aStorage) >> 2)),
      1u);
  }
  sub_1A01F4(this);
}
// 66B594: using guessed type void *off_66B594;
// 678534: using guessed type int *CPools::ms_pVehiclePool;

//----- (005063E4) --------------------------------------------------------
void __fastcall CTaskSimpleCreateCarAndGetIn::~CTaskSimpleCreateCarAndGetIn(CTaskSimpleCreateCarAndGetIn *this)
{
  CVehicle *m_pVehicle; // r0
  void *v3; // r0

  m_pVehicle = this->m_pVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B594;
  if ( m_pVehicle )
  {
    CTheScripts::CleanUpThisVehicle(m_pVehicle);
    CMissionCleanup::RemoveEntityFromList(
      &CTheScripts::MissionCleanUp,
      CPools::ms_pVehiclePool->m_aFlags[-1075391197
                                      * (((char *)this->m_pVehicle - (char *)CPools::ms_pVehiclePool->m_aStorage) >> 2)] | (-422239488 * (((char *)this->m_pVehicle - (char *)CPools::ms_pVehiclePool->m_aStorage) >> 2)),
      1u);
  }
  CTask::~CTask(this);
  sub_197118(v3);
}
// 506434: variable 'v3' is possibly undefined
// 66B594: using guessed type void *off_66B594;
// 678534: using guessed type int *CPools::ms_pVehiclePool;

//----- (00506444) --------------------------------------------------------
bool __fastcall CTaskSimpleCreateCarAndGetIn::ProcessPed(CTaskSimpleCreateCarAndGetIn *this, CPed *pPed)
{
  CNodeAddress *NodeClosestToCoors; // r0
  CVehicle *m_pVehicle; // r1
  __int64 v6; // d16
  CTaskSimpleStandStill *v7; // r0
  CVehicle *v8; // r0
  CVehicle *CarForScript; // r6
  int v10; // r0
  CEntity **v11; // r8
  bool v12; // r6
  unsigned int v13; // r0
  int m_iStartTime; // r1
  CSimpleTransform *p_m_transform; // r8
  CMatrix *m_pMat; // r3
  CSimpleTransform *p_tx; // r1
  CMatrix *v19; // r0
  CTaskSimpleCarSetPedInAsDriver v20; // [sp+1Ch] [bp-64h] BYREF
  CTaskSimpleStandStill v21; // [sp+38h] [bp-48h] BYREF
  CVector v22; // [sp+58h] [bp-28h] BYREF
  bool pSuccess; // [sp+67h] [bp-19h] BYREF
  CVector v24; // 0:r2.8,8:^0.4

  *(_QWORD *)&v24.x = *(_QWORD *)&this->m_vPedPos.y;
  v24.z = 0.0;
  NodeClosestToCoors = CPathFind::FindNodeClosestToCoors(
                         (CNodeAddress *)&ThePaths,
                         (CPathFind *)LODWORD(this->m_vPedPos.x),
                         v24,
                         1000000.0,
                         COERCE_FLOAT(1),
                         1,
                         0,
                         0,
                         0,
                         (bool)v20._vptr$CTask);
  CPathFind::FindNodeCoorsForScript(&v22, &ThePaths, (CNodeAddress)NodeClosestToCoors, &pSuccess);
  if ( pSuccess )
  {
    this->m_timer.m_bIsActive = 0;
    m_pVehicle = this->m_pVehicle;
    v6 = *(_QWORD *)&v22.x;
    this->m_vPos.z = v22.z;
    *(_QWORD *)&this->m_vPos.x = v6;
    if ( m_pVehicle )
      goto LABEL_3;
    if ( CCamera::IsSphereVisible(&TheCamera, &this->m_vPos, 3.0) )
      return 1;
    p_m_transform = &pPed->m_transform;
    m_pMat = pPed->m_pMat;
    p_tx = &pPed->m_transform;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    v12 = 1;
    if ( !CCamera::IsSphereVisible(
            &TheCamera,
            &p_tx->m_translate,
            CModelInfo::ms_modelInfoPtrs[pPed->m_nModelIndex]->m_pColModel->m_sphereBound.m_fRadius) )
    {
      v19 = pPed->m_pMat;
      if ( v19 )
        p_m_transform = (CSimpleTransform *)&v19->tx;
      if ( CPedPlacement::IsPositionClearForPed(&p_m_transform->m_translate, 3.0, -1, 0, 1, 1, 1) == 1 )
      {
LABEL_3:
        CTaskSimpleStandStill::CTaskSimpleStandStill(&v21, 0, 0, 0, 8.0);
        CTaskSimpleStandStill::ProcessPed(v7, pPed);
        if ( CStreaming::ms_aInfoForModel[this->m_iDesiredCarModel].m_status == 1 )
        {
          v8 = this->m_pVehicle;
          if ( !v8 )
          {
            CarForScript = CCarCtrl::CreateCarForScript(this->m_iDesiredCarModel, this->m_vPos, 1);
            this->m_pVehicle = CarForScript;
            CTaskSimple::CTaskSimple(&v20);
            v11 = (CEntity **)(v10 + 16);
            v20.m_bIsFinished = 0;
            v20._vptr$CTask = (int (**)(void))&off_66B268;
            v20.m_pAnim = 0;
            v20.m_pTargetVehicle = CarForScript;
            v20.m_nNumGettingInToClear = 0;
            *(_WORD *)&v20.m_bWarpingInToCar = 0;
            v20.m_pUtility = 0;
            if ( CarForScript )
              CEntity::RegisterReference(CarForScript, v11);
            v20.m_bWarpingInToCar = 1;
            CTaskSimpleCarSetPedInAsDriver::ProcessPed(&v20, pPed);
            v20._vptr$CTask = (int (**)(void))&off_66B268;
            if ( v20.m_pTargetVehicle )
              CEntity::CleanUpOldReference(v20.m_pTargetVehicle, v11);
            CTask::~CTask(&v20);
            v8 = this->m_pVehicle;
          }
          v12 = 0;
          if ( (*(_DWORD *)&v8->m_nFlags & 0x40004) == 0 )
          {
            CTheScripts::CleanUpThisVehicle(v8);
            CMissionCleanup::RemoveEntityFromList(
              &CTheScripts::MissionCleanUp,
              CPools::ms_pVehiclePool->m_aFlags[-1075391197
                                              * (((char *)this->m_pVehicle - (char *)CPools::ms_pVehiclePool->m_aStorage) >> 2)] | (-422239488 * (((char *)this->m_pVehicle - (char *)CPools::ms_pVehiclePool->m_aStorage) >> 2)),
              1u);
            this->m_pVehicle = 0;
            v12 = 1;
          }
        }
        else
        {
          CStreaming::RequestModel(this->m_iDesiredCarModel, 12);
          v12 = 0;
        }
        CTaskSimpleStandStill::~CTaskSimpleStandStill(&v21);
      }
    }
  }
  else
  {
    if ( !this->m_timer.m_bIsActive )
    {
      *(_QWORD *)&this->m_timer.m_iStartTime = CTimer::m_snTimeInMilliseconds | 0x7D000000000LL;
      this->m_timer.m_bIsActive = 1;
    }
    if ( this->m_timer.m_bIsStopped )
    {
      v13 = CTimer::m_snTimeInMilliseconds;
      this->m_timer.m_bIsStopped = 0;
      this->m_timer.m_iStartTime = v13;
      m_iStartTime = v13;
    }
    else
    {
      m_iStartTime = this->m_timer.m_iStartTime;
      v13 = CTimer::m_snTimeInMilliseconds;
    }
    return m_iStartTime + this->m_timer.m_iDuration <= v13;
  }
  return v12;
}
// 5064C2: variable 'v7' is possibly undefined
// 506502: variable 'v10' is possibly undefined
// 66B268: using guessed type void *off_66B268;
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];
// 678534: using guessed type int *CPools::ms_pVehiclePool;

//----- (005066B0) --------------------------------------------------------
void __fastcall CTaskSimpleWaitUntilPedIsOutCar::CTaskSimpleWaitUntilPedIsOutCar(
        CTaskSimpleWaitUntilPedIsOutCar *this,
        CPed *pTargetPed,
        const CVector *vDir)
{
  __int64 v6; // d16

  CTaskSimple::CTaskSimple(this);
  this->m_bFirstTime = 1;
  this->_vptr$CTask = (int (**)(void))&off_66B5C8;
  this->m_pTargetPed = pTargetPed;
  v6 = *(_QWORD *)&vDir->x;
  this->m_vDir.z = vDir->z;
  *(_QWORD *)&this->m_vDir.x = v6;
  if ( pTargetPed )
    CEntity::RegisterReference(pTargetPed, &this->m_pTargetPed);
}
// 66B5C8: using guessed type void *;

//----- (005066FC) --------------------------------------------------------
void __fastcall CTaskSimpleWaitUntilPedIsOutCar::~CTaskSimpleWaitUntilPedIsOutCar(
        CTaskSimpleWaitUntilPedIsOutCar *this)
{
  CPed *m_pTargetPed; // r0
  CEntity **p_m_pTargetPed; // r1

  p_m_pTargetPed = &this->m_pTargetPed;
  m_pTargetPed = this->m_pTargetPed;
  this->_vptr$CTask = (int (**)(void))&off_66B5C8;
  if ( m_pTargetPed )
    CEntity::CleanUpOldReference(m_pTargetPed, p_m_pTargetPed);
  sub_1A01F4(this);
}
// 66B5C8: using guessed type void *off_66B5C8;

//----- (00506728) --------------------------------------------------------
void __fastcall CTaskSimpleWaitUntilPedIsOutCar::~CTaskSimpleWaitUntilPedIsOutCar(
        CTaskSimpleWaitUntilPedIsOutCar *this)
{
  CPed *m_pTargetPed; // r0
  CEntity **p_m_pTargetPed; // r1
  void *v4; // r0

  p_m_pTargetPed = &this->m_pTargetPed;
  m_pTargetPed = this->m_pTargetPed;
  this->_vptr$CTask = (int (**)(void))&off_66B5C8;
  if ( m_pTargetPed )
    CEntity::CleanUpOldReference(m_pTargetPed, p_m_pTargetPed);
  CTask::~CTask(this);
  sub_197118(v4);
}
// 506750: variable 'v4' is possibly undefined
// 66B5C8: using guessed type void *off_66B5C8;

//----- (00506758) --------------------------------------------------------
bool __fastcall CTaskSimpleWaitUntilPedIsOutCar::ProcessPed(CTaskSimpleWaitUntilPedIsOutCar *this, CPed *pPed)
{
  CPed *m_pTargetPed; // r0
  CTaskSimpleStandStill *v5; // r0
  float RadianAngleBetweenPoints; // r0
  CTaskSimpleStandStill v8; // [sp+8h] [bp-30h] BYREF

  m_pTargetPed = this->m_pTargetPed;
  if ( !m_pTargetPed )
    return 1;
  if ( this->m_bFirstTime )
  {
    this->m_bFirstTime = 0;
    CTaskSimpleStandStill::CTaskSimpleStandStill(&v8, 0, 0, 0, 8.0);
    CTaskSimpleStandStill::ProcessPed(v5, pPed);
    RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(this->m_vDir.x, this->m_vDir.y, 0.0, 0.0);
    pPed->m_fDesiredHeading = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
    CTaskSimpleStandStill::~CTaskSimpleStandStill(&v8);
    m_pTargetPed = this->m_pTargetPed;
  }
  return *((unsigned __int8 *)&m_pTargetPed->m_nPedFlags + 1) << 31 == 0;
}
// 506788: variable 'v5' is possibly undefined

//----- (005067C4) --------------------------------------------------------
void __fastcall CTaskSimpleWaitUntilPedIsInCar::CTaskSimpleWaitUntilPedIsInCar(
        CTaskSimpleWaitUntilPedIsInCar *this,
        CPed *pTargetPed)
{
  CTaskSimple::CTaskSimple(this);
  this->m_bIsWalkingToDoor = 0;
  this->_vptr$CTask = (int (**)(void))&off_66B5FC;
  this->m_pTargetPed = pTargetPed;
  if ( pTargetPed )
    CEntity::RegisterReference(pTargetPed, &this->m_pTargetPed);
}
// 66B5FC: using guessed type void *;

//----- (005067F8) --------------------------------------------------------
void __fastcall CTaskSimpleWaitUntilPedIsInCar::~CTaskSimpleWaitUntilPedIsInCar(CTaskSimpleWaitUntilPedIsInCar *this)
{
  CPed *m_pTargetPed; // r0
  CEntity **p_m_pTargetPed; // r1

  p_m_pTargetPed = &this->m_pTargetPed;
  m_pTargetPed = this->m_pTargetPed;
  this->_vptr$CTask = (int (**)(void))&off_66B5FC;
  if ( m_pTargetPed )
    CEntity::CleanUpOldReference(m_pTargetPed, p_m_pTargetPed);
  sub_1A01F4(this);
}
// 66B5FC: using guessed type void *off_66B5FC;

//----- (00506824) --------------------------------------------------------
void __fastcall CTaskSimpleWaitUntilPedIsInCar::~CTaskSimpleWaitUntilPedIsInCar(CTaskSimpleWaitUntilPedIsInCar *this)
{
  CPed *m_pTargetPed; // r0
  CEntity **p_m_pTargetPed; // r1
  void *v4; // r0

  p_m_pTargetPed = &this->m_pTargetPed;
  m_pTargetPed = this->m_pTargetPed;
  this->_vptr$CTask = (int (**)(void))&off_66B5FC;
  if ( m_pTargetPed )
    CEntity::CleanUpOldReference(m_pTargetPed, p_m_pTargetPed);
  CTask::~CTask(this);
  sub_197118(v4);
}
// 50684C: variable 'v4' is possibly undefined
// 66B5FC: using guessed type void *off_66B5FC;

//----- (00506854) --------------------------------------------------------
bool __fastcall CTaskSimpleWaitUntilPedIsInCar::ProcessPed(CTaskSimpleWaitUntilPedIsInCar *this, CPed *pPed)
{
  CPed *m_pTargetPed; // r0

  CPed::SetMoveState(pPed, PEDMOVE_STILL);
  m_pTargetPed = this->m_pTargetPed;
  if ( m_pTargetPed )
  {
    if ( CTaskManager::FindActiveTaskByType(&m_pTargetPed->m_pPedIntelligence->m_taskManager, 800) )
    {
      this->m_bIsWalkingToDoor = 1;
      return *((_BYTE *)&this->m_pTargetPed->m_nPedFlags + 1) & 1;
    }
    if ( !this->m_bIsWalkingToDoor
      && !CTaskManager::FindActiveTaskByType(&this->m_pTargetPed->m_pPedIntelligence->m_taskManager, 807)
      && (CPed::IsPlayer(this->m_pTargetPed) || (*((_BYTE *)&this->m_pTargetPed->m_nPedFlags + 12) & 8) == 0) )
    {
      return *((_BYTE *)&this->m_pTargetPed->m_nPedFlags + 1) & 1;
    }
  }
  return 1;
}

//----- (005068BC) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToCarDoorAndStandStill::Clone(const CTaskComplexGoToCarDoorAndStandStill *this)
{
  char *v2; // r4
  __int64 v3; // kr00_8
  __int64 v4; // d8
  __int64 v5; // d9
  int m_iTargetSeat; // r9

  v2 = (char *)CTask::operator new(0x50u);
  v3 = *(_QWORD *)&this->m_pTargetVehicle;
  v4 = *(_QWORD *)&this->m_fTargetRadius;
  v5 = *(_QWORD *)&this->m_fMaxSeekDistance;
  m_iTargetSeat = this->m_iTargetSeat;
  LOBYTE(this) = this->m_bIsDriver;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_QWORD *)v2 + 3) = v4;
  *((_QWORD *)v2 + 4) = v5;
  *(_QWORD *)(v2 + 52) = 0LL;
  *(_QWORD *)(v2 + 60) = 0LL;
  *((_DWORD *)v2 + 4) = HIDWORD(v3);
  v2[20] = (char)this;
  *((_WORD *)v2 + 24) = 0;
  *((_DWORD *)v2 + 17) = m_iTargetSeat;
  *((_WORD *)v2 + 36) = 0;
  *((_DWORD *)v2 + 19) = 0;
  *((_DWORD *)v2 + 10) = 0;
  *((_DWORD *)v2 + 11) = 0;
  *(_DWORD *)v2 = &off_66AFBC;
  *((_DWORD *)v2 + 3) = v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)v2 + 3);
  return (CTask *)v2;
}
// 66AFBC: using guessed type void *off_66AFBC;

//----- (00506944) --------------------------------------------------------
int __fastcall CTaskComplexGoToCarDoorAndStandStill::GetTaskType(const CTaskComplexGoToCarDoorAndStandStill *this)
{
  return 800;
}

//----- (0050694C) --------------------------------------------------------
void __fastcall CTaskComplexGoToCarDoorAndStandStill::Serialize(CTaskComplexGoToCarDoorAndStandStill *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CVehicle *m_pTargetVehicle; // r0
  int v5; // r5
  _DWORD *v6; // r6
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r5
  _DWORD *v10; // r5
  _DWORD *v11; // r5
  float *v12; // r5
  float *v13; // r5
  _DWORD *v14; // r5

  v2 = (*((int (__fastcall **)(CTaskComplexGoToCarDoorAndStandStill *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexGoToCarDoorAndStandStill *))this->_vptr$CTask + 5))(this) == 800 )
  {
    m_pTargetVehicle = this->m_pTargetVehicle;
    if ( m_pTargetVehicle )
    {
      v5 = GettPoolVehicleRef(m_pTargetVehicle);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    free(v7);
    if ( UseDataFence )
      AddDataFence();
    v10 = malloc(4u);
    *v10 = this->m_iMoveState;
    CGenericGameStorage::_SaveDataToWorkBuffer(v10, 4);
    free(v10);
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(&this->m_bIsDriver, 1);
    if ( UseDataFence )
      AddDataFence();
    v11 = malloc(4u);
    *v11 = this->m_iTargetSeat;
    CGenericGameStorage::_SaveDataToWorkBuffer(v11, 4);
    free(v11);
    if ( UseDataFence )
      AddDataFence();
    v12 = (float *)malloc(4u);
    *v12 = this->m_fTargetRadius;
    CGenericGameStorage::_SaveDataToWorkBuffer(v12, 4);
    free(v12);
    if ( UseDataFence )
      AddDataFence();
    v13 = (float *)malloc(4u);
    *v13 = this->m_fSlowDownDistance;
    CGenericGameStorage::_SaveDataToWorkBuffer(v13, 4);
    free(v13);
    if ( UseDataFence )
      AddDataFence();
    v14 = malloc(4u);
    *v14 = this->m_iMaxSeekTime;
    CGenericGameStorage::_SaveDataToWorkBuffer(v14, 4);
    j_free(v14);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexGoToCarDoorAndStandStill *))this->_vptr$CTask + 5))(this);
    sub_1941C4(800, v8);
  }
}

//----- (00506B20) --------------------------------------------------------
CTask *__fastcall CTaskSimpleCarAlign::Clone(const CTaskSimpleCarAlign *this)
{
  CTaskSimple *v2; // r0
  CVehicle *m_pTargetVehicle; // r5
  CTaskSimple *v4; // r4
  CTaskSimple v5; // r8
  __int64 v6; // d16

  v2 = (CTaskSimple *)CTask::operator new(0x28u);
  m_pTargetVehicle = this->m_pTargetVehicle;
  v4 = v2;
  v5 = *(CTaskSimple *)&this->m_iTargetDoor;
  CTaskSimple::CTaskSimple(v2);
  LOBYTE(v4[1]._vptr$CTask) = 0;
  v4[1].m_pParent = 0;
  v4->_vptr$CTask = (int (**)(void))&off_66AFF8;
  v4[2]._vptr$CTask = (int (**)(void))m_pTargetVehicle;
  v6 = *(_QWORD *)&this->m_vTargetDoorPos.x;
  v4[3].m_pParent = (CTask *)LODWORD(this->m_vTargetDoorPos.z);
  v4[4] = v5;
  *(_QWORD *)&v4[2].m_pParent = v6;
  if ( m_pTargetVehicle )
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)&v4[2]);
  return v4;
}
// 66AFF8: using guessed type void *off_66AFF8;

//----- (00506B7C) --------------------------------------------------------
int __fastcall CTaskSimpleCarAlign::GetTaskType(const CTaskSimpleCarAlign *this)
{
  return 801;
}

//----- (00506B84) --------------------------------------------------------
CTask *__fastcall CTaskSimpleCarOpenDoorFromOutside::Clone(const CTaskSimpleCarOpenDoorFromOutside *this)
{
  CTaskSimple *v2; // r0
  __int64 v3; // kr00_8
  CTaskSimple *v4; // r4
  CTaskUtilityLineUpPedWithCar *m_pUtility; // r9

  v2 = (CTaskSimple *)CTask::operator new(0x24u);
  v3 = *(_QWORD *)&this->m_pTargetVehicle;
  v4 = v2;
  m_pUtility = this->m_pUtility;
  LOBYTE(this) = this->m_bQuitAfterOpeningDoor;
  CTaskSimple::CTaskSimple(v2);
  LOBYTE(v4[1]._vptr$CTask) = 0;
  v4[1].m_pParent = 0;
  v4[2].m_pParent = (CTask *)HIDWORD(v3);
  LOBYTE(v4[3]._vptr$CTask) = (_BYTE)this;
  BYTE1(v4[3]._vptr$CTask) = 0;
  v4[3].m_pParent = (CTask *)m_pUtility;
  v4[4]._vptr$CTask = 0;
  v4->_vptr$CTask = (int (**)(void))&off_66B02C;
  v4[2]._vptr$CTask = (int (**)(void))v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)&v4[2]);
  return v4;
}
// 66B02C: using guessed type void *off_66B02C;

//----- (00506BE0) --------------------------------------------------------
int __fastcall CTaskSimpleCarOpenDoorFromOutside::GetTaskType(const CTaskSimpleCarOpenDoorFromOutside *this)
{
  return 802;
}

//----- (00506BE8) --------------------------------------------------------
CTask *__fastcall CTaskSimpleCarOpenLockedDoorFromOutside::Clone(const CTaskSimpleCarOpenLockedDoorFromOutside *this)
{
  CTaskSimple *v2; // r0
  __int64 v3; // kr00_8
  CTaskSimple *v4; // r4
  CTaskUtilityLineUpPedWithCar *m_pUtility; // r6

  v2 = (CTaskSimple *)CTask::operator new(0x1Cu);
  v3 = *(_QWORD *)&this->m_pTargetVehicle;
  v4 = v2;
  m_pUtility = this->m_pUtility;
  CTaskSimple::CTaskSimple(v2);
  LOBYTE(v4[1]._vptr$CTask) = 0;
  v4[1].m_pParent = 0;
  v4[2].m_pParent = (CTask *)HIDWORD(v3);
  v4[3]._vptr$CTask = (int (**)(void))m_pUtility;
  v4->_vptr$CTask = (int (**)(void))&off_66B060;
  v4[2]._vptr$CTask = (int (**)(void))v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)&v4[2]);
  return v4;
}
// 66B060: using guessed type void *off_66B060;

//----- (00506C38) --------------------------------------------------------
int __fastcall CTaskSimpleCarOpenLockedDoorFromOutside::GetTaskType(
        const CTaskSimpleCarOpenLockedDoorFromOutside *this)
{
  return 803;
}

//----- (00506C40) --------------------------------------------------------
CTask *__fastcall CTaskSimplePickUpBike::Clone(const CTaskSimplePickUpBike *this)
{
  CTaskSimple *v2; // r0
  __int64 v3; // kr00_8
  CTaskSimple *v4; // r4
  CTaskUtilityLineUpPedWithCar *m_pUtility; // r6

  v2 = (CTaskSimple *)CTask::operator new(0x1Cu);
  v3 = *(_QWORD *)&this->m_pTargetVehicle;
  v4 = v2;
  m_pUtility = this->m_pUtility;
  CTaskSimple::CTaskSimple(v2);
  LOBYTE(v4[1]._vptr$CTask) = 0;
  v4[1].m_pParent = 0;
  v4[2].m_pParent = (CTask *)HIDWORD(v3);
  v4[3]._vptr$CTask = (int (**)(void))m_pUtility;
  v4->_vptr$CTask = (int (**)(void))&off_66B094;
  v4[2]._vptr$CTask = (int (**)(void))v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)&v4[2]);
  return v4;
}
// 66B094: using guessed type void *off_66B094;

//----- (00506C90) --------------------------------------------------------
int __fastcall CTaskSimplePickUpBike::GetTaskType(const CTaskSimplePickUpBike *this)
{
  return 804;
}

//----- (00506C98) --------------------------------------------------------
CTask *__fastcall CTaskSimpleCarCloseDoorFromInside::Clone(const CTaskSimpleCarCloseDoorFromInside *this)
{
  CTaskSimple *v2; // r0
  __int64 v3; // kr00_8
  CTaskSimple *v4; // r4
  CTaskUtilityLineUpPedWithCar *m_pUtility; // r6

  v2 = (CTaskSimple *)CTask::operator new(0x1Cu);
  v3 = *(_QWORD *)&this->m_pTargetVehicle;
  v4 = v2;
  m_pUtility = this->m_pUtility;
  CTaskSimple::CTaskSimple(v2);
  LOBYTE(v4[1]._vptr$CTask) = 0;
  v4[1].m_pParent = 0;
  v4[2].m_pParent = (CTask *)HIDWORD(v3);
  v4[3]._vptr$CTask = (int (**)(void))m_pUtility;
  v4->_vptr$CTask = (int (**)(void))&off_66B0C8;
  v4[2]._vptr$CTask = (int (**)(void))v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)&v4[2]);
  return v4;
}
// 66B0C8: using guessed type void *off_66B0C8;

//----- (00506CE8) --------------------------------------------------------
int __fastcall CTaskSimpleCarCloseDoorFromInside::GetTaskType(const CTaskSimpleCarCloseDoorFromInside *this)
{
  return 805;
}

//----- (00506CF0) --------------------------------------------------------
CTask *__fastcall CTaskSimpleCarCloseDoorFromOutside::Clone(const CTaskSimpleCarCloseDoorFromOutside *this)
{
  CTaskSimple *v2; // r0
  __int64 v3; // kr00_8
  CTaskSimple *v4; // r4
  CTaskUtilityLineUpPedWithCar *m_pUtility; // r6

  v2 = (CTaskSimple *)CTask::operator new(0x1Cu);
  v3 = *(_QWORD *)&this->m_pTargetVehicle;
  v4 = v2;
  m_pUtility = this->m_pUtility;
  CTaskSimple::CTaskSimple(v2);
  LOBYTE(v4[1]._vptr$CTask) = 0;
  v4[1].m_pParent = 0;
  v4[2].m_pParent = (CTask *)HIDWORD(v3);
  v4[3]._vptr$CTask = (int (**)(void))m_pUtility;
  v4->_vptr$CTask = (int (**)(void))&off_66B0FC;
  v4[2]._vptr$CTask = (int (**)(void))v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)&v4[2]);
  return v4;
}
// 66B0FC: using guessed type void *off_66B0FC;

//----- (00506D40) --------------------------------------------------------
int __fastcall CTaskSimpleCarCloseDoorFromOutside::GetTaskType(const CTaskSimpleCarCloseDoorFromOutside *this)
{
  return 806;
}

//----- (00506D48) --------------------------------------------------------
CTask *__fastcall CTaskSimpleCarGetIn::Clone(const CTaskSimpleCarGetIn *this)
{
  CTaskSimple *v2; // r0
  __int64 v3; // kr00_8
  CTaskSimple *v4; // r4
  CTaskUtilityLineUpPedWithCar *m_pUtility; // r6

  v2 = (CTaskSimple *)CTask::operator new(0x24u);
  v3 = *(_QWORD *)&this->m_pTargetVehicle;
  v4 = v2;
  m_pUtility = this->m_pUtility;
  CTaskSimple::CTaskSimple(v2);
  LOBYTE(v4[1]._vptr$CTask) = 0;
  v4[1].m_pParent = 0;
  v4[3].m_pParent = (CTask *)HIDWORD(v3);
  v4[4]._vptr$CTask = (int (**)(void))m_pUtility;
  v4->_vptr$CTask = (int (**)(void))&off_66B130;
  v4[3]._vptr$CTask = (int (**)(void))v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)&v4[3]);
  return v4;
}
// 66B130: using guessed type void *off_66B130;

//----- (00506D98) --------------------------------------------------------
int __fastcall CTaskSimpleCarGetIn::GetTaskType(const CTaskSimpleCarGetIn *this)
{
  return 807;
}

//----- (00506DA0) --------------------------------------------------------
CTask *__fastcall CTaskSimpleCarShuffle::Clone(const CTaskSimpleCarShuffle *this)
{
  CTaskSimple *v2; // r0
  __int64 v3; // kr00_8
  CTaskSimple *v4; // r4
  CTaskUtilityLineUpPedWithCar *m_pUtility; // r6

  v2 = (CTaskSimple *)CTask::operator new(0x1Cu);
  v3 = *(_QWORD *)&this->m_pTargetVehicle;
  v4 = v2;
  m_pUtility = this->m_pUtility;
  CTaskSimple::CTaskSimple(v2);
  LOBYTE(v4[1]._vptr$CTask) = 0;
  v4[1].m_pParent = 0;
  v4[2].m_pParent = (CTask *)HIDWORD(v3);
  v4[3]._vptr$CTask = (int (**)(void))m_pUtility;
  v4->_vptr$CTask = (int (**)(void))&off_66B164;
  v4[2]._vptr$CTask = (int (**)(void))v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)&v4[2]);
  return v4;
}
// 66B164: using guessed type void *off_66B164;

//----- (00506DF0) --------------------------------------------------------
int __fastcall CTaskSimpleCarShuffle::GetTaskType(const CTaskSimpleCarShuffle *this)
{
  return 808;
}

//----- (00506DF8) --------------------------------------------------------
CTask *__fastcall CTaskSimpleCarWaitToSlowDown::Clone(const CTaskSimpleCarWaitToSlowDown *this)
{
  CTaskSimple *v2; // r0
  CVehicle *m_pTargetVehicle; // r5
  CTaskSimple *v4; // r4
  int m_iSlowType; // r6

  v2 = (CTaskSimple *)CTask::operator new(0x14u);
  m_pTargetVehicle = this->m_pTargetVehicle;
  v4 = v2;
  m_iSlowType = this->m_iSlowType;
  CTaskSimple::CTaskSimple(v2);
  v4[2]._vptr$CTask = (int (**)(void))m_iSlowType;
  v4->_vptr$CTask = (int (**)(void))&off_66B198;
  v4[1]._vptr$CTask = (int (**)(void))m_pTargetVehicle;
  if ( m_pTargetVehicle )
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)&v4[1]);
  return v4;
}
// 66B198: using guessed type void *off_66B198;

//----- (00506E3C) --------------------------------------------------------
int __fastcall CTaskSimpleCarWaitToSlowDown::GetTaskType(const CTaskSimpleCarWaitToSlowDown *this)
{
  return 809;
}

//----- (00506E44) --------------------------------------------------------
CTask *__fastcall CTaskSimpleCarWaitForDoorNotToBeInUse::Clone(const CTaskSimpleCarWaitForDoorNotToBeInUse *this)
{
  CTaskSimple *v2; // r0
  __int64 v3; // kr00_8
  CTaskSimple *v4; // r4
  int m_iTargetDoorOpposite; // r6

  v2 = (CTaskSimple *)CTask::operator new(0x14u);
  v3 = *(_QWORD *)&this->m_pTargetVehicle;
  v4 = v2;
  m_iTargetDoorOpposite = this->m_iTargetDoorOpposite;
  CTaskSimple::CTaskSimple(v2);
  v4[1].m_pParent = (CTask *)HIDWORD(v3);
  v4[2]._vptr$CTask = (int (**)(void))m_iTargetDoorOpposite;
  v4->_vptr$CTask = (int (**)(void))&off_66B1CC;
  v4[1]._vptr$CTask = (int (**)(void))v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)&v4[1]);
  return v4;
}
// 66B1CC: using guessed type void *off_66B1CC;

//----- (00506E8C) --------------------------------------------------------
int __fastcall CTaskSimpleCarWaitForDoorNotToBeInUse::GetTaskType(const CTaskSimpleCarWaitForDoorNotToBeInUse *this)
{
  return 810;
}

//----- (00506E92) --------------------------------------------------------
bool __fastcall CTaskSimpleCarWaitForDoorNotToBeInUse::MakeAbortable(
        CTaskSimpleCarWaitForDoorNotToBeInUse *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 1;
}

//----- (00506E96) --------------------------------------------------------
int __fastcall CTaskSimpleCarGoToPointNearDoorUntilDoorNotInUse::GetTaskType(
        const CTaskSimpleCarGoToPointNearDoorUntilDoorNotInUse *this)
{
  return 828;
}

//----- (00506E9C) --------------------------------------------------------
bool __fastcall CTaskSimpleCarGoToPointNearDoorUntilDoorNotInUse::MakeAbortable(
        CTaskSimpleCarGoToPointNearDoorUntilDoorNotInUse *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 1;
}

//----- (00506EA0) --------------------------------------------------------
CTask *__fastcall CTaskSimpleCarSetPedInAsPassenger::Clone(const CTaskSimpleCarSetPedInAsPassenger *this)
{
  char *v2; // r5
  CVehicle *m_pTargetVehicle; // r6
  __int64 v4; // r8

  v2 = (char *)CTask::operator new(0x20u);
  m_pTargetVehicle = this->m_pTargetVehicle;
  v4 = *(_QWORD *)&this->m_iTargetDoor;
  CTaskSimple::CTaskSimple((CTaskSimple *)v2);
  v2[8] = 0;
  *((_DWORD *)v2 + 3) = 0;
  *(_QWORD *)(v2 + 20) = v4;
  v2[28] = 0;
  v2[29] = 0;
  v2[30] = 0;
  *(_DWORD *)v2 = &off_66B234;
  *((_DWORD *)v2 + 4) = m_pTargetVehicle;
  if ( m_pTargetVehicle )
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v2 + 4);
  v2[28] = this->m_bWarpingInToCar;
  v2[29] = this->m_nDoorFlagsToClear;
  v2[30] = this->m_nNumGettingInToClear;
  return (CTask *)v2;
}
// 66B234: using guessed type void *off_66B234;

//----- (00506F04) --------------------------------------------------------
int __fastcall CTaskSimpleCarSetPedInAsPassenger::GetTaskType(const CTaskSimpleCarSetPedInAsPassenger *this)
{
  return 811;
}

//----- (00506F0A) --------------------------------------------------------
bool __fastcall CTaskSimpleCarSetPedInAsPassenger::MakeAbortable(
        CTaskSimpleCarSetPedInAsPassenger *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 0;
}

//----- (00506F10) --------------------------------------------------------
CTask *__fastcall CTaskSimpleCarSetPedInAsDriver::Clone(const CTaskSimpleCarSetPedInAsDriver *this)
{
  void *v2; // r5
  __int64 v3; // kr00_8

  v2 = CTask::operator new(0x1Cu);
  v3 = *(_QWORD *)&this->m_pTargetVehicle;
  CTaskSimple::CTaskSimple((CTaskSimple *)v2);
  *((_BYTE *)v2 + 8) = 0;
  *((_DWORD *)v2 + 3) = 0;
  *((_DWORD *)v2 + 5) = HIDWORD(v3);
  *((_BYTE *)v2 + 24) = 0;
  *((_BYTE *)v2 + 25) = 0;
  *((_BYTE *)v2 + 26) = 0;
  *(_DWORD *)v2 = &off_66B268;
  *((_DWORD *)v2 + 4) = v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)v2 + 4);
  *((_BYTE *)v2 + 24) = this->m_bWarpingInToCar;
  *((_BYTE *)v2 + 25) = this->m_nDoorFlagsToClear;
  *((_BYTE *)v2 + 26) = this->m_nNumGettingInToClear;
  return (CTask *)v2;
}
// 66B268: using guessed type void *off_66B268;

//----- (00506F70) --------------------------------------------------------
int __fastcall CTaskSimpleCarSetPedInAsDriver::GetTaskType(const CTaskSimpleCarSetPedInAsDriver *this)
{
  return 812;
}

//----- (00506F76) --------------------------------------------------------
bool __fastcall CTaskSimpleCarSetPedInAsDriver::MakeAbortable(
        CTaskSimpleCarSetPedInAsDriver *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 0;
}

//----- (00506F7C) --------------------------------------------------------
CTask *__fastcall CTaskSimpleCarGetOut::Clone(const CTaskSimpleCarGetOut *this)
{
  CTaskSimple *v2; // r0
  __int64 v3; // kr00_8
  CTaskSimple *v4; // r4
  CTaskUtilityLineUpPedWithCar *m_pUtility; // r6

  v2 = (CTaskSimple *)CTask::operator new(0x20u);
  v3 = *(_QWORD *)&this->m_pTargetVehicle;
  v4 = v2;
  m_pUtility = this->m_pUtility;
  CTaskSimple::CTaskSimple(v2);
  LOWORD(v4[1]._vptr$CTask) = 0;
  v4[1].m_pParent = 0;
  LOBYTE(v4[2]._vptr$CTask) = 0;
  v4[3]._vptr$CTask = (int (**)(void))HIDWORD(v3);
  v4[3].m_pParent = (CTask *)m_pUtility;
  v4->_vptr$CTask = (int (**)(void))&off_66B29C;
  v4[2].m_pParent = (CTask *)v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)&v4[2].m_pParent);
  return v4;
}
// 66B29C: using guessed type void *off_66B29C;

//----- (00506FCC) --------------------------------------------------------
int __fastcall CTaskSimpleCarGetOut::GetTaskType(const CTaskSimpleCarGetOut *this)
{
  return 813;
}

//----- (00506FD4) --------------------------------------------------------
CTask *__fastcall CTaskSimpleCarJumpOut::Clone(const CTaskSimpleCarJumpOut *this)
{
  void *v2; // r4
  CVehicle *m_pTargetVehicle; // r5
  int m_iTargetDoor; // r8
  CTaskUtilityLineUpPedWithCar *m_pUtility; // r6
  float *v6; // r0

  v2 = CTask::operator new(0x24u);
  m_pTargetVehicle = this->m_pTargetVehicle;
  m_iTargetDoor = this->m_iTargetDoor;
  m_pUtility = this->m_pUtility;
  CTaskSimple::CTaskSimple((CTaskSimple *)v2);
  *((_BYTE *)v2 + 8) = 0;
  *((_DWORD *)v2 + 3) = 0;
  *((_DWORD *)v2 + 5) = 0;
  *((_DWORD *)v2 + 6) = m_iTargetDoor;
  *((_BYTE *)v2 + 28) = 0;
  *((_BYTE *)v2 + 29) = 0;
  *((_DWORD *)v2 + 8) = m_pUtility;
  *(_DWORD *)v2 = &off_66B2D0;
  *((_DWORD *)v2 + 4) = m_pTargetVehicle;
  if ( m_pTargetVehicle )
  {
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v2 + 4);
    v6 = (float *)*((_DWORD *)v2 + 4);
    *((float *)v2 + 5) = sqrtf((float)((float)(v6[18] * v6[18]) + (float)(v6[19] * v6[19])) + (float)(v6[20] * v6[20]));
  }
  return (CTask *)v2;
}
// 66B2D0: using guessed type void *off_66B2D0;

//----- (00507054) --------------------------------------------------------
int __fastcall CTaskSimpleCarJumpOut::GetTaskType(const CTaskSimpleCarJumpOut *this)
{
  return 814;
}

//----- (0050705C) --------------------------------------------------------
CTask *__fastcall CTaskSimpleCarForcePedOut::Clone(const CTaskSimpleCarForcePedOut *this)
{
  void *v2; // r4
  __int64 v3; // kr00_8

  v2 = CTask::operator new(0x10u);
  v3 = *(_QWORD *)&this->m_pTargetVehicle;
  CTaskSimple::CTaskSimple((CTaskSimple *)v2);
  *((_DWORD *)v2 + 3) = HIDWORD(v3);
  *(_DWORD *)v2 = &off_66B304;
  *((_DWORD *)v2 + 2) = v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)v2 + 2);
  return (CTask *)v2;
}
// 66B304: using guessed type void *off_66B304;

//----- (005070A0) --------------------------------------------------------
int __fastcall CTaskSimpleCarForcePedOut::GetTaskType(const CTaskSimpleCarForcePedOut *this)
{
  return 815;
}

//----- (005070A6) --------------------------------------------------------
bool __fastcall CTaskSimpleCarForcePedOut::MakeAbortable(
        CTaskSimpleCarForcePedOut *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 0;
}

//----- (005070AC) --------------------------------------------------------
CTask *__fastcall CTaskSimpleCarSetPedOut::Clone(const CTaskSimpleCarSetPedOut *this)
{
  CTaskSimple *v2; // r0
  __int64 v3; // kr00_8
  CTaskSimple *v4; // r5
  bool m_bSwitchOffEngine; // r9

  v2 = (CTaskSimple *)CTask::operator new(0x18u);
  v3 = *(_QWORD *)&this->m_pTargetVehicle;
  v4 = v2;
  m_bSwitchOffEngine = this->m_bSwitchOffEngine;
  CTaskSimple::CTaskSimple(v2);
  v4[1].m_pParent = (CTask *)HIDWORD(v3);
  LOBYTE(v4[2]._vptr$CTask) = m_bSwitchOffEngine;
  BYTE1(v4[2].m_pParent) = 0;
  *(int (***)(void))((char *)&v4[2]._vptr$CTask + 1) = 0;
  v4->_vptr$CTask = (int (**)(void))&off_66B338;
  v4[1]._vptr$CTask = (int (**)(void))v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)&v4[1]);
  BYTE1(v4[2]._vptr$CTask) = this->m_bWarpingOutOfCar;
  BYTE2(v4[2]._vptr$CTask) = this->m_bFallingOutOfCar;
  HIBYTE(v4[2]._vptr$CTask) = this->m_bKnockedOffBike;
  LOBYTE(v4[2].m_pParent) = this->m_nDoorFlagsToClear;
  BYTE1(v4[2].m_pParent) = this->m_nNumGettingInToClear;
  return v4;
}
// 66B338: using guessed type void *off_66B338;

//----- (00507118) --------------------------------------------------------
int __fastcall CTaskSimpleCarSetPedOut::GetTaskType(const CTaskSimpleCarSetPedOut *this)
{
  return 816;
}

//----- (0050711E) --------------------------------------------------------
bool __fastcall CTaskSimpleCarSetPedOut::MakeAbortable(
        CTaskSimpleCarSetPedOut *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 0;
}

//----- (00507124) --------------------------------------------------------
CTask *__fastcall CTaskSimpleCarSlowDragPedOut::Clone(const CTaskSimpleCarSlowDragPedOut *this)
{
  char *v2; // r4
  CVehicle *m_pTargetVehicle; // r5
  __int64 v4; // r8

  v2 = (char *)CTask::operator new(0x20u);
  m_pTargetVehicle = this->m_pTargetVehicle;
  v4 = *(_QWORD *)&this->m_iTargetDoor;
  LOBYTE(this) = this->m_bQuitAfterDraggingPedOut;
  CTaskSimple::CTaskSimple((CTaskSimple *)v2);
  v2[8] = 0;
  *((_DWORD *)v2 + 3) = 0;
  *(_QWORD *)(v2 + 20) = v4;
  v2[28] = (char)this;
  *(_DWORD *)v2 = &off_66B36C;
  *((_DWORD *)v2 + 4) = m_pTargetVehicle;
  if ( m_pTargetVehicle )
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v2 + 4);
  return (CTask *)v2;
}
// 66B36C: using guessed type void *off_66B36C;

//----- (00507178) --------------------------------------------------------
int __fastcall CTaskSimpleCarSlowDragPedOut::GetTaskType(const CTaskSimpleCarSlowDragPedOut *this)
{
  return 820;
}

//----- (00507180) --------------------------------------------------------
CTask *__fastcall CTaskSimpleCarSlowBeDraggedOut::Clone(const CTaskSimpleCarSlowBeDraggedOut *this)
{
  CTaskSimple *v2; // r0
  __int64 v3; // kr00_8
  CTaskSimple *v4; // r4
  CTaskUtilityLineUpPedWithCar *m_pUtility; // r6

  v2 = (CTaskSimple *)CTask::operator new(0x20u);
  v3 = *(_QWORD *)&this->m_pTargetVehicle;
  v4 = v2;
  m_pUtility = this->m_pUtility;
  CTaskSimple::CTaskSimple(v2);
  LOBYTE(v4[1]._vptr$CTask) = 0;
  v4[1].m_pParent = 0;
  v4[2].m_pParent = (CTask *)HIDWORD(v3);
  LOBYTE(v4[3]._vptr$CTask) = 0;
  BYTE1(v4[3]._vptr$CTask) = 0;
  v4[3].m_pParent = (CTask *)m_pUtility;
  v4->_vptr$CTask = (int (**)(void))&off_66B3A0;
  v4[2]._vptr$CTask = (int (**)(void))v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)&v4[2]);
  return v4;
}
// 66B3A0: using guessed type void *off_66B3A0;

//----- (005071D4) --------------------------------------------------------
int __fastcall CTaskSimpleCarSlowBeDraggedOut::GetTaskType(const CTaskSimpleCarSlowBeDraggedOut *this)
{
  return 821;
}

//----- (005071DC) --------------------------------------------------------
CTask *__fastcall CTaskSimpleCarSetPedSlowDraggedOut::Clone(const CTaskSimpleCarSetPedSlowDraggedOut *this)
{
  void *v2; // r4
  __int64 v3; // kr00_8

  v2 = CTask::operator new(0x10u);
  v3 = *(_QWORD *)&this->m_pTargetVehicle;
  CTaskSimple::CTaskSimple((CTaskSimple *)v2);
  *((_DWORD *)v2 + 3) = HIDWORD(v3);
  *(_DWORD *)v2 = &off_66B3D4;
  *((_DWORD *)v2 + 2) = v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)v2 + 2);
  return (CTask *)v2;
}
// 66B3D4: using guessed type void *off_66B3D4;

//----- (00507220) --------------------------------------------------------
int __fastcall CTaskSimpleCarSetPedSlowDraggedOut::GetTaskType(const CTaskSimpleCarSetPedSlowDraggedOut *this)
{
  return 822;
}

//----- (00507226) --------------------------------------------------------
bool __fastcall CTaskSimpleCarSetPedSlowDraggedOut::MakeAbortable(
        CTaskSimpleCarSetPedSlowDraggedOut *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 0;
}

//----- (0050722C) --------------------------------------------------------
CTask *__fastcall CTaskComplexCarSlowBeDraggedOut::Clone(const CTaskComplexCarSlowBeDraggedOut *this)
{
  CTaskComplex *v2; // r0
  __int64 v3; // kr00_8
  CTaskComplex *v4; // r4

  v2 = (CTaskComplex *)CTask::operator new(0x1Cu);
  v3 = *(_QWORD *)&this->m_pTargetVehicle;
  v4 = v2;
  LOBYTE(this) = this->m_bDraggedBySelf;
  CTaskComplex::CTaskComplex(v2);
  v4[1].m_pParent = (CTask *)HIDWORD(v3);
  LOBYTE(v4[1].m_pSubTask) = (_BYTE)this;
  v4[2]._vptr$CTask = 0;
  v4->_vptr$CTask = (int (**)(void))&off_66B408;
  v4[1]._vptr$CTask = (int (**)(void))v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)&v4[1]);
  return v4;
}
// 66B408: using guessed type void *off_66B408;

//----- (0050727C) --------------------------------------------------------
int __fastcall CTaskComplexCarSlowBeDraggedOut::GetTaskType(const CTaskComplexCarSlowBeDraggedOut *this)
{
  return 823;
}

//----- (00507284) --------------------------------------------------------
CTask *__fastcall CTaskComplexCarSlowBeDraggedOutAndStandUp::Clone(
        const CTaskComplexCarSlowBeDraggedOutAndStandUp *this)
{
  void *v2; // r4
  __int64 v3; // kr00_8

  v2 = CTask::operator new(0x14u);
  v3 = *(_QWORD *)&this->m_pTargetVehicle;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_DWORD *)v2 + 4) = HIDWORD(v3);
  *(_DWORD *)v2 = &off_66B444;
  *((_DWORD *)v2 + 3) = v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)v2 + 3);
  return (CTask *)v2;
}
// 66B444: using guessed type void *off_66B444;

//----- (005072C8) --------------------------------------------------------
int __fastcall CTaskComplexCarSlowBeDraggedOutAndStandUp::GetTaskType(
        const CTaskComplexCarSlowBeDraggedOutAndStandUp *this)
{
  return 824;
}

//----- (005072D0) --------------------------------------------------------
CTask *__fastcall CTaskSimpleBikeJacked::Clone(const CTaskSimpleBikeJacked *this)
{
  void *v2; // r4
  CVehicle *m_pTargetVehicle; // r8
  int m_iTargetDoor; // r9
  int m_iDownTime; // r10
  CPed *m_pDraggingPed; // r5

  v2 = CTask::operator new(0x2Cu);
  m_pTargetVehicle = this->m_pTargetVehicle;
  m_iTargetDoor = this->m_iTargetDoor;
  m_iDownTime = this->m_iDownTime;
  m_pDraggingPed = this->m_pDraggingPed;
  LOBYTE(this) = this->m_bWasDriver;
  CTaskSimple::CTaskSimple((CTaskSimple *)v2);
  *((_BYTE *)v2 + 8) = 0;
  *((_DWORD *)v2 + 3) = 0;
  *((_DWORD *)v2 + 4) = 191;
  *((_DWORD *)v2 + 6) = m_iTargetDoor;
  *((_DWORD *)v2 + 7) = m_iDownTime;
  *((_BYTE *)v2 + 36) = (_BYTE)this;
  *((_DWORD *)v2 + 10) = 0;
  *(_DWORD *)v2 = &off_66B480;
  *((_DWORD *)v2 + 8) = m_pDraggingPed;
  *((_DWORD *)v2 + 5) = m_pTargetVehicle;
  if ( m_pTargetVehicle )
  {
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v2 + 5);
    m_pDraggingPed = (CPed *)*((_DWORD *)v2 + 8);
  }
  if ( m_pDraggingPed )
    CEntity::RegisterReference(m_pDraggingPed, (CEntity **)v2 + 8);
  return (CTask *)v2;
}
// 66B480: using guessed type void *off_66B480;

//----- (00507348) --------------------------------------------------------
int __fastcall CTaskSimpleBikeJacked::GetTaskType(const CTaskSimpleBikeJacked *this)
{
  return 826;
}

//----- (00507350) --------------------------------------------------------
CTask *__fastcall CTaskSimpleCarFallOut::Clone(const CTaskSimpleCarFallOut *this)
{
  CTaskSimple *v2; // r0
  __int64 v3; // kr00_8
  CTaskSimple *v4; // r4
  CTaskUtilityLineUpPedWithCar *m_pUtility; // r6

  v2 = (CTaskSimple *)CTask::operator new(0x1Cu);
  v3 = *(_QWORD *)&this->m_pTargetVehicle;
  v4 = v2;
  m_pUtility = this->m_pUtility;
  CTaskSimple::CTaskSimple(v2);
  LOBYTE(v4[1]._vptr$CTask) = 0;
  v4[1].m_pParent = 0;
  v4[2].m_pParent = (CTask *)HIDWORD(v3);
  v4[3]._vptr$CTask = (int (**)(void))m_pUtility;
  v4->_vptr$CTask = (int (**)(void))&off_66B4B4;
  v4[2]._vptr$CTask = (int (**)(void))v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)&v4[2]);
  return v4;
}
// 66B4B4: using guessed type void *off_66B4B4;

//----- (005073A0) --------------------------------------------------------
int __fastcall CTaskSimpleCarFallOut::GetTaskType(const CTaskSimpleCarFallOut *this)
{
  return 834;
}

//----- (005073A8) --------------------------------------------------------
CTask *__fastcall CTaskSimpleSetPedAsAutoDriver::Clone(const CTaskSimpleSetPedAsAutoDriver *this)
{
  void *v2; // r4
  CVehicle *m_pTargetVehicle; // r5

  v2 = CTask::operator new(0xCu);
  m_pTargetVehicle = this->m_pTargetVehicle;
  CTaskSimple::CTaskSimple((CTaskSimple *)v2);
  *(_DWORD *)v2 = &off_66B4E8;
  *((_DWORD *)v2 + 2) = m_pTargetVehicle;
  if ( m_pTargetVehicle )
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v2 + 2);
  return (CTask *)v2;
}
// 66B4E8: using guessed type void *off_66B4E8;

//----- (005073E0) --------------------------------------------------------
int __fastcall CTaskSimpleSetPedAsAutoDriver::GetTaskType(const CTaskSimpleSetPedAsAutoDriver *this)
{
  return 827;
}

//----- (005073E6) --------------------------------------------------------
bool __fastcall CTaskSimpleSetPedAsAutoDriver::MakeAbortable(
        CTaskSimpleSetPedAsAutoDriver *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 0;
}

//----- (005073EC) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToBoatSteeringWheel::Clone(const CTaskComplexGoToBoatSteeringWheel *this)
{
  void *v2; // r4
  CVehicle *m_pTargetVehicle; // r5

  v2 = CTask::operator new(0x24u);
  m_pTargetVehicle = this->m_pTargetVehicle;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_BYTE *)v2 + 28) = 0;
  *((_DWORD *)v2 + 8) = 0;
  *(_DWORD *)v2 = &off_66B51C;
  *((_DWORD *)v2 + 6) = m_pTargetVehicle;
  if ( m_pTargetVehicle )
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v2 + 6);
  return (CTask *)v2;
}
// 66B51C: using guessed type void *off_66B51C;

//----- (0050742C) --------------------------------------------------------
int __fastcall CTaskComplexGoToBoatSteeringWheel::GetTaskType(const CTaskComplexGoToBoatSteeringWheel *this)
{
  return 830;
}

//----- (00507434) --------------------------------------------------------
CTask *__fastcall CTaskComplexGetOnBoatSeat::Clone(const CTaskComplexGetOnBoatSeat *this)
{
  void *v2; // r4
  CVehicle *m_pTargetVehicle; // r5

  v2 = CTask::operator new(0x10u);
  m_pTargetVehicle = this->m_pTargetVehicle;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *(_DWORD *)v2 = &off_66B558;
  *((_DWORD *)v2 + 3) = m_pTargetVehicle;
  if ( m_pTargetVehicle )
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v2 + 3);
  return (CTask *)v2;
}
// 66B558: using guessed type void *off_66B558;

//----- (0050746C) --------------------------------------------------------
int __fastcall CTaskComplexGetOnBoatSeat::GetTaskType(const CTaskComplexGetOnBoatSeat *this)
{
  return 831;
}

//----- (00507474) --------------------------------------------------------
CTask *__fastcall CTaskSimpleCreateCarAndGetIn::Clone(const CTaskSimpleCreateCarAndGetIn *this)
{
  CTaskSimple *v2; // r0
  CTask *m_iDesiredCarModel; // r5
  CTask *result; // r0
  CTask v5; // d16

  v2 = (CTaskSimple *)CTask::operator new(0x34u);
  m_iDesiredCarModel = (CTask *)this->m_iDesiredCarModel;
  CTaskSimple::CTaskSimple(v2);
  result->_vptr$CTask = (int (**)(void))&off_66B594;
  v5 = *(CTask *)&this->m_vPedPos.x;
  result[2]._vptr$CTask = (int (**)(void))LODWORD(this->m_vPedPos.z);
  result[2].m_pParent = m_iDesiredCarModel;
  result[3]._vptr$CTask = 0;
  result[5]._vptr$CTask = 0;
  result[5].m_pParent = 0;
  LOWORD(result[6]._vptr$CTask) = 0;
  result[1] = v5;
  return result;
}
// 507490: variable 'result' is possibly undefined
// 66B594: using guessed type void *off_66B594;

//----- (005074B0) --------------------------------------------------------
int __fastcall CTaskSimpleCreateCarAndGetIn::GetTaskType(const CTaskSimpleCreateCarAndGetIn *this)
{
  return 832;
}

//----- (005074B6) --------------------------------------------------------
bool __fastcall CTaskSimpleCreateCarAndGetIn::MakeAbortable(
        CTaskSimpleCreateCarAndGetIn *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 1;
}

//----- (005074BC) --------------------------------------------------------
CTask *__fastcall CTaskSimpleWaitUntilPedIsOutCar::Clone(const CTaskSimpleWaitUntilPedIsOutCar *this)
{
  void *v2; // r4
  CPed *m_pTargetPed; // r5
  __int64 v4; // d16

  v2 = CTask::operator new(0x1Cu);
  m_pTargetPed = this->m_pTargetPed;
  CTaskSimple::CTaskSimple((CTaskSimple *)v2);
  *((_BYTE *)v2 + 12) = 1;
  *(_DWORD *)v2 = &off_66B5C8;
  *((_DWORD *)v2 + 2) = m_pTargetPed;
  v4 = *(_QWORD *)&this->m_vDir.x;
  *((_DWORD *)v2 + 6) = LODWORD(this->m_vDir.z);
  *((_QWORD *)v2 + 2) = v4;
  if ( m_pTargetPed )
    CEntity::RegisterReference(m_pTargetPed, (CEntity **)v2 + 2);
  return (CTask *)v2;
}
// 66B5C8: using guessed type void *off_66B5C8;

//----- (0050750C) --------------------------------------------------------
int __fastcall CTaskSimpleWaitUntilPedIsOutCar::GetTaskType(const CTaskSimpleWaitUntilPedIsOutCar *this)
{
  return 829;
}

//----- (00507512) --------------------------------------------------------
bool __fastcall CTaskSimpleWaitUntilPedIsOutCar::MakeAbortable(
        CTaskSimpleWaitUntilPedIsOutCar *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 1;
}

//----- (00507518) --------------------------------------------------------
CTask *__fastcall CTaskSimpleWaitUntilPedIsInCar::Clone(const CTaskSimpleWaitUntilPedIsInCar *this)
{
  void *v2; // r4
  CPed *m_pTargetPed; // r5

  v2 = CTask::operator new(0x10u);
  m_pTargetPed = this->m_pTargetPed;
  CTaskSimple::CTaskSimple((CTaskSimple *)v2);
  *((_BYTE *)v2 + 12) = 0;
  *(_DWORD *)v2 = &off_66B5FC;
  *((_DWORD *)v2 + 2) = m_pTargetPed;
  if ( m_pTargetPed )
    CEntity::RegisterReference(m_pTargetPed, (CEntity **)v2 + 2);
  return (CTask *)v2;
}
// 66B5FC: using guessed type void *off_66B5FC;

//----- (00507554) --------------------------------------------------------
int __fastcall CTaskSimpleWaitUntilPedIsInCar::GetTaskType(const CTaskSimpleWaitUntilPedIsInCar *this)
{
  return 833;
}

//----- (0050755A) --------------------------------------------------------
bool __fastcall CTaskSimpleWaitUntilPedIsInCar::MakeAbortable(
        CTaskSimpleWaitUntilPedIsInCar *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 1;
}

//----- (00507560) --------------------------------------------------------
int __fastcall CCarEnterExit::GetNearestCarPassengerDoor(
        const CPed *ped,
        const CVehicle *vehicle,
        CVector *vDoorPos,
        int *iDoor,
        int bRequireSeatNotBeingUsed,
        int bRequireDoorNotBeingUsed,
        int bRequireDoorNotBlocked)
{
  RwReal z; // s16
  RwReal v8; // s17
  RwReal y; // s18
  RwReal v10; // s19
  RwReal x; // s20
  RwReal v12; // s21
  RwReal v13; // s23
  RwReal v14; // s28
  RwReal v15; // s30
  tHandlingData *pHandling; // r0
  _BOOL4 v21; // r5
  __int64 v22; // d16
  CMatrix *v23; // r0
  CSimpleTransform *v24; // r1
  float v25; // s22
  float v26; // s24
  float v27; // s25
  float v28; // s26
  float v29; // s27
  float v30; // s29
  int v31; // r5
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  CMatrix *v34; // r0
  CSimpleTransform *p_m_transform; // r1
  CMatrix *v36; // r0
  CSimpleTransform *v37; // r1
  CMatrix *v38; // r0
  CSimpleTransform *v39; // r1
  CVector v41[9]; // [sp+0h] [bp-70h] BYREF

  pHandling = vehicle->pHandling;
  if ( (unsigned int)pHandling->AnimGroup - 15 <= 1 )
  {
    if ( bRequireDoorNotBeingUsed == 1 && (vehicle->m_nGettingInFlags & 4) != 0 )
      return 0;
    if ( bRequireDoorNotBlocked != 1 || (v21 = 0, CCarEnterExit::IsRoomForPedToLeaveCar(vehicle, 8, 0)) )
    {
      CCarEnterExit::GetPositionToOpenCarDoor(v41, vehicle, 8);
      v22 = *(_QWORD *)&v41[0].x;
      vDoorPos->z = v41[0].z;
      *(_QWORD *)&vDoorPos->x = v22;
      *iDoor = 8;
      return 1;
    }
    return v21;
  }
  if ( vehicle->m_baseVehicleType == 9 || (pHandling->mFlags & 0x200) != 0 )
  {
    if ( bRequireSeatNotBeingUsed == 1 && vehicle->pPassengers[0] )
    {
      v25 = 999.0;
      v31 = 0;
      v26 = 999.0;
LABEL_42:
      v28 = 999.0;
      v21 = v31 != 0;
      v27 = 999.0;
      goto LABEL_45;
    }
    if ( bRequireDoorNotBeingUsed == 1 && (vehicle->m_nGettingInFlags & 2) != 0 )
    {
      v25 = 999.0;
      v31 = 0;
    }
    else
    {
      if ( bRequireDoorNotBlocked != 1 || (v31 = 0, CCarEnterExit::IsRoomForPedToLeaveCar(vehicle, 11, 0)) )
      {
        CCarEnterExit::GetPositionToOpenCarDoor(v41, vehicle, 11);
        m_pMat = ped->m_pMat;
        v31 = 1;
        x = v41[0].x;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        y = v41[0].y;
        z = v41[0].z;
        if ( !m_pMat )
          p_tx = &ped->m_transform;
        v26 = v41[0].x - p_tx->m_translate.x;
        v25 = v41[0].y - p_tx->m_translate.y;
        if ( bRequireSeatNotBeingUsed != 1 )
          goto LABEL_35;
        goto LABEL_34;
      }
      v25 = 999.0;
    }
    v26 = 999.0;
    if ( bRequireSeatNotBeingUsed != 1 )
      goto LABEL_35;
LABEL_34:
    if ( vehicle->pPassengers[0] )
      goto LABEL_42;
LABEL_35:
    if ( (bRequireDoorNotBeingUsed != 1 || (vehicle->m_nGettingInFlags & 8) == 0)
      && (bRequireDoorNotBlocked != 1 || CCarEnterExit::IsRoomForPedToLeaveCar(vehicle, 9, 0)) )
    {
      CCarEnterExit::GetPositionToOpenCarDoor(v41, vehicle, 9);
      v34 = ped->m_pMat;
      v21 = 1;
      v13 = v41[0].x;
      p_m_transform = (CSimpleTransform *)&v34->tx;
      v12 = v41[0].y;
      v10 = v41[0].z;
      if ( !v34 )
        p_m_transform = &ped->m_transform;
      v28 = 999.0;
      v30 = v41[0].x - p_m_transform->m_translate.x;
      v29 = v41[0].y - p_m_transform->m_translate.y;
      v27 = 999.0;
      goto LABEL_46;
    }
    goto LABEL_42;
  }
  if ( bRequireSeatNotBeingUsed == 1 && vehicle->pPassengers[0]
    || bRequireDoorNotBeingUsed == 1 && (vehicle->m_nGettingInFlags & 4) != 0 )
  {
    v28 = 999.0;
    v21 = 0;
  }
  else
  {
    if ( bRequireDoorNotBlocked != 1 || (v21 = 0, CCarEnterExit::IsRoomForPedToLeaveCar(vehicle, 8, 0)) )
    {
      CCarEnterExit::GetPositionToOpenCarDoor(v41, vehicle, 8);
      v23 = ped->m_pMat;
      v21 = 1;
      v8 = v41[0].x;
      v24 = (CSimpleTransform *)&v23->tx;
      v15 = v41[0].y;
      v14 = v41[0].z;
      if ( !v23 )
        v24 = &ped->m_transform;
      v25 = 999.0;
      v26 = 999.0;
      v27 = v41[0].x - v24->m_translate.x;
      v28 = v41[0].y - v24->m_translate.y;
      v29 = 999.0;
      v30 = 999.0;
      goto LABEL_46;
    }
    v28 = 999.0;
  }
  v27 = 999.0;
  v25 = 999.0;
  v26 = 999.0;
LABEL_45:
  v29 = 999.0;
  v30 = 999.0;
LABEL_46:
  if ( SLOBYTE(CModelInfo::ms_modelInfoPtrs[vehicle->m_nModelIndex][1].m_pColModel) >= 3 )
  {
    if ( ((vehicle->pHandling->mFlags & 0x8000) == 0
       || !vehicle->m_baseVehicleType && vehicle[1].m_aCollisionRecordPtrs[5])
      && (bRequireSeatNotBeingUsed != 1 || !vehicle->pPassengers[1])
      && (bRequireDoorNotBeingUsed != 1 || (vehicle->m_nGettingInFlags & 2) == 0)
      && (bRequireDoorNotBlocked != 1 || CCarEnterExit::IsRoomForPedToLeaveCar(vehicle, 11, 0)) )
    {
      CCarEnterExit::GetPositionToOpenCarDoor(v41, vehicle, 11);
      v36 = ped->m_pMat;
      v21 = 1;
      x = v41[0].x;
      v37 = (CSimpleTransform *)&v36->tx;
      y = v41[0].y;
      z = v41[0].z;
      if ( !v36 )
        v37 = &ped->m_transform;
      v26 = v41[0].x - v37->m_translate.x;
      v25 = v41[0].y - v37->m_translate.y;
    }
    if ( ((vehicle->pHandling->mFlags & 0x8000) == 0
       || !vehicle->m_baseVehicleType && vehicle[1].m_aCollisionRecordPtrs[3])
      && (bRequireSeatNotBeingUsed != 1 || !vehicle->pPassengers[2])
      && (bRequireDoorNotBeingUsed != 1 || (vehicle->m_nGettingInFlags & 8) == 0)
      && (bRequireDoorNotBlocked != 1 || CCarEnterExit::IsRoomForPedToLeaveCar(vehicle, 9, 0)) )
    {
      CCarEnterExit::GetPositionToOpenCarDoor(v41, vehicle, 9);
      v38 = ped->m_pMat;
      v21 = 1;
      v13 = v41[0].x;
      v39 = (CSimpleTransform *)&v38->tx;
      v12 = v41[0].y;
      v10 = v41[0].z;
      if ( !v38 )
        v39 = &ped->m_transform;
      v30 = v41[0].x - v39->m_translate.x;
      v29 = v41[0].y - v39->m_translate.y;
    }
  }
  vDoorPos->x = v8;
  vDoorPos->y = v15;
  vDoorPos->z = v14;
  *iDoor = 8;
  if ( (float)((float)(v25 * v25) + (float)(v26 * v26)) < (float)((float)(v28 * v28) + (float)(v27 * v27)) )
  {
    v28 = v25;
    v27 = v26;
    *iDoor = 11;
    vDoorPos->x = x;
    vDoorPos->y = y;
    vDoorPos->z = z;
  }
  if ( (float)((float)(v29 * v29) + (float)(v30 * v30)) < (float)((float)(v28 * v28) + (float)(v27 * v27)) )
  {
    *iDoor = 9;
    vDoorPos->x = v13;
    vDoorPos->y = v12;
    vDoorPos->z = v10;
  }
  return v21;
}
// 5078A6: variable 'v8' is possibly undefined
// 5078AE: variable 'v15' is possibly undefined
// 5078B6: variable 'v14' is possibly undefined
// 5078DE: variable 'x' is possibly undefined
// 5078E2: variable 'y' is possibly undefined
// 5078E6: variable 'z' is possibly undefined
// 507912: variable 'v13' is possibly undefined
// 507916: variable 'v12' is possibly undefined
// 50791A: variable 'v10' is possibly undefined

//----- (00507950) --------------------------------------------------------
bool __fastcall CCarEnterExit::IsRoomForPedToLeaveCar(
        const CVehicle *vehicle,
        const int iDoor,
        CVector *pvecCarJackOffset)
{
  CBaseModelInfo *v6; // r0
  int v7; // r1
  uint32 v8; // r0
  __int64 v9; // d16
  RwReal v10; // r0
  uint32 m_hashKey; // r0
  __int64 v12; // d16
  RwReal v13; // r0
  int v14; // r1
  uint32 v15; // r0
  __int64 v16; // d16
  RwReal v17; // s16
  RwReal y; // s18
  RwReal v19; // s2
  RwReal z; // r8
  float v21; // s8
  float v22; // s8
  bool v23; // r5
  CEntity *v24; // r0
  _BOOL4 v25; // r0
  float v26; // s16
  int m_nModelIndex; // r0
  bool v28; // zf
  float v29; // s0
  bool v30; // zf
  char v31; // r1
  char v32; // r0
  uint32 v34; // r0
  int v35; // r1
  uint32 v36; // r0
  float x; // s0
  RwReal v38; // r0
  uint32 v39; // r0
  CEntity *refEntityPtr; // [sp+20h] [bp-A0h] BYREF
  CColPoint colPoint; // [sp+24h] [bp-9Ch] BYREF
  CVector v42; // [sp+50h] [bp-70h] BYREF
  CVector vecEnd; // [sp+60h] [bp-60h] BYREF
  CVector v44; // [sp+70h] [bp-50h] BYREF
  CVector vecStart; // [sp+80h] [bp-40h] BYREF
  CVector v; // [sp+90h] [bp-30h] BYREF
  CVector v47; // 0:r0.12

  v6 = CModelInfo::ms_modelInfoPtrs[vehicle->m_nModelIndex];
  refEntityPtr = 0;
  memset(&colPoint, 0, 12);
  if ( vehicle->m_baseVehicleType == 9 || (vehicle->pHandling->mFlags & 0x200) != 0 )
  {
    if ( (iDoor | 2) == 11 )
    {
      m_hashKey = v6[2].m_hashKey;
      v12 = *(_QWORD *)(m_hashKey + 60);
      v13 = *(float *)(m_hashKey + 68);
    }
    else
    {
      v14 = *(_DWORD *)&v6[1].m_modelName[20];
      v15 = v6[2].m_hashKey;
      if ( v14 != 5 )
        v15 += 48;
      v12 = *(_QWORD *)v15;
      v13 = *(float *)(v15 + 8);
    }
    v.z = v13;
    *(_QWORD *)&v.x = v12;
    if ( (iDoor | 1) == 11 )
      v.x = -v.x;
  }
  else
  {
    switch ( iDoor )
    {
      case 8:
        v7 = *(_DWORD *)&v6[1].m_modelName[20];
        v8 = v6[2].m_hashKey;
        if ( v7 != 5 )
          v8 += 48;
        v9 = *(_QWORD *)v8;
        v10 = *(float *)(v8 + 8);
        goto LABEL_51;
      case 9:
        v34 = v6[2].m_hashKey;
        v9 = *(_QWORD *)(v34 + 60);
        v10 = *(float *)(v34 + 68);
LABEL_51:
        v.z = v10;
        *(_QWORD *)&v.x = v9;
        break;
      case 10:
        v35 = *(_DWORD *)&v6[1].m_modelName[20];
        v36 = v6[2].m_hashKey;
        if ( v35 != 5 )
          v36 += 48;
        *(_QWORD *)&v.x = *(_QWORD *)v36;
        x = v.x;
        v38 = *(float *)(v36 + 8);
        goto LABEL_56;
      case 11:
        v39 = v6[2].m_hashKey;
        *(_QWORD *)&v.x = *(_QWORD *)(v39 + 60);
        x = v.x;
        v38 = *(float *)(v39 + 68);
LABEL_56:
        v.z = v38;
        v.x = -x;
        break;
      default:
        return 0;
    }
  }
  operator*(&v44, vehicle->m_pMat, &v);
  vecStart = v44;
  CCarEnterExit::GetPositionToOpenCarDoor(&vecEnd, vehicle, iDoor);
  v44 = vecEnd;
  if ( pvecCarJackOffset )
  {
    v16 = *(_QWORD *)&pvecCarJackOffset->x;
    v42.z = pvecCarJackOffset->z;
    *(_QWORD *)&v42.x = v16;
    if ( (iDoor | 1) == 9 )
      v42.x = -v42.x;
    Multiply3x3(&vecEnd, vehicle->m_pMat, &v42);
    v44.x = vecEnd.x + v44.x;
    v44.y = vecEnd.y + v44.y;
    v44.z = vecEnd.z + v44.z;
  }
  if ( vehicle->m_pMat->zz < 0.0 )
  {
    vecStart.z = vecStart.z + 0.5;
    v44.z = v44.z + 0.5;
  }
  v17 = v44.x;
  y = v44.y;
  if ( vehicle->m_baseVehicleType == 9 )
  {
    v19 = (float)(v44.z + 0.2) + 0.35;
    v44.z = v44.z + 0.2;
    vecEnd = v44;
    z = v19;
    v44.z = v19;
  }
  else
  {
    z = v44.z;
    v21 = sqrtf(
            (float)((float)((float)(v44.x - vecStart.x) * (float)(v44.x - vecStart.x))
                  + (float)((float)(v44.y - vecStart.y) * (float)(v44.y - vecStart.y)))
          + 0.0);
    v22 = (float)(v21 + 0.35) / v21;
    vecEnd.y = vecStart.y + (float)((float)(v44.y - vecStart.y) * v22);
    vecEnd.x = vecStart.x + (float)((float)(v44.x - vecStart.x) * v22);
    vecEnd.z = v44.z;
  }
  v23 = 0;
  if ( CWorld::GetIsLineOfSightClear(&vecStart, &vecEnd, 1, 0, 0, 1, 0, 0, 0) )
  {
    *(_QWORD *)&v47.x = __PAIR64__(LODWORD(y), LODWORD(v17));
    v47.z = z;
    v24 = CWorld::TestSphereAgainstWorld(v47, 0.35, &vehicle->CPhysical, vehicle->m_baseVehicleType != 6, 1, 0, 1, 0, 0);
    if ( v24 && (v24->m_nModelIndex != 608 || vehicle->m_nModelIndex != 577) && v24 != vehicle->m_pAttachToEntity )
      return 0;
    v25 = CWorld::ProcessVerticalLine(&v44, 1000.0, &colPoint, &refEntityPtr, 1, 0, 0, 1, 0, 0, 0);
    v26 = colPoint.m_vecPosition.z;
    if ( v25 && colPoint.m_vecPosition.z > v44.z && colPoint.m_vecPosition.z < (float)(v44.z + 0.6) )
      return 0;
    if ( vehicle->m_baseVehicleType != 5 )
    {
      m_nModelIndex = vehicle->m_nModelIndex;
      if ( m_nModelIndex >= 460 )
      {
        v30 = m_nModelIndex == 539;
        if ( m_nModelIndex != 539 )
          v30 = m_nModelIndex == 460;
        if ( !v30 )
          goto LABEL_37;
      }
      else
      {
        v28 = m_nModelIndex == 417;
        if ( m_nModelIndex != 417 )
          v28 = m_nModelIndex == 447;
        if ( !v28 )
        {
LABEL_37:
          v23 = 0;
          if ( !CWorld::ProcessVerticalLine(&v44, -1000.0, &colPoint, &refEntityPtr, 1, 0, 0, 1, 0, 0, 0) )
            return v23;
          v29 = colPoint.m_vecPosition.z;
          goto LABEL_44;
        }
      }
    }
    v29 = colPoint.m_vecPosition.z + -1.0;
LABEL_44:
    v31 = 0;
    v32 = 0;
    if ( v26 >= v29 )
      v31 = 1;
    if ( v26 == 0.0 )
      v32 = 1;
    return v32 | v31;
  }
  return v23;
}

//----- (00507CF0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
CVector *__fastcall CCarEnterExit::GetPositionToOpenCarDoor(CVector *retstr, const CVehicle *vehicle, const int iDoor)
{
  CBaseModelInfo *v6; // r5
  tHandlingData *pHandling; // r2
  int v8; // r1
  unsigned int AnimGroup; // r0
  float fSeatOffsetDist; // s16
  int v11; // r2
  float x; // r0
  float y; // r1
  float z; // r2
  uint32 m_hashKey; // r6
  float v16; // s0
  RwReal v17; // r3
  uint32 v18; // r1
  float v19; // s0
  float v20; // s2
  float v21; // s4
  __int64 v22; // d16
  float v23; // s4
  float v24; // s0
  float v25; // s2
  RwReal v26; // r2
  float v27; // r3
  float v28; // r0
  uint32 v29; // r1
  __int64 v30; // d16
  RwReal v31; // r1
  int v32; // r1
  uint32 v33; // r5
  CVector *result; // r0
  float v35; // s0
  float v36; // s0
  __int64 v37; // d16
  uint32 v38; // r1
  __int64 v39; // d16
  RwReal v40; // r0
  float v41; // s0
  uint32 v42; // r3
  uint32 v43; // r6
  float v44; // s0
  RwReal v45; // r3
  uint32 v46; // r3
  RwReal v47; // s2
  RwReal v48; // s4
  int32 m_vehicleType; // r0
  bool v50; // zf
  __int64 v51; // d16
  CSimpleTransform *p_m_transform; // r0
  CMatrix *m_pMat; // r1
  float v54; // s4
  float v55; // s10
  RwReal v56; // s2
  float v57; // [sp+0h] [bp-48h]
  CVector v58; // [sp+10h] [bp-38h] BYREF
  CVector v; // [sp+20h] [bp-28h] BYREF

  v6 = CModelInfo::ms_modelInfoPtrs[vehicle->m_nModelIndex];
  if ( vehicle->m_baseVehicleType != 9 )
  {
    pHandling = vehicle->pHandling;
    if ( (pHandling->mFlags & 0x200) == 0 )
    {
      v8 = iDoor | 2;
      AnimGroup = pHandling->AnimGroup;
      if ( __PAIR64__(iDoor | 2u, AnimGroup) == 0xB00000065LL )
      {
        fSeatOffsetDist = 0.0;
      }
      else
      {
        fSeatOffsetDist = pHandling->fSeatOffsetDist;
        if ( v8 == 10 )
        {
          v11 = 0;
LABEL_7:
          CVehicleAnimGroup::ComputeAnimDoorOffsets(
            &v,
            &CVehicleAnimGroupData::m_vehicleAnimGroups[(__int16)AnimGroup],
            v11);
          x = v.x;
          y = v.y;
          z = v.z;
          switch ( iDoor )
          {
            case 8:
              m_hashKey = v6[2].m_hashKey;
              if ( *(_DWORD *)&v6[1].m_modelName[20] != 5 )
                m_hashKey += 48;
              *(_QWORD *)&v.x = *(_QWORD *)m_hashKey;
              v16 = v.x;
              v17 = *(float *)(m_hashKey + 8);
              goto LABEL_35;
            case 9:
              v42 = v6[2].m_hashKey;
              *(_QWORD *)&v.x = *(_QWORD *)(v42 + 60);
              v16 = v.x;
              v17 = *(float *)(v42 + 68);
LABEL_35:
              v41 = fSeatOffsetDist + v16;
              v.z = v17;
              LODWORD(x) ^= 0x80000000;
              goto LABEL_41;
            case 10:
              v43 = v6[2].m_hashKey;
              if ( *(_DWORD *)&v6[1].m_modelName[20] != 5 )
                v43 += 48;
              *(_QWORD *)&v.x = *(_QWORD *)v43;
              v44 = v.x;
              v45 = *(float *)(v43 + 8);
              goto LABEL_40;
            case 11:
              v46 = v6[2].m_hashKey;
              *(_QWORD *)&v.x = *(_QWORD *)(v46 + 60);
              v44 = v.x;
              v45 = *(float *)(v46 + 68);
LABEL_40:
              v41 = -(float)(fSeatOffsetDist + v44);
              v.z = v45;
LABEL_41:
              v.x = v41;
              break;
            default:
              z = 0.0;
              v38 = v6[2].m_hashKey;
              if ( *(_DWORD *)&v6[1].m_modelName[20] != 5 )
                v38 += 48;
              v39 = *(_QWORD *)v38;
              v40 = *(float *)(v38 + 8);
              y = 0.0;
              v.z = v40;
              x = 0.0;
              *(_QWORD *)&v.x = v39;
              v41 = *(float *)&v39;
              break;
          }
          v47 = v.y - y;
          v48 = v.z - z;
          retstr->x = v41 - x;
          retstr->y = v47;
          retstr->z = v48;
          m_vehicleType = vehicle->m_vehicleType;
          if ( m_vehicleType == 1 )
            goto LABEL_46;
          v50 = m_vehicleType == 4;
          if ( m_vehicleType != 4 )
            v50 = (vehicle->pHandling->mFlags & 8) == 0;
          if ( !v50 )
LABEL_46:
            retstr->z = 0.95 - (*((float (__fastcall **)(const CVehicle *))vehicle->_vptr$CPlaceable + 54))(vehicle);
          Multiply3x3(&v58, vehicle->m_pMat, retstr);
          v51 = *(_QWORD *)&v58.x;
          retstr->z = v58.z;
          p_m_transform = &vehicle->m_transform;
          *(_QWORD *)&retstr->x = v51;
          m_pMat = vehicle->m_pMat;
          v54 = retstr->z;
          if ( m_pMat )
            p_m_transform = (CSimpleTransform *)&m_pMat->tx;
          v55 = p_m_transform->m_translate.z;
          v56 = p_m_transform->m_translate.y + retstr->y;
          retstr->x = p_m_transform->m_translate.x + retstr->x;
          retstr->y = v56;
          retstr->z = v55 + v54;
          Multiply3x3(&v58, m_pMat, &v);
          v = v58;
          return (CVector *)vehicle->m_pMat;
        }
      }
      v11 = 2;
      if ( v8 == 11 )
        v11 = 1;
      goto LABEL_7;
    }
  }
  if ( iDoor == 18 )
  {
    CVehicleAnimGroup::ComputeAnimDoorOffsets(
      &v,
      &CVehicleAnimGroupData::m_vehicleAnimGroups[vehicle->pHandling->AnimGroup],
      2);
    v18 = v6[2].m_hashKey;
    v19 = v.x;
    v20 = v.y;
    v21 = v.z;
    if ( *(_DWORD *)&v6[1].m_modelName[20] != 5 )
      v18 += 48;
    v22 = *(_QWORD *)v18;
    v.z = *(RwReal *)(v18 + 8);
    *(_QWORD *)&v.x = v22;
    v23 = v.z - v21;
    v24 = *(float *)&v22 - v19;
    v25 = v20 + *((float *)&v22 + 1);
    goto LABEL_28;
  }
  CVehicleAnimGroup::ComputeAnimDoorOffsets(
    &v,
    &CVehicleAnimGroupData::m_vehicleAnimGroups[vehicle->pHandling->AnimGroup],
    0);
  v26 = v.x;
  v27 = v.y;
  v28 = v.z;
  if ( (iDoor | 2) == 11 )
  {
    v29 = v6[2].m_hashKey;
    v30 = *(_QWORD *)(v29 + 60);
    v31 = *(float *)(v29 + 68);
  }
  else
  {
    v32 = *(_DWORD *)&v6[1].m_modelName[20];
    v33 = v6[2].m_hashKey;
    if ( v32 != 5 )
      v33 += 48;
    v31 = *(float *)(v33 + 8);
    v30 = *(_QWORD *)v33;
  }
  v.z = v31;
  *(_QWORD *)&v.x = v30;
  if ( vehicle->m_baseVehicleType != 9 )
  {
    v35 = vehicle->pHandling->fSeatOffsetDist;
    if ( (iDoor | 1) == 9 )
    {
      LODWORD(v26) ^= 0x80000000;
      v36 = v35 + v.x;
    }
    else
    {
      v36 = v.x - v35;
    }
    v.x = v36;
    v25 = v.y - v27;
    v24 = v36 - v26;
    v23 = v.z - v28;
LABEL_28:
    retstr->x = v24;
    retstr->y = v25;
    retstr->z = v23;
    operator*(&v58, vehicle->m_pMat, retstr);
    v37 = *(_QWORD *)&v58.x;
    result = (CVector *)LODWORD(v58.z);
    retstr->z = v58.z;
    *(_QWORD *)&retstr->x = v37;
    return result;
  }
  if ( (iDoor | 1) == 9 )
    LODWORD(v26) ^= 0x80000000;
  v57 = v28;
  CBike::GetCorrectedWorldDoorPosition((CBike *)vehicle, retstr, *(CVector *)&v26, v);
  return result;
}
// 507CF0: fragmented variable at r2.4 may be wrong
// 507CF0: fragmented variable at r3.4 may be wrong

//----- (0050807C) --------------------------------------------------------
bool __fastcall CCarEnterExit::GetNearestCarDoor(
        const CPed *ped,
        const CVehicle *vehicle,
        CVector *vDoorPos,
        int *iDoor)
{
  CPed *pDriver; // r4
  CVector *v9; // r11
  int32 m_vehicleType; // r0
  CTask *ActiveTask; // r0
  CMatrix *m_pMat; // r4
  CMatrix *v13; // r1
  CSimpleTransform *p_tx; // r0
  CSimpleTransform *p_m_transform; // r2
  float v16; // s16
  float m_heading; // s0
  CVector *v18; // r5
  float v19; // s0
  float v20; // s2
  __int64 v21; // d16
  RwReal z; // r0
  CMatrix *v23; // r0
  CSimpleTransform *v24; // r1
  float y; // s6
  float v26; // s22
  float v27; // s18
  float v28; // s20
  CVehicle *m_pVehicleBeingTowed; // r1
  float v30; // s16
  CPed *v31; // r0
  int v32; // r4
  const CVehicle *v33; // r0
  int v34; // r1
  CVector *v35; // r2
  const CPed *v36; // r0
  bool v37; // zf
  bool result; // r0
  CVector v39; // [sp+0h] [bp-70h] BYREF
  CVector v40; // [sp+10h] [bp-60h] BYREF
  CVector door_pos; // [sp+20h] [bp-50h] BYREF

  pDriver = vehicle->pDriver;
  v9 = (CVector *)vehicle->pPassengers[0];
  CCarEnterExit::GetPositionToOpenCarDoor(&door_pos, vehicle, 10);
  CCarEnterExit::GetPositionToOpenCarDoor(&v40, vehicle, 8);
  m_vehicleType = vehicle->m_vehicleType;
  if ( vehicle->m_baseVehicleType != 9 )
  {
    if ( m_vehicleType == 2 )
      goto LABEL_3;
LABEL_12:
    v18 = 0;
    if ( (*((_BYTE *)&vehicle->m_nVehicleFlags + 1) & 0xA) == 0 )
      v18 = &CCarEnterExit::ms_vecPedQuickDraggedOutCarAnimOffset;
    if ( v9 )
      v9 = v18;
    if ( !pDriver )
      v18 = 0;
    goto LABEL_39;
  }
  if ( m_vehicleType == 10 )
    goto LABEL_12;
LABEL_3:
  ActiveTask = CTaskManager::GetActiveTask(&ped->m_pPedIntelligence->m_taskManager);
  if ( (*((int (__fastcall **)(CTask *))ActiveTask->_vptr$CTask + 5))(ActiveTask) == 700 )
    goto LABEL_38;
  m_pMat = vehicle->m_pMat;
  if ( fabsf(m_pMat->zx) >= 0.1 )
    goto LABEL_38;
  v13 = ped->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &vehicle->m_transform;
  p_m_transform = (CSimpleTransform *)&v13->tx;
  if ( !v13 )
    p_m_transform = &ped->m_transform;
  v16 = atan2f(
          -(float)(p_m_transform->m_translate.x - p_tx->m_translate.x),
          p_m_transform->m_translate.y - p_tx->m_translate.y);
  if ( m_pMat )
    m_heading = atan2f(COERCE_FLOAT(LODWORD(m_pMat->xy) ^ 0x80000000), m_pMat->yy);
  else
    m_heading = vehicle->m_transform.m_heading;
  v19 = v16 - m_heading;
  if ( v19 > 3.1416 )
  {
    v20 = -6.2832;
LABEL_24:
    v19 = v19 + v20;
    goto LABEL_25;
  }
  if ( v19 < -3.1416 )
  {
    v20 = 6.2832;
    goto LABEL_24;
  }
LABEL_25:
  if ( fabsf(v19) >= 0.5236 )
    goto LABEL_38;
  if ( !CPed::IsPlayer(ped) || ped->m_pPlayerData->m_moveBlendRatio <= 1.5 || *iDoor )
  {
    if ( !CPed::IsPlayer(ped) && ped->m_nPedType != 6 && ped->m_eMoveState == PEDMOVE_RUN )
    {
      v18 = 0;
      if ( *iDoor != 18 )
      {
        v9 = 0;
        if ( *iDoor != 0 || ped->m_pPedStats->m_nTemper <= 65 )
          goto LABEL_39;
      }
      goto LABEL_36;
    }
    if ( *iDoor != 18 )
    {
LABEL_38:
      v18 = 0;
      v9 = 0;
      goto LABEL_39;
    }
  }
LABEL_36:
  v18 = 0;
  v9 = 0;
  if ( CCarEnterExit::IsRoomForPedToLeaveCar(vehicle, 18, 0) )
  {
    *iDoor = 18;
    CCarEnterExit::GetPositionToOpenCarDoor(&v39, vehicle, 18);
    v21 = *(_QWORD *)&v39.x;
    z = v39.z;
LABEL_85:
    vDoorPos->z = z;
    result = 1;
    *(_QWORD *)&vDoorPos->x = v21;
    return result;
  }
LABEL_39:
  v23 = ped->m_pMat;
  v24 = (CSimpleTransform *)&v23->tx;
  if ( !v23 )
    v24 = &ped->m_transform;
  y = v24->m_translate.y;
  v26 = v40.x - v24->m_translate.x;
  v27 = v40.y - y;
  v28 = door_pos.x - v24->m_translate.x;
  m_pVehicleBeingTowed = vehicle->m_pVehicleBeingTowed;
  v30 = door_pos.y - y;
  if ( m_pVehicleBeingTowed )
  {
    if ( (float)((float)(v28 * v28) + (float)(v30 * v30)) >= (float)((float)(v26 * v26) + (float)(v27 * v27)) )
    {
      if ( CCarEnterExit::IsPathToDoorBlockedByVehicleCollisionModel(ped, m_pVehicleBeingTowed, &v40) )
      {
        v26 = 999.9;
        v27 = 999.9;
      }
    }
    else if ( CCarEnterExit::IsPathToDoorBlockedByVehicleCollisionModel(ped, m_pVehicleBeingTowed, &door_pos) )
    {
      v28 = 999.9;
      v30 = 999.9;
    }
  }
  if ( (vehicle->pHandling->mFlags & 0x8000) != 0 && !vehicle->m_baseVehicleType )
  {
    if ( vehicle[1].m_aCollisionRecordPtrs[4] )
    {
      if ( vehicle[1].m_aCollisionRecordPtrs[2] )
        goto LABEL_50;
      v32 = 10;
      if ( CCarEnterExit::IsRoomForPedToLeaveCar(vehicle, 10, v18) )
        goto LABEL_83;
    }
    if ( !vehicle[1].m_aCollisionRecordPtrs[2] )
      return 0;
    v33 = vehicle;
    v34 = 8;
    v35 = v18;
    v32 = 8;
    goto LABEL_82;
  }
LABEL_50:
  if ( *iDoor && CCarEnterExit::IsRoomForPedToLeaveCar(vehicle, *iDoor, v18) )
  {
    if ( *iDoor != 8 )
    {
      if ( *iDoor != 10 )
        return 0;
LABEL_84:
      z = door_pos.z;
      v21 = *(_QWORD *)&door_pos.x;
      goto LABEL_85;
    }
LABEL_80:
    v21 = *(_QWORD *)&v40.x;
    z = v40.z;
    goto LABEL_85;
  }
  v31 = vehicle->pDriver;
  if ( v31 && (CPedGroups::AreInSameGroup(v31, ped) || (*((_BYTE *)&vehicle->pDriver->m_nPedFlags + 3) & 0x20) != 0) )
    return 0;
  if ( (*((_BYTE *)&vehicle->m_nVehicleFlags + 1) & 2) == 0
    && (float)((float)(v30 * v30) + (float)(v28 * v28)) >= (float)((float)(v27 * v27) + (float)(v26 * v26)) )
  {
    if ( CCarEnterExit::IsRoomForPedToLeaveCar(vehicle, 8, v9) )
    {
      v36 = vehicle->pPassengers[0];
      v37 = v36 == 0;
      if ( v36 )
        v37 = vehicle->m_baseVehicleType == 9;
      if ( v37
        || (vehicle->pHandling->mFlags & 0x200) != 0
        || !CPedGroups::AreInSameGroup(v36, ped)
        && (*((_BYTE *)&vehicle->pPassengers[0]->m_nPedFlags + 3) & 0x20) == 0
        && vehicle->VehicleCreatedBy != 2
        || (v32 = 10, !CCarEnterExit::IsRoomForPedToLeaveCar(vehicle, 10, v18)) )
      {
        if ( (vehicle->m_nGettingInFlags & 4) == 0
          || (v32 = 10, !CCarEnterExit::IsRoomForPedToLeaveCar(vehicle, 10, v18)) )
        {
          *iDoor = 8;
          goto LABEL_80;
        }
      }
      goto LABEL_83;
    }
    v33 = vehicle;
    v34 = 10;
    v35 = v18;
    v32 = 10;
LABEL_82:
    if ( !CCarEnterExit::IsRoomForPedToLeaveCar(v33, v34, v35) )
      return 0;
LABEL_83:
    *iDoor = v32;
    goto LABEL_84;
  }
  v32 = 10;
  if ( CCarEnterExit::IsRoomForPedToLeaveCar(vehicle, 10, v18) )
    goto LABEL_83;
  if ( CCarEnterExit::IsRoomForPedToLeaveCar(vehicle, 8, v9) )
  {
    *iDoor = 8;
    goto LABEL_80;
  }
  return 0;
}

//----- (0050849C) --------------------------------------------------------
bool __fastcall CCarEnterExit::IsPathToDoorBlockedByVehicleCollisionModel(
        const CPed *ped,
        CVehicle *vehicle,
        const CVector *door_pos)
{
  bool v6; // r6
  CCollisionData *m_pColData; // r5
  CMatrix *m_pMat; // r0
  CMatrix *v9; // r0
  CSimpleTransform *p_tx; // r2
  int m_nNoOfSpheres; // r6
  int v12; // r4
  int v13; // r6
  __int64 v14; // kr00_8
  CColLine v16; // [sp+0h] [bp-B8h] BYREF
  CColSphere sphere; // [sp+20h] [bp-98h] BYREF
  CVector v18; // [sp+38h] [bp-80h] BYREF
  CVector v19; // [sp+48h] [bp-70h] BYREF
  CMatrix output; // [sp+58h] [bp-60h] BYREF

  v6 = 0;
  if ( vehicle->m_nModelIndex != 577 )
  {
    m_pColData = CEntity::GetColModel(vehicle)->m_pColData;
    m_pMat = vehicle->m_pMat;
    output.m_pRwMat = 0;
    output.m_owner = 0;
    Invert(m_pMat, &output);
    v9 = ped->m_pMat;
    p_tx = (CSimpleTransform *)&v9->tx;
    if ( !v9 )
      p_tx = &ped->m_transform;
    CVector::FromMultiply(&v19, &output, &p_tx->m_translate);
    CVector::FromMultiply(&v18, &output, door_pos);
    v16.m_vecStart = v19;
    v16.m_vecEnd.z = v19.z;
    v16.m_vecEnd.x = v18.x;
    v16.m_vecEnd.y = v18.y;
    m_nNoOfSpheres = m_pColData->m_nNoOfSpheres;
    if ( m_nNoOfSpheres < 1 )
    {
      v12 = 0;
    }
    else
    {
      *(_QWORD *)&sphere.m_vecCentre.x = *(_QWORD *)&m_pColData->m_pSphereArray->m_vecCentre.x;
      sphere.m_vecCentre.z = v19.z;
      sphere.m_fRadius = m_pColData->m_pSphereArray->m_fRadius;
      v12 = 0;
      if ( CCollision::TestLineSphere(&v16, &sphere) )
      {
LABEL_9:
        LOWORD(m_nNoOfSpheres) = m_pColData->m_nNoOfSpheres;
      }
      else
      {
        v13 = 32;
        while ( ++v12 < m_pColData->m_nNoOfSpheres )
        {
          v14 = *(_QWORD *)((char *)m_pColData->m_pSphereArray + v13 - 12);
          sphere.m_vecCentre.z = v16.m_vecStart.z;
          *(_QWORD *)&sphere.m_vecCentre.x = v14;
          sphere.m_fRadius = *(float *)((char *)&m_pColData->m_pSphereArray->m_vecCentre.x + v13);
          v13 += 20;
          if ( CCollision::TestLineSphere(&v16, &sphere) )
            goto LABEL_9;
        }
        LOWORD(m_nNoOfSpheres) = m_pColData->m_nNoOfSpheres;
      }
    }
    CMatrix::~CMatrix(&output);
    return v12 != (__int16)m_nNoOfSpheres;
  }
  return v6;
}

//----- (00508588) --------------------------------------------------------
int __fastcall CCarEnterExit::ComputeDoorFlag(const CVehicle *vehicle, const int iDoor, const bool bSettingFlags)
{
  if ( bSettingFlags && (vehicle->m_baseVehicleType == 9 || (vehicle->pHandling->mFlags & 0x200) != 0) )
  {
    if ( (unsigned int)(iDoor - 8) < 0xB )
      return dword_61E460[iDoor - 8];
  }
  else if ( (unsigned int)(iDoor - 8) < 0xB )
  {
    return dword_5085C8[iDoor - 8];
  }
  return 0;
}
// 5085C8: using guessed type int dword_5085C8[10];
// 61E460: using guessed type _DWORD dword_61E460[11];

//----- (005085F8) --------------------------------------------------------
int __fastcall CCarEnterExit::ComputeOppositeDoorFlag(
        const CVehicle *vehicle,
        const int iDoor,
        const bool bSettingFlags)
{
  if ( bSettingFlags && (vehicle->m_baseVehicleType == 9 || (vehicle->pHandling->mFlags & 0x200) != 0) )
  {
    if ( (unsigned int)(iDoor - 8) < 0xB )
      return dword_61E460[iDoor - 8];
  }
  else if ( (unsigned int)(iDoor - 8) < 0xB )
  {
    return dword_508638[iDoor - 8];
  }
  return 0;
}
// 508638: using guessed type int dword_508638[10];
// 61E460: using guessed type _DWORD dword_61E460[11];

//----- (00508668) --------------------------------------------------------
bool __fastcall CCarEnterExit::IsDriverDoorFlag(const CVehicle *vehicle, const uint8 flag, const bool bSettingFlags)
{
  if ( bSettingFlags && (vehicle->m_baseVehicleType == 9 || (vehicle->pHandling->mFlags & 0x200) != 0) )
    return flag == 5;
  if ( flag != 1 )
    return 0;
  return flag;
}

//----- (00508694) --------------------------------------------------------
bool __fastcall CCarEnterExit::IsCarDoorInUse(const CVehicle *vehicle, const int iDoor, const int iDoorOpposite)
{
  char v3; // r12
  char v4; // r1

  v3 = 0;
  switch ( iDoor )
  {
    case 0:
      goto LABEL_9;
    case 8:
      v3 = 4;
      goto LABEL_6;
    case 9:
      v3 = 8;
      goto LABEL_6;
    case 10:
    case 18:
      v3 = 1;
      goto LABEL_6;
    case 11:
      v3 = 2;
      goto LABEL_6;
    default:
LABEL_6:
      v3 = ((unsigned __int8)v3 & vehicle->m_nGettingInFlags) != 0
        || (unsigned __int8)(v3 & vehicle->m_nGettingOutFlags) != 0;
LABEL_9:
      v4 = 0;
      switch ( iDoorOpposite )
      {
        case 0:
          return v3 | v4;
        case 8:
          v4 = 4;
          break;
        case 9:
          v4 = 8;
          break;
        case 10:
        case 18:
          v4 = 1;
          break;
        case 11:
          v4 = 2;
          break;
        default:
          break;
      }
      if ( ((unsigned __int8)v4 & vehicle->m_nGettingInFlags) != 0 )
        return v3 | 1;
      v4 = (unsigned __int8)(v4 & vehicle->m_nGettingOutFlags) != 0;
      return v3 | v4;
  }
}

//----- (00508734) --------------------------------------------------------
bool __fastcall CCarEnterExit::IsCarDoorReady(const CVehicle *vehicle, const int iDoor)
{
  if ( (*((int (__fastcall **)(const CVehicle *))vehicle->_vptr$CPlaceable + 36))(vehicle) )
    return 1;
  else
    return (*((int (__fastcall **)(const CVehicle *, const int))vehicle->_vptr$CPlaceable + 37))(vehicle, iDoor);
}

//----- (0050875E) --------------------------------------------------------
bool __fastcall CCarEnterExit::CarHasDoorToOpen(const CVehicle *vehicle, const int iDoor)
{
  if ( (*((int (__fastcall **)(const CVehicle *))vehicle->_vptr$CPlaceable + 39))(vehicle) )
    return 0;
  else
    return (*((int (__fastcall **)(const CVehicle *, const int))vehicle->_vptr$CPlaceable + 37))(vehicle, iDoor) ^ 1;
}

//----- (0050878A) --------------------------------------------------------
bool __fastcall CCarEnterExit::CarHasDoorToClose(const CVehicle *vehicle, const int iDoor)
{
  if ( (*((int (__fastcall **)(const CVehicle *))vehicle->_vptr$CPlaceable + 39))(vehicle) )
    return 0;
  else
    return (*((int (__fastcall **)(const CVehicle *, const int))vehicle->_vptr$CPlaceable + 38))(vehicle, iDoor) ^ 1;
}

//----- (005087B6) --------------------------------------------------------
bool __fastcall CCarEnterExit::CarHasOpenableDoor(const CVehicle *vehicle, const int iDoor, const CPed *ped)
{
  return CVehicle::CanPedOpenLocks(vehicle, ped) != 0;
}

//----- (005087C8) --------------------------------------------------------
bool __fastcall CCarEnterExit::CarHasPartiallyOpenDoor(const CVehicle *vehicle, const int iDoor)
{
  if ( (*((int (__fastcall **)(const CVehicle *))vehicle->_vptr$CPlaceable + 39))(vehicle)
    || (*((int (__fastcall **)(const CVehicle *, const int))vehicle->_vptr$CPlaceable + 37))(vehicle, iDoor) )
  {
    return 0;
  }
  else
  {
    return (*((int (__fastcall **)(const CVehicle *, const int))vehicle->_vptr$CPlaceable + 38))(vehicle, iDoor) ^ 1;
  }
}

//----- (00508800) --------------------------------------------------------
bool __fastcall CCarEnterExit::IsVehicleHealthy(const CVehicle *vehicle)
{
  return (*(_BYTE *)&vehicle->m_info & 0xF8) != 40;
}

//----- (00508812) --------------------------------------------------------
bool __fastcall CCarEnterExit::IsPedHealthy(const CPed *ped)
{
  return ped->m_nHealth > 0.0;
}

//----- (0050882A) --------------------------------------------------------
bool __fastcall CCarEnterExit::IsCarQuickJackPossible(const CVehicle *vehicle, const int iDoor, const CPed *ped)
{
  bool v4; // zf

  v4 = iDoor == 10;
  if ( iDoor == 10 )
    v4 = vehicle->m_baseVehicleType == 0;
  if ( !v4
    || (*((int (__fastcall **)(const CVehicle *, int))vehicle->_vptr$CPlaceable + 39))(vehicle, 10)
    || (*((int (__fastcall **)(const CVehicle *, int))vehicle->_vptr$CPlaceable + 38))(vehicle, 10) != 1 )
  {
    return 0;
  }
  CVehicle::CanPedOpenLocks(vehicle, ped);
  return 0;
}

//----- (00508870) --------------------------------------------------------
bool __fastcall CCarEnterExit::IsCarSlowJackRequired(const CVehicle *vehicle, const int iDoor, const CPed *ped)
{
  tHandlingData *pHandling; // r0
  bool result; // r0
  int v6; // r1
  CPed *pDriver; // r0

  if ( vehicle->m_baseVehicleType == 9 || (pHandling = vehicle->pHandling, (pHandling->mFlags & 0x200) != 0) )
  {
    result = 0;
    if ( (unsigned int)iDoor > 0x12 )
      return result;
    v6 = 1 << iDoor;
    if ( (v6 & (unsigned int)&stru_404FC.st_value) == 0 )
    {
      if ( (v6 & 0xA00) == 0 )
        return result;
LABEL_17:
      pDriver = vehicle->pPassengers[0];
      return pDriver != 0;
    }
  }
  else
  {
    if ( (unsigned int)pHandling->AnimGroup - 15 > 1 )
    {
      if ( (unsigned int)(iDoor - 8) > 3 )
        return 0;
      switch ( iDoor )
      {
        case 8:
          goto LABEL_17;
        case 9:
          pDriver = vehicle->pPassengers[2];
          break;
        case 10:
          goto LABEL_16;
        case 11:
          pDriver = vehicle->pPassengers[1];
          break;
      }
      return pDriver != 0;
    }
    if ( iDoor != 10 )
      return 0;
  }
LABEL_16:
  pDriver = vehicle->pDriver;
  return pDriver != 0;
}
// 404FC: using guessed type Elf32_Sym stru_404FC;

//----- (005088F0) --------------------------------------------------------
CPed *__fastcall CCarEnterExit::ComputeQuickJackedPed(const CVehicle *vehicle, const int iTargetDoor)
{
  if ( iTargetDoor == 11 )
    return vehicle->pPassengers[1];
  if ( iTargetDoor == 10 )
    return vehicle->pDriver;
  return 0;
}

//----- (0050890C) --------------------------------------------------------
CPed *__fastcall CCarEnterExit::ComputeSlowJackedPed(const CVehicle *vehicle, const int iTargetDoor)
{
  CPed *v2; // r2
  int v3; // r1
  CPed *result; // r0

  if ( vehicle->m_baseVehicleType == 9 || (vehicle->pHandling->mFlags & 0x200) != 0 )
  {
    v2 = 0;
    if ( (unsigned int)iTargetDoor > 0x12 )
      return v2;
    v3 = 1 << iTargetDoor;
    if ( (v3 & (unsigned int)&stru_404FC.st_value) != 0 )
      return vehicle->pDriver;
    if ( (v3 & 0xA00) != 0 )
      return vehicle->pPassengers[0];
    else
      return v2;
  }
  else
  {
    switch ( iTargetDoor )
    {
      case 8:
        return vehicle->pPassengers[0];
      case 9:
        return vehicle->pPassengers[2];
      case 10:
        return vehicle->pDriver;
      case 11:
        result = vehicle->pPassengers[1];
        break;
      default:
        result = 0;
        break;
    }
  }
  return result;
}
// 404FC: using guessed type Elf32_Sym stru_404FC;

//----- (00508974) --------------------------------------------------------
bool __fastcall CCarEnterExit::IsVehicleStealable(const CVehicle *vehicleToSteal, const CPed *ped)
{
  int32 m_baseVehicleType; // r0
  bool v5; // zf
  CPed *pDriver; // r0
  CPedGroup *PedsGroup; // r0
  CColModel *m_pColModel; // r0
  float y; // s0
  float v10; // s2
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float zy; // s6
  float yy; // s4
  float v15; // s0
  float xy; // s2
  float v17; // s4
  RwReal v18; // s2
  RwReal v19; // s0
  int v20; // r0
  bool v21; // zf
  CUpsideDownCarCheck v23; // [sp+24h] [bp-74h] BYREF
  CVector vecStart; // [sp+54h] [bp-44h] BYREF
  CEntity *refEntityPtr; // [sp+60h] [bp-38h] BYREF
  CColPoint colPoint; // [sp+64h] [bp-34h] BYREF

  if ( (unsigned int)(vehicleToSteal->m_vehicleType - 3) < 2 )
    return 0;
  m_baseVehicleType = vehicleToSteal->m_baseVehicleType;
  v5 = m_baseVehicleType == 9;
  if ( m_baseVehicleType != 9 )
    v5 = m_baseVehicleType == 0;
  if ( !v5 || (vehicleToSteal->VehicleCreatedBy | 2) != 3 && ped->m_pMyVehicle != vehicleToSteal )
    return 0;
  if ( CUpsideDownCarCheck::IsCarUpsideDown(&v23, vehicleToSteal) )
    return 0;
  if ( !CVehicle::CanBeDriven(vehicleToSteal) )
    return 0;
  if ( CVehicle::IsLawEnforcementVehicle(vehicleToSteal) )
    return 0;
  pDriver = vehicleToSteal->pDriver;
  if ( pDriver )
  {
    if ( pDriver->CharCreatedBy == 2
      || CPed::IsPlayer(pDriver)
      || CPedIntelligence::IsFriendlyWith(ped->m_pPedIntelligence, vehicleToSteal->pDriver)
      || CPedGroups::AreInSameGroup(ped, vehicleToSteal->pDriver) )
    {
      return 0;
    }
  }
  PedsGroup = CPedGroups::GetPedsGroup(ped);
  if ( PedsGroup )
  {
    if ( CPedGroup::IsAnyoneUsingCar(PedsGroup, vehicleToSteal) )
      return 0;
  }
  if ( vehicleToSteal->m_pFire
    || vehicleToSteal->m_nHealth <= 600.0
    || CVehicle::IsUpsideDown(vehicleToSteal)
    || CVehicle::IsOnItsSide(vehicleToSteal) )
  {
    return 0;
  }
  m_pColModel = CModelInfo::ms_modelInfoPtrs[vehicleToSteal->m_nModelIndex]->m_pColModel;
  y = m_pColModel->m_boxBound.m_vecMin.y;
  v10 = m_pColModel->m_boxBound.m_vecMax.y;
  m_pMat = vehicleToSteal->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  zy = m_pMat->zy;
  yy = m_pMat->yy;
  v15 = (float)((float)(v10 - y) * 0.5) + 1.5;
  xy = m_pMat->xy;
  refEntityPtr = 0;
  if ( !m_pMat )
    p_tx = &vehicleToSteal->m_transform;
  v17 = v15 * yy;
  v18 = (float)(xy * v15) + p_tx->m_translate.x;
  v19 = (float)(v15 * zy) + p_tx->m_translate.z;
  vecStart.y = v17 + p_tx->m_translate.y;
  vecStart.x = v18;
  vecStart.z = v19;
  v20 = CWorld::ProcessLineOfSight(&vecStart, &p_tx->m_translate, &colPoint, &refEntityPtr, 1, 1, 0, 0, 0, 1, 1, 0);
  v21 = refEntityPtr == vehicleToSteal;
  if ( refEntityPtr != vehicleToSteal )
    return v20 == 0;
  return v21;
}

//----- (00508B08) --------------------------------------------------------
bool __fastcall CCarEnterExit::IsClearToDriveAway(const CVehicle *vehicle)
{
  char v2; // r5
  CColModel *m_pColModel; // r0
  float y; // s0
  float v5; // s2
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float zy; // s6
  float yy; // s4
  float v10; // s0
  float xy; // s2
  float v12; // s4
  RwReal v13; // s2
  RwReal v14; // s0
  char v15; // r0
  CVector vecStart; // [sp+24h] [bp-44h] BYREF
  CEntity *refEntityPtr; // [sp+30h] [bp-38h] BYREF
  CColPoint colPoint; // [sp+34h] [bp-34h] BYREF

  v2 = 0;
  m_pColModel = CModelInfo::ms_modelInfoPtrs[vehicle->m_nModelIndex]->m_pColModel;
  y = m_pColModel->m_boxBound.m_vecMin.y;
  v5 = m_pColModel->m_boxBound.m_vecMax.y;
  m_pMat = vehicle->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  zy = m_pMat->zy;
  yy = m_pMat->yy;
  v10 = (float)((float)(v5 - y) * 0.5) + 1.5;
  xy = m_pMat->xy;
  refEntityPtr = 0;
  if ( !m_pMat )
    p_tx = &vehicle->m_transform;
  v12 = v10 * yy;
  v13 = (float)(xy * v10) + p_tx->m_translate.x;
  v14 = (float)(v10 * zy) + p_tx->m_translate.z;
  vecStart.y = v12 + p_tx->m_translate.y;
  vecStart.x = v13;
  vecStart.z = v14;
  v15 = CWorld::ProcessLineOfSight(&vecStart, &p_tx->m_translate, &colPoint, &refEntityPtr, 1, 1, 0, 0, 0, 1, 1, 0);
  if ( refEntityPtr == vehicle )
    v2 = 1;
  return v2 & 1 | ((v15 & 1) == 0);
}

//----- (00508BBC) --------------------------------------------------------
int __fastcall CCarEnterExit::ComputeTargetDoorToExit(const CVehicle *vehicle, const CPed *ped)
{
  int result; // r0
  tHandlingData *pHandling; // r2
  const CPed *v4; // r2

  if ( vehicle->pDriver == ped )
    return 10;
  pHandling = vehicle->pHandling;
  if ( (unsigned int)pHandling->AnimGroup - 15 < 2 )
    return 8;
  if ( vehicle->pPassengers[0] != ped )
  {
    if ( vehicle->pPassengers[1] != ped )
    {
      v4 = vehicle->pPassengers[2];
      result = -1;
      if ( v4 == ped )
        return 9;
      return result;
    }
    return 11;
  }
  if ( vehicle->m_baseVehicleType == 9 )
    return 11;
  result = 8;
  if ( (pHandling->mFlags & 0x200) != 0 )
    return 11;
  return result;
}

//----- (00508C16) --------------------------------------------------------
int __fastcall CCarEnterExit::ComputeTargetDoorToEnterAsPassenger(const CVehicle *vehicle, const int iSeat)
{
  int result; // r0
  bool v3; // nf

  if ( (*((_BYTE *)&vehicle->m_nVehicleFlags + 1) & 2) != 0 )
    return 8;
  if ( iSeat == 2 )
    return 9;
  if ( iSeat == 1 )
    return 11;
  if ( iSeat )
    return -1;
  if ( vehicle->m_baseVehicleType == 9 )
    return 11;
  v3 = (vehicle->pHandling->mFlags & 0x200) != 0;
  result = 8;
  if ( v3 )
    return 11;
  return result;
}

//----- (00508C5C) --------------------------------------------------------
int __fastcall CCarEnterExit::ComputePassengerIndexFromCarDoor(const CVehicle *vehicle, const int iDoor)
{
  if ( vehicle->m_baseVehicleType == 9 || (vehicle->pHandling->mFlags & 0x200) != 0 )
  {
    if ( (iDoor | 2) == 11 )
      return 0;
  }
  else if ( (unsigned int)(iDoor - 8) < 4 )
  {
    return dword_61E48C[iDoor - 8];
  }
  return -1;
}
// 61E48C: using guessed type _DWORD dword_61E48C[4];

//----- (00508C98) --------------------------------------------------------
bool __fastcall CCarEnterExit::IsPlayerToQuitCarEnter(
        const CPed *ped,
        const CVehicle *vehicle,
        const int iEnterCarStartTime,
        CTask *pSubTask)
{
  CPad *PadFromPlayer; // r9
  float m_fCurrentHeading; // s16
  int v10; // r0
  _BOOL4 v11; // r10
  CMatrix *m_pMat; // r4
  CMatrix *v13; // r0
  CSimpleTransform *p_tx; // r1
  CSimpleTransform *p_m_transform; // r2
  float v16; // s16
  float m_heading; // s0
  int *v18; // r0
  float PedWalkLeftRight; // s18
  float PedWalkUpDown; // s20
  float v22; // s2
  float v23; // s0
  float v24; // s4

  PadFromPlayer = CPlayerPed::GetPadFromPlayer((CPlayerPed *)ped);
  m_fCurrentHeading = ped->m_fCurrentHeading;
  if ( pSubTask )
  {
    v10 = (*((int (__fastcall **)(CTask *))pSubTask->_vptr$CTask + 5))(pSubTask);
    v11 = 0;
    switch ( v10 )
    {
      case 704:
      case 802:
      case 803:
      case 804:
      case 817:
      case 820:
        v11 = 1;
        goto LABEL_4;
      case 705:
      case 706:
      case 707:
      case 708:
      case 709:
      case 710:
      case 711:
      case 712:
      case 713:
      case 714:
      case 715:
      case 716:
      case 717:
      case 718:
      case 719:
      case 720:
      case 721:
      case 722:
      case 723:
      case 724:
      case 725:
      case 726:
      case 727:
      case 728:
      case 729:
      case 730:
      case 731:
      case 732:
      case 733:
      case 734:
      case 735:
      case 736:
      case 737:
      case 738:
      case 739:
      case 740:
      case 741:
      case 742:
      case 743:
      case 744:
      case 745:
      case 746:
      case 747:
      case 748:
      case 749:
      case 750:
      case 751:
      case 752:
      case 753:
      case 754:
      case 755:
      case 756:
      case 757:
      case 758:
      case 759:
      case 760:
      case 761:
      case 762:
      case 763:
      case 764:
      case 765:
      case 766:
      case 767:
      case 768:
      case 769:
      case 770:
      case 771:
      case 772:
      case 773:
      case 774:
      case 775:
      case 776:
      case 777:
      case 778:
      case 779:
      case 780:
      case 781:
      case 782:
      case 783:
      case 784:
      case 785:
      case 786:
      case 787:
      case 788:
      case 789:
      case 790:
      case 791:
      case 792:
      case 793:
      case 794:
      case 795:
      case 796:
      case 797:
      case 798:
      case 799:
      case 800:
      case 806:
      case 809:
      case 810:
      case 811:
      case 813:
      case 814:
      case 815:
      case 818:
      case 819:
      case 821:
      case 822:
      case 823:
      case 824:
      case 825:
      case 826:
      case 827:
      case 828:
        break;
      case 801:
      case 805:
      case 807:
      case 808:
      case 812:
      case 816:
      case 829:
        goto LABEL_4;
      default:
        if ( v10 != 203 && v10 != 208 )
          break;
LABEL_4:
        m_pMat = vehicle->m_pMat;
        v13 = ped->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &vehicle->m_transform;
        p_m_transform = (CSimpleTransform *)&v13->tx;
        if ( !v13 )
          p_m_transform = &ped->m_transform;
        v16 = (float)((float)((float)(p_m_transform->m_translate.x - p_tx->m_translate.x) * m_pMat->xx)
                    + (float)((float)(p_m_transform->m_translate.y - p_tx->m_translate.y) * m_pMat->yx))
            + (float)((float)(p_m_transform->m_translate.z - p_tx->m_translate.z) * m_pMat->zx);
        if ( m_pMat )
          m_heading = atan2f(COERCE_FLOAT(LODWORD(m_pMat->xy) ^ 0x80000000), m_pMat->yy);
        else
          m_heading = vehicle->m_transform.m_heading;
        v18 = dword_508FF0;
        if ( v16 > 0.0 )
          v18 = &dword_508FF0[1];
        m_fCurrentHeading = *(float *)v18 + m_heading;
        if ( m_pMat->zz < 0.0 )
        {
          m_fCurrentHeading = m_fCurrentHeading + 3.1416;
          if ( m_fCurrentHeading > 3.1416 )
            m_fCurrentHeading = m_fCurrentHeading + -6.2832;
        }
        if ( m_fCurrentHeading <= 3.1416 )
        {
          v11 = v11;
          if ( m_fCurrentHeading < -3.1416 )
            m_fCurrentHeading = m_fCurrentHeading + 6.2832;
        }
        else
        {
          v11 = v11;
          m_fCurrentHeading = m_fCurrentHeading + -6.2832;
        }
        break;
    }
  }
  else
  {
    v11 = 0;
  }
  if ( vehicle->m_pFire )
    return 1;
  if ( !PadFromPlayer->DisablePlayerControls )
  {
    if ( v11 )
    {
      if ( CPad::MeleeAttackJustDown(PadFromPlayer) )
        return 1;
    }
    else if ( CCarEnterExit::ms_fPlayerMinQuitTime >= (float)(CTimer::m_snTimeInMilliseconds - iEnterCarStartTime) )
    {
      return 0;
    }
    PedWalkLeftRight = (float)CPad::GetPedWalkLeftRight(PadFromPlayer);
    PedWalkUpDown = (float)CPad::GetPedWalkUpDown(PadFromPlayer);
    v22 = sqrtf((float)(PedWalkLeftRight * PedWalkLeftRight) + (float)(PedWalkUpDown * PedWalkUpDown)) * 0.0078125;
    v23 = CGeneral::GetRadianAngleBetweenPoints(
            0.0,
            0.0,
            COERCE_FLOAT(LODWORD(PedWalkLeftRight) ^ 0x80000000),
            PedWalkUpDown)
        - TheCamera.Orientation;
    if ( v23 <= (float)(m_fCurrentHeading + 3.1416) )
    {
      if ( v23 >= (float)(m_fCurrentHeading + -3.1416) )
        return v22 > 0.75 && fabsf(v23 - m_fCurrentHeading) > 0.7854;
      v24 = 6.2832;
    }
    else
    {
      v24 = -6.2832;
    }
    v23 = v23 + v24;
    return v22 > 0.75 && fabsf(v23 - m_fCurrentHeading) > 0.7854;
  }
  return 0;
}
// 508FF0: using guessed type int dword_508FF0[2];

//----- (0050901C) --------------------------------------------------------
void __fastcall CCarEnterExit::MakeUndraggedPassengerPedsLeaveCar(
        const CVehicle *vehicle,
        const CPed *pDraggedPed,
        const CPed *pDraggingPed)
{
  int m_nMaxPassengers; // r0
  int i; // r4
  const CPed *v8; // r5
  bool v9; // zf
  tHandlingData *pHandling; // r0
  int v11; // r3
  CEventPedEnteredMyVehicle v12[2]; // [sp+0h] [bp-38h] BYREF

  m_nMaxPassengers = vehicle->m_nMaxPassengers;
  if ( m_nMaxPassengers )
  {
    for ( i = 0; i < (unsigned __int8)m_nMaxPassengers; ++i )
    {
      v8 = vehicle->pPassengers[i];
      v9 = v8 == 0;
      if ( v8 )
        v9 = v8 == pDraggedPed;
      if ( v9 || *((unsigned __int8 *)&v8->m_nPedFlags + 6) >> 7 )
        continue;
      if ( vehicle->pDriver == v8 )
      {
        v11 = 10;
      }
      else
      {
        pHandling = vehicle->pHandling;
        if ( (unsigned int)pHandling->AnimGroup - 15 >= 2 )
        {
          if ( vehicle->pPassengers[0] == v8 )
          {
            if ( vehicle->m_baseVehicleType != 9 )
            {
              v11 = 8;
              if ( (pHandling->mFlags & 0x200) != 0 )
                v11 = 11;
              goto LABEL_20;
            }
          }
          else if ( vehicle->pPassengers[1] != v8 )
          {
            v11 = -1;
            if ( vehicle->pPassengers[2] == v8 )
              v11 = 9;
            goto LABEL_20;
          }
          v11 = 11;
        }
        else
        {
          v11 = 8;
        }
      }
LABEL_20:
      CEventPedEnteredMyVehicle::CEventPedEnteredMyVehicle(v12, pDraggingPed, vehicle, v11);
      CEventGroup::Add(&v8->m_pPedIntelligence->m_eventGroup, (CEvent *)v12, 0);
      CEventPedEnteredMyVehicle::~CEventPedEnteredMyVehicle(v12);
      LOBYTE(m_nMaxPassengers) = vehicle->m_nMaxPassengers;
    }
  }
}

//----- (005090DE) --------------------------------------------------------
void __fastcall CCarEnterExit::MakeUndraggedDriverPedLeaveCar(const CVehicle *vehicle, const CPed *pedGettingIn)
{
  CPed *pDriver; // r5
  CEventDraggedOutCar v3; // [sp+4h] [bp-24h] BYREF

  pDriver = vehicle->pDriver;
  CEventDraggedOutCar::CEventDraggedOutCar(&v3, vehicle, pedGettingIn, 1);
  CEventGroup::Add(&pDriver->m_pPedIntelligence->m_eventGroup, (CEvent *)&v3, 0);
  CEventDraggedOutCar::~CEventDraggedOutCar(&v3);
}

//----- (0050910E) --------------------------------------------------------
void __fastcall CCarEnterExit::RemoveCarSitAnim(const CPed *ped)
{
  CAnimBlendAssociation *i; // r0
  uint16 m_bitsFlag; // r1

  for ( i = RpAnimBlendClumpGetFirstAssociation((RpClump_0 *)ped->m_pRwObject, 0x1000u);
        i;
        i = RpAnimBlendGetNextAssociation(i, 0x1000u) )
  {
    m_bitsFlag = i->m_bitsFlag;
    i->m_fBlendDelta = -1000.0;
    i->m_bitsFlag = m_bitsFlag | 4;
  }
  sub_197F5C((RpClump_0 *)ped->m_pRwObject, ped->m_motionAnimGroup, ANIM_STD_IDLE, 1000.0);
}

//----- (00509152) --------------------------------------------------------
void __fastcall CCarEnterExit::RemoveGetInAnims(const CPed *ped)
{
  CAnimBlendAssociation *i; // r0
  uint16 m_bitsFlag; // r1

  for ( i = RpAnimBlendClumpGetFirstAssociation((RpClump_0 *)ped->m_pRwObject, 0x10u);
        i;
        i = RpAnimBlendGetNextAssociation(i, 0x10u) )
  {
    m_bitsFlag = i->m_bitsFlag;
    i->m_fBlendDelta = -1000.0;
    i->m_bitsFlag = m_bitsFlag | 4;
  }
}

//----- (00509180) --------------------------------------------------------
void __fastcall CCarEnterExit::AddInCarAnim(const CVehicle *Vehicle, CPed *pPed, bool bDriver)
{
  _BOOL4 v5; // r6
  int v6; // r0
  RpClump_0 *m_pRwObject; // r0
  AssocGroupId v8; // r1
  AnimationId v9; // r2
  RwObject_0 *v10; // r6

  v5 = bDriver;
  v6 = (*((int (__fastcall **)(const CVehicle *))Vehicle->_vptr$CPlaceable + 48))(Vehicle);
  if ( v5 )
  {
    if ( !v6 )
    {
      if ( Vehicle->m_baseVehicleType == 5 )
      {
        m_pRwObject = (RpClump_0 *)pPed->m_pRwObject;
        if ( (Vehicle->pHandling->mFlags & 0x400) == 0 )
        {
          v8 = ANIM_STD_PED;
          v9 = ANIM_STD_BOAT_DRIVE;
          goto LABEL_15;
        }
      }
      else
      {
        m_pRwObject = (RpClump_0 *)pPed->m_pRwObject;
        if ( (*((_BYTE *)&Vehicle->m_nVehicleFlags + 1) & 8) != 0 )
        {
          v8 = ANIM_STD_PED;
          v9 = ANIM_STD_CAR_SIT_LO;
          goto LABEL_15;
        }
      }
      v8 = ANIM_STD_PED;
      v9 = ANIM_STD_CAR_SIT;
      goto LABEL_15;
    }
LABEL_7:
    v10 = pPed->m_pRwObject;
    v8 = *(_DWORD *)(*((int (__fastcall **)(const CVehicle *))Vehicle->_vptr$CPlaceable + 48))(Vehicle);
    m_pRwObject = (RpClump_0 *)v10;
    v9 = ANIM_BIKE_RIDE;
    goto LABEL_15;
  }
  if ( v6 )
    goto LABEL_7;
  m_pRwObject = (RpClump_0 *)pPed->m_pRwObject;
  if ( (*((_BYTE *)&Vehicle->m_nVehicleFlags + 1) & 8) != 0 )
    v9 = ANIM_STD_CAR_SIT_P_LO;
  else
    v9 = ANIM_STD_CAR_SIT_P;
  v8 = ANIM_STD_PED;
LABEL_15:
  CAnimManager::BlendAnimation(m_pRwObject, v8, v9, 1000.0);
  sub_190330(pPed);
}

//----- (00509228) --------------------------------------------------------
void CCarEnterExit::SetAnimOffsetForEnterOrExitVehicle()
{
  int32 AnimationBlockIndex; // r8
  int32 v1; // r5
  CAnimBlendHierarchy *m_pAnimBlendHierarchy; // r0
  CAnimBlendSequence *m_pSequences; // r6
  uint8 *m_pKeyFrames; // r1
  __int64 v5; // d16
  CAnimBlendHierarchy *v6; // r0
  CAnimBlendSequence *v7; // r6
  int m_iNumKeyFrames; // r0
  int v9; // r0
  uint8 *v10; // r2
  int v11; // r4
  __int64 v12; // d16
  float *v13; // r0
  float v14; // s6
  float v15; // s8
  CAnimBlendHierarchy *v16; // r0
  CAnimBlendSequence *v17; // r6
  int v18; // r0
  int v19; // r0
  uint8 *v20; // r2
  int v21; // r4
  __int64 v22; // d16
  float *v23; // r0
  float v24; // s6
  float v25; // s8
  CAnimBlendHierarchy *v26; // r0
  CAnimBlendSequence *v27; // r6
  int v28; // r0
  int v29; // r0
  uint8 *v30; // r2
  int v31; // r4
  __int64 v32; // d16
  float *v33; // r0
  float v34; // s6
  float v35; // s8
  CAnimBlendHierarchy *v36; // r0
  CAnimBlendSequence *v37; // r6
  int v38; // r0
  int v39; // r0
  uint8 *v40; // r2
  int v41; // r4
  __int64 v42; // d16
  float *v43; // r0
  float v44; // s6
  float v45; // s8

  if ( !CCarEnterExit::ms_bPedOffsetsCalculated )
  {
    AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("int_house");
    v1 = CAnimManager::GetAnimationBlockIndex("int_office");
    CStreaming::RequestModel(v1 + 25575, 8);
    CStreaming::RequestModel(AnimationBlockIndex + 25575, 8);
    CStreaming::LoadAllRequestedModels(0);
    CAnimManager::AddAnimBlockRef(v1);
    CAnimManager::AddAnimBlockRef(AnimationBlockIndex);
    m_pAnimBlendHierarchy = CAnimManager::GetAnimAssociation(ANIM_STD_PED, ANIM_STD_GET_UP)->m_pAnimBlendHierarchy;
    m_pSequences = m_pAnimBlendHierarchy->m_pSequences;
    CAnimManager::UncompressAnimation(m_pAnimBlendHierarchy);
    if ( m_pSequences->m_iNumKeyFrames >= 1 )
    {
      m_pKeyFrames = m_pSequences->m_pKeyFrames;
      v5 = *(_QWORD *)(m_pKeyFrames + 20);
      CCarEnterExit::ms_vecPedGetUpAnimOffset.z = *((RwReal *)m_pKeyFrames + 7);
      *(_QWORD *)&CCarEnterExit::ms_vecPedGetUpAnimOffset.x = v5;
    }
    CCarEnterExit::ms_vecPedQuickDraggedOutCarAnimOffset.x = -1.8418;
    CCarEnterExit::ms_vecPedQuickDraggedOutCarAnimOffset.y = -0.32617;
    CCarEnterExit::ms_vecPedQuickDraggedOutCarAnimOffset.z = -0.012695;
    v6 = CAnimManager::GetAnimAssociation(ANIM_INT_HOUSE_PED, ANIM_INT_BEDRM_BED_IN_L)->m_pAnimBlendHierarchy;
    v7 = v6->m_pSequences;
    CAnimManager::UncompressAnimation(v6);
    m_iNumKeyFrames = v7->m_iNumKeyFrames;
    if ( m_iNumKeyFrames >= 1 )
    {
      v9 = m_iNumKeyFrames - 1;
      v10 = v7->m_pKeyFrames;
      v11 = 20 * v9;
      if ( (v7->m_bitsFlag & 2) != 0 )
        v11 = 32 * v9;
      v12 = *(_QWORD *)&v10[v11 + 20];
      CCarEnterExit::ms_vecPedBedLAnimOffset.z = *(RwReal *)&v10[v11 + 28];
      *(_QWORD *)&CCarEnterExit::ms_vecPedBedLAnimOffset.x = v12;
      v13 = (float *)v7->m_pKeyFrames;
      v14 = v13[6];
      v15 = v13[7];
      CCarEnterExit::ms_vecPedBedLAnimOffset.x = *(float *)&v12 - v13[5];
      CCarEnterExit::ms_vecPedBedLAnimOffset.y = *((float *)&v12 + 1) - v14;
      CCarEnterExit::ms_vecPedBedLAnimOffset.z = CCarEnterExit::ms_vecPedBedLAnimOffset.z - v15;
    }
    v16 = CAnimManager::GetAnimAssociation(ANIM_INT_HOUSE_PED, ANIM_INT_BEDRM_BED_IN_R)->m_pAnimBlendHierarchy;
    v17 = v16->m_pSequences;
    CAnimManager::UncompressAnimation(v16);
    v18 = v17->m_iNumKeyFrames;
    if ( v18 >= 1 )
    {
      v19 = v18 - 1;
      v20 = v17->m_pKeyFrames;
      v21 = 20 * v19;
      if ( (v17->m_bitsFlag & 2) != 0 )
        v21 = 32 * v19;
      v22 = *(_QWORD *)&v20[v21 + 20];
      CCarEnterExit::ms_vecPedBedRAnimOffset.z = *(RwReal *)&v20[v21 + 28];
      *(_QWORD *)&CCarEnterExit::ms_vecPedBedRAnimOffset.x = v22;
      v23 = (float *)v17->m_pKeyFrames;
      v24 = v23[6];
      v25 = v23[7];
      CCarEnterExit::ms_vecPedBedRAnimOffset.x = *(float *)&v22 - v23[5];
      CCarEnterExit::ms_vecPedBedRAnimOffset.y = *((float *)&v22 + 1) - v24;
      CCarEnterExit::ms_vecPedBedRAnimOffset.z = CCarEnterExit::ms_vecPedBedRAnimOffset.z - v25;
    }
    v26 = CAnimManager::GetAnimAssociation(ANIM_INT_OFFICE_PED, ANIM_INT_OFFICE_DESK_IN)->m_pAnimBlendHierarchy;
    v27 = v26->m_pSequences;
    CAnimManager::UncompressAnimation(v26);
    v28 = v27->m_iNumKeyFrames;
    if ( v28 >= 1 )
    {
      v29 = v28 - 1;
      v30 = v27->m_pKeyFrames;
      v31 = 20 * v29;
      if ( (v27->m_bitsFlag & 2) != 0 )
        v31 = 32 * v29;
      v32 = *(_QWORD *)&v30[v31 + 20];
      CCarEnterExit::ms_vecPedDeskAnimOffset.z = *(RwReal *)&v30[v31 + 28];
      *(_QWORD *)&CCarEnterExit::ms_vecPedDeskAnimOffset.x = v32;
      v33 = (float *)v27->m_pKeyFrames;
      v34 = v33[6];
      v35 = v33[7];
      CCarEnterExit::ms_vecPedDeskAnimOffset.x = *(float *)&v32 - v33[5];
      CCarEnterExit::ms_vecPedDeskAnimOffset.y = *((float *)&v32 + 1) - v34;
      CCarEnterExit::ms_vecPedDeskAnimOffset.z = CCarEnterExit::ms_vecPedDeskAnimOffset.z - v35;
    }
    v36 = CAnimManager::GetAnimAssociation(ANIM_INT_HOUSE_PED, ANIM_INT_LOUNGE_CHAIR_IN)->m_pAnimBlendHierarchy;
    v37 = v36->m_pSequences;
    CAnimManager::UncompressAnimation(v36);
    v38 = v37->m_iNumKeyFrames;
    if ( v38 >= 1 )
    {
      v39 = v38 - 1;
      v40 = v37->m_pKeyFrames;
      v41 = 20 * v39;
      if ( (v37->m_bitsFlag & 2) != 0 )
        v41 = 32 * v39;
      v42 = *(_QWORD *)&v40[v41 + 20];
      CCarEnterExit::ms_vecPedChairAnimOffset.z = *(RwReal *)&v40[v41 + 28];
      *(_QWORD *)&CCarEnterExit::ms_vecPedChairAnimOffset.x = v42;
      v43 = (float *)v37->m_pKeyFrames;
      v44 = v43[6];
      v45 = v43[7];
      CCarEnterExit::ms_vecPedChairAnimOffset.x = *(float *)&v42 - v43[5];
      CCarEnterExit::ms_vecPedChairAnimOffset.y = *((float *)&v42 + 1) - v44;
      CCarEnterExit::ms_vecPedChairAnimOffset.z = CCarEnterExit::ms_vecPedChairAnimOffset.z - v45;
    }
    CAnimManager::RemoveAnimBlockRef(AnimationBlockIndex);
    CAnimManager::RemoveAnimBlockRef(v1);
    CCarEnterExit::ms_bPedOffsetsCalculated = 1;
  }
}

//----- (005094F4) --------------------------------------------------------
void __fastcall CTaskUtilityLineUpPedWithCar::CTaskUtilityLineUpPedWithCar(
        CTaskUtilityLineUpPedWithCar *this,
        const CVector *vInitialBlendVector,
        const int iBlendTime,
        const int nZflag,
        const int iTargetDoor)
{
  __int64 v5; // d16
  uint32 v6; // r1

  v5 = *(_QWORD *)&vInitialBlendVector->x;
  this->m_vInitialBlendVector.z = vInitialBlendVector->z;
  this->m_fGroundZCoord = -999.99;
  *(_QWORD *)&this->m_vInitialBlendVector.x = v5;
  v6 = CTimer::m_snTimeInMilliseconds;
  this->m_nZFlag = nZflag;
  this->m_iTargetDoor = iTargetDoor;
  this->m_iBlendTime = v6 + iBlendTime;
}

//----- (00509538) --------------------------------------------------------
bool __fastcall CTaskUtilityLineUpPedWithCar::ProcessPed(
        CTaskUtilityLineUpPedWithCar *this,
        CPed *pPed,
        CVehicle *pVehicle,
        CAnimBlendAssociation *pAnim)
{
  CMatrix *m_pMat; // r0
  int m_iTargetDoor; // r1
  float zz; // s18
  unsigned int v11; // r4
  float v12; // s0
  float m_heading; // s0
  float v14; // s20
  int m_animId; // r4
  float v16; // s22
  float v17; // s22
  float v18; // s24
  CVehicleAnimGroup *v19; // r5
  float v20; // r0
  float v21; // s0
  float v22; // s2
  float v23; // s4
  float m_fCurrentTime; // s20
  float m_fTotalTime; // s22
  CVehicleAnimGroup *v26; // r10
  float v27; // r0
  float v28; // s2
  float v29; // s4
  float v30; // s6
  CVehicleAnimGroup *v31; // r10
  float v32; // r0
  float v33; // s4
  float v34; // s0
  float v35; // s2
  CVehicleAnimGroup *v36; // r10
  CMatrix *v37; // r0
  CSimpleTransform *p_tx; // r1
  float x; // r5
  float y; // r10
  float z; // r0
  CMatrix *v42; // r0
  CSimpleTransform *p_m_transform; // r1
  float v44; // s2
  float v45; // s4
  int32 m_baseVehicleType; // r0
  bool v47; // zf
  CMatrix *v48; // r0
  CSimpleTransform *v49; // r1
  RwReal v50; // s2
  RwReal v51; // s4
  CMatrix *v52; // r0
  CSimpleTransform *v53; // r1
  float v54; // s24
  float v55; // s28
  float v56; // s30
  float v57; // s26
  float xx; // s2
  float yx; // s4
  float zx; // s0
  float v61; // r4
  float v62; // s26
  float v63; // s0
  CMatrix *v64; // r0
  float v65; // s26
  float v66; // s24
  float v67; // s28
  float v68; // r4
  float v69; // r0
  float v70; // s0
  CMatrix *v71; // r2
  CSimpleTransform *v72; // r1
  float v73; // s2
  float v74; // r4
  float m_fGroundZCoord; // s2
  int v76; // r0
  float v77; // s2
  CMatrix *v78; // r1
  CSimpleTransform *v79; // r2
  float v80; // s24
  float v81; // s4
  float v82; // s2
  float m_fCurrentHeading; // s0
  float v84; // s8
  float v85; // s6
  float v86; // s6
  float v87; // s8
  float v88; // s12
  int v89; // r0
  const CMatrix *v90; // r0
  float v91; // s16
  float v92; // s18
  float32x2_t v93; // d0
  RwReal *v94; // r0
  float32x2_t v95; // d16
  float32x2_t v96; // d16
  float32x2_t v97; // d17
  RtQuat_0 v98; // q0
  int32 v99; // r0
  bool v100; // zf
  CMatrix *v101; // r0
  float *p_tz; // r0
  const CMatrix *v103; // r0
  CMatrix *v104; // r0
  float v105; // s16
  float v106; // s18
  float32x2_t v107; // d0
  RwReal *p_omega; // r0
  float32x2_t v109; // d16
  float32x2_t v110; // d16
  float32x2_t v111; // d17
  float v112; // s2
  float v113; // s4
  float v114; // s14
  float v115; // s3
  float v116; // s6
  float real; // s4
  float v118; // s0
  float v119; // s2
  CMatrix *v120; // r0
  float tx; // s16
  float ty; // s18
  float tz; // s20
  CMatrix *v124; // r0
  float v125; // s2
  float v126; // s4
  CMatrix *v127; // r0
  float v128; // s4
  float v129; // s6
  float v130; // s8
  float v131; // s4
  float v132; // s12
  float v133; // s7
  float v134; // s14
  float v135; // s5
  float v136; // s8
  float v137; // s4
  float v138; // s8
  float v139; // s10
  float v140; // s12
  float v141; // s8
  float v142; // s14
  float v143; // s1
  float v144; // s5
  float v145; // s3
  float v146; // s7
  float v147; // s2
  float v148; // s6
  float v149; // s4
  float v150; // s0
  float v152; // [sp+14h] [bp-244h]
  RwMatrix v153; // [sp+18h] [bp-240h] BYREF
  RtQuatSlerpCache_0 sCache; // [sp+58h] [bp-200h] BYREF
  RtQuat_0 v155; // [sp+80h] [bp-1D8h] BYREF
  RwMatrix pMatrix; // [sp+90h] [bp-1C8h] BYREF
  RtQuat_0 qpQuat; // [sp+D0h] [bp-188h] BYREF
  RwMatrix v158; // [sp+E0h] [bp-178h] BYREF
  CMatrix v; // [sp+120h] [bp-138h] BYREF
  CMatrix v160; // [sp+168h] [bp-F0h] BYREF
  CMatrix v161; // [sp+1B0h] [bp-A8h] BYREF

  if ( !this->m_nZFlag )
  {
    pPed->m_vecMoveSpeed.x = 0.0;
    pPed->m_vecMoveSpeed.y = 0.0;
    pPed->m_vecMoveSpeed.z = 0.0;
  }
  m_pMat = pVehicle->m_pMat;
  m_iTargetDoor = this->m_iTargetDoor;
  zz = m_pMat->zz;
  if ( zz > -0.8 )
  {
    if ( m_iTargetDoor == 18 )
    {
      if ( m_pMat )
        m_heading = atan2f(COERCE_FLOAT(LODWORD(m_pMat->xy) ^ 0x80000000), m_pMat->yy);
      else
        m_heading = pVehicle->m_transform.m_heading;
      v12 = m_heading + 3.1416;
    }
    else
    {
      if ( this->m_nZFlag == 2 )
        goto LABEL_19;
      if ( m_pMat )
        v12 = atan2f(COERCE_FLOAT(LODWORD(m_pMat->xy) ^ 0x80000000), m_pMat->yy);
      else
        v12 = pVehicle->m_transform.m_heading;
    }
  }
  else
  {
    v11 = m_iTargetDoor & 0xFFFFFFFE;
    if ( m_pMat )
      v12 = atan2f(COERCE_FLOAT(LODWORD(m_pMat->xy) ^ 0x80000000), m_pMat->yy);
    else
      v12 = pVehicle->m_transform.m_heading;
    if ( v11 == 8 )
      v12 = v12 + -3.1416;
  }
  pPed->m_fDesiredHeading = v12;
LABEL_19:
  v14 = 0.0;
  if ( pAnim )
  {
    m_animId = pAnim->m_animId;
    v16 = 0.0;
    switch ( pAnim->m_animId )
    {
      case 0x6C:
      case 0x6D:
        v21 = pAnim->m_fCurrentTime / pAnim->m_pAnimBlendHierarchy->m_fTotalTime;
        goto LABEL_46;
      case 0x6E:
      case 0x6F:
      case 0x70:
      case 0x71:
      case 0x72:
      case 0x73:
      case 0x74:
      case 0x75:
      case 0x76:
      case 0x77:
      case 0x78:
      case 0x79:
      case 0x7A:
      case 0x7B:
      case 0x7C:
      case 0x7D:
      case 0x7E:
      case 0x7F:
      case 0x80:
      case 0x81:
      case 0x82:
      case 0x83:
      case 0x84:
      case 0x85:
      case 0x86:
      case 0x87:
      case 0x88:
      case 0x89:
      case 0x8A:
      case 0x8B:
      case 0x8C:
      case 0x8D:
      case 0x8E:
      case 0x8F:
      case 0x90:
      case 0x91:
      case 0x92:
      case 0x93:
      case 0x94:
      case 0x95:
      case 0x96:
      case 0x97:
      case 0x98:
      case 0x99:
      case 0x9A:
      case 0x9B:
      case 0x9C:
      case 0x9D:
      case 0x9E:
      case 0x9F:
      case 0xA0:
      case 0xA1:
      case 0xA2:
      case 0xA3:
      case 0xA4:
      case 0xA5:
      case 0xA6:
      case 0xA7:
      case 0xA8:
      case 0xA9:
      case 0xAA:
      case 0xAB:
      case 0xAC:
      case 0xAD:
      case 0xAE:
      case 0xAF:
      case 0xB0:
      case 0xB1:
      case 0xB2:
      case 0xB3:
      case 0xB4:
      case 0xB5:
      case 0xB6:
      case 0xB7:
      case 0xB8:
      case 0xB9:
      case 0xBA:
      case 0xBB:
      case 0xBC:
      case 0xBD:
      case 0xBE:
      case 0xBF:
      case 0xC0:
      case 0xC1:
      case 0xC2:
      case 0xC3:
      case 0xC4:
      case 0xC5:
      case 0xC6:
      case 0xC7:
      case 0xC8:
      case 0xC9:
      case 0xCA:
      case 0xCB:
      case 0xCC:
      case 0xCD:
      case 0xCE:
      case 0xCF:
      case 0xD0:
      case 0xD1:
      case 0xD2:
      case 0xD3:
      case 0xD4:
      case 0xD5:
      case 0xD6:
      case 0xD7:
      case 0xD8:
      case 0xD9:
      case 0xDA:
      case 0xDB:
      case 0xDC:
      case 0xDD:
      case 0xDE:
      case 0xDF:
      case 0xE0:
      case 0xE1:
      case 0xE2:
      case 0xE3:
      case 0xE4:
      case 0xE5:
      case 0xE6:
      case 0xE7:
      case 0xE8:
      case 0xE9:
      case 0xEA:
      case 0xEB:
      case 0xEC:
      case 0xED:
      case 0xEE:
      case 0xEF:
      case 0xF0:
      case 0xF1:
      case 0xF2:
      case 0xF3:
      case 0xF4:
      case 0xF5:
      case 0xF6:
      case 0xF7:
      case 0xF8:
      case 0xF9:
      case 0xFA:
      case 0xFB:
      case 0xFC:
      case 0xFD:
      case 0xFE:
      case 0xFF:
      case 0x100:
      case 0x101:
      case 0x102:
      case 0x103:
      case 0x104:
      case 0x105:
      case 0x106:
      case 0x107:
      case 0x108:
      case 0x109:
      case 0x10A:
      case 0x10B:
      case 0x10C:
      case 0x10D:
      case 0x10E:
      case 0x10F:
      case 0x110:
      case 0x111:
      case 0x112:
      case 0x113:
      case 0x114:
      case 0x115:
      case 0x116:
      case 0x117:
      case 0x118:
      case 0x119:
      case 0x11A:
      case 0x11B:
      case 0x11C:
      case 0x11D:
      case 0x11E:
      case 0x11F:
      case 0x120:
      case 0x121:
      case 0x122:
      case 0x123:
      case 0x124:
      case 0x125:
      case 0x126:
      case 0x127:
      case 0x128:
      case 0x129:
      case 0x12A:
      case 0x12B:
      case 0x12C:
      case 0x12D:
      case 0x12E:
      case 0x12F:
      case 0x130:
      case 0x131:
      case 0x132:
      case 0x133:
      case 0x134:
      case 0x135:
      case 0x136:
      case 0x137:
      case 0x138:
      case 0x139:
      case 0x13A:
      case 0x13B:
      case 0x13C:
      case 0x13D:
      case 0x13E:
      case 0x13F:
      case 0x140:
      case 0x141:
      case 0x142:
      case 0x143:
      case 0x144:
      case 0x145:
      case 0x146:
      case 0x147:
      case 0x148:
      case 0x149:
      case 0x14A:
      case 0x14B:
      case 0x14C:
      case 0x14D:
      case 0x14E:
      case 0x14F:
      case 0x150:
      case 0x151:
      case 0x152:
      case 0x153:
      case 0x154:
      case 0x155:
      case 0x156:
      case 0x157:
      case 0x158:
      case 0x159:
      case 0x15A:
      case 0x15B:
      case 0x15C:
      case 0x15D:
      case 0x15E:
      case 0x179:
        break;
      case 0x15F:
      case 0x160:
      case 0x161:
      case 0x162:
        v31 = &CVehicleAnimGroupData::m_vehicleAnimGroups[pVehicle->pHandling->AnimGroup];
        CVehicleAnimGroup::GetGroup(v31, pAnim->m_animId);
        v32 = CVehicleAnimGroup::ComputeCriticalBlendTime(v31, m_animId);
        v16 = 0.0;
        v33 = fabsf(v32);
        if ( v33 < 10.0 )
          goto LABEL_53;
        v34 = pAnim->m_fCurrentTime / pAnim->m_pAnimBlendHierarchy->m_fTotalTime;
        v35 = v33 + -11.0;
        if ( (float)(v32 + -11.0) <= 0.0 )
        {
          if ( v34 < v35 )
            goto LABEL_53;
          v34 = v34 - v35;
          v35 = 1.0 - v35;
        }
        else if ( v34 >= v35 )
        {
          v16 = 1.0;
          goto LABEL_53;
        }
        v16 = v34 / v35;
LABEL_53:
        v14 = 1.0;
LABEL_54:
        if ( pVehicle->m_nModelIndex == 577 )
          v16 = v14;
        break;
      case 0x163:
      case 0x164:
      case 0x165:
      case 0x166:
        v36 = &CVehicleAnimGroupData::m_vehicleAnimGroups[pVehicle->pHandling->AnimGroup];
        CVehicleAnimGroup::GetGroup(v36, pAnim->m_animId);
        v14 = 1.0;
        v16 = 1.0;
        if ( COERCE_FLOAT(COERCE_UNSIGNED_INT(CVehicleAnimGroup::ComputeCriticalBlendTime(v36, m_animId)) & 0x7FFFFFFF) < 10.0 )
          v16 = 0.0;
        goto LABEL_54;
      case 0x167:
      case 0x168:
      case 0x169:
      case 0x16A:
      case 0x16B:
        m_fCurrentTime = pAnim->m_fCurrentTime;
        m_fTotalTime = pAnim->m_pAnimBlendHierarchy->m_fTotalTime;
        v26 = &CVehicleAnimGroupData::m_vehicleAnimGroups[pVehicle->pHandling->AnimGroup];
        CVehicleAnimGroup::GetGroup(v26, pAnim->m_animId);
        v27 = CVehicleAnimGroup::ComputeCriticalBlendTime(v26, m_animId);
        v28 = m_fCurrentTime / m_fTotalTime;
        v29 = fabsf(v27);
        v16 = 1.0;
        if ( v29 >= 10.0 )
          goto LABEL_59;
        v30 = pAnim->m_fCurrentTime / pAnim->m_pAnimBlendHierarchy->m_fTotalTime;
        if ( v27 <= 0.0 )
        {
          if ( v30 < v29 )
          {
            v16 = 0.0;
            goto LABEL_59;
          }
          v30 = v30 - v29;
          v29 = 1.0 - v29;
        }
        else
        {
          v16 = 1.0;
          if ( v30 >= v29 )
            goto LABEL_59;
        }
        v16 = v30 / v29;
LABEL_59:
        v14 = 1.0 - v28;
        if ( pVehicle->m_nModelIndex == 577 )
          v16 = 1.0;
        break;
      case 0x16C:
      case 0x16D:
      case 0x16E:
      case 0x17C:
      case 0x17D:
      case 0x17E:
      case 0x17F:
        v21 = 1.0;
        goto LABEL_46;
      case 0x16F:
      case 0x170:
      case 0x171:
      case 0x172:
      case 0x173:
      case 0x174:
      case 0x182:
        v16 = 1.0;
        break;
      case 0x175:
      case 0x176:
      case 0x177:
      case 0x178:
      case 0x17A:
      case 0x17B:
      case 0x180:
      case 0x181:
      case 0x183:
      case 0x184:
        v17 = pAnim->m_fCurrentTime;
        v18 = pAnim->m_pAnimBlendHierarchy->m_fTotalTime;
        v19 = &CVehicleAnimGroupData::m_vehicleAnimGroups[pVehicle->pHandling->AnimGroup];
        CVehicleAnimGroup::GetGroup(v19, pAnim->m_animId);
        v20 = CVehicleAnimGroup::ComputeCriticalBlendTime(v19, m_animId);
        v21 = v17 / v18;
        v22 = pAnim->m_fCurrentTime / pAnim->m_pAnimBlendHierarchy->m_fTotalTime;
        v23 = fabsf(v20);
        if ( v20 <= 0.0 )
        {
          if ( v22 >= v23 )
            v16 = 1.0 - (float)((float)(v22 - v23) / (float)(1.0 - v23));
          else
            v16 = 1.0;
        }
        else if ( v22 >= v23 )
        {
LABEL_46:
          v16 = 0.0;
        }
        else
        {
          v16 = 1.0 - (float)(v22 / v23);
        }
        v14 = v21;
        break;
      case 0x185:
      case 0x186:
        v14 = 1.0;
        v16 = 0.0;
        if ( (CVehicleAnimGroupData::m_vehicleAnimGroups[pVehicle->pHandling->AnimGroup].m_specialFlags & 0x20) != 0 )
          v16 = 1.0;
        break;
      default:
        goto LABEL_24;
    }
  }
  else
  {
LABEL_24:
    v16 = 0.0;
  }
  if ( this->m_nZFlag == 2 )
  {
    v37 = pPed->m_pMat;
    p_tx = (CSimpleTransform *)&v37->tx;
    if ( !v37 )
      p_tx = &pPed->m_transform;
    y = p_tx->m_translate.y;
    x = p_tx->m_translate.x;
    z = p_tx->m_translate.z;
  }
  else
  {
    CMatrix::CMatrix(&v161, pVehicle->m_pMat);
    CTaskUtilityLineUpPedWithCar::GetLocalPositionToOpenCarDoor((CVector *)&v160, this, pVehicle, v14, (int)pAnim);
    v.zx = v160.zx;
    *(_QWORD *)&v.xx = *(_QWORD *)&v160.xx;
    Multiply3x3((CVector *)&v160, &v161, (const CVector *)&v);
    v.zx = v160.zx;
    *(_QWORD *)&v.xx = *(_QWORD *)&v160.xx;
    v42 = pVehicle->m_pMat;
    p_m_transform = (CSimpleTransform *)&v42->tx;
    if ( !v42 )
      p_m_transform = &pVehicle->m_transform;
    v44 = p_m_transform->m_translate.y + v160.yx;
    v45 = p_m_transform->m_translate.z + v160.zx;
    v.xx = p_m_transform->m_translate.x + v160.xx;
    v.yx = v44;
    v.zx = v45;
    CMatrix::~CMatrix(&v161);
    x = v.xx;
    y = v.yx;
    z = v.zx;
  }
  v152 = z;
  v.xx = x;
  v.yx = y;
  v.zx = z;
  m_baseVehicleType = pVehicle->m_baseVehicleType;
  v47 = m_baseVehicleType == 9;
  if ( m_baseVehicleType != 9 )
    v47 = this->m_nZFlag == 2;
  if ( !v47 )
  {
    CMatrix::CMatrix(&v161, pVehicle->m_pMat);
    CTaskUtilityLineUpPedWithCar::GetLocalPositionToOpenCarDoor((CVector *)&v160, this, pVehicle, 1.0, (int)pAnim);
    v158.right.z = v160.zx;
    *(_QWORD *)&v158.right.x = *(_QWORD *)&v160.xx;
    Multiply3x3((CVector *)&v160, &v161, (const CVector *)&v158);
    v158.right.z = v160.zx;
    *(_QWORD *)&v158.right.x = *(_QWORD *)&v160.xx;
    v48 = pVehicle->m_pMat;
    v49 = (CSimpleTransform *)&v48->tx;
    if ( !v48 )
      v49 = &pVehicle->m_transform;
    v50 = v49->m_translate.y + v160.yx;
    v51 = v49->m_translate.z + v160.zx;
    v158.right.x = v49->m_translate.x + v160.xx;
    v158.right.y = v50;
    v158.right.z = v51;
    CMatrix::~CMatrix(&v161);
    v.zx = v158.right.z;
    *(_QWORD *)&v.xx = *(_QWORD *)&v158.right.x;
  }
  if ( *((unsigned __int8 *)&pVehicle->m_nPhysicalFlags + 1) << 31 )
  {
    if ( pVehicle->m_baseVehicleType == 5 && CVehicle::IsUpsideDown(pVehicle) )
      v.zx = v.zx + 1.0;
  }
  else
  {
    v52 = pVehicle->m_pMat;
    v53 = (CSimpleTransform *)&v52->tx;
    if ( !v52 )
      v53 = &pVehicle->m_transform;
    v54 = v53->m_translate.z;
    v55 = v.xx - v53->m_translate.x;
    v56 = v.yx - v53->m_translate.y;
    v57 = v.zx - v54;
    if ( v52 )
    {
      xx = v52->xx;
      yx = v52->yx;
      zx = v52->zx;
    }
    else
    {
      v61 = pVehicle->m_transform.m_heading;
      xx = cosf(v61);
      yx = sinf(v61);
      zx = 0.0;
    }
    v62 = v57 * zx;
    v63 = COERCE_FLOAT((*((int (__fastcall **)(CVehicle *))pVehicle->_vptr$CPlaceable + 54))(pVehicle));
    v64 = pVehicle->m_pMat;
    v65 = (float)((float)(v55 * xx) + (float)(v56 * yx)) + v62;
    v66 = v54 - v63;
    if ( v64 )
      v67 = v64->zx;
    else
      v67 = 0.0;
    v68 = v.zx;
    CPedPlacement::FindZCoorForPed((CVector *)&v);
    if ( v.zx < (float)((float)((float)(v66 + (float)(v65 * v67)) + 1.0) + -0.5) )
      v.zx = v68;
  }
  v69 = v.zx;
  this->m_fGroundZCoord = v.zx;
  if ( (unsigned int)(this->m_nZFlag - 1) > 1 )
  {
    v74 = v152;
  }
  else
  {
    v70 = v69;
    v71 = pPed->m_pMat;
    v72 = (CSimpleTransform *)&v71->tx;
    if ( !v71 )
      v72 = &pPed->m_transform;
    v73 = pPed->m_vecMoveSpeed.z + (float)(CTimer::ms_fTimeStep * -0.008);
    if ( (float)(v72->m_translate.z + v73) < v69 )
    {
      v74 = v69;
      pPed->m_vecMoveSpeed.x = 0.0;
      pPed->m_vecMoveSpeed.y = 0.0;
      pPed->m_vecMoveSpeed.z = 0.0;
      goto LABEL_97;
    }
    pPed->m_vecMoveSpeed.z = v73;
    v74 = v72->m_translate.z;
  }
  v70 = v74;
LABEL_97:
  m_fGroundZCoord = this->m_fGroundZCoord;
  if ( m_fGroundZCoord <= v70 )
  {
    if ( this->m_nZFlag )
      goto LABEL_111;
    goto LABEL_110;
  }
  if ( pAnim && pVehicle->m_baseVehicleType == 9 )
  {
    v76 = pAnim->m_animId;
    if ( (unsigned int)(v76 - 359) < 4 )
    {
      v16 = 1.0;
      v77 = pAnim->m_pAnimBlendHierarchy->m_fTotalTime;
      if ( (float)((float)(pAnim->m_fCurrentTime + pAnim->m_fCurrentTime) / v77) <= 1.0 )
        v16 = (float)(pAnim->m_fCurrentTime + pAnim->m_fCurrentTime) / v77;
      goto LABEL_107;
    }
    if ( (unsigned int)(v76 - 373) < 4 )
    {
      v16 = 1.0 - v14;
LABEL_107:
      v78 = pVehicle->m_pMat;
      v79 = (CSimpleTransform *)&v78->tx;
      if ( !v78 )
        v79 = &pVehicle->m_transform;
      v80 = v79->m_translate.z;
      v70 = (float)(v80 - (*((float (__fastcall **)(CVehicle *))pVehicle->_vptr$CPlaceable + 54))(pVehicle)) + 1.0;
      m_fGroundZCoord = this->m_fGroundZCoord;
      goto LABEL_110;
    }
    if ( v76 != 363 )
    {
      v16 = 0.0;
      goto LABEL_107;
    }
  }
LABEL_110:
  v74 = m_fGroundZCoord + (float)((float)(v70 - m_fGroundZCoord) * v16);
LABEL_111:
  if ( CTimer::m_snTimeInMilliseconds >= this->m_iBlendTime )
  {
    pPed->m_fCurrentHeading = pPed->m_fDesiredHeading;
    if ( !pAnim )
      goto LABEL_132;
    goto LABEL_123;
  }
  v81 = CGeneral::LimitRadianAngle(pPed->m_fDesiredHeading);
  v82 = (float)(this->m_iBlendTime - CTimer::m_snTimeInMilliseconds) / 600.0;
  m_fCurrentHeading = pPed->m_fCurrentHeading;
  if ( v82 <= 0.0 )
  {
    v85 = 0.0;
    this->m_vInitialBlendVector.x = 0.0;
    this->m_vInitialBlendVector.y = 0.0;
    v84 = 0.0;
  }
  else
  {
    v84 = this->m_vInitialBlendVector.x;
    v85 = this->m_vInitialBlendVector.y;
  }
  this->m_vInitialBlendVector.z = 0.0;
  v86 = y - (float)(v82 * v85);
  v87 = x - (float)(v82 * v84);
  if ( (float)(m_fCurrentHeading + 3.1416) >= v81 )
  {
    if ( (float)(m_fCurrentHeading + -3.1416) <= v81 )
      goto LABEL_122;
    v88 = 6.2832;
  }
  else
  {
    v88 = -6.2832;
  }
  v81 = v81 + v88;
LABEL_122:
  y = v86;
  x = v87;
  v74 = v74 - (float)(v82 * 0.0);
  pPed->m_fCurrentHeading = m_fCurrentHeading - (float)((float)(1.0 - v82) * (float)(m_fCurrentHeading - v81));
  if ( !pAnim )
    goto LABEL_132;
LABEL_123:
  v89 = pAnim->m_animId;
  if ( (unsigned int)(v89 - 373) < 5 )
  {
    CMatrix::CMatrix(&v161, pVehicle->m_pMat);
    CMatrix::CopyToRwMatrix(v103, &v158);
    RtQuatConvertFromMatrix(&qpQuat, &v158);
    CMatrix::CMatrix(&v160, pPed->m_pMat);
    CMatrix::SetRotateZOnly(v104, pPed->m_fCurrentHeading);
    CMatrix::CopyToRwMatrix(&v160, &pMatrix);
    RtQuatConvertFromMatrix(&v155, &pMatrix);
    v105 = pAnim->m_fCurrentTime;
    v106 = pAnim->m_pAnimBlendHierarchy->m_fTotalTime;
    RtQuatSetupSlerpCache(&qpQuat, &v155, &sCache);
    v107.n64_f32[1] = v105 / v106;
    if ( (float)(v105 / v106) <= 0.0 )
    {
      v119 = qpQuat.imag.x;
      v118 = qpQuat.imag.y;
      v116 = qpQuat.imag.z;
      real = qpQuat.real;
    }
    else if ( v107.n64_f32[1] >= 1.0 )
    {
      v119 = v155.imag.x;
      v118 = v155.imag.y;
      v116 = v155.imag.z;
      real = v155.real;
    }
    else
    {
      v107.n64_f32[0] = 1.0 - v107.n64_f32[1];
      if ( !sCache.nearlyZeroOm )
      {
        p_omega = &sCache.omega;
        v109.n64_u64[0] = vld1_dup_f32(p_omega).n64_u64[0];
        v110.n64_u64[0] = vmul_f32(v107, v109).n64_u64[0];
        v111.n64_u64[0] = vmul_f32(v110, v110).n64_u64[0];
        v107.n64_u64[0] = vadd_f32(
                            v110,
                            vmul_f32(
                              vmul_f32(v110, v111),
                              vadd_f32(
                                vmul_f32(
                                  v111,
                                  vadd_f32(
                                    vmul_f32(
                                      v111,
                                      vadd_f32(
                                        vmul_f32(
                                          v111,
                                          vadd_f32(
                                            vmul_f32(
                                              v111,
                                              vadd_f32(
                                                vmul_f32(v111, (float32x2_t)0x2F2EC9D32F2EC9D3LL),
                                                (float32x2_t)0xB2D72F34B2D72F34LL)),
                                            (float32x2_t)0x3638EF1B3638EF1BLL)),
                                        (float32x2_t)0xB9500D01B9500D01LL)),
                                    (float32x2_t)0x3C0888893C088889LL)),
                                (float32x2_t)0xBE2AAAABBE2AAAABLL))).n64_u64[0];
      }
      v112 = v107.n64_f32[1] * sCache.raTo.imag.z;
      v113 = v107.n64_f32[1] * sCache.raTo.real;
      v114 = v107.n64_f32[1] * sCache.raTo.imag.y;
      v115 = v107.n64_f32[1] * sCache.raTo.imag.x;
      v107.n64_f32[1] = v107.n64_f32[0] * sCache.raFrom.imag.x;
      v116 = (float)(v107.n64_f32[0] * sCache.raFrom.imag.z) + v112;
      real = (float)(v107.n64_f32[0] * sCache.raFrom.real) + v113;
      v107.n64_f32[0] = (float)(v107.n64_f32[0] * sCache.raFrom.imag.y) + v114;
      v119 = v107.n64_f32[1] + v115;
    }
    v.m_owner = 0;
    v.m_pRwMat = 0;
    memset(&v153.pos, 0, sizeof(v153.pos));
    v138 = 2.0
         / (float)((float)(real * real)
                 + (float)((float)(v116 * v116) + (float)((float)(v118 * v118) + (float)(v119 * v119))));
    v139 = v116 * v138;
    v140 = v118 * v138;
    v141 = v119 * v138;
    v142 = v116 * v139;
    v143 = v118 * v140;
    v144 = v119 * v141;
    v145 = real * v140;
    v146 = real * v139;
    v147 = v119 * v140;
    v148 = v116 * v141;
    v149 = real * v141;
    v150 = v118 * v139;
    v153.right.y = v147 + v146;
    v153.right.z = v148 - v145;
    v153.up.x = v147 - v146;
    v153.up.z = v150 + v149;
    v153.at.y = v150 - v149;
    v153.at.x = v148 + v145;
    v153.right.x = 1.0 - (float)(v143 + v142);
    v153.up.y = 1.0 - (float)(v142 + v144);
    v153.at.z = 1.0 - (float)(v144 + v143);
    v153.flags = 2;
    CMatrix::UpdateMatrix(&v, &v153);
    v.tx = x;
    v.ty = y;
    v.tz = v74;
    CPlaceable::SetMatrix(pPed, &v);
    CMatrix::~CMatrix(&v);
    CMatrix::~CMatrix(&v160);
    v127 = &v161;
    goto LABEL_155;
  }
  if ( (unsigned int)(v89 - 359) <= 4 )
  {
    CMatrix::CMatrix(&v160, pVehicle->m_pMat);
    if ( pAnim->m_animId == 363 )
    {
      v.m_pRwMat = 0;
      v.m_owner = 0;
      CMatrix::SetRotateZ(&v, 3.1416);
      operator*(&v161, &v160, &v);
      CMatrix::operator=(&v160, &v161);
      CMatrix::~CMatrix(&v161);
      CMatrix::~CMatrix(&v);
    }
    CMatrix::CopyToRwMatrix(&v160, &v158);
    RtQuatConvertFromMatrix(&qpQuat, &v158);
    CMatrix::CMatrix(&v161, pPed->m_pMat);
    CMatrix::CopyToRwMatrix(v90, &pMatrix);
    RtQuatConvertFromMatrix(&v155, &pMatrix);
    v91 = pAnim->m_fCurrentTime;
    v92 = pAnim->m_pAnimBlendHierarchy->m_fTotalTime;
    RtQuatSetupSlerpCache(&v155, &qpQuat, &sCache);
    v93.n64_f32[0] = v91 / v92;
    if ( (float)(v91 / v92) <= 0.0 )
    {
      v98 = v155;
    }
    else if ( v93.n64_f32[0] >= 1.0 )
    {
      v98 = qpQuat;
    }
    else
    {
      v93.n64_f32[1] = 1.0 - v93.n64_f32[0];
      if ( !sCache.nearlyZeroOm )
      {
        v94 = &sCache.omega;
        v95.n64_u64[0] = vld1_dup_f32(v94).n64_u64[0];
        v96.n64_u64[0] = vmul_f32(v93, v95).n64_u64[0];
        v97.n64_u64[0] = vmul_f32(v96, v96).n64_u64[0];
        v93.n64_u64[0] = vadd_f32(
                           v96,
                           vmul_f32(
                             vmul_f32(v96, v97),
                             vadd_f32(
                               vmul_f32(
                                 v97,
                                 vadd_f32(
                                   vmul_f32(
                                     v97,
                                     vadd_f32(
                                       vmul_f32(
                                         v97,
                                         vadd_f32(
                                           vmul_f32(
                                             v97,
                                             vadd_f32(
                                               vmul_f32(v97, (float32x2_t)0x2F2EC9D32F2EC9D3LL),
                                               (float32x2_t)0xB2D72F34B2D72F34LL)),
                                           (float32x2_t)0x3638EF1B3638EF1BLL)),
                                       (float32x2_t)0xB9500D01B9500D01LL)),
                                   (float32x2_t)0x3C0888893C088889LL)),
                               (float32x2_t)0xBE2AAAABBE2AAAABLL))).n64_u64[0];
      }
      v98 = (RtQuat_0)vaddq_f32(
                        vmulq_lane_f32((float32x4_t)sCache.raFrom, v93, 1),
                        vmulq_n_f32((float32x4_t)sCache.raTo, v93.n64_f32[0]));
    }
    v.m_owner = 0;
    v.m_pRwMat = 0;
    memset(&v153.pos, 0, sizeof(v153.pos));
    v128 = 2.0
         / (float)((float)(v98.real * v98.real)
                 + (float)((float)((float)(v98.imag.x * v98.imag.x) + (float)(v98.imag.y * v98.imag.y))
                         + (float)(v98.imag.z * v98.imag.z)));
    v129 = v98.imag.z * v128;
    v130 = v98.imag.y * v128;
    v131 = v98.imag.x * v128;
    v132 = v98.imag.y * v130;
    v133 = v98.imag.x * v131;
    v134 = v98.real * v130;
    v135 = v98.imag.z * v131;
    v136 = v98.imag.x * v130;
    v137 = v98.real * v131;
    v153.right.y = v136 + (float)(v98.real * v129);
    v153.right.z = v135 - v134;
    v153.up.x = v136 - (float)(v98.real * v129);
    v153.up.z = (float)(v98.imag.y * v129) + v137;
    v153.at.y = (float)(v98.imag.y * v129) - v137;
    v153.at.x = v135 + v134;
    v153.right.x = 1.0 - (float)(v132 + (float)(v98.imag.z * v129));
    v153.up.y = 1.0 - (float)((float)(v98.imag.z * v129) + v133);
    v153.at.z = 1.0 - (float)(v133 + v132);
    v153.flags = 2;
    CMatrix::UpdateMatrix(&v, &v153);
    v.tx = x;
    v.ty = y;
    v.tz = v74;
    CPlaceable::SetMatrix(pPed, &v);
    CMatrix::~CMatrix(&v);
    CMatrix::~CMatrix(&v161);
    v127 = &v160;
    goto LABEL_155;
  }
LABEL_132:
  if ( zz > -0.8 && v14 <= 0.2 )
  {
    v99 = pVehicle->m_baseVehicleType;
    v100 = v99 == 9;
    if ( v99 != 9 )
      v100 = pVehicle->m_vehicleType == 2;
    if ( !v100 )
    {
      CMatrix::CMatrix(&v161, pVehicle->m_pMat);
      CTaskUtilityLineUpPedWithCar::GetLocalPositionToOpenCarDoor((CVector *)&v, this, pVehicle, 0.0, (int)pAnim);
      v160.zx = v.zx;
      *(_QWORD *)&v160.xx = *(_QWORD *)&v.xx;
      Multiply3x3((CVector *)&v, &v161, (const CVector *)&v160);
      v161.tx = v.xx + v161.tx;
      v161.ty = v.yx + v161.ty;
      v161.tz = v.zx + v161.tz;
      CPlaceable::SetMatrix(pPed, &v161);
      v127 = &v161;
LABEL_155:
      CMatrix::~CMatrix(v127);
      return 0;
    }
  }
  v101 = pPed->m_pMat;
  if ( v101 )
  {
    v101->tx = x;
    pPed->m_pMat->ty = y;
    p_tz = &pPed->m_pMat->tz;
  }
  else
  {
    p_tz = &pPed->m_transform.m_translate.z;
    pPed->m_transform.m_translate.x = x;
    pPed->m_transform.m_translate.y = y;
  }
  *p_tz = v74;
  v120 = pPed->m_pMat;
  if ( v120 )
  {
    tx = v120->tx;
    ty = v120->ty;
    tz = v120->tz;
    CMatrix::SetRotate(v120, 0.0, 0.0, pPed->m_fCurrentHeading);
    v124 = pPed->m_pMat;
    v125 = ty + v124->ty;
    v126 = tz + v124->tz;
    v124->tx = tx + v124->tx;
    v124->ty = v125;
    v124->tz = v126;
  }
  else
  {
    pPed->m_transform.m_heading = pPed->m_fCurrentHeading;
  }
  return 0;
}
// 50A054: variable 'v90' is possibly undefined
// 50A168: variable 'v103' is possibly undefined
// 50A186: variable 'v104' is possibly undefined

//----- (0050A5D4) --------------------------------------------------------
CVector *__fastcall CTaskUtilityLineUpPedWithCar::GetPositionToOpenCarDoor(
        CVector *retstr,
        CTaskUtilityLineUpPedWithCar *this,
        CVehicle *pVehicle,
        float XBlend,
        CAnimBlendAssociation *pAnim)
{
  __int64 v9; // d16
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  RwReal v12; // s2
  RwReal v13; // s4
  CVector *result; // r0
  CVector v15; // [sp+8h] [bp-70h] BYREF
  CMatrix v16; // [sp+18h] [bp-60h] BYREF

  CMatrix::CMatrix(&v16, pVehicle->m_pMat);
  CTaskUtilityLineUpPedWithCar::GetLocalPositionToOpenCarDoor(&v15, this, pVehicle, XBlend, (int)pAnim);
  retstr->z = v15.z;
  *(_QWORD *)&retstr->x = *(_QWORD *)&v15.x;
  Multiply3x3(&v15, &v16, retstr);
  v9 = *(_QWORD *)&v15.x;
  retstr->z = v15.z;
  *(_QWORD *)&retstr->x = v9;
  m_pMat = pVehicle->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pVehicle->m_transform;
  v12 = p_tx->m_translate.y + retstr->y;
  v13 = p_tx->m_translate.z + retstr->z;
  retstr->x = p_tx->m_translate.x + retstr->x;
  retstr->y = v12;
  retstr->z = v13;
  CMatrix::~CMatrix(&v16);
  return result;
}

//----- (0050A670) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
RwReal __fastcall CTaskUtilityLineUpPedWithCar::GetLocalPositionToOpenCarDoor(
        CVector *a1,
        CTaskUtilityLineUpPedWithCar *this,
        CVehicle *pVehicle,
        float XBlend,
        int a5)
{
  CBaseModelInfo *v8; // r10
  float v9; // s16
  int v10; // r1
  __int16 v11; // r0
  int v12; // r2
  int v13; // r6
  int m_iTargetDoor; // r0
  RwReal x; // r2
  float y; // r3
  float z; // r9
  float v18; // s0
  float v19; // s2
  float v20; // s4
  float v21; // s18
  float v22; // s20
  float v23; // s22
  float v24; // s24
  float v25; // s0
  float v26; // s14
  int v27; // lr
  uint32 m_hashKey; // r1
  float v29; // s0
  float v30; // r1
  float v31; // r6
  __int64 v32; // kr00_8
  uint32 v33; // r1
  float v34; // s0
  __int64 v35; // kr08_8
  float *v36; // r1
  float v37; // r12
  float v38; // s2
  float v39; // s4
  float v40; // s0
  uint32 v41; // r1
  __int64 v42; // kr18_8
  float v43; // s10
  uint32 v44; // r1
  __int64 v45; // kr20_8
  float *v46; // r1
  RwReal result; // r0
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r0
  float v50; // s2
  float v51; // s4
  __int64 v52; // d16
  float v53; // [sp+0h] [bp-68h]
  CVector v54; // [sp+4h] [bp-64h]
  CVector v55; // [sp+10h] [bp-58h] BYREF

  v8 = CModelInfo::ms_modelInfoPtrs[pVehicle->m_nModelIndex];
  if ( *((unsigned __int8 *)&pVehicle->m_nVehicleFlags + 1) << 31 && (this->m_iTargetDoor | 2) == 11 )
  {
    v9 = 0.0;
    if ( !a5 )
    {
LABEL_13:
      m_iTargetDoor = this->m_iTargetDoor;
      if ( m_iTargetDoor != 9 )
      {
        if ( m_iTargetDoor == 18 )
        {
          v13 = 2;
          if ( !a5 )
            goto LABEL_26;
LABEL_21:
          v11 = *(_WORD *)(a5 + 44);
          goto LABEL_24;
        }
        if ( m_iTargetDoor != 11 )
        {
          v13 = 0;
          if ( !a5 )
          {
LABEL_26:
            CVehicleAnimGroup::ComputeAnimDoorOffsets(
              &v55,
              &CVehicleAnimGroupData::m_vehicleAnimGroups[pVehicle->pHandling->AnimGroup],
              v13);
            x = v55.x;
            y = v55.y;
            z = v55.z;
            v18 = v55.z;
            v19 = v55.y;
            v20 = v55.x;
            goto LABEL_28;
          }
          goto LABEL_21;
        }
      }
      v13 = 1;
      if ( !a5 )
        goto LABEL_26;
      goto LABEL_21;
    }
  }
  else
  {
    v9 = pVehicle->pHandling->fSeatOffsetDist * XBlend;
    if ( !a5 )
      goto LABEL_13;
  }
  v10 = *(__int16 *)(a5 + 44);
  v11 = *(_WORD *)(a5 + 44);
  if ( (unsigned int)(v10 - 373) > 0xF )
  {
LABEL_12:
    if ( (unsigned int)(v10 - 108) >= 2 )
      goto LABEL_13;
    goto LABEL_8;
  }
  v12 = 1 << (v10 - 117);
  if ( (v12 & 0xC78F) == 0 )
  {
    if ( (v12 & 0x60) != 0 )
    {
      v13 = 0;
      goto LABEL_24;
    }
    goto LABEL_12;
  }
LABEL_8:
  v13 = 0;
  switch ( this->m_iTargetDoor )
  {
    case 8:
    case 0xA:
      break;
    case 9:
    case 0xB:
      v13 = 1;
      break;
    case 0x12:
      v13 = 2;
      break;
    default:
      v13 = 3;
      break;
  }
LABEL_24:
  if ( (unsigned int)(v11 - 389) > 1
    || (CVehicleAnimGroupData::m_vehicleAnimGroups[pVehicle->pHandling->AnimGroup].m_specialFlags & 0x20) == 0 )
  {
    goto LABEL_26;
  }
  CVehicleAnimGroup::ComputeAnimDoorOffsets(
    &v55,
    &CVehicleAnimGroupData::m_vehicleAnimGroups[pVehicle->pHandling->AnimGroup],
    v13);
  v21 = v55.x;
  v22 = v55.y;
  v23 = v55.z;
  v24 = *(float *)(a5 + 24);
  CVehicleAnimGroup::ComputeAnimDoorOffsets(&v55, CVehicleAnimGroupData::m_vehicleAnimGroups, v13);
  v25 = 1.0 - *(float *)(a5 + 24);
  v26 = v21 * v25;
  v19 = (float)(v24 * v55.y) + (float)(v22 * v25);
  v18 = (float)(v24 * v55.z) + (float)(v23 * v25);
  v20 = (float)(v24 * v55.x) + v26;
  y = v19;
  z = v18;
  x = v20;
LABEL_28:
  v27 = this->m_iTargetDoor;
  switch ( v27 )
  {
    case 8:
      m_hashKey = v8[2].m_hashKey;
      if ( *(_DWORD *)&v8[1].m_modelName[20] != 5 )
        m_hashKey += 48;
      v29 = *(float *)m_hashKey;
      v32 = *(_QWORD *)(m_hashKey + 4);
      v30 = *(float *)(m_hashKey + 8);
      LODWORD(v31) = v32;
      goto LABEL_39;
    case 9:
      v41 = v8[2].m_hashKey;
      v29 = *(float *)(v41 + 60);
      v42 = *(_QWORD *)(v41 + 64);
      v30 = *(float *)(v41 + 68);
      LODWORD(v31) = v42;
LABEL_39:
      v20 = v9 + v29;
      v37 = v9 + v29;
      v43 = x;
      LODWORD(x) ^= 0x80000000;
      v40 = v30 - z;
      v38 = v31 - y;
      goto LABEL_45;
    case 10:
      v33 = v8[2].m_hashKey;
      if ( *(_DWORD *)&v8[1].m_modelName[20] != 5 )
        v33 += 48;
      v34 = *(float *)v33;
      v35 = *(_QWORD *)(v33 + 4);
      v30 = *(float *)(v33 + 8);
      LODWORD(v31) = v35;
      goto LABEL_41;
    case 11:
      v44 = v8[2].m_hashKey;
      v34 = *(float *)(v44 + 60);
      v45 = *(_QWORD *)(v44 + 64);
      v30 = *(float *)(v44 + 68);
      LODWORD(v31) = v45;
LABEL_41:
      v37 = -(float)(v9 + v34);
      v40 = v30 - z;
      v38 = v31 - y;
      v39 = v37 - x;
      break;
    case 18:
      v46 = (float *)v8[2].m_hashKey;
      if ( *(_DWORD *)&v8[1].m_modelName[20] != 5 )
        v46 += 12;
      v31 = v46[1];
      v37 = *v46;
      v30 = v46[2];
      v43 = v37;
      v38 = v19 + v31;
      v40 = v18 + v30;
LABEL_45:
      v39 = v20 + v43;
      break;
    default:
      x = 0.0;
      v36 = (float *)v8[2].m_hashKey;
      y = 0.0;
      z = 0.0;
      if ( *(_DWORD *)&v8[1].m_modelName[20] != 5 )
        v36 += 12;
      v31 = v36[1];
      v37 = *v36;
      v30 = v36[2];
      v38 = v31;
      v39 = v37;
      v40 = v30;
      break;
  }
  a1->x = v39;
  a1->y = v38;
  a1->z = v40;
  result = *(float *)&pVehicle->m_baseVehicleType;
  if ( LODWORD(result) == 9 && v27 != 18 )
  {
    v53 = z;
    v54.x = v37;
    *(_QWORD *)&v54.y = __PAIR64__(LODWORD(v30), LODWORD(v31));
    CBike::GetCorrectedWorldDoorPosition((CBike *)pVehicle, a1, *(CVector *)&x, v54);
    m_pMat = pVehicle->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    v50 = a1->y;
    v51 = a1->z;
    if ( !m_pMat )
      p_tx = &pVehicle->m_transform;
    a1->x = a1->x - p_tx->m_translate.x;
    a1->y = v50 - p_tx->m_translate.y;
    a1->z = v51 - p_tx->m_translate.z;
    Multiply3x3(&v55, a1, m_pMat);
    v52 = *(_QWORD *)&v55.x;
    result = v55.z;
    a1->z = v55.z;
    *(_QWORD *)&a1->x = v52;
  }
  return result;
}
// 50A670: fragmented variable at r2.4 may be wrong
// 50A670: fragmented variable at r3.4 may be wrong

//----- (0050A9CC) --------------------------------------------------------
void __fastcall CCarEnterExit::QuitEnteringCar(CPed *pPed, CVehicle *pVehicle, const int iTargetDoor, bool bCarJacker)
{
  _BOOL4 v6; // r9
  CAnimBlendAssociation *i; // r0
  uint16 m_bitsFlag; // r1
  CVehicle *v10; // r0
  uint8 v11; // r1
  CVehicle *v12; // r0
  uint8 v13; // r1

  v6 = bCarJacker;
  for ( i = RpAnimBlendClumpGetFirstAssociation((RpClump_0 *)pPed->m_pRwObject, 0x10u);
        i;
        i = RpAnimBlendGetNextAssociation(i, 0x10u) )
  {
    m_bitsFlag = i->m_bitsFlag;
    i->m_fBlendDelta = -1000.0;
    i->m_bitsFlag = m_bitsFlag | 4;
  }
  CPed::RestartNonPartialAnims(pPed);
  if ( !RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 3u) )
    CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, pPed->m_motionAnimGroup, ANIM_STD_IDLE, 1000.0);
  if ( v6 )
    *(_DWORD *)&pVehicle->m_nVehicleFlags &= ~0x80000u;
  if ( pVehicle->m_nNumGettingIn )
    --pVehicle->m_nNumGettingIn;
  if ( pVehicle->m_baseVehicleType == 9 || (pVehicle->pHandling->mFlags & 0x200) != 0 )
  {
    if ( (iTargetDoor | 2) == 11 )
    {
      v12 = pVehicle;
      v13 = 10;
    }
    else
    {
      if ( (iTargetDoor | 2) != 10 )
      {
LABEL_18:
        LOBYTE(pVehicle[1].m_vecTurnFriction.z) &= ~8u;
        goto LABEL_26;
      }
      v12 = pVehicle;
      v13 = 5;
    }
    CVehicle::ClearGettingInFlags(v12, v13);
    goto LABEL_18;
  }
  switch ( iTargetDoor )
  {
    case 8:
      v10 = pVehicle;
      v11 = 4;
      goto LABEL_25;
    case 9:
      v10 = pVehicle;
      v11 = 8;
      goto LABEL_25;
    case 10:
      if ( !pVehicle->m_nMaxPassengers )
        goto LABEL_24;
      v10 = pVehicle;
      v11 = 1;
      goto LABEL_25;
    case 11:
      if ( pVehicle->m_nMaxPassengers )
      {
        v10 = pVehicle;
        v11 = 2;
      }
      else
      {
LABEL_24:
        v10 = pVehicle;
        v11 = 3;
      }
LABEL_25:
      CVehicle::ClearGettingInFlags(v10, v11);
      break;
    default:
      break;
  }
LABEL_26:
  *(_DWORD *)&pPed->m_nFlags |= 1u;
}

//----- (0050AAC8) --------------------------------------------------------
bool __fastcall CCarEnterExit::SetPedInCarDirect(CPed *pPed, CVehicle *pVehicle, const int iTargetDoor, bool bDriver)
{
  CTaskSimpleCarSetPedInAsDriver *v6; // r0
  CTaskComplexCarDriveWander *v7; // r6
  int v8; // r6
  CTaskSimpleCarSetPedInAsPassenger *v9; // r0
  CTaskComplexCarDrive *v10; // r8
  CPed *pDriver; // r4
  uint32 v12; // r0
  uint32 PedFlag; // r0
  CPed **pPassengers; // r5
  CPed *v15; // r4
  uint32 v16; // r0
  uint32 v17; // r0
  CTaskSimpleCarSetPedInAsPassenger v19; // [sp+0h] [bp-38h] BYREF

  if ( bDriver )
  {
    CTaskSimpleCarSetPedInAsDriver::CTaskSimpleCarSetPedInAsDriver((CTaskSimpleCarSetPedInAsDriver *)&v19, pVehicle, 0);
    LOBYTE(v19.m_pUtility) = 1;
    CTaskSimpleCarSetPedInAsDriver::ProcessPed(v6, pPed);
    v7 = (CTaskComplexCarDriveWander *)CTask::operator new(0x24u);
    CTaskComplexCarDriveWander::CTaskComplexCarDriveWander(
      v7,
      pVehicle,
      pVehicle->AutoPilot.DrivingMode,
      (float)pVehicle->AutoPilot.CruiseSpeed);
    v7->m_bAsDriver = 1;
    CTaskManager::SetTask(&pPed->m_pPedIntelligence->m_taskManager, v7, 3, 0);
    CTaskSimpleCarSetPedInAsDriver::~CTaskSimpleCarSetPedInAsDriver((CTaskSimpleCarSetPedInAsDriver *)&v19);
    return 1;
  }
  if ( pVehicle->m_baseVehicleType == 9 || (pVehicle->pHandling->mFlags & 0x200) != 0 )
  {
    if ( (iTargetDoor | 2) == 11 )
    {
      v8 = 0;
      goto LABEL_10;
    }
LABEL_9:
    v8 = -1;
    goto LABEL_10;
  }
  if ( (unsigned int)(iTargetDoor - 8) >= 4 )
    goto LABEL_9;
  v8 = dword_61E48C[iTargetDoor - 8];
LABEL_10:
  CTaskSimpleCarSetPedInAsPassenger::CTaskSimpleCarSetPedInAsPassenger(&v19, pVehicle, iTargetDoor, 0);
  v19.m_bWarpingInToCar = 1;
  CTaskSimpleCarSetPedInAsPassenger::ProcessPed(v9, pPed);
  if ( pVehicle->m_baseVehicleType == 9 )
  {
    v10 = (CTaskComplexCarDrive *)CTask::operator new(0x24u);
    CTaskComplexCarDrive::CTaskComplexCarDrive(v10, pVehicle);
    v10->m_bAsDriver = 0;
    CTaskManager::SetTask(&pPed->m_pPedIntelligence->m_taskManager, v10, 3, 0);
  }
  pDriver = pVehicle->pDriver;
  if ( pDriver )
  {
    if ( pPed->CharCreatedBy == 2
      || (v12 = CPedType::GetPedFlag(pDriver->m_nPedType),
          CAcquaintance::SetAsAcquaintance(&pPed->m_acquaintances, 0, v12),
          (pDriver = pVehicle->pDriver) != 0) )
    {
      if ( pDriver->CharCreatedBy != 2 )
      {
        PedFlag = CPedType::GetPedFlag(pPed->m_nPedType);
        CAcquaintance::SetAsAcquaintance(&pDriver->m_acquaintances, 0, PedFlag);
      }
    }
  }
  if ( v8 >= 1 )
  {
    pPassengers = pVehicle->pPassengers;
    do
    {
      v15 = *pPassengers;
      if ( *pPassengers )
      {
        if ( pPed->CharCreatedBy != 2 )
        {
          v16 = CPedType::GetPedFlag(v15->m_nPedType);
          CAcquaintance::SetAsAcquaintance(&pPed->m_acquaintances, 0, v16);
        }
        if ( v15->CharCreatedBy != 2 )
        {
          v17 = CPedType::GetPedFlag(pPed->m_nPedType);
          CAcquaintance::SetAsAcquaintance(&v15->m_acquaintances, 0, v17);
        }
      }
      ++pPassengers;
      --v8;
    }
    while ( v8 );
  }
  CTaskSimpleCarSetPedInAsPassenger::~CTaskSimpleCarSetPedInAsPassenger(&v19);
  return 1;
}
// 50AAEE: variable 'v6' is possibly undefined
// 50AB7A: variable 'v9' is possibly undefined
// 61E48C: using guessed type _DWORD dword_61E48C[4];

//----- (0050AC4C) --------------------------------------------------------
void __fastcall CTaskSimpleHitHead::CTaskSimpleHitHead(CTaskSimpleHitHead *this)
{
  int v1; // r0

  CTaskSimple::CTaskSimple(this);
  *(_BYTE *)(v1 + 8) = 0;
  *(_DWORD *)(v1 + 12) = 0;
  *(_DWORD *)v1 = &off_66B630;
}
// 50AC58: variable 'v1' is possibly undefined
// 66B630: using guessed type void *;

//----- (0050AC6C) --------------------------------------------------------
void __fastcall CTaskSimpleHitHead::~CTaskSimpleHitHead(CTaskSimpleHitHead *this)
{
  CAnimBlendAssociation *m_pAnim; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_66B630;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  sub_1A01F4(this);
}
// 66B630: using guessed type void *off_66B630;

//----- (0050ACA0) --------------------------------------------------------
void __fastcall CTaskSimpleHitHead::~CTaskSimpleHitHead(CTaskSimpleHitHead *this)
{
  CAnimBlendAssociation *m_pAnim; // r0
  void *v3; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_66B630;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v3);
}
// 50ACCA: variable 'v3' is possibly undefined
// 66B630: using guessed type void *off_66B630;

//----- (0050ACD8) --------------------------------------------------------
bool __fastcall CTaskSimpleHitHead::MakeAbortable(
        CTaskSimpleHitHead *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0
  bool result; // r0

  m_pAnim = this->m_pAnim;
  if ( (unsigned int)(iPriority - 1) > 1 )
  {
    if ( m_pAnim )
      m_pAnim->m_fBlendDelta = -4.0;
    return 0;
  }
  else
  {
    if ( m_pAnim )
    {
      m_pAnim->m_fBlendDelta = -4.0;
      CAnimBlendAssociation::SetFinishCallback(this->m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
      this->m_pAnim = 0;
    }
    result = 1;
    this->m_bIsFinished = 1;
  }
  return result;
}

//----- (0050AD1C) --------------------------------------------------------
bool __fastcall CTaskSimpleHitHead::ProcessPed(CTaskSimpleHitHead *this, CPed *pPed)
{
  CAnimBlendAssociation *v4; // r0

  if ( this->m_bIsFinished )
    return 1;
  if ( this->m_pAnim )
    return 0;
  v4 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, ANIM_STD_HIT_WALL, 8.0);
  this->m_pAnim = v4;
  CAnimBlendAssociation::SetFinishCallback(v4, CTaskSimpleHitHead::FinishAnimHitHeadCB, this);
  return this->m_bIsFinished;
}

//----- (0050AD60) --------------------------------------------------------
void __fastcall CTaskSimpleHitHead::StartAnim(CTaskSimpleHitHead *this, CPed *pPed)
{
  CAnimBlendAssociation *v3; // r0

  v3 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, ANIM_STD_HIT_WALL, 8.0);
  this->m_pAnim = v3;
  sub_18C19C(v3, CTaskSimpleHitHead::FinishAnimHitHeadCB, this);
}

//----- (0050AD8C) --------------------------------------------------------
void __fastcall CTaskSimpleHitHead::FinishAnimHitHeadCB(CAnimBlendAssociation *pAnim, void *pData)
{
  *((_BYTE *)pData + 8) = 1;
  *((_DWORD *)pData + 3) = 0;
}

//----- (0050AD98) --------------------------------------------------------
void __fastcall CTaskSimpleEvasiveStep::CTaskSimpleEvasiveStep(CTaskSimpleEvasiveStep *this, CEntity *pTargetEntity)
{
  CTaskSimple::CTaskSimple(this);
  this->m_bIsFinished = 0;
  this->m_pAnim = 0;
  this->_vptr$CTask = (int (**)(void))&off_66B664;
  this->m_pTargetEntity = pTargetEntity;
  if ( pTargetEntity )
    CEntity::RegisterReference(pTargetEntity, &this->m_pTargetEntity);
}
// 66B664: using guessed type void *off_66B664;

//----- (0050ADD0) --------------------------------------------------------
void __fastcall CTaskSimpleEvasiveStep::~CTaskSimpleEvasiveStep(CTaskSimpleEvasiveStep *this)
{
  CAnimBlendAssociation *m_pAnim; // r0
  CEntity *m_pTargetEntity; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_66B664;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  m_pTargetEntity = this->m_pTargetEntity;
  if ( m_pTargetEntity )
    CEntity::CleanUpOldReference(m_pTargetEntity, &this->m_pTargetEntity);
  sub_1A01F4(this);
}
// 66B664: using guessed type void *off_66B664;

//----- (0050AE10) --------------------------------------------------------
void __fastcall CTaskSimpleEvasiveStep::~CTaskSimpleEvasiveStep(CTaskSimpleEvasiveStep *this)
{
  CAnimBlendAssociation *m_pAnim; // r0
  CEntity *m_pTargetEntity; // r0
  void *v4; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_66B664;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  m_pTargetEntity = this->m_pTargetEntity;
  if ( m_pTargetEntity )
    CEntity::CleanUpOldReference(m_pTargetEntity, &this->m_pTargetEntity);
  CTask::~CTask(this);
  sub_197118(v4);
}
// 50AE48: variable 'v4' is possibly undefined
// 66B664: using guessed type void *off_66B664;

//----- (0050AE54) --------------------------------------------------------
bool __fastcall CTaskSimpleEvasiveStep::MakeAbortable(
        CTaskSimpleEvasiveStep *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0

  if ( (unsigned int)(iPriority - 1) > 1 )
    return 0;
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
  {
    m_pAnim->m_fBlendDelta = -4.0;
    CAnimBlendAssociation::SetFinishCallback(this->m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
    this->m_pAnim = 0;
  }
  return 1;
}

//----- (0050AE8C) --------------------------------------------------------
bool __fastcall CTaskSimpleEvasiveStep::ProcessPed(CTaskSimpleEvasiveStep *this, CPed *pPed)
{
  bool v4; // r5
  CEntity *m_pTargetEntity; // r0
  RpClump_0 *m_pRwObject; // r0
  CAnimBlendAssociation *v8; // r0

  if ( this->m_bIsFinished )
    return 1;
  m_pTargetEntity = this->m_pTargetEntity;
  if ( !m_pTargetEntity )
    return 1;
  if ( this->m_pAnim )
    return 0;
  if ( (*(_BYTE *)&m_pTargetEntity->m_info & 7) == 2 )
    CPed::Say(pPed, 0x4Au, 0, 1.0, 0, 0, 0);
  m_pRwObject = (RpClump_0 *)pPed->m_pRwObject;
  v4 = 0;
  v8 = CAnimManager::BlendAnimation(m_pRwObject, ANIM_STD_PED, ANIM_STD_EVADE_STEP, 8.0);
  this->m_pAnim = v8;
  v8->m_bitsFlag &= ~4u;
  CAnimBlendAssociation::SetFinishCallback(this->m_pAnim, CTaskSimpleEvasiveStep::FinishAnimEvasiveStepCB, this);
  return v4;
}

//----- (0050AF00) --------------------------------------------------------
void __fastcall CTaskSimpleEvasiveStep::StartAnim(CTaskSimpleEvasiveStep *this, CPed *pPed)
{
  CAnimBlendAssociation *v3; // r0

  v3 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, ANIM_STD_EVADE_STEP, 8.0);
  this->m_pAnim = v3;
  v3->m_bitsFlag &= ~4u;
  sub_18C19C(this->m_pAnim, CTaskSimpleEvasiveStep::FinishAnimEvasiveStepCB, this);
}

//----- (0050AF34) --------------------------------------------------------
void __fastcall CTaskSimpleEvasiveStep::FinishAnimEvasiveStepCB(CAnimBlendAssociation *pAnim, void *pData)
{
  int v2; // r0

  *(_WORD *)(*((_DWORD *)pData + 4) + 46) |= 4u;
  v2 = *((_DWORD *)pData + 4);
  if ( *(float *)(v2 + 28) >= 0.0 )
    *(_DWORD *)(v2 + 28) = -1065353216;
  *((_DWORD *)pData + 4) = 0;
  *((_BYTE *)pData + 12) = 1;
}

//----- (0050AF60) --------------------------------------------------------
void __fastcall CTaskComplexEvasiveStep::CTaskComplexEvasiveStep(
        CTaskComplexEvasiveStep *this,
        CEntity *pTargetEntity,
        const CVector *vMoveDir)
{
  __int64 v6; // d16
  RwReal z; // r0

  CTaskComplex::CTaskComplex(this);
  this->_vptr$CTask = (int (**)(void))&off_66B698;
  v6 = *(_QWORD *)&vMoveDir->x;
  z = vMoveDir->z;
  this->m_pTargetEntity = pTargetEntity;
  this->m_vMoveDir.z = z;
  *(_QWORD *)&this->m_vMoveDir.x = v6;
  if ( pTargetEntity )
    CEntity::RegisterReference(pTargetEntity, &this->m_pTargetEntity);
}
// 66B698: using guessed type void *;

//----- (0050AFA8) --------------------------------------------------------
void __fastcall CTaskComplexEvasiveStep::~CTaskComplexEvasiveStep(CTaskComplexEvasiveStep *this)
{
  CEntity *m_pTargetEntity; // r0
  CEntity **p_m_pTargetEntity; // r1

  p_m_pTargetEntity = &this->m_pTargetEntity;
  m_pTargetEntity = this->m_pTargetEntity;
  this->_vptr$CTask = (int (**)(void))&off_66B698;
  if ( m_pTargetEntity )
    CEntity::CleanUpOldReference(m_pTargetEntity, p_m_pTargetEntity);
  sub_18EDB4(this);
}
// 66B698: using guessed type void *off_66B698;

//----- (0050AFD4) --------------------------------------------------------
void __fastcall CTaskComplexEvasiveStep::~CTaskComplexEvasiveStep(CTaskComplexEvasiveStep *this)
{
  CEntity *m_pTargetEntity; // r0
  CEntity **p_m_pTargetEntity; // r1
  void *v4; // r0

  p_m_pTargetEntity = &this->m_pTargetEntity;
  m_pTargetEntity = this->m_pTargetEntity;
  this->_vptr$CTask = (int (**)(void))&off_66B698;
  if ( m_pTargetEntity )
    CEntity::CleanUpOldReference(m_pTargetEntity, p_m_pTargetEntity);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 50AFFC: variable 'v4' is possibly undefined
// 66B698: using guessed type void *off_66B698;

//----- (0050B004) --------------------------------------------------------
float __fastcall CTaskComplexEvasiveStep::ComputeTargetHeading(const CTaskComplexEvasiveStep *this)
{
  return sub_1991B4(
           COERCE_FLOAT(LODWORD(this->m_vMoveDir.x) ^ 0x80000000),
           COERCE_FLOAT((*(_QWORD *)&this->m_vMoveDir.x ^ 0x8000000080000000LL) >> 32),
           0.0,
           0.0);
}

//----- (0050B018) --------------------------------------------------------
CTask *__fastcall CTaskComplexEvasiveStep::CreateSubTask(const CTaskComplexEvasiveStep *this, const int iSubTaskType)
{
  CTaskSimpleAchieveHeading *v3; // r4
  float RadianAngleBetweenPoints; // r0
  void *v5; // r6
  CEntity *m_pTargetEntity; // r5

  v3 = 0;
  if ( iSubTaskType == 501 )
  {
    v5 = CTask::operator new(0x14u);
    m_pTargetEntity = this->m_pTargetEntity;
    CTaskSimple::CTaskSimple((CTaskSimple *)v5);
    *((_BYTE *)v5 + 12) = 0;
    *((_DWORD *)v5 + 4) = 0;
    *(_DWORD *)v5 = &off_66B664;
    *((_DWORD *)v5 + 2) = m_pTargetEntity;
    if ( m_pTargetEntity )
      CEntity::RegisterReference(m_pTargetEntity, (CEntity **)v5 + 2);
    return (CTask *)v5;
  }
  else if ( iSubTaskType == 902 )
  {
    v3 = (CTaskSimpleAchieveHeading *)CTask::operator new(0x18u);
    RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                                 COERCE_FLOAT(LODWORD(this->m_vMoveDir.x) ^ 0x80000000),
                                 COERCE_FLOAT((*(_QWORD *)&this->m_vMoveDir.x ^ 0x8000000080000000LL) >> 32),
                                 0.0,
                                 0.0);
    CTaskSimpleAchieveHeading::CTaskSimpleAchieveHeading(v3, RadianAngleBetweenPoints, 2.0, 0.2);
  }
  return v3;
}
// 66B664: using guessed type void *off_66B664;

//----- (0050B0A8) --------------------------------------------------------
CTask *__fastcall CTaskComplexEvasiveStep::CreateNextSubTask(CTaskComplexEvasiveStep *this, CPed *pPed)
{
  int v3; // r0
  int v5; // r1

  v3 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v3 == 501 )
  {
    v5 = 1302;
  }
  else
  {
    if ( v3 != 902 )
      return 0;
    v5 = 501;
  }
  return CTaskComplexEvasiveStep::CreateSubTask(this, v5);
}

//----- (0050B0DC) --------------------------------------------------------
CTask *__fastcall CTaskComplexEvasiveStep::CreateFirstSubTask(CTaskComplexEvasiveStep *this, CPed *pPed)
{
  CTaskSimpleAchieveHeading *v3; // r5
  float RadianAngleBetweenPoints; // r1
  CTask *result; // r0

  v3 = (CTaskSimpleAchieveHeading *)CTask::operator new(0x18u);
  RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                               COERCE_FLOAT(LODWORD(this->m_vMoveDir.x) ^ 0x80000000),
                               COERCE_FLOAT((*(_QWORD *)&this->m_vMoveDir.x ^ 0x8000000080000000LL) >> 32),
                               0.0,
                               0.0);
  sub_19DE08(v3, RadianAngleBetweenPoints, 2.0, 0.2);
  return result;
}

//----- (0050B11C) --------------------------------------------------------
CTask *__fastcall CTaskComplexEvasiveStep::ControlSubTask(CTaskComplexEvasiveStep *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (0050B120) --------------------------------------------------------
void __fastcall CTaskSimpleEvasiveDive::CTaskSimpleEvasiveDive(CTaskSimpleEvasiveDive *this, CVehicle *pTargetVehicle)
{
  CTaskSimple::CTaskSimple(this);
  this->m_bIsFinished = 0;
  this->m_pAnim = 0;
  this->_vptr$CTask = (int (**)(void))&off_66B6D4;
  this->m_pTargetVehicle = pTargetVehicle;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66B6D4: using guessed type void *off_66B6D4;

//----- (0050B158) --------------------------------------------------------
void __fastcall CTaskSimpleEvasiveDive::~CTaskSimpleEvasiveDive(CTaskSimpleEvasiveDive *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CAnimBlendAssociation *m_pAnim; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B6D4;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  sub_1A01F4(this);
}
// 66B6D4: using guessed type void *;

//----- (0050B198) --------------------------------------------------------
void __fastcall CTaskSimpleEvasiveDive::~CTaskSimpleEvasiveDive(CTaskSimpleEvasiveDive *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  CAnimBlendAssociation *m_pAnim; // r0
  void *v5; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B6D4;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v5);
}
// 50B1D0: variable 'v5' is possibly undefined
// 66B6D4: using guessed type void *off_66B6D4;

//----- (0050B1DC) --------------------------------------------------------
bool __fastcall CTaskSimpleEvasiveDive::MakeAbortable(
        CTaskSimpleEvasiveDive *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0
  int m_iAccumulatedTime; // r0

  if ( iPriority == 2 )
  {
    m_pAnim = this->m_pAnim;
    if ( m_pAnim )
    {
      m_pAnim->m_fBlendDelta = -1000.0;
      return 1;
    }
    return 1;
  }
  if ( pEvent )
  {
    if ( (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) == 9 )
    {
      m_iAccumulatedTime = pEvent[1].m_iAccumulatedTime;
      if ( m_iAccumulatedTime )
      {
        if ( (*(_BYTE *)(m_iAccumulatedTime + 58) & 7) == 2 && (unsigned int)pEvent[2]._vptr$CEvent - 49 < 2 )
          return 1;
      }
    }
  }
  return 0;
}

//----- (0050B224) --------------------------------------------------------
bool __fastcall CTaskSimpleEvasiveDive::ProcessPed(CTaskSimpleEvasiveDive *this, CPed *pPed)
{
  if ( this->m_bIsFinished )
    return 1;
  if ( !this->m_pAnim )
    CTaskSimpleEvasiveDive::StartAnim(this, pPed);
  return 0;
}

//----- (0050B244) --------------------------------------------------------
void __fastcall CTaskSimpleEvasiveDive::StartAnim(CTaskSimpleEvasiveDive *this, CPed *pPed)
{
  CAnimBlendAssociation *v4; // r0
  CVehicle *m_pTargetVehicle; // r0
  const CPed *pDriver; // r0
  CWanted *PlayerWanted; // r0
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_m_transform; // r5
  CSimpleTransform *p_tx; // r2
  CWanted *v11; // r0
  CMatrix *v12; // r1

  CPed::Say(pPed, 0x4Au, 0, 1.0, 0, 0, 0);
  v4 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_STD_PED, ANIM_STD_EVADE_DIVE, 8.0);
  this->m_pAnim = v4;
  CAnimBlendAssociation::SetFinishCallback(v4, CTaskSimpleEvasiveDive::FinishAnimEvasiveDiveCB, this);
  m_pTargetVehicle = this->m_pTargetVehicle;
  if ( m_pTargetVehicle )
  {
    if ( pPed->m_nPedType == 6 )
    {
      pDriver = m_pTargetVehicle->pDriver;
      if ( pDriver )
      {
        if ( CPed::IsPlayer(pDriver) )
        {
          PlayerWanted = FindPlayerWanted(-1);
          m_pMat = pPed->m_pMat;
          p_m_transform = &pPed->m_transform;
          p_tx = &pPed->m_transform;
          if ( m_pMat )
            p_tx = (CSimpleTransform *)&m_pMat->tx;
          CWanted::RegisterCrime_Immediately(
            PlayerWanted,
            CRIME_RECKLESS_DRIVING,
            &p_tx->m_translate,
            (u_native)pPed,
            0);
          v11 = FindPlayerWanted(-1);
          v12 = pPed->m_pMat;
          if ( v12 )
            p_m_transform = (CSimpleTransform *)&v12->tx;
          CWanted::RegisterCrime_Immediately(v11, CRIME_SPEEDING, &p_m_transform->m_translate, (u_native)pPed, 0);
        }
      }
    }
  }
}

//----- (0050B2EC) --------------------------------------------------------
void __fastcall CTaskSimpleEvasiveDive::FinishAnimEvasiveDiveCB(CAnimBlendAssociation *pAnim, void *pData)
{
  *((_DWORD *)pData + 4) = 0;
  *((_BYTE *)pData + 12) = 1;
}

//----- (0050B2F8) --------------------------------------------------------
void __fastcall CTaskComplexEvasiveDiveAndGetUp::CTaskComplexEvasiveDiveAndGetUp(
        CTaskComplexEvasiveDiveAndGetUp *this,
        CVehicle *pTargetVehicle,
        const int iUnconsciousTime,
        const CVector *vDiveDir,
        bool bAchieveHeadingFirst)
{
  __int64 v9; // d16

  CTaskComplex::CTaskComplex(this);
  this->m_iUnconsciousTime = iUnconsciousTime;
  this->_vptr$CTask = (int (**)(void))&off_66B708;
  this->m_pTargetVehicle = pTargetVehicle;
  v9 = *(_QWORD *)&vDiveDir->x;
  this->m_vDiveDir.z = vDiveDir->z;
  this->m_bAchieveHeadingFirst = bAchieveHeadingFirst;
  *(_QWORD *)&this->m_vDiveDir.x = v9;
  if ( pTargetVehicle )
    CEntity::RegisterReference(pTargetVehicle, &this->m_pTargetVehicle);
}
// 66B708: using guessed type void *;

//----- (0050B34C) --------------------------------------------------------
void __fastcall CTaskComplexEvasiveDiveAndGetUp::~CTaskComplexEvasiveDiveAndGetUp(
        CTaskComplexEvasiveDiveAndGetUp *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  void *v4; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B708;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 50B374: variable 'v4' is possibly undefined
// 66B708: using guessed type void *off_66B708;

//----- (0050B37C) --------------------------------------------------------
bool __fastcall CTaskComplexEvasiveDiveAndGetUp::MakeAbortable(
        CTaskComplexEvasiveDiveAndGetUp *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  int v6; // r0
  bool v7; // zf
  bool v8; // r4
  CAnimBlendAssociation *Association; // r0

  v6 = (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
        + 7))(
         this->m_pSubTask,
         pPed,
         iPriority,
         pEvent);
  v7 = iPriority == 2;
  v8 = v6;
  if ( iPriority == 2 )
    v7 = v6 == 1;
  if ( v7 )
  {
    Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x7Fu);
    if ( Association )
      Association->m_fBlendDelta = -1000.0;
  }
  return v8;
}

//----- (0050B3B8) --------------------------------------------------------
float __fastcall CTaskComplexEvasiveDiveAndGetUp::ComputeTargetHeading(const CTaskComplexEvasiveDiveAndGetUp *this)
{
  return sub_1991B4(this->m_vDiveDir.x, this->m_vDiveDir.y, 0.0, 0.0);
}

//----- (0050B3C8) --------------------------------------------------------
CTask *__fastcall CTaskComplexEvasiveDiveAndGetUp::CreateNextSubTask(CTaskComplexEvasiveDiveAndGetUp *this, CPed *pPed)
{
  int v4; // r0
  int v5; // r1
  float v7; // r0

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v4 > 502 )
  {
    if ( v4 == 503 )
    {
      v5 = 202;
      return CTaskComplexEvasiveDiveAndGetUp::CreateSubTask(this, v5);
    }
    if ( v4 == 902 )
    {
      v5 = 503;
      return CTaskComplexEvasiveDiveAndGetUp::CreateSubTask(this, v5);
    }
    return 0;
  }
  if ( v4 == 202 )
  {
    v7 = CGeneral::LimitRadianAngle(pPed->m_fCurrentHeading);
    v5 = 205;
    pPed->m_fCurrentHeading = v7 + -1.5708;
    pPed->m_fDesiredHeading = v7 + -1.5708;
    return CTaskComplexEvasiveDiveAndGetUp::CreateSubTask(this, v5);
  }
  if ( v4 != 205 )
    return 0;
  v5 = 1302;
  return CTaskComplexEvasiveDiveAndGetUp::CreateSubTask(this, v5);
}

//----- (0050B43C) --------------------------------------------------------
CTask *__fastcall CTaskComplexEvasiveDiveAndGetUp::CreateSubTask(
        const CTaskComplexEvasiveDiveAndGetUp *this,
        const int iSubTaskType)
{
  void *v3; // r4
  CTaskSimpleGetUp *v4; // r0
  CTask *result; // r0
  CTaskSimpleAchieveHeading *v6; // r4
  float RadianAngleBetweenPoints; // r0
  int m_iUnconsciousTime; // r5
  CVehicle *m_pTargetVehicle; // r5

  v3 = 0;
  if ( iSubTaskType > 502 )
  {
    if ( iSubTaskType == 503 )
    {
      v3 = CTask::operator new(0x14u);
      m_pTargetVehicle = this->m_pTargetVehicle;
      CTaskSimple::CTaskSimple((CTaskSimple *)v3);
      *((_BYTE *)v3 + 12) = 0;
      *((_DWORD *)v3 + 4) = 0;
      *(_DWORD *)v3 = &off_66B6D4;
      *((_DWORD *)v3 + 2) = m_pTargetVehicle;
      if ( m_pTargetVehicle )
      {
        CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v3 + 2);
        return (CTask *)v3;
      }
    }
    else if ( iSubTaskType == 902 )
    {
      v6 = (CTaskSimpleAchieveHeading *)CTask::operator new(0x18u);
      RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(this->m_vDiveDir.x, this->m_vDiveDir.y, 0.0, 0.0);
      CTaskSimpleAchieveHeading::CTaskSimpleAchieveHeading(v6, RadianAngleBetweenPoints, 2.0, 0.2);
      return result;
    }
  }
  else if ( iSubTaskType == 202 )
  {
    v3 = CTask::operator new(0x18u);
    m_iUnconsciousTime = this->m_iUnconsciousTime;
    CTaskSimple::CTaskSimple((CTaskSimple *)v3);
    *((_WORD *)v3 + 8) = 0;
    *((_DWORD *)v3 + 5) = m_iUnconsciousTime;
    *((_DWORD *)v3 + 2) = 0;
    *((_DWORD *)v3 + 3) = 0;
    *(_DWORD *)v3 = &off_665750;
  }
  else if ( iSubTaskType == 205 )
  {
    v4 = (CTaskSimpleGetUp *)CTask::operator new(0x10u);
    CTaskSimpleGetUp::CTaskSimpleGetUp(v4);
    return result;
  }
  return (CTask *)v3;
}
// 665750: using guessed type void *off_665750;
// 66B6D4: using guessed type void *off_66B6D4;
// 678E00: using guessed type void *`vtable for'CTaskSimplePause;

//----- (0050B504) --------------------------------------------------------
CTask *__fastcall CTaskComplexEvasiveDiveAndGetUp::CreateFirstSubTask(
        CTaskComplexEvasiveDiveAndGetUp *this,
        CPed *pPed)
{
  int v2; // r1

  v2 = 902;
  if ( !this->m_bAchieveHeadingFirst )
    v2 = 503;
  return CTaskComplexEvasiveDiveAndGetUp::CreateSubTask(this, v2);
}

//----- (0050B516) --------------------------------------------------------
CTask *__fastcall CTaskComplexEvasiveDiveAndGetUp::ControlSubTask(CTaskComplexEvasiveDiveAndGetUp *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (0050B51C) --------------------------------------------------------
void __fastcall CTaskComplexHitPedWithCar::CTaskComplexHitPedWithCar(
        CTaskComplexHitPedWithCar *this,
        CVehicle *pVehicle,
        const float fImpulseMagnitude)
{
  CTaskComplex::CTaskComplex(this);
  this->m_fImpulseMagnitude = fImpulseMagnitude;
  this->m_iDownTime = 1000;
  this->_vptr$CTask = (int (**)(void))&off_66B744;
  this->m_pVehicle = pVehicle;
  if ( pVehicle )
    CEntity::RegisterReference(pVehicle, &this->m_pVehicle);
}
// 66B744: using guessed type void *;

//----- (0050B560) --------------------------------------------------------
void __fastcall CTaskComplexHitPedWithCar::~CTaskComplexHitPedWithCar(CTaskComplexHitPedWithCar *this)
{
  CVehicle *m_pVehicle; // r0
  CEntity **p_m_pVehicle; // r1

  p_m_pVehicle = &this->m_pVehicle;
  m_pVehicle = this->m_pVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B744;
  if ( m_pVehicle )
    CEntity::CleanUpOldReference(m_pVehicle, p_m_pVehicle);
  sub_18EDB4(this);
}
// 66B744: using guessed type void *off_66B744;

//----- (0050B58C) --------------------------------------------------------
void __fastcall CTaskComplexHitPedWithCar::~CTaskComplexHitPedWithCar(CTaskComplexHitPedWithCar *this)
{
  CVehicle *m_pVehicle; // r0
  CEntity **p_m_pVehicle; // r1
  void *v4; // r0

  p_m_pVehicle = &this->m_pVehicle;
  m_pVehicle = this->m_pVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B744;
  if ( m_pVehicle )
    CEntity::CleanUpOldReference(m_pVehicle, p_m_pVehicle);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 50B5B4: variable 'v4' is possibly undefined
// 66B744: using guessed type void *off_66B744;

//----- (0050B5BC) --------------------------------------------------------
CTask *__fastcall CTaskComplexHitPedWithCar::CreateNextSubTask(CTaskComplexHitPedWithCar *this, CPed *pPed)
{
  CTask *result; // r0
  unsigned int v4; // r0
  AnimationId v5; // r5
  CTaskComplexFallAndGetUp *v6; // r0

  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 507
    || LOBYTE(this->m_pSubTask[2]._vptr$CTask) )
  {
    return 0;
  }
  v4 = this->m_iPedHitSide - 1;
  if ( v4 > 2 )
    v5 = ANIM_STD_HIGHIMPACT_BACK;
  else
    v5 = dword_61E4EC[v4];
  v6 = (CTaskComplexFallAndGetUp *)CTask::operator new(0x18u);
  CTaskComplexFallAndGetUp::CTaskComplexFallAndGetUp(v6, v5, ANIM_STD_PED, this->m_iDownTime);
  return result;
}
// 61E4EC: using guessed type _DWORD dword_61E4EC[3];

//----- (0050B608) --------------------------------------------------------
CTask *__fastcall CTaskComplexHitPedWithCar::CreateSubTask(CTaskComplexHitPedWithCar *this, const int iSubTaskType)
{
  char *v3; // r4
  void **v4; // r0
  float v5; // r5
  CVehicle *m_pVehicle; // r6
  __int64 v7; // kr00_8
  void **v8; // r0
  __int64 v9; // d16
  CEntity **v10; // r1
  unsigned int v11; // r0
  AnimationId v12; // r6
  float m_fImpulseMagnitude; // r5
  __int64 v14; // kr08_8

  v3 = 0;
  if ( iSubTaskType >= 502 )
  {
    if ( iSubTaskType == 502 )
    {
      v3 = (char *)CTask::operator new(0x1Cu);
      m_pVehicle = this->m_pVehicle;
      CTaskComplex::CTaskComplex((CTaskComplex *)v3);
      *(_DWORD *)v3 = &off_66B698;
      v9 = *(_QWORD *)&this->m_vMoveDir.x;
      *((_DWORD *)v3 + 5) = LODWORD(this->m_vMoveDir.z);
      *(_QWORD *)(v3 + 12) = v9;
      *((_DWORD *)v3 + 6) = m_pVehicle;
      v10 = (CEntity **)(v3 + 24);
      if ( !m_pVehicle )
        return (CTask *)v3;
    }
    else
    {
      if ( iSubTaskType == 507 )
      {
        v3 = (char *)CTask::operator new(0x14u);
        v14 = *(_QWORD *)&this->m_pVehicle;
        m_fImpulseMagnitude = this->m_fImpulseMagnitude;
        m_pVehicle = (CVehicle *)v14;
        CTaskSimple::CTaskSimple((CTaskSimple *)v3);
        *((float *)v3 + 3) = m_fImpulseMagnitude;
        v8 = &`vtable for'CTaskSimpleHurtPedWithCar;
        v3[16] = 0;
      }
      else
      {
        if ( iSubTaskType != 506 )
          return (CTask *)v3;
        v3 = (char *)CTask::operator new(0x10u);
        v7 = *(_QWORD *)&this->m_pVehicle;
        v5 = this->m_fImpulseMagnitude;
        m_pVehicle = (CVehicle *)v7;
        CTaskSimple::CTaskSimple((CTaskSimple *)v3);
        *((float *)v3 + 3) = v5;
        v8 = &`vtable for'CTaskSimpleKillPedWithCar;
      }
      *(_DWORD *)v3 = (char *)*v8 + 8;
      *((_DWORD *)v3 + 2) = m_pVehicle;
      v10 = (CEntity **)(v3 + 8);
      if ( !m_pVehicle )
        return (CTask *)v3;
    }
    CEntity::RegisterReference(m_pVehicle, v10);
    return (CTask *)v3;
  }
  switch ( iSubTaskType )
  {
    case 200:
      v3 = (char *)CTask::operator new(8u);
      CTaskSimple::CTaskSimple((CTaskSimple *)v3);
      v4 = &`vtable for'CTaskSimpleNone;
      goto LABEL_11;
    case 208:
      v11 = this->m_iPedHitSide - 1;
      if ( v11 > 2 )
        v12 = ANIM_STD_HIGHIMPACT_BACK;
      else
        v12 = dword_61E4EC[v11];
      v3 = (char *)CTask::operator new(0x18u);
      CTaskComplexFallAndGetUp::CTaskComplexFallAndGetUp(
        (CTaskComplexFallAndGetUp *)v3,
        v12,
        ANIM_STD_PED,
        this->m_iDownTime);
      break;
    case 414:
      v3 = (char *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        (CTaskSimpleRunAnim *)v3,
        ANIM_STD_PED,
        ANIM_STD_HIT_BEHIND,
        4.0,
        414,
        "HitFromBehind",
        0);
      v4 = &`vtable for'CTaskSimpleHitFromBehind;
LABEL_11:
      *(_DWORD *)v3 = (char *)*v4 + 8;
      break;
  }
  return (CTask *)v3;
}
// 61E4EC: using guessed type _DWORD dword_61E4EC[3];
// 66B698: using guessed type void *off_66B698;
// 677B3C: using guessed type void *`vtable for'CTaskSimpleHurtPedWithCar;
// 678150: using guessed type void *`vtable for'CTaskSimpleNone;
// 678828: using guessed type void *`vtable for'CTaskSimpleKillPedWithCar;
// 679D48: using guessed type void *`vtable for'CTaskSimpleHitFromBehind;

//----- (0050B740) --------------------------------------------------------
CTask *__fastcall CTaskComplexHitPedWithCar::ControlSubTask(CTaskComplexHitPedWithCar *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (0050B744) --------------------------------------------------------
CTask *__fastcall CTaskComplexHitPedWithCar::CreateFirstSubTask(CTaskComplexHitPedWithCar *this, CPed *pPed)
{
  float v2; // s4
  float v5; // s0
  int v6; // r1
  float v7; // s2
  float m_fImpulseMagnitude; // s0
  float v9; // s2
  CVehicle *m_pVehicle; // r6
  float *p_xx; // r0
  float *v12; // r0
  float v13; // s4
  float v14; // s2
  float v15; // s0
  float *v16; // r0
  float *v17; // r0

  this->m_iPedHitSide = CPedGeometryAnalyser::ComputePedHitSide(pPed, this->m_pVehicle);
  v5 = 12.0;
  if ( CPed::IsPlayer(pPed) )
    v5 = 20.0;
  if ( this->m_fImpulseMagnitude <= v5 )
  {
    v7 = 6.0;
    if ( CPed::IsPlayer(pPed) )
      v7 = 10.0;
    m_fImpulseMagnitude = this->m_fImpulseMagnitude;
    if ( m_fImpulseMagnitude <= v7
      && ((v9 = 3.0, m_fImpulseMagnitude <= 3.0)
       || (m_fImpulseMagnitude = pPed->m_vecDamageNormal.z, v9 = -0.8, m_fImpulseMagnitude >= -0.8)) )
    {
      m_pVehicle = this->m_pVehicle;
      switch ( CPedGeometryAnalyser::ComputeEntityHitSide(pPed, m_pVehicle) )
      {
        case 0:
          p_xx = &m_pVehicle->m_pMat->xx;
          v2 = p_xx[4];
          v9 = p_xx[5];
          m_fImpulseMagnitude = p_xx[6];
          break;
        case 1:
          v12 = &m_pVehicle->m_pMat->xx;
          v13 = *v12;
          v14 = v12[1];
          v15 = v12[2];
          goto LABEL_15;
        case 2:
          v16 = &m_pVehicle->m_pMat->xx;
          v13 = v16[4];
          v14 = v16[5];
          v15 = v16[6];
LABEL_15:
          m_fImpulseMagnitude = -v15;
          v9 = -v14;
          v2 = -v13;
          break;
        case 3:
          v17 = &m_pVehicle->m_pMat->xx;
          v2 = *v17;
          v9 = v17[1];
          m_fImpulseMagnitude = v17[2];
          break;
        default:
          break;
      }
      v6 = 502;
      this->m_vMoveDir.x = v2;
      this->m_vMoveDir.y = v9;
      this->m_vMoveDir.z = m_fImpulseMagnitude;
    }
    else
    {
      v6 = 507;
    }
  }
  else
  {
    v6 = 506;
  }
  return CTaskComplexHitPedWithCar::CreateSubTask(this, v6);
}
// 50B834: variable 'v2' is possibly undefined

//----- (0050B850) --------------------------------------------------------
bool __fastcall CTaskComplexHitPedWithCar::HitKillsPed(const CTaskComplexHitPedWithCar *this, CPed *pPed)
{
  bool v3; // zf
  float v4; // s0
  bool result; // r0

  v3 = !CPed::IsPlayer(pPed);
  v4 = 12.0;
  result = 0;
  if ( !v3 )
    v4 = 20.0;
  if ( this->m_fImpulseMagnitude > v4 )
    return 1;
  return result;
}

//----- (0050B884) --------------------------------------------------------
bool __fastcall CTaskComplexHitPedWithCar::HitHurtsPed(const CTaskComplexHitPedWithCar *this, CPed *pPed)
{
  float v4; // s2
  float m_fImpulseMagnitude; // s0
  char v7; // r1
  char v8; // r0

  v4 = 6.0;
  if ( CPed::IsPlayer(pPed) )
    v4 = 10.0;
  m_fImpulseMagnitude = this->m_fImpulseMagnitude;
  if ( m_fImpulseMagnitude > v4 )
    return 1;
  v7 = 0;
  v8 = 0;
  if ( pPed->m_vecDamageNormal.z < -0.8 )
    v7 = 1;
  if ( m_fImpulseMagnitude > 3.0 )
    v8 = 1;
  return v8 & v7;
}

//----- (0050B8E4) --------------------------------------------------------
CVector *__fastcall CTaskComplexHitPedWithCar::ComputeEvasiveStepMoveDir(
        CVector *retstr,
        const CPed *ped,
        CVehicle *pVehicle)
{
  CMatrix *m_pMat; // r0
  __int64 v6; // d16
  CVector *result; // r0
  CMatrix *v8; // r0
  __int64 v9; // d16
  CMatrix *v10; // r0
  CMatrix *v11; // r0
  float z; // s0
  RwReal v13; // s4

  switch ( CPedGeometryAnalyser::ComputeEntityHitSide(ped, pVehicle) )
  {
    case 0:
      m_pMat = pVehicle->m_pMat;
      v6 = *(_QWORD *)&m_pMat->xy;
      result = (CVector *)LODWORD(m_pMat->zy);
      goto LABEL_5;
    case 1:
      v11 = pVehicle->m_pMat;
      v9 = *(_QWORD *)&v11->xx;
      result = (CVector *)LODWORD(v11->zx);
      goto LABEL_7;
    case 2:
      v8 = pVehicle->m_pMat;
      v9 = *(_QWORD *)&v8->xy;
      result = (CVector *)LODWORD(v8->zy);
LABEL_7:
      LODWORD(retstr->z) = result;
      z = retstr->z;
      *(_QWORD *)&retstr->x = v9;
      v13 = -retstr->y;
      retstr->x = -retstr->x;
      retstr->y = v13;
      retstr->z = -z;
      break;
    case 3:
      v10 = pVehicle->m_pMat;
      v6 = *(_QWORD *)&v10->xx;
      result = (CVector *)LODWORD(v10->zx);
LABEL_5:
      LODWORD(retstr->z) = result;
      *(_QWORD *)&retstr->x = v6;
      break;
  }
  return result;
}

//----- (0050B95C) --------------------------------------------------------
void __fastcall CTaskSimpleKillPedWithCar::CTaskSimpleKillPedWithCar(
        CTaskSimpleKillPedWithCar *this,
        CVehicle *pVehicle,
        const float fImpulseMagnitude)
{
  CTaskSimple::CTaskSimple(this);
  this->m_fImpulseMagnitude = fImpulseMagnitude;
  this->_vptr$CTask = (int (**)(void))&off_66B780;
  this->m_pVehicle = pVehicle;
  if ( pVehicle )
    CEntity::RegisterReference(pVehicle, &this->m_pVehicle);
}
// 66B780: using guessed type void *off_66B780;
// 678828: using guessed type void *`vtable for'CTaskSimpleKillPedWithCar;

//----- (0050B998) --------------------------------------------------------
void __fastcall CTaskSimpleKillPedWithCar::~CTaskSimpleKillPedWithCar(CTaskSimpleKillPedWithCar *this)
{
  CVehicle *m_pVehicle; // r0
  CEntity **p_m_pVehicle; // r1

  p_m_pVehicle = &this->m_pVehicle;
  m_pVehicle = this->m_pVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B780;
  if ( m_pVehicle )
    CEntity::CleanUpOldReference(m_pVehicle, p_m_pVehicle);
  sub_1A01F4(this);
}
// 66B780: using guessed type void *;
// 678828: using guessed type void *`vtable for'CTaskSimpleKillPedWithCar;

//----- (0050B9C4) --------------------------------------------------------
void __fastcall CTaskSimpleKillPedWithCar::~CTaskSimpleKillPedWithCar(CTaskSimpleKillPedWithCar *this)
{
  CVehicle *m_pVehicle; // r0
  CEntity **p_m_pVehicle; // r1
  void *v4; // r0

  p_m_pVehicle = &this->m_pVehicle;
  m_pVehicle = this->m_pVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B780;
  if ( m_pVehicle )
    CEntity::CleanUpOldReference(m_pVehicle, p_m_pVehicle);
  CTask::~CTask(this);
  sub_197118(v4);
}
// 50B9EC: variable 'v4' is possibly undefined
// 66B780: using guessed type void *off_66B780;
// 678828: using guessed type void *`vtable for'CTaskSimpleKillPedWithCar;

//----- (0050B9F4) --------------------------------------------------------
void __fastcall CTaskSimpleKillPedWithCar::SetPlayerPadJolt(const CTaskSimpleKillPedWithCar *this)
{
  CVehicle *PlayerVehicle; // r0
  CVehicle *m_pVehicle; // r1
  float m_fMass; // s4
  unsigned int v5; // r4
  CPad *Pad; // r0

  PlayerVehicle = FindPlayerVehicle(-1, 0);
  m_pVehicle = this->m_pVehicle;
  if ( PlayerVehicle == m_pVehicle )
  {
    m_fMass = m_pVehicle->m_fMass;
    if ( (float)((float)((float)((float)(sqrtf(
                                           (float)((float)(PlayerVehicle->m_vecMoveSpeed.x
                                                         * PlayerVehicle->m_vecMoveSpeed.x)
                                                 + (float)(PlayerVehicle->m_vecMoveSpeed.y
                                                         * PlayerVehicle->m_vecMoveSpeed.y))
                                         + (float)(PlayerVehicle->m_vecMoveSpeed.z * PlayerVehicle->m_vecMoveSpeed.z))
                                       * 100.0)
                               * 2000.0)
                       / m_fMass)
               + 80.0) <= 250.0 )
      v5 = (unsigned int)(float)((float)((float)((float)(sqrtf(
                                                           (float)((float)(m_pVehicle->m_vecMoveSpeed.x
                                                                         * m_pVehicle->m_vecMoveSpeed.x)
                                                                 + (float)(m_pVehicle->m_vecMoveSpeed.y
                                                                         * m_pVehicle->m_vecMoveSpeed.y))
                                                         + (float)(m_pVehicle->m_vecMoveSpeed.z
                                                                 * m_pVehicle->m_vecMoveSpeed.z))
                                                       * 100.0)
                                               * 2000.0)
                                       / m_fMass)
                               + 80.0);
    else
      v5 = 250;
    Pad = CPad::GetPad(0);
    sub_18F10C(Pad, 0x9C40 / v5, v5, 0);
  }
}

//----- (0050BAD0) --------------------------------------------------------
bool __fastcall CTaskSimpleKillPedWithCar::ProcessPed(CTaskSimpleKillPedWithCar *this, CPed *pPed)
{
  CVehicle *m_pVehicle; // r1
  CSimpleTransform *p_m_transform; // r4
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r3
  float *p_xx; // r0
  float *p_x; // r6
  float v10; // s16
  float v11; // s18
  float v12; // s20
  float v13; // s30
  float v14; // s19
  float v15; // s21
  float v16; // s23
  float v17; // s27
  CColModel *m_pColModel; // r2
  float v19; // s25
  float y; // s24
  float v21; // s22
  float z; // s28
  float v23; // s17
  float v24; // s29
  float v25; // s26
  int v26; // r8
  int v27; // r10
  float v28; // s0
  float v29; // s2
  CVehicle *v30; // r0
  float v31; // s2
  RwReal v32; // s4
  CVehicle *v33; // r0
  CMatrix *v34; // r1
  float zy; // s2
  float v36; // s4
  float v37; // s0
  float v38; // s2
  float v39; // s24
  float x; // s2
  RwReal v41; // s4
  eWeaponType v42; // r6
  CMatrix *v43; // r1
  float v44; // s26
  float v45; // s28
  float v46; // s30
  __int64 v47; // d16
  float v48; // s17
  float v49; // s0
  unsigned int v50; // s4
  unsigned int v51; // s2
  CEventGlobalGroup *EventGlobalGroup; // r0
  int v53; // r0
  CPedFlags *p_m_nPedFlags; // r4
  __int64 v55; // r0
  CVehicle *v56; // r0
  float v57; // s0
  float v58; // s6
  CVector v60; // [sp+14h] [bp-D4h] BYREF
  CEventDamage v61; // [sp+20h] [bp-C8h] BYREF
  CPedDamageResponseCalculator v62; // [sp+60h] [bp-88h] BYREF
  CEventVehicleHitAndRun v63; // [sp+74h] [bp-74h] BYREF

  m_pVehicle = this->m_pVehicle;
  p_m_transform = &pPed->m_transform;
  m_pMat = pPed->m_pMat;
  p_tx = &pPed->m_transform;
  p_xx = &m_pVehicle->m_pMat->xx;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  p_x = p_xx + 12;
  if ( !p_xx )
    p_x = &m_pVehicle->m_transform.m_translate.x;
  v10 = p_tx->m_translate.x - *p_x;
  v11 = p_tx->m_translate.y - p_x[1];
  v12 = p_tx->m_translate.z - p_x[2];
  v13 = p_xx[4];
  v14 = p_xx[5];
  v15 = p_xx[6];
  v16 = p_xx[8];
  v17 = p_xx[9];
  m_pColModel = CModelInfo::ms_modelInfoPtrs[m_pVehicle->m_nModelIndex]->m_pColModel;
  v19 = p_xx[10];
  y = m_pColModel->m_boxBound.m_vecMin.y;
  v21 = m_pColModel->m_boxBound.m_vecMax.y;
  z = m_pColModel->m_boxBound.m_vecMax.z;
  v23 = (float)((float)(v10 * *p_xx) + (float)(v11 * p_xx[1])) + (float)(v12 * p_xx[2]);
  v24 = m_pColModel->m_boxBound.m_vecMax.x * 0.99;
  v25 = (float)((float)(v13 * m_pVehicle->m_vecMoveSpeed.x) + (float)(v14 * m_pVehicle->m_vecMoveSpeed.y))
      + (float)(v15 * m_pVehicle->m_vecMoveSpeed.z);
  v26 = CPedGeometryAnalyser::ComputePedHitSide(pPed, m_pVehicle);
  if ( fabsf(v23) <= v24 )
  {
    v33 = this->m_pVehicle;
    if ( (float)((float)((float)(v10 * v16) + (float)(v11 * v17)) + (float)(v12 * v19)) <= 0.1 )
    {
      x = v33->m_vecMoveSpeed.x;
      v41 = v33->m_vecMoveSpeed.y * 0.9;
      pPed->m_vecMoveSpeed.z = 0.0;
      pPed->m_vecMoveSpeed.x = x * 0.9;
      pPed->m_vecMoveSpeed.y = v41;
      if ( (v26 | 2) == 3 )
        LOBYTE(v26) = 0;
      if ( CLocalisation::KnockDownPeds() )
        CAEVehicleAudioEntity::AddAudioEvent(&this->m_pVehicle->m_VehicleAudioEntity, 119, 0.0);
      v27 = 5;
      goto LABEL_26;
    }
    v34 = v33->m_pMat;
    zy = v34->zy;
    if ( zy >= -0.2 )
    {
      if ( zy <= 0.1 )
      {
        v39 = -y;
        v37 = z * v34->zz;
      }
      else
      {
        v39 = v21 - y;
        v37 = (float)(v21 * zy) + (float)(z * v34->zz);
      }
      v38 = p_x[2];
      if ( v25 > 0.0 )
        v39 = v21;
    }
    else
    {
      v36 = -0.0;
      v37 = (float)(y * zy) + (float)(z * v34->zz);
      if ( v25 > 0.0 )
        v36 = v21;
      v38 = p_x[2];
      v39 = v36 - y;
    }
    v43 = pPed->m_pMat;
    v44 = v33->m_vecMoveSpeed.x;
    v45 = v33->m_vecMoveSpeed.y;
    v46 = v33->m_vecMoveSpeed.z;
    if ( v43 )
      p_m_transform = (CSimpleTransform *)&v43->tx;
    v47 = *(_QWORD *)&v33->m_vecMoveSpeed.x;
    v48 = p_m_transform->m_translate.z;
    *(RwReal *)&v61.m_bIsPersistent = v33->m_vecMoveSpeed.z;
    *(_QWORD *)&v61._vptr$CEvent = v47;
    CVector::Normalise((CVector *)&v61);
    v49 = (float)((float)(v38 + v37) - v48)
        / (float)(v39 / sqrtf((float)((float)(v44 * v44) + (float)(v45 * v45)) + (float)(v46 * v46)));
    *(float *)&v50 = v49 * *(float *)&v61.m_iAccumulatedTime;
    *(float *)&v51 = v49 * *(float *)&v61._vptr$CEvent;
    *(_QWORD *)&v61._vptr$CEvent = __PAIR64__(
                                     v49 * *(float *)&v61.m_iAccumulatedTime,
                                     v49 * *(float *)&v61._vptr$CEvent);
    *(float *)&v61.m_bIsPersistent = v49 * *(float *)&v61.m_bIsPersistent;
    pPed->m_vecMoveSpeed.z = *(RwReal *)&v61.m_bIsPersistent;
    *(_QWORD *)&pPed->m_vecMoveSpeed.x = __PAIR64__(v50, v51);
    CTaskSimpleKillPedWithCar::DamageCarBonnet(this, pPed);
    v27 = 4;
  }
  else
  {
    v27 = 1;
    if ( v25 > 0.0 )
      y = v21;
    v28 = fabsf((float)((float)(v10 * v13) + (float)(v11 * v14)) + (float)(v12 * v15));
    v29 = fabsf(y * 0.85);
    if ( v23 > 0.0 )
      v27 = 3;
    if ( v28 < v29 )
    {
      v30 = this->m_pVehicle;
      v31 = v30->m_vecMoveSpeed.x;
      v32 = v30->m_vecMoveSpeed.y * 0.9;
      pPed->m_vecMoveSpeed.z = 0.0;
      pPed->m_vecMoveSpeed.x = v31 * 0.9;
      pPed->m_vecMoveSpeed.y = v32;
      if ( CLocalisation::KnockDownPeds() )
        CAEVehicleAudioEntity::AddAudioEvent(&this->m_pVehicle->m_VehicleAudioEntity, 119, 0.0);
      if ( (v26 | 2) == 3 )
        LOBYTE(v26) = 0;
LABEL_26:
      v42 = WEAPONTYPE_RUNOVERBYCAR;
      goto LABEL_36;
    }
  }
  v42 = WEAPONTYPE_RAMMEDBYCAR;
LABEL_36:
  CEventVehicleHitAndRun::CEventVehicleHitAndRun(&v63, pPed, this->m_pVehicle);
  EventGlobalGroup = GetEventGlobalGroup();
  CEventGroup::Add(EventGlobalGroup, &v63, 0);
  CPedDamageResponseCalculator::CPedDamageResponseCalculator(&v62, this->m_pVehicle, 1000.0, v42, PED_SPHERE_HEAD, 0);
  CEventDamage::CEventDamage(
    &v61,
    this->m_pVehicle,
    CTimer::m_snTimeInMilliseconds,
    v42,
    PED_SPHERE_HEAD,
    v26,
    0,
    *(_DWORD *)&pPed->m_nPedFlags & 0x100);
  v53 = ((unsigned __int8)v27 ^ 4) & 7;
  p_m_nPedFlags = &pPed->m_nPedFlags;
  if ( 0xA3u >> v53 << 31 )
    v61.m_eHitZone = dword_50BF58[v53];
  if ( CEventDamage::AffectsPed(&v61, pPed) )
    CPedDamageResponseCalculator::ComputeDamageResponse(&v62, pPed, &v61.m_pedDamageResponse, 1);
  else
    v61.m_pedDamageResponse.m_bDamageCalculated = 1;
  CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, (CEvent *)&v61, 0);
  CTaskSimpleKillPedWithCar::SetPlayerPadJolt(this);
  HIDWORD(v55) = *((_DWORD *)&pPed->m_nPedFlags + 1) & 0xFFFFFFEF;
  if ( v27 == 4 )
    HIDWORD(v55) |= 0x10u;
  LODWORD(v55) = *(_DWORD *)p_m_nPedFlags & 0xFFFFFFFE;
  *(_QWORD *)p_m_nPedFlags = v55;
  v60.y = v11;
  v60.x = v10;
  v60.z = v12;
  CVector::Normalise(&v60);
  v56 = this->m_pVehicle;
  v57 = v56->m_fMass / 1400.0;
  v58 = v57 * -100.0;
  if ( v57 > 1.0 )
    v58 = -100.0;
  v60.x = v60.x * v58;
  v60.y = v60.y * v58;
  v60.z = v58 * v60.z;
  CPhysical::ApplyMoveForce(v56, v60);
  CEventDamage::~CEventDamage(&v61);
  CPedDamageResponseCalculator::~CPedDamageResponseCalculator(&v62);
  CEventVehicleHitAndRun::~CEventVehicleHitAndRun(&v63);
  return 1;
}
// 50BF58: using guessed type int dword_50BF58[8];

//----- (0050BF80) --------------------------------------------------------
void __fastcall CTaskSimpleKillPedWithCar::DamageCarBonnet(const CTaskSimpleKillPedWithCar *this, const CPed *pPed)
{
  CAutomobile *m_pVehicle; // r0
  CPhysical *v5; // r4
  float v6; // s0
  CMatrix *m_pMat; // r0
  float v8; // s6
  float v9; // s4
  float v10; // s2
  float x; // s8
  float v12; // s2
  float v13; // s6
  float v14; // s4
  float v15; // s10
  float v16; // s12
  CMatrix *v17; // r0
  CVector v18; // 0:r1.12

  m_pVehicle = (CAutomobile *)this->m_pVehicle;
  if ( !m_pVehicle->m_vehicleType )
  {
    v5 = CAutomobile::RemoveBonnetInPedCollision(m_pVehicle);
    if ( v5 )
    {
      v6 = (float)rand();
      m_pMat = this->m_pVehicle->m_pMat;
      v8 = m_pMat->yx * 0.1;
      v9 = m_pMat->zx * 0.1;
      v10 = m_pMat->xx * 0.1;
      x = pPed->m_vecMoveSpeed.x;
      if ( (float)((float)(v6 * 4.6566e-10) + 0.0) <= 0.5 )
      {
        v12 = x - v10;
        v13 = pPed->m_vecMoveSpeed.y - v8;
        v14 = pPed->m_vecMoveSpeed.z - v9;
      }
      else
      {
        v12 = v10 + x;
        v13 = v8 + pPed->m_vecMoveSpeed.y;
        v14 = v9 + pPed->m_vecMoveSpeed.z;
      }
      v15 = m_pMat->yz * 0.5;
      v16 = m_pMat->zz * 0.5;
      v5->m_vecMoveSpeed.x = v12 + (float)(m_pMat->xz * 0.5);
      v5->m_vecMoveSpeed.y = v13 + v15;
      v5->m_vecMoveSpeed.z = v14 + v16;
      v17 = this->m_pVehicle->m_pMat;
      v18.x = v17->xz * 10.0;
      v18.y = v17->yz * 10.0;
      v18.z = v17->zz * 10.0;
      CPhysical::ApplyTurnForce(v5, v18, *(CVector *)&v17->xy);
    }
  }
}

//----- (0050C09C) --------------------------------------------------------
void __fastcall CTaskSimpleHurtPedWithCar::CTaskSimpleHurtPedWithCar(
        CTaskSimpleHurtPedWithCar *this,
        CVehicle *pVehicle,
        const float fImpulseMagnitude)
{
  CTaskSimple::CTaskSimple(this);
  this->m_fImpulseMagnitude = fImpulseMagnitude;
  this->m_bWillKillPed = 0;
  this->_vptr$CTask = (int (**)(void))&off_66B7B4;
  this->m_pVehicle = pVehicle;
  if ( pVehicle )
    CEntity::RegisterReference(pVehicle, &this->m_pVehicle);
}
// 66B7B4: using guessed type void *off_66B7B4;
// 677B3C: using guessed type void *`vtable for'CTaskSimpleHurtPedWithCar;

//----- (0050C0DC) --------------------------------------------------------
void __fastcall CTaskSimpleHurtPedWithCar::~CTaskSimpleHurtPedWithCar(CTaskSimpleHurtPedWithCar *this)
{
  CVehicle *m_pVehicle; // r0
  CEntity **p_m_pVehicle; // r1

  p_m_pVehicle = &this->m_pVehicle;
  m_pVehicle = this->m_pVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B7B4;
  if ( m_pVehicle )
    CEntity::CleanUpOldReference(m_pVehicle, p_m_pVehicle);
  sub_1A01F4(this);
}
// 66B7B4: using guessed type void *;
// 677B3C: using guessed type void *`vtable for'CTaskSimpleHurtPedWithCar;

//----- (0050C108) --------------------------------------------------------
void __fastcall CTaskSimpleHurtPedWithCar::~CTaskSimpleHurtPedWithCar(CTaskSimpleHurtPedWithCar *this)
{
  CVehicle *m_pVehicle; // r0
  CEntity **p_m_pVehicle; // r1
  void *v4; // r0

  p_m_pVehicle = &this->m_pVehicle;
  m_pVehicle = this->m_pVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B7B4;
  if ( m_pVehicle )
    CEntity::CleanUpOldReference(m_pVehicle, p_m_pVehicle);
  CTask::~CTask(this);
  sub_197118(v4);
}
// 50C130: variable 'v4' is possibly undefined
// 66B7B4: using guessed type void *off_66B7B4;
// 677B3C: using guessed type void *`vtable for'CTaskSimpleHurtPedWithCar;

//----- (0050C138) --------------------------------------------------------
bool __fastcall CTaskSimpleHurtPedWithCar::ProcessPed(CTaskSimpleHurtPedWithCar *this, CPed *pPed)
{
  uint8 v4; // r6
  const CEventDamage *v5; // r0
  CPedFlags *p_m_nPedFlags; // r6
  _BOOL4 m_bKilled; // r0
  unsigned __int64 v8; // r0
  float v9; // s2
  RwReal v10; // s4
  CVehicle *m_pVehicle; // r0
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_m_transform; // r3
  float *p_tx; // r1
  float y; // s2
  float z; // s4
  CVehicle *v17; // r0
  float v18; // s0
  float v19; // s6
  CVector v21; // [sp+10h] [bp-78h] BYREF
  CEventDamage v22; // [sp+1Ch] [bp-6Ch] BYREF
  CPedDamageResponseCalculator v23; // [sp+5Ch] [bp-2Ch] BYREF

  v4 = CPedGeometryAnalyser::ComputePedHitSide(pPed, this->m_pVehicle);
  CPedDamageResponseCalculator::CPedDamageResponseCalculator(
    &v23,
    this->m_pVehicle,
    30.0,
    WEAPONTYPE_RAMMEDBYCAR,
    PED_SPHERE_CHEST,
    0);
  CEventDamage::CEventDamage(
    &v22,
    this->m_pVehicle,
    CTimer::m_snTimeInMilliseconds,
    WEAPONTYPE_RAMMEDBYCAR,
    PED_SPHERE_CHEST,
    v4,
    0,
    *(_DWORD *)&pPed->m_nPedFlags & 0x100);
  p_m_nPedFlags = &pPed->m_nPedFlags;
  if ( CEventDamage::AffectsPed(v5, pPed) )
    CPedDamageResponseCalculator::ComputeDamageResponse(&v23, pPed, &v22.m_pedDamageResponse, 1);
  m_bKilled = v22.m_pedDamageResponse.m_bKilled;
  this->m_bWillKillPed = v22.m_pedDamageResponse.m_bKilled;
  if ( m_bKilled )
    CEventGroup::Add(&pPed->m_pPedIntelligence->m_eventGroup, (CEvent *)&v22, 0);
  v8 = *(_QWORD *)p_m_nPedFlags & 0xFFFFFFEFFFFFFFFFLL;
  LODWORD(v8) = *(_DWORD *)p_m_nPedFlags & 0xFFFFFFFE;
  *(_QWORD *)p_m_nPedFlags = v8;
  LODWORD(v8) = this->m_pVehicle;
  v9 = *(float *)(v8 + 72);
  v10 = *(float *)(v8 + 76) * 0.75;
  pPed->m_vecMoveSpeed.z = 0.0;
  pPed->m_vecMoveSpeed.x = v9 * 0.75;
  pPed->m_vecMoveSpeed.y = v10;
  m_pVehicle = this->m_pVehicle;
  HIDWORD(v8) = pPed->m_pMat;
  m_pMat = m_pVehicle->m_pMat;
  p_m_transform = (CSimpleTransform *)(HIDWORD(v8) + 48);
  if ( !HIDWORD(v8) )
    p_m_transform = &pPed->m_transform;
  p_tx = &m_pMat->tx;
  y = p_m_transform->m_translate.y;
  z = p_m_transform->m_translate.z;
  if ( !m_pMat )
    p_tx = &m_pVehicle->m_transform.m_translate.x;
  v21.x = p_m_transform->m_translate.x - *p_tx;
  v21.y = y - p_tx[1];
  v21.z = z - p_tx[2];
  CVector::Normalise(&v21);
  v17 = this->m_pVehicle;
  v18 = v17->m_fMass / 1400.0;
  v19 = v18 * -60.0;
  if ( v18 > 1.0 )
    v19 = -60.0;
  v21.x = v21.x * v19;
  v21.y = v21.y * v19;
  v21.z = v19 * v21.z;
  CPhysical::ApplyMoveForce(v17, v21);
  CEventDamage::~CEventDamage(&v22);
  CPedDamageResponseCalculator::~CPedDamageResponseCalculator(&v23);
  return 1;
}
// 50C196: variable 'v5' is possibly undefined

//----- (0050C2C8) --------------------------------------------------------
void __fastcall CTaskComplexWalkRoundCar::CTaskComplexWalkRoundCar(
        CTaskComplexWalkRoundCar *this,
        const int iMoveState,
        const CVector *vTargetPos,
        const CVehicle *pVehicle,
        bool bGoingForDoor,
        const int iForceThisDirectionRoundCar)
{
  int8 v8; // r5
  char v10; // r3
  char v11; // r1
  __int64 v12; // d16
  RwReal z; // r0
  CPointRoute *v14; // r0

  v8 = iMoveState;
  CTaskComplex::CTaskComplex(this);
  v10 = *((_BYTE *)this + 13) & 0xFC;
  v11 = *((_BYTE *)this + 14) & 0xF0 | iForceThisDirectionRoundCar & 0xF;
  this->m_iMoveState = v8;
  *((_BYTE *)this + 13) = v10 | bGoingForDoor;
  *((_BYTE *)this + 14) = v11;
  this->_vptr$CTask = (int (**)(void))&off_66B7E8;
  v12 = *(_QWORD *)&vTargetPos->x;
  z = vTargetPos->z;
  this->m_pVehicle = (CVehicle *)pVehicle;
  this->m_vTargetPos.z = z;
  this->m_timer.m_iStartTime = 0;
  this->m_timer.m_iDuration = 0;
  *(_QWORD *)&this->m_vTargetPos.x = v12;
  *(_WORD *)&this->m_timer.m_bIsActive = 0;
  this->m_iEnterCarStartTime = -1;
  if ( pVehicle )
    CEntity::RegisterReference(&pVehicle->CPhysical, &this->m_pVehicle);
  v14 = (CPointRoute *)CPointRoute::operator new(0x64u);
  v14->m_iRouteSize = 0;
  this->m_pPointRoute = v14;
}
// 66B7E8: using guessed type void *;

//----- (0050C354) --------------------------------------------------------
void __fastcall CTaskComplexWalkRoundCar::~CTaskComplexWalkRoundCar(CTaskComplexWalkRoundCar *this)
{
  CVehicle *m_pVehicle; // r0
  CEntity **p_m_pVehicle; // r1
  CPointRoute *m_pPointRoute; // r0

  p_m_pVehicle = &this->m_pVehicle;
  m_pVehicle = this->m_pVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B7E8;
  if ( m_pVehicle )
    CEntity::CleanUpOldReference(m_pVehicle, p_m_pVehicle);
  m_pPointRoute = this->m_pPointRoute;
  if ( m_pPointRoute )
    CPointRoute::operator delete(m_pPointRoute);
  sub_18EDB4(this);
}
// 66B7E8: using guessed type void *off_66B7E8;

//----- (0050C38C) --------------------------------------------------------
void __fastcall CTaskComplexWalkRoundCar::~CTaskComplexWalkRoundCar(CTaskComplexWalkRoundCar *this)
{
  CVehicle *m_pVehicle; // r0
  CEntity **p_m_pVehicle; // r1
  CPointRoute *m_pPointRoute; // r0
  void *v5; // r0

  p_m_pVehicle = &this->m_pVehicle;
  m_pVehicle = this->m_pVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B7E8;
  if ( m_pVehicle )
    CEntity::CleanUpOldReference(m_pVehicle, p_m_pVehicle);
  m_pPointRoute = this->m_pPointRoute;
  if ( m_pPointRoute )
    CPointRoute::operator delete(m_pPointRoute);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v5);
}
// 50C3BE: variable 'v5' is possibly undefined
// 66B7E8: using guessed type void *off_66B7E8;

//----- (0050C3C8) --------------------------------------------------------
CTask *__fastcall CTaskComplexWalkRoundCar::CreateNextSubTask(CTaskComplexWalkRoundCar *this, CPed *pPed)
{
  CTask *v3; // r4
  CTaskComplexFollowPointRoute *v4; // r0
  CTask *v5; // r0

  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 902 )
    return 0;
  v3 = 0;
  if ( this->m_pPointRoute->m_iRouteSize )
  {
    v4 = (CTaskComplexFollowPointRoute *)CTask::operator new(0x3Cu);
    CTaskComplexFollowPointRoute::CTaskComplexFollowPointRoute(
      v4,
      this->m_iMoveState,
      this->m_pPointRoute,
      0,
      0.5,
      0.0,
      1,
      0,
      0);
    return v5;
  }
  return v3;
}
// 50C412: variable 'v5' is possibly undefined

//----- (0050C424) --------------------------------------------------------
CTask *__fastcall CTaskComplexWalkRoundCar::CreateRouteTask(CTaskComplexWalkRoundCar *this, CPed *pPed)
{
  CTask *v3; // r4
  CTaskComplexFollowPointRoute *v4; // r0
  CTask *v5; // r0

  v3 = 0;
  if ( this->m_pPointRoute->m_iRouteSize )
  {
    v4 = (CTaskComplexFollowPointRoute *)CTask::operator new(0x3Cu);
    CTaskComplexFollowPointRoute::CTaskComplexFollowPointRoute(
      v4,
      this->m_iMoveState,
      this->m_pPointRoute,
      0,
      0.5,
      0.0,
      1,
      0,
      0);
    return v5;
  }
  return v3;
}
// 50C45E: variable 'v5' is possibly undefined

//----- (0050C46C) --------------------------------------------------------
void __fastcall CTaskComplexWalkRoundCar::SetNewVehicle(
        CTaskComplexWalkRoundCar *this,
        CVehicle *vehicle,
        const int iForceThisDirectionRoundCar)
{
  char v4; // r8
  CVehicle *m_pVehicle; // r0
  CEntity **p_m_pVehicle; // r5
  char v8; // r1
  CPointRoute *m_pPointRoute; // r2

  v4 = iForceThisDirectionRoundCar;
  p_m_pVehicle = &this->m_pVehicle;
  m_pVehicle = this->m_pVehicle;
  if ( m_pVehicle )
    CEntity::CleanUpOldReference(m_pVehicle, p_m_pVehicle);
  this->m_pVehicle = vehicle;
  CEntity::RegisterReference(vehicle, p_m_pVehicle);
  v8 = *((_BYTE *)this + 14);
  m_pPointRoute = this->m_pPointRoute;
  *((_BYTE *)this + 13) |= 2u;
  *((_BYTE *)this + 14) = v4 & 0xF | v8 & 0xF0;
  m_pPointRoute->m_iRouteSize = 0;
}

//----- (0050C4B8) --------------------------------------------------------
CTask *__fastcall CTaskComplexWalkRoundCar::CreateFirstSubTask(CTaskComplexWalkRoundCar *this, CPed *pPed)
{
  CPointRoute *m_pPointRoute; // r0
  CVehicle *m_pVehicle; // r1
  int v6; // r2
  CVehicle *m_pVehicleBeingTowed; // r6
  bool v8; // zf
  int v9; // r3
  CSimpleTransform *p_m_transform; // r6
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r3
  __int64 v13; // d16
  CMatrix *v14; // r1
  __int64 v15; // d16
  __int64 v16; // d16
  CMatrix *v17; // r1
  float x; // s0
  float y; // s2
  float z; // s4
  CSimpleTransform *v21; // r0
  float v22; // s10
  RwReal v23; // s0
  float v24; // r0
  CMatrix *v25; // r1
  float v26; // s18
  float v27; // s20
  float v28; // s24
  float v29; // s17
  float xy; // s26
  float yy; // s30
  float zy; // s28
  int m_iMoveState; // r1
  float v34; // s22
  CTask *TaskByType; // r0
  CTaskSimpleAchieveHeading *v36; // r5
  CTaskComplexFollowPointRoute *v37; // r0
  CTask *v38; // r0
  CTaskSimpleStandStill *v39; // r0
  CMatrix *v40; // r0
  float RadianAngleBetweenPoints; // r0
  float v42; // r4
  CTaskSimpleStandStill v44; // [sp+14h] [bp-7Ch] BYREF
  CVector v45; // [sp+34h] [bp-5Ch] BYREF

  this->m_pPointRoute->m_iRouteSize = 0;
  if ( (*((_BYTE *)&this->m_pVehicle->m_nVehicleFlags + 1) & 4) != 0 )
    CTaskComplexWalkRoundCar::ComputeRouteRoundBigCar(this, pPed);
  else
    CTaskComplexWalkRoundCar::ComputeRouteRoundSmallCar(this, pPed);
  m_pPointRoute = this->m_pPointRoute;
  if ( !m_pPointRoute->m_iRouteSize )
    return 0;
  m_pVehicle = this->m_pVehicle;
  v6 = 15000;
  m_pVehicleBeingTowed = m_pVehicle->m_pVehicleBeingTowed;
  if ( this->m_iMoveState == 4 )
    v6 = 20000;
  v8 = m_pVehicleBeingTowed == 0;
  if ( !m_pVehicleBeingTowed )
    v8 = m_pVehicle->m_pTowingVehicle == 0;
  if ( !v8 )
    v6 = (int)(float)((float)v6 * 4.0);
  v9 = CTimer::m_snTimeInMilliseconds;
  this->m_timer.m_bIsActive = 1;
  p_m_transform = &pPed->m_transform;
  this->m_timer.m_iStartTime = v9;
  this->m_timer.m_iDuration = v6;
  m_pMat = m_pVehicle->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &m_pVehicle->m_transform;
  v13 = *(_QWORD *)&p_tx->m_translate.x;
  this->m_VehiclePos.z = p_tx->m_translate.z;
  *(_QWORD *)&this->m_VehiclePos.x = v13;
  v14 = m_pVehicle->m_pMat;
  v15 = *(_QWORD *)&v14->xy;
  this->m_VehicleForwardsVec.z = v14->zy;
  *(_QWORD *)&this->m_VehicleForwardsVec.x = v15;
  v16 = *(_QWORD *)&v14->xx;
  this->m_VehicleRightVec.z = v14->zx;
  *(_QWORD *)&this->m_VehicleRightVec.x = v16;
  v17 = pPed->m_pMat;
  x = m_pPointRoute->m_routePoints[0].x;
  y = m_pPointRoute->m_routePoints[0].y;
  z = m_pPointRoute->m_routePoints[0].z;
  v21 = &pPed->m_transform;
  if ( v17 )
    v21 = (CSimpleTransform *)&v17->tx;
  v22 = v21->m_translate.z;
  v23 = x - v21->m_translate.x;
  v45.y = y - v21->m_translate.y;
  v45.x = v23;
  v45.z = z - v22;
  v24 = CVector::NormaliseAndMag(&v45);
  v25 = pPed->m_pMat;
  v26 = 6.0;
  v27 = v45.x;
  v28 = v45.y;
  v29 = v24;
  xy = v25->xy;
  yy = v25->yy;
  zy = v25->zy;
  m_iMoveState = (unsigned __int8)this->m_iMoveState;
  v34 = v45.z;
  if ( m_iMoveState == 6 )
    v26 = 4.0;
  if ( m_iMoveState == 4 )
    v26 = 2.0;
  if ( CPed::IsPlayer(pPed) )
  {
    TaskByType = CTaskManager::FindTaskByType(&pPed->m_pPedIntelligence->m_taskManager, 3, 701);
    if ( TaskByType )
      this->m_iEnterCarStartTime = (int)TaskByType[9].m_pParent;
  }
  if ( v29 <= v26
    || (*(_DWORD *)&this->m_pVehicle->m_nVehicleFlags & 0x400) != 0
    || (float)((float)((float)(v27 * xy) + (float)(v28 * yy)) + (float)(v34 * zy)) <= 0.0 )
  {
    CTaskSimpleStandStill::CTaskSimpleStandStill(&v44, 0, 0, 0, 8.0);
    CTaskSimpleStandStill::ProcessPed(v39, pPed);
    v40 = pPed->m_pMat;
    if ( v40 )
      p_m_transform = (CSimpleTransform *)&v40->tx;
    RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                                 this->m_pPointRoute->m_routePoints[0].x - p_m_transform->m_translate.x,
                                 this->m_pPointRoute->m_routePoints[0].y - p_m_transform->m_translate.y,
                                 0.0,
                                 0.0);
    v42 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
    v36 = (CTaskSimpleAchieveHeading *)CTask::operator new(0x18u);
    CTaskSimpleAchieveHeading::CTaskSimpleAchieveHeading(v36, v42, 1.0, 0.1);
    CTaskSimpleStandStill::~CTaskSimpleStandStill(&v44);
  }
  else
  {
    v36 = 0;
    if ( this->m_pPointRoute->m_iRouteSize )
    {
      v37 = (CTaskComplexFollowPointRoute *)CTask::operator new(0x3Cu);
      CTaskComplexFollowPointRoute::CTaskComplexFollowPointRoute(
        v37,
        this->m_iMoveState,
        this->m_pPointRoute,
        0,
        0.5,
        0.0,
        1,
        0,
        0);
      return v38;
    }
  }
  return v36;
}
// 50C68E: variable 'v38' is possibly undefined
// 50C6AA: variable 'v39' is possibly undefined

//----- (0050C728) --------------------------------------------------------
float __fastcall CTaskComplexWalkRoundCar::ComputeRoute(CTaskComplexWalkRoundCar *this, const CPed *pPed)
{
  if ( (*((_BYTE *)&this->m_pVehicle->m_nVehicleFlags + 1) & 4) == 0 )
    return CTaskComplexWalkRoundCar::ComputeRouteRoundSmallCar(this, pPed);
  CTaskComplexWalkRoundCar::ComputeRouteRoundBigCar(this, pPed);
  return 0.0;
}

//----- (0050C740) --------------------------------------------------------
CTask *__fastcall CTaskComplexWalkRoundCar::ControlSubTask(CTaskComplexWalkRoundCar *this, CPed *pPed)
{
  char v4; // r0
  int m_iEnterCarStartTime; // r2
  CVehicle *m_pVehicle; // r1
  bool v7; // zf
  int v8; // r0
  int v9; // r8
  int (**v10)(void); // r1
  unsigned int v12; // r1
  int m_iStartTime; // r0
  unsigned int v14; // r2
  CVehicle *v15; // r2
  float *p_xx; // r1
  CSimpleTransform *p_m_transform; // r3
  float32x2_t v18; // d16
  unsigned __int64 v19; // d1
  CTask **p_m_pSubTask; // r5
  CTask *m_pSubTask; // t1
  CPedIntelligence *m_pPedIntelligence; // r0
  CTask *v23; // r6
  CTask *v24; // r5

  v4 = *((_BYTE *)this + 13);
  if ( (v4 & 2) != 0 )
  {
    v10 = this->_vptr$CTask;
    *((_BYTE *)this + 13) = v4 & 0xFD;
    return (CTask *)((int (__fastcall *)(CTaskComplexWalkRoundCar *, CPed *))v10[11])(this, pPed);
  }
  if ( !CPed::IsPlayer(pPed) )
    goto LABEL_37;
  m_pVehicle = this->m_pVehicle;
  v7 = m_pVehicle == 0;
  if ( m_pVehicle )
  {
    m_iEnterCarStartTime = this->m_iEnterCarStartTime;
    v7 = m_iEnterCarStartTime == -1;
  }
  if ( !v7
    && CCarEnterExit::IsPlayerToQuitCarEnter(pPed, m_pVehicle, m_iEnterCarStartTime, this->m_pSubTask)
    && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 905 )
  {
    v8 = 1302;
    v9 = 1;
  }
  else
  {
LABEL_37:
    if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 905
      && this->m_timer.m_bIsActive )
    {
      if ( this->m_timer.m_bIsStopped )
      {
        v12 = CTimer::m_snTimeInMilliseconds;
        this->m_timer.m_bIsStopped = 0;
        this->m_timer.m_iStartTime = v12;
        m_iStartTime = v12;
      }
      else
      {
        m_iStartTime = this->m_timer.m_iStartTime;
        v12 = CTimer::m_snTimeInMilliseconds;
      }
      v14 = this->m_timer.m_iDuration + m_iStartTime;
      v8 = 200;
      if ( v14 <= v12 )
        v8 = 1302;
    }
    else
    {
      v8 = 200;
    }
    v9 = 0;
  }
  v15 = this->m_pVehicle;
  if ( !v15 )
    goto LABEL_27;
  p_xx = &v15->m_pMat->xx;
  p_m_transform = (CSimpleTransform *)(p_xx + 12);
  if ( !p_xx )
    p_m_transform = &v15->m_transform;
  v18.n64_u64[0] = vsub_f32(*(float32x2_t *)&this->m_VehiclePos.y, *(float32x2_t *)&p_m_transform->m_translate.y).n64_u64[0];
  v19 = vmul_f32(v18, v18).n64_u64[0];
  if ( (float)((float)((float)((float)(this->m_VehiclePos.x - p_m_transform->m_translate.x)
                             * (float)(this->m_VehiclePos.x - p_m_transform->m_translate.x))
                     + *(float *)&v19)
             + *((float *)&v19 + 1)) <= 0.0625
    && (float)((float)((float)(this->m_VehicleForwardsVec.x * p_xx[4]) + (float)(this->m_VehicleForwardsVec.y * p_xx[5]))
             + (float)(this->m_VehicleForwardsVec.z * p_xx[6])) >= 0.9
    && v8 == 200
    && (float)((float)((float)(this->m_VehicleRightVec.x * *p_xx) + (float)(this->m_VehicleRightVec.y * p_xx[1]))
             + (float)(this->m_VehicleRightVec.z * p_xx[2])) >= 0.9 )
  {
    p_m_pSubTask = &this->m_pSubTask;
  }
  else
  {
LABEL_27:
    m_pSubTask = this->m_pSubTask;
    p_m_pSubTask = &this->m_pSubTask;
    if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))m_pSubTask->_vptr$CTask + 7))(m_pSubTask, pPed, 1, 0) == 1 )
    {
      if ( v9 != 1 )
        return 0;
      m_pPedIntelligence = pPed->m_pPedIntelligence;
      v23 = m_pPedIntelligence->m_taskManager.m_tasks[3];
      if ( !v23
        || (*((int (__fastcall **)(CTask *))v23->_vptr$CTask + 5))(m_pPedIntelligence->m_taskManager.m_tasks[3]) != 701 )
      {
        return 0;
      }
      v24 = 0;
      (*((void (__fastcall **)(CTask *, CPed *, _DWORD, _DWORD))v23->_vptr$CTask + 7))(v23, pPed, 0, 0);
      return v24;
    }
  }
  return *p_m_pSubTask;
}
// 50C770: variable 'm_iEnterCarStartTime' is possibly undefined

//----- (0050C920) --------------------------------------------------------
float __fastcall CTaskComplexWalkRoundCar::ComputeRouteRoundBigCar(CTaskComplexWalkRoundCar *this, const CPed *pPed)
{
  CVector *p_m_vTargetPos; // r8
  int v5; // r5
  float v6; // r9
  CPointRoute *m_pPointRoute; // r0
  __int64 v8; // d16
  char *v9; // r1
  float v10; // r10
  CMatrix *m_pMat; // r5
  CSimpleTransform *p_tx; // r0
  __int64 v13; // kr00_8
  RwReal z; // r10
  float y; // r2
  RwReal v16; // r0
  float *p_tz; // r1
  double v18; // d16
  __int64 v19; // d16
  double v20; // d16
  CMatrix *v21; // r0
  float *p_z; // r0
  CPointRoute *v23; // r1
  RwReal v24; // r0
  CVector *m_routePoints; // r2
  RwReal *p_y; // r3
  int v27; // r6
  __int64 v28; // d16
  RwReal v29; // r5
  CPointRoute *v30; // r1
  __int64 v31; // d16
  char *v32; // r2
  int v33; // r2
  RwReal *v34; // r1
  CPointRoute *v35; // r3
  __int64 v36; // d16
  char *v37; // r6
  float v38; // r6
  CPointRoute *v39; // r0
  __int64 v40; // d16
  char *v41; // r1
  CVector v43[8]; // [sp+0h] [bp-B0h] BYREF
  double v44; // [sp+68h] [bp-48h]
  RwReal v45; // [sp+70h] [bp-40h]
  CVector v46; // [sp+78h] [bp-38h] BYREF
  CVector vClosestPoint; // [sp+88h] [bp-28h] BYREF

  p_m_vTargetPos = &this->m_vTargetPos;
  v5 = CPedGeometryAnalyser::ComputeEntityHitSide(pPed, this->m_pVehicle);
  if ( v5 == CPedGeometryAnalyser::ComputeEntityHitSide(&this->m_vTargetPos, this->m_pVehicle) )
  {
    v6 = CPedGeometryAnalyser::ms_fPedNominalRadius;
    CPedGeometryAnalyser::ms_fPedNominalRadius = 0.7;
    CPedGeometryAnalyser::ComputeClosestSurfacePoint(pPed, this->m_pVehicle, v43);
    CPedGeometryAnalyser::ComputeClosestSurfacePoint(&this->m_vTargetPos, this->m_pVehicle, &vClosestPoint);
    CPedGeometryAnalyser::ms_fPedNominalRadius = v6;
    m_pPointRoute = this->m_pPointRoute;
    if ( m_pPointRoute->m_iRouteSize > 7 )
      return 0.0;
    v8 = *(_QWORD *)&v43[0].x;
    v9 = (char *)m_pPointRoute + 12 * m_pPointRoute->m_iRouteSize;
    *((_DWORD *)v9 + 3) = LODWORD(v43[0].z);
    *(_QWORD *)(v9 + 4) = v8;
    ++m_pPointRoute->m_iRouteSize;
  }
  else
  {
    v10 = CPedGeometryAnalyser::ms_fPedNominalRadius;
    CPedGeometryAnalyser::ms_fPedNominalRadius = 0.7;
    CPedGeometryAnalyser::ComputeClosestSurfacePoint(pPed, this->m_pVehicle, &vClosestPoint);
    CPedGeometryAnalyser::ComputeClosestSurfacePoint(&this->m_vTargetPos, this->m_pVehicle, &v46);
    CPedGeometryAnalyser::ms_fPedNominalRadius = v10;
    m_pMat = pPed->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pPed->m_transform;
    v13 = *(_QWORD *)&p_tx->m_translate.x;
    z = p_tx->m_translate.z;
    y = vClosestPoint.y;
    v16 = vClosestPoint.z;
    if ( m_pMat )
    {
      m_pMat->tx = vClosestPoint.x;
      pPed->m_pMat->ty = y;
      p_tz = &pPed->m_pMat->tz;
    }
    else
    {
      p_tz = &pPed->m_transform.m_translate.z;
      pPed->m_transform.m_translate.x = vClosestPoint.x;
      pPed->m_transform.m_translate.y = y;
    }
    *p_tz = v16;
    v18 = *(double *)&p_m_vTargetPos->x;
    v45 = this->m_vTargetPos.z;
    v44 = v18;
    v19 = *(_QWORD *)&v46.x;
    this->m_vTargetPos.z = v46.z;
    *(_QWORD *)&p_m_vTargetPos->x = v19;
    CTaskComplexWalkRoundCar::ComputeRouteRoundSmallCar(this, pPed);
    v20 = v44;
    this->m_vTargetPos.z = v45;
    *(double *)&p_m_vTargetPos->x = v20;
    v21 = pPed->m_pMat;
    if ( v21 )
    {
      LODWORD(v21->tx) = v13;
      pPed->m_pMat->ty = *((float *)&v13 + 1);
      p_z = &pPed->m_pMat->tz;
    }
    else
    {
      p_z = &pPed->m_transform.m_translate.z;
      *(_QWORD *)&pPed->m_transform.m_translate.x = v13;
    }
    *p_z = z;
    v23 = this->m_pPointRoute;
    v24 = *(float *)&v23->m_iRouteSize;
    v43[0].x = v24;
    if ( SLODWORD(v24) >= 1 )
    {
      m_routePoints = v23->m_routePoints;
      p_y = &v43[0].y;
      v27 = 0;
      do
      {
        v28 = *(_QWORD *)&m_routePoints->x;
        ++v27;
        v29 = m_routePoints->z;
        ++m_routePoints;
        p_y[2] = v29;
        *(_QWORD *)p_y = v28;
        p_y += 3;
      }
      while ( v27 < SLODWORD(v24) );
    }
    v23->m_iRouteSize = 0;
    v30 = this->m_pPointRoute;
    if ( v30->m_iRouteSize <= 7 )
    {
      v31 = *(_QWORD *)&vClosestPoint.x;
      v32 = (char *)v30 + 12 * v30->m_iRouteSize;
      *((_DWORD *)v32 + 3) = LODWORD(vClosestPoint.z);
      *(_QWORD *)(v32 + 4) = v31;
      ++v30->m_iRouteSize;
    }
    if ( SLODWORD(v24) >= 1 )
    {
      v33 = 0;
      v34 = &v43[0].y;
      do
      {
        v35 = this->m_pPointRoute;
        if ( v35->m_iRouteSize <= 7 )
        {
          v36 = *(_QWORD *)v34;
          v37 = (char *)v35 + 12 * v35->m_iRouteSize;
          *((RwReal *)v37 + 3) = v34[2];
          *(_QWORD *)(v37 + 4) = v36;
          ++v35->m_iRouteSize;
        }
        ++v33;
        v34 += 3;
      }
      while ( v33 < SLODWORD(v24) );
    }
    v38 = CPedGeometryAnalyser::ms_fPedNominalRadius;
    CPedGeometryAnalyser::ms_fPedNominalRadius = 0.7;
    CPedGeometryAnalyser::ComputeClosestSurfacePoint(&this->m_vTargetPos, this->m_pVehicle, &vClosestPoint);
    CPedGeometryAnalyser::ms_fPedNominalRadius = v38;
  }
  v39 = this->m_pPointRoute;
  if ( v39->m_iRouteSize <= 7 )
  {
    v40 = *(_QWORD *)&vClosestPoint.x;
    v41 = (char *)v39 + 12 * v39->m_iRouteSize;
    *((_DWORD *)v41 + 3) = LODWORD(vClosestPoint.z);
    *(_QWORD *)(v41 + 4) = v40;
    ++v39->m_iRouteSize;
  }
  return 0.0;
}

//----- (0050CB2C) --------------------------------------------------------
float __fastcall CTaskComplexWalkRoundCar::ComputeRouteRoundSmallCar(CTaskComplexWalkRoundCar *this, const CPed *pPed)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r6
  CSimpleTransform *p_tx; // r2
  CMatrix *v7; // r0
  CSimpleTransform *v8; // r2
  int v9; // r0
  int v10; // r2
  CMatrix *v11; // r1
  float *v12; // r0
  float *v13; // r2
  float v14; // s16
  float x; // s0
  float y; // s4
  float z; // s2
  int v18; // r0
  float *v19; // r1
  CVector *v20; // r0
  float v21; // s0
  RwReal v22; // s4
  RwReal v23; // s2
  RwReal v24; // s0
  float v26; // [sp+8h] [bp-A0h] BYREF
  float v27; // [sp+Ch] [bp-9Ch]
  float v28; // [sp+10h] [bp-98h]
  float v29; // [sp+14h] [bp-94h]
  float out_ds[4]; // [sp+18h] [bp-90h] BYREF
  CVector out_normals; // [sp+28h] [bp-80h] BYREF
  float v32; // [sp+34h] [bp-74h]
  float v33; // [sp+38h] [bp-70h]
  float v34; // [sp+3Ch] [bp-6Ch]
  float v35; // [sp+40h] [bp-68h]
  float v36; // [sp+44h] [bp-64h]
  float v37; // [sp+48h] [bp-60h]
  float v38; // [sp+4Ch] [bp-5Ch]
  float v39; // [sp+50h] [bp-58h]
  float v40; // [sp+54h] [bp-54h]
  CVector corners; // [sp+58h] [bp-50h] BYREF

  m_pMat = pPed->m_pMat;
  p_m_transform = &pPed->m_transform;
  p_tx = &pPed->m_transform;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  CPedGeometryAnalyser::ComputeEntityBoundingBoxCorners(p_tx->m_translate.z, this->m_pVehicle, &corners);
  v7 = pPed->m_pMat;
  v8 = p_m_transform;
  if ( v7 )
    v8 = (CSimpleTransform *)&v7->tx;
  CPedGeometryAnalyser::ComputeEntityBoundingBoxPlanes(v8->m_translate.z, this->m_pVehicle, &out_normals, out_ds);
  v9 = CPedGeometryAnalyser::ComputeEntityHitSide(pPed, this->m_pVehicle);
  if ( v9 == -1 )
  {
    v14 = 0.0;
  }
  else
  {
    v10 = 3 * v9;
    v11 = pPed->m_pMat;
    v12 = &out_ds[v9];
    v13 = &out_normals.x + v10;
    if ( v11 )
      p_m_transform = (CSimpleTransform *)&v11->tx;
    v14 = *v12
        + (float)((float)((float)(*v13 * p_m_transform->m_translate.x) + (float)(v13[1] * p_m_transform->m_translate.y))
                + (float)(v13[2] * p_m_transform->m_translate.z));
  }
  if ( *((unsigned __int8 *)this + 13) << 31 )
  {
    x = this->m_vTargetPos.x;
    y = this->m_vTargetPos.y;
    z = this->m_vTargetPos.z;
    v26 = out_ds[0]
        + (float)((float)((float)(out_normals.x * x) + (float)(out_normals.y * y)) + (float)(out_normals.z * z));
    if ( v26 < 0.0 )
    {
      v27 = out_ds[1] + (float)((float)((float)(v32 * x) + (float)(v33 * y)) + (float)(v34 * z));
      if ( v27 < 0.0 )
      {
        v28 = out_ds[2] + (float)((float)((float)(v35 * x) + (float)(v36 * y)) + (float)(v37 * z));
        if ( v28 < 0.0 )
        {
          v29 = out_ds[3] + (float)((float)((float)(v38 * x) + (float)(v39 * y)) + (float)(v40 * z));
          if ( v29 < 0.0 )
          {
            v18 = CPedGeometryAnalyser::ComputeEntityHitSide(&this->m_vTargetPos, this->m_pVehicle);
            if ( v18 != -1 )
            {
              v19 = &v26 + v18;
              v20 = &out_normals + v18;
              v21 = 0.05 - *v19;
              v22 = (float)(v21 * v20->y) + this->m_vTargetPos.y;
              v23 = (float)(v20->x * v21) + this->m_vTargetPos.x;
              v24 = (float)(v21 * v20->z) + this->m_vTargetPos.z;
              this->m_vTargetPos.x = v23;
              this->m_vTargetPos.y = v22;
              this->m_vTargetPos.z = v24;
            }
          }
        }
      }
    }
  }
  *((_BYTE *)this + 13) = *((_BYTE *)this + 13) & 0xC3 | (4
                                                        * (CPedGeometryAnalyser::ComputeRouteRoundEntityBoundingBox(
                                                             pPed,
                                                             this->m_pVehicle,
                                                             &this->m_vTargetPos,
                                                             this->m_pPointRoute,
                                                             *((unsigned __int8 *)this + 14) << 28 >> 28) & 0xF));
  return v14;
}

//----- (0050CD60) --------------------------------------------------------
bool __fastcall CTaskComplexWalkRoundCar::GoingForDoor(const CTaskComplexWalkRoundCar *this)
{
  bool v1; // zf
  _BOOL4 v2; // r0

  v1 = *((unsigned __int8 *)this + 13) << 31 == 0;
  if ( *((unsigned __int8 *)this + 13) << 31 )
  {
    this = (const CTaskComplexWalkRoundCar *)this->m_pVehicle;
    v1 = this == 0;
  }
  if ( v1 )
    LOBYTE(v2) = 0;
  else
    return (*((unsigned __int8 *)&this[12] + 13) >> 2) & 1;
  return v2;
}

//----- (0050CD7C) --------------------------------------------------------
void __fastcall CTaskComplexWalkRoundBuildingAttempt::CTaskComplexWalkRoundBuildingAttempt(
        CTaskComplexWalkRoundBuildingAttempt *this,
        const int iMoveState,
        const CVector *vTarget,
        const CVector *vPos,
        const CVector *vNormal,
        const bool bIsHeadOnCollision)
{
  int8 v8; // r8
  __int64 v10; // d16
  __int64 v11; // d16
  char v12; // r2
  CPointRoute *v13; // r0
  CPointRoute *v14; // r0

  v8 = iMoveState;
  CTaskComplex::CTaskComplex(this);
  this->_vptr$CTask = (int (**)(void))&off_66B824;
  v10 = *(_QWORD *)&vTarget->x;
  this->m_vTarget.z = vTarget->z;
  *(_QWORD *)&this->m_vTarget.x = v10;
  v11 = *(_QWORD *)&vPos->x;
  v12 = *((_BYTE *)this + 73);
  this->m_vPos.z = vPos->z;
  *(_QWORD *)&this->m_vPos.x = v11;
  *(_QWORD *)&this->m_vNormal.x = *(_QWORD *)&vNormal->x;
  *((_BYTE *)this + 73) = v12 & 0xC0 | bIsHeadOnCollision;
  this->m_TargetEntity = 0;
  this->m_iMoveState = v8;
  this->m_iAttempts = 0;
  this->m_vNormal.z = 0.0;
  CVector::Normalise(&this->m_vNormal);
  v13 = (CPointRoute *)CPointRoute::operator new(0x64u);
  v13->m_iRouteSize = 0;
  this->m_pRoute = v13;
  v14 = (CPointRoute *)CPointRoute::operator new(0x64u);
  v14->m_iRouteSize = 0;
  this->m_pCrapRoute = v14;
}
// 66B824: using guessed type void *;

//----- (0050CE04) --------------------------------------------------------
void __fastcall CTaskComplexWalkRoundBuildingAttempt::CTaskComplexWalkRoundBuildingAttempt(
        CTaskComplexWalkRoundBuildingAttempt *this,
        const int iMoveState,
        CEntity *target_entity,
        const CVector *offset_vector,
        const CVector *vPos,
        const CVector *vNormal,
        const bool bIsHeadOnCollision)
{
  int8 v9; // r9
  __int64 v11; // d16
  __int64 v12; // d16
  char v13; // r1
  __int64 v14; // d16
  CPointRoute *v15; // r0
  CPointRoute *v16; // r0
  CEntity *m_TargetEntity; // r1

  v9 = iMoveState;
  CTaskComplex::CTaskComplex(this);
  this->_vptr$CTask = (int (**)(void))&off_66B824;
  v11 = *(_QWORD *)&vPos->x;
  this->m_vPos.z = vPos->z;
  *(_QWORD *)&this->m_vPos.x = v11;
  v12 = *(_QWORD *)&vNormal->x;
  this->m_vNormal.z = vNormal->z;
  *(_QWORD *)&this->m_vNormal.x = v12;
  this->m_TargetEntity = target_entity;
  v13 = *((_BYTE *)this + 73);
  v14 = *(_QWORD *)&offset_vector->x;
  this->m_OffsetVector.z = offset_vector->z;
  this->m_iMoveState = v9;
  this->m_iAttempts = 0;
  this->m_vNormal.z = 0.0;
  *((_BYTE *)this + 73) = v13 & 0xC0 | bIsHeadOnCollision | 4;
  *(_QWORD *)&this->m_OffsetVector.x = v14;
  CVector::Normalise(&this->m_vNormal);
  v15 = (CPointRoute *)CPointRoute::operator new(0x64u);
  v15->m_iRouteSize = 0;
  this->m_pRoute = v15;
  v16 = (CPointRoute *)CPointRoute::operator new(0x64u);
  v16->m_iRouteSize = 0;
  m_TargetEntity = this->m_TargetEntity;
  this->m_pCrapRoute = v16;
  CEntity::RegisterReference(m_TargetEntity, &this->m_TargetEntity);
}
// 66B824: using guessed type void *off_66B824;

//----- (0050CEA4) --------------------------------------------------------
void __fastcall CTaskComplexWalkRoundBuildingAttempt::~CTaskComplexWalkRoundBuildingAttempt(
        CTaskComplexWalkRoundBuildingAttempt *this)
{
  CPointRoute *m_pRoute; // r0
  CPointRoute *m_pCrapRoute; // r0
  CEntity *m_TargetEntity; // r0

  m_pRoute = this->m_pRoute;
  this->_vptr$CTask = (int (**)(void))&off_66B824;
  if ( m_pRoute )
    CPointRoute::operator delete(m_pRoute);
  m_pCrapRoute = this->m_pCrapRoute;
  if ( m_pCrapRoute )
    CPointRoute::operator delete(m_pCrapRoute);
  m_TargetEntity = this->m_TargetEntity;
  if ( m_TargetEntity )
    CEntity::CleanUpOldReference(m_TargetEntity, &this->m_TargetEntity);
  sub_18EDB4(this);
}
// 66B824: using guessed type void *off_66B824;

//----- (0050CEE4) --------------------------------------------------------
void __fastcall CTaskComplexWalkRoundBuildingAttempt::~CTaskComplexWalkRoundBuildingAttempt(
        CTaskComplexWalkRoundBuildingAttempt *this)
{
  CPointRoute *m_pRoute; // r0
  CPointRoute *m_pCrapRoute; // r0
  CEntity *m_TargetEntity; // r0
  void *v5; // r0

  m_pRoute = this->m_pRoute;
  this->_vptr$CTask = (int (**)(void))&off_66B824;
  if ( m_pRoute )
    CPointRoute::operator delete(m_pRoute);
  m_pCrapRoute = this->m_pCrapRoute;
  if ( m_pCrapRoute )
    CPointRoute::operator delete(m_pCrapRoute);
  m_TargetEntity = this->m_TargetEntity;
  if ( m_TargetEntity )
    CEntity::CleanUpOldReference(m_TargetEntity, &this->m_TargetEntity);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v5);
}
// 50CF20: variable 'v5' is possibly undefined
// 66B824: using guessed type void *off_66B824;

//----- (0050CF28) --------------------------------------------------------
bool __fastcall CTaskComplexWalkRoundBuildingAttempt::MakeAbortable(
        CTaskComplexWalkRoundBuildingAttempt *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  int v5; // r0

  v5 = (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
        + 7))(
         this->m_pSubTask,
         pPed,
         iPriority,
         pEvent);
  if ( v5 == 1 )
    *((_DWORD *)&pPed->m_nPedFlags + 3) &= ~0x40u;
  return v5;
}

//----- (0050CF4C) --------------------------------------------------------
CTask *__fastcall CTaskComplexWalkRoundBuildingAttempt::CreateNextSubTask(
        CTaskComplexWalkRoundBuildingAttempt *this,
        CPed *pPed)
{
  int v4; // r0
  int v5; // r2
  int v6; // r3
  int v7; // r1
  CTask *result; // r0
  CTaskSimpleRunTimedAnim *v9; // r0
  CMatrix *m_pMat; // r0
  CPointRoute *m_pRoute; // r1
  CSimpleTransform *p_tx; // r2
  float y; // s4
  float z; // s6
  float RadianAngleBetweenPoints; // r0
  float v16; // r4
  CTaskSimpleAchieveHeading *v17; // r0
  CTaskComplexFollowPointRoute *v18; // r0
  CVector v19; // [sp+14h] [bp-1Ch] BYREF

  if ( (*((_BYTE *)this + 73) & 0x10) != 0 )
    goto LABEL_14;
  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v4 < 422 )
  {
    if ( v4 == 203 || v4 != 411 && v4 != 421 )
      goto LABEL_14;
    goto LABEL_10;
  }
  if ( v4 <= 901 )
  {
    if ( v4 == 422 )
    {
      if ( (*((_BYTE *)this + 73) & 2) == 0 )
      {
LABEL_17:
        v9 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x34u);
        CTaskSimpleRunTimedAnim::CTaskSimpleRunTimedAnim(
          v9,
          ANIM_STD_PED,
          ANIM_STD_IDLE_HBHB,
          4.0,
          -4.0,
          1000,
          422,
          "LookAbout",
          0);
        result->_vptr$CTask = (int (**)(void))&off_665898;
        return result;
      }
      goto LABEL_18;
    }
    if ( v4 != 900 )
      goto LABEL_14;
LABEL_10:
    if ( (*((_BYTE *)this + 73) & 2) == 0 )
      goto LABEL_17;
LABEL_18:
    m_pMat = pPed->m_pMat;
    m_pRoute = this->m_pRoute;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pPed->m_transform;
    y = p_tx->m_translate.y;
    z = p_tx->m_translate.z;
    v19.x = m_pRoute->m_routePoints[0].x - p_tx->m_translate.x;
    v19.y = m_pRoute->m_routePoints[0].y - y;
    v19.z = m_pRoute->m_routePoints[0].z - z;
    CVector::Normalise(&v19);
    RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(v19.x, v19.y, 0.0, 0.0);
    v16 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
    v17 = (CTaskSimpleAchieveHeading *)CTask::operator new(0x18u);
    CTaskSimpleAchieveHeading::CTaskSimpleAchieveHeading(v17, v16, 1.0, 0.1);
    return result;
  }
  if ( v4 != 902 )
  {
    if ( v4 == 905 )
      return 0;
LABEL_14:
    v5 = *((_DWORD *)&pPed->m_nPedFlags + 2);
    v6 = *((_DWORD *)&pPed->m_nPedFlags + 3);
    v7 = *((_DWORD *)&pPed->m_nPedFlags + 1);
    *(_DWORD *)&pPed->m_nPedFlags = pPed->m_nPedFlags;
    *((_DWORD *)&pPed->m_nPedFlags + 1) = v7;
    *((_DWORD *)&pPed->m_nPedFlags + 2) = v5;
    *((_DWORD *)&pPed->m_nPedFlags + 3) = v6 & 0xFFFFFFBF;
    return 0;
  }
  v18 = (CTaskComplexFollowPointRoute *)CTask::operator new(0x3Cu);
  CTaskComplexFollowPointRoute::CTaskComplexFollowPointRoute(
    v18,
    this->m_iMoveState,
    this->m_pRoute,
    0,
    0.5,
    0.5,
    0,
    0,
    1);
  return result;
}
// 50D064: variable 'result' is possibly undefined
// 665898: using guessed type void *off_665898;
// 677568: using guessed type void *`vtable for'CTaskSimpleLookAbout;

//----- (0050D11C) --------------------------------------------------------
CTask *__fastcall CTaskComplexWalkRoundBuildingAttempt::CreateSubTask(
        const CTaskComplexWalkRoundBuildingAttempt *this,
        const int iSubTaskType,
        CPed *pPed)
{
  CTask *result; // r0
  CTaskSimpleGoToPoint *v5; // r0
  CTaskSimpleRunAnim *v6; // r0
  void **v7; // r1
  CTaskComplexFollowPointRoute *v8; // r0
  CTaskSimpleRunTimedAnim *v9; // r0
  CTaskSimpleStandStill *v10; // r0
  CMatrix *m_pMat; // r0
  CPointRoute *m_pRoute; // r1
  CSimpleTransform *p_tx; // r3
  float y; // s4
  float z; // s6
  float RadianAngleBetweenPoints; // r0
  float v17; // r4
  CTaskSimpleAchieveHeading *v18; // r0
  CTaskSimpleRunAnim *v19; // r0
  CVector v20; // [sp+14h] [bp-14h] BYREF

  result = 0;
  if ( iSubTaskType < 422 )
  {
    switch ( iSubTaskType )
    {
      case 203:
        v10 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
        CTaskSimpleStandStill::CTaskSimpleStandStill(v10, 1000, 0, 0, 8.0);
        return result;
      case 411:
        v19 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
        CTaskSimpleRunAnim::CTaskSimpleRunAnim(v19, ANIM_STD_PED, ANIM_STD_HIT_WALL, 4.0, 411, "HitWall", 0);
        v7 = &`vtable for'CTaskSimpleHitWall;
        break;
      case 421:
        v6 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
        CTaskSimpleRunAnim::CTaskSimpleRunAnim(v6, ANIM_STD_PED, ANIM_STD_XPRESS_SCRATCH, 4.0, 421, "ScratchHead", 0);
        v7 = &`vtable for'CTaskSimpleScratchHead;
        break;
      default:
        return result;
    }
    goto LABEL_20;
  }
  if ( iSubTaskType <= 901 )
  {
    if ( iSubTaskType != 422 )
    {
      if ( iSubTaskType == 900 )
      {
        v5 = (CTaskSimpleGoToPoint *)CTask::operator new(0x2Cu);
        CTaskSimpleGoToPoint::CTaskSimpleGoToPoint(v5, this->m_iMoveState, &this->m_vTarget, 0.5, 0, 0);
      }
      return result;
    }
    v9 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x34u);
    CTaskSimpleRunTimedAnim::CTaskSimpleRunTimedAnim(
      v9,
      ANIM_STD_PED,
      ANIM_STD_IDLE_HBHB,
      4.0,
      -4.0,
      1000,
      422,
      "LookAbout",
      0);
    v7 = &`vtable for'CTaskSimpleLookAbout;
LABEL_20:
    result->_vptr$CTask = (int (**)(void))((char *)*v7 + 8);
    return result;
  }
  if ( iSubTaskType == 902 )
  {
    m_pMat = pPed->m_pMat;
    m_pRoute = this->m_pRoute;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pPed->m_transform;
    y = p_tx->m_translate.y;
    z = p_tx->m_translate.z;
    v20.x = m_pRoute->m_routePoints[0].x - p_tx->m_translate.x;
    v20.y = m_pRoute->m_routePoints[0].y - y;
    v20.z = m_pRoute->m_routePoints[0].z - z;
    CVector::Normalise(&v20);
    RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(v20.x, v20.y, 0.0, 0.0);
    v17 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
    v18 = (CTaskSimpleAchieveHeading *)CTask::operator new(0x18u);
    CTaskSimpleAchieveHeading::CTaskSimpleAchieveHeading(v18, v17, 1.0, 0.1);
  }
  else if ( iSubTaskType == 905 )
  {
    v8 = (CTaskComplexFollowPointRoute *)CTask::operator new(0x3Cu);
    CTaskComplexFollowPointRoute::CTaskComplexFollowPointRoute(
      v8,
      this->m_iMoveState,
      this->m_pRoute,
      0,
      0.5,
      0.5,
      0,
      0,
      1);
  }
  return result;
}
// 50D2CC: variable 'result' is possibly undefined
// 677568: using guessed type void *`vtable for'CTaskSimpleLookAbout;
// 6784D8: using guessed type void *`vtable for'CTaskSimpleScratchHead;
// 6796E4: using guessed type void *`vtable for'CTaskSimpleHitWall;

//----- (0050D2F4) --------------------------------------------------------
CTask *__fastcall CTaskComplexWalkRoundBuildingAttempt::CreateFirstSubTask(
        CTaskComplexWalkRoundBuildingAttempt *this,
        CPed *pPed)
{
  CEntity *m_TargetEntity; // r6
  const CMatrix *m_pMat; // r1
  int v6; // r3
  int m_nPedFlags; // r0
  int v8; // r1
  int v9; // r2
  int m_iMoveState; // r6
  CTaskSimpleRunAnim *v11; // r0
  CTask *result; // r0
  void **v13; // r1
  CTaskSimpleRunAnim *v14; // r0
  int v15; // r2
  int v16; // r3
  int v17; // r1

  if ( (*((_BYTE *)this + 73) & 4) != 0 )
  {
    m_TargetEntity = this->m_TargetEntity;
    if ( !m_TargetEntity )
    {
      v15 = *((_DWORD *)&pPed->m_nPedFlags + 2);
      v16 = *((_DWORD *)&pPed->m_nPedFlags + 3);
      v17 = *((_DWORD *)&pPed->m_nPedFlags + 1);
      *(_DWORD *)&pPed->m_nPedFlags = pPed->m_nPedFlags;
      *((_DWORD *)&pPed->m_nPedFlags + 1) = v17;
      *((_DWORD *)&pPed->m_nPedFlags + 2) = v15;
      *((_DWORD *)&pPed->m_nPedFlags + 3) = v16 & 0xFFFFFFBF;
      return 0;
    }
    m_pMat = m_TargetEntity->m_pMat;
    if ( !m_pMat )
    {
      CPlaceable::AllocateMatrix(this->m_TargetEntity);
      CSimpleTransform::UpdateMatrix(&m_TargetEntity->m_transform, m_TargetEntity->m_pMat);
      m_pMat = m_TargetEntity->m_pMat;
    }
    CVector::FromMultiply(&this->m_vTarget, m_pMat, &this->m_OffsetVector);
  }
  v6 = *((_DWORD *)&pPed->m_nPedFlags + 3);
  m_nPedFlags = (int)pPed->m_nPedFlags;
  v8 = *((_DWORD *)&pPed->m_nPedFlags + 1);
  v9 = *((_DWORD *)&pPed->m_nPedFlags + 2);
  *((_DWORD *)&pPed->m_nPedFlags + 3) = v6 | 0x40;
  m_iMoveState = this->m_iMoveState;
  if ( (unsigned int)(m_iMoveState - 1) < 3 )
    goto LABEL_11;
  if ( (unsigned int)(m_iMoveState - 6) < 2 )
  {
    v11 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
    CTaskSimpleRunAnim::CTaskSimpleRunAnim(v11, ANIM_STD_PED, ANIM_STD_HIT_WALL, 4.0, 411, "HitWall", 0);
    v13 = &`vtable for'CTaskSimpleHitWall;
LABEL_12:
    result->_vptr$CTask = (int (**)(void))((char *)*v13 + 8);
    return result;
  }
  if ( m_iMoveState == 4 )
  {
LABEL_11:
    v14 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
    CTaskSimpleRunAnim::CTaskSimpleRunAnim(v14, ANIM_STD_PED, ANIM_STD_XPRESS_SCRATCH, 4.0, 421, "ScratchHead", 0);
    v13 = &`vtable for'CTaskSimpleScratchHead;
    goto LABEL_12;
  }
  *(_DWORD *)&pPed->m_nPedFlags = m_nPedFlags;
  *((_DWORD *)&pPed->m_nPedFlags + 1) = v8;
  *((_DWORD *)&pPed->m_nPedFlags + 2) = v9;
  *((_DWORD *)&pPed->m_nPedFlags + 3) = v6 & 0xFFFFFFBF;
  return 0;
}
// 50D3E0: variable 'result' is possibly undefined
// 6784D8: using guessed type void *`vtable for'CTaskSimpleScratchHead;
// 6796E4: using guessed type void *`vtable for'CTaskSimpleHitWall;

//----- (0050D450) --------------------------------------------------------
void __fastcall CTaskComplexWalkRoundBuildingAttempt::ComputeMoveDir(
        const CTaskComplexWalkRoundBuildingAttempt *this,
        const CPed *ped,
        CVector *vMoveDir)
{
  CMatrix *m_pMat; // r12
  CSimpleTransform *p_tx; // r3
  float v5; // s0
  __int64 v6; // d16
  float v7; // s2
  float x; // s6
  float v9; // s4
  float y; // s8
  RwReal v11; // s2
  RwReal v12; // s0
  CMatrix *v13; // r0
  __int64 v14; // d16

  m_pMat = ped->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &ped->m_transform;
  v5 = this->m_vTarget.x - p_tx->m_translate.x;
  v6 = *(_QWORD *)&this->m_vNormal.x;
  v7 = this->m_vTarget.y - p_tx->m_translate.y;
  vMoveDir->z = this->m_vNormal.z;
  *(_QWORD *)&vMoveDir->x = v6;
  x = vMoveDir->x;
  v9 = (float)((float)(v5 * this->m_vNormal.x) + (float)(v7 * this->m_vNormal.y)) + (float)(this->m_vNormal.z * 0.0);
  y = vMoveDir->y;
  vMoveDir->z = 0.0;
  v11 = v7 - (float)(v9 * y);
  v12 = v5 - (float)(x * v9);
  vMoveDir->x = v12;
  vMoveDir->y = v11;
  if ( (float)((float)((float)(v12 * v12) + (float)(v11 * v11)) + 0.0) < 0.00000001 )
  {
    v13 = ped->m_pMat;
    v14 = *(_QWORD *)&v13->xx;
    vMoveDir->z = v13->zx;
    *(_QWORD *)&vMoveDir->x = v14;
  }
  else
  {
    j_CVector::Normalise(vMoveDir);
  }
}

//----- (0050D508) --------------------------------------------------------
void __fastcall CTaskComplexWalkRoundBuildingAttempt::AddNormalToMoveDir(
        const CTaskComplexWalkRoundBuildingAttempt *this,
        CVector *vMoveDir)
{
  RwReal v2; // s4
  RwReal v3; // s0

  v2 = (float)(this->m_vNormal.y * 0.35) + vMoveDir->y;
  v3 = (float)(this->m_vNormal.z * 0.35) + vMoveDir->z;
  vMoveDir->x = (float)(this->m_vNormal.x * 0.35) + vMoveDir->x;
  vMoveDir->y = v2;
  vMoveDir->z = v3;
}

//----- (0050D550) --------------------------------------------------------
void __fastcall CTaskComplexWalkRoundBuildingAttempt::ComputeRoute(
        CTaskComplexWalkRoundBuildingAttempt *this,
        const CPed *ped)
{
  CPointRoute *m_pRoute; // r1
  char v5; // r0
  float v6; // s20
  float v7; // s18
  float v8; // s16
  int v9; // r10
  int v10; // r1
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r1
  float v13; // s0
  float v14; // s2
  float v15; // s4
  __int64 v16; // d16
  float x; // s23
  float y; // s25
  float z; // s27
  float v20; // s0
  float v21; // s6
  RwReal v22; // s23
  RwReal v23; // s25
  RwReal v24; // s27
  CSimpleTransform *p_tx; // r1
  char v26; // r6
  RwReal v27; // s8
  RwReal v28; // s10
  RwReal v29; // s0
  CMatrix *v30; // r0
  RwReal v31; // s0
  CPointRoute *m_pCrapRoute; // r0
  __int64 v33; // d16
  char *v34; // r1
  CPointRoute *v35; // r0
  __int64 v36; // d16
  char *v37; // r1
  CPointRoute *v38; // r0
  __int64 v39; // d16
  char *v40; // r1
  CPointRoute *v41; // r0
  __int64 v42; // d16
  char *v43; // r1
  __int64 v44; // r0
  bool v45; // cc
  int v46; // r2
  int v47; // r3
  __int64 v48; // d16
  int v49; // r6
  CPointRoute *v50; // r0
  __int64 v51; // d16
  char *v52; // r1
  int v53; // [sp+18h] [bp-D0h]
  int v54; // [sp+1Ch] [bp-CCh]
  const CVector *p_m_vTarget; // [sp+24h] [bp-C4h]
  CVector vecStart; // [sp+28h] [bp-C0h] BYREF
  CVector v57; // [sp+34h] [bp-B4h] BYREF
  CVector v58; // [sp+40h] [bp-A8h] BYREF
  CVector v59; // [sp+50h] [bp-98h] BYREF
  CVector v60; // [sp+5Ch] [bp-8Ch] BYREF
  CVector v61; // [sp+68h] [bp-80h] BYREF
  CVector vecEnd; // [sp+78h] [bp-70h] BYREF

  m_pRoute = this->m_pRoute;
  v5 = *((_BYTE *)this + 73);
  m_pRoute->m_iRouteSize = 0;
  LOBYTE(m_pRoute) = this->m_iAttempts + 1;
  this->m_iAttempts = (char)m_pRoute;
  if ( (char)m_pRoute > 19 )
  {
    if ( (*((_BYTE *)this + 73) & 8) == 0 )
      CTaskComplexWalkRoundBuildingAttempt::ComputeCrapRoute(this, ped);
    v44 = *(_QWORD *)&this->m_pRoute;
    v45 = *(_DWORD *)HIDWORD(v44) < 1;
    *(_DWORD *)v44 = *(_DWORD *)HIDWORD(v44);
    if ( !v45 )
    {
      HIDWORD(v44) += 4;
      v46 = v44 + 4;
      v47 = 0;
      do
      {
        v48 = *(_QWORD *)HIDWORD(v44);
        ++v47;
        v49 = *(_DWORD *)(HIDWORD(v44) + 8);
        HIDWORD(v44) += 12;
        *(_DWORD *)(v46 + 8) = v49;
        *(_QWORD *)v46 = v48;
        v46 += 12;
      }
      while ( v47 < *(_DWORD *)v44 );
    }
  }
  else
  {
    v53 = (v5 & 1) + 1;
    v6 = this->m_vNormal.x + this->m_vNormal.x;
    v7 = this->m_vNormal.y + this->m_vNormal.y;
    v8 = this->m_vNormal.z + this->m_vNormal.z;
    v9 = 1;
    v10 = 0;
    p_m_vTarget = &this->m_vTarget;
LABEL_3:
    v54 = v10;
    while ( 1 )
    {
      m_pMat = ped->m_pMat;
      p_m_transform = &ped->m_transform;
      if ( m_pMat )
        p_m_transform = (CSimpleTransform *)&m_pMat->tx;
      v13 = this->m_vTarget.x - p_m_transform->m_translate.x;
      v14 = this->m_vTarget.y - p_m_transform->m_translate.y;
      *(_QWORD *)&v58.x = *(_QWORD *)&this->m_vNormal.x;
      v15 = (float)((float)(v13 * this->m_vNormal.x) + (float)(v14 * this->m_vNormal.y))
          + (float)(this->m_vNormal.z * 0.0);
      v58.z = 0.0;
      v58.y = v14 - (float)(v15 * v58.y);
      v58.x = v13 - (float)(v58.x * v15);
      if ( (float)((float)((float)(v58.x * v58.x) + (float)(v58.y * v58.y)) + 0.0) >= 0.00000001 )
      {
        CVector::Normalise(&v58);
      }
      else
      {
        v16 = *(_QWORD *)&m_pMat->xx;
        v58.z = m_pMat->zx;
        *(_QWORD *)&v58.x = v16;
      }
      x = v58.x;
      y = v58.y;
      z = v58.z;
      v20 = (float)((float)((float)((float)rand() * 4.6566e-10) * 0.4) + -0.2) + (float)this->m_iAttempts;
      v21 = (float)(x * v20) * (float)v9;
      v22 = (float)(this->m_vNormal.y * 0.35) + (float)((float)(y * v20) * (float)v9);
      v23 = (float)(this->m_vNormal.x * 0.35) + v21;
      v24 = (float)(this->m_vNormal.z * 0.35) + (float)((float)(z * v20) * (float)v9);
      v57.y = v22;
      v57.x = v23;
      v57.z = v24;
      CVector::Normalise(&v57);
      p_tx = &ped->m_transform;
      v57.x = v57.x * 0.7;
      v57.y = v57.y * 0.7;
      v57.z = v57.z * 0.7;
      v26 = *((_BYTE *)this + 73);
      v27 = v22 + this->m_vPos.y;
      v28 = (float)(v24 + this->m_vPos.z) + -0.5;
      v29 = (float)(v23 + this->m_vPos.x) - v57.x;
      vecEnd.x = v23 + this->m_vPos.x;
      vecEnd.y = v27;
      vecEnd.z = v28;
      v60.x = v29;
      v60.y = v27 - v57.y;
      v60.z = v28 - v57.z;
      v30 = ped->m_pMat;
      if ( v30 )
        p_tx = (CSimpleTransform *)&v30->tx;
      v31 = p_tx->m_translate.z + -0.5;
      *(_QWORD *)&vecStart.x = *(_QWORD *)&p_tx->m_translate.x;
      vecStart.z = v31;
      v9 = (v26 & 1) + v9 - 3;
      if ( !CWorld::GetIsLineOfSightClear(&vecStart, &vecEnd, 1, 0, 0, 0, 0, 0, 0) )
      {
        v10 = v54 + 1;
        if ( v9 >= -1 )
          goto LABEL_3;
        goto LABEL_38;
      }
      if ( CWorld::GetIsLineOfSightClear(&vecEnd, p_m_vTarget, 1, 0, 0, 0, 0, 0, 0) )
        break;
      v61.x = vecEnd.x - v6;
      v61.y = vecEnd.y - v7;
      v61.z = vecEnd.z - v8;
      v59.x = v60.x - v6;
      v59.y = v60.y - v7;
      v59.z = v60.z - v8;
      if ( CWorld::GetIsLineOfSightClear(&vecEnd, &v61, 1, 0, 0, 0, 0, 0, 0)
        && CWorld::GetIsLineOfSightClear(&v60, &v59, 1, 0, 0, 0, 0, 0, 0) )
      {
        if ( (*((_BYTE *)this + 73) & 8) == 0 )
        {
          this->m_pCrapRoute->m_iRouteSize = 0;
          m_pCrapRoute = this->m_pCrapRoute;
          if ( m_pCrapRoute->m_iRouteSize <= 7 )
          {
            v33 = *(_QWORD *)&vecEnd.x;
            v34 = (char *)m_pCrapRoute + 12 * m_pCrapRoute->m_iRouteSize;
            *((_DWORD *)v34 + 3) = LODWORD(vecEnd.z);
            *(_QWORD *)(v34 + 4) = v33;
            ++m_pCrapRoute->m_iRouteSize;
            v35 = this->m_pCrapRoute;
            if ( v35->m_iRouteSize <= 7 )
            {
              v36 = *(_QWORD *)&v61.x;
              v37 = (char *)v35 + 12 * v35->m_iRouteSize;
              *((_DWORD *)v37 + 3) = LODWORD(v61.z);
              *(_QWORD *)(v37 + 4) = v36;
              ++v35->m_iRouteSize;
            }
          }
          *((_BYTE *)this + 73) |= 8u;
        }
        if ( CWorld::GetIsLineOfSightClear(&v61, p_m_vTarget, 1, 0, 0, 0, 0, 0, 0) )
        {
          v38 = this->m_pRoute;
          if ( v38->m_iRouteSize <= 7 )
          {
            v39 = *(_QWORD *)&vecEnd.x;
            v40 = (char *)v38 + 12 * v38->m_iRouteSize;
            *((_DWORD *)v40 + 3) = LODWORD(vecEnd.z);
            *(_QWORD *)(v40 + 4) = v39;
            ++v38->m_iRouteSize;
            v41 = this->m_pRoute;
            if ( v41->m_iRouteSize <= 7 )
            {
              v42 = *(_QWORD *)&v61.x;
              v43 = (char *)v41 + 12 * v41->m_iRouteSize;
              *((_DWORD *)v43 + 3) = LODWORD(v61.z);
              *(_QWORD *)(v43 + 4) = v42;
              ++v41->m_iRouteSize;
            }
          }
          *((_BYTE *)this + 73) |= 2u;
        }
      }
      if ( v9 < -1 )
      {
        v10 = v54;
LABEL_38:
        if ( v10 == v53 && this->m_iAttempts == 1 )
          this->m_iAttempts = 20;
        return;
      }
    }
    v50 = this->m_pRoute;
    if ( v50->m_iRouteSize <= 7 )
    {
      v51 = *(_QWORD *)&vecEnd.x;
      v52 = (char *)v50 + 12 * v50->m_iRouteSize;
      *((_DWORD *)v52 + 3) = LODWORD(vecEnd.z);
      *(_QWORD *)(v52 + 4) = v51;
      ++v50->m_iRouteSize;
    }
  }
  *((_BYTE *)this + 73) |= 2u;
}

//----- (0050D9E8) --------------------------------------------------------
void __fastcall CTaskComplexWalkRoundBuildingAttempt::ComputeCrapRoute(
        CTaskComplexWalkRoundBuildingAttempt *this,
        const CPed *ped)
{
  int v4; // r6
  float x; // s16
  float y; // s18
  float z; // s20
  float v8; // s22
  float v9; // s24
  float v10; // s26
  float v11; // s0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float v14; // s14
  __int64 v15; // r0
  float v16; // s2
  float v17; // s0
  CPointRoute *m_pCrapRoute; // r0
  __int64 v19; // d16
  char *v20; // r1
  CVector v21; // [sp+20h] [bp-A0h] BYREF
  CEntity *refEntityPtr; // [sp+2Ch] [bp-94h] BYREF
  CColPoint v23; // [sp+30h] [bp-90h] BYREF
  CVector vecStart; // [sp+5Ch] [bp-64h] BYREF
  CVector v2; // [sp+68h] [bp-58h] BYREF

  v4 = rand();
  x = this->m_vNormal.x;
  y = this->m_vNormal.y;
  z = this->m_vNormal.z;
  v2.x = 0.0;
  v2.y = 0.0;
  v2.z = 1.0;
  CrossProduct(&v23.m_vecPosition, &this->m_vNormal, &v2);
  v8 = v23.m_vecPosition.x;
  v9 = v23.m_vecPosition.y;
  v10 = v23.m_vecPosition.z;
  v11 = (float)rand();
  m_pMat = ped->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &ped->m_transform;
  v14 = p_tx->m_translate.z;
  v15 = *(_QWORD *)&p_tx->m_translate.x;
  v16 = (float)((float)((float)v4 * 4.6566e-10) + 0.0) + 1.0;
  v17 = (float)((float)(v11 * 4.6566e-10) + (float)(v11 * 4.6566e-10)) + -1.0;
  vecStart.z = v14 + -0.5;
  *(_QWORD *)&vecStart.x = v15;
  v2.y = (float)((float)(y * v16) + (float)(v9 * v17)) + *((float *)&v15 + 1);
  v2.z = (float)((float)(z * v16) + (float)(v10 * v17)) + (float)(v14 + -0.5);
  v2.x = (float)((float)(x * v16) + (float)(v8 * v17)) + *(float *)&v15;
  if ( CWorld::ProcessLineOfSight(&vecStart, &v2, &v23, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0, 0) )
  {
    v21.x = v23.m_vecPosition.x - vecStart.x;
    v21.y = v23.m_vecPosition.y - vecStart.y;
    v21.z = v23.m_vecPosition.z - vecStart.z;
    if ( CVector::NormaliseAndMag(&v21) < 0.35 )
      return;
    v2.z = v23.m_vecPosition.z - (float)(v21.z * 0.35);
    v2.y = v23.m_vecPosition.y - (float)(v21.y * 0.35);
    v2.x = v23.m_vecPosition.x - (float)(v21.x * 0.35);
  }
  m_pCrapRoute = this->m_pCrapRoute;
  if ( m_pCrapRoute->m_iRouteSize <= 7 )
  {
    v19 = *(_QWORD *)&v2.x;
    v20 = (char *)m_pCrapRoute + 12 * m_pCrapRoute->m_iRouteSize;
    *((_DWORD *)v20 + 3) = LODWORD(v2.z);
    *(_QWORD *)(v20 + 4) = v19;
    ++m_pCrapRoute->m_iRouteSize;
  }
  *((_BYTE *)this + 73) |= 8u;
}

//----- (0050DBD0) --------------------------------------------------------
CTask *__fastcall CTaskComplexWalkRoundBuildingAttempt::ControlSubTask(
        CTaskComplexWalkRoundBuildingAttempt *this,
        CPed *pPed)
{
  char v4; // r0
  CEntity *m_TargetEntity; // r5
  const CMatrix *m_pMat; // r1
  float32x2_t v7; // d16
  unsigned __int64 v8; // d1
  CTaskSimpleStandStill *m_pSubTask; // r5
  char v10; // r0
  CPointRoute *m_pRoute; // r1
  CVector v13; // [sp+14h] [bp-1Ch] BYREF

  v4 = *((_BYTE *)this + 73);
  if ( (v4 & 0x10) != 0 )
    return this->m_pSubTask;
  if ( (v4 & 4) != 0 )
  {
    m_TargetEntity = this->m_TargetEntity;
    if ( !m_TargetEntity )
    {
LABEL_8:
      *((_BYTE *)this + 73) = v4 | 0x10;
      m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(m_pSubTask, 1000, 0, 0, 8.0);
      return m_pSubTask;
    }
    m_pMat = m_TargetEntity->m_pMat;
    if ( !m_pMat )
    {
      CPlaceable::AllocateMatrix(this->m_TargetEntity);
      CSimpleTransform::UpdateMatrix(&m_TargetEntity->m_transform, m_TargetEntity->m_pMat);
      m_pMat = m_TargetEntity->m_pMat;
    }
    CVector::FromMultiply(&v13, m_pMat, &this->m_OffsetVector);
    v7.n64_u64[0] = vsub_f32(*(float32x2_t *)&v13.y, *(float32x2_t *)&this->m_vTarget.y).n64_u64[0];
    v8 = vmul_f32(v7, v7).n64_u64[0];
    if ( (float)((float)((float)((float)(v13.x - this->m_vTarget.x) * (float)(v13.x - this->m_vTarget.x)) + *(float *)&v8)
               + *((float *)&v8 + 1)) > 16.0 )
    {
      v4 = *((_BYTE *)this + 73);
      goto LABEL_8;
    }
    v4 = *((_BYTE *)this + 73);
  }
  if ( (v4 & 2) != 0 )
  {
    if ( (v4 & 0x20) == 0
      && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
           this->m_pSubTask,
           pPed,
           1,
           0) == 1 )
    {
      v10 = *((_BYTE *)this + 73);
      m_pRoute = this->m_pRoute;
      *((_BYTE *)this + 73) = v10 | 0x20;
      if ( m_pRoute->m_iRouteSize )
      {
        m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x3Cu);
        CTaskComplexFollowPointRoute::CTaskComplexFollowPointRoute(
          (CTaskComplexFollowPointRoute *)m_pSubTask,
          this->m_iMoveState,
          this->m_pRoute,
          0,
          0.5,
          0.5,
          0,
          0,
          1);
        return m_pSubTask;
      }
      *((_BYTE *)this + 73) = v10 | 0x30;
      m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        (CTaskSimpleRunAnim *)m_pSubTask,
        ANIM_STD_PED,
        ANIM_STD_HIT_WALL,
        4.0,
        411,
        "HitWall",
        0);
LABEL_22:
      m_pSubTask->_vptr$CTask = (int (**)(void))&off_668808;
      return m_pSubTask;
    }
  }
  else
  {
    CTaskComplexWalkRoundBuildingAttempt::ComputeRoute(this, pPed);
  }
  m_pSubTask = (CTaskSimpleStandStill *)this->m_pSubTask;
  if ( (*((int (__fastcall **)(CTaskSimpleStandStill *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) == 905
    && pPed->m_pPedIntelligence->m_iStaticCounter > 30
    && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
         this->m_pSubTask,
         pPed,
         1,
         0) == 1 )
  {
    *((_BYTE *)this + 73) |= 0x10u;
    m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
    CTaskSimpleRunAnim::CTaskSimpleRunAnim(
      (CTaskSimpleRunAnim *)m_pSubTask,
      ANIM_STD_PED,
      ANIM_STD_HIT_WALL,
      4.0,
      411,
      "HitWall",
      0);
    goto LABEL_22;
  }
  return m_pSubTask;
}
// 668808: using guessed type void *off_668808;
// 6796E4: using guessed type void *`vtable for'CTaskSimpleHitWall;

//----- (0050DDB4) --------------------------------------------------------
void __fastcall CTaskComplexWalkRoundObject::CTaskComplexWalkRoundObject(
        CTaskComplexWalkRoundObject *this,
        const int iMoveState,
        const CVector *vTargetPos,
        CEntity *pObject)
{
  __int64 v8; // d16
  RwReal z; // r0
  CPointRoute *v10; // r0

  CTaskComplex::CTaskComplex(this);
  this->m_iMoveState = iMoveState;
  this->_vptr$CTask = (int (**)(void))&off_66B860;
  v8 = *(_QWORD *)&vTargetPos->x;
  z = vTargetPos->z;
  this->m_pObject = pObject;
  this->m_vTargetPos.z = z;
  this->m_timer.m_iStartTime = 0;
  this->m_timer.m_iDuration = 0;
  *(_QWORD *)&this->m_vTargetPos.x = v8;
  *(_WORD *)&this->m_timer.m_bIsActive = 0;
  if ( pObject )
    CEntity::RegisterReference(pObject, &this->m_pObject);
  v10 = (CPointRoute *)CPointRoute::operator new(0x64u);
  v10->m_iRouteSize = 0;
  this->m_pPointRoute = v10;
}
// 66B860: using guessed type void *;

//----- (0050DE18) --------------------------------------------------------
void __fastcall CTaskComplexWalkRoundObject::~CTaskComplexWalkRoundObject(CTaskComplexWalkRoundObject *this)
{
  CEntity *m_pObject; // r0
  CEntity **p_m_pObject; // r1
  CPointRoute *m_pPointRoute; // r0

  p_m_pObject = &this->m_pObject;
  m_pObject = this->m_pObject;
  this->_vptr$CTask = (int (**)(void))&off_66B860;
  if ( m_pObject )
    CEntity::CleanUpOldReference(m_pObject, p_m_pObject);
  m_pPointRoute = this->m_pPointRoute;
  if ( m_pPointRoute )
    CPointRoute::operator delete(m_pPointRoute);
  sub_18EDB4(this);
}
// 66B860: using guessed type void *off_66B860;

//----- (0050DE50) --------------------------------------------------------
void __fastcall CTaskComplexWalkRoundObject::~CTaskComplexWalkRoundObject(CTaskComplexWalkRoundObject *this)
{
  CEntity *m_pObject; // r0
  CEntity **p_m_pObject; // r1
  CPointRoute *m_pPointRoute; // r0
  void *v5; // r0

  p_m_pObject = &this->m_pObject;
  m_pObject = this->m_pObject;
  this->_vptr$CTask = (int (**)(void))&off_66B860;
  if ( m_pObject )
    CEntity::CleanUpOldReference(m_pObject, p_m_pObject);
  m_pPointRoute = this->m_pPointRoute;
  if ( m_pPointRoute )
    CPointRoute::operator delete(m_pPointRoute);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v5);
}
// 50DE82: variable 'v5' is possibly undefined
// 66B860: using guessed type void *off_66B860;

//----- (0050DE8C) --------------------------------------------------------
CTask *__fastcall CTaskComplexWalkRoundObject::CreateNextSubTask(CTaskComplexWalkRoundObject *this, CPed *pPed)
{
  int v4; // r0
  CTaskComplexFollowPointRoute *v5; // r5
  CTaskComplexFollowPointRoute *v6; // r0
  CTask *v7; // r0
  int v8; // r6
  CPointRoute *m_pPointRoute; // r0
  __int64 v10; // d16
  char *v11; // r1
  CPointRoute *v12; // r0
  __int64 v13; // d16
  char *v14; // r1
  CVector vClosestPoint; // [sp+18h] [bp-20h] BYREF

  if ( !this->m_pObject )
    return 0;
  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v4 != 903 )
  {
    if ( v4 == 902 )
    {
      if ( this->m_pPointRoute->m_iRouteSize )
      {
        v5 = (CTaskComplexFollowPointRoute *)CTask::operator new(0x3Cu);
LABEL_6:
        CTaskComplexFollowPointRoute::CTaskComplexFollowPointRoute(
          v5,
          this->m_iMoveState,
          this->m_pPointRoute,
          0,
          0.5,
          0.0,
          1,
          0,
          0);
        return v5;
      }
      CPedGeometryAnalyser::ComputeClosestSurfacePoint(pPed, this->m_pObject, &vClosestPoint);
      v8 = CPedGeometryAnalyser::ComputeEntityHitSide(&vClosestPoint, this->m_pObject);
      if ( v8 != CPedGeometryAnalyser::ComputeEntityHitSide(&this->m_vTargetPos, this->m_pObject) )
      {
        v5 = (CTaskComplexFollowPointRoute *)CTask::operator new(0x28u);
        CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(
          (CTaskComplexGoToPointAndStandStill *)v5,
          4,
          &vClosestPoint,
          0.5,
          2.0,
          0,
          0);
        return v5;
      }
      m_pPointRoute = this->m_pPointRoute;
      if ( m_pPointRoute->m_iRouteSize <= 7 )
      {
        v10 = *(_QWORD *)&vClosestPoint.x;
        v11 = (char *)m_pPointRoute + 12 * m_pPointRoute->m_iRouteSize;
        *((_DWORD *)v11 + 3) = LODWORD(vClosestPoint.z);
        *(_QWORD *)(v11 + 4) = v10;
        ++m_pPointRoute->m_iRouteSize;
      }
      CPedGeometryAnalyser::ComputeClosestSurfacePoint(&this->m_vTargetPos, this->m_pObject, &vClosestPoint);
      v12 = this->m_pPointRoute;
      if ( v12->m_iRouteSize > 7
        || (v13 = *(_QWORD *)&vClosestPoint.x,
            v14 = (char *)v12 + 12 * v12->m_iRouteSize,
            *((_DWORD *)v14 + 3) = LODWORD(vClosestPoint.z),
            *(_QWORD *)(v14 + 4) = v13,
            ++v12->m_iRouteSize,
            this->m_pPointRoute->m_iRouteSize) )
      {
        v5 = (CTaskComplexFollowPointRoute *)CTask::operator new(0x3Cu);
        goto LABEL_6;
      }
    }
    return 0;
  }
  v5 = 0;
  if ( this->m_pPointRoute->m_iRouteSize )
  {
    v6 = (CTaskComplexFollowPointRoute *)CTask::operator new(0x3Cu);
    CTaskComplexFollowPointRoute::CTaskComplexFollowPointRoute(
      v6,
      this->m_iMoveState,
      this->m_pPointRoute,
      0,
      0.5,
      0.0,
      1,
      0,
      0);
    return v7;
  }
  return v5;
}
// 50DF22: variable 'v7' is possibly undefined

//----- (0050E000) --------------------------------------------------------
CTask *__fastcall CTaskComplexWalkRoundObject::CreateSubTask(
        const CTaskComplexWalkRoundObject *this,
        const int iSubTaskType,
        const CPed *pPed)
{
  CTaskSimpleStandStill *v4; // r4
  CTaskComplexFollowPointRoute *v5; // r0
  CTask *v6; // r0

  if ( iSubTaskType == 203 )
  {
    v4 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill(v4, 500, 0, 0, 8.0);
  }
  else if ( iSubTaskType == 905 )
  {
    v4 = 0;
    if ( this->m_pPointRoute->m_iRouteSize )
    {
      v5 = (CTaskComplexFollowPointRoute *)CTask::operator new(0x3Cu);
      CTaskComplexFollowPointRoute::CTaskComplexFollowPointRoute(
        v5,
        this->m_iMoveState,
        this->m_pPointRoute,
        0,
        0.5,
        0.0,
        1,
        0,
        0);
      return v6;
    }
  }
  else
  {
    return 0;
  }
  return v4;
}
// 50E044: variable 'v6' is possibly undefined

//----- (0050E074) --------------------------------------------------------
CTask *__fastcall CTaskComplexWalkRoundObject::CreateRouteTask(
        const CTaskComplexWalkRoundObject *this,
        const CPed *pPed)
{
  CTask *v3; // r4
  CTaskComplexFollowPointRoute *v4; // r0
  CTask *v5; // r0

  v3 = 0;
  if ( this->m_pPointRoute->m_iRouteSize )
  {
    v4 = (CTaskComplexFollowPointRoute *)CTask::operator new(0x3Cu);
    CTaskComplexFollowPointRoute::CTaskComplexFollowPointRoute(
      v4,
      this->m_iMoveState,
      this->m_pPointRoute,
      0,
      0.5,
      0.0,
      1,
      0,
      0);
    return v5;
  }
  return v3;
}
// 50E0AC: variable 'v5' is possibly undefined

//----- (0050E0B8) --------------------------------------------------------
CTask *__fastcall CTaskComplexWalkRoundObject::CreateFirstSubTask(CTaskComplexWalkRoundObject *this, CPed *pPed)
{
  CTaskSimpleAchieveHeading *v4; // r11
  float v5; // r6
  CSimpleTransform *p_m_transform; // r10
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r2
  CMatrix *v9; // r1
  CSimpleTransform *v10; // r0
  int v11; // r0
  CMatrix *v12; // r2
  CSimpleTransform *v13; // r1
  float x; // s22
  float v15; // s24
  CVector *v16; // r2
  float y; // s28
  float z; // s26
  int m_iMoveState; // r1
  float v20; // s16
  float v21; // s20
  float v22; // s18
  CEntity *m_pObject; // r6
  int v24; // r0
  int v25; // r2
  CMatrix *v26; // r0
  CSimpleTransform *v27; // r1
  __int64 v28; // d16
  CMatrix *v29; // r0
  CEntity *v30; // r5
  __int64 v31; // d16
  CMatrix *v32; // r0
  __int64 v33; // d16
  CPointRoute *m_pPointRoute; // r1
  CMatrix *v35; // r0
  float v36; // s0
  float v37; // s2
  float v38; // s4
  CSimpleTransform *v39; // r1
  RwReal v40; // s0
  RwReal v41; // s4
  float v42; // r0
  int v43; // r1
  float v44; // s0
  CMatrix *v45; // r1
  CTaskComplexFollowPointRoute *v46; // r0
  CTask *v47; // r0
  float RadianAngleBetweenPoints; // r0
  float v49; // r4
  float out_ds[4]; // [sp+18h] [bp-98h] BYREF
  CVector out_normals[11]; // [sp+28h] [bp-88h] BYREF

  v4 = 0;
  if ( this->m_pObject )
  {
    this->m_pPointRoute->m_iRouteSize = 0;
    v5 = CPedGeometryAnalyser::ms_fPedNominalRadius;
    CPedGeometryAnalyser::ms_fPedNominalRadius = 0.7;
    CPedGeometryAnalyser::ComputeRouteRoundEntityBoundingBox(
      pPed,
      this->m_pObject,
      &this->m_vTargetPos,
      this->m_pPointRoute,
      0);
    CPedGeometryAnalyser::ms_fPedNominalRadius = v5;
    p_m_transform = &pPed->m_transform;
    m_pMat = pPed->m_pMat;
    p_tx = &pPed->m_transform;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    CPedGeometryAnalyser::ComputeEntityBoundingBoxPlanes(p_tx->m_translate.z, this->m_pObject, out_normals, out_ds);
    v9 = pPed->m_pMat;
    v10 = &pPed->m_transform;
    if ( v9 )
      v10 = (CSimpleTransform *)&v9->tx;
    v11 = CPedGeometryAnalyser::ComputeEntityHitSide(&v10->m_translate, this->m_pObject);
    v12 = pPed->m_pMat;
    v13 = &pPed->m_transform;
    if ( v12 )
      v13 = (CSimpleTransform *)&v12->tx;
    if ( this->m_pPointRoute->m_iRouteSize )
    {
      x = v13->m_translate.x;
      v15 = out_ds[v11];
      v16 = &out_normals[v11];
      y = v13->m_translate.y;
      z = v13->m_translate.z;
      m_iMoveState = this->m_iMoveState;
      v20 = v16->x;
      v21 = v16->y;
      v22 = v16->z;
      m_pObject = this->m_pObject;
      v24 = CTimer::m_snTimeInMilliseconds;
      this->m_timer.m_bIsActive = 1;
      v25 = 4000;
      if ( m_iMoveState == 4 )
        v25 = 8000;
      this->m_timer.m_iStartTime = v24;
      this->m_timer.m_iDuration = v25;
      v26 = m_pObject->m_pMat;
      v27 = &m_pObject->m_transform;
      if ( v26 )
        v27 = (CSimpleTransform *)&v26->tx;
      v28 = *(_QWORD *)&v27->m_translate.x;
      this->m_ObjectPos.z = v27->m_translate.z;
      *(_QWORD *)&this->m_ObjectPos.x = v28;
      v29 = m_pObject->m_pMat;
      if ( v29 )
      {
        v30 = m_pObject;
      }
      else
      {
        CPlaceable::AllocateMatrix(m_pObject);
        CSimpleTransform::UpdateMatrix(&m_pObject->m_transform, m_pObject->m_pMat);
        v30 = this->m_pObject;
        v29 = m_pObject->m_pMat;
      }
      v31 = *(_QWORD *)&v29->xy;
      this->m_ObjectForwardsVec.z = v29->zy;
      *(_QWORD *)&this->m_ObjectForwardsVec.x = v31;
      v32 = v30->m_pMat;
      if ( !v32 )
      {
        CPlaceable::AllocateMatrix(v30);
        CSimpleTransform::UpdateMatrix(&v30->m_transform, v30->m_pMat);
        v32 = v30->m_pMat;
      }
      v33 = *(_QWORD *)&v32->xx;
      this->m_ObjectRightVec.z = v32->zx;
      *(_QWORD *)&this->m_ObjectRightVec.x = v33;
      m_pPointRoute = this->m_pPointRoute;
      v35 = pPed->m_pMat;
      v36 = m_pPointRoute->m_routePoints[0].x;
      v37 = m_pPointRoute->m_routePoints[0].y;
      v38 = m_pPointRoute->m_routePoints[0].z;
      v39 = &pPed->m_transform;
      if ( v35 )
        v39 = (CSimpleTransform *)&v35->tx;
      v40 = v36 - v39->m_translate.x;
      v41 = v38 - v39->m_translate.z;
      out_normals[0].y = v37 - v39->m_translate.y;
      out_normals[0].x = v40;
      out_normals[0].z = v41;
      v42 = CVector::NormaliseAndMag(out_normals);
      v43 = this->m_iMoveState;
      v44 = 6.0;
      if ( v43 == 6 )
        v44 = 4.0;
      if ( v43 == 4 )
        v44 = 2.0;
      v45 = pPed->m_pMat;
      if ( v42 <= v44
        || (float)(v15 + (float)((float)((float)(v20 * x) + (float)(v21 * y)) + (float)(v22 * z))) <= v44
        || (float)((float)((float)(out_normals[0].x * v45->xy) + (float)(out_normals[0].y * v45->yy))
                 + (float)(out_normals[0].z * v45->zy)) <= 0.0 )
      {
        if ( v45 )
          p_m_transform = (CSimpleTransform *)&v45->tx;
        RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                                     this->m_pPointRoute->m_routePoints[0].x - p_m_transform->m_translate.x,
                                     this->m_pPointRoute->m_routePoints[0].y - p_m_transform->m_translate.y,
                                     0.0,
                                     0.0);
        v49 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
        v4 = (CTaskSimpleAchieveHeading *)CTask::operator new(0x18u);
        CTaskSimpleAchieveHeading::CTaskSimpleAchieveHeading(v4, v49, 1.0, 0.2);
      }
      else
      {
        v4 = 0;
        if ( this->m_pPointRoute->m_iRouteSize )
        {
          v46 = (CTaskComplexFollowPointRoute *)CTask::operator new(0x3Cu);
          CTaskComplexFollowPointRoute::CTaskComplexFollowPointRoute(
            v46,
            this->m_iMoveState,
            this->m_pPointRoute,
            0,
            0.5,
            0.0,
            1,
            0,
            0);
          return v47;
        }
      }
    }
  }
  return v4;
}
// 50E302: variable 'v47' is possibly undefined
// 50E0B8: using guessed type float out_ds[4];
// 50E0B8: using guessed type CVector out_normals[11];

//----- (0050E378) --------------------------------------------------------
float __fastcall CTaskComplexWalkRoundObject::ComputeRoute(CTaskComplexWalkRoundObject *this, CPed *pPed)
{
  float v4; // r8
  CSimpleTransform *p_m_transform; // r6
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r2
  CMatrix *v8; // r2
  CSimpleTransform *v9; // r0
  int v10; // r0
  int v11; // r2
  CMatrix *v12; // r1
  float *v13; // r0
  CVector *v14; // r2
  float out_ds[4]; // [sp+8h] [bp-58h] BYREF
  CVector out_normals[6]; // [sp+18h] [bp-48h] BYREF

  v4 = CPedGeometryAnalyser::ms_fPedNominalRadius;
  CPedGeometryAnalyser::ms_fPedNominalRadius = 0.7;
  CPedGeometryAnalyser::ComputeRouteRoundEntityBoundingBox(
    pPed,
    this->m_pObject,
    &this->m_vTargetPos,
    this->m_pPointRoute,
    0);
  CPedGeometryAnalyser::ms_fPedNominalRadius = v4;
  p_m_transform = &pPed->m_transform;
  m_pMat = pPed->m_pMat;
  p_tx = &pPed->m_transform;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  CPedGeometryAnalyser::ComputeEntityBoundingBoxPlanes(p_tx->m_translate.z, this->m_pObject, out_normals, out_ds);
  v8 = pPed->m_pMat;
  v9 = &pPed->m_transform;
  if ( v8 )
    v9 = (CSimpleTransform *)&v8->tx;
  v10 = CPedGeometryAnalyser::ComputeEntityHitSide(&v9->m_translate, this->m_pObject);
  v11 = v10;
  v12 = pPed->m_pMat;
  v13 = &out_ds[v10];
  v14 = &out_normals[v11];
  if ( v12 )
    p_m_transform = (CSimpleTransform *)&v12->tx;
  return *v13
       + (float)((float)((float)(v14->x * p_m_transform->m_translate.x) + (float)(v14->y * p_m_transform->m_translate.y))
               + (float)(v14->z * p_m_transform->m_translate.z));
}
// 50E378: using guessed type float out_ds[4];
// 50E378: using guessed type CVector out_normals[6];

//----- (0050E440) --------------------------------------------------------
CTask *__fastcall CTaskComplexWalkRoundObject::ControlSubTask(CTaskComplexWalkRoundObject *this, CPed *pPed)
{
  unsigned int v4; // r0
  int m_iStartTime; // r1
  CEntity *m_pObject; // r6
  CMatrix *m_pMat; // r1
  CEntity *v8; // r2
  float *p_xx; // r0
  CSimpleTransform *p_tx; // r3
  float32x2_t v11; // d16
  unsigned __int64 v12; // d1
  CTaskSimpleStandStill *v13; // r0
  CTask *result; // r0

  if ( this->m_pObject )
  {
    if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 905
      || !this->m_timer.m_bIsActive
      || (!this->m_timer.m_bIsStopped ? (m_iStartTime = this->m_timer.m_iStartTime, v4 = CTimer::m_snTimeInMilliseconds) : (v4 = CTimer::m_snTimeInMilliseconds, this->m_timer.m_bIsStopped = 0, this->m_timer.m_iStartTime = v4, m_iStartTime = v4),
          m_iStartTime + this->m_timer.m_iDuration > v4) )
    {
      if ( pPed->m_pPedIntelligence->m_iStaticCounter <= 30 )
      {
        if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 203 )
          return this->m_pSubTask;
        m_pObject = this->m_pObject;
        m_pMat = m_pObject->m_pMat;
        if ( m_pMat )
        {
          v8 = this->m_pObject;
          p_xx = &m_pObject->m_pMat->xx;
        }
        else
        {
          CPlaceable::AllocateMatrix(this->m_pObject);
          CSimpleTransform::UpdateMatrix(&m_pObject->m_transform, m_pObject->m_pMat);
          v8 = this->m_pObject;
          p_xx = &m_pObject->m_pMat->xx;
          m_pMat = v8->m_pMat;
        }
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &v8->m_transform;
        v11.n64_u64[0] = vsub_f32(*(float32x2_t *)&this->m_ObjectPos.y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
        v12 = vmul_f32(v11, v11).n64_u64[0];
        if ( (float)((float)((float)((float)(this->m_ObjectPos.x - p_tx->m_translate.x)
                                   * (float)(this->m_ObjectPos.x - p_tx->m_translate.x))
                           + *(float *)&v12)
                   + *((float *)&v12 + 1)) <= 0.0625
          && (float)((float)((float)(this->m_ObjectForwardsVec.x * p_xx[4])
                           + (float)(this->m_ObjectForwardsVec.y * p_xx[5]))
                   + (float)(this->m_ObjectForwardsVec.z * p_xx[6])) >= 0.9
          && (float)((float)((float)(this->m_ObjectRightVec.x * *p_xx) + (float)(this->m_ObjectRightVec.y * p_xx[1]))
                   + (float)(this->m_ObjectRightVec.z * p_xx[2])) >= 0.9 )
        {
          return this->m_pSubTask;
        }
      }
    }
  }
  if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
         this->m_pSubTask,
         pPed,
         1,
         0) != 1 )
    return this->m_pSubTask;
  v13 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
  CTaskSimpleStandStill::CTaskSimpleStandStill(v13, 500, 0, 0, 8.0);
  return result;
}

//----- (0050E5D4) --------------------------------------------------------
void __fastcall CTaskComplexMoveBackAndJump::CTaskComplexMoveBackAndJump(CTaskComplexMoveBackAndJump *this)
{
  _DWORD *v1; // r0

  CTaskComplex::CTaskComplex(this);
  *v1 = &off_66B89C;
}
// 50E5E4: variable 'v1' is possibly undefined
// 66B89C: using guessed type void *;

//----- (0050E5F0) --------------------------------------------------------
void __fastcall CTaskComplexMoveBackAndJump::~CTaskComplexMoveBackAndJump(CTaskComplexMoveBackAndJump *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 50E5FC: variable 'v1' is possibly undefined

//----- (0050E600) --------------------------------------------------------
CTask *__fastcall CTaskComplexMoveBackAndJump::CreateNextSubTask(CTaskComplexMoveBackAndJump *this, CPed *pPed)
{
  CTask *result; // r0
  CTaskComplexJump *v3; // r0

  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 411 )
    return 0;
  v3 = (CTaskComplexJump *)CTask::operator new(0x14u);
  CTaskComplexJump::CTaskComplexJump(v3, 0);
  return result;
}

//----- (0050E628) --------------------------------------------------------
CTask *__fastcall CTaskComplexMoveBackAndJump::CreateSubTask(
        const CTaskComplexMoveBackAndJump *this,
        const int iSubTaskType)
{
  CTaskComplexJump *v2; // r4
  CTaskSimpleRunAnim *v3; // r0
  CTaskComplexJump *v4; // r0

  v2 = 0;
  if ( iSubTaskType == 411 )
  {
    v3 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
    CTaskSimpleRunAnim::CTaskSimpleRunAnim(v3, ANIM_STD_PED, ANIM_STD_HIT_WALL, 4.0, 411, "HitWall", 0);
    v2 = v4;
    v4->_vptr$CTask = (int (**)(void))&off_668808;
  }
  else if ( iSubTaskType == 211 )
  {
    v2 = (CTaskComplexJump *)CTask::operator new(0x14u);
    CTaskComplexJump::CTaskComplexJump(v2, 0);
  }
  return v2;
}
// 50E66A: variable 'v4' is possibly undefined
// 668808: using guessed type void *off_668808;
// 6796E4: using guessed type void *`vtable for'CTaskSimpleHitWall;

//----- (0050E684) --------------------------------------------------------
CTask *__fastcall CTaskComplexMoveBackAndJump::CreateFirstSubTask(CTaskComplexMoveBackAndJump *this, CPed *pPed)
{
  CTaskSimpleRunAnim *v2; // r0
  CTask *result; // r0

  v2 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
  CTaskSimpleRunAnim::CTaskSimpleRunAnim(v2, ANIM_STD_PED, ANIM_STD_HIT_WALL, 4.0, 411, "HitWall", 0);
  result->_vptr$CTask = (int (**)(void))&off_668808;
  return result;
}
// 50E6B4: variable 'result' is possibly undefined
// 668808: using guessed type void *off_668808;
// 6796E4: using guessed type void *`vtable for'CTaskSimpleHitWall;

//----- (0050E6C4) --------------------------------------------------------
CTask *__fastcall CTaskComplexMoveBackAndJump::ControlSubTask(CTaskComplexMoveBackAndJump *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (0050E6C8) --------------------------------------------------------
void __fastcall CTaskComplexEvasiveCower::CTaskComplexEvasiveCower(
        CTaskComplexEvasiveCower *this,
        CEntity *pTargetEntity,
        const CVector *vMoveDir)
{
  __int64 v6; // d16
  RwReal z; // r0

  CTaskComplex::CTaskComplex(this);
  this->_vptr$CTask = (int (**)(void))&off_66B8D8;
  v6 = *(_QWORD *)&vMoveDir->x;
  z = vMoveDir->z;
  this->m_pTargetEntity = pTargetEntity;
  this->m_vMoveDir.z = z;
  *(_QWORD *)&this->m_vMoveDir.x = v6;
  if ( pTargetEntity )
    CEntity::RegisterReference(pTargetEntity, &this->m_pTargetEntity);
}
// 66B8D8: using guessed type void *off_66B8D8;

//----- (0050E710) --------------------------------------------------------
void __fastcall CTaskComplexEvasiveCower::~CTaskComplexEvasiveCower(CTaskComplexEvasiveCower *this)
{
  CEntity *m_pTargetEntity; // r0
  CEntity **p_m_pTargetEntity; // r1

  p_m_pTargetEntity = &this->m_pTargetEntity;
  m_pTargetEntity = this->m_pTargetEntity;
  this->_vptr$CTask = (int (**)(void))&off_66B8D8;
  if ( m_pTargetEntity )
    CEntity::CleanUpOldReference(m_pTargetEntity, p_m_pTargetEntity);
  sub_18EDB4(this);
}
// 66B8D8: using guessed type void *;

//----- (0050E73C) --------------------------------------------------------
void __fastcall CTaskComplexEvasiveCower::~CTaskComplexEvasiveCower(CTaskComplexEvasiveCower *this)
{
  CEntity *m_pTargetEntity; // r0
  CEntity **p_m_pTargetEntity; // r1
  void *v4; // r0

  p_m_pTargetEntity = &this->m_pTargetEntity;
  m_pTargetEntity = this->m_pTargetEntity;
  this->_vptr$CTask = (int (**)(void))&off_66B8D8;
  if ( m_pTargetEntity )
    CEntity::CleanUpOldReference(m_pTargetEntity, p_m_pTargetEntity);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 50E764: variable 'v4' is possibly undefined
// 66B8D8: using guessed type void *off_66B8D8;

//----- (0050E76C) --------------------------------------------------------
float __fastcall CTaskComplexEvasiveCower::ComputeTargetHeading(const CTaskComplexEvasiveCower *this)
{
  return sub_1991B4(
           COERCE_FLOAT(LODWORD(this->m_vMoveDir.x) ^ 0x80000000),
           COERCE_FLOAT((*(_QWORD *)&this->m_vMoveDir.x ^ 0x8000000080000000LL) >> 32),
           0.0,
           0.0);
}

//----- (0050E780) --------------------------------------------------------
CTask *__fastcall CTaskComplexEvasiveCower::CreateSubTask(const CTaskComplexEvasiveCower *this, const int iSubTaskType)
{
  CTaskSimpleAchieveHeading *v3; // r4
  float RadianAngleBetweenPoints; // r0
  CTaskSimpleRunAnim *v5; // r0
  CTaskSimpleAchieveHeading *v6; // r0

  v3 = 0;
  if ( iSubTaskType == 412 )
  {
    v5 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
    CTaskSimpleRunAnim::CTaskSimpleRunAnim(v5, ANIM_STD_PED, ANIM_STD_HANDSCOWER, 4.0, 412, "Cower", 0);
    v3 = v6;
    v6->_vptr$CTask = (int (**)(void))&off_6657B8;
  }
  else if ( iSubTaskType == 902 )
  {
    v3 = (CTaskSimpleAchieveHeading *)CTask::operator new(0x18u);
    RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                                 COERCE_FLOAT(LODWORD(this->m_vMoveDir.x) ^ 0x80000000),
                                 COERCE_FLOAT((*(_QWORD *)&this->m_vMoveDir.x ^ 0x8000000080000000LL) >> 32),
                                 0.0,
                                 0.0);
    CTaskSimpleAchieveHeading::CTaskSimpleAchieveHeading(v3, RadianAngleBetweenPoints, 2.0, 0.2);
  }
  return v3;
}
// 50E7EC: variable 'v6' is possibly undefined
// 6657B8: using guessed type void *off_6657B8;
// 676378: using guessed type void *`vtable for'CTaskSimpleCower;

//----- (0050E808) --------------------------------------------------------
CTask *__fastcall CTaskComplexEvasiveCower::CreateNextSubTask(CTaskComplexEvasiveCower *this, CPed *pPed)
{
  int v3; // r0
  int v5; // r1

  v3 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v3 == 412 )
  {
    v5 = 1302;
  }
  else
  {
    if ( v3 != 902 )
      return 0;
    v5 = 412;
  }
  return CTaskComplexEvasiveCower::CreateSubTask(this, v5);
}

//----- (0050E83C) --------------------------------------------------------
CTask *__fastcall CTaskComplexEvasiveCower::CreateFirstSubTask(CTaskComplexEvasiveCower *this, CPed *pPed)
{
  CTaskSimpleAchieveHeading *v3; // r5
  float RadianAngleBetweenPoints; // r1
  CTask *result; // r0

  v3 = (CTaskSimpleAchieveHeading *)CTask::operator new(0x18u);
  RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                               COERCE_FLOAT(LODWORD(this->m_vMoveDir.x) ^ 0x80000000),
                               COERCE_FLOAT((*(_QWORD *)&this->m_vMoveDir.x ^ 0x8000000080000000LL) >> 32),
                               0.0,
                               0.0);
  sub_19DE08(v3, RadianAngleBetweenPoints, 2.0, 0.2);
  return result;
}

//----- (0050E87C) --------------------------------------------------------
CTask *__fastcall CTaskComplexEvasiveCower::ControlSubTask(CTaskComplexEvasiveCower *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (0050E880) --------------------------------------------------------
CTask *__fastcall CTaskComplexDiveFromAttachedEntityAndGetUp::CreateNextSubTask(
        CTaskComplexDiveFromAttachedEntityAndGetUp *this,
        CPed *pPed)
{
  int v4; // r0
  int v5; // r1
  float v7; // r0

  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplexEvasiveDiveAndGetUp::CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 902 )
    CPed::DettachPedFromEntity(pPed);
  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplexEvasiveDiveAndGetUp::CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v4 > 502 )
  {
    if ( v4 == 503 )
    {
      v5 = 202;
      return CTaskComplexEvasiveDiveAndGetUp::CreateSubTask(this, v5);
    }
    if ( v4 == 902 )
    {
      v5 = 503;
      return CTaskComplexEvasiveDiveAndGetUp::CreateSubTask(this, v5);
    }
    return 0;
  }
  if ( v4 == 202 )
  {
    v7 = CGeneral::LimitRadianAngle(pPed->m_fCurrentHeading);
    v5 = 205;
    pPed->m_fCurrentHeading = v7 + -1.5708;
    pPed->m_fDesiredHeading = v7 + -1.5708;
    return CTaskComplexEvasiveDiveAndGetUp::CreateSubTask(this, v5);
  }
  if ( v4 != 205 )
    return 0;
  v5 = 1302;
  return CTaskComplexEvasiveDiveAndGetUp::CreateSubTask(this, v5);
}

//----- (0050E90C) --------------------------------------------------------
CTask *__fastcall CTaskComplexDiveFromAttachedEntityAndGetUp::CreateFirstSubTask(
        CTaskComplexDiveFromAttachedEntityAndGetUp *this,
        CPed *pPed)
{
  CEntity *m_pAttachToEntity; // r1
  int v5; // r6
  CEntity *v6; // r1
  CVector *v7; // r0
  __int64 v8; // d16
  bool v9; // zf
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r6
  CSimpleTransform *p_tx; // r2
  CMatrix *v13; // r0
  double v14; // d16
  int v15; // r0
  CMatrix *v16; // r0
  __int64 v17; // d16
  int v18; // r1
  float v20[4]; // [sp+0h] [bp-80h] BYREF
  CVector out_normals; // [sp+10h] [bp-70h] BYREF
  float v22; // [sp+1Ch] [bp-64h]
  float v23; // [sp+20h] [bp-60h]
  float v24; // [sp+24h] [bp-5Ch]
  float v25; // [sp+34h] [bp-4Ch]
  float v26; // [sp+38h] [bp-48h]
  float v27; // [sp+3Ch] [bp-44h]
  CVector dirs; // [sp+40h] [bp-40h] BYREF
  double v29; // [sp+4Ch] [bp-34h]
  int v30; // [sp+54h] [bp-2Ch]
  double v31; // [sp+64h] [bp-1Ch]
  int v32; // [sp+6Ch] [bp-14h]

  m_pAttachToEntity = pPed->m_pAttachToEntity;
  if ( m_pAttachToEntity )
  {
    v5 = CPedGeometryAnalyser::ComputeEntityHitSide(pPed, m_pAttachToEntity);
    CPedGeometryAnalyser::ComputeEntityDirs(pPed->m_pAttachToEntity, &dirs);
    v7 = &dirs + v5;
    v8 = *(_QWORD *)&v7->x;
    this->m_vDiveDir.z = v7->z;
    *(_QWORD *)&this->m_vDiveDir.x = v8;
    v9 = (v5 | 2) == 2;
    if ( (v5 | 2) == 2 )
    {
      v6 = pPed->m_pAttachToEntity;
      v9 = (*(_BYTE *)&v6->m_info & 7) == 2;
    }
    if ( v9
      && (float)((float)((float)(v6[1].m_transform.m_translate.z * this->m_vDiveDir.x)
                       + (float)(v6[1].m_transform.m_heading * this->m_vDiveDir.y))
               + (float)(*(float *)&v6[1].m_pMat * this->m_vDiveDir.z)) > 0.0 )
    {
      m_pMat = pPed->m_pMat;
      p_m_transform = &pPed->m_transform;
      p_tx = &pPed->m_transform;
      if ( m_pMat )
        p_tx = (CSimpleTransform *)&m_pMat->tx;
      CPedGeometryAnalyser::ComputeEntityBoundingBoxPlanes(p_tx->m_translate.z, v6, &out_normals, v20);
      v13 = pPed->m_pMat;
      if ( v13 )
        p_m_transform = (CSimpleTransform *)&v13->tx;
      if ( fabsf(
             v20[1]
           + (float)((float)((float)(v22 * p_m_transform->m_translate.x) + (float)(v23 * p_m_transform->m_translate.y))
                   + (float)(v24 * p_m_transform->m_translate.z))) >= fabsf(
                                                                        v20[3]
                                                                      + (float)((float)((float)(p_m_transform->m_translate.x
                                                                                              * v25)
                                                                                      + (float)(p_m_transform->m_translate.y
                                                                                              * v26))
                                                                              + (float)(p_m_transform->m_translate.z
                                                                                      * v27))) )
      {
        v15 = v32;
        v14 = v31;
      }
      else
      {
        v14 = v29;
        v15 = v30;
      }
      LODWORD(this->m_vDiveDir.z) = v15;
      *(double *)&this->m_vDiveDir.x = v14;
    }
  }
  else
  {
    v16 = pPed->m_pMat;
    v17 = *(_QWORD *)&v16->xy;
    this->m_vDiveDir.z = v16->zy;
    *(_QWORD *)&this->m_vDiveDir.x = v17;
  }
  v18 = 902;
  if ( pPed->m_pAttachToEntity )
    pPed->m_fAttachHeadingLimit = 6.2832;
  if ( !this->m_bAchieveHeadingFirst )
    v18 = 503;
  return CTaskComplexEvasiveDiveAndGetUp::CreateSubTask(this, v18);
}
// 50E96A: variable 'v6' is possibly undefined

//----- (0050EA88) --------------------------------------------------------
CTask *__fastcall CTaskComplexDiveFromAttachedEntityAndGetUp::ControlSubTask(
        CTaskComplexDiveFromAttachedEntityAndGetUp *this,
        CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (0050EA8C) --------------------------------------------------------
void __fastcall CTaskComplexWalkRoundFire::CTaskComplexWalkRoundFire(
        CTaskComplexWalkRoundFire *this,
        const int iMoveState,
        const CVector *vFirePos,
        const float fFireRadius,
        const CVector *vTarget)
{
  int v8; // r0
  __int64 v9; // d16
  __int64 v10; // d16

  CTaskComplex::CTaskComplex(this);
  *(_DWORD *)(v8 + 12) = iMoveState;
  *(_DWORD *)v8 = &off_66B914;
  v9 = *(_QWORD *)&vFirePos->x;
  *(RwReal *)(v8 + 24) = vFirePos->z;
  *(const float *)(v8 + 28) = fFireRadius;
  *(_QWORD *)(v8 + 16) = v9;
  v10 = *(_QWORD *)&vTarget->x;
  *(RwReal *)(v8 + 40) = vTarget->z;
  *(_QWORD *)(v8 + 32) = v10;
}
// 50EAA0: variable 'v8' is possibly undefined
// 66B914: using guessed type void *;

//----- (0050EAD4) --------------------------------------------------------
void __fastcall CTaskComplexWalkRoundFire::~CTaskComplexWalkRoundFire(CTaskComplexWalkRoundFire *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 50EAE0: variable 'v1' is possibly undefined

//----- (0050EAE4) --------------------------------------------------------
CTask *__fastcall CTaskComplexWalkRoundFire::CreateNextSubTask(CTaskComplexWalkRoundFire *this, CPed *pPed)
{
  return 0;
}

//----- (0050EAE8) --------------------------------------------------------
CTask *__fastcall CTaskComplexWalkRoundFire::CreateFirstSubTask(CTaskComplexWalkRoundFire *this, CPed *pPed)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  __int64 v6; // d16
  CTaskSimpleGoToPoint *v7; // r0
  CTask *result; // r0
  CVector v9; // [sp+Ch] [bp-44h] BYREF
  CVector vNewTarget; // [sp+18h] [bp-38h] BYREF
  CColSphere v11; // [sp+24h] [bp-2Ch] BYREF

  m_pMat = pPed->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  v6 = *(_QWORD *)&p_tx->m_translate.x;
  this->m_vStartPos.z = p_tx->m_translate.z;
  *(_QWORD *)&this->m_vStartPos.x = v6;
  CColSphere::Set(&v11, this->m_fFireRadius, &this->m_vFirePos, 0, 0, 0xFFu);
  CPedGeometryAnalyser::ComputeRouteRoundSphere(pPed, &v11, &this->m_vStartPos, &this->m_vTarget, &vNewTarget, &v9);
  v7 = (CTaskSimpleGoToPoint *)CTask::operator new(0x2Cu);
  CTaskSimpleGoToPoint::CTaskSimpleGoToPoint(v7, this->m_iMoveState, &v9, 0.5, 0, 0);
  return result;
}

//----- (0050EB68) --------------------------------------------------------
void __fastcall CTaskComplexWalkRoundFire::ComputeDetourTarget(
        CTaskComplexWalkRoundFire *this,
        const CPed *ped,
        CVector *vDetourTarget)
{
  CVector vNewTarget; // [sp+8h] [bp-30h] BYREF
  CColSphere v7; // [sp+14h] [bp-24h] BYREF

  CColSphere::Set(&v7, this->m_fFireRadius, &this->m_vFirePos, 0, 0, 0xFFu);
  CPedGeometryAnalyser::ComputeRouteRoundSphere(
    ped,
    &v7,
    &this->m_vStartPos,
    &this->m_vTarget,
    &vNewTarget,
    vDetourTarget);
}

//----- (0050EBB0) --------------------------------------------------------
CTask *__fastcall CTaskComplexWalkRoundFire::ControlSubTask(CTaskComplexWalkRoundFire *this, CPed *pPed)
{
  CTask *result; // r0
  char m_pParent; // r2
  __int64 v6; // d16
  CVector v7; // [sp+8h] [bp-40h] BYREF
  CVector vNewTarget; // [sp+18h] [bp-30h] BYREF
  CColSphere v9; // [sp+24h] [bp-24h] BYREF

  CColSphere::Set(&v9, this->m_fFireRadius, &this->m_vFirePos, 0, 0, 0xFFu);
  CPedGeometryAnalyser::ComputeRouteRoundSphere(pPed, &v9, &this->m_vStartPos, &this->m_vTarget, &vNewTarget, &v7);
  result = this->m_pSubTask;
  if ( *(float *)&result[1].m_pParent != v7.x
    || *(float *)&result[2]._vptr$CTask != v7.y
    || *(float *)&result[2].m_pParent != v7.z
    || *(float *)&result[3]._vptr$CTask != 0.5 )
  {
    m_pParent = (char)result[3].m_pParent;
    v6 = *(_QWORD *)&v7.x;
    result[2].m_pParent = (CTask *)LODWORD(v7.z);
    result[3]._vptr$CTask = (int (**)(void))1056964608;
    *(_QWORD *)&result[1].m_pParent = v6;
    LOBYTE(result[3].m_pParent) = m_pParent & 0xD0 | 0x20;
    return this->m_pSubTask;
  }
  return result;
}

//----- (0050EC68) --------------------------------------------------------
void __fastcall CTaskComplexEvasiveDiveAndGetUp::~CTaskComplexEvasiveDiveAndGetUp(
        CTaskComplexEvasiveDiveAndGetUp *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B708;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  sub_18EDB4(this);
}
// 66B708: using guessed type void *off_66B708;

//----- (0050EC94) --------------------------------------------------------
void __fastcall CTaskComplexDiveFromAttachedEntityAndGetUp::~CTaskComplexDiveFromAttachedEntityAndGetUp(
        CTaskComplexDiveFromAttachedEntityAndGetUp *this)
{
  CVehicle *m_pTargetVehicle; // r0
  CEntity **p_m_pTargetVehicle; // r1
  void *v4; // r0

  p_m_pTargetVehicle = &this->m_pTargetVehicle;
  m_pTargetVehicle = this->m_pTargetVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66B708;
  if ( m_pTargetVehicle )
    CEntity::CleanUpOldReference(m_pTargetVehicle, p_m_pTargetVehicle);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 50ECBC: variable 'v4' is possibly undefined
// 66B708: using guessed type void *off_66B708;

//----- (0050ECC4) --------------------------------------------------------
CTask *__fastcall CTaskComplexDiveFromAttachedEntityAndGetUp::Clone(
        const CTaskComplexDiveFromAttachedEntityAndGetUp *this)
{
  CTaskComplex *v2; // r0
  int (**m_iUnconsciousTime)(void); // r4
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x24u);
  m_iUnconsciousTime = (int (**)(void))this->m_iUnconsciousTime;
  CTaskComplex::CTaskComplex(v2);
  result[1].m_pParent = 0;
  result[2]._vptr$CTask = m_iUnconsciousTime;
  result[2].m_pParent = 0;
  result[3]._vptr$CTask = 0;
  result[3].m_pParent = 0;
  LOBYTE(result[4]._vptr$CTask) = 1;
  result->_vptr$CTask = (int (**)(void))&off_66B950;
  return result;
}
// 50ECDA: variable 'result' is possibly undefined
// 66B950: using guessed type void *off_66B950;
// 675F04: using guessed type void *`vtable for'CTaskComplexDiveFromAttachedEntityAndGetUp;

//----- (0050ECF8) --------------------------------------------------------
int __fastcall CTaskComplexDiveFromAttachedEntityAndGetUp::GetTaskType(
        const CTaskComplexDiveFromAttachedEntityAndGetUp *this)
{
  return 513;
}

//----- (0050ED00) --------------------------------------------------------
void __fastcall CTaskComplexDiveFromAttachedEntityAndGetUp::Serialize(CTaskComplexDiveFromAttachedEntityAndGetUp *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  int v5; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexDiveFromAttachedEntityAndGetUp *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexDiveFromAttachedEntityAndGetUp *))this->_vptr$CTask + 5))(this) == 513 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(4u);
    *v4 = this->m_iUnconsciousTime;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    j_free(v4);
  }
  else
  {
    v5 = (*((int (__fastcall **)(CTaskComplexDiveFromAttachedEntityAndGetUp *))this->_vptr$CTask + 5))(this);
    sub_1941C4(513, v5);
  }
}

//----- (0050EDA0) --------------------------------------------------------
CTask *__fastcall CTaskSimpleHitHead::Clone(const CTaskSimpleHitHead *this)
{
  CTaskSimple *v1; // r0
  CTask *result; // r0

  v1 = (CTaskSimple *)CTask::operator new(0x10u);
  CTaskSimple::CTaskSimple(v1);
  LOBYTE(result[1]._vptr$CTask) = 0;
  result[1].m_pParent = 0;
  result->_vptr$CTask = (int (**)(void))&off_66B630;
  return result;
}
// 50EDB2: variable 'result' is possibly undefined
// 66B630: using guessed type void *off_66B630;

//----- (0050EDC4) --------------------------------------------------------
int __fastcall CTaskSimpleHitHead::GetTaskType(const CTaskSimpleHitHead *this)
{
  return 500;
}

//----- (0050EDCC) --------------------------------------------------------
void __fastcall CTaskSimpleHitHead::Serialize(CTaskSimpleHitHead *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskSimpleHitHead *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleHitHead *))this->_vptr$CTask + 5))(this) != 500 )
  {
    v4 = (*((int (__fastcall **)(CTaskSimpleHitHead *))this->_vptr$CTask + 5))(this);
    sub_1941C4(500, v4);
  }
}

//----- (0050EE38) --------------------------------------------------------
CTask *__fastcall CTaskSimpleEvasiveStep::Clone(const CTaskSimpleEvasiveStep *this)
{
  void *v2; // r4
  CEntity *m_pTargetEntity; // r5

  v2 = CTask::operator new(0x14u);
  m_pTargetEntity = this->m_pTargetEntity;
  CTaskSimple::CTaskSimple((CTaskSimple *)v2);
  *((_BYTE *)v2 + 12) = 0;
  *((_DWORD *)v2 + 4) = 0;
  *(_DWORD *)v2 = &off_66B664;
  *((_DWORD *)v2 + 2) = m_pTargetEntity;
  if ( m_pTargetEntity )
    CEntity::RegisterReference(m_pTargetEntity, (CEntity **)v2 + 2);
  return (CTask *)v2;
}
// 66B664: using guessed type void *off_66B664;

//----- (0050EE78) --------------------------------------------------------
int __fastcall CTaskSimpleEvasiveStep::GetTaskType(const CTaskSimpleEvasiveStep *this)
{
  return 501;
}

//----- (0050EE80) --------------------------------------------------------
void __fastcall CTaskSimpleEvasiveStep::Serialize(CTaskSimpleEvasiveStep *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CEntity *m_pTargetEntity; // r0
  int v5; // r6
  _DWORD *v6; // r5
  CEntity *v7; // r0
  int v8; // r1
  int v9; // r4
  int v10; // r0
  _DWORD *v11; // r4
  _DWORD *v12; // r5

  v2 = (*((int (__fastcall **)(CTaskSimpleEvasiveStep *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleEvasiveStep *))this->_vptr$CTask + 5))(this) == 501 )
  {
    m_pTargetEntity = this->m_pTargetEntity;
    if ( m_pTargetEntity )
    {
      v5 = *(_BYTE *)&m_pTargetEntity->m_info & 7;
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      free(v6);
      v7 = this->m_pTargetEntity;
      v8 = *(_BYTE *)&v7->m_info & 7;
      switch ( v8 )
      {
        case 2:
          v9 = GettPoolVehicleRef((CVehicle *)v7);
          break;
        case 4:
          v9 = GettPoolObjRef((CObject *)v7);
          break;
        case 3:
          v9 = GettPoolPedRef((CPed *)v7);
          break;
        default:
          return;
      }
      if ( UseDataFence )
        AddDataFence();
      v12 = malloc(4u);
      *v12 = v9;
      CGenericGameStorage::_SaveDataToWorkBuffer(v12, 4);
      j_free(v12);
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v11 = malloc(4u);
      *v11 = 0;
      CGenericGameStorage::_SaveDataToWorkBuffer(v11, 4);
      j_free(v11);
    }
  }
  else
  {
    v10 = (*((int (__fastcall **)(CTaskSimpleEvasiveStep *))this->_vptr$CTask + 5))(this);
    sub_1941C4(501, v10);
  }
}

//----- (0050EFC0) --------------------------------------------------------
CTask *__fastcall CTaskComplexEvasiveStep::Clone(const CTaskComplexEvasiveStep *this)
{
  char *v2; // r4
  CEntity *m_pTargetEntity; // r5
  __int64 v4; // d16

  v2 = (char *)CTask::operator new(0x1Cu);
  m_pTargetEntity = this->m_pTargetEntity;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *(_DWORD *)v2 = &off_66B698;
  v4 = *(_QWORD *)&this->m_vMoveDir.x;
  *((_DWORD *)v2 + 5) = LODWORD(this->m_vMoveDir.z);
  *(_QWORD *)(v2 + 12) = v4;
  *((_DWORD *)v2 + 6) = m_pTargetEntity;
  if ( m_pTargetEntity )
    CEntity::RegisterReference(m_pTargetEntity, (CEntity **)v2 + 6);
  return (CTask *)v2;
}
// 66B698: using guessed type void *off_66B698;

//----- (0050F00C) --------------------------------------------------------
int __fastcall CTaskComplexEvasiveStep::GetTaskType(const CTaskComplexEvasiveStep *this)
{
  return 502;
}

//----- (0050F014) --------------------------------------------------------
void __fastcall CTaskComplexEvasiveStep::Serialize(CTaskComplexEvasiveStep *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CEntity *m_pTargetEntity; // r0
  int v5; // r6
  _DWORD *v6; // r5
  CEntity *v7; // r0
  int v8; // r1
  int v9; // r5
  int v10; // r0
  _DWORD *v11; // r5
  void *v12; // r0
  _DWORD *v13; // r6
  _DWORD *v14; // r5
  __int64 v15; // d16

  v2 = (*((int (__fastcall **)(CTaskComplexEvasiveStep *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexEvasiveStep *))this->_vptr$CTask + 5))(this) != 502 )
  {
    v10 = (*((int (__fastcall **)(CTaskComplexEvasiveStep *))this->_vptr$CTask + 5))(this);
    sub_1941C4(502, v10);
    return;
  }
  m_pTargetEntity = this->m_pTargetEntity;
  if ( !m_pTargetEntity )
  {
    if ( UseDataFence )
      AddDataFence();
    v11 = malloc(4u);
    *v11 = 0;
    CGenericGameStorage::_SaveDataToWorkBuffer(v11, 4);
    v12 = v11;
    goto LABEL_20;
  }
  v5 = *(_BYTE *)&m_pTargetEntity->m_info & 7;
  if ( UseDataFence )
    AddDataFence();
  v6 = malloc(4u);
  *v6 = v5;
  CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
  free(v6);
  v7 = this->m_pTargetEntity;
  v8 = *(_BYTE *)&v7->m_info & 7;
  switch ( v8 )
  {
    case 2:
      v9 = GettPoolVehicleRef((CVehicle *)v7);
      goto LABEL_17;
    case 4:
      v9 = GettPoolObjRef((CObject *)v7);
      goto LABEL_17;
    case 3:
      v9 = GettPoolPedRef((CPed *)v7);
LABEL_17:
      if ( UseDataFence )
        AddDataFence();
      v13 = malloc(4u);
      *v13 = v9;
      CGenericGameStorage::_SaveDataToWorkBuffer(v13, 4);
      v12 = v13;
LABEL_20:
      free(v12);
      break;
  }
  if ( UseDataFence )
    AddDataFence();
  v14 = malloc(0xCu);
  v15 = *(_QWORD *)&this->m_vMoveDir.x;
  v14[2] = LODWORD(this->m_vMoveDir.z);
  *(_QWORD *)v14 = v15;
  CGenericGameStorage::_SaveDataToWorkBuffer(v14, 12);
  j_free(v14);
}

//----- (0050F184) --------------------------------------------------------
CTask *__fastcall CTaskSimpleEvasiveDive::Clone(const CTaskSimpleEvasiveDive *this)
{
  void *v2; // r4
  CVehicle *m_pTargetVehicle; // r5

  v2 = CTask::operator new(0x14u);
  m_pTargetVehicle = this->m_pTargetVehicle;
  CTaskSimple::CTaskSimple((CTaskSimple *)v2);
  *((_BYTE *)v2 + 12) = 0;
  *((_DWORD *)v2 + 4) = 0;
  *(_DWORD *)v2 = &off_66B6D4;
  *((_DWORD *)v2 + 2) = m_pTargetVehicle;
  if ( m_pTargetVehicle )
    CEntity::RegisterReference(m_pTargetVehicle, (CEntity **)v2 + 2);
  return (CTask *)v2;
}
// 66B6D4: using guessed type void *off_66B6D4;

//----- (0050F1C4) --------------------------------------------------------
int __fastcall CTaskSimpleEvasiveDive::GetTaskType(const CTaskSimpleEvasiveDive *this)
{
  return 503;
}

//----- (0050F1CC) --------------------------------------------------------
void __fastcall CTaskSimpleEvasiveDive::Serialize(CTaskSimpleEvasiveDive *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CVehicle *m_pTargetVehicle; // r0
  int v5; // r4
  _DWORD *v6; // r5
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r4

  v2 = (*((int (__fastcall **)(CTaskSimpleEvasiveDive *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleEvasiveDive *))this->_vptr$CTask + 5))(this) == 503 )
  {
    m_pTargetVehicle = this->m_pTargetVehicle;
    if ( m_pTargetVehicle )
    {
      v5 = GettPoolVehicleRef(m_pTargetVehicle);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    j_free(v7);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskSimpleEvasiveDive *))this->_vptr$CTask + 5))(this);
    sub_1941C4(503, v8);
  }
}

//----- (0050F2A0) --------------------------------------------------------
CTask *__fastcall CTaskComplexEvasiveDiveAndGetUp::Clone(const CTaskComplexEvasiveDiveAndGetUp *this)
{
  CTaskComplex *v2; // r0
  __int64 v3; // kr00_8
  CTaskComplex *v4; // r4
  bool m_bAchieveHeadingFirst; // r9
  __int64 v6; // d16

  v2 = (CTaskComplex *)CTask::operator new(0x24u);
  v3 = *(_QWORD *)&this->m_pTargetVehicle;
  v4 = v2;
  m_bAchieveHeadingFirst = this->m_bAchieveHeadingFirst;
  CTaskComplex::CTaskComplex(v2);
  v4[1].m_pParent = (CTask *)HIDWORD(v3);
  v4->_vptr$CTask = (int (**)(void))&off_66B708;
  v4[1]._vptr$CTask = (int (**)(void))v3;
  v6 = *(_QWORD *)&this->m_vDiveDir.x;
  v4[2].m_pParent = (CTask *)LODWORD(this->m_vDiveDir.z);
  LOBYTE(v4[2].m_pSubTask) = m_bAchieveHeadingFirst;
  *(_QWORD *)&v4[1].m_pSubTask = v6;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)&v4[1]);
  return v4;
}
// 66B708: using guessed type void *off_66B708;

//----- (0050F2FC) --------------------------------------------------------
int __fastcall CTaskComplexEvasiveDiveAndGetUp::GetTaskType(const CTaskComplexEvasiveDiveAndGetUp *this)
{
  return 504;
}

//----- (0050F304) --------------------------------------------------------
void __fastcall CTaskComplexEvasiveDiveAndGetUp::Serialize(CTaskComplexEvasiveDiveAndGetUp *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CVehicle *m_pTargetVehicle; // r0
  int v5; // r5
  _DWORD *v6; // r6
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r5
  _DWORD *v10; // r5
  _DWORD *v11; // r5
  __int64 v12; // d16

  v2 = (*((int (__fastcall **)(CTaskComplexEvasiveDiveAndGetUp *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexEvasiveDiveAndGetUp *))this->_vptr$CTask + 5))(this) == 504 )
  {
    m_pTargetVehicle = this->m_pTargetVehicle;
    if ( m_pTargetVehicle )
    {
      v5 = GettPoolVehicleRef(m_pTargetVehicle);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    free(v7);
    if ( UseDataFence )
      AddDataFence();
    v10 = malloc(4u);
    *v10 = this->m_iUnconsciousTime;
    CGenericGameStorage::_SaveDataToWorkBuffer(v10, 4);
    free(v10);
    if ( UseDataFence )
      AddDataFence();
    v11 = malloc(0xCu);
    v12 = *(_QWORD *)&this->m_vDiveDir.x;
    v11[2] = LODWORD(this->m_vDiveDir.z);
    *(_QWORD *)v11 = v12;
    CGenericGameStorage::_SaveDataToWorkBuffer(v11, 12);
    free(v11);
    if ( UseDataFence )
      AddDataFence();
    sub_19E9A8(&this->m_bAchieveHeadingFirst, 1);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexEvasiveDiveAndGetUp *))this->_vptr$CTask + 5))(this);
    sub_1941C4(504, v8);
  }
}

//----- (0050F45C) --------------------------------------------------------
CTask *__fastcall CTaskComplexHitPedWithCar::Clone(const CTaskComplexHitPedWithCar *this)
{
  void *v2; // r4
  __int64 v3; // kr00_8

  v2 = CTask::operator new(0x28u);
  v3 = *(_QWORD *)&this->m_pVehicle;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_DWORD *)v2 + 4) = HIDWORD(v3);
  *((_DWORD *)v2 + 6) = 1000;
  *(_DWORD *)v2 = &off_66B744;
  *((_DWORD *)v2 + 3) = v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)v2 + 3);
  return (CTask *)v2;
}
// 66B744: using guessed type void *off_66B744;

//----- (0050F4A8) --------------------------------------------------------
int __fastcall CTaskComplexHitPedWithCar::GetTaskType(const CTaskComplexHitPedWithCar *this)
{
  return 505;
}

//----- (0050F4B0) --------------------------------------------------------
void __fastcall CTaskComplexHitPedWithCar::Serialize(CTaskComplexHitPedWithCar *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CVehicle *m_pVehicle; // r0
  int v5; // r5
  _DWORD *v6; // r6
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r5
  float *v10; // r5

  v2 = (*((int (__fastcall **)(CTaskComplexHitPedWithCar *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexHitPedWithCar *))this->_vptr$CTask + 5))(this) == 505 )
  {
    m_pVehicle = this->m_pVehicle;
    if ( m_pVehicle )
    {
      v5 = GettPoolVehicleRef(m_pVehicle);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    free(v7);
    if ( UseDataFence )
      AddDataFence();
    v10 = (float *)malloc(4u);
    *v10 = this->m_fImpulseMagnitude;
    CGenericGameStorage::_SaveDataToWorkBuffer(v10, 4);
    j_free(v10);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexHitPedWithCar *))this->_vptr$CTask + 5))(this);
    sub_1941C4(505, v8);
  }
}

//----- (0050F5B0) --------------------------------------------------------
CTask *__fastcall CTaskSimpleKillPedWithCar::Clone(const CTaskSimpleKillPedWithCar *this)
{
  void *v2; // r4
  __int64 v3; // kr00_8

  v2 = CTask::operator new(0x10u);
  v3 = *(_QWORD *)&this->m_pVehicle;
  CTaskSimple::CTaskSimple((CTaskSimple *)v2);
  *((_DWORD *)v2 + 3) = HIDWORD(v3);
  *(_DWORD *)v2 = &off_66B780;
  *((_DWORD *)v2 + 2) = v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)v2 + 2);
  return (CTask *)v2;
}
// 66B780: using guessed type void *off_66B780;
// 678828: using guessed type void *`vtable for'CTaskSimpleKillPedWithCar;

//----- (0050F5F4) --------------------------------------------------------
int __fastcall CTaskSimpleKillPedWithCar::GetTaskType(const CTaskSimpleKillPedWithCar *this)
{
  return 506;
}

//----- (0050F5FA) --------------------------------------------------------
bool __fastcall CTaskSimpleKillPedWithCar::MakeAbortable(
        CTaskSimpleKillPedWithCar *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 0;
}

//----- (0050F600) --------------------------------------------------------
void __fastcall CTaskSimpleKillPedWithCar::Serialize(CTaskSimpleKillPedWithCar *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CVehicle *m_pVehicle; // r0
  int v5; // r5
  _DWORD *v6; // r6
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r5
  float *v10; // r5

  v2 = (*((int (__fastcall **)(CTaskSimpleKillPedWithCar *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleKillPedWithCar *))this->_vptr$CTask + 5))(this) == 506 )
  {
    m_pVehicle = this->m_pVehicle;
    if ( m_pVehicle )
    {
      v5 = GettPoolVehicleRef(m_pVehicle);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    free(v7);
    if ( UseDataFence )
      AddDataFence();
    v10 = (float *)malloc(4u);
    *v10 = this->m_fImpulseMagnitude;
    CGenericGameStorage::_SaveDataToWorkBuffer(v10, 4);
    j_free(v10);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskSimpleKillPedWithCar *))this->_vptr$CTask + 5))(this);
    sub_1941C4(506, v8);
  }
}

//----- (0050F700) --------------------------------------------------------
CTask *__fastcall CTaskSimpleHurtPedWithCar::Clone(const CTaskSimpleHurtPedWithCar *this)
{
  void *v2; // r4
  __int64 v3; // kr00_8

  v2 = CTask::operator new(0x14u);
  v3 = *(_QWORD *)&this->m_pVehicle;
  CTaskSimple::CTaskSimple((CTaskSimple *)v2);
  *((_DWORD *)v2 + 3) = HIDWORD(v3);
  *((_BYTE *)v2 + 16) = 0;
  *(_DWORD *)v2 = &off_66B7B4;
  *((_DWORD *)v2 + 2) = v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)v2 + 2);
  return (CTask *)v2;
}
// 66B7B4: using guessed type void *off_66B7B4;
// 677B3C: using guessed type void *`vtable for'CTaskSimpleHurtPedWithCar;

//----- (0050F748) --------------------------------------------------------
int __fastcall CTaskSimpleHurtPedWithCar::GetTaskType(const CTaskSimpleHurtPedWithCar *this)
{
  return 507;
}

//----- (0050F74E) --------------------------------------------------------
bool __fastcall CTaskSimpleHurtPedWithCar::MakeAbortable(
        CTaskSimpleHurtPedWithCar *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 0;
}

//----- (0050F754) --------------------------------------------------------
void __fastcall CTaskSimpleHurtPedWithCar::Serialize(CTaskSimpleHurtPedWithCar *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CVehicle *m_pVehicle; // r0
  int v5; // r5
  _DWORD *v6; // r6
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r5
  float *v10; // r5

  v2 = (*((int (__fastcall **)(CTaskSimpleHurtPedWithCar *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleHurtPedWithCar *))this->_vptr$CTask + 5))(this) == 507 )
  {
    m_pVehicle = this->m_pVehicle;
    if ( m_pVehicle )
    {
      v5 = GettPoolVehicleRef(m_pVehicle);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    free(v7);
    if ( UseDataFence )
      AddDataFence();
    v10 = (float *)malloc(4u);
    *v10 = this->m_fImpulseMagnitude;
    CGenericGameStorage::_SaveDataToWorkBuffer(v10, 4);
    j_free(v10);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskSimpleHurtPedWithCar *))this->_vptr$CTask + 5))(this);
    sub_1941C4(507, v8);
  }
}

//----- (0050F854) --------------------------------------------------------
CTask *__fastcall CTaskComplexWalkRoundCar::Clone(const CTaskComplexWalkRoundCar *this)
{
  void *v2; // r4
  int8 m_iMoveState; // r8
  char v4; // r9
  char v5; // r10
  CVehicle *m_pVehicle; // r5
  char v7; // r2
  char v8; // r1
  __int64 v9; // d16
  _DWORD *v10; // r0

  v2 = CTask::operator new(0x58u);
  m_iMoveState = this->m_iMoveState;
  v4 = *((_BYTE *)this + 13);
  v5 = *((_BYTE *)this + 14);
  m_pVehicle = this->m_pVehicle;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_BYTE *)v2 + 12) = m_iMoveState;
  v7 = *((_BYTE *)v2 + 14);
  v8 = *((_BYTE *)v2 + 13) & 0xFC;
  *(_DWORD *)v2 = &off_66B7E8;
  *((_BYTE *)v2 + 13) = v4 & 1 | v8;
  *((_BYTE *)v2 + 14) = v5 & 0xF | v7 & 0xF0;
  v9 = *(_QWORD *)&this->m_vTargetPos.x;
  *((_DWORD *)v2 + 6) = LODWORD(this->m_vTargetPos.z);
  *((_DWORD *)v2 + 9) = 0;
  *((_DWORD *)v2 + 10) = 0;
  *((_WORD *)v2 + 22) = 0;
  *((_DWORD *)v2 + 21) = -1;
  *((_QWORD *)v2 + 2) = v9;
  *((_DWORD *)v2 + 7) = m_pVehicle;
  if ( m_pVehicle )
    CEntity::RegisterReference(m_pVehicle, (CEntity **)v2 + 7);
  v10 = CPointRoute::operator new(0x64u);
  *v10 = 0;
  *((_DWORD *)v2 + 8) = v10;
  return (CTask *)v2;
}
// 66B7E8: using guessed type void *off_66B7E8;

//----- (0050F8EC) --------------------------------------------------------
int __fastcall CTaskComplexWalkRoundCar::GetTaskType(const CTaskComplexWalkRoundCar *this)
{
  return 508;
}

//----- (0050F8F4) --------------------------------------------------------
void __fastcall CTaskComplexWalkRoundCar::Serialize(CTaskComplexWalkRoundCar *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r5
  _DWORD *v5; // r6
  _DWORD *v6; // r5
  __int64 v7; // d16
  int v8; // r5
  _DWORD *v9; // r4
  int v10; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexWalkRoundCar *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexWalkRoundCar *))this->_vptr$CTask + 5))(this) == 508 )
  {
    v4 = GettPoolVehicleRef(this->m_pVehicle);
    if ( UseDataFence )
      AddDataFence();
    v5 = malloc(4u);
    *v5 = v4;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 4);
    free(v5);
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(&this->m_iMoveState, 1);
    if ( UseDataFence )
      AddDataFence();
    v6 = malloc(0xCu);
    v7 = *(_QWORD *)&this->m_vTargetPos.x;
    v6[2] = LODWORD(this->m_vTargetPos.z);
    *(_QWORD *)v6 = v7;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 12);
    free(v6);
    v8 = *((_BYTE *)this + 13) & 1;
    if ( UseDataFence )
      AddDataFence();
    v9 = malloc(4u);
    *v9 = v8;
    CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
    j_free(v9);
  }
  else
  {
    v10 = (*((int (__fastcall **)(CTaskComplexWalkRoundCar *))this->_vptr$CTask + 5))(this);
    sub_1941C4(508, v10);
  }
}

//----- (0050FA1C) --------------------------------------------------------
CTask *__fastcall CTaskComplexWalkRoundBuildingAttempt::Clone(const CTaskComplexWalkRoundBuildingAttempt *this)
{
  char *v2; // r4
  int8 m_iMoveState; // r8
  char v4; // r6
  __int64 v5; // d16
  __int64 v6; // d16
  char v7; // r2
  _DWORD *v8; // r0
  _DWORD *v9; // r0

  v2 = (char *)CTask::operator new(0x4Cu);
  m_iMoveState = this->m_iMoveState;
  v4 = *((_BYTE *)this + 73);
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *(_DWORD *)v2 = &off_66B824;
  v5 = *(_QWORD *)&this->m_vTarget.x;
  *((_DWORD *)v2 + 7) = LODWORD(this->m_vTarget.z);
  *(_QWORD *)(v2 + 20) = v5;
  v6 = *(_QWORD *)&this->m_vPos.x;
  *((_DWORD *)v2 + 10) = LODWORD(this->m_vPos.z);
  *((_QWORD *)v2 + 4) = v6;
  v7 = v2[73];
  *(_QWORD *)(v2 + 44) = *(_QWORD *)&this->m_vNormal.x;
  v2[73] = v4 & 1 | v7 & 0xC0;
  *((_DWORD *)v2 + 14) = 0;
  v2[72] = m_iMoveState;
  v2[74] = 0;
  *((_DWORD *)v2 + 13) = 0;
  CVector::Normalise((CVector *)(v2 + 44));
  v8 = CPointRoute::operator new(0x64u);
  *v8 = 0;
  *((_DWORD *)v2 + 3) = v8;
  v9 = CPointRoute::operator new(0x64u);
  *v9 = 0;
  *((_DWORD *)v2 + 4) = v9;
  return (CTask *)v2;
}
// 66B824: using guessed type void *off_66B824;

//----- (0050FAAC) --------------------------------------------------------
int __fastcall CTaskComplexWalkRoundBuildingAttempt::GetTaskType(const CTaskComplexWalkRoundBuildingAttempt *this)
{
  return 509;
}

//----- (0050FAB4) --------------------------------------------------------
void __fastcall CTaskComplexWalkRoundBuildingAttempt::Serialize(CTaskComplexWalkRoundBuildingAttempt *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CEntity *m_TargetEntity; // r0
  int v5; // r5
  int v6; // r0
  _DWORD *v7; // r6
  _DWORD *v8; // r5
  __int64 v9; // d16
  _DWORD *v10; // r5
  __int64 v11; // d16
  _DWORD *v12; // r5
  __int64 v13; // d16
  _DWORD *v14; // r5
  __int64 v15; // d16
  char pData[17]; // [sp+7h] [bp-11h] BYREF

  v2 = (*((int (__fastcall **)(CTaskComplexWalkRoundBuildingAttempt *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexWalkRoundBuildingAttempt *))this->_vptr$CTask + 5))(this) == 509 )
  {
    m_TargetEntity = this->m_TargetEntity;
    if ( m_TargetEntity && (*(_BYTE *)&m_TargetEntity->m_info & 7) == 3 )
      v5 = GettPoolPedRef((CPed *)m_TargetEntity);
    else
      v5 = -1;
    if ( UseDataFence )
      AddDataFence();
    v7 = malloc(4u);
    *v7 = v5;
    CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
    free(v7);
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(&this->m_iMoveState, 1);
    if ( UseDataFence )
      AddDataFence();
    v8 = malloc(0xCu);
    v9 = *(_QWORD *)&this->m_vTarget.x;
    v8[2] = LODWORD(this->m_vTarget.z);
    *(_QWORD *)v8 = v9;
    CGenericGameStorage::_SaveDataToWorkBuffer(v8, 12);
    free(v8);
    if ( UseDataFence )
      AddDataFence();
    v10 = malloc(0xCu);
    v11 = *(_QWORD *)&this->m_vPos.x;
    v10[2] = LODWORD(this->m_vPos.z);
    *(_QWORD *)v10 = v11;
    CGenericGameStorage::_SaveDataToWorkBuffer(v10, 12);
    free(v10);
    if ( UseDataFence )
      AddDataFence();
    v12 = malloc(0xCu);
    v13 = *(_QWORD *)&this->m_vNormal.x;
    v12[2] = LODWORD(this->m_vNormal.z);
    *(_QWORD *)v12 = v13;
    CGenericGameStorage::_SaveDataToWorkBuffer(v12, 12);
    free(v12);
    if ( UseDataFence )
      AddDataFence();
    v14 = malloc(0xCu);
    v15 = *(_QWORD *)&this->m_OffsetVector.x;
    v14[2] = LODWORD(this->m_OffsetVector.z);
    *(_QWORD *)v14 = v15;
    CGenericGameStorage::_SaveDataToWorkBuffer(v14, 12);
    free(v14);
    pData[0] = *((_BYTE *)this + 73) & 1;
    if ( UseDataFence )
      AddDataFence();
    CGenericGameStorage::_SaveDataToWorkBuffer(pData, 1);
  }
  else
  {
    v6 = (*((int (__fastcall **)(CTaskComplexWalkRoundBuildingAttempt *))this->_vptr$CTask + 5))(this);
    sub_1941C4(509, v6);
  }
}
// 50FAB4: using guessed type char pData[17];

//----- (0050FCA0) --------------------------------------------------------
CTask *__fastcall CTaskComplexWalkRoundObject::Clone(const CTaskComplexWalkRoundObject *this)
{
  void *v2; // r4
  int m_iMoveState; // r8
  CEntity *m_pObject; // r5
  __int64 v5; // d16
  _DWORD *v6; // r0

  v2 = CTask::operator new(0x54u);
  m_iMoveState = this->m_iMoveState;
  m_pObject = this->m_pObject;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_DWORD *)v2 + 3) = m_iMoveState;
  *(_DWORD *)v2 = &off_66B860;
  v5 = *(_QWORD *)&this->m_vTargetPos.x;
  *((_DWORD *)v2 + 6) = LODWORD(this->m_vTargetPos.z);
  *((_DWORD *)v2 + 9) = 0;
  *((_DWORD *)v2 + 10) = 0;
  *((_WORD *)v2 + 22) = 0;
  *((_QWORD *)v2 + 2) = v5;
  *((_DWORD *)v2 + 7) = m_pObject;
  if ( m_pObject )
    CEntity::RegisterReference(m_pObject, (CEntity **)v2 + 7);
  v6 = CPointRoute::operator new(0x64u);
  *v6 = 0;
  *((_DWORD *)v2 + 8) = v6;
  return (CTask *)v2;
}
// 66B860: using guessed type void *off_66B860;

//----- (0050FD08) --------------------------------------------------------
int __fastcall CTaskComplexWalkRoundObject::GetTaskType(const CTaskComplexWalkRoundObject *this)
{
  return 510;
}

//----- (0050FD10) --------------------------------------------------------
void __fastcall CTaskComplexWalkRoundObject::Serialize(CTaskComplexWalkRoundObject *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  _DWORD *v5; // r5
  __int64 v6; // d16
  CEntity *m_pObject; // r0
  int v8; // r6
  _DWORD *v9; // r5
  CEntity *v10; // r0
  int v11; // r1
  int v12; // r4
  int v13; // r0
  _DWORD *v14; // r4
  _DWORD *v15; // r5

  v2 = (*((int (__fastcall **)(CTaskComplexWalkRoundObject *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexWalkRoundObject *))this->_vptr$CTask + 5))(this) == 510 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(4u);
    *v4 = this->m_iMoveState;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    free(v4);
    if ( UseDataFence )
      AddDataFence();
    v5 = malloc(0xCu);
    v6 = *(_QWORD *)&this->m_vTargetPos.x;
    v5[2] = LODWORD(this->m_vTargetPos.z);
    *(_QWORD *)v5 = v6;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 12);
    free(v5);
    m_pObject = this->m_pObject;
    if ( m_pObject )
    {
      v8 = *(_BYTE *)&m_pObject->m_info & 7;
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = v8;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      free(v9);
      v10 = this->m_pObject;
      v11 = *(_BYTE *)&v10->m_info & 7;
      switch ( v11 )
      {
        case 2:
          v12 = GettPoolVehicleRef((CVehicle *)v10);
          break;
        case 4:
          v12 = GettPoolObjRef((CObject *)v10);
          break;
        case 3:
          v12 = GettPoolPedRef((CPed *)v10);
          break;
        default:
          return;
      }
      if ( UseDataFence )
        AddDataFence();
      v15 = malloc(4u);
      *v15 = v12;
      CGenericGameStorage::_SaveDataToWorkBuffer(v15, 4);
      j_free(v15);
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v14 = malloc(4u);
      *v14 = 0;
      CGenericGameStorage::_SaveDataToWorkBuffer(v14, 4);
      j_free(v14);
    }
  }
  else
  {
    v13 = (*((int (__fastcall **)(CTaskComplexWalkRoundObject *))this->_vptr$CTask + 5))(this);
    sub_1941C4(510, v13);
  }
}

//----- (0050FEB4) --------------------------------------------------------
CTask *__fastcall CTaskComplexMoveBackAndJump::Clone(const CTaskComplexMoveBackAndJump *this)
{
  CTaskComplex *v1; // r0
  CTask *result; // r0

  v1 = (CTaskComplex *)CTask::operator new(0xCu);
  CTaskComplex::CTaskComplex(v1);
  result->_vptr$CTask = (int (**)(void))&off_66B89C;
  return result;
}
// 50FECA: variable 'result' is possibly undefined
// 66B89C: using guessed type void *off_66B89C;

//----- (0050FED4) --------------------------------------------------------
int __fastcall CTaskComplexMoveBackAndJump::GetTaskType(const CTaskComplexMoveBackAndJump *this)
{
  return 511;
}

//----- (0050FEDC) --------------------------------------------------------
void __fastcall CTaskComplexMoveBackAndJump::Serialize(CTaskComplexMoveBackAndJump *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexMoveBackAndJump *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexMoveBackAndJump *))this->_vptr$CTask + 5))(this) != 511 )
  {
    v4 = (*((int (__fastcall **)(CTaskComplexMoveBackAndJump *))this->_vptr$CTask + 5))(this);
    sub_1941C4(511, v4);
  }
}

//----- (0050FF4C) --------------------------------------------------------
CTask *__fastcall CTaskComplexEvasiveCower::Clone(const CTaskComplexEvasiveCower *this)
{
  char *v2; // r4
  CEntity *m_pTargetEntity; // r5
  __int64 v4; // d16

  v2 = (char *)CTask::operator new(0x1Cu);
  m_pTargetEntity = this->m_pTargetEntity;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *(_DWORD *)v2 = &off_66B8D8;
  v4 = *(_QWORD *)&this->m_vMoveDir.x;
  *((_DWORD *)v2 + 5) = LODWORD(this->m_vMoveDir.z);
  *(_QWORD *)(v2 + 12) = v4;
  *((_DWORD *)v2 + 6) = m_pTargetEntity;
  if ( m_pTargetEntity )
    CEntity::RegisterReference(m_pTargetEntity, (CEntity **)v2 + 6);
  return (CTask *)v2;
}
// 66B8D8: using guessed type void *off_66B8D8;

//----- (0050FF98) --------------------------------------------------------
int __fastcall CTaskComplexEvasiveCower::GetTaskType(const CTaskComplexEvasiveCower *this)
{
  return 512;
}

//----- (0050FFA0) --------------------------------------------------------
void __fastcall CTaskComplexEvasiveCower::Serialize(CTaskComplexEvasiveCower *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CEntity *m_pTargetEntity; // r0
  int v5; // r6
  _DWORD *v6; // r5
  CEntity *v7; // r0
  int v8; // r1
  int v9; // r5
  int v10; // r0
  _DWORD *v11; // r5
  void *v12; // r0
  _DWORD *v13; // r6
  _DWORD *v14; // r5
  __int64 v15; // d16

  v2 = (*((int (__fastcall **)(CTaskComplexEvasiveCower *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexEvasiveCower *))this->_vptr$CTask + 5))(this) != 512 )
  {
    v10 = (*((int (__fastcall **)(CTaskComplexEvasiveCower *))this->_vptr$CTask + 5))(this);
    sub_1941C4(512, v10);
    return;
  }
  m_pTargetEntity = this->m_pTargetEntity;
  if ( !m_pTargetEntity )
  {
    if ( UseDataFence )
      AddDataFence();
    v11 = malloc(4u);
    *v11 = 0;
    CGenericGameStorage::_SaveDataToWorkBuffer(v11, 4);
    v12 = v11;
    goto LABEL_20;
  }
  v5 = *(_BYTE *)&m_pTargetEntity->m_info & 7;
  if ( UseDataFence )
    AddDataFence();
  v6 = malloc(4u);
  *v6 = v5;
  CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
  free(v6);
  v7 = this->m_pTargetEntity;
  v8 = *(_BYTE *)&v7->m_info & 7;
  switch ( v8 )
  {
    case 2:
      v9 = GettPoolVehicleRef((CVehicle *)v7);
      goto LABEL_17;
    case 4:
      v9 = GettPoolObjRef((CObject *)v7);
      goto LABEL_17;
    case 3:
      v9 = GettPoolPedRef((CPed *)v7);
LABEL_17:
      if ( UseDataFence )
        AddDataFence();
      v13 = malloc(4u);
      *v13 = v9;
      CGenericGameStorage::_SaveDataToWorkBuffer(v13, 4);
      v12 = v13;
LABEL_20:
      free(v12);
      break;
  }
  if ( UseDataFence )
    AddDataFence();
  v14 = malloc(0xCu);
  v15 = *(_QWORD *)&this->m_vMoveDir.x;
  v14[2] = LODWORD(this->m_vMoveDir.z);
  *(_QWORD *)v14 = v15;
  CGenericGameStorage::_SaveDataToWorkBuffer(v14, 12);
  j_free(v14);
}

//----- (00510110) --------------------------------------------------------
CTask *__fastcall CTaskComplexWalkRoundFire::Clone(const CTaskComplexWalkRoundFire *this)
{
  CTaskComplex *v2; // r0
  CTask *m_iMoveState; // r5
  float m_fFireRadius; // r6
  CTask *result; // r0
  CTask v6; // d16
  CTask v7; // d16

  v2 = (CTaskComplex *)CTask::operator new(0x38u);
  m_iMoveState = (CTask *)this->m_iMoveState;
  m_fFireRadius = this->m_fFireRadius;
  CTaskComplex::CTaskComplex(v2);
  result[1].m_pParent = m_iMoveState;
  result->_vptr$CTask = (int (**)(void))&off_66B914;
  v6 = *(CTask *)&this->m_vFirePos.x;
  result[3]._vptr$CTask = (int (**)(void))LODWORD(this->m_vFirePos.z);
  *(float *)&result[3].m_pParent = m_fFireRadius;
  result[2] = v6;
  v7 = *(CTask *)&this->m_vTarget.x;
  result[5]._vptr$CTask = (int (**)(void))LODWORD(this->m_vTarget.z);
  result[4] = v7;
  return result;
}
// 51012A: variable 'result' is possibly undefined
// 66B914: using guessed type void *off_66B914;

//----- (00510158) --------------------------------------------------------
int __fastcall CTaskComplexWalkRoundFire::GetTaskType(const CTaskComplexWalkRoundFire *this)
{
  return 514;
}

//----- (00510160) --------------------------------------------------------
void __fastcall CTaskComplexWalkRoundFire::Serialize(CTaskComplexWalkRoundFire *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int m_iMoveState; // r6
  _DWORD *v5; // r5
  _DWORD *v6; // r5
  __int64 v7; // d16
  float *v8; // r5
  _DWORD *v9; // r5
  __int64 v10; // d16
  int v11; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexWalkRoundFire *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexWalkRoundFire *))this->_vptr$CTask + 5))(this) == 514 )
  {
    m_iMoveState = this->m_iMoveState;
    if ( UseDataFence )
      AddDataFence();
    v5 = malloc(4u);
    *v5 = m_iMoveState;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 4);
    free(v5);
    if ( UseDataFence )
      AddDataFence();
    v6 = malloc(0xCu);
    v7 = *(_QWORD *)&this->m_vFirePos.x;
    v6[2] = LODWORD(this->m_vFirePos.z);
    *(_QWORD *)v6 = v7;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 12);
    free(v6);
    if ( UseDataFence )
      AddDataFence();
    v8 = (float *)malloc(4u);
    *v8 = this->m_fFireRadius;
    CGenericGameStorage::_SaveDataToWorkBuffer(v8, 4);
    free(v8);
    if ( UseDataFence )
      AddDataFence();
    v9 = malloc(0xCu);
    v10 = *(_QWORD *)&this->m_vTarget.x;
    v9[2] = LODWORD(this->m_vTarget.z);
    *(_QWORD *)v9 = v10;
    CGenericGameStorage::_SaveDataToWorkBuffer(v9, 12);
    j_free(v9);
  }
  else
  {
    v11 = (*((int (__fastcall **)(CTaskComplexWalkRoundFire *))this->_vptr$CTask + 5))(this);
    sub_1941C4(514, v11);
  }
}

//----- (005102A0) --------------------------------------------------------
void __fastcall CTaskSimpleGiveCPR::CTaskSimpleGiveCPR(CTaskSimpleGiveCPR *this, CAccident *pAccident)
{
  int v3; // r0
  char v4; // r2

  CTaskSimple::CTaskSimple(this);
  v4 = *(_BYTE *)(v3 + 8);
  *(_DWORD *)(v3 + 12) = pAccident;
  *(_DWORD *)(v3 + 16) = 0;
  *(_BYTE *)(v3 + 8) = v4 & 0xFC | 1;
  *(_DWORD *)v3 = &off_66B98C;
}
// 5102AE: variable 'v3' is possibly undefined
// 66B98C: using guessed type void *off_66B98C;

//----- (005102CC) --------------------------------------------------------
void __fastcall CTaskSimpleGiveCPR::~CTaskSimpleGiveCPR(CTaskSimpleGiveCPR *this)
{
  CAnimBlendAssociation *m_pAnim; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_66B98C;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  sub_1A01F4(this);
}
// 66B98C: using guessed type void *;

//----- (00510300) --------------------------------------------------------
void __fastcall CTaskSimpleGiveCPR::~CTaskSimpleGiveCPR(CTaskSimpleGiveCPR *this)
{
  CAnimBlendAssociation *m_pAnim; // r0
  void *v3; // r0

  m_pAnim = this->m_pAnim;
  this->_vptr$CTask = (int (**)(void))&off_66B98C;
  if ( m_pAnim )
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v3);
}
// 51032A: variable 'v3' is possibly undefined
// 66B98C: using guessed type void *off_66B98C;

//----- (00510338) --------------------------------------------------------
bool __fastcall CTaskSimpleGiveCPR::ProcessPed(CTaskSimpleGiveCPR *this, CPed *pPed)
{
  char v3; // r0
  float m_nHealth; // r2
  CAnimBlendAssociation *v5; // r0
  bool result; // r0
  CAccident *m_pAccident; // r1
  CPed *m_pInjuredPed; // r4
  CEventRevived v9; // [sp+4h] [bp-14h] BYREF

  v3 = *((_BYTE *)this + 8);
  if ( (v3 & 1) != 0 )
  {
    m_nHealth = pPed->m_nHealth;
    v3 &= ~1u;
    *((_BYTE *)this + 8) = v3;
    this->m_nMedicInitialHealth = m_nHealth;
  }
  if ( (v3 & 2) != 0 )
  {
    m_pAccident = this->m_pAccident;
    result = 1;
    m_pInjuredPed = m_pAccident->m_pInjuredPed;
    if ( m_pAccident->m_pInjuredPed )
    {
      m_pAccident->m_bHealed = 1;
      if ( !(*((unsigned __int8 *)&m_pInjuredPed->m_nPedFlags + 1) >> 7) )
      {
        CInterestingEvents::Add(&g_InterestingEvents, EPedRevived, m_pInjuredPed);
        CEventRevived::CEventRevived(&v9);
        CEventGroup::Add(&m_pInjuredPed->m_pPedIntelligence->m_eventGroup, &v9, 0);
        CEvent::~CEvent(&v9);
        return 1;
      }
    }
  }
  else
  {
    if ( !this->m_pAnim )
    {
      v5 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_MEDIC_PED, ANIM_MEDIC_CPR, 4.0);
      this->m_pAnim = v5;
      CAnimBlendAssociation::SetFinishCallback(v5, CTaskSimpleGiveCPR::FinishGiveCPRAnimCB, this);
    }
    return 0;
  }
  return result;
}

//----- (005103D0) --------------------------------------------------------
void __fastcall CTaskSimpleGiveCPR::ReviveDeadPed(const CTaskSimpleGiveCPR *this, CPed *pPed)
{
  CAccident *m_pAccident; // r0
  CPed *m_pInjuredPed; // r4
  CEventRevived v4; // [sp+4h] [bp-14h] BYREF

  m_pAccident = this->m_pAccident;
  m_pInjuredPed = m_pAccident->m_pInjuredPed;
  if ( m_pAccident->m_pInjuredPed )
  {
    m_pAccident->m_bHealed = 1;
    if ( !(*((unsigned __int8 *)&m_pInjuredPed->m_nPedFlags + 1) >> 7) )
    {
      CInterestingEvents::Add(&g_InterestingEvents, EPedRevived, m_pInjuredPed);
      CEventRevived::CEventRevived(&v4);
      CEventGroup::Add(&m_pInjuredPed->m_pPedIntelligence->m_eventGroup, &v4, 0);
      CEvent::~CEvent(&v4);
    }
  }
}

//----- (00510420) --------------------------------------------------------
void __fastcall CTaskSimpleGiveCPR::StartAnim(CTaskSimpleGiveCPR *this, CPed *pPed)
{
  CAnimBlendAssociation *v3; // r0

  v3 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_MEDIC_PED, ANIM_MEDIC_CPR, 4.0);
  this->m_pAnim = v3;
  sub_18C19C(v3, CTaskSimpleGiveCPR::FinishGiveCPRAnimCB, this);
}

//----- (0051044C) --------------------------------------------------------
void __fastcall CTaskSimpleGiveCPR::FinishGiveCPRAnimCB(CAnimBlendAssociation *pAnim, void *pData)
{
  char v2; // r0

  v2 = *((_BYTE *)pData + 8);
  *((_DWORD *)pData + 4) = 0;
  *((_BYTE *)pData + 8) = v2 | 2;
}

//----- (0051045C) --------------------------------------------------------
bool __fastcall CTaskSimpleGiveCPR::MakeAbortable(
        CTaskSimpleGiveCPR *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  int v7; // r0
  float m_nHealth; // s0
  CAnimBlendAssociation *m_pAnim; // r0

  if ( iPriority != 2
    && (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 10
    && (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 52
    && (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 58
    && (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 66
    && (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 64
    && (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 41
    && (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 73 )
  {
    v7 = (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent);
    m_nHealth = pPed->m_nHealth;
    if ( (v7 != 9 || m_nHealth > 10.0 && (float)(this->m_nMedicInitialHealth - m_nHealth) < 40.0) && m_nHealth > 0.0 )
      return 0;
  }
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
  {
    CAnimBlendAssociation::SetFinishCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
    this->m_pAnim->m_fBlendDelta = -1000.0;
    this->m_pAnim = 0;
  }
  return 1;
}

//----- (0051053C) --------------------------------------------------------
void __fastcall CTaskComplexTreatAccident::CTaskComplexTreatAccident(
        CTaskComplexTreatAccident *this,
        CAccident *pAccident)
{
  _DWORD *v3; // r0

  CTaskComplex::CTaskComplex(this);
  v3[3] = pAccident;
  *v3 = &off_66B9C0;
}
// 510548: variable 'v3' is possibly undefined
// 66B9C0: using guessed type void *off_66B9C0;
// 6780A4: using guessed type void *`vtable for'CTaskComplexTreatAccident;

//----- (0051055C) --------------------------------------------------------
void __fastcall CTaskComplexTreatAccident::~CTaskComplexTreatAccident(CTaskComplexTreatAccident *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 510568: variable 'v1' is possibly undefined

//----- (0051056C) --------------------------------------------------------
CTask *__fastcall CTaskComplexTreatAccident::CreateNextSubTask(CTaskComplexTreatAccident *this, CPed *pPed)
{
  CPed *m_pInjuredPed; // r0
  CTask *v5; // r4
  CTaskSimple *v6; // r5
  CAccident *m_pAccident; // r9
  char v8; // r0
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r3
  float RadianAngleBetweenPoints; // r0
  float v12; // r0
  RwV3d_0 v14; // [sp+0h] [bp-30h] BYREF
  RwV3d_0 posn; // [sp+Ch] [bp-24h] BYREF

  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 902 )
    return 0;
  m_pInjuredPed = this->m_pAccident->m_pInjuredPed;
  if ( !m_pInjuredPed )
    return 0;
  v5 = 0;
  if ( (*((_BYTE *)&m_pInjuredPed->m_nPedFlags + 4) & 8) == 0 )
  {
    m_pInjuredPed->m_nTimeOfDeath = CTimer::m_snTimeInMilliseconds;
    v6 = (CTaskSimple *)CTask::operator new(0x18u);
    m_pAccident = this->m_pAccident;
    CTaskSimple::CTaskSimple(v6);
    v6->_vptr$CTask = (int (**)(void))&off_66B98C;
    v8 = (char)v6[1]._vptr$CTask;
    v6[1].m_pParent = (CTask *)m_pAccident;
    v6[2]._vptr$CTask = 0;
    LOBYTE(v6[1]._vptr$CTask) = v8 & 0xFC | 1;
    CPed::GetBonePosition(this->m_pAccident->m_pInjuredPed, &posn, 5u, 0);
    CPed::GetBonePosition(this->m_pAccident->m_pInjuredPed, &v14, 1u, 0);
    m_pMat = pPed->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pPed->m_transform;
    RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                                 (float)(posn.x + v14.x) * 0.5,
                                 (float)(posn.y + v14.y) * 0.5,
                                 p_tx->m_translate.x,
                                 p_tx->m_translate.y);
    v12 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
    v5 = v6;
    pPed->m_fCurrentHeading = v12;
    pPed->m_fDesiredHeading = v12;
  }
  return v5;
}
// 66B98C: using guessed type void *off_66B98C;

//----- (00510658) --------------------------------------------------------
CTask *__fastcall CTaskComplexTreatAccident::CreateSubTask(
        CTaskComplexTreatAccident *this,
        const int iSubTaskType,
        const CPed *pPed)
{
  CTaskSimpleAchieveHeading *v5; // r4
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r3
  float RadianAngleBetweenPoints; // r0
  float v9; // r5
  CTaskSimple *v10; // r0
  CAccident *m_pAccident; // r5
  int v12; // r0
  char v13; // r2
  RwV3d_0 v15; // [sp+0h] [bp-28h] BYREF
  RwV3d_0 posn; // [sp+Ch] [bp-1Ch] BYREF

  v5 = 0;
  switch ( iSubTaskType )
  {
    case 102:
      v10 = (CTaskSimple *)CTask::operator new(0x18u);
      m_pAccident = this->m_pAccident;
      CTaskSimple::CTaskSimple(v10);
      v13 = *(_BYTE *)(v12 + 8);
      *(_DWORD *)(v12 + 12) = m_pAccident;
      *(_DWORD *)(v12 + 16) = 0;
      v5 = (CTaskSimpleAchieveHeading *)v12;
      *(_DWORD *)v12 = &off_66B98C;
      *(_BYTE *)(v12 + 8) = v13 & 0xFC | 1;
      break;
    case 200:
      v5 = (CTaskSimpleAchieveHeading *)CTask::operator new(8u);
      CTaskSimple::CTaskSimple(v5);
      v5->_vptr$CTask = (int (**)(void))&off_668FF0;
      break;
    case 902:
      CPed::GetBonePosition(this->m_pAccident->m_pInjuredPed, &posn, 5u, 0);
      CPed::GetBonePosition(this->m_pAccident->m_pInjuredPed, &v15, 1u, 0);
      m_pMat = pPed->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                                   (float)(posn.x + v15.x) * 0.5,
                                   (float)(posn.y + v15.y) * 0.5,
                                   p_tx->m_translate.x,
                                   p_tx->m_translate.y);
      v9 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
      v5 = (CTaskSimpleAchieveHeading *)CTask::operator new(0x18u);
      CTaskSimpleAchieveHeading::CTaskSimpleAchieveHeading(v5, v9, 0.5, 0.2);
      break;
  }
  return v5;
}
// 51070A: variable 'v12' is possibly undefined
// 668FF0: using guessed type void *off_668FF0;
// 66B98C: using guessed type void *off_66B98C;
// 678150: using guessed type void *`vtable for'CTaskSimpleNone;

//----- (00510758) --------------------------------------------------------
float __fastcall CTaskComplexTreatAccident::ComputeHeading(const CTaskComplexTreatAccident *this, const CPed *ped)
{
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r3
  float RadianAngleBetweenPoints; // r0
  RwV3d_0 v8; // [sp+0h] [bp-20h] BYREF
  RwV3d_0 posn; // [sp+Ch] [bp-14h] BYREF

  CPed::GetBonePosition(this->m_pAccident->m_pInjuredPed, &posn, 5u, 0);
  CPed::GetBonePosition(this->m_pAccident->m_pInjuredPed, &v8, 1u, 0);
  m_pMat = ped->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &ped->m_transform;
  RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                               (float)(posn.x + v8.x) * 0.5,
                               (float)(posn.y + v8.y) * 0.5,
                               p_tx->m_translate.x,
                               p_tx->m_translate.y);
  return CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
}

//----- (005107C8) --------------------------------------------------------
CTask *__fastcall CTaskComplexTreatAccident::CreateFirstSubTask(CTaskComplexTreatAccident *this, CPed *pPed)
{
  CPed *m_pInjuredPed; // r0
  int v5; // r1

  m_pInjuredPed = this->m_pAccident->m_pInjuredPed;
  if ( !m_pInjuredPed || (*((_BYTE *)&m_pInjuredPed->m_nPedFlags + 4) & 8) != 0 )
  {
    v5 = 200;
  }
  else
  {
    m_pInjuredPed->m_nTimeOfDeath = CTimer::m_snTimeInMilliseconds;
    CPed::Say(pPed, 0xE8u, 0, 1.0, 0, 0, 0);
    IKChainManager_c::LookAt(
      &g_ikChainMan,
      "TaskTreatAccident",
      pPed,
      this->m_pAccident->m_pInjuredPed,
      5000,
      5,
      0,
      1,
      0.25,
      500,
      3,
      0);
    v5 = 902;
  }
  return CTaskComplexTreatAccident::CreateSubTask(this, v5, pPed);
}

//----- (00510874) --------------------------------------------------------
CTask *__fastcall CTaskComplexTreatAccident::ControlSubTask(CTaskComplexTreatAccident *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (00510878) --------------------------------------------------------
void __fastcall CTaskComplexMedicTreatInjuredPed::CTaskComplexMedicTreatInjuredPed(
        CTaskComplexMedicTreatInjuredPed *this,
        CVehicle *pAmbulance,
        CPed *pColleague,
        const bool bIsDriver)
{
  CTaskComplex::CTaskComplex(this);
  this->m_bIsDriver = bIsDriver;
  this->m_pAccident = 0;
  this->m_bLeftAmbulance = 0;
  this->_vptr$CTask = (int (**)(void))&off_66B9FC;
  this->m_pColleague = pColleague;
  this->m_pAmbulance = pAmbulance;
  if ( pAmbulance )
  {
    CEntity::RegisterReference(pAmbulance, &this->m_pAmbulance);
    pColleague = this->m_pColleague;
  }
  if ( pColleague )
    CEntity::RegisterReference(pColleague, &this->m_pColleague);
}
// 66B9FC: using guessed type void *;

//----- (005108D4) --------------------------------------------------------
void __fastcall CTaskComplexMedicTreatInjuredPed::~CTaskComplexMedicTreatInjuredPed(
        CTaskComplexMedicTreatInjuredPed *this)
{
  CAccident *m_pAccident; // r0
  bool v3; // zf
  CVehicle *m_pAmbulance; // r0
  CPed *m_pColleague; // r0

  m_pAccident = this->m_pAccident;
  this->_vptr$CTask = (int (**)(void))&off_66B9FC;
  v3 = m_pAccident == 0;
  if ( m_pAccident )
    v3 = m_pAccident->m_pInjuredPed == 0;
  if ( !v3 && !m_pAccident->m_bHealed )
    m_pAccident->m_bBeingDealtWith = 0;
  m_pAmbulance = this->m_pAmbulance;
  if ( m_pAmbulance )
    CEntity::CleanUpOldReference(m_pAmbulance, &this->m_pAmbulance);
  m_pColleague = this->m_pColleague;
  if ( m_pColleague )
    CEntity::CleanUpOldReference(m_pColleague, &this->m_pColleague);
  sub_18EDB4(this);
}
// 66B9FC: using guessed type void *off_66B9FC;

//----- (00510924) --------------------------------------------------------
void __fastcall CTaskComplexMedicTreatInjuredPed::~CTaskComplexMedicTreatInjuredPed(
        CTaskComplexMedicTreatInjuredPed *this)
{
  CAccident *m_pAccident; // r0
  bool v3; // zf
  CVehicle *m_pAmbulance; // r0
  CPed *m_pColleague; // r0
  void *v6; // r0

  m_pAccident = this->m_pAccident;
  this->_vptr$CTask = (int (**)(void))&off_66B9FC;
  v3 = m_pAccident == 0;
  if ( m_pAccident )
    v3 = m_pAccident->m_pInjuredPed == 0;
  if ( !v3 && !m_pAccident->m_bHealed )
    m_pAccident->m_bBeingDealtWith = 0;
  m_pAmbulance = this->m_pAmbulance;
  if ( m_pAmbulance )
    CEntity::CleanUpOldReference(m_pAmbulance, &this->m_pAmbulance);
  m_pColleague = this->m_pColleague;
  if ( m_pColleague )
    CEntity::CleanUpOldReference(m_pColleague, &this->m_pColleague);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v6);
}
// 510970: variable 'v6' is possibly undefined
// 66B9FC: using guessed type void *off_66B9FC;

//----- (00510978) --------------------------------------------------------
CTask *__fastcall CTaskComplexMedicTreatInjuredPed::CreateNextSubTask(
        CTaskComplexMedicTreatInjuredPed *this,
        CPed *pPed)
{
  int v4; // r0
  CTaskComplexWander *v5; // r5
  unsigned __int16 v6; // r0
  void **v7; // r0
  CAccident *v8; // r0
  CPed *v9; // r5
  bool v10; // zf
  RwReal v11; // s2
  RwReal v12; // s4
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r5
  CAccidentManager *AccidentManager; // r0
  CAccident *NearestFreeAccident; // r0
  _BOOL4 m_bIsDriver; // r6
  CTaskComplexEnterCarAsPassenger *v18; // r0
  CMatrix *v19; // r1
  CSimpleTransform *p_m_transform; // r0
  float *p_z; // r0
  float32x2_t v22; // d17
  float32x2_t v23; // d16
  unsigned __int64 v24; // d0
  CAccident *m_pAccident; // r4
  CMatrix *v27; // r0
  CSimpleTransform *v28; // r5
  CAccidentManager *v29; // r0
  CMatrix *v30; // r0
  CSimpleTransform *v31; // r5
  CAccidentManager *v32; // r0
  CPed *m_pInjuredPed; // r5
  RwReal v34; // s2
  RwReal v35; // s4
  RwV3d_0 v36; // [sp+10h] [bp-28h] BYREF
  RwV3d_0 posn; // [sp+1Ch] [bp-1Ch] BYREF

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  v5 = 0;
  if ( v4 <= 700 )
  {
    if ( v4 != 101 )
    {
      if ( v4 != 203 )
      {
        if ( v4 == 700 )
        {
          if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
          {
LABEL_6:
            v5 = (CTaskComplexWander *)CTask::operator new(0x28u);
            v6 = rand();
            CTaskComplexWander::CTaskComplexWander(v5, 4, (int)(float)((float)((float)v6 * 0.000015259) * 8.0), 1, 0.5);
            v7 = &`vtable for'CTaskComplexWanderMedic;
LABEL_27:
            v5->_vptr$CTask = (int (**)(void))((char *)*v7 + 8);
            return v5;
          }
LABEL_28:
          v5 = (CTaskComplexWander *)CTask::operator new(0x60u);
          CTaskSimpleCarDrive::CTaskSimpleCarDrive((CTaskSimpleCarDrive *)v5, this->m_pAmbulance, 0, 0);
          return v5;
        }
        return v5;
      }
      goto LABEL_18;
    }
    m_pMat = pPed->m_pMat;
    this->m_pAccident = 0;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pPed->m_transform;
    AccidentManager = GetAccidentManager();
    NearestFreeAccident = CAccidentManager::GetNearestFreeAccident(AccidentManager, &p_tx->m_translate, 1);
    this->m_pAccident = NearestFreeAccident;
    if ( !NearestFreeAccident )
    {
LABEL_18:
      m_bIsDriver = this->m_bIsDriver;
      v18 = (CTaskComplexEnterCarAsPassenger *)CTask::operator new(0x50u);
      v5 = (CTaskComplexWander *)v18;
      if ( !m_bIsDriver )
      {
        CTaskComplexEnterCarAsPassenger::CTaskComplexEnterCarAsPassenger(v18, this->m_pAmbulance, 11, 0);
        return v5;
      }
      goto LABEL_19;
    }
LABEL_38:
    NearestFreeAccident->m_bBeingDealtWith = 1;
    m_pInjuredPed = this->m_pAccident->m_pInjuredPed;
    CPed::GetBonePosition(m_pInjuredPed, &posn, 0x29u, 0);
    CPed::GetBonePosition(m_pInjuredPed, &v36, 0x33u, 0);
    v34 = (float)(posn.y + v36.y) * 0.5;
    v35 = (float)(posn.z + v36.z) * 0.5;
    this->m_vTarget.x = (float)(posn.x + v36.x) * 0.5;
    this->m_vTarget.y = v34;
    this->m_vTarget.z = v35;
    v5 = (CTaskComplexWander *)CTask::operator new(0x28u);
    CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(
      (CTaskComplexGoToPointAndStandStill *)v5,
      6,
      &this->m_vTarget,
      0.125,
      2.0,
      0,
      0);
    return v5;
  }
  switch ( v4 )
  {
    case 701:
      if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
        goto LABEL_6;
      goto LABEL_28;
    case 903:
      v19 = pPed->m_pMat;
      p_m_transform = (CSimpleTransform *)&v19->tx;
      if ( !v19 )
        p_m_transform = &pPed->m_transform;
      v22.n64_u64[0] = *(unsigned __int64 *)&p_m_transform->m_translate.x;
      p_z = &p_m_transform->m_translate.z;
      v23.n64_u64[0] = vsub_f32(v22, *(float32x2_t *)&this->m_vTarget.x).n64_u64[0];
      v24 = vmul_f32(v23, v23).n64_u64[0];
      if ( sqrtf(*(float *)&v24 + *((float *)&v24 + 1)) > 1.0 || fabsf(*p_z - this->m_vTarget.z) > 2.0 )
        return CTaskComplexMedicTreatInjuredPed::CreateDealWithNextAccidentTask(this, pPed, this->m_pAccident);
      v5 = (CTaskComplexWander *)CTask::operator new(0x10u);
      m_pAccident = this->m_pAccident;
      CTaskComplex::CTaskComplex(v5);
      v5->m_iMoveState = (int)m_pAccident;
      v7 = &`vtable for'CTaskComplexTreatAccident;
      goto LABEL_27;
    case 704:
      CInterestingEvents::Add(&g_InterestingEvents, EEmergencyServicesArrived, pPed);
      if ( this->m_bIsDriver )
      {
        v8 = this->m_pAccident;
        v9 = v8->m_pInjuredPed;
        v10 = v8->m_pInjuredPed == 0;
        if ( v8->m_pInjuredPed )
          v10 = !v8->m_bBeingDealtWith;
        if ( !v10 )
        {
          CPed::GetBonePosition(v9, &posn, 0x29u, 0);
          CPed::GetBonePosition(v9, &v36, 0x33u, 0);
          v11 = (float)(posn.y + v36.y) * 0.5;
          v12 = (float)(posn.z + v36.z) * 0.5;
          this->m_vTarget.x = (float)(posn.x + v36.x) * 0.5;
          this->m_vTarget.y = v11;
          this->m_vTarget.z = v12;
          v5 = (CTaskComplexWander *)CTask::operator new(0x28u);
          CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(
            (CTaskComplexGoToPointAndStandStill *)v5,
            6,
            &this->m_vTarget,
            0.125,
            2.0,
            0,
            0);
          return v5;
        }
        v30 = pPed->m_pMat;
        this->m_pAccident = 0;
        v31 = (CSimpleTransform *)&v30->tx;
        if ( !v30 )
          v31 = &pPed->m_transform;
        v32 = GetAccidentManager();
        NearestFreeAccident = CAccidentManager::GetNearestFreeAccident(v32, &v31->m_translate, 1);
        this->m_pAccident = NearestFreeAccident;
        if ( !NearestFreeAccident )
        {
          v5 = (CTaskComplexWander *)CTask::operator new(0x50u);
LABEL_19:
          CTaskComplexEnterCarAsDriver::CTaskComplexEnterCarAsDriver(
            (CTaskComplexEnterCarAsDriver *)v5,
            this->m_pAmbulance);
          return v5;
        }
      }
      else
      {
        v27 = pPed->m_pMat;
        this->m_pAccident = 0;
        v28 = (CSimpleTransform *)&v27->tx;
        if ( !v27 )
          v28 = &pPed->m_transform;
        v29 = GetAccidentManager();
        NearestFreeAccident = CAccidentManager::GetNearestFreeAccident(v29, &v28->m_translate, 1);
        this->m_pAccident = NearestFreeAccident;
        if ( !NearestFreeAccident )
        {
          v5 = (CTaskComplexWander *)CTask::operator new(0x20u);
          CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v5, 10000, 0, 0, 8.0);
          return v5;
        }
      }
      goto LABEL_38;
  }
  return v5;
}
// 676B0C: using guessed type void *`vtable for'CTaskComplexWanderMedic;
// 6780A4: using guessed type void *`vtable for'CTaskComplexTreatAccident;

//----- (00510E04) --------------------------------------------------------
void __fastcall CTaskComplexMedicTreatInjuredPed::CalcTargetPosWithOffset(
        CTaskComplexMedicTreatInjuredPed *this,
        CPed *pMedicPed,
        CPed *pInjuredPed)
{
  RwReal v5; // s2
  RwReal v6; // s4
  RwV3d_0 v7; // [sp+0h] [bp-20h] BYREF
  RwV3d_0 posn; // [sp+Ch] [bp-14h] BYREF

  CPed::GetBonePosition(pInjuredPed, &posn, 0x29u, 0);
  CPed::GetBonePosition(pInjuredPed, &v7, 0x33u, 0);
  v5 = (float)(posn.y + v7.y) * 0.5;
  v6 = (float)(posn.z + v7.z) * 0.5;
  this->m_vTarget.x = (float)(posn.x + v7.x) * 0.5;
  this->m_vTarget.y = v5;
  this->m_vTarget.z = v6;
}

//----- (00510E6C) --------------------------------------------------------
CTask *__fastcall CTaskComplexMedicTreatInjuredPed::CreateSubTask(
        CTaskComplexMedicTreatInjuredPed *this,
        const int iSubTaskType)
{
  CTaskComplexEnterCarAsPassenger *v3; // r4
  unsigned __int16 v4; // r0
  void **v5; // r0
  CAccident *m_pAccident; // r5

  v3 = 0;
  if ( iSubTaskType < 700 )
  {
    if ( iSubTaskType == 101 )
    {
      v3 = (CTaskComplexEnterCarAsPassenger *)CTask::operator new(0x10u);
      m_pAccident = this->m_pAccident;
      CTaskComplex::CTaskComplex(v3);
      v3->m_pTargetVehicle = (CVehicle *)m_pAccident;
      v5 = &`vtable for'CTaskComplexTreatAccident;
LABEL_16:
      v3->_vptr$CTask = (int (**)(void))((char *)*v5 + 8);
    }
    else if ( iSubTaskType == 203 )
    {
      v3 = (CTaskComplexEnterCarAsPassenger *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v3, 10000, 0, 0, 8.0);
    }
  }
  else
  {
    switch ( iSubTaskType )
    {
      case 700:
        v3 = (CTaskComplexEnterCarAsPassenger *)CTask::operator new(0x50u);
        CTaskComplexEnterCarAsPassenger::CTaskComplexEnterCarAsPassenger(v3, this->m_pAmbulance, 11, 0);
        break;
      case 701:
        v3 = (CTaskComplexEnterCarAsPassenger *)CTask::operator new(0x50u);
        CTaskComplexEnterCarAsDriver::CTaskComplexEnterCarAsDriver(
          (CTaskComplexEnterCarAsDriver *)v3,
          this->m_pAmbulance);
        break;
      case 702:
      case 703:
      case 705:
      case 706:
      case 707:
      case 708:
        return v3;
      case 704:
        this->m_bLeftAmbulance = 1;
        v3 = (CTaskComplexEnterCarAsPassenger *)CTask::operator new(0x34u);
        CTaskComplexLeaveCar::CTaskComplexLeaveCar((CTaskComplexLeaveCar *)v3, this->m_pAmbulance, 0, 0, 1, 0);
        break;
      case 709:
        v3 = (CTaskComplexEnterCarAsPassenger *)CTask::operator new(0x60u);
        CTaskSimpleCarDrive::CTaskSimpleCarDrive((CTaskSimpleCarDrive *)v3, this->m_pAmbulance, 0, 0);
        break;
      case 710:
        v3 = (CTaskComplexEnterCarAsPassenger *)CTask::operator new(0x3Cu);
        CTaskComplexDriveToPoint::CTaskComplexDriveToPoint(
          (CTaskComplexDriveToPoint *)v3,
          this->m_pAmbulance,
          &this->m_vTarget,
          30.0,
          0,
          -1,
          -1.0,
          2);
        break;
      case 711:
        v3 = (CTaskComplexEnterCarAsPassenger *)CTask::operator new(0x24u);
        CTaskComplexCarDriveWander::CTaskComplexCarDriveWander(
          (CTaskComplexCarDriveWander *)v3,
          this->m_pAmbulance,
          2,
          30.0);
        break;
      default:
        if ( iSubTaskType == 903 )
        {
          v3 = (CTaskComplexEnterCarAsPassenger *)CTask::operator new(0x28u);
          CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(
            (CTaskComplexGoToPointAndStandStill *)v3,
            6,
            &this->m_vTarget,
            0.125,
            2.0,
            0,
            0);
        }
        else if ( iSubTaskType == 912 )
        {
          v3 = (CTaskComplexEnterCarAsPassenger *)CTask::operator new(0x28u);
          v4 = rand();
          CTaskComplexWander::CTaskComplexWander(
            (CTaskComplexWander *)v3,
            4,
            (int)(float)((float)((float)v4 * 0.000015259) * 8.0),
            1,
            0.5);
          v5 = &`vtable for'CTaskComplexWanderMedic;
          goto LABEL_16;
        }
        break;
    }
  }
  return v3;
}
// 676B0C: using guessed type void *`vtable for'CTaskComplexWanderMedic;
// 6780A4: using guessed type void *`vtable for'CTaskComplexTreatAccident;

//----- (00511030) --------------------------------------------------------
void __fastcall CTaskComplexMedicTreatInjuredPed::GetNearestAccident(
        CTaskComplexMedicTreatInjuredPed *this,
        const CVector *vPos)
{
  CAccidentManager *AccidentManager; // r0

  this->m_pAccident = 0;
  AccidentManager = GetAccidentManager();
  this->m_pAccident = CAccidentManager::GetNearestFreeAccident(AccidentManager, vPos, 1);
}

//----- (0051104C) --------------------------------------------------------
CTask *__fastcall CTaskComplexMedicTreatInjuredPed::CreateDealWithNextAccidentTask(
        CTaskComplexMedicTreatInjuredPed *this,
        CPed *pMedicPed,
        CAccident *exclude)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r6
  CAccidentManager *AccidentManager; // r0
  CAccident *NearestFreeAccidentExceptThisOne; // r0
  bool v9; // zf
  CTask *v10; // r4
  CPed *m_pInjuredPed; // r6
  RwReal v12; // s2
  RwReal v13; // s4
  CTask *m_pSubTask; // r0
  CTask v15; // d16
  char m_pParent; // r1
  _BOOL4 m_bIsDriver; // r6
  CTaskComplexEnterCarAsDriver *v18; // r0
  CTaskComplexGoToPointAndStandStill *v19; // r0
  RwV3d_0 v21; // [sp+10h] [bp-28h] BYREF
  RwV3d_0 posn; // [sp+1Ch] [bp-1Ch] BYREF

  m_pMat = pMedicPed->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  this->m_pAccident = 0;
  if ( !m_pMat )
    p_tx = &pMedicPed->m_transform;
  AccidentManager = GetAccidentManager();
  NearestFreeAccidentExceptThisOne = CAccidentManager::GetNearestFreeAccidentExceptThisOne(
                                       AccidentManager,
                                       &p_tx->m_translate,
                                       exclude,
                                       1);
  this->m_pAccident = NearestFreeAccidentExceptThisOne;
  v9 = NearestFreeAccidentExceptThisOne == 0;
  if ( NearestFreeAccidentExceptThisOne )
    v9 = NearestFreeAccidentExceptThisOne->m_pInjuredPed == 0;
  if ( v9 )
  {
    m_bIsDriver = this->m_bIsDriver;
    v18 = (CTaskComplexEnterCarAsDriver *)CTask::operator new(0x50u);
    v10 = v18;
    if ( m_bIsDriver )
      CTaskComplexEnterCarAsDriver::CTaskComplexEnterCarAsDriver(v18, this->m_pAmbulance);
    else
      CTaskComplexEnterCarAsPassenger::CTaskComplexEnterCarAsPassenger(
        (CTaskComplexEnterCarAsPassenger *)v18,
        this->m_pAmbulance,
        11,
        0);
  }
  else
  {
    NearestFreeAccidentExceptThisOne->m_bBeingDealtWith = 1;
    v10 = 0;
    m_pInjuredPed = this->m_pAccident->m_pInjuredPed;
    CPed::GetBonePosition(m_pInjuredPed, &posn, 0x29u, 0);
    CPed::GetBonePosition(m_pInjuredPed, &v21, 0x33u, 0);
    v12 = (float)(posn.y + v21.y) * 0.5;
    v13 = (float)(posn.z + v21.z) * 0.5;
    this->m_vTarget.x = (float)(posn.x + v21.x) * 0.5;
    this->m_vTarget.y = v12;
    this->m_vTarget.z = v13;
    m_pSubTask = this->m_pSubTask;
    if ( m_pSubTask && (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) == 903 )
    {
      v10 = this->m_pSubTask;
      if ( *(float *)&v10[2]._vptr$CTask != this->m_vTarget.x
        || *(float *)&v10[2].m_pParent != this->m_vTarget.y
        || *(float *)&v10[3]._vptr$CTask != this->m_vTarget.z
        || *(float *)&v10[4]._vptr$CTask != 2.0 )
      {
        v15 = *(CTask *)&this->m_vTarget.x;
        v10[3]._vptr$CTask = (int (**)(void))LODWORD(this->m_vTarget.z);
        v10[2] = v15;
        m_pParent = (char)v10[4].m_pParent;
        v10[3].m_pParent = (CTask *)1056964608;
        v10[4]._vptr$CTask = (int (**)(void))0x40000000;
        LOBYTE(v10[4].m_pParent) = m_pParent | 4;
      }
      v10[1].m_pParent = (CTask *)&byte_6;
    }
    else
    {
      v19 = (CTaskComplexGoToPointAndStandStill *)CTask::operator new(0x28u);
      CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(v19, 6, &this->m_vTarget, 0.125, 2.0, 0, 0);
    }
  }
  return v10;
}
// 6: using guessed type char byte_6;

//----- (005111E0) --------------------------------------------------------
CTask *__fastcall CTaskComplexMedicTreatInjuredPed::CreateFirstSubTask(
        CTaskComplexMedicTreatInjuredPed *this,
        CPed *pPed)
{
  int v2; // r1

  if ( this->m_pAmbulance )
  {
    v2 = 711;
    if ( !this->m_bIsDriver )
      v2 = 709;
  }
  else
  {
    v2 = 912;
  }
  return CTaskComplexMedicTreatInjuredPed::CreateSubTask(this, v2);
}

//----- (005111FC) --------------------------------------------------------
void __fastcall CTaskComplexMedicTreatInjuredPed::GetNearestAccidentExceptThisOne(
        CTaskComplexMedicTreatInjuredPed *this,
        const CVector *vPos,
        CAccident *exclude)
{
  CAccidentManager *AccidentManager; // r0

  this->m_pAccident = 0;
  AccidentManager = GetAccidentManager();
  this->m_pAccident = CAccidentManager::GetNearestFreeAccidentExceptThisOne(AccidentManager, vPos, exclude, 1);
}

//----- (00511224) --------------------------------------------------------
CTask *__fastcall CTaskComplexMedicTreatInjuredPed::ControlSubTask(CTaskComplexMedicTreatInjuredPed *this, CPed *pPed)
{
  CTaskComplexDriveToPoint *m_pSubTask; // r4
  int v5; // r0
  CAccident *v6; // r0
  bool v7; // zf
  CMatrix *v8; // r0
  CSimpleTransform *p_m_transform; // r5
  CAccidentManager *AccidentManager; // r0
  CAccident *NearestFreeAccident; // r0
  CPed *v12; // r4
  RwReal v13; // s2
  RwReal v14; // s4
  CAccident *m_pAccident; // r0
  bool v16; // zf
  CTask *v17; // r11
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float32x2_t v20; // d16
  unsigned __int64 v21; // d1
  int i; // r5
  CEntity *v23; // r0
  CPed *m_pInjuredPed; // r6
  RwReal v26; // s2
  RwReal v27; // s4
  float v28; // s2
  CTask v29; // d16
  char m_pParent; // r2
  CVehicle *m_pAmbulance; // r0
  CMatrix *v33; // r1
  CSimpleTransform *v34; // r2
  float32x2_t v35; // d16
  unsigned __int64 v36; // d1
  CPed *m_pColleague; // r0
  CTask *ActiveTask; // r0
  CTask *v39; // r8
  int (**v40)(void); // r0
  bool v41; // zf
  __int64 v42; // d16
  RwV3d_0 v43; // [sp+14h] [bp-34h] BYREF
  RwV3d_0 posn; // [sp+20h] [bp-28h] BYREF

  m_pSubTask = (CTaskComplexDriveToPoint *)this->m_pSubTask;
  v5 = (*((int (__fastcall **)(CTaskComplexDriveToPoint *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask);
  if ( v5 > 710 )
  {
    if ( v5 == 903 )
    {
      m_pAccident = this->m_pAccident;
      v16 = m_pAccident == 0;
      if ( m_pAccident )
        v16 = m_pAccident->m_pInjuredPed == 0;
      if ( !v16 )
      {
        v17 = this->m_pSubTask;
        if ( v17[1].m_pParent == (CTask *)byte_4 )
          return m_pSubTask;
        m_pMat = pPed->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &pPed->m_transform;
        v20.n64_u64[0] = vsub_f32(*(float32x2_t *)&this->m_vTarget.y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
        v21 = vmul_f32(v20, v20).n64_u64[0];
        if ( (float)((float)((float)((float)(this->m_vTarget.x - p_tx->m_translate.x)
                                   * (float)(this->m_vTarget.x - p_tx->m_translate.x))
                           + *(float *)&v21)
                   + *((float *)&v21 + 1)) >= 25.0 )
          return m_pSubTask;
        for ( i = 56; ; ++i )
        {
          v23 = (CEntity *)*((_DWORD *)&pPed->m_pPedIntelligence->m_pPed + i);
          if ( v23 )
          {
            if ( CPedGeometryAnalyser::IsEntityBlockingTarget(v23, &this->m_vTarget, 0.125) )
              break;
          }
          if ( i - 56 >= 15 )
          {
            m_pInjuredPed = this->m_pAccident->m_pInjuredPed;
            CPed::GetBonePosition(m_pInjuredPed, &posn, 0x29u, 0);
            CPed::GetBonePosition(m_pInjuredPed, &v43, 0x33u, 0);
            v26 = (float)(posn.y + v43.y) * 0.5;
            v27 = (float)(posn.z + v43.z) * 0.5;
            this->m_vTarget.x = (float)(posn.x + v43.x) * 0.5;
            this->m_vTarget.y = v26;
            this->m_vTarget.z = v27;
            v28 = *(float *)&v17[2]._vptr$CTask;
            v17[1].m_pParent = (CTask *)byte_4;
            if ( v28 != this->m_vTarget.x
              || *(float *)&v17[2].m_pParent != this->m_vTarget.y
              || *(float *)&v17[3]._vptr$CTask != this->m_vTarget.z
              || *(float *)&v17[4]._vptr$CTask != 2.0 )
            {
              v29 = *(CTask *)&this->m_vTarget.x;
              m_pParent = (char)v17[4].m_pParent;
              v17[3]._vptr$CTask = (int (**)(void))LODWORD(this->m_vTarget.z);
              v17[3].m_pParent = (CTask *)1056964608;
              v17[4]._vptr$CTask = (int (**)(void))0x40000000;
              LOBYTE(v17[4].m_pParent) = m_pParent | 4;
              v17[2] = v29;
            }
            return m_pSubTask;
          }
        }
      }
      return CTaskComplexMedicTreatInjuredPed::CreateDealWithNextAccidentTask(this, pPed, 0);
    }
    if ( v5 == 711 && *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
    {
      v8 = pPed->m_pMat;
      this->m_pAccident = 0;
      p_m_transform = (CSimpleTransform *)&v8->tx;
      if ( !v8 )
        p_m_transform = &pPed->m_transform;
      AccidentManager = GetAccidentManager();
      NearestFreeAccident = CAccidentManager::GetNearestFreeAccident(AccidentManager, &p_m_transform->m_translate, 1);
      this->m_pAccident = NearestFreeAccident;
      if ( NearestFreeAccident )
      {
        NearestFreeAccident->m_bBeingDealtWith = 1;
        v12 = this->m_pAccident->m_pInjuredPed;
        CPed::GetBonePosition(v12, &posn, 0x29u, 0);
        CPed::GetBonePosition(v12, &v43, 0x33u, 0);
        v13 = (float)(posn.y + v43.y) * 0.5;
        v14 = (float)(posn.z + v43.z) * 0.5;
        this->m_vTarget.x = (float)(posn.x + v43.x) * 0.5;
        this->m_vTarget.y = v13;
        this->m_vTarget.z = v14;
        m_pSubTask = (CTaskComplexDriveToPoint *)CTask::operator new(0x3Cu);
        CTaskComplexDriveToPoint::CTaskComplexDriveToPoint(
          m_pSubTask,
          this->m_pAmbulance,
          &this->m_vTarget,
          30.0,
          0,
          -1,
          -1.0,
          2);
      }
    }
  }
  else
  {
    if ( v5 != 709 )
    {
      if ( v5 != 710 || !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
        return m_pSubTask;
      v6 = this->m_pAccident;
      v7 = v6 == 0;
      if ( v6 )
        v7 = v6->m_pInjuredPed == 0;
      if ( !v7 )
      {
        m_pAmbulance = this->m_pAmbulance;
LABEL_38:
        v33 = m_pAmbulance->m_pMat;
        v34 = (CSimpleTransform *)&v33->tx;
        if ( !v33 )
          v34 = &m_pAmbulance->m_transform;
        v35.n64_u64[0] = vsub_f32(*(float32x2_t *)&v34->m_translate.y, *(float32x2_t *)&this->m_vTarget.y).n64_u64[0];
        v36 = vmul_f32(v35, v35).n64_u64[0];
        if ( (float)((float)((float)((float)(v34->m_translate.x - this->m_vTarget.x)
                                   * (float)(v34->m_translate.x - this->m_vTarget.x))
                           + *(float *)&v36)
                   + *((float *)&v36 + 1)) < 100.0 )
        {
          CPed::Say(pPed, 0xE7u, 0, 1.0, 0, 0, 0);
          this->m_bLeftAmbulance = 1;
          m_pSubTask = (CTaskComplexDriveToPoint *)CTask::operator new(0x34u);
          CTaskComplexLeaveCar::CTaskComplexLeaveCar((CTaskComplexLeaveCar *)m_pSubTask, this->m_pAmbulance, 0, 0, 1, 0);
        }
        return m_pSubTask;
      }
      this->m_pAccident = 0;
      goto LABEL_20;
    }
    if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
    {
      if ( !this->m_bIsDriver )
      {
        if ( this->m_bLeftAmbulance )
          return m_pSubTask;
        m_pColleague = this->m_pColleague;
        if ( !m_pColleague )
          return m_pSubTask;
        ActiveTask = CTaskManager::GetActiveTask(&m_pColleague->m_pPedIntelligence->m_taskManager);
        v39 = ActiveTask;
        if ( !ActiveTask || (*((int (__fastcall **)(CTask *))ActiveTask->_vptr$CTask + 5))(ActiveTask) != 100 )
          return m_pSubTask;
        v40 = v39[3]._vptr$CTask;
        v41 = v40 == 0;
        if ( v40 )
          v41 = *v40 == 0;
        if ( v41 )
          return m_pSubTask;
        m_pAmbulance = this->m_pAmbulance;
        v42 = *(_QWORD *)&v39[3].m_pParent;
        LODWORD(this->m_vTarget.z) = v39[4].m_pParent;
        *(_QWORD *)&this->m_vTarget.x = v42;
        goto LABEL_38;
      }
      if ( CVehicle::IsPassenger(this->m_pAmbulance, this->m_pColleague) )
      {
LABEL_20:
        m_pSubTask = (CTaskComplexDriveToPoint *)CTask::operator new(0x24u);
        CTaskComplexCarDriveWander::CTaskComplexCarDriveWander(
          (CTaskComplexCarDriveWander *)m_pSubTask,
          this->m_pAmbulance,
          2,
          30.0);
      }
    }
  }
  return m_pSubTask;
}

//----- (005115F8) --------------------------------------------------------
void __fastcall CTaskComplexPresentIDToCop::CTaskComplexPresentIDToCop(CTaskComplexPresentIDToCop *this, CPed *pCop)
{
  CTaskComplex::CTaskComplex(this);
  this->_vptr$CTask = (int (**)(void))&off_66BA38;
  this->m_pHassleCop = pCop;
  CEntity::RegisterReference(pCop, &this->m_pHassleCop);
}
// 66BA38: using guessed type void *;

//----- (00511624) --------------------------------------------------------
void __fastcall CTaskComplexPresentIDToCop::~CTaskComplexPresentIDToCop(CTaskComplexPresentIDToCop *this)
{
  CPed *m_pHassleCop; // r0
  CEntity **p_m_pHassleCop; // r1

  p_m_pHassleCop = &this->m_pHassleCop;
  m_pHassleCop = this->m_pHassleCop;
  this->_vptr$CTask = (int (**)(void))&off_66BA38;
  if ( m_pHassleCop )
    CEntity::CleanUpOldReference(m_pHassleCop, p_m_pHassleCop);
  sub_18EDB4(this);
}
// 66BA38: using guessed type void *off_66BA38;

//----- (00511650) --------------------------------------------------------
void __fastcall CTaskComplexPresentIDToCop::~CTaskComplexPresentIDToCop(CTaskComplexPresentIDToCop *this)
{
  CPed *m_pHassleCop; // r0
  CEntity **p_m_pHassleCop; // r1
  void *v4; // r0

  p_m_pHassleCop = &this->m_pHassleCop;
  m_pHassleCop = this->m_pHassleCop;
  this->_vptr$CTask = (int (**)(void))&off_66BA38;
  if ( m_pHassleCop )
    CEntity::CleanUpOldReference(m_pHassleCop, p_m_pHassleCop);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 511678: variable 'v4' is possibly undefined
// 66BA38: using guessed type void *off_66BA38;

//----- (00511680) --------------------------------------------------------
CTask *__fastcall CTaskComplexPresentIDToCop::CreateNextSubTask(CTaskComplexPresentIDToCop *this, CPed *pPed)
{
  int v4; // r0
  int v5; // r1

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v4 == 413 )
  {
    v5 = 1302;
    return CTaskComplexPresentIDToCop::CreateSubTask(this, v5, pPed);
  }
  if ( v4 == 902 )
  {
    CPed::Say(pPed, 0x45u, 0, 1.0, 0, 0, 0);
    v5 = 413;
    return CTaskComplexPresentIDToCop::CreateSubTask(this, v5, pPed);
  }
  return 0;
}

//----- (005116D4) --------------------------------------------------------
CTask *__fastcall CTaskComplexPresentIDToCop::CreateSubTask(
        const CTaskComplexPresentIDToCop *this,
        const int iSubTaskType,
        const CPed *pPed)
{
  CTaskSimpleAchieveHeading *v5; // r4
  CPed *m_pHassleCop; // r0
  CMatrix *m_pMat; // r1
  CMatrix *v8; // r6
  CSimpleTransform *p_tx; // r3
  float *p_x; // r1
  __int64 v11; // r2
  float RadianAngleBetweenPoints; // r0
  float v13; // r0
  CTaskSimpleRunTimedAnim *v14; // r0
  CTaskSimpleAchieveHeading *v15; // r0

  v5 = 0;
  if ( iSubTaskType == 413 )
  {
    v14 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x34u);
    CTaskSimpleRunTimedAnim::CTaskSimpleRunTimedAnim(
      v14,
      ANIM_STD_PED,
      ANIM_STD_HANDSUP,
      4.0,
      -4.0,
      3000,
      413,
      "HandsUp",
      0);
    v5 = v15;
    v15->_vptr$CTask = (int (**)(void))&off_6657F0;
  }
  else if ( iSubTaskType == 902 )
  {
    v5 = (CTaskSimpleAchieveHeading *)CTask::operator new(0x18u);
    m_pHassleCop = this->m_pHassleCop;
    m_pMat = pPed->m_pMat;
    v8 = m_pHassleCop->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pPed->m_transform;
    p_x = &v8->tx;
    v11 = *(_QWORD *)&p_tx->m_translate.x;
    if ( !v8 )
      p_x = &m_pHassleCop->m_transform.m_translate.x;
    RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(*p_x, p_x[1], *(float *)&v11, *((float *)&v11 + 1));
    v13 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
    CTaskSimpleAchieveHeading::CTaskSimpleAchieveHeading(v5, v13, 0.5, 0.2);
  }
  return v5;
}
// 51176C: variable 'v15' is possibly undefined
// 6657F0: using guessed type void *off_6657F0;
// 676D34: using guessed type void *`vtable for'CTaskSimpleHandsUp;

//----- (00511790) --------------------------------------------------------
CTask *__fastcall CTaskComplexPresentIDToCop::CreateFirstSubTask(CTaskComplexPresentIDToCop *this, CPed *pPed)
{
  CTaskSimpleAchieveHeading *v4; // r4
  CPed *m_pHassleCop; // r0
  CMatrix *m_pMat; // r1
  CMatrix *v7; // r6
  CSimpleTransform *p_tx; // r3
  float *p_x; // r1
  __int64 v10; // r2
  float RadianAngleBetweenPoints; // r0
  float v12; // r1
  CTask *result; // r0

  v4 = (CTaskSimpleAchieveHeading *)CTask::operator new(0x18u);
  m_pHassleCop = this->m_pHassleCop;
  m_pMat = pPed->m_pMat;
  v7 = m_pHassleCop->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  p_x = &v7->tx;
  v10 = *(_QWORD *)&p_tx->m_translate.x;
  if ( !v7 )
    p_x = &m_pHassleCop->m_transform.m_translate.x;
  RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(*p_x, p_x[1], *(float *)&v10, *((float *)&v10 + 1));
  v12 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
  sub_19DE08(v4, v12, 0.5, 0.2);
  return result;
}

//----- (005117F8) --------------------------------------------------------
CTask *__fastcall CTaskComplexPresentIDToCop::ControlSubTask(CTaskComplexPresentIDToCop *this, CPed *pPed)
{
  if ( this->m_pHassleCop )
    return this->m_pSubTask;
  else
    return 0;
}

//----- (00511804) --------------------------------------------------------
float __fastcall CTaskComplexPresentIDToCop::ComputeTargetHeading(
        const CTaskComplexPresentIDToCop *this,
        const CPed *ped)
{
  CPed *m_pHassleCop; // r12
  CMatrix *m_pMat; // r2
  CMatrix *v4; // r0
  CSimpleTransform *p_tx; // r3
  float *p_x; // r1
  __int64 v7; // r2
  float RadianAngleBetweenPoints; // r0

  m_pHassleCop = this->m_pHassleCop;
  m_pMat = ped->m_pMat;
  v4 = m_pHassleCop->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &ped->m_transform;
  p_x = &v4->tx;
  v7 = *(_QWORD *)&p_tx->m_translate.x;
  if ( !v4 )
    p_x = &m_pHassleCop->m_transform.m_translate.x;
  RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(*p_x, p_x[1], *(float *)&v7, *((float *)&v7 + 1));
  return sub_192588(RadianAngleBetweenPoints);
}

//----- (0051183C) --------------------------------------------------------
void __fastcall CTaskComplexDriveFireTruck::CTaskComplexDriveFireTruck(
        CTaskComplexDriveFireTruck *this,
        CVehicle *pVehicle,
        CPed *pColleague,
        const bool bIsDriver)
{
  CTaskComplex::CTaskComplex(this);
  this->m_bIsDriver = bIsDriver;
  this->m_pNearestFire = 0;
  this->_vptr$CTask = (int (**)(void))&off_66BA74;
  this->m_pColleague = pColleague;
  this->m_pVehicle = pVehicle;
  if ( pVehicle )
  {
    CEntity::RegisterReference(pVehicle, &this->m_pVehicle);
    pColleague = this->m_pColleague;
  }
  if ( pColleague )
    CEntity::RegisterReference(pColleague, &this->m_pColleague);
}
// 66BA74: using guessed type void *;

//----- (00511894) --------------------------------------------------------
void __fastcall CTaskComplexDriveFireTruck::~CTaskComplexDriveFireTruck(CTaskComplexDriveFireTruck *this)
{
  CVehicle *m_pVehicle; // r0
  CEntity **p_m_pVehicle; // r1
  CPed *m_pColleague; // r0

  p_m_pVehicle = &this->m_pVehicle;
  m_pVehicle = this->m_pVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66BA74;
  if ( m_pVehicle )
    CEntity::CleanUpOldReference(m_pVehicle, p_m_pVehicle);
  m_pColleague = this->m_pColleague;
  if ( m_pColleague )
    CEntity::CleanUpOldReference(m_pColleague, &this->m_pColleague);
  sub_18EDB4(this);
}
// 66BA74: using guessed type void *off_66BA74;

//----- (005118D0) --------------------------------------------------------
void __fastcall CTaskComplexDriveFireTruck::~CTaskComplexDriveFireTruck(CTaskComplexDriveFireTruck *this)
{
  CVehicle *m_pVehicle; // r0
  CEntity **p_m_pVehicle; // r1
  CPed *m_pColleague; // r0
  void *v5; // r0

  p_m_pVehicle = &this->m_pVehicle;
  m_pVehicle = this->m_pVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66BA74;
  if ( m_pVehicle )
    CEntity::CleanUpOldReference(m_pVehicle, p_m_pVehicle);
  m_pColleague = this->m_pColleague;
  if ( m_pColleague )
    CEntity::CleanUpOldReference(m_pColleague, &this->m_pColleague);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v5);
}
// 511906: variable 'v5' is possibly undefined
// 66BA74: using guessed type void *off_66BA74;

//----- (00511910) --------------------------------------------------------
CTask *__fastcall CTaskComplexDriveFireTruck::CreateNextSubTask(CTaskComplexDriveFireTruck *this, CPed *pPed)
{
  int v4; // r0
  CTask *result; // r0
  CTaskComplex *v6; // r0
  CTask *m_pNearestFire; // r4

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v4 == 109 )
  {
    if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
      return (CTask *)(*((int (__fastcall **)(CTaskComplexDriveFireTruck *, CPed *))this->_vptr$CTask + 11))(this, pPed);
    return 0;
  }
  if ( v4 != 710 )
    return 0;
  if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
    return 0;
  v6 = (CTaskComplex *)CTask::operator new(0x10u);
  m_pNearestFire = (CTask *)this->m_pNearestFire;
  CTaskComplex::CTaskComplex(v6);
  result[1].m_pParent = m_pNearestFire;
  result->_vptr$CTask = (int (**)(void))&off_66BAF4;
  return result;
}
// 511946: variable 'result' is possibly undefined
// 66BAF4: using guessed type void *;

//----- (00511970) --------------------------------------------------------
CTask *__fastcall CTaskComplexDriveFireTruck::CreateSubTask(
        const CTaskComplexDriveFireTruck *this,
        const int iSubTaskType,
        CPed *pPed)
{
  CTask *result; // r0
  CTaskSimpleCarDrive *v5; // r0
  CTaskComplexDriveToPoint *v6; // r0
  CTaskComplex *v7; // r0
  CTask *m_pNearestFire; // r4
  CTaskComplexCarDriveWander *v9; // r0

  result = 0;
  if ( iSubTaskType > 709 )
  {
    if ( iSubTaskType == 711 )
    {
      v9 = (CTaskComplexCarDriveWander *)CTask::operator new(0x24u);
      CTaskComplexCarDriveWander::CTaskComplexCarDriveWander(v9, this->m_pVehicle, 0, 10.0);
    }
    else if ( iSubTaskType == 710 )
    {
      v6 = (CTaskComplexDriveToPoint *)CTask::operator new(0x3Cu);
      CTaskComplexDriveToPoint::CTaskComplexDriveToPoint(
        v6,
        this->m_pVehicle,
        &this->m_pNearestFire->m_vLocation,
        30.0,
        0,
        -1,
        25.0,
        2);
    }
  }
  else if ( iSubTaskType == 109 )
  {
    v7 = (CTaskComplex *)CTask::operator new(0x10u);
    m_pNearestFire = (CTask *)this->m_pNearestFire;
    CTaskComplex::CTaskComplex(v7);
    result[1].m_pParent = m_pNearestFire;
    result->_vptr$CTask = (int (**)(void))&off_66BAF4;
  }
  else if ( iSubTaskType == 709 )
  {
    v5 = (CTaskSimpleCarDrive *)CTask::operator new(0x60u);
    CTaskSimpleCarDrive::CTaskSimpleCarDrive(v5, this->m_pVehicle, 0, 0);
  }
  return result;
}
// 5119F4: variable 'result' is possibly undefined
// 66BAF4: using guessed type void *off_66BAF4;

//----- (00511A20) --------------------------------------------------------
CTask *__fastcall CTaskComplexDriveFireTruck::CreateFirstSubTask(CTaskComplexDriveFireTruck *this, CPed *pPed)
{
  CPed *v2; // r2
  CVehicle *m_pVehicle; // r2
  CMatrix *m_pMat; // r3
  const CVector *p_tx; // r1
  CFire *NearestFire; // r0
  int v8; // r1

  if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 && pPed->m_pMyVehicle )
  {
    if ( this->m_bIsDriver )
    {
      m_pVehicle = this->m_pVehicle;
      m_pMat = m_pVehicle->m_pMat;
      p_tx = (const CVector *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &m_pVehicle->m_transform.m_translate;
      NearestFire = CFireManager::FindNearestFire(&gFireManager, p_tx, 1, 1);
      v8 = 710;
      this->m_pNearestFire = NearestFire;
      if ( !NearestFire )
        v8 = 711;
    }
    else
    {
      v8 = 709;
    }
  }
  else
  {
    v8 = 1302;
  }
  return CTaskComplexDriveFireTruck::CreateSubTask(this, v8, v2);
}
// 511A6E: variable 'v2' is possibly undefined
// 676438: using guessed type CFireManager *gFireManager_ptr;

//----- (00511A7C) --------------------------------------------------------
CTask *__fastcall CTaskComplexDriveFireTruck::ControlSubTask(CTaskComplexDriveFireTruck *this, CPed *pPed)
{
  bool v4; // zf
  CTaskComplexCarDriveWander *m_pSubTask; // r4
  CVehicle *v7; // r2
  CMatrix *v8; // r3
  const CVector *p_m_translate; // r1
  CFire *NearestFire; // r0
  CTask *v11; // r1
  __int64 v12; // d16
  CVehicle *m_pVehicle; // r2
  CMatrix *m_pMat; // r3
  const CVector *p_tx; // r1

  v4 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
  if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
    v4 = pPed->m_pMyVehicle == 0;
  if ( v4 )
    return (CTask *)(*((int (__fastcall **)(CTaskComplexDriveFireTruck *, CPed *))this->_vptr$CTask + 11))(this, pPed);
  m_pSubTask = (CTaskComplexCarDriveWander *)this->m_pSubTask;
  if ( (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(this->m_pSubTask) != 710 )
  {
    if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 711
      || !this->m_bIsDriver )
    {
      return m_pSubTask;
    }
    m_pVehicle = this->m_pVehicle;
    m_pMat = m_pVehicle->m_pMat;
    p_tx = (const CVector *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &m_pVehicle->m_transform.m_translate;
    if ( !CFireManager::FindNearestFire(&gFireManager, p_tx, 1, 1) )
      return m_pSubTask;
    return (CTask *)(*((int (__fastcall **)(CTaskComplexDriveFireTruck *, CPed *))this->_vptr$CTask + 11))(this, pPed);
  }
  if ( this->m_bIsDriver && (*(_BYTE *)this->m_pNearestFire & 8) != 0 )
  {
    v7 = this->m_pVehicle;
    v8 = v7->m_pMat;
    p_m_translate = (const CVector *)&v8->tx;
    if ( !v8 )
      p_m_translate = &v7->m_transform.m_translate;
    NearestFire = CFireManager::FindNearestFire(&gFireManager, p_m_translate, 1, 1);
    if ( NearestFire )
    {
      if ( NearestFire != this->m_pNearestFire )
      {
        v11 = this->m_pSubTask;
        this->m_pNearestFire = NearestFire;
        v12 = *(_QWORD *)&NearestFire->m_vLocation.x;
        v11[5].m_pParent = (CTask *)LODWORD(NearestFire->m_vLocation.z);
        *(_QWORD *)&v11[4].m_pParent = v12;
      }
    }
    else
    {
      m_pSubTask = (CTaskComplexCarDriveWander *)CTask::operator new(0x24u);
      CTaskComplexCarDriveWander::CTaskComplexCarDriveWander(m_pSubTask, this->m_pVehicle, 0, 10.0);
    }
  }
  return m_pSubTask;
}
// 676438: using guessed type CFireManager *gFireManager_ptr;

//----- (00511B5C) --------------------------------------------------------
void __fastcall CTaskComplexUseSwatRope::CTaskComplexUseSwatRope(CTaskComplexUseSwatRope *this, const int iRopeID)
{
  int v3; // r0
  char v4; // r2

  CTaskComplex::CTaskComplex(this);
  v4 = *(_BYTE *)(v3 + 20);
  *(_DWORD *)(v3 + 12) = iRopeID;
  *(_DWORD *)(v3 + 16) = 0;
  *(_DWORD *)(v3 + 24) = 0;
  *(_BYTE *)(v3 + 20) = v4 & 0xFE;
  *(_DWORD *)v3 = &off_66BAB0;
}
// 511B6A: variable 'v3' is possibly undefined
// 66BAB0: using guessed type void *;

//----- (00511B88) --------------------------------------------------------
void __fastcall CTaskComplexUseSwatRope::CTaskComplexUseSwatRope(
        CTaskComplexUseSwatRope *this,
        const int iRopeID,
        CHeli *pHeli)
{
  char v6; // r1

  CTaskComplex::CTaskComplex(this);
  v6 = *((_BYTE *)this + 20);
  this->m_iRopeID = iRopeID;
  this->m_fPositionAlongRope = 0.0;
  *((_BYTE *)this + 20) = v6 | 1;
  this->_vptr$CTask = (int (**)(void))&off_66BAB0;
  this->m_pHeli = pHeli;
  CEntity::RegisterReference(pHeli, &this->m_pHeli);
}
// 66BAB0: using guessed type void *off_66BAB0;

//----- (00511BCC) --------------------------------------------------------
void __fastcall CTaskComplexUseSwatRope::~CTaskComplexUseSwatRope(CTaskComplexUseSwatRope *this)
{
  int v2; // r1
  CHeli *m_pHeli; // r0

  v2 = *((unsigned __int8 *)this + 20);
  this->_vptr$CTask = (int (**)(void))&off_66BAB0;
  if ( v2 << 31 )
  {
    m_pHeli = this->m_pHeli;
    if ( m_pHeli )
      CEntity::CleanUpOldReference(m_pHeli, &this->m_pHeli);
  }
  sub_18EDB4(this);
}
// 66BAB0: using guessed type void *off_66BAB0;

//----- (00511C00) --------------------------------------------------------
void __fastcall CTaskComplexUseSwatRope::~CTaskComplexUseSwatRope(CTaskComplexUseSwatRope *this)
{
  int v2; // r1
  CHeli *m_pHeli; // r0
  void *v4; // r0

  v2 = *((unsigned __int8 *)this + 20);
  this->_vptr$CTask = (int (**)(void))&off_66BAB0;
  if ( v2 << 31 )
  {
    m_pHeli = this->m_pHeli;
    if ( m_pHeli )
      CEntity::CleanUpOldReference(m_pHeli, &this->m_pHeli);
  }
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 511C2E: variable 'v4' is possibly undefined
// 66BAB0: using guessed type void *off_66BAB0;

//----- (00511C38) --------------------------------------------------------
bool __fastcall CTaskComplexUseSwatRope::MakeAbortable(
        CTaskComplexUseSwatRope *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  int v8; // r1
  bool result; // r0
  int m_nPedFlags; // r1
  int m_nFlags; // r2

  if ( iPriority != 2
    && (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 10
    && (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 52
    && (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 58
    && (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 66
    && (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 64
    && (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 73
    && (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent) != 41
    && pPed->m_nHealth >= 20.0 )
  {
    return 0;
  }
  v8 = (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
        + 7))(
         this->m_pSubTask,
         pPed,
         iPriority,
         pEvent);
  result = 0;
  if ( v8 == 1 )
  {
    m_nPedFlags = (int)pPed->m_nPedFlags;
    m_nFlags = (int)pPed->m_nFlags;
    pPed->m_vecMoveSpeed.x = 0.0;
    pPed->m_vecMoveSpeed.y = 0.0;
    pPed->m_vecMoveSpeed.z = 0.0;
    *(_DWORD *)&pPed->m_nPedFlags = m_nPedFlags & 0xFFFFFFFE;
    *(_DWORD *)&pPed->m_nFlags = m_nFlags | 1;
    return 1;
  }
  return result;
}

//----- (00511CFA) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseSwatRope::CreateNextSubTask(CTaskComplexUseSwatRope *this, CPed *pPed)
{
  const CTaskComplexUseSwatRope *v3; // r0
  bool v4; // zf
  int v5; // r1

  v3 = (const CTaskComplexUseSwatRope *)(*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  v4 = v3 == (const CTaskComplexUseSwatRope *)&dword_C8;
  v5 = 1302;
  if ( v3 != (const CTaskComplexUseSwatRope *)&dword_C8 )
    v4 = v3 == (const CTaskComplexUseSwatRope *)((char *)&dword_C8 + 2);
  if ( !v4 )
  {
    if ( v3 != (const CTaskComplexUseSwatRope *)((char *)&elf_hash_bucket[42] + 3) )
      return 0;
    v5 = 202;
  }
  return CTaskComplexUseSwatRope::CreateSubTask(v3, v5, pPed);
}
// C8: using guessed type int dword_C8;
// FC: using guessed type int elf_hash_bucket[16411];

//----- (00511D2C) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseSwatRope::CreateSubTask(
        const CTaskComplexUseSwatRope *this,
        const int iSubTaskType,
        CPed *pPed)
{
  CTask *result; // r0
  CTaskSimple *v4; // r0
  char *v5; // r1
  CTaskSimpleRunAnim *v6; // r0
  void **v7; // r1
  CTaskSimple *v8; // r0
  int m_nFlags; // r1

  result = 0;
  if ( iSubTaskType <= 422 )
  {
    if ( iSubTaskType != 200 )
    {
      if ( iSubTaskType != 202 )
        return result;
      v4 = (CTaskSimple *)CTask::operator new(0x18u);
      CTaskSimple::CTaskSimple(v4);
      LOWORD(result[2]._vptr$CTask) = 0;
      result[2].m_pParent = (CTask *)&elf_hash_chain[8526];
      v5 = (char *)&`vtable for'CTaskSimplePause;
      result[1]._vptr$CTask = 0;
      result[1].m_pParent = 0;
      goto LABEL_10;
    }
    v8 = (CTaskSimple *)CTask::operator new(8u);
    CTaskSimple::CTaskSimple(v8);
    v7 = &`vtable for'CTaskSimpleNone;
LABEL_9:
    v5 = (char *)*v7;
LABEL_10:
    result->_vptr$CTask = (int (**)(void))(v5 + 8);
    return result;
  }
  if ( iSubTaskType != 1302 )
  {
    if ( iSubTaskType != 423 )
      return result;
    v6 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
    CTaskSimpleRunAnim::CTaskSimpleRunAnim(v6, ANIM_STD_PED, ANIM_STD_ABSEIL, 4.0, 423, "Abseil", 0);
    v7 = &`vtable for'CTaskSimpleAbseil;
    goto LABEL_9;
  }
  m_nFlags = (int)pPed->m_nFlags;
  result = 0;
  pPed->m_vecMoveSpeed.x = 0.0;
  pPed->m_vecMoveSpeed.y = 0.0;
  pPed->m_vecMoveSpeed.z = 0.0;
  *(_DWORD *)&pPed->m_nFlags = m_nFlags | 1;
  return result;
}
// 511D5A: variable 'result' is possibly undefined
// 10168: using guessed type int elf_hash_chain[22025];
// 678150: using guessed type void *`vtable for'CTaskSimpleNone;
// 678E00: using guessed type void *`vtable for'CTaskSimplePause;
// 679D78: using guessed type void *`vtable for'CTaskSimpleAbseil;

//----- (00511DD8) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseSwatRope::CreateFirstSubTask(CTaskComplexUseSwatRope *this, CPed *pPed)
{
  CTaskSimpleRunAnim *v2; // r0
  CTask *result; // r0

  v2 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
  CTaskSimpleRunAnim::CTaskSimpleRunAnim(v2, ANIM_STD_PED, ANIM_STD_ABSEIL, 4.0, 423, "Abseil", 0);
  result->_vptr$CTask = (int (**)(void))&off_6688E8;
  return result;
}
// 511E08: variable 'result' is possibly undefined
// 6688E8: using guessed type void *off_6688E8;
// 679D78: using guessed type void *`vtable for'CTaskSimpleAbseil;

//----- (00511E18) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseSwatRope::ControlSubTask(CTaskComplexUseSwatRope *this, CPed *pPed)
{
  CHeli *m_pHeli; // r0
  bool v5; // zf
  CTaskSimple *m_pSubTask; // r8
  int m_nPedFlags; // r0
  int m_nFlags; // r1
  int v9; // r0
  bool v10; // zf
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r4
  CSimpleTransform *p_tx; // r1
  __int64 v14; // d16
  CMatrix *v15; // r0
  float v16; // r1
  float y; // r1
  CMatrix *v18; // r3
  RwReal z; // r0
  float *p_tz; // r1
  float v21; // s0
  float m_fCurrentHeading; // s2
  CVector pResult; // [sp+Ch] [bp-2Ch] BYREF
  CVector pCoors; // [sp+18h] [bp-20h] BYREF

  if ( *((unsigned __int8 *)this + 20) << 31 )
  {
    m_pHeli = this->m_pHeli;
    v5 = m_pHeli == 0;
    if ( m_pHeli )
      v5 = m_pHeli->AutoPilot.Mission == 58;
    if ( v5 || m_pHeli->m_nHealth <= 0.0 )
    {
      m_pSubTask = 0;
      if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
             this->m_pSubTask,
             pPed,
             1,
             0) == 1 )
      {
        m_nPedFlags = (int)pPed->m_nPedFlags;
        pPed->m_vecMoveSpeed.x = 0.0;
        pPed->m_vecMoveSpeed.y = 0.0;
        pPed->m_vecMoveSpeed.z = 0.0;
        m_nFlags = (int)pPed->m_nFlags;
        *(_DWORD *)&pPed->m_nPedFlags = m_nPedFlags & 0xFFFFFFFE;
        *(_DWORD *)&pPed->m_nFlags = m_nFlags | 1;
        return m_pSubTask;
      }
    }
  }
  m_pSubTask = (CTaskSimple *)this->m_pSubTask;
  v9 = (*((int (__fastcall **)(CTaskSimple *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask);
  v10 = v9 == 423;
  if ( v9 != 423 )
    v10 = v9 == 202;
  if ( v10 )
  {
    m_pMat = pPed->m_pMat;
    p_m_transform = &pPed->m_transform;
    p_tx = &pPed->m_transform;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    v14 = *(_QWORD *)&p_tx->m_translate.x;
    pCoors.z = p_tx->m_translate.z;
    *(_QWORD *)&pCoors.x = v14;
    CPedPlacement::FindZCoorForPed(&pCoors);
    v15 = pPed->m_pMat;
    if ( v15 )
      p_m_transform = (CSimpleTransform *)&v15->tx;
    if ( (float)(p_m_transform->m_translate.z + -2.0) >= pCoors.z )
    {
      v16 = this->m_fPositionAlongRope + (float)(CTimer::ms_fTimeStep * 0.003);
      this->m_fPositionAlongRope = v16;
      if ( CRopes::FindCoorsAlongRope(this->m_iRopeID, v16, &pResult, 0) )
      {
        y = pResult.y;
        v18 = pPed->m_pMat;
        z = pResult.z;
        if ( v18 )
        {
          v18->tx = pResult.x;
          pPed->m_pMat->ty = y;
          p_tz = &pPed->m_pMat->tz;
        }
        else
        {
          pPed->m_transform.m_translate.x = pResult.x;
          pPed->m_transform.m_translate.y = y;
          p_tz = &pPed->m_transform.m_translate.z;
        }
        *p_tz = z;
        v21 = CTimer::ms_fTimeStep * -0.05;
        m_fCurrentHeading = pPed->m_fCurrentHeading;
        pPed->m_vecMoveSpeed.z = -0.03;
        pPed->m_fDesiredHeading = m_fCurrentHeading + v21;
        CPed::Say(pPed, 0xB1u, 0, 1.0, 0, 0, 0);
        return m_pSubTask;
      }
      if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
             this->m_pSubTask,
             pPed,
             1,
             0) != 1 )
        return m_pSubTask;
      m_pSubTask = (CTaskSimple *)CTask::operator new(8u);
      CTaskSimple::CTaskSimple(m_pSubTask);
    }
    else
    {
      if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
             this->m_pSubTask,
             pPed,
             1,
             0) != 1 )
        return m_pSubTask;
      m_pSubTask = (CTaskSimple *)CTask::operator new(8u);
      CTaskSimple::CTaskSimple(m_pSubTask);
    }
    m_pSubTask->_vptr$CTask = (int (**)(void))&off_668FF0;
  }
  return m_pSubTask;
}
// 668FF0: using guessed type void *off_668FF0;
// 678150: using guessed type void *`vtable for'CTaskSimpleNone;

//----- (00511FE8) --------------------------------------------------------
void __fastcall CTaskComplexUseWaterCannon::CTaskComplexUseWaterCannon(CTaskComplexUseWaterCannon *this, CFire *pFire)
{
  _DWORD *v3; // r0

  CTaskComplex::CTaskComplex(this);
  v3[3] = pFire;
  *v3 = &off_66BAF4;
}
// 511FF4: variable 'v3' is possibly undefined
// 66BAF4: using guessed type void *off_66BAF4;

//----- (00512008) --------------------------------------------------------
void __fastcall CTaskComplexUseWaterCannon::~CTaskComplexUseWaterCannon(CTaskComplexUseWaterCannon *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 512014: variable 'v1' is possibly undefined

//----- (00512018) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseWaterCannon::CreateNextSubTask(CTaskComplexUseWaterCannon *this, CPed *pPed)
{
  (*((void (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  return 0;
}

//----- (00512028) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseWaterCannon::CreateFirstSubTask(CTaskComplexUseWaterCannon *this, CPed *pPed)
{
  CTaskSimpleCarDrive *v3; // r0
  CTask *result; // r0

  v3 = (CTaskSimpleCarDrive *)CTask::operator new(0x60u);
  sub_18D108(v3, pPed->m_pMyVehicle, 0, 0);
  return result;
}

//----- (00512044) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseWaterCannon::ControlSubTask(CTaskComplexUseWaterCannon *this, CPed *pPed)
{
  char *m_pSubTask; // r4
  CVehicle *m_pMyVehicle; // r0
  CFire *m_pFire; // r1

  m_pSubTask = (char *)this->m_pSubTask;
  if ( (*(int (__fastcall **)(char *))(*(_DWORD *)m_pSubTask + 20))(m_pSubTask) == 709 )
  {
    m_pMyVehicle = pPed->m_pMyVehicle;
    if ( (*(_BYTE *)&m_pMyVehicle->m_info & 0xF8) == 24 && (m_pFire = this->m_pFire, *(_BYTE *)m_pFire << 31) )
    {
      CAutomobile::FireTruckControl((CAutomobile *)m_pMyVehicle, m_pFire);
    }
    else
    {
      m_pSubTask = (char *)CTask::operator new(0x70u);
      CTaskSimpleCarDrive::CTaskSimpleCarDrive((CTaskSimpleCarDrive *)m_pSubTask, pPed->m_pMyVehicle, 0, 0);
      *(_DWORD *)(m_pSubTask + 106) = 0;
      *(_DWORD *)(m_pSubTask + 102) = 0;
      *((_DWORD *)m_pSubTask + 24) = 0;
      *((_DWORD *)m_pSubTask + 25) = 0;
      *(_DWORD *)m_pSubTask = &off_66571C;
    }
  }
  return (CTask *)m_pSubTask;
}
// 66571C: using guessed type void *off_66571C;
// 676B38: using guessed type void *`vtable for'CTaskSimpleCarDriveTimed;

//----- (005120B8) --------------------------------------------------------
bool __fastcall CTaskComplexUseWaterCannon::ExtinguishFire(CTaskComplexUseWaterCannon *this, CPed *pPed)
{
  CVehicle *m_pMyVehicle; // r0
  CFire *m_pFire; // r1

  m_pMyVehicle = pPed->m_pMyVehicle;
  if ( (*(_BYTE *)&m_pMyVehicle->m_info & 0xF8) != 24 )
    return 1;
  m_pFire = this->m_pFire;
  if ( !(*(_BYTE *)m_pFire << 31) )
    return 1;
  CAutomobile::FireTruckControl((CAutomobile *)m_pMyVehicle, m_pFire);
  return 0;
}

//----- (005120E4) --------------------------------------------------------
void __fastcall CTaskComplexExtinguishFireOnFoot::CTaskComplexExtinguishFireOnFoot(
        CTaskComplexExtinguishFireOnFoot *this,
        const CVector *vFirePos)
{
  int v3; // r0
  __int64 v4; // d16

  CTaskComplex::CTaskComplex(this);
  *(_DWORD *)v3 = &off_66BB30;
  v4 = *(_QWORD *)&vFirePos->x;
  *(RwReal *)(v3 + 20) = vFirePos->z;
  *(_QWORD *)(v3 + 12) = v4;
}
// 5120F6: variable 'v3' is possibly undefined
// 66BB30: using guessed type void *off_66BB30;

//----- (00512110) --------------------------------------------------------
void __fastcall CTaskComplexExtinguishFireOnFoot::~CTaskComplexExtinguishFireOnFoot(
        CTaskComplexExtinguishFireOnFoot *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 51211C: variable 'v1' is possibly undefined

//----- (00512120) --------------------------------------------------------
CTask *__fastcall CTaskComplexExtinguishFireOnFoot::CreateNextSubTask(
        CTaskComplexExtinguishFireOnFoot *this,
        CPed *pPed)
{
  int v4; // r0
  CTaskSimpleGunControl *v5; // r0
  CTask *result; // r0

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v4 == 1020 )
    return (CTask *)(*((int (__fastcall **)(CTaskComplexExtinguishFireOnFoot *, CPed *))this->_vptr$CTask + 11))(
                      this,
                      pPed);
  if ( v4 != 903 )
    return 0;
  v5 = (CTaskSimpleGunControl *)CTask::operator new(0x3Cu);
  CTaskSimpleGunControl::CTaskSimpleGunControl(v5, 0, &this->m_vFirePos, 0, 4, 1, -1);
  return result;
}

//----- (0051217C) --------------------------------------------------------
CTask *__fastcall CTaskComplexExtinguishFireOnFoot::CreateFirstSubTask(
        CTaskComplexExtinguishFireOnFoot *this,
        CPed *pPed)
{
  CSimpleTransform *p_m_transform; // r6
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r1
  CTask *v7; // r9
  CFire *NearestFire; // r5
  CMatrix *v9; // r0
  float32x2_t v10; // d16
  unsigned __int64 v11; // d1
  __int64 v12; // d16
  CTaskComplexGoToPointAndStandStill *v13; // r0
  CTask *v14; // r0

  p_m_transform = &pPed->m_transform;
  m_pMat = pPed->m_pMat;
  p_tx = &pPed->m_transform;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  v7 = 0;
  NearestFire = CFireManager::FindNearestFire(&gFireManager, &p_tx->m_translate, 0, 1);
  if ( NearestFire )
  {
    v9 = pPed->m_pMat;
    v7 = 0;
    if ( v9 )
      p_m_transform = (CSimpleTransform *)&v9->tx;
    v10.n64_u64[0] = vsub_f32(
                       *(float32x2_t *)&p_m_transform->m_translate.y,
                       *(float32x2_t *)&NearestFire->m_vLocation.y).n64_u64[0];
    v11 = vmul_f32(v10, v10).n64_u64[0];
    if ( (float)((float)((float)((float)(p_m_transform->m_translate.x - NearestFire->m_vLocation.x)
                               * (float)(p_m_transform->m_translate.x - NearestFire->m_vLocation.x))
                       + *(float *)&v11)
               + *((float *)&v11 + 1)) < 100.0 )
    {
      v12 = *(_QWORD *)&NearestFire->m_vLocation.x;
      this->m_vFirePos.z = NearestFire->m_vLocation.z;
      *(_QWORD *)&this->m_vFirePos.x = v12;
      v13 = (CTaskComplexGoToPointAndStandStill *)CTask::operator new(0x28u);
      CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(
        v13,
        6,
        &NearestFire->m_vLocation,
        2.0,
        2.0,
        0,
        0);
      return v14;
    }
  }
  return v7;
}
// 512224: variable 'v14' is possibly undefined
// 676438: using guessed type CFireManager *gFireManager_ptr;

//----- (0051223C) --------------------------------------------------------
CFire *__fastcall CTaskComplexExtinguishFireOnFoot::FindNearestFire(CTaskComplexExtinguishFireOnFoot *this, CPed *pPed)
{
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_m_transform; // r6
  CSimpleTransform *p_tx; // r1
  CFire *v6; // r4
  CFire *NearestFire; // r0
  CMatrix *v8; // r1
  float32x2_t v9; // d16
  unsigned __int64 v10; // d1

  m_pMat = pPed->m_pMat;
  p_m_transform = &pPed->m_transform;
  p_tx = &pPed->m_transform;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  v6 = 0;
  NearestFire = CFireManager::FindNearestFire(&gFireManager, &p_tx->m_translate, 0, 1);
  if ( NearestFire )
  {
    v8 = pPed->m_pMat;
    if ( v8 )
      p_m_transform = (CSimpleTransform *)&v8->tx;
    v9.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.y, *(float32x2_t *)&NearestFire->m_vLocation.y).n64_u64[0];
    v10 = vmul_f32(v9, v9).n64_u64[0];
    if ( (float)((float)((float)((float)(p_m_transform->m_translate.x - NearestFire->m_vLocation.x)
                               * (float)(p_m_transform->m_translate.x - NearestFire->m_vLocation.x))
                       + *(float *)&v10)
               + *((float *)&v10 + 1)) < 100.0 )
      return NearestFire;
  }
  return v6;
}
// 676438: using guessed type CFireManager *gFireManager_ptr;

//----- (005122B8) --------------------------------------------------------
CTask *__fastcall CTaskComplexExtinguishFireOnFoot::ControlSubTask(CTaskComplexExtinguishFireOnFoot *this, CPed *pPed)
{
  return this->m_pSubTask;
}

//----- (005122BC) --------------------------------------------------------
CTask *__fastcall CTaskSimpleGiveCPR::Clone(const CTaskSimpleGiveCPR *this)
{
  CTaskSimple *v2; // r0
  CTask *m_pAccident; // r4
  CTask *result; // r0
  char v5; // r3

  v2 = (CTaskSimple *)CTask::operator new(0x18u);
  m_pAccident = (CTask *)this->m_pAccident;
  CTaskSimple::CTaskSimple(v2);
  v5 = (char)result[1]._vptr$CTask;
  result[1].m_pParent = m_pAccident;
  result[2]._vptr$CTask = 0;
  result->_vptr$CTask = (int (**)(void))&off_66B98C;
  LOBYTE(result[1]._vptr$CTask) = v5 & 0xFC | 1;
  return result;
}
// 5122D2: variable 'result' is possibly undefined
// 66B98C: using guessed type void *off_66B98C;

//----- (005122F0) --------------------------------------------------------
int __fastcall CTaskSimpleGiveCPR::GetTaskType(const CTaskSimpleGiveCPR *this)
{
  return 102;
}

//----- (005122F4) --------------------------------------------------------
void __fastcall CTaskSimpleGiveCPR::Serialize(CTaskSimpleGiveCPR *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CPed *m_pInjuredPed; // r0
  int v5; // r4
  _DWORD *v6; // r5
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r4

  v2 = (*((int (__fastcall **)(CTaskSimpleGiveCPR *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskSimpleGiveCPR *))this->_vptr$CTask + 5))(this) == 102 )
  {
    m_pInjuredPed = this->m_pAccident->m_pInjuredPed;
    if ( m_pInjuredPed )
    {
      v5 = GettPoolPedRef(m_pInjuredPed);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    j_free(v7);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskSimpleGiveCPR *))this->_vptr$CTask + 5))(this);
    sub_1941C4(102, v8);
  }
}

//----- (005123C4) --------------------------------------------------------
CTask *__fastcall CTaskComplexTreatAccident::Clone(const CTaskComplexTreatAccident *this)
{
  CTaskComplex *v2; // r0
  CTask *m_pAccident; // r4
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x10u);
  m_pAccident = (CTask *)this->m_pAccident;
  CTaskComplex::CTaskComplex(v2);
  result[1].m_pParent = m_pAccident;
  result->_vptr$CTask = (int (**)(void))&off_66B9C0;
  return result;
}
// 5123D8: variable 'result' is possibly undefined
// 66B9C0: using guessed type void *;
// 6780A4: using guessed type void *`vtable for'CTaskComplexTreatAccident;

//----- (005123E8) --------------------------------------------------------
int __fastcall CTaskComplexTreatAccident::GetTaskType(const CTaskComplexTreatAccident *this)
{
  return 101;
}

//----- (005123EC) --------------------------------------------------------
void __fastcall CTaskComplexTreatAccident::Serialize(CTaskComplexTreatAccident *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CPed *m_pInjuredPed; // r0
  int v5; // r4
  _DWORD *v6; // r5
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r4

  v2 = (*((int (__fastcall **)(CTaskComplexTreatAccident *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexTreatAccident *))this->_vptr$CTask + 5))(this) == 101 )
  {
    m_pInjuredPed = this->m_pAccident->m_pInjuredPed;
    if ( m_pInjuredPed )
    {
      v5 = GettPoolPedRef(m_pInjuredPed);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    j_free(v7);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexTreatAccident *))this->_vptr$CTask + 5))(this);
    sub_1941C4(101, v8);
  }
}

//----- (005124BC) --------------------------------------------------------
CTask *__fastcall CTaskComplexMedicTreatInjuredPed::Clone(const CTaskComplexMedicTreatInjuredPed *this)
{
  CTaskComplex *v2; // r0
  CPed *m_pColleague; // r5
  CVehicle *m_pAmbulance; // r8
  CTaskComplex *v5; // r4

  v2 = (CTaskComplex *)CTask::operator new(0x2Cu);
  m_pColleague = this->m_pColleague;
  m_pAmbulance = this->m_pAmbulance;
  v5 = v2;
  LOBYTE(this) = this->m_bIsDriver;
  CTaskComplex::CTaskComplex(v2);
  LOBYTE(v5[1].m_pSubTask) = (_BYTE)this;
  v5[2]._vptr$CTask = 0;
  LOBYTE(v5[3].m_pParent) = 0;
  v5->_vptr$CTask = (int (**)(void))&off_66B9FC;
  v5[1].CTask = (CTask)__PAIR64__((unsigned int)m_pColleague, (unsigned int)m_pAmbulance);
  if ( m_pAmbulance )
  {
    CEntity::RegisterReference(m_pAmbulance, (CEntity **)&v5[1]);
    m_pColleague = (CPed *)v5[1].m_pParent;
  }
  if ( m_pColleague )
    CEntity::RegisterReference(m_pColleague, (CEntity **)&v5[1].m_pParent);
  return v5;
}
// 66B9FC: using guessed type void *off_66B9FC;

//----- (00512520) --------------------------------------------------------
int __fastcall CTaskComplexMedicTreatInjuredPed::GetTaskType(const CTaskComplexMedicTreatInjuredPed *this)
{
  return 100;
}

//----- (00512524) --------------------------------------------------------
void __fastcall CTaskComplexMedicTreatInjuredPed::Serialize(CTaskComplexMedicTreatInjuredPed *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CVehicle *m_pAmbulance; // r0
  int v5; // r5
  _DWORD *v6; // r6
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r5
  CPed *m_pColleague; // r0
  int v11; // r5
  _DWORD *v12; // r6
  void *v13; // r0
  _DWORD *v14; // r5

  v2 = (*((int (__fastcall **)(CTaskComplexMedicTreatInjuredPed *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexMedicTreatInjuredPed *))this->_vptr$CTask + 5))(this) == 100 )
  {
    m_pAmbulance = this->m_pAmbulance;
    if ( m_pAmbulance )
    {
      v5 = GettPoolVehicleRef(m_pAmbulance);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    free(v7);
    m_pColleague = this->m_pColleague;
    if ( m_pColleague )
    {
      v11 = GettPoolPedRef(m_pColleague);
      if ( UseDataFence )
        AddDataFence();
      v12 = malloc(4u);
      *v12 = v11;
      CGenericGameStorage::_SaveDataToWorkBuffer(v12, 4);
      v13 = v12;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v14 = malloc(4u);
      *v14 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v14, 4);
      v13 = v14;
    }
    free(v13);
    if ( UseDataFence )
      AddDataFence();
    sub_19E9A8(&this->m_bIsDriver, 1);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexMedicTreatInjuredPed *))this->_vptr$CTask + 5))(this);
    sub_1941C4(100, v8);
  }
}

//----- (00512670) --------------------------------------------------------
CTask *__fastcall CTaskComplexPresentIDToCop::Clone(const CTaskComplexPresentIDToCop *this)
{
  void *v2; // r5
  CPed *m_pHassleCop; // r4

  v2 = CTask::operator new(0x10u);
  m_pHassleCop = this->m_pHassleCop;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *(_DWORD *)v2 = &off_66BA38;
  *((_DWORD *)v2 + 3) = m_pHassleCop;
  CEntity::RegisterReference(m_pHassleCop, (CEntity **)v2 + 3);
  return (CTask *)v2;
}
// 66BA38: using guessed type void *off_66BA38;

//----- (005126A4) --------------------------------------------------------
int __fastcall CTaskComplexPresentIDToCop::GetTaskType(const CTaskComplexPresentIDToCop *this)
{
  return 106;
}

//----- (005126A8) --------------------------------------------------------
CTask *__fastcall CTaskComplexDriveFireTruck::Clone(const CTaskComplexDriveFireTruck *this)
{
  void *v2; // r4
  CVehicle *m_pVehicle; // r8
  CPed *m_pColleague; // r5

  v2 = CTask::operator new(0x1Cu);
  m_pVehicle = this->m_pVehicle;
  m_pColleague = this->m_pColleague;
  LOBYTE(this) = this->m_bIsDriver;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_BYTE *)v2 + 16) = (_BYTE)this;
  *((_DWORD *)v2 + 6) = 0;
  *(_DWORD *)v2 = &off_66BA74;
  *((_DWORD *)v2 + 5) = m_pColleague;
  *((_DWORD *)v2 + 3) = m_pVehicle;
  if ( m_pVehicle )
  {
    CEntity::RegisterReference(m_pVehicle, (CEntity **)v2 + 3);
    m_pColleague = (CPed *)*((_DWORD *)v2 + 5);
  }
  if ( m_pColleague )
    CEntity::RegisterReference(m_pColleague, (CEntity **)v2 + 5);
  return (CTask *)v2;
}
// 66BA74: using guessed type void *off_66BA74;

//----- (0051270C) --------------------------------------------------------
int __fastcall CTaskComplexDriveFireTruck::GetTaskType(const CTaskComplexDriveFireTruck *this)
{
  return 107;
}

//----- (00512710) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseSwatRope::Clone(const CTaskComplexUseSwatRope *this)
{
  char v2; // r6
  CTaskComplex *v3; // r0
  int m_iRopeID; // r8
  CTaskComplex *v5; // r4
  char m_pSubTask; // r1
  CHeli *m_pHeli; // r5
  int m_pSubTask_low; // r1

  v2 = *((_BYTE *)this + 20);
  v3 = (CTaskComplex *)CTask::operator new(0x1Cu);
  m_iRopeID = this->m_iRopeID;
  v5 = v3;
  if ( (v2 & 1) != 0 )
  {
    m_pHeli = this->m_pHeli;
    CTaskComplex::CTaskComplex(v3);
    v5[1]._vptr$CTask = (int (**)(void))m_iRopeID;
    v5[1].m_pParent = 0;
    m_pSubTask_low = LOBYTE(v5[1].m_pSubTask);
    v5->_vptr$CTask = (int (**)(void))&off_66BAB0;
    LOBYTE(v5[1].m_pSubTask) = m_pSubTask_low | 1;
    v5[2]._vptr$CTask = (int (**)(void))m_pHeli;
    CEntity::RegisterReference(m_pHeli, (CEntity **)&v5[2]);
  }
  else
  {
    CTaskComplex::CTaskComplex(v3);
    m_pSubTask = (char)v5[1].m_pSubTask;
    v5[1]._vptr$CTask = (int (**)(void))m_iRopeID;
    v5[1].m_pParent = 0;
    v5[2]._vptr$CTask = 0;
    LOBYTE(v5[1].m_pSubTask) = m_pSubTask & 0xFE;
    v5->_vptr$CTask = (int (**)(void))&off_66BAB0;
  }
  return v5;
}
// 66BAB0: using guessed type void *off_66BAB0;

//----- (00512790) --------------------------------------------------------
int __fastcall CTaskComplexUseSwatRope::GetTaskType(const CTaskComplexUseSwatRope *this)
{
  return 108;
}

//----- (00512794) --------------------------------------------------------
bool __fastcall CTaskComplexUseSwatRope::IsInterruptable(const CTaskComplexUseSwatRope *this, const CPed *pPed)
{
  return 0;
}

//----- (00512798) --------------------------------------------------------
bool __fastcall CTaskComplexUseSwatRope::AbortUrgently(CTaskComplexUseSwatRope *this, CPed *pPed)
{
  return 0;
}

//----- (0051279C) --------------------------------------------------------
CTask *__fastcall CTaskComplexUseWaterCannon::Clone(const CTaskComplexUseWaterCannon *this)
{
  CTaskComplex *v2; // r0
  CTask *m_pFire; // r4
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x10u);
  m_pFire = (CTask *)this->m_pFire;
  CTaskComplex::CTaskComplex(v2);
  result[1].m_pParent = m_pFire;
  result->_vptr$CTask = (int (**)(void))&off_66BAF4;
  return result;
}
// 5127B0: variable 'result' is possibly undefined
// 66BAF4: using guessed type void *off_66BAF4;

//----- (005127C0) --------------------------------------------------------
int __fastcall CTaskComplexUseWaterCannon::GetTaskType(const CTaskComplexUseWaterCannon *this)
{
  return 109;
}

//----- (005127C4) --------------------------------------------------------
CTask *__fastcall CTaskComplexExtinguishFireOnFoot::Clone(const CTaskComplexExtinguishFireOnFoot *this)
{
  CTaskComplex *v2; // r0
  CTask *result; // r0
  __int64 v4; // d16

  v2 = (CTaskComplex *)CTask::operator new(0x18u);
  CTaskComplex::CTaskComplex(v2);
  result->_vptr$CTask = (int (**)(void))&off_66BB30;
  v4 = *(_QWORD *)&this->m_vFirePos.x;
  result[2].m_pParent = (CTask *)LODWORD(this->m_vFirePos.z);
  *(_QWORD *)&result[1].m_pParent = v4;
  return result;
}
// 5127DC: variable 'result' is possibly undefined
// 66BB30: using guessed type void *;

//----- (005127F0) --------------------------------------------------------
int __fastcall CTaskComplexExtinguishFireOnFoot::GetTaskType(const CTaskComplexExtinguishFireOnFoot *this)
{
  return 110;
}

//----- (005127F4) --------------------------------------------------------
void __fastcall CTaskComplexExtinguishFireOnFoot::Serialize(CTaskComplexExtinguishFireOnFoot *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  _DWORD *v4; // r5
  __int64 v5; // d16
  int v6; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexExtinguishFireOnFoot *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexExtinguishFireOnFoot *))this->_vptr$CTask + 5))(this) == 110 )
  {
    if ( UseDataFence )
      AddDataFence();
    v4 = malloc(0xCu);
    v5 = *(_QWORD *)&this->m_vFirePos.x;
    v4[2] = LODWORD(this->m_vFirePos.z);
    *(_QWORD *)v4 = v5;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 12);
    j_free(v4);
  }
  else
  {
    v6 = (*((int (__fastcall **)(CTaskComplexExtinguishFireOnFoot *))this->_vptr$CTask + 5))(this);
    sub_1941C4(110, v6);
  }
}

//----- (00512898) --------------------------------------------------------
void __fastcall CTaskComplexWanderMedic::~CTaskComplexWanderMedic(CTaskComplexWanderMedic *this)
{
  void *v1; // r0

  CTaskComplexWander::~CTaskComplexWander(this);
  sub_197118(v1);
}
// 5128A4: variable 'v1' is possibly undefined

//----- (005128A8) --------------------------------------------------------
CTask *__fastcall CTaskComplexWanderMedic::Clone(const CTaskComplexWanderMedic *this)
{
  CTaskComplexWander *v2; // r0
  CTask *result; // r0

  v2 = (CTaskComplexWander *)CTask::operator new(0x28u);
  CTaskComplexWander::CTaskComplexWander(
    v2,
    this->m_iMoveState,
    this->m_iDir,
    *((_BYTE *)&this->CTaskComplexWander + 36) & 1,
    0.5);
  result->_vptr$CTask = (int (**)(void))&off_66BB6C;
  return result;
}
// 5128DC: variable 'result' is possibly undefined
// 66BB6C: using guessed type void *off_66BB6C;
// 676B0C: using guessed type void *`vtable for'CTaskComplexWanderMedic;

//----- (005128EC) --------------------------------------------------------
int __fastcall CTaskComplexWander::GetTaskType(const CTaskComplexWander *this)
{
  return 912;
}

//----- (005128F2) --------------------------------------------------------
int __fastcall CTaskComplexWanderMedic::GetWanderType(const CTaskComplexWanderMedic *this)
{
  return 2;
}

//----- (005128F8) --------------------------------------------------------
void __fastcall CTaskComplexWanderFlee::CTaskComplexWanderFlee(
        CTaskComplexWanderFlee *this,
        const int iMoveState,
        const UINT8 iDir)
{
  _DWORD *v3; // r0

  CTaskComplexWander::CTaskComplexWander(this, iMoveState, iDir, 0, 0.5);
  *v3 = &off_66BBB8;
}
// 51291A: variable 'v3' is possibly undefined
// 66BBB8: using guessed type void *;

//----- (0051292C) --------------------------------------------------------
void __fastcall CTaskComplexWanderFlee::~CTaskComplexWanderFlee(CTaskComplexWanderFlee *this)
{
  void *v1; // r0

  CTaskComplexWander::~CTaskComplexWander(this);
  sub_197118(v1);
}
// 512938: variable 'v1' is possibly undefined

//----- (00512940) --------------------------------------------------------
void __fastcall CTaskComplexFleePoint::CTaskComplexFleePoint(
        CTaskComplexFleePoint *this,
        const CVector *vFleePos,
        const bool bScream,
        const float fSafeDistance,
        const int iFleeTime)
{
  int v8; // r0
  __int64 v9; // d16
  uint32 v10; // r2

  CTaskComplex::CTaskComplex(this);
  *(_DWORD *)v8 = &off_66BC04;
  v9 = *(_QWORD *)&vFleePos->x;
  *(RwReal *)(v8 + 20) = vFleePos->z;
  *(_DWORD *)(v8 + 36) = iFleeTime;
  *(_DWORD *)(v8 + 40) = 0;
  *(_DWORD *)(v8 + 44) = 0;
  *(_WORD *)(v8 + 48) = 0;
  *(const float *)(v8 + 52) = fSafeDistance;
  *(_BYTE *)(v8 + 56) = bScream;
  *(_BYTE *)(v8 + 57) = 0;
  *(_QWORD *)(v8 + 12) = v9;
  if ( iFleeTime != -1 )
  {
    v10 = CTimer::m_snTimeInMilliseconds;
    *(_BYTE *)(v8 + 48) = 1;
    *(_DWORD *)(v8 + 40) = v10;
    *(_DWORD *)(v8 + 44) = iFleeTime;
  }
}
// 51295A: variable 'v8' is possibly undefined
// 66BC04: using guessed type void *;

//----- (005129A8) --------------------------------------------------------
void __fastcall CTaskComplexFleePoint::~CTaskComplexFleePoint(CTaskComplexFleePoint *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 5129B4: variable 'v1' is possibly undefined

//----- (005129B8) --------------------------------------------------------
bool __fastcall CTaskComplexFleePoint::MakeAbortable(
        CTaskComplexFleePoint *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  int v4; // r12

  if ( !iPriority )
  {
    v4 = CTimer::m_snTimeInMilliseconds;
    this->m_timer.m_bIsActive = 1;
    this->m_iFleeTime = -1;
    this->m_timer.m_iStartTime = v4;
    this->m_timer.m_iDuration = -1;
  }
  return (*((int (__fastcall **)(CTask *, CPed *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
           this->m_pSubTask,
           pPed);
}

//----- (005129F0) --------------------------------------------------------
CTask *__fastcall CTaskComplexFleePoint::CreateFirstSubTask(CTaskComplexFleePoint *this, CPed *pPed)
{
  bool v4; // zf
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r4
  CSimpleTransform *p_tx; // r1
  float y; // s2
  float v9; // s6
  float v10; // r6
  float v11; // r8
  float v12; // r6
  int v13; // r0
  float v14; // s0
  CMatrix *v15; // r0
  float v16; // s6
  float v17; // s4
  float v18; // s0
  int v19; // r1
  CVector v21; // [sp+4h] [bp-2Ch] BYREF

  v4 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
  if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
    v4 = pPed->m_pMyVehicle == 0;
  if ( v4 )
  {
    m_pMat = pPed->m_pMat;
    p_m_transform = &pPed->m_transform;
    p_tx = &pPed->m_transform;
    y = this->m_vFleePos.y;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    v9 = p_tx->m_translate.y;
    v21.x = p_tx->m_translate.x - this->m_vFleePos.x;
    v21.z = 0.0;
    v21.y = v9 - y;
    CVector::Normalise(&v21);
    v10 = (float)((float)((float)rand() * 4.6566e-10) * 0.66) + -0.33;
    v11 = cosf(v10);
    v12 = sinf(v10);
    v13 = rand();
    v19 = 900;
    v14 = (float)v13;
    v15 = pPed->m_pMat;
    v16 = v11 * v21.x;
    v17 = v12 * v21.y;
    if ( v15 )
      p_m_transform = (CSimpleTransform *)&v15->tx;
    v18 = (float)((float)(v14 * 4.6566e-10) * 3.0) + 3.0;
    this->m_vTargetPoint.x = p_m_transform->m_translate.x + (float)(v18 * (float)(v16 + v17));
    this->m_vTargetPoint.y = (float)(v18 * (float)(v16 - v17)) + p_m_transform->m_translate.y;
    this->m_vTargetPoint.z = p_m_transform->m_translate.z + 0.0;
  }
  else
  {
    v19 = 714;
  }
  return CTaskComplexFleePoint::CreateSubTask(this, v19);
}

//----- (00512B24) --------------------------------------------------------
CTask *__fastcall CTaskComplexFleePoint::CreateSubTask(CTaskComplexFleePoint *this, const int iSubTaskType)
{
  CTaskSimpleGoToPoint *v3; // r4
  CTaskSimpleRunAnim *v4; // r5
  CTaskSimpleTired *v5; // r5

  v3 = 0;
  if ( iSubTaskType >= 900 )
  {
    if ( iSubTaskType == 900 )
    {
      v3 = (CTaskSimpleGoToPoint *)CTask::operator new(0x2Cu);
      CTaskSimpleGoToPoint::CTaskSimpleGoToPoint(v3, 7, &this->m_vTargetPoint, 0.5, 0, 0);
    }
    else if ( iSubTaskType == 903 )
    {
      v3 = (CTaskSimpleGoToPoint *)CTask::operator new(0x28u);
      CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(
        (CTaskComplexGoToPointAndStandStill *)v3,
        7,
        &this->m_vTargetPoint,
        0.5,
        2.0,
        0,
        0);
    }
  }
  else if ( iSubTaskType == 244 )
  {
    v3 = (CTaskSimpleGoToPoint *)CTask::operator new(0x40u);
    CTaskComplexSequence::CTaskComplexSequence((CTaskComplexSequence *)v3);
    v4 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
    CTaskSimpleRunAnim::CTaskSimpleRunAnim(v4, ANIM_STD_PED, ANIM_STD_LOOK, 4.0, 0);
    CTaskComplexSequence::AddTask((CTaskComplexSequence *)v3, v4);
    v5 = (CTaskSimpleTired *)CTask::operator new(0x1Cu);
    CTaskSimpleTired::CTaskSimpleTired(v5, 2000);
    CTaskComplexSequence::AddTask((CTaskComplexSequence *)v3, v5);
  }
  else if ( iSubTaskType == 714 )
  {
    v3 = (CTaskSimpleGoToPoint *)CTask::operator new(0x14u);
    CTaskComplex::CTaskComplex((CTaskComplex *)v3);
    v3->m_vTarget.x = 0.0;
    LOWORD(v3->m_vTarget.y) = 1;
    v3->_vptr$CTask = (int (**)(void))&off_66AF80;
  }
  return v3;
}
// 66AF80: using guessed type void *off_66AF80;
// 677A98: using guessed type void *`vtable for'CTaskComplexLeaveAnyCar;

//----- (00512C1C) --------------------------------------------------------
void __fastcall CTaskComplexFleePoint::ComputeTargetPoint(CTaskComplexFleePoint *this, const CPed *pPed)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r5
  CSimpleTransform *p_tx; // r1
  float y; // s2
  float v8; // s6
  float v9; // r6
  float v10; // r9
  float v11; // r6
  float v12; // s0
  CMatrix *v13; // r0
  float v14; // s6
  float v15; // s4
  float v16; // s0
  CVector v17; // [sp+4h] [bp-2Ch] BYREF

  m_pMat = pPed->m_pMat;
  p_m_transform = &pPed->m_transform;
  p_tx = &pPed->m_transform;
  y = this->m_vFleePos.y;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  v8 = p_tx->m_translate.y;
  v17.x = p_tx->m_translate.x - this->m_vFleePos.x;
  v17.z = 0.0;
  v17.y = v8 - y;
  CVector::Normalise(&v17);
  v9 = (float)((float)((float)rand() * 4.6566e-10) * 0.66) + -0.33;
  v10 = cosf(v9);
  v11 = sinf(v9);
  v12 = (float)rand();
  v13 = pPed->m_pMat;
  v14 = v10 * v17.x;
  v15 = v11 * v17.y;
  if ( v13 )
    p_m_transform = (CSimpleTransform *)&v13->tx;
  v16 = (float)((float)(v12 * 4.6566e-10) * 3.0) + 3.0;
  this->m_vTargetPoint.x = p_m_transform->m_translate.x + (float)(v16 * (float)(v14 + v15));
  this->m_vTargetPoint.y = (float)(v16 * (float)(v14 - v15)) + p_m_transform->m_translate.y;
  this->m_vTargetPoint.z = p_m_transform->m_translate.z + 0.0;
}

//----- (00512D38) --------------------------------------------------------
CTask *__fastcall CTaskComplexFleePoint::CreateNextSubTask(CTaskComplexFleePoint *this, CPed *pPed)
{
  int v4; // r0
  CTaskSimpleGoToPoint *v5; // r6
  CMatrix *v6; // r0
  CSimpleTransform *v7; // r5
  CSimpleTransform *v8; // r1
  float v9; // s2
  float v10; // s6
  float v11; // r6
  float v12; // r8
  float v13; // r6
  float v14; // s0
  CMatrix *v15; // r0
  float v16; // s6
  float v17; // s4
  float v18; // s0
  CTaskComplexSequence *v19; // r4
  CTaskSimpleRunAnim *v20; // r5
  CTaskSimpleTired *v21; // r5
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r5
  CSimpleTransform *p_tx; // r1
  float y; // s2
  float v26; // s6
  float v27; // r6
  float v28; // r8
  float v29; // r6
  int v30; // r0
  int v31; // r1
  float v32; // s0
  CMatrix *v33; // r0
  float v34; // s6
  float v35; // s4
  float v36; // s0
  RwReal v37; // s2
  RwReal v38; // s0
  RwReal v39; // s4
  CVector v41; // [sp+Ch] [bp-2Ch] BYREF

  (*((void (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  v5 = 0;
  switch ( v4 )
  {
    case 903:
      v19 = (CTaskComplexSequence *)CTask::operator new(0x40u);
      CTaskComplexSequence::CTaskComplexSequence(v19);
      v20 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(v20, ANIM_STD_PED, ANIM_STD_LOOK, 4.0, 0);
      CTaskComplexSequence::AddTask(v19, v20);
      v21 = (CTaskSimpleTired *)CTask::operator new(0x1Cu);
      CTaskSimpleTired::CTaskSimpleTired(v21, 2000);
      CTaskComplexSequence::AddTask(v19, v21);
      return v19;
    case 900:
      m_pMat = pPed->m_pMat;
      p_m_transform = &pPed->m_transform;
      p_tx = &pPed->m_transform;
      y = this->m_vFleePos.y;
      if ( m_pMat )
        p_tx = (CSimpleTransform *)&m_pMat->tx;
      v26 = p_tx->m_translate.y;
      v41.x = p_tx->m_translate.x - this->m_vFleePos.x;
      v41.z = 0.0;
      v41.y = v26 - y;
      CVector::Normalise(&v41);
      v27 = (float)((float)((float)rand() * 4.6566e-10) * 0.66) + -0.33;
      v28 = cosf(v27);
      v29 = sinf(v27);
      v30 = rand();
      v31 = 900;
      v32 = (float)v30;
      v33 = pPed->m_pMat;
      v34 = v28 * v41.x;
      v35 = v29 * v41.y;
      if ( v33 )
        p_m_transform = (CSimpleTransform *)&v33->tx;
      v36 = (float)((float)(v32 * 4.6566e-10) * 3.0) + 3.0;
      v37 = p_m_transform->m_translate.x + (float)(v36 * (float)(v34 + v35));
      this->m_vTargetPoint.x = v37;
      v38 = (float)(v36 * (float)(v34 - v35)) + p_m_transform->m_translate.y;
      this->m_vTargetPoint.y = v38;
      v39 = p_m_transform->m_translate.z + 0.0;
      this->m_vTargetPoint.z = v39;
      if ( (float)((float)((float)((float)(v37 - this->m_vFleePos.x) * (float)(v37 - this->m_vFleePos.x))
                         + (float)((float)(v38 - this->m_vFleePos.y) * (float)(v38 - this->m_vFleePos.y)))
                 + (float)((float)(v39 - this->m_vFleePos.z) * (float)(v39 - this->m_vFleePos.z))) > (float)(this->m_fSafeDistance * this->m_fSafeDistance) )
        v31 = 903;
      return CTaskComplexFleePoint::CreateSubTask(this, v31);
    case 714:
      v6 = pPed->m_pMat;
      v7 = &pPed->m_transform;
      v8 = &pPed->m_transform;
      v9 = this->m_vFleePos.y;
      if ( v6 )
        v8 = (CSimpleTransform *)&v6->tx;
      v10 = v8->m_translate.y;
      v41.x = v8->m_translate.x - this->m_vFleePos.x;
      v41.z = 0.0;
      v41.y = v10 - v9;
      CVector::Normalise(&v41);
      v11 = (float)((float)((float)rand() * 4.6566e-10) * 0.66) + -0.33;
      v12 = cosf(v11);
      v13 = sinf(v11);
      v14 = (float)rand();
      v15 = pPed->m_pMat;
      v16 = v12 * v41.x;
      v17 = v13 * v41.y;
      if ( v15 )
        v7 = (CSimpleTransform *)&v15->tx;
      v18 = (float)((float)(v14 * 4.6566e-10) * 3.0) + 3.0;
      this->m_vTargetPoint.x = v7->m_translate.x + (float)(v18 * (float)(v16 + v17));
      this->m_vTargetPoint.y = (float)(v18 * (float)(v16 - v17)) + v7->m_translate.y;
      this->m_vTargetPoint.z = v7->m_translate.z + 0.0;
      v5 = (CTaskSimpleGoToPoint *)CTask::operator new(0x2Cu);
      CTaskSimpleGoToPoint::CTaskSimpleGoToPoint(v5, 7, &this->m_vTargetPoint, 0.5, 0, 0);
      break;
  }
  return v5;
}

//----- (0051302C) --------------------------------------------------------
CTask *__fastcall CTaskComplexFleePoint::ControlSubTask(CTaskComplexFleePoint *this, CPed *pPed)
{
  CTaskComplexSequence *m_pSubTask; // r6
  int m_iFleeTime; // r2
  int (**v6)(void); // r1
  int v7; // r0
  unsigned int v8; // r0
  int m_iStartTime; // r1
  CTaskSimpleRunAnim *v11; // r8
  CTaskSimpleTired *v12; // r8

  m_pSubTask = (CTaskComplexSequence *)this->m_pSubTask;
  if ( (*((int (__fastcall **)(CTaskComplexSequence *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) == 900
    || (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 903 )
  {
    if ( this->m_bScream )
      CPed::Say(pPed, 0x15Bu, 0, 0.1, 0, 0, 0);
    if ( this->m_bNewFleePoint )
    {
      m_iFleeTime = this->m_iFleeTime;
      v6 = this->_vptr$CTask;
      this->m_bNewFleePoint = 0;
      v7 = CTimer::m_snTimeInMilliseconds;
      this->m_timer.m_bIsActive = 1;
      this->m_timer.m_iStartTime = v7;
      this->m_timer.m_iDuration = m_iFleeTime;
      m_pSubTask = (CTaskComplexSequence *)((int (__fastcall *)(CTaskComplexFleePoint *, CPed *))v6[11])(this, pPed);
    }
    else if ( this->m_timer.m_bIsActive )
    {
      if ( this->m_timer.m_bIsStopped )
      {
        v8 = CTimer::m_snTimeInMilliseconds;
        this->m_timer.m_bIsStopped = 0;
        this->m_timer.m_iStartTime = v8;
        m_iStartTime = v8;
      }
      else
      {
        m_iStartTime = this->m_timer.m_iStartTime;
        v8 = CTimer::m_snTimeInMilliseconds;
      }
      if ( m_iStartTime + this->m_timer.m_iDuration <= v8 )
      {
        m_pSubTask = (CTaskComplexSequence *)CTask::operator new(0x40u);
        CTaskComplexSequence::CTaskComplexSequence(m_pSubTask);
        v11 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
        CTaskSimpleRunAnim::CTaskSimpleRunAnim(v11, ANIM_STD_PED, ANIM_STD_LOOK, 4.0, 0);
        CTaskComplexSequence::AddTask(m_pSubTask, v11);
        v12 = (CTaskSimpleTired *)CTask::operator new(0x1Cu);
        CTaskSimpleTired::CTaskSimpleTired(v12, 2000);
        CTaskComplexSequence::AddTask(m_pSubTask, v12);
      }
    }
    if ( !IKChainManager_c::IsLooking(&g_ikChainMan, pPed)
      && (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) <= 5 )
    {
      IKChainManager_c::LookAt(&g_ikChainMan, "TaskFleePoint", pPed, 0, 2000, -1, &this->m_vFleePos, 0, 0.25, 500, 3, 0);
    }
  }
  else
  {
    if ( IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
      IKChainManager_c::AbortLookAt(&g_ikChainMan, pPed, 250);
    return this->m_pSubTask;
  }
  return m_pSubTask;
}

//----- (005131FC) --------------------------------------------------------
void __fastcall CTaskComplexFleePoint::SetFleePosition(
        CTaskComplexFleePoint *this,
        const CVector *vFleePos,
        const float fSafeDistance,
        const bool bScream)
{
  __int64 v4; // d16

  if ( this->m_vFleePos.x != vFleePos->x
    || this->m_vFleePos.y != vFleePos->y
    || this->m_vFleePos.z != vFleePos->z
    || this->m_fSafeDistance != fSafeDistance )
  {
    v4 = *(_QWORD *)&vFleePos->x;
    this->m_vFleePos.z = vFleePos->z;
    *(_QWORD *)&this->m_vFleePos.x = v4;
    this->m_bNewFleePoint = 1;
    this->m_fSafeDistance = fSafeDistance;
  }
  this->m_bScream = bScream;
}

//----- (00513268) --------------------------------------------------------
void __fastcall CTaskComplexFleeEntity::CTaskComplexFleeEntity(
        CTaskComplexFleeEntity *this,
        CEntity *pFleeEntity,
        const bool bScream,
        const float fSafeDistance,
        const int iFleeTime,
        const int iEntityPosCheckPeriod,
        const float fEntityPosChangeThreshold)
{
  CTaskComplex::CTaskComplex(this);
  this->m_iFleeTime = iFleeTime;
  *(_WORD *)&this->m_timer.m_bIsActive = 0;
  this->m_fSafeDistance = fSafeDistance;
  this->m_iEntityPosCheckPeriod = iEntityPosCheckPeriod;
  this->m_fEntityPosChangeThreshold = fEntityPosChangeThreshold;
  this->m_bScream = bScream;
  this->m_timer.m_iStartTime = 0;
  this->m_timer.m_iDuration = 0;
  this->_vptr$CTask = (int (**)(void))&off_66BC40;
  this->m_pFleeEntity = pFleeEntity;
  if ( pFleeEntity )
    CEntity::RegisterReference(pFleeEntity, &this->m_pFleeEntity);
}
// 66BC40: using guessed type void *;

//----- (005132C4) --------------------------------------------------------
void __fastcall CTaskComplexFleeEntity::~CTaskComplexFleeEntity(CTaskComplexFleeEntity *this)
{
  CEntity *m_pFleeEntity; // r0
  CEntity **p_m_pFleeEntity; // r1

  p_m_pFleeEntity = &this->m_pFleeEntity;
  m_pFleeEntity = this->m_pFleeEntity;
  this->_vptr$CTask = (int (**)(void))&off_66BC40;
  if ( m_pFleeEntity )
    CEntity::CleanUpOldReference(m_pFleeEntity, p_m_pFleeEntity);
  sub_18EDB4(this);
}
// 66BC40: using guessed type void *off_66BC40;

//----- (005132F0) --------------------------------------------------------
void __fastcall CTaskComplexFleeEntity::~CTaskComplexFleeEntity(CTaskComplexFleeEntity *this)
{
  CEntity *m_pFleeEntity; // r0
  CEntity **p_m_pFleeEntity; // r1
  void *v4; // r0

  p_m_pFleeEntity = &this->m_pFleeEntity;
  m_pFleeEntity = this->m_pFleeEntity;
  this->_vptr$CTask = (int (**)(void))&off_66BC40;
  if ( m_pFleeEntity )
    CEntity::CleanUpOldReference(m_pFleeEntity, p_m_pFleeEntity);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 513318: variable 'v4' is possibly undefined
// 66BC40: using guessed type void *off_66BC40;

//----- (00513320) --------------------------------------------------------
CTask *__fastcall CTaskComplexFleeEntity::CreateSubTask(CTaskComplexFleeEntity *this, const int iSubTaskType)
{
  CTask *result; // r0
  CTaskComplex *v4; // r0
  CTask *m_iFleeTime; // r6
  float m_fSafeDistance; // r8
  bool m_bScream; // r9
  __int64 v8; // d16

  result = 0;
  if ( iSubTaskType == 908 )
  {
    v4 = (CTaskComplex *)CTask::operator new(0x3Cu);
    m_iFleeTime = (CTask *)this->m_iFleeTime;
    m_fSafeDistance = this->m_fSafeDistance;
    m_bScream = this->m_bScream;
    CTaskComplex::CTaskComplex(v4);
    result->_vptr$CTask = (int (**)(void))&off_66BC04;
    v8 = *(_QWORD *)&this->m_vFleePos.x;
    result[2].m_pParent = (CTask *)LODWORD(this->m_vFleePos.z);
    result[4].m_pParent = m_iFleeTime;
    result[5]._vptr$CTask = 0;
    result[5].m_pParent = 0;
    LOWORD(result[6]._vptr$CTask) = 0;
    *(float *)&result[6].m_pParent = m_fSafeDistance;
    LOBYTE(result[7]._vptr$CTask) = m_bScream;
    BYTE1(result[7]._vptr$CTask) = 0;
    *(_QWORD *)&result[1].m_pParent = v8;
    if ( m_iFleeTime != (CTask *)-1 )
    {
      result[5]._vptr$CTask = (int (**)(void))CTimer::m_snTimeInMilliseconds;
      result[5].m_pParent = m_iFleeTime;
      LOBYTE(result[6]._vptr$CTask) = 1;
    }
  }
  return result;
}
// 513352: variable 'result' is possibly undefined
// 66BC04: using guessed type void *off_66BC04;

//----- (00513398) --------------------------------------------------------
CTask *__fastcall CTaskComplexFleeEntity::CreateNextSubTask(CTaskComplexFleeEntity *this, CPed *pPed)
{
  if ( this->m_pFleeEntity )
    (*((void (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  return 0;
}

//----- (005133B0) --------------------------------------------------------
CTask *__fastcall CTaskComplexFleeEntity::CreateFirstSubTask(CTaskComplexFleeEntity *this, CPed *pPed)
{
  CEntity *m_pFleeEntity; // r3
  int32 v5; // r6
  int m_iEntityPosCheckPeriod; // r2
  CEntity *v7; // r1
  int v8; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r2
  __int64 v11; // d16
  CTaskComplex *v12; // r0
  CTask *m_iFleeTime; // r6
  float m_fSafeDistance; // r5
  bool m_bScream; // r9
  CTask *result; // r0
  __int64 v17; // d16

  CInterestingEvents::Add(&g_InterestingEvents, EPanickedPed, pPed);
  if ( !IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
  {
    m_pFleeEntity = this->m_pFleeEntity;
    if ( (*(_BYTE *)&m_pFleeEntity->m_info & 7) == 3 )
      v5 = 5;
    else
      v5 = -1;
    IKChainManager_c::LookAt(&g_ikChainMan, "TaskFleeEntity", pPed, m_pFleeEntity, 3000, v5, 0, 1, 0.25, 500, 3, 0);
  }
  m_iEntityPosCheckPeriod = this->m_iEntityPosCheckPeriod;
  v7 = this->m_pFleeEntity;
  v8 = CTimer::m_snTimeInMilliseconds;
  this->m_timer.m_bIsActive = 1;
  this->m_timer.m_iStartTime = v8;
  this->m_timer.m_iDuration = m_iEntityPosCheckPeriod;
  m_pMat = v7->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &v7->m_transform;
  v11 = *(_QWORD *)&p_tx->m_translate.x;
  this->m_vFleePos.z = p_tx->m_translate.z;
  *(_QWORD *)&this->m_vFleePos.x = v11;
  v12 = (CTaskComplex *)CTask::operator new(0x3Cu);
  m_iFleeTime = (CTask *)this->m_iFleeTime;
  m_fSafeDistance = this->m_fSafeDistance;
  m_bScream = this->m_bScream;
  CTaskComplex::CTaskComplex(v12);
  result->_vptr$CTask = (int (**)(void))&off_66BC04;
  v17 = *(_QWORD *)&this->m_vFleePos.x;
  result[2].m_pParent = (CTask *)LODWORD(this->m_vFleePos.z);
  result[4].m_pParent = m_iFleeTime;
  result[5]._vptr$CTask = 0;
  result[5].m_pParent = 0;
  LOWORD(result[6]._vptr$CTask) = 0;
  *(float *)&result[6].m_pParent = m_fSafeDistance;
  LOBYTE(result[7]._vptr$CTask) = m_bScream;
  BYTE1(result[7]._vptr$CTask) = 0;
  *(_QWORD *)&result[1].m_pParent = v17;
  if ( m_iFleeTime != (CTask *)-1 )
  {
    result[5]._vptr$CTask = (int (**)(void))CTimer::m_snTimeInMilliseconds;
    result[5].m_pParent = m_iFleeTime;
    LOBYTE(result[6]._vptr$CTask) = 1;
  }
  return result;
}
// 513486: variable 'result' is possibly undefined
// 66BC04: using guessed type void *off_66BC04;

//----- (005134F0) --------------------------------------------------------
CTask *__fastcall CTaskComplexFleeEntity::ControlSubTask(CTaskComplexFleeEntity *this, CPed *pPed)
{
  __int64 v4; // r0
  unsigned int v5; // r2
  int m_iStartTime; // r0
  CEntity *m_pFleeEntity; // r6
  CSimpleTransform *p_m_transform; // r3
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float32x2_t v11; // d16
  unsigned __int64 v12; // d1
  int m_iEntityPosCheckPeriod; // r1
  CVector *p_m_vFleePos; // r0
  CMatrix *v15; // r1
  __int64 v16; // d16
  CTask *m_pSubTask; // r2
  bool m_bScream; // r3
  float m_fSafeDistance; // s0
  __int64 v20; // d16
  CEventGlobalGroup *EventGlobalGroup; // r0
  CEventSeenPanickedPed v23; // [sp+4h] [bp-24h] BYREF

  v4 = *(_QWORD *)&this->m_pSubTask;
  if ( HIDWORD(v4) )
  {
    if ( (*(int (__fastcall **)(_DWORD))(*(_DWORD *)v4 + 20))(v4) == 908 && this->m_timer.m_bIsActive )
    {
      if ( this->m_timer.m_bIsStopped )
      {
        v5 = CTimer::m_snTimeInMilliseconds;
        this->m_timer.m_bIsStopped = 0;
        this->m_timer.m_iStartTime = v5;
        m_iStartTime = v5;
      }
      else
      {
        m_iStartTime = this->m_timer.m_iStartTime;
        v5 = CTimer::m_snTimeInMilliseconds;
      }
      if ( m_iStartTime + this->m_timer.m_iDuration <= v5 )
      {
        m_pFleeEntity = this->m_pFleeEntity;
        p_m_transform = &m_pFleeEntity->m_transform;
        m_pMat = m_pFleeEntity->m_pMat;
        p_tx = &m_pFleeEntity->m_transform;
        if ( m_pMat )
          p_tx = (CSimpleTransform *)&m_pMat->tx;
        v11.n64_u64[0] = vsub_f32(*(float32x2_t *)&this->m_vFleePos.y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
        v12 = vmul_f32(v11, v11).n64_u64[0];
        if ( (float)((float)((float)((float)(this->m_vFleePos.x - p_tx->m_translate.x)
                                   * (float)(this->m_vFleePos.x - p_tx->m_translate.x))
                           + *(float *)&v12)
                   + *((float *)&v12 + 1)) > (float)(this->m_fEntityPosChangeThreshold
                                                   * this->m_fEntityPosChangeThreshold) )
        {
          m_iEntityPosCheckPeriod = this->m_iEntityPosCheckPeriod;
          this->m_timer.m_bIsActive = 1;
          p_m_vFleePos = &this->m_vFleePos;
          this->m_timer.m_iStartTime = v5;
          this->m_timer.m_iDuration = m_iEntityPosCheckPeriod;
          v15 = m_pFleeEntity->m_pMat;
          if ( v15 )
            p_m_transform = (CSimpleTransform *)&v15->tx;
          v16 = *(_QWORD *)&p_m_transform->m_translate.x;
          this->m_vFleePos.z = p_m_transform->m_translate.z;
          *(_QWORD *)&p_m_vFleePos->x = v16;
          m_pSubTask = this->m_pSubTask;
          m_bScream = this->m_bScream;
          m_fSafeDistance = this->m_fSafeDistance;
          if ( *(float *)&m_pSubTask[1].m_pParent != this->m_vFleePos.x
            || *(float *)&m_pSubTask[2]._vptr$CTask != this->m_vFleePos.y
            || *(float *)&m_pSubTask[2].m_pParent != this->m_vFleePos.z
            || *(float *)&m_pSubTask[6].m_pParent != m_fSafeDistance )
          {
            v20 = *(_QWORD *)&p_m_vFleePos->x;
            m_pSubTask[2].m_pParent = (CTask *)LODWORD(this->m_vFleePos.z);
            *(_QWORD *)&m_pSubTask[1].m_pParent = v20;
            BYTE1(m_pSubTask[7]._vptr$CTask) = 1;
            *(float *)&m_pSubTask[6].m_pParent = m_fSafeDistance;
          }
          LOBYTE(m_pSubTask[7]._vptr$CTask) = m_bScream;
          CEventSeenPanickedPed::CEventSeenPanickedPed(&v23, pPed);
          EventGlobalGroup = GetEventGlobalGroup();
          CEventGroup::Add(EventGlobalGroup, (CEvent *)&v23, 0);
          CEventSeenPanickedPed::~CEventSeenPanickedPed(&v23);
        }
      }
    }
  }
  else
  {
    (*(void (__fastcall **)(_DWORD, CPed *, _DWORD, _DWORD))(*(_DWORD *)v4 + 28))(v4, pPed, 0, 0);
  }
  return this->m_pSubTask;
}

//----- (00513664) --------------------------------------------------------
void __fastcall CTaskComplexSmartFleePoint::CTaskComplexSmartFleePoint(
        CTaskComplexSmartFleePoint *this,
        const CVector *vFleePos,
        const bool bScream,
        const float fSafeDistance,
        const int iFleeTime)
{
  int v8; // r0
  __int64 v9; // d16
  uint32 v10; // r2

  CTaskComplex::CTaskComplex(this);
  *(_DWORD *)v8 = &off_66BC7C;
  v9 = *(_QWORD *)&vFleePos->x;
  *(RwReal *)(v8 + 32) = vFleePos->z;
  *(_DWORD *)(v8 + 40) = iFleeTime;
  *(const float *)(v8 + 44) = fSafeDistance;
  *(_QWORD *)(v8 + 48) = 7LL;
  *(_DWORD *)(v8 + 56) = 0;
  *(_BYTE *)(v8 + 36) = bScream;
  *(_WORD *)(v8 + 60) = 0;
  *(_WORD *)(v8 + 64) = 0;
  *(_QWORD *)(v8 + 24) = v9;
  if ( iFleeTime != -1 )
  {
    v10 = CTimer::m_snTimeInMilliseconds;
    *(_BYTE *)(v8 + 60) = 1;
    *(_DWORD *)(v8 + 52) = v10;
    *(_DWORD *)(v8 + 56) = iFleeTime;
  }
}
// 513680: variable 'v8' is possibly undefined
// 66BC7C: using guessed type void *;

//----- (005136D0) --------------------------------------------------------
void __fastcall CTaskComplexSmartFleePoint::~CTaskComplexSmartFleePoint(CTaskComplexSmartFleePoint *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 5136DC: variable 'v1' is possibly undefined

//----- (005136E0) --------------------------------------------------------
bool __fastcall CTaskComplexSmartFleePoint::MakeAbortable(
        CTaskComplexSmartFleePoint *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  int v4; // r12

  if ( !iPriority )
  {
    this->m_iFleeTime = -1;
    v4 = CTimer::m_snTimeInMilliseconds;
    this->m_timer.m_bIsActive = 1;
    this->m_timer.m_iStartTime = v4;
    this->m_timer.m_iDuration = -1;
  }
  return (*((int (__fastcall **)(CTask *, CPed *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
           this->m_pSubTask,
           pPed);
}

//----- (00513718) --------------------------------------------------------
void __fastcall CTaskComplexSmartFleePoint::SetDefaultTaskWanderDir(const CTaskComplexSmartFleePoint *this, CPed *pPed)
{
  CTaskComplexWander *v3; // r5

  v3 = (CTaskComplexWander *)pPed->m_pPedIntelligence->m_taskManager.m_tasks[4];
  if ( v3 )
  {
    if ( (*((int (__fastcall **)(CTaskComplexWander *))v3->_vptr$CTask + 5))(v3) == 912 )
      sub_19536C(v3, (const CTaskComplexWander *)this->m_pSubTask);
  }
}

//----- (00513746) --------------------------------------------------------
UINT8 __fastcall CTaskComplexSmartFleePoint::ComputeFleeDir(const CTaskComplexSmartFleePoint *this, CPed *pPed)
{
  CMatrix *m_pMat; // r2
  float x; // s0
  float y; // s2
  CSimpleTransform *p_tx; // r0

  m_pMat = pPed->m_pMat;
  x = this->m_vFleePos.x;
  y = this->m_vFleePos.y;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  return CGeneral::GetNodeHeadingFromVector(p_tx->m_translate.x - x, p_tx->m_translate.y - y);
}

//----- (00513780) --------------------------------------------------------
CTask *__fastcall CTaskComplexSmartFleePoint::CreateSubTask(
        CTaskComplexSmartFleePoint *this,
        const int iSubTaskType,
        CPed *pPed)
{
  CTaskComplexWander *v4; // r4
  bool v5; // zf
  CTaskComplexSequence *v6; // r5
  CTaskSimpleRunAnim *v7; // r6
  CTaskSimpleTired *v8; // r4
  void **v9; // r0
  CTaskComplexWander *v10; // r4

  v4 = 0;
  if ( iSubTaskType > 713 )
  {
    if ( iSubTaskType == 912 )
    {
      v4 = (CTaskComplexWander *)CTask::operator new(0x28u);
      CTaskComplexWander::CTaskComplexWander(v4, this->m_iMoveState, this->m_iFleeDir, 0, 0.5);
      v9 = &`vtable for'CTaskComplexWanderFlee;
    }
    else
    {
      if ( iSubTaskType != 714 )
        return v4;
      v4 = (CTaskComplexWander *)CTask::operator new(0x14u);
      CTaskComplex::CTaskComplex(v4);
      v4->m_iMoveState = 0;
      v9 = &`vtable for'CTaskComplexLeaveAnyCar;
      *(_WORD *)&v4->m_iDir = 256;
    }
    v4->_vptr$CTask = (int (**)(void))((char *)*v9 + 8);
    return v4;
  }
  if ( iSubTaskType == 203 )
  {
    v10 = (CTaskComplexWander *)pPed->m_pPedIntelligence->m_taskManager.m_tasks[4];
    if ( v10
      && (*((int (__fastcall **)(CTask *))v10->_vptr$CTask + 5))(pPed->m_pPedIntelligence->m_taskManager.m_tasks[4]) == 912 )
    {
      CTaskComplexWander::ContinueFrom(v10, (const CTaskComplexWander *)this->m_pSubTask);
    }
    v4 = (CTaskComplexWander *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v4, 0, 0, 0, 8.0);
  }
  else
  {
    v5 = iSubTaskType == 244;
    if ( iSubTaskType == 244 )
    {
      v4 = 0;
      v5 = this->m_iMoveState == 6;
    }
    if ( v5 )
    {
      v6 = (CTaskComplexSequence *)CTask::operator new(0x40u);
      CTaskComplexSequence::CTaskComplexSequence(v6);
      v7 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(v7, ANIM_STD_PED, ANIM_STD_LOOK, 4.0, 0);
      CTaskComplexSequence::AddTask(v6, v7);
      v8 = (CTaskSimpleTired *)CTask::operator new(0x1Cu);
      CTaskSimpleTired::CTaskSimpleTired(v8, 2000);
      CTaskComplexSequence::AddTask(v6, v8);
      return v6;
    }
  }
  return v4;
}
// 67733C: using guessed type void *`vtable for'CTaskComplexWanderFlee;
// 677A98: using guessed type void *`vtable for'CTaskComplexLeaveAnyCar;

//----- (00513894) --------------------------------------------------------
CTask *__fastcall CTaskComplexSmartFleePoint::CreateNextSubTask(CTaskComplexSmartFleePoint *this, CPed *pPed)
{
  int v4; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  int v8; // r1

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  switch ( v4 )
  {
    case 203:
      v8 = 244;
      break;
    case 244:
      v8 = 1302;
      break;
    case 714:
      m_pMat = pPed->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      this->m_iFleeDir = CGeneral::GetNodeHeadingFromVector(
                           p_tx->m_translate.x - this->m_vFleePos.x,
                           p_tx->m_translate.y - this->m_vFleePos.y);
      v8 = 912;
      break;
    default:
      return 0;
  }
  return CTaskComplexSmartFleePoint::CreateSubTask(this, v8, pPed);
}

//----- (00513904) --------------------------------------------------------
CTask *__fastcall CTaskComplexSmartFleePoint::CreateFirstSubTask(CTaskComplexSmartFleePoint *this, CPed *pPed)
{
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_m_transform; // r0
  CSimpleTransform *p_tx; // r2
  __int64 v7; // d16
  bool v8; // zf
  CMatrix *v9; // r1
  UINT8 NodeHeadingFromVector; // r0
  int v11; // r1

  m_pMat = pPed->m_pMat;
  p_m_transform = &pPed->m_transform;
  p_tx = &pPed->m_transform;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  v7 = *(_QWORD *)&p_tx->m_translate.x;
  this->m_vStartPos.z = p_tx->m_translate.z;
  *(_QWORD *)&this->m_vStartPos.x = v7;
  v8 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
  if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
    v8 = pPed->m_pMyVehicle == 0;
  if ( v8 )
  {
    v9 = pPed->m_pMat;
    if ( v9 )
      p_m_transform = (CSimpleTransform *)&v9->tx;
    NodeHeadingFromVector = CGeneral::GetNodeHeadingFromVector(
                              p_m_transform->m_translate.x - this->m_vFleePos.x,
                              p_m_transform->m_translate.y - this->m_vFleePos.y);
    v11 = 912;
    this->m_iFleeDir = NodeHeadingFromVector;
  }
  else
  {
    v11 = 714;
  }
  return CTaskComplexSmartFleePoint::CreateSubTask(this, v11, pPed);
}

//----- (0051397C) --------------------------------------------------------
CTask *__fastcall CTaskComplexSmartFleePoint::ControlSubTask(CTaskComplexSmartFleePoint *this, CPed *pPed)
{
  CTaskSimpleStandStill *m_pSubTask; // r6
  CTaskComplexWander *v5; // r4
  int m_bIsActive; // r0
  __int64 v7; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  UINT8 NodeHeadingFromVector; // r0
  unsigned int v11; // r0
  int m_iStartTime; // r1
  CMatrix *v13; // r0
  CSimpleTransform *p_m_transform; // r1
  float m_fSafeDistance; // s12
  float y; // s4
  float z; // s2
  CPedIntelligence *m_pPedIntelligence; // r0
  CTaskComplexWander *v19; // r4

  m_pSubTask = (CTaskSimpleStandStill *)this->m_pSubTask;
  if ( (*((int (__fastcall **)(CTaskSimpleStandStill *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) == 912 )
  {
    if ( this->m_bScream )
      CPed::Say(pPed, 0x15Bu, 0, 0.1, 0, 0, 0);
    v5 = (CTaskComplexWander *)this->m_pSubTask;
    v5->m_iMoveState = this->m_iMoveState;
    if ( this->m_bNewFleePoint )
    {
      m_bIsActive = this->m_timer.m_bIsActive;
      this->m_bNewFleePoint = 0;
      if ( m_bIsActive )
      {
        HIDWORD(v7) = this->m_iFleeTime;
        LODWORD(v7) = CTimer::m_snTimeInMilliseconds;
        *(_QWORD *)&this->m_timer.m_iStartTime = v7;
        this->m_timer.m_bIsActive = 1;
      }
      m_pMat = pPed->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      NodeHeadingFromVector = CGeneral::GetNodeHeadingFromVector(
                                p_tx->m_translate.x - this->m_vFleePos.x,
                                p_tx->m_translate.y - this->m_vFleePos.y);
      if ( this->m_iFleeDir != NodeHeadingFromVector )
      {
        this->m_iFleeDir = NodeHeadingFromVector;
        CTaskComplexWander::SetDir(v5, NodeHeadingFromVector);
      }
LABEL_27:
      m_pSubTask = (CTaskSimpleStandStill *)this->m_pSubTask;
      goto LABEL_28;
    }
    if ( !this->m_timer.m_bIsActive
      || (!this->m_timer.m_bIsStopped ? (m_iStartTime = this->m_timer.m_iStartTime, v11 = CTimer::m_snTimeInMilliseconds) : (v11 = CTimer::m_snTimeInMilliseconds, this->m_timer.m_bIsStopped = 0, this->m_timer.m_iStartTime = v11, m_iStartTime = v11),
          m_iStartTime + this->m_timer.m_iDuration > v11) )
    {
      v13 = pPed->m_pMat;
      p_m_transform = (CSimpleTransform *)&v13->tx;
      m_fSafeDistance = this->m_fSafeDistance;
      if ( !v13 )
        p_m_transform = &pPed->m_transform;
      y = p_m_transform->m_translate.y;
      z = p_m_transform->m_translate.z;
      if ( (float)((float)((float)((float)(this->m_vFleePos.x - p_m_transform->m_translate.x)
                                 * (float)(this->m_vFleePos.x - p_m_transform->m_translate.x))
                         + (float)((float)(this->m_vFleePos.y - y) * (float)(this->m_vFleePos.y - y)))
                 + (float)((float)(this->m_vFleePos.z - z) * (float)(this->m_vFleePos.z - z))) <= (float)(m_fSafeDistance * m_fSafeDistance) )
        goto LABEL_27;
      if ( (float)((float)((float)((float)(this->m_vStartPos.x - p_m_transform->m_translate.x)
                                 * (float)(this->m_vStartPos.x - p_m_transform->m_translate.x))
                         + (float)((float)(this->m_vStartPos.y - y) * (float)(this->m_vStartPos.y - y)))
                 + (float)((float)(this->m_vStartPos.z - z) * (float)(this->m_vStartPos.z - z))) <= (float)(m_fSafeDistance * m_fSafeDistance) )
      {
LABEL_28:
        if ( this->m_iMoveState == 6
          && !IKChainManager_c::IsLooking(&g_ikChainMan, pPed)
          && (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) <= 5 )
        {
          IKChainManager_c::LookAt(
            &g_ikChainMan,
            "TaskSmartFleePoint",
            pPed,
            0,
            2000,
            -1,
            &this->m_vFleePos,
            0,
            0.25,
            500,
            3,
            0);
        }
        return m_pSubTask;
      }
    }
    m_pPedIntelligence = pPed->m_pPedIntelligence;
    v19 = (CTaskComplexWander *)m_pPedIntelligence->m_taskManager.m_tasks[4];
    if ( v19
      && (*((int (__fastcall **)(CTask *))v19->_vptr$CTask + 5))(m_pPedIntelligence->m_taskManager.m_tasks[4]) == 912 )
    {
      CTaskComplexWander::ContinueFrom(v19, (const CTaskComplexWander *)this->m_pSubTask);
    }
    m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill(m_pSubTask, 0, 0, 0, 8.0);
    goto LABEL_28;
  }
  if ( IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
    IKChainManager_c::AbortLookAt(&g_ikChainMan, pPed, 250);
  return this->m_pSubTask;
}

//----- (00513C10) --------------------------------------------------------
void __fastcall CTaskComplexSmartFleePoint::SetFleePosition(
        CTaskComplexSmartFleePoint *this,
        const CVector *vFleePos,
        const float fSafeDistance,
        const bool bScream)
{
  __int64 v4; // d16

  if ( this->m_vFleePos.x != vFleePos->x
    || this->m_vFleePos.y != vFleePos->y
    || this->m_vFleePos.z != vFleePos->z
    || this->m_fSafeDistance != fSafeDistance )
  {
    v4 = *(_QWORD *)&vFleePos->x;
    this->m_vFleePos.z = vFleePos->z;
    *(_QWORD *)&this->m_vFleePos.x = v4;
    this->m_bNewFleePoint = 1;
    this->m_fSafeDistance = fSafeDistance;
  }
  this->m_bScream = bScream;
}

//----- (00513C7C) --------------------------------------------------------
void __fastcall CTaskComplexSmartFleeEntity::CTaskComplexSmartFleeEntity(
        CTaskComplexSmartFleeEntity *this,
        CEntity *pFleeEntity,
        const bool bScream,
        const float fSafeDistance,
        const int iFleeTime,
        const int iEntityPosCheckPeriod,
        const float fEntityPosChangeThreshold)
{
  CTaskComplex::CTaskComplex(this);
  this->m_iFleeTime = iFleeTime;
  this->m_fSafeDistance = fSafeDistance;
  this->m_bScream = bScream;
  this->m_iEntityPosCheckPeriod = iEntityPosCheckPeriod;
  this->m_fEntityPosChangeThreshold = fEntityPosChangeThreshold;
  this->m_iMoveState = 7;
  *(_WORD *)&this->m_timer.m_bIsActive = 0;
  this->m_timer.m_iStartTime = 0;
  this->m_timer.m_iDuration = 0;
  this->_vptr$CTask = (int (**)(void))&off_66BCB8;
  this->m_pFleeEntity = pFleeEntity;
  if ( pFleeEntity )
    CEntity::RegisterReference(pFleeEntity, &this->m_pFleeEntity);
}
// 66BCB8: using guessed type void *off_66BCB8;

//----- (00513CE0) --------------------------------------------------------
void __fastcall CTaskComplexSmartFleeEntity::~CTaskComplexSmartFleeEntity(CTaskComplexSmartFleeEntity *this)
{
  CEntity *m_pFleeEntity; // r0
  CEntity **p_m_pFleeEntity; // r1

  p_m_pFleeEntity = &this->m_pFleeEntity;
  m_pFleeEntity = this->m_pFleeEntity;
  this->_vptr$CTask = (int (**)(void))&off_66BCB8;
  if ( m_pFleeEntity )
    CEntity::CleanUpOldReference(m_pFleeEntity, p_m_pFleeEntity);
  sub_18EDB4(this);
}
// 66BCB8: using guessed type void *off_66BCB8;

//----- (00513D0C) --------------------------------------------------------
void __fastcall CTaskComplexSmartFleeEntity::~CTaskComplexSmartFleeEntity(CTaskComplexSmartFleeEntity *this)
{
  CEntity *m_pFleeEntity; // r0
  CEntity **p_m_pFleeEntity; // r1
  void *v4; // r0

  p_m_pFleeEntity = &this->m_pFleeEntity;
  m_pFleeEntity = this->m_pFleeEntity;
  this->_vptr$CTask = (int (**)(void))&off_66BCB8;
  if ( m_pFleeEntity )
    CEntity::CleanUpOldReference(m_pFleeEntity, p_m_pFleeEntity);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 513D34: variable 'v4' is possibly undefined
// 66BCB8: using guessed type void *off_66BCB8;

//----- (00513D3C) --------------------------------------------------------
CTask *__fastcall CTaskComplexSmartFleeEntity::CreateSubTask(CTaskComplexSmartFleeEntity *this, const int iSubTaskType)
{
  CTaskSimpleStandStill *v3; // r4
  unsigned __int16 v4; // r0
  int m_iEntityPosCheckPeriod; // r2
  CEntity *m_pFleeEntity; // r1
  int v7; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r2
  __int64 v10; // d16
  CTaskComplex *v11; // r0
  __int64 v12; // kr00_8
  bool m_bScream; // r10
  int v14; // r0
  __int64 v15; // d16

  v3 = 0;
  if ( iSubTaskType == 910 )
  {
    m_iEntityPosCheckPeriod = this->m_iEntityPosCheckPeriod;
    m_pFleeEntity = this->m_pFleeEntity;
    v7 = CTimer::m_snTimeInMilliseconds;
    this->m_timer.m_bIsActive = 1;
    this->m_timer.m_iStartTime = v7;
    this->m_timer.m_iDuration = m_iEntityPosCheckPeriod;
    m_pMat = m_pFleeEntity->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &m_pFleeEntity->m_transform;
    v10 = *(_QWORD *)&p_tx->m_translate.x;
    this->m_vFleePos.z = p_tx->m_translate.z;
    *(_QWORD *)&this->m_vFleePos.x = v10;
    v11 = (CTaskComplex *)CTask::operator new(0x44u);
    v12 = *(_QWORD *)&this->m_iFleeTime;
    m_bScream = this->m_bScream;
    CTaskComplex::CTaskComplex(v11);
    *(_DWORD *)v14 = &off_66BC7C;
    v15 = *(_QWORD *)&this->m_vFleePos.x;
    *(RwReal *)(v14 + 32) = this->m_vFleePos.z;
    *(_QWORD *)(v14 + 40) = v12;
    *(_DWORD *)(v14 + 48) = 7;
    *(_DWORD *)(v14 + 52) = 0;
    *(_DWORD *)(v14 + 56) = 0;
    *(_BYTE *)(v14 + 36) = m_bScream;
    *(_WORD *)(v14 + 60) = 0;
    *(_WORD *)(v14 + 64) = 0;
    *(_QWORD *)(v14 + 24) = v15;
    if ( (_DWORD)v12 != -1 )
    {
      *(_DWORD *)(v14 + 52) = CTimer::m_snTimeInMilliseconds;
      *(_DWORD *)(v14 + 56) = v12;
      *(_BYTE *)(v14 + 60) = 1;
    }
    return (CTask *)v14;
  }
  else if ( iSubTaskType == 203 )
  {
    v3 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
    v4 = rand();
    CTaskSimpleStandStill::CTaskSimpleStandStill(v3, (int)(float)((float)((float)v4 * 0.000015259) * 50.0), 0, 0, 8.0);
  }
  return v3;
}
// 513DE0: variable 'v14' is possibly undefined
// 66BC7C: using guessed type void *off_66BC7C;

//----- (00513E38) --------------------------------------------------------
CTask *__fastcall CTaskComplexSmartFleeEntity::CreateNextSubTask(CTaskComplexSmartFleeEntity *this, CPed *pPed)
{
  __int64 v3; // kr00_8
  int v4; // r0
  int v5; // r1

  v3 = *(_QWORD *)&this->m_pSubTask;
  (*(void (__fastcall **)(_DWORD))(*(_DWORD *)v3 + 20))(v3);
  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( !HIDWORD(v3) )
    return 0;
  if ( v4 == 910 )
  {
    v5 = 1302;
    return CTaskComplexSmartFleeEntity::CreateSubTask(this, v5);
  }
  if ( v4 != 203 )
    return 0;
  v5 = 910;
  return CTaskComplexSmartFleeEntity::CreateSubTask(this, v5);
}

//----- (00513E74) --------------------------------------------------------
CTask *__fastcall CTaskComplexSmartFleeEntity::CreateFirstSubTask(CTaskComplexSmartFleeEntity *this, CPed *pPed)
{
  CEntity *m_pFleeEntity; // r3
  int32 v5; // r6
  CTask *result; // r0
  int m_iEntityPosCheckPeriod; // r2
  CEntity *v8; // r1
  int v9; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r2
  __int64 v12; // d16
  CTaskComplex *v13; // r0
  CTask v14; // kr00_8
  bool m_bScream; // r9
  CTask v16; // d16

  if ( !this->m_pFleeEntity )
    return 0;
  CInterestingEvents::Add(&g_InterestingEvents, EPanickedPed, pPed);
  if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) && !IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
  {
    m_pFleeEntity = this->m_pFleeEntity;
    if ( (*(_BYTE *)&m_pFleeEntity->m_info & 7) == 3 )
      v5 = 5;
    else
      v5 = -1;
    IKChainManager_c::LookAt(&g_ikChainMan, "TaskSmartFleeEntity", pPed, m_pFleeEntity, 3000, v5, 0, 1, 0.25, 500, 3, 0);
  }
  m_iEntityPosCheckPeriod = this->m_iEntityPosCheckPeriod;
  v8 = this->m_pFleeEntity;
  v9 = CTimer::m_snTimeInMilliseconds;
  this->m_timer.m_bIsActive = 1;
  this->m_timer.m_iStartTime = v9;
  this->m_timer.m_iDuration = m_iEntityPosCheckPeriod;
  m_pMat = v8->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &v8->m_transform;
  v12 = *(_QWORD *)&p_tx->m_translate.x;
  this->m_vFleePos.z = p_tx->m_translate.z;
  *(_QWORD *)&this->m_vFleePos.x = v12;
  v13 = (CTaskComplex *)CTask::operator new(0x44u);
  v14 = *(CTask *)&this->m_iFleeTime;
  m_bScream = this->m_bScream;
  CTaskComplex::CTaskComplex(v13);
  result->_vptr$CTask = (int (**)(void))&off_66BC7C;
  v16 = *(CTask *)&this->m_vFleePos.x;
  result[4]._vptr$CTask = (int (**)(void))LODWORD(this->m_vFleePos.z);
  result[5] = v14;
  result[6]._vptr$CTask = (int (**)(void))&byte_7;
  result[6].m_pParent = 0;
  result[7]._vptr$CTask = 0;
  LOBYTE(result[4].m_pParent) = m_bScream;
  LOWORD(result[7].m_pParent) = 0;
  LOWORD(result[8]._vptr$CTask) = 0;
  result[3] = v16;
  if ( v14._vptr$CTask != (int (**)(void))-1 )
  {
    result[6].m_pParent = (CTask *)CTimer::m_snTimeInMilliseconds;
    result[7]._vptr$CTask = v14._vptr$CTask;
    LOBYTE(result[7].m_pParent) = 1;
  }
  return result;
}
// 513F5C: variable 'result' is possibly undefined
// 7: using guessed type char byte_7;
// 66BC7C: using guessed type void *off_66BC7C;

//----- (00513FCC) --------------------------------------------------------
CTask *__fastcall CTaskComplexSmartFleeEntity::ControlSubTask(CTaskComplexSmartFleeEntity *this, CPed *pPed)
{
  __int64 v4; // r0
  CTask *m_pSubTask; // r0
  unsigned int v6; // r3
  int m_iStartTime; // r1
  CEntity *m_pFleeEntity; // lr
  CSimpleTransform *p_m_transform; // r2
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r6
  float32x2_t v12; // d16
  unsigned __int64 v13; // d1
  int m_iEntityPosCheckPeriod; // r6
  CVector *p_m_vFleePos; // r1
  CMatrix *v16; // r3
  __int64 v17; // d16
  bool m_bScream; // r3
  float m_fSafeDistance; // s0
  CTask v20; // d16
  CEventGlobalGroup *EventGlobalGroup; // r0
  CEventSeenPanickedPed v23; // [sp+4h] [bp-24h] BYREF

  v4 = *(_QWORD *)&this->m_pSubTask;
  if ( HIDWORD(v4) )
  {
    if ( (*(int (__fastcall **)(_DWORD))(*(_DWORD *)v4 + 20))(v4) == 910 )
    {
      m_pSubTask = this->m_pSubTask;
      m_pSubTask[6]._vptr$CTask = (int (**)(void))this->m_iMoveState;
      if ( this->m_timer.m_bIsActive )
      {
        if ( this->m_timer.m_bIsStopped )
        {
          v6 = CTimer::m_snTimeInMilliseconds;
          this->m_timer.m_bIsStopped = 0;
          this->m_timer.m_iStartTime = v6;
          m_iStartTime = v6;
        }
        else
        {
          m_iStartTime = this->m_timer.m_iStartTime;
          v6 = CTimer::m_snTimeInMilliseconds;
        }
        if ( m_iStartTime + this->m_timer.m_iDuration <= v6 )
        {
          m_pFleeEntity = this->m_pFleeEntity;
          p_m_transform = &m_pFleeEntity->m_transform;
          m_pMat = m_pFleeEntity->m_pMat;
          p_tx = &m_pFleeEntity->m_transform;
          if ( m_pMat )
            p_tx = (CSimpleTransform *)&m_pMat->tx;
          v12.n64_u64[0] = vsub_f32(*(float32x2_t *)&this->m_vFleePos.y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
          v13 = vmul_f32(v12, v12).n64_u64[0];
          if ( (float)((float)((float)((float)(this->m_vFleePos.x - p_tx->m_translate.x)
                                     * (float)(this->m_vFleePos.x - p_tx->m_translate.x))
                             + *(float *)&v13)
                     + *((float *)&v13 + 1)) > (float)(this->m_fEntityPosChangeThreshold
                                                     * this->m_fEntityPosChangeThreshold) )
          {
            m_iEntityPosCheckPeriod = this->m_iEntityPosCheckPeriod;
            this->m_timer.m_bIsActive = 1;
            p_m_vFleePos = &this->m_vFleePos;
            this->m_timer.m_iStartTime = v6;
            this->m_timer.m_iDuration = m_iEntityPosCheckPeriod;
            v16 = m_pFleeEntity->m_pMat;
            if ( v16 )
              p_m_transform = (CSimpleTransform *)&v16->tx;
            v17 = *(_QWORD *)&p_m_transform->m_translate.x;
            this->m_vFleePos.z = p_m_transform->m_translate.z;
            *(_QWORD *)&p_m_vFleePos->x = v17;
            m_bScream = this->m_bScream;
            m_fSafeDistance = this->m_fSafeDistance;
            if ( *(float *)&m_pSubTask[3]._vptr$CTask != this->m_vFleePos.x
              || *(float *)&m_pSubTask[3].m_pParent != this->m_vFleePos.y
              || *(float *)&m_pSubTask[4]._vptr$CTask != this->m_vFleePos.z
              || *(float *)&m_pSubTask[5].m_pParent != m_fSafeDistance )
            {
              v20 = *(CTask *)&p_m_vFleePos->x;
              m_pSubTask[4]._vptr$CTask = (int (**)(void))LODWORD(this->m_vFleePos.z);
              m_pSubTask[3] = v20;
              BYTE1(m_pSubTask[8]._vptr$CTask) = 1;
              *(float *)&m_pSubTask[5].m_pParent = m_fSafeDistance;
            }
            LOBYTE(m_pSubTask[4].m_pParent) = m_bScream;
            if ( this->m_iMoveState >= 5 )
            {
              CEventSeenPanickedPed::CEventSeenPanickedPed(&v23, pPed);
              EventGlobalGroup = GetEventGlobalGroup();
              CEventGroup::Add(EventGlobalGroup, (CEvent *)&v23, 0);
              CEventSeenPanickedPed::~CEventSeenPanickedPed(&v23);
            }
          }
        }
      }
    }
  }
  else
  {
    (*(void (__fastcall **)(_DWORD, CPed *, _DWORD, _DWORD))(*(_DWORD *)v4 + 28))(v4, pPed, 0, 0);
  }
  return this->m_pSubTask;
}

//----- (00514158) --------------------------------------------------------
void __fastcall CTaskComplexFleeShooting::CTaskComplexFleeShooting(
        CTaskComplexFleeShooting *this,
        CEntity *pFleeEntity,
        const bool bScream,
        const float fSafeDistance,
        const int iFleeTime,
        const int iEntityPosCheckPeriod,
        const float fEntityPosChangeThreshold,
        int a8,
        float a9)
{
  CEntity *m_pFleeEntity; // r0

  CTaskComplex::CTaskComplex(this);
  this->m_iFleeTime = iFleeTime;
  this->m_fSafeDistance = fSafeDistance;
  this->m_bScream = bScream;
  this->m_iEntityPosCheckPeriod = a8;
  this->m_fEntityPosChangeThreshold = a9;
  this->m_iMoveState = 7;
  *(_WORD *)&this->m_timer.m_bIsActive = 0;
  this->m_timer.m_iStartTime = 0;
  this->m_timer.m_iDuration = 0;
  this->_vptr$CTask = (int (**)(void))&off_66BCB8;
  this->m_pFleeEntity = pFleeEntity;
  if ( pFleeEntity )
  {
    CEntity::RegisterReference(pFleeEntity, &this->m_pFleeEntity);
    m_pFleeEntity = this->m_pFleeEntity;
  }
  else
  {
    m_pFleeEntity = 0;
  }
  this->m_iShootTime = iEntityPosCheckPeriod;
  *(const float *)&this->m_iShootRecoverTime = fEntityPosChangeThreshold;
  *(_WORD *)&this->m_gunTimer.m_bIsActive = 0;
  this->m_gunTimer.m_iStartTime = 0;
  this->m_gunTimer.m_iDuration = 0;
  this->_vptr$CTask = (int (**)(void))&off_66BCF4;
  if ( m_pFleeEntity )
    CEntity::RegisterReference(m_pFleeEntity, &this->m_pFleeEntity);
}
// 66BCB8: using guessed type void *off_66BCB8;
// 66BCF4: using guessed type void *;

//----- (005141F0) --------------------------------------------------------
void __fastcall CTaskComplexFleeShooting::~CTaskComplexFleeShooting(CTaskComplexFleeShooting *this)
{
  CEntity *m_pFleeEntity; // r0
  CEntity **p_m_pFleeEntity; // r5
  CEntity *v4; // r0

  p_m_pFleeEntity = &this->m_pFleeEntity;
  m_pFleeEntity = this->m_pFleeEntity;
  this->_vptr$CTask = (int (**)(void))&off_66BCF4;
  if ( m_pFleeEntity )
  {
    CEntity::CleanUpOldReference(m_pFleeEntity, p_m_pFleeEntity);
    v4 = this->m_pFleeEntity;
    this->_vptr$CTask = (int (**)(void))&off_66BCB8;
    if ( v4 )
      CEntity::CleanUpOldReference(v4, p_m_pFleeEntity);
  }
  else
  {
    this->_vptr$CTask = (int (**)(void))&off_66BCB8;
  }
  sub_18EDB4(this);
}
// 66BCB8: using guessed type void *off_66BCB8;
// 66BCF4: using guessed type void *off_66BCF4;

//----- (00514248) --------------------------------------------------------
void __fastcall CTaskComplexFleeShooting::~CTaskComplexFleeShooting(CTaskComplexFleeShooting *this)
{
  CEntity *m_pFleeEntity; // r0
  CEntity **p_m_pFleeEntity; // r5
  CEntity *v4; // r0
  void *v5; // r0

  p_m_pFleeEntity = &this->m_pFleeEntity;
  m_pFleeEntity = this->m_pFleeEntity;
  this->_vptr$CTask = (int (**)(void))&off_66BCF4;
  if ( m_pFleeEntity )
  {
    CEntity::CleanUpOldReference(m_pFleeEntity, p_m_pFleeEntity);
    v4 = this->m_pFleeEntity;
    this->_vptr$CTask = (int (**)(void))&off_66BCB8;
    if ( v4 )
      CEntity::CleanUpOldReference(v4, p_m_pFleeEntity);
  }
  else
  {
    this->_vptr$CTask = (int (**)(void))&off_66BCB8;
  }
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v5);
}
// 514292: variable 'v5' is possibly undefined
// 66BCB8: using guessed type void *off_66BCB8;
// 66BCF4: using guessed type void *off_66BCF4;

//----- (005142A4) --------------------------------------------------------
bool __fastcall CTaskComplexFleeShooting::MakeAbortable(
        CTaskComplexFleeShooting *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CTask *TaskSecondary; // r0
  CTask *v9; // r4

  TaskSecondary = CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 0);
  v9 = TaskSecondary;
  if ( TaskSecondary && (*((int (__fastcall **)(CTask *))TaskSecondary->_vptr$CTask + 5))(TaskSecondary) == 1017 )
    (*((void (__fastcall **)(CTask *, CPed *, const int, const CEvent *))v9->_vptr$CTask + 7))(
      v9,
      pPed,
      iPriority,
      pEvent);
  return (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplexSmartFleeEntity::CTaskComplex::_vptr$CTask
          + 7))(
           this->m_pSubTask,
           pPed,
           iPriority,
           pEvent);
}

//----- (005142FE) --------------------------------------------------------
CTask *__fastcall CTaskComplexFleeShooting::CreateNextSubTask(CTaskComplexFleeShooting *this, CPed *pPed)
{
  __int64 v3; // kr00_8
  int v4; // r0
  int v5; // r1

  v3 = *(_QWORD *)&this->m_pSubTask;
  (*(void (__fastcall **)(_DWORD))(*(_DWORD *)v3 + 20))(v3);
  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplexSmartFleeEntity::CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( !HIDWORD(v3) )
    return 0;
  if ( v4 == 910 )
  {
    v5 = 1302;
    return CTaskComplexSmartFleeEntity::CreateSubTask(this, v5);
  }
  if ( v4 != 203 )
    return 0;
  v5 = 910;
  return CTaskComplexSmartFleeEntity::CreateSubTask(this, v5);
}

//----- (0051433C) --------------------------------------------------------
CTask *__fastcall CTaskComplexFleeShooting::CreateFirstSubTask(CTaskComplexFleeShooting *this, CPed *pPed)
{
  unsigned __int64 v2; // r2

  v2 = CTimer::m_snTimeInMilliseconds | 0xFFFFFFFF00000000LL;
  this->m_gunTimer.m_bIsActive = 1;
  *(_QWORD *)&this->m_gunTimer.m_iStartTime = v2;
  return CTaskComplexSmartFleeEntity::CreateFirstSubTask(this, pPed);
}

//----- (00514358) --------------------------------------------------------
CTask *__fastcall CTaskComplexFleeShooting::ControlSubTask(CTaskComplexFleeShooting *this, CPed *pPed)
{
  CTask *TaskSecondary; // r0
  CTaskSimpleUseGun *v5; // r6
  __int64 v6; // r0
  int m_bIsActive; // r0
  unsigned int v8; // r0
  int m_iStartTime; // r1
  eWeaponType m_eWeaponType; // r6
  int8 WeaponSkill; // r0
  __int64 v12; // r0
  CPedIntelligence *m_pPedIntelligence; // r8
  CTaskSimpleUseGun *v14; // r6
  CEntity *m_pFleeEntity; // r2
  CTaskSimpleUseGun *v16; // r0
  CPed *v17; // r1
  int8 v18; // r3
  CVector v20; // 0:r2.8,8:^0.4

  TaskSecondary = CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 0);
  v5 = (CTaskSimpleUseGun *)TaskSecondary;
  if ( TaskSecondary )
  {
    this->m_iMoveState = 6;
    if ( (*((int (__fastcall **)(CTask *))TaskSecondary->_vptr$CTask + 5))(TaskSecondary) == 1017 )
    {
      if ( this->m_gunTimer.m_bIsActive
        && (!this->m_gunTimer.m_bIsStopped ? (HIDWORD(v6) = this->m_gunTimer.m_iStartTime,
                                              LODWORD(v6) = CTimer::m_snTimeInMilliseconds) : (LODWORD(v6) = CTimer::m_snTimeInMilliseconds,
                                                                                               this->m_gunTimer.m_bIsStopped = 0,
                                                                                               this->m_gunTimer.m_iStartTime = v6,
                                                                                               HIDWORD(v6) = v6),
            HIDWORD(v6) + this->m_gunTimer.m_iDuration <= (unsigned int)v6) )
      {
        if ( v5->m_nLastCommand != 3 )
          return CTaskComplexSmartFleeEntity::ControlSubTask(this, pPed);
        HIDWORD(v6) = this->m_iShootRecoverTime;
        m_pFleeEntity = this->m_pFleeEntity;
        this->m_gunTimer.m_bIsActive = 1;
        v18 = 6;
        *(_QWORD *)&this->m_gunTimer.m_iStartTime = v6;
        v16 = v5;
        v17 = pPed;
      }
      else
      {
        m_pFleeEntity = this->m_pFleeEntity;
        v16 = v5;
        v17 = pPed;
        v18 = 3;
      }
      CTaskSimpleUseGun::ControlGun(v16, v17, m_pFleeEntity, v18);
    }
  }
  else
  {
    m_bIsActive = this->m_gunTimer.m_bIsActive;
    this->m_iMoveState = 7;
    if ( m_bIsActive )
    {
      if ( this->m_gunTimer.m_bIsStopped )
      {
        v8 = CTimer::m_snTimeInMilliseconds;
        this->m_gunTimer.m_bIsStopped = 0;
        this->m_gunTimer.m_iStartTime = v8;
        m_iStartTime = v8;
      }
      else
      {
        m_iStartTime = this->m_gunTimer.m_iStartTime;
        v8 = CTimer::m_snTimeInMilliseconds;
      }
      if ( m_iStartTime + this->m_gunTimer.m_iDuration <= v8 )
      {
        m_eWeaponType = pPed->m_WeaponSlots[pPed->m_nCurrentWeapon].m_eWeaponType;
        WeaponSkill = CPed::GetWeaponSkill(pPed);
        if ( (CWeaponInfo::GetWeaponInfo(m_eWeaponType, WeaponSkill)->m_nFlags & 2) != 0 )
        {
          HIDWORD(v12) = this->m_iShootTime;
          LODWORD(v12) = CTimer::m_snTimeInMilliseconds;
          *(_QWORD *)&this->m_gunTimer.m_iStartTime = v12;
          this->m_gunTimer.m_bIsActive = 1;
          m_pPedIntelligence = pPed->m_pPedIntelligence;
          v14 = (CTaskSimpleUseGun *)CTask::operator new(0x3Cu);
          v20.z = 0.0;
          *(_QWORD *)&v20.x = 0LL;
          CTaskSimpleUseGun::CTaskSimpleUseGun(v14, this->m_pFleeEntity, v20, 3, 3, 0);
          CTaskManager::SetTaskSecondary(&m_pPedIntelligence->m_taskManager, v14, 0);
        }
      }
    }
  }
  return CTaskComplexSmartFleeEntity::ControlSubTask(this, pPed);
}

//----- (005144B0) --------------------------------------------------------
void __fastcall CTaskComplexFleeAnyMeans::CTaskComplexFleeAnyMeans(
        CTaskComplexFleeAnyMeans *this,
        CEntity *pFleeEntity,
        const bool bAttackWhileFleeing,
        const float fSafeDistance,
        const int iFleeTime,
        const int iShootTime,
        const int iShootRecoverTime,
        const float fStealCarDist,
        const int iEntityPosCheckPeriod,
        const float fEntityPosChangeThreshold)
{
  CEntity *m_pFleeEntity; // r0

  CTaskComplex::CTaskComplex(this);
  this->m_iFleeTime = iFleeTime;
  this->m_fSafeDistance = fSafeDistance;
  this->m_bScream = 0;
  this->m_iEntityPosCheckPeriod = iEntityPosCheckPeriod;
  this->m_fEntityPosChangeThreshold = fEntityPosChangeThreshold;
  this->m_iMoveState = 7;
  *(_WORD *)&this->m_timer.m_bIsActive = 0;
  this->m_timer.m_iStartTime = 0;
  this->m_timer.m_iDuration = 0;
  this->_vptr$CTask = (int (**)(void))&off_66BCB8;
  this->m_pFleeEntity = pFleeEntity;
  if ( pFleeEntity )
  {
    CEntity::RegisterReference(pFleeEntity, &this->m_pFleeEntity);
    m_pFleeEntity = this->m_pFleeEntity;
  }
  else
  {
    m_pFleeEntity = 0;
  }
  this->m_bAttackWhileFleeing = bAttackWhileFleeing;
  this->m_iShootTime = iShootTime;
  this->m_iShootRecoverTime = iShootRecoverTime;
  this->m_fStealCarDist = fStealCarDist;
  this->m_pStealVehicle = 0;
  this->_vptr$CTask = (int (**)(void))&off_66BD30;
  if ( m_pFleeEntity )
    CEntity::RegisterReference(m_pFleeEntity, &this->m_pFleeEntity);
}
// 66BCB8: using guessed type void *;
// 66BD30: using guessed type void *;

//----- (0051455C) --------------------------------------------------------
void __fastcall CTaskComplexFleeAnyMeans::~CTaskComplexFleeAnyMeans(CTaskComplexFleeAnyMeans *this)
{
  CEntity *m_pFleeEntity; // r0
  CEntity **p_m_pFleeEntity; // r5
  CEntity *v4; // r0

  p_m_pFleeEntity = &this->m_pFleeEntity;
  m_pFleeEntity = this->m_pFleeEntity;
  this->_vptr$CTask = (int (**)(void))&off_66BD30;
  if ( m_pFleeEntity )
  {
    CEntity::CleanUpOldReference(m_pFleeEntity, p_m_pFleeEntity);
    v4 = this->m_pFleeEntity;
    this->_vptr$CTask = (int (**)(void))&off_66BCB8;
    if ( v4 )
      CEntity::CleanUpOldReference(v4, p_m_pFleeEntity);
  }
  else
  {
    this->_vptr$CTask = (int (**)(void))&off_66BCB8;
  }
  sub_18EDB4(this);
}
// 66BCB8: using guessed type void *off_66BCB8;
// 66BD30: using guessed type void *off_66BD30;

//----- (005145B4) --------------------------------------------------------
void __fastcall CTaskComplexFleeAnyMeans::~CTaskComplexFleeAnyMeans(CTaskComplexFleeAnyMeans *this)
{
  CEntity *m_pFleeEntity; // r0
  CEntity **p_m_pFleeEntity; // r5
  CEntity *v4; // r0
  void *v5; // r0

  p_m_pFleeEntity = &this->m_pFleeEntity;
  m_pFleeEntity = this->m_pFleeEntity;
  this->_vptr$CTask = (int (**)(void))&off_66BD30;
  if ( m_pFleeEntity )
  {
    CEntity::CleanUpOldReference(m_pFleeEntity, p_m_pFleeEntity);
    v4 = this->m_pFleeEntity;
    this->_vptr$CTask = (int (**)(void))&off_66BCB8;
    if ( v4 )
      CEntity::CleanUpOldReference(v4, p_m_pFleeEntity);
  }
  else
  {
    this->_vptr$CTask = (int (**)(void))&off_66BCB8;
  }
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v5);
}
// 5145FE: variable 'v5' is possibly undefined
// 66BCB8: using guessed type void *off_66BCB8;
// 66BD30: using guessed type void *off_66BD30;

//----- (00514610) --------------------------------------------------------
CTask *__fastcall CTaskComplexFleeAnyMeans::CreateSubTask(
        const CTaskComplexFleeAnyMeans *this,
        const int iSubTaskType,
        CPed *pPed)
{
  char *v5; // r4
  CTaskComplex *v6; // r0
  CEntity *m_pFleeEntity; // r10
  __int64 v8; // kr00_8
  __int64 v9; // r8
  bool m_bScream; // r5
  CEntity *v11; // r0
  CVehicle *m_pStealVehicle; // r3
  CMatrix *m_pMat; // r0
  const CVector *p_tx; // r2
  unsigned __int16 v15; // r0
  CVector iDrivingStyle; // [sp+0h] [bp-38h] BYREF
  int m_iShootRecoverTime; // [sp+14h] [bp-24h]
  int m_iShootTime; // [sp+18h] [bp-20h]

  v5 = 0;
  if ( iSubTaskType <= 900 )
  {
    if ( iSubTaskType == 702 )
    {
      v5 = (char *)CTask::operator new(0x20u);
      CTaskComplexStealCar::CTaskComplexStealCar((CTaskComplexStealCar *)v5, this->m_pStealVehicle);
    }
    else if ( iSubTaskType == 724 )
    {
      v5 = (char *)CTask::operator new(0x2Cu);
      CTaskComplexCarDriveMission::CTaskComplexCarDriveMission(
        (CTaskComplexCarDriveMission *)v5,
        pPed->m_pMyVehicle,
        0,
        1,
        3,
        40.0);
    }
  }
  else
  {
    switch ( iSubTaskType )
    {
      case 901:
        v5 = (char *)CTask::operator new(0x38u);
        m_pStealVehicle = this->m_pStealVehicle;
        m_pMat = m_pStealVehicle->m_pMat;
        p_tx = (const CVector *)&m_pMat->tx;
        memset(&iDrivingStyle, 0, sizeof(iDrivingStyle));
        if ( !m_pMat )
          p_tx = &m_pStealVehicle->m_transform.m_translate;
        CTaskComplexGoToPointShooting::CTaskComplexGoToPointShooting(
          (CTaskComplexGoToPointShooting *)v5,
          6,
          p_tx,
          m_pStealVehicle,
          iDrivingStyle,
          CModelInfo::ms_modelInfoPtrs[m_pStealVehicle->m_nModelIndex]->m_pColModel->m_sphereBound.m_fRadius + 0.35,
          4.0);
        break;
      case 912:
        v5 = (char *)CTask::operator new(0x28u);
        v15 = rand();
        CTaskComplexWander::CTaskComplexWander(
          (CTaskComplexWander *)v5,
          7,
          (int)(float)((float)((float)v15 * 0.000015259) * 8.0),
          0,
          0.5);
        *(_DWORD *)v5 = &off_66BBB8;
        break;
      case 928:
        v6 = (CTaskComplex *)CTask::operator new(0x54u);
        m_pFleeEntity = this->m_pFleeEntity;
        v5 = (char *)v6;
        v8 = *(_QWORD *)&this->m_iFleeTime;
        m_iShootTime = this->m_iShootTime;
        m_iShootRecoverTime = this->m_iShootRecoverTime;
        v9 = *(_QWORD *)&this->m_iEntityPosCheckPeriod;
        m_bScream = this->m_bScream;
        CTaskComplex::CTaskComplex(v6);
        v5[36] = m_bScream;
        *((_DWORD *)v5 + 10) = v9;
        *(_QWORD *)(v5 + 28) = v8;
        *((_DWORD *)v5 + 11) = HIDWORD(v9);
        *((_DWORD *)v5 + 12) = 7;
        *((_WORD *)v5 + 30) = 0;
        *((_DWORD *)v5 + 13) = 0;
        *((_DWORD *)v5 + 14) = 0;
        *(_DWORD *)v5 = &off_66BCB8;
        *((_DWORD *)v5 + 3) = m_pFleeEntity;
        if ( m_pFleeEntity )
        {
          CEntity::RegisterReference(m_pFleeEntity, (CEntity **)v5 + 3);
          v11 = (CEntity *)*((_DWORD *)v5 + 3);
        }
        else
        {
          v11 = 0;
        }
        *((_DWORD *)v5 + 16) = m_iShootTime;
        *((_DWORD *)v5 + 17) = m_iShootRecoverTime;
        *((_WORD *)v5 + 40) = 0;
        *((_DWORD *)v5 + 18) = 0;
        *((_DWORD *)v5 + 19) = 0;
        *(_DWORD *)v5 = &off_66BCF4;
        if ( v11 )
          CEntity::RegisterReference(v11, (CEntity **)v5 + 3);
        break;
    }
  }
  return (CTask *)v5;
}
// 66BBB8: using guessed type void *off_66BBB8;
// 66BCB8: using guessed type void *off_66BCB8;
// 66BCF4: using guessed type void *off_66BCF4;
// 67733C: using guessed type void *`vtable for'CTaskComplexWanderFlee;

//----- (005147E4) --------------------------------------------------------
CTask *__fastcall CTaskComplexFleeAnyMeans::CreateNextSubTask(CTaskComplexFleeAnyMeans *this, CPed *pPed)
{
  int v4; // r0
  bool v5; // zf
  CTaskComplexStealCar *v6; // r0
  bool v7; // zf
  int (**v8)(void); // r0
  CTaskComplexCarDriveMission *v9; // r0
  CTask *result; // r0
  CTaskComplexCarDriveMission *v11; // r0

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplexSmartFleeEntity::CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v4 == 901 )
  {
    if ( this->m_pStealVehicle )
    {
      v6 = (CTaskComplexStealCar *)CTask::operator new(0x20u);
      CTaskComplexStealCar::CTaskComplexStealCar(v6, this->m_pStealVehicle);
      return result;
    }
    v8 = this->_vptr$CTask;
    this->m_pStealVehicle = 0;
    return (CTask *)((int (__fastcall *)(CTaskComplexFleeAnyMeans *, CPed *))v8[11])(this, pPed);
  }
  if ( v4 == 724 )
  {
    v7 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
    if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
      v7 = pPed->m_pMyVehicle == 0;
    if ( !v7 )
    {
      v11 = (CTaskComplexCarDriveMission *)CTask::operator new(0x2Cu);
      CTaskComplexCarDriveMission::CTaskComplexCarDriveMission(v11, pPed->m_pMyVehicle, 0, 1, 3, 40.0);
      return result;
    }
    v8 = this->_vptr$CTask;
    return (CTask *)((int (__fastcall *)(CTaskComplexFleeAnyMeans *, CPed *))v8[11])(this, pPed);
  }
  if ( v4 != 702 )
    return 0;
  v5 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
  if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
    v5 = pPed->m_pMyVehicle == 0;
  if ( v5 )
  {
    result = (CTask *)(*((int (__fastcall **)(CTaskComplexFleeAnyMeans *, CPed *))this->_vptr$CTask + 11))(this, pPed);
  }
  else
  {
    v9 = (CTaskComplexCarDriveMission *)CTask::operator new(0x2Cu);
    CTaskComplexCarDriveMission::CTaskComplexCarDriveMission(v9, pPed->m_pMyVehicle, 0, 1, 3, 40.0);
  }
  this->m_pStealVehicle = 0;
  return result;
}

//----- (005148B2) --------------------------------------------------------
CTask *__fastcall CTaskComplexFleeAnyMeans::CreateFirstSubTask(CTaskComplexFleeAnyMeans *this, CPed *pPed)
{
  CVehicle *m_pMyVehicle; // r1
  bool v4; // zf
  int v6; // r1

  m_pMyVehicle = pPed->m_pMyVehicle;
  v4 = m_pMyVehicle == 0;
  if ( m_pMyVehicle )
    v4 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
  if ( v4 )
  {
    v6 = 928;
    if ( !this->m_bAttackWhileFleeing )
      v6 = 912;
  }
  else
  {
    v6 = 724;
  }
  return CTaskComplexFleeAnyMeans::CreateSubTask(this, v6, pPed);
}

//----- (005148E0) --------------------------------------------------------
CTask *__fastcall CTaskComplexFleeAnyMeans::ControlSubTask(CTaskComplexFleeAnyMeans *this, CPed *pPed)
{
  CTask **p_m_pSubTask; // r9
  CVehicle *ClosestVehicleInRange; // r6
  CEntity *m_pFleeEntity; // r1
  CMatrix *m_pMat; // r2
  CMatrix *v8; // r3
  CSimpleTransform *p_tx; // r0
  float *p_x; // r2
  float x; // s2
  float y; // s4
  float z; // s0
  float v14; // s6
  CMatrix *v15; // r1
  float *v16; // r2
  CVehicle *m_pStealVehicle; // r0
  CVehicle **p_m_pStealVehicle; // r8
  const CPed *pDriver; // r0
  CVehicle *v20; // r0
  int v21; // r1
  int v22; // r10
  const CPed *v23; // r0
  int v24; // r6
  CTask **v25; // r4
  CTask *v26; // r6
  CEventVehicleDamage v28; // [sp+4h] [bp-44h] BYREF
  CVector v29; // [sp+20h] [bp-28h] BYREF

  if ( this->m_pFleeEntity )
  {
    p_m_pSubTask = &this->m_pSubTask;
    ClosestVehicleInRange = CVehicleScanner::GetClosestVehicleInRange(&pPed->m_pPedIntelligence->m_vehicleScanner);
    if ( !ClosestVehicleInRange
      || (*((int (__fastcall **)(CTask *))(*p_m_pSubTask)->_vptr$CTask + 5))(*p_m_pSubTask) != 928
      && (*((int (__fastcall **)(CTask *))(*p_m_pSubTask)->_vptr$CTask + 5))(*p_m_pSubTask) != 912 )
    {
      return *p_m_pSubTask;
    }
    m_pFleeEntity = this->m_pFleeEntity;
    m_pMat = pPed->m_pMat;
    v8 = m_pFleeEntity->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pPed->m_transform;
    p_x = &v8->tx;
    x = p_tx->m_translate.x;
    y = p_tx->m_translate.y;
    z = p_tx->m_translate.z;
    if ( !v8 )
      p_x = &m_pFleeEntity->m_transform.m_translate.x;
    v29.x = x - *p_x;
    v29.y = y - p_x[1];
    v14 = (float)(z - p_x[2]) * (float)(z - p_x[2]);
    v29.z = z - p_x[2];
    if ( (float)(v14 + (float)((float)(v29.x * v29.x) + (float)(v29.y * v29.y))) <= (float)(this->m_fStealCarDist
                                                                                          * this->m_fStealCarDist) )
      return *p_m_pSubTask;
    v15 = ClosestVehicleInRange->m_pMat;
    v16 = &v15->tx;
    if ( !v15 )
      v16 = &ClosestVehicleInRange->m_transform.m_translate.x;
    v29.x = *v16 - x;
    v29.y = v16[1] - p_tx->m_translate.y;
    v29.z = v16[2] - z;
    CVector::Normalise(&v29);
    if ( (float)((float)((float)(v29.x * pPed->m_pMat->xy) + (float)(v29.y * pPed->m_pMat->yy))
               + (float)(v29.z * pPed->m_pMat->zy)) <= 0.0
      || !CCarEnterExit::IsVehicleStealable(ClosestVehicleInRange, pPed) )
    {
      return *p_m_pSubTask;
    }
    p_m_pStealVehicle = &this->m_pStealVehicle;
    m_pStealVehicle = this->m_pStealVehicle;
    if ( m_pStealVehicle )
      CEntity::CleanUpOldReference(m_pStealVehicle, &this->m_pStealVehicle);
    this->m_pStealVehicle = ClosestVehicleInRange;
    CEntity::RegisterReference(ClosestVehicleInRange, &this->m_pStealVehicle);
    if ( this->m_bAttackWhileFleeing )
    {
      pDriver = (*p_m_pStealVehicle)->pDriver;
      if ( pDriver && !CPed::IsPlayer(pDriver) )
      {
        CEventVehicleDamage::CEventVehicleDamage(&v28, *p_m_pStealVehicle, pPed, WEAPONTYPE_PISTOL);
        v28.m_iTaskType = 706;
        v28._vptr$CEvent = (int (**)(void))&off_669BAC;
        CEventGroup::Add(&(*p_m_pStealVehicle)->pDriver->m_pPedIntelligence->m_eventGroup, (CEvent *)&v28, 0);
        CEventVehicleDamage::~CEventVehicleDamage(&v28);
      }
      v20 = *p_m_pStealVehicle;
      if ( (*p_m_pStealVehicle)->m_nMaxPassengers )
      {
        v21 = 282;
        do
        {
          v22 = v21;
          v23 = (const CPed *)*((_DWORD *)&v20->_vptr$CPlaceable + v21);
          if ( v23 && !CPed::IsPlayer(v23) )
          {
            CEventVehicleDamage::CEventVehicleDamage(&v28, *p_m_pStealVehicle, pPed, WEAPONTYPE_PISTOL);
            v28.m_iTaskType = 706;
            v28._vptr$CEvent = (int (**)(void))&off_669BAC;
            CEventGroup::Add(
              (CEventGroup *)(*(_DWORD *)(*((_DWORD *)&(*p_m_pStealVehicle)->_vptr$CPlaceable + v22) + 1088) + 104),
              (CEvent *)&v28,
              0);
            CEventVehicleDamage::~CEventVehicleDamage(&v28);
          }
          v20 = *p_m_pStealVehicle;
          v21 = v22 + 1;
        }
        while ( v22 - 281 < (*p_m_pStealVehicle)->m_nMaxPassengers );
      }
      v24 = 901;
    }
    else
    {
      if ( !(*((int (__fastcall **)(CVehicle *, _DWORD))ClosestVehicleInRange->_vptr$CPlaceable + 58))(
              ClosestVehicleInRange,
              0) )
        return *p_m_pSubTask;
      v24 = 702;
    }
    if ( (*((int (__fastcall **)(CTask *, CPed *, _DWORD, _DWORD))(*p_m_pSubTask)->_vptr$CTask + 7))(
           *p_m_pSubTask,
           pPed,
           0,
           0) == 1 )
      return CTaskComplexFleeAnyMeans::CreateSubTask(this, v24, pPed);
    return *p_m_pSubTask;
  }
  v25 = &this->m_pSubTask;
  v26 = 0;
  if ( !(*((int (__fastcall **)(CTask *, CPed *, _DWORD, _DWORD))this->m_pSubTask->CTaskComplexSmartFleeEntity::CTaskComplex::_vptr$CTask
         + 7))(
          this->m_pSubTask,
          pPed,
          0,
          0) )
    return *v25;
  return v26;
}
// 669BAC: using guessed type void *off_669BAC;

//----- (00514B78) --------------------------------------------------------
CTask *__fastcall CTaskComplexWanderFlee::Clone(const CTaskComplexWanderFlee *this)
{
  CTaskComplexWander *v2; // r0
  CTask *result; // r0

  v2 = (CTaskComplexWander *)CTask::operator new(0x28u);
  CTaskComplexWander::CTaskComplexWander(v2, this->m_iMoveState, this->m_iDir, 0, 0.5);
  result->_vptr$CTask = (int (**)(void))&off_66BBB8;
  return result;
}
// 514BA6: variable 'result' is possibly undefined
// 66BBB8: using guessed type void *off_66BBB8;
// 67733C: using guessed type void *`vtable for'CTaskComplexWanderFlee;

//----- (00514BB4) --------------------------------------------------------
int __fastcall CTaskComplexWanderFlee::GetWanderType(const CTaskComplexWanderFlee *this)
{
  return 6;
}

//----- (00514BBC) --------------------------------------------------------
CTask *__fastcall CTaskComplexFleePoint::Clone(const CTaskComplexFleePoint *this)
{
  CTaskComplex *v2; // r0
  CTask *m_iFleeTime; // r5
  float m_fSafeDistance; // r6
  bool m_bScream; // r8
  CTask *result; // r0
  __int64 v7; // d16

  v2 = (CTaskComplex *)CTask::operator new(0x3Cu);
  m_iFleeTime = (CTask *)this->m_iFleeTime;
  m_fSafeDistance = this->m_fSafeDistance;
  m_bScream = this->m_bScream;
  CTaskComplex::CTaskComplex(v2);
  result->_vptr$CTask = (int (**)(void))&off_66BC04;
  v7 = *(_QWORD *)&this->m_vFleePos.x;
  result[2].m_pParent = (CTask *)LODWORD(this->m_vFleePos.z);
  result[4].m_pParent = m_iFleeTime;
  result[5]._vptr$CTask = 0;
  result[5].m_pParent = 0;
  LOWORD(result[6]._vptr$CTask) = 0;
  *(float *)&result[6].m_pParent = m_fSafeDistance;
  LOBYTE(result[7]._vptr$CTask) = m_bScream;
  BYTE1(result[7]._vptr$CTask) = 0;
  *(_QWORD *)&result[1].m_pParent = v7;
  if ( m_iFleeTime != (CTask *)-1 )
  {
    result[5]._vptr$CTask = (int (**)(void))CTimer::m_snTimeInMilliseconds;
    result[5].m_pParent = m_iFleeTime;
    LOBYTE(result[6]._vptr$CTask) = 1;
  }
  return result;
}
// 514BE0: variable 'result' is possibly undefined
// 66BC04: using guessed type void *off_66BC04;

//----- (00514C28) --------------------------------------------------------
int __fastcall CTaskComplexFleePoint::GetTaskType(const CTaskComplexFleePoint *this)
{
  return 908;
}

//----- (00514C30) --------------------------------------------------------
CTask *__fastcall CTaskComplexFleeEntity::Clone(const CTaskComplexFleeEntity *this)
{
  char *v2; // r4
  CEntity *m_pFleeEntity; // r5
  int m_iFleeTime; // r8
  float m_fSafeDistance; // r9
  bool m_bScream; // r10
  __int64 v7; // kr00_8

  v2 = (char *)CTask::operator new(0x3Cu);
  m_pFleeEntity = this->m_pFleeEntity;
  m_iFleeTime = this->m_iFleeTime;
  m_fSafeDistance = this->m_fSafeDistance;
  m_bScream = this->m_bScream;
  v7 = *(_QWORD *)&this->m_iEntityPosCheckPeriod;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_DWORD *)v2 + 7) = m_iFleeTime;
  *((_WORD *)v2 + 20) = 0;
  *((float *)v2 + 11) = m_fSafeDistance;
  *(_QWORD *)(v2 + 52) = v7;
  v2[48] = m_bScream;
  *((_DWORD *)v2 + 8) = 0;
  *((_DWORD *)v2 + 9) = 0;
  *(_DWORD *)v2 = &off_66BC40;
  *((_DWORD *)v2 + 3) = m_pFleeEntity;
  if ( m_pFleeEntity )
    CEntity::RegisterReference(m_pFleeEntity, (CEntity **)v2 + 3);
  return (CTask *)v2;
}
// 66BC40: using guessed type void *off_66BC40;

//----- (00514C9C) --------------------------------------------------------
int __fastcall CTaskComplexFleeEntity::GetTaskType(const CTaskComplexFleeEntity *this)
{
  return 909;
}

//----- (00514CA4) --------------------------------------------------------
CTask *__fastcall CTaskComplexSmartFleePoint::Clone(const CTaskComplexSmartFleePoint *this)
{
  CTaskComplex *v2; // r0
  bool m_bScream; // r8
  CTask v4; // kr00_8
  CTask *result; // r0
  CTask v6; // d16

  v2 = (CTaskComplex *)CTask::operator new(0x44u);
  m_bScream = this->m_bScream;
  v4 = *(CTask *)&this->m_iFleeTime;
  CTaskComplex::CTaskComplex(v2);
  result->_vptr$CTask = (int (**)(void))&off_66BC7C;
  v6 = *(CTask *)&this->m_vFleePos.x;
  result[4]._vptr$CTask = (int (**)(void))LODWORD(this->m_vFleePos.z);
  result[5] = v4;
  result[6]._vptr$CTask = (int (**)(void))&byte_7;
  result[6].m_pParent = 0;
  result[7]._vptr$CTask = 0;
  LOBYTE(result[4].m_pParent) = m_bScream;
  LOWORD(result[7].m_pParent) = 0;
  LOWORD(result[8]._vptr$CTask) = 0;
  result[3] = v6;
  if ( v4._vptr$CTask != (int (**)(void))-1 )
  {
    result[6].m_pParent = (CTask *)CTimer::m_snTimeInMilliseconds;
    result[7]._vptr$CTask = v4._vptr$CTask;
    LOBYTE(result[7].m_pParent) = 1;
  }
  return result;
}
// 514CCA: variable 'result' is possibly undefined
// 7: using guessed type char byte_7;
// 66BC7C: using guessed type void *off_66BC7C;

//----- (00514D14) --------------------------------------------------------
int __fastcall CTaskComplexSmartFleePoint::GetTaskType(const CTaskComplexSmartFleePoint *this)
{
  return 910;
}

//----- (00514D1C) --------------------------------------------------------
CTask *__fastcall CTaskComplexSmartFleeEntity::Clone(const CTaskComplexSmartFleeEntity *this)
{
  CTaskComplex *v2; // r0
  CEntity *m_pFleeEntity; // r6
  CTaskComplex *v4; // r5
  __int64 v5; // r8
  float m_fEntityPosChangeThreshold; // r11
  bool m_bScream; // r10
  int m_iEntityPosCheckPeriod; // [sp+0h] [bp-20h]

  v2 = (CTaskComplex *)CTask::operator new(0x40u);
  m_pFleeEntity = this->m_pFleeEntity;
  v4 = v2;
  v5 = *(_QWORD *)&this->m_iFleeTime;
  m_iEntityPosCheckPeriod = this->m_iEntityPosCheckPeriod;
  m_fEntityPosChangeThreshold = this->m_fEntityPosChangeThreshold;
  m_bScream = this->m_bScream;
  CTaskComplex::CTaskComplex(v2);
  *(_QWORD *)&v4[2].m_pParent = v5;
  LOBYTE(v4[3]._vptr$CTask) = m_bScream;
  v4[3].m_pParent = (CTask *)m_iEntityPosCheckPeriod;
  *(float *)&v4[3].m_pSubTask = m_fEntityPosChangeThreshold;
  v4[4]._vptr$CTask = (int (**)(void))&byte_7;
  LOWORD(v4[5]._vptr$CTask) = 0;
  v4[4].m_pParent = 0;
  v4[4].m_pSubTask = 0;
  v4->_vptr$CTask = (int (**)(void))&off_66BCB8;
  v4[1]._vptr$CTask = (int (**)(void))m_pFleeEntity;
  if ( m_pFleeEntity )
    CEntity::RegisterReference(m_pFleeEntity, (CEntity **)&v4[1]);
  v4[4]._vptr$CTask = (int (**)(void))this->m_iMoveState;
  return v4;
}
// 7: using guessed type char byte_7;
// 66BCB8: using guessed type void *off_66BCB8;

//----- (00514D94) --------------------------------------------------------
int __fastcall CTaskComplexSmartFleeEntity::GetTaskType(const CTaskComplexSmartFleeEntity *this)
{
  return 911;
}

//----- (00514D9C) --------------------------------------------------------
void __fastcall CTaskComplexSmartFleeEntity::Serialize(CTaskComplexSmartFleeEntity *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CEntity *m_pFleeEntity; // r0
  int v5; // r6
  _DWORD *v6; // r5
  CEntity *v7; // r0
  int v8; // r1
  int v9; // r4
  int v10; // r0
  _DWORD *v11; // r4
  _DWORD *v12; // r5

  v2 = (*((int (__fastcall **)(CTaskComplexSmartFleeEntity *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexSmartFleeEntity *))this->_vptr$CTask + 5))(this) == 911 )
  {
    m_pFleeEntity = this->m_pFleeEntity;
    if ( m_pFleeEntity )
    {
      v5 = *(_BYTE *)&m_pFleeEntity->m_info & 7;
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      free(v6);
      v7 = this->m_pFleeEntity;
      v8 = *(_BYTE *)&v7->m_info & 7;
      switch ( v8 )
      {
        case 2:
          v9 = GettPoolVehicleRef((CVehicle *)v7);
          break;
        case 4:
          v9 = GettPoolObjRef((CObject *)v7);
          break;
        case 3:
          v9 = GettPoolPedRef((CPed *)v7);
          break;
        default:
          return;
      }
      if ( UseDataFence )
        AddDataFence();
      v12 = malloc(4u);
      *v12 = v9;
      CGenericGameStorage::_SaveDataToWorkBuffer(v12, 4);
      j_free(v12);
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v11 = malloc(4u);
      *v11 = 0;
      CGenericGameStorage::_SaveDataToWorkBuffer(v11, 4);
      j_free(v11);
    }
  }
  else
  {
    v10 = (*((int (__fastcall **)(CTaskComplexSmartFleeEntity *))this->_vptr$CTask + 5))(this);
    sub_1941C4(911, v10);
  }
}

//----- (00514EDC) --------------------------------------------------------
CTask *__fastcall CTaskComplexFleeShooting::Clone(const CTaskComplexFleeShooting *this)
{
  CTaskComplex *v2; // r0
  CEntity *m_pFleeEntity; // r10
  CTaskComplex *v4; // r4
  __int64 v5; // kr00_8
  __int64 v6; // r8
  CEntity *v7; // r0
  int m_iShootRecoverTime; // [sp+4h] [bp-24h]
  int m_iShootTime; // [sp+8h] [bp-20h]

  v2 = (CTaskComplex *)CTask::operator new(0x54u);
  m_pFleeEntity = this->m_pFleeEntity;
  v4 = v2;
  v5 = *(_QWORD *)&this->m_iFleeTime;
  m_iShootTime = this->m_iShootTime;
  m_iShootRecoverTime = this->m_iShootRecoverTime;
  v6 = *(_QWORD *)&this->m_iEntityPosCheckPeriod;
  LOBYTE(this) = this->m_bScream;
  CTaskComplex::CTaskComplex(v2);
  LOBYTE(v4[3]._vptr$CTask) = (_BYTE)this;
  v4[3].m_pParent = (CTask *)v6;
  *(_QWORD *)&v4[2].m_pParent = v5;
  v4[3].m_pSubTask = (CTask *)HIDWORD(v6);
  v4[4]._vptr$CTask = (int (**)(void))&byte_7;
  LOWORD(v4[5]._vptr$CTask) = 0;
  v4[4].m_pParent = 0;
  v4[4].m_pSubTask = 0;
  v4->_vptr$CTask = (int (**)(void))&off_66BCB8;
  v4[1]._vptr$CTask = (int (**)(void))m_pFleeEntity;
  if ( m_pFleeEntity )
  {
    CEntity::RegisterReference(m_pFleeEntity, (CEntity **)&v4[1]);
    v7 = (CEntity *)v4[1]._vptr$CTask;
  }
  else
  {
    v7 = 0;
  }
  v4[5].m_pParent = (CTask *)m_iShootTime;
  v4[5].m_pSubTask = (CTask *)m_iShootRecoverTime;
  LOWORD(v4[6].m_pSubTask) = 0;
  v4[6]._vptr$CTask = 0;
  v4[6].m_pParent = 0;
  v4->_vptr$CTask = (int (**)(void))&off_66BCF4;
  if ( v7 )
    CEntity::RegisterReference(v7, (CEntity **)&v4[1]);
  return v4;
}
// 7: using guessed type char byte_7;
// 66BCB8: using guessed type void *off_66BCB8;
// 66BCF4: using guessed type void *off_66BCF4;

//----- (00514F88) --------------------------------------------------------
int __fastcall CTaskComplexFleeShooting::GetTaskType(const CTaskComplexFleeShooting *this)
{
  return 928;
}

//----- (00514F90) --------------------------------------------------------
CTask *__fastcall CTaskComplexFleeAnyMeans::Clone(const CTaskComplexFleeAnyMeans *this)
{
  char *v2; // r4
  float m_fStealCarDist; // r11
  __int64 v4; // r8
  CEntity *m_pFleeEntity; // r6
  __int64 v6; // kr00_8
  CEntity *v7; // r0
  int m_iShootRecoverTime; // [sp+0h] [bp-28h]
  int m_iShootTime; // [sp+4h] [bp-24h]
  bool m_bAttackWhileFleeing; // [sp+8h] [bp-20h]

  v2 = (char *)CTask::operator new(0x54u);
  m_bAttackWhileFleeing = this->m_bAttackWhileFleeing;
  m_iShootTime = this->m_iShootTime;
  m_iShootRecoverTime = this->m_iShootRecoverTime;
  m_fStealCarDist = this->m_fStealCarDist;
  v4 = *(_QWORD *)&this->m_iEntityPosCheckPeriod;
  m_pFleeEntity = this->m_pFleeEntity;
  v6 = *(_QWORD *)&this->m_iFleeTime;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *(_QWORD *)(v2 + 28) = v6;
  *((_QWORD *)v2 + 5) = v4;
  *((_DWORD *)v2 + 12) = 7;
  *(_DWORD *)v2 = &off_66BCB8;
  *((_DWORD *)v2 + 3) = m_pFleeEntity;
  v2[36] = 0;
  *((_WORD *)v2 + 30) = 0;
  *((_DWORD *)v2 + 13) = 0;
  *((_DWORD *)v2 + 14) = 0;
  if ( m_pFleeEntity )
  {
    CEntity::RegisterReference(m_pFleeEntity, (CEntity **)v2 + 3);
    v7 = (CEntity *)*((_DWORD *)v2 + 3);
  }
  else
  {
    v7 = 0;
  }
  v2[64] = m_bAttackWhileFleeing;
  *((_DWORD *)v2 + 17) = m_iShootTime;
  *((_DWORD *)v2 + 18) = m_iShootRecoverTime;
  *((float *)v2 + 19) = m_fStealCarDist;
  *((_DWORD *)v2 + 20) = 0;
  *(_DWORD *)v2 = &off_66BD30;
  if ( v7 )
    CEntity::RegisterReference(v7, (CEntity **)v2 + 3);
  return (CTask *)v2;
}
// 66BCB8: using guessed type void *off_66BCB8;
// 66BD30: using guessed type void *off_66BD30;

//----- (00515044) --------------------------------------------------------
int __fastcall CTaskComplexFleeAnyMeans::GetTaskType(const CTaskComplexFleeAnyMeans *this)
{
  return 927;
}

//----- (0051504C) --------------------------------------------------------
void __fastcall CTaskComplexFleeAnyMeans::Serialize(CTaskComplexFleeAnyMeans *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CEntity *m_pFleeEntity; // r0
  int v5; // r6
  _DWORD *v6; // r5
  CEntity *v7; // r0
  int v8; // r1
  int v9; // r5
  int v10; // r0
  _DWORD *v11; // r5
  void *v12; // r0
  _DWORD *v13; // r6
  float *v14; // r5
  _DWORD *v15; // r5
  _DWORD *v16; // r5
  _DWORD *v17; // r5
  float *v18; // r5
  _DWORD *v19; // r5
  float *v20; // r5

  v2 = (*((int (__fastcall **)(CTaskComplexFleeAnyMeans *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexFleeAnyMeans *))this->_vptr$CTask + 5))(this) != 927 )
  {
    v10 = (*((int (__fastcall **)(CTaskComplexFleeAnyMeans *))this->_vptr$CTask + 5))(this);
    sub_1941C4(927, v10);
    return;
  }
  m_pFleeEntity = this->m_pFleeEntity;
  if ( !m_pFleeEntity )
  {
    if ( UseDataFence )
      AddDataFence();
    v11 = malloc(4u);
    *v11 = 0;
    CGenericGameStorage::_SaveDataToWorkBuffer(v11, 4);
    v12 = v11;
    goto LABEL_20;
  }
  v5 = *(_BYTE *)&m_pFleeEntity->m_info & 7;
  if ( UseDataFence )
    AddDataFence();
  v6 = malloc(4u);
  *v6 = v5;
  CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
  free(v6);
  v7 = this->m_pFleeEntity;
  v8 = *(_BYTE *)&v7->m_info & 7;
  switch ( v8 )
  {
    case 2:
      v9 = GettPoolVehicleRef((CVehicle *)v7);
      goto LABEL_17;
    case 4:
      v9 = GettPoolObjRef((CObject *)v7);
      goto LABEL_17;
    case 3:
      v9 = GettPoolPedRef((CPed *)v7);
LABEL_17:
      if ( UseDataFence )
        AddDataFence();
      v13 = malloc(4u);
      *v13 = v9;
      CGenericGameStorage::_SaveDataToWorkBuffer(v13, 4);
      v12 = v13;
LABEL_20:
      free(v12);
      break;
  }
  if ( UseDataFence )
    AddDataFence();
  CGenericGameStorage::_SaveDataToWorkBuffer(&this->m_bAttackWhileFleeing, 1);
  if ( UseDataFence )
    AddDataFence();
  v14 = (float *)malloc(4u);
  *v14 = this->m_fSafeDistance;
  CGenericGameStorage::_SaveDataToWorkBuffer(v14, 4);
  free(v14);
  if ( UseDataFence )
    AddDataFence();
  v15 = malloc(4u);
  *v15 = this->m_iFleeTime;
  CGenericGameStorage::_SaveDataToWorkBuffer(v15, 4);
  free(v15);
  if ( UseDataFence )
    AddDataFence();
  v16 = malloc(4u);
  *v16 = this->m_iShootTime;
  CGenericGameStorage::_SaveDataToWorkBuffer(v16, 4);
  free(v16);
  if ( UseDataFence )
    AddDataFence();
  v17 = malloc(4u);
  *v17 = this->m_iShootRecoverTime;
  CGenericGameStorage::_SaveDataToWorkBuffer(v17, 4);
  free(v17);
  if ( UseDataFence )
    AddDataFence();
  v18 = (float *)malloc(4u);
  *v18 = this->m_fStealCarDist;
  CGenericGameStorage::_SaveDataToWorkBuffer(v18, 4);
  free(v18);
  if ( UseDataFence )
    AddDataFence();
  v19 = malloc(4u);
  *v19 = this->m_iEntityPosCheckPeriod;
  CGenericGameStorage::_SaveDataToWorkBuffer(v19, 4);
  free(v19);
  if ( UseDataFence )
    AddDataFence();
  v20 = (float *)malloc(4u);
  *v20 = this->m_fEntityPosChangeThreshold;
  CGenericGameStorage::_SaveDataToWorkBuffer(v20, 4);
  j_free(v20);
}

//----- (005152F0) --------------------------------------------------------
void __fastcall CTaskComplexGangLeader::CTaskComplexGangLeader(CTaskComplexGangLeader *this, CPedGroup *pPedGroup)
{
  int v3; // r0

  CTaskComplex::CTaskComplex(this);
  *(_WORD *)(v3 + 24) = 0;
  *(_WORD *)(v3 + 36) = 0;
  *(_DWORD *)(v3 + 16) = 0;
  *(_DWORD *)(v3 + 20) = 0;
  *(_DWORD *)(v3 + 28) = 0;
  *(_DWORD *)(v3 + 32) = 0;
  *(_WORD *)(v3 + 48) = 0;
  *(_DWORD *)(v3 + 40) = 0;
  *(_DWORD *)(v3 + 44) = 0;
  *(_DWORD *)(v3 + 12) = pPedGroup;
  *(_BYTE *)(v3 + 52) = 0;
  *(_DWORD *)v3 = &off_66BD6C;
}
// 5152FE: variable 'v3' is possibly undefined
// 66BD6C: using guessed type void *;

//----- (00515324) --------------------------------------------------------
void __fastcall CTaskComplexGangLeader::~CTaskComplexGangLeader(CTaskComplexGangLeader *this)
{
  int m_animsReferenced; // r1
  int32 AnimationBlockIndex; // r0

  m_animsReferenced = this->m_animsReferenced;
  this->_vptr$CTask = (int (**)(void))&off_66BD6C;
  if ( m_animsReferenced )
  {
    AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("gangs");
    CAnimManager::RemoveAnimBlockRef(AnimationBlockIndex);
    this->m_animsReferenced = 0;
  }
  sub_18EDB4(this);
}
// 66BD6C: using guessed type void *off_66BD6C;

//----- (00515364) --------------------------------------------------------
void __fastcall CTaskComplexGangLeader::~CTaskComplexGangLeader(CTaskComplexGangLeader *this)
{
  int m_animsReferenced; // r1
  int32 AnimationBlockIndex; // r0
  void *v4; // r0

  m_animsReferenced = this->m_animsReferenced;
  this->_vptr$CTask = (int (**)(void))&off_66BD6C;
  if ( m_animsReferenced )
  {
    AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("gangs");
    CAnimManager::RemoveAnimBlockRef(AnimationBlockIndex);
    this->m_animsReferenced = 0;
  }
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 51539A: variable 'v4' is possibly undefined
// 66BD6C: using guessed type void *off_66BD6C;

//----- (005153A8) --------------------------------------------------------
bool __fastcall CTaskComplexGangLeader::MakeAbortable(
        CTaskComplexGangLeader *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CTask *m_pSubTask; // r0

  m_pSubTask = this->m_pSubTask;
  if ( m_pSubTask
    && (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))m_pSubTask->_vptr$CTask + 7))(
         m_pSubTask,
         pPed,
         iPriority,
         pEvent) != 1 )
  {
    return 0;
  }
  *((_DWORD *)&pPed->m_nPedFlags + 2) &= ~0x400000u;
  return 1;
}

//----- (005153D4) --------------------------------------------------------
CTask *__fastcall CTaskComplexGangLeader::CreateNextSubTask(CTaskComplexGangLeader *this, CPed *pPed)
{
  int v3; // r5
  CTask *m_pSubTask; // r0
  unsigned __int16 v5; // r0
  CPed *Member; // r6
  CTaskComplexTurnToFaceEntityOrCoord *v7; // r4
  int v8; // s0
  unsigned __int16 v9; // r0
  unsigned __int16 v10; // r0

  v3 = CPedGroupMembership::CountMembers(&this->m_pPedGroup->m_membership);
  m_pSubTask = this->m_pSubTask;
  if ( m_pSubTask
    && ((*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) == 203
     || (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 426)
    && (v5 = rand(),
        (Member = CPedGroupMembership::GetMember(
                    &this->m_pPedGroup->m_membership,
                    (int)(float)((float)((float)v5 * 0.000015259) * (float)v3))) != 0) )
  {
    v7 = (CTaskComplexTurnToFaceEntityOrCoord *)CTask::operator new(0x28u);
    CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(v7, Member, 0.5, 0.2);
  }
  else
  {
    v8 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0);
    if ( v3 < 3 || v8 >= 96 )
    {
      v9 = rand();
      this->m_wanderTimer.m_iStartTime = CTimer::m_snTimeInMilliseconds;
      this->m_wanderTimer.m_bIsActive = 1;
      this->m_wanderTimer.m_iDuration = (int)(float)((float)((float)v9 * 0.000015259) * 15000.0) + 15000;
      v7 = (CTaskComplexTurnToFaceEntityOrCoord *)CTask::operator new(0x38u);
      v10 = rand();
      CTaskComplexWanderGang::CTaskComplexWanderGang(
        (CTaskComplexWanderGang *)v7,
        4,
        (int)(float)((float)((float)v10 * 0.000015259) * 8.0),
        5000,
        1,
        0.05);
    }
    else
    {
      v7 = (CTaskComplexTurnToFaceEntityOrCoord *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v7, 5000, 0, 0, 8.0);
    }
  }
  return v7;
}

//----- (00515550) --------------------------------------------------------
CTask *__fastcall CTaskComplexGangLeader::CreateFirstSubTask(CTaskComplexGangLeader *this, CPed *pPed)
{
  return (CTask *)(*((int (__fastcall **)(CTaskComplexGangLeader *, CPed *))this->_vptr$CTask + 10))(this, pPed);
}

//----- (00515558) --------------------------------------------------------
CTask *__fastcall CTaskComplexGangLeader::ControlSubTask(CTaskComplexGangLeader *this, CPed *pPed)
{
  int m_animsReferenced; // r6
  CPlayerPed *v5; // r1
  float *m_pMyVehicle; // r0
  bool v7; // zf
  _BOOL4 v8; // r0
  int32 AnimationBlockIndex; // r0
  bool8 v10; // r0
  int32 v11; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r3
  CPathFind *x_low; // r1
  unsigned int v15; // r0
  int m_iStartTime; // r1
  void *v17; // r4
  unsigned int v18; // r0
  int v19; // r1
  RwObject_0 *m_pRwObject; // r1
  FxSystem_c *v21; // r0
  FxSystem_c *v22; // r6
  unsigned __int16 v23; // r6
  unsigned __int16 v24; // r0
  CPed *Member; // r0
  bool v26; // zf
  CEntity *EntityThatThisPedIsHolding; // r11
  CAnimBlendAssociation *Association; // r6
  CAnimBlendAssociation *v29; // r8
  unsigned int v30; // r6
  CAnimBlendAssociation *v31; // r10
  int v32; // r9
  int m_nModelIndex; // r0
  unsigned __int16 v35; // r0
  unsigned __int16 v36; // r0
  int v37; // r0
  CPedIntelligence *m_pPedIntelligence; // r6
  CTaskComplexPlayHandSignalAnim *v39; // r5
  unsigned __int16 v40; // r0
  CPed *ClosestGroupPed; // r8
  int v43; // r0
  UInt16 v44; // r1
  CTaskSimpleHoldEntity *ActiveTaskByType; // r6
  AnimationId RandomGangAmbientAnim; // r0
  bool fromScript; // [sp+1Ch] [bp-44h]
  RwV3d_0 offsetPos; // [sp+24h] [bp-3Ch] BYREF
  CEntity *v49; // [sp+30h] [bp-30h] BYREF
  char v50; // [sp+34h] [bp-2Ch]
  CVector v51; // 0:r2.8,8:^0.4

  *((_DWORD *)&pPed->m_nPedFlags + 2) &= ~0x400000u;
  m_animsReferenced = this->m_animsReferenced;
  v5 = CWorld::Players[CWorld::PlayerInFocus].pPed;
  m_pMyVehicle = (float *)v5->m_pMyVehicle;
  v7 = m_pMyVehicle == 0;
  if ( m_pMyVehicle )
    v7 = (*(_DWORD *)&v5->m_nPedFlags & 0x100) == 0;
  if ( v7
    || (float)((float)((float)(m_pMyVehicle[18] * m_pMyVehicle[18]) + (float)(m_pMyVehicle[19] * m_pMyVehicle[19]))
             + (float)(m_pMyVehicle[20] * m_pMyVehicle[20])) <= 0.04 )
  {
    v8 = !CStreaming::IsVeryBusy();
    if ( !m_animsReferenced )
    {
LABEL_6:
      if ( v8 )
      {
        AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("gangs");
        if ( !CAnimManager::ms_aAnimBlocks[AnimationBlockIndex].m_loaded )
        {
          CStreaming::RequestModel(AnimationBlockIndex + 25575, 8);
          goto LABEL_14;
        }
        CAnimManager::AddAnimBlockRef(AnimationBlockIndex);
        v10 = 1;
        goto LABEL_12;
      }
      goto LABEL_14;
    }
  }
  else
  {
    v8 = 0;
    if ( !m_animsReferenced )
      goto LABEL_6;
  }
  if ( !v8 )
  {
    v11 = CAnimManager::GetAnimationBlockIndex("gangs");
    CAnimManager::RemoveAnimBlockRef(v11);
    v10 = 0;
LABEL_12:
    this->m_animsReferenced = v10;
  }
LABEL_14:
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 203
    && !((unsigned __int8)CTimer::m_FrameCounter << 28) )
  {
    m_pMat = pPed->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pPed->m_transform;
    x_low = (CPathFind *)LODWORD(p_tx->m_translate.x);
    *(_QWORD *)&v51.x = *(_QWORD *)&p_tx->m_translate.y;
    LODWORD(v51.z) = 1;
    if ( (unsigned __int16)CPathFind::FindNodeClosestToCoors(
                             (CNodeAddress *)&ThePaths,
                             x_low,
                             v51,
                             2.0,
                             0.0,
                             0,
                             0,
                             0,
                             0,
                             fromScript) == 0xFFFF )
    {
      v35 = rand();
      this->m_wanderTimer.m_iStartTime = CTimer::m_snTimeInMilliseconds;
      this->m_wanderTimer.m_bIsActive = 1;
      this->m_wanderTimer.m_iDuration = (int)(float)((float)((float)v35 * 0.000015259) * 40000.0) + 20000;
      v17 = CTask::operator new(0x38u);
      v36 = rand();
      CTaskComplexWanderGang::CTaskComplexWanderGang(
        (CTaskComplexWanderGang *)v17,
        4,
        (int)(float)((float)((float)v36 * 0.000015259) * 8.0),
        5000,
        1,
        0.05);
      return (CTask *)v17;
    }
  }
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 912
    && this->m_wanderTimer.m_bIsActive )
  {
    if ( this->m_wanderTimer.m_bIsStopped )
    {
      v15 = CTimer::m_snTimeInMilliseconds;
      this->m_wanderTimer.m_bIsStopped = 0;
      this->m_wanderTimer.m_iStartTime = v15;
      m_iStartTime = v15;
    }
    else
    {
      m_iStartTime = this->m_wanderTimer.m_iStartTime;
      v15 = CTimer::m_snTimeInMilliseconds;
    }
    if ( m_iStartTime + this->m_wanderTimer.m_iDuration <= v15
      && CTaskComplexWanderGang::GetDistanceSqToNode((CTaskComplexWanderGang *)this->m_pSubTask, pPed) < 2.0 )
    {
      CPedGroupIntelligence::SetDefaultTaskAllocatorType(&this->m_pPedGroup->m_intelligence, 5);
      v17 = CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v17, 500, 0, 0, 8.0);
      return (CTask *)v17;
    }
  }
  if ( this->m_exhaleTimer.m_bIsActive )
  {
    if ( this->m_exhaleTimer.m_bIsStopped )
    {
      v18 = CTimer::m_snTimeInMilliseconds;
      this->m_exhaleTimer.m_bIsStopped = 0;
      this->m_exhaleTimer.m_iStartTime = v18;
      v19 = v18;
    }
    else
    {
      v19 = this->m_exhaleTimer.m_iStartTime;
      v18 = CTimer::m_snTimeInMilliseconds;
    }
    if ( v19 + this->m_exhaleTimer.m_iDuration <= v18 )
    {
      offsetPos.y = 0.1;
      offsetPos.x = 0.0;
      offsetPos.z = 0.0;
      m_pRwObject = pPed->m_pRwObject;
      if ( m_pRwObject )
      {
        v21 = FxManager_c::CreateFxSystem(
                &g_fxMan,
                "exhale",
                &offsetPos,
                (RwMatrix *)((char *)m_pRwObject->parent + 16),
                0);
        v22 = v21;
        if ( v21 )
        {
          FxSystem_c::AttachToBone(v21, pPed, 5);
          FxSystem_c::PlayAndKill(v22);
        }
        this->m_exhaleTimer.m_bIsActive = 0;
      }
    }
  }
  (*((void (__fastcall **)(CTaskComplexGangLeader *, CPed *))this->_vptr$CTask + 13))(this, pPed);
  if ( !CEntity::IsVisible(pPed) )
    return this->m_pSubTask;
  if ( !IKChainManager_c::IsLooking(&g_ikChainMan, pPed)
    && (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) >= 96 )
  {
    v23 = rand();
    v24 = rand();
    Member = CPedGroupMembership::GetMember(
               &this->m_pPedGroup->m_membership,
               (int)(float)((float)((float)v24 * 0.000015259) * 8.0));
    v26 = Member == 0;
    if ( Member )
      v26 = Member == pPed;
    if ( !v26 )
      IKChainManager_c::LookAt(
        &g_ikChainMan,
        "TaskGangLeader",
        pPed,
        Member,
        (int)(float)((int)(float)((float)((float)v23 * 0.000015259) * 2000.0) + 3000),
        5,
        0,
        1,
        0.15,
        500,
        3,
        0);
  }
  if ( !this->m_animsReferenced || pPed->m_eMoveState > PEDMOVE_JOG )
    return this->m_pSubTask;
  EntityThatThisPedIsHolding = CPed::GetEntityThatThisPedIsHolding(pPed);
  if ( !EntityThatThisPedIsHolding )
  {
    if ( CPed::IsPlayingHandSignal(pPed) || CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 4) )
      return this->m_pSubTask;
    v37 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 500.0);
    if ( (unsigned int)(v37 - 51) > 4 )
    {
      if ( v37 != 100 )
        return this->m_pSubTask;
      m_pPedIntelligence = pPed->m_pPedIntelligence;
      v39 = (CTaskComplexPlayHandSignalAnim *)CTask::operator new(0x18u);
      CTaskComplexPlayHandSignalAnim::CTaskComplexPlayHandSignalAnim(v39, (const AnimationId)-1, 4.0);
    }
    else
    {
      m_pPedIntelligence = pPed->m_pPedIntelligence;
      v39 = (CTaskComplexPlayHandSignalAnim *)CTask::operator new(0x20u);
      v40 = rand();
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        (CTaskSimpleRunAnim *)v39,
        ANIM_GANG_PED,
        (const AnimationId)((int)(float)((float)((float)v40 * 0.000015259) * 8.0) + 279),
        4.0,
        0);
    }
    CTaskManager::SetTaskSecondary(&m_pPedIntelligence->m_taskManager, v39, 4);
    return this->m_pSubTask;
  }
  Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x12Bu);
  v29 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x12Cu);
  v30 = (unsigned int)Association | (unsigned int)v29 | (unsigned int)RpAnimBlendClumpGetAssociation(
                                                                        (RpClump_0 *)pPed->m_pRwObject,
                                                                        0x12Du);
  v31 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x12Eu);
  v32 = v30 | (unsigned int)v31;
  if ( v30 | (unsigned int)v31 )
  {
    v32 = 1;
    if ( IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
      IKChainManager_c::AbortLookAt(&g_ikChainMan, pPed, 250);
    *((_DWORD *)&pPed->m_nPedFlags + 2) |= 0x400000u;
  }
  if ( (unsigned int)v29 | (unsigned int)v31
    && (v29 && v29->m_fCurrentTime < 0.5 || v31 && v31->m_fCurrentTime < 0.5)
    && !this->m_exhaleTimer.m_bIsActive )
  {
    *(_QWORD *)&this->m_exhaleTimer.m_iStartTime = CTimer::m_snTimeInMilliseconds | 0xA8C00000000LL;
    this->m_exhaleTimer.m_bIsActive = 1;
  }
  m_nModelIndex = EntityThatThisPedIsHolding->m_nModelIndex;
  if ( m_nModelIndex == MI_GANG_DRINK )
  {
    CPed::Say(pPed, 0x17u, 0, 0.2, 0, 0, 0);
  }
  else if ( m_nModelIndex == MI_GANG_SMOKE )
  {
    CPed::Say(pPed, 0xC8u, 0, 0.2, 0, 0, 0);
  }
  if ( CTaskManager::FindActiveTaskByType(&pPed->m_pPedIntelligence->m_taskManager, 1211) )
    return this->m_pSubTask;
  if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 500.0) != 200 )
  {
    if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) == 50 )
    {
      ActiveTaskByType = (CTaskSimpleHoldEntity *)CTaskManager::FindActiveTaskByType(
                                                    &pPed->m_pPedIntelligence->m_taskManager,
                                                    307);
      if ( ActiveTaskByType )
      {
        RandomGangAmbientAnim = CTaskComplexGangLeader::GetRandomGangAmbientAnim(pPed, EntityThatThisPedIsHolding);
        CTaskSimpleHoldEntity::PlayAnim(ActiveTaskByType, RandomGangAmbientAnim, ANIM_GANG_PED);
      }
    }
    return this->m_pSubTask;
  }
  if ( v32 )
    return this->m_pSubTask;
  ClosestGroupPed = CPedGroup::GetClosestGroupPed(this->m_pPedGroup, pPed, &offsetPos.x);
  if ( !ClosestGroupPed
    || offsetPos.x >= 4.0
    || CPed::IsPlayer(pPed)
    || CPed::GetEntityThatThisPedIsHolding(ClosestGroupPed)
    || ClosestGroupPed->m_WeaponSlots[ClosestGroupPed->m_nCurrentWeapon].m_eWeaponType )
  {
    return this->m_pSubTask;
  }
  v43 = EntityThatThisPedIsHolding->m_nModelIndex;
  if ( v43 == MI_GANG_DRINK )
  {
    v44 = 24;
LABEL_88:
    CPed::Say(ClosestGroupPed, v44, 0, 1.0, 0, 0, 0);
    goto LABEL_89;
  }
  if ( v43 == MI_GANG_SMOKE )
  {
    v44 = 201;
    goto LABEL_88;
  }
LABEL_89:
  CEvent::CEvent((CEvent *)&offsetPos);
  v49 = pPed;
  LODWORD(offsetPos.x) = &off_6670B0;
  CEntity::RegisterReference(pPed, &v49);
  v50 = 0;
  CEventGroup::Add(&ClosestGroupPed->m_pPedIntelligence->m_eventGroup, (CEvent *)&offsetPos, 0);
  v17 = CTask::operator new(0x30u);
  CTaskComplex::CTaskComplex((CTaskComplex *)v17);
  *((_WORD *)v17 + 20) = 0;
  *((_BYTE *)v17 + 16) = 1;
  *((_DWORD *)v17 + 8) = 0;
  *((_DWORD *)v17 + 9) = 0;
  *(_DWORD *)v17 = &off_66BFEC;
  *((_DWORD *)v17 + 3) = ClosestGroupPed;
  CEntity::RegisterReference(ClosestGroupPed, (CEntity **)v17 + 3);
  LODWORD(offsetPos.x) = &off_6670B0;
  if ( v49 )
    CEntity::CleanUpOldReference(v49, &v49);
  CEvent::~CEvent((CEvent *)&offsetPos);
  return (CTask *)v17;
}
// 51567C: variable 'fromScript' is possibly undefined
// 6670B0: using guessed type void *off_6670B0;
// 66BFEC: using guessed type void *off_66BFEC;
// 6778F8: using guessed type __int16 *MI_GANG_DRINK_ptr;
// 679000: using guessed type __int16 *MI_GANG_SMOKE_ptr;

//----- (00515D28) --------------------------------------------------------
bool CTaskComplexGangLeader::ShouldLoadGangAnims()
{
  CPlayerPed *pPed; // r1
  float *m_pMyVehicle; // r0
  bool v2; // zf

  pPed = CWorld::Players[CWorld::PlayerInFocus].pPed;
  m_pMyVehicle = (float *)pPed->m_pMyVehicle;
  v2 = m_pMyVehicle == 0;
  if ( m_pMyVehicle )
    v2 = (*(_DWORD *)&pPed->m_nPedFlags & 0x100) == 0;
  return (v2
       || (float)((float)((float)(m_pMyVehicle[18] * m_pMyVehicle[18]) + (float)(m_pMyVehicle[19] * m_pMyVehicle[19]))
                + (float)(m_pMyVehicle[20] * m_pMyVehicle[20])) <= 0.04)
      && !CStreaming::IsVeryBusy();
}

//----- (00515DA0) --------------------------------------------------------
CPed *__fastcall CTaskComplexGangLeader::TryToPassObject(CPed *pPed, CPedGroup *pPedGroup)
{
  CPed *ClosestGroupPed; // r4
  float retDistSqr[3]; // [sp+4h] [bp-Ch] BYREF

  ClosestGroupPed = CPedGroup::GetClosestGroupPed(pPedGroup, pPed, retDistSqr);
  if ( !ClosestGroupPed || retDistSqr[0] >= 4.0 )
    return 0;
  if ( CPed::IsPlayer(pPed) )
    return 0;
  return ClosestGroupPed;
}
// 515DA0: using guessed type float retDistSqr[3];

//----- (00515DE0) --------------------------------------------------------
AnimationId __fastcall CTaskComplexGangLeader::GetRandomGangAmbientAnim(CPed *pPed, CEntity *objectBeingHeld)
{
  int m_nModelIndex; // r0
  int v4; // s0
  float v5; // s4
  AnimationId result; // r0
  int v7; // r1
  bool v8; // zf
  int v9; // r1
  bool v10; // zf

  if ( !objectBeingHeld )
    goto LABEL_7;
  m_nModelIndex = objectBeingHeld->m_nModelIndex;
  if ( m_nModelIndex != MI_GANG_DRINK )
  {
    if ( m_nModelIndex == MI_GANG_SMOKE && (rand() & 1) != 0 )
    {
      v9 = pPed->m_nModelIndex;
      result = ANIM_GANG_SMOKE_FAT;
      v10 = v9 == 103;
      if ( v9 != 103 )
        v10 = v9 == 105;
      if ( !v10 )
        return 300;
      return result;
    }
LABEL_7:
    v5 = 8.0;
    v4 = (unsigned __int16)rand();
    return (int)(float)((float)((float)v4 * 0.000015259) * v5) + 279;
  }
  if ( (rand() & 1) == 0 )
  {
    v4 = (unsigned __int16)rand();
    v5 = 4.0;
    return (int)(float)((float)((float)v4 * 0.000015259) * v5) + 279;
  }
  v7 = pPed->m_nModelIndex;
  result = ANIM_GANG_DRINK_FAT;
  v8 = v7 == 103;
  if ( v7 != 103 )
    v8 = v7 == 105;
  if ( !v8 )
    return 299;
  return result;
}
// 6778F8: using guessed type __int16 *MI_GANG_DRINK_ptr;
// 679000: using guessed type __int16 *MI_GANG_SMOKE_ptr;

//----- (00515E90) --------------------------------------------------------
void __fastcall CTaskComplexGangLeader::ScanForStuff(CTaskComplexGangLeader *this, CPed *pPed)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d10
  unsigned int v6; // r0
  int m_iStartTime; // r1
  int v8; // r0
  CEventGroupEvent *v9; // r6
  CEntity **m_entities; // r4
  int v11; // r8
  uint32 *v12; // r11
  CEntity *v13; // r5
  int v14; // r0
  bool v15; // zf
  CMatrix *v16; // r0
  float32x2_t *v17; // r1
  CSimpleTransform *p_m_transform; // r2
  float32x2_t *v19; // r0
  float *p_z; // r2
  float32x2_t v21; // d16
  float v22; // s0
  float32x2_t v23; // d16
  unsigned __int64 v24; // d1
  CEventGroupEvent *v25; // r11
  void *v26; // r6
  CEvent *v27; // r2
  CEventGroupEvent *v28; // r0
  int v29; // r0
  CPedIntelligence *m_pPedIntelligence; // r4
  int v31; // r11
  int v32; // r5
  CPedGroup *PedsGroup; // r8
  CPlayerPed *PlayerPed; // r0
  CTask *ActiveTaskByType; // r0
  CTaskComplexWanderGang *v36; // r6
  int32 GroupId; // r4
  CTaskComplexBeInGroup *v38; // r6
  int v39; // r6
  CTask *v40; // r9
  CPedGroupMembership *p_m_membership; // r8
  CPed *Member; // r0
  bool v43; // zf
  CMatrix *m_pMat; // r1
  int v45; // r2
  CSimpleTransform *p_tx; // r3
  int v47; // r1
  float32x2_t v48; // d16
  unsigned __int64 v49; // d1
  bool v50; // nf
  unsigned __int16 v51; // r4
  int v52; // r0
  CEntity **v53; // r6
  int m_iTaskPriority; // r4
  unsigned __int16 v55; // [sp+4h] [bp-84h]
  int *v56; // [sp+8h] [bp-80h]
  CEvent v57; // [sp+10h] [bp-78h] BYREF
  int v58; // [sp+1Ch] [bp-6Ch]
  CEntity *v59; // [sp+20h] [bp-68h] BYREF
  char v60; // [sp+24h] [bp-64h]
  int v61; // [sp+28h] [bp-60h]
  CEventScriptCommand v62; // [sp+2Ch] [bp-5Ch] BYREF
  int v63; // [sp+44h] [bp-44h]

  if ( !this->m_scanTimer.m_bIsActive
    || (!this->m_scanTimer.m_bIsStopped ? (m_iStartTime = this->m_scanTimer.m_iStartTime,
                                           v6 = CTimer::m_snTimeInMilliseconds) : (v6 = CTimer::m_snTimeInMilliseconds,
                                                                                   this->m_scanTimer.m_bIsStopped = 0,
                                                                                   this->m_scanTimer.m_iStartTime = v6,
                                                                                   m_iStartTime = v6),
        m_iStartTime + this->m_scanTimer.m_iDuration <= v6) )
  {
    v8 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0);
    if ( v8 > 4 )
    {
      if ( v8 == 20 )
      {
        v29 = 76;
        m_pPedIntelligence = pPed->m_pPedIntelligence;
        while ( 1 )
        {
          v31 = v29;
          v32 = *((_DWORD *)&m_pPedIntelligence->m_pPed + v29);
          if ( v32 )
          {
            if ( *(_BYTE *)(v32 + 1096) == 1 && pPed->m_nPedType == *(_DWORD *)(v32 + 1436) )
            {
              PedsGroup = CPedGroups::GetPedsGroup((const CPed *)v32);
              if ( PedsGroup != this->m_pPedGroup && !(*(unsigned __int8 *)(v32 + 1157) << 31) )
              {
                PlayerPed = FindPlayerPed(-1);
                if ( !CPedGroupMembership::IsMember(
                        &CPedGroups::ms_groups[PlayerPed->m_pPlayerData->m_PlayerGroup].m_membership,
                        (const CPed *)v32) )
                {
                  ActiveTaskByType = CTaskManager::FindActiveTaskByType(&pPed->m_pPedIntelligence->m_taskManager, 912);
                  v36 = (CTaskComplexWanderGang *)ActiveTaskByType;
                  if ( !ActiveTaskByType
                    || (*((int (__fastcall **)(CTask *))ActiveTaskByType->_vptr$CTask + 13))(ActiveTaskByType) != 4
                    || CTaskComplexWanderGang::CanJoinGang(v36) )
                  {
                    break;
                  }
                }
              }
            }
          }
          v29 = v31 + 1;
          if ( v31 - 76 >= 15 )
            return;
        }
        if ( !PedsGroup )
        {
          GroupId = CPedGroups::GetGroupId(this->m_pPedGroup);
          if ( CPedGroupMembership::CountMembersExcludingLeader(&this->m_pPedGroup->m_membership) <= 6 )
          {
            v38 = (CTaskComplexBeInGroup *)CTask::operator new(0x28u);
            CTaskComplexBeInGroup::CTaskComplexBeInGroup(v38, GroupId, 0);
            CEventScriptCommand::CEventScriptCommand(&v62, 3, v38, 0);
            CEventGroup::Add((CEventGroup *)(*(_DWORD *)(v32 + 1088) + 104), &v62, 0);
            CPedGroupMembership::AddFollower(&this->m_pPedGroup->m_membership, (CPed *)v32);
            CPedGroup::Process(this->m_pPedGroup);
            CEventScriptCommand::~CEventScriptCommand(&v62);
          }
        }
        v39 = 0;
        v3.n64_u32[0] = 1315859240;
        v40 = 0;
        p_m_membership = &this->m_pPedGroup->m_membership;
        do
        {
          Member = CPedGroupMembership::GetMember(p_m_membership, v39);
          v43 = Member == 0;
          if ( Member )
            v43 = Member == (CPed *)v32;
          if ( !v43 )
          {
            m_pMat = Member->m_pMat;
            v45 = *(_DWORD *)(v32 + 20);
            p_tx = (CSimpleTransform *)&m_pMat->tx;
            if ( !m_pMat )
              p_tx = &Member->m_transform;
            v47 = v45 + 48;
            if ( !v45 )
              v47 = v32 + 4;
            v48.n64_u64[0] = vsub_f32(*(float32x2_t *)(v47 + 4), *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
            v49 = vmul_f32(v48, v48).n64_u64[0];
            v2.n64_f32[0] = (float)((float)((float)(*(float *)v47 - p_tx->m_translate.x)
                                          * (float)(*(float *)v47 - p_tx->m_translate.x))
                                  + *(float *)&v49)
                          + *((float *)&v49 + 1);
            v50 = v2.n64_f32[0] < v3.n64_f32[0];
            v3.n64_u64[0] = vmin_f32(v2, v3).n64_u64[0];
            if ( v50 )
              v40 = (CTask *)Member;
          }
          ++v39;
        }
        while ( v39 != 8 );
        if ( v3.n64_f32[0] <= 100.0 && v3.n64_f32[0] >= 16.0 )
        {
          v51 = rand();
          CEvent::CEvent(&v62);
          v53 = (CEntity **)(v52 + 16);
          v62.m_pTask = v40;
          v62.m_bAcceptWhenDead = 1;
          v63 = 1056964608;
          v62._vptr$CEvent = (int (**)(void))&off_669024;
          v62.m_iTaskPriority = (int)(float)((float)((float)v51 * 0.000015259) * 7.0);
          m_iTaskPriority = v62.m_iTaskPriority;
          if ( v40 )
            CEntity::RegisterReference((CEntity *)v40, v53);
          CEventGroup::Add((CEventGroup *)(*(_DWORD *)(v32 + 1088) + 104), &v62, 0);
          CEvent::CEvent(&v57);
          v58 = m_iTaskPriority;
          v57._vptr$CEvent = (int (**)(void))&off_669024;
          v59 = (CEntity *)v32;
          v60 = 0;
          v61 = 1056964608;
          CEntity::RegisterReference((CEntity *)v32, &v59);
          CEventGroup::Add((CEventGroup *)(v40[136]._vptr$CTask + 26), &v57, 0);
          v57._vptr$CEvent = (int (**)(void))&off_669024;
          if ( v59 )
            CEntity::CleanUpOldReference(v59, &v59);
          CEvent::~CEvent(&v57);
          v62._vptr$CEvent = (int (**)(void))&off_669024;
          if ( v62.m_pTask )
            CEntity::CleanUpOldReference((CEntity *)v62.m_pTask, v53);
          CEvent::~CEvent(&v62);
        }
        *(_QWORD *)&this->m_scanTimer.m_iStartTime = CTimer::m_snTimeInMilliseconds | 0x271000000000LL;
        this->m_scanTimer.m_bIsActive = 1;
      }
    }
    else
    {
      v9 = (CEventGroupEvent *)&v62;
      m_entities = pPed->m_pPedIntelligence->m_vehicleScanner.m_entities;
      v11 = 0;
      v12 = &CTimer::m_snTimeInMilliseconds;
      do
      {
        v13 = m_entities[v11];
        if ( v13 && !LODWORD(v13[24].m_transform.m_translate.x) )
        {
          v14 = *(_BYTE *)&v13->m_info & 0xF8;
          v15 = v14 == 32;
          if ( v14 == 32 )
            v15 = BYTE2(v13[17].m_pLod) << 31 == 0;
          if ( v15 && LOBYTE(v13[19].m_pLod) != 2 )
          {
            v16 = pPed->m_pMat;
            v17 = (float32x2_t *)v13->m_pMat;
            p_m_transform = (CSimpleTransform *)&v16->tx;
            if ( !v16 )
              p_m_transform = &pPed->m_transform;
            v19 = v17 + 6;
            v21.n64_u64[0] = *(unsigned __int64 *)&p_m_transform->m_translate.x;
            p_z = &p_m_transform->m_translate.z;
            if ( !v17 )
              v19 = (float32x2_t *)&v13->m_transform;
            v22 = v19[1].n64_f32[0] - *p_z;
            if ( fabsf(v22) < 5.0 )
            {
              v23.n64_u64[0] = vsub_f32((float32x2_t)v19->n64_u64[0], v21).n64_u64[0];
              v24 = vmul_f32(v23, v23).n64_u64[0];
              if ( (float)((float)(*(float *)&v24 + *((float *)&v24 + 1)) + (float)(v22 * v22)) < 300.0 )
              {
                v55 = rand();
                v56 = (int *)v12;
                v25 = v9;
                v26 = CEvent::operator new(0x14u);
                CEvent::CEvent((CEvent *)v26);
                *(_DWORD *)v26 = &off_667064;
                *((_DWORD *)v26 + 4) = (int)(float)((float)((float)v55 * 0.000015259) * 15000.0) + 10000;
                *((_DWORD *)v26 + 3) = v13;
                CEntity::RegisterReference(v13, (CEntity **)v26 + 3);
                v27 = (CEvent *)v26;
                v28 = v25;
                v9 = v25;
                v12 = (uint32 *)v56;
                CEventGroupEvent::CEventGroupEvent(v28, pPed, v27);
                CPedGroupIntelligence::AddEvent(&this->m_pPedGroup->m_intelligence, v9);
                this->m_scanTimer.m_iStartTime = *v56;
                this->m_scanTimer.m_iDuration = 60000;
                this->m_scanTimer.m_bIsActive = 1;
                CEventGroupEvent::~CEventGroupEvent(v9);
              }
            }
          }
        }
        ++v11;
      }
      while ( v11 != 16 );
    }
  }
}
// 5161DA: variable 'v2' is possibly undefined
// 5161DA: variable 'v3' is possibly undefined
// 516226: variable 'v52' is possibly undefined
// 667064: using guessed type void *off_667064;
// 669024: using guessed type void *off_669024;

//----- (00516330) --------------------------------------------------------
AnimationId __fastcall CTaskComplexGangLeader::GetDrinkAnim(CPed *pPed)
{
  int m_nModelIndex; // r1
  AnimationId result; // r0

  m_nModelIndex = pPed->m_nModelIndex;
  result = ANIM_GANG_DRINK_FAT;
  if ( m_nModelIndex != 103 && m_nModelIndex != 105 )
    return 299;
  return result;
}

//----- (00516348) --------------------------------------------------------
AnimationId __fastcall CTaskComplexGangLeader::GetSmokeAnim(CPed *pPed)
{
  int m_nModelIndex; // r1
  AnimationId result; // r0

  m_nModelIndex = pPed->m_nModelIndex;
  result = ANIM_GANG_SMOKE_FAT;
  if ( m_nModelIndex != 103 && m_nModelIndex != 105 )
    return 300;
  return result;
}

//----- (00516360) --------------------------------------------------------
void __fastcall CTaskComplexGangLeader::DoGangAbuseSpeech(CPed *pPed1, CPed *pPed2)
{
  int32 m_nPedType; // r0
  UInt16 v5; // r1

  if ( (unsigned int)(pPed1->m_nPedType - 7) <= 9 )
  {
    m_nPedType = pPed2->m_nPedType;
    if ( (unsigned int)(m_nPedType - 7) >= 0xA )
    {
      if ( !CPed::IsPlayer(pPed2) )
        return;
      m_nPedType = pPed2->m_nPedType;
    }
    if ( m_nPedType == 8 )
      goto LABEL_9;
    if ( m_nPedType == 7 )
    {
      v5 = 1;
LABEL_10:
      CPed::Say(pPed1, v5, 0, 1.0, 0, 0, 0);
      return;
    }
    if ( CPed::IsPlayer(pPed2) )
    {
LABEL_9:
      v5 = 4;
      goto LABEL_10;
    }
    switch ( pPed2->m_nPedType )
    {
      case 0xA:
        v5 = 7;
        goto LABEL_10;
      case 0xB:
        v5 = 8;
        goto LABEL_10;
      case 0xC:
        v5 = 6;
        goto LABEL_10;
      case 0xD:
        v5 = 5;
        goto LABEL_10;
      case 0xE:
        v5 = 3;
        goto LABEL_10;
      default:
        return;
    }
  }
}

//----- (005163F0) --------------------------------------------------------
void __fastcall CTaskComplexGangLeader::DoGangAttackSpeech(CPed *pPed1, CPed *pPed2)
{
  bool v3; // zf
  int32 m_nPedType; // r0
  UInt16 v6; // r1

  v3 = pPed1 == 0;
  if ( pPed1 )
    v3 = pPed2 == 0;
  if ( !v3 && (unsigned int)(pPed1->m_nPedType - 7) <= 9 )
  {
    m_nPedType = pPed2->m_nPedType;
    if ( (unsigned int)(m_nPedType - 7) >= 0xA )
    {
      if ( FindPlayerPed(0) != pPed2 )
        return;
      m_nPedType = pPed2->m_nPedType;
    }
    switch ( m_nPedType )
    {
      case 14:
        v6 = 19;
        break;
      case 9:
        v6 = 18;
        break;
      case 7:
        v6 = 17;
        break;
      default:
        return;
    }
    CPed::Say(pPed1, v6, 0, 1.0, 0, 0, 0);
  }
}

//----- (00516458) --------------------------------------------------------
int __fastcall CTaskComplexGangFollower::CTaskComplexGangFollower(
        int a1,
        int a2,
        CEntity *a3,
        char a4,
        unsigned int a5,
        int a6,
        unsigned int a7,
        int a8)
{
  CPlayerPed *v12; // r6
  char v13; // r1
  char v14; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  __int64 v17; // d16
  CPlayerPed *PlayerPed; // r0
  char v19; // r1
  bool v20; // zf
  int result; // r0
  char v22; // r2

  CTaskComplex::CTaskComplex((CTaskComplex *)a1);
  v12 = 0;
  *(_WORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 12) = a2;
  v13 = *(_BYTE *)(a1 + 61);
  *(_BYTE *)(a1 + 60) = a4;
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 32) = a5;
  *(_DWORD *)(a1 + 36) = a6;
  *(_QWORD *)(a1 + 40) = __PAIR64__(a5, a7);
  *(_DWORD *)(a1 + 48) = a6;
  *(_DWORD *)(a1 + 52) = a7;
  v14 = v13 | 0x14;
  *(_DWORD *)(a1 + 56) = a8;
  *(_BYTE *)(a1 + 61) = v13 | 0x14;
  *(_DWORD *)a1 = &off_66BDAC;
  *(_DWORD *)(a1 + 16) = a3;
  if ( a3 )
  {
    CEntity::RegisterReference(a3, (CEntity **)(a1 + 16));
    v12 = *(CPlayerPed **)(a1 + 16);
    m_pMat = v12->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &v12->m_transform;
    v14 = *(_BYTE *)(a1 + 61);
    v17 = *(_QWORD *)&p_tx->m_translate.x;
    *(RwReal *)(a1 + 28) = p_tx->m_translate.z;
    *(_QWORD *)(a1 + 20) = v17;
  }
  *(_BYTE *)(a1 + 61) = v14 & 0xFC;
  PlayerPed = FindPlayerPed(0);
  v19 = *(_BYTE *)(a1 + 61);
  v20 = v12 == PlayerPed;
  result = a1;
  v22 = v19 & 0xF7;
  if ( v20 )
    v22 = v19 | 8;
  *(_BYTE *)(a1 + 61) = v22;
  return result;
}
// 66BDAC: using guessed type void *;

//----- (00516510) --------------------------------------------------------
void __fastcall CTaskComplexGangFollower::~CTaskComplexGangFollower(CTaskComplexGangFollower *this)
{
  CPed *m_pLeader; // r0
  CEntity **p_m_pLeader; // r1
  int32 AnimationBlockIndex; // r0

  p_m_pLeader = &this->m_pLeader;
  m_pLeader = this->m_pLeader;
  this->_vptr$CTask = (int (**)(void))&off_66BDAC;
  if ( m_pLeader )
    CEntity::CleanUpOldReference(m_pLeader, p_m_pLeader);
  if ( *((unsigned __int8 *)this + 61) << 31 )
  {
    AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("gangs");
    CAnimManager::RemoveAnimBlockRef(AnimationBlockIndex);
    *((_BYTE *)this + 61) &= ~1u;
  }
  sub_18EDB4(this);
}
// 66BDAC: using guessed type void *off_66BDAC;

//----- (00516560) --------------------------------------------------------
void __fastcall CTaskComplexGangFollower::~CTaskComplexGangFollower(CTaskComplexGangFollower *this)
{
  CPed *m_pLeader; // r0
  CEntity **p_m_pLeader; // r1
  int32 AnimationBlockIndex; // r0
  void *v5; // r0

  p_m_pLeader = &this->m_pLeader;
  m_pLeader = this->m_pLeader;
  this->_vptr$CTask = (int (**)(void))&off_66BDAC;
  if ( m_pLeader )
    CEntity::CleanUpOldReference(m_pLeader, p_m_pLeader);
  if ( *((unsigned __int8 *)this + 61) << 31 )
  {
    AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("gangs");
    CAnimManager::RemoveAnimBlockRef(AnimationBlockIndex);
    *((_BYTE *)this + 61) &= ~1u;
  }
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v5);
}
// 5165A8: variable 'v5' is possibly undefined
// 66BDAC: using guessed type void *off_66BDAC;

//----- (005165B4) --------------------------------------------------------
bool __fastcall CTaskComplexGangFollower::MakeAbortable(
        CTaskComplexGangFollower *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CTask *m_pSubTask; // r0
  bool result; // r0
  int v7; // r1

  m_pSubTask = this->m_pSubTask;
  if ( m_pSubTask
    && (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))m_pSubTask->_vptr$CTask + 7))(
         m_pSubTask,
         pPed,
         iPriority,
         pEvent) != 1 )
  {
    return 0;
  }
  v7 = *((_DWORD *)&pPed->m_nPedFlags + 3);
  *((_DWORD *)&pPed->m_nPedFlags + 2) &= ~0x400000u;
  result = 1;
  *((_DWORD *)&pPed->m_nPedFlags + 3) = v7 & 0xFFFEFFFF;
  return result;
}

//----- (005165EC) --------------------------------------------------------
CTask *__fastcall CTaskComplexGangFollower::Clone(const CTaskComplexGangFollower *this)
{
  char *v2; // r5
  RwReal x; // r6
  RwReal y; // r11
  RwReal z; // r9
  __int64 v6; // kr08_8
  CPlayerPed *v7; // r6
  char v8; // r1
  char v9; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  __int64 v12; // d16
  CPlayerPed *PlayerPed; // r0
  char v14; // r1
  char v15; // r2
  float m_targetRadius; // [sp+4h] [bp-24h]
  uint8 m_groupMembershipIndex; // [sp+8h] [bp-20h]

  v2 = (char *)CTask::operator new(0x4Cu);
  m_groupMembershipIndex = this->m_groupMembershipIndex;
  m_targetRadius = this->m_targetRadius;
  y = this->m_offsetPos.y;
  x = this->m_offsetPos.x;
  z = this->m_offsetPos.z;
  v6 = *(_QWORD *)&this->m_pPedGroup;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_DWORD *)v2 + 3) = v6;
  *(_QWORD *)(v2 + 44) = __PAIR64__(LODWORD(y), LODWORD(x));
  *((_QWORD *)v2 + 4) = __PAIR64__(LODWORD(y), LODWORD(x));
  v7 = 0;
  *((RwReal *)v2 + 13) = z;
  *((RwReal *)v2 + 10) = z;
  *((_WORD *)v2 + 36) = 0;
  *((float *)v2 + 14) = m_targetRadius;
  v2[60] = m_groupMembershipIndex;
  *((_DWORD *)v2 + 16) = 0;
  *((_DWORD *)v2 + 17) = 0;
  v8 = v2[61];
  *(_DWORD *)v2 = &off_66BDAC;
  v9 = v8 | 0x14;
  v2[61] = v8 | 0x14;
  *((_DWORD *)v2 + 4) = HIDWORD(v6);
  if ( HIDWORD(v6) )
  {
    CEntity::RegisterReference((CEntity *)HIDWORD(v6), (CEntity **)v2 + 4);
    v7 = (CPlayerPed *)*((_DWORD *)v2 + 4);
    m_pMat = v7->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &v7->m_transform;
    v9 = v2[61];
    v12 = *(_QWORD *)&p_tx->m_translate.x;
    *((_DWORD *)v2 + 7) = LODWORD(p_tx->m_translate.z);
    *(_QWORD *)(v2 + 20) = v12;
  }
  v2[61] = v9 & 0xFC;
  PlayerPed = FindPlayerPed(0);
  v14 = v2[61];
  v15 = v14 & 0xF7;
  if ( v7 == PlayerPed )
    v15 = v14 | 8;
  v2[61] = v15;
  v2[61] = *((_BYTE *)this + 61) & 4 | v15 & 0xFB;
  return (CTask *)v2;
}
// 66BDAC: using guessed type void *off_66BDAC;

//----- (005166D0) --------------------------------------------------------
CTask *__fastcall CTaskComplexGangFollower::CreateNextSubTask(CTaskComplexGangFollower *this, CPed *pPed)
{
  int m_iStaticCounter; // r6
  CPedIntelligence *m_pPedIntelligence; // r6
  CTaskComplexWanderGang *v6; // r5
  unsigned __int16 v7; // r0
  CTaskManager *p_m_taskManager; // r0
  char *v9; // r6
  int m_nPedFlags; // r0
  CPed *m_pLeader; // r0
  int v12; // r2
  int v13; // r3
  int v14; // r1
  int v16; // r6
  unsigned __int16 v17; // r0
  CPed *Member; // r8
  CPed *v19; // r4
  CPed *v20; // r8
  char v21; // r3
  char v22; // r0
  __int64 v23; // d16

  if ( !this->m_pLeader )
  {
    m_nPedFlags = (int)pPed->m_nPedFlags;
    v9 = 0;
    goto LABEL_9;
  }
  m_iStaticCounter = pPed->m_pPedIntelligence->m_iStaticCounter;
  if ( (*((_BYTE *)this + 61) & 2) != 0
    && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 1210 )
  {
    CPedGroupMembership::RemoveMember(&this->m_pPedGroup->m_membership, pPed);
    m_pPedIntelligence = pPed->m_pPedIntelligence;
    v6 = (CTaskComplexWanderGang *)CTask::operator new(0x38u);
    v7 = rand();
    CTaskComplexWanderGang::CTaskComplexWanderGang(
      v6,
      4,
      (int)(float)((float)((float)v7 * 0.000015259) * 8.0),
      30000,
      1,
      0.5);
    p_m_taskManager = &m_pPedIntelligence->m_taskManager;
    v9 = 0;
    CTaskManager::SetTask(p_m_taskManager, v6, 4, 0);
    m_nPedFlags = (int)pPed->m_nPedFlags;
LABEL_9:
    v12 = *((_DWORD *)&pPed->m_nPedFlags + 2);
    v13 = *((_DWORD *)&pPed->m_nPedFlags + 3);
    v14 = *((_DWORD *)&pPed->m_nPedFlags + 1);
    *(_DWORD *)&pPed->m_nPedFlags = m_nPedFlags;
    *((_DWORD *)&pPed->m_nPedFlags + 1) = v14;
    *((_DWORD *)&pPed->m_nPedFlags + 2) = v12;
    *((_DWORD *)&pPed->m_nPedFlags + 3) = v13 & 0xFFFEFFFF;
    return (CTask *)v9;
  }
  if ( m_iStaticCounter > 30 )
  {
    m_pLeader = this->m_pLeader;
    if ( !m_pLeader )
      goto LABEL_15;
    goto LABEL_13;
  }
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 907 )
  {
    m_pLeader = this->m_pLeader;
    if ( m_pLeader->m_eMoveState < PEDMOVE_WALK )
    {
      if ( !m_pLeader )
      {
LABEL_15:
        v9 = (char *)CTask::operator new(0x20u);
        CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v9, 500, 0, 0, 8.0);
        return (CTask *)v9;
      }
LABEL_13:
      if ( CPed::IsPlayer(m_pLeader) )
        CPed::Say(pPed, 0x5Au, 0, 0.3, 0, 0, 0);
      goto LABEL_15;
    }
  }
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 203
    || (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 426 )
  {
    if ( (*((_BYTE *)this + 61) & 2) != 0 )
    {
      v9 = (char *)CTask::operator new(0x18u);
      v19 = this->m_pLeader;
      CTaskComplex::CTaskComplex((CTaskComplex *)v9);
      *((_DWORD *)v9 + 4) = 0;
      *((_WORD *)v9 + 10) = 0;
      *(_DWORD *)v9 = &off_66BF40;
      *((_DWORD *)v9 + 3) = v19;
      if ( v19 )
        CEntity::RegisterReference(v19, (CEntity **)v9 + 3);
    }
    else
    {
      if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 30.0) != 20 )
        goto LABEL_27;
      v16 = CPedGroupMembership::CountMembers(&this->m_pPedGroup->m_membership);
      v17 = rand();
      Member = CPedGroupMembership::GetMember(
                 &this->m_pPedGroup->m_membership,
                 (int)(float)((float)((float)v17 * 0.000015259) * (float)v16));
      if ( Member == pPed )
        Member = CPedGroupMembership::GetLeader(&this->m_pPedGroup->m_membership);
      if ( Member )
      {
        v9 = (char *)CTask::operator new(0x28u);
        CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(
          (CTaskComplexTurnToFaceEntityOrCoord *)v9,
          Member,
          0.5,
          0.2);
      }
      else
      {
LABEL_27:
        v9 = (char *)CTask::operator new(0x18u);
        CTaskSimple::CTaskSimple((CTaskSimple *)v9);
        *((_WORD *)v9 + 8) = 0;
        *((_DWORD *)v9 + 5) = 50;
        *((_DWORD *)v9 + 2) = 0;
        *((_DWORD *)v9 + 3) = 0;
        *(_DWORD *)v9 = &off_665750;
      }
    }
    return (CTask *)v9;
  }
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 709 )
  {
    if ( (*((_BYTE *)this + 61) & 4) != 0 )
    {
      v9 = (char *)CTask::operator new(0x58u);
      v20 = this->m_pLeader;
      CTaskComplex::CTaskComplex((CTaskComplex *)v9);
      *((_QWORD *)v9 + 3) = 0x40A000003F000000LL;
      *((_QWORD *)v9 + 4) = 0x4000000000000000LL;
      *((_QWORD *)v9 + 2) = 0x3E80000C350LL;
      *((_WORD *)v9 + 24) = 0;
      *((_WORD *)v9 + 30) = 0;
      *((_DWORD *)v9 + 10) = 0;
      *((_DWORD *)v9 + 11) = 0;
      *((_DWORD *)v9 + 13) = 0;
      *((_DWORD *)v9 + 14) = 0;
      *((_DWORD *)v9 + 18) = 0;
      *((_DWORD *)v9 + 19) = 0;
      *((_DWORD *)v9 + 20) = 6;
      v21 = v9[84];
      *(_DWORD *)v9 = &off_668968;
      *((_DWORD *)v9 + 16) = &off_66D3CC;
      v22 = v21 & 0xF0;
      v9[84] = v21 & 0xF0;
      *((_DWORD *)v9 + 17) = 0;
      *((_DWORD *)v9 + 3) = v20;
      if ( v20 )
      {
        CEntity::RegisterReference(v20, (CEntity **)v9 + 3);
        v22 = v9[84];
      }
      v23 = *(_QWORD *)&this->m_offsetPos.x;
      *((_DWORD *)v9 + 19) = LODWORD(this->m_offsetPos.z);
      *(_QWORD *)(v9 + 68) = v23;
      *((_DWORD *)v9 + 20) = 7;
      v9[84] = v22 | 8;
      return (CTask *)v9;
    }
    goto LABEL_15;
  }
  return (CTask *)(*((int (__fastcall **)(CTaskComplexGangFollower *, CPed *))this->_vptr$CTask + 11))(this, pPed);
}
// 665750: using guessed type void *off_665750;
// 668968: using guessed type void *off_668968;
// 66BF40: using guessed type void *off_66BF40;
// 66D3CC: using guessed type void *off_66D3CC;
// 678E00: using guessed type void *`vtable for'CTaskSimplePause;

//----- (00516A60) --------------------------------------------------------
CTask *__fastcall CTaskComplexGangFollower::CreateFirstSubTask(CTaskComplexGangFollower *this, CPed *pPed)
{
  CPed *m_pLeader; // r0
  int m_nPedFlags; // r1
  CVehicle *m_pMyVehicle; // r1
  char *v7; // r4
  CPed *v8; // r8
  char v9; // r0
  char v10; // r0
  __int64 v11; // d16
  int *v12; // r3
  CPedFlags *p_m_nPedFlags; // r6
  int v14; // r0
  __int64 v15; // r2

  m_pLeader = this->m_pLeader;
  m_nPedFlags = (int)pPed->m_nPedFlags;
  if ( m_pLeader )
  {
    if ( (m_nPedFlags & 0x100) == 0 )
      goto LABEL_8;
    m_pMyVehicle = pPed->m_pMyVehicle;
    if ( m_pMyVehicle && m_pLeader->m_pMyVehicle == m_pMyVehicle )
    {
      v7 = (char *)CTask::operator new(0x60u);
      CTaskSimpleCarDrive::CTaskSimpleCarDrive((CTaskSimpleCarDrive *)v7, pPed->m_pMyVehicle, 0, 0);
      return (CTask *)v7;
    }
    if ( pPed->m_pMyVehicle )
    {
      v7 = (char *)CTask::operator new(0x34u);
      CTaskComplexLeaveCar::CTaskComplexLeaveCar((CTaskComplexLeaveCar *)v7, pPed->m_pMyVehicle, 0, 0, 1, 0);
    }
    else
    {
LABEL_8:
      if ( (*((_BYTE *)this + 61) & 4) != 0 && pPed->m_pPedIntelligence->m_iStaticCounter <= 30 )
      {
        v7 = (char *)CTask::operator new(0x58u);
        v8 = this->m_pLeader;
        CTaskComplex::CTaskComplex((CTaskComplex *)v7);
        *((_QWORD *)v7 + 3) = 0x40A000003F000000LL;
        *((_QWORD *)v7 + 4) = 0x4000000000000000LL;
        *((_DWORD *)v7 + 4) = 50000;
        *((_DWORD *)v7 + 5) = 1000;
        *((_WORD *)v7 + 24) = 0;
        *((_WORD *)v7 + 30) = 0;
        *((_DWORD *)v7 + 10) = 0;
        *((_DWORD *)v7 + 11) = 0;
        *((_DWORD *)v7 + 13) = 0;
        *((_DWORD *)v7 + 14) = 0;
        *((_DWORD *)v7 + 18) = 0;
        *((_DWORD *)v7 + 19) = 0;
        *((_DWORD *)v7 + 20) = 6;
        v9 = v7[84];
        *(_DWORD *)v7 = &off_668968;
        *((_DWORD *)v7 + 16) = &off_66D3CC;
        v10 = v9 & 0xF0 | 2;
        v7[84] = v10;
        *((_DWORD *)v7 + 17) = 0;
        *((_DWORD *)v7 + 3) = v8;
        if ( v8 )
        {
          CEntity::RegisterReference(v8, (CEntity **)v7 + 3);
          v10 = v7[84];
        }
        v11 = *(_QWORD *)&this->m_offsetPos.x;
        *((_DWORD *)v7 + 19) = LODWORD(this->m_offsetPos.z);
        *(_QWORD *)(v7 + 68) = v11;
        *((_DWORD *)v7 + 20) = 7;
        v7[84] = v10 | 8;
      }
      else
      {
        v7 = (char *)CTask::operator new(0x20u);
        CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v7, 500, 0, 0, 8.0);
      }
    }
  }
  else
  {
    v12 = (int *)&pPed->m_nPedFlags + 1;
    p_m_nPedFlags = &pPed->m_nPedFlags;
    v7 = 0;
    v14 = *v12;
    LODWORD(v15) = v12[1];
    HIDWORD(v15) = v12[2] & 0xFFFEFFFF;
    *(_DWORD *)p_m_nPedFlags = m_nPedFlags;
    *((_DWORD *)p_m_nPedFlags + 1) = v14;
    *((_QWORD *)p_m_nPedFlags + 1) = v15;
  }
  return (CTask *)v7;
}
// 668968: using guessed type void *off_668968;
// 66D3CC: using guessed type void *off_66D3CC;

//----- (00516BEC) --------------------------------------------------------
void __fastcall CTaskComplexGangFollower::CalculateOffsetPosition(CTaskComplexGangFollower *this, CVector *outVec)
{
  CPed *m_pLeader; // r1
  unsigned int v5; // r0
  unsigned int v6; // r2
  CMatrix *m_pMat; // r3
  CSimpleTransform *p_tx; // r0
  const CMatrix *v9; // r1
  char v10; // r0
  float32x2_t v11; // d16
  char v12; // r1
  unsigned __int64 v13; // d1
  __int64 v14; // d16
  int m_groupMembershipIndex; // r0
  float x; // r3
  float y; // r0
  __int64 v18; // d16
  CVector v; // [sp+4h] [bp-14h] BYREF

  m_pLeader = this->m_pLeader;
  v5 = m_pLeader->m_eMoveState - 4;
  if ( v5 > 3 )
    v6 = 0;
  else
    v6 = (0xDu >> (v5 & 0xF)) & 1;
  m_pMat = m_pLeader->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &m_pLeader->m_transform;
  if ( v6 )
  {
    v9 = m_pLeader->m_pMat;
    *(CVector2D *)&v.x = CTaskComplexFollowLeaderInFormation::ms_offsets.m_movingOffsets[this->m_groupMembershipIndex];
    v.z = 0.0;
    CVector::FromMultiply3X3(&this->m_offsetPos, v9, &v);
    v10 = *((_BYTE *)this + 61) & 0xEF;
LABEL_11:
    *((_BYTE *)this + 61) = v10;
    goto LABEL_12;
  }
  v11.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.y, *(float32x2_t *)&this->m_leaderInitialPos.y).n64_u64[0];
  v12 = *((_BYTE *)this + 61);
  v13 = vmul_f32(v11, v11).n64_u64[0];
  if ( (float)((float)((float)((float)(p_tx->m_translate.x - this->m_leaderInitialPos.x)
                             * (float)(p_tx->m_translate.x - this->m_leaderInitialPos.x))
                     + *(float *)&v13)
             + *((float *)&v13 + 1)) > 9.0
    || (*((_BYTE *)this + 61) & 0x10) == 0 )
  {
    v14 = *(_QWORD *)&p_tx->m_translate.x;
    this->m_leaderInitialPos.z = p_tx->m_translate.z;
    *(_QWORD *)&this->m_leaderInitialPos.x = v14;
    m_groupMembershipIndex = this->m_groupMembershipIndex;
    x = CTaskComplexFollowLeaderInFormation::ms_offsets.m_offsets[m_groupMembershipIndex].x;
    y = CTaskComplexFollowLeaderInFormation::ms_offsets.m_offsets[m_groupMembershipIndex].y;
    this->m_offsetPos.x = x;
    this->m_offsetPos.y = y;
    v10 = v12 | 0x10;
    this->m_offsetPos.z = 0.0;
    goto LABEL_11;
  }
LABEL_12:
  v18 = *(_QWORD *)&this->m_offsetPos.x;
  outVec->z = this->m_offsetPos.z;
  *(_QWORD *)&outVec->x = v18;
}

//----- (00516CE0) --------------------------------------------------------
CTask *__fastcall CTaskComplexGangFollower::ControlSubTask(CTaskComplexGangFollower *this, CPed *pPed)
{
  CPedFlags *p_m_nPedFlags; // r8
  CPed *m_pLeader; // r1
  CTask *m_pSubTask; // r0
  CAnimBlendAssociation *Association; // r9
  unsigned int MoveStateFromGoToTask; // r5
  CPed *v9; // r1
  CSimpleTransform *p_m_transform; // r10
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r6
  CMatrix *v13; // r3
  float *p_x; // r2
  float x; // s18
  float y; // s16
  float v17; // s20
  float v18; // s22
  int v19; // r9
  _BYTE *v20; // r10
  int v21; // r9
  void *v22; // r4
  int v23; // r2
  int v24; // r1
  unsigned int v25; // r3
  int v26; // r3
  int v27; // r1
  int v28; // r0
  int v29; // r6
  CPlayerPed *v30; // r1
  float *m_pMyVehicle; // r0
  bool v32; // zf
  _BOOL4 v33; // r0
  int32 v34; // r0
  char v35; // r0
  int32 AnimationBlockIndex; // r0
  float v37; // s16
  float v38; // s18
  CTask *v39; // r0
  RwReal v40; // r1
  RwReal v41; // r2
  RwReal z; // r3
  CTask *ActiveTaskByType; // r6
  CTask *v44; // r0
  CPed *v45; // r0
  CMatrix *v46; // r1
  float *v47; // r2
  float v48; // s24
  float v49; // s22
  CMatrix *v50; // r1
  float v51; // s26
  CMatrix *v52; // r0
  float v53; // s8
  float yy; // s2
  float32x2_t v55; // d0
  float32x2_t v56; // d2
  float m_fSpeed; // s28
  float v58; // s0
  float v59; // s0
  CPedGroup *m_pPedGroup; // r0
  unsigned int v61; // r0
  int m_iStartTime; // r1
  RwObject_0 *m_pRwObject; // r0
  char *parent; // r0
  FxSystem_c *v65; // r0
  FxSystem_c *v66; // r6
  unsigned __int16 v67; // r6
  unsigned __int16 v68; // r0
  CPed *Member; // r3
  CEntity *EntityThatThisPedIsHolding; // r0
  CAnimBlendAssociation *v71; // r6
  CAnimBlendAssociation *v72; // r4
  unsigned int v73; // r6
  CAnimBlendAssociation *v74; // r10
  int v75; // r9
  CPed *ClosestGroupPed; // r8
  int m_nModelIndex; // r0
  UInt16 v79; // r1
  int v80; // r0
  CPedIntelligence *v81; // r4
  CTaskSimpleRunAnim *v82; // r6
  unsigned __int16 v83; // r0
  char m_pParent; // r0
  CTaskSimpleHoldEntity *v85; // r6
  AnimationId RandomGangAmbientAnim; // r0
  bool v87; // zf
  CPedIntelligence *m_pPedIntelligence; // r4
  CTaskComplexPlayHandSignalAnim *v89; // r6
  UInt16 v90; // r1
  UInt16 v92; // r1
  CAnimBlendAssociation *v93; // [sp+24h] [bp-7Ch]
  int m_iStaticCounter; // [sp+28h] [bp-78h]
  CEntity *objectBeingHeld; // [sp+2Ch] [bp-74h]
  CPed *v96; // [sp+30h] [bp-70h]
  RwV3d_0 offsetPos; // [sp+34h] [bp-6Ch] BYREF
  CEntity *v98; // [sp+40h] [bp-60h] BYREF
  char v99; // [sp+44h] [bp-5Ch]

  p_m_nPedFlags = &pPed->m_nPedFlags;
  *((_DWORD *)&pPed->m_nPedFlags + 2) &= ~0x400000u;
  m_pLeader = this->m_pLeader;
  m_pSubTask = this->m_pSubTask;
  if ( !m_pLeader )
  {
    if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))m_pSubTask->_vptr$CTask + 7))(m_pSubTask, pPed, 1, 0) == 1 )
    {
      v22 = 0;
      v23 = *((_DWORD *)p_m_nPedFlags + 2);
      v24 = *((_DWORD *)p_m_nPedFlags + 1);
      v25 = *((_DWORD *)p_m_nPedFlags + 3) & 0xFFFEFFFF;
      *(_DWORD *)p_m_nPedFlags = *(_DWORD *)p_m_nPedFlags;
      *((_DWORD *)p_m_nPedFlags + 1) = v24;
      *((_DWORD *)p_m_nPedFlags + 2) = v23;
      *((_DWORD *)p_m_nPedFlags + 3) = v25;
      return (CTask *)v22;
    }
    return this->m_pSubTask;
  }
  if ( (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) == 709 )
    return this->m_pSubTask;
  Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0);
  MoveStateFromGoToTask = CPedIntelligence::GetMoveStateFromGoToTask(this->m_pLeader->m_pPedIntelligence);
  CTaskComplexGangFollower::CalculateOffsetPosition(this, &this->m_offsetPos);
  v9 = this->m_pLeader;
  p_m_transform = &pPed->m_transform;
  m_pMat = pPed->m_pMat;
  p_tx = &pPed->m_transform;
  v13 = v9->m_pMat;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  p_x = &v13->tx;
  x = p_tx->m_translate.x;
  y = p_tx->m_translate.y;
  if ( !v13 )
    p_x = &v9->m_transform.m_translate.x;
  v17 = *p_x;
  v18 = p_x[1];
  v96 = pPed;
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 907 )
  {
    if ( (*((_BYTE *)this + 61) & 4) == 0 )
    {
      v19 = 0;
      goto LABEL_10;
    }
    v37 = v18 - y;
    v93 = Association;
    v38 = v17 - x;
    m_iStaticCounter = pPed->m_pPedIntelligence->m_iStaticCounter;
    v39 = this->m_pSubTask;
    v40 = this->m_offsetPos.x;
    v41 = this->m_offsetPos.y;
    z = this->m_offsetPos.z;
    v39[4]._vptr$CTask = (int (**)(void))0x40000000;
    v39 = (CTask *)((char *)v39 + 68);
    *(RwReal *)&v39->_vptr$CTask = v40;
    *(RwReal *)&v39->m_pParent = v41;
    *(RwReal *)&v39[1]._vptr$CTask = z;
    ActiveTaskByType = CTaskManager::FindActiveTaskByType(&pPed->m_pPedIntelligence->m_taskManager, 900);
    v44 = CTaskManager::FindActiveTaskByType(&pPed->m_pPedIntelligence->m_taskManager, 906);
    v19 = 0;
    if ( !ActiveTaskByType || v44 )
    {
LABEL_107:
      if ( (float)((float)((float)(v38 * v38) + (float)(v37 * v37)) + 0.0) < 64.0 )
      {
        v20 = (char *)this + 61;
        if ( m_iStaticCounter >= 9
          && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
               this->m_pSubTask,
               pPed,
               1,
               0) )
        {
          this->m_offsetPos.x = v38;
          this->m_offsetPos.y = v37;
          this->m_offsetPos.z = 0.0;
          v22 = CTask::operator new(0x20u);
          CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v22, 500, 0, 0, 8.0);
          return (CTask *)v22;
        }
        goto LABEL_11;
      }
LABEL_10:
      v20 = (char *)this + 61;
LABEL_11:
      v21 = v19 != 0;
      goto LABEL_15;
    }
    v45 = this->m_pLeader;
    v19 = 0;
    v46 = v45->m_pMat;
    v47 = &v46->tx;
    if ( !v46 )
      v47 = &v45->m_transform.m_translate.x;
    v48 = *v47 + this->m_offsetPos.x;
    v49 = v47[1] + this->m_offsetPos.y;
    v50 = pPed->m_pMat;
    v51 = v47[2] + this->m_offsetPos.z;
    if ( v50 )
      p_m_transform = (CSimpleTransform *)&v50->tx;
    if ( MoveStateFromGoToTask > 7 || ((1 << MoveStateFromGoToTask) & 0xD0) == 0 )
    {
LABEL_103:
      if ( *(float *)&ActiveTaskByType[1].m_pParent != v48
        || *(float *)&ActiveTaskByType[2]._vptr$CTask != v49
        || *(float *)&ActiveTaskByType[3]._vptr$CTask != 0.5 )
      {
        m_pParent = (char)ActiveTaskByType[3].m_pParent;
        *(float *)&ActiveTaskByType[1].m_pParent = v48;
        *(float *)&ActiveTaskByType[2]._vptr$CTask = v49;
        *(float *)&ActiveTaskByType[2].m_pParent = v51;
        ActiveTaskByType[3]._vptr$CTask = (int (**)(void))1056964608;
        LOBYTE(ActiveTaskByType[3].m_pParent) = m_pParent & 0xD0 | 0x20;
      }
      goto LABEL_107;
    }
    v52 = v45->m_pMat;
    v53 = p_m_transform->m_translate.y;
    v55.n64_u32[0] = LODWORD(v52->xy);
    yy = v52->yy;
    v56.n64_u32[0] = LODWORD(v52->zy);
    v55.n64_f32[1] = p_m_transform->m_translate.x * v55.n64_f32[0];
    v56.n64_f32[1] = v51 * v56.n64_f32[0];
    if ( (float)((float)((float)(v55.n64_f32[1] + (float)(v53 * yy))
                       + (float)(p_m_transform->m_translate.z * v56.n64_f32[0]))
               - (float)((float)((float)(v48 * v55.n64_f32[0]) + (float)(v49 * yy)) + (float)(v51 * v56.n64_f32[0]))) < 0.0 )
    {
      if ( (float)((float)((float)((float)(v48 - p_m_transform->m_translate.x)
                                 * (float)(v48 - p_m_transform->m_translate.x))
                         + (float)((float)(v49 - v53) * (float)(v49 - v53)))
                 + 0.0) <= (float)((float)(*(float *)&ActiveTaskByType[3]._vptr$CTask + 1.0)
                                 * (float)(*(float *)&ActiveTaskByType[3]._vptr$CTask + 1.0)) )
      {
        v51 = v51 + (float)(v56.n64_f32[0] + v56.n64_f32[0]);
        v49 = v49 + (float)(yy + yy);
        v48 = v48 + (float)(v55.n64_f32[0] + v55.n64_f32[0]);
        if ( v93 )
        {
          v56.n64_u32[0] = 1062836634;
          v55.n64_f32[0] = v93->m_fSpeed + -0.0125;
          LODWORD(v93->m_fSpeed) = vmax_f32(v55, v56).n64_u32[0];
LABEL_101:
          v19 = 1;
          goto LABEL_103;
        }
      }
      else if ( v93 )
      {
        m_fSpeed = v93->m_fSpeed;
        CPed::SetMoveAnimSpeed(pPed, v93);
        v58 = v93->m_fSpeed;
        if ( fabsf(m_fSpeed - v58) >= 0.013 )
        {
          if ( m_fSpeed > v58 )
            v59 = -0.0125;
          else
            v59 = 0.0125;
          m_fSpeed = m_fSpeed + v59;
        }
        v93->m_fSpeed = m_fSpeed;
        goto LABEL_101;
      }
    }
    v19 = 0;
    goto LABEL_103;
  }
  v20 = (char *)this + 61;
  v21 = 0;
LABEL_15:
  v26 = *((_DWORD *)p_m_nPedFlags + 3);
  v27 = *((_DWORD *)p_m_nPedFlags + 1);
  v28 = *(_DWORD *)p_m_nPedFlags;
  *((_DWORD *)p_m_nPedFlags + 2) = *((_DWORD *)p_m_nPedFlags + 2);
  *((_DWORD *)p_m_nPedFlags + 1) = v27;
  *(_DWORD *)p_m_nPedFlags = v28;
  *((_DWORD *)p_m_nPedFlags + 3) = v26 & 0xFFFEFFFF | (v21 << 16);
  v29 = *v20 & 1;
  v30 = CWorld::Players[CWorld::PlayerInFocus].pPed;
  m_pMyVehicle = (float *)v30->m_pMyVehicle;
  v32 = m_pMyVehicle == 0;
  if ( m_pMyVehicle )
    v32 = (*(_DWORD *)&v30->m_nPedFlags & 0x100) == 0;
  v33 = (v32
      || (float)((float)((float)(m_pMyVehicle[18] * m_pMyVehicle[18]) + (float)(m_pMyVehicle[19] * m_pMyVehicle[19]))
               + (float)(m_pMyVehicle[20] * m_pMyVehicle[20])) <= 0.04)
     && !CStreaming::IsVeryBusy();
  if ( v29 )
  {
    if ( v33 )
      goto LABEL_46;
    AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("gangs");
    CAnimManager::RemoveAnimBlockRef(AnimationBlockIndex);
    v35 = *v20 & 0xFE;
    goto LABEL_27;
  }
  if ( !v33 )
    goto LABEL_46;
  v34 = CAnimManager::GetAnimationBlockIndex("gangs");
  if ( CAnimManager::ms_aAnimBlocks[v34].m_loaded )
  {
    CAnimManager::AddAnimBlockRef(v34);
    v35 = *v20 | 1;
LABEL_27:
    *v20 = v35;
    goto LABEL_46;
  }
  CStreaming::RequestModel(v34 + 25575, 8);
LABEL_46:
  m_pPedGroup = this->m_pPedGroup;
  if ( !m_pPedGroup->m_iGroupCreatedBy
    && (*v20 & 8) == 0
    && CPedGroupMembership::CountMembers(&m_pPedGroup->m_membership) >= 4
    && (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 2000.0) == 500 )
  {
    *v20 |= 2u;
  }
  if ( this->m_exhaleTimer.m_bIsActive )
  {
    if ( this->m_exhaleTimer.m_bIsStopped )
    {
      v61 = CTimer::m_snTimeInMilliseconds;
      this->m_exhaleTimer.m_bIsStopped = 0;
      this->m_exhaleTimer.m_iStartTime = v61;
      m_iStartTime = v61;
    }
    else
    {
      m_iStartTime = this->m_exhaleTimer.m_iStartTime;
      v61 = CTimer::m_snTimeInMilliseconds;
    }
    if ( m_iStartTime + this->m_exhaleTimer.m_iDuration <= v61 )
    {
      m_pRwObject = pPed->m_pRwObject;
      if ( m_pRwObject )
      {
        parent = (char *)m_pRwObject->parent;
        offsetPos.y = 0.1;
        offsetPos.x = 0.0;
        offsetPos.z = 0.0;
        v65 = FxManager_c::CreateFxSystem(&g_fxMan, "exhale", &offsetPos, (RwMatrix *)(parent + 16), 0);
        v66 = v65;
        if ( v65 )
        {
          FxSystem_c::AttachToBone(v65, pPed, 5);
          FxSystem_c::PlayAndKill(v66);
        }
        this->m_exhaleTimer.m_bIsActive = 0;
      }
    }
  }
  if ( !CEntity::IsVisible(pPed) )
    return this->m_pSubTask;
  if ( !IKChainManager_c::IsLooking(&g_ikChainMan, pPed)
    && (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) >= 96 )
  {
    v67 = rand();
    v68 = rand();
    Member = CPedGroupMembership::GetMember(
               &this->m_pPedGroup->m_membership,
               (int)(float)(int)(float)((float)((float)v68 * 0.000015259) * 8.0));
    if ( Member == pPed )
      Member = this->m_pLeader;
    if ( Member )
      IKChainManager_c::LookAt(
        &g_ikChainMan,
        "TaskGangFollower",
        pPed,
        Member,
        (int)(float)((int)(float)((float)((float)v67 * 0.000015259) * 2000.0) + 3000),
        5,
        0,
        1,
        0.15,
        500,
        3,
        0);
  }
  if ( !((unsigned __int8)*v20 << 31) || pPed->m_eMoveState > PEDMOVE_JOG )
    return this->m_pSubTask;
  EntityThatThisPedIsHolding = CPed::GetEntityThatThisPedIsHolding(pPed);
  if ( !EntityThatThisPedIsHolding )
  {
    if ( !CPed::IsPlayingHandSignal(pPed)
      && !CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 4) )
    {
      v80 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 500.0);
      if ( (unsigned int)(v80 - 51) > 4 )
      {
        v87 = v80 == 100;
        if ( v80 == 100 )
          v87 = pPed->m_eMoveState == PEDMOVE_STILL;
        if ( v87 )
        {
          m_pPedIntelligence = pPed->m_pPedIntelligence;
          v89 = (CTaskComplexPlayHandSignalAnim *)CTask::operator new(0x18u);
          CTaskComplexPlayHandSignalAnim::CTaskComplexPlayHandSignalAnim(v89, (const AnimationId)-1, 4.0);
          CTaskManager::SetTaskSecondary(&m_pPedIntelligence->m_taskManager, v89, 4);
          switch ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 10.0) )
          {
            case 0:
            case 1:
            case 2:
LABEL_120:
              v90 = 45;
              goto LABEL_123;
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
LABEL_119:
              v90 = 166;
              goto LABEL_123;
            case 8:
LABEL_121:
              v90 = 24;
              goto LABEL_123;
            case 9:
LABEL_122:
              v90 = 201;
LABEL_123:
              CPed::Say(v96, v90, 0, 1.0, 0, 0, 0);
              break;
            default:
              return this->m_pSubTask;
          }
        }
      }
      else
      {
        v81 = pPed->m_pPedIntelligence;
        v82 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
        v83 = rand();
        CTaskSimpleRunAnim::CTaskSimpleRunAnim(
          v82,
          ANIM_GANG_PED,
          (const AnimationId)((int)(float)((float)((float)v83 * 0.000015259) * 8.0) + 279),
          4.0,
          0);
        CTaskManager::SetTaskSecondary(&v81->m_taskManager, v82, 4);
        if ( v96->m_eMoveState == PEDMOVE_STILL )
        {
          switch ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 10.0) )
          {
            case 0:
            case 1:
            case 2:
              goto LABEL_120;
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
              goto LABEL_119;
            case 8:
              goto LABEL_121;
            case 9:
              goto LABEL_122;
            default:
              return this->m_pSubTask;
          }
        }
      }
    }
    return this->m_pSubTask;
  }
  objectBeingHeld = EntityThatThisPedIsHolding;
  v71 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x12Bu);
  v72 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x12Cu);
  v73 = (unsigned int)v71 | (unsigned int)v72 | (unsigned int)RpAnimBlendClumpGetAssociation(
                                                                (RpClump_0 *)v96->m_pRwObject,
                                                                0x12Du);
  v74 = RpAnimBlendClumpGetAssociation((RpClump_0 *)v96->m_pRwObject, 0x12Eu);
  v75 = v73 | (unsigned int)v74;
  if ( v73 | (unsigned int)v74 )
  {
    v75 = 1;
    if ( IKChainManager_c::IsLooking(&g_ikChainMan, v96) )
      IKChainManager_c::AbortLookAt(&g_ikChainMan, v96, 250);
    *((_DWORD *)p_m_nPedFlags + 2) |= 0x400000u;
  }
  if ( (unsigned int)v72 | (unsigned int)v74
    && (v72 && v72->m_fCurrentTime < 0.5 || v74 && v74->m_fCurrentTime < 0.5)
    && !this->m_exhaleTimer.m_bIsActive )
  {
    *(_QWORD *)&this->m_exhaleTimer.m_iStartTime = CTimer::m_snTimeInMilliseconds | 0xA8C00000000LL;
    this->m_exhaleTimer.m_bIsActive = 1;
  }
  if ( CTaskManager::FindActiveTaskByType(&v96->m_pPedIntelligence->m_taskManager, 1211) )
    return this->m_pSubTask;
  if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 500.0) != 200 )
  {
    if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) == 50 )
    {
      v85 = (CTaskSimpleHoldEntity *)CTaskManager::FindActiveTaskByType(&v96->m_pPedIntelligence->m_taskManager, 307);
      if ( v85 )
      {
        RandomGangAmbientAnim = CTaskComplexGangLeader::GetRandomGangAmbientAnim(v96, objectBeingHeld);
        CTaskSimpleHoldEntity::PlayAnim(v85, RandomGangAmbientAnim, ANIM_GANG_PED);
      }
    }
    return this->m_pSubTask;
  }
  if ( v75 )
    return this->m_pSubTask;
  ClosestGroupPed = CPedGroup::GetClosestGroupPed(this->m_pPedGroup, v96, &offsetPos.x);
  if ( !ClosestGroupPed
    || offsetPos.x >= 4.0
    || CPed::IsPlayer(v96)
    || CPed::GetEntityThatThisPedIsHolding(ClosestGroupPed)
    || ClosestGroupPed->m_WeaponSlots[ClosestGroupPed->m_nCurrentWeapon].m_eWeaponType )
  {
    return this->m_pSubTask;
  }
  m_nModelIndex = objectBeingHeld->m_nModelIndex;
  if ( m_nModelIndex == MI_GANG_DRINK )
  {
    if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 500.0) <= 249 )
    {
      v79 = 24;
LABEL_129:
      CPed::Say(ClosestGroupPed, v79, 0, 1.0, 0, 0, 0);
      goto LABEL_133;
    }
    v92 = 23;
    goto LABEL_132;
  }
  if ( m_nModelIndex == MI_GANG_SMOKE )
  {
    if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 500.0) <= 249 )
    {
      v79 = 201;
      goto LABEL_129;
    }
    v92 = 200;
LABEL_132:
    CPed::Say(v96, v92, 0x5DCu, 1.0, 0, 0, 0);
  }
LABEL_133:
  CEvent::CEvent((CEvent *)&offsetPos);
  v98 = v96;
  LODWORD(offsetPos.x) = &off_6670B0;
  CEntity::RegisterReference(v96, &v98);
  v99 = 0;
  CEventGroup::Add(&ClosestGroupPed->m_pPedIntelligence->m_eventGroup, (CEvent *)&offsetPos, 0);
  v22 = CTask::operator new(0x30u);
  CTaskComplex::CTaskComplex((CTaskComplex *)v22);
  *((_WORD *)v22 + 20) = 0;
  *((_BYTE *)v22 + 16) = 1;
  *((_DWORD *)v22 + 8) = 0;
  *((_DWORD *)v22 + 9) = 0;
  *(_DWORD *)v22 = &off_66BFEC;
  *((_DWORD *)v22 + 3) = ClosestGroupPed;
  CEntity::RegisterReference(ClosestGroupPed, (CEntity **)v22 + 3);
  LODWORD(offsetPos.x) = &off_6670B0;
  if ( v98 )
    CEntity::CleanUpOldReference(v98, &v98);
  CEvent::~CEvent((CEvent *)&offsetPos);
  return (CTask *)v22;
}
// 6670B0: using guessed type void *off_6670B0;
// 66BFEC: using guessed type void *off_66BFEC;
// 6778F8: using guessed type __int16 *MI_GANG_DRINK_ptr;
// 679000: using guessed type __int16 *MI_GANG_SMOKE_ptr;

//----- (00517848) --------------------------------------------------------
void __fastcall CTaskComplexGangFollower::SetFollowLeader(CTaskComplexGangFollower *this, bool8 val)
{
  *((_BYTE *)this + 61) = (4 * val) & 4 | *((_BYTE *)this + 61) & 0xFB;
}

//----- (00517860) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CTaskSimpleGoToPointFine::CTaskSimpleGoToPointFine(
        CTaskSimpleGoToPointFine *this,
        float moveBlendRatio,
        CVector targetPos,
        float targetRadius,
        CEntity *pEntityWhichMayObscureWaypoint)
{
  int v6; // r0
  CVector vTarget; // [sp+4h] [bp-14h] BYREF

  vTarget = targetPos;
  CTaskSimpleGoTo::CTaskSimpleGoTo(this, 4, &vTarget, targetRadius);
  *(float *)(v6 + 32) = moveBlendRatio;
  *(_DWORD *)v6 = &off_66BDE8;
}
// 517860: fragmented variable at 0:r2.8,8:^20.4 may be wrong
// 517860: variables would overlap: 0:r2.8,8:^20.4 and ^20.4
// 66BDE8: using guessed type void *off_66BDE8;

//----- (00517894) --------------------------------------------------------
void __fastcall CTaskSimpleGoToPointFine::~CTaskSimpleGoToPointFine(CTaskSimpleGoToPointFine *this)
{
  void *v1; // r0

  CTaskSimpleGoToPoint::~CTaskSimpleGoToPoint(this);
  sub_197118(v1);
}
// 5178A0: variable 'v1' is possibly undefined

//----- (005178A4) --------------------------------------------------------
bool __fastcall CTaskSimpleGoToPointFine::MakeAbortable(
        CTaskSimpleGoToPointFine *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CTaskSimpleGoTo::QuitIK(this, pPed);
  CPed::SetMoveState(pPed, PEDMOVE_STILL);
  (*((void (__fastcall **)(CPed *))pPed->_vptr$CPlaceable + 24))(pPed);
  CPed::SetMoveState(pPed, (eMoveState)this->m_iMoveState);
  (*((void (__fastcall **)(CPed *))pPed->_vptr$CPlaceable + 24))(pPed);
  return 1;
}

//----- (005178D4) --------------------------------------------------------
void __fastcall CTaskSimpleGoToPointFine::Finish(CTaskSimpleGoToPointFine *this, CPed *pPed)
{
  CPed::SetMoveState(pPed, PEDMOVE_STILL);
  (*((void (__fastcall **)(CPed *))pPed->_vptr$CPlaceable + 24))(pPed);
  CPed::SetMoveState(pPed, (eMoveState)this->m_iMoveState);
  (*((void (__fastcall **)(CPed *))pPed->_vptr$CPlaceable + 24))(pPed);
}

//----- (00517900) --------------------------------------------------------
bool __fastcall CTaskSimpleGoToPointFine::ProcessPed(CTaskSimpleGoToPointFine *this, CPed *pPed)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float v6; // s18
  float v7; // s16
  bool v8; // r6
  float RadianAngleBetweenPoints; // r0

  m_pMat = pPed->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  v6 = this->m_vTarget.x - p_tx->m_translate.x;
  v7 = this->m_vTarget.y - p_tx->m_translate.y;
  if ( (float)((float)((float)(v6 * v6) + (float)(v7 * v7)) + 0.0) <= (float)(this->m_fTargetRadius
                                                                            * this->m_fTargetRadius)
    || CTaskSimpleGoTo::HasCircledTarget(this, pPed) )
  {
    CTaskSimpleGoTo::QuitIK(this, pPed);
    v8 = 1;
    CPed::SetMoveState(pPed, PEDMOVE_STILL);
    (*((void (__fastcall **)(CPed *))pPed->_vptr$CPlaceable + 24))(pPed);
    CPed::SetMoveState(pPed, (eMoveState)this->m_iMoveState);
    (*((void (__fastcall **)(CPed *))pPed->_vptr$CPlaceable + 24))(pPed);
  }
  else
  {
    CTaskSimpleGoToPointFine::SetBlendedMoveAnim(this, pPed);
    v8 = 0;
    RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(v6, v7, 0.0, 0.0);
    pPed->m_fDesiredHeading = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
    CTaskSimpleGoTo::SetUpIK(this, pPed);
  }
  return v8;
}

//----- (005179CC) --------------------------------------------------------
void __fastcall CTaskSimpleGoToPointFine::SetBlendedMoveAnim(CTaskSimpleGoToPointFine *this, CPed *pPed)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d2
  CAnimBlendAssociation *Association; // r4
  CAnimBlendAssociation *v7; // r6
  CAnimBlendAssociation *v8; // r10
  CAnimBlendAssociation *v9; // r11
  int v10; // r4
  CTaskSimpleDuck *TaskDuck; // r0
  CVector2D v12; // r1
  int (**v13)(void); // r0
  float m_moveBlendRatio; // s0
  float v15; // s0
  CAnimBlendAssociation *v16; // r0
  float v17; // s2
  eMoveState v18; // r1
  CPed *v19; // r0
  uint16 m_bitsFlag; // r1
  float v21; // s0
  float v22; // s2
  CAnimBlendAssociation *v23; // [sp+4h] [bp-2Ch]

  Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 3u);
  v7 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0);
  v8 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 1u);
  v23 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 2u);
  v9 = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0xAu);
  if ( (*(_DWORD *)&pPed->m_nPedFlags & 0x4000000) == 0 )
  {
    if ( !(*((_DWORD *)&pPed->m_nPedFlags + 1) << 31) )
      goto LABEL_10;
    goto LABEL_3;
  }
  if ( CPedIntelligence::GetTaskDuck(pPed->m_pPedIntelligence, 0) )
  {
    v3.n64_u32[0] = 1.0;
    v2.n64_f32[0] = this->m_moveBlendRatio * 0.5;
    TaskDuck = CPedIntelligence::GetTaskDuck(pPed->m_pPedIntelligence, 0);
    LODWORD(v12.y) = vmin_f32(v2, v3).n64_u32[0] ^ 0x80000000;
    v12.x = 0.0;
    CTaskSimpleDuck::ControlDuckMove(TaskDuck, v12);
    return;
  }
  if ( *((_DWORD *)&pPed->m_nPedFlags + 1) << 31 )
  {
LABEL_3:
    if ( v7 )
      CAnimBlendAssociation::SetCurrentTime(v7, 0.0);
    if ( v8 )
      CAnimBlendAssociation::SetCurrentTime(v8, 0.0);
    if ( v23 )
      CAnimBlendAssociation::SetCurrentTime(v23, 0.0);
    *((_DWORD *)&pPed->m_nPedFlags + 1) &= ~1u;
  }
LABEL_10:
  if ( this->m_moveBlendRatio == 0.0 )
  {
    if ( !Association )
      CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, pPed->m_motionAnimGroup, ANIM_STD_IDLE, 4.0);
    if ( v7 )
      (*((void (__fastcall **)(CAnimBlendAssociation *))v7->_vptr$CAnimBlendAssociation + 1))(v7);
    if ( v8 )
      (*((void (__fastcall **)(CAnimBlendAssociation *))v8->_vptr$CAnimBlendAssociation + 1))(v8);
    if ( v23 )
      (*((void (__fastcall **)(CAnimBlendAssociation *))v23->_vptr$CAnimBlendAssociation + 1))(v23);
    v10 = 1;
    CPed::SetMoveState(pPed, PEDMOVE_STILL);
  }
  else
  {
    if ( Association )
    {
      if ( v7 )
        CAnimBlendAssociation::SetCurrentTime(v7, 0.0);
      if ( v8 )
        CAnimBlendAssociation::SetCurrentTime(v8, 0.0);
      (*((void (__fastcall **)(CAnimBlendAssociation *))Association->_vptr$CAnimBlendAssociation + 1))(Association);
    }
    if ( v9 )
    {
      v13 = v9->_vptr$CAnimBlendAssociation;
      v9->m_fBlendDelta = -4.0;
      ((void (__fastcall *)(CAnimBlendAssociation *))v13[1])(v9);
    }
    m_moveBlendRatio = this->m_moveBlendRatio;
    if ( m_moveBlendRatio <= 1.0 )
    {
      if ( !v7 )
      {
        v7 = CAnimManager::AddAnimation((RpClump_0 *)pPed->m_pRwObject, pPed->m_motionAnimGroup, ANIM_STD_WALK);
        v7->m_fBlendAmount = 0.0;
        v7->m_fSpeed = 1.0;
      }
      m_bitsFlag = v7->m_bitsFlag;
      v7->m_fBlendAmount = 1.0;
      v7->m_fBlendDelta = 0.0;
      v7->m_bitsFlag = m_bitsFlag | 1;
      if ( v8 )
        (*((void (__fastcall **)(CAnimBlendAssociation *))v8->_vptr$CAnimBlendAssociation + 1))(v8);
      if ( v23 )
        (*((void (__fastcall **)(CAnimBlendAssociation *))v23->_vptr$CAnimBlendAssociation + 1))(v23);
      v10 = 4;
      v19 = pPed;
      v18 = PEDMOVE_WALK;
    }
    else if ( m_moveBlendRatio <= 2.0 )
    {
      if ( !v7 )
      {
        v7 = CAnimManager::AddAnimation((RpClump_0 *)pPed->m_pRwObject, pPed->m_motionAnimGroup, ANIM_STD_WALK);
        v7->m_fBlendAmount = 0.0;
        v7->m_fSpeed = 1.0;
      }
      v7->m_bitsFlag |= 1u;
      v21 = this->m_moveBlendRatio;
      v7->m_fBlendDelta = 0.0;
      v7->m_fBlendAmount = 2.0 - v21;
      if ( !v8 )
      {
        v8 = CAnimManager::AddAnimation((RpClump_0 *)pPed->m_pRwObject, pPed->m_motionAnimGroup, ANIM_STD_RUN);
        v8->m_fBlendAmount = 0.0;
        v8->m_fSpeed = 1.0;
      }
      v8->m_bitsFlag |= 1u;
      v22 = this->m_moveBlendRatio;
      v8->m_fBlendDelta = 0.0;
      v8->m_fBlendAmount = v22 + -1.0;
      if ( v23 )
        (*((void (__fastcall **)(CAnimBlendAssociation *))v23->_vptr$CAnimBlendAssociation + 1))(v23);
      v10 = 6;
      v19 = pPed;
      v18 = PEDMOVE_RUN;
    }
    else
    {
      if ( m_moveBlendRatio > 3.0 )
        return;
      if ( v7 )
        (*((void (__fastcall **)(CAnimBlendAssociation *))v7->_vptr$CAnimBlendAssociation + 1))(v7);
      if ( !v8 )
      {
        v8 = CAnimManager::AddAnimation((RpClump_0 *)pPed->m_pRwObject, pPed->m_motionAnimGroup, ANIM_STD_RUN);
        v8->m_fBlendAmount = 0.0;
        v8->m_fSpeed = 1.0;
      }
      v8->m_bitsFlag |= 1u;
      v15 = this->m_moveBlendRatio;
      v8->m_fBlendDelta = 0.0;
      v8->m_fBlendAmount = 3.0 - v15;
      v16 = v23;
      if ( !v23 )
      {
        v16 = CAnimManager::AddAnimation((RpClump_0 *)pPed->m_pRwObject, pPed->m_motionAnimGroup, ANIM_STD_RUNFAST);
        v16->m_fBlendAmount = 0.0;
        v16->m_fSpeed = 1.0;
      }
      v16->m_bitsFlag |= 1u;
      v17 = this->m_moveBlendRatio;
      v18 = PEDMOVE_SPRINT;
      v16->m_fBlendDelta = 0.0;
      v10 = 7;
      v16->m_fBlendAmount = v17 + -2.0;
      v19 = pPed;
    }
    CPed::SetMoveState(v19, v18);
    pPed->m_eMoveStateAnim = v10;
  }
  this->m_iMoveState = v10;
}
// 517AD2: variable 'v2' is possibly undefined
// 517AD2: variable 'v3' is possibly undefined

//----- (00517CD8) --------------------------------------------------------
float __fastcall CTaskSimpleGoToPointFine::BaseRatio(eMoveState movestate)
{
  unsigned __int32 v1; // r0

  v1 = movestate - 4;
  if ( v1 <= 3 )
    return *(float *)&dword_517CE8[v1];
  else
    return 0.0;
}
// 517CE8: using guessed type int dword_517CE8[2];

//----- (00517CF8) --------------------------------------------------------
void __fastcall CTaskSimpleGoToPointFine::SetTargetPos(CTaskSimpleGoToPointFine *this, CVector targetPos)
{
  char v2; // r12

  if ( this->m_vTarget.x != targetPos.x
    || this->m_vTarget.y != targetPos.y
    || this->m_vTarget.z != targetPos.z
    || this->m_fTargetRadius != 0.5 )
  {
    v2 = *((_BYTE *)&this->CTaskSimpleGoTo + 28);
    this->m_vTarget = targetPos;
    this->m_fTargetRadius = 0.5;
    *((_BYTE *)&this->CTaskSimpleGoTo + 28) = v2 & 0xD0 | 0x20;
  }
}

//----- (00517D6C) --------------------------------------------------------
void __fastcall CTaskSimpleGoToPointFine::SetMoveRatio(CTaskSimpleGoToPointFine *this, float moveRatio)
{
  this->m_moveBlendRatio = moveRatio;
}

//----- (00517D70) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CTaskComplexTrackEntity::CTaskComplexTrackEntity(
        CTaskComplexTrackEntity *this,
        CEntity *pEntity,
        CVector offsetPos,
        bool8 useSprint,
        int32 giveUpTime,
        float nodeRouteDist,
        float giveUpDist,
        bool8 localOffset)
{
  RwReal y; // r8
  RwReal x; // r6

  y = offsetPos.y;
  x = offsetPos.x;
  CTaskComplex::CTaskComplex(this);
  *(_WORD *)&this->m_timer.m_bIsActive = 0;
  this->m_offsetPos.x = x;
  this->m_timer.m_iStartTime = 0;
  this->m_timer.m_iDuration = 0;
  this->m_offsetPos.z = offsetPos.z;
  this->m_offsetPos.y = y;
  this->m_giveUpTime = giveUpTime;
  this->m_nodeRouteDist = nodeRouteDist;
  this->m_giveUpDist = giveUpDist;
  this->m_useSprint = useSprint;
  this->m_localOffset = localOffset;
  this->_vptr$CTask = (int (**)(void))&off_66BE1C;
  this->m_pEntity = pEntity;
  CEntity::RegisterReference(pEntity, &this->m_pEntity);
  this->m_moveBlendRatio = -1.0;
}
// 517D70: fragmented variable at 0:r2.8,8:^18.4 may be wrong
// 517D70: variables would overlap: 0:r2.8,8:^18.4 and ^18.4
// 66BE1C: using guessed type void *;

//----- (00517DE4) --------------------------------------------------------
void __fastcall CTaskComplexTrackEntity::~CTaskComplexTrackEntity(CTaskComplexTrackEntity *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CTask = (int (**)(void))&off_66BE1C;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  sub_18EDB4(this);
}
// 66BE1C: using guessed type void *off_66BE1C;

//----- (00517E10) --------------------------------------------------------
void __fastcall CTaskComplexTrackEntity::~CTaskComplexTrackEntity(CTaskComplexTrackEntity *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1
  void *v4; // r0

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CTask = (int (**)(void))&off_66BE1C;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 517E38: variable 'v4' is possibly undefined
// 66BE1C: using guessed type void *off_66BE1C;

//----- (00517E40) --------------------------------------------------------
bool __fastcall CTaskComplexTrackEntity::MakeAbortable(
        CTaskComplexTrackEntity *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
          + 7))(
           this->m_pSubTask,
           pPed,
           iPriority,
           pEvent);
}

//----- (00517E4C) --------------------------------------------------------
CTask *__fastcall CTaskComplexTrackEntity::Clone(const CTaskComplexTrackEntity *this)
{
  int32 m_giveUpTime; // r0
  CTaskComplex *v3; // r0
  __int64 v4; // kr00_8
  CTaskComplex *v5; // r5
  __int64 v6; // r10
  float m_nodeRouteDist; // r8
  float m_giveUpDist; // [sp+4h] [bp-2Ch]
  bool8 m_useSprint; // [sp+8h] [bp-28h]
  bool8 m_localOffset; // [sp+Ch] [bp-24h]
  int32 v12; // [sp+10h] [bp-20h]

  if ( this->m_timer.m_bIsActive )
    m_giveUpTime = this->m_timer.m_iStartTime + this->m_timer.m_iDuration - CTimer::m_snTimeInMilliseconds;
  else
    m_giveUpTime = this->m_giveUpTime;
  v12 = m_giveUpTime;
  v3 = (CTaskComplex *)CTask::operator new(0x58u);
  v4 = *(_QWORD *)&this->m_pEntity;
  v5 = v3;
  v6 = *(_QWORD *)&this->m_offsetPos.y;
  m_localOffset = this->m_localOffset;
  m_useSprint = this->m_useSprint;
  m_nodeRouteDist = this->m_nodeRouteDist;
  m_giveUpDist = this->m_giveUpDist;
  CTaskComplex::CTaskComplex(v3);
  v5[1].m_pParent = (CTask *)HIDWORD(v4);
  *(_QWORD *)&v5[1].m_pSubTask = v6;
  v5[2].m_pSubTask = (CTask *)v12;
  *(float *)&v5[3]._vptr$CTask = m_nodeRouteDist;
  *(float *)&v5[3].m_pParent = m_giveUpDist;
  LOWORD(v5[4].m_pSubTask) = 0;
  LOBYTE(v5[2].m_pParent) = m_useSprint;
  LOBYTE(v5[3].m_pSubTask) = m_localOffset;
  v5[4]._vptr$CTask = 0;
  v5[4].m_pParent = 0;
  v5->_vptr$CTask = (int (**)(void))&off_66BE1C;
  v5[1]._vptr$CTask = (int (**)(void))v4;
  CEntity::RegisterReference((CEntity *)v4, (CEntity **)&v5[1]);
  v5[5]._vptr$CTask = (int (**)(void))-1082130432;
  v5[5]._vptr$CTask = (int (**)(void))LODWORD(this->m_moveBlendRatio);
  return v5;
}
// 66BE1C: using guessed type void *off_66BE1C;

//----- (00517EF4) --------------------------------------------------------
CTask *__fastcall CTaskComplexTrackEntity::CreateNextSubTask(CTaskComplexTrackEntity *this, CPed *pPed)
{
  CTask *m_pSubTask; // r0
  CTaskSimpleGoTo *v4; // r0
  float m_moveBlendRatio; // r5
  RwReal y; // r2
  RwReal z; // r3
  CTask *result; // r0
  CTaskSimpleStandStill *v9; // r0
  CTaskComplexFollowNodeRoute *v10; // r0
  CEntity *m_pEntity; // r3
  CMatrix *m_pMat; // r5
  const CVector *p_tx; // r2
  CVector vTarget; // [sp+14h] [bp-14h] BYREF

  if ( !this->m_pEntity )
    return 0;
  m_pSubTask = this->m_pSubTask;
  if ( m_pSubTask && (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) == 203 )
  {
    if ( this->m_distToTargetSq >= (float)(this->m_nodeRouteDist * this->m_nodeRouteDist) )
    {
      v10 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x60u);
      m_pEntity = this->m_pEntity;
      m_pMat = m_pEntity->m_pMat;
      p_tx = (const CVector *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &m_pEntity->m_transform.m_translate;
      CTaskComplexFollowNodeRoute::CTaskComplexFollowNodeRoute(v10, 6, p_tx, 0.5, 0.2, 2.0, 0, -1, 1);
    }
    else
    {
      v4 = (CTaskSimpleGoTo *)CTask::operator new(0x24u);
      m_moveBlendRatio = this->m_moveBlendRatio;
      y = this->m_targetPos.y;
      z = this->m_targetPos.z;
      vTarget.x = this->m_targetPos.x;
      vTarget.y = y;
      vTarget.z = z;
      CTaskSimpleGoTo::CTaskSimpleGoTo(v4, 4, &vTarget, 0.25);
      *(float *)&result[4]._vptr$CTask = m_moveBlendRatio;
      result->_vptr$CTask = (int (**)(void))&off_66BDE8;
    }
  }
  else
  {
    v9 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill(v9, 50, 0, 0, 8.0);
  }
  return result;
}
// 517F48: variable 'result' is possibly undefined
// 66BDE8: using guessed type void *;

//----- (00517FC8) --------------------------------------------------------
CTask *__fastcall CTaskComplexTrackEntity::CreateFirstSubTask(CTaskComplexTrackEntity *this, CPed *pPed)
{
  eMoveState m_eMoveState; // r2
  float v3; // s0

  if ( this->m_moveBlendRatio < 0.0 )
  {
    m_eMoveState = pPed->m_eMoveState;
    if ( m_eMoveState == PEDMOVE_STILL )
    {
      v3 = 0.0;
    }
    else if ( m_eMoveState == PEDMOVE_WALK )
    {
      v3 = 1.0;
    }
    else
    {
      v3 = 3.0;
      if ( m_eMoveState == PEDMOVE_RUN )
        v3 = 2.0;
    }
    this->m_moveBlendRatio = v3;
  }
  return (CTask *)(*((int (__fastcall **)(CTaskComplexTrackEntity *))this->_vptr$CTask + 10))(this);
}

//----- (0051800C) --------------------------------------------------------
CTask *__fastcall CTaskComplexTrackEntity::ControlSubTask(CTaskComplexTrackEntity *this, CPed *pPed)
{
  unsigned int v4; // r0
  int m_iStartTime; // r1
  float v6; // s0
  CTask *v7; // r6
  float m_distToTargetSq; // s0
  float v9; // s0
  float v11; // s2
  float v12; // s6
  float v13; // s0
  float m_moveBlendRatio; // s0
  float v15; // s2
  float v16; // s8
  float v17; // s0
  float x; // r1
  float y; // r2
  float z; // r3
  CTask *m_pSubTask; // r0
  char m_pParent; // r6
  float v23; // r1

  if ( !this->m_pEntity
    || this->m_timer.m_bIsActive
    && (!this->m_timer.m_bIsStopped ? (m_iStartTime = this->m_timer.m_iStartTime, v4 = CTimer::m_snTimeInMilliseconds) : (v4 = CTimer::m_snTimeInMilliseconds, this->m_timer.m_bIsStopped = 0, this->m_timer.m_iStartTime = v4, m_iStartTime = v4),
        m_iStartTime + this->m_timer.m_iDuration <= v4) )
  {
    v7 = 0;
    if ( !(*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
            this->m_pSubTask,
            pPed,
            1,
            0) )
      return this->m_pSubTask;
    return v7;
  }
  CTaskComplexTrackEntity::CalcTargetPos(this, pPed);
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 906 )
  {
    if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 926 )
    {
      m_distToTargetSq = this->m_distToTargetSq;
      if ( m_distToTargetSq >= (float)(this->m_nodeRouteDist * this->m_nodeRouteDist) )
      {
        if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
               this->m_pSubTask,
               pPed,
               1,
               0) == 1 )
          return (CTask *)(*((int (__fastcall **)(CTaskComplexTrackEntity *, CPed *))this->_vptr$CTask + 10))(
                            this,
                            pPed);
        m_distToTargetSq = this->m_distToTargetSq;
      }
      if ( m_distToTargetSq >= 0.04 )
      {
        if ( m_distToTargetSq <= 25.0 )
        {
          v11 = sqrtf(m_distToTargetSq);
          if ( m_distToTargetSq >= 1.0 )
            v9 = (float)((float)((float)(v11 + -1.0) * 0.25) * 0.5) + 0.5;
          else
            v9 = (float)((float)(v11 + -0.2) * 1.25) * 0.5;
        }
        else
        {
          v9 = 1.0;
        }
      }
      else
      {
        v9 = 0.0;
      }
      v12 = sqrtf(v9) * 3.0;
      v13 = v12;
      if ( v12 > 2.0 )
        v13 = 2.0;
      if ( !this->m_useSprint )
        v12 = v13;
      m_moveBlendRatio = this->m_moveBlendRatio;
      v15 = v12 - m_moveBlendRatio;
      v16 = m_moveBlendRatio + 0.2;
      v17 = v12;
      if ( v15 > 0.2 )
        v17 = v16;
      x = this->m_targetPos.x;
      y = this->m_targetPos.y;
      z = this->m_targetPos.z;
      m_pSubTask = this->m_pSubTask;
      this->m_moveBlendRatio = v17;
      this->m_targetBlendRatio = v12;
      if ( *(float *)&m_pSubTask[1].m_pParent == x
        && *(float *)&m_pSubTask[2]._vptr$CTask == y
        && *(float *)&m_pSubTask[2].m_pParent == z
        && *(float *)&m_pSubTask[3]._vptr$CTask == 0.5 )
      {
        v23 = v17;
      }
      else
      {
        m_pSubTask[3]._vptr$CTask = (int (**)(void))1056964608;
        m_pParent = (char)m_pSubTask[3].m_pParent;
        *(float *)&m_pSubTask[1].m_pParent = x;
        *(float *)&m_pSubTask[2]._vptr$CTask = y;
        *(float *)&m_pSubTask[2].m_pParent = z;
        LOBYTE(m_pSubTask[3].m_pParent) = m_pParent & 0xD0 | 0x20;
        v23 = this->m_moveBlendRatio;
      }
      *(float *)&m_pSubTask[4]._vptr$CTask = v23;
    }
    return this->m_pSubTask;
  }
  v6 = this->m_distToTargetSq;
  if ( v6 <= (float)(this->m_giveUpDist * this->m_giveUpDist) )
  {
    if ( v6 < (float)(this->m_nodeRouteDist * this->m_nodeRouteDist)
      && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
           this->m_pSubTask,
           pPed,
           1,
           0) == 1 )
    {
      return (CTask *)(*((int (__fastcall **)(CTaskComplexTrackEntity *, CPed *))this->_vptr$CTask + 10))(this, pPed);
    }
    return this->m_pSubTask;
  }
  return 0;
}
// 15F8AC: using guessed type Elf32_Rel;

//----- (00518274) --------------------------------------------------------
void __fastcall CTaskComplexTrackEntity::CalcTargetPos(CTaskComplexTrackEntity *this, CPed *pPed)
{
  CEntity *m_pEntity; // r5
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r1
  __int64 v7; // d16
  RwReal z; // r0
  int m_localOffset; // r1
  float *p_xx; // r0
  CEntity *v11; // r6
  float *v12; // r1
  RwReal *p_z; // r0
  float v14; // s2
  float v15; // s0
  float v16; // s4
  float v17; // s18
  float v18; // s20
  float v19; // s16
  float x; // s0
  float y; // s4
  float v22; // s12
  float v23; // s14
  float v24; // s1
  float v25; // s3
  RwReal v26; // s6
  float v27; // s2
  RwReal v28; // s4
  CMatrix *v29; // r0
  CSimpleTransform *p_tx; // r1

  m_pEntity = this->m_pEntity;
  m_pMat = m_pEntity->m_pMat;
  p_m_transform = &m_pEntity->m_transform;
  if ( m_pMat )
    p_m_transform = (CSimpleTransform *)&m_pMat->tx;
  v7 = *(_QWORD *)&p_m_transform->m_translate.x;
  z = p_m_transform->m_translate.z;
  m_localOffset = this->m_localOffset;
  this->m_targetPos.z = z;
  *(_QWORD *)&this->m_targetPos.x = v7;
  if ( m_localOffset )
  {
    p_xx = &m_pEntity->m_pMat->xx;
    if ( p_xx )
    {
      v11 = m_pEntity;
      v12 = &m_pEntity->m_pMat->xx;
    }
    else
    {
      CPlaceable::AllocateMatrix(m_pEntity);
      CSimpleTransform::UpdateMatrix(&m_pEntity->m_transform, m_pEntity->m_pMat);
      v11 = this->m_pEntity;
      v12 = &m_pEntity->m_pMat->xx;
      p_xx = &v11->m_pMat->xx;
    }
    v17 = *v12;
    v18 = v12[1];
    v19 = v12[2];
    if ( !p_xx )
    {
      CPlaceable::AllocateMatrix(v11);
      CSimpleTransform::UpdateMatrix(&v11->m_transform, v11->m_pMat);
      p_xx = &v11->m_pMat->xx;
      v11 = this->m_pEntity;
    }
    x = this->m_offsetPos.x;
    y = this->m_offsetPos.y;
    v22 = v18 * x;
    v23 = p_xx[4] * y;
    v24 = p_xx[5] * y;
    v25 = p_xx[6];
    p_z = &this->m_targetPos.z;
    v14 = (float)(v19 * x) + this->m_targetPos.z;
    v16 = v25 * y;
    v15 = v23 + (float)((float)(v17 * x) + this->m_targetPos.x);
    v26 = v24 + (float)(v22 + this->m_targetPos.y);
    this->m_targetPos.x = v15;
    this->m_targetPos.y = v26;
    this->m_targetPos.z = v14;
  }
  else
  {
    p_z = &this->m_targetPos.y;
    v11 = m_pEntity;
    v14 = this->m_offsetPos.y;
    v15 = this->m_offsetPos.x + this->m_targetPos.x;
    v16 = this->m_targetPos.y;
    this->m_targetPos.x = v15;
  }
  *p_z = v16 + v14;
  if ( (*(_BYTE *)&v11->m_info & 6) == 2 )
  {
    v15 = (float)(CTimer::ms_fTimeStep * v11[1].m_transform.m_translate.z) + v15;
    v27 = (float)(CTimer::ms_fTimeStep * v11[1].m_transform.m_heading) + this->m_targetPos.y;
    v28 = (float)(CTimer::ms_fTimeStep * *(float *)&v11[1].m_pMat) + this->m_targetPos.z;
    this->m_targetPos.x = v15;
    this->m_targetPos.y = v27;
    this->m_targetPos.z = v28;
  }
  else
  {
    v27 = this->m_targetPos.y;
  }
  v29 = pPed->m_pMat;
  p_tx = (CSimpleTransform *)&v29->tx;
  if ( !v29 )
    p_tx = &pPed->m_transform;
  this->m_distToTargetSq = (float)((float)((float)(v15 - p_tx->m_translate.x) * (float)(v15 - p_tx->m_translate.x))
                                 + (float)((float)(v27 - p_tx->m_translate.y) * (float)(v27 - p_tx->m_translate.y)))
                         + 0.0;
}

//----- (0051840C) --------------------------------------------------------
void __fastcall CTaskComplexTrackEntity::CalcMoveRatio(CTaskComplexTrackEntity *this, CPed *pPed)
{
  float m_distToTargetSq; // s2
  float v3; // s0
  float v4; // s0
  float v5; // s0
  float v6; // s2
  float m_moveBlendRatio; // s2
  float v8; // s4
  float v9; // s2
  bool v10; // cc
  float v11; // s4

  m_distToTargetSq = this->m_distToTargetSq;
  if ( m_distToTargetSq >= 0.04 )
  {
    if ( m_distToTargetSq <= 25.0 )
    {
      v4 = sqrtf(m_distToTargetSq);
      if ( m_distToTargetSq >= 1.0 )
        v3 = (float)((float)((float)(v4 + -1.0) * 0.25) * 0.5) + 0.5;
      else
        v3 = (float)((float)(v4 + -0.2) * 1.25) * 0.5;
    }
    else
    {
      v3 = 1.0;
    }
  }
  else
  {
    v3 = 0.0;
  }
  v5 = sqrtf(v3) * 3.0;
  v6 = v5;
  if ( v5 > 2.0 )
    v6 = 2.0;
  if ( !this->m_useSprint )
    v5 = v6;
  m_moveBlendRatio = this->m_moveBlendRatio;
  v8 = v5 - m_moveBlendRatio;
  v9 = m_moveBlendRatio + 0.2;
  v10 = v8 <= 0.2;
  v11 = v5;
  if ( !v10 )
    v11 = v9;
  this->m_moveBlendRatio = v11;
  this->m_targetBlendRatio = v5;
}

//----- (005184E8) --------------------------------------------------------
void __fastcall CTaskComplexTrackEntity::SetOffsetPos(CTaskComplexTrackEntity *this, CVector offsetPos)
{
  this->m_offsetPos = offsetPos;
}

//----- (005184EE) --------------------------------------------------------
float __fastcall CTaskComplexTrackEntity::GetDistToTargetSq(CTaskComplexTrackEntity *this)
{
  return this->m_distToTargetSq;
}

//----- (005184F4) --------------------------------------------------------
void __fastcall CTaskGangHassleVehicle::CTaskGangHassleVehicle(
        CTaskGangHassleVehicle *this,
        CVehicle *pVehicle,
        int32 posId,
        bool8 beAggressive,
        float targetRadius,
        float bbOffset)
{
  CTaskComplex::CTaskComplex(this);
  *(_WORD *)&this->m_timer.m_bIsActive = 0;
  this->m_posId = -1;
  this->m_beAggressive = beAggressive;
  this->m_targetRadius = targetRadius;
  this->m_bbOffset = bbOffset;
  this->m_animsReferenced = 0;
  this->m_pDriver = 0;
  this->m_timer.m_iStartTime = 0;
  this->m_timer.m_iDuration = 0;
  this->_vptr$CTask = (int (**)(void))&off_66BE58;
  this->m_pVehicle = pVehicle;
  if ( pVehicle )
    CEntity::RegisterReference(pVehicle, &this->m_pVehicle);
}
// 66BE58: using guessed type void *;

//----- (00518558) --------------------------------------------------------
void __fastcall CTaskGangHassleVehicle::~CTaskGangHassleVehicle(CTaskGangHassleVehicle *this)
{
  CVehicle *m_pVehicle; // r0
  CEntity **p_m_pVehicle; // r5
  int m_posId; // r1
  CPed *m_pDriver; // r0
  int32 AnimationBlockIndex; // r0

  p_m_pVehicle = &this->m_pVehicle;
  m_pVehicle = this->m_pVehicle;
  this->_vptr$CTask = (int (**)(void))&off_66BE58;
  if ( m_pVehicle )
  {
    m_posId = this->m_posId;
    if ( m_posId < 0
      || (CVehicle::SetHasslePosId(m_pVehicle, m_posId, 0), (m_pVehicle = (CVehicle *)*p_m_pVehicle) != 0) )
    {
      CEntity::CleanUpOldReference(m_pVehicle, p_m_pVehicle);
    }
  }
  m_pDriver = this->m_pDriver;
  if ( m_pDriver )
    CEntity::CleanUpOldReference(m_pDriver, &this->m_pDriver);
  if ( this->m_animsReferenced )
  {
    AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("gangs");
    CAnimManager::RemoveAnimBlockRef(AnimationBlockIndex);
    this->m_animsReferenced = 0;
  }
  sub_18EDB4(this);
}
// 66BE58: using guessed type void *off_66BE58;

//----- (005185C0) --------------------------------------------------------
void __fastcall CTaskGangHassleVehicle::~CTaskGangHassleVehicle(CTaskGangHassleVehicle *this)
{
  void *v1; // r0

  CTaskGangHassleVehicle::~CTaskGangHassleVehicle(this);
  sub_197118(v1);
}
// 5185CC: variable 'v1' is possibly undefined

//----- (005185D0) --------------------------------------------------------
CTask *__fastcall CTaskGangHassleVehicle::Clone(const CTaskGangHassleVehicle *this)
{
  char *v2; // r4
  CVehicle *m_pVehicle; // r5
  bool8 m_beAggressive; // r8
  __int64 v5; // kr00_8

  v2 = (char *)CTask::operator new(0x44u);
  m_pVehicle = this->m_pVehicle;
  m_beAggressive = this->m_beAggressive;
  v5 = *(_QWORD *)&this->m_targetRadius;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_WORD *)v2 + 32) = 0;
  *((_DWORD *)v2 + 5) = -1;
  *(_QWORD *)(v2 + 28) = v5;
  v2[24] = m_beAggressive;
  v2[48] = 0;
  *((_DWORD *)v2 + 13) = 0;
  *((_DWORD *)v2 + 14) = 0;
  *((_DWORD *)v2 + 15) = 0;
  *(_DWORD *)v2 = &off_66BE58;
  *((_DWORD *)v2 + 4) = m_pVehicle;
  if ( m_pVehicle )
    CEntity::RegisterReference(m_pVehicle, (CEntity **)v2 + 4);
  return (CTask *)v2;
}
// 66BE58: using guessed type void *off_66BE58;

//----- (00518638) --------------------------------------------------------
CTask *__fastcall CTaskGangHassleVehicle::CreateNextSubTask(CTaskGangHassleVehicle *this, CPed *pPed)
{
  CVehicle *m_pVehicle; // r1
  CTask *m_pSubTask; // r0
  void *v5; // r5
  CTask *v6; // r0
  CTask *v7; // r0
  CTaskComplex *v9; // r0
  CVehicle *v10; // r8
  __int64 v11; // kr00_8
  RwReal z; // r4

  m_pVehicle = this->m_pVehicle;
  if ( !m_pVehicle )
    return 0;
  m_pSubTask = this->m_pSubTask;
  if ( !m_pSubTask )
    goto LABEL_5;
  if ( (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) == 911 )
    return 0;
  m_pVehicle = this->m_pVehicle;
LABEL_5:
  if ( m_pVehicle->m_nHealth >= 250.0 )
  {
    v6 = this->m_pSubTask;
    if ( !v6
      || (*((int (__fastcall **)(CTask *))v6->_vptr$CTask + 5))(v6) != 1212
      && ((v7 = this->m_pSubTask) == 0 || (*((int (__fastcall **)(CTask *))v7->_vptr$CTask + 5))(v7) != 925) )
    {
      v9 = (CTaskComplex *)CTask::operator new(0x58u);
      v10 = this->m_pVehicle;
      v5 = v9;
      v11 = *(_QWORD *)&this->m_entityOffset.x;
      z = this->m_entityOffset.z;
      CTaskComplex::CTaskComplex(v9);
      *((_WORD *)v5 + 28) = 0;
      *((_QWORD *)v5 + 2) = v11;
      *((RwReal *)v5 + 6) = z;
      *((_DWORD *)v5 + 8) = -1;
      *((_DWORD *)v5 + 9) = 1092616192;
      *((_DWORD *)v5 + 10) = 1109393408;
      *((_BYTE *)v5 + 28) = 1;
      *((_BYTE *)v5 + 44) = 1;
      *((_DWORD *)v5 + 12) = 0;
      *((_DWORD *)v5 + 13) = 0;
      *(_DWORD *)v5 = &off_66BE1C;
      *((_DWORD *)v5 + 3) = v10;
      CEntity::RegisterReference(v10, (CEntity **)v5 + 3);
      *((_DWORD *)v5 + 15) = -1082130432;
      return (CTask *)v5;
    }
    return 0;
  }
  v5 = CTask::operator new(0x40u);
  CTaskComplexSmartFleeEntity::CTaskComplexSmartFleeEntity(
    (CTaskComplexSmartFleeEntity *)v5,
    this->m_pVehicle,
    0,
    30.0,
    (const int)"ist_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly",
    (const int)&elf_hash_bucket[187],
    1.0);
  return (CTask *)v5;
}
// FC: using guessed type int elf_hash_bucket[16411];
// 66BE1C: using guessed type void *off_66BE1C;

//----- (00518758) --------------------------------------------------------
CTask *__fastcall CTaskGangHassleVehicle::CreateFirstSubTask(CTaskGangHassleVehicle *this, CPed *pPed)
{
  CVehicle *m_pVehicle; // r0
  CPed *pDriver; // r2
  CColModel *m_pColModel; // r1
  CTaskComplexLeaveCar *v7; // r6
  int32 SpareHasslePosId; // r1
  __int64 v10; // kr00_8
  CColModel *v11; // r1
  float x; // s4
  float y; // s0
  float v14; // s6
  float v15; // s2
  float v16; // s0
  RwReal v17; // s6
  float v18; // s0
  float v19; // s2
  int v20; // r6
  unsigned __int16 v21; // r0
  bool v22; // zf

  m_pVehicle = this->m_pVehicle;
  if ( !m_pVehicle )
    return 0;
  pDriver = m_pVehicle->pDriver;
  this->m_pDriver = pDriver;
  if ( pDriver )
  {
    CEntity::RegisterReference(pDriver, &this->m_pDriver);
    m_pVehicle = this->m_pVehicle;
  }
  m_pColModel = CModelInfo::ms_modelInfoPtrs[m_pVehicle->m_nModelIndex]->m_pColModel;
  if ( (float)(m_pColModel->m_boxBound.m_vecMax.x - m_pColModel->m_boxBound.m_vecMin.x) > 4.0
    || (float)(m_pColModel->m_boxBound.m_vecMax.y - m_pColModel->m_boxBound.m_vecMin.y) > 8.0 )
  {
    return 0;
  }
  SpareHasslePosId = CVehicle::GetSpareHasslePosId(m_pVehicle);
  v7 = 0;
  this->m_posId = SpareHasslePosId;
  if ( SpareHasslePosId == -1 )
    return v7;
  CVehicle::SetHasslePosId(this->m_pVehicle, SpareHasslePosId, 1);
  v10 = *(_QWORD *)&this->m_pVehicle;
  this->m_entityOffset.x = 0.0;
  this->m_entityOffset.y = 0.0;
  this->m_entityOffset.z = 0.0;
  v11 = CModelInfo::ms_modelInfoPtrs[*(__int16 *)(v10 + 38)]->m_pColModel;
  x = v11->m_boxBound.m_vecMin.x;
  y = v11->m_boxBound.m_vecMin.y;
  v14 = v11->m_boxBound.m_vecMax.x;
  v15 = v11->m_boxBound.m_vecMax.y;
  switch ( HIDWORD(v10) )
  {
    case 0:
      v16 = x - this->m_bbOffset;
      goto LABEL_12;
    case 1:
      v16 = v14 + this->m_bbOffset;
LABEL_12:
      v17 = v16 + 0.0;
      v18 = v15 * 0.5;
      this->m_entityOffset.x = v17;
      goto LABEL_18;
    case 2:
      v19 = x - this->m_bbOffset;
      goto LABEL_15;
    case 3:
      v19 = v14 + this->m_bbOffset;
LABEL_15:
      v18 = y * 0.5;
      this->m_entityOffset.x = v19 + 0.0;
      goto LABEL_18;
    case 4:
      v18 = y - this->m_bbOffset;
      goto LABEL_18;
    case 5:
      v18 = v15 + this->m_bbOffset;
LABEL_18:
      this->m_entityOffset.y = v18 + 0.0;
      break;
    default:
      break;
  }
  this->m_state = 0;
  CPed::DropEntityThatThisPedIsHolding(pPed, 1u);
  v20 = CTimer::m_snTimeInMilliseconds;
  v21 = rand();
  this->m_timer.m_bIsActive = 1;
  this->m_timer.m_iStartTime = v20;
  this->m_timer.m_iDuration = (int)(float)((float)((float)v21 * 0.000015259) * 100000.0) + 150000;
  v22 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
  if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
    v22 = pPed->m_pMyVehicle == 0;
  if ( !v22 )
  {
    v7 = (CTaskComplexLeaveCar *)CTask::operator new(0x34u);
    CTaskComplexLeaveCar::CTaskComplexLeaveCar(v7, pPed->m_pMyVehicle, 0, 0, 1, 0);
    return v7;
  }
  return (CTask *)(*((int (__fastcall **)(CTaskGangHassleVehicle *, CPed *))this->_vptr$CTask + 10))(this, pPed);
}

//----- (00518938) --------------------------------------------------------
void __fastcall CTaskGangHassleVehicle::CalcTargetOffset(CTaskGangHassleVehicle *this)
{
  __int64 v1; // kr00_8
  CColModel *m_pColModel; // r2
  float x; // s4
  float y; // s0
  float v5; // s6
  float v6; // s2
  float v7; // s0
  RwReal v8; // s6
  float v9; // s0
  float v10; // s2

  v1 = *(_QWORD *)&this->m_pVehicle;
  this->m_entityOffset.x = 0.0;
  this->m_entityOffset.y = 0.0;
  this->m_entityOffset.z = 0.0;
  if ( HIDWORD(v1) <= 5 )
    JUMPOUT(0x51894A);
  m_pColModel = CModelInfo::ms_modelInfoPtrs[*(__int16 *)(v1 + 38)]->m_pColModel;
  x = m_pColModel->m_boxBound.m_vecMin.x;
  y = m_pColModel->m_boxBound.m_vecMin.y;
  v5 = m_pColModel->m_boxBound.m_vecMax.x;
  v6 = m_pColModel->m_boxBound.m_vecMax.y;
  switch ( HIDWORD(v1) )
  {
    case 0:
      v7 = x - this->m_bbOffset;
      goto LABEL_5;
    case 1:
      v7 = v5 + this->m_bbOffset;
LABEL_5:
      v8 = v7 + 0.0;
      v9 = v6 * 0.5;
      this->m_entityOffset.x = v8;
      break;
    case 2:
      v10 = x - this->m_bbOffset;
      goto LABEL_8;
    case 3:
      v10 = v5 + this->m_bbOffset;
LABEL_8:
      v9 = y * 0.5;
      this->m_entityOffset.x = v10 + 0.0;
      break;
    case 4:
      v9 = y - this->m_bbOffset;
      break;
    case 5:
      v9 = v6 + this->m_bbOffset;
      break;
  }
  this->m_entityOffset.y = v9 + 0.0;
}
// 518946: control flows out of bounds to 51894A

//----- (005189EC) --------------------------------------------------------
CTask *__fastcall CTaskGangHassleVehicle::ControlSubTask(CTaskGangHassleVehicle *this, CPed *pPed)
{
  CTask *m_pSubTask; // r0
  unsigned int m_animsReferenced; // r6
  CPlayerPed *v6; // r1
  float *m_pMyVehicle; // r0
  bool v8; // zf
  _BOOL4 v9; // r0
  int32 AnimationBlockIndex; // r0
  bool8 v11; // r0
  int32 v12; // r0
  void *v13; // r6
  unsigned int v14; // r0
  int m_iStartTime; // r1
  CVehicle *m_pVehicle; // r0
  float v17; // s16
  unsigned __int16 v18; // r0
  CPed *pDriver; // r3
  CTask *v20; // r0
  CTask *v21; // r0
  int m_state; // r0
  CPedIntelligence *m_pPedIntelligence; // r5
  CTaskSimpleShakeFist *v25; // r6
  CTask *v26; // r0
  int m_beAggressive; // r5
  CPed *m_pDriver; // r4
  int v29; // r2
  __int64 v30; // kr00_8
  float32x2_t *v31; // r1
  float32x2_t v32; // d0
  __int64 v33; // kr08_8
  float32x2_t *v34; // r1
  float32x2_t v35; // d0
  float v36; // r0
  float v37; // s18
  CMatrix *v38; // r0
  float v39; // s0
  int v40; // r0
  UInt16 v41; // r1
  CTask *v42; // r0
  __int128 v43; // r0
  float v44; // s16
  float RadianAngleBetweenPoints; // r0
  float v46; // r6
  CMatrix *m_pMat; // r0
  float m_heading; // s18
  int v49; // r0
  CPedIntelligence *v50; // r6
  CTaskComplexPlayHandSignalAnim *v51; // r5
  float v52; // s0
  int *v53; // r1
  int v54; // r2
  int v55; // r5
  int v56; // r1
  unsigned __int16 v57; // r0
  _DWORD *v58; // r6
  _DWORD *v59; // r1
  CVehicle *v60; // r1
  float m_nHealth; // r9
  CMatrix *v62; // r0
  CVehicle *v63; // r0
  const CMatrix *v64; // r6
  CColModel *ColModel; // r0
  CVector nTimeToDuck; // [sp+0h] [bp-C0h]
  CMatrix v67; // [sp+20h] [bp-A0h] BYREF
  CTaskSimpleFight v68; // [sp+68h] [bp-58h] BYREF

  m_pSubTask = this->m_pSubTask;
  if ( m_pSubTask
    && (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) != 1000
    && !this->m_pVehicle )
  {
    v13 = 0;
    if ( !(*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
            this->m_pSubTask,
            pPed,
            1,
            0) )
      return this->m_pSubTask;
    return (CTask *)v13;
  }
  m_animsReferenced = this->m_animsReferenced;
  v6 = CWorld::Players[CWorld::PlayerInFocus].pPed;
  m_pMyVehicle = (float *)v6->m_pMyVehicle;
  v8 = m_pMyVehicle == 0;
  if ( m_pMyVehicle )
    v8 = (*(_DWORD *)&v6->m_nPedFlags & 0x100) == 0;
  if ( v8
    || (float)((float)((float)(m_pMyVehicle[18] * m_pMyVehicle[18]) + (float)(m_pMyVehicle[19] * m_pMyVehicle[19]))
             + (float)(m_pMyVehicle[20] * m_pMyVehicle[20])) <= 0.04 )
  {
    v9 = !CStreaming::IsVeryBusy();
    if ( !m_animsReferenced )
    {
LABEL_9:
      if ( v9 )
      {
        AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("gangs");
        if ( !CAnimManager::ms_aAnimBlocks[AnimationBlockIndex].m_loaded )
        {
          CStreaming::RequestModel(AnimationBlockIndex + 25575, 8);
          goto LABEL_20;
        }
        CAnimManager::AddAnimBlockRef(AnimationBlockIndex);
        v11 = 1;
        goto LABEL_15;
      }
      goto LABEL_20;
    }
  }
  else
  {
    v9 = 0;
    if ( !this->m_animsReferenced )
      goto LABEL_9;
  }
  if ( !v9 )
  {
    v12 = CAnimManager::GetAnimationBlockIndex("gangs");
    CAnimManager::RemoveAnimBlockRef(v12);
    v11 = 0;
LABEL_15:
    this->m_animsReferenced = v11;
  }
LABEL_20:
  if ( !this->m_timer.m_bIsActive
    || (!this->m_timer.m_bIsStopped ? (m_iStartTime = this->m_timer.m_iStartTime, v14 = CTimer::m_snTimeInMilliseconds) : (v14 = CTimer::m_snTimeInMilliseconds, this->m_timer.m_bIsStopped = 0, this->m_timer.m_iStartTime = v14, m_iStartTime = v14),
        m_iStartTime + this->m_timer.m_iDuration > v14 || !this->m_beAggressive) )
  {
    m_pVehicle = this->m_pVehicle;
    if ( m_pVehicle )
    {
      if ( !m_pVehicle->pDriver )
      {
        if ( this->m_pDriver )
        {
          if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 1212 )
          {
            v26 = this->m_pSubTask;
            m_animsReferenced = *((_DWORD *)v26->_vptr$CTask + 7);
            if ( ((int (__fastcall *)(CTask *, CPed *, int, _DWORD))m_animsReferenced)(v26, pPed, 1, 0) == 1 )
            {
              m_beAggressive = this->m_beAggressive;
              this->m_state = 3;
              v13 = CTask::operator new(0x2Cu);
              m_pDriver = this->m_pDriver;
              CTaskComplex::CTaskComplex((CTaskComplex *)v13);
              *((_WORD *)v13 + 20) = 0;
              *(_DWORD *)v13 = &off_66BE94;
              *((_DWORD *)v13 + 8) = 0;
              *((_DWORD *)v13 + 9) = 0;
              *((_DWORD *)v13 + 3) = m_pDriver;
              if ( m_beAggressive )
                v29 = 2;
              else
                v29 = 1;
              *((_DWORD *)v13 + 4) = v29;
              *((_DWORD *)v13 + 5) = 12000;
              *((_DWORD *)v13 + 6) = 20000;
              *((_BYTE *)v13 + 28) = 0;
              if ( m_pDriver )
                CEntity::RegisterReference(m_pDriver, (CEntity **)v13 + 3);
              return (CTask *)v13;
            }
          }
        }
      }
    }
    if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 925 )
    {
      v17 = *(float *)&this->m_pSubTask[10]._vptr$CTask;
      if ( CEntity::IsVisible(pPed)
        && v17 < 4.0
        && !IKChainManager_c::IsLooking(&g_ikChainMan, pPed)
        && (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) >= 61 )
      {
        v18 = rand();
        pDriver = this->m_pVehicle->pDriver;
        if ( pDriver )
          IKChainManager_c::LookAt(
            &g_ikChainMan,
            "TaskHassleVehicle",
            pPed,
            pDriver,
            (int)(float)((int)(float)((float)((float)v18 * 0.000015259) * 2000.0) + 1000),
            5,
            0,
            1,
            0.15,
            500,
            3,
            0);
      }
    }
    else
    {
      CEntity::IsVisible(pPed);
      v17 = 100.0;
    }
    v20 = this->m_pSubTask;
    if ( !v20
      || (*((int (__fastcall **)(CTask *))v20->_vptr$CTask + 5))(v20) != 925
      && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 906 )
    {
      return this->m_pSubTask;
    }
    if ( this->m_pVehicle->m_nHealth < 250.0 )
    {
      v21 = this->m_pSubTask;
      m_animsReferenced = *((_DWORD *)v21->_vptr$CTask + 7);
      if ( ((int (__fastcall *)(CTask *, CPed *, int, _DWORD))m_animsReferenced)(v21, pPed, 1, 0) == 1 )
        return (CTask *)(*((int (__fastcall **)(CTaskGangHassleVehicle *, CPed *))this->_vptr$CTask + 10))(this, pPed);
    }
    m_state = (unsigned __int8)this->m_state;
    if ( m_state != 2 )
    {
      if ( m_state != 1 )
      {
        if ( !this->m_state )
        {
          if ( !CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 4)
            && (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) >= 61 )
          {
            m_pPedIntelligence = pPed->m_pPedIntelligence;
            v25 = (CTaskSimpleShakeFist *)CTask::operator new(0x10u);
            CTaskSimpleShakeFist::CTaskSimpleShakeFist(v25);
            CTaskManager::SetTaskSecondary(&m_pPedIntelligence->m_taskManager, v25, 4);
          }
          if ( v17 <= (float)(this->m_targetRadius * this->m_targetRadius) )
            this->m_state = 1;
          CPed::Say(pPed, 0x101u, 0, 1.0, 0, 0, 0);
        }
        return this->m_pSubTask;
      }
      v33 = *(_QWORD *)&this->m_pVehicle;
      v34 = *(float32x2_t **)(v33 + 20);
      v35.n64_u64[0] = v34->n64_u64[0];
      switch ( HIDWORD(v33) )
      {
        case 1:
        case 3:
          v35.n64_u64[0] = vneg_f32(v35).n64_u64[0];
          break;
        case 4:
          v35.n64_u64[0] = v34[2].n64_u64[0];
          break;
        case 5:
          v35.n64_u64[0] = vneg_f32(v34[2]).n64_u64[0];
          break;
        default:
          break;
      }
      RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(v35.n64_f32[0], v35.n64_f32[1], 0.0, 0.0);
      v46 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
      m_pMat = pPed->m_pMat;
      pPed->m_fDesiredHeading = v46;
      if ( m_pMat )
        m_heading = atan2f(COERCE_FLOAT(LODWORD(m_pMat->xy) ^ 0x80000000), m_pMat->yy);
      else
        m_heading = pPed->m_transform.m_heading;
      if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 925 )
        return this->m_pSubTask;
      if ( v17 <= (float)(this->m_targetRadius * this->m_targetRadius) )
      {
        if ( fabsf(m_heading - v46) < 0.05 )
          this->m_state = 2;
        return this->m_pSubTask;
      }
LABEL_97:
      this->m_state = 0;
      return this->m_pSubTask;
    }
    if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 925
      && v17 > (float)((float)(this->m_targetRadius * this->m_targetRadius) + 0.05) )
    {
      this->m_state = 0;
    }
    v30 = *(_QWORD *)&this->m_pVehicle;
    v31 = *(float32x2_t **)(v30 + 20);
    v32.n64_u64[0] = v31->n64_u64[0];
    switch ( HIDWORD(v30) )
    {
      case 1:
      case 3:
        v32.n64_u64[0] = vneg_f32(v32).n64_u64[0];
        break;
      case 4:
        v32.n64_u64[0] = v31[2].n64_u64[0];
        break;
      case 5:
        v32.n64_u64[0] = vneg_f32(v31[2]).n64_u64[0];
        break;
      default:
        break;
    }
    v36 = CGeneral::GetRadianAngleBetweenPoints(v32.n64_f32[0], v32.n64_f32[1], 0.0, 0.0);
    v37 = CGeneral::LimitRadianAngle(v36);
    v38 = pPed->m_pMat;
    if ( v38 )
      v39 = atan2f(COERCE_FLOAT(LODWORD(v38->xy) ^ 0x80000000), v38->yy);
    else
      v39 = pPed->m_transform.m_heading;
    if ( fabsf(v39 - v37) >= 0.1 )
      this->m_state = 1;
    v40 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 3.0);
    if ( v40 == 2 )
    {
      v41 = 256;
    }
    else if ( v40 == 1 )
    {
      v41 = 255;
    }
    else
    {
      if ( v40 )
      {
LABEL_82:
        if ( !this->m_animsReferenced || pPed->m_eMoveState > PEDMOVE_JOG )
          return this->m_pSubTask;
        if ( CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 4) )
        {
          if ( v17 > (float)(this->m_targetRadius * this->m_targetRadius) )
          {
            v42 = this->m_pSubTask;
            m_animsReferenced = *((_DWORD *)v42->_vptr$CTask + 7);
            ((void (__fastcall *)(CTask *, CPed *, int, _DWORD))m_animsReferenced)(v42, pPed, 1, 0);
          }
          LODWORD(v43) = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x128u);
          v44 = 0.5;
          if ( !(_DWORD)v43 )
          {
            LODWORD(v43) = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x129u);
            if ( (_DWORD)v43 )
            {
              v44 = 0.7;
            }
            else
            {
              LODWORD(v43) = RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x12Au);
              if ( !(_DWORD)v43 )
                return this->m_pSubTask;
            }
          }
          v52 = *(float *)(v43 + 32);
          if ( v52 > v44 && (float)(v52 - *(float *)(v43 + 40)) <= v44 )
          {
            *(_QWORD *)&v43 = *(_QWORD *)&this->m_pVehicle;
            switch ( DWORD1(v43) )
            {
              case 0:
              case 2:
                v53 = *(int **)(v43 + 20);
                v54 = v53[1];
                v55 = *v53;
                v56 = v53[2];
                goto LABEL_120;
              case 1:
              case 3:
                v58 = *(_DWORD **)(v43 + 20);
                goto LABEL_122;
              case 4:
                v59 = *(_DWORD **)(v43 + 20);
                v54 = v59[5];
                v55 = v59[4];
                v56 = v59[6];
LABEL_120:
                m_animsReferenced = v56 ^ 0x80000000;
                DWORD2(v43) = v54 ^ 0x80000000;
                DWORD1(v43) = v55 ^ 0x80000000;
                break;
              case 5:
                v58 = (_DWORD *)(*(_DWORD *)(v43 + 20) + 16);
LABEL_122:
                DWORD1(v43) = *v58;
                DWORD2(v43) = v58[1];
                m_animsReferenced = v58[2];
                break;
              default:
                break;
            }
            nTimeToDuck.x = *((RwReal *)&v43 + 1);
            *(_QWORD *)&nTimeToDuck.y = __PAIR64__(m_animsReferenced, DWORD2(v43));
            DWORD1(v43) = 0;
            DWORD2(v43) = 0;
            *((float *)&v43 + 3) = *(float *)(v43 + 144) * 0.02;
            CPhysical::ApplyTurnForce((CPhysical *)v43, *(CVector *)((char *)&v43 + 4), nTimeToDuck);
            v60 = this->m_pVehicle;
            m_nHealth = v60->m_nHealth;
            CTaskSimpleFight::CTaskSimpleFight(&v68, v60, 11, 0x4E20u);
            CMatrix::CMatrix(&v67, pPed->m_pMat);
            v62 = pPed->m_pMat;
            v67.tx = v62->xy + v67.tx;
            v67.ty = v62->yy + v67.ty;
            v67.tz = v62->zy + v67.tz;
            CTaskSimpleFight::FightSetUpCol(&v68, 0.5);
            v68.m_nLastCommand = 11;
            *(_WORD *)&v68.m_nComboSet = 260;
            v63 = this->m_pVehicle;
            v64 = v63->m_pMat;
            ColModel = CEntity::GetColModel(v63);
            if ( CCollision::ProcessColModels(
                   &v67,
                   &CTaskSimpleFight::m_sStrikeColModel,
                   v64,
                   ColModel,
                   CWorld::m_aTempColPts,
                   0,
                   0,
                   0) >= 1 )
              CTaskSimpleFight::FightHitCar(
                &v68,
                pPed,
                this->m_pVehicle,
                &CWorld::m_aTempColPts[0].m_vecPosition,
                &CWorld::m_aTempColPts[0].m_vecNormal,
                CWorld::m_aTempColPts[0].m_dataB.m_nPieceType,
                CWorld::m_aTempColPts[0].m_dataB.m_nSurfaceType);
            this->m_pVehicle->m_nHealth = m_nHealth;
            CAEVehicleAudioEntity::AddAudioEvent(&this->m_pVehicle->m_VehicleAudioEntity, 108, 0.0);
            CMatrix::~CMatrix(&v67);
            CTaskSimpleFight::~CTaskSimpleFight(&v68);
          }
          return this->m_pSubTask;
        }
        v49 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 200.0);
        if ( v49 < 167 )
        {
          if ( v49 < 134 )
          {
            if ( v49 < 101 )
            {
              if ( v49 < 71 )
              {
                if ( v49 < 61 )
                {
                  if ( v49 < 41 )
                    return this->m_pSubTask;
                  goto LABEL_97;
                }
                if ( CPed::IsPlayingHandSignal(pPed) )
                  return this->m_pSubTask;
                v50 = pPed->m_pPedIntelligence;
                v51 = (CTaskComplexPlayHandSignalAnim *)CTask::operator new(0x18u);
                CTaskComplexPlayHandSignalAnim::CTaskComplexPlayHandSignalAnim(v51, (const AnimationId)-1, 4.0);
              }
              else
              {
                v50 = pPed->m_pPedIntelligence;
                v51 = (CTaskComplexPlayHandSignalAnim *)CTask::operator new(0x20u);
                v57 = rand();
                CTaskSimpleRunAnim::CTaskSimpleRunAnim(
                  (CTaskSimpleRunAnim *)v51,
                  ANIM_GANG_PED,
                  (const AnimationId)((int)(float)((float)((float)v57 * 0.000015259) * 8.0) + 279),
                  4.0,
                  0);
              }
            }
            else
            {
              v50 = pPed->m_pPedIntelligence;
              v51 = (CTaskComplexPlayHandSignalAnim *)CTask::operator new(0x20u);
              CTaskSimpleRunAnim::CTaskSimpleRunAnim(
                (CTaskSimpleRunAnim *)v51,
                ANIM_GANG_PED,
                ANIM_GANG_KICK_CAR,
                4.0,
                0);
            }
          }
          else
          {
            v50 = pPed->m_pPedIntelligence;
            v51 = (CTaskComplexPlayHandSignalAnim *)CTask::operator new(0x20u);
            CTaskSimpleRunAnim::CTaskSimpleRunAnim(
              (CTaskSimpleRunAnim *)v51,
              ANIM_GANG_PED,
              ANIM_GANG_BARGE_CAR,
              4.0,
              0);
          }
        }
        else
        {
          v50 = pPed->m_pPedIntelligence;
          v51 = (CTaskComplexPlayHandSignalAnim *)CTask::operator new(0x20u);
          CTaskSimpleRunAnim::CTaskSimpleRunAnim((CTaskSimpleRunAnim *)v51, ANIM_GANG_PED, ANIM_GANG_SHAKE_CAR, 4.0, 0);
        }
        CTaskManager::SetTaskSecondary(&v50->m_taskManager, v51, 4);
        return this->m_pSubTask;
      }
      v41 = 254;
    }
    CPed::Say(pPed, v41, 0, 1.0, 0, 0, 0);
    goto LABEL_82;
  }
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 1000 )
    return this->m_pSubTask;
  v13 = CTask::operator new(0x38u);
  CTaskComplexKillPedOnFoot::CTaskComplexKillPedOnFoot(
    (CTaskComplexKillPedOnFoot *)v13,
    this->m_pDriver,
    -1,
    0,
    0,
    0,
    1);
  return (CTask *)v13;
}
// 5191A2: variable 'v43' is possibly undefined
// 66BE94: using guessed type void *off_66BE94;

//----- (00519300) --------------------------------------------------------
float __fastcall CTaskGangHassleVehicle::GetTargetHeading(CTaskGangHassleVehicle *this, CPed *pPed)
{
  __int64 v2; // kr00_8
  float32x2_t *v3; // r1
  float32x2_t v4; // d0
  float RadianAngleBetweenPoints; // r0

  v2 = *(_QWORD *)&this->m_pVehicle;
  v3 = *(float32x2_t **)(v2 + 20);
  v4.n64_u64[0] = v3->n64_u64[0];
  switch ( HIDWORD(v2) )
  {
    case 1:
    case 3:
      v4.n64_u64[0] = vneg_f32(v4).n64_u64[0];
      break;
    case 4:
      v4.n64_u64[0] = v3[2].n64_u64[0];
      break;
    case 5:
      v4.n64_u64[0] = vneg_f32(v3[2]).n64_u64[0];
      break;
    default:
      break;
  }
  RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(v4.n64_f32[0], v4.n64_f32[1], 0.0, 0.0);
  return sub_192588(RadianAngleBetweenPoints);
}

//----- (0051934C) --------------------------------------------------------
void __fastcall CTaskGangHasslePed::CTaskGangHasslePed(
        CTaskGangHasslePed *this,
        CPed *pPed,
        int32 hassleType,
        int32 minTime,
        int32 maxTime)
{
  CTaskComplex::CTaskComplex(this);
  *(_WORD *)&this->m_timer.m_bIsActive = 0;
  this->m_hassleType = hassleType;
  this->m_hassleTimeMin = minTime;
  this->m_hassleTimeMax = maxTime;
  this->m_animsReferenced = 0;
  this->m_timer.m_iStartTime = 0;
  this->m_timer.m_iDuration = 0;
  this->_vptr$CTask = (int (**)(void))&off_66BE94;
  this->m_pPed = pPed;
  if ( pPed )
    CEntity::RegisterReference(pPed, &this->m_pPed);
}
// 66BE94: using guessed type void *;

//----- (0051939C) --------------------------------------------------------
void __fastcall CTaskGangHasslePed::~CTaskGangHasslePed(CTaskGangHasslePed *this)
{
  CPed *m_pPed; // r0
  CEntity **p_m_pPed; // r1
  int32 AnimationBlockIndex; // r0

  p_m_pPed = &this->m_pPed;
  m_pPed = this->m_pPed;
  this->_vptr$CTask = (int (**)(void))&off_66BE94;
  if ( m_pPed )
    CEntity::CleanUpOldReference(m_pPed, p_m_pPed);
  if ( this->m_animsReferenced )
  {
    AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("gangs");
    CAnimManager::RemoveAnimBlockRef(AnimationBlockIndex);
    this->m_animsReferenced = 0;
  }
  sub_18EDB4(this);
}
// 66BE94: using guessed type void *off_66BE94;

//----- (005193E0) --------------------------------------------------------
void __fastcall CTaskGangHasslePed::~CTaskGangHasslePed(CTaskGangHasslePed *this)
{
  CPed *m_pPed; // r0
  CEntity **p_m_pPed; // r1
  int32 AnimationBlockIndex; // r0
  void *v5; // r0

  p_m_pPed = &this->m_pPed;
  m_pPed = this->m_pPed;
  this->_vptr$CTask = (int (**)(void))&off_66BE94;
  if ( m_pPed )
    CEntity::CleanUpOldReference(m_pPed, p_m_pPed);
  if ( this->m_animsReferenced )
  {
    AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("gangs");
    CAnimManager::RemoveAnimBlockRef(AnimationBlockIndex);
    this->m_animsReferenced = 0;
  }
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v5);
}
// 51941C: variable 'v5' is possibly undefined
// 66BE94: using guessed type void *off_66BE94;

//----- (00519428) --------------------------------------------------------
CTask *__fastcall CTaskGangHasslePed::CreateNextSubTask(CTaskGangHasslePed *this, CPed *pPed)
{
  int v3; // r8
  void *v4; // r4
  CPed *m_pPed; // r5
  __int64 v6; // r2

  v3 = rand();
  v4 = 0;
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 1000 )
  {
    v4 = CTask::operator new(0x4Cu);
    m_pPed = this->m_pPed;
    CTaskComplex::CTaskComplex((CTaskComplex *)v4);
    LODWORD(v6) = "List_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly";
    HIDWORD(v6) = 1000;
    *((_QWORD *)v4 + 2) = v6;
    *((_DWORD *)v4 + 7) = 0x40000000;
    *((_DWORD *)v4 + 8) = 0;
    *((_DWORD *)v4 + 9) = 0x40000000;
    *((_WORD *)v4 + 24) = 0;
    *((_WORD *)v4 + 30) = 0;
    *((_DWORD *)v4 + 10) = 0;
    *((_DWORD *)v4 + 11) = 0;
    *((_DWORD *)v4 + 13) = 0;
    *((_DWORD *)v4 + 14) = 0;
    BYTE4(v6) = *((_BYTE *)v4 + 72);
    *(_DWORD *)v4 = &off_6656D4;
    *((_DWORD *)v4 + 16) = &off_665710;
    *((_DWORD *)v4 + 17) = 6;
    *((_BYTE *)v4 + 72) = BYTE4(v6) & 0xF0 | 2;
    *((float *)v4 + 6) = (float)((float)((float)v3 * 4.6566e-10) + (float)((float)v3 * 4.6566e-10)) + 3.0;
    *((_DWORD *)v4 + 3) = m_pPed;
    if ( m_pPed )
      CEntity::RegisterReference(m_pPed, (CEntity **)v4 + 3);
  }
  return (CTask *)v4;
}
// 6656D4: using guessed type void *off_6656D4;
// 665710: using guessed type void *off_665710;

//----- (005194F4) --------------------------------------------------------
CTask *__fastcall CTaskGangHasslePed::CreateFirstSubTask(CTaskGangHasslePed *this, CPed *pPed)
{
  int v3; // r0
  __int64 v4; // kr00_8
  int v5; // r8
  int v6; // r4
  unsigned __int16 v7; // r0
  void *v8; // r4
  CPed *m_pPed; // r5
  char v10; // r1

  if ( !this->m_pPed )
    return 0;
  v3 = rand();
  v4 = *(_QWORD *)&this->m_hassleTimeMin;
  v5 = v3;
  v6 = CTimer::m_snTimeInMilliseconds;
  v7 = rand();
  this->m_timer.m_iStartTime = v6;
  this->m_timer.m_bIsActive = 1;
  this->m_timer.m_iDuration = (int)(float)((float)((float)v7 * 0.000015259) * (float)(HIDWORD(v4) - v4)) + v4;
  v8 = CTask::operator new(0x4Cu);
  m_pPed = this->m_pPed;
  CTaskComplex::CTaskComplex((CTaskComplex *)v8);
  *(_DWORD *)v8 = &off_6656D4;
  *((_DWORD *)v8 + 4) = "List_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly";
  *((_DWORD *)v8 + 5) = 1000;
  *((float *)v8 + 6) = (float)((float)((float)v5 * 4.6566e-10) + (float)((float)v5 * 4.6566e-10)) + 3.0;
  *((_DWORD *)v8 + 7) = 0x40000000;
  *((_DWORD *)v8 + 8) = 0;
  *((_DWORD *)v8 + 9) = 0x40000000;
  *((_WORD *)v8 + 24) = 0;
  *((_WORD *)v8 + 30) = 0;
  *((_DWORD *)v8 + 10) = 0;
  *((_DWORD *)v8 + 11) = 0;
  *((_DWORD *)v8 + 13) = 0;
  *((_DWORD *)v8 + 14) = 0;
  v10 = *((_BYTE *)v8 + 72);
  *((_DWORD *)v8 + 16) = &off_665710;
  *((_DWORD *)v8 + 17) = 6;
  *((_BYTE *)v8 + 72) = v10 & 0xF0 | 2;
  *((_DWORD *)v8 + 3) = m_pPed;
  if ( m_pPed )
    CEntity::RegisterReference(m_pPed, (CEntity **)v8 + 3);
  return (CTask *)v8;
}
// 6656D4: using guessed type void *off_6656D4;
// 665710: using guessed type void *off_665710;

//----- (0051960C) --------------------------------------------------------
CTask *__fastcall CTaskGangHasslePed::ControlSubTask(CTaskGangHasslePed *this, CPed *pPed)
{
  unsigned int v4; // r0
  int m_iStartTime; // r1
  int32 m_hassleType; // r0
  int m_animsReferenced; // r6
  CPlayerPed *v8; // r1
  float *m_pMyVehicle; // r0
  bool v10; // zf
  _BOOL4 v11; // r0
  int32 v12; // r0
  CTask *result; // r0
  int32 AnimationBlockIndex; // r0
  int v15; // r0
  CPedIntelligence *m_pPedIntelligence; // r8
  CTaskSimpleRunAnim *v17; // r6
  unsigned __int16 v18; // r0
  CTaskComplexKillPedOnFoot *v19; // r0
  int32 v20; // r0

  if ( !this->m_pPed )
    return 0;
  if ( !this->m_timer.m_bIsActive )
    goto LABEL_10;
  if ( this->m_timer.m_bIsStopped )
  {
    v4 = CTimer::m_snTimeInMilliseconds;
    this->m_timer.m_bIsStopped = 0;
    this->m_timer.m_iStartTime = v4;
    m_iStartTime = v4;
  }
  else
  {
    m_iStartTime = this->m_timer.m_iStartTime;
    v4 = CTimer::m_snTimeInMilliseconds;
  }
  if ( m_iStartTime + this->m_timer.m_iDuration > v4 )
    goto LABEL_10;
  m_hassleType = this->m_hassleType;
  if ( m_hassleType == 1 )
    goto LABEL_10;
  if ( m_hassleType != 2 )
    return 0;
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 1000 )
  {
    v19 = (CTaskComplexKillPedOnFoot *)CTask::operator new(0x38u);
    CTaskComplexKillPedOnFoot::CTaskComplexKillPedOnFoot(v19, this->m_pPed, -1, 0, 0, 0, 1);
    return result;
  }
LABEL_10:
  m_animsReferenced = this->m_animsReferenced;
  v8 = CWorld::Players[CWorld::PlayerInFocus].pPed;
  m_pMyVehicle = (float *)v8->m_pMyVehicle;
  v10 = m_pMyVehicle == 0;
  if ( m_pMyVehicle )
    v10 = (*(_DWORD *)&v8->m_nPedFlags & 0x100) == 0;
  if ( !v10
    && (float)((float)((float)(m_pMyVehicle[18] * m_pMyVehicle[18]) + (float)(m_pMyVehicle[19] * m_pMyVehicle[19]))
             + (float)(m_pMyVehicle[20] * m_pMyVehicle[20])) > 0.04 )
  {
    v11 = 0;
    if ( !this->m_animsReferenced )
      goto LABEL_15;
LABEL_20:
    if ( !v11 )
    {
      AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("gangs");
      CAnimManager::RemoveAnimBlockRef(AnimationBlockIndex);
      this->m_animsReferenced = 0;
      goto LABEL_32;
    }
    goto LABEL_23;
  }
  v11 = !CStreaming::IsVeryBusy();
  if ( m_animsReferenced )
    goto LABEL_20;
LABEL_15:
  if ( !v11 )
    goto LABEL_23;
  v12 = CAnimManager::GetAnimationBlockIndex("gangs");
  if ( !CAnimManager::ms_aAnimBlocks[v12].m_loaded )
  {
    CStreaming::RequestModel(v12 + 25575, 8);
LABEL_23:
    if ( !this->m_animsReferenced )
      goto LABEL_32;
    goto LABEL_24;
  }
  CAnimManager::AddAnimBlockRef(v12);
  this->m_animsReferenced = 1;
LABEL_24:
  if ( !CPed::IsPlayingHandSignal(pPed) && !CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 4) )
  {
    v15 = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 200.0);
    if ( (unsigned int)(v15 - 51) <= 4 )
    {
      m_pPedIntelligence = pPed->m_pPedIntelligence;
      v17 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
      v18 = rand();
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        v17,
        ANIM_GANG_PED,
        (const AnimationId)((int)(float)((float)((float)v18 * 0.000015259) * 8.0) + 279),
        4.0,
        0);
LABEL_31:
      CTaskManager::SetTaskSecondary(&m_pPedIntelligence->m_taskManager, v17, 4);
      goto LABEL_32;
    }
    if ( v15 == 100 )
    {
      m_pPedIntelligence = pPed->m_pPedIntelligence;
      v17 = (CTaskSimpleRunAnim *)CTask::operator new(0x18u);
      CTaskComplexPlayHandSignalAnim::CTaskComplexPlayHandSignalAnim(
        (CTaskComplexPlayHandSignalAnim *)v17,
        (const AnimationId)-1,
        4.0);
      goto LABEL_31;
    }
  }
LABEL_32:
  v20 = this->m_hassleType;
  if ( (unsigned int)(v20 - 1) >= 2 )
  {
    if ( !v20 )
      CPed::Say(pPed, 0x56u, 0, 1.0, 0, 0, 0);
  }
  else
  {
    CTaskComplexGangLeader::DoGangAbuseSpeech(pPed, this->m_pPed);
  }
  return this->m_pSubTask;
}

//----- (0051985C) --------------------------------------------------------
void __fastcall CTaskComplexStareAtPed::CTaskComplexStareAtPed(
        CTaskComplexStareAtPed *this,
        CPedGroup *pPedGroup,
        CPed *pPed,
        int32 timeout)
{
  _BOOL4 v8; // r0
  CPed **p_m_pPed; // r1

  CTaskComplex::CTaskComplex(this);
  *(_WORD *)&this->m_timer.m_bIsActive = 0;
  this->m_pPedGroup = pPedGroup;
  this->m_timer.m_iStartTime = 0;
  this->m_timer.m_iDuration = 0;
  this->_vptr$CTask = (int (**)(void))&off_66BED0;
  v8 = IsEntityPointerValid(pPed);
  p_m_pPed = &this->m_pPed;
  if ( v8 )
  {
    *p_m_pPed = pPed;
    CEntity::RegisterReference(pPed, p_m_pPed);
  }
  else
  {
    *p_m_pPed = 0;
  }
  this->m_timeout = timeout;
  *(_WORD *)&this->m_lookInitialised = 0;
}
// 66BED0: using guessed type void *;

//----- (005198B8) --------------------------------------------------------
void __fastcall CTaskComplexStareAtPed::~CTaskComplexStareAtPed(CTaskComplexStareAtPed *this)
{
  CPed *m_pPed; // r0
  CEntity **p_m_pPed; // r1
  int32 AnimationBlockIndex; // r0

  p_m_pPed = &this->m_pPed;
  m_pPed = this->m_pPed;
  this->_vptr$CTask = (int (**)(void))&off_66BED0;
  if ( m_pPed )
    CEntity::CleanUpOldReference(m_pPed, p_m_pPed);
  if ( this->m_animsReferenced )
  {
    AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("gangs");
    CAnimManager::RemoveAnimBlockRef(AnimationBlockIndex);
    this->m_animsReferenced = 0;
  }
  sub_18EDB4(this);
}
// 66BED0: using guessed type void *off_66BED0;

//----- (00519900) --------------------------------------------------------
void __fastcall CTaskComplexStareAtPed::~CTaskComplexStareAtPed(CTaskComplexStareAtPed *this)
{
  CPed *m_pPed; // r0
  CEntity **p_m_pPed; // r1
  int32 AnimationBlockIndex; // r0
  void *v5; // r0

  p_m_pPed = &this->m_pPed;
  m_pPed = this->m_pPed;
  this->_vptr$CTask = (int (**)(void))&off_66BED0;
  if ( m_pPed )
    CEntity::CleanUpOldReference(m_pPed, p_m_pPed);
  if ( this->m_animsReferenced )
  {
    AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("gangs");
    CAnimManager::RemoveAnimBlockRef(AnimationBlockIndex);
    this->m_animsReferenced = 0;
  }
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v5);
}
// 519940: variable 'v5' is possibly undefined
// 66BED0: using guessed type void *off_66BED0;

//----- (0051994C) --------------------------------------------------------
CTask *__fastcall CTaskComplexStareAtPed::Clone(const CTaskComplexStareAtPed *this)
{
  int32 m_timeout; // r8
  char *v3; // r4
  __int64 v4; // kr00_8
  _BOOL4 v5; // r0
  CEntity **v6; // r1

  if ( this->m_timer.m_bIsActive )
    m_timeout = this->m_timer.m_iStartTime + this->m_timer.m_iDuration - CTimer::m_snTimeInMilliseconds;
  else
    m_timeout = this->m_timeout;
  v3 = (char *)CTask::operator new(0x28u);
  v4 = *(_QWORD *)&this->m_pPedGroup;
  CTaskComplex::CTaskComplex((CTaskComplex *)v3);
  *((_WORD *)v3 + 16) = 0;
  *((_DWORD *)v3 + 3) = v4;
  *((_DWORD *)v3 + 6) = 0;
  *((_DWORD *)v3 + 7) = 0;
  *(_DWORD *)v3 = &off_66BED0;
  v5 = IsEntityPointerValid((CEntity *)HIDWORD(v4));
  v6 = (CEntity **)(v3 + 16);
  if ( v5 )
  {
    *v6 = (CEntity *)HIDWORD(v4);
    CEntity::RegisterReference((CEntity *)HIDWORD(v4), v6);
  }
  else
  {
    *v6 = 0;
  }
  *((_DWORD *)v3 + 5) = m_timeout;
  *((_WORD *)v3 + 18) = 0;
  return (CTask *)v3;
}
// 66BED0: using guessed type void *off_66BED0;

//----- (005199D0) --------------------------------------------------------
CTask *__fastcall CTaskComplexStareAtPed::CreateNextSubTask(CTaskComplexStareAtPed *this, CPed *pPed)
{
  float v3; // s16
  CTaskSimpleStandStill *v4; // r0
  CTask *result; // r0
  CTaskComplexTurnToFaceEntityOrCoord *v6; // r0

  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 920 )
  {
    v3 = (float)((float)(unsigned __int16)rand() * 0.000015259) * 1000.0;
    v4 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill(v4, (int)v3 + 500, 0, 0, 8.0);
  }
  else
  {
    v6 = (CTaskComplexTurnToFaceEntityOrCoord *)CTask::operator new(0x28u);
    CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(v6, this->m_pPed, 0.5, 0.2);
  }
  return result;
}

//----- (00519A64) --------------------------------------------------------
CTask *__fastcall CTaskComplexStareAtPed::CreateFirstSubTask(CTaskComplexStareAtPed *this, CPed *pPed)
{
  int m_timeout; // r2
  int v3; // r1
  float v4; // s16
  CTaskSimpleStandStill *v5; // r0
  CTask *result; // r0

  m_timeout = this->m_timeout;
  v3 = CTimer::m_snTimeInMilliseconds;
  this->m_timer.m_bIsActive = 1;
  this->m_timer.m_iStartTime = v3;
  this->m_timer.m_iDuration = m_timeout;
  v4 = (float)((float)(unsigned __int16)rand() * 0.000015259) * 1000.0;
  v5 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
  CTaskSimpleStandStill::CTaskSimpleStandStill(v5, (int)v4 + 500, 0, 0, 8.0);
  return result;
}

//----- (00519AD4) --------------------------------------------------------
CTask *__fastcall CTaskComplexStareAtPed::ControlSubTask(CTaskComplexStareAtPed *this, CPed *pPed)
{
  unsigned int v4; // r0
  int m_iStartTime; // r1
  _BOOL4 v6; // r6
  int m_animsReferenced; // r5
  CPlayerPed *v8; // r1
  float *m_pMyVehicle; // r0
  bool v10; // zf
  _BOOL4 v11; // r0
  int32 AnimationBlockIndex; // r0
  bool8 v13; // r0
  int32 v14; // r0
  CPed *m_pPed; // r1
  CEntity *LookAtEntity; // r0
  CPed *v17; // r3
  char *m_pPedGroup; // r0
  bool v19; // zf
  __int64 v20; // kr00_8
  int v21; // r6
  CPed *Leader; // r0
  CMatrix *m_pMat; // r1
  int v24; // r2
  CSimpleTransform *p_tx; // r3
  float32x2_t v26; // d16
  unsigned __int64 v27; // d1
  CPedIntelligence *m_pPedIntelligence; // r6
  CTaskSimpleRunAnim *v30; // r5
  unsigned __int16 v31; // r0

  if ( this->m_timer.m_bIsActive )
  {
    if ( this->m_timer.m_bIsStopped )
    {
      v4 = CTimer::m_snTimeInMilliseconds;
      this->m_timer.m_bIsStopped = 0;
      this->m_timer.m_iStartTime = v4;
      m_iStartTime = v4;
    }
    else
    {
      m_iStartTime = this->m_timer.m_iStartTime;
      v4 = CTimer::m_snTimeInMilliseconds;
    }
    v6 = m_iStartTime + this->m_timer.m_iDuration <= v4;
  }
  else
  {
    v6 = 0;
  }
  m_animsReferenced = this->m_animsReferenced;
  v8 = CWorld::Players[CWorld::PlayerInFocus].pPed;
  m_pMyVehicle = (float *)v8->m_pMyVehicle;
  v10 = m_pMyVehicle == 0;
  if ( m_pMyVehicle )
    v10 = (*(_DWORD *)&v8->m_nPedFlags & 0x100) == 0;
  if ( v10
    || (float)((float)((float)(m_pMyVehicle[18] * m_pMyVehicle[18]) + (float)(m_pMyVehicle[19] * m_pMyVehicle[19]))
             + (float)(m_pMyVehicle[20] * m_pMyVehicle[20])) <= 0.04 )
  {
    v11 = !CStreaming::IsVeryBusy();
    if ( !m_animsReferenced )
    {
LABEL_12:
      if ( v11 )
      {
        AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("gangs");
        if ( !CAnimManager::ms_aAnimBlocks[AnimationBlockIndex].m_loaded )
        {
          CStreaming::RequestModel(AnimationBlockIndex + 25575, 8);
          goto LABEL_19;
        }
        CAnimManager::AddAnimBlockRef(AnimationBlockIndex);
        v13 = 1;
        goto LABEL_18;
      }
      goto LABEL_19;
    }
  }
  else
  {
    v11 = 0;
    if ( !this->m_animsReferenced )
      goto LABEL_12;
  }
  if ( !v11 )
  {
    v14 = CAnimManager::GetAnimationBlockIndex("gangs");
    CAnimManager::RemoveAnimBlockRef(v14);
    v13 = 0;
LABEL_18:
    this->m_animsReferenced = v13;
  }
LABEL_19:
  m_pPed = this->m_pPed;
  if ( m_pPed == 0 || v6 )
    goto LABEL_44;
  CTaskComplexGangLeader::DoGangAbuseSpeech(pPed, m_pPed);
  if ( this->m_lookInitialised )
  {
    LookAtEntity = IKChainManager_c::GetLookAtEntity(&g_ikChainMan, pPed);
    v17 = this->m_pPed;
    if ( LookAtEntity != v17 )
      IKChainManager_c::LookAt(&g_ikChainMan, "TaskStareAtPed", pPed, v17, 9999999, 5, 0, 1, 0.15, 500, 3, 0);
  }
  else
  {
    IKChainManager_c::LookAt(&g_ikChainMan, "TaskStareAtPed", pPed, this->m_pPed, 9999999, 5, 0, 1, 0.15, 500, 3, 0);
    this->m_lookInitialised = 1;
  }
  if ( !this->m_animsReferenced )
    goto LABEL_44;
  m_pPedGroup = (char *)this->m_pPed;
  v19 = m_pPedGroup == 0;
  if ( m_pPedGroup )
  {
    m_pPedGroup = (char *)this->m_pPedGroup;
    v19 = m_pPedGroup == 0;
  }
  if ( v19 || !CPedGroupMembership::GetLeader((const CPedGroupMembership *)(m_pPedGroup + 8)) )
    goto LABEL_44;
  v20 = *(_QWORD *)&this->m_pPedGroup;
  v21 = *(_DWORD *)(HIDWORD(v20) + 20);
  Leader = CPedGroupMembership::GetLeader((const CPedGroupMembership *)(v20 + 8));
  m_pMat = Leader->m_pMat;
  v24 = v21 + 48;
  if ( !v21 )
    v24 = HIDWORD(v20) + 4;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &Leader->m_transform;
  v26.n64_u64[0] = vsub_f32(*(float32x2_t *)(v24 + 4), *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
  v27 = vmul_f32(v26, v26).n64_u64[0];
  if ( (float)((float)((float)((float)(*(float *)v24 - p_tx->m_translate.x)
                             * (float)(*(float *)v24 - p_tx->m_translate.x))
                     + *(float *)&v27)
             + *((float *)&v27 + 1)) <= 64.0 )
  {
    if ( !CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 4)
      && (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) == 50 )
    {
      m_pPedIntelligence = pPed->m_pPedIntelligence;
      v30 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
      v31 = rand();
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        v30,
        ANIM_GANG_PED,
        (const AnimationId)((int)(float)((float)((float)v31 * 0.000015259) * 8.0) + 279),
        4.0,
        0);
      CTaskManager::SetTaskSecondary(&m_pPedIntelligence->m_taskManager, v30, 4);
    }
    return this->m_pSubTask;
  }
  else
  {
LABEL_44:
    if ( IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
      IKChainManager_c::AbortLookAt(&g_ikChainMan, pPed, 500);
    return 0;
  }
}

//----- (00519DF8) --------------------------------------------------------
void __fastcall CTaskSimpleDoHandSignal::CTaskSimpleDoHandSignal(CTaskSimpleDoHandSignal *this)
{
  int v1; // r0

  CTaskSimple::CTaskSimple(this);
  *(_BYTE *)(v1 + 8) = 0;
  *(_DWORD *)v1 = &off_66BF0C;
}
// 519E04: variable 'v1' is possibly undefined
// 66BF0C: using guessed type void *off_66BF0C;

//----- (00519E18) --------------------------------------------------------
void __fastcall CTaskSimpleDoHandSignal::~CTaskSimpleDoHandSignal(CTaskSimpleDoHandSignal *this)
{
  void *v1; // r0

  CTask::~CTask(this);
  sub_197118(v1);
}
// 519E24: variable 'v1' is possibly undefined

//----- (00519E28) --------------------------------------------------------
CTask *__fastcall CTaskSimpleDoHandSignal::Clone(const CTaskSimpleDoHandSignal *this)
{
  CTaskSimple *v2; // r0
  CTask *result; // r0

  v2 = (CTaskSimple *)CTask::operator new(0xCu);
  CTaskSimple::CTaskSimple(v2);
  LOBYTE(result[1]._vptr$CTask) = 0;
  result->_vptr$CTask = (int (**)(void))&off_66BF0C;
  LOBYTE(result[1]._vptr$CTask) = this->m_initialised;
  return result;
}
// 519E3C: variable 'result' is possibly undefined
// 66BF0C: using guessed type void *;

//----- (00519E50) --------------------------------------------------------
bool __fastcall CTaskSimpleDoHandSignal::MakeAbortable(
        CTaskSimpleDoHandSignal *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 1;
}

//----- (00519E54) --------------------------------------------------------
bool __fastcall CTaskSimpleDoHandSignal::ProcessPed(CTaskSimpleDoHandSignal *this, CPed *pPed)
{
  CTask *TaskSecondary; // r6
  CPedIntelligence *m_pPedIntelligence; // r6
  CTaskComplexPlayHandSignalAnim *v7; // r5

  if ( !CEntity::GetIsOnScreen(pPed) )
    return 1;
  TaskSecondary = CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 4);
  if ( this->m_initialised )
    return !TaskSecondary || (*((int (__fastcall **)(CTask *))TaskSecondary->_vptr$CTask + 5))(TaskSecondary) != 426;
  if ( TaskSecondary )
  {
    if ( (*((int (__fastcall **)(CTask *))TaskSecondary->_vptr$CTask + 5))(TaskSecondary) == 426 )
      return 1;
    (*((void (__fastcall **)(CTask *, CPed *, int, _DWORD))TaskSecondary->_vptr$CTask + 7))(TaskSecondary, pPed, 1, 0);
  }
  else
  {
    m_pPedIntelligence = pPed->m_pPedIntelligence;
    v7 = (CTaskComplexPlayHandSignalAnim *)CTask::operator new(0x18u);
    CTaskComplexPlayHandSignalAnim::CTaskComplexPlayHandSignalAnim(v7, (const AnimationId)-1, 4.0);
    CTaskManager::SetTaskSecondary(&m_pPedIntelligence->m_taskManager, v7, 4);
    this->m_initialised = 1;
  }
  return 0;
}

//----- (00519EE4) --------------------------------------------------------
void __fastcall CTaskComplexSignalAtPed::CTaskComplexSignalAtPed(
        CTaskComplexSignalAtPed *this,
        CPed *pPed,
        int32 initialPause,
        bool8 playAnimAtEnd)
{
  CTaskComplex::CTaskComplex(this);
  this->m_initialPause = 0;
  this->m_playAnimAtEnd = playAnimAtEnd;
  this->m_animsReferenced = 0;
  this->_vptr$CTask = (int (**)(void))&off_66BF40;
  this->m_pPed = pPed;
  if ( pPed )
    CEntity::RegisterReference(pPed, &this->m_pPed);
}
// 66BF40: using guessed type void *;

//----- (00519F28) --------------------------------------------------------
void __fastcall CTaskComplexSignalAtPed::~CTaskComplexSignalAtPed(CTaskComplexSignalAtPed *this)
{
  int m_animsReferenced; // r1
  int32 AnimationBlockIndex; // r0
  CPed *m_pPed; // r0

  m_animsReferenced = this->m_animsReferenced;
  this->_vptr$CTask = (int (**)(void))&off_66BF40;
  if ( m_animsReferenced )
  {
    AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("gangs");
    CAnimManager::RemoveAnimBlockRef(AnimationBlockIndex);
    this->m_animsReferenced = 0;
  }
  m_pPed = this->m_pPed;
  if ( m_pPed )
    CEntity::CleanUpOldReference(m_pPed, &this->m_pPed);
  sub_18EDB4(this);
}
// 66BF40: using guessed type void *off_66BF40;

//----- (00519F70) --------------------------------------------------------
void __fastcall CTaskComplexSignalAtPed::~CTaskComplexSignalAtPed(CTaskComplexSignalAtPed *this)
{
  int m_animsReferenced; // r1
  int32 AnimationBlockIndex; // r0
  CPed *m_pPed; // r0
  void *v5; // r0

  m_animsReferenced = this->m_animsReferenced;
  this->_vptr$CTask = (int (**)(void))&off_66BF40;
  if ( m_animsReferenced )
  {
    AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("gangs");
    CAnimManager::RemoveAnimBlockRef(AnimationBlockIndex);
    this->m_animsReferenced = 0;
  }
  m_pPed = this->m_pPed;
  if ( m_pPed )
    CEntity::CleanUpOldReference(m_pPed, &this->m_pPed);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v5);
}
// 519FB0: variable 'v5' is possibly undefined
// 66BF40: using guessed type void *off_66BF40;

//----- (00519FBC) --------------------------------------------------------
CTask *__fastcall CTaskComplexSignalAtPed::CreateNextSubTask(CTaskComplexSignalAtPed *this, CPed *pPed)
{
  int32 m_initialPause; // r5
  CTaskSimpleStandStill *v4; // r4
  int m_playAnimAtEnd; // r0
  CTaskSimpleRunAnim *v6; // r5
  unsigned __int16 v7; // r0

  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 920 )
  {
    m_initialPause = this->m_initialPause;
    if ( m_initialPause == -1 )
      m_initialPause = (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 2000.0);
    v4 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill(v4, m_initialPause, 0, 0, 8.0);
  }
  else if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 203 )
  {
    v4 = (CTaskSimpleStandStill *)CTask::operator new(0xCu);
    CTaskSimple::CTaskSimple(v4);
    LOBYTE(v4->m_iDuration) = 0;
    v4->_vptr$CTask = (int (**)(void))&off_66BF0C;
  }
  else if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 1214
         && this->m_animsReferenced )
  {
    m_playAnimAtEnd = this->m_playAnimAtEnd;
    v4 = 0;
    if ( m_playAnimAtEnd )
    {
      v6 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
      v7 = rand();
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        v6,
        ANIM_GANG_PED,
        (const AnimationId)((int)(float)((float)((float)v7 * 0.000015259) * 8.0) + 279),
        4.0,
        0);
      return v6;
    }
  }
  else
  {
    return 0;
  }
  return v4;
}
// 66BF0C: using guessed type void *off_66BF0C;

//----- (0051A0B4) --------------------------------------------------------
CTask *__fastcall CTaskComplexSignalAtPed::CreateFirstSubTask(CTaskComplexSignalAtPed *this, CPed *pPed)
{
  CPlayerPed *v4; // r1
  float *m_pMyVehicle; // r0
  bool v6; // zf
  CTaskComplexTurnToFaceEntityOrCoord *v7; // r6

  if ( !this->m_pPed )
    return 0;
  v4 = CWorld::Players[CWorld::PlayerInFocus].pPed;
  m_pMyVehicle = (float *)v4->m_pMyVehicle;
  v6 = m_pMyVehicle == 0;
  if ( m_pMyVehicle )
    v6 = (*(_DWORD *)&v4->m_nPedFlags & 0x100) == 0;
  if ( !v6
    && (float)((float)((float)(m_pMyVehicle[18] * m_pMyVehicle[18]) + (float)(m_pMyVehicle[19] * m_pMyVehicle[19]))
             + (float)(m_pMyVehicle[20] * m_pMyVehicle[20])) > 0.04 )
  {
    return 0;
  }
  v7 = 0;
  if ( !CStreaming::IsVeryBusy() )
  {
    CPed::StopPlayingHandSignal(pPed);
    IKChainManager_c::LookAt(&g_ikChainMan, "TaskSignalAtPed", pPed, this->m_pPed, 5000, 5, 0, 1, 0.15, 500, 3, 0);
    v7 = (CTaskComplexTurnToFaceEntityOrCoord *)CTask::operator new(0x28u);
    CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(v7, this->m_pPed, 0.5, 0.2);
  }
  return v7;
}

//----- (0051A1BC) --------------------------------------------------------
CTask *__fastcall CTaskComplexSignalAtPed::ControlSubTask(CTaskComplexSignalAtPed *this, CPed *pPed)
{
  int m_animsReferenced; // r6
  CPlayerPed *v5; // r1
  float *m_pMyVehicle; // r0
  bool v7; // zf
  _BOOL4 v8; // r0
  int32 v9; // r0
  bool8 v10; // r0
  int32 AnimationBlockIndex; // r0
  CPed *m_pPed; // r0
  CMatrix *m_pMat; // r1
  CMatrix *v14; // r2
  CSimpleTransform *p_tx; // r3
  float *p_x; // r1
  float RadianAngleBetweenPoints; // r0

  m_animsReferenced = this->m_animsReferenced;
  v5 = CWorld::Players[CWorld::PlayerInFocus].pPed;
  m_pMyVehicle = (float *)v5->m_pMyVehicle;
  v7 = m_pMyVehicle == 0;
  if ( m_pMyVehicle )
    v7 = (*(_DWORD *)&v5->m_nPedFlags & 0x100) == 0;
  if ( !v7
    && (float)((float)((float)(m_pMyVehicle[18] * m_pMyVehicle[18]) + (float)(m_pMyVehicle[19] * m_pMyVehicle[19]))
             + (float)(m_pMyVehicle[20] * m_pMyVehicle[20])) > 0.04 )
  {
    v8 = 0;
    if ( !m_animsReferenced )
      goto LABEL_6;
LABEL_10:
    if ( v8 )
      goto LABEL_14;
    AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("gangs");
    CAnimManager::RemoveAnimBlockRef(AnimationBlockIndex);
    v10 = 0;
    goto LABEL_12;
  }
  v8 = !CStreaming::IsVeryBusy();
  if ( m_animsReferenced )
    goto LABEL_10;
LABEL_6:
  if ( !v8 )
    goto LABEL_14;
  v9 = CAnimManager::GetAnimationBlockIndex("gangs");
  if ( CAnimManager::ms_aAnimBlocks[v9].m_loaded )
  {
    CAnimManager::AddAnimBlockRef(v9);
    v10 = 1;
LABEL_12:
    this->m_animsReferenced = v10;
    goto LABEL_14;
  }
  CStreaming::RequestModel(v9 + 25575, 8);
LABEL_14:
  m_pPed = this->m_pPed;
  if ( m_pPed )
  {
    m_pMat = pPed->m_pMat;
    v14 = m_pPed->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pPed->m_transform;
    p_x = &v14->tx;
    if ( !v14 )
      p_x = &m_pPed->m_transform.m_translate.x;
    RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                                 *p_x - p_tx->m_translate.x,
                                 p_x[1] - p_tx->m_translate.y,
                                 0.0,
                                 0.0);
    pPed->m_fDesiredHeading = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
  }
  return this->m_pSubTask;
}

//----- (0051A2E4) --------------------------------------------------------
void __fastcall CTaskGoToVehicleAndLean::CTaskGoToVehicleAndLean(
        CTaskGoToVehicleAndLean *this,
        CVehicle *pVehicle,
        int32 time)
{
  CTaskComplex::CTaskComplex(this);
  this->m_time = time;
  this->m_animsReferenced = 0;
  this->_vptr$CTask = (int (**)(void))&off_66BF7C;
  this->m_pVehicle = pVehicle;
  if ( pVehicle )
    CEntity::RegisterReference(pVehicle, &this->m_pVehicle);
}
// 66BF7C: using guessed type void *;

//----- (0051A324) --------------------------------------------------------
void __fastcall CTaskGoToVehicleAndLean::~CTaskGoToVehicleAndLean(CTaskGoToVehicleAndLean *this)
{
  int m_animsReferenced; // r1
  int32 AnimationBlockIndex; // r0
  CVehicle *m_pVehicle; // r0

  m_animsReferenced = this->m_animsReferenced;
  this->_vptr$CTask = (int (**)(void))&off_66BF7C;
  if ( m_animsReferenced )
  {
    AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("gangs");
    CAnimManager::RemoveAnimBlockRef(AnimationBlockIndex);
    this->m_animsReferenced = 0;
  }
  m_pVehicle = this->m_pVehicle;
  if ( m_pVehicle )
    CEntity::CleanUpOldReference(m_pVehicle, &this->m_pVehicle);
  sub_18EDB4(this);
}
// 66BF7C: using guessed type void *off_66BF7C;

//----- (0051A36C) --------------------------------------------------------
void __fastcall CTaskGoToVehicleAndLean::~CTaskGoToVehicleAndLean(CTaskGoToVehicleAndLean *this)
{
  int m_animsReferenced; // r1
  int32 AnimationBlockIndex; // r0
  CVehicle *m_pVehicle; // r0
  void *v5; // r0

  m_animsReferenced = this->m_animsReferenced;
  this->_vptr$CTask = (int (**)(void))&off_66BF7C;
  if ( m_animsReferenced )
  {
    AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("gangs");
    CAnimManager::RemoveAnimBlockRef(AnimationBlockIndex);
    this->m_animsReferenced = 0;
  }
  m_pVehicle = this->m_pVehicle;
  if ( m_pVehicle )
    CEntity::CleanUpOldReference(m_pVehicle, &this->m_pVehicle);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v5);
}
// 51A3AC: variable 'v5' is possibly undefined
// 66BF7C: using guessed type void *off_66BF7C;

//----- (0051A3B8) --------------------------------------------------------
bool __fastcall CTaskGoToVehicleAndLean::MakeAbortable(
        CTaskGoToVehicleAndLean *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  int v7; // r0
  bool v8; // zf
  CVehicle *m_pVehicle; // r0
  CTask *m_pSubTask; // r0

  v7 = (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
        + 7))(
         this->m_pSubTask,
         pPed,
         iPriority,
         pEvent);
  v8 = iPriority == 2;
  if ( iPriority != 2 )
    v8 = v7 == 1;
  if ( !v8 )
    return 0;
  m_pVehicle = this->m_pVehicle;
  if ( m_pVehicle )
    *((_DWORD *)&m_pVehicle->m_nVehicleFlags + 1) &= ~0x10000u;
  m_pSubTask = this->m_pSubTask;
  if ( m_pSubTask )
    (*((void (__fastcall **)(CTask *, CPed *, int, _DWORD))m_pSubTask->_vptr$CTask + 7))(m_pSubTask, pPed, 2, 0);
  return 1;
}

//----- (0051A40A) --------------------------------------------------------
void __fastcall CTaskGoToVehicleAndLean::DoTidyUp(CTaskGoToVehicleAndLean *this, CPed *pPed)
{
  CVehicle *m_pVehicle; // r2
  CTask *m_pSubTask; // r0

  m_pVehicle = this->m_pVehicle;
  if ( m_pVehicle )
    *((_DWORD *)&m_pVehicle->m_nVehicleFlags + 1) &= ~0x10000u;
  m_pSubTask = this->m_pSubTask;
  if ( m_pSubTask )
    (*((void (__fastcall **)(CTask *, CPed *, int, _DWORD))m_pSubTask->_vptr$CTask + 7))(m_pSubTask, pPed, 2, 0);
}

//----- (0051A43C) --------------------------------------------------------
CTask *__fastcall CTaskGoToVehicleAndLean::CreateNextSubTask(CTaskGoToVehicleAndLean *this, CPed *pPed)
{
  __int64 v4; // r0
  CMatrix *m_pMat; // r0
  float yx; // s2
  float xx; // s0
  float RadianAngleBetweenPoints; // r5
  void *v9; // r4
  __int64 v10; // kr00_8
  CVehicle *m_pVehicle; // r0

  v4 = *(_QWORD *)&this->m_pSubTask;
  if ( !HIDWORD(v4) )
  {
    if ( !(_DWORD)v4 )
      return 0;
LABEL_7:
    v9 = 0;
    (*(void (__fastcall **)(_DWORD, CPed *, int, _DWORD))(*(_DWORD *)v4 + 28))(v4, pPed, 2, 0);
    return (CTask *)v9;
  }
  if ( (*(int (__fastcall **)(_DWORD))(*(_DWORD *)v4 + 20))(v4) == 903 )
  {
    m_pMat = this->m_pVehicle->m_pMat;
    yx = m_pMat->yx;
    xx = m_pMat->xx;
    if ( !this->m_onRHS )
    {
      xx = -xx;
      yx = -yx;
    }
    RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(xx, yx, 0.0, 0.0);
    CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
    v9 = CTask::operator new(0x18u);
    CTaskSimpleAchieveHeading::CTaskSimpleAchieveHeading(
      (CTaskSimpleAchieveHeading *)v9,
      RadianAngleBetweenPoints,
      0.5,
      0.2);
    return (CTask *)v9;
  }
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 902
    && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 203 )
  {
    m_pVehicle = this->m_pVehicle;
    if ( m_pVehicle )
      *((_DWORD *)&m_pVehicle->m_nVehicleFlags + 1) &= ~0x10000u;
    LODWORD(v4) = this->m_pSubTask;
    if ( !(_DWORD)v4 )
      return 0;
    goto LABEL_7;
  }
  if ( this->m_animsReferenced )
  {
    v9 = CTask::operator new(0x2Cu);
    v10 = *(_QWORD *)&this->m_pVehicle;
    CTaskSimple::CTaskSimple((CTaskSimple *)v9);
    *((_WORD *)v9 + 18) = 0;
    *((_DWORD *)v9 + 3) = HIDWORD(v10);
    *((_BYTE *)v9 + 16) = 0;
    *((_BYTE *)v9 + 40) = 0;
    *((_BYTE *)v9 + 41) = 0;
    *((_BYTE *)v9 + 42) = 0;
    *((_DWORD *)v9 + 5) = 0;
    *((_DWORD *)v9 + 6) = -1;
    *((_DWORD *)v9 + 7) = 0;
    *((_DWORD *)v9 + 8) = 0;
    *(_DWORD *)v9 = &off_66BFB8;
    *((_DWORD *)v9 + 2) = v10;
    if ( (_DWORD)v10 )
      CEntity::RegisterReference((CEntity *)v10, (CEntity **)v9 + 2);
  }
  else
  {
    v9 = CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v9, 500, 0, 0, 8.0);
  }
  return (CTask *)v9;
}
// 66BFB8: using guessed type void *;

//----- (0051A588) --------------------------------------------------------
CTask *__fastcall CTaskGoToVehicleAndLean::CreateFirstSubTask(CTaskGoToVehicleAndLean *this, CPed *pPed)
{
  CVehicle *m_pVehicle; // r0
  int v5; // r2
  int m_nVehicleFlags; // r1
  CVehicle::CVehicleFlags *p_m_nVehicleFlags; // r0
  __int64 v8; // d16
  CTask *v9; // r6
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float32x2_t v12; // d16
  unsigned __int64 v13; // d1
  CTaskComplexGoToPointAndStandStill *v14; // r0
  CTask *v15; // r0
  CTask *m_pSubTask; // r0
  CVector v18; // [sp+10h] [bp-20h] BYREF

  m_pVehicle = this->m_pVehicle;
  if ( m_pVehicle )
  {
    v5 = *((_DWORD *)&m_pVehicle->m_nVehicleFlags + 1);
    m_nVehicleFlags = (int)m_pVehicle->m_nVehicleFlags;
    p_m_nVehicleFlags = &m_pVehicle->m_nVehicleFlags;
    if ( (v5 & 0x10000) == 0 )
    {
      *(_DWORD *)p_m_nVehicleFlags = m_nVehicleFlags;
      *((_DWORD *)p_m_nVehicleFlags + 1) = v5 | 0x10000;
      CTaskGoToVehicleAndLean::CalcTargetPos(&v18, this, pPed);
      v8 = *(_QWORD *)&v18.x;
      v9 = 0;
      this->m_targetPos.z = v18.z;
      *(_QWORD *)&this->m_targetPos.x = v8;
      m_pMat = pPed->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      v12.n64_u64[0] = vsub_f32(*(float32x2_t *)&this->m_targetPos.y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
      v13 = vmul_f32(v12, v12).n64_u64[0];
      if ( (float)((float)((float)((float)(this->m_targetPos.x - p_tx->m_translate.x)
                                 * (float)(this->m_targetPos.x - p_tx->m_translate.x))
                         + *(float *)&v13)
                 + *((float *)&v13 + 1)) >= 1.0 )
      {
        v14 = (CTaskComplexGoToPointAndStandStill *)CTask::operator new(0x28u);
        CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(
          v14,
          4,
          &this->m_targetPos,
          0.05,
          2.0,
          0,
          1);
        return v15;
      }
      return v9;
    }
    *(_DWORD *)p_m_nVehicleFlags = m_nVehicleFlags;
    *((_DWORD *)p_m_nVehicleFlags + 1) = v5 & 0xFFFEFFFF;
  }
  m_pSubTask = this->m_pSubTask;
  v9 = 0;
  if ( m_pSubTask )
    (*((void (__fastcall **)(CTask *, CPed *, int, _DWORD))m_pSubTask->_vptr$CTask + 7))(m_pSubTask, pPed, 2, 0);
  return v9;
}
// 51A634: variable 'v15' is possibly undefined

//----- (0051A660) --------------------------------------------------------
CVector *__fastcall CTaskGoToVehicleAndLean::CalcTargetPos(CVector *retstr, CTaskGoToVehicleAndLean *this, CPed *pPed)
{
  CVehicle *m_pVehicle; // r4
  CColModel *m_pColModel; // r0
  float x; // s18
  float v8; // s16
  float *p_xx; // r0
  CMatrix *m_pMat; // r1
  float *p_x; // r3
  CSimpleTransform *p_tx; // r6
  float v13; // s24
  float v14; // s22
  float v15; // s20
  float v16; // s4
  float v17; // s2
  float v18; // s0
  float m_heading; // r6
  float v20; // r9
  bool8 v21; // r0
  float v22; // s6
  float v23; // s0
  CVector v; // [sp+4h] [bp-4Ch] BYREF

  m_pVehicle = this->m_pVehicle;
  m_pColModel = CModelInfo::ms_modelInfoPtrs[m_pVehicle->m_nModelIndex]->m_pColModel;
  x = m_pColModel->m_boxBound.m_vecMin.x;
  v8 = m_pColModel->m_boxBound.m_vecMax.x;
  memset(&v, 0, sizeof(v));
  p_xx = &m_pVehicle->m_pMat->xx;
  m_pMat = pPed->m_pMat;
  p_x = p_xx + 12;
  if ( !p_xx )
    p_x = &m_pVehicle->m_transform.m_translate.x;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  v13 = p_tx->m_translate.x - *p_x;
  v14 = p_tx->m_translate.y - p_x[1];
  v15 = p_tx->m_translate.z - p_x[2];
  if ( p_xx )
  {
    v16 = *p_xx;
    v17 = p_xx[1];
    v18 = p_xx[2];
  }
  else
  {
    m_heading = m_pVehicle->m_transform.m_heading;
    v20 = cosf(m_heading);
    v17 = sinf(m_heading);
    v18 = 0.0;
    v16 = v20;
  }
  v21 = 0;
  v22 = x + -0.5;
  v23 = (float)(v15 * v18) + (float)((float)(v14 * v17) + (float)(v13 * v16));
  if ( v23 > 0.0 )
    v22 = v8 + 0.5;
  v.x = v22;
  if ( v23 > 0.0 )
    v21 = 1;
  this->m_onRHS = v21;
  return operator*(retstr, m_pVehicle->m_pMat, &v);
}

//----- (0051A75C) --------------------------------------------------------
CTask *__fastcall CTaskGoToVehicleAndLean::ControlSubTask(CTaskGoToVehicleAndLean *this, CPed *pPed)
{
  CVehicle *m_pVehicle; // r1
  CMatrix *m_pMat; // r0
  CMatrix *v6; // r2
  float *p_tx; // r3
  CSimpleTransform *p_m_transform; // r0
  float v9; // s4
  float32x2_t v10; // d16
  unsigned __int64 v11; // d1
  CVehicle *v12; // r0
  CTask *m_pSubTask; // r0
  CTask *v14; // r4
  int m_animsReferenced; // r5
  CPlayerPed *v16; // r1
  float *m_pMyVehicle; // r0
  bool v18; // zf
  _BOOL4 v19; // r0
  int32 AnimationBlockIndex; // r0
  bool8 v21; // r0
  int32 v22; // r0
  CVector v24; // [sp+4h] [bp-14h] BYREF
  CVector v25; // 0:r2.8,8:^0.4

  m_pVehicle = this->m_pVehicle;
  if ( m_pVehicle )
  {
    if ( pPed->m_pPedIntelligence->m_iStaticCounter > 30 )
    {
      *((_DWORD *)&m_pVehicle->m_nVehicleFlags + 1) &= ~0x10000u;
      goto LABEL_15;
    }
    m_pMat = m_pVehicle->m_pMat;
    v6 = pPed->m_pMat;
    p_tx = &m_pMat->tx;
    if ( !m_pMat )
      p_tx = &m_pVehicle->m_transform.m_translate.x;
    p_m_transform = (CSimpleTransform *)&v6->tx;
    v9 = p_tx[2];
    if ( !v6 )
      p_m_transform = &pPed->m_transform;
    v25.x = p_m_transform->m_translate.x - *p_tx;
    v25.y = p_m_transform->m_translate.y - p_tx[1];
    v25.z = p_m_transform->m_translate.z - v9;
    CPhysical::GetSpeed(&v24, m_pVehicle, v25);
    if ( (this->m_pVehicle->pDriver
       || sqrtf((float)((float)(v24.x * v24.x) + (float)(v24.y * v24.y)) + (float)(v24.z * v24.z)) > 0.01)
      && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
           this->m_pSubTask,
           pPed,
           1,
           0) == 1
      || (CTaskGoToVehicleAndLean::CalcTargetPos(&v24, this, pPed),
          v10.n64_u64[0] = vsub_f32(*(float32x2_t *)&v24.y, *(float32x2_t *)&this->m_targetPos.y).n64_u64[0],
          v11 = vmul_f32(v10, v10).n64_u64[0],
          (float)((float)((float)((float)(v24.x - this->m_targetPos.x) * (float)(v24.x - this->m_targetPos.x))
                        + *(float *)&v11)
                + *((float *)&v11 + 1)) > 0.01)
      && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
           this->m_pSubTask,
           pPed,
           1,
           0) == 1 )
    {
      v12 = this->m_pVehicle;
      if ( v12 )
        *((_DWORD *)&v12->m_nVehicleFlags + 1) &= ~0x10000u;
      goto LABEL_15;
    }
    m_animsReferenced = this->m_animsReferenced;
    v16 = CWorld::Players[CWorld::PlayerInFocus].pPed;
    m_pMyVehicle = (float *)v16->m_pMyVehicle;
    v18 = m_pMyVehicle == 0;
    if ( m_pMyVehicle )
      v18 = (*(_DWORD *)&v16->m_nPedFlags & 0x100) == 0;
    if ( v18
      || (float)((float)((float)(m_pMyVehicle[18] * m_pMyVehicle[18]) + (float)(m_pMyVehicle[19] * m_pMyVehicle[19]))
               + (float)(m_pMyVehicle[20] * m_pMyVehicle[20])) <= 0.04 )
    {
      v19 = !CStreaming::IsVeryBusy();
      if ( !m_animsReferenced )
      {
LABEL_23:
        if ( v19 )
        {
          AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("gangs");
          if ( !CAnimManager::ms_aAnimBlocks[AnimationBlockIndex].m_loaded )
          {
            CStreaming::RequestModel(AnimationBlockIndex + 25575, 8);
            return this->m_pSubTask;
          }
          CAnimManager::AddAnimBlockRef(AnimationBlockIndex);
          v21 = 1;
          goto LABEL_29;
        }
        return this->m_pSubTask;
      }
    }
    else
    {
      v19 = 0;
      if ( !this->m_animsReferenced )
        goto LABEL_23;
    }
    if ( !v19 )
    {
      v22 = CAnimManager::GetAnimationBlockIndex("gangs");
      CAnimManager::RemoveAnimBlockRef(v22);
      v21 = 0;
LABEL_29:
      this->m_animsReferenced = v21;
    }
    return this->m_pSubTask;
  }
LABEL_15:
  m_pSubTask = this->m_pSubTask;
  v14 = 0;
  if ( m_pSubTask )
    (*((void (__fastcall **)(CTask *, CPed *, int, _DWORD))m_pSubTask->_vptr$CTask + 7))(m_pSubTask, pPed, 2, 0);
  return v14;
}

//----- (0051A988) --------------------------------------------------------
void __fastcall CTaskLeanOnVehicle::CTaskLeanOnVehicle(
        CTaskLeanOnVehicle *this,
        CEntity *pEntity,
        int32 duration,
        bool8 doInstantly)
{
  CTaskSimple::CTaskSimple(this);
  *(_WORD *)&this->m_taskTimer.m_bIsActive = 0;
  this->m_duration = duration;
  this->m_doInstantly = doInstantly;
  this->m_pAnim = 0;
  this->m_prevAnimId = -1;
  *(_WORD *)&this->m_taskFinished = 0;
  this->m_taskAborted = 0;
  this->m_taskTimer.m_iStartTime = 0;
  this->m_taskTimer.m_iDuration = 0;
  this->_vptr$CTask = (int (**)(void))&off_66BFB8;
  this->m_pEntity = pEntity;
  if ( pEntity )
    CEntity::RegisterReference(pEntity, &this->m_pEntity);
}
// 66BFB8: using guessed type void *off_66BFB8;

//----- (0051A9E0) --------------------------------------------------------
void __fastcall CTaskLeanOnVehicle::~CTaskLeanOnVehicle(CTaskLeanOnVehicle *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1
  CAnimBlendAssociation *m_pAnim; // r0

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CTask = (int (**)(void))&off_66BFB8;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetDeleteCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  sub_1A01F4(this);
}
// 66BFB8: using guessed type void *off_66BFB8;

//----- (0051AA20) --------------------------------------------------------
void __fastcall CTaskLeanOnVehicle::~CTaskLeanOnVehicle(CTaskLeanOnVehicle *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1
  CAnimBlendAssociation *m_pAnim; // r0
  void *v5; // r0

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CTask = (int (**)(void))&off_66BFB8;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    CAnimBlendAssociation::SetDeleteCallback(m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
  CTask::~CTask(this);
  sub_197118(v5);
}
// 51AA58: variable 'v5' is possibly undefined
// 66BFB8: using guessed type void *off_66BFB8;

//----- (0051AA64) --------------------------------------------------------
CTask *__fastcall CTaskLeanOnVehicle::Clone(const CTaskLeanOnVehicle *this)
{
  CTaskSimple *v2; // r0
  __int64 v3; // kr00_8
  CTaskSimple *v4; // r4

  v2 = (CTaskSimple *)CTask::operator new(0x2Cu);
  v3 = *(_QWORD *)&this->m_pEntity;
  v4 = v2;
  LOBYTE(this) = this->m_doInstantly;
  CTaskSimple::CTaskSimple(v2);
  LOWORD(v4[4].m_pParent) = 0;
  v4[1].m_pParent = (CTask *)HIDWORD(v3);
  LOBYTE(v4[2]._vptr$CTask) = (_BYTE)this;
  LOWORD(v4[5]._vptr$CTask) = 0;
  BYTE2(v4[5]._vptr$CTask) = 0;
  v4[2].m_pParent = 0;
  v4[3]._vptr$CTask = (int (**)(void))-1;
  v4[3].m_pParent = 0;
  v4[4]._vptr$CTask = 0;
  v4->_vptr$CTask = (int (**)(void))&off_66BFB8;
  v4[1]._vptr$CTask = (int (**)(void))v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)&v4[1]);
  return v4;
}
// 66BFB8: using guessed type void *off_66BFB8;

//----- (0051AAC4) --------------------------------------------------------
bool __fastcall CTaskLeanOnVehicle::MakeAbortable(
        CTaskLeanOnVehicle *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CAnimBlendAssociation *m_pAnim; // r0
  bool result; // r0

  if ( iPriority == 2 )
  {
    m_pAnim = this->m_pAnim;
    if ( m_pAnim )
    {
      m_pAnim->m_fBlendDelta = -1000.0;
      CAnimBlendAssociation::SetDeleteCallback(this->m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
      this->m_pAnim = 0;
    }
    result = 1;
    this->m_taskAborted = 1;
    pPed->m_pNOCollisionVehicle = 0;
  }
  else
  {
    this->m_taskAborting = 1;
    return 0;
  }
  return result;
}

//----- (0051AB18) --------------------------------------------------------
bool __fastcall CTaskLeanOnVehicle::ProcessPed(CTaskLeanOnVehicle *this, CPed *pPed)
{
  CEntity *m_pEntity; // r0
  CAnimBlendAssociation *m_pAnim; // r0
  int m_animId; // r6
  bool v7; // r6
  CAnimBlendAssociation *v9; // r0
  unsigned int v10; // r1
  int m_iStartTime; // r2
  AnimationId m_prevAnimId; // r0
  int v13; // r0
  int v14; // r1
  CAnimBlendAssociation *v15; // r0
  CAnimBlendAssociation *v16; // r0
  int m_duration; // r0
  int v18; // r1

  m_pEntity = this->m_pEntity;
  if ( !m_pEntity )
    this->m_taskAborted = 1;
  pPed->m_pNOCollisionVehicle = m_pEntity;
  m_pAnim = this->m_pAnim;
  if ( m_pAnim )
    m_animId = m_pAnim->m_animId;
  else
    m_animId = -1;
  if ( !this->m_taskAborted )
  {
    CPed::SetMoveState(pPed, PEDMOVE_STILL);
    if ( !this->m_taskFinished || RpAnimBlendClumpGetAssociation((RpClump_0 *)pPed->m_pRwObject, 0x131u) )
    {
      if ( this->m_taskAborting )
      {
        switch ( m_animId )
        {
          case 305:
            this->m_pAnim->m_fSpeed = 3.0;
            break;
          case 304:
            v7 = 0;
            CAnimBlendAssociation::SetDeleteCallback(this->m_pAnim, CDefaultAnimCallback::DefaultAnimCB, 0);
            v16 = CAnimManager::BlendAnimation(
                    (RpClump_0 *)pPed->m_pRwObject,
                    ANIM_GANG_PED,
                    ANIM_GANG_CARLEAN_OUT,
                    1000.0);
            goto LABEL_37;
          case 303:
            this->m_pAnim->m_fBlendDelta = -8.0;
            break;
        }
      }
      v9 = this->m_pAnim;
      if ( v9 )
      {
        if ( !this->m_taskTimer.m_bIsActive )
          return 0;
        if ( this->m_taskTimer.m_bIsStopped )
        {
          v10 = CTimer::m_snTimeInMilliseconds;
          this->m_taskTimer.m_bIsStopped = 0;
          this->m_taskTimer.m_iStartTime = v10;
          m_iStartTime = v10;
        }
        else
        {
          m_iStartTime = this->m_taskTimer.m_iStartTime;
          v10 = CTimer::m_snTimeInMilliseconds;
        }
        if ( m_iStartTime + this->m_taskTimer.m_iDuration > v10 || v9->m_animId == 305 )
          return 0;
        v7 = 0;
        CAnimBlendAssociation::SetDeleteCallback(v9, CDefaultAnimCallback::DefaultAnimCB, 0);
        v16 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_GANG_PED, ANIM_GANG_CARLEAN_OUT, 1000.0);
LABEL_37:
        this->m_pAnim = v16;
        CAnimBlendAssociation::SetFinishCallback(v16, CTaskLeanOnVehicle::FinishAnimCB, this);
        return v7;
      }
      m_prevAnimId = this->m_prevAnimId;
      if ( m_prevAnimId == ANIM_GANG_CARLEAN_IN )
      {
        m_duration = this->m_duration;
        if ( m_duration >= 0 )
        {
          v18 = CTimer::m_snTimeInMilliseconds;
          this->m_taskTimer.m_bIsActive = 1;
          this->m_taskTimer.m_iStartTime = v18;
          this->m_taskTimer.m_iDuration = m_duration;
        }
      }
      else
      {
        if ( m_prevAnimId != -1 )
          return 0;
        if ( !this->m_doInstantly )
        {
          v15 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_GANG_PED, ANIM_GANG_CARLEAN_IN, 4.0);
          goto LABEL_39;
        }
        v13 = this->m_duration;
        if ( v13 >= 0 )
        {
          v14 = CTimer::m_snTimeInMilliseconds;
          this->m_taskTimer.m_bIsActive = 1;
          this->m_taskTimer.m_iStartTime = v14;
          this->m_taskTimer.m_iDuration = v13;
        }
      }
      v15 = CAnimManager::BlendAnimation((RpClump_0 *)pPed->m_pRwObject, ANIM_GANG_PED, ANIM_GANG_CARLEAN_LOOP, 1000.0);
LABEL_39:
      this->m_pAnim = v15;
      CAnimBlendAssociation::SetFinishCallback(v15, CTaskLeanOnVehicle::FinishAnimCB, this);
      return 0;
    }
  }
  v7 = 1;
  pPed->m_pNOCollisionVehicle = 0;
  return v7;
}

//----- (0051AD08) --------------------------------------------------------
void __fastcall CTaskLeanOnVehicle::FinishAnimCB(CAnimBlendAssociation *pAnim, void *pData)
{
  int m_animId; // r2

  m_animId = pAnim->m_animId;
  *((_DWORD *)pData + 6) = m_animId;
  if ( m_animId == 305 )
  {
    pAnim->m_fBlendDelta = -1000.0;
    *((_BYTE *)pData + 40) = 1;
  }
  if ( *((_BYTE *)pData + 41) && *((_DWORD *)pData + 6) == 303 )
  {
    pAnim->m_fBlendDelta = -1000.0;
    *((_BYTE *)pData + 40) = 1;
  }
  *((_DWORD *)pData + 5) = 0;
}

//----- (0051AD48) --------------------------------------------------------
void __fastcall CTaskComplexPassObject::CTaskComplexPassObject(
        CTaskComplexPassObject *this,
        CPed *pPed,
        bool8 isPasser)
{
  CTaskComplex::CTaskComplex(this);
  *(_WORD *)&this->m_timer.m_bIsActive = 0;
  this->m_isPasser = isPasser;
  this->m_timer.m_iStartTime = 0;
  this->m_timer.m_iDuration = 0;
  this->_vptr$CTask = (int (**)(void))&off_66BFEC;
  this->m_pPed = pPed;
  if ( pPed )
    CEntity::RegisterReference(pPed, &this->m_pPed);
}
// 66BFEC: using guessed type void *;

//----- (0051AD8C) --------------------------------------------------------
void __fastcall CTaskComplexPassObject::~CTaskComplexPassObject(CTaskComplexPassObject *this)
{
  CPed *m_pPed; // r0
  CEntity **p_m_pPed; // r1

  p_m_pPed = &this->m_pPed;
  m_pPed = this->m_pPed;
  this->_vptr$CTask = (int (**)(void))&off_66BFEC;
  if ( m_pPed )
    CEntity::CleanUpOldReference(m_pPed, p_m_pPed);
  sub_18EDB4(this);
}
// 66BFEC: using guessed type void *off_66BFEC;

//----- (0051ADB8) --------------------------------------------------------
void __fastcall CTaskComplexPassObject::~CTaskComplexPassObject(CTaskComplexPassObject *this)
{
  CPed *m_pPed; // r0
  CEntity **p_m_pPed; // r1
  void *v4; // r0

  p_m_pPed = &this->m_pPed;
  m_pPed = this->m_pPed;
  this->_vptr$CTask = (int (**)(void))&off_66BFEC;
  if ( m_pPed )
    CEntity::CleanUpOldReference(m_pPed, p_m_pPed);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 51ADE0: variable 'v4' is possibly undefined
// 66BFEC: using guessed type void *off_66BFEC;

//----- (0051ADE8) --------------------------------------------------------
bool __fastcall CTaskComplexPassObject::MakeAbortable(
        CTaskComplexPassObject *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  if ( IKChainManager_c::IsArmPointing(&g_ikChainMan, 0, pPed) )
    IKChainManager_c::AbortPointArm(&g_ikChainMan, 0, pPed, 500);
  return 1;
}

//----- (0051AE1C) --------------------------------------------------------
void __fastcall CTaskComplexPassObject::AbortIK(CTaskComplexPassObject *this, CPed *pPed)
{
  if ( IKChainManager_c::IsArmPointing(&g_ikChainMan, 0, pPed) )
    sub_19A228(&g_ikChainMan, 0, pPed, 500);
}

//----- (0051AE54) --------------------------------------------------------
CTask *__fastcall CTaskComplexPassObject::CreateNextSubTask(CTaskComplexPassObject *this, CPed *pPed)
{
  CTaskSimpleStandStill *v4; // r5

  if ( this->m_pPed
    && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 920 )
  {
    IKChainManager_c::PointArm(
      &g_ikChainMan,
      "CTaskComplexPassObject",
      0,
      pPed,
      0,
      -1,
      &this->m_targetPos,
      0.25,
      250,
      30.0);
    v4 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill(
      v4,
      (const int)"List_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly",
      0,
      0,
      8.0);
  }
  else
  {
    v4 = 0;
    if ( IKChainManager_c::IsArmPointing(&g_ikChainMan, 0, pPed) )
    {
      v4 = 0;
      IKChainManager_c::AbortPointArm(&g_ikChainMan, 0, pPed, 500);
    }
  }
  return v4;
}

//----- (0051AF18) --------------------------------------------------------
CTask *__fastcall CTaskComplexPassObject::CreateFirstSubTask(CTaskComplexPassObject *this, CPed *pPed)
{
  CTaskComplexTurnToFaceEntityOrCoord *v4; // r6
  CPed *m_pPed; // r0
  CEntity *EntityThatThisPedIsHolding; // r0
  CPed *v7; // r1
  CMatrix *m_pMat; // r0
  CMatrix *v9; // r2
  CSimpleTransform *p_tx; // r3
  bool v11; // zf
  float *p_x; // r0
  float x; // s2
  float y; // s0
  float z; // s4
  float *v16; // r3
  float v17; // s2
  float v18; // s0
  float v19; // s4
  __int64 v21; // r2
  float v22; // s2
  float v23; // s4
  float v24; // s0
  CMatrix *v25; // r1
  float v26; // s10
  RwReal v27; // s0

  if ( this->m_pPed )
  {
    if ( CPed::IsPlayer(pPed) || CPed::IsPlayer(this->m_pPed) )
    {
      v4 = 0;
      if ( IKChainManager_c::IsArmPointing(&g_ikChainMan, 0, pPed) )
        goto LABEL_16;
      return v4;
    }
    m_pPed = pPed;
    if ( !this->m_isPasser )
      m_pPed = this->m_pPed;
    EntityThatThisPedIsHolding = CPed::GetEntityThatThisPedIsHolding(m_pPed);
    this->m_pEntity = EntityThatThisPedIsHolding;
    if ( EntityThatThisPedIsHolding )
      CEntity::RegisterReference(EntityThatThisPedIsHolding, &this->m_pEntity);
    v7 = this->m_pPed;
    m_pMat = pPed->m_pMat;
    v9 = v7->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    v11 = m_pMat == 0;
    p_x = &v7->m_transform.m_translate.x;
    if ( v11 )
      p_tx = &pPed->m_transform;
    x = p_tx->m_translate.x;
    y = p_tx->m_translate.y;
    z = p_tx->m_translate.z;
    v16 = &v7->m_transform.m_translate.x;
    if ( v9 )
      v16 = &v9->tx;
    v17 = *v16 - x;
    v18 = v16[1] - y;
    v19 = v16[2] - z;
    if ( (float)((float)((float)(v17 * v17) + (float)(v18 * v18)) + (float)(v19 * v19)) <= 2.25 )
    {
      v21 = CTimer::m_snTimeInMilliseconds | 0x3E800000000LL;
      v22 = v17 * 0.5;
      this->m_timer.m_bIsActive = 1;
      *(_QWORD *)&this->m_timer.m_iStartTime = v21;
      v23 = v19 * 0.5;
      v24 = v18 * 0.5;
      v25 = v7->m_pMat;
      if ( v25 )
        p_x = &v25->tx;
      v26 = p_x[2];
      v27 = v24 + p_x[1];
      this->m_targetPos.x = v22 + *p_x;
      this->m_targetPos.y = v27;
      this->m_targetPos.z = v23 + v26;
      v4 = (CTaskComplexTurnToFaceEntityOrCoord *)CTask::operator new(0x28u);
      CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(v4, this->m_pPed, 0.5, 0.2);
      return v4;
    }
  }
  v4 = 0;
  if ( IKChainManager_c::IsArmPointing(&g_ikChainMan, 0, pPed) )
  {
LABEL_16:
    v4 = 0;
    IKChainManager_c::AbortPointArm(&g_ikChainMan, 0, pPed, 500);
  }
  return v4;
}

//----- (0051B098) --------------------------------------------------------
CTask *__fastcall CTaskComplexPassObject::ControlSubTask(CTaskComplexPassObject *this, CPed *pPed)
{
  CPed *m_pPed; // r0
  unsigned int v5; // r1
  int m_iStartTime; // r2
  CTask *v7; // r5
  CTaskSimpleHoldEntity *ActiveTaskByType; // r0
  CEntity *m_pHoldEntity; // r8
  CPedIntelligence *m_pPedIntelligence; // r9
  CTaskSimpleHoldEntity *v11; // r5
  CVector pVecOffset; // [sp+14h] [bp-24h] BYREF

  m_pPed = this->m_pPed;
  if ( m_pPed )
  {
    if ( !this->m_timer.m_bIsActive )
      return this->m_pSubTask;
    if ( this->m_timer.m_bIsStopped )
    {
      v5 = CTimer::m_snTimeInMilliseconds;
      this->m_timer.m_bIsStopped = 0;
      this->m_timer.m_iStartTime = v5;
      m_iStartTime = v5;
    }
    else
    {
      m_iStartTime = this->m_timer.m_iStartTime;
      v5 = CTimer::m_snTimeInMilliseconds;
    }
    if ( m_iStartTime + this->m_timer.m_iDuration > v5 )
      return this->m_pSubTask;
    if ( !this->m_isPasser )
    {
      if ( this->m_pEntity )
      {
        ActiveTaskByType = (CTaskSimpleHoldEntity *)CTaskManager::FindActiveTaskByType(
                                                      &m_pPed->m_pPedIntelligence->m_taskManager,
                                                      307);
        if ( ActiveTaskByType )
        {
          m_pHoldEntity = ActiveTaskByType->m_pHoldEntity;
          CTaskSimpleHoldEntity::DropEntity(ActiveTaskByType, this->m_pPed, 0);
          memset(&pVecOffset, 0, sizeof(pVecOffset));
          m_pPedIntelligence = pPed->m_pPedIntelligence;
          v11 = (CTaskSimpleHoldEntity *)CTask::operator new(0x3Cu);
          CTaskSimpleHoldEntity::CTaskSimpleHoldEntity(
            v11,
            m_pHoldEntity,
            &pVecOffset,
            6u,
            0x10u,
            ANIM_STD_NUM,
            ANIM_STD_PED,
            1);
          CTaskManager::SetTaskSecondary(&m_pPedIntelligence->m_taskManager, v11, 4);
        }
      }
    }
    v7 = 0;
    if ( IKChainManager_c::IsArmPointing(&g_ikChainMan, 0, pPed) )
    {
LABEL_15:
      v7 = 0;
      IKChainManager_c::AbortPointArm(&g_ikChainMan, 0, pPed, 500);
    }
  }
  else
  {
    v7 = 0;
    if ( IKChainManager_c::IsArmPointing(&g_ikChainMan, 0, pPed) )
      goto LABEL_15;
  }
  return v7;
}

//----- (0051B1A0) --------------------------------------------------------
void __fastcall CTaskComplexGangJoinRespond::CTaskComplexGangJoinRespond(
        CTaskComplexGangJoinRespond *this,
        bool8 response)
{
  int v3; // r0

  CTaskComplex::CTaskComplex(this);
  *(_BYTE *)(v3 + 12) = response;
  *(_BYTE *)(v3 + 13) = 0;
  *(_DWORD *)v3 = &off_66C028;
}
// 51B1AE: variable 'v3' is possibly undefined
// 66C028: using guessed type void *;

//----- (0051B1C0) --------------------------------------------------------
void __fastcall CTaskComplexGangJoinRespond::~CTaskComplexGangJoinRespond(CTaskComplexGangJoinRespond *this)
{
  int m_animsReferenced; // r1
  int32 AnimationBlockIndex; // r0

  m_animsReferenced = this->m_animsReferenced;
  this->_vptr$CTask = (int (**)(void))&off_66C028;
  if ( m_animsReferenced )
  {
    AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("gangs");
    CAnimManager::RemoveAnimBlockRef(AnimationBlockIndex);
    this->m_animsReferenced = 0;
  }
  sub_18EDB4(this);
}
// 66C028: using guessed type void *off_66C028;

//----- (0051B1FC) --------------------------------------------------------
void __fastcall CTaskComplexGangJoinRespond::~CTaskComplexGangJoinRespond(CTaskComplexGangJoinRespond *this)
{
  int m_animsReferenced; // r1
  int32 AnimationBlockIndex; // r0
  void *v4; // r0

  m_animsReferenced = this->m_animsReferenced;
  this->_vptr$CTask = (int (**)(void))&off_66C028;
  if ( m_animsReferenced )
  {
    AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("gangs");
    CAnimManager::RemoveAnimBlockRef(AnimationBlockIndex);
    this->m_animsReferenced = 0;
  }
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 51B22E: variable 'v4' is possibly undefined
// 66C028: using guessed type void *off_66C028;

//----- (0051B23C) --------------------------------------------------------
bool __fastcall CTaskComplexGangJoinRespond::MakeAbortable(
        CTaskComplexGangJoinRespond *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  return 1;
}

//----- (0051B240) --------------------------------------------------------
CTask *__fastcall CTaskComplexGangJoinRespond::CreateNextSubTask(CTaskComplexGangJoinRespond *this, CPed *pPed)
{
  CTask *result; // r0
  int m_response; // r4
  CTaskSimpleRunAnim *v5; // r0
  AnimationId v6; // r2
  int32 m_attempts; // r0
  CTaskSimpleStandStill *v8; // r0

  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 400 )
    return 0;
  if ( this->m_animsReferenced )
  {
    m_response = this->m_response;
    v5 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
    if ( m_response == 1 )
      v6 = ANIM_GANG_JOIN_YES;
    else
      v6 = ANIM_GANG_JOIN_NO;
    CTaskSimpleRunAnim::CTaskSimpleRunAnim(v5, ANIM_GANG_PED, v6, 4.0, 0);
  }
  else
  {
    m_attempts = this->m_attempts;
    this->m_attempts = m_attempts + 1;
    if ( m_attempts > 9 )
      return 0;
    v8 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill(v8, 250, 0, 0, 8.0);
  }
  return result;
}

//----- (0051B2AC) --------------------------------------------------------
CTask *__fastcall CTaskComplexGangJoinRespond::CreateFirstSubTask(CTaskComplexGangJoinRespond *this, CPed *pPed)
{
  CTaskComplexTurnToFaceEntityOrCoord *v2; // r4
  CPlayerPed *PlayerPed; // r1
  CTask *result; // r0

  this->m_attempts = 0;
  v2 = (CTaskComplexTurnToFaceEntityOrCoord *)CTask::operator new(0x28u);
  PlayerPed = FindPlayerPed(0);
  sub_19C9FC(v2, PlayerPed, 0.5, 0.2);
  return result;
}

//----- (0051B2E8) --------------------------------------------------------
CTask *__fastcall CTaskComplexGangJoinRespond::ControlSubTask(CTaskComplexGangJoinRespond *this, CPed *pPed)
{
  CPlayerPed *PlayerPed; // r0
  CMatrix *m_pMat; // r1
  CMatrix *v6; // r2
  CSimpleTransform *p_tx; // r3
  float *p_x; // r1
  float y; // s2
  float v10; // s6
  float RadianAngleBetweenPoints; // r0
  int m_animsReferenced; // r5
  CPlayerPed *v13; // r1
  float *m_pMyVehicle; // r0
  bool v15; // zf
  _BOOL4 v16; // r0
  int32 AnimationBlockIndex; // r0
  bool8 v18; // r0
  int32 v19; // r0
  CVector v21; // [sp+4h] [bp-14h] BYREF

  PlayerPed = FindPlayerPed(-1);
  m_pMat = pPed->m_pMat;
  v6 = PlayerPed->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  p_x = &v6->tx;
  y = p_tx->m_translate.y;
  if ( !v6 )
    p_x = &PlayerPed->m_transform.m_translate.x;
  v10 = p_x[1];
  v21.x = *p_x - p_tx->m_translate.x;
  v21.z = 0.0;
  v21.y = v10 - y;
  CVector::Normalise(&v21);
  RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(v21.x, v21.y, 0.0, 0.0);
  pPed->m_fDesiredHeading = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
  m_animsReferenced = this->m_animsReferenced;
  v13 = CWorld::Players[CWorld::PlayerInFocus].pPed;
  m_pMyVehicle = (float *)v13->m_pMyVehicle;
  v15 = m_pMyVehicle == 0;
  if ( m_pMyVehicle )
    v15 = (*(_DWORD *)&v13->m_nPedFlags & 0x100) == 0;
  if ( v15
    || (float)((float)((float)(m_pMyVehicle[18] * m_pMyVehicle[18]) + (float)(m_pMyVehicle[19] * m_pMyVehicle[19]))
             + (float)(m_pMyVehicle[20] * m_pMyVehicle[20])) <= 0.04 )
  {
    v16 = !CStreaming::IsVeryBusy();
    if ( !m_animsReferenced )
    {
LABEL_10:
      if ( v16 )
      {
        AnimationBlockIndex = CAnimManager::GetAnimationBlockIndex("gangs");
        if ( !CAnimManager::ms_aAnimBlocks[AnimationBlockIndex].m_loaded )
        {
          CStreaming::RequestModel(AnimationBlockIndex + 25575, 8);
          return this->m_pSubTask;
        }
        CAnimManager::AddAnimBlockRef(AnimationBlockIndex);
        v18 = 1;
        goto LABEL_16;
      }
      return this->m_pSubTask;
    }
  }
  else
  {
    v16 = 0;
    if ( !this->m_animsReferenced )
      goto LABEL_10;
  }
  if ( !v16 )
  {
    v19 = CAnimManager::GetAnimationBlockIndex("gangs");
    CAnimManager::RemoveAnimBlockRef(v19);
    v18 = 0;
LABEL_16:
    this->m_animsReferenced = v18;
  }
  return this->m_pSubTask;
}

//----- (0051B41C) --------------------------------------------------------
void __fastcall CTaskComplexProstituteSolicit::CTaskComplexProstituteSolicit(
        CTaskComplexProstituteSolicit *this,
        CPed *pPunterPed)
{
  __int16 v4; // r2

  CTaskComplex::CTaskComplex(this);
  v4 = *((_WORD *)this + 22);
  this->m_iLastTimeCarMoving = 0;
  this->m_iNextTimeToScanForPeds = 0;
  this->m_iSecondsCounter = 0;
  *(_DWORD *)&this->m_iShaggingFreq = 850;
  *((_WORD *)this + 22) = v4 & 0xE000 | 0x2C0;
  this->_vptr$CTask = (int (**)(void))&off_66C064;
  this->m_pPunterPed = pPunterPed;
  CEntity::RegisterReference(pPunterPed, &this->m_pPunterPed);
}
// 66C064: using guessed type void *;

//----- (0051B460) --------------------------------------------------------
void __fastcall CTaskComplexProstituteSolicit::~CTaskComplexProstituteSolicit(CTaskComplexProstituteSolicit *this)
{
  CPlayerPed *PlayerPed; // r0
  CPlayerPedData *m_pPlayerData; // r5
  CEntity *v4; // r0
  CEntity **p_m_pCurrentProstitutePed; // r5
  CEntity *m_pCurrentProstitutePed; // t1

  this->_vptr$CTask = (int (**)(void))&off_66C064;
  PlayerPed = FindPlayerPed(-1);
  if ( PlayerPed )
  {
    m_pPlayerData = PlayerPed->m_pPlayerData;
    m_pCurrentProstitutePed = m_pPlayerData->m_pCurrentProstitutePed;
    p_m_pCurrentProstitutePed = &m_pPlayerData->m_pCurrentProstitutePed;
    v4 = m_pCurrentProstitutePed;
    if ( m_pCurrentProstitutePed )
    {
      CEntity::CleanUpOldReference(v4, p_m_pCurrentProstitutePed);
      *p_m_pCurrentProstitutePed = 0;
    }
    if ( (*((_WORD *)this + 22) & 0x100) != 0 )
      *((_WORD *)this + 22) &= ~0x100u;
  }
  sub_18EDB4(this);
}
// 66C064: using guessed type void *off_66C064;

//----- (0051B4AC) --------------------------------------------------------
void __fastcall CTaskComplexProstituteSolicit::~CTaskComplexProstituteSolicit(CTaskComplexProstituteSolicit *this)
{
  CPlayerPed *PlayerPed; // r0
  CPlayerPedData *m_pPlayerData; // r5
  CEntity *v4; // r0
  CEntity **p_m_pCurrentProstitutePed; // r5
  CEntity *m_pCurrentProstitutePed; // t1
  void *v7; // r0

  this->_vptr$CTask = (int (**)(void))&off_66C064;
  PlayerPed = FindPlayerPed(-1);
  if ( PlayerPed )
  {
    m_pPlayerData = PlayerPed->m_pPlayerData;
    m_pCurrentProstitutePed = m_pPlayerData->m_pCurrentProstitutePed;
    p_m_pCurrentProstitutePed = &m_pPlayerData->m_pCurrentProstitutePed;
    v4 = m_pCurrentProstitutePed;
    if ( m_pCurrentProstitutePed )
    {
      CEntity::CleanUpOldReference(v4, p_m_pCurrentProstitutePed);
      *p_m_pCurrentProstitutePed = 0;
    }
    if ( (*((_WORD *)this + 22) & 0x100) != 0 )
      *((_WORD *)this + 22) &= ~0x100u;
  }
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v7);
}
// 51B4F2: variable 'v7' is possibly undefined
// 66C064: using guessed type void *off_66C064;

//----- (0051B4FC) --------------------------------------------------------
bool __fastcall CTaskComplexProstituteSolicit::MakeAbortable(
        CTaskComplexProstituteSolicit *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  int v5; // r0

  v5 = (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
        + 7))(
         this->m_pSubTask,
         pPed,
         iPriority,
         pEvent);
  if ( v5 == 1 )
    *((_WORD *)this + 22) &= ~0x100u;
  return v5;
}

//----- (0051B518) --------------------------------------------------------
bool __fastcall CTaskComplexProstituteSolicit::IsTaskValid(CPed *pProzzyPed, CPed *pPunterPed)
{
  CPlayerPed *PlayerPed; // r1
  bool result; // r0
  CPed *m_pCurrentProstitutePed; // r0
  bool v7; // zf
  CTask *SimplestActiveTask; // r0
  CVehicle *m_pMyVehicle; // r0
  CVehicle *v10; // r1
  bool v11; // zf
  CMatrix *m_pMat; // r0
  CMatrix *v13; // r1
  CSimpleTransform *p_tx; // r2
  CSimpleTransform *p_m_transform; // r0
  float32x2_t v16; // d16
  unsigned __int64 v17; // d1

  PlayerPed = FindPlayerPed(-1);
  result = 0;
  if ( pPunterPed && PlayerPed == pPunterPed )
  {
    if ( (*(_DWORD *)&pPunterPed->m_nPedFlags & 0x100) == 0 )
      return 0;
    result = 0;
    if ( (*((_DWORD *)&pPunterPed->m_nPedFlags + 2) & 0x40) == 0 && pPunterPed->m_pMyVehicle )
    {
      m_pCurrentProstitutePed = pPunterPed->m_pPlayerData->m_pCurrentProstitutePed;
      v7 = m_pCurrentProstitutePed == 0;
      if ( m_pCurrentProstitutePed )
        v7 = m_pCurrentProstitutePed == pProzzyPed;
      if ( !v7 )
        return 0;
      if ( CVehicle::GetVehicleAppearance(pPunterPed->m_pMyVehicle) != APR_CAR )
        return 0;
      if ( CVehicle::IsUpsideDown(pPunterPed->m_pMyVehicle) )
        return 0;
      if ( CVehicle::IsOnItsSide(pPunterPed->m_pMyVehicle) )
        return 0;
      SimplestActiveTask = CTaskManager::GetSimplestActiveTask(&pPunterPed->m_pPedIntelligence->m_taskManager);
      if ( (*((int (__fastcall **)(CTask *))SimplestActiveTask->_vptr$CTask + 5))(SimplestActiveTask) != 709 )
        return 0;
      m_pMyVehicle = pPunterPed->m_pMyVehicle;
      if ( m_pMyVehicle->pDriver != pPunterPed )
        return 0;
      v10 = pProzzyPed->m_pMyVehicle;
      v11 = v10 == 0;
      if ( v10 )
        v11 = v10 == m_pMyVehicle;
      if ( !v11 )
        return 0;
      if ( v10 )
      {
        if ( v10->m_nNumPassengers != 1 )
          return 0;
      }
      else if ( m_pMyVehicle->m_nNumPassengers )
      {
        return 0;
      }
      if ( !m_pMyVehicle->m_nMaxPassengers || (m_pMyVehicle->pHandling->mFlags & 0x200) != 0 )
        return 0;
      m_pMat = pProzzyPed->m_pMat;
      v13 = pPunterPed->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pProzzyPed->m_transform;
      p_m_transform = (CSimpleTransform *)&v13->tx;
      if ( !v13 )
        p_m_transform = &pPunterPed->m_transform;
      v16.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
      v17 = vmul_f32(v16, v16).n64_u64[0];
      if ( (float)((float)((float)((float)(p_m_transform->m_translate.x - p_tx->m_translate.x)
                                 * (float)(p_m_transform->m_translate.x - p_tx->m_translate.x))
                         + *(float *)&v17)
                 + *((float *)&v17 + 1)) > 100.0
        || CTheScripts::IsPlayerOnAMission() )
      {
        return 0;
      }
      return CGameLogic::IsCoopGameGoingOn() ^ 1;
    }
  }
  return result;
}

//----- (0051B64C) --------------------------------------------------------
void CTaskComplexProstituteSolicit::GetRidOfPlayerProstitute()
{
  CPed *m_pCurrentProstitutePed; // r0
  CTask *TaskByType; // r0
  __int16 m_pParent; // r1

  m_pCurrentProstitutePed = FindPlayerPed(-1)->m_pPlayerData->m_pCurrentProstitutePed;
  if ( m_pCurrentProstitutePed )
  {
    TaskByType = CPedIntelligence::FindTaskByType(m_pCurrentProstitutePed->m_pPedIntelligence, 1309);
    if ( TaskByType )
    {
      m_pParent = (__int16)TaskByType[5].m_pParent;
      HIWORD(TaskByType[5]._vptr$CTask) = 0;
      LOWORD(TaskByType[5].m_pParent) = m_pParent | 4;
    }
  }
}

//----- (0051B686) --------------------------------------------------------
CTask *__fastcall CTaskComplexProstituteSolicit::CreateFirstSubTask(CTaskComplexProstituteSolicit *this, CPed *pPed)
{
  CPed *m_pPunterPed; // r0
  CVehicle *m_pMyVehicle; // r1
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r3
  __int64 v8; // d16
  CPlayerPed *PlayerPed; // r0
  CPlayerPedData *m_pPlayerData; // r2
  CPed *m_pLastProstituteShagged; // r0

  if ( CTaskComplexProstituteSolicit::IsTaskValid(pPed, this->m_pPunterPed) )
  {
    m_pPunterPed = this->m_pPunterPed;
    m_pMyVehicle = m_pPunterPed->m_pMyVehicle;
    m_pMat = m_pMyVehicle->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &m_pMyVehicle->m_transform;
    v8 = *(_QWORD *)&p_tx->m_translate.x;
    this->m_InitialVehiclePos.z = p_tx->m_translate.z;
    *(_QWORD *)&this->m_InitialVehiclePos.x = v8;
    m_pPunterPed->m_pPlayerData->m_pCurrentProstitutePed = pPed;
    PlayerPed = FindPlayerPed(-1);
    CEntity::RegisterReference(
      PlayerPed->m_pPlayerData->m_pCurrentProstitutePed,
      &PlayerPed->m_pPlayerData->m_pCurrentProstitutePed);
    m_pPlayerData = this->m_pPunterPed->m_pPlayerData;
    m_pLastProstituteShagged = m_pPlayerData->m_pLastProstituteShagged;
    if ( m_pLastProstituteShagged != pPed )
    {
      if ( m_pLastProstituteShagged )
      {
        CEntity::CleanUpOldReference(m_pLastProstituteShagged, &m_pPlayerData->m_pLastProstituteShagged);
        m_pPlayerData = this->m_pPunterPed->m_pPlayerData;
      }
      m_pPlayerData->m_pLastProstituteShagged = pPed;
      CEntity::RegisterReference(
        this->m_pPunterPed->m_pPlayerData->m_pLastProstituteShagged,
        &this->m_pPunterPed->m_pPlayerData->m_pLastProstituteShagged);
    }
    return CTaskComplexProstituteSolicit::CreateSubTask(this, 907, pPed);
  }
  else
  {
    *((_WORD *)this + 22) |= 4u;
    return 0;
  }
}

//----- (0051B720) --------------------------------------------------------
CTask *__fastcall CTaskComplexProstituteSolicit::CreateSubTask(
        CTaskComplexProstituteSolicit *this,
        const int iSubTaskType,
        CPed *pPed)
{
  char *v5; // r4
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float y; // s8
  CVector *p_v; // r2
  CVehicle *m_pMyVehicle; // r5
  char v11; // r0
  __int64 v12; // d16
  CVector v14; // [sp+8h] [bp-90h] BYREF
  CVector v15; // [sp+18h] [bp-80h]
  CVector v16; // [sp+28h] [bp-70h] BYREF
  CVector v; // [sp+34h] [bp-64h] BYREF
  CMatrix output; // [sp+40h] [bp-58h] BYREF

  v5 = 0;
  if ( iSubTaskType > 724 )
  {
    switch ( iSubTaskType )
    {
      case 725:
        *((_WORD *)this + 22) = *((_WORD *)this + 22) & 0xFFFC | 1;
        v5 = (char *)CTask::operator new(0x24u);
        CTaskComplexCarDrive::CTaskComplexCarDrive((CTaskComplexCarDrive *)v5, this->m_pPunterPed->m_pMyVehicle);
        break;
      case 907:
        output.m_pRwMat = 0;
        output.m_owner = 0;
        Invert(this->m_pPunterPed->m_pMyVehicle->m_pMat, &output);
        CCarEnterExit::GetPositionToOpenCarDoor(&v, this->m_pPunterPed->m_pMyVehicle, 10);
        CCarEnterExit::GetPositionToOpenCarDoor(&v16, this->m_pPunterPed->m_pMyVehicle, 8);
        m_pMat = pPed->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &pPed->m_transform;
        y = p_tx->m_translate.y;
        if ( (float)((float)((float)((float)(p_tx->m_translate.x - v.x) * (float)(p_tx->m_translate.x - v.x))
                           + (float)((float)(y - v.y) * (float)(y - v.y)))
                   + (float)((float)(p_tx->m_translate.z - v.z) * (float)(p_tx->m_translate.z - v.z))) < (float)((float)((float)((float)(p_tx->m_translate.x - v16.x) * (float)(p_tx->m_translate.x - v16.x)) + (float)((float)(y - v16.y) * (float)(y - v16.y))) + (float)((float)(p_tx->m_translate.z - v16.z) * (float)(p_tx->m_translate.z - v16.z))) )
          p_v = &v;
        else
          p_v = &v16;
        operator*(&v14, &output, p_v);
        v15 = v14;
        v5 = (char *)CTask::operator new(0x58u);
        m_pMyVehicle = this->m_pPunterPed->m_pMyVehicle;
        CTaskComplex::CTaskComplex((CTaskComplex *)v5);
        *((_QWORD *)v5 + 3) = 0x400000003F800000LL;
        *((_QWORD *)v5 + 4) = 0x4000000000000000LL;
        *(_DWORD *)v5 = &off_668968;
        *((_DWORD *)v5 + 4) = 50000;
        *((_DWORD *)v5 + 5) = 1000;
        *((_WORD *)v5 + 24) = 0;
        *((_WORD *)v5 + 30) = 0;
        *((_DWORD *)v5 + 10) = 0;
        *((_DWORD *)v5 + 11) = 0;
        *((_DWORD *)v5 + 13) = 0;
        *((_DWORD *)v5 + 14) = 0;
        *((_DWORD *)v5 + 16) = &off_66D3CC;
        v11 = v5[84];
        *((_DWORD *)v5 + 18) = 0;
        *((_DWORD *)v5 + 19) = 0;
        *((_DWORD *)v5 + 20) = 6;
        v5[84] = v11 & 0xF0;
        *((_DWORD *)v5 + 17) = 0;
        *((_DWORD *)v5 + 3) = m_pMyVehicle;
        if ( m_pMyVehicle )
          CEntity::RegisterReference(m_pMyVehicle, (CEntity **)v5 + 3);
        v12 = *(_QWORD *)&v15.x;
        *((_DWORD *)v5 + 19) = LODWORD(v15.z);
        *(_QWORD *)(v5 + 68) = v12;
        CMatrix::~CMatrix(&output);
        break;
      case 920:
        v5 = (char *)CTask::operator new(0x28u);
        CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(
          (CTaskComplexTurnToFaceEntityOrCoord *)v5,
          this->m_pPunterPed,
          0.5,
          0.2);
        break;
    }
  }
  else
  {
    switch ( iSubTaskType )
    {
      case 203:
        v5 = (char *)CTask::operator new(0x20u);
        CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v5, 5000, 0, 0, 8.0);
        break;
      case 700:
        v5 = (char *)CTask::operator new(0x50u);
        CTaskComplexEnterCarAsPassenger::CTaskComplexEnterCarAsPassenger(
          (CTaskComplexEnterCarAsPassenger *)v5,
          this->m_pPunterPed->m_pMyVehicle,
          8,
          0);
        break;
      case 704:
        v5 = (char *)CTask::operator new(0x34u);
        CTaskComplexLeaveCar::CTaskComplexLeaveCar(
          (CTaskComplexLeaveCar *)v5,
          this->m_pPunterPed->m_pMyVehicle,
          0,
          0,
          1,
          0);
        break;
    }
  }
  return (CTask *)v5;
}
// 668968: using guessed type void *off_668968;
// 66D3CC: using guessed type void *off_66D3CC;

//----- (0051B990) --------------------------------------------------------
CTask *__fastcall CTaskComplexProstituteSolicit::CreateNextSubTask(CTaskComplexProstituteSolicit *this, CPed *pPed)
{
  CPed *m_pPunterPed; // r1
  int v5; // r0
  int v6; // r1
  CVehicle *m_pMyVehicle; // r0
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  __int64 v11; // d16
  GxtChar *v12; // r0
  CPlayerPed *PlayerPed; // r0
  GxtChar *v14; // r0
  GxtChar *v15; // r0

  m_pPunterPed = this->m_pPunterPed;
  if ( !m_pPunterPed )
    return 0;
  if ( !CTaskComplexProstituteSolicit::IsTaskValid(pPed, m_pPunterPed) )
    *((_WORD *)this + 22) |= 4u;
  v5 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v5 <= 724 )
  {
    switch ( v5 )
    {
      case 203:
        if ( (*((_BYTE *)this + 45) & 4) != 0 )
        {
          if ( CCheat::m_aCheatsActive[98]
            || (PlayerPed = FindPlayerPed(-1), CPlayerPed::GetPlayerInfoForThisPlayerPed(PlayerPed)->Score > 19) )
          {
            v6 = 700;
          }
          else
          {
            CMessages::ClearMessages(0);
            v14 = CText::Get(&TheText, "PROS_06");
            CMessages::AddMessage("PROS_06", v14, 0x7D0u, 1u, 1);
            v15 = CText::Get(&TheText, "PROS_09");
            CMessages::AddMessage("PROS_09", v15, 0xBB8u, 1u, 1);
            v6 = 1302;
          }
          return CTaskComplexProstituteSolicit::CreateSubTask(this, v6, pPed);
        }
        goto LABEL_15;
      case 700:
        CPed::Say(pPed, 0xC5u, 0, 1.0, 0, 0, 0);
        m_pMyVehicle = this->m_pPunterPed->m_pMyVehicle;
        m_pMat = m_pMyVehicle->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &m_pMyVehicle->m_transform;
        v6 = 725;
        v11 = *(_QWORD *)&p_tx->m_translate.x;
        this->m_InitialVehiclePos.z = p_tx->m_translate.z;
        *(_QWORD *)&this->m_InitialVehiclePos.x = v11;
        return CTaskComplexProstituteSolicit::CreateSubTask(this, v6, pPed);
      case 704:
        IKChainManager_c::LookAt(&g_ikChainMan, "TaskProzzy", pPed, this->m_pPunterPed, 2500, -1, 0, 0, 0.25, 500, 3, 0);
LABEL_15:
        v6 = 1302;
        return CTaskComplexProstituteSolicit::CreateSubTask(this, v6, pPed);
    }
    return 0;
  }
  if ( v5 == 725 )
  {
    v6 = 704;
    return CTaskComplexProstituteSolicit::CreateSubTask(this, v6, pPed);
  }
  if ( v5 == 920 )
  {
    CPed::Say(pPed, 0xC0u, 0, 1.0, 0, 0, 0);
    v12 = CText::Get(&TheText, "PROS_04");
    CMessages::AddMessage("PROS_04", v12, 0x1388u, 1u, 1);
    v6 = 203;
    return CTaskComplexProstituteSolicit::CreateSubTask(this, v6, pPed);
  }
  if ( v5 != 907 )
    return 0;
  IKChainManager_c::LookAt(&g_ikChainMan, "TaskProzzy", pPed, this->m_pPunterPed, 5000, -1, 0, 0, 0.25, 500, 3, 0);
  v6 = 920;
  return CTaskComplexProstituteSolicit::CreateSubTask(this, v6, pPed);
}

//----- (0051BBB8) --------------------------------------------------------
CTask *__fastcall CTaskComplexProstituteSolicit::ControlSubTask(CTaskComplexProstituteSolicit *this, CPed *pPed)
{
  float32x2_t v2; // d2
  float32x2_t v3; // d3
  float32x2_t v4; // d4
  __int16 v7; // r0
  __int16 v8; // r0
  _BOOL4 IsTaskValid; // r0
  __int16 v10; // r1
  int v11; // r11
  CTask **p_m_pSubTask; // r9
  CPed *v13; // r0
  CTask *result; // r0
  int v15; // r0
  CVehicle *m_pMyVehicle; // r0
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  float32x2_t v19; // d16
  unsigned __int64 v20; // d1
  CPed *v21; // r0
  uint32 v22; // r5
  __int16 v23; // r1
  CVehicle *v24; // r0
  float32x2_t v25; // d17
  float v26; // s0
  __int16 v27; // r0
  float32x2_t v28; // d16
  unsigned __int64 v29; // d1
  float v30; // s18
  CWanted *PlayerWanted; // r12
  int v32; // r8
  __int16 v33; // r0
  CEntity **m_entities; // lr
  CPed *v35; // r1
  CPed *m_pPunterPed; // r2
  bool v37; // zf
  CMatrix *v38; // r0
  CMatrix *v39; // r3
  CSimpleTransform *p_m_transform; // r5
  const CVector *p_m_translate; // r0
  CSimpleTransform *v42; // r6
  float32x2_t v43; // d16
  unsigned __int64 v44; // d1
  float v45; // s0
  bool v46; // zf
  CVehicle *v47; // r2
  uint32 bdummy; // r3
  CPed *v49; // r2
  const CVector *v50; // r1
  CMatrix *v51; // r3
  const CVector *v52; // r1
  CWanted *v53; // r5
  _BOOL4 IsLineOfSightClear; // r0
  __int16 v55; // r0
  CWanted *v56; // r6
  _BOOL4 v57; // r5
  GxtChar *v58; // r1
  unsigned int v59; // r2
  __int16 v60; // r0
  bool v61; // zf
  int v62; // r8
  GxtChar *v63; // r0
  unsigned int v64; // r6
  CWanted *v65; // r0
  __int16 v66; // r0
  GxtChar *v67; // r1
  __int16 v68; // r0
  int v69; // r2
  unsigned int v70; // r6
  int v71; // r0
  float v72; // s0
  int m_iShagTimeLeft; // r0
  int16 *p_m_iShagTimeLeft; // r5
  float v75; // s16
  GxtChar *v76; // r0
  CPad *Pad; // r0
  CPed *v78; // r1
  CPhysical *v79; // r0
  CMatrix *v80; // r2
  float *p_x; // r3
  CMatrix *v82; // r2
  float v83; // s0
  float v84; // s2
  CSimpleTransform *v85; // r3
  double v86; // d16
  float v87; // s4
  CMatrix *v88; // r2
  CSimpleTransform *v89; // r1
  RwReal v90; // s0
  unsigned int v91; // s2
  UInt16 v92; // r1
  int v93; // r0
  __int16 v94; // r0
  CPlayerPed *v95; // r0
  CPlayerInfo *PlayerInfoForThisPlayerPed; // r6
  int Score; // r0
  __int16 v98; // r1
  GxtChar *v99; // r0
  GxtChar *v100; // r0
  CVector bOverideSilence; // [sp+0h] [bp-70h]
  int m_nFlags; // [sp+18h] [bp-58h]
  uint32 v103; // [sp+1Ch] [bp-54h]
  double v104; // [sp+20h] [bp-50h] BYREF
  RwReal z; // [sp+28h] [bp-48h]
  CVector v106; // 0:r1.12

  v7 = *((_WORD *)this + 22);
  if ( (v7 & 0x102) == 256 )
  {
    v8 = v7 & 0xFEFF;
  }
  else
  {
    if ( (v7 & 0x102) != 2 )
      goto LABEL_6;
    v8 = v7 | 0x100;
  }
  *((_WORD *)this + 22) = v8;
LABEL_6:
  IsTaskValid = CTaskComplexProstituteSolicit::IsTaskValid(pPed, this->m_pPunterPed);
  v10 = *((_WORD *)this + 22);
  if ( !IsTaskValid )
  {
    v10 = v10 & 0xFEFB | 4;
    *((_WORD *)this + 22) = v10;
  }
  v11 = (int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
  if ( (v10 & 4) != 0 )
  {
    if ( this->m_iShagTimeLeft )
    {
      v15 = (unsigned __int16)this->m_iShagTimeLeft - v11;
      this->m_iShagTimeLeft = v15;
      if ( v15 << 16 >= 1 )
        return this->m_pSubTask;
      CAEPedSpeechAudioEntity::SetCJMood(9, (UInt32)&elf_hash_chain[13526], -1, -1, -1);
      CPed::Say(this->m_pPunterPed, 0xBu, 0, 1.0, 0, 0, 0);
      p_m_pSubTask = &this->m_pSubTask;
      this->m_iShagTimeLeft = 0;
    }
    else
    {
      p_m_pSubTask = &this->m_pSubTask;
      if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 704
        && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))(*p_m_pSubTask)->_vptr$CTask + 7))(
             *p_m_pSubTask,
             pPed,
             1,
             0) == 1 )
      {
        return CTaskComplexProstituteSolicit::CreateSubTask(this, 704, pPed);
      }
    }
    return *p_m_pSubTask;
  }
  p_m_pSubTask = &this->m_pSubTask;
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 203 )
  {
    if ( (*((int (__fastcall **)(CTask *))(*p_m_pSubTask)->_vptr$CTask + 5))(*p_m_pSubTask) == 907
      || (*((int (__fastcall **)(CTask *))(*p_m_pSubTask)->_vptr$CTask + 5))(*p_m_pSubTask) == 700 )
    {
      m_pMyVehicle = this->m_pPunterPed->m_pMyVehicle;
      m_pMat = m_pMyVehicle->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &m_pMyVehicle->m_transform;
      v19.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.y, *(float32x2_t *)&this->m_InitialVehiclePos.y).n64_u64[0];
      v20 = vmul_f32(v19, v19).n64_u64[0];
      if ( (float)((float)((float)((float)(p_tx->m_translate.x - this->m_InitialVehiclePos.x)
                                 * (float)(p_tx->m_translate.x - this->m_InitialVehiclePos.x))
                         + *(float *)&v20)
                 + *((float *)&v20 + 1)) <= 16.0 )
        return *p_m_pSubTask;
      goto LABEL_29;
    }
    if ( (*((int (__fastcall **)(CTask *))(*p_m_pSubTask)->_vptr$CTask + 5))(*p_m_pSubTask) != 725 )
      return *p_m_pSubTask;
    v22 = CTimer::m_snTimeInMilliseconds;
    if ( TheCamera.WhoIsInControlOfTheCamera == 1 )
    {
      this->m_iLastTimeCarMoving = CTimer::m_snTimeInMilliseconds;
      v23 = *((_WORD *)this + 22);
      this->m_iShagTimeLeft = 8000;
      result = this->m_pSubTask;
      *((_WORD *)this + 22) = v23 & 0xF67F | 0x880;
      return result;
    }
    v24 = this->m_pPunterPed->m_pMyVehicle;
    v25.n64_u64[0] = *(unsigned __int64 *)&v24->m_vecMoveSpeed.y;
    v26 = v24->m_vecMoveSpeed.x * 50.0;
    v27 = *((_WORD *)this + 22);
    v28.n64_u64[0] = vmul_f32(v25, (float32x2_t)0x4248000042480000LL).n64_u64[0];
    v29 = vmul_f32(v28, v28).n64_u64[0];
    v30 = (float)((float)(v26 * v26) + *(float *)&v29) + *((float *)&v29 + 1);
    if ( v30 >= 0.5625 || (v27 & 0x80) != 0 )
    {
      *((_WORD *)this + 22) = v27 & 0xFF7F;
      this->m_iLastTimeCarMoving = v22;
    }
    PlayerWanted = FindPlayerWanted(-1);
    v103 = v22;
    if ( v22 > this->m_iNextTimeToScanForPeds )
    {
      v32 = 0;
      v33 = *((_WORD *)this + 22) & 0xFFC7;
      this->m_iNextTimeToScanForPeds = v22 + 1000;
      *((_WORD *)this + 22) = v33;
      m_entities = pPed->m_pPedIntelligence->m_pedScanner.m_entities;
      do
      {
        v35 = (CPed *)m_entities[v32];
        if ( v35 )
        {
          m_pPunterPed = this->m_pPunterPed;
          v37 = v35 == m_pPunterPed;
          if ( v35 != m_pPunterPed )
            v37 = v35->m_nPedType == 22;
          if ( !v37 )
          {
            v38 = pPed->m_pMat;
            v39 = v35->m_pMat;
            p_m_transform = (CSimpleTransform *)&v38->tx;
            v37 = v38 == 0;
            p_m_translate = &v35->m_transform.m_translate;
            if ( v37 )
              p_m_transform = &pPed->m_transform;
            v42 = &v35->m_transform;
            if ( v39 )
              v42 = (CSimpleTransform *)&v39->tx;
            v43.n64_u64[0] = vsub_f32(
                               *(float32x2_t *)&v42->m_translate.y,
                               *(float32x2_t *)&p_m_transform->m_translate.y).n64_u64[0];
            v44 = vmul_f32(v43, v43).n64_u64[0];
            v45 = (float)((float)((float)(v42->m_translate.x - p_m_transform->m_translate.x)
                                * (float)(v42->m_translate.x - p_m_transform->m_translate.x))
                        + *(float *)&v44)
                + *((float *)&v44 + 1);
            if ( v45 < 56.25 )
              *((_WORD *)this + 22) |= 0x10u;
            if ( v45 < 400.0 )
              *((_WORD *)this + 22) |= 8u;
            if ( v35->m_nPedType == 6 )
            {
              v46 = PlayerWanted == 0;
              if ( PlayerWanted )
                v46 = (*((_WORD *)this + 22) & 2) == 0;
              if ( !v46 && PlayerWanted->m_WantedLevel <= WANTED_CLEAN )
              {
                v47 = m_pPunterPed->m_pMyVehicle;
                m_nFlags = (int)v47->m_nFlags;
                bdummy = v47->m_nFlags.bdummy;
                *(_DWORD *)&v47->m_nFlags = m_nFlags & 0xFFFFFFFE;
                v47->m_nFlags.bdummy = bdummy;
                v49 = this->m_pPunterPed;
                v50 = (const CVector *)v35->m_pMat;
                v51 = v49->m_pMat;
                if ( v50 )
                  p_m_translate = v50 + 4;
                v52 = (const CVector *)&v51->tx;
                if ( !v51 )
                  v52 = &v49->m_transform.m_translate;
                v53 = PlayerWanted;
                IsLineOfSightClear = CWorld::GetIsLineOfSightClear(p_m_translate, v52, 1, 1, 0, 1, 0, 1, 0);
                PlayerWanted = v53;
                *(_DWORD *)&this->m_pPunterPed->m_pMyVehicle->m_nFlags = *(_DWORD *)&this->m_pPunterPed->m_pMyVehicle->m_nFlags & 0xFFFFFFFE | m_nFlags & 1;
                if ( IsLineOfSightClear )
                  *((_WORD *)this + 22) |= 0x20u;
              }
            }
          }
        }
        ++v32;
      }
      while ( v32 != 16 );
    }
    v55 = *((_WORD *)this + 22);
    if ( (v55 & 1) != 0 )
    {
      if ( v30 < 0.5625 && v103 - this->m_iLastTimeCarMoving > 0xFA0 )
      {
        if ( (v55 & 8) != 0 )
        {
          if ( (*((_WORD *)this + 22) & 0x1000) == 0 )
          {
            v63 = CText::Get(&TheText, "PROS_01");
            CMessages::AddMessage("PROS_01", v63, 0xBB8u, 1u, 1);
            *((_WORD *)this + 22) |= 0x1000u;
          }
        }
        else
        {
          this->m_iSecondsCounter = v103;
          *((_WORD *)this + 22) = v55 & 0xFFFC | 2;
          v58 = CText::Get(&TheText, "PROS_02");
          CMessages::AddMessage("PROS_02", v58, 0x7D0u, 1u, 1);
        }
      }
      return *p_m_pSubTask;
    }
    if ( (v55 & 2) == 0 )
      return *p_m_pSubTask;
    v56 = PlayerWanted;
    if ( (v55 & 0x40) != 0 )
    {
      this->m_iShagTimeLeft = 15000;
      *((_WORD *)this + 22) = v55 & 0xFFBF;
      CStats::IncrementStat(0xBEu, 1.0);
    }
    if ( CPad::GetAccelerate(Pads) )
      v57 = 1;
    else
      v57 = CPad::GetBrake(Pads) != 0;
    v59 = rand();
    v60 = *((_WORD *)this + 22);
    v61 = v56 == 0;
    v62 = 0;
    if ( v56 )
      v61 = (v60 & 0x20) == 0;
    if ( !v61 )
    {
      if ( v56->m_WantedLevel > WANTED_CLEAN )
      {
        v62 = 0;
        if ( !v57 )
          goto LABEL_87;
        goto LABEL_84;
      }
      v64 = v59;
      v65 = FindPlayerWanted(-1);
      v62 = 1;
      CWanted::SetWantedLevel(v65, 1);
      v60 = *((_WORD *)this + 22);
      v59 = v64;
    }
    if ( !v57 )
    {
LABEL_87:
      if ( !(v62 | ((unsigned __int8)(v60 & 0x10) >> 4)) )
      {
        v70 = v59;
        v71 = (unsigned __int16)this->m_iShaggingFreq - v11;
        this->m_iShaggingFreq = v71;
        if ( v71 << 16 >= 0x10000 )
        {
          p_m_iShagTimeLeft = &this->m_iShagTimeLeft;
        }
        else
        {
          v72 = (float)rand();
          p_m_iShagTimeLeft = &this->m_iShagTimeLeft;
          m_iShagTimeLeft = this->m_iShagTimeLeft;
          v75 = (float)((float)(v72 * -4.6566e-10) * 0.4) + -0.5;
          if ( m_iShagTimeLeft < 10001 )
          {
            if ( m_iShagTimeLeft < 5001 )
            {
              if ( m_iShagTimeLeft <= 1000 )
              {
                this->m_iShaggingFreq = 850;
                Pad = CPad::GetPad(0);
                CPad::StartShake(Pad, 1000, 0x78u, 0);
                v75 = v75 * 0.5;
              }
              else
              {
                this->m_iShaggingFreq = 120;
              }
            }
            else
            {
              this->m_iShaggingFreq = 450;
            }
          }
          else
          {
            this->m_iShaggingFreq = 850;
          }
          v78 = this->m_pPunterPed;
          v79 = v78->m_pMyVehicle;
          v80 = v79->m_pMat;
          p_x = &v80->tx;
          if ( !v80 )
            p_x = &v79->m_transform.m_translate.x;
          v82 = v78->m_pMat;
          v83 = *p_x;
          v84 = p_x[1];
          v85 = (CSimpleTransform *)&v82->tx;
          if ( !v82 )
            v85 = &v78->m_transform;
          v86 = *(double *)&v85->m_translate.x;
          z = v85->m_translate.z;
          v104 = v86;
          v4.n64_u32[0] = LODWORD(v78->m_fMass);
          v2.n64_f32[0] = v79->m_fMass / 15.0;
          v3.n64_u32[0] = 1125515264;
          v87 = v75 * vmax_f32(vmin_f32(v2, v3), v4).n64_f32[0];
          if ( v70 << 31 )
          {
            v89 = (CSimpleTransform *)&v104;
          }
          else
          {
            v88 = pPed->m_pMat;
            v89 = (CSimpleTransform *)&v88->tx;
            if ( !v88 )
              v89 = &pPed->m_transform;
          }
          v106.z = v87;
          v90 = v89->m_translate.x - v83;
          *(float *)&v91 = v89->m_translate.y - v84;
          v106.x = 0.0;
          v106.y = 0.0;
          bOverideSilence.x = v90;
          *(_QWORD *)&bOverideSilence.y = v91;
          CPhysical::ApplyTurnForce(v79, v106, bOverideSilence);
          CAEVehicleAudioEntity::AddAudioEvent(&this->m_pPunterPed->m_pMyVehicle->m_VehicleAudioEntity, 108, 0.0);
          if ( v70 >= 0x10000000 && (*((_WORD *)this + 22) & 0x200) != 0 )
          {
            if ( (unsigned __int16)v70 <= 0xFEu )
              v92 = 112;
            else
              v92 = 116;
            CPed::Say(pPed, v92, 0, 0.5, 0, 0, 0);
          }
        }
        v93 = (unsigned __int16)*p_m_iShagTimeLeft - v11;
        *p_m_iShagTimeLeft = v93;
        if ( v93 << 16 < 0x10000 )
        {
          v94 = *((_WORD *)this + 22);
          this->m_iShagTimeLeft = 3000;
          *((_WORD *)this + 22) = v94 & 0xFFF9 | 4;
        }
        if ( v103 - this->m_iSecondsCounter > 0x3E8 )
        {
          v95 = (CPlayerPed *)this->m_pPunterPed;
          this->m_iSecondsCounter = v103;
          PlayerInfoForThisPlayerPed = CPlayerPed::GetPlayerInfoForThisPlayerPed(v95);
          Score = PlayerInfoForThisPlayerPed->Score;
          if ( CCheat::m_aCheatsActive[98] )
          {
            PlayerInfoForThisPlayerPed->Score = Score + 2;
          }
          else if ( Score < 2 )
          {
            PlayerInfoForThisPlayerPed->Score = 0;
            v98 = *((_WORD *)this + 22);
            this->m_iShagTimeLeft = 0;
            *((_WORD *)this + 22) = v98 & 0xFFF9 | 4;
            CMessages::ClearMessages(0);
            v99 = CText::Get(&TheText, "PROS_06");
            CMessages::AddMessage("PROS_06", v99, 0x7D0u, 1u, 1);
            v100 = CText::Get(&TheText, "PROS_09");
            CMessages::AddMessage("PROS_09", v100, 0xBB8u, 1u, 1);
          }
          else
          {
            PlayerInfoForThisPlayerPed->Score = Score - 2;
            CStats::IncrementStat(0x21u, 2.0);
            ++pPed->m_MoneyCarried;
          }
          if ( (*((_BYTE *)this + 45) & 8) == 0 )
            CPlayerInfo::AddHealth(PlayerInfoForThisPlayerPed, 2);
        }
        return *p_m_pSubTask;
      }
      this->m_iLastTimeCarMoving = v103;
      v68 = v60 & 0xF7FC;
      v69 = this->m_iShagTimeLeft;
      *((_WORD *)this + 22) = v68 | 0x801;
      if ( v69 <= 2999 )
      {
        this->m_iShagTimeLeft = 0;
        *((_WORD *)this + 22) = v68 | 0x805;
        return *p_m_pSubTask;
      }
      v76 = CText::Get(&TheText, "PROS_01");
      CMessages::AddMessage("PROS_01", v76, 0xBB8u, 1u, 1);
      goto LABEL_94;
    }
LABEL_84:
    this->m_iLastTimeCarMoving = v103;
    v66 = v60 & 0xF7FC;
    *((_WORD *)this + 22) = v66 | 0x801;
    if ( v59 < 0x1FFFFFFF || this->m_iShagTimeLeft <= 2999 )
    {
      this->m_iShagTimeLeft = 0;
      *((_WORD *)this + 22) = v66 | 0x805;
      v67 = CText::Get(&TheText, "PROS_09");
      CMessages::AddMessage("PROS_09", v67, 0xBB8u, 1u, 1);
      return *p_m_pSubTask;
    }
LABEL_94:
    this->m_iShagTimeLeft = 8000;
    return *p_m_pSubTask;
  }
  if ( !CPad::ConversationYesJustDown(Pads) )
  {
    if ( CPad::ConversationNoJustDown(Pads) )
    {
      v21 = this->m_pPunterPed;
      if ( v21 )
        CPed::Say(v21, 0xC3u, 0, 1.0, 0, 0, 0);
LABEL_29:
      *((_WORD *)this + 22) |= 4u;
      return *p_m_pSubTask;
    }
    return *p_m_pSubTask;
  }
  v13 = this->m_pPunterPed;
  *((_WORD *)this + 22) |= 0x400u;
  if ( v13 )
    CPed::Say(v13, 0xC4u, 0, 1.0, 0, 0, 0);
  return (CTask *)(*((int (__fastcall **)(CTaskComplexProstituteSolicit *, CPed *))this->_vptr$CTask + 10))(this, pPed);
}
// 51C23E: variable 'v2' is possibly undefined
// 51C23E: variable 'v3' is possibly undefined
// 51C242: variable 'v4' is possibly undefined
// 10168: using guessed type int elf_hash_chain[22025];

//----- (0051C420) --------------------------------------------------------
CTask *__fastcall CTaskComplexGangLeader::Clone(const CTaskComplexGangLeader *this)
{
  CTaskComplex *v2; // r0
  CTask *m_pPedGroup; // r4
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x38u);
  m_pPedGroup = (CTask *)this->m_pPedGroup;
  CTaskComplex::CTaskComplex(v2);
  LOWORD(result[3]._vptr$CTask) = 0;
  LOWORD(result[4].m_pParent) = 0;
  result[3].m_pParent = 0;
  result[4]._vptr$CTask = 0;
  LOWORD(result[6]._vptr$CTask) = 0;
  result[5]._vptr$CTask = 0;
  result[5].m_pParent = 0;
  result[1].m_pParent = m_pPedGroup;
  result[2]._vptr$CTask = 0;
  result[2].m_pParent = 0;
  LOBYTE(result[6].m_pParent) = 0;
  result->_vptr$CTask = (int (**)(void))&off_66BD6C;
  return result;
}
// 51C436: variable 'result' is possibly undefined
// 66BD6C: using guessed type void *off_66BD6C;

//----- (0051C45C) --------------------------------------------------------
int __fastcall CTaskComplexGangLeader::GetTaskType(const CTaskComplexGangLeader *this)
{
  return 1201;
}

//----- (0051C462) --------------------------------------------------------
int __fastcall CTaskComplexGangFollower::GetTaskType(const CTaskComplexGangFollower *this)
{
  return 1207;
}

//----- (0051C468) --------------------------------------------------------
CTask *__fastcall CTaskSimpleGoToPointFine::Clone(const CTaskSimpleGoToPointFine *this)
{
  CTaskSimpleGoTo *v2; // r0
  __int64 v3; // kr00_8
  __int64 v4; // kr08_8
  float m_moveBlendRatio; // r4
  CTask *result; // r0
  CVector vTarget; // [sp+4h] [bp-14h] BYREF

  v2 = (CTaskSimpleGoTo *)CTask::operator new(0x24u);
  v3 = *(_QWORD *)&this->m_vTarget.x;
  v4 = *(_QWORD *)&this->m_vTarget.z;
  m_moveBlendRatio = this->m_moveBlendRatio;
  *(_QWORD *)&vTarget.x = v3;
  LODWORD(vTarget.z) = v4;
  CTaskSimpleGoTo::CTaskSimpleGoTo(v2, 4, &vTarget, *((const float *)&v4 + 1));
  *(float *)&result[4]._vptr$CTask = m_moveBlendRatio;
  result->_vptr$CTask = (int (**)(void))&off_66BDE8;
  return result;
}
// 51C490: variable 'result' is possibly undefined
// 66BDE8: using guessed type void *off_66BDE8;

//----- (0051C4A4) --------------------------------------------------------
int __fastcall CTaskSimpleGoToPointFine::GetTaskType(const CTaskSimpleGoToPointFine *this)
{
  return 926;
}

//----- (0051C4AA) --------------------------------------------------------
int __fastcall CTaskComplexTrackEntity::GetTaskType(const CTaskComplexTrackEntity *this)
{
  return 925;
}

//----- (0051C4B0) --------------------------------------------------------
int __fastcall CTaskGangHassleVehicle::GetTaskType(const CTaskGangHassleVehicle *this)
{
  return 1205;
}

//----- (0051C4B8) --------------------------------------------------------
CTask *__fastcall CTaskGangHasslePed::Clone(const CTaskGangHasslePed *this)
{
  void *v2; // r4
  CPed *m_pPed; // r5
  __int64 v4; // r8
  int32 m_hassleTimeMax; // r6

  v2 = CTask::operator new(0x2Cu);
  m_pPed = this->m_pPed;
  v4 = *(_QWORD *)&this->m_hassleType;
  m_hassleTimeMax = this->m_hassleTimeMax;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_WORD *)v2 + 20) = 0;
  *((_QWORD *)v2 + 2) = v4;
  *((_DWORD *)v2 + 6) = m_hassleTimeMax;
  *((_BYTE *)v2 + 28) = 0;
  *((_DWORD *)v2 + 8) = 0;
  *((_DWORD *)v2 + 9) = 0;
  *(_DWORD *)v2 = &off_66BE94;
  *((_DWORD *)v2 + 3) = m_pPed;
  if ( m_pPed )
    CEntity::RegisterReference(m_pPed, (CEntity **)v2 + 3);
  return (CTask *)v2;
}
// 66BE94: using guessed type void *off_66BE94;

//----- (0051C510) --------------------------------------------------------
int __fastcall CTaskGangHasslePed::GetTaskType(const CTaskGangHasslePed *this)
{
  return 1212;
}

//----- (0051C516) --------------------------------------------------------
int __fastcall CTaskComplexStareAtPed::GetTaskType(const CTaskComplexStareAtPed *this)
{
  return 257;
}

//----- (0051C51C) --------------------------------------------------------
int __fastcall CTaskSimpleDoHandSignal::GetTaskType(const CTaskSimpleDoHandSignal *this)
{
  return 1214;
}

//----- (0051C524) --------------------------------------------------------
CTask *__fastcall CTaskComplexSignalAtPed::Clone(const CTaskComplexSignalAtPed *this)
{
  CTaskComplex *v2; // r0
  CPed *m_pPed; // r5
  CTaskComplex *v4; // r4

  v2 = (CTaskComplex *)CTask::operator new(0x18u);
  m_pPed = this->m_pPed;
  v4 = v2;
  LOBYTE(this) = this->m_playAnimAtEnd;
  CTaskComplex::CTaskComplex(v2);
  v4[1].m_pParent = 0;
  LOBYTE(v4[1].m_pSubTask) = (_BYTE)this;
  BYTE1(v4[1].m_pSubTask) = 0;
  v4->_vptr$CTask = (int (**)(void))&off_66BF40;
  v4[1]._vptr$CTask = (int (**)(void))m_pPed;
  if ( m_pPed )
    CEntity::RegisterReference(m_pPed, (CEntity **)&v4[1]);
  return v4;
}
// 66BF40: using guessed type void *off_66BF40;

//----- (0051C570) --------------------------------------------------------
int __fastcall CTaskComplexSignalAtPed::GetTaskType(const CTaskComplexSignalAtPed *this)
{
  return 1210;
}

//----- (0051C578) --------------------------------------------------------
CTask *__fastcall CTaskGoToVehicleAndLean::Clone(const CTaskGoToVehicleAndLean *this)
{
  void *v2; // r4
  __int64 v3; // kr00_8

  v2 = CTask::operator new(0x24u);
  v3 = *(_QWORD *)&this->m_pVehicle;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_DWORD *)v2 + 4) = HIDWORD(v3);
  *((_BYTE *)v2 + 20) = 0;
  *(_DWORD *)v2 = &off_66BF7C;
  *((_DWORD *)v2 + 3) = v3;
  if ( (_DWORD)v3 )
    CEntity::RegisterReference((CEntity *)v3, (CEntity **)v2 + 3);
  return (CTask *)v2;
}
// 66BF7C: using guessed type void *off_66BF7C;

//----- (0051C5C0) --------------------------------------------------------
int __fastcall CTaskGoToVehicleAndLean::GetTaskType(const CTaskGoToVehicleAndLean *this)
{
  return 1216;
}

//----- (0051C5C6) --------------------------------------------------------
int __fastcall CTaskLeanOnVehicle::GetTaskType(const CTaskLeanOnVehicle *this)
{
  return 1217;
}

//----- (0051C5CC) --------------------------------------------------------
CTask *__fastcall CTaskComplexPassObject::Clone(const CTaskComplexPassObject *this)
{
  CTaskComplex *v2; // r0
  CPed *m_pPed; // r5
  CTaskComplex *v4; // r4

  v2 = (CTaskComplex *)CTask::operator new(0x30u);
  m_pPed = this->m_pPed;
  v4 = v2;
  LOBYTE(this) = this->m_isPasser;
  CTaskComplex::CTaskComplex(v2);
  LOWORD(v4[3].m_pParent) = 0;
  LOBYTE(v4[1].m_pParent) = (_BYTE)this;
  v4[2].m_pSubTask = 0;
  v4[3]._vptr$CTask = 0;
  v4->_vptr$CTask = (int (**)(void))&off_66BFEC;
  v4[1]._vptr$CTask = (int (**)(void))m_pPed;
  if ( m_pPed )
    CEntity::RegisterReference(m_pPed, (CEntity **)&v4[1]);
  return v4;
}
// 66BFEC: using guessed type void *off_66BFEC;

//----- (0051C618) --------------------------------------------------------
int __fastcall CTaskComplexPassObject::GetTaskType(const CTaskComplexPassObject *this)
{
  return 1211;
}

//----- (0051C620) --------------------------------------------------------
CTask *__fastcall CTaskComplexGangJoinRespond::Clone(const CTaskComplexGangJoinRespond *this)
{
  CTaskComplex *v2; // r0
  CTask *result; // r0

  v2 = (CTaskComplex *)CTask::operator new(0x14u);
  LOBYTE(this) = this->m_response;
  CTaskComplex::CTaskComplex(v2);
  LOBYTE(result[1].m_pParent) = (_BYTE)this;
  BYTE1(result[1].m_pParent) = 0;
  result->_vptr$CTask = (int (**)(void))&off_66C028;
  return result;
}
// 51C636: variable 'result' is possibly undefined
// 66C028: using guessed type void *off_66C028;

//----- (0051C648) --------------------------------------------------------
int __fastcall CTaskComplexGangJoinRespond::GetTaskType(const CTaskComplexGangJoinRespond *this)
{
  return 1219;
}

//----- (0051C650) --------------------------------------------------------
void __fastcall CTaskComplexGangJoinRespond::Serialize(CTaskComplexGangJoinRespond *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  int v4; // r0

  v2 = (*((int (__fastcall **)(CTaskComplexGangJoinRespond *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexGangJoinRespond *))this->_vptr$CTask + 5))(this) == 1219 )
  {
    if ( UseDataFence )
      AddDataFence();
    sub_19E9A8(&this->m_response, 1);
  }
  else
  {
    v4 = (*((int (__fastcall **)(CTaskComplexGangJoinRespond *))this->_vptr$CTask + 5))(this);
    sub_1941C4(1219, v4);
  }
}

//----- (0051C6E0) --------------------------------------------------------
CTask *__fastcall CTaskComplexProstituteSolicit::Clone(const CTaskComplexProstituteSolicit *this)
{
  void *v2; // r5
  CPed *m_pPunterPed; // r4
  __int16 v4; // r3

  v2 = CTask::operator new(0x30u);
  m_pPunterPed = this->m_pPunterPed;
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  v4 = *((_WORD *)v2 + 22);
  *((_DWORD *)v2 + 7) = 0;
  *((_DWORD *)v2 + 8) = 0;
  *((_DWORD *)v2 + 9) = 0;
  *((_DWORD *)v2 + 10) = 850;
  *(_DWORD *)v2 = &off_66C064;
  *((_WORD *)v2 + 22) = v4 & 0xE000 | 0x2C0;
  *((_DWORD *)v2 + 3) = m_pPunterPed;
  CEntity::RegisterReference(m_pPunterPed, (CEntity **)v2 + 3);
  return (CTask *)v2;
}
// 66C064: using guessed type void *off_66C064;

//----- (0051C72C) --------------------------------------------------------
int __fastcall CTaskComplexProstituteSolicit::GetTaskType(const CTaskComplexProstituteSolicit *this)
{
  return 1309;
}

//----- (0051C734) --------------------------------------------------------
void __fastcall CTaskComplexProstituteSolicit::Serialize(CTaskComplexProstituteSolicit *this)
{
  int v2; // r5
  _DWORD *v3; // r6
  CPed *m_pPunterPed; // r0
  int v5; // r4
  _DWORD *v6; // r5
  void *v7; // r0
  int v8; // r0
  _DWORD *v9; // r4

  v2 = (*((int (__fastcall **)(CTaskComplexProstituteSolicit *))this->_vptr$CTask + 5))(this);
  if ( UseDataFence )
    AddDataFence();
  v3 = malloc(4u);
  *v3 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  if ( (*((int (__fastcall **)(CTaskComplexProstituteSolicit *))this->_vptr$CTask + 5))(this) == 1309 )
  {
    m_pPunterPed = this->m_pPunterPed;
    if ( m_pPunterPed )
    {
      v5 = GettPoolPedRef(m_pPunterPed);
      if ( UseDataFence )
        AddDataFence();
      v6 = malloc(4u);
      *v6 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      v7 = v6;
    }
    else
    {
      if ( UseDataFence )
        AddDataFence();
      v9 = malloc(4u);
      *v9 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      v7 = v9;
    }
    j_free(v7);
  }
  else
  {
    v8 = (*((int (__fastcall **)(CTaskComplexProstituteSolicit *))this->_vptr$CTask + 5))(this);
    sub_1941C4(1309, v8);
  }
}

//----- (0051C810) --------------------------------------------------------
void __fastcall CTaskSimpleGoTo::CTaskSimpleGoTo(
        CTaskSimpleGoTo *this,
        const int iMoveState,
        const CVector *vTarget,
        const float fTargetRadius)
{
  int v7; // r0
  char v8; // r2
  __int64 v9; // d16

  CTaskSimple::CTaskSimple(this);
  *(_DWORD *)(v7 + 8) = iMoveState;
  *(_DWORD *)v7 = &off_66C0A0;
  v8 = *(_BYTE *)(v7 + 28);
  v9 = *(_QWORD *)&vTarget->x;
  *(RwReal *)(v7 + 20) = vTarget->z;
  *(const float *)(v7 + 24) = fTargetRadius;
  *(_BYTE *)(v7 + 28) = v8 & 0xC0;
  *(_QWORD *)(v7 + 12) = v9;
}
// 51C824: variable 'v7' is possibly undefined
// 66C0A0: using guessed type void *off_66C0A0;

//----- (0051C856) --------------------------------------------------------
bool __fastcall CTaskSimpleGoTo::HasCircledTarget(CTaskSimpleGoTo *this, CPed *pPed)
{
  CMatrix *m_pMat; // r3
  CSimpleTransform *p_tx; // r2
  float x; // s2
  float y; // s0
  float v6; // s4
  char v7; // r1
  float v8; // s2
  char v9; // r1
  char v10; // r1

  m_pMat = pPed->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  x = p_tx->m_translate.x;
  y = p_tx->m_translate.y;
  if ( (*((_BYTE *)&pPed->m_nPedFlags + 12) & 0x40) == 0 && fabsf(p_tx->m_translate.z - this->m_vTarget.z) >= 2.0 )
    return 0;
  v6 = this->m_vTarget.x;
  if ( x >= v6 )
  {
    if ( x <= v6 )
      goto LABEL_10;
    v7 = 2;
  }
  else
  {
    v7 = 1;
  }
  *((_BYTE *)this + 28) = (v7 | *((_BYTE *)this + 28)) & 0xF | *((_BYTE *)this + 28) & 0xF0;
LABEL_10:
  v8 = this->m_vTarget.y;
  if ( y < v8 )
  {
    v9 = 4;
LABEL_14:
    v10 = (v9 | *((_BYTE *)this + 28)) & 0xF | (16 * (*((_BYTE *)this + 28) >> 4));
    *((_BYTE *)this + 28) = v10;
    return (v10 & 0xF) == 15;
  }
  if ( y > v8 )
  {
    v9 = 8;
    goto LABEL_14;
  }
  v10 = *((_BYTE *)this + 28);
  return (v10 & 0xF) == 15;
}

//----- (0051C900) --------------------------------------------------------
void __fastcall CTaskSimpleGoTo::SetUpIK(CTaskSimpleGoTo *this, CPed *pPed)
{
  CPad *Pad; // r6
  CPlayerPed *PlayerPed; // r0
  bool v6; // zf
  CTask *m_pParent; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r6
  CSimpleTransform *p_tx; // r1
  RwReal v11; // s0
  RwReal v12; // s4
  CMatrix *v13; // r0
  float v14; // s4
  float x; // s6
  RwV3d_0 pOffsetPos; // [sp+20h] [bp-28h] BYREF
  CVector v17; // [sp+2Ch] [bp-1Ch] BYREF

  Pad = CPad::GetPad(0);
  if ( CEntity::GetIsOnScreen(pPed)
    && (*((_BYTE *)this + 28) & 0x10) == 0
    && !IKChainManager_c::GetLookAtEntity(&g_ikChainMan, pPed)
    && !CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 5) )
  {
    PlayerPed = FindPlayerPed(-1);
    v6 = PlayerPed == pPed;
    if ( PlayerPed == pPed )
      v6 = Pad->DisablePlayerControls == 0;
    if ( !v6 )
    {
      m_pParent = this->m_pParent;
      if ( !m_pParent
        || (*((int (__fastcall **)(CTask *))m_pParent->_vptr$CTask + 5))(m_pParent) != 917
        && (*((int (__fastcall **)(CTask *))this->m_pParent->CTaskSimple::CTask::_vptr$CTask + 5))(this->m_pParent) != 939 )
      {
        m_pMat = pPed->m_pMat;
        p_m_transform = &pPed->m_transform;
        p_tx = &pPed->m_transform;
        if ( m_pMat )
          p_tx = (CSimpleTransform *)&m_pMat->tx;
        v11 = this->m_vTarget.x - p_tx->m_translate.x;
        v12 = this->m_vTarget.z - p_tx->m_translate.z;
        v17.y = this->m_vTarget.y - p_tx->m_translate.y;
        v17.x = v11;
        v17.z = v12;
        if ( (float)((float)((float)(v11 * v11) + (float)(v17.y * v17.y)) + (float)(v12 * v12)) > 9.0 )
        {
          CVector::Normalise(&v17);
          v13 = pPed->m_pMat;
          if ( (float)((float)((float)(v17.x * v13->xy) + (float)(v17.y * v13->yy)) + (float)(v17.z * v13->zy)) < g_PedIkDiffDot )
          {
            if ( v13 )
              p_m_transform = (CSimpleTransform *)&v13->tx;
            v14 = (float)(v17.z + v17.z) + p_m_transform->m_translate.z;
            x = this->m_vTarget.x;
            pOffsetPos.y = (float)(v17.y + v17.y) + this->m_vTarget.y;
            pOffsetPos.x = (float)(v17.x + v17.x) + x;
            pOffsetPos.z = v14 + 0.61;
            IKChainManager_c::LookAt(&g_ikChainMan, "TaskGoTo", pPed, 0, 5000, -1, &pOffsetPos, 0, 0.25, 500, 3, 0);
            *((_BYTE *)this + 28) |= 0x10u;
          }
        }
      }
    }
  }
}

//----- (0051CAC4) --------------------------------------------------------
void __fastcall CTaskSimpleGoTo::QuitIK(CTaskSimpleGoTo *this, CPed *pPed)
{
  if ( (*((_BYTE *)this + 28) & 0x10) != 0 )
  {
    if ( IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
      sub_1A0E80(&g_ikChainMan, pPed, 250);
  }
}

//----- (0051CAFC) --------------------------------------------------------
void __fastcall CTaskSimpleGoToPoint::CTaskSimpleGoToPoint(
        CTaskSimpleGoToPoint *this,
        const int iMoveState,
        const CVector *vTarget,
        const float fTargetRadius,
        const bool bSlowSmoothlyApproachTarget,
        const bool bMustOverShootTarget)
{
  int v9; // r0
  RwReal z; // r1
  char v11; // r3
  __int64 v12; // d16

  CTaskSimple::CTaskSimple(this);
  *(_DWORD *)(v9 + 8) = iMoveState;
  *(_DWORD *)v9 = &off_66C0A0;
  z = vTarget->z;
  v11 = *(_BYTE *)(v9 + 29);
  v12 = *(_QWORD *)&vTarget->x;
  LOBYTE(vTarget) = *(_BYTE *)(v9 + 28);
  *(RwReal *)(v9 + 20) = z;
  *(_DWORD *)v9 = &off_66C0D4;
  *(const float *)(v9 + 24) = fTargetRadius;
  *(_BYTE *)(v9 + 29) = bSlowSmoothlyApproachTarget | (8 * bMustOverShootTarget) | v11 & 0xE0;
  *(_BYTE *)(v9 + 28) = (unsigned __int8)vTarget & 0xC0;
  *(_QWORD *)(v9 + 12) = v12;
}
// 51CB14: variable 'v9' is possibly undefined
// 66C0A0: using guessed type void *;
// 66C0D4: using guessed type void *;

//----- (0051CB60) --------------------------------------------------------
void __fastcall CTaskSimpleGoToPoint::~CTaskSimpleGoToPoint(CTaskSimpleGoToPoint *this)
{
  void *v1; // r0

  CTask::~CTask(this);
  sub_197118(v1);
}
// 51CB6C: variable 'v1' is possibly undefined

//----- (0051CB70) --------------------------------------------------------
bool __fastcall CTaskSimpleGoToPoint::MakeAbortable(
        CTaskSimpleGoToPoint *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  CTaskSimpleStandStill *v7; // r0
  CTaskSimpleStandStill v9; // [sp+8h] [bp-30h] BYREF

  if ( (*((_BYTE *)&this->CTaskSimpleGoTo:232 + 28) & 0x10) != 0 && IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
    IKChainManager_c::AbortLookAt(&g_ikChainMan, pPed, 250);
  if ( (unsigned int)(iPriority - 1) > 1 )
  {
    *((_BYTE *)this + 29) |= 2u;
    return 0;
  }
  else
  {
    if ( iPriority == 2 )
    {
      CTaskSimpleStandStill::CTaskSimpleStandStill(&v9, 0, 0, 0, 8.0);
      CTaskSimpleStandStill::ProcessPed(v7, pPed);
      CTaskSimpleStandStill::~CTaskSimpleStandStill(&v9);
    }
    return 1;
  }
}
// 51CBC2: variable 'v7' is possibly undefined

//----- (0051CBEC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
bool __fastcall CTaskSimpleGoToPoint::ProcessPed(CTaskSimpleGoToPoint *this, CPed *pPed)
{
  uint32 m_flags; // r0
  float32x2_t *p_m_transform; // r9
  CMatrix *m_pMat; // r1
  char v7; // r2
  float *p_tx; // r0
  float v9; // s2
  float v10; // s0
  float x; // s4
  char v12; // r0
  float y; // s2
  char v14; // r0
  int v15; // r0
  char v16; // r1
  bool v17; // zf
  CPedFlags *p_m_nPedFlags; // r8
  int v19; // r0
  CMatrix *v20; // r0
  float z; // s22
  float32x2_t v22; // d8
  float v23; // s24
  unsigned __int64 v24; // d0
  float v25; // s26
  float v26; // s0
  float v27; // s18
  float v28; // s20
  int v29; // r1
  __int64 v31; // r2
  int v32; // r0
  int v33; // r1
  CTaskSimpleDuck *TaskDuck; // r0
  int m_iMoveState; // r10
  CTaskSimpleDuck *v36; // r0
  int v37; // r2 OVERLAPPED
  int v38; // r1 OVERLAPPED
  AssocGroupId m_motionAnimGroup; // r10
  CAnimBlendAssocGroup *v40; // r4
  CPed *v41; // r0
  eMoveState v42; // r1
  CPlayerPed *v43; // r0
  CVector *p_m_vTarget; // r1
  char v45; // r0
  float v46; // s0
  float32x2_t v47; // d17
  float32x2_t v48; // d16
  float32x2_t v49; // d18
  unsigned __int64 v50; // d0
  bool v51; // nf
  const float *v52; // r1
  float32x2_t v53; // d18
  unsigned __int64 v54; // d0
  char v55; // r1
  float RadianAngleBetweenPoints; // r0
  char v57; // r1
  CAnimBlendAssocGroup *v58; // r10
  CAnimBlendHierarchy *m_pAnimBlendHierarchy; // r4

  m_flags = pPed->m_ik.m_flags;
  p_m_transform = (float32x2_t *)&pPed->m_transform;
  m_pMat = pPed->m_pMat;
  v7 = *((_BYTE *)&pPed->m_nPedFlags + 12);
  pPed->m_ik.m_flags = m_flags | 8;
  p_tx = (float *)p_m_transform;
  if ( m_pMat )
    p_tx = &m_pMat->tx;
  v9 = *p_tx;
  v10 = p_tx[1];
  if ( (v7 & 0x40) == 0 && fabsf(p_tx[2] - this->m_vTarget.z) >= 2.0 )
    goto LABEL_19;
  x = this->m_vTarget.x;
  if ( v9 >= x )
  {
    if ( v9 <= x )
      goto LABEL_10;
    v12 = 2;
  }
  else
  {
    v12 = 1;
  }
  *((_BYTE *)&this->CTaskSimpleGoTo:232 + 28) = (v12 | *((_BYTE *)&this->CTaskSimpleGoTo:232 + 28)) & 0xF | *((_BYTE *)&this->CTaskSimpleGoTo:232 + 28) & 0xF0;
LABEL_10:
  y = this->m_vTarget.y;
  if ( v10 < y )
  {
    v14 = 4;
LABEL_14:
    v15 = ((unsigned __int8)v14 | *((_BYTE *)&this->CTaskSimpleGoTo:232 + 28)) & 0xF | (16
                                                                                      * (*((unsigned __int8 *)&this->CTaskSimpleGoTo:232
                                                                                         + 28) >> 4));
    *((_BYTE *)&this->CTaskSimpleGoTo:232 + 28) = v15;
    goto LABEL_16;
  }
  if ( v10 > y )
  {
    v14 = 8;
    goto LABEL_14;
  }
  LOBYTE(v15) = *((_BYTE *)&this->CTaskSimpleGoTo:232 + 28);
LABEL_16:
  v16 = v15 & 0xF;
  v17 = (v15 & 0xF) == 15;
  if ( (v15 & 0xF) == 15 )
  {
    v16 = *((_BYTE *)this + 29);
    v17 = (v16 & 0x10) == 0;
  }
  if ( v17 )
  {
    *((_BYTE *)this + 29) = v16 | 4;
    if ( (v15 & 0x10) != 0 && IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
      goto LABEL_28;
    return 1;
  }
LABEL_19:
  p_m_nPedFlags = &pPed->m_nPedFlags;
  v19 = *((_DWORD *)&pPed->m_nPedFlags + 2);
  if ( (v19 & 8) != 0 )
  {
    CEventScanner::ScanForEventsNow(&pPed->m_pPedIntelligence->m_eventScanner, pPed, 0);
    v29 = -9;
  }
  else
  {
    if ( (v19 & 0x80) == 0 )
    {
      v20 = pPed->m_pMat;
      if ( v20 )
        p_m_transform = (float32x2_t *)&v20->tx;
      z = this->m_vTarget.z;
      v22.n64_u64[0] = vsub_f32(*(float32x2_t *)&this->m_vTarget.x, (float32x2_t)p_m_transform->n64_u64[0]).n64_u64[0];
      v23 = p_m_transform[1].n64_f32[0];
      v24 = vmul_f32(v22, v22).n64_u64[0];
      v25 = *(float *)&v24 + *((float *)&v24 + 1);
      if ( (float)(*(float *)&v24 + *((float *)&v24 + 1)) <= 0.0 )
      {
        v28 = 1.0;
        v27 = v22.n64_f32[1];
      }
      else
      {
        v26 = 1.0 / sqrtf(v25);
        v27 = v22.n64_f32[1] * v26;
        v28 = v22.n64_f32[0] * v26;
      }
      TaskDuck = CPedIntelligence::GetTaskDuck(pPed->m_pPedIntelligence, 0);
      m_iMoveState = this->m_iMoveState;
      if ( TaskDuck )
      {
        v36 = CPedIntelligence::GetTaskDuck(pPed->m_pPedIntelligence, 0);
        v37 = -1081291571;
        v38 = 0;
        if ( m_iMoveState == 4 )
          v37 = -1086324736;
        CTaskSimpleDuck::ControlDuckMove(v36, *(CVector2D *)&v38);
LABEL_56:
        v45 = *((_BYTE *)this + 29);
        v46 = this->m_fTargetRadius * this->m_fTargetRadius;
        v47.n64_u64[0] = *(unsigned __int64 *)&this->m_vLastPedPos.x;
        v48.n64_u64[0] = *(unsigned __int64 *)&this->m_vTarget.x;
        v49.n64_u64[0] = p_m_transform->n64_u64[0];
        LODWORD(this->m_vLastPedPos.z) = p_m_transform[1].n64_u32[0];
        *(float32x2_t *)&this->m_vLastPedPos.x = v49;
        if ( v25 >= v46
          || (v45 & 0x10) != 0
          || fabsf(v23 - z) >= 2.0 && (*((_DWORD *)&pPed->m_nPedFlags + 3) & 0x40) == 0
          || (v50 = vmul_f32(v22, vsub_f32(v48, v47)).n64_u64[0], (float)(*(float *)&v50 + *((float *)&v50 + 1)) >= 0.0)
          && (v45 & 8) != 0 )
        {
          v51 = (v45 & 8) != 0;
          if ( (v45 & 8) == 0 )
            v51 = (v45 & 0x10) != 0;
          if ( !v51 )
          {
            v52 = &CTimer::ms_fTimeStep;
            v53.n64_u64[0] = vld1_dup_f32(v52).n64_u64[0];
            v54 = vmul_f32(
                    v22,
                    vsub_f32(
                      v48,
                      vadd_f32(
                        vmul_f32(v53, *(float32x2_t *)&pPed->m_vecMoveSpeed.x),
                        (float32x2_t)p_m_transform->n64_u64[0]))).n64_u64[0];
            if ( (float)(*(float *)&v54 + *((float *)&v54 + 1)) <= 0.0 )
            {
              v55 = *((_BYTE *)&this->CTaskSimpleGoTo:232 + 28);
              *((_BYTE *)this + 29) = v45 | 4;
              if ( (v55 & 0x10) != 0 && IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
              {
LABEL_28:
                IKChainManager_c::AbortLookAt(&g_ikChainMan, pPed, 250);
                return 1;
              }
              return 1;
            }
          }
          if ( (v45 & 2) == 0 )
          {
            RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(v28, v27, 0.0, 0.0);
            pPed->m_fDesiredHeading = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
            goto LABEL_31;
          }
          if ( (*((_BYTE *)&this->CTaskSimpleGoTo:232 + 28) & 0x10) != 0
            && IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
          {
            goto LABEL_28;
          }
        }
        else
        {
          v57 = *((_BYTE *)&this->CTaskSimpleGoTo:232 + 28);
          *((_BYTE *)this + 29) = v45 | 4;
          if ( (v57 & 0x10) != 0 && IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
            goto LABEL_28;
        }
        return 1;
      }
      CPed::SetMoveState(pPed, (eMoveState)this->m_iMoveState);
      if ( !CPed::IsPlayer(pPed) )
      {
        (*((void (__fastcall **)(CPed *))pPed->_vptr$CPlaceable + 24))(pPed);
        goto LABEL_56;
      }
      if ( CPad::GetPad(0)->DisablePlayerControls )
        goto LABEL_53;
      if ( (CWeaponInfo::GetWeaponInfo(pPed->m_WeaponSlots[pPed->m_nCurrentWeapon].m_eWeaponType, 1)->m_nFlags & 0x200) != 0
        || CPedIntelligence::GetTaskHold(pPed->m_pPedIntelligence, 0)
        && CPedIntelligence::GetTaskHold(pPed->m_pPedIntelligence, 0)->m_pAnim
        || pPed->m_pPlayerData->m_bPlayerSprintDisabled
        || (m_motionAnimGroup = pPed->m_motionAnimGroup,
            v40 = CAnimManager::ms_aAnimAssocGroups,
            SurfaceInfos_c::CantSprintOn(&g_surfaceInfos, pPed->m_LastMaterialToHaveBeenStandingOn))
        || (v58 = &v40[m_motionAnimGroup],
            m_pAnimBlendHierarchy = CAnimBlendAssocGroup::GetAnimation(v58, 1u)->m_pAnimBlendHierarchy,
            m_pAnimBlendHierarchy == CAnimBlendAssocGroup::GetAnimation(v58, 2u)->m_pAnimBlendHierarchy)
        || CPlayerPed::ControlButtonSprint((CPlayerPed *)pPed, SPRINT_ON_FOOT) < 1.0 )
      {
        if ( pPed->m_eMoveState != PEDMOVE_SPRINT )
          goto LABEL_52;
        v41 = pPed;
        v42 = PEDMOVE_RUN;
      }
      else
      {
        v41 = pPed;
        v42 = PEDMOVE_SPRINT;
      }
      CPed::SetMoveState(v41, v42);
LABEL_52:
      if ( *((unsigned __int8 *)this + 29) << 31 )
      {
        v43 = (CPlayerPed *)pPed;
        p_m_vTarget = &this->m_vTarget;
        goto LABEL_54;
      }
LABEL_53:
      v43 = (CPlayerPed *)pPed;
      p_m_vTarget = 0;
LABEL_54:
      CPlayerPed::SetPlayerMoveBlendRatio(v43, p_m_vTarget);
      CPlayerPed::SetRealMoveAnim((CPlayerPed *)pPed);
      goto LABEL_56;
    }
    CEventScanner::ScanForEventsNow(&pPed->m_pPedIntelligence->m_eventScanner, pPed, 1);
    v29 = -129;
  }
  LODWORD(v31) = *(_DWORD *)p_m_nPedFlags;
  HIDWORD(v31) = *((_DWORD *)&pPed->m_nPedFlags + 1);
  v32 = *((_DWORD *)&pPed->m_nPedFlags + 3);
  v33 = v29 & *((_DWORD *)&pPed->m_nPedFlags + 2);
  *(_QWORD *)p_m_nPedFlags = v31;
  *((_DWORD *)&pPed->m_nPedFlags + 2) = v33;
  *((_DWORD *)&pPed->m_nPedFlags + 3) = v32;
LABEL_31:
  if ( (*((_BYTE *)&this->CTaskSimpleGoTo:232 + 28) & 0x20) != 0 )
  {
    if ( (*((_BYTE *)&this->CTaskSimpleGoTo:232 + 28) & 0x10) != 0 && IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
      IKChainManager_c::AbortLookAt(&g_ikChainMan, pPed, 250);
    *((_BYTE *)&this->CTaskSimpleGoTo:232 + 28) &= ~0x20u;
  }
  CTaskSimpleGoTo::SetUpIK((CTaskSimpleGoTo *)this, pPed);
  *((_BYTE *)this + 29) &= ~0x10u;
  return 0;
}
// 51CBEC: variables would overlap: r1.4 and r1.8
// 51CBEC: variables would overlap: r2.4 and r1.8

//----- (0051D06C) --------------------------------------------------------
void __fastcall CTaskSimpleAchieveHeading::CTaskSimpleAchieveHeading(
        CTaskSimpleAchieveHeading *this,
        const float fDesiredHeading,
        const float fHeadingChangeRateFrac,
        const float fHeadingTolerance)
{
  int v7; // r0
  char v8; // r2

  CTaskSimple::CTaskSimple(this);
  v8 = *(_BYTE *)(v7 + 20);
  *(const float *)(v7 + 8) = fDesiredHeading;
  *(const float *)(v7 + 12) = fHeadingChangeRateFrac;
  *(const float *)(v7 + 16) = fHeadingTolerance;
  *(_BYTE *)(v7 + 20) = v8 & 0xFE;
  *(_DWORD *)v7 = &off_66C108;
}
// 51D080: variable 'v7' is possibly undefined
// 66C108: using guessed type void *;

//----- (0051D0A4) --------------------------------------------------------
void __fastcall CTaskSimpleAchieveHeading::~CTaskSimpleAchieveHeading(CTaskSimpleAchieveHeading *this)
{
  void *v1; // r0

  CTask::~CTask(this);
  sub_197118(v1);
}
// 51D0B0: variable 'v1' is possibly undefined

//----- (0051D0B4) --------------------------------------------------------
void __fastcall CTaskSimpleAchieveHeading::QuitIK(CTaskSimpleAchieveHeading *this, CPed *pPed)
{
  if ( *((unsigned __int8 *)this + 20) << 31 )
  {
    if ( IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
      sub_1A0E80(&g_ikChainMan, pPed, 250);
  }
}

//----- (0051D0EC) --------------------------------------------------------
bool __fastcall CTaskSimpleAchieveHeading::MakeAbortable(
        CTaskSimpleAchieveHeading *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  if ( *((unsigned __int8 *)this + 20) << 31 && IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
    IKChainManager_c::AbortLookAt(&g_ikChainMan, pPed, 250);
  if ( iPriority == 2 )
  {
    pPed->m_fDesiredHeading = pPed->m_fCurrentHeading;
    CPed::RestoreHeadingRate(pPed);
    return 1;
  }
  else
  {
    this->m_fHeadingTolerance = 6.2832;
    pPed->m_fDesiredHeading = pPed->m_fCurrentHeading;
    return 0;
  }
}

//----- (0051D158) --------------------------------------------------------
void __fastcall CTaskSimpleAchieveHeading::SetUpIK(CTaskSimpleAchieveHeading *this, CPed *pPed)
{
  CPad *Pad; // r6
  CPlayerPed *PlayerPed; // r0
  bool v6; // zf
  _BOOL4 v7; // r0
  bool v8; // zf
  CTask *m_pParent; // r0
  float m_fDesiredHeading; // r6
  CMatrix *m_pMat; // r9
  float v12; // r8
  float v13; // s0
  CSimpleTransform *p_tx; // r0
  float v15; // s0
  RwReal v16; // s0
  RwReal v17; // s4
  RwV3d_0 pOffsetPos; // [sp+24h] [bp-24h] BYREF

  Pad = CPad::GetPad(0);
  PlayerPed = FindPlayerPed(-1);
  v6 = PlayerPed == pPed;
  if ( PlayerPed == pPed )
    v6 = Pad->DisablePlayerControls == 0;
  if ( !v6 )
  {
    v7 = CEntity::GetIsOnScreen(pPed);
    v8 = v7;
    if ( v7 )
      v8 = *((unsigned __int8 *)this + 20) << 31 == 0;
    if ( v8
      && !IKChainManager_c::GetLookAtEntity(&g_ikChainMan, pPed)
      && !CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 5) )
    {
      m_pParent = this->m_pParent;
      if ( !m_pParent
        || (*((int (__fastcall **)(CTask *))m_pParent->_vptr$CTask + 5))(m_pParent) != 917
        && (*((int (__fastcall **)(CTask *))this->m_pParent->CTaskSimple::CTask::_vptr$CTask + 5))(this->m_pParent) != 939 )
      {
        m_fDesiredHeading = this->m_fDesiredHeading;
        m_pMat = pPed->m_pMat;
        v12 = sinf(m_fDesiredHeading);
        v13 = cosf(m_fDesiredHeading);
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        v15 = v13 + v13;
        if ( !m_pMat )
          p_tx = &pPed->m_transform;
        v16 = p_tx->m_translate.y + v15;
        v17 = p_tx->m_translate.x + (float)(v12 + v12);
        pOffsetPos.z = p_tx->m_translate.z + 0.61;
        pOffsetPos.y = v16;
        pOffsetPos.x = v17;
        IKChainManager_c::LookAt(&g_ikChainMan, "TaskAchvHeading", pPed, 0, 5000, -1, &pOffsetPos, 0, 0.25, 500, 3, 0);
        *((_BYTE *)this + 20) |= 1u;
      }
    }
  }
}

//----- (0051D294) --------------------------------------------------------
bool __fastcall CTaskSimpleAchieveHeading::ProcessPed(CTaskSimpleAchieveHeading *this, CPed *pPed)
{
  float m_fCurrentHeading; // s0

  if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
    return 1;
  CPed::RestoreHeadingRate(pPed);
  pPed->m_fHeadingChangeRate = pPed->m_fHeadingChangeRate * this->m_fHeadingChangeRateFrac;
  CPed::SetMoveState(pPed, PEDMOVE_STILL);
  (*((void (__fastcall **)(CPed *))pPed->_vptr$CPlaceable + 24))(pPed);
  m_fCurrentHeading = pPed->m_fCurrentHeading;
  pPed->m_fDesiredHeading = this->m_fDesiredHeading;
  if ( COERCE_FLOAT(COERCE_UNSIGNED_INT(CGeneral::LimitRadianAngle(fabs(this->m_fDesiredHeading - m_fCurrentHeading))) & 0x7FFFFFFF) < this->m_fHeadingTolerance )
  {
    pPed->m_fDesiredHeading = pPed->m_fCurrentHeading;
    CPed::RestoreHeadingRate(pPed);
    if ( *((unsigned __int8 *)this + 20) << 31 && IKChainManager_c::IsLooking(&g_ikChainMan, pPed) )
    {
      IKChainManager_c::AbortLookAt(&g_ikChainMan, pPed, 250);
      return 1;
    }
    return 1;
  }
  CTaskSimpleAchieveHeading::SetUpIK(this, pPed);
  return 0;
}

//----- (0051D354) --------------------------------------------------------
void __fastcall CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(
        CTaskComplexGoToPointAndStandStill *this,
        const int iMoveState,
        const CVector *vTarget,
        const float fTargetRadius,
        const float fSlowDownDistance,
        const bool bMustOvershootTarget,
        const bool bStopExactly)
{
  int v10; // r0
  float v11; // s2
  char v12; // r1
  __int64 v13; // d16
  float v14; // s0
  float v15; // s2

  CTaskComplex::CTaskComplex(this);
  *(_DWORD *)(v10 + 12) = iMoveState;
  v11 = *(float *)(v10 + 16);
  v12 = *(_BYTE *)(v10 + 36) & 0xE4 | bMustOvershootTarget | (2 * bStopExactly);
  *(_BYTE *)(v10 + 36) = v12;
  *(_DWORD *)v10 = &off_66C13C;
  if ( v11 != vTarget->x
    || *(float *)(v10 + 20) != vTarget->y
    || *(float *)(v10 + 24) != vTarget->z
    || *(float *)(v10 + 32) != fSlowDownDistance )
  {
    v12 |= 4u;
    v13 = *(_QWORD *)&vTarget->x;
    *(RwReal *)(v10 + 24) = vTarget->z;
    *(const float *)(v10 + 28) = fTargetRadius;
    *(const float *)(v10 + 32) = fSlowDownDistance;
    *(_BYTE *)(v10 + 36) = v12;
    *(_QWORD *)(v10 + 16) = v13;
  }
  if ( (v12 & 2) != 0 )
  {
    v14 = *(float *)(v10 + 28);
    *(_BYTE *)(v10 + 36) = v12 & 0xFE;
    if ( iMoveState >= 5 )
      v15 = 1.0;
    else
      v15 = 0.5;
    if ( v14 >= v15 )
      v15 = v14;
    *(_DWORD *)(v10 + 32) = 0;
    *(float *)(v10 + 28) = v15;
  }
}
// 51D36A: variable 'v10' is possibly undefined
// 66C13C: using guessed type void *;

//----- (0051D434) --------------------------------------------------------
void __fastcall CTaskComplexGoToPointAndStandStill::~CTaskComplexGoToPointAndStandStill(
        CTaskComplexGoToPointAndStandStill *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 51D440: variable 'v1' is possibly undefined

//----- (0051D444) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToPointAndStandStill::CreateNextSubTask(
        CTaskComplexGoToPointAndStandStill *this,
        CPed *pPed)
{
  int v4; // r0
  int v6; // r1

  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  switch ( v4 )
  {
    case 203:
      v6 = 1302;
      break;
    case 900:
      v6 = 203;
      *((_BYTE *)this + 36) = (4 * BYTE1(this->m_pSubTask[3].m_pParent)) & 0x10 | *((_BYTE *)this + 36) & 0xEF;
      break;
    case 704:
      v6 = 1302;
      if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
        v6 = 900;
      break;
    default:
      return 0;
  }
  return CTaskComplexGoToPointAndStandStill::CreateSubTask(this, v6, pPed);
}

//----- (0051D4A4) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToPointAndStandStill::CreateSubTask(
        const CTaskComplexGoToPointAndStandStill *this,
        int iSubTaskType,
        CPed *pPed)
{
  CTask *result; // r0
  CTask *m_pSubTask; // r0
  CMatrix *v7; // r0
  float *p_y; // r2
  CSimpleTransform *v9; // r1
  float v10; // s16
  CTaskComplexLeaveCar *v11; // r0
  CTaskSimple *v12; // r0
  CTaskSimple *v13; // r0
  int m_iMoveState; // r6
  float m_fTargetRadius; // r8
  char v16; // r9
  char v17; // r3
  __int64 v18; // d16
  RwReal z; // r2
  char v20; // r2
  CTask **p_m_pParent; // r1
  int v22; // r2
  CMatrix *v23; // r2
  float32x2_t v24; // d16
  CSimpleTransform *p_m_transform; // r1
  float32x2_t v26; // d16
  float v27; // s4
  CTaskSimpleStandStill *v28; // r0
  CMatrix *m_pMat; // r2
  float32x2_t v30; // d16
  CSimpleTransform *p_tx; // r1
  unsigned __int64 v32; // d0
  float v33; // s0
  int (**v34)(void); // r1
  float v35; // s4
  CTaskSimpleStandStill *v36; // r0

  result = 0;
  if ( iSubTaskType >= 704 )
  {
    if ( iSubTaskType == 900 )
    {
      v13 = (CTaskSimple *)CTask::operator new(0x2Cu);
      m_iMoveState = this->m_iMoveState;
      m_fTargetRadius = this->m_fTargetRadius;
      v16 = *((_BYTE *)this + 36);
      CTaskSimple::CTaskSimple(v13);
      result[1]._vptr$CTask = (int (**)(void))m_iMoveState;
      LOBYTE(m_iMoveState) = BYTE1(result[3].m_pParent);
      v17 = (int)result[3].m_pParent & 0xC0;
      result->_vptr$CTask = (int (**)(void))&off_66C0A0;
      v18 = *(_QWORD *)&this->m_vTarget.x;
      z = this->m_vTarget.z;
      *(float *)&result[3]._vptr$CTask = m_fTargetRadius;
      LOBYTE(result[3].m_pParent) = v17;
      result->_vptr$CTask = (int (**)(void))&off_66C0D4;
      *(RwReal *)&result[2].m_pParent = z;
      v20 = m_iMoveState & 0xE0 | (8 * v16) & 8;
      BYTE1(result[3].m_pParent) = v20;
      *(_QWORD *)&result[1].m_pParent = v18;
      p_m_pParent = &result[1].m_pParent;
      if ( (*((_BYTE *)this + 36) & 8) != 0 )
        BYTE1(result[3].m_pParent) = v20 | 0x10;
      v22 = this->m_iMoveState;
      if ( v22 == 7 )
      {
        m_pMat = pPed->m_pMat;
        v30.n64_u64[0] = *(unsigned __int64 *)p_m_pParent;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &pPed->m_transform;
        v26.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.x, v30).n64_u64[0];
        v27 = 100.0;
      }
      else
      {
        if ( v22 != 6 )
          return result;
        v23 = pPed->m_pMat;
        v24.n64_u64[0] = *(unsigned __int64 *)p_m_pParent;
        p_m_transform = (CSimpleTransform *)&v23->tx;
        if ( !v23 )
          p_m_transform = &pPed->m_transform;
        v26.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.x, v24).n64_u64[0];
        v27 = 1.0e16;
      }
      v32 = vmul_f32(v26, v26).n64_u64[0];
      v33 = (float)(*(float *)&v32 + *((float *)&v32 + 1)) + 0.0;
      v34 = (int (**)(void))&byte_7;
      if ( v33 < v27 )
        v34 = (int (**)(void))&byte_6;
      if ( v33 < (float)(this->m_fSlowDownDistance * this->m_fSlowDownDistance) )
        v34 = (int (**)(void))byte_4;
      result[1]._vptr$CTask = v34;
    }
    else if ( iSubTaskType == 704 )
    {
      v11 = (CTaskComplexLeaveCar *)CTask::operator new(0x34u);
      CTaskComplexLeaveCar::CTaskComplexLeaveCar(v11, pPed->m_pMyVehicle, 0, 0, 1, 0);
    }
  }
  else if ( iSubTaskType == 202 )
  {
    v12 = (CTaskSimple *)CTask::operator new(0x18u);
    CTaskSimple::CTaskSimple(v12);
    LOWORD(result[2]._vptr$CTask) = 0;
    result[2].m_pParent = (CTask *)(&dword_0 + 1);
    result[1]._vptr$CTask = 0;
    result[1].m_pParent = 0;
    result->_vptr$CTask = (int (**)(void))&off_665750;
  }
  else if ( iSubTaskType == 203 )
  {
    if ( (*((_BYTE *)this + 36) & 2) != 0
      && (m_pSubTask = this->m_pSubTask) != 0
      && (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) == 900 )
    {
      v7 = pPed->m_pMat;
      p_y = &pPed->m_extractedVelocity.y;
      v9 = (CSimpleTransform *)&v7->tx;
      if ( !v7 )
        v9 = &pPed->m_transform;
      if ( *p_y >= 0.01 )
      {
        v35 = (float)((float)((float)(this->m_vTarget.x - v9->m_translate.x) * v7->xy)
                    + (float)((float)(this->m_vTarget.y - v9->m_translate.y) * v7->yy))
            + (float)((float)(this->m_vTarget.z - v9->m_translate.z) * v7->zy);
        if ( v35 <= 0.01 )
        {
          v10 = 16.0;
        }
        else
        {
          v10 = 50.0 / (float)((float)((float)(v35 / (float)(*p_y * 0.5)) + -1.0) * CTimer::ms_fTimeStep);
          if ( v10 > 16.0 )
            v10 = 16.0;
        }
      }
      else
      {
        v10 = 8.0;
      }
      v36 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(v36, 2000, 0, 1, v10);
    }
    else
    {
      v28 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(v28, 1, 0, 0, 8.0);
    }
  }
  return result;
}
// 51D54C: variable 'result' is possibly undefined
// 0: using guessed type int dword_0;
// 6: using guessed type char byte_6;
// 7: using guessed type char byte_7;
// 665750: using guessed type void *off_665750;
// 66C0A0: using guessed type void *off_66C0A0;
// 66C0D4: using guessed type void *off_66C0D4;
// 678E00: using guessed type void *`vtable for'CTaskSimplePause;

//----- (0051D730) --------------------------------------------------------
void __fastcall CTaskComplexGoToPointAndStandStill::SelectMoveState(
        const CTaskComplexGoToPointAndStandStill *this,
        CTaskSimpleGoToPoint *pGoToPoint,
        CPed *pPed,
        float fRunDistance,
        float fSprintDistance)
{
  CMatrix *m_pMat; // r12
  CSimpleTransform *p_tx; // r0
  float32x2_t v7; // d16
  unsigned __int64 v8; // d0
  float v9; // s0
  int v10; // r0

  m_pMat = pPed->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  v7.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.x, *(float32x2_t *)&pGoToPoint->m_vTarget.x).n64_u64[0];
  v8 = vmul_f32(v7, v7).n64_u64[0];
  v9 = (float)(*(float *)&v8 + *((float *)&v8 + 1)) + 0.0;
  if ( v9 >= (float)(fRunDistance * fRunDistance) )
  {
    v10 = 7;
    if ( v9 < (float)(fSprintDistance * fSprintDistance) )
      v10 = 6;
    pGoToPoint->m_iMoveState = v10;
  }
  else
  {
    pGoToPoint->m_iMoveState = 4;
  }
}

//----- (0051D794) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToPointAndStandStill::CreateFirstSubTask(
        CTaskComplexGoToPointAndStandStill *this,
        CPed *pPed)
{
  int m_nPedFlags; // r3
  int v4; // r1

  *((_BYTE *)this + 36) &= ~4u;
  m_nPedFlags = (int)pPed->m_nPedFlags;
  v4 = 704;
  if ( (m_nPedFlags & 0x100) == 0 )
    v4 = 900;
  return CTaskComplexGoToPointAndStandStill::CreateSubTask(this, v4, pPed);
}

//----- (0051D7B8) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToPointAndStandStill::ControlSubTask(
        CTaskComplexGoToPointAndStandStill *this,
        CPed *pPed)
{
  char v4; // r1
  CTask *m_pSubTask; // r0
  __int64 v6; // r0
  CMatrix *v7; // r1
  CSimpleTransform *p_m_transform; // r2
  float32x2_t v9; // d16
  float v10; // s4
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  unsigned __int64 v14; // d0
  float v15; // s0

  v4 = *((_BYTE *)this + 36);
  m_pSubTask = this->m_pSubTask;
  if ( (v4 & 4) != 0 )
  {
    if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))m_pSubTask->_vptr$CTask + 7))(m_pSubTask, pPed, 1, 0) == 1 )
      return (CTask *)(*((int (__fastcall **)(CTaskComplexGoToPointAndStandStill *, CPed *))this->_vptr$CTask + 11))(
                        this,
                        pPed);
  }
  else if ( (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) == 900 )
  {
    v6 = *(_QWORD *)&this->m_pSubTask;
    if ( HIDWORD(v6) == 7 )
    {
      m_pMat = pPed->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      v9.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.x, *(float32x2_t *)(v6 + 12)).n64_u64[0];
      v10 = 100.0;
      goto LABEL_13;
    }
    if ( HIDWORD(v6) == 6 )
    {
      v7 = pPed->m_pMat;
      p_m_transform = (CSimpleTransform *)&v7->tx;
      if ( !v7 )
        p_m_transform = &pPed->m_transform;
      v9.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.x, *(float32x2_t *)(v6 + 12)).n64_u64[0];
      v10 = 1.0e16;
LABEL_13:
      v14 = vmul_f32(v9, v9).n64_u64[0];
      v15 = (float)(*(float *)&v14 + *((float *)&v14 + 1)) + 0.0;
      HIDWORD(v6) = 7;
      if ( v15 < v10 )
        HIDWORD(v6) = 6;
      if ( v15 < (float)(this->m_fSlowDownDistance * this->m_fSlowDownDistance) )
        HIDWORD(v6) = 4;
      *(_DWORD *)(v6 + 8) = HIDWORD(v6);
    }
  }
  return this->m_pSubTask;
}

//----- (0051D890) --------------------------------------------------------
void __fastcall CTaskComplexGoToPointAndStandStillTimed::CTaskComplexGoToPointAndStandStillTimed(
        CTaskComplexGoToPointAndStandStillTimed *this,
        const int iMoveState,
        const CVector *vTarget,
        const float fTargetRadius,
        const float fSlowDownDistance,
        const int iTime)
{
  int v9; // r0
  float v10; // s2
  char v11; // r3
  __int64 v12; // d16

  CTaskComplex::CTaskComplex(this);
  v10 = *(float *)(v9 + 16);
  v11 = *(_BYTE *)(v9 + 36);
  *(_DWORD *)(v9 + 12) = iMoveState;
  *(_BYTE *)(v9 + 36) = v11 & 0xE4;
  *(_DWORD *)v9 = &off_66C13C;
  if ( v10 != vTarget->x
    || *(float *)(v9 + 20) != vTarget->y
    || *(float *)(v9 + 24) != vTarget->z
    || *(float *)(v9 + 32) != fSlowDownDistance )
  {
    v12 = *(_QWORD *)&vTarget->x;
    *(RwReal *)(v9 + 24) = vTarget->z;
    *(const float *)(v9 + 28) = fTargetRadius;
    *(const float *)(v9 + 32) = fSlowDownDistance;
    *(_BYTE *)(v9 + 36) = v11 & 0xE0 | 4;
    *(_QWORD *)(v9 + 16) = v12;
  }
  *(_DWORD *)(v9 + 40) = iTime;
  *(_WORD *)(v9 + 52) = 0;
  *(_DWORD *)(v9 + 44) = 0;
  *(_DWORD *)(v9 + 48) = 0;
  *(_DWORD *)v9 = &off_66C178;
}
// 51D8A4: variable 'v9' is possibly undefined
// 66C13C: using guessed type void *off_66C13C;
// 66C178: using guessed type void *;

//----- (0051D948) --------------------------------------------------------
void __fastcall CTaskComplexGoToPointAndStandStillTimed::~CTaskComplexGoToPointAndStandStillTimed(
        CTaskComplexGoToPointAndStandStillTimed *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 51D954: variable 'v1' is possibly undefined

//----- (0051D958) --------------------------------------------------------
bool __fastcall CTaskComplexGoToPointAndStandStillTimed::MakeAbortable(
        CTaskComplexGoToPointAndStandStillTimed *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  int v7; // r0
  bool v8; // zf
  bool v9; // r8
  __int64 v10; // kr00_8

  v7 = (*((int (__fastcall **)(CTask *, CPed *, const int))this->m_pSubTask->CTaskComplexGoToPointAndStandStill::CTaskComplex::_vptr$CTask
        + 7))(
         this->m_pSubTask,
         pPed,
         iPriority);
  v8 = iPriority == 1;
  v9 = v7;
  if ( iPriority == 1 )
    v8 = v7 == 1;
  if ( v8 && (!pEvent || !CEventHandler::IsTemporaryEvent(pEvent)) )
  {
    if ( this->m_timer.m_bIsActive )
    {
      v10 = *(_QWORD *)&this->m_timer.m_iStartTime;
      this->m_timer.m_bIsStopped = 1;
      this->m_timer.m_iDuration = HIDWORD(v10) - CTimer::m_snTimeInMilliseconds + v10;
    }
  }
  return v9;
}

//----- (0051D9B4) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToPointAndStandStillTimed::CreateFirstSubTask(
        CTaskComplexGoToPointAndStandStillTimed *this,
        CPed *pPed)
{
  int m_iTime; // r1
  int v4; // r3
  int v5; // r1

  m_iTime = this->m_iTime;
  if ( m_iTime >= 0 )
  {
    v4 = CTimer::m_snTimeInMilliseconds;
    this->m_timer.m_bIsActive = 1;
    this->m_timer.m_iStartTime = v4;
    this->m_timer.m_iDuration = m_iTime;
  }
  *((_BYTE *)&this->CTaskComplexGoToPointAndStandStill + 36) &= ~4u;
  v5 = 704;
  if ( (*(_DWORD *)&pPed->m_nPedFlags & 0x100) == 0 )
    v5 = 900;
  return CTaskComplexGoToPointAndStandStill::CreateSubTask(this, v5, pPed);
}

//----- (0051D9F4) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToPointAndStandStillTimed::ControlSubTask(
        CTaskComplexGoToPointAndStandStillTimed *this,
        CPed *pPed)
{
  unsigned int v4; // r0
  int m_iStartTime; // r1
  __int64 v6; // kr00_8
  CMatrix *m_pMat; // r3
  RwReal z; // r0
  float *p_tz; // r1

  if ( this->m_timer.m_bIsActive )
  {
    if ( this->m_timer.m_bIsStopped )
    {
      v4 = CTimer::m_snTimeInMilliseconds;
      this->m_timer.m_bIsStopped = 0;
      this->m_timer.m_iStartTime = v4;
      m_iStartTime = v4;
    }
    else
    {
      m_iStartTime = this->m_timer.m_iStartTime;
      v4 = CTimer::m_snTimeInMilliseconds;
    }
    if ( m_iStartTime + this->m_timer.m_iDuration <= v4
      && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplexGoToPointAndStandStill::CTaskComplex::_vptr$CTask
          + 5))(this->m_pSubTask) != 203
      && CPedPlacement::FindZCoorForPed(&this->m_vTarget) )
    {
      v6 = *(_QWORD *)&this->m_vTarget.x;
      m_pMat = pPed->m_pMat;
      z = this->m_vTarget.z;
      if ( m_pMat )
      {
        LODWORD(m_pMat->tx) = v6;
        pPed->m_pMat->ty = *((float *)&v6 + 1);
        p_tz = &pPed->m_pMat->tz;
      }
      else
      {
        *(_QWORD *)&pPed->m_transform.m_translate.x = v6;
        p_tz = &pPed->m_transform.m_translate.z;
      }
      *p_tz = z;
    }
  }
  return CTaskComplexGoToPointAndStandStill::ControlSubTask(this, pPed);
}

//----- (0051DA78) --------------------------------------------------------
void __fastcall CTaskComplexGoToPointAndStandStillTimed::StopTimer(
        CTaskComplexGoToPointAndStandStillTimed *this,
        const CEvent *pEvent)
{
  __int64 v3; // kr00_8

  if ( !CEventHandler::IsTemporaryEvent(pEvent) )
  {
    if ( this->m_timer.m_bIsActive )
    {
      v3 = *(_QWORD *)&this->m_timer.m_iStartTime;
      this->m_timer.m_bIsStopped = 1;
      this->m_timer.m_iDuration = HIDWORD(v3) - CTimer::m_snTimeInMilliseconds + v3;
    }
  }
}

//----- (0051DAB0) --------------------------------------------------------
bool __fastcall CTaskComplexGoToPointUntilCollisionAndStandStill::MakeAbortable(
        CTaskComplexGoToPointUntilCollisionAndStandStill *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  int v5; // r8
  unsigned int v8; // r0
  CTask *m_pSubTask; // r0
  const CEvent *v11; // r3

  v5 = iPriority;
  if ( pEvent )
  {
    v8 = (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent);
    if ( v8 <= 6 && ((1 << v8) & 0x62) != 0 || v8 == 60 )
    {
      (*((void (__fastcall **)(CTask *, CPed *, _DWORD, const CEvent *))this->m_pSubTask->CTaskComplexGoToPointAndStandStill::CTaskComplex::_vptr$CTask
       + 7))(
        this->m_pSubTask,
        pPed,
        0,
        pEvent);
      return 0;
    }
    m_pSubTask = this->m_pSubTask;
    iPriority = v5;
    v11 = pEvent;
  }
  else
  {
    m_pSubTask = this->m_pSubTask;
    v11 = 0;
  }
  return (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))m_pSubTask->_vptr$CTask + 7))(
           m_pSubTask,
           pPed,
           iPriority,
           v11);
}

//----- (0051DB14) --------------------------------------------------------
void __fastcall CTaskComplexGoToPointAiming::CTaskComplexGoToPointAiming(
        CTaskComplexGoToPointAiming *this,
        const int iMoveState,
        const CVector *vecMovePos,
        CEntity *pAimEntity,
        CVector vecAimPos,
        const float fTargetRadius,
        const float fSlowDownDistance)
{
  __int64 v11; // d16
  char v12; // r1

  CTaskComplex::CTaskComplex(this);
  this->m_iMoveState = iMoveState;
  this->m_vecAimPos = vecAimPos;
  this->_vptr$CTask = (int (**)(void))&off_66C1B4;
  this->m_pAimEntity = pAimEntity;
  if ( pAimEntity )
    CEntity::RegisterReference(pAimEntity, &this->m_pAimEntity);
  if ( this->m_vecMovePos.x != vecMovePos->x
    || this->m_vecMovePos.y != vecMovePos->y
    || this->m_vecMovePos.z != vecMovePos->z
    || this->m_fMoveTargetRadius != fTargetRadius
    || this->m_fSlowDownDistance != fSlowDownDistance )
  {
    v11 = *(_QWORD *)&vecMovePos->x;
    v12 = *((_BYTE *)this + 52);
    this->m_vecMovePos.z = vecMovePos->z;
    this->m_fMoveTargetRadius = fTargetRadius;
    this->m_fSlowDownDistance = fSlowDownDistance;
    *((_BYTE *)this + 52) = v12 | 1;
    *(_QWORD *)&this->m_vecMovePos.x = v11;
  }
}
// 66C1B4: using guessed type void *off_66C1B4;

//----- (0051DBDC) --------------------------------------------------------
void __fastcall CTaskComplexGoToPointAiming::~CTaskComplexGoToPointAiming(CTaskComplexGoToPointAiming *this)
{
  CEntity *m_pAimEntity; // r0
  CEntity **p_m_pAimEntity; // r1
  void *v4; // r0

  p_m_pAimEntity = &this->m_pAimEntity;
  m_pAimEntity = this->m_pAimEntity;
  this->_vptr$CTask = (int (**)(void))&off_66C1B4;
  if ( m_pAimEntity )
    CEntity::CleanUpOldReference(m_pAimEntity, p_m_pAimEntity);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 51DC04: variable 'v4' is possibly undefined
// 66C1B4: using guessed type void *off_66C1B4;

//----- (0051DC0C) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToPointAiming::CreateNextSubTask(CTaskComplexGoToPointAiming *this, CPed *pPed)
{
  (*((void (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  return 0;
}

//----- (0051DC1C) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToPointAiming::CreateSubTask(const CTaskComplexGoToPointAiming *this, int iSubTaskType)
{
  CTaskComplex *v3; // r0
  CTask *m_iMoveState; // r6
  float m_fMoveTargetRadius; // r5
  float m_fSlowDownDistance; // s16
  CTask *result; // r0
  char m_pParent; // r2
  int (**v9)(void); // s0
  CTask v10; // d16
  int v11; // r5
  CTaskSimpleGunControl *v12; // r0
  int8 nFiringTask; // r5

  if ( iSubTaskType == 1020 )
  {
    v11 = (*((int (__fastcall **)(const CTaskComplexGoToPointAiming *))this->_vptr$CTask + 5))(this);
    v12 = (CTaskSimpleGunControl *)CTask::operator new(0x3Cu);
    if ( v11 == 901 )
      nFiringTask = 3;
    else
      nFiringTask = 0;
    CTaskSimpleGunControl::CTaskSimpleGunControl(
      v12,
      this->m_pAimEntity,
      &this->m_vecAimPos,
      0,
      nFiringTask,
      1,
      (int32)"ceShowAdv");
  }
  else if ( iSubTaskType == 903 )
  {
    v3 = (CTaskComplex *)CTask::operator new(0x28u);
    m_iMoveState = (CTask *)this->m_iMoveState;
    m_fMoveTargetRadius = this->m_fMoveTargetRadius;
    m_fSlowDownDistance = this->m_fSlowDownDistance;
    CTaskComplex::CTaskComplex(v3);
    result[1].m_pParent = m_iMoveState;
    m_pParent = (char)result[4].m_pParent;
    v9 = result[2]._vptr$CTask;
    result->_vptr$CTask = (int (**)(void))&off_66C13C;
    LOBYTE(result[4].m_pParent) = m_pParent & 0xE4;
    if ( *(float *)&v9 != this->m_vecMovePos.x
      || *(float *)&result[2].m_pParent != this->m_vecMovePos.y
      || *(float *)&result[3]._vptr$CTask != this->m_vecMovePos.z
      || *(float *)&result[4]._vptr$CTask != m_fSlowDownDistance )
    {
      v10 = *(CTask *)&this->m_vecMovePos.x;
      result[3]._vptr$CTask = (int (**)(void))LODWORD(this->m_vecMovePos.z);
      result[2] = v10;
      *(float *)&result[4]._vptr$CTask = m_fSlowDownDistance;
      *(float *)&result[3].m_pParent = m_fMoveTargetRadius;
      LOBYTE(result[4].m_pParent) = m_pParent & 0xE0 | 4;
    }
  }
  else
  {
    return 0;
  }
  return result;
}
// 51DC4E: variable 'result' is possibly undefined
// 66C13C: using guessed type void *off_66C13C;

//----- (0051DD18) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToPointAiming::CreateFirstSubTask(CTaskComplexGoToPointAiming *this, CPed *pPed)
{
  eWeaponType m_eWeaponType; // r6
  int8 WeaponSkill; // r0
  CWeaponInfo *WeaponInfo; // r0
  int32 m_nFlags; // r1
  int v8; // r1
  CTask *TaskSecondary; // r0
  int v10; // r6
  CPedIntelligence *m_pPedIntelligence; // r8
  CTaskSimpleUseGun *v12; // r0
  CTask *v13; // r9
  __int16 nBurstLength; // r5

  *((_BYTE *)this + 52) &= ~1u;
  m_eWeaponType = pPed->m_WeaponSlots[pPed->m_nCurrentWeapon].m_eWeaponType;
  WeaponSkill = CPed::GetWeaponSkill(pPed);
  WeaponInfo = CWeaponInfo::GetWeaponInfo(m_eWeaponType, WeaponSkill);
  m_nFlags = WeaponInfo->m_nFlags;
  if ( (m_nFlags & 2) != 0 )
  {
    if ( CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 0) )
    {
      TaskSecondary = CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 0);
      (*((void (__fastcall **)(CTask *, CPed *, int, _DWORD))TaskSecondary->_vptr$CTask + 7))(TaskSecondary, pPed, 1, 0);
    }
    else
    {
      v10 = (*((int (__fastcall **)(CTaskComplexGoToPointAiming *))this->_vptr$CTask + 5))(this);
      m_pPedIntelligence = pPed->m_pPedIntelligence;
      v12 = (CTaskSimpleUseGun *)CTask::operator new(0x3Cu);
      v13 = v12;
      if ( v10 == 901 )
        nBurstLength = 3;
      else
        nBurstLength = 1;
      CTaskSimpleUseGun::CTaskSimpleUseGun(v12, this->m_pAimEntity, this->m_vecAimPos, nBurstLength, nBurstLength, 0);
      CTaskManager::SetTaskSecondary(&m_pPedIntelligence->m_taskManager, v13, 0);
    }
    goto LABEL_11;
  }
  if ( !(m_nFlags << 31) || (WeaponInfo->m_eFireType | 2) != 3 )
  {
LABEL_11:
    v8 = 903;
    return CTaskComplexGoToPointAiming::CreateSubTask(this, v8);
  }
  v8 = 1020;
  return CTaskComplexGoToPointAiming::CreateSubTask(this, v8);
}

//----- (0051DDEE) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToPointAiming::ControlSubTask(CTaskComplexGoToPointAiming *this, CPed *pPed)
{
  CTask *m_pSubTask; // r8
  eWeaponType m_eWeaponType; // r4
  int8 WeaponSkill; // r0
  CWeaponInfo *WeaponInfo; // r4
  int v8; // r0
  CTask *v9; // r0
  char m_pParent; // r2
  CTask v11; // d16
  CTask *v12; // r0
  CPedIntelligence *m_pPedIntelligence; // r4
  CTaskSimpleUseGun *v14; // r0
  CEntity *m_pAimEntity; // r2
  CPed *v16; // r1
  int8 v17; // r3
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float v21; // s6
  float v22; // s2
  float v23; // s4
  float v24; // s0
  float v25; // s4
  float v26; // s2
  float v27; // s4
  float v28; // s4
  CTaskSimpleUseGun *TaskSecondary; // r0
  CTaskSimpleUseGun *v30; // r5
  CTask *v31; // r0
  CVector2D pMoveVec; // [sp+10h] [bp-20h] BYREF

  m_pSubTask = this->m_pSubTask;
  m_eWeaponType = pPed->m_WeaponSlots[pPed->m_nCurrentWeapon].m_eWeaponType;
  WeaponSkill = CPed::GetWeaponSkill(pPed);
  WeaponInfo = CWeaponInfo::GetWeaponInfo(m_eWeaponType, WeaponSkill);
  if ( *((unsigned __int8 *)this + 52) << 31 )
    return (CTask *)(*((int (__fastcall **)(CTaskComplexGoToPointAiming *, CPed *))this->_vptr$CTask + 11))(this, pPed);
  v8 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  if ( v8 == 1020 )
  {
    if ( CPedIntelligence::GetTaskUseGun(pPed->m_pPedIntelligence) )
    {
      m_pMat = pPed->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      v21 = this->m_vecMovePos.x - p_tx->m_translate.x;
      v22 = this->m_vecMovePos.y - p_tx->m_translate.y;
      v23 = this->m_vecMovePos.z - p_tx->m_translate.z;
      v24 = (float)((float)(v21 * m_pMat->xx) + (float)(v22 * m_pMat->yx)) + (float)(v23 * m_pMat->zx);
      pMoveVec.x = v24;
      v25 = (float)((float)(v21 * m_pMat->xy) + (float)(v22 * m_pMat->yy)) + (float)(v23 * m_pMat->zy);
      v26 = -v25;
      pMoveVec.y = -v25;
      v27 = (float)(v24 * v24) + (float)(v25 * v25);
      if ( v27 <= (float)(this->m_fMoveTargetRadius * this->m_fMoveTargetRadius) )
      {
        pMoveVec.x = 0.0;
        pMoveVec.y = 0.0;
      }
      else
      {
        v28 = 1.0 / sqrtf(v27);
        pMoveVec.y = v28 * v26;
        pMoveVec.x = v24 * v28;
      }
      TaskSecondary = (CTaskSimpleUseGun *)CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 0);
      CTaskSimpleUseGun::ControlGunMove(TaskSecondary, &pMoveVec);
    }
  }
  else if ( v8 == 903 )
  {
    v9 = this->m_pSubTask;
    if ( *(float *)&v9[2]._vptr$CTask != this->m_vecMovePos.x
      || *(float *)&v9[2].m_pParent != this->m_vecMovePos.y
      || *(float *)&v9[3]._vptr$CTask != this->m_vecMovePos.z
      || *(float *)&v9[4]._vptr$CTask != 2.0 )
    {
      m_pParent = (char)v9[4].m_pParent;
      v11 = *(CTask *)&this->m_vecMovePos.x;
      v9[3]._vptr$CTask = (int (**)(void))LODWORD(this->m_vecMovePos.z);
      v9[3].m_pParent = (CTask *)1056964608;
      v9[4]._vptr$CTask = (int (**)(void))0x40000000;
      LOBYTE(v9[4].m_pParent) = m_pParent | 4;
      v9[2] = v11;
    }
    if ( (WeaponInfo->m_nFlags & 2) != 0 )
    {
      v12 = CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 0);
      m_pPedIntelligence = pPed->m_pPedIntelligence;
      if ( v12 )
      {
        if ( CPedIntelligence::GetTaskUseGun(pPed->m_pPedIntelligence) )
        {
          if ( (*((int (__fastcall **)(CTaskComplexGoToPointAiming *))this->_vptr$CTask + 5))(this) == 901
            && (rand() & 0x3F) == 0 )
          {
            v14 = (CTaskSimpleUseGun *)CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 0);
            m_pAimEntity = this->m_pAimEntity;
            v16 = pPed;
            v17 = 2;
          }
          else
          {
            v14 = (CTaskSimpleUseGun *)CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 0);
            m_pAimEntity = this->m_pAimEntity;
            v16 = pPed;
            v17 = 1;
          }
          CTaskSimpleUseGun::ControlGun(v14, v16, m_pAimEntity, v17);
        }
        else
        {
          v31 = CTaskManager::GetTaskSecondary(&pPed->m_pPedIntelligence->m_taskManager, 0);
          (*((void (__fastcall **)(CTask *, CPed *, int, _DWORD))v31->_vptr$CTask + 7))(v31, pPed, 1, 0);
        }
      }
      else
      {
        v30 = (CTaskSimpleUseGun *)CTask::operator new(0x3Cu);
        CTaskSimpleUseGun::CTaskSimpleUseGun(v30, this->m_pAimEntity, this->m_vecAimPos, 1, 1, 0);
        CTaskManager::SetTaskSecondary(&m_pPedIntelligence->m_taskManager, v30, 0);
      }
    }
  }
  return m_pSubTask;
}

//----- (0051E06C) --------------------------------------------------------
void __fastcall CTaskComplexGoToPointShooting::CTaskComplexGoToPointShooting(
        CTaskComplexGoToPointShooting *this,
        const int iMoveState,
        const CVector *vecMovePos,
        CEntity *pAimEntity,
        CVector vecAimPos,
        const float fTargetRadius,
        const float fSlowDownDistance)
{
  __int64 v11; // d16
  char v12; // r1

  CTaskComplex::CTaskComplex(this);
  this->m_iMoveState = iMoveState;
  this->m_vecAimPos = vecAimPos;
  this->_vptr$CTask = (int (**)(void))&off_66C1B4;
  this->m_pAimEntity = pAimEntity;
  if ( pAimEntity )
    CEntity::RegisterReference(pAimEntity, &this->m_pAimEntity);
  if ( this->m_vecMovePos.x != vecMovePos->x
    || this->m_vecMovePos.y != vecMovePos->y
    || this->m_vecMovePos.z != vecMovePos->z
    || this->m_fMoveTargetRadius != fTargetRadius
    || this->m_fSlowDownDistance != fSlowDownDistance )
  {
    v11 = *(_QWORD *)&vecMovePos->x;
    v12 = *((_BYTE *)&this->CTaskComplexGoToPointAiming + 52);
    this->m_vecMovePos.z = vecMovePos->z;
    this->m_fMoveTargetRadius = fTargetRadius;
    this->m_fSlowDownDistance = fSlowDownDistance;
    *((_BYTE *)&this->CTaskComplexGoToPointAiming + 52) = v12 | 1;
    *(_QWORD *)&this->m_vecMovePos.x = v11;
  }
  this->_vptr$CTask = (int (**)(void))&off_66C6E8;
}
// 66C1B4: using guessed type void *;
// 66C6E8: using guessed type void *;

//----- (0051E140) --------------------------------------------------------
void __fastcall CTaskComplexGoToPointAndStandStillAndAchieveHeading::CTaskComplexGoToPointAndStandStillAndAchieveHeading(
        CTaskComplexGoToPointAndStandStillAndAchieveHeading *this,
        const int iMoveState,
        const CVector *vTarget,
        const float fDesiredHeading,
        const float fTargetRadius,
        const float fHeadingChangeRateFrac,
        const float fHeadingTolerance)
{
  int v10; // r0
  __int64 v11; // d16
  char v12; // r2

  CTaskComplex::CTaskComplex(this);
  *(_DWORD *)(v10 + 12) = iMoveState;
  *(_DWORD *)v10 = &off_66C1F0;
  v11 = *(_QWORD *)&vTarget->x;
  v12 = *(_BYTE *)(v10 + 44);
  *(RwReal *)(v10 + 24) = vTarget->z;
  *(const float *)(v10 + 28) = fTargetRadius;
  *(const float *)(v10 + 32) = fDesiredHeading;
  *(const float *)(v10 + 36) = fHeadingChangeRateFrac;
  *(const float *)(v10 + 40) = fHeadingTolerance;
  *(_BYTE *)(v10 + 44) = v12 | 1;
  *(_QWORD *)(v10 + 16) = v11;
}
// 51E154: variable 'v10' is possibly undefined
// 66C1F0: using guessed type void *off_66C1F0;

//----- (0051E1A0) --------------------------------------------------------
void __fastcall CTaskComplexGoToPointAndStandStillAndAchieveHeading::~CTaskComplexGoToPointAndStandStillAndAchieveHeading(
        CTaskComplexGoToPointAndStandStillAndAchieveHeading *this)
{
  void *v1; // r0

  CTaskComplex::~CTaskComplex(this);
  sub_197118(v1);
}
// 51E1AC: variable 'v1' is possibly undefined

//----- (0051E1B0) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToPointAndStandStillAndAchieveHeading::CreateNextSubTask(
        CTaskComplexGoToPointAndStandStillAndAchieveHeading *this,
        CPed *pPed)
{
  int v3; // r0
  int v4; // r1

  v3 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  v4 = 902;
  if ( v3 != 203 )
  {
    if ( v3 == 902 )
    {
      v4 = 1302;
    }
    else
    {
      if ( v3 != 900 )
        return 0;
      v4 = 203;
    }
  }
  return CTaskComplexGoToPointAndStandStillAndAchieveHeading::CreateSubTask(this, v4);
}

//----- (0051E1E4) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToPointAndStandStillAndAchieveHeading::CreateSubTask(
        CTaskComplexGoToPointAndStandStillAndAchieveHeading *this,
        int iSubTaskType)
{
  CTaskSimple *v3; // r0
  int m_iMoveState; // r5
  float m_fTargetRadius; // r6
  CTask *result; // r0
  __int64 v7; // d16
  char v8; // r3
  CTaskSimpleStandStill *v9; // r0
  CTaskSimple *v10; // r0
  CTask v11; // kr00_8
  float m_fHeadingTolerance; // r4
  char m_pParent; // r2

  switch ( iSubTaskType )
  {
    case 203:
      v9 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(v9, 0, 0, 0, 8.0);
      break;
    case 902:
      v10 = (CTaskSimple *)CTask::operator new(0x18u);
      v11 = *(CTask *)&this->m_fDesiredHeading;
      m_fHeadingTolerance = this->m_fHeadingTolerance;
      CTaskSimple::CTaskSimple(v10);
      result[1] = v11;
      *(float *)&result[2]._vptr$CTask = m_fHeadingTolerance;
      m_pParent = (char)result[2].m_pParent;
      result->_vptr$CTask = (int (**)(void))&off_66C108;
      LOBYTE(result[2].m_pParent) = m_pParent & 0xFE;
      break;
    case 900:
      v3 = (CTaskSimple *)CTask::operator new(0x2Cu);
      m_iMoveState = this->m_iMoveState;
      m_fTargetRadius = this->m_fTargetRadius;
      CTaskSimple::CTaskSimple(v3);
      result[1]._vptr$CTask = (int (**)(void))m_iMoveState;
      result->_vptr$CTask = (int (**)(void))&off_66C0A0;
      LOBYTE(m_iMoveState) = BYTE1(result[3].m_pParent);
      v7 = *(_QWORD *)&this->m_vTarget.x;
      v8 = (char)result[3].m_pParent;
      result[2].m_pParent = (CTask *)LODWORD(this->m_vTarget.z);
      result->_vptr$CTask = (int (**)(void))&off_66C0D4;
      *(float *)&result[3]._vptr$CTask = m_fTargetRadius;
      BYTE1(result[3].m_pParent) = m_iMoveState & 0xE0;
      LOBYTE(result[3].m_pParent) = v8 & 0xC0;
      *(_QWORD *)&result[1].m_pParent = v7;
      break;
    default:
      return 0;
  }
  return result;
}
// 51E216: variable 'result' is possibly undefined
// 66C0A0: using guessed type void *off_66C0A0;
// 66C0D4: using guessed type void *off_66C0D4;
// 66C108: using guessed type void *off_66C108;

//----- (0051E2A0) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToPointAndStandStillAndAchieveHeading::CreateFirstSubTask(
        CTaskComplexGoToPointAndStandStillAndAchieveHeading *this,
        CPed *pPed)
{
  CTaskSimple *v3; // r0
  int m_iMoveState; // r5
  float m_fTargetRadius; // r6
  CTask *result; // r0
  __int64 v7; // d16
  char m_pParent; // r3

  *((_BYTE *)this + 44) &= ~1u;
  v3 = (CTaskSimple *)CTask::operator new(0x2Cu);
  m_iMoveState = this->m_iMoveState;
  m_fTargetRadius = this->m_fTargetRadius;
  CTaskSimple::CTaskSimple(v3);
  result[1]._vptr$CTask = (int (**)(void))m_iMoveState;
  result->_vptr$CTask = (int (**)(void))&off_66C0A0;
  LOBYTE(m_iMoveState) = BYTE1(result[3].m_pParent);
  v7 = *(_QWORD *)&this->m_vTarget.x;
  m_pParent = (char)result[3].m_pParent;
  result[2].m_pParent = (CTask *)LODWORD(this->m_vTarget.z);
  result->_vptr$CTask = (int (**)(void))&off_66C0D4;
  *(float *)&result[3]._vptr$CTask = m_fTargetRadius;
  BYTE1(result[3].m_pParent) = m_iMoveState & 0xE0;
  LOBYTE(result[3].m_pParent) = m_pParent & 0xC0;
  *(_QWORD *)&result[1].m_pParent = v7;
  return result;
}
// 51E2CA: variable 'result' is possibly undefined
// 66C0A0: using guessed type void *off_66C0A0;
// 66C0D4: using guessed type void *off_66C0D4;

//----- (0051E308) --------------------------------------------------------
CTask *__fastcall CTaskComplexGoToPointAndStandStillAndAchieveHeading::ControlSubTask(
        CTaskComplexGoToPointAndStandStillAndAchieveHeading *this,
        CPed *pPed)
{
  if ( *((unsigned __int8 *)this + 44) << 31 )
    return (CTask *)(*((int (__fastcall **)(CTaskComplexGoToPointAndStandStillAndAchieveHeading *, CPed *))this->_vptr$CTask
                     + 11))(
                      this,
                      pPed);
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 900 )
    this->m_pSubTask[1]._vptr$CTask = (int (**)(void))this->m_iMoveState;
  return this->m_pSubTask;
}

//----- (0051E33C) --------------------------------------------------------
void __fastcall CTaskComplexFollowPointRoute::CTaskComplexFollowPointRoute(
        CTaskComplexFollowPointRoute *this,
        const int iMoveState,
        const CPointRoute *route,
        const int iMode,
        const float fTargetRadius,
        const float fSlowDownDistance,
        const bool bMustOvershootTarget,
        int bUseBlending,
        const bool bStandStillAfterMove)
{
  char v13; // r0
  CPointRoute *v14; // r0
  int m_iRouteSize; // r2
  CVector *m_routePoints; // r2
  CVector *v17; // r3
  int v18; // r6
  __int64 v19; // d16
  RwReal z; // r5
  char v21; // r2

  CTaskComplex::CTaskComplex(this);
  this->m_iMode = iMode;
  this->m_iMoveState = iMoveState;
  v13 = *((_BYTE *)this + 40) & 0xF2 | bMustOvershootTarget | (8 * bUseBlending) | (4 * bStandStillAfterMove);
  *((_BYTE *)this + 40) = v13;
  this->_vptr$CTask = (int (**)(void))&off_66C22C;
  if ( bUseBlending )
  {
    *((_BYTE *)this + 40) = v13 & 0x9F;
    *(_QWORD *)&this->m_SpeedDecreaseDistance = 0LL;
    *(_QWORD *)&this->m_SpeedDecreaseAmt = 0LL;
  }
  v14 = (CPointRoute *)CPointRoute::operator new(0x64u);
  v14->m_iRouteSize = 0;
  this->m_pRoute = v14;
  m_iRouteSize = route->m_iRouteSize;
  v14->m_iRouteSize = route->m_iRouteSize;
  if ( m_iRouteSize >= 1 )
  {
    m_routePoints = route->m_routePoints;
    v17 = v14->m_routePoints;
    v18 = 0;
    do
    {
      v19 = *(_QWORD *)&m_routePoints->x;
      ++v18;
      z = m_routePoints->z;
      ++m_routePoints;
      v17->z = z;
      *(_QWORD *)&v17->x = v19;
      ++v17;
    }
    while ( v18 < v14->m_iRouteSize );
  }
  this->m_fTargetRadius = fTargetRadius;
  this->m_fSlowDownDistance = fSlowDownDistance;
  v21 = *((_BYTE *)this + 40);
  this->m_iProgress = 0;
  this->m_iRouteTraversals = 0;
  *((_BYTE *)this + 40) = v21 | 2;
  if ( (v21 & 8) != 0 )
  {
    *((_BYTE *)this + 40) = v21 & 0x9D | 0x42;
    *(_QWORD *)&this->m_SpeedDecreaseDistance = 0LL;
    *(_QWORD *)&this->m_SpeedDecreaseAmt = 0LL;
  }
}
// 66C22C: using guessed type void *;

//----- (0051E420) --------------------------------------------------------
void __fastcall CTaskComplexFollowPointRoute::SetRoute(
        CTaskComplexFollowPointRoute *this,
        const CPointRoute *route,
        const float fTargetRadius,
        const float fSlowDownDistance,
        int bForce)
{
  CPointRoute *m_pRoute; // lr
  int m_iRouteSize; // r2
  int v9; // r12
  float *p_y; // r2
  RwReal *v11; // r3
  int v12; // r4
  CVector *m_routePoints; // r1
  CVector *v14; // r2
  int v15; // r3
  __int64 v16; // d16
  RwReal z; // r4
  char v18; // r2
  float *p_m_SpeedDecreaseDistance; // r0

  m_pRoute = this->m_pRoute;
  if ( bForce == 1 )
  {
    m_iRouteSize = route->m_iRouteSize;
  }
  else
  {
    m_iRouteSize = route->m_iRouteSize;
    v9 = m_pRoute->m_iRouteSize;
    if ( m_pRoute->m_iRouteSize == route->m_iRouteSize )
    {
      if ( v9 < 1 )
      {
LABEL_10:
        if ( this->m_fTargetRadius == fTargetRadius )
        {
          m_iRouteSize = m_pRoute->m_iRouteSize;
          if ( this->m_fSlowDownDistance == fSlowDownDistance )
            return;
          goto LABEL_12;
        }
      }
      else
      {
        p_y = &m_pRoute->m_routePoints[0].y;
        v11 = &route->m_routePoints[0].y;
        v12 = 0;
        while ( *(p_y - 1) == *(v11 - 1) && *p_y == *v11 && p_y[1] == v11[1] )
        {
          ++v12;
          p_y += 3;
          v11 += 3;
          if ( v12 >= v9 )
            goto LABEL_10;
        }
      }
      m_iRouteSize = m_pRoute->m_iRouteSize;
    }
  }
LABEL_12:
  m_pRoute->m_iRouteSize = m_iRouteSize;
  if ( m_iRouteSize >= 1 )
  {
    m_routePoints = route->m_routePoints;
    v14 = m_pRoute->m_routePoints;
    v15 = 0;
    do
    {
      v16 = *(_QWORD *)&m_routePoints->x;
      ++v15;
      z = m_routePoints->z;
      ++m_routePoints;
      v14->z = z;
      *(_QWORD *)&v14->x = v16;
      ++v14;
    }
    while ( v15 < m_pRoute->m_iRouteSize );
  }
  this->m_fTargetRadius = fTargetRadius;
  this->m_fSlowDownDistance = fSlowDownDistance;
  v18 = *((_BYTE *)this + 40);
  this->m_iProgress = 0;
  this->m_iRouteTraversals = 0;
  *((_BYTE *)this + 40) = v18 | 2;
  if ( (v18 & 8) != 0 )
  {
    *((_BYTE *)this + 40) = v18 & 0x9D | 0x42;
    p_m_SpeedDecreaseDistance = &this->m_SpeedDecreaseDistance;
    *(_QWORD *)p_m_SpeedDecreaseDistance = 0LL;
    *((_QWORD *)p_m_SpeedDecreaseDistance + 1) = 0LL;
  }
}

//----- (0051E51C) --------------------------------------------------------
void __fastcall CTaskComplexFollowPointRoute::~CTaskComplexFollowPointRoute(CTaskComplexFollowPointRoute *this)
{
  CPointRoute *m_pRoute; // r0

  m_pRoute = this->m_pRoute;
  this->_vptr$CTask = (int (**)(void))&off_66C22C;
  if ( m_pRoute )
    CPointRoute::operator delete(m_pRoute);
  sub_18EDB4(this);
}
// 66C22C: using guessed type void *off_66C22C;

//----- (0051E544) --------------------------------------------------------
void __fastcall CTaskComplexFollowPointRoute::~CTaskComplexFollowPointRoute(CTaskComplexFollowPointRoute *this)
{
  CPointRoute *m_pRoute; // r0
  void *v3; // r0

  m_pRoute = this->m_pRoute;
  this->_vptr$CTask = (int (**)(void))&off_66C22C;
  if ( m_pRoute )
    CPointRoute::operator delete(m_pRoute);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v3);
}
// 51E568: variable 'v3' is possibly undefined
// 66C22C: using guessed type void *off_66C22C;

//----- (0051E570) --------------------------------------------------------
bool __fastcall CTaskComplexFollowPointRoute::MakeAbortable(
        CTaskComplexFollowPointRoute *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  const CVector *m_pSubTask; // r10
  int v9; // r0
  char *p_m_bIsPersistent; // r0
  int v11; // r9
  int v12; // r0
  bool v13; // zf
  bool v14; // zf
  int v15; // r0
  CMatrix *m_pMat; // r1
  float *v17; // r2
  CSimpleTransform *p_tx; // r0

  if ( !pEvent || this->m_iProgress + 1 >= this->m_pRoute->m_iRouteSize )
    goto LABEL_23;
  v9 = (*((int (__fastcall **)(const CEvent *))pEvent->_vptr$CEvent + 2))(pEvent);
  if ( v9 == 1 )
  {
    p_m_bIsPersistent = (char *)&pEvent[1].m_bIsPersistent;
  }
  else
  {
    if ( v9 != 56 )
    {
      v11 = 0;
      goto LABEL_9;
    }
    p_m_bIsPersistent = (char *)&pEvent[1].m_iAccumulatedTime;
  }
  v11 = *(_DWORD *)p_m_bIsPersistent;
LABEL_9:
  v12 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  v13 = v12 == 926;
  if ( v12 != 926 )
    v13 = v12 == 900;
  if ( v13 )
  {
    v14 = v11 == 0;
    if ( v11 )
    {
      m_pSubTask = (const CVector *)this->m_pSubTask;
      v14 = m_pSubTask == 0;
    }
    if ( !v14
      && (float)((float)((float)(*(float *)(v11 + 72) * *(float *)(v11 + 72))
                       + (float)(*(float *)(v11 + 76) * *(float *)(v11 + 76)))
               + (float)(*(float *)(v11 + 80) * *(float *)(v11 + 80))) < 0.015625
      && CPedGeometryAnalyser::IsEntityBlockingTarget((CEntity *)v11, m_pSubTask + 1, m_pSubTask[2].x) )
    {
      v15 = *(_DWORD *)(v11 + 20);
      m_pMat = pPed->m_pMat;
      v17 = (float *)(v15 + 48);
      if ( !v15 )
        v17 = (float *)(v11 + 4);
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      m_pSubTask[2].x = sqrtf(
                          (float)((float)(p_tx->m_translate.x - *v17) * (float)(p_tx->m_translate.x - *v17))
                        + (float)((float)(p_tx->m_translate.y - v17[1]) * (float)(p_tx->m_translate.y - v17[1])));
    }
  }
LABEL_23:
  if ( !iPriority )
    this->m_pRoute->m_iRouteSize = 0;
  return (*((int (__fastcall **)(CTask *, CPed *, const int, const CEvent *))this->m_pSubTask->CTaskComplex::_vptr$CTask
          + 7))(
           this->m_pSubTask,
           pPed,
           iPriority,
           pEvent);
}
// 51E60C: variable 'm_pSubTask' is possibly undefined

//----- (0051E68C) --------------------------------------------------------
int __fastcall CTaskComplexFollowPointRoute::GetSubTaskType(CTaskComplexFollowPointRoute *this)
{
  CPointRoute *m_pRoute; // r12
  int m_iRouteSize; // r2
  int m_iProgress; // r3
  int result; // r0
  bool v5; // nf
  __int64 v6; // kr00_8
  int v7; // r3
  int v8; // lr
  int v9; // r2
  CVector *v10; // r1
  int v11; // r12
  bool v12; // cc
  __int64 v13; // d16
  int v14; // r3
  int v15; // lr
  int v16; // r2
  CVector *m_routePoints; // r1
  int v18; // r12
  __int64 v19; // d16
  __int64 v20; // [sp+0h] [bp-18h]
  __int64 v21; // [sp+0h] [bp-18h]
  RwReal v22; // [sp+8h] [bp-10h]
  RwReal z; // [sp+8h] [bp-10h]

  while ( 1 )
  {
    m_pRoute = this->m_pRoute;
    m_iRouteSize = m_pRoute->m_iRouteSize;
    if ( !m_pRoute->m_iRouteSize )
      return 1302;
    m_iProgress = this->m_iProgress;
    if ( m_iProgress + 1 < m_iRouteSize )
      return (int)&elf_hash_bucket[162];
    if ( m_iProgress + 1 == m_iRouteSize )
      break;
    if ( m_iProgress != m_iRouteSize )
      return 200;
    v6 = *(_QWORD *)&this->m_iMode;
    this->m_iRouteTraversals = HIDWORD(v6) + 1;
    switch ( (int)v6 )
    {
      case 0:
        if ( (*((_BYTE *)this + 40) & 8) != 0 )
          *((_BYTE *)this + 40) &= 0x8Fu;
        return 1302;
      case 1:
        if ( HIDWORD(v6) )
          return 1302;
        v14 = m_pRoute->m_iRouteSize;
        if ( m_pRoute->m_iRouteSize >= 2 )
        {
          v15 = v14 - 1;
          v16 = (int)m_pRoute + 12 * v14 - 8;
          m_routePoints = m_pRoute->m_routePoints;
          v18 = 1;
          do
          {
            v12 = v18 < --v15;
            z = m_routePoints->z;
            v21 = *(_QWORD *)&m_routePoints->x;
            v19 = *(_QWORD *)v16;
            m_routePoints->z = *(RwReal *)(v16 + 8);
            *(_QWORD *)&m_routePoints->x = v19;
            ++m_routePoints;
            *(RwReal *)(v16 + 8) = z;
            *(_QWORD *)v16 = v21;
            v16 -= 12;
            ++v18;
          }
          while ( v12 );
        }
        break;
      case 2:
        v7 = m_pRoute->m_iRouteSize;
        if ( m_pRoute->m_iRouteSize >= 2 )
        {
          v8 = v7 - 1;
          v9 = (int)m_pRoute + 12 * v7 - 8;
          v10 = m_pRoute->m_routePoints;
          v11 = 1;
          do
          {
            v12 = v11 < --v8;
            v22 = v10->z;
            v20 = *(_QWORD *)&v10->x;
            v13 = *(_QWORD *)v9;
            v10->z = *(RwReal *)(v9 + 8);
            *(_QWORD *)&v10->x = v13;
            ++v10;
            *(RwReal *)(v9 + 8) = v22;
            *(_QWORD *)v9 = v20;
            v9 -= 12;
            ++v11;
          }
          while ( v12 );
        }
        break;
      case 3:
        break;
      default:
        return 200;
    }
    this->m_iProgress = 0;
  }
  v5 = (*((_BYTE *)this + 40) & 4) != 0;
  result = 903;
  if ( !v5 )
    return 900;
  return result;
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (0051E7C0) --------------------------------------------------------
CTask *__fastcall CTaskComplexFollowPointRoute::CreateSubTask(
        CTaskComplexFollowPointRoute *this,
        const int iTaskType,
        CPed *pPed)
{
  char *v5; // r4
  float v6; // r1
  CTask *m_pSubTask; // r0
  CTaskSimple *v8; // r0
  int m_iMoveState; // r6
  __int64 v10; // r8
  char v11; // r5
  char v12; // r2
  char v13; // r3
  int v14; // r0
  __int64 v15; // d16
  int m_iMode; // r0
  bool v17; // zf
  float m_fSlowDownDistance; // s16
  CTask *m_pParent; // r0
  int v20; // r10
  CTaskComplex *v21; // r0
  __int64 v22; // kr00_8
  __int64 v23; // kr08_8
  char v24; // r1
  float v25; // s0
  char v26; // r0
  float *v27; // r1
  float *v28; // r1
  __int64 v29; // d16
  float v30; // s0
  float v31; // s2

  v5 = 0;
  if ( iTaskType >= 900 )
  {
    switch ( iTaskType )
    {
      case 900:
        v8 = (CTaskSimple *)CTask::operator new(0x2Cu);
        m_iMoveState = this->m_iMoveState;
        v5 = (char *)v8;
        v10 = *(_QWORD *)&this->m_pRoute;
        v11 = *((_BYTE *)this + 40);
        CTaskSimple::CTaskSimple(v8);
        *((_DWORD *)v5 + 2) = m_iMoveState;
        *(_DWORD *)v5 = &off_66C0A0;
        v12 = v5[28];
        v13 = v5[29];
        v14 = v10 + 12 * HIDWORD(v10);
        v15 = *(_QWORD *)(v14 + 4);
        *((_DWORD *)v5 + 5) = *(_DWORD *)(v14 + 12);
        *(_DWORD *)v5 = &off_66C0D4;
        *((_DWORD *)v5 + 6) = 1056964608;
        v5[29] = (8 * v11) & 8 | v13 & 0xE0;
        v5[28] = v12 & 0xC0;
        *(_QWORD *)(v5 + 12) = v15;
        break;
      case 903:
        m_iMode = this->m_iMode;
        v17 = m_iMode == 3;
        if ( m_iMode != 3 )
          v17 = m_iMode == 2;
        if ( v17 )
        {
          m_fSlowDownDistance = 0.0;
        }
        else
        {
          m_fSlowDownDistance = this->m_fSlowDownDistance;
          if ( m_iMode == 1 && !this->m_iRouteTraversals )
            m_fSlowDownDistance = 0.0;
        }
        m_pParent = this->m_pParent;
        if ( m_pParent && (*((int (__fastcall **)(CTask *))m_pParent->_vptr$CTask + 5))(m_pParent) == 508 )
          v20 = 2 * CTaskComplexWalkRoundCar::GoingForDoor((const CTaskComplexWalkRoundCar *)this->m_pParent);
        else
          LOBYTE(v20) = 0;
        v21 = (CTaskComplex *)CTask::operator new(0x28u);
        v22 = *(_QWORD *)&this->m_iMoveState;
        v5 = (char *)v21;
        v23 = *(_QWORD *)&this->m_pRoute;
        CTaskComplex::CTaskComplex(v21);
        *((_DWORD *)v5 + 3) = v22;
        v24 = v5[36];
        v25 = *((float *)v5 + 4);
        *(_DWORD *)v5 = &off_66C13C;
        v26 = v24 & 0xE4 | v20;
        v5[36] = v26;
        v27 = (float *)(v23 + 12 * HIDWORD(v23));
        if ( v25 != v27[1]
          || *((float *)v5 + 5) != v27[2]
          || *((float *)v5 + 6) != v27[3]
          || *((float *)v5 + 8) != m_fSlowDownDistance )
        {
          v28 = v27 + 1;
          v26 |= 4u;
          v29 = *(_QWORD *)v28;
          *((float *)v5 + 6) = v28[2];
          *((_QWORD *)v5 + 2) = v29;
          *((float *)v5 + 8) = m_fSlowDownDistance;
          *((_DWORD *)v5 + 7) = HIDWORD(v22);
          v5[36] = v26;
        }
        if ( (v26 & 2) != 0 )
        {
          v30 = *((float *)v5 + 7);
          v5[36] = v26 & 0xFE;
          if ( (int)v22 >= 5 )
            v31 = 1.0;
          else
            v31 = 0.5;
          if ( v30 >= v31 )
            v31 = v30;
          *((_DWORD *)v5 + 8) = 0;
          *((float *)v5 + 7) = v31;
        }
        break;
      case 926:
        v5 = (char *)CTask::operator new(0x24u);
        v6 = CTaskSimpleGoToPointFine::BaseRatio((eMoveState)this->m_iMoveState);
        CTaskSimpleGoToPointFine::CTaskSimpleGoToPointFine(
          (CTaskSimpleGoToPointFine *)v5,
          v6,
          this->m_pRoute->m_routePoints[this->m_iProgress],
          0.5,
          0);
        if ( (*((_BYTE *)this + 40) & 0x20) != 0 )
        {
          m_pSubTask = this->m_pSubTask;
          if ( m_pSubTask )
          {
            if ( (*((int (__fastcall **)(CTask *))m_pSubTask->_vptr$CTask + 5))(m_pSubTask) == 900 )
              v5[28] = (int)this->m_pSubTask[3].m_pParent & 0xF | v5[28] & 0xF0;
          }
        }
        break;
    }
  }
  else
  {
    switch ( iTaskType )
    {
      case 200:
        v5 = (char *)CTask::operator new(8u);
        CTaskSimple::CTaskSimple((CTaskSimple *)v5);
        *(_DWORD *)v5 = &off_668FF0;
        break;
      case 203:
        v5 = (char *)CTask::operator new(0x20u);
        CTaskSimpleStandStill::CTaskSimpleStandStill(
          (CTaskSimpleStandStill *)v5,
          (const int)&elf_