Ware();
  else
    return 0;
}

//----- (0046F570) --------------------------------------------------------
int CGame::InitialiseRenderWare()
{
  const char *v0; // r0
  int v1; // r4
  RpWorld_0 *v2; // r0
  RwBBox_0 v4; // [sp+0h] [bp-20h] BYREF

  ValidateVersion();
  CTxdStore::Initialise();
  CVisibilityPlugins::Initialise();
  TextureDatabaseRuntime::Load("mobile", 0, DF_Default);
  TextureDatabaseRuntime::Load("txd", 0, DF_Default);
  TextureDatabaseRuntime::Load("gta3", 0, DF_Default);
  TextureDatabaseRuntime::Load("gta_int", 0, DF_Default);
  TextureDatabaseRuntime::Load("cutscene", 0, DF_Default);
  if ( UseHiDetailPlayer() == 1 )
    v0 = "playerhi";
  else
    v0 = "player";
  TextureDatabaseRuntime::Load((const unsigned __int8 *)v0, 0, DF_PVR);
  v1 = 0;
  TextureDatabaseRuntime::Load("menu", 0, DF_PVR);
  Scene.camera = CameraCreate(RsGlobal.screenWidth, RsGlobal.screenHeight, 1);
  if ( Scene.camera )
  {
    CCamera::Init(&TheCamera);
    CCamera::SetRwCamera(&TheCamera, Scene.camera);
    RwCameraSetFarClipPlane(Scene.camera, 2000.0);
    RwCameraSetNearClipPlane(Scene.camera, 0.9);
    v1 = 0;
    CameraSize(Scene.camera, 0, 0.7, 1.3333);
    *(_QWORD *)&v4.sup.x = 0x461C4000461C4000LL;
    *(_QWORD *)&v4.sup.z = 0xC61C4000461C4000LL;
    v4.inf.y = -10000.0;
    v4.inf.z = -10000.0;
    v2 = RpWorldCreate(&v4);
    Scene.world = v2;
    if ( v2 )
    {
      RpWorldAddCamera(v2, Scene.camera);
      LightsCreate(Scene.world);
      CreateDebugFont();
      CFont::Initialise();
      CHud::Initialise();
      CPlayerSkin::Initialise();
      CPostEffects::Initialise();
      CGame::m_pWorkingMatrix1 = RwMatrixCreate();
      v1 = 1;
      CGame::m_pWorkingMatrix2 = RwMatrixCreate();
    }
    else
    {
      CameraDestroy(Scene.camera);
      Scene.camera = 0;
    }
  }
  return v1;
}

//----- (0046F734) --------------------------------------------------------
void GameInit()
{
  unsigned int v0; // r0

  if ( RsRwInitialize(0) )
    CGame::InitialiseRenderWare();
  v0 = RsTimer();
  sub_18D6C4(v0);
}

//----- (0046F754) --------------------------------------------------------
void ValidateVersion()
{
  u_native v0; // r0
  u_native v1; // r4
  int v2; // r5
  int v3; // r0
  char v5[15]; // [sp+4h] [bp-94h] BYREF
  char v6[113]; // [sp+13h] [bp-85h] BYREF

  v0 = CFileMgr::OpenFile("models\\coll\\peds.col", "rb");
  v1 = v0;
  if ( !v0 )
    goto LABEL_6;
  v2 = 0;
  CFileMgr::Seek(v0, 100, 0);
  do
  {
    CFileMgr::ReadBytes(v1, (unsigned __int8 *)&v5[v2], 1);
    v3 = (unsigned __int8)v5[v2];
    v5[v2] = v3 - 23;
    if ( v3 == 23 )
      break;
    CFileMgr::Seek(v1, 99, 1);
  }
  while ( v2++ < 127 );
  if ( strncmp(v5, "grandtheftauto3", 0xFu) )
  {
LABEL_6:
    LoadingScreen("Invalid version", 0, 0);
    while ( 1 )
      ;
  }
  strncpy((char *)version_name, v6, 0x40u);
  CFileMgr::CloseFile(v1);
}
// 46F754: using guessed type char var_94[15];
// 46F754: using guessed type char anonymous_0[113];

//----- (0046F83C) --------------------------------------------------------
RwCamera_0 *__fastcall CameraCreate(RwInt32 width, RwInt32 height, RwBool zBuffer)
{
  RwCamera_0 *v6; // r4
  RwFrame_0 *v7; // r0
  RwRaster_0 *frameBuffer; // r0
  bool v9; // zf
  RwRaster_0 *v10; // r0
  bool v11; // zf

  v6 = RwCameraCreate();
  if ( !v6 )
    goto LABEL_13;
  v7 = RwFrameCreate();
  _rwObjectHasFrameSetFrame(v6, v7);
  v6->frameBuffer = RwRasterCreate(width, height, 0, 2);
  if ( zBuffer )
    v6->zBuffer = RwRasterCreate(width, height, 0, 1);
  if ( !v6->object.object.parent )
    goto LABEL_13;
  frameBuffer = v6->frameBuffer;
  v9 = frameBuffer == 0;
  if ( frameBuffer )
    v9 = frameBuffer->parent == 0;
  if ( v9 )
    goto LABEL_13;
  if ( zBuffer )
  {
    v10 = v6->zBuffer;
    v11 = v10 == 0;
    if ( v10 )
      v11 = v10->parent == 0;
    if ( v11 )
    {
LABEL_13:
      CameraDestroy(v6);
      return 0;
    }
  }
  return v6;
}

//----- (0046F8C0) --------------------------------------------------------
void __fastcall CCamera::Init(CCamera *this)
{
  __int64 v2; // r0
  CEntity *PlayerVehicle; // r0

  memset(&this->m_bAboveGroundTrainNodesLoaded, 0, 0xCE8u);
  CCamera::InitialiseScriptableComponents(&TheCamera);
  this->m_1rstPersonRunCloseToAWall = 0;
  this->m_bPlayerWasOnBike = 0;
  this->m_fPositionAlongSpline = 0.0;
  this->m_bCameraJustRestored = 0;
  CCam::Init(this->Cams);
  CCam::Init(&this->Cams[1]);
  CCam::Init(&this->Cams[2]);
  *(_QWORD *)&this->Cams[0].m_fTargetZoomOneZExtra = *(_QWORD *)sub_46FBD0;
  *(_QWORD *)&this->Cams[0].m_fTargetZoomTwoInteriorZExtra = 0xBD8F5C2900000000LL;
  this->Cams[1].Mode = 4;
  this->Cams[0].Mode = 4;
  *(_DWORD *)&this->m_bVehicleSuspenHigh = 0;
  this->Cams[0].m_fTargetZoomGroundOne = -0.55;
  this->Cams[0].m_fTargetZoomGroundTwo = 1.5;
  this->Cams[0].m_fTargetZoomGroundThree = 3.6;
  this->Cams[0].m_fTargetZoomZCloseIn = 0.90041;
  this->Cams[0].m_fMinRealGroundDist = 1.85;
  this->Cams[0].m_fTargetCloseInDist = 0.23378;
  this->m_bAllowShootingWith2PlayersInCar = 1;
  this->m_bMoveCamToAvoidGeom = 0;
  CCamera::ClearPlayerWeaponMode(this);
  this->Cams[1].CamTargetEntity = 0;
  this->Cams[0].CamTargetEntity = 0;
  this->m_bInATunnelAndABigVehicle = 0;
  this->Cams[2].CamTargetEntity = 0;
  this->Cams[0].m_fCamBufferedHeight = 0.0;
  this->Cams[0].m_fCamBufferedHeightSpeed = 0.0;
  this->Cams[1].m_bCamLookingAtVector = 0;
  this->Cams[0].m_bCamLookingAtVector = 0;
  this->Cams[1].m_fCamBufferedHeight = 0.0;
  this->Cams[1].m_fCamBufferedHeightSpeed = 0.0;
  this->Cams[2].m_bCamLookingAtVector = 0;
  this->Cams[1].m_fPlayerVelocity = 0.0;
  this->Cams[0].m_fPlayerVelocity = 0.0;
  this->Cams[2].m_fPlayerVelocity = 0.0;
  this->m_fFractionInterToStopMoving = 0.25;
  this->m_fFractionInterToStopCatchUp = 0.75;
  this->m_fGaitSwayBuffer = 0.85;
  this->m_uiCamShakeStart = 0;
  HIDWORD(v2) = &loc_300002;
  this->m_fCamShakeForce = 0.0;
  this->m_iModeObbeCamIsInForCar = 30;
  this->pToGarageWeAreIn = 0;
  this->pToGarageWeAreInForHackAvoidFirstPerson = 0;
  this->m_fNearClipScript = 0.9;
  LODWORD(v2) = 3211314;
  this->m_bHeadBob = 0;
  this->m_bScriptParametersSetForInterPol = 0;
  this->m_bWaitForInterpolToFinish = 0;
  *(_WORD *)&this->m_bIgnoreFadingStuffForMusic = 0;
  this->m_bJustCameOutOfGarage = 0;
  this->m_bUseNearClipScript = 0;
  this->m_vecDoingSpecialInterPolation = 0;
  *(_WORD *)&this->m_bAboveGroundTrainNodesLoaded = 0;
  *(_QWORD *)&this->m_ModeForTwoPlayersSeparateCars = v2;
  this->m_WideScreenOn = 0;
  this->m_fFOV_Wide_Screen = 0.0;
  this->m_bRestoreByJumpCut = 0;
  this->m_nCarZoom = 2;
  this->m_fCarZoomBase = 0.0;
  this->m_fCarZoomTotal = 0.0;
  this->m_fCarZoomSmoothed = 0.0;
  this->m_nPedZoom = 2;
  this->m_fPedZoomBase = 0.0;
  this->m_fPedZoomTotal = 0.0;
  this->m_fPedZoomSmoothed = 0.0;
  this->pTargetEntity = 0;
  if ( FindPlayerVehicle(-1, 0) )
    PlayerVehicle = FindPlayerVehicle(-1, 0);
  else
    PlayerVehicle = CWorld::Players[CWorld::PlayerInFocus].pPed;
  this->pTargetEntity = PlayerVehicle;
  if ( PlayerVehicle )
    CEntity::RegisterReference(PlayerVehicle, &this->pTargetEntity);
  this->m_bInitialNodeFound = 0;
  this->m_ScreenReductionPercentage = 0.0;
  this->m_ScreenReductionSpeed = 0.0;
  this->m_WideScreenOn = 0;
  this->m_bWantsToSwitchWidescreenOff = 0;
  this->WorldViewerBeingUsed = 0;
  this->PlayerExhaustion = 1.0;
  this->m_PedOrientForBehindOrInFront = 0.0;
  if ( gMobileMenu.m_WantsToRestartGame == 1 )
  {
    this->m_fTimeToFadeMusic = 0.0;
  }
  else if ( !gMobileMenu.m_WantsToRestartGame )
  {
    this->m_bFading = 0;
    CDraw::FadeValue = 0;
    this->m_bMusicFading = 0;
    this->m_fTimeToFadeMusic = 0.0;
    this->m_fFloatingFade = 0.0;
    this->m_fFloatingFadeMusic = 0.0;
    CCamera::m_fMouseAccelVertical = 0.0015;
    CCamera::m_fMouseAccelHorzntl = 0.0025;
  }
  this->m_iTypeOfSwitch = 1;
  this->m_bStartingSpline = 0;
  this->m_bUseScriptZoomValuePed = 0;
  this->m_bUseScriptZoomValueCar = 0;
  this->m_fPedZoomValueScript = 0.0;
  this->m_fCarZoomValueScript = 0.0;
  this->m_bUseSpecialFovTrain = 0;
  this->m_fFovForTrain = 70.0;
  this->m_iModeToGoTo = 4;
  this->m_bJust_Switched = 0;
  this->m_bUseTransitionBeta = 0;
  CMatrix::SetScale(&this->m_cameraMatrix, 1.0);
  this->m_bInitialNoNodeStaticsSet = 0;
  this->m_bTargetJustBeenOnTrain = 0;
  this->m_uiLongestTimeInMill = 5000;
  this->m_bIdleOn = 0;
  this->m_uiTimeLastChange = 0;
  this->m_uiTimeWeLeftIdle_StillNoInput = 0;
  this->m_uiTimeWeEnteredIdle = 0;
  this->LODDistMultiplier = 1.0;
  *(_WORD *)&this->m_bCamDirectlyBehind = 0;
  this->m_motionBlur = 0;
  this->m_bGarageFixedCamPositionSet = 0;
  CCamera::SetMotionBlur(this, 255, 255, 255, 0, 0);
  this->m_iWorkOutSpeedThisNumFrames = 4;
  this->m_iNumFramesSoFar = 0;
  this->m_uiTimeTransitionStart = 0;
  this->m_bJustInitalised = 1;
  this->m_uiTransitionState = 0;
  this->m_bLookingAtPlayer = 1;
  this->m_bLookingAtVector = 0;
  this->m_bFailedCullZoneTestPreviously = 0;
  this->m_bCullZoneChecksOn = 0;
  this->m_iCheckCullZoneThisNumFrames = 6;
  this->m_iZoneCullFrameNumWereAt = 0;
  this->m_CameraAverageSpeed = 0.0;
  this->m_CameraSpeedSoFar = 0.0;
  this->m_PreviousCameraPosition.x = 0.0;
  this->m_PreviousCameraPosition.y = 0.0;
  this->m_PreviousCameraPosition.z = 0.0;
  CCamera::m_f3rdPersonCHairMultY = 0.4;
  CCamera::m_f3rdPersonCHairMultX = 0.53;
  this->m_nAvoidTheGeometryProbsDirn = 0;
  this->m_fAvoidTheGeometryProbsTimer = 0.0;
  gPlayerPedVisible = 1;
  this->m_bResetOldMatrix = 1;
}

//----- (0046FBD0) --------------------------------------------------------
void __fastcall sub_46FBD0(int a1, int a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v9; // r7

  *a3 = a1;
  a3[1] = a2;
  a3[2] = a3;
  a3[3] = a4;
  a3[4] = v9;
  __asm { POP             {R2,R3,R6,R7,PC} }
}
// 46FBD6: unbalanced stack, ignored a potential tail call
// 46FBD0: variable 'v9' is possibly undefined

//----- (0046FC08) --------------------------------------------------------
RpWorld_0 *__fastcall LightsCreate(RpWorld_0 *world)
{
  RpWorld_0 *v2; // r5
  RwFrame_0 *v3; // r6
  RwFrame_0 *v4; // r0
  RwFrame_0 *v5; // r0
  RwFrame_0 *v6; // r0
  RwV3d_0 v8; // [sp+0h] [bp-38h] BYREF
  RwRGBAReal_0 color; // [sp+Ch] [bp-2Ch] BYREF

  v2 = 0;
  if ( world )
  {
    pAmbient = RpLightCreate(2);
    pAmbient->object.object.flags = 1;
    color.red = 0.25;
    color.green = 0.25;
    color.blue = 0.2;
    RpLightSetColor(pAmbient, &color);
    pDirect = RpLightCreate(1);
    pDirect->object.object.flags = 1;
    color.green = 0.85;
    color.red = 1.0;
    color.blue = 0.45;
    RpLightSetColor(pDirect, &color);
    RpLightSetRadius(pDirect, 2.0);
    v3 = RwFrameCreate();
    _rwObjectHasFrameSetFrame(pDirect, v3);
    v8.x = 1.0;
    v8.y = 1.0;
    v8.z = 0.0;
    RwFrameRotate(v3, &v8, 160.0, rwCOMBINEPRECONCAT);
    RpWorldAddLight(world, pAmbient);
    RpWorldAddLight(world, pDirect);
    pExtraDirectionals[0] = RpLightCreate(1);
    pExtraDirectionals[0]->object.object.flags = 0;
    color.red = 1.0;
    color.green = 0.5;
    color.blue = 0.0;
    RpLightSetColor(pExtraDirectionals[0], &color);
    RpLightSetRadius(pExtraDirectionals[0], 2.0);
    v4 = RwFrameCreate();
    _rwObjectHasFrameSetFrame(pExtraDirectionals[0], v4);
    RpWorldAddLight(world, pExtraDirectionals[0]);
    pExtraDirectionals[1] = RpLightCreate(1);
    pExtraDirectionals[1]->object.object.flags = 0;
    color.red = 1.0;
    color.green = 0.5;
    color.blue = 0.0;
    RpLightSetColor(pExtraDirectionals[1], &color);
    RpLightSetRadius(pExtraDirectionals[1], 2.0);
    v5 = RwFrameCreate();
    _rwObjectHasFrameSetFrame(pExtraDirectionals[1], v5);
    RpWorldAddLight(world, pExtraDirectionals[1]);
    pExtraDirectionals[2] = RpLightCreate(1);
    pExtraDirectionals[2]->object.object.flags = 0;
    color.red = 1.0;
    color.green = 0.5;
    color.blue = 0.0;
    RpLightSetColor(pExtraDirectionals[2], &color);
    RpLightSetRadius(pExtraDirectionals[2], 2.0);
    v6 = RwFrameCreate();
    _rwObjectHasFrameSetFrame(pExtraDirectionals[2], v6);
    RpWorldAddLight(world, pExtraDirectionals[2]);
    return world;
  }
  return v2;
}

//----- (0046FD8C) --------------------------------------------------------
void CFont::Initialise()
{
  CRGBA v0; // r0
  CRGBA v1; // r0
  int32 v2; // r4
  CRGBA v3; // [sp+8h] [bp-10h] BYREF
  CRGBA v4; // [sp+Ch] [bp-Ch] BYREF

  CFont::ClearSpecialLanguages();
  IsInitialized = 1;
  if ( FrontEndMenuManager.m_PrefsLanguage == 5 )
  {
    CFont::AddRussianTexture();
  }
  else if ( FrontEndMenuManager.m_PrefsLanguage == 6 )
  {
    CFont::AddJapaneseTexture();
  }
  else
  {
    CFont::AddEFIGSFont();
  }
  CFont::LoadFontValues();
  CFont::SetScale(1.0);
  CFont::SetSlantRefPoint((float)RsGlobal.screenWidth, 0.0);
  CFont::SetSlant(0.0);
  CRGBA::CRGBA(&v4, 0xFFu, 0xFFu, 0xFFu, 0);
  CFont::SetColor(v0);
  CFont::SetOrientation(1u);
  CFont::SetJustify(0);
  CFont::SetWrapx((float)RsGlobal.screenWidth);
  CFont::SetCentreSize((float)RsGlobal.screenWidth);
  CFont::SetBackground(0, 0);
  CRGBA::CRGBA(&v3, 0x80u, 0x80u, 0x80u, 0x80u);
  CFont::SetBackgroundColor(v1);
  CFont::SetProportional(1u);
  CFont::SetFontStyle(0);
  CFont::SetRightJustifyWrap(0.0);
  CFont::SetAlphaFade(255.0);
  CFont::SetDropShadowPosition(0);
  v2 = CTxdStore::AddTxdSlot("ps2btns", "txd", 0);
  CTxdStore::LoadTxd(v2, "MODELS\\PCBTNS.TXD");
  CTxdStore::AddRef(v2);
  CTxdStore::PushCurrentTxd();
  CTxdStore::SetCurrentTxd(v2, 0);
  CSprite2d::SetTexture(&CFont::PS2Sprite[1], (unsigned __int8 *)&dword_46FF00, (unsigned __int8 *)&dword_46FF04);
  CSprite2d::SetTexture(&CFont::PS2Sprite[2], "down", "downA");
  CSprite2d::SetTexture(&CFont::PS2Sprite[3], "left", "leftA");
  CSprite2d::SetTexture(&CFont::PS2Sprite[4], "right", "rightA");
  CTxdStore::PopCurrentTxd();
}
// 46FDFE: variable 'v0' is possibly undefined
// 46FE4A: variable 'v1' is possibly undefined
// 46FF00: using guessed type int dword_46FF00;
// 46FF04: using guessed type int dword_46FF04;

//----- (0046FF38) --------------------------------------------------------
void CHud::Initialise()
{
  int32 v0; // r4

  v0 = CTxdStore::AddTxdSlot((const unsigned __int8 *)&off_46FFD0, (const unsigned __int8 *)&off_46FFD4, 0);
  CTxdStore::LoadTxd(v0, "MODELS\\HUD.TXD");
  CTxdStore::AddRef(v0);
  CTxdStore::PushCurrentTxd();
  CTxdStore::SetCurrentTxd(v0, 0);
  CSprite2d::SetTexture(CHud::Sprites, "fist", "fistm");
  CSprite2d::SetTexture(&CHud::Sprites[1], "siteM16", "siteM16m");
  CSprite2d::SetTexture(&CHud::Sprites[2], "siterocket", "siterocketm");
  CSprite2d::SetTexture(&CHud::Sprites[3], "radardisc", "radardiscA");
  CSprite2d::SetTexture(&CHud::Sprites[4], "radarRingPlane", "radarRingPlaneA");
  CSprite2d::SetTexture(&CHud::Sprites[5], "skipicon", "SkipIconA");
  CTxdStore::PopCurrentTxd();
  sub_19C67C();
}
// 46FFD0: using guessed type void *off_46FFD0;
// 46FFD4: using guessed type void *off_46FFD4;

//----- (0047001C) --------------------------------------------------------
int DoHaspChecks()
{
  return 1;
}

//----- (00470020) --------------------------------------------------------
int CGame::InitialiseEssentialsAfterRW()
{
  int v0; // r4

  v0 = 0;
  CText::Load(&TheText, 0);
  if ( !CCarFXRenderer::Initialise() )
    return v0;
  if ( CGrassRenderer::Initialise() == 1 && CCustomBuildingRenderer::Initialise() )
  {
    CTimer::Initialise();
    CTouchInterface::LoadTouchControls();
    CWidgetListShop::LoadFromFile();
    return 1;
  }
  return 0;
}

//----- (00470070) --------------------------------------------------------
int CGame::InitialiseCoreDataAfterRW()
{
  CPedStats *v0; // r0
  int v1; // r2
  int v2; // r1
  _BYTE *v3; // r5
  int v4; // r4

  CTempColModels::Initialise();
  cHandlingDataMgr::LoadHandlingData(&mod_HandlingManager);
  *(_QWORD *)&mod_HandlingManager.m_fCoefficientOfRestitution = 0x3F6666663DCCCCCDLL;
  *(_QWORD *)mod_HandlingManager.m_aResistanceTable = 0x3F4CCCCD3F800000LL;
  mod_HandlingManager.m_aResistanceTable[2] = 0.98;
  SurfaceInfos_c::Init(&g_surfaceInfos);
  v0 = (CPedStats *)operator new[](0x8BCu);
  v1 = 50;
  CPedStats::ms_apPedStats = v0;
  v2 = 43;
  do
  {
    --v2;
    *(_DWORD *)((char *)v0 + v1 - 50) = 0;
    v0 = CPedStats::ms_apPedStats;
    v3 = (char *)CPedStats::ms_apPedStats + v1;
    *v3 = 0;
    v1 += 52;
    *(_DWORD *)(v3 - 10) = 1065353216;
    *(_DWORD *)(v3 - 14) = 842150450;
    *(_DWORD *)(v3 - 22) = 1101004800;
    *(_DWORD *)(v3 - 18) = 1097859072;
    strcpy(v3 - 46, "PLAYER");
    *(_DWORD *)(v3 - 6) = 1065353216;
    *((_WORD *)v3 - 1) = 0;
  }
  while ( v2 );
  CPedStats::LoadPedStats();
  CDecisionMakerTypesFileLoader::LoadDefaultDecisionMaker();
  CTimeCycle::Initialise(0);
  CPopCycle::Initialise();
  CVehicleRecording::InitAtStartOfGame();
  if ( !NeedsAmazonDownload() && !CAudioEngine::Initialise(&AudioEngine) || !BreakManager_c::Init(&g_breakMan) )
    return 0;
  v4 = 0;
  if ( BoneNodeManager_c::Init(&g_boneNodeMan) && !IKChainManager_c::Init(&g_ikChainMan) )
    return 1;
  return v4;
}

//----- (004701C0) --------------------------------------------------------
void CTempColModels::Initialise()
{
  CCollisionData *m_pColData; // r4
  CColSphere *m_pSphereArray; // r0
  CColSphere *v2; // r0
  CColSphere *v3; // r0
  CColLine *m_pLineArray; // r0
  CColLine *v5; // r0
  CCollisionData *v6; // r10
  CColSphere *v7; // r0
  CColSphere *v8; // r0
  CColSphere *v9; // r0
  CColSphere *v10; // r0
  CColSphere *v11; // r0
  CColSphere *v12; // r0
  CColSphere *v13; // r0
  CColSphere *v14; // r0
  CColSphere *v15; // r0
  CColLine *v16; // r0
  CColLine *v17; // r0
  CCollisionData *v18; // r5
  CColSphere *v19; // r0
  CColSphere *v20; // r0
  CColSphere *v21; // r0
  CCollisionData *v22; // r5
  CColSphere *v23; // r0
  CColSphere *v24; // r0
  CColSphere *v25; // r0
  CColSphere *v26; // r0
  CCollisionData *v27; // r5
  CColSphere *v28; // r0
  CColSphere *v29; // r0
  CColSphere *v30; // r0
  CColSphere *v31; // r0
  CCollisionData *v32; // r5
  CColSphere *v33; // r0
  CColSphere *v34; // r0
  CColSphere *v35; // r0
  CColSphere *v36; // r0
  CCollisionData *v37; // r5
  CColSphere *v38; // r0
  CColSphere *v39; // r0
  CColSphere *v40; // r0
  CColSphere *v41; // r0
  CCollisionData *v42; // r5
  CColSphere *v43; // r0
  CColSphere *v44; // r0
  CCollisionData *v45; // r5
  CColSphere *v46; // r0
  CColSphere *v47; // r0
  CCollisionData *v48; // r5
  CColSphere *v49; // r0
  CColSphere *v50; // r0
  CVector vecMax; // [sp+14h] [bp-34h] BYREF
  CVector vecCentre; // [sp+20h] [bp-28h] BYREF

  memset(&vecCentre, 0, sizeof(vecCentre));
  CSphere::Set(&CTempColModels::ms_colModelBBox.m_sphereBound, 2.0, &vecCentre);
  vecCentre.y = -2.0;
  vecCentre.z = -2.0;
  vecMax.x = 2.0;
  vecMax.y = 2.0;
  vecMax.z = 2.0;
  vecCentre.x = -2.0;
  CBox::Set(&CTempColModels::ms_colModelBBox.m_boxBound, &vecCentre, &vecMax);
  CTempColModels::ms_colModelBBox.m_level = 0;
  memset(&vecCentre, 0, sizeof(vecCentre));
  CSphere::Set(&CTempColModels::ms_colModelCutObj[0].m_sphereBound, 2.0, &vecCentre);
  vecCentre.y = -2.0;
  vecCentre.z = -2.0;
  vecMax.x = 2.0;
  vecMax.y = 2.0;
  vecMax.z = 2.0;
  vecCentre.x = -2.0;
  CBox::Set(&CTempColModels::ms_colModelCutObj[0].m_boxBound, &vecCentre, &vecMax);
  CTempColModels::ms_colModelCutObj[0].m_level = 0;
  memset(&vecCentre, 0, sizeof(vecCentre));
  CSphere::Set(&CTempColModels::ms_colModelCutObj[1].m_sphereBound, 2.0, &vecCentre);
  vecCentre.y = -2.0;
  vecCentre.z = -2.0;
  vecMax.x = 2.0;
  vecMax.y = 2.0;
  vecMax.z = 2.0;
  vecCentre.x = -2.0;
  CBox::Set(&CTempColModels::ms_colModelCutObj[1].m_boxBound, &vecCentre, &vecMax);
  CTempColModels::ms_colModelCutObj[1].m_level = 0;
  memset(&vecCentre, 0, sizeof(vecCentre));
  CSphere::Set(&CTempColModels::ms_colModelCutObj[2].m_sphereBound, 2.0, &vecCentre);
  vecCentre.y = -2.0;
  vecCentre.z = -2.0;
  vecMax.x = 2.0;
  vecMax.y = 2.0;
  vecMax.z = 2.0;
  vecCentre.x = -2.0;
  CBox::Set(&CTempColModels::ms_colModelCutObj[2].m_boxBound, &vecCentre, &vecMax);
  CTempColModels::ms_colModelCutObj[2].m_level = 0;
  memset(&vecCentre, 0, sizeof(vecCentre));
  CSphere::Set(&CTempColModels::ms_colModelCutObj[3].m_sphereBound, 2.0, &vecCentre);
  vecCentre.y = -2.0;
  vecCentre.z = -2.0;
  vecMax.x = 2.0;
  vecMax.y = 2.0;
  vecMax.z = 2.0;
  vecCentre.x = -2.0;
  CBox::Set(&CTempColModels::ms_colModelCutObj[3].m_boxBound, &vecCentre, &vecMax);
  CTempColModels::ms_colModelCutObj[3].m_level = 0;
  memset(&vecCentre, 0, sizeof(vecCentre));
  CSphere::Set(&CTempColModels::ms_colModelCutObj[4].m_sphereBound, 2.0, &vecCentre);
  vecCentre.y = -2.0;
  vecCentre.z = -2.0;
  vecMax.x = 2.0;
  vecMax.y = 2.0;
  vecMax.z = 2.0;
  vecCentre.x = -2.0;
  CBox::Set(&CTempColModels::ms_colModelCutObj[4].m_boxBound, &vecCentre, &vecMax);
  CTempColModels::ms_colModelCutObj[4].m_level = 0;
  CColModel::AllocateData(&CTempColModels::ms_colModelPed1, 3, 0, 2, 0, 0, 0);
  m_pColData = CTempColModels::ms_colModelPed1.m_pColData;
  m_pSphereArray = CTempColModels::ms_colModelPed1.m_pColData->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = 0.0;
  vecCentre.z = -0.2;
  CColSphere::Set(m_pSphereArray, 0.35, &vecCentre, 0x3Eu, 0, 0xFFu);
  v2 = m_pColData->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = 0.0;
  vecCentre.z = 0.2;
  CColSphere::Set(v2 + 1, 0.35, &vecCentre, 0x3Eu, 1u, 0xFFu);
  v3 = m_pColData->m_pSphereArray + 2;
  vecCentre.x = 0.0;
  vecCentre.y = 0.0;
  vecCentre.z = 0.6;
  CColSphere::Set(v3, 0.35, &vecCentre, 0x3Eu, 2u, 0xFFu);
  m_pLineArray = m_pColData->_anon_1.m_pLineArray;
  memset(&vecCentre, 0, sizeof(vecCentre));
  vecMax.x = 0.0;
  vecMax.y = 0.0;
  vecMax.z = -1.0;
  CColLine::Set(m_pLineArray, &vecCentre, &vecMax);
  v5 = m_pColData->_anon_1.m_pLineArray;
  memset(&vecCentre, 0, sizeof(vecCentre));
  vecMax.x = 0.0;
  vecMax.y = 0.0;
  vecMax.z = 1.0;
  CColLine::Set(v5 + 1, &vecCentre, &vecMax);
  m_pColData->_anon_0.m_nNoOfLines = 0;
  memset(&vecCentre, 0, sizeof(vecCentre));
  CSphere::Set(&CTempColModels::ms_colModelPed1.m_sphereBound, 1.0, &vecCentre);
  vecCentre.x = -0.35;
  vecCentre.y = -0.35;
  vecCentre.z = -1.0;
  vecMax.x = 0.35;
  vecMax.y = 0.35;
  vecMax.z = 0.95;
  CBox::Set(&CTempColModels::ms_colModelPed1.m_boxBound, &vecCentre, &vecMax);
  CTempColModels::ms_colModelPed1.m_level = 0;
  CColModel::AllocateData(&CTempColModels::ms_colModelPed2, 9, 0, 2, 0, 0, 0);
  v6 = CTempColModels::ms_colModelPed2.m_pColData;
  v7 = CTempColModels::ms_colModelPed2.m_pColData->m_pSphereArray;
  vecCentre.z = -0.2;
  vecCentre.x = 0.0;
  vecCentre.y = 0.0;
  CColSphere::Set(v7, 0.35, &vecCentre, 0x3Eu, 0, 0xFFu);
  v8 = v6->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = 0.0;
  vecCentre.z = 0.2;
  CColSphere::Set(v8 + 1, 0.35, &vecCentre, 0x3Eu, 1u, 0xFFu);
  v9 = v6->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = 0.0;
  vecCentre.z = 0.6;
  CColSphere::Set(v9 + 2, 0.35, &vecCentre, 0x3Eu, 2u, 0xFFu);
  v10 = v6->m_pSphereArray;
  vecCentre.y = 0.35;
  vecCentre.x = 0.18;
  vecCentre.z = 0.75;
  CColSphere::Set(v10 + 3, 0.13, &vecCentre, 0x3Eu, 6u, 0xFFu);
  v11 = v6->m_pSphereArray;
  vecCentre.x = 0.18;
  vecCentre.y = 0.5;
  vecCentre.z = 0.75;
  CColSphere::Set(v11 + 4, 0.13, &vecCentre, 0x3Eu, 6u, 0xFFu);
  v12 = v6->m_pSphereArray;
  vecCentre.y = 0.35;
  vecCentre.x = -0.18;
  vecCentre.z = 0.75;
  CColSphere::Set(v12 + 5, 0.13, &vecCentre, 0x3Eu, 5u, 0xFFu);
  v13 = v6->m_pSphereArray;
  vecCentre.x = -0.18;
  vecCentre.z = 0.75;
  vecCentre.y = 0.5;
  CColSphere::Set(v13 + 6, 0.13, &vecCentre, 0x3Eu, 5u, 0xFFu);
  v14 = v6->m_pSphereArray;
  vecCentre.z = 0.45;
  vecCentre.x = 0.0;
  vecCentre.y = 0.5;
  CColSphere::Set(v14 + 7, 0.2, &vecCentre, 0x3Eu, 8u, 0xFFu);
  v15 = v6->m_pSphereArray;
  vecCentre.y = 0.55;
  vecCentre.z = 0.2;
  vecCentre.x = 0.0;
  CColSphere::Set(v15 + 8, 0.35, &vecCentre, 0x3Eu, 4u, 0xFFu);
  v16 = v6->_anon_1.m_pLineArray;
  memset(&vecCentre, 0, sizeof(vecCentre));
  vecMax.x = 0.0;
  vecMax.y = 0.0;
  vecMax.z = -1.0;
  CColLine::Set(v16, &vecCentre, &vecMax);
  v17 = v6->_anon_1.m_pLineArray;
  memset(&vecCentre, 0, sizeof(vecCentre));
  vecMax.x = 0.0;
  vecMax.y = 0.0;
  vecMax.z = 1.0;
  CColLine::Set(v17 + 1, &vecCentre, &vecMax);
  v6->_anon_0.m_nNoOfLines = 0;
  memset(&vecCentre, 0, sizeof(vecCentre));
  CSphere::Set(&CTempColModels::ms_colModelPed2.m_sphereBound, 1.0, &vecCentre);
  vecCentre.z = -1.0;
  vecCentre.x = -0.35;
  vecCentre.y = -0.35;
  vecMax.z = 0.95;
  vecMax.x = 0.35;
  vecMax.y = 0.9;
  CBox::Set(&CTempColModels::ms_colModelPed2.m_boxBound, &vecCentre, &vecMax);
  CTempColModels::ms_colModelPed2.m_level = 0;
  CColModel::AllocateData(&CTempColModels::ms_colModelDoor1, 3, 0, 0, 0, 0, 0);
  v18 = CTempColModels::ms_colModelDoor1.m_pColData;
  v19 = CTempColModels::ms_colModelDoor1.m_pColData->m_pSphereArray;
  vecCentre.x = 0.0;
  vecCentre.y = -0.25;
  vecCentre.z = -0.35;
  CColSphere::Set(v19, 0.15, &vecCentre, 0x40u, 0, 0xFFu);
  v20 = v18->m_pSphereArray + 1;
  vecCentre.z = -0.35;
  vecCentre.x = 0.0;
  vecCentre.y = -0.95;
  CColSphere::Set(v20, 0.15, &vecCentre, 0x40u, 0, 0xFFu);
  v21 = v18->m_pSphereArray;
  vecCentre.y = -0.6;
  vecCentre.x = 0.0;
  vecCentre.z = 0.25;
  CColSphere::Set(v21 + 2, 0.25, &vecCentre, 0x40u, 0, 0xFFu);
  vecCentre.x = 0.0;
  vecCentre.y = -0.6;
  vecCentre.z = 0.0;
  CSphere::Set(&CTempColModels::ms_colModelDoor1.m_sphereBound, 1.5, &vecCentre);
  vecCentre.y = 0.0;
  vecCentre.x = -0.3;
  vecMax.y = -1.2;
  vecCentre.z = -0.6;
  vecMax.x = 0.3;
  vecMax.z = 0.6;
  CBox::Set(&CTempColModels::ms_colModelDoor1.m_boxBound, &vecCentre, &vecMax);
  CTempColModels::ms_colModelDoor1.m_level = 0;
  CColModel::AllocateData(&CTempColModels::ms_colModelBumper1, 4, 0, 0, 0, 0, 0);
  v22 = CTempColModels::ms_colModelBumper1.m_pColData;
  v23 = CTempColModels::ms_colModelBumper1.m_pColData->m_pSphereArray;
  vecCentre.x = 0.85;
  vecCentre.y = -0.05;
  vecCentre.z = 0.0;
  CColSphere::Set(v23, 0.15, &vecCentre, 0x40u, 0, 0xFFu);
  v24 = v22->m_pSphereArray + 1;
  vecCentre.y = 0.05;
  vecCentre.x = 0.4;
  vecCentre.z = 0.0;
  CColSphere::Set(v24, 0.15, &vecCentre, 0x40u, 0, 0xFFu);
  v25 = v22->m_pSphereArray + 2;
  vecCentre.y = 0.05;
  vecCentre.x = -0.4;
  vecCentre.z = 0.0;
  CColSphere::Set(v25, 0.15, &vecCentre, 0x40u, 0, 0xFFu);
  v26 = v22->m_pSphereArray + 3;
  vecCentre.y = -0.05;
  vecCentre.x = -0.85;
  vecCentre.z = 0.0;
  CColSphere::Set(v26, 0.15, &vecCentre, 0x40u, 0, 0xFFu);
  memset(&vecCentre, 0, sizeof(vecCentre));
  CSphere::Set(&CTempColModels::ms_colModelBumper1.m_sphereBound, 2.2, &vecCentre);
  vecCentre.x = -1.2;
  vecCentre.y = -0.3;
  vecCentre.z = -0.2;
  vecMax.y = 0.3;
  vecMax.x = 1.2;
  vecMax.z = 0.2;
  CBox::Set(&CTempColModels::ms_colModelBumper1.m_boxBound, &vecCentre, &vecMax);
  CTempColModels::ms_colModelBumper1.m_level = 0;
  CColModel::AllocateData(&CTempColModels::ms_colModelPanel1, 4, 0, 0, 0, 0, 0);
  v27 = CTempColModels::ms_colModelPanel1.m_pColData;
  v28 = CTempColModels::ms_colModelPanel1.m_pColData->m_pSphereArray;
  vecCentre.x = 0.15;
  vecCentre.y = 0.45;
  vecCentre.z = 0.0;
  CColSphere::Set(v28, 0.15, &vecCentre, 0x40u, 0, 0xFFu);
  v29 = v27->m_pSphereArray + 1;
  vecCentre.x = 0.15;
  vecCentre.y = -0.45;
  vecCentre.z = 0.0;
  CColSphere::Set(v29, 0.15, &vecCentre, 0x40u, 0, 0xFFu);
  v30 = v27->m_pSphereArray + 2;
  vecCentre.y = -0.45;
  vecCentre.x = -0.15;
  vecCentre.z = 0.0;
  CColSphere::Set(v30, 0.15, &vecCentre, 0x40u, 0, 0xFFu);
  v31 = v27->m_pSphereArray + 3;
  vecCentre.x = -0.15;
  vecCentre.y = 0.45;
  vecCentre.z = 0.0;
  CColSphere::Set(v31, 0.15, &vecCentre, 0x40u, 0, 0xFFu);
  memset(&vecCentre, 0, sizeof(vecCentre));
  CSphere::Set(&CTempColModels::ms_colModelPanel1.m_sphereBound, 1.4, &vecCentre);
  vecCentre.z = -0.15;
  vecCentre.y = -0.6;
  vecCentre.x = -0.3;
  vecMax.y = 0.6;
  vecMax.x = 0.3;
  vecMax.z = 0.15;
  CBox::Set(&CTempColModels::ms_colModelPanel1.m_boxBound, &vecCentre, &vecMax);
  CTempColModels::ms_colModelPanel1.m_level = 0;
  CColModel::AllocateData(&CTempColModels::ms_colModelBonnet1, 4, 0, 0, 0, 0, 0);
  v32 = CTempColModels::ms_colModelBonnet1.m_pColData;
  v33 = CTempColModels::ms_colModelBonnet1.m_pColData->m_pSphereArray;
  vecCentre.y = 0.1;
  vecCentre.x = -0.4;
  vecCentre.z = 0.0;
  CColSphere::Set(v33, 0.2, &vecCentre, 0x40u, 0, 0xFFu);
  v34 = v32->m_pSphereArray + 1;
  vecCentre.x = -0.4;
  vecCentre.y = 0.9;
  vecCentre.z = 0.0;
  CColSphere::Set(v34, 0.2, &vecCentre, 0x40u, 0, 0xFFu);
  v35 = v32->m_pSphereArray + 2;
  vecCentre.y = 0.1;
  vecCentre.x = 0.4;
  vecCentre.z = 0.0;
  CColSphere::Set(v35, 0.2, &vecCentre, 0x40u, 0, 0xFFu);
  v36 = v32->m_pSphereArray + 3;
  vecCentre.x = 0.4;
  vecCentre.y = 0.9;
  vecCentre.z = 0.0;
  CColSphere::Set(v36, 0.2, &vecCentre, 0x40u, 0, 0xFFu);
  vecCentre.x = 0.0;
  vecCentre.y = 0.5;
  vecCentre.z = 0.0;
  CSphere::Set(&CTempColModels::ms_colModelBonnet1.m_sphereBound, 1.7, &vecCentre);
  vecCentre.y = -0.2;
  vecCentre.x = -0.7;
  vecCentre.z = -0.3;
  vecMax.y = 1.2;
  vecMax.x = 0.7;
  vecMax.z = 0.3;
  CBox::Set(&CTempColModels::ms_colModelBonnet1.m_boxBound, &vecCentre, &vecMax);
  CTempColModels::ms_colModelBonnet1.m_level = 0;
  CColModel::AllocateData(&CTempColModels::ms_colModelBoot1, 4, 0, 0, 0, 0, 0);
  v37 = CTempColModels::ms_colModelBoot1.m_pColData;
  v38 = CTempColModels::ms_colModelBoot1.m_pColData->m_pSphereArray;
  vecCentre.y = -0.1;
  vecCentre.x = -0.4;
  vecCentre.z = 0.0;
  CColSphere::Set(v38, 0.2, &vecCentre, 0x40u, 0, 0xFFu);
  v39 = v37->m_pSphereArray + 1;
  vecCentre.x = -0.4;
  vecCentre.y = -0.6;
  vecCentre.z = 0.0;
  CColSphere::Set(v39, 0.2, &vecCentre, 0x40u, 0, 0xFFu);
  v40 = v37->m_pSphereArray;
  vecCentre.y = -0.1;
  vecCentre.x = 0.4;
  vecCentre.z = 0.0;
  CColSphere::Set(v40 + 2, 0.2, &vecCentre, 0x40u, 0, 0xFFu);
  v41 = v37->m_pSphereArray;
  vecCentre.x = 0.4;
  vecCentre.y = -0.6;
  vecCentre.z = 0.0;
  CColSphere::Set(v41 + 3, 0.2, &vecCentre, 0x40u, 0, 0xFFu);
  vecCentre.x = 0.0;
  vecCentre.y = -0.4;
  vecCentre.z = 0.0;
  CSphere::Set(&CTempColModels::ms_colModelBoot1.m_sphereBound, 1.4, &vecCentre);
  vecCentre.y = -0.9;
  vecMax.y = 0.2;
  vecMax.x = 0.7;
  vecCentre.x = -0.7;
  vecCentre.z = -0.3;
  vecMax.z = 0.3;
  CBox::Set(&CTempColModels::ms_colModelBoot1.m_boxBound, &vecCentre, &vecMax);
  CTempColModels::ms_colModelBoot1.m_level = 0;
  CColModel::AllocateData(&CTempColModels::ms_colModelWheel1, 2, 0, 0, 0, 0, 0);
  v42 = CTempColModels::ms_colModelWheel1.m_pColData;
  v43 = CTempColModels::ms_colModelWheel1.m_pColData->m_pSphereArray;
  vecCentre.x = -0.3;
  vecCentre.y = 0.0;
  vecCentre.z = 0.0;
  CColSphere::Set(v43, 0.35, &vecCentre, 0x3Cu, 0, 0xFFu);
  v44 = v42->m_pSphereArray + 1;
  vecCentre.x = 0.3;
  vecCentre.y = 0.0;
  vecCentre.z = 0.0;
  CColSphere::Set(v44, 0.35, &vecCentre, 0x3Cu, 0, 0xFFu);
  memset(&vecCentre, 0, sizeof(vecCentre));
  CSphere::Set(&CTempColModels::ms_colModelWheel1.m_sphereBound, 1.4, &vecCentre);
  vecCentre.x = -0.7;
  vecCentre.y = -0.4;
  vecCentre.z = -0.4;
  vecMax.y = 0.4;
  vecMax.x = 0.7;
  vecMax.z = 0.4;
  CBox::Set(&CTempColModels::ms_colModelWheel1.m_boxBound, &vecCentre, &vecMax);
  CTempColModels::ms_colModelWheel1.m_level = 0;
  CColModel::AllocateData(&CTempColModels::ms_colModelBodyPart1, 2, 0, 0, 0, 0, 0);
  v45 = CTempColModels::ms_colModelBodyPart1.m_pColData;
  v46 = CTempColModels::ms_colModelBodyPart1.m_pColData->m_pSphereArray;
  memset(&vecCentre, 0, sizeof(vecCentre));
  CColSphere::Set(v46, 0.2, &vecCentre, 0x3Eu, 0, 0xFFu);
  v47 = v45->m_pSphereArray + 1;
  vecCentre.x = 0.8;
  vecCentre.y = 0.0;
  vecCentre.z = 0.0;
  CColSphere::Set(v47, 0.2, &vecCentre, 0x3Eu, 0, 0xFFu);
  vecCentre.x = 0.4;
  vecCentre.y = 0.0;
  vecCentre.z = 0.0;
  CSphere::Set(&CTempColModels::ms_colModelBodyPart1.m_sphereBound, 0.7, &vecCentre);
  vecCentre.x = -0.3;
  vecCentre.y = -0.3;
  vecCentre.z = -0.3;
  vecMax.x = 1.1;
  vecMax.y = 0.3;
  vecMax.z = 0.3;
  CBox::Set(&CTempColModels::ms_colModelBodyPart1.m_boxBound, &vecCentre, &vecMax);
  CTempColModels::ms_colModelBodyPart1.m_level = 0;
  CColModel::AllocateData(&CTempColModels::ms_colModelBodyPart2, 2, 0, 0, 0, 0, 0);
  v48 = CTempColModels::ms_colModelBodyPart2.m_pColData;
  v49 = CTempColModels::ms_colModelBodyPart2.m_pColData->m_pSphereArray;
  memset(&vecCentre, 0, sizeof(vecCentre));
  CColSphere::Set(v49, 0.15, &vecCentre, 0x3Eu, 0, 0xFFu);
  v50 = v48->m_pSphereArray;
  vecCentre.y = 0.0;
  vecCentre.x = 0.5;
  vecCentre.z = 0.0;
  CColSphere::Set(v50 + 1, 0.15, &vecCentre, 0x3Eu, 0, 0xFFu);
  vecCentre.y = 0.0;
  vecCentre.x = 0.25;
  vecCentre.z = 0.0;
  CSphere::Set(&CTempColModels::ms_colModelBodyPart2.m_sphereBound, 0.5, &vecCentre);
  vecCentre.y = -0.2;
  vecCentre.z = -0.2;
  vecMax.x = 0.7;
  vecMax.y = 0.2;
  vecMax.z = 0.2;
  vecCentre.x = -0.2;
  CBox::Set(&CTempColModels::ms_colModelBodyPart2.m_boxBound, &vecCentre, &vecMax);
  CTempColModels::ms_colModelBodyPart2.m_level = 0;
  CTempColModels::ms_colModelWeapon.m_sphereBound.m_fRadius = 0.25;
  CTempColModels::ms_colModelWeapon.m_boxBound.m_vecMax.z = 0.25;
  *(_QWORD *)&CTempColModels::ms_colModelWeapon.m_boxBound.m_vecMin.x = 0xBE800000BE800000LL;
  *(_QWORD *)&CTempColModels::ms_colModelWeapon.m_boxBound.m_vecMin.z = 0x3E800000BE800000LL;
  CTempColModels::ms_colModelWeapon.m_boxBound.m_vecMax.y = 0.25;
}

//----- (00470DD0) --------------------------------------------------------
void __fastcall cHandlingDataMgr::Initialise(cHandlingDataMgr *this)
{
  cHandlingDataMgr::LoadHandlingData(this);
  *(_QWORD *)&this->m_fCoefficientOfRestitution = 0x3F6666663DCCCCCDLL;
  *(_QWORD *)this->m_aResistanceTable = 0x3F4CCCCD3F800000LL;
  this->m_aResistanceTable[2] = 0.98;
}

//----- (00470E00) --------------------------------------------------------
void CPedStats::Initialise()
{
  CPedStats *v0; // r0
  int v1; // r2
  int v2; // r1
  _BYTE *v3; // r5

  v0 = (CPedStats *)operator new[](0x8BCu);
  v1 = 43;
  CPedStats::ms_apPedStats = v0;
  v2 = 50;
  do
  {
    --v1;
    *(_DWORD *)((char *)v0 + v2 - 50) = 0;
    v0 = CPedStats::ms_apPedStats;
    v3 = (char *)CPedStats::ms_apPedStats + v2;
    *v3 = 0;
    v2 += 52;
    *(_DWORD *)(v3 - 10) = 1065353216;
    *(_DWORD *)(v3 - 14) = 842150450;
    *(_DWORD *)(v3 - 22) = 1101004800;
    *(_DWORD *)(v3 - 18) = 1097859072;
    strcpy(v3 - 46, "PLAYER");
    *(_DWORD *)(v3 - 6) = 1065353216;
    *((_WORD *)v3 - 1) = 0;
  }
  while ( v1 );
  CPedStats::LoadPedStats();
  CDecisionMakerTypesFileLoader::LoadDefaultDecisionMaker();
}

//----- (00470EA0) --------------------------------------------------------
void __fastcall CTimeCycle::Initialise(bool bPalFile)
{
  u_native v1; // r4
  int i; // r6
  int j; // r9
  const char *Line; // r0
  float v5; // s0
  Int8 v6; // r5
  float v7; // s0
  Int8 v8; // r5
  float v9; // s0
  Int8 v10; // r5
  float v11; // s0
  Int16 v12; // r3
  float v13; // s0
  Int16 v14; // r5
  float v15; // s0
  float v16; // s0
  UInt8 v17; // r2
  float v18; // s0
  UInt8 v19; // r2
  float v20; // s0
  UInt8 v21; // r2
  float v22; // s0
  UInt8 v23; // r2
  float v24; // s0
  UInt8 v25; // r2
  float v26; // s0
  UInt8 v27; // r2
  float v28; // s0
  UInt8 v29; // r2
  float v30; // s0
  UInt8 v31; // r2
  float v32; // s0
  UInt8 v33; // r2
  float v34; // s0
  UInt8 v35; // r2
  float v36; // s0
  UInt8 v37; // r2
  float v38; // s0
  float v39; // s0
  unsigned int v40; // r3
  float v41; // s0
  UInt8 *v42; // r0
  u_native v43; // r11
  int v44; // r6
  float32x4_t v45; // q6
  int v46; // r1
  int v47; // r8
  char *v48; // r5
  unsigned __int8 *v49; // r0
  char *v50; // r4
  char *v51; // r6
  float32x4_t v52; // q2
  float32x4_t v53; // q1
  float32x4_t v54; // q0
  float v55; // s14
  float v56; // s12
  float v57; // s13
  float v58; // s28
  bool v59; // cc
  float v60; // s15
  bool v61; // fzf
  bool v62; // fnf
  float v63; // s12
  float v64; // s14
  float v65; // s30
  float v66; // s15
  bool v67; // fzf
  bool v68; // fnf
  float v69; // s13
  float32x4_t v70; // q8
  float v71; // s15
  int v72; // [sp+174h] [bp-144h]
  int v73; // [sp+178h] [bp-140h]
  char *v74; // [sp+17Ch] [bp-13Ch]
  char *v75; // [sp+180h] [bp-138h]
  char *v76; // [sp+184h] [bp-134h]
  float v77; // [sp+188h] [bp-130h] BYREF
  float v78; // [sp+18Ch] [bp-12Ch] BYREF
  float v79; // [sp+190h] [bp-128h] BYREF
  float v80; // [sp+194h] [bp-124h] BYREF
  float v81; // [sp+198h] [bp-120h] BYREF
  float v82; // [sp+19Ch] [bp-11Ch] BYREF
  float v83; // [sp+1A0h] [bp-118h] BYREF
  float v84; // [sp+1A4h] [bp-114h] BYREF
  float v85; // [sp+1A8h] [bp-110h] BYREF
  float v86; // [sp+1ACh] [bp-10Ch] BYREF
  float v87; // [sp+1B0h] [bp-108h] BYREF
  float v88; // [sp+1B4h] [bp-104h] BYREF
  float v89; // [sp+1B8h] [bp-100h] BYREF
  float v90; // [sp+1BCh] [bp-FCh] BYREF
  int v91; // [sp+1C0h] [bp-F8h] BYREF
  int v92; // [sp+1C4h] [bp-F4h] BYREF
  int v93; // [sp+1C8h] [bp-F0h] BYREF
  int v94; // [sp+1CCh] [bp-ECh] BYREF
  int v95; // [sp+1D0h] [bp-E8h] BYREF
  int v96; // [sp+1D4h] [bp-E4h] BYREF
  int v97; // [sp+1D8h] [bp-E0h] BYREF
  int v98; // [sp+1DCh] [bp-DCh] BYREF
  int v99; // [sp+1E0h] [bp-D8h] BYREF
  int v100; // [sp+1E4h] [bp-D4h] BYREF
  int v101; // [sp+1E8h] [bp-D0h] BYREF
  float v102; // [sp+1ECh] [bp-CCh] BYREF
  float v103; // [sp+1F0h] [bp-C8h] BYREF
  float v104; // [sp+1F4h] [bp-C4h] BYREF
  float v105; // [sp+1F8h] [bp-C0h] BYREF
  float v106; // [sp+1FCh] [bp-BCh] BYREF
  float v107; // [sp+200h] [bp-B8h] BYREF
  int v108; // [sp+204h] [bp-B4h] BYREF
  int v109; // [sp+208h] [bp-B0h] BYREF
  int v110; // [sp+20Ch] [bp-ACh] BYREF
  int v111; // [sp+210h] [bp-A8h] BYREF
  int v112; // [sp+214h] [bp-A4h] BYREF
  int v113; // [sp+218h] [bp-A0h] BYREF
  char v114; // [sp+21Ch] [bp-9Ch] BYREF
  char v115; // [sp+220h] [bp-98h] BYREF
  char v116; // [sp+224h] [bp-94h] BYREF
  int v117; // [sp+228h] [bp-90h] BYREF
  int v118; // [sp+22Ch] [bp-8Ch] BYREF
  int v119; // [sp+230h] [bp-88h] BYREF
  int v120; // [sp+234h] [bp-84h] BYREF
  int v121; // [sp+238h] [bp-80h] BYREF
  int v122; // [sp+23Ch] [bp-7Ch] BYREF
  int v123; // [sp+240h] [bp-78h] BYREF
  int v124; // [sp+244h] [bp-74h] BYREF
  int v125; // [sp+248h] [bp-70h] BYREF
  int v126; // [sp+24Ch] [bp-6Ch] BYREF
  int v127; // [sp+250h] [bp-68h] BYREF
  int v128; // [sp+254h] [bp-64h] BYREF

  v77 = 1.28;
  CFileMgr::SetDir("DATA");
  v1 = CFileMgr::OpenFile("TIMECYC.DAT", "rb");
  CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
  for ( i = 0; i != 23; ++i )
  {
    for ( j = 0; j != 8; ++j )
    {
      do
      {
        Line = (const char *)CFileLoader::LoadLine(v1);
        if ( !Line )
        {
          Line = 0;
          break;
        }
      }
      while ( *Line == 47 || !*Line );
      sscanf(
        Line,
        "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %f %f %f %d %d %d %f %f %f %d %d %d %d %d %d %f %"
        "f %f %f  %f %f %f %f  %f %f %f %f %f %d %d %f",
        &v128,
        &v127,
        &v126,
        &v125,
        &v124,
        &v123,
        &v116,
        &v115,
        &v114,
        &v122,
        &v121,
        &v120,
        &v119,
        &v118,
        &v117,
        &v113,
        &v112,
        &v111,
        &v110,
        &v109,
        &v108,
        &v107,
        &v106,
        &v105,
        &v101,
        &v100,
        &v99,
        &v104,
        &v103,
        &v102,
        &v98,
        &v97,
        &v96,
        &v95,
        &v94,
        &v93,
        &v90,
        &v89,
        &v88,
        &v87,
        &v83,
        &v86,
        &v85,
        &v84,
        &v79,
        &v82,
        &v81,
        &v80,
        &v78,
        &v92,
        &v91,
        &v77);
      v5 = v107 * 10.0;
      CTimeCycle::m_nAmbientRed[j][i] = v128;
      CTimeCycle::m_nAmbientGreen[j][i] = v127;
      CTimeCycle::m_nAmbientBlue[j][i] = v126;
      CTimeCycle::m_nAmbientRed_Obj[j][i] = v125;
      CTimeCycle::m_nAmbientGreen_Obj[j][i] = v124;
      CTimeCycle::m_nAmbientBlue_Obj[j][i] = v123;
      CTimeCycle::m_nSkyTopRed[j][i] = v122;
      CTimeCycle::m_nSkyTopGreen[j][i] = v121;
      CTimeCycle::m_nSkyTopBlue[j][i] = v120;
      CTimeCycle::m_nSkyBottomRed[j][i] = v119;
      CTimeCycle::m_nSkyBottomGreen[j][i] = v118;
      CTimeCycle::m_nSkyBottomBlue[j][i] = v117;
      CTimeCycle::m_nSunCoreRed[j][i] = v113;
      CTimeCycle::m_nSunCoreGreen[j][i] = v112;
      CTimeCycle::m_nSunCoreBlue[j][i] = v111;
      CTimeCycle::m_nSunCoronaRed[j][i] = v110;
      CTimeCycle::m_nSunCoronaGreen[j][i] = v109;
      CTimeCycle::m_nSunCoronaBlue[j][i] = v108;
      v6 = (int)(float)(v5 + 0.5);
      v7 = (float)(v106 * 10.0) + 0.5;
      CTimeCycle::m_fSunSize[23 * j + i] = v6;
      v8 = (int)v7;
      v9 = (float)(v105 * 10.0) + 0.5;
      CTimeCycle::m_fSpriteSize[23 * j + i] = v8;
      v10 = (int)v9;
      v11 = v104;
      CTimeCycle::m_fSpriteBrightness[23 * j + i] = v10;
      CTimeCycle::m_nShadowStrength[j][i] = v101;
      CTimeCycle::m_nLightShadowStrength[j][i] = v100;
      CTimeCycle::m_nPoleShadowStrength[j][i] = v99;
      v12 = (int)v11;
      v13 = v103;
      CTimeCycle::m_fFarClip[j][i] = v12;
      v14 = (int)v13;
      v15 = (float)(v102 * 10.0) + 0.5;
      CTimeCycle::m_fFogStart[j][i] = v14;
      LOBYTE(v14) = (unsigned int)v15;
      v16 = v90;
      CTimeCycle::m_fLightsOnGroundBrightness[j][i] = v14;
      CTimeCycle::m_nLowCloudsRed[j][i] = v98;
      CTimeCycle::m_nLowCloudsGreen[j][i] = v97;
      CTimeCycle::m_nLowCloudsBlue[j][i] = v96;
      CTimeCycle::m_nFluffyCloudsBottomRed[j][i] = v95;
      CTimeCycle::m_nFluffyCloudsBottomGreen[j][i] = v94;
      CTimeCycle::m_nFluffyCloudsBottomBlue[j][i] = v93;
      v17 = (unsigned int)v16;
      v18 = v89;
      CTimeCycle::m_fWaterRed[j][i] = v17;
      v19 = (unsigned int)v18;
      v20 = v88;
      CTimeCycle::m_fWaterGreen[j][i] = v19;
      v21 = (unsigned int)v20;
      v22 = v87;
      CTimeCycle::m_fWaterBlue[j][i] = v21;
      v23 = (unsigned int)v22;
      v24 = v86;
      CTimeCycle::m_fWaterAlpha[j][i] = v23;
      v25 = (unsigned int)v24;
      v26 = v85;
      CTimeCycle::m_fPostFx1Red[j][i] = v25;
      v27 = (unsigned int)v26;
      v28 = v84;
      CTimeCycle::m_fPostFx1Green[j][i] = v27;
      v29 = (unsigned int)v28;
      v30 = v82;
      CTimeCycle::m_fPostFx1Blue[j][i] = v29;
      v31 = (unsigned int)v30;
      v32 = v81;
      CTimeCycle::m_fPostFx2Red[j][i] = v31;
      v33 = (unsigned int)v32;
      v34 = v80;
      CTimeCycle::m_fPostFx2Green[j][i] = v33;
      v35 = (unsigned int)v34;
      v36 = v83;
      CTimeCycle::m_fPostFx2Blue[j][i] = v35;
      v37 = (unsigned int)v36;
      v38 = v79;
      CTimeCycle::m_fPostFx1Alpha[j][i] = v37;
      LOBYTE(v12) = (unsigned int)v38;
      v39 = v78;
      CTimeCycle::m_fPostFx2Alpha[j][i] = v12;
      v40 = (unsigned int)v39;
      v41 = v77 * 100.0;
      CTimeCycle::m_fCloudAlpha[j][i] = v40;
      CTimeCycle::m_nHighLightMinIntensity[j][i] = v92;
      CTimeCycle::m_nWaterFogAlpha[j][i] = v91;
      v42 = CTimeCycle::m_nDirectionalMult[j];
      v42[i] = (unsigned int)v41;
    }
  }
  CFileMgr::CloseFile(v1);
  v43 = CFileMgr::OpenFile("data/colorcycle.dat", "rb");
  v44 = 0;
  v45.n128_u64[0] = 0x3F2B851F3F2B851FLL;
  v45.n128_u64[1] = 0x3F2B851F3F2B851FLL;
  v46 = 0;
  do
  {
    v72 = v46;
    v47 = 0;
    v73 = v44;
    v76 = (char *)CTimeCycle::m_vBlueGrade + v44;
    v75 = (char *)CTimeCycle::m_vGreenGrade + v44;
    v74 = (char *)CTimeCycle::m_vRedGrade + v44;
    do
    {
      v48 = &v76[v47];
      v49 = CFileLoader::LoadLine(v43);
      v50 = &v75[v47];
      v51 = &v74[v47];
      sscanf(
        (const char *)v49,
        "%f %f %f %f %f %f %f %f %f %f %f %f",
        &v74[v47],
        &v74[v47 + 4],
        &v74[v47 + 8],
        &v74[v47 + 12],
        &v75[v47],
        &v75[v47 + 4],
        &v75[v47 + 8],
        &v75[v47 + 12],
        v48,
        v48 + 4,
        v48 + 8,
        &v76[v47 + 12]);
      v54.n128_u32[1] = *(_DWORD *)&v76[v47 + 4];
      v47 += 368;
      v53.n128_u64[0] = *(_QWORD *)v50;
      v52.n128_u64[0] = *(_QWORD *)v51;
      v52.n128_u32[2] = *((_DWORD *)v51 + 2);
      v53.n128_u32[2] = *((_DWORD *)v50 + 2);
      v54.n128_u32[0] = *(_DWORD *)v48;
      v54.n128_u32[2] = *((_DWORD *)v48 + 2);
      v55 = (float)(*(float *)v50 + *((float *)v50 + 1)) + v53.n128_f32[2];
      v56 = (float)(*(float *)v51 + *((float *)v51 + 1)) + v52.n128_f32[2];
      v57 = (float)(*(float *)v48 + v54.n128_f32[1]) + v54.n128_f32[2];
      v58 = v55 + -1.7;
      v59 = v56 <= 1.7;
      v60 = v56 + -1.7;
      v61 = v55 == 1.7;
      v62 = v55 < 1.7;
      v63 = 0.0;
      v64 = 0.0;
      v65 = v57 + -1.7;
      v66 = v60 * 0.13;
      if ( !v59 )
        v63 = v66;
      v59 = v62 || v61;
      v67 = v57 == 1.7;
      v68 = v57 < 1.7;
      v69 = 0.0;
      if ( !v59 )
        v64 = v58 * 0.13;
      v52.n128_f32[3] = *((float *)v51 + 3) - v63;
      v70 = vmulq_f32(v52, v45);
      if ( !v68 && !v67 )
        v69 = v65 * 0.13;
      v71 = *((float *)v48 + 3);
      v53.n128_f32[3] = *((float *)v50 + 3) - v64;
      *(float32x4_t *)v51 = v70;
      v54.n128_f32[3] = v71 - v69;
      *(float32x4_t *)v50 = vmulq_f32(v53, v45);
      *(float32x4_t *)v48 = vmulq_f32(v54, v45);
    }
    while ( v47 != 2944 );
    v44 = v73 + 16;
    v46 = v72 + 1;
  }
  while ( v72 != 22 );
  CFileMgr::CloseFile(v43);
  CTimeCycle::m_vecDirnLightToSun.x = -0.5;
  CTimeCycle::m_vecDirnLightToSun.y = -0.5;
  CTimeCycle::m_vecDirnLightToSun.z = 0.70711;
  CVector::Normalise(&CTimeCycle::m_vecDirnLightToSun);
  CTimeCycle::m_bExtraColourOn = 0;
  CTimeCycle::m_FogReduction = 0;
}
// 61CADE: using guessed type char byte_61CADE;

//----- (004717E0) --------------------------------------------------------
void CPopCycle::Initialise()
{
  u_native v0; // r4
  int v1; // r5
  const char *Line; // r0
  int v3; // r2
  unsigned __int8 v4; // r4
  int v5; // r6
  uint8 (*v6)[18]; // r1
  uint8 v7; // r3
  int v8; // r2
  uint8 *v9; // r0
  unsigned __int8 v10; // r5
  int v11; // r3
  unsigned __int8 v12; // r5
  int v13; // r3
  unsigned __int8 v14; // r4
  int v15; // r3
  unsigned __int8 v16; // r5
  unsigned __int8 v17; // r4
  int v18; // r3
  unsigned __int8 v19; // r5
  int v20; // r3
  unsigned __int8 v21; // r4
  int v22; // r3
  unsigned __int8 v23; // r5
  unsigned __int8 v24; // r4
  int v25; // r3
  unsigned __int8 v26; // r5
  float v27; // s0
  unsigned int v28; // r3
  int v29; // r2
  unsigned int v30; // r6
  unsigned int v31; // r5
  unsigned int v32; // r1
  bool v33; // cc
  unsigned int v34; // r3
  unsigned int v35; // s2
  unsigned int v36; // r1
  unsigned int v37; // r1
  unsigned int v38; // r1
  unsigned int v39; // r6
  unsigned int v40; // r6
  unsigned int v41; // r6
  unsigned int v42; // r11
  unsigned int v43; // r10
  unsigned int v44; // r9
  unsigned int v45; // r8
  unsigned int v46; // r4
  unsigned int v47; // lr
  unsigned int v48; // r1
  unsigned int v49; // s0
  char v50; // r3
  u_native id; // [sp+78h] [bp-C0h]
  int v52; // [sp+7Ch] [bp-BCh]
  int i; // [sp+80h] [bp-B8h]
  char v54; // [sp+88h] [bp-B0h]
  char v55; // [sp+8Ch] [bp-ACh]
  char v56; // [sp+90h] [bp-A8h]
  char v57; // [sp+94h] [bp-A4h]
  char v58; // [sp+98h] [bp-A0h]
  char v59; // [sp+A0h] [bp-98h]
  char v60; // [sp+A4h] [bp-94h]
  char v61; // [sp+A8h] [bp-90h]
  int v62; // [sp+ACh] [bp-8Ch]
  int v63; // [sp+B0h] [bp-88h] BYREF
  int v64; // [sp+B4h] [bp-84h] BYREF
  int v65; // [sp+B8h] [bp-80h] BYREF
  int v66; // [sp+BCh] [bp-7Ch] BYREF
  int v67; // [sp+C0h] [bp-78h] BYREF
  int v68; // [sp+C4h] [bp-74h] BYREF
  int v69; // [sp+C8h] [bp-70h] BYREF
  int v70; // [sp+CCh] [bp-6Ch] BYREF
  int v71; // [sp+D0h] [bp-68h] BYREF
  int v72; // [sp+D4h] [bp-64h] BYREF
  int v73; // [sp+D8h] [bp-60h] BYREF
  int v74; // [sp+DCh] [bp-5Ch] BYREF
  int v75; // [sp+E0h] [bp-58h] BYREF
  int v76; // [sp+E4h] [bp-54h] BYREF
  int v77; // [sp+E8h] [bp-50h] BYREF
  int v78; // [sp+ECh] [bp-4Ch] BYREF
  int v79; // [sp+F0h] [bp-48h] BYREF
  int v80; // [sp+F4h] [bp-44h] BYREF
  int v81; // [sp+F8h] [bp-40h] BYREF
  int v82; // [sp+FCh] [bp-3Ch] BYREF
  int v83; // [sp+100h] [bp-38h] BYREF
  int v84; // [sp+104h] [bp-34h] BYREF
  int v85; // [sp+108h] [bp-30h] BYREF
  int v86; // [sp+10Ch] [bp-2Ch] BYREF

  CFileMgr::SetDir("DATA");
  v0 = CFileMgr::OpenFile("POPCYCLE.DAT", "rb");
  CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
  v52 = 0;
  id = v0;
  do
  {
    for ( i = 0; i != 2; ++i )
    {
      v1 = 0;
      do
      {
        while ( 1 )
        {
          Line = (const char *)CFileLoader::LoadLine(v0);
          if ( !Line )
            break;
          if ( *Line != 47 && *Line )
            goto LABEL_9;
        }
        Line = 0;
LABEL_9:
        sscanf(
          Line,
          "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d",
          &v86,
          &v85,
          &v84,
          &v83,
          &v82,
          &v81,
          &v80,
          &v79,
          &v78,
          &v77,
          &v76,
          &v75,
          &v74,
          &v73,
          &v72,
          &v71,
          &v70,
          &v69,
          &v68,
          &v67,
          &v66,
          &v65,
          &v64,
          &v63);
        v3 = v1;
        v62 = v1;
        v4 = v77;
        v5 = 5 * i;
        v6 = CPopCycle::m_nPercTypeGroup[v1][i];
        CPopCycle::m_nMaxNumPeds[v3][i][v52] = v86;
        CPopCycle::m_nMaxNumCars[v3][0][4 * v5 + v52] = v85;
        CPopCycle::m_nPercDealers[v3][0][4 * v5 + v52] = v84;
        CPopCycle::m_nPercGang[v3][0][4 * v5 + v52] = v83;
        CPopCycle::m_nPercCops[v3][0][4 * v5 + v52] = v82;
        v7 = v80;
        LOBYTE(v5) = v79;
        CPopCycle::m_nPercOther[v3][i][v52] = v81;
        v8 = v52;
        v9 = v6[v52];
        v10 = v78;
        v6[v8][0] = v7;
        v9[1] = v5;
        v11 = v7 + (unsigned __int8)v5 + v10;
        LOBYTE(v5) = v76;
        v9[2] = v10;
        v12 = v75;
        v9[3] = v4;
        v13 = v11 + v4 + (unsigned __int8)v5;
        v14 = v74;
        v9[4] = v5;
        LOBYTE(v5) = v73;
        v9[5] = v12;
        v15 = v13 + v12 + v14;
        v16 = v72;
        v9[6] = v14;
        v17 = v71;
        v9[7] = v5;
        v18 = v15 + (unsigned __int8)v5 + v16;
        LOBYTE(v5) = v70;
        v9[8] = v16;
        v19 = v69;
        v9[9] = v17;
        v20 = v18 + v17 + (unsigned __int8)v5;
        v21 = v68;
        v9[10] = v5;
        LOBYTE(v5) = v67;
        v9[11] = v19;
        v22 = v20 + v19 + v21;
        v23 = v66;
        v9[12] = v21;
        v24 = v65;
        v9[13] = v5;
        v25 = v22 + (unsigned __int8)v5 + v23;
        LOBYTE(v5) = v64;
        v9[14] = v23;
        v26 = v63;
        v9[15] = v24;
        v9[16] = v5;
        v9[17] = v26;
        v27 = 100.0 / (float)(v25 + v24 + (unsigned __int8)v5 + v26);
        v28 = (unsigned int)(float)(v27 * (float)*v9);
        v6[v8][0] = v28;
        v29 = 0;
        v30 = (unsigned int)(float)(v27 * (float)v9[1]);
        v9[1] = v30;
        v61 = v30;
        v31 = (unsigned int)(float)(v27 * (float)v9[2]);
        v9[2] = v31;
        v32 = v28;
        v33 = v28 > v30;
        v34 = v30;
        v60 = v32;
        if ( v33 )
          v34 = v32;
        else
          v29 = 1;
        v59 = v31;
        if ( v34 <= v31 )
          v29 = 2;
        v35 = (unsigned int)(float)(v27 * (float)v9[3]);
        if ( v34 <= v31 )
          v34 = v31;
        if ( v34 <= v35 )
        {
          v29 = 3;
          v34 = (unsigned int)(float)(v27 * (float)v9[3]);
        }
        v9[3] = v35;
        v36 = (unsigned int)(float)(v27 * (float)v9[4]);
        v58 = v36;
        if ( v34 <= v36 )
        {
          v29 = 4;
          v34 = (unsigned int)(float)(v27 * (float)v9[4]);
        }
        v9[4] = v36;
        v37 = (unsigned int)(float)(v27 * (float)v9[5]);
        v57 = v37;
        if ( v34 <= v37 )
        {
          v29 = 5;
          v34 = (unsigned int)(float)(v27 * (float)v9[5]);
        }
        v9[5] = v37;
        v38 = (unsigned int)(float)(v27 * (float)v9[6]);
        v56 = v38;
        if ( v34 <= v38 )
        {
          v29 = 6;
          LOBYTE(v34) = v38;
        }
        v9[6] = v38;
        v39 = (unsigned int)(float)(v27 * (float)v9[7]);
        v55 = v39;
        if ( (unsigned __int8)v34 <= v39 )
        {
          v29 = 7;
          LOBYTE(v34) = v39;
        }
        v9[7] = v39;
        v40 = (unsigned int)(float)(v27 * (float)v9[8]);
        v54 = v40;
        if ( (unsigned __int8)v34 <= v40 )
        {
          v29 = 8;
          LOBYTE(v34) = v40;
        }
        v9[8] = v40;
        v41 = (unsigned int)(float)(v27 * (float)v9[9]);
        if ( (unsigned __int8)v34 <= v41 )
        {
          v29 = 9;
          LOBYTE(v34) = (unsigned int)(float)(v27 * (float)v9[9]);
        }
        v9[9] = v41;
        v42 = (unsigned int)(float)(v27 * (float)v9[10]);
        if ( (unsigned __int8)v34 <= v42 )
        {
          v29 = 10;
          v34 = (unsigned int)(float)(v27 * (float)v9[10]);
        }
        v9[10] = v42;
        v43 = (unsigned int)(float)(v27 * (float)v9[11]);
        if ( (unsigned __int8)v34 <= v43 )
        {
          v29 = 11;
          v34 = (unsigned int)(float)(v27 * (float)v9[11]);
        }
        v9[11] = v43;
        v44 = (unsigned int)(float)(v27 * (float)v9[12]);
        if ( (unsigned __int8)v34 <= v44 )
        {
          v29 = 12;
          v34 = (unsigned int)(float)(v27 * (float)v9[12]);
        }
        v9[12] = v44;
        v45 = (unsigned int)(float)(v27 * (float)v9[13]);
        if ( (unsigned __int8)v34 <= v45 )
        {
          v29 = 13;
          v34 = (unsigned int)(float)(v27 * (float)v9[13]);
        }
        v9[13] = v45;
        v46 = (unsigned int)(float)(v27 * (float)v9[14]);
        if ( (unsigned __int8)v34 <= v46 )
        {
          v29 = 14;
          v34 = (unsigned int)(float)(v27 * (float)v9[14]);
        }
        v9[14] = v46;
        v47 = (unsigned int)(float)(v27 * (float)v9[15]);
        if ( (unsigned __int8)v34 <= v47 )
        {
          v29 = 15;
          v34 = (unsigned int)(float)(v27 * (float)v9[15]);
        }
        v9[15] = v47;
        v48 = (unsigned int)(float)(v27 * (float)v9[16]);
        if ( (unsigned __int8)v34 <= v48 )
        {
          v29 = 16;
          v34 = (unsigned int)(float)(v27 * (float)v9[16]);
        }
        v9[16] = v48;
        v49 = (unsigned int)(float)(v27 * (float)v9[17]);
        if ( (unsigned __int8)v34 <= v49 )
          v29 = 17;
        v9[17] = v49;
        v1 = v62 + 1;
        v50 = v61 + v60 + v59 + v35 + v58 + v57 + v56 + v55 + v54 + v41 + v42 + v43 + v44 + v45 + v46;
        v0 = id;
        v9[v29] += 100 - (v48 + v50 + v47 + v49);
      }
      while ( v62 != 11 );
    }
    ++v52;
  }
  while ( v52 != 20 );
  CPopCycle::m_nCurrentTimeOfWeek = 0;
  CPopCycle::m_nCurrentZoneType = -1;
  CPopCycle::m_nCurrentTimeIndex = 0;
  CPopCycle::m_pCurrZoneInfo = 0;
  CFileMgr::CloseFile(id);
}
// 61CADE: using guessed type char byte_61CADE;
// 678AD8: using guessed type int *CPopCycle::m_nCurrentZoneType[5];

//----- (00471D6C) --------------------------------------------------------
bool __fastcall CGame::Init1(const unsigned __int8 *pDatFile)
{
  bool v2; // r4
  int32 v3; // r5
  int v4; // r0
  __int64 v5; // r2
  int v6; // r0
  unsigned int v7; // r1
  CLink<CAnimBlendHierarchy *> *m_pStore; // r6
  CLink<CAnimBlendHierarchy *> *v9; // r5

  CMaths::InitMathsTables();
  strcpy((char *)CGame::aDatFile, (const char *)pDatFile);
  CPools::Initialise();
  CPlaceable::InitMatrixArray();
  CIniFile::LoadIniFile();
  v2 = 0;
  CGame::currArea = AREA_MAIN_MAP;
  CGame::currLevel = LEVEL_GENERIC;
  gameTxdSlot = CTxdStore::AddTxdSlot("generic", "txd", 0);
  CTxdStore::Create(gameTxdSlot);
  CTxdStore::AddRef(gameTxdSlot);
  v3 = CTxdStore::AddTxdSlot("particle", "txd", 1);
  CTxdStore::LoadTxd(v3, "MODELS\\PARTICLE.TXD");
  CTxdStore::AddRef(v3);
  CTxdStore::SetCurrentTxd(gameTxdSlot, 0);
  CGameLogic::InitAtStartOfGame();
  CGangWars::InitAtStartOfGame();
  CConversations::Clear();
  CPedToPlayerConversations::Clear();
  CQuadTreeNode::InitPool();
  if ( CPlantMgr::Initialise() )
  {
    v2 = 0;
    if ( CCustomRoadsignMgr::Initialise() )
    {
      CReferences::Init();
      CDebug::DebugInitTextBuffer();
      CTagManager::Init();
      CWeather::Init();
      CCover::Init();
      CCullZones::Init();
      COcclusion::Init();
      CCollision::Init();
      CBirds::Init();
      CEntryExitManager::Init();
      CStuntJumpManager::Init();
      CSetPieces::Init();
      CTheZones::Init();
      CUserDisplay::Init();
      CMessages::Init();
      CMessages::ClearAllMessagesDisplayedByGame(0);
      CVehicleRecording::Init();
      CRestart::Initialise();
      CWorld::Initialise();
      CAnimManager::ms_numAnimBlocks = 0;
      CAnimManager::ms_numAnimAssocDefinitions = 118;
      CAnimManager::ms_numAnimations = 0;
      v4 = operator new[](0x258u);
      HIDWORD(v5) = &CAnimManager::ms_animCache.m_lastFreeLink;
      CAnimManager::ms_animCache.m_pStore = (CLink<CAnimBlendHierarchy *> *)v4;
      CAnimManager::ms_animCache.m_firstLink.m_pNext = &CAnimManager::ms_animCache.m_lastLink;
      LODWORD(v5) = v4 + 576;
      CAnimManager::ms_animCache.m_lastLink.m_pPrev = (CLink<CAnimBlendHierarchy *> *)&CAnimManager::ms_animCache;
      CAnimManager::ms_animCache.m_lastFreeLink.m_pPrev = (CLink<CAnimBlendHierarchy *> *)(v4 + 588);
      *(_QWORD *)(v4 + 592) = v5;
      *(_DWORD *)(v4 + 580) = &CAnimManager::ms_animCache.m_firstFreeLink;
      *(_DWORD *)(v4 + 584) = v4 + 588;
      v6 = 48;
      CAnimManager::ms_animCache.m_firstFreeLink.m_pNext = (CLink<CAnimBlendHierarchy *> *)v5;
      v7 = 564;
      do
      {
        m_pStore = CAnimManager::ms_animCache.m_pStore;
        --v6;
        v9 = &CAnimManager::ms_animCache.m_pStore[v7 / 0xC];
        v7 -= 12;
        v9->m_pNext = (CLink<CAnimBlendHierarchy *> *)v5;
        CAnimManager::ms_animCache.m_firstFreeLink.m_pNext->m_pPrev = v9;
        v9->m_pPrev = &CAnimManager::ms_animCache.m_firstFreeLink;
        CAnimManager::ms_animCache.m_firstFreeLink.m_pNext = v9;
        LODWORD(v5) = &m_pStore[v6];
      }
      while ( v7 != -12 );
      CAnimManager::ReadAnimAssociationDefinitions();
      CAnimManager::RegisterAnimBlock((const unsigned __int8 *)&off_471F88);
      CCutsceneMgr::Initialise();
      CCarCtrl::Init();
      InitModelIndices();
      CModelInfo::Initialise();
      CPickups::Init();
      CTheCarGenerators::Init();
      CGarages::Init();
      CAudioZones::Init();
      CStreaming::InitImageList();
      CStreaming::ReadIniFile();
      CPathFind::Init(&ThePaths);
      CPathFind::AllocatePathFindInfoMem(&ThePaths);
      CTaskSimpleFight::LoadMeleeData();
      CCheat::ResetCheats();
      Fx_c::Init(&g_fx);
      return 1;
    }
  }
  return v2;
}
// 471F88: using guessed type void *off_471F88;

//----- (00471F94) --------------------------------------------------------
void CAnimManager::Initialise()
{
  CLink<CAnimBlendHierarchy *> *v0; // r0
  CLink<CAnimBlendHierarchy *> *v1; // lr
  int v2; // r0
  unsigned int v3; // r1
  CLink<CAnimBlendHierarchy *> *m_pStore; // r4
  CLink<CAnimBlendHierarchy *> *v5; // r3

  CAnimManager::ms_numAnimBlocks = 0;
  CAnimManager::ms_numAnimAssocDefinitions = 118;
  CAnimManager::ms_numAnimations = 0;
  v0 = (CLink<CAnimBlendHierarchy *> *)operator new[](0x258u);
  v1 = v0 + 48;
  CAnimManager::ms_animCache.m_pStore = v0;
  CAnimManager::ms_animCache.m_firstLink.m_pNext = &CAnimManager::ms_animCache.m_lastLink;
  CAnimManager::ms_animCache.m_lastLink.m_pPrev = (CLink<CAnimBlendHierarchy *> *)&CAnimManager::ms_animCache;
  CAnimManager::ms_animCache.m_lastFreeLink.m_pPrev = v0 + 49;
  v0[49].m_pPrev = &CAnimManager::ms_animCache.m_firstFreeLink;
  v0[49].m_pNext = &CAnimManager::ms_animCache.m_lastFreeLink;
  CAnimManager::ms_animCache.m_firstFreeLink.m_pNext = v0 + 49;
  v0[48].m_pNext = v0 + 49;
  CAnimManager::ms_animCache.m_firstFreeLink.m_pNext->m_pPrev = v0 + 48;
  v0[48].m_pPrev = &CAnimManager::ms_animCache.m_firstFreeLink;
  v2 = 48;
  CAnimManager::ms_animCache.m_firstFreeLink.m_pNext = v1;
  v3 = 564;
  do
  {
    m_pStore = CAnimManager::ms_animCache.m_pStore;
    --v2;
    v5 = &CAnimManager::ms_animCache.m_pStore[v3 / 0xC];
    v3 -= 12;
    v5->m_pNext = v1;
    CAnimManager::ms_animCache.m_firstFreeLink.m_pNext->m_pPrev = v5;
    v5->m_pPrev = &CAnimManager::ms_animCache.m_firstFreeLink;
    CAnimManager::ms_animCache.m_firstFreeLink.m_pNext = v5;
    v1 = &m_pStore[v2];
  }
  while ( v3 != -12 );
  CAnimManager::ReadAnimAssociationDefinitions();
  sub_19D1CC((const unsigned __int8 *)&off_472054);
}
// 472054: using guessed type void *off_472054;

//----- (00472058) --------------------------------------------------------
void InitModelIndices()
{
  MI_TRAFFICLIGHTS_VERTICAL = -1;
  MI_TRAFFICLIGHTS = -1;
  MI_BASKETBALL = -1;
  MI_HYDRAULICS = -1;
  MI_STEREO_UPGRADE = -1;
  MI_TRAFFICLIGHTS_MIAMI = -1;
  MI_POOL_CUE_BALL = -1;
  MI_PUNCHBAG = -1;
  MI_IMY_GRAY_CRATE = -1;
  MI_TRAFFICLIGHTS_VEGAS = -1;
  MI_TRAFFICLIGHTS_TWOVERTICAL = -1;
  MI_SINGLESTREETLIGHTS1 = -1;
  MI_SINGLESTREETLIGHTS2 = -1;
  MI_SINGLESTREETLIGHTS3 = -1;
  MI_DOUBLESTREETLIGHTS = -1;
  MI_STREETLAMP1 = -1;
  MI_STREETLAMP2 = -1;
  MODELID_CRANE_1 = -1;
  MODELID_CRANE_2 = -1;
  MODELID_CRANE_3 = -1;
  MODELID_CRANE_4 = -1;
  MODELID_CRANE_5 = -1;
  MODELID_CRANE_6 = -1;
  MI_PARKINGMETER = -1;
  MI_PARKINGMETER2 = -1;
  MI_HOTELFAN_NIGHT = -1;
  MI_MALLFAN = -1;
  MI_HOTELFAN_DAY = -1;
  MI_HOTROOMFAN = -1;
  MI_PHONEBOOTH1 = -1;
  MI_WASTEBIN = -1;
  MI_BIN = -1;
  MI_POSTBOX1 = -1;
  MI_NEWSSTAND = -1;
  MI_TRAFFICCONE = -1;
  MI_DUMP1 = -1;
  MI_ROADWORKBARRIER1 = -1;
  MI_ROADBLOCKFUCKEDCAR1 = -1;
  MI_ROADBLOCKFUCKEDCAR2 = -1;
  MI_BUSSIGN1 = -1;
  MI_NOPARKINGSIGN1 = -1;
  MI_PHONESIGN = -1;
  MI_FIRE_HYDRANT = -1;
  MI_COLLECTABLE1 = -1;
  MI_MONEY = -1;
  MI_CARMINE = -1;
  MI_NAUTICALMINE = -1;
  MI_TELLY = -1;
  MI_BRIEFCASE = -1;
  MI_GLASS1 = -1;
  MI_GLASS8 = -1;
  MI_EXPLODINGBARREL = -1;
  MI_PICKUP_ADRENALINE = -1;
  MI_PICKUP_BODYARMOUR = -1;
  MI_PICKUP_INFO = -1;
  MI_PICKUP_HEALTH = -1;
  MI_PICKUP_PROPERTY = -1;
  MI_PICKUP_PROPERTY_FORSALE = -1;
  MI_PICKUP_BONUS = -1;
  MI_PICKUP_BRIBE = -1;
  MI_PICKUP_KILLFRENZY = -1;
  MI_PICKUP_CAMERA = -1;
  MI_PICKUP_PARACHUTE = -1;
  MI_PICKUP_REVENUE = -1;
  MI_PICKUP_SAVEGAME = -1;
  MI_PICKUP_CLOTHES = -1;
  MI_PICKUP_2P_KILLFRENZY = -1;
  MI_PICKUP_2P_COOP = -1;
  MI_BOLLARDLIGHT = -1;
  MI_PARACHUTE_BACKPACK = -1;
  MI_OYSTER = -1;
  MI_HORSESHOE = -1;
  MI_LAMPPOST1 = -1;
  MI_MLAMPPOST = -1;
  MI_BARRIER1 = -1;
  MI_LITTLEHA_POLICE = -1;
  MI_TELPOLE02 = -1;
  MI_TRAFFICLIGHT01 = -1;
  MI_PARKBENCH = -1;
  MI_LIGHTBEAM = -1;
  MI_AIRPORTRADAR = -1;
  MI_RCBOMB = -1;
  MI_BEACHBALL = -1;
  MI_SANDCASTLE1 = -1;
  MI_SANDCASTLE2 = -1;
  MI_JELLYFISH = -1;
  MI_JELLYFISH01 = -1;
  MI_FISH1SINGLE = -1;
  MI_FISH1S = -1;
  MI_FISH2SINGLE = -1;
  MI_FISH2S = -1;
  MI_FISH3SINGLE = -1;
  MI_FISH3S = -1;
  MI_TURTLE = -1;
  MI_DOLPHIN = -1;
  MI_SHARK = -1;
  MI_SUBMARINE = -1;
  MI_ESCALATORSTEP = -1;
  MI_ESCALATORSTEP8 = -1;
  MI_LOUNGE_WOOD_UP = -1;
  MI_LOUNGE_TOWEL_UP = -1;
  MI_LOUNGE_WOOD_DN = -1;
  MI_LOTION = -1;
  MI_BEACHTOWEL01 = -1;
  MI_BEACHTOWEL02 = -1;
  MI_BEACHTOWEL03 = -1;
  MI_BEACHTOWEL04 = -1;
  MI_BLIMP_NIGHT = -1;
  MI_BLIMP_DAY = -1;
  MI_YT_MAIN_BODY = -1;
  MI_YT_MAIN_BODY2 = -1;
  MI_TRAFFICLIGHTS_3 = -1;
  MI_TRAFFICLIGHTS_4 = -1;
  MI_TRAFFICLIGHTS_5 = -1;
  MI_TRAFFICLIGHTS_GAY = -1;
  MI_IMY_SHASH_WALL = -1;
}

//----- (00472614) --------------------------------------------------------
void CStreaming::ReadIniFile()
{
  u_native v0; // r4
  char *Line; // r0
  int v2; // r9
  int v3; // r0
  int32 *v4; // r1
  int v5; // r1
  bool v6; // zf
  char *v7; // r10
  char *v8; // r11
  int v9; // r0
  double v10; // d16
  float *v11; // r0
  float v12; // s0

  v0 = CFileMgr::OpenFile("stream.ini", "r");
  Line = (char *)CFileLoader::LoadLine(v0);
  if ( Line )
  {
    v2 = 0;
    do
    {
      v5 = (unsigned __int8)*Line;
      v6 = v5 == 0;
      if ( *Line )
        v6 = v5 == 35;
      if ( v6 )
        goto LABEL_32;
      v7 = strtok(Line, " ,\t");
      v8 = strtok(0, " ,\t");
      if ( ((strcasecmp(v7, "memory") != 0) | v2) << 31 )
      {
        if ( !strcasecmp(v7, "devkit_memory") )
        {
          v9 = atoi(v8);
          v4 = (int32 *)&CStreaming::ms_memoryAvailable;
          v3 = v9 << 10;
          v2 = 1;
        }
        else if ( !strcasecmp(v7, "vehicles") )
        {
          v3 = atoi(v8);
          v4 = &CStreaming::desiredNumVehiclesLoaded;
        }
        else
        {
          if ( !strcasecmp(v7, "dontbuildpaths") )
          {
            bDontBuildPaths = 1;
            goto LABEL_32;
          }
          if ( !strcasecmp(v7, "pe_lightchangerate") )
          {
            v10 = atof(v8);
            v11 = &CPostEffects::SCREEN_EXTRA_MULT_CHANGE_RATE;
LABEL_31:
            v12 = v10;
            *v11 = v12;
            goto LABEL_32;
          }
          if ( !strcasecmp(v7, "pe_lightingbasecap") )
          {
            v10 = atof(v8);
            v11 = &CPostEffects::SCREEN_EXTRA_MULT_BASE_CAP;
            goto LABEL_31;
          }
          if ( !strcasecmp(v7, "pe_lightingbasemult") )
          {
            v10 = atof(v8);
            v11 = &CPostEffects::SCREEN_EXTRA_MULT_BASE_MULT;
            goto LABEL_31;
          }
          if ( !strcasecmp(v7, "pe_leftx") )
          {
            v3 = atoi(v8);
            v4 = &CPostEffects::m_colourLeftUOffset;
          }
          else if ( !strcasecmp(v7, "pe_rightx") )
          {
            v3 = atoi(v8);
            v4 = &CPostEffects::m_colourRightUOffset;
          }
          else if ( !strcasecmp(v7, "pe_topy") )
          {
            v3 = atoi(v8);
            v4 = &CPostEffects::m_colourTopVOffset;
          }
          else
          {
            if ( strcasecmp(v7, "pe_bottomy") )
            {
              if ( !strcasecmp(v7, "pe_bRadiosity") )
                CPostEffects::m_bRadiosity = atoi(v8) != 0;
              goto LABEL_32;
            }
            v3 = atoi(v8);
            v4 = &CPostEffects::m_colourBottomVOffset;
          }
        }
        *v4 = v3;
      }
      else
      {
        v2 = 0;
        CStreaming::ms_memoryAvailable = atoi(v8) << 10;
      }
LABEL_32:
      Line = (char *)CFileLoader::LoadLine(v0);
    }
    while ( Line );
  }
  sub_19B258(v0);
}

//----- (00472900) --------------------------------------------------------
void CTaskSimpleFight::LoadMeleeData()
{
  int v0; // r3
  tMeleeComboSet *v1; // r2
  u_native v2; // r4
  unsigned __int8 *Line; // r10
  int v4; // r9
  int v5; // r8
  int v6; // r6
  int v7; // r11
  int v8; // r0
  double v9; // d16
  CVector *v10; // r0
  char v11; // r5
  int v12; // r0
  bool v13; // cf
  int v14; // r6
  int v15; // r1
  float *v16; // r0
  AssocGroupId v17; // r6
  const unsigned __int8 *AnimGroupName; // r0
  float v19; // s2
  tMeleeComboSet *v20; // r0
  char v21; // r2
  tMeleeComboSet *v22; // r0
  char *v23; // r1
  AssocGroupId *v24; // r0
  int v25; // r2
  int v26; // r1
  int v27; // r2
  float v28; // s0
  int v29; // r0
  bool v30; // zf
  int v31; // [sp+20h] [bp-D8h]
  int v32; // [sp+48h] [bp-B0h]
  double v33; // [sp+58h] [bp-A0h] BYREF
  RwReal v34; // [sp+60h] [bp-98h] BYREF
  float v35; // [sp+68h] [bp-90h] BYREF
  int v36; // [sp+6Ch] [bp-8Ch] BYREF
  int v37; // [sp+70h] [bp-88h] BYREF
  int v38; // [sp+74h] [bp-84h] BYREF
  int v39; // [sp+78h] [bp-80h] BYREF
  int v40; // [sp+7Ch] [bp-7Ch] BYREF
  float v41; // [sp+80h] [bp-78h] BYREF
  float v42; // [sp+84h] [bp-74h] BYREF
  float v43; // [sp+88h] [bp-70h] BYREF
  char v44[32]; // [sp+8Ch] [bp-6Ch] BYREF
  char v45; // [sp+ACh] [bp-4Ch] BYREF

  v0 = 0;
  do
  {
    v1 = &CTaskSimpleFight::m_aComboData[v0];
    CTaskSimpleFight::m_aComboData[v0++].nAnimGroup = ANIM_MELEE_UNARMED_1;
    *(_WORD *)v1->aHitLevel = 1799;
    *(_WORD *)v1->aDamage = 0;
    *(_QWORD *)&v1->aRadius[4] = 1065353216LL;
    *(_QWORD *)&v1->aBlockLoopStart = 0x42C8000042C80000LL;
    v1->aDamage[2] = 0;
    *(_WORD *)&v1->aHitLevel[2] = 1799;
    v1->aDamage[3] = 0;
    v1->fGroupRange = 1.5;
    v1->aFireTime[0] = 100.0;
    v1->aFireTime[1] = 100.0;
    v1->aFireTime[2] = 100.0;
    v1->aFireTime[3] = 100.0;
    v1->aFireTime[4] = 100.0;
    v1->aComboTime[0] = 100.0;
    v1->aComboTime[1] = 100.0;
    v1->aComboTime[2] = 100.0;
    v1->aComboTime[3] = 100.0;
    v1->aComboTime[4] = 100.0;
    v1->aRadius[0] = 1.0;
    v1->aRadius[1] = 1.0;
    v1->aRadius[2] = 1.0;
    v1->aRadius[3] = 1.0;
    v1->aHitLevel[4] = 7;
    v1->aDamage[4] = 0;
    v1->aHitSound[0] = 0;
    v1->aHitSound[1] = 0;
    v1->aHitSound[2] = 0;
    v1->aHitSound[3] = 0;
    v1->aHitSound[4] = 0;
    v1->aAltHitSound[0] = 0;
    v1->aAltHitSound[1] = 0;
    v1->aAltHitSound[2] = 0;
    v1->aAltHitSound[3] = 0;
    v1->aAltHitSound[4] = 0;
    v1->nFlags = 0;
  }
  while ( v0 != 13 );
  *(_QWORD *)&CTaskSimpleFight::m_aHitOffset[0].x = 0x3F40000000000000LL;
  *(_QWORD *)&CTaskSimpleFight::m_aHitOffset[0].z = 0LL;
  *(_QWORD *)&CTaskSimpleFight::m_aHitOffset[1].y = loc_472DA0;
  *(_QWORD *)&CTaskSimpleFight::m_aHitOffset[2].x = loc_472DA8;
  *(_QWORD *)&CTaskSimpleFight::m_aHitOffset[5].y = loc_472DA0;
  *(_QWORD *)&CTaskSimpleFight::m_aHitOffset[6].x = loc_472DA8;
  *(_QWORD *)&CTaskSimpleFight::m_aHitOffset[4].x = 0x3F40000000000000LL;
  *(_QWORD *)&CTaskSimpleFight::m_aHitOffset[4].z = 0LL;
  *(_QWORD *)&CTaskSimpleFight::m_aHitOffset[2].z = loc_472DB0;
  *(_QWORD *)&CTaskSimpleFight::m_aHitOffset[3].y = loc_472DB8;
  CTaskSimpleFight::m_aHitOffset[6].z = 0.0;
  v2 = CFileMgr::OpenFile("DATA\\melee.dat", "rb");
  Line = CFileLoader::LoadLine(v2);
  if ( Line )
  {
    v4 = 0;
    v5 = 0;
    v6 = 0;
    v7 = 0;
    v32 = 0;
    do
    {
      v29 = *Line;
      v30 = v29 == 35;
      if ( v29 != 35 )
        v30 = v29 == 0;
      if ( !v30 )
      {
        if ( !strncmp((const char *)Line, "END_MELEE_DATA", 0xEu) )
          break;
        if ( (v5 | v4) << 31 )
        {
          if ( !strncmp((const char *)Line, "END_COMBO", 9u) )
          {
            v6 = 0;
            v7 += v5 & 1;
            v5 = 0;
            v4 = 0;
          }
          else if ( v4 << 31 )
          {
            sscanf((const char *)Line, "%s %f %f %f", &v45, &v33, (char *)&v33 + 4, &v34);
            v8 = v6;
            v9 = v33;
            ++v6;
            v10 = &CTaskSimpleFight::m_aHitOffset[v8];
            v4 = 1;
            v10->z = v34;
            *(double *)&v10->x = v9;
          }
          else
          {
            v31 = v6 + 1;
            switch ( v6 )
            {
              case 0:
                sscanf((const char *)Line, "%s %s", &v45, v44);
                if ( CAnimManager::ms_numAnimAssocDefinitions < 1 )
                  goto LABEL_37;
                v17 = ANIM_STD_PED;
                do
                {
                  AnimGroupName = CAnimManager::GetAnimGroupName(v17);
                  if ( !strcmp(v44, (const char *)AnimGroupName) )
                  {
                    CTaskSimpleFight::m_aComboData[v7].nAnimGroup = v17;
                    goto LABEL_37;
                  }
                  ++v17;
                  v4 = 0;
                }
                while ( v17 < CAnimManager::ms_numAnimAssocDefinitions );
                v6 = v31;
                break;
              case 1:
                sscanf((const char *)Line, "%s %f", &v45, &v43);
                CTaskSimpleFight::m_aComboData[v7].fGroupRange = v43;
                goto LABEL_37;
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                v11 = 0;
                v35 = 0.0;
                sscanf(
                  (const char *)Line,
                  "%s %f %f %f %s %d %d %d %f",
                  &v45,
                  &v42,
                  &v41,
                  &v40,
                  v44,
                  &v39,
                  &v37,
                  &v36,
                  &v35);
                v12 = v6 - 2;
                v13 = (unsigned int)(v6 - 2) >= 5;
                v14 = v32;
                if ( !v13 )
                  v14 = v12;
                v15 = v40;
                v16 = (float *)(&CTaskSimpleFight::m_aComboData[v7].nAnimGroup + v14);
                v16[2] = v42 * 0.033333;
                v16[7] = v41 * 0.033333;
                *((_DWORD *)v16 + 12) = v15;
                switch ( v44[0] )
                {
                  case 'B':
                    v11 = 3;
                    break;
                  case 'G':
                    v11 = 2;
                    break;
                  case 'H':
                    break;
                  case 'L':
                    v11 = 1;
                    break;
                  default:
                    if ( !strcmp(v44, (const char *)&off_472E54) )
                    {
                      v11 = 4;
                    }
                    else if ( !strcmp(v44, (const char *)&off_472E58) )
                    {
                      v11 = 5;
                    }
                    else
                    {
                      v11 = 7;
                      if ( !strcmp(v44, (const char *)&dword_472E5C) )
                        v11 = 6;
                    }
                    break;
                }
                v21 = v39;
                v22 = &CTaskSimpleFight::m_aComboData[v7];
                v23 = (char *)v22 + v14;
                v24 = &v22->nAnimGroup + v14;
                v23[80] = v11;
                v23[85] = v21;
                v25 = 62;
                if ( (unsigned int)(v37 - 1) < 8 )
                  v25 = v37 + 60;
                v26 = v36;
                *((_DWORD *)v24 + 23) = v25;
                v32 = v14;
                v27 = 62;
                if ( (unsigned int)(v26 - 1) < 8 )
                  v27 = v26 + 60;
                v28 = v35;
                *((_DWORD *)v24 + 28) = v27;
                if ( v28 > 0.0 )
                  CTaskSimpleFight::m_aComboData[v7].aGroundLoopStart = v28 * 0.033333;
                v4 = 0;
                v6 = v31;
                break;
              case 7:
                sscanf((const char *)Line, "%s %f %f", &v45, &v42, &v41);
                v19 = v41 * 0.033333;
                v20 = &CTaskSimpleFight::m_aComboData[v7];
                v20->aBlockLoopStart = v42 * 0.033333;
                v20->aBlockLoopEnd = v19;
                goto LABEL_37;
              case 8:
                sscanf((const char *)Line, "%s %x", &v45, &v38);
                CTaskSimpleFight::m_aComboData[v7].nFlags = v38;
LABEL_37:
                v4 = 0;
                v6 = v31;
                break;
              default:
                v4 = 0;
                ++v6;
                break;
            }
          }
        }
        else
        {
          v4 = 0;
          if ( !strncmp((const char *)Line, "START_COMBO", 0xBu) )
          {
            v5 = 1;
          }
          else
          {
            v4 = strncmp((const char *)Line, "START_LEVELS", 0xCu) == 0;
            v5 = 0;
          }
        }
      }
      Line = CFileLoader::LoadLine(v2);
    }
    while ( Line );
  }
  CFileMgr::CloseFile(v2);
}
// 472E54: using guessed type void *off_472E54;
// 472E58: using guessed type void *off_472E58;
// 472E5C: using guessed type int dword_472E5C;

//----- (00472E9C) --------------------------------------------------------
void ReadPlayerCoordsFile()
{
  u_native v0; // r0
  u_native v1; // r4
  unsigned __int8 *Line; // r0
  CPlayerPed *pPed; // r5
  RwReal y; // r1
  CMatrix *m_pMat; // r3
  RwReal z; // r0
  RwReal *p_tz; // r1
  CVector posn; // [sp+4h] [bp-14h] BYREF

  v0 = CFileMgr::OpenFile("playercoords.txt", "r");
  v1 = v0;
  if ( v0 )
  {
    Line = CFileLoader::LoadLine(v0);
    if ( sscanf((const char *)Line, "%f%f%f", &posn, &posn.y, &posn.z) == 3 )
    {
      pPed = CWorld::Players[0].pPed;
      if ( CWorld::Players[0].pPed )
      {
        CStreaming::LoadScene(&posn);
        y = posn.y;
        m_pMat = pPed->m_pMat;
        z = posn.z;
        if ( m_pMat )
        {
          m_pMat->tx = posn.x;
          pPed->m_pMat->ty = y;
          p_tz = &pPed->m_pMat->tz;
        }
        else
        {
          pPed->m_transform.m_translate.x = posn.x;
          pPed->m_transform.m_translate.y = y;
          p_tz = &pPed->m_transform.m_translate.z;
        }
        *p_tz = z;
      }
    }
    CFileMgr::CloseFile(v1);
  }
}

//----- (00472F28) --------------------------------------------------------
bool __fastcall CGame::Init2(const unsigned __int8 *pDatFile)
{
  bool v1; // r4

  v1 = 0;
  LoadingScreen("Loading the Game", "Add Particles", 0);
  CTheZones::PostZoneCreation();
  CEntryExitManager::PostEntryExitsCreation();
  LoadingScreen("Loading the Game", "Setup paths", 0);
  CPathFind::PreparePathData(&ThePaths);
  CPlayerInfo::Clear(CWorld::Players);
  CPlayerInfo::Clear(&CWorld::Players[1]);
  CPlayerInfo::LoadPlayerSkin(CWorld::Players);
  TestModelIndices();
  LoadingScreen("Loading the Game", "Setup water", 0);
  CClothes::Init();
  CWaterLevel::WaterLevelInitialise();
  CDraw::SetFOV(120.0, 0);
  CDraw::ms_fLODDistance = 500.0;
  if ( CCustomCarPlateMgr::Initialise() )
  {
    LoadingScreen("Loading the Game", "Setup streaming", 0);
    CStreaming::LoadInitialVehicles();
    CStreaming::LoadInitialPeds();
    CStreaming::LoadAllRequestedModels(0);
    LoadingScreen("Loading the Game", "Load animations", 0);
    CAnimManager::LoadAnimFiles();
    LoadingScreen("Loading the Game", "Setup streaming", 0);
    CStreaming::LoadInitialWeapons();
    CStreaming::LoadAllRequestedModels(0);
    LoadingScreen("Loading the Game", "Ped Init", 0);
    CPed::Initialise();
    CRenderer::Init();
    LoadingScreen("Loading the Game", "Setup game variables", 0);
    CRadar::Initialise();
    CRadar::LoadTextures();
    LoadingScreen(0, 0, 0);
    CWeapon::InitialiseWeapons();
    CRoadBlocks::Init();
    LoadingScreen(0, 0, 0);
    CPopulation::Initialise();
    LoadingScreen(0, 0, 0);
    CWorld::PlayerInFocus = 0;
    CCoronas::Init();
    CShadows::Init();
    LoadingScreen(0, 0, 0);
    CWeaponEffects::Init();
    CSkidmarks::Init();
    CGlass::Init();
    CGarages::Init_AfterRestart();
    LoadingScreen("Loading the Game", "Load scripts", 0);
    CTheScripts::Init();
    CGangs::Initialise();
    LoadingScreen("Loading the Game", "Setup game variables", 0);
    CClock::Initialise(0x3E8u);
    CHeli::InitHelis();
    CCranes::InitCranes();
    LoadingScreen(0, 0, 0);
    CMovingThings::Init();
    CDarkel::Init();
    LoadingScreen(0, 0, 0);
    CGridRef::Init();
    CStats::Init();
    CClouds::Init();
    CSpecialFX::Init();
    LoadingScreen(0, 0, 0);
    CRopes::Init();
    CWaterCannons::Init();
    CBridge::Init();
    CPedGroups::Init();
    CInformFriendsEventQueue::Init();
    CInformGroupEventQueue::Init();
    LoadingScreen(0, 0, 0);
    CCredits::bCreditsGoing = 0;
    CShopping::Init();
    LoadingScreen(0, 0, 0);
    return 1;
  }
  return v1;
}

//----- (004731A8) --------------------------------------------------------
bool __fastcall CGame::Init3(const unsigned __int8 *pDatFile)
{
  CPad *Pad; // r0
  CPad *v2; // r0

  LoadingScreen("Loading the Game", "Load scene", 0);
  Pad = CPad::GetPad(0);
  CPad::Clear(Pad, 1, 1);
  v2 = CPad::GetPad(1);
  CPad::Clear(v2, 1, 1);
  LoadingScreen("Loading the Game", "Procedural Interiors", 0);
  InteriorManager_c::Init(&g_interiorMan);
  ProcObjectMan_c::Init(&g_procObjMan);
  WaterCreatureManager_c::Init(&g_waterCreatureMan);
  CRealTimeShadowManager::Init(&g_realTimeShadowMan);
  return 1;
}

//----- (00473248) --------------------------------------------------------
void __fastcall cHandlingDataMgr::LoadHandlingData(cHandlingDataMgr *this)
{
  u_native v1; // r8
  const char *v2; // r4
  tHandlingData *v3; // r11
  tBikeHandlingData *v4; // r9
  unsigned __int8 (*v5)[14]; // r10
  CVehicleAnimGroup *v6; // r1
  int v7; // r0
  char *v8; // r11
  float v9; // s0
  float v10; // s0
  float v11; // s0
  RwReal v12; // s0
  RwReal v13; // s0
  RwReal v14; // s0
  float v15; // s0
  float v16; // s0
  float v17; // s0
  float v18; // s0
  float v19; // s0
  float v20; // s0
  float v21; // s0
  float v22; // s0
  float v23; // s0
  float v24; // s0
  float v25; // s0
  float v26; // s0
  float v27; // s0
  float v28; // s0
  float v29; // s0
  float v30; // s0
  float v31; // s0
  float v32; // s0
  char v33; // r4
  unsigned __int8 *v34; // r3
  const char *v35; // r9
  int v36; // r4
  tBoatHandlingData *BoatPointer; // r6
  float v38; // s0
  float v39; // s0
  float v40; // s0
  float v41; // s0
  float v42; // s0
  float v43; // s0
  float v44; // s0
  RwReal v45; // s0
  RwReal v46; // s0
  RwReal v47; // s0
  RwReal v48; // s0
  RwReal v49; // s0
  RwReal v50; // s0
  float v51; // s0
  char v52; // r10
  unsigned __int8 *v53; // r1
  unsigned __int8 *Line; // r0
  char *v55; // r9
  char *v56; // r0
  char v57; // r4
  unsigned __int8 *v58; // r1
  int v59; // r0
  char *v60; // r1
  float v61; // s0
  float v62; // s0
  float v63; // s0
  float v64; // s0
  float v65; // s0
  float v66; // s0
  float v67; // s0
  float v68; // s0
  float v69; // s0
  float v70; // s0
  float v71; // s0
  float v72; // s0
  float v73; // s0
  float v74; // s0
  float v75; // s0
  float v76; // s0
  float v77; // s0
  float v78; // s0
  float v79; // s0
  float v80; // s0
  float v81; // s0
  char v82; // r4
  char *v83; // r0
  unsigned __int8 *v84; // r1
  int ExactWord; // r0
  char *v86; // r1
  float v87; // s0
  float v88; // s0
  float v89; // s0
  float v90; // s0
  float v91; // s0
  float v92; // s0
  float v93; // s0
  float v94; // s0
  float v95; // s0
  float v96; // s0
  float v97; // s0
  float v98; // s0
  float v99; // s0
  float v100; // s0
  float v101; // s0
  char v102; // r4
  char *v103; // r0
  int v104; // r9
  int v105; // r11
  float v106; // s0
  float v107; // s0
  float v108; // s0
  float v109; // s0
  float v110; // s0
  float v111; // s0
  float v112; // s0
  float v113; // s0
  float v114; // s0
  float v115; // s0
  float v116; // s0
  float v117; // s0
  float v118; // s0
  unsigned __int8 *szArray; // [sp+8h] [bp-90h]
  char v120; // [sp+10h] [bp-88h]
  char v121; // [sp+14h] [bp-84h]
  int v122; // [sp+18h] [bp-80h]
  float v123; // [sp+1Ch] [bp-7Ch]
  float v124; // [sp+20h] [bp-78h]
  float v125; // [sp+24h] [bp-74h]
  float v126; // [sp+28h] [bp-70h]
  float v127; // [sp+2Ch] [bp-6Ch]
  float v128; // [sp+30h] [bp-68h]
  float v129; // [sp+34h] [bp-64h]
  float v130; // [sp+38h] [bp-60h]
  float v131; // [sp+3Ch] [bp-5Ch]
  float v132; // [sp+40h] [bp-58h]
  float v133; // [sp+44h] [bp-54h]
  float v134; // [sp+48h] [bp-50h]
  float v135; // [sp+4Ch] [bp-4Ch]
  tBoatHandlingData *v136; // [sp+54h] [bp-44h]
  tHandlingData *v137; // [sp+58h] [bp-40h]
  tBikeHandlingData *v138; // [sp+5Ch] [bp-3Ch]
  float *v140; // [sp+64h] [bp-34h]
  char v141[4]; // [sp+68h] [bp-30h] BYREF
  char v142[4]; // [sp+6Ch] [bp-2Ch] BYREF
  char v143[4]; // [sp+70h] [bp-28h] BYREF
  char v144[4]; // [sp+74h] [bp-24h] BYREF
  char v145[32]; // [sp+78h] [bp-20h] BYREF

  CFileMgr::SetDir("DATA");
  v1 = CFileMgr::OpenFile("HANDLING.CFG", "rb");
  CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
  v2 = ";the end";
  v3 = 0;
  v4 = 0;
  v5 = VehicleNames;
  v135 = COERCE_FLOAT(&VehicleNames_ptr);
  v134 = COERCE_FLOAT(&VehicleNames_ptr);
  v133 = COERCE_FLOAT(&VehicleNames_ptr);
  v132 = COERCE_FLOAT(&VehicleNames_ptr);
  v131 = COERCE_FLOAT(&VehicleNames_ptr);
  v130 = COERCE_FLOAT(&VehicleNames_ptr);
  v129 = COERCE_FLOAT(&VehicleNames_ptr);
  v128 = COERCE_FLOAT(&VehicleNames_ptr);
  v127 = COERCE_FLOAT(&VehicleNames_ptr);
  v126 = COERCE_FLOAT(&VehicleNames_ptr);
  v125 = COERCE_FLOAT(&VehicleNames_ptr);
  v124 = COERCE_FLOAT(&VehicleNames_ptr);
  v123 = COERCE_FLOAT(&VehicleNames_ptr);
  v140 = 0;
  v136 = 0;
  v122 = 0;
  v121 = 0;
  v120 = 0;
  while ( 1 )
  {
    v137 = v3;
LABEL_42:
    v138 = v4;
LABEL_61:
    Line = CFileLoader::LoadLine(v1);
    v55 = (char *)Line;
    if ( !Line || !strcmp((const char *)Line, v2) )
      break;
    switch ( *v55 )
    {
      case '!':
        v82 = 0;
        strcpy(v145, " \t");
        v83 = strtok(v55, v145);
        v4 = v138;
        v84 = (unsigned __int8 *)v83;
        do
        {
          switch ( v82 )
          {
            case 1:
              ExactWord = cHandlingDataMgr::FindExactWord(this, v84, VehicleNames[0], 14, 210);
              v86 = (char *)this + 64 * ExactWord;
              *((_DWORD *)v86 + 9173) = ExactWord;
              v4 = (tBikeHandlingData *)(v86 + 36692);
              break;
            case 2:
              v87 = atof((const char *)v84);
              v4->fLeanFwdCOMMult = v87;
              break;
            case 3:
              v88 = atof((const char *)v84);
              v4->fLeanFwdForceMult = v88;
              break;
            case 4:
              v89 = atof((const char *)v84);
              v4->fLeanBakCOMMult = v89;
              break;
            case 5:
              v90 = atof((const char *)v84);
              v4->fLeanBakForceMult = v90;
              break;
            case 6:
              v91 = atof((const char *)v84);
              v4->fMaxBankAngle = v91;
              break;
            case 7:
              v92 = atof((const char *)v84);
              v4->fFullAnimAngle = v92;
              break;
            case 8:
              v93 = atof((const char *)v84);
              v4->fDesLeanReturnFrac = v93;
              break;
            case 9:
              v94 = atof((const char *)v84);
              v4->fSpeedSteerFrac = v94;
              break;
            case 10:
              v95 = atof((const char *)v84);
              v4->fSlippySpeedSteerMult = v95;
              break;
            case 11:
              v96 = atof((const char *)v84);
              v4->fNoRiderCOMz = v96;
              break;
            case 12:
              v97 = atof((const char *)v84);
              v4->fWheelieBalancePoint = v97;
              break;
            case 13:
              v98 = atof((const char *)v84);
              v4->fStoppieBalancePoint = v98;
              break;
            case 14:
              v99 = atof((const char *)v84);
              v4->fWheelieSteerMult = v99;
              break;
            case 15:
              v100 = atof((const char *)v84);
              v4->fRearBalanceMult = v100;
              break;
            case 16:
              v101 = atof((const char *)v84);
              v4->fFrontBalanceMult = v101;
              break;
            default:
              break;
          }
          ++v82;
          v84 = (unsigned __int8 *)strtok(0, v145);
        }
        while ( v84 );
        cHandlingDataMgr::ConvertBikeDataToGameUnits(this, v4);
        v2 = ";the end";
        goto LABEL_42;
      case '"':
      case '#':
      case '&':
      case '\'':
      case '(':
      case ')':
      case '*':
      case '+':
      case ',':
      case '-':
      case '.':
      case '/':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case ':':
        goto LABEL_65;
      case '$':
        v57 = 0;
        strcpy(v144, " \t");
        v58 = (unsigned __int8 *)strtok(v55, v144);
        do
        {
          switch ( v57 )
          {
            case 1:
              v59 = cHandlingDataMgr::FindExactWord(this, v58, VehicleNames[0], 14, 210);
              v60 = (char *)this + 88 * v59;
              *((_DWORD *)v60 + 7881) = v59;
              v140 = (float *)(v60 + 31524);
              break;
            case 2:
              v61 = atof((const char *)v58);
              v140[1] = v61;
              break;
            case 3:
              v62 = atof((const char *)v58);
              v140[2] = v62;
              break;
            case 4:
              v63 = atof((const char *)v58);
              v140[3] = v63;
              break;
            case 5:
              v64 = atof((const char *)v58);
              v140[4] = v64;
              break;
            case 6:
              v65 = atof((const char *)v58);
              v140[5] = v65;
              break;
            case 7:
              v66 = atof((const char *)v58);
              v140[6] = v66;
              break;
            case 8:
              v67 = atof((const char *)v58);
              v140[7] = v67;
              break;
            case 9:
              v68 = atof((const char *)v58);
              v140[8] = v68;
              break;
            case 10:
              v69 = atof((const char *)v58);
              v140[9] = v69;
              break;
            case 11:
              v70 = atof((const char *)v58);
              v140[10] = v70;
              break;
            case 12:
              v71 = atof((const char *)v58);
              v140[11] = v71;
              break;
            case 13:
              v72 = atof((const char *)v58);
              v140[12] = v72;
              break;
            case 14:
              v73 = atof((const char *)v58);
              v140[13] = v73;
              break;
            case 15:
              v74 = atof((const char *)v58);
              v140[14] = v74;
              break;
            case 16:
              v75 = atof((const char *)v58);
              v140[15] = v75;
              break;
            case 17:
              v76 = atof((const char *)v58);
              v140[16] = v76;
              break;
            case 18:
              v77 = atof((const char *)v58);
              v140[17] = v77;
              break;
            case 19:
              v78 = atof((const char *)v58);
              v140[18] = v78;
              break;
            case 20:
              v79 = atof((const char *)v58);
              v140[19] = v79;
              break;
            case 21:
              v80 = atof((const char *)v58);
              v140[20] = v80;
              break;
            case 22:
              v81 = atof((const char *)v58);
              v140[21] = v81;
              break;
            default:
              break;
          }
          ++v57;
          v58 = (unsigned __int8 *)strtok(0, v144);
        }
        while ( v58 );
        v2 = ";the end";
        goto LABEL_61;
      case '%':
        szArray = (unsigned __int8 *)v5;
        v52 = 0;
        strcpy(v143, " \t");
        BoatPointer = v136;
        v53 = (unsigned __int8 *)strtok(v55, v143);
        do
        {
          switch ( v52 )
          {
            case 1:
              v35 = v2;
              v36 = cHandlingDataMgr::FindExactWord(this, v53, szArray, 14, 210);
              BoatPointer = cHandlingDataMgr::GetBoatPointer(this, v36);
              BoatPointer->nVehicleID = v36;
              v2 = v35;
              break;
            case 2:
              v38 = atof((const char *)v53);
              BoatPointer->fThrustOffsetY = v38;
              break;
            case 3:
              v39 = atof((const char *)v53);
              BoatPointer->fThrustOffsetZ = v39;
              break;
            case 4:
              v40 = atof((const char *)v53);
              BoatPointer->fThrustAppOffsetZ = v40;
              break;
            case 5:
              v41 = atof((const char *)v53);
              BoatPointer->fAquaplaneForce = v41;
              break;
            case 6:
              v42 = atof((const char *)v53);
              BoatPointer->fAquaplaneLimit = v42;
              break;
            case 7:
              v43 = atof((const char *)v53);
              BoatPointer->fAquaplaneOffsetY = v43;
              break;
            case 8:
              v44 = atof((const char *)v53);
              BoatPointer->fWaveAudioMult = v44;
              break;
            case 9:
              v45 = atof((const char *)v53);
              BoatPointer->vecMoveResistance.x = v45;
              break;
            case 10:
              v46 = atof((const char *)v53);
              BoatPointer->vecMoveResistance.y = v46;
              break;
            case 11:
              v47 = atof((const char *)v53);
              BoatPointer->vecMoveResistance.z = v47;
              break;
            case 12:
              v48 = atof((const char *)v53);
              BoatPointer->vecTurnResistance.x = v48;
              break;
            case 13:
              v49 = atof((const char *)v53);
              BoatPointer->vecTurnResistance.y = v49;
              break;
            case 14:
              v50 = atof((const char *)v53);
              BoatPointer->vecTurnResistance.z = v50;
              break;
            case 15:
              v51 = atof((const char *)v53);
              BoatPointer->Look_L_R_CamHeight = v51;
              break;
            default:
              break;
          }
          ++v52;
          v53 = (unsigned __int8 *)strtok(0, v143);
        }
        while ( v53 );
        v136 = BoatPointer;
        v5 = (unsigned __int8 (*)[14])szArray;
        goto LABEL_61;
      case ';':
        goto LABEL_61;
      default:
        if ( *v55 == 94 )
        {
          v102 = 0;
          strcpy(v142, " \t");
          v103 = strtok(v55, v142);
          v104 = 0;
          v105 = 0;
          do
          {
            switch ( v102 )
            {
              case 1:
                v122 = atoi(v103);
                break;
              case 2:
                v121 = atoi(v103);
                break;
              case 3:
                v120 = atoi(v103);
                break;
              case 4:
                if ( atoi(v103) )
                  v104 |= 1u;
                break;
              case 5:
                if ( atoi(v103) )
                  v104 |= 2u;
                break;
              case 6:
                if ( atoi(v103) )
                  v104 |= 4u;
                break;
              case 7:
                if ( atoi(v103) )
                  v104 |= 8u;
                break;
              case 8:
                if ( atoi(v103) )
                  v104 |= 0x10u;
                break;
              case 9:
                if ( atoi(v103) )
                  v104 |= 0x20u;
                break;
              case 10:
                if ( atoi(v103) )
                  v104 |= 0x40u;
                break;
              case 11:
                if ( atoi(v103) )
                  v104 |= 0x80u;
                break;
              case 12:
                if ( atoi(v103) )
                  v104 |= 0x100u;
                break;
              case 13:
                if ( atoi(v103) )
                  v104 |= 0x200u;
                break;
              case 14:
                if ( atoi(v103) )
                  v104 |= 0x400u;
                break;
              case 15:
                if ( atoi(v103) )
                  v104 |= 0x800u;
                break;
              case 16:
                if ( atoi(v103) )
                  v104 |= 0x1000u;
                break;
              case 17:
                if ( atoi(v103) )
                  v104 |= 0x2000u;
                break;
              case 18:
                if ( atoi(v103) )
                  v104 |= 0x4000u;
                break;
              case 19:
                if ( atoi(v103) )
                  v104 |= 0x8000u;
                break;
              case 20:
                if ( atoi(v103) )
                  v104 |= 0x10000u;
                break;
              case 21:
                if ( atoi(v103) )
                  v104 |= 0x20000u;
                break;
              case 22:
                v106 = atof(v103);
                v127 = v106;
                break;
              case 23:
                v107 = atof(v103);
                v126 = v107;
                break;
              case 24:
                v108 = atof(v103);
                v125 = v108;
                break;
              case 25:
                v109 = atof(v103);
                v124 = v109;
                break;
              case 26:
                v110 = atof(v103);
                v123 = v110;
                break;
              case 27:
                v111 = atof(v103);
                v131 = v111;
                break;
              case 28:
                v112 = atof(v103);
                v135 = v112;
                break;
              case 29:
                v113 = atof(v103);
                v130 = v113;
                break;
              case 30:
                v114 = atof(v103);
                v134 = v114;
                break;
              case 31:
                v115 = atof(v103);
                v129 = v115;
                break;
              case 32:
                v116 = atof(v103);
                v133 = v116;
                break;
              case 33:
                v117 = atof(v103);
                v128 = v117;
                break;
              case 34:
                v118 = atof(v103);
                v132 = v118;
                break;
              case 35:
                v105 = atoi(v103);
                break;
              default:
                break;
            }
            v103 = strtok(0, v142);
            ++v102;
          }
          while ( v103 );
          v2 = ";the end";
          v6 = &CVehicleAnimGroupData::m_vehicleAnimGroups[v122];
          v6->m_firstGroup = v121 + 88;
          v6->m_secondGroup = v120 + 88;
          v6->m_flags = v104;
          v6->m_specialFlags = v105;
          v6->m_criticalBlendTimes[0] = v127;
          v6->m_criticalBlendTimes[1] = v126;
          v6->m_criticalBlendTimes[2] = v125;
          v6->m_criticalBlendTimes[3] = v124;
          v6->m_criticalBlendTimes[4] = v123;
          v6->m_processDoorStartTimes[0] = v131;
          v6->m_processDoorStartTimes[1] = v130;
          v6->m_processDoorStartTimes[2] = v129;
          v6->m_processDoorStartTimes[3] = v128;
          v6->m_processDoorStopTimes[0] = v135;
          v6->m_processDoorStopTimes[1] = v134;
          v6->m_processDoorStopTimes[2] = v133;
          v6->m_processDoorStopTimes[3] = v132;
          v3 = v137;
          v4 = v138;
        }
        else
        {
LABEL_65:
          v33 = 0;
          strcpy(v141, " \t");
          v56 = strtok(v55, v141);
          v4 = v138;
          v34 = (unsigned __int8 *)v56;
          do
          {
            switch ( v33 )
            {
              case 0:
                v7 = cHandlingDataMgr::FindExactWord(this, v34, VehicleNames[0], 14, 210);
                v8 = (char *)this + 224 * v7;
                *((_DWORD *)v8 + 5) = v7;
                v3 = (tHandlingData *)(v8 + 20);
                break;
              case 1:
                v9 = atof((const char *)v34);
                v3->fMass = v9;
                break;
              case 2:
                v10 = atof((const char *)v34);
                v3->fTurnMass = v10;
                break;
              case 3:
                v11 = atof((const char *)v34);
                v3->fDragCoeff = v11;
                break;
              case 4:
                v12 = atof((const char *)v34);
                v3->CentreOfMass.x = v12;
                break;
              case 5:
                v13 = atof((const char *)v34);
                v3->CentreOfMass.y = v13;
                break;
              case 6:
                v14 = atof((const char *)v34);
                v3->CentreOfMass.z = v14;
                break;
              case 7:
                v3->nPercentSubmerged = atoi((const char *)v34);
                break;
              case 8:
                v15 = atof((const char *)v34);
                v3->fTractionMultiplier = v15;
                break;
              case 9:
                v16 = atof((const char *)v34);
                v3->fTractionLoss = v16;
                break;
              case 10:
                v17 = atof((const char *)v34);
                v3->fTractionBias = v17;
                break;
              case 11:
                v3->Transmission.m_nNumberOfGears = atoi((const char *)v34);
                break;
              case 12:
                v18 = atof((const char *)v34);
                v3->Transmission.m_fMaxVelocity = v18;
                break;
              case 13:
                v19 = atof((const char *)v34) * 0.4;
                v3->Transmission.m_fEngineAcceleration = v19;
                break;
              case 14:
                v20 = atof((const char *)v34);
                v3->Transmission.m_fEngineInertia = v20;
                break;
              case 15:
                v3->Transmission.m_nDriveType = *v34;
                break;
              case 16:
                v3->Transmission.m_nEngineType = *v34;
                break;
              case 17:
                v21 = atof((const char *)v34);
                v3->fBrakeDeceleration = v21;
                break;
              case 18:
                v22 = atof((const char *)v34);
                v3->fBrakeBias = v22;
                break;
              case 19:
                v3->bABS = atoi((const char *)v34) != 0;
                break;
              case 20:
                v23 = atof((const char *)v34);
                v3->fSteeringLock = v23;
                break;
              case 21:
                v24 = atof((const char *)v34);
                v3->fSuspensionForce = v24;
                break;
              case 22:
                v25 = atof((const char *)v34);
                v3->fSuspensionDamping = v25;
                break;
              case 23:
                v26 = atof((const char *)v34);
                v3->fSuspensionHighSpdComDamp = v26;
                break;
              case 24:
                v27 = atof((const char *)v34);
                v3->fSuspensionUpperLimit = v27;
                break;
              case 25:
                v28 = atof((const char *)v34);
                v3->fSuspensionLowerLimit = v28;
                break;
              case 26:
                v29 = atof((const char *)v34);
                v3->fSuspensionBias = v29;
                break;
              case 27:
                v30 = atof((const char *)v34);
                v3->fSuspensionAntiDive = v30;
                break;
              case 28:
                v31 = atof((const char *)v34);
                v3->fSeatOffsetDist = v31;
                break;
              case 29:
                v32 = atof((const char *)v34);
                v3->fCollisionDamageMultiplier = v32;
                break;
              case 30:
                v3->nMonetaryValue = atoi((const char *)v34);
                break;
              case 31:
                sscanf((const char *)v34, (const char *)&dword_473FA8, &v3->mFlags);
                break;
              case 32:
                sscanf((const char *)v34, (const char *)&dword_473FA8, &v3->hFlags);
                v3->Transmission.m_nFlags = v3->hFlags;
                break;
              case 33:
                v3->HeadLightType = atoi((const char *)v34);
                break;
              case 34:
                v3->RearLightType = atoi((const char *)v34);
                break;
              case 35:
                v3->AnimGroup = atoi((const char *)v34);
                break;
              default:
                break;
            }
            ++v33;
            v34 = (unsigned __int8 *)strtok(0, v141);
          }
          while ( v34 );
          cHandlingDataMgr::ConvertDataToGameUnits(this, v3);
          v2 = ";the end";
        }
        break;
    }
  }
  sub_19B258(v1);
}
// 473FA8: using guessed type int dword_473FA8;
// 61CADE: using guessed type char byte_61CADE;
// 6794AC: using guessed type char (*VehicleNames_ptr)[2940];

//----- (00473FB0) --------------------------------------------------------
void CPedStats::LoadPedStats()
{
  u_native v0; // r4
  unsigned __int8 *Line; // r0
  ePedStats v2; // r5
  CPedStats *v3; // r0
  int v4; // r2
  int v5; // r2
  int v6; // r1
  bool v7; // zf
  int v8; // [sp+28h] [bp-68h] BYREF
  float v9; // [sp+2Ch] [bp-64h] BYREF
  int v10; // [sp+30h] [bp-60h] BYREF
  float v11; // [sp+34h] [bp-5Ch] BYREF
  int v12; // [sp+38h] [bp-58h] BYREF
  int v13; // [sp+3Ch] [bp-54h] BYREF
  int v14; // [sp+40h] [bp-50h] BYREF
  int v15; // [sp+44h] [bp-4Ch] BYREF
  int v16; // [sp+48h] [bp-48h] BYREF
  int v17; // [sp+4Ch] [bp-44h] BYREF
  char v18[32]; // [sp+50h] [bp-40h] BYREF

  v0 = CFileMgr::OpenFile("DATA\\PEDSTATS.DAT", "r");
  Line = CFileLoader::LoadLine(v0);
  if ( Line )
  {
    v2 = PEDSTAT_PLAYER;
    do
    {
      v6 = *Line;
      v7 = v6 == 35;
      if ( v6 != 35 )
        v7 = v6 == 0;
      if ( !v7 )
      {
        sscanf(
          (const char *)Line,
          "%s %f %f %d %d %d %d %f %f %d %d",
          v18,
          &v11,
          &v10,
          &v17,
          &v16,
          &v15,
          &v14,
          &v9,
          &v8,
          &v13,
          &v12);
        CPedStats::ms_apPedStats[v2].m_ePedStatType = v2;
        strcpy((char *)CPedStats::ms_apPedStats[v2].m_sPedStatName, v18);
        v3 = &CPedStats::ms_apPedStats[v2];
        v4 = v10;
        ++v2;
        v3->m_fFleeDistance = v11;
        LODWORD(v3->m_fMaxHeadingChange) = v4;
        v3->m_nFear = v17;
        v3->m_nTemper = v16;
        v3->m_nLawfulness = v15;
        v3->m_nSexiness = v14;
        v5 = v8;
        v3->m_fAttackMult = v9;
        LODWORD(v3->m_fDefendMult) = v5;
        v3->m_nStatFlags = v13;
        v3->m_iDefaultDecisionMaker = v12;
      }
      Line = CFileLoader::LoadLine(v0);
    }
    while ( Line );
  }
  CFileMgr::CloseFile(v0);
}
// 473FB0: using guessed type char var_40[32];

//----- (004740F4) --------------------------------------------------------
void CDecisionMakerTypesFileLoader::LoadDefaultDecisionMaker()
{
  CDecisionMakerTypes *v0; // r0
  CDecisionMakerTypes *v1; // r0
  CDecisionMaker *p_decisionMaker; // r4
  int v3; // r5
  CDecisionMakerTypes *v4; // r0
  CDecisionMakerTypes *v5; // r0
  CDecisionMaker *p_m_defaultRandomPedDecisionMaker; // r5
  int v7; // r6
  int v8; // r4
  CDecisionMaker *v9; // r4
  int v10; // r5
  CDecisionMakerTypes *v11; // r0
  CDecisionMakerTypes *v12; // r0
  CDecisionMaker *p_m_defaultMissionPedDecisionMaker; // r5
  int v14; // r6
  int v15; // r4
  CDecisionMaker *v16; // r4
  int v17; // r5
  CDecisionMakerTypes *v18; // r0
  CDecisionMakerTypes *v19; // r0
  CDecisionMaker *p_m_defaultPlayerPedDecisionMaker; // r5
  int v21; // r6
  int v22; // r4
  CDecisionMaker *v23; // r4
  int v24; // r5
  CDecisionMakerTypes *v25; // r0
  CDecisionMakerTypes *v26; // r0
  CDecisionMaker *p_m_defaultRandomPedGroupDecisionMaker; // r5
  int v28; // r6
  int v29; // r4
  CDecisionMaker *v30; // r4
  int v31; // r5
  CDecisionMakerTypes *v32; // r0
  CDecisionMakerTypes *v33; // r0
  CDecision *m_decisions; // r4
  CDecisionMaker *v35; // r5
  int v36; // r6
  CDecisionMaker decisionMaker; // [sp+4h] [bp-9ACh] BYREF

  v0 = CDecisionMakerTypes::m_pPedDecisionTypes;
  if ( !CDecisionMakerTypes::m_pPedDecisionTypes )
  {
    v1 = (CDecisionMakerTypes *)operator new(0xF1C0u);
    CDecisionMakerTypes::CDecisionMakerTypes(v1);
    CDecisionMakerTypes::m_pPedDecisionTypes = v0;
  }
  CDecisionMakerTypes::LoadEventIndices(v0);
  CDecisionMakerTypesFileLoader::UnloadDecisionMaker(0);
  CDecisionMakerTypesFileLoader::UnloadDecisionMaker(1);
  CDecisionMakerTypesFileLoader::UnloadDecisionMaker(2);
  CDecisionMakerTypesFileLoader::UnloadDecisionMaker(3);
  CDecisionMakerTypesFileLoader::UnloadDecisionMaker(4);
  CDecisionMakerTypesFileLoader::UnloadDecisionMaker(5);
  CDecisionMakerTypesFileLoader::UnloadDecisionMaker(6);
  CDecisionMakerTypesFileLoader::UnloadDecisionMaker(7);
  CDecisionMakerTypesFileLoader::UnloadDecisionMaker(8);
  CDecisionMakerTypesFileLoader::UnloadDecisionMaker(9);
  CDecisionMakerTypesFileLoader::UnloadDecisionMaker(10);
  CDecisionMakerTypesFileLoader::UnloadDecisionMaker(11);
  CDecisionMakerTypesFileLoader::UnloadDecisionMaker(12);
  CDecisionMakerTypesFileLoader::UnloadDecisionMaker(13);
  CDecisionMakerTypesFileLoader::UnloadDecisionMaker(14);
  CDecisionMakerTypesFileLoader::UnloadDecisionMaker(15);
  CDecisionMakerTypesFileLoader::UnloadDecisionMaker(16);
  CDecisionMakerTypesFileLoader::UnloadDecisionMaker(17);
  CDecisionMakerTypesFileLoader::UnloadDecisionMaker(18);
  CDecisionMakerTypesFileLoader::UnloadDecisionMaker(19);
  p_decisionMaker = &decisionMaker;
  CDecisionMaker::CDecisionMaker(&decisionMaker);
  v3 = 41;
  do
  {
    CDecision::SetDefault(p_decisionMaker->m_decisions);
    p_decisionMaker = (CDecisionMaker *)((char *)p_decisionMaker + 60);
    --v3;
  }
  while ( v3 );
  CDecisionMakerTypesFileLoader::LoadDecisionMaker("RANDOM.ped", &decisionMaker);
  v4 = CDecisionMakerTypes::m_pPedDecisionTypes;
  if ( !CDecisionMakerTypes::m_pPedDecisionTypes )
  {
    v5 = (CDecisionMakerTypes *)operator new(0xF1C0u);
    CDecisionMakerTypes::CDecisionMakerTypes(v5);
    CDecisionMakerTypes::m_pPedDecisionTypes = v4;
  }
  p_m_defaultRandomPedDecisionMaker = &v4->m_defaultRandomPedDecisionMaker;
  v7 = 41;
  v8 = 0;
  do
  {
    CDecision::From(&p_m_defaultRandomPedDecisionMaker->m_decisions[v8], &decisionMaker.m_decisions[v8]);
    ++v8;
    --v7;
  }
  while ( v7 );
  v9 = &decisionMaker;
  v10 = 41;
  do
  {
    CDecision::SetDefault(v9->m_decisions);
    v9 = (CDecisionMaker *)((char *)v9 + 60);
    --v10;
  }
  while ( v10 );
  CDecisionMakerTypesFileLoader::LoadDecisionMaker("m_norm.ped", &decisionMaker);
  v11 = CDecisionMakerTypes::m_pPedDecisionTypes;
  if ( !CDecisionMakerTypes::m_pPedDecisionTypes )
  {
    v12 = (CDecisionMakerTypes *)operator new(0xF1C0u);
    CDecisionMakerTypes::CDecisionMakerTypes(v12);
    CDecisionMakerTypes::m_pPedDecisionTypes = v11;
  }
  p_m_defaultMissionPedDecisionMaker = &v11->m_defaultMissionPedDecisionMaker;
  v14 = 41;
  v15 = 0;
  do
  {
    CDecision::From(&p_m_defaultMissionPedDecisionMaker->m_decisions[v15], &decisionMaker.m_decisions[v15]);
    ++v15;
    --v14;
  }
  while ( v14 );
  v16 = &decisionMaker;
  v17 = 41;
  do
  {
    CDecision::SetDefault(v16->m_decisions);
    v16 = (CDecisionMaker *)((char *)v16 + 60);
    --v17;
  }
  while ( v17 );
  CDecisionMakerTypesFileLoader::LoadDecisionMaker("m_plyr.ped", &decisionMaker);
  v18 = CDecisionMakerTypes::m_pPedDecisionTypes;
  if ( !CDecisionMakerTypes::m_pPedDecisionTypes )
  {
    v19 = (CDecisionMakerTypes *)operator new(0xF1C0u);
    CDecisionMakerTypes::CDecisionMakerTypes(v19);
    CDecisionMakerTypes::m_pPedDecisionTypes = v18;
  }
  p_m_defaultPlayerPedDecisionMaker = &v18->m_defaultPlayerPedDecisionMaker;
  v21 = 41;
  v22 = 0;
  do
  {
    CDecision::From(&p_m_defaultPlayerPedDecisionMaker->m_decisions[v22], &decisionMaker.m_decisions[v22]);
    ++v22;
    --v21;
  }
  while ( v21 );
  v23 = &decisionMaker;
  v24 = 41;
  do
  {
    CDecision::SetDefault(v23->m_decisions);
    v23 = (CDecisionMaker *)((char *)v23 + 60);
    --v24;
  }
  while ( v24 );
  CDecisionMakerTypesFileLoader::LoadDecisionMaker("RANDOM.grp", &decisionMaker);
  v25 = CDecisionMakerTypes::m_pPedDecisionTypes;
  if ( !CDecisionMakerTypes::m_pPedDecisionTypes )
  {
    v26 = (CDecisionMakerTypes *)operator new(0xF1C0u);
    CDecisionMakerTypes::CDecisionMakerTypes(v26);
    CDecisionMakerTypes::m_pPedDecisionTypes = v25;
  }
  p_m_defaultRandomPedGroupDecisionMaker = &v25->m_defaultRandomPedGroupDecisionMaker;
  v28 = 41;
  v29 = 0;
  do
  {
    CDecision::From(&p_m_defaultRandomPedGroupDecisionMaker->m_decisions[v29], &decisionMaker.m_decisions[v29]);
    ++v29;
    --v28;
  }
  while ( v28 );
  v30 = &decisionMaker;
  v31 = 41;
  do
  {
    CDecision::SetDefault(v30->m_decisions);
    v30 = (CDecisionMaker *)((char *)v30 + 60);
    --v31;
  }
  while ( v31 );
  CDecisionMakerTypesFileLoader::LoadDecisionMaker("MISSION.grp", &decisionMaker);
  v32 = CDecisionMakerTypes::m_pPedDecisionTypes;
  if ( !CDecisionMakerTypes::m_pPedDecisionTypes )
  {
    v33 = (CDecisionMakerTypes *)operator new(0xF1C0u);
    CDecisionMakerTypes::CDecisionMakerTypes(v33);
    CDecisionMakerTypes::m_pPedDecisionTypes = v32;
  }
  m_decisions = v32->m_defaultMissionPedGroupDecisionMaker.m_decisions;
  v35 = &decisionMaker;
  v36 = 41;
  do
  {
    CDecision::From(m_decisions, v35->m_decisions);
    v35 = (CDecisionMaker *)((char *)v35 + 60);
    ++m_decisions;
    --v36;
  }
  while ( v36 );
  CDecisionMakerTypesFileLoader::LoadDecisionMaker("GangMbr.ped", 0, 0, -1);
  CDecisionMakerTypesFileLoader::LoadDecisionMaker("Cop.ped", 0, 0, -1);
  CDecisionMakerTypesFileLoader::LoadDecisionMaker("R_Norm.ped", 0, 0, -1);
  CDecisionMakerTypesFileLoader::LoadDecisionMaker("R_Tough.ped", 0, 0, -1);
  CDecisionMakerTypesFileLoader::LoadDecisionMaker("R_Weak.ped", 0, 0, -1);
  CDecisionMakerTypesFileLoader::LoadDecisionMaker("Fireman.ped", 0, 0, -1);
  CDecisionMakerTypesFileLoader::LoadDecisionMaker("m_empty.ped", 0, 0, -1);
  CDecisionMakerTypesFileLoader::LoadDecisionMaker("Indoors.ped", 0, 0, -1);
  CDecisionMakerTypesFileLoader::LoadDecisionMaker("RANDOM.grp", 1u, 0, -1);
  CDecisionMakerTypesFileLoader::LoadDecisionMaker("RANDOM2.grp", 1u, 0, -1);
}
// 47411C: variable 'v0' is possibly undefined
// 4741D8: variable 'v4' is possibly undefined
// 47422C: variable 'v11' is possibly undefined
// 474280: variable 'v18' is possibly undefined
// 4742D4: variable 'v25' is possibly undefined
// 474324: variable 'v32' is possibly undefined

//----- (004744AC) --------------------------------------------------------
void __fastcall CDecisionMakerTypes::LoadEventIndices(
        CDecisionMakerTypes *this,
        int *pMap,
        const unsigned __int8 *pName)
{
  u_native v5; // r5
  int v6; // r4
  bool v7; // zf
  _BOOL4 Line; // r0
  int v9; // [sp+4h] [bp-224h] BYREF
  char v10; // [sp+8h] [bp-220h] BYREF
  unsigned __int8 pLine[256]; // [sp+108h] [bp-120h] BYREF

  memset(pMap, 0, 0x180u);
  CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
  CFileMgr::SetDir("data\\decision\\");
  v5 = CFileMgr::OpenFile(pName, "r");
  CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
  if ( CFileMgr::ReadLine(v5, pLine, 256) )
  {
    v6 = 0;
    do
    {
      while ( 1 )
      {
        v7 = pLine[0] == 10;
        if ( pLine[0] != 10 )
          v7 = pLine[0] == 0;
        if ( !v7 )
          break;
        if ( !CFileMgr::ReadLine(v5, pLine, 256) )
          goto LABEL_10;
      }
      sscanf((const char *)pLine, "%s %d", &v10, &v9);
      pMap[v9] = v6;
      Line = CFileMgr::ReadLine(v5, pLine, 256);
      ++v6;
    }
    while ( Line );
  }
LABEL_10:
  CFileMgr::CloseFile(v5);
}
// 61CADE: using guessed type char byte_61CADE;

//----- (0047459C) --------------------------------------------------------
void CAnimManager::ReadAnimAssociationDefinitions()
{
  u_native v0; // r4
  unsigned __int8 *Line; // r0
  int v2; // r10
  CAnimManager::AnimAssocDefinition *v3; // r5
  int v4; // r1
  bool v5; // zf
  uint32 v6; // [sp+Ch] [bp-84h] BYREF
  char v7; // [sp+10h] [bp-80h] BYREF
  unsigned __int8 v8[32]; // [sp+30h] [bp-60h] BYREF
  unsigned __int8 v9[32]; // [sp+50h] [bp-40h] BYREF

  CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
  v0 = CFileMgr::OpenFile("DATA\\ANIMGRP.DAT", "rb");
  Line = CFileLoader::LoadLine(v0);
  if ( Line )
  {
    v2 = 0;
    v3 = 0;
    do
    {
      while ( 1 )
      {
        v4 = *Line;
        v5 = v4 == 35;
        if ( v4 != 35 )
          v5 = v4 == 0;
        if ( v5 )
          goto LABEL_7;
        if ( v2 << 31 )
          break;
        sscanf((const char *)Line, "%s %s %s %d", v9, v8, &v7, &v6);
        v3 = CAnimManager::AddAnimAssocDefinition(v9, v8, 7u, v6, aStdAnimDescs);
        Line = CFileLoader::LoadLine(v0);
        v2 = 1;
        if ( !Line )
          goto LABEL_16;
      }
      if ( sscanf((const char *)Line, (const char *)&dword_4746AC, v9) == 1 )
      {
        if ( !strcmp((const char *)v9, (const char *)&off_4746B0) )
        {
          v2 = 0;
          goto LABEL_7;
        }
        CAnimManager::AddAnimToAssocDefinition(v3, v9);
      }
      v2 = 1;
LABEL_7:
      Line = CFileLoader::LoadLine(v0);
    }
    while ( Line );
  }
LABEL_16:
  CFileMgr::CloseFile(v0);
}
// 4746AC: using guessed type int dword_4746AC;
// 4746B0: using guessed type void *off_4746B0;
// 61CADE: using guessed type char byte_61CADE;
// 47459C: using guessed type unsigned __int8 var_60[32];

//----- (004746B8) --------------------------------------------------------
void CWeaponInfo::Initialise()
{
  int v0; // r4
  CWeaponInfo *v1; // r5
  AssocGroupId *p_m_animGroup; // r6
  _QWORD *p_m_anim2LoopEnd; // r6

  v0 = 0;
  do
  {
    v1 = &aWeaponInfo[v0];
    aWeaponInfo[v0].m_eFireType = FIRETYPE_MELEE;
    p_m_animGroup = &aWeaponInfo[v0].m_animGroup;
    v1->m_fTargetRange = 0.0;
    v1->m_fWeaponRange = 0.0;
    ++v0;
    v1->m_modelId = -1;
    v1->m_modelId2 = -1;
    v1->m_nWeaponSlot = -1;
    v1->m_nFlags = 0;
    v1->m_vecFireOffset.z = 0.0;
    v1->m_SkillLevel = WEAPONSKILL_STD;
    v1->m_nReqStatLevel = 0;
    v1->m_fAccuracy = 1.0;
    v1->m_fMoveSpeed = 1.0;
    *(_WORD *)&v1->m_defaultCombo = 260;
    *(_QWORD *)p_m_animGroup = 0LL;
    *((_QWORD *)p_m_animGroup + 1) = 0LL;
    *(_QWORD *)((char *)&v1->m_fSpeed + 2) = 0LL;
    *(_QWORD *)((char *)&v1->m_fLifeSpan + 2) = 0LL;
    p_m_anim2LoopEnd = (_QWORD *)&v1->m_anim2LoopEnd;
    v1 = (CWeaponInfo *)((char *)v1 + 64);
    *p_m_anim2LoopEnd = 0LL;
    p_m_anim2LoopEnd[1] = 0LL;
    *(_QWORD *)&v1->m_eFireType = 0LL;
    *(_QWORD *)&v1->m_fWeaponRange = 0LL;
  }
  while ( v0 != 80 );
  memset(CWeaponInfo::ms_aWeaponAimOffsets, 0, sizeof(CWeaponInfo::ms_aWeaponAimOffsets));
  CWeaponInfo::LoadWeaponData();
}

//----- (00474750) --------------------------------------------------------
void CWeaponInfo::LoadWeaponData()
{
  eWeaponType v0; // r8
  u_native v1; // r4
  unsigned __int8 *Line; // r0
  float32x4_t v3; // q4
  int v4; // r1
  bool v5; // zf
  int v6; // r1
  AssocGroupId v7; // r8
  const unsigned __int8 *AnimGroupName; // r0
  tAnimAimOffsets *v9; // r1
  eWeaponType WeaponType; // r6
  eFireType WeaponFireType; // r0
  eWeaponType v12; // r8
  uint32 v13; // r11
  int v14; // r12
  eWeaponType v15; // r1
  CWeaponInfo *v16; // r6
  int v17; // r1
  unsigned __int64 v18; // r2
  int v19; // r0
  int v20; // r0
  int v21; // r1
  AssocGroupId v22; // r6
  const unsigned __int8 *v23; // r0
  eWeaponType v24; // r0
  int v25; // r6
  eFireType v26; // r0
  int v27; // r11
  double v28; // d16
  int v29; // r1
  CWeaponInfo *v30; // r8
  int v31; // r0
  int v32; // s0
  int32x4_t v33; // q8
  int v34; // r0
  int v35; // r1
  int v36; // r2
  int v37; // r3
  int v38; // r0
  float *p_m_anim2LoopStart; // r1
  float *p_m_animLoopEnd; // r8
  AssocGroupId v41; // r6
  const unsigned __int8 *v42; // r0
  uint32 v43; // r2
  AssocGroupId m_animGroup; // r0
  float v45; // s28
  float v46; // r0
  int v47; // r6
  float v48; // s28
  float v49; // s0
  int v50; // r0
  float *v51; // [sp+70h] [bp-1B0h]
  float *p_m_animLoopStart; // [sp+74h] [bp-1ACh]
  float *p_m_anim2LoopEnd; // [sp+78h] [bp-1A8h]
  uint32 v54; // [sp+7Ch] [bp-1A4h]
  eWeaponType v55; // [sp+BCh] [bp-164h]
  eWeaponType v56; // [sp+BCh] [bp-164h]
  int v57; // [sp+C0h] [bp-160h] BYREF
  int v58; // [sp+C4h] [bp-15Ch] BYREF
  int v59; // [sp+C8h] [bp-158h] BYREF
  float v60; // [sp+CCh] [bp-154h] BYREF
  int32 v61; // [sp+D0h] [bp-150h] BYREF
  int v62; // [sp+D4h] [bp-14Ch] BYREF
  int v63; // [sp+D8h] [bp-148h] BYREF
  int v64; // [sp+DCh] [bp-144h] BYREF
  unsigned int v65; // [sp+E0h] [bp-140h] BYREF
  unsigned int v66; // [sp+E4h] [bp-13Ch] BYREF
  unsigned int v67; // [sp+E8h] [bp-138h] BYREF
  unsigned int v68; // [sp+ECh] [bp-134h] BYREF
  float v69; // [sp+F0h] [bp-130h] BYREF
  float v70; // [sp+F4h] [bp-12Ch] BYREF
  int v71; // [sp+F8h] [bp-128h] BYREF
  int v72; // [sp+FCh] [bp-124h] BYREF
  double v73; // [sp+100h] [bp-120h] BYREF
  float v74; // [sp+108h] [bp-118h] BYREF
  int v75; // [sp+10Ch] [bp-114h] BYREF
  int v76; // [sp+110h] [bp-110h] BYREF
  int v77; // [sp+114h] [bp-10Ch] BYREF
  int v78; // [sp+118h] [bp-108h] BYREF
  int v79; // [sp+11Ch] [bp-104h] BYREF
  int v80; // [sp+120h] [bp-100h] BYREF
  int v81; // [sp+124h] [bp-FCh] BYREF
  int v82; // [sp+128h] [bp-F8h] BYREF
  unsigned int v83; // [sp+12Ch] [bp-F4h] BYREF
  int v84; // [sp+130h] [bp-F0h] BYREF
  float v85; // [sp+134h] [bp-ECh] BYREF
  float v86; // [sp+138h] [bp-E8h] BYREF
  char v87[32]; // [sp+13Ch] [bp-E4h] BYREF
  unsigned __int8 pComboName[32]; // [sp+15Ch] [bp-C4h] BYREF
  unsigned __int8 pString[32]; // [sp+17Ch] [bp-A4h] BYREF
  unsigned __int8 v90[32]; // [sp+19Ch] [bp-84h] BYREF
  char v91; // [sp+1BCh] [bp-64h] BYREF

  v1 = CFileMgr::OpenFile("DATA\\WEAPON.DAT", "rb");
  Line = CFileLoader::LoadLine(v1);
  if ( !Line )
    goto LABEL_53;
  v3.n128_u64[0] = loc_474CF0;
  v3.n128_u64[1] = loc_474CF8;
  do
  {
    v55 = v0;
    while ( 1 )
    {
      v4 = *Line;
      v5 = v4 == 35;
      if ( v4 != 35 )
        v5 = v4 == 0;
      if ( v5 )
        goto LABEL_8;
      v90[0] = 0;
      pString[0] = 0;
      pComboName[0] = 0;
      v87[0] = 0;
      v6 = *Line;
      if ( v6 == 37 )
      {
        sscanf(
          (const char *)Line,
          "%s %s %f %f %f %f %d %d %d %d",
          &v91,
          v87,
          &v73,
          &v74,
          &v86,
          &v85,
          &v82,
          &v81,
          &v80,
          &v79);
        v7 = ANIM_STD_PED;
        if ( CAnimManager::ms_numAnimAssocDefinitions >= 1 )
        {
          do
          {
            AnimGroupName = CAnimManager::GetAnimGroupName(v7);
            if ( !strcmp(v87, (const char *)AnimGroupName) )
              break;
            ++v7;
          }
          while ( v7 < CAnimManager::ms_numAnimAssocDefinitions );
        }
        v9 = &CWeaponInfo::ms_aWeaponAimOffsets[v7];
        v0 = v55;
        v9[-11].fAimFromX = *(float *)&v73;
        v9[-11].fAimFromZ = v74;
        v9[-11].fDuckAimX = v86;
        v9[-11].fDuckAimZ = v85;
        v9[-11].nReloadSampleA = v82;
        v9[-11].nReloadSampleB = v81;
        v9[-11].nReloadSampleCrouchedA = v80;
        v9[-11].nReloadSampleCrouchedB = v79;
        goto LABEL_8;
      }
      if ( v6 == 36 )
        break;
      if ( v6 == 163 )
      {
        sscanf(
          (const char *)Line,
          "%s %s %s %f %f %d %d %d %s %d %x %s",
          &v91,
          v90,
          pString,
          &v86,
          &v85,
          &v84,
          &v83,
          &v78,
          pComboName,
          &v77,
          &v61,
          v87);
        WeaponType = CWeaponInfo::FindWeaponType(v90);
        WeaponFireType = CWeaponInfo::FindWeaponFireType(pString);
        v12 = WeaponType;
        v13 = WeaponType;
        v14 = LODWORD(v86);
        v15 = WeaponType;
        v16 = &aWeaponInfo[WeaponType];
        aWeaponInfo[v15].m_eFireType = WeaponFireType;
        v17 = LODWORD(v85);
        v18 = __PAIR64__(v83, v84);
        v19 = v78;
        LODWORD(v16->m_fTargetRange) = v14;
        LODWORD(v16->m_fWeaponRange) = v17;
        *(_QWORD *)&v16->m_modelId = v18;
        v16->m_nWeaponSlot = v19;
        v16->m_nCombosAvailable = v77;
        v16->m_defaultCombo = CTaskSimpleFight::GetComboType(pComboName);
        v16->m_nFlags = v61;
        v20 = strncmp(v87, "null", 4u);
        v21 = 1;
        if ( v20 && CAnimManager::ms_numAnimAssocDefinitions >= 1 )
        {
          v22 = ANIM_STD_PED;
          while ( 1 )
          {
            v23 = CAnimManager::GetAnimGroupName(v22);
            if ( !strcmp(v87, (const char *)v23) )
              break;
            if ( ++v22 >= CAnimManager::ms_numAnimAssocDefinitions )
            {
              v21 = 1;
              goto LABEL_40;
            }
          }
          v21 = 1;
          aWeaponInfo[v12].m_animGroup = v22;
        }
LABEL_40:
        v0 = v55;
        v43 = v13;
        goto LABEL_49;
      }
      sscanf((const char *)Line, (const char *)&dword_474D9C, v90);
      if ( !strncmp((const char *)v90, "ENDWEAPONDATA", 0xDu) )
        goto LABEL_53;
LABEL_8:
      Line = CFileLoader::LoadLine(v1);
      if ( !Line )
        goto LABEL_53;
    }
    v57 = 0;
    v58 = 0;
    v59 = 0;
    v60 = 0.0;
    sscanf(
      (const char *)Line,
      "%s %s %s %f %f %d %d %d %s %d %d %f %f %f %d %d %f %f %d %d %d %d %d %d %d %x %f %f %f %f",
      &v91,
      v90,
      pString,
      &v86,
      &v85,
      &v84,
      &v83,
      &v78,
      v87,
      &v76,
      &v75,
      &v73,
      (char *)&v73 + 4,
      &v74,
      &v72,
      &v71,
      &v70,
      &v69,
      &v68,
      &v67,
      &v66,
      &v65,
      &v64,
      &v63,
      &v62,
      &v61,
      &v60,
      &v59,
      &v58,
      &v57);
    v24 = CWeaponInfo::FindWeaponType(v90);
    v54 = v24;
    if ( (unsigned int)(v24 - 22) > 0xA )
    {
      v25 = 1;
      v72 = 1;
LABEL_32:
      v0 = v24;
    }
    else
    {
      v25 = v72;
      switch ( v72 )
      {
        case 0:
          v0 = v24 + 25;
          v25 = 0;
          break;
        case 1:
          v25 = 1;
          goto LABEL_32;
        case 2:
          v0 = v24 + 36;
          v25 = 2;
          break;
        case 3:
          v0 = v24 + 47;
          v25 = 3;
          break;
        default:
          break;
      }
    }
    v26 = CWeaponInfo::FindWeaponFireType(pString);
    v27 = (__int16)v0;
    v56 = v0;
    v28 = v73;
    v29 = (__int16)v0;
    v30 = &aWeaponInfo[v29];
    aWeaponInfo[v29].m_eFireType = v26;
    v30->m_fTargetRange = v86;
    v30->m_fWeaponRange = v85;
    v30->m_modelId = v84;
    v30->m_modelId2 = v83;
    v30->m_nWeaponSlot = v78;
    v30->m_nAmmo = v76;
    v30->m_nDamage = v75;
    v30->m_vecFireOffset.z = v74;
    v30->m_SkillLevel = v25;
    v31 = v71;
    *(double *)&v30->m_vecFireOffset.x = v28;
    v30->m_nReqStatLevel = v31;
    v30->m_fAccuracy = v70;
    v30->m_fMoveSpeed = v69;
    v32 = v64;
    v33.n128_u64[1] = __PAIR64__(v65, v66);
    v33.n128_u64[0] = __PAIR64__(v67, v68);
    p_m_animLoopStart = &aWeaponInfo[v29].m_animLoopStart;
    *(float32x4_t *)&v30->m_animLoopStart = vmulq_f32(vcvtq_f32_s32(v33), v3);
    v30->m_anim2LoopEnd = (float)v32 * 0.033333;
    v30->m_anim2FireTime = (float)v63 * 0.033333;
    v34 = v61;
    v30->m_animBreakoutTime = (float)v62 * 0.033333;
    v30->m_nFlags = v34;
    v35 = v59;
    v37 = v57;
    v36 = v58;
    v30->m_fSpeed = v60;
    LODWORD(v30->m_fRadius) = v35;
    LODWORD(v30->m_fLifeSpan) = v36;
    LODWORD(v30->m_fSpread) = v37;
    v38 = strncmp(v87, "null", 4u);
    p_m_anim2LoopEnd = &v30->m_anim2LoopEnd;
    p_m_anim2LoopStart = &v30->m_anim2LoopStart;
    p_m_animLoopEnd = &v30->m_animLoopEnd;
    v51 = p_m_anim2LoopStart;
    if ( v38 && CAnimManager::ms_numAnimAssocDefinitions >= 1 )
    {
      v41 = ANIM_STD_PED;
      while ( 1 )
      {
        v42 = CAnimManager::GetAnimGroupName(v41);
        if ( !strcmp(v87, (const char *)v42) )
          break;
        if ( ++v41 >= CAnimManager::ms_numAnimAssocDefinitions )
          goto LABEL_42;
      }
      aWeaponInfo[v27].m_animGroup = v41;
    }
LABEL_42:
    m_animGroup = aWeaponInfo[v27].m_animGroup;
    if ( (unsigned int)(m_animGroup - 11) <= 0x14 )
      aWeaponInfo[v27].m_nAimOffsetIndex = m_animGroup - 11;
    v45 = *p_m_animLoopStart;
    v46 = floorf((float)((float)(*p_m_animLoopEnd - *p_m_animLoopStart) / 0.02) + 0.1);
    v47 = v72;
    *p_m_animLoopEnd = v45 + (float)((float)(v46 * 0.02) + -0.006);
    v48 = *v51;
    v49 = floorf((float)((float)(*p_m_anim2LoopEnd - *v51) / 0.02) + 0.1);
    v43 = v54;
    v50 = 0;
    *p_m_anim2LoopEnd = v48 + (float)((float)(v49 * 0.02) + -0.006);
    if ( v54 != 40 )
      v50 = 1;
    if ( v47 != 1 )
      v47 = 0;
    v0 = v56;
    v21 = v50 & v47;
LABEL_49:
    if ( v21 == 1 && v84 >= 1 )
      CModelInfo::ms_modelInfoPtrs[v84][1].m_hashKey = v43;
    Line = CFileLoader::LoadLine(v1);
  }
  while ( Line );
LABEL_53:
  CFileMgr::CloseFile(v1);
}
// 47483C: variable 'v0' is possibly undefined
// 474D9C: using guessed type int dword_474D9C;
// 474750: using guessed type unsigned __int8 pComboName[32];

//----- (00474DB8) --------------------------------------------------------
eFireType __fastcall CWeaponInfo::FindWeaponFireType(const unsigned __int8 *pString)
{
  int v2; // r1
  eFireType result; // r0

  if ( !strcmp((const char *)pString, "MELEE") )
    return 0;
  if ( !strcmp((const char *)pString, "INSTANT_HIT") )
    return 1;
  if ( !strcmp((const char *)pString, "PROJECTILE") )
    return 2;
  if ( !strcmp((const char *)pString, "AREA_EFFECT") )
    return 3;
  if ( !strcmp((const char *)pString, "CAMERA") )
    return 4;
  v2 = strcmp((const char *)pString, "USE");
  result = FIRETYPE_INSTANT_HIT;
  if ( !v2 )
    return 5;
  return result;
}

//----- (00474E50) --------------------------------------------------------
void CPopulation::LoadPedGroups()
{
  int16x8_t v0; // q4
  int v1; // r0
  unsigned __int8 *i; // r1
  int v3; // r0
  bool v4; // zf
  int v5; // r0
  int v6; // r5
  int v7; // r9
  int v8; // r1
  _BYTE *v9; // r10
  int v10; // r3
  int v11; // r2
  int v12; // r11
  int v13; // r1
  unsigned __int8 *v14; // r3
  unsigned int v15; // r5
  bool v16; // cf
  unsigned int v17; // r3
  int v18; // r1
  int v19; // r0
  unsigned int v20; // r12
  int16x8_t *v21; // r3
  unsigned int v22; // r2
  UInt16 (*v24)[21]; // [sp+8h] [bp-548h]
  u_native id; // [sp+Ch] [bp-544h]
  int v26; // [sp+14h] [bp-53Ch]
  int32 pIndex; // [sp+18h] [bp-538h] BYREF
  char v28; // [sp+1Ch] [bp-534h] BYREF
  _BYTE v29[3]; // [sp+1Dh] [bp-533h] BYREF
  unsigned __int8 pLine[1024]; // [sp+11Ch] [bp-434h] BYREF

  CFileMgr::ChangeDir("\\DATA\\");
  id = CFileMgr::OpenFile("PEDGRP.DAT", "r");
  CFileMgr::ChangeDir("\\");
  v24 = CPopulation::m_PedGroups;
  v0 = vdupq_n_s16(0x7D0u);
  v1 = 0;
LABEL_3:
  v26 = v1;
  while ( CFileMgr::ReadLine(id, pLine, 1024) )
  {
    for ( i = pLine; ; ++i )
    {
      v3 = *i;
      v4 = v3 == 13;
      if ( v3 != 13 )
        v4 = v3 == 44;
      if ( !v4 )
        break;
      *i = 32;
LABEL_6:
      ;
    }
    if ( v3 != 10 )
      goto LABEL_6;
    v5 = 0;
    v6 = 0;
    *i = 0;
    v7 = 0;
    v8 = 0;
    while ( 1 )
    {
      v9 = &v29[-v6];
      v10 = v6 + 1;
      v11 = v6 - 1;
      v12 = v8;
      do
      {
        v13 = v10;
        v14 = &pLine[v11];
        --v9;
        ++v11;
        v15 = v14[1];
        v10 = v13 + 1;
      }
      while ( (unsigned __int8)(v15 - 1) < 0x20u );
      if ( v15 == 35 )
        break;
      v16 = v15 >= 0x21;
      v6 = v11;
      if ( v16 )
      {
        do
          v17 = pLine[v13++];
        while ( v17 > 0x20 );
        v6 = v13 - 1;
      }
      if ( v6 == v11 )
        break;
      strncpy(&v28, (const char *)&pLine[v11], v6 - v11);
      v9[v6] = 0;
      if ( CModelInfo::GetModelInfo((const unsigned __int8 *)&v28, &pIndex) )
        CPopulation::m_PedGroups[v26][v7++] = pIndex;
      v8 = v12 + 1;
      v5 = 1;
      if ( v12 >= 20 )
        goto LABEL_26;
    }
    if ( v5 << 31 )
    {
LABEL_26:
      CPopulation::m_nNumPedsInGroup[v26] = v7;
      if ( v7 <= 20 )
      {
        v18 = 21 - v7;
        if ( (unsigned int)(21 - v7) < 8 )
        {
          v19 = v7;
          goto LABEL_35;
        }
        v20 = v18 & 0xFFFFFFF8;
        if ( (v18 & 0xFFFFFFF8) == 0 )
        {
          v19 = v7;
          goto LABEL_35;
        }
        v19 = v7 + v20;
        v21 = (int16x8_t *)&(*v24)[v7];
        v22 = v18 & 0xFFFFFFF8;
        do
        {
          *v21++ = v0;
          v22 -= 8;
        }
        while ( v22 );
        if ( v18 != v20 )
        {
          do
LABEL_35:
            (*v24)[v19] = 2000;
          while ( v19++ < 20 );
        }
      }
      ++v24;
      v1 = v26 + 1;
      goto LABEL_3;
    }
  }
  CFileMgr::CloseFile(id);
}
// 474E50: using guessed type unsigned __int8 pLine[1024];

//----- (00475018) --------------------------------------------------------
void CPopulation::LoadCarGroups()
{
  int16x8_t v0; // q4
  UInt16 (*v1)[23]; // r8
  int v2; // r0
  unsigned __int8 *i; // r0
  int v4; // r1
  bool v5; // zf
  int v6; // r5
  int v7; // r9
  int v8; // r0
  int v9; // r8
  int v10; // r2
  _BYTE *v11; // r11
  int v12; // r0
  int v13; // r1
  unsigned __int8 *v14; // r2
  unsigned int v15; // r3
  unsigned int v16; // r2
  int v17; // r1
  int v18; // r0
  unsigned int v19; // r12
  int16x8_t *v20; // r3
  unsigned int v21; // r2
  UInt16 (*v23)[23]; // [sp+4h] [bp-54Ch]
  u_native id; // [sp+8h] [bp-548h]
  int v25; // [sp+10h] [bp-540h]
  int32 pIndex; // [sp+18h] [bp-538h] BYREF
  char v27; // [sp+1Ch] [bp-534h] BYREF
  _BYTE v28[3]; // [sp+1Dh] [bp-533h] BYREF
  unsigned __int8 pLine[1024]; // [sp+11Ch] [bp-434h] BYREF

  CFileMgr::ChangeDir("\\DATA\\");
  id = CFileMgr::OpenFile("CARGRP.DAT", "r");
  CFileMgr::ChangeDir("\\");
  v0 = vdupq_n_s16(0x7D0u);
  v1 = CPopulation::m_CarGroups;
  v2 = 0;
LABEL_3:
  v25 = v2;
  v23 = v1;
LABEL_4:
  if ( CFileMgr::ReadLine(id, pLine, 1024) )
  {
    for ( i = pLine; ; ++i )
    {
      v4 = *i;
      v5 = v4 == 13;
      if ( v4 != 13 )
        v5 = v4 == 44;
      if ( v5 )
      {
        *i = 32;
      }
      else if ( v4 == 10 )
      {
        v6 = 0;
        v7 = 0;
        *i = 0;
        v8 = 0;
        do
        {
          v9 = v8;
          v10 = v6 + 1;
          v11 = &v28[-v6];
          v12 = v6 - 1;
          do
          {
            v13 = v10;
            v14 = &pLine[v12];
            --v11;
            ++v12;
            v15 = v14[1];
            v10 = v13 + 1;
          }
          while ( (unsigned __int8)(v15 - 1) < 0x20u );
          if ( v15 == 35 )
            break;
          v6 = v12;
          if ( v15 >= 0x21 )
          {
            do
              v16 = pLine[v13++];
            while ( v16 > 0x20 );
            v6 = v13 - 1;
          }
          if ( v6 == v12 )
            break;
          strncpy(&v27, (const char *)&pLine[v12], v6 - v12);
          v11[v6] = 0;
          if ( CModelInfo::GetModelInfo((const unsigned __int8 *)&v27, &pIndex) )
            CPopulation::m_CarGroups[v25][v7++] = pIndex;
          v8 = v9 + 1;
        }
        while ( v9 < 22 );
        if ( v7 >= 1 )
        {
          CPopulation::m_nNumCarsInGroup[v25] = v7;
          if ( v7 <= 22 )
          {
            v17 = 23 - v7;
            if ( (unsigned int)(23 - v7) < 8 )
            {
              v18 = v7;
              goto LABEL_33;
            }
            v19 = v17 & 0xFFFFFFF8;
            if ( (v17 & 0xFFFFFFF8) == 0 )
            {
              v18 = v7;
              goto LABEL_33;
            }
            v18 = v7 + v19;
            v20 = (int16x8_t *)&(*v23)[v7];
            v21 = v17 & 0xFFFFFFF8;
            do
            {
              *v20++ = v0;
              v21 -= 8;
            }
            while ( v21 );
            if ( v17 != v19 )
            {
              do
LABEL_33:
                (*v23)[v18] = 2000;
              while ( v18++ < 22 );
            }
          }
          v1 = v23 + 1;
          v2 = v25 + 1;
          goto LABEL_3;
        }
        goto LABEL_4;
      }
    }
  }
  CFileMgr::CloseFile(id);
}
// 475018: using guessed type unsigned __int8 pLine[1024];

//----- (004751F4) --------------------------------------------------------
uint8 __fastcall CTaskSimpleFight::GetHitLevel(const unsigned __int8 *pString)
{
  uint8 v2; // r1
  uint8 result; // r0
  int v4; // r0

  v2 = 0;
  switch ( *pString )
  {
    case 'B':
      result = 3;
      break;
    case 'G':
      result = 2;
      break;
    case 'H':
      goto LABEL_7;
    case 'L':
      result = 1;
      break;
    default:
      if ( !strcmp((const char *)pString, (const char *)&off_47525C) )
      {
        result = 4;
      }
      else if ( !strcmp((const char *)pString, (const char *)&off_475260) )
      {
        result = 5;
      }
      else
      {
        v4 = strcmp((const char *)pString, (const char *)&dword_475264);
        v2 = 7;
        if ( !v4 )
          v2 = 6;
LABEL_7:
        result = v2;
      }
      break;
  }
  return result;
}
// 47525C: using guessed type void *off_47525C;
// 475260: using guessed type void *off_475260;
// 475264: using guessed type int dword_475264;

//----- (00475268) --------------------------------------------------------
Int16 __fastcall CTaskSimpleFight::GetHitSound(const int32 nHitSound)
{
  int v1; // r1
  Int16 result; // r0

  v1 = nHitSound - 1;
  result = 61;
  switch ( v1 )
  {
    case 0:
      return result;
    case 2:
      result = 63;
      break;
    case 3:
      result = 64;
      break;
    case 4:
      result = 65;
      break;
    case 5:
      result = 66;
      break;
    case 6:
      result = 67;
      break;
    case 7:
      result = 68;
      break;
    default:
      result = 62;
      break;
  }
  return result;
}

//----- (00475298) --------------------------------------------------------
bool8 __fastcall InteriorManager_c::Init(InteriorManager_c *this)
{
  this->m_activePeds = 1;
  *(_WORD *)&this->m_freeze = 256;
  InteriorManager_c::ReturnInteriorToPool(&g_interiorMan, this->m_interiors);
  InteriorManager_c::ReturnInteriorToPool(&g_interiorMan, &this->m_interiors[1]);
  InteriorManager_c::ReturnInteriorToPool(&g_interiorMan, &this->m_interiors[2]);
  InteriorManager_c::ReturnInteriorToPool(&g_interiorMan, &this->m_interiors[3]);
  InteriorManager_c::ReturnInteriorToPool(&g_interiorMan, &this->m_interiors[4]);
  InteriorManager_c::ReturnInteriorToPool(&g_interiorMan, &this->m_interiors[5]);
  InteriorManager_c::ReturnInteriorToPool(&g_interiorMan, &this->m_interiors[6]);
  InteriorManager_c::ReturnInteriorToPool(&g_interiorMan, &this->m_interiors[7]);
  this->m_interiorGroups[0].m_id = 0;
  List_c::AddItem(&this->m_interiorGroupPool, this->m_interiorGroups);
  this->m_interiorGroups[1].m_id = 1;
  List_c::AddItem(&this->m_interiorGroupPool, &this->m_interiorGroups[1]);
  this->m_interiorGroups[2].m_id = 2;
  List_c::AddItem(&this->m_interiorGroupPool, &this->m_interiorGroups[2]);
  this->m_interiorGroups[3].m_id = 3;
  List_c::AddItem(&this->m_interiorGroupPool, &this->m_interiorGroups[3]);
  this->m_interiorGroups[4].m_id = 4;
  List_c::AddItem(&this->m_interiorGroupPool, &this->m_interiorGroups[4]);
  this->m_interiorGroups[5].m_id = 5;
  List_c::AddItem(&this->m_interiorGroupPool, &this->m_interiorGroups[5]);
  this->m_interiorGroups[6].m_id = 6;
  List_c::AddItem(&this->m_interiorGroupPool, &this->m_interiorGroups[6]);
  this->m_interiorGroups[7].m_id = 7;
  List_c::AddItem(&this->m_interiorGroupPool, &this->m_interiorGroups[7]);
  FurnitureManager_c::Init(&g_furnitureMan);
  this->m_pEntryExit = 0;
  this->m_numStealInfosIds = 0;
  this->m_numStealableObjects = 0;
  *(_DWORD *)&this->m_pedsAlive[12] = 16843009;
  *(_DWORD *)&this->m_pedsAlive[8] = 16843009;
  *(_DWORD *)&this->m_pedsAlive[4] = 16843009;
  this->m_timeLastPickupsGenerated = -180000;
  *(_DWORD *)this->m_pedsAlive = 16843009;
  return 1;
}

//----- (00475414) --------------------------------------------------------
int32 __fastcall FurnitureManager_c::Init(FurnitureManager_c *this)
{
  List_c *p_m_furnitureEntityPool; // r5
  int v3; // r6

  p_m_furnitureEntityPool = &this->m_furnitureEntityPool;
  v3 = 108;
  g_currSubGroupId = 0;
  g_currFurnitureId = 0;
  do
  {
    List_c::AddItem(p_m_furnitureEntityPool, (ListItem_c *)((char *)this + v3));
    v3 += 16;
  }
  while ( v3 != 8300 );
  FurnitureGroup_c::Init(this->m_groups);
  FurnitureGroup_c::Init(&this->m_groups[1]);
  FurnitureGroup_c::Init(&this->m_groups[2]);
  FurnitureGroup_c::Init(&this->m_groups[3]);
  FurnitureGroup_c::Init(&this->m_groups[4]);
  FurnitureGroup_c::Init(&this->m_groups[5]);
  FurnitureGroup_c::Init(&this->m_groups[6]);
  FurnitureGroup_c::Init(&this->m_groups[7]);
  FurnitureGroup_c::Init(&this->m_groups[8]);
  FurnitureManager_c::LoadFurniture(this);
  return 1;
}

//----- (004754A4) --------------------------------------------------------
void __fastcall FurnitureManager_c::LoadFurniture(FurnitureManager_c *this)
{
  u_native v2; // r5
  unsigned __int8 *Line; // r9
  int32 GroupId; // r8
  FurnitureSubGroup_c *m_head; // r4
  uint8 v6; // r6
  uint8 v7; // r8
  int16 v8; // r11
  uint8 v9; // r9
  uint16 v10; // r10
  FurnitureManager_c *v11; // r0
  FurnitureManager_c *v12; // r0
  int v13; // r0
  bool v14; // zf
  int32 v15; // [sp+1Ch] [bp-124h]
  FurnitureManager_c *v16; // [sp+20h] [bp-120h]
  int32 SubGroupId; // [sp+24h] [bp-11Ch]
  bool8 isStealable; // [sp+28h] [bp-118h] BYREF
  int32 pIndex; // [sp+2Ch] [bp-114h] BYREF
  bool8 onWindow; // [sp+30h] [bp-110h] BYREF
  int32 v21; // [sp+34h] [bp-10Ch] BYREF
  int32 v22; // [sp+38h] [bp-108h] BYREF
  int32 v23; // [sp+3Ch] [bp-104h] BYREF
  unsigned __int8 s[128]; // [sp+40h] [bp-100h] BYREF
  int32 v25[16]; // [sp+C0h] [bp-80h] BYREF
  char v26[32]; // [sp+100h] [bp-40h] BYREF

  v2 = CFileMgr::OpenFile("data\\furnitur.dat", "rb");
  Line = CFileLoader::LoadLine(v2);
  if ( Line )
  {
    GroupId = -1;
    SubGroupId = -1;
    do
    {
      v13 = *Line;
      v14 = v13 == 35;
      if ( v13 != 35 )
        v14 = v13 == 0;
      if ( !v14 )
      {
        sscanf((const char *)Line, "%s", v26);
        if ( !strcmp(v26, "GROUP:") )
        {
          v11 = (FurnitureManager_c *)sscanf((const char *)Line, "%s %s", v26, s);
          GroupId = FurnitureManager_c::GetGroupId(v11, s);
        }
        else if ( !strcmp(v26, "SUBGROUP:") )
        {
          v12 = (FurnitureManager_c *)sscanf(
                                        (const char *)Line,
                                        "%s %s %d %d %d %d %d %d %d",
                                        v26,
                                        s,
                                        v25,
                                        &v22,
                                        &v23,
                                        &v21,
                                        &onWindow,
                                        &pIndex,
                                        &isStealable);
          SubGroupId = FurnitureManager_c::GetSubGroupId(v12, s);
          FurnitureGroup_c::AddSubGroup(
            &this->m_groups[GroupId],
            SubGroupId,
            v25[0],
            v22,
            v23,
            v21,
            onWindow,
            pIndex,
            isStealable);
        }
        else if ( !strcmp(v26, "ITEM:") )
        {
          sscanf((const char *)Line, "%s %s %d %d %d %d", v26, v25, &v23, &v22, &v21, &onWindow);
          v15 = GroupId;
          v16 = this;
          if ( CModelInfo::GetModelInfo((const unsigned __int8 *)v25, &pIndex) )
          {
            m_head = (FurnitureSubGroup_c *)this->m_groups[GroupId].m_subGroupList.m_head;
            if ( m_head )
            {
              v6 = v21;
              v7 = v22;
              v8 = v23;
              v10 = pIndex;
              v9 = onWindow;
              do
              {
                if ( m_head->m_id == SubGroupId )
                  FurnitureSubGroup_c::AddFurniture(m_head, v10, v8, v7, v6, v9);
                m_head = (FurnitureSubGroup_c *)m_head->m_next;
              }
              while ( m_head );
            }
          }
          else
          {
            sprintf(s, "Cannot find model %s", (const char *)v25);
          }
          GroupId = v15;
          this = v16;
        }
      }
      Line = CFileLoader::LoadLine(v2);
    }
    while ( Line );
  }
  CFileMgr::CloseFile(v2);
}

//----- (004756FC) --------------------------------------------------------
int32 __fastcall FurnitureManager_c::GetGroupId(FurnitureManager_c *this, unsigned __int8 *groupString)
{
  int v3; // r1
  int32 result; // r0

  if ( !strcmp((const char *)groupString, "IT_SHOP") )
    return 0;
  if ( !strcmp((const char *)groupString, "IT_OFFICE") )
    return 1;
  if ( !strcmp((const char *)groupString, "IT_LOUNGE") )
    return 2;
  if ( !strcmp((const char *)groupString, "IT_BEDROOM") )
    return 3;
  if ( !strcmp((const char *)groupString, "IT_KITCHEN") )
    return 4;
  v3 = strcmp((const char *)groupString, "IT_MISC");
  result = -1;
  if ( !v3 )
    return 8;
  return result;
}

//----- (004757A0) --------------------------------------------------------
int32 __fastcall FurnitureManager_c::GetSubGroupId(FurnitureManager_c *this, unsigned __int8 *subGroupString)
{
  int v3; // r1
  int32 result; // r0

  if ( !strcmp((const char *)subGroupString, "SHOP_UNIT1_L") )
    return 0;
  if ( !strcmp((const char *)subGroupString, "SHOP_UNIT1_R") )
    return 1;
  if ( !strcmp((const char *)subGroupString, "SHOP_UNIT1_M") )
    return 2;
  if ( !strcmp((const char *)subGroupString, "SHOP_UNIT2_L") )
    return 3;
  if ( !strcmp((const char *)subGroupString, "SHOP_UNIT2_R") )
    return 4;
  if ( !strcmp((const char *)subGroupString, "SHOP_UNIT2_M") )
    return 5;
  if ( !strcmp((const char *)subGroupString, "SHOP_UNIT3_L") )
    return 6;
  if ( !strcmp((const char *)subGroupString, "SHOP_UNIT3_R") )
    return 7;
  if ( !strcmp((const char *)subGroupString, "SHOP_UNIT3_M") )
    return 8;
  if ( !strcmp((const char *)subGroupString, "SHOP_UNIT4_L") )
    return 9;
  if ( !strcmp((const char *)subGroupString, "SHOP_UNIT4_R") )
    return 10;
  if ( !strcmp((const char *)subGroupString, "SHOP_UNIT4_M") )
    return 11;
  if ( !strcmp((const char *)subGroupString, "SHOP_CHECKOUTS") )
    return 12;
  if ( !strcmp((const char *)subGroupString, "SHOP_BASKETS") )
    return 13;
  if ( !strcmp((const char *)subGroupString, "SHOP_LIGHTS") )
    return 14;
  if ( !strcmp((const char *)subGroupString, "OFFICE_DESKS") )
    return 0;
  if ( !strcmp((const char *)subGroupString, "OFFICE_CHAIRS") )
    return 1;
  if ( !strcmp((const char *)subGroupString, "OFFICE_WATERCOOLERS") )
    return 2;
  if ( !strcmp((const char *)subGroupString, "OFFICE_FILINGCABS") )
    return 3;
  if ( !strcmp((const char *)subGroupString, "LOUNGE_SOFAS") )
    return 0;
  if ( !strcmp((const char *)subGroupString, "LOUNGE_CHAIRS") )
    return 1;
  if ( !strcmp((const char *)subGroupString, "LOUNGE_TVSTANDS") )
    return 2;
  if ( !strcmp((const char *)subGroupString, "LOUNGE_TVS") )
    return 3;
  if ( !strcmp((const char *)subGroupString, "LOUNGE_TABLES") )
    return 4;
  if ( !strcmp((const char *)subGroupString, "LOUNGE_LAMPS") )
    return 5;
  if ( !strcmp((const char *)subGroupString, "LOUNGE_HIFI_TABLES") )
    return 6;
  if ( !strcmp((const char *)subGroupString, "LOUNGE_VIDEOS") )
    return 7;
  if ( !strcmp((const char *)subGroupString, "LOUNGE_HIFIS") )
    return 8;
  if ( !strcmp((const char *)subGroupString, "LOUNGE_CONSOLES") )
    return 9;
  if ( !strcmp((const char *)subGroupString, "BEDROOM_BEDS") )
    return 0;
  if ( !strcmp((const char *)subGroupString, "BEDROOM_TABLES") )
    return 1;
  if ( !strcmp((const char *)subGroupString, "BEDROOM_DRAWERS") )
    return 2;
  if ( !strcmp((const char *)subGroupString, "BEDROOM_WARDROBES") )
    return 3;
  if ( !strcmp((const char *)subGroupString, "KITCHEN_UNIT_L") )
    return 0;
  if ( !strcmp((const char *)subGroupString, "KITCHEN_UNIT_M") )
    return 1;
  if ( !strcmp((const char *)subGroupString, "KITCHEN_UNIT_R") )
    return 2;
  if ( !strcmp((const char *)subGroupString, "KITCHEN_UNIT_SINKS") )
    return 3;
  if ( !strcmp((const char *)subGroupString, "KITCHEN_UNIT_FRIDGES") )
    return 4;
  if ( !strcmp((const char *)subGroupString, "KITCHEN_UNIT_OVENS") )
    return 5;
  if ( !strcmp((const char *)subGroupString, "KITCHEN_UNIT_WASHERS") )
    return 6;
  if ( !strcmp((const char *)subGroupString, "KITCHEN_UNIT_CORNERS") )
    return 7;
  if ( !strcmp((const char *)subGroupString, "KITCHEN_MICROWAVES") )
    return 8;
  if ( !strcmp((const char *)subGroupString, "KITCHEN_TOASTERS") )
    return 9;
  if ( !strcmp((const char *)subGroupString, "KITCHEN_TVS") )
    return 10;
  if ( !strcmp((const char *)subGroupString, "MISC_PLANTS") )
    return 0;
  if ( !strcmp((const char *)subGroupString, "MISC_LIGHTS") )
    return 1;
  if ( !strcmp((const char *)subGroupString, "MISC_RUGS") )
    return 2;
  if ( !strcmp((const char *)subGroupString, "MISC_PLATES") )
    return 3;
  if ( !strcmp((const char *)subGroupString, "MISC_FOOD") )
    return 4;
  if ( !strcmp((const char *)subGroupString, "MISC_MAGAZINES") )
    return 5;
  v3 = strcmp((const char *)subGroupString, "MISC_CLOTHES");
  result = -1;
  if ( !v3 )
    return 6;
  return result;
}

//----- (00475CF0) --------------------------------------------------------
int __fastcall FurnitureGroup_c::AddFurniture(
        FurnitureGroup_c *this,
        int32 subGroupId,
        uint16 modelIndex,
        int16 refId,
        uint8 a5,
        uint8 a6,
        uint8 a7)
{
  FurnitureSubGroup_c *m_head; // r4

  m_head = (FurnitureSubGroup_c *)this->m_subGroupList.m_head;
  if ( this->m_subGroupList.m_head )
  {
    do
    {
      if ( m_head->m_id == subGroupId )
        FurnitureSubGroup_c::AddFurniture(m_head, modelIndex, refId, a5, a6, a7);
      m_head = (FurnitureSubGroup_c *)m_head->m_next;
    }
    while ( m_head );
  }
  return 1;
}

//----- (00475D34) --------------------------------------------------------
int __fastcall FurnitureSubGroup_c::AddFurniture(
        FurnitureSubGroup_c *this,
        int modelIndex,
        int16 refId,
        uint8 minRating,
        uint8 a5,
        uint8 a6)
{
  int v6; // r4
  Furniture_c *v7; // r5
  CColModel *m_pColModel; // r1
  unsigned __int64 v9; // d0
  int v11; // r2
  Furniture_c *v12; // r1
  int v13; // r5
  float v14; // s0

  if ( g_currFurnitureId > 0xFFu )
    return 0;
  v6 = g_currFurnitureId++;
  v7 = &g_furnitureStore[v6];
  v7->m_refId = refId;
  v7->m_modelIndex = modelIndex;
  m_pColModel = CModelInfo::ms_modelInfoPtrs[modelIndex]->m_pColModel;
  if ( this->m_isStealable )
    v9 = vsub_f32(
           *(float32x2_t *)&m_pColModel->m_boxBound.m_vecMax.x,
           *(float32x2_t *)&m_pColModel->m_boxBound.m_vecMin.x).n64_u64[0];
  else
    v9 = vadd_f32(*(float32x2_t *)&m_pColModel->m_boxBound.m_vecMax.x, (float32x2_t)0x3F0000003F000000LL).n64_u64[0];
  v11 = (int)*((float *)&v9 + 1);
  v12 = &g_furnitureStore[v6];
  v13 = (int)*(float *)&v9;
  v12->m_ratingMin = minRating;
  v12->m_ratingMax = a5;
  v12->m_maxAngle = a6;
  *(float *)&v9 = *(float *)&v9 - (float)(int)*(float *)&v9;
  if ( (float)(*((float *)&v9 + 1) - (float)(int)*((float *)&v9 + 1)) >= 0.02 )
    LOBYTE(v11) = v11 + 1;
  v12->m_depth = v11;
  if ( v14 >= 0.02 )
    LOBYTE(v13) = v13 + 1;
  v12->m_width = v13;
  v12->m_onWindowTile = this->m_onWindowTile;
  v12->m_isTall = this->m_isTall;
  v12->m_isStealable = this->m_isStealable;
  List_c::AddItem(&this->m_furnitureList, v12);
  return 1;
}

//----- (00475E2C) --------------------------------------------------------
void __fastcall jpeg_CreateCompress(j_compress_ptr cinfo, int version, size_t structsize)
{
  jpeg_error_mgr *err; // r5
  void *client_data; // r6

  cinfo->mem = 0;
  if ( version != 62 )
  {
    cinfo->err->msg_code = 12;
    cinfo->err->msg_parm.i[0] = 62;
    cinfo->err->msg_parm.i[1] = version;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  if ( structsize != 360 )
  {
    cinfo->err->msg_code = 21;
    cinfo->err->msg_parm.i[0] = 360;
    cinfo->err->msg_parm.i[1] = structsize;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  err = cinfo->err;
  client_data = cinfo->client_data;
  memset(&cinfo->mem, 0, 0x164u);
  cinfo->client_data = client_data;
  cinfo->err = err;
  cinfo->is_decompressor = 0;
  jinit_memory_mgr((j_common_ptr)cinfo);
  *(_QWORD *)&cinfo->dc_huff_tbl_ptrs[3] = 0LL;
  *(_QWORD *)&cinfo->ac_huff_tbl_ptrs[1] = 0LL;
  *(_QWORD *)&cinfo->quant_tbl_ptrs[3] = 0LL;
  *(_QWORD *)&cinfo->dc_huff_tbl_ptrs[1] = 0LL;
  *(_QWORD *)&cinfo->comp_info = 0LL;
  *(_QWORD *)&cinfo->quant_tbl_ptrs[1] = 0LL;
  cinfo->progress = 0;
  cinfo->script_space = 0;
  cinfo->ac_huff_tbl_ptrs[3] = 0;
  LODWORD(cinfo->input_gamma) = 0;
  HIDWORD(cinfo->input_gamma) = 1072693248;
  cinfo->global_state = 100;
  cinfo->dest = 0;
}

//----- (00475ED6) --------------------------------------------------------
void __fastcall jpeg_suppress_tables(j_compress_ptr cinfo, boolean suppress)
{
  JQUANT_TBL *v2; // r2
  JQUANT_TBL *v3; // r2
  JQUANT_TBL *v4; // r2
  JQUANT_TBL *v5; // r2
  JHUFF_TBL *v6; // r2
  JHUFF_TBL *v7; // r2
  JHUFF_TBL *v8; // r2
  JHUFF_TBL *v9; // r2
  JHUFF_TBL *v10; // r2
  JHUFF_TBL *v11; // r2
  JHUFF_TBL *v12; // r2
  JHUFF_TBL *v13; // r0

  v2 = cinfo->quant_tbl_ptrs[0];
  if ( v2 )
    v2->sent_table = suppress;
  v3 = cinfo->quant_tbl_ptrs[1];
  if ( v3 )
    v3->sent_table = suppress;
  v4 = cinfo->quant_tbl_ptrs[2];
  if ( v4 )
    v4->sent_table = suppress;
  v5 = cinfo->quant_tbl_ptrs[3];
  if ( v5 )
    v5->sent_table = suppress;
  v6 = cinfo->dc_huff_tbl_ptrs[0];
  if ( v6 )
    v6->sent_table = suppress;
  v7 = cinfo->ac_huff_tbl_ptrs[0];
  if ( v7 )
    v7->sent_table = suppress;
  v8 = cinfo->dc_huff_tbl_ptrs[1];
  if ( v8 )
    v8->sent_table = suppress;
  v9 = cinfo->ac_huff_tbl_ptrs[1];
  if ( v9 )
    v9->sent_table = suppress;
  v10 = cinfo->dc_huff_tbl_ptrs[2];
  if ( v10 )
    v10->sent_table = suppress;
  v11 = cinfo->ac_huff_tbl_ptrs[2];
  if ( v11 )
    v11->sent_table = suppress;
  v12 = cinfo->dc_huff_tbl_ptrs[3];
  if ( v12 )
    v12->sent_table = suppress;
  v13 = cinfo->ac_huff_tbl_ptrs[3];
  if ( v13 )
    v13->sent_table = suppress;
}

//----- (00475F50) --------------------------------------------------------
void __fastcall jpeg_finish_compress(j_compress_ptr cinfo)
{
  int global_state; // r0
  jpeg_comp_master *i; // r0
  JDIMENSION v4; // r6
  jpeg_progress_mgr *progress; // r0

  global_state = cinfo->global_state;
  if ( (unsigned int)(global_state - 101) >= 2 )
  {
    if ( global_state != 103 )
    {
      cinfo->err->msg_code = 20;
      cinfo->err->msg_parm.i[0] = cinfo->global_state;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
  }
  else
  {
    if ( cinfo->next_scanline < cinfo->image_height )
    {
      cinfo->err->msg_code = 67;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    cinfo->master->finish_pass(cinfo);
  }
  for ( i = cinfo->master; !i->is_last_pass; i = cinfo->master )
  {
    i->prepare_for_pass(cinfo);
    if ( cinfo->total_iMCU_rows )
    {
      v4 = 0;
      do
      {
        progress = cinfo->progress;
        if ( progress )
        {
          progress->pass_counter = v4;
          cinfo->progress->pass_limit = cinfo->total_iMCU_rows;
          cinfo->progress->progress_monitor((j_common_ptr)cinfo);
        }
        if ( !((int (__fastcall *)(j_compress_ptr, _DWORD))cinfo->coef->compress_data)(cinfo, 0) )
        {
          cinfo->err->msg_code = 24;
          cinfo->err->error_exit((j_common_ptr)cinfo);
        }
        ++v4;
      }
      while ( v4 < cinfo->total_iMCU_rows );
    }
    cinfo->master->finish_pass(cinfo);
  }
  cinfo->marker->write_file_trailer(cinfo);
  cinfo->dest->term_destination(cinfo);
  sub_190B3C((j_common_ptr)cinfo);
}

//----- (00476022) --------------------------------------------------------
void __fastcall jpeg_write_marker(j_compress_ptr cinfo, int marker, const JOCTET *dataptr, unsigned int datalen)
{
  void (*write_marker_byte)(j_compress_ptr, int); // r6
  int v9; // t1

  if ( cinfo->next_scanline || (unsigned int)(cinfo->global_state - 101) >= 3 )
  {
    cinfo->err->msg_code = 20;
    cinfo->err->msg_parm.i[0] = cinfo->global_state;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  cinfo->marker->write_marker_header(cinfo, marker, datalen);
  if ( datalen )
  {
    write_marker_byte = cinfo->marker->write_marker_byte;
    do
    {
      v9 = *dataptr++;
      write_marker_byte(cinfo, v9);
      --datalen;
    }
    while ( datalen );
  }
}

//----- (00476086) --------------------------------------------------------
void __fastcall jpeg_write_m_header(j_compress_ptr cinfo, int marker, unsigned int datalen)
{
  if ( cinfo->next_scanline || (unsigned int)(cinfo->global_state - 101) >= 3 )
  {
    cinfo->err->msg_code = 20;
    cinfo->err->msg_parm.i[0] = cinfo->global_state;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  cinfo->marker->write_marker_header(cinfo, marker, datalen);
}

//----- (004760CC) --------------------------------------------------------
void __fastcall jpeg_write_m_byte(j_compress_ptr cinfo, int val)
{
  ((void (*)(void))cinfo->marker->write_marker_byte)();
}

//----- (004760D4) --------------------------------------------------------
void __fastcall jpeg_write_tables(j_compress_ptr cinfo)
{
  if ( cinfo->global_state != 100 )
  {
    cinfo->err->msg_code = 20;
    cinfo->err->msg_parm.i[0] = cinfo->global_state;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  cinfo->err->reset_error_mgr((j_common_ptr)cinfo);
  cinfo->dest->init_destination(cinfo);
  jinit_marker_writer(cinfo);
  cinfo->marker->write_tables_only(cinfo);
  cinfo->dest->term_destination(cinfo);
}

//----- (00476120) --------------------------------------------------------
void __fastcall jpeg_start_compress(j_compress_ptr cinfo, boolean write_all_tables)
{
  int v3; // r5
  int raw_data_in; // r1
  int v5; // r0

  v3 = write_all_tables;
  if ( cinfo->global_state != 100 )
  {
    cinfo->err->msg_code = 20;
    cinfo->err->msg_parm.i[0] = cinfo->global_state;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  if ( v3 )
    jpeg_suppress_tables(cinfo, 0);
  cinfo->err->reset_error_mgr((j_common_ptr)cinfo);
  cinfo->dest->init_destination(cinfo);
  jinit_compress_master(cinfo);
  cinfo->master->prepare_for_pass(cinfo);
  raw_data_in = cinfo->raw_data_in;
  cinfo->next_scanline = 0;
  v5 = 101;
  if ( raw_data_in )
    v5 = 102;
  cinfo->global_state = v5;
}

//----- (00476184) --------------------------------------------------------
JDIMENSION __fastcall jpeg_write_scanlines(j_compress_ptr cinfo, JSAMPARRAY scanlines, JDIMENSION num_lines)
{
  jpeg_progress_mgr *progress; // r0
  jpeg_comp_master *master; // r0
  JDIMENSION image_height; // r0
  JDIMENSION next_scanline; // r1
  JDIMENSION v10; // r0
  JDIMENSION result; // r0
  JDIMENSION v12[5]; // [sp+4h] [bp-14h] BYREF

  if ( cinfo->global_state != 101 )
  {
    cinfo->err->msg_code = 20;
    cinfo->err->msg_parm.i[0] = cinfo->global_state;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  if ( cinfo->next_scanline >= cinfo->image_height )
  {
    cinfo->err->msg_code = 123;
    cinfo->err->emit_message((j_common_ptr)cinfo, -1);
  }
  progress = cinfo->progress;
  if ( progress )
  {
    progress->pass_counter = cinfo->next_scanline;
    cinfo->progress->pass_limit = cinfo->image_height;
    cinfo->progress->progress_monitor((j_common_ptr)cinfo);
  }
  master = cinfo->master;
  if ( master->call_pass_startup )
    master->pass_startup(cinfo);
  image_height = cinfo->image_height;
  next_scanline = cinfo->next_scanline;
  v12[0] = 0;
  v10 = image_height - next_scanline;
  if ( v10 < num_lines )
    num_lines = v10;
  cinfo->main->process_data(cinfo, scanlines, v12, num_lines);
  result = v12[0];
  cinfo->next_scanline += v12[0];
  return result;
}
// 476184: using guessed type JDIMENSION var_14[5];

//----- (00476228) --------------------------------------------------------
JDIMENSION __fastcall jpeg_write_raw_data(j_compress_ptr cinfo, JSAMPIMAGE data, JDIMENSION num_lines)
{
  JDIMENSION next_scanline; // r0
  jpeg_progress_mgr *progress; // r1
  jpeg_comp_master *master; // r0
  unsigned int v9; // r5

  if ( cinfo->global_state != 102 )
  {
    cinfo->err->msg_code = 20;
    cinfo->err->msg_parm.i[0] = cinfo->global_state;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  next_scanline = cinfo->next_scanline;
  if ( next_scanline >= cinfo->image_height )
  {
    cinfo->err->msg_code = 123;
    cinfo->err->emit_message((j_common_ptr)cinfo, -1);
    return 0;
  }
  progress = cinfo->progress;
  if ( progress )
  {
    progress->pass_counter = next_scanline;
    cinfo->progress->pass_limit = cinfo->image_height;
    cinfo->progress->progress_monitor((j_common_ptr)cinfo);
  }
  master = cinfo->master;
  if ( master->call_pass_startup )
    master->pass_startup(cinfo);
  v9 = 8 * cinfo->max_v_samp_factor;
  if ( v9 > num_lines )
  {
    cinfo->err->msg_code = 23;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  if ( !((int (__fastcall *)(j_compress_ptr, JSAMPIMAGE))cinfo->coef->compress_data)(cinfo, data) )
    return 0;
  cinfo->next_scanline += v9;
  return v9;
}

//----- (004762D0) --------------------------------------------------------
void __fastcall jinit_c_coef_controller(j_compress_ptr cinfo, boolean need_full_buffer)
{
  int v3; // r6
  int v4; // r5
  int v5; // r8
  int v6; // r4
  int *p_width_in_blocks; // r6
  jvirt_barray_ptr (*request_virt_barray)(j_common_ptr, int, boolean, JDIMENSION, JDIMENSION, JDIMENSION); // r10
  int v9; // r5
  int v10; // r0
  char *v11; // r0
  int32x4_t v12; // q10
  int32x4_t v13; // q8
  int32x4_t v14; // q9

  v3 = need_full_buffer;
  v4 = cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 80);
  cinfo->coef = (jpeg_c_coef_controller *)v4;
  *(_DWORD *)v4 = start_pass_coef;
  if ( v3 )
  {
    if ( cinfo->num_components >= 1 )
    {
      v5 = v4 + 64;
      v6 = 0;
      p_width_in_blocks = (int *)&cinfo->comp_info->width_in_blocks;
      do
      {
        request_virt_barray = cinfo->mem->request_virt_barray;
        v9 = jround_up(*p_width_in_blocks, *(p_width_in_blocks - 5));
        v10 = jround_up(p_width_in_blocks[1], *(p_width_in_blocks - 4));
        *(_DWORD *)(v5 + 4 * v6) = request_virt_barray((j_common_ptr)cinfo, 1, 0, v9, v10, *(p_width_in_blocks - 4));
        p_width_in_blocks += 21;
        ++v6;
      }
      while ( v6 < cinfo->num_components );
    }
  }
  else
  {
    v11 = (char *)cinfo->mem->alloc_large(cinfo, 1, 1280);
    v12 = vdupq_n_s32((unsigned int)v11);
    v13.n128_u64[0] = 0x10000000080LL;
    v13.n128_u64[1] = 0x20000000180LL;
    v14.n128_u64[0] = 0x30000000280LL;
    v14.n128_u64[1] = 0x40000000380LL;
    *(_DWORD *)(v4 + 24) = v11;
    *(_DWORD *)(v4 + 60) = v11 + 1152;
    *(_DWORD *)(v4 + 64) = 0;
    *(int32x4_t *)(v4 + 28) = vaddq_s32(v12, v13);
    *(int32x4_t *)(v4 + 44) = vaddq_s32(v12, v14);
  }
}

//----- (004763C4) --------------------------------------------------------
void __fastcall start_pass_coef(j_compress_ptr cinfo, J_BUF_MODE pass_mode)
{
  jpeg_c_coef_controller *coef; // r8
  jpeg_c_coef_controller *v3; // r3
  int v4; // r4
  jpeg_component_info *v5; // r5
  int *p_last_row_height; // r4
  boolean (__fastcall *v7)(j_compress_ptr, JSAMPIMAGE); // r0

  coef = cinfo->coef;
  coef[1].start_pass = 0;
  v3 = cinfo->coef;
  if ( cinfo->comps_in_scan <= 1 )
  {
    v5 = cinfo->cur_comp_info[0];
    p_last_row_height = &v5->last_row_height;
    if ( (char *)v3[1].start_pass < (char *)(cinfo->total_iMCU_rows - 1) )
      p_last_row_height = &v5->v_samp_factor;
    v4 = *p_last_row_height;
  }
  else
  {
    v4 = 1;
  }
  v3[1].compress_data = 0;
  v3[2].start_pass = 0;
  v3[2].compress_data = (boolean (*)(j_compress_ptr, JSAMPIMAGE))v4;
  switch ( pass_mode )
  {
    case JBUF_SAVE_AND_PASS:
      if ( !coef[8].start_pass )
      {
        cinfo->err->msg_code = 4;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      v7 = compress_first_pass;
      goto LABEL_18;
    case JBUF_CRANK_DEST:
      if ( !coef[8].start_pass )
      {
        cinfo->err->msg_code = 4;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      v7 = compress_output;
      goto LABEL_18;
    case JBUF_PASS_THRU:
      if ( coef[8].start_pass )
      {
        cinfo->err->msg_code = 4;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      v7 = compress_data;
LABEL_18:
      coef->compress_data = v7;
      return;
  }
  cinfo->err->msg_code = 4;
  cinfo->err->error_exit((j_common_ptr)cinfo);
}

//----- (00476484) --------------------------------------------------------
boolean __fastcall compress_data(j_compress_ptr cinfo, JSAMPIMAGE input_buf)
{
  j_compress_ptr v2; // r4
  jpeg_c_coef_controller *coef; // r3
  boolean (*v4)(j_compress_ptr, JSAMPIMAGE); // r0
  jpeg_c_coef_controller *v5; // r8
  boolean (*v6)(j_compress_ptr, JSAMPIMAGE); // r5
  int comps_in_scan; // r0
  int v8; // r10
  int v9; // r3
  jpeg_component_info *v10; // r12
  int *p_MCU_width; // r9
  int *p_last_col_width; // r1
  int v13; // r11
  int v14; // r5
  int MCU_width; // r0
  int v16; // r1
  int v17; // r0
  void (**v18)(j_compress_ptr, J_BUF_MODE); // r4
  int v19; // r3
  _WORD *v20; // r6
  jpeg_c_coef_controller *v21; // r0
  int v22; // r1
  jpeg_component_info *v24; // r2
  int *p_last_row_height; // r6
  boolean (*v26)(j_compress_ptr, JSAMPIMAGE); // [sp+10h] [bp-50h]
  unsigned int v27; // [sp+14h] [bp-4Ch]
  int v28; // [sp+18h] [bp-48h]
  jpeg_c_coef_controller *v29; // [sp+1Ch] [bp-44h]
  void (*start_pass)(j_compress_ptr, J_BUF_MODE); // [sp+20h] [bp-40h]
  jpeg_c_coef_controller *v31; // [sp+24h] [bp-3Ch]
  j_compress_ptr v33; // [sp+30h] [bp-30h]
  unsigned int v34; // [sp+34h] [bp-2Ch]
  jpeg_c_coef_controller *v35; // [sp+38h] [bp-28h]
  int v36; // [sp+3Ch] [bp-24h]
  jpeg_component_info *v37; // [sp+40h] [bp-20h]

  v2 = cinfo;
  coef = cinfo->coef;
  v4 = coef[2].compress_data;
  start_pass = coef[2].start_pass;
  if ( (int)start_pass >= (int)v4 )
  {
    v5 = coef + 1;
LABEL_30:
    ++v5->start_pass;
    v21 = v2->coef;
    if ( v2->comps_in_scan <= 1 )
    {
      v24 = v2->cur_comp_info[0];
      p_last_row_height = &v24->last_row_height;
      if ( (char *)v21[1].start_pass < (char *)(v2->total_iMCU_rows - 1) )
        p_last_row_height = &v24->v_samp_factor;
      v22 = *p_last_row_height;
    }
    else
    {
      v22 = 1;
    }
    v21[1].compress_data = 0;
    v21[2].start_pass = 0;
    v21[2].compress_data = (boolean (*)(j_compress_ptr, JSAMPIMAGE))v22;
    return 1;
  }
  else
  {
    v5 = coef + 1;
    v34 = v2->total_iMCU_rows - 1;
    v27 = v2->MCUs_per_row - 1;
    v29 = coef + 3;
    v6 = coef[1].compress_data;
    v33 = v2;
    v35 = coef;
    v31 = coef + 1;
    while ( (unsigned int)v6 > v27 )
    {
LABEL_27:
      v6 = 0;
      coef[1].compress_data = 0;
      start_pass = (void (*)(j_compress_ptr, J_BUF_MODE))((char *)start_pass + 1);
      if ( (int)start_pass >= (int)v4 )
        goto LABEL_30;
    }
    while ( 1 )
    {
      comps_in_scan = v2->comps_in_scan;
      if ( comps_in_scan >= 1 )
      {
        v8 = 0;
        v9 = 0;
        v26 = v6;
        do
        {
          v10 = v2->cur_comp_info[v9];
          p_MCU_width = &v10->MCU_width;
          p_last_col_width = &v10->MCU_width;
          if ( (unsigned int)v6 >= v27 )
            p_last_col_width = &v10->last_col_width;
          if ( v10->MCU_height >= 1 )
          {
            v28 = v9;
            v13 = 0;
            v14 = 8 * (_DWORD)start_pass;
            v36 = *p_last_col_width;
            v37 = v2->cur_comp_info[v9];
            do
            {
              if ( (char *)v5->start_pass >= (char *)v34 && (int)start_pass + v13 >= v10->last_row_height )
              {
                v18 = &v35->start_pass + v8;
                jzero_far(v18[6], *p_MCU_width << 7);
                v10 = v37;
                MCU_width = *p_MCU_width;
                if ( *p_MCU_width >= 1 )
                {
                  v19 = 0;
                  do
                  {
                    v20 = (_WORD *)*((_DWORD *)&v29->start_pass + v8 + v19++);
                    *v20 = *(_WORD *)v18[5];
                    MCU_width = *p_MCU_width;
                  }
                  while ( v19 < *p_MCU_width );
                }
              }
              else
              {
                ((void (__fastcall *)(j_compress_ptr, jpeg_component_info *, JSAMPARRAY))v33->fdct->forward_DCT)(
                  v33,
                  v10,
                  input_buf[v10->component_index]);
                v10 = v37;
                MCU_width = v37->MCU_width;
                if ( MCU_width <= v36 )
                {
                  v5 = v31;
                }
                else
                {
                  jzero_far(*((void **)&v35[3].start_pass + v8 + v36), (MCU_width - v36) << 7);
                  v10 = v37;
                  MCU_width = *p_MCU_width;
                  v5 = v31;
                  if ( v36 < *p_MCU_width )
                  {
                    v16 = v36;
                    do
                    {
                      v17 = (int)v35 + 4 * v8 + 4 * v16++;
                      **(_WORD **)(v17 + 24) = **(_WORD **)(v17 + 20);
                      MCU_width = *p_MCU_width;
                    }
                    while ( v16 < *p_MCU_width );
                  }
                }
              }
              v8 += MCU_width;
              ++v13;
              v14 += 8;
            }
            while ( v13 < v10->MCU_height );
            v2 = v33;
            v6 = v26;
            v9 = v28;
            comps_in_scan = v33->comps_in_scan;
          }
          ++v9;
        }
        while ( v9 < comps_in_scan );
      }
      if ( !((int (__fastcall *)(j_compress_ptr, jpeg_c_coef_controller *))v2->entropy->encode_mcu)(v2, v29) )
        break;
      v6 = (boolean (*)(j_compress_ptr, JSAMPIMAGE))((char *)v6 + 1);
      if ( (unsigned int)v6 > v27 )
      {
        coef = v35;
        v4 = v35[2].compress_data;
        goto LABEL_27;
      }
    }
    v35[1].compress_data = v6;
    v35[2].start_pass = start_pass;
    return 0;
  }
}

//----- (00476696) --------------------------------------------------------
boolean __fastcall compress_first_pass(j_compress_ptr cinfo, JSAMPIMAGE input_buf)
{
  JSAMPARRAY *v2; // r8
  int v3; // r4
  jpeg_component_info *comp_info; // r6
  int v_samp_factor; // r9
  unsigned int h_samp_factor; // r5
  JDIMENSION width_in_blocks; // r11
  int v8; // r10
  void (*start_pass)(j_compress_ptr, J_BUF_MODE); // r1
  int i; // r4
  JBLOCK *v11; // r6
  JCOEF *v12; // r6
  JCOEF v13; // r0
  int v14; // r1
  char *v15; // r6
  int v16; // r8
  unsigned int v17; // r0
  int v18; // r2
  __int16 v19; // r1
  unsigned int v20; // r3
  jpeg_c_coef_controller *coef; // [sp+14h] [bp-3Ch]
  JDIMENSION v24; // [sp+18h] [bp-38h]
  size_t bytestozero; // [sp+20h] [bp-30h]
  j_compress_ptr v26; // [sp+24h] [bp-2Ch]
  int v27; // [sp+28h] [bp-28h]
  int v28; // [sp+2Ch] [bp-24h]
  jpeg_component_info *v29; // [sp+30h] [bp-20h]

  v2 = input_buf;
  if ( cinfo->num_components >= 1 )
  {
    v3 = 0;
    coef = cinfo->coef;
    v24 = cinfo->total_iMCU_rows - 1;
    comp_info = cinfo->comp_info;
    v26 = cinfo;
    do
    {
      v28 = ((int (__fastcall *)(j_compress_ptr))cinfo->mem->access_virt_barray)(cinfo);
      v27 = v3;
      if ( (char *)coef[1].start_pass >= (char *)v24 )
      {
        v_samp_factor = comp_info->height_in_blocks % comp_info->v_samp_factor;
        if ( !v_samp_factor )
          v_samp_factor = comp_info->v_samp_factor;
      }
      else
      {
        v_samp_factor = comp_info->v_samp_factor;
      }
      h_samp_factor = comp_info->h_samp_factor;
      v29 = comp_info;
      width_in_blocks = comp_info->width_in_blocks;
      v8 = width_in_blocks % h_samp_factor;
      if ( (int)(width_in_blocks % h_samp_factor) > 0 )
        v8 = h_samp_factor - width_in_blocks % h_samp_factor;
      start_pass = coef[1].start_pass;
      if ( v_samp_factor >= 1 )
      {
        for ( i = 0; i != v_samp_factor; ++i )
        {
          v11 = *(JBLOCK **)(v28 + 4 * i);
          v26->fdct->forward_DCT(v26, v29, v2[v27], v11, 8 * i, 0, width_in_blocks);
          if ( v8 >= 1 )
          {
            v12 = v11[width_in_blocks];
            jzero_far(v12, v8 << 7);
            v13 = *(v12 - 64);
            v14 = v8;
            do
            {
              *v12 = v13;
              v12 += 64;
              --v14;
            }
            while ( v14 );
          }
        }
        start_pass = coef[1].start_pass;
      }
      if ( start_pass == (void (*)(j_compress_ptr, J_BUF_MODE))v24 )
      {
        for ( bytestozero = v8 + width_in_blocks; v_samp_factor < v29->v_samp_factor; ++v_samp_factor )
        {
          v15 = *(char **)(v28 + 4 * v_samp_factor);
          v16 = *(_DWORD *)(v28 + 4 * v_samp_factor - 4);
          jzero_far(v15, bytestozero << 7);
          if ( h_samp_factor <= bytestozero )
          {
            v17 = 0;
            do
            {
              if ( (int)h_samp_factor >= 1 )
              {
                v18 = 0;
                v19 = *(_WORD *)(v16 + ((h_samp_factor - 1) << 7));
                v20 = h_samp_factor;
                do
                {
                  *(_WORD *)&v15[v18] = v19;
                  v18 += 128;
                  --v20;
                }
                while ( v20 );
              }
              ++v17;
              v15 += 128 * h_samp_factor;
              v16 += h_samp_factor << 7;
            }
            while ( v17 < (v8 + width_in_blocks) / h_samp_factor );
          }
        }
      }
      cinfo = v26;
      comp_info = v29 + 1;
      v2 = input_buf;
      v3 = v27 + 1;
    }
    while ( v27 + 1 < v26->num_components );
  }
  return compress_output(cinfo, v2);
}

//----- (00476824) --------------------------------------------------------
boolean __fastcall compress_output(j_compress_ptr cinfo, JSAMPIMAGE input_buf)
{
  j_compress_ptr v2; // r6
  jpeg_c_coef_controller *coef; // r3
  jpeg_component_info **cur_comp_info; // r10
  int v5; // r5
  jpeg_c_coef_controller *v6; // r8
  JBLOCKARRAY (*access_virt_barray)(j_common_ptr, jvirt_barray_ptr, JDIMENSION, JDIMENSION, boolean); // r4
  boolean (*compress_data)(j_compress_ptr, JSAMPIMAGE); // r0
  void (*start_pass)(j_compress_ptr, J_BUF_MODE); // r8
  JDIMENSION v10; // r4
  jpeg_c_coef_controller *v11; // r9
  int comps_in_scan; // r3
  int v13; // r12
  int v14; // r1
  jpeg_component_info *v15; // r2
  int MCU_height; // r0
  int MCU_width; // r5
  JDIMENSION v18; // r11
  int v19; // r6
  int v20; // lr
  int v21; // r4
  int v22; // r10
  int i; // r3
  jpeg_c_coef_controller *v24; // r0
  int v25; // r1
  jpeg_component_info *v27; // r2
  unsigned int v28; // r1
  int *p_last_row_height; // r6
  jpeg_c_coef_controller *v30; // [sp+4h] [bp-34h]
  _DWORD v32[11]; // [sp+Ch] [bp-2Ch]

  v2 = cinfo;
  coef = cinfo->coef;
  if ( cinfo->comps_in_scan >= 1 )
  {
    cur_comp_info = cinfo->cur_comp_info;
    v5 = 0;
    do
    {
      v6 = coef;
      access_virt_barray = v2->mem->access_virt_barray;
      v2 = cinfo;
      v32[v5] = ((int (__fastcall *)(j_compress_ptr, _DWORD, int))access_virt_barray)(
                  cinfo,
                  *((_DWORD *)&coef[8].start_pass + cur_comp_info[v5]->component_index),
                  (int)coef[1].start_pass * cur_comp_info[v5]->v_samp_factor);
      ++v5;
      coef = v6;
    }
    while ( v5 < cinfo->comps_in_scan );
  }
  compress_data = coef[2].compress_data;
  start_pass = coef[2].start_pass;
  if ( (int)start_pass >= (int)compress_data )
  {
LABEL_22:
    ++coef[1].start_pass;
    v24 = v2->coef;
    if ( v2->comps_in_scan <= 1 )
    {
      v27 = v2->cur_comp_info[0];
      v28 = v2->total_iMCU_rows - 1;
      p_last_row_height = &v27->last_row_height;
      if ( (char *)v24[1].start_pass < (char *)v28 )
        p_last_row_height = &v27->v_samp_factor;
      v25 = *p_last_row_height;
    }
    else
    {
      v25 = 1;
    }
    v24[1].compress_data = 0;
    v24[2].start_pass = 0;
    v24[2].compress_data = (boolean (*)(j_compress_ptr, JSAMPIMAGE))v25;
    return 1;
  }
  else
  {
    v10 = (JDIMENSION)coef[1].compress_data;
    v11 = coef + 3;
    v30 = coef;
    while ( v10 >= v2->MCUs_per_row )
    {
LABEL_21:
      start_pass = (void (*)(j_compress_ptr, J_BUF_MODE))((char *)start_pass + 1);
      v10 = 0;
      coef[1].compress_data = 0;
      if ( (int)start_pass >= (int)compress_data )
        goto LABEL_22;
    }
    while ( 1 )
    {
      comps_in_scan = v2->comps_in_scan;
      if ( comps_in_scan >= 1 )
      {
        v13 = 0;
        v14 = 0;
        do
        {
          v15 = v2->cur_comp_info[v13];
          MCU_height = v15->MCU_height;
          if ( MCU_height >= 1 )
          {
            MCU_width = v15->MCU_width;
            v18 = v10;
            v19 = 0;
            v20 = MCU_width * v10;
            v21 = v32[v13];
            do
            {
              if ( MCU_width >= 1 )
              {
                v22 = *(_DWORD *)(v21 + 4 * ((_DWORD)start_pass + v19)) + (v20 << 7);
                for ( i = 0; i < MCU_width; ++i )
                {
                  *((_DWORD *)&v11->start_pass + v14 + i) = v22;
                  v22 += 128;
                  MCU_width = v15->MCU_width;
                }
                MCU_height = v15->MCU_height;
                v14 += i;
              }
              ++v19;
            }
            while ( v19 < MCU_height );
            v2 = cinfo;
            v10 = v18;
            comps_in_scan = cinfo->comps_in_scan;
          }
          ++v13;
        }
        while ( v13 < comps_in_scan );
      }
      if ( !((int (__fastcall *)(j_compress_ptr, jpeg_c_coef_controller *))v2->entropy->encode_mcu)(v2, v11) )
        break;
      if ( ++v10 >= v2->MCUs_per_row )
      {
        coef = v30;
        compress_data = v30[2].compress_data;
        goto LABEL_21;
      }
    }
    v30[1].compress_data = (boolean (*)(j_compress_ptr, JSAMPIMAGE))v10;
    v30[2].start_pass = start_pass;
    return 0;
  }
}
// 476824: using guessed type _DWORD var_2C[11];

//----- (00476980) --------------------------------------------------------
void __fastcall jinit_color_converter(j_compress_ptr cinfo)
{
  jpeg_color_converter *v2; // r5
  J_COLOR_SPACE jpeg_color_space; // r1
  J_COLOR_SPACE in_color_space; // r0
  J_COLOR_SPACE v5; // r0
  void (*v6)(j_compress_ptr, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int); // r0
  J_COLOR_SPACE v7; // r0

  v2 = (jpeg_color_converter *)cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 12);
  cinfo->cconvert = v2;
  v2->start_pass = null_method;
  switch ( cinfo->in_color_space )
  {
    case JCS_GRAYSCALE:
      if ( cinfo->input_components != 1 )
        goto LABEL_3;
      break;
    case JCS_RGB:
    case JCS_CMYK:
    case JCS_YCCK:
      if ( cinfo->input_components != 4 )
        goto LABEL_3;
      break;
    case JCS_YCbCr:
      if ( cinfo->input_components != 3 )
        goto LABEL_3;
      break;
    default:
      if ( cinfo->input_components <= 0 )
      {
LABEL_3:
        cinfo->err->msg_code = 9;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      break;
  }
  jpeg_color_space = cinfo->jpeg_color_space;
  switch ( jpeg_color_space )
  {
    case JCS_GRAYSCALE:
      if ( cinfo->num_components != 1 )
      {
        cinfo->err->msg_code = 10;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      in_color_space = cinfo->in_color_space;
      switch ( in_color_space )
      {
        case JCS_YCbCr:
          v2->color_convert = (void (*)(j_compress_ptr, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int))grayscale_convert;
          break;
        case JCS_RGB:
          v6 = (void (*)(j_compress_ptr, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int))rgb_gray_convert;
          goto LABEL_42;
        case JCS_GRAYSCALE:
          v2->color_convert = (void (*)(j_compress_ptr, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int))grayscale_convert;
          break;
        default:
          goto LABEL_31;
      }
      return;
    case JCS_RGB:
      if ( cinfo->num_components != 3 )
      {
        cinfo->err->msg_code = 10;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      goto LABEL_31;
    case JCS_YCbCr:
      if ( cinfo->num_components != 3 )
      {
        cinfo->err->msg_code = 10;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      v5 = cinfo->in_color_space;
      if ( v5 == JCS_YCbCr )
      {
        v2->color_convert = (void (*)(j_compress_ptr, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int))null_convert;
        return;
      }
      if ( v5 != JCS_RGB )
        goto LABEL_31;
      v6 = rgb_ycc_convert;
      goto LABEL_42;
    case JCS_CMYK:
      if ( cinfo->num_components != 4 )
      {
        cinfo->err->msg_code = 10;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      if ( cinfo->in_color_space != JCS_CMYK )
        goto LABEL_31;
      v2->color_convert = (void (*)(j_compress_ptr, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int))null_convert;
      return;
    case JCS_YCCK:
      if ( cinfo->num_components != 4 )
      {
        cinfo->err->msg_code = 10;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      v7 = cinfo->in_color_space;
      if ( v7 == JCS_YCCK )
      {
        v2->color_convert = (void (*)(j_compress_ptr, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int))null_convert;
      }
      else if ( v7 == JCS_CMYK )
      {
        v6 = cmyk_ycck_convert;
LABEL_42:
        v2->start_pass = rgb_ycc_start;
        v2->color_convert = v6;
      }
      else
      {
LABEL_31:
        cinfo->err->msg_code = 27;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      return;
    default:
      if ( jpeg_color_space != cinfo->in_color_space || cinfo->num_components != cinfo->input_components )
      {
        cinfo->err->msg_code = 27;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      v2->color_convert = (void (*)(j_compress_ptr, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int))null_convert;
      return;
  }
}

//----- (00476B3A) --------------------------------------------------------
void __fastcall grayscale_convert(
        j_compress_ptr cinfo,
        JSAMPARRAY input_buf,
        JSAMPIMAGE output_buf,
        JDIMENSION output_row,
        int a5)
{
  int v5; // r12
  JDIMENSION image_width; // lr
  int input_components; // r9
  JDIMENSION v8; // r5
  JSAMPARRAY v9; // r4
  int v10; // r8
  JSAMPROW v11; // r5
  JSAMPROW v12; // r6
  JDIMENSION v13; // r4
  JSAMPLE v14; // r0

  v5 = a5;
  if ( a5 >= 1 )
  {
    image_width = cinfo->image_width;
    input_components = cinfo->input_components;
    do
    {
      v8 = output_row;
      v9 = input_buf;
      v10 = v5;
      ++output_row;
      ++input_buf;
      --v5;
      if ( image_width )
      {
        v11 = (*output_buf)[v8];
        v12 = *v9;
        v13 = image_width;
        do
        {
          v14 = *v12;
          v12 += input_components;
          *v11++ = v14;
          --v13;
        }
        while ( v13 );
      }
    }
    while ( v10 >= 2 );
  }
}

//----- (00476B90) --------------------------------------------------------
void __fastcall rgb_ycc_start(j_compress_ptr cinfo)
{
  jpeg_color_converter *cconvert; // r4
  int v2; // r0
  int32x4_t v3; // q11
  int32x4_t v4; // q12
  int32x4_t v5; // q13
  int32x4_t v6; // q14
  int32x4_t v7; // q15
  int32x4_t v8; // q8
  int v9; // r1
  int32x4_t v10; // q0
  int32x4_t v11; // q5
  int32x4_t v12; // q9
  int32x4_t *v13; // r2
  int32x4_t *v14; // r3
  int32x4_t v15; // q2
  int32x4_t v16; // q1
  int32x4_t v17; // q9
  int32x4_t v18; // q10

  cconvert = cinfo->cconvert;
  v2 = ((int (*)(void))cinfo->mem->alloc_small)();
  cconvert[1].start_pass = (void (*)(j_compress_ptr))v2;
  v3.n128_u64[0] = 0xFFFFD4CDFFFFD4CDLL;
  v3.n128_u64[1] = 0xFFFFD4CDFFFFD4CDLL;
  v4.n128_u64[0] = 0x807FFF00807FFFLL;
  v4.n128_u64[1] = 0x807FFF00807FFFLL;
  v5.n128_u64[0] = 0xFFFF94D1FFFF94D1LL;
  v5.n128_u64[1] = 0xFFFF94D1FFFF94D1LL;
  v6.n128_u64[0] = 0x1D2F00001D2FLL;
  v6.n128_u64[1] = 0x1D2F00001D2FLL;
  v7.n128_u64[0] = 0xFFFFEB2FFFFFEB2FLL;
  v7.n128_u64[1] = 0xFFFFEB2FFFFFEB2FLL;
  v8.n128_u64[0] = 0x100000000LL;
  v8.n128_u64[1] = 0x300000002LL;
  v9 = 0;
  v10.n128_u64[0] = 0xFFFFAB33FFFFAB33LL;
  v10.n128_u64[1] = 0xFFFFAB33FFFFAB33LL;
  do
  {
    v11.n128_u64[0] = 0x800000008000LL;
    v11.n128_u64[1] = 0x800000008000LL;
    v12.n128_u64[0] = 0x964600009646LL;
    v12.n128_u64[1] = 0x964600009646LL;
    v13 = (int32x4_t *)(v2 + v9);
    v14 = (int32x4_t *)(v2 + v9 + 5120);
    v9 += 16;
    v15 = vmulq_s32(v8, v12);
    v12.n128_u64[0] = 0x4C8B00004C8BLL;
    v12.n128_u64[1] = 0x4C8B00004C8BLL;
    *v14 = vaddq_s32(vshlq_n_s32(v8, 0xFu), v4);
    v13[64] = v15;
    *v13 = vmulq_s32(v8, v12);
    v16 = vmulq_s32(v8, v5);
    v13[128] = vmlaq_s32(v11, v8, v6);
    v17 = vmulq_s32(v8, v7);
    v13[192] = vmulq_s32(v8, v3);
    v18.n128_u64[0] = 0x400000004LL;
    v18.n128_u64[1] = 0x400000004LL;
    v13[256] = vmulq_s32(v8, v10);
    v8 = vaddq_s32(v8, v18);
    v13[384] = v16;
    v13[448] = v17;
  }
  while ( v9 != 1024 );
}

//----- (00476D20) --------------------------------------------------------
void __fastcall rgb_gray_convert(
        j_compress_ptr cinfo,
        JSAMPARRAY input_buf,
        JSAMPIMAGE output_buf,
        JDIMENSION output_row,
        int a5)
{
  int v5; // r12
  void (*start_pass)(j_compress_ptr); // r9
  JDIMENSION v7; // r5
  JSAMPARRAY v8; // r4
  int v9; // r8
  JSAMPROW v10; // r5
  JSAMPROW v11; // r6
  JDIMENSION v12; // r4
  int v13; // r0
  int v14; // r10
  int v15; // r11
  JDIMENSION image_width; // [sp+4h] [bp-20h]

  v5 = a5;
  if ( a5 >= 1 )
  {
    image_width = cinfo->image_width;
    start_pass = cinfo->cconvert[1].start_pass;
    do
    {
      v7 = output_row;
      v8 = input_buf;
      v9 = v5;
      ++output_row;
      ++input_buf;
      --v5;
      if ( image_width )
      {
        v10 = (*output_buf)[v7];
        v11 = *v8;
        v12 = image_width;
        do
        {
          v13 = *v11;
          --v12;
          v14 = v11[1];
          v15 = v11[2];
          v11 += 4;
          *v10++ = (unsigned int)(*((_DWORD *)start_pass + (v14 | 0x100))
                                + *((_DWORD *)start_pass + v13)
                                + *((_DWORD *)start_pass + (v15 | 0x200))) >> 16;
        }
        while ( v12 );
      }
    }
    while ( v9 >= 2 );
  }
}

//----- (00476DA2) --------------------------------------------------------
void __fastcall null_convert(
        j_compress_ptr cinfo,
        JSAMPARRAY input_buf,
        JSAMPIMAGE output_buf,
        JDIMENSION output_row,
        int a5)
{
  int v5; // r12
  JDIMENSION image_width; // lr
  int num_components; // r9
  int i; // r10
  JSAMPROW v9; // r4
  JSAMPROW v10; // r6
  JDIMENSION v11; // r0
  JSAMPLE v12; // r5

  v5 = a5;
  if ( a5 >= 1 )
  {
    image_width = cinfo->image_width;
    num_components = cinfo->num_components;
    do
    {
      if ( num_components >= 1 )
      {
        for ( i = 0; i != num_components; ++i )
        {
          if ( image_width )
          {
            v9 = *input_buf;
            v10 = output_buf[i][output_row];
            v11 = image_width;
            do
            {
              v12 = v9[i];
              v9 += num_components;
              *v10++ = v12;
              --v11;
            }
            while ( v11 );
          }
        }
      }
      ++output_row;
      ++input_buf;
    }
    while ( v5-- > 1 );
  }
}

//----- (00476E04) --------------------------------------------------------
void __fastcall rgb_ycc_convert(
        j_compress_ptr cinfo,
        JSAMPARRAY input_buf,
        JSAMPIMAGE output_buf,
        JDIMENSION output_row,
        int num_rows)
{
  int v5; // r2
  void (*start_pass)(j_compress_ptr); // r0
  int v7; // r8
  JSAMPROW v8; // r10
  JSAMPROW v9; // r11
  JSAMPROW v10; // r9
  JSAMPROW v11; // r5
  JDIMENSION v12; // r6
  int v13; // lr
  int v14; // r4
  int v15; // r12
  JDIMENSION image_width; // [sp+4h] [bp-2Ch]

  v5 = num_rows;
  if ( num_rows >= 1 )
  {
    image_width = cinfo->image_width;
    start_pass = cinfo->cconvert[1].start_pass;
    do
    {
      v7 = v5;
      if ( image_width )
      {
        v8 = output_buf[1][output_row];
        v9 = (*output_buf)[output_row];
        v10 = output_buf[2][output_row];
        v11 = *input_buf;
        v12 = image_width;
        do
        {
          v13 = v11[1];
          --v12;
          v14 = *v11;
          v15 = v11[2];
          v11 += 4;
          *v9++ = (unsigned int)(*((_DWORD *)start_pass + v14)
                               + *((_DWORD *)start_pass + (v13 | 0x100))
                               + *((_DWORD *)start_pass + (v15 | 0x200))) >> 16;
          *v8++ = (unsigned int)(*((_DWORD *)start_pass + (v14 | 0x300))
                               + *((_DWORD *)start_pass + (v13 | 0x400))
                               + *((_DWORD *)start_pass + (v15 | 0x500))) >> 16;
          *v10++ = (unsigned int)(*((_DWORD *)start_pass + (v14 | 0x500))
                                + *((_DWORD *)start_pass + (v13 | 0x600))
                                + *((_DWORD *)start_pass + (v15 | 0x700))) >> 16;
        }
        while ( v12 );
      }
      ++output_row;
      --v5;
      ++input_buf;
    }
    while ( v7 >= 2 );
  }
}

//----- (00476EE0) --------------------------------------------------------
void __fastcall cmyk_ycck_convert(
        j_compress_ptr cinfo,
        JSAMPARRAY input_buf,
        JSAMPIMAGE output_buf,
        JDIMENSION output_row,
        int num_rows)
{
  int v5; // r2
  void (*start_pass)(j_compress_ptr); // r0
  JSAMPROW v7; // r9
  JSAMPROW v8; // r8
  JSAMPROW v9; // r10
  JSAMPROW v10; // r11
  JSAMPROW v11; // r6
  JDIMENSION v12; // lr
  int v13; // r12
  int v14; // r4
  int v15; // r2
  JDIMENSION image_width; // [sp+4h] [bp-30h]
  int v18; // [sp+8h] [bp-2Ch]
  int v19; // [sp+Ch] [bp-28h]

  v5 = num_rows;
  if ( num_rows >= 1 )
  {
    image_width = cinfo->image_width;
    start_pass = cinfo->cconvert[1].start_pass;
    do
    {
      v19 = v5 - 1;
      v18 = v5;
      if ( image_width )
      {
        v7 = output_buf[3][output_row];
        v8 = (*output_buf)[output_row];
        v9 = output_buf[2][output_row];
        v10 = output_buf[1][output_row];
        v11 = *input_buf;
        v12 = image_width;
        do
        {
          v13 = v11[1];
          --v12;
          v14 = v11[2];
          v15 = *v11 ^ 0xFF;
          *v7++ = v11[3];
          v11 += 4;
          *v8++ = (unsigned int)(*((_DWORD *)start_pass + (v13 ^ 0xFF | 0x100))
                               + *((_DWORD *)start_pass + v15)
                               + *((_DWORD *)start_pass + (v14 ^ 0xFF | 0x200))) >> 16;
          *v10++ = (unsigned int)(*((_DWORD *)start_pass + (v15 | 0x300))
                                + *((_DWORD *)start_pass + (v13 ^ 0xFF | 0x400))
                                + *((_DWORD *)start_pass + (v14 ^ 0xFF | 0x500))) >> 16;
          *v9++ = (unsigned int)(*((_DWORD *)start_pass + (v13 ^ 0xFF | 0x600))
                               + *((_DWORD *)start_pass + (v15 | 0x500))
                               + *((_DWORD *)start_pass + (v14 ^ 0xFF | 0x700))) >> 16;
        }
        while ( v12 );
      }
      ++output_row;
      v5 = v19;
      ++input_buf;
    }
    while ( v18 >= 2 );
  }
}

//----- (00476FD8) --------------------------------------------------------
void __fastcall jinit_forward_dct(j_compress_ptr cinfo)
{
  int v2; // r4

  v2 = cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 48);
  cinfo->fdct = (jpeg_forward_dct *)v2;
  *(_DWORD *)v2 = start_pass_fdctmgr;
  if ( cinfo->dct_method == JDCT_FLOAT )
  {
    *(_DWORD *)(v2 + 4) = forward_DCT_float;
    *(_DWORD *)(v2 + 28) = jpeg_fdct_float;
  }
  else
  {
    cinfo->err->msg_code = 48;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  *(_QWORD *)(v2 + 32) = 0LL;
  *(_QWORD *)(v2 + 40) = 0LL;
  *(_QWORD *)(v2 + 12) = 0LL;
  *(_QWORD *)(v2 + 20) = 0LL;
}

//----- (00477048) --------------------------------------------------------
void __fastcall start_pass_fdctmgr(j_compress_ptr cinfo)
{
  int v2; // r10
  jpeg_component_info *comp_info; // r5
  unsigned int quant_tbl_no; // r9
  JQUANT_TBL **v5; // r8
  JQUANT_TBL *v6; // r11
  jpeg_component_info *v7; // r8
  void (**v8)(j_compress_ptr); // r5
  int v9; // r0
  int *v10; // r5
  int v11; // t1
  float *v12; // r0
  UINT16 *v13; // r1
  int v14; // r2
  double v15; // d17
  unsigned __int16 *v16; // r3
  float v17; // s0
  float v18; // s0
  float v19; // s0
  float v20; // s0
  float v21; // s0
  float v22; // s0
  float v23; // s0
  unsigned int v24; // r3
  float v25; // s0
  jpeg_forward_dct *fdct; // [sp+4h] [bp-64h]

  if ( cinfo->num_components >= 1 )
  {
    v2 = 0;
    fdct = cinfo->fdct;
    comp_info = cinfo->comp_info;
    do
    {
      quant_tbl_no = comp_info->quant_tbl_no;
      v5 = &cinfo->quant_tbl_ptrs[quant_tbl_no];
      if ( quant_tbl_no > 3 || (v6 = *v5) == 0 )
      {
        cinfo->err->msg_code = 52;
        cinfo->err->msg_parm.i[0] = quant_tbl_no;
        cinfo->err->error_exit((j_common_ptr)cinfo);
        v6 = *v5;
      }
      v7 = comp_info;
      if ( cinfo->dct_method == JDCT_FLOAT )
      {
        v8 = &fdct->start_pass + quant_tbl_no;
        v11 = (int)v8[8];
        v10 = (int *)(v8 + 8);
        v9 = v11;
        if ( !v11 )
        {
          v9 = cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 256);
          *v10 = v9;
        }
        v12 = (float *)(v9 + 28);
        v13 = &v6->quantval[7];
        v14 = 0;
        do
        {
          v15 = start_pass_fdctmgr(jpeg_compress_struct *)::aanscalefactor[v14];
          v16 = &v6->quantval[v14 * 8];
          ++v14;
          v17 = 1.0 / (v15 * (double)*(v13 - 7) * 8.0);
          *(v12 - 7) = v17;
          v18 = 1.0 / (v15 * (double)v16[1] * 1.38703985 * 8.0);
          *(v12 - 6) = v18;
          v19 = 1.0 / (v15 * (double)v16[2] * 1.30656296 * 8.0);
          *(v12 - 5) = v19;
          v20 = 1.0 / (v15 * (double)v16[3] * 1.1758756 * 8.0);
          *(v12 - 4) = v20;
          v21 = 1.0 / (v15 * (double)v16[4] * 8.0);
          *(v12 - 3) = v21;
          v22 = 1.0 / (v15 * (double)v16[5] * 0.785694958 * 8.0);
          *(v12 - 2) = v22;
          v23 = 1.0 / (v15 * (double)v16[6] * 0.5411961 * 8.0);
          *(v12 - 1) = v23;
          v24 = *v13;
          v13 += 8;
          v25 = 1.0 / (v15 * (double)v24 * 0.275899379 * 8.0);
          *v12 = v25;
          v12 += 8;
        }
        while ( v14 != 8 );
      }
      else
      {
        cinfo->err->msg_code = 48;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      ++v2;
      comp_info = v7 + 1;
    }
    while ( v2 < cinfo->num_components );
  }
}

//----- (0047727C) --------------------------------------------------------
void __fastcall forward_DCT_float(
        j_compress_ptr cinfo,
        jpeg_component_info *compptr,
        JSAMPARRAY sample_data,
        JBLOCKROW coef_blocks,
        JDIMENSION start_row,
        JDIMENSION start_col,
        JDIMENSION num_blocks)
{
  int v8; // r8
  jpeg_forward_dct *fdct; // r0
  void (*forward_DCT)(j_compress_ptr, jpeg_component_info *, JSAMPARRAY, JBLOCKROW, JDIMENSION, JDIMENSION, JDIMENSION); // r9
  int v12; // r4
  JSAMPROW *v13; // r5
  int v14; // r0
  float *v15; // r1
  JSAMPROW v16; // r2
  int v17; // r3
  unsigned __int8 *v18; // r2
  int v19; // r0
  JBLOCKROW v20; // r1
  float v21; // s0
  float *v22; // r2
  _BYTE v23[296]; // [sp+0h] [bp-128h] BYREF

  if ( num_blocks )
  {
    v8 = 0;
    fdct = cinfo->fdct;
    forward_DCT = fdct[3].forward_DCT;
    v12 = *((_DWORD *)&fdct[4].start_pass + compptr->quant_tbl_no);
    v13 = &sample_data[start_row];
    do
    {
      v14 = 0;
      v15 = (float *)v23;
      do
      {
        v16 = v13[v14++];
        v17 = v16[start_col];
        v18 = &v16[start_col];
        *v15 = (float)(v17 - 128);
        v15[1] = (float)(v18[1] - 128);
        v15[2] = (float)(v18[2] - 128);
        v15[3] = (float)(v18[3] - 128);
        v15[4] = (float)(v18[4] - 128);
        v15[5] = (float)(v18[5] - 128);
        v15[6] = (float)(v18[6] - 128);
        v15[7] = (float)(v18[7] - 128);
        v15 += 8;
      }
      while ( v14 != 8 );
      ((void (__fastcall *)(_BYTE *, float *))forward_DCT)(v23, v15);
      v19 = 0;
      v20 = coef_blocks;
      do
      {
        v21 = *(float *)(v12 + v19);
        v22 = (float *)&v23[v19];
        v19 += 4;
        *(_WORD *)v20 = (int)(float)((float)(*v22 * v21) + 16384.0) - 0x4000;
        v20 = (JBLOCKROW)((char *)v20 + 2);
      }
      while ( v19 != 256 );
      ++v8;
      ++coef_blocks;
      start_col += 8;
    }
    while ( v8 != num_blocks );
  }
}

//----- (004773B4) --------------------------------------------------------
void __fastcall jpeg_make_c_derived_tbl(j_compress_ptr cinfo, boolean isDC, int tblno, c_derived_tbl **pdtbl)
{
  int v7; // r4
  jpeg_error_mgr **v8; // r0
  int *v9; // r1
  int v10; // r10
  c_derived_tbl *v11; // r0
  int v12; // r5
  int v13; // r11
  size_t v14; // r6
  int v15; // r4
  int v16; // r9
  int v17; // r6
  int v18; // r10
  int v19; // r11
  c_derived_tbl *v20; // r10
  unsigned int v21; // r8
  unsigned __int8 *v22; // r6
  unsigned int *v23; // r11
  char *v24; // r5
  unsigned int v25; // r4
  unsigned __int8 *v26; // r10
  unsigned int v27; // t1
  int v28; // [sp+0h] [bp-538h]
  c_derived_tbl *v29; // [sp+4h] [bp-534h]
  j_compress_ptr v30; // [sp+8h] [bp-530h]
  int v31; // [sp+Ch] [bp-52Ch]
  _DWORD v32[257]; // [sp+10h] [bp-528h] BYREF
  char v33[257]; // [sp+417h] [bp-121h] BYREF

  v7 = isDC;
  if ( (unsigned int)tblno >= 4 )
  {
    cinfo->err->msg_code = 50;
    cinfo->err->msg_parm.i[0] = tblno;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v8 = &cinfo->err + tblno;
  v9 = (int *)(v8 + 26);
  if ( v7 )
    v9 = (int *)(v8 + 22);
  v10 = *v9;
  if ( !*v9 )
  {
    cinfo->err->msg_code = 50;
    cinfo->err->msg_parm.i[0] = tblno;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v11 = *pdtbl;
  v28 = v7;
  if ( !*pdtbl )
  {
    v11 = (c_derived_tbl *)cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 1280);
    *pdtbl = v11;
  }
  v12 = 1;
  v13 = 0;
  v29 = v11;
  do
  {
    v14 = *(unsigned __int8 *)(v10 + v12);
    if ( (int)(v13 + v14) > 256 )
    {
      cinfo->err->msg_code = 8;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    if ( v14 )
    {
      memset(&v33[v13], (unsigned __int8)v12, v14);
      v13 += v14;
    }
    ++v12;
  }
  while ( v12 != 17 );
  v33[v13] = 0;
  v15 = v10;
  v30 = cinfo;
  v16 = (unsigned __int8)v33[0];
  v31 = v13;
  if ( v33[0] )
  {
    v17 = 0;
    v18 = 0;
    v19 = (unsigned __int8)v33[0];
    do
    {
      if ( v19 == (unsigned __int8)v16 )
      {
        do
        {
          v32[v18] = v17++;
          v16 = (unsigned __int8)v33[++v18];
        }
        while ( v19 == v16 );
      }
      if ( v17 >= 1 << v19 )
      {
        v30->err->msg_code = 8;
        v30->err->error_exit((j_common_ptr)v30);
      }
      ++v19;
      v17 *= 2;
    }
    while ( v16 << 24 );
  }
  v20 = v29;
  memset(v29->ehufsi, 0, sizeof(v29->ehufsi));
  v21 = 255;
  if ( v28 )
    v21 = 15;
  if ( v31 >= 1 )
  {
    v22 = (unsigned __int8 *)(v15 + 17);
    v23 = v32;
    v24 = v33;
    do
    {
      v25 = *v22;
      v26 = &v20->ehufsi[v25];
      if ( v21 < v25 || *v26 )
      {
        v30->err->msg_code = 8;
        v30->err->error_exit((j_common_ptr)v30);
      }
      ++v22;
      v27 = *v23++;
      v29->ehufco[v25] = v27;
      LOBYTE(v27) = *v24++;
      *v26 = v27;
      v20 = v29;
      --v31;
    }
    while ( v31 );
  }
}
// 4773B4: using guessed type char var_121[257];
// 4773B4: using guessed type _DWORD var_528[257];

//----- (00477588) --------------------------------------------------------
void __fastcall jpeg_gen_optimal_table(j_compress_ptr cinfo, JHUFF_TBL *htbl, int *freq)
{
  int v4; // r0
  int v5; // r1
  int v6; // r2
  int v7; // lr
  int v8; // r0
  int v9; // r2
  int v10; // r5
  int v11; // r4
  int v12; // r6
  int i; // r0
  int v14; // r6
  int v15; // r4
  int v16; // r3
  int v17; // r6
  int v18; // r11
  int v19; // r1
  UINT8 v20; // r6
  int v21; // r2
  char *v22; // r3
  char v24; // r6
  bool v25; // cc
  UINT8 *v26; // r0
  char v27; // r1
  int v28; // t1
  __int64 v29; // d17
  int v30; // r0
  int j; // r1
  int k; // r2
  _DWORD v35[258]; // [sp+8h] [bp-858h] BYREF
  char v36[1032]; // [sp+410h] [bp-450h] BYREF
  __int64 v37; // [sp+818h] [bp-48h]
  UINT8 bits[33]; // [sp+820h] [bp-40h] BYREF

  v37 = 0LL;
  memset(bits, 0, 25);
  memset(v36, 0, 0x404u);
  memset(v35, 255, 0x404u);
  freq[256] = 1;
  while ( 1 )
  {
    v7 = 1000000000;
    v5 = -1;
    v8 = 0;
    v9 = 1000000000;
    do
    {
      v10 = freq[v8];
      v11 = 0;
      v12 = 0;
      if ( v10 > v9 )
        v11 = 1;
      if ( !v10 )
        v12 = 1;
      if ( !(v12 | v11) )
      {
        v9 = freq[v8];
        v5 = v8;
      }
      ++v8;
    }
    while ( v8 != 257 );
    v6 = -1;
    for ( i = 0; i != 257; ++i )
    {
      v14 = freq[i];
      v15 = 0;
      v16 = 0;
      if ( v14 > v7 )
        v15 = 1;
      if ( !v14 )
        v16 = 1;
      if ( !(v16 | v15 | (v5 == i)) )
      {
        v7 = freq[i];
        v6 = i;
      }
    }
    if ( v6 <= -1 )
      break;
    freq[v5] += freq[v6];
    freq[v6] = 0;
    do
    {
      v4 = v5;
      ++*(_DWORD *)&v36[4 * v5];
      v5 = v35[v5];
    }
    while ( v5 > -1 );
    v35[v4] = v6;
    do
    {
      ++*(_DWORD *)&v36[4 * v6];
      v6 = v35[v6];
    }
    while ( v6 > -1 );
  }
  v17 = -1028;
  do
  {
    v18 = *(_DWORD *)&v36[v17 + 1028];
    if ( v18 )
    {
      if ( v18 >= 33 )
      {
        cinfo->err->msg_code = 39;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      ++bits[v18 - 8];
    }
    v17 += 4;
  }
  while ( v17 );
  v19 = 32;
  do
  {
    v20 = bits[v19 - 8];
    if ( v20 )
    {
      v21 = v19 - 1;
      do
      {
        v22 = &v36[v19 + 1031];
        while ( !*--v22 )
          ;
        bits[v19 - 8] = v20 - 2;
        ++bits[v21 - 8];
        v24 = *v22 - 1;
        v22[1] += 2;
        *v22 = v24;
        v20 = bits[v19 - 8];
      }
      while ( v20 );
    }
    else
    {
      v21 = v19 - 1;
    }
    v25 = v19 <= 17;
    v19 = v21;
  }
  while ( !v25 );
  v26 = &bits[8];
  do
  {
    v28 = *v26--;
    v27 = v28;
  }
  while ( !v28 );
  v26[1] = v27 - 1;
  v29 = *(_QWORD *)bits;
  *(_QWORD *)htbl->bits = v37;
  *(_QWORD *)&htbl->bits[8] = v29;
  htbl->bits[16] = bits[8];
  v30 = 0;
  for ( j = 1; j != 33; ++j )
  {
    for ( k = 0; k != 256; ++k )
    {
      if ( *(_DWORD *)&v36[4 * k] == j )
        htbl->huffval[v30++] = k;
    }
  }
  htbl->sent_table = 0;
}
// 477588: using guessed type _QWORD var_48;
// 477588: using guessed type _DWORD var_858[258];

//----- (00477798) --------------------------------------------------------
void __fastcall jinit_huff_encoder(j_compress_ptr cinfo)
{
  int v2; // r0
  _QWORD *v3; // r1

  v2 = cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 108);
  cinfo->entropy = (jpeg_entropy_encoder *)v2;
  *(_DWORD *)v2 = start_pass_huff;
  *(_DWORD *)(v2 + 76) = 0;
  *(_DWORD *)(v2 + 80) = 0;
  *(_DWORD *)(v2 + 84) = 0;
  *(_DWORD *)(v2 + 88) = 0;
  *(_QWORD *)(v2 + 92) = 0LL;
  *(_QWORD *)(v2 + 100) = 0LL;
  v3 = (_QWORD *)(v2 + 44);
  v2 += 60;
  *v3 = 0LL;
  v3[1] = 0LL;
  *(_QWORD *)v2 = 0LL;
  *(_QWORD *)(v2 + 8) = 0LL;
}

//----- (004777E0) --------------------------------------------------------
void __fastcall start_pass_huff(j_compress_ptr cinfo, boolean gather_statistics)
{
  int v3; // r8
  jpeg_entropy_encoder *entropy; // r9
  void (__fastcall *v5)(j_compress_ptr); // r2
  boolean (__fastcall *v6)(j_compress_ptr, JBLOCKROW *); // r3
  int v7; // r11
  __int64 v8; // kr00_8
  void (**v9)(j_compress_ptr, boolean); // r5
  void (*v10)(j_compress_ptr, boolean); // r0
  void (**v11)(j_compress_ptr, boolean); // r5
  void (*v12)(j_compress_ptr, boolean); // t1
  void (**v13)(j_compress_ptr, boolean); // r5
  void (*v14)(j_compress_ptr, boolean); // r0
  void (**v15)(j_compress_ptr, boolean); // r5
  void (*v16)(j_compress_ptr, boolean); // t1

  v3 = gather_statistics;
  entropy = cinfo->entropy;
  v5 = finish_pass_gather;
  v6 = encode_mcu_gather;
  if ( !gather_statistics )
  {
    v5 = finish_pass_huff;
    v6 = encode_mcu_huff;
  }
  entropy->encode_mcu = v6;
  entropy->finish_pass = v5;
  if ( cinfo->comps_in_scan >= 1 )
  {
    v7 = 0;
    do
    {
      v8 = *(_QWORD *)&cinfo->cur_comp_info[v7]->dc_tbl_no;
      if ( v3 )
      {
        if ( (unsigned int)v8 >= 4 )
        {
          cinfo->err->msg_code = 50;
          cinfo->err->msg_parm.i[0] = v8;
          cinfo->err->error_exit((j_common_ptr)cinfo);
        }
        if ( HIDWORD(v8) >= 4 )
        {
          cinfo->err->msg_code = 50;
          cinfo->err->msg_parm.i[0] = HIDWORD(v8);
          cinfo->err->error_exit((j_common_ptr)cinfo);
        }
        v9 = &entropy->start_pass + v8;
        v12 = v9[19];
        v11 = v9 + 19;
        v10 = v12;
        if ( !v12 )
        {
          v10 = (void (*)(j_compress_ptr, boolean))cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 1028);
          *v11 = v10;
        }
        memset(v10, 0, 0x404u);
        v13 = &entropy->start_pass + HIDWORD(v8);
        v16 = v13[23];
        v15 = v13 + 23;
        v14 = v16;
        if ( !v16 )
        {
          v14 = (void (*)(j_compress_ptr, boolean))cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 1028);
          *v15 = v14;
        }
        memset(v14, 0, 0x404u);
      }
      else
      {
        jpeg_make_c_derived_tbl(cinfo, 1u, v8, (c_derived_tbl **)&entropy[3].finish_pass + v8);
        jpeg_make_c_derived_tbl(cinfo, 0, SHIDWORD(v8), (c_derived_tbl **)&entropy[5].start_pass + HIDWORD(v8));
      }
      *((_DWORD *)&entropy[1].finish_pass + v7++) = 0;
    }
    while ( v7 < cinfo->comps_in_scan );
  }
  entropy[1].start_pass = 0;
  entropy[1].encode_mcu = 0;
  entropy[3].start_pass = (void (*)(j_compress_ptr, boolean))cinfo->restart_interval;
  entropy[3].encode_mcu = 0;
}

//----- (00477900) --------------------------------------------------------
boolean __fastcall encode_mcu_gather(j_compress_ptr cinfo, JBLOCKROW *MCU_data)
{
  j_compress_ptr v2; // r3
  unsigned int restart_interval; // r0
  jpeg_entropy_encoder *entropy; // r12
  unsigned int start_pass; // r2
  int v6; // r2
  int v7; // r5
  JBLOCKROW v8; // r9
  int v9; // r0
  void (**v10)(j_compress_ptr, boolean); // r11
  _DWORD *v11; // r11
  void (*v12)(j_compress_ptr, boolean); // t1
  __int64 v13; // kr00_8
  int v14; // r0
  _DWORD *v15; // r8
  int v16; // r10
  int v17; // r1
  int v18; // r5
  signed int v19; // r11
  int i; // r10
  int v21; // r0
  int v22; // r2
  unsigned int v23; // r2
  int v24; // r5
  _DWORD *v25; // r0
  jpeg_entropy_encoder *v27; // [sp+0h] [bp-30h]
  JBLOCKROW *v28; // [sp+4h] [bp-2Ch]
  _DWORD *v29; // [sp+8h] [bp-28h]
  int v30; // [sp+Ch] [bp-24h]
  jpeg_compress_struct *v31; // [sp+10h] [bp-20h]

  v2 = cinfo;
  restart_interval = cinfo->restart_interval;
  entropy = v2->entropy;
  if ( restart_interval )
  {
    start_pass = (unsigned int)entropy[3].start_pass;
    if ( !start_pass )
    {
      if ( v2->comps_in_scan >= 1 )
      {
        v6 = 0;
        do
          *((_DWORD *)&entropy[1].finish_pass + v6++) = 0;
        while ( v6 < v2->comps_in_scan );
        restart_interval = v2->restart_interval;
      }
      start_pass = restart_interval;
      entropy[3].start_pass = (void (*)(j_compress_ptr, boolean))restart_interval;
    }
    entropy[3].start_pass = (void (*)(j_compress_ptr, boolean))(start_pass - 1);
  }
  if ( v2->blocks_in_MCU >= 1 )
  {
    v7 = 0;
    v31 = v2;
    v27 = entropy;
    v28 = MCU_data;
    do
    {
      v8 = MCU_data[v7];
      v9 = v2->MCU_membership[v7];
      v10 = &entropy->start_pass + v9;
      v12 = v10[5];
      v11 = v10 + 5;
      v13 = *(_QWORD *)&v2->cur_comp_info[v9]->dc_tbl_no;
      v14 = *(_WORD *)v8 - (_DWORD)v12;
      if ( v14 < 0 )
        v14 = -v14;
      v15 = (_DWORD *)*((_DWORD *)&entropy[7].finish_pass + HIDWORD(v13));
      v16 = *((_DWORD *)&entropy[6].encode_mcu + v13);
      v29 = v11;
      v30 = v7;
      if ( v14 )
      {
        v17 = -1;
        do
        {
          ++v17;
          v14 >>= 1;
        }
        while ( v14 );
        v18 = v17 + 1;
        if ( v17 >= 11 )
        {
          v2->err->msg_code = 6;
          v2->err->error_exit((j_common_ptr)v2);
          v2 = v31;
        }
      }
      else
      {
        v18 = 0;
      }
      v19 = 0;
      ++*(_DWORD *)(v16 + 4 * v18);
      for ( i = 1; i != 64; ++i )
      {
        v21 = (*v8)[jpeg_natural_order[i]];
        if ( (*v8)[jpeg_natural_order[i]] )
        {
          if ( v19 >= 16 )
          {
            v22 = ~v19;
            if ( ~v19 < -32 || v19 == 31 )
              v22 = -32;
            v23 = v22 + v19 + 16;
            v15[240] += (v23 >> 4) + 1;
            v19 = v19 - 16 - (v23 & 0xFFFFFFF0);
          }
          v24 = 0;
          if ( v21 < 0 )
            v21 = -v21;
          do
          {
            ++v24;
            v21 >>= 1;
          }
          while ( v21 );
          if ( v24 >= 11 )
          {
            v2->err->msg_code = 6;
            v2->err->error_exit((j_common_ptr)v2);
            v2 = v31;
          }
          v25 = &v15[16 * v19];
          v19 = 0;
          ++v25[v24];
        }
        else
        {
          ++v19;
        }
      }
      if ( v19 >= 1 )
        ++*v15;
      MCU_data = v28;
      v7 = v30 + 1;
      *v29 = (*v28[v30])[0];
      entropy = v27;
    }
    while ( v30 + 1 < v2->blocks_in_MCU );
  }
  return 1;
}

//----- (00477AAC) --------------------------------------------------------
void __fastcall finish_pass_gather(j_compress_ptr cinfo)
{
  jpeg_entropy_encoder *entropy; // r11
  int *v3; // r4
  int v4; // r6
  __int64 v5; // kr00_8
  jpeg_error_mgr **v6; // r8
  JHUFF_TBL *v7; // r1
  JHUFF_TBL **v8; // r8
  JHUFF_TBL *v9; // t1
  int *v10; // r8
  jpeg_error_mgr **v11; // r4
  JHUFF_TBL *v12; // r1
  JHUFF_TBL **v13; // r4
  JHUFF_TBL *v14; // t1
  int v15; // [sp+4h] [bp-24h]
  int v16; // [sp+8h] [bp-20h] BYREF

  entropy = cinfo->entropy;
  v15 = 0;
  v16 = 0;
  if ( cinfo->comps_in_scan >= 1 )
  {
    v3 = &v16;
    v4 = 0;
    do
    {
      v5 = *(_QWORD *)&cinfo->cur_comp_info[v4]->dc_tbl_no;
      if ( !*((_BYTE *)v3 + v5) )
      {
        v6 = &cinfo->err + v5;
        v9 = (JHUFF_TBL *)v6[22];
        v8 = (JHUFF_TBL **)(v6 + 22);
        v7 = v9;
        if ( !v9 )
        {
          v7 = jpeg_alloc_huff_table((j_common_ptr)cinfo);
          *v8 = v7;
        }
        jpeg_gen_optimal_table(cinfo, v7, *((int **)&entropy[6].encode_mcu + v5));
        *((_BYTE *)v3 + v5) = 1;
      }
      if ( !*((_BYTE *)&v15 + HIDWORD(v5)) )
      {
        v10 = v3;
        v11 = &cinfo->err + HIDWORD(v5);
        v14 = (JHUFF_TBL *)v11[26];
        v13 = (JHUFF_TBL **)(v11 + 26);
        v12 = v14;
        if ( !v14 )
        {
          v12 = jpeg_alloc_huff_table((j_common_ptr)cinfo);
          *v13 = v12;
        }
        jpeg_gen_optimal_table(cinfo, v12, *((int **)&entropy[7].finish_pass + HIDWORD(v5)));
        v3 = v10;
        *((_BYTE *)&v15 + HIDWORD(v5)) = 1;
      }
      ++v4;
    }
    while ( v4 < cinfo->comps_in_scan );
  }
}

//----- (00477B4C) --------------------------------------------------------
boolean __fastcall encode_mcu_huff(j_compress_ptr cinfo, JBLOCKROW *MCU_data)
{
  j_compress_ptr v2; // r4
  jpeg_destination_mgr *dest; // r1
  jpeg_entropy_encoder *entropy; // r5
  JOCTET *next_output_byte; // r0
  double *v7; // r8
  __int64 v8; // d17
  double v9; // d18
  int v10; // r0
  JBLOCKROW v11; // r2
  int v12; // r0
  int *v13; // r12
  __int64 v14; // kr00_8
  int v15; // r0
  int v16; // r6
  int v17; // r5
  int v18; // r0
  int v19; // r1
  int v20; // r10
  int v21; // r4
  int v22; // r6
  int v23; // r5
  int v24; // r1
  int v25; // r5
  int v26; // r9
  int v27; // r5
  JOCTET *v28; // r0
  int v29; // r6
  JOCTET *v30; // r0
  int v31; // r4
  int *v32; // r10
  int v33; // r4
  JOCTET *v34; // r0
  int v35; // r6
  JOCTET *v36; // r0
  int v37; // r5
  int v38; // r2
  int v39; // r8
  int v40; // r4
  int v41; // r6
  int v42; // r4
  JOCTET *v43; // r0
  int v44; // r6
  JOCTET *v45; // r0
  int v46; // r5
  bool v47; // cc
  int v48; // r4
  int v49; // r0
  int v50; // r10
  int v51; // r6
  int v52; // r8
  int v53; // r0
  int v54; // r5
  int v55; // r6
  JOCTET *v56; // r0
  int v57; // r9
  JOCTET *v58; // r0
  int v59; // r8
  int v60; // r0
  int v61; // r4
  JOCTET *v62; // r0
  int v63; // r6
  JOCTET *v64; // r0
  int v65; // r5
  int v66; // r4
  int v67; // r8
  int v68; // r0
  int v69; // r4
  int v70; // r5
  JOCTET *v71; // r0
  int v72; // r6
  JOCTET *v73; // r0
  int v74; // r8
  __int64 v75; // d17
  double v76; // d18
  __int64 v77; // r0
  void (*start_pass)(j_compress_ptr, boolean); // r1
  jpeg_entropy_encoder *v80; // r11
  jpeg_compress_struct *v81; // r8
  int v82; // r5
  int i; // r6
  int v84; // r4
  JOCTET *v85; // r0
  int v86; // r4
  JOCTET *v87; // r0
  int v88; // r9
  int v89; // r6
  int v90; // r2
  j_compress_ptr v91; // [sp+0h] [bp-78h]
  jpeg_entropy_encoder *v92; // [sp+4h] [bp-74h]
  _DWORD *v93; // [sp+8h] [bp-70h]
  int v94; // [sp+Ch] [bp-6Ch]
  int *v95; // [sp+14h] [bp-64h]
  int v96; // [sp+18h] [bp-60h]
  JBLOCKROW *v97; // [sp+1Ch] [bp-5Ch]
  JBLOCKROW *v98; // [sp+1Ch] [bp-5Ch]
  double *v99; // [sp+20h] [bp-58h]
  jpeg_entropy_encoder *v100; // [sp+20h] [bp-58h]
  int v101; // [sp+28h] [bp-50h]
  int v102; // [sp+28h] [bp-50h]
  JBLOCKROW v103; // [sp+30h] [bp-48h]
  int *v104; // [sp+34h] [bp-44h]
  boolean (*encode_mcu)(j_compress_ptr, JBLOCKROW *); // [sp+34h] [bp-44h]
  JOCTET *v106; // [sp+38h] [bp-40h] BYREF
  size_t free_in_buffer; // [sp+3Ch] [bp-3Ch]
  unsigned __int64 v108; // [sp+40h] [bp-38h]
  __int64 v109; // [sp+48h] [bp-30h]
  double v110; // [sp+50h] [bp-28h]
  _DWORD *p_err; // [sp+58h] [bp-20h]

  v2 = cinfo;
  dest = cinfo->dest;
  entropy = cinfo->entropy;
  next_output_byte = dest->next_output_byte;
  v7 = (double *)&entropy[1];
  v106 = dest->next_output_byte;
  free_in_buffer = dest->free_in_buffer;
  v8 = *(_QWORD *)&entropy[1].finish_pass;
  v9 = *(double *)&entropy[2].encode_mcu;
  v108 = *(_QWORD *)&entropy[1].start_pass;
  v109 = v8;
  p_err = &v2->err;
  v110 = v9;
  if ( v2->restart_interval && !entropy[3].start_pass )
  {
    v80 = entropy;
    v98 = MCU_data;
    v100 = entropy + 1;
    v81 = v2;
    encode_mcu = entropy[3].encode_mcu;
    if ( SHIDWORD(v108) >= 1 )
    {
      v82 = (127 << (17 - BYTE4(v108))) | v108;
      for ( i = HIDWORD(v108) + 15; i > 15; i -= 8 )
      {
        v106 = next_output_byte + 1;
        *next_output_byte = BYTE2(v82);
        if ( --free_in_buffer )
        {
          if ( BYTE2(v82) == 255 )
            goto LABEL_123;
        }
        else
        {
          v84 = p_err[6];
          if ( !(*(int (**)(void))(v84 + 12))() )
            return 0;
          v106 = *(JOCTET **)v84;
          free_in_buffer = *(_DWORD *)(v84 + 4);
          if ( BYTE2(v82) == 255 )
          {
LABEL_123:
            v85 = v106++;
            *v85 = 0;
            if ( !--free_in_buffer )
            {
              v86 = p_err[6];
              if ( !(*(int (**)(void))(v86 + 12))() )
                return 0;
              v106 = *(JOCTET **)v86;
              free_in_buffer = *(_DWORD *)(v86 + 4);
            }
          }
        }
        next_output_byte = v106;
        v82 <<= 8;
      }
    }
    v106 = next_output_byte + 1;
    v108 = 0LL;
    *next_output_byte = -1;
    if ( --free_in_buffer )
    {
      v2 = v81;
      v87 = v106;
      entropy = v80;
      v7 = (double *)v100;
    }
    else
    {
      v88 = p_err[6];
      v2 = v81;
      v7 = (double *)v100;
      entropy = v80;
      if ( !(*(int (**)(void))(v88 + 12))() )
        return 0;
      v87 = *(JOCTET **)v88;
      v106 = *(JOCTET **)v88;
      free_in_buffer = *(_DWORD *)(v88 + 4);
    }
    v106 = v87 + 1;
    *v87 = (_BYTE)encode_mcu - 48;
    if ( --free_in_buffer )
      goto LABEL_134;
    v89 = p_err[6];
    if ( (*(int (__fastcall **)(_DWORD *))(v89 + 12))(p_err) )
    {
      v106 = *(JOCTET **)v89;
      free_in_buffer = *(_DWORD *)(v89 + 4);
LABEL_134:
      MCU_data = v98;
      if ( (int)p_err[57] >= 1 )
      {
        v90 = 0;
        do
          *((_DWORD *)&v109 + v90++) = 0;
        while ( v90 < p_err[57] );
      }
      goto LABEL_3;
    }
    return 0;
  }
LABEL_3:
  if ( v2->blocks_in_MCU >= 1 )
  {
    v10 = 0;
    v91 = v2;
    v92 = entropy;
    v97 = MCU_data;
    v99 = v7;
    do
    {
      v11 = MCU_data[v10];
      v94 = v10;
      v12 = v2->MCU_membership[v10];
      v103 = v11;
      v13 = (int *)&(&v106)[v12];
      v14 = *(_QWORD *)&v2->cur_comp_info[v12]->dc_tbl_no;
      v15 = *(_WORD *)v11 - v13[4];
      v104 = (int *)*((_DWORD *)&entropy[5].start_pass + HIDWORD(v14));
      v16 = v15 + (v15 >> 31);
      v17 = *((_DWORD *)&entropy[3].finish_pass + v14);
      v18 = v16 ^ (v15 >> 31);
      v93 = v13 + 4;
      v101 = v16;
      if ( v18 )
      {
        v19 = -1;
        do
        {
          ++v19;
          v18 >>= 1;
        }
        while ( v18 );
        v20 = v19 + 1;
        if ( v19 >= 11 )
        {
          *(_DWORD *)(*p_err + 20) = 6;
          (*(void (__fastcall **)(_DWORD *))*p_err)(p_err);
        }
      }
      else
      {
        v20 = 0;
      }
      v21 = *(_DWORD *)(v17 + 4 * v20);
      v22 = HIDWORD(v108);
      v23 = *(unsigned __int8 *)(v17 + v20 + 1024);
      if ( !v23 )
      {
        *(_DWORD *)(*p_err + 20) = 40;
        (*(void (__fastcall **)(_DWORD *))*p_err)(p_err);
      }
      v24 = 1 << v23;
      v25 = v23 + v22;
      v26 = v108 | (((v24 - 1) & v21) << (24 - v25));
      if ( v25 >= 8 )
      {
        v27 = v25 + 8;
        while ( 1 )
        {
          v28 = v106++;
          *v28 = BYTE2(v26);
          if ( --free_in_buffer )
          {
            if ( BYTE2(v26) == 255 )
              goto LABEL_20;
          }
          else
          {
            v29 = p_err[6];
            if ( !(*(int (**)(void))(v29 + 12))() )
              return 0;
            v106 = *(JOCTET **)v29;
            free_in_buffer = *(_DWORD *)(v29 + 4);
            if ( BYTE2(v26) == 255 )
            {
LABEL_20:
              v30 = v106++;
              *v30 = 0;
              if ( !--free_in_buffer )
              {
                v31 = p_err[6];
                if ( !(*(int (**)(void))(v31 + 12))() )
                  return 0;
                v106 = *(JOCTET **)v31;
                free_in_buffer = *(_DWORD *)(v31 + 4);
              }
            }
          }
          v27 -= 8;
          v26 <<= 8;
          if ( v27 <= 15 )
          {
            v25 = v27 - 8;
            break;
          }
        }
      }
      v108 = __PAIR64__(v25, v26);
      if ( v20 )
      {
        v25 += v20;
        v26 |= (((1 << v20) - 1) & v101) << (24 - v25);
        if ( v25 >= 8 )
        {
          v32 = v104;
          v33 = v25 + 8;
          while ( 1 )
          {
            v34 = v106++;
            *v34 = BYTE2(v26);
            if ( --free_in_buffer )
            {
              if ( BYTE2(v26) == 255 )
                goto LABEL_33;
            }
            else
            {
              v35 = p_err[6];
              if ( !(*(int (**)(void))(v35 + 12))() )
                return 0;
              v106 = *(JOCTET **)v35;
              free_in_buffer = *(_DWORD *)(v35 + 4);
              if ( BYTE2(v26) == 255 )
              {
LABEL_33:
                v36 = v106++;
                *v36 = 0;
                if ( !--free_in_buffer )
                {
                  v37 = p_err[6];
                  if ( !(*(int (**)(void))(v37 + 12))() )
                    return 0;
                  v106 = *(JOCTET **)v37;
                  free_in_buffer = *(_DWORD *)(v37 + 4);
                }
              }
            }
            v33 -= 8;
            v26 <<= 8;
            if ( v33 <= 15 )
            {
              v25 = v33 - 8;
              goto LABEL_40;
            }
          }
        }
        v32 = v104;
LABEL_40:
        v108 = __PAIR64__(v25, v26);
      }
      else
      {
        v32 = v104;
      }
      v38 = 1;
      v39 = 0;
      v95 = v32 + 256;
      do
      {
        if ( (*v103)[jpeg_natural_order[v38]] )
        {
          v102 = (*v103)[jpeg_natural_order[v38]];
          v96 = v38;
          if ( v39 >= 16 )
          {
            while ( 1 )
            {
              v40 = *((unsigned __int8 *)v32 + 1264);
              v41 = v32[240];
              if ( !*((_BYTE *)v32 + 1264) )
              {
                *(_DWORD *)(*p_err + 20) = 40;
                (*(void (__fastcall **)(_DWORD *))*p_err)(p_err);
              }
              v25 += v40;
              v26 |= (((1 << v40) - 1) & v41) << (24 - v25);
              if ( v25 >= 8 )
                break;
LABEL_58:
              v47 = v39 <= 31;
              v108 = __PAIR64__(v25, v26);
              v39 -= 16;
              if ( v47 )
                goto LABEL_60;
            }
            v42 = v25 + 8;
            while ( 1 )
            {
              v43 = v106++;
              *v43 = BYTE2(v26);
              if ( --free_in_buffer )
              {
                if ( BYTE2(v26) == 255 )
                  goto LABEL_53;
              }
              else
              {
                v44 = p_err[6];
                if ( !(*(int (**)(void))(v44 + 12))() )
                  return 0;
                v106 = *(JOCTET **)v44;
                free_in_buffer = *(_DWORD *)(v44 + 4);
                if ( BYTE2(v26) == 255 )
                {
LABEL_53:
                  v45 = v106++;
                  *v45 = 0;
                  if ( !--free_in_buffer )
                  {
                    v46 = p_err[6];
                    if ( !(*(int (**)(void))(v46 + 12))() )
                      return 0;
                    v106 = *(JOCTET **)v46;
                    free_in_buffer = *(_DWORD *)(v46 + 4);
                  }
                }
              }
              v42 -= 8;
              v26 <<= 8;
              if ( v42 <= 15 )
              {
                v25 = v42 - 8;
                goto LABEL_58;
              }
            }
          }
LABEL_60:
          v48 = 0;
          v49 = v102;
          if ( v102 < 0 )
            v49 = -v102;
          do
          {
            v50 = v48++;
            v49 >>= 1;
          }
          while ( v49 );
          if ( v48 >= 11 )
          {
            *(_DWORD *)(*p_err + 20) = 6;
            (*(void (__fastcall **)(_DWORD *))*p_err)(p_err);
          }
          v51 = *((unsigned __int8 *)&v95[4 * v39] + v48);
          v52 = v104[16 * v39 + v48];
          if ( !v51 )
          {
            *(_DWORD *)(*p_err + 20) = 40;
            (*(void (__fastcall **)(_DWORD *))*p_err)(p_err);
          }
          v53 = v25 + v51;
          v47 = v25 + v51 < 8;
          v54 = v26 | ((((1 << v51) - 1) & v52) << (24 - (v25 + v51)));
          if ( !v47 )
          {
            v55 = v53 + 8;
            while ( 1 )
            {
              v56 = v106++;
              *v56 = BYTE2(v54);
              if ( --free_in_buffer )
              {
                if ( BYTE2(v54) == 255 )
                  goto LABEL_74;
              }
              else
              {
                v57 = p_err[6];
                if ( !(*(int (**)(void))(v57 + 12))() )
                  return 0;
                v106 = *(JOCTET **)v57;
                free_in_buffer = *(_DWORD *)(v57 + 4);
                if ( BYTE2(v54) == 255 )
                {
LABEL_74:
                  v58 = v106++;
                  *v58 = 0;
                  if ( !--free_in_buffer )
                  {
                    v59 = p_err[6];
                    if ( !(*(int (**)(void))(v59 + 12))() )
                      return 0;
                    v106 = *(JOCTET **)v59;
                    free_in_buffer = *(_DWORD *)(v59 + 4);
                  }
                }
              }
              v55 -= 8;
              v54 <<= 8;
              if ( v55 <= 15 )
              {
                v53 = v55 - 8;
                break;
              }
            }
          }
          v108 = __PAIR64__(v53, v54);
          v26 = v54 | (((v102 + (v102 >> 15)) & ((1 << v48) - 1)) << (-(char)v53 - v48 + 24));
          v25 = v53 + v48;
          if ( v53 + v48 >= 8 )
          {
            v60 = v53 + v50;
            v32 = v104;
            v61 = v60 + 9;
            while ( 1 )
            {
              v62 = v106++;
              *v62 = BYTE2(v26);
              if ( --free_in_buffer )
              {
                if ( BYTE2(v26) == 255 )
                  goto LABEL_86;
              }
              else
              {
                v63 = p_err[6];
                if ( !(*(int (**)(void))(v63 + 12))() )
                  return 0;
                v106 = *(JOCTET **)v63;
                free_in_buffer = *(_DWORD *)(v63 + 4);
                if ( BYTE2(v26) == 255 )
                {
LABEL_86:
                  v64 = v106++;
                  *v64 = 0;
                  if ( !--free_in_buffer )
                  {
                    v65 = p_err[6];
                    if ( !(*(int (**)(void))(v65 + 12))() )
                      return 0;
                    v106 = *(JOCTET **)v65;
                    free_in_buffer = *(_DWORD *)(v65 + 4);
                  }
                }
              }
              v61 -= 8;
              v26 <<= 8;
              if ( v61 <= 15 )
              {
                v25 = v61 - 8;
                goto LABEL_93;
              }
            }
          }
          v32 = v104;
LABEL_93:
          v38 = v96;
          v39 = 0;
          v108 = __PAIR64__(v25, v26);
        }
        else
        {
          ++v39;
        }
        v47 = v38++ < 63;
      }
      while ( v47 );
      if ( v39 >= 1 )
      {
        v66 = *((unsigned __int8 *)v32 + 1024);
        v67 = *v32;
        if ( !*((_BYTE *)v32 + 1024) )
        {
          *(_DWORD *)(*p_err + 20) = 40;
          (*(void (__fastcall **)(_DWORD *))*p_err)(p_err);
        }
        v68 = v25 + v66;
        v47 = v25 + v66 < 8;
        v69 = v26 | ((((1 << v66) - 1) & v67) << (24 - (v25 + v66)));
        if ( !v47 )
        {
          v70 = v68 + 8;
          do
          {
            v71 = v106++;
            *v71 = BYTE2(v69);
            if ( !--free_in_buffer )
            {
              v72 = p_err[6];
              if ( !(*(int (**)(void))(v72 + 12))() )
                return 0;
              v106 = *(JOCTET **)v72;
              free_in_buffer = *(_DWORD *)(v72 + 4);
            }
            if ( BYTE2(v69) == 255 )
            {
              v73 = v106++;
              *v73 = 0;
              if ( !--free_in_buffer )
              {
                v74 = p_err[6];
                if ( !(*(int (**)(void))(v74 + 12))() )
                  return 0;
                v106 = *(JOCTET **)v74;
                free_in_buffer = *(_DWORD *)(v74 + 4);
              }
            }
            v70 -= 8;
            v69 <<= 8;
          }
          while ( v70 > 15 );
          v68 = v70 - 8;
        }
        v108 = __PAIR64__(v68, v69);
      }
      MCU_data = v97;
      v2 = v91;
      entropy = v92;
      v7 = v99;
      *v93 = (*v97[v94])[0];
      v10 = v94 + 1;
    }
    while ( v94 + 1 < v91->blocks_in_MCU );
  }
  v2->dest->next_output_byte = v106;
  v2->dest->free_in_buffer = free_in_buffer;
  v75 = v109;
  v76 = v110;
  *(_QWORD *)v7 = v108;
  *((_QWORD *)v7 + 1) = v75;
  v7[2] = v76;
  LODWORD(v77) = v2->restart_interval;
  if ( (_DWORD)v77 )
  {
    start_pass = entropy[3].start_pass;
    if ( !start_pass )
    {
      HIDWORD(v77) = ((unsigned __int8)entropy[3].encode_mcu + 1) & 7;
      *(_QWORD *)&entropy[3].start_pass = v77;
      start_pass = (void (*)(j_compress_ptr, boolean))v77;
    }
    entropy[3].start_pass = (void (*)(j_compress_ptr, boolean))((char *)start_pass - 1);
  }
  return 1;
}

//----- (00478278) --------------------------------------------------------
void __fastcall finish_pass_huff(j_compress_ptr cinfo)
{
  jpeg_entropy_encoder *entropy; // r2
  void (**p_finish_pass)(j_compress_ptr); // r8
  __int64 v4; // kr00_8
  size_t free_in_buffer; // r0
  JOCTET *next_output_byte; // r6
  __int64 v7; // kr08_8
  int v8; // r10
  int v9; // r9
  jpeg_destination_mgr *dest; // r8
  bool v11; // zf
  jpeg_destination_mgr *v12; // r5
  void (*v13)(j_compress_ptr, boolean); // r12
  boolean (*v14)(j_compress_ptr, JBLOCKROW *); // lr
  void (**v15)(j_compress_ptr); // [sp+8h] [bp-38h]
  jpeg_entropy_encoder *v16; // [sp+Ch] [bp-34h]
  __int64 v17; // [sp+10h] [bp-30h]
  __int64 v18; // [sp+18h] [bp-28h]

  entropy = cinfo->entropy;
  p_finish_pass = &entropy[1].finish_pass;
  v4 = *(_QWORD *)&entropy[1].start_pass;
  v7 = *(_QWORD *)&cinfo->dest->next_output_byte;
  free_in_buffer = cinfo->dest->free_in_buffer;
  next_output_byte = (JOCTET *)v7;
  v17 = *(_QWORD *)&entropy[1].finish_pass;
  v18 = *(_QWORD *)&entropy[2].encode_mcu;
  if ( SHIDWORD(v4) >= 1 )
  {
    v15 = &entropy[1].finish_pass;
    v16 = entropy;
    v8 = HIDWORD(v4) + 15;
    v9 = (127 << (17 - BYTE4(v4))) | v4;
    while ( 1 )
    {
      --free_in_buffer;
      *next_output_byte++ = BYTE2(v9);
      if ( !free_in_buffer )
      {
        dest = cinfo->dest;
        if ( !((int (__fastcall *)(j_compress_ptr))dest->empty_output_buffer)(cinfo) )
          goto LABEL_15;
        free_in_buffer = dest->free_in_buffer;
        next_output_byte = dest->next_output_byte;
      }
      v11 = BYTE2(v9) == 255;
      if ( BYTE2(v9) == 255 )
      {
        *next_output_byte++ = 0;
        v11 = --free_in_buffer == 0;
      }
      if ( v11 )
      {
        v12 = cinfo->dest;
        if ( !((int (__fastcall *)(j_compress_ptr))v12->empty_output_buffer)(cinfo) )
        {
LABEL_15:
          cinfo->err->msg_code = 24;
          cinfo->err->error_exit((j_common_ptr)cinfo);
          p_finish_pass = v15;
          entropy = v16;
          v14 = (boolean (*)(j_compress_ptr, JBLOCKROW *))HIDWORD(v4);
          v13 = (void (*)(j_compress_ptr, boolean))v4;
          free_in_buffer = 0;
          goto LABEL_16;
        }
        free_in_buffer = v12->free_in_buffer;
        next_output_byte = v12->next_output_byte;
      }
      v8 -= 8;
      v9 <<= 8;
      if ( v8 <= 15 )
      {
        v13 = 0;
        v14 = 0;
        p_finish_pass = v15;
        entropy = v16;
        goto LABEL_16;
      }
    }
  }
  v13 = 0;
  v14 = 0;
LABEL_16:
  cinfo->dest->next_output_byte = next_output_byte;
  cinfo->dest->free_in_buffer = free_in_buffer;
  entropy[1].start_pass = v13;
  entropy[1].encode_mcu = v14;
  *(_QWORD *)p_finish_pass = v17;
  *((_QWORD *)p_finish_pass + 1) = v18;
}

//----- (00478364) --------------------------------------------------------
void __fastcall jinit_compress_master(j_compress_ptr cinfo)
{
  jpeg_error_mgr *err; // r0
  int v3; // r1
  bool v4; // r1
  boolean optimize_coding; // r1

  jinit_c_master_control(cinfo, 0);
  if ( !cinfo->raw_data_in )
  {
    jinit_color_converter(cinfo);
    jinit_downsampler(cinfo);
    jinit_c_prep_controller(cinfo, 0);
  }
  jinit_forward_dct(cinfo);
  if ( cinfo->arith_code )
  {
    err = cinfo->err;
    v3 = 1;
LABEL_7:
    err->msg_code = v3;
    cinfo->err->error_exit((j_common_ptr)cinfo);
    goto LABEL_8;
  }
  if ( cinfo->progressive_mode )
  {
    err = cinfo->err;
    v3 = 48;
    goto LABEL_7;
  }
  jinit_huff_encoder(cinfo);
LABEL_8:
  if ( cinfo->num_scans <= 1 )
  {
    optimize_coding = cinfo->optimize_coding;
    v4 = optimize_coding != 0;
  }
  else
  {
    v4 = 1;
  }
  jinit_c_coef_controller(cinfo, v4);
  jinit_c_main_controller(cinfo, 0);
  jinit_marker_writer(cinfo);
  cinfo->mem->realize_virt_arrays((j_common_ptr)cinfo);
  cinfo->marker->write_file_header(cinfo);
}

//----- (004783F8) --------------------------------------------------------
void __fastcall jinit_c_main_controller(j_compress_ptr cinfo, boolean need_full_buffer)
{
  int v3; // r5
  jpeg_c_main_controller *v4; // r0
  jpeg_c_main_controller *v5; // r8
  int v6; // r5
  JDIMENSION *p_width_in_blocks; // r6

  v3 = need_full_buffer;
  v4 = (jpeg_c_main_controller *)cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 40);
  cinfo->main = v4;
  v4->start_pass = start_pass_main;
  if ( !cinfo->raw_data_in )
  {
    if ( v3 )
    {
      cinfo->err->msg_code = 4;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    else if ( cinfo->num_components >= 1 )
    {
      v5 = v4 + 3;
      v6 = 0;
      p_width_in_blocks = &cinfo->comp_info->width_in_blocks;
      do
      {
        *((_DWORD *)&v5->start_pass + v6) = cinfo->mem->alloc_sarray(
                                              cinfo,
                                              1,
                                              8 * *p_width_in_blocks,
                                              8 * *(p_width_in_blocks - 4));
        p_width_in_blocks += 21;
        ++v6;
      }
      while ( v6 < cinfo->num_components );
    }
  }
}

//----- (00478488) --------------------------------------------------------
void __fastcall start_pass_main(j_compress_ptr cinfo, J_BUF_MODE pass_mode)
{
  jpeg_c_main_controller *main; // r2

  if ( !cinfo->raw_data_in )
  {
    main = cinfo->main;
    main[1].start_pass = 0;
    main[1].process_data = 0;
    LOBYTE(main[2].start_pass) = 0;
    main[2].process_data = (void (*)(j_compress_ptr, JSAMPARRAY, JDIMENSION *, JDIMENSION))pass_mode;
    if ( pass_mode )
    {
      cinfo->err->msg_code = 4;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    else
    {
      main->process_data = process_data_simple_main;
    }
  }
}

//----- (004784BC) --------------------------------------------------------
void __fastcall process_data_simple_main(
        j_compress_ptr cinfo,
        JSAMPARRAY input_buf,
        JDIMENSION *in_row_ctr,
        JDIMENSION in_rows_avail)
{
  jpeg_c_main_controller *main; // r4
  unsigned int process_data; // r0
  JDIMENSION v9; // r1

  main = cinfo->main;
  if ( (char *)main[1].start_pass < (char *)cinfo->total_iMCU_rows )
  {
    process_data = (unsigned int)main[1].process_data;
    do
    {
      if ( process_data <= 7 )
      {
        cinfo->prep->pre_process_data(
          cinfo,
          input_buf,
          in_row_ctr,
          in_rows_avail,
          (JSAMPIMAGE)&main[3],
          (JDIMENSION *)&main[1].process_data,
          8);
        process_data = (unsigned int)main[1].process_data;
      }
      if ( process_data != 8 )
        break;
      if ( !((int (__fastcall *)(j_compress_ptr, jpeg_c_main_controller *))cinfo->coef->compress_data)(cinfo, &main[3]) )
      {
        if ( !LOBYTE(main[2].start_pass) )
        {
          --*in_row_ctr;
          LOBYTE(main[2].start_pass) = 1;
        }
        return;
      }
      if ( LOBYTE(main[2].start_pass) )
      {
        ++*in_row_ctr;
        LOBYTE(main[2].start_pass) = 0;
      }
      process_data = 0;
      v9 = (JDIMENSION)main[1].start_pass + 1;
      main[1].start_pass = (void (*)(j_compress_ptr, J_BUF_MODE))v9;
      main[1].process_data = 0;
    }
    while ( v9 < cinfo->total_iMCU_rows );
  }
}

//----- (0047855C) --------------------------------------------------------
void __fastcall jinit_marker_writer(j_compress_ptr cinfo)
{
  int v2; // r0
  __int64 v3; // d17
  __int64 v4; // d16

  v2 = cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 32);
  LODWORD(v3) = write_scan_header;
  LODWORD(v4) = write_file_header;
  HIDWORD(v3) = write_file_trailer;
  cinfo->marker = (jpeg_marker_writer *)v2;
  HIDWORD(v4) = write_frame_header;
  *(_DWORD *)(v2 + 20) = write_marker_header;
  *(_DWORD *)(v2 + 24) = write_marker_byte;
  *(_DWORD *)(v2 + 28) = 0;
  *(_QWORD *)v2 = v4;
  *(_QWORD *)(v2 + 8) = v3;
  *(_DWORD *)(v2 + 16) = write_tables_only;
}

//----- (004785D0) --------------------------------------------------------
void __fastcall write_file_header(j_compress_ptr cinfo)
{
  jpeg_destination_mgr *dest; // r0
  jpeg_marker_writer *marker; // r5
  JOCTET *v4; // r1
  int v5; // r1
  jpeg_destination_mgr *v6; // r0
  JOCTET *v7; // r1
  int v8; // r1
  jpeg_destination_mgr *v9; // r0
  JOCTET *v10; // r1
  int v11; // r1
  jpeg_destination_mgr *v12; // r0
  JOCTET *v13; // r1
  int v14; // r1
  jpeg_destination_mgr *v15; // r0
  JOCTET *v16; // r1
  int v17; // r1
  jpeg_destination_mgr *v18; // r0
  JOCTET *v19; // r1
  int v20; // r1
  jpeg_destination_mgr *v21; // r0
  JOCTET *v22; // r1
  int v23; // r1
  jpeg_destination_mgr *v24; // r0
  JOCTET *v25; // r1
  int v26; // r1
  jpeg_destination_mgr *v27; // r0
  JOCTET *v28; // r1
  int v29; // r1
  jpeg_destination_mgr *v30; // r0
  JOCTET *v31; // r1
  int v32; // r1
  jpeg_destination_mgr *v33; // r0
  JOCTET *v34; // r1
  int v35; // r1
  jpeg_destination_mgr *v36; // r0
  UINT8 JFIF_major_version; // r2
  UINT8 *v38; // r1
  int v39; // r1
  jpeg_destination_mgr *v40; // r0
  UINT8 JFIF_minor_version; // r2
  UINT8 *v42; // r1
  int v43; // r1
  jpeg_destination_mgr *v44; // r0
  UINT8 density_unit; // r2
  UINT8 *v46; // r1
  int v47; // r1
  jpeg_destination_mgr *v48; // r0
  UINT16 X_density; // r5
  JOCTET *v50; // r1
  int v51; // r1
  jpeg_destination_mgr *v52; // r0
  JOCTET *v53; // r1
  int v54; // r1
  jpeg_destination_mgr *v55; // r0
  UINT16 Y_density; // r5
  JOCTET *v57; // r1
  int v58; // r1
  jpeg_destination_mgr *v59; // r0
  JOCTET *v60; // r1
  int v61; // r1
  jpeg_destination_mgr *v62; // r0
  JOCTET *v63; // r1
  int v64; // r1
  jpeg_destination_mgr *v65; // r0
  JOCTET *v66; // r1
  int v67; // r1
  jpeg_destination_mgr *v68; // r0
  JOCTET *v69; // r1
  int v70; // r1
  jpeg_destination_mgr *v71; // r0
  JOCTET *v72; // r1
  int v73; // r1
  jpeg_destination_mgr *v74; // r0
  JOCTET *v75; // r1
  int v76; // r1
  jpeg_destination_mgr *v77; // r0
  JOCTET *v78; // r1
  int v79; // r1
  jpeg_destination_mgr *v80; // r0
  JOCTET *v81; // r1
  int v82; // r1
  jpeg_destination_mgr *v83; // r0
  JOCTET *v84; // r1
  int v85; // r1
  jpeg_destination_mgr *v86; // r0
  JOCTET *v87; // r1
  int v88; // r1
  jpeg_destination_mgr *v89; // r0
  JOCTET *v90; // r1
  int v91; // r1
  jpeg_destination_mgr *v92; // r0
  JOCTET *v93; // r1
  int v94; // r1
  jpeg_destination_mgr *v95; // r0
  JOCTET *v96; // r1
  int v97; // r1
  jpeg_destination_mgr *v98; // r0
  JOCTET *v99; // r1
  int v100; // r1
  jpeg_destination_mgr *v101; // r0
  JOCTET *v102; // r1
  int v103; // r1
  jpeg_destination_mgr *v104; // r0
  JOCTET *v105; // r1
  int v106; // r1
  jpeg_destination_mgr *v107; // r0
  JOCTET *v108; // r1
  int v109; // r1
  jpeg_destination_mgr *v110; // r0
  JOCTET *v111; // r1
  int v112; // r1
  J_COLOR_SPACE jpeg_color_space; // r0
  bool v114; // zf
  jpeg_destination_mgr *v115; // r0
  char *v116; // r1
  char v117; // r2
  int v118; // r1

  dest = cinfo->dest;
  marker = cinfo->marker;
  v4 = dest->next_output_byte++;
  *v4 = -1;
  v5 = dest->free_in_buffer - 1;
  dest->free_in_buffer = v5;
  if ( !v5 && !((int (__fastcall *)(j_compress_ptr))dest->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v6 = cinfo->dest;
  v7 = v6->next_output_byte++;
  *v7 = -40;
  v8 = v6->free_in_buffer - 1;
  v6->free_in_buffer = v8;
  if ( !v8 && !((int (__fastcall *)(j_compress_ptr))v6->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  marker[1].write_file_header = 0;
  if ( cinfo->write_JFIF_header )
  {
    v9 = cinfo->dest;
    v10 = v9->next_output_byte++;
    *v10 = -1;
    v11 = v9->free_in_buffer - 1;
    v9->free_in_buffer = v11;
    if ( !v11 && !((int (__fastcall *)(j_compress_ptr))v9->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v12 = cinfo->dest;
    v13 = v12->next_output_byte++;
    *v13 = -32;
    v14 = v12->free_in_buffer - 1;
    v12->free_in_buffer = v14;
    if ( !v14 && !((int (__fastcall *)(j_compress_ptr))v12->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v15 = cinfo->dest;
    v16 = v15->next_output_byte++;
    *v16 = 0;
    v17 = v15->free_in_buffer - 1;
    v15->free_in_buffer = v17;
    if ( !v17 && !((int (__fastcall *)(j_compress_ptr))v15->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v18 = cinfo->dest;
    v19 = v18->next_output_byte++;
    *v19 = 16;
    v20 = v18->free_in_buffer - 1;
    v18->free_in_buffer = v20;
    if ( !v20 && !((int (__fastcall *)(j_compress_ptr))v18->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v21 = cinfo->dest;
    v22 = v21->next_output_byte++;
    *v22 = 74;
    v23 = v21->free_in_buffer - 1;
    v21->free_in_buffer = v23;
    if ( !v23 && !((int (__fastcall *)(j_compress_ptr))v21->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v24 = cinfo->dest;
    v25 = v24->next_output_byte++;
    *v25 = 70;
    v26 = v24->free_in_buffer - 1;
    v24->free_in_buffer = v26;
    if ( !v26 && !((int (__fastcall *)(j_compress_ptr))v24->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v27 = cinfo->dest;
    v28 = v27->next_output_byte++;
    *v28 = 73;
    v29 = v27->free_in_buffer - 1;
    v27->free_in_buffer = v29;
    if ( !v29 && !((int (__fastcall *)(j_compress_ptr))v27->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v30 = cinfo->dest;
    v31 = v30->next_output_byte++;
    *v31 = 70;
    v32 = v30->free_in_buffer - 1;
    v30->free_in_buffer = v32;
    if ( !v32 && !((int (__fastcall *)(j_compress_ptr))v30->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v33 = cinfo->dest;
    v34 = v33->next_output_byte++;
    *v34 = 0;
    v35 = v33->free_in_buffer - 1;
    v33->free_in_buffer = v35;
    if ( !v35 && !((int (__fastcall *)(j_compress_ptr))v33->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v36 = cinfo->dest;
    JFIF_major_version = cinfo->JFIF_major_version;
    v38 = v36->next_output_byte++;
    *v38 = JFIF_major_version;
    v39 = v36->free_in_buffer - 1;
    v36->free_in_buffer = v39;
    if ( !v39 && !((int (__fastcall *)(j_compress_ptr))v36->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v40 = cinfo->dest;
    JFIF_minor_version = cinfo->JFIF_minor_version;
    v42 = v40->next_output_byte++;
    *v42 = JFIF_minor_version;
    v43 = v40->free_in_buffer - 1;
    v40->free_in_buffer = v43;
    if ( !v43 && !((int (__fastcall *)(j_compress_ptr))v40->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v44 = cinfo->dest;
    density_unit = cinfo->density_unit;
    v46 = v44->next_output_byte++;
    *v46 = density_unit;
    v47 = v44->free_in_buffer - 1;
    v44->free_in_buffer = v47;
    if ( !v47 && !((int (__fastcall *)(j_compress_ptr))v44->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v48 = cinfo->dest;
    X_density = cinfo->X_density;
    v50 = v48->next_output_byte++;
    *v50 = HIBYTE(X_density);
    v51 = v48->free_in_buffer - 1;
    v48->free_in_buffer = v51;
    if ( !v51 && !((int (__fastcall *)(j_compress_ptr))v48->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v52 = cinfo->dest;
    v53 = v52->next_output_byte++;
    *v53 = X_density;
    v54 = v52->free_in_buffer - 1;
    v52->free_in_buffer = v54;
    if ( !v54 && !((int (__fastcall *)(j_compress_ptr))v52->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v55 = cinfo->dest;
    Y_density = cinfo->Y_density;
    v57 = v55->next_output_byte++;
    *v57 = HIBYTE(Y_density);
    v58 = v55->free_in_buffer - 1;
    v55->free_in_buffer = v58;
    if ( !v58 && !((int (__fastcall *)(j_compress_ptr))v55->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v59 = cinfo->dest;
    v60 = v59->next_output_byte++;
    *v60 = Y_density;
    v61 = v59->free_in_buffer - 1;
    v59->free_in_buffer = v61;
    if ( !v61 && !((int (__fastcall *)(j_compress_ptr))v59->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v62 = cinfo->dest;
    v63 = v62->next_output_byte++;
    *v63 = 0;
    v64 = v62->free_in_buffer - 1;
    v62->free_in_buffer = v64;
    if ( !v64 && !((int (__fastcall *)(j_compress_ptr))v62->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v65 = cinfo->dest;
    v66 = v65->next_output_byte++;
    *v66 = 0;
    v67 = v65->free_in_buffer - 1;
    v65->free_in_buffer = v67;
    if ( !v67 && !((int (__fastcall *)(j_compress_ptr))v65->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
  }
  if ( cinfo->write_Adobe_marker )
  {
    v68 = cinfo->dest;
    v69 = v68->next_output_byte++;
    *v69 = -1;
    v70 = v68->free_in_buffer - 1;
    v68->free_in_buffer = v70;
    if ( !v70 && !((int (__fastcall *)(j_compress_ptr))v68->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v71 = cinfo->dest;
    v72 = v71->next_output_byte++;
    *v72 = -18;
    v73 = v71->free_in_buffer - 1;
    v71->free_in_buffer = v73;
    if ( !v73 && !((int (__fastcall *)(j_compress_ptr))v71->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v74 = cinfo->dest;
    v75 = v74->next_output_byte++;
    *v75 = 0;
    v76 = v74->free_in_buffer - 1;
    v74->free_in_buffer = v76;
    if ( !v76 && !((int (__fastcall *)(j_compress_ptr))v74->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v77 = cinfo->dest;
    v78 = v77->next_output_byte++;
    *v78 = 14;
    v79 = v77->free_in_buffer - 1;
    v77->free_in_buffer = v79;
    if ( !v79 && !((int (__fastcall *)(j_compress_ptr))v77->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v80 = cinfo->dest;
    v81 = v80->next_output_byte++;
    *v81 = 65;
    v82 = v80->free_in_buffer - 1;
    v80->free_in_buffer = v82;
    if ( !v82 && !((int (__fastcall *)(j_compress_ptr))v80->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v83 = cinfo->dest;
    v84 = v83->next_output_byte++;
    *v84 = 100;
    v85 = v83->free_in_buffer - 1;
    v83->free_in_buffer = v85;
    if ( !v85 && !((int (__fastcall *)(j_compress_ptr))v83->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v86 = cinfo->dest;
    v87 = v86->next_output_byte++;
    *v87 = 111;
    v88 = v86->free_in_buffer - 1;
    v86->free_in_buffer = v88;
    if ( !v88 && !((int (__fastcall *)(j_compress_ptr))v86->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v89 = cinfo->dest;
    v90 = v89->next_output_byte++;
    *v90 = 98;
    v91 = v89->free_in_buffer - 1;
    v89->free_in_buffer = v91;
    if ( !v91 && !((int (__fastcall *)(j_compress_ptr))v89->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v92 = cinfo->dest;
    v93 = v92->next_output_byte++;
    *v93 = 101;
    v94 = v92->free_in_buffer - 1;
    v92->free_in_buffer = v94;
    if ( !v94 && !((int (__fastcall *)(j_compress_ptr))v92->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v95 = cinfo->dest;
    v96 = v95->next_output_byte++;
    *v96 = 0;
    v97 = v95->free_in_buffer - 1;
    v95->free_in_buffer = v97;
    if ( !v97 && !((int (__fastcall *)(j_compress_ptr))v95->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v98 = cinfo->dest;
    v99 = v98->next_output_byte++;
    *v99 = 100;
    v100 = v98->free_in_buffer - 1;
    v98->free_in_buffer = v100;
    if ( !v100 && !((int (__fastcall *)(j_compress_ptr))v98->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v101 = cinfo->dest;
    v102 = v101->next_output_byte++;
    *v102 = 0;
    v103 = v101->free_in_buffer - 1;
    v101->free_in_buffer = v103;
    if ( !v103 && !((int (__fastcall *)(j_compress_ptr))v101->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v104 = cinfo->dest;
    v105 = v104->next_output_byte++;
    *v105 = 0;
    v106 = v104->free_in_buffer - 1;
    v104->free_in_buffer = v106;
    if ( !v106 && !((int (__fastcall *)(j_compress_ptr))v104->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v107 = cinfo->dest;
    v108 = v107->next_output_byte++;
    *v108 = 0;
    v109 = v107->free_in_buffer - 1;
    v107->free_in_buffer = v109;
    if ( !v109 && !((int (__fastcall *)(j_compress_ptr))v107->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v110 = cinfo->dest;
    v111 = v110->next_output_byte++;
    *v111 = 0;
    v112 = v110->free_in_buffer - 1;
    v110->free_in_buffer = v112;
    if ( !v112 && !((int (__fastcall *)(j_compress_ptr))v110->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    jpeg_color_space = cinfo->jpeg_color_space;
    if ( jpeg_color_space == JCS_YCCK )
    {
      v115 = cinfo->dest;
      v116 = (char *)v115->next_output_byte++;
      v117 = 2;
    }
    else
    {
      v114 = jpeg_color_space == JCS_YCbCr;
      v115 = cinfo->dest;
      v116 = (char *)v115->next_output_byte++;
      v117 = v114;
    }
    *v116 = v117;
    v118 = v115->free_in_buffer - 1;
    v115->free_in_buffer = v118;
    if ( !v118 && !((int (__fastcall *)(j_compress_ptr))v115->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
  }
}

//----- (00478C02) --------------------------------------------------------
void __fastcall write_frame_header(j_compress_ptr cinfo)
{
  int num_components; // r0
  int v3; // r5
  int v4; // r4
  int *p_quant_tbl_no; // r6
  int v6; // t1
  jpeg_compress_struct *v7; // r0
  JPEG_MARKER v8; // r1
  int v9; // r2
  int v10; // r6
  int *p_dc_tbl_no; // r1
  bool v12; // cc
  bool v13; // zf

  num_components = cinfo->num_components;
  if ( num_components < 1 )
  {
    v3 = 0;
  }
  else
  {
    v3 = 0;
    v4 = 0;
    p_quant_tbl_no = &cinfo->comp_info->quant_tbl_no;
    do
    {
      v6 = *p_quant_tbl_no;
      p_quant_tbl_no += 21;
      v3 += emit_dqt(cinfo, v6);
      num_components = cinfo->num_components;
      ++v4;
    }
    while ( v4 < num_components );
  }
  if ( cinfo->arith_code )
  {
LABEL_7:
    v7 = cinfo;
    v8 = M_SOF9;
    goto LABEL_26;
  }
  if ( cinfo->progressive_mode )
    goto LABEL_25;
  if ( cinfo->data_precision == 8 )
  {
    if ( num_components < 1 )
    {
      v10 = 1;
    }
    else
    {
      v9 = 0;
      v10 = 1;
      p_dc_tbl_no = &cinfo->comp_info->dc_tbl_no;
      do
      {
        v12 = *p_dc_tbl_no < 1;
        if ( *p_dc_tbl_no <= 1 )
          v12 = p_dc_tbl_no[1] < 2;
        if ( !v12 )
          v10 = 0;
        ++v9;
        p_dc_tbl_no += 21;
      }
      while ( v9 < num_components );
    }
    v13 = v3 == 0;
    if ( v3 )
      v13 = v10 << 24 == 0;
    if ( !v13 )
    {
      v10 = 0;
      cinfo->err->msg_code = 75;
      cinfo->err->emit_message((j_common_ptr)cinfo, 0);
      if ( cinfo->arith_code )
        goto LABEL_7;
    }
  }
  else
  {
    v10 = 0;
  }
  if ( cinfo->progressive_mode )
  {
LABEL_25:
    v7 = cinfo;
    v8 = M_SOF2;
    goto LABEL_26;
  }
  v7 = cinfo;
  if ( v10 << 24 )
    v8 = M_SOF0;
  else
    v8 = M_SOF1;
LABEL_26:
  emit_sof(v7, v8);
}

//----- (00478CCA) --------------------------------------------------------
void __fastcall write_scan_header(j_compress_ptr cinfo)
{
  jpeg_marker_writer *marker; // r8
  int v3; // r6
  jpeg_component_info *v4; // r5
  int dc_tbl_no; // r1
  jpeg_compress_struct *v6; // r0
  boolean v7; // r2
  jpeg_destination_mgr *dest; // r0
  JOCTET *v9; // r1
  int v10; // r1
  jpeg_destination_mgr *v11; // r0
  JOCTET *v12; // r1
  int v13; // r1
  jpeg_destination_mgr *v14; // r0
  JOCTET *v15; // r1
  int v16; // r1
  jpeg_destination_mgr *v17; // r0
  JOCTET *v18; // r1
  int v19; // r1
  jpeg_destination_mgr *v20; // r0
  unsigned int restart_interval; // r6
  JOCTET *v22; // r1
  int v23; // r1
  jpeg_destination_mgr *v24; // r0
  JOCTET *v25; // r1
  int v26; // r1
  jpeg_destination_mgr *v27; // r0
  JOCTET *v28; // r1
  int v29; // r1
  jpeg_destination_mgr *v30; // r0
  JOCTET *v31; // r1
  int v32; // r1
  jpeg_destination_mgr *v33; // r0
  int comps_in_scan; // r1
  JOCTET *v35; // r2
  __int16 v36; // r5
  int v37; // r1
  jpeg_destination_mgr *v38; // r0
  JOCTET *v39; // r1
  int v40; // r1
  jpeg_destination_mgr *v41; // r0
  int v42; // r1
  JOCTET *v43; // r2
  int v44; // r1
  int v45; // r5
  jpeg_destination_mgr *v46; // r0
  jpeg_component_info *v47; // r6
  JOCTET *next_output_byte; // r1
  int component_id; // r2
  int v50; // r1
  __int64 v51; // r0
  jpeg_destination_mgr *v52; // r2
  JOCTET *v53; // r3
  int v54; // r0
  jpeg_destination_mgr *v55; // r0
  int Ss; // r1
  JOCTET *v57; // r2
  int v58; // r1
  jpeg_destination_mgr *v59; // r0
  int Se; // r1
  JOCTET *v61; // r2
  int v62; // r1
  jpeg_destination_mgr *v63; // r0
  __int64 v64; // kr00_8
  JOCTET *v65; // r3
  int v66; // r1

  marker = cinfo->marker;
  if ( !cinfo->arith_code && cinfo->comps_in_scan >= 1 )
  {
    v3 = 0;
    while ( 1 )
    {
      v4 = cinfo->cur_comp_info[v3];
      if ( !cinfo->progressive_mode )
        break;
      if ( cinfo->Ss )
        goto LABEL_9;
      if ( !cinfo->Ah )
      {
        dc_tbl_no = v4->dc_tbl_no;
        v6 = cinfo;
        v7 = 0;
        goto LABEL_10;
      }
LABEL_11:
      if ( ++v3 >= cinfo->comps_in_scan )
        goto LABEL_12;
    }
    emit_dht(cinfo, v4->dc_tbl_no, 0);
LABEL_9:
    dc_tbl_no = v4->ac_tbl_no;
    v6 = cinfo;
    v7 = 1;
LABEL_10:
    emit_dht(v6, dc_tbl_no, v7);
    goto LABEL_11;
  }
LABEL_12:
  if ( (void (*)(j_compress_ptr))cinfo->restart_interval != marker[1].write_file_header )
  {
    dest = cinfo->dest;
    v9 = dest->next_output_byte++;
    *v9 = -1;
    v10 = dest->free_in_buffer - 1;
    dest->free_in_buffer = v10;
    if ( !v10 && !((int (__fastcall *)(j_compress_ptr))dest->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v11 = cinfo->dest;
    v12 = v11->next_output_byte++;
    *v12 = -35;
    v13 = v11->free_in_buffer - 1;
    v11->free_in_buffer = v13;
    if ( !v13 && !((int (__fastcall *)(j_compress_ptr))v11->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v14 = cinfo->dest;
    v15 = v14->next_output_byte++;
    *v15 = 0;
    v16 = v14->free_in_buffer - 1;
    v14->free_in_buffer = v16;
    if ( !v16 && !((int (__fastcall *)(j_compress_ptr))v14->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v17 = cinfo->dest;
    v18 = v17->next_output_byte++;
    *v18 = 4;
    v19 = v17->free_in_buffer - 1;
    v17->free_in_buffer = v19;
    if ( !v19 && !((int (__fastcall *)(j_compress_ptr))v17->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v20 = cinfo->dest;
    restart_interval = cinfo->restart_interval;
    v22 = v20->next_output_byte++;
    *v22 = BYTE1(restart_interval);
    v23 = v20->free_in_buffer - 1;
    v20->free_in_buffer = v23;
    if ( !v23 && !((int (__fastcall *)(j_compress_ptr))v20->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v24 = cinfo->dest;
    v25 = v24->next_output_byte++;
    *v25 = restart_interval;
    v26 = v24->free_in_buffer - 1;
    v24->free_in_buffer = v26;
    if ( !v26 && !((int (__fastcall *)(j_compress_ptr))v24->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    marker[1].write_file_header = (void (*)(j_compress_ptr))cinfo->restart_interval;
  }
  v27 = cinfo->dest;
  v28 = v27->next_output_byte++;
  *v28 = -1;
  v29 = v27->free_in_buffer - 1;
  v27->free_in_buffer = v29;
  if ( !v29 && !((int (__fastcall *)(j_compress_ptr))v27->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v30 = cinfo->dest;
  v31 = v30->next_output_byte++;
  *v31 = -38;
  v32 = v30->free_in_buffer - 1;
  v30->free_in_buffer = v32;
  if ( !v32 && !((int (__fastcall *)(j_compress_ptr))v30->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v33 = cinfo->dest;
  comps_in_scan = cinfo->comps_in_scan;
  v35 = v33->next_output_byte++;
  v36 = 2 * comps_in_scan + 6;
  *v35 = HIBYTE(v36);
  v37 = v33->free_in_buffer - 1;
  v33->free_in_buffer = v37;
  if ( !v37 && !((int (__fastcall *)(j_compress_ptr))v33->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v38 = cinfo->dest;
  v39 = v38->next_output_byte++;
  *v39 = v36;
  v40 = v38->free_in_buffer - 1;
  v38->free_in_buffer = v40;
  if ( !v40 && !((int (__fastcall *)(j_compress_ptr))v38->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v41 = cinfo->dest;
  v42 = cinfo->comps_in_scan;
  v43 = v41->next_output_byte++;
  *v43 = v42;
  v44 = v41->free_in_buffer - 1;
  v41->free_in_buffer = v44;
  if ( !v44 && !((int (__fastcall *)(j_compress_ptr))v41->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  if ( cinfo->comps_in_scan > 0 )
  {
    v45 = 0;
    do
    {
      v46 = cinfo->dest;
      v47 = cinfo->cur_comp_info[v45];
      next_output_byte = v46->next_output_byte;
      component_id = v47->component_id;
      ++v46->next_output_byte;
      *next_output_byte = component_id;
      v50 = v46->free_in_buffer - 1;
      v46->free_in_buffer = v50;
      if ( !v50 && !((int (__fastcall *)(j_compress_ptr))v46->empty_output_buffer)(cinfo) )
      {
        cinfo->err->msg_code = 24;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      v51 = *(_QWORD *)&v47->dc_tbl_no;
      if ( cinfo->progressive_mode )
      {
        if ( cinfo->Ss )
        {
          LOBYTE(v51) = 0;
        }
        else
        {
          if ( cinfo->Ah && !cinfo->arith_code )
            LOBYTE(v51) = cinfo->arith_code;
          BYTE4(v51) = 0;
        }
      }
      v52 = cinfo->dest;
      v53 = v52->next_output_byte++;
      *v53 = BYTE4(v51) + 16 * v51;
      v54 = v52->free_in_buffer - 1;
      v52->free_in_buffer = v54;
      if ( !v54 && !((int (__fastcall *)(j_compress_ptr))v52->empty_output_buffer)(cinfo) )
      {
        cinfo->err->msg_code = 24;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      ++v45;
    }
    while ( v45 < cinfo->comps_in_scan );
  }
  v55 = cinfo->dest;
  Ss = cinfo->Ss;
  v57 = v55->next_output_byte++;
  *v57 = Ss;
  v58 = v55->free_in_buffer - 1;
  v55->free_in_buffer = v58;
  if ( !v58 && !((int (__fastcall *)(j_compress_ptr))v55->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v59 = cinfo->dest;
  Se = cinfo->Se;
  v61 = v59->next_output_byte++;
  *v61 = Se;
  v62 = v59->free_in_buffer - 1;
  v59->free_in_buffer = v62;
  if ( !v62 && !((int (__fastcall *)(j_compress_ptr))v59->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v63 = cinfo->dest;
  v64 = *(_QWORD *)&cinfo->Ah;
  v65 = v63->next_output_byte++;
  *v65 = BYTE4(v64) + 16 * v64;
  v66 = v63->free_in_buffer - 1;
  v63->free_in_buffer = v66;
  if ( !v66 && !((int (__fastcall *)(j_compress_ptr))v63->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
}

//----- (0047904A) --------------------------------------------------------
void __fastcall write_file_trailer(j_compress_ptr cinfo)
{
  jpeg_destination_mgr *dest; // r0
  JOCTET *v3; // r1
  int v4; // r1
  jpeg_destination_mgr *v5; // r0
  JOCTET *v6; // r1
  int v7; // r1

  dest = cinfo->dest;
  v3 = dest->next_output_byte++;
  *v3 = -1;
  v4 = dest->free_in_buffer - 1;
  dest->free_in_buffer = v4;
  if ( !v4 && !((int (__fastcall *)(j_compress_ptr))dest->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v5 = cinfo->dest;
  v6 = v5->next_output_byte++;
  *v6 = -39;
  v7 = v5->free_in_buffer - 1;
  v5->free_in_buffer = v7;
  if ( !v7 && !((int (__fastcall *)(j_compress_ptr))v5->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
}

//----- (004790AC) --------------------------------------------------------
void __fastcall write_tables_only(j_compress_ptr cinfo)
{
  jpeg_destination_mgr *dest; // r0
  JOCTET *v3; // r1
  int v4; // r1
  jpeg_destination_mgr *v5; // r0
  JOCTET *v6; // r1
  int v7; // r1
  jpeg_destination_mgr *v8; // r0
  JOCTET *v9; // r1
  int v10; // r1
  jpeg_destination_mgr *v11; // r0
  JOCTET *v12; // r1
  int v13; // r1

  dest = cinfo->dest;
  v3 = dest->next_output_byte++;
  *v3 = -1;
  v4 = dest->free_in_buffer - 1;
  dest->free_in_buffer = v4;
  if ( !v4 && !((int (__fastcall *)(j_compress_ptr))dest->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v5 = cinfo->dest;
  v6 = v5->next_output_byte++;
  *v6 = -40;
  v7 = v5->free_in_buffer - 1;
  v5->free_in_buffer = v7;
  if ( !v7 && !((int (__fastcall *)(j_compress_ptr))v5->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  if ( cinfo->quant_tbl_ptrs[0] )
    emit_dqt(cinfo, 0);
  if ( cinfo->quant_tbl_ptrs[1] )
    emit_dqt(cinfo, 1);
  if ( cinfo->quant_tbl_ptrs[2] )
    emit_dqt(cinfo, 2);
  if ( cinfo->quant_tbl_ptrs[3] )
    emit_dqt(cinfo, 3);
  if ( !cinfo->arith_code )
  {
    if ( cinfo->dc_huff_tbl_ptrs[0] )
      emit_dht(cinfo, 0, 0);
    if ( cinfo->ac_huff_tbl_ptrs[0] )
      emit_dht(cinfo, 0, 1u);
    if ( cinfo->dc_huff_tbl_ptrs[1] )
      emit_dht(cinfo, 1, 0);
    if ( cinfo->ac_huff_tbl_ptrs[1] )
      emit_dht(cinfo, 1, 1u);
    if ( cinfo->dc_huff_tbl_ptrs[2] )
      emit_dht(cinfo, 2, 0);
    if ( cinfo->ac_huff_tbl_ptrs[2] )
      emit_dht(cinfo, 2, 1u);
    if ( cinfo->dc_huff_tbl_ptrs[3] )
      emit_dht(cinfo, 3, 0);
    if ( cinfo->ac_huff_tbl_ptrs[3] )
      emit_dht(cinfo, 3, 1u);
  }
  v8 = cinfo->dest;
  v9 = v8->next_output_byte++;
  *v9 = -1;
  v10 = v8->free_in_buffer - 1;
  v8->free_in_buffer = v10;
  if ( !v10 && !((int (__fastcall *)(j_compress_ptr))v8->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v11 = cinfo->dest;
  v12 = v11->next_output_byte++;
  *v12 = -39;
  v13 = v11->free_in_buffer - 1;
  v11->free_in_buffer = v13;
  if ( !v13 && !((int (__fastcall *)(j_compress_ptr))v11->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
}

//----- (00479210) --------------------------------------------------------
void __fastcall write_marker_header(j_compress_ptr cinfo, int marker, unsigned int datalen)
{
  __int16 v4; // r5
  JOCTET v5; // r6
  jpeg_destination_mgr *dest; // r0
  JOCTET *v7; // r1
  int v8; // r1
  jpeg_destination_mgr *v9; // r0
  JOCTET *v10; // r1
  int v11; // r1
  jpeg_destination_mgr *v12; // r0
  __int16 v13; // r5
  JOCTET *v14; // r1
  int v15; // r1
  jpeg_destination_mgr *v16; // r0
  JOCTET *v17; // r1
  int v18; // r1

  v4 = datalen;
  v5 = marker;
  if ( datalen >= 0xFFFE )
  {
    cinfo->err->msg_code = 11;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  dest = cinfo->dest;
  v7 = dest->next_output_byte++;
  *v7 = -1;
  v8 = dest->free_in_buffer - 1;
  dest->free_in_buffer = v8;
  if ( !v8 && !((int (__fastcall *)(j_compress_ptr))dest->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v9 = cinfo->dest;
  v10 = v9->next_output_byte++;
  *v10 = v5;
  v11 = v9->free_in_buffer - 1;
  v9->free_in_buffer = v11;
  if ( !v11 && !((int (__fastcall *)(j_compress_ptr))v9->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v12 = cinfo->dest;
  v13 = v4 + 2;
  v14 = v12->next_output_byte++;
  *v14 = HIBYTE(v13);
  v15 = v12->free_in_buffer - 1;
  v12->free_in_buffer = v15;
  if ( !v15 && !((int (__fastcall *)(j_compress_ptr))v12->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v16 = cinfo->dest;
  v17 = v16->next_output_byte++;
  *v17 = v13;
  v18 = v16->free_in_buffer - 1;
  v16->free_in_buffer = v18;
  if ( !v18 && !((int (__fastcall *)(j_compress_ptr))v16->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
}

//----- (004792E8) --------------------------------------------------------
void __fastcall write_marker_byte(j_compress_ptr cinfo, int val)
{
  jpeg_destination_mgr *dest; // r0
  JOCTET *v4; // r2
  int v5; // r1

  dest = cinfo->dest;
  v4 = dest->next_output_byte++;
  *v4 = val;
  v5 = dest->free_in_buffer - 1;
  dest->free_in_buffer = v5;
  if ( !v5 && !((int (__fastcall *)(j_compress_ptr))dest->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
}

//----- (00479320) --------------------------------------------------------
int __fastcall emit_dqt(j_compress_ptr cinfo, int index)
{
  char v2; // r8
  JQUANT_TBL *v4; // r11
  int v5; // r5
  int i; // r0
  unsigned int v7; // r1
  jpeg_destination_mgr *dest; // r0
  JOCTET *v9; // r1
  int v10; // r1
  jpeg_destination_mgr *v11; // r0
  JOCTET *v12; // r1
  int v13; // r1
  jpeg_destination_mgr *v14; // r0
  JOCTET *v15; // r1
  int v16; // r1
  jpeg_destination_mgr *v17; // r0
  char *v18; // r1
  char v19; // r2
  int v20; // r1
  jpeg_destination_mgr *v21; // r0
  JOCTET *v22; // r1
  int v23; // r1
  int j; // r4
  UINT16 v25; // r6
  jpeg_destination_mgr *v26; // r0
  JOCTET *v27; // r1
  int v28; // r1
  jpeg_destination_mgr *v29; // r0
  JOCTET *v30; // r1
  int v31; // r1

  v2 = index;
  v4 = cinfo->quant_tbl_ptrs[index];
  if ( !v4 )
  {
    cinfo->err->msg_code = 52;
    cinfo->err->msg_parm.i[0] = index;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v5 = 0;
  for ( i = 0; i != 64; ++i )
  {
    v7 = v4->quantval[i];
    if ( v7 > 0xFF )
      v5 = 1;
  }
  if ( !v4->sent_table )
  {
    dest = cinfo->dest;
    v9 = dest->next_output_byte++;
    *v9 = -1;
    v10 = dest->free_in_buffer - 1;
    dest->free_in_buffer = v10;
    if ( !v10 && !((int (__fastcall *)(j_compress_ptr))dest->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v11 = cinfo->dest;
    v12 = v11->next_output_byte++;
    *v12 = -37;
    v13 = v11->free_in_buffer - 1;
    v11->free_in_buffer = v13;
    if ( !v13 && !((int (__fastcall *)(j_compress_ptr))v11->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v14 = cinfo->dest;
    v15 = v14->next_output_byte++;
    *v15 = 0;
    v16 = v14->free_in_buffer - 1;
    v14->free_in_buffer = v16;
    if ( !v16 && !((int (__fastcall *)(j_compress_ptr))v14->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v17 = cinfo->dest;
    v18 = (char *)v17->next_output_byte++;
    v19 = 67;
    if ( v5 )
      v19 = -125;
    *v18 = v19;
    v20 = v17->free_in_buffer - 1;
    v17->free_in_buffer = v20;
    if ( !v20 && !((int (__fastcall *)(j_compress_ptr))v17->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v21 = cinfo->dest;
    v22 = v21->next_output_byte++;
    *v22 = v2 + 16 * v5;
    v23 = v21->free_in_buffer - 1;
    v21->free_in_buffer = v23;
    if ( !v23 && !((int (__fastcall *)(j_compress_ptr))v21->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    for ( j = 0; j != 64; ++j )
    {
      v25 = v4->quantval[jpeg_natural_order[j]];
      if ( v5 )
      {
        v26 = cinfo->dest;
        v27 = v26->next_output_byte++;
        *v27 = HIBYTE(v25);
        v28 = v26->free_in_buffer - 1;
        v26->free_in_buffer = v28;
        if ( !v28 && !((int (__fastcall *)(j_compress_ptr))v26->empty_output_buffer)(cinfo) )
        {
          cinfo->err->msg_code = 24;
          cinfo->err->error_exit((j_common_ptr)cinfo);
        }
      }
      v29 = cinfo->dest;
      v30 = v29->next_output_byte++;
      *v30 = v25;
      v31 = v29->free_in_buffer - 1;
      v29->free_in_buffer = v31;
      if ( !v31 && !((int (__fastcall *)(j_compress_ptr))v29->empty_output_buffer)(cinfo) )
      {
        cinfo->err->msg_code = 24;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
    }
    v4->sent_table = 1;
  }
  return v5;
}

//----- (00479504) --------------------------------------------------------
void __fastcall emit_sof(j_compress_ptr cinfo, JPEG_MARKER code)
{
  JOCTET v3; // r5
  jpeg_destination_mgr *dest; // r0
  JOCTET *v5; // r1
  int v6; // r1
  jpeg_destination_mgr *v7; // r0
  JOCTET *v8; // r1
  int v9; // r1
  jpeg_destination_mgr *v10; // r0
  int v11; // r5
  JOCTET *v12; // r2
  int v13; // r1
  jpeg_destination_mgr *v14; // r0
  JOCTET *v15; // r1
  int v16; // r1
  signed int image_height; // r0
  bool v18; // cc
  jpeg_destination_mgr *v19; // r0
  int data_precision; // r1
  JOCTET *v21; // r2
  int v22; // r1
  jpeg_destination_mgr *v23; // r0
  JDIMENSION v24; // r5
  JOCTET *v25; // r1
  int v26; // r1
  jpeg_destination_mgr *v27; // r0
  JOCTET *v28; // r1
  int v29; // r1
  jpeg_destination_mgr *v30; // r0
  JDIMENSION image_width; // r5
  JOCTET *v32; // r1
  int v33; // r1
  jpeg_destination_mgr *v34; // r0
  JOCTET *v35; // r1
  int v36; // r1
  jpeg_destination_mgr *v37; // r0
  int num_components; // r1
  JOCTET *v39; // r2
  int v40; // r1
  jpeg_component_info *comp_info; // r5
  int v42; // r6
  jpeg_destination_mgr *v43; // r0
  int component_id; // r2
  JOCTET *v45; // r1
  int v46; // r1
  jpeg_destination_mgr *v47; // r0
  __int64 v48; // kr08_8
  JOCTET *v49; // r3
  int v50; // r1
  jpeg_destination_mgr *v51; // r0
  int quant_tbl_no; // r2
  JOCTET *v53; // r1
  int v54; // r1

  v3 = code;
  dest = cinfo->dest;
  v5 = dest->next_output_byte++;
  *v5 = -1;
  v6 = dest->free_in_buffer - 1;
  dest->free_in_buffer = v6;
  if ( !v6 && !((int (__fastcall *)(j_compress_ptr))dest->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v7 = cinfo->dest;
  v8 = v7->next_output_byte++;
  *v8 = v3;
  v9 = v7->free_in_buffer - 1;
  v7->free_in_buffer = v9;
  if ( !v9 && !((int (__fastcall *)(j_compress_ptr))v7->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v10 = cinfo->dest;
  v11 = 3 * cinfo->num_components + 8;
  v12 = v10->next_output_byte++;
  *v12 = BYTE1(v11);
  v13 = v10->free_in_buffer - 1;
  v10->free_in_buffer = v13;
  if ( !v13 && !((int (__fastcall *)(j_compress_ptr))v10->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v14 = cinfo->dest;
  v15 = v14->next_output_byte++;
  *v15 = v11;
  v16 = v14->free_in_buffer - 1;
  v14->free_in_buffer = v16;
  if ( !v16 && !((int (__fastcall *)(j_compress_ptr))v14->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  image_height = cinfo->image_height;
  v18 = image_height < 0x10000;
  if ( image_height < 0x10000 )
    v18 = (signed int)cinfo->image_width < 0x10000;
  if ( !v18 )
  {
    cinfo->err->msg_code = 41;
    cinfo->err->msg_parm.i[0] = 0xFFFF;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v19 = cinfo->dest;
  data_precision = cinfo->data_precision;
  v21 = v19->next_output_byte++;
  *v21 = data_precision;
  v22 = v19->free_in_buffer - 1;
  v19->free_in_buffer = v22;
  if ( !v22 && !((int (__fastcall *)(j_compress_ptr))v19->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v23 = cinfo->dest;
  v24 = cinfo->image_height;
  v25 = v23->next_output_byte++;
  *v25 = BYTE1(v24);
  v26 = v23->free_in_buffer - 1;
  v23->free_in_buffer = v26;
  if ( !v26 && !((int (__fastcall *)(j_compress_ptr))v23->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v27 = cinfo->dest;
  v28 = v27->next_output_byte++;
  *v28 = v24;
  v29 = v27->free_in_buffer - 1;
  v27->free_in_buffer = v29;
  if ( !v29 && !((int (__fastcall *)(j_compress_ptr))v27->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  image_width = cinfo->image_width;
  v30 = cinfo->dest;
  v32 = v30->next_output_byte++;
  *v32 = BYTE1(image_width);
  v33 = v30->free_in_buffer - 1;
  v30->free_in_buffer = v33;
  if ( !v33 && !((int (__fastcall *)(j_compress_ptr))v30->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v34 = cinfo->dest;
  v35 = v34->next_output_byte++;
  *v35 = image_width;
  v36 = v34->free_in_buffer - 1;
  v34->free_in_buffer = v36;
  if ( !v36 && !((int (__fastcall *)(j_compress_ptr))v34->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v37 = cinfo->dest;
  num_components = cinfo->num_components;
  v39 = v37->next_output_byte++;
  *v39 = num_components;
  v40 = v37->free_in_buffer - 1;
  v37->free_in_buffer = v40;
  if ( !v40 && !((int (__fastcall *)(j_compress_ptr))v37->empty_output_buffer)(cinfo) )
  {
    cinfo->err->msg_code = 24;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  if ( cinfo->num_components >= 1 )
  {
    comp_info = cinfo->comp_info;
    v42 = 0;
    do
    {
      v43 = cinfo->dest;
      component_id = comp_info->component_id;
      v45 = v43->next_output_byte++;
      *v45 = component_id;
      v46 = v43->free_in_buffer - 1;
      v43->free_in_buffer = v46;
      if ( !v46 && !((int (__fastcall *)(j_compress_ptr))v43->empty_output_buffer)(cinfo) )
      {
        cinfo->err->msg_code = 24;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      v47 = cinfo->dest;
      v48 = *(_QWORD *)&comp_info->h_samp_factor;
      v49 = v47->next_output_byte++;
      *v49 = BYTE4(v48) + 16 * v48;
      v50 = v47->free_in_buffer - 1;
      v47->free_in_buffer = v50;
      if ( !v50 && !((int (__fastcall *)(j_compress_ptr))v47->empty_output_buffer)(cinfo) )
      {
        cinfo->err->msg_code = 24;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      v51 = cinfo->dest;
      quant_tbl_no = comp_info->quant_tbl_no;
      v53 = v51->next_output_byte++;
      *v53 = quant_tbl_no;
      v54 = v51->free_in_buffer - 1;
      v51->free_in_buffer = v54;
      if ( !v54 && !((int (__fastcall *)(j_compress_ptr))v51->empty_output_buffer)(cinfo) )
      {
        cinfo->err->msg_code = 24;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      ++v42;
      ++comp_info;
    }
    while ( v42 < cinfo->num_components );
  }
}

//----- (004797E6) --------------------------------------------------------
void __fastcall emit_dht(j_compress_ptr cinfo, int index, boolean is_ac)
{
  int v3; // r4
  jpeg_error_mgr **v5; // r0
  unsigned __int8 **v6; // r1
  unsigned __int8 *v7; // r9
  jpeg_destination_mgr *dest; // r0
  JOCTET *v9; // r1
  int v10; // r1
  jpeg_destination_mgr *v11; // r0
  JOCTET *v12; // r1
  int v13; // r1
  jpeg_destination_mgr *v14; // r3
  JOCTET *next_output_byte; // r4
  int v16; // r12
  int v17; // r0
  int v18; // lr
  int v19; // r5
  int v20; // r0
  jpeg_destination_mgr *v21; // r0
  JOCTET *v22; // r1
  int v23; // r1
  jpeg_destination_mgr *v24; // r0
  JOCTET *v25; // r1
  int v26; // r1
  int i; // r4
  jpeg_destination_mgr *v28; // r0
  unsigned __int8 v29; // r2
  JOCTET *v30; // r1
  int v31; // r1
  JOCTET *v32; // r6
  jpeg_destination_mgr *v33; // r0
  JOCTET v34; // r2
  JOCTET *v35; // r1
  int v36; // r1
  int v37; // [sp+0h] [bp-40h]
  int v38; // [sp+4h] [bp-3Ch]
  int v39; // [sp+8h] [bp-38h]
  int v40; // [sp+Ch] [bp-34h]
  int v41; // [sp+10h] [bp-30h]
  int v42; // [sp+14h] [bp-2Ch]
  int v43; // [sp+18h] [bp-28h]
  int v44; // [sp+1Ch] [bp-24h]
  JOCTET v45; // [sp+20h] [bp-20h]

  v3 = index;
  v5 = &cinfo->err + index;
  v6 = (unsigned __int8 **)(v5 + 26);
  if ( !is_ac )
    v6 = (unsigned __int8 **)(v5 + 22);
  v7 = *v6;
  if ( is_ac )
    v3 += 16;
  if ( !v7 )
  {
    cinfo->err->msg_code = 50;
    cinfo->err->msg_parm.i[0] = v3;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  if ( !v7[273] )
  {
    dest = cinfo->dest;
    v9 = dest->next_output_byte++;
    *v9 = -1;
    v10 = dest->free_in_buffer - 1;
    dest->free_in_buffer = v10;
    if ( !v10 && !((int (__fastcall *)(j_compress_ptr))dest->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v45 = v3;
    v11 = cinfo->dest;
    v12 = v11->next_output_byte++;
    *v12 = -60;
    v13 = v11->free_in_buffer - 1;
    v11->free_in_buffer = v13;
    if ( !v13 && !((int (__fastcall *)(j_compress_ptr))v11->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v44 = v7[16];
    v43 = v7[15];
    v42 = v7[14];
    v41 = v7[13];
    v40 = v7[12];
    v39 = v7[11];
    v38 = v7[10];
    v37 = v7[9];
    v14 = cinfo->dest;
    next_output_byte = v14->next_output_byte;
    v16 = v7[7];
    v17 = v7[1] + v7[2] + v7[3] + v7[4] + v7[5] + v7[6];
    v18 = v7[8];
    ++v14->next_output_byte;
    v19 = v17 + v16 + v18 + v37 + v38 + v39 + v40 + v41 + v42 + v43 + v44;
    *next_output_byte = (unsigned __int16)(v19 + 19) >> 8;
    v20 = v14->free_in_buffer - 1;
    v14->free_in_buffer = v20;
    if ( !v20 && !((int (__fastcall *)(j_compress_ptr))v14->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v21 = cinfo->dest;
    v22 = v21->next_output_byte++;
    *v22 = v19 + 19;
    v23 = v21->free_in_buffer - 1;
    v21->free_in_buffer = v23;
    if ( !v23 && !((int (__fastcall *)(j_compress_ptr))v21->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v24 = cinfo->dest;
    v25 = v24->next_output_byte++;
    *v25 = v45;
    v26 = v24->free_in_buffer - 1;
    v24->free_in_buffer = v26;
    if ( !v26 && !((int (__fastcall *)(j_compress_ptr))v24->empty_output_buffer)(cinfo) )
    {
      cinfo->err->msg_code = 24;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    for ( i = 0; i != 16; ++i )
    {
      v28 = cinfo->dest;
      v29 = v7[i + 1];
      v30 = v28->next_output_byte++;
      *v30 = v29;
      v31 = v28->free_in_buffer - 1;
      v28->free_in_buffer = v31;
      if ( !v31 && !((int (__fastcall *)(j_compress_ptr))v28->empty_output_buffer)(cinfo) )
      {
        cinfo->err->msg_code = 24;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
    }
    if ( v19 >= 1 )
    {
      v32 = v7 + 17;
      do
      {
        v33 = cinfo->dest;
        v34 = *v32;
        v35 = v33->next_output_byte++;
        *v35 = v34;
        v36 = v33->free_in_buffer - 1;
        v33->free_in_buffer = v36;
        if ( !v36 && !((int (__fastcall *)(j_compress_ptr))v33->empty_output_buffer)(cinfo) )
        {
          cinfo->err->msg_code = 24;
          cinfo->err->error_exit((j_common_ptr)cinfo);
        }
        ++v32;
        --v19;
      }
      while ( v19 );
    }
    v7[273] = 1;
  }
}

//----- (00479A40) --------------------------------------------------------
void __fastcall jinit_c_master_control(j_compress_ptr cinfo, boolean transcode_only)
{
  int v3; // r8
  int v4; // r9
  signed int image_height; // r0
  bool v6; // zf
  int num_components; // r1
  bool v8; // cc
  int v9; // r12
  int v10; // r1
  int v11; // r5
  int *p_h_samp_factor; // r6
  int max_h_samp_factor; // r2
  int v14; // r3
  int max_v_samp_factor; // r0
  int v16; // r6
  boolean *p_component_needed; // r5
  int v18; // r0
  int v19; // r1
  int v20; // r0
  int v21; // r2
  int v22; // r0
  int v23; // r2
  int v24; // r0
  const jpeg_scan_info *scan_info; // r1
  int v26; // r1
  boolean optimize_coding; // r0

  v3 = transcode_only;
  v4 = cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 32);
  cinfo->master = (jpeg_comp_master *)v4;
  *(_BYTE *)(v4 + 13) = 0;
  *(_DWORD *)v4 = prepare_for_pass;
  *(_DWORD *)(v4 + 4) = pass_startup;
  *(_DWORD *)(v4 + 8) = finish_pass_master;
  image_height = cinfo->image_height;
  v6 = image_height == 0;
  if ( image_height )
    v6 = cinfo->image_width == 0;
  if ( v6 )
    goto LABEL_8;
  num_components = cinfo->num_components;
  v8 = num_components <= 1;
  if ( num_components >= 1 )
    v8 = cinfo->input_components <= 0;
  if ( v8 )
  {
LABEL_8:
    cinfo->err->msg_code = 32;
    cinfo->err->error_exit((j_common_ptr)cinfo);
    image_height = cinfo->image_height;
  }
  if ( image_height > 65500 || (int)cinfo->image_width >= 65501 )
  {
    cinfo->err->msg_code = 41;
    cinfo->err->msg_parm.i[0] = 65500;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  if ( cinfo->data_precision != 8 )
  {
    cinfo->err->msg_code = 15;
    cinfo->err->msg_parm.i[0] = cinfo->data_precision;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v9 = cinfo->num_components;
  if ( v9 >= 5 )
  {
    cinfo->err->msg_code = 26;
    cinfo->err->msg_parm.i[0] = cinfo->num_components;
    cinfo->err->msg_parm.i[1] = 4;
    cinfo->err->error_exit((j_common_ptr)cinfo);
    v9 = cinfo->num_components;
  }
  v10 = 1;
  cinfo->max_h_samp_factor = 1;
  cinfo->max_v_samp_factor = 1;
  if ( v9 >= 1 )
  {
    v11 = 0;
    v10 = 1;
    p_h_samp_factor = &cinfo->comp_info->h_samp_factor;
    max_h_samp_factor = 1;
    do
    {
      v14 = *p_h_samp_factor;
      if ( (unsigned int)(*p_h_samp_factor - 1) > 3
        || (max_v_samp_factor = v10, (unsigned int)(p_h_samp_factor[1] - 1) >= 4) )
      {
        cinfo->err->msg_code = 18;
        cinfo->err->error_exit((j_common_ptr)cinfo);
        v9 = cinfo->num_components;
        max_v_samp_factor = cinfo->max_v_samp_factor;
        max_h_samp_factor = cinfo->max_h_samp_factor;
        v14 = *p_h_samp_factor;
      }
      ++v11;
      if ( max_h_samp_factor <= v14 )
        max_h_samp_factor = v14;
      cinfo->max_h_samp_factor = max_h_samp_factor;
      v10 = p_h_samp_factor[1];
      p_h_samp_factor += 21;
      if ( max_v_samp_factor > v10 )
        v10 = max_v_samp_factor;
      cinfo->max_v_samp_factor = v10;
    }
    while ( v11 < v9 );
    if ( v9 >= 1 )
    {
      v16 = 0;
      p_component_needed = &cinfo->comp_info->component_needed;
      do
      {
        *((_DWORD *)p_component_needed - 3) = 8;
        *((_DWORD *)p_component_needed - 11) = v16;
        v18 = jdiv_round_up(*((_DWORD *)p_component_needed - 10) * cinfo->image_width, 8 * cinfo->max_h_samp_factor);
        v19 = *((_DWORD *)p_component_needed - 9);
        *((_DWORD *)p_component_needed - 5) = v18;
        v20 = jdiv_round_up(cinfo->image_height * v19, 8 * cinfo->max_v_samp_factor);
        v21 = *((_DWORD *)p_component_needed - 10);
        *((_DWORD *)p_component_needed - 4) = v20;
        v22 = jdiv_round_up(cinfo->image_width * v21, cinfo->max_h_samp_factor);
        v23 = *((_DWORD *)p_component_needed - 9);
        *((_DWORD *)p_component_needed - 2) = v22;
        *((_DWORD *)p_component_needed - 1) = jdiv_round_up(cinfo->image_height * v23, cinfo->max_v_samp_factor);
        ++v16;
        *p_component_needed = 1;
        p_component_needed += 84;
      }
      while ( v16 < cinfo->num_components );
      v10 = cinfo->max_v_samp_factor;
    }
  }
  v24 = jdiv_round_up(cinfo->image_height, 8 * v10);
  scan_info = cinfo->scan_info;
  cinfo->total_iMCU_rows = v24;
  if ( scan_info )
  {
    cinfo->err->msg_code = 48;
    cinfo->err->error_exit((j_common_ptr)cinfo);
    if ( cinfo->progressive_mode )
      cinfo->optimize_coding = 1;
    if ( v3 )
      goto LABEL_34;
LABEL_38:
    *(_DWORD *)(v4 + 16) = 0;
    goto LABEL_39;
  }
  cinfo->num_scans = 1;
  cinfo->progressive_mode = 0;
  if ( !v3 )
    goto LABEL_38;
LABEL_34:
  v26 = 2;
  if ( cinfo->optimize_coding )
    v26 = 1;
  *(_DWORD *)(v4 + 16) = v26;
LABEL_39:
  *(_DWORD *)(v4 + 20) = 0;
  *(_DWORD *)(v4 + 28) = 0;
  optimize_coding = cinfo->optimize_coding;
  *(_DWORD *)(v4 + 24) = cinfo->num_scans << (optimize_coding != 0);
}

//----- (00479C90) --------------------------------------------------------
void __fastcall prepare_for_pass(j_compress_ptr cinfo)
{
  jpeg_comp_master *master; // r5
  void (*v3)(j_compress_ptr); // r0
  int v4; // r0
  int v5; // r1
  int v6; // r2
  char v7; // r6
  J_BUF_MODE v8; // r1
  int v9; // r0
  int v10; // r1
  int v11; // r2
  int v12; // r0
  int num_components; // r0
  int v14; // r1
  int v15; // r2
  __int64 v16; // r0

  master = cinfo->master;
  v3 = master[1].prepare_for_pass;
  if ( v3 == (void (*)(j_compress_ptr))((char *)&dword_0 + 2) )
  {
LABEL_27:
    if ( !cinfo->optimize_coding )
    {
      num_components = cinfo->num_components;
      if ( num_components >= 5 )
      {
        cinfo->err->msg_code = 26;
        cinfo->err->msg_parm.i[0] = cinfo->num_components;
        cinfo->err->msg_parm.i[1] = 4;
        cinfo->err->error_exit((j_common_ptr)cinfo);
        num_components = cinfo->num_components;
      }
      cinfo->comps_in_scan = num_components;
      if ( num_components >= 1 )
      {
        v14 = 0;
        v15 = 0;
        do
          cinfo->cur_comp_info[v15++] = &cinfo->comp_info[v14++];
        while ( v15 < cinfo->num_components );
      }
      *(_QWORD *)&cinfo->Ss = 0x3F00000000LL;
      *(_QWORD *)&cinfo->Ah = 0LL;
      per_scan_setup(cinfo);
    }
    v7 = 0;
    cinfo->entropy->start_pass(cinfo, 0);
    cinfo->coef->start_pass(cinfo, JBUF_CRANK_DEST);
    if ( !*(_DWORD *)&master[1].call_pass_startup )
      cinfo->marker->write_frame_header(cinfo);
    cinfo->marker->write_scan_header(cinfo);
    goto LABEL_37;
  }
  if ( v3 == (void (*)(j_compress_ptr))((char *)&dword_0 + 1) )
  {
    v9 = cinfo->num_components;
    if ( v9 >= 5 )
    {
      cinfo->err->msg_code = 26;
      cinfo->err->msg_parm.i[0] = cinfo->num_components;
      cinfo->err->msg_parm.i[1] = 4;
      cinfo->err->error_exit((j_common_ptr)cinfo);
      v9 = cinfo->num_components;
    }
    cinfo->comps_in_scan = v9;
    if ( v9 >= 1 )
    {
      v10 = 0;
      v11 = 0;
      do
        cinfo->cur_comp_info[v11++] = &cinfo->comp_info[v10++];
      while ( v11 < cinfo->num_components );
    }
    *(_QWORD *)&cinfo->Ss = 0x3F00000000LL;
    *(_QWORD *)&cinfo->Ah = 0LL;
    per_scan_setup(cinfo);
    if ( cinfo->Ss || !cinfo->Ah || cinfo->arith_code )
    {
      cinfo->entropy->start_pass(cinfo, 1);
      cinfo->coef->start_pass(cinfo, JBUF_CRANK_DEST);
      master->call_pass_startup = 0;
      goto LABEL_38;
    }
    v12 = (int)master[1].pass_startup + 1;
    master[1].prepare_for_pass = (void (*)(j_compress_ptr))(&dword_0 + 2);
    master[1].pass_startup = (void (*)(j_compress_ptr))v12;
    goto LABEL_27;
  }
  if ( v3 )
  {
    cinfo->err->msg_code = 48;
    cinfo->err->error_exit((j_common_ptr)cinfo);
    goto LABEL_38;
  }
  v4 = cinfo->num_components;
  if ( v4 >= 5 )
  {
    cinfo->err->msg_code = 26;
    cinfo->err->msg_parm.i[0] = cinfo->num_components;
    cinfo->err->msg_parm.i[1] = 4;
    cinfo->err->error_exit((j_common_ptr)cinfo);
    v4 = cinfo->num_components;
  }
  cinfo->comps_in_scan = v4;
  if ( v4 >= 1 )
  {
    v5 = 0;
    v6 = 0;
    do
      cinfo->cur_comp_info[v6++] = &cinfo->comp_info[v5++];
    while ( v6 < cinfo->num_components );
  }
  *(_QWORD *)&cinfo->Ss = 0x3F00000000LL;
  *(_QWORD *)&cinfo->Ah = 0LL;
  per_scan_setup(cinfo);
  if ( !cinfo->raw_data_in )
  {
    cinfo->cconvert->start_pass(cinfo);
    cinfo->downsample->start_pass(cinfo);
    cinfo->prep->start_pass(cinfo, JBUF_PASS_THRU);
  }
  cinfo->fdct->start_pass(cinfo);
  cinfo->entropy->start_pass(cinfo, cinfo->optimize_coding);
  v7 = 0;
  v8 = JBUF_PASS_THRU;
  if ( (int)master[1].finish_pass > 1 )
    v8 = JBUF_SAVE_AND_PASS;
  cinfo->coef->start_pass(cinfo, v8);
  cinfo->main->start_pass(cinfo, JBUF_PASS_THRU);
  if ( !cinfo->optimize_coding )
    v7 = 1;
LABEL_37:
  master->call_pass_startup = v7;
LABEL_38:
  v16 = *(_QWORD *)&master[1].pass_startup;
  master->is_last_pass = (_DWORD)v16 == HIDWORD(v16) - 1;
  HIDWORD(v16) = cinfo->progress;
  if ( HIDWORD(v16) )
  {
    *(_DWORD *)(HIDWORD(v16) + 12) = v16;
    cinfo->progress->total_passes = (int)master[1].finish_pass;
  }
}
// 0: using guessed type int dword_0;

//----- (00479EF0) --------------------------------------------------------
void __fastcall pass_startup(j_compress_ptr cinfo)
{
  cinfo->master->call_pass_startup = 0;
  cinfo->marker->write_frame_header(cinfo);
  cinfo->marker->write_scan_header(cinfo);
}

//----- (00479F16) --------------------------------------------------------
void __fastcall finish_pass_master(j_compress_ptr cinfo)
{
  jpeg_comp_master *master; // r5
  void (*prepare_for_pass)(j_compress_ptr); // r0

  master = cinfo->master;
  cinfo->entropy->finish_pass(cinfo);
  prepare_for_pass = master[1].prepare_for_pass;
  if ( prepare_for_pass == (void (*)(j_compress_ptr))((char *)&dword_0 + 2) )
  {
    if ( cinfo->optimize_coding )
      master[1].prepare_for_pass = (void (*)(j_compress_ptr))(&dword_0 + 1);
LABEL_8:
    ++*(_DWORD *)&master[1].call_pass_startup;
    goto LABEL_10;
  }
  if ( prepare_for_pass == (void (*)(j_compress_ptr))((char *)&dword_0 + 1) )
  {
    master[1].prepare_for_pass = (void (*)(j_compress_ptr))(&dword_0 + 2);
    goto LABEL_10;
  }
  if ( !prepare_for_pass )
  {
    master[1].prepare_for_pass = (void (*)(j_compress_ptr))(&dword_0 + 2);
    if ( !cinfo->optimize_coding )
      goto LABEL_8;
  }
LABEL_10:
  ++master[1].pass_startup;
}
// 0: using guessed type int dword_0;

//----- (00479F70) --------------------------------------------------------
void __fastcall per_scan_setup(j_compress_ptr cinfo)
{
  int comps_in_scan; // r0
  jpeg_component_info *v3; // r6
  unsigned int v_samp_factor; // r5
  JDIMENSION height_in_blocks; // r0
  int v6; // r1
  int v7; // r0
  int max_v_samp_factor; // r1
  int image_height; // r2
  int v10; // r0
  int v11; // r1
  int v12; // r6
  jpeg_component_info *v13; // r10
  __int64 v14; // kr00_8
  __int64 v15; // kr08_8
  int v16; // r11
  __int64 v17; // r0
  int v18; // r1
  int v19; // r0
  int blocks_in_MCU; // r1
  int restart_in_rows; // r0
  signed int v22; // r0
  unsigned int v23; // r1

  comps_in_scan = cinfo->comps_in_scan;
  if ( comps_in_scan == 1 )
  {
    v3 = cinfo->cur_comp_info[0];
    cinfo->MCUs_per_row = v3->width_in_blocks;
    cinfo->MCU_rows_in_scan = v3->height_in_blocks;
    *(_QWORD *)&v3->MCU_width = 0x100000001LL;
    *(_QWORD *)&v3->MCU_blocks = 0x800000001LL;
    v_samp_factor = v3->v_samp_factor;
    height_in_blocks = v3->height_in_blocks;
    v3->last_col_width = 1;
    v6 = height_in_blocks % v_samp_factor;
    if ( !(height_in_blocks % v_samp_factor) )
      v6 = v_samp_factor;
    v3->last_row_height = v6;
    cinfo->blocks_in_MCU = 1;
    cinfo->MCU_membership[0] = 0;
  }
  else
  {
    if ( (unsigned int)(comps_in_scan - 1) >= 4 )
    {
      cinfo->err->msg_code = 26;
      cinfo->err->msg_parm.i[0] = cinfo->comps_in_scan;
      cinfo->err->msg_parm.i[1] = 4;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v7 = jdiv_round_up(cinfo->image_width, 8 * cinfo->max_h_samp_factor);
    max_v_samp_factor = cinfo->max_v_samp_factor;
    image_height = cinfo->image_height;
    cinfo->MCUs_per_row = v7;
    v10 = jdiv_round_up(image_height, 8 * max_v_samp_factor);
    v11 = cinfo->comps_in_scan;
    cinfo->MCU_rows_in_scan = v10;
    cinfo->blocks_in_MCU = 0;
    if ( v11 >= 1 )
    {
      v12 = 0;
      do
      {
        v13 = cinfo->cur_comp_info[v12];
        v14 = *(_QWORD *)&v13->h_samp_factor;
        v15 = *(_QWORD *)&v13->width_in_blocks;
        *(_QWORD *)&v13->MCU_width = v14;
        v16 = HIDWORD(v14) * v14;
        HIDWORD(v17) = (unsigned int)v15 % (unsigned int)v14;
        if ( !((unsigned int)v15 % (unsigned int)v14) )
          HIDWORD(v17) = v14;
        LODWORD(v17) = 8 * v14;
        *(_QWORD *)&v13->MCU_sample_width = v17;
        v18 = HIDWORD(v15) % HIDWORD(v14);
        if ( !(HIDWORD(v15) % HIDWORD(v14)) )
          v18 = HIDWORD(v14);
        v13->last_row_height = v18;
        v13->MCU_blocks = v16;
        if ( cinfo->blocks_in_MCU + HIDWORD(v14) * (int)v14 >= 11 )
        {
          cinfo->err->msg_code = 13;
          cinfo->err->error_exit((j_common_ptr)cinfo);
        }
        if ( v16 >= 1 )
        {
          v19 = v16 + 1;
          do
          {
            blocks_in_MCU = cinfo->blocks_in_MCU;
            --v19;
            cinfo->blocks_in_MCU = blocks_in_MCU + 1;
            cinfo->MCU_membership[blocks_in_MCU] = v12;
          }
          while ( v19 > 1 );
        }
        ++v12;
      }
      while ( v12 < cinfo->comps_in_scan );
    }
  }
  restart_in_rows = cinfo->restart_in_rows;
  if ( restart_in_rows >= 1 )
  {
    v22 = restart_in_rows * cinfo->MCUs_per_row;
    v23 = 0xFFFF;
    if ( v22 < 0xFFFF )
      v23 = v22;
    cinfo->restart_interval = v23;
  }
}

//----- (0047A0E0) --------------------------------------------------------
void __fastcall jpeg_abort(j_common_ptr cinfo)
{
  jpeg_memory_mgr *mem; // r0
  int v3; // r0

  mem = cinfo->mem;
  if ( mem )
  {
    mem->free_pool(cinfo, 1);
    if ( cinfo->is_decompressor )
    {
      cinfo[11].mem = 0;
      v3 = 200;
    }
    else
    {
      v3 = 100;
    }
    cinfo->global_state = v3;
  }
}

//----- (0047A10A) --------------------------------------------------------
void __fastcall jpeg_destroy(j_common_ptr cinfo)
{
  jpeg_memory_mgr *mem; // r0

  mem = cinfo->mem;
  if ( mem )
    mem->self_destruct(cinfo);
  cinfo->global_state = 0;
  cinfo->mem = 0;
}

//----- (0047A124) --------------------------------------------------------
JQUANT_TBL *__fastcall jpeg_alloc_quant_table(j_common_ptr cinfo)
{
  JQUANT_TBL *result; // r0

  result = (JQUANT_TBL *)cinfo->mem->alloc_small(cinfo, 0, 130);
  result->sent_table = 0;
  return result;
}

//----- (0047A13A) --------------------------------------------------------
JHUFF_TBL *__fastcall jpeg_alloc_huff_table(j_common_ptr cinfo)
{
  JHUFF_TBL *result; // r0

  result = (JHUFF_TBL *)cinfo->mem->alloc_small(cinfo, 0, 274);
  result->sent_table = 0;
  return result;
}

//----- (0047A160) --------------------------------------------------------
void __fastcall jpeg_add_quant_table(
        j_compress_ptr cinfo,
        int which_tbl,
        const unsigned int *basic_table,
        int scale_factor,
        int a5)
{
  jpeg_error_mgr **v9; // r6
  JQUANT_TBL *v10; // r0
  JQUANT_TBL **v11; // r6
  JQUANT_TBL *v12; // t1
  int i; // r2
  int v14; // r3
  __int16 v15; // r4

  if ( cinfo->global_state != 100 )
  {
    cinfo->err->msg_code = 20;
    cinfo->err->msg_parm.i[0] = cinfo->global_state;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  if ( (unsigned int)which_tbl >= 4 )
  {
    cinfo->err->msg_code = 31;
    cinfo->err->msg_parm.i[0] = which_tbl;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v9 = &cinfo->err + which_tbl;
  v12 = (JQUANT_TBL *)v9[18];
  v11 = (JQUANT_TBL **)(v9 + 18);
  v10 = v12;
  if ( !v12 )
  {
    v10 = jpeg_alloc_quant_table((j_common_ptr)cinfo);
    *v11 = v10;
  }
  for ( i = 0; i != 64; ++i )
  {
    v14 = (signed int)(basic_table[i] * scale_factor + 50) / 100;
    if ( v14 <= 1 )
      v14 = 1;
    if ( v14 >= 0x7FFF )
      v14 = 0x7FFF;
    v15 = v14;
    if ( v14 > 255 )
      v15 = 255;
    if ( !a5 )
      v15 = v14;
    v10->quantval[i] = v15;
    v10 = *v11;
  }
  v10->sent_table = 0;
}

//----- (0047A220) --------------------------------------------------------
void __fastcall jpeg_set_linear_quality(j_compress_ptr cinfo, int scale_factor, boolean force_baseline)
{
  int v4; // r9
  JQUANT_TBL *v6; // r0
  int i; // r1
  int v8; // r2
  __int16 v9; // r4
  JQUANT_TBL *v10; // r0
  int j; // r1
  int v12; // r2
  __int16 v13; // r4

  v4 = force_baseline;
  if ( cinfo->global_state != 100 )
  {
    cinfo->err->msg_code = 20;
    cinfo->err->msg_parm.i[0] = cinfo->global_state;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v6 = cinfo->quant_tbl_ptrs[0];
  if ( !v6 )
  {
    v6 = jpeg_alloc_quant_table((j_common_ptr)cinfo);
    cinfo->quant_tbl_ptrs[0] = v6;
  }
  for ( i = 0; i != 64; ++i )
  {
    v8 = (signed int)(jpeg_set_linear_quality(jpeg_compress_struct *,int,unsigned char)::std_luminance_quant_tbl[i]
                    * scale_factor
                    + 50)
       / 100;
    if ( v8 <= 1 )
      v8 = 1;
    if ( v8 >= 0x7FFF )
      v8 = 0x7FFF;
    v9 = v8;
    if ( v8 > 255 )
      v9 = 255;
    if ( !v4 )
      v9 = v8;
    v6->quantval[i] = v9;
    v6 = cinfo->quant_tbl_ptrs[0];
  }
  v6->sent_table = 0;
  if ( cinfo->global_state != 100 )
  {
    cinfo->err->msg_code = 20;
    cinfo->err->msg_parm.i[0] = cinfo->global_state;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v10 = cinfo->quant_tbl_ptrs[1];
  if ( !v10 )
  {
    v10 = jpeg_alloc_quant_table((j_common_ptr)cinfo);
    cinfo->quant_tbl_ptrs[1] = v10;
  }
  for ( j = 0; j != 64; ++j )
  {
    v12 = (signed int)(jpeg_set_linear_quality(jpeg_compress_struct *,int,unsigned char)::std_chrominance_quant_tbl[j]
                     * scale_factor
                     + 50)
        / 100;
    if ( v12 <= 1 )
      v12 = 1;
    if ( v12 >= 0x7FFF )
      v12 = 0x7FFF;
    v13 = v12;
    if ( v12 > 255 )
      v13 = 255;
    if ( !v4 )
      v13 = v12;
    v10->quantval[j] = v13;
    v10 = cinfo->quant_tbl_ptrs[1];
  }
  v10->sent_table = 0;
}

//----- (0047A328) --------------------------------------------------------
int __fastcall jpeg_quality_scaling(int quality)
{
  int v1; // r1

  v1 = quality;
  if ( quality <= 1 )
    v1 = 1;
  if ( v1 >= 100 )
    v1 = 100;
  if ( v1 <= 49 )
    return 0x1388u / v1;
  else
    return 200 - 2 * v1;
}

//----- (0047A350) --------------------------------------------------------
void __fastcall jpeg_set_quality(j_compress_ptr cinfo, int quality, boolean force_baseline)
{
  int v3; // r1

  if ( quality <= 1 )
    quality = 1;
  if ( quality >= 100 )
    quality = 100;
  if ( quality > 49 )
    v3 = 200 - 2 * quality;
  else
    v3 = 0x1388u / quality;
  jpeg_set_linear_quality(cinfo, v3, force_baseline);
}

//----- (0047A384) --------------------------------------------------------
void __fastcall jpeg_set_defaults(j_compress_ptr cinfo)
{
  boolean v2; // r0
  int data_precision; // r2

  if ( cinfo->global_state != 100 )
  {
    cinfo->err->msg_code = 20;
    cinfo->err->msg_parm.i[0] = cinfo->global_state;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  if ( !cinfo->comp_info )
    cinfo->comp_info = (jpeg_component_info *)cinfo->mem->alloc_small((j_common_ptr)cinfo, 0, 336);
  cinfo->data_precision = 8;
  jpeg_set_linear_quality(cinfo, 50, 1u);
  add_huff_table(
    cinfo,
    cinfo->dc_huff_tbl_ptrs,
    std_huff_tables(jpeg_compress_struct *)::bits_dc_luminance,
    std_huff_tables(jpeg_compress_struct *)::val_dc_luminance);
  add_huff_table(
    cinfo,
    cinfo->ac_huff_tbl_ptrs,
    std_huff_tables(jpeg_compress_struct *)::bits_ac_luminance,
    std_huff_tables(jpeg_compress_struct *)::val_ac_luminance);
  add_huff_table(
    cinfo,
    &cinfo->dc_huff_tbl_ptrs[1],
    std_huff_tables(jpeg_compress_struct *)::bits_dc_chrominance,
    std_huff_tables(jpeg_compress_struct *)::val_dc_chrominance);
  add_huff_table(
    cinfo,
    &cinfo->ac_huff_tbl_ptrs[1],
    std_huff_tables(jpeg_compress_struct *)::bits_ac_chrominance,
    std_huff_tables(jpeg_compress_struct *)::val_ac_chrominance);
  v2 = 0;
  *(_DWORD *)cinfo->arith_dc_L = 0;
  *(_DWORD *)cinfo->arith_dc_U = 16843009;
  *(_DWORD *)cinfo->arith_ac_K = 84215045;
  cinfo->arith_ac_K[4] = 5;
  *(_WORD *)&cinfo->arith_dc_L[4] = 0;
  *(_WORD *)&cinfo->arith_dc_U[4] = 257;
  cinfo->arith_ac_K[5] = 5;
  cinfo->arith_dc_U[6] = 1;
  cinfo->arith_ac_K[6] = 5;
  cinfo->arith_dc_U[7] = 1;
  cinfo->arith_ac_K[7] = 5;
  cinfo->arith_dc_U[8] = 1;
  cinfo->arith_ac_K[8] = 5;
  *(_DWORD *)&cinfo->arith_dc_L[6] = 0;
  cinfo->arith_dc_U[9] = 1;
  cinfo->arith_ac_K[9] = 5;
  cinfo->arith_dc_L[10] = 0;
  cinfo->arith_ac_K[10] = 5;
  cinfo->arith_dc_U[10] = 1;
  cinfo->arith_dc_L[11] = 0;
  cinfo->arith_dc_U[11] = 1;
  cinfo->arith_ac_K[11] = 5;
  cinfo->arith_dc_L[12] = 0;
  cinfo->arith_dc_U[12] = 1;
  cinfo->arith_ac_K[12] = 5;
  cinfo->arith_dc_L[13] = 0;
  cinfo->arith_dc_U[13] = 1;
  cinfo->arith_ac_K[13] = 5;
  cinfo->arith_dc_L[14] = 0;
  cinfo->arith_dc_U[14] = 1;
  cinfo->arith_ac_K[14] = 5;
  cinfo->arith_dc_L[15] = 0;
  cinfo->arith_dc_U[15] = 1;
  cinfo->arith_ac_K[15] = 5;
  cinfo->optimize_coding = 0;
  *(_WORD *)&cinfo->raw_data_in = 0;
  data_precision = cinfo->data_precision;
  *(_QWORD *)&cinfo->CCIR601_sampling = 0LL;
  *(_QWORD *)((char *)&cinfo->dct_method + 3) = 0LL;
  HIBYTE(cinfo->restart_in_rows) = 0;
  cinfo->num_scans = 0;
  cinfo->scan_info = 0;
  *(_WORD *)&cinfo->JFIF_major_version = 257;
  cinfo->density_unit = 0;
  cinfo->X_density = 1;
  cinfo->Y_density = 1;
  if ( data_precision > 8 )
    v2 = 1;
  cinfo->optimize_coding = v2;
  jpeg_default_colorspace(cinfo);
}
// 61D110: using guessed type UINT8 std_huff_tables(jpeg_compress_struct *)::bits_dc_luminance[17];
// 61D121: using guessed type UINT8 std_huff_tables(jpeg_compress_struct *)::val_dc_luminance[12];
// 61D12D: using guessed type UINT8 std_huff_tables(jpeg_compress_struct *)::bits_dc_chrominance[17];
// 61D13E: using guessed type UINT8 std_huff_tables(jpeg_compress_struct *)::val_dc_chrominance[12];
// 61D14A: using guessed type UINT8 std_huff_tables(jpeg_compress_struct *)::bits_ac_luminance[17];
// 61D15B: using guessed type UINT8 std_huff_tables(jpeg_compress_struct *)::val_ac_luminance[162];
// 61D1FD: using guessed type UINT8 std_huff_tables(jpeg_compress_struct *)::bits_ac_chrominance[17];
// 61D20E: using guessed type UINT8 std_huff_tables(jpeg_compress_struct *)::val_ac_chrominance[162];

//----- (0047A510) --------------------------------------------------------
void __fastcall jpeg_default_colorspace(j_compress_ptr cinfo)
{
  jpeg_component_info *v2; // r2
  jpeg_component_info *v3; // r0
  jpeg_component_info *v4; // r0
  int input_components; // r0
  int v6; // r1
  int v7; // r0
  jpeg_component_info *comp_info; // r2
  jpeg_component_info *v9; // r2
  jpeg_component_info *v10; // r1
  __int64 v11; // d16
  jpeg_component_info *v12; // r2
  jpeg_component_info *v13; // r1
  jpeg_component_info *v14; // r1
  jpeg_component_info *v15; // r1
  jpeg_component_info *v16; // r3
  jpeg_component_info *v17; // r1
  jpeg_component_info *v18; // r1

  switch ( cinfo->in_color_space )
  {
    case JCS_UNKNOWN:
      if ( cinfo->global_state != 100 )
      {
        cinfo->err->msg_code = 20;
        cinfo->err->msg_parm.i[0] = cinfo->global_state;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      input_components = cinfo->input_components;
      cinfo->write_JFIF_header = 0;
      cinfo->write_Adobe_marker = 0;
      cinfo->num_components = input_components;
      cinfo->jpeg_color_space = JCS_UNKNOWN;
      if ( (unsigned int)(input_components - 1) < 4
        || (cinfo->err->msg_code = 26,
            cinfo->err->msg_parm.i[0] = cinfo->num_components,
            cinfo->err->msg_parm.i[1] = 4,
            cinfo->err->error_exit((j_common_ptr)cinfo),
            cinfo->num_components >= 1) )
      {
        v6 = 0;
        v7 = 0;
        do
        {
          comp_info = cinfo->comp_info;
          comp_info[v7].component_id = v6;
          v9 = &comp_info[v7++];
          v9->ac_tbl_no = 0;
          v9 = (jpeg_component_info *)((char *)v9 + 8);
          ++v6;
          *(_QWORD *)&v9->component_id = 0x100000001LL;
          *(_QWORD *)&v9->h_samp_factor = 0LL;
        }
        while ( v6 < cinfo->num_components );
      }
      break;
    case JCS_GRAYSCALE:
      if ( cinfo->global_state != 100 )
      {
        cinfo->err->msg_code = 20;
        cinfo->err->msg_parm.i[0] = cinfo->global_state;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      cinfo->write_Adobe_marker = 0;
      v10 = cinfo->comp_info;
      cinfo->write_JFIF_header = 1;
      cinfo->num_components = 1;
      cinfo->jpeg_color_space = JCS_GRAYSCALE;
      v10->component_id = 1;
      v10->ac_tbl_no = 0;
      *(_QWORD *)&v10->h_samp_factor = 0x100000001LL;
      *(_QWORD *)&v10->quant_tbl_no = 0LL;
      break;
    case JCS_RGB:
    case JCS_YCbCr:
      if ( cinfo->global_state != 100 )
      {
        cinfo->err->msg_code = 20;
        cinfo->err->msg_parm.i[0] = cinfo->global_state;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      cinfo->write_Adobe_marker = 0;
      v2 = cinfo->comp_info;
      cinfo->write_JFIF_header = 1;
      cinfo->num_components = 3;
      cinfo->jpeg_color_space = JCS_YCbCr;
      v2->component_id = 1;
      v2->ac_tbl_no = 0;
      *(_QWORD *)&v2->h_samp_factor = 0x200000002LL;
      *(_QWORD *)&v2->quant_tbl_no = 0LL;
      v3 = cinfo->comp_info;
      v3[1].ac_tbl_no = 1;
      v3[1].component_id = 2;
      v3 = (jpeg_component_info *)((char *)v3 + 92);
      *(_QWORD *)&v3->component_id = 0x100000001LL;
      *(_QWORD *)&v3->h_samp_factor = 0x100000001LL;
      v4 = cinfo->comp_info;
      v4[2].ac_tbl_no = 1;
      v4[2].component_id = 3;
      v4 = (jpeg_component_info *)((char *)v4 + 176);
      *(_QWORD *)&v4->component_id = 0x100000001LL;
      *(_QWORD *)&v4->h_samp_factor = 0x100000001LL;
      break;
    case JCS_CMYK:
      if ( cinfo->global_state != 100 )
      {
        cinfo->err->msg_code = 20;
        cinfo->err->msg_parm.i[0] = cinfo->global_state;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      v11 = 0x100000001LL;
      cinfo->write_JFIF_header = 0;
      v12 = cinfo->comp_info;
      cinfo->write_Adobe_marker = 1;
      cinfo->num_components = 4;
      cinfo->jpeg_color_space = JCS_CMYK;
      v12->component_id = 67;
      v12->ac_tbl_no = 0;
      *(_QWORD *)&v12->h_samp_factor = 0x100000001LL;
      *(_QWORD *)&v12->quant_tbl_no = 0LL;
      v13 = cinfo->comp_info;
      v13[1].ac_tbl_no = 0;
      v13[1].component_id = 77;
      v13 = (jpeg_component_info *)((char *)v13 + 92);
      *(_QWORD *)&v13->component_id = 0x100000001LL;
      *(_QWORD *)&v13->h_samp_factor = 0LL;
      v14 = cinfo->comp_info;
      v14[2].ac_tbl_no = 0;
      v14[2].component_id = 89;
      v14 = (jpeg_component_info *)((char *)v14 + 176);
      *(_QWORD *)&v14->component_id = 0x100000001LL;
      *(_QWORD *)&v14->h_samp_factor = 0LL;
      v15 = cinfo->comp_info;
      v15[3].ac_tbl_no = 0;
      v15[3].component_id = 75;
      goto LABEL_21;
    case JCS_YCCK:
      if ( cinfo->global_state != 100 )
      {
        cinfo->err->msg_code = 20;
        cinfo->err->msg_parm.i[0] = cinfo->global_state;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      v11 = 0x200000002LL;
      cinfo->write_JFIF_header = 0;
      v16 = cinfo->comp_info;
      cinfo->write_Adobe_marker = 1;
      cinfo->num_components = 4;
      cinfo->jpeg_color_space = JCS_YCCK;
      v16->component_id = 1;
      v16->ac_tbl_no = 0;
      *(_QWORD *)&v16->h_samp_factor = 0x200000002LL;
      *(_QWORD *)&v16->quant_tbl_no = 0LL;
      v17 = cinfo->comp_info;
      v17[1].ac_tbl_no = 1;
      v17[1].component_id = 2;
      v17 = (jpeg_component_info *)((char *)v17 + 92);
      *(_QWORD *)&v17->component_id = 0x100000001LL;
      *(_QWORD *)&v17->h_samp_factor = 0x100000001LL;
      v18 = cinfo->comp_info;
      v18[2].ac_tbl_no = 1;
      v18[2].component_id = 3;
      v18 = (jpeg_component_info *)((char *)v18 + 176);
      *(_QWORD *)&v18->component_id = 0x100000001LL;
      *(_QWORD *)&v18->h_samp_factor = 0x100000001LL;
      v15 = cinfo->comp_info;
      v15[3].ac_tbl_no = 0;
      v15[3].component_id = 4;
LABEL_21:
      *(_QWORD *)&v15[3].h_samp_factor = v11;
      *(_QWORD *)&v15[3].quant_tbl_no = 0LL;
      break;
    default:
      cinfo->err->msg_code = 9;
      cinfo->err->error_exit((j_common_ptr)cinfo);
      break;
  }
}

//----- (0047A760) --------------------------------------------------------
void __fastcall jpeg_set_colorspace(j_compress_ptr cinfo, J_COLOR_SPACE colorspace)
{
  int input_components; // r0
  int v5; // r1
  int v6; // r2
  jpeg_component_info *comp_info; // r3
  jpeg_component_info *v8; // r3
  jpeg_component_info *v9; // r0
  jpeg_component_info *v10; // r0
  jpeg_component_info *v11; // r0
  jpeg_component_info *v12; // r0
  jpeg_component_info *v13; // r1
  jpeg_component_info *v14; // r1
  jpeg_component_info *v15; // r1
  jpeg_component_info *v16; // r0
  jpeg_component_info *v17; // r0
  jpeg_component_info *v18; // r0
  jpeg_component_info *v19; // r0
  jpeg_component_info *v20; // r1
  jpeg_component_info *v21; // r1
  jpeg_component_info *v22; // r1
  jpeg_component_info *v23; // r1

  if ( cinfo->global_state != 100 )
  {
    cinfo->err->msg_code = 20;
    cinfo->err->msg_parm.i[0] = cinfo->global_state;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  cinfo->write_JFIF_header = 0;
  cinfo->jpeg_color_space = colorspace;
  cinfo->write_Adobe_marker = 0;
  switch ( colorspace )
  {
    case JCS_UNKNOWN:
      input_components = cinfo->input_components;
      cinfo->num_components = input_components;
      if ( (unsigned int)(input_components - 1) < 4
        || (cinfo->err->msg_code = 26,
            cinfo->err->msg_parm.i[0] = cinfo->num_components,
            cinfo->err->msg_parm.i[1] = 4,
            cinfo->err->error_exit((j_common_ptr)cinfo),
            cinfo->num_components >= 1) )
      {
        v5 = 0;
        v6 = 0;
        do
        {
          comp_info = cinfo->comp_info;
          comp_info[v5].component_id = v6;
          v8 = &comp_info[v5++];
          v8->ac_tbl_no = 0;
          v8 = (jpeg_component_info *)((char *)v8 + 8);
          ++v6;
          *(_QWORD *)&v8->component_id = 0x100000001LL;
          *(_QWORD *)&v8->h_samp_factor = 0LL;
        }
        while ( v6 < cinfo->num_components );
      }
      break;
    case JCS_GRAYSCALE:
      v9 = cinfo->comp_info;
      cinfo->num_components = 1;
      cinfo->write_JFIF_header = 1;
      v9->component_id = 1;
      v9->ac_tbl_no = 0;
      v9 = (jpeg_component_info *)((char *)v9 + 8);
      *(_QWORD *)&v9->component_id = 0x100000001LL;
      *(_QWORD *)&v9->h_samp_factor = 0LL;
      break;
    case JCS_RGB:
      cinfo->num_components = 3;
      v10 = cinfo->comp_info;
      cinfo->write_Adobe_marker = 1;
      v10->component_id = 82;
      v10->ac_tbl_no = 0;
      v10 = (jpeg_component_info *)((char *)v10 + 8);
      *(_QWORD *)&v10->component_id = 0x100000001LL;
      *(_QWORD *)&v10->h_samp_factor = 0LL;
      v11 = cinfo->comp_info;
      v11[1].ac_tbl_no = 0;
      v11[1].component_id = 71;
      v11 = (jpeg_component_info *)((char *)v11 + 92);
      *(_QWORD *)&v11->component_id = 0x100000001LL;
      *(_QWORD *)&v11->h_samp_factor = 0LL;
      v12 = cinfo->comp_info;
      v12[2].ac_tbl_no = 0;
      v12[2].component_id = 66;
      v12 = (jpeg_component_info *)((char *)v12 + 176);
      *(_QWORD *)&v12->component_id = 0x100000001LL;
      *(_QWORD *)&v12->h_samp_factor = 0LL;
      break;
    case JCS_YCbCr:
      cinfo->num_components = 3;
      v13 = cinfo->comp_info;
      cinfo->write_JFIF_header = 1;
      v13->component_id = 1;
      v13->ac_tbl_no = 0;
      v13 = (jpeg_component_info *)((char *)v13 + 8);
      *(_QWORD *)&v13->component_id = 0x200000002LL;
      *(_QWORD *)&v13->h_samp_factor = 0LL;
      v14 = cinfo->comp_info;
      v14[1].ac_tbl_no = 1;
      v14[1].component_id = 2;
      v14 = (jpeg_component_info *)((char *)v14 + 92);
      *(_QWORD *)&v14->component_id = 0x100000001LL;
      *(_QWORD *)&v14->h_samp_factor = 0x100000001LL;
      v15 = cinfo->comp_info;
      v15[2].ac_tbl_no = 1;
      v15[2].component_id = 3;
      *(_QWORD *)&v15[2].h_samp_factor = 0x100000001LL;
      *(_QWORD *)&v15[2].quant_tbl_no = 0x100000001LL;
      break;
    case JCS_CMYK:
      cinfo->num_components = 4;
      v16 = cinfo->comp_info;
      cinfo->write_Adobe_marker = 1;
      v16->component_id = 67;
      v16->ac_tbl_no = 0;
      v16 = (jpeg_component_info *)((char *)v16 + 8);
      *(_QWORD *)&v16->component_id = 0x100000001LL;
      *(_QWORD *)&v16->h_samp_factor = 0LL;
      v17 = cinfo->comp_info;
      v17[1].ac_tbl_no = 0;
      v17[1].component_id = 77;
      v17 = (jpeg_component_info *)((char *)v17 + 92);
      *(_QWORD *)&v17->component_id = 0x100000001LL;
      *(_QWORD *)&v17->h_samp_factor = 0LL;
      v18 = cinfo->comp_info;
      v18[2].ac_tbl_no = 0;
      v18[2].component_id = 89;
      v18 = (jpeg_component_info *)((char *)v18 + 176);
      *(_QWORD *)&v18->component_id = 0x100000001LL;
      *(_QWORD *)&v18->h_samp_factor = 0LL;
      v19 = cinfo->comp_info;
      v19[3].ac_tbl_no = 0;
      v19[3].component_id = 75;
      v19 = (jpeg_component_info *)((char *)v19 + 260);
      *(_QWORD *)&v19->component_id = 0x100000001LL;
      *(_QWORD *)&v19->h_samp_factor = 0LL;
      break;
    case JCS_YCCK:
      cinfo->num_components = 4;
      v20 = cinfo->comp_info;
      cinfo->write_Adobe_marker = 1;
      v20->component_id = 1;
      v20->ac_tbl_no = 0;
      v20 = (jpeg_component_info *)((char *)v20 + 8);
      *(_QWORD *)&v20->component_id = 0x200000002LL;
      *(_QWORD *)&v20->h_samp_factor = 0LL;
      v21 = cinfo->comp_info;
      v21[1].ac_tbl_no = 1;
      v21[1].component_id = 2;
      v21 = (jpeg_component_info *)((char *)v21 + 92);
      *(_QWORD *)&v21->component_id = 0x100000001LL;
      *(_QWORD *)&v21->h_samp_factor = 0x100000001LL;
      v22 = cinfo->comp_info;
      v22[2].ac_tbl_no = 1;
      v22[2].component_id = 3;
      v22 = (jpeg_component_info *)((char *)v22 + 176);
      *(_QWORD *)&v22->component_id = 0x100000001LL;
      *(_QWORD *)&v22->h_samp_factor = 0x100000001LL;
      v23 = cinfo->comp_info;
      v23[3].ac_tbl_no = 0;
      v23[3].component_id = 4;
      *(_QWORD *)&v23[3].h_samp_factor = 0x200000002LL;
      *(_QWORD *)&v23[3].quant_tbl_no = 0LL;
      break;
    default:
      cinfo->err->msg_code = 10;
      cinfo->err->error_exit((j_common_ptr)cinfo);
      break;
  }
}

//----- (0047A980) --------------------------------------------------------
void __fastcall add_huff_table(j_compress_ptr cinfo, JHUFF_TBL **htblptr, const UINT8 *bits, const UINT8 *val)
{
  JHUFF_TBL *v6; // r0
  __int64 v9; // d17
  uint16x8_t v10; // q9
  uint16x8_t v11; // q8
  int8x16_t v12; // q8
  int32x4_t v13; // q8
  size_t v14; // d16.s[0]

  v6 = *htblptr;
  if ( !*htblptr )
  {
    v6 = jpeg_alloc_huff_table((j_common_ptr)cinfo);
    *htblptr = v6;
  }
  v9 = *((_QWORD *)bits + 1);
  *(_QWORD *)v6->bits = *(_QWORD *)bits;
  *(_QWORD *)&v6->bits[8] = v9;
  v6->bits[16] = bits[16];
  v10 = vmovl_u8(*(uint8x8_t *)(bits + 1));
  v11 = vmovl_u8(*(uint8x8_t *)(bits + 9));
  v12 = vaddq_s32(
          vaddl_u16((uint16x4_t)v11.n128_u64[0], (uint16x4_t)v10.n128_u64[0]),
          vaddl_u16(*(uint16x4_t *)&v11.n128_i8[8], *(uint16x4_t *)&v10.n128_i8[8]));
  v13 = vaddq_s32(v12, vextq_s8(v12, v12, 8u));
  v14 = vaddq_s32(v13, vdupq_lane_s32((int32x2_t)v13.n128_u64[0], 1)).n128_u32[0];
  if ( v14 - 1 >= 0x100 )
  {
    cinfo->err->msg_code = 8;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  qmemcpy((*htblptr)->huffval, val, v14);
  (*htblptr)->sent_table = 0;
}

//----- (0047AA08) --------------------------------------------------------
void __fastcall jinit_c_prep_controller(j_compress_ptr cinfo, boolean need_full_buffer)
{
  jpeg_c_prep_controller *v3; // r0
  jpeg_c_prep_controller *v4; // r8
  int v5; // r4
  JDIMENSION *p_width_in_blocks; // r6

  if ( need_full_buffer )
  {
    cinfo->err->msg_code = 4;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v3 = (jpeg_c_prep_controller *)cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 32);
  cinfo->prep = v3;
  v3->start_pass = start_pass_prep;
  if ( cinfo->downsample->need_context_rows )
  {
    cinfo->err->msg_code = 48;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  else
  {
    v3->pre_process_data = pre_process_data;
    if ( cinfo->num_components >= 1 )
    {
      v4 = v3 + 1;
      v5 = 0;
      p_width_in_blocks = &cinfo->comp_info->width_in_blocks;
      do
      {
        *((_DWORD *)&v4->start_pass + v5) = cinfo->mem->alloc_sarray(
                                              cinfo,
                                              1,
                                              (int)(8 * cinfo->max_h_samp_factor * *p_width_in_blocks)
                                            / (int)*(p_width_in_blocks - 5),
                                              cinfo->max_v_samp_factor);
        p_width_in_blocks += 21;
        ++v5;
      }
      while ( v5 < cinfo->num_components );
    }
  }
}

//----- (0047AABC) --------------------------------------------------------
void __fastcall start_pass_prep(j_compress_ptr cinfo, J_BUF_MODE pass_mode)
{
  jpeg_c_prep_controller *prep; // r5

  prep = cinfo->prep;
  if ( pass_mode )
  {
    cinfo->err->msg_code = 4;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  prep[3].start_pass = (void (*)(j_compress_ptr, J_BUF_MODE))cinfo->image_height;
  prep[3].pre_process_data = 0;
}

//----- (0047AAE2) --------------------------------------------------------
void __fastcall pre_process_data(
        j_compress_ptr cinfo,
        JSAMPARRAY input_buf,
        JDIMENSION *in_row_ctr,
        JDIMENSION in_rows_avail,
        JSAMPIMAGE output_buf,
        JDIMENSION *out_row_group_ctr,
        JDIMENSION out_row_groups_avail)
{
  JDIMENSION *v7; // r5
  JDIMENSION v9; // r0
  JDIMENSION v10; // r6
  JDIMENSION v11; // r8
  JDIMENSION v12; // r4
  void (*v13)(j_compress_ptr, JSAMPARRAY, JDIMENSION *, JDIMENSION, JSAMPIMAGE, JDIMENSION *, JDIMENSION); // r3
  jpeg_c_prep_controller *v14; // r3
  int v15; // r6
  jpeg_c_prep_controller v16; // r0
  int max_v_samp_factor; // r5
  int num_components; // r0
  int v19; // r8
  size_t image_width; // r10
  int v21; // r9
  JSAMPROW *v22; // r4
  JDIMENSION v23; // r0
  int v24; // r1
  jpeg_component_info *comp_info; // r6
  int v26; // r10
  int v_samp_factor; // r2
  int v28; // r5
  int v29; // r4
  JDIMENSION width_in_blocks; // r1
  JSAMPROW *v31; // r6
  JDIMENSION v32; // r0
  size_t v33; // r8
  int v34; // r9
  JSAMPARRAY *v38; // [sp+18h] [bp-28h]
  j_compress_ptr v39; // [sp+1Ch] [bp-24h]
  jpeg_c_prep_controller *prep; // [sp+20h] [bp-20h]
  jpeg_component_info *v41; // [sp+20h] [bp-20h]

  v7 = in_row_ctr;
  v9 = *in_row_ctr;
  v10 = in_rows_avail;
  if ( *in_row_ctr < in_rows_avail )
  {
    v11 = out_row_groups_avail;
    v38 = (JSAMPARRAY *)&cinfo->prep[1];
    v39 = cinfo;
    prep = cinfo->prep;
    while ( *out_row_group_ctr < v11 )
    {
      v12 = v10 - v9;
      v13 = prep[3].pre_process_data;
      if ( cinfo->max_v_samp_factor - (int)v13 < v10 - v9 )
        v12 = cinfo->max_v_samp_factor - (_DWORD)v13;
      ((void (__fastcall *)(j_compress_ptr, JSAMPROW *, JSAMPARRAY *))cinfo->cconvert->color_convert)(
        cinfo,
        &input_buf[v9],
        v38);
      v14 = prep;
      *v7 += v12;
      v16 = prep[3];
      v15 = (int)v16.pre_process_data + v12;
      v16.start_pass = (void (*)(j_compress_ptr, J_BUF_MODE))((char *)v16.start_pass - v12);
      prep[3].start_pass = v16.start_pass;
      prep[3].pre_process_data = (void (*)(j_compress_ptr, JSAMPARRAY, JDIMENSION *, JDIMENSION, JSAMPIMAGE, JDIMENSION *, JDIMENSION))((char *)v16.pre_process_data + v12);
      if ( v16.start_pass || (max_v_samp_factor = cinfo->max_v_samp_factor, v15 >= max_v_samp_factor) )
      {
        max_v_samp_factor = (int)v16.pre_process_data + v12;
      }
      else
      {
        num_components = cinfo->num_components;
        if ( num_components >= 1 )
        {
          v19 = 0;
          if ( v15 >= max_v_samp_factor )
            goto LABEL_14;
LABEL_10:
          image_width = cinfo->image_width;
          v21 = v15 - 1;
          v22 = (JSAMPROW *)*((_DWORD *)&v14[1].start_pass + v19);
          do
            jcopy_sample_rows(v22, v21, v22, v15++, 1, image_width);
          while ( max_v_samp_factor != v15 );
          cinfo = v39;
          v14 = prep;
          num_components = v39->num_components;
LABEL_14:
          while ( ++v19 < num_components )
          {
            max_v_samp_factor = cinfo->max_v_samp_factor;
            v15 = (int)v14[3].pre_process_data;
            if ( v15 < max_v_samp_factor )
              goto LABEL_10;
          }
          max_v_samp_factor = cinfo->max_v_samp_factor;
          v11 = out_row_groups_avail;
        }
        v14[3].pre_process_data = (void (*)(j_compress_ptr, JSAMPARRAY, JDIMENSION *, JDIMENSION, JSAMPIMAGE, JDIMENSION *, JDIMENSION))max_v_samp_factor;
      }
      if ( max_v_samp_factor == cinfo->max_v_samp_factor )
      {
        cinfo->downsample->downsample(cinfo, v38, 0, output_buf, *out_row_group_ctr);
        v14 = prep;
        prep[3].pre_process_data = 0;
        ++*out_row_group_ctr;
      }
      v7 = in_row_ctr;
      v10 = in_rows_avail;
      if ( !v14[3].start_pass )
      {
        v23 = *out_row_group_ctr;
        if ( *out_row_group_ctr < v11 )
        {
          v24 = cinfo->num_components;
          if ( v24 >= 1 )
          {
            comp_info = cinfo->comp_info;
            v26 = 0;
            while ( 1 )
            {
              v_samp_factor = comp_info->v_samp_factor;
              v28 = v_samp_factor * v23;
              if ( (int)(v_samp_factor * v23) < (int)(v_samp_factor * v11) )
              {
                v29 = v28 - 1;
                v41 = comp_info;
                width_in_blocks = comp_info->width_in_blocks;
                v31 = output_buf[v26];
                v32 = v11 - v23;
                v33 = 8 * width_in_blocks;
                v34 = v_samp_factor * v32;
                do
                {
                  jcopy_sample_rows(v31, v29, v31, v28, 1, v33);
                  --v34;
                  ++v28;
                }
                while ( v34 );
                v11 = out_row_groups_avail;
                comp_info = v41;
                v24 = v39->num_components;
              }
              if ( ++v26 >= v24 )
                break;
              ++comp_info;
              v23 = *out_row_group_ctr;
            }
          }
          *out_row_group_ctr = v11;
          return;
        }
      }
      v9 = *in_row_ctr;
      if ( *in_row_ctr >= in_rows_avail )
        return;
    }
  }
}

//----- (0047AC88) --------------------------------------------------------
void __fastcall jinit_downsampler(j_compress_ptr cinfo)
{
  jpeg_downsampler *v2; // r5
  jpeg_downsampler *v3; // r8
  int v4; // r5
  int *p_v_samp_factor; // r6
  int max_h_samp_factor; // r0
  int v7; // r1

  v2 = (jpeg_downsampler *)cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 28);
  cinfo->downsample = v2;
  v2->start_pass = start_pass_downsample;
  v2->downsample = sep_downsample;
  v2->need_context_rows = 0;
  if ( cinfo->CCIR601_sampling )
  {
    cinfo->err->msg_code = 25;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  if ( cinfo->num_components >= 1 )
  {
    v3 = v2 + 1;
    v4 = 0;
    p_v_samp_factor = &cinfo->comp_info->v_samp_factor;
    do
    {
      max_h_samp_factor = cinfo->max_h_samp_factor;
      v7 = *(p_v_samp_factor - 1);
      if ( v7 == max_h_samp_factor && *p_v_samp_factor == cinfo->max_v_samp_factor )
      {
        *((_DWORD *)&v3->start_pass + v4) = fullsize_downsample;
      }
      else
      {
        if ( max_h_samp_factor != 2 * v7 )
          goto LABEL_14;
        if ( *p_v_samp_factor == cinfo->max_v_samp_factor )
        {
          *((_DWORD *)&v3->start_pass + v4) = h2v1_downsample;
        }
        else
        {
          if ( cinfo->max_v_samp_factor != 2 * *p_v_samp_factor )
          {
LABEL_14:
            if ( max_h_samp_factor % v7 || cinfo->max_v_samp_factor % *p_v_samp_factor )
            {
              cinfo->err->msg_code = 38;
              cinfo->err->error_exit((j_common_ptr)cinfo);
            }
            else
            {
              *((_DWORD *)&v3->start_pass + v4) = int_downsample;
            }
            goto LABEL_17;
          }
          *((_DWORD *)&v3->start_pass + v4) = h2v2_downsample;
        }
      }
LABEL_17:
      ++v4;
      p_v_samp_factor += 21;
    }
    while ( v4 < cinfo->num_components );
  }
}

//----- (0047AD8E) --------------------------------------------------------
void __fastcall sep_downsample(
        j_compress_ptr cinfo,
        JSAMPIMAGE input_buf,
        JDIMENSION in_row_index,
        JSAMPIMAGE output_buf,
        JDIMENSION out_row_group_index)
{
  int v9; // r10
  jpeg_component_info *comp_info; // r5
  jpeg_downsampler *v11; // [sp+0h] [bp-20h]

  if ( cinfo->num_components >= 1 )
  {
    v9 = 0;
    v11 = cinfo->downsample + 1;
    comp_info = cinfo->comp_info;
    do
    {
      (*((void (__fastcall **)(j_compress_ptr, jpeg_component_info *, JSAMPROW *, JSAMPROW *))&v11->start_pass + v9))(
        cinfo,
        comp_info,
        &input_buf[v9][in_row_index],
        &output_buf[v9][comp_info->v_samp_factor * out_row_group_index]);
      ++v9;
      ++comp_info;
    }
    while ( v9 < cinfo->num_components );
  }
}

//----- (0047ADF0) --------------------------------------------------------
void __fastcall fullsize_downsample(
        j_compress_ptr cinfo,
        jpeg_component_info *compptr,
        JSAMPARRAY input_data,
        JSAMPARRAY output_data)
{
  JDIMENSION image_width; // r9
  JSAMPARRAY v6; // r4
  JDIMENSION width_in_blocks; // r0
  int max_v_samp_factor; // r6
  bool v10; // cc
  int v11; // r0
  JDIMENSION v12; // r1
  int v13; // r0
  size_t v14; // r5
  int v15; // t1

  v6 = output_data;
  jcopy_sample_rows(input_data, 0, output_data, 0, cinfo->max_v_samp_factor, cinfo->image_width);
  max_v_samp_factor = cinfo->max_v_samp_factor;
  v10 = max_v_samp_factor < 1;
  if ( max_v_samp_factor >= 1 )
  {
    image_width = cinfo->image_width;
    width_in_blocks = compptr->width_in_blocks;
    v10 = (int)(8 * width_in_blocks - image_width) < 1;
  }
  if ( !v10 )
  {
    v11 = 8 * width_in_blocks;
    v12 = 2 - image_width + v11;
    v13 = image_width - 1 - v11;
    if ( v13 < -1 )
      v13 = -2;
    v14 = v12 + v13;
    do
    {
      v15 = (int)*v6++;
      memset((void *)(v15 + image_width), *(unsigned __int8 *)(v15 + image_width - 1), v14);
      --max_v_samp_factor;
    }
    while ( max_v_samp_factor );
  }
}
// 47AE2E: variable 'width_in_blocks' is possibly undefined
// 47AE30: variable 'image_width' is possibly undefined

//----- (0047AE64) --------------------------------------------------------
void __fastcall h2v1_downsample(
        j_compress_ptr cinfo,
        jpeg_component_info *compptr,
        JSAMPARRAY input_data,
        JSAMPARRAY output_data)
{
  JDIMENSION image_width; // r6
  int max_v_samp_factor; // r5
  bool v8; // cc
  JSAMPARRAY v10; // r10
  int v11; // r1
  size_t v12; // r4
  int v13; // t1
  int v_samp_factor; // r0
  int i; // r1
  JSAMPROW v16; // r2
  int v17; // r6
  JSAMPROW v18; // r3
  int v19; // r0
  int v20; // r4
  int v21; // r5
  int v22; // r4
  JDIMENSION width_in_blocks; // [sp+0h] [bp-20h]

  max_v_samp_factor = cinfo->max_v_samp_factor;
  width_in_blocks = compptr->width_in_blocks;
  v8 = max_v_samp_factor < 1;
  if ( max_v_samp_factor >= 1 )
  {
    image_width = cinfo->image_width;
    v8 = (int)(16 * width_in_blocks - image_width) < 1;
  }
  if ( !v8 )
  {
    v10 = input_data;
    v11 = ~(16 * width_in_blocks) + image_width;
    if ( v11 < -1 )
      v11 = -2;
    v12 = ((16 * width_in_blocks) | 2) - image_width + v11;
    do
    {
      v13 = (int)*v10++;
      memset((void *)(v13 + image_width), *(unsigned __int8 *)(v13 + image_width - 1), v12);
      --max_v_samp_factor;
    }
    while ( max_v_samp_factor );
  }
  v_samp_factor = compptr->v_samp_factor;
  if ( v_samp_factor >= 1 )
  {
    for ( i = 0; i < v_samp_factor; ++i )
    {
      if ( 8 * width_in_blocks )
      {
        v16 = output_data[i];
        v17 = 0;
        v18 = input_data[i];
        v19 = 8 * width_in_blocks;
        do
        {
          v20 = *v18;
          --v19;
          v21 = v18[1];
          v18 += 2;
          v22 = v20 + v17;
          v17 ^= 1u;
          *v16++ = (unsigned int)(v21 + v22) >> 1;
        }
        while ( v19 );
        v_samp_factor = compptr->v_samp_factor;
      }
    }
  }
}
// 47AE9A: variable 'image_width' is possibly undefined

//----- (0047AF0E) --------------------------------------------------------
void __fastcall h2v2_downsample(
        j_compress_ptr cinfo,
        jpeg_component_info *compptr,
        JSAMPARRAY input_data,
        JSAMPARRAY output_data)
{
  JDIMENSION image_width; // r5
  int max_v_samp_factor; // r6
  JDIMENSION width_in_blocks; // r8
  bool v8; // cc
  JSAMPARRAY v9; // r11
  int v10; // r1
  size_t v11; // r4
  int v12; // t1
  int v_samp_factor; // r0
  int v14; // r12
  int v15; // lr
  int i; // r11
  int v17; // r5
  JSAMPROW v18; // r6
  JSAMPROW v19; // r3
  JSAMPROW v20; // r4
  int v21; // r0
  int v22; // r1
  int v23; // r2
  int v24; // r8
  int v25; // r10
  unsigned int v26; // r1

  max_v_samp_factor = cinfo->max_v_samp_factor;
  width_in_blocks = compptr->width_in_blocks;
  v8 = max_v_samp_factor < 1;
  if ( max_v_samp_factor >= 1 )
  {
    image_width = cinfo->image_width;
    v8 = (int)(16 * width_in_blocks - image_width) < 1;
  }
  if ( !v8 )
  {
    v9 = input_data;
    v10 = ~(16 * width_in_blocks) + image_width;
    if ( v10 < -1 )
      v10 = -2;
    v11 = ((16 * width_in_blocks) | 2) - image_width + v10;
    do
    {
      v12 = (int)*v9++;
      memset((void *)(v12 + image_width), *(unsigned __int8 *)(v12 + image_width - 1), v11);
      --max_v_samp_factor;
    }
    while ( max_v_samp_factor );
  }
  v_samp_factor = compptr->v_samp_factor;
  if ( v_samp_factor >= 1 )
  {
    v14 = 8 * width_in_blocks;
    v15 = 0;
    for ( i = 0; i < v_samp_factor; ++i )
    {
      if ( v14 )
      {
        v17 = 1;
        v18 = input_data[v15];
        v19 = output_data[i];
        v20 = input_data[v15 | 1];
        v21 = v14;
        do
        {
          v22 = *v18;
          --v21;
          v23 = v18[1];
          v18 += 2;
          v24 = *v20;
          v25 = v20[1];
          v20 += 2;
          v26 = v22 + v17 + v23 + v24 + v25;
          v17 ^= 3u;
          *v19++ = v26 >> 2;
        }
        while ( v21 );
        v_samp_factor = compptr->v_samp_factor;
      }
      v15 += 2;
    }
  }
}
// 47AF40: variable 'image_width' is possibly undefined

//----- (0047AFD8) --------------------------------------------------------
void __fastcall int_downsample(
        j_compress_ptr cinfo,
        jpeg_component_info *compptr,
        JSAMPARRAY input_data,
        JSAMPARRAY output_data)
{
  JDIMENSION image_width; // r6
  int max_v_samp_factor; // r10
  __int64 v6; // kr08_8
  int v7; // r0
  int v8; // r4
  JDIMENSION v9; // r2
  int v10; // r8
  int v11; // r0
  int v_samp_factor; // r3
  int v13; // r1
  JDIMENSION v14; // r0
  JSAMPARRAY v15; // r9
  size_t v16; // r11
  int v17; // t1
  unsigned int v18; // r11
  int v19; // r1
  int v20; // r0
  int32x4_t v21; // q4
  int v22; // r10
  JSAMPROW v23; // r1
  int v24; // r0
  unsigned __int32 v25; // r1
  int i; // r0
  JSAMPLE *v27; // r3
  JSAMPLE *v28; // r2
  int32x4_t v29; // q9
  unsigned int v30; // r1
  int8x16_t v31; // q8
  unsigned __int32 v32; // t1
  int v33; // r5
  int32x4_t v34; // q8
  int v35; // r3
  int v36; // t1
  int v39; // [sp+Ch] [bp-54h]
  int v41; // [sp+14h] [bp-4Ch]
  JDIMENSION v42; // [sp+20h] [bp-40h]
  int v43; // [sp+24h] [bp-3Ch]
  JSAMPROW v44; // [sp+28h] [bp-38h]

  image_width = cinfo->image_width;
  max_v_samp_factor = cinfo->max_v_samp_factor;
  v6 = *(_QWORD *)&compptr->h_samp_factor;
  v7 = cinfo->max_h_samp_factor / (int)v6;
  v8 = v7;
  v9 = 8 * compptr->width_in_blocks;
  v10 = max_v_samp_factor / SHIDWORD(v6);
  v42 = v9;
  if ( max_v_samp_factor < 1 )
  {
    v_samp_factor = compptr->v_samp_factor;
    if ( SHIDWORD(v6) < 1 )
      return;
  }
  else
  {
    v11 = v7 * v9;
    v_samp_factor = compptr->v_samp_factor;
    if ( (int)(v8 * v9 - image_width) >= 1 )
    {
      v13 = ~v11 + image_width;
      v14 = (v11 | 2) - image_width;
      if ( v13 < -1 )
        v13 = -2;
      v15 = input_data;
      v16 = v14 + v13;
      do
      {
        v17 = (int)*v15++;
        memset((void *)(v17 + image_width), *(unsigned __int8 *)(v17 + image_width - 1), v16);
        --max_v_samp_factor;
      }
      while ( max_v_samp_factor );
      v9 = v42;
      v_samp_factor = compptr->v_samp_factor;
    }
    if ( v_samp_factor < 1 )
      return;
  }
  v18 = v8 & 0xFFFFFFFC;
  v19 = 0;
  v20 = 0;
  v21 = vdupq_n_s32(0);
  do
  {
    if ( !v9 )
      goto LABEL_27;
    v41 = v20;
    v22 = 0;
    v39 = v19;
    v23 = output_data[v19];
    v24 = 0;
    do
    {
      v43 = v24;
      v44 = v23;
      v25 = 0;
      if ( v10 >= 1 )
      {
        for ( i = 0; i != v10; ++i )
        {
          if ( v8 >= 1 )
          {
            v27 = &(&input_data[i])[v41][v22];
            if ( (unsigned int)v8 >= 4 && v18 )
            {
              v28 = &v27[v18];
              v31.n128_u64[1] = v21.n128_u64[1];
              v29.n128_u64[0] = __PAIR64__(v21.n128_u32[1], v25);
              v30 = v8 & 0xFFFFFFFC;
              v31.n128_u64[0] = v29.n128_u64[0];
              do
              {
                v32 = *(_DWORD *)v27;
                v27 += 4;
                v30 -= 4;
                v29.n128_u32[0] = v32;
                v29 = vmovl_u16((uint16x4_t)vmovl_u8((uint8x8_t)v29.n128_u64[0]).n128_u64[0]);
                v31 = vaddq_s32(v31, v29);
              }
              while ( v30 );
              v33 = v8 & 0x7FFFFFFC;
              v34 = vaddq_s32(v31, vextq_s8(v31, v31, 8u));
              v25 = vaddq_s32(v34, vdupq_lane_s32((int32x2_t)v34.n128_u64[0], 1)).n128_u32[0];
              if ( v8 == v18 )
                continue;
            }
            else
            {
              v33 = 0;
              v28 = &(&input_data[i])[v41][v22];
            }
            v35 = v8 - v33;
            do
            {
              v36 = *v28++;
              --v35;
              v25 += v36;
            }
            while ( v35 );
          }
        }
      }
      v22 += v8;
      *v44 = (int)(v10 * v8 / 2 + v25) / (v10 * v8);
      v23 = v44 + 1;
      v9 = v42;
      v24 = v43 + 1;
    }
    while ( v43 + 1 != v42 );
    v19 = v39;
    v_samp_factor = compptr->v_samp_factor;
    v20 = v41;
LABEL_27:
    ++v19;
    v20 += v10;
  }
  while ( v19 < v_samp_factor );
}
// 47B0FA: mask 0xFFFFFFFC is shortened because r4.4 <= 0x7FFFFFFF

//----- (0047B170) --------------------------------------------------------
void __fastcall jpeg_write_coefficients(j_compress_ptr cinfo, jvirt_barray_ptr *coef_arrays)
{
  int v4; // r6
  char *v5; // r5
  int32x4_t v6; // q9
  int32x4_t v7; // q8
  int32x4_t v8; // q10

  if ( cinfo->global_state != 100 )
  {
    cinfo->err->msg_code = 20;
    cinfo->err->msg_parm.i[0] = cinfo->global_state;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  jpeg_suppress_tables(cinfo, 0);
  cinfo->err->reset_error_mgr((j_common_ptr)cinfo);
  cinfo->dest->init_destination(cinfo);
  cinfo->input_components = 1;
  jinit_c_master_control(cinfo, 1u);
  if ( cinfo->arith_code )
  {
    cinfo->err->msg_code = 1;
  }
  else
  {
    if ( !cinfo->progressive_mode )
    {
      jinit_huff_encoder(cinfo);
      goto LABEL_8;
    }
    cinfo->err->msg_code = 48;
  }
  cinfo->err->error_exit((j_common_ptr)cinfo);
LABEL_8:
  v4 = cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 68);
  cinfo->coef = (jpeg_c_coef_controller *)v4;
  *(_DWORD *)v4 = start_pass_coef;
  *(_DWORD *)(v4 + 4) = compress_output;
  *(_DWORD *)(v4 + 24) = coef_arrays;
  v5 = (char *)cinfo->mem->alloc_large(cinfo, 1, 1280);
  jzero_far(v5, 0x500u);
  v6 = vdupq_n_s32((unsigned int)v5);
  v7.n128_u64[0] = 0x30000000280LL;
  v7.n128_u64[1] = 0x40000000380LL;
  v8.n128_u64[0] = 0x10000000080LL;
  v8.n128_u64[1] = 0x20000000180LL;
  *(_DWORD *)(v4 + 28) = v5;
  *(_DWORD *)(v4 + 64) = v5 + 1152;
  *(int32x4_t *)(v4 + 32) = vaddq_s32(v6, v8);
  *(int32x4_t *)(v4 + 48) = vaddq_s32(v6, v7);
  jinit_marker_writer(cinfo);
  cinfo->mem->realize_virt_arrays((j_common_ptr)cinfo);
  cinfo->marker->write_file_header(cinfo);
  cinfo->global_state = 103;
  cinfo->next_scanline = 0;
}

//----- (0047B2A8) --------------------------------------------------------
void __fastcall jpeg_copy_critical_parameters(j_decompress_ptr srcinfo, j_compress_ptr dstinfo)
{
  JQUANT_TBL *v4; // r1
  JQUANT_TBL *v5; // r0
  JQUANT_TBL *v6; // r1
  JQUANT_TBL *v7; // r0
  JQUANT_TBL *v8; // r1
  JQUANT_TBL *v9; // r0
  JQUANT_TBL *v10; // r1
  JQUANT_TBL *v11; // r0
  int num_components; // r0
  jpeg_component_info *comp_info; // r6
  int v14; // r1
  jpeg_component_info *v15; // r5
  unsigned int quant_tbl_no; // r10
  JQUANT_TBL **v17; // r9
  JQUANT_TBL *v18; // r8
  JQUANT_TBL *quant_table; // r11
  int i; // r9
  jpeg_decompress_struct *v21; // [sp+4h] [bp-24h]
  int v22; // [sp+8h] [bp-20h]

  if ( dstinfo->global_state != 100 )
  {
    dstinfo->err->msg_code = 20;
    dstinfo->err->msg_parm.i[0] = dstinfo->global_state;
    dstinfo->err->error_exit((j_common_ptr)dstinfo);
  }
  dstinfo->image_width = srcinfo->image_width;
  dstinfo->image_height = srcinfo->image_height;
  dstinfo->input_components = srcinfo->num_components;
  dstinfo->in_color_space = srcinfo->jpeg_color_space;
  jpeg_set_defaults(dstinfo);
  jpeg_set_colorspace(dstinfo, srcinfo->jpeg_color_space);
  dstinfo->data_precision = srcinfo->data_precision;
  dstinfo->CCIR601_sampling = srcinfo->CCIR601_sampling;
  v4 = srcinfo->quant_tbl_ptrs[0];
  if ( v4 )
  {
    v5 = dstinfo->quant_tbl_ptrs[0];
    if ( !v5 )
    {
      v5 = jpeg_alloc_quant_table((j_common_ptr)dstinfo);
      dstinfo->quant_tbl_ptrs[0] = v5;
      v4 = srcinfo->quant_tbl_ptrs[0];
    }
    qmemcpy(v5, v4, 0x80u);
    dstinfo->quant_tbl_ptrs[0]->sent_table = 0;
  }
  v6 = srcinfo->quant_tbl_ptrs[1];
  if ( v6 )
  {
    v7 = dstinfo->quant_tbl_ptrs[1];
    if ( !v7 )
    {
      v7 = jpeg_alloc_quant_table((j_common_ptr)dstinfo);
      dstinfo->quant_tbl_ptrs[1] = v7;
      v6 = srcinfo->quant_tbl_ptrs[1];
    }
    qmemcpy(v7, v6, 0x80u);
    dstinfo->quant_tbl_ptrs[1]->sent_table = 0;
  }
  v8 = srcinfo->quant_tbl_ptrs[2];
  if ( v8 )
  {
    v9 = dstinfo->quant_tbl_ptrs[2];
    if ( !v9 )
    {
      v9 = jpeg_alloc_quant_table((j_common_ptr)dstinfo);
      dstinfo->quant_tbl_ptrs[2] = v9;
      v8 = srcinfo->quant_tbl_ptrs[2];
    }
    qmemcpy(v9, v8, 0x80u);
    dstinfo->quant_tbl_ptrs[2]->sent_table = 0;
  }
  v10 = srcinfo->quant_tbl_ptrs[3];
  if ( v10 )
  {
    v11 = dstinfo->quant_tbl_ptrs[3];
    if ( !v11 )
    {
      v11 = jpeg_alloc_quant_table((j_common_ptr)dstinfo);
      dstinfo->quant_tbl_ptrs[3] = v11;
      v10 = srcinfo->quant_tbl_ptrs[3];
    }
    qmemcpy(v11, v10, 0x80u);
    dstinfo->quant_tbl_ptrs[3]->sent_table = 0;
  }
  num_components = srcinfo->num_components;
  dstinfo->num_components = num_components;
  if ( (unsigned int)(num_components - 1) <= 3
    || (dstinfo->err->msg_code = 26,
        dstinfo->err->msg_parm.i[0] = dstinfo->num_components,
        dstinfo->err->msg_parm.i[1] = 4,
        dstinfo->err->error_exit((j_common_ptr)dstinfo),
        dstinfo->num_components >= 1) )
  {
    comp_info = srcinfo->comp_info;
    v14 = 0;
    v15 = dstinfo->comp_info;
    v21 = srcinfo;
    do
    {
      v22 = v14;
      v15->component_id = comp_info->component_id;
      v15->h_samp_factor = comp_info->h_samp_factor;
      v15->v_samp_factor = comp_info->v_samp_factor;
      quant_tbl_no = comp_info->quant_tbl_no;
      v15->quant_tbl_no = quant_tbl_no;
      v17 = &srcinfo->quant_tbl_ptrs[quant_tbl_no];
      if ( quant_tbl_no > 3 || (v18 = *v17) == 0 )
      {
        dstinfo->err->msg_code = 52;
        dstinfo->err->msg_parm.i[0] = quant_tbl_no;
        dstinfo->err->error_exit((j_common_ptr)dstinfo);
        v18 = *v17;
      }
      quant_table = comp_info->quant_table;
      if ( quant_table )
      {
        for ( i = 0; i != 64; ++i )
        {
          if ( quant_table->quantval[i] != v18->quantval[i] )
          {
            dstinfo->err->msg_code = 44;
            dstinfo->err->msg_parm.i[0] = quant_tbl_no;
            dstinfo->err->error_exit((j_common_ptr)dstinfo);
          }
        }
      }
      ++v15;
      ++comp_info;
      srcinfo = v21;
      v14 = v22 + 1;
    }
    while ( v22 + 1 < dstinfo->num_components );
  }
  if ( srcinfo->saw_JFIF_marker )
  {
    if ( srcinfo->JFIF_major_version == 1 )
    {
      dstinfo->JFIF_major_version = 1;
      dstinfo->JFIF_minor_version = srcinfo->JFIF_minor_version;
    }
    dstinfo->density_unit = srcinfo->density_unit;
    dstinfo->X_density = srcinfo->X_density;
    dstinfo->Y_density = srcinfo->Y_density;
  }
}

//----- (0047B49A) --------------------------------------------------------
void __fastcall start_pass_coef(j_compress_ptr cinfo, J_BUF_MODE pass_mode)
{
  jpeg_c_coef_controller *coef; // r5
  jpeg_c_coef_controller *v4; // r1
  int v5; // r2
  jpeg_component_info *v6; // r3
  JDIMENSION v7; // r2
  int *p_last_row_height; // r4

  coef = cinfo->coef;
  if ( pass_mode != JBUF_CRANK_DEST )
  {
    cinfo->err->msg_code = 4;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  coef[1].start_pass = 0;
  v4 = cinfo->coef;
  if ( cinfo->comps_in_scan <= 1 )
  {
    v6 = cinfo->cur_comp_info[0];
    v7 = cinfo->total_iMCU_rows - 1;
    p_last_row_height = &v6->last_row_height;
    if ( (char *)v4[1].start_pass < (char *)v7 )
      p_last_row_height = &v6->v_samp_factor;
    v5 = *p_last_row_height;
  }
  else
  {
    v5 = 1;
  }
  v4[1].compress_data = 0;
  v4[2].start_pass = 0;
  v4[2].compress_data = (boolean (*)(j_compress_ptr, JSAMPIMAGE))v5;
}

//----- (0047B4EC) --------------------------------------------------------
boolean __fastcall compress_output(j_compress_ptr cinfo, JSAMPIMAGE input_buf)
{
  __int64 v3; // kr00_8
  jpeg_c_coef_controller *coef; // r9
  int v5; // r5
  boolean (*compress_data)(j_compress_ptr, JSAMPIMAGE); // r0
  void (*start_pass)(j_compress_ptr, J_BUF_MODE); // r2
  jpeg_c_coef_controller *v8; // lr
  j_compress_ptr v9; // r10
  boolean (*v10)(j_compress_ptr, JSAMPIMAGE); // r6
  int comps_in_scan; // r0
  int v12; // r5
  int v13; // r1
  jpeg_component_info *v14; // r8
  int *p_MCU_width; // r3
  int MCU_width; // r12
  int *p_last_col_width; // r2
  int v18; // r11
  int v19; // r10
  void (*v20)(j_compress_ptr, J_BUF_MODE); // r5
  int v21; // r0
  int v22; // r4
  int v23; // r0
  int v24; // r4
  int v25; // r12
  int v26; // r5
  _QWORD *v27; // r2
  unsigned int v28; // r0
  __int64 v29; // d17
  __int64 v30; // d16
  int v31; // r6
  unsigned int v32; // r2
  unsigned int v33; // r2
  _DWORD *v34; // r0
  void (**v35)(j_compress_ptr, J_BUF_MODE); // r0
  void (**v36)(j_compress_ptr, J_BUF_MODE); // r6
  _WORD *v37; // r2
  void (*v38)(j_compress_ptr, J_BUF_MODE); // r6
  jpeg_c_coef_controller *v39; // r0
  int v40; // r1
  jpeg_component_info *v42; // r2
  int *p_last_row_height; // r6
  j_compress_ptr v44; // [sp+4h] [bp-84h]
  boolean (*v45)(j_compress_ptr, JSAMPIMAGE); // [sp+8h] [bp-80h]
  int v46; // [sp+Ch] [bp-7Ch]
  JDIMENSION v47; // [sp+10h] [bp-78h]
  int v48; // [sp+18h] [bp-70h]
  void (*v49)(j_compress_ptr, J_BUF_MODE); // [sp+1Ch] [bp-6Ch]
  unsigned int v50; // [sp+20h] [bp-68h]
  _BOOL4 v51; // [sp+24h] [bp-64h]
  int v52; // [sp+28h] [bp-60h]
  JDIMENSION MCUs_per_row; // [sp+2Ch] [bp-5Ch]
  int v54; // [sp+2Ch] [bp-5Ch]
  JDIMENSION total_iMCU_rows; // [sp+30h] [bp-58h]
  _DWORD v56[21]; // [sp+34h] [bp-54h] BYREF

  v3 = *(_QWORD *)&cinfo->total_iMCU_rows;
  total_iMCU_rows = cinfo->total_iMCU_rows;
  MCUs_per_row = cinfo->MCUs_per_row;
  coef = cinfo->coef;
  if ( SHIDWORD(v3) >= 1 )
  {
    v5 = 0;
    do
    {
      v56[v5 + 10] = ((int (__fastcall *)(j_compress_ptr, _DWORD, int))cinfo->mem->access_virt_barray)(
                       cinfo,
                       *((_DWORD *)coef[3].start_pass + cinfo->cur_comp_info[v5]->component_index),
                       cinfo->cur_comp_info[v5]->v_samp_factor * (int)coef[1].start_pass);
      ++v5;
    }
    while ( v5 < cinfo->comps_in_scan );
  }
  v44 = cinfo;
  compress_data = coef[2].compress_data;
  start_pass = coef[2].start_pass;
  if ( (int)start_pass >= (int)compress_data )
  {
    v8 = coef + 1;
    v9 = cinfo;
    goto LABEL_41;
  }
  v8 = coef + 1;
  v9 = cinfo;
  --total_iMCU_rows;
  v47 = MCUs_per_row - 1;
  v10 = coef[1].compress_data;
  do
  {
    if ( (unsigned int)v10 >= v9->MCUs_per_row )
      goto LABEL_38;
    v49 = start_pass;
    v46 = (_DWORD)v10 << 7;
    do
    {
      comps_in_scan = v9->comps_in_scan;
      if ( comps_in_scan >= 1 )
      {
        v12 = 0;
        v13 = 0;
        v45 = v10;
        while ( 1 )
        {
          v14 = v9->cur_comp_info[v12];
          p_MCU_width = &v14->MCU_width;
          MCU_width = v14->MCU_width;
          p_last_col_width = &v14->MCU_width;
          if ( (unsigned int)v10 >= v47 )
            p_last_col_width = &v14->last_col_width;
          if ( v14->MCU_height >= 1 )
            break;
LABEL_34:
          if ( ++v12 >= comps_in_scan )
            goto LABEL_35;
        }
        v54 = v12;
        v18 = 0;
        v52 = MCU_width * (_DWORD)v10;
        v19 = *p_last_col_width;
        v48 = v46 * MCU_width;
        v20 = v49;
        v51 = *p_last_col_width < 1;
        v50 = *p_last_col_width & 0xFFFFFFFC;
        while ( 1 )
        {
          v21 = (int)v20 + v18;
          if ( (char *)v8->start_pass >= (char *)total_iMCU_rows )
          {
            v22 = 0;
            if ( v21 >= v14->last_row_height || v51 )
              goto LABEL_29;
          }
          else if ( v19 < 1 )
          {
            v22 = 0;
            if ( MCU_width > 0 )
              goto LABEL_30;
            goto LABEL_32;
          }
          v23 = *(_DWORD *)(v56[v54 + 10] + 4 * v21);
          v24 = v23 + (v52 << 7);
          if ( (unsigned int)v19 >= 4 && v50 )
          {
            v25 = v13 + v50;
            v24 += v50 << 7;
            v26 = v23 + v48 + 384;
            v27 = &v56[v13];
            v28 = v50;
            do
            {
              v28 -= 4;
              LODWORD(v29) = v26 - 128;
              LODWORD(v30) = v26 - 384;
              v31 = v26 - 256;
              HIDWORD(v29) = v26;
              v26 += 512;
              HIDWORD(v30) = v31;
              *v27 = v30;
              v27[1] = v29;
              v27 += 2;
            }
            while ( v28 );
            v20 = v49;
            v8 = coef + 1;
            v32 = v50;
            if ( v19 == v50 )
              goto LABEL_28;
          }
          else
          {
            v32 = 0;
            v25 = v13;
          }
          v33 = v19 - v32;
          v34 = &v56[v25];
          do
          {
            *v34++ = v24;
            --v33;
            v24 += 128;
          }
          while ( v33 );
LABEL_28:
          MCU_width = *p_MCU_width;
          v13 += v19;
          v22 = v19;
LABEL_29:
          if ( v22 < MCU_width )
          {
LABEL_30:
            v35 = (void (**)(j_compress_ptr, J_BUF_MODE))&v56[v13];
            do
            {
              v36 = &coef->start_pass + v13;
              v37 = *(v35 - 1);
              ++v22;
              ++v13;
              v38 = v36[7];
              *v35++ = v38;
              *(_WORD *)v38 = *v37;
              MCU_width = *p_MCU_width;
            }
            while ( v22 < *p_MCU_width );
          }
LABEL_32:
          if ( ++v18 >= v14->MCU_height )
          {
            v9 = v44;
            v10 = v45;
            v12 = v54;
            comps_in_scan = v44->comps_in_scan;
            goto LABEL_34;
          }
        }
      }
LABEL_35:
      if ( !((int (__fastcall *)(j_compress_ptr, _DWORD *))v9->entropy->encode_mcu)(v9, v56) )
      {
        coef[1].compress_data = v10;
        coef[2].start_pass = v49;
        return 0;
      }
      v10 = (boolean (*)(j_compress_ptr, JSAMPIMAGE))((char *)v10 + 1);
      v8 = coef + 1;
      v46 += 128;
    }
    while ( (unsigned int)v10 < v9->MCUs_per_row );
    compress_data = coef[2].compress_data;
    start_pass = v49;
LABEL_38:
    start_pass = (void (*)(j_compress_ptr, J_BUF_MODE))((char *)start_pass + 1);
    v10 = 0;
    coef[1].compress_data = 0;
  }
  while ( (int)start_pass < (int)compress_data );
LABEL_41:
  ++v8->start_pass;
  v39 = v9->coef;
  if ( v9->comps_in_scan <= 1 )
  {
    v42 = v9->cur_comp_info[0];
    p_last_row_height = &v42->last_row_height;
    if ( (char *)v39[1].start_pass < (char *)(v9->total_iMCU_rows - 1) )
      p_last_row_height = &v42->v_samp_factor;
    v40 = *p_last_row_height;
  }
  else
  {
    v40 = 1;
  }
  v39[1].compress_data = 0;
  v39[2].start_pass = 0;
  v39[2].compress_data = (boolean (*)(j_compress_ptr, JSAMPIMAGE))v40;
  return 1;
}

//----- (0047B78C) --------------------------------------------------------
void __fastcall jpeg_CreateDecompress(j_decompress_ptr cinfo, int version, size_t structsize)
{
  jpeg_error_mgr *err; // r5
  void *client_data; // r6

  cinfo->mem = 0;
  if ( version != 62 )
  {
    cinfo->err->msg_code = 12;
    cinfo->err->msg_parm.i[0] = 62;
    cinfo->err->msg_parm.i[1] = version;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  if ( structsize != 432 )
  {
    cinfo->err->msg_code = 21;
    cinfo->err->msg_parm.i[0] = 432;
    cinfo->err->msg_parm.i[1] = structsize;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  err = cinfo->err;
  client_data = cinfo->client_data;
  memset(&cinfo->mem, 0, 0x1ACu);
  cinfo->client_data = client_data;
  cinfo->err = err;
  cinfo->is_decompressor = 1;
  jinit_memory_mgr((j_common_ptr)cinfo);
  *(_QWORD *)cinfo->ac_huff_tbl_ptrs = 0LL;
  *(_QWORD *)&cinfo->ac_huff_tbl_ptrs[2] = 0LL;
  *(_QWORD *)cinfo->dc_huff_tbl_ptrs = 0LL;
  *(_QWORD *)&cinfo->dc_huff_tbl_ptrs[2] = 0LL;
  *(_QWORD *)cinfo->quant_tbl_ptrs = 0LL;
  *(_QWORD *)&cinfo->quant_tbl_ptrs[2] = 0LL;
  cinfo->src = 0;
  cinfo->progress = 0;
  cinfo->marker_list = 0;
  jinit_marker_reader(cinfo);
  jinit_input_controller(cinfo);
  cinfo->global_state = 200;
}

//----- (0047B838) --------------------------------------------------------
int __fastcall jpeg_read_header(j_decompress_ptr cinfo, boolean require_image)
{
  int v3; // r5
  int result; // r0

  v3 = require_image;
  if ( (cinfo->global_state & 0xFFFFFFFE) != 200 )
  {
    cinfo->err->msg_code = 20;
    cinfo->err->msg_parm.i[0] = cinfo->global_state;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  result = jpeg_consume_input(cinfo);
  if ( result == 2 )
  {
    if ( v3 )
    {
      cinfo->err->msg_code = 51;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    jpeg_abort((j_common_ptr)cinfo);
    return 2;
  }
  else if ( result == 1 )
  {
    return 1;
  }
  return result;
}

//----- (0047B88C) --------------------------------------------------------
int __fastcall jpeg_consume_input(j_decompress_ptr cinfo)
{
  int v2; // r1
  int result; // r0
  int num_components; // r0
  J_COLOR_SPACE v5; // r12
  J_COLOR_SPACE v6; // r2
  int saw_Adobe_marker; // r0
  bool v8; // zf
  int v9; // r1
  jpeg_component_info *comp_info; // r2
  int component_id; // r0
  int v12; // r1
  int v13; // r2
  bool v14; // zf
  bool v15; // zf
  jpeg_error_mgr::$5C543C3B007127DC5800B89B1E344C14 *p_msg_parm; // r3

  v2 = cinfo->global_state - 200;
  result = 1;
  switch ( v2 )
  {
    case 0:
      cinfo->inputctl->reset_input_controller(cinfo);
      cinfo->src->init_source(cinfo);
      cinfo->global_state = 201;
      goto LABEL_4;
    case 1:
LABEL_4:
      result = cinfo->inputctl->consume_input(cinfo);
      if ( result != 1 )
        return result;
      num_components = cinfo->num_components;
      if ( num_components == 4 )
      {
        saw_Adobe_marker = cinfo->saw_Adobe_marker;
        v8 = saw_Adobe_marker == 0;
        if ( cinfo->saw_Adobe_marker )
        {
          saw_Adobe_marker = cinfo->Adobe_transform;
          v8 = saw_Adobe_marker == 0;
        }
        if ( v8 )
        {
          v5 = JCS_CMYK;
          v6 = JCS_CMYK;
        }
        else
        {
          if ( saw_Adobe_marker != 2 )
          {
            cinfo->err->msg_code = 114;
            cinfo->err->msg_parm.i[0] = cinfo->Adobe_transform;
            cinfo->err->emit_message((j_common_ptr)cinfo, -1);
          }
          v6 = JCS_CMYK;
          v5 = JCS_YCCK;
        }
        goto LABEL_36;
      }
      if ( num_components != 3 )
      {
        if ( num_components == 1 )
        {
          v5 = JCS_GRAYSCALE;
          v6 = JCS_GRAYSCALE;
        }
        else
        {
          v5 = JCS_UNKNOWN;
          v6 = JCS_UNKNOWN;
        }
        goto LABEL_36;
      }
      if ( cinfo->saw_JFIF_marker )
        goto LABEL_16;
      if ( cinfo->saw_Adobe_marker )
      {
        if ( cinfo->Adobe_transform )
        {
          if ( cinfo->Adobe_transform == 1 )
          {
LABEL_16:
            v6 = JCS_RGB;
            v5 = JCS_YCbCr;
            goto LABEL_36;
          }
          cinfo->err->msg_code = 114;
          cinfo->err->msg_parm.i[0] = cinfo->Adobe_transform;
          v9 = -1;
LABEL_38:
          cinfo->err->emit_message((j_common_ptr)cinfo, v9);
          goto LABEL_16;
        }
      }
      else
      {
        comp_info = cinfo->comp_info;
        component_id = comp_info->component_id;
        v12 = comp_info[1].component_id;
        v13 = comp_info[2].component_id;
        v14 = component_id == 1;
        if ( component_id == 1 )
          v14 = v12 == 2;
        if ( v14 && v13 == 3 )
          goto LABEL_16;
        v15 = component_id == 82;
        if ( component_id == 82 )
          v15 = v12 == 71;
        if ( !v15 || v13 != 66 )
        {
          p_msg_parm = &cinfo->err->msg_parm;
          p_msg_parm->i[0] = component_id;
          p_msg_parm->i[1] = v12;
          p_msg_parm->i[2] = v13;
          cinfo->err->msg_code = 111;
          v9 = 1;
          goto LABEL_38;
        }
      }
      v5 = JCS_RGB;
      v6 = JCS_RGB;
LABEL_36:
      result = 1;
      cinfo->jpeg_color_space = v5;
      cinfo->out_color_space = v6;
      cinfo->scale_num = 1;
      cinfo->scale_denom = 1;
      LODWORD(cinfo->output_gamma) = 0;
      HIDWORD(cinfo->output_gamma) = 1072693248;
      *(_WORD *)&cinfo->buffered_image = 0;
      cinfo->dct_method = JDCT_ISLOW;
      *(_WORD *)&cinfo->do_fancy_upsampling = 257;
      cinfo->quantize_colors = 0;
      cinfo->dither_mode = JDITHER_FS;
      cinfo->two_pass_quantize = 0;
      cinfo->desired_number_of_colors = 256;
      cinfo->colormap = 0;
      cinfo->enable_1pass_quant = 0;
      cinfo->enable_external_quant = 0;
      cinfo->enable_2pass_quant = 0;
      cinfo->global_state = 202;
      return result;
    case 2:
      return result;
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 10:
      return cinfo->inputctl->consume_input(cinfo);
    default:
      cinfo->err->msg_code = 20;
      cinfo->err->msg_parm.i[0] = cinfo->global_state;
      cinfo->err->error_exit((j_common_ptr)cinfo);
      return 0;
  }
}

//----- (0047BA14) --------------------------------------------------------
boolean __fastcall jpeg_input_complete(j_decompress_ptr cinfo)
{
  if ( (unsigned int)(cinfo->global_state - 200) >= 0xB )
  {
    cinfo->err->msg_code = 20;
    cinfo->err->msg_parm.i[0] = cinfo->global_state;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  return cinfo->inputctl->eoi_reached;
}

//----- (0047BA3E) --------------------------------------------------------
boolean __fastcall jpeg_has_multiple_scans(j_decompress_ptr cinfo)
{
  if ( (unsigned int)(cinfo->global_state - 202) >= 9 )
  {
    cinfo->err->msg_code = 20;
    cinfo->err->msg_parm.i[0] = cinfo->global_state;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  return cinfo->inputctl->has_multiple_scans;
}

//----- (0047BA68) --------------------------------------------------------
boolean __fastcall jpeg_finish_decompress(j_decompress_ptr cinfo)
{
  int global_state; // r0
  jpeg_input_controller *inputctl; // r0

  global_state = cinfo->global_state;
  if ( (unsigned int)(global_state - 205) > 1 || cinfo->buffered_image )
  {
    if ( global_state == 210 )
      goto LABEL_10;
    if ( global_state != 207 )
    {
      cinfo->err->msg_code = 20;
      cinfo->err->msg_parm.i[0] = cinfo->global_state;
      cinfo->err->error_exit((j_common_ptr)cinfo);
      goto LABEL_10;
    }
  }
  else
  {
    if ( cinfo->output_scanline < cinfo->output_height )
    {
      cinfo->err->msg_code = 67;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    cinfo->master->finish_output_pass(cinfo);
  }
  cinfo->global_state = 210;
LABEL_10:
  while ( 1 )
  {
    inputctl = cinfo->inputctl;
    if ( inputctl->eoi_reached )
      break;
    if ( !inputctl->consume_input(cinfo) )
      return 0;
  }
  cinfo->src->term_source(cinfo);
  jpeg_abort((j_common_ptr)cinfo);
  return 1;
}

//----- (0047BAE8) --------------------------------------------------------
boolean __fastcall jpeg_start_decompress(j_decompress_ptr cinfo)
{
  int global_state; // r0
  jpeg_decomp_master **p_master; // r5
  int v4; // r0

  global_state = cinfo->global_state;
  if ( global_state == 202 )
  {
    jinit_master_decompress(cinfo);
    if ( cinfo->buffered_image )
    {
      v4 = 207;
      goto LABEL_18;
    }
    cinfo->global_state = 203;
    goto LABEL_9;
  }
  if ( global_state == 203 )
  {
LABEL_9:
    if ( cinfo->inputctl->has_multiple_scans )
    {
      cinfo->err->msg_code = 48;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    cinfo->output_scan_number = cinfo->input_scan_number;
    goto LABEL_12;
  }
  if ( global_state != 204 )
  {
    cinfo->err->msg_code = 20;
    cinfo->err->msg_parm.i[0] = cinfo->global_state;
    cinfo->err->error_exit((j_common_ptr)cinfo);
LABEL_12:
    p_master = &cinfo->master;
    if ( cinfo->global_state != 204 )
    {
      cinfo->master->prepare_for_output_pass(cinfo);
      cinfo->global_state = 204;
      cinfo->output_scanline = 0;
    }
    goto LABEL_14;
  }
  p_master = &cinfo->master;
LABEL_14:
  while ( (*p_master)->is_dummy_pass )
  {
    cinfo->err->msg_code = 48;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v4 = 205;
  if ( cinfo->raw_data_out )
    v4 = 206;
LABEL_18:
  cinfo->global_state = v4;
  return 1;
}

//----- (0047BB9A) --------------------------------------------------------
JDIMENSION __fastcall jpeg_read_scanlines(j_decompress_ptr cinfo, JSAMPARRAY scanlines, JDIMENSION max_lines)
{
  JDIMENSION output_scanline; // r0
  jpeg_progress_mgr *progress; // r1
  JDIMENSION result; // r0
  JDIMENSION v9[5]; // [sp+4h] [bp-14h] BYREF

  if ( cinfo->global_state != 205 )
  {
    cinfo->err->msg_code = 20;
    cinfo->err->msg_parm.i[0] = cinfo->global_state;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  output_scanline = cinfo->output_scanline;
  if ( output_scanline >= cinfo->output_height )
  {
    cinfo->err->msg_code = 123;
    cinfo->err->emit_message((j_common_ptr)cinfo, -1);
    return 0;
  }
  else
  {
    progress = cinfo->progress;
    if ( progress )
    {
      progress->pass_counter = output_scanline;
      cinfo->progress->pass_limit = cinfo->output_height;
      cinfo->progress->progress_monitor((j_common_ptr)cinfo);
    }
    v9[0] = 0;
    cinfo->main->process_data(cinfo, scanlines, v9, max_lines);
    result = v9[0];
    cinfo->output_scanline += v9[0];
  }
  return result;
}
// 47BB9A: using guessed type JDIMENSION var_14[5];

//----- (0047BC1A) --------------------------------------------------------
JDIMENSION __fastcall jpeg_read_raw_data(j_decompress_ptr cinfo, JSAMPIMAGE data, JDIMENSION max_lines)
{
  JDIMENSION output_scanline; // r0
  jpeg_progress_mgr *progress; // r1
  unsigned int v8; // r5

  if ( cinfo->global_state != 206 )
  {
    cinfo->err->msg_code = 20;
    cinfo->err->msg_parm.i[0] = cinfo->global_state;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  output_scanline = cinfo->output_scanline;
  if ( output_scanline >= cinfo->output_height )
  {
    cinfo->err->msg_code = 123;
    cinfo->err->emit_message((j_common_ptr)cinfo, -1);
    return 0;
  }
  progress = cinfo->progress;
  if ( progress )
  {
    progress->pass_counter = output_scanline;
    cinfo->progress->pass_limit = cinfo->output_height;
    cinfo->progress->progress_monitor((j_common_ptr)cinfo);
  }
  v8 = cinfo->min_DCT_scaled_size * cinfo->max_v_samp_factor;
  if ( v8 > max_lines )
  {
    cinfo->err->msg_code = 23;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  if ( !cinfo->coef->decompress_data(cinfo, data) )
    return 0;
  cinfo->output_scanline += v8;
  return v8;
}

//----- (0047BCAC) --------------------------------------------------------
void __fastcall jpeg_stdio_dest(j_compress_ptr cinfo, FILE *outfile)
{
  jpeg_destination_mgr *dest; // r0

  dest = cinfo->dest;
  if ( !dest )
  {
    dest = (jpeg_destination_mgr *)cinfo->mem->alloc_small((j_common_ptr)cinfo, 0, 28);
    cinfo->dest = dest;
  }
  dest->init_destination = init_destination;
  dest->empty_output_buffer = empty_output_buffer;
  dest->term_destination = term_destination;
  dest[1].next_output_byte = (JOCTET *)outfile;
}

//----- (0047BCE8) --------------------------------------------------------
void __fastcall init_destination(j_compress_ptr cinfo)
{
  jpeg_destination_mgr *dest; // r4
  int v2; // r0

  dest = cinfo->dest;
  v2 = ((int (*)(void))cinfo->mem->alloc_small)();
  dest[1].free_in_buffer = v2;
  dest->next_output_byte = (JOCTET *)v2;
  dest->free_in_buffer = 4096;
}

//----- (0047BD06) --------------------------------------------------------
boolean __fastcall empty_output_buffer(j_compress_ptr cinfo)
{
  jpeg_destination_mgr *dest; // r5

  dest = cinfo->dest;
  if ( fwrite((const void *)dest[1].free_in_buffer, 1u, 0x1000u, (FILE *)dest[1].next_output_byte) != 4096 )
  {
    cinfo->err->msg_code = 37;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  dest->next_output_byte = (JOCTET *)dest[1].free_in_buffer;
  dest->free_in_buffer = 4096;
  return 1;
}

//----- (0047BD46) --------------------------------------------------------
void __fastcall term_destination(j_compress_ptr cinfo)
{
  jpeg_destination_mgr *dest; // r6
  size_t free_in_buffer; // r0
  jpeg_destination_mgr *v4; // r6
  FILE *next_output_byte; // t1

  dest = cinfo->dest;
  free_in_buffer = dest->free_in_buffer;
  if ( free_in_buffer == 4096 )
  {
    v4 = dest + 1;
  }
  else
  {
    next_output_byte = (FILE *)dest[1].next_output_byte;
    v4 = dest + 1;
    if ( fwrite((const void *)v4->free_in_buffer, 1u, 4096 - free_in_buffer, next_output_byte) != 4096 - free_in_buffer )
    {
      cinfo->err->msg_code = 37;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
  }
  fflush((FILE *)v4->next_output_byte);
  if ( ferror((FILE *)v4->next_output_byte) )
  {
    cinfo->err->msg_code = 37;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
}

//----- (0047BDA8) --------------------------------------------------------
void __fastcall jpeg_stdio_src(j_decompress_ptr cinfo, FILE *infile)
{
  jpeg_source_mgr *src; // r0
  jpeg_source_mgr *v5; // r6
  jpeg_memory_mgr *mem; // r0

  src = cinfo->src;
  if ( !src )
  {
    v5 = (jpeg_source_mgr *)cinfo->mem->alloc_small((j_common_ptr)cinfo, 0, 40);
    mem = cinfo->mem;
    cinfo->src = v5;
    v5[1].bytes_in_buffer = (int)mem->alloc_small((j_common_ptr)cinfo, 0, 4096);
    src = cinfo->src;
  }
  src[1].next_input_byte = (const JOCTET *)infile;
  src->next_input_byte = 0;
  src->bytes_in_buffer = 0;
  src->init_source = init_source;
  src->fill_input_buffer = fill_input_buffer;
  src->term_source = term_source;
  src->skip_input_data = skip_input_data;
  src->resync_to_restart = jpeg_resync_to_restart;
}

//----- (0047BE1C) --------------------------------------------------------
void __fastcall init_source(j_decompress_ptr cinfo)
{
  LOBYTE(cinfo->src[1].init_source) = 1;
}

//----- (0047BE26) --------------------------------------------------------
boolean __fastcall fill_input_buffer(j_decompress_ptr cinfo)
{
  jpeg_source_mgr *src; // r5
  size_t v3; // r0

  src = cinfo->src;
  v3 = fread((void *)src[1].bytes_in_buffer, 1u, 0x1000u, (FILE *)src[1].next_input_byte);
  if ( !v3 )
  {
    if ( LOBYTE(src[1].init_source) )
    {
      cinfo->err->msg_code = 42;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    cinfo->err->msg_code = 120;
    cinfo->err->emit_message((j_common_ptr)cinfo, -1);
    *(_BYTE *)src[1].bytes_in_buffer = -1;
    *(_BYTE *)(src[1].bytes_in_buffer + 1) = -39;
    v3 = 2;
  }
  LOBYTE(src[1].init_source) = 0;
  src->next_input_byte = (const JOCTET *)src[1].bytes_in_buffer;
  src->bytes_in_buffer = v3;
  return 1;
}

//----- (0047BE82) --------------------------------------------------------
void __fastcall skip_input_data(j_decompress_ptr cinfo, int num_bytes)
{
  int v2; // r4
  jpeg_source_mgr *src; // r8
  int bytes_in_buffer; // r9
  jpeg_source_mgr *i; // r6
  size_t v7; // r0
  const JOCTET *v8; // r1
  __int64 v9; // r0

  v2 = num_bytes;
  if ( num_bytes >= 1 )
  {
    src = cinfo->src;
    bytes_in_buffer = src->bytes_in_buffer;
    if ( bytes_in_buffer < num_bytes )
    {
      for ( i = cinfo->src; ; i = cinfo->src )
      {
        v7 = fread((void *)i[1].bytes_in_buffer, 1u, 0x1000u, (FILE *)i[1].next_input_byte);
        v2 -= bytes_in_buffer;
        if ( !v7 )
        {
          if ( LOBYTE(i[1].init_source) )
          {
            cinfo->err->msg_code = 42;
            cinfo->err->error_exit((j_common_ptr)cinfo);
          }
          cinfo->err->msg_code = 120;
          cinfo->err->emit_message((j_common_ptr)cinfo, -1);
          *(_BYTE *)i[1].bytes_in_buffer = -1;
          *(_BYTE *)(i[1].bytes_in_buffer + 1) = -39;
          v7 = 2;
        }
        v8 = (const JOCTET *)i[1].bytes_in_buffer;
        LOBYTE(i[1].init_source) = 0;
        i->next_input_byte = v8;
        i->bytes_in_buffer = v7;
        bytes_in_buffer = src->bytes_in_buffer;
        if ( v2 <= bytes_in_buffer )
          break;
      }
    }
    HIDWORD(v9) = bytes_in_buffer - v2;
    LODWORD(v9) = &src->next_input_byte[v2];
    *(_QWORD *)&src->next_input_byte = v9;
  }
}

//----- (0047BF30) --------------------------------------------------------
void __fastcall jinit_d_coef_controller(j_decompress_ptr cinfo, boolean need_full_buffer)
{
  int v3; // r6
  int v4; // r4
  char *v5; // r0
  int32x4_t v6; // q8
  int32x4_t v7; // q10
  int32x4_t v8; // q9

  v3 = need_full_buffer;
  v4 = cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 72);
  cinfo->coef = (jpeg_d_coef_controller *)v4;
  *(_DWORD *)(v4 + 8) = start_output_pass;
  *(_DWORD *)v4 = start_input_pass;
  if ( v3 )
  {
    cinfo->err->msg_code = 48;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  else
  {
    v5 = (char *)cinfo->mem->alloc_large(cinfo, 1, 1280);
    v6.n128_u64[0] = 0x10000000080LL;
    v6.n128_u64[1] = 0x20000000180LL;
    v7 = vdupq_n_s32((unsigned int)v5);
    v8.n128_u64[0] = 0x30000000280LL;
    v8.n128_u64[1] = 0x40000000380LL;
    *(_DWORD *)(v4 + 32) = v5;
    *(_DWORD *)(v4 + 68) = v5 + 1152;
    *(_DWORD *)(v4 + 4) = dummy_consume_data;
    *(_DWORD *)(v4 + 12) = decompress_onepass;
    *(_DWORD *)(v4 + 16) = 0;
    *(int32x4_t *)(v4 + 36) = vaddq_s32(v7, v6);
    *(int32x4_t *)(v4 + 52) = vaddq_s32(v7, v8);
  }
}

//----- (0047C000) --------------------------------------------------------
void __fastcall start_input_pass(j_decompress_ptr cinfo)
{
  int comps_in_scan; // r3
  jpeg_d_coef_controller *coef; // r2
  int v3; // r0
  JDIMENSION total_iMCU_rows; // r12
  jpeg_component_info *v5; // r0
  int *p_last_row_height; // r3

  comps_in_scan = cinfo->comps_in_scan;
  coef = cinfo->coef;
  cinfo->input_iMCU_row = 0;
  if ( comps_in_scan <= 1 )
  {
    total_iMCU_rows = cinfo->total_iMCU_rows;
    v5 = cinfo->cur_comp_info[0];
    p_last_row_height = &v5->last_row_height;
    if ( total_iMCU_rows != 1 )
      p_last_row_height = &v5->v_samp_factor;
    v3 = *p_last_row_height;
  }
  else
  {
    v3 = 1;
  }
  coef[1].start_input_pass = 0;
  coef[1].consume_data = 0;
  coef[1].start_output_pass = (void (*)(j_decompress_ptr))v3;
}

//----- (0047C036) --------------------------------------------------------
void __fastcall start_output_pass(j_decompress_ptr cinfo)
{
  cinfo->output_iMCU_row = 0;
}

//----- (0047C03E) --------------------------------------------------------
int __fastcall dummy_consume_data(j_decompress_ptr cinfo)
{
  return 0;
}

//----- (0047C042) --------------------------------------------------------
int __fastcall decompress_onepass(j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
{
  jpeg_d_coef_controller *coef; // r3
  JDIMENSION total_iMCU_rows; // r1
  void (*start_output_pass)(j_decompress_ptr); // r0
  JDIMENSION start_input_pass; // r8
  int comps_in_scan; // r1
  int v8; // r12
  int v9; // r3
  jpeg_component_info *v10; // r10
  int MCU_height; // r0
  int *p_MCU_width; // r2
  int component_index; // r3
  int v14; // lr
  inverse_DCT_method_ptr v15; // r5
  int DCT_scaled_size; // r1
  int v17; // r4
  JSAMPROW *v18; // r11
  int v19; // r9
  int v20; // r4
  JDIMENSION input_iMCU_row; // r0
  unsigned int v22; // r2
  jpeg_d_coef_controller *v23; // r0
  int v24; // r1
  jpeg_component_info *v26; // r3
  int *p_last_row_height; // r6
  jpeg_d_coef_controller *v28; // [sp+4h] [bp-54h]
  JDIMENSION v30; // [sp+Ch] [bp-4Ch]
  JDIMENSION v31; // [sp+10h] [bp-48h]
  int v32; // [sp+14h] [bp-44h]
  _BOOL4 v33; // [sp+18h] [bp-40h]
  int (*consume_data)(j_decompress_ptr); // [sp+1Ch] [bp-3Ch]
  void **p_decompress_data; // [sp+20h] [bp-38h]
  int v36; // [sp+24h] [bp-34h]
  JDIMENSION v37; // [sp+28h] [bp-30h]
  int v38; // [sp+30h] [bp-28h]
  int v39; // [sp+34h] [bp-24h]
  void **v40; // [sp+38h] [bp-20h]

  coef = cinfo->coef;
  total_iMCU_rows = cinfo->total_iMCU_rows;
  start_output_pass = coef[1].start_output_pass;
  consume_data = coef[1].consume_data;
  if ( (int)consume_data >= (int)start_output_pass )
    goto LABEL_27;
  v37 = total_iMCU_rows - 1;
  v31 = cinfo->MCUs_per_row - 1;
  start_input_pass = (JDIMENSION)coef[1].start_input_pass;
  p_decompress_data = (void **)&coef[1].decompress_data;
  v28 = coef;
  do
  {
    if ( start_input_pass > v31 )
      goto LABEL_25;
    do
    {
      jzero_far(*p_decompress_data, cinfo->blocks_in_MCU << 7);
      if ( !((int (__fastcall *)(j_decompress_ptr, void **))cinfo->entropy->decode_mcu)(cinfo, p_decompress_data) )
      {
        v28[1].start_input_pass = (void (*)(j_decompress_ptr))start_input_pass;
        v28[1].consume_data = consume_data;
        return 0;
      }
      comps_in_scan = cinfo->comps_in_scan;
      if ( comps_in_scan >= 1 )
      {
        v8 = 0;
        v9 = 0;
        v30 = start_input_pass;
        do
        {
          v10 = cinfo->cur_comp_info[v9];
          if ( v10->component_needed )
          {
            MCU_height = v10->MCU_height;
            p_MCU_width = &v10->MCU_width;
            if ( start_input_pass >= v31 )
              p_MCU_width = &v10->last_col_width;
            if ( MCU_height >= 1 )
            {
              v32 = v9;
              component_index = v10->component_index;
              v36 = v10->MCU_sample_width * start_input_pass;
              v14 = *p_MCU_width;
              v15 = cinfo->idct->inverse_DCT[component_index];
              DCT_scaled_size = v10->DCT_scaled_size;
              v17 = 0;
              v18 = &output_buf[component_index][DCT_scaled_size * (_DWORD)consume_data];
              v33 = *p_MCU_width < 1;
              while ( 1 )
              {
                if ( cinfo->input_iMCU_row >= v37 )
                {
                  if ( (int)consume_data + v17 < v10->last_row_height && !v33 )
                  {
LABEL_16:
                    v38 = v17;
                    v19 = 0;
                    v20 = v36;
                    v39 = v8;
                    v40 = &p_decompress_data[v8];
                    do
                    {
                      v15(cinfo, v10, (JCOEFPTR)v40[v19++], v18, v20);
                      DCT_scaled_size = v10->DCT_scaled_size;
                      v20 += DCT_scaled_size;
                    }
                    while ( v19 < v14 );
                    MCU_height = v10->MCU_height;
                    v17 = v38;
                    v8 = v39;
                  }
                }
                else if ( v14 >= 1 )
                {
                  goto LABEL_16;
                }
                ++v17;
                v18 += DCT_scaled_size;
                v8 += v10->MCU_width;
                if ( v17 >= MCU_height )
                {
                  comps_in_scan = cinfo->comps_in_scan;
                  start_input_pass = v30;
                  v9 = v32;
                  break;
                }
              }
            }
          }
          else
          {
            v8 += v10->MCU_blocks;
          }
          ++v9;
        }
        while ( v9 < comps_in_scan );
      }
      ++start_input_pass;
    }
    while ( start_input_pass <= v31 );
    coef = v28;
    start_output_pass = v28[1].start_output_pass;
LABEL_25:
    start_input_pass = 0;
    coef[1].start_input_pass = 0;
    consume_data = (int (*)(j_decompress_ptr))((char *)consume_data + 1);
  }
  while ( (int)consume_data < (int)start_output_pass );
  total_iMCU_rows = cinfo->total_iMCU_rows;
LABEL_27:
  input_iMCU_row = cinfo->input_iMCU_row;
  ++cinfo->output_iMCU_row;
  v22 = input_iMCU_row + 1;
  cinfo->input_iMCU_row = input_iMCU_row + 1;
  if ( input_iMCU_row + 1 >= total_iMCU_rows )
  {
    cinfo->inputctl->finish_input_pass(cinfo);
    return 4;
  }
  else
  {
    v23 = cinfo->coef;
    if ( cinfo->comps_in_scan <= 1 )
    {
      v26 = cinfo->cur_comp_info[0];
      p_last_row_height = &v26->last_row_height;
      if ( v22 < total_iMCU_rows - 1 )
        p_last_row_height = &v26->v_samp_factor;
      v24 = *p_last_row_height;
    }
    else
    {
      v24 = 1;
    }
    v23[1].start_input_pass = 0;
    v23[1].consume_data = 0;
    v23[1].start_output_pass = (void (*)(j_decompress_ptr))v24;
    return 3;
  }
}

//----- (0047C258) --------------------------------------------------------
void __fastcall jinit_color_deconverter(j_decompress_ptr cinfo)
{
  jpeg_color_deconverter *v2; // r10
  J_COLOR_SPACE jpeg_color_space; // r0
  J_COLOR_SPACE out_color_space; // r0
  char *v5; // r6
  char *v6; // r5
  int v7; // r4
  int v8; // r8
  J_COLOR_SPACE v9; // r0
  int v10; // r0
  int v11; // r1
  J_COLOR_SPACE v12; // r0
  jpeg_color_deconverter *cconvert; // r10
  int i; // r0
  int v15; // r1
  int v16; // r3
  J_COLOR_SPACE v17; // r0
  jpeg_color_deconverter *v18; // r10
  int j; // r0
  int v20; // r1
  int v21; // r3
  int out_color_components; // r0

  v2 = (jpeg_color_deconverter *)cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 24);
  cinfo->cconvert = v2;
  v2->start_pass = start_pass_dcolor;
  jpeg_color_space = cinfo->jpeg_color_space;
  if ( (unsigned int)(jpeg_color_space - 2) < 2 )
  {
    if ( cinfo->num_components == 3 )
      goto LABEL_7;
    goto LABEL_6;
  }
  if ( (unsigned int)(jpeg_color_space - 4) < 2 )
  {
    if ( cinfo->num_components == 4 )
      goto LABEL_7;
LABEL_6:
    cinfo->err->msg_code = 10;
    cinfo->err->error_exit((j_common_ptr)cinfo);
    goto LABEL_7;
  }
  if ( jpeg_color_space != JCS_GRAYSCALE )
  {
    if ( cinfo->num_components > 0 )
      goto LABEL_7;
    goto LABEL_6;
  }
  if ( cinfo->num_components != 1 )
    goto LABEL_6;
LABEL_7:
  out_color_space = cinfo->out_color_space;
  v5 = (char *)&loc_2C8CFE + 2;
  v6 = (char *)&loc_5B6900;
  v7 = -14831872;
  v8 = -11728000;
  if ( out_color_space == JCS_CMYK )
  {
    v12 = cinfo->jpeg_color_space;
    cinfo->out_color_components = 4;
    if ( v12 == JCS_CMYK )
    {
      v2->color_convert = (void (*)(j_decompress_ptr, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int))null_convert;
      goto LABEL_31;
    }
    if ( v12 == JCS_YCCK )
    {
      v2->color_convert = (void (*)(j_decompress_ptr, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int))ycck_cmyk_convert;
      cconvert = cinfo->cconvert;
      cconvert[1].start_pass = (void (*)(j_decompress_ptr))cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 1024);
      cconvert[1].color_convert = (void (*)(j_decompress_ptr, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int))cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 1024);
      cconvert[2].start_pass = (void (*)(j_decompress_ptr))cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 1024);
      cconvert[2].color_convert = (void (*)(j_decompress_ptr, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int))cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 1024);
      for ( i = 0; i != 256; ++i )
      {
        v15 = v8 >> 16;
        v8 += (int)&elf_hash_chain[6496] + 1;
        *((_DWORD *)cconvert[1].start_pass + i) = v15;
        v16 = v7 >> 16;
        v7 += (int)&elf_hash_chain[12558] + 2;
        *((_DWORD *)cconvert[1].color_convert + i) = v16;
        *((_DWORD *)cconvert[2].start_pass + i) = v6;
        v6 -= 46802;
        *((_DWORD *)cconvert[2].color_convert + i) = v5;
        v5 -= 22554;
      }
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  if ( out_color_space == JCS_RGB )
  {
    v17 = cinfo->jpeg_color_space;
    cinfo->out_color_components = 4;
    if ( v17 == JCS_GRAYSCALE )
    {
      v2->color_convert = (void (*)(j_decompress_ptr, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int))gray_rgb_convert;
      goto LABEL_31;
    }
    if ( v17 == JCS_YCbCr )
    {
      v2->color_convert = (void (*)(j_decompress_ptr, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int))ycc_rgb_convert;
      v18 = cinfo->cconvert;
      v18[1].start_pass = (void (*)(j_decompress_ptr))cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 1024);
      v18[1].color_convert = (void (*)(j_decompress_ptr, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int))cinfo->mem->alloc_small(
                                                                                                    (j_common_ptr)cinfo,
                                                                                                    1,
                                                                                                    1024);
      v18[2].start_pass = (void (*)(j_decompress_ptr))cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 1024);
      v18[2].color_convert = (void (*)(j_decompress_ptr, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int))cinfo->mem->alloc_small(
                                                                                                    (j_common_ptr)cinfo,
                                                                                                    1,
                                                                                                    1024);
      for ( j = 0; j != 256; ++j )
      {
        v20 = v8 >> 16;
        v8 += (int)&elf_hash_chain[6496] + 1;
        *((_DWORD *)v18[1].start_pass + j) = v20;
        v21 = v7 >> 16;
        v7 += (int)&elf_hash_chain[12558] + 2;
        *((_DWORD *)v18[1].color_convert + j) = v21;
        *((_DWORD *)v18[2].start_pass + j) = v6;
        v6 -= 46802;
        *((_DWORD *)v18[2].color_convert + j) = v5;
        v5 -= 22554;
      }
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  if ( out_color_space != JCS_GRAYSCALE )
  {
    if ( out_color_space == cinfo->jpeg_color_space )
    {
      cinfo->out_color_components = cinfo->num_components;
      v2->color_convert = (void (*)(j_decompress_ptr, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int))null_convert;
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  v9 = cinfo->jpeg_color_space;
  cinfo->out_color_components = 1;
  if ( (v9 | 2) != 3 )
  {
LABEL_30:
    cinfo->err->msg_code = 27;
    cinfo->err->error_exit((j_common_ptr)cinfo);
    goto LABEL_31;
  }
  v2->color_convert = grayscale_convert;
  if ( cinfo->num_components >= 2 )
  {
    v10 = 1;
    v11 = 132;
    do
    {
      ++v10;
      *((_BYTE *)&cinfo->comp_info->component_id + v11) = 0;
      v11 += 84;
    }
    while ( v10 < cinfo->num_components );
  }
LABEL_31:
  if ( cinfo->quantize_colors )
    out_color_components = 1;
  else
    out_color_components = cinfo->out_color_components;
  cinfo->output_components = out_color_components;
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (0047C53E) --------------------------------------------------------
void __fastcall grayscale_convert(
        j_decompress_ptr cinfo,
        JSAMPIMAGE input_buf,
        JDIMENSION input_row,
        JSAMPARRAY output_buf,
        int num_rows)
{
  jcopy_sample_rows(*input_buf, input_row, output_buf, 0, num_rows, cinfo->output_width);
}

//----- (0047C560) --------------------------------------------------------
void __fastcall ycc_rgb_convert(
        j_decompress_ptr cinfo,
        JSAMPIMAGE input_buf,
        JDIMENSION input_row,
        JSAMPARRAY output_buf,
        int a5)
{
  int v5; // r6
  JSAMPLE *sample_range_limit; // r10
  jpeg_color_deconverter *cconvert; // r0
  jpeg_color_deconverter v8; // kr00_8
  void (*start_pass)(j_decompress_ptr); // r8
  void (*v10)(j_decompress_ptr, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int); // r11
  JSAMPROW v11; // r6
  JSAMPROW v12; // lr
  JSAMPROW v13; // r5
  JSAMPROW v14; // r12
  int v15; // r2
  int v16; // t1
  int v17; // r3
  int v18; // t1
  int v19; // r0
  int v20; // t1
  JDIMENSION output_width; // [sp+Ch] [bp-34h]
  int v22; // [sp+10h] [bp-30h]
  int v23; // [sp+14h] [bp-2Ch]
  JDIMENSION v24; // [sp+18h] [bp-28h]
  JSAMPROW *v25; // [sp+1Ch] [bp-24h]
  void (*color_convert)(j_decompress_ptr, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int); // [sp+20h] [bp-20h]

  v5 = a5;
  if ( a5 >= 1 )
  {
    output_width = cinfo->output_width;
    sample_range_limit = cinfo->sample_range_limit;
    cconvert = cinfo->cconvert;
    v8 = cconvert[1];
    color_convert = cconvert[1].color_convert;
    v10 = cconvert[2].color_convert;
    start_pass = cconvert[2].start_pass;
    do
    {
      v25 = output_buf + 1;
      v24 = input_row + 1;
      v23 = v5 - 1;
      v22 = v5;
      if ( output_width )
      {
        v11 = input_buf[1][input_row];
        v12 = (*input_buf)[input_row];
        v13 = input_buf[2][input_row];
        v14 = *output_buf;
        do
        {
          v16 = *v13++;
          v15 = v16;
          v18 = *v12++;
          v17 = v18;
          v19 = *((_DWORD *)v8.start_pass + v15) + v18;
          v20 = *v11++;
          *v14 = sample_range_limit[v19];
          v14[1] = sample_range_limit[v17 + ((*((_DWORD *)v10 + v20) + *((_DWORD *)start_pass + v15)) >> 16)];
          v14[2] = sample_range_limit[*((_DWORD *)color_convert + v20) + v17];
          v14 += 4;
        }
        while ( v8.color_convert != (void (*)(j_decompress_ptr, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int))((char *)&dword_0 + 1) );
      }
      output_buf = v25;
      v5 = v23;
      input_row = v24;
    }
    while ( v22 >= 2 );
  }
}
// 0: using guessed type int dword_0;

//----- (0047C624) --------------------------------------------------------
void __fastcall gray_rgb_convert(
        j_decompress_ptr cinfo,
        JSAMPIMAGE input_buf,
        JDIMENSION input_row,
        JSAMPARRAY output_buf,
        int a5)
{
  int v5; // r12
  JDIMENSION output_width; // lr
  JSAMPARRAY v7; // r5
  JDIMENSION v8; // r4
  int v9; // r8
  JSAMPROW v10; // r4
  _BYTE *v11; // r5
  JDIMENSION v12; // r6
  char v13; // t1

  v5 = a5;
  if ( a5 >= 1 )
  {
    output_width = cinfo->output_width;
    do
    {
      v7 = output_buf;
      v8 = input_row;
      v9 = v5;
      ++output_buf;
      ++input_row;
      --v5;
      if ( output_width )
      {
        v10 = (*input_buf)[v8];
        v11 = *v7 + 1;
        v12 = output_width;
        do
        {
          v13 = *v10++;
          --v12;
          *v11 = v13;
          v11[1] = v13;
          *(v11 - 1) = v13;
          v11 += 4;
        }
        while ( v12 );
      }
    }
    while ( v9 >= 2 );
  }
}

//----- (0047C67A) --------------------------------------------------------
void __fastcall null_convert(
        j_decompress_ptr cinfo,
        JSAMPIMAGE input_buf,
        JDIMENSION input_row,
        JSAMPARRAY output_buf,
        int a5)
{
  int v5; // r12
  int num_components; // lr
  JDIMENSION output_width; // r9
  int i; // r10
  JSAMPROW v9; // r6
  JSAMPROW v10; // r4
  JDIMENSION v11; // r0
  JSAMPLE v12; // t1

  v5 = a5;
  if ( a5 >= 1 )
  {
    num_components = cinfo->num_components;
    output_width = cinfo->output_width;
    do
    {
      if ( num_components >= 1 )
      {
        for ( i = 0; i != num_components; ++i )
        {
          if ( output_width )
          {
            v9 = *output_buf;
            v10 = input_buf[i][input_row];
            v11 = output_width;
            do
            {
              v12 = *v10++;
              --v11;
              v9[i] = v12;
              v9 += num_components;
            }
            while ( v11 );
          }
        }
      }
      ++output_buf;
      ++input_row;
    }
    while ( v5-- > 1 );
  }
}

//----- (0047C6DC) --------------------------------------------------------
void __fastcall ycck_cmyk_convert(
        j_decompress_ptr cinfo,
        JSAMPIMAGE input_buf,
        JDIMENSION input_row,
        JSAMPARRAY output_buf,
        int a5)
{
  int v5; // r6
  JSAMPLE *sample_range_limit; // r4
  jpeg_color_deconverter *cconvert; // r0
  __int64 v8; // kr00_8
  JSAMPROW v9; // r11
  JSAMPROW v10; // lr
  JSAMPROW v11; // r6
  JSAMPROW v12; // r12
  JSAMPROW v13; // r3
  JDIMENSION v14; // r2
  int v15; // r9
  int v16; // t1
  int v17; // t1
  int v18; // r1
  JSAMPLE v19; // r0
  int v20; // t1
  JDIMENSION output_width; // [sp+4h] [bp-3Ch]
  int v23; // [sp+8h] [bp-38h]
  int v24; // [sp+Ch] [bp-34h]
  JDIMENSION v25; // [sp+10h] [bp-30h]
  JSAMPROW *v26; // [sp+14h] [bp-2Ch]
  void (*color_convert)(j_decompress_ptr, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int); // [sp+18h] [bp-28h]
  jpeg_color_deconverter v28; // [sp+1Ch] [bp-24h]

  v5 = a5;
  if ( a5 >= 1 )
  {
    output_width = cinfo->output_width;
    sample_range_limit = cinfo->sample_range_limit;
    cconvert = cinfo->cconvert;
    v28 = cconvert[1];
    v8 = *(_QWORD *)&cconvert[1].color_convert;
    color_convert = cconvert[2].color_convert;
    do
    {
      v26 = output_buf + 1;
      v25 = input_row + 1;
      v24 = v5 - 1;
      v23 = v5;
      if ( output_width )
      {
        v9 = input_buf[3][input_row];
        v10 = input_buf[1][input_row];
        v11 = input_buf[2][input_row];
        v12 = (*input_buf)[input_row];
        v13 = *output_buf;
        v14 = output_width;
        do
        {
          v16 = *v11++;
          v15 = v16;
          --v14;
          v17 = *v12++;
          v18 = v17 ^ 0xFF;
          v19 = sample_range_limit[(v17 ^ 0xFF) - *((_DWORD *)v28.start_pass + v15)];
          v20 = *v10++;
          *v13 = v19;
          v13[1] = sample_range_limit[v18
                                    - ((*(_DWORD *)(HIDWORD(v8) + 4 * v15) + *((_DWORD *)color_convert + v20)) >> 16)];
          v13[2] = sample_range_limit[v18 - *((_DWORD *)v28.color_convert + v20)];
          LOBYTE(v20) = *v9++;
          v13[3] = v20;
          v13 += 4;
        }
        while ( v14 );
      }
      output_buf = v26;
      v5 = v24;
      input_row = v25;
    }
    while ( v23 >= 2 );
  }
}

//----- (0047C7A8) --------------------------------------------------------
void __fastcall jinit_inverse_dct(j_decompress_ptr cinfo)
{
  jpeg_inverse_dct *v2; // r0
  jpeg_inverse_dct *v3; // r8
  int v4; // r5
  void **p_dct_table; // r6
  void *v6; // r0

  v2 = (jpeg_inverse_dct *)cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 36);
  cinfo->idct = v2;
  v2->start_pass = start_pass;
  if ( cinfo->num_components >= 1 )
  {
    v3 = v2 + 1;
    v4 = 0;
    p_dct_table = &cinfo->comp_info->dct_table;
    do
    {
      v6 = (void *)cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 256);
      *p_dct_table = v6;
      p_dct_table += 21;
      memset(v6, 0, 0x100u);
      *((_DWORD *)&v3->start_pass + v4++) = -1;
    }
    while ( v4 < cinfo->num_components );
  }
}

//----- (0047C810) --------------------------------------------------------
void __fastcall start_pass(j_decompress_ptr cinfo)
{
  JQUANT_TBL *quant_table; // r12
  int v3; // r5
  void (*v4)(j_decompress_ptr, jpeg_component_info *, JCOEFPTR, JSAMPARRAY, JDIMENSION); // r9
  int v5; // r10
  jpeg_component_info *i; // r6
  void (**v7)(j_decompress_ptr); // r1
  int *v8; // r1
  void (*v9)(j_decompress_ptr); // t1
  bool v10; // zf
  UINT16 *v11; // r1
  int v12; // r3
  float *v13; // r2
  double v14; // d17
  unsigned __int16 *v15; // r4
  float v16; // s0
  float v17; // s0
  float v18; // s0
  float v19; // s0
  float v20; // s0
  float v21; // s0
  float v22; // s0
  unsigned int v23; // r0
  float v24; // s0
  jpeg_inverse_dct *idct; // [sp+4h] [bp-54h]

  if ( cinfo->num_components >= 1 )
  {
    v3 = 0;
    idct = cinfo->idct;
    v4 = 0;
    v5 = 0;
    for ( i = cinfo->comp_info; i->DCT_scaled_size == 8; ++i )
    {
      if ( cinfo->dct_method != JDCT_FLOAT )
      {
        cinfo->err->msg_code = 48;
        goto LABEL_8;
      }
      v5 = 2;
      v4 = jpeg_idct_float;
LABEL_9:
      v7 = &idct->start_pass + v3;
      v7[1] = (void (*)(j_decompress_ptr))v4;
      if ( i->component_needed )
      {
        v9 = v7[5];
        v8 = (int *)(v7 + 5);
        v10 = v9 == (void (*)(j_decompress_ptr))v5;
        if ( v9 != (void (*)(j_decompress_ptr))v5 )
        {
          quant_table = i->quant_table;
          v10 = quant_table == 0;
        }
        if ( !v10 )
        {
          *v8 = v5;
          if ( v5 == 2 )
          {
            v11 = &quant_table->quantval[7];
            v12 = 0;
            v13 = (float *)((char *)i->dct_table + 28);
            do
            {
              v14 = start_pass(jpeg_decompress_struct *)::aanscalefactor[v12];
              v15 = &quant_table->quantval[v12 * 8];
              ++v12;
              v16 = v14 * (double)*(v11 - 7);
              *(v13 - 7) = v16;
              v17 = v14 * (double)v15[1] * 1.38703985;
              *(v13 - 6) = v17;
              v18 = v14 * (double)v15[2] * 1.30656296;
              *(v13 - 5) = v18;
              v19 = v14 * (double)v15[3] * 1.1758756;
              *(v13 - 4) = v19;
              v20 = v14 * (double)v15[4];
              *(v13 - 3) = v20;
              v21 = v14 * (double)v15[5] * 0.785694958;
              *(v13 - 2) = v21;
              v22 = v14 * (double)v15[6] * 0.5411961;
              *(v13 - 1) = v22;
              v23 = *v11;
              v11 += 8;
              v24 = v14 * (double)v23 * 0.275899379;
              *v13 = v24;
              v13 += 8;
            }
            while ( v12 != 8 );
          }
          else
          {
            cinfo->err->msg_code = 48;
            cinfo->err->error_exit((j_common_ptr)cinfo);
          }
        }
      }
      if ( ++v3 >= cinfo->num_components )
        return;
    }
    cinfo->err->msg_code = 7;
    cinfo->err->msg_parm.i[0] = i->DCT_scaled_size;
LABEL_8:
    cinfo->err->error_exit((j_common_ptr)cinfo);
    goto LABEL_9;
  }
}
// 47C8D6: variable 'quant_table' is possibly undefined

//----- (0047CA30) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall jpeg_make_d_derived_tbl(j_decompress_ptr cinfo, boolean isDC, int tblno, d_derived_tbl **pdtbl)
{
  int8x8_t v4; // d20
  jpeg_error_mgr **v8; // r0
  JHUFF_TBL **v9; // r1
  JHUFF_TBL *v10; // r11
  d_derived_tbl *v11; // r0
  int v12; // r6
  int v13; // r9
  size_t v14; // r5
  int v15; // r6
  int v16; // r5
  int v17; // r11
  int v18; // r9
  JHUFF_TBL *v19; // r9
  int v20; // r1
  d_derived_tbl *v21; // r11
  int v22; // r2
  UINT8 *v23; // r0
  int v24; // r3
  INT32 *v25; // r6
  UINT8 *look_sym; // r0
  unsigned int v27; // r3
  int v28; // r12
  int v29; // r8
  int32x4_t v30; // q8
  int v31; // r2
  int v32; // r6
  int v33; // r1
  int v34; // r2
  UINT8 *v35; // lr
  int v36; // r10
  int v37; // r1
  unsigned int v38; // r6
  _BOOL4 v39; // r8
  unsigned int v40; // r9
  unsigned int v41; // r4
  _BOOL4 v42; // r11
  bool v43; // r4
  bool v44; // cc
  int v45; // r6
  int v46; // r1
  UINT8 *v47; // r6
  unsigned int v48; // r4
  int32x4_t *v49; // r2
  int8x8_t v50; // d18
  int v51; // d19.s[0]
  int v52; // r2
  int v53; // r0
  unsigned __int8 *huffval; // r4
  int v55; // r5
  int v56; // [sp+4h] [bp-574h]
  int v57; // [sp+8h] [bp-570h]
  j_decompress_ptr v58; // [sp+Ch] [bp-56Ch]
  int v59; // [sp+18h] [bp-560h]
  d_derived_tbl *v60; // [sp+20h] [bp-558h]
  JHUFF_TBL *v61; // [sp+24h] [bp-554h]
  int v62; // [sp+28h] [bp-550h]
  int v63; // [sp+2Ch] [bp-54Ch]
  int v64; // [sp+30h] [bp-548h]
  unsigned int v65; // [sp+34h] [bp-544h]
  int v66; // [sp+40h] [bp-538h]
  int v67; // [sp+44h] [bp-534h]
  unsigned int v68; // [sp+48h] [bp-530h]
  unsigned int v69; // [sp+4Ch] [bp-52Ch]
  _DWORD v70[257]; // [sp+50h] [bp-528h] BYREF
  char v71[257]; // [sp+457h] [bp-121h] BYREF

  v57 = isDC;
  if ( (unsigned int)tblno >= 4 )
  {
    cinfo->err->msg_code = 50;
    cinfo->err->msg_parm.i[0] = tblno;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v8 = &cinfo->err + tblno;
  v9 = (JHUFF_TBL **)(v8 + 44);
  if ( v57 )
    v9 = (JHUFF_TBL **)(v8 + 40);
  v10 = *v9;
  if ( !*v9 )
  {
    cinfo->err->msg_code = 50;
    cinfo->err->msg_parm.i[0] = tblno;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v11 = *pdtbl;
  if ( !*pdtbl )
  {
    v11 = (d_derived_tbl *)cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 1424);
    *pdtbl = v11;
  }
  v12 = 1;
  v13 = 0;
  v60 = v11;
  v11->pub = v10;
  do
  {
    v14 = v10->bits[v12];
    if ( (int)(v13 + v14) > 256 )
    {
      cinfo->err->msg_code = 8;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    if ( v14 )
    {
      memset(&v71[v13], (unsigned __int8)v12, v14);
      v13 += v14;
    }
    ++v12;
  }
  while ( v12 != 17 );
  v61 = v10;
  v71[v13] = 0;
  v15 = (unsigned __int8)v71[0];
  v58 = cinfo;
  v56 = v13;
  if ( v71[0] )
  {
    v16 = 0;
    v17 = 0;
    v18 = (unsigned __int8)v71[0];
    do
    {
      if ( v18 == (unsigned __int8)v15 )
      {
        do
        {
          v70[v16] = v17++;
          v15 = (unsigned __int8)v71[++v16];
        }
        while ( v18 == v15 );
      }
      if ( v17 >= 1 << v18 )
      {
        cinfo->err->msg_code = 8;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      ++v18;
      v17 *= 2;
    }
    while ( v15 << 24 );
  }
  v19 = v61;
  v20 = 0;
  v21 = v60;
  v22 = 0;
  v23 = &v61->bits[1];
  do
  {
    if ( v23[v20] )
    {
      v60->valoffset[v20 + 1] = v22 - v70[v22];
      v22 += v23[v20];
      v24 = v70[v22 - 1];
    }
    else
    {
      v24 = -1;
    }
    v25 = &v60->maxcode[v20++];
    v25[1] = v24;
  }
  while ( v20 != 16 );
  v60->maxcode[17] = (INT32)"Ev";
  memset(v60->look_nbits, 0, sizeof(v60->look_nbits));
  look_sym = v60->look_sym;
  v27 = 1;
  v28 = 0;
  do
  {
    if ( v19->bits[v27] )
    {
      v29 = 1;
      v30 = vdupq_n_s32(v27);
      v31 = 1 << (8 - v27);
      v32 = 0;
      v33 = ~v31;
      if ( ~v31 < -1 )
        v33 = -2;
      v63 = (int)&v60->look_sym[v31 + 2 + v33];
      v64 = v31 + v33;
      v69 = v31 + v33 + 2;
      v68 = v69 & 0xFFFFFFFC;
      v62 = v28 + 1;
      v59 = v31 - (v69 & 0xFFFFFFFC);
      do
      {
        v35 = &v19->huffval[v28];
        v36 = v70[v28] << (8 - v27);
        if ( v69 >= 4 && v68 )
        {
          v66 = v32;
          v37 = v62 + v32;
          v38 = (unsigned int)&v21->look_nbits[v36];
          v65 = (unsigned int)&v19->huffval[v37];
          v67 = v29;
          v39 = v63 + v36 > v38;
          v40 = (unsigned int)&v60->look_nbits[v64 + 2 + v36];
          v41 = (unsigned int)&v21->look_sym[v36];
          v42 = v41 < v40;
          v43 = v41 < v65;
          v44 = v65 > v38;
          v45 = 0;
          v46 = 0;
          if ( v44 )
            v45 = 1;
          if ( (unsigned int)v35 < v40 )
            v46 = 1;
          if ( v39 && v42 )
          {
            v34 = 1 << (8 - v27);
            v19 = v61;
          }
          else
          {
            v19 = v61;
            if ( (v46 & v45) == 0 )
            {
              v34 = 1 << (8 - v27);
              v21 = v60;
              v32 = v66;
              v29 = v67;
              if ( !v43 || (unsigned int)v35 >= v63 + v36 )
              {
                v47 = &look_sym[v36];
                v48 = v68;
                v49 = (int32x4_t *)&v60->look_nbits[v36];
                v50.n64_u64[0] = vdup_n_s16(*v35).n64_u64[0];
                do
                {
                  v48 -= 4;
                  *(int8x8x2_t *)(&v4 - 1) = vuzp_s8(v50, v4);
                  *v49++ = v30;
                  *(_DWORD *)v47 = v51;
                  v47 += 8;
                }
                while ( v48 );
                v36 += v68;
                v34 = v59;
                v32 = v66;
                v29 = v67;
                if ( v69 == v68 )
                  goto LABEL_51;
              }
              goto LABEL_49;
            }
            v34 = 1 << (8 - v27);
          }
          v21 = v60;
          v32 = v66;
          v29 = v67;
        }
        else
        {
          v34 = 1 << (8 - v27);
        }
LABEL_49:
        v52 = v34 + 1;
        do
        {
          --v52;
          *(_DWORD *)&look_sym[4 * v36 - 1024] = v27;
          look_sym[v36++] = *v35;
        }
        while ( v52 > 1 );
LABEL_51:
        ++v32;
        ++v28;
        v44 = v29++ < v19->bits[v27];
      }
      while ( v44 );
    }
    ++v27;
  }
  while ( v27 != 9 );
  v53 = v56;
  if ( v57 && v56 >= 1 )
  {
    huffval = v19->huffval;
    do
    {
      v55 = v53;
      if ( *huffval >= 0x10u )
      {
        v58->err->msg_code = 8;
        v58->err->error_exit((j_common_ptr)v58);
      }
      ++huffval;
      v53 = v55 - 1;
    }
    while ( v55 != 1 );
  }
}
// 47CA30: fragmented variable at d20.8 may be wrong
// 47CA30: using guessed type char var_121[257];
// 47CA30: using guessed type _DWORD var_528[257];

//----- (0047CDC4) --------------------------------------------------------
boolean __fastcall jpeg_fill_bit_buffer(
        bitread_working_state *state,
        bit_buf_type get_buffer,
        int bits_left,
        int nbits)
{
  size_t bytes_in_buffer; // r5
  const JOCTET *next_input_byte; // r6
  int v8; // r10
  j_decompress_ptr cinfo; // r4
  int v11; // r0
  int v13; // r0
  int v14; // t1
  bool v15; // cc
  int v16; // r0
  int v17; // t1

  bytes_in_buffer = state->bytes_in_buffer;
  next_input_byte = state->next_input_byte;
  v8 = bits_left;
  cinfo = state->cinfo;
  if ( cinfo->unread_marker )
  {
    if ( bits_left >= nbits )
      goto LABEL_7;
LABEL_3:
    if ( !cinfo->entropy->insufficient_data )
    {
      cinfo->err->msg_code = 117;
      cinfo->err->emit_message((j_common_ptr)cinfo, -1);
      cinfo->entropy->insufficient_data = 1;
    }
    get_buffer <<= 25 - v8;
    v11 = 25;
    goto LABEL_8;
  }
  if ( bits_left > 24 )
    goto LABEL_7;
  while ( 1 )
  {
    if ( !bytes_in_buffer )
    {
      if ( !((int (__fastcall *)(j_decompress_ptr))cinfo->src->fill_input_buffer)(cinfo) )
        return 0;
      bytes_in_buffer = cinfo->src->bytes_in_buffer;
      next_input_byte = cinfo->src->next_input_byte;
    }
    v14 = *next_input_byte++;
    v13 = v14;
    --bytes_in_buffer;
    if ( v14 == 255 )
      break;
LABEL_14:
    get_buffer = v13 | (get_buffer << 8);
    v11 = v8 + 8;
    v15 = v8 < 17;
    v8 += 8;
    if ( !v15 )
      goto LABEL_8;
  }
  do
  {
    if ( !bytes_in_buffer )
    {
      if ( !((int (__fastcall *)(j_decompress_ptr))cinfo->src->fill_input_buffer)(cinfo) )
        return 0;
      bytes_in_buffer = cinfo->src->bytes_in_buffer;
      next_input_byte = cinfo->src->next_input_byte;
    }
    v17 = *next_input_byte++;
    v16 = v17;
    --bytes_in_buffer;
  }
  while ( v17 == 255 );
  if ( !v16 )
  {
    v13 = 255;
    goto LABEL_14;
  }
  cinfo->unread_marker = v16;
  if ( v8 < nbits )
    goto LABEL_3;
LABEL_7:
  v11 = v8;
LABEL_8:
  state->next_input_byte = next_input_byte;
  state->bytes_in_buffer = bytes_in_buffer;
  state->get_buffer = get_buffer;
  state->bits_left = v11;
  return 1;
}

//----- (0047CE90) --------------------------------------------------------
int __fastcall jpeg_huff_decode(
        bitread_working_state *state,
        bit_buf_type get_buffer,
        int bits_left,
        d_derived_tbl *htbl,
        int nbits)
{
  int v5; // r6
  int v8; // r2
  INT32 v9; // r4
  INT32 *v10; // r3

  v5 = nbits;
  if ( bits_left < nbits )
  {
    if ( !jpeg_fill_bit_buffer(state, get_buffer, bits_left, nbits) )
      return -1;
    bits_left = state->bits_left;
    get_buffer = state->get_buffer;
  }
  v8 = bits_left - nbits;
  v9 = ((1 << nbits) - 1) & (get_buffer >> v8);
  if ( v9 > htbl->maxcode[nbits] )
  {
    do
    {
      if ( v8 <= 0 )
      {
        if ( !jpeg_fill_bit_buffer(state, get_buffer, v8, 1) )
          return -1;
        v8 = state->bits_left;
        get_buffer = state->get_buffer;
      }
      --v8;
      v10 = &htbl->maxcode[v5++];
      v9 = ((unsigned int)get_buffer >> v8) & 1 | (2 * v9);
    }
    while ( v9 > v10[1] );
  }
  state->get_buffer = get_buffer;
  state->bits_left = v8;
  if ( v5 < 17 )
    return htbl->pub->huffval[htbl->valoffset[v5] + v9];
  state->cinfo->err->msg_code = 118;
  state->cinfo->err->emit_message((j_common_ptr)state->cinfo, -1);
  return 0;
}

//----- (0047CF38) --------------------------------------------------------
void __fastcall jinit_huff_decoder(j_decompress_ptr cinfo)
{
  int v2; // r0
  _QWORD *v3; // r1

  v2 = cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 172);
  cinfo->entropy = (jpeg_entropy_decoder *)v2;
  *(_DWORD *)v2 = start_pass_huff_decoder;
  *(_DWORD *)(v2 + 4) = decode_mcu;
  v3 = (_QWORD *)(v2 + 40);
  v2 += 56;
  *v3 = 0LL;
  v3[1] = 0LL;
  *(_QWORD *)v2 = 0LL;
  *(_QWORD *)(v2 + 8) = 0LL;
}

//----- (0047CF78) --------------------------------------------------------
void __fastcall start_pass_huff_decoder(j_decompress_ptr cinfo)
{
  jpeg_entropy_decoder *entropy; // r10
  int Se; // r0
  bool v4; // zf
  int v5; // r6
  __int64 v6; // kr00_8
  int v7; // r1
  void (**v8)(j_decompress_ptr); // r5
  jpeg_component_info *v9; // r3
  bool *v10; // r6
  bool v11; // r3

  entropy = cinfo->entropy;
  if ( cinfo->Ss )
    goto LABEL_5;
  Se = cinfo->Se;
  v4 = Se == 63;
  if ( Se == 63 )
    v4 = cinfo->Ah == 0;
  if ( !v4 || cinfo->Al )
  {
LABEL_5:
    cinfo->err->msg_code = 122;
    cinfo->err->emit_message((j_common_ptr)cinfo, -1);
  }
  if ( cinfo->comps_in_scan >= 1 )
  {
    v5 = 0;
    do
    {
      v6 = *(_QWORD *)&cinfo->cur_comp_info[v5]->dc_tbl_no;
      jpeg_make_d_derived_tbl(cinfo, 1u, v6, (d_derived_tbl **)&entropy[3].decode_mcu + v6);
      jpeg_make_d_derived_tbl(cinfo, 0, SHIDWORD(v6), (d_derived_tbl **)&entropy[4].insufficient_data + HIDWORD(v6));
      *((_DWORD *)&entropy[1].insufficient_data + v5++) = 0;
    }
    while ( v5 < cinfo->comps_in_scan );
  }
  if ( cinfo->blocks_in_MCU >= 1 )
  {
    v7 = 0;
    do
    {
      v8 = &entropy->start_pass + v7;
      v9 = cinfo->cur_comp_info[cinfo->MCU_membership[v7]];
      v8[18] = (void (*)(j_decompress_ptr))*((_DWORD *)&entropy[3].decode_mcu + v9->dc_tbl_no);
      v8[28] = (void (*)(j_decompress_ptr))*((_DWORD *)&entropy[4].insufficient_data + v9->ac_tbl_no);
      if ( v9->component_needed )
      {
        *(&entropy[12].insufficient_data + v7) = 1;
        v10 = (bool *)&entropy[13].decode_mcu + v7 + 2;
        v11 = v9->DCT_scaled_size > 1;
      }
      else
      {
        v11 = 0;
        *((_BYTE *)&entropy[13].decode_mcu + v7 + 2) = 0;
        v10 = (bool *)(&entropy[12].insufficient_data + v7);
      }
      *v10 = v11;
      ++v7;
    }
    while ( v7 < cinfo->blocks_in_MCU );
  }
  entropy->insufficient_data = 0;
  entropy[1].start_pass = 0;
  entropy[1].decode_mcu = 0;
  entropy[3].start_pass = (void (*)(j_decompress_ptr))cinfo->restart_interval;
}

//----- (0047D088) --------------------------------------------------------
boolean __fastcall decode_mcu(j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
  jpeg_entropy_decoder *entropy; // r11
  boolean v5; // r6
  int v6; // r2
  boolean *p_insufficient_data; // r4
  jpeg_source_mgr *src; // r6
  const JOCTET *next_input_byte; // r0
  size_t bytes_in_buffer; // r12
  int start_pass; // r1
  int bits_left; // r2
  __int64 v14; // d17
  int v15; // r4
  void (**v16)(j_decompress_ptr); // r0
  d_derived_tbl *v17; // r10
  d_derived_tbl *v18; // r8
  int v19; // r0
  int v20; // r3
  int v21; // r0
  char *v22; // r3
  int v23; // r6
  int v24; // r0
  int v25; // r0
  char *v26; // r3
  int v27; // r6
  int v28; // r0
  int v29; // r4
  int v30; // r0
  int v31; // r0
  int v32; // r3
  int v33; // r0
  int v34; // r6
  int v35; // r5
  int v36; // r0
  int v37; // r3
  int v38; // r0
  int v39; // r0
  int v40; // r3
  int v41; // r0
  int v42; // r6
  int v43; // r5
  __int64 v44; // d17
  int v45; // [sp+8h] [bp-50h]
  JBLOCKROW *v46; // [sp+Ch] [bp-4Ch]
  JBLOCKROW min_bits; // [sp+14h] [bp-44h]
  __int64 v48; // [sp+18h] [bp-40h]
  __int64 v49; // [sp+20h] [bp-38h]
  bitread_working_state state; // [sp+28h] [bp-30h] BYREF

  entropy = cinfo->entropy;
  if ( cinfo->restart_interval && !entropy[3].start_pass )
  {
    v5 = 0;
    cinfo->marker->discarded_bytes += (int)entropy[1].decode_mcu / 8;
    entropy[1].decode_mcu = 0;
    if ( !((int (__fastcall *)(j_decompress_ptr))cinfo->marker->read_restart_marker)(cinfo) )
      return v5;
    if ( cinfo->comps_in_scan >= 1 )
    {
      v6 = 0;
      do
        *((_DWORD *)&entropy[1].insufficient_data + v6++) = 0;
      while ( v6 < cinfo->comps_in_scan );
    }
    entropy[3].start_pass = (void (*)(j_decompress_ptr))cinfo->restart_interval;
    if ( !cinfo->unread_marker )
      entropy->insufficient_data = 0;
  }
  if ( entropy->insufficient_data )
    goto LABEL_10;
  state.cinfo = cinfo;
  p_insufficient_data = &entropy[1].insufficient_data;
  src = cinfo->src;
  next_input_byte = src->next_input_byte;
  state.next_input_byte = src->next_input_byte;
  bytes_in_buffer = src->bytes_in_buffer;
  state.bytes_in_buffer = bytes_in_buffer;
  bits_left = (int)entropy[1].decode_mcu;
  start_pass = (int)entropy[1].start_pass;
  v14 = *(_QWORD *)&entropy[2].decode_mcu;
  v48 = *(_QWORD *)&entropy[1].insufficient_data;
  v49 = v14;
  if ( cinfo->blocks_in_MCU < 1 )
    goto LABEL_71;
  v15 = 0;
  v46 = MCU_data;
  do
  {
    min_bits = MCU_data[v15];
    v16 = &entropy->start_pass + v15;
    v17 = (d_derived_tbl *)v16[18];
    v18 = (d_derived_tbl *)v16[28];
    if ( bits_left > 7 )
      goto LABEL_18;
    v5 = 0;
    if ( !jpeg_fill_bit_buffer(&state, start_pass, bits_left, 0) )
      return v5;
    start_pass = state.get_buffer;
    bits_left = state.bits_left;
    if ( state.bits_left >= 8 )
    {
LABEL_18:
      v20 = (unsigned __int8)(start_pass >> (bits_left - 8));
      v21 = v17->look_nbits[v20];
      if ( v21 )
      {
        v22 = (char *)v17 + v20;
        bits_left -= v21;
        v23 = (unsigned __int8)v22[1168];
        if ( !v22[1168] )
          goto LABEL_20;
        goto LABEL_24;
      }
      v19 = 9;
    }
    else
    {
      v19 = 1;
    }
    v25 = jpeg_huff_decode(&state, start_pass, bits_left, v17, v19);
    v23 = v25;
    if ( v25 < 0 )
      return 0;
    start_pass = state.get_buffer;
    bits_left = state.bits_left;
    if ( !v25 )
    {
LABEL_20:
      v24 = 0;
      goto LABEL_29;
    }
LABEL_24:
    if ( bits_left < v23 )
    {
      if ( !jpeg_fill_bit_buffer(&state, start_pass, bits_left, v23) )
        return 0;
      start_pass = state.get_buffer;
      bits_left = state.bits_left;
    }
    bits_left -= v23;
    v24 = (start_pass >> bits_left) & ((1 << v23) - 1);
    if ( v24 < extend_test[v23] )
      v24 += extend_offset[v23];
LABEL_29:
    v26 = (char *)entropy + v15;
    v45 = v15;
    if ( *(&entropy[12].insufficient_data + v15) )
    {
      v27 = cinfo->MCU_membership[v15];
      v28 = v24 + *((_DWORD *)&v48 + v27);
      *((_DWORD *)&v48 + v27) = v28;
      *(_WORD *)min_bits = v28;
    }
    v29 = 1;
    if ( v26[162] )
    {
      while ( 1 )
      {
        if ( bits_left <= 7 )
        {
          v5 = 0;
          if ( !jpeg_fill_bit_buffer(&state, start_pass, bits_left, 0) )
            return v5;
          start_pass = state.get_buffer;
          bits_left = state.bits_left;
          if ( state.bits_left < 8 )
            break;
        }
        v31 = (unsigned __int8)(start_pass >> (bits_left - 8));
        v32 = v18->look_nbits[v31];
        if ( !v32 )
        {
          v30 = 9;
          goto LABEL_39;
        }
        bits_left -= v32;
        v33 = v18->look_sym[v31];
LABEL_41:
        v34 = v33 & 0xF;
        v35 = v33 >> 4;
        if ( (v33 & 0xF) != 0 )
        {
          if ( bits_left < v34 )
          {
            if ( !jpeg_fill_bit_buffer(&state, start_pass, bits_left, v34) )
              return 0;
            start_pass = state.get_buffer;
            bits_left = state.bits_left;
          }
          v36 = v35 + v29;
          bits_left -= v34;
          v37 = (start_pass >> bits_left) & ((1 << v34) - 1);
          if ( v37 < extend_test[v34] )
            v37 += extend_offset[v34];
          (*min_bits)[jpeg_natural_order[v36]] = v37;
        }
        else
        {
          if ( v35 != 15 )
            goto LABEL_69;
          v36 = v29 + 15;
        }
        v29 = v36 + 1;
        if ( v36 >= 63 )
          goto LABEL_69;
      }
      v30 = 1;
LABEL_39:
      v33 = jpeg_huff_decode(&state, start_pass, bits_left, v18, v30);
      if ( v33 < 0 )
        return 0;
      start_pass = state.get_buffer;
      bits_left = state.bits_left;
      goto LABEL_41;
    }
    do
    {
      if ( bits_left > 7 )
        goto LABEL_56;
      v5 = 0;
      if ( !jpeg_fill_bit_buffer(&state, start_pass, bits_left, 0) )
        return v5;
      start_pass = state.get_buffer;
      bits_left = state.bits_left;
      if ( state.bits_left >= 8 )
      {
LABEL_56:
        v39 = (unsigned __int8)(start_pass >> (bits_left - 8));
        v40 = v18->look_nbits[v39];
        if ( v40 )
        {
          bits_left -= v40;
          v41 = v18->look_sym[v39];
          goto LABEL_61;
        }
        v38 = 9;
      }
      else
      {
        v38 = 1;
      }
      v41 = jpeg_huff_decode(&state, start_pass, bits_left, v18, v38);
      if ( v41 < 0 )
        return 0;
      start_pass = state.get_buffer;
      bits_left = state.bits_left;
LABEL_61:
      v42 = v41 & 0xF;
      v43 = v41 >> 4;
      if ( (v41 & 0xF) != 0 )
      {
        if ( bits_left < v42 )
        {
          if ( !jpeg_fill_bit_buffer(&state, start_pass, bits_left, v42) )
            return 0;
          start_pass = state.get_buffer;
          bits_left = state.bits_left;
        }
        bits_left -= v42;
      }
      else
      {
        if ( v43 != 15 )
          break;
        v43 = 15;
      }
      v29 += v43 + 1;
    }
    while ( v29 < 64 );
LABEL_69:
    MCU_data = v46;
    v15 = v45 + 1;
  }
  while ( v45 + 1 < cinfo->blocks_in_MCU );
  next_input_byte = state.next_input_byte;
  bytes_in_buffer = state.bytes_in_buffer;
  src = cinfo->src;
  p_insufficient_data = &entropy[1].insufficient_data;
LABEL_71:
  src->next_input_byte = next_input_byte;
  cinfo->src->bytes_in_buffer = bytes_in_buffer;
  entropy[1].start_pass = (void (*)(j_decompress_ptr))start_pass;
  entropy[1].decode_mcu = (boolean (*)(j_decompress_ptr, JBLOCKROW *))bits_left;
  v44 = v49;
  *(_QWORD *)p_insufficient_data = v48;
  *((_QWORD *)p_insufficient_data + 1) = v44;
LABEL_10:
  v5 = 1;
  --entropy[3].start_pass;
  return v5;
}

//----- (0047D424) --------------------------------------------------------
void __fastcall jinit_input_controller(j_decompress_ptr cinfo)
{
  int v2; // r0

  v2 = cinfo->mem->alloc_small((j_common_ptr)cinfo, 0, 24);
  cinfo->inputctl = (jpeg_input_controller *)v2;
  *(_BYTE *)(v2 + 20) = 1;
  *(_WORD *)(v2 + 16) = 0;
  *(_DWORD *)v2 = consume_markers;
  *(_DWORD *)(v2 + 4) = reset_input_controller;
  *(_DWORD *)(v2 + 8) = start_input_pass;
  *(_DWORD *)(v2 + 12) = finish_input_pass;
}

//----- (0047D474) --------------------------------------------------------
int __fastcall consume_markers(j_decompress_ptr cinfo)
{
  jpeg_input_controller *inputctl; // r8
  int result; // r0
  int num_components; // r12
  int v5; // r5
  int v6; // r1
  int *p_h_samp_factor; // r6
  int max_h_samp_factor; // r2
  int v9; // r3
  int max_v_samp_factor; // r0
  int v11; // r6
  JQUANT_TBL **p_quant_table; // r5
  int v13; // r0
  int v14; // r1
  int v15; // r0
  int v16; // r2
  int v17; // r0
  int v18; // r2
  int consume_input_low; // r0
  int input_scan_number; // r0
  int v21; // r0
  int v22; // r1
  int comps_in_scan; // r2
  bool v24; // r0
  boolean progressive_mode; // r0

  inputctl = cinfo->inputctl;
  if ( inputctl->eoi_reached )
    return 2;
  result = cinfo->marker->read_markers(cinfo);
  if ( result == 2 )
  {
    consume_input_low = LOBYTE(inputctl[1].consume_input);
    inputctl->eoi_reached = 1;
    if ( consume_input_low )
    {
      if ( cinfo->marker->saw_SOF )
      {
        cinfo->err->msg_code = 59;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
    }
    else
    {
      input_scan_number = cinfo->input_scan_number;
      if ( cinfo->output_scan_number > input_scan_number )
        cinfo->output_scan_number = input_scan_number;
    }
    return 2;
  }
  if ( result == 1 )
  {
    if ( LOBYTE(inputctl[1].consume_input) )
    {
      if ( (int)cinfo->image_height > 65500 || (int)cinfo->image_width >= 65501 )
      {
        cinfo->err->msg_code = 41;
        cinfo->err->msg_parm.i[0] = 65500;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      if ( cinfo->data_precision != 8 )
      {
        cinfo->err->msg_code = 15;
        cinfo->err->msg_parm.i[0] = cinfo->data_precision;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      num_components = cinfo->num_components;
      if ( num_components >= 5 )
      {
        cinfo->err->msg_code = 26;
        cinfo->err->msg_parm.i[0] = cinfo->num_components;
        cinfo->err->msg_parm.i[1] = 4;
        cinfo->err->error_exit((j_common_ptr)cinfo);
        num_components = cinfo->num_components;
      }
      cinfo->max_h_samp_factor = 1;
      cinfo->max_v_samp_factor = 1;
      if ( num_components <= 0 )
      {
        v6 = 1;
        cinfo->min_DCT_scaled_size = 8;
      }
      else
      {
        v5 = 0;
        v6 = 1;
        p_h_samp_factor = &cinfo->comp_info->h_samp_factor;
        max_h_samp_factor = 1;
        do
        {
          v9 = *p_h_samp_factor;
          if ( (unsigned int)(*p_h_samp_factor - 1) > 3
            || (max_v_samp_factor = v6, (unsigned int)(p_h_samp_factor[1] - 1) >= 4) )
          {
            cinfo->err->msg_code = 18;
            cinfo->err->error_exit((j_common_ptr)cinfo);
            num_components = cinfo->num_components;
            max_v_samp_factor = cinfo->max_v_samp_factor;
            max_h_samp_factor = cinfo->max_h_samp_factor;
            v9 = *p_h_samp_factor;
          }
          ++v5;
          if ( max_h_samp_factor <= v9 )
            max_h_samp_factor = v9;
          cinfo->max_h_samp_factor = max_h_samp_factor;
          v6 = p_h_samp_factor[1];
          p_h_samp_factor += 21;
          if ( max_v_samp_factor > v6 )
            v6 = max_v_samp_factor;
          cinfo->max_v_samp_factor = v6;
        }
        while ( v5 < num_components );
        cinfo->min_DCT_scaled_size = 8;
        if ( num_components >= 1 )
        {
          v11 = 0;
          p_quant_table = &cinfo->comp_info->quant_table;
          do
          {
            *(p_quant_table - 10) = (JQUANT_TBL *)byte_8;
            v13 = jdiv_round_up((_DWORD)*(p_quant_table - 17) * cinfo->image_width, 8 * cinfo->max_h_samp_factor);
            v14 = (int)*(p_quant_table - 16);
            *(p_quant_table - 12) = (JQUANT_TBL *)v13;
            v15 = jdiv_round_up(cinfo->image_height * v14, 8 * cinfo->max_v_samp_factor);
            v16 = (int)*(p_quant_table - 17);
            *(p_quant_table - 11) = (JQUANT_TBL *)v15;
            v17 = jdiv_round_up(cinfo->image_width * v16, cinfo->max_h_samp_factor);
            v18 = (int)*(p_quant_table - 16);
            *(p_quant_table - 9) = (JQUANT_TBL *)v17;
            *(p_quant_table - 8) = (JQUANT_TBL *)jdiv_round_up(cinfo->image_height * v18, cinfo->max_v_samp_factor);
            ++v11;
            *((_BYTE *)p_quant_table - 28) = 1;
            *p_quant_table = 0;
            p_quant_table += 21;
          }
          while ( v11 < cinfo->num_components );
          v6 = cinfo->max_v_samp_factor;
        }
      }
      v21 = jdiv_round_up(cinfo->image_height, 8 * v6);
      v22 = cinfo->num_components;
      comps_in_scan = cinfo->comps_in_scan;
      cinfo->total_iMCU_rows = v21;
      if ( comps_in_scan >= v22 )
      {
        progressive_mode = cinfo->progressive_mode;
        v24 = progressive_mode != 0;
      }
      else
      {
        v24 = 1;
      }
      cinfo->inputctl->has_multiple_scans = v24;
      LOBYTE(inputctl[1].consume_input) = 0;
      return 1;
    }
    else
    {
      if ( !inputctl->has_multiple_scans )
      {
        cinfo->err->msg_code = 35;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      start_input_pass(cinfo);
      return 1;
    }
  }
  return result;
}

//----- (0047D6AC) --------------------------------------------------------
void __fastcall reset_input_controller(j_decompress_ptr cinfo)
{
  jpeg_input_controller *inputctl; // r0

  inputctl = cinfo->inputctl;
  inputctl->consume_input = consume_markers;
  *(_WORD *)&inputctl->has_multiple_scans = 0;
  LOBYTE(inputctl[1].consume_input) = 1;
  cinfo->err->reset_error_mgr((j_common_ptr)cinfo);
  cinfo->marker->reset_marker_reader(cinfo);
  cinfo->coef_bits = 0;
}

//----- (0047D6E0) --------------------------------------------------------
void __fastcall start_input_pass(j_decompress_ptr cinfo)
{
  int comps_in_scan; // r0
  jpeg_component_info *v3; // r6
  unsigned int v_samp_factor; // r5
  __int64 v5; // r0
  unsigned int v6; // r1
  int v7; // r0
  int v8; // r0
  int max_v_samp_factor; // r1
  int image_height; // r2
  int v11; // r0
  int v12; // r1
  int v13; // r6
  jpeg_component_info *v14; // r10
  __int64 v15; // kr00_8
  __int64 v16; // kr08_8
  int v17; // r11
  unsigned int v18; // r1
  int v19; // r1
  int v20; // r0
  int blocks_in_MCU; // r1
  int i; // r6
  jpeg_component_info *v23; // r5
  unsigned int quant_tbl_no; // r0
  const void **v25; // r11
  JQUANT_TBL *v26; // r10
  int v27; // [sp+0h] [bp-20h]

  comps_in_scan = cinfo->comps_in_scan;
  if ( comps_in_scan == 1 )
  {
    v3 = cinfo->cur_comp_info[0];
    cinfo->MCUs_per_row = v3->width_in_blocks;
    cinfo->MCU_rows_in_scan = v3->height_in_blocks;
    v_samp_factor = v3->v_samp_factor;
    v5 = *(_QWORD *)&v3->height_in_blocks;
    v3->MCU_width = 1;
    v3->MCU_height = 1;
    v3->MCU_blocks = 1;
    v3->MCU_sample_width = HIDWORD(v5);
    v3->last_col_width = 1;
    v6 = (unsigned int)v5 % v_samp_factor;
    if ( !((unsigned int)v5 % v_samp_factor) )
      v6 = v_samp_factor;
    v3->last_row_height = v6;
    v7 = cinfo->comps_in_scan;
    cinfo->blocks_in_MCU = 1;
    cinfo->MCU_membership[0] = 0;
    if ( v7 < 1 )
      goto LABEL_28;
LABEL_21:
    for ( i = 0; i < v7; ++i )
    {
      v23 = cinfo->cur_comp_info[i];
      if ( !v23->quant_table )
      {
        quant_tbl_no = v23->quant_tbl_no;
        v25 = (const void **)&cinfo->quant_tbl_ptrs[quant_tbl_no];
        if ( quant_tbl_no > 3 || !*v25 )
        {
          cinfo->err->msg_code = 52;
          cinfo->err->msg_parm.i[0] = quant_tbl_no;
          cinfo->err->error_exit((j_common_ptr)cinfo);
        }
        v26 = (JQUANT_TBL *)cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 130);
        qmemcpy(v26, *v25, sizeof(JQUANT_TBL));
        v23->quant_table = v26;
        v7 = cinfo->comps_in_scan;
      }
    }
    goto LABEL_28;
  }
  if ( (unsigned int)(comps_in_scan - 1) >= 4 )
  {
    cinfo->err->msg_code = 26;
    cinfo->err->msg_parm.i[0] = cinfo->comps_in_scan;
    cinfo->err->msg_parm.i[1] = 4;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v8 = jdiv_round_up(cinfo->image_width, 8 * cinfo->max_h_samp_factor);
  max_v_samp_factor = cinfo->max_v_samp_factor;
  image_height = cinfo->image_height;
  cinfo->MCUs_per_row = v8;
  v11 = jdiv_round_up(image_height, 8 * max_v_samp_factor);
  v12 = cinfo->comps_in_scan;
  cinfo->MCU_rows_in_scan = v11;
  cinfo->blocks_in_MCU = 0;
  if ( v12 >= 1 )
  {
    v13 = 0;
    do
    {
      v14 = cinfo->cur_comp_info[v13];
      v15 = *(_QWORD *)&v14->h_samp_factor;
      v16 = *(_QWORD *)&v14->width_in_blocks;
      v17 = HIDWORD(v15) * v15;
      v27 = v14->DCT_scaled_size * v15;
      *(_QWORD *)&v14->MCU_width = v15;
      v18 = (unsigned int)v16 % (unsigned int)v15;
      if ( !((unsigned int)v16 % (unsigned int)v15) )
        v18 = v15;
      v14->last_col_width = v18;
      v19 = HIDWORD(v16) % HIDWORD(v15);
      if ( !(HIDWORD(v16) % HIDWORD(v15)) )
        v19 = HIDWORD(v15);
      v14->last_row_height = v19;
      v14->MCU_blocks = v17;
      v14->MCU_sample_width = v27;
      if ( cinfo->blocks_in_MCU + HIDWORD(v15) * (int)v15 >= 11 )
      {
        cinfo->err->msg_code = 13;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      if ( v17 >= 1 )
      {
        v20 = v17 + 1;
        do
        {
          blocks_in_MCU = cinfo->blocks_in_MCU;
          --v20;
          cinfo->blocks_in_MCU = blocks_in_MCU + 1;
          cinfo->MCU_membership[blocks_in_MCU] = v13;
        }
        while ( v20 > 1 );
      }
      v7 = cinfo->comps_in_scan;
      ++v13;
    }
    while ( v13 < v7 );
    if ( v7 >= 1 )
      goto LABEL_21;
  }
LABEL_28:
  cinfo->entropy->start_pass(cinfo);
  cinfo->coef->start_input_pass(cinfo);
  cinfo->inputctl->consume_input = cinfo->coef->consume_data;
}

//----- (0047D8A8) --------------------------------------------------------
void __fastcall finish_input_pass(j_decompress_ptr cinfo)
{
  cinfo->inputctl->consume_input = consume_markers;
}

//----- (0047D8B8) --------------------------------------------------------
void __fastcall jinit_d_main_controller(j_decompress_ptr cinfo, boolean need_full_buffer)
{
  int v3; // r6
  jpeg_d_main_controller *v4; // r0
  int min_DCT_scaled_size; // r10
  jpeg_d_main_controller *main; // r11
  int v7; // r0
  int num_components; // r0
  int v9; // r4
  int *p_DCT_scaled_size; // r5
  int v11; // r6
  int v12; // r9
  int v13; // r0
  int v14; // r9
  int v15; // r11
  JDIMENSION *i; // r5
  jpeg_d_main_controller *v17; // [sp+8h] [bp-20h]

  v3 = need_full_buffer;
  v4 = (jpeg_d_main_controller *)cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 56);
  cinfo->main = v4;
  v17 = v4;
  v4->start_pass = start_pass_main;
  if ( v3 )
  {
    cinfo->err->msg_code = 4;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  min_DCT_scaled_size = cinfo->min_DCT_scaled_size;
  if ( !cinfo->upsample->need_context_rows )
  {
    v14 = cinfo->min_DCT_scaled_size;
    if ( cinfo->num_components < 1 )
      return;
    goto LABEL_12;
  }
  if ( min_DCT_scaled_size <= 1 )
  {
    cinfo->err->msg_code = 47;
    cinfo->err->error_exit((j_common_ptr)cinfo);
    min_DCT_scaled_size = cinfo->min_DCT_scaled_size;
  }
  main = cinfo->main;
  v7 = cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 8 * cinfo->num_components);
  main[4].start_pass = (void (*)(j_decompress_ptr, J_BUF_MODE))v7;
  main[4].process_data = (void (*)(j_decompress_ptr, JSAMPARRAY, JDIMENSION *, JDIMENSION))(v7
                                                                                          + 4 * cinfo->num_components);
  num_components = cinfo->num_components;
  if ( num_components >= 1 )
  {
    v9 = 0;
    p_DCT_scaled_size = &cinfo->comp_info->DCT_scaled_size;
    do
    {
      v11 = *(p_DCT_scaled_size - 6) * *p_DCT_scaled_size / cinfo->min_DCT_scaled_size;
      v12 = v11 * (min_DCT_scaled_size + 4);
      v13 = cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 8 * v12) + 4 * v11;
      p_DCT_scaled_size += 21;
      *((_DWORD *)main[4].start_pass + v9) = v13;
      *((_DWORD *)main[4].process_data + v9++) = v13 + 4 * v12;
      num_components = cinfo->num_components;
    }
    while ( v9 < num_components );
  }
  min_DCT_scaled_size = cinfo->min_DCT_scaled_size;
  v14 = min_DCT_scaled_size + 2;
  if ( num_components >= 1 )
  {
LABEL_12:
    v15 = 2;
    for ( i = &cinfo->comp_info->width_in_blocks; ; i += 21 )
    {
      *((_DWORD *)&v17->start_pass + v15) = cinfo->mem->alloc_sarray(
                                              cinfo,
                                              1,
                                              *i * i[2],
                                              (int)(*(i - 4) * i[2]) / min_DCT_scaled_size * v14);
      if ( v15 - 1 >= cinfo->num_components )
        break;
      ++v15;
      min_DCT_scaled_size = cinfo->min_DCT_scaled_size;
    }
  }
}

//----- (0047DA20) --------------------------------------------------------
void __fastcall start_pass_main(j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
{
  j_decompress_ptr v2; // r10
  jpeg_d_main_controller *main; // r1
  int min_DCT_scaled_size; // r1
  int v5; // r8
  jpeg_component_info *comp_info; // r11
  int v7; // r0
  unsigned int v8; // r2
  int v9; // r3
  _DWORD *v10; // r9
  unsigned int v11; // r12
  _DWORD *v12; // r10
  int v13; // r11
  unsigned int v14; // r5
  int v15; // r3
  unsigned int v16; // r6
  unsigned int v17; // r4
  _BOOL4 v18; // r1
  _BOOL4 v19; // r6
  _BOOL4 v20; // r4
  _BOOL4 v21; // r5
  bool v22; // zf
  __int64 *v23; // r5
  _QWORD *v24; // r1
  unsigned int v25; // r3
  _QWORD *v26; // r6
  __int64 v27; // d16
  __int64 v28; // d17
  _DWORD *v29; // r5
  _DWORD *v30; // r6
  unsigned int v31; // r2
  int *v32; // r4
  int v33; // t1
  int v34; // r2
  int v35; // r10
  bool v36; // cc
  unsigned int v37; // r11
  int v38; // r0
  int v39; // r4
  int v40; // r5
  int v41; // r2
  int v42; // r6
  unsigned int v43; // r2
  int v44; // r6
  int v45; // lr
  int v46; // r0
  unsigned int v47; // r3
  unsigned int v48; // r4
  unsigned int v49; // r12
  unsigned int v50; // r1
  int v51; // r2
  _BOOL4 v52; // r3
  _BOOL4 v53; // r12
  bool v54; // zf
  int v55; // lr
  unsigned int v56; // r12
  int v57; // r6
  int v58; // r3
  int v59; // r2
  __int64 v60; // d17
  _QWORD *v61; // r1
  __int64 *v62; // r1
  __int64 v63; // d16
  __int64 v64; // d17
  _QWORD *v65; // r1
  int v66; // r6
  int v67; // r3
  int v68; // r6
  int v69; // r0
  jpeg_d_main_controller *v70; // [sp+0h] [bp-78h]
  int v71; // [sp+4h] [bp-74h]
  int v72; // [sp+8h] [bp-70h]
  int v73; // [sp+10h] [bp-68h]
  _BOOL4 v74; // [sp+14h] [bp-64h]
  _BOOL4 v75; // [sp+18h] [bp-60h]
  unsigned int v76; // [sp+1Ch] [bp-5Ch]
  int v77; // [sp+20h] [bp-58h]
  _BOOL4 v78; // [sp+20h] [bp-58h]
  unsigned int v79; // [sp+24h] [bp-54h]
  unsigned int v80; // [sp+28h] [bp-50h]
  int v81; // [sp+2Ch] [bp-4Ch]
  int v82; // [sp+34h] [bp-44h]
  int v83; // [sp+38h] [bp-40h]
  int v84; // [sp+3Ch] [bp-3Ch]
  int v86; // [sp+44h] [bp-34h]
  unsigned int v87; // [sp+44h] [bp-34h]
  int v88; // [sp+44h] [bp-34h]
  int v89; // [sp+48h] [bp-30h]
  jpeg_d_main_controller *v90; // [sp+4Ch] [bp-2Ch]
  int v91; // [sp+50h] [bp-28h]
  jpeg_component_info *v92; // [sp+54h] [bp-24h]
  jpeg_component_info *v93; // [sp+54h] [bp-24h]
  unsigned int v94; // [sp+58h] [bp-20h]

  v2 = cinfo;
  if ( pass_mode )
  {
    cinfo->err->msg_code = 4;
    cinfo->err->error_exit((j_common_ptr)cinfo);
    return;
  }
  main = cinfo->main;
  if ( cinfo->upsample->need_context_rows )
  {
    v70 = cinfo->main;
    main->process_data = process_data_context_main;
    if ( cinfo->num_components >= 1 )
    {
      min_DCT_scaled_size = cinfo->min_DCT_scaled_size;
      v5 = 0;
      v90 = cinfo->main;
      v72 = 4 * min_DCT_scaled_size;
      v89 = min_DCT_scaled_size + 2;
      comp_info = cinfo->comp_info;
      v83 = min_DCT_scaled_size - 2;
      v71 = 4 * (min_DCT_scaled_size - 2);
      v84 = min_DCT_scaled_size;
      while ( 1 )
      {
        v7 = comp_info->v_samp_factor * comp_info->DCT_scaled_size / min_DCT_scaled_size;
        v94 = *((_DWORD *)&v90[1].start_pass + v5);
        v8 = v89 * v7;
        v9 = *((_DWORD *)v90[4].process_data + v5);
        v10 = (_DWORD *)*((_DWORD *)v90[4].start_pass + v5);
        if ( v89 * v7 < 1 )
          goto LABEL_26;
        if ( v8 <= 3 )
          break;
        v11 = 0;
        if ( (v8 & 0xFFFFFFFC) == 0 )
          goto LABEL_24;
        v92 = comp_info;
        v12 = &v10[v8];
        v13 = 0;
        v14 = *((_DWORD *)v90[4].process_data + v5);
        v15 = 0;
        v16 = v94 + 4 * v8;
        if ( v94 < (unsigned int)v12 )
          v13 = 1;
        v17 = v14 + 4 * v8;
        if ( (unsigned int)v10 < v16 )
          v15 = 1;
        v18 = v94 < v17;
        v19 = v14 < v16;
        v20 = (unsigned int)v10 < v17;
        v86 = *((_DWORD *)v90[4].process_data + v5);
        v21 = v14 < (unsigned int)v12;
        v22 = !v21 || !v20;
        if ( !v21 || !v20 )
          v22 = !v18 || !v19;
        if ( !v22 )
        {
          comp_info = v92;
          v2 = cinfo;
          v9 = *((_DWORD *)v90[4].process_data + v5);
LABEL_24:
          v29 = (_DWORD *)(v9 + 4 * v11);
          v30 = &v10[v11];
          v31 = v8 - v11;
          v32 = (int *)(v94 + 4 * v11);
          do
          {
            v33 = *v32++;
            --v31;
            *v29++ = v33;
            *v30++ = v33;
          }
          while ( v31 );
          goto LABEL_26;
        }
        v22 = (v15 & v13) == 0;
        comp_info = v92;
        v2 = cinfo;
        v9 = *((_DWORD *)v90[4].process_data + v5);
        if ( !v22 )
          goto LABEL_24;
        v23 = (__int64 *)*((_DWORD *)&v90[1].start_pass + v5);
        v11 = v8 & 0xFFFFFFFC;
        v24 = (_QWORD *)*((_DWORD *)v90[4].start_pass + v5);
        v25 = v8 & 0xFFFFFFFC;
        v26 = (_QWORD *)*((_DWORD *)v90[4].process_data + v5);
        do
        {
          v27 = *v23;
          v28 = v23[1];
          v23 += 2;
          v25 -= 4;
          *v26 = v27;
          v26[1] = v28;
          v26 += 2;
          *v24 = v27;
          v24[1] = v28;
          v24 += 2;
        }
        while ( v25 );
        v9 = v86;
        if ( v8 != (v8 & 0xFFFFFFFC) )
          goto LABEL_24;
LABEL_26:
        if ( v7 < 1 )
          goto LABEL_54;
        v93 = comp_info;
        v34 = v7;
        v35 = 2 * v7;
        v36 = 2 * v7 <= 1;
        v37 = 1;
        v38 = v7 * v83;
        v91 = v34;
        if ( !v36 )
          v37 = v35;
        v39 = v34 * v84;
        if ( v37 > 3 )
        {
          v40 = 0;
          if ( (v37 & 0x7FFFFFFC) != 0 )
          {
            v41 = 1;
            if ( v35 > 1 )
              v41 = v35;
            v42 = 0;
            v81 = v41 + v38;
            v87 = v94 + 4 * v38;
            v77 = v41 + v39;
            v76 = v9 + 4 * (v41 + v39);
            if ( v87 < v76 )
              v42 = 1;
            v73 = v42;
            v80 = v94 + 4 * (v41 + v38);
            v43 = v9 + 4 * v39;
            v44 = 0;
            v79 = v43;
            if ( v43 < v80 )
              v44 = 1;
            v45 = v38;
            v82 = v39;
            v46 = v9;
            v47 = v94 + 4 * v39;
            v48 = v46 + 4 * v45;
            v49 = v94 + 4 * v77;
            v75 = v47 < v76;
            v74 = v43 < v49;
            v50 = v46 + 4 * v81;
            v78 = v87 < v50;
            v51 = 0;
            v88 = v46;
            if ( v48 < v80 )
              v51 = 1;
            v52 = v47 < v50;
            v53 = v48 < v49;
            if ( v48 < v76 && v79 < v50 )
            {
              v9 = v46;
              v38 = v45;
              v39 = v82;
            }
            else
            {
              v38 = v45;
              if ( v53 && v52 )
              {
                v9 = v88;
                v39 = v82;
              }
              else
              {
                v9 = v88;
                v39 = v82;
                if ( (v78 & v51) == 0 )
                {
                  v54 = !v75 || !v74;
                  if ( !v75 || !v74 )
                    v54 = (v73 & v44) == 0;
                  if ( v54 )
                  {
                    v55 = v88;
                    v56 = v94;
                    v57 = v71 * v91;
                    v40 = v37 & 0x7FFFFFFC;
                    v58 = v37 & 0x7FFFFFFC;
                    v59 = v91 * v72;
                    do
                    {
                      v58 -= 4;
                      v60 = *(_QWORD *)(v56 + v59 + 8);
                      v61 = (_QWORD *)(v55 + v57);
                      *v61 = *(_QWORD *)(v56 + v59);
                      v61[1] = v60;
                      v62 = (__int64 *)(v56 + v57);
                      v56 += 16;
                      v63 = *v62;
                      v64 = v62[1];
                      v65 = (_QWORD *)(v55 + v59);
                      v55 += 16;
                      *v65 = v63;
                      v65[1] = v64;
                    }
                    while ( v58 );
                    v9 = v88;
                    v39 = v82;
                    if ( v37 == (v37 & 0x7FFFFFFC) )
                      goto LABEL_52;
                  }
                }
              }
            }
          }
        }
        else
        {
          v40 = 0;
        }
        v66 = v9;
        v67 = v9 + 4 * v39;
        v68 = v66 + 4 * v38;
        do
        {
          *(_DWORD *)(v68 + 4 * v40) = *(_DWORD *)(v94 + 4 * v39 + 4 * v40);
          *(_DWORD *)(v67 + 4 * v40) = *(_DWORD *)(v94 + 4 * v38 + 4 * v40);
          ++v40;
        }
        while ( v40 < v35 );
LABEL_52:
        v2 = cinfo;
        comp_info = v93;
        v69 = -v91;
        do
          v10[v69++] = *v10;
        while ( v69 );
LABEL_54:
        if ( ++v5 >= v2->num_components )
          goto LABEL_58;
        min_DCT_scaled_size = v2->min_DCT_scaled_size;
        ++comp_info;
      }
      v11 = 0;
      goto LABEL_24;
    }
LABEL_58:
    main = v70;
    v70[5].start_pass = 0;
    v70[5].process_data = 0;
    v70[6].process_data = 0;
  }
  else
  {
    main->process_data = process_data_simple_main;
  }
  main[3].process_data = 0;
  LOBYTE(main[3].start_pass) = 0;
}

//----- (0047DDA4) --------------------------------------------------------
void __fastcall process_data_context_main(
        j_decompress_ptr cinfo,
        JSAMPARRAY output_buf,
        JDIMENSION *out_row_ctr,
        JDIMENSION out_rows_avail)
{
  jpeg_d_main_controller *main; // r4
  void (*process_data)(j_decompress_ptr, JSAMPARRAY, JDIMENSION *, JDIMENSION); // r0
  void (*v9)(j_decompress_ptr, JSAMPARRAY, JDIMENSION *, JDIMENSION); // r0
  void (**p_process_data)(j_decompress_ptr, JSAMPARRAY, JDIMENSION *, JDIMENSION); // r6
  void (*v11)(j_decompress_ptr, JSAMPARRAY, JDIMENSION *, JDIMENSION); // r1
  jpeg_d_main_controller *v12; // r10
  int v13; // r9
  jpeg_component_info *comp_info; // r11
  int v15; // r5
  unsigned int v16; // r6
  unsigned int v17; // r3
  int v18; // r0
  int v19; // r2
  int v20; // r6
  JDIMENSION *v21; // r2
  int *p_min_DCT_scaled_size; // r5
  int num_components; // r8
  int v24; // r9
  int min_DCT_scaled_size; // r1
  jpeg_component_info *i; // r4
  int v27; // r0
  int v28; // r5
  jpeg_d_main_controller v29; // kr00_8
  int v30; // r10
  int v31; // r2
  void (*start_pass)(j_decompress_ptr, J_BUF_MODE); // r0
  int v33; // r0
  jpeg_d_main_controller *v34; // [sp+10h] [bp-38h]
  int v35; // [sp+14h] [bp-34h]
  JDIMENSION *v36; // [sp+18h] [bp-30h]
  int v37; // [sp+18h] [bp-30h]
  JSAMPROW *v38; // [sp+1Ch] [bp-2Ch]
  jpeg_d_main_controller *v39; // [sp+1Ch] [bp-2Ch]
  JDIMENSION *v40; // [sp+20h] [bp-28h]

  main = cinfo->main;
  if ( !LOBYTE(main[3].start_pass) )
  {
    if ( !((int (*)(void))cinfo->coef->decompress_data)() )
      return;
    process_data = main[6].process_data;
    LOBYTE(main[3].start_pass) = 1;
    main[6].process_data = (void (*)(j_decompress_ptr, JSAMPARRAY, JDIMENSION *, JDIMENSION))((char *)process_data + 1);
  }
  v9 = main[5].process_data;
  if ( v9 == (void (*)(j_decompress_ptr, JSAMPARRAY, JDIMENSION *, JDIMENSION))((char *)&dword_0 + 2) )
  {
    p_process_data = &main[3].process_data;
    cinfo->post->post_process_data(
      cinfo,
      (JSAMPIMAGE)*((_DWORD *)&main[4].start_pass + (int)main[5].start_pass),
      (JDIMENSION *)&main[3].process_data,
      (JDIMENSION)main[6].start_pass,
      output_buf,
      out_row_ctr,
      out_rows_avail);
    if ( (char *)main[3].process_data < (char *)main[6].start_pass )
      return;
    main[5].process_data = 0;
    if ( *out_row_ctr >= out_rows_avail )
      return;
    goto LABEL_8;
  }
  if ( v9 != (void (*)(j_decompress_ptr, JSAMPARRAY, JDIMENSION *, JDIMENSION))((char *)&dword_0 + 1) )
  {
    if ( v9 )
      return;
    p_process_data = &main[3].process_data;
LABEL_8:
    v36 = (JDIMENSION *)p_process_data;
    v38 = output_buf;
    v40 = out_row_ctr;
    main[3].process_data = 0;
    v11 = main[6].process_data;
    main[6].start_pass = (void (*)(j_decompress_ptr, J_BUF_MODE))(cinfo->min_DCT_scaled_size - 1);
    if ( v11 == (void (*)(j_decompress_ptr, JSAMPARRAY, JDIMENSION *, JDIMENSION))cinfo->total_iMCU_rows
      && cinfo->num_components >= 1 )
    {
      v12 = cinfo->main;
      v13 = 0;
      comp_info = cinfo->comp_info;
      do
      {
        v15 = comp_info->DCT_scaled_size * comp_info->v_samp_factor / cinfo->min_DCT_scaled_size;
        v16 = comp_info->downsampled_height % (comp_info->DCT_scaled_size * comp_info->v_samp_factor);
        if ( !v16 )
          v16 = comp_info->DCT_scaled_size * comp_info->v_samp_factor;
        if ( v13 )
        {
          if ( v15 >= 1 )
            goto LABEL_17;
        }
        else
        {
          v12[6].start_pass = (void (*)(j_decompress_ptr, J_BUF_MODE))((int)(v16 - 1) / v15 + 1);
          if ( v15 >= 1 )
          {
LABEL_17:
            v17 = v16 - 1;
            v18 = *(_DWORD *)(*((_DWORD *)&v12[4].start_pass + (int)v12[5].start_pass) + 4 * v13);
            v19 = v18 + 4 * v16;
            v20 = 0;
            do
              *(_DWORD *)(v19 + 4 * v20++) = *(_DWORD *)(v18 + 4 * v17);
            while ( v20 < 2 * v15 );
          }
        }
        ++v13;
        ++comp_info;
      }
      while ( v13 < cinfo->num_components );
    }
    main[5].process_data = (void (*)(j_decompress_ptr, JSAMPARRAY, JDIMENSION *, JDIMENSION))(&dword_0 + 1);
    v21 = v36;
    output_buf = v38;
    out_row_ctr = v40;
    goto LABEL_25;
  }
  v21 = (JDIMENSION *)&main[3].process_data;
LABEL_25:
  cinfo->post->post_process_data(
    cinfo,
    (JSAMPIMAGE)*((_DWORD *)&main[4].start_pass + (int)main[5].start_pass),
    v21,
    (JDIMENSION)main[6].start_pass,
    output_buf,
    out_row_ctr,
    out_rows_avail);
  if ( (char *)main[3].process_data >= (char *)main[6].start_pass )
  {
    if ( main[6].process_data == (void (*)(j_decompress_ptr, JSAMPARRAY, JDIMENSION *, JDIMENSION))((char *)&dword_0 + 1) )
    {
      p_min_DCT_scaled_size = &cinfo->min_DCT_scaled_size;
      num_components = cinfo->num_components;
      if ( num_components >= 1 )
      {
        v34 = main;
        v24 = 0;
        min_DCT_scaled_size = cinfo->min_DCT_scaled_size;
        v39 = cinfo->main;
        v37 = 4 * min_DCT_scaled_size + 4;
        v35 = 4 * min_DCT_scaled_size + 8;
        for ( i = cinfo->comp_info; ; ++i )
        {
          v27 = i->v_samp_factor * i->DCT_scaled_size / min_DCT_scaled_size;
          if ( v27 >= 1 )
          {
            v28 = 0;
            v29 = v39[4];
            v30 = *((_DWORD *)v29.process_data + v24);
            v31 = *((_DWORD *)v29.start_pass + v24);
            do
            {
              *(_DWORD *)(v31 - 4 * v27 + 4 * v28) = *(_DWORD *)(v31 + v37 * v27 + 4 * v28);
              *(_DWORD *)(v30 - 4 * v27 + 4 * v28) = *(_DWORD *)(v30 + v37 * v27 + 4 * v28);
              *(_DWORD *)(v31 + v35 * v27 + 4 * v28) = *(_DWORD *)(v31 + 4 * v28);
              *(_DWORD *)(v30 + v35 * v27 + 4 * v28) = *(_DWORD *)(v30 + 4 * v28);
              ++v28;
            }
            while ( v27 != v28 );
            num_components = cinfo->num_components;
            p_min_DCT_scaled_size = &cinfo->min_DCT_scaled_size;
          }
          if ( ++v24 >= num_components )
            break;
          min_DCT_scaled_size = *p_min_DCT_scaled_size;
        }
        main = v34;
      }
    }
    else
    {
      p_min_DCT_scaled_size = &cinfo->min_DCT_scaled_size;
    }
    start_pass = main[5].start_pass;
    LOBYTE(main[3].start_pass) = 0;
    main[5].start_pass = (void (*)(j_decompress_ptr, J_BUF_MODE))((unsigned int)start_pass ^ 1);
    main[3].process_data = (void (*)(j_decompress_ptr, JSAMPARRAY, JDIMENSION *, JDIMENSION))(*p_min_DCT_scaled_size + 1);
    v33 = *p_min_DCT_scaled_size + 2;
    main[5].process_data = (void (*)(j_decompress_ptr, JSAMPARRAY, JDIMENSION *, JDIMENSION))(&dword_0 + 2);
    main[6].start_pass = (void (*)(j_decompress_ptr, J_BUF_MODE))v33;
  }
}
// 0: using guessed type int dword_0;

//----- (0047E00E) --------------------------------------------------------
void __fastcall process_data_simple_main(
        j_decompress_ptr cinfo,
        JSAMPARRAY output_buf,
        JDIMENSION *out_row_ctr,
        JDIMENSION out_rows_avail)
{
  jpeg_d_main_controller *main; // r6
  JSAMPARRAY *v9; // r11
  unsigned int min_DCT_scaled_size; // r4

  main = cinfo->main;
  if ( LOBYTE(main[3].start_pass) )
  {
    v9 = (JSAMPARRAY *)&main[1];
  }
  else
  {
    v9 = (JSAMPARRAY *)&main[1];
    if ( !cinfo->coef->decompress_data(cinfo, (JSAMPIMAGE)&main[1]) )
      return;
    LOBYTE(main[3].start_pass) = 1;
  }
  min_DCT_scaled_size = cinfo->min_DCT_scaled_size;
  cinfo->post->post_process_data(
    cinfo,
    v9,
    (JDIMENSION *)&main[3].process_data,
    min_DCT_scaled_size,
    output_buf,
    out_row_ctr,
    out_rows_avail);
  if ( (char *)main[3].process_data >= (char *)min_DCT_scaled_size )
  {
    main[3].process_data = 0;
    LOBYTE(main[3].start_pass) = 0;
  }
}

//----- (0047E078) --------------------------------------------------------
boolean __fastcall jpeg_resync_to_restart(j_decompress_ptr cinfo, int desired)
{
  char v3; // r5
  int unread_marker; // r6
  int v5; // r12
  int v6; // r3
  int v7; // r2
  int v8; // r8
  int v9; // r0
  int v10; // r1
  int v11; // r0

  v3 = desired;
  unread_marker = cinfo->unread_marker;
  cinfo->err->msg_code = 121;
  cinfo->err->msg_parm.i[0] = unread_marker;
  cinfo->err->msg_parm.i[1] = desired;
  cinfo->err->emit_message((j_common_ptr)cinfo, -1);
  v5 = (v3 + 6) & 7 | 0xD0;
  v6 = (v3 + 7) & 7 | 0xD0;
  while ( 2 )
  {
    v7 = 0;
    v8 = 1;
    if ( (unread_marker & 0xFFFFFFF8) != 208 )
      v7 = 1;
    v9 = (unread_marker == ((v3 + 1) & 7 | 0xD0)) | (unread_marker < 192) | v7;
    v10 = 3;
    if ( unread_marker < 192 )
      v10 = 2;
    if ( !v9 )
      v10 = 3;
    if ( unread_marker == v5 )
      v8 = 2;
    if ( unread_marker == v6 )
      v8 = 2;
    if ( unread_marker == ((v3 + 2) & 7 | 0xD0) )
      v8 = v10;
    if ( v9 )
      v8 = v10;
    while ( 1 )
    {
      cinfo->err->msg_code = 97;
      cinfo->err->msg_parm.i[0] = unread_marker;
      cinfo->err->msg_parm.i[1] = v8;
      cinfo->err->emit_message((j_common_ptr)cinfo, 4);
      v11 = v8 & 3;
      if ( v11 == 3 )
        return 1;
      if ( v11 == 2 )
        break;
      if ( v11 == 1 )
      {
        cinfo->unread_marker = 0;
        return 1;
      }
    }
    if ( next_marker(cinfo) )
    {
      unread_marker = cinfo->unread_marker;
      v5 = (v3 + 6) & 7 | 0xD0;
      v6 = (v3 + 7) & 7 | 0xD0;
      continue;
    }
    break;
  }
  return 0;
}

//----- (0047E180) --------------------------------------------------------
boolean __fastcall next_marker(j_decompress_ptr cinfo)
{
  jpeg_source_mgr *src; // r9
  size_t bytes_in_buffer; // r4
  const JOCTET *i; // r6
  jpeg_marker_reader *marker; // r1
  unsigned int discarded_bytes; // r0
  int v7; // t1
  int v8; // r5
  int v9; // t1
  boolean result; // r0

  src = cinfo->src;
  bytes_in_buffer = src->bytes_in_buffer;
  for ( i = src->next_input_byte; bytes_in_buffer; src->bytes_in_buffer = bytes_in_buffer )
  {
LABEL_7:
    v7 = *i++;
    --bytes_in_buffer;
    if ( v7 == 255 )
    {
      do
      {
        if ( !bytes_in_buffer )
        {
          if ( !((int (__fastcall *)(j_decompress_ptr))src->fill_input_buffer)(cinfo) )
            return 0;
          bytes_in_buffer = src->bytes_in_buffer;
          i = src->next_input_byte;
        }
        v9 = *i++;
        v8 = v9;
        --bytes_in_buffer;
      }
      while ( v9 == 255 );
      marker = cinfo->marker;
      discarded_bytes = marker->discarded_bytes;
      if ( v8 )
      {
        if ( discarded_bytes )
        {
          cinfo->err->msg_code = 116;
          cinfo->err->msg_parm.i[0] = cinfo->marker->discarded_bytes;
          cinfo->err->msg_parm.i[1] = v8;
          cinfo->err->emit_message((j_common_ptr)cinfo, -1);
          cinfo->marker->discarded_bytes = 0;
        }
        cinfo->unread_marker = v8;
        result = 1;
        src->next_input_byte = i;
        src->bytes_in_buffer = bytes_in_buffer;
        return result;
      }
      marker->discarded_bytes = discarded_bytes + 2;
    }
    else
    {
      ++cinfo->marker->discarded_bytes;
    }
    src->next_input_byte = i;
  }
  if ( ((int (__fastcall *)(j_decompress_ptr))src->fill_input_buffer)(cinfo) )
  {
    i = src->next_input_byte;
    bytes_in_buffer = src->bytes_in_buffer;
    goto LABEL_7;
  }
  return 0;
}

//----- (0047E23C) --------------------------------------------------------
void __fastcall jinit_marker_reader(j_decompress_ptr cinfo)
{
  int v2; // r0
  int32x4_t v3; // q9
  jpeg_marker_reader *marker; // r0

  v2 = cinfo->mem->alloc_small((j_common_ptr)cinfo, 0, 168);
  v3 = vdupq_n_s32((unsigned int)skip_variable);
  cinfo->marker = (jpeg_marker_reader *)v2;
  *(_DWORD *)v2 = reset_marker_reader;
  *(_DWORD *)(v2 + 4) = read_markers;
  *(_DWORD *)(v2 + 8) = read_restart_marker;
  *(_DWORD *)(v2 + 24) = skip_variable;
  *(_DWORD *)(v2 + 48) = skip_variable;
  *(_DWORD *)(v2 + 108) = 0;
  *(_DWORD *)(v2 + 112) = 0;
  *(_DWORD *)(v2 + 116) = 0;
  *(_DWORD *)(v2 + 88) = skip_variable;
  *(_DWORD *)(v2 + 152) = 0;
  *(_DWORD *)(v2 + 156) = 0;
  *(_QWORD *)(v2 + 92) = 0LL;
  *(_QWORD *)(v2 + 100) = 0LL;
  *(int32x4_t *)(v2 + 32) = v3;
  *(int32x4_t *)(v2 + 52) = v3;
  *(_QWORD *)(v2 + 120) = 0LL;
  *(_QWORD *)(v2 + 128) = 0LL;
  *(int32x4_t *)(v2 + 68) = v3;
  *(_QWORD *)(v2 + 136) = 0LL;
  *(_QWORD *)(v2 + 144) = 0LL;
  *(_DWORD *)(v2 + 84) = get_interesting_appn;
  *(_DWORD *)(v2 + 28) = get_interesting_appn;
  marker = cinfo->marker;
  cinfo->comp_info = 0;
  cinfo->input_scan_number = 0;
  cinfo->unread_marker = 0;
  marker->discarded_bytes = 0;
  marker[6].next_restart_num = 0;
  *(_WORD *)&marker->saw_SOI = 0;
}

//----- (0047E2EC) --------------------------------------------------------
void __fastcall reset_marker_reader(j_decompress_ptr cinfo)
{
  jpeg_marker_reader *marker; // r1

  marker = cinfo->marker;
  cinfo->comp_info = 0;
  cinfo->input_scan_number = 0;
  cinfo->unread_marker = 0;
  marker->discarded_bytes = 0;
  *(_WORD *)&marker->saw_SOI = 0;
  marker[6].next_restart_num = 0;
}

//----- (0047E308) --------------------------------------------------------
int __fastcall read_markers(j_decompress_ptr cinfo)
{
  uint8x8_t v1; // d16
  int unread_marker; // r0
  jpeg_source_mgr *v4; // r4
  size_t v5; // r0
  size_t v6; // r0
  const JOCTET *v7; // r5
  int v8; // r8
  const JOCTET *v9; // r5
  int v10; // r6
  int v11; // t1
  bool v12; // zf
  size_t v13; // r10
  jpeg_marker_reader *marker; // r0
  jpeg_source_mgr *v15; // r8
  size_t v16; // r0
  size_t v17; // r0
  int v18; // r4
  const JOCTET *v19; // r11
  const JOCTET *v20; // r11
  int v21; // t1
  size_t v22; // r10
  unsigned int v23; // r1
  unsigned int v24; // r4
  unsigned int v25; // r1
  unsigned int v26; // r4
  jpeg_error_mgr **v27; // r4
  JQUANT_TBL **v28; // r4
  JQUANT_TBL *v29; // r6
  JQUANT_TBL *v30; // t1
  int v31; // r4
  __int16 v32; // r5
  __int16 v33; // t1
  UINT16 v34; // r0
  bool v35; // cc
  jpeg_error_mgr *v36; // r0
  UINT16 *v37; // r4
  int j; // r5
  unsigned __int16 *v39; // r1
  int v40; // r0
  jpeg_source_mgr *v41; // r4
  size_t v42; // r0
  size_t v43; // r8
  const JOCTET *v44; // r5
  int v45; // r6
  int v46; // t1
  unsigned int v47; // r6
  jpeg_source_mgr *v48; // r4
  size_t v49; // r0
  size_t v50; // r0
  const JOCTET *v51; // r5
  int v52; // r6
  const JOCTET *v53; // r5
  int v54; // t1
  int v55; // r1
  size_t v56; // r6
  const JOCTET *v57; // r5
  int v58; // r8
  int v59; // t1
  size_t v60; // r10
  int v61; // t1
  int v62; // r6
  int v63; // r0
  int v64; // r6
  jpeg_decompress_struct *v65; // r0
  boolean v66; // r1
  boolean v67; // r2
  jpeg_error_mgr *err; // r0
  int v69; // r1
  jpeg_source_mgr *src; // r8
  size_t bytes_in_buffer; // r0
  size_t v72; // r0
  int v73; // r4
  const JOCTET *next_input_byte; // r5
  char *v75; // r5
  int v76; // t1
  size_t v77; // r6
  unsigned int v78; // r1
  int v79; // r4
  int v80; // r11
  int v81; // t1
  int v82; // r10
  int v83; // r4
  int v84; // t1
  int *v85; // r0
  uint32x4_t v86; // q8
  uint32x4_t v87; // q8
  uint32x4_t *v88; // r0
  uint32x4_t v89; // q8
  int i; // r10
  char v91; // t1
  unsigned int v92; // r0
  int *v93; // r10
  JHUFF_TBL *v94; // r0
  __int64 v95; // d17
  UINT8 v96; // r1
  jpeg_source_mgr *v97; // r6
  size_t v98; // r4
  const JOCTET *v99; // r5
  size_t v100; // r0
  const JOCTET *v101; // r5
  int v102; // r8
  int v103; // t1
  const JOCTET *v104; // r5
  int v105; // r10
  int v106; // t1
  size_t v107; // r6
  int v108; // r4
  unsigned __int8 *v109; // r0
  int v110; // r1
  unsigned __int8 *v111; // r5
  int v112; // r6
  jpeg_source_mgr *v113; // r8
  unsigned __int8 *v114; // r5
  int v115; // r10
  int v116; // t1
  unsigned __int8 *v117; // r11
  int num_components; // r0
  jpeg_component_info *comp_info; // r4
  unsigned int v120; // r8
  int v121; // r1
  jpeg_error_mgr *v122; // r0
  unsigned __int8 *v123; // r5
  int v124; // t1
  unsigned __int8 *v125; // r0
  unsigned __int8 *v126; // r5
  int v127; // t1
  unsigned __int8 *v128; // r4
  unsigned int v129; // t1
  jpeg_error_mgr *v130; // r1
  int Ss; // r2
  unsigned int v133; // [sp+4h] [bp-164h]
  unsigned int v134; // [sp+18h] [bp-150h]
  int v135; // [sp+18h] [bp-150h]
  int v136; // [sp+18h] [bp-150h]
  int v137; // [sp+18h] [bp-150h]
  jpeg_source_mgr *v138; // [sp+1Ch] [bp-14Ch]
  char v139[256]; // [sp+30h] [bp-138h] BYREF
  __int64 v140; // [sp+130h] [bp-38h] BYREF
  _QWORD v141[2]; // [sp+138h] [bp-30h]

  unread_marker = cinfo->unread_marker;
  if ( unread_marker )
    goto LABEL_89;
  while ( cinfo->marker->saw_SOI )
  {
    if ( !next_marker(cinfo) )
      return 0;
LABEL_16:
    unread_marker = cinfo->unread_marker;
LABEL_89:
    switch ( unread_marker )
    {
      case 1:
      case 208:
      case 209:
      case 210:
      case 211:
      case 212:
      case 213:
      case 214:
      case 215:
        cinfo->err->msg_code = 92;
        cinfo->err->msg_parm.i[0] = cinfo->unread_marker;
        cinfo->err->emit_message((j_common_ptr)cinfo, 1);
        goto LABEL_88;
      case 192:
      case 193:
        v64 = 0;
        v65 = cinfo;
        v66 = 0;
        goto LABEL_99;
      case 194:
        v64 = 0;
        v65 = cinfo;
        v66 = 1;
LABEL_99:
        v67 = 0;
        goto LABEL_20;
      case 195:
      case 197:
      case 198:
      case 199:
      case 200:
      case 203:
      case 205:
      case 206:
      case 207:
        err = cinfo->err;
        v69 = 60;
        goto LABEL_95;
      case 196:
        src = cinfo->src;
        bytes_in_buffer = src->bytes_in_buffer;
        if ( bytes_in_buffer )
          goto LABEL_103;
        if ( !((int (__fastcall *)(j_decompress_ptr))src->fill_input_buffer)(cinfo) )
          return 0;
        bytes_in_buffer = src->bytes_in_buffer;
LABEL_103:
        v72 = bytes_in_buffer - 1;
        next_input_byte = src->next_input_byte + 1;
        v73 = *src->next_input_byte;
        if ( v72 )
          goto LABEL_106;
        if ( !((int (__fastcall *)(j_decompress_ptr))src->fill_input_buffer)(cinfo) )
          return 0;
        v72 = src->bytes_in_buffer;
        next_input_byte = src->next_input_byte;
LABEL_106:
        v76 = *next_input_byte;
        v75 = (char *)(next_input_byte + 1);
        v77 = v72 - 1;
        v78 = (v73 << 8) | v76;
        v79 = v78 - 2;
        if ( v78 < 0x13 )
          goto LABEL_17;
        do
        {
          v135 = v79;
          if ( !v77 )
          {
            if ( !((int (__fastcall *)(j_decompress_ptr))src->fill_input_buffer)(cinfo) )
              return 0;
            v77 = src->bytes_in_buffer;
            v75 = (char *)src->next_input_byte;
          }
          v81 = (unsigned __int8)*v75++;
          v80 = v81;
          cinfo->err->msg_code = 80;
          cinfo->err->msg_parm.i[0] = v81;
          cinfo->err->emit_message((j_common_ptr)cinfo, 1);
          --v77;
          v82 = 0;
          v83 = 0;
          LOBYTE(v140) = 0;
          do
          {
            if ( !v77 )
            {
              if ( !((int (__fastcall *)(j_decompress_ptr))src->fill_input_buffer)(cinfo) )
                return 0;
              v77 = src->bytes_in_buffer;
              v75 = (char *)src->next_input_byte;
            }
            v84 = (unsigned __int8)*v75++;
            --v77;
            *((_BYTE *)&v140 + ++v82) = v84;
            v83 += v84;
          }
          while ( v82 < 16 );
          v1.n64_u32[0] = *(_DWORD *)((char *)&v140 + 1);
          v85 = &cinfo->err->msg_parm.i[4];
          v86 = vmovl_u16((uint16x4_t)vmovl_u8(v1).n128_u64[0]);
          *(uint32x4_t *)cinfo->err->msg_parm.i = v86;
          v86.n128_u32[0] = *(_DWORD *)((unsigned int)&v140 | 5);
          v87 = vmovl_u16((uint16x4_t)vmovl_u8((uint8x8_t)v86.n128_u64[0]).n128_u64[0]);
          *(uint32x4_t *)v85 = v87;
          cinfo->err->msg_code = 86;
          cinfo->err->emit_message((j_common_ptr)cinfo, 2);
          v87.n128_u32[0] = *(_DWORD *)((char *)v141 + 1);
          v88 = (uint32x4_t *)&cinfo->err->msg_parm.s[16];
          v89 = vmovl_u16((uint16x4_t)vmovl_u8((uint8x8_t)v87.n128_u64[0]).n128_u64[0]);
          *(uint32x4_t *)cinfo->err->msg_parm.i = v89;
          v89.n128_u32[0] = *(_DWORD *)((char *)v141 + 5);
          *v88 = vmovl_u16((uint16x4_t)vmovl_u8((uint8x8_t)v89.n128_u64[0]).n128_u64[0]);
          cinfo->err->msg_code = 86;
          cinfo->err->emit_message((j_common_ptr)cinfo, 2);
          if ( v83 > 256 || v135 - 17 < v83 )
          {
            cinfo->err->msg_code = 8;
            cinfo->err->error_exit((j_common_ptr)cinfo);
          }
          v136 = v135 - 17;
          if ( v83 >= 1 )
          {
            for ( i = 0; i < v83; ++i )
            {
              if ( !v77 )
              {
                if ( !((int (__fastcall *)(j_decompress_ptr))src->fill_input_buffer)(cinfo) )
                  return 0;
                v77 = src->bytes_in_buffer;
                v75 = (char *)src->next_input_byte;
              }
              v91 = *v75++;
              --v77;
              v139[i] = v91;
            }
          }
          v92 = v80 - 16;
          if ( (v80 & 0x10) == 0 )
            v92 = v80;
          v93 = &cinfo->actual_number_of_colors + v80;
          if ( (v80 & 0x10) == 0 )
            v93 = (int *)&cinfo->dc_huff_tbl_ptrs[v80];
          if ( v92 >= 4 )
          {
            cinfo->err->msg_code = 30;
            cinfo->err->msg_parm.i[0] = v92;
            cinfo->err->error_exit((j_common_ptr)cinfo);
          }
          v79 = v136 - v83;
          v94 = (JHUFF_TBL *)*v93;
          if ( !*v93 )
          {
            v94 = jpeg_alloc_huff_table((j_common_ptr)cinfo);
            *v93 = (int)v94;
          }
          v1.n64_u32[1] = HIDWORD(v140);
          v95 = v141[0];
          v96 = v141[1];
          *(_QWORD *)v94->bits = v140;
          *(_QWORD *)&v94->bits[8] = v95;
          v94->bits[16] = v96;
          qmemcpy((void *)(*v93 + 17), v139, 0x100u);
        }
        while ( v79 > 16 );
LABEL_17:
        if ( v79 )
        {
          cinfo->err->msg_code = 11;
          cinfo->err->error_exit((j_common_ptr)cinfo);
        }
        src->next_input_byte = (const JOCTET *)v75;
        src->bytes_in_buffer = v77;
        goto LABEL_88;
      case 201:
        v64 = 0;
        v65 = cinfo;
        v66 = 0;
        v67 = 1;
LABEL_20:
        if ( !get_sof(v65, v66, v67) )
          return v64;
        goto LABEL_88;
      case 202:
        if ( !get_sof(cinfo, 1u, 1u) )
          return 0;
        goto LABEL_88;
      case 204:
      case 220:
        v41 = cinfo->src;
        v42 = v41->bytes_in_buffer;
        if ( v42 )
          goto LABEL_66;
        if ( !((int (__fastcall *)(j_decompress_ptr))v41->fill_input_buffer)(cinfo) )
          return 0;
        v42 = v41->bytes_in_buffer;
LABEL_66:
        v43 = v42 - 1;
        v44 = v41->next_input_byte + 1;
        v45 = *v41->next_input_byte;
        if ( v42 != 1 )
          goto LABEL_69;
        if ( !((int (__fastcall *)(j_decompress_ptr))v41->fill_input_buffer)(cinfo) )
          return 0;
        v44 = v41->next_input_byte;
        v43 = v41->bytes_in_buffer;
LABEL_69:
        v46 = *v44;
        cinfo->err->msg_code = 91;
        v47 = (v45 << 8) | v46;
        cinfo->err->msg_parm.i[0] = cinfo->unread_marker;
        cinfo->err->msg_parm.i[1] = v47 - 2;
        cinfo->err->emit_message((j_common_ptr)cinfo, 1);
        v41->next_input_byte = v44 + 1;
        v41->bytes_in_buffer = v43 - 1;
        if ( v47 >= 3 )
          cinfo->src->skip_input_data(cinfo, v47 - 2);
        goto LABEL_88;
      case 216:
        cinfo->err->msg_code = 102;
        cinfo->err->emit_message((j_common_ptr)cinfo, 1);
        marker = cinfo->marker;
        if ( marker->saw_SOI )
        {
          cinfo->err->msg_code = 61;
          cinfo->err->error_exit((j_common_ptr)cinfo);
          marker = cinfo->marker;
        }
        *(_DWORD *)cinfo->arith_dc_L = 0;
        *(_DWORD *)cinfo->arith_dc_U = 16843009;
        *(_DWORD *)cinfo->arith_ac_K = 84215045;
        *(_DWORD *)&cinfo->arith_dc_L[4] = 0;
        *(_DWORD *)&cinfo->arith_dc_U[4] = 16843009;
        *(_DWORD *)&cinfo->arith_ac_K[4] = 84215045;
        *(_WORD *)&cinfo->arith_dc_U[8] = 257;
        *(_WORD *)&cinfo->arith_ac_K[8] = 1285;
        *(_DWORD *)&cinfo->arith_dc_L[8] = 0;
        *(_WORD *)&cinfo->arith_ac_K[10] = 1285;
        *(_DWORD *)&cinfo->arith_dc_U[10] = 16843009;
        *(_DWORD *)&cinfo->arith_dc_L[12] = 0;
        *(_WORD *)&cinfo->arith_dc_U[14] = 257;
        *(_DWORD *)&cinfo->arith_ac_K[12] = 84215045;
        cinfo->restart_interval = 0;
        cinfo->jpeg_color_space = JCS_UNKNOWN;
        cinfo->CCIR601_sampling = 0;
        cinfo->JFIF_major_version = 1;
        cinfo->saw_JFIF_marker = 0;
        cinfo->JFIF_minor_version = 1;
        cinfo->density_unit = 0;
        cinfo->X_density = 1;
        cinfo->Y_density = 1;
        cinfo->saw_Adobe_marker = 0;
        cinfo->Adobe_transform = 0;
        marker->saw_SOI = 1;
        goto LABEL_88;
      case 217:
        cinfo->err->msg_code = 85;
        cinfo->err->emit_message((j_common_ptr)cinfo, 1);
        v64 = 2;
        cinfo->unread_marker = 0;
        return v64;
      case 218:
        v97 = cinfo->src;
        v98 = v97->bytes_in_buffer;
        v99 = v97->next_input_byte;
        if ( cinfo->marker->saw_SOF )
        {
          if ( v98 )
            goto LABEL_143;
        }
        else
        {
          cinfo->err->msg_code = 62;
          cinfo->err->error_exit((j_common_ptr)cinfo);
          if ( v98 )
            goto LABEL_143;
        }
        if ( !((int (__fastcall *)(j_decompress_ptr))v97->fill_input_buffer)(cinfo) )
          return 0;
        v98 = v97->bytes_in_buffer;
        v99 = v97->next_input_byte;
LABEL_143:
        v138 = v97;
        v100 = v98 - 1;
        v103 = *v99;
        v101 = v99 + 1;
        v102 = v103;
        if ( v98 != 1 )
          goto LABEL_146;
        if ( !((int (__fastcall *)(j_decompress_ptr))v97->fill_input_buffer)(cinfo) )
          return 0;
        v100 = v97->bytes_in_buffer;
        v101 = v97->next_input_byte;
LABEL_146:
        v106 = *v101;
        v104 = v101 + 1;
        v105 = v106;
        v107 = v100 - 1;
        if ( v100 != 1 )
          goto LABEL_149;
        if ( !((int (__fastcall *)(j_decompress_ptr))v138->fill_input_buffer)(cinfo) )
          return 0;
        v107 = v138->bytes_in_buffer;
        v104 = v138->next_input_byte;
LABEL_149:
        v108 = *v104;
        cinfo->err->msg_code = 103;
        cinfo->err->msg_parm.i[0] = v108;
        cinfo->err->emit_message((j_common_ptr)cinfo, 1);
        if ( (unsigned __int8)(v108 - 1) > 3u || ((v102 << 8) | v105) != 2 * v108 + 6 )
        {
          cinfo->err->msg_code = 11;
          cinfo->err->error_exit((j_common_ptr)cinfo);
        }
        v109 = (unsigned __int8 *)(v107 - 1);
        v110 = 0;
        v111 = (unsigned __int8 *)(v104 + 1);
        cinfo->comps_in_scan = v108;
        if ( v107 == 1 )
          v110 = 1;
        v112 = 0;
        if ( v108 )
        {
          v113 = v138;
          v137 = v108;
          while ( 1 )
          {
            if ( v110 << 31 )
            {
              if ( !((int (__fastcall *)(j_decompress_ptr))v113->fill_input_buffer)(cinfo) )
                return 0;
              v109 = (unsigned __int8 *)v113->bytes_in_buffer;
              v111 = (unsigned __int8 *)v113->next_input_byte;
            }
            v116 = *v111;
            v114 = v111 + 1;
            v115 = v116;
            v117 = v109 - 1;
            if ( v109 == (_BYTE *)&dword_0 + 1 )
            {
              if ( !((int (__fastcall *)(j_decompress_ptr))v113->fill_input_buffer)(cinfo) )
                return 0;
              v117 = (unsigned __int8 *)v113->bytes_in_buffer;
              v114 = (unsigned __int8 *)v113->next_input_byte;
            }
            num_components = cinfo->num_components;
            comp_info = cinfo->comp_info;
            v120 = *v114;
            if ( num_components < 1 )
            {
LABEL_166:
              cinfo->err->msg_code = 5;
              cinfo->err->msg_parm.i[0] = v115;
              cinfo->err->error_exit((j_common_ptr)cinfo);
            }
            else
            {
              v121 = 0;
              while ( comp_info->component_id != v115 )
              {
                ++v121;
                ++comp_info;
                if ( v121 >= num_components )
                  goto LABEL_166;
              }
            }
            cinfo->cur_comp_info[v112] = comp_info;
            comp_info->dc_tbl_no = v120 >> 4;
            comp_info->ac_tbl_no = v120 & 0xF;
            v122 = cinfo->err;
            v122->msg_parm.i[0] = v115;
            v122->msg_parm.i[1] = comp_info->dc_tbl_no;
            v122->msg_parm.i[2] = comp_info->ac_tbl_no;
            cinfo->err->msg_code = 104;
            cinfo->err->emit_message((j_common_ptr)cinfo, 1);
            v109 = v117 - 1;
            v110 = v117 == (_BYTE *)&dword_0 + 1;
            v113 = v138;
            ++v112;
            v111 = v114 + 1;
            if ( v112 >= v137 )
            {
              if ( v110 != 1 )
                goto LABEL_173;
              goto LABEL_171;
            }
          }
        }
        v113 = v138;
        if ( v110 != 1 )
          goto LABEL_173;
LABEL_171:
        if ( !((int (__fastcall *)(j_decompress_ptr))v113->fill_input_buffer)(cinfo) )
          return 0;
        v109 = (unsigned __int8 *)v113->bytes_in_buffer;
        v111 = (unsigned __int8 *)v113->next_input_byte;
LABEL_173:
        v124 = *v111;
        v123 = v111 + 1;
        v125 = v109 - 1;
        cinfo->Ss = v124;
        if ( v125 )
          goto LABEL_176;
        if ( !((int (__fastcall *)(j_decompress_ptr))v113->fill_input_buffer)(cinfo) )
          return 0;
        v125 = (unsigned __int8 *)v113->bytes_in_buffer;
        v123 = (unsigned __int8 *)v113->next_input_byte;
LABEL_176:
        v127 = *v123;
        v126 = v123 + 1;
        v128 = v125 - 1;
        cinfo->Se = v127;
        if ( v125 != (_BYTE *)&dword_0 + 1 )
          goto LABEL_179;
        if ( !((int (__fastcall *)(j_decompress_ptr))v113->fill_input_buffer)(cinfo) )
          return 0;
        v128 = (unsigned __int8 *)v113->bytes_in_buffer;
        v126 = (unsigned __int8 *)v113->next_input_byte;
LABEL_179:
        v129 = *v126;
        v64 = 1;
        v130 = cinfo->err;
        Ss = cinfo->Ss;
        cinfo->Ah = v129 >> 4;
        cinfo->Al = v129 & 0xF;
        v130->msg_parm.i[0] = Ss;
        v130->msg_parm.i[1] = cinfo->Se;
        v130->msg_parm.i[2] = cinfo->Ah;
        v130->msg_parm.i[3] = cinfo->Al;
        cinfo->err->msg_code = 105;
        cinfo->err->emit_message((j_common_ptr)cinfo, 1);
        cinfo->marker->next_restart_num = 0;
        ++cinfo->input_scan_number;
        v113->next_input_byte = v126 + 1;
        v113->bytes_in_buffer = (size_t)(v128 - 1);
        cinfo->unread_marker = 0;
        return v64;
      case 219:
        v15 = cinfo->src;
        v16 = v15->bytes_in_buffer;
        if ( v16 )
          goto LABEL_28;
        if ( !((int (__fastcall *)(j_decompress_ptr))v15->fill_input_buffer)(cinfo) )
          return 0;
        v16 = v15->bytes_in_buffer;
LABEL_28:
        v17 = v16 - 1;
        v19 = v15->next_input_byte + 1;
        v18 = *v15->next_input_byte;
        if ( v17 )
          goto LABEL_31;
        if ( !((int (__fastcall *)(j_decompress_ptr))v15->fill_input_buffer)(cinfo) )
          return 0;
        v17 = v15->bytes_in_buffer;
        v19 = v15->next_input_byte;
LABEL_31:
        v21 = *v19;
        v20 = v19 + 1;
        v22 = v17 - 1;
        v23 = (v18 << 8) | v21;
        v24 = v23 - 2;
        if ( v23 < 3 )
          goto LABEL_60;
        break;
      case 221:
        v48 = cinfo->src;
        v49 = v48->bytes_in_buffer;
        if ( v49 )
          goto LABEL_75;
        if ( !((int (__fastcall *)(j_decompress_ptr))v48->fill_input_buffer)(cinfo) )
          return 0;
        v49 = v48->bytes_in_buffer;
LABEL_75:
        v50 = v49 - 1;
        v51 = v48->next_input_byte + 1;
        v52 = *v48->next_input_byte;
        if ( v50 )
          goto LABEL_78;
        if ( !((int (__fastcall *)(j_decompress_ptr))v48->fill_input_buffer)(cinfo) )
          return 0;
        v50 = v48->bytes_in_buffer;
        v51 = v48->next_input_byte;
LABEL_78:
        v54 = *v51;
        v53 = v51 + 1;
        v55 = v52 << 8;
        v56 = v50 - 1;
        if ( (v55 | v54) != 4 )
        {
          cinfo->err->msg_code = 11;
          cinfo->err->error_exit((j_common_ptr)cinfo);
        }
        if ( v56 )
          goto LABEL_83;
        if ( !((int (__fastcall *)(j_decompress_ptr))v48->fill_input_buffer)(cinfo) )
          return 0;
        v56 = v48->bytes_in_buffer;
        v53 = v48->next_input_byte;
LABEL_83:
        v59 = *v53;
        v57 = v53 + 1;
        v58 = v59;
        v60 = v56 - 1;
        if ( v56 != 1 )
          goto LABEL_86;
        if ( !((int (__fastcall *)(j_decompress_ptr))v48->fill_input_buffer)(cinfo) )
          return 0;
        v60 = v48->bytes_in_buffer;
        v57 = v48->next_input_byte;
LABEL_86:
        v61 = *v57;
        cinfo->err->msg_code = 82;
        v62 = (v58 << 8) | v61;
        cinfo->err->msg_parm.i[0] = v62;
        cinfo->err->emit_message((j_common_ptr)cinfo, 1);
        cinfo->restart_interval = v62;
        v48->next_input_byte = v57 + 1;
        v48->bytes_in_buffer = v60 - 1;
        goto LABEL_88;
      case 224:
      case 225:
      case 226:
      case 227:
      case 228:
      case 229:
      case 230:
      case 231:
      case 232:
      case 233:
      case 234:
      case 235:
      case 236:
      case 237:
      case 238:
      case 239:
        v63 = (*((int (__fastcall **)(j_decompress_ptr))&cinfo->marker[-36] + unread_marker - 1))(cinfo);
        goto LABEL_87;
      case 254:
        v63 = ((int (__fastcall *)(j_decompress_ptr))cinfo->marker[1].reset_marker_reader)(cinfo);
LABEL_87:
        if ( v63 )
          goto LABEL_88;
        return 0;
      default:
        err = cinfo->err;
        v69 = 68;
LABEL_95:
        err->msg_code = v69;
        cinfo->err->msg_parm.i[0] = cinfo->unread_marker;
        cinfo->err->error_exit((j_common_ptr)cinfo);
        goto LABEL_88;
    }
    do
    {
      if ( !v22 )
      {
        if ( !((int (__fastcall *)(j_decompress_ptr))v15->fill_input_buffer)(cinfo) )
          return 0;
        v22 = v15->bytes_in_buffer;
        v20 = v15->next_input_byte;
      }
      v133 = v24;
      v25 = *v20;
      cinfo->err->msg_code = 81;
      v26 = v25 & 0xF;
      cinfo->err->msg_parm.i[0] = v26;
      v134 = v25 >> 4;
      cinfo->err->msg_parm.i[1] = v25 >> 4;
      cinfo->err->emit_message((j_common_ptr)cinfo, 1);
      if ( v26 >= 4 )
      {
        cinfo->err->msg_code = 31;
        cinfo->err->msg_parm.i[0] = v26;
        cinfo->err->error_exit((j_common_ptr)cinfo);
      }
      v27 = &cinfo->err + v26;
      v30 = (JQUANT_TBL *)v27[36];
      v28 = (JQUANT_TBL **)(v27 + 36);
      v29 = v30;
      if ( !v30 )
      {
        v29 = jpeg_alloc_quant_table((j_common_ptr)cinfo);
        *v28 = v29;
      }
      ++v20;
      --v22;
      v31 = 0;
      do
      {
        if ( v134 )
        {
          if ( !v22 )
          {
            if ( !((int (__fastcall *)(j_decompress_ptr))v15->fill_input_buffer)(cinfo) )
              return 0;
            v22 = v15->bytes_in_buffer;
            v20 = v15->next_input_byte;
          }
          v33 = *v20++;
          v32 = v33;
          if ( !--v22 )
          {
            if ( !((int (__fastcall *)(j_decompress_ptr))v15->fill_input_buffer)(cinfo) )
              return 0;
            v22 = v15->bytes_in_buffer;
            v20 = v15->next_input_byte;
          }
          v34 = (v32 << 8) | *v20;
        }
        else
        {
          if ( !v22 )
          {
            if ( !((int (__fastcall *)(j_decompress_ptr))v15->fill_input_buffer)(cinfo) )
              return 0;
            v22 = v15->bytes_in_buffer;
            v20 = v15->next_input_byte;
          }
          v34 = *v20;
        }
        ++v20;
        --v22;
        v35 = v31 < 63;
        v29->quantval[jpeg_natural_order[v31++]] = v34;
      }
      while ( v35 );
      v36 = cinfo->err;
      if ( cinfo->err->trace_level >= 2 )
      {
        v37 = &v29->quantval[7];
        for ( j = 0; ; j += 8 )
        {
          v36->msg_parm.i[0] = *(v37 - 7);
          v39 = &v29->quantval[j];
          v36->msg_parm.i[1] = v39[1];
          v36->msg_parm.i[2] = v39[2];
          v36->msg_parm.i[3] = v39[3];
          v36->msg_parm.i[4] = v39[4];
          v36->msg_parm.i[5] = v39[5];
          v36->msg_parm.i[6] = v39[6];
          v36->msg_parm.i[7] = *v37;
          cinfo->err->msg_code = 93;
          cinfo->err->emit_message((j_common_ptr)cinfo, 2);
          if ( j > 55 )
            break;
          v37 += 8;
          v36 = cinfo->err;
        }
      }
      v40 = -129;
      if ( !v134 )
        v40 = -65;
      v24 = v133 + v40;
    }
    while ( (int)(v133 + v40) > 0 );
LABEL_60:
    if ( v24 )
    {
      cinfo->err->msg_code = 11;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    v15->next_input_byte = v20;
    v15->bytes_in_buffer = v22;
LABEL_88:
    cinfo->unread_marker = 0;
  }
  v4 = cinfo->src;
  v5 = v4->bytes_in_buffer;
  if ( !v5 )
  {
    if ( !((int (__fastcall *)(j_decompress_ptr))v4->fill_input_buffer)(cinfo) )
      return 0;
    v5 = v4->bytes_in_buffer;
  }
  v6 = v5 - 1;
  v7 = v4->next_input_byte + 1;
  v8 = *v4->next_input_byte;
  if ( v6 )
  {
LABEL_11:
    v11 = *v7;
    v9 = v7 + 1;
    v10 = v11;
    v12 = v8 == 255;
    v13 = v6 - 1;
    if ( v8 == 255 )
      v12 = v10 == 216;
    if ( !v12 )
    {
      cinfo->err->msg_code = 53;
      cinfo->err->msg_parm.i[0] = v8;
      cinfo->err->msg_parm.i[1] = v10;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    cinfo->unread_marker = v10;
    v4->next_input_byte = v9;
    v4->bytes_in_buffer = v13;
    goto LABEL_16;
  }
  if ( ((int (__fastcall *)(j_decompress_ptr))v4->fill_input_buffer)(cinfo) )
  {
    v6 = v4->bytes_in_buffer;
    v7 = v4->next_input_byte;
    goto LABEL_11;
  }
  return 0;
}
// 47EB38: variable 'v1' is possibly undefined
// 0: using guessed type int dword_0;
// 47E308: using guessed type char var_138[256];

//----- (0047EF30) --------------------------------------------------------
boolean __fastcall read_restart_marker(j_decompress_ptr cinfo)
{
  int unread_marker; // r0

  unread_marker = cinfo->unread_marker;
  if ( !unread_marker )
  {
    if ( !next_marker(cinfo) )
      return 0;
    unread_marker = cinfo->unread_marker;
  }
  if ( unread_marker == cinfo->marker->next_restart_num + 208 )
  {
    cinfo->err->msg_code = 98;
    cinfo->err->msg_parm.i[0] = cinfo->marker->next_restart_num;
    cinfo->err->emit_message((j_common_ptr)cinfo, 3);
    cinfo->unread_marker = 0;
LABEL_7:
    cinfo->marker->next_restart_num = ((unsigned __int8)cinfo->marker->next_restart_num + 1) & 7;
    return 1;
  }
  if ( ((int (__fastcall *)(j_decompress_ptr))cinfo->src->resync_to_restart)(cinfo) )
    goto LABEL_7;
  return 0;
}

//----- (0047EF98) --------------------------------------------------------
boolean __fastcall skip_variable(j_decompress_ptr cinfo)
{
  jpeg_source_mgr *src; // r6
  size_t bytes_in_buffer; // r0
  size_t v4; // r10
  const JOCTET *next_input_byte; // r5
  int v6; // r8
  int v7; // t1
  boolean v8; // r9
  unsigned int v9; // r11

  src = cinfo->src;
  bytes_in_buffer = src->bytes_in_buffer;
  if ( !bytes_in_buffer )
  {
    if ( !((int (__fastcall *)(j_decompress_ptr))src->fill_input_buffer)(cinfo) )
      return 0;
    bytes_in_buffer = src->bytes_in_buffer;
  }
  v4 = bytes_in_buffer - 1;
  next_input_byte = src->next_input_byte + 1;
  v6 = *src->next_input_byte;
  if ( bytes_in_buffer != 1 )
    goto LABEL_7;
  if ( !((int (__fastcall *)(j_decompress_ptr))src->fill_input_buffer)(cinfo) )
    return 0;
  v4 = src->bytes_in_buffer;
  next_input_byte = src->next_input_byte;
LABEL_7:
  v7 = *next_input_byte;
  v8 = 1;
  cinfo->err->msg_code = 91;
  v9 = (v6 << 8) | v7;
  cinfo->err->msg_parm.i[0] = cinfo->unread_marker;
  cinfo->err->msg_parm.i[1] = v9 - 2;
  cinfo->err->emit_message((j_common_ptr)cinfo, 1);
  src->next_input_byte = next_input_byte + 1;
  src->bytes_in_buffer = v4 - 1;
  if ( v9 >= 3 )
  {
    cinfo->src->skip_input_data(cinfo, v9 - 2);
    return 1;
  }
  return v8;
}

//----- (0047F02C) --------------------------------------------------------
boolean __fastcall get_interesting_appn(j_decompress_ptr cinfo)
{
  jpeg_source_mgr *src; // r6
  size_t bytes_in_buffer; // r0
  size_t v4; // r0
  int v5; // r4
  const JOCTET *next_input_byte; // r5
  char *v7; // r5
  int v8; // t1
  int v9; // r1
  size_t v10; // r4
  unsigned int v11; // r1
  unsigned int v12; // r11
  unsigned int i; // r10
  char v14; // t1
  int unread_marker; // r0
  int v16; // r8
  bool v17; // zf
  bool v18; // zf
  int v19; // r11
  int v20; // r0
  int JFIF_major_version; // r0
  bool v23; // zf
  bool v24; // zf
  jpeg_error_mgr *v25; // r0
  int v26; // r1
  bool v27; // zf
  bool v28; // zf
  jpeg_error_mgr *err; // r0
  int v30; // r1
  int v31; // r10
  int v32; // r3
  int v33; // r0
  jpeg_error_mgr *v34; // r1
  int v35; // r8
  int v36; // r10
  int v37; // r0
  unsigned int v38; // [sp+0h] [bp-38h]
  int v39; // [sp+4h] [bp-34h]
  char v40; // [sp+Ah] [bp-2Eh]
  char v41; // [sp+Bh] [bp-2Dh]
  char v42; // [sp+Ch] [bp-2Ch]
  char v43; // [sp+Dh] [bp-2Bh]
  char v44; // [sp+Eh] [bp-2Ah]
  UINT8 v45; // [sp+Fh] [bp-29h]
  UINT8 v46; // [sp+10h] [bp-28h]
  UINT8 v47; // [sp+11h] [bp-27h]
  JOCTET b[14]; // [sp+12h] [bp-26h]

  src = cinfo->src;
  bytes_in_buffer = src->bytes_in_buffer;
  if ( !bytes_in_buffer )
  {
    if ( !((int (__fastcall *)(j_decompress_ptr))src->fill_input_buffer)(cinfo) )
      return 0;
    bytes_in_buffer = src->bytes_in_buffer;
  }
  v4 = bytes_in_buffer - 1;
  next_input_byte = src->next_input_byte + 1;
  v5 = *src->next_input_byte;
  if ( v4 )
    goto LABEL_7;
  if ( !((int (__fastcall *)(j_decompress_ptr))src->fill_input_buffer)(cinfo) )
    return 0;
  v4 = src->bytes_in_buffer;
  next_input_byte = src->next_input_byte;
LABEL_7:
  v8 = *next_input_byte;
  v7 = (char *)(next_input_byte + 1);
  v9 = v5 << 8;
  v10 = v4 - 1;
  v11 = v9 | v8;
  v12 = v11 - 2;
  v39 = v11 - 2;
  if ( v11 <= 2 )
    v12 = 0;
  v38 = v11;
  if ( v11 > 0xF )
    v12 = 14;
  if ( v12 )
  {
    for ( i = 0; i < v12; ++i )
    {
      if ( !v10 )
      {
        if ( !((int (__fastcall *)(j_decompress_ptr))src->fill_input_buffer)(cinfo) )
          return 0;
        v10 = src->bytes_in_buffer;
        v7 = (char *)src->next_input_byte;
      }
      v14 = *v7++;
      --v10;
      *(&v40 + i) = v14;
    }
  }
  unread_marker = cinfo->unread_marker;
  v16 = v39 - v12;
  if ( unread_marker == 238 )
  {
    if ( v12 >= 0xC && v40 == 65 )
    {
      v23 = v41 == 100;
      if ( v41 == 100 )
        v23 = v42 == 111;
      if ( v23 )
      {
        v24 = v43 == 98;
        if ( v43 == 98 )
          v24 = v44 == 101;
        if ( v24 )
        {
          err = cinfo->err;
          v30 = b[0] | (v47 << 8);
          v31 = b[3];
          v32 = b[2] | (b[1] << 8);
          err->msg_parm.i[0] = v46 | (v45 << 8);
          err->msg_parm.i[1] = v30;
          err->msg_parm.i[2] = v32;
          err->msg_parm.i[3] = v31;
          cinfo->err->msg_code = 76;
          cinfo->err->emit_message((j_common_ptr)cinfo, 1);
          cinfo->Adobe_transform = v31;
          cinfo->saw_Adobe_marker = 1;
          v16 = v39 - v12;
          goto LABEL_55;
        }
      }
    }
    v25 = cinfo->err;
    v26 = 78;
    goto LABEL_53;
  }
  if ( unread_marker == 224 )
  {
    if ( v12 < 0xE )
    {
      if ( v12 < 6 )
        goto LABEL_52;
      v27 = v40 == 74;
      if ( v40 == 74 )
        v27 = v41 == 70;
      if ( !v27 )
        goto LABEL_52;
    }
    else
    {
      v17 = v40 == 74;
      if ( v40 == 74 )
        v17 = v41 == 70;
      if ( !v17 )
        goto LABEL_52;
      if ( v42 == 73 )
      {
        v18 = v43 == 70;
        if ( v43 == 70 )
          v18 = v44 == 0;
        if ( v18 )
        {
          v19 = v39 - v12;
          cinfo->saw_JFIF_marker = 1;
          v20 = v45;
          cinfo->JFIF_major_version = v45;
          cinfo->JFIF_minor_version = v46;
          cinfo->density_unit = v47;
          cinfo->X_density = _byteswap_ushort(*(unsigned __int16 *)b);
          cinfo->Y_density = _byteswap_ushort(*(unsigned __int16 *)&b[2]);
          if ( v20 == 1 )
          {
            JFIF_major_version = 1;
          }
          else
          {
            cinfo->err->msg_code = 119;
            cinfo->err->msg_parm.i[0] = cinfo->JFIF_major_version;
            cinfo->err->msg_parm.i[1] = cinfo->JFIF_minor_version;
            cinfo->err->emit_message((j_common_ptr)cinfo, -1);
            JFIF_major_version = cinfo->JFIF_major_version;
          }
          v34 = cinfo->err;
          v34->msg_parm.i[0] = JFIF_major_version;
          v34->msg_parm.i[1] = cinfo->JFIF_minor_version;
          v34->msg_parm.i[2] = cinfo->X_density;
          v34->msg_parm.i[3] = cinfo->Y_density;
          v34->msg_parm.i[4] = cinfo->density_unit;
          cinfo->err->msg_code = 87;
          cinfo->err->emit_message((j_common_ptr)cinfo, 1);
          v35 = b[4];
          v36 = b[5];
          if ( b[5] | b[4] )
          {
            cinfo->err->msg_code = 90;
            cinfo->err->msg_parm.i[0] = v35;
            cinfo->err->msg_parm.i[1] = v36;
            cinfo->err->emit_message((j_common_ptr)cinfo, 1);
          }
          v37 = (__int16)v36 * (__int16)v35;
          v16 = v19;
          if ( v38 - 16 == 3 * v37 )
            goto LABEL_55;
          cinfo->err->msg_code = 88;
          cinfo->err->msg_parm.i[0] = v38 - 16;
          goto LABEL_54;
        }
      }
    }
    if ( v42 == 88 )
    {
      v28 = v43 == 88;
      if ( v43 == 88 )
        v28 = v44 == 0;
      if ( v28 )
      {
        v33 = v45;
        switch ( v45 )
        {
          case 0x13u:
            v25 = cinfo->err;
            v26 = 110;
            break;
          case 0x11u:
            v25 = cinfo->err;
            v26 = 109;
            break;
          case 0x10u:
            v25 = cinfo->err;
            v26 = 108;
            break;
          default:
            cinfo->err->msg_code = 89;
            cinfo->err->msg_parm.i[0] = v33;
            cinfo->err->msg_parm.i[1] = v39;
            goto LABEL_54;
        }
LABEL_53:
        v25->msg_code = v26;
        cinfo->err->msg_parm.i[0] = v39;
LABEL_54:
        cinfo->err->emit_message((j_common_ptr)cinfo, 1);
        goto LABEL_55;
      }
    }
LABEL_52:
    v25 = cinfo->err;
    v26 = 77;
    goto LABEL_53;
  }
  cinfo->err->msg_code = 68;
  cinfo->err->msg_parm.i[0] = cinfo->unread_marker;
  cinfo->err->error_exit((j_common_ptr)cinfo);
LABEL_55:
  src->next_input_byte = (const JOCTET *)v7;
  src->bytes_in_buffer = v10;
  if ( v16 >= 1 )
    cinfo->src->skip_input_data(cinfo, v16);
  return 1;
}

//----- (0047F374) --------------------------------------------------------
void __fastcall jpeg_set_marker_processor(j_decompress_ptr cinfo, int marker_code, jpeg_marker_parser_method routine)
{
  jpeg_marker_reader *marker; // r12

  marker = cinfo->marker;
  if ( marker_code == 254 )
  {
    marker[1].reset_marker_reader = (void (*)(j_decompress_ptr))routine;
  }
  else if ( (marker_code & 0xFFFFFFF0) == 224 )
  {
    *((_DWORD *)&marker[-36] + marker_code - 1) = routine;
  }
  else
  {
    cinfo->err->msg_code = 68;
    cinfo->err->msg_parm.i[0] = marker_code;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
}

//----- (0047F3AA) --------------------------------------------------------
boolean __fastcall get_sof(j_decompress_ptr cinfo, boolean is_prog, boolean is_arith)
{
  jpeg_source_mgr *src; // r10
  size_t bytes_in_buffer; // r0
  const JOCTET *next_input_byte; // r6
  const JOCTET *v7; // r6
  int v8; // r8
  int v9; // t1
  size_t v10; // r0
  const JOCTET *v11; // r6
  int v12; // r9
  int v13; // t1
  size_t v14; // r0
  const JOCTET *v15; // r6
  int v16; // t1
  size_t v17; // r0
  const JOCTET *v18; // r6
  int v19; // t1
  size_t v20; // r0
  JDIMENSION image_height; // r1
  const JOCTET *v22; // r6
  int v23; // t1
  size_t v24; // r0
  const JOCTET *v25; // r6
  int v26; // t1
  size_t v27; // r0
  JDIMENSION image_width; // r1
  const JOCTET *v29; // r6
  int v30; // t1
  size_t v31; // r5
  jpeg_error_mgr *err; // r0
  int unread_marker; // r1
  JDIMENSION v34; // r0
  bool v35; // zf
  int num_components; // r0
  jpeg_component_info *comp_info; // r0
  const JOCTET *v38; // r4
  size_t v39; // r1
  int *p_h_samp_factor; // r6
  int v41; // r5
  const JOCTET *v42; // r4
  int v43; // t1
  size_t v44; // r0
  const JOCTET *v45; // r4
  unsigned int v46; // t1
  size_t v47; // r9
  int v48; // t1
  jpeg_error_mgr *v49; // r0
  boolean result; // r0

  src = cinfo->src;
  bytes_in_buffer = src->bytes_in_buffer;
  next_input_byte = src->next_input_byte;
  cinfo->progressive_mode = is_prog;
  cinfo->arith_code = is_arith;
  if ( !bytes_in_buffer )
  {
    if ( !((int (__fastcall *)(j_decompress_ptr))src->fill_input_buffer)(cinfo) )
      return 0;
    bytes_in_buffer = src->bytes_in_buffer;
    next_input_byte = src->next_input_byte;
  }
  v9 = *next_input_byte;
  v7 = next_input_byte + 1;
  v8 = v9;
  v10 = bytes_in_buffer - 1;
  if ( !v10 )
  {
    if ( !((int (__fastcall *)(j_decompress_ptr))src->fill_input_buffer)(cinfo) )
      return 0;
    v10 = src->bytes_in_buffer;
    v7 = src->next_input_byte;
  }
  v13 = *v7;
  v11 = v7 + 1;
  v12 = v13;
  v14 = v10 - 1;
  if ( !v14 )
  {
    if ( !((int (__fastcall *)(j_decompress_ptr))src->fill_input_buffer)(cinfo) )
      return 0;
    v14 = src->bytes_in_buffer;
    v11 = src->next_input_byte;
  }
  v16 = *v11;
  v15 = v11 + 1;
  v17 = v14 - 1;
  cinfo->data_precision = v16;
  if ( !v17 )
  {
    if ( !((int (__fastcall *)(j_decompress_ptr))src->fill_input_buffer)(cinfo) )
      return 0;
    v17 = src->bytes_in_buffer;
    v15 = src->next_input_byte;
  }
  v19 = *v15;
  v18 = v15 + 1;
  v20 = v17 - 1;
  image_height = v19 << 8;
  cinfo->image_height = v19 << 8;
  if ( !v20 )
  {
    if ( !((int (__fastcall *)(j_decompress_ptr))src->fill_input_buffer)(cinfo) )
      return 0;
    v20 = src->bytes_in_buffer;
    v18 = src->next_input_byte;
    image_height = cinfo->image_height;
  }
  v23 = *v18;
  v22 = v18 + 1;
  v24 = v20 - 1;
  cinfo->image_height = image_height + v23;
  if ( !v24 )
  {
    if ( !((int (__fastcall *)(j_decompress_ptr))src->fill_input_buffer)(cinfo) )
      return 0;
    v24 = src->bytes_in_buffer;
    v22 = src->next_input_byte;
  }
  v26 = *v22;
  v25 = v22 + 1;
  v27 = v24 - 1;
  image_width = v26 << 8;
  cinfo->image_width = v26 << 8;
  if ( !v27 )
  {
    if ( !((int (__fastcall *)(j_decompress_ptr))src->fill_input_buffer)(cinfo) )
      return 0;
    v27 = src->bytes_in_buffer;
    v25 = src->next_input_byte;
    image_width = cinfo->image_width;
  }
  v30 = *v25;
  v29 = v25 + 1;
  v31 = v27 - 1;
  cinfo->image_width = image_width + v30;
  if ( v27 == 1 )
  {
    if ( ((int (__fastcall *)(j_decompress_ptr))src->fill_input_buffer)(cinfo) )
    {
      v31 = src->bytes_in_buffer;
      v29 = src->next_input_byte;
      goto LABEL_25;
    }
    return 0;
  }
LABEL_25:
  err = cinfo->err;
  unread_marker = cinfo->unread_marker;
  cinfo->num_components = *v29;
  err->msg_parm.i[0] = unread_marker;
  err->msg_parm.i[1] = cinfo->image_width;
  err->msg_parm.i[2] = cinfo->image_height;
  err->msg_parm.i[3] = cinfo->num_components;
  cinfo->err->msg_code = 100;
  cinfo->err->emit_message((j_common_ptr)cinfo, 1);
  if ( cinfo->marker->saw_SOF )
  {
    cinfo->err->msg_code = 58;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  v34 = cinfo->image_height;
  v35 = v34 == 0;
  if ( v34 )
    v35 = cinfo->image_width == 0;
  if ( v35 || (num_components = cinfo->num_components, num_components <= 0) )
  {
    cinfo->err->msg_code = 32;
    cinfo->err->error_exit((j_common_ptr)cinfo);
    num_components = cinfo->num_components;
  }
  if ( ((v8 << 8) | v12) - 8 != 3 * num_components )
  {
    cinfo->err->msg_code = 11;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  comp_info = cinfo->comp_info;
  if ( !comp_info )
  {
    comp_info = (jpeg_component_info *)cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 84 * cinfo->num_components);
    cinfo->comp_info = comp_info;
  }
  v38 = v29 + 1;
  v39 = v31 - 1;
  if ( cinfo->num_components >= 1 )
  {
    p_h_samp_factor = &comp_info->h_samp_factor;
    v41 = 0;
    do
    {
      *(p_h_samp_factor - 1) = v41;
      if ( !v39 )
      {
        if ( !((int (__fastcall *)(j_decompress_ptr))src->fill_input_buffer)(cinfo) )
          return 0;
        v39 = src->bytes_in_buffer;
        v38 = src->next_input_byte;
      }
      v43 = *v38;
      v42 = v38 + 1;
      *(p_h_samp_factor - 2) = v43;
      v44 = v39 - 1;
      if ( v39 == 1 )
      {
        if ( !((int (__fastcall *)(j_decompress_ptr))src->fill_input_buffer)(cinfo) )
          return 0;
        v44 = src->bytes_in_buffer;
        v42 = src->next_input_byte;
      }
      v46 = *v42;
      v45 = v42 + 1;
      v47 = v44 - 1;
      *p_h_samp_factor = v46 >> 4;
      p_h_samp_factor[1] = v46 & 0xF;
      if ( v44 == 1 )
      {
        if ( !((int (__fastcall *)(j_decompress_ptr))src->fill_input_buffer)(cinfo) )
          return 0;
        v47 = src->bytes_in_buffer;
        v45 = src->next_input_byte;
      }
      v48 = *v45;
      v38 = v45 + 1;
      p_h_samp_factor[2] = v48;
      v49 = cinfo->err;
      v49->msg_parm.i[0] = *(p_h_samp_factor - 2);
      v49->msg_parm.i[1] = *p_h_samp_factor;
      v49->msg_parm.i[2] = p_h_samp_factor[1];
      v49->msg_parm.i[3] = p_h_samp_factor[2];
      cinfo->err->msg_code = 101;
      cinfo->err->emit_message((j_common_ptr)cinfo, 1);
      ++v41;
      p_h_samp_factor += 21;
      v39 = v47 - 1;
    }
    while ( v41 < cinfo->num_components );
  }
  result = 1;
  cinfo->marker->saw_SOF = 1;
  src->next_input_byte = v38;
  src->bytes_in_buffer = v39;
  return result;
}

//----- (0047F640) --------------------------------------------------------
void __fastcall jpeg_calc_output_dimensions(j_decompress_ptr cinfo)
{
  J_COLOR_SPACE out_color_space; // r2
  int quantize_colors; // r3
  int *p_num_components; // r1
  __int64 v5; // r0

  if ( cinfo->global_state != 202 )
  {
    cinfo->err->msg_code = 20;
    cinfo->err->msg_parm.i[0] = cinfo->global_state;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  out_color_space = cinfo->out_color_space;
  quantize_colors = cinfo->quantize_colors;
  *(_QWORD *)&cinfo->output_width = *(_QWORD *)&cinfo->image_width;
  p_num_components = &cinfo->num_components;
  if ( (unsigned int)(out_color_space - 1) < 5 )
    p_num_components = (int *)((char *)&unk_61D2F0 + 4 * out_color_space - 4);
  LODWORD(v5) = *p_num_components;
  HIDWORD(v5) = 1;
  cinfo->out_color_components = v5;
  if ( quantize_colors )
    LODWORD(v5) = 1;
  *(_QWORD *)&cinfo->output_components = v5;
}

//----- (0047F6A0) --------------------------------------------------------
void __fastcall jinit_master_decompress(j_decompress_ptr cinfo)
{
  jpeg_decomp_master *v2; // r0
  jpeg_decomp_master *master; // r9
  jpeg_memory_mgr *mem; // r0
  J_COLOR_SPACE out_color_space; // r3
  int quantize_colors; // r5
  int *p_num_components; // r2
  int v8; // r1
  int v9; // r2
  int v10; // r5
  boolean *p_raw_data_out; // r5
  jpeg_error_mgr *err; // r0
  int v13; // r1
  bool v14; // r1
  boolean buffered_image; // r1

  v2 = (jpeg_decomp_master *)cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 28);
  cinfo->master = v2;
  v2->is_dummy_pass = 0;
  v2->prepare_for_output_pass = prepare_for_output_pass;
  v2->finish_output_pass = finish_output_pass;
  master = cinfo->master;
  if ( cinfo->global_state != 202 )
  {
    cinfo->err->msg_code = 20;
    cinfo->err->msg_parm.i[0] = cinfo->global_state;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  mem = cinfo->mem;
  out_color_space = cinfo->out_color_space;
  quantize_colors = cinfo->quantize_colors;
  *(_QWORD *)&cinfo->output_width = *(_QWORD *)&cinfo->image_width;
  p_num_components = &cinfo->num_components;
  if ( (unsigned int)(out_color_space - 1) < 5 )
    p_num_components = (int *)((char *)&unk_61D2F0 + 4 * out_color_space - 4);
  v8 = *p_num_components;
  v9 = 1;
  if ( !quantize_colors )
    v9 = v8;
  cinfo->out_color_components = v8;
  cinfo->output_components = v9;
  cinfo->rec_outbuf_height = 1;
  v10 = (int)mem->alloc_small((j_common_ptr)cinfo, 1, 1408);
  cinfo->sample_range_limit = (JSAMPLE *)(v10 + 256);
  memset((void *)v10, 0, 0x100u);
  *(_QWORD *)(v10 + 272) = 0x1716151413121110LL;
  *(_QWORD *)(v10 + 280) = 0x1F1E1D1C1B1A1918LL;
  *(_QWORD *)(v10 + 256) = 0x706050403020100LL;
  *(_QWORD *)(v10 + 264) = 0xF0E0D0C0B0A0908LL;
  qmemcpy(
    (void *)(v10 + 288),
    " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvw",
    88);
  *(_QWORD *)(v10 + 376) = unk_47F9B8;
  *(_QWORD *)(v10 + 384) = 0x8786858483828180LL;
  *(_QWORD *)(v10 + 392) = 0x8F8E8D8C8B8A8988LL;
  *(_QWORD *)(v10 + 400) = 0x9796959493929190LL;
  *(_QWORD *)(v10 + 408) = 0x9F9E9D9C9B9A9998LL;
  *(_QWORD *)(v10 + 416) = 0xA7A6A5A4A3A2A1A0LL;
  *(_QWORD *)(v10 + 424) = 0xAFAEADACABAAA9A8LL;
  *(_QWORD *)(v10 + 432) = unk_47F9F0;
  *(_QWORD *)(v10 + 440) = unk_47F9F8;
  *(_QWORD *)(v10 + 448) = 0xC7C6C5C4C3C2C1C0LL;
  *(_QWORD *)(v10 + 456) = 0xCFCECDCCCBCAC9C8LL;
  *(_QWORD *)(v10 + 464) = 0xD7D6D5D4D3D2D1D0LL;
  *(_QWORD *)(v10 + 472) = 0xDFDEDDDCDBDAD9D8LL;
  *(_QWORD *)(v10 + 480) = loc_47FA20;
  *(_QWORD *)(v10 + 488) = 0xEFEEEDECEBEAE9E8LL;
  *(_QWORD *)(v10 + 496) = 0xF7F6F5F4F3F2F1F0LL;
  *(_QWORD *)(v10 + 504) = 0xFFFEFDFCFBFAF9F8LL;
  memset((void *)(v10 + 512), 255, 0x180u);
  memset((void *)(v10 + 896), 0, 0x180u);
  qmemcpy((void *)(v10 + 1280), cinfo->sample_range_limit, 0x80u);
  master[1].prepare_for_output_pass = 0;
  LOBYTE(master[1].finish_output_pass) = 0;
  *(_DWORD *)&master[1].is_dummy_pass = 0;
  master[2].prepare_for_output_pass = 0;
  if ( cinfo->quantize_colors )
  {
    if ( !cinfo->buffered_image )
    {
      cinfo->enable_2pass_quant = 0;
      *(_WORD *)&cinfo->enable_1pass_quant = 0;
    }
    p_raw_data_out = &cinfo->raw_data_out;
    if ( cinfo->raw_data_out )
    {
      cinfo->err->msg_code = 47;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    if ( cinfo->out_color_components == 3 )
    {
      if ( cinfo->colormap )
      {
        cinfo->enable_external_quant = 1;
      }
      else if ( cinfo->two_pass_quantize )
      {
        cinfo->enable_2pass_quant = 1;
      }
      else
      {
        cinfo->enable_1pass_quant = 1;
      }
    }
    else
    {
      cinfo->enable_2pass_quant = 0;
      *(_WORD *)&cinfo->enable_1pass_quant = 1;
      cinfo->colormap = 0;
    }
    if ( cinfo->enable_1pass_quant )
    {
      cinfo->err->msg_code = 48;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    if ( *(_WORD *)&cinfo->enable_external_quant )
    {
      cinfo->err->msg_code = 48;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
  }
  else
  {
    p_raw_data_out = &cinfo->raw_data_out;
    cinfo->enable_2pass_quant = 0;
    *(_WORD *)&cinfo->enable_1pass_quant = 0;
  }
  if ( !*p_raw_data_out )
  {
    if ( LOBYTE(master[1].finish_output_pass) )
    {
      cinfo->err->msg_code = 48;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    else
    {
      jinit_color_deconverter(cinfo);
      jinit_upsampler(cinfo);
    }
    jinit_d_post_controller(cinfo, cinfo->enable_2pass_quant);
  }
  jinit_inverse_dct(cinfo);
  if ( cinfo->arith_code )
  {
    err = cinfo->err;
    v13 = 1;
LABEL_33:
    err->msg_code = v13;
    cinfo->err->error_exit((j_common_ptr)cinfo);
    goto LABEL_34;
  }
  if ( cinfo->progressive_mode )
  {
    err = cinfo->err;
    v13 = 48;
    goto LABEL_33;
  }
  jinit_huff_decoder(cinfo);
LABEL_34:
  if ( cinfo->inputctl->has_multiple_scans )
  {
    v14 = 1;
  }
  else
  {
    buffered_image = cinfo->buffered_image;
    v14 = buffered_image != 0;
  }
  jinit_d_coef_controller(cinfo, v14);
  if ( !*p_raw_data_out )
    jinit_d_main_controller(cinfo, 0);
  cinfo->mem->realize_virt_arrays((j_common_ptr)cinfo);
  cinfo->inputctl->start_input_pass(cinfo);
}

//----- (0047FAAC) --------------------------------------------------------
void __fastcall prepare_for_output_pass(j_decompress_ptr cinfo)
{
  jpeg_decomp_master *master; // r5
  bool v3; // zf
  jpeg_progress_mgr *progress; // r0
  int v5; // r3
  int v6; // r3

  master = cinfo->master;
  if ( master->is_dummy_pass )
  {
    cinfo->err->msg_code = 48;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  else
  {
    if ( cinfo->quantize_colors && !cinfo->colormap )
    {
      v3 = cinfo->two_pass_quantize == 0;
      if ( cinfo->two_pass_quantize )
        v3 = cinfo->enable_2pass_quant == 0;
      if ( v3 )
      {
        if ( cinfo->enable_1pass_quant )
        {
          cinfo->cquantize = *(jpeg_color_quantizer **)&master[1].is_dummy_pass;
        }
        else
        {
          cinfo->err->msg_code = 46;
          cinfo->err->error_exit((j_common_ptr)cinfo);
        }
      }
      else
      {
        cinfo->cquantize = (jpeg_color_quantizer *)master[2].prepare_for_output_pass;
        master->is_dummy_pass = 1;
      }
    }
    cinfo->idct->start_pass(cinfo);
    cinfo->coef->start_output_pass(cinfo);
    if ( !cinfo->raw_data_out )
    {
      if ( !LOBYTE(master[1].finish_output_pass) )
        cinfo->cconvert->start_pass(cinfo);
      cinfo->upsample->start_pass(cinfo);
      if ( cinfo->quantize_colors )
        cinfo->cquantize->start_pass(cinfo, master->is_dummy_pass);
      ((void (__fastcall *)(j_decompress_ptr))cinfo->post->start_pass)(cinfo);
      cinfo->main->start_pass(cinfo, JBUF_PASS_THRU);
    }
  }
  progress = cinfo->progress;
  if ( progress )
  {
    v5 = 1;
    progress->completed_passes = (int)master[1].prepare_for_output_pass;
    if ( master->is_dummy_pass )
      v5 = 2;
    cinfo->progress->total_passes = (int)master[1].prepare_for_output_pass + v5;
    if ( cinfo->buffered_image && !cinfo->inputctl->eoi_reached )
    {
      v6 = 1;
      if ( cinfo->enable_2pass_quant )
        v6 = 2;
      cinfo->progress->total_passes += v6;
    }
  }
}

//----- (0047FBB0) --------------------------------------------------------
void __fastcall finish_output_pass(j_decompress_ptr cinfo)
{
  jpeg_decomp_master *master; // r4

  master = cinfo->master;
  if ( cinfo->quantize_colors )
    ((void (*)(void))cinfo->cquantize->finish_pass)();
  ++master[1].prepare_for_output_pass;
}

//----- (0047FBD0) --------------------------------------------------------
void __fastcall jinit_d_post_controller(j_decompress_ptr cinfo, boolean need_full_buffer)
{
  int v3; // r6
  jpeg_d_post_controller *v4; // r5

  v3 = need_full_buffer;
  v4 = (jpeg_d_post_controller *)cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 28);
  cinfo->post = v4;
  v4->start_pass = start_pass_dpost;
  v4[1].start_pass = 0;
  v4[1].post_process_data = 0;
  if ( cinfo->quantize_colors )
  {
    v4[2].start_pass = (void (*)(j_decompress_ptr, J_BUF_MODE))cinfo->max_v_samp_factor;
    if ( v3 )
    {
      cinfo->err->msg_code = 4;
      cinfo->err->error_exit((j_common_ptr)cinfo);
    }
    else
    {
      v4[1].post_process_data = (void (*)(j_decompress_ptr, JSAMPIMAGE, JDIMENSION *, JDIMENSION, JSAMPARRAY, JDIMENSION *, JDIMENSION))((int (__fastcall *)(j_decompress_ptr, int, JDIMENSION))cinfo->mem->alloc_sarray)(cinfo, 1, cinfo->out_color_components * cinfo->output_width);
    }
  }
}

//----- (0047FC3C) --------------------------------------------------------
void __fastcall start_pass_dpost(j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
{
  jpeg_d_post_controller *post; // r4
  void (*post_process_data)(j_decompress_ptr, JSAMPIMAGE, JDIMENSION *, JDIMENSION, JSAMPARRAY, JDIMENSION *, JDIMENSION); // r2

  post = cinfo->post;
  if ( pass_mode )
  {
    cinfo->err->msg_code = 4;
    cinfo->err->error_exit((j_common_ptr)cinfo);
  }
  else if ( cinfo->quantize_colors )
  {
    post_process_data = post[1].post_process_data;
    post->post_process_data = post_process_1pass;
    if ( !post_process_data )
      post[1].post_process_data = (void (*)(j_decompress_ptr, JSAMPIMAGE, JDIMENSION *, JDIMENSION, JSAMPARRAY, JDIMENSION *, JDIMENSION))cinfo->mem->access_virt_sarray(cinfo, post[1].start_pass, 0, post[2].start_pass, 1);
  }
  else
  {
    post->post_process_data = cinfo->upsample->upsample;
  }
  post[2].post_process_data = 0;
  post[3].start_pass = 0;
}

//----- (0047FC94) --------------------------------------------------------
void __fastcall post_process_1pass(
        j_decompress_ptr cinfo,
        JSAMPIMAGE input_buf,
        JDIMENSION *in_row_group_ctr,
        JDIMENSION in_row_groups_avail,
        JSAMPARRAY output_buf,
        JDIMENSION *out_row_ctr,
        JDIMENSION out_rows_avail)
{
  jpeg_d_post_controller *post; // r6
  JDIMENSION v9; // r9
  __int64 v10; // kr00_8
  JDIMENSION v11; // r0
  int v12[7]; // [sp+Ch] [bp-1Ch] BYREF

  post = cinfo->post;
  v9 = *out_row_ctr;
  v10 = *(_QWORD *)&post[1].post_process_data;
  v12[0] = 0;
  v11 = out_rows_avail - v9;
  if ( out_rows_avail - v9 > HIDWORD(v10) )
    v11 = HIDWORD(v10);
  cinfo->upsample->upsample(
    cinfo,
    input_buf,
    in_row_group_ctr,
    in_row_groups_avail,
    (JSAMPARRAY)v10,
    (JDIMENSION *)v12,
    v11);
  cinfo->cquantize->color_quantize(cinfo, (JSAMPARRAY)post[1].post_process_data, &output_buf[*out_row_ctr], v12[0]);
  *out_row_ctr += v12[0];
}
// 47FC94: using guessed type int var_1C[7];

//----- (0047FD04) --------------------------------------------------------
void __fastcall jinit_upsampler(j_decompress_ptr cinfo)
{
  j_decompress_ptr v1; // r6
  int v2; // r0
  int v3; // r1
  int v4; // r8
  int p_DCT_scaled_size; // r11
  bool v6; // zf
  int v7; // r4
  int v8; // r5
  __int64 v9; // kr00_8
  __int64 v10; // kr08_8
  int min_DCT_scaled_size; // r6
  int v12; // r2
  int v13; // r0
  int v14; // r4
  int v15; // r0
  bool v16; // zf
  bool v17; // zf
  void (__fastcall *v18)(j_decompress_ptr, jpeg_component_info *, JSAMPARRAY, JSAMPARRAY *); // r0
  JSAMPARRAY (*alloc_sarray)(j_common_ptr, int, JDIMENSION, JDIMENSION); // r5
  int v20; // r0
  int v21; // [sp+4h] [bp-2Ch]
  jpeg_decompress_struct *v22; // [sp+8h] [bp-28h]
  int v23; // [sp+Ch] [bp-24h]
  int v24; // [sp+10h] [bp-20h]

  v1 = cinfo;
  v2 = cinfo->mem->alloc_small((j_common_ptr)cinfo, 1, 76);
  v1->upsample = (jpeg_upsampler *)v2;
  *(_DWORD *)v2 = start_pass_upsample;
  *(_DWORD *)(v2 + 4) = sep_upsample;
  v23 = v2;
  *(_BYTE *)(v2 + 8) = 0;
  if ( v1->CCIR601_sampling )
  {
    v1->err->msg_code = 25;
    v1->err->error_exit((j_common_ptr)v1);
  }
  v3 = 0;
  if ( v1->do_fancy_upsampling )
  {
    if ( v1->min_DCT_scaled_size > 1 )
      v3 = 1;
    v21 = v3;
  }
  else
  {
    v21 = 0;
  }
  if ( v1->num_components >= 1 )
  {
    v4 = 0;
    v22 = v1;
    p_DCT_scaled_size = (int)&v1->comp_info->DCT_scaled_size;
    do
    {
      v9 = *(_QWORD *)(p_DCT_scaled_size - 28);
      v10 = *(_QWORD *)&v1->max_h_samp_factor;
      min_DCT_scaled_size = v1->min_DCT_scaled_size;
      v12 = HIDWORD(v9) * *(_DWORD *)p_DCT_scaled_size / min_DCT_scaled_size;
      v13 = *(_DWORD *)p_DCT_scaled_size * v9;
      v14 = v23 + 4 * v4;
      *(_DWORD *)(v14 + 52) = v12;
      v15 = v13 / min_DCT_scaled_size;
      if ( *(_BYTE *)(p_DCT_scaled_size + 12) )
      {
        v16 = v15 == (_DWORD)v10;
        v24 = v23 + 4 * v4;
        if ( v15 == (_DWORD)v10 )
          v16 = v12 == HIDWORD(v10);
        if ( v16 )
        {
          *(_DWORD *)(v24 + 28) = fullsize_upsample;
          v1 = v22;
        }
        else
        {
          v17 = (_DWORD)v10 == 2 * v15;
          if ( (_DWORD)v10 == 2 * v15 )
            v17 = v12 == HIDWORD(v10);
          if ( v17 )
          {
            v1 = v22;
            if ( v21 != 1 || (v18 = h2v1_fancy_upsample, *(_DWORD *)(p_DCT_scaled_size + 4) <= 2u) )
              v18 = h2v1_upsample;
            v7 = v23 + 4 * v4;
            *(_DWORD *)(v24 + 28) = v18;
          }
          else
          {
            v6 = 2 * v15 == (_DWORD)v10;
            if ( 2 * v15 == (_DWORD)v10 )
              v6 = 2 * v12 == HIDWORD(v10);
            if ( v6 )
            {
              if ( v21 == 1 && *(_DWORD *)(p_DCT_scaled_size + 4) >= 3u )
              {
                v7 = v23 + 4 * v4;
                *(_DWORD *)(v24 + 28) = h2v2_fancy_upsample;
                *(_BYTE *)(v23 + 8) = 1;
                v1 = v22;
              }
              else
              {
                v7 = v23 + 4 * v4;
                *(_DWORD *)(v24 + 28) = h2v2_upsample;
                v1 = v22;
              }
            }
            else if ( (int)v10 % v15 || SHIDWORD(v10) % v12 )
            {
              v1 = v22;
              v22->err->msg_code = 38;
              v22->err->error_exit((j_common_ptr)v22);
              v7 = v23 + 4 * v4;
            }
            else
            {
              *(_DWORD *)(v24 + 28) = int_upsample;
              v8 = v23 + v4;
              v7 = v23 + 4 * v4;
              *(_BYTE *)(v8 + 72) = SHIDWORD(v10) / v12;
              *(_BYTE *)(v8 + 68) = (int)v10 / v15;
              v1 = v22;
            }
          }
          alloc_sarray = v1->mem->alloc_sarray;
          v20 = jround_up(v1->output_width, v1->max_h_samp_factor);
          *(_DWORD *)(v7 + 12) = alloc_sarray((j_common_ptr)v1, 1, v20, v1->max_v_samp_factor);
        }
      }
      else
      {
        *(_DWORD *)(v14 + 28) = noop_upsample;
        v1 = v22;
      }
      ++v4;
      p_DCT_scaled_size += 84;
    }
    while ( v4 < v1->num_components );
  }
}

//----- (0047FEE4) --------------------------------------------------------
void __fastcall start_pass_upsample(j_decompress_ptr cinfo)
{
  jpeg_upsampler *upsample; // r2

  upsample = cinfo->upsample;
  *(_DWORD *)&upsample[3].need_context_rows = cinfo->max_v_samp_factor;
  upsample[4].start_pass = (void (*)(j_decompress_ptr))cinfo->output_height;
}

//----- (0047FEF4) --------------------------------------------------------
void __fastcall sep_upsample(
        j_decompress_ptr cinfo,
        JSAMPIMAGE input_buf,
        JDIMENSION *in_row_group_ctr,
        JDIMENSION in_row_groups_avail,
        int a5,
        int *a6,
        int a7)
{
  jpeg_upsampler *upsample; // r5
  int max_v_samp_factor; // r0
  int *v12; // r10
  int v13; // r2
  int v14; // lr
  int v15; // r10
  jpeg_component_info *comp_info; // r4
  void (**p_upsample)(j_decompress_ptr, JSAMPIMAGE, JDIMENSION *, JDIMENSION, JSAMPARRAY, JDIMENSION *, JDIMENSION); // r11
  int v18; // t1
  int v19; // r0
  unsigned int start_pass; // r4
  int v21; // r1
  __int64 v22; // r0

  upsample = cinfo->upsample;
  max_v_samp_factor = cinfo->max_v_samp_factor;
  v12 = a6;
  v13 = *(_DWORD *)&upsample[3].need_context_rows;
  v14 = a7;
  if ( v13 >= max_v_samp_factor )
  {
    if ( cinfo->num_components >= 1 )
    {
      v15 = 13;
      comp_info = cinfo->comp_info;
      p_upsample = &upsample[2].upsample;
      do
      {
        v18 = (int)*input_buf++;
        ((void (__fastcall *)(j_decompress_ptr, jpeg_component_info *, JDIMENSION, char *))*p_upsample)(
          cinfo,
          comp_info,
          v18 + 4 * (_DWORD)p_upsample[6] * *in_row_group_ctr,
          (char *)p_upsample - 16);
        v19 = v15 - 12;
        ++p_upsample;
        ++v15;
        ++comp_info;
      }
      while ( v19 < cinfo->num_components );
    }
    v13 = 0;
    v14 = a7;
    *(_DWORD *)&upsample[3].need_context_rows = 0;
    max_v_samp_factor = cinfo->max_v_samp_factor;
    v12 = a6;
  }
  start_pass = max_v_samp_factor - v13;
  v21 = *v12;
  if ( (char *)(max_v_samp_factor - v13) > (char *)upsample[4].start_pass )
    start_pass = (unsigned int)upsample[4].start_pass;
  if ( start_pass > v14 - v21 )
    start_pass = v14 - v21;
  ((void (__fastcall *)(j_decompress_ptr, jpeg_upsampler *))cinfo->cconvert->color_convert)(cinfo, &upsample[1]);
  *v12 += start_pass;
  v22 = *(_QWORD *)&upsample[3].need_context_rows;
  HIDWORD(v22) -= start_pass;
  LODWORD(v22) = v22 + start_pass;
  *(_QWORD *)&upsample[3].need_context_rows = v22;
  if ( (int)v22 >= cinfo->max_v_samp_factor )
    ++*in_row_group_ctr;
}

//----- (0047FFD6) --------------------------------------------------------
void __fastcall noop_upsample(
        j_decompress_ptr cinfo,
        jpeg_component_info *compptr,
        JSAMPARRAY input_data,
        JSAMPARRAY *output_data_ptr)
{
  *output_data_ptr = 0;
}

//----- (0047FFDC) --------------------------------------------------------
void __fastcall fullsize_upsample(
        j_decompress_ptr cinfo,
        jpeg_component_info *compptr,
        JSAMPARRAY input_data,
        JSAMPARRAY *output_data_ptr)
{
  *output_data_ptr = input_data;
}

//----- (0047FFE0) --------------------------------------------------------
void __fastcall h2v1_fancy_upsample(
        j_decompress_ptr cinfo,
        jpeg_component_info *compptr,
        JSAMPARRAY input_data,
        JSAMPARRAY *output_data_ptr)
{
  JSAMPARRAY v4; // r12
  int16x8_t v5; // q9
  int v6; // r9
  int16x8_t v7; // q10
  JSAMPROW v8; // r8
  JSAMPROW v9; // lr
  int v10; // r0
  char *v11; // r5
  unsigned __int8 *v12; // r4
  JDIMENSION downsampled_width; // r2
  unsigned int v14; // r3
  unsigned int v15; // r10
  bool v16; // cf
  JSAMPROW v17; // r11
  unsigned int v18; // r12
  char *v19; // r6
  unsigned int v20; // r1
  unsigned int v21; // r0
  uint8x8_t *v22; // r3
  uint8x8_t v23; // d23
  uint16x8_t v24; // q12
  uint8x8_t v25; // d30
  uint8x8_t v26; // d31
  uint16x8_t v27; // q11
  uint16x8_t v28; // q13
  uint16x8_t v29; // q14
  jpeg_component_info *v30; // r8
  JSAMPARRAY v31; // r10
  char *v32; // r0
  int v33; // r3
  int v34; // t1
  int v35; // r2
  jpeg_component_info *v37; // [sp+4h] [bp-38h]
  JSAMPARRAY v38; // [sp+Ch] [bp-30h]
  int v40; // [sp+14h] [bp-28h]
  unsigned __int8 *v41; // [sp+18h] [bp-24h]
  int8x8x4_t v42; // 0:d0.8,8:d1.8,16:d2.8,24:d3.8

  v4 = input_data;
  if ( cinfo->max_v_samp_factor >= 1 )
  {
    v5.n128_u64[0] = 0x2000200020002LL;
    v5.n128_u64[1] = 0x2000200020002LL;
    v6 = 0;
    v7.n128_u64[0] = 0x1000100010001LL;
    v7.n128_u64[1] = 0x1000100010001LL;
    v38 = *output_data_ptr;
    v37 = compptr;
    while ( 1 )
    {
      v8 = v4[v6];
      v9 = v38[v6];
      v10 = *v8;
      v11 = (char *)(v9 + 2);
      *v9 = v10;
      v12 = v8 + 1;
      v9[1] = (3 * v10 + (unsigned int)v8[1] + 2) >> 2;
      downsampled_width = compptr->downsampled_width;
      v14 = downsampled_width - 2;
      if ( downsampled_width != 2 )
        break;
LABEL_17:
      v35 = *v12;
      ++v6;
      *v11 = ((unsigned int)*(v12 - 1) + 3 * v35 + 1) >> 2;
      v9[3] = v35;
      if ( v6 >= cinfo->max_v_samp_factor )
        return;
    }
    v40 = 2 * downsampled_width;
    v41 = v8 - 1;
    if ( v14 < 0x10 )
      goto LABEL_14;
    v15 = v14 & 0xFFFFFFF0;
    if ( (v14 & 0xFFFFFFF0) == 0 )
      goto LABEL_14;
    v16 = v11 >= (char *)&v8[downsampled_width];
    if ( v11 < (char *)&v8[downsampled_width] )
      v16 = v8 >= &v9[2 * downsampled_width - 2];
    if ( v16 )
    {
      v12 += v15;
      v17 = &v9[2 * v15];
      v18 = v14 - v15;
      v19 = &v11[2 * v15];
      v20 = v14 & 0xFFFFFFF0;
      v21 = v14 & 0xFFFFFFF0;
      do
      {
        v22 = (uint8x8_t *)(v8 + 2);
        v23.n64_u64[0] = *(unsigned __int64 *)(v8 + 9);
        v21 -= 16;
        v24 = vmovl_u8(*(uint8x8_t *)(v8 + 1));
        v25.n64_u64[0] = *(unsigned __int64 *)v8;
        v26.n64_u64[0] = (unsigned __int64)*((uint8x8_t *)v8 + 1);
        v8 += 16;
        v27 = vmovl_u8(v23);
        *(int16x4_t *)&v28.n128_i8[8] = vmovn_s32(vmull_u16(*(uint16x4_t *)&v24.n128_i8[8], (uint16x4_t)0x3000300030003LL));
        *(int16x4_t *)&v29.n128_i8[8] = vmovn_s32(vmull_u16(*(uint16x4_t *)&v27.n128_i8[8], (uint16x4_t)0x3000300030003LL));
        v29.n128_u64[0] = vmovn_s32(vmull_u16((uint16x4_t)v27.n128_u64[0], (uint16x4_t)0x3000300030003LL)).n64_u64[0];
        v28.n128_u64[0] = vmovn_s32(vmull_u16((uint16x4_t)v24.n128_u64[0], (uint16x4_t)0x3000300030003LL)).n64_u64[0];
        v42.val[3] = vshrn_n_s16(vaddq_s16(vaddw_u8(v29, v22[1]), v5), 2u);
        v42.val[2] = vshrn_n_s16(vaddq_s16(vaddw_u8(v28, (uint8x8_t)v22->n64_u64[0]), v5), 2u);
        v42.val[1] = vshrn_n_s16(vaddq_s16(vaddw_u8(v29, v26), v7), 2u);
        v42.val[0] = vshrn_n_s16(vaddq_s16(vaddw_u8(v28, v25), v7), 2u);
        vst2q_s8(v11, v42);
        v11 += 32;
      }
      while ( v21 );
      v31 = input_data;
      v30 = v37;
      if ( downsampled_width - 2 == v20 )
        goto LABEL_16;
    }
    else
    {
LABEL_14:
      v31 = v4;
      v30 = compptr;
      v19 = (char *)(v9 + 2);
      v18 = downsampled_width - 2;
      v17 = v9;
    }
    do
    {
      v32 = v19;
      --v18;
      v33 = 3 * *v12;
      *v19 = ((unsigned int)*(v12 - 1) + v33 + 1) >> 2;
      v19 += 2;
      v34 = *++v12;
      v17[3] = (unsigned int)(v34 + v33 + 2) >> 2;
      v17 = (JSAMPROW)v32;
    }
    while ( v18 );
LABEL_16:
    v4 = v31;
    v11 = (char *)&v9[v40 - 2];
    v12 = &v41[downsampled_width];
    v9 = &v9[v40 - 4];
    compptr = v30;
    goto LABEL_17;
  }
}

//----- (0048018C) --------------------------------------------------------
void __fastcall h2v1_upsample(
        j_decompress_ptr cinfo,
        jpeg_component_info *compptr,
        JSAMPARRAY input_data,
        JSAMPARRAY *output_data_ptr)
{
  int max_v_samp_factor; // r1
  JSAMPARRAY v5; // lr
  int v6; // r8
  signed int output_width; // r4
  char *v8; // r3
  unsigned __int64 *v9; // r5
  unsigned int v10; // r11
  char *v11; // r4
  char *v12; // r1
  unsigned int v13; // r9
  unsigned int v14; // r10
  char *v15; // r1
  unsigned int v16; // r1
  unsigned int v17; // r6
  bool v18; // cf
  char *v19; // r4
  JSAMPROW v20; // r6
  unsigned int v21; // r1
  char v22; // t1
  int8x8x4_t v23; // 0:d16.8,8:d17.8,16:d18.8,24:d19.8

  max_v_samp_factor = cinfo->max_v_samp_factor;
  if ( max_v_samp_factor >= 1 )
  {
    v5 = *output_data_ptr;
    v6 = 0;
    while ( 1 )
    {
      output_width = cinfo->output_width;
      if ( output_width >= 1 )
        break;
LABEL_21:
      if ( ++v6 >= max_v_samp_factor )
        return;
    }
    v8 = (char *)v5[v6];
    v9 = (unsigned __int64 *)input_data[v6];
    v10 = (unsigned int)&v8[output_width];
    v11 = v8 + 2;
    v12 = v8 + 2;
    if ( v10 > (unsigned int)(v8 + 2) )
      v12 = (char *)v10;
    v13 = ((unsigned int)(v12 - v8 - 1) >> 1) + 1;
    if ( v13 < 0x10 )
      goto LABEL_18;
    v14 = v13 & 0xFFFFFFF0;
    if ( (v13 & 0xFFFFFFF0) == 0 )
      goto LABEL_18;
    v15 = v8 + 2;
    if ( v10 > (unsigned int)v11 )
      v15 = (char *)v10;
    v16 = v15 - v8 - 1;
    v17 = (unsigned int)v9 + (v16 >> 1) + 1;
    v18 = (unsigned int)v8 >= v17;
    if ( (unsigned int)v8 < v17 )
      v18 = v9 >= (unsigned __int64 *)&v11[v16 & 0xFFFFFFFE];
    if ( v18 )
    {
      v19 = &v8[2 * v14];
      v20 = (JSAMPROW)v9 + v14;
      v21 = v13 & 0xFFFFFFF0;
      do
      {
        v23.val[0].n64_u64[0] = *v9;
        v23.val[1].n64_u64[0] = v9[1];
        v9 += 2;
        v21 -= 16;
        *(_OWORD *)v23.val[2].n64_u64 = *(_OWORD *)v23.val[0].n64_u64;
        vst2q_s8(v8, v23);
        v8 += 32;
      }
      while ( v21 );
      if ( v13 == v14 )
        goto LABEL_20;
    }
    else
    {
LABEL_18:
      v20 = input_data[v6];
      v19 = (char *)v5[v6];
    }
    do
    {
      v22 = *v20++;
      v19[1] = v22;
      *v19 = v22;
      v19 += 2;
    }
    while ( (unsigned int)v19 < v10 );
LABEL_20:
    max_v_samp_factor = cinfo->max_v_samp_factor;
    goto LABEL_21;
  }
}

//----- (00480240) --------------------------------------------------------
void __fastcall h2v2_fancy_upsample(
        j_decompress_ptr cinfo,
        jpeg_component_info *compptr,
        JSAMPARRAY input_data,
        JSAMPARRAY *output_data_ptr)
{
  int v4; // r11
  int v5; // r1
  int v6; // r12
  JSAMPROW v7; // r9
  JSAMPROW v8; // r8
  JSAMPROW v9; // r5
  int v10; // r2
  int v11; // r6
  int v12; // r3
  int v13; // lr
  JSAMPLE *v14; // r6
  JDIMENSION downsampled_width; // r2
  unsigned __int8 *v16; // r1
  JDIMENSION v17; // r0
  unsigned __int8 *v18; // r9
  int v19; // r12
  int v20; // r5
  int v21; // r4
  int v22; // t1
  int v23; // r10
  int v24; // t1
  JSAMPLE *v25; // r0
  JSAMPROW v26; // r4
  JSAMPROW v27; // r5
  int v28; // r2
  int v29; // r6
  int v30; // r8
  JSAMPROW v31; // r9
  int v32; // r3
  JSAMPLE *v33; // r6
  JDIMENSION v34; // r2
  JDIMENSION v35; // r0
  int v36; // lr
  unsigned __int8 *v37; // r1
  unsigned __int8 *v38; // r2
  int v39; // r5
  int v40; // r12
  int v41; // t1
  int v42; // r4
  int v43; // t1
  unsigned int v44; // r3
  JSAMPARRAY v46; // [sp+Ch] [bp-2Ch]
  int v49; // [sp+18h] [bp-20h]
  int v50; // [sp+18h] [bp-20h]

  if ( cinfo->max_v_samp_factor >= 1 )
  {
    v4 = 0;
    v5 = 0;
    v46 = *output_data_ptr;
    do
    {
      v6 = v4 | 1;
      v7 = input_data[v5];
      v8 = v46[v4];
      v9 = input_data[v5 - 1];
      v10 = v7[1];
      v11 = v9[1];
      v12 = *v9 + 3 * *v7;
      *v8 = (unsigned int)(4 * v12 + 8) >> 4;
      v13 = 3 * v10 + v11;
      v14 = v8 + 2;
      v8[1] = (unsigned int)(3 * v12 + v13 + 7) >> 4;
      downsampled_width = compptr->downsampled_width;
      if ( downsampled_width == 2 )
      {
        v20 = v12;
      }
      else
      {
        v49 = v5;
        v16 = v7 + 2;
        v17 = 2 - downsampled_width;
        v18 = v9 + 2;
        v19 = 2 * downsampled_width;
        do
        {
          v20 = v13;
          v22 = *v16++;
          v21 = v22;
          v23 = 3 * v13;
          v24 = *v18++;
          ++v17;
          *v14 = (unsigned int)(v12 + 3 * v13 + 8) >> 4;
          v13 = 3 * v21 + v24;
          v12 = v20;
          v14[1] = (unsigned int)(v23 + v13 + 7) >> 4;
          v14 += 2;
        }
        while ( v17 );
        v5 = v49;
        v14 = &v8[v19 - 2];
        v25 = &v8[v19];
        v6 = v4 | 1;
        v8 = v25 - 4;
      }
      *v14 = (unsigned int)(3 * v13 + v20 + 8) >> 4;
      v8[3] = (unsigned int)(4 * v13 + 7) >> 4;
      v26 = input_data[v5++];
      v27 = input_data[v5];
      v28 = v26[1];
      v29 = v27[1];
      v30 = 3 * *v26 + *v27;
      v31 = v46[v6];
      *v31 = (unsigned int)(4 * v30 + 8) >> 4;
      v32 = 3 * v28 + v29;
      v33 = v31 + 2;
      v31[1] = (unsigned int)(3 * v30 + v32 + 7) >> 4;
      v34 = compptr->downsampled_width;
      if ( v34 == 2 )
      {
        v39 = v30;
      }
      else
      {
        v50 = v5;
        v35 = 2 - v34;
        v36 = 2 * v34;
        v37 = v26 + 2;
        v38 = v27 + 2;
        do
        {
          v39 = v32;
          v41 = *v37++;
          v40 = v41;
          v42 = 3 * v32;
          v43 = *v38++;
          ++v35;
          v44 = v30 + 3 * v32 + 8;
          v30 = v39;
          *v33 = v44 >> 4;
          v32 = 3 * v40 + v43;
          v33[1] = (unsigned int)(v42 + v32 + 7) >> 4;
          v33 += 2;
        }
        while ( v35 );
        v5 = v50;
        v33 = &v31[v36 - 2];
        v31 = &v31[v36 - 4];
      }
      v4 += 2;
      *v33 = (unsigned int)(3 * v32 + v39 + 8) >> 4;
      v31[3] = (unsigned int)(4 * v32 + 7) >> 4;
    }
    while ( v4 < cinfo->max_v_samp_factor );
  }
}

//----- (00480420) --------------------------------------------------------
void __fastcall h2v2_upsample(
        j_decompress_ptr cinfo,
        jpeg_component_info *compptr,
        JSAMPARRAY input_data,
        JSAMPARRAY *output_data_ptr)
{
  JSAMPROW *v6; // r11
  int v7; // r4
  int i; // r5
  signed int output_width; // r0
  char *v10; // r6
  unsigned __int64 *v11; // r2
  char *v12; // r1
  unsigned int v13; // r0
  char *v14; // r3
  unsigned int v15; // r12
  JSAMPROW v16; // r3
  char *v17; // r1
  JSAMPROW *v18; // r9
  unsigned int v19; // r8
  char *v20; // r3
  unsigned int v21; // lr
  unsigned int v22; // r3
  bool v23; // cf
  unsigned int v24; // lr
  bool v25; // zf
  char v26; // t1
  int8x8x4_t v27; // 0:d16.8,8:d17.8,16:d18.8,24:d19.8

  if ( cinfo->max_v_samp_factor >= 1 )
  {
    v6 = *output_data_ptr;
    v7 = 0;
    for ( i = 0; ; ++i )
    {
      output_width = cinfo->output_width;
      if ( output_width >= 1 )
        break;
LABEL_23:
      jcopy_sample_rows(v6, v7, v6, v7 | 1, 1, output_width);
      v7 += 2;
      if ( v7 >= cinfo->max_v_samp_factor )
        return;
    }
    v10 = (char *)v6[v7];
    v11 = (unsigned __int64 *)input_data[i];
    v12 = v10 + 2;
    v13 = (unsigned int)&v10[output_width];
    v14 = v10 + 2;
    if ( v13 > (unsigned int)(v10 + 2) )
      v14 = (char *)v13;
    v15 = ((unsigned int)(v14 - v10 - 1) >> 1) + 1;
    if ( v15 >= 0x10 )
    {
      v18 = input_data;
      v19 = v15 & 0xFFFFFFF0;
      if ( (v15 & 0xFFFFFFF0) == 0 )
        goto LABEL_20;
      v20 = v10 + 2;
      if ( v13 > (unsigned int)v12 )
        v20 = (char *)v13;
      v21 = v20 - v10 - 1;
      v22 = (unsigned int)v11 + (v21 >> 1) + 1;
      v23 = (unsigned int)v10 >= v22;
      if ( (unsigned int)v10 < v22 )
        v23 = v11 >= (unsigned __int64 *)&v12[v21 & 0xFFFFFFFE];
      if ( v23 )
      {
        v17 = &v10[2 * v19];
        v16 = (JSAMPROW)v11 + v19;
        v24 = v15 & 0xFFFFFFF0;
        do
        {
          v27.val[0].n64_u64[0] = *v11;
          v27.val[1].n64_u64[0] = v11[1];
          v11 += 2;
          v24 -= 16;
          *(_OWORD *)v27.val[2].n64_u64 = *(_OWORD *)v27.val[0].n64_u64;
          vst2q_s8(v10, v27);
          v10 += 32;
        }
        while ( v24 );
        v25 = v15 == v19;
        input_data = v18;
        if ( v25 )
          goto LABEL_22;
      }
      else
      {
LABEL_20:
        input_data = v18;
        v16 = (JSAMPROW)v11;
        v17 = (char *)v6[v7];
      }
    }
    else
    {
      v16 = input_data[i];
      v17 = (char *)v6[v7];
    }
    do
    {
      v26 = *v16++;
      v17[1] = v26;
      *v17 = v26;
      v17 += 2;
    }
    while ( (unsigned int)v17 < v13 );
LABEL_22:
    output_width = cinfo->output_width;
    goto LABEL_23;
  }
}

//----- (0048050A) --------------------------------------------------------
void __fastcall int_upsample(
        j_decompress_ptr cinfo,
        jpeg_component_info *compptr,
        JSAMPARRAY input_data,
        JSAMPARRAY *output_data_ptr)
{
  j_decompress_ptr v4; // r8
  int v5; // r11
  char *v6; // r0
  int v7; // r6
  unsigned int v8; // r5
  int v9; // r0
  size_t v10; // r4
  int output_width; // r0
  JSAMPROW v12; // r5
  JSAMPLE *v13; // r10
  JSAMPROW v14; // r8
  JSAMPROW v15; // r0
  int v16; // r0
  int v17; // [sp+Ch] [bp-34h]
  unsigned int v19; // [sp+14h] [bp-2Ch]
  JDIMENSION num_cols; // [sp+18h] [bp-28h]
  JSAMPROW *output_array; // [sp+1Ch] [bp-24h]
  int v22; // [sp+20h] [bp-20h]

  v4 = cinfo;
  if ( cinfo->max_v_samp_factor >= 1 )
  {
    v5 = 0;
    v6 = (char *)cinfo->upsample + compptr->component_index;
    output_array = *output_data_ptr;
    v7 = (unsigned __int8)v6[68];
    v8 = (unsigned __int8)v6[72];
    v9 = -2;
    if ( !v7 )
      v9 = -1;
    v10 = v9 + v7 + 2;
    v17 = v8 - 1;
    v22 = 0;
    v19 = v8;
    num_cols = (JDIMENSION)v4;
    do
    {
      output_width = v4->output_width;
      if ( output_width >= 1 )
      {
        v12 = output_array[v5];
        v13 = &v12[output_width];
        v14 = input_data[v22];
        do
        {
          v15 = v14++;
          if ( v7 )
          {
            memset(v12, *v15, v10);
            v16 = v7 + 1;
            do
            {
              --v16;
              ++v12;
            }
            while ( v16 > 1 );
          }
        }
        while ( v12 < v13 );
      }
      v4 = (j_decompress_ptr)num_cols;
      if ( v19 >= 2 )
        jcopy_sample_rows(output_array, v5, output_array, v5 + 1, v17, *(_DWORD *)(num_cols + 92));
      v5 += v19;
      ++v22;
    }
    while ( v5 < *(_DWORD *)(num_cols + 276) );
  }
}

//----- (004805CC) --------------------------------------------------------
jvirt_barray_ptr *__fastcall jpeg_read_coefficients(j_decompress_ptr cinfo)
{
  int arith_code; // r1
  jpeg_progress_mgr **p_progress; // r5
  jpeg_progress_mgr *progress; // r0
  int num_components; // r1
  jpeg_progress_mgr *v6; // r1
  int v7; // r0
  int v8; // r2
  int pass_limit; // r0

  switch ( cinfo->global_state )
  {
    case 0xCA:
      arith_code = cinfo->arith_code;
      cinfo->buffered_image = 1;
      if ( arith_code )
      {
        cinfo->err->msg_code = 1;
      }
      else
      {
        if ( !cinfo->progressive_mode )
        {
          jinit_huff_decoder(cinfo);
          goto LABEL_8;
        }
        cinfo->err->msg_code = 48;
      }
      cinfo->err->error_exit((j_common_ptr)cinfo);
LABEL_8:
      jinit_d_coef_controller(cinfo, 1u);
      cinfo->mem->realize_virt_arrays((j_common_ptr)cinfo);
      cinfo->inputctl->start_input_pass(cinfo);
      p_progress = &cinfo->progress;
      progress = cinfo->progress;
      if ( progress )
      {
        if ( cinfo->progressive_mode )
        {
          num_components = 3 * cinfo->num_components + 2;
        }
        else if ( cinfo->inputctl->has_multiple_scans )
        {
          num_components = cinfo->num_components;
        }
        else
        {
          num_components = 1;
        }
        progress->pass_counter = 0;
        cinfo->progress->pass_limit = num_components * cinfo->total_iMCU_rows;
        cinfo->progress->completed_passes = 0;
        cinfo->progress->total_passes = 1;
      }
      cinfo->global_state = 209;
      goto LABEL_16;
    case 0xCF:
    case 0xD2:
      goto LABEL_26;
    case 0xD1:
      p_progress = &cinfo->progress;
LABEL_16:
      while ( 2 )
      {
        v6 = *p_progress;
LABEL_17:
        if ( v6 )
          v6->progress_monitor((j_common_ptr)cinfo);
        v7 = cinfo->inputctl->consume_input(cinfo);
        if ( !v7 )
          return 0;
        if ( v7 != 2 )
        {
          v6 = *p_progress;
          if ( (v7 | 2) == 3 )
          {
            if ( v6 )
            {
              v8 = v6->pass_counter + 1;
              v6->pass_counter = v8;
              v6 = *p_progress;
              pass_limit = (*p_progress)->pass_limit;
              if ( v8 >= pass_limit )
              {
                v6->pass_limit = pass_limit + cinfo->total_iMCU_rows;
                continue;
              }
            }
          }
          goto LABEL_17;
        }
        break;
      }
      cinfo->global_state = 210;
LABEL_26:
      if ( cinfo->buffered_image )
        return cinfo->coef->coef_arrays;
LABEL_28:
      cinfo->err->msg_code = 20;
      cinfo->err->msg_parm.i[0] = cinfo->global_state;
      cinfo->err->error_exit((j_common_ptr)cinfo);
      return 0;
    default:
      goto LABEL_28;
  }
}

//----- (004806EC) --------------------------------------------------------
jpeg_error_mgr *__fastcall jpeg_std_error(jpeg_error_mgr *err)
{
  err->error_exit = error_exit;
  err->emit_message = emit_message;
  err->output_message = output_message;
  err->format_message = format_message;
  err->reset_error_mgr = reset_error_mgr;
  err->msg_code = 0;
  err->trace_level = 0;
  err->num_warnings = 0;
  err->jpeg_message_table = jpeg_std_message_table;
  err->last_jpeg_message = 1;
  err->addon_message_table = 0;
  err->first_addon_message = 0;
  err->last_addon_message = 0;
  return err;
}

//----- (0048074C) --------------------------------------------------------
void __fastcall __noreturn error_exit(j_common_ptr cinfo)
{
  cinfo->err->output_message(cinfo);
  jpeg_destroy(cinfo);
  exit(1);
}

//----- (00480766) --------------------------------------------------------
void __fastcall emit_message(j_common_ptr cinfo, int msg_level)
{
  jpeg_error_mgr *err; // r4
  int num_warnings; // r1

  err = cinfo->err;
  if ( msg_level <= -1 )
  {
    num_warnings = err->num_warnings;
    if ( !num_warnings || err->trace_level >= 3 )
    {
      ((void (*)(void))err->output_message)();
      num_warnings = err->num_warnings;
    }
    err->num_warnings = num_warnings + 1;
  }
  else if ( err->trace_level >= msg_level )
  {
    ((void (*)(void))err->output_message)();
  }
}

//----- (00480798) --------------------------------------------------------
void __fastcall output_message(j_common_ptr cinfo)
{
  char v1[200]; // [sp+4h] [bp-D4h] BYREF

  cinfo->err->format_message(cinfo, (unsigned __int8 *)v1);
  fprintf((FILE *)stderr, (const char *)&dword_4807E0, v1);
}
// 4807E0: using guessed type int dword_4807E0;

//----- (004807E8) --------------------------------------------------------
void __fastcall format_message(j_common_ptr cinfo, unsigned __int8 *buffer)
{
  jpeg_error_mgr *err; // r0
  int msg_code; // r2
  const unsigned __int8 *const *addon_message_table; // lr
  int first_addon_message; // r12
  const unsigned __int8 **v6; // r3
  const unsigned __int8 *v7; // r12
  const unsigned __int8 **jpeg_message_table; // r3
  const unsigned __int8 *v9; // r2
  int v10; // r3
  int v11; // t1

  err = cinfo->err;
  msg_code = err->msg_code;
  if ( msg_code >= 1 && msg_code <= err->last_jpeg_message )
  {
    v6 = (const unsigned __int8 **)&err->jpeg_message_table[msg_code];
  }
  else
  {
    addon_message_table = err->addon_message_table;
    if ( !addon_message_table )
      goto LABEL_9;
    first_addon_message = err->first_addon_message;
    if ( msg_code < first_addon_message || msg_code > err->last_addon_message )
      goto LABEL_9;
    v6 = (const unsigned __int8 **)&addon_message_table[msg_code - first_addon_message];
  }
  v7 = *v6;
  if ( !*v6 )
  {
LABEL_9:
    jpeg_message_table = (const unsigned __int8 **)err->jpeg_message_table;
    err->msg_parm.i[0] = msg_code;
    v7 = *jpeg_message_table;
  }
  v9 = v7;
  while ( 1 )
  {
    v11 = *v9++;
    v10 = v11;
    if ( !v11 )
      break;
    if ( v10 == 37 )
    {
      if ( *v9 == 115 )
      {
        sprintf(buffer, v7, &err->msg_parm);
        return;
      }
      break;
    }
  }
  sprintf(
    buffer,
    v7,
    err->msg_parm.i[0],
    err->msg_parm.i[1],
    err->msg_parm.i[2],
    err->msg_parm.i[3],
    err->msg_parm.i[4],
    err->msg_parm.i[5],
    err->msg_parm.i[6],
    err->msg_parm.i[7]);
}

//----- (00480896) --------------------------------------------------------
void __fastcall reset_error_mgr(j_common_ptr cinfo)
{
  cinfo->err->num_warnings = 0;
  cinfo->err->msg_code = 0;
}

//----- (004808A4) --------------------------------------------------------
void __fastcall jpeg_fdct_float(float *data)
{
  int v1; // r1
  float *v2; // r2
  float v3; // s7
  float v4; // s10
  float v5; // s5
  float v6; // s11
  float v7; // s12
  float v8; // s8
  float v9; // s3
  float v10; // s9
  float v11; // s14
  float v12; // s10
  float v13; // s1
  float v14; // s15
  float v15; // s12
  float v16; // s13
  float v17; // s14
  float v18; // s1
  float v19; // s7
  float v20; // s3
  float v21; // s5
  float v22; // s8
  float v23; // s10
  float v24; // s9
  float v25; // s13
  float v26; // s12
  float v27; // s3
  float v28; // s1
  int v29; // r1
  float v30; // s3
  float v31; // s10
  float v32; // s1
  float v33; // s11
  float v34; // s12
  float v35; // s8
  float v36; // s9
  float v37; // s7
  float v38; // s14
  float v39; // s10
  float v40; // s5
  float v41; // s15
  float v42; // s12
  float v43; // s13
  float v44; // s14
  float v45; // s1
  float v46; // s9
  float v47; // s3
  float v48; // s5
  float v49; // s8
  float v50; // s10
  float v51; // s7
  float v52; // s14
  float v53; // s7
  float v54; // s13
  float v55; // s12
  float v56; // s3
  float v57; // s1

  v1 = 8;
  v2 = data;
  do
  {
    --v1;
    v3 = v2[7];
    v4 = v2[1];
    v5 = v2[6];
    v6 = *v2 - v3;
    v7 = v2[2];
    v8 = *v2 + v3;
    v9 = v2[5];
    v10 = v4 - v5;
    v11 = v2[3];
    v12 = v4 + v5;
    v13 = v2[4];
    v14 = v7 - v9;
    v15 = v7 + v9;
    v16 = v11 - v13;
    v17 = v11 + v13;
    v18 = v6 + v10;
    v19 = v12 - v15;
    v20 = v14 + v16;
    v21 = v8 - v17;
    v22 = v8 + v17;
    v23 = v12 + v15;
    v24 = (float)(v10 + v14) * 0.70711;
    v25 = (float)((float)(v14 + v16) - v18) * 0.38268;
    v26 = (float)(v19 + v21) * 0.70711;
    v27 = (float)(v20 * 0.5412) + v25;
    v28 = (float)(v18 * 1.3066) + v25;
    *v2 = v23 + v22;
    v2[1] = (float)(v6 + v24) + v28;
    v2[2] = v21 + v26;
    v2[3] = (float)(v6 - v24) - v27;
    v2[4] = v22 - v23;
    v2[5] = (float)(v6 - v24) + v27;
    v2[6] = v21 - v26;
    v2[7] = (float)(v6 + v24) - v28;
    v2 += 8;
  }
  while ( v1 > 0 );
  v29 = 8;
  do
  {
    --v29;
    v30 = data[56];
    v31 = data[8];
    v32 = data[48];
    v33 = *data - v30;
    v34 = data[16];
    v35 = *data + v30;
    v36 = data[40];
    v37 = v31 - v32;
    v38 = data[24];
    v39 = v31 + v32;
    v40 = data[32];
    v41 = v34 - v36;
    v42 = v34 + v36;
    v43 = v38 - v40;
    v44 = v38 + v40;
    v45 = v33 + v37;
    v46 = v39 - v42;
    v47 = v41 + v43;
    v48 = v35 - v44;
    v49 = v35 + v44;
    v50 = v39 + v42;
    v51 = (float)(v37 + v41) * 0.70711;
    v52 = v33 - v51;
    v53 = v33 + v51;
    v54 = (float)((float)(v41 + v43) - v45) * 0.38268;
    v55 = (float)(v46 + v48) * 0.70711;
    v56 = (float)(v47 * 0.5412) + v54;
    v57 = (float)(v45 * 1.3066) + v54;
    *data = v50 + v49;
    data[32] = v49 - v50;
    data[16] = v48 + v55;
    data[48] = v48 - v55;
    data[40] = v52 + v56;
    data[24] = v52 - v56;
    data[8] = v53 + v57;
    data[56] = v53 - v57;
    ++data;
  }
  while ( v29 > 0 );
}

//----- (00480A70) --------------------------------------------------------
void __fastcall jpeg_idct_float(
        j_decompress_ptr cinfo,
        jpeg_component_info *compptr,
        JCOEFPTR coef_block,
        JSAMPARRAY output_buf,
        JDIMENSION output_col)
{
  unsigned __int16 *v5; // r2
  int v6; // r10
  char *dct_table; // r3
  int v8; // r4
  bool v9; // zf
  int v10; // r0
  float v11; // s8
  int v12; // r0
  float *v13; // r1
  int v14; // r12
  float *v15; // r6
  bool v16; // zf
  float v17; // s8
  float v18; // s10
  float v19; // s12
  float v20; // s14
  float v21; // s3
  float v22; // s8
  float v23; // s1
  float v24; // s5
  float v25; // s13
  float v26; // s9
  float v27; // s11
  float v28; // s8
  float v29; // s7
  float v30; // s10
  float v31; // s12
  float v32; // s14
  float v33; // s1
  float v34; // s5
  float v35; // s7
  float v36; // s10
  float v37; // s1
  float v38; // s9
  float v39; // s12
  float v40; // s3
  float v41; // s11
  float v42; // s1
  float v43; // s14
  float *v44; // r0
  float *v45; // r2
  int v46; // r1
  JSAMPLE *v47; // r0
  float v48; // s8
  float v49; // s10
  float v50; // s7
  float v51; // s12
  float v52; // s14
  float v53; // s9
  float v54; // s3
  float v55; // s10
  float v56; // s1
  float v57; // s5
  float v58; // s11
  float v59; // s14
  float v60; // s3
  float v61; // s7
  float v62; // s12
  float v63; // s8
  float v64; // s13
  float v65; // s5
  float v66; // s12
  float v67; // s1
  float v68; // s11
  JSAMPROW v69; // r3
  float v70; // s15
  float v71; // s8
  float v72; // s12
  float v73; // s10
  float v74; // s5
  JSAMPLE *v75; // r6
  JSAMPLE *sample_range_limit; // [sp+0h] [bp-124h]
  char v78[284]; // [sp+8h] [bp-11Ch] BYREF

  v5 = (unsigned __int16 *)(coef_block + 32);
  sample_range_limit = cinfo->sample_range_limit;
  v6 = 9;
  dct_table = (char *)compptr->dct_table;
  v8 = 0;
  do
  {
    v12 = *(v5 - 16);
    v13 = (float *)&dct_table[v8];
    v14 = *(v5 - 24);
    v15 = (float *)&v78[v8];
    if ( !(v14 | v12) )
    {
      v16 = *(v5 - 8) == 0;
      if ( !*(v5 - 8) )
        v16 = *v5 == 0;
      if ( v16 )
      {
        v9 = v5[8] == 0;
        if ( !v5[8] )
          v9 = v5[16] == 0;
        if ( v9 && !v5[24] )
        {
          v10 = 56;
          v11 = *v13 * (float)(__int16)*(v5 - 32);
          *v15 = v11;
          v15[16] = v11;
          v15[8] = v11;
          v15[24] = v11;
          v15[32] = v11;
          v15[40] = v11;
          v15[48] = v11;
          goto LABEL_14;
        }
      }
      LOWORD(v12) = 0;
    }
    v17 = v13[56] * (float)(__int16)v5[24];
    v18 = v13[8] * (float)(__int16)v14;
    v19 = v13[40] * (float)(__int16)v5[8];
    v20 = v13[24] * (float)(__int16)*(v5 - 8);
    v21 = v18 - v17;
    v22 = v18 + v17;
    v23 = v13[48] * (float)(__int16)v5[16];
    v24 = v13[16] * (float)(__int16)v12;
    v10 = 24;
    v25 = (float)(v19 - v20) + v21;
    v26 = v13[32] * (float)(__int16)*v5;
    v27 = v22 - (float)(v20 + v19);
    v28 = (float)(v20 + v19) + v22;
    v29 = *v13 * (float)(__int16)*(v5 - 32);
    v30 = (float)(v25 * 1.8478) + (float)((float)(v19 - v20) * -2.6131);
    v31 = v24 + v23;
    v32 = (float)(v21 * 1.0824) - (float)(v25 * 1.8478);
    v33 = (float)(v24 - v23) * 1.4142;
    v34 = v29 + v26;
    v35 = v29 - v26;
    v36 = v30 - v28;
    v37 = v33 - v31;
    v38 = v34 + v31;
    v39 = v34 - v31;
    v40 = (float)(v27 * 1.4142) - v36;
    v41 = v35 + v37;
    v42 = v35 - v37;
    v43 = v32 + v40;
    *v15 = v38 + v28;
    v15[56] = v38 - v28;
    v11 = v39 - v43;
    v15[8] = v41 + v36;
    v15[48] = v41 - v36;
    v15[16] = v42 + v40;
    v15[40] = v42 - v40;
    v15[32] = v39 + v43;
LABEL_14:
    --v6;
    v44 = (float *)&v78[4 * v10 + v8];
    ++v5;
    v8 += 4;
    *v44 = v11;
  }
  while ( v6 > 1 );
  v45 = (float *)v78;
  v46 = 0;
  v47 = sample_range_limit + 128;
  do
  {
    v48 = *v45;
    v49 = v45[1];
    v50 = v45[7];
    v51 = v45[2];
    v52 = v45[3];
    v53 = v49 - v50;
    v54 = v45[5];
    v55 = v49 + v50;
    v56 = v45[4];
    v57 = v45[6];
    v58 = v54 - v52;
    v59 = v54 + v52;
    v45 += 8;
    v60 = v51 + v57;
    v61 = v48 + v56;
    v62 = v51 - v57;
    v63 = v48 - v56;
    v64 = v59 + v55;
    v65 = (float)(v58 + v53) * 1.8478;
    v66 = (float)(v62 * 1.4142) - v60;
    v67 = v65 + (float)(v58 * -2.6131);
    v68 = (float)(v61 + v60) - (float)(v59 + v55);
    v69 = output_buf[v46++];
    v70 = v63 + v66;
    v71 = v63 - v66;
    v72 = v70 + (float)(v67 - (float)(v59 + v55));
    v73 = (float)((float)(v55 - v59) * 1.4142) - (float)(v67 - (float)(v59 + v55));
    v74 = (float)((float)(v53 * 1.0824) - v65) + v73;
    v69[output_col] = v47[((unsigned int)((int)(float)((float)(v61 + v60) + v64) + 4) >> 3) & 0x3FF];
    v75 = &v69[output_col];
    v75[7] = v47[((unsigned int)((int)v68 + 4) >> 3) & 0x3FF];
    v75[1] = v47[((unsigned int)((int)v72 + 4) >> 3) & 0x3FF];
    v75[6] = v47[((unsigned int)((int)(float)(v70 - (float)(v67 - v64)) + 4) >> 3) & 0x3FF];
    v75[2] = v47[((unsigned int)((int)(float)(v71 + v73) + 4) >> 3) & 0x3FF];
    v75[5] = v47[((unsigned int)((int)(float)(v71 - v73) + 4) >> 3) & 0x3FF];
    v75[4] = v47[((unsigned int)((int)(float)((float)(v61 - v60) + v74) + 4) >> 3) & 0x3FF];
    v75[3] = v47[((unsigned int)((int)(float)((float)(v61 - v60) - v74) + 4) >> 3) & 0x3FF];
  }
  while ( v46 != 8 );
}

//----- (00480DEC) --------------------------------------------------------
void __fastcall jinit_memory_mgr(j_common_ptr cinfo)
{
  jpeg_memory_mgr *small; // r4
  char *v3; // r0
  int v4; // r0
  unsigned __int8 v5; // [sp+3h] [bp-1Dh] BYREF
  int v6; // [sp+4h] [bp-1Ch] BYREF

  cinfo->mem = 0;
  v6 = jpeg_mem_init(cinfo);
  small = (jpeg_memory_mgr *)jpeg_get_small(cinfo, 0x54u);
  if ( !small )
  {
    jpeg_mem_term(cinfo);
    cinfo->err->msg_code = 54;
    cinfo->err->msg_parm.i[0] = 0;
    cinfo->err->error_exit(cinfo);
  }
  small->max_alloc_chunk = 1000000000;
  small->alloc_large = alloc_large;
  small->alloc_small = alloc_small;
  small->alloc_sarray = alloc_sarray;
  small->alloc_barray = alloc_barray;
  small->request_virt_sarray = (jvirt_sarray_ptr (*)(j_common_ptr, int, boolean, JDIMENSION, JDIMENSION, JDIMENSION))request_virt_sarray;
  small->request_virt_barray = (jvirt_barray_ptr (*)(j_common_ptr, int, boolean, JDIMENSION, JDIMENSION, JDIMENSION))request_virt_barray;
  small->realize_virt_arrays = realize_virt_arrays;
  small->access_virt_sarray = (JSAMPARRAY (*)(j_common_ptr, jvirt_sarray_ptr, JDIMENSION, JDIMENSION, boolean))access_virt_sarray;
  small->access_virt_barray = (JBLOCKARRAY (*)(j_common_ptr, jvirt_barray_ptr, JDIMENSION, JDIMENSION, boolean))access_virt_barray;
  small->free_pool = free_pool;
  small->self_destruct = self_destruct;
  small->max_memory_to_use = v6;
  small[1].alloc_small = 0;
  small[1].alloc_large = 0;
  small[1].alloc_sarray = 0;
  small[1].alloc_barray = 0;
  small[1].request_virt_sarray = 0;
  small[1].request_virt_barray = 0;
  small[1].realize_virt_arrays = (void (*)(j_common_ptr))&dword_54;
  cinfo->mem = small;
  v3 = getenv("JPEGMEM");
  if ( v3 )
  {
    v5 = 120;
    if ( sscanf(v3, "%ld%c", &v6, &v5) >= 1 )
    {
      v4 = v6;
      if ( (v5 | 0x20) == 109 )
      {
        v4 = 1000 * v6;
        v6 *= 1000;
      }
      small->max_memory_to_use = 1000 * v4;
    }
  }
}
// 54: using guessed type int dword_54;

//----- (00480F18) --------------------------------------------------------
void *__fastcall alloc_small(j_common_ptr cinfo, int pool_id, size_t sizeofobject)
{
  jpeg_memory_mgr *mem; // r9
  size_t v5; // r10
  void *(**v7)(j_common_ptr, int, size_t); // r1
  void *(*small)(j_common_ptr, int, size_t); // r0
  void *(**v9)(j_common_ptr, int, size_t); // r1
  void *(*v10)(j_common_ptr, int, size_t); // t1
  _DWORD *v11; // r4
  const size_t *v12; // r1
  unsigned int v13; // r8
  size_t v14; // r11
  size_t v15; // r6
  unsigned int v16; // r9
  __int64 v17; // kr00_8
  jpeg_memory_mgr *v19; // [sp+4h] [bp-24h]
  void *(**v20)(j_common_ptr, int, size_t); // [sp+8h] [bp-20h]

  mem = cinfo->mem;
  v5 = sizeofobject;
  if ( sizeofobject > 0x3B9AC9F0 )
  {
    cinfo->err->msg_code = 54;
    cinfo->err->msg_parm.i[0] = 1;
    cinfo->err->error_exit(cinfo);
  }
  if ( (v5 & 7) != 0 )
    v5 += 8 - (v5 & 7);
  if ( (unsigned int)pool_id >= 2 )
  {
    cinfo->err->msg_code = 14;
    cinfo->err->msg_parm.i[0] = pool_id;
    cinfo->err->error_exit(cinfo);
  }
  v7 = &mem->alloc_small + pool_id;
  v10 = v7[13];
  v9 = v7 + 13;
  small = v10;
  if ( v10 )
  {
    while ( 1 )
    {
      v11 = small;
      if ( *((_DWORD *)small + 2) >= v5 )
        break;
      small = *(void *(**)(j_common_ptr, int, size_t))small;
      if ( !*v11 )
        goto LABEL_12;
    }
  }
  else
  {
    v11 = 0;
LABEL_12:
    v20 = v9;
    v12 = first_pool_slop;
    if ( v11 )
      v12 = extra_pool_slop;
    v13 = v12[pool_id];
    v14 = v5 + 16;
    if ( v13 > 999999984 - v5 )
      v13 = 999999984 - v5;
    v15 = v14 + v13;
    small = (void *(*)(j_common_ptr, int, size_t))jpeg_get_small(cinfo, v14 + v13);
    if ( !small )
    {
      v19 = mem;
      do
      {
        v16 = v13 >> 1;
        if ( v13 <= 0x63 )
        {
          cinfo->err->msg_code = 54;
          cinfo->err->msg_parm.i[0] = 2;
          cinfo->err->error_exit(cinfo);
        }
        v15 = v14 + v16;
        small = (void *(*)(j_common_ptr, int, size_t))jpeg_get_small(cinfo, v14 + v16);
        v13 >>= 1;
      }
      while ( !small );
      v13 = v16;
      mem = v19;
    }
    mem[1].realize_virt_arrays = (void (*)(j_common_ptr))((char *)mem[1].realize_virt_arrays + v15);
    *(_DWORD *)small = 0;
    *((_DWORD *)small + 1) = 0;
    *((_DWORD *)small + 2) = v13 + v5;
    if ( v11 )
      *v11 = small;
    else
      *v20 = small;
  }
  v17 = *(_QWORD *)((char *)small + 4);
  *((_DWORD *)small + 1) = v17 + v5;
  *((_DWORD *)small + 2) = HIDWORD(v17) - v5;
  return (char *)small + v17 + 16;
}

//----- (00481044) --------------------------------------------------------
void *__fastcall alloc_large(j_common_ptr cinfo, int pool_id, size_t sizeofobject)
{
  jpeg_memory_mgr *mem; // r10
  size_t v5; // r4
  _DWORD *large; // r5
  void *(**v8)(j_common_ptr, int, size_t); // r0

  mem = cinfo->mem;
  v5 = sizeofobject;
  if ( sizeofobject >= 0x3B9AC9F1 )
  {
    cinfo->err->msg_code = 54;
    cinfo->err->msg_parm.i[0] = 3;
    cinfo->err->error_exit(cinfo);
  }
  if ( (v5 & 7) != 0 )
    v5 += 8 - (v5 & 7);
  if ( (unsigned int)pool_id >= 2 )
  {
    cinfo->err->msg_code = 14;
    cinfo->err->msg_parm.i[0] = pool_id;
    cinfo->err->error_exit(cinfo);
  }
  large = jpeg_get_large(cinfo, v5 + 16);
  if ( !large )
  {
    cinfo->err->msg_code = 54;
    cinfo->err->msg_parm.i[0] = 4;
    cinfo->err->error_exit(cinfo);
  }
  mem[1].realize_virt_arrays = (void (*)(j_common_ptr))((char *)mem[1].realize_virt_arrays + v5 + 16);
  v8 = &mem->alloc_small + pool_id;
  *large = v8[15];
  large[1] = v5;
  large[2] = 0;
  v8[15] = (void *(*)(j_common_ptr, int, size_t))large;
  return large + 4;
}

//----- (004810E4) --------------------------------------------------------
JSAMPARRAY __fastcall alloc_sarray(j_common_ptr cinfo, int pool_id, JDIMENSION samplesperrow, JDIMENSION numrows)
{
  jpeg_memory_mgr *mem; // r6
  signed int v8; // r8
  JSAMPROW *v9; // r4
  JDIMENSION v10; // r11
  JDIMENSION v11; // r6
  JSAMPLE *v12; // r0
  int v13; // r2
  int v14; // r1
  JDIMENSION v16; // [sp+4h] [bp-24h]

  mem = cinfo->mem;
  v8 = 0x3B9AC9F0 / samplesperrow;
  if ( samplesperrow > 0x3B9AC9F0 )
  {
    cinfo->err->msg_code = 70;
    cinfo->err->error_exit(cinfo);
  }
  if ( v8 >= (int)numrows )
    v8 = numrows;
  mem[1].access_virt_sarray = (JSAMPARRAY (*)(j_common_ptr, jvirt_sarray_ptr, JDIMENSION, JDIMENSION, boolean))v8;
  v9 = (JSAMPROW *)alloc_small(cinfo, pool_id, 4 * numrows);
  if ( numrows )
  {
    v10 = 0;
    v16 = ~numrows;
    do
    {
      v11 = v8;
      v8 = numrows - v10;
      if ( v11 < numrows - v10 )
        v8 = v11;
      v12 = (JSAMPLE *)alloc_large(cinfo, pool_id, v8 * samplesperrow);
      if ( v8 )
      {
        v13 = ~v11;
        if ( v16 + v10 > ~v11 )
          v13 = v16 + v10;
        v14 = v13 + 1;
        do
        {
          v9[v10] = v12;
          v12 += samplesperrow;
          ++v14;
          ++v10;
        }
        while ( v14 );
      }
    }
    while ( v10 < numrows );
  }
  return v9;
}

//----- (00481192) --------------------------------------------------------
JBLOCKARRAY __fastcall alloc_barray(j_common_ptr cinfo, int pool_id, JDIMENSION blocksperrow, JDIMENSION numrows)
{
  JDIMENSION v4; // r5
  jpeg_memory_mgr *mem; // r6
  signed int v8; // r8
  JBLOCKROW *v9; // r4
  JDIMENSION v10; // r11
  JDIMENSION v11; // r6
  JBLOCK *v12; // r0
  int v13; // r2
  int v14; // r1
  JDIMENSION v16; // [sp+4h] [bp-24h]

  v4 = blocksperrow << 7;
  mem = cinfo->mem;
  v8 = 0x3B9AC9F0 / (blocksperrow << 7);
  if ( blocksperrow << 7 > 0x3B9AC9F0 )
  {
    cinfo->err->msg_code = 70;
    cinfo->err->error_exit(cinfo);
  }
  if ( v8 >= (int)numrows )
    v8 = numrows;
  mem[1].access_virt_sarray = (JSAMPARRAY (*)(j_common_ptr, jvirt_sarray_ptr, JDIMENSION, JDIMENSION, boolean))v8;
  v9 = (JBLOCKROW *)alloc_small(cinfo, pool_id, 4 * numrows);
  if ( numrows )
  {
    v10 = 0;
    v16 = ~numrows;
    do
    {
      v11 = v8;
      v8 = numrows - v10;
      if ( v11 < numrows - v10 )
        v8 = v11;
      v12 = (JBLOCK *)alloc_large(cinfo, pool_id, v4 * v8);
      if ( v8 )
      {
        v13 = ~v11;
        if ( v16 + v10 > ~v11 )
          v13 = v16 + v10;
        v14 = v13 + 1;
        do
        {
          v9[v10] = v12;
          v12 = (JBLOCK *)((char *)v12 + v4);
          ++v14;
          ++v10;
        }
        while ( v14 );
      }
    }
    while ( v10 < numrows );
  }
  return v9;
}

//----- (00481240) --------------------------------------------------------
jvirt_sarray_ptr (*__fastcall request_virt_sarray(
        j_common_ptr cinfo,
        int pool_id,
        boolean pre_zero,
        JDIMENSION samplesperrow,
        JDIMENSION a5,
        JDIMENSION a6))(j_common_ptr, int, boolean, JDIMENSION, JDIMENSION, JDIMENSION)
{
  jpeg_memory_mgr *mem; // r5
  jvirt_sarray_ptr (*result)(j_common_ptr, int, boolean, JDIMENSION, JDIMENSION, JDIMENSION); // r0

  mem = cinfo->mem;
  if ( pool_id != 1 )
  {
    cinfo->err->msg_code = 14;
    cinfo->err->msg_parm.i[0] = pool_id;
    cinfo->err->error_exit(cinfo);
  }
  result = (jvirt_sarray_ptr (*)(j_common_ptr, int, boolean, JDIMENSION, JDIMENSION, JDIMENSION))alloc_small(
                                                                                                   cinfo,
                                                                                                   pool_id,
                                                                                                   0x78u);
  *(_DWORD *)result = 0;
  *((_DWORD *)result + 1) = a5;
  *((_DWORD *)result + 2) = samplesperrow;
  *((_DWORD *)result + 3) = a6;
  *((_BYTE *)result + 32) = pre_zero;
  *((_BYTE *)result + 34) = 0;
  *((_DWORD *)result + 9) = mem[1].request_virt_sarray;
  mem[1].request_virt_sarray = result;
  return result;
}

//----- (00481298) --------------------------------------------------------
jvirt_barray_ptr (*__fastcall request_virt_barray(
        j_common_ptr cinfo,
        int pool_id,
        boolean pre_zero,
        JDIMENSION blocksperrow,
        JDIMENSION a5,
        JDIMENSION a6))(j_common_ptr, int, boolean, JDIMENSION, JDIMENSION, JDIMENSION)
{
  jpeg_memory_mgr *mem; // r5
  jvirt_barray_ptr (*result)(j_common_ptr, int, boolean, JDIMENSION, JDIMENSION, JDIMENSION); // r0

  mem = cinfo->mem;
  if ( pool_id != 1 )
  {
    cinfo->err->msg_code = 14;
    cinfo->err->msg_parm.i[0] = pool_id;
    cinfo->err->error_exit(cinfo);
  }
  result = (jvirt_barray_ptr (*)(j_common_ptr, int, boolean, JDIMENSION, JDIMENSION, JDIMENSION))alloc_small(
                                                                                                   cinfo,
                                                                                                   pool_id,
                                                                                                   0x78u);
  *(_DWORD *)result = 0;
  *((_DWORD *)result + 1) = a5;
  *((_DWORD *)result + 2) = blocksperrow;
  *((_DWORD *)result + 3) = a6;
  *((_BYTE *)result + 32) = pre_zero;
  *((_BYTE *)result + 34) = 0;
  *((_DWORD *)result + 9) = mem[1].request_virt_barray;
  mem[1].request_virt_barray = result;
  return result;
}

//----- (004812F0) --------------------------------------------------------
void __fastcall realize_virt_arrays(j_common_ptr cinfo)
{
  jvirt_sarray_ptr (*request_virt_sarray)(j_common_ptr, int, boolean, JDIMENSION, JDIMENSION, JDIMENSION); // r0
  int v2; // r4
  int v3; // r5
  int v4; // r2
  jvirt_barray_ptr (*i)(j_common_ptr, int, boolean, JDIMENSION, JDIMENSION, JDIMENSION); // r0
  int v6; // r2
  int v7; // r0
  int v8; // r9
  jpeg_common_struct *v9; // r2
  jvirt_sarray_ptr (*v10)(j_common_ptr, int, boolean, JDIMENSION, JDIMENSION, JDIMENSION); // r6
  signed int v11; // r5
  jpeg_common_struct *v12; // r10
  int v13; // r0
  unsigned int *v14; // r4
  jpeg_common_struct *v15; // r9
  int v16; // r2
  unsigned int v17; // r6
  unsigned int v18; // r0
  jpeg_memory_mgr *v19; // r4
  unsigned int v20; // r11
  jpeg_common_struct *v21; // r0
  _DWORD *v22; // r0
  _DWORD *v23; // r4
  unsigned int v24; // r9
  unsigned int v25; // r0
  int v26; // r11
  jpeg_memory_mgr *v27; // r10
  jpeg_common_struct *v28; // r5
  _DWORD *large; // r5
  JBLOCKARRAY (*alloc_barray)(j_common_ptr, int, JDIMENSION, JDIMENSION); // r0
  int v31; // r1
  int v32; // r0
  _DWORD *v33; // r1
  jvirt_barray_ptr (*k)(j_common_ptr, int, boolean, JDIMENSION, JDIMENSION, JDIMENSION); // r5
  jpeg_common_struct *v35; // r5
  signed int v36; // r10
  unsigned int v37; // r4
  _DWORD *v38; // r5
  int v39; // t1
  jpeg_common_struct *v40; // r4
  unsigned int v41; // r6
  unsigned int v42; // r11
  jpeg_memory_mgr *v43; // r8
  _DWORD *v44; // r4
  unsigned int v45; // r9
  unsigned int v46; // r0
  int v47; // r11
  jpeg_memory_mgr *v48; // r10
  _DWORD *v49; // r5
  JBLOCKARRAY (*v50)(j_common_ptr, int, JDIMENSION, JDIMENSION); // r0
  int v51; // r1
  int v52; // r0
  _DWORD *v53; // r1
  jvirt_sarray_ptr (*v54)(j_common_ptr, int, boolean, JDIMENSION, JDIMENSION, JDIMENSION); // [sp+4h] [bp-3Ch]
  jvirt_barray_ptr (*v55)(j_common_ptr, int, boolean, JDIMENSION, JDIMENSION, JDIMENSION); // [sp+4h] [bp-3Ch]
  int j; // [sp+8h] [bp-38h]
  jpeg_memory_mgr *mem; // [sp+Ch] [bp-34h]
  int v58; // [sp+10h] [bp-30h]
  int v59; // [sp+10h] [bp-30h]
  unsigned int v60; // [sp+14h] [bp-2Ch]
  unsigned int v61; // [sp+14h] [bp-2Ch]
  unsigned int v62; // [sp+18h] [bp-28h]
  unsigned int v63; // [sp+18h] [bp-28h]
  unsigned int v64; // [sp+1Ch] [bp-24h]
  unsigned int v65; // [sp+1Ch] [bp-24h]

  mem = cinfo->mem;
  request_virt_sarray = mem[1].request_virt_sarray;
  if ( request_virt_sarray )
  {
    v2 = 0;
    v3 = 0;
    do
    {
      if ( !*(_DWORD *)request_virt_sarray )
      {
        v4 = *((_DWORD *)request_virt_sarray + 2);
        v3 += *((_DWORD *)request_virt_sarray + 1) * v4;
        v2 += v4 * *((_DWORD *)request_virt_sarray + 3);
      }
      request_virt_sarray = (jvirt_sarray_ptr (*)(j_common_ptr, int, boolean, JDIMENSION, JDIMENSION, JDIMENSION))*((_DWORD *)request_virt_sarray + 9);
    }
    while ( request_virt_sarray );
  }
  else
  {
    v3 = 0;
    v2 = 0;
  }
  for ( i = mem[1].request_virt_barray;
        i;
        i = (jvirt_barray_ptr (*)(j_common_ptr, int, boolean, JDIMENSION, JDIMENSION, JDIMENSION))*((_DWORD *)i + 9) )
  {
    if ( !*(_DWORD *)i )
    {
      v6 = *((_DWORD *)i + 2);
      v3 += (*((_DWORD *)i + 1) * v6) << 7;
      v2 += (v6 * *((_DWORD *)i + 3)) << 7;
    }
  }
  if ( v2 >= 1 )
  {
    v7 = jpeg_mem_available(cinfo, v2, v3, (int)mem[1].realize_virt_arrays);
    if ( v7 >= v3 )
    {
      v8 = 1000000000;
    }
    else
    {
      v8 = v7 / v2;
      if ( v7 / v2 <= 1 )
        v8 = 1;
    }
    v9 = cinfo;
    v10 = mem[1].request_virt_sarray;
    for ( j = v8;
          v10;
          v10 = (jvirt_sarray_ptr (*)(j_common_ptr, int, boolean, JDIMENSION, JDIMENSION, JDIMENSION))*((_DWORD *)v10 + 9) )
    {
      if ( !*(_DWORD *)v10 )
      {
        v11 = *((_DWORD *)v10 + 1);
        v12 = v9;
        if ( (int)((unsigned int)(v11 - 1) / *((_DWORD *)v10 + 3) + 1) <= v8 )
        {
          *((_DWORD *)v10 + 4) = v11;
          v14 = (unsigned int *)((char *)v10 + 8);
          v15 = v9;
        }
        else
        {
          v13 = *((_DWORD *)v10 + 3) * v8;
          v14 = (unsigned int *)((char *)v10 + 8);
          v15 = v9;
          v16 = *((_DWORD *)v10 + 2) * v11;
          *((_DWORD *)v10 + 4) = v13;
          jpeg_open_backing_store(v12, (backing_store_ptr)((char *)v10 + 40), v16);
          v11 = *((_DWORD *)v10 + 4);
          *((_BYTE *)v10 + 34) = 1;
        }
        v54 = v10;
        v17 = *v14;
        v18 = 0x3B9AC9F0 / *v14;
        v19 = v15->mem;
        v20 = v18;
        v21 = v15;
        if ( v17 > 0x3B9AC9F0 )
        {
          v15->err->msg_code = 70;
          v15->err->error_exit(v15);
          v21 = v12;
        }
        if ( (int)v20 >= v11 )
          v20 = v11;
        v19[1].access_virt_sarray = (JSAMPARRAY (*)(j_common_ptr, jvirt_sarray_ptr, JDIMENSION, JDIMENSION, boolean))v20;
        v22 = alloc_small(v21, 1, 4 * v11);
        v9 = v12;
        v23 = v22;
        if ( v11 )
        {
          v24 = 0;
          v58 = ~v11;
          v60 = v11;
          do
          {
            while ( 1 )
            {
              v25 = v11 - v24;
              v62 = v20;
              if ( v20 < v11 - v24 )
                v25 = v20;
              v26 = v25 * v17;
              v64 = v25;
              v27 = v9->mem;
              if ( v25 * v17 > 0x3B9AC9F0 )
              {
                v28 = v9;
                v9->err->msg_code = 54;
                v9->err->msg_parm.i[0] = 3;
                v9->err->error_exit(v9);
                v9 = v28;
              }
              if ( (v26 & 7) != 0 )
                v26 += 8 - (v26 & 7);
              large = jpeg_get_large(v9, v26 + 16);
              if ( !large )
              {
                cinfo->err->msg_code = 54;
                cinfo->err->msg_parm.i[0] = 4;
                cinfo->err->error_exit(cinfo);
              }
              alloc_barray = v27[1].alloc_barray;
              v27[1].realize_virt_arrays = (void (*)(j_common_ptr))((char *)v27[1].realize_virt_arrays + v26 + 16);
              *large = alloc_barray;
              large[1] = v26;
              large[2] = 0;
              v27[1].alloc_barray = (JBLOCKARRAY (*)(j_common_ptr, int, JDIMENSION, JDIMENSION))large;
              v20 = v64;
              if ( v64 )
                break;
              v9 = cinfo;
              v11 = v60;
              if ( v24 >= v60 )
                goto LABEL_46;
            }
            v31 = ~v62;
            if ( v58 + v24 > ~v62 )
              v31 = v58 + v24;
            v9 = cinfo;
            v32 = v31 + 1;
            v33 = large + 4;
            v11 = v60;
            do
            {
              v23[v24] = v33;
              v33 = (_DWORD *)((char *)v33 + v17);
              ++v32;
              ++v24;
            }
            while ( v32 );
          }
          while ( v24 < v60 );
        }
LABEL_46:
        v10 = v54;
        *(_DWORD *)v54 = v23;
        *((_DWORD *)v54 + 5) = mem[1].access_virt_sarray;
        *((_DWORD *)v54 + 6) = 0;
        *((_DWORD *)v54 + 7) = 0;
        *((_BYTE *)v54 + 33) = 0;
        v8 = j;
      }
    }
    for ( k = mem[1].request_virt_barray;
          k;
          k = (jvirt_barray_ptr (*)(j_common_ptr, int, boolean, JDIMENSION, JDIMENSION, JDIMENSION))*((_DWORD *)k + 9) )
    {
      if ( !*(_DWORD *)k )
      {
        v36 = *((_DWORD *)k + 1);
        v37 = *((_DWORD *)k + 3);
        v55 = k;
        if ( (int)((v36 - 1) / v37 + 1) <= v8 )
        {
          *((_DWORD *)k + 4) = v36;
          v38 = (_DWORD *)((char *)k + 8);
          v40 = cinfo;
        }
        else
        {
          v39 = *((_DWORD *)k + 2);
          v38 = (_DWORD *)((char *)k + 8);
          v38[2] = v37 * v8;
          v40 = cinfo;
          jpeg_open_backing_store(cinfo, (backing_store_ptr)(v38 + 8), (v36 * v39) << 7);
          v36 = v38[2];
          *((_BYTE *)v38 + 26) = 1;
        }
        v41 = *v38 << 7;
        v42 = 0x3B9AC9F0 / v41;
        v43 = v40->mem;
        v35 = v40;
        if ( v41 > 0x3B9AC9F0 )
        {
          v40->err->msg_code = 70;
          v40->err->error_exit(v40);
        }
        if ( (int)v42 >= v36 )
          v42 = v36;
        v43[1].access_virt_sarray = (JSAMPARRAY (*)(j_common_ptr, jvirt_sarray_ptr, JDIMENSION, JDIMENSION, boolean))v42;
        v44 = alloc_small(v40, 1, 4 * v36);
        if ( v36 )
        {
          v45 = 0;
          v59 = ~v36;
          v61 = v36;
          do
          {
            while ( 1 )
            {
              v46 = v36 - v45;
              v63 = v42;
              if ( v42 < v36 - v45 )
                v46 = v42;
              v47 = v46 * v41;
              v65 = v46;
              v48 = v35->mem;
              if ( v46 * v41 > 0x3B9AC9F0 )
              {
                v35->err->msg_code = 54;
                v35->err->msg_parm.i[0] = 3;
                v35->err->error_exit(v35);
              }
              v49 = jpeg_get_large(v35, v47 | 0x10);
              if ( !v49 )
              {
                cinfo->err->msg_code = 54;
                cinfo->err->msg_parm.i[0] = 4;
                cinfo->err->error_exit(cinfo);
              }
              v50 = v48[1].alloc_barray;
              v48[1].realize_virt_arrays = (void (*)(j_common_ptr))((char *)v48[1].realize_virt_arrays + (v47 | 0x10));
              *v49 = v50;
              v49[1] = v47;
              v49[2] = 0;
              v48[1].alloc_barray = (JBLOCKARRAY (*)(j_common_ptr, int, JDIMENSION, JDIMENSION))v49;
              v42 = v65;
              if ( v65 )
                break;
              v35 = cinfo;
              v36 = v61;
              if ( v45 >= v61 )
                goto LABEL_51;
            }
            v51 = ~v63;
            if ( v59 + v45 > ~v63 )
              v51 = v59 + v45;
            v36 = v61;
            v52 = v51 + 1;
            v53 = v49 + 4;
            v35 = cinfo;
            do
            {
              v44[v45] = v53;
              v53 = (_DWORD *)((char *)v53 + v41);
              ++v52;
              ++v45;
            }
            while ( v52 );
          }
          while ( v45 < v61 );
        }
LABEL_51:
        k = v55;
        *(_DWORD *)v55 = v44;
        *((_DWORD *)v55 + 5) = mem[1].access_virt_sarray;
        *((_DWORD *)v55 + 6) = 0;
        *((_DWORD *)v55 + 7) = 0;
        *((_BYTE *)v55 + 33) = 0;
        v8 = j;
      }
    }
  }
}

//----- (004816AA) --------------------------------------------------------
JSAMPARRAY __fastcall access_virt_sarray(
        j_common_ptr cinfo,
        jvirt_sarray_ptr ptr,
        JDIMENSION start_row,
        JDIMENSION num_rows,
        int a5)
{
  jpeg_common_struct *v6; // r8
  JDIMENSION cur_start_row; // r0
  signed int rows_in_mem; // r0
  __int64 v10; // kr00_8
  JDIMENSION first_undef_row; // r6
  JDIMENSION samplesperrow; // r6
  int v13; // r11
  int v14; // r4
  int v15; // r8
  __int64 v16; // r0
  __int64 v17; // kr08_8
  signed int rowsperchunk; // r0
  JDIMENSION v19; // r1
  JDIMENSION v20; // r9
  int v21; // r6
  int v22; // r4
  int v23; // r5
  __int64 v24; // r0
  JDIMENSION rows_in_array; // r12
  __int64 v26; // kr10_8
  JDIMENSION v27; // r0
  int v28; // r1
  JDIMENSION v29; // r1
  size_t v30; // r4
  int v31; // r5
  JDIMENSION v32; // r6
  JDIMENSION v34; // [sp+8h] [bp-28h]
  JDIMENSION v35; // [sp+Ch] [bp-24h]
  jpeg_common_struct *v36; // [sp+10h] [bp-20h]

  v6 = cinfo;
  v35 = num_rows + start_row;
  if ( num_rows + start_row > ptr->rows_in_array || ptr->maxaccess < num_rows || !ptr->mem_buffer )
  {
    cinfo->err->msg_code = 22;
    cinfo->err->error_exit(cinfo);
  }
  cur_start_row = ptr->cur_start_row;
  v34 = start_row;
  v36 = v6;
  if ( cur_start_row > start_row || v35 > cur_start_row + ptr->rows_in_mem )
  {
    if ( !ptr->b_s_open )
    {
      v6->err->msg_code = 69;
      v6->err->error_exit(v6);
    }
    if ( ptr->dirty )
    {
      rows_in_mem = ptr->rows_in_mem;
      if ( rows_in_mem >= 1 )
      {
        v10 = *(_QWORD *)&ptr->rowsperchunk;
        first_undef_row = ptr->first_undef_row;
        if ( (int)v10 < rows_in_mem )
          rows_in_mem = ptr->rowsperchunk;
        if ( rows_in_mem >= (int)(first_undef_row - HIDWORD(v10)) )
          rows_in_mem = first_undef_row - HIDWORD(v10);
        if ( rows_in_mem >= (signed int)(ptr->rows_in_array - HIDWORD(v10)) )
          rows_in_mem = ptr->rows_in_array - HIDWORD(v10);
        if ( rows_in_mem >= 1 )
        {
          samplesperrow = ptr->samplesperrow;
          v13 = 0;
          v14 = HIDWORD(v10) * samplesperrow;
          do
          {
            v15 = rows_in_mem * samplesperrow;
            ptr->b_s_info.write_backing_store(
              v36,
              &ptr->b_s_info,
              ptr->mem_buffer[v13],
              v14,
              rows_in_mem * samplesperrow);
            v16 = *(_QWORD *)&ptr->rows_in_mem;
            v13 += HIDWORD(v16);
            if ( (int)v16 <= v13 )
              break;
            rows_in_mem = v16 - v13;
            v17 = *(_QWORD *)&ptr->cur_start_row;
            if ( SHIDWORD(v16) < rows_in_mem )
              rows_in_mem = ptr->rowsperchunk;
            v14 += v15;
            if ( rows_in_mem >= HIDWORD(v17) - (v13 + (int)v17) )
              rows_in_mem = HIDWORD(v17) - (v13 + v17);
            if ( rows_in_mem >= (signed int)(ptr->rows_in_array - (v13 + v17)) )
              rows_in_mem = ptr->rows_in_array - (v13 + v17);
          }
          while ( rows_in_mem > 0 );
        }
      }
      ptr->dirty = 0;
      v6 = v36;
    }
    rowsperchunk = ptr->rows_in_mem;
    v19 = v34;
    if ( ptr->cur_start_row >= v34 )
    {
      v19 = v35 - rowsperchunk;
      if ( (int)(v35 - rowsperchunk) <= 0 )
        v19 = 0;
    }
    v20 = ptr->samplesperrow;
    ptr->cur_start_row = v19;
    if ( rowsperchunk >= 1 )
    {
      if ( (signed int)ptr->rowsperchunk < rowsperchunk )
        rowsperchunk = ptr->rowsperchunk;
      if ( rowsperchunk >= (int)(ptr->first_undef_row - v19) )
        rowsperchunk = ptr->first_undef_row - v19;
      if ( rowsperchunk >= (int)(ptr->rows_in_array - v19) )
        rowsperchunk = ptr->rows_in_array - v19;
      if ( rowsperchunk >= 1 )
      {
        v21 = v20 * v19;
        v22 = 0;
        do
        {
          v23 = rowsperchunk * v20;
          ptr->b_s_info.read_backing_store(v6, &ptr->b_s_info, ptr->mem_buffer[v22], v21, rowsperchunk * v20);
          v24 = *(_QWORD *)&ptr->rows_in_mem;
          v22 += HIDWORD(v24);
          if ( (int)v24 <= v22 )
            break;
          rowsperchunk = v24 - v22;
          v26 = *(_QWORD *)&ptr->cur_start_row;
          if ( SHIDWORD(v24) < rowsperchunk )
            rowsperchunk = ptr->rowsperchunk;
          v21 += v23;
          rows_in_array = ptr->rows_in_array;
          if ( rowsperchunk >= HIDWORD(v26) - (v22 + (int)v26) )
            rowsperchunk = HIDWORD(v26) - (v22 + v26);
          if ( rowsperchunk >= (int)(rows_in_array - (v22 + v26)) )
            rowsperchunk = rows_in_array - (v22 + v26);
        }
        while ( rowsperchunk > 0 );
      }
    }
  }
  v27 = ptr->first_undef_row;
  if ( v27 < v35 )
  {
    if ( v27 >= v34 )
    {
      if ( a5 )
        goto LABEL_53;
      v28 = 0;
    }
    else
    {
      if ( a5 )
      {
        v36->err->msg_code = 22;
        v36->err->error_exit(v36);
        v27 = v34;
LABEL_53:
        v28 = 1;
        ptr->first_undef_row = v35;
        goto LABEL_56;
      }
      v28 = 0;
      v27 = v34;
    }
LABEL_56:
    if ( ptr->pre_zero )
    {
      v29 = ptr->cur_start_row;
      if ( v27 - v29 < v35 - v29 )
      {
        v30 = ptr->samplesperrow;
        v31 = 4 * v27 - 4 * v29;
        v32 = v35 - v27;
        do
        {
          jzero_far(*(void **)((char *)ptr->mem_buffer + v31), v30);
          --v32;
          v31 += 4;
        }
        while ( v32 );
      }
    }
    else if ( !v28 )
    {
      v36->err->msg_code = 22;
      v36->err->error_exit(v36);
    }
  }
  if ( a5 )
    ptr->dirty = 1;
  return &ptr->mem_buffer[v34 - ptr->cur_start_row];
}

//----- (00481910) --------------------------------------------------------
JBLOCKARRAY __fastcall access_virt_barray(j_common_ptr cinfo, jvirt_barray_ptr ptr, JDIMENSION start_row, JDIMENSION num_rows, int a5)
{
  jpeg_common_struct *v6; // r8
  JDIMENSION cur_start_row; // r0
  signed int rows_in_mem; // r0
  __int64 v10; // kr00_8
  JDIMENSION first_undef_row; // r6
  int v12; // r11
  JDIMENSION v13; // r6
  int v14; // r4
  int v15; // r8
  __int64 v16; // r0
  __int64 v17; // kr08_8
  signed int rowsperchunk; // r0
  JDIMENSION v19; // r1
  JDIMENSION blocksperrow; // r2
  JDIMENSION v21; // r11
  int v22; // r6
  int v23; // r4
  int v24; // r5
  __int64 v25; // r0
  JDIMENSION rows_in_array; // r12
  __int64 v27; // kr10_8
  JDIMENSION v28; // r0
  int v29; // r1
  JDIMENSION v30; // r1
  JDIMENSION v31; // r6
  size_t v32; // r4
  int v33; // r5
  JDIMENSION v35; // [sp+8h] [bp-28h]
  JDIMENSION v36; // [sp+Ch] [bp-24h]
  jpeg_common_struct *v37; // [sp+10h] [bp-20h]

  v6 = cinfo;
  v36 = num_rows + start_row;
  if ( num_rows + start_row > ptr->rows_in_array || ptr->maxaccess < num_rows || !ptr->mem_buffer )
  {
    cinfo->err->msg_code = 22;
    cinfo->err->error_exit(cinfo);
  }
  cur_start_row = ptr->cur_start_row;
  v35 = start_row;
  v37 = v6;
  if ( cur_start_row > start_row || v36 > cur_start_row + ptr->rows_in_mem )
  {
    if ( !ptr->b_s_open )
    {
      v6->err->msg_code = 69;
      v6->err->error_exit(v6);
    }
    if ( ptr->dirty )
    {
      rows_in_mem = ptr->rows_in_mem;
      if ( rows_in_mem >= 1 )
      {
        v10 = *(_QWORD *)&ptr->rowsperchunk;
        first_undef_row = ptr->first_undef_row;
        if ( (int)v10 < rows_in_mem )
          rows_in_mem = ptr->rowsperchunk;
        if ( rows_in_mem >= (int)(first_undef_row - HIDWORD(v10)) )
          rows_in_mem = first_undef_row - HIDWORD(v10);
        if ( rows_in_mem >= (signed int)(ptr->rows_in_array - HIDWORD(v10)) )
          rows_in_mem = ptr->rows_in_array - HIDWORD(v10);
        if ( rows_in_mem >= 1 )
        {
          v12 = 0;
          v13 = ptr->blocksperrow << 7;
          v14 = HIDWORD(v10) * v13;
          do
          {
            v15 = rows_in_mem * v13;
            ptr->b_s_info.write_backing_store(v37, &ptr->b_s_info, ptr->mem_buffer[v12], v14, rows_in_mem * v13);
            v16 = *(_QWORD *)&ptr->rows_in_mem;
            v12 += HIDWORD(v16);
            if ( (int)v16 <= v12 )
              break;
            rows_in_mem = v16 - v12;
            v17 = *(_QWORD *)&ptr->cur_start_row;
            if ( SHIDWORD(v16) < rows_in_mem )
              rows_in_mem = ptr->rowsperchunk;
            v14 += v15;
            if ( rows_in_mem >= HIDWORD(v17) - (v12 + (int)v17) )
              rows_in_mem = HIDWORD(v17) - (v12 + v17);
            if ( rows_in_mem >= (signed int)(ptr->rows_in_array - (v12 + v17)) )
              rows_in_mem = ptr->rows_in_array - (v12 + v17);
          }
          while ( rows_in_mem > 0 );
        }
      }
      ptr->dirty = 0;
      v6 = v37;
    }
    rowsperchunk = ptr->rows_in_mem;
    v19 = v35;
    if ( ptr->cur_start_row >= v35 )
    {
      v19 = v36 - rowsperchunk;
      if ( (int)(v36 - rowsperchunk) <= 0 )
        v19 = 0;
    }
    blocksperrow = ptr->blocksperrow;
    ptr->cur_start_row = v19;
    if ( rowsperchunk >= 1 )
    {
      if ( (signed int)ptr->rowsperchunk < rowsperchunk )
        rowsperchunk = ptr->rowsperchunk;
      if ( rowsperchunk >= (int)(ptr->first_undef_row - v19) )
        rowsperchunk = ptr->first_undef_row - v19;
      if ( rowsperchunk >= (int)(ptr->rows_in_array - v19) )
        rowsperchunk = ptr->rows_in_array - v19;
      if ( rowsperchunk >= 1 )
      {
        v21 = blocksperrow << 7;
        v22 = (blocksperrow << 7) * v19;
        v23 = 0;
        do
        {
          v24 = rowsperchunk * v21;
          ptr->b_s_info.read_backing_store(v6, &ptr->b_s_info, ptr->mem_buffer[v23], v22, rowsperchunk * v21);
          v25 = *(_QWORD *)&ptr->rows_in_mem;
          v23 += HIDWORD(v25);
          if ( (int)v25 <= v23 )
            break;
          rowsperchunk = v25 - v23;
          v27 = *(_QWORD *)&ptr->cur_start_row;
          if ( SHIDWORD(v25) < rowsperchunk )
            rowsperchunk = ptr->rowsperchunk;
          v22 += v24;
          rows_in_array = ptr->rows_in_array;
          if ( rowsperchunk >= HIDWORD(v27) - (v23 + (int)v27) )
            rowsperchunk = HIDWORD(v27) - (v23 + v27);
          if ( rowsperchunk >= (int)(rows_in_array - (v23 + v27)) )
            rowsperchunk = rows_in_array - (v23 + v27);
        }
        while ( rowsperchunk > 0 );
      }
    }
  }
  v28 = ptr->first_undef_row;
  if ( v28 < v36 )
  {
    if ( v28 >= v35 )
    {
      if ( a5 )
        goto LABEL_53;
      v29 = 0;
    }
    else
    {
      if ( a5 )
      {
        v37->err->msg_code = 22;
        v37->err->error_exit(v37);
        v28 = v35;
LABEL_53:
        v29 = 1;
        ptr->first_undef_row = v36;
        goto LABEL_56;
      }
      v29 = 0;
      v28 = v35;
    }
LABEL_56:
    if ( ptr->pre_zero )
    {
      v30 = ptr->cur_start_row;
      if ( v28 - v30 < v36 - v30 )
      {
        v31 = v36 - v28;
        v32 = ptr->blocksperrow << 7;
        v33 = 4 * v28 - 4 * v30;
        do
        {
          jzero_far(*(void **)((char *)ptr->mem_buffer + v33), v32);
          --v31;
          v33 += 4;
        }
        while ( v31 );
      }
    }
    else if ( !v29 )
    {
      v37->err->msg_code = 22;
      v37->err->error_exit(v37);
    }
  }
  if ( a5 )
    ptr->dirty = 1;
  return &ptr->mem_buffer[v35 - ptr->cur_start_row];
}

//----- (00481B7E) --------------------------------------------------------
void __fastcall free_pool(j_common_ptr cinfo, int pool_id)
{
  jpeg_memory_mgr *mem; // r6
  jvirt_sarray_ptr (*i)(j_common_ptr, int, boolean, JDIMENSION, JDIMENSION, JDIMENSION); // r5
  jvirt_barray_ptr (*request_virt_barray)(j_common_ptr, int, boolean, JDIMENSION, JDIMENSION, JDIMENSION); // r5
  void *(**v7)(j_common_ptr, int, size_t); // r8
  void *(*v8)(j_common_ptr, int, size_t); // r1
  __int64 v9; // kr00_8
  size_t v10; // r5
  void *(*v11)(j_common_ptr, int, size_t); // r1
  __int64 v12; // kr08_8
  size_t v13; // r5

  mem = cinfo->mem;
  if ( (unsigned int)pool_id < 2 )
  {
    if ( pool_id == 1 )
    {
      for ( i = mem[1].request_virt_sarray;
            i;
            i = (jvirt_sarray_ptr (*)(j_common_ptr, int, boolean, JDIMENSION, JDIMENSION, JDIMENSION))*((_DWORD *)i + 9) )
      {
        if ( *((_BYTE *)i + 34) )
        {
          *((_BYTE *)i + 34) = 0;
          (*((void (__fastcall **)(j_common_ptr, int))i + 12))(cinfo, (int)i + 40);
        }
      }
      request_virt_barray = mem[1].request_virt_barray;
      for ( mem[1].request_virt_sarray = 0;
            request_virt_barray;
            request_virt_barray = (jvirt_barray_ptr (*)(j_common_ptr, int, boolean, JDIMENSION, JDIMENSION, JDIMENSION))*((_DWORD *)request_virt_barray + 9) )
      {
        if ( *((_BYTE *)request_virt_barray + 34) )
        {
          *((_BYTE *)request_virt_barray + 34) = 0;
          (*((void (__fastcall **)(j_common_ptr, int))request_virt_barray + 12))(cinfo, (int)request_virt_barray + 40);
        }
      }
      mem[1].request_virt_barray = 0;
    }
  }
  else
  {
    cinfo->err->msg_code = 14;
    cinfo->err->msg_parm.i[0] = pool_id;
    cinfo->err->error_exit(cinfo);
  }
  v7 = &mem->alloc_small + pool_id;
  v8 = v7[15];
  v7[15] = 0;
  if ( v8 )
  {
    do
    {
      v9 = *(_QWORD *)v8;
      v10 = *((_DWORD *)v8 + 1) + *((_DWORD *)v8 + 2) + 16;
      jpeg_free_large(cinfo, v8, v10);
      v8 = (void *(*)(j_common_ptr, int, size_t))v9;
      mem[1].realize_virt_arrays = (void (*)(j_common_ptr))((char *)mem[1].realize_virt_arrays - v10);
    }
    while ( (_DWORD)v9 );
  }
  v11 = v7[13];
  v7[13] = 0;
  if ( v11 )
  {
    do
    {
      v12 = *(_QWORD *)v11;
      v13 = *((_DWORD *)v11 + 1) + *((_DWORD *)v11 + 2) + 16;
      jpeg_free_small(cinfo, v11, v13);
      v11 = (void *(*)(j_common_ptr, int, size_t))v12;
      mem[1].realize_virt_arrays = (void (*)(j_common_ptr))((char *)mem[1].realize_virt_arrays - v13);
    }
    while ( (_DWORD)v12 );
  }
}

//----- (00481C6C) --------------------------------------------------------
void __fastcall self_destruct(j_common_ptr cinfo)
{
  free_pool(cinfo, 1);
  free_pool(cinfo, 0);
  jpeg_free_small(cinfo, cinfo->mem, 0x54u);
  cinfo->mem = 0;
  sub_18E8C4(cinfo);
}

//----- (00481C98) --------------------------------------------------------
void *__fastcall jpeg_get_small(j_common_ptr cinfo, size_t sizeofobject)
{
  return sub_19CF40(sizeofobject);
}

//----- (00481C9E) --------------------------------------------------------
void __fastcall jpeg_free_small(j_common_ptr cinfo, void *object, size_t sizeofobject)
{
  sub_193D14(object);
}

//----- (00481CA4) --------------------------------------------------------
void *__fastcall jpeg_get_large(j_common_ptr cinfo, size_t sizeofobject)
{
  return sub_19CF40(sizeofobject);
}

//----- (00481CAA) --------------------------------------------------------
void __fastcall jpeg_free_large(j_common_ptr cinfo, void *object, size_t sizeofobject)
{
  sub_193D14(object);
}

//----- (00481CB0) --------------------------------------------------------
int __fastcall jpeg_mem_available(
        j_common_ptr cinfo,
        int min_bytes_needed,
        int max_bytes_needed,
        int already_allocated)
{
  return max_bytes_needed;
}

//----- (00481CB4) --------------------------------------------------------
void __fastcall jpeg_open_backing_store(j_common_ptr cinfo, backing_store_ptr info, int total_bytes_needed)
{
  cinfo->err->msg_code = 49;
  cinfo->err->error_exit(cinfo);
}

//----- (00481CC0) --------------------------------------------------------
int __fastcall jpeg_mem_init(j_common_ptr cinfo)
{
  return 0;
}

//----- (00481CCC) --------------------------------------------------------
void __fastcall BufferInitDestination(j_compress_ptr cinfo)
{
  cinfo->dest->next_output_byte = jpegBuffer;
  cinfo->dest->free_in_buffer = 204800;
}

//----- (00481CE4) --------------------------------------------------------
boolean __fastcall BufferEmptyOutputBuffer(j_compress_ptr cinfo)
{
  unsigned int v2; // r5

  v2 = g_tmp_buffer_offset + 204800;
  if ( g_tmp_buffer_offset + 204800 < g_tmp_buffer_size )
  {
    qmemcpy(&(*g_tmp_buffer)[g_tmp_buffer_offset], jpegBuffer, 0x32000u);
    g_tmp_buffer_offset = v2;
  }
  cinfo->dest->next_output_byte = jpegBuffer;
  cinfo->dest->free_in_buffer = 204800;
  return 1;
}

//----- (00481D50) --------------------------------------------------------
void __fastcall BufferTermDestination(j_compress_ptr cinfo)
{
  JOCTET *next_output_byte; // r3

  next_output_byte = cinfo->dest->next_output_byte;
  if ( g_tmp_buffer_offset + next_output_byte - jpegBuffer < g_tmp_buffer_size )
  {
    qmemcpy(&(*g_tmp_buffer)[g_tmp_buffer_offset], jpegBuffer, next_output_byte - jpegBuffer);
    g_tmp_buffer_offset += 204800;
  }
}

//----- (00481DBC) --------------------------------------------------------
void __fastcall JPegCompressScreenToBuffer(RwCamera_0 *pCamera, unsigned __int8 **buffer, unsigned int *size)
{
  jpeg_destination_mgr dest_mgr; // [sp+4h] [bp-2Ch] BYREF

  g_tmp_buffer = buffer;
  g_tmp_buffer_size = *size;
  g_tmp_buffer_offset = 0;
  dest_mgr.init_destination = BufferInitDestination;
  dest_mgr.empty_output_buffer = BufferEmptyOutputBuffer;
  dest_mgr.term_destination = BufferTermDestination;
  JPegCompressScreen(pCamera, &dest_mgr);
  *size = g_tmp_buffer_offset;
}

//----- (00481E3C) --------------------------------------------------------
void __fastcall JPegCompressScreen(RwCamera_0 *pCamera, jpeg_destination_mgr *dest_mgr)
{
  RwImage_0 *v3; // r4
  JSAMPLE *cpPixels; // r5
  int v5; // r6
  JSAMPROW v6; // [sp+0h] [bp-210h] BYREF
  jpeg_error_mgr err; // [sp+4h] [bp-20Ch] BYREF
  jpeg_compress_struct cinfo; // [sp+88h] [bp-188h] BYREF

  v3 = RsGrabScreen(pCamera);
  cinfo.err = jpeg_std_error(&err);
  jpeg_CreateCompress(&cinfo, 62, 0x168u);
  cinfo.in_color_space = JCS_RGB;
  jpeg_set_defaults(&cinfo);
  cinfo.image_width = v3->width;
  cinfo.image_height = v3->height;
  cinfo.input_components = 4;
  cinfo.dct_method = JDCT_FLOAT;
  cinfo.dest = dest_mgr;
  jpeg_start_compress(&cinfo, 1u);
  cpPixels = v3->cpPixels;
  v6 = cpPixels;
  if ( cinfo.next_scanline < cinfo.image_height )
  {
    v5 = 0;
    do
    {
      v6 = &cpPixels[v5 * v3->width];
      if ( jpeg_write_scanlines(&cinfo, &v6, 1u) != 1 )
        break;
      v5 += 4;
    }
    while ( cinfo.next_scanline < cinfo.image_height );
  }
  jpeg_finish_compress(&cinfo);
  jpeg_destroy_compress(&cinfo);
  if ( v3 )
    RwImageDestroy(v3);
}

//----- (00481F00) --------------------------------------------------------
boolean __fastcall BufferFillInputBuffer(j_decompress_ptr cinfo)
{
  int32 v2; // r6

  v2 = gBufferId;
  qmemcpy(jpegBuffer, &FrontEndMenuManager.gallery_image_buffer[gBufferId], sizeof(jpegBuffer));
  cinfo->src->next_input_byte = jpegBuffer;
  cinfo->src->bytes_in_buffer = 204800;
  gBufferId = v2 + 204800;
  return 1;
}

//----- (00481F5C) --------------------------------------------------------
bool8 __fastcall JPegDecompressToVramFromBuffer(RwRaster_0 *pRaster, unsigned __int8 **buffer)
{
  bool8 result; // r0
  jpeg_source_mgr src_mgr; // [sp+4h] [bp-2Ch] BYREF

  result = 0;
  if ( buffer )
  {
    gBufferId = 0;
    qmemcpy(jpegBuffer, FrontEndMenuManager.gallery_image_buffer, sizeof(jpegBuffer));
    src_mgr.init_source = InitSource;
    src_mgr.fill_input_buffer = BufferFillInputBuffer;
    src_mgr.skip_input_data = BufferSkipInputData;
    src_mgr.resync_to_restart = jpeg_resync_to_restart;
    src_mgr.term_source = TermSource;
    src_mgr.next_input_byte = jpegBuffer;
    JPegDecompressToRaster(pRaster, &src_mgr);
    return 1;
  }
  return result;
}

//----- (00481FE4) --------------------------------------------------------
bool8 __fastcall JPegDecompressToRaster(RwRaster_0 *pRaster, jpeg_source_mgr *src_mgr)
{
  bool8 v4; // r5
  int i; // r8
  JSAMPROW scanlines; // [sp+4h] [bp-25Ch] BYREF
  RwRGBA_0 v8; // [sp+8h] [bp-258h] BYREF
  jpeg_error_mgr err; // [sp+Ch] [bp-254h] BYREF
  jpeg_decompress_struct cinfo; // [sp+90h] [bp-1D0h] BYREF

  cinfo.err = jpeg_std_error(&err);
  jpeg_CreateDecompress(&cinfo, 62, 0x1B0u);
  cinfo.src = src_mgr;
  if ( jpeg_read_header(&cinfo, 1u) == 1 && (cinfo.dct_method = JDCT_FLOAT, jpeg_start_decompress(&cinfo)) )
  {
    v4 = 0;
    pDst = (uint32 *)RwRasterLock(pRaster, 0, 1);
    if ( cinfo.output_scanline >= cinfo.output_height )
    {
      RwRasterUnlock(pRaster);
    }
    else
    {
      while ( 1 )
      {
        scanlines = gJPegScanline;
        if ( jpeg_read_scanlines(&cinfo, &scanlines, 1u) != 1 )
          break;
        for ( i = 0; i != 2048; i += 4 )
        {
          CRGBA::CRGBA((CRGBA *)&v8, gJPegScanline[i + 256], gJPegScanline[i + 257], gJPegScanline[i + 258], 0xFFu);
          *pDst++ = RwRGBAToPixel(&v8, pRaster->cFormat << 8);
        }
        if ( cinfo.output_scanline >= cinfo.output_height )
        {
          RwRasterUnlock(pRaster);
          pDst = 0;
          jpeg_finish_decompress(&cinfo);
          v4 = 1;
          goto LABEL_13;
        }
      }
      RwRasterUnlock(pRaster);
      v4 = 0;
    }
    pDst = 0;
LABEL_13:
    jpeg_destroy_decompress(&cinfo);
  }
  else
  {
    jpeg_destroy_decompress(&cinfo);
    return 0;
  }
  return v4;
}

//----- (0048214C) --------------------------------------------------------
boolean __fastcall HDFillInputBuffer(j_decompress_ptr cinfo)
{
  signed int old; // r0

  old = CFileMgr::Read_old(gFileId, jpegBuffer, 204800);
  if ( old < 1 )
    return 0;
  cinfo->src->next_input_byte = jpegBuffer;
  cinfo->src->bytes_in_buffer = old;
  return 1;
}

//----- (00482188) --------------------------------------------------------
void __fastcall HDSkipInputData(j_decompress_ptr cinfo, int numBytes)
{
  sub_19059C(gFileId, numBytes, 1);
}

//----- (00482198) --------------------------------------------------------
void __fastcall InitDestination(j_compress_ptr cinfo)
{
  cinfo->dest->next_output_byte = jpegBuffer;
  cinfo->dest->free_in_buffer = 204800;
}

//----- (004821B0) --------------------------------------------------------
boolean __fastcall HDEmptyOutputBuffer(j_compress_ptr cinfo)
{
  CFileMgr::Write(gFileId, jpegBuffer, 204800);
  cinfo->dest->next_output_byte = jpegBuffer;
  cinfo->dest->free_in_buffer = 204800;
  return 1;
}

//----- (004821EC) --------------------------------------------------------
void __fastcall HDTermDestination(j_compress_ptr cinfo)
{
  int32 v1; // r2

  v1 = cinfo->dest->next_output_byte - jpegBuffer;
  if ( v1 >= 1 )
    sub_18FEC0(gFileId, jpegBuffer, v1);
}

//----- (00482218) --------------------------------------------------------
void __fastcall JPegCompressScreenToFile(RwCamera_0 *pCamera, const unsigned __int8 *pFilename)
{
  jpeg_destination_mgr dest_mgr; // [sp+4h] [bp-1Ch] BYREF

  gFileId = CFileMgr::OpenFile(pFilename, (const unsigned __int8 *)&dword_482264);
  if ( gFileId )
  {
    dest_mgr.init_destination = InitDestination;
    dest_mgr.empty_output_buffer = HDEmptyOutputBuffer;
    dest_mgr.term_destination = HDTermDestination;
    JPegCompressScreen(pCamera, &dest_mgr);
    CFileMgr::CloseFile(gFileId);
  }
}
// 482264: using guessed type int dword_482264;

//----- (0048227C) --------------------------------------------------------
bool __fastcall CopyCameraRasterScanlineToTexture(RwRaster_0 *pRaster, int32 scanline, uint32 start_x, uint32 end_x)
{
  uint32 v5; // r6
  uint8 *v6; // r4
  CRGBA v8; // [sp+4h] [bp-1Ch] BYREF

  if ( start_x < end_x )
  {
    v5 = end_x - start_x;
    v6 = &gJPegScanline[4 * start_x + 1];
    do
    {
      CRGBA::CRGBA(&v8, *(v6 - 1), *v6, v6[1], 0xFFu);
      v6 += 4;
      --v5;
      *pDst++ = RwRGBAToPixel(&v8, pRaster->cFormat << 8);
    }
    while ( v5 );
  }
  return 1;
}

//----- (004822E8) --------------------------------------------------------
int __fastcall jdiv_round_up(int a, int b)
{
  return sub_1912A8(a + b - 1, b);
}
// 1912A8: using guessed type int __fastcall sub_1912A8(_DWORD, _DWORD);

//----- (004822F0) --------------------------------------------------------
int __fastcall jround_up(int a, int b)
{
  return a + b - 1 - (a + b - 1) % b;
}

//----- (00482302) --------------------------------------------------------
void __fastcall jcopy_sample_rows(
        JSAMPARRAY input_array,
        int source_row,
        JSAMPARRAY output_array,
        int dest_row,
        int a5,
        size_t a6)
{
  const void **v6; // r5
  JSAMPROW *v7; // r6
  int v8; // r4
  void *v9; // r0
  void *v10; // t1
  const void *v11; // t1

  if ( a5 >= 1 )
  {
    v6 = (const void **)&input_array[source_row];
    v7 = &output_array[dest_row];
    v8 = a5 + 1;
    do
    {
      v10 = *v7++;
      v9 = v10;
      v11 = *v6++;
      qmemcpy(v9, v11, a6);
      --v8;
    }
    while ( v8 > 1 );
  }
}

//----- (00482338) --------------------------------------------------------
void __fastcall jcopy_block_row(JBLOCKROW input_row, JBLOCKROW output_row, JDIMENSION num_blocks)
{
  sub_19EA98(output_row, input_row, num_blocks << 7);
}

//----- (00482344) --------------------------------------------------------
void __fastcall jzero_far(void *target, size_t bytestozero)
{
  memset(target, 0, bytestozero);
}

//----- (00482350) --------------------------------------------------------
bool NodeNamePluginAttach()
{
  gPluginOffset = RwFrameRegisterPlugin(24, 0x253F2FEu, NodeNameConstructor, NodeNameDestructor, NodeNameCopy);
  RwFrameRegisterPluginStream(0x253F2FEu, NodeNameStreamRead, NodeNameStreamWrite, NodeNameStreamGetSize);
  return gPluginOffset != -1;
}

//----- (004823B8) --------------------------------------------------------
void *__fastcall NodeNameConstructor(void *frame, RwInt32 offset, RwInt32 size)
{
  if ( gPluginOffset >= 1 )
    *((_BYTE *)frame + gPluginOffset) = 0;
  return frame;
}

//----- (004823D0) --------------------------------------------------------
void *__fastcall NodeNameCopy(void *pDst, const void *pSrc, RwInt32 offset, RwInt32 size)
{
  strncpy((char *)pDst + gPluginOffset, (const char *)pSrc + gPluginOffset, 0x17u);
  return pDst;
}

//----- (004823F0) --------------------------------------------------------
RwStream_0 *__fastcall NodeNameStreamRead(RwStream_0 *pStream, RwInt32 len, void *pData, RwInt32 offset, RwInt32 size)
{
  char *v7; // r6

  v7 = (char *)pData + gPluginOffset;
  RwStreamRead(pStream, (char *)pData + gPluginOffset, len);
  v7[len] = 0;
  return pStream;
}

//----- (00482420) --------------------------------------------------------
RwStream_0 *__fastcall NodeNameStreamWrite(
        RwStream_0 *pStream,
        RwInt32 len,
        const void *pData,
        RwInt32 offset,
        RwInt32 size)
{
  RwStreamWrite(pStream, (char *)pData + gPluginOffset, len);
  return pStream;
}

//----- (00482440) --------------------------------------------------------
RwInt32 __fastcall NodeNameStreamGetSize(const void *pData, RwInt32 offset, RwInt32 size)
{
  if ( (char *)pData + gPluginOffset )
    return (*((int (**)(void))RwEngineInstance + 70))();
  else
    return 0;
}

//----- (00482464) --------------------------------------------------------
void __fastcall SetFrameNodeName(RwFrame_0 *pFrame, const unsigned __int8 *pName)
{
  RwUInt8 *v2; // r4

  if ( gPluginOffset >= 1 )
  {
    v2 = &pFrame->object.type + gPluginOffset;
    strncpy((char *)&pFrame->object.type + gPluginOffset, (const char *)pName, 0x17u);
    v2[23] = 0;
  }
}

//----- (0048248C) --------------------------------------------------------
const unsigned __int8 *__fastcall GetFrameNodeName(RwFrame_0 *pFrame)
{
  const unsigned __int8 *v1; // r1

  v1 = 0;
  if ( gPluginOffset > 0 )
    return &pFrame->object.type + gPluginOffset;
  return v1;
}

//----- (004824A4) --------------------------------------------------------
bool PipelinePluginAttach()
{
  int v0; // r4

  v0 = 0;
  gPluginOffset = RpAtomicRegisterPlugin(4, 0x253F2F3u, PipelineConstructor, 0, PipelineCopy);
  if ( gPluginOffset != -1 )
  {
    if ( RpAtomicRegisterPluginStream(0x253F2F3u, PipelineStreamRead, PipelineStreamWrite, PipelineStreamGetSize) < 0 )
    {
      v0 = 0;
      gPluginOffset = -1;
    }
    else
    {
      return gPluginOffset != -1;
    }
  }
  return v0;
}

//----- (0048252C) --------------------------------------------------------
void *__fastcall PipelineConstructor(void *atomic, RwInt32 offset, RwInt32 size)
{
  if ( gPluginOffset >= 1 )
    *(_DWORD *)((char *)atomic + gPluginOffset) = 0;
  return atomic;
}

//----- (00482540) --------------------------------------------------------
void *__fastcall PipelineCopy(void *pDst, const void *pSrc, RwInt32 offset, RwInt32 size)
{
  *(_DWORD *)((char *)pDst + gPluginOffset) = *(_DWORD *)((char *)pSrc + gPluginOffset);
  return pDst;
}

//----- (00482550) --------------------------------------------------------
RwStream_0 *__fastcall PipelineStreamRead(RwStream_0 *pStream, RwInt32 len, void *pData, RwInt32 offset, RwInt32 size)
{
  RwStreamRead(pStream, (char *)pData + gPluginOffset, len);
  return pStream;
}

//----- (00482570) --------------------------------------------------------
RwStream_0 *__fastcall PipelineStreamWrite(
        RwStream_0 *pStream,
        RwInt32 len,
        const void *pData,
        RwInt32 offset,
        RwInt32 size)
{
  RwStreamWrite(pStream, (char *)pData + gPluginOffset, len);
  return pStream;
}

//----- (00482590) --------------------------------------------------------
RwInt32 __fastcall PipelineStreamGetSize(const void *pData, RwInt32 offset, RwInt32 size)
{
  RwInt32 result; // r0

  result = *(_DWORD *)((char *)pData + gPluginOffset);
  if ( result )
    return 4;
  return result;
}

//----- (004825A4) --------------------------------------------------------
uint32 __fastcall GetPipelineID(RpAtomic_0 *pAtomic)
{
  return *(_DWORD *)(&pAtomic->object.object.type + gPluginOffset);
}

//----- (004825B4) --------------------------------------------------------
uint32 __fastcall SetPipelineID(RpAtomic_0 *pAtomic, uint32 pipelineID)
{
  *(_DWORD *)(&pAtomic->object.object.type + gPluginOffset) = pipelineID;
  return pipelineID;
}

//----- (004825C4) --------------------------------------------------------
bool __fastcall CGenericGameStorage::GenericSave(int SlotNum)
{
  int v1; // r5
  bool v2; // r4
  CSimpleVariablesSaveStructure *v3; // r10
  _BOOL4 v5; // r4
  int32 v6; // r5
  _BOOL4 v7; // [sp+0h] [bp-1D0h]
  bool v8; // [sp+4h] [bp-1CCh]
  CSimpleVariablesSaveStructure v9; // [sp+8h] [bp-1C8h] BYREF

  ResetFenceCount();
  CGenericGameStorage::ms_bFailed = 0;
  CGenericGameStorage::ms_FileHandle = CFileMgr::OpenFile(
                                         CGenericGameStorage::ms_ValidSaveName,
                                         (const unsigned __int8 *)&dword_4828EC);
  if ( !CGenericGameStorage::ms_FileHandle )
  {
    PcSaveHelper.ErrorCode = 4;
    return 0;
  }
  CGenericGameStorage::ms_WorkBufferPos = 0;
  CGenericGameStorage::ms_FilePos = 0;
  if ( !CGenericGameStorage::_ms_WorkBuffer )
  {
    CGenericGameStorage::_ms_WorkBuffer = (uint8 *)operator new[](0xFDE9u);
    CGenericGameStorage::ms_WorkBuffer.data = CGenericGameStorage::_ms_WorkBuffer;
    CGenericGameStorage::ms_WorkBuffer.size = 65001;
  }
  v1 = -1;
  CGenericGameStorage::ms_CheckSum = 0;
  do
  {
    v2 = UseDataFence;
    UseDataFence = 0;
    if ( !CGenericGameStorage::_SaveDataToWorkBuffer(CGenericGameStorage::ms_BlockTagName, 5) )
    {
      if ( CGenericGameStorage::_ms_WorkBuffer )
      {
        operator delete[](CGenericGameStorage::_ms_WorkBuffer);
        CGenericGameStorage::_ms_WorkBuffer = 0;
        CGenericGameStorage::ms_WorkBuffer.data = 0;
        CGenericGameStorage::ms_WorkBuffer.size = 0;
      }
      goto LABEL_42;
    }
    ++v1;
    UseDataFence = v2;
    switch ( v1 )
    {
      case 0:
        CSimpleVariablesSaveStructure::Construct(&v9);
        v8 = UseDataFence;
        UseDataFence = 0;
        v3 = (CSimpleVariablesSaveStructure *)malloc(0x1ACu);
        qmemcpy(v3, &v9, sizeof(CSimpleVariablesSaveStructure));
        v7 = CGenericGameStorage::_SaveDataToWorkBuffer(v3, 428);
        free(v3);
        UseDataFence = v8;
        CGenericGameStorage::ms_bFailed = !v7;
        if ( !v7 )
          goto LABEL_36;
        continue;
      case 1:
        CTheScripts::Save();
        break;
      case 2:
        CPools::Save();
        break;
      case 3:
        CGarages::Save();
        break;
      case 4:
        CGameLogic::Save();
        break;
      case 5:
        CPathFind::Save(&ThePaths);
        break;
      case 6:
        CPickups::Save();
        break;
      case 8:
        CRestart::Save();
        break;
      case 9:
        CRadar::Save();
        break;
      case 10:
        CTheZones::Save();
        break;
      case 11:
        CGangs::Save();
        break;
      case 12:
        CTheCarGenerators::Save();
        break;
      case 15:
        CPlayerInfo::Save(&CWorld::Players[CWorld::PlayerInFocus]);
        break;
      case 16:
        CStats::Save();
        break;
      case 17:
        CSetPieces::Save();
        break;
      case 18:
        CStreaming::Save();
        break;
      case 19:
        CPedType::Save();
        break;
      case 20:
        CTagManager::Save();
        break;
      case 21:
        CIplStore::Save();
        break;
      case 22:
        CShopping::Save();
        break;
      case 23:
        CGangWars::Save();
        break;
      case 24:
        CStuntJumpManager::Save();
        break;
      case 25:
        CEntryExitManager::Save();
        break;
      case 26:
        CAERadioTrackManager::Save();
        break;
      case 27:
        C3dMarkers::SaveUser3dMarkers();
        break;
      case 28:
        CPostEffects::Save();
        break;
      default:
        break;
    }
    if ( CGenericGameStorage::ms_bFailed )
    {
LABEL_36:
      if ( CGenericGameStorage::_ms_WorkBuffer )
      {
        operator delete[](CGenericGameStorage::_ms_WorkBuffer);
        CGenericGameStorage::_ms_WorkBuffer = 0;
        CGenericGameStorage::ms_WorkBuffer.data = 0;
        CGenericGameStorage::ms_WorkBuffer.size = 0;
      }
      goto LABEL_42;
    }
  }
  while ( v1 <= 27 );
  SaveBriefs();
  if ( (int)(64996 - CGenericGameStorage::ms_WorkBufferPos) >= -1 && CGenericGameStorage::ms_WorkBufferPos != 64997 )
  {
    CGenericGameStorage::ms_WorkBufferPos = 64996;
    goto LABEL_47;
  }
  CGenericGameStorage::ms_WorkBufferPos = 65000;
  if ( !CGenericGameStorage::SaveWorkBuffer(0) )
  {
    if ( CGenericGameStorage::_ms_WorkBuffer )
    {
      operator delete[](CGenericGameStorage::_ms_WorkBuffer);
      CGenericGameStorage::_ms_WorkBuffer = 0;
      CGenericGameStorage::ms_WorkBuffer.data = 0;
      CGenericGameStorage::ms_WorkBuffer.size = 0;
    }
LABEL_42:
    CFileMgr::CloseFile(CGenericGameStorage::ms_FileHandle);
    return 0;
  }
LABEL_47:
  v5 = CGenericGameStorage::SaveWorkBuffer(1);
  if ( CGenericGameStorage::_ms_WorkBuffer )
  {
    operator delete[](CGenericGameStorage::_ms_WorkBuffer);
    CGenericGameStorage::_ms_WorkBuffer = 0;
    CGenericGameStorage::ms_WorkBuffer.data = 0;
    CGenericGameStorage::ms_WorkBuffer.size = 0;
  }
  v6 = CFileMgr::CloseFile(CGenericGameStorage::ms_FileHandle);
  if ( !v5 )
    return 0;
  strncpy(
    (char *)CGenericGameStorage::ms_SaveFileNameJustSaved,
    (const char *)CGenericGameStorage::ms_ValidSaveName,
    0x103u);
  if ( v6 )
    return 0;
  CPad::FixPadsAfterSave();
  return 1;
}
// 4828EC: using guessed type int dword_4828EC;

//----- (00482988) --------------------------------------------------------
int CGenericGameStorage::OpenFileForWriting()
{
  CGenericGameStorage::ms_FileHandle = CFileMgr::OpenFile(
                                         CGenericGameStorage::ms_ValidSaveName,
                                         (const unsigned __int8 *)&dword_4829F8);
  if ( CGenericGameStorage::ms_FileHandle )
  {
    CGenericGameStorage::ms_WorkBufferPos = 0;
    CGenericGameStorage::ms_FilePos = 0;
    if ( !CGenericGameStorage::_ms_WorkBuffer )
    {
      CGenericGameStorage::_ms_WorkBuffer = (uint8 *)operator new[](0xFDE9u);
      CGenericGameStorage::ms_WorkBuffer.data = CGenericGameStorage::_ms_WorkBuffer;
      CGenericGameStorage::ms_WorkBuffer.size = 65001;
    }
    return 1;
  }
  else
  {
    PcSaveHelper.ErrorCode = 4;
    return 0;
  }
}
// 4829F8: using guessed type int dword_4829F8;

//----- (00482A18) --------------------------------------------------------
bool CGenericGameStorage::CloseFile()
{
  if ( CGenericGameStorage::_ms_WorkBuffer )
  {
    operator delete[](CGenericGameStorage::_ms_WorkBuffer);
    CGenericGameStorage::_ms_WorkBuffer = 0;
    CGenericGameStorage::ms_WorkBuffer.data = 0;
    CGenericGameStorage::ms_WorkBuffer.size = 0;
  }
  return CFileMgr::CloseFile(CGenericGameStorage::ms_FileHandle) == 0;
}

//----- (00482A68) --------------------------------------------------------
bool __fastcall CGenericGameStorage::SaveWorkBuffer(bool bWithChecksum)
{
  int32 v2; // r2
  uint32 v3; // r4
  UInt32 v4; // r1
  int v5; // r3
  int32 v6; // r4

  if ( CGenericGameStorage::ms_bFailed )
    return 0;
  v2 = CGenericGameStorage::ms_WorkBufferPos;
  if ( !CGenericGameStorage::ms_WorkBufferPos )
    return 1;
  v3 = 0;
  v4 = CGenericGameStorage::ms_CheckSum;
  do
  {
    v5 = CGenericGameStorage::_ms_WorkBuffer[v3++];
    v4 += v5;
    CGenericGameStorage::ms_CheckSum = v4;
  }
  while ( v3 < CGenericGameStorage::ms_WorkBufferPos );
  if ( bWithChecksum )
  {
    if ( CGenericGameStorage::ms_WorkBufferPos >= 0xFDE5 )
    {
      CGenericGameStorage::SaveWorkBuffer(0);
      v2 = CGenericGameStorage::ms_WorkBufferPos;
    }
    *(_DWORD *)&CGenericGameStorage::ms_WorkBuffer.data[v2] = CGenericGameStorage::ms_CheckSum;
    v2 = CGenericGameStorage::ms_WorkBufferPos + 4;
    CGenericGameStorage::ms_WorkBufferPos += 4;
  }
  v6 = CFileMgr::Write(CGenericGameStorage::ms_FileHandle, CGenericGameStorage::_ms_WorkBuffer, v2);
  if ( !CFileMgr::GetErrorReadWrite(CGenericGameStorage::ms_FileHandle) && v6 == CGenericGameStorage::ms_WorkBufferPos )
  {
    CGenericGameStorage::ms_WorkBufferPos = 0;
    CGenericGameStorage::ms_FilePos += v6;
    return 1;
  }
  PcSaveHelper.ErrorCode = 11;
  if ( CGenericGameStorage::_ms_WorkBuffer )
  {
    operator delete[](CGenericGameStorage::_ms_WorkBuffer);
    CGenericGameStorage::_ms_WorkBuffer = 0;
    CGenericGameStorage::ms_WorkBuffer.data = 0;
    CGenericGameStorage::ms_WorkBuffer.size = 0;
  }
  if ( CFileMgr::CloseFile(CGenericGameStorage::ms_FileHandle) )
    PcSaveHelper.ErrorCode = 6;
  strncpy(
    (char *)CGenericGameStorage::ms_SaveFileNameJustSaved,
    (const char *)CGenericGameStorage::ms_ValidSaveName,
    0x103u);
  CGenericGameStorage::ms_bFailed = 1;
  return 0;
}

//----- (00482BF0) --------------------------------------------------------
bool __fastcall IsGameResuming(bool reset)
{
  _BOOL4 v1; // r1
  _BOOL4 v2; // r0

  v1 = reset;
  v2 = DoingCheckpointLoad;
  if ( v1 )
    DoingCheckpointLoad = 0;
  return v2;
}

//----- (00482C18) --------------------------------------------------------
bool __fastcall CGenericGameStorage::GenericLoad(bool *bWrongVersion)
{
  bool v2; // r8
  char *v3; // r4
  CGenericGameStorage::eBlocks v4; // r5
  bool v5; // r9
  const char *v6; // r0
  int v7; // r4
  char *v8; // r9
  _BOOL4 v9; // r0
  signed int SavedVersionNumber; // r0
  bool v11; // cc
  bool result; // r0
  bool v13; // [sp+0h] [bp-390h]
  char v14; // [sp+13h] [bp-37Dh] BYREF
  uint32 savedKey; // [sp+18h] [bp-378h] BYREF
  CSimpleVariablesSaveStructure pData; // [sp+1Ch] [bp-374h] BYREF
  CSimpleVariablesSaveStructure v17; // [sp+1C8h] [bp-1C8h] BYREF

  TotalLoadSize = 0;
  ResetFenceCount();
  v2 = UseDataFence;
  *bWrongVersion = 0;
  CGenericGameStorage::ms_CheckSum = 0;
  CGenericGameStorage::ms_bFailed = 0;
  CCheat::ResetCheats();
  CFileMgr::SetDirMyDocuments();
  CGenericGameStorage::ms_FileHandle = CFileMgr::OpenFile(
                                         CGenericGameStorage::ms_LoadFileName,
                                         (const unsigned __int8 *)&dword_483060);
  CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
  if ( !CGenericGameStorage::ms_FileHandle )
  {
    PcSaveHelper.ErrorCode = 4;
    return 0;
  }
  CGenericGameStorage::ms_FileSize = CFileMgr::GetTotalSize(CGenericGameStorage::ms_FileHandle);
  CGenericGameStorage::ms_FilePos = 0;
  CGenericGameStorage::ms_WorkBufferSize = 65000;
  CGenericGameStorage::ms_WorkBufferPos = 65000;
  if ( !CGenericGameStorage::_ms_WorkBuffer )
  {
    CGenericGameStorage::_ms_WorkBuffer = (uint8 *)operator new[](0xFDE9u);
    CGenericGameStorage::ms_WorkBuffer.data = CGenericGameStorage::_ms_WorkBuffer;
    CGenericGameStorage::ms_WorkBuffer.size = 65001;
  }
  v3 = &v14;
  v4 = -1;
  CGenericGameStorage::ms_bLoading = 1;
  while ( 1 )
  {
    if ( v4 == BLOCK_USER_3DMARKERS && CGenericGameStorage::m_currentSlotVersionNumber < 3 )
    {
LABEL_43:
      LoadBriefs();
      UseDataFence = v2;
      CGenericGameStorage::ms_bLoading = 0;
      if ( CGenericGameStorage::_ms_WorkBuffer )
      {
        operator delete[](CGenericGameStorage::_ms_WorkBuffer);
        CGenericGameStorage::_ms_WorkBuffer = 0;
        CGenericGameStorage::ms_WorkBuffer.data = 0;
        CGenericGameStorage::ms_WorkBuffer.size = 0;
      }
      if ( CFileMgr::CloseFile(CGenericGameStorage::ms_FileHandle) )
        return 0;
      CGenericGameStorage::DoGameSpecificStuffAfterSucessLoad();
      CGenericGameStorage::DoAnytimeSavingStuffAfterSucessLoad();
      CLoadingScreen::Shutdown(0);
      return 1;
    }
    CLoadingScreen::NewChunkLoaded();
    v5 = UseDataFence;
    UseDataFence = 0;
    if ( !CGenericGameStorage::_LoadDataFromWorkBuffer(v3, 5) )
      break;
    v6 = v3;
    UseDataFence = v5;
    v7 = v4 + 1;
    v8 = (char *)v6;
    if ( strncmp(v6, (const char *)CGenericGameStorage::ms_BlockTagName, 5u) )
    {
      if ( v7 >= 1 )
      {
        CGenericGameStorage::ReportError(v4, SLERROR_SYNC);
        if ( v4 == BLOCK_SIMPLE_VARIABLES )
          CSimpleVariablesSaveStructure::Extract(&v17, &savedKey);
      }
      if ( CGenericGameStorage::_ms_WorkBuffer )
      {
        operator delete[](CGenericGameStorage::_ms_WorkBuffer);
        CGenericGameStorage::_ms_WorkBuffer = 0;
        CGenericGameStorage::ms_WorkBuffer.data = 0;
        CGenericGameStorage::ms_WorkBuffer.size = 0;
      }
      CFileMgr::CloseFile(CGenericGameStorage::ms_FileHandle);
      result = 0;
      CGenericGameStorage::ms_bLoading = 0;
      return result;
    }
    switch ( v4 )
    {
      case -1:
        CSimpleVariablesSaveStructure::Construct(&v17);
        v13 = UseDataFence;
        UseDataFence = 0;
        v9 = !CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 428);
        CGenericGameStorage::ms_bFailed = v9;
        UseDataFence = v13;
        if ( v9 )
          goto LABEL_41;
        CSimpleVariablesSaveStructure::Extract(&pData, &savedKey);
        SavedVersionNumber = CGenericGameStorage::GetSavedVersionNumber(savedKey);
        CGenericGameStorage::m_currentSlotVersionNumber = SavedVersionNumber;
        if ( SavedVersionNumber > 1 )
        {
          if ( SavedVersionNumber == 2 )
            UseDataFence = 1;
          goto LABEL_40;
        }
        CSimpleVariablesSaveStructure::Extract(&v17, &savedKey);
        if ( CGenericGameStorage::_ms_WorkBuffer )
        {
          operator delete[](CGenericGameStorage::_ms_WorkBuffer);
          CGenericGameStorage::_ms_WorkBuffer = 0;
          CGenericGameStorage::ms_WorkBuffer.data = 0;
          CGenericGameStorage::ms_WorkBuffer.size = 0;
        }
        CFileMgr::CloseFile(CGenericGameStorage::ms_FileHandle);
        *bWrongVersion = 1;
        return 0;
      case 0:
        CTheScripts::Load();
        goto LABEL_40;
      case 1:
        if ( CPools::Load() == 1 )
          CTheScripts::DoScriptSetupAfterPoolsHaveLoaded();
        goto LABEL_40;
      case 2:
        CGarages::Load();
        goto LABEL_40;
      case 3:
        CGameLogic::Load();
        goto LABEL_40;
      case 4:
        CPathFind::Load(&ThePaths);
        goto LABEL_40;
      case 5:
        CPickups::Load();
        goto LABEL_40;
      case 7:
        CRestart::Load();
        goto LABEL_40;
      case 8:
        CRadar::Load();
        goto LABEL_40;
      case 9:
        CTheZones::Load();
        goto LABEL_40;
      case 10:
        CGangs::Load();
        goto LABEL_40;
      case 11:
        CTheCarGenerators::Load();
        goto LABEL_40;
      case 14:
        CPlayerInfo::Load(&CWorld::Players[CWorld::PlayerInFocus]);
        goto LABEL_40;
      case 15:
        CStats::Load();
        goto LABEL_40;
      case 16:
        CSetPieces::Load();
        goto LABEL_40;
      case 17:
        CStreaming::Load();
        goto LABEL_40;
      case 18:
        CPedType::Load();
        goto LABEL_40;
      case 19:
        CTagManager::Load();
        goto LABEL_40;
      case 20:
        CIplStore::Load();
        goto LABEL_40;
      case 21:
        CShopping::Load();
        goto LABEL_40;
      case 22:
        CGangWars::Load();
        goto LABEL_40;
      case 23:
        CStuntJumpManager::Load();
        goto LABEL_40;
      case 24:
        CEntryExitManager::Load();
        goto LABEL_40;
      case 25:
        CAERadioTrackManager::Load();
        goto LABEL_40;
      case 26:
        C3dMarkers::LoadUser3dMarkers();
        goto LABEL_40;
      case 27:
        CPostEffects::Load();
        goto LABEL_40;
      default:
LABEL_40:
        v9 = CGenericGameStorage::ms_bFailed;
LABEL_41:
        if ( v9 )
        {
          CGenericGameStorage::ReportError((CGenericGameStorage::eBlocks)v7, SLERROR_LOAD);
          if ( CGenericGameStorage::_ms_WorkBuffer )
          {
            operator delete[](CGenericGameStorage::_ms_WorkBuffer);
            CGenericGameStorage::_ms_WorkBuffer = 0;
            CGenericGameStorage::ms_WorkBuffer.data = 0;
            CGenericGameStorage::ms_WorkBuffer.size = 0;
          }
          CFileMgr::CloseFile(CGenericGameStorage::ms_FileHandle);
          result = 0;
          CGenericGameStorage::ms_bLoading = 0;
          UseDataFence = v2;
          return result;
        }
        v11 = v7 < 28;
        ++v4;
        v3 = v8;
        if ( !v11 )
          goto LABEL_43;
        break;
    }
  }
  if ( CGenericGameStorage::_ms_WorkBuffer )
  {
    operator delete[](CGenericGameStorage::_ms_WorkBuffer);
    CGenericGameStorage::_ms_WorkBuffer = 0;
    CGenericGameStorage::ms_WorkBuffer.data = 0;
    CGenericGameStorage::ms_WorkBuffer.size = 0;
  }
  CFileMgr::CloseFile(CGenericGameStorage::ms_FileHandle);
  return 0;
}
// 483060: using guessed type int dword_483060;
// 61CADE: using guessed type char byte_61CADE;

//----- (00483124) --------------------------------------------------------
bool __fastcall CGenericGameStorage::OpenFileForReading(unsigned __int8 *FileName, UInt32 SlotNumber)
{
  char (**v3)[260]; // r1
  int RockstarID; // [sp+0h] [bp-10h]

  if ( FileName )
  {
    strcpy((char *)CGenericGameStorage::ms_LoadFileName, (const char *)FileName);
    if ( FrontEndMenuManager.m_UseDebugScripts )
    {
      v3 = &MarketingPCSaveFileName_ptr;
    }
    else
    {
      if ( IsCloudSlot(SlotNumber) )
      {
        RockstarID = GetRockstarID();
        sprintf(
          CGenericGameStorage::ms_LoadFileNameWithPath,
          "%s%i_%s%s",
          DefaultPCSaveFileName,
          SlotNumber + 1,
          RockstarID,
          &dword_483234);
        goto LABEL_8;
      }
      v3 = &DefaultPCSaveFileName_ptr;
    }
    sprintf(CGenericGameStorage::ms_LoadFileNameWithPath, "%s%i%s", *v3, SlotNumber + 1, &dword_483234);
  }
LABEL_8:
  CFileMgr::SetDirMyDocuments();
  CGenericGameStorage::ms_FileHandle = CFileMgr::OpenFile(
                                         CGenericGameStorage::ms_LoadFileName,
                                         (const unsigned __int8 *)&dword_483260);
  CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
  if ( CGenericGameStorage::ms_FileHandle )
  {
    CGenericGameStorage::ms_FileSize = CFileMgr::GetTotalSize(CGenericGameStorage::ms_FileHandle);
    CGenericGameStorage::ms_FilePos = 0;
    CGenericGameStorage::ms_WorkBufferSize = 65000;
    CGenericGameStorage::ms_WorkBufferPos = 65000;
    if ( !CGenericGameStorage::_ms_WorkBuffer )
    {
      CGenericGameStorage::_ms_WorkBuffer = (uint8 *)operator new[](0xFDE9u);
      CGenericGameStorage::ms_WorkBuffer.data = CGenericGameStorage::_ms_WorkBuffer;
      CGenericGameStorage::ms_WorkBuffer.size = 65001;
    }
    return 1;
  }
  else
  {
    PcSaveHelper.ErrorCode = 4;
    return 0;
  }
}
// 198C68: using guessed type int GetRockstarID(void);
// 483234: using guessed type int dword_483234;
// 483260: using guessed type int dword_483260;
// 61CADE: using guessed type char byte_61CADE;
// 6776F8: using guessed type char (*DefaultPCSaveFileName_ptr)[260];
// 678A28: using guessed type char (*MarketingPCSaveFileName_ptr)[260];

//----- (0048328C) --------------------------------------------------------
void __fastcall CGenericGameStorage::ReportError(
        CGenericGameStorage::eBlocks block,
        CGenericGameStorage::eSaveLoadError error)
{
  int v2; // r0
  int v3; // r0
  __int64 v4; // d16
  __int16 v5; // r0
  const char *v6; // r0
  int v7; // r0
  const char *v8; // r0
  unsigned __int8 s[100]; // [sp+4h] [bp-9Ch] BYREF
  _QWORD v10[5]; // [sp+68h] [bp-38h] BYREF

  switch ( block )
  {
    case BLOCK_SIMPLE_VARIABLES:
      strcpy((char *)v10, "SIMPLE_VARIABLES");
      if ( error != SLERROR_SYNC )
        goto LABEL_33;
      goto LABEL_26;
    case BLOCK_SCRIPTS:
      strcpy((char *)v10 + 4, "PTS");
      v2 = 1230127955;
      goto LABEL_12;
    case BLOCK_POOLS:
      v3 = 1280266064;
      goto LABEL_24;
    case BLOCK_GARAGES:
      strcpy((char *)v10 + 4, "GES");
      v2 = 1095909703;
      goto LABEL_12;
    case BLOCK_GAMELOGIC:
      v4 = *(_QWORD *)"GAMELOGIC";
      strcpy((char *)&v10[1], "C");
      goto LABEL_44;
    case BLOCK_PATHS:
      v3 = 1213481296;
      goto LABEL_24;
    case BLOCK_PICKUPS:
      strcpy((char *)v10 + 4, "UPS");
      v2 = 1262700880;
      goto LABEL_12;
    case BLOCK_PHONEINFO:
      v4 = *(_QWORD *)"PHONEINFO";
      strcpy((char *)&v10[1], "O");
      goto LABEL_44;
    case BLOCK_RESTART:
      strcpy((char *)v10 + 4, "ART");
      v2 = 1414743378;
LABEL_12:
      LODWORD(v10[0]) = v2;
      if ( error == SLERROR_SYNC )
        goto LABEL_26;
      goto LABEL_33;
    case BLOCK_RADAR:
      LODWORD(v10[0]) = 1094992210;
      v5 = 82;
      goto LABEL_25;
    case BLOCK_ZONES:
      v3 = 1162760026;
      goto LABEL_24;
    case BLOCK_GANGS:
      v3 = 1196310855;
      goto LABEL_24;
    case BLOCK_CARGENERATORS:
      v6 = "CAR GENERATORS";
      goto LABEL_19;
    case BLOCK_PEDGENERATORS:
      v6 = "PED GENERATORS";
LABEL_19:
      v4 = *(_QWORD *)v6;
      *(_QWORD *)((unsigned int)v10 | 7) = *(_QWORD *)(v6 + 7);
      goto LABEL_44;
    case BLOCK_AUDIOSCRIPTOBJECT:
      strcpy((char *)v10, "AUDIO SCRIPT OBJECT");
      if ( error == SLERROR_SYNC )
        goto LABEL_26;
      goto LABEL_33;
    case BLOCK_PLAYERINFO:
      v4 = *(_QWORD *)"PLAYERINFO";
      strcpy((char *)&v10[1], "FO");
      goto LABEL_44;
    case BLOCK_STATS:
      v3 = 1413567571;
LABEL_24:
      LODWORD(v10[0]) = v3;
      v5 = 83;
LABEL_25:
      WORD2(v10[0]) = v5;
      if ( error == SLERROR_SYNC )
        goto LABEL_26;
      goto LABEL_33;
    case BLOCK_SETPIECES:
      v4 = *(_QWORD *)"SET PIECES";
      strcpy((char *)&v10[1], "ES");
      goto LABEL_44;
    case BLOCK_STREAMING:
      v4 = *(_QWORD *)"STREAMING";
      strcpy((char *)&v10[1], "G");
      goto LABEL_44;
    case BLOCK_PEDTYPE:
      v4 = *(_QWORD *)"PED TYPES";
      strcpy((char *)&v10[1], "S");
      goto LABEL_44;
    case BLOCK_TAGS:
      v7 = 1397178708;
      goto LABEL_32;
    case BLOCK_IPLS:
      v7 = 1397510217;
LABEL_32:
      LODWORD(v10[0]) = v7;
      BYTE4(v10[0]) = 0;
      if ( error != SLERROR_SYNC )
        goto LABEL_33;
      goto LABEL_26;
    case BLOCK_SHOPPING:
      v8 = "SHOPPING";
      goto LABEL_40;
    case BLOCK_GANGWARS:
      v8 = "GANGWARS";
LABEL_40:
      v4 = *(_QWORD *)v8;
      LOBYTE(v10[1]) = 0;
      goto LABEL_44;
    case BLOCK_STUNTJUMPS:
      v4 = *(_QWORD *)"STUNTJUMPS";
      strcpy((char *)&v10[1], "PS");
      goto LABEL_44;
    case BLOCK_USER_3DMARKERS:
      v4 = *(_QWORD *)"USER3DMARKERS";
      strcpy((char *)((unsigned int)v10 | 6), "MARKERS");
      goto LABEL_44;
    case BLOCK_POSTEFFECTS:
      v4 = *(_QWORD *)"POSTEFFECTS";
      strcpy((char *)&v10[1], "CTS");
LABEL_44:
      v10[0] = v4;
      break;
    default:
      break;
  }
  if ( error == SLERROR_SYNC )
  {
LABEL_26:
    sprintf(s, "Saving error: %s", v10);
  }
  else
  {
LABEL_33:
    if ( error == SLERROR_LOAD )
    {
      sprintf(s, "Loading error: %s", v10);
    }
    else if ( error == SLERROR_SAVE )
    {
      sprintf(s, "Loading sync error: %s", v10);
    }
  }
}

//----- (00483580) --------------------------------------------------------
uint32 __fastcall CGenericGameStorage::GetSavedVersionNumber(uint32 savedKey)
{
  uint32 v2; // r5
  unsigned __int8 s[40]; // [sp+4h] [bp-3Ch] BYREF

  v2 = 0;
  sprintf(s, "GTASA%d", 0);
  CKeyGen::GetKey(s);
  if ( CKeyGen::GetKey(s) != savedKey )
  {
    sprintf(s, "GTASA%d", 1);
    CKeyGen::GetKey(s);
    if ( CKeyGen::GetKey(s) == savedKey )
    {
      return 1;
    }
    else
    {
      v2 = 2;
      sprintf(s, "GTASA%d", 2);
      CKeyGen::GetKey(s);
      if ( CKeyGen::GetKey(s) != savedKey )
      {
        v2 = 3;
        sprintf(s, "GTASA%d", 3);
        CKeyGen::GetKey(s);
        if ( CKeyGen::GetKey(s) != savedKey )
        {
          sprintf(s, "GTASA%d", 4);
          CKeyGen::GetKey(s);
          v2 = 0;
          if ( CKeyGen::GetKey(s) == savedKey )
            return 4;
        }
      }
    }
  }
  return v2;
}

//----- (00483674) --------------------------------------------------------
bool __fastcall CGenericGameStorage::_SaveDataToWorkBuffer(void *pData, int32 SizeOfData)
{
  bool v4; // r6
  uint32 v5; // r0
  bool v6; // r9
  uint32 v7; // r8

  if ( CGenericGameStorage::ms_bFailed )
    return 0;
  if ( UseDataFence )
    AddDataFence();
  if ( SizeOfData < 1 )
    return 1;
  v5 = CGenericGameStorage::ms_WorkBufferPos;
  if ( CGenericGameStorage::ms_WorkBufferPos + SizeOfData < 0xFDE9 )
  {
LABEL_10:
    qmemcpy(&CGenericGameStorage::_ms_WorkBuffer[v5], pData, SizeOfData);
    CGenericGameStorage::ms_WorkBufferPos += SizeOfData;
    return 1;
  }
  v4 = 0;
  v6 = UseDataFence;
  UseDataFence = 0;
  v7 = 65000 - CGenericGameStorage::ms_WorkBufferPos;
  if ( CGenericGameStorage::_SaveDataToWorkBuffer(pData, 65000 - CGenericGameStorage::ms_WorkBufferPos) )
  {
    v4 = 0;
    UseDataFence = v6;
    if ( CGenericGameStorage::SaveWorkBuffer(0) )
    {
      SizeOfData -= v7;
      pData = (char *)pData + v7;
      v5 = CGenericGameStorage::ms_WorkBufferPos;
      goto LABEL_10;
    }
  }
  return v4;
}

//----- (00483744) --------------------------------------------------------
bool __fastcall CGenericGameStorage::_LoadDataFromWorkBuffer(void *pData, int32 SizeOfData)
{
  signed int v2; // r4
  bool v4; // r6
  uint32 v5; // r0
  bool v6; // r9
  uint32 v7; // r8

  v2 = SizeOfData;
  TotalLoadSize += SizeOfData;
  if ( CGenericGameStorage::ms_bFailed )
    return 0;
  if ( UseDataFence )
    ReadDataFence();
  if ( v2 < 1 )
    return 1;
  v5 = CGenericGameStorage::ms_WorkBufferPos;
  if ( CGenericGameStorage::ms_WorkBufferPos + v2 <= CGenericGameStorage::ms_WorkBufferSize )
  {
LABEL_10:
    qmemcpy(pData, &CGenericGameStorage::_ms_WorkBuffer[v5], v2);
    CGenericGameStorage::ms_WorkBufferPos += v2;
    return 1;
  }
  v4 = 0;
  v6 = UseDataFence;
  UseDataFence = 0;
  v7 = 65000 - CGenericGameStorage::ms_WorkBufferPos;
  if ( !CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 65000 - CGenericGameStorage::ms_WorkBufferPos) )
    return v4;
  UseDataFence = v6;
  if ( CGenericGameStorage::LoadWorkBuffer() == 1 )
  {
    v2 -= v7;
    pData = (char *)pData + v7;
    v5 = CGenericGameStorage::ms_WorkBufferPos;
    goto LABEL_10;
  }
  return 0;
}

//----- (00483828) --------------------------------------------------------
int CGenericGameStorage::LoadWorkBuffer()
{
  UInt32 v1; // r4
  int32 Bytes; // r8
  int v3; // r0
  bool v4; // zf

  if ( CGenericGameStorage::ms_bFailed )
    return 0;
  v1 = 65000;
  if ( CGenericGameStorage::ms_FilePos + 65000 > CGenericGameStorage::ms_FileSize )
    v1 = CGenericGameStorage::ms_FileSize - CGenericGameStorage::ms_FilePos;
  if ( !v1 || v1 != ((v1 + 3) & 0xFFFFFFFC) )
    return 0;
  Bytes = CFileMgr::ReadBytes(CGenericGameStorage::ms_FileHandle, CGenericGameStorage::_ms_WorkBuffer, v1);
  CGenericGameStorage::ms_WorkBuffer.data = CGenericGameStorage::_ms_WorkBuffer;
  CGenericGameStorage::ms_WorkBuffer.size = v1;
  v3 = CFileMgr::GetErrorReadWrite(CGenericGameStorage::ms_FileHandle);
  v4 = Bytes == v1;
  if ( Bytes == v1 )
    v4 = v3 == 0;
  if ( !v4 )
  {
    PcSaveHelper.ErrorCode = 5;
    if ( CGenericGameStorage::_ms_WorkBuffer )
    {
      operator delete[](CGenericGameStorage::_ms_WorkBuffer);
      CGenericGameStorage::_ms_WorkBuffer = 0;
      CGenericGameStorage::ms_WorkBuffer.data = 0;
      CGenericGameStorage::ms_WorkBuffer.size = 0;
    }
    if ( CFileMgr::CloseFile(CGenericGameStorage::ms_FileHandle) )
      PcSaveHelper.ErrorCode = 6;
    CGenericGameStorage::ms_bFailed = 1;
    return 0;
  }
  CGenericGameStorage::ms_WorkBufferSize = v1;
  CGenericGameStorage::ms_WorkBufferPos = 0;
  CGenericGameStorage::ms_FilePos += v1;
  return 1;
}

//----- (00483954) --------------------------------------------------------
bool __fastcall CGenericGameStorage::CheckSlotDataValid(int SlotNumber, bool DeleteRwObjects)
{
  _BOOL4 v3; // r4
  unsigned __int8 v5[260]; // [sp+0h] [bp-118h] BYREF

  v3 = DeleteRwObjects;
  C_PcSave::GenerateGameFilename(&PcSaveHelper, SlotNumber, v5);
  if ( CGenericGameStorage::CheckDataNotCorrupt(SlotNumber, v5) )
  {
    if ( v3 )
      CStreaming::DeleteAllRwObjects();
    return 1;
  }
  else
  {
    PcSaveHelper.ErrorCode = 7;
    return 0;
  }
}

//----- (004839CC) --------------------------------------------------------
bool __fastcall CGenericGameStorage::CheckDataNotCorrupt(int SlotNumber, unsigned __int8 *FileName)
{
  unsigned __int32 v2; // r4
  int32x4_t v3; // q4
  uint32 v4; // r2
  uint32 v5; // r3
  uint8 *v6; // r1
  int32x4_t v7; // q9
  int8x16_t v8; // q8
  unsigned __int32 v9; // t1
  int32x4_t v10; // q8
  int v11; // r1
  int v12; // r8
  int v13; // r6

  v2 = 0;
  CGenericGameStorage::ms_bFailed = 0;
  if ( CGenericGameStorage::OpenFileForReading(FileName, SlotNumber) )
  {
    PcSaveHelper.ErrorCode = 0;
    if ( CGenericGameStorage::LoadWorkBuffer() == 1 )
    {
      v2 = 0;
      v3 = vdupq_n_s32(0);
      do
      {
        if ( CGenericGameStorage::ms_WorkBufferSize )
        {
          if ( CGenericGameStorage::ms_WorkBufferSize >= 4 )
          {
            v4 = CGenericGameStorage::ms_WorkBufferSize & 0xFFFFFFFC;
            if ( (CGenericGameStorage::ms_WorkBufferSize & 0xFFFFFFFC) != 0 )
            {
              v5 = CGenericGameStorage::ms_WorkBufferSize & 0xFFFFFFFC;
              v8.n128_u64[1] = v3.n128_u64[1];
              v6 = CGenericGameStorage::_ms_WorkBuffer;
              v7.n128_u64[0] = __PAIR64__(v3.n128_u32[1], v2);
              v8.n128_u64[0] = __PAIR64__(v3.n128_u32[1], v2);
              do
              {
                v9 = *(_DWORD *)v6;
                v6 += 4;
                v5 -= 4;
                v7.n128_u32[0] = v9;
                v7 = vmovl_u16((uint16x4_t)vmovl_u8((uint8x8_t)v7.n128_u64[0]).n128_u64[0]);
                v8 = vaddq_s32(v8, v7);
              }
              while ( v5 );
              v10 = vaddq_s32(v8, vextq_s8(v8, v8, 8u));
              v2 = vaddq_s32(v10, vdupq_lane_s32((int32x2_t)v10.n128_u64[0], 1)).n128_u32[0];
              if ( CGenericGameStorage::ms_WorkBufferSize == v4 )
                continue;
            }
            else
            {
              v4 = 0;
            }
          }
          else
          {
            v4 = 0;
          }
          do
          {
            v11 = CGenericGameStorage::_ms_WorkBuffer[v4++];
            v2 += v11;
          }
          while ( v4 < CGenericGameStorage::ms_WorkBufferSize );
        }
      }
      while ( CGenericGameStorage::LoadWorkBuffer() == 1 );
    }
    if ( PcSaveHelper.ErrorCode || CGenericGameStorage::ms_WorkBufferSize <= 3 )
    {
      if ( CGenericGameStorage::_ms_WorkBuffer )
      {
        operator delete[](CGenericGameStorage::_ms_WorkBuffer);
        CGenericGameStorage::_ms_WorkBuffer = 0;
        CGenericGameStorage::ms_WorkBuffer.data = 0;
        CGenericGameStorage::ms_WorkBuffer.size = 0;
      }
      CFileMgr::CloseFile(CGenericGameStorage::ms_FileHandle);
      LOBYTE(v2) = 0;
    }
    else
    {
      v12 = *(_DWORD *)&CGenericGameStorage::ms_WorkBuffer.data[CGenericGameStorage::ms_WorkBufferSize - 4];
      v13 = v2
          - CGenericGameStorage::_ms_WorkBuffer[CGenericGameStorage::ms_WorkBufferSize - 1]
          - CGenericGameStorage::_ms_WorkBuffer[CGenericGameStorage::ms_WorkBufferSize - 2]
          - CGenericGameStorage::_ms_WorkBuffer[CGenericGameStorage::ms_WorkBufferSize - 3]
          - CGenericGameStorage::_ms_WorkBuffer[CGenericGameStorage::ms_WorkBufferSize - 4];
      if ( CGenericGameStorage::_ms_WorkBuffer )
      {
        operator delete[](CGenericGameStorage::_ms_WorkBuffer);
        CGenericGameStorage::_ms_WorkBuffer = 0;
        CGenericGameStorage::ms_WorkBuffer.data = 0;
        CGenericGameStorage::ms_WorkBuffer.size = 0;
      }
      CFileMgr::CloseFile(CGenericGameStorage::ms_FileHandle);
      LOBYTE(v2) = v13 == v12;
    }
  }
  return v2;
}

//----- (00483B88) --------------------------------------------------------
void __fastcall CGenericGameStorage::MakeValidSaveName(int SlotNumber)
{
  int RockstarID; // r0
  unsigned __int8 *v3; // r4
  int v4; // r1
  bool v5; // zf
  unsigned __int8 s[260]; // [sp+8h] [bp-110h] BYREF

  s[0] = 0;
  if ( IsCloudSlot(SlotNumber) )
  {
    RockstarID = GetRockstarID();
    sprintf(s, "%s%i_%s", DefaultPCSaveFileName, SlotNumber + 1, RockstarID);
  }
  else
  {
    sprintf(s, "%s%i", DefaultPCSaveFileName, SlotNumber + 1);
  }
  if ( strlen((const char *)s) > 0x100 )
    s[257] = 0;
  strcat((char *)s, ".b");
  v3 = CGenericGameStorage::ms_ValidSaveName;
  strcpy((char *)CGenericGameStorage::ms_ValidSaveName, (const char *)s);
  while ( 1 )
  {
    v4 = *v3;
    if ( v4 == 63 )
    {
      *v3 = 32;
      goto LABEL_7;
    }
    v5 = v4 == 0;
    if ( *v3 )
      v5 = v4 == 10;
    if ( v5 )
      break;
LABEL_7:
    ++v3;
  }
}
// 198C68: using guessed type int GetRockstarID(void);
// 6776F8: using guessed type char (*DefaultPCSaveFileName_ptr)[260];

//----- (00483C58) --------------------------------------------------------
GxtChar *__fastcall CGenericGameStorage::GetNameOfSavedGame(int SlotNumber)
{
  return CGenericGameStorage::ms_SlotFileName[SlotNumber];
}

//----- (00483C6C) --------------------------------------------------------
uint32 CGenericGameStorage::GetCurrentVersionNumber()
{
  unsigned __int8 s[40]; // [sp+4h] [bp-34h] BYREF

  sprintf(s, "GTASA%d", 4);
  return CKeyGen::GetKey(s);
}

//----- (00483CB4) --------------------------------------------------------
void ResetFenceCount()
{
  currentSaveFenceCount = 0;
  currentLoadFenceCount = 0;
}

//----- (00483CD0) --------------------------------------------------------
void AddDataFence()
{
  bool v0; // r8
  __int16 v1; // r6
  _WORD *v2; // r4

  v0 = UseDataFence;
  UseDataFence = 0;
  v1 = currentSaveFenceCount++ + DataFence;
  v2 = malloc(2u);
  *v2 = v1;
  CGenericGameStorage::_SaveDataToWorkBuffer(v2, 2);
  free(v2);
  UseDataFence = v0;
}

//----- (00483D28) --------------------------------------------------------
void ReadDataFence()
{
  bool v0; // r5
  char pData[10]; // [sp+6h] [bp-Ah] BYREF

  v0 = UseDataFence;
  UseDataFence = 0;
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
  UseDataFence = v0;
}
// 483D28: using guessed type char pData[10];

//----- (00483D50) --------------------------------------------------------
void __fastcall ClassSerializeError(int expectedTaskType, int realTaskType)
{
  unsigned __int8 s[128]; // [sp+4h] [bp-8Ch] BYREF

  sprintf(s, "ERROR - class %d is not type %d serialize is not this class expected", realTaskType, expectedTaskType);
}
// 483D50: using guessed type unsigned __int8 s[128];

//----- (00483D90) --------------------------------------------------------
int __fastcall GettPoolVehicleRef(CVehicle *veh)
{
  if ( veh )
    return sub_192FE8(veh);
  else
    return -1;
}

//----- (00483D9E) --------------------------------------------------------
CVehicle *__fastcall GetPoolVehicle(int slot)
{
  if ( slot == -1 )
    return 0;
  else
    return sub_19069C(slot);
}

//----- (00483DAA) --------------------------------------------------------
int __fastcall GettPoolPedRef(CPed *ped)
{
  if ( ped )
    return sub_18AB00(ped);
  else
    return -1;
}

//----- (00483DB8) --------------------------------------------------------
CPed *__fastcall GetPoolPed(int slot)
{
  if ( slot == -1 )
    return 0;
  else
    return sub_190280(slot);
}

//----- (00483DC4) --------------------------------------------------------
int __fastcall GettPoolObjRef(CObject *obj)
{
  if ( obj )
    return sub_199BE4(obj);
  else
    return -1;
}

//----- (00483DD2) --------------------------------------------------------
CObject *__fastcall GetPoolObj(int slot)
{
  if ( slot == -1 )
    return 0;
  else
    return sub_198A38(slot);
}

//----- (00483DE0) --------------------------------------------------------
void __fastcall CSimpleVariablesSaveStructure::Construct(CSimpleVariablesSaveStructure *this)
{
  const Char *v2; // r0
  signed int v3; // r0
  __int64 v4; // d16
  UInt8 v5; // r1
  bool8 v6; // r1
  char value; // r0
  char v8; // r0
  bool8 v9; // r0
  bool8 v10; // r0
  GxtChar pInStr[6]; // [sp+4h] [bp-3Ch] BYREF
  Char aStr[8]; // [sp+10h] [bp-30h] BYREF
  GxtChar pOutput[20]; // [sp+18h] [bp-28h] BYREF

  if ( CStats::LastMissionPassedName[0] )
    v2 = CStats::LastMissionPassedName;
  else
    v2 = (const Char *)"ITBEG";
  AsciiToGxtChar(v2, pOutput);
  strcpy((char *)aStr, "...'");
  AsciiToGxtChar(aStr, pInStr);
  pInStr[3] = 0;
  TextCopy(this->m_MissionName, pOutput);
  v3 = GxtCharStrlen(this->m_MissionName);
  this->m_MissionName[v3] = 0;
  if ( v3 >= 23 )
    TextCopy(&this->m_MissionName[18], pInStr);
  this->m_MissionName[23] = 0;
  this->m_VersionNumber = CGenericGameStorage::GetCurrentVersionNumber();
  this->m_MissionPackGame = CGame::bMissionPackGame;
  this->m_CurrLevel = CGame::currLevel;
  v4 = *(_QWORD *)&TheCamera.m_cameraMatrix.tx;
  this->m_CameraPosition.z = TheCamera.m_cameraMatrix.tz;
  *(_QWORD *)&this->m_CameraPosition.x = v4;
  this->m_MillisecondsPerGameMinute = CClock::ms_nMillisecondsPerGameMinute;
  this->m_LastClockTick = CClock::ms_nLastClockTick;
  this->m_GameClockMonths = CClock::ms_nGameClockMonths;
  this->m_GameClockDays = CClock::ms_nGameClockDays;
  this->m_GameClockHours = CClock::ms_nGameClockHours;
  this->m_GameClockMinutes = CClock::ms_nGameClockMinutes;
  this->m_CurrentDay = CClock::CurrentDay;
  this->m_StoredGameClockMonths = CClock::ms_Stored_nGameClockMonths;
  this->m_StoredGameClockDays = CClock::ms_Stored_nGameClockDays;
  this->m_StoredGameClockHours = CClock::ms_Stored_nGameClockHours;
  this->m_StoredGameClockMinutes = CClock::ms_Stored_nGameClockMinutes;
  v5 = CClock::bClockHasBeenStored;
  this->m_PadMode = 0;
  this->m_ClockStored = v5;
  v6 = CCheat::m_bHasPlayerCheated;
  if ( CCheat::m_bHasPlayerCheated )
    v6 = 1;
  this->m_bHasPlayerCheated = v6;
  this->m_TimeInMilliseconds = CTimer::m_snTimeInMilliseconds;
  this->m_TimeScale = CTimer::ms_fTimeScale;
  this->m_TimeStep = CTimer::ms_fTimeStep;
  this->m_TimeStepNonClipped = CTimer::ms_fTimeStepNonClipped;
  this->m_FrameCounter = CTimer::m_FrameCounter;
  this->m_OldWeatherType = CWeather::OldWeatherType;
  this->m_NewWeatherType = CWeather::NewWeatherType;
  this->m_ForcedWeatherType = CWeather::ForcedWeatherType;
  this->m_InterpolationValue = CWeather::InterpolationValue;
  this->m_WeatherTypeInList = CWeather::WeatherTypeInList;
  this->m_Rain = CWeather::Rain;
  this->m_CarZoom = TheCamera.m_nCarZoom;
  this->m_PedZoom = TheCamera.m_nPedZoom;
  this->m_bCineyCamMessageDisplayed = gbCineyCamMessageDisplayed;
  this->m_CurrArea = CGame::currArea;
  value = MobileSettings::settings[15].value;
  if ( MobileSettings::settings[15].value )
    value = 1;
  this->m_InvertLook4Pad = value;
  this->m_ExtraColour = CTimeCycle::m_ExtraColour;
  v8 = CTimeCycle::m_bExtraColourOn;
  if ( CTimeCycle::m_bExtraColourOn )
    v8 = 1;
  this->m_ExtraColourOn = v8;
  this->m_ExtraColourInter = CTimeCycle::m_ExtraColourInter;
  this->m_ExtraColourWeatherType = CTimeCycle::m_ExtraColourWeatherType;
  this->m_WaterConfiguration = CWaterLevel::m_nWaterConfiguration;
  this->m_bLARiots = gbLARiots;
  this->m_bLARiots_NoPoliceCars = gbLARiots_NoPoliceCars;
  this->m_MaximumWantedLevel = CWanted::MaximumWantedLevel;
  this->m_nMaximumWantedLevel = CWanted::nMaximumWantedLevel;
  this->m_germanGame = CLocalisation::germanGame;
  this->m_frenchGame = CLocalisation::frenchGame;
  this->m_nastyGame = CLocalisation::nastyGame;
  this->m_BlurOn = CMBlur::BlurOn;
  this->m_PrefsMusicVolume = FrontEndMenuManager.m_PrefsMusicVolume;
  this->m_PrefsSfxVolume = FrontEndMenuManager.m_PrefsSfxVolume;
  this->m_PrefsUseVibration = FrontEndMenuManager.m_PrefsUseVibration;
  this->m_PrefsRadioStation = FrontEndMenuManager.m_PrefsRadioStation;
  this->m_PrefsShowSubtitles = FrontEndMenuManager.m_PrefsShowSubtitles;
  this->m_PrefsLanguage = FrontEndMenuManager.m_PrefsLanguage;
  this->m_PrefsUseWideScreen = FrontEndMenuManager.m_PrefsUseWideScreen;
  this->m_PrefsDisplayHud = FrontEndMenuManager.m_PrefsDisplayHud;
  this->m_PrefsUseBass = FrontEndMenuManager.m_PrefsUseBass;
  this->m_PrefsAutoRetune = FrontEndMenuManager.m_PrefsAutoRetune;
  this->m_PrefsAudioOutputMode = FrontEndMenuManager.m_PrefsAudioOutputMode;
  this->m_waypoint_blip = gMobileMenu.waypoint_blip;
  this->m_bHasDisplayedPlayerQuitEnterCarHelpText = CPlayerPed::bHasDisplayedPlayerQuitEnterCarHelpText;
  v9 = CCheat::m_aCheatsActive[99];
  if ( CCheat::m_aCheatsActive[99] )
    v9 = 1;
  this->m_bTaxiNitroCheat = v9;
  v10 = CCheat::m_aCheatsActive[98];
  if ( CCheat::m_aCheatsActive[98] )
    v10 = 1;
  this->m_bPimpCheat = v10;
  this->m_CPIndex = CPIndex;
}
// 60: using guessed type int dword_60;
// FC: using guessed type int elf_hash_bucket[16411];

//----- (00484208) --------------------------------------------------------
void __fastcall CSimpleVariablesSaveStructure::Extract(CSimpleVariablesSaveStructure *this, uint32 *versionNum)
{
  __int64 v3; // kr00_8
  __int64 v4; // r2
  __int64 v5; // kr08_8
  UInt8 m_ClockStored; // r0
  __int64 v7; // kr10_8
  unsigned __int64 v8; // kr18_8
  Int32 m_ExtraColourWeatherType; // r1
  Int32 m_WaterConfiguration; // r5
  __int64 v11; // kr20_8

  *versionNum = this->m_VersionNumber;
  CGame::bMissionPackGame = this->m_MissionPackGame;
  v3 = *(_QWORD *)&this->m_CurrLevel;
  v4 = *(_QWORD *)&this->m_CameraPosition.y;
  CGame::currLevel = this->m_CurrLevel;
  CMatrix::SetTranslate(&TheCamera.m_cameraMatrix, *((float *)&v3 + 1), *(float *)&v4, *((float *)&v4 + 1));
  v5 = *(_QWORD *)&this->m_MillisecondsPerGameMinute;
  CClock::ms_nMillisecondsPerGameMinute = this->m_MillisecondsPerGameMinute;
  CClock::ms_nLastClockTick = HIDWORD(v5);
  CClock::ms_nGameClockMonths = this->m_GameClockMonths;
  CClock::ms_nGameClockDays = this->m_GameClockDays;
  CClock::ms_nGameClockHours = this->m_GameClockHours;
  CClock::ms_nGameClockMinutes = this->m_GameClockMinutes;
  CClock::CurrentDay = this->m_CurrentDay;
  CClock::ms_Stored_nGameClockMonths = this->m_StoredGameClockMonths;
  CClock::ms_Stored_nGameClockDays = this->m_StoredGameClockDays;
  CClock::ms_Stored_nGameClockHours = this->m_StoredGameClockHours;
  CClock::ms_Stored_nGameClockMinutes = this->m_StoredGameClockMinutes;
  m_ClockStored = this->m_ClockStored;
  CClock::bClockHasBeenStored = m_ClockStored != 0;
  CCheat::m_bHasPlayerCheated = this->m_bHasPlayerCheated;
  CTimer::m_snTimeInMilliseconds = this->m_TimeInMilliseconds;
  if ( CTimer::m_snTimeInMilliseconds >= 0xF6C36301 )
  {
    CTimer::m_snTimeInMilliseconds = 1;
    CClock::ms_nLastClockTick = 1;
  }
  v7 = *(_QWORD *)&this->m_TimeScale;
  v8 = *(_QWORD *)&this->m_TimeStepNonClipped;
  CTimer::ms_fTimeScale = this->m_TimeScale;
  CTimer::ms_fTimeStep = *((float *)&v7 + 1);
  CTimer::m_FrameCounter = HIDWORD(v8);
  LODWORD(CTimer::ms_fTimeStepNonClipped) = v8;
  CWeather::OldWeatherType = this->m_OldWeatherType;
  CWeather::NewWeatherType = this->m_NewWeatherType;
  CWeather::ForcedWeatherType = this->m_ForcedWeatherType;
  CWeather::InterpolationValue = this->m_InterpolationValue;
  CWeather::WeatherTypeInList = this->m_WeatherTypeInList;
  CWeather::Rain = this->m_Rain;
  TheCamera.m_nCarZoom = this->m_CarZoom;
  TheCamera.m_nPedZoom = this->m_PedZoom;
  gbCineyCamMessageDisplayed = this->m_bCineyCamMessageDisplayed;
  CGame::currArea = this->m_CurrArea;
  CTimeCycle::m_ExtraColour = this->m_ExtraColour;
  CTimeCycle::m_bExtraColourOn = this->m_ExtraColourOn;
  m_ExtraColourWeatherType = this->m_ExtraColourWeatherType;
  m_WaterConfiguration = this->m_WaterConfiguration;
  CTimeCycle::m_ExtraColourInter = this->m_ExtraColourInter;
  CTimeCycle::m_ExtraColourWeatherType = m_ExtraColourWeatherType;
  CWaterLevel::m_nWaterConfiguration = m_WaterConfiguration;
  gbLARiots = this->m_bLARiots;
  gbLARiots_NoPoliceCars = this->m_bLARiots_NoPoliceCars;
  v11 = *(_QWORD *)&this->m_MaximumWantedLevel;
  CWanted::MaximumWantedLevel = this->m_MaximumWantedLevel;
  CWanted::nMaximumWantedLevel = HIDWORD(v11);
  CLocalisation::germanGame = this->m_germanGame;
  CLocalisation::frenchGame = this->m_frenchGame;
  CLocalisation::nastyGame = this->m_nastyGame;
  if ( ForceGermanBuild )
  {
    CLocalisation::nastyGame = 1;
    CLocalisation::germanGame = 0;
  }
  gMobileMenu.waypoint_blip = this->m_waypoint_blip;
  CPlayerPed::bHasDisplayedPlayerQuitEnterCarHelpText = this->m_bHasDisplayedPlayerQuitEnterCarHelpText;
  if ( this->m_bTaxiNitroCheat )
  {
    if ( CCheat::m_aCheatFunctions[99] )
      CCheat::m_aCheatFunctions[99]();
    else
      CCheat::m_aCheatsActive[99] = CCheat::m_aCheatsActive[99] == 0;
  }
  if ( this->m_bPimpCheat )
  {
    if ( CCheat::m_aCheatFunctions[98] )
      CCheat::m_aCheatFunctions[98]();
    else
      CCheat::m_aCheatsActive[98] = CCheat::m_aCheatsActive[98] == 0;
  }
  CPIndex = this->m_CPIndex;
}
// 0: using guessed type int dword_0;
// 60: using guessed type int dword_60;
// 678910: using guessed type char *gbLARiots_ptr[8];

//----- (004845C8) --------------------------------------------------------
void __fastcall CObjectSaveStructure::Construct(CObjectSaveStructure *this, CObject *pObject)
{
  int m_nFlags; // r0
  Int16 StreamedScriptBrainToLoad; // r1
  int v6; // r0
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r1

  CCompressedMatrixNotAligned::CompressFromFullMatrix(&this->m_CompressedMatrix, pObject->m_pMat);
  this->m_ObjMessage = pObject->ObjectMessage;
  this->m_ObjMessageAmount = pObject->ObjectMessageAmount;
  this->m_nEndOfLifeTime = pObject->m_nEndOfLifeTime;
  m_nFlags = (int)pObject->m_nFlags;
  this->m_nEntityFlags.bdummy = pObject->m_nFlags.bdummy;
  *(_DWORD *)&this->m_nEntityFlags = m_nFlags;
  this->m_pad = 0;
  this->m_nObjectFlags = pObject->m_nObjectFlags;
  this->m_ObjectCreatedBy = pObject->ObjectCreatedBy;
  this->m_CollisionDamageEffect = pObject->m_nCollisionDamageEffect;
  this->m_StoredCollisionDamageEffect = pObject->m_nStoredCollisionDamageEffect;
  StreamedScriptBrainToLoad = pObject->StreamedScriptBrainToLoad;
  this->m_FlagsNeededByScripts = 0;
  this->StreamedScriptBrainToLoad = StreamedScriptBrainToLoad;
  v6 = (*(_DWORD *)&pObject->m_nPhysicalFlags >> 2) & 1;
  this->m_FlagsNeededByScripts = (*(_DWORD *)&pObject->m_nPhysicalFlags & 4) != 0;
  m_nPhysicalFlags = pObject->m_nPhysicalFlags;
  if ( (*(_WORD *)&m_nPhysicalFlags & 0x2000) != 0 )
  {
    LOBYTE(v6) = v6 | 2;
    this->m_FlagsNeededByScripts = v6;
    m_nPhysicalFlags = pObject->m_nPhysicalFlags;
  }
  if ( (*(_DWORD *)&m_nPhysicalFlags & 0x40000) != 0 )
  {
    LOBYTE(v6) = v6 | 4;
    this->m_FlagsNeededByScripts = v6;
    m_nPhysicalFlags = pObject->m_nPhysicalFlags;
  }
  if ( (*(_DWORD *)&m_nPhysicalFlags & 0x80000) != 0 )
  {
    LOBYTE(v6) = v6 | 8;
    this->m_FlagsNeededByScripts = v6;
    m_nPhysicalFlags = pObject->m_nPhysicalFlags;
  }
  if ( (*(_DWORD *)&m_nPhysicalFlags & 0x100000) != 0 )
  {
    LOBYTE(v6) = v6 | 0x10;
    this->m_FlagsNeededByScripts = v6;
    m_nPhysicalFlags = pObject->m_nPhysicalFlags;
  }
  if ( (*(_DWORD *)&m_nPhysicalFlags & 0x200000) != 0 )
  {
    LOBYTE(v6) = v6 | 0x20;
    this->m_FlagsNeededByScripts = v6;
    m_nPhysicalFlags = pObject->m_nPhysicalFlags;
  }
  if ( (*(_DWORD *)&m_nPhysicalFlags & 0x800000) != 0 )
    this->m_FlagsNeededByScripts = v6 | 0x40;
}

//----- (00484682) --------------------------------------------------------
void __fastcall CObjectSaveStructure::Extract(CObjectSaveStructure *this, CObject *pObject)
{
  CObject::CObjectFlags m_nObjectFlags; // r0
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r1
  CPhysical::CPhysicalFlags v6; // r2
  CPhysical::CPhysicalFlags v7; // r1
  CPhysical::CPhysicalFlags v8; // r2
  CPhysical::CPhysicalFlags v9; // r1
  CPhysical::CPhysicalFlags v10; // r2
  CPhysical::CPhysicalFlags v11; // r1
  CPhysical::CPhysicalFlags v12; // r2

  CCompressedMatrixNotAligned::DecompressIntoFullMatrix(&this->m_CompressedMatrix, pObject->m_pMat);
  pObject->ObjectMessage = this->m_ObjMessage;
  pObject->ObjectMessageAmount = this->m_ObjMessageAmount;
  pObject->m_nEndOfLifeTime = this->m_nEndOfLifeTime;
  pObject->m_nFlags = this->m_nEntityFlags;
  m_nObjectFlags = this->m_nObjectFlags;
  pObject->ObjectCreatedBy = 2;
  pObject->m_nObjectFlags = m_nObjectFlags;
  pObject->m_nCollisionDamageEffect = this->m_CollisionDamageEffect;
  m_nPhysicalFlags = pObject->m_nPhysicalFlags;
  pObject->m_nStoredCollisionDamageEffect = this->m_StoredCollisionDamageEffect;
  v6 = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags & 0xFFFFFFFB);
  pObject->StreamedScriptBrainToLoad = this->StreamedScriptBrainToLoad;
  if ( (this->m_FlagsNeededByScripts & 1) != 0 )
    v6 = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags | 4);
  pObject->m_nPhysicalFlags = v6;
  v7 = (CPhysical::CPhysicalFlags)(*(_DWORD *)&v6 & 0xFFFFDFFF);
  if ( (this->m_FlagsNeededByScripts & 2) != 0 )
    v7 = (CPhysical::CPhysicalFlags)(*(_DWORD *)&v6 | 0x2000);
  pObject->m_nPhysicalFlags = v7;
  v8 = (CPhysical::CPhysicalFlags)(*(_DWORD *)&v7 & 0xFFFBFFFF);
  if ( (this->m_FlagsNeededByScripts & 4) != 0 )
    v8 = (CPhysical::CPhysicalFlags)(*(_DWORD *)&v7 | 0x40000);
  pObject->m_nPhysicalFlags = v8;
  v9 = (CPhysical::CPhysicalFlags)(*(_DWORD *)&v8 & 0xFFF7FFFF);
  if ( (this->m_FlagsNeededByScripts & 8) != 0 )
    v9 = (CPhysical::CPhysicalFlags)(*(_DWORD *)&v8 | 0x80000);
  pObject->m_nPhysicalFlags = v9;
  v10 = (CPhysical::CPhysicalFlags)(*(_DWORD *)&v9 & 0xFFEFFFFF);
  if ( (this->m_FlagsNeededByScripts & 0x10) != 0 )
    v10 = (CPhysical::CPhysicalFlags)(*(_DWORD *)&v9 | 0x100000);
  pObject->m_nPhysicalFlags = v10;
  v11 = (CPhysical::CPhysicalFlags)(*(_DWORD *)&v10 & 0xFFDFFFFF);
  if ( (this->m_FlagsNeededByScripts & 0x20) != 0 )
    v11 = (CPhysical::CPhysicalFlags)(*(_DWORD *)&v10 | 0x200000);
  pObject->m_nPhysicalFlags = v11;
  v12 = (CPhysical::CPhysicalFlags)(*(_DWORD *)&v11 & 0xFF7FFFFF);
  if ( (this->m_FlagsNeededByScripts & 0x40) != 0 )
    v12 = (CPhysical::CPhysicalFlags)(*(_DWORD *)&v11 | 0x800000);
  pObject->m_nPhysicalFlags = v12;
}

//----- (00484760) --------------------------------------------------------
void __fastcall CPedSaveStructure::Construct(CPedSaveStructure *this, CPed *pPed)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  __int64 v6; // d16
  CMatrix *v7; // r0
  float m_heading; // s0
  __int64 m_nPedFlags; // d16
  __int64 v10; // d17
  CEntryExit *m_pLastEntryExit; // r0
  CEntryExit *pLink; // r1

  m_pMat = pPed->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  v6 = *(_QWORD *)&p_tx->m_translate.x;
  this->m_Position.z = p_tx->m_translate.z;
  *(_QWORD *)&this->m_Position.x = v6;
  v7 = pPed->m_pMat;
  if ( v7 )
    m_heading = atan2f(COERCE_FLOAT(LODWORD(v7->xy) ^ 0x80000000), v7->yy);
  else
    m_heading = pPed->m_transform.m_heading;
  this->m_heading = m_heading;
  this->m_nHealth = pPed->m_nHealth;
  this->m_nArmour = pPed->m_nArmour;
  this->m_CharCreatedBy = pPed->CharCreatedBy;
  this->m_nCurrentWeapon = pPed->m_nCurrentWeapon;
  this->m_nAreaCode = pPed->m_areaCode;
  this->m_nExtraMeleeCombo = pPed->m_nExtraMeleeCombo;
  this->m_nExtraMeleeComboFlags = pPed->m_nExtraMeleeComboFlags;
  m_nPedFlags = (__int64)pPed->m_nPedFlags;
  v10 = *((_QWORD *)&pPed->m_nPedFlags + 1);
  this->m_lastEntryExit = -1;
  *(_QWORD *)&this->m_nPedFlags = m_nPedFlags;
  *((_QWORD *)&this->m_nPedFlags + 1) = v10;
  m_pLastEntryExit = pPed->m_pLastEntryExit;
  if ( m_pLastEntryExit )
  {
    pLink = m_pLastEntryExit->pLink;
    if ( !pLink )
      pLink = pPed->m_pLastEntryExit;
    if ( pLink->areacode )
      this->m_lastEntryExit = -286331153
                            * (((char *)m_pLastEntryExit - (char *)CEntryExitManager::mp_poolEntryExits->m_aStorage) >> 2);
  }
  qmemcpy(this->m_WeaponSlots, pPed->m_WeaponSlots, sizeof(this->m_WeaponSlots));
}

//----- (00484830) --------------------------------------------------------
void __fastcall CPedSaveStructure::Extract(CPedSaveStructure *this, CPed *pPed)
{
  __int64 v4; // kr00_8
  CMatrix *m_pMat; // r3
  RwReal z; // r0
  float *p_tz; // r1
  int v8; // r6
  __int64 v9; // d17
  char *v10; // r5
  eWeaponType m_eWeaponType; // r0
  int32 m_modelId; // r0
  int32 m_modelId2; // r0
  int32 m_lastEntryExit; // r0
  CEntryExit *v15; // r0

  v4 = *(_QWORD *)&this->m_Position.x;
  m_pMat = pPed->m_pMat;
  z = this->m_Position.z;
  if ( m_pMat )
  {
    LODWORD(m_pMat->tx) = v4;
    pPed->m_pMat->ty = *((float *)&v4 + 1);
    p_tz = &pPed->m_pMat->tz;
  }
  else
  {
    *(_QWORD *)&pPed->m_transform.m_translate.x = v4;
    p_tz = &pPed->m_transform.m_translate.z;
  }
  *p_tz = z;
  pPed->m_fDesiredHeading = this->m_heading;
  pPed->m_fCurrentHeading = this->m_heading;
  pPed->m_nHealth = this->m_nHealth;
  pPed->m_nArmour = this->m_nArmour;
  pPed->m_nCurrentWeapon = this->m_nCurrentWeapon;
  CPed::SetCharCreatedBy(pPed, this->m_CharCreatedBy);
  v8 = 0;
  pPed->m_nExtraMeleeCombo = this->m_nExtraMeleeCombo;
  pPed->m_nExtraMeleeComboFlags = this->m_nExtraMeleeComboFlags;
  if ( IsMissionSave )
  {
    v9 = *((_QWORD *)&this->m_nPedFlags + 1);
    *(_QWORD *)&pPed->m_nPedFlags = this->m_nPedFlags;
    *((_QWORD *)&pPed->m_nPedFlags + 1) = v9;
  }
  *((_DWORD *)&pPed->m_nPedFlags + 3) &= ~2u;
  do
  {
    v10 = (char *)this + v8 * 28;
    m_eWeaponType = this->m_WeaponSlots[v8].m_eWeaponType;
    if ( m_eWeaponType )
    {
      m_modelId = CWeaponInfo::GetWeaponInfo(m_eWeaponType, 1)->m_modelId;
      if ( m_modelId != -1 )
      {
        CStreaming::RequestModel(m_modelId, 8);
        CStreaming::LoadAllRequestedModels(0);
      }
      m_modelId2 = CWeaponInfo::GetWeaponInfo(*((eWeaponType *)v10 + 6), 1)->m_modelId2;
      if ( m_modelId2 != -1 )
      {
        CStreaming::RequestModel(m_modelId2, 8);
        CStreaming::LoadAllRequestedModels(0);
      }
      CPed::GiveWeapon(pPed, *((eWeaponType *)v10 + 6), *((_DWORD *)v10 + 9), 0);
      pPed->m_WeaponSlots[v8].m_nAmmoInClip = *((_DWORD *)v10 + 8);
    }
    ++v8;
  }
  while ( v8 != 13 );
  CPed::SetCurrentWeapon(pPed, this->m_nCurrentWeapon);
  pPed->m_areaCode = this->m_nAreaCode;
  m_lastEntryExit = this->m_lastEntryExit;
  if ( m_lastEntryExit == -1 || (CEntryExitManager::mp_poolEntryExits->m_aFlags[m_lastEntryExit] & 0x80u) != 0 )
    v15 = 0;
  else
    v15 = (CEntryExit *)CEntryExitManager::mp_poolEntryExits->m_aStorage[m_lastEntryExit];
  pPed->m_pLastEntryExit = v15;
}

//----- (00484968) --------------------------------------------------------
void __fastcall CVehicleSaveStructure::Construct(CVehicleSaveStructure *this, CVehicle *pVehicle)
{
  int m_nVehicleFlags; // r0

  CMatrix::operator=(&this->m_Matrix, pVehicle->m_pMat);
  this->m_Colour1 = pVehicle->m_colour1;
  this->m_Colour2 = pVehicle->m_colour2;
  this->m_Colour3 = pVehicle->m_colour3;
  this->m_Colour4 = pVehicle->m_colour4;
  this->m_CarAlarmState = pVehicle->CarAlarmState;
  this->m_nMaxPassengers = pVehicle->m_nMaxPassengers;
  this->m_fSteerAngle = pVehicle->m_fSteerAngle;
  this->m_fGasPedal = pVehicle->m_fGasPedal;
  this->m_fBrakePedal = pVehicle->m_fBrakePedal;
  m_nVehicleFlags = (int)pVehicle->m_nVehicleFlags;
  *((_DWORD *)&this->m_nVehicleFlags + 1) = *((_DWORD *)&pVehicle->m_nVehicleFlags + 1);
  *(_DWORD *)&this->m_nVehicleFlags = m_nVehicleFlags;
  this->m_VehicleCreatedBy = pVehicle->VehicleCreatedBy;
  this->m_nHealth = pVehicle->m_nHealth;
  this->m_eDoorLockState = pVehicle->m_eDoorLockState;
  this->m_nPhysicalFlags = pVehicle->m_nPhysicalFlags;
  this->m_fMass = pVehicle->m_fMass;
  this->m_fTurnMass = pVehicle->m_fTurnMass;
  this->m_fBuoyancyConstant = pVehicle->m_fBuoyancyConstant;
}

//----- (004849F0) --------------------------------------------------------
void __fastcall CVehicleSaveStructure::Extract(CVehicleSaveStructure *this, CVehicle *pVehicle)
{
  int m_nVehicleFlags; // r0

  CPlaceable::SetMatrix(pVehicle, &this->m_Matrix);
  pVehicle->m_colour1 = this->m_Colour1;
  pVehicle->m_colour2 = this->m_Colour2;
  pVehicle->m_colour3 = this->m_Colour3;
  pVehicle->m_colour4 = this->m_Colour4;
  pVehicle->CarAlarmState = this->m_CarAlarmState;
  pVehicle->m_nMaxPassengers = this->m_nMaxPassengers;
  pVehicle->m_fSteerAngle = this->m_fSteerAngle;
  pVehicle->m_fGasPedal = this->m_fGasPedal;
  pVehicle->m_fBrakePedal = this->m_fBrakePedal;
  m_nVehicleFlags = (int)this->m_nVehicleFlags;
  *((_DWORD *)&pVehicle->m_nVehicleFlags + 1) = *((_DWORD *)&this->m_nVehicleFlags + 1);
  *(_DWORD *)&pVehicle->m_nVehicleFlags = m_nVehicleFlags;
  CVehicle::SetVehicleCreatedBy(pVehicle, this->m_VehicleCreatedBy, 1);
  pVehicle->m_nHealth = this->m_nHealth;
  pVehicle->m_eDoorLockState = this->m_eDoorLockState;
  pVehicle->m_nPhysicalFlags = this->m_nPhysicalFlags;
  pVehicle->m_fMass = this->m_fMass;
  pVehicle->m_fTurnMass = this->m_fTurnMass;
  pVehicle->m_fBuoyancyConstant = this->m_fBuoyancyConstant;
}

//----- (00484A7E) --------------------------------------------------------
void __fastcall CPlayerPedDataSaveStructure::Construct(
        CPlayerPedDataSaveStructure *this,
        CPlayerPedData *pPlayerPedData)
{
  this->m_nWantedLevel = pPlayerPedData->m_Wanted->m_nWantedLevel;
  this->m_WantedLevel = pPlayerPedData->m_Wanted->m_WantedLevel;
  qmemcpy(&this->m_Clothes, pPlayerPedData->m_pClothes, sizeof(this->m_Clothes));
  this->m_nChosenWeapon = pPlayerPedData->m_nChosenWeapon;
  this->m_fMultiplier = pPlayerPedData->m_Wanted->m_fMultiplier;
}

//----- (00484AB0) --------------------------------------------------------
void __fastcall CPlayerPedDataSaveStructure::Extract(CPlayerPedDataSaveStructure *this, CPlayerPedData *pPlayerPedData)
{
  CWanted *m_Wanted; // r0

  pPlayerPedData->m_Wanted->m_nWantedLevel = this->m_nWantedLevel;
  pPlayerPedData->m_Wanted->m_WantedLevel = this->m_WantedLevel;
  qmemcpy(pPlayerPedData->m_pClothes, &this->m_Clothes, sizeof(CPedClothesDesc));
  m_Wanted = pPlayerPedData->m_Wanted;
  pPlayerPedData->m_nChosenWeapon = this->m_nChosenWeapon;
  m_Wanted->m_fMultiplier = this->m_fMultiplier;
}

//----- (00484AE2) --------------------------------------------------------
void __fastcall CPlayerInfoSaveStructure::Construct(CPlayerInfoSaveStructure *this, CPlayerInfo *pPlayerInfo)
{
  this->m_Score = pPlayerInfo->Score;
  this->m_CarDensityForCurrentZone = pPlayerInfo->CarDensityForCurrentZone;
  this->m_PlayerState = pPlayerInfo->PlayerState;
  this->m_RoadDensityAroundPlayer = pPlayerInfo->RoadDensityAroundPlayer;
  this->m_DisplayScore = pPlayerInfo->DisplayScore;
  this->m_TimeLastEaten = pPlayerInfo->TimeLastEaten;
  this->m_CollectablesPickedUp = pPlayerInfo->CollectablesPickedUp;
  this->m_TotalNumCollectables = pPlayerInfo->TotalNumCollectables;
  this->m_DoesNotGetTired = pPlayerInfo->DoesNotGetTired;
  this->m_FastReload = pPlayerInfo->FastReload;
  this->m_FireProof = pPlayerInfo->FireProof;
  this->m_MaxHealth = pPlayerInfo->MaxHealth;
  this->m_MaxArmour = pPlayerInfo->MaxArmour;
  this->m_bGetOutOfJailFree = pPlayerInfo->bGetOutOfJailFree;
  this->m_bFreeHealthCare = pPlayerInfo->bFreeHealthCare;
  this->m_bCanDoDriveBy = pPlayerInfo->bCanDoDriveBy;
  this->m_nBustedAudioStatus = pPlayerInfo->m_nBustedAudioStatus;
  this->m_nLastBustMessageNumber = pPlayerInfo->m_nLastBustMessageNumber;
}

//----- (00484B5A) --------------------------------------------------------
void __fastcall CPlayerInfoSaveStructure::Extract(CPlayerInfoSaveStructure *this, CPlayerInfo *pPlayerInfo)
{
  pPlayerInfo->Score = this->m_Score;
  pPlayerInfo->CarDensityForCurrentZone = this->m_CarDensityForCurrentZone;
  pPlayerInfo->PlayerState = this->m_PlayerState;
  pPlayerInfo->CarDensityForCurrentZone = this->m_CarDensityForCurrentZone;
  pPlayerInfo->RoadDensityAroundPlayer = this->m_RoadDensityAroundPlayer;
  pPlayerInfo->DisplayScore = this->m_DisplayScore;
  pPlayerInfo->TimeLastEaten = this->m_TimeLastEaten;
  pPlayerInfo->CollectablesPickedUp = this->m_CollectablesPickedUp;
  pPlayerInfo->TotalNumCollectables = this->m_TotalNumCollectables;
  pPlayerInfo->DoesNotGetTired = this->m_DoesNotGetTired;
  pPlayerInfo->FastReload = this->m_FastReload;
  pPlayerInfo->FireProof = this->m_FireProof;
  pPlayerInfo->MaxHealth = this->m_MaxHealth;
  pPlayerInfo->MaxArmour = this->m_MaxArmour;
  pPlayerInfo->bGetOutOfJailFree = this->m_bGetOutOfJailFree;
  pPlayerInfo->bFreeHealthCare = this->m_bFreeHealthCare;
  pPlayerInfo->bCanDoDriveBy = this->m_bCanDoDriveBy;
  pPlayerInfo->m_nBustedAudioStatus = this->m_nBustedAudioStatus;
  pPlayerInfo->m_nLastBustMessageNumber = this->m_nLastBustMessageNumber;
}

//----- (00484BD8) --------------------------------------------------------
void __fastcall CGangWarsSaveStructure::Construct(CGangWarsSaveStructure *this)
{
  UInt32 v1; // r3
  Int32 v2; // r3
  int v3; // r1
  int v4; // r3
  Int32 v5; // r2
  __int64 v6; // d16
  __int64 v7; // d16

  this->m_bGangWarsActive = CGangWars::bGangWarsActive;
  v1 = CGangWars::TimeStarted;
  this->m_State = CGangWars::State;
  this->m_TimeStarted = v1;
  this->m_ZoneInfoToFightOver = -1;
  if ( CGangWars::pZoneInfoToFightOver && CTheZones::TotalNumberOfZoneInfos )
  {
    v2 = 0;
    v3 = (char *)CGangWars::pZoneInfoToFightOver - (char *)CTheZones::ZoneInfoArray + 17;
    while ( 1 )
    {
      v3 -= 17;
      if ( !v3 )
        break;
      if ( ++v2 >= CTheZones::TotalNumberOfZoneInfos )
        goto LABEL_8;
    }
    this->m_ZoneInfoToFightOver = v2;
  }
LABEL_8:
  this->m_ZoneToFightOver = -1;
  if ( CGangWars::pZoneToFightOver && CTheZones::TotalNumberOfNavigationZones )
  {
    v4 = (char *)CGangWars::pZoneToFightOver - (char *)CTheZones::NavigationZoneArray + 32;
    v5 = 0;
    while ( 1 )
    {
      v4 -= 32;
      if ( !v4 )
        break;
      if ( ++v5 >= CTheZones::TotalNumberOfNavigationZones )
        goto LABEL_15;
    }
    this->m_ZoneToFightOver = v5;
  }
LABEL_15:
  v6 = *(_QWORD *)&CGangWars::CoorsOfPlayerAtStartOfWar.x;
  this->m_CoorsOfPlayerAtStartOfWar.z = CGangWars::CoorsOfPlayerAtStartOfWar.z;
  *(_QWORD *)&this->m_CoorsOfPlayerAtStartOfWar.x = v6;
  this->m_Gang1 = CGangWars::Gang1;
  this->m_Gang2 = CGangWars::Gang2;
  this->m_WarFerocity = CGangWars::WarFerocity;
  this->m_LastTimeInArea = CGangWars::LastTimeInArea;
  this->m_State2 = CGangWars::State2;
  this->m_TimeTillNextAttack = CGangWars::TimeTillNextAttack;
  v7 = *(_QWORD *)&CGangWars::PointOfAttack.x;
  this->m_PointOfAttack.z = CGangWars::PointOfAttack.z;
  *(_QWORD *)&this->m_PointOfAttack.x = v7;
  this->m_FightTimer = CGangWars::FightTimer;
  this->m_RadarBlip = CGangWars::RadarBlip;
  this->m_bPlayerIsCloseby = CGangWars::bPlayerIsCloseby;
  this->m_TerritoryUnderControlPercentage = CGangWars::TerritoryUnderControlPercentage;
  this->m_Difficulty = CGangWars::Difficulty;
  this->m_CanTriggerGangWarWhenOnAMission = CGangWars::bCanTriggerGangWarWhenOnAMission;
  this->m_bTrainingMission = CGangWars::bTrainingMission;
  this->m_ZoneInfoForTraining = CGangWars::ZoneInfoForTraining;
}

//----- (00484DA0) --------------------------------------------------------
void __fastcall CGangWarsSaveStructure::Extract(CGangWarsSaveStructure *this)
{
  Int32 m_ZoneInfoToFightOver; // r1
  CZoneInfo *v2; // r3
  Int32 m_ZoneToFightOver; // r1
  CZone *v4; // r3
  __int64 v5; // d16
  __int64 v6; // d16
  __int64 v7; // kr00_8
  Int32 m_RadarBlip; // r3
  __int64 v9; // kr08_8

  CGangWars::bGangWarsActive = this->m_bGangWarsActive;
  CGangWars::State = this->m_State;
  CGangWars::TimeStarted = this->m_TimeStarted;
  m_ZoneInfoToFightOver = this->m_ZoneInfoToFightOver;
  v2 = &CTheZones::ZoneInfoArray[m_ZoneInfoToFightOver];
  if ( m_ZoneInfoToFightOver == -1 )
    v2 = 0;
  CGangWars::pZoneInfoToFightOver = v2;
  m_ZoneToFightOver = this->m_ZoneToFightOver;
  v4 = &CTheZones::NavigationZoneArray[m_ZoneToFightOver];
  if ( m_ZoneToFightOver == -1 )
    v4 = 0;
  CGangWars::pZoneToFightOver = v4;
  v5 = *(_QWORD *)&this->m_CoorsOfPlayerAtStartOfWar.x;
  CGangWars::CoorsOfPlayerAtStartOfWar.z = this->m_CoorsOfPlayerAtStartOfWar.z;
  *(_QWORD *)&CGangWars::CoorsOfPlayerAtStartOfWar.x = v5;
  CGangWars::Gang1 = this->m_Gang1;
  CGangWars::Gang2 = this->m_Gang2;
  CGangWars::WarFerocity = this->m_WarFerocity;
  CGangWars::LastTimeInArea = this->m_LastTimeInArea;
  CGangWars::State2 = this->m_State2;
  CGangWars::TimeTillNextAttack = this->m_TimeTillNextAttack;
  v6 = *(_QWORD *)&this->m_PointOfAttack.x;
  v7 = *(_QWORD *)&this->m_PointOfAttack.z;
  m_RadarBlip = this->m_RadarBlip;
  CGangWars::PointOfAttack.z = this->m_PointOfAttack.z;
  *(_QWORD *)&CGangWars::PointOfAttack.x = v6;
  CGangWars::FightTimer = HIDWORD(v7);
  CGangWars::RadarBlip = m_RadarBlip;
  CGangWars::bPlayerIsCloseby = this->m_bPlayerIsCloseby;
  v9 = *(_QWORD *)&this->m_TerritoryUnderControlPercentage;
  CGangWars::TerritoryUnderControlPercentage = this->m_TerritoryUnderControlPercentage;
  CGangWars::Difficulty = *((float *)&v9 + 1);
  CGangWars::bCanTriggerGangWarWhenOnAMission = this->m_CanTriggerGangWarWhenOnAMission;
  CGangWars::bTrainingMission = this->m_bTrainingMission;
  CGangWars::ZoneInfoForTraining = this->m_ZoneInfoForTraining;
}

//----- (00484F40) --------------------------------------------------------
bool __fastcall CObject::Save(CObject *this)
{
  _DWORD *v1; // r5
  CEntity::CFlags *v2; // r5
  CEntity::CFlags m_nEntityFlags; // d18
  CEntity::CFlags v4; // d19
  CEntity::CFlags v5; // d16
  CEntity::CFlags v6; // d17
  CEntity::CFlags v7; // d20
  CEntity::CFlags v8; // d21
  CObjectSaveStructure v10; // [sp+0h] [bp-40h] BYREF

  CObjectSaveStructure::Construct(&v10, this);
  v1 = malloc(4u);
  *v1 = 52;
  CGenericGameStorage::_SaveDataToWorkBuffer(v1, 4);
  free(v1);
  v2 = (CEntity::CFlags *)malloc(0x34u);
  m_nEntityFlags = v10.m_nEntityFlags;
  v4 = *(CEntity::CFlags *)&v10.m_pad;
  *(_DWORD *)&v2[6] = *(_DWORD *)&v10.m_StoredCollisionDamageEffect;
  v5 = *(CEntity::CFlags *)&v10.m_CompressedMatrix.CoorX;
  v6 = *(CEntity::CFlags *)&v10.m_CompressedMatrix.CoorZ;
  v2[4] = m_nEntityFlags;
  v2[5] = v4;
  v7 = *(CEntity::CFlags *)&v10.m_CompressedMatrix.Matrix_yy;
  v8 = *(CEntity::CFlags *)&v10.m_ObjMessage;
  *v2 = v5;
  v2[1] = v6;
  v2[2] = v7;
  v2[3] = v8;
  CGenericGameStorage::_SaveDataToWorkBuffer(v2, 52);
  free(v2);
  return 1;
}

//----- (00484FAC) --------------------------------------------------------
bool __fastcall CObject::Load(CObject *this)
{
  CObjectSaveStructure v3; // [sp+0h] [bp-40h] BYREF
  char pData[12]; // [sp+34h] [bp-Ch] BYREF

  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v3, 52);
  CObjectSaveStructure::Extract(&v3, this);
  return 1;
}
// 484FAC: using guessed type char pData[12];

//----- (00484FD4) --------------------------------------------------------
bool __fastcall CPed::Save(CPed *this)
{
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  double v4; // d16
  float m_heading; // s16
  uint8 m_nExtraMeleeComboFlags; // r8
  UInt8 CharCreatedBy; // r9
  float m_nArmour; // r10
  CEntryExit *m_pLastEntryExit; // r0
  CEntryExit *pLink; // r1
  int v11; // r11
  _DWORD *v12; // r5
  char *v13; // r5
  double v14; // d16
  int v15; // r1
  float m_nHealth; // [sp+0h] [bp-1D0h]
  int8 m_nCurrentWeapon; // [sp+4h] [bp-1CCh]
  uint8 m_areaCode; // [sp+8h] [bp-1C8h]
  uint8 m_nExtraMeleeCombo; // [sp+Ch] [bp-1C4h]
  _BYTE v21[18]; // [sp+10h] [bp-1C0h]
  char v22[364]; // [sp+28h] [bp-1A8h] BYREF
  double v23; // [sp+198h] [bp-38h]
  int z_low; // [sp+1A0h] [bp-30h]

  m_pMat = this->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &this->m_transform;
  v4 = *(double *)&p_tx->m_translate.x;
  z_low = LODWORD(p_tx->m_translate.z);
  v23 = v4;
  if ( m_pMat )
    m_heading = atan2f(COERCE_FLOAT(LODWORD(m_pMat->xy) ^ 0x80000000), m_pMat->yy);
  else
    m_heading = this->m_transform.m_heading;
  m_nExtraMeleeComboFlags = this->m_nExtraMeleeComboFlags;
  CharCreatedBy = this->CharCreatedBy;
  m_nArmour = this->m_nArmour;
  *(_QWORD *)&v21[2] = this->m_nPedFlags;
  *(_QWORD *)&v21[10] = *((_QWORD *)&this->m_nPedFlags + 1);
  m_pLastEntryExit = this->m_pLastEntryExit;
  m_areaCode = this->m_areaCode;
  m_nExtraMeleeCombo = this->m_nExtraMeleeCombo;
  m_nHealth = this->m_nHealth;
  m_nCurrentWeapon = this->m_nCurrentWeapon;
  if ( !m_pLastEntryExit )
    goto LABEL_11;
  pLink = m_pLastEntryExit->pLink;
  if ( !pLink )
    pLink = this->m_pLastEntryExit;
  if ( pLink->areacode )
    v11 = -286331153 * (((char *)m_pLastEntryExit - (char *)CEntryExitManager::mp_poolEntryExits->m_aStorage) >> 2);
  else
LABEL_11:
    v11 = -1;
  qmemcpy(v22, this->m_WeaponSlots, sizeof(v22));
  v12 = malloc(4u);
  *v12 = 420;
  CGenericGameStorage::_SaveDataToWorkBuffer(v12, 4);
  free(v12);
  v13 = (char *)malloc(0x1A4u);
  v14 = v23;
  v15 = z_low;
  *((float *)v13 + 4) = m_nHealth;
  *((float *)v13 + 5) = m_nArmour;
  *((_DWORD *)v13 + 2) = v15;
  *(double *)v13 = v14;
  *((float *)v13 + 3) = m_heading;
  qmemcpy(v13 + 24, v22, 0x16Cu);
  v13[388] = CharCreatedBy;
  v13[389] = m_nCurrentWeapon;
  v13[390] = m_areaCode;
  *((_DWORD *)v13 + 98) = v11;
  v13[396] = m_nExtraMeleeCombo;
  v13[397] = m_nExtraMeleeComboFlags;
  *(_QWORD *)(v13 + 398) = *(_QWORD *)v21;
  *(_QWORD *)(v13 + 406) = *(_QWORD *)&v21[8];
  *((_WORD *)v13 + 207) = *(_WORD *)&v21[16];
  CGenericGameStorage::_SaveDataToWorkBuffer(v13, 420);
  free(v13);
  return 1;
}
// 48510A: variable 'v21' is possibly undefined

//----- (00485138) --------------------------------------------------------
bool __fastcall CPed::Load(CPed *this)
{
  CPedSaveStructure v3; // [sp+0h] [bp-1B0h] BYREF
  char pData[12]; // [sp+1A4h] [bp-Ch] BYREF

  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v3, 420);
  CPedSaveStructure::Extract(&v3, this);
  return 1;
}
// 485138: using guessed type char pData[12];

//----- (00485162) --------------------------------------------------------
bool __fastcall CPlayerPed::Save(CPlayerPed *this)
{
  CPlayerPedData *m_pPlayerData; // r6
  CPedClothesDesc *v3; // r0
  _DWORD *v4; // r5
  void *v5; // r5
  _QWORD v7[19]; // [sp+0h] [bp-98h] BYREF

  CPedClothesDesc::CPedClothesDesc((CPedClothesDesc *)&v7[1]);
  m_pPlayerData = this->m_pPlayerData;
  LODWORD(v7[0]) = m_pPlayerData->m_Wanted->m_nWantedLevel;
  BYTE4(v7[0]) = m_pPlayerData->m_Wanted->m_WantedLevel;
  qmemcpy(v3, m_pPlayerData->m_pClothes, sizeof(CPedClothesDesc));
  LOBYTE(v7[16]) = m_pPlayerData->m_nChosenWeapon;
  HIDWORD(v7[16]) = LODWORD(m_pPlayerData->m_Wanted->m_fMultiplier);
  CPed::Save(this);
  v4 = malloc(4u);
  *v4 = 136;
  CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
  free(v4);
  v5 = malloc(0x88u);
  qmemcpy(v5, v7, 0x88u);
  CGenericGameStorage::_SaveDataToWorkBuffer(v5, 136);
  free(v5);
  return 1;
}
// 48518E: variable 'v3' is possibly undefined

//----- (004851E8) --------------------------------------------------------
bool __fastcall CPlayerPed::Load(CPlayerPed *this)
{
  CPlayerPedData *m_pPlayerData; // r5
  CWanted *m_Wanted; // r0
  int32 v5; // [sp+0h] [bp-240h] BYREF
  unsigned __int8 v6; // [sp+4h] [bp-23Ch]
  CPedClothesDesc v7; // [sp+8h] [bp-238h] BYREF
  int8 v8; // [sp+80h] [bp-1C0h]
  float v9; // [sp+84h] [bp-1BCh]
  CPedSaveStructure v10; // [sp+88h] [bp-1B8h] BYREF
  char pData[20]; // [sp+22Ch] [bp-14h] BYREF

  CPedClothesDesc::CPedClothesDesc(&v7);
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v10, 420);
  CPedSaveStructure::Extract(&v10, this);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v10, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v5, 136);
  m_pPlayerData = this->m_pPlayerData;
  m_pPlayerData->m_Wanted->m_nWantedLevel = v5;
  m_pPlayerData->m_Wanted->m_WantedLevel = v6;
  qmemcpy(m_pPlayerData->m_pClothes, &v7, sizeof(CPedClothesDesc));
  m_Wanted = m_pPlayerData->m_Wanted;
  m_pPlayerData->m_nChosenWeapon = v8;
  m_Wanted->m_fMultiplier = v9;
  return 1;
}
// 4851E8: using guessed type char pData[20];

//----- (00485264) --------------------------------------------------------
void __fastcall CPedIntelligence::Save(CPedIntelligence *this)
{
  CPedIntelligence *v1; // r10
  int v2; // r4
  bool v3; // r8
  __int16 v4; // r2
  __int16 v5; // r6
  _WORD *v6; // r5
  _DWORD *v7; // r5
  int i; // r11
  int v9; // r5
  int v10; // r6
  bool v11; // r8
  CPedIntelligence *v12; // r6
  __int16 v13; // r0
  __int16 v14; // r10
  _WORD *v15; // r4
  _DWORD *v16; // r4
  bool v17; // r4
  __int16 v18; // r0
  __int16 v19; // r8
  _WORD *v20; // r5
  _DWORD *v21; // r5
  CEvent **m_events; // r8
  int v23; // r10
  CEvent *v24; // r4
  int v25; // r5
  bool v26; // r11
  __int16 v27; // r0
  __int16 v28; // r9
  _WORD *v29; // r6
  _DWORD *v30; // r6
  bool v31; // r5
  __int16 v32; // r0
  __int16 v33; // r9
  _WORD *v34; // r4
  _DWORD *v35; // r4
  CEvent **v36; // [sp+14h] [bp-2Ch]
  int v37; // [sp+20h] [bp-20h]

  v1 = this;
  v2 = this->m_taskManager.m_tasks[1] != 0;
  if ( this->m_taskManager.m_tasks[0] )
    ++v2;
  v3 = UseDataFence;
  if ( this->m_taskManager.m_tasks[2] )
    ++v2;
  if ( this->m_taskManager.m_tasks[3] )
    ++v2;
  if ( this->m_taskManager.m_tasks[4] )
    ++v2;
  if ( UseDataFence )
  {
    v4 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v5 = v4 + DataFence;
    v6 = malloc(2u);
    *v6 = v5;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 2);
    free(v6);
    UseDataFence = v3;
  }
  v7 = malloc(4u);
  *v7 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
  free(v7);
  if ( v2 )
  {
    for ( i = 1; i != 6; ++i )
    {
      v9 = *((_DWORD *)&v1->m_pPed + i);
      if ( v9 )
      {
        v10 = (*(int (__fastcall **)(_DWORD))(*(_DWORD *)v9 + 20))(*((_DWORD *)&v1->m_pPed + i));
        v11 = UseDataFence;
        if ( UseDataFence )
        {
          v37 = v10;
          v12 = v1;
          UseDataFence = 0;
          v13 = currentSaveFenceCount++;
          v14 = v13 + DataFence;
          v15 = malloc(2u);
          *v15 = v14;
          v1 = v12;
          CGenericGameStorage::_SaveDataToWorkBuffer(v15, 2);
          free(v15);
          v10 = v37;
          UseDataFence = v11;
        }
        v16 = malloc(4u);
        *v16 = v10;
        CGenericGameStorage::_SaveDataToWorkBuffer(v16, 4);
        free(v16);
        (*(void (__fastcall **)(int))(*(_DWORD *)v9 + 32))(v9);
      }
      else
      {
        v17 = UseDataFence;
        if ( UseDataFence )
        {
          UseDataFence = 0;
          v18 = currentSaveFenceCount++;
          v19 = v18 + DataFence;
          v20 = malloc(2u);
          *v20 = v19;
          CGenericGameStorage::_SaveDataToWorkBuffer(v20, 2);
          free(v20);
          UseDataFence = v17;
        }
        v21 = malloc(4u);
        *v21 = -1;
        CGenericGameStorage::_SaveDataToWorkBuffer(v21, 4);
        free(v21);
      }
    }
  }
  m_events = v1->m_eventGroup.m_events;
  v23 = 0;
  v36 = m_events;
  do
  {
    v24 = m_events[v23];
    if ( v24 )
    {
      v25 = (*((int (__fastcall **)(CEvent *))v24->_vptr$CEvent + 2))(m_events[v23]);
      v26 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        v27 = currentSaveFenceCount++;
        v28 = v27 + DataFence;
        v29 = malloc(2u);
        *v29 = v28;
        CGenericGameStorage::_SaveDataToWorkBuffer(v29, 2);
        free(v29);
        UseDataFence = v26;
        m_events = v36;
      }
      v30 = malloc(4u);
      *v30 = v25;
      CGenericGameStorage::_SaveDataToWorkBuffer(v30, 4);
      free(v30);
      if ( v25 == 32 )
        (*(void (__fastcall **)(int))(*(_DWORD *)v24[1].m_iAccumulatedTime + 32))(v24[1].m_iAccumulatedTime);
    }
    else
    {
      v31 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        v32 = currentSaveFenceCount++;
        v33 = v32 + DataFence;
        v34 = malloc(2u);
        *v34 = v33;
        CGenericGameStorage::_SaveDataToWorkBuffer(v34, 2);
        free(v34);
        UseDataFence = v31;
      }
      v35 = malloc(4u);
      *v35 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v35, 4);
      free(v35);
    }
    ++v23;
  }
  while ( v23 != 16 );
}

//----- (0048559C) --------------------------------------------------------
void __fastcall CPedIntelligence::Load(CPedIntelligence *this)
{
  bool v2; // r5
  int v3; // r8
  bool v4; // r6
  CTask *Task; // r6
  int v6; // r6
  bool v7; // r5
  CTask *v8; // r5
  int32 PedRef; // r0
  CTaskManager *p_m_taskManager; // [sp+0h] [bp-28h]
  int v11; // [sp+4h] [bp-24h] BYREF
  int pData[8]; // [sp+8h] [bp-20h] BYREF

  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  if ( pData[0] )
  {
    p_m_taskManager = &this->m_taskManager;
    v3 = 0;
    while ( 1 )
    {
      v4 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 2);
        UseDataFence = v4;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 4);
      if ( v11 == -1 )
        goto LABEL_12;
      Task = CTask::CreateTask();
      CPools::GetPedRef(loadingPed);
      if ( !Task )
        goto LABEL_12;
      if ( v3 == 3 )
      {
        CTaskManager::SetTask(p_m_taskManager, Task, 3, 0);
        v3 = 4;
      }
      else
      {
        if ( v3 == 4 )
        {
          CTaskManager::SetTask(p_m_taskManager, Task, 4, 0);
          break;
        }
LABEL_12:
        if ( ++v3 == 5 )
          break;
      }
    }
  }
  v6 = 16;
  do
  {
    v7 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 2);
      UseDataFence = v7;
    }
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 4);
    if ( v11 == 32 )
    {
      v8 = CTask::CreateTask();
      PedRef = CPools::GetPedRef(loadingPed);
      CRunningScript::GivePedScriptedTask(missionScript, PedRef, v8, 1483);
    }
    --v6;
  }
  while ( v6 );
}

//----- (004856F4) --------------------------------------------------------
CTask *CTask::CreateTask()
{
  bool v0; // r4
  CTask *Task; // r4
  int v2; // r0
  void **v3; // r0
  int v4; // r0
  bool v5; // r4
  RwReal x; // r5
  int v7; // r1
  void **v8; // r0
  bool v9; // r4
  int v10; // r0
  int v11; // r0
  bool v12; // r4
  int v13; // r0
  bool v14; // r4
  int v15; // r0
  int v16; // r0
  bool v17; // r4
  int v18; // r0
  bool v19; // r4
  int v20; // r0
  int v21; // r0
  int v22; // r0
  int v23; // r0
  char *v24; // r0
  int v25; // r0
  bool v26; // r4
  bool v27; // r4
  int v28; // r0
  int v29; // r0
  bool v30; // r4
  int v31; // r0
  int v32; // r0
  int v33; // r0
  int v34; // r0
  int v35; // r0
  int v36; // r0
  int v37; // r0
  int v38; // r0
  int v39; // r0
  bool v40; // r4
  CPed *v41; // r5
  int v42; // r0
  bool v43; // r4
  CVehicle *v44; // r5
  int v45; // r0
  int v46; // r0
  int v47; // r0
  int v48; // r0
  bool v49; // r4
  CVehicle *v50; // r5
  int v51; // r0
  int v52; // r0
  int v53; // r0
  int v54; // r0
  int v55; // r0
  int v56; // r0
  int v57; // r0
  bool v58; // r4
  int v59; // r0
  int v60; // r0
  int v61; // r0
  int v62; // r0
  int v63; // r0
  bool v64; // r4
  int v65; // r0
  bool v66; // r4
  CPed *v67; // r5
  bool v68; // r4
  CPed *v69; // r5
  bool v70; // r4
  int v71; // r0
  bool v72; // r4
  bool v73; // r4
  bool v74; // r4
  bool v75; // r4
  int v76; // r0
  int v77; // r0
  int v78; // r0
  bool v79; // r4
  bool v80; // r4
  int v81; // r0
  bool v82; // r4
  RwReal v83; // r5
  int v84; // r0
  bool v85; // r4
  bool v86; // r4
  int v87; // r0
  bool v88; // r4
  bool v89; // r4
  bool v90; // r4
  CVehicle *Vehicle; // r5
  int v92; // r0
  int v93; // r0
  int v94; // r0
  int v95; // r0
  bool v96; // r4
  bool v98; // r4
  CPed *Ped; // r5
  int v100; // r0
  bool v101; // r4
  CVehicle *v102; // r5
  int v103; // r0
  int v104; // r0
  int v105; // r0
  bool v106; // r4
  CVehicle *v107; // r5
  int v108; // r0
  bool v109; // r4
  CVehicle *v110; // r5
  int v111; // r0
  bool v112; // r4
  CVehicle *v113; // r5
  bool v114; // r4
  CVehicle *v115; // r5
  int v116; // r0
  bool v117; // r4
  CVehicle *v118; // r5
  int v119; // r0
  int v120; // r0
  int v121; // r0
  int v122; // r0
  int v123; // r0
  int v124; // r0
  int v125; // r0
  int v126; // r0
  int v127; // r0
  int v128; // r0
  int v129; // r0
  int v130; // r0
  int v131; // r0
  int v132; // r0
  bool v133; // r4
  bool v134; // r4
  int32 PedRef; // r0
  int v136; // [sp+18h] [bp-20h] BYREF
  int iUnconsciousTime; // [sp+1Ch] [bp-1Ch] BYREF
  CVector pData; // [sp+20h] [bp-18h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v136, 4);
  Task = 0;
  switch ( v136 )
  {
    case 100:
      CTaskComplexMedicTreatInjuredPed::CreateTask();
      return (CTask *)v2;
    case 101:
      CTaskComplexTreatAccident::CreateTask();
      return (CTask *)v4;
    case 102:
      CTaskSimpleGiveCPR::CreateTask();
      return (CTask *)v71;
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
    case 125:
    case 126:
    case 127:
    case 128:
    case 129:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 136:
    case 137:
    case 138:
    case 139:
    case 140:
    case 141:
    case 142:
    case 143:
    case 144:
    case 145:
    case 146:
    case 147:
    case 148:
    case 149:
    case 150:
    case 151:
    case 152:
    case 153:
    case 154:
    case 155:
    case 156:
    case 157:
    case 158:
    case 159:
    case 160:
    case 161:
    case 162:
    case 163:
    case 164:
    case 165:
    case 166:
    case 167:
    case 168:
    case 169:
    case 170:
    case 171:
    case 172:
    case 173:
    case 174:
    case 175:
    case 176:
    case 177:
    case 178:
    case 179:
    case 180:
    case 181:
    case 182:
    case 183:
    case 184:
    case 185:
    case 186:
    case 187:
    case 188:
    case 189:
    case 190:
    case 191:
    case 192:
    case 193:
    case 194:
    case 195:
    case 196:
    case 197:
    case 198:
    case 199:
    case 200:
    case 201:
    case 206:
    case 212:
    case 226:
    case 232:
    case 233:
    case 234:
    case 235:
    case 244:
    case 245:
    case 246:
    case 247:
    case 248:
    case 249:
    case 251:
    case 252:
    case 253:
    case 256:
    case 257:
    case 259:
    case 260:
    case 264:
    case 265:
    case 266:
    case 267:
    case 272:
    case 273:
    case 280:
    case 281:
    case 282:
    case 283:
    case 284:
    case 285:
    case 286:
    case 287:
    case 288:
    case 289:
    case 290:
    case 291:
    case 292:
    case 293:
    case 294:
    case 295:
    case 296:
    case 297:
    case 298:
    case 299:
    case 300:
    case 304:
    case 306:
    case 307:
    case 308:
    case 309:
    case 312:
    case 313:
    case 314:
    case 315:
    case 316:
    case 317:
    case 318:
    case 319:
    case 320:
    case 321:
    case 322:
    case 323:
    case 324:
    case 325:
    case 326:
    case 327:
    case 328:
    case 329:
    case 330:
    case 331:
    case 332:
    case 333:
    case 334:
    case 335:
    case 336:
    case 337:
    case 338:
    case 339:
    case 340:
    case 341:
    case 342:
    case 343:
    case 344:
    case 345:
    case 346:
    case 347:
    case 348:
    case 349:
    case 350:
    case 351:
    case 352:
    case 353:
    case 354:
    case 355:
    case 356:
    case 357:
    case 358:
    case 359:
    case 360:
    case 361:
    case 362:
    case 363:
    case 364:
    case 365:
    case 366:
    case 367:
    case 368:
    case 369:
    case 370:
    case 371:
    case 372:
    case 373:
    case 374:
    case 375:
    case 376:
    case 377:
    case 378:
    case 379:
    case 380:
    case 381:
    case 382:
    case 383:
    case 384:
    case 385:
    case 386:
    case 387:
    case 388:
    case 389:
    case 390:
    case 391:
    case 392:
    case 393:
    case 394:
    case 395:
    case 396:
    case 397:
    case 398:
    case 399:
    case 400:
    case 402:
    case 417:
    case 418:
    case 424:
    case 427:
    case 428:
    case 429:
    case 430:
    case 431:
    case 432:
    case 433:
    case 434:
    case 435:
    case 436:
    case 437:
    case 438:
    case 439:
    case 440:
    case 441:
    case 442:
    case 443:
    case 444:
    case 445:
    case 446:
    case 447:
    case 448:
    case 449:
    case 450:
    case 451:
    case 452:
    case 453:
    case 454:
    case 455:
    case 456:
    case 457:
    case 458:
    case 459:
    case 460:
    case 461:
    case 462:
    case 463:
    case 464:
    case 465:
    case 466:
    case 467:
    case 468:
    case 469:
    case 470:
    case 471:
    case 472:
    case 473:
    case 474:
    case 475:
    case 476:
    case 477:
    case 478:
    case 479:
    case 480:
    case 481:
    case 482:
    case 483:
    case 484:
    case 485:
    case 486:
    case 487:
    case 488:
    case 489:
    case 490:
    case 491:
    case 492:
    case 493:
    case 494:
    case 495:
    case 496:
    case 497:
    case 498:
    case 499:
    case 516:
    case 517:
    case 518:
    case 519:
    case 520:
    case 521:
    case 522:
    case 523:
    case 524:
    case 525:
    case 526:
    case 527:
    case 528:
    case 529:
    case 530:
    case 531:
    case 532:
    case 533:
    case 534:
    case 535:
    case 536:
    case 537:
    case 538:
    case 539:
    case 540:
    case 541:
    case 542:
    case 543:
    case 544:
    case 545:
    case 546:
    case 547:
    case 548:
    case 549:
    case 550:
    case 551:
    case 552:
    case 553:
    case 554:
    case 555:
    case 556:
    case 557:
    case 558:
    case 559:
    case 560:
    case 561:
    case 562:
    case 563:
    case 564:
    case 565:
    case 566:
    case 567:
    case 568:
    case 569:
    case 570:
    case 571:
    case 572:
    case 573:
    case 574:
    case 575:
    case 576:
    case 577:
    case 578:
    case 579:
    case 580:
    case 581:
    case 582:
    case 583:
    case 584:
    case 585:
    case 586:
    case 587:
    case 588:
    case 589:
    case 590:
    case 591:
    case 592:
    case 593:
    case 594:
    case 595:
    case 596:
    case 597:
    case 598:
    case 599:
    case 603:
    case 605:
    case 606:
    case 607:
    case 608:
    case 609:
    case 610:
    case 611:
    case 612:
    case 613:
    case 614:
    case 615:
    case 616:
    case 617:
    case 618:
    case 619:
    case 620:
    case 621:
    case 622:
    case 623:
    case 624:
    case 625:
    case 626:
    case 627:
    case 628:
    case 629:
    case 630:
    case 631:
    case 632:
    case 633:
    case 634:
    case 635:
    case 636:
    case 637:
    case 638:
    case 639:
    case 640:
    case 641:
    case 642:
    case 643:
    case 644:
    case 645:
    case 646:
    case 647:
    case 648:
    case 649:
    case 650:
    case 651:
    case 652:
    case 653:
    case 654:
    case 655:
    case 656:
    case 657:
    case 658:
    case 659:
    case 660:
    case 661:
    case 662:
    case 663:
    case 664:
    case 665:
    case 666:
    case 667:
    case 668:
    case 669:
    case 670:
    case 671:
    case 672:
    case 673:
    case 674:
    case 675:
    case 676:
    case 677:
    case 678:
    case 679:
    case 680:
    case 681:
    case 682:
    case 683:
    case 684:
    case 685:
    case 686:
    case 687:
    case 688:
    case 689:
    case 690:
    case 691:
    case 692:
    case 693:
    case 694:
    case 695:
    case 696:
    case 697:
    case 698:
    case 699:
    case 727:
    case 731:
    case 732:
    case 733:
    case 734:
    case 735:
    case 736:
    case 737:
    case 738:
    case 739:
    case 740:
    case 741:
    case 742:
    case 743:
    case 744:
    case 745:
    case 746:
    case 747:
    case 748:
    case 749:
    case 750:
    case 751:
    case 752:
    case 753:
    case 754:
    case 755:
    case 756:
    case 757:
    case 758:
    case 759:
    case 760:
    case 761:
    case 762:
    case 763:
    case 764:
    case 765:
    case 766:
    case 767:
    case 768:
    case 769:
    case 770:
    case 771:
    case 772:
    case 773:
    case 774:
    case 775:
    case 776:
    case 777:
    case 778:
    case 779:
    case 780:
    case 781:
    case 782:
    case 783:
    case 784:
    case 785:
    case 786:
    case 787:
    case 788:
    case 789:
    case 790:
    case 791:
    case 792:
    case 793:
    case 794:
    case 795:
    case 796:
    case 797:
    case 798:
    case 799:
    case 801:
    case 802:
    case 803:
    case 804:
    case 805:
    case 806:
    case 807:
    case 808:
    case 809:
    case 810:
    case 811:
    case 812:
    case 813:
    case 814:
    case 815:
    case 816:
    case 817:
    case 818:
    case 819:
    case 820:
    case 821:
    case 822:
    case 823:
    case 824:
    case 825:
    case 826:
    case 827:
    case 828:
    case 829:
    case 830:
    case 831:
    case 832:
    case 833:
    case 834:
    case 835:
    case 836:
    case 837:
    case 838:
    case 839:
    case 840:
    case 841:
    case 842:
    case 843:
    case 844:
    case 845:
    case 846:
    case 847:
    case 848:
    case 849:
    case 850:
    case 851:
    case 852:
    case 853:
    case 854:
    case 855:
    case 856:
    case 857:
    case 858:
    case 859:
    case 860:
    case 861:
    case 862:
    case 863:
    case 864:
    case 865:
    case 866:
    case 867:
    case 868:
    case 869:
    case 870:
    case 871:
    case 872:
    case 873:
    case 874:
    case 875:
    case 876:
    case 877:
    case 878:
    case 879:
    case 880:
    case 881:
    case 882:
    case 883:
    case 884:
    case 885:
    case 886:
    case 887:
    case 888:
    case 889:
    case 890:
    case 891:
    case 892:
    case 893:
    case 894:
    case 895:
    case 896:
    case 897:
    case 898:
    case 899:
    case 900:
    case 908:
    case 909:
    case 910:
    case 912:
    case 913:
    case 914:
    case 915:
    case 916:
    case 919:
    case 921:
    case 922:
    case 923:
    case 925:
    case 926:
    case 928:
    case 929:
    case 930:
    case 932:
    case 934:
    case 935:
    case 936:
    case 937:
    case 938:
    case 939:
    case 940:
    case 941:
    case 942:
    case 943:
    case 944:
    case 945:
    case 946:
    case 947:
    case 948:
    case 949:
    case 950:
    case 951:
    case 952:
    case 953:
    case 954:
    case 955:
    case 956:
    case 957:
    case 958:
    case 959:
    case 960:
    case 961:
    case 962:
    case 963:
    case 964:
    case 965:
    case 966:
    case 967:
    case 968:
    case 969:
    case 970:
    case 971:
    case 972:
    case 973:
    case 974:
    case 975:
    case 976:
    case 977:
    case 978:
    case 979:
    case 980:
    case 981:
    case 982:
    case 983:
    case 984:
    case 985:
    case 986:
    case 987:
    case 988:
    case 989:
    case 990:
    case 991:
    case 992:
    case 993:
    case 994:
    case 995:
    case 996:
    case 997:
    case 998:
    case 999:
    case 1001:
    case 1002:
    case 1004:
    case 1005:
    case 1006:
    case 1007:
    case 1008:
    case 1009:
    case 1010:
    case 1011:
    case 1012:
    case 1013:
    case 1014:
    case 1015:
    case 1016:
    case 1018:
    case 1019:
    case 1021:
    case 1023:
    case 1024:
    case 1025:
    case 1026:
    case 1027:
    case 1028:
    case 1029:
    case 1030:
    case 1031:
    case 1032:
    case 1033:
    case 1034:
    case 1035:
    case 1036:
    case 1037:
    case 1038:
    case 1039:
    case 1040:
    case 1041:
    case 1042:
    case 1043:
    case 1044:
    case 1045:
    case 1046:
    case 1047:
    case 1048:
    case 1049:
    case 1050:
    case 1051:
    case 1052:
    case 1053:
    case 1054:
    case 1055:
    case 1056:
    case 1057:
    case 1058:
    case 1059:
    case 1060:
    case 1061:
    case 1062:
    case 1063:
    case 1064:
    case 1065:
    case 1066:
    case 1067:
    case 1068:
    case 1069:
    case 1070:
    case 1071:
    case 1072:
    case 1073:
    case 1074:
    case 1075:
    case 1076:
    case 1077:
    case 1078:
    case 1079:
    case 1080:
    case 1081:
    case 1082:
    case 1083:
    case 1084:
    case 1085:
    case 1086:
    case 1087:
    case 1088:
    case 1089:
    case 1090:
    case 1091:
    case 1092:
    case 1093:
    case 1094:
    case 1095:
    case 1096:
    case 1097:
    case 1098:
    case 1099:
    case 1100:
    case 1101:
    case 1102:
    case 1103:
    case 1104:
    case 1105:
    case 1106:
    case 1107:
    case 1108:
    case 1109:
    case 1110:
    case 1111:
    case 1112:
    case 1113:
    case 1114:
    case 1115:
    case 1116:
    case 1117:
    case 1118:
    case 1119:
    case 1120:
    case 1121:
    case 1122:
    case 1123:
    case 1124:
    case 1125:
    case 1126:
    case 1127:
    case 1128:
    case 1129:
    case 1130:
    case 1131:
    case 1132:
    case 1133:
    case 1134:
    case 1135:
    case 1136:
    case 1137:
    case 1138:
    case 1139:
    case 1140:
    case 1141:
    case 1142:
    case 1143:
    case 1144:
    case 1145:
    case 1146:
    case 1147:
    case 1148:
    case 1149:
    case 1150:
    case 1151:
    case 1152:
    case 1153:
    case 1154:
    case 1155:
    case 1156:
    case 1157:
    case 1158:
    case 1159:
    case 1160:
    case 1161:
    case 1162:
    case 1163:
    case 1164:
    case 1165:
    case 1166:
    case 1167:
    case 1168:
    case 1169:
    case 1170:
    case 1171:
    case 1172:
    case 1173:
    case 1174:
    case 1175:
    case 1176:
    case 1177:
    case 1178:
    case 1179:
    case 1180:
    case 1181:
    case 1182:
    case 1183:
    case 1184:
    case 1185:
    case 1186:
    case 1187:
    case 1188:
    case 1189:
    case 1190:
    case 1191:
    case 1192:
    case 1193:
    case 1194:
    case 1195:
    case 1196:
    case 1197:
    case 1198:
    case 1199:
    case 1200:
    case 1201:
    case 1202:
    case 1203:
    case 1205:
    case 1206:
    case 1207:
    case 1208:
    case 1209:
    case 1210:
    case 1211:
    case 1212:
    case 1213:
    case 1214:
    case 1215:
    case 1216:
    case 1217:
    case 1218:
    case 1220:
    case 1221:
    case 1222:
    case 1223:
    case 1224:
    case 1225:
    case 1226:
    case 1227:
    case 1228:
    case 1229:
    case 1230:
    case 1231:
    case 1232:
    case 1233:
    case 1234:
    case 1235:
    case 1236:
    case 1237:
    case 1238:
    case 1239:
    case 1240:
    case 1241:
    case 1242:
    case 1243:
    case 1244:
    case 1245:
    case 1246:
    case 1247:
    case 1248:
    case 1249:
    case 1250:
    case 1251:
    case 1252:
    case 1253:
    case 1254:
    case 1255:
    case 1256:
    case 1257:
    case 1258:
    case 1259:
    case 1260:
    case 1261:
    case 1262:
    case 1263:
    case 1264:
    case 1265:
    case 1266:
    case 1267:
    case 1268:
    case 1269:
    case 1270:
    case 1271:
    case 1272:
    case 1273:
    case 1274:
    case 1275:
    case 1276:
    case 1277:
    case 1278:
    case 1279:
    case 1280:
    case 1281:
    case 1282:
    case 1283:
    case 1284:
    case 1285:
    case 1286:
    case 1287:
    case 1288:
    case 1289:
    case 1290:
    case 1291:
    case 1292:
    case 1293:
    case 1294:
    case 1295:
    case 1296:
    case 1297:
    case 1298:
    case 1299:
    case 1300:
    case 1302:
    case 1305:
    case 1310:
    case 1311:
    case 1312:
    case 1313:
    case 1314:
    case 1315:
    case 1316:
    case 1317:
    case 1318:
    case 1319:
    case 1320:
    case 1321:
    case 1322:
    case 1323:
    case 1324:
    case 1325:
    case 1326:
    case 1327:
    case 1328:
    case 1329:
    case 1330:
    case 1331:
    case 1332:
    case 1333:
    case 1334:
    case 1335:
    case 1336:
    case 1337:
    case 1338:
    case 1339:
    case 1340:
    case 1341:
    case 1342:
    case 1343:
    case 1344:
    case 1345:
    case 1346:
    case 1347:
    case 1348:
    case 1349:
    case 1350:
    case 1351:
    case 1352:
    case 1353:
    case 1354:
    case 1355:
    case 1356:
    case 1357:
    case 1358:
    case 1359:
    case 1360:
    case 1361:
    case 1362:
    case 1363:
    case 1364:
    case 1365:
    case 1366:
    case 1367:
    case 1368:
    case 1369:
    case 1370:
    case 1371:
    case 1372:
    case 1373:
    case 1374:
    case 1375:
    case 1376:
    case 1377:
    case 1378:
    case 1379:
    case 1380:
    case 1381:
    case 1382:
    case 1383:
    case 1384:
    case 1385:
    case 1386:
    case 1387:
    case 1388:
    case 1389:
    case 1390:
    case 1391:
    case 1392:
    case 1393:
    case 1394:
    case 1395:
    case 1396:
    case 1397:
    case 1398:
    case 1399:
    case 1400:
    case 1401:
    case 1402:
    case 1403:
    case 1404:
    case 1405:
    case 1406:
    case 1407:
    case 1408:
    case 1409:
    case 1410:
    case 1411:
    case 1412:
    case 1413:
    case 1414:
    case 1415:
    case 1416:
    case 1417:
    case 1418:
    case 1419:
    case 1420:
    case 1421:
    case 1422:
    case 1423:
    case 1424:
    case 1425:
    case 1426:
    case 1427:
    case 1428:
    case 1429:
    case 1430:
    case 1431:
    case 1432:
    case 1433:
    case 1434:
    case 1435:
    case 1436:
    case 1437:
    case 1438:
    case 1439:
    case 1440:
    case 1441:
    case 1442:
    case 1443:
    case 1444:
    case 1445:
    case 1446:
    case 1447:
    case 1448:
    case 1449:
    case 1450:
    case 1451:
    case 1452:
    case 1453:
    case 1454:
    case 1455:
    case 1456:
    case 1457:
    case 1458:
    case 1459:
    case 1460:
    case 1461:
    case 1462:
    case 1463:
    case 1464:
    case 1465:
    case 1466:
    case 1467:
    case 1468:
    case 1469:
    case 1470:
    case 1471:
    case 1472:
    case 1473:
    case 1474:
    case 1475:
    case 1476:
    case 1477:
    case 1478:
    case 1479:
    case 1480:
    case 1481:
    case 1482:
    case 1483:
    case 1484:
    case 1485:
    case 1486:
    case 1487:
    case 1488:
    case 1489:
    case 1490:
    case 1491:
    case 1492:
    case 1493:
    case 1494:
    case 1495:
    case 1496:
    case 1497:
    case 1498:
    case 1499:
    case 1500:
    case 1501:
    case 1502:
    case 1503:
    case 1504:
    case 1505:
    case 1506:
    case 1507:
    case 1508:
    case 1509:
    case 1510:
    case 1511:
    case 1512:
    case 1513:
    case 1514:
    case 1515:
    case 1516:
    case 1517:
    case 1518:
    case 1519:
    case 1520:
    case 1521:
    case 1522:
    case 1523:
    case 1524:
    case 1525:
    case 1526:
    case 1527:
    case 1528:
    case 1529:
    case 1530:
    case 1531:
    case 1532:
    case 1533:
    case 1534:
    case 1535:
    case 1536:
    case 1537:
    case 1538:
    case 1539:
    case 1540:
    case 1541:
    case 1542:
    case 1543:
    case 1544:
    case 1545:
    case 1546:
    case 1547:
    case 1548:
    case 1549:
    case 1550:
    case 1551:
    case 1552:
    case 1553:
    case 1554:
    case 1555:
    case 1556:
    case 1557:
    case 1558:
    case 1559:
    case 1560:
    case 1561:
    case 1562:
    case 1563:
    case 1564:
    case 1565:
    case 1566:
    case 1567:
    case 1568:
    case 1569:
    case 1570:
    case 1571:
    case 1572:
    case 1573:
    case 1574:
    case 1575:
    case 1576:
    case 1577:
    case 1578:
    case 1579:
    case 1580:
    case 1581:
    case 1582:
    case 1583:
    case 1584:
    case 1585:
    case 1586:
    case 1587:
    case 1588:
    case 1589:
    case 1590:
    case 1591:
    case 1592:
    case 1593:
    case 1594:
    case 1595:
    case 1596:
    case 1597:
    case 1598:
    case 1599:
    case 1601:
    case 1602:
    case 1603:
      return Task;
    case 110:
      v72 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v72;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 12);
      Task = (CTask *)CTask::operator new(0x18u);
      CTaskComplexExtinguishFireOnFoot::CTaskComplexExtinguishFireOnFoot(
        (CTaskComplexExtinguishFireOnFoot *)Task,
        &pData);
      return Task;
    case 202:
      v5 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v5;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      Task = (CTask *)CTask::operator new(0x18u);
      x = pData.x;
      CTaskSimple::CTaskSimple((CTaskSimple *)Task);
      v7 = 0;
      LOWORD(Task[2]._vptr$CTask) = 0;
      v8 = &`vtable for'CTaskSimplePause;
      *(RwReal *)&Task[2].m_pParent = x;
      Task[1]._vptr$CTask = 0;
      goto LABEL_48;
    case 203:
      Task = (CTask *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(
        (CTaskSimpleStandStill *)Task,
        (const int)&elf_hash_bucket[4937],
        0,
        0,
        8.0);
      return Task;
    case 204:
      v9 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v9;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 1);
      Task = (CTask *)CTask::operator new(0xCu);
      CTaskSimpleSetStayInSamePlace::CTaskSimpleSetStayInSamePlace(
        (CTaskSimpleSetStayInSamePlace *)Task,
        SLOBYTE(pData.x));
      return Task;
    case 205:
      Task = (CTask *)CTask::operator new(0x10u);
      CTaskSimpleGetUp::CTaskSimpleGetUp((CTaskSimpleGetUp *)Task);
      return Task;
    case 207:
      Task = (CTask *)CTask::operator new(0xCu);
      CTaskComplexGetUpAndStandStill::CTaskComplexGetUpAndStandStill((CTaskComplexGetUpAndStandStill *)Task);
      return Task;
    case 208:
      CTaskComplexFallAndGetUp::CreateTask();
      return (CTask *)v10;
    case 209:
      CTaskComplexFallAndStayDown::CreateTask();
      return (CTask *)v11;
    case 210:
      v73 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v73;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 1);
      Task = (CTask *)CTask::operator new(0x2Cu);
      CTaskSimpleJump::CTaskSimpleJump((CTaskSimpleJump *)Task, SLOBYTE(pData.x));
      return Task;
    case 211:
      v12 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v12;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      Task = (CTask *)CTask::operator new(0x14u);
      CTaskComplexJump::CTaskComplexJump((CTaskComplexJump *)Task, SLODWORD(pData.x));
      return Task;
    case 213:
      Task = (CTask *)CTask::operator new(0x2Cu);
      CTaskSimpleDrown::CTaskSimpleDrown((CTaskSimpleDrown *)Task);
      return Task;
    case 214:
      CTaskSimpleDieInCar::CreateTask();
      return (CTask *)v13;
    case 215:
      v14 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v14;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      Task = (CTask *)CTask::operator new(0x1Cu);
      CTaskComplexDieInCar::CTaskComplexDieInCar((CTaskComplexDieInCar *)Task, SLODWORD(pData.x));
      return Task;
    case 216:
      Task = (CTask *)CTask::operator new(8u);
      CTaskSimpleDrownInCar::CTaskSimpleDrownInCar((CTaskSimpleDrownInCar *)Task);
      return Task;
    case 217:
      CTaskComplexDie::CreateTask();
      return (CTask *)v15;
    case 218:
      CTaskSimpleDead::CreateTask();
      return (CTask *)v16;
    case 219:
      v74 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v74;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      Task = (CTask *)CTask::operator new(0x1Cu);
      CTaskSimpleTired::CTaskSimpleTired((CTaskSimpleTired *)Task, SLODWORD(pData.x));
      return Task;
    case 220:
      v75 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v75;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 1);
      Task = (CTask *)CTask::operator new(0x10u);
      CTaskSimpleSitDown::CTaskSimpleSitDown((CTaskSimpleSitDown *)Task, LOBYTE(pData.x));
      return Task;
    case 221:
      CTaskSimpleSitIdle::CreateTask();
      return (CTask *)v76;
    case 222:
      v17 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v17;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 1);
      Task = (CTask *)CTask::operator new(0x10u);
      CTaskSimpleStandUp::CTaskSimpleStandUp((CTaskSimpleStandUp *)Task, LOBYTE(pData.x));
      return Task;
    case 223:
      CTaskComplexSitDownThenIdleThenStandUp::CreateTask();
      return (CTask *)v77;
    case 224:
      Task = (CTask *)CTask::operator new(0x18u);
      CTaskComplexObserveTrafficLights::CTaskComplexObserveTrafficLights((CTaskComplexObserveTrafficLights *)Task);
      return Task;
    case 225:
      CTaskComplexObserveTrafficLightsAndAchieveHeading::CreateTask();
      return (CTask *)v78;
    case 227:
      CTaskComplexCrossRoadLookAndAchieveHeading::CreateTask();
      return (CTask *)v18;
    case 228:
      Task = (CTask *)CTask::operator new(0x10u);
      CTaskSimpleTurn180::CTaskSimpleTurn180((CTaskSimpleTurn180 *)Task);
      return Task;
    case 229:
      Task = (CTask *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        (CTaskSimpleRunAnim *)Task,
        ANIM_STD_PED,
        ANIM_STD_HAILTAXI,
        4.0,
        229,
        "HailTaxi",
        0);
      v3 = &`vtable for'CTaskSimpleHailTaxi;
      goto LABEL_208;
    case 230:
      v79 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v79;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      Task = (CTask *)CTask::operator new(0x10u);
      CTaskComplexHitResponse::CTaskComplexHitResponse((CTaskComplexHitResponse *)Task, SLODWORD(pData.x));
      return Task;
    case 231:
      v19 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v19;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      Task = (CTask *)CTask::operator new(0x10u);
      CTaskComplexHitByGunResponse::CTaskComplexHitByGunResponse(
        (CTaskComplexHitByGunResponse *)Task,
        SLODWORD(pData.x));
      return Task;
    case 236:
      Task = (CTask *)CTask::operator new(0xCu);
      CTaskComplexWaitForDryWeather::CTaskComplexWaitForDryWeather((CTaskComplexWaitForDryWeather *)Task);
      return Task;
    case 237:
      Task = (CTask *)CTask::operator new(0x10u);
      CTaskComplexWaitForBus::CTaskComplexWaitForBus((CTaskComplexWaitForBus *)Task);
      return Task;
    case 238:
      Task = (CTask *)CTask::operator new(0xCu);
      CTaskSimpleWaitForBus::CTaskSimpleWaitForBus((CTaskSimpleWaitForBus *)Task);
      return Task;
    case 239:
      Task = (CTask *)CTask::operator new(0x14u);
      CTaskSimpleWaitForPizza::CTaskSimpleWaitForPizza((CTaskSimpleWaitForPizza *)Task);
      return Task;
    case 240:
      CTaskComplexInAirAndLand::CreateTask();
      return (CTask *)v20;
    case 241:
      CTaskSimpleInAir::CreateTask();
      return (CTask *)v21;
    case 242:
      v80 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v80;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      Task = (CTask *)CTask::operator new(0x14u);
      CTaskSimpleLand::CTaskSimpleLand((CTaskSimpleLand *)Task, SLODWORD(pData.x));
      return Task;
    case 243:
      CTaskComplexBeInGroup::CreateTask();
      return (CTask *)v22;
    case 250:
      Task = (CTask *)CTask::operator new(0xCu);
      CTaskComplexOnFire::CTaskComplexOnFire((CTaskComplexOnFire *)Task);
      return Task;
    case 254:
      CTaskSimpleClimb::CreateTask();
      return (CTask *)v23;
    case 255:
      Task = (CTask *)CTask::operator new(0x18u);
      CTaskSimplePlayerOnFire::CTaskSimplePlayerOnFire((CTaskSimplePlayerOnFire *)Task);
      return Task;
    case 258:
      Task = (CTask *)CTask::operator new(0x10u);
      CTaskComplexUseClosestFreeScriptedAttractor::CTaskComplexUseClosestFreeScriptedAttractor(
        (CTaskComplexUseClosestFreeScriptedAttractor *)Task,
        0);
      return Task;
    case 261:
      Task = (CTask *)CTask::operator new(0x10u);
      CTaskComplexUseClosestFreeScriptedAttractor::CTaskComplexUseClosestFreeScriptedAttractor(
        (CTaskComplexUseClosestFreeScriptedAttractor *)Task,
        0);
      v7 = 6;
      v8 = &`vtable for'CTaskComplexUseClosestFreeScriptedAttractorRun;
      goto LABEL_48;
    case 262:
      Task = (CTask *)CTask::operator new(0x10u);
      CTaskComplexUseClosestFreeScriptedAttractor::CTaskComplexUseClosestFreeScriptedAttractor(
        (CTaskComplexUseClosestFreeScriptedAttractor *)Task,
        0);
      v7 = 7;
      v8 = &`vtable for'CTaskComplexUseClosestFreeScriptedAttractorSprint;
LABEL_48:
      v24 = (char *)*v8;
      Task[1].m_pParent = (CTask *)v7;
      goto LABEL_209;
    case 263:
      CTaskSimpleChoking::CreateTask();
      return (CTask *)v25;
    case 268:
      Task = (CTask *)CTask::operator new(0xCu);
      CTaskComplexInWater::CTaskComplexInWater((CTaskComplexInWater *)Task);
      return Task;
    case 269:
      CTaskSimpleTriggerLookAt::CreateTask();
      return (CTask *)v81;
    case 270:
      Task = (CTask *)CTask::operator new(8u);
      CTaskSimpleClearLookAt::CTaskSimpleClearLookAt((CTaskSimpleClearLookAt *)Task);
      return Task;
    case 271:
      v82 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v82;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      Task = (CTask *)CTask::operator new(0xCu);
      v83 = pData.x;
      CTaskSimple::CTaskSimple((CTaskSimple *)Task);
      *(RwReal *)&Task[1]._vptr$CTask = v83;
      v3 = &`vtable for'CTaskSimpleSetCharDecisionMaker;
      goto LABEL_208;
    case 274:
      Task = (CTask *)CTask::operator new(0xCu);
      CTaskComplex::CTaskComplex((CTaskComplex *)Task);
      v3 = &`vtable for'CTaskComplexBeStill;
      goto LABEL_208;
    case 275:
      return CTaskComplexUseSequence::CreateTask();
    case 276:
      v26 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v26;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 1);
      Task = (CTask *)CTask::operator new(0xCu);
      CTaskSimpleSetKindaStayInSamePlace::CTaskSimpleSetKindaStayInSamePlace(
        (CTaskSimpleSetKindaStayInSamePlace *)Task,
        SLOBYTE(pData.x));
      return Task;
    case 277:
      CTaskComplexFallToDeath::CreateTask();
      return (CTask *)v84;
    case 278:
      return CTaskSimpleWaitUntilLeaderAreaCodesMatch::CreateTask();
    case 279:
      v27 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v27;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      Task = (CTask *)CTask::operator new(0x34u);
      CTaskSimpleRunTimedAnim::CTaskSimpleRunTimedAnim(
        (CTaskSimpleRunTimedAnim *)Task,
        ANIM_STD_PED,
        ANIM_STD_HAILTAXI,
        4.0,
        -4.0,
        SLODWORD(pData.x),
        279,
        "HailTaxiAndPause",
        0);
      v3 = &`vtable for'CTaskSimpleHailTaxiAndPause;
      goto LABEL_208;
    case 301:
      return CTaskSimpleSay::CreateTask();
    case 302:
      Task = (CTask *)CTask::operator new(0x10u);
      CTaskSimpleShakeFist::CTaskSimpleShakeFist((CTaskSimpleShakeFist *)Task);
      return Task;
    case 303:
      CTaskSimpleFacial::CreateTask();
      return (CTask *)v28;
    case 305:
      Task = (CTask *)CTask::operator new(0x20u);
      CTaskComplexFacial::CTaskComplexFacial((CTaskComplexFacial *)Task);
      return Task;
    case 310:
      CTaskComplexGoPickUpEntity::CreateTask();
      return (CTask *)v29;
    case 311:
      v85 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v85;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
      Task = (CTask *)CTask::operator new(0x28u);
      CTaskSimpleDuckWhileShotsWhizzing::CTaskSimpleDuckWhileShotsWhizzing(
        (CTaskSimpleDuckWhileShotsWhizzing *)Task,
        LOWORD(pData.x));
      return Task;
    case 401:
      return CTaskSimpleRunNamedAnim::CreateTask();
    case 403:
      Task = (CTask *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        (CTaskSimpleRunAnim *)Task,
        ANIM_STD_PED,
        ANIM_STD_HIT_BACK,
        4.0,
        403,
        "HitFromBack",
        0);
      v3 = &`vtable for'CTaskSimpleHitFromBack;
      goto LABEL_208;
    case 404:
      Task = (CTask *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        (CTaskSimpleRunAnim *)Task,
        ANIM_STD_PED,
        ANIM_STD_HIT_FRONT,
        4.0,
        404,
        "HitFromFront",
        0);
      v3 = &`vtable for'CTaskSimpleHitFromFront;
      goto LABEL_208;
    case 405:
      Task = (CTask *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        (CTaskSimpleRunAnim *)Task,
        ANIM_STD_PED,
        ANIM_STD_HIT_LEFT,
        4.0,
        405,
        "HitFromLeft",
        0);
      v3 = &`vtable for'CTaskSimpleHitFromLeft;
      goto LABEL_208;
    case 406:
      Task = (CTask *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        (CTaskSimpleRunAnim *)Task,
        ANIM_STD_PED,
        ANIM_STD_HIT_RIGHT,
        4.0,
        406,
        "HitFromRight",
        0);
      v3 = &`vtable for'CTaskSimpleHitFromRight;
      goto LABEL_208;
    case 407:
      Task = (CTask *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        (CTaskSimpleRunAnim *)Task,
        ANIM_STD_PED,
        ANIM_STD_HITBYGUN_BACK,
        4.0,
        407,
        "HitByGunFromRear",
        0);
      v3 = &`vtable for'CTaskSimpleHitByGunFromRear;
      goto LABEL_208;
    case 408:
      Task = (CTask *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        (CTaskSimpleRunAnim *)Task,
        ANIM_STD_PED,
        ANIM_STD_HITBYGUN_FRONT,
        4.0,
        408,
        "HitByGunFromFront",
        0);
      v3 = &`vtable for'CTaskSimpleHitByGunFromFront;
      goto LABEL_208;
    case 409:
      Task = (CTask *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        (CTaskSimpleRunAnim *)Task,
        ANIM_STD_PED,
        ANIM_STD_HITBYGUN_LEFT,
        4.0,
        409,
        "HitByGunFromLeft",
        0);
      v3 = &`vtable for'CTaskSimpleHitByGunFromLeft;
      goto LABEL_208;
    case 410:
      Task = (CTask *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        (CTaskSimpleRunAnim *)Task,
        ANIM_STD_PED,
        ANIM_STD_HITBYGUN_RIGHT,
        4.0,
        410,
        "HitByGunFromRight",
        0);
      v3 = &`vtable for'CTaskSimpleHitByGunFromRight;
      goto LABEL_208;
    case 411:
      Task = (CTask *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        (CTaskSimpleRunAnim *)Task,
        ANIM_STD_PED,
        ANIM_STD_HIT_WALL,
        4.0,
        411,
        "HitWall",
        0);
      v3 = &`vtable for'CTaskSimpleHitWall;
      goto LABEL_208;
    case 412:
      Task = (CTask *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        (CTaskSimpleRunAnim *)Task,
        ANIM_STD_PED,
        ANIM_STD_HANDSCOWER,
        4.0,
        412,
        "Cower",
        0);
      v3 = &`vtable for'CTaskSimpleCower;
      goto LABEL_208;
    case 413:
      v86 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v86;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      Task = (CTask *)CTask::operator new(0x34u);
      CTaskSimpleRunTimedAnim::CTaskSimpleRunTimedAnim(
        (CTaskSimpleRunTimedAnim *)Task,
        ANIM_STD_PED,
        ANIM_STD_HANDSUP,
        4.0,
        -4.0,
        SLODWORD(pData.x),
        413,
        "HandsUp",
        0);
      v3 = &`vtable for'CTaskSimpleHandsUp;
      goto LABEL_208;
    case 414:
      Task = (CTask *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        (CTaskSimpleRunAnim *)Task,
        ANIM_STD_PED,
        ANIM_STD_HIT_BEHIND,
        4.0,
        414,
        "HitFromBehind",
        0);
      v3 = &`vtable for'CTaskSimpleHitFromBehind;
      goto LABEL_208;
    case 415:
      CTaskSimpleDuck::CreateTask();
      return (CTask *)v87;
    case 416:
      v88 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v88;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      Task = (CTask *)CTask::operator new(0x34u);
      CTaskSimpleRunTimedAnim::CTaskSimpleRunTimedAnim(
        (CTaskSimpleRunTimedAnim *)Task,
        ANIM_STD_PED,
        ANIM_STD_CHAT,
        4.0,
        -4.0,
        SLODWORD(pData.x),
        416,
        "Chat",
        0);
      v3 = &`vtable for'CTaskSimpleChat;
      goto LABEL_208;
    case 419:
      v30 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v30;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      Task = (CTask *)CTask::operator new(0x34u);
      CTaskSimpleRunTimedAnim::CTaskSimpleRunTimedAnim(
        (CTaskSimpleRunTimedAnim *)Task,
        ANIM_STD_PED,
        ANIM_STD_DETONATE,
        4.0,
        -4.0,
        SLODWORD(pData.x),
        419,
        "Detonate",
        0);
      v3 = &`vtable for'CTaskSimpleDetonate;
      goto LABEL_208;
    case 420:
      Task = (CTask *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        (CTaskSimpleRunAnim *)Task,
        ANIM_STD_PED,
        ANIM_STD_ATM,
        4.0,
        420,
        "UseAtm",
        0);
      v3 = &`vtable for'CTaskSimpleUseAtm;
      goto LABEL_208;
    case 421:
      Task = (CTask *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        (CTaskSimpleRunAnim *)Task,
        ANIM_STD_PED,
        ANIM_STD_XPRESS_SCRATCH,
        4.0,
        421,
        "ScratchHead",
        0);
      v3 = &`vtable for'CTaskSimpleScratchHead;
      goto LABEL_208;
    case 422:
      v89 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v89;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      Task = (CTask *)CTask::operator new(0x34u);
      CTaskSimpleRunTimedAnim::CTaskSimpleRunTimedAnim(
        (CTaskSimpleRunTimedAnim *)Task,
        ANIM_STD_PED,
        ANIM_STD_IDLE_HBHB,
        4.0,
        -4.0,
        SLODWORD(pData.x),
        422,
        "LookAbout",
        0);
      v3 = &`vtable for'CTaskSimpleLookAbout;
      goto LABEL_208;
    case 423:
      Task = (CTask *)CTask::operator new(0x20u);
      CTaskSimpleRunAnim::CTaskSimpleRunAnim(
        (CTaskSimpleRunAnim *)Task,
        ANIM_STD_PED,
        ANIM_STD_ABSEIL,
        4.0,
        423,
        "Abseil",
        0);
      v3 = &`vtable for'CTaskSimpleAbseil;
      goto LABEL_208;
    case 425:
      CTaskSimplePlayHandSignalAnim::CreateTask();
      return (CTask *)v31;
    case 426:
      CTaskComplexPlayHandSignalAnim::CreateTask();
      return (CTask *)v32;
    case 500:
      Task = (CTask *)CTask::operator new(0x10u);
      CTaskSimpleHitHead::CTaskSimpleHitHead((CTaskSimpleHitHead *)Task);
      return Task;
    case 501:
      CTaskSimpleEvasiveStep::CreateTask();
      return (CTask *)v33;
    case 502:
      CTaskComplexEvasiveStep::CreateTask();
      return (CTask *)v34;
    case 503:
      v90 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v90;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      if ( LODWORD(pData.x) == -1 )
        Vehicle = 0;
      else
        Vehicle = CPools::GetVehicle(SLODWORD(pData.x));
      Task = (CTask *)CTask::operator new(0x14u);
      CTaskSimpleEvasiveDive::CTaskSimpleEvasiveDive((CTaskSimpleEvasiveDive *)Task, Vehicle);
      return Task;
    case 504:
      CTaskComplexEvasiveDiveAndGetUp::CreateTask();
      return (CTask *)v35;
    case 505:
      CTaskComplexHitPedWithCar::CreateTask();
      return (CTask *)v92;
    case 506:
      CTaskSimpleKillPedWithCar::CreateTask();
      return (CTask *)v36;
    case 507:
      CTaskSimpleHurtPedWithCar::CreateTask();
      return (CTask *)v93;
    case 508:
      CTaskComplexWalkRoundCar::CreateTask();
      return (CTask *)v94;
    case 509:
      CTaskComplexWalkRoundBuildingAttempt::CreateTask();
      return (CTask *)v95;
    case 510:
      CTaskComplexWalkRoundObject::CreateTask();
      return (CTask *)v37;
    case 511:
      Task = (CTask *)CTask::operator new(0xCu);
      CTaskComplexMoveBackAndJump::CTaskComplexMoveBackAndJump((CTaskComplexMoveBackAndJump *)Task);
      return Task;
    case 512:
      CTaskComplexEvasiveCower::CreateTask();
      return (CTask *)v38;
    case 513:
      v96 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v96;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&iUnconsciousTime, 4);
      Task = (CTask *)CTask::operator new(0x24u);
      memset(&pData, 0, sizeof(pData));
      CTaskComplexEvasiveDiveAndGetUp::CTaskComplexEvasiveDiveAndGetUp(
        (CTaskComplexEvasiveDiveAndGetUp *)Task,
        0,
        iUnconsciousTime,
        &pData,
        1);
      v3 = &`vtable for'CTaskComplexDiveFromAttachedEntityAndGetUp;
      goto LABEL_208;
    case 514:
      CTaskComplexWalkRoundFire::CreateTask();
      return (CTask *)v39;
    case 515:
      Task = (CTask *)CTask::operator new(0xCu);
      CTaskComplexStuckInAir::CTaskComplexStuckInAir((CTaskComplexStuckInAir *)Task);
      return Task;
    case 600:
      v98 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v98;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      if ( LODWORD(pData.x) == -1 )
        Ped = 0;
      else
        Ped = CPools::GetPed(SLODWORD(pData.x));
      Task = (CTask *)CTask::operator new(0x3Cu);
      CTaskComplexInvestigateDeadPed::CTaskComplexInvestigateDeadPed((CTaskComplexInvestigateDeadPed *)Task, Ped);
      return Task;
    case 601:
      v40 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v40;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      if ( LODWORD(pData.x) == -1 )
        v41 = 0;
      else
        v41 = CPools::GetPed(SLODWORD(pData.x));
      Task = (CTask *)CTask::operator new(0x1Cu);
      CTaskComplexReactToGunAimedAt::CTaskComplexReactToGunAimedAt((CTaskComplexReactToGunAimedAt *)Task, v41);
      return Task;
    case 602:
      CTaskComplexWaitForBackup::CreateTask();
      return (CTask *)v42;
    case 604:
      Task = (CTask *)CTask::operator new(0x10u);
      CTaskComplexExtinguishFires::CTaskComplexExtinguishFires((CTaskComplexExtinguishFires *)Task);
      return Task;
    case 700:
      CTaskComplexEnterCarAsPassenger::CreateTask();
      return (CTask *)v100;
    case 701:
      v43 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v43;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      if ( LODWORD(pData.x) == -1 )
        v44 = 0;
      else
        v44 = CPools::GetVehicle(SLODWORD(pData.x));
      Task = (CTask *)CTask::operator new(0x50u);
      CTaskComplexEnterCarAsDriver::CTaskComplexEnterCarAsDriver((CTaskComplexEnterCarAsDriver *)Task, v44);
      return Task;
    case 702:
      v101 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v101;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      if ( LODWORD(pData.x) == -1 )
        v102 = 0;
      else
        v102 = CPools::GetVehicle(SLODWORD(pData.x));
      Task = (CTask *)CTask::operator new(0x20u);
      CTaskComplexStealCar::CTaskComplexStealCar((CTaskComplexStealCar *)Task, v102);
      return Task;
    case 703:
      CTaskComplexDragPedFromCar::CreateTask();
      return (CTask *)v45;
    case 704:
      CTaskComplexLeaveCar::CreateTask();
      return (CTask *)v103;
    case 705:
      return CTaskComplexLeaveCarAndDie::CreateTask();
    case 706:
      CTaskComplexLeaveCarAndFlee::CreateTask();
      return (CTask *)v104;
    case 707:
      CTaskComplexLeaveCarAndWander::CreateTask();
      return (CTask *)v105;
    case 708:
      CTaskComplexScreamInCarThenLeave::CreateTask();
      return (CTask *)v46;
    case 709:
      v106 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v106;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      if ( LODWORD(pData.x) == -1 )
        v107 = 0;
      else
        v107 = CPools::GetVehicle(SLODWORD(pData.x));
      Task = (CTask *)CTask::operator new(0x60u);
      CTaskSimpleCarDrive::CTaskSimpleCarDrive((CTaskSimpleCarDrive *)Task, v107, 0, 0);
      return Task;
    case 710:
      CTaskComplexDriveToPoint::CreateTask();
      return (CTask *)v108;
    case 711:
      CTaskComplexCarDriveWander::CreateTask();
      return (CTask *)v47;
    case 712:
      CTaskComplexEnterCarAsPassengerTimed::CreateTask();
      return (CTask *)v48;
    case 713:
      v49 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v49;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      if ( LODWORD(pData.x) == -1 )
        v50 = 0;
      else
        v50 = CPools::GetVehicle(SLODWORD(pData.x));
      Task = (CTask *)CTask::operator new(0x24u);
      CTaskComplexEnterCarAsDriverTimed::CTaskComplexEnterCarAsDriverTimed(
        (CTaskComplexEnterCarAsDriverTimed *)Task,
        v50,
        (const int)&elf_hash_bucket[4937]);
      Task[2].m_pParent = (CTask *)CPedIntelligence::ms_iDesiredMoveState;
      CPedIntelligence::ms_iDesiredMoveState = 6;
      if ( loadingPed )
      {
        PedRef = CPools::GetPedRef(loadingPed);
        CRunningScript::GivePedScriptedTask(missionScript, PedRef, Task, 1483);
        return 0;
      }
      return Task;
    case 714:
      return CTaskComplexLeaveAnyCar::CreateTask();
    case 715:
      v109 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v109;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      if ( LODWORD(pData.x) == -1 )
        v110 = 0;
      else
        v110 = CPools::GetVehicle(SLODWORD(pData.x));
      Task = (CTask *)CTask::operator new(0x10u);
      CTaskComplexEnterBoatAsDriver::CTaskComplexEnterBoatAsDriver((CTaskComplexEnterBoatAsDriver *)Task, v110);
      return Task;
    case 716:
      CTaskComplexLeaveBoat::CreateTask();
      return (CTask *)v111;
    case 717:
      Task = (CTask *)CTask::operator new(0xCu);
      CTaskComplexEnterAnyCarAsDriver::CTaskComplexEnterAnyCarAsDriver((CTaskComplexEnterAnyCarAsDriver *)Task);
      return Task;
    case 718:
      CTaskComplexEnterCarAsPassengerWait::CreateTask();
      return (CTask *)v51;
    case 719:
      return CTaskSimpleCarDriveTimed::CreateTask();
    case 720:
      v112 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v112;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      if ( LODWORD(pData.x) == -1 )
        v113 = 0;
      else
        v113 = CPools::GetVehicle(SLODWORD(pData.x));
      Task = (CTask *)CTask::operator new(0x2Cu);
      CTaskComplexShuffleSeats::CTaskComplexShuffleSeats((CTaskComplexShuffleSeats *)Task, v113);
      return Task;
    case 721:
      CTaskComplexDrivePointRoute::CreateTask();
      return (CTask *)v52;
    case 722:
      v114 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v114;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      if ( LODWORD(pData.x) == -1 )
        v115 = 0;
      else
        v115 = CPools::GetVehicle(SLODWORD(pData.x));
      Task = (CTask *)CTask::operator new(0x50u);
      CTaskComplexOpenDriverDoor::CTaskComplexOpenDriverDoor((CTaskComplexOpenDriverDoor *)Task, v115);
      return Task;
    case 723:
      CTaskSimpleCarSetTempAction::CreateTask();
      return (CTask *)v116;
    case 724:
      CTaskComplexCarDriveMission::CreateTask();
      return (CTask *)v53;
    case 725:
      CTaskComplexCarDrive::CreateTask();
      return (CTask *)v54;
    case 726:
      return CTaskComplexCarDriveMissionFleeScene::CreateTask();
    case 728:
      CTaskComplexOpenPassengerDoor::CreateTask();
      return (CTask *)v55;
    case 729:
      return CTaskComplexCarDriveMissionKillPed::CreateTask();
    case 730:
      v117 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v117;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      if ( LODWORD(pData.x) == -1 )
        v118 = 0;
      else
        v118 = CPools::GetVehicle(SLODWORD(pData.x));
      Task = (CTask *)CTask::operator new(0x10u);
      CTaskComplexLeaveCarAsPassengerWait::CTaskComplexLeaveCarAsPassengerWait(
        (CTaskComplexLeaveCarAsPassengerWait *)Task,
        v118);
      return Task;
    case 800:
      CTaskComplexGoToCarDoorAndStandStill::CreateTask();
      return (CTask *)v119;
    case 901:
      CTaskComplexGoToPointShooting::CreateTask();
      return (CTask *)v120;
    case 902:
      CTaskSimpleAchieveHeading::CreateTask();
      return (CTask *)v121;
    case 903:
      CTaskComplexGoToPointAndStandStill::CreateTask();
      return (CTask *)v122;
    case 904:
      CTaskComplexGoToPointAndStandStillAndAchieveHeading::CreateTask();
      return (CTask *)v56;
    case 905:
      CTaskComplexFollowPointRoute::CreateTask();
      return (CTask *)v123;
    case 906:
      CTaskComplexFollowNodeRoute::CreateTask();
      return (CTask *)v57;
    case 907:
      v58 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v58;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      switch ( LODWORD(pData.x) )
      {
        case 0:
          Task = CTaskComplexSeekEntity<CEntitySeekPosCalculator>::CreateTask();
          break;
        case 1:
          Task = CTaskComplexSeekEntity<CEntitySeekPosCalculatorStandard>::CreateTask();
          break;
        case 2:
          Task = CTaskComplexSeekEntity<CEntitySeekPosCalculatorRadiusAngleOffset>::CreateTask();
          break;
        case 3:
          Task = CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset>::CreateTask();
          break;
        case 4:
          Task = CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface>::CreateTask();
          break;
        case 5:
          Task = CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId>::CreateTask();
          break;
        case 6:
          Task = CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving>::CreateTask();
          break;
        case 7:
          Task = CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos>::CreateTask();
          break;
        default:
          Task = 0;
          break;
      }
      return Task;
    case 911:
      CTaskComplexSmartFleeEntity::CreateTask();
      return (CTask *)v124;
    case 917:
      CTaskComplexAvoidOtherPedWhileWandering::CreateTask();
      return (CTask *)v125;
    case 918:
      CTaskComplexGoToPointAnyMeans::CreateTask();
      return (CTask *)v126;
    case 920:
      CTaskComplexTurnToFaceEntityOrCoord::CreateTask();
      return (CTask *)v127;
    case 924:
      CTaskComplexGoToPointAiming::CreateTask();
      return (CTask *)v128;
    case 927:
      CTaskComplexFleeAnyMeans::CreateTask();
      return (CTask *)v129;
    case 931:
      CTaskComplexFollowPatrolRoute::CreateTask();
      return (CTask *)v130;
    case 933:
      CTaskComplexSeekEntityAiming::CreateTask();
      return (CTask *)v59;
    case 1000:
      CTaskComplexKillPedOnFoot::CreateTask();
      return (CTask *)v60;
    case 1003:
      CTaskComplexDestroyCar::CreateTask();
      return (CTask *)v61;
    case 1017:
      CTaskSimpleUseGun::CreateTask();
      return (CTask *)v131;
    case 1020:
      CTaskSimpleGunControl::CreateTask();
      return (CTask *)v62;
    case 1022:
      CTaskSimpleGangDriveBy::CreateTask();
      return (CTask *)v63;
    case 1204:
      return CTaskComplexPartnerChat::CreateTask();
    case 1219:
      v64 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v64;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 1);
      Task = (CTask *)CTask::operator new(0x14u);
      CTaskComplexGangJoinRespond::CTaskComplexGangJoinRespond((CTaskComplexGangJoinRespond *)Task, LOBYTE(pData.x));
      return Task;
    case 1301:
      return CTaskSimpleTogglePedThreatScanner::CreateTask();
    case 1303:
      CTaskSimpleJetPack::CreateTask();
      return (CTask *)v65;
    case 1304:
      CTaskSimpleSwim::CreateTask();
      return (CTask *)v132;
    case 1306:
      v133 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v133;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      Task = (CTask *)CTask::operator new(0xCu);
      CTaskSimpleDuckToggle::CTaskSimpleDuckToggle((CTaskSimpleDuckToggle *)Task, SLODWORD(pData.x));
      return Task;
    case 1307:
      v66 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v66;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      if ( LODWORD(pData.x) == -1 )
        v67 = 0;
      else
        v67 = CPools::GetPed(SLODWORD(pData.x));
      Task = (CTask *)CTask::operator new(0x24u);
      CTaskSimpleWaitUntilAreaCodesMatch::CTaskSimpleWaitUntilAreaCodesMatch(
        (CTaskSimpleWaitUntilAreaCodesMatch *)Task,
        v67);
      return Task;
    case 1308:
      Task = (CTask *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)Task, 0, 1, 0, 8.0);
      v3 = &`vtable for'CTaskSimpleOnEscalator;
      goto LABEL_208;
    case 1309:
      v68 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v68;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      if ( LODWORD(pData.x) == -1 )
        v69 = 0;
      else
        v69 = CPools::GetPed(SLODWORD(pData.x));
      Task = (CTask *)CTask::operator new(0x30u);
      CTaskComplexProstituteSolicit::CTaskComplexProstituteSolicit((CTaskComplexProstituteSolicit *)Task, v69);
      return Task;
    case 1600:
      v70 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v70;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      Task = (CTask *)CTask::operator new(0x20u);
      CTaskComplexUseMobilePhone::CTaskComplexUseMobilePhone((CTaskComplexUseMobilePhone *)Task, SLODWORD(pData.x));
      return Task;
    case 1604:
      Task = (CTask *)CTask::operator new(0xCu);
      CTaskComplexUseGoggles::CTaskComplexUseGoggles((CTaskComplexUseGoggles *)Task);
      return Task;
    default:
      if ( v136 == 1800 )
      {
        v134 = UseDataFence;
        if ( UseDataFence )
        {
          UseDataFence = 0;
          CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
          UseDataFence = v134;
        }
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 8);
        Task = (CTask *)CTask::operator new(0x1Cu);
        CTaskComplexUseScriptedBrain::CTaskComplexUseScriptedBrain(
          (CTaskComplexUseScriptedBrain *)Task,
          (const unsigned __int8 *)&pData);
      }
      else if ( v136 == 1801 )
      {
        Task = (CTask *)CTask::operator new(8u);
        CTaskSimple::CTaskSimple((CTaskSimple *)Task);
        v3 = &`vtable for'CTaskSimpleFinishBrain;
LABEL_208:
        v24 = (char *)*v3;
LABEL_209:
        Task->_vptr$CTask = (int (**)(void))(v24 + 8);
      }
      return Task;
  }
}
// 4863A4: variable 'v2' is possibly undefined
// 4863D6: variable 'v4' is possibly undefined
// 48649C: variable 'v10' is possibly undefined
// 4864A6: variable 'v11' is possibly undefined
// 4864FC: variable 'v13' is possibly undefined
// 486552: variable 'v15' is possibly undefined
// 48655C: variable 'v16' is possibly undefined
// 4865A4: variable 'v18' is possibly undefined
// 48664A: variable 'v20' is possibly undefined
// 486654: variable 'v21' is possibly undefined
// 48665E: variable 'v22' is possibly undefined
// 486668: variable 'v23' is possibly undefined
// 4866BA: variable 'v25' is possibly undefined
// 48679E: variable 'v28' is possibly undefined
// 4867B8: variable 'v29' is possibly undefined
// 486924: variable 'v31' is possibly undefined
// 48692E: variable 'v32' is possibly undefined
// 486948: variable 'v33' is possibly undefined
// 486952: variable 'v34' is possibly undefined
// 48695C: variable 'v35' is possibly undefined
// 486966: variable 'v36' is possibly undefined
// 486970: variable 'v37' is possibly undefined
// 48698A: variable 'v38' is possibly undefined
// 486994: variable 'v39' is possibly undefined
// 4869EA: variable 'v42' is possibly undefined
// 486A30: variable 'v45' is possibly undefined
// 486A44: variable 'v46' is possibly undefined
// 486A4E: variable 'v47' is possibly undefined
// 486A58: variable 'v48' is possibly undefined
// 486AB8: variable 'v51' is possibly undefined
// 486AC2: variable 'v52' is possibly undefined
// 486ACC: variable 'v53' is possibly undefined
// 486AD6: variable 'v54' is possibly undefined
// 486AEA: variable 'v55' is possibly undefined
// 486AFA: variable 'v56' is possibly undefined
// 486B02: variable 'v57' is possibly undefined
// 486B58: variable 'v59' is possibly undefined
// 486B60: variable 'v60' is possibly undefined
// 486B68: variable 'v61' is possibly undefined
// 486B70: variable 'v62' is possibly undefined
// 486B78: variable 'v63' is possibly undefined
// 486BBC: variable 'v65' is possibly undefined
// 486CA6: variable 'v71' is possibly undefined
// 486DAA: variable 'v76' is possibly undefined
// 486DB2: variable 'v77' is possibly undefined
// 486DC8: variable 'v78' is possibly undefined
// 486E8A: variable 'v81' is possibly undefined
// 486EE8: variable 'v84' is possibly undefined
// 4870F2: variable 'v87' is possibly undefined
// 487260: variable 'v92' is possibly undefined
// 487268: variable 'v93' is possibly undefined
// 487270: variable 'v94' is possibly undefined
// 487278: variable 'v95' is possibly undefined
// 487338: variable 'v100' is possibly undefined
// 48737A: variable 'v103' is possibly undefined
// 487382: variable 'v104' is possibly undefined
// 48738A: variable 'v105' is possibly undefined
// 4873CC: variable 'v108' is possibly undefined
// 48740E: variable 'v111' is possibly undefined
// 48748A: variable 'v116' is possibly undefined
// 4874C8: variable 'v119' is possibly undefined
// 4874D0: variable 'v120' is possibly undefined
// 4874D8: variable 'v121' is possibly undefined
// 4874E0: variable 'v122' is possibly undefined
// 4874E8: variable 'v123' is possibly undefined
// 4874F0: variable 'v124' is possibly undefined
// 4874F8: variable 'v125' is possibly undefined
// 487500: variable 'v126' is possibly undefined
// 487508: variable 'v127' is possibly undefined
// 487510: variable 'v128' is possibly undefined
// 487518: variable 'v129' is possibly undefined
// 487520: variable 'v130' is possibly undefined
// 487528: variable 'v131' is possibly undefined
// 487540: variable 'v132' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 675F04: using guessed type void *`vtable for'CTaskComplexDiveFromAttachedEntityAndGetUp;
// 676378: using guessed type void *`vtable for'CTaskSimpleCower;
// 6764A4: using guessed type void *`vtable for'CTaskSimpleHailTaxiAndPause;
// 67678C: using guessed type void *`vtable for'CTaskSimpleSetCharDecisionMaker;
// 676894: using guessed type void *`vtable for'CTaskSimpleHitByGunFromFront;
// 676A48: using guessed type void *`vtable for'CTaskSimpleHitByGunFromRear;
// 676AF8: using guessed type void *`vtable for'CTaskSimpleHitByGunFromLeft;
// 676C0C: using guessed type void *`vtable for'CTaskComplexUseClosestFreeScriptedAttractorSprint;
// 676D34: using guessed type void *`vtable for'CTaskSimpleHandsUp;
// 676E04: using guessed type void *`vtable for'CTaskSimpleHailTaxi;
// 676E7C: using guessed type void *`vtable for'CTaskSimpleFinishBrain;
// 677568: using guessed type void *`vtable for'CTaskSimpleLookAbout;
// 6777B8: using guessed type void *`vtable for'CTaskSimpleOnEscalator;
// 6778C4: using guessed type void *`vtable for'CTaskSimpleHitFromLeft;
// 677EFC: using guessed type void *`vtable for'CTaskSimpleDetonate;
// 677F24: using guessed type void *`vtable for'CTaskSimpleHitFromBack;
// 6784D8: using guessed type void *`vtable for'CTaskSimpleScratchHead;
// 678748: using guessed type void *`vtable for'CTaskSimpleHitFromRight;
// 678A48: using guessed type void *`vtable for'CTaskComplexUseClosestFreeScriptedAttractorRun;
// 678CDC: using guessed type void *`vtable for'CTaskSimpleHitFromFront;
// 678D1C: using guessed type void *`vtable for'CTaskSimpleChat;
// 678E00: using guessed type void *`vtable for'CTaskSimplePause;
// 6796E4: using guessed type void *`vtable for'CTaskSimpleHitWall;
// 67998C: using guessed type void *`vtable for'CTaskSimpleHitByGunFromRight;
// 679A44: using guessed type void *`vtable for'CTaskComplexBeStill;
// 679BB0: using guessed type void *`vtable for'CTaskSimpleUseAtm;
// 679D48: using guessed type void *`vtable for'CTaskSimpleHitFromBehind;
// 679D78: using guessed type void *`vtable for'CTaskSimpleAbseil;

//----- (004878A0) --------------------------------------------------------
bool __fastcall CVehicle::Save(CVehicle *this)
{
  float m_fBrakePedal; // r1
  int v3; // r1
  _DWORD *v4; // r5
  void *v5; // r5
  _BYTE v7[128]; // [sp+0h] [bp-88h] BYREF

  *(_DWORD *)&v7[64] = 0;
  *(_DWORD *)&v7[68] = 0;
  CMatrix::operator=((CMatrix *)v7, this->m_pMat);
  v7[73] = this->m_colour1;
  v7[74] = this->m_colour2;
  v7[75] = this->m_colour3;
  v7[76] = this->m_colour4;
  *(_WORD *)&v7[78] = this->CarAlarmState;
  v7[80] = this->m_nMaxPassengers;
  *(float *)&v7[84] = this->m_fSteerAngle;
  m_fBrakePedal = this->m_fBrakePedal;
  *(float *)&v7[88] = this->m_fGasPedal;
  *(float *)&v7[92] = m_fBrakePedal;
  v3 = *((_DWORD *)&this->m_nVehicleFlags + 1);
  *(_DWORD *)&v7[96] = this->m_nVehicleFlags;
  *(_DWORD *)&v7[100] = v3;
  v7[72] = this->VehicleCreatedBy;
  *(float *)&v7[104] = this->m_nHealth;
  *(_DWORD *)&v7[108] = this->m_eDoorLockState;
  *(CPhysical::CPhysicalFlags *)&v7[112] = this->m_nPhysicalFlags;
  *(_QWORD *)&v7[116] = *(_QWORD *)&this->m_fMass;
  *(float *)&v7[124] = this->m_fBuoyancyConstant;
  v4 = malloc(4u);
  *v4 = 128;
  CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
  free(v4);
  v5 = malloc(0x80u);
  qmemcpy(v5, v7, 0x80u);
  CGenericGameStorage::_SaveDataToWorkBuffer(v5, 128);
  free(v5);
  CMatrix::~CMatrix((CMatrix *)v7);
  return 1;
}

//----- (00487970) --------------------------------------------------------
bool __fastcall CVehicle::Load(CVehicle *this)
{
  float v2; // r1
  int v3; // r0
  CMatrix v5; // [sp+0h] [bp-90h] BYREF
  unsigned __int8 NewVehicleCreatedBy; // [sp+48h] [bp-48h]
  __int16 NewVehicleCreatedBy_1; // [sp+49h] [bp-47h]
  uint8 NewVehicleCreatedBy_3; // [sp+4Bh] [bp-45h]
  uint8 v9; // [sp+4Ch] [bp-44h]
  UInt16 v10; // [sp+4Eh] [bp-42h]
  uint8 v11; // [sp+50h] [bp-40h]
  float v12; // [sp+54h] [bp-3Ch]
  float v13; // [sp+58h] [bp-38h]
  float v14; // [sp+5Ch] [bp-34h]
  int v15; // [sp+60h] [bp-30h]
  int v16; // [sp+64h] [bp-2Ch]
  float v17; // [sp+68h] [bp-28h]
  eCarLockState v18; // [sp+6Ch] [bp-24h]
  CPhysical::CPhysicalFlags v19; // [sp+70h] [bp-20h]
  __int64 v20; // [sp+74h] [bp-1Ch]
  float v21; // [sp+7Ch] [bp-14h]
  char pData[12]; // [sp+84h] [bp-Ch] BYREF

  v5.m_pRwMat = 0;
  v5.m_owner = 0;
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v5, 128);
  CPlaceable::SetMatrix(this, &v5);
  *(_WORD *)&this->m_colour1 = NewVehicleCreatedBy_1;
  this->m_colour3 = NewVehicleCreatedBy_3;
  this->m_colour4 = v9;
  this->CarAlarmState = v10;
  this->m_nMaxPassengers = v11;
  this->m_fSteerAngle = v12;
  v2 = v14;
  this->m_fGasPedal = v13;
  this->m_fBrakePedal = v2;
  v3 = v15;
  *((_DWORD *)&this->m_nVehicleFlags + 1) = v16;
  *(_DWORD *)&this->m_nVehicleFlags = v3;
  CVehicle::SetVehicleCreatedBy(this, NewVehicleCreatedBy, 1);
  this->m_nHealth = v17;
  this->m_eDoorLockState = v18;
  this->m_nPhysicalFlags = v19;
  *(_QWORD *)&this->m_fMass = v20;
  this->m_fBuoyancyConstant = v21;
  CMatrix::~CMatrix(&v5);
  return 1;
}
// 487970: using guessed type char pData[12];

//----- (00487A1C) --------------------------------------------------------
bool __fastcall CAutomobile::Save(CAutomobile *this)
{
  _QWORD *v2; // r5
  __int64 v3; // d17
  __int64 v4; // d18

  CVehicle::Save(this);
  v2 = malloc(0x18u);
  v3 = *(_QWORD *)&this->Damage.m_Wheel[3];
  v4 = *(_QWORD *)&this->Damage.m_Lights;
  *v2 = *(_QWORD *)&this->Damage.fWheelDamageEffect;
  v2[1] = v3;
  v2[2] = v4;
  CGenericGameStorage::_SaveDataToWorkBuffer(v2, 24);
  free(v2);
  return 1;
}

//----- (00487A62) --------------------------------------------------------
bool __fastcall CAutomobile::Load(CAutomobile *this)
{
  CVehicle::Load(this);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&this->Damage, 24);
  return 1;
}

//----- (00487A7C) --------------------------------------------------------
int CStreaming::Save()
{
  int v0; // r6
  uint8 *p_m_status; // r5
  int v2; // r0
  char pData[17]; // [sp+7h] [bp-11h] BYREF

  v0 = 26316;
  p_m_status = &CStreaming::ms_aInfoForModel[0].m_status;
  do
  {
    v2 = *p_m_status;
    pData[0] = -1;
    if ( v2 == 1 )
      pData[0] = *(p_m_status - 10);
    CGenericGameStorage::_SaveDataToWorkBuffer(pData, 1);
    p_m_status += 20;
    --v0;
  }
  while ( v0 );
  return 1;
}
// 487A7C: using guessed type char pData[17];

//----- (00487ACC) --------------------------------------------------------
int CStreaming::Load()
{
  int v0; // r6
  uint8 *p_m_status; // r5
  char pData[17]; // [sp+7h] [bp-11h] BYREF

  v0 = 26316;
  p_m_status = &CStreaming::ms_aInfoForModel[0].m_status;
  do
  {
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 1);
    if ( *p_m_status == 1 && (unsigned __int8)pData[0] != 255 )
      *(p_m_status - 10) |= pData[0];
    p_m_status += 20;
    --v0;
  }
  while ( v0 );
  return 1;
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];
// 487ACC: using guessed type char pData[17];

//----- (00487B1C) --------------------------------------------------------
int CPools::SaveVehiclePool()
{
  CVehiclePool *v0; // r0
  int32 m_nSize; // r9
  int v2; // r4
  int v3; // r6
  const CPed *v4; // r0
  int v5; // r2
  _BOOL4 v6; // r0
  int v7; // r11
  const CPed *v8; // r0
  _BOOL4 IsPlayer; // r0
  int v10; // r2
  int v11; // r1
  _DWORD *v12; // r4
  int v13; // r5
  CVehiclePool **v14; // r8
  int v15; // r10
  const CPed *v16; // r0
  _BOOL4 v17; // r0
  int v18; // r2
  int v19; // r1
  const CPed *v20; // r0
  int v21; // r2
  _BOOL4 v22; // r0
  CVehiclePool **v23; // r9
  CPed **v24; // r11
  int32 VehicleRef; // r6
  int v26; // r8
  _DWORD *v27; // r4
  _DWORD *v28; // r4
  __int16 v29; // r6
  _WORD *v30; // r4
  int32 PedRef; // r6
  _DWORD *v32; // r4
  CPed *v33; // r0
  int32 v34; // r6
  _DWORD *v35; // r4
  CPed *v36; // r0
  int32 v37; // r6
  _DWORD *v38; // r4
  CPed *v39; // r0
  int32 v40; // r6
  _DWORD *v41; // r4
  CPed *v42; // r0
  int32 v43; // r6
  _DWORD *v44; // r4
  CPed *v45; // r0
  int32 v46; // r6
  _DWORD *v47; // r4
  CPed *v48; // r0
  int32 v49; // r6
  _DWORD *v50; // r4
  CPed *v51; // r0
  int32 v52; // r6
  _DWORD *v53; // r4
  CPed *v54; // r0
  int32 v55; // r6
  _DWORD *v56; // r4
  _DWORD *v57; // r4
  int32 v58; // r8
  bool v59; // r6
  __int16 v60; // r2
  __int16 v61; // r4
  _WORD *v62; // r5
  _DWORD *v63; // r5
  int v64; // r8
  bool v65; // r6
  __int16 v66; // r2
  __int16 v67; // r5
  _WORD *v68; // r4
  _DWORD *v69; // r4
  int v70; // r1
  int32 v71; // r8
  bool v72; // r6
  __int16 v73; // r2
  __int16 v74; // r4
  _WORD *v75; // r5
  _DWORD *v76; // r5
  CVehicle *m_pMyVehicle; // r0
  CVehicle *m_pVehicleBeingTowed; // r0
  int32 v79; // r8
  bool v80; // r5
  __int16 v81; // r2
  __int16 v82; // r6
  _WORD *v83; // r4
  _DWORD *v84; // r4
  void *v85; // r0
  bool v86; // r6
  __int16 v87; // r2
  __int16 v88; // r4
  _WORD *v89; // r5
  _DWORD *v90; // r5
  int32 v92; // [sp+14h] [bp-24h]

  v0 = CPools::ms_pVehiclePool;
  m_nSize = CPools::ms_pVehiclePool->m_nSize;
  if ( m_nSize )
  {
    v2 = 0;
    v3 = 0;
    while ( 1 )
    {
      if ( (v0->m_aFlags[v2] & 0x80u) == 0 )
      {
        v7 = (int)v0->m_aStorage[v2];
        if ( v7 )
        {
          if ( *(_BYTE *)(v7 + 1192) != 2 )
          {
            v8 = *(const CPed **)(v7 + 1124);
            if ( v8 )
            {
              IsPlayer = CPed::IsPlayer(v8);
              if ( !IsMissionSave && !IsPlayer )
                goto LABEL_12;
            }
            else if ( !IsMissionSave )
            {
              goto LABEL_12;
            }
          }
          v10 = 0;
          v11 = 0;
          do
          {
            v11 |= *(_DWORD *)(v7 + 1128 + 4 * v10) != 0;
            if ( v10 > 6 )
              break;
            ++v10;
          }
          while ( !(v11 << 31) );
          v4 = *(const CPed **)(v7 + 1124);
          v5 = (int)v4;
          if ( v4 )
            v5 = 1;
          if ( !((v11 | v5) << 31) )
          {
LABEL_8:
            ++v3;
            goto LABEL_12;
          }
          if ( v4 )
          {
            v6 = CPed::IsPlayer(v4);
            if ( IsMissionSave )
              goto LABEL_8;
          }
          else
          {
            v6 = IsMissionSave;
          }
          if ( v6 )
            ++v3;
        }
      }
LABEL_12:
      if ( ++v2 == m_nSize )
      {
        v12 = malloc(4u);
        *v12 = v3;
        CGenericGameStorage::_SaveDataToWorkBuffer(v12, 4);
        free(v12);
        v13 = 0;
        v14 = &CPools::ms_pVehiclePool;
        v92 = m_nSize;
        while ( 1 )
        {
          if ( ((*v14)->m_aFlags[v13] & 0x80u) != 0 )
            goto LABEL_78;
          v15 = (int)(*v14)->m_aStorage[v13];
          if ( !v15 )
            goto LABEL_78;
          if ( *(_BYTE *)(v15 + 1192) != 2 )
          {
            v16 = *(const CPed **)(v15 + 1124);
            if ( v16 )
            {
              v17 = CPed::IsPlayer(v16);
              if ( !IsMissionSave && !v17 )
                goto LABEL_78;
            }
            else if ( !IsMissionSave )
            {
              goto LABEL_78;
            }
          }
          v18 = 0;
          v19 = 0;
          do
          {
            v19 |= *(_DWORD *)(v15 + 1128 + 4 * v18) != 0;
            if ( v18 > 6 )
              break;
            ++v18;
          }
          while ( !(v19 << 31) );
          v20 = *(const CPed **)(v15 + 1124);
          v21 = (int)v20;
          if ( v20 )
            v21 = 1;
          if ( !((v19 | v21) << 31) )
          {
LABEL_47:
            v23 = v14;
            v24 = (CPed **)(v15 + 1124);
            VehicleRef = CPools::GetVehicleRef((CVehicle *)v15);
            v26 = *(__int16 *)(v15 + 38);
            v27 = malloc(4u);
            *v27 = VehicleRef;
            CGenericGameStorage::_SaveDataToWorkBuffer(v27, 4);
            free(v27);
            v28 = malloc(4u);
            *v28 = v26;
            CGenericGameStorage::_SaveDataToWorkBuffer(v28, 4);
            free(v28);
            (*(void (__fastcall **)(int))(*(_DWORD *)v15 + 260))(v15);
            if ( *(_DWORD *)(v15 + 1444) == 6 )
            {
              v29 = *(_WORD *)(v15 + 1484);
              v30 = malloc(2u);
              *v30 = v29;
              CGenericGameStorage::_SaveDataToWorkBuffer(v30, 2);
              free(v30);
              if ( *(_BYTE *)(v15 + 1192) == 2 )
                CGenericGameStorage::_SaveDataToWorkBuffer(&CTrain::bDisableRandomTrains, 1);
            }
            if ( *v24 )
              PedRef = CPools::GetPedRef(*v24);
            else
              PedRef = -1;
            v14 = v23;
            m_nSize = v92;
            v32 = malloc(4u);
            *v32 = PedRef;
            CGenericGameStorage::_SaveDataToWorkBuffer(v32, 4);
            free(v32);
            v33 = *(CPed **)(v15 + 1128);
            if ( v33 )
              v34 = CPools::GetPedRef(v33);
            else
              v34 = -1;
            v35 = malloc(4u);
            *v35 = v34;
            CGenericGameStorage::_SaveDataToWorkBuffer(v35, 4);
            free(v35);
            v36 = *(CPed **)(v15 + 1132);
            if ( v36 )
              v37 = CPools::GetPedRef(v36);
            else
              v37 = -1;
            v38 = malloc(4u);
            *v38 = v37;
            CGenericGameStorage::_SaveDataToWorkBuffer(v38, 4);
            free(v38);
            v39 = *(CPed **)(v15 + 1136);
            if ( v39 )
              v40 = CPools::GetPedRef(v39);
            else
              v40 = -1;
            v41 = malloc(4u);
            *v41 = v40;
            CGenericGameStorage::_SaveDataToWorkBuffer(v41, 4);
            free(v41);
            v42 = *(CPed **)(v15 + 1140);
            if ( v42 )
              v43 = CPools::GetPedRef(v42);
            else
              v43 = -1;
            v44 = malloc(4u);
            *v44 = v43;
            CGenericGameStorage::_SaveDataToWorkBuffer(v44, 4);
            free(v44);
            v45 = *(CPed **)(v15 + 1144);
            if ( v45 )
              v46 = CPools::GetPedRef(v45);
            else
              v46 = -1;
            v47 = malloc(4u);
            *v47 = v46;
            CGenericGameStorage::_SaveDataToWorkBuffer(v47, 4);
            free(v47);
            v48 = *(CPed **)(v15 + 1148);
            if ( v48 )
              v49 = CPools::GetPedRef(v48);
            else
              v49 = -1;
            v50 = malloc(4u);
            *v50 = v49;
            CGenericGameStorage::_SaveDataToWorkBuffer(v50, 4);
            free(v50);
            v51 = *(CPed **)(v15 + 1152);
            if ( v51 )
              v52 = CPools::GetPedRef(v51);
            else
              v52 = -1;
            v53 = malloc(4u);
            *v53 = v52;
            CGenericGameStorage::_SaveDataToWorkBuffer(v53, 4);
            free(v53);
            v54 = *(CPed **)(v15 + 1156);
            if ( v54 )
              v55 = CPools::GetPedRef(v54);
            else
              v55 = -1;
            v56 = malloc(4u);
            *v56 = v55;
            CGenericGameStorage::_SaveDataToWorkBuffer(v56, 4);
            free(v56);
            goto LABEL_78;
          }
          if ( v20 )
          {
            v22 = CPed::IsPlayer(v20);
            if ( IsMissionSave || v22 )
              goto LABEL_47;
          }
          else if ( IsMissionSave )
          {
            goto LABEL_47;
          }
LABEL_78:
          if ( ++v13 == m_nSize )
            goto LABEL_81;
        }
      }
      v0 = CPools::ms_pVehiclePool;
    }
  }
  v57 = malloc(4u);
  *v57 = 0;
  CGenericGameStorage::_SaveDataToWorkBuffer(v57, 4);
  free(v57);
LABEL_81:
  if ( CWorld::Players[0].pRemoteVehicle )
    v58 = CPools::GetVehicleRef(CWorld::Players[0].pRemoteVehicle);
  else
    v58 = -1;
  v59 = UseDataFence;
  if ( UseDataFence )
  {
    v60 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v61 = v60 + DataFence;
    v62 = malloc(2u);
    *v62 = v61;
    CGenericGameStorage::_SaveDataToWorkBuffer(v62, 2);
    free(v62);
    UseDataFence = v59;
  }
  v63 = malloc(4u);
  *v63 = v58;
  CGenericGameStorage::_SaveDataToWorkBuffer(v63, 4);
  free(v63);
  if ( TheCamera.pTargetEntity )
  {
    v64 = *(_BYTE *)&TheCamera.pTargetEntity->m_info & 7;
    v65 = UseDataFence;
    if ( UseDataFence )
    {
      v66 = currentSaveFenceCount;
      UseDataFence = 0;
      ++currentSaveFenceCount;
      v67 = v66 + DataFence;
      v68 = malloc(2u);
      *v68 = v67;
      CGenericGameStorage::_SaveDataToWorkBuffer(v68, 2);
      free(v68);
      UseDataFence = v65;
    }
    v69 = malloc(4u);
    *v69 = v64;
    CGenericGameStorage::_SaveDataToWorkBuffer(v69, 4);
    free(v69);
    v70 = *(_BYTE *)&TheCamera.pTargetEntity->m_info & 7;
    if ( v70 == 2 )
    {
      if ( TheCamera.pTargetEntity )
        v71 = CPools::GetVehicleRef((CVehicle *)TheCamera.pTargetEntity);
      else
        v71 = -1;
      v72 = UseDataFence;
      if ( !UseDataFence )
        goto LABEL_101;
    }
    else
    {
      if ( v70 != 3 )
        goto LABEL_102;
      if ( TheCamera.pTargetEntity )
        v71 = CPools::GetPedRef((CPed *)TheCamera.pTargetEntity);
      else
        v71 = -1;
      v72 = UseDataFence;
      if ( !UseDataFence )
        goto LABEL_101;
    }
    v73 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v74 = v73 + DataFence;
    v75 = malloc(2u);
    *v75 = v74;
    CGenericGameStorage::_SaveDataToWorkBuffer(v75, 2);
    free(v75);
    UseDataFence = v72;
LABEL_101:
    v76 = malloc(4u);
    *v76 = v71;
    CGenericGameStorage::_SaveDataToWorkBuffer(v76, 4);
    free(v76);
  }
LABEL_102:
  m_pMyVehicle = CWorld::Players[0].pPed->m_pMyVehicle;
  if ( m_pMyVehicle )
  {
    m_pVehicleBeingTowed = m_pMyVehicle->m_pVehicleBeingTowed;
    if ( m_pVehicleBeingTowed )
      v79 = CPools::GetVehicleRef(m_pVehicleBeingTowed);
    else
      v79 = -1;
    v86 = UseDataFence;
    if ( UseDataFence )
    {
      v87 = currentSaveFenceCount;
      UseDataFence = 0;
      ++currentSaveFenceCount;
      v88 = v87 + DataFence;
      v89 = malloc(2u);
      *v89 = v88;
      CGenericGameStorage::_SaveDataToWorkBuffer(v89, 2);
      free(v89);
      UseDataFence = v86;
    }
    v90 = malloc(4u);
    *v90 = v79;
    CGenericGameStorage::_SaveDataToWorkBuffer(v90, 4);
    v85 = v90;
  }
  else
  {
    v80 = UseDataFence;
    if ( UseDataFence )
    {
      v81 = currentSaveFenceCount;
      UseDataFence = 0;
      ++currentSaveFenceCount;
      v82 = v81 + DataFence;
      v83 = malloc(2u);
      *v83 = v82;
      CGenericGameStorage::_SaveDataToWorkBuffer(v83, 2);
      free(v83);
      UseDataFence = v80;
    }
    v84 = malloc(4u);
    *v84 = -1;
    CGenericGameStorage::_SaveDataToWorkBuffer(v84, 4);
    v85 = v84;
  }
  free(v85);
  return 1;
}
// 487C20: conditional instruction was optimized away because r9.4!=0

//----- (00488244) --------------------------------------------------------
int CPools::LoadVehiclePool()
{
  int v0; // r6
  CPlayerPed *pPed; // r0
  unsigned int m_nPedFlags; // r8
  int (**v3)(void); // r1
  RwReal v4; // r2
  RwReal v5; // r3
  int v6; // r9
  CMonsterTruck *v7; // r4
  CPlayerPed *v8; // r0
  int v9; // r2
  int v10; // r3
  int v11; // r5
  CPed *Ped; // r0
  CPed *v13; // r5
  CTaskSimpleCarSetPedInAsDriver *v14; // r0
  int i; // r8
  CPed *v16; // r0
  CPed *v17; // r9
  int v18; // r5
  CTaskSimpleCarSetPedInAsPassenger *v19; // r0
  int *v20; // r0
  int v21; // r1
  bool v22; // r4
  CVehicle *Vehicle; // r0
  CVehicle *PlayerVehicle; // r0
  bool v25; // r4
  bool v26; // r4
  CEntity *v27; // r0
  bool v28; // r4
  bool v29; // r4
  CVehicle *v30; // r0
  CEntity::CEntityInfo m_info; // r2
  int32 v33; // [sp+1Ch] [bp-4Ch] BYREF
  CTaskSimpleCarSetPedInAsDriver v34; // [sp+20h] [bp-48h] BYREF
  int32 nRef; // [sp+3Ch] [bp-2Ch] BYREF
  int32 index; // [sp+40h] [bp-28h] BYREF
  int32 v37; // [sp+44h] [bp-24h] BYREF
  int pData[8]; // [sp+48h] [bp-20h] BYREF

  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  if ( pData[0] >= 1 )
  {
    v0 = 0;
    do
    {
      CGenericGameStorage::_LoadDataFromWorkBuffer(&v37, 4);
      CGenericGameStorage::_LoadDataFromWorkBuffer(&index, 4);
      CStreaming::RequestModel(index, 8);
      CStreaming::LoadAllRequestedModels(0);
      pPed = CWorld::Players[0].pPed;
      m_nPedFlags = (unsigned int)CWorld::Players[0].pPed->m_nPedFlags;
      v3 = (int (**)(void))*((_DWORD *)&CWorld::Players[0].pPed->m_nPedFlags + 1);
      v4 = *((float *)&CWorld::Players[0].pPed->m_nPedFlags + 2);
      v5 = *((float *)&CWorld::Players[0].pPed->m_nPedFlags + 3);
      *(_DWORD *)&CWorld::Players[0].pPed->m_nPedFlags = m_nPedFlags & 0xFFFFFEFF;
      pPed = (CPlayerPed *)((char *)pPed + 1160);
      pPed->_vptr$CPlaceable = v3;
      pPed->m_transform.m_translate.x = v4;
      pPed->m_transform.m_translate.y = v5;
      switch ( *(_DWORD *)&CModelInfo::ms_modelInfoPtrs[index][1].m_modelName[20] )
      {
        case 1:
          v6 = v0;
          v7 = (CMonsterTruck *)CVehicle::operator new(0x9B0u, v37);
          CMonsterTruck::CMonsterTruck(v7, index, 1u);
          break;
        case 2:
          v6 = v0;
          v7 = (CMonsterTruck *)CVehicle::operator new(0x9D0u, v37);
          CQuadBike::CQuadBike((CQuadBike *)v7, index, 1u);
          break;
        case 3:
          v6 = v0;
          v7 = (CMonsterTruck *)CVehicle::operator new(0xA2Cu, v37);
          CHeli::CHeli((CHeli *)v7, index, 1u);
          break;
        case 4:
          v6 = v0;
          v7 = (CMonsterTruck *)CVehicle::operator new(0xA18u, v37);
          CPlane::CPlane((CPlane *)v7, index, 1u);
          break;
        case 5:
          v6 = v0;
          v7 = (CMonsterTruck *)CVehicle::operator new(0x7FCu, v37);
          CBoat::CBoat((CBoat *)v7, index, 1u);
          break;
        case 6:
          v6 = v0;
          v7 = (CMonsterTruck *)CVehicle::operator new(0x6C0u, v37);
          CTrain::CTrain((CTrain *)v7, index, 1u);
          break;
        case 9:
          v6 = v0;
          v7 = (CMonsterTruck *)CVehicle::operator new(0x828u, v37);
          CBike::CBike((CBike *)v7, index, 1u);
          goto LABEL_13;
        case 0xA:
          v6 = v0;
          v7 = (CMonsterTruck *)CVehicle::operator new(0x84Cu, v37);
          CBmx::CBmx((CBmx *)v7, index, 1u);
LABEL_13:
          LOBYTE(v7->Door[3].m_fAngVel) |= 0x10u;
          break;
        case 0xB:
          v6 = v0;
          v7 = (CMonsterTruck *)CVehicle::operator new(0xA08u, v37);
          CTrailer::CTrailer((CTrailer *)v7, index, 1u);
          break;
        default:
          v6 = v0;
          v7 = (CMonsterTruck *)CVehicle::operator new(0x99Cu, v37);
          CAutomobile::CAutomobile(v7, index, 1u, 1u);
          break;
      }
      v8 = CWorld::Players[0].pPed;
      v9 = *((_DWORD *)&CWorld::Players[0].pPed->m_nPedFlags + 1);
      v10 = *((_DWORD *)&CWorld::Players[0].pPed->m_nPedFlags + 2);
      v11 = *((_DWORD *)&CWorld::Players[0].pPed->m_nPedFlags + 3);
      *(_DWORD *)&CWorld::Players[0].pPed->m_nPedFlags = *(_DWORD *)&CWorld::Players[0].pPed->m_nPedFlags & 0xFFFFFEFF | (((m_nPedFlags >> 8) & 1) << 8);
      *((_DWORD *)&v8->m_nPedFlags + 1) = v9;
      *((_DWORD *)&v8->m_nPedFlags + 2) = v10;
      *((_DWORD *)&v8->m_nPedFlags + 3) = v11;
      (*((void (__fastcall **)(CMonsterTruck *))v7->_vptr$CPlaceable + 66))(v7);
      if ( v7->m_vehicleType == 6 )
      {
        CGenericGameStorage::_LoadDataFromWorkBuffer(v7->Door, 2);
        if ( v7->VehicleCreatedBy == 2 )
          CGenericGameStorage::_LoadDataFromWorkBuffer(&CTrain::bDisableRandomTrains, 1);
      }
      --CCarCtrl::NumRandomCars;
      CCarCtrl::UpdateCarCount(v7, 0);
      CWorld::Add(v7);
      nRef = -1;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      v0 = v6 + 1;
      if ( nRef != -1 )
      {
        Ped = CPools::GetPed(nRef);
        v13 = Ped;
        if ( Ped )
        {
          CPedIntelligence::FlushImmediately(Ped->m_pPedIntelligence, 0);
          CTaskSimpleCarSetPedInAsDriver::CTaskSimpleCarSetPedInAsDriver(&v34, v7, 0);
          v34.m_bWarpingInToCar = 1;
          CTaskSimpleCarSetPedInAsDriver::ProcessPed(v14, v13);
          CTaskSimpleCarSetPedInAsDriver::~CTaskSimpleCarSetPedInAsDriver(&v34);
        }
      }
      for ( i = 0; i != 8; ++i )
      {
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
        if ( nRef != -1 )
        {
          v16 = CPools::GetPed(nRef);
          v17 = v16;
          if ( v16 )
          {
            *(_DWORD *)&v16->m_nPedFlags &= ~0x100u;
            v18 = CCarEnterExit::ComputeTargetDoorToEnterAsPassenger(v7, i);
            v19 = (CTaskSimpleCarSetPedInAsPassenger *)CTask::operator new(0x20u);
            CTaskSimpleCarSetPedInAsPassenger::CTaskSimpleCarSetPedInAsPassenger(v19, v7, v18, 0);
            v21 = *v20;
            *((_BYTE *)v20 + 28) = 1;
            (*(void (__fastcall **)(int *, CPed *))(v21 + 36))(v20, v17);
          }
        }
      }
      if ( v7->VehicleCreatedBy == 2 )
        CMissionCleanup::AddEntityToList(
          &CTheScripts::MissionCleanUp,
          CPools::ms_pVehiclePool->m_aFlags[-1075391197
                                          * (((char *)v7 - (char *)CPools::ms_pVehiclePool->m_aStorage) >> 2)] | (-422239488 * (((char *)v7 - (char *)CPools::ms_pVehiclePool->m_aStorage) >> 2)),
          1u);
    }
    while ( v0 < pData[0] );
  }
  v22 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v34, 2);
    UseDataFence = v22;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v34, 4);
  if ( v34._vptr$CTask != (int (**)(void))-1 )
  {
    Vehicle = CPools::GetVehicle((int32)v34._vptr$CTask);
    if ( Vehicle )
    {
      CWorld::Players[0].pRemoteVehicle = Vehicle;
      if ( FindPlayerVehicle(-1, 0) )
      {
        PlayerVehicle = FindPlayerVehicle(-1, 0);
        PlayerVehicle->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&PlayerVehicle->m_info & 7 | 0x48);
      }
    }
  }
  v25 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
    UseDataFence = v25;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == 2 )
  {
    v28 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&v33, 2);
      UseDataFence = v28;
    }
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v33, 4);
    if ( v33 != -1 )
    {
      v27 = CPools::GetVehicle(v33);
      if ( v27 )
        goto LABEL_48;
    }
  }
  else if ( nRef == 3 )
  {
    v26 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&v33, 2);
      UseDataFence = v26;
    }
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v33, 4);
    if ( v33 != -1 )
    {
      v27 = CPools::GetPed(v33);
      if ( v27 )
LABEL_48:
        TheCamera.Cams[0].CamTargetEntity = v27;
    }
  }
  if ( !TheCamera.Cams[0].CamTargetEntity )
    TheCamera.Cams[0].CamTargetEntity = CWorld::Players[0].pPed;
  v29 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v33, 2);
    UseDataFence = v29;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v33, 4);
  if ( v33 >= 0 )
  {
    v30 = CPools::GetVehicle(v33);
    if ( v30 )
    {
      m_info = v30->m_info;
      v30->m_pTowingVehicle = CWorld::Players[0].pPed->m_pMyVehicle;
      v30->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&m_info & 7 | 0x50);
    }
  }
  return 1;
}
// 4884B0: variable 'v14' is possibly undefined
// 4884FE: variable 'v20' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 67664C: using guessed type int *CCarCtrl::NumRandomCars;
// 678534: using guessed type int *CPools::ms_pVehiclePool;
// 488244: using guessed type int pData[8];

//----- (00488724) --------------------------------------------------------
int CPools::SaveObjectPool()
{
  int v0; // r5
  uint8 *m_aFlags; // r1
  int v2; // r2
  int32 v3; // r3
  bool v4; // r6
  __int16 v5; // r2
  __int16 v6; // r9
  _WORD *v7; // r4
  _DWORD *v8; // r4
  int v9; // r10
  int i; // r8
  CObject *v11; // r5
  int32 ObjectRef; // r6
  bool v13; // r9
  __int16 v14; // r0
  __int16 v15; // r11
  _WORD *v16; // r4
  _DWORD *v17; // r4
  bool v18; // r6
  __int16 v19; // r0
  __int16 v20; // r9
  _WORD *v21; // r4
  _DWORD *v22; // r4
  _DWORD *v23; // r4
  CEntity::CFlags *v24; // r4
  CEntity::CFlags v25; // d16
  CEntity::CFlags v26; // d17
  CEntity::CFlags v27; // d20
  CEntity::CFlags v28; // d21
  CEntity::CFlags m_nEntityFlags; // d18
  CEntity::CFlags v30; // d19
  int m_nModelIndex; // [sp+28h] [bp-58h]
  int32 m_nSize; // [sp+2Ch] [bp-54h]
  CObjectSaveStructure v34; // [sp+30h] [bp-50h] BYREF

  v0 = 0;
  m_nSize = CPools::ms_pObjectPool->m_nSize;
  if ( m_nSize )
  {
    m_aFlags = CPools::ms_pObjectPool->m_aFlags;
    v2 = 320;
    v3 = CPools::ms_pObjectPool->m_nSize;
    do
    {
      if ( (*m_aFlags & 0x80u) == 0
        && &(*CPools::ms_pObjectPool->m_aStorage)[v2] != (uint8 *)&elf_hash_bucket[17]
        && (*CPools::ms_pObjectPool->m_aStorage)[v2] == 2 )
      {
        ++v0;
      }
      v2 += 420;
      ++m_aFlags;
      --v3;
    }
    while ( v3 );
  }
  v4 = UseDataFence;
  if ( UseDataFence )
  {
    v5 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v6 = v5 + DataFence;
    v7 = malloc(2u);
    *v7 = v6;
    CGenericGameStorage::_SaveDataToWorkBuffer(v7, 2);
    free(v7);
    UseDataFence = v4;
  }
  v8 = malloc(4u);
  *v8 = v0;
  CGenericGameStorage::_SaveDataToWorkBuffer(v8, 4);
  free(v8);
  if ( v0 )
  {
    if ( m_nSize )
    {
      v9 = 0;
      for ( i = 0; i != m_nSize; ++i )
      {
        if ( (CPools::ms_pObjectPool->m_aFlags[i] & 0x80u) == 0 )
        {
          v11 = (CObject *)CPools::ms_pObjectPool->m_aStorage[v9];
          if ( v11 )
          {
            if ( v11->ObjectCreatedBy == 2 )
            {
              ObjectRef = CPools::GetObjectRef(v11);
              m_nModelIndex = v11->m_nModelIndex;
              v13 = UseDataFence;
              if ( UseDataFence )
              {
                UseDataFence = 0;
                v14 = currentSaveFenceCount++;
                v15 = v14 + DataFence;
                v16 = malloc(2u);
                *v16 = v15;
                CGenericGameStorage::_SaveDataToWorkBuffer(v16, 2);
                free(v16);
                UseDataFence = v13;
              }
              v17 = malloc(4u);
              *v17 = ObjectRef;
              CGenericGameStorage::_SaveDataToWorkBuffer(v17, 4);
              free(v17);
              v18 = UseDataFence;
              if ( UseDataFence )
              {
                UseDataFence = 0;
                v19 = currentSaveFenceCount++;
                v20 = v19 + DataFence;
                v21 = malloc(2u);
                *v21 = v20;
                CGenericGameStorage::_SaveDataToWorkBuffer(v21, 2);
                free(v21);
                UseDataFence = v18;
              }
              v22 = malloc(4u);
              *v22 = m_nModelIndex;
              CGenericGameStorage::_SaveDataToWorkBuffer(v22, 4);
              free(v22);
              CObjectSaveStructure::Construct(&v34, v11);
              v23 = malloc(4u);
              *v23 = 52;
              CGenericGameStorage::_SaveDataToWorkBuffer(v23, 4);
              free(v23);
              v24 = (CEntity::CFlags *)malloc(0x34u);
              v25 = *(CEntity::CFlags *)&v34.m_CompressedMatrix.CoorX;
              v26 = *(CEntity::CFlags *)&v34.m_CompressedMatrix.CoorZ;
              v27 = *(CEntity::CFlags *)&v34.m_CompressedMatrix.Matrix_yy;
              v28 = *(CEntity::CFlags *)&v34.m_ObjMessage;
              m_nEntityFlags = v34.m_nEntityFlags;
              v30 = *(CEntity::CFlags *)&v34.m_pad;
              *(_DWORD *)&v24[6] = *(_DWORD *)&v34.m_StoredCollisionDamageEffect;
              v24[4] = m_nEntityFlags;
              v24[5] = v30;
              *v24 = v25;
              v24[1] = v26;
              v24[2] = v27;
              v24[3] = v28;
              CGenericGameStorage::_SaveDataToWorkBuffer(v24, 52);
              free(v24);
            }
          }
        }
        ++v9;
      }
    }
    return 1;
  }
  else
  {
    CGenericGameStorage::ms_bFailed = 1;
    return 0;
  }
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (004889D0) --------------------------------------------------------
int CPools::LoadObjectPool()
{
  bool v0; // r4
  int v1; // r11
  int v2; // r8
  int i; // r9
  bool v4; // r4
  bool v5; // r4
  int32 v6; // r1
  CObject *v7; // r0
  CObject *v8; // r6
  unsigned int v9; // r4
  CMatrix *m_pMat; // r0
  float *p_tx; // r1
  float v12; // s0
  float v13; // s2
  RwReal *p_y; // r0
  int v15; // r0
  int v16; // r0
  int v17; // r3
  int v18; // r4
  float *v19; // r2
  int *v20; // r4
  int v21; // t1
  _DWORD v23[300]; // [sp+18h] [bp-9D0h] BYREF
  _DWORD pData[301]; // [sp+4C8h] [bp-520h] BYREF
  int v25; // [sp+97Ch] [bp-6Ch] BYREF
  int32 nModelIndex; // [sp+980h] [bp-68h] BYREF
  int32 index; // [sp+984h] [bp-64h] BYREF
  CObjectSaveStructure v28; // [sp+988h] [bp-60h] BYREF
  char v29[44]; // [sp+9BCh] [bp-2Ch] BYREF

  v0 = UseDataFence;
  v25 = 0;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v25, 4);
  if ( v25 )
  {
    memset(pData, 255, 0x4B0u);
    memset(v23, 0, sizeof(v23));
    if ( v25 >= 1 )
    {
      v1 = 0;
      v2 = 0;
      for ( i = 0; i < v25; ++i )
      {
        v4 = UseDataFence;
        if ( UseDataFence )
        {
          UseDataFence = 0;
          CGenericGameStorage::_LoadDataFromWorkBuffer(&v28, 2);
          UseDataFence = v4;
        }
        CGenericGameStorage::_LoadDataFromWorkBuffer(&index, 4);
        v5 = UseDataFence;
        if ( UseDataFence )
        {
          UseDataFence = 0;
          CGenericGameStorage::_LoadDataFromWorkBuffer(&v28, 2);
          UseDataFence = v5;
        }
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nModelIndex, 4);
        v6 = index;
        if ( (CPools::ms_pObjectPool->m_aFlags[index >> 8] & 0x80u) == 0 )
        {
          v7 = (CObject *)CPools::ms_pObjectPool->m_aStorage[index >> 8];
          if ( v7 )
          {
            CPopulation::ConvertToDummyObject(v7);
            v6 = index;
          }
        }
        v8 = (CObject *)CObject::operator new(0x184u, v6);
        v9 = 0;
        CObject::CObject(v8, nModelIndex, 0);
        CGenericGameStorage::_LoadDataFromWorkBuffer(v29, 4);
        CGenericGameStorage::_LoadDataFromWorkBuffer(&v28, 52);
        CObjectSaveStructure::Extract(&v28, v8);
        m_pMat = v8->m_pMat;
        p_tx = &m_pMat->tx;
        if ( !m_pMat )
          p_tx = &v8->m_transform.m_translate.x;
        v12 = *p_tx;
        v13 = p_tx[1];
        p_y = &dupPos[0].y;
        while ( sqrtf(
                  (float)((float)((float)(v12 - *(p_y - 1)) * (float)(v12 - *(p_y - 1)))
                        + (float)((float)(v13 - *p_y) * (float)(v13 - *p_y)))
                + (float)((float)(p_tx[2] - p_y[1]) * (float)(p_tx[2] - p_y[1]))) >= 0.01 )
        {
          ++v9;
          p_y += 3;
          if ( v9 > 0x16 )
          {
            v15 = 0;
            if ( i )
              goto LABEL_19;
LABEL_31:
            v23[v1++] = v8;
            goto LABEL_32;
          }
        }
        v15 = 1;
        if ( !i )
          goto LABEL_31;
LABEL_19:
        if ( v15 )
          goto LABEL_32;
        if ( v1 < 1 )
          goto LABEL_31;
        v16 = 0;
        while ( 1 )
        {
          if ( (v8->m_nModelIndex | 8) != 3085 )
          {
            v17 = v23[v16];
            v18 = *(_DWORD *)(v17 + 20);
            v19 = (float *)(v18 + 48);
            if ( !v18 )
              v19 = (float *)(v17 + 4);
            if ( *v19 == v12 && v19[1] == v13 )
              break;
          }
          if ( ++v16 >= v1 )
            goto LABEL_31;
        }
        pData[v2++] = v16;
LABEL_32:
        CWorld::Add(v8);
      }
      if ( v2 )
      {
        v20 = pData;
        do
        {
          v21 = *v20++;
          CWorld::Remove((CEntity *)v23[v21]);
          --v2;
        }
        while ( v2 );
      }
    }
    return 1;
  }
  else
  {
    CGenericGameStorage::ms_bFailed = 1;
    return 0;
  }
}
// 4889D0: using guessed type _DWORD pData[301];
// 4889D0: using guessed type _DWORD var_9D0[300];
// 4889D0: using guessed type char var_2C[44];

//----- (00488C74) --------------------------------------------------------
void SaveSomeStaticSettings()
{
  float *v0; // r4
  float *v1; // r4

  v0 = (float *)malloc(4u);
  *v0 = CCarCtrl::CarDensityMultiplier;
  CGenericGameStorage::_SaveDataToWorkBuffer(v0, 4);
  free(v0);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CCarCtrl::bAllowEmergencyServicesToBeCreated, 1);
  v1 = (float *)malloc(4u);
  *v1 = CPopulation::PedDensityMultiplier;
  CGenericGameStorage::_SaveDataToWorkBuffer(v1, 4);
  j_free(v1);
}

//----- (00488CD4) --------------------------------------------------------
void LoadSomeStaticSettings()
{
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CCarCtrl::CarDensityMultiplier, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CCarCtrl::bAllowEmergencyServicesToBeCreated, 1);
  sub_193B6C(&CPopulation::PedDensityMultiplier, 4);
}

//----- (00488D0C) --------------------------------------------------------
int CPools::Save()
{
  _QWORD *v0; // r4
  __int64 v1; // d16
  __int64 v2; // d17
  __int64 v3; // d20
  __int64 v4; // d21
  CDecisionMakerTypes *v5; // r4
  CDecisionMakerTypes *v6; // r5
  _QWORD *v7; // r4
  __int64 v8; // d19
  __int64 v9; // d16
  __int64 v10; // d17
  __int64 v11; // d22
  __int64 v12; // d23
  __int64 v13; // d20
  __int64 v14; // d21
  COnscreenCounterEntry *v15; // r4
  CAudioEngine *v16; // r0
  float *v17; // r4
  float *v18; // r4
  int v19; // r8
  bool v20; // r6
  __int16 v21; // r2
  __int16 v22; // r4
  _WORD *v23; // r5
  bool v24; // r6
  __int16 v25; // r2
  __int16 v26; // r4
  _WORD *v27; // r5

  CPools::SavePedPool();
  CPools::SaveVehiclePool();
  if ( IsMissionSave )
  {
    CPools::SavePedTasks();
    CPedGroups::Save();
    CGenericGameStorage::_SaveDataToWorkBuffer(CDecisionMakerTypes::m_bIsActive, 20);
    v0 = malloc(0x28u);
    v1 = *(_QWORD *)CDecisionMakerTypes::ScriptReferenceIndex;
    v2 = *(_QWORD *)&CDecisionMakerTypes::ScriptReferenceIndex[4];
    v3 = *(_QWORD *)&CDecisionMakerTypes::ScriptReferenceIndex[8];
    v4 = *(_QWORD *)&CDecisionMakerTypes::ScriptReferenceIndex[12];
    v0[4] = *(_QWORD *)&CDecisionMakerTypes::ScriptReferenceIndex[16];
    *v0 = v1;
    v0[1] = v2;
    v0[2] = v3;
    v0[3] = v4;
    CGenericGameStorage::_SaveDataToWorkBuffer(v0, 40);
    free(v0);
    CGenericGameStorage::_SaveDataToWorkBuffer(CDecisionMakerTypes::m_types, 20);
    v5 = CDecisionMakerTypes::m_pPedDecisionTypes;
    v6 = (CDecisionMakerTypes *)malloc(0xF1C0u);
    qmemcpy(v6, v5, sizeof(CDecisionMakerTypes));
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 61888);
    free(v6);
    v7 = malloc(0x40u);
    v8 = *(_QWORD *)&CUserDisplay::OnscnTimer.TimerEntry[0].Clock;
    v9 = *(_QWORD *)&CUserDisplay::OnscnTimer.TimerEntry[0].ClockIndex;
    v10 = *(_QWORD *)&CUserDisplay::OnscnTimer.TimerEntry[0].ClockTextKey[4];
    v11 = *(_QWORD *)&CUserDisplay::OnscnTimer.TimerEntry[0].ClockString[2];
    v12 = *(_QWORD *)&CUserDisplay::OnscnTimer.TimerEntry[0].ClockString[10];
    v13 = *(_QWORD *)&CUserDisplay::OnscnTimer.TimerEntry[0].ClockString[18];
    v14 = *(_QWORD *)&CUserDisplay::OnscnTimer.TimerEntry[0].ClockString[26];
    v7[6] = *(_QWORD *)&CUserDisplay::OnscnTimer.TimerEntry[0].ClockString[34];
    v7[7] = v8;
    v7[4] = v13;
    v7[5] = v14;
    *v7 = v9;
    v7[1] = v10;
    v7[2] = v11;
    v7[3] = v12;
    CGenericGameStorage::_SaveDataToWorkBuffer(v7, 64);
    free(v7);
    v15 = (COnscreenCounterEntry *)malloc(0x110u);
    qmemcpy(v15, CUserDisplay::OnscnTimer.CounterEntry, 0x110u);
    CGenericGameStorage::_SaveDataToWorkBuffer(v15, 272);
    free(v15);
    CPedScriptedTaskRecord::Save();
    CAudioEngine::Save(v16);
    v17 = (float *)malloc(4u);
    *v17 = CCarCtrl::CarDensityMultiplier;
    CGenericGameStorage::_SaveDataToWorkBuffer(v17, 4);
    free(v17);
    CGenericGameStorage::_SaveDataToWorkBuffer(&CCarCtrl::bAllowEmergencyServicesToBeCreated, 1);
    v18 = (float *)malloc(4u);
    *v18 = CPopulation::PedDensityMultiplier;
    CGenericGameStorage::_SaveDataToWorkBuffer(v18, 4);
    free(v18);
  }
  v19 = CPools::SaveObjectPool();
  if ( IsMissionSave )
  {
    v20 = UseDataFence;
    if ( UseDataFence )
    {
      v21 = currentSaveFenceCount;
      UseDataFence = 0;
      ++currentSaveFenceCount;
      v22 = v21 + DataFence;
      v23 = malloc(2u);
      *v23 = v22;
      CGenericGameStorage::_SaveDataToWorkBuffer(v23, 2);
      free(v23);
      UseDataFence = v20;
    }
    CGenericGameStorage::_SaveDataToWorkBuffer(&CPopulation::m_bDontCreateRandomGangMembers, 1);
    v24 = UseDataFence;
    if ( UseDataFence )
    {
      v25 = currentSaveFenceCount;
      UseDataFence = 0;
      ++currentSaveFenceCount;
      v26 = v25 + DataFence;
      v27 = malloc(2u);
      *v27 = v26;
      CGenericGameStorage::_SaveDataToWorkBuffer(v27, 2);
      free(v27);
      UseDataFence = v24;
    }
    CGenericGameStorage::_SaveDataToWorkBuffer(&CPopulation::m_bOnlyCreateRandomGangMembers, 1);
    CTheScripts::SaveAfter();
  }
  return v19;
}
// 488E2E: variable 'v16' is possibly undefined

//----- (00488F94) --------------------------------------------------------
int CPools::SavePedPool()
{
  int32 m_nSize; // r9
  int v1; // r3
  int v2; // r6
  int v3; // r8
  uint8 *v4; // r4
  int v5; // r5
  int v6; // r4
  int v7; // r2
  _DWORD *v8; // r4
  int v9; // r6
  int v10; // r8
  CPool<CPed,CCopPed>::StorageType *m_aStorage; // r11
  uint8 *v12; // r5
  int v13; // r0
  int32 PedRef; // r10
  int v15; // r9
  _DWORD *v16; // r4
  _DWORD *v17; // r4
  _DWORD *v18; // r4
  _DWORD *v19; // r4
  int32 v21; // [sp+Ch] [bp-34h]
  int v22; // [sp+10h] [bp-30h]
  char v23[8]; // [sp+17h] [bp-29h] BYREF

  m_nSize = CPools::ms_pPedPool->m_nSize;
  if ( m_nSize )
  {
    v1 = 0;
    v2 = 0;
    v3 = 0;
    do
    {
      if ( (CPools::ms_pPedPool->m_aFlags[v2] & 0x80u) == 0 )
      {
        v4 = CPools::ms_pPedPool->m_aStorage[v1];
        if ( v4 )
        {
          v5 = *((_DWORD *)v4 + 289);
          v6 = *((_DWORD *)v4 + 359);
          if ( (v5 & 0x100) == 0 || !v6 || IsMissionSave )
          {
            v7 = IsMissionSave;
            if ( IsMissionSave )
              v7 = 1;
            v3 += v7 | (v6 == 0);
          }
        }
      }
      ++v2;
      ++v1;
    }
    while ( m_nSize != v2 );
    v8 = malloc(4u);
    *v8 = v3;
    CGenericGameStorage::_SaveDataToWorkBuffer(v8, 4);
    free(v8);
    v9 = 0;
    v10 = 0;
    v21 = m_nSize;
    do
    {
      if ( (CPools::ms_pPedPool->m_aFlags[v10] & 0x80u) == 0 )
      {
        m_aStorage = CPools::ms_pPedPool->m_aStorage;
        v12 = CPools::ms_pPedPool->m_aStorage[v9];
        if ( v12 )
        {
          if ( (v13 = *((_DWORD *)v12 + 359), (*((_DWORD *)v12 + 289) & 0x100) == 0) && !v13 || !v13 || IsMissionSave )
          {
            PedRef = CPools::GetPedRef((CPed *)v12);
            v22 = *((_DWORD *)v12 + 359);
            v15 = *((__int16 *)v12 + 19);
            v16 = malloc(4u);
            *v16 = PedRef;
            CGenericGameStorage::_SaveDataToWorkBuffer(v16, 4);
            free(v16);
            v17 = malloc(4u);
            *v17 = v15;
            CGenericGameStorage::_SaveDataToWorkBuffer(v17, 4);
            free(v17);
            v18 = malloc(4u);
            *v18 = v22;
            CGenericGameStorage::_SaveDataToWorkBuffer(v18, 4);
            free(v18);
            if ( (unsigned int)(v15 - 290) <= 9 )
            {
              strncpy(v23, (const char *)CModelInfo::ms_modelInfoPtrs[v15]->m_modelName, 9u);
              CGenericGameStorage::_SaveDataToWorkBuffer(v23, 9);
            }
            (*(void (__fastcall **)(uint8 *))(*(_DWORD *)&m_aStorage[v9][0] + 100))(v12);
            m_nSize = v21;
          }
        }
      }
      ++v10;
      ++v9;
    }
    while ( m_nSize != v10 );
  }
  else
  {
    v19 = malloc(4u);
    *v19 = 0;
    CGenericGameStorage::_SaveDataToWorkBuffer(v19, 4);
    free(v19);
  }
  return 1;
}
// 48902C: conditional instruction was optimized away because r9.4!=0

//----- (00489170) --------------------------------------------------------
int CPools::SavePedTasks()
{
  int v0; // r8
  int32 m_nSize; // r10
  int32 v2; // r3
  int v3; // r6
  uint8 *m_aFlags; // r1
  uint8 *v5; // r4
  int v6; // r5
  int v7; // r4
  int v8; // r2
  bool v9; // r6
  __int16 v10; // r2
  __int16 v11; // r5
  _WORD *v12; // r4
  _DWORD *v13; // r4
  int v14; // r6
  int v15; // r5
  CPool<CPed,CCopPed>::StorageType *m_aStorage; // r11
  uint8 *v17; // r8
  int v18; // r0
  int32 PedRef; // r9
  int v20; // r10
  _DWORD *v21; // r0
  void *v22; // r4
  CPedIntelligence *v23; // r0
  int32 v25; // [sp+8h] [bp-20h]

  CTaskSequences::Save();
  v0 = 0;
  m_nSize = CPools::ms_pPedPool->m_nSize;
  if ( m_nSize )
  {
    v2 = CPools::ms_pPedPool->m_nSize;
    v3 = 0;
    m_aFlags = CPools::ms_pPedPool->m_aFlags;
    do
    {
      if ( (*m_aFlags & 0x80u) == 0 )
      {
        v5 = CPools::ms_pPedPool->m_aStorage[v3];
        if ( v5 )
        {
          v6 = *((_DWORD *)v5 + 289);
          v7 = *((_DWORD *)v5 + 359);
          if ( (v6 & 0x100) == 0 || !v7 || IsMissionSave )
          {
            v8 = IsMissionSave;
            if ( IsMissionSave )
              v8 = 1;
            v0 += v8 | (v7 == 0);
          }
        }
      }
      ++m_aFlags;
      --v2;
      ++v3;
    }
    while ( v2 );
  }
  v9 = UseDataFence;
  if ( UseDataFence )
  {
    v10 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v11 = v10 + DataFence;
    v12 = malloc(2u);
    *v12 = v11;
    CGenericGameStorage::_SaveDataToWorkBuffer(v12, 2);
    free(v12);
    UseDataFence = v9;
  }
  v13 = malloc(4u);
  *v13 = v0;
  CGenericGameStorage::_SaveDataToWorkBuffer(v13, 4);
  free(v13);
  if ( m_nSize )
  {
    v14 = 0;
    v15 = 1088;
    v25 = m_nSize;
    do
    {
      if ( (CPools::ms_pPedPool->m_aFlags[v14] & 0x80u) == 0 )
      {
        m_aStorage = CPools::ms_pPedPool->m_aStorage;
        v17 = &(*CPools::ms_pPedPool->m_aStorage)[v15];
        if ( v17 != (uint8 *)&elf_hash_bucket[209] )
        {
          if ( (v18 = *((_DWORD *)v17 + 87), (*((_DWORD *)v17 + 17) & 0x100) == 0) && !v18 || !v18 || IsMissionSave )
          {
            PedRef = CPools::GetPedRef((CPed *)(v17 - 1088));
            v20 = v17[8];
            v21 = malloc(4u);
            v22 = v21;
            if ( v20 == 2 )
            {
              *v21 = PedRef;
              CGenericGameStorage::_SaveDataToWorkBuffer(v21, 4);
              free(v22);
              m_nSize = v25;
              if ( v17[8] == 2 )
              {
                v23 = *(CPedIntelligence **)&(*m_aStorage)[v15];
                if ( v23 )
                  CPedIntelligence::Save(v23);
              }
            }
            else
            {
              *v21 = -1;
              CGenericGameStorage::_SaveDataToWorkBuffer(v21, 4);
              free(v22);
              m_nSize = v25;
            }
          }
        }
      }
      ++v14;
      v15 += 1996;
    }
    while ( m_nSize != v14 );
  }
  return 1;
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (00489328) --------------------------------------------------------
void CPedGroups::Save()
{
  _DWORD *v0; // r4
  int v1; // r1
  int v2; // r1
  CPed *m_lastPedRespondedTo; // r0
  int32 PedRef; // r8
  bool v5; // r6
  __int16 v6; // r0
  __int16 v7; // r10
  _WORD *v8; // r5
  _DWORD *v9; // r5
  bool v10; // r5
  __int16 v11; // r0
  __int16 v12; // r8
  _WORD *v13; // r4
  CPedGroup *v14; // r4
  int v15; // r8
  bool v16; // r6
  __int16 v17; // r0
  __int16 v18; // r10
  _WORD *v19; // r5
  _DWORD *v20; // r5
  CPed *Leader; // r0
  int32 v22; // r11
  bool v23; // r4
  __int16 v24; // r0
  __int16 v25; // r10
  _WORD *v26; // r6
  _DWORD *v27; // r6
  int i; // r5
  CPed *Member; // r0
  int32 v30; // r6
  bool v31; // r11
  __int16 v32; // r0
  __int16 v33; // r10
  _WORD *v34; // r4
  _DWORD *v35; // r4
  int v36; // [sp+54h] [bp-2Ch]

  CGenericGameStorage::_SaveDataToWorkBuffer(CPedGroups::ms_activeGroups, 8);
  v0 = malloc(8u);
  v1 = *(_DWORD *)CPedGroups::ScriptReferenceIndex;
  v0[1] = *(_DWORD *)&CPedGroups::ScriptReferenceIndex[2];
  *v0 = v1;
  CGenericGameStorage::_SaveDataToWorkBuffer(v0, 8);
  free(v0);
  v2 = 0;
  do
  {
    v36 = v2;
    if ( CPedGroups::ms_activeGroups[v2] )
    {
      m_lastPedRespondedTo = CPedGroups::ms_groups[v2].m_lastPedRespondedTo;
      if ( m_lastPedRespondedTo )
        PedRef = CPools::GetPedRef(m_lastPedRespondedTo);
      else
        PedRef = -1;
      v5 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        v6 = currentSaveFenceCount++;
        v7 = v6 + DataFence;
        v8 = malloc(2u);
        *v8 = v7;
        CGenericGameStorage::_SaveDataToWorkBuffer(v8, 2);
        free(v8);
        UseDataFence = v5;
      }
      v9 = malloc(4u);
      *v9 = PedRef;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
      free(v9);
      v10 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        v11 = currentSaveFenceCount++;
        v12 = v11 + DataFence;
        v13 = malloc(2u);
        *v13 = v12;
        CGenericGameStorage::_SaveDataToWorkBuffer(v13, 2);
        free(v13);
        UseDataFence = v10;
      }
      v14 = &CPedGroups::ms_groups[v36];
      CGenericGameStorage::_SaveDataToWorkBuffer(&v14->m_followLeader, 1);
      v15 = (*((int (__fastcall **)(const CPedGroupDefaultTaskAllocator *))v14->m_intelligence.m_pDefaultTaskAllocator->_vptr$CPedGroupDefaultTaskAllocator
             + 1))(v14->m_intelligence.m_pDefaultTaskAllocator);
      v16 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        v17 = currentSaveFenceCount++;
        v18 = v17 + DataFence;
        v19 = malloc(2u);
        *v19 = v18;
        CGenericGameStorage::_SaveDataToWorkBuffer(v19, 2);
        free(v19);
        UseDataFence = v16;
      }
      v20 = malloc(4u);
      *v20 = v15;
      CGenericGameStorage::_SaveDataToWorkBuffer(v20, 4);
      free(v20);
      Leader = CPedGroupMembership::GetLeader(&CPedGroups::ms_groups[v36].m_membership);
      if ( Leader )
        v22 = CPools::GetPedRef(Leader);
      else
        v22 = -1;
      v23 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        v24 = currentSaveFenceCount++;
        v25 = v24 + DataFence;
        v26 = malloc(2u);
        *v26 = v25;
        CGenericGameStorage::_SaveDataToWorkBuffer(v26, 2);
        free(v26);
        UseDataFence = v23;
      }
      v27 = malloc(4u);
      *v27 = v22;
      CGenericGameStorage::_SaveDataToWorkBuffer(v27, 4);
      free(v27);
      for ( i = 0; i != 8; ++i )
      {
        Member = CPedGroupMembership::GetMember(&CPedGroups::ms_groups[v36].m_membership, i);
        if ( Member )
          v30 = CPools::GetPedRef(Member);
        else
          v30 = -1;
        v31 = UseDataFence;
        if ( UseDataFence )
        {
          UseDataFence = 0;
          v32 = currentSaveFenceCount++;
          v33 = v32 + DataFence;
          v34 = malloc(2u);
          *v34 = v33;
          CGenericGameStorage::_SaveDataToWorkBuffer(v34, 2);
          free(v34);
          UseDataFence = v31;
        }
        v35 = malloc(4u);
        *v35 = v30;
        CGenericGameStorage::_SaveDataToWorkBuffer(v35, 4);
        free(v35);
      }
    }
    v2 = v36 + 1;
  }
  while ( v36 != 7 );
}

//----- (0048969C) --------------------------------------------------------
void CDecisionMakerTypes::Save()
{
  _QWORD *v0; // r4
  __int64 v1; // d16
  __int64 v2; // d17
  __int64 v3; // d20
  __int64 v4; // d21
  CDecisionMakerTypes *v5; // r4
  CDecisionMakerTypes *v6; // r5

  CGenericGameStorage::_SaveDataToWorkBuffer(CDecisionMakerTypes::m_bIsActive, 20);
  v0 = malloc(0x28u);
  v1 = *(_QWORD *)CDecisionMakerTypes::ScriptReferenceIndex;
  v2 = *(_QWORD *)&CDecisionMakerTypes::ScriptReferenceIndex[4];
  v3 = *(_QWORD *)&CDecisionMakerTypes::ScriptReferenceIndex[8];
  v4 = *(_QWORD *)&CDecisionMakerTypes::ScriptReferenceIndex[12];
  v0[4] = *(_QWORD *)&CDecisionMakerTypes::ScriptReferenceIndex[16];
  *v0 = v1;
  v0[1] = v2;
  v0[2] = v3;
  v0[3] = v4;
  CGenericGameStorage::_SaveDataToWorkBuffer(v0, 40);
  free(v0);
  CGenericGameStorage::_SaveDataToWorkBuffer(CDecisionMakerTypes::m_types, 20);
  v5 = CDecisionMakerTypes::m_pPedDecisionTypes;
  v6 = (CDecisionMakerTypes *)malloc(0xF1C0u);
  qmemcpy(v6, v5, sizeof(CDecisionMakerTypes));
  CGenericGameStorage::_SaveDataToWorkBuffer(v6, 61888);
  j_free(v6);
}
// 676BF4: using guessed type __int16 (*CDecisionMakerTypes::ScriptReferenceIndex)[20];
// 6793D0: using guessed type char (*CDecisionMakerTypes::m_bIsActive)[20];

//----- (00489738) --------------------------------------------------------
void __fastcall COnscreenTimer::Save(COnscreenTimer *this)
{
  _QWORD *v2; // r5
  __int64 v3; // d16
  __int64 v4; // d17
  __int64 v5; // d19
  __int64 v6; // d22
  __int64 v7; // d23
  __int64 v8; // d20
  __int64 v9; // d21
  COnscreenCounterEntry *v10; // r5

  v2 = malloc(0x40u);
  v3 = *(_QWORD *)&this->TimerEntry[0].ClockIndex;
  v4 = *(_QWORD *)&this->TimerEntry[0].ClockTextKey[4];
  v5 = *(_QWORD *)&this->TimerEntry[0].Clock;
  v6 = *(_QWORD *)&this->TimerEntry[0].ClockString[2];
  v7 = *(_QWORD *)&this->TimerEntry[0].ClockString[10];
  v8 = *(_QWORD *)&this->TimerEntry[0].ClockString[18];
  v9 = *(_QWORD *)&this->TimerEntry[0].ClockString[26];
  v2[6] = *(_QWORD *)&this->TimerEntry[0].ClockString[34];
  v2[7] = v5;
  v2[4] = v8;
  v2[5] = v9;
  *v2 = v3;
  v2[1] = v4;
  v2[2] = v6;
  v2[3] = v7;
  CGenericGameStorage::_SaveDataToWorkBuffer(v2, 64);
  free(v2);
  v10 = (COnscreenCounterEntry *)malloc(0x110u);
  qmemcpy(v10, this->CounterEntry, 0x110u);
  CGenericGameStorage::_SaveDataToWorkBuffer(v10, 272);
  j_free(v10);
}

//----- (004897B4) --------------------------------------------------------
void CPedScriptedTaskRecord::Save()
{
  int i; // r11
  bool v1; // r5
  CPedScriptedTaskRecordData *v2; // r8
  bool v3; // r5
  __int16 v4; // r10
  _WORD *v5; // r4
  _DWORD *v6; // r4
  bool v7; // r5
  __int16 v8; // r10
  _WORD *v9; // r4
  _DWORD *v10; // r4
  CPed *m_pPed; // r0
  int32 PedRef; // r10
  bool v13; // r6
  __int16 v14; // r9
  _WORD *v15; // r5
  _DWORD *v16; // r5
  const CEventScriptCommand *m_pEvent; // r4
  int v18; // r5
  bool v19; // r8
  __int16 v20; // r9
  _WORD *v21; // r6
  _DWORD *v22; // r6
  __int16 v23; // r0
  __int16 v24; // r8
  _WORD *v25; // r4
  _DWORD *v26; // r4

  for ( i = 0; i != 128; ++i )
  {
    v2 = &CPedScriptedTaskRecord::ms_scriptedTasks[i];
    if ( !CPedScriptedTaskRecord::ms_scriptedTasks[i].m_pEvent
      && !CPedScriptedTaskRecord::ms_scriptedTasks[i].m_pTask
      && !CPedScriptedTaskRecord::ms_scriptedTasks[i].m_pPed )
    {
      v1 = UseDataFence;
      if ( UseDataFence )
        goto LABEL_22;
      goto LABEL_23;
    }
    v3 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      v4 = currentSaveFenceCount++ + DataFence;
      v5 = malloc(2u);
      *v5 = v4;
      CGenericGameStorage::_SaveDataToWorkBuffer(v5, 2);
      free(v5);
      UseDataFence = v3;
    }
    v6 = malloc(4u);
    *v6 = CPedScriptedTaskRecord::ms_scriptedTasks[i].m_iCommandType;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
    free(v6);
    v7 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      v8 = currentSaveFenceCount++ + DataFence;
      v9 = malloc(2u);
      *v9 = v8;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 2);
      free(v9);
      UseDataFence = v7;
    }
    v10 = malloc(4u);
    *v10 = CPedScriptedTaskRecord::ms_scriptedTasks[i].m_iStage;
    CGenericGameStorage::_SaveDataToWorkBuffer(v10, 4);
    free(v10);
    m_pPed = CPedScriptedTaskRecord::ms_scriptedTasks[i].m_pPed;
    if ( m_pPed )
      PedRef = CPools::GetPedRef(m_pPed);
    else
      PedRef = -1;
    v13 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      v14 = currentSaveFenceCount++ + DataFence;
      v15 = malloc(2u);
      *v15 = v14;
      CGenericGameStorage::_SaveDataToWorkBuffer(v15, 2);
      free(v15);
      UseDataFence = v13;
    }
    v16 = malloc(4u);
    *v16 = PedRef;
    CGenericGameStorage::_SaveDataToWorkBuffer(v16, 4);
    free(v16);
    m_pEvent = v2->m_pEvent;
    if ( !m_pEvent )
    {
      v1 = UseDataFence;
      if ( UseDataFence )
      {
LABEL_22:
        v23 = currentSaveFenceCount;
        UseDataFence = 0;
        ++currentSaveFenceCount;
        v24 = v23 + DataFence;
        v25 = malloc(2u);
        *v25 = v24;
        CGenericGameStorage::_SaveDataToWorkBuffer(v25, 2);
        free(v25);
        UseDataFence = v1;
      }
LABEL_23:
      v26 = malloc(4u);
      *v26 = -1;
      CGenericGameStorage::_SaveDataToWorkBuffer(v26, 4);
      free(v26);
      continue;
    }
    v18 = (*((int (__fastcall **)(const CEventScriptCommand *))m_pEvent->_vptr$CEvent + 2))(v2->m_pEvent);
    v19 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      v20 = currentSaveFenceCount++ + DataFence;
      v21 = malloc(2u);
      *v21 = v20;
      CGenericGameStorage::_SaveDataToWorkBuffer(v21, 2);
      free(v21);
      UseDataFence = v19;
    }
    v22 = malloc(4u);
    *v22 = v18;
    CGenericGameStorage::_SaveDataToWorkBuffer(v22, 4);
    free(v22);
    if ( v18 == 32 )
      (*((void (__fastcall **)(int (***)(void)))m_pEvent->m_pTask->_vptr$CTask + 8))(&m_pEvent->m_pTask->_vptr$CTask);
  }
}

//----- (00489B40) --------------------------------------------------------
void __fastcall CAudioEngine::Save(CAudioEngine *this)
{
  bool v1; // r5
  __int16 v2; // r2
  __int16 v3; // r6
  _WORD *v4; // r4
  _QWORD *v5; // r4
  __int64 v6; // d17
  __int64 v7; // d18
  __int64 v8; // d19
  bool v9; // r5
  __int16 v10; // r2
  __int16 v11; // r6
  _WORD *v12; // r4
  _QWORD *v13; // r4
  __int64 v14; // d17
  __int64 v15; // d18
  __int64 v16; // d19
  bool v17; // r5
  __int16 v18; // r2
  __int16 v19; // r6
  _WORD *v20; // r4
  _QWORD *v21; // r4
  __int64 v22; // d17
  __int64 v23; // d18
  __int64 v24; // d19
  bool v25; // r5
  __int16 v26; // r2
  __int16 v27; // r6
  _WORD *v28; // r4
  _QWORD *v29; // r4
  __int64 v30; // d17
  __int64 v31; // d18
  __int64 v32; // d19

  v1 = UseDataFence;
  if ( UseDataFence )
  {
    v2 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v3 = v2 + DataFence;
    v4 = malloc(2u);
    *v4 = v3;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 2);
    free(v4);
    UseDataFence = v1;
  }
  v5 = malloc(0x20u);
  v6 = *(_QWORD *)&AudioEngine.m_ScriptAudioEntity.m_MissionSlotSettings[0].vAudioPosition.z;
  v7 = *(_QWORD *)&AudioEngine.m_ScriptAudioEntity.m_MissionSlotSettings[0].pSound;
  v8 = *(_QWORD *)&AudioEngine.m_ScriptAudioEntity.m_MissionSlotSettings[0].BankID;
  *v5 = *(_QWORD *)&AudioEngine.m_ScriptAudioEntity.m_MissionSlotSettings[0].vAudioPosition.x;
  v5[1] = v6;
  v5[2] = v7;
  v5[3] = v8;
  CGenericGameStorage::_SaveDataToWorkBuffer(v5, 32);
  free(v5);
  v9 = UseDataFence;
  if ( UseDataFence )
  {
    v10 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v11 = v10 + DataFence;
    v12 = malloc(2u);
    *v12 = v11;
    CGenericGameStorage::_SaveDataToWorkBuffer(v12, 2);
    free(v12);
    UseDataFence = v9;
  }
  v13 = malloc(0x20u);
  v14 = *(_QWORD *)&AudioEngine.m_ScriptAudioEntity.m_MissionSlotSettings[1].vAudioPosition.z;
  v15 = *(_QWORD *)&AudioEngine.m_ScriptAudioEntity.m_MissionSlotSettings[1].pSound;
  v16 = *(_QWORD *)&AudioEngine.m_ScriptAudioEntity.m_MissionSlotSettings[1].BankID;
  *v13 = *(_QWORD *)&AudioEngine.m_ScriptAudioEntity.m_MissionSlotSettings[1].vAudioPosition.x;
  v13[1] = v14;
  v13[2] = v15;
  v13[3] = v16;
  CGenericGameStorage::_SaveDataToWorkBuffer(v13, 32);
  free(v13);
  v17 = UseDataFence;
  if ( UseDataFence )
  {
    v18 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v19 = v18 + DataFence;
    v20 = malloc(2u);
    *v20 = v19;
    CGenericGameStorage::_SaveDataToWorkBuffer(v20, 2);
    free(v20);
    UseDataFence = v17;
  }
  v21 = malloc(0x20u);
  v22 = *(_QWORD *)&AudioEngine.m_ScriptAudioEntity.m_MissionSlotSettings[2].vAudioPosition.z;
  v23 = *(_QWORD *)&AudioEngine.m_ScriptAudioEntity.m_MissionSlotSettings[2].pSound;
  v24 = *(_QWORD *)&AudioEngine.m_ScriptAudioEntity.m_MissionSlotSettings[2].BankID;
  *v21 = *(_QWORD *)&AudioEngine.m_ScriptAudioEntity.m_MissionSlotSettings[2].vAudioPosition.x;
  v21[1] = v22;
  v21[2] = v23;
  v21[3] = v24;
  CGenericGameStorage::_SaveDataToWorkBuffer(v21, 32);
  free(v21);
  v25 = UseDataFence;
  if ( UseDataFence )
  {
    v26 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v27 = v26 + DataFence;
    v28 = malloc(2u);
    *v28 = v27;
    CGenericGameStorage::_SaveDataToWorkBuffer(v28, 2);
    free(v28);
    UseDataFence = v25;
  }
  v29 = malloc(0x20u);
  v30 = *(_QWORD *)&AudioEngine.m_ScriptAudioEntity.m_MissionSlotSettings[3].vAudioPosition.z;
  v31 = *(_QWORD *)&AudioEngine.m_ScriptAudioEntity.m_MissionSlotSettings[3].pSound;
  v32 = *(_QWORD *)&AudioEngine.m_ScriptAudioEntity.m_MissionSlotSettings[3].BankID;
  *v29 = *(_QWORD *)&AudioEngine.m_ScriptAudioEntity.m_MissionSlotSettings[3].vAudioPosition.x;
  v29[1] = v30;
  v29[2] = v31;
  v29[3] = v32;
  CGenericGameStorage::_SaveDataToWorkBuffer(v29, 32);
  j_free(v29);
}

//----- (00489D98) --------------------------------------------------------
void CTheScripts::SaveAfter()
{
  int i; // r8
  CEntity *pEntity; // r0
  bool v2; // r10
  int v3; // r9
  __int16 v4; // r11
  _WORD *v5; // r4
  _DWORD *v6; // r4
  CEntity *v7; // r0
  int v8; // r1
  int32 VehicleRef; // r9
  bool v10; // r5
  __int16 v11; // r9
  _WORD *v12; // r4
  _DWORD *v13; // r4
  void *v14; // r0
  bool v15; // r4
  __int16 v16; // r0
  __int16 v17; // r10
  _WORD *v18; // r5
  _DWORD *v19; // r5
  bool v20; // r5
  __int16 v21; // r9
  _WORD *v22; // r4
  _WORD *v23; // r4

  for ( i = 0; i != 150; ++i )
  {
    pEntity = CTheScripts::EntitiesWaitingForScriptBrain[i].pEntity;
    if ( !pEntity )
    {
      v10 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        v11 = currentSaveFenceCount++ + DataFence;
        v12 = malloc(2u);
        *v12 = v11;
        CGenericGameStorage::_SaveDataToWorkBuffer(v12, 2);
        free(v12);
        UseDataFence = v10;
      }
      v13 = malloc(4u);
      *v13 = 0;
      CGenericGameStorage::_SaveDataToWorkBuffer(v13, 4);
      v14 = v13;
      goto LABEL_27;
    }
    v2 = UseDataFence;
    v3 = *(_BYTE *)&pEntity->m_info & 7;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      v4 = currentSaveFenceCount++ + DataFence;
      v5 = malloc(2u);
      *v5 = v4;
      CGenericGameStorage::_SaveDataToWorkBuffer(v5, 2);
      free(v5);
      UseDataFence = v2;
    }
    v6 = malloc(4u);
    *v6 = v3;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
    free(v6);
    v7 = CTheScripts::EntitiesWaitingForScriptBrain[i].pEntity;
    v8 = *(_BYTE *)&v7->m_info & 7;
    switch ( v8 )
    {
      case 2:
        if ( v7 )
          VehicleRef = CPools::GetVehicleRef((CVehicle *)v7);
        else
          VehicleRef = -1;
        v15 = UseDataFence;
        if ( !UseDataFence )
          goto LABEL_26;
        break;
      case 4:
        if ( v7 )
          VehicleRef = CPools::GetObjectRef((CObject *)v7);
        else
          VehicleRef = -1;
        v15 = UseDataFence;
        if ( !UseDataFence )
          goto LABEL_26;
        break;
      case 3:
        if ( v7 )
          VehicleRef = CPools::GetPedRef((CPed *)v7);
        else
          VehicleRef = -1;
        v15 = UseDataFence;
        if ( !UseDataFence )
          goto LABEL_26;
        break;
      default:
        goto LABEL_28;
    }
    v16 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v17 = v16 + DataFence;
    v18 = malloc(2u);
    *v18 = v17;
    CGenericGameStorage::_SaveDataToWorkBuffer(v18, 2);
    free(v18);
    UseDataFence = v15;
LABEL_26:
    v19 = malloc(4u);
    *v19 = VehicleRef;
    CGenericGameStorage::_SaveDataToWorkBuffer(v19, 4);
    v14 = v19;
LABEL_27:
    free(v14);
LABEL_28:
    v20 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      v21 = currentSaveFenceCount++ + DataFence;
      v22 = malloc(2u);
      *v22 = v21;
      CGenericGameStorage::_SaveDataToWorkBuffer(v22, 2);
      free(v22);
      UseDataFence = v20;
    }
    v23 = malloc(2u);
    *v23 = CTheScripts::EntitiesWaitingForScriptBrain[i].ScriptBrainIndex;
    CGenericGameStorage::_SaveDataToWorkBuffer(v23, 2);
    free(v23);
  }
}

//----- (0048A0C4) --------------------------------------------------------
int CPools::Load()
{
  CAudioEngine *v0; // r0
  int ObjectPool; // r4
  bool v2; // r5
  bool v3; // r5
  char pData[2]; // [sp+4h] [bp-14h] BYREF
  char v6[18]; // [sp+6h] [bp-12h] BYREF

  CPools::LoadPedPool();
  CPools::LoadVehiclePool();
  if ( IsMissionSave )
  {
    DoingCheckpointLoad = 1;
    CPools::LoadPedTasks();
    CPedGroups::Load();
    CDecisionMakerTypes::Load();
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CUserDisplay::OnscnTimer, 64);
    CGenericGameStorage::_LoadDataFromWorkBuffer(CUserDisplay::OnscnTimer.CounterEntry, 272);
    CPedScriptedTaskRecord::Load();
    CAudioEngine::Load(v0);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CCarCtrl::CarDensityMultiplier, 4);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CCarCtrl::bAllowEmergencyServicesToBeCreated, 1);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CPopulation::PedDensityMultiplier, 4);
  }
  ObjectPool = CPools::LoadObjectPool();
  if ( IsMissionSave )
  {
    v2 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
      UseDataFence = v2;
    }
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CPopulation::m_bDontCreateRandomGangMembers, 1);
    v3 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      CGenericGameStorage::_LoadDataFromWorkBuffer(v6, 2);
      UseDataFence = v3;
    }
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CPopulation::m_bOnlyCreateRandomGangMembers, 1);
    CTheScripts::LoadAfter();
  }
  return ObjectPool;
}
// 48A114: variable 'v0' is possibly undefined
// 6784A0: using guessed type char *CPopulation::m_bOnlyCreateRandomGangMembers[3];
// 48A0C4: using guessed type char pData[2];
// 48A0C4: using guessed type char var_12[18];

//----- (0048A1E4) --------------------------------------------------------
int CPools::LoadPedPool()
{
  int i; // r4
  int32 v1; // r0
  CEmergencyPed *v2; // r6
  int pData; // [sp+4h] [bp-3Ch] BYREF
  signed int v5; // [sp+8h] [bp-38h] BYREF
  Int32 Index; // [sp+Ch] [bp-34h] BYREF
  int32 index; // [sp+10h] [bp-30h] BYREF
  unsigned __int8 v8[8]; // [sp+17h] [bp-29h] BYREF

  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
  if ( pData >= 1 )
  {
    for ( i = 0; i < pData; ++i )
    {
      CGenericGameStorage::_LoadDataFromWorkBuffer(&index, 4);
      CGenericGameStorage::_LoadDataFromWorkBuffer(&Index, 4);
      CGenericGameStorage::_LoadDataFromWorkBuffer(&v5, 4);
      v1 = Index;
      if ( (unsigned int)(Index - 290) <= 9 )
      {
        CGenericGameStorage::_LoadDataFromWorkBuffer(v8, 9);
        CStreaming::RequestSpecialChar(Index - 290, v8, 12);
        CScriptResourceManager::AddToResourceManager(&CTheScripts::ScriptResourceManager, Index, 2u, missionScript);
        v1 = Index;
      }
      if ( v1 )
      {
        CStreaming::RequestModel(v1, 16);
        CStreaming::LoadAllRequestedModels(1);
      }
      if ( (unsigned int)(v5 - 18) < 2 )
      {
        v2 = (CEmergencyPed *)CPed::operator new(0x7A4u, index);
        CEmergencyPed::CEmergencyPed(v2, v5, Index);
      }
      else if ( v5 == 6 )
      {
        v2 = (CEmergencyPed *)CPed::operator new(0x7CCu, index);
        CCopPed::CCopPed((CCopPed *)v2, COPTYPE_NORMAL);
      }
      else if ( v5 )
      {
        v2 = (CEmergencyPed *)CPed::operator new(0x7A4u, index);
        CCivilianPed::CCivilianPed((CCivilianPed *)v2, (ePedType)v5, Index);
      }
      else
      {
        v2 = (CEmergencyPed *)CPed::operator new(0x7ACu, index);
        CPlayerPed::CPlayerPed((CPlayerPed *)v2, 0, 0);
        v2->m_nShootingAccuracy = 100;
        CWorld::Players[0].pPed = (CPlayerPed *)v2;
      }
      (*((void (__fastcall **)(CEmergencyPed *))v2->_vptr$CPlaceable + 26))(v2);
      CWorld::Add(v2);
    }
  }
  return 1;
}

//----- (0048A334) --------------------------------------------------------
int CPools::LoadPedTasks()
{
  bool v0; // r4
  int i; // r5
  CPed *Ped; // r0
  int v4; // [sp+4h] [bp-1Ch] BYREF
  int32 nRef; // [sp+8h] [bp-18h] BYREF
  char pData[18]; // [sp+Eh] [bp-12h] BYREF

  CTaskSequences::Load();
  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v4, 4);
  if ( v4 >= 1 )
  {
    for ( i = 0; i < v4; ++i )
    {
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef >= 0 )
      {
        Ped = CPools::GetPed(nRef);
        if ( Ped->CharCreatedBy == 2 )
        {
          loadingPed = Ped;
          CPedIntelligence::Load(Ped->m_pPedIntelligence);
          loadingPed = 0;
        }
      }
    }
  }
  return 1;
}
// 48A334: using guessed type char pData[18];

//----- (0048A3C4) --------------------------------------------------------
void CPedGroups::Load()
{
  int i; // r4
  bool v1; // r6
  bool v2; // r6
  bool v3; // r6
  bool v4; // r6
  CPed *Ped; // r0
  CPed *v6; // r6
  CPedGroupMembership *p_m_membership; // r8
  CTaskComplexBeInGroup *v8; // r11
  int v9; // r6
  bool v10; // r4
  CPed *v11; // r0
  CPed *v12; // r11
  _BOOL4 IsPlayer; // r0
  CTaskComplexBeInGroup *v14; // r8
  CPedGroupMembership *v15; // [sp+38h] [bp-58h]
  CPedGroup *v16; // [sp+3Ch] [bp-54h]
  int v17; // [sp+40h] [bp-50h]
  CPed *v18; // [sp+44h] [bp-4Ch]
  int32 v19; // [sp+48h] [bp-48h] BYREF
  CEventScriptCommand pData; // [sp+4Ch] [bp-44h] BYREF
  int32 v21; // [sp+64h] [bp-2Ch] BYREF
  int iType; // [sp+68h] [bp-28h] BYREF
  char v23; // [sp+6Fh] [bp-21h] BYREF
  int32 nRef[8]; // [sp+70h] [bp-20h] BYREF

  CGenericGameStorage::_LoadDataFromWorkBuffer(CPedGroups::ms_activeGroups, 8);
  CGenericGameStorage::_LoadDataFromWorkBuffer(CPedGroups::ScriptReferenceIndex, 8);
  for ( i = 0; i != 8; ++i )
  {
    if ( CPedGroups::ms_activeGroups[i] )
    {
      v1 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v1;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(nRef, 4);
      if ( nRef[0] != -1 )
        CPools::GetPed(nRef[0]);
      v2 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v2;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&v23, 1);
      v3 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v3;
      }
      v16 = &CPedGroups::ms_groups[i];
      CGenericGameStorage::_LoadDataFromWorkBuffer(&iType, 4);
      CPedGroupIntelligence::SetDefaultTaskAllocatorType(&v16->m_intelligence, iType);
      v4 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v4;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&v21, 4);
      v17 = i;
      if ( v21 == -1 || (Ped = CPools::GetPed(v21), (v6 = Ped) == 0) )
      {
        v18 = 0;
      }
      else
      {
        p_m_membership = &CPedGroups::ms_groups[i].m_membership;
        v18 = Ped;
        if ( !CPed::IsPlayer(Ped) || !CPedGroupMembership::GetLeader(p_m_membership) )
        {
          v8 = (CTaskComplexBeInGroup *)CTask::operator new(0x28u);
          CTaskComplexBeInGroup::CTaskComplexBeInGroup(v8, i, 1);
          CEventScriptCommand::CEventScriptCommand(&pData, 3, v8, 0);
          CEventGroup::Add(&v6->m_pPedIntelligence->m_eventGroup, &pData, 0);
          CPedGroupMembership::SetLeader(p_m_membership, v6);
          CPedGroup::Process(v16);
          CEventScriptCommand::~CEventScriptCommand(&pData);
        }
      }
      v9 = 8;
      v15 = &CPedGroups::ms_groups[i].m_membership;
      do
      {
        v10 = UseDataFence;
        if ( UseDataFence )
        {
          UseDataFence = 0;
          CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
          UseDataFence = v10;
        }
        CGenericGameStorage::_LoadDataFromWorkBuffer(&v19, 4);
        if ( v19 != -1 )
        {
          v11 = CPools::GetPed(v19);
          v12 = v11;
          if ( v11 )
          {
            IsPlayer = CPed::IsPlayer(v11);
            if ( v18 != v12 && !IsPlayer )
            {
              v14 = (CTaskComplexBeInGroup *)CTask::operator new(0x28u);
              CTaskComplexBeInGroup::CTaskComplexBeInGroup(v14, v17, 0);
              CEventScriptCommand::CEventScriptCommand(&pData, 3, v14, 0);
              CEventGroup::Add(&v12->m_pPedIntelligence->m_eventGroup, &pData, 0);
              CPedGroupMembership::AddFollower(v15, v12);
              CPedGroup::Process(v16);
              CEventScriptCommand::~CEventScriptCommand(&pData);
            }
          }
        }
        --v9;
      }
      while ( v9 );
      i = v17;
    }
  }
}
// 677350: using guessed type char (*CPedGroups::ms_activeGroups)[8];
// 677A44: using guessed type __int16 (*CPedGroups::ScriptReferenceIndex)[8];
// 48A3C4: using guessed type int32 nRef[8];

//----- (0048A694) --------------------------------------------------------
void CDecisionMakerTypes::Load()
{
  int32 i; // r4
  int32 UniqueScriptThingIndex; // r5
  unsigned __int8 v2[256]; // [sp+4h] [bp-11Ch] BYREF

  CGenericGameStorage::_LoadDataFromWorkBuffer(CDecisionMakerTypes::m_bIsActive, 20);
  CGenericGameStorage::_LoadDataFromWorkBuffer(CDecisionMakerTypes::ScriptReferenceIndex, 40);
  CGenericGameStorage::_LoadDataFromWorkBuffer(CDecisionMakerTypes::m_types, 20);
  CGenericGameStorage::_LoadDataFromWorkBuffer(CDecisionMakerTypes::m_pPedDecisionTypes, 61888);
  for ( i = 0; i != 20; ++i )
  {
    if ( i >= 15 && CDecisionMakerTypes::m_bIsActive[i] )
    {
      UniqueScriptThingIndex = CTheScripts::GetUniqueScriptThingIndex(i, 7u);
      CDecisionMakerTypesFileLoader::GetPedDMName(i - 15, v2);
      CDecisionMakerTypesFileLoader::LoadDecisionMaker(v2, CDecisionMakerTypes::m_types[i], 1u, i);
      CMissionCleanup::AddEntityToList(&CTheScripts::MissionCleanUp, UniqueScriptThingIndex, 9u);
    }
  }
}
// 676BF4: using guessed type __int16 (*CDecisionMakerTypes::ScriptReferenceIndex)[20];
// 6793D0: using guessed type char (*CDecisionMakerTypes::m_bIsActive)[20];

//----- (0048A770) --------------------------------------------------------
void __fastcall COnscreenTimer::Load(COnscreenTimer *this)
{
  CGenericGameStorage::_LoadDataFromWorkBuffer(this, 64);
  sub_193B6C(this->CounterEntry, 272);
}

//----- (0048A78C) --------------------------------------------------------
void CPedScriptedTaskRecord::Load()
{
  int i; // r6
  bool v1; // r8
  bool v2; // r5
  bool v3; // r5
  CPed *Ped; // r0
  bool v5; // r5
  CTask *Task; // r0
  CEventScriptCommand *v7; // r0
  CEventScriptCommand v8; // [sp+34h] [bp-44h] BYREF
  int v9; // [sp+4Ch] [bp-2Ch] BYREF
  int32 pData; // [sp+50h] [bp-28h] BYREF
  int v11; // [sp+54h] [bp-24h] BYREF
  int v12[8]; // [sp+58h] [bp-20h] BYREF

  for ( i = 0; i != 128; ++i )
  {
    CPedScriptedTaskRecordData::Flush(&CPedScriptedTaskRecord::ms_scriptedTasks[i]);
    v1 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      CGenericGameStorage::_LoadDataFromWorkBuffer(v12, 2);
      UseDataFence = v1;
    }
    CGenericGameStorage::_LoadDataFromWorkBuffer(v12, 4);
    if ( v12[0] != -1 )
    {
      CPedScriptedTaskRecord::ms_scriptedTasks[i].m_iCommandType = v12[0];
      v2 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 2);
        UseDataFence = v2;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 4);
      CPedScriptedTaskRecord::ms_scriptedTasks[i].m_iStage = v11;
      v3 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v3;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      if ( pData == -1 )
        Ped = 0;
      else
        Ped = CPools::GetPed(pData);
      CPedScriptedTaskRecord::ms_scriptedTasks[i].m_pPed = Ped;
      v5 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&v9, 2);
        UseDataFence = v5;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&v9, 4);
      if ( v9 == 32 )
      {
        Task = CTask::CreateTask();
        CEventScriptCommand::CEventScriptCommand(&v8, 3, Task, 0);
        CEventScriptCommand::~CEventScriptCommand(v7);
      }
    }
  }
}
// 48A8D0: variable 'v7' is possibly undefined

//----- (0048A914) --------------------------------------------------------
void __fastcall CAudioEngine::Load(CAudioEngine *this)
{
  bool v1; // r4
  bool v2; // r5
  bool v3; // r5
  bool v4; // r5
  tMissionSlotSettings v5; // [sp+0h] [bp-30h] BYREF

  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v5, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v5, 32);
  v2 = UseDataFence;
  AudioEngine.m_ScriptAudioEntity.m_MissionSlotSettings[0] = v5;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v5, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v5, 32);
  v3 = UseDataFence;
  AudioEngine.m_ScriptAudioEntity.m_MissionSlotSettings[1] = v5;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v5, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v5, 32);
  v4 = UseDataFence;
  AudioEngine.m_ScriptAudioEntity.m_MissionSlotSettings[2] = v5;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v5, 2);
    UseDataFence = v4;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v5, 32);
  AudioEngine.m_ScriptAudioEntity.m_MissionSlotSettings[3] = v5;
}

//----- (0048AA74) --------------------------------------------------------
void CTheScripts::LoadAfter()
{
  int i; // r5
  bool v1; // r4
  bool v2; // r4
  CEntity *Vehicle; // r0
  bool v4; // r4
  bool v5; // r4
  _BOOL4 v6; // r4
  int32 nRef; // [sp+24h] [bp-24h] BYREF
  int pData[8]; // [sp+28h] [bp-20h] BYREF

  for ( i = 0; i != 150; ++i )
  {
    v1 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
      UseDataFence = v1;
    }
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
    switch ( pData[0] )
    {
      case 2:
        v5 = UseDataFence;
        if ( UseDataFence )
        {
          UseDataFence = 0;
          CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
          UseDataFence = v5;
        }
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
        if ( nRef != -1 )
        {
          Vehicle = CPools::GetVehicle(nRef);
          goto LABEL_20;
        }
        break;
      case 4:
        v4 = UseDataFence;
        if ( UseDataFence )
        {
          UseDataFence = 0;
          CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
          UseDataFence = v4;
        }
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
        if ( nRef != -1 )
        {
          Vehicle = CPools::GetObject(nRef);
          goto LABEL_20;
        }
        break;
      case 3:
        v2 = UseDataFence;
        if ( UseDataFence )
        {
          UseDataFence = 0;
          CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
          UseDataFence = v2;
        }
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
        if ( nRef != -1 )
        {
          Vehicle = CPools::GetPed(nRef);
          goto LABEL_20;
        }
        break;
    }
    Vehicle = 0;
LABEL_20:
    v6 = UseDataFence;
    CTheScripts::EntitiesWaitingForScriptBrain[i].pEntity = Vehicle;
    if ( v6 )
    {
      UseDataFence = 0;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
      UseDataFence = v6;
    }
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::EntitiesWaitingForScriptBrain[i].ScriptBrainIndex, 2);
  }
}

//----- (0048AC24) --------------------------------------------------------
int CTheZones::Save()
{
  _DWORD *v0; // r4
  _WORD *v1; // r4
  _WORD *v2; // r4
  _WORD *v3; // r4
  unsigned __int16 v4; // r5
  CZone *v5; // r6
  _QWORD *v6; // r0
  UInt64 InfoLabel; // d16
  UInt64 TextLabel; // d17
  void *v9; // r4
  UInt64 v10; // d18
  UInt64 v11; // d19
  unsigned __int16 v12; // r5
  CZoneInfo *v13; // r6
  _QWORD *v14; // r4
  __int64 v15; // d17
  unsigned __int16 v16; // r5
  CZone *v17; // r6
  _QWORD *v18; // r0
  UInt64 v19; // d16
  UInt64 v20; // d17
  void *v21; // r4
  UInt64 v22; // d18
  UInt64 v23; // d19
  _DWORD *v24; // r4

  v0 = malloc(4u);
  *v0 = CTheZones::m_CurrLevel;
  CGenericGameStorage::_SaveDataToWorkBuffer(v0, 4);
  free(v0);
  v1 = malloc(2u);
  *v1 = CTheZones::TotalNumberOfNavigationZones;
  CGenericGameStorage::_SaveDataToWorkBuffer(v1, 2);
  free(v1);
  v2 = malloc(2u);
  *v2 = CTheZones::TotalNumberOfZoneInfos;
  CGenericGameStorage::_SaveDataToWorkBuffer(v2, 2);
  free(v2);
  v3 = malloc(2u);
  *v3 = CTheZones::TotalNumberOfMapZones;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 2);
  free(v3);
  if ( CTheZones::TotalNumberOfNavigationZones )
  {
    v4 = 0;
    do
    {
      v5 = &CTheZones::NavigationZoneArray[v4];
      v6 = malloc(0x20u);
      InfoLabel = v5->InfoLabel;
      TextLabel = v5->TextLabel;
      v5 = (CZone *)((char *)v5 + 16);
      v9 = v6;
      v10 = v5->InfoLabel;
      v11 = v5->TextLabel;
      *v6 = InfoLabel;
      v6[1] = TextLabel;
      v6 += 2;
      *v6 = v10;
      v6[1] = v11;
      CGenericGameStorage::_SaveDataToWorkBuffer(v9, 32);
      free(v9);
      ++v4;
    }
    while ( v4 < (unsigned int)CTheZones::TotalNumberOfNavigationZones );
  }
  if ( CTheZones::TotalNumberOfZoneInfos )
  {
    v12 = 0;
    do
    {
      v13 = &CTheZones::ZoneInfoArray[v12];
      v14 = malloc(0x11u);
      v15 = *(_QWORD *)&v13->aGangStrengths[8];
      *v14 = *(_QWORD *)v13->aGangStrengths;
      v14[1] = v15;
      *((_BYTE *)v14 + 16) = *((_BYTE *)v13 + 16);
      CGenericGameStorage::_SaveDataToWorkBuffer(v14, 17);
      free(v14);
      ++v12;
    }
    while ( v12 < (unsigned int)CTheZones::TotalNumberOfZoneInfos );
  }
  if ( CTheZones::TotalNumberOfMapZones )
  {
    v16 = 0;
    do
    {
      v17 = &CTheZones::MapZoneArray[v16];
      v18 = malloc(0x20u);
      v19 = v17->InfoLabel;
      v20 = v17->TextLabel;
      v17 = (CZone *)((char *)v17 + 16);
      v21 = v18;
      v22 = v17->InfoLabel;
      v23 = v17->TextLabel;
      *v18 = v19;
      v18[1] = v20;
      v18 += 2;
      *v18 = v22;
      v18[1] = v23;
      CGenericGameStorage::_SaveDataToWorkBuffer(v21, 32);
      free(v21);
      ++v16;
    }
    while ( v16 < (unsigned int)CTheZones::TotalNumberOfMapZones );
  }
  CGenericGameStorage::_SaveDataToWorkBuffer(CTheZones::ZonesVisited, 100);
  v24 = malloc(4u);
  *v24 = CTheZones::ZonesRevealed;
  CGenericGameStorage::_SaveDataToWorkBuffer(v24, 4);
  free(v24);
  return 1;
}

//----- (0048AE14) --------------------------------------------------------
int CTheZones::Load()
{
  unsigned __int16 v0; // r4
  unsigned __int16 v1; // r4
  unsigned __int16 v2; // r4

  CTheZones::Init();
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheZones::m_CurrLevel, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheZones::TotalNumberOfNavigationZones, 2);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheZones::TotalNumberOfZoneInfos, 2);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheZones::TotalNumberOfMapZones, 2);
  if ( CTheZones::TotalNumberOfNavigationZones )
  {
    v0 = 0;
    do
      CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheZones::NavigationZoneArray[v0++], 32);
    while ( v0 < (unsigned int)CTheZones::TotalNumberOfNavigationZones );
  }
  if ( CTheZones::TotalNumberOfZoneInfos )
  {
    v1 = 0;
    do
      CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheZones::ZoneInfoArray[v1++], 17);
    while ( v1 < (unsigned int)CTheZones::TotalNumberOfZoneInfos );
  }
  if ( CTheZones::TotalNumberOfMapZones )
  {
    v2 = 0;
    do
      CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheZones::MapZoneArray[v2++], 32);
    while ( v2 < (unsigned int)CTheZones::TotalNumberOfMapZones );
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(CTheZones::ZonesVisited, 100);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheZones::ZonesRevealed, 4);
  return 1;
}

//----- (0048AF34) --------------------------------------------------------
void __fastcall CSaveGarage::CopyGarageIntoSaveGarage(CSaveGarage *this, CGarage *pGarage)
{
  this->Type = pGarage->Type;
  this->State = pGarage->State;
  this->Flags = pGarage->Flags;
  this->BaseX = pGarage->BaseX;
  this->BaseY = pGarage->BaseY;
  this->BaseZ = pGarage->BaseZ;
  this->Delta1X = pGarage->Delta1X;
  this->Delta1Y = pGarage->Delta1Y;
  this->Delta2X = pGarage->Delta2X;
  this->Delta2Y = pGarage->Delta2Y;
  this->CeilingZ = pGarage->CeilingZ;
  this->Delta1Length = pGarage->Delta1Length;
  this->Delta2Length = pGarage->Delta2Length;
  this->MinX = pGarage->MinX;
  this->MaxX = pGarage->MaxX;
  this->MinY = pGarage->MinY;
  this->MaxY = pGarage->MaxY;
  this->Openness = pGarage->Openness;
  this->TimeOfNextEvent = pGarage->TimeOfNextEvent;
  strcpy((char *)this->Name, (const char *)pGarage->Name);
  this->OriginalType = pGarage->OriginalType;
}

//----- (0048AFA4) --------------------------------------------------------
void __fastcall CSaveGarage::CopyGarageOutOfSaveGarage(CSaveGarage *this, CGarage *pGarage)
{
  pGarage->Type = this->Type;
  pGarage->State = this->State;
  pGarage->Flags = this->Flags;
  pGarage->BaseX = this->BaseX;
  pGarage->BaseY = this->BaseY;
  pGarage->BaseZ = this->BaseZ;
  pGarage->Delta1X = this->Delta1X;
  pGarage->Delta1Y = this->Delta1Y;
  pGarage->Delta2X = this->Delta2X;
  pGarage->Delta2Y = this->Delta2Y;
  pGarage->CeilingZ = this->CeilingZ;
  pGarage->Delta1Length = this->Delta1Length;
  pGarage->Delta2Length = this->Delta2Length;
  pGarage->MinX = this->MinX;
  pGarage->MaxX = this->MaxX;
  pGarage->MinY = this->MinY;
  pGarage->MaxY = this->MaxY;
  pGarage->Openness = this->Openness;
  *(_QWORD *)&pGarage->TimeOfNextEvent = this->TimeOfNextEvent;
  strcpy((char *)pGarage->Name, (const char *)this->Name);
  pGarage->OriginalType = this->OriginalType;
}

//----- (0048B018) --------------------------------------------------------
int CGarages::Save()
{
  _DWORD *v0; // r4
  _DWORD *v1; // r4
  _DWORD *v2; // r4
  _DWORD *v3; // r4
  _DWORD *v4; // r4
  _DWORD *v5; // r4
  _DWORD *v6; // r4
  _DWORD *v7; // r4
  _DWORD *v8; // r4
  int i; // r5
  _QWORD *v10; // r4
  __int64 v11; // d16
  __int64 v12; // d17
  __int64 v13; // d20
  __int64 v14; // d21
  __int64 v15; // d23
  __int64 v16; // d18
  __int64 v17; // d19
  int j; // r5
  _QWORD *v19; // r4
  __int64 v20; // d16
  __int64 v21; // d17
  __int64 v22; // d20
  __int64 v23; // d21
  __int64 v24; // d23
  __int64 v25; // d18
  __int64 v26; // d19
  int k; // r5
  _QWORD *v28; // r4
  __int64 v29; // d16
  __int64 v30; // d17
  __int64 v31; // d20
  __int64 v32; // d21
  __int64 v33; // d23
  __int64 v34; // d18
  __int64 v35; // d19
  int m; // r5
  _QWORD *v37; // r4
  __int64 v38; // d16
  __int64 v39; // d17
  __int64 v40; // d20
  __int64 v41; // d21
  __int64 v42; // d23
  __int64 v43; // d18
  __int64 v44; // d19
  UInt32 v45; // r8
  CGarage *v46; // r4
  __int64 v47; // d17
  __int64 v48; // d17
  __int64 v49; // d17
  void *v50; // r6
  _DWORD v52[20]; // [sp+8h] [bp-70h] BYREF

  CGarages::CloseHideOutGaragesBeforeSave();
  v0 = malloc(4u);
  *v0 = CGarages::NumGarages;
  CGenericGameStorage::_SaveDataToWorkBuffer(v0, 4);
  free(v0);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CGarages::BombsAreFree, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CGarages::RespraysAreFree, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CGarages::NoResprays, 1);
  v1 = malloc(4u);
  *v1 = CGarages::CarsCollected;
  CGenericGameStorage::_SaveDataToWorkBuffer(v1, 4);
  free(v1);
  v2 = malloc(4u);
  *v2 = CGarages::BankVansCollected;
  CGenericGameStorage::_SaveDataToWorkBuffer(v2, 4);
  free(v2);
  v3 = malloc(4u);
  *v3 = CGarages::PoliceCarsCollected;
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 4);
  free(v3);
  v4 = malloc(4u);
  *v4 = CGarages::CarTypesCollected[0];
  CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
  free(v4);
  v5 = malloc(4u);
  *v5 = CGarages::CarTypesCollected[1];
  CGenericGameStorage::_SaveDataToWorkBuffer(v5, 4);
  free(v5);
  v6 = malloc(4u);
  *v6 = CGarages::CarTypesCollected[2];
  CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
  free(v6);
  v7 = malloc(4u);
  *v7 = CGarages::CarTypesCollected[3];
  CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
  free(v7);
  v8 = malloc(4u);
  *v8 = CGarages::LastTimeHelpMessage;
  CGenericGameStorage::_SaveDataToWorkBuffer(v8, 4);
  free(v8);
  for ( i = 0; i != 20; ++i )
  {
    v10 = malloc(0x40u);
    v11 = *(_QWORD *)&CGarages::aCarsInSafeHouse[i][0].CoorX;
    v12 = *(_QWORD *)&CGarages::aCarsInSafeHouse[i][0].CoorZ;
    v13 = *(_QWORD *)&CGarages::aCarsInSafeHouse[i][0].Bits;
    v14 = *(_QWORD *)&CGarages::aCarsInSafeHouse[i][0].CarMods[2];
    v15 = *(_QWORD *)&CGarages::aCarsInSafeHouse[i][0].Comp2;
    v16 = *(_QWORD *)&CGarages::aCarsInSafeHouse[i][0].CarMods[6];
    v17 = *(_QWORD *)&CGarages::aCarsInSafeHouse[i][0].CarMods[10];
    v10[6] = *(_QWORD *)&CGarages::aCarsInSafeHouse[i][0].CarMods[14];
    v10[7] = v15;
    v10[4] = v16;
    v10[5] = v17;
    *v10 = v11;
    v10[1] = v12;
    v10[2] = v13;
    v10[3] = v14;
    CGenericGameStorage::_SaveDataToWorkBuffer(v10, 64);
    free(v10);
  }
  for ( j = 1; j != 81; j += 4 )
  {
    v19 = malloc(0x40u);
    v20 = *(_QWORD *)&CGarages::aCarsInSafeHouse[0][j].CoorX;
    v21 = *(_QWORD *)&CGarages::aCarsInSafeHouse[0][j].CoorZ;
    v22 = *(_QWORD *)&CGarages::aCarsInSafeHouse[0][j].Bits;
    v23 = *(_QWORD *)&CGarages::aCarsInSafeHouse[0][j].CarMods[2];
    v24 = *(_QWORD *)&CGarages::aCarsInSafeHouse[0][j].Comp2;
    v25 = *(_QWORD *)&CGarages::aCarsInSafeHouse[0][j].CarMods[6];
    v26 = *(_QWORD *)&CGarages::aCarsInSafeHouse[0][j].CarMods[10];
    v19[6] = *(_QWORD *)&CGarages::aCarsInSafeHouse[0][j].CarMods[14];
    v19[7] = v24;
    v19[4] = v25;
    v19[5] = v26;
    *v19 = v20;
    v19[1] = v21;
    v19[2] = v22;
    v19[3] = v23;
    CGenericGameStorage::_SaveDataToWorkBuffer(v19, 64);
    free(v19);
  }
  for ( k = 2; k != 82; k += 4 )
  {
    v28 = malloc(0x40u);
    v29 = *(_QWORD *)&CGarages::aCarsInSafeHouse[0][k].CoorX;
    v30 = *(_QWORD *)&CGarages::aCarsInSafeHouse[0][k].CoorZ;
    v31 = *(_QWORD *)&CGarages::aCarsInSafeHouse[0][k].Bits;
    v32 = *(_QWORD *)&CGarages::aCarsInSafeHouse[0][k].CarMods[2];
    v33 = *(_QWORD *)&CGarages::aCarsInSafeHouse[0][k].Comp2;
    v34 = *(_QWORD *)&CGarages::aCarsInSafeHouse[0][k].CarMods[6];
    v35 = *(_QWORD *)&CGarages::aCarsInSafeHouse[0][k].CarMods[10];
    v28[6] = *(_QWORD *)&CGarages::aCarsInSafeHouse[0][k].CarMods[14];
    v28[7] = v33;
    v28[4] = v34;
    v28[5] = v35;
    *v28 = v29;
    v28[1] = v30;
    v28[2] = v31;
    v28[3] = v32;
    CGenericGameStorage::_SaveDataToWorkBuffer(v28, 64);
    free(v28);
  }
  for ( m = 3; m != 83; m += 4 )
  {
    v37 = malloc(0x40u);
    v38 = *(_QWORD *)&CGarages::aCarsInSafeHouse[0][m].CoorX;
    v39 = *(_QWORD *)&CGarages::aCarsInSafeHouse[0][m].CoorZ;
    v40 = *(_QWORD *)&CGarages::aCarsInSafeHouse[0][m].Bits;
    v41 = *(_QWORD *)&CGarages::aCarsInSafeHouse[0][m].CarMods[2];
    v42 = *(_QWORD *)&CGarages::aCarsInSafeHouse[0][m].Comp2;
    v43 = *(_QWORD *)&CGarages::aCarsInSafeHouse[0][m].CarMods[6];
    v44 = *(_QWORD *)&CGarages::aCarsInSafeHouse[0][m].CarMods[10];
    v37[6] = *(_QWORD *)&CGarages::aCarsInSafeHouse[0][m].CarMods[14];
    v37[7] = v42;
    v37[4] = v43;
    v37[5] = v44;
    *v37 = v38;
    v37[1] = v39;
    v37[2] = v40;
    v37[3] = v41;
    CGenericGameStorage::_SaveDataToWorkBuffer(v37, 64);
    free(v37);
  }
  if ( CGarages::NumGarages )
  {
    v45 = 0;
    v46 = CGarages::aGarages;
    do
    {
      LOWORD(v52[0]) = *(_WORD *)&v46->Type;
      BYTE2(v52[0]) = v46->Flags;
      v47 = *(_QWORD *)&v46->BaseZ;
      *(_QWORD *)&v52[1] = *(_QWORD *)&v46->BaseX;
      *(_QWORD *)&v52[3] = v47;
      v48 = *(_QWORD *)&v46->Delta2Y;
      *(_QWORD *)&v52[5] = *(_QWORD *)&v46->Delta1Y;
      *(_QWORD *)&v52[7] = v48;
      v49 = *(_QWORD *)&v46->MinX;
      *(_QWORD *)&v52[9] = *(_QWORD *)&v46->Delta1Length;
      *(_QWORD *)&v52[11] = v49;
      v52[13] = LODWORD(v46->MinY);
      v52[14] = LODWORD(v46->MaxY);
      v52[15] = LODWORD(v46->Openness);
      v52[16] = v46->TimeOfNextEvent;
      strcpy((char *)&v52[17], (const char *)v46->Name);
      LOBYTE(v52[19]) = v46->OriginalType;
      v50 = malloc(0x50u);
      qmemcpy(v50, v52, 0x50u);
      CGenericGameStorage::_SaveDataToWorkBuffer(v50, 80);
      free(v50);
      ++v45;
      ++v46;
    }
    while ( v45 < CGarages::NumGarages );
  }
  return 1;
}

//----- (0048B408) --------------------------------------------------------
int CGarages::Load()
{
  int i; // r5
  UInt32 v1; // r8
  CGarage *v2; // r6
  __int64 v3; // d16
  __int64 v4; // d17
  __int64 v5; // d17
  __int64 v6; // d17
  char v8[4]; // [sp+0h] [bp-70h] BYREF
  __int64 v9; // [sp+4h] [bp-6Ch]
  __int64 v10; // [sp+Ch] [bp-64h]
  __int64 v11; // [sp+14h] [bp-5Ch]
  __int64 v12; // [sp+1Ch] [bp-54h]
  __int64 v13; // [sp+24h] [bp-4Ch]
  __int64 v14; // [sp+2Ch] [bp-44h]
  float v15; // [sp+34h] [bp-3Ch]
  float v16; // [sp+38h] [bp-38h]
  float v17; // [sp+3Ch] [bp-34h]
  unsigned int v18; // [sp+40h] [bp-30h]
  char v19[12]; // [sp+44h] [bp-2Ch] BYREF

  CGarages::CloseHideOutGaragesBeforeSave();
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::NumGarages, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::BombsAreFree, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::RespraysAreFree, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::NoResprays, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::CarsCollected, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::BankVansCollected, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::PoliceCarsCollected, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(CGarages::CarTypesCollected, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::CarTypesCollected[1], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::CarTypesCollected[2], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::CarTypesCollected[3], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::LastTimeHelpMessage, 4);
  for ( i = 0; i != 4; ++i )
  {
    CGenericGameStorage::_LoadDataFromWorkBuffer((char *)CGarages::aCarsInSafeHouse + i * 64, 64);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::aCarsInSafeHouse[1][i], 64);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::aCarsInSafeHouse[2][i], 64);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::aCarsInSafeHouse[3][i], 64);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::aCarsInSafeHouse[4][i], 64);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::aCarsInSafeHouse[5][i], 64);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::aCarsInSafeHouse[6][i], 64);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::aCarsInSafeHouse[7][i], 64);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::aCarsInSafeHouse[8][i], 64);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::aCarsInSafeHouse[9][i], 64);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::aCarsInSafeHouse[10][i], 64);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::aCarsInSafeHouse[11][i], 64);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::aCarsInSafeHouse[12][i], 64);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::aCarsInSafeHouse[13][i], 64);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::aCarsInSafeHouse[14][i], 64);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::aCarsInSafeHouse[15][i], 64);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::aCarsInSafeHouse[16][i], 64);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::aCarsInSafeHouse[17][i], 64);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::aCarsInSafeHouse[18][i], 64);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CGarages::aCarsInSafeHouse[19][i], 64);
  }
  if ( CGarages::NumGarages )
  {
    v1 = 0;
    v2 = CGarages::aGarages;
    do
    {
      CGenericGameStorage::_LoadDataFromWorkBuffer(v8, 80);
      v2->Type = v8[0];
      v2->State = v8[1];
      v3 = v9;
      v4 = v10;
      v2->Flags = (CGarageFlags)v8[2];
      *(_QWORD *)&v2->BaseX = v3;
      *(_QWORD *)&v2->BaseZ = v4;
      v5 = v12;
      *(_QWORD *)&v2->Delta1Y = v11;
      *(_QWORD *)&v2->Delta2Y = v5;
      v6 = v14;
      *(_QWORD *)&v2->Delta1Length = v13;
      *(_QWORD *)&v2->MinX = v6;
      v2->MinY = v15;
      v2->MaxY = v16;
      v2->Openness = v17;
      *(_QWORD *)&v2->TimeOfNextEvent = v18;
      strcpy((char *)v2->Name, v19);
      ++v1;
      v2->OriginalType = v19[8];
      ++v2;
    }
    while ( v1 < CGarages::NumGarages );
  }
  CGarages::MessageStartTime = 0;
  CGarages::MessageEndTime = 0;
  CGarages::bCamShouldBeOutside = 0;
  return 1;
}

//----- (0048B6A0) --------------------------------------------------------
void __fastcall CScriptResourceManager::Save(CScriptResourceManager *this)
{
  int v2; // r1
  int v3; // r6
  CRunningScript *pUsedBy; // r2
  bool v5; // zf
  _WORD *v6; // r5
  CRunningScript **p_pUsedBy; // r6
  int i; // r9
  _WORD *v9; // r4
  _WORD *v10; // r5
  _DWORD *v11; // r4
  _WORD *v12; // r4
  int v13; // r0
  unsigned __int8 *m_modelName; // r8
  int32 v15; // r5
  _DWORD *v16; // r4

  v2 = 0;
  v3 = 0;
  do
  {
    if ( this->ScriptResources[v2].ResourceType )
    {
      pUsedBy = this->ScriptResources[v2].pUsedBy;
      v5 = pUsedBy->bIsThisAStreamedScript == 0;
      if ( !pUsedBy->bIsThisAStreamedScript )
        v5 = (unsigned __int8)pUsedBy->ScriptBrainType == 255;
      if ( v5 )
      {
        ++v3;
      }
      else if ( SaveStreamedScripts )
      {
        ++v3;
      }
    }
    ++v2;
  }
  while ( v2 != 75 );
  v6 = malloc(2u);
  *v6 = v3;
  CGenericGameStorage::_SaveDataToWorkBuffer(v6, 2);
  free(v6);
  if ( (_WORD)v3 )
  {
    p_pUsedBy = &this->ScriptResources[0].pUsedBy;
    for ( i = 0; i != 75; ++i )
    {
      if ( *((_WORD *)p_pUsedBy + 2) )
      {
        if ( (*p_pUsedBy)->bIsThisAStreamedScript )
        {
          if ( SaveStreamedScripts )
            goto LABEL_18;
        }
        else if ( (unsigned __int8)(*p_pUsedBy)->ScriptBrainType == 255 || SaveStreamedScripts )
        {
LABEL_18:
          v9 = malloc(2u);
          *v9 = i;
          CGenericGameStorage::_SaveDataToWorkBuffer(v9, 2);
          free(v9);
          LOWORD(v9) = CTheScripts::GetScriptIndexFromPointer(*p_pUsedBy);
          v10 = malloc(2u);
          *v10 = (_WORD)v9;
          CGenericGameStorage::_SaveDataToWorkBuffer(v10, 2);
          free(v10);
          v11 = malloc(4u);
          *v11 = *(p_pUsedBy - 1);
          CGenericGameStorage::_SaveDataToWorkBuffer(v11, 4);
          free(v11);
          v12 = malloc(2u);
          *v12 = *((_WORD *)p_pUsedBy + 2);
          CGenericGameStorage::_SaveDataToWorkBuffer(v12, 2);
          free(v12);
          if ( *((_WORD *)p_pUsedBy + 2) == 2 )
          {
            v13 = (int)*(p_pUsedBy - 1);
            if ( (unsigned int)(v13 - 290) <= 9 )
            {
              m_modelName = CModelInfo::ms_modelInfoPtrs[v13]->m_modelName;
              v15 = strlen((const char *)m_modelName) + 1;
              v16 = malloc(4u);
              *v16 = v15;
              CGenericGameStorage::_SaveDataToWorkBuffer(v16, 4);
              free(v16);
              CGenericGameStorage::_SaveDataToWorkBuffer(m_modelName, v15);
            }
          }
        }
      }
      p_pUsedBy += 3;
    }
  }
}

//----- (0048B818) --------------------------------------------------------
void __fastcall CScriptResourceManager::Load(CScriptResourceManager *this)
{
  int i; // r5
  script_resource_struct *v3; // r0
  script_resource_struct *v4; // r0
  int ResourceType; // r1
  int32 v6; // r1
  int32 ResourceIndex; // r0
  int32 SizeOfData; // [sp+4h] [bp-84h] BYREF
  unsigned __int16 v9; // [sp+Ah] [bp-7Eh] BYREF
  unsigned __int16 v10; // [sp+Ch] [bp-7Ch] BYREF
  unsigned __int16 pData; // [sp+Eh] [bp-7Ah] BYREF
  unsigned __int8 v12[68]; // [sp+10h] [bp-78h] BYREF

  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
  if ( pData )
  {
    for ( i = 0; (unsigned __int16)i < (unsigned int)pData; ++i )
    {
      CGenericGameStorage::_LoadDataFromWorkBuffer(&v10, 2);
      CGenericGameStorage::_LoadDataFromWorkBuffer(&v9, 2);
      v3 = &this->ScriptResources[v10];
      v3->pUsedBy = &CTheScripts::ScriptsArray[v9];
      CGenericGameStorage::_LoadDataFromWorkBuffer(v3, 4);
      CGenericGameStorage::_LoadDataFromWorkBuffer(&this->ScriptResources[v10].ResourceType, 2);
      v4 = &this->ScriptResources[v10];
      ResourceType = v4->ResourceType;
      if ( ResourceType == 2 )
      {
        ResourceIndex = v4->ResourceIndex;
        if ( (unsigned int)(ResourceIndex - 290) > 9 )
        {
          v6 = 12;
          goto LABEL_9;
        }
        memset(v12, 0, 64);
        CGenericGameStorage::_LoadDataFromWorkBuffer(&SizeOfData, 4);
        CGenericGameStorage::_LoadDataFromWorkBuffer(v12, SizeOfData);
        CStreaming::RequestSpecialChar(this->ScriptResources[v10].ResourceIndex - 290, v12, 12);
      }
      else if ( ResourceType == 1 )
      {
        v6 = 4;
        ResourceIndex = v4->ResourceIndex + 25575;
LABEL_9:
        CStreaming::RequestModel(ResourceIndex, v6);
      }
    }
  }
  CStreaming::LoadAllRequestedModels(0);
}

//----- (0048B954) --------------------------------------------------------
void CTheScripts::Save()
{
  UInt8 *v0; // r4
  int32 v1; // r6
  _DWORD *v2; // r5
  int32 v3; // r1
  bool v4; // cc
  int i; // r5
  _QWORD *v6; // r4
  __int64 v7; // d17
  _DWORD *v8; // r4
  _DWORD *v9; // r4
  int v10; // r5
  building_swap_struct *v11; // r11
  CBuilding *pBuilding; // r0
  int v13; // r9
  int v14; // r8
  _DWORD *v15; // r4
  _DWORD *v16; // r4
  _DWORD *v17; // r4
  _DWORD *v18; // r4
  int j; // r5
  CEntity *pEntity; // r0
  int v21; // r1
  CBuildingPool *v22; // r1
  int v23; // r0
  int v24; // r1
  _DWORD *v25; // r4
  _DWORD *v26; // r4
  int k; // r5
  _DWORD *v28; // r4
  _DWORD *v29; // r4
  Int32 Object1ID; // r0
  _DWORD *v31; // r4
  Int32 v32; // r0
  _DWORD *v33; // r4
  Int32 v34; // r0
  _DWORD *v35; // r4
  Int32 v36; // r0
  _DWORD *v37; // r4
  Int32 v38; // r0
  _DWORD *v39; // r4
  Int32 v40; // r0
  _DWORD *v41; // r4
  Int32 v42; // r0
  _DWORD *v43; // r4
  Int32 v44; // r0
  _DWORD *v45; // r4
  Int32 v46; // r0
  _DWORD *v47; // r4
  Int32 v48; // r0
  _QWORD *v49; // r4
  __int64 v50; // d17
  _QWORD *v51; // r4
  __int64 v52; // d17
  _QWORD *v53; // r4
  __int64 v54; // d17
  _QWORD *v55; // r4
  __int64 v56; // d17
  _QWORD *v57; // r4
  __int64 v58; // d17
  _QWORD *v59; // r4
  __int64 v60; // d17
  _QWORD *v61; // r4
  __int64 v62; // d17
  _QWORD *v63; // r4
  __int64 v64; // d17
  _DWORD *v65; // r4
  _DWORD *v66; // r4
  _WORD *v67; // r4
  _WORD *v68; // r4
  _DWORD *v69; // r4
  CRunningScript *v70; // r0
  int v71; // r5
  bool v72; // zf
  _DWORD *v73; // r4
  CRunningScript *v74; // r0
  CRunningScript *v75; // r4
  bool v76; // r6
  __int16 v77; // r2
  __int16 v78; // r9
  _WORD *v79; // r5
  _DWORD *v80; // r5
  int v81; // r10
  UInt16 ScriptIndexFromPointer; // r6
  _WORD *v83; // r8
  Int32 StreamedScriptWithThisStartAddress; // r6
  _DWORD *v85; // r5
  Int32 *v86; // r5
  CRunningScript *v87; // r5
  int v88; // r6
  _DWORD *v89; // r5
  UInt8 *v90; // r6
  _DWORD *v91; // r5
  UInt8 *v92; // r6
  _DWORD *v93; // r5
  UInt8 *v94; // r6
  _DWORD *v95; // r5
  UInt8 *v96; // r6
  _DWORD *v97; // r5
  UInt8 *v98; // r6
  _DWORD *v99; // r5
  UInt8 *v100; // r6
  _DWORD *v101; // r5
  UInt8 *v102; // r6
  _DWORD *v103; // r5
  UInt8 *v104; // r6
  _DWORD *v105; // r5
  _DWORD *v106; // r4
  _DWORD *v107; // r4
  unsigned __int8 pStringToFill[8]; // [sp+20h] [bp-28h] BYREF

  v0 = CTheScripts::ScriptSpace;
  v1 = *(_DWORD *)&CTheScripts::ScriptSpace[3];
  v2 = malloc(4u);
  *v2 = v1;
  CGenericGameStorage::_SaveDataToWorkBuffer(v2, 4);
  free(v2);
  if ( v1 < 65001 )
  {
    v3 = v1;
  }
  else
  {
    v0 = CTheScripts::ScriptSpace;
    do
    {
      CGenericGameStorage::_SaveDataToWorkBuffer(v0, 65000);
      v3 = v1 - 65000;
      v0 += 65000;
      v4 = v1 <= (int)&elf_hash_chain[16026];
      v1 -= 65000;
    }
    while ( !v4 );
  }
  CGenericGameStorage::_SaveDataToWorkBuffer(v0, v3);
  for ( i = 0; i != 70; ++i )
  {
    v6 = malloc(0x14u);
    v7 = *(_QWORD *)&CTheScripts::ScriptsForBrains.ScriptBrainArray[i].ObjectBrainActivationRange;
    *v6 = *(_QWORD *)&CTheScripts::ScriptsForBrains.ScriptBrainArray[i].StreamedScriptIndex;
    v6[1] = v7;
    *((_DWORD *)v6 + 4) = CTheScripts::ScriptsForBrains.ScriptBrainArray[i]._anon_0.RandomPedData.Pad;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 20);
    free(v6);
  }
  v8 = malloc(4u);
  *v8 = CTheScripts::OnAMissionFlag;
  CGenericGameStorage::_SaveDataToWorkBuffer(v8, 4);
  free(v8);
  v9 = malloc(4u);
  *v9 = CTheScripts::LastMissionPassedTime;
  CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
  free(v9);
  v10 = 0;
  v11 = CTheScripts::BuildingSwapArray;
  do
  {
    pBuilding = CTheScripts::BuildingSwapArray[v10].pBuilding;
    if ( pBuilding )
    {
      v13 = 2;
      v14 = -286331153 * (((char *)pBuilding - (char *)CPools::ms_pBuildingPool->m_aStorage) >> 2) + 1;
    }
    else
    {
      v13 = 0;
      v14 = 0;
    }
    v15 = malloc(4u);
    *v15 = v13;
    CGenericGameStorage::_SaveDataToWorkBuffer(v15, 4);
    free(v15);
    v16 = malloc(4u);
    *v16 = v14;
    CGenericGameStorage::_SaveDataToWorkBuffer(v16, 4);
    free(v16);
    v17 = malloc(4u);
    *v17 = CTheScripts::BuildingSwapArray[v10].NewModelIndex;
    CGenericGameStorage::_SaveDataToWorkBuffer(v17, 4);
    free(v17);
    v18 = malloc(4u);
    *v18 = CTheScripts::BuildingSwapArray[v10].OldModelIndex;
    CGenericGameStorage::_SaveDataToWorkBuffer(v18, 4);
    free(v18);
    ++v10;
  }
  while ( v10 != 25 );
  for ( j = 0; j != 20; ++j )
  {
    pEntity = CTheScripts::InvisibilitySettingArray[j].pEntity;
    if ( !pEntity )
    {
      v13 = 0;
      v11 = 0;
      goto LABEL_25;
    }
    v21 = *(_BYTE *)&pEntity->m_info & 7;
    switch ( v21 )
    {
      case 5:
        v22 = (CBuildingPool *)CPools::ms_pDummyPool;
        v13 = 4;
        break;
      case 4:
        v13 = 3;
        v23 = (char *)pEntity - (char *)CPools::ms_pObjectPool->m_aStorage;
        v24 = -654471207;
        goto LABEL_24;
      case 1:
        v22 = CPools::ms_pBuildingPool;
        v13 = 2;
        break;
      default:
        goto LABEL_25;
    }
    v23 = (char *)pEntity - (char *)v22->m_aStorage;
    v24 = -286331153;
LABEL_24:
    v11 = (building_swap_struct *)((v23 >> 2) * v24 + 1);
LABEL_25:
    v25 = malloc(4u);
    *v25 = v13;
    CGenericGameStorage::_SaveDataToWorkBuffer(v25, 4);
    free(v25);
    v26 = malloc(4u);
    *v26 = v11;
    CGenericGameStorage::_SaveDataToWorkBuffer(v26, 4);
    free(v26);
  }
  for ( k = 0; k != 20; ++k )
  {
    v28 = malloc(4u);
    *v28 = CTheScripts::VehicleModelsBlockedByScript[k];
    CGenericGameStorage::_SaveDataToWorkBuffer(v28, 4);
    free(v28);
  }
  v29 = malloc(8u);
  Object1ID = CTheScripts::ScriptConnectLodsObjects[0].Object1ID;
  v29[1] = CTheScripts::ScriptConnectLodsObjects[0].Object2ID;
  *v29 = Object1ID;
  CGenericGameStorage::_SaveDataToWorkBuffer(v29, 8);
  free(v29);
  v31 = malloc(8u);
  v32 = CTheScripts::ScriptConnectLodsObjects[1].Object1ID;
  v31[1] = CTheScripts::ScriptConnectLodsObjects[1].Object2ID;
  *v31 = v32;
  CGenericGameStorage::_SaveDataToWorkBuffer(v31, 8);
  free(v31);
  v33 = malloc(8u);
  v34 = CTheScripts::ScriptConnectLodsObjects[2].Object1ID;
  v33[1] = CTheScripts::ScriptConnectLodsObjects[2].Object2ID;
  *v33 = v34;
  CGenericGameStorage::_SaveDataToWorkBuffer(v33, 8);
  free(v33);
  v35 = malloc(8u);
  v36 = CTheScripts::ScriptConnectLodsObjects[3].Object1ID;
  v35[1] = CTheScripts::ScriptConnectLodsObjects[3].Object2ID;
  *v35 = v36;
  CGenericGameStorage::_SaveDataToWorkBuffer(v35, 8);
  free(v35);
  v37 = malloc(8u);
  v38 = CTheScripts::ScriptConnectLodsObjects[4].Object1ID;
  v37[1] = CTheScripts::ScriptConnectLodsObjects[4].Object2ID;
  *v37 = v38;
  CGenericGameStorage::_SaveDataToWorkBuffer(v37, 8);
  free(v37);
  v39 = malloc(8u);
  v40 = CTheScripts::ScriptConnectLodsObjects[5].Object1ID;
  v39[1] = CTheScripts::ScriptConnectLodsObjects[5].Object2ID;
  *v39 = v40;
  CGenericGameStorage::_SaveDataToWorkBuffer(v39, 8);
  free(v39);
  v41 = malloc(8u);
  v42 = CTheScripts::ScriptConnectLodsObjects[6].Object1ID;
  v41[1] = CTheScripts::ScriptConnectLodsObjects[6].Object2ID;
  *v41 = v42;
  CGenericGameStorage::_SaveDataToWorkBuffer(v41, 8);
  free(v41);
  v43 = malloc(8u);
  v44 = CTheScripts::ScriptConnectLodsObjects[7].Object1ID;
  v43[1] = CTheScripts::ScriptConnectLodsObjects[7].Object2ID;
  *v43 = v44;
  CGenericGameStorage::_SaveDataToWorkBuffer(v43, 8);
  free(v43);
  v45 = malloc(8u);
  v46 = CTheScripts::ScriptConnectLodsObjects[8].Object1ID;
  v45[1] = CTheScripts::ScriptConnectLodsObjects[8].Object2ID;
  *v45 = v46;
  CGenericGameStorage::_SaveDataToWorkBuffer(v45, 8);
  free(v45);
  v47 = malloc(8u);
  v48 = CTheScripts::ScriptConnectLodsObjects[9].Object1ID;
  v47[1] = CTheScripts::ScriptConnectLodsObjects[9].Object2ID;
  *v47 = v48;
  CGenericGameStorage::_SaveDataToWorkBuffer(v47, 8);
  free(v47);
  v49 = malloc(0x14u);
  v50 = *(_QWORD *)&CTheScripts::ScriptAttachedAnimGroups[0].AnimGroupName[4];
  *v49 = *(_QWORD *)&CTheScripts::ScriptAttachedAnimGroups[0].CharModelIndex;
  v49[1] = v50;
  *((_DWORD *)v49 + 4) = *(_DWORD *)&CTheScripts::ScriptAttachedAnimGroups[0].AnimGroupName[12];
  CGenericGameStorage::_SaveDataToWorkBuffer(v49, 20);
  free(v49);
  v51 = malloc(0x14u);
  v52 = *(_QWORD *)&CTheScripts::ScriptAttachedAnimGroups[1].AnimGroupName[4];
  *v51 = *(_QWORD *)&CTheScripts::ScriptAttachedAnimGroups[1].CharModelIndex;
  v51[1] = v52;
  *((_DWORD *)v51 + 4) = *(_DWORD *)&CTheScripts::ScriptAttachedAnimGroups[1].AnimGroupName[12];
  CGenericGameStorage::_SaveDataToWorkBuffer(v51, 20);
  free(v51);
  v53 = malloc(0x14u);
  v54 = *(_QWORD *)&CTheScripts::ScriptAttachedAnimGroups[2].AnimGroupName[4];
  *v53 = *(_QWORD *)&CTheScripts::ScriptAttachedAnimGroups[2].CharModelIndex;
  v53[1] = v54;
  *((_DWORD *)v53 + 4) = *(_DWORD *)&CTheScripts::ScriptAttachedAnimGroups[2].AnimGroupName[12];
  CGenericGameStorage::_SaveDataToWorkBuffer(v53, 20);
  free(v53);
  v55 = malloc(0x14u);
  v56 = *(_QWORD *)&CTheScripts::ScriptAttachedAnimGroups[3].AnimGroupName[4];
  *v55 = *(_QWORD *)&CTheScripts::ScriptAttachedAnimGroups[3].CharModelIndex;
  v55[1] = v56;
  *((_DWORD *)v55 + 4) = *(_DWORD *)&CTheScripts::ScriptAttachedAnimGroups[3].AnimGroupName[12];
  CGenericGameStorage::_SaveDataToWorkBuffer(v55, 20);
  free(v55);
  v57 = malloc(0x14u);
  v58 = *(_QWORD *)&CTheScripts::ScriptAttachedAnimGroups[4].AnimGroupName[4];
  *v57 = *(_QWORD *)&CTheScripts::ScriptAttachedAnimGroups[4].CharModelIndex;
  v57[1] = v58;
  *((_DWORD *)v57 + 4) = *(_DWORD *)&CTheScripts::ScriptAttachedAnimGroups[4].AnimGroupName[12];
  CGenericGameStorage::_SaveDataToWorkBuffer(v57, 20);
  free(v57);
  v59 = malloc(0x14u);
  v60 = *(_QWORD *)&CTheScripts::ScriptAttachedAnimGroups[5].AnimGroupName[4];
  *v59 = *(_QWORD *)&CTheScripts::ScriptAttachedAnimGroups[5].CharModelIndex;
  v59[1] = v60;
  *((_DWORD *)v59 + 4) = *(_DWORD *)&CTheScripts::ScriptAttachedAnimGroups[5].AnimGroupName[12];
  CGenericGameStorage::_SaveDataToWorkBuffer(v59, 20);
  free(v59);
  v61 = malloc(0x14u);
  v62 = *(_QWORD *)&CTheScripts::ScriptAttachedAnimGroups[6].AnimGroupName[4];
  *v61 = *(_QWORD *)&CTheScripts::ScriptAttachedAnimGroups[6].CharModelIndex;
  v61[1] = v62;
  *((_DWORD *)v61 + 4) = *(_DWORD *)&CTheScripts::ScriptAttachedAnimGroups[6].AnimGroupName[12];
  CGenericGameStorage::_SaveDataToWorkBuffer(v61, 20);
  free(v61);
  v63 = malloc(0x14u);
  v64 = *(_QWORD *)&CTheScripts::ScriptAttachedAnimGroups[7].AnimGroupName[4];
  *v63 = *(_QWORD *)&CTheScripts::ScriptAttachedAnimGroups[7].CharModelIndex;
  v63[1] = v64;
  *((_DWORD *)v63 + 4) = *(_DWORD *)&CTheScripts::ScriptAttachedAnimGroups[7].AnimGroupName[12];
  CGenericGameStorage::_SaveDataToWorkBuffer(v63, 20);
  free(v63);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CTheScripts::bUsingAMultiScriptFile, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CTheScripts::bPlayerHasMetDebbieHarry, 1);
  v65 = malloc(4u);
  *v65 = CTheScripts::MainScriptSize;
  CGenericGameStorage::_SaveDataToWorkBuffer(v65, 4);
  free(v65);
  v66 = malloc(4u);
  *v66 = CTheScripts::LargestMissionScriptSize;
  CGenericGameStorage::_SaveDataToWorkBuffer(v66, 4);
  free(v66);
  v67 = malloc(2u);
  *v67 = CTheScripts::NumberOfMissionScripts;
  CGenericGameStorage::_SaveDataToWorkBuffer(v67, 2);
  free(v67);
  v68 = malloc(2u);
  *v68 = CTheScripts::NumberOfExclusiveMissionScripts;
  CGenericGameStorage::_SaveDataToWorkBuffer(v68, 2);
  free(v68);
  v69 = malloc(4u);
  *v69 = CTheScripts::LargestNumberOfMissionScriptLocalVariables;
  CGenericGameStorage::_SaveDataToWorkBuffer(v69, 4);
  free(v69);
  v70 = CTheScripts::pActiveScripts;
  if ( CTheScripts::pActiveScripts )
  {
    v71 = 0;
    do
    {
      v72 = v70->bIsThisAStreamedScript == 0;
      if ( !v70->bIsThisAStreamedScript )
        v72 = (unsigned __int8)v70->ScriptBrainType == 255;
      if ( v72 )
      {
        ++v71;
      }
      else if ( SaveStreamedScripts )
      {
        ++v71;
      }
      v70 = v70->pNext;
    }
    while ( v70 );
  }
  else
  {
    v71 = 0;
  }
  v73 = malloc(4u);
  *v73 = v71;
  CGenericGameStorage::_SaveDataToWorkBuffer(v73, 4);
  free(v73);
  v74 = CTheScripts::pActiveScripts;
  do
  {
    v75 = v74;
    v74 = v74->pNext;
  }
  while ( v74 );
  v76 = UseDataFence;
  if ( UseDataFence )
  {
    v77 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v78 = v77 + DataFence;
    v79 = malloc(2u);
    *v79 = v78;
    CGenericGameStorage::_SaveDataToWorkBuffer(v79, 2);
    free(v79);
    UseDataFence = v76;
  }
  v80 = malloc(4u);
  *v80 = SaveGameStateType;
  CGenericGameStorage::_SaveDataToWorkBuffer(v80, 4);
  free(v80);
  v81 = 0;
  IsMissionLoad = 0;
  IsMissionSave = 0;
  if ( v75 )
  {
    v81 = 0;
    do
    {
      if ( v75->bIsThisAStreamedScript )
      {
        if ( SaveStreamedScripts )
          goto LABEL_50;
      }
      else if ( (unsigned __int8)v75->ScriptBrainType == 255 || SaveStreamedScripts )
      {
LABEL_50:
        ScriptIndexFromPointer = CTheScripts::GetScriptIndexFromPointer(v75);
        if ( v75->IsThisAMissionScript )
        {
          ScriptIndexFromPointer |= 0x8000u;
          if ( SaveGameStateType == eCheckpointSave )
            IsMissionSave = 1;
          strncpy((char *)CurrentScriptName, (const char *)v75->ScriptName, 8u);
        }
        v83 = malloc(2u);
        *v83 = ScriptIndexFromPointer;
        CGenericGameStorage::_SaveDataToWorkBuffer(v83, 2);
        free(v83);
        if ( v75->bIsThisAStreamedScript )
          StreamedScriptWithThisStartAddress = CStreamedScripts::GetStreamedScriptWithThisStartAddress(
                                                 &CTheScripts::StreamedScripts,
                                                 v75->BaseAddressOfThisScript);
        else
          StreamedScriptWithThisStartAddress = -1;
        v85 = malloc(4u);
        *v85 = StreamedScriptWithThisStartAddress;
        CGenericGameStorage::_SaveDataToWorkBuffer(v85, 4);
        free(v85);
        if ( v75->IsThisAMissionScript )
        {
          CGenericGameStorage::_SaveDataToWorkBuffer(&CTheScripts::ScriptSpace[270000], 34500);
          CGenericGameStorage::_SaveDataToWorkBuffer(&CTheScripts::ScriptSpace[304500], 34500);
          v86 = (Int32 *)malloc(0x1000u);
          qmemcpy(v86, CTheScripts::LocalVariablesForCurrentMission, 0x1000u);
          CGenericGameStorage::_SaveDataToWorkBuffer(v86, 4096);
          free(v86);
          v81 = 1;
        }
        v87 = (CRunningScript *)malloc(0x100u);
        qmemcpy(v87, v75, sizeof(CRunningScript));
        CGenericGameStorage::_SaveDataToWorkBuffer(v87, 256);
        free(v87);
        v88 = v75->PCPointer - CTheScripts::ScriptSpace;
        v89 = malloc(4u);
        *v89 = v88;
        CGenericGameStorage::_SaveDataToWorkBuffer(v89, 4);
        free(v89);
        v90 = v75->PCStack[0];
        if ( v90 )
          v90 -= (int)CTheScripts::ScriptSpace;
        v91 = malloc(4u);
        *v91 = v90;
        CGenericGameStorage::_SaveDataToWorkBuffer(v91, 4);
        free(v91);
        v92 = v75->PCStack[1];
        if ( v92 )
          v92 -= (int)CTheScripts::ScriptSpace;
        v93 = malloc(4u);
        *v93 = v92;
        CGenericGameStorage::_SaveDataToWorkBuffer(v93, 4);
        free(v93);
        v94 = v75->PCStack[2];
        if ( v94 )
          v94 -= (int)CTheScripts::ScriptSpace;
        v95 = malloc(4u);
        *v95 = v94;
        CGenericGameStorage::_SaveDataToWorkBuffer(v95, 4);
        free(v95);
        v96 = v75->PCStack[3];
        if ( v96 )
          v96 -= (int)CTheScripts::ScriptSpace;
        v97 = malloc(4u);
        *v97 = v96;
        CGenericGameStorage::_SaveDataToWorkBuffer(v97, 4);
        free(v97);
        v98 = v75->PCStack[4];
        if ( v98 )
          v98 -= (int)CTheScripts::ScriptSpace;
        v99 = malloc(4u);
        *v99 = v98;
        CGenericGameStorage::_SaveDataToWorkBuffer(v99, 4);
        free(v99);
        v100 = v75->PCStack[5];
        if ( v100 )
          v100 -= (int)CTheScripts::ScriptSpace;
        v101 = malloc(4u);
        *v101 = v100;
        CGenericGameStorage::_SaveDataToWorkBuffer(v101, 4);
        free(v101);
        v102 = v75->PCStack[6];
        if ( v102 )
          v102 -= (int)CTheScripts::ScriptSpace;
        v103 = malloc(4u);
        *v103 = v102;
        CGenericGameStorage::_SaveDataToWorkBuffer(v103, 4);
        free(v103);
        v104 = v75->PCStack[7];
        if ( v104 )
          v104 -= (int)CTheScripts::ScriptSpace;
        v105 = malloc(4u);
        *v105 = v104;
        CGenericGameStorage::_SaveDataToWorkBuffer(v105, 4);
        free(v105);
      }
      v75 = v75->pPrevious;
    }
    while ( v75 );
  }
  CScriptResourceManager::Save(&CTheScripts::ScriptResourceManager);
  v106 = malloc(4u);
  *v106 = IsOddJob;
  CGenericGameStorage::_SaveDataToWorkBuffer(v106, 4);
  free(v106);
  if ( IsOddJob == 1 )
  {
    IsMissionLoad = 1;
    IsMissionSave = 1;
  }
  if ( v81 << 31 )
  {
    CText::GetNameOfLoadedMissionText(&TheText, pStringToFill);
    CGenericGameStorage::_SaveDataToWorkBuffer(pStringToFill, 8);
    v107 = malloc(4u);
    *v107 = missionReplaySetting;
    CGenericGameStorage::_SaveDataToWorkBuffer(v107, 4);
    free(v107);
  }
}
// 10168: using guessed type int elf_hash_chain[22025];
// 4A56C: using guessed type Elf32_Sym stru_4A56C;

//----- (0048C408) --------------------------------------------------------
void CTheScripts::Load()
{
  int32 v0; // r4
  UInt8 *v1; // r5
  int32 v2; // r0
  bool v3; // cc
  int v4; // r4
  int i; // r11
  CBuilding *v6; // r0
  int v7; // r1
  CBuilding *pBuilding; // r6
  CRunningScript *v9; // r0
  int v10; // r1
  bool v11; // r4
  int v12; // r11
  unsigned int v13; // r10
  UInt16 v14; // r1
  CRunningScript *started; // r0
  UInt8 *v16; // r0
  CRunningScript *v17; // r8
  __int64 v18; // kr00_8
  UInt8 *v19; // r0
  UInt8 *v20; // r0
  UInt8 *v21; // r0
  UInt8 *v22; // r0
  UInt8 *v23; // r0
  UInt8 *v24; // r0
  UInt8 *v25; // r0
  UInt8 *v26; // r0
  int32 v27; // [sp+2Ch] [bp-44h] BYREF
  UInt16 ScriptIndex; // [sp+32h] [bp-3Eh] BYREF
  UInt8 *v29; // [sp+34h] [bp-3Ch] BYREF
  char v30[6]; // [sp+38h] [bp-38h] BYREF
  char v31[2]; // [sp+3Eh] [bp-32h] BYREF
  char v32[4]; // [sp+40h] [bp-30h] BYREF
  int v33; // [sp+44h] [bp-2Ch] BYREF
  int v34; // [sp+48h] [bp-28h] BYREF
  unsigned int v35; // [sp+4Ch] [bp-24h] BYREF
  int32 pData[8]; // [sp+50h] [bp-20h] BYREF

  CTheScripts::Init();
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  v0 = pData[0];
  if ( pData[0] < 65001 )
  {
    v1 = CTheScripts::ScriptSpace;
  }
  else
  {
    v1 = CTheScripts::ScriptSpace;
    do
    {
      CGenericGameStorage::_LoadDataFromWorkBuffer(v1, 65000);
      v2 = v0 - 65000;
      v1 += 65000;
      v3 = v0 <= (int)&elf_hash_chain[16026];
      v0 -= 65000;
    }
    while ( !v3 );
    v0 = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(v1, v0);
  if ( (*(_DWORD *)&CTheScripts::ScriptSpace[1556] & 0x100002) != 0 )
    *(_DWORD *)&CTheScripts::ScriptSpace[1556] &= *(_DWORD *)&CTheScripts::ScriptSpace[1556] & 0x100000 ^ 0xFFFFFFFD;
  v4 = 0;
  *(_DWORD *)&CTheScripts::ScriptSpace[14368] = 0;
  do
  {
    CGenericGameStorage::_LoadDataFromWorkBuffer((char *)&CTheScripts::ScriptsForBrains + v4, 20);
    v4 += 20;
  }
  while ( v4 != 1400 );
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::OnAMissionFlag, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::LastMissionPassedTime, 4);
  for ( i = 0; i != 25; ++i )
  {
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v34, 4);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v33, 4);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::BuildingSwapArray[i].NewModelIndex, 4);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::BuildingSwapArray[i].OldModelIndex, 4);
    if ( v34 == 2 )
    {
      v7 = v33 - 1;
      v33 = v7;
      if ( (CPools::ms_pBuildingPool->m_aFlags[v7] & 0x80u) != 0 )
        v6 = 0;
      else
        v6 = (CBuilding *)CPools::ms_pBuildingPool->m_aStorage[v7];
    }
    else
    {
      if ( v34 == 1 )
      {
        --v33;
        goto LABEL_21;
      }
      if ( v34 )
        goto LABEL_21;
      v6 = 0;
    }
    CTheScripts::BuildingSwapArray[i].pBuilding = v6;
LABEL_21:
    pBuilding = CTheScripts::BuildingSwapArray[i].pBuilding;
    if ( pBuilding )
    {
      CWorld::Remove(CTheScripts::BuildingSwapArray[i].pBuilding);
      CBuilding::ReplaceWithNewModel(pBuilding, CTheScripts::BuildingSwapArray[i].NewModelIndex);
      CWorld::Add(pBuilding);
    }
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v34, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(v32, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v34, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(v32, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v34, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(v32, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v34, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(v32, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v34, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(v32, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v34, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(v32, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v34, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(v32, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v34, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(v32, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v34, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(v32, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v34, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(v32, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v34, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(v32, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v34, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(v32, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v34, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(v32, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v34, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(v32, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v34, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(v32, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v34, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(v32, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v34, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(v32, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v34, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(v32, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v34, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(v32, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v34, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(v32, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(CTheScripts::VehicleModelsBlockedByScript, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::VehicleModelsBlockedByScript[1], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::VehicleModelsBlockedByScript[2], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::VehicleModelsBlockedByScript[3], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::VehicleModelsBlockedByScript[4], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::VehicleModelsBlockedByScript[5], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::VehicleModelsBlockedByScript[6], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::VehicleModelsBlockedByScript[7], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::VehicleModelsBlockedByScript[8], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::VehicleModelsBlockedByScript[9], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::VehicleModelsBlockedByScript[10], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::VehicleModelsBlockedByScript[11], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::VehicleModelsBlockedByScript[12], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::VehicleModelsBlockedByScript[13], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::VehicleModelsBlockedByScript[14], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::VehicleModelsBlockedByScript[15], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::VehicleModelsBlockedByScript[16], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::VehicleModelsBlockedByScript[17], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::VehicleModelsBlockedByScript[18], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::VehicleModelsBlockedByScript[19], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(CTheScripts::ScriptConnectLodsObjects, 8);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::ScriptConnectLodsObjects[1], 8);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::ScriptConnectLodsObjects[2], 8);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::ScriptConnectLodsObjects[3], 8);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::ScriptConnectLodsObjects[4], 8);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::ScriptConnectLodsObjects[5], 8);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::ScriptConnectLodsObjects[6], 8);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::ScriptConnectLodsObjects[7], 8);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::ScriptConnectLodsObjects[8], 8);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::ScriptConnectLodsObjects[9], 8);
  CGenericGameStorage::_LoadDataFromWorkBuffer(CTheScripts::ScriptAttachedAnimGroups, 20);
  if ( CTheScripts::ScriptAttachedAnimGroups[0].CharModelIndex != -1 )
    CTheScripts::ScriptAttachAnimGroupToCharModel(
      CTheScripts::ScriptAttachedAnimGroups[0].CharModelIndex,
      CTheScripts::ScriptAttachedAnimGroups[0].AnimGroupName);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::ScriptAttachedAnimGroups[1], 20);
  if ( CTheScripts::ScriptAttachedAnimGroups[1].CharModelIndex != -1 )
    CTheScripts::ScriptAttachAnimGroupToCharModel(
      CTheScripts::ScriptAttachedAnimGroups[1].CharModelIndex,
      CTheScripts::ScriptAttachedAnimGroups[1].AnimGroupName);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::ScriptAttachedAnimGroups[2], 20);
  if ( CTheScripts::ScriptAttachedAnimGroups[2].CharModelIndex != -1 )
    CTheScripts::ScriptAttachAnimGroupToCharModel(
      CTheScripts::ScriptAttachedAnimGroups[2].CharModelIndex,
      CTheScripts::ScriptAttachedAnimGroups[2].AnimGroupName);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::ScriptAttachedAnimGroups[3], 20);
  if ( CTheScripts::ScriptAttachedAnimGroups[3].CharModelIndex != -1 )
    CTheScripts::ScriptAttachAnimGroupToCharModel(
      CTheScripts::ScriptAttachedAnimGroups[3].CharModelIndex,
      CTheScripts::ScriptAttachedAnimGroups[3].AnimGroupName);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::ScriptAttachedAnimGroups[4], 20);
  if ( CTheScripts::ScriptAttachedAnimGroups[4].CharModelIndex != -1 )
    CTheScripts::ScriptAttachAnimGroupToCharModel(
      CTheScripts::ScriptAttachedAnimGroups[4].CharModelIndex,
      CTheScripts::ScriptAttachedAnimGroups[4].AnimGroupName);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::ScriptAttachedAnimGroups[5], 20);
  if ( CTheScripts::ScriptAttachedAnimGroups[5].CharModelIndex != -1 )
    CTheScripts::ScriptAttachAnimGroupToCharModel(
      CTheScripts::ScriptAttachedAnimGroups[5].CharModelIndex,
      CTheScripts::ScriptAttachedAnimGroups[5].AnimGroupName);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::ScriptAttachedAnimGroups[6], 20);
  if ( CTheScripts::ScriptAttachedAnimGroups[6].CharModelIndex != -1 )
    CTheScripts::ScriptAttachAnimGroupToCharModel(
      CTheScripts::ScriptAttachedAnimGroups[6].CharModelIndex,
      CTheScripts::ScriptAttachedAnimGroups[6].AnimGroupName);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::ScriptAttachedAnimGroups[7], 20);
  if ( CTheScripts::ScriptAttachedAnimGroups[7].CharModelIndex != -1 )
    CTheScripts::ScriptAttachAnimGroupToCharModel(
      CTheScripts::ScriptAttachedAnimGroups[7].CharModelIndex,
      CTheScripts::ScriptAttachedAnimGroups[7].AnimGroupName);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::bUsingAMultiScriptFile, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::bPlayerHasMetDebbieHarry, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(v30, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(v30, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(v31, 2);
  CGenericGameStorage::_LoadDataFromWorkBuffer(v31, 2);
  CGenericGameStorage::_LoadDataFromWorkBuffer(v30, 4);
  v35 = 0;
  v9 = CTheScripts::pActiveScripts;
  if ( CTheScripts::pActiveScripts )
  {
    v10 = 1;
    do
    {
      v9 = v9->pNext;
      v35 = v10++;
    }
    while ( v9 );
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v35, 4);
  v11 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v29, 2);
    UseDataFence = v11;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&SaveGameStateType, 4);
  v12 = 0;
  IsMissionSave = 0;
  IsMissionLoad = 0;
  if ( v35 )
  {
    v13 = 0;
    v12 = 0;
    while ( 1 )
    {
      CGenericGameStorage::_LoadDataFromWorkBuffer(&ScriptIndex, 2);
      v27 = -1;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&v27, 4);
      v14 = ScriptIndex;
      if ( (ScriptIndex & 0x8000) != 0 )
        break;
      if ( v27 < 0 )
      {
        v16 = 0;
LABEL_57:
        started = CTheScripts::StartNewScript(v16, v14);
        goto LABEL_58;
      }
      started = CStreamedScripts::StartNewStreamedScript(&CTheScripts::StreamedScripts, v27);
LABEL_58:
      v17 = started;
      v18 = *(_QWORD *)&started->pNext;
      CGenericGameStorage::_LoadDataFromWorkBuffer(started, 256);
      if ( v17->IsThisAMissionScript )
      {
        v17->BaseAddressOfThisScript = &CTheScripts::ScriptSpace[270000];
        missionScript = v17;
        strncpy((char *)CurrentScriptName, (const char *)v17->ScriptName, 8u);
        v12 = 1;
      }
      *(_QWORD *)&v17->pNext = v18;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&v29, 4);
      v17->PCPointer = &CTheScripts::ScriptSpace[(_DWORD)v29];
      CGenericGameStorage::_LoadDataFromWorkBuffer(&v29, 4);
      v19 = v29;
      if ( v29 )
        v19 = &CTheScripts::ScriptSpace[(_DWORD)v29];
      v17->PCStack[0] = v19;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&v29, 4);
      v20 = v29;
      if ( v29 )
        v20 = &CTheScripts::ScriptSpace[(_DWORD)v29];
      v17->PCStack[1] = v20;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&v29, 4);
      v21 = v29;
      if ( v29 )
        v21 = &CTheScripts::ScriptSpace[(_DWORD)v29];
      v17->PCStack[2] = v21;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&v29, 4);
      v22 = v29;
      if ( v29 )
        v22 = &CTheScripts::ScriptSpace[(_DWORD)v29];
      v17->PCStack[3] = v22;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&v29, 4);
      v23 = v29;
      if ( v29 )
        v23 = &CTheScripts::ScriptSpace[(_DWORD)v29];
      v17->PCStack[4] = v23;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&v29, 4);
      v24 = v29;
      if ( v29 )
        v24 = &CTheScripts::ScriptSpace[(_DWORD)v29];
      v17->PCStack[5] = v24;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&v29, 4);
      v25 = v29;
      if ( v29 )
        v25 = &CTheScripts::ScriptSpace[(_DWORD)v29];
      v17->PCStack[6] = v25;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&v29, 4);
      v26 = v29;
      ++v13;
      if ( v29 )
        v26 = &CTheScripts::ScriptSpace[(_DWORD)v29];
      v17->PCStack[7] = v26;
      if ( v13 >= v35 )
        goto LABEL_77;
    }
    ScriptIndex &= ~0x8000u;
    if ( SaveGameStateType == eStartmissionSave )
    {
      skipMissionStartCount = 10;
LABEL_55:
      CTheScripts::bAlreadyRunningAMissionScript = 1;
    }
    else if ( SaveGameStateType == eCheckpointSave )
    {
      v12 = 1;
      IsMissionSave = 1;
      goto LABEL_55;
    }
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::ScriptSpace[270000], 34500);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheScripts::ScriptSpace[304500], 34500);
    CGenericGameStorage::_LoadDataFromWorkBuffer(CTheScripts::LocalVariablesForCurrentMission, 4096);
    v14 = ScriptIndex;
    v16 = &CTheScripts::ScriptSpace[270000];
    goto LABEL_57;
  }
LABEL_77:
  CScriptResourceManager::Load(&CTheScripts::ScriptResourceManager);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&IsOddJob, 4);
  if ( IsOddJob )
  {
    if ( IsOddJob == 1 )
      IsMissionSave = 1;
    IsMissionLoad = 1;
  }
  anytimeMissionScript[0] = 0;
  if ( v12 << 31 )
  {
    CGenericGameStorage::_LoadDataFromWorkBuffer(anytimeMissionScript, 8);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&missionReplaySetting, 4);
  }
}
// FC: using guessed type int elf_hash_bucket[16411];
// 10168: using guessed type int elf_hash_chain[22025];
// 41EAC: using guessed type Elf32_Sym stru_41EAC;
// 48C408: using guessed type int32 pData[8];
// 48C408: using guessed type char var_30[4];

//----- (0048CD3C) --------------------------------------------------------
void CTheScripts::DoScriptSetupAfterPoolsHaveLoaded()
{
  connect_lods_objects *v0; // r6
  int i; // r4
  Int32 Object1ID; // r0
  bool v3; // zf
  Int32 Object2ID; // r1

  for ( i = 0; i != 10; ++i )
  {
    Object1ID = CTheScripts::ScriptConnectLodsObjects[i].Object1ID;
    Object2ID = Object1ID + 1;
    v3 = Object1ID == -1;
    if ( Object1ID != -1 )
    {
      v0 = &CTheScripts::ScriptConnectLodsObjects[i];
      Object2ID = v0->Object2ID;
      v3 = Object2ID == -1;
    }
    if ( !v3 && !CTheScripts::ScriptConnectLodsFunction(Object1ID, Object2ID) )
    {
      CTheScripts::ScriptConnectLodsObjects[i].Object1ID = -1;
      v0->Object2ID = -1;
    }
  }
}
// 48CD82: variable 'v0' is possibly undefined

//----- (0048CDA0) --------------------------------------------------------
int CGameLogic::Save()
{
  _DWORD *v0; // r4
  _DWORD *v1; // r4
  Int32 v2; // r6
  CVector *v3; // r5
  _DWORD *v4; // r4
  __int64 v5; // d16
  float *v6; // r4

  v0 = malloc(4u);
  *v0 = CGameLogic::NumAfterDeathStartPoints;
  CGenericGameStorage::_SaveDataToWorkBuffer(v0, 4);
  free(v0);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CGameLogic::bPenaltyForDeathApplies, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CGameLogic::bPenaltyForArrestApplies, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CGameLogic::GameState, 1);
  v1 = malloc(4u);
  *v1 = CGameLogic::TimeOfLastEvent;
  CGenericGameStorage::_SaveDataToWorkBuffer(v1, 4);
  free(v1);
  if ( CGameLogic::NumAfterDeathStartPoints >= 1 )
  {
    v2 = 0;
    v3 = CGameLogic::AfterDeathStartPoints;
    do
    {
      v4 = malloc(0xCu);
      v5 = *(_QWORD *)&v3->x;
      v4[2] = LODWORD(v3->z);
      *(_QWORD *)v4 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v4, 12);
      free(v4);
      v6 = (float *)malloc(4u);
      *v6 = CGameLogic::AfterDeathStartPointOrientations[v2];
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      free(v6);
      ++v2;
      ++v3;
    }
    while ( v2 < CGameLogic::NumAfterDeathStartPoints );
  }
  return 1;
}

//----- (0048CE9C) --------------------------------------------------------
int CGameLogic::Load()
{
  Int32 v0; // r6
  CVector *v1; // r4
  float *v2; // r5

  CGenericGameStorage::_LoadDataFromWorkBuffer(&CGameLogic::NumAfterDeathStartPoints, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CGameLogic::bPenaltyForDeathApplies, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CGameLogic::bPenaltyForArrestApplies, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CGameLogic::GameState, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CGameLogic::TimeOfLastEvent, 4);
  if ( CGameLogic::NumAfterDeathStartPoints >= 1 )
  {
    v0 = 0;
    v1 = CGameLogic::AfterDeathStartPoints;
    v2 = CGameLogic::AfterDeathStartPointOrientations;
    do
    {
      CGenericGameStorage::_LoadDataFromWorkBuffer(v1, 12);
      CGenericGameStorage::_LoadDataFromWorkBuffer(v2, 4);
      ++v0;
      ++v2;
      ++v1;
    }
    while ( v0 < CGameLogic::NumAfterDeathStartPoints );
  }
  return 1;
}
// 676284: using guessed type char *CGameLogic::bPenaltyForArrestApplies[2];
// 6784D4: using guessed type char *CGameLogic::bPenaltyForDeathApplies;

//----- (0048CF44) --------------------------------------------------------
bool __fastcall CPathFind::Save(CPathFind *this)
{
  _DWORD *v2; // r5
  Int32 *p_NumNodeSwitches; // r8
  CNodesSwitchedOnOrOff *NodeSwitches; // r6
  Int32 v5; // r5
  _QWORD *v6; // r4
  __int64 v7; // d19
  __int64 v8; // d16
  __int64 v9; // d17

  v2 = malloc(4u);
  *v2 = this->NumNodeSwitches;
  CGenericGameStorage::_SaveDataToWorkBuffer(v2, 4);
  free(v2);
  if ( this->NumNodeSwitches >= 1 )
  {
    p_NumNodeSwitches = &this->NumNodeSwitches;
    NodeSwitches = this->NodeSwitches;
    v5 = 0;
    do
    {
      v6 = malloc(0x1Cu);
      v7 = *(_QWORD *)&NodeSwitches->MaxZ;
      v8 = *(_QWORD *)&NodeSwitches->MinX;
      v9 = *(_QWORD *)&NodeSwitches->MinY;
      *(_QWORD *)((char *)v6 + 12) = *(_QWORD *)&NodeSwitches->MaxY;
      *(_QWORD *)((char *)v6 + 20) = v7;
      *v6 = v8;
      v6[1] = v9;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 28);
      free(v6);
      ++v5;
      ++NodeSwitches;
    }
    while ( v5 < *p_NumNodeSwitches );
  }
  return 1;
}

//----- (0048CFC0) --------------------------------------------------------
bool __fastcall CPathFind::Load(CPathFind *this)
{
  Int32 *p_NumNodeSwitches; // r4
  CNodesSwitchedOnOrOff *NodeSwitches; // r5
  Int32 v4; // r6

  p_NumNodeSwitches = &this->NumNodeSwitches;
  CGenericGameStorage::_LoadDataFromWorkBuffer(&this->NumNodeSwitches, 4);
  if ( this->NumNodeSwitches >= 1 )
  {
    NodeSwitches = this->NodeSwitches;
    v4 = 0;
    do
    {
      CGenericGameStorage::_LoadDataFromWorkBuffer(NodeSwitches, 28);
      ++v4;
      ++NodeSwitches;
    }
    while ( v4 < *p_NumNodeSwitches );
  }
  return 1;
}

//----- (0048D000) --------------------------------------------------------
int CPickups::Save()
{
  int i; // r5
  _QWORD *v1; // r0
  __int64 v2; // d17
  void *v3; // r4
  __int64 v4; // d18
  __int64 v5; // d19
  _WORD *v6; // r4
  int j; // r5
  _DWORD *v8; // r4

  for ( i = 0; i != 620; ++i )
  {
    v1 = malloc(0x20u);
    v2 = *(_QWORD *)&CPickups::aPickUps[i].MonetaryValue;
    v3 = v1;
    v4 = *(_QWORD *)&CPickups::aPickUps[i].CoorsX;
    v5 = *(_QWORD *)&CPickups::aPickUps[i].MI;
    *v1 = *(_QWORD *)&CPickups::aPickUps[i].CurrentValue;
    v1[1] = v2;
    v1 += 2;
    *v1 = v4;
    v1[1] = v5;
    CGenericGameStorage::_SaveDataToWorkBuffer(v3, 32);
    free(v3);
  }
  v6 = malloc(2u);
  *v6 = CPickups::CollectedPickUpIndex;
  CGenericGameStorage::_SaveDataToWorkBuffer(v6, 2);
  free(v6);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CPickups::DisplayHelpMessage, 1);
  for ( j = 0; j != 20; ++j )
  {
    v8 = malloc(4u);
    *v8 = CPickups::aPickUpsCollected[j];
    CGenericGameStorage::_SaveDataToWorkBuffer(v8, 4);
    free(v8);
  }
  return 1;
}

//----- (0048D0B4) --------------------------------------------------------
int CPickups::Load()
{
  int i; // r5

  for ( i = 0; i != 620; ++i )
  {
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CPickups::aPickUps[i], 32);
    if ( CPickups::aPickUps[i].Type && CPickups::aPickUps[i].pObject )
    {
      CPickups::aPickUps[i].pObject = 0;
      *((_BYTE *)&CPickups::aPickUps[i] + 29) &= ~8u;
    }
  }
  CPickups::NumMessages = 0;
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CPickups::CollectedPickUpIndex, 2);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CPickups::DisplayHelpMessage, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(CPickups::aPickUpsCollected, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CPickups::aPickUpsCollected[1], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CPickups::aPickUpsCollected[2], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CPickups::aPickUpsCollected[3], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CPickups::aPickUpsCollected[4], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CPickups::aPickUpsCollected[5], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CPickups::aPickUpsCollected[6], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CPickups::aPickUpsCollected[7], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CPickups::aPickUpsCollected[8], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CPickups::aPickUpsCollected[9], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CPickups::aPickUpsCollected[10], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CPickups::aPickUpsCollected[11], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CPickups::aPickUpsCollected[12], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CPickups::aPickUpsCollected[13], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CPickups::aPickUpsCollected[14], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CPickups::aPickUpsCollected[15], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CPickups::aPickUpsCollected[16], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CPickups::aPickUpsCollected[17], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CPickups::aPickUpsCollected[18], 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CPickups::aPickUpsCollected[19], 4);
  return 1;
}

//----- (0048D21C) --------------------------------------------------------
int CRestart::Save()
{
  _WORD *v0; // r4
  int v1; // r5
  int v2; // r6
  CVector *v3; // r8
  _DWORD *v4; // r4
  __int64 v5; // d16
  float *v6; // r4
  _DWORD *v7; // r4
  _WORD *v8; // r4
  int v9; // r5
  int v10; // r6
  CVector *v11; // r8
  _DWORD *v12; // r4
  __int64 v13; // d16
  float *v14; // r4
  _DWORD *v15; // r4
  _DWORD *v16; // r4
  __int64 v17; // d16
  _DWORD *v18; // r4
  __int64 v19; // d16
  float *v20; // r4
  float *v21; // r4
  _DWORD *v22; // r4
  __int64 v23; // d16
  float *v24; // r4
  float *v25; // r4

  v0 = malloc(2u);
  *v0 = CRestart::NumberOfHospitalRestarts;
  CGenericGameStorage::_SaveDataToWorkBuffer(v0, 2);
  free(v0);
  if ( CRestart::NumberOfHospitalRestarts )
  {
    v1 = 0;
    v2 = 0;
    do
    {
      v3 = &CRestart::HospitalRestartPoints[v1];
      v4 = malloc(0xCu);
      v5 = *(_QWORD *)&v3->x;
      v4[2] = LODWORD(v3->z);
      *(_QWORD *)v4 = v5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v4, 12);
      free(v4);
      v6 = (float *)malloc(4u);
      *v6 = CRestart::HospitalRestartHeadings[v1];
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
      free(v6);
      v7 = malloc(4u);
      *v7 = CRestart::HospitalRestartWhenToUse[v1];
      CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
      free(v7);
      v1 = (unsigned __int16)++v2;
    }
    while ( (unsigned __int16)v2 < (unsigned int)CRestart::NumberOfHospitalRestarts );
  }
  v8 = malloc(2u);
  *v8 = CRestart::NumberOfPoliceRestarts;
  CGenericGameStorage::_SaveDataToWorkBuffer(v8, 2);
  free(v8);
  if ( CRestart::NumberOfPoliceRestarts )
  {
    v9 = 0;
    v10 = 0;
    do
    {
      v11 = &CRestart::PoliceRestartPoints[v9];
      v12 = malloc(0xCu);
      v13 = *(_QWORD *)&v11->x;
      v12[2] = LODWORD(v11->z);
      *(_QWORD *)v12 = v13;
      CGenericGameStorage::_SaveDataToWorkBuffer(v12, 12);
      free(v12);
      v14 = (float *)malloc(4u);
      *v14 = CRestart::PoliceRestartHeadings[v9];
      CGenericGameStorage::_SaveDataToWorkBuffer(v14, 4);
      free(v14);
      v15 = malloc(4u);
      *v15 = CRestart::PoliceRestartWhenToUse[v9];
      CGenericGameStorage::_SaveDataToWorkBuffer(v15, 4);
      free(v15);
      v9 = (unsigned __int16)++v10;
    }
    while ( (unsigned __int16)v10 < (unsigned int)CRestart::NumberOfPoliceRestarts );
  }
  CGenericGameStorage::_SaveDataToWorkBuffer(&CRestart::bOverrideRestart, 1);
  v16 = malloc(0xCu);
  v17 = *(_QWORD *)&CRestart::OverridePosition.x;
  v16[2] = LODWORD(CRestart::OverridePosition.z);
  *(_QWORD *)v16 = v17;
  CGenericGameStorage::_SaveDataToWorkBuffer(v16, 12);
  free(v16);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CRestart::bFadeInAfterNextDeath, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CRestart::bFadeInAfterNextArrest, 1);
  v18 = malloc(0xCu);
  v19 = *(_QWORD *)&CRestart::ExtraHospitalRestartCoors.x;
  v18[2] = LODWORD(CRestart::ExtraHospitalRestartCoors.z);
  *(_QWORD *)v18 = v19;
  CGenericGameStorage::_SaveDataToWorkBuffer(v18, 12);
  free(v18);
  v20 = (float *)malloc(4u);
  *v20 = CRestart::ExtraHospitalRestartRadius;
  CGenericGameStorage::_SaveDataToWorkBuffer(v20, 4);
  free(v20);
  v21 = (float *)malloc(4u);
  *v21 = CRestart::ExtraHospitalRestartHeading;
  CGenericGameStorage::_SaveDataToWorkBuffer(v21, 4);
  free(v21);
  v22 = malloc(0xCu);
  v23 = *(_QWORD *)&CRestart::ExtraPoliceStationRestartCoors.x;
  v22[2] = LODWORD(CRestart::ExtraPoliceStationRestartCoors.z);
  *(_QWORD *)v22 = v23;
  CGenericGameStorage::_SaveDataToWorkBuffer(v22, 12);
  free(v22);
  v24 = (float *)malloc(4u);
  *v24 = CRestart::ExtraPoliceStationRestartRadius;
  CGenericGameStorage::_SaveDataToWorkBuffer(v24, 4);
  free(v24);
  v25 = (float *)malloc(4u);
  *v25 = CRestart::ExtraPoliceStationRestartHeading;
  CGenericGameStorage::_SaveDataToWorkBuffer(v25, 4);
  free(v25);
  return 1;
}

//----- (0048D514) --------------------------------------------------------
int CRestart::Load()
{
  int v0; // r6
  int v1; // r4
  int v2; // r6
  int v3; // r4

  CRestart::Initialise();
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CRestart::NumberOfHospitalRestarts, 2);
  if ( CRestart::NumberOfHospitalRestarts )
  {
    v0 = 0;
    v1 = 0;
    do
    {
      CGenericGameStorage::_LoadDataFromWorkBuffer(&CRestart::HospitalRestartPoints[v0], 12);
      CGenericGameStorage::_LoadDataFromWorkBuffer(&CRestart::HospitalRestartHeadings[v0], 4);
      CGenericGameStorage::_LoadDataFromWorkBuffer(&CRestart::HospitalRestartWhenToUse[v0], 4);
      v0 = (unsigned __int16)++v1;
    }
    while ( (unsigned __int16)v1 < (unsigned int)CRestart::NumberOfHospitalRestarts );
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CRestart::NumberOfPoliceRestarts, 2);
  if ( CRestart::NumberOfPoliceRestarts )
  {
    v2 = 0;
    v3 = 0;
    do
    {
      CGenericGameStorage::_LoadDataFromWorkBuffer(&CRestart::PoliceRestartPoints[v2], 12);
      CGenericGameStorage::_LoadDataFromWorkBuffer(&CRestart::PoliceRestartHeadings[v2], 4);
      CGenericGameStorage::_LoadDataFromWorkBuffer(&CRestart::PoliceRestartWhenToUse[v2], 4);
      v2 = (unsigned __int16)++v3;
    }
    while ( (unsigned __int16)v3 < (unsigned int)CRestart::NumberOfPoliceRestarts );
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CRestart::bOverrideRestart, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CRestart::OverridePosition, 12);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CRestart::bFadeInAfterNextDeath, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CRestart::bFadeInAfterNextArrest, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CRestart::ExtraHospitalRestartCoors, 12);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CRestart::ExtraHospitalRestartRadius, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CRestart::ExtraHospitalRestartHeading, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CRestart::ExtraPoliceStationRestartCoors, 12);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CRestart::ExtraPoliceStationRestartRadius, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CRestart::ExtraPoliceStationRestartHeading, 4);
  return 1;
}
// 6769C4: using guessed type float CRestart::ExtraHospitalRestartHeading;
// 676A24: using guessed type CVector *CRestart::ExtraHospitalRestartCoors;
// 676D14: using guessed type float CRestart::ExtraHospitalRestartRadius;
// 677038: using guessed type float *CRestart::ExtraPoliceStationRestartHeading;
// 67831C: using guessed type CVector *CRestart::ExtraPoliceStationRestartCoors;
// 6797E8: using guessed type float *CRestart::ExtraPoliceStationRestartRadius;

//----- (0048D6B0) --------------------------------------------------------
void __fastcall CopyToRadarTraceSerialize(sRadarTraceSerialize *pRadarTrace, sRadarTrace *radarTrace)
{
  __int64 v2; // d16
  int v3; // r2
  unsigned int v4; // r2
  unsigned int v5; // r2
  unsigned int v6; // r2
  unsigned int v7; // r2
  unsigned int v8; // r2
  unsigned int v9; // r2
  unsigned int v10; // r2
  unsigned int v11; // r2

  pRadarTrace->nColour = radarTrace->nColour;
  pRadarTrace->PoolIndex = radarTrace->PoolIndex;
  v2 = *(_QWORD *)&radarTrace->position.x;
  pRadarTrace->position.z = radarTrace->position.z;
  *(_QWORD *)&pRadarTrace->position.x = v2;
  pRadarTrace->ReferenceIndex = radarTrace->ReferenceIndex;
  pRadarTrace->fBlipMarkerScale = radarTrace->fBlipMarkerScale;
  pRadarTrace->nBlipScale = radarTrace->nBlipScale;
  pRadarTrace->pEntryExit = (fakePtr)radarTrace->pEntryExit->cTitle;
  v3 = *(unsigned __int16 *)((char *)pRadarTrace + 37);
  pRadarTrace->nBlipSprite = radarTrace->nBlipSprite;
  v4 = v3 & 0xFFFFFFFE | *(_WORD *)((char *)radarTrace + 37) & 1;
  *(_WORD *)((char *)pRadarTrace + 37) = v4;
  v5 = v4 & 0xFFFFFFFD | (2 * ((*(unsigned __int16 *)((char *)radarTrace + 37) >> 1) & 1));
  *(_WORD *)((char *)pRadarTrace + 37) = v5;
  v6 = v5 & 0xFFFFFFFB | (4 * ((*(unsigned __int16 *)((char *)radarTrace + 37) >> 2) & 1));
  *(_WORD *)((char *)pRadarTrace + 37) = v6;
  v7 = v6 & 0xFFFFFFF7 | (8 * ((*(unsigned __int16 *)((char *)radarTrace + 37) >> 3) & 1));
  *(_WORD *)((char *)pRadarTrace + 37) = v7;
  v8 = v7 & 0xFFFFFFEF | (16 * ((*(unsigned __int16 *)((char *)radarTrace + 37) >> 4) & 1));
  *(_WORD *)((char *)pRadarTrace + 37) = v8;
  v9 = v8 & 0xFFFFFFDF | (32 * ((*(unsigned __int16 *)((char *)radarTrace + 37) >> 5) & 1));
  *(_WORD *)((char *)pRadarTrace + 37) = v9;
  v10 = v9 & 0xFFFFFF3F | (((*(unsigned __int16 *)((char *)radarTrace + 37) >> 6) & 3) << 6);
  *(_WORD *)((char *)pRadarTrace + 37) = v10;
  v11 = v10 & 0xFFFFFCFF | ((HIBYTE(*(unsigned __int16 *)((char *)radarTrace + 37)) & 3) << 8);
  *(_WORD *)((char *)pRadarTrace + 37) = v11;
  *(_WORD *)((char *)pRadarTrace + 37) = *(_WORD *)((char *)radarTrace + 37) & 0x3C00 | v11 & 0xC3FF;
}

//----- (0048D764) --------------------------------------------------------
void __fastcall CopyFromRadarTraceSerialize(sRadarTrace *pRadarTrace, sRadarTraceSerialize *radarTrace)
{
  __int64 v2; // d16
  int v3; // r2
  unsigned int v4; // r2
  unsigned int v5; // r2
  unsigned int v6; // r2
  unsigned int v7; // r2
  unsigned int v8; // r2
  unsigned int v9; // r2
  unsigned int v10; // r2
  unsigned int v11; // r2

  pRadarTrace->nColour = radarTrace->nColour;
  pRadarTrace->PoolIndex = radarTrace->PoolIndex;
  v2 = *(_QWORD *)&radarTrace->position.x;
  pRadarTrace->position.z = radarTrace->position.z;
  *(_QWORD *)&pRadarTrace->position.x = v2;
  pRadarTrace->ReferenceIndex = radarTrace->ReferenceIndex;
  pRadarTrace->fBlipMarkerScale = radarTrace->fBlipMarkerScale;
  pRadarTrace->nBlipScale = radarTrace->nBlipScale;
  pRadarTrace->pEntryExit = (CEntryExit *)radarTrace->pEntryExit;
  v3 = *(unsigned __int16 *)((char *)pRadarTrace + 37);
  pRadarTrace->nBlipSprite = radarTrace->nBlipSprite;
  v4 = v3 & 0xFFFFFFFE | *(_WORD *)((char *)radarTrace + 37) & 1;
  *(_WORD *)((char *)pRadarTrace + 37) = v4;
  v5 = v4 & 0xFFFFFFFD | (2 * ((*(unsigned __int16 *)((char *)radarTrace + 37) >> 1) & 1));
  *(_WORD *)((char *)pRadarTrace + 37) = v5;
  v6 = v5 & 0xFFFFFFFB | (4 * ((*(unsigned __int16 *)((char *)radarTrace + 37) >> 2) & 1));
  *(_WORD *)((char *)pRadarTrace + 37) = v6;
  v7 = v6 & 0xFFFFFFF7 | (8 * ((*(unsigned __int16 *)((char *)radarTrace + 37) >> 3) & 1));
  *(_WORD *)((char *)pRadarTrace + 37) = v7;
  v8 = v7 & 0xFFFFFFEF | (16 * ((*(unsigned __int16 *)((char *)radarTrace + 37) >> 4) & 1));
  *(_WORD *)((char *)pRadarTrace + 37) = v8;
  v9 = v8 & 0xFFFFFFDF | (32 * ((*(unsigned __int16 *)((char *)radarTrace + 37) >> 5) & 1));
  *(_WORD *)((char *)pRadarTrace + 37) = v9;
  v10 = v9 & 0xFFFFFF3F | (((*(unsigned __int16 *)((char *)radarTrace + 37) >> 6) & 3) << 6);
  *(_WORD *)((char *)pRadarTrace + 37) = v10;
  v11 = v10 & 0xFFFFFCFF | ((HIBYTE(*(unsigned __int16 *)((char *)radarTrace + 37)) & 3) << 8);
  *(_WORD *)((char *)pRadarTrace + 37) = v11;
  *(_WORD *)((char *)pRadarTrace + 37) = *(_WORD *)((char *)radarTrace + 37) & 0x3C00 | v11 & 0xC3FF;
}

//----- (0048D818) --------------------------------------------------------
int CRadar::Save()
{
  int v0; // r11
  sRadarTrace *v1; // r5
  CEntryExit *pEntryExit; // r6
  int v3; // r1
  int32 v4; // r1
  int v5; // r10
  __int16 v6; // r0
  _QWORD *v7; // r4
  __int64 v8; // d16
  __int64 v9; // d17
  __int64 v10; // d18
  __int64 v11; // d19

  v0 = 250;
  v1 = CRadar::ms_RadarTrace;
  do
  {
    pEntryExit = v1->pEntryExit;
    if ( pEntryExit
      && (v3 = (char *)pEntryExit - (char *)CEntryExitManager::mp_poolEntryExits->m_aStorage, v3 >= 0)
      && (v4 = -286331153 * (v3 >> 2), v4 < CEntryExitManager::mp_poolEntryExits->m_nSize)
      && (CEntryExitManager::mp_poolEntryExits->m_aFlags[v4] & 0x80u) == 0 )
    {
      v1->pEntryExit = (CEntryExit *)(-286331153
                                    * (((char *)pEntryExit - (char *)CEntryExitManager::mp_poolEntryExits->m_aStorage) >> 2)
                                    + 1);
    }
    else
    {
      pEntryExit = 0;
    }
    if ( IsMissionSave )
    {
      v5 = 0;
    }
    else
    {
      v6 = *(_WORD *)((char *)v1 + 37);
      v5 = 0;
      if ( (v6 & 0x3800) != 4096 && (v6 & 2) != 0 )
      {
        *(_WORD *)((char *)v1 + 37) = v6 & 0xFFFD;
        v5 = 1;
      }
    }
    v7 = malloc(0x28u);
    v8 = *(_QWORD *)&v1->nColour;
    v9 = *(_QWORD *)&v1->position.x;
    v10 = *(_QWORD *)&v1->position.z;
    v11 = *(_QWORD *)&v1->fBlipMarkerScale;
    v7[4] = *(_QWORD *)&v1->pEntryExit;
    *v7 = v8;
    v7[1] = v9;
    v7[2] = v10;
    v7[3] = v11;
    CGenericGameStorage::_SaveDataToWorkBuffer(v7, 40);
    free(v7);
    if ( pEntryExit )
      v1->pEntryExit = pEntryExit;
    if ( v5 == 1 )
      *(_WORD *)((char *)v1 + 37) |= 2u;
    --v0;
    ++v1;
  }
  while ( v0 );
  return 1;
}

//----- (0048D920) --------------------------------------------------------
int CRadar::Load()
{
  unsigned int v0; // r9
  int v1; // r5
  int v2; // r0
  sRadarTrace *v3; // r4
  CEntryExit *v4; // r0
  _DWORD *p_pEntryExit; // r4
  CEntryExit *pEntryExit; // t1
  int v7; // r0
  uint8 *v8; // r0

  CRadar::Initialise();
  v0 = 250;
  v1 = 0;
  v2 = 0;
  if ( CGenericGameStorage::m_currentSlotVersionNumber < 4 )
    v0 = 175;
  do
  {
    v3 = &CRadar::ms_RadarTrace[v2];
    CGenericGameStorage::_LoadDataFromWorkBuffer(v3, 40);
    pEntryExit = v3->pEntryExit;
    p_pEntryExit = &v3->pEntryExit;
    v4 = pEntryExit;
    if ( pEntryExit )
    {
      v7 = (int)&v4[-1].pLink + 3;
      if ( (CEntryExitManager::mp_poolEntryExits->m_aFlags[v7] & 0x80u) != 0 )
        v8 = 0;
      else
        v8 = CEntryExitManager::mp_poolEntryExits->m_aStorage[v7];
      *p_pEntryExit = v8;
    }
    v2 = (unsigned __int16)++v1;
  }
  while ( v0 > (unsigned __int16)v1 );
  return 1;
}

//----- (0048D9A4) --------------------------------------------------------
int CTheCarGenerators::Save()
{
  int v0; // r0
  int v1; // r5
  _DWORD *v2; // r4
  int v3; // r6
  CCarGenerator *v4; // r5
  _WORD *v5; // r4
  _QWORD *v6; // r4
  __int64 v7; // d17
  __int64 v8; // d18
  __int64 v9; // d19
  _DWORD *v10; // r4
  int i; // r5
  _QWORD *v12; // r0
  __int64 v13; // d17
  void *v14; // r4

  v0 = 0;
  v1 = 0;
  do
  {
    if ( !CTheCarGenerators::CarGeneratorArray[v0].m_level && CTheCarGenerators::CarGeneratorArray[v0].m_used )
      ++v1;
    ++v0;
  }
  while ( v0 != 500 );
  v2 = malloc(4u);
  *v2 = v1;
  CGenericGameStorage::_SaveDataToWorkBuffer(v2, 4);
  free(v2);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CTheCarGenerators::ProcessCounter, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CTheCarGenerators::GenerateEvenIfPlayerIsCloseCounter, 1);
  v3 = 0;
  v4 = CTheCarGenerators::CarGeneratorArray;
  do
  {
    if ( !v4->m_level && v4->m_used )
    {
      v5 = malloc(2u);
      *v5 = v3;
      CGenericGameStorage::_SaveDataToWorkBuffer(v5, 2);
      free(v5);
      v6 = malloc(0x20u);
      v7 = *(_QWORD *)&v4->nZ;
      v8 = *(_QWORD *)&v4->MaxDelay;
      v9 = *(_QWORD *)&v4->LatestCarID;
      *v6 = *(_QWORD *)&v4->VisibleModel;
      v6[1] = v7;
      v6[2] = v8;
      v6[3] = v9;
      CGenericGameStorage::_SaveDataToWorkBuffer(v6, 32);
      free(v6);
    }
    ++v3;
    ++v4;
  }
  while ( v3 != 500 );
  v10 = malloc(4u);
  *v10 = CTheCarGenerators::m_SpecialPlateHandler.m_nSpecialPlates;
  CGenericGameStorage::_SaveDataToWorkBuffer(v10, 4);
  free(v10);
  for ( i = 0; i != 15; ++i )
  {
    v12 = malloc(0x10u);
    v13 = *(_QWORD *)&CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[i].szNumPlate[4];
    v14 = v12;
    *v12 = *(_QWORD *)&CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[i].nCarIndex;
    v12[1] = v13;
    CGenericGameStorage::_SaveDataToWorkBuffer(v12, 16);
    free(v14);
  }
  return 1;
}

//----- (0048DAD4) --------------------------------------------------------
int CTheCarGenerators::Load()
{
  int v0; // r5
  unsigned __int16 pData[9]; // [sp+6h] [bp-12h] BYREF

  CTheCarGenerators::Init();
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheCarGenerators::NumOfCarGenerators, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheCarGenerators::ProcessCounter, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheCarGenerators::GenerateEvenIfPlayerIsCloseCounter, 1);
  if ( CTheCarGenerators::NumOfCarGenerators >= 1 )
  {
    v0 = 0;
    do
    {
      CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
      if ( pData[0] >> 2 <= 0x7Cu )
        CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheCarGenerators::CarGeneratorArray[pData[0]], 32);
      ++v0;
    }
    while ( CTheCarGenerators::NumOfCarGenerators > (unsigned __int16)v0 );
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheCarGenerators::m_SpecialPlateHandler.m_nSpecialPlates, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheCarGenerators::m_SpecialPlateHandler, 16);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[1], 16);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[2], 16);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[3], 16);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[4], 16);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[5], 16);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[6], 16);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[7], 16);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[8], 16);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[9], 16);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[10], 16);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[11], 16);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[12], 16);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[13], 16);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTheCarGenerators::m_SpecialPlateHandler.m_aSpecialPlates[14], 16);
  return 1;
}
// 48DAD4: using guessed type unsigned __int16 pData[9];

//----- (0048DC0C) --------------------------------------------------------
int CGangs::Save()
{
  _QWORD *v0; // r4
  __int64 v1; // d17
  _QWORD *v2; // r0
  __int64 v3; // d17
  void *v4; // r4
  _QWORD *v5; // r4
  __int64 v6; // d17
  _QWORD *v7; // r4
  __int64 v8; // d17
  _QWORD *v9; // r4
  __int64 v10; // d17
  _QWORD *v11; // r4
  __int64 v12; // d17
  _QWORD *v13; // r4
  __int64 v14; // d17
  _QWORD *v15; // r4
  __int64 v16; // d17
  _QWORD *v17; // r4
  __int64 v18; // d17
  _QWORD *v19; // r4
  __int64 v20; // d17

  v0 = malloc(0x10u);
  v1 = *(_QWORD *)&CGangs::Gang[0].SecondWeapon;
  *v0 = *(_QWORD *)&CGangs::Gang[0].PedModelOverride;
  v0[1] = v1;
  CGenericGameStorage::_SaveDataToWorkBuffer(v0, 16);
  free(v0);
  v2 = malloc(0x10u);
  v3 = *(_QWORD *)&CGangs::Gang[1].SecondWeapon;
  v4 = v2;
  *v2 = *(_QWORD *)&CGangs::Gang[1].PedModelOverride;
  v2[1] = v3;
  CGenericGameStorage::_SaveDataToWorkBuffer(v2, 16);
  free(v4);
  v5 = malloc(0x10u);
  v6 = *(_QWORD *)&CGangs::Gang[2].SecondWeapon;
  *v5 = *(_QWORD *)&CGangs::Gang[2].PedModelOverride;
  v5[1] = v6;
  CGenericGameStorage::_SaveDataToWorkBuffer(v5, 16);
  free(v5);
  v7 = malloc(0x10u);
  v8 = *(_QWORD *)&CGangs::Gang[3].SecondWeapon;
  *v7 = *(_QWORD *)&CGangs::Gang[3].PedModelOverride;
  v7[1] = v8;
  CGenericGameStorage::_SaveDataToWorkBuffer(v7, 16);
  free(v7);
  v9 = malloc(0x10u);
  v10 = *(_QWORD *)&CGangs::Gang[4].SecondWeapon;
  *v9 = *(_QWORD *)&CGangs::Gang[4].PedModelOverride;
  v9[1] = v10;
  CGenericGameStorage::_SaveDataToWorkBuffer(v9, 16);
  free(v9);
  v11 = malloc(0x10u);
  v12 = *(_QWORD *)&CGangs::Gang[5].SecondWeapon;
  *v11 = *(_QWORD *)&CGangs::Gang[5].PedModelOverride;
  v11[1] = v12;
  CGenericGameStorage::_SaveDataToWorkBuffer(v11, 16);
  free(v11);
  v13 = malloc(0x10u);
  v14 = *(_QWORD *)&CGangs::Gang[6].SecondWeapon;
  *v13 = *(_QWORD *)&CGangs::Gang[6].PedModelOverride;
  v13[1] = v14;
  CGenericGameStorage::_SaveDataToWorkBuffer(v13, 16);
  free(v13);
  v15 = malloc(0x10u);
  v16 = *(_QWORD *)&CGangs::Gang[7].SecondWeapon;
  *v15 = *(_QWORD *)&CGangs::Gang[7].PedModelOverride;
  v15[1] = v16;
  CGenericGameStorage::_SaveDataToWorkBuffer(v15, 16);
  free(v15);
  v17 = malloc(0x10u);
  v18 = *(_QWORD *)&CGangs::Gang[8].SecondWeapon;
  *v17 = *(_QWORD *)&CGangs::Gang[8].PedModelOverride;
  v17[1] = v18;
  CGenericGameStorage::_SaveDataToWorkBuffer(v17, 16);
  free(v17);
  v19 = malloc(0x10u);
  v20 = *(_QWORD *)&CGangs::Gang[9].SecondWeapon;
  *v19 = *(_QWORD *)&CGangs::Gang[9].PedModelOverride;
  v19[1] = v20;
  CGenericGameStorage::_SaveDataToWorkBuffer(v19, 16);
  free(v19);
  return 1;
}

//----- (0048DD74) --------------------------------------------------------
int CGangs::Load()
{
  CGenericGameStorage::_LoadDataFromWorkBuffer(CGangs::Gang, 16);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CGangs::Gang[1], 16);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CGangs::Gang[2], 16);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CGangs::Gang[3], 16);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CGangs::Gang[4], 16);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CGangs::Gang[5], 16);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CGangs::Gang[6], 16);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CGangs::Gang[7], 16);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CGangs::Gang[8], 16);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CGangs::Gang[9], 16);
  return 1;
}

//----- (0048DDE8) --------------------------------------------------------
bool __fastcall CPlayerInfo::Save(CPlayerInfo *this)
{
  UInt8 PlayerState; // r6
  UInt16 CarDensityForCurrentZone; // r9
  __int64 v3; // r10
  __int64 v4; // kr00_8
  _DWORD *v5; // r4
  char *v6; // r4
  float RoadDensityAroundPlayer; // [sp+4h] [bp-4Ch]
  char TimeLastEaten; // [sp+8h] [bp-48h]
  bool DoesNotGetTired; // [sp+Ch] [bp-44h]
  bool FastReload; // [sp+10h] [bp-40h]
  bool FireProof; // [sp+14h] [bp-3Ch]
  UInt8 MaxHealth; // [sp+18h] [bp-38h]
  UInt8 MaxArmour; // [sp+1Ch] [bp-34h]
  bool bGetOutOfJailFree; // [sp+20h] [bp-30h]
  bool bFreeHealthCare; // [sp+24h] [bp-2Ch]
  bool bCanDoDriveBy; // [sp+28h] [bp-28h]
  UInt8 m_nBustedAudioStatus; // [sp+2Ch] [bp-24h]
  UInt16 m_nLastBustMessageNumber; // [sp+30h] [bp-20h]

  m_nLastBustMessageNumber = this->m_nLastBustMessageNumber;
  m_nBustedAudioStatus = this->m_nBustedAudioStatus;
  bCanDoDriveBy = this->bCanDoDriveBy;
  bFreeHealthCare = this->bFreeHealthCare;
  bGetOutOfJailFree = this->bGetOutOfJailFree;
  MaxArmour = this->MaxArmour;
  MaxHealth = this->MaxHealth;
  FireProof = this->FireProof;
  FastReload = this->FastReload;
  DoesNotGetTired = this->DoesNotGetTired;
  TimeLastEaten = this->TimeLastEaten;
  RoadDensityAroundPlayer = this->RoadDensityAroundPlayer;
  PlayerState = this->PlayerState;
  CarDensityForCurrentZone = this->CarDensityForCurrentZone;
  v3 = *(_QWORD *)&this->Score;
  v4 = *(_QWORD *)&this->CollectablesPickedUp;
  v5 = malloc(4u);
  *v5 = 40;
  CGenericGameStorage::_SaveDataToWorkBuffer(v5, 4);
  free(v5);
  v6 = (char *)malloc(0x28u);
  *(_DWORD *)v6 = v3;
  *((_WORD *)v6 + 2) = CarDensityForCurrentZone;
  v6[6] = PlayerState;
  *((float *)v6 + 2) = RoadDensityAroundPlayer;
  *((_DWORD *)v6 + 3) = HIDWORD(v3);
  v6[16] = TimeLastEaten;
  *(_QWORD *)(v6 + 20) = v4;
  v6[28] = DoesNotGetTired;
  v6[29] = FastReload;
  v6[30] = FireProof;
  v6[31] = MaxHealth;
  v6[32] = MaxArmour;
  v6[33] = bGetOutOfJailFree;
  v6[34] = bFreeHealthCare;
  v6[35] = bCanDoDriveBy;
  v6[36] = m_nBustedAudioStatus;
  *((_WORD *)v6 + 19) = m_nLastBustMessageNumber;
  CGenericGameStorage::_SaveDataToWorkBuffer(v6, 40);
  free(v6);
  return 1;
}

//----- (0048DED2) --------------------------------------------------------
bool __fastcall CPlayerInfo::Load(CPlayerInfo *this)
{
  UInt8 v2; // r1
  Int32 v3; // r0
  Int32 v4; // r1
  Int32 v5; // r2
  Int32 v6; // r3
  Int32 v8; // [sp+4h] [bp-34h] BYREF
  UInt16 v9; // [sp+8h] [bp-30h]
  UInt8 v10; // [sp+Ah] [bp-2Eh]
  float v11; // [sp+Ch] [bp-2Ch]
  Int32 v12; // [sp+10h] [bp-28h]
  unsigned __int8 v13; // [sp+14h] [bp-24h]
  Int32 v14; // [sp+18h] [bp-20h]
  Int32 v15; // [sp+1Ch] [bp-1Ch]
  bool v16; // [sp+20h] [bp-18h]
  bool v17; // [sp+21h] [bp-17h]
  bool v18; // [sp+22h] [bp-16h]
  UInt8 v19; // [sp+23h] [bp-15h]
  UInt8 v20; // [sp+24h] [bp-14h]
  bool v21; // [sp+25h] [bp-13h]
  bool v22; // [sp+26h] [bp-12h]
  bool v23; // [sp+27h] [bp-11h]
  UInt8 v24; // [sp+28h] [bp-10h]
  UInt16 v25; // [sp+2Ah] [bp-Eh]
  char pData[12]; // [sp+2Ch] [bp-Ch] BYREF

  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v8, 40);
  v2 = v10;
  v3 = v8;
  this->CarDensityForCurrentZone = v9;
  this->PlayerState = v2;
  this->RoadDensityAroundPlayer = v11;
  v4 = v12;
  this->TimeLastEaten = v13;
  v5 = v14;
  v6 = v15;
  this->Score = v3;
  this->DisplayScore = v4;
  this->CollectablesPickedUp = v5;
  this->TotalNumCollectables = v6;
  this->DoesNotGetTired = v16;
  this->FastReload = v17;
  this->FireProof = v18;
  this->MaxHealth = v19;
  this->MaxArmour = v20;
  this->bGetOutOfJailFree = v21;
  this->bFreeHealthCare = v22;
  this->bCanDoDriveBy = v23;
  this->m_nBustedAudioStatus = v24;
  this->m_nLastBustMessageNumber = v25;
  return 1;
}
// 48DED2: using guessed type char pData[12];

//----- (0048DF70) --------------------------------------------------------
int CStats::Save()
{
  float StatValue; // r0
  int v1; // r5
  float *v2; // r4
  Int32 *v3; // r4
  UInt32 *v4; // r4
  _QWORD *v5; // r4
  __int64 v6; // d18
  __int64 v7; // d19
  __int64 v8; // d16
  __int64 v9; // d17
  __int64 v10; // d22
  __int64 v11; // d23
  Int32 *v12; // r4

  StatValue = CStats::GetStatValue(0xB0u);
  CStats::IncrementStat(0xB1u, StatValue);
  v1 = 0;
  CStats::SetStatValue(0xB0u, 0.0);
  v2 = (float *)malloc(0x148u);
  qmemcpy(v2, CStats::StatTypesFloat, 0x148u);
  CGenericGameStorage::_SaveDataToWorkBuffer(v2, 328);
  free(v2);
  v3 = (Int32 *)malloc(0x37Cu);
  qmemcpy(v3, CStats::StatTypesInt, 0x37Cu);
  CGenericGameStorage::_SaveDataToWorkBuffer(v3, 892);
  free(v3);
  v4 = (UInt32 *)malloc(0x80u);
  qmemcpy(v4, CStats::PedsKilledOfThisType, 0x80u);
  CGenericGameStorage::_SaveDataToWorkBuffer(v4, 128);
  free(v4);
  CGenericGameStorage::_SaveDataToWorkBuffer(CStats::LastMissionPassedName, 8);
  CStats::PopulateFavoriteRadioStationList();
  v5 = malloc(0x38u);
  v6 = *(_QWORD *)&CStats::FavoriteRadioStationList[8];
  v7 = *(_QWORD *)&CStats::FavoriteRadioStationList[10];
  v5[6] = *(_QWORD *)&CStats::FavoriteRadioStationList[12];
  v8 = *(_QWORD *)CStats::FavoriteRadioStationList;
  v9 = *(_QWORD *)&CStats::FavoriteRadioStationList[2];
  v5[4] = v6;
  v5[5] = v7;
  v10 = *(_QWORD *)&CStats::FavoriteRadioStationList[4];
  v11 = *(_QWORD *)&CStats::FavoriteRadioStationList[6];
  *v5 = v8;
  v5[1] = v9;
  v5[2] = v10;
  v5[3] = v11;
  CGenericGameStorage::_SaveDataToWorkBuffer(v5, 56);
  free(v5);
  v12 = (Int32 *)malloc(0x190u);
  qmemcpy(v12, CStats::TimesMissionAttempted, 0x190u);
  CGenericGameStorage::_SaveDataToWorkBuffer(v12, 400);
  free(v12);
  do
    CGenericGameStorage::_SaveDataToWorkBuffer(&CStats::StatMessage[v1++].processed, 1);
  while ( v1 != 128 );
  return 1;
}

//----- (0048E0C4) --------------------------------------------------------
int CStats::Load()
{
  int i; // r4

  CGenericGameStorage::_LoadDataFromWorkBuffer(CStats::StatTypesFloat, 328);
  CGenericGameStorage::_LoadDataFromWorkBuffer(CStats::StatTypesInt, 892);
  CGenericGameStorage::_LoadDataFromWorkBuffer(CStats::PedsKilledOfThisType, 128);
  CGenericGameStorage::_LoadDataFromWorkBuffer(CStats::LastMissionPassedName, 8);
  CGenericGameStorage::_LoadDataFromWorkBuffer(CStats::FavoriteRadioStationList, 56);
  CGenericGameStorage::_LoadDataFromWorkBuffer(CStats::TimesMissionAttempted, 400);
  for ( i = 0; i != 128; ++i )
    CGenericGameStorage::_LoadDataFromWorkBuffer(&CStats::StatMessage[i].processed, 1);
  return 1;
}

//----- (0048E150) --------------------------------------------------------
int CSetPieces::Save()
{
  _DWORD *v0; // r4
  CSetPiece *v1; // r4

  v0 = malloc(4u);
  *v0 = CSetPieces::NumSetPieces;
  CGenericGameStorage::_SaveDataToWorkBuffer(v0, 4);
  free(v0);
  v1 = (CSetPiece *)malloc(0x1A40u);
  qmemcpy(v1, CSetPieces::aSetPieces, 0x1A40u);
  CGenericGameStorage::_SaveDataToWorkBuffer(v1, 6720);
  free(v1);
  return 1;
}

//----- (0048E1AC) --------------------------------------------------------
int CSetPieces::Load()
{
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CSetPieces::NumSetPieces, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(CSetPieces::aSetPieces, 6720);
  return 1;
}

//----- (0048E1D8) --------------------------------------------------------
int CPedType::Save()
{
  int i; // r6
  uint32 Acquaintances; // r4
  _DWORD *v2; // r5
  uint32 v3; // r4
  _DWORD *v4; // r5
  uint32 v5; // r4
  _DWORD *v6; // r5
  uint32 v7; // r4
  _DWORD *v8; // r5
  uint32 v9; // r4
  _DWORD *v10; // r5

  for ( i = 0; i != 32; ++i )
  {
    Acquaintances = CAcquaintance::GetAcquaintances(&CPedType::ms_apPedTypes[i].m_acquaintances, 0);
    v2 = malloc(4u);
    *v2 = Acquaintances;
    CGenericGameStorage::_SaveDataToWorkBuffer(v2, 4);
    free(v2);
    v3 = CAcquaintance::GetAcquaintances(&CPedType::ms_apPedTypes[i].m_acquaintances, 1);
    v4 = malloc(4u);
    *v4 = v3;
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    free(v4);
    v5 = CAcquaintance::GetAcquaintances(&CPedType::ms_apPedTypes[i].m_acquaintances, 2);
    v6 = malloc(4u);
    *v6 = v5;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
    free(v6);
    v7 = CAcquaintance::GetAcquaintances(&CPedType::ms_apPedTypes[i].m_acquaintances, 3);
    v8 = malloc(4u);
    *v8 = v7;
    CGenericGameStorage::_SaveDataToWorkBuffer(v8, 4);
    free(v8);
    v9 = CAcquaintance::GetAcquaintances(&CPedType::ms_apPedTypes[i].m_acquaintances, 4);
    v10 = malloc(4u);
    *v10 = v9;
    CGenericGameStorage::_SaveDataToWorkBuffer(v10, 4);
    free(v10);
  }
  return 1;
}

//----- (0048E2B4) --------------------------------------------------------
int CPedType::Load()
{
  int i; // r5
  uint32 pData[5]; // [sp+4h] [bp-14h] BYREF

  for ( i = 0; i != 32; ++i )
  {
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
    CAcquaintance::SetAcquaintances(&CPedType::ms_apPedTypes[i].m_acquaintances, 0, pData[0]);
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
    CAcquaintance::SetAcquaintances(&CPedType::ms_apPedTypes[i].m_acquaintances, 1, pData[0]);
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
    CAcquaintance::SetAcquaintances(&CPedType::ms_apPedTypes[i].m_acquaintances, 2, pData[0]);
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
    CAcquaintance::SetAcquaintances(&CPedType::ms_apPedTypes[i].m_acquaintances, 3, pData[0]);
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
    CAcquaintance::SetAcquaintances(&CPedType::ms_apPedTypes[i].m_acquaintances, 4, pData[0]);
  }
  return 1;
}

//----- (0048E344) --------------------------------------------------------
int CTagManager::Save()
{
  _DWORD *v0; // r4
  uint32 v1; // r5
  uint8 *p_m_alpha; // r4

  v0 = malloc(4u);
  *v0 = CTagManager::ms_numTags;
  CGenericGameStorage::_SaveDataToWorkBuffer(v0, 4);
  free(v0);
  if ( CTagManager::ms_numTags )
  {
    v1 = 0;
    p_m_alpha = &CTagManager::ms_tagDesc[0].m_alpha;
    do
    {
      CGenericGameStorage::_SaveDataToWorkBuffer(p_m_alpha, 1);
      ++v1;
      p_m_alpha += 8;
    }
    while ( v1 < CTagManager::ms_numTags );
  }
  return 1;
}

//----- (0048E3A8) --------------------------------------------------------
int CTagManager::Load()
{
  uint32 v0; // r5
  uint8 *p_m_alpha; // r4

  CGenericGameStorage::_LoadDataFromWorkBuffer(&CTagManager::ms_numTags, 4);
  if ( CTagManager::ms_numTags )
  {
    v0 = 0;
    p_m_alpha = &CTagManager::ms_tagDesc[0].m_alpha;
    do
    {
      CGenericGameStorage::_LoadDataFromWorkBuffer(p_m_alpha, 1);
      ++v0;
      p_m_alpha += 8;
    }
    while ( v0 < CTagManager::ms_numTags );
  }
  return 1;
}

//----- (0048E3F8) --------------------------------------------------------
int CIplStore::Save()
{
  _DWORD *v0; // r4
  int v1; // r5
  int v2; // r6
  uint8 *v3; // r0
  bool v4; // r0
  char pData[17]; // [sp+7h] [bp-11h] BYREF

  v0 = malloc(4u);
  *v0 = 256;
  CGenericGameStorage::_SaveDataToWorkBuffer(v0, 4);
  free(v0);
  v1 = 1;
  v2 = 0;
  do
  {
    v4 = (CIplStore::ms_pPool->m_aFlags[v1] & 0x80u) == 0
      && (v3 = CIplStore::ms_pPool->m_aStorage[v2], v3[97])
      && v3[99] != 0;
    pData[0] = v4;
    CGenericGameStorage::_SaveDataToWorkBuffer(pData, 1);
    ++v1;
    ++v2;
  }
  while ( v1 != 256 );
  return 1;
}
// 48E3F8: using guessed type char pData[17];

//----- (0048E474) --------------------------------------------------------
int CIplStore::Load()
{
  int32 v0; // r4
  int v1; // r6
  CPool<IplDef,IplDef>::StorageType *m_aStorage; // r5
  char v4; // [sp+3h] [bp-1Dh] BYREF
  char pData[28]; // [sp+4h] [bp-1Ch] BYREF

  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  v0 = 1;
  v1 = 0;
  do
  {
    if ( (char)CIplStore::ms_pPool->m_aFlags[v0] <= -1 )
    {
      CGenericGameStorage::_LoadDataFromWorkBuffer(&v4, 1);
    }
    else
    {
      m_aStorage = CIplStore::ms_pPool->m_aStorage;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&v4, 1);
      if ( v4 )
      {
        CIplStore::RequestIplAndIgnore(v0);
      }
      else if ( m_aStorage[v1 + 1][45] && m_aStorage[v1 + 1][47] )
      {
        CIplStore::RemoveIplAndIgnore(v0);
      }
    }
    ++v0;
    ++v1;
  }
  while ( v0 != 256 );
  return 1;
}
// 48E474: using guessed type char pData[28];

//----- (0048E4F4) --------------------------------------------------------
int CShopping::Save()
{
  _DWORD *v0; // r4
  unsigned int v1; // r6
  CShopping::PriceModifier *v2; // r5
  _QWORD *v3; // r4
  _DWORD *v4; // r4

  v0 = malloc(4u);
  *v0 = CShopping::ms_numPriceModifiers;
  CGenericGameStorage::_SaveDataToWorkBuffer(v0, 4);
  free(v0);
  if ( CShopping::ms_numPriceModifiers )
  {
    v1 = 0;
    v2 = CShopping::ms_priceModifiers;
    do
    {
      v3 = malloc(8u);
      *v3 = *v2;
      CGenericGameStorage::_SaveDataToWorkBuffer(v3, 8);
      free(v3);
      ++v1;
      ++v2;
    }
    while ( v1 < CShopping::ms_numPriceModifiers );
  }
  v4 = malloc(4u);
  *v4 = CShopping::ms_numBuyableItems;
  CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
  free(v4);
  CGenericGameStorage::_SaveDataToWorkBuffer(CShopping::ms_bHasBought, CShopping::ms_numBuyableItems);
  return 1;
}

//----- (0048E5A4) --------------------------------------------------------
int CShopping::Load()
{
  unsigned int v0; // r5
  CShopping::PriceModifier *v1; // r4

  CGenericGameStorage::_LoadDataFromWorkBuffer(&CShopping::ms_numPriceModifiers, 4);
  if ( CShopping::ms_numPriceModifiers )
  {
    v0 = 0;
    v1 = CShopping::ms_priceModifiers;
    do
    {
      CGenericGameStorage::_LoadDataFromWorkBuffer(v1, 8);
      ++v0;
      ++v1;
    }
    while ( v0 < CShopping::ms_numPriceModifiers );
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CShopping::ms_numBuyableItems, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(CShopping::ms_bHasBought, CShopping::ms_numBuyableItems);
  return 1;
}

//----- (0048E614) --------------------------------------------------------
int CGangWars::Save()
{
  int v0; // r6
  int v1; // r1
  int v2; // r5
  int v3; // r1
  UInt32 v4; // r9
  Int32 v5; // r10
  Int32 v6; // r11
  Int32 v7; // r8
  _DWORD *v8; // r4
  char *v9; // r4
  Int32 v11; // [sp+0h] [bp-78h]
  float v12; // [sp+4h] [bp-74h]
  Int32 v13; // [sp+8h] [bp-70h]
  Int32 v14; // [sp+Ch] [bp-6Ch]
  bool v15; // [sp+10h] [bp-68h]
  float v16; // [sp+14h] [bp-64h]
  float v17; // [sp+18h] [bp-60h]
  bool v18; // [sp+1Ch] [bp-5Ch]
  bool v19; // [sp+20h] [bp-58h]
  Int32 v20; // [sp+24h] [bp-54h]
  bool v21; // [sp+28h] [bp-50h]
  Int32 v22; // [sp+2Ch] [bp-4Ch]
  UInt32 v23; // [sp+30h] [bp-48h]
  __int16 v24; // [sp+35h] [bp-43h]
  char v25; // [sp+37h] [bp-41h]
  CVector v26; // [sp+38h] [bp-40h]
  CVector v27; // [sp+48h] [bp-30h]
  __int16 v28; // [sp+59h] [bp-1Fh]
  char v29; // [sp+5Bh] [bp-1Dh]

  if ( CGangWars::pZoneInfoToFightOver && CTheZones::TotalNumberOfZoneInfos )
  {
    v0 = 0;
    v1 = (char *)CGangWars::pZoneInfoToFightOver - (char *)CTheZones::ZoneInfoArray + 17;
    while ( 1 )
    {
      v1 -= 17;
      if ( !v1 )
        break;
      if ( ++v0 >= CTheZones::TotalNumberOfZoneInfos )
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    v0 = -1;
  }
  v23 = CGangWars::TimeStarted;
  v21 = CGangWars::bGangWarsActive;
  v22 = CGangWars::State;
  if ( CGangWars::pZoneToFightOver && CTheZones::TotalNumberOfNavigationZones )
  {
    v2 = 0;
    v3 = (char *)CGangWars::pZoneToFightOver - (char *)CTheZones::NavigationZoneArray + 32;
    while ( 1 )
    {
      v3 -= 32;
      if ( !v3 )
        break;
      if ( ++v2 >= CTheZones::TotalNumberOfNavigationZones )
        goto LABEL_12;
    }
  }
  else
  {
LABEL_12:
    v2 = -1;
  }
  v17 = CGangWars::Difficulty;
  v16 = CGangWars::TerritoryUnderControlPercentage;
  v27 = CGangWars::CoorsOfPlayerAtStartOfWar;
  v26 = CGangWars::PointOfAttack;
  v20 = CGangWars::ZoneInfoForTraining;
  v15 = CGangWars::bPlayerIsCloseby;
  v19 = CGangWars::bTrainingMission;
  v18 = CGangWars::bCanTriggerGangWarWhenOnAMission;
  v14 = CGangWars::RadarBlip;
  v13 = CGangWars::FightTimer;
  v12 = CGangWars::TimeTillNextAttack;
  v11 = CGangWars::State2;
  v4 = CGangWars::LastTimeInArea;
  v5 = CGangWars::WarFerocity;
  v6 = CGangWars::Gang2;
  v7 = CGangWars::Gang1;
  v8 = malloc(4u);
  *v8 = 96;
  CGenericGameStorage::_SaveDataToWorkBuffer(v8, 4);
  free(v8);
  v9 = (char *)malloc(0x60u);
  *v9 = v21;
  v9[3] = v29;
  *((_DWORD *)v9 + 1) = v22;
  *((_DWORD *)v9 + 2) = v23;
  *((_DWORD *)v9 + 3) = v0;
  *((_DWORD *)v9 + 4) = v2;
  *(_WORD *)(v9 + 1) = v28;
  *((_DWORD *)v9 + 8) = v7;
  *((_DWORD *)v9 + 9) = v6;
  *((_DWORD *)v9 + 10) = v5;
  *((_DWORD *)v9 + 11) = v4;
  *((_DWORD *)v9 + 12) = v11;
  *((float *)v9 + 13) = v12;
  *(CVector *)(v9 + 20) = v27;
  *((_DWORD *)v9 + 16) = LODWORD(v26.z);
  *((_DWORD *)v9 + 17) = v13;
  *((_DWORD *)v9 + 18) = v14;
  v9[76] = v15;
  *((_QWORD *)v9 + 7) = *(_QWORD *)&v26.x;
  v9[79] = v25;
  *(_WORD *)(v9 + 77) = v24;
  *((float *)v9 + 20) = v16;
  *((float *)v9 + 21) = v17;
  v9[88] = v18;
  v9[89] = v19;
  *((_DWORD *)v9 + 23) = v20;
  CGenericGameStorage::_SaveDataToWorkBuffer(v9, 96);
  free(v9);
  return 1;
}
// 48E792: variable 'v29' is possibly undefined
// 48E7A4: variable 'v28' is possibly undefined
// 48E7F2: variable 'v25' is possibly undefined
// 48E7FA: variable 'v24' is possibly undefined

//----- (0048E890) --------------------------------------------------------
int CGangWars::Load()
{
  CZone *v0; // r0
  CZoneInfo *v1; // r0
  char v3[4]; // [sp+0h] [bp-78h] BYREF
  Int32 v4; // [sp+4h] [bp-74h]
  UInt32 v5; // [sp+8h] [bp-70h]
  int v6; // [sp+Ch] [bp-6Ch]
  int v7; // [sp+10h] [bp-68h]
  CVector v8; // [sp+14h] [bp-64h]
  Int32 v9; // [sp+20h] [bp-58h]
  Int32 v10; // [sp+24h] [bp-54h]
  Int32 v11; // [sp+28h] [bp-50h]
  UInt32 v12; // [sp+2Ch] [bp-4Ch]
  Int32 v13; // [sp+30h] [bp-48h]
  float v14; // [sp+34h] [bp-44h]
  CVector v15; // [sp+38h] [bp-40h]
  Int32 v16; // [sp+44h] [bp-34h]
  Int32 v17; // [sp+48h] [bp-30h]
  bool v18; // [sp+4Ch] [bp-2Ch]
  float v19; // [sp+50h] [bp-28h]
  float v20; // [sp+54h] [bp-24h]
  bool v21; // [sp+58h] [bp-20h]
  bool v22; // [sp+59h] [bp-1Fh]
  Int32 v23; // [sp+5Ch] [bp-1Ch]
  char pData[20]; // [sp+64h] [bp-14h] BYREF

  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(v3, 96);
  CGangWars::CoorsOfPlayerAtStartOfWar = v8;
  CGangWars::Gang1 = v9;
  CGangWars::Gang2 = v10;
  CGangWars::bGangWarsActive = v3[0];
  CGangWars::State = v4;
  CGangWars::TimeStarted = v5;
  v0 = &CTheZones::NavigationZoneArray[v7];
  if ( v7 == -1 )
    v0 = 0;
  CGangWars::pZoneToFightOver = v0;
  v1 = &CTheZones::ZoneInfoArray[v6];
  if ( v6 == -1 )
    v1 = 0;
  CGangWars::pZoneInfoToFightOver = v1;
  CGangWars::WarFerocity = v11;
  CGangWars::LastTimeInArea = v12;
  CGangWars::State2 = v13;
  CGangWars::TimeTillNextAttack = v14;
  CGangWars::PointOfAttack = v15;
  CGangWars::FightTimer = v16;
  CGangWars::RadarBlip = v17;
  CGangWars::bPlayerIsCloseby = v18;
  CGangWars::TerritoryUnderControlPercentage = v19;
  CGangWars::Difficulty = v20;
  CGangWars::bCanTriggerGangWarWhenOnAMission = v21;
  CGangWars::bTrainingMission = v22;
  CGangWars::ZoneInfoForTraining = v23;
  return 1;
}
// 6784B4: using guessed type char *CGangWars::bCanTriggerGangWarWhenOnAMission[2];
// 48E890: using guessed type char pData[20];
// 48E890: using guessed type char var_78[4];

//----- (0048EA2C) --------------------------------------------------------
int CStuntJumpManager::Save()
{
  _DWORD *v0; // r4
  int v1; // r5
  int i; // r6
  CPool<CStuntJump,CStuntJump>::StorageType *m_aStorage; // r9
  uint8 *v4; // r4

  v0 = malloc(4u);
  *v0 = CStuntJumpManager::m_iNumJumps;
  CGenericGameStorage::_SaveDataToWorkBuffer(v0, 4);
  free(v0);
  v1 = 0;
  for ( i = 0; i != 256; ++i )
  {
    if ( (CStuntJumpManager::mp_poolStuntJumps->m_aFlags[i] & 0x80u) == 0 )
    {
      m_aStorage = CStuntJumpManager::mp_poolStuntJumps->m_aStorage;
      v4 = (uint8 *)malloc(0x44u);
      qmemcpy(v4, m_aStorage[v1], 0x44u);
      CGenericGameStorage::_SaveDataToWorkBuffer(v4, 68);
      free(v4);
    }
    ++v1;
  }
  return 1;
}

//----- (0048EAAC) --------------------------------------------------------
int CStuntJumpManager::Load()
{
  int32 v0; // r0
  int v1; // r4
  CStuntJumpPool *v2; // r1
  int v3; // r3
  uint8 *m_nFreeIndex; // r0
  int32 m_nSize; // r2
  uint8 *m_aFlags; // r5
  int v7; // r6
  int pData[5]; // [sp+4h] [bp-14h] BYREF

  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  v0 = pData[0];
  if ( pData[0] >= 1 )
  {
    v1 = 0;
    do
    {
      v2 = CStuntJumpManager::mp_poolStuntJumps;
      v3 = 0;
      m_nFreeIndex = (uint8 *)CStuntJumpManager::mp_poolStuntJumps->m_nFreeIndex;
      m_nSize = CStuntJumpManager::mp_poolStuntJumps->m_nSize;
      do
      {
        v2->m_nFreeIndex = (int32)++m_nFreeIndex;
        if ( m_nFreeIndex == (uint8 *)m_nSize )
        {
          m_nFreeIndex = 0;
          v2->m_nFreeIndex = 0;
          if ( v3 << 31 )
            goto LABEL_9;
          v3 = 1;
        }
        m_aFlags = v2->m_aFlags;
        v7 = (char)m_nFreeIndex[(_DWORD)m_aFlags];
      }
      while ( v7 > -1 );
      m_nFreeIndex[(_DWORD)m_aFlags] = v7 & 0x7F;
      v2->m_aFlags[v2->m_nFreeIndex] = (v2->m_aFlags[v2->m_nFreeIndex] + 1) & 0x7F | v2->m_aFlags[v2->m_nFreeIndex] & 0x80;
      m_nFreeIndex = v2->m_aStorage[v2->m_nFreeIndex];
LABEL_9:
      CGenericGameStorage::_LoadDataFromWorkBuffer(m_nFreeIndex, 68);
      v0 = pData[0];
      ++v1;
    }
    while ( v1 < pData[0] );
  }
  CStuntJumpManager::m_iNumJumps = v0;
  return 1;
}
// 48EAAC: using guessed type int pData[5];

//----- (0048EB44) --------------------------------------------------------
int CEntryExitManager::Save()
{
  _DWORD *v0; // r4
  int32 v1; // r5
  unsigned int v2; // r6
  _WORD *v3; // r4
  int v4; // r6
  int v5; // r5
  uint8 *m_aFlags; // r1
  uint8 *v7; // r8
  int v8; // r2
  __int16 v9; // r10
  int v10; // r3
  int32 v11; // r3
  _WORD *v12; // r4
  _WORD *v13; // r4
  _WORD *v14; // r4
  _WORD *v15; // r4

  v0 = malloc(4u);
  *v0 = CEntryExitManager::ms_entryExitStackPosn;
  CGenericGameStorage::_SaveDataToWorkBuffer(v0, 4);
  free(v0);
  if ( CEntryExitManager::ms_entryExitStackPosn >= 1 )
  {
    v1 = 0;
    do
    {
      v2 = -286331153
         * ((unsigned int)((char *)CEntryExitManager::ms_entryExitStack[v1]
                         - (char *)CEntryExitManager::mp_poolEntryExits->m_aStorage) >> 2);
      v3 = malloc(2u);
      *v3 = v2;
      CGenericGameStorage::_SaveDataToWorkBuffer(v3, 2);
      free(v3);
      ++v1;
    }
    while ( v1 < CEntryExitManager::ms_entryExitStackPosn );
  }
  v4 = 0;
  v5 = 0;
  do
  {
    m_aFlags = CEntryExitManager::mp_poolEntryExits->m_aFlags;
    if ( (m_aFlags[v5] & 0x80u) == 0 )
    {
      v7 = CEntryExitManager::mp_poolEntryExits->m_aStorage[v4];
      if ( v7 )
      {
        v8 = *((_DWORD *)v7 + 14);
        v9 = -1;
        if ( v8 )
        {
          v10 = v8 - (unsigned int)CEntryExitManager::mp_poolEntryExits->m_aStorage;
          v9 = -1;
          if ( v10 >= 0 )
          {
            v9 = -1;
            v11 = -286331153 * (v10 >> 2);
            if ( v11 < CEntryExitManager::mp_poolEntryExits->m_nSize )
            {
              v9 = -1;
              if ( (m_aFlags[v11] & 0x80u) == 0 )
                v9 = -4369 * ((signed int)(v8 - (unsigned int)CEntryExitManager::mp_poolEntryExits->m_aStorage) >> 2);
            }
          }
        }
        v12 = malloc(2u);
        *v12 = v5;
        CGenericGameStorage::_SaveDataToWorkBuffer(v12, 2);
        free(v12);
        v13 = malloc(2u);
        *v13 = *((_WORD *)v7 + 24);
        CGenericGameStorage::_SaveDataToWorkBuffer(v13, 2);
        free(v13);
        v14 = malloc(2u);
        *v14 = v9;
        CGenericGameStorage::_SaveDataToWorkBuffer(v14, 2);
        free(v14);
      }
    }
    ++v4;
    ++v5;
  }
  while ( v4 != 455 );
  v15 = malloc(2u);
  *v15 = -1;
  CGenericGameStorage::_SaveDataToWorkBuffer(v15, 2);
  free(v15);
  return 1;
}

//----- (0048ECC0) --------------------------------------------------------
int CEntryExitManager::Load()
{
  int v0; // r4
  int32 i; // r5
  CEntryExit *v2; // r0
  int32 v3; // r4
  __int16 j; // r0
  uint8 *v5; // r6
  uint8 *v6; // r0
  __int16 v8; // [sp+6h] [bp-22h] BYREF
  unsigned __int16 v9; // [sp+8h] [bp-20h] BYREF
  __int16 pData[15]; // [sp+Ah] [bp-1Eh] BYREF

  CGenericGameStorage::_LoadDataFromWorkBuffer(&CEntryExitManager::ms_entryExitStackPosn, 4);
  v0 = CEntryExitManager::ms_entryExitStackPosn;
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
  if ( v0 >= 1 )
  {
    for ( i = 0; i < v3; ++i )
    {
      if ( (CEntryExitManager::mp_poolEntryExits->m_aFlags[pData[0]] & 0x80u) != 0 )
        v2 = 0;
      else
        v2 = (CEntryExit *)CEntryExitManager::mp_poolEntryExits->m_aStorage[pData[0]];
      CEntryExitManager::ms_entryExitStack[i] = v2;
      v3 = CEntryExitManager::ms_entryExitStackPosn;
      CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    }
  }
  for ( j = pData[0]; (unsigned __int16)pData[0] != 0xFFFF; j = pData[0] )
  {
    if ( (CEntryExitManager::mp_poolEntryExits->m_aFlags[j] & 0x80u) != 0 )
      v5 = 0;
    else
      v5 = CEntryExitManager::mp_poolEntryExits->m_aStorage[j];
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v8, 2);
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v9, 2);
    if ( v5 )
    {
      *((_WORD *)v5 + 24) = v8;
      if ( v9 == 0xFFFF || (CEntryExitManager::mp_poolEntryExits->m_aFlags[(__int16)v9] & 0x80u) != 0 )
        v6 = 0;
      else
        v6 = CEntryExitManager::mp_poolEntryExits->m_aStorage[(__int16)v9];
      *((_DWORD *)v5 + 14) = v6;
    }
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
  }
  return 1;
}

//----- (0048EDE8) --------------------------------------------------------
int CAERadioTrackManager::Save()
{
  int v0; // r8
  Int32 (*v1)[40]; // r9
  Int32 (*v2)[15]; // r6
  Int8 *v3; // r4
  _DWORD *v4; // r4
  Int32 *v5; // r11
  _DWORD *v6; // r4
  _DWORD *v7; // r4
  _DWORD *v8; // r4
  _DWORD *v9; // r4
  _DWORD *v10; // r4
  _DWORD *v11; // r4
  _DWORD *v12; // r4
  int i; // r5
  _DWORD *v14; // r4
  int j; // r5
  _DWORD *v16; // r4

  v0 = 0;
  v1 = CAERadioTrackManager::m_nAdvertIndexHistory;
  v2 = CAERadioTrackManager::m_nDJBanterIndexHistory;
  do
  {
    v3 = &CAERadioTrackManager::m_nMusicTrackIndexHistory[20 * v0];
    CGenericGameStorage::_SaveDataToWorkBuffer(v3, 1);
    CGenericGameStorage::_SaveDataToWorkBuffer(v3 + 1, 1);
    CGenericGameStorage::_SaveDataToWorkBuffer(v3 + 2, 1);
    CGenericGameStorage::_SaveDataToWorkBuffer(v3 + 3, 1);
    CGenericGameStorage::_SaveDataToWorkBuffer(v3 + 4, 1);
    CGenericGameStorage::_SaveDataToWorkBuffer(v3 + 5, 1);
    CGenericGameStorage::_SaveDataToWorkBuffer(v3 + 6, 1);
    CGenericGameStorage::_SaveDataToWorkBuffer(v3 + 7, 1);
    CGenericGameStorage::_SaveDataToWorkBuffer(v3 + 8, 1);
    CGenericGameStorage::_SaveDataToWorkBuffer(v3 + 9, 1);
    CGenericGameStorage::_SaveDataToWorkBuffer(v3 + 10, 1);
    CGenericGameStorage::_SaveDataToWorkBuffer(v3 + 11, 1);
    CGenericGameStorage::_SaveDataToWorkBuffer(v3 + 12, 1);
    CGenericGameStorage::_SaveDataToWorkBuffer(v3 + 13, 1);
    CGenericGameStorage::_SaveDataToWorkBuffer(v3 + 14, 1);
    CGenericGameStorage::_SaveDataToWorkBuffer(v3 + 15, 1);
    CGenericGameStorage::_SaveDataToWorkBuffer(v3 + 16, 1);
    CGenericGameStorage::_SaveDataToWorkBuffer(v3 + 17, 1);
    CGenericGameStorage::_SaveDataToWorkBuffer(v3 + 18, 1);
    CGenericGameStorage::_SaveDataToWorkBuffer(v3 + 19, 1);
    v4 = malloc(4u);
    *v4 = CAERadioTrackManager::m_nIdentIndexHistory[v0][0];
    CGenericGameStorage::_SaveDataToWorkBuffer(v4, 4);
    free(v4);
    v5 = CAERadioTrackManager::m_nIdentIndexHistory[v0];
    v6 = malloc(4u);
    *v6 = v5[1];
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
    free(v6);
    v7 = malloc(4u);
    *v7 = v5[2];
    CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
    free(v7);
    v8 = malloc(4u);
    *v8 = v5[3];
    CGenericGameStorage::_SaveDataToWorkBuffer(v8, 4);
    free(v8);
    v9 = malloc(4u);
    *v9 = v5[4];
    CGenericGameStorage::_SaveDataToWorkBuffer(v9, 4);
    free(v9);
    v10 = malloc(4u);
    *v10 = v5[5];
    CGenericGameStorage::_SaveDataToWorkBuffer(v10, 4);
    free(v10);
    v11 = malloc(4u);
    *v11 = v5[6];
    CGenericGameStorage::_SaveDataToWorkBuffer(v11, 4);
    free(v11);
    v12 = malloc(4u);
    *v12 = v5[7];
    CGenericGameStorage::_SaveDataToWorkBuffer(v12, 4);
    free(v12);
    for ( i = 0; i != 40; ++i )
    {
      v14 = malloc(4u);
      *v14 = (*v1)[i];
      CGenericGameStorage::_SaveDataToWorkBuffer(v14, 4);
      free(v14);
    }
    for ( j = 0; j != 15; ++j )
    {
      v16 = malloc(4u);
      *v16 = (*v2)[j];
      CGenericGameStorage::_SaveDataToWorkBuffer(v16, 4);
      free(v16);
    }
    ++v0;
    ++v2;
    ++v1;
  }
  while ( v0 != 14 );
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nStatsCitiesPassed, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nStatsPassedCasino3, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nStatsPassedCasino6, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nStatsPassedCasino10, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nStatsPassedCat1, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nStatsPassedDesert1, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nStatsPassedDesert3, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nStatsPassedDesert5, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nStatsPassedDesert8, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nStatsPassedDesert10, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nStatsPassedFarlie3, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nStatsPassedLAFin2, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nStatsPassedMansion2, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nStatsPassedRyder2, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nStatsPassedRiot1, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nStatsPassedSCrash1, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nStatsPassedStrap4, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nStatsPassedSweet2, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nStatsPassedTruth2, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nStatsPassedVCrash2, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nStatsStartedBadlands, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nStatsStartedCat2, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nStatsStartedCrash1, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nStatsLastHitGameClockDays, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nStatsLastHitGameClockHours, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nStatsLastHitTimeOutHours, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nSpecialDJBanterPending, 1);
  CGenericGameStorage::_SaveDataToWorkBuffer(&CAERadioTrackManager::m_nSpecialDJBanterIndex, 1);
  return 1;
}

//----- (0048F1F4) --------------------------------------------------------
int CAERadioTrackManager::Load()
{
  int v0; // r6
  Int32 (*v1)[40]; // r5
  Int8 *v2; // r4
  Int32 *v3; // r4
  int i; // r4
  Int32 *v5; // r4

  v0 = 0;
  v1 = CAERadioTrackManager::m_nAdvertIndexHistory;
  do
  {
    v2 = &CAERadioTrackManager::m_nMusicTrackIndexHistory[20 * v0];
    CGenericGameStorage::_LoadDataFromWorkBuffer(v2, 1);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v2 + 1, 1);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v2 + 2, 1);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v2 + 3, 1);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v2 + 4, 1);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v2 + 5, 1);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v2 + 6, 1);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v2 + 7, 1);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v2 + 8, 1);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v2 + 9, 1);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v2 + 10, 1);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v2 + 11, 1);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v2 + 12, 1);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v2 + 13, 1);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v2 + 14, 1);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v2 + 15, 1);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v2 + 16, 1);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v2 + 17, 1);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v2 + 18, 1);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v2 + 19, 1);
    v3 = CAERadioTrackManager::m_nIdentIndexHistory[v0];
    CGenericGameStorage::_LoadDataFromWorkBuffer(v3, 4);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v3 + 1, 4);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v3 + 2, 4);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v3 + 3, 4);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v3 + 4, 4);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v3 + 5, 4);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v3 + 6, 4);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v3 + 7, 4);
    for ( i = 0; i != 40; ++i )
      CGenericGameStorage::_LoadDataFromWorkBuffer(&(*v1)[i], 4);
    v5 = CAERadioTrackManager::m_nDJBanterIndexHistory[v0];
    CGenericGameStorage::_LoadDataFromWorkBuffer(v5, 4);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v5 + 1, 4);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v5 + 2, 4);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v5 + 3, 4);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v5 + 4, 4);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v5 + 5, 4);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v5 + 6, 4);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v5 + 7, 4);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v5 + 8, 4);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v5 + 9, 4);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v5 + 10, 4);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v5 + 11, 4);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v5 + 12, 4);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v5 + 13, 4);
    CGenericGameStorage::_LoadDataFromWorkBuffer(v5 + 14, 4);
    ++v0;
    ++v1;
  }
  while ( v0 != 14 );
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nStatsCitiesPassed, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nStatsPassedCasino3, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nStatsPassedCasino6, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nStatsPassedCasino10, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nStatsPassedCat1, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nStatsPassedDesert1, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nStatsPassedDesert3, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nStatsPassedDesert5, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nStatsPassedDesert8, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nStatsPassedDesert10, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nStatsPassedFarlie3, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nStatsPassedLAFin2, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nStatsPassedMansion2, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nStatsPassedRyder2, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nStatsPassedRiot1, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nStatsPassedSCrash1, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nStatsPassedStrap4, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nStatsPassedSweet2, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nStatsPassedTruth2, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nStatsPassedVCrash2, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nStatsStartedBadlands, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nStatsStartedCat2, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nStatsStartedCrash1, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nStatsLastHitGameClockDays, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nStatsLastHitGameClockHours, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nStatsLastHitTimeOutHours, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nSpecialDJBanterPending, 1);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&CAERadioTrackManager::m_nSpecialDJBanterIndex, 1);
  return 1;
}

//----- (0048F5B8) --------------------------------------------------------
int C3dMarkers::LoadUser3dMarkers()
{
  CGenericGameStorage::_LoadDataFromWorkBuffer(C3dMarkers::ms_user3dMarkers, 28);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&C3dMarkers::ms_user3dMarkers[1], 28);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&C3dMarkers::ms_user3dMarkers[2], 28);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&C3dMarkers::ms_user3dMarkers[3], 28);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&C3dMarkers::ms_user3dMarkers[4], 28);
  return 1;
}

//----- (0048F5FC) --------------------------------------------------------
int C3dMarkers::SaveUser3dMarkers()
{
  _QWORD *v0; // r4
  __int64 v1; // d17
  __int64 v2; // d18
  __int64 v3; // d19
  _QWORD *v4; // r4
  __int64 v5; // d16
  __int64 v6; // d17
  __int64 v7; // d19
  _QWORD *v8; // r4
  __int64 v9; // d16
  __int64 v10; // d17
  __int64 v11; // d19
  _QWORD *v12; // r4
  __int64 v13; // d16
  __int64 v14; // d17
  __int64 v15; // d19
  _QWORD *v16; // r4
  __int64 v17; // d16
  __int64 v18; // d17
  __int64 v19; // d19

  v0 = malloc(0x1Cu);
  v1 = *(_QWORD *)&C3dMarkers::ms_user3dMarkers[0].pos.y;
  v2 = *(_QWORD *)&C3dMarkers::ms_user3dMarkers[0].pos.z;
  v3 = *(_QWORD *)&C3dMarkers::ms_user3dMarkers[0].g;
  *v0 = *(_QWORD *)&C3dMarkers::ms_user3dMarkers[0].bActive;
  v0[1] = v1;
  *(_QWORD *)((char *)v0 + 12) = v2;
  *(_QWORD *)((char *)v0 + 20) = v3;
  CGenericGameStorage::_SaveDataToWorkBuffer(v0, 28);
  free(v0);
  v4 = malloc(0x1Cu);
  v5 = *(_QWORD *)&C3dMarkers::ms_user3dMarkers[1].bActive;
  v6 = *(_QWORD *)&C3dMarkers::ms_user3dMarkers[1].pos.y;
  v7 = *(_QWORD *)&C3dMarkers::ms_user3dMarkers[1].g;
  *(_QWORD *)((char *)v4 + 12) = *(_QWORD *)&C3dMarkers::ms_user3dMarkers[1].pos.z;
  *(_QWORD *)((char *)v4 + 20) = v7;
  *v4 = v5;
  v4[1] = v6;
  CGenericGameStorage::_SaveDataToWorkBuffer(v4, 28);
  free(v4);
  v8 = malloc(0x1Cu);
  v9 = *(_QWORD *)&C3dMarkers::ms_user3dMarkers[2].bActive;
  v10 = *(_QWORD *)&C3dMarkers::ms_user3dMarkers[2].pos.y;
  v11 = *(_QWORD *)&C3dMarkers::ms_user3dMarkers[2].g;
  *(_QWORD *)((char *)v8 + 12) = *(_QWORD *)&C3dMarkers::ms_user3dMarkers[2].pos.z;
  *(_QWORD *)((char *)v8 + 20) = v11;
  *v8 = v9;
  v8[1] = v10;
  CGenericGameStorage::_SaveDataToWorkBuffer(v8, 28);
  free(v8);
  v12 = malloc(0x1Cu);
  v13 = *(_QWORD *)&C3dMarkers::ms_user3dMarkers[3].bActive;
  v14 = *(_QWORD *)&C3dMarkers::ms_user3dMarkers[3].pos.y;
  v15 = *(_QWORD *)&C3dMarkers::ms_user3dMarkers[3].g;
  *(_QWORD *)((char *)v12 + 12) = *(_QWORD *)&C3dMarkers::ms_user3dMarkers[3].pos.z;
  *(_QWORD *)((char *)v12 + 20) = v15;
  *v12 = v13;
  v12[1] = v14;
  CGenericGameStorage::_SaveDataToWorkBuffer(v12, 28);
  free(v12);
  v16 = malloc(0x1Cu);
  v17 = *(_QWORD *)&C3dMarkers::ms_user3dMarkers[4].bActive;
  v18 = *(_QWORD *)&C3dMarkers::ms_user3dMarkers[4].pos.y;
  v19 = *(_QWORD *)&C3dMarkers::ms_user3dMarkers[4].g;
  *(_QWORD *)((char *)v16 + 12) = *(_QWORD *)&C3dMarkers::ms_user3dMarkers[4].pos.z;
  *(_QWORD *)((char *)v16 + 20) = v19;
  *v16 = v17;
  v16[1] = v18;
  CGenericGameStorage::_SaveDataToWorkBuffer(v16, 28);
  free(v16);
  return 1;
}

//----- (0048F704) --------------------------------------------------------
void SaveBriefs()
{
  int i; // r11
  size_t v1; // r5
  bool v2; // r10
  __int16 v3; // r0
  __int16 v4; // r4
  _WORD *v5; // r6
  _DWORD *v6; // r6
  bool v7; // r4
  __int16 v8; // r0
  __int16 v9; // r10
  _WORD *v10; // r6
  bool v11; // r5
  __int16 v12; // r0
  __int16 v13; // r9
  _WORD *v14; // r4
  _DWORD *v15; // r4
  bool v16; // r5
  __int16 v17; // r0
  __int16 v18; // r9
  _WORD *v19; // r4
  _DWORD *v20; // r4
  bool v21; // r5
  __int16 v22; // r0
  __int16 v23; // r9
  _WORD *v24; // r4
  _DWORD *v25; // r4
  bool v26; // r5
  __int16 v27; // r0
  __int16 v28; // r9
  _WORD *v29; // r4
  _DWORD *v30; // r4
  bool v31; // r5
  __int16 v32; // r0
  __int16 v33; // r9
  _WORD *v34; // r4
  _DWORD *v35; // r4
  bool v36; // r5
  __int16 v37; // r0
  __int16 v38; // r9
  _WORD *v39; // r4
  _DWORD *v40; // r4
  Int32 NumberToInsert6; // r0
  bool v42; // r5
  __int16 v43; // r0
  __int16 v44; // r9
  _WORD *v45; // r4

  for ( i = 0; i != 20; ++i )
  {
    if ( !CMessages::PreviousBriefs[i].pMessage )
    {
      v42 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        v43 = currentSaveFenceCount++;
        v44 = v43 + DataFence;
        v45 = malloc(2u);
        *v45 = v44;
        CGenericGameStorage::_SaveDataToWorkBuffer(v45, 2);
        free(v45);
        UseDataFence = v42;
      }
      v40 = malloc(4u);
      NumberToInsert6 = 0;
      goto LABEL_24;
    }
    v1 = strlen((const char *)&CMessages::PreviousBriefs[i]);
    v2 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      v3 = currentSaveFenceCount++;
      v4 = v3 + DataFence;
      v5 = malloc(2u);
      *v5 = v4;
      CGenericGameStorage::_SaveDataToWorkBuffer(v5, 2);
      free(v5);
      UseDataFence = v2;
    }
    v6 = malloc(4u);
    *v6 = v1;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
    free(v6);
    if ( v1 )
    {
      v7 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        v8 = currentSaveFenceCount++;
        v9 = v8 + DataFence;
        v10 = malloc(2u);
        *v10 = v9;
        CGenericGameStorage::_SaveDataToWorkBuffer(v10, 2);
        free(v10);
        UseDataFence = v7;
      }
      CGenericGameStorage::_SaveDataToWorkBuffer(&CMessages::PreviousBriefs[i], v1);
      v11 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        v12 = currentSaveFenceCount++;
        v13 = v12 + DataFence;
        v14 = malloc(2u);
        *v14 = v13;
        CGenericGameStorage::_SaveDataToWorkBuffer(v14, 2);
        free(v14);
        UseDataFence = v11;
      }
      v15 = malloc(4u);
      *v15 = CMessages::PreviousBriefs[i].NumberToInsert;
      CGenericGameStorage::_SaveDataToWorkBuffer(v15, 4);
      free(v15);
      v16 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        v17 = currentSaveFenceCount++;
        v18 = v17 + DataFence;
        v19 = malloc(2u);
        *v19 = v18;
        CGenericGameStorage::_SaveDataToWorkBuffer(v19, 2);
        free(v19);
        UseDataFence = v16;
      }
      v20 = malloc(4u);
      *v20 = CMessages::PreviousBriefs[i].NumberToInsert2;
      CGenericGameStorage::_SaveDataToWorkBuffer(v20, 4);
      free(v20);
      v21 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        v22 = currentSaveFenceCount++;
        v23 = v22 + DataFence;
        v24 = malloc(2u);
        *v24 = v23;
        CGenericGameStorage::_SaveDataToWorkBuffer(v24, 2);
        free(v24);
        UseDataFence = v21;
      }
      v25 = malloc(4u);
      *v25 = CMessages::PreviousBriefs[i].NumberToInsert3;
      CGenericGameStorage::_SaveDataToWorkBuffer(v25, 4);
      free(v25);
      v26 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        v27 = currentSaveFenceCount++;
        v28 = v27 + DataFence;
        v29 = malloc(2u);
        *v29 = v28;
        CGenericGameStorage::_SaveDataToWorkBuffer(v29, 2);
        free(v29);
        UseDataFence = v26;
      }
      v30 = malloc(4u);
      *v30 = CMessages::PreviousBriefs[i].NumberToInsert4;
      CGenericGameStorage::_SaveDataToWorkBuffer(v30, 4);
      free(v30);
      v31 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        v32 = currentSaveFenceCount++;
        v33 = v32 + DataFence;
        v34 = malloc(2u);
        *v34 = v33;
        CGenericGameStorage::_SaveDataToWorkBuffer(v34, 2);
        free(v34);
        UseDataFence = v31;
      }
      v35 = malloc(4u);
      *v35 = CMessages::PreviousBriefs[i].NumberToInsert5;
      CGenericGameStorage::_SaveDataToWorkBuffer(v35, 4);
      free(v35);
      v36 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        v37 = currentSaveFenceCount++;
        v38 = v37 + DataFence;
        v39 = malloc(2u);
        *v39 = v38;
        CGenericGameStorage::_SaveDataToWorkBuffer(v39, 2);
        free(v39);
        UseDataFence = v36;
      }
      v40 = malloc(4u);
      NumberToInsert6 = CMessages::PreviousBriefs[i].NumberToInsert6;
LABEL_24:
      *v40 = NumberToInsert6;
      CGenericGameStorage::_SaveDataToWorkBuffer(v40, 4);
      free(v40);
      continue;
    }
  }
}

//----- (0048FC74) --------------------------------------------------------
void LoadBriefs()
{
  int i; // r8
  bool v1; // r5
  int32 v2; // r1
  CPreviousMessage *v3; // r5
  bool v4; // r10
  bool v5; // r5
  bool v6; // r5
  bool v7; // r5
  bool v8; // r5
  bool v9; // r5
  bool v10; // r5
  int32 pData; // [sp+6Ch] [bp-24h] BYREF
  char v12[30]; // [sp+72h] [bp-1Eh] BYREF

  for ( i = 0; i != 20; ++i )
  {
    v1 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
      UseDataFence = v1;
    }
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
    v2 = pData;
    if ( pData < 1 )
    {
      CMessages::PreviousBriefs[i].TextLabel[0] = 0;
      CMessages::PreviousBriefs[i].pMessage = 0;
    }
    else
    {
      v3 = &CMessages::PreviousBriefs[i];
      *(_DWORD *)CMessages::PreviousBriefs[i].TextLabel = 0;
      *(_DWORD *)&CMessages::PreviousBriefs[i].TextLabel[4] = 0;
      v4 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(v12, 2);
        v2 = pData;
        UseDataFence = v4;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(v3, v2);
      CMessages::PreviousBriefs[i].pMessage = CText::Get(&TheText, v3->TextLabel);
      v5 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(v12, 2);
        UseDataFence = v5;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&CMessages::PreviousBriefs[i].NumberToInsert, 4);
      v6 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(v12, 2);
        UseDataFence = v6;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&CMessages::PreviousBriefs[i].NumberToInsert2, 4);
      v7 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(v12, 2);
        UseDataFence = v7;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&CMessages::PreviousBriefs[i].NumberToInsert3, 4);
      v8 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(v12, 2);
        UseDataFence = v8;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&CMessages::PreviousBriefs[i].NumberToInsert4, 4);
      v9 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(v12, 2);
        UseDataFence = v9;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&CMessages::PreviousBriefs[i].NumberToInsert5, 4);
      v10 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(v12, 2);
        UseDataFence = v10;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&CMessages::PreviousBriefs[i].NumberToInsert6, 4);
    }
  }
}
// 48FC74: using guessed type int32 pData;

//----- (0048FF30) --------------------------------------------------------
void __fastcall CTask::Serialize(CTask *this)
{
  int v1; // r8
  bool v2; // r6
  __int16 v3; // r2
  __int16 v4; // r4
  _WORD *v5; // r5
  _DWORD *v6; // r5

  v1 = (*((int (__fastcall **)(CTask *))this->_vptr$CTask + 5))(this);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    v3 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v4 = v3 + DataFence;
    v5 = malloc(2u);
    *v5 = v4;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 2);
    free(v5);
    UseDataFence = v2;
  }
  v6 = malloc(4u);
  *v6 = v1;
  CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
  j_free(v6);
}

//----- (0048FFB8) --------------------------------------------------------
void CPostEffects::Save()
{
  _DWORD *v0; // r5
  CPostEffectsSaveStructure *v1; // r5
  CPostEffectsSaveStructure v2; // [sp+0h] [bp-168h] BYREF

  CPostEffectsSaveStructure::CopyValues(&v2, 0);
  v0 = malloc(4u);
  *v0 = 348;
  CGenericGameStorage::_SaveDataToWorkBuffer(v0, 4);
  free(v0);
  v1 = (CPostEffectsSaveStructure *)malloc(0x15Cu);
  qmemcpy(v1, &v2, sizeof(CPostEffectsSaveStructure));
  CGenericGameStorage::_SaveDataToWorkBuffer(v1, 348);
  free(v1);
}

//----- (0049000C) --------------------------------------------------------
void __fastcall CPostEffectsSaveStructure::CopyValues(CPostEffectsSaveStructure *this, bool isExtract)
{
  Int32 m_SeamRemoverShiftTopLeft; // r2
  Int32 m_SeamRemoverShiftBottomRight; // r5
  __int64 v4; // kr00_8
  Int32 m_DarknessFilterAlphaDefault; // r2
  Int32 m_DarknessFilterRadiosityIntensityLimit; // r3
  float m_fNightVisionSwitchOnFXCount; // r2
  float m_fInfraredVisionSwitchOnFXCount; // r4
  __int64 v9; // kr08_8
  __int64 v10; // d17
  int32 m_hilightScale; // r3
  int32 m_hilightOffset; // r4
  __int64 v13; // kr10_8
  unsigned __int64 v14; // kr18_8
  __int64 v15; // d17
  int32 v16; // r2

  if ( isExtract )
  {
    CPostEffects::m_colour1Multiplier = this->m_colour1Multiplier;
    CPostEffects::m_colour2Multiplier = this->m_colour2Multiplier;
    CPostEffects::SCREEN_EXTRA_MULT_CHANGE_RATE = this->SCREEN_EXTRA_MULT_CHANGE_RATE;
    CPostEffects::SCREEN_EXTRA_MULT_BASE_CAP = this->SCREEN_EXTRA_MULT_BASE_CAP;
    CPostEffects::SCREEN_EXTRA_MULT_BASE_MULT = this->SCREEN_EXTRA_MULT_BASE_MULT;
    CPostEffects::m_colourLeftUOffset = this->m_colourLeftUOffset;
    CPostEffects::m_colourRightUOffset = this->m_colourRightUOffset;
    CPostEffects::m_colourTopVOffset = this->m_colourTopVOffset;
    CPostEffects::m_colourBottomVOffset = this->m_colourBottomVOffset;
    CPostEffects::m_bSeamRemover = this->m_bSeamRemover;
    CPostEffects::m_bSeamRemoverSeamSearchMode = this->m_bSeamRemoverSeamSearchMode;
    CPostEffects::m_bSeamRemoverDebugMode = this->m_bSeamRemoverDebugMode;
    m_SeamRemoverShiftTopLeft = this->m_SeamRemoverShiftTopLeft;
    m_SeamRemoverShiftBottomRight = this->m_SeamRemoverShiftBottomRight;
    CPostEffects::m_SeamRemoverMode = this->m_SeamRemoverMode;
    CPostEffects::m_SeamRemoverShiftTopLeft = m_SeamRemoverShiftTopLeft;
    CPostEffects::m_SeamRemoverShiftBottomRight = m_SeamRemoverShiftBottomRight;
    CPostEffects::m_smokeyEnable = this->m_smokeyEnable;
    v4 = *(_QWORD *)&this->m_smokeyStrength;
    CPostEffects::m_smokeyStrength = this->m_smokeyStrength;
    CPostEffects::m_smokeyDistance = HIDWORD(v4);
    CPostEffects::m_waterEnable = this->m_waterEnable;
    CPostEffects::m_VisionFXDayNightBalance = this->m_VisionFXDayNightBalance;
    CPostEffects::m_bHeatHazeFX = this->m_bHeatHazeFX;
    CPostEffects::m_bHeatHazeMaskModeTest = this->m_bHeatHazeMaskModeTest;
    CPostEffects::m_HeatHazeFXHourOfDayStart = this->m_HeatHazeFXHourOfDayStart;
    CPostEffects::m_HeatHazeFXHourOfDayEnd = this->m_HeatHazeFXHourOfDayEnd;
    CPostEffects::m_fHeatHazeFXFadeSpeed = this->m_fHeatHazeFXFadeSpeed;
    CPostEffects::m_fHeatHazeFXInsideBuildingFadeSpeed = this->m_fHeatHazeFXInsideBuildingFadeSpeed;
    CPostEffects::m_HeatHazeFXType = this->m_HeatHazeFXType;
    CPostEffects::m_HeatHazeFXTypeLast = this->m_HeatHazeFXTypeLast;
    CPostEffects::m_HeatHazeFXIntensity = this->m_HeatHazeFXIntensity;
    CPostEffects::m_HeatHazeFXRandomShift = this->m_HeatHazeFXRandomShift;
    CPostEffects::m_HeatHazeFXSpeedMin = this->m_HeatHazeFXSpeedMin;
    CPostEffects::m_HeatHazeFXSpeedMax = this->m_HeatHazeFXSpeedMax;
    CPostEffects::m_HeatHazeFXScanSizeX = this->m_HeatHazeFXScanSizeX;
    CPostEffects::m_HeatHazeFXScanSizeY = this->m_HeatHazeFXScanSizeY;
    CPostEffects::m_HeatHazeFXRenderSizeX = this->m_HeatHazeFXRenderSizeX;
    CPostEffects::m_HeatHazeFXRenderSizeY = this->m_HeatHazeFXRenderSizeY;
    CPostEffects::m_bDarknessFilter = this->m_bDarknessFilter;
    m_DarknessFilterAlphaDefault = this->m_DarknessFilterAlphaDefault;
    m_DarknessFilterRadiosityIntensityLimit = this->m_DarknessFilterRadiosityIntensityLimit;
    CPostEffects::m_DarknessFilterAlpha = this->m_DarknessFilterAlpha;
    CPostEffects::m_DarknessFilterAlphaDefault = m_DarknessFilterAlphaDefault;
    CPostEffects::m_DarknessFilterRadiosityIntensityLimit = m_DarknessFilterRadiosityIntensityLimit;
    CPostEffects::m_bCCTV = this->m_bCCTV;
    CPostEffects::m_CCTVcol = this->m_CCTVcol;
    CPostEffects::m_bFog = this->m_bFog;
    CPostEffects::m_bSpeedFX = this->m_bSpeedFX;
    CPostEffects::m_bSpeedFXTestMode = this->m_bSpeedFXTestMode;
    CPostEffects::m_SpeedFXAlpha = this->m_SpeedFXAlpha;
    CPostEffects::m_bSpeedFXUserFlag = this->m_bSpeedFXUserFlag;
    CPostEffects::m_bSpeedFXUserFlagCurrentFrame = this->m_bSpeedFXUserFlagCurrentFrame;
    CPostEffects::m_fSpeedFXManualSpeedCurrentFrame = this->m_fSpeedFXManualSpeedCurrentFrame;
    CPostEffects::m_bInCutscene = this->m_bInCutscene;
    CPostEffects::m_bNightVision = this->m_bNightVision;
    CPostEffects::m_NightVisionGrainStrength = this->m_NightVisionGrainStrength;
    CPostEffects::m_NightVisionMainCol = this->m_NightVisionMainCol;
    m_fNightVisionSwitchOnFXCount = this->m_fNightVisionSwitchOnFXCount;
    m_fInfraredVisionSwitchOnFXCount = this->m_fInfraredVisionSwitchOnFXCount;
    CPostEffects::m_fNightVisionSwitchOnFXTime = this->m_fNightVisionSwitchOnFXTime;
    CPostEffects::m_fNightVisionSwitchOnFXCount = m_fNightVisionSwitchOnFXCount;
    CPostEffects::m_fInfraredVisionSwitchOnFXCount = m_fInfraredVisionSwitchOnFXCount;
    CPostEffects::m_bInfraredVision = this->m_bInfraredVision;
    v9 = *(_QWORD *)&this->m_InfraredVisionGrainStrength;
    CPostEffects::m_InfraredVisionGrainStrength = this->m_InfraredVisionGrainStrength;
    CPostEffects::m_fInfraredVisionFilterRadius = *((float *)&v9 + 1);
    v10 = *(_QWORD *)&this->m_fInfraredVisionHeatObjectCol.blue;
    *(_QWORD *)&CPostEffects::m_fInfraredVisionHeatObjectCol.red = *(_QWORD *)&this->m_fInfraredVisionHeatObjectCol.red;
    *(_QWORD *)&CPostEffects::m_fInfraredVisionHeatObjectCol.blue = v10;
    CPostEffects::m_InfraredVisionCol = this->m_InfraredVisionCol;
    CPostEffects::m_InfraredVisionMainCol = this->m_InfraredVisionMainCol;
    CPostEffects::m_bRadiosity = this->m_bRadiosity;
    CPostEffects::m_bRadiosityLinearFilter = this->m_bRadiosityLinearFilter;
    CPostEffects::m_bRadiosityStripCopyMode = this->m_bRadiosityStripCopyMode;
    CPostEffects::m_RadiosityPixelsX = this->m_RadiosityPixelsX;
    CPostEffects::m_RadiosityPixelsY = this->m_RadiosityPixelsY;
    CPostEffects::m_RadiosityFilterPasses = this->m_RadiosityFilterPasses;
    CPostEffects::m_RadiosityRenderPasses = this->m_RadiosityRenderPasses;
    CPostEffects::m_RadiosityIntensityLimit = this->m_RadiosityIntensityLimit;
    CPostEffects::m_RadiosityIntensity = this->m_RadiosityIntensity;
    CPostEffects::m_RadiosityFilterUCorrection = this->m_RadiosityFilterUCorrection;
    CPostEffects::m_RadiosityFilterVCorrection = this->m_RadiosityFilterVCorrection;
    CPostEffects::m_bRadiosityDebug = this->m_bRadiosityDebug;
    CPostEffects::m_bRadiosityBypassTimeCycleIntensityLimit = this->m_bRadiosityBypassTimeCycleIntensityLimit;
    CPostEffects::m_bDisableAllPostEffect = this->m_bDisableAllPostEffect;
    CPostEffects::m_bSavePhotoFromScript = this->m_bSavePhotoFromScript;
    CPostEffects::m_bGrainEnable = this->m_bGrainEnable;
    CPostEffects::m_grainStrength = this->m_grainStrength;
    CPostEffects::m_bHilightEnable = this->m_bHilightEnable;
    m_hilightScale = this->m_hilightScale;
    m_hilightOffset = this->m_hilightOffset;
    CPostEffects::m_hilightStrength = this->m_hilightStrength;
    CPostEffects::m_hilightScale = m_hilightScale;
    CPostEffects::m_hilightOffset = m_hilightOffset;
    CPostEffects::m_hilightMblur = this->m_hilightMblur;
    CPostEffects::m_waterStrength = this->m_waterStrength;
    CPostEffects::m_xoffset = this->m_xoffset;
    CPostEffects::m_yoffset = this->m_yoffset;
    CPostEffects::m_waterSpeed = this->m_waterSpeed;
    CPostEffects::m_waterFreq = this->m_waterFreq;
    CPostEffects::m_waterCol = this->m_waterCol;
    CPostEffects::m_bWaterDepthDarkness = this->m_bWaterDepthDarkness;
    v13 = *(_QWORD *)&this->m_fWaterFullDarknessDepth;
    CPostEffects::m_fWaterFullDarknessDepth = this->m_fWaterFullDarknessDepth;
    CPostEffects::m_fWaterFXStartUnderWaterness = *((float *)&v13 + 1);
    CPostEffects::m_bRainEnable = this->m_bRainEnable;
    CPostEffects::m_bColorEnable = this->m_bColorEnable;
    v14 = *(_QWORD *)&this->m_defScreenXPosn;
    CPostEffects::m_defScreenYPosn = HIDWORD(v14);
    CPostEffects::m_defScreenXPosn = v14;
  }
  else
  {
    this->m_colour1Multiplier = CPostEffects::m_colour1Multiplier;
    this->m_colour2Multiplier = CPostEffects::m_colour2Multiplier;
    this->SCREEN_EXTRA_MULT_CHANGE_RATE = CPostEffects::SCREEN_EXTRA_MULT_CHANGE_RATE;
    this->SCREEN_EXTRA_MULT_BASE_CAP = CPostEffects::SCREEN_EXTRA_MULT_BASE_CAP;
    this->SCREEN_EXTRA_MULT_BASE_MULT = CPostEffects::SCREEN_EXTRA_MULT_BASE_MULT;
    this->m_colourLeftUOffset = CPostEffects::m_colourLeftUOffset;
    this->m_colourRightUOffset = CPostEffects::m_colourRightUOffset;
    this->m_colourTopVOffset = CPostEffects::m_colourTopVOffset;
    this->m_colourBottomVOffset = CPostEffects::m_colourBottomVOffset;
    this->m_bSeamRemover = CPostEffects::m_bSeamRemover;
    this->m_bSeamRemoverSeamSearchMode = CPostEffects::m_bSeamRemoverSeamSearchMode;
    this->m_bSeamRemoverDebugMode = CPostEffects::m_bSeamRemoverDebugMode;
    this->m_SeamRemoverMode = CPostEffects::m_SeamRemoverMode;
    this->m_SeamRemoverShiftTopLeft = CPostEffects::m_SeamRemoverShiftTopLeft;
    this->m_SeamRemoverShiftBottomRight = CPostEffects::m_SeamRemoverShiftBottomRight;
    this->m_smokeyEnable = CPostEffects::m_smokeyEnable;
    this->m_smokeyStrength = CPostEffects::m_smokeyStrength;
    this->m_smokeyDistance = CPostEffects::m_smokeyDistance;
    this->m_waterEnable = CPostEffects::m_waterEnable;
    this->m_VisionFXDayNightBalance = CPostEffects::m_VisionFXDayNightBalance;
    this->m_bHeatHazeFX = CPostEffects::m_bHeatHazeFX;
    this->m_bHeatHazeMaskModeTest = CPostEffects::m_bHeatHazeMaskModeTest;
    this->m_HeatHazeFXHourOfDayStart = CPostEffects::m_HeatHazeFXHourOfDayStart;
    this->m_HeatHazeFXHourOfDayEnd = CPostEffects::m_HeatHazeFXHourOfDayEnd;
    this->m_fHeatHazeFXFadeSpeed = CPostEffects::m_fHeatHazeFXFadeSpeed;
    this->m_fHeatHazeFXInsideBuildingFadeSpeed = CPostEffects::m_fHeatHazeFXInsideBuildingFadeSpeed;
    this->m_HeatHazeFXType = CPostEffects::m_HeatHazeFXType;
    this->m_HeatHazeFXTypeLast = CPostEffects::m_HeatHazeFXTypeLast;
    this->m_HeatHazeFXIntensity = CPostEffects::m_HeatHazeFXIntensity;
    this->m_HeatHazeFXRandomShift = CPostEffects::m_HeatHazeFXRandomShift;
    this->m_HeatHazeFXSpeedMin = CPostEffects::m_HeatHazeFXSpeedMin;
    this->m_HeatHazeFXSpeedMax = CPostEffects::m_HeatHazeFXSpeedMax;
    this->m_HeatHazeFXScanSizeX = CPostEffects::m_HeatHazeFXScanSizeX;
    this->m_HeatHazeFXScanSizeY = CPostEffects::m_HeatHazeFXScanSizeY;
    this->m_HeatHazeFXRenderSizeX = CPostEffects::m_HeatHazeFXRenderSizeX;
    this->m_HeatHazeFXRenderSizeY = CPostEffects::m_HeatHazeFXRenderSizeY;
    this->m_bDarknessFilter = CPostEffects::m_bDarknessFilter;
    this->m_DarknessFilterAlpha = CPostEffects::m_DarknessFilterAlpha;
    this->m_DarknessFilterAlphaDefault = CPostEffects::m_DarknessFilterAlphaDefault;
    this->m_DarknessFilterRadiosityIntensityLimit = CPostEffects::m_DarknessFilterRadiosityIntensityLimit;
    this->m_bCCTV = CPostEffects::m_bCCTV;
    this->m_CCTVcol = CPostEffects::m_CCTVcol;
    this->m_bFog = CPostEffects::m_bFog;
    this->m_bSpeedFX = CPostEffects::m_bSpeedFX;
    this->m_bSpeedFXTestMode = CPostEffects::m_bSpeedFXTestMode;
    this->m_SpeedFXAlpha = CPostEffects::m_SpeedFXAlpha;
    this->m_bSpeedFXUserFlag = CPostEffects::m_bSpeedFXUserFlag;
    this->m_bSpeedFXUserFlagCurrentFrame = CPostEffects::m_bSpeedFXUserFlagCurrentFrame;
    this->m_fSpeedFXManualSpeedCurrentFrame = CPostEffects::m_fSpeedFXManualSpeedCurrentFrame;
    this->m_bInCutscene = CPostEffects::m_bInCutscene;
    this->m_bNightVision = CPostEffects::m_bNightVision;
    this->m_NightVisionGrainStrength = CPostEffects::m_NightVisionGrainStrength;
    this->m_NightVisionMainCol = CPostEffects::m_NightVisionMainCol;
    this->m_fNightVisionSwitchOnFXTime = CPostEffects::m_fNightVisionSwitchOnFXTime;
    this->m_fNightVisionSwitchOnFXCount = CPostEffects::m_fNightVisionSwitchOnFXCount;
    this->m_fInfraredVisionSwitchOnFXCount = CPostEffects::m_fInfraredVisionSwitchOnFXCount;
    this->m_bInfraredVision = CPostEffects::m_bInfraredVision;
    this->m_InfraredVisionGrainStrength = CPostEffects::m_InfraredVisionGrainStrength;
    this->m_fInfraredVisionFilterRadius = CPostEffects::m_fInfraredVisionFilterRadius;
    v15 = *(_QWORD *)&CPostEffects::m_fInfraredVisionHeatObjectCol.blue;
    *(_QWORD *)&this->m_fInfraredVisionHeatObjectCol.red = *(_QWORD *)&CPostEffects::m_fInfraredVisionHeatObjectCol.red;
    *(_QWORD *)&this->m_fInfraredVisionHeatObjectCol.blue = v15;
    this->m_InfraredVisionCol = CPostEffects::m_InfraredVisionCol;
    this->m_InfraredVisionMainCol = CPostEffects::m_InfraredVisionMainCol;
    this->m_bRadiosity = CPostEffects::m_bRadiosity;
    this->m_bRadiosityLinearFilter = CPostEffects::m_bRadiosityLinearFilter;
    this->m_bRadiosityStripCopyMode = CPostEffects::m_bRadiosityStripCopyMode;
    this->m_RadiosityPixelsX = CPostEffects::m_RadiosityPixelsX;
    this->m_RadiosityPixelsY = CPostEffects::m_RadiosityPixelsY;
    this->m_RadiosityFilterPasses = CPostEffects::m_RadiosityFilterPasses;
    this->m_RadiosityRenderPasses = CPostEffects::m_RadiosityRenderPasses;
    this->m_RadiosityIntensityLimit = CPostEffects::m_RadiosityIntensityLimit;
    this->m_RadiosityIntensity = CPostEffects::m_RadiosityIntensity;
    this->m_RadiosityFilterUCorrection = CPostEffects::m_RadiosityFilterUCorrection;
    this->m_RadiosityFilterVCorrection = CPostEffects::m_RadiosityFilterVCorrection;
    this->m_bRadiosityDebug = CPostEffects::m_bRadiosityDebug;
    this->m_bRadiosityBypassTimeCycleIntensityLimit = CPostEffects::m_bRadiosityBypassTimeCycleIntensityLimit;
    this->m_bDisableAllPostEffect = CPostEffects::m_bDisableAllPostEffect;
    this->m_bSavePhotoFromScript = CPostEffects::m_bSavePhotoFromScript;
    this->m_bGrainEnable = CPostEffects::m_bGrainEnable;
    this->m_grainStrength = CPostEffects::m_grainStrength;
    this->m_bHilightEnable = CPostEffects::m_bHilightEnable;
    this->m_hilightStrength = CPostEffects::m_hilightStrength;
    this->m_hilightScale = CPostEffects::m_hilightScale;
    this->m_hilightOffset = CPostEffects::m_hilightOffset;
    this->m_hilightMblur = CPostEffects::m_hilightMblur;
    this->m_waterStrength = CPostEffects::m_waterStrength;
    this->m_xoffset = CPostEffects::m_xoffset;
    this->m_yoffset = CPostEffects::m_yoffset;
    this->m_waterSpeed = CPostEffects::m_waterSpeed;
    this->m_waterFreq = CPostEffects::m_waterFreq;
    this->m_waterCol = CPostEffects::m_waterCol;
    this->m_bWaterDepthDarkness = CPostEffects::m_bWaterDepthDarkness;
    this->m_fWaterFullDarknessDepth = CPostEffects::m_fWaterFullDarknessDepth;
    this->m_fWaterFXStartUnderWaterness = CPostEffects::m_fWaterFXStartUnderWaterness;
    this->m_bRainEnable = CPostEffects::m_bRainEnable;
    this->m_bColorEnable = CPostEffects::m_bColorEnable;
    v16 = CPostEffects::m_defScreenYPosn;
    this->m_defScreenXPosn = CPostEffects::m_defScreenXPosn;
    this->m_defScreenYPosn = v16;
  }
}

//----- (00490DC0) --------------------------------------------------------
void CPostEffects::Load()
{
  CPostEffectsSaveStructure v0; // [sp+0h] [bp-168h] BYREF
  char pData[12]; // [sp+15Ch] [bp-Ch] BYREF

  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v0, 348);
  CPostEffectsSaveStructure::CopyValues(&v0, 1);
}
// 490DC0: using guessed type char pData[12];

//----- (00490DE8) --------------------------------------------------------
void CTaskComplexMedicTreatInjuredPed::CreateTask()
{
  bool v0; // r4
  CVehicle *Vehicle; // r8
  bool v2; // r5
  CPed *Ped; // r5
  bool v4; // r6
  CTaskComplexMedicTreatInjuredPed *v5; // r0
  bool bIsDriver; // [sp+7h] [bp-21h] BYREF
  int32 v7; // [sp+8h] [bp-20h] BYREF
  int32 nRef; // [sp+Ch] [bp-1Ch] BYREF
  char pData[2]; // [sp+12h] [bp-16h] BYREF
  char v10[2]; // [sp+14h] [bp-14h] BYREF
  char v11[18]; // [sp+16h] [bp-12h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(nRef);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v10, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v7, 4);
  if ( v7 == -1 )
    Ped = 0;
  else
    Ped = CPools::GetPed(v7);
  v4 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v11, 2);
    UseDataFence = v4;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&bIsDriver, 1);
  v5 = (CTaskComplexMedicTreatInjuredPed *)CTask::operator new(0x2Cu);
  CTaskComplexMedicTreatInjuredPed::CTaskComplexMedicTreatInjuredPed(v5, Vehicle, Ped, bIsDriver);
}
// 490DE8: using guessed type char pData[2];
// 490DE8: using guessed type char var_14[2];
// 490DE8: using guessed type char var_12[18];

//----- (00490EC0) --------------------------------------------------------
void CTaskComplexTreatAccident::CreateTask()
{
  bool v0; // r4
  CPed *Ped; // r4
  CTaskComplexTreatAccident *v2; // r5
  int v3; // r0
  int32 nRef; // [sp+0h] [bp-18h] BYREF
  char pData[18]; // [sp+6h] [bp-12h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    Ped = 0;
  else
    Ped = CPools::GetPed(nRef);
  v2 = (CTaskComplexTreatAccident *)CTask::operator new(0x10u);
  v3 = operator new(8u);
  *(_DWORD *)v3 = Ped;
  *(_WORD *)(v3 + 4) = 0;
  CTaskComplexTreatAccident::CTaskComplexTreatAccident(v2, (CAccident *)v3);
}
// 490EC0: using guessed type char pData[18];

//----- (00490F30) --------------------------------------------------------
void CTaskSimpleGiveCPR::CreateTask()
{
  bool v0; // r4
  CPed *Ped; // r4
  CTaskSimpleGiveCPR *v2; // r5
  int v3; // r0
  int32 nRef; // [sp+0h] [bp-18h] BYREF
  char pData[18]; // [sp+6h] [bp-12h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    Ped = 0;
  else
    Ped = CPools::GetPed(nRef);
  v2 = (CTaskSimpleGiveCPR *)CTask::operator new(0x18u);
  v3 = operator new(8u);
  *(_DWORD *)v3 = Ped;
  *(_WORD *)(v3 + 4) = 0;
  CTaskSimpleGiveCPR::CTaskSimpleGiveCPR(v2, (CAccident *)v3);
}
// 490F30: using guessed type char pData[18];

//----- (00490FA0) --------------------------------------------------------
void CTaskComplexFallAndGetUp::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  bool v2; // r4
  CTaskComplexFallAndGetUp *v3; // r0
  int v4; // [sp+4h] [bp-14h] BYREF
  AssocGroupId v5; // [sp+8h] [bp-10h] BYREF
  int pData[3]; // [sp+Ch] [bp-Ch] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v5, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v5, 4);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v4, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v4, 4);
  v3 = (CTaskComplexFallAndGetUp *)CTask::operator new(0x18u);
  CTaskComplexFallAndGetUp::CTaskComplexFallAndGetUp(v3, (const AnimationId)pData[0], v5, v4);
}

//----- (00491044) --------------------------------------------------------
void CTaskComplexFallAndStayDown::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CTaskComplexFallAndStayDown *v2; // r0
  AssocGroupId v3; // [sp+4h] [bp-14h] BYREF
  AnimationId v4; // [sp+8h] [bp-10h] BYREF
  char pData[2]; // [sp+Ch] [bp-Ch] BYREF
  char v6[10]; // [sp+Eh] [bp-Ah] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v4, 4);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v6, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v3, 4);
  v2 = (CTaskComplexFallAndStayDown *)CTask::operator new(0x14u);
  CTaskComplexFallAndStayDown::CTaskComplexFallAndStayDown(v2, v4, v3);
}
// 491044: using guessed type char pData[2];
// 491044: using guessed type char var_A[10];

//----- (004910BC) --------------------------------------------------------
void CTaskSimpleDieInCar::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CTaskSimpleDieInCar *v2; // r0
  AnimationId v3; // [sp+4h] [bp-14h] BYREF
  AssocGroupId v4; // [sp+8h] [bp-10h] BYREF
  char pData[2]; // [sp+Ch] [bp-Ch] BYREF
  char v6[10]; // [sp+Eh] [bp-Ah] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v4, 4);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v6, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v3, 4);
  v2 = (CTaskSimpleDieInCar *)CTask::operator new(0x28u);
  CTaskSimpleDieInCar::CTaskSimpleDieInCar(v2, v4, v3);
}
// 4910BC: using guessed type char pData[2];
// 4910BC: using guessed type char var_A[10];

//----- (00491134) --------------------------------------------------------
void CTaskComplexDie::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  bool v2; // r4
  bool v3; // r4
  bool v4; // r4
  bool v5; // r4
  CTaskComplexDie *v6; // r0
  char v7[4]; // [sp+18h] [bp-20h] BYREF
  float v8; // [sp+1Ch] [bp-1Ch] BYREF
  float v9; // [sp+20h] [bp-18h] BYREF
  AnimationId v10; // [sp+24h] [bp-14h] BYREF
  AssocGroupId v11; // [sp+28h] [bp-10h] BYREF
  int pData[3]; // [sp+2Ch] [bp-Ch] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 4);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v10, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v10, 4);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v9, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v9, 4);
  v4 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v8, 2);
    UseDataFence = v4;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v8, 4);
  v5 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v7, 2);
    UseDataFence = v5;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(v7, 4);
  v6 = (CTaskComplexDie *)CTask::operator new(0x28u);
  CTaskComplexDie::CTaskComplexDie(v6, (const eWeaponType)pData[0], v11, v10, v9, v8, 0, 0, 0, 0);
}
// 491134: using guessed type char var_20[4];

//----- (0049127C) --------------------------------------------------------
void CTaskSimpleDead::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CTaskSimpleDead *v2; // r0
  char v3; // r2
  char v4; // [sp+7h] [bp-11h] BYREF
  int iTimeOfDeath; // [sp+8h] [bp-10h] BYREF
  char pData[2]; // [sp+Ch] [bp-Ch] BYREF
  char v7[10]; // [sp+Eh] [bp-Ah] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&iTimeOfDeath, 4);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v7, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v4, 1);
  v2 = (CTaskSimpleDead *)CTask::operator new(0x10u);
  v3 = v4;
  if ( v4 )
    v3 = 1;
  CTaskSimpleDead::CTaskSimpleDead(v2, iTimeOfDeath, v3);
}
// 49127C: using guessed type char pData[2];
// 49127C: using guessed type char var_A[10];

//----- (004912FC) --------------------------------------------------------
void CTaskSimpleSitIdle::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CTaskSimpleSitIdle *v2; // r0
  bool8 sitOnStep; // [sp+7h] [bp-11h] BYREF
  int iDuration; // [sp+8h] [bp-10h] BYREF
  char pData[2]; // [sp+Ch] [bp-Ch] BYREF
  char v6[10]; // [sp+Eh] [bp-Ah] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&iDuration, 4);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v6, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&sitOnStep, 1);
  v2 = (CTaskSimpleSitIdle *)CTask::operator new(0x20u);
  CTaskSimpleSitIdle::CTaskSimpleSitIdle(v2, iDuration, sitOnStep);
}
// 4912FC: using guessed type char pData[2];
// 4912FC: using guessed type char var_A[10];

//----- (00491378) --------------------------------------------------------
void CTaskComplexSitDownThenIdleThenStandUp::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  bool v2; // r4
  CTaskComplexSitDownThenIdleThenStandUp *v3; // r0
  bool8 doInstantly; // [sp+2h] [bp-16h] BYREF
  bool8 sitOnStep; // [sp+3h] [bp-15h] BYREF
  int iDuration; // [sp+4h] [bp-14h] BYREF
  char pData[2]; // [sp+Ah] [bp-Eh] BYREF
  char v8[2]; // [sp+Ch] [bp-Ch] BYREF
  char v9[10]; // [sp+Eh] [bp-Ah] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&iDuration, 4);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v8, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&sitOnStep, 1);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v9, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&doInstantly, 1);
  v3 = (CTaskComplexSitDownThenIdleThenStandUp *)CTask::operator new(0x14u);
  CTaskComplexSitDownThenIdleThenStandUp::CTaskComplexSitDownThenIdleThenStandUp(v3, iDuration, sitOnStep, doInstantly);
}
// 491378: using guessed type char pData[2];
// 491378: using guessed type char var_C[2];
// 491378: using guessed type char var_A[10];

//----- (00491428) --------------------------------------------------------
void CTaskComplexObserveTrafficLightsAndAchieveHeading::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CTaskComplexObserveTrafficLightsAndAchieveHeading *v2; // r0
  float v3; // [sp+4h] [bp-14h] BYREF
  int v4; // [sp+8h] [bp-10h] BYREF
  char pData[2]; // [sp+Ch] [bp-Ch] BYREF
  char v6[10]; // [sp+Eh] [bp-Ah] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v4, 4);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v6, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v3, 4);
  v2 = (CTaskComplexObserveTrafficLightsAndAchieveHeading *)CTask::operator new(0x14u);
  CTaskComplexObserveTrafficLightsAndAchieveHeading::CTaskComplexObserveTrafficLightsAndAchieveHeading(v2, v4, v3);
}
// 491428: using guessed type char pData[2];
// 491428: using guessed type char var_A[10];
// 491428: using guessed type float var_14;

//----- (004914A0) --------------------------------------------------------
void CTaskComplexCrossRoadLookAndAchieveHeading::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CTaskComplexCrossRoadLookAndAchieveHeading *v2; // r0
  float v3; // [sp+4h] [bp-14h] BYREF
  int v4; // [sp+8h] [bp-10h] BYREF
  char pData[2]; // [sp+Ch] [bp-Ch] BYREF
  char v6[10]; // [sp+Eh] [bp-Ah] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v4, 4);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v6, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v3, 4);
  v2 = (CTaskComplexCrossRoadLookAndAchieveHeading *)CTask::operator new(0x14u);
  CTaskComplexCrossRoadLookAndAchieveHeading::CTaskComplexCrossRoadLookAndAchieveHeading(v2, v4, v3);
}
// 4914A0: using guessed type char pData[2];
// 4914A0: using guessed type char var_A[10];
// 4914A0: using guessed type float var_14;

//----- (00491518) --------------------------------------------------------
void CTaskComplexInAirAndLand::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CTaskComplexInAirAndLand *v2; // r0
  char v3; // r1
  char v4; // [sp+2h] [bp-Eh] BYREF
  char v5; // [sp+3h] [bp-Dh] BYREF
  char pData[2]; // [sp+4h] [bp-Ch] BYREF
  char v7[10]; // [sp+6h] [bp-Ah] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v5, 1);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v7, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v4, 1);
  v2 = (CTaskComplexInAirAndLand *)CTask::operator new(0x10u);
  v3 = v5;
  if ( v5 )
    v3 = 1;
  CTaskComplexInAirAndLand::CTaskComplexInAirAndLand(v2, v3, v4 != 0);
}
// 491518: using guessed type char pData[2];
// 491518: using guessed type char var_A[10];

//----- (004915A4) --------------------------------------------------------
void CTaskSimpleInAir::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  bool v2; // r4
  CTaskSimpleInAir *v3; // r0
  char v4; // r1
  char v5; // [sp+7h] [bp-11h] BYREF
  char v6; // [sp+8h] [bp-10h] BYREF
  char v7; // [sp+9h] [bp-Fh] BYREF
  char pData[2]; // [sp+Ah] [bp-Eh] BYREF
  char v9[2]; // [sp+Ch] [bp-Ch] BYREF
  char v10[10]; // [sp+Eh] [bp-Ah] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v7, 1);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v9, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v6, 1);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v10, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v5, 1);
  v3 = (CTaskSimpleInAir *)CTask::operator new(0x3Cu);
  v4 = v7;
  if ( v7 )
    v4 = 1;
  CTaskSimpleInAir::CTaskSimpleInAir(v3, v4, v6 != 0, v5 != 0);
}
// 4915A4: using guessed type char pData[2];
// 4915A4: using guessed type char var_C[2];
// 4915A4: using guessed type char var_A[10];

//----- (00491668) --------------------------------------------------------
void CTaskComplexBeInGroup::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  bool v2; // r4
  CTaskComplexBeInGroup *v3; // r0
  bool bIsLeader; // [sp+7h] [bp-19h] BYREF
  int iGroupID; // [sp+8h] [bp-18h] BYREF
  char v6[6]; // [sp+Ch] [bp-14h] BYREF
  char pData[2]; // [sp+12h] [bp-Eh] BYREF
  char v8[2]; // [sp+14h] [bp-Ch] BYREF
  char v9[10]; // [sp+16h] [bp-Ah] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(v6, 4);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v8, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&iGroupID, 4);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v9, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&bIsLeader, 1);
  v3 = (CTaskComplexBeInGroup *)CTask::operator new(0x28u);
  CTaskComplexBeInGroup::CTaskComplexBeInGroup(v3, iGroupID, bIsLeader);
}
// 491668: using guessed type char pData[2];
// 491668: using guessed type char var_14[6];
// 491668: using guessed type char var_C[2];
// 491668: using guessed type char var_A[10];

//----- (00491714) --------------------------------------------------------
void CTaskSimpleClimb::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CEntity *Vehicle; // r0
  bool v3; // r4
  bool v4; // r4
  CEntity *v5; // r4
  bool v6; // r5
  bool v7; // r5
  bool v8; // r5
  bool v9; // r5
  bool v10; // r5
  CTaskSimpleClimb *v11; // r0
  int8 v12; // [sp+Eh] [bp-2Ah] BYREF
  uint8 v13; // [sp+Fh] [bp-29h] BYREF
  float fHeading; // [sp+10h] [bp-28h] BYREF
  CVector pData; // [sp+14h] [bp-24h] BYREF
  int v16; // [sp+20h] [bp-18h] BYREF
  bool v17[18]; // [sp+26h] [bp-12h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v16, 4);
  switch ( v16 )
  {
    case 2:
      v3 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v3;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      if ( LODWORD(pData.x) != -1 )
      {
        Vehicle = CPools::GetVehicle(SLODWORD(pData.x));
        goto LABEL_18;
      }
      break;
    case 4:
      v4 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v4;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      if ( LODWORD(pData.x) != -1 )
      {
        Vehicle = CPools::GetObject(SLODWORD(pData.x));
        goto LABEL_18;
      }
      break;
    case 3:
      v1 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v1;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      if ( LODWORD(pData.x) != -1 )
      {
        Vehicle = CPools::GetPed(SLODWORD(pData.x));
LABEL_18:
        v5 = Vehicle;
        goto LABEL_20;
      }
      break;
  }
  v5 = 0;
LABEL_20:
  v6 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v6;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 12);
  v7 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&fHeading, 2);
    UseDataFence = v7;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&fHeading, 4);
  v8 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v17, 2);
    UseDataFence = v8;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v13, 1);
  v9 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v17, 2);
    UseDataFence = v9;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v12, 1);
  v10 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v17, 2);
    UseDataFence = v10;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(v17, 1);
  v11 = (CTaskSimpleClimb *)CTask::operator new(0x30u);
  CTaskSimpleClimb::CTaskSimpleClimb(v11, v5, &pData, fHeading, v13, v12, v17[0]);
}
// 491714: using guessed type int var_18;

//----- (00491928) --------------------------------------------------------
void CTaskSimpleChoking::CreateTask()
{
  bool v0; // r4
  CPed *Ped; // r4
  bool v2; // r5
  CTaskSimpleChoking *v3; // r0
  bool8 isTeargas; // [sp+7h] [bp-19h] BYREF
  int32 nRef; // [sp+8h] [bp-18h] BYREF
  char pData[2]; // [sp+Ch] [bp-14h] BYREF
  char v7[18]; // [sp+Eh] [bp-12h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    Ped = 0;
  else
    Ped = CPools::GetPed(nRef);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v7, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&isTeargas, 1);
  v3 = (CTaskSimpleChoking *)CTask::operator new(0x1Cu);
  CTaskSimpleChoking::CTaskSimpleChoking(v3, Ped, isTeargas);
}
// 491928: using guessed type char pData[2];
// 491928: using guessed type char var_12[18];

//----- (004919BC) --------------------------------------------------------
void CTaskSimpleTriggerLookAt::CreateTask()
{
  bool v0; // r4
  CPed *Ped; // r8
  bool v2; // r5
  bool v3; // r5
  bool v4; // r5
  bool v5; // r5
  bool v6; // r5
  bool v7; // r5
  bool v8; // r5
  bool v9; // r5
  CTaskSimpleTriggerLookAt *v10; // r0
  char v11; // [sp+1Fh] [bp-39h] BYREF
  int32 blendTime; // [sp+20h] [bp-38h] BYREF
  float v13; // [sp+24h] [bp-34h] BYREF
  bool8 v14; // [sp+2Bh] [bp-2Dh] BYREF
  RwV3d_0 pData; // [sp+2Ch] [bp-2Ch] BYREF
  int32 v16; // [sp+38h] [bp-20h] BYREF
  int32 time; // [sp+3Ch] [bp-1Ch] BYREF
  int32 nRef; // [sp+40h] [bp-18h] BYREF
  char v19[18]; // [sp+46h] [bp-12h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    Ped = 0;
  else
    Ped = CPools::GetPed(nRef);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&time, 4);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v16, 4);
  v4 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v4;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 12);
  v5 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v13, 2);
    UseDataFence = v5;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v14, 1);
  v6 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v13, 2);
    UseDataFence = v6;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v13, 4);
  v7 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&blendTime, 2);
    UseDataFence = v7;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&blendTime, 4);
  v8 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v19, 2);
    UseDataFence = v8;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 1);
  v9 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v19, 2);
    UseDataFence = v9;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(v19, 1);
  v10 = (CTaskSimpleTriggerLookAt *)CTask::operator new(0x30u);
  CTaskSimpleTriggerLookAt::CTaskSimpleTriggerLookAt(v10, Ped, time, v16, pData, v14, v13, blendTime, v19[0]);
}
// 4919BC: using guessed type float var_34;

//----- (00491BBC) --------------------------------------------------------
CTask *CTaskComplexUseSequence::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  bool v2; // r4
  CTaskComplexUseSequence *v3; // r0
  CTask *result; // r0
  CTask *v5; // r2
  CTask *v6; // [sp+4h] [bp-14h] BYREF
  int (**v7)(void); // [sp+8h] [bp-10h] BYREF
  int pData[3]; // [sp+Ch] [bp-Ch] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v7, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v7, 4);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v6, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v6, 4);
  v3 = (CTaskComplexUseSequence *)CTask::operator new(0x1Cu);
  CTaskComplexUseSequence::CTaskComplexUseSequence(v3, pData[0]);
  v5 = v6;
  result[2]._vptr$CTask = v7;
  result[2].m_pParent = v5;
  return result;
}
// 491C44: variable 'result' is possibly undefined

//----- (00491C64) --------------------------------------------------------
void CTaskComplexFallToDeath::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  bool v2; // r4
  bool v3; // r4
  CTaskComplexFallToDeath *v4; // r0
  char tumble; // r2
  char v6; // [sp+7h] [bp-19h] BYREF
  CVector pData; // [sp+8h] [bp-18h] BYREF
  unsigned __int8 iNudgeDir; // [sp+15h] [bp-Bh] BYREF
  _BYTE iNudgeDir_1[10]; // [sp+16h] [bp-Ah] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&iNudgeDir, 1);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 12);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(iNudgeDir_1, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v6, 1);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(iNudgeDir_1, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(iNudgeDir_1, 1);
  v4 = (CTaskComplexFallToDeath *)CTask::operator new(0x24u);
  tumble = iNudgeDir_1[0];
  if ( iNudgeDir_1[0] )
    tumble = 1;
  CTaskComplexFallToDeath::CTaskComplexFallToDeath(v4, iNudgeDir, &pData, v6 != 0, tumble);
}
// 491C64: using guessed type CVector pData;

//----- (00491D58) --------------------------------------------------------
CTask *CTaskSimpleWaitUntilLeaderAreaCodesMatch::CreateTask()
{
  bool v0; // r4
  CPed *Ped; // r4
  CTaskSimpleWaitUntilAreaCodesMatch *v2; // r0
  CTask *result; // r0
  int32 nRef; // [sp+0h] [bp-10h] BYREF
  char pData[10]; // [sp+6h] [bp-Ah] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    Ped = 0;
  else
    Ped = CPools::GetPed(nRef);
  v2 = (CTaskSimpleWaitUntilAreaCodesMatch *)CTask::operator new(0x38u);
  CTaskSimpleWaitUntilAreaCodesMatch::CTaskSimpleWaitUntilAreaCodesMatch(v2, Ped);
  LOBYTE(result[4].m_pParent) = 0;
  LOBYTE(result[6].m_pParent) = 0;
  result->_vptr$CTask = (int (**)(void))&off_66A848;
  return result;
}
// 491DA6: variable 'result' is possibly undefined
// 66A848: using guessed type void *off_66A848;
// 491D58: using guessed type char pData[10];

//----- (00491DC8) --------------------------------------------------------
CTask *CTaskSimpleSay::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CTaskSimple *v2; // r0
  CTask *v3; // r4
  int (**v4)(void); // r5
  CTask *result; // r0
  CTask *v6; // [sp+4h] [bp-14h] BYREF
  int (**v7)(void); // [sp+8h] [bp-10h] BYREF
  char pData[2]; // [sp+Ch] [bp-Ch] BYREF
  char v9[10]; // [sp+Eh] [bp-Ah] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v7, 4);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v9, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v6, 4);
  v2 = (CTaskSimple *)CTask::operator new(0x1Cu);
  v3 = v6;
  v4 = v7;
  CTaskSimple::CTaskSimple(v2);
  result[1]._vptr$CTask = v4;
  result->_vptr$CTask = (int (**)(void))&off_665784;
  result[1].m_pParent = v3;
  LOWORD(result[3]._vptr$CTask) = 0;
  result[2]._vptr$CTask = 0;
  result[2].m_pParent = 0;
  return result;
}
// 491E2C: variable 'result' is possibly undefined
// 665784: using guessed type void *off_665784;
// 491DC8: using guessed type char pData[2];
// 491DC8: using guessed type char var_A[10];

//----- (00491E58) --------------------------------------------------------
void CTaskSimpleFacial::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CTaskSimpleFacial *v2; // r0
  int32 v3; // [sp+4h] [bp-14h] BYREF
  int32 v4; // [sp+8h] [bp-10h] BYREF
  char pData[2]; // [sp+Ch] [bp-Ch] BYREF
  char v6[10]; // [sp+Eh] [bp-Ah] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v4, 4);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v6, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v3, 4);
  v2 = (CTaskSimpleFacial *)CTask::operator new(0x1Cu);
  CTaskSimpleFacial::CTaskSimpleFacial(v2, v4, v3);
}
// 491E58: using guessed type char pData[2];
// 491E58: using guessed type char var_A[10];

//----- (00491ED0) --------------------------------------------------------
void CTaskComplexGoPickUpEntity::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CEntity *Vehicle; // r0
  bool v3; // r4
  bool v4; // r4
  CEntity *v5; // r4
  bool v6; // r5
  CTaskComplexGoPickUpEntity *v7; // r0
  int32 nRef; // [sp+0h] [bp-18h] BYREF
  int pData[5]; // [sp+4h] [bp-14h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  switch ( pData[0] )
  {
    case 2:
      v3 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v3;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetVehicle(nRef);
        goto LABEL_18;
      }
      break;
    case 4:
      v4 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v4;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetObject(nRef);
        goto LABEL_18;
      }
      break;
    case 3:
      v1 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v1;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetPed(nRef);
LABEL_18:
        v5 = Vehicle;
        goto LABEL_20;
      }
      break;
  }
  v5 = 0;
LABEL_20:
  v6 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
    UseDataFence = v6;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  v7 = (CTaskComplexGoPickUpEntity *)CTask::operator new(0x34u);
  CTaskComplexGoPickUpEntity::CTaskComplexGoPickUpEntity(v7, v5, (AssocGroupId)nRef);
}

//----- (0049200C) --------------------------------------------------------
CTask *CTaskSimpleRunNamedAnim::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  bool v2; // r4
  bool v3; // r4
  bool v4; // r4
  CAnimBlock *AnimationBlock; // r0
  int v6; // r4
  CTaskSimpleRunNamedAnim *v7; // r0
  int v8; // r0
  char v10[4]; // [sp+18h] [bp-40h] BYREF
  float v11; // [sp+1Ch] [bp-3Ch] BYREF
  int32 flags; // [sp+20h] [bp-38h] BYREF
  unsigned __int8 pName[16]; // [sp+24h] [bp-34h] BYREF
  unsigned __int8 pData[24]; // [sp+34h] [bp-24h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 24);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pName, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pName, 16);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&flags, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&flags, 4);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 4);
  v4 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v10, 2);
    UseDataFence = v4;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(v10, 4);
  AnimationBlock = CAnimManager::GetAnimationBlock(pName);
  if ( !AnimationBlock )
    return 0;
  v6 = 0;
  if ( AnimationBlock->m_loaded )
  {
    v7 = (CTaskSimpleRunNamedAnim *)CTask::operator new(0x64u);
    CTaskSimpleRunNamedAnim::CTaskSimpleRunNamedAnim(v7, pData, pName, flags, v11, -1, 0, 0, 0, 0);
    return (CTask *)v8;
  }
  return (CTask *)v6;
}
// 492110: variable 'v8' is possibly undefined
// 49200C: using guessed type char var_40[4];

//----- (00492160) --------------------------------------------------------
void CTaskSimpleDuck::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  bool v2; // r4
  CTaskSimpleDuck *v3; // r0
  int16 nUseShotsWhizzingEvents; // [sp+4h] [bp-14h] BYREF
  uint16 nLengthOfDuck; // [sp+6h] [bp-12h] BYREF
  uint8 nDuckControl; // [sp+9h] [bp-Fh] BYREF
  char pData[2]; // [sp+Ah] [bp-Eh] BYREF
  char v8[2]; // [sp+Ch] [bp-Ch] BYREF
  char v9[10]; // [sp+Eh] [bp-Ah] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nDuckControl, 1);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v8, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nLengthOfDuck, 2);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v9, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nUseShotsWhizzingEvents, 2);
  v3 = (CTaskSimpleDuck *)CTask::operator new(0x28u);
  CTaskSimpleDuck::CTaskSimpleDuck(v3, nDuckControl, nLengthOfDuck, nUseShotsWhizzingEvents);
}
// 492160: using guessed type char pData[2];
// 492160: using guessed type char var_C[2];
// 492160: using guessed type char var_A[10];

//----- (00492214) --------------------------------------------------------
void CTaskSimplePlayHandSignalAnim::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  bool v2; // r4
  bool v3; // r4
  CTaskSimplePlayHandSignalAnim *v4; // r0
  char bHoldLastFrame; // r5
  bool8 useFatHands; // [sp+Bh] [bp-15h] BYREF
  float fBlendDelta; // [sp+Ch] [bp-14h] BYREF
  AnimationId pData; // [sp+10h] [bp-10h] BYREF
  char v9[10]; // [sp+16h] [bp-Ah] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&fBlendDelta, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&fBlendDelta, 4);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v9, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&useFatHands, 1);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v9, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(v9, 1);
  v4 = (CTaskSimplePlayHandSignalAnim *)CTask::operator new(0x24u);
  bHoldLastFrame = v9[0];
  if ( v9[0] )
    bHoldLastFrame = 1;
  CTaskSimplePlayHandSignalAnim::CTaskSimplePlayHandSignalAnim(v4, pData, fBlendDelta, useFatHands, bHoldLastFrame);
}
// 492214: using guessed type AnimationId pData;

//----- (004922FC) --------------------------------------------------------
void CTaskComplexPlayHandSignalAnim::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CTaskComplexPlayHandSignalAnim *v2; // r0
  float v3; // [sp+4h] [bp-14h] BYREF
  AnimationId v4; // [sp+8h] [bp-10h] BYREF
  char pData[2]; // [sp+Ch] [bp-Ch] BYREF
  char v6[10]; // [sp+Eh] [bp-Ah] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v4, 4);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v6, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v3, 4);
  v2 = (CTaskComplexPlayHandSignalAnim *)CTask::operator new(0x18u);
  CTaskComplexPlayHandSignalAnim::CTaskComplexPlayHandSignalAnim(v2, v4, v3);
}
// 4922FC: using guessed type char pData[2];
// 4922FC: using guessed type char var_A[10];
// 4922FC: using guessed type float var_14;

//----- (00492374) --------------------------------------------------------
void CTaskSimpleEvasiveStep::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CEntity *Vehicle; // r0
  bool v3; // r4
  bool v4; // r4
  CEntity *v5; // r4
  CTaskSimpleEvasiveStep *v6; // r0
  int32 nRef; // [sp+0h] [bp-10h] BYREF
  int pData[3]; // [sp+4h] [bp-Ch] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  if ( pData[0] == 2 )
  {
    v3 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
      UseDataFence = v3;
    }
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
    if ( nRef != -1 )
    {
      Vehicle = CPools::GetVehicle(nRef);
      goto LABEL_18;
    }
LABEL_19:
    v5 = 0;
    goto LABEL_20;
  }
  if ( pData[0] == 4 )
  {
    v4 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
      UseDataFence = v4;
    }
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
    if ( nRef != -1 )
    {
      Vehicle = CPools::GetObject(nRef);
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  if ( pData[0] != 3 )
    goto LABEL_19;
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    goto LABEL_19;
  Vehicle = CPools::GetPed(nRef);
LABEL_18:
  v5 = Vehicle;
LABEL_20:
  v6 = (CTaskSimpleEvasiveStep *)CTask::operator new(0x14u);
  CTaskSimpleEvasiveStep::CTaskSimpleEvasiveStep(v6, v5);
}

//----- (00492478) --------------------------------------------------------
void CTaskComplexEvasiveStep::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CEntity *Vehicle; // r0
  bool v3; // r4
  bool v4; // r4
  CEntity *v5; // r4
  bool v6; // r5
  CTaskComplexEvasiveStep *v7; // r0
  CVector nRef; // [sp+0h] [bp-20h] BYREF
  int pData[5]; // [sp+Ch] [bp-14h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  switch ( pData[0] )
  {
    case 2:
      v3 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v3;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( LODWORD(nRef.x) != -1 )
      {
        Vehicle = CPools::GetVehicle(SLODWORD(nRef.x));
        goto LABEL_18;
      }
      break;
    case 4:
      v4 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v4;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( LODWORD(nRef.x) != -1 )
      {
        Vehicle = CPools::GetObject(SLODWORD(nRef.x));
        goto LABEL_18;
      }
      break;
    case 3:
      v1 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v1;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( LODWORD(nRef.x) != -1 )
      {
        Vehicle = CPools::GetPed(SLODWORD(nRef.x));
LABEL_18:
        v5 = Vehicle;
        goto LABEL_20;
      }
      break;
  }
  v5 = 0;
LABEL_20:
  v6 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
    UseDataFence = v6;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 12);
  v7 = (CTaskComplexEvasiveStep *)CTask::operator new(0x1Cu);
  CTaskComplexEvasiveStep::CTaskComplexEvasiveStep(v7, v5, &nRef);
}
// 492478: using guessed type int pData[5];

//----- (004925B8) --------------------------------------------------------
void CTaskComplexEvasiveDiveAndGetUp::CreateTask()
{
  bool v0; // r4
  CVehicle *Vehicle; // r4
  bool v2; // r5
  bool v3; // r5
  bool v4; // r5
  CTaskComplexEvasiveDiveAndGetUp *v5; // r0
  CVector pData; // [sp+8h] [bp-28h] BYREF
  int iUnconsciousTime; // [sp+14h] [bp-1Ch] BYREF
  int32 nRef; // [sp+18h] [bp-18h] BYREF
  bool bAchieveHeadingFirst[18]; // [sp+1Eh] [bp-12h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(nRef);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&iUnconsciousTime, 4);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 12);
  v4 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(bAchieveHeadingFirst, 2);
    UseDataFence = v4;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(bAchieveHeadingFirst, 1);
  v5 = (CTaskComplexEvasiveDiveAndGetUp *)CTask::operator new(0x24u);
  CTaskComplexEvasiveDiveAndGetUp::CTaskComplexEvasiveDiveAndGetUp(
    v5,
    Vehicle,
    iUnconsciousTime,
    &pData,
    bAchieveHeadingFirst[0]);
}

//----- (004926AC) --------------------------------------------------------
void CTaskComplexHitPedWithCar::CreateTask()
{
  bool v0; // r4
  CVehicle *Vehicle; // r4
  bool v2; // r5
  CTaskComplexHitPedWithCar *v3; // r0
  float fImpulseMagnitude; // [sp+4h] [bp-1Ch] BYREF
  int32 nRef; // [sp+8h] [bp-18h] BYREF
  char pData[2]; // [sp+Ch] [bp-14h] BYREF
  char v7[18]; // [sp+Eh] [bp-12h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(nRef);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v7, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&fImpulseMagnitude, 4);
  v3 = (CTaskComplexHitPedWithCar *)CTask::operator new(0x28u);
  CTaskComplexHitPedWithCar::CTaskComplexHitPedWithCar(v3, Vehicle, fImpulseMagnitude);
}
// 4926AC: using guessed type char pData[2];
// 4926AC: using guessed type char var_12[18];

//----- (0049273C) --------------------------------------------------------
void CTaskSimpleKillPedWithCar::CreateTask()
{
  bool v0; // r4
  CVehicle *Vehicle; // r4
  bool v2; // r5
  CTaskSimpleKillPedWithCar *v3; // r0
  float fImpulseMagnitude; // [sp+4h] [bp-1Ch] BYREF
  int32 nRef; // [sp+8h] [bp-18h] BYREF
  char pData[2]; // [sp+Ch] [bp-14h] BYREF
  char v7[18]; // [sp+Eh] [bp-12h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(nRef);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v7, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&fImpulseMagnitude, 4);
  v3 = (CTaskSimpleKillPedWithCar *)CTask::operator new(0x10u);
  CTaskSimpleKillPedWithCar::CTaskSimpleKillPedWithCar(v3, Vehicle, fImpulseMagnitude);
}
// 49273C: using guessed type char pData[2];
// 49273C: using guessed type char var_12[18];

//----- (004927CC) --------------------------------------------------------
void CTaskSimpleHurtPedWithCar::CreateTask()
{
  bool v0; // r4
  CVehicle *Vehicle; // r4
  bool v2; // r5
  CTaskSimpleHurtPedWithCar *v3; // r0
  float fImpulseMagnitude; // [sp+4h] [bp-1Ch] BYREF
  int32 nRef; // [sp+8h] [bp-18h] BYREF
  char pData[2]; // [sp+Ch] [bp-14h] BYREF
  char v7[18]; // [sp+Eh] [bp-12h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(nRef);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v7, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&fImpulseMagnitude, 4);
  v3 = (CTaskSimpleHurtPedWithCar *)CTask::operator new(0x14u);
  CTaskSimpleHurtPedWithCar::CTaskSimpleHurtPedWithCar(v3, Vehicle, fImpulseMagnitude);
}
// 4927CC: using guessed type char pData[2];
// 4927CC: using guessed type char var_12[18];

//----- (0049285C) --------------------------------------------------------
void CTaskComplexWalkRoundCar::CreateTask()
{
  bool v0; // r4
  CVehicle *Vehicle; // r4
  bool v2; // r5
  bool v3; // r5
  bool v4; // r5
  CTaskComplexWalkRoundCar *v5; // r0
  char bGoingForDoor; // r2
  int v7; // [sp+8h] [bp-28h] BYREF
  CVector pData; // [sp+Ch] [bp-24h] BYREF
  char iMoveState[21]; // [sp+1Bh] [bp-15h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&iMoveState[1], 4);
  if ( *(_DWORD *)&iMoveState[1] == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(*(int32 *)&iMoveState[1]);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(iMoveState, 1);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 12);
  v4 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v7, 2);
    UseDataFence = v4;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v7, 4);
  v5 = (CTaskComplexWalkRoundCar *)CTask::operator new(0x58u);
  bGoingForDoor = v7;
  if ( v7 )
    bGoingForDoor = 1;
  CTaskComplexWalkRoundCar::CTaskComplexWalkRoundCar(v5, iMoveState[0], &pData, Vehicle, bGoingForDoor, 0);
}
// 49285C: using guessed type CVector pData;

//----- (00492958) --------------------------------------------------------
void CTaskComplexWalkRoundBuildingAttempt::CreateTask()
{
  bool v0; // r4
  CPed *Ped; // r9
  bool v2; // r5
  bool v3; // r5
  bool v4; // r5
  bool v5; // r6
  bool v6; // r5
  bool v7; // r5
  CTaskComplexWalkRoundBuildingAttempt *v8; // r0
  char bIsHeadOnCollision; // r2
  char v10; // r2
  CVector offset_vector; // [sp+Ch] [bp-54h] BYREF
  CVector v12; // [sp+18h] [bp-48h] BYREF
  CVector vPos; // [sp+24h] [bp-3Ch] BYREF
  CVector pData; // [sp+30h] [bp-30h] BYREF
  char iMoveState[7]; // [sp+3Fh] [bp-21h] BYREF
  char v16[26]; // [sp+46h] [bp-1Ah] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&iMoveState[1], 4);
  if ( *(_DWORD *)&iMoveState[1] == -1 )
    Ped = 0;
  else
    Ped = CPools::GetPed(*(int32 *)&iMoveState[1]);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(iMoveState, 1);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 12);
  v4 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&vPos, 2);
    UseDataFence = v4;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&vPos, 12);
  v5 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v12, 2);
    UseDataFence = v5;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v12, 12);
  v6 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&offset_vector, 2);
    UseDataFence = v6;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&offset_vector, 12);
  v7 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v16, 2);
    UseDataFence = v7;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(v16, 1);
  v8 = (CTaskComplexWalkRoundBuildingAttempt *)CTask::operator new(0x4Cu);
  if ( Ped )
  {
    bIsHeadOnCollision = v16[0];
    if ( v16[0] )
      bIsHeadOnCollision = 1;
    CTaskComplexWalkRoundBuildingAttempt::CTaskComplexWalkRoundBuildingAttempt(
      v8,
      iMoveState[0],
      Ped,
      &offset_vector,
      &vPos,
      &v12,
      bIsHeadOnCollision);
  }
  else
  {
    v10 = v16[0];
    if ( v16[0] )
      v10 = 1;
    CTaskComplexWalkRoundBuildingAttempt::CTaskComplexWalkRoundBuildingAttempt(
      v8,
      iMoveState[0],
      &pData,
      &vPos,
      &v12,
      v10);
  }
}
// 492958: using guessed type CVector pData;

//----- (00492B0C) --------------------------------------------------------
void CTaskComplexWalkRoundObject::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  bool v2; // r4
  bool v3; // r4
  CEntity *Vehicle; // r0
  bool v5; // r4
  bool v6; // r4
  CEntity *v7; // r4
  CTaskComplexWalkRoundObject *v8; // r0
  int32 nRef; // [sp+0h] [bp-20h] BYREF
  int v10; // [sp+4h] [bp-1Ch] BYREF
  CVector pData; // [sp+8h] [bp-18h] BYREF
  int iMoveState[3]; // [sp+14h] [bp-Ch] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(iMoveState, 4);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 12);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v10, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v10, 4);
  if ( v10 == 2 )
  {
    v5 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
      UseDataFence = v5;
    }
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
    if ( nRef != -1 )
    {
      Vehicle = CPools::GetVehicle(nRef);
      goto LABEL_22;
    }
LABEL_23:
    v7 = 0;
    goto LABEL_24;
  }
  if ( v10 == 4 )
  {
    v6 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
      UseDataFence = v6;
    }
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
    if ( nRef != -1 )
    {
      Vehicle = CPools::GetObject(nRef);
      goto LABEL_22;
    }
    goto LABEL_23;
  }
  if ( v10 != 3 )
    goto LABEL_23;
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    goto LABEL_23;
  Vehicle = CPools::GetPed(nRef);
LABEL_22:
  v7 = Vehicle;
LABEL_24:
  v8 = (CTaskComplexWalkRoundObject *)CTask::operator new(0x54u);
  CTaskComplexWalkRoundObject::CTaskComplexWalkRoundObject(v8, iMoveState[0], &pData, v7);
}
// 492B0C: using guessed type int iMoveState[3];

//----- (00492C70) --------------------------------------------------------
void CTaskComplexEvasiveCower::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CEntity *Vehicle; // r0
  bool v3; // r4
  bool v4; // r4
  CEntity *v5; // r4
  bool v6; // r5
  CTaskComplexEvasiveCower *v7; // r0
  CVector nRef; // [sp+0h] [bp-20h] BYREF
  int pData[5]; // [sp+Ch] [bp-14h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  switch ( pData[0] )
  {
    case 2:
      v3 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v3;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( LODWORD(nRef.x) != -1 )
      {
        Vehicle = CPools::GetVehicle(SLODWORD(nRef.x));
        goto LABEL_18;
      }
      break;
    case 4:
      v4 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v4;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( LODWORD(nRef.x) != -1 )
      {
        Vehicle = CPools::GetObject(SLODWORD(nRef.x));
        goto LABEL_18;
      }
      break;
    case 3:
      v1 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v1;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( LODWORD(nRef.x) != -1 )
      {
        Vehicle = CPools::GetPed(SLODWORD(nRef.x));
LABEL_18:
        v5 = Vehicle;
        goto LABEL_20;
      }
      break;
  }
  v5 = 0;
LABEL_20:
  v6 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
    UseDataFence = v6;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 12);
  v7 = (CTaskComplexEvasiveCower *)CTask::operator new(0x1Cu);
  CTaskComplexEvasiveCower::CTaskComplexEvasiveCower(v7, v5, &nRef);
}
// 492C70: using guessed type int pData[5];

//----- (00492DB0) --------------------------------------------------------
void CTaskComplexWalkRoundFire::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  bool v2; // r4
  bool v3; // r4
  CTaskComplexWalkRoundFire *v4; // r0
  CVector vTarget; // [sp+8h] [bp-28h] BYREF
  float fFireRadius; // [sp+14h] [bp-1Ch] BYREF
  CVector pData; // [sp+18h] [bp-18h] BYREF
  int iMoveState[3]; // [sp+24h] [bp-Ch] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(iMoveState, 4);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 12);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&vTarget, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&fFireRadius, 4);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&vTarget, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&vTarget, 12);
  v4 = (CTaskComplexWalkRoundFire *)CTask::operator new(0x38u);
  CTaskComplexWalkRoundFire::CTaskComplexWalkRoundFire(v4, iMoveState[0], &pData, fFireRadius, &vTarget);
}
// 492DB0: using guessed type int iMoveState[3];

//----- (00492E88) --------------------------------------------------------
void CTaskComplexWaitForBackup::CreateTask()
{
  bool v0; // r4
  CPed *Ped; // r8
  bool v2; // r5
  CPed *v3; // r5
  bool v4; // r6
  CTaskComplexWaitForBackup *v5; // r0
  int32 pData[5]; // [sp+4h] [bp-14h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  if ( pData[0] == -1 )
    Ped = 0;
  else
    Ped = CPools::GetPed(pData[0]);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  if ( pData[0] == -1 )
    v3 = 0;
  else
    v3 = CPools::GetPed(pData[0]);
  v4 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v4;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  v5 = (CTaskComplexWaitForBackup *)CTask::operator new(0x24u);
  CTaskComplexWaitForBackup::CTaskComplexWaitForBackup(v5, Ped, v3, *(const float *)pData);
}

//----- (00492F58) --------------------------------------------------------
void CTaskComplexEnterCarAsPassenger::CreateTask()
{
  bool v0; // r4
  CVehicle *Vehicle; // r4
  bool v2; // r5
  bool v3; // r5
  CTaskComplexEnterCarAsPassenger *v4; // r0
  char v5; // r3
  char v6; // [sp+7h] [bp-21h] BYREF
  int iTargetSeat; // [sp+8h] [bp-20h] BYREF
  int32 nRef; // [sp+Ch] [bp-1Ch] BYREF
  char pData[2]; // [sp+12h] [bp-16h] BYREF
  char v10[2]; // [sp+14h] [bp-14h] BYREF
  char v11[18]; // [sp+16h] [bp-12h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(nRef);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v10, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&iTargetSeat, 4);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v11, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v6, 1);
  v4 = (CTaskComplexEnterCarAsPassenger *)CTask::operator new(0x50u);
  v5 = v6;
  if ( v6 )
    v5 = 1;
  CTaskComplexEnterCarAsPassenger::CTaskComplexEnterCarAsPassenger(v4, Vehicle, iTargetSeat, v5);
}
// 492F58: using guessed type char pData[2];
// 492F58: using guessed type char var_14[2];
// 492F58: using guessed type char var_12[18];

//----- (00493024) --------------------------------------------------------
void CTaskComplexDragPedFromCar::CreateTask()
{
  bool v0; // r4
  CPed *Ped; // r4
  bool v2; // r5
  CTaskComplexDragPedFromCar *v3; // r0
  int iDraggedPedDownTime; // [sp+4h] [bp-1Ch] BYREF
  int32 nRef; // [sp+8h] [bp-18h] BYREF
  char pData[2]; // [sp+Ch] [bp-14h] BYREF
  char v7[18]; // [sp+Eh] [bp-12h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    Ped = 0;
  else
    Ped = CPools::GetPed(nRef);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v7, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&iDraggedPedDownTime, 4);
  v3 = (CTaskComplexDragPedFromCar *)CTask::operator new(0x54u);
  CTaskComplexDragPedFromCar::CTaskComplexDragPedFromCar(v3, Ped, iDraggedPedDownTime);
}
// 493024: using guessed type char pData[2];
// 493024: using guessed type char var_12[18];

//----- (004930B4) --------------------------------------------------------
void CTaskComplexLeaveCar::CreateTask()
{
  bool v0; // r4
  CVehicle *Vehicle; // r4
  bool v2; // r5
  bool v3; // r5
  bool v4; // r5
  bool v5; // r5
  CTaskComplexLeaveCar *v6; // r0
  bool bSensibleLeaveCar; // [sp+Fh] [bp-21h] BYREF
  int v8; // [sp+10h] [bp-20h] BYREF
  int v9; // [sp+14h] [bp-1Ch] BYREF
  int32 pData; // [sp+18h] [bp-18h] BYREF
  bool v11[18]; // [sp+1Eh] [bp-12h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
  if ( pData == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(pData);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v9, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v9, 4);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v8, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v8, 4);
  v4 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v11, 2);
    UseDataFence = v4;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&bSensibleLeaveCar, 1);
  v5 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v11, 2);
    UseDataFence = v5;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(v11, 1);
  v6 = (CTaskComplexLeaveCar *)CTask::operator new(0x34u);
  CTaskComplexLeaveCar::CTaskComplexLeaveCar(v6, Vehicle, v9, v8, bSensibleLeaveCar, v11[0]);
}
// 4930B4: using guessed type int32 pData;

//----- (004931E0) --------------------------------------------------------
CTask *CTaskComplexLeaveCarAndDie::CreateTask()
{
  bool v0; // r4
  CVehicle *Vehicle; // r4
  bool v2; // r5
  bool v3; // r5
  CTaskComplexLeaveCar *v4; // r0
  CTask *result; // r0
  int v6; // [sp+Ch] [bp-1Ch] BYREF
  int v7; // [sp+10h] [bp-18h] BYREF
  int32 pData[5]; // [sp+14h] [bp-14h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  if ( pData[0] == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(pData[0]);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v7, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v7, 4);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v6, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v6, 4);
  v4 = (CTaskComplexLeaveCar *)CTask::operator new(0x34u);
  CTaskComplexLeaveCar::CTaskComplexLeaveCar(v4, Vehicle, v7, v6, 0, 1);
  BYTE2(result[3]._vptr$CTask) = 1;
  result->_vptr$CTask = (int (**)(void))&off_66AF44;
  return result;
}
// 493286: variable 'result' is possibly undefined
// 66AF44: using guessed type void *off_66AF44;

//----- (004932B4) --------------------------------------------------------
void CTaskComplexLeaveCarAndFlee::CreateTask()
{
  bool v0; // r4
  CVehicle *Vehicle; // r4
  bool v2; // r5
  bool v3; // r5
  bool v4; // r5
  bool v5; // r5
  CTaskComplexLeaveCarAndFlee *v6; // r0
  int iDelayTime; // [sp+Ch] [bp-2Ch] BYREF
  int v8; // [sp+10h] [bp-28h] BYREF
  CVector pData; // [sp+14h] [bp-24h] BYREF
  int32 nRef; // [sp+20h] [bp-18h] BYREF
  bool v11[18]; // [sp+26h] [bp-12h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(nRef);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 12);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v8, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v8, 4);
  v4 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&iDelayTime, 2);
    UseDataFence = v4;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&iDelayTime, 4);
  v5 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v11, 2);
    UseDataFence = v5;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(v11, 1);
  v6 = (CTaskComplexLeaveCarAndFlee *)CTask::operator new(0x28u);
  CTaskComplexLeaveCarAndFlee::CTaskComplexLeaveCarAndFlee(v6, Vehicle, &pData, v8, iDelayTime, v11[0]);
}

//----- (004933DC) --------------------------------------------------------
void CTaskComplexLeaveCarAndWander::CreateTask()
{
  bool v0; // r4
  CVehicle *Vehicle; // r4
  bool v2; // r5
  bool v3; // r5
  bool v4; // r5
  CTaskComplexLeaveCarAndWander *v5; // r0
  int v6; // [sp+8h] [bp-20h] BYREF
  int v7; // [sp+Ch] [bp-1Ch] BYREF
  int32 pData; // [sp+10h] [bp-18h] BYREF
  bool bSensibleLeaveCar[18]; // [sp+16h] [bp-12h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
  if ( pData == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(pData);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v7, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v7, 4);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v6, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v6, 4);
  v4 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(bSensibleLeaveCar, 2);
    UseDataFence = v4;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(bSensibleLeaveCar, 1);
  v5 = (CTaskComplexLeaveCarAndWander *)CTask::operator new(0x1Cu);
  CTaskComplexLeaveCarAndWander::CTaskComplexLeaveCarAndWander(v5, Vehicle, v7, v6, bSensibleLeaveCar[0]);
}
// 4933DC: using guessed type int32 pData;

//----- (004934D0) --------------------------------------------------------
void CTaskComplexScreamInCarThenLeave::CreateTask()
{
  bool v0; // r4
  CVehicle *Vehicle; // r4
  bool v2; // r5
  CTaskComplexScreamInCarThenLeave *v3; // r0
  int iTargetDoor; // [sp+4h] [bp-1Ch] BYREF
  int32 nRef; // [sp+8h] [bp-18h] BYREF
  char pData[2]; // [sp+Ch] [bp-14h] BYREF
  char v7[18]; // [sp+Eh] [bp-12h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(nRef);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v7, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&iTargetDoor, 4);
  v3 = (CTaskComplexScreamInCarThenLeave *)CTask::operator new(0x20u);
  CTaskComplexScreamInCarThenLeave::CTaskComplexScreamInCarThenLeave(v3, Vehicle, iTargetDoor);
}
// 4934D0: using guessed type char pData[2];
// 4934D0: using guessed type char var_12[18];

//----- (00493560) --------------------------------------------------------
void CTaskComplexDriveToPoint::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  bool v2; // r4
  bool v3; // r4
  bool v4; // r4
  bool v5; // r4
  bool v6; // r4
  CVehicle *Vehicle; // r4
  CTaskComplexDriveToPoint *v8; // r0
  int v9; // [sp+14h] [bp-2Ch] BYREF
  float v10; // [sp+18h] [bp-28h] BYREF
  int v11; // [sp+1Ch] [bp-24h] BYREF
  int v12; // [sp+20h] [bp-20h] BYREF
  float fCruiseSpeed; // [sp+24h] [bp-1Ch] BYREF
  CVector pData; // [sp+28h] [bp-18h] BYREF
  int32 nRef[3]; // [sp+34h] [bp-Ch] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(nRef, 4);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 12);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&fCruiseSpeed, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&fCruiseSpeed, 4);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v12, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v12, 4);
  v4 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 2);
    UseDataFence = v4;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 4);
  v5 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v10, 2);
    UseDataFence = v5;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v10, 4);
  v6 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v9, 2);
    UseDataFence = v6;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v9, 4);
  if ( nRef[0] == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(nRef[0]);
  v8 = (CTaskComplexDriveToPoint *)CTask::operator new(0x3Cu);
  CTaskComplexDriveToPoint::CTaskComplexDriveToPoint(v8, Vehicle, &pData, fCruiseSpeed, v12, v11, v10, v9);
}
// 493560: using guessed type int32 nRef[3];

//----- (004936E0) --------------------------------------------------------
void CTaskComplexCarDriveWander::CreateTask()
{
  bool v0; // r4
  CVehicle *Vehicle; // r4
  bool v2; // r5
  bool v3; // r5
  CTaskComplexCarDriveWander *v4; // r0
  char v5[4]; // [sp+4h] [bp-1Ch] BYREF
  int v6; // [sp+8h] [bp-18h] BYREF
  int32 pData[5]; // [sp+Ch] [bp-14h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  if ( pData[0] == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(pData[0]);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v6, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v6, 4);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v5, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(v5, 4);
  v4 = (CTaskComplexCarDriveWander *)CTask::operator new(0x24u);
  CTaskComplexCarDriveWander::CTaskComplexCarDriveWander(v4, Vehicle, v6, (float)v6);
}
// 4936E0: using guessed type char var_1C[4];

//----- (004937A8) --------------------------------------------------------
void CTaskComplexEnterCarAsPassengerTimed::CreateTask()
{
  bool v0; // r4
  CVehicle *Vehicle; // r4
  CTaskComplexEnterCarAsPassengerTimed *v2; // r0
  int32 nRef; // [sp+8h] [bp-10h] BYREF
  char pData[10]; // [sp+Eh] [bp-Ah] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(nRef);
  v2 = (CTaskComplexEnterCarAsPassengerTimed *)CTask::operator new(0x2Cu);
  CTaskComplexEnterCarAsPassengerTimed::CTaskComplexEnterCarAsPassengerTimed(
    v2,
    Vehicle,
    0,
    (const int)&elf_hash_bucket[4937],
    0);
}
// FC: using guessed type int elf_hash_bucket[16411];
// 4937A8: using guessed type char pData[10];

//----- (00493810) --------------------------------------------------------
CTask *CTaskComplexLeaveAnyCar::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  bool v2; // r4
  CTaskComplex *v3; // r0
  char v4; // r4
  char v5; // r5
  CTask *v6; // r6
  CTask *result; // r0
  char v8; // [sp+2h] [bp-1Eh] BYREF
  char v9; // [sp+3h] [bp-1Dh] BYREF
  CTask *v10; // [sp+4h] [bp-1Ch] BYREF
  char pData[2]; // [sp+Ah] [bp-16h] BYREF
  char v12[2]; // [sp+Ch] [bp-14h] BYREF
  char v13[18]; // [sp+Eh] [bp-12h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v10, 4);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v12, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v9, 1);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v13, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v8, 1);
  v3 = (CTaskComplex *)CTask::operator new(0x14u);
  v4 = v8;
  v5 = v9;
  v6 = v10;
  CTaskComplex::CTaskComplex(v3);
  result[1].m_pParent = v6;
  result->_vptr$CTask = (int (**)(void))&off_66AF80;
  LOBYTE(result[2]._vptr$CTask) = v5;
  BYTE1(result[2]._vptr$CTask) = v4;
  return result;
}
// 4938AA: variable 'result' is possibly undefined
// 66AF80: using guessed type void *off_66AF80;
// 677A98: using guessed type void *`vtable for'CTaskComplexLeaveAnyCar;
// 493810: using guessed type char pData[2];
// 493810: using guessed type CTask *var_1C;
// 493810: using guessed type char var_14[2];
// 493810: using guessed type char var_12[18];

//----- (004938DC) --------------------------------------------------------
void CTaskComplexLeaveBoat::CreateTask()
{
  bool v0; // r4
  CVehicle *Vehicle; // r4
  bool v2; // r5
  CTaskComplexLeaveBoat *v3; // r0
  int iDelayTime; // [sp+4h] [bp-1Ch] BYREF
  int32 nRef; // [sp+8h] [bp-18h] BYREF
  char pData[2]; // [sp+Ch] [bp-14h] BYREF
  char v7[18]; // [sp+Eh] [bp-12h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(nRef);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v7, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&iDelayTime, 4);
  v3 = (CTaskComplexLeaveBoat *)CTask::operator new(0x14u);
  CTaskComplexLeaveBoat::CTaskComplexLeaveBoat(v3, Vehicle, iDelayTime);
}
// 4938DC: using guessed type char pData[2];
// 4938DC: using guessed type char var_12[18];

//----- (0049396C) --------------------------------------------------------
void CTaskComplexEnterCarAsPassengerWait::CreateTask()
{
  bool v0; // r4
  CVehicle *Vehicle; // r8
  bool v2; // r5
  CPed *Ped; // r5
  bool v4; // r6
  bool v5; // r6
  CTaskComplexEnterCarAsPassengerWait *v6; // r0
  bool bForceFrontSeat; // [sp+7h] [bp-19h] BYREF
  int32 nRef; // [sp+8h] [bp-18h] BYREF
  int32 pData[5]; // [sp+Ch] [bp-14h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  if ( pData[0] == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(pData[0]);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    Ped = 0;
  else
    Ped = CPools::GetPed(nRef);
  v4 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
    UseDataFence = v4;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&bForceFrontSeat, 1);
  v5 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
    UseDataFence = v5;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  v6 = (CTaskComplexEnterCarAsPassengerWait *)CTask::operator new(0x24u);
  CTaskComplexEnterCarAsPassengerWait::CTaskComplexEnterCarAsPassengerWait(v6, Vehicle, Ped, bForceFrontSeat, nRef);
}

//----- (00493A70) --------------------------------------------------------
CTask *CTaskSimpleCarDriveTimed::CreateTask()
{
  bool v0; // r4
  CVehicle *Vehicle; // r4
  bool v2; // r5
  CTaskSimpleCarDrive *v3; // r0
  int (**v4)(void); // r5
  CTask *result; // r0
  int (**v6)(void); // [sp+4h] [bp-1Ch] BYREF
  int32 nRef; // [sp+8h] [bp-18h] BYREF
  char pData[2]; // [sp+Ch] [bp-14h] BYREF
  char v9[18]; // [sp+Eh] [bp-12h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(nRef);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v9, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v6, 4);
  v3 = (CTaskSimpleCarDrive *)CTask::operator new(0x70u);
  v4 = v6;
  CTaskSimpleCarDrive::CTaskSimpleCarDrive(v3, Vehicle, 0, 0);
  result[12]._vptr$CTask = v4;
  result->_vptr$CTask = (int (**)(void))&off_66571C;
  LOWORD(result[13].m_pParent) = 0;
  result[12].m_pParent = 0;
  result[13]._vptr$CTask = 0;
  return result;
}
// 493AEE: variable 'result' is possibly undefined
// 66571C: using guessed type void *off_66571C;
// 676B38: using guessed type void *`vtable for'CTaskSimpleCarDriveTimed;
// 493A70: using guessed type char pData[2];
// 493A70: using guessed type char var_12[18];

//----- (00493B1C) --------------------------------------------------------
void CTaskComplexDrivePointRoute::CreateTask()
{
  bool v0; // r4
  CVehicle *Vehicle; // r8
  bool v2; // r5
  bool v3; // r6
  bool v4; // r5
  bool v5; // r5
  bool v6; // r5
  bool v7; // r5
  CTaskComplexDrivePointRoute *v8; // r0
  int iDrivingStyle; // [sp+14h] [bp-8Ch] BYREF
  float v10; // [sp+18h] [bp-88h] BYREF
  int v11; // [sp+1Ch] [bp-84h] BYREF
  int iMode; // [sp+20h] [bp-80h] BYREF
  float fCruiseSpeed; // [sp+24h] [bp-7Ch] BYREF
  CPointRoute pData; // [sp+28h] [bp-78h] BYREF
  int32 nRef[5]; // [sp+8Ch] [bp-14h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(nRef, 4);
  if ( nRef[0] == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(nRef[0]);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v2;
  }
  pData.m_iRouteSize = 0;
  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 100);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&fCruiseSpeed, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&fCruiseSpeed, 4);
  v4 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&iMode, 2);
    UseDataFence = v4;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&iMode, 4);
  v5 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 2);
    UseDataFence = v5;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 4);
  v6 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v10, 2);
    UseDataFence = v6;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v10, 4);
  v7 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&iDrivingStyle, 2);
    UseDataFence = v7;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&iDrivingStyle, 4);
  v8 = (CTaskComplexDrivePointRoute *)CTask::operator new(0x2Cu);
  CTaskComplexDrivePointRoute::CTaskComplexDrivePointRoute(
    v8,
    Vehicle,
    &pData,
    fCruiseSpeed,
    iMode,
    v11,
    v10,
    iDrivingStyle);
}
// 493B1C: using guessed type int32 nRef[5];

//----- (00493CA8) --------------------------------------------------------
void CTaskSimpleCarSetTempAction::CreateTask()
{
  bool v0; // r4
  CVehicle *Vehicle; // r4
  bool v2; // r5
  bool v3; // r5
  CTaskSimpleCarSetTempAction *v4; // r0
  int v5; // [sp+4h] [bp-1Ch] BYREF
  int v6; // [sp+8h] [bp-18h] BYREF
  int32 pData[5]; // [sp+Ch] [bp-14h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  if ( pData[0] == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(pData[0]);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v6, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v6, 4);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v5, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v5, 4);
  v4 = (CTaskSimpleCarSetTempAction *)CTask::operator new(0x68u);
  CTaskSimpleCarSetTempAction::CTaskSimpleCarSetTempAction(v4, Vehicle, v6, v5);
}

//----- (00493D64) --------------------------------------------------------
void CTaskComplexCarDriveMission::CreateTask()
{
  bool v0; // r4
  CVehicle *Vehicle; // r8
  bool v2; // r5
  bool v3; // r5
  CEntity *Object; // r0
  bool v5; // r5
  bool v6; // r5
  CEntity *v7; // r5
  bool v8; // r6
  CTaskComplexCarDriveMission *v9; // r0
  int32 nRef; // [sp+Ch] [bp-1Ch] BYREF
  int v11; // [sp+10h] [bp-18h] BYREF
  int32 pData[5]; // [sp+14h] [bp-14h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  if ( pData[0] == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(pData[0]);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 4);
  switch ( v11 )
  {
    case 2:
      v5 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v5;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Object = CPools::GetVehicle(nRef);
        goto LABEL_23;
      }
      break;
    case 4:
      v6 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v6;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Object = CPools::GetObject(nRef);
        goto LABEL_23;
      }
      break;
    case 3:
      v3 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v3;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Object = CPools::GetPed(nRef);
LABEL_23:
        v7 = Object;
        goto LABEL_25;
      }
      break;
  }
  v7 = 0;
LABEL_25:
  v8 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
    UseDataFence = v8;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  v9 = (CTaskComplexCarDriveMission *)CTask::operator new(0x2Cu);
  CTaskComplexCarDriveMission::CTaskComplexCarDriveMission(v9, Vehicle, v7, nRef, 0, 10.0);
}

//----- (00493EF0) --------------------------------------------------------
void CTaskComplexCarDrive::CreateTask()
{
  bool v0; // r4
  CVehicle *Vehicle; // r4
  bool v2; // r5
  bool v3; // r5
  bool v4; // r5
  CTaskComplexCarDrive *v5; // r0
  int iDrivingStyle; // [sp+8h] [bp-20h] BYREF
  int v7; // [sp+Ch] [bp-1Ch] BYREF
  float fCruiseSpeed; // [sp+10h] [bp-18h] BYREF
  int32 pData[5]; // [sp+14h] [bp-14h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  if ( pData[0] == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(pData[0]);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&fCruiseSpeed, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&fCruiseSpeed, 4);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v7, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v7, 4);
  v4 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&iDrivingStyle, 2);
    UseDataFence = v4;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&iDrivingStyle, 4);
  v5 = (CTaskComplexCarDrive *)CTask::operator new(0x24u);
  CTaskComplexCarDrive::CTaskComplexCarDrive(v5, Vehicle, fCruiseSpeed, v7, iDrivingStyle);
}

//----- (00493FE0) --------------------------------------------------------
CTask *CTaskComplexCarDriveMissionFleeScene::CreateTask()
{
  bool v0; // r4
  CVehicle *Vehicle; // r4
  CTaskComplexCarDriveMission *v2; // r0
  CTask *result; // r0
  int32 nRef; // [sp+8h] [bp-10h] BYREF
  char pData[10]; // [sp+Eh] [bp-Ah] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(nRef);
  v2 = (CTaskComplexCarDriveMission *)CTask::operator new(0x2Cu);
  CTaskComplexCarDriveMission::CTaskComplexCarDriveMission(v2, Vehicle, 0, 1, 2, 40.0);
  result->_vptr$CTask = (int (**)(void))&off_667284;
  return result;
}
// 494042: variable 'result' is possibly undefined
// 667284: using guessed type void *off_667284;
// 677E30: using guessed type void *`vtable for'CTaskComplexCarDriveMissionFleeScene;
// 493FE0: using guessed type char pData[10];

//----- (00494054) --------------------------------------------------------
void CTaskComplexOpenPassengerDoor::CreateTask()
{
  bool v0; // r4
  CVehicle *Vehicle; // r4
  bool v2; // r5
  CTaskComplexOpenPassengerDoor *v3; // r0
  int iTargetSeat; // [sp+4h] [bp-1Ch] BYREF
  int32 nRef; // [sp+8h] [bp-18h] BYREF
  char pData[2]; // [sp+Ch] [bp-14h] BYREF
  char v7[18]; // [sp+Eh] [bp-12h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(nRef);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v7, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&iTargetSeat, 4);
  v3 = (CTaskComplexOpenPassengerDoor *)CTask::operator new(0x50u);
  CTaskComplexOpenPassengerDoor::CTaskComplexOpenPassengerDoor(v3, Vehicle, iTargetSeat);
}
// 494054: using guessed type char pData[2];
// 494054: using guessed type char var_12[18];

//----- (004940E4) --------------------------------------------------------
CTask *CTaskComplexCarDriveMissionKillPed::CreateTask()
{
  bool v0; // r4
  CVehicle *Vehicle; // r4
  bool v2; // r5
  bool v3; // r5
  CEntity *Object; // r0
  bool v5; // r5
  bool v6; // r5
  CEntity *v7; // r5
  CTaskComplexCarDriveMission *v8; // r0
  CTask *result; // r0
  int32 nRef; // [sp+Ch] [bp-1Ch] BYREF
  int v11; // [sp+10h] [bp-18h] BYREF
  int32 pData[5]; // [sp+14h] [bp-14h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  if ( pData[0] == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(pData[0]);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 4);
  if ( v11 == 2 )
  {
    v5 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
      UseDataFence = v5;
    }
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
    if ( nRef != -1 )
    {
      Object = CPools::GetVehicle(nRef);
      goto LABEL_23;
    }
LABEL_24:
    v7 = 0;
    goto LABEL_25;
  }
  if ( v11 == 4 )
  {
    v6 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
      UseDataFence = v6;
    }
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
    if ( nRef != -1 )
    {
      Object = CPools::GetObject(nRef);
      goto LABEL_23;
    }
    goto LABEL_24;
  }
  if ( v11 != 3 )
    goto LABEL_24;
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    goto LABEL_24;
  Object = CPools::GetPed(nRef);
LABEL_23:
  v7 = Object;
LABEL_25:
  v8 = (CTaskComplexCarDriveMission *)CTask::operator new(0x2Cu);
  CTaskComplexCarDriveMission::CTaskComplexCarDriveMission(v8, Vehicle, v7, 54, 3, 40.0);
  result->_vptr$CTask = (int (**)(void))&off_667344;
  return result;
}
// 494216: variable 'result' is possibly undefined
// 667344: using guessed type void *off_667344;
// 677834: using guessed type void *`vtable for'CTaskComplexCarDriveMissionKillPed;

//----- (0049424C) --------------------------------------------------------
void CTaskComplexGoToCarDoorAndStandStill::CreateTask()
{
  bool v0; // r4
  CVehicle *Vehicle; // r4
  bool v2; // r5
  bool v3; // r5
  bool v4; // r5
  bool v5; // r5
  bool v6; // r5
  bool v7; // r5
  CTaskComplexGoToCarDoorAndStandStill *v8; // r0
  int v9; // [sp+14h] [bp-2Ch] BYREF
  float v10; // [sp+18h] [bp-28h] BYREF
  float v11; // [sp+1Ch] [bp-24h] BYREF
  int iTargetSeat; // [sp+20h] [bp-20h] BYREF
  bool bIsDriver; // [sp+27h] [bp-19h] BYREF
  int iMoveState; // [sp+28h] [bp-18h] BYREF
  int32 pData[5]; // [sp+2Ch] [bp-14h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  if ( pData[0] == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(pData[0]);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&iMoveState, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&iMoveState, 4);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&iTargetSeat, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&bIsDriver, 1);
  v4 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&iTargetSeat, 2);
    UseDataFence = v4;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&iTargetSeat, 4);
  v5 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 2);
    UseDataFence = v5;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 4);
  v6 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v10, 2);
    UseDataFence = v6;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v10, 4);
  v7 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v9, 2);
    UseDataFence = v7;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v9, 4);
  v8 = (CTaskComplexGoToCarDoorAndStandStill *)CTask::operator new(0x50u);
  CTaskComplexGoToCarDoorAndStandStill::CTaskComplexGoToCarDoorAndStandStill(
    v8,
    Vehicle,
    iMoveState,
    bIsDriver,
    iTargetSeat,
    v11,
    v10,
    (float)v9,
    (const int)&elf_hash_bucket[7437]);
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (004943F4) --------------------------------------------------------
void CTaskComplexGoToPointShooting::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  bool v2; // r4
  bool v3; // r4
  CEntity *Vehicle; // r0
  bool v5; // r4
  bool v6; // r4
  CEntity *v7; // r4
  bool v8; // r5
  bool v9; // r5
  bool v10; // r5
  CTaskComplexGoToPointShooting *v11; // r0
  float v12; // [sp+18h] [bp-38h] BYREF
  float v13; // [sp+1Ch] [bp-34h] BYREF
  CVector nRef; // [sp+20h] [bp-30h] BYREF
  int v15; // [sp+2Ch] [bp-24h] BYREF
  CVector pData; // [sp+30h] [bp-20h] BYREF
  int iMoveState[5]; // [sp+3Ch] [bp-14h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(iMoveState, 4);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 12);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v15, 4);
  switch ( v15 )
  {
    case 2:
      v5 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v5;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( LODWORD(nRef.x) != -1 )
      {
        Vehicle = CPools::GetVehicle(SLODWORD(nRef.x));
        goto LABEL_22;
      }
      break;
    case 4:
      v6 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v6;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( LODWORD(nRef.x) != -1 )
      {
        Vehicle = CPools::GetObject(SLODWORD(nRef.x));
        goto LABEL_22;
      }
      break;
    case 3:
      v3 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v3;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( LODWORD(nRef.x) != -1 )
      {
        Vehicle = CPools::GetPed(SLODWORD(nRef.x));
LABEL_22:
        v7 = Vehicle;
        goto LABEL_24;
      }
      break;
  }
  v7 = 0;
LABEL_24:
  v8 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
    UseDataFence = v8;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 12);
  v9 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v13, 2);
    UseDataFence = v9;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v13, 4);
  v10 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v12, 2);
    UseDataFence = v10;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v12, 4);
  v11 = (CTaskComplexGoToPointShooting *)CTask::operator new(0x38u);
  CTaskComplexGoToPointShooting::CTaskComplexGoToPointShooting(v11, iMoveState[0], &pData, v7, nRef, v13, v12);
}
// 4943F4: using guessed type int iMoveState[5];

//----- (00494604) --------------------------------------------------------
void CTaskSimpleAchieveHeading::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  bool v2; // r4
  CTaskSimpleAchieveHeading *v3; // r0
  float v4; // [sp+4h] [bp-14h] BYREF
  float v5; // [sp+8h] [bp-10h] BYREF
  int pData[3]; // [sp+Ch] [bp-Ch] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v5, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v5, 4);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v4, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v4, 4);
  v3 = (CTaskSimpleAchieveHeading *)CTask::operator new(0x18u);
  CTaskSimpleAchieveHeading::CTaskSimpleAchieveHeading(v3, *(const float *)pData, v5, v4);
}
// 494604: using guessed type float var_10;
// 494604: using guessed type float var_14;

//----- (004946A8) --------------------------------------------------------
void CTaskComplexGoToPointAndStandStill::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  bool v2; // r4
  bool v3; // r4
  CTaskComplexGoToPointAndStandStill *v4; // r0
  float v5; // [sp+10h] [bp-20h] BYREF
  float fTargetRadius; // [sp+14h] [bp-1Ch] BYREF
  CVector pData; // [sp+18h] [bp-18h] BYREF
  int iMoveState[3]; // [sp+24h] [bp-Ch] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(iMoveState, 4);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 12);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&fTargetRadius, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&fTargetRadius, 4);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v5, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v5, 4);
  v4 = (CTaskComplexGoToPointAndStandStill *)CTask::operator new(0x28u);
  CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(
    v4,
    iMoveState[0],
    &pData,
    fTargetRadius,
    v5,
    0,
    0);
}
// 4946A8: using guessed type int iMoveState[3];

//----- (00494788) --------------------------------------------------------
void CTaskComplexGoToPointAndStandStillAndAchieveHeading::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  bool v2; // r4
  CTaskComplexGoToPointAndStandStillAndAchieveHeading *v3; // r0
  float fDesiredHeading; // [sp+Ch] [bp-1Ch] BYREF
  CVector pData; // [sp+10h] [bp-18h] BYREF
  int iMoveState[3]; // [sp+1Ch] [bp-Ch] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(iMoveState, 4);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 12);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&fDesiredHeading, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&fDesiredHeading, 4);
  v3 = (CTaskComplexGoToPointAndStandStillAndAchieveHeading *)CTask::operator new(0x30u);
  CTaskComplexGoToPointAndStandStillAndAchieveHeading::CTaskComplexGoToPointAndStandStillAndAchieveHeading(
    v3,
    iMoveState[0],
    &pData,
    fDesiredHeading,
    0.5,
    0.5,
    0.2);
}
// 494788: using guessed type int iMoveState[3];

//----- (00494864) --------------------------------------------------------
void CTaskComplexFollowPointRoute::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  bool v2; // r5
  bool v3; // r4
  bool v4; // r4
  bool v5; // r4
  bool v6; // r4
  bool v7; // r4
  CTaskComplexFollowPointRoute *v8; // r0
  unsigned __int8 v9; // [sp+16h] [bp-8Ah] BYREF
  bool bMustOvershootTarget; // [sp+17h] [bp-89h] BYREF
  float v11; // [sp+18h] [bp-88h] BYREF
  float v12; // [sp+1Ch] [bp-84h] BYREF
  int iMode; // [sp+20h] [bp-80h] BYREF
  CPointRoute pData; // [sp+24h] [bp-7Ch] BYREF
  int v15; // [sp+88h] [bp-18h] BYREF
  bool bStandStillAfterMove[18]; // [sp+8Eh] [bp-12h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v15, 4);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v1;
  }
  pData.m_iRouteSize = 0;
  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 100);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&iMode, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&iMode, 4);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v12, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v12, 4);
  v4 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 2);
    UseDataFence = v4;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 4);
  v5 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(bStandStillAfterMove, 2);
    UseDataFence = v5;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&bMustOvershootTarget, 1);
  v6 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(bStandStillAfterMove, 2);
    UseDataFence = v6;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v9, 1);
  v7 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(bStandStillAfterMove, 2);
    UseDataFence = v7;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(bStandStillAfterMove, 1);
  v8 = (CTaskComplexFollowPointRoute *)CTask::operator new(0x3Cu);
  CTaskComplexFollowPointRoute::CTaskComplexFollowPointRoute(
    v8,
    v15,
    &pData,
    iMode,
    v12,
    v11,
    bMustOvershootTarget,
    v9,
    bStandStillAfterMove[0]);
}

//----- (00494A28) --------------------------------------------------------
void CTaskComplexFollowNodeRoute::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  bool v2; // r4
  bool v3; // r4
  bool v4; // r4
  bool v5; // r4
  bool v6; // r4
  bool v7; // r4
  CTaskComplexFollowNodeRoute *v8; // r0
  int bUseBlending; // r4
  int v10; // [sp+18h] [bp-30h] BYREF
  int v11; // [sp+1Ch] [bp-2Ch] BYREF
  int v12; // [sp+20h] [bp-28h] BYREF
  float v13; // [sp+24h] [bp-24h] BYREF
  float v14; // [sp+28h] [bp-20h] BYREF
  float fTargetRadius; // [sp+2Ch] [bp-1Ch] BYREF
  CVector pData; // [sp+30h] [bp-18h] BYREF
  int iMoveState[3]; // [sp+3Ch] [bp-Ch] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(iMoveState, 4);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 12);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&fTargetRadius, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&fTargetRadius, 4);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v14, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v14, 4);
  v4 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v13, 2);
    UseDataFence = v4;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v13, 4);
  v5 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v12, 2);
    UseDataFence = v5;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v12, 4);
  v6 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 2);
    UseDataFence = v6;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 4);
  v7 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v10, 2);
    UseDataFence = v7;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v10, 4);
  v8 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x60u);
  bUseBlending = v10;
  if ( v10 )
    bUseBlending = 1;
  CTaskComplexFollowNodeRoute::CTaskComplexFollowNodeRoute(
    v8,
    iMoveState[0],
    &pData,
    fTargetRadius,
    v14,
    v13,
    v12 != 0,
    v11,
    bUseBlending);
}
// 494A28: using guessed type int iMoveState[3];

//----- (00494BE0) --------------------------------------------------------
CTask *CTaskComplexSeekEntity<CEntitySeekPosCalculator>::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CEntity *Vehicle; // r0
  bool v3; // r4
  bool v4; // r4
  CEntity *v5; // r4
  void *v6; // r5
  char v7; // r2
  int32 nRef; // [sp+0h] [bp-10h] BYREF
  int pData[3]; // [sp+4h] [bp-Ch] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  switch ( pData[0] )
  {
    case 2:
      v3 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v3;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetVehicle(nRef);
        goto LABEL_18;
      }
      break;
    case 4:
      v4 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v4;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetObject(nRef);
        goto LABEL_18;
      }
      break;
    case 3:
      v1 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v1;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetPed(nRef);
LABEL_18:
        v5 = Vehicle;
        goto LABEL_20;
      }
      break;
  }
  v5 = 0;
LABEL_20:
  v6 = CTask::operator new(0x4Cu);
  CTaskComplex::CTaskComplex((CTaskComplex *)v6);
  *((_QWORD *)v6 + 3) = 0x400000003F800000LL;
  *((_QWORD *)v6 + 4) = 0x4000000000000000LL;
  *((_QWORD *)v6 + 2) = 0x3E80000C350LL;
  *((_WORD *)v6 + 24) = 0;
  *((_WORD *)v6 + 30) = 0;
  *((_DWORD *)v6 + 10) = 0;
  *((_DWORD *)v6 + 11) = 0;
  *((_DWORD *)v6 + 13) = 0;
  *((_DWORD *)v6 + 14) = 0;
  *((_DWORD *)v6 + 17) = 6;
  v7 = *((_BYTE *)v6 + 72);
  *(_DWORD *)v6 = &off_668920;
  *((_DWORD *)v6 + 16) = &off_66895C;
  *((_BYTE *)v6 + 72) = v7 & 0xF0 | 3;
  *((_DWORD *)v6 + 3) = v5;
  if ( v5 )
    CEntity::RegisterReference(v5, (CEntity **)v6 + 3);
  return (CTask *)v6;
}
// 668920: using guessed type void *off_668920;
// 66895C: using guessed type void *off_66895C;

//----- (00494D70) --------------------------------------------------------
CTask *CTaskComplexSeekEntity<CEntitySeekPosCalculatorStandard>::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CEntity *Vehicle; // r0
  bool v3; // r4
  bool v4; // r4
  CEntity *v5; // r4
  void *v6; // r5
  char v7; // r2
  int32 nRef; // [sp+0h] [bp-10h] BYREF
  int pData[3]; // [sp+4h] [bp-Ch] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  switch ( pData[0] )
  {
    case 2:
      v3 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v3;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetVehicle(nRef);
        goto LABEL_18;
      }
      break;
    case 4:
      v4 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v4;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetObject(nRef);
        goto LABEL_18;
      }
      break;
    case 3:
      v1 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v1;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetPed(nRef);
LABEL_18:
        v5 = Vehicle;
        goto LABEL_20;
      }
      break;
  }
  v5 = 0;
LABEL_20:
  v6 = CTask::operator new(0x4Cu);
  CTaskComplex::CTaskComplex((CTaskComplex *)v6);
  *((_QWORD *)v6 + 3) = 0x400000003F800000LL;
  *((_QWORD *)v6 + 4) = 0x4000000000000000LL;
  *((_QWORD *)v6 + 2) = 0x3E80000C350LL;
  *((_WORD *)v6 + 24) = 0;
  *((_WORD *)v6 + 30) = 0;
  *((_DWORD *)v6 + 10) = 0;
  *((_DWORD *)v6 + 11) = 0;
  *((_DWORD *)v6 + 13) = 0;
  *((_DWORD *)v6 + 14) = 0;
  *((_DWORD *)v6 + 17) = 6;
  v7 = *((_BYTE *)v6 + 72);
  *(_DWORD *)v6 = &off_6656D4;
  *((_DWORD *)v6 + 16) = &off_665710;
  *((_BYTE *)v6 + 72) = v7 & 0xF0 | 3;
  *((_DWORD *)v6 + 3) = v5;
  if ( v5 )
    CEntity::RegisterReference(v5, (CEntity **)v6 + 3);
  return (CTask *)v6;
}
// 6656D4: using guessed type void *off_6656D4;
// 665710: using guessed type void *off_665710;

//----- (00494F00) --------------------------------------------------------
CTask *CTaskComplexSeekEntity<CEntitySeekPosCalculatorRadiusAngleOffset>::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CEntity *Vehicle; // r0
  bool v3; // r4
  bool v4; // r4
  CEntity *v5; // r4
  void *v6; // r5
  char v7; // r2
  int32 nRef; // [sp+0h] [bp-10h] BYREF
  int pData[3]; // [sp+4h] [bp-Ch] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  switch ( pData[0] )
  {
    case 2:
      v3 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v3;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetVehicle(nRef);
        goto LABEL_18;
      }
      break;
    case 4:
      v4 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v4;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetObject(nRef);
        goto LABEL_18;
      }
      break;
    case 3:
      v1 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v1;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetPed(nRef);
LABEL_18:
        v5 = Vehicle;
        goto LABEL_20;
      }
      break;
  }
  v5 = 0;
LABEL_20:
  v6 = CTask::operator new(0x54u);
  CTaskComplex::CTaskComplex((CTaskComplex *)v6);
  *((_QWORD *)v6 + 3) = 0x400000003F800000LL;
  *((_QWORD *)v6 + 4) = 0x4000000000000000LL;
  *((_QWORD *)v6 + 2) = 0x3E80000C350LL;
  *((_WORD *)v6 + 24) = 0;
  *((_WORD *)v6 + 30) = 0;
  *((_DWORD *)v6 + 10) = 0;
  *((_DWORD *)v6 + 11) = 0;
  *((_DWORD *)v6 + 13) = 0;
  *((_DWORD *)v6 + 14) = 0;
  *((_DWORD *)v6 + 17) = 0;
  *((_DWORD *)v6 + 18) = 0;
  *((_DWORD *)v6 + 19) = 6;
  v7 = *((_BYTE *)v6 + 80);
  *(_DWORD *)v6 = &off_6658D0;
  *((_DWORD *)v6 + 16) = &off_66D3C0;
  *((_BYTE *)v6 + 80) = v7 & 0xF0 | 3;
  *((_DWORD *)v6 + 3) = v5;
  if ( v5 )
    CEntity::RegisterReference(v5, (CEntity **)v6 + 3);
  return (CTask *)v6;
}
// 6658D0: using guessed type void *off_6658D0;
// 66D3C0: using guessed type void *off_66D3C0;

//----- (004950A0) --------------------------------------------------------
CTask *CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset>::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CEntity *Vehicle; // r0
  bool v3; // r4
  bool v4; // r4
  CEntity *v5; // r4
  void *v6; // r5
  char v7; // r2
  int32 nRef; // [sp+0h] [bp-10h] BYREF
  int pData[3]; // [sp+4h] [bp-Ch] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  switch ( pData[0] )
  {
    case 2:
      v3 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v3;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetVehicle(nRef);
        goto LABEL_18;
      }
      break;
    case 4:
      v4 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v4;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetObject(nRef);
        goto LABEL_18;
      }
      break;
    case 3:
      v1 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v1;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetPed(nRef);
LABEL_18:
        v5 = Vehicle;
        goto LABEL_20;
      }
      break;
  }
  v5 = 0;
LABEL_20:
  v6 = CTask::operator new(0x58u);
  CTaskComplex::CTaskComplex((CTaskComplex *)v6);
  *((_QWORD *)v6 + 3) = 0x400000003F800000LL;
  *((_QWORD *)v6 + 4) = 0x4000000000000000LL;
  *((_QWORD *)v6 + 2) = 0x3E80000C350LL;
  *((_WORD *)v6 + 24) = 0;
  *((_WORD *)v6 + 30) = 0;
  *((_DWORD *)v6 + 10) = 0;
  *((_DWORD *)v6 + 11) = 0;
  *((_DWORD *)v6 + 13) = 0;
  *((_DWORD *)v6 + 14) = 0;
  *((_DWORD *)v6 + 17) = 0;
  *((_DWORD *)v6 + 18) = 0;
  *((_DWORD *)v6 + 19) = 0;
  *((_DWORD *)v6 + 20) = 6;
  v7 = *((_BYTE *)v6 + 84);
  *(_DWORD *)v6 = &off_668968;
  *((_DWORD *)v6 + 16) = &off_66D3CC;
  *((_BYTE *)v6 + 84) = v7 & 0xF0 | 3;
  *((_DWORD *)v6 + 3) = v5;
  if ( v5 )
    CEntity::RegisterReference(v5, (CEntity **)v6 + 3);
  return (CTask *)v6;
}
// 668968: using guessed type void *off_668968;
// 66D3CC: using guessed type void *off_66D3CC;

//----- (00495240) --------------------------------------------------------
CTask *CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface>::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CEntity *Vehicle; // r0
  bool v3; // r4
  bool v4; // r4
  CEntity *v5; // r4
  void *v6; // r5
  char v7; // r2
  int32 nRef; // [sp+0h] [bp-10h] BYREF
  int pData[3]; // [sp+4h] [bp-Ch] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  switch ( pData[0] )
  {
    case 2:
      v3 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v3;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetVehicle(nRef);
        goto LABEL_18;
      }
      break;
    case 4:
      v4 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v4;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetObject(nRef);
        goto LABEL_18;
      }
      break;
    case 3:
      v1 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v1;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetPed(nRef);
LABEL_18:
        v5 = Vehicle;
        goto LABEL_20;
      }
      break;
  }
  v5 = 0;
LABEL_20:
  v6 = CTask::operator new(0x4Cu);
  CTaskComplex::CTaskComplex((CTaskComplex *)v6);
  *((_QWORD *)v6 + 3) = 0x400000003F800000LL;
  *((_QWORD *)v6 + 4) = 0x4000000000000000LL;
  *((_QWORD *)v6 + 2) = 0x3E80000C350LL;
  *((_WORD *)v6 + 24) = 0;
  *((_WORD *)v6 + 30) = 0;
  *((_DWORD *)v6 + 10) = 0;
  *((_DWORD *)v6 + 11) = 0;
  *((_DWORD *)v6 + 13) = 0;
  *((_DWORD *)v6 + 14) = 0;
  *((_DWORD *)v6 + 17) = 6;
  v7 = *((_BYTE *)v6 + 72);
  *(_DWORD *)v6 = &off_6689A4;
  *((_DWORD *)v6 + 16) = &off_66D3D8;
  *((_BYTE *)v6 + 72) = v7 & 0xF0 | 3;
  *((_DWORD *)v6 + 3) = v5;
  if ( v5 )
    CEntity::RegisterReference(v5, (CEntity **)v6 + 3);
  return (CTask *)v6;
}
// 6689A4: using guessed type void *off_6689A4;
// 66D3D8: using guessed type void *off_66D3D8;

//----- (004953D0) --------------------------------------------------------
CTask *CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId>::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CEntity *Vehicle; // r0
  bool v3; // r4
  bool v4; // r4
  CEntity *v5; // r4
  void *v6; // r5
  char v7; // r2
  int32 nRef; // [sp+0h] [bp-10h] BYREF
  int pData[3]; // [sp+4h] [bp-Ch] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  switch ( pData[0] )
  {
    case 2:
      v3 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v3;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetVehicle(nRef);
        goto LABEL_18;
      }
      break;
    case 4:
      v4 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v4;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetObject(nRef);
        goto LABEL_18;
      }
      break;
    case 3:
      v1 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v1;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetPed(nRef);
LABEL_18:
        v5 = Vehicle;
        goto LABEL_20;
      }
      break;
  }
  v5 = 0;
LABEL_20:
  v6 = CTask::operator new(0x50u);
  CTaskComplex::CTaskComplex((CTaskComplex *)v6);
  *((_QWORD *)v6 + 3) = 0x400000003F800000LL;
  *((_QWORD *)v6 + 4) = 0x4000000000000000LL;
  *((_QWORD *)v6 + 2) = 0x3E80000C350LL;
  *((_WORD *)v6 + 24) = 0;
  *((_WORD *)v6 + 30) = 0;
  *((_DWORD *)v6 + 10) = 0;
  *((_DWORD *)v6 + 11) = 0;
  *((_DWORD *)v6 + 13) = 0;
  *((_DWORD *)v6 + 14) = 0;
  *((_DWORD *)v6 + 17) = 0;
  *((_DWORD *)v6 + 18) = 6;
  v7 = *((_BYTE *)v6 + 76);
  *(_DWORD *)v6 = &off_6689E0;
  *((_DWORD *)v6 + 16) = &off_66D3E4;
  *((_BYTE *)v6 + 76) = v7 & 0xF0 | 3;
  *((_DWORD *)v6 + 3) = v5;
  if ( v5 )
    CEntity::RegisterReference(v5, (CEntity **)v6 + 3);
  return (CTask *)v6;
}
// 6689E0: using guessed type void *off_6689E0;
// 66D3E4: using guessed type void *off_66D3E4;

//----- (00495560) --------------------------------------------------------
CTask *CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving>::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CEntity *Vehicle; // r0
  bool v3; // r4
  bool v4; // r4
  CEntity *v5; // r4
  void *v6; // r5
  char v7; // r2
  int32 nRef; // [sp+0h] [bp-10h] BYREF
  int pData[3]; // [sp+4h] [bp-Ch] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  switch ( pData[0] )
  {
    case 2:
      v3 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v3;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetVehicle(nRef);
        goto LABEL_18;
      }
      break;
    case 4:
      v4 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v4;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetObject(nRef);
        goto LABEL_18;
      }
      break;
    case 3:
      v1 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v1;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetPed(nRef);
LABEL_18:
        v5 = Vehicle;
        goto LABEL_20;
      }
      break;
  }
  v5 = 0;
LABEL_20:
  v6 = CTask::operator new(0x58u);
  CTaskComplex::CTaskComplex((CTaskComplex *)v6);
  *((_QWORD *)v6 + 3) = 0x400000003F800000LL;
  *((_QWORD *)v6 + 4) = 0x4000000000000000LL;
  *((_QWORD *)v6 + 2) = 0x3E80000C350LL;
  *((_WORD *)v6 + 24) = 0;
  *((_WORD *)v6 + 30) = 0;
  *((_DWORD *)v6 + 10) = 0;
  *((_DWORD *)v6 + 11) = 0;
  *((_DWORD *)v6 + 13) = 0;
  *((_DWORD *)v6 + 14) = 0;
  *((_DWORD *)v6 + 17) = 0;
  *((_DWORD *)v6 + 18) = 0;
  *((_DWORD *)v6 + 19) = 0;
  *((_DWORD *)v6 + 20) = 6;
  v7 = *((_BYTE *)v6 + 84);
  *(_DWORD *)v6 = &off_668A1C;
  *((_DWORD *)v6 + 16) = &off_66D3F0;
  *((_BYTE *)v6 + 84) = v7 & 0xF0 | 3;
  *((_DWORD *)v6 + 3) = v5;
  if ( v5 )
    CEntity::RegisterReference(v5, (CEntity **)v6 + 3);
  return (CTask *)v6;
}
// 668A1C: using guessed type void *off_668A1C;
// 66D3F0: using guessed type void *off_66D3F0;

//----- (00495700) --------------------------------------------------------
CTask *CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos>::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CEntity *Vehicle; // r0
  bool v3; // r4
  bool v4; // r4
  CEntity *v5; // r4
  void *v6; // r5
  char v7; // r2
  int32 nRef; // [sp+0h] [bp-10h] BYREF
  int pData[3]; // [sp+4h] [bp-Ch] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  switch ( pData[0] )
  {
    case 2:
      v3 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v3;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetVehicle(nRef);
        goto LABEL_18;
      }
      break;
    case 4:
      v4 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v4;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetObject(nRef);
        goto LABEL_18;
      }
      break;
    case 3:
      v1 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v1;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetPed(nRef);
LABEL_18:
        v5 = Vehicle;
        goto LABEL_20;
      }
      break;
  }
  v5 = 0;
LABEL_20:
  v6 = CTask::operator new(0x58u);
  CTaskComplex::CTaskComplex((CTaskComplex *)v6);
  *((_QWORD *)v6 + 3) = 0x400000003F800000LL;
  *((_QWORD *)v6 + 4) = 0x4000000000000000LL;
  *((_QWORD *)v6 + 2) = 0x3E80000C350LL;
  *((_WORD *)v6 + 24) = 0;
  *((_WORD *)v6 + 30) = 0;
  *((_DWORD *)v6 + 10) = 0;
  *((_DWORD *)v6 + 11) = 0;
  *((_DWORD *)v6 + 13) = 0;
  *((_DWORD *)v6 + 14) = 0;
  *((_DWORD *)v6 + 17) = 0;
  *((_DWORD *)v6 + 18) = 0;
  *((_DWORD *)v6 + 19) = 0;
  *((_DWORD *)v6 + 20) = 6;
  v7 = *((_BYTE *)v6 + 84);
  *(_DWORD *)v6 = &off_668A58;
  *((_DWORD *)v6 + 16) = &off_66D3FC;
  *((_BYTE *)v6 + 84) = v7 & 0xF0 | 3;
  *((_DWORD *)v6 + 3) = v5;
  if ( v5 )
    CEntity::RegisterReference(v5, (CEntity **)v6 + 3);
  return (CTask *)v6;
}
// 668A58: using guessed type void *off_668A58;
// 66D3FC: using guessed type void *off_66D3FC;

//----- (00495898) --------------------------------------------------------
void CTaskComplexSmartFleeEntity::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CEntity *Vehicle; // r0
  bool v3; // r4
  bool v4; // r4
  CEntity *v5; // r6
  CTaskComplexSmartFleeEntity *v6; // r0
  int32 nRef; // [sp+10h] [bp-18h] BYREF
  int pData[5]; // [sp+14h] [bp-14h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  if ( pData[0] == 2 )
  {
    v3 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
      UseDataFence = v3;
    }
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
    if ( nRef != -1 )
    {
      Vehicle = CPools::GetVehicle(nRef);
      goto LABEL_18;
    }
LABEL_19:
    v5 = 0;
    goto LABEL_20;
  }
  if ( pData[0] == 4 )
  {
    v4 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
      UseDataFence = v4;
    }
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
    if ( nRef != -1 )
    {
      Vehicle = CPools::GetObject(nRef);
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  if ( pData[0] != 3 )
    goto LABEL_19;
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    goto LABEL_19;
  Vehicle = CPools::GetPed(nRef);
LABEL_18:
  v5 = Vehicle;
LABEL_20:
  v6 = (CTaskComplexSmartFleeEntity *)CTask::operator new(0x40u);
  CTaskComplexSmartFleeEntity::CTaskComplexSmartFleeEntity(
    v6,
    v5,
    0,
    60.0,
    (const int)"ist_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly",
    (const int)&elf_hash_bucket[187],
    1.0);
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (004959E0) --------------------------------------------------------
void CTaskComplexAvoidOtherPedWhileWandering::CreateTask()
{
  bool v0; // r4
  CPed *Ped; // r4
  bool v2; // r5
  bool v3; // r5
  CTaskComplexAvoidOtherPedWhileWandering *v4; // r0
  CVector pData; // [sp+4h] [bp-24h] BYREF
  int iMoveState; // [sp+10h] [bp-18h] BYREF
  int32 nRef[5]; // [sp+14h] [bp-14h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(nRef, 4);
  if ( nRef[0] == -1 )
    Ped = 0;
  else
    Ped = CPools::GetPed(nRef[0]);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&iMoveState, 4);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 12);
  v4 = (CTaskComplexAvoidOtherPedWhileWandering *)CTask::operator new(0x60u);
  CTaskComplexAvoidOtherPedWhileWandering::CTaskComplexAvoidOtherPedWhileWandering(v4, Ped, &pData, iMoveState);
}
// 4959E0: using guessed type int32 nRef[5];

//----- (00495AA0) --------------------------------------------------------
void CTaskComplexGoToPointAnyMeans::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  bool v2; // r4
  bool v3; // r4
  CVehicle *Vehicle; // r4
  bool v5; // r5
  CTaskComplexGoToPointAnyMeans *v6; // r0
  int iDesiredCarModel; // [sp+Ch] [bp-2Ch] BYREF
  int32 nRef; // [sp+10h] [bp-28h] BYREF
  float v9; // [sp+14h] [bp-24h] BYREF
  int iMoveState; // [sp+18h] [bp-20h] BYREF
  CVector pData[2]; // [sp+1Ch] [bp-1Ch] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 12);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&iMoveState, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&iMoveState, 4);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v9, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v9, 4);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(nRef);
  v5 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&iDesiredCarModel, 2);
    UseDataFence = v5;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&iDesiredCarModel, 4);
  v6 = (CTaskComplexGoToPointAnyMeans *)CTask::operator new(0x34u);
  if ( Vehicle )
    CTaskComplexGoToPointAnyMeans::CTaskComplexGoToPointAnyMeans(v6, iMoveState, pData, Vehicle, v9, iDesiredCarModel);
  else
    CTaskComplexGoToPointAnyMeans::CTaskComplexGoToPointAnyMeans(v6, iMoveState, pData, v9, iDesiredCarModel);
}

//----- (00495BD8) --------------------------------------------------------
void CTaskComplexTurnToFaceEntityOrCoord::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CEntity *Vehicle; // r0
  bool v3; // r4
  CEntity *v4; // r4
  bool v5; // r5
  bool v6; // r5
  CTaskComplexTurnToFaceEntityOrCoord *v7; // r0
  CVector pData; // [sp+4h] [bp-24h] BYREF
  char v9; // [sp+13h] [bp-15h] BYREF
  int v10[5]; // [sp+14h] [bp-14h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(v10, 4);
  if ( v10[0] == 2 )
  {
    v3 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
      UseDataFence = v3;
    }
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
    if ( LODWORD(pData.x) != -1 )
    {
      Vehicle = CPools::GetVehicle(SLODWORD(pData.x));
      goto LABEL_13;
    }
  }
  else if ( v10[0] == 3 )
  {
    v1 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
      UseDataFence = v1;
    }
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
    if ( LODWORD(pData.x) != -1 )
    {
      Vehicle = CPools::GetPed(SLODWORD(pData.x));
LABEL_13:
      v4 = Vehicle;
      goto LABEL_15;
    }
  }
  v4 = 0;
LABEL_15:
  v5 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v5;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v9, 1);
  v6 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v6;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 12);
  v7 = (CTaskComplexTurnToFaceEntityOrCoord *)CTask::operator new(0x28u);
  if ( v4 )
    CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(v7, v4, 0.5, 0.2);
  else
    CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(v7, &pData, 0.5, 0.2);
}
// 495BD8: using guessed type CVector pData;
// 495BD8: using guessed type int var_14[5];

//----- (00495D34) --------------------------------------------------------
void CTaskComplexGoToPointAiming::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  bool v2; // r4
  CEntity *Vehicle; // r0
  bool v4; // r4
  bool v5; // r4
  CEntity *v6; // r8
  bool v7; // r5
  bool v8; // r5
  CTaskComplexGoToPointAiming *v9; // r0
  CVector v10; // [sp+18h] [bp-38h] BYREF
  CVector pData; // [sp+24h] [bp-2Ch] BYREF
  int v12; // [sp+30h] [bp-20h] BYREF
  int iMoveState[7]; // [sp+34h] [bp-1Ch] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(iMoveState, 4);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v12, 4);
  switch ( v12 )
  {
    case 2:
      v4 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v4;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      if ( LODWORD(pData.x) != -1 )
      {
        Vehicle = CPools::GetVehicle(SLODWORD(pData.x));
        goto LABEL_20;
      }
      break;
    case 4:
      v5 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v5;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      if ( LODWORD(pData.x) != -1 )
      {
        Vehicle = CPools::GetObject(SLODWORD(pData.x));
        goto LABEL_20;
      }
      break;
    case 3:
      v2 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v2;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      if ( LODWORD(pData.x) != -1 )
      {
        Vehicle = CPools::GetPed(SLODWORD(pData.x));
LABEL_20:
        v6 = Vehicle;
        goto LABEL_22;
      }
      break;
  }
  v6 = 0;
LABEL_22:
  v7 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v7;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 12);
  v8 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v10, 2);
    UseDataFence = v8;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v10, 12);
  v9 = (CTaskComplexGoToPointAiming *)CTask::operator new(0x38u);
  CTaskComplexGoToPointAiming::CTaskComplexGoToPointAiming(v9, iMoveState[0], &v10, v6, pData, 0.5, 4.0);
}
// 495D34: using guessed type int iMoveState[7];

//----- (00495F04) --------------------------------------------------------
void CTaskComplexFleeAnyMeans::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CEntity *Vehicle; // r0
  bool v3; // r4
  bool v4; // r4
  CEntity *v5; // r4
  bool v6; // r5
  bool v7; // r5
  bool v8; // r5
  bool v9; // r5
  bool v10; // r5
  bool v11; // r5
  bool v12; // r5
  bool v13; // r5
  CTaskComplexFleeAnyMeans *v14; // r0
  float v15; // [sp+1Ch] [bp-34h] BYREF
  int v16; // [sp+20h] [bp-30h] BYREF
  float v17; // [sp+24h] [bp-2Ch] BYREF
  int v18; // [sp+28h] [bp-28h] BYREF
  int iFleeTime; // [sp+2Ch] [bp-24h] BYREF
  int v20; // [sp+30h] [bp-20h] BYREF
  char v21; // [sp+37h] [bp-19h] BYREF
  int32 nRef; // [sp+38h] [bp-18h] BYREF
  int pData[5]; // [sp+3Ch] [bp-14h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  switch ( pData[0] )
  {
    case 2:
      v3 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v3;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( *(float *)&nRef != NAN )
      {
        Vehicle = CPools::GetVehicle(nRef);
        goto LABEL_18;
      }
      break;
    case 4:
      v4 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v4;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( *(float *)&nRef != NAN )
      {
        Vehicle = CPools::GetObject(nRef);
        goto LABEL_18;
      }
      break;
    case 3:
      v1 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v1;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( *(float *)&nRef != NAN )
      {
        Vehicle = CPools::GetPed(nRef);
LABEL_18:
        v5 = Vehicle;
        goto LABEL_20;
      }
      break;
  }
  v5 = 0;
LABEL_20:
  v6 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
    UseDataFence = v6;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v21, 1);
  v7 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
    UseDataFence = v7;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  v8 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v20, 2);
    UseDataFence = v8;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v20, 4);
  v9 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&iFleeTime, 2);
    UseDataFence = v9;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&iFleeTime, 4);
  v10 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v18, 2);
    UseDataFence = v10;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v18, 4);
  v11 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v17, 2);
    UseDataFence = v11;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v17, 4);
  v12 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v16, 2);
    UseDataFence = v12;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v16, 4);
  v13 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v15, 2);
    UseDataFence = v13;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v15, 4);
  v14 = (CTaskComplexFleeAnyMeans *)CTask::operator new(0x54u);
  CTaskComplexFleeAnyMeans::CTaskComplexFleeAnyMeans(
    v14,
    v5,
    *(float *)&nRef != 0.0,
    (float)v20,
    iFleeTime,
    v18,
    (int)v17,
    (float)v16,
    (int)v15,
    1.0);
}
// 495F04: using guessed type float var_20;

//----- (004961E0) --------------------------------------------------------
void CTaskComplexFollowPatrolRoute::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  bool v2; // r5
  bool v3; // r4
  bool v4; // r4
  CTaskComplexFollowPatrolRoute *v5; // r0
  float v6; // [sp+Ch] [bp-1C4h] BYREF
  float v7; // [sp+10h] [bp-1C0h] BYREF
  __int16 iMode; // [sp+16h] [bp-1BAh] BYREF
  CPatrolRoute iMode_2; // [sp+18h] [bp-1B8h] BYREF
  int iMoveState[4]; // [sp+1BEh] [bp-12h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&iMode_2, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(iMoveState, 2);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&iMode_2, 2);
    UseDataFence = v1;
  }
  iMode_2.m_anims[0].m_animName[0] = 0;
  iMode_2.m_iRouteSize = 0;
  iMode_2.m_anims[1].m_animName[0] = 0;
  iMode_2.m_anims[0].m_animGroupName[0] = 0;
  iMode_2.m_anims[1].m_animGroupName[0] = 0;
  iMode_2.m_anims[2].m_animGroupName[0] = 0;
  iMode_2.m_anims[2].m_animName[0] = 0;
  iMode_2.m_anims[3].m_animGroupName[0] = 0;
  iMode_2.m_anims[3].m_animName[0] = 0;
  iMode_2.m_anims[4].m_animGroupName[0] = 0;
  iMode_2.m_anims[4].m_animName[0] = 0;
  iMode_2.m_anims[5].m_animGroupName[0] = 0;
  iMode_2.m_anims[5].m_animName[0] = 0;
  iMode_2.m_anims[6].m_animGroupName[0] = 0;
  iMode_2.m_anims[6].m_animName[0] = 0;
  iMode_2.m_anims[7].m_animGroupName[0] = 0;
  iMode_2.m_anims[7].m_animName[0] = 0;
  CGenericGameStorage::_LoadDataFromWorkBuffer(&iMode_2, 420);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v7, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&iMode, 2);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v7, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v7, 4);
  v4 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v6, 2);
    UseDataFence = v4;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v6, 4);
  v5 = (CTaskComplexFollowPatrolRoute *)CTask::operator new(0x30u);
  CTaskComplexFollowPatrolRoute::CTaskComplexFollowPatrolRoute(v5, SLOWORD(iMoveState[0]), &iMode_2, iMode, v7, v6);
}
// 4961E0: using guessed type int iMoveState[4];
// 4961E0: using guessed type float var_1C0;

//----- (00496344) --------------------------------------------------------
void CTaskComplexSeekEntityAiming::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CEntity *Vehicle; // r0
  bool v3; // r4
  bool v4; // r4
  CEntity *v5; // r4
  bool v6; // r5
  bool v7; // r5
  CTaskComplexSeekEntityAiming *v8; // r0
  float v9; // [sp+4h] [bp-1Ch] BYREF
  int32 nRef; // [sp+8h] [bp-18h] BYREF
  int pData[5]; // [sp+Ch] [bp-14h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  switch ( pData[0] )
  {
    case 2:
      v3 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v3;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetVehicle(nRef);
        goto LABEL_18;
      }
      break;
    case 4:
      v4 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v4;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetObject(nRef);
        goto LABEL_18;
      }
      break;
    case 3:
      v1 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
        UseDataFence = v1;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
      if ( nRef != -1 )
      {
        Vehicle = CPools::GetPed(nRef);
LABEL_18:
        v5 = Vehicle;
        goto LABEL_20;
      }
      break;
  }
  v5 = 0;
LABEL_20:
  v6 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
    UseDataFence = v6;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  v7 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v9, 2);
    UseDataFence = v7;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v9, 4);
  v8 = (CTaskComplexSeekEntityAiming *)CTask::operator new(0x18u);
  CTaskComplexSeekEntityAiming::CTaskComplexSeekEntityAiming(v8, v5, *(const float *)&nRef, v9);
}
// 496344: using guessed type float var_1C;

//----- (004964B0) --------------------------------------------------------
void CTaskComplexKillPedOnFoot::CreateTask()
{
  bool v0; // r4
  CPed *Ped; // r4
  CTaskComplexKillPedOnFoot *v2; // r0
  int32 nRef; // [sp+10h] [bp-10h] BYREF
  char pData[10]; // [sp+16h] [bp-Ah] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    Ped = 0;
  else
    Ped = CPools::GetPed(nRef);
  v2 = (CTaskComplexKillPedOnFoot *)CTask::operator new(0x38u);
  CTaskComplexKillPedOnFoot::CTaskComplexKillPedOnFoot(v2, Ped, -1, 0, 0, 0, 1);
}
// 4964B0: using guessed type char pData[10];

//----- (00496518) --------------------------------------------------------
void CTaskComplexDestroyCar::CreateTask()
{
  bool v0; // r4
  CVehicle *Vehicle; // r4
  bool v2; // r5
  bool v3; // r5
  bool v4; // r5
  CTaskComplexDestroyCar *v5; // r0
  uint32 nPercentageDuckChance; // [sp+8h] [bp-20h] BYREF
  uint32 v7; // [sp+Ch] [bp-1Ch] BYREF
  uint32 nDuckingConditions; // [sp+10h] [bp-18h] BYREF
  int32 pData[5]; // [sp+14h] [bp-14h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  if ( pData[0] == -1 )
    Vehicle = 0;
  else
    Vehicle = CPools::GetVehicle(pData[0]);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nDuckingConditions, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nDuckingConditions, 4);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v7, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v7, 4);
  v4 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nPercentageDuckChance, 2);
    UseDataFence = v4;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nPercentageDuckChance, 4);
  v5 = (CTaskComplexDestroyCar *)CTask::operator new(0x20u);
  CTaskComplexDestroyCar::CTaskComplexDestroyCar(v5, Vehicle, nDuckingConditions, v7, nPercentageDuckChance);
}

//----- (00496608) --------------------------------------------------------
void CTaskSimpleUseGun::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CEntity *Vehicle; // r0
  bool v3; // r4
  bool v4; // r4
  CEntity *v5; // r8
  bool v6; // r5
  bool v7; // r5
  bool v8; // r5
  bool v9; // r5
  CTaskSimpleUseGun *v10; // r0
  int16 nBurstLength; // [sp+10h] [bp-28h] BYREF
  int8 v12; // [sp+13h] [bp-25h] BYREF
  CVector pData; // [sp+14h] [bp-24h] BYREF
  int v14; // [sp+20h] [bp-18h] BYREF
  bool8 v15[18]; // [sp+26h] [bp-12h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v14, 4);
  switch ( v14 )
  {
    case 2:
      v3 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v3;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      if ( LODWORD(pData.x) != -1 )
      {
        Vehicle = CPools::GetVehicle(SLODWORD(pData.x));
        goto LABEL_18;
      }
      break;
    case 4:
      v4 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v4;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      if ( LODWORD(pData.x) != -1 )
      {
        Vehicle = CPools::GetObject(SLODWORD(pData.x));
        goto LABEL_18;
      }
      break;
    case 3:
      v1 = UseDataFence;
      if ( UseDataFence )
      {
        UseDataFence = 0;
        CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
        UseDataFence = v1;
      }
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
      if ( LODWORD(pData.x) != -1 )
      {
        Vehicle = CPools::GetPed(SLODWORD(pData.x));
LABEL_18:
        v5 = Vehicle;
        goto LABEL_20;
      }
      break;
  }
  v5 = 0;
LABEL_20:
  v6 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v6;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 12);
  v7 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v15, 2);
    UseDataFence = v7;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v12, 1);
  v8 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v15, 2);
    UseDataFence = v8;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nBurstLength, 2);
  v9 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v15, 2);
    UseDataFence = v9;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(v15, 1);
  v10 = (CTaskSimpleUseGun *)CTask::operator new(0x3Cu);
  CTaskSimpleUseGun::CTaskSimpleUseGun(v10, v5, pData, v12, nBurstLength, v15[0]);
}
// 496608: using guessed type int var_18;

//----- (004967F4) --------------------------------------------------------
void CTaskSimpleGunControl::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CEntity *Vehicle; // r0
  bool v3; // r4
  CEntity *v4; // r4
  bool v5; // r5
  bool v6; // r5
  CTaskSimpleGunControl *v7; // r0
  CVector v8; // [sp+Ch] [bp-2Ch] BYREF
  CVector pData; // [sp+18h] [bp-20h] BYREF
  int v10[5]; // [sp+24h] [bp-14h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(v10, 4);
  if ( v10[0] == 2 )
  {
    v3 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
      UseDataFence = v3;
    }
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
    if ( LODWORD(pData.x) != -1 )
    {
      Vehicle = CPools::GetVehicle(SLODWORD(pData.x));
      goto LABEL_13;
    }
  }
  else if ( v10[0] == 3 )
  {
    v1 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
      UseDataFence = v1;
    }
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
    if ( LODWORD(pData.x) != -1 )
    {
      Vehicle = CPools::GetPed(SLODWORD(pData.x));
LABEL_13:
      v4 = Vehicle;
      goto LABEL_15;
    }
  }
  v4 = 0;
LABEL_15:
  v5 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v5;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 12);
  v6 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v8, 2);
    UseDataFence = v6;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v8, 12);
  v7 = (CTaskSimpleGunControl *)CTask::operator new(0x3Cu);
  CTaskSimpleGunControl::CTaskSimpleGunControl(v7, v4, &pData, &v8, 1, 1, -1);
}
// 4967F4: using guessed type int var_14[5];

//----- (00496930) --------------------------------------------------------
void CTaskSimpleGangDriveBy::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  CEntity *Vehicle; // r0
  bool v3; // r4
  CEntity *v4; // r4
  bool v5; // r5
  bool v6; // r5
  bool v7; // r5
  bool v8; // r5
  bool v9; // r5
  CTaskSimpleGangDriveBy *v10; // r0
  int8 v11; // [sp+Eh] [bp-2Ah] BYREF
  int8 v12; // [sp+Fh] [bp-29h] BYREF
  float fAbortRange; // [sp+10h] [bp-28h] BYREF
  CVector pData; // [sp+14h] [bp-24h] BYREF
  int v15; // [sp+20h] [bp-18h] BYREF
  bool v16[18]; // [sp+26h] [bp-12h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v15, 4);
  if ( v15 == 2 )
  {
    v3 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
      UseDataFence = v3;
    }
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
    if ( LODWORD(pData.x) != -1 )
    {
      Vehicle = CPools::GetVehicle(SLODWORD(pData.x));
      goto LABEL_13;
    }
  }
  else if ( v15 == 3 )
  {
    v1 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
      UseDataFence = v1;
    }
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 4);
    if ( LODWORD(pData.x) != -1 )
    {
      Vehicle = CPools::GetPed(SLODWORD(pData.x));
LABEL_13:
      v4 = Vehicle;
      goto LABEL_15;
    }
  }
  v4 = 0;
LABEL_15:
  v5 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v5;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 12);
  v6 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&fAbortRange, 2);
    UseDataFence = v6;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&fAbortRange, 4);
  v7 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v16, 2);
    UseDataFence = v7;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v12, 1);
  v8 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v16, 2);
    UseDataFence = v8;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 1);
  v9 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v16, 2);
    UseDataFence = v9;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(v16, 1);
  v10 = (CTaskSimpleGangDriveBy *)CTask::operator new(0x44u);
  CTaskSimpleGangDriveBy::CTaskSimpleGangDriveBy(v10, v4, &pData, fAbortRange, v12, v11, v16[0]);
}
// 496930: using guessed type int var_18;

//----- (00496B04) --------------------------------------------------------
CTask *CTaskComplexPartnerChat::CreateTask()
{
  bool v0; // r4
  CPed *Ped; // r8
  bool v2; // r5
  bool v3; // r5
  bool v4; // r5
  bool v5; // r5
  bool v6; // r5
  bool v7; // r5
  bool v8; // r5
  CTaskComplexPartnerChat *v9; // r0
  CTask *result; // r0
  CVector v11; // [sp+20h] [bp-50h] BYREF
  bool8 defaultToNonAudio; // [sp+2Dh] [bp-43h] BYREF
  unsigned __int8 v13; // [sp+2Eh] [bp-42h] BYREF
  char v14; // [sp+2Fh] [bp-41h] BYREF
  float v15; // [sp+30h] [bp-40h] BYREF
  bool8 isLeader; // [sp+37h] [bp-39h] BYREF
  int32 nRef; // [sp+38h] [bp-38h] BYREF
  unsigned __int8 pData[32]; // [sp+3Ch] [bp-34h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    Ped = 0;
  else
    Ped = CPools::GetPed(nRef);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 32);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&isLeader, 1);
  v4 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 2);
    UseDataFence = v4;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v15, 4);
  v5 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 2);
    UseDataFence = v5;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v14, 1);
  v6 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 2);
    UseDataFence = v6;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v13, 1);
  v7 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 2);
    UseDataFence = v7;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&defaultToNonAudio, 1);
  v8 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 2);
    UseDataFence = v8;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 12);
  v9 = (CTaskComplexPartnerChat *)CTask::operator new(0x78u);
  CTaskComplexPartnerChat::CTaskComplexPartnerChat(v9, pData, Ped, isLeader, v15, v14, v13, defaultToNonAudio, v11);
  return result;
}

//----- (00496D00) --------------------------------------------------------
CTask *CTaskSimpleTogglePedThreatScanner::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  bool v2; // r4
  CTaskSimple *v3; // r0
  char v4; // r4
  char v5; // r5
  char v6; // r6
  CTask *result; // r0
  char v8; // [sp+7h] [bp-19h] BYREF
  char v9; // [sp+8h] [bp-18h] BYREF
  char v10; // [sp+9h] [bp-17h] BYREF
  char pData[2]; // [sp+Ah] [bp-16h] BYREF
  char v12[2]; // [sp+Ch] [bp-14h] BYREF
  char v13[18]; // [sp+Eh] [bp-12h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v10, 1);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v12, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v9, 1);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(v13, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v8, 1);
  v3 = (CTaskSimple *)CTask::operator new(0xCu);
  v4 = v8;
  v5 = v9;
  v6 = v10;
  CTaskSimple::CTaskSimple(v3);
  LOBYTE(result[1]._vptr$CTask) = v6;
  result->_vptr$CTask = (int (**)(void))&off_66A7AC;
  BYTE1(result[1]._vptr$CTask) = v5;
  BYTE2(result[1]._vptr$CTask) = v4;
  return result;
}
// 496D9C: variable 'result' is possibly undefined
// 66A7AC: using guessed type void *off_66A7AC;
// 496D00: using guessed type char pData[2];
// 496D00: using guessed type char var_14[2];
// 496D00: using guessed type char var_12[18];

//----- (00496DD0) --------------------------------------------------------
void CTaskSimpleJetPack::CreateTask()
{
  bool v0; // r4
  bool v1; // r4
  bool v2; // r4
  bool v3; // r4
  bool v4; // r4
  CEntity *Vehicle; // r0
  bool v6; // r4
  bool v7; // r4
  CEntity *v8; // r4
  CTaskSimpleJetPack *v9; // r0
  int32 nRef; // [sp+4h] [bp-24h] BYREF
  int v11; // [sp+8h] [bp-20h] BYREF
  int32 v12; // [sp+Ch] [bp-1Ch] BYREF
  float v13; // [sp+10h] [bp-18h] BYREF
  CVector pData; // [sp+14h] [bp-14h] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&pData, 12);
  v1 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v13, 2);
    UseDataFence = v1;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v13, 4);
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v12, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v12, 4);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 2);
    UseDataFence = v3;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&v11, 4);
  if ( v11 == 2 )
  {
    v6 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
      UseDataFence = v6;
    }
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
    if ( nRef != -1 )
    {
      Vehicle = CPools::GetVehicle(nRef);
      goto LABEL_24;
    }
LABEL_25:
    v8 = 0;
    goto LABEL_26;
  }
  if ( v11 == 4 )
  {
    v7 = UseDataFence;
    if ( UseDataFence )
    {
      UseDataFence = 0;
      CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
      UseDataFence = v7;
    }
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
    if ( nRef != -1 )
    {
      Vehicle = CPools::GetObject(nRef);
      goto LABEL_24;
    }
    goto LABEL_25;
  }
  if ( v11 != 3 )
    goto LABEL_25;
  v4 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 2);
    UseDataFence = v4;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(&nRef, 4);
  if ( nRef == -1 )
    goto LABEL_25;
  Vehicle = CPools::GetPed(nRef);
LABEL_24:
  v8 = Vehicle;
LABEL_26:
  v9 = (CTaskSimpleJetPack *)CTask::operator new(0x70u);
  CTaskSimpleJetPack::CTaskSimpleJetPack(v9, &pData, v13, v12, v8);
}
// 496DD0: using guessed type CVector pData;
// 496DD0: using guessed type float var_18;

//----- (00496F64) --------------------------------------------------------
void CTaskSimpleSwim::CreateTask()
{
  bool v0; // r4
  CPed *Ped; // r4
  bool v2; // r5
  CTaskSimpleSwim *v3; // r0
  CVector pData[2]; // [sp+4h] [bp-1Ch] BYREF

  v0 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v0;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 4);
  if ( LODWORD(pData[0].x) == -1 )
    Ped = 0;
  else
    Ped = CPools::GetPed(SLODWORD(pData[0].x));
  v2 = UseDataFence;
  if ( UseDataFence )
  {
    UseDataFence = 0;
    CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 2);
    UseDataFence = v2;
  }
  CGenericGameStorage::_LoadDataFromWorkBuffer(pData, 12);
  v3 = (CTaskSimpleSwim *)CTask::operator new(0x68u);
  CTaskSimpleSwim::CTaskSimpleSwim(v3, pData, Ped);
}

//----- (00496FF4) --------------------------------------------------------
void __fastcall CTaskSimpleHailTaxi::~CTaskSimpleHailTaxi(CTaskSimpleHailTaxi *this)
{
  void *v1; // r0

  CTaskSimpleAnim::~CTaskSimpleAnim(this);
  sub_197118(v1);
}
// 497000: variable 'v1' is possibly undefined

//----- (00497004) --------------------------------------------------------
CTask *__fastcall CTaskSimpleHailTaxi::Clone(const CTaskSimpleHailTaxi *this)
{
  CTaskSimpleRunAnim *v1; // r0
  CTask *result; // r0

  v1 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
  CTaskSimpleRunAnim::CTaskSimpleRunAnim(v1, ANIM_STD_PED, ANIM_STD_HAILTAXI, 4.0, 229, "HailTaxi", 0);
  result->_vptr$CTask = (int (**)(void))&off_6685D8;
  return result;
}
// 497032: variable 'result' is possibly undefined
// 6685D8: using guessed type void *;

//----- (00497040) --------------------------------------------------------
void __fastcall CTaskSimpleHailTaxi::Serialize(CTaskSimpleHailTaxi *this)
{
  int v2; // r8
  bool v3; // r5
  __int16 v4; // r2
  __int16 v5; // r10
  _WORD *v6; // r6
  _DWORD *v7; // r6
  int v8; // r0
  unsigned __int8 s[128]; // [sp+4h] [bp-9Ch] BYREF

  v2 = (*((int (__fastcall **)(CTaskSimpleHailTaxi *))this->_vptr$CTask + 5))(this);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    v4 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v5 = v4 + DataFence;
    v6 = malloc(2u);
    *v6 = v5;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 2);
    free(v6);
    UseDataFence = v3;
  }
  v7 = malloc(4u);
  *v7 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
  free(v7);
  if ( (*((int (__fastcall **)(CTaskSimpleHailTaxi *))this->_vptr$CTask + 5))(this) != 229 )
  {
    v8 = (*((int (__fastcall **)(CTaskSimpleHailTaxi *))this->_vptr$CTask + 5))(this);
    sprintf(s, "ERROR - class %d is not type %d serialize is not this class expected", v8, 229);
  }
}
// 497040: using guessed type unsigned __int8 s[128];

//----- (0049711C) --------------------------------------------------------
bool __fastcall CTaskSimpleHailTaxi::IsInterruptable(const CTaskSimpleHailTaxi *this, const CPed *a2)
{
  return 0;
}

//----- (00497120) --------------------------------------------------------
void __fastcall CTaskSimpleHailTaxiAndPause::~CTaskSimpleHailTaxiAndPause(CTaskSimpleHailTaxiAndPause *this)
{
  void *v1; // r0

  CTaskSimpleAnim::~CTaskSimpleAnim(this);
  sub_197118(v1);
}
// 49712C: variable 'v1' is possibly undefined

//----- (00497130) --------------------------------------------------------
CTask *__fastcall CTaskSimpleHailTaxiAndPause::Clone(const CTaskSimpleHailTaxiAndPause *this)
{
  CTaskSimpleRunTimedAnim *v2; // r0
  CTask *result; // r0

  v2 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x34u);
  CTaskSimpleRunTimedAnim::CTaskSimpleRunTimedAnim(
    v2,
    ANIM_STD_PED,
    ANIM_STD_HAILTAXI,
    4.0,
    -4.0,
    this->m_iDuration,
    279,
    "HailTaxiAndPause",
    0);
  result->_vptr$CTask = (int (**)(void))&off_668610;
  return result;
}
// 497170: variable 'result' is possibly undefined
// 668610: using guessed type void *;

//----- (00497180) --------------------------------------------------------
void __fastcall CTaskSimpleHailTaxiAndPause::Serialize(CTaskSimpleHailTaxiAndPause *this)
{
  int v2; // r8
  bool v3; // r5
  __int16 v4; // r2
  __int16 v5; // r10
  _WORD *v6; // r6
  _DWORD *v7; // r6
  bool v8; // r6
  __int16 v9; // r2
  __int16 v10; // r9
  _WORD *v11; // r5
  _DWORD *v12; // r5
  int v13; // r0
  unsigned __int8 s[128]; // [sp+4h] [bp-9Ch] BYREF

  v2 = (*((int (__fastcall **)(CTaskSimpleHailTaxiAndPause *))this->_vptr$CTask + 5))(this);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    v4 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v5 = v4 + DataFence;
    v6 = malloc(2u);
    *v6 = v5;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 2);
    free(v6);
    UseDataFence = v3;
  }
  v7 = malloc(4u);
  *v7 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
  free(v7);
  if ( (*((int (__fastcall **)(CTaskSimpleHailTaxiAndPause *))this->_vptr$CTask + 5))(this) == 279 )
  {
    v8 = UseDataFence;
    if ( UseDataFence )
    {
      v9 = currentSaveFenceCount;
      UseDataFence = 0;
      ++currentSaveFenceCount;
      v10 = v9 + DataFence;
      v11 = malloc(2u);
      *v11 = v10;
      CGenericGameStorage::_SaveDataToWorkBuffer(v11, 2);
      free(v11);
      UseDataFence = v8;
    }
    v12 = malloc(4u);
    *v12 = this->m_iDuration;
    CGenericGameStorage::_SaveDataToWorkBuffer(v12, 4);
    j_free(v12);
  }
  else
  {
    v13 = (*((int (__fastcall **)(CTaskSimpleHailTaxiAndPause *))this->_vptr$CTask + 5))(this);
    sprintf(s, "ERROR - class %d is not type %d serialize is not this class expected", v13, 279);
  }
}
// 497180: using guessed type unsigned __int8 s[128];

//----- (004972FC) --------------------------------------------------------
bool __fastcall CTaskSimpleHailTaxiAndPause::IsInterruptable(const CTaskSimpleHailTaxiAndPause *this, const CPed *a2)
{
  return 0;
}

//----- (00497300) --------------------------------------------------------
void __fastcall CTaskSimpleHitFromBack::~CTaskSimpleHitFromBack(CTaskSimpleHitFromBack *this)
{
  void *v1; // r0

  CTaskSimpleAnim::~CTaskSimpleAnim(this);
  sub_197118(v1);
}
// 49730C: variable 'v1' is possibly undefined

//----- (00497310) --------------------------------------------------------
CTask *__fastcall CTaskSimpleHitFromBack::Clone(const CTaskSimpleHitFromBack *this)
{
  CTaskSimpleRunAnim *v1; // r0
  CTask *result; // r0

  v1 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
  CTaskSimpleRunAnim::CTaskSimpleRunAnim(v1, ANIM_STD_PED, ANIM_STD_HIT_BACK, 4.0, 403, "HitFromBack", 0);
  result->_vptr$CTask = (int (**)(void))&off_668648;
  return result;
}
// 497340: variable 'result' is possibly undefined
// 668648: using guessed type void *;

//----- (00497350) --------------------------------------------------------
void __fastcall CTaskSimpleHitFromBack::Serialize(CTaskSimpleHitFromBack *this)
{
  int v2; // r8
  bool v3; // r5
  __int16 v4; // r2
  __int16 v5; // r10
  _WORD *v6; // r6
  _DWORD *v7; // r6
  int v8; // r0
  unsigned __int8 s[128]; // [sp+4h] [bp-9Ch] BYREF

  v2 = (*((int (__fastcall **)(CTaskSimpleHitFromBack *))this->_vptr$CTask + 5))(this);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    v4 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v5 = v4 + DataFence;
    v6 = malloc(2u);
    *v6 = v5;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 2);
    free(v6);
    UseDataFence = v3;
  }
  v7 = malloc(4u);
  *v7 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
  free(v7);
  if ( (*((int (__fastcall **)(CTaskSimpleHitFromBack *))this->_vptr$CTask + 5))(this) != 403 )
  {
    v8 = (*((int (__fastcall **)(CTaskSimpleHitFromBack *))this->_vptr$CTask + 5))(this);
    sprintf(s, "ERROR - class %d is not type %d serialize is not this class expected", v8, 403);
  }
}
// 497350: using guessed type unsigned __int8 s[128];

//----- (00497434) --------------------------------------------------------
bool __fastcall CTaskSimpleHitFromBack::IsInterruptable(const CTaskSimpleHitFromBack *this, const CPed *a2)
{
  return 0;
}

//----- (00497438) --------------------------------------------------------
void __fastcall CTaskSimpleHitFromFront::~CTaskSimpleHitFromFront(CTaskSimpleHitFromFront *this)
{
  void *v1; // r0

  CTaskSimpleAnim::~CTaskSimpleAnim(this);
  sub_197118(v1);
}
// 497444: variable 'v1' is possibly undefined

//----- (00497448) --------------------------------------------------------
CTask *__fastcall CTaskSimpleHitFromFront::Clone(const CTaskSimpleHitFromFront *this)
{
  CTaskSimpleRunAnim *v1; // r0
  CTask *result; // r0

  v1 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
  CTaskSimpleRunAnim::CTaskSimpleRunAnim(v1, ANIM_STD_PED, ANIM_STD_HIT_FRONT, 4.0, 404, "HitFromFront", 0);
  result->_vptr$CTask = (int (**)(void))&off_668680;
  return result;
}
// 497478: variable 'result' is possibly undefined
// 668680: using guessed type void *;

//----- (00497488) --------------------------------------------------------
void __fastcall CTaskSimpleHitFromFront::Serialize(CTaskSimpleHitFromFront *this)
{
  int v2; // r8
  bool v3; // r5
  __int16 v4; // r2
  __int16 v5; // r10
  _WORD *v6; // r6
  _DWORD *v7; // r6
  int v8; // r0
  unsigned __int8 s[128]; // [sp+4h] [bp-9Ch] BYREF

  v2 = (*((int (__fastcall **)(CTaskSimpleHitFromFront *))this->_vptr$CTask + 5))(this);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    v4 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v5 = v4 + DataFence;
    v6 = malloc(2u);
    *v6 = v5;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 2);
    free(v6);
    UseDataFence = v3;
  }
  v7 = malloc(4u);
  *v7 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
  free(v7);
  if ( (*((int (__fastcall **)(CTaskSimpleHitFromFront *))this->_vptr$CTask + 5))(this) != 404 )
  {
    v8 = (*((int (__fastcall **)(CTaskSimpleHitFromFront *))this->_vptr$CTask + 5))(this);
    sprintf(s, "ERROR - class %d is not type %d serialize is not this class expected", v8, 404);
  }
}
// 497488: using guessed type unsigned __int8 s[128];

//----- (00497568) --------------------------------------------------------
bool __fastcall CTaskSimpleHitFromFront::IsInterruptable(const CTaskSimpleHitFromFront *this, const CPed *a2)
{
  return 0;
}

//----- (0049756C) --------------------------------------------------------
void __fastcall CTaskSimpleHitFromLeft::~CTaskSimpleHitFromLeft(CTaskSimpleHitFromLeft *this)
{
  void *v1; // r0

  CTaskSimpleAnim::~CTaskSimpleAnim(this);
  sub_197118(v1);
}
// 497578: variable 'v1' is possibly undefined

//----- (0049757C) --------------------------------------------------------
CTask *__fastcall CTaskSimpleHitFromLeft::Clone(const CTaskSimpleHitFromLeft *this)
{
  CTaskSimpleRunAnim *v1; // r0
  CTask *result; // r0

  v1 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
  CTaskSimpleRunAnim::CTaskSimpleRunAnim(v1, ANIM_STD_PED, ANIM_STD_HIT_LEFT, 4.0, 405, "HitFromLeft", 0);
  result->_vptr$CTask = (int (**)(void))&off_6686B8;
  return result;
}
// 4975AC: variable 'result' is possibly undefined
// 6686B8: using guessed type void *;

//----- (004975BC) --------------------------------------------------------
void __fastcall CTaskSimpleHitFromLeft::Serialize(CTaskSimpleHitFromLeft *this)
{
  int v2; // r8
  bool v3; // r5
  __int16 v4; // r2
  __int16 v5; // r10
  _WORD *v6; // r6
  _DWORD *v7; // r6
  int v8; // r0
  unsigned __int8 s[128]; // [sp+4h] [bp-9Ch] BYREF

  v2 = (*((int (__fastcall **)(CTaskSimpleHitFromLeft *))this->_vptr$CTask + 5))(this);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    v4 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v5 = v4 + DataFence;
    v6 = malloc(2u);
    *v6 = v5;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 2);
    free(v6);
    UseDataFence = v3;
  }
  v7 = malloc(4u);
  *v7 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
  free(v7);
  if ( (*((int (__fastcall **)(CTaskSimpleHitFromLeft *))this->_vptr$CTask + 5))(this) != 405 )
  {
    v8 = (*((int (__fastcall **)(CTaskSimpleHitFromLeft *))this->_vptr$CTask + 5))(this);
    sprintf(s, "ERROR - class %d is not type %d serialize is not this class expected", v8, 405);
  }
}
// 4975BC: using guessed type unsigned __int8 s[128];

//----- (004976A0) --------------------------------------------------------
bool __fastcall CTaskSimpleHitFromLeft::IsInterruptable(const CTaskSimpleHitFromLeft *this, const CPed *a2)
{
  return 0;
}

//----- (004976A4) --------------------------------------------------------
void __fastcall CTaskSimpleHitFromRight::~CTaskSimpleHitFromRight(CTaskSimpleHitFromRight *this)
{
  void *v1; // r0

  CTaskSimpleAnim::~CTaskSimpleAnim(this);
  sub_197118(v1);
}
// 4976B0: variable 'v1' is possibly undefined

//----- (004976B4) --------------------------------------------------------
CTask *__fastcall CTaskSimpleHitFromRight::Clone(const CTaskSimpleHitFromRight *this)
{
  CTaskSimpleRunAnim *v1; // r0
  CTask *result; // r0

  v1 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
  CTaskSimpleRunAnim::CTaskSimpleRunAnim(v1, ANIM_STD_PED, ANIM_STD_HIT_RIGHT, 4.0, 406, "HitFromRight", 0);
  result->_vptr$CTask = (int (**)(void))&off_6686F0;
  return result;
}
// 4976E4: variable 'result' is possibly undefined
// 6686F0: using guessed type void *;

//----- (004976F4) --------------------------------------------------------
void __fastcall CTaskSimpleHitFromRight::Serialize(CTaskSimpleHitFromRight *this)
{
  int v2; // r8
  bool v3; // r5
  __int16 v4; // r2
  __int16 v5; // r10
  _WORD *v6; // r6
  _DWORD *v7; // r6
  int v8; // r0
  unsigned __int8 s[128]; // [sp+4h] [bp-9Ch] BYREF

  v2 = (*((int (__fastcall **)(CTaskSimpleHitFromRight *))this->_vptr$CTask + 5))(this);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    v4 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v5 = v4 + DataFence;
    v6 = malloc(2u);
    *v6 = v5;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 2);
    free(v6);
    UseDataFence = v3;
  }
  v7 = malloc(4u);
  *v7 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
  free(v7);
  if ( (*((int (__fastcall **)(CTaskSimpleHitFromRight *))this->_vptr$CTask + 5))(this) != 406 )
  {
    v8 = (*((int (__fastcall **)(CTaskSimpleHitFromRight *))this->_vptr$CTask + 5))(this);
    sprintf(s, "ERROR - class %d is not type %d serialize is not this class expected", v8, 406);
  }
}
// 4976F4: using guessed type unsigned __int8 s[128];

//----- (004977D4) --------------------------------------------------------
bool __fastcall CTaskSimpleHitFromRight::IsInterruptable(const CTaskSimpleHitFromRight *this, const CPed *a2)
{
  return 0;
}

//----- (004977D8) --------------------------------------------------------
void __fastcall CTaskSimpleHitByGunFromRear::~CTaskSimpleHitByGunFromRear(CTaskSimpleHitByGunFromRear *this)
{
  void *v1; // r0

  CTaskSimpleAnim::~CTaskSimpleAnim(this);
  sub_197118(v1);
}
// 4977E4: variable 'v1' is possibly undefined

//----- (004977E8) --------------------------------------------------------
CTask *__fastcall CTaskSimpleHitByGunFromRear::Clone(const CTaskSimpleHitByGunFromRear *this)
{
  CTaskSimpleRunAnim *v1; // r0
  CTask *result; // r0

  v1 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
  CTaskSimpleRunAnim::CTaskSimpleRunAnim(v1, ANIM_STD_PED, ANIM_STD_HITBYGUN_BACK, 4.0, 407, "HitByGunFromRear", 0);
  result->_vptr$CTask = (int (**)(void))&off_668728;
  return result;
}
// 497818: variable 'result' is possibly undefined
// 668728: using guessed type void *;

//----- (00497828) --------------------------------------------------------
void __fastcall CTaskSimpleHitByGunFromRear::Serialize(CTaskSimpleHitByGunFromRear *this)
{
  int v2; // r8
  bool v3; // r5
  __int16 v4; // r2
  __int16 v5; // r10
  _WORD *v6; // r6
  _DWORD *v7; // r6
  int v8; // r0
  unsigned __int8 s[128]; // [sp+4h] [bp-9Ch] BYREF

  v2 = (*((int (__fastcall **)(CTaskSimpleHitByGunFromRear *))this->_vptr$CTask + 5))(this);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    v4 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v5 = v4 + DataFence;
    v6 = malloc(2u);
    *v6 = v5;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 2);
    free(v6);
    UseDataFence = v3;
  }
  v7 = malloc(4u);
  *v7 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
  free(v7);
  if ( (*((int (__fastcall **)(CTaskSimpleHitByGunFromRear *))this->_vptr$CTask + 5))(this) != 407 )
  {
    v8 = (*((int (__fastcall **)(CTaskSimpleHitByGunFromRear *))this->_vptr$CTask + 5))(this);
    sprintf(s, "ERROR - class %d is not type %d serialize is not this class expected", v8, 407);
  }
}
// 497828: using guessed type unsigned __int8 s[128];

//----- (0049790C) --------------------------------------------------------
bool __fastcall CTaskSimpleHitByGunFromRear::IsInterruptable(const CTaskSimpleHitByGunFromRear *this, const CPed *a2)
{
  return 0;
}

//----- (00497910) --------------------------------------------------------
void __fastcall CTaskSimpleHitByGunFromFront::~CTaskSimpleHitByGunFromFront(CTaskSimpleHitByGunFromFront *this)
{
  void *v1; // r0

  CTaskSimpleAnim::~CTaskSimpleAnim(this);
  sub_197118(v1);
}
// 49791C: variable 'v1' is possibly undefined

//----- (00497920) --------------------------------------------------------
CTask *__fastcall CTaskSimpleHitByGunFromFront::Clone(const CTaskSimpleHitByGunFromFront *this)
{
  CTaskSimpleRunAnim *v1; // r0
  CTask *result; // r0

  v1 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
  CTaskSimpleRunAnim::CTaskSimpleRunAnim(v1, ANIM_STD_PED, ANIM_STD_HITBYGUN_FRONT, 4.0, 408, "HitByGunFromFront", 0);
  result->_vptr$CTask = (int (**)(void))&off_668760;
  return result;
}
// 497950: variable 'result' is possibly undefined
// 668760: using guessed type void *;

//----- (00497960) --------------------------------------------------------
void __fastcall CTaskSimpleHitByGunFromFront::Serialize(CTaskSimpleHitByGunFromFront *this)
{
  int v2; // r8
  bool v3; // r5
  __int16 v4; // r2
  __int16 v5; // r10
  _WORD *v6; // r6
  _DWORD *v7; // r6
  int v8; // r0
  unsigned __int8 s[128]; // [sp+4h] [bp-9Ch] BYREF

  v2 = (*((int (__fastcall **)(CTaskSimpleHitByGunFromFront *))this->_vptr$CTask + 5))(this);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    v4 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v5 = v4 + DataFence;
    v6 = malloc(2u);
    *v6 = v5;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 2);
    free(v6);
    UseDataFence = v3;
  }
  v7 = malloc(4u);
  *v7 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
  free(v7);
  if ( (*((int (__fastcall **)(CTaskSimpleHitByGunFromFront *))this->_vptr$CTask + 5))(this) != 408 )
  {
    v8 = (*((int (__fastcall **)(CTaskSimpleHitByGunFromFront *))this->_vptr$CTask + 5))(this);
    sprintf(s, "ERROR - class %d is not type %d serialize is not this class expected", v8, 408);
  }
}
// 497960: using guessed type unsigned __int8 s[128];

//----- (00497A40) --------------------------------------------------------
bool __fastcall CTaskSimpleHitByGunFromFront::IsInterruptable(const CTaskSimpleHitByGunFromFront *this, const CPed *a2)
{
  return 0;
}

//----- (00497A44) --------------------------------------------------------
void __fastcall CTaskSimpleHitByGunFromLeft::~CTaskSimpleHitByGunFromLeft(CTaskSimpleHitByGunFromLeft *this)
{
  void *v1; // r0

  CTaskSimpleAnim::~CTaskSimpleAnim(this);
  sub_197118(v1);
}
// 497A50: variable 'v1' is possibly undefined

//----- (00497A54) --------------------------------------------------------
CTask *__fastcall CTaskSimpleHitByGunFromLeft::Clone(const CTaskSimpleHitByGunFromLeft *this)
{
  CTaskSimpleRunAnim *v1; // r0
  CTask *result; // r0

  v1 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
  CTaskSimpleRunAnim::CTaskSimpleRunAnim(v1, ANIM_STD_PED, ANIM_STD_HITBYGUN_LEFT, 4.0, 409, "HitByGunFromLeft", 0);
  result->_vptr$CTask = (int (**)(void))&off_668798;
  return result;
}
// 497A84: variable 'result' is possibly undefined
// 668798: using guessed type void *;

//----- (00497A94) --------------------------------------------------------
void __fastcall CTaskSimpleHitByGunFromLeft::Serialize(CTaskSimpleHitByGunFromLeft *this)
{
  int v2; // r8
  bool v3; // r5
  __int16 v4; // r2
  __int16 v5; // r10
  _WORD *v6; // r6
  _DWORD *v7; // r6
  int v8; // r0
  unsigned __int8 s[128]; // [sp+4h] [bp-9Ch] BYREF

  v2 = (*((int (__fastcall **)(CTaskSimpleHitByGunFromLeft *))this->_vptr$CTask + 5))(this);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    v4 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v5 = v4 + DataFence;
    v6 = malloc(2u);
    *v6 = v5;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 2);
    free(v6);
    UseDataFence = v3;
  }
  v7 = malloc(4u);
  *v7 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
  free(v7);
  if ( (*((int (__fastcall **)(CTaskSimpleHitByGunFromLeft *))this->_vptr$CTask + 5))(this) != 409 )
  {
    v8 = (*((int (__fastcall **)(CTaskSimpleHitByGunFromLeft *))this->_vptr$CTask + 5))(this);
    sprintf(s, "ERROR - class %d is not type %d serialize is not this class expected", v8, 409);
  }
}
// 497A94: using guessed type unsigned __int8 s[128];

//----- (00497B78) --------------------------------------------------------
bool __fastcall CTaskSimpleHitByGunFromLeft::IsInterruptable(const CTaskSimpleHitByGunFromLeft *this, const CPed *a2)
{
  return 0;
}

//----- (00497B7C) --------------------------------------------------------
void __fastcall CTaskSimpleHitByGunFromRight::~CTaskSimpleHitByGunFromRight(CTaskSimpleHitByGunFromRight *this)
{
  void *v1; // r0

  CTaskSimpleAnim::~CTaskSimpleAnim(this);
  sub_197118(v1);
}
// 497B88: variable 'v1' is possibly undefined

//----- (00497B8C) --------------------------------------------------------
CTask *__fastcall CTaskSimpleHitByGunFromRight::Clone(const CTaskSimpleHitByGunFromRight *this)
{
  CTaskSimpleRunAnim *v1; // r0
  CTask *result; // r0

  v1 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
  CTaskSimpleRunAnim::CTaskSimpleRunAnim(v1, ANIM_STD_PED, ANIM_STD_HITBYGUN_RIGHT, 4.0, 410, "HitByGunFromRight", 0);
  result->_vptr$CTask = (int (**)(void))&off_6687D0;
  return result;
}
// 497BBC: variable 'result' is possibly undefined
// 6687D0: using guessed type void *;

//----- (00497BCC) --------------------------------------------------------
void __fastcall CTaskSimpleHitByGunFromRight::Serialize(CTaskSimpleHitByGunFromRight *this)
{
  int v2; // r8
  bool v3; // r5
  __int16 v4; // r2
  __int16 v5; // r10
  _WORD *v6; // r6
  _DWORD *v7; // r6
  int v8; // r0
  unsigned __int8 s[128]; // [sp+4h] [bp-9Ch] BYREF

  v2 = (*((int (__fastcall **)(CTaskSimpleHitByGunFromRight *))this->_vptr$CTask + 5))(this);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    v4 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v5 = v4 + DataFence;
    v6 = malloc(2u);
    *v6 = v5;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 2);
    free(v6);
    UseDataFence = v3;
  }
  v7 = malloc(4u);
  *v7 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
  free(v7);
  if ( (*((int (__fastcall **)(CTaskSimpleHitByGunFromRight *))this->_vptr$CTask + 5))(this) != 410 )
  {
    v8 = (*((int (__fastcall **)(CTaskSimpleHitByGunFromRight *))this->_vptr$CTask + 5))(this);
    sprintf(s, "ERROR - class %d is not type %d serialize is not this class expected", v8, 410);
  }
}
// 497BCC: using guessed type unsigned __int8 s[128];

//----- (00497CAC) --------------------------------------------------------
bool __fastcall CTaskSimpleHitByGunFromRight::IsInterruptable(const CTaskSimpleHitByGunFromRight *this, const CPed *a2)
{
  return 0;
}

//----- (00497CB0) --------------------------------------------------------
void __fastcall CTaskSimpleHitWall::~CTaskSimpleHitWall(CTaskSimpleHitWall *this)
{
  void *v1; // r0

  CTaskSimpleAnim::~CTaskSimpleAnim(this);
  sub_197118(v1);
}
// 497CBC: variable 'v1' is possibly undefined

//----- (00497CC0) --------------------------------------------------------
CTask *__fastcall CTaskSimpleHitWall::Clone(const CTaskSimpleHitWall *this)
{
  CTaskSimpleRunAnim *v1; // r0
  CTask *result; // r0

  v1 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
  CTaskSimpleRunAnim::CTaskSimpleRunAnim(v1, ANIM_STD_PED, ANIM_STD_HIT_WALL, 4.0, 411, "HitWall", 0);
  result->_vptr$CTask = (int (**)(void))&off_668808;
  return result;
}
// 497CF0: variable 'result' is possibly undefined
// 668808: using guessed type void *;

//----- (00497D00) --------------------------------------------------------
void __fastcall CTaskSimpleHitWall::Serialize(CTaskSimpleHitWall *this)
{
  int v2; // r8
  bool v3; // r5
  __int16 v4; // r2
  __int16 v5; // r10
  _WORD *v6; // r6
  _DWORD *v7; // r6
  int v8; // r0
  unsigned __int8 s[128]; // [sp+4h] [bp-9Ch] BYREF

  v2 = (*((int (__fastcall **)(CTaskSimpleHitWall *))this->_vptr$CTask + 5))(this);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    v4 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v5 = v4 + DataFence;
    v6 = malloc(2u);
    *v6 = v5;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 2);
    free(v6);
    UseDataFence = v3;
  }
  v7 = malloc(4u);
  *v7 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
  free(v7);
  if ( (*((int (__fastcall **)(CTaskSimpleHitWall *))this->_vptr$CTask + 5))(this) != 411 )
  {
    v8 = (*((int (__fastcall **)(CTaskSimpleHitWall *))this->_vptr$CTask + 5))(this);
    sprintf(s, "ERROR - class %d is not type %d serialize is not this class expected", v8, 411);
  }
}
// 497D00: using guessed type unsigned __int8 s[128];

//----- (00497DE4) --------------------------------------------------------
bool __fastcall CTaskSimpleHitWall::IsInterruptable(const CTaskSimpleHitWall *this, const CPed *a2)
{
  return 0;
}

//----- (00497DE8) --------------------------------------------------------
void __fastcall CTaskSimpleHitFromBehind::~CTaskSimpleHitFromBehind(CTaskSimpleHitFromBehind *this)
{
  void *v1; // r0

  CTaskSimpleAnim::~CTaskSimpleAnim(this);
  sub_197118(v1);
}
// 497DF4: variable 'v1' is possibly undefined

//----- (00497DF8) --------------------------------------------------------
CTask *__fastcall CTaskSimpleHitFromBehind::Clone(const CTaskSimpleHitFromBehind *this)
{
  CTaskSimpleRunAnim *v1; // r0
  CTask *result; // r0

  v1 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
  CTaskSimpleRunAnim::CTaskSimpleRunAnim(v1, ANIM_STD_PED, ANIM_STD_HIT_BEHIND, 4.0, 414, "HitFromBehind", 0);
  result->_vptr$CTask = (int (**)(void))&off_668840;
  return result;
}
// 497E28: variable 'result' is possibly undefined
// 668840: using guessed type void *;

//----- (00497E38) --------------------------------------------------------
void __fastcall CTaskSimpleHitFromBehind::Serialize(CTaskSimpleHitFromBehind *this)
{
  int v2; // r8
  bool v3; // r5
  __int16 v4; // r2
  __int16 v5; // r10
  _WORD *v6; // r6
  _DWORD *v7; // r6
  int v8; // r0
  unsigned __int8 s[128]; // [sp+4h] [bp-9Ch] BYREF

  v2 = (*((int (__fastcall **)(CTaskSimpleHitFromBehind *))this->_vptr$CTask + 5))(this);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    v4 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v5 = v4 + DataFence;
    v6 = malloc(2u);
    *v6 = v5;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 2);
    free(v6);
    UseDataFence = v3;
  }
  v7 = malloc(4u);
  *v7 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
  free(v7);
  if ( (*((int (__fastcall **)(CTaskSimpleHitFromBehind *))this->_vptr$CTask + 5))(this) != 414 )
  {
    v8 = (*((int (__fastcall **)(CTaskSimpleHitFromBehind *))this->_vptr$CTask + 5))(this);
    sprintf(s, "ERROR - class %d is not type %d serialize is not this class expected", v8, 414);
  }
}
// 497E38: using guessed type unsigned __int8 s[128];

//----- (00497F18) --------------------------------------------------------
bool __fastcall CTaskSimpleHitFromBehind::IsInterruptable(const CTaskSimpleHitFromBehind *this, const CPed *a2)
{
  return 0;
}

//----- (00497F1C) --------------------------------------------------------
void __fastcall CTaskSimpleChat::~CTaskSimpleChat(CTaskSimpleChat *this)
{
  void *v1; // r0

  CTaskSimpleAnim::~CTaskSimpleAnim(this);
  sub_197118(v1);
}
// 497F28: variable 'v1' is possibly undefined

//----- (00497F2C) --------------------------------------------------------
CTask *__fastcall CTaskSimpleChat::Clone(const CTaskSimpleChat *this)
{
  CTaskSimpleRunTimedAnim *v2; // r0
  CTask *result; // r0

  v2 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x34u);
  CTaskSimpleRunTimedAnim::CTaskSimpleRunTimedAnim(
    v2,
    ANIM_STD_PED,
    ANIM_STD_CHAT,
    4.0,
    -4.0,
    this->m_iDuration,
    416,
    "Chat",
    0);
  result->_vptr$CTask = (int (**)(void))&off_668878;
  return result;
}
// 497F6C: variable 'result' is possibly undefined
// 668878: using guessed type void *;

//----- (00497F7C) --------------------------------------------------------
void __fastcall CTaskSimpleChat::Serialize(CTaskSimpleChat *this)
{
  int v2; // r8
  bool v3; // r5
  __int16 v4; // r2
  __int16 v5; // r10
  _WORD *v6; // r6
  _DWORD *v7; // r6
  bool v8; // r6
  __int16 v9; // r2
  __int16 v10; // r9
  _WORD *v11; // r5
  _DWORD *v12; // r5
  int v13; // r0
  unsigned __int8 s[128]; // [sp+4h] [bp-9Ch] BYREF

  v2 = (*((int (__fastcall **)(CTaskSimpleChat *))this->_vptr$CTask + 5))(this);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    v4 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v5 = v4 + DataFence;
    v6 = malloc(2u);
    *v6 = v5;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 2);
    free(v6);
    UseDataFence = v3;
  }
  v7 = malloc(4u);
  *v7 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
  free(v7);
  if ( (*((int (__fastcall **)(CTaskSimpleChat *))this->_vptr$CTask + 5))(this) == 416 )
  {
    v8 = UseDataFence;
    if ( UseDataFence )
    {
      v9 = currentSaveFenceCount;
      UseDataFence = 0;
      ++currentSaveFenceCount;
      v10 = v9 + DataFence;
      v11 = malloc(2u);
      *v11 = v10;
      CGenericGameStorage::_SaveDataToWorkBuffer(v11, 2);
      free(v11);
      UseDataFence = v8;
    }
    v12 = malloc(4u);
    *v12 = this->m_iDuration;
    CGenericGameStorage::_SaveDataToWorkBuffer(v12, 4);
    j_free(v12);
  }
  else
  {
    v13 = (*((int (__fastcall **)(CTaskSimpleChat *))this->_vptr$CTask + 5))(this);
    sprintf(s, "ERROR - class %d is not type %d serialize is not this class expected", v13, 416);
  }
}
// 497F7C: using guessed type unsigned __int8 s[128];

//----- (004980F4) --------------------------------------------------------
bool __fastcall CTaskSimpleChat::IsInterruptable(const CTaskSimpleChat *this, const CPed *a2)
{
  return 0;
}

//----- (004980F8) --------------------------------------------------------
void __fastcall CTaskSimpleDetonate::~CTaskSimpleDetonate(CTaskSimpleDetonate *this)
{
  void *v1; // r0

  CTaskSimpleAnim::~CTaskSimpleAnim(this);
  sub_197118(v1);
}
// 498104: variable 'v1' is possibly undefined

//----- (00498108) --------------------------------------------------------
CTask *__fastcall CTaskSimpleDetonate::Clone(const CTaskSimpleDetonate *this)
{
  CTaskSimpleRunTimedAnim *v2; // r0
  CTask *result; // r0

  v2 = (CTaskSimpleRunTimedAnim *)CTask::operator new(0x34u);
  CTaskSimpleRunTimedAnim::CTaskSimpleRunTimedAnim(
    v2,
    ANIM_STD_PED,
    ANIM_STD_DETONATE,
    4.0,
    -4.0,
    this->m_iDuration,
    419,
    "Detonate",
    0);
  result->_vptr$CTask = (int (**)(void))&off_6688B0;
  return result;
}
// 498148: variable 'result' is possibly undefined
// 6688B0: using guessed type void *;

//----- (00498158) --------------------------------------------------------
void __fastcall CTaskSimpleDetonate::Serialize(CTaskSimpleDetonate *this)
{
  int v2; // r8
  bool v3; // r5
  __int16 v4; // r2
  __int16 v5; // r10
  _WORD *v6; // r6
  _DWORD *v7; // r6
  bool v8; // r6
  __int16 v9; // r2
  __int16 v10; // r9
  _WORD *v11; // r5
  _DWORD *v12; // r5
  int v13; // r0
  unsigned __int8 s[128]; // [sp+4h] [bp-9Ch] BYREF

  v2 = (*((int (__fastcall **)(CTaskSimpleDetonate *))this->_vptr$CTask + 5))(this);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    v4 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v5 = v4 + DataFence;
    v6 = malloc(2u);
    *v6 = v5;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 2);
    free(v6);
    UseDataFence = v3;
  }
  v7 = malloc(4u);
  *v7 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
  free(v7);
  if ( (*((int (__fastcall **)(CTaskSimpleDetonate *))this->_vptr$CTask + 5))(this) == 419 )
  {
    v8 = UseDataFence;
    if ( UseDataFence )
    {
      v9 = currentSaveFenceCount;
      UseDataFence = 0;
      ++currentSaveFenceCount;
      v10 = v9 + DataFence;
      v11 = malloc(2u);
      *v11 = v10;
      CGenericGameStorage::_SaveDataToWorkBuffer(v11, 2);
      free(v11);
      UseDataFence = v8;
    }
    v12 = malloc(4u);
    *v12 = this->m_iDuration;
    CGenericGameStorage::_SaveDataToWorkBuffer(v12, 4);
    j_free(v12);
  }
  else
  {
    v13 = (*((int (__fastcall **)(CTaskSimpleDetonate *))this->_vptr$CTask + 5))(this);
    sprintf(s, "ERROR - class %d is not type %d serialize is not this class expected", v13, 419);
  }
}
// 498158: using guessed type unsigned __int8 s[128];

//----- (004982D4) --------------------------------------------------------
bool __fastcall CTaskSimpleDetonate::IsInterruptable(const CTaskSimpleDetonate *this, const CPed *a2)
{
  return 0;
}

//----- (004982D8) --------------------------------------------------------
void __fastcall CTaskSimpleAbseil::~CTaskSimpleAbseil(CTaskSimpleAbseil *this)
{
  void *v1; // r0

  CTaskSimpleAnim::~CTaskSimpleAnim(this);
  sub_197118(v1);
}
// 4982E4: variable 'v1' is possibly undefined

//----- (004982E8) --------------------------------------------------------
CTask *__fastcall CTaskSimpleAbseil::Clone(const CTaskSimpleAbseil *this)
{
  CTaskSimpleRunAnim *v1; // r0
  CTask *result; // r0

  v1 = (CTaskSimpleRunAnim *)CTask::operator new(0x20u);
  CTaskSimpleRunAnim::CTaskSimpleRunAnim(v1, ANIM_STD_PED, ANIM_STD_ABSEIL, 4.0, 423, "Abseil", 0);
  result->_vptr$CTask = (int (**)(void))&off_6688E8;
  return result;
}
// 498318: variable 'result' is possibly undefined
// 6688E8: using guessed type void *;

//----- (00498328) --------------------------------------------------------
void __fastcall CTaskSimpleAbseil::Serialize(CTaskSimpleAbseil *this)
{
  int v2; // r8
  bool v3; // r5
  __int16 v4; // r2
  __int16 v5; // r10
  _WORD *v6; // r6
  _DWORD *v7; // r6
  int v8; // r0
  unsigned __int8 s[128]; // [sp+4h] [bp-9Ch] BYREF

  v2 = (*((int (__fastcall **)(CTaskSimpleAbseil *))this->_vptr$CTask + 5))(this);
  v3 = UseDataFence;
  if ( UseDataFence )
  {
    v4 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v5 = v4 + DataFence;
    v6 = malloc(2u);
    *v6 = v5;
    CGenericGameStorage::_SaveDataToWorkBuffer(v6, 2);
    free(v6);
    UseDataFence = v3;
  }
  v7 = malloc(4u);
  *v7 = v2;
  CGenericGameStorage::_SaveDataToWorkBuffer(v7, 4);
  free(v7);
  if ( (*((int (__fastcall **)(CTaskSimpleAbseil *))this->_vptr$CTask + 5))(this) != 423 )
  {
    v8 = (*((int (__fastcall **)(CTaskSimpleAbseil *))this->_vptr$CTask + 5))(this);
    sprintf(s, "ERROR - class %d is not type %d serialize is not this class expected", v8, 423);
  }
}
// 498328: using guessed type unsigned __int8 s[128];

//----- (0049840C) --------------------------------------------------------
bool __fastcall CTaskSimpleAbseil::IsInterruptable(const CTaskSimpleAbseil *this, const CPed *a2)
{
  return 0;
}

//----- (00498410) --------------------------------------------------------
void __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculator>::~CTaskComplexSeekEntity(
        CTaskComplexSeekEntity<CEntitySeekPosCalculator> *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CTask = (int (**)(void))&off_668920;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  sub_18EDB4(this);
}
// 668920: using guessed type void *;

//----- (0049843C) --------------------------------------------------------
void __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculator>::~CTaskComplexSeekEntity(
        CTaskComplexSeekEntity<CEntitySeekPosCalculator> *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1
  void *v4; // r0

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CTask = (int (**)(void))&off_668920;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 498464: variable 'v4' is possibly undefined
// 668920: using guessed type void *off_668920;

//----- (0049846C) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculator>::Clone(
        const CTaskComplexSeekEntity<CEntitySeekPosCalculator> *this)
{
  void *v2; // r5
  __int64 v3; // d8
  __int64 v4; // d9
  CEntity *m_pEntity; // r6
  float m_fFollowNodeThresholdHeightChange; // r8
  char v7; // r9
  char v8; // r3
  char v9; // r0

  v2 = CTask::operator new(0x4Cu);
  v3 = *(_QWORD *)&this->m_iMaxSeekTime;
  v4 = *(_QWORD *)&this->m_fTargetRadius;
  m_pEntity = this->m_pEntity;
  m_fFollowNodeThresholdHeightChange = this->m_fFollowNodeThresholdHeightChange;
  v7 = *((_BYTE *)this + 72);
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_QWORD *)v2 + 2) = v3;
  *((_QWORD *)v2 + 3) = v4;
  *((_DWORD *)v2 + 8) = 0;
  *((float *)v2 + 9) = m_fFollowNodeThresholdHeightChange;
  *((_WORD *)v2 + 24) = 0;
  *((_WORD *)v2 + 30) = 0;
  *((_DWORD *)v2 + 10) = 0;
  *((_DWORD *)v2 + 11) = 0;
  *((_DWORD *)v2 + 13) = 0;
  *((_DWORD *)v2 + 14) = 0;
  v8 = *((_BYTE *)v2 + 72);
  *(_DWORD *)v2 = &off_668920;
  *((_DWORD *)v2 + 16) = &off_66895C;
  *((_DWORD *)v2 + 17) = 6;
  v9 = v7 & 1 | v8 & 0xF0 | 2;
  *((_BYTE *)v2 + 72) = v9;
  *((_DWORD *)v2 + 3) = m_pEntity;
  if ( m_pEntity )
  {
    CEntity::RegisterReference(m_pEntity, (CEntity **)v2 + 3);
    v9 = *((_BYTE *)v2 + 72);
  }
  *((_DWORD *)v2 + 17) = this->m_iMoveState;
  *((_BYTE *)v2 + 72) = v9 & 0xF7 | *((_BYTE *)this + 72) & 8;
  *((_DWORD *)v2 + 8) = LODWORD(this->m_fGoToPointDistance);
  *((_DWORD *)v2 + 17) = this->m_iMoveState;
  return (CTask *)v2;
}
// 668920: using guessed type void *off_668920;
// 66895C: using guessed type void *;

//----- (00498534) --------------------------------------------------------
int __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculator>::GetTaskType(
        const CTaskComplexSeekEntity<CEntitySeekPosCalculator> *this)
{
  return 907;
}

//----- (0049853C) --------------------------------------------------------
bool __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculator>::MakeAbortable(
        CTaskComplexSeekEntity<CEntitySeekPosCalculator> *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  int v5; // lr
  int v6; // r0
  int v7; // r1

  if ( !iPriority )
  {
    this->m_iMaxSeekTime = -1;
    v5 = CTimer::m_snTimeInMilliseconds;
    this->m_seekTimer.m_bIsActive = 1;
    this->m_seekTimer.m_iStartTime = v5;
    this->m_seekTimer.m_iDuration = -1;
  }
  v6 = (*((int (__fastcall **)(CTask *, CPed *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
         this->m_pSubTask,
         pPed);
  if ( v6 == 1 )
  {
    v7 = CTimer::m_snTimeInMilliseconds;
    this->m_scanTimer.m_bIsActive = 1;
    this->m_scanTimer.m_iStartTime = v7;
    this->m_scanTimer.m_iDuration = 0;
  }
  return v6;
}

//----- (0049858C) --------------------------------------------------------
void __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculator>::Serialize(
        CTaskComplexSeekEntity<CEntitySeekPosCalculator> *this)
{
  bool v2; // r6
  __int16 v3; // r2
  __int16 v4; // r4
  _WORD *v5; // r5
  _DWORD *v6; // r5
  int v7; // r8
  bool v8; // r5
  __int16 v9; // r2
  __int16 v10; // r4
  _WORD *v11; // r6
  _DWORD *v12; // r6
  CEntity *m_pEntity; // r0
  int v14; // r8
  bool v15; // r6
  __int16 v16; // r2
  __int16 v17; // r4
  _WORD *v18; // r5
  _DWORD *v19; // r5
  CEntity *v20; // r0
  int v21; // r1
  int32 VehicleRef; // r8
  int v23; // r0
  bool v24; // r5
  __int16 v25; // r2
  __int16 v26; // r6
  _WORD *v27; // r4
  _DWORD *v28; // r4
  bool v29; // r6
  __int16 v30; // r2
  __int16 v31; // r4
  _WORD *v32; // r5
  bool v33; // r6
  __int16 v34; // r2
  __int16 v35; // r4
  _WORD *v36; // r5
  bool v37; // r6
  __int16 v38; // r2
  __int16 v39; // r4
  _WORD *v40; // r5
  _DWORD *v41; // r5
  unsigned __int8 s[128]; // [sp+4h] [bp-9Ch] BYREF

  v2 = UseDataFence;
  if ( UseDataFence )
  {
    v3 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v4 = v3 + DataFence;
    v5 = malloc(2u);
    *v5 = v4;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 2);
    free(v5);
    UseDataFence = v2;
  }
  v6 = malloc(4u);
  *v6 = 0;
  CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
  free(v6);
  v7 = (*((int (__fastcall **)(CTaskComplexSeekEntity<CEntitySeekPosCalculator> *))this->_vptr$CTask + 5))(this);
  v8 = UseDataFence;
  if ( UseDataFence )
  {
    v9 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v10 = v9 + DataFence;
    v11 = malloc(2u);
    *v11 = v10;
    CGenericGameStorage::_SaveDataToWorkBuffer(v11, 2);
    free(v11);
    UseDataFence = v8;
  }
  v12 = malloc(4u);
  *v12 = v7;
  CGenericGameStorage::_SaveDataToWorkBuffer(v12, 4);
  free(v12);
  if ( (*((int (__fastcall **)(CTaskComplexSeekEntity<CEntitySeekPosCalculator> *))this->_vptr$CTask + 5))(this) == 907 )
  {
    m_pEntity = this->m_pEntity;
    if ( m_pEntity )
    {
      v14 = *(_BYTE *)&m_pEntity->m_info & 7;
      v15 = UseDataFence;
      if ( UseDataFence )
      {
        v16 = currentSaveFenceCount;
        UseDataFence = 0;
        ++currentSaveFenceCount;
        v17 = v16 + DataFence;
        v18 = malloc(2u);
        *v18 = v17;
        CGenericGameStorage::_SaveDataToWorkBuffer(v18, 2);
        free(v18);
        UseDataFence = v15;
      }
      v19 = malloc(4u);
      *v19 = v14;
      CGenericGameStorage::_SaveDataToWorkBuffer(v19, 4);
      free(v19);
      v20 = this->m_pEntity;
      v21 = *(_BYTE *)&v20->m_info & 7;
      switch ( v21 )
      {
        case 2:
          if ( v20 )
            VehicleRef = CPools::GetVehicleRef((CVehicle *)v20);
          else
            VehicleRef = -1;
          v29 = UseDataFence;
          if ( UseDataFence )
          {
            v30 = currentSaveFenceCount;
            UseDataFence = 0;
            ++currentSaveFenceCount;
            v31 = v30 + DataFence;
            v32 = malloc(2u);
            *v32 = v31;
            CGenericGameStorage::_SaveDataToWorkBuffer(v32, 2);
            free(v32);
            UseDataFence = v29;
          }
          goto LABEL_34;
        case 4:
          if ( v20 )
            VehicleRef = CPools::GetObjectRef((CObject *)v20);
          else
            VehicleRef = -1;
          v33 = UseDataFence;
          if ( UseDataFence )
          {
            v34 = currentSaveFenceCount;
            UseDataFence = 0;
            ++currentSaveFenceCount;
            v35 = v34 + DataFence;
            v36 = malloc(2u);
            *v36 = v35;
            CGenericGameStorage::_SaveDataToWorkBuffer(v36, 2);
            free(v36);
            UseDataFence = v33;
          }
          goto LABEL_34;
        case 3:
          if ( v20 )
            VehicleRef = CPools::GetPedRef((CPed *)v20);
          else
            VehicleRef = -1;
          v37 = UseDataFence;
          if ( UseDataFence )
          {
            v38 = currentSaveFenceCount;
            UseDataFence = 0;
            ++currentSaveFenceCount;
            v39 = v38 + DataFence;
            v40 = malloc(2u);
            *v40 = v39;
            CGenericGameStorage::_SaveDataToWorkBuffer(v40, 2);
            free(v40);
            UseDataFence = v37;
          }
LABEL_34:
          v41 = malloc(4u);
          *v41 = VehicleRef;
          CGenericGameStorage::_SaveDataToWorkBuffer(v41, 4);
          j_free(v41);
          break;
      }
    }
    else
    {
      v24 = UseDataFence;
      if ( UseDataFence )
      {
        v25 = currentSaveFenceCount;
        UseDataFence = 0;
        ++currentSaveFenceCount;
        v26 = v25 + DataFence;
        v27 = malloc(2u);
        *v27 = v26;
        CGenericGameStorage::_SaveDataToWorkBuffer(v27, 2);
        free(v27);
        UseDataFence = v24;
      }
      v28 = malloc(4u);
      *v28 = 0;
      CGenericGameStorage::_SaveDataToWorkBuffer(v28, 4);
      j_free(v28);
    }
  }
  else
  {
    v23 = (*((int (__fastcall **)(CTaskComplexSeekEntity<CEntitySeekPosCalculator> *))this->_vptr$CTask + 5))(this);
    sprintf(s, "ERROR - class %d is not type %d serialize is not this class expected", v23, 907);
  }
}
// 49858C: using guessed type unsigned __int8 s[128];

//----- (004989A0) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculator>::CreateNextSubTask(
        CTaskComplexSeekEntity<CEntitySeekPosCalculator> *this,
        CPed *pPed)
{
  int v4; // r0
  CTaskSimpleStandStill *v5; // r6
  CTaskSimpleCarDrive *v6; // r0
  int v7; // r0
  bool v9; // zf
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float32x2_t v12; // d16
  unsigned __int64 v13; // d0
  float v14; // s0
  float m_fGoToPointDistance; // s2
  int v16; // r1
  CTaskSimpleStandStill *v17; // r0
  char v18; // r0
  CTaskSimpleStandStill v19; // [sp+8h] [bp-30h] BYREF

  if ( !this->m_pEntity )
    return 0;
  v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
  v5 = 0;
  if ( v4 <= 718 )
  {
    if ( v4 != 203 )
    {
      if ( v4 == 219 )
      {
        v5 = 0;
        CTaskSimpleStandStill::CTaskSimpleStandStill(&v19, -1, 0, 0, 8.0);
        CTaskSimpleStandStill::ProcessPed(v17, pPed);
        CTaskSimpleStandStill::~CTaskSimpleStandStill(&v19);
      }
      else if ( v4 == 704 )
      {
        v5 = 0;
        if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
        {
          v6 = (CTaskSimpleCarDrive *)CTask::operator new(0x70u);
          CTaskSimpleCarDrive::CTaskSimpleCarDrive(v6, pPed->m_pMyVehicle, 0, 0);
          *(_DWORD *)(v7 + 96) = 2000;
          *(_WORD *)(v7 + 108) = 0;
          *(_DWORD *)(v7 + 100) = 0;
          *(_DWORD *)(v7 + 104) = 0;
          v5 = (CTaskSimpleStandStill *)v7;
          *(_DWORD *)v7 = &off_66571C;
        }
      }
      return v5;
    }
    if ( pPed->m_pAttachToEntity )
    {
      v5 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(v5, 2000, 0, 0, 8.0);
      return v5;
    }
    return (CTask *)(*((int (__fastcall **)(CTaskComplexSeekEntity<CEntitySeekPosCalculator> *, CPed *))this->_vptr$CTask
                     + 11))(
                      this,
                      pPed);
  }
  if ( v4 == 719 )
    return (CTask *)(*((int (__fastcall **)(CTaskComplexSeekEntity<CEntitySeekPosCalculator> *, CPed *))this->_vptr$CTask
                     + 11))(
                      this,
                      pPed);
  v9 = v4 == 903;
  if ( v4 != 903 )
    v9 = v4 == 906;
  if ( !v9 )
    return v5;
  m_pMat = pPed->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pPed->m_transform;
  v12.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.x, *(float32x2_t *)&p_tx->m_translate.x).n64_u64[0];
  v13 = vmul_f32(v12, v12).n64_u64[0];
  v14 = (float)(*(float *)&v13 + *((float *)&v13 + 1)) + 0.0;
  if ( v14 <= (float)(this->m_fTargetRadius * this->m_fTargetRadius) )
  {
    v18 = *((_BYTE *)this + 72);
    *((_BYTE *)this + 72) = v18 | 4;
    v16 = 920;
    if ( (v18 & 2) == 0 )
      v16 = 1302;
  }
  else
  {
    m_fGoToPointDistance = this->m_fGoToPointDistance;
    if ( m_fGoToPointDistance == 0.0 )
    {
      v16 = 906;
    }
    else if ( v14 <= (float)(m_fGoToPointDistance * m_fGoToPointDistance) )
    {
      v16 = 903;
    }
    else
    {
      v16 = 906;
    }
  }
  return sub_19D23C(this, v16, pPed);
}
// 4989F4: variable 'v7' is possibly undefined
// 498ADE: variable 'v17' is possibly undefined
// 66571C: using guessed type void *off_66571C;

//----- (00498B24) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculator>::CreateFirstSubTask(
        CTaskComplexSeekEntity<CEntitySeekPosCalculator> *this,
        CPed *pPed)
{
  __int64 v4; // kr00_8
  int v5; // r1
  bool v6; // zf
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float32x2_t v9; // d16
  unsigned __int64 v10; // d0
  float v11; // s0
  int v12; // r1
  CTaskSimpleTired *v13; // r0
  float m_fGoToPointDistance; // s2
  CTaskComplexLeaveCar *v15; // r0
  CTask *result; // r0

  v4 = *(_QWORD *)&this->m_iMaxSeekTime;
  v5 = CTimer::m_snTimeInMilliseconds;
  this->m_scanTimer.m_bIsActive = 1;
  this->m_scanTimer.m_iStartTime = v5;
  this->m_scanTimer.m_iDuration = HIDWORD(v4);
  if ( (_DWORD)v4 != -1 )
  {
    this->m_seekTimer.m_bIsActive = 1;
    this->m_seekTimer.m_iStartTime = v5;
    this->m_seekTimer.m_iDuration = v4;
  }
  if ( this->m_pEntity )
  {
    v6 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
    if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
      v6 = pPed->m_pMyVehicle == 0;
    if ( v6 )
    {
      m_pMat = pPed->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      v9.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.x, *(float32x2_t *)&p_tx->m_translate.x).n64_u64[0];
      v10 = vmul_f32(v9, v9).n64_u64[0];
      v11 = (float)(*(float *)&v10 + *((float *)&v10 + 1)) + 0.0;
      if ( v11 >= (float)(this->m_fTargetRadius * this->m_fTargetRadius) )
      {
        m_fGoToPointDistance = this->m_fGoToPointDistance;
        if ( m_fGoToPointDistance == 0.0 )
        {
          v12 = 906;
        }
        else
        {
          v12 = 903;
          if ( v11 > (float)(m_fGoToPointDistance * m_fGoToPointDistance) )
            v12 = 906;
        }
      }
      else
      {
        *((_BYTE *)this + 72) |= 4u;
        CPed::SetMoveState(pPed, PEDMOVE_STILL);
        v12 = 244;
      }
      return sub_19D23C(this, v12, pPed);
    }
    else
    {
      v15 = (CTaskComplexLeaveCar *)CTask::operator new(0x34u);
      CTaskComplexLeaveCar::CTaskComplexLeaveCar(v15, pPed->m_pMyVehicle, 0, 0, 1, 0);
    }
  }
  else
  {
    v13 = (CTaskSimpleTired *)CTask::operator new(0x1Cu);
    CTaskSimpleTired::CTaskSimpleTired(v13, 1000);
  }
  return result;
}

//----- (00498C24) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculator>::ControlSubTask(
        CTaskComplexSeekEntity<CEntitySeekPosCalculator> *this,
        CPed *pPed)
{
  CEntity *m_pEntity; // r4
  CTaskSimpleStandStill *m_pSubTask; // r6
  RwReal y; // r8
  CPhysical *m_pGroundPhysical; // r0
  bool v8; // zf
  CPhysical *v9; // r0
  bool v10; // zf
  CEntity *m_pAttachToEntity; // r0
  unsigned int v12; // r0
  int m_iStartTime; // r1
  __int64 v14; // r0
  CMatrix *m_pMat; // r0
  float *v16; // r4
  int v17; // r1
  CSimpleTransform *p_tx; // r2
  float *v19; // r0
  float v20; // s2
  float z; // s4
  float x; // s16
  RwReal v23; // s18
  RwReal v24; // s20
  float *v25; // r1
  float v26; // s4
  float v27; // s6
  int v28; // r0
  float v29; // s18
  float v30; // s20
  float v31; // s16
  int v32; // r0
  float RadianAngleBetweenPoints; // r0
  float v34; // r0
  CMatrix *v35; // r0
  CSimpleTransform *p_m_transform; // r1
  float v37; // s16
  float m_fGoToPointDistance; // s0
  CTask *v39; // r0
  char m_pParent; // r1
  float v41; // s0
  CTask v42; // d16
  __int64 v43; // kr10_8
  CEntity *v44; // r0
  CPlayerPed *PlayerPed; // r0
  CVector v47; // [sp+14h] [bp-B4h] BYREF
  CMatrix output; // [sp+20h] [bp-A8h] BYREF
  CVector pCoors; // [sp+68h] [bp-60h] BYREF
  CVector v50; // [sp+78h] [bp-50h] BYREF
  CVector v; // [sp+88h] [bp-40h] BYREF

  m_pEntity = this->m_pEntity;
  m_pSubTask = (CTaskSimpleStandStill *)this->m_pSubTask;
  if ( m_pEntity && (*(_BYTE *)&m_pEntity->m_info & 7) == 3 && CPedGroups::AreInSameGroup(pPed, (const CPed *)m_pEntity) )
  {
    if ( BYTE1(m_pEntity[1].m_transform.m_translate.y) << 31 )
      goto LABEL_15;
    y = m_pEntity[23].m_transform.m_translate.y;
    if ( y != 0.0 && (*(_BYTE *)(LODWORD(y) + 58) & 7) == 2 )
    {
      m_pGroundPhysical = pPed->m_pGroundPhysical;
      v8 = m_pGroundPhysical == (CPhysical *)LODWORD(y);
      if ( m_pGroundPhysical != (CPhysical *)LODWORD(y) )
        v8 = pPed->m_pEntityStandingOn == (CEntity *)LODWORD(y);
      if ( v8 )
        goto LABEL_67;
    }
    y = *(float *)&m_pEntity[23].RandomSeed;
    if ( y == 0.0 || (*(_BYTE *)(LODWORD(y) + 58) & 7) != 2 )
      goto LABEL_15;
    v9 = pPed->m_pGroundPhysical;
    v10 = v9 == (CPhysical *)LODWORD(y);
    if ( v9 != (CPhysical *)LODWORD(y) )
      v10 = pPed->m_pEntityStandingOn == (CEntity *)LODWORD(y);
    if ( v10 )
    {
LABEL_67:
      if ( *(_DWORD *)(LODWORD(y) + 1440) != 5 )
        y = 0.0;
    }
    else
    {
LABEL_15:
      y = 0.0;
    }
    m_pAttachToEntity = pPed->m_pAttachToEntity;
    if ( y == 0.0 && m_pAttachToEntity )
    {
      CPed::DettachPedFromEntity(pPed);
    }
    else if ( y != 0.0
           && !m_pAttachToEntity
           && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 203
           && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
                this->m_pSubTask,
                pPed,
                1,
                0) == 1 )
    {
      m_pMat = pPed->m_pMat;
      v16 = (float *)(LODWORD(y) + 4);
      v17 = *(int *)((char *)&dword_14 + LODWORD(y));
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      v19 = (float *)(LODWORD(y) + 4);
      v20 = p_tx->m_translate.y;
      z = p_tx->m_translate.z;
      if ( v17 )
        v19 = (float *)(v17 + 48);
      v.x = *v19 - p_tx->m_translate.x;
      x = v.x;
      v.y = v19[1] - v20;
      v23 = v.y;
      v24 = v19[2] - z;
      v.z = v24;
      v50.z = v24;
      *(_QWORD *)&v50.x = *(_QWORD *)&v.x;
      CVector::Normalise(&v50);
      v25 = (float *)(LODWORD(y) + 4);
      v26 = v23 - (float)(v50.y * 0.25);
      v27 = v24 - (float)(v50.z * 0.25);
      v.y = v26;
      v.z = v27;
      v28 = *(int *)((char *)&dword_14 + LODWORD(y));
      if ( v28 )
        v25 = (float *)(v28 + 48);
      v29 = *v25 - (float)(x - (float)(v50.x * 0.25));
      v.x = v29;
      v30 = v25[1] - v26;
      v.y = v30;
      v31 = v25[2] - v27;
      v.z = v31;
      pCoors.z = v31;
      *(_QWORD *)&pCoors.x = *(_QWORD *)&v.x;
      if ( CPedPlacement::FindZCoorForPed(&pCoors) )
      {
        v = pCoors;
        v31 = pCoors.z;
        v30 = pCoors.y;
        v29 = pCoors.x;
      }
      v32 = *(int *)((char *)&dword_14 + LODWORD(y));
      if ( v32 )
        v16 = (float *)(v32 + 48);
      v.x = v29 - *v16;
      v.y = v30 - v16[1];
      v.z = v31 - v16[2];
      output.m_pRwMat = 0;
      output.m_owner = 0;
      Invert(*(const CMatrix **)((char *)&dword_14 + LODWORD(y)), &output);
      CVector::FromMultiply3X3(&v47, &output, &v);
      RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(v50.x, v50.y, 0.0, 0.0);
      v34 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
      CPed::AttachPedToEntity(
        pPed,
        (CEntity *)LODWORD(y),
        v47,
        (unsigned int)v34,
        0.2,
        pPed->m_WeaponSlots[pPed->m_nCurrentWeapon].m_eWeaponType);
      m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(m_pSubTask, 2000, 0, 0, 8.0);
      CMatrix::~CMatrix(&output);
      return m_pSubTask;
    }
  }
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 906
    || (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 903 )
  {
    if ( this->m_pEntity )
    {
      if ( this->m_seekTimer.m_bIsActive
        && (!this->m_seekTimer.m_bIsStopped ? (m_iStartTime = this->m_seekTimer.m_iStartTime,
                                               v12 = CTimer::m_snTimeInMilliseconds) : (v12 = CTimer::m_snTimeInMilliseconds,
                                                                                        this->m_seekTimer.m_bIsStopped = 0,
                                                                                        this->m_seekTimer.m_iStartTime = v12,
                                                                                        m_iStartTime = v12),
            m_iStartTime + this->m_seekTimer.m_iDuration <= v12) )
      {
        if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
               this->m_pSubTask,
               pPed,
               1,
               0) == 1 )
        {
          if ( *((unsigned __int8 *)this + 72) << 31 )
          {
            m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x1Cu);
            CTaskSimpleTired::CTaskSimpleTired((CTaskSimpleTired *)m_pSubTask, 1000);
          }
          else
          {
            m_pSubTask = 0;
          }
        }
      }
      else if ( this->m_scanTimer.m_bIsActive )
      {
        if ( this->m_scanTimer.m_bIsStopped )
        {
          LODWORD(v14) = CTimer::m_snTimeInMilliseconds;
          this->m_scanTimer.m_bIsStopped = 0;
          this->m_scanTimer.m_iStartTime = v14;
          HIDWORD(v14) = v14;
        }
        else
        {
          HIDWORD(v14) = this->m_scanTimer.m_iStartTime;
          LODWORD(v14) = CTimer::m_snTimeInMilliseconds;
        }
        if ( HIDWORD(v14) + this->m_scanTimer.m_iDuration <= (unsigned int)v14 )
        {
          HIDWORD(v14) = this->m_iPeriod;
          this->m_scanTimer.m_bIsActive = 1;
          *(_QWORD *)&this->m_scanTimer.m_iStartTime = v14;
          v35 = pPed->m_pMat;
          p_m_transform = (CSimpleTransform *)&v35->tx;
          if ( !v35 )
            p_m_transform = &pPed->m_transform;
          v37 = (float)((float)((float)(p_m_transform->m_translate.x - p_m_transform->m_translate.x)
                              * (float)(p_m_transform->m_translate.x - p_m_transform->m_translate.x))
                      + (float)((float)(p_m_transform->m_translate.y - p_m_transform->m_translate.x)
                              * (float)(p_m_transform->m_translate.y - p_m_transform->m_translate.x)))
              + 0.0;
          if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 906 )
          {
            m_fGoToPointDistance = this->m_fGoToPointDistance;
            if ( m_fGoToPointDistance == 0.0
              || v37 >= (float)((float)(m_fGoToPointDistance + -1.0) * (float)(m_fGoToPointDistance + -1.0)) )
            {
              CTaskComplexFollowNodeRoute::SetTarget(
                (CTaskComplexFollowNodeRoute *)this->m_pSubTask,
                pPed,
                &v,
                this->m_fTargetRadius,
                this->m_fSlowDownDistance,
                this->m_fFollowNodeThresholdHeightChange,
                0);
            }
            else if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask
                       + 7))(
                        this->m_pSubTask,
                        pPed,
                        1,
                        0) == 1 )
            {
              m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x28u);
              CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(
                (CTaskComplexGoToPointAndStandStill *)m_pSubTask,
                this->m_iMoveState,
                (const CVector *)&output,
                this->m_fTargetRadius,
                this->m_fSlowDownDistance,
                0,
                0);
              LOBYTE(m_pSubTask[1].m_pParent) = *((_BYTE *)this + 72) & 8 | (int)m_pSubTask[1].m_pParent & 0xF7;
              return m_pSubTask;
            }
          }
          else
          {
            v39 = this->m_pSubTask;
            m_pParent = (char)v39[4].m_pParent;
            if ( (m_pParent & 0x10) == 0 )
            {
              v41 = this->m_fGoToPointDistance;
              if ( v41 == 0.0 || v37 <= (float)((float)(v41 + 1.0) * (float)(v41 + 1.0)) )
              {
                v42 = *(CTask *)&v.x;
                v43 = *(_QWORD *)&this->m_fTargetRadius;
                v39[3]._vptr$CTask = (int (**)(void))LODWORD(v.z);
                *(_QWORD *)&v39[3].m_pParent = v43;
                LOBYTE(v39[4].m_pParent) = m_pParent | 4;
                v39[2] = v42;
              }
              else if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))v39->_vptr$CTask + 7))(v39, pPed, 1, 0) == 1 )
              {
                m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x60u);
                CTaskComplexFollowNodeRoute::CTaskComplexFollowNodeRoute(
                  (CTaskComplexFollowNodeRoute *)m_pSubTask,
                  this->m_iMoveState,
                  (const CVector *)&output,
                  this->m_fTargetRadius,
                  this->m_fSlowDownDistance,
                  this->m_fFollowNodeThresholdHeightChange,
                  0,
                  -1,
                  1);
                return m_pSubTask;
              }
            }
          }
          m_pSubTask = (CTaskSimpleStandStill *)this->m_pSubTask;
        }
      }
    }
    else if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
                this->m_pSubTask,
                pPed,
                1,
                0) )
    {
      m_pSubTask = 0;
    }
  }
  v44 = this->m_pEntity;
  if ( v44 )
  {
    if ( (*(_BYTE *)&v44->m_info & 7) == 3 && CPed::IsPlayer((const CPed *)v44) )
    {
      PlayerPed = FindPlayerPed(-1);
      if ( CPedGroupMembership::IsMember(
             &CPedGroups::ms_groups[PlayerPed->m_pPlayerData->m_PlayerGroup].m_membership,
             pPed)
        && (unsigned int)(pPed->m_eMoveState - 5) <= 2
        && !((CTimer::m_FrameCounter + pPed->RandomSeed) << 18) )
      {
        CPed::Say(pPed, 0x5Bu, 0, 1.0, 0, 0, 0);
      }
    }
  }
  return m_pSubTask;
}
// 14: using guessed type int dword_14;

//----- (004991AC) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculator>::CreateSubTask(
        const CTaskComplexSeekEntity<CEntitySeekPosCalculator> *this,
        const int iSubTaskType,
        CPed *pPed)
{
  CTaskComplexFollowNodeRoute *v5; // r4
  CTaskComplexTurnToFaceEntityOrCoord *v6; // r6
  CTaskSimpleStandStill *v7; // r5
  CVector vTarget; // [sp+14h] [bp-1Ch] BYREF

  v5 = 0;
  if ( iSubTaskType > 718 )
  {
    if ( iSubTaskType > 905 )
    {
      if ( iSubTaskType == 906 )
      {
        v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x60u);
        CTaskComplexFollowNodeRoute::CTaskComplexFollowNodeRoute(
          v5,
          this->m_iMoveState,
          &vTarget,
          this->m_fTargetRadius,
          this->m_fSlowDownDistance,
          this->m_fFollowNodeThresholdHeightChange,
          0,
          -1,
          1);
      }
      else if ( iSubTaskType == 920 )
      {
        v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x28u);
        CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(
          (CTaskComplexTurnToFaceEntityOrCoord *)v5,
          this->m_pEntity,
          0.5,
          0.2);
      }
    }
    else if ( iSubTaskType == 719 )
    {
      v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x70u);
      CTaskSimpleCarDrive::CTaskSimpleCarDrive((CTaskSimpleCarDrive *)v5, pPed->m_pMyVehicle, 0, 0);
      v5[1]._vptr$CTask = (int (**)(void))(elf_hash_bucket + 1748);
      LOWORD(v5[1].m_vTarget.x) = 0;
      v5[1].m_pParent = 0;
      v5[1].m_pSubTask = 0;
      v5->_vptr$CTask = (int (**)(void))&off_66571C;
    }
    else if ( iSubTaskType == 903 )
    {
      v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x28u);
      CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(
        (CTaskComplexGoToPointAndStandStill *)v5,
        this->m_iMoveState,
        &vTarget,
        this->m_fTargetRadius,
        this->m_fSlowDownDistance,
        0,
        0);
      LOBYTE(v5->m_fFollowNodeThresholdHeightChange) = *((_BYTE *)this + 72) & 8 | LOBYTE(v5->m_fFollowNodeThresholdHeightChange) & 0xF7;
    }
  }
  else if ( iSubTaskType > 243 )
  {
    if ( iSubTaskType == 244 )
    {
      v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x40u);
      CTaskComplexSequence::CTaskComplexSequence((CTaskComplexSequence *)v5);
      if ( (*((_BYTE *)this + 72) & 2) != 0 )
      {
        v6 = (CTaskComplexTurnToFaceEntityOrCoord *)CTask::operator new(0x28u);
        CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(v6, this->m_pEntity, 0.5, 0.2);
        CTaskComplexSequence::AddTask((CTaskComplexSequence *)v5, v6);
      }
      v7 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(v7, 100, 0, 0, 8.0);
      CTaskComplexSequence::AddTask((CTaskComplexSequence *)v5, v7);
    }
    else if ( iSubTaskType == 704 )
    {
      v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x34u);
      CTaskComplexLeaveCar::CTaskComplexLeaveCar((CTaskComplexLeaveCar *)v5, pPed->m_pMyVehicle, 0, 0, 1, 0);
    }
  }
  else if ( iSubTaskType == 203 )
  {
    v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v5, 2000, 0, 0, 8.0);
  }
  else if ( iSubTaskType == 219 )
  {
    v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x1Cu);
    CTaskSimpleTired::CTaskSimpleTired((CTaskSimpleTired *)v5, 1000);
  }
  return v5;
}
// FC: using guessed type int elf_hash_bucket[16411];
// 66571C: using guessed type void *off_66571C;

//----- (00499394) --------------------------------------------------------
void __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset>::~CTaskComplexSeekEntity(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset> *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CTask = (int (**)(void))&off_668968;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  sub_18EDB4(this);
}
// 668968: using guessed type void *;

//----- (004993C0) --------------------------------------------------------
void __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset>::~CTaskComplexSeekEntity(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset> *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1
  void *v4; // r0

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CTask = (int (**)(void))&off_668968;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 4993E8: variable 'v4' is possibly undefined
// 668968: using guessed type void *off_668968;

//----- (004993F0) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset>::Clone(
        const CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset> *this)
{
  char *v2; // r5
  __int64 v3; // d8
  __int64 v4; // d9
  CEntity *m_pEntity; // r9
  float m_fFollowNodeThresholdHeightChange; // r6
  char v7; // r8
  char v8; // r2
  char v9; // r0
  __int64 v10; // d16

  v2 = (char *)CTask::operator new(0x58u);
  v3 = *(_QWORD *)&this->m_iMaxSeekTime;
  v4 = *(_QWORD *)&this->m_fTargetRadius;
  m_pEntity = this->m_pEntity;
  m_fFollowNodeThresholdHeightChange = this->m_fFollowNodeThresholdHeightChange;
  v7 = *((_BYTE *)this + 84);
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_QWORD *)v2 + 2) = v3;
  *((_QWORD *)v2 + 3) = v4;
  *((_DWORD *)v2 + 20) = 6;
  v8 = v2[84];
  *((_DWORD *)v2 + 8) = 0;
  *((float *)v2 + 9) = m_fFollowNodeThresholdHeightChange;
  *((_WORD *)v2 + 24) = 0;
  *((_WORD *)v2 + 30) = 0;
  *((_DWORD *)v2 + 10) = 0;
  *((_DWORD *)v2 + 11) = 0;
  *((_DWORD *)v2 + 13) = 0;
  *((_DWORD *)v2 + 14) = 0;
  *((_DWORD *)v2 + 18) = 0;
  *((_DWORD *)v2 + 19) = 0;
  *(_DWORD *)v2 = &off_668968;
  *((_DWORD *)v2 + 16) = &off_66D3CC;
  v9 = v7 & 1 | v8 & 0xF0 | 2;
  v2[84] = v9;
  *((_DWORD *)v2 + 17) = 0;
  *((_DWORD *)v2 + 3) = m_pEntity;
  if ( m_pEntity )
  {
    CEntity::RegisterReference(m_pEntity, (CEntity **)v2 + 3);
    v9 = v2[84];
  }
  v10 = *(_QWORD *)&this->m_entitySeekPosCalculator.m_vOffset.x;
  *((_DWORD *)v2 + 19) = LODWORD(this->m_entitySeekPosCalculator.m_vOffset.z);
  *(_QWORD *)(v2 + 68) = v10;
  *((_DWORD *)v2 + 20) = this->m_iMoveState;
  v2[84] = v9 & 0xF7 | *((_BYTE *)this + 84) & 8;
  *((_DWORD *)v2 + 8) = LODWORD(this->m_fGoToPointDistance);
  *((_DWORD *)v2 + 20) = this->m_iMoveState;
  return (CTask *)v2;
}
// 668968: using guessed type void *off_668968;
// 66D3CC: using guessed type void *;

//----- (004994CC) --------------------------------------------------------
int __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset>::GetTaskType(
        const CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset> *this)
{
  return 907;
}

//----- (004994D4) --------------------------------------------------------
bool __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset>::MakeAbortable(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset> *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  int v5; // lr
  int v6; // r0
  int v7; // r1

  if ( !iPriority )
  {
    this->m_iMaxSeekTime = -1;
    v5 = CTimer::m_snTimeInMilliseconds;
    this->m_seekTimer.m_bIsActive = 1;
    this->m_seekTimer.m_iStartTime = v5;
    this->m_seekTimer.m_iDuration = -1;
  }
  v6 = (*((int (__fastcall **)(CTask *, CPed *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
         this->m_pSubTask,
         pPed);
  if ( v6 == 1 )
  {
    v7 = CTimer::m_snTimeInMilliseconds;
    this->m_scanTimer.m_bIsActive = 1;
    this->m_scanTimer.m_iStartTime = v7;
    this->m_scanTimer.m_iDuration = 0;
  }
  return v6;
}

//----- (00499524) --------------------------------------------------------
void __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset>::Serialize(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset> *this)
{
  bool v2; // r6
  __int16 v3; // r2
  __int16 v4; // r4
  _WORD *v5; // r5
  _DWORD *v6; // r5
  int v7; // r8
  bool v8; // r5
  __int16 v9; // r2
  __int16 v10; // r4
  _WORD *v11; // r6
  _DWORD *v12; // r6
  CEntity *m_pEntity; // r0
  int v14; // r8
  bool v15; // r6
  __int16 v16; // r2
  __int16 v17; // r4
  _WORD *v18; // r5
  _DWORD *v19; // r5
  CEntity *v20; // r0
  int v21; // r1
  int32 VehicleRef; // r8
  int v23; // r0
  bool v24; // r5
  __int16 v25; // r2
  __int16 v26; // r6
  _WORD *v27; // r4
  _DWORD *v28; // r4
  bool v29; // r6
  __int16 v30; // r2
  __int16 v31; // r4
  _WORD *v32; // r5
  bool v33; // r6
  __int16 v34; // r2
  __int16 v35; // r4
  _WORD *v36; // r5
  bool v37; // r6
  __int16 v38; // r2
  __int16 v39; // r4
  _WORD *v40; // r5
  _DWORD *v41; // r5
  unsigned __int8 s[128]; // [sp+4h] [bp-9Ch] BYREF

  v2 = UseDataFence;
  if ( UseDataFence )
  {
    v3 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v4 = v3 + DataFence;
    v5 = malloc(2u);
    *v5 = v4;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 2);
    free(v5);
    UseDataFence = v2;
  }
  v6 = malloc(4u);
  *v6 = 3;
  CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
  free(v6);
  v7 = (*((int (__fastcall **)(CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset> *))this->_vptr$CTask + 5))(this);
  v8 = UseDataFence;
  if ( UseDataFence )
  {
    v9 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v10 = v9 + DataFence;
    v11 = malloc(2u);
    *v11 = v10;
    CGenericGameStorage::_SaveDataToWorkBuffer(v11, 2);
    free(v11);
    UseDataFence = v8;
  }
  v12 = malloc(4u);
  *v12 = v7;
  CGenericGameStorage::_SaveDataToWorkBuffer(v12, 4);
  free(v12);
  if ( (*((int (__fastcall **)(CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset> *))this->_vptr$CTask + 5))(this) == 907 )
  {
    m_pEntity = this->m_pEntity;
    if ( m_pEntity )
    {
      v14 = *(_BYTE *)&m_pEntity->m_info & 7;
      v15 = UseDataFence;
      if ( UseDataFence )
      {
        v16 = currentSaveFenceCount;
        UseDataFence = 0;
        ++currentSaveFenceCount;
        v17 = v16 + DataFence;
        v18 = malloc(2u);
        *v18 = v17;
        CGenericGameStorage::_SaveDataToWorkBuffer(v18, 2);
        free(v18);
        UseDataFence = v15;
      }
      v19 = malloc(4u);
      *v19 = v14;
      CGenericGameStorage::_SaveDataToWorkBuffer(v19, 4);
      free(v19);
      v20 = this->m_pEntity;
      v21 = *(_BYTE *)&v20->m_info & 7;
      switch ( v21 )
      {
        case 2:
          if ( v20 )
            VehicleRef = CPools::GetVehicleRef((CVehicle *)v20);
          else
            VehicleRef = -1;
          v29 = UseDataFence;
          if ( UseDataFence )
          {
            v30 = currentSaveFenceCount;
            UseDataFence = 0;
            ++currentSaveFenceCount;
            v31 = v30 + DataFence;
            v32 = malloc(2u);
            *v32 = v31;
            CGenericGameStorage::_SaveDataToWorkBuffer(v32, 2);
            free(v32);
            UseDataFence = v29;
          }
          goto LABEL_34;
        case 4:
          if ( v20 )
            VehicleRef = CPools::GetObjectRef((CObject *)v20);
          else
            VehicleRef = -1;
          v33 = UseDataFence;
          if ( UseDataFence )
          {
            v34 = currentSaveFenceCount;
            UseDataFence = 0;
            ++currentSaveFenceCount;
            v35 = v34 + DataFence;
            v36 = malloc(2u);
            *v36 = v35;
            CGenericGameStorage::_SaveDataToWorkBuffer(v36, 2);
            free(v36);
            UseDataFence = v33;
          }
          goto LABEL_34;
        case 3:
          if ( v20 )
            VehicleRef = CPools::GetPedRef((CPed *)v20);
          else
            VehicleRef = -1;
          v37 = UseDataFence;
          if ( UseDataFence )
          {
            v38 = currentSaveFenceCount;
            UseDataFence = 0;
            ++currentSaveFenceCount;
            v39 = v38 + DataFence;
            v40 = malloc(2u);
            *v40 = v39;
            CGenericGameStorage::_SaveDataToWorkBuffer(v40, 2);
            free(v40);
            UseDataFence = v37;
          }
LABEL_34:
          v41 = malloc(4u);
          *v41 = VehicleRef;
          CGenericGameStorage::_SaveDataToWorkBuffer(v41, 4);
          j_free(v41);
          break;
      }
    }
    else
    {
      v24 = UseDataFence;
      if ( UseDataFence )
      {
        v25 = currentSaveFenceCount;
        UseDataFence = 0;
        ++currentSaveFenceCount;
        v26 = v25 + DataFence;
        v27 = malloc(2u);
        *v27 = v26;
        CGenericGameStorage::_SaveDataToWorkBuffer(v27, 2);
        free(v27);
        UseDataFence = v24;
      }
      v28 = malloc(4u);
      *v28 = 0;
      CGenericGameStorage::_SaveDataToWorkBuffer(v28, 4);
      j_free(v28);
    }
  }
  else
  {
    v23 = (*((int (__fastcall **)(CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset> *))this->_vptr$CTask + 5))(this);
    sprintf(s, "ERROR - class %d is not type %d serialize is not this class expected", v23, 907);
  }
}
// 499524: using guessed type unsigned __int8 s[128];

//----- (00499940) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset>::CreateNextSubTask(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset> *this,
        CPed *pPed)
{
  int v4; // r0
  CTaskSimpleStandStill *v5; // r6
  CTaskSimpleCarDrive *v6; // r0
  int v7; // r0
  bool v8; // zf
  CMatrix *m_pMat; // r6
  CSimpleTransform *p_tx; // r0
  float32x2_t v11; // d16
  unsigned __int64 v12; // d0
  float v13; // s0
  float m_fGoToPointDistance; // s2
  int v15; // r1
  CTaskSimpleStandStill *v17; // r0
  char v18; // r0
  CTaskSimpleStandStill vSeekPos; // [sp+8h] [bp-30h] BYREF

  if ( this->m_pEntity )
  {
    v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
    v5 = 0;
    if ( v4 > 718 )
    {
      if ( v4 != 719 )
      {
        v8 = v4 == 903;
        if ( v4 != 903 )
          v8 = v4 == 906;
        if ( v8 )
        {
          m_pMat = pPed->m_pMat;
          CEntitySeekPosCalculatorXYOffset::ComputeEntitySeekPos(
            &this->m_entitySeekPosCalculator,
            pPed,
            this->m_pEntity,
            (CVector *)&vSeekPos);
          p_tx = (CSimpleTransform *)&m_pMat->tx;
          if ( !m_pMat )
            p_tx = &pPed->m_transform;
          v11.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.x, (float32x2_t)vSeekPos.CTaskSimple).n64_u64[0];
          v12 = vmul_f32(v11, v11).n64_u64[0];
          v13 = (float)(*(float *)&v12 + *((float *)&v12 + 1)) + 0.0;
          if ( v13 <= (float)(this->m_fTargetRadius * this->m_fTargetRadius) )
          {
            v18 = *((_BYTE *)this + 84);
            *((_BYTE *)this + 84) = v18 | 4;
            v15 = 920;
            if ( (v18 & 2) == 0 )
              v15 = 1302;
          }
          else
          {
            m_fGoToPointDistance = this->m_fGoToPointDistance;
            if ( m_fGoToPointDistance == 0.0 )
            {
              v15 = 906;
            }
            else if ( v13 <= (float)(m_fGoToPointDistance * m_fGoToPointDistance) )
            {
              v15 = 903;
            }
            else
            {
              v15 = 906;
            }
          }
          return CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset>::CreateSubTask(this, v15, pPed);
        }
        return v5;
      }
    }
    else
    {
      if ( v4 != 203 )
      {
        if ( v4 == 219 )
        {
          v5 = 0;
          CTaskSimpleStandStill::CTaskSimpleStandStill(&vSeekPos, -1, 0, 0, 8.0);
          CTaskSimpleStandStill::ProcessPed(v17, pPed);
          CTaskSimpleStandStill::~CTaskSimpleStandStill(&vSeekPos);
        }
        else if ( v4 == 704 )
        {
          v5 = 0;
          if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
          {
            v6 = (CTaskSimpleCarDrive *)CTask::operator new(0x70u);
            CTaskSimpleCarDrive::CTaskSimpleCarDrive(v6, pPed->m_pMyVehicle, 0, 0);
            *(_DWORD *)(v7 + 96) = 2000;
            *(_WORD *)(v7 + 108) = 0;
            *(_DWORD *)(v7 + 100) = 0;
            *(_DWORD *)(v7 + 104) = 0;
            v5 = (CTaskSimpleStandStill *)v7;
            *(_DWORD *)v7 = &off_66571C;
          }
        }
        return v5;
      }
      if ( pPed->m_pAttachToEntity )
      {
        v5 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
        CTaskSimpleStandStill::CTaskSimpleStandStill(v5, 2000, 0, 0, 8.0);
        return v5;
      }
    }
    return (CTask *)(*((int (__fastcall **)(CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset> *, CPed *))this->_vptr$CTask
                     + 11))(
                      this,
                      pPed);
  }
  return 0;
}
// 49999A: variable 'v7' is possibly undefined
// 499A8E: variable 'v17' is possibly undefined
// 66571C: using guessed type void *off_66571C;

//----- (00499AD8) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset>::CreateFirstSubTask(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset> *this,
        CPed *pPed)
{
  __int64 v4; // kr00_8
  int v5; // r1
  CEntity *m_pEntity; // r2
  bool v7; // zf
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float32x2_t v10; // d16
  unsigned __int64 v11; // d0
  float v12; // s0
  int v13; // r1
  CTaskSimpleTired *v14; // r0
  float m_fGoToPointDistance; // s2
  CTaskComplexLeaveCar *v16; // r0
  CTask *result; // r0
  CVector vSeekPos; // [sp+8h] [bp-18h] BYREF

  v4 = *(_QWORD *)&this->m_iMaxSeekTime;
  v5 = CTimer::m_snTimeInMilliseconds;
  this->m_scanTimer.m_bIsActive = 1;
  this->m_scanTimer.m_iStartTime = v5;
  this->m_scanTimer.m_iDuration = HIDWORD(v4);
  if ( (_DWORD)v4 != -1 )
  {
    this->m_seekTimer.m_bIsActive = 1;
    this->m_seekTimer.m_iStartTime = v5;
    this->m_seekTimer.m_iDuration = v4;
  }
  m_pEntity = this->m_pEntity;
  if ( m_pEntity )
  {
    v7 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
    if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
      v7 = pPed->m_pMyVehicle == 0;
    if ( v7 )
    {
      CEntitySeekPosCalculatorXYOffset::ComputeEntitySeekPos(
        &this->m_entitySeekPosCalculator,
        pPed,
        m_pEntity,
        &vSeekPos);
      m_pMat = pPed->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      v10.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.x, *(float32x2_t *)&vSeekPos.x).n64_u64[0];
      v11 = vmul_f32(v10, v10).n64_u64[0];
      v12 = (float)(*(float *)&v11 + *((float *)&v11 + 1)) + 0.0;
      if ( v12 >= (float)(this->m_fTargetRadius * this->m_fTargetRadius) )
      {
        m_fGoToPointDistance = this->m_fGoToPointDistance;
        if ( m_fGoToPointDistance == 0.0 )
        {
          v13 = 906;
        }
        else
        {
          v13 = 903;
          if ( v12 > (float)(m_fGoToPointDistance * m_fGoToPointDistance) )
            v13 = 906;
        }
      }
      else
      {
        *((_BYTE *)this + 84) |= 4u;
        CPed::SetMoveState(pPed, PEDMOVE_STILL);
        v13 = 244;
      }
      return CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset>::CreateSubTask(this, v13, pPed);
    }
    else
    {
      v16 = (CTaskComplexLeaveCar *)CTask::operator new(0x34u);
      CTaskComplexLeaveCar::CTaskComplexLeaveCar(v16, pPed->m_pMyVehicle, 0, 0, 1, 0);
    }
  }
  else
  {
    v14 = (CTaskSimpleTired *)CTask::operator new(0x1Cu);
    CTaskSimpleTired::CTaskSimpleTired(v14, 1000);
  }
  return result;
}

//----- (00499BE4) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset>::ControlSubTask(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset> *this,
        CPed *pPed)
{
  CEntity *m_pEntity; // r4
  CTaskSimpleStandStill *m_pSubTask; // r6
  RwReal y; // r8
  CPhysical *m_pGroundPhysical; // r0
  bool v8; // zf
  CPhysical *v9; // r0
  bool v10; // zf
  CEntity *m_pAttachToEntity; // r0
  CMatrix *m_pMat; // r0
  float *v13; // r4
  int v14; // r1
  CSimpleTransform *p_tx; // r2
  float *v16; // r0
  float v17; // s2
  float z; // s4
  float x; // s16
  RwReal v20; // s18
  RwReal v21; // s20
  float *v22; // r1
  float v23; // s4
  float v24; // s6
  int v25; // r0
  float v26; // s18
  float v27; // s20
  float v28; // s16
  int v29; // r0
  float RadianAngleBetweenPoints; // r0
  float v31; // r0
  CEntity *v32; // r2
  unsigned int v33; // r0
  int m_iStartTime; // r1
  __int64 v35; // r0
  CMatrix *v36; // r0
  CSimpleTransform *p_m_transform; // r1
  float v38; // s16
  float m_fGoToPointDistance; // s0
  int m_iMoveState; // r4
  CTask *v41; // r0
  char m_pParent; // r1
  float v43; // s0
  int v44; // r4
  float m_fTargetRadius; // r2
  float m_fSlowDownDistance; // s0
  CTask v47; // d16
  CEntity *v48; // r0
  CPlayerPed *PlayerPed; // r0
  CVector v51; // [sp+14h] [bp-BCh] BYREF
  CMatrix output; // [sp+20h] [bp-B0h] BYREF
  CVector pCoors; // [sp+68h] [bp-68h] BYREF
  CVector v54; // [sp+78h] [bp-58h] BYREF
  CVector v; // [sp+88h] [bp-48h] BYREF

  m_pEntity = this->m_pEntity;
  m_pSubTask = (CTaskSimpleStandStill *)this->m_pSubTask;
  if ( m_pEntity && (*(_BYTE *)&m_pEntity->m_info & 7) == 3 && CPedGroups::AreInSameGroup(pPed, (const CPed *)m_pEntity) )
  {
    if ( BYTE1(m_pEntity[1].m_transform.m_translate.y) << 31 )
      goto LABEL_15;
    y = m_pEntity[23].m_transform.m_translate.y;
    if ( y != 0.0 && (*(_BYTE *)(LODWORD(y) + 58) & 7) == 2 )
    {
      m_pGroundPhysical = pPed->m_pGroundPhysical;
      v8 = m_pGroundPhysical == (CPhysical *)LODWORD(y);
      if ( m_pGroundPhysical != (CPhysical *)LODWORD(y) )
        v8 = pPed->m_pEntityStandingOn == (CEntity *)LODWORD(y);
      if ( v8 )
        goto LABEL_67;
    }
    y = *(float *)&m_pEntity[23].RandomSeed;
    if ( y == 0.0 || (*(_BYTE *)(LODWORD(y) + 58) & 7) != 2 )
      goto LABEL_15;
    v9 = pPed->m_pGroundPhysical;
    v10 = v9 == (CPhysical *)LODWORD(y);
    if ( v9 != (CPhysical *)LODWORD(y) )
      v10 = pPed->m_pEntityStandingOn == (CEntity *)LODWORD(y);
    if ( v10 )
    {
LABEL_67:
      if ( *(_DWORD *)(LODWORD(y) + 1440) != 5 )
        y = 0.0;
    }
    else
    {
LABEL_15:
      y = 0.0;
    }
    m_pAttachToEntity = pPed->m_pAttachToEntity;
    if ( y == 0.0 && m_pAttachToEntity )
    {
      CPed::DettachPedFromEntity(pPed);
    }
    else if ( y != 0.0
           && !m_pAttachToEntity
           && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 203
           && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
                this->m_pSubTask,
                pPed,
                1,
                0) == 1 )
    {
      m_pMat = pPed->m_pMat;
      v13 = (float *)(LODWORD(y) + 4);
      v14 = *(int *)((char *)&dword_14 + LODWORD(y));
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      v16 = (float *)(LODWORD(y) + 4);
      v17 = p_tx->m_translate.y;
      z = p_tx->m_translate.z;
      if ( v14 )
        v16 = (float *)(v14 + 48);
      v.x = *v16 - p_tx->m_translate.x;
      x = v.x;
      v.y = v16[1] - v17;
      v20 = v.y;
      v21 = v16[2] - z;
      v.z = v21;
      v54.z = v21;
      *(_QWORD *)&v54.x = *(_QWORD *)&v.x;
      CVector::Normalise(&v54);
      v22 = (float *)(LODWORD(y) + 4);
      v23 = v20 - (float)(v54.y * 0.25);
      v24 = v21 - (float)(v54.z * 0.25);
      v.y = v23;
      v.z = v24;
      v25 = *(int *)((char *)&dword_14 + LODWORD(y));
      if ( v25 )
        v22 = (float *)(v25 + 48);
      v26 = *v22 - (float)(x - (float)(v54.x * 0.25));
      v.x = v26;
      v27 = v22[1] - v23;
      v.y = v27;
      v28 = v22[2] - v24;
      v.z = v28;
      pCoors.z = v28;
      *(_QWORD *)&pCoors.x = *(_QWORD *)&v.x;
      if ( CPedPlacement::FindZCoorForPed(&pCoors) )
      {
        v = pCoors;
        v28 = pCoors.z;
        v27 = pCoors.y;
        v26 = pCoors.x;
      }
      v29 = *(int *)((char *)&dword_14 + LODWORD(y));
      if ( v29 )
        v13 = (float *)(v29 + 48);
      v.x = v26 - *v13;
      v.y = v27 - v13[1];
      v.z = v28 - v13[2];
      output.m_pRwMat = 0;
      output.m_owner = 0;
      Invert(*(const CMatrix **)((char *)&dword_14 + LODWORD(y)), &output);
      CVector::FromMultiply3X3(&v51, &output, &v);
      RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(v54.x, v54.y, 0.0, 0.0);
      v31 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
      CPed::AttachPedToEntity(
        pPed,
        (CEntity *)LODWORD(y),
        v51,
        (unsigned int)v31,
        0.2,
        pPed->m_WeaponSlots[pPed->m_nCurrentWeapon].m_eWeaponType);
      m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(m_pSubTask, 2000, 0, 0, 8.0);
      CMatrix::~CMatrix(&output);
      return m_pSubTask;
    }
  }
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 906
    || (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 903 )
  {
    v32 = this->m_pEntity;
    if ( v32 )
    {
      if ( this->m_seekTimer.m_bIsActive
        && (!this->m_seekTimer.m_bIsStopped ? (m_iStartTime = this->m_seekTimer.m_iStartTime,
                                               v33 = CTimer::m_snTimeInMilliseconds) : (v33 = CTimer::m_snTimeInMilliseconds,
                                                                                        this->m_seekTimer.m_bIsStopped = 0,
                                                                                        this->m_seekTimer.m_iStartTime = v33,
                                                                                        m_iStartTime = v33),
            m_iStartTime + this->m_seekTimer.m_iDuration <= v33) )
      {
        if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
               this->m_pSubTask,
               pPed,
               1,
               0) == 1 )
        {
          if ( *((unsigned __int8 *)this + 84) << 31 )
          {
            m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x1Cu);
            CTaskSimpleTired::CTaskSimpleTired((CTaskSimpleTired *)m_pSubTask, 1000);
          }
          else
          {
            m_pSubTask = 0;
          }
        }
      }
      else if ( this->m_scanTimer.m_bIsActive )
      {
        if ( this->m_scanTimer.m_bIsStopped )
        {
          LODWORD(v35) = CTimer::m_snTimeInMilliseconds;
          this->m_scanTimer.m_bIsStopped = 0;
          this->m_scanTimer.m_iStartTime = v35;
          HIDWORD(v35) = v35;
        }
        else
        {
          HIDWORD(v35) = this->m_scanTimer.m_iStartTime;
          LODWORD(v35) = CTimer::m_snTimeInMilliseconds;
        }
        if ( HIDWORD(v35) + this->m_scanTimer.m_iDuration <= (unsigned int)v35 )
        {
          HIDWORD(v35) = this->m_iPeriod;
          this->m_scanTimer.m_bIsActive = 1;
          *(_QWORD *)&this->m_scanTimer.m_iStartTime = v35;
          CEntitySeekPosCalculatorXYOffset::ComputeEntitySeekPos(&this->m_entitySeekPosCalculator, pPed, v32, &v);
          v36 = pPed->m_pMat;
          p_m_transform = (CSimpleTransform *)&v36->tx;
          if ( !v36 )
            p_m_transform = &pPed->m_transform;
          v38 = (float)((float)((float)(p_m_transform->m_translate.x - v.x) * (float)(p_m_transform->m_translate.x - v.x))
                      + (float)((float)(p_m_transform->m_translate.y - v.y) * (float)(p_m_transform->m_translate.y - v.y)))
              + 0.0;
          if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 906 )
          {
            m_fGoToPointDistance = this->m_fGoToPointDistance;
            if ( m_fGoToPointDistance == 0.0
              || v38 >= (float)((float)(m_fGoToPointDistance + -1.0) * (float)(m_fGoToPointDistance + -1.0)) )
            {
              CTaskComplexFollowNodeRoute::SetTarget(
                (CTaskComplexFollowNodeRoute *)this->m_pSubTask,
                pPed,
                &v,
                this->m_fTargetRadius,
                this->m_fSlowDownDistance,
                this->m_fFollowNodeThresholdHeightChange,
                0);
            }
            else if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask
                       + 7))(
                        this->m_pSubTask,
                        pPed,
                        1,
                        0) == 1 )
            {
              m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x28u);
              m_iMoveState = this->m_iMoveState;
              CEntitySeekPosCalculatorXYOffset::ComputeEntitySeekPos(
                &this->m_entitySeekPosCalculator,
                pPed,
                this->m_pEntity,
                (CVector *)&output);
              CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(
                (CTaskComplexGoToPointAndStandStill *)m_pSubTask,
                m_iMoveState,
                (const CVector *)&output,
                this->m_fTargetRadius,
                this->m_fSlowDownDistance,
                0,
                0);
              LOBYTE(m_pSubTask[1].m_pParent) = *((_BYTE *)this + 84) & 8 | (int)m_pSubTask[1].m_pParent & 0xF7;
              return m_pSubTask;
            }
          }
          else
          {
            v41 = this->m_pSubTask;
            m_pParent = (char)v41[4].m_pParent;
            if ( (m_pParent & 0x10) == 0 )
            {
              v43 = this->m_fGoToPointDistance;
              if ( v43 == 0.0 || v38 <= (float)((float)(v43 + 1.0) * (float)(v43 + 1.0)) )
              {
                m_fTargetRadius = this->m_fTargetRadius;
                m_fSlowDownDistance = this->m_fSlowDownDistance;
                if ( *(float *)&v41[2]._vptr$CTask != v.x
                  || *(float *)&v41[2].m_pParent != v.y
                  || *(float *)&v41[3]._vptr$CTask != v.z
                  || *(float *)&v41[4]._vptr$CTask != m_fSlowDownDistance )
                {
                  v47 = *(CTask *)&v.x;
                  v41[3]._vptr$CTask = (int (**)(void))LODWORD(v.z);
                  *(float *)&v41[3].m_pParent = m_fTargetRadius;
                  *(float *)&v41[4]._vptr$CTask = m_fSlowDownDistance;
                  LOBYTE(v41[4].m_pParent) = m_pParent | 4;
                  v41[2] = v47;
                }
              }
              else if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))v41->_vptr$CTask + 7))(v41, pPed, 1, 0) == 1 )
              {
                m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x60u);
                v44 = this->m_iMoveState;
                CEntitySeekPosCalculatorXYOffset::ComputeEntitySeekPos(
                  &this->m_entitySeekPosCalculator,
                  pPed,
                  this->m_pEntity,
                  (CVector *)&output);
                CTaskComplexFollowNodeRoute::CTaskComplexFollowNodeRoute(
                  (CTaskComplexFollowNodeRoute *)m_pSubTask,
                  v44,
                  (const CVector *)&output,
                  this->m_fTargetRadius,
                  this->m_fSlowDownDistance,
                  this->m_fFollowNodeThresholdHeightChange,
                  0,
                  -1,
                  1);
                return m_pSubTask;
              }
            }
          }
          m_pSubTask = (CTaskSimpleStandStill *)this->m_pSubTask;
        }
      }
    }
    else if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
                this->m_pSubTask,
                pPed,
                1,
                0) )
    {
      m_pSubTask = 0;
    }
  }
  v48 = this->m_pEntity;
  if ( v48 )
  {
    if ( (*(_BYTE *)&v48->m_info & 7) == 3 && CPed::IsPlayer((const CPed *)v48) )
    {
      PlayerPed = FindPlayerPed(-1);
      if ( CPedGroupMembership::IsMember(
             &CPedGroups::ms_groups[PlayerPed->m_pPlayerData->m_PlayerGroup].m_membership,
             pPed)
        && (unsigned int)(pPed->m_eMoveState - 5) <= 2
        && !((CTimer::m_FrameCounter + pPed->RandomSeed) << 18) )
      {
        CPed::Say(pPed, 0x5Bu, 0, 1.0, 0, 0, 0);
      }
    }
  }
  return m_pSubTask;
}
// 14: using guessed type int dword_14;

//----- (0049A1F4) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset>::CreateSubTask(
        const CTaskComplexSeekEntity<CEntitySeekPosCalculatorXYOffset> *this,
        const int iSubTaskType,
        CPed *pPed)
{
  CTaskComplexFollowNodeRoute *v5; // r4
  int v6; // r8
  CTaskComplexTurnToFaceEntityOrCoord *v7; // r6
  CTaskSimpleStandStill *v8; // r5
  int m_iMoveState; // r8
  CVector vSeekPos; // [sp+14h] [bp-24h] BYREF

  v5 = 0;
  if ( iSubTaskType > 718 )
  {
    if ( iSubTaskType > 905 )
    {
      if ( iSubTaskType == 906 )
      {
        v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x60u);
        m_iMoveState = this->m_iMoveState;
        CEntitySeekPosCalculatorXYOffset::ComputeEntitySeekPos(
          &this->m_entitySeekPosCalculator,
          pPed,
          this->m_pEntity,
          &vSeekPos);
        CTaskComplexFollowNodeRoute::CTaskComplexFollowNodeRoute(
          v5,
          m_iMoveState,
          &vSeekPos,
          this->m_fTargetRadius,
          this->m_fSlowDownDistance,
          this->m_fFollowNodeThresholdHeightChange,
          0,
          -1,
          1);
      }
      else if ( iSubTaskType == 920 )
      {
        v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x28u);
        CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(
          (CTaskComplexTurnToFaceEntityOrCoord *)v5,
          this->m_pEntity,
          0.5,
          0.2);
      }
    }
    else if ( iSubTaskType == 719 )
    {
      v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x70u);
      CTaskSimpleCarDrive::CTaskSimpleCarDrive((CTaskSimpleCarDrive *)v5, pPed->m_pMyVehicle, 0, 0);
      v5[1]._vptr$CTask = (int (**)(void))(elf_hash_bucket + 1748);
      LOWORD(v5[1].m_vTarget.x) = 0;
      v5[1].m_pParent = 0;
      v5[1].m_pSubTask = 0;
      v5->_vptr$CTask = (int (**)(void))&off_66571C;
    }
    else if ( iSubTaskType == 903 )
    {
      v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x28u);
      v6 = this->m_iMoveState;
      CEntitySeekPosCalculatorXYOffset::ComputeEntitySeekPos(
        &this->m_entitySeekPosCalculator,
        pPed,
        this->m_pEntity,
        &vSeekPos);
      CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(
        (CTaskComplexGoToPointAndStandStill *)v5,
        v6,
        &vSeekPos,
        this->m_fTargetRadius,
        this->m_fSlowDownDistance,
        0,
        0);
      LOBYTE(v5->m_fFollowNodeThresholdHeightChange) = *((_BYTE *)this + 84) & 8 | LOBYTE(v5->m_fFollowNodeThresholdHeightChange) & 0xF7;
    }
  }
  else if ( iSubTaskType > 243 )
  {
    if ( iSubTaskType == 244 )
    {
      v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x40u);
      CTaskComplexSequence::CTaskComplexSequence((CTaskComplexSequence *)v5);
      if ( (*((_BYTE *)this + 84) & 2) != 0 )
      {
        v7 = (CTaskComplexTurnToFaceEntityOrCoord *)CTask::operator new(0x28u);
        CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(v7, this->m_pEntity, 0.5, 0.2);
        CTaskComplexSequence::AddTask((CTaskComplexSequence *)v5, v7);
      }
      v8 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(v8, 100, 0, 0, 8.0);
      CTaskComplexSequence::AddTask((CTaskComplexSequence *)v5, v8);
    }
    else if ( iSubTaskType == 704 )
    {
      v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x34u);
      CTaskComplexLeaveCar::CTaskComplexLeaveCar((CTaskComplexLeaveCar *)v5, pPed->m_pMyVehicle, 0, 0, 1, 0);
    }
  }
  else if ( iSubTaskType == 203 )
  {
    v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v5, 2000, 0, 0, 8.0);
  }
  else if ( iSubTaskType == 219 )
  {
    v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x1Cu);
    CTaskSimpleTired::CTaskSimpleTired((CTaskSimpleTired *)v5, 1000);
  }
  return v5;
}
// FC: using guessed type int elf_hash_bucket[16411];
// 66571C: using guessed type void *off_66571C;

//----- (0049A408) --------------------------------------------------------
void __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface>::~CTaskComplexSeekEntity(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface> *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CTask = (int (**)(void))&off_6689A4;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  sub_18EDB4(this);
}
// 6689A4: using guessed type void *;

//----- (0049A434) --------------------------------------------------------
void __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface>::~CTaskComplexSeekEntity(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface> *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1
  void *v4; // r0

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CTask = (int (**)(void))&off_6689A4;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 49A45C: variable 'v4' is possibly undefined
// 6689A4: using guessed type void *off_6689A4;

//----- (0049A464) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface>::Clone(
        const CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface> *this)
{
  void *v2; // r5
  __int64 v3; // d8
  __int64 v4; // d9
  CEntity *m_pEntity; // r6
  float m_fFollowNodeThresholdHeightChange; // r8
  char v7; // r9
  char v8; // r3
  char v9; // r0

  v2 = CTask::operator new(0x4Cu);
  v3 = *(_QWORD *)&this->m_iMaxSeekTime;
  v4 = *(_QWORD *)&this->m_fTargetRadius;
  m_pEntity = this->m_pEntity;
  m_fFollowNodeThresholdHeightChange = this->m_fFollowNodeThresholdHeightChange;
  v7 = *((_BYTE *)this + 72);
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_QWORD *)v2 + 2) = v3;
  *((_QWORD *)v2 + 3) = v4;
  *((_DWORD *)v2 + 8) = 0;
  *((float *)v2 + 9) = m_fFollowNodeThresholdHeightChange;
  *((_WORD *)v2 + 24) = 0;
  *((_WORD *)v2 + 30) = 0;
  *((_DWORD *)v2 + 10) = 0;
  *((_DWORD *)v2 + 11) = 0;
  *((_DWORD *)v2 + 13) = 0;
  *((_DWORD *)v2 + 14) = 0;
  v8 = *((_BYTE *)v2 + 72);
  *(_DWORD *)v2 = &off_6689A4;
  *((_DWORD *)v2 + 16) = &off_66D3D8;
  *((_DWORD *)v2 + 17) = 6;
  v9 = v7 & 1 | v8 & 0xF0 | 2;
  *((_BYTE *)v2 + 72) = v9;
  *((_DWORD *)v2 + 3) = m_pEntity;
  if ( m_pEntity )
  {
    CEntity::RegisterReference(m_pEntity, (CEntity **)v2 + 3);
    v9 = *((_BYTE *)v2 + 72);
  }
  *((_DWORD *)v2 + 17) = this->m_iMoveState;
  *((_BYTE *)v2 + 72) = v9 & 0xF7 | *((_BYTE *)this + 72) & 8;
  *((_DWORD *)v2 + 8) = LODWORD(this->m_fGoToPointDistance);
  *((_DWORD *)v2 + 17) = this->m_iMoveState;
  return (CTask *)v2;
}
// 6689A4: using guessed type void *off_6689A4;
// 66D3D8: using guessed type void *;

//----- (0049A52C) --------------------------------------------------------
int __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface>::GetTaskType(
        const CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface> *this)
{
  return 907;
}

//----- (0049A534) --------------------------------------------------------
bool __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface>::MakeAbortable(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface> *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  int v5; // lr
  int v6; // r0
  int v7; // r1

  if ( !iPriority )
  {
    this->m_iMaxSeekTime = -1;
    v5 = CTimer::m_snTimeInMilliseconds;
    this->m_seekTimer.m_bIsActive = 1;
    this->m_seekTimer.m_iStartTime = v5;
    this->m_seekTimer.m_iDuration = -1;
  }
  v6 = (*((int (__fastcall **)(CTask *, CPed *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
         this->m_pSubTask,
         pPed);
  if ( v6 == 1 )
  {
    v7 = CTimer::m_snTimeInMilliseconds;
    this->m_scanTimer.m_bIsActive = 1;
    this->m_scanTimer.m_iStartTime = v7;
    this->m_scanTimer.m_iDuration = 0;
  }
  return v6;
}

//----- (0049A584) --------------------------------------------------------
void __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface>::Serialize(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface> *this)
{
  bool v2; // r6
  __int16 v3; // r2
  __int16 v4; // r4
  _WORD *v5; // r5
  _DWORD *v6; // r5
  int v7; // r8
  bool v8; // r5
  __int16 v9; // r2
  __int16 v10; // r4
  _WORD *v11; // r6
  _DWORD *v12; // r6
  CEntity *m_pEntity; // r0
  int v14; // r8
  bool v15; // r6
  __int16 v16; // r2
  __int16 v17; // r4
  _WORD *v18; // r5
  _DWORD *v19; // r5
  CEntity *v20; // r0
  int v21; // r1
  int32 VehicleRef; // r8
  int v23; // r0
  bool v24; // r5
  __int16 v25; // r2
  __int16 v26; // r6
  _WORD *v27; // r4
  _DWORD *v28; // r4
  bool v29; // r6
  __int16 v30; // r2
  __int16 v31; // r4
  _WORD *v32; // r5
  bool v33; // r6
  __int16 v34; // r2
  __int16 v35; // r4
  _WORD *v36; // r5
  bool v37; // r6
  __int16 v38; // r2
  __int16 v39; // r4
  _WORD *v40; // r5
  _DWORD *v41; // r5
  unsigned __int8 s[128]; // [sp+4h] [bp-9Ch] BYREF

  v2 = UseDataFence;
  if ( UseDataFence )
  {
    v3 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v4 = v3 + DataFence;
    v5 = malloc(2u);
    *v5 = v4;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 2);
    free(v5);
    UseDataFence = v2;
  }
  v6 = malloc(4u);
  *v6 = 4;
  CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
  free(v6);
  v7 = (*((int (__fastcall **)(CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface> *))this->_vptr$CTask + 5))(this);
  v8 = UseDataFence;
  if ( UseDataFence )
  {
    v9 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v10 = v9 + DataFence;
    v11 = malloc(2u);
    *v11 = v10;
    CGenericGameStorage::_SaveDataToWorkBuffer(v11, 2);
    free(v11);
    UseDataFence = v8;
  }
  v12 = malloc(4u);
  *v12 = v7;
  CGenericGameStorage::_SaveDataToWorkBuffer(v12, 4);
  free(v12);
  if ( (*((int (__fastcall **)(CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface> *))this->_vptr$CTask + 5))(this) == 907 )
  {
    m_pEntity = this->m_pEntity;
    if ( m_pEntity )
    {
      v14 = *(_BYTE *)&m_pEntity->m_info & 7;
      v15 = UseDataFence;
      if ( UseDataFence )
      {
        v16 = currentSaveFenceCount;
        UseDataFence = 0;
        ++currentSaveFenceCount;
        v17 = v16 + DataFence;
        v18 = malloc(2u);
        *v18 = v17;
        CGenericGameStorage::_SaveDataToWorkBuffer(v18, 2);
        free(v18);
        UseDataFence = v15;
      }
      v19 = malloc(4u);
      *v19 = v14;
      CGenericGameStorage::_SaveDataToWorkBuffer(v19, 4);
      free(v19);
      v20 = this->m_pEntity;
      v21 = *(_BYTE *)&v20->m_info & 7;
      switch ( v21 )
      {
        case 2:
          if ( v20 )
            VehicleRef = CPools::GetVehicleRef((CVehicle *)v20);
          else
            VehicleRef = -1;
          v29 = UseDataFence;
          if ( UseDataFence )
          {
            v30 = currentSaveFenceCount;
            UseDataFence = 0;
            ++currentSaveFenceCount;
            v31 = v30 + DataFence;
            v32 = malloc(2u);
            *v32 = v31;
            CGenericGameStorage::_SaveDataToWorkBuffer(v32, 2);
            free(v32);
            UseDataFence = v29;
          }
          goto LABEL_34;
        case 4:
          if ( v20 )
            VehicleRef = CPools::GetObjectRef((CObject *)v20);
          else
            VehicleRef = -1;
          v33 = UseDataFence;
          if ( UseDataFence )
          {
            v34 = currentSaveFenceCount;
            UseDataFence = 0;
            ++currentSaveFenceCount;
            v35 = v34 + DataFence;
            v36 = malloc(2u);
            *v36 = v35;
            CGenericGameStorage::_SaveDataToWorkBuffer(v36, 2);
            free(v36);
            UseDataFence = v33;
          }
          goto LABEL_34;
        case 3:
          if ( v20 )
            VehicleRef = CPools::GetPedRef((CPed *)v20);
          else
            VehicleRef = -1;
          v37 = UseDataFence;
          if ( UseDataFence )
          {
            v38 = currentSaveFenceCount;
            UseDataFence = 0;
            ++currentSaveFenceCount;
            v39 = v38 + DataFence;
            v40 = malloc(2u);
            *v40 = v39;
            CGenericGameStorage::_SaveDataToWorkBuffer(v40, 2);
            free(v40);
            UseDataFence = v37;
          }
LABEL_34:
          v41 = malloc(4u);
          *v41 = VehicleRef;
          CGenericGameStorage::_SaveDataToWorkBuffer(v41, 4);
          j_free(v41);
          break;
      }
    }
    else
    {
      v24 = UseDataFence;
      if ( UseDataFence )
      {
        v25 = currentSaveFenceCount;
        UseDataFence = 0;
        ++currentSaveFenceCount;
        v26 = v25 + DataFence;
        v27 = malloc(2u);
        *v27 = v26;
        CGenericGameStorage::_SaveDataToWorkBuffer(v27, 2);
        free(v27);
        UseDataFence = v24;
      }
      v28 = malloc(4u);
      *v28 = 0;
      CGenericGameStorage::_SaveDataToWorkBuffer(v28, 4);
      j_free(v28);
    }
  }
  else
  {
    v23 = (*((int (__fastcall **)(CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface> *))this->_vptr$CTask + 5))(this);
    sprintf(s, "ERROR - class %d is not type %d serialize is not this class expected", v23, 907);
  }
}
// 49A584: using guessed type unsigned __int8 s[128];

//----- (0049A998) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface>::CreateNextSubTask(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface> *this,
        CPed *pPed)
{
  int v4; // r0
  CTaskSimpleStandStill *v5; // r6
  CTaskSimpleCarDrive *v6; // r0
  int v7; // r0
  bool v8; // zf
  CMatrix *m_pMat; // r6
  CSimpleTransform *p_tx; // r0
  float32x2_t v11; // d16
  unsigned __int64 v12; // d0
  float v13; // s0
  float m_fGoToPointDistance; // s2
  int v15; // r1
  CTaskSimpleStandStill *v17; // r0
  char v18; // r0
  CTaskSimpleStandStill vSeekPos; // [sp+8h] [bp-30h] BYREF

  if ( this->m_pEntity )
  {
    v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
    v5 = 0;
    if ( v4 > 718 )
    {
      if ( v4 != 719 )
      {
        v8 = v4 == 903;
        if ( v4 != 903 )
          v8 = v4 == 906;
        if ( v8 )
        {
          m_pMat = pPed->m_pMat;
          CEntitySeekPosCalculatorEntitySurface::ComputeEntitySeekPos(
            &this->m_entitySeekPosCalculator,
            pPed,
            this->m_pEntity,
            (CVector *)&vSeekPos);
          p_tx = (CSimpleTransform *)&m_pMat->tx;
          if ( !m_pMat )
            p_tx = &pPed->m_transform;
          v11.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.x, (float32x2_t)vSeekPos.CTaskSimple).n64_u64[0];
          v12 = vmul_f32(v11, v11).n64_u64[0];
          v13 = (float)(*(float *)&v12 + *((float *)&v12 + 1)) + 0.0;
          if ( v13 <= (float)(this->m_fTargetRadius * this->m_fTargetRadius) )
          {
            v18 = *((_BYTE *)this + 72);
            *((_BYTE *)this + 72) = v18 | 4;
            v15 = 920;
            if ( (v18 & 2) == 0 )
              v15 = 1302;
          }
          else
          {
            m_fGoToPointDistance = this->m_fGoToPointDistance;
            if ( m_fGoToPointDistance == 0.0 )
            {
              v15 = 906;
            }
            else if ( v13 <= (float)(m_fGoToPointDistance * m_fGoToPointDistance) )
            {
              v15 = 903;
            }
            else
            {
              v15 = 906;
            }
          }
          return CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface>::CreateSubTask(this, v15, pPed);
        }
        return v5;
      }
    }
    else
    {
      if ( v4 != 203 )
      {
        if ( v4 == 219 )
        {
          v5 = 0;
          CTaskSimpleStandStill::CTaskSimpleStandStill(&vSeekPos, -1, 0, 0, 8.0);
          CTaskSimpleStandStill::ProcessPed(v17, pPed);
          CTaskSimpleStandStill::~CTaskSimpleStandStill(&vSeekPos);
        }
        else if ( v4 == 704 )
        {
          v5 = 0;
          if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
          {
            v6 = (CTaskSimpleCarDrive *)CTask::operator new(0x70u);
            CTaskSimpleCarDrive::CTaskSimpleCarDrive(v6, pPed->m_pMyVehicle, 0, 0);
            *(_DWORD *)(v7 + 96) = 2000;
            *(_WORD *)(v7 + 108) = 0;
            *(_DWORD *)(v7 + 100) = 0;
            *(_DWORD *)(v7 + 104) = 0;
            v5 = (CTaskSimpleStandStill *)v7;
            *(_DWORD *)v7 = &off_66571C;
          }
        }
        return v5;
      }
      if ( pPed->m_pAttachToEntity )
      {
        v5 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
        CTaskSimpleStandStill::CTaskSimpleStandStill(v5, 2000, 0, 0, 8.0);
        return v5;
      }
    }
    return (CTask *)(*((int (__fastcall **)(CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface> *, CPed *))this->_vptr$CTask
                     + 11))(
                      this,
                      pPed);
  }
  return 0;
}
// 49A9F2: variable 'v7' is possibly undefined
// 49AAE6: variable 'v17' is possibly undefined
// 66571C: using guessed type void *off_66571C;

//----- (0049AB30) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface>::CreateFirstSubTask(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface> *this,
        CPed *pPed)
{
  __int64 v4; // kr00_8
  int v5; // r1
  CEntity *m_pEntity; // r2
  bool v7; // zf
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float32x2_t v10; // d16
  unsigned __int64 v11; // d0
  float v12; // s0
  int v13; // r1
  CTaskSimpleTired *v14; // r0
  float m_fGoToPointDistance; // s2
  CTaskComplexLeaveCar *v16; // r0
  CTask *result; // r0
  CVector vSeekPos; // [sp+8h] [bp-18h] BYREF

  v4 = *(_QWORD *)&this->m_iMaxSeekTime;
  v5 = CTimer::m_snTimeInMilliseconds;
  this->m_scanTimer.m_bIsActive = 1;
  this->m_scanTimer.m_iStartTime = v5;
  this->m_scanTimer.m_iDuration = HIDWORD(v4);
  if ( (_DWORD)v4 != -1 )
  {
    this->m_seekTimer.m_bIsActive = 1;
    this->m_seekTimer.m_iStartTime = v5;
    this->m_seekTimer.m_iDuration = v4;
  }
  m_pEntity = this->m_pEntity;
  if ( m_pEntity )
  {
    v7 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
    if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
      v7 = pPed->m_pMyVehicle == 0;
    if ( v7 )
    {
      CEntitySeekPosCalculatorEntitySurface::ComputeEntitySeekPos(
        &this->m_entitySeekPosCalculator,
        pPed,
        m_pEntity,
        &vSeekPos);
      m_pMat = pPed->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      v10.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.x, *(float32x2_t *)&vSeekPos.x).n64_u64[0];
      v11 = vmul_f32(v10, v10).n64_u64[0];
      v12 = (float)(*(float *)&v11 + *((float *)&v11 + 1)) + 0.0;
      if ( v12 >= (float)(this->m_fTargetRadius * this->m_fTargetRadius) )
      {
        m_fGoToPointDistance = this->m_fGoToPointDistance;
        if ( m_fGoToPointDistance == 0.0 )
        {
          v13 = 906;
        }
        else
        {
          v13 = 903;
          if ( v12 > (float)(m_fGoToPointDistance * m_fGoToPointDistance) )
            v13 = 906;
        }
      }
      else
      {
        *((_BYTE *)this + 72) |= 4u;
        CPed::SetMoveState(pPed, PEDMOVE_STILL);
        v13 = 244;
      }
      return CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface>::CreateSubTask(this, v13, pPed);
    }
    else
    {
      v16 = (CTaskComplexLeaveCar *)CTask::operator new(0x34u);
      CTaskComplexLeaveCar::CTaskComplexLeaveCar(v16, pPed->m_pMyVehicle, 0, 0, 1, 0);
    }
  }
  else
  {
    v14 = (CTaskSimpleTired *)CTask::operator new(0x1Cu);
    CTaskSimpleTired::CTaskSimpleTired(v14, 1000);
  }
  return result;
}

//----- (0049AC3C) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface>::ControlSubTask(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface> *this,
        CPed *pPed)
{
  CEntity *m_pEntity; // r4
  CTaskSimpleStandStill *m_pSubTask; // r6
  RwReal y; // r8
  CPhysical *m_pGroundPhysical; // r0
  bool v8; // zf
  CPhysical *v9; // r0
  bool v10; // zf
  CEntity *m_pAttachToEntity; // r0
  CMatrix *m_pMat; // r0
  float *v13; // r4
  int v14; // r1
  CSimpleTransform *p_tx; // r2
  float *v16; // r0
  float v17; // s2
  float z; // s4
  float x; // s16
  RwReal v20; // s18
  RwReal v21; // s20
  float *v22; // r1
  float v23; // s4
  float v24; // s6
  int v25; // r0
  float v26; // s18
  float v27; // s20
  float v28; // s16
  int v29; // r0
  float RadianAngleBetweenPoints; // r0
  float v31; // r0
  CEntity *v32; // r2
  unsigned int v33; // r0
  int m_iStartTime; // r1
  __int64 v35; // r0
  CMatrix *v36; // r0
  CSimpleTransform *p_m_transform; // r1
  float v38; // s16
  float m_fGoToPointDistance; // s0
  int m_iMoveState; // r4
  CTask *v41; // r0
  char m_pParent; // r1
  float v43; // s0
  int v44; // r4
  float m_fTargetRadius; // r2
  float m_fSlowDownDistance; // s0
  CTask v47; // d16
  CEntity *v48; // r0
  CPlayerPed *PlayerPed; // r0
  CVector v51; // [sp+14h] [bp-BCh] BYREF
  CMatrix output; // [sp+20h] [bp-B0h] BYREF
  CVector pCoors; // [sp+68h] [bp-68h] BYREF
  CVector v54; // [sp+78h] [bp-58h] BYREF
  CVector v; // [sp+88h] [bp-48h] BYREF

  m_pEntity = this->m_pEntity;
  m_pSubTask = (CTaskSimpleStandStill *)this->m_pSubTask;
  if ( m_pEntity && (*(_BYTE *)&m_pEntity->m_info & 7) == 3 && CPedGroups::AreInSameGroup(pPed, (const CPed *)m_pEntity) )
  {
    if ( BYTE1(m_pEntity[1].m_transform.m_translate.y) << 31 )
      goto LABEL_15;
    y = m_pEntity[23].m_transform.m_translate.y;
    if ( y != 0.0 && (*(_BYTE *)(LODWORD(y) + 58) & 7) == 2 )
    {
      m_pGroundPhysical = pPed->m_pGroundPhysical;
      v8 = m_pGroundPhysical == (CPhysical *)LODWORD(y);
      if ( m_pGroundPhysical != (CPhysical *)LODWORD(y) )
        v8 = pPed->m_pEntityStandingOn == (CEntity *)LODWORD(y);
      if ( v8 )
        goto LABEL_67;
    }
    y = *(float *)&m_pEntity[23].RandomSeed;
    if ( y == 0.0 || (*(_BYTE *)(LODWORD(y) + 58) & 7) != 2 )
      goto LABEL_15;
    v9 = pPed->m_pGroundPhysical;
    v10 = v9 == (CPhysical *)LODWORD(y);
    if ( v9 != (CPhysical *)LODWORD(y) )
      v10 = pPed->m_pEntityStandingOn == (CEntity *)LODWORD(y);
    if ( v10 )
    {
LABEL_67:
      if ( *(_DWORD *)(LODWORD(y) + 1440) != 5 )
        y = 0.0;
    }
    else
    {
LABEL_15:
      y = 0.0;
    }
    m_pAttachToEntity = pPed->m_pAttachToEntity;
    if ( y == 0.0 && m_pAttachToEntity )
    {
      CPed::DettachPedFromEntity(pPed);
    }
    else if ( y != 0.0
           && !m_pAttachToEntity
           && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 203
           && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
                this->m_pSubTask,
                pPed,
                1,
                0) == 1 )
    {
      m_pMat = pPed->m_pMat;
      v13 = (float *)(LODWORD(y) + 4);
      v14 = *(int *)((char *)&dword_14 + LODWORD(y));
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      v16 = (float *)(LODWORD(y) + 4);
      v17 = p_tx->m_translate.y;
      z = p_tx->m_translate.z;
      if ( v14 )
        v16 = (float *)(v14 + 48);
      v.x = *v16 - p_tx->m_translate.x;
      x = v.x;
      v.y = v16[1] - v17;
      v20 = v.y;
      v21 = v16[2] - z;
      v.z = v21;
      v54.z = v21;
      *(_QWORD *)&v54.x = *(_QWORD *)&v.x;
      CVector::Normalise(&v54);
      v22 = (float *)(LODWORD(y) + 4);
      v23 = v20 - (float)(v54.y * 0.25);
      v24 = v21 - (float)(v54.z * 0.25);
      v.y = v23;
      v.z = v24;
      v25 = *(int *)((char *)&dword_14 + LODWORD(y));
      if ( v25 )
        v22 = (float *)(v25 + 48);
      v26 = *v22 - (float)(x - (float)(v54.x * 0.25));
      v.x = v26;
      v27 = v22[1] - v23;
      v.y = v27;
      v28 = v22[2] - v24;
      v.z = v28;
      pCoors.z = v28;
      *(_QWORD *)&pCoors.x = *(_QWORD *)&v.x;
      if ( CPedPlacement::FindZCoorForPed(&pCoors) )
      {
        v = pCoors;
        v28 = pCoors.z;
        v27 = pCoors.y;
        v26 = pCoors.x;
      }
      v29 = *(int *)((char *)&dword_14 + LODWORD(y));
      if ( v29 )
        v13 = (float *)(v29 + 48);
      v.x = v26 - *v13;
      v.y = v27 - v13[1];
      v.z = v28 - v13[2];
      output.m_pRwMat = 0;
      output.m_owner = 0;
      Invert(*(const CMatrix **)((char *)&dword_14 + LODWORD(y)), &output);
      CVector::FromMultiply3X3(&v51, &output, &v);
      RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(v54.x, v54.y, 0.0, 0.0);
      v31 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
      CPed::AttachPedToEntity(
        pPed,
        (CEntity *)LODWORD(y),
        v51,
        (unsigned int)v31,
        0.2,
        pPed->m_WeaponSlots[pPed->m_nCurrentWeapon].m_eWeaponType);
      m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(m_pSubTask, 2000, 0, 0, 8.0);
      CMatrix::~CMatrix(&output);
      return m_pSubTask;
    }
  }
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 906
    || (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 903 )
  {
    v32 = this->m_pEntity;
    if ( v32 )
    {
      if ( this->m_seekTimer.m_bIsActive
        && (!this->m_seekTimer.m_bIsStopped ? (m_iStartTime = this->m_seekTimer.m_iStartTime,
                                               v33 = CTimer::m_snTimeInMilliseconds) : (v33 = CTimer::m_snTimeInMilliseconds,
                                                                                        this->m_seekTimer.m_bIsStopped = 0,
                                                                                        this->m_seekTimer.m_iStartTime = v33,
                                                                                        m_iStartTime = v33),
            m_iStartTime + this->m_seekTimer.m_iDuration <= v33) )
      {
        if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
               this->m_pSubTask,
               pPed,
               1,
               0) == 1 )
        {
          if ( *((unsigned __int8 *)this + 72) << 31 )
          {
            m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x1Cu);
            CTaskSimpleTired::CTaskSimpleTired((CTaskSimpleTired *)m_pSubTask, 1000);
          }
          else
          {
            m_pSubTask = 0;
          }
        }
      }
      else if ( this->m_scanTimer.m_bIsActive )
      {
        if ( this->m_scanTimer.m_bIsStopped )
        {
          LODWORD(v35) = CTimer::m_snTimeInMilliseconds;
          this->m_scanTimer.m_bIsStopped = 0;
          this->m_scanTimer.m_iStartTime = v35;
          HIDWORD(v35) = v35;
        }
        else
        {
          HIDWORD(v35) = this->m_scanTimer.m_iStartTime;
          LODWORD(v35) = CTimer::m_snTimeInMilliseconds;
        }
        if ( HIDWORD(v35) + this->m_scanTimer.m_iDuration <= (unsigned int)v35 )
        {
          HIDWORD(v35) = this->m_iPeriod;
          this->m_scanTimer.m_bIsActive = 1;
          *(_QWORD *)&this->m_scanTimer.m_iStartTime = v35;
          CEntitySeekPosCalculatorEntitySurface::ComputeEntitySeekPos(&this->m_entitySeekPosCalculator, pPed, v32, &v);
          v36 = pPed->m_pMat;
          p_m_transform = (CSimpleTransform *)&v36->tx;
          if ( !v36 )
            p_m_transform = &pPed->m_transform;
          v38 = (float)((float)((float)(p_m_transform->m_translate.x - v.x) * (float)(p_m_transform->m_translate.x - v.x))
                      + (float)((float)(p_m_transform->m_translate.y - v.y) * (float)(p_m_transform->m_translate.y - v.y)))
              + 0.0;
          if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 906 )
          {
            m_fGoToPointDistance = this->m_fGoToPointDistance;
            if ( m_fGoToPointDistance == 0.0
              || v38 >= (float)((float)(m_fGoToPointDistance + -1.0) * (float)(m_fGoToPointDistance + -1.0)) )
            {
              CTaskComplexFollowNodeRoute::SetTarget(
                (CTaskComplexFollowNodeRoute *)this->m_pSubTask,
                pPed,
                &v,
                this->m_fTargetRadius,
                this->m_fSlowDownDistance,
                this->m_fFollowNodeThresholdHeightChange,
                0);
            }
            else if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask
                       + 7))(
                        this->m_pSubTask,
                        pPed,
                        1,
                        0) == 1 )
            {
              m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x28u);
              m_iMoveState = this->m_iMoveState;
              CEntitySeekPosCalculatorEntitySurface::ComputeEntitySeekPos(
                &this->m_entitySeekPosCalculator,
                pPed,
                this->m_pEntity,
                (CVector *)&output);
              CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(
                (CTaskComplexGoToPointAndStandStill *)m_pSubTask,
                m_iMoveState,
                (const CVector *)&output,
                this->m_fTargetRadius,
                this->m_fSlowDownDistance,
                0,
                0);
              LOBYTE(m_pSubTask[1].m_pParent) = *((_BYTE *)this + 72) & 8 | (int)m_pSubTask[1].m_pParent & 0xF7;
              return m_pSubTask;
            }
          }
          else
          {
            v41 = this->m_pSubTask;
            m_pParent = (char)v41[4].m_pParent;
            if ( (m_pParent & 0x10) == 0 )
            {
              v43 = this->m_fGoToPointDistance;
              if ( v43 == 0.0 || v38 <= (float)((float)(v43 + 1.0) * (float)(v43 + 1.0)) )
              {
                m_fTargetRadius = this->m_fTargetRadius;
                m_fSlowDownDistance = this->m_fSlowDownDistance;
                if ( *(float *)&v41[2]._vptr$CTask != v.x
                  || *(float *)&v41[2].m_pParent != v.y
                  || *(float *)&v41[3]._vptr$CTask != v.z
                  || *(float *)&v41[4]._vptr$CTask != m_fSlowDownDistance )
                {
                  v47 = *(CTask *)&v.x;
                  v41[3]._vptr$CTask = (int (**)(void))LODWORD(v.z);
                  *(float *)&v41[3].m_pParent = m_fTargetRadius;
                  *(float *)&v41[4]._vptr$CTask = m_fSlowDownDistance;
                  LOBYTE(v41[4].m_pParent) = m_pParent | 4;
                  v41[2] = v47;
                }
              }
              else if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))v41->_vptr$CTask + 7))(v41, pPed, 1, 0) == 1 )
              {
                m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x60u);
                v44 = this->m_iMoveState;
                CEntitySeekPosCalculatorEntitySurface::ComputeEntitySeekPos(
                  &this->m_entitySeekPosCalculator,
                  pPed,
                  this->m_pEntity,
                  (CVector *)&output);
                CTaskComplexFollowNodeRoute::CTaskComplexFollowNodeRoute(
                  (CTaskComplexFollowNodeRoute *)m_pSubTask,
                  v44,
                  (const CVector *)&output,
                  this->m_fTargetRadius,
                  this->m_fSlowDownDistance,
                  this->m_fFollowNodeThresholdHeightChange,
                  0,
                  -1,
                  1);
                return m_pSubTask;
              }
            }
          }
          m_pSubTask = (CTaskSimpleStandStill *)this->m_pSubTask;
        }
      }
    }
    else if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
                this->m_pSubTask,
                pPed,
                1,
                0) )
    {
      m_pSubTask = 0;
    }
  }
  v48 = this->m_pEntity;
  if ( v48 )
  {
    if ( (*(_BYTE *)&v48->m_info & 7) == 3 && CPed::IsPlayer((const CPed *)v48) )
    {
      PlayerPed = FindPlayerPed(-1);
      if ( CPedGroupMembership::IsMember(
             &CPedGroups::ms_groups[PlayerPed->m_pPlayerData->m_PlayerGroup].m_membership,
             pPed)
        && (unsigned int)(pPed->m_eMoveState - 5) <= 2
        && !((CTimer::m_FrameCounter + pPed->RandomSeed) << 18) )
      {
        CPed::Say(pPed, 0x5Bu, 0, 1.0, 0, 0, 0);
      }
    }
  }
  return m_pSubTask;
}
// 14: using guessed type int dword_14;

//----- (0049B24C) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface>::CreateSubTask(
        const CTaskComplexSeekEntity<CEntitySeekPosCalculatorEntitySurface> *this,
        const int iSubTaskType,
        CPed *pPed)
{
  CTaskComplexFollowNodeRoute *v5; // r4
  int v6; // r8
  CTaskComplexTurnToFaceEntityOrCoord *v7; // r6
  CTaskSimpleStandStill *v8; // r5
  int m_iMoveState; // r8
  CVector vSeekPos; // [sp+14h] [bp-24h] BYREF

  v5 = 0;
  if ( iSubTaskType > 718 )
  {
    if ( iSubTaskType > 905 )
    {
      if ( iSubTaskType == 906 )
      {
        v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x60u);
        m_iMoveState = this->m_iMoveState;
        CEntitySeekPosCalculatorEntitySurface::ComputeEntitySeekPos(
          &this->m_entitySeekPosCalculator,
          pPed,
          this->m_pEntity,
          &vSeekPos);
        CTaskComplexFollowNodeRoute::CTaskComplexFollowNodeRoute(
          v5,
          m_iMoveState,
          &vSeekPos,
          this->m_fTargetRadius,
          this->m_fSlowDownDistance,
          this->m_fFollowNodeThresholdHeightChange,
          0,
          -1,
          1);
      }
      else if ( iSubTaskType == 920 )
      {
        v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x28u);
        CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(
          (CTaskComplexTurnToFaceEntityOrCoord *)v5,
          this->m_pEntity,
          0.5,
          0.2);
      }
    }
    else if ( iSubTaskType == 719 )
    {
      v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x70u);
      CTaskSimpleCarDrive::CTaskSimpleCarDrive((CTaskSimpleCarDrive *)v5, pPed->m_pMyVehicle, 0, 0);
      v5[1]._vptr$CTask = (int (**)(void))(elf_hash_bucket + 1748);
      LOWORD(v5[1].m_vTarget.x) = 0;
      v5[1].m_pParent = 0;
      v5[1].m_pSubTask = 0;
      v5->_vptr$CTask = (int (**)(void))&off_66571C;
    }
    else if ( iSubTaskType == 903 )
    {
      v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x28u);
      v6 = this->m_iMoveState;
      CEntitySeekPosCalculatorEntitySurface::ComputeEntitySeekPos(
        &this->m_entitySeekPosCalculator,
        pPed,
        this->m_pEntity,
        &vSeekPos);
      CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(
        (CTaskComplexGoToPointAndStandStill *)v5,
        v6,
        &vSeekPos,
        this->m_fTargetRadius,
        this->m_fSlowDownDistance,
        0,
        0);
      LOBYTE(v5->m_fFollowNodeThresholdHeightChange) = *((_BYTE *)this + 72) & 8 | LOBYTE(v5->m_fFollowNodeThresholdHeightChange) & 0xF7;
    }
  }
  else if ( iSubTaskType > 243 )
  {
    if ( iSubTaskType == 244 )
    {
      v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x40u);
      CTaskComplexSequence::CTaskComplexSequence((CTaskComplexSequence *)v5);
      if ( (*((_BYTE *)this + 72) & 2) != 0 )
      {
        v7 = (CTaskComplexTurnToFaceEntityOrCoord *)CTask::operator new(0x28u);
        CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(v7, this->m_pEntity, 0.5, 0.2);
        CTaskComplexSequence::AddTask((CTaskComplexSequence *)v5, v7);
      }
      v8 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(v8, 100, 0, 0, 8.0);
      CTaskComplexSequence::AddTask((CTaskComplexSequence *)v5, v8);
    }
    else if ( iSubTaskType == 704 )
    {
      v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x34u);
      CTaskComplexLeaveCar::CTaskComplexLeaveCar((CTaskComplexLeaveCar *)v5, pPed->m_pMyVehicle, 0, 0, 1, 0);
    }
  }
  else if ( iSubTaskType == 203 )
  {
    v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v5, 2000, 0, 0, 8.0);
  }
  else if ( iSubTaskType == 219 )
  {
    v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x1Cu);
    CTaskSimpleTired::CTaskSimpleTired((CTaskSimpleTired *)v5, 1000);
  }
  return v5;
}
// FC: using guessed type int elf_hash_bucket[16411];
// 66571C: using guessed type void *off_66571C;

//----- (0049B460) --------------------------------------------------------
void __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId>::~CTaskComplexSeekEntity(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId> *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CTask = (int (**)(void))&off_6689E0;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  sub_18EDB4(this);
}
// 6689E0: using guessed type void *;

//----- (0049B48C) --------------------------------------------------------
void __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId>::~CTaskComplexSeekEntity(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId> *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1
  void *v4; // r0

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CTask = (int (**)(void))&off_6689E0;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 49B4B4: variable 'v4' is possibly undefined
// 6689E0: using guessed type void *off_6689E0;

//----- (0049B4BC) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId>::Clone(
        const CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId> *this)
{
  void *v2; // r5
  __int64 v3; // d8
  __int64 v4; // d9
  CEntity *m_pEntity; // r6
  float m_fFollowNodeThresholdHeightChange; // r8
  char v7; // r9
  char v8; // r3
  char v9; // r0

  v2 = CTask::operator new(0x50u);
  v3 = *(_QWORD *)&this->m_iMaxSeekTime;
  v4 = *(_QWORD *)&this->m_fTargetRadius;
  m_pEntity = this->m_pEntity;
  m_fFollowNodeThresholdHeightChange = this->m_fFollowNodeThresholdHeightChange;
  v7 = *((_BYTE *)this + 76);
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_QWORD *)v2 + 2) = v3;
  *((_QWORD *)v2 + 3) = v4;
  *((_DWORD *)v2 + 8) = 0;
  *((float *)v2 + 9) = m_fFollowNodeThresholdHeightChange;
  *((_WORD *)v2 + 24) = 0;
  *((_WORD *)v2 + 30) = 0;
  *((_DWORD *)v2 + 10) = 0;
  *((_DWORD *)v2 + 11) = 0;
  *((_DWORD *)v2 + 13) = 0;
  *((_DWORD *)v2 + 14) = 0;
  v8 = *((_BYTE *)v2 + 76);
  *(_DWORD *)v2 = &off_6689E0;
  *((_DWORD *)v2 + 16) = &off_66D3E4;
  *((_DWORD *)v2 + 17) = 0;
  *((_DWORD *)v2 + 18) = 6;
  v9 = v7 & 1 | v8 & 0xF0 | 2;
  *((_BYTE *)v2 + 76) = v9;
  *((_DWORD *)v2 + 3) = m_pEntity;
  if ( m_pEntity )
  {
    CEntity::RegisterReference(m_pEntity, (CEntity **)v2 + 3);
    v9 = *((_BYTE *)v2 + 76);
  }
  *((_DWORD *)v2 + 17) = this->m_entitySeekPosCalculator.m_posId;
  *((_DWORD *)v2 + 18) = this->m_iMoveState;
  *((_BYTE *)v2 + 76) = v9 & 0xF7 | *((_BYTE *)this + 76) & 8;
  *((_DWORD *)v2 + 8) = LODWORD(this->m_fGoToPointDistance);
  *((_DWORD *)v2 + 18) = this->m_iMoveState;
  return (CTask *)v2;
}
// 6689E0: using guessed type void *off_6689E0;
// 66D3E4: using guessed type void *;

//----- (0049B588) --------------------------------------------------------
int __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId>::GetTaskType(
        const CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId> *this)
{
  return 907;
}

//----- (0049B590) --------------------------------------------------------
bool __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId>::MakeAbortable(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId> *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  int v5; // lr
  int v6; // r0
  int v7; // r1

  if ( !iPriority )
  {
    this->m_iMaxSeekTime = -1;
    v5 = CTimer::m_snTimeInMilliseconds;
    this->m_seekTimer.m_bIsActive = 1;
    this->m_seekTimer.m_iStartTime = v5;
    this->m_seekTimer.m_iDuration = -1;
  }
  v6 = (*((int (__fastcall **)(CTask *, CPed *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
         this->m_pSubTask,
         pPed);
  if ( v6 == 1 )
  {
    v7 = CTimer::m_snTimeInMilliseconds;
    this->m_scanTimer.m_bIsActive = 1;
    this->m_scanTimer.m_iStartTime = v7;
    this->m_scanTimer.m_iDuration = 0;
  }
  return v6;
}

//----- (0049B5E0) --------------------------------------------------------
void __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId>::Serialize(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId> *this)
{
  bool v2; // r6
  __int16 v3; // r2
  __int16 v4; // r4
  _WORD *v5; // r5
  _DWORD *v6; // r5
  int v7; // r8
  bool v8; // r5
  __int16 v9; // r2
  __int16 v10; // r4
  _WORD *v11; // r6
  _DWORD *v12; // r6
  CEntity *m_pEntity; // r0
  int v14; // r8
  bool v15; // r6
  __int16 v16; // r2
  __int16 v17; // r4
  _WORD *v18; // r5
  _DWORD *v19; // r5
  CEntity *v20; // r0
  int v21; // r1
  int32 VehicleRef; // r8
  int v23; // r0
  bool v24; // r5
  __int16 v25; // r2
  __int16 v26; // r6
  _WORD *v27; // r4
  _DWORD *v28; // r4
  bool v29; // r6
  __int16 v30; // r2
  __int16 v31; // r4
  _WORD *v32; // r5
  bool v33; // r6
  __int16 v34; // r2
  __int16 v35; // r4
  _WORD *v36; // r5
  bool v37; // r6
  __int16 v38; // r2
  __int16 v39; // r4
  _WORD *v40; // r5
  _DWORD *v41; // r5
  unsigned __int8 s[128]; // [sp+4h] [bp-9Ch] BYREF

  v2 = UseDataFence;
  if ( UseDataFence )
  {
    v3 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v4 = v3 + DataFence;
    v5 = malloc(2u);
    *v5 = v4;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 2);
    free(v5);
    UseDataFence = v2;
  }
  v6 = malloc(4u);
  *v6 = 5;
  CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
  free(v6);
  v7 = (*((int (__fastcall **)(CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId> *))this->_vptr$CTask + 5))(this);
  v8 = UseDataFence;
  if ( UseDataFence )
  {
    v9 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v10 = v9 + DataFence;
    v11 = malloc(2u);
    *v11 = v10;
    CGenericGameStorage::_SaveDataToWorkBuffer(v11, 2);
    free(v11);
    UseDataFence = v8;
  }
  v12 = malloc(4u);
  *v12 = v7;
  CGenericGameStorage::_SaveDataToWorkBuffer(v12, 4);
  free(v12);
  if ( (*((int (__fastcall **)(CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId> *))this->_vptr$CTask + 5))(this) == 907 )
  {
    m_pEntity = this->m_pEntity;
    if ( m_pEntity )
    {
      v14 = *(_BYTE *)&m_pEntity->m_info & 7;
      v15 = UseDataFence;
      if ( UseDataFence )
      {
        v16 = currentSaveFenceCount;
        UseDataFence = 0;
        ++currentSaveFenceCount;
        v17 = v16 + DataFence;
        v18 = malloc(2u);
        *v18 = v17;
        CGenericGameStorage::_SaveDataToWorkBuffer(v18, 2);
        free(v18);
        UseDataFence = v15;
      }
      v19 = malloc(4u);
      *v19 = v14;
      CGenericGameStorage::_SaveDataToWorkBuffer(v19, 4);
      free(v19);
      v20 = this->m_pEntity;
      v21 = *(_BYTE *)&v20->m_info & 7;
      switch ( v21 )
      {
        case 2:
          if ( v20 )
            VehicleRef = CPools::GetVehicleRef((CVehicle *)v20);
          else
            VehicleRef = -1;
          v29 = UseDataFence;
          if ( UseDataFence )
          {
            v30 = currentSaveFenceCount;
            UseDataFence = 0;
            ++currentSaveFenceCount;
            v31 = v30 + DataFence;
            v32 = malloc(2u);
            *v32 = v31;
            CGenericGameStorage::_SaveDataToWorkBuffer(v32, 2);
            free(v32);
            UseDataFence = v29;
          }
          goto LABEL_34;
        case 4:
          if ( v20 )
            VehicleRef = CPools::GetObjectRef((CObject *)v20);
          else
            VehicleRef = -1;
          v33 = UseDataFence;
          if ( UseDataFence )
          {
            v34 = currentSaveFenceCount;
            UseDataFence = 0;
            ++currentSaveFenceCount;
            v35 = v34 + DataFence;
            v36 = malloc(2u);
            *v36 = v35;
            CGenericGameStorage::_SaveDataToWorkBuffer(v36, 2);
            free(v36);
            UseDataFence = v33;
          }
          goto LABEL_34;
        case 3:
          if ( v20 )
            VehicleRef = CPools::GetPedRef((CPed *)v20);
          else
            VehicleRef = -1;
          v37 = UseDataFence;
          if ( UseDataFence )
          {
            v38 = currentSaveFenceCount;
            UseDataFence = 0;
            ++currentSaveFenceCount;
            v39 = v38 + DataFence;
            v40 = malloc(2u);
            *v40 = v39;
            CGenericGameStorage::_SaveDataToWorkBuffer(v40, 2);
            free(v40);
            UseDataFence = v37;
          }
LABEL_34:
          v41 = malloc(4u);
          *v41 = VehicleRef;
          CGenericGameStorage::_SaveDataToWorkBuffer(v41, 4);
          j_free(v41);
          break;
      }
    }
    else
    {
      v24 = UseDataFence;
      if ( UseDataFence )
      {
        v25 = currentSaveFenceCount;
        UseDataFence = 0;
        ++currentSaveFenceCount;
        v26 = v25 + DataFence;
        v27 = malloc(2u);
        *v27 = v26;
        CGenericGameStorage::_SaveDataToWorkBuffer(v27, 2);
        free(v27);
        UseDataFence = v24;
      }
      v28 = malloc(4u);
      *v28 = 0;
      CGenericGameStorage::_SaveDataToWorkBuffer(v28, 4);
      j_free(v28);
    }
  }
  else
  {
    v23 = (*((int (__fastcall **)(CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId> *))this->_vptr$CTask + 5))(this);
    sprintf(s, "ERROR - class %d is not type %d serialize is not this class expected", v23, 907);
  }
}
// 49B5E0: using guessed type unsigned __int8 s[128];

//----- (0049B9FC) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId>::CreateNextSubTask(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId> *this,
        CPed *pPed)
{
  int v4; // r0
  CTaskSimpleStandStill *v5; // r6
  CTaskSimpleCarDrive *v6; // r0
  int v7; // r0
  bool v8; // zf
  CMatrix *m_pMat; // r6
  CSimpleTransform *p_tx; // r0
  float32x2_t v11; // d16
  unsigned __int64 v12; // d0
  float v13; // s0
  float m_fGoToPointDistance; // s2
  int v15; // r1
  CTaskSimpleStandStill *v17; // r0
  char v18; // r0
  CTaskSimpleStandStill vSeekPos; // [sp+8h] [bp-30h] BYREF

  if ( this->m_pEntity )
  {
    v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
    v5 = 0;
    if ( v4 > 718 )
    {
      if ( v4 != 719 )
      {
        v8 = v4 == 903;
        if ( v4 != 903 )
          v8 = v4 == 906;
        if ( v8 )
        {
          m_pMat = pPed->m_pMat;
          CEntitySeekPosCalculatorVehicleId::ComputeEntitySeekPos(
            &this->m_entitySeekPosCalculator,
            pPed,
            this->m_pEntity,
            (CVector *)&vSeekPos);
          p_tx = (CSimpleTransform *)&m_pMat->tx;
          if ( !m_pMat )
            p_tx = &pPed->m_transform;
          v11.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.x, (float32x2_t)vSeekPos.CTaskSimple).n64_u64[0];
          v12 = vmul_f32(v11, v11).n64_u64[0];
          v13 = (float)(*(float *)&v12 + *((float *)&v12 + 1)) + 0.0;
          if ( v13 <= (float)(this->m_fTargetRadius * this->m_fTargetRadius) )
          {
            v18 = *((_BYTE *)this + 76);
            *((_BYTE *)this + 76) = v18 | 4;
            v15 = 920;
            if ( (v18 & 2) == 0 )
              v15 = 1302;
          }
          else
          {
            m_fGoToPointDistance = this->m_fGoToPointDistance;
            if ( m_fGoToPointDistance == 0.0 )
            {
              v15 = 906;
            }
            else if ( v13 <= (float)(m_fGoToPointDistance * m_fGoToPointDistance) )
            {
              v15 = 903;
            }
            else
            {
              v15 = 906;
            }
          }
          return CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId>::CreateSubTask(this, v15, pPed);
        }
        return v5;
      }
    }
    else
    {
      if ( v4 != 203 )
      {
        if ( v4 == 219 )
        {
          v5 = 0;
          CTaskSimpleStandStill::CTaskSimpleStandStill(&vSeekPos, -1, 0, 0, 8.0);
          CTaskSimpleStandStill::ProcessPed(v17, pPed);
          CTaskSimpleStandStill::~CTaskSimpleStandStill(&vSeekPos);
        }
        else if ( v4 == 704 )
        {
          v5 = 0;
          if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
          {
            v6 = (CTaskSimpleCarDrive *)CTask::operator new(0x70u);
            CTaskSimpleCarDrive::CTaskSimpleCarDrive(v6, pPed->m_pMyVehicle, 0, 0);
            *(_DWORD *)(v7 + 96) = 2000;
            *(_WORD *)(v7 + 108) = 0;
            *(_DWORD *)(v7 + 100) = 0;
            *(_DWORD *)(v7 + 104) = 0;
            v5 = (CTaskSimpleStandStill *)v7;
            *(_DWORD *)v7 = &off_66571C;
          }
        }
        return v5;
      }
      if ( pPed->m_pAttachToEntity )
      {
        v5 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
        CTaskSimpleStandStill::CTaskSimpleStandStill(v5, 2000, 0, 0, 8.0);
        return v5;
      }
    }
    return (CTask *)(*((int (__fastcall **)(CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId> *, CPed *))this->_vptr$CTask
                     + 11))(
                      this,
                      pPed);
  }
  return 0;
}
// 49BA56: variable 'v7' is possibly undefined
// 49BB4A: variable 'v17' is possibly undefined
// 66571C: using guessed type void *off_66571C;

//----- (0049BB94) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId>::CreateFirstSubTask(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId> *this,
        CPed *pPed)
{
  __int64 v4; // kr00_8
  int v5; // r1
  CEntity *m_pEntity; // r2
  bool v7; // zf
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float32x2_t v10; // d16
  unsigned __int64 v11; // d0
  float v12; // s0
  int v13; // r1
  CTaskSimpleTired *v14; // r0
  float m_fGoToPointDistance; // s2
  CTaskComplexLeaveCar *v16; // r0
  CTask *result; // r0
  CVector vSeekPos; // [sp+8h] [bp-18h] BYREF

  v4 = *(_QWORD *)&this->m_iMaxSeekTime;
  v5 = CTimer::m_snTimeInMilliseconds;
  this->m_scanTimer.m_bIsActive = 1;
  this->m_scanTimer.m_iStartTime = v5;
  this->m_scanTimer.m_iDuration = HIDWORD(v4);
  if ( (_DWORD)v4 != -1 )
  {
    this->m_seekTimer.m_bIsActive = 1;
    this->m_seekTimer.m_iStartTime = v5;
    this->m_seekTimer.m_iDuration = v4;
  }
  m_pEntity = this->m_pEntity;
  if ( m_pEntity )
  {
    v7 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
    if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
      v7 = pPed->m_pMyVehicle == 0;
    if ( v7 )
    {
      CEntitySeekPosCalculatorVehicleId::ComputeEntitySeekPos(
        &this->m_entitySeekPosCalculator,
        pPed,
        m_pEntity,
        &vSeekPos);
      m_pMat = pPed->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      v10.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.x, *(float32x2_t *)&vSeekPos.x).n64_u64[0];
      v11 = vmul_f32(v10, v10).n64_u64[0];
      v12 = (float)(*(float *)&v11 + *((float *)&v11 + 1)) + 0.0;
      if ( v12 >= (float)(this->m_fTargetRadius * this->m_fTargetRadius) )
      {
        m_fGoToPointDistance = this->m_fGoToPointDistance;
        if ( m_fGoToPointDistance == 0.0 )
        {
          v13 = 906;
        }
        else
        {
          v13 = 903;
          if ( v12 > (float)(m_fGoToPointDistance * m_fGoToPointDistance) )
            v13 = 906;
        }
      }
      else
      {
        *((_BYTE *)this + 76) |= 4u;
        CPed::SetMoveState(pPed, PEDMOVE_STILL);
        v13 = 244;
      }
      return CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId>::CreateSubTask(this, v13, pPed);
    }
    else
    {
      v16 = (CTaskComplexLeaveCar *)CTask::operator new(0x34u);
      CTaskComplexLeaveCar::CTaskComplexLeaveCar(v16, pPed->m_pMyVehicle, 0, 0, 1, 0);
    }
  }
  else
  {
    v14 = (CTaskSimpleTired *)CTask::operator new(0x1Cu);
    CTaskSimpleTired::CTaskSimpleTired(v14, 1000);
  }
  return result;
}

//----- (0049BCA0) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId>::ControlSubTask(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId> *this,
        CPed *pPed)
{
  CEntity *m_pEntity; // r4
  CTaskSimpleStandStill *m_pSubTask; // r6
  RwReal y; // r8
  CPhysical *m_pGroundPhysical; // r0
  bool v8; // zf
  CPhysical *v9; // r0
  bool v10; // zf
  CEntity *m_pAttachToEntity; // r0
  CMatrix *m_pMat; // r0
  float *v13; // r4
  int v14; // r1
  CSimpleTransform *p_tx; // r2
  float *v16; // r0
  float v17; // s2
  float z; // s4
  float x; // s16
  RwReal v20; // s18
  RwReal v21; // s20
  float *v22; // r1
  float v23; // s4
  float v24; // s6
  int v25; // r0
  float v26; // s18
  float v27; // s20
  float v28; // s16
  int v29; // r0
  float RadianAngleBetweenPoints; // r0
  float v31; // r0
  CEntity *v32; // r2
  unsigned int v33; // r0
  int m_iStartTime; // r1
  __int64 v35; // r0
  CMatrix *v36; // r0
  CSimpleTransform *p_m_transform; // r1
  float v38; // s16
  float m_fGoToPointDistance; // s0
  int m_iMoveState; // r4
  CTask *v41; // r0
  char m_pParent; // r1
  float v43; // s0
  int v44; // r4
  float m_fTargetRadius; // r2
  float m_fSlowDownDistance; // s0
  CTask v47; // d16
  CEntity *v48; // r0
  CPlayerPed *PlayerPed; // r0
  CVector v51; // [sp+14h] [bp-BCh] BYREF
  CMatrix output; // [sp+20h] [bp-B0h] BYREF
  CVector pCoors; // [sp+68h] [bp-68h] BYREF
  CVector v54; // [sp+78h] [bp-58h] BYREF
  CVector v; // [sp+88h] [bp-48h] BYREF

  m_pEntity = this->m_pEntity;
  m_pSubTask = (CTaskSimpleStandStill *)this->m_pSubTask;
  if ( m_pEntity && (*(_BYTE *)&m_pEntity->m_info & 7) == 3 && CPedGroups::AreInSameGroup(pPed, (const CPed *)m_pEntity) )
  {
    if ( BYTE1(m_pEntity[1].m_transform.m_translate.y) << 31 )
      goto LABEL_15;
    y = m_pEntity[23].m_transform.m_translate.y;
    if ( y != 0.0 && (*(_BYTE *)(LODWORD(y) + 58) & 7) == 2 )
    {
      m_pGroundPhysical = pPed->m_pGroundPhysical;
      v8 = m_pGroundPhysical == (CPhysical *)LODWORD(y);
      if ( m_pGroundPhysical != (CPhysical *)LODWORD(y) )
        v8 = pPed->m_pEntityStandingOn == (CEntity *)LODWORD(y);
      if ( v8 )
        goto LABEL_67;
    }
    y = *(float *)&m_pEntity[23].RandomSeed;
    if ( y == 0.0 || (*(_BYTE *)(LODWORD(y) + 58) & 7) != 2 )
      goto LABEL_15;
    v9 = pPed->m_pGroundPhysical;
    v10 = v9 == (CPhysical *)LODWORD(y);
    if ( v9 != (CPhysical *)LODWORD(y) )
      v10 = pPed->m_pEntityStandingOn == (CEntity *)LODWORD(y);
    if ( v10 )
    {
LABEL_67:
      if ( *(_DWORD *)(LODWORD(y) + 1440) != 5 )
        y = 0.0;
    }
    else
    {
LABEL_15:
      y = 0.0;
    }
    m_pAttachToEntity = pPed->m_pAttachToEntity;
    if ( y == 0.0 && m_pAttachToEntity )
    {
      CPed::DettachPedFromEntity(pPed);
    }
    else if ( y != 0.0
           && !m_pAttachToEntity
           && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 203
           && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
                this->m_pSubTask,
                pPed,
                1,
                0) == 1 )
    {
      m_pMat = pPed->m_pMat;
      v13 = (float *)(LODWORD(y) + 4);
      v14 = *(int *)((char *)&dword_14 + LODWORD(y));
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      v16 = (float *)(LODWORD(y) + 4);
      v17 = p_tx->m_translate.y;
      z = p_tx->m_translate.z;
      if ( v14 )
        v16 = (float *)(v14 + 48);
      v.x = *v16 - p_tx->m_translate.x;
      x = v.x;
      v.y = v16[1] - v17;
      v20 = v.y;
      v21 = v16[2] - z;
      v.z = v21;
      v54.z = v21;
      *(_QWORD *)&v54.x = *(_QWORD *)&v.x;
      CVector::Normalise(&v54);
      v22 = (float *)(LODWORD(y) + 4);
      v23 = v20 - (float)(v54.y * 0.25);
      v24 = v21 - (float)(v54.z * 0.25);
      v.y = v23;
      v.z = v24;
      v25 = *(int *)((char *)&dword_14 + LODWORD(y));
      if ( v25 )
        v22 = (float *)(v25 + 48);
      v26 = *v22 - (float)(x - (float)(v54.x * 0.25));
      v.x = v26;
      v27 = v22[1] - v23;
      v.y = v27;
      v28 = v22[2] - v24;
      v.z = v28;
      pCoors.z = v28;
      *(_QWORD *)&pCoors.x = *(_QWORD *)&v.x;
      if ( CPedPlacement::FindZCoorForPed(&pCoors) )
      {
        v = pCoors;
        v28 = pCoors.z;
        v27 = pCoors.y;
        v26 = pCoors.x;
      }
      v29 = *(int *)((char *)&dword_14 + LODWORD(y));
      if ( v29 )
        v13 = (float *)(v29 + 48);
      v.x = v26 - *v13;
      v.y = v27 - v13[1];
      v.z = v28 - v13[2];
      output.m_pRwMat = 0;
      output.m_owner = 0;
      Invert(*(const CMatrix **)((char *)&dword_14 + LODWORD(y)), &output);
      CVector::FromMultiply3X3(&v51, &output, &v);
      RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(v54.x, v54.y, 0.0, 0.0);
      v31 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
      CPed::AttachPedToEntity(
        pPed,
        (CEntity *)LODWORD(y),
        v51,
        (unsigned int)v31,
        0.2,
        pPed->m_WeaponSlots[pPed->m_nCurrentWeapon].m_eWeaponType);
      m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(m_pSubTask, 2000, 0, 0, 8.0);
      CMatrix::~CMatrix(&output);
      return m_pSubTask;
    }
  }
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 906
    || (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 903 )
  {
    v32 = this->m_pEntity;
    if ( v32 )
    {
      if ( this->m_seekTimer.m_bIsActive
        && (!this->m_seekTimer.m_bIsStopped ? (m_iStartTime = this->m_seekTimer.m_iStartTime,
                                               v33 = CTimer::m_snTimeInMilliseconds) : (v33 = CTimer::m_snTimeInMilliseconds,
                                                                                        this->m_seekTimer.m_bIsStopped = 0,
                                                                                        this->m_seekTimer.m_iStartTime = v33,
                                                                                        m_iStartTime = v33),
            m_iStartTime + this->m_seekTimer.m_iDuration <= v33) )
      {
        if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
               this->m_pSubTask,
               pPed,
               1,
               0) == 1 )
        {
          if ( *((unsigned __int8 *)this + 76) << 31 )
          {
            m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x1Cu);
            CTaskSimpleTired::CTaskSimpleTired((CTaskSimpleTired *)m_pSubTask, 1000);
          }
          else
          {
            m_pSubTask = 0;
          }
        }
      }
      else if ( this->m_scanTimer.m_bIsActive )
      {
        if ( this->m_scanTimer.m_bIsStopped )
        {
          LODWORD(v35) = CTimer::m_snTimeInMilliseconds;
          this->m_scanTimer.m_bIsStopped = 0;
          this->m_scanTimer.m_iStartTime = v35;
          HIDWORD(v35) = v35;
        }
        else
        {
          HIDWORD(v35) = this->m_scanTimer.m_iStartTime;
          LODWORD(v35) = CTimer::m_snTimeInMilliseconds;
        }
        if ( HIDWORD(v35) + this->m_scanTimer.m_iDuration <= (unsigned int)v35 )
        {
          HIDWORD(v35) = this->m_iPeriod;
          this->m_scanTimer.m_bIsActive = 1;
          *(_QWORD *)&this->m_scanTimer.m_iStartTime = v35;
          CEntitySeekPosCalculatorVehicleId::ComputeEntitySeekPos(&this->m_entitySeekPosCalculator, pPed, v32, &v);
          v36 = pPed->m_pMat;
          p_m_transform = (CSimpleTransform *)&v36->tx;
          if ( !v36 )
            p_m_transform = &pPed->m_transform;
          v38 = (float)((float)((float)(p_m_transform->m_translate.x - v.x) * (float)(p_m_transform->m_translate.x - v.x))
                      + (float)((float)(p_m_transform->m_translate.y - v.y) * (float)(p_m_transform->m_translate.y - v.y)))
              + 0.0;
          if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 906 )
          {
            m_fGoToPointDistance = this->m_fGoToPointDistance;
            if ( m_fGoToPointDistance == 0.0
              || v38 >= (float)((float)(m_fGoToPointDistance + -1.0) * (float)(m_fGoToPointDistance + -1.0)) )
            {
              CTaskComplexFollowNodeRoute::SetTarget(
                (CTaskComplexFollowNodeRoute *)this->m_pSubTask,
                pPed,
                &v,
                this->m_fTargetRadius,
                this->m_fSlowDownDistance,
                this->m_fFollowNodeThresholdHeightChange,
                0);
            }
            else if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask
                       + 7))(
                        this->m_pSubTask,
                        pPed,
                        1,
                        0) == 1 )
            {
              m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x28u);
              m_iMoveState = this->m_iMoveState;
              CEntitySeekPosCalculatorVehicleId::ComputeEntitySeekPos(
                &this->m_entitySeekPosCalculator,
                pPed,
                this->m_pEntity,
                (CVector *)&output);
              CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(
                (CTaskComplexGoToPointAndStandStill *)m_pSubTask,
                m_iMoveState,
                (const CVector *)&output,
                this->m_fTargetRadius,
                this->m_fSlowDownDistance,
                0,
                0);
              LOBYTE(m_pSubTask[1].m_pParent) = *((_BYTE *)this + 76) & 8 | (int)m_pSubTask[1].m_pParent & 0xF7;
              return m_pSubTask;
            }
          }
          else
          {
            v41 = this->m_pSubTask;
            m_pParent = (char)v41[4].m_pParent;
            if ( (m_pParent & 0x10) == 0 )
            {
              v43 = this->m_fGoToPointDistance;
              if ( v43 == 0.0 || v38 <= (float)((float)(v43 + 1.0) * (float)(v43 + 1.0)) )
              {
                m_fTargetRadius = this->m_fTargetRadius;
                m_fSlowDownDistance = this->m_fSlowDownDistance;
                if ( *(float *)&v41[2]._vptr$CTask != v.x
                  || *(float *)&v41[2].m_pParent != v.y
                  || *(float *)&v41[3]._vptr$CTask != v.z
                  || *(float *)&v41[4]._vptr$CTask != m_fSlowDownDistance )
                {
                  v47 = *(CTask *)&v.x;
                  v41[3]._vptr$CTask = (int (**)(void))LODWORD(v.z);
                  *(float *)&v41[3].m_pParent = m_fTargetRadius;
                  *(float *)&v41[4]._vptr$CTask = m_fSlowDownDistance;
                  LOBYTE(v41[4].m_pParent) = m_pParent | 4;
                  v41[2] = v47;
                }
              }
              else if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))v41->_vptr$CTask + 7))(v41, pPed, 1, 0) == 1 )
              {
                m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x60u);
                v44 = this->m_iMoveState;
                CEntitySeekPosCalculatorVehicleId::ComputeEntitySeekPos(
                  &this->m_entitySeekPosCalculator,
                  pPed,
                  this->m_pEntity,
                  (CVector *)&output);
                CTaskComplexFollowNodeRoute::CTaskComplexFollowNodeRoute(
                  (CTaskComplexFollowNodeRoute *)m_pSubTask,
                  v44,
                  (const CVector *)&output,
                  this->m_fTargetRadius,
                  this->m_fSlowDownDistance,
                  this->m_fFollowNodeThresholdHeightChange,
                  0,
                  -1,
                  1);
                return m_pSubTask;
              }
            }
          }
          m_pSubTask = (CTaskSimpleStandStill *)this->m_pSubTask;
        }
      }
    }
    else if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
                this->m_pSubTask,
                pPed,
                1,
                0) )
    {
      m_pSubTask = 0;
    }
  }
  v48 = this->m_pEntity;
  if ( v48 )
  {
    if ( (*(_BYTE *)&v48->m_info & 7) == 3 && CPed::IsPlayer((const CPed *)v48) )
    {
      PlayerPed = FindPlayerPed(-1);
      if ( CPedGroupMembership::IsMember(
             &CPedGroups::ms_groups[PlayerPed->m_pPlayerData->m_PlayerGroup].m_membership,
             pPed)
        && (unsigned int)(pPed->m_eMoveState - 5) <= 2
        && !((CTimer::m_FrameCounter + pPed->RandomSeed) << 18) )
      {
        CPed::Say(pPed, 0x5Bu, 0, 1.0, 0, 0, 0);
      }
    }
  }
  return m_pSubTask;
}
// 14: using guessed type int dword_14;

//----- (0049C2B0) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId>::CreateSubTask(
        const CTaskComplexSeekEntity<CEntitySeekPosCalculatorVehicleId> *this,
        const int iSubTaskType,
        CPed *pPed)
{
  CTaskComplexFollowNodeRoute *v5; // r4
  int v6; // r8
  CTaskComplexTurnToFaceEntityOrCoord *v7; // r6
  CTaskSimpleStandStill *v8; // r5
  int m_iMoveState; // r8
  CVector vSeekPos; // [sp+14h] [bp-24h] BYREF

  v5 = 0;
  if ( iSubTaskType > 718 )
  {
    if ( iSubTaskType > 905 )
    {
      if ( iSubTaskType == 906 )
      {
        v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x60u);
        m_iMoveState = this->m_iMoveState;
        CEntitySeekPosCalculatorVehicleId::ComputeEntitySeekPos(
          &this->m_entitySeekPosCalculator,
          pPed,
          this->m_pEntity,
          &vSeekPos);
        CTaskComplexFollowNodeRoute::CTaskComplexFollowNodeRoute(
          v5,
          m_iMoveState,
          &vSeekPos,
          this->m_fTargetRadius,
          this->m_fSlowDownDistance,
          this->m_fFollowNodeThresholdHeightChange,
          0,
          -1,
          1);
      }
      else if ( iSubTaskType == 920 )
      {
        v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x28u);
        CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(
          (CTaskComplexTurnToFaceEntityOrCoord *)v5,
          this->m_pEntity,
          0.5,
          0.2);
      }
    }
    else if ( iSubTaskType == 719 )
    {
      v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x70u);
      CTaskSimpleCarDrive::CTaskSimpleCarDrive((CTaskSimpleCarDrive *)v5, pPed->m_pMyVehicle, 0, 0);
      v5[1]._vptr$CTask = (int (**)(void))(elf_hash_bucket + 1748);
      LOWORD(v5[1].m_vTarget.x) = 0;
      v5[1].m_pParent = 0;
      v5[1].m_pSubTask = 0;
      v5->_vptr$CTask = (int (**)(void))&off_66571C;
    }
    else if ( iSubTaskType == 903 )
    {
      v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x28u);
      v6 = this->m_iMoveState;
      CEntitySeekPosCalculatorVehicleId::ComputeEntitySeekPos(
        &this->m_entitySeekPosCalculator,
        pPed,
        this->m_pEntity,
        &vSeekPos);
      CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(
        (CTaskComplexGoToPointAndStandStill *)v5,
        v6,
        &vSeekPos,
        this->m_fTargetRadius,
        this->m_fSlowDownDistance,
        0,
        0);
      LOBYTE(v5->m_fFollowNodeThresholdHeightChange) = *((_BYTE *)this + 76) & 8 | LOBYTE(v5->m_fFollowNodeThresholdHeightChange) & 0xF7;
    }
  }
  else if ( iSubTaskType > 243 )
  {
    if ( iSubTaskType == 244 )
    {
      v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x40u);
      CTaskComplexSequence::CTaskComplexSequence((CTaskComplexSequence *)v5);
      if ( (*((_BYTE *)this + 76) & 2) != 0 )
      {
        v7 = (CTaskComplexTurnToFaceEntityOrCoord *)CTask::operator new(0x28u);
        CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(v7, this->m_pEntity, 0.5, 0.2);
        CTaskComplexSequence::AddTask((CTaskComplexSequence *)v5, v7);
      }
      v8 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(v8, 100, 0, 0, 8.0);
      CTaskComplexSequence::AddTask((CTaskComplexSequence *)v5, v8);
    }
    else if ( iSubTaskType == 704 )
    {
      v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x34u);
      CTaskComplexLeaveCar::CTaskComplexLeaveCar((CTaskComplexLeaveCar *)v5, pPed->m_pMyVehicle, 0, 0, 1, 0);
    }
  }
  else if ( iSubTaskType == 203 )
  {
    v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v5, 2000, 0, 0, 8.0);
  }
  else if ( iSubTaskType == 219 )
  {
    v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x1Cu);
    CTaskSimpleTired::CTaskSimpleTired((CTaskSimpleTired *)v5, 1000);
  }
  return v5;
}
// FC: using guessed type int elf_hash_bucket[16411];
// 66571C: using guessed type void *off_66571C;

//----- (0049C4C4) --------------------------------------------------------
void __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving>::~CTaskComplexSeekEntity(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving> *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CTask = (int (**)(void))&off_668A1C;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  sub_18EDB4(this);
}
// 668A1C: using guessed type void *;

//----- (0049C4F0) --------------------------------------------------------
void __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving>::~CTaskComplexSeekEntity(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving> *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1
  void *v4; // r0

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CTask = (int (**)(void))&off_668A1C;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 49C518: variable 'v4' is possibly undefined
// 668A1C: using guessed type void *off_668A1C;

//----- (0049C520) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving>::Clone(
        const CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving> *this)
{
  char *v2; // r5
  __int64 v3; // d8
  __int64 v4; // d9
  CEntity *m_pEntity; // r9
  float m_fFollowNodeThresholdHeightChange; // r6
  char v7; // r8
  char v8; // r2
  char v9; // r0
  __int64 v10; // d16

  v2 = (char *)CTask::operator new(0x58u);
  v3 = *(_QWORD *)&this->m_iMaxSeekTime;
  v4 = *(_QWORD *)&this->m_fTargetRadius;
  m_pEntity = this->m_pEntity;
  m_fFollowNodeThresholdHeightChange = this->m_fFollowNodeThresholdHeightChange;
  v7 = *((_BYTE *)this + 84);
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_QWORD *)v2 + 2) = v3;
  *((_QWORD *)v2 + 3) = v4;
  *((_DWORD *)v2 + 20) = 6;
  v8 = v2[84];
  *((_DWORD *)v2 + 8) = 0;
  *((float *)v2 + 9) = m_fFollowNodeThresholdHeightChange;
  *((_WORD *)v2 + 24) = 0;
  *((_WORD *)v2 + 30) = 0;
  *((_DWORD *)v2 + 10) = 0;
  *((_DWORD *)v2 + 11) = 0;
  *((_DWORD *)v2 + 13) = 0;
  *((_DWORD *)v2 + 14) = 0;
  *((_DWORD *)v2 + 18) = 0;
  *((_DWORD *)v2 + 19) = 0;
  *(_DWORD *)v2 = &off_668A1C;
  *((_DWORD *)v2 + 16) = &off_66D3F0;
  v9 = v7 & 1 | v8 & 0xF0 | 2;
  v2[84] = v9;
  *((_DWORD *)v2 + 17) = 0;
  *((_DWORD *)v2 + 3) = m_pEntity;
  if ( m_pEntity )
  {
    CEntity::RegisterReference(m_pEntity, (CEntity **)v2 + 3);
    v9 = v2[84];
  }
  v10 = *(_QWORD *)&this->m_entitySeekPosCalculator.m_vOffset.x;
  *((_DWORD *)v2 + 19) = LODWORD(this->m_entitySeekPosCalculator.m_vOffset.z);
  *(_QWORD *)(v2 + 68) = v10;
  *((_DWORD *)v2 + 20) = this->m_iMoveState;
  v2[84] = v9 & 0xF7 | *((_BYTE *)this + 84) & 8;
  *((_DWORD *)v2 + 8) = LODWORD(this->m_fGoToPointDistance);
  *((_DWORD *)v2 + 20) = this->m_iMoveState;
  return (CTask *)v2;
}
// 668A1C: using guessed type void *off_668A1C;
// 66D3F0: using guessed type void *;

//----- (0049C5FC) --------------------------------------------------------
int __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving>::GetTaskType(
        const CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving> *this)
{
  return 907;
}

//----- (0049C604) --------------------------------------------------------
bool __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving>::MakeAbortable(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving> *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  int v5; // lr
  int v6; // r0
  int v7; // r1

  if ( !iPriority )
  {
    this->m_iMaxSeekTime = -1;
    v5 = CTimer::m_snTimeInMilliseconds;
    this->m_seekTimer.m_bIsActive = 1;
    this->m_seekTimer.m_iStartTime = v5;
    this->m_seekTimer.m_iDuration = -1;
  }
  v6 = (*((int (__fastcall **)(CTask *, CPed *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
         this->m_pSubTask,
         pPed);
  if ( v6 == 1 )
  {
    v7 = CTimer::m_snTimeInMilliseconds;
    this->m_scanTimer.m_bIsActive = 1;
    this->m_scanTimer.m_iStartTime = v7;
    this->m_scanTimer.m_iDuration = 0;
  }
  return v6;
}

//----- (0049C654) --------------------------------------------------------
void __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving>::Serialize(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving> *this)
{
  bool v2; // r6
  __int16 v3; // r2
  __int16 v4; // r4
  _WORD *v5; // r5
  _DWORD *v6; // r5
  int v7; // r8
  bool v8; // r5
  __int16 v9; // r2
  __int16 v10; // r4
  _WORD *v11; // r6
  _DWORD *v12; // r6
  CEntity *m_pEntity; // r0
  int v14; // r8
  bool v15; // r6
  __int16 v16; // r2
  __int16 v17; // r4
  _WORD *v18; // r5
  _DWORD *v19; // r5
  CEntity *v20; // r0
  int v21; // r1
  int32 VehicleRef; // r8
  int v23; // r0
  bool v24; // r5
  __int16 v25; // r2
  __int16 v26; // r6
  _WORD *v27; // r4
  _DWORD *v28; // r4
  bool v29; // r6
  __int16 v30; // r2
  __int16 v31; // r4
  _WORD *v32; // r5
  bool v33; // r6
  __int16 v34; // r2
  __int16 v35; // r4
  _WORD *v36; // r5
  bool v37; // r6
  __int16 v38; // r2
  __int16 v39; // r4
  _WORD *v40; // r5
  _DWORD *v41; // r5
  unsigned __int8 s[128]; // [sp+4h] [bp-9Ch] BYREF

  v2 = UseDataFence;
  if ( UseDataFence )
  {
    v3 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v4 = v3 + DataFence;
    v5 = malloc(2u);
    *v5 = v4;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 2);
    free(v5);
    UseDataFence = v2;
  }
  v6 = malloc(4u);
  *v6 = 6;
  CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
  free(v6);
  v7 = (*((int (__fastcall **)(CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving> *))this->_vptr$CTask + 5))(this);
  v8 = UseDataFence;
  if ( UseDataFence )
  {
    v9 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v10 = v9 + DataFence;
    v11 = malloc(2u);
    *v11 = v10;
    CGenericGameStorage::_SaveDataToWorkBuffer(v11, 2);
    free(v11);
    UseDataFence = v8;
  }
  v12 = malloc(4u);
  *v12 = v7;
  CGenericGameStorage::_SaveDataToWorkBuffer(v12, 4);
  free(v12);
  if ( (*((int (__fastcall **)(CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving> *))this->_vptr$CTask + 5))(this) == 907 )
  {
    m_pEntity = this->m_pEntity;
    if ( m_pEntity )
    {
      v14 = *(_BYTE *)&m_pEntity->m_info & 7;
      v15 = UseDataFence;
      if ( UseDataFence )
      {
        v16 = currentSaveFenceCount;
        UseDataFence = 0;
        ++currentSaveFenceCount;
        v17 = v16 + DataFence;
        v18 = malloc(2u);
        *v18 = v17;
        CGenericGameStorage::_SaveDataToWorkBuffer(v18, 2);
        free(v18);
        UseDataFence = v15;
      }
      v19 = malloc(4u);
      *v19 = v14;
      CGenericGameStorage::_SaveDataToWorkBuffer(v19, 4);
      free(v19);
      v20 = this->m_pEntity;
      v21 = *(_BYTE *)&v20->m_info & 7;
      switch ( v21 )
      {
        case 2:
          if ( v20 )
            VehicleRef = CPools::GetVehicleRef((CVehicle *)v20);
          else
            VehicleRef = -1;
          v29 = UseDataFence;
          if ( UseDataFence )
          {
            v30 = currentSaveFenceCount;
            UseDataFence = 0;
            ++currentSaveFenceCount;
            v31 = v30 + DataFence;
            v32 = malloc(2u);
            *v32 = v31;
            CGenericGameStorage::_SaveDataToWorkBuffer(v32, 2);
            free(v32);
            UseDataFence = v29;
          }
          goto LABEL_34;
        case 4:
          if ( v20 )
            VehicleRef = CPools::GetObjectRef((CObject *)v20);
          else
            VehicleRef = -1;
          v33 = UseDataFence;
          if ( UseDataFence )
          {
            v34 = currentSaveFenceCount;
            UseDataFence = 0;
            ++currentSaveFenceCount;
            v35 = v34 + DataFence;
            v36 = malloc(2u);
            *v36 = v35;
            CGenericGameStorage::_SaveDataToWorkBuffer(v36, 2);
            free(v36);
            UseDataFence = v33;
          }
          goto LABEL_34;
        case 3:
          if ( v20 )
            VehicleRef = CPools::GetPedRef((CPed *)v20);
          else
            VehicleRef = -1;
          v37 = UseDataFence;
          if ( UseDataFence )
          {
            v38 = currentSaveFenceCount;
            UseDataFence = 0;
            ++currentSaveFenceCount;
            v39 = v38 + DataFence;
            v40 = malloc(2u);
            *v40 = v39;
            CGenericGameStorage::_SaveDataToWorkBuffer(v40, 2);
            free(v40);
            UseDataFence = v37;
          }
LABEL_34:
          v41 = malloc(4u);
          *v41 = VehicleRef;
          CGenericGameStorage::_SaveDataToWorkBuffer(v41, 4);
          j_free(v41);
          break;
      }
    }
    else
    {
      v24 = UseDataFence;
      if ( UseDataFence )
      {
        v25 = currentSaveFenceCount;
        UseDataFence = 0;
        ++currentSaveFenceCount;
        v26 = v25 + DataFence;
        v27 = malloc(2u);
        *v27 = v26;
        CGenericGameStorage::_SaveDataToWorkBuffer(v27, 2);
        free(v27);
        UseDataFence = v24;
      }
      v28 = malloc(4u);
      *v28 = 0;
      CGenericGameStorage::_SaveDataToWorkBuffer(v28, 4);
      j_free(v28);
    }
  }
  else
  {
    v23 = (*((int (__fastcall **)(CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving> *))this->_vptr$CTask + 5))(this);
    sprintf(s, "ERROR - class %d is not type %d serialize is not this class expected", v23, 907);
  }
}
// 49C654: using guessed type unsigned __int8 s[128];

//----- (0049CA70) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving>::CreateNextSubTask(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving> *this,
        CPed *pPed)
{
  int v4; // r0
  CTaskSimpleStandStill *v5; // r6
  CTaskSimpleCarDrive *v6; // r0
  int v7; // r0
  bool v8; // zf
  CMatrix *m_pMat; // r6
  CSimpleTransform *p_tx; // r0
  float32x2_t v11; // d16
  unsigned __int64 v12; // d0
  float v13; // s0
  float m_fGoToPointDistance; // s2
  int v15; // r1
  CTaskSimpleStandStill *v17; // r0
  char v18; // r0
  CTaskSimpleStandStill vSeekPos; // [sp+8h] [bp-30h] BYREF

  if ( this->m_pEntity )
  {
    v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
    v5 = 0;
    if ( v4 > 718 )
    {
      if ( v4 != 719 )
      {
        v8 = v4 == 903;
        if ( v4 != 903 )
          v8 = v4 == 906;
        if ( v8 )
        {
          m_pMat = pPed->m_pMat;
          CEntitySeekPosCalculatorDriving::ComputeEntitySeekPos(
            &this->m_entitySeekPosCalculator,
            pPed,
            this->m_pEntity,
            (CVector *)&vSeekPos);
          p_tx = (CSimpleTransform *)&m_pMat->tx;
          if ( !m_pMat )
            p_tx = &pPed->m_transform;
          v11.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.x, (float32x2_t)vSeekPos.CTaskSimple).n64_u64[0];
          v12 = vmul_f32(v11, v11).n64_u64[0];
          v13 = (float)(*(float *)&v12 + *((float *)&v12 + 1)) + 0.0;
          if ( v13 <= (float)(this->m_fTargetRadius * this->m_fTargetRadius) )
          {
            v18 = *((_BYTE *)this + 84);
            *((_BYTE *)this + 84) = v18 | 4;
            v15 = 920;
            if ( (v18 & 2) == 0 )
              v15 = 1302;
          }
          else
          {
            m_fGoToPointDistance = this->m_fGoToPointDistance;
            if ( m_fGoToPointDistance == 0.0 )
            {
              v15 = 906;
            }
            else if ( v13 <= (float)(m_fGoToPointDistance * m_fGoToPointDistance) )
            {
              v15 = 903;
            }
            else
            {
              v15 = 906;
            }
          }
          return CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving>::CreateSubTask(this, v15, pPed);
        }
        return v5;
      }
    }
    else
    {
      if ( v4 != 203 )
      {
        if ( v4 == 219 )
        {
          v5 = 0;
          CTaskSimpleStandStill::CTaskSimpleStandStill(&vSeekPos, -1, 0, 0, 8.0);
          CTaskSimpleStandStill::ProcessPed(v17, pPed);
          CTaskSimpleStandStill::~CTaskSimpleStandStill(&vSeekPos);
        }
        else if ( v4 == 704 )
        {
          v5 = 0;
          if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
          {
            v6 = (CTaskSimpleCarDrive *)CTask::operator new(0x70u);
            CTaskSimpleCarDrive::CTaskSimpleCarDrive(v6, pPed->m_pMyVehicle, 0, 0);
            *(_DWORD *)(v7 + 96) = 2000;
            *(_WORD *)(v7 + 108) = 0;
            *(_DWORD *)(v7 + 100) = 0;
            *(_DWORD *)(v7 + 104) = 0;
            v5 = (CTaskSimpleStandStill *)v7;
            *(_DWORD *)v7 = &off_66571C;
          }
        }
        return v5;
      }
      if ( pPed->m_pAttachToEntity )
      {
        v5 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
        CTaskSimpleStandStill::CTaskSimpleStandStill(v5, 2000, 0, 0, 8.0);
        return v5;
      }
    }
    return (CTask *)(*((int (__fastcall **)(CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving> *, CPed *))this->_vptr$CTask
                     + 11))(
                      this,
                      pPed);
  }
  return 0;
}
// 49CACA: variable 'v7' is possibly undefined
// 49CBBE: variable 'v17' is possibly undefined
// 66571C: using guessed type void *off_66571C;

//----- (0049CC08) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving>::CreateFirstSubTask(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving> *this,
        CPed *pPed)
{
  __int64 v4; // kr00_8
  int v5; // r1
  CEntity *m_pEntity; // r2
  bool v7; // zf
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float32x2_t v10; // d16
  unsigned __int64 v11; // d0
  float v12; // s0
  int v13; // r1
  CTaskSimpleTired *v14; // r0
  float m_fGoToPointDistance; // s2
  CTaskComplexLeaveCar *v16; // r0
  CTask *result; // r0
  CVector vSeekPos; // [sp+8h] [bp-18h] BYREF

  v4 = *(_QWORD *)&this->m_iMaxSeekTime;
  v5 = CTimer::m_snTimeInMilliseconds;
  this->m_scanTimer.m_bIsActive = 1;
  this->m_scanTimer.m_iStartTime = v5;
  this->m_scanTimer.m_iDuration = HIDWORD(v4);
  if ( (_DWORD)v4 != -1 )
  {
    this->m_seekTimer.m_bIsActive = 1;
    this->m_seekTimer.m_iStartTime = v5;
    this->m_seekTimer.m_iDuration = v4;
  }
  m_pEntity = this->m_pEntity;
  if ( m_pEntity )
  {
    v7 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
    if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
      v7 = pPed->m_pMyVehicle == 0;
    if ( v7 )
    {
      CEntitySeekPosCalculatorDriving::ComputeEntitySeekPos(
        &this->m_entitySeekPosCalculator,
        pPed,
        m_pEntity,
        &vSeekPos);
      m_pMat = pPed->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      v10.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.x, *(float32x2_t *)&vSeekPos.x).n64_u64[0];
      v11 = vmul_f32(v10, v10).n64_u64[0];
      v12 = (float)(*(float *)&v11 + *((float *)&v11 + 1)) + 0.0;
      if ( v12 >= (float)(this->m_fTargetRadius * this->m_fTargetRadius) )
      {
        m_fGoToPointDistance = this->m_fGoToPointDistance;
        if ( m_fGoToPointDistance == 0.0 )
        {
          v13 = 906;
        }
        else
        {
          v13 = 903;
          if ( v12 > (float)(m_fGoToPointDistance * m_fGoToPointDistance) )
            v13 = 906;
        }
      }
      else
      {
        *((_BYTE *)this + 84) |= 4u;
        CPed::SetMoveState(pPed, PEDMOVE_STILL);
        v13 = 244;
      }
      return CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving>::CreateSubTask(this, v13, pPed);
    }
    else
    {
      v16 = (CTaskComplexLeaveCar *)CTask::operator new(0x34u);
      CTaskComplexLeaveCar::CTaskComplexLeaveCar(v16, pPed->m_pMyVehicle, 0, 0, 1, 0);
    }
  }
  else
  {
    v14 = (CTaskSimpleTired *)CTask::operator new(0x1Cu);
    CTaskSimpleTired::CTaskSimpleTired(v14, 1000);
  }
  return result;
}

//----- (0049CD14) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving>::ControlSubTask(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving> *this,
        CPed *pPed)
{
  CEntity *m_pEntity; // r4
  CTaskSimpleStandStill *m_pSubTask; // r6
  RwReal y; // r8
  CPhysical *m_pGroundPhysical; // r0
  bool v8; // zf
  CPhysical *v9; // r0
  bool v10; // zf
  CEntity *m_pAttachToEntity; // r0
  CMatrix *m_pMat; // r0
  float *v13; // r4
  int v14; // r1
  CSimpleTransform *p_tx; // r2
  float *v16; // r0
  float v17; // s2
  float z; // s4
  float x; // s16
  RwReal v20; // s18
  RwReal v21; // s20
  float *v22; // r1
  float v23; // s4
  float v24; // s6
  int v25; // r0
  float v26; // s18
  float v27; // s20
  float v28; // s16
  int v29; // r0
  float RadianAngleBetweenPoints; // r0
  float v31; // r0
  CEntity *v32; // r2
  unsigned int v33; // r0
  int m_iStartTime; // r1
  __int64 v35; // r0
  CMatrix *v36; // r0
  CSimpleTransform *p_m_transform; // r1
  float v38; // s16
  float m_fGoToPointDistance; // s0
  int m_iMoveState; // r4
  CTask *v41; // r0
  char m_pParent; // r1
  float v43; // s0
  int v44; // r4
  float m_fTargetRadius; // r2
  float m_fSlowDownDistance; // s0
  CTask v47; // d16
  CEntity *v48; // r0
  CPlayerPed *PlayerPed; // r0
  CVector v51; // [sp+14h] [bp-BCh] BYREF
  CMatrix output; // [sp+20h] [bp-B0h] BYREF
  CVector pCoors; // [sp+68h] [bp-68h] BYREF
  CVector v54; // [sp+78h] [bp-58h] BYREF
  CVector v; // [sp+88h] [bp-48h] BYREF

  m_pEntity = this->m_pEntity;
  m_pSubTask = (CTaskSimpleStandStill *)this->m_pSubTask;
  if ( m_pEntity && (*(_BYTE *)&m_pEntity->m_info & 7) == 3 && CPedGroups::AreInSameGroup(pPed, (const CPed *)m_pEntity) )
  {
    if ( BYTE1(m_pEntity[1].m_transform.m_translate.y) << 31 )
      goto LABEL_15;
    y = m_pEntity[23].m_transform.m_translate.y;
    if ( y != 0.0 && (*(_BYTE *)(LODWORD(y) + 58) & 7) == 2 )
    {
      m_pGroundPhysical = pPed->m_pGroundPhysical;
      v8 = m_pGroundPhysical == (CPhysical *)LODWORD(y);
      if ( m_pGroundPhysical != (CPhysical *)LODWORD(y) )
        v8 = pPed->m_pEntityStandingOn == (CEntity *)LODWORD(y);
      if ( v8 )
        goto LABEL_67;
    }
    y = *(float *)&m_pEntity[23].RandomSeed;
    if ( y == 0.0 || (*(_BYTE *)(LODWORD(y) + 58) & 7) != 2 )
      goto LABEL_15;
    v9 = pPed->m_pGroundPhysical;
    v10 = v9 == (CPhysical *)LODWORD(y);
    if ( v9 != (CPhysical *)LODWORD(y) )
      v10 = pPed->m_pEntityStandingOn == (CEntity *)LODWORD(y);
    if ( v10 )
    {
LABEL_67:
      if ( *(_DWORD *)(LODWORD(y) + 1440) != 5 )
        y = 0.0;
    }
    else
    {
LABEL_15:
      y = 0.0;
    }
    m_pAttachToEntity = pPed->m_pAttachToEntity;
    if ( y == 0.0 && m_pAttachToEntity )
    {
      CPed::DettachPedFromEntity(pPed);
    }
    else if ( y != 0.0
           && !m_pAttachToEntity
           && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 203
           && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
                this->m_pSubTask,
                pPed,
                1,
                0) == 1 )
    {
      m_pMat = pPed->m_pMat;
      v13 = (float *)(LODWORD(y) + 4);
      v14 = *(int *)((char *)&dword_14 + LODWORD(y));
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      v16 = (float *)(LODWORD(y) + 4);
      v17 = p_tx->m_translate.y;
      z = p_tx->m_translate.z;
      if ( v14 )
        v16 = (float *)(v14 + 48);
      v.x = *v16 - p_tx->m_translate.x;
      x = v.x;
      v.y = v16[1] - v17;
      v20 = v.y;
      v21 = v16[2] - z;
      v.z = v21;
      v54.z = v21;
      *(_QWORD *)&v54.x = *(_QWORD *)&v.x;
      CVector::Normalise(&v54);
      v22 = (float *)(LODWORD(y) + 4);
      v23 = v20 - (float)(v54.y * 0.25);
      v24 = v21 - (float)(v54.z * 0.25);
      v.y = v23;
      v.z = v24;
      v25 = *(int *)((char *)&dword_14 + LODWORD(y));
      if ( v25 )
        v22 = (float *)(v25 + 48);
      v26 = *v22 - (float)(x - (float)(v54.x * 0.25));
      v.x = v26;
      v27 = v22[1] - v23;
      v.y = v27;
      v28 = v22[2] - v24;
      v.z = v28;
      pCoors.z = v28;
      *(_QWORD *)&pCoors.x = *(_QWORD *)&v.x;
      if ( CPedPlacement::FindZCoorForPed(&pCoors) )
      {
        v = pCoors;
        v28 = pCoors.z;
        v27 = pCoors.y;
        v26 = pCoors.x;
      }
      v29 = *(int *)((char *)&dword_14 + LODWORD(y));
      if ( v29 )
        v13 = (float *)(v29 + 48);
      v.x = v26 - *v13;
      v.y = v27 - v13[1];
      v.z = v28 - v13[2];
      output.m_pRwMat = 0;
      output.m_owner = 0;
      Invert(*(const CMatrix **)((char *)&dword_14 + LODWORD(y)), &output);
      CVector::FromMultiply3X3(&v51, &output, &v);
      RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(v54.x, v54.y, 0.0, 0.0);
      v31 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
      CPed::AttachPedToEntity(
        pPed,
        (CEntity *)LODWORD(y),
        v51,
        (unsigned int)v31,
        0.2,
        pPed->m_WeaponSlots[pPed->m_nCurrentWeapon].m_eWeaponType);
      m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(m_pSubTask, 2000, 0, 0, 8.0);
      CMatrix::~CMatrix(&output);
      return m_pSubTask;
    }
  }
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 906
    || (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 903 )
  {
    v32 = this->m_pEntity;
    if ( v32 )
    {
      if ( this->m_seekTimer.m_bIsActive
        && (!this->m_seekTimer.m_bIsStopped ? (m_iStartTime = this->m_seekTimer.m_iStartTime,
                                               v33 = CTimer::m_snTimeInMilliseconds) : (v33 = CTimer::m_snTimeInMilliseconds,
                                                                                        this->m_seekTimer.m_bIsStopped = 0,
                                                                                        this->m_seekTimer.m_iStartTime = v33,
                                                                                        m_iStartTime = v33),
            m_iStartTime + this->m_seekTimer.m_iDuration <= v33) )
      {
        if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
               this->m_pSubTask,
               pPed,
               1,
               0) == 1 )
        {
          if ( *((unsigned __int8 *)this + 84) << 31 )
          {
            m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x1Cu);
            CTaskSimpleTired::CTaskSimpleTired((CTaskSimpleTired *)m_pSubTask, 1000);
          }
          else
          {
            m_pSubTask = 0;
          }
        }
      }
      else if ( this->m_scanTimer.m_bIsActive )
      {
        if ( this->m_scanTimer.m_bIsStopped )
        {
          LODWORD(v35) = CTimer::m_snTimeInMilliseconds;
          this->m_scanTimer.m_bIsStopped = 0;
          this->m_scanTimer.m_iStartTime = v35;
          HIDWORD(v35) = v35;
        }
        else
        {
          HIDWORD(v35) = this->m_scanTimer.m_iStartTime;
          LODWORD(v35) = CTimer::m_snTimeInMilliseconds;
        }
        if ( HIDWORD(v35) + this->m_scanTimer.m_iDuration <= (unsigned int)v35 )
        {
          HIDWORD(v35) = this->m_iPeriod;
          this->m_scanTimer.m_bIsActive = 1;
          *(_QWORD *)&this->m_scanTimer.m_iStartTime = v35;
          CEntitySeekPosCalculatorDriving::ComputeEntitySeekPos(&this->m_entitySeekPosCalculator, pPed, v32, &v);
          v36 = pPed->m_pMat;
          p_m_transform = (CSimpleTransform *)&v36->tx;
          if ( !v36 )
            p_m_transform = &pPed->m_transform;
          v38 = (float)((float)((float)(p_m_transform->m_translate.x - v.x) * (float)(p_m_transform->m_translate.x - v.x))
                      + (float)((float)(p_m_transform->m_translate.y - v.y) * (float)(p_m_transform->m_translate.y - v.y)))
              + 0.0;
          if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 906 )
          {
            m_fGoToPointDistance = this->m_fGoToPointDistance;
            if ( m_fGoToPointDistance == 0.0
              || v38 >= (float)((float)(m_fGoToPointDistance + -1.0) * (float)(m_fGoToPointDistance + -1.0)) )
            {
              CTaskComplexFollowNodeRoute::SetTarget(
                (CTaskComplexFollowNodeRoute *)this->m_pSubTask,
                pPed,
                &v,
                this->m_fTargetRadius,
                this->m_fSlowDownDistance,
                this->m_fFollowNodeThresholdHeightChange,
                0);
            }
            else if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask
                       + 7))(
                        this->m_pSubTask,
                        pPed,
                        1,
                        0) == 1 )
            {
              m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x28u);
              m_iMoveState = this->m_iMoveState;
              CEntitySeekPosCalculatorDriving::ComputeEntitySeekPos(
                &this->m_entitySeekPosCalculator,
                pPed,
                this->m_pEntity,
                (CVector *)&output);
              CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(
                (CTaskComplexGoToPointAndStandStill *)m_pSubTask,
                m_iMoveState,
                (const CVector *)&output,
                this->m_fTargetRadius,
                this->m_fSlowDownDistance,
                0,
                0);
              LOBYTE(m_pSubTask[1].m_pParent) = *((_BYTE *)this + 84) & 8 | (int)m_pSubTask[1].m_pParent & 0xF7;
              return m_pSubTask;
            }
          }
          else
          {
            v41 = this->m_pSubTask;
            m_pParent = (char)v41[4].m_pParent;
            if ( (m_pParent & 0x10) == 0 )
            {
              v43 = this->m_fGoToPointDistance;
              if ( v43 == 0.0 || v38 <= (float)((float)(v43 + 1.0) * (float)(v43 + 1.0)) )
              {
                m_fTargetRadius = this->m_fTargetRadius;
                m_fSlowDownDistance = this->m_fSlowDownDistance;
                if ( *(float *)&v41[2]._vptr$CTask != v.x
                  || *(float *)&v41[2].m_pParent != v.y
                  || *(float *)&v41[3]._vptr$CTask != v.z
                  || *(float *)&v41[4]._vptr$CTask != m_fSlowDownDistance )
                {
                  v47 = *(CTask *)&v.x;
                  v41[3]._vptr$CTask = (int (**)(void))LODWORD(v.z);
                  *(float *)&v41[3].m_pParent = m_fTargetRadius;
                  *(float *)&v41[4]._vptr$CTask = m_fSlowDownDistance;
                  LOBYTE(v41[4].m_pParent) = m_pParent | 4;
                  v41[2] = v47;
                }
              }
              else if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))v41->_vptr$CTask + 7))(v41, pPed, 1, 0) == 1 )
              {
                m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x60u);
                v44 = this->m_iMoveState;
                CEntitySeekPosCalculatorDriving::ComputeEntitySeekPos(
                  &this->m_entitySeekPosCalculator,
                  pPed,
                  this->m_pEntity,
                  (CVector *)&output);
                CTaskComplexFollowNodeRoute::CTaskComplexFollowNodeRoute(
                  (CTaskComplexFollowNodeRoute *)m_pSubTask,
                  v44,
                  (const CVector *)&output,
                  this->m_fTargetRadius,
                  this->m_fSlowDownDistance,
                  this->m_fFollowNodeThresholdHeightChange,
                  0,
                  -1,
                  1);
                return m_pSubTask;
              }
            }
          }
          m_pSubTask = (CTaskSimpleStandStill *)this->m_pSubTask;
        }
      }
    }
    else if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
                this->m_pSubTask,
                pPed,
                1,
                0) )
    {
      m_pSubTask = 0;
    }
  }
  v48 = this->m_pEntity;
  if ( v48 )
  {
    if ( (*(_BYTE *)&v48->m_info & 7) == 3 && CPed::IsPlayer((const CPed *)v48) )
    {
      PlayerPed = FindPlayerPed(-1);
      if ( CPedGroupMembership::IsMember(
             &CPedGroups::ms_groups[PlayerPed->m_pPlayerData->m_PlayerGroup].m_membership,
             pPed)
        && (unsigned int)(pPed->m_eMoveState - 5) <= 2
        && !((CTimer::m_FrameCounter + pPed->RandomSeed) << 18) )
      {
        CPed::Say(pPed, 0x5Bu, 0, 1.0, 0, 0, 0);
      }
    }
  }
  return m_pSubTask;
}
// 14: using guessed type int dword_14;

//----- (0049D324) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving>::CreateSubTask(
        const CTaskComplexSeekEntity<CEntitySeekPosCalculatorDriving> *this,
        const int iSubTaskType,
        CPed *pPed)
{
  CTaskComplexFollowNodeRoute *v5; // r4
  int v6; // r8
  CTaskComplexTurnToFaceEntityOrCoord *v7; // r6
  CTaskSimpleStandStill *v8; // r5
  int m_iMoveState; // r8
  CVector vSeekPos; // [sp+14h] [bp-24h] BYREF

  v5 = 0;
  if ( iSubTaskType > 718 )
  {
    if ( iSubTaskType > 905 )
    {
      if ( iSubTaskType == 906 )
      {
        v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x60u);
        m_iMoveState = this->m_iMoveState;
        CEntitySeekPosCalculatorDriving::ComputeEntitySeekPos(
          &this->m_entitySeekPosCalculator,
          pPed,
          this->m_pEntity,
          &vSeekPos);
        CTaskComplexFollowNodeRoute::CTaskComplexFollowNodeRoute(
          v5,
          m_iMoveState,
          &vSeekPos,
          this->m_fTargetRadius,
          this->m_fSlowDownDistance,
          this->m_fFollowNodeThresholdHeightChange,
          0,
          -1,
          1);
      }
      else if ( iSubTaskType == 920 )
      {
        v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x28u);
        CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(
          (CTaskComplexTurnToFaceEntityOrCoord *)v5,
          this->m_pEntity,
          0.5,
          0.2);
      }
    }
    else if ( iSubTaskType == 719 )
    {
      v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x70u);
      CTaskSimpleCarDrive::CTaskSimpleCarDrive((CTaskSimpleCarDrive *)v5, pPed->m_pMyVehicle, 0, 0);
      v5[1]._vptr$CTask = (int (**)(void))(elf_hash_bucket + 1748);
      LOWORD(v5[1].m_vTarget.x) = 0;
      v5[1].m_pParent = 0;
      v5[1].m_pSubTask = 0;
      v5->_vptr$CTask = (int (**)(void))&off_66571C;
    }
    else if ( iSubTaskType == 903 )
    {
      v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x28u);
      v6 = this->m_iMoveState;
      CEntitySeekPosCalculatorDriving::ComputeEntitySeekPos(
        &this->m_entitySeekPosCalculator,
        pPed,
        this->m_pEntity,
        &vSeekPos);
      CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(
        (CTaskComplexGoToPointAndStandStill *)v5,
        v6,
        &vSeekPos,
        this->m_fTargetRadius,
        this->m_fSlowDownDistance,
        0,
        0);
      LOBYTE(v5->m_fFollowNodeThresholdHeightChange) = *((_BYTE *)this + 84) & 8 | LOBYTE(v5->m_fFollowNodeThresholdHeightChange) & 0xF7;
    }
  }
  else if ( iSubTaskType > 243 )
  {
    if ( iSubTaskType == 244 )
    {
      v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x40u);
      CTaskComplexSequence::CTaskComplexSequence((CTaskComplexSequence *)v5);
      if ( (*((_BYTE *)this + 84) & 2) != 0 )
      {
        v7 = (CTaskComplexTurnToFaceEntityOrCoord *)CTask::operator new(0x28u);
        CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(v7, this->m_pEntity, 0.5, 0.2);
        CTaskComplexSequence::AddTask((CTaskComplexSequence *)v5, v7);
      }
      v8 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(v8, 100, 0, 0, 8.0);
      CTaskComplexSequence::AddTask((CTaskComplexSequence *)v5, v8);
    }
    else if ( iSubTaskType == 704 )
    {
      v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x34u);
      CTaskComplexLeaveCar::CTaskComplexLeaveCar((CTaskComplexLeaveCar *)v5, pPed->m_pMyVehicle, 0, 0, 1, 0);
    }
  }
  else if ( iSubTaskType == 203 )
  {
    v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v5, 2000, 0, 0, 8.0);
  }
  else if ( iSubTaskType == 219 )
  {
    v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x1Cu);
    CTaskSimpleTired::CTaskSimpleTired((CTaskSimpleTired *)v5, 1000);
  }
  return v5;
}
// FC: using guessed type int elf_hash_bucket[16411];
// 66571C: using guessed type void *off_66571C;

//----- (0049D538) --------------------------------------------------------
void __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos>::~CTaskComplexSeekEntity(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos> *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CTask = (int (**)(void))&off_668A58;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  sub_18EDB4(this);
}
// 668A58: using guessed type void *;

//----- (0049D564) --------------------------------------------------------
void __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos>::~CTaskComplexSeekEntity(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos> *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1
  void *v4; // r0

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CTask = (int (**)(void))&off_668A58;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  CTaskComplex::~CTaskComplex(this);
  sub_197118(v4);
}
// 49D58C: variable 'v4' is possibly undefined
// 668A58: using guessed type void *off_668A58;

//----- (0049D594) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos>::Clone(
        const CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos> *this)
{
  char *v2; // r5
  __int64 v3; // d8
  __int64 v4; // d9
  CEntity *m_pEntity; // r9
  float m_fFollowNodeThresholdHeightChange; // r6
  char v7; // r8
  char v8; // r2
  char v9; // r0
  __int64 v10; // d16

  v2 = (char *)CTask::operator new(0x58u);
  v3 = *(_QWORD *)&this->m_iMaxSeekTime;
  v4 = *(_QWORD *)&this->m_fTargetRadius;
  m_pEntity = this->m_pEntity;
  m_fFollowNodeThresholdHeightChange = this->m_fFollowNodeThresholdHeightChange;
  v7 = *((_BYTE *)this + 84);
  CTaskComplex::CTaskComplex((CTaskComplex *)v2);
  *((_QWORD *)v2 + 2) = v3;
  *((_QWORD *)v2 + 3) = v4;
  *((_DWORD *)v2 + 20) = 6;
  v8 = v2[84];
  *((_DWORD *)v2 + 8) = 0;
  *((float *)v2 + 9) = m_fFollowNodeThresholdHeightChange;
  *((_WORD *)v2 + 24) = 0;
  *((_WORD *)v2 + 30) = 0;
  *((_DWORD *)v2 + 10) = 0;
  *((_DWORD *)v2 + 11) = 0;
  *((_DWORD *)v2 + 13) = 0;
  *((_DWORD *)v2 + 14) = 0;
  *((_DWORD *)v2 + 18) = 0;
  *((_DWORD *)v2 + 19) = 0;
  *(_DWORD *)v2 = &off_668A58;
  *((_DWORD *)v2 + 16) = &off_66D3FC;
  v9 = v7 & 1 | v8 & 0xF0 | 2;
  v2[84] = v9;
  *((_DWORD *)v2 + 17) = 0;
  *((_DWORD *)v2 + 3) = m_pEntity;
  if ( m_pEntity )
  {
    CEntity::RegisterReference(m_pEntity, (CEntity **)v2 + 3);
    v9 = v2[84];
  }
  v10 = *(_QWORD *)&this->m_entitySeekPosCalculator.m_vecPos.x;
  *((_DWORD *)v2 + 19) = LODWORD(this->m_entitySeekPosCalculator.m_vecPos.z);
  *(_QWORD *)(v2 + 68) = v10;
  *((_DWORD *)v2 + 20) = this->m_iMoveState;
  v2[84] = v9 & 0xF7 | *((_BYTE *)this + 84) & 8;
  *((_DWORD *)v2 + 8) = LODWORD(this->m_fGoToPointDistance);
  *((_DWORD *)v2 + 20) = this->m_iMoveState;
  return (CTask *)v2;
}
// 668A58: using guessed type void *off_668A58;
// 66D3FC: using guessed type void *;

//----- (0049D670) --------------------------------------------------------
int __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos>::GetTaskType(
        const CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos> *this)
{
  return 907;
}

//----- (0049D678) --------------------------------------------------------
bool __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos>::MakeAbortable(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos> *this,
        CPed *pPed,
        const int iPriority,
        const CEvent *pEvent)
{
  int v5; // lr
  int v6; // r0
  int v7; // r1

  if ( !iPriority )
  {
    this->m_iMaxSeekTime = -1;
    v5 = CTimer::m_snTimeInMilliseconds;
    this->m_seekTimer.m_bIsActive = 1;
    this->m_seekTimer.m_iStartTime = v5;
    this->m_seekTimer.m_iDuration = -1;
  }
  v6 = (*((int (__fastcall **)(CTask *, CPed *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
         this->m_pSubTask,
         pPed);
  if ( v6 == 1 )
  {
    v7 = CTimer::m_snTimeInMilliseconds;
    this->m_scanTimer.m_bIsActive = 1;
    this->m_scanTimer.m_iStartTime = v7;
    this->m_scanTimer.m_iDuration = 0;
  }
  return v6;
}

//----- (0049D6C8) --------------------------------------------------------
void __fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos>::Serialize(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos> *this)
{
  bool v2; // r6
  __int16 v3; // r2
  __int16 v4; // r4
  _WORD *v5; // r5
  _DWORD *v6; // r5
  int v7; // r8
  bool v8; // r5
  __int16 v9; // r2
  __int16 v10; // r4
  _WORD *v11; // r6
  _DWORD *v12; // r6
  CEntity *m_pEntity; // r0
  int v14; // r8
  bool v15; // r6
  __int16 v16; // r2
  __int16 v17; // r4
  _WORD *v18; // r5
  _DWORD *v19; // r5
  CEntity *v20; // r0
  int v21; // r1
  int32 VehicleRef; // r8
  int v23; // r0
  bool v24; // r5
  __int16 v25; // r2
  __int16 v26; // r6
  _WORD *v27; // r4
  _DWORD *v28; // r4
  bool v29; // r6
  __int16 v30; // r2
  __int16 v31; // r4
  _WORD *v32; // r5
  bool v33; // r6
  __int16 v34; // r2
  __int16 v35; // r4
  _WORD *v36; // r5
  bool v37; // r6
  __int16 v38; // r2
  __int16 v39; // r4
  _WORD *v40; // r5
  _DWORD *v41; // r5
  unsigned __int8 s[128]; // [sp+4h] [bp-9Ch] BYREF

  v2 = UseDataFence;
  if ( UseDataFence )
  {
    v3 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v4 = v3 + DataFence;
    v5 = malloc(2u);
    *v5 = v4;
    CGenericGameStorage::_SaveDataToWorkBuffer(v5, 2);
    free(v5);
    UseDataFence = v2;
  }
  v6 = malloc(4u);
  *v6 = 7;
  CGenericGameStorage::_SaveDataToWorkBuffer(v6, 4);
  free(v6);
  v7 = (*((int (__fastcall **)(CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos> *))this->_vptr$CTask + 5))(this);
  v8 = UseDataFence;
  if ( UseDataFence )
  {
    v9 = currentSaveFenceCount;
    UseDataFence = 0;
    ++currentSaveFenceCount;
    v10 = v9 + DataFence;
    v11 = malloc(2u);
    *v11 = v10;
    CGenericGameStorage::_SaveDataToWorkBuffer(v11, 2);
    free(v11);
    UseDataFence = v8;
  }
  v12 = malloc(4u);
  *v12 = v7;
  CGenericGameStorage::_SaveDataToWorkBuffer(v12, 4);
  free(v12);
  if ( (*((int (__fastcall **)(CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos> *))this->_vptr$CTask + 5))(this) == 907 )
  {
    m_pEntity = this->m_pEntity;
    if ( m_pEntity )
    {
      v14 = *(_BYTE *)&m_pEntity->m_info & 7;
      v15 = UseDataFence;
      if ( UseDataFence )
      {
        v16 = currentSaveFenceCount;
        UseDataFence = 0;
        ++currentSaveFenceCount;
        v17 = v16 + DataFence;
        v18 = malloc(2u);
        *v18 = v17;
        CGenericGameStorage::_SaveDataToWorkBuffer(v18, 2);
        free(v18);
        UseDataFence = v15;
      }
      v19 = malloc(4u);
      *v19 = v14;
      CGenericGameStorage::_SaveDataToWorkBuffer(v19, 4);
      free(v19);
      v20 = this->m_pEntity;
      v21 = *(_BYTE *)&v20->m_info & 7;
      switch ( v21 )
      {
        case 2:
          if ( v20 )
            VehicleRef = CPools::GetVehicleRef((CVehicle *)v20);
          else
            VehicleRef = -1;
          v29 = UseDataFence;
          if ( UseDataFence )
          {
            v30 = currentSaveFenceCount;
            UseDataFence = 0;
            ++currentSaveFenceCount;
            v31 = v30 + DataFence;
            v32 = malloc(2u);
            *v32 = v31;
            CGenericGameStorage::_SaveDataToWorkBuffer(v32, 2);
            free(v32);
            UseDataFence = v29;
          }
          goto LABEL_34;
        case 4:
          if ( v20 )
            VehicleRef = CPools::GetObjectRef((CObject *)v20);
          else
            VehicleRef = -1;
          v33 = UseDataFence;
          if ( UseDataFence )
          {
            v34 = currentSaveFenceCount;
            UseDataFence = 0;
            ++currentSaveFenceCount;
            v35 = v34 + DataFence;
            v36 = malloc(2u);
            *v36 = v35;
            CGenericGameStorage::_SaveDataToWorkBuffer(v36, 2);
            free(v36);
            UseDataFence = v33;
          }
          goto LABEL_34;
        case 3:
          if ( v20 )
            VehicleRef = CPools::GetPedRef((CPed *)v20);
          else
            VehicleRef = -1;
          v37 = UseDataFence;
          if ( UseDataFence )
          {
            v38 = currentSaveFenceCount;
            UseDataFence = 0;
            ++currentSaveFenceCount;
            v39 = v38 + DataFence;
            v40 = malloc(2u);
            *v40 = v39;
            CGenericGameStorage::_SaveDataToWorkBuffer(v40, 2);
            free(v40);
            UseDataFence = v37;
          }
LABEL_34:
          v41 = malloc(4u);
          *v41 = VehicleRef;
          CGenericGameStorage::_SaveDataToWorkBuffer(v41, 4);
          j_free(v41);
          break;
      }
    }
    else
    {
      v24 = UseDataFence;
      if ( UseDataFence )
      {
        v25 = currentSaveFenceCount;
        UseDataFence = 0;
        ++currentSaveFenceCount;
        v26 = v25 + DataFence;
        v27 = malloc(2u);
        *v27 = v26;
        CGenericGameStorage::_SaveDataToWorkBuffer(v27, 2);
        free(v27);
        UseDataFence = v24;
      }
      v28 = malloc(4u);
      *v28 = 0;
      CGenericGameStorage::_SaveDataToWorkBuffer(v28, 4);
      j_free(v28);
    }
  }
  else
  {
    v23 = (*((int (__fastcall **)(CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos> *))this->_vptr$CTask + 5))(this);
    sprintf(s, "ERROR - class %d is not type %d serialize is not this class expected", v23, 907);
  }
}
// 49D6C8: using guessed type unsigned __int8 s[128];

//----- (0049DAE4) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos>::CreateNextSubTask(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos> *this,
        CPed *pPed)
{
  int v4; // r0
  CTaskSimpleStandStill *v5; // r6
  CTaskSimpleCarDrive *v6; // r0
  int v7; // r0
  bool v8; // zf
  CMatrix *m_pMat; // r6
  CSimpleTransform *p_tx; // r0
  float32x2_t v11; // d16
  unsigned __int64 v12; // d0
  float v13; // s0
  float m_fGoToPointDistance; // s2
  int v15; // r1
  CTaskSimpleStandStill *v17; // r0
  char v18; // r0
  CTaskSimpleStandStill vSeekPos; // [sp+8h] [bp-30h] BYREF

  if ( this->m_pEntity )
  {
    v4 = (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask);
    v5 = 0;
    if ( v4 > 718 )
    {
      if ( v4 != 719 )
      {
        v8 = v4 == 903;
        if ( v4 != 903 )
          v8 = v4 == 906;
        if ( v8 )
        {
          m_pMat = pPed->m_pMat;
          CEntitySeekPosCalculatorFixedPos::ComputeEntitySeekPos(
            &this->m_entitySeekPosCalculator,
            pPed,
            this->m_pEntity,
            (CVector *)&vSeekPos);
          p_tx = (CSimpleTransform *)&m_pMat->tx;
          if ( !m_pMat )
            p_tx = &pPed->m_transform;
          v11.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.x, (float32x2_t)vSeekPos.CTaskSimple).n64_u64[0];
          v12 = vmul_f32(v11, v11).n64_u64[0];
          v13 = (float)(*(float *)&v12 + *((float *)&v12 + 1)) + 0.0;
          if ( v13 <= (float)(this->m_fTargetRadius * this->m_fTargetRadius) )
          {
            v18 = *((_BYTE *)this + 84);
            *((_BYTE *)this + 84) = v18 | 4;
            v15 = 920;
            if ( (v18 & 2) == 0 )
              v15 = 1302;
          }
          else
          {
            m_fGoToPointDistance = this->m_fGoToPointDistance;
            if ( m_fGoToPointDistance == 0.0 )
            {
              v15 = 906;
            }
            else if ( v13 <= (float)(m_fGoToPointDistance * m_fGoToPointDistance) )
            {
              v15 = 903;
            }
            else
            {
              v15 = 906;
            }
          }
          return CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos>::CreateSubTask(this, v15, pPed);
        }
        return v5;
      }
    }
    else
    {
      if ( v4 != 203 )
      {
        if ( v4 == 219 )
        {
          v5 = 0;
          CTaskSimpleStandStill::CTaskSimpleStandStill(&vSeekPos, -1, 0, 0, 8.0);
          CTaskSimpleStandStill::ProcessPed(v17, pPed);
          CTaskSimpleStandStill::~CTaskSimpleStandStill(&vSeekPos);
        }
        else if ( v4 == 704 )
        {
          v5 = 0;
          if ( !(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31) )
          {
            v6 = (CTaskSimpleCarDrive *)CTask::operator new(0x70u);
            CTaskSimpleCarDrive::CTaskSimpleCarDrive(v6, pPed->m_pMyVehicle, 0, 0);
            *(_DWORD *)(v7 + 96) = 2000;
            *(_WORD *)(v7 + 108) = 0;
            *(_DWORD *)(v7 + 100) = 0;
            *(_DWORD *)(v7 + 104) = 0;
            v5 = (CTaskSimpleStandStill *)v7;
            *(_DWORD *)v7 = &off_66571C;
          }
        }
        return v5;
      }
      if ( pPed->m_pAttachToEntity )
      {
        v5 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
        CTaskSimpleStandStill::CTaskSimpleStandStill(v5, 2000, 0, 0, 8.0);
        return v5;
      }
    }
    return (CTask *)(*((int (__fastcall **)(CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos> *, CPed *))this->_vptr$CTask
                     + 11))(
                      this,
                      pPed);
  }
  return 0;
}
// 49DB3E: variable 'v7' is possibly undefined
// 49DC32: variable 'v17' is possibly undefined
// 66571C: using guessed type void *off_66571C;

//----- (0049DC7C) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos>::CreateFirstSubTask(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos> *this,
        CPed *pPed)
{
  __int64 v4; // kr00_8
  int v5; // r1
  CEntity *m_pEntity; // r2
  bool v7; // zf
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  float32x2_t v10; // d16
  unsigned __int64 v11; // d0
  float v12; // s0
  int v13; // r1
  CTaskSimpleTired *v14; // r0
  float m_fGoToPointDistance; // s2
  CTaskComplexLeaveCar *v16; // r0
  CTask *result; // r0
  CVector vSeekPos; // [sp+8h] [bp-18h] BYREF

  v4 = *(_QWORD *)&this->m_iMaxSeekTime;
  v5 = CTimer::m_snTimeInMilliseconds;
  this->m_scanTimer.m_bIsActive = 1;
  this->m_scanTimer.m_iStartTime = v5;
  this->m_scanTimer.m_iDuration = HIDWORD(v4);
  if ( (_DWORD)v4 != -1 )
  {
    this->m_seekTimer.m_bIsActive = 1;
    this->m_seekTimer.m_iStartTime = v5;
    this->m_seekTimer.m_iDuration = v4;
  }
  m_pEntity = this->m_pEntity;
  if ( m_pEntity )
  {
    v7 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
    if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
      v7 = pPed->m_pMyVehicle == 0;
    if ( v7 )
    {
      CEntitySeekPosCalculatorFixedPos::ComputeEntitySeekPos(
        &this->m_entitySeekPosCalculator,
        pPed,
        m_pEntity,
        &vSeekPos);
      m_pMat = pPed->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      v10.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_tx->m_translate.x, *(float32x2_t *)&vSeekPos.x).n64_u64[0];
      v11 = vmul_f32(v10, v10).n64_u64[0];
      v12 = (float)(*(float *)&v11 + *((float *)&v11 + 1)) + 0.0;
      if ( v12 >= (float)(this->m_fTargetRadius * this->m_fTargetRadius) )
      {
        m_fGoToPointDistance = this->m_fGoToPointDistance;
        if ( m_fGoToPointDistance == 0.0 )
        {
          v13 = 906;
        }
        else
        {
          v13 = 903;
          if ( v12 > (float)(m_fGoToPointDistance * m_fGoToPointDistance) )
            v13 = 906;
        }
      }
      else
      {
        *((_BYTE *)this + 84) |= 4u;
        CPed::SetMoveState(pPed, PEDMOVE_STILL);
        v13 = 244;
      }
      return CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos>::CreateSubTask(this, v13, pPed);
    }
    else
    {
      v16 = (CTaskComplexLeaveCar *)CTask::operator new(0x34u);
      CTaskComplexLeaveCar::CTaskComplexLeaveCar(v16, pPed->m_pMyVehicle, 0, 0, 1, 0);
    }
  }
  else
  {
    v14 = (CTaskSimpleTired *)CTask::operator new(0x1Cu);
    CTaskSimpleTired::CTaskSimpleTired(v14, 1000);
  }
  return result;
}

//----- (0049DD88) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos>::ControlSubTask(
        CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos> *this,
        CPed *pPed)
{
  CEntity *m_pEntity; // r4
  CTaskSimpleStandStill *m_pSubTask; // r6
  RwReal y; // r8
  CPhysical *m_pGroundPhysical; // r0
  bool v8; // zf
  CPhysical *v9; // r0
  bool v10; // zf
  CEntity *m_pAttachToEntity; // r0
  CMatrix *m_pMat; // r0
  float *v13; // r4
  int v14; // r1
  CSimpleTransform *p_tx; // r2
  float *v16; // r0
  float v17; // s2
  float z; // s4
  float x; // s16
  RwReal v20; // s18
  RwReal v21; // s20
  float *v22; // r1
  float v23; // s4
  float v24; // s6
  int v25; // r0
  float v26; // s18
  float v27; // s20
  float v28; // s16
  int v29; // r0
  float RadianAngleBetweenPoints; // r0
  float v31; // r0
  CEntity *v32; // r2
  unsigned int v33; // r0
  int m_iStartTime; // r1
  __int64 v35; // r0
  CMatrix *v36; // r0
  CSimpleTransform *p_m_transform; // r1
  float v38; // s16
  float m_fGoToPointDistance; // s0
  int m_iMoveState; // r4
  CTask *v41; // r0
  char m_pParent; // r1
  float v43; // s0
  int v44; // r4
  float m_fTargetRadius; // r2
  float m_fSlowDownDistance; // s0
  CTask v47; // d16
  CEntity *v48; // r0
  CPlayerPed *PlayerPed; // r0
  CVector v51; // [sp+14h] [bp-BCh] BYREF
  CMatrix output; // [sp+20h] [bp-B0h] BYREF
  CVector pCoors; // [sp+68h] [bp-68h] BYREF
  CVector v54; // [sp+78h] [bp-58h] BYREF
  CVector v; // [sp+88h] [bp-48h] BYREF

  m_pEntity = this->m_pEntity;
  m_pSubTask = (CTaskSimpleStandStill *)this->m_pSubTask;
  if ( m_pEntity && (*(_BYTE *)&m_pEntity->m_info & 7) == 3 && CPedGroups::AreInSameGroup(pPed, (const CPed *)m_pEntity) )
  {
    if ( BYTE1(m_pEntity[1].m_transform.m_translate.y) << 31 )
      goto LABEL_15;
    y = m_pEntity[23].m_transform.m_translate.y;
    if ( y != 0.0 && (*(_BYTE *)(LODWORD(y) + 58) & 7) == 2 )
    {
      m_pGroundPhysical = pPed->m_pGroundPhysical;
      v8 = m_pGroundPhysical == (CPhysical *)LODWORD(y);
      if ( m_pGroundPhysical != (CPhysical *)LODWORD(y) )
        v8 = pPed->m_pEntityStandingOn == (CEntity *)LODWORD(y);
      if ( v8 )
        goto LABEL_67;
    }
    y = *(float *)&m_pEntity[23].RandomSeed;
    if ( y == 0.0 || (*(_BYTE *)(LODWORD(y) + 58) & 7) != 2 )
      goto LABEL_15;
    v9 = pPed->m_pGroundPhysical;
    v10 = v9 == (CPhysical *)LODWORD(y);
    if ( v9 != (CPhysical *)LODWORD(y) )
      v10 = pPed->m_pEntityStandingOn == (CEntity *)LODWORD(y);
    if ( v10 )
    {
LABEL_67:
      if ( *(_DWORD *)(LODWORD(y) + 1440) != 5 )
        y = 0.0;
    }
    else
    {
LABEL_15:
      y = 0.0;
    }
    m_pAttachToEntity = pPed->m_pAttachToEntity;
    if ( y == 0.0 && m_pAttachToEntity )
    {
      CPed::DettachPedFromEntity(pPed);
    }
    else if ( y != 0.0
           && !m_pAttachToEntity
           && (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) != 203
           && (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
                this->m_pSubTask,
                pPed,
                1,
                0) == 1 )
    {
      m_pMat = pPed->m_pMat;
      v13 = (float *)(LODWORD(y) + 4);
      v14 = *(int *)((char *)&dword_14 + LODWORD(y));
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &pPed->m_transform;
      v16 = (float *)(LODWORD(y) + 4);
      v17 = p_tx->m_translate.y;
      z = p_tx->m_translate.z;
      if ( v14 )
        v16 = (float *)(v14 + 48);
      v.x = *v16 - p_tx->m_translate.x;
      x = v.x;
      v.y = v16[1] - v17;
      v20 = v.y;
      v21 = v16[2] - z;
      v.z = v21;
      v54.z = v21;
      *(_QWORD *)&v54.x = *(_QWORD *)&v.x;
      CVector::Normalise(&v54);
      v22 = (float *)(LODWORD(y) + 4);
      v23 = v20 - (float)(v54.y * 0.25);
      v24 = v21 - (float)(v54.z * 0.25);
      v.y = v23;
      v.z = v24;
      v25 = *(int *)((char *)&dword_14 + LODWORD(y));
      if ( v25 )
        v22 = (float *)(v25 + 48);
      v26 = *v22 - (float)(x - (float)(v54.x * 0.25));
      v.x = v26;
      v27 = v22[1] - v23;
      v.y = v27;
      v28 = v22[2] - v24;
      v.z = v28;
      pCoors.z = v28;
      *(_QWORD *)&pCoors.x = *(_QWORD *)&v.x;
      if ( CPedPlacement::FindZCoorForPed(&pCoors) )
      {
        v = pCoors;
        v28 = pCoors.z;
        v27 = pCoors.y;
        v26 = pCoors.x;
      }
      v29 = *(int *)((char *)&dword_14 + LODWORD(y));
      if ( v29 )
        v13 = (float *)(v29 + 48);
      v.x = v26 - *v13;
      v.y = v27 - v13[1];
      v.z = v28 - v13[2];
      output.m_pRwMat = 0;
      output.m_owner = 0;
      Invert(*(const CMatrix **)((char *)&dword_14 + LODWORD(y)), &output);
      CVector::FromMultiply3X3(&v51, &output, &v);
      RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(v54.x, v54.y, 0.0, 0.0);
      v31 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
      CPed::AttachPedToEntity(
        pPed,
        (CEntity *)LODWORD(y),
        v51,
        (unsigned int)v31,
        0.2,
        pPed->m_WeaponSlots[pPed->m_nCurrentWeapon].m_eWeaponType);
      m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(m_pSubTask, 2000, 0, 0, 8.0);
      CMatrix::~CMatrix(&output);
      return m_pSubTask;
    }
  }
  if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 906
    || (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 903 )
  {
    v32 = this->m_pEntity;
    if ( v32 )
    {
      if ( this->m_seekTimer.m_bIsActive
        && (!this->m_seekTimer.m_bIsStopped ? (m_iStartTime = this->m_seekTimer.m_iStartTime,
                                               v33 = CTimer::m_snTimeInMilliseconds) : (v33 = CTimer::m_snTimeInMilliseconds,
                                                                                        this->m_seekTimer.m_bIsStopped = 0,
                                                                                        this->m_seekTimer.m_iStartTime = v33,
                                                                                        m_iStartTime = v33),
            m_iStartTime + this->m_seekTimer.m_iDuration <= v33) )
      {
        if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
               this->m_pSubTask,
               pPed,
               1,
               0) == 1 )
        {
          if ( *((unsigned __int8 *)this + 84) << 31 )
          {
            m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x1Cu);
            CTaskSimpleTired::CTaskSimpleTired((CTaskSimpleTired *)m_pSubTask, 1000);
          }
          else
          {
            m_pSubTask = 0;
          }
        }
      }
      else if ( this->m_scanTimer.m_bIsActive )
      {
        if ( this->m_scanTimer.m_bIsStopped )
        {
          LODWORD(v35) = CTimer::m_snTimeInMilliseconds;
          this->m_scanTimer.m_bIsStopped = 0;
          this->m_scanTimer.m_iStartTime = v35;
          HIDWORD(v35) = v35;
        }
        else
        {
          HIDWORD(v35) = this->m_scanTimer.m_iStartTime;
          LODWORD(v35) = CTimer::m_snTimeInMilliseconds;
        }
        if ( HIDWORD(v35) + this->m_scanTimer.m_iDuration <= (unsigned int)v35 )
        {
          HIDWORD(v35) = this->m_iPeriod;
          this->m_scanTimer.m_bIsActive = 1;
          *(_QWORD *)&this->m_scanTimer.m_iStartTime = v35;
          CEntitySeekPosCalculatorFixedPos::ComputeEntitySeekPos(&this->m_entitySeekPosCalculator, pPed, v32, &v);
          v36 = pPed->m_pMat;
          p_m_transform = (CSimpleTransform *)&v36->tx;
          if ( !v36 )
            p_m_transform = &pPed->m_transform;
          v38 = (float)((float)((float)(p_m_transform->m_translate.x - v.x) * (float)(p_m_transform->m_translate.x - v.x))
                      + (float)((float)(p_m_transform->m_translate.y - v.y) * (float)(p_m_transform->m_translate.y - v.y)))
              + 0.0;
          if ( (*((int (__fastcall **)(CTask *))this->m_pSubTask->CTaskComplex::_vptr$CTask + 5))(this->m_pSubTask) == 906 )
          {
            m_fGoToPointDistance = this->m_fGoToPointDistance;
            if ( m_fGoToPointDistance == 0.0
              || v38 >= (float)((float)(m_fGoToPointDistance + -1.0) * (float)(m_fGoToPointDistance + -1.0)) )
            {
              CTaskComplexFollowNodeRoute::SetTarget(
                (CTaskComplexFollowNodeRoute *)this->m_pSubTask,
                pPed,
                &v,
                this->m_fTargetRadius,
                this->m_fSlowDownDistance,
                this->m_fFollowNodeThresholdHeightChange,
                0);
            }
            else if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask
                       + 7))(
                        this->m_pSubTask,
                        pPed,
                        1,
                        0) == 1 )
            {
              m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x28u);
              m_iMoveState = this->m_iMoveState;
              CEntitySeekPosCalculatorFixedPos::ComputeEntitySeekPos(
                &this->m_entitySeekPosCalculator,
                pPed,
                this->m_pEntity,
                (CVector *)&output);
              CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(
                (CTaskComplexGoToPointAndStandStill *)m_pSubTask,
                m_iMoveState,
                (const CVector *)&output,
                this->m_fTargetRadius,
                this->m_fSlowDownDistance,
                0,
                0);
              LOBYTE(m_pSubTask[1].m_pParent) = *((_BYTE *)this + 84) & 8 | (int)m_pSubTask[1].m_pParent & 0xF7;
              return m_pSubTask;
            }
          }
          else
          {
            v41 = this->m_pSubTask;
            m_pParent = (char)v41[4].m_pParent;
            if ( (m_pParent & 0x10) == 0 )
            {
              v43 = this->m_fGoToPointDistance;
              if ( v43 == 0.0 || v38 <= (float)((float)(v43 + 1.0) * (float)(v43 + 1.0)) )
              {
                m_fTargetRadius = this->m_fTargetRadius;
                m_fSlowDownDistance = this->m_fSlowDownDistance;
                if ( *(float *)&v41[2]._vptr$CTask != v.x
                  || *(float *)&v41[2].m_pParent != v.y
                  || *(float *)&v41[3]._vptr$CTask != v.z
                  || *(float *)&v41[4]._vptr$CTask != m_fSlowDownDistance )
                {
                  v47 = *(CTask *)&v.x;
                  v41[3]._vptr$CTask = (int (**)(void))LODWORD(v.z);
                  *(float *)&v41[3].m_pParent = m_fTargetRadius;
                  *(float *)&v41[4]._vptr$CTask = m_fSlowDownDistance;
                  LOBYTE(v41[4].m_pParent) = m_pParent | 4;
                  v41[2] = v47;
                }
              }
              else if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))v41->_vptr$CTask + 7))(v41, pPed, 1, 0) == 1 )
              {
                m_pSubTask = (CTaskSimpleStandStill *)CTask::operator new(0x60u);
                v44 = this->m_iMoveState;
                CEntitySeekPosCalculatorFixedPos::ComputeEntitySeekPos(
                  &this->m_entitySeekPosCalculator,
                  pPed,
                  this->m_pEntity,
                  (CVector *)&output);
                CTaskComplexFollowNodeRoute::CTaskComplexFollowNodeRoute(
                  (CTaskComplexFollowNodeRoute *)m_pSubTask,
                  v44,
                  (const CVector *)&output,
                  this->m_fTargetRadius,
                  this->m_fSlowDownDistance,
                  this->m_fFollowNodeThresholdHeightChange,
                  0,
                  -1,
                  1);
                return m_pSubTask;
              }
            }
          }
          m_pSubTask = (CTaskSimpleStandStill *)this->m_pSubTask;
        }
      }
    }
    else if ( (*((int (__fastcall **)(CTask *, CPed *, int, _DWORD))this->m_pSubTask->CTaskComplex::_vptr$CTask + 7))(
                this->m_pSubTask,
                pPed,
                1,
                0) )
    {
      m_pSubTask = 0;
    }
  }
  v48 = this->m_pEntity;
  if ( v48 )
  {
    if ( (*(_BYTE *)&v48->m_info & 7) == 3 && CPed::IsPlayer((const CPed *)v48) )
    {
      PlayerPed = FindPlayerPed(-1);
      if ( CPedGroupMembership::IsMember(
             &CPedGroups::ms_groups[PlayerPed->m_pPlayerData->m_PlayerGroup].m_membership,
             pPed)
        && (unsigned int)(pPed->m_eMoveState - 5) <= 2
        && !((CTimer::m_FrameCounter + pPed->RandomSeed) << 18) )
      {
        CPed::Say(pPed, 0x5Bu, 0, 1.0, 0, 0, 0);
      }
    }
  }
  return m_pSubTask;
}
// 14: using guessed type int dword_14;

//----- (0049E398) --------------------------------------------------------
CTask *__fastcall CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos>::CreateSubTask(
        const CTaskComplexSeekEntity<CEntitySeekPosCalculatorFixedPos> *this,
        const int iSubTaskType,
        CPed *pPed)
{
  CTaskComplexFollowNodeRoute *v5; // r4
  int v6; // r8
  CTaskComplexTurnToFaceEntityOrCoord *v7; // r6
  CTaskSimpleStandStill *v8; // r5
  int m_iMoveState; // r8
  CVector vSeekPos; // [sp+14h] [bp-24h] BYREF

  v5 = 0;
  if ( iSubTaskType > 718 )
  {
    if ( iSubTaskType > 905 )
    {
      if ( iSubTaskType == 906 )
      {
        v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x60u);
        m_iMoveState = this->m_iMoveState;
        CEntitySeekPosCalculatorFixedPos::ComputeEntitySeekPos(
          &this->m_entitySeekPosCalculator,
          pPed,
          this->m_pEntity,
          &vSeekPos);
        CTaskComplexFollowNodeRoute::CTaskComplexFollowNodeRoute(
          v5,
          m_iMoveState,
          &vSeekPos,
          this->m_fTargetRadius,
          this->m_fSlowDownDistance,
          this->m_fFollowNodeThresholdHeightChange,
          0,
          -1,
          1);
      }
      else if ( iSubTaskType == 920 )
      {
        v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x28u);
        CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(
          (CTaskComplexTurnToFaceEntityOrCoord *)v5,
          this->m_pEntity,
          0.5,
          0.2);
      }
    }
    else if ( iSubTaskType == 719 )
    {
      v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x70u);
      CTaskSimpleCarDrive::CTaskSimpleCarDrive((CTaskSimpleCarDrive *)v5, pPed->m_pMyVehicle, 0, 0);
      v5[1]._vptr$CTask = (int (**)(void))(elf_hash_bucket + 1748);
      LOWORD(v5[1].m_vTarget.x) = 0;
      v5[1].m_pParent = 0;
      v5[1].m_pSubTask = 0;
      v5->_vptr$CTask = (int (**)(void))&off_66571C;
    }
    else if ( iSubTaskType == 903 )
    {
      v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x28u);
      v6 = this->m_iMoveState;
      CEntitySeekPosCalculatorFixedPos::ComputeEntitySeekPos(
        &this->m_entitySeekPosCalculator,
        pPed,
        this->m_pEntity,
        &vSeekPos);
      CTaskComplexGoToPointAndStandStill::CTaskComplexGoToPointAndStandStill(
        (CTaskComplexGoToPointAndStandStill *)v5,
        v6,
        &vSeekPos,
        this->m_fTargetRadius,
        this->m_fSlowDownDistance,
        0,
        0);
      LOBYTE(v5->m_fFollowNodeThresholdHeightChange) = *((_BYTE *)this + 84) & 8 | LOBYTE(v5->m_fFollowNodeThresholdHeightChange) & 0xF7;
    }
  }
  else if ( iSubTaskType > 243 )
  {
    if ( iSubTaskType == 244 )
    {
      v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x40u);
      CTaskComplexSequence::CTaskComplexSequence((CTaskComplexSequence *)v5);
      if ( (*((_BYTE *)this + 84) & 2) != 0 )
      {
        v7 = (CTaskComplexTurnToFaceEntityOrCoord *)CTask::operator new(0x28u);
        CTaskComplexTurnToFaceEntityOrCoord::CTaskComplexTurnToFaceEntityOrCoord(v7, this->m_pEntity, 0.5, 0.2);
        CTaskComplexSequence::AddTask((CTaskComplexSequence *)v5, v7);
      }
      v8 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
      CTaskSimpleStandStill::CTaskSimpleStandStill(v8, 100, 0, 0, 8.0);
      CTaskComplexSequence::AddTask((CTaskComplexSequence *)v5, v8);
    }
    else if ( iSubTaskType == 704 )
    {
      v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x34u);
      CTaskComplexLeaveCar::CTaskComplexLeaveCar((CTaskComplexLeaveCar *)v5, pPed->m_pMyVehicle, 0, 0, 1, 0);
    }
  }
  else if ( iSubTaskType == 203 )
  {
    v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x20u);
    CTaskSimpleStandStill::CTaskSimpleStandStill((CTaskSimpleStandStill *)v5, 2000, 0, 0, 8.0);
  }
  else if ( iSubTaskType == 219 )
  {
    v5 = (CTaskComplexFollowNodeRoute *)CTask::operator new(0x1Cu);
    CTaskSimpleTired::CTaskSimpleTired((CTaskSimpleTired *)v5, 1000);
  }
  return v5;
}
// FC: using guessed type int elf_hash_bucket[16411];
// 66571C: using guessed type void *off_66571C;

//----- (0049E5AC) --------------------------------------------------------
void __fastcall CCivilianPed::CCivilianPed(CCivilianPed *this, ePedType PedType, UInt32 PedModelIndex)
{
  CPed::CPed(this, PedType);
  this->_vptr$CPlaceable = (int (**)(void))&off_668A94;
  CPed::SetModelIndex(this, PedModelIndex);
  CAEPedSpeechAudioEntity::Initialise(&this->m_PedSpeechAudioEntity, this);
}
// 668A94: using guessed type void *;

//----- (0049E5E0) --------------------------------------------------------
void __fastcall CCivilianPed::~CCivilianPed(CCivilianPed *this)
{
  void *v1; // r0

  CPed::~CPed(this);
  sub_19B93C(v1);
}
// 49E5EC: variable 'v1' is possibly undefined

//----- (0049E5F0) --------------------------------------------------------
void __fastcall CCivilianPed::ProcessControl(CCivilianPed *this)
{
  if ( this->CharCreatedBy != 3 )
  {
    CPed::ProcessControl(this);
    if ( (*(_BYTE *)&this->m_nFlags & 0x40) == 0 && this->m_nPedState != PED_DEAD )
      sub_18FD48(&this->m_WeaponSlots[this->m_nCurrentWeapon], this);
  }
}

//----- (0049E630) --------------------------------------------------------
void __fastcall CCopPed::CCopPed(CCopPed *this, eCopType CopType)
{
  uint8 v4; // r0
  int v5; // s0
  uint8 v6; // r1
  uint32 DefaultCopModel; // r1
  CCopPed *v8; // r0
  CPedIntelligence *m_pPedIntelligence; // r0

  CPed::CPed(this, 6u);
  this->m_CopType = CopType;
  this->_vptr$CPlaceable = (int (**)(void))&off_668B08;
  switch ( CopType )
  {
    case COPTYPE_NORMAL:
      DefaultCopModel = CStreaming::GetDefaultCopModel();
      v8 = this;
      goto LABEL_8;
    case COPTYPE_MOTORCYCLE:
      v8 = this;
      DefaultCopModel = 284;
      goto LABEL_8;
    case COPTYPE_SWAT:
    case COPTYPE_HELI_SWAT:
      CPed::SetModelIndex(this, 0x11Du);
      CPed::GiveDelayedWeapon(this, WEAPONTYPE_MICRO_UZI, 0x3E8u);
      CPed::SetCurrentWeapon(this, WEAPONTYPE_MICRO_UZI);
      v4 = 68;
      v5 = 1112014848;
      v6 = 70;
      goto LABEL_9;
    case COPTYPE_FBI:
      CPed::SetModelIndex(this, 0x11Eu);
      CPed::GiveDelayedWeapon(this, WEAPONTYPE_MP5, 0x3E8u);
      CPed::SetCurrentWeapon(this, WEAPONTYPE_MP5);
      v4 = 76;
      v5 = 1120403456;
      v6 = 60;
      goto LABEL_9;
    case COPTYPE_ARMY:
      CPed::SetModelIndex(this, 0x11Fu);
      CPed::GiveDelayedWeapon(this, WEAPONTYPE_M4, 0x3E8u);
      CPed::SetCurrentWeapon(this, WEAPONTYPE_M4);
      v4 = 84;
      v5 = 1120403456;
      v6 = 80;
      goto LABEL_9;
    case COPTYPE_RURAL:
      v8 = this;
      DefaultCopModel = 283;
      goto LABEL_8;
    default:
      v8 = this;
      DefaultCopModel = CopType;
LABEL_8:
      CPed::SetModelIndex(v8, DefaultCopModel);
      CPed::GiveWeapon(this, WEAPONTYPE_NIGHTSTICK, 0x3E8u, 1);
      CPed::GiveDelayedWeapon(this, WEAPONTYPE_PISTOL, 0x3E8u);
      v5 = 0;
      this->m_nCurrentWeapon = 0;
      v4 = 60;
      v6 = 30;
LABEL_9:
      this->m_nShootRate = v6;
      this->m_nShootingAccuracy = v4;
      this->m_nAttackTimer = 0;
      *(_WORD *)&this->m_bRoadBlockCop = 0;
      this->m_nStuckCounter = 0;
      LODWORD(this->m_nArmour) = v5;
      CPed::SetWeaponLockOnTarget(this, 0);
      CAEPedSpeechAudioEntity::Initialise(&this->m_PedSpeechAudioEntity, this);
      m_pPedIntelligence = this->m_pPedIntelligence;
      m_pPedIntelligence->m_iMaxNumFriendsToInform = 8;
      m_pPedIntelligence->m_fMaxInformFriendDistance = 60.0;
      *(_QWORD *)((char *)&this->m_aCriminalsImAfter[1] + 1) = 0LL;
      *(_QWORD *)((char *)&this->m_aCriminalsImAfter[3] + 1) = 0LL;
      *(_QWORD *)&this->m_pPartner = 0LL;
      *(_QWORD *)&this->m_aCriminalsImAfter[1] = 0LL;
      return;
  }
}
// 668B08: using guessed type void *;

//----- (0049E788) --------------------------------------------------------
void __fastcall CCopPed::~CCopPed(CCopPed *this)
{
  CWanted *PlayerWanted; // r0
  CCopPed *m_pPartner; // r0

  this->_vptr$CPlaceable = (int (**)(void))&off_668B08;
  if ( FindPlayerPed(-1) )
  {
    PlayerWanted = FindPlayerWanted(-1);
    CWanted::RemovePursuitCop(PlayerWanted, this);
  }
  m_pPartner = this->m_pPartner;
  if ( m_pPartner )
    CEntity::CleanUpOldReference(m_pPartner, &this->m_pPartner);
  CCopPed::ClearCriminalsToKill(this);
  sub_18CED4(this);
}
// 668B08: using guessed type void *off_668B08;

//----- (0049E7D4) --------------------------------------------------------
void __fastcall CCopPed::ClearCriminalsToKill(CCopPed *this)
{
  CPed *v2; // r0
  CPed *v3; // r0
  int v4; // r3
  unsigned int v5; // r2
  int v6; // r12
  CPed *v7; // r0
  CPed *v8; // r0
  CPed *v9; // r0
  int v10; // r3
  unsigned int v11; // r2
  int v12; // r12
  CPed *v13; // r0
  CPed *v14; // r0
  CPed *v15; // r0
  int v16; // r3
  unsigned int v17; // r2
  int v18; // r12
  CPed *v19; // r0
  CPed *v20; // r0
  CPed *v21; // r0
  int v22; // r3
  unsigned int v23; // r2
  int v24; // r12
  CPed *v25; // r0
  CPed *v26; // r0
  CEntity **v27; // r4
  CEntity *v28; // r0
  RwObject_0 *m_pRwObject; // r3
  unsigned int v30; // r2
  int m_nFlags; // r5

  v2 = this->m_aCriminalsImAfter[0];
  if ( v2 )
  {
    v2->DontUseSmallerRemovalRange = CTimer::m_snTimeInMilliseconds;
    v3 = this->m_aCriminalsImAfter[0];
    v4 = *((_DWORD *)&v3->m_nPedFlags + 2);
    v5 = *((_DWORD *)&v3->m_nPedFlags + 1) & 0xFFFFFFBF;
    v6 = *((_DWORD *)&v3->m_nPedFlags + 3);
    *(_DWORD *)&v3->m_nPedFlags = v3->m_nPedFlags;
    *((_DWORD *)&v3->m_nPedFlags + 1) = v5;
    *((_DWORD *)&v3->m_nPedFlags + 2) = v4;
    *((_DWORD *)&v3->m_nPedFlags + 3) = v6;
    this->m_aCriminalsImAfter[0]->fRemoveRangeMultiplier = 1.0;
    v7 = this->m_aCriminalsImAfter[0];
    if ( v7 )
      CEntity::CleanUpOldReference(v7, this->m_aCriminalsImAfter);
    this->m_aCriminalsImAfter[0] = 0;
  }
  v8 = this->m_aCriminalsImAfter[1];
  if ( v8 )
  {
    v8->DontUseSmallerRemovalRange = CTimer::m_snTimeInMilliseconds;
    v9 = this->m_aCriminalsImAfter[1];
    v10 = *((_DWORD *)&v9->m_nPedFlags + 2);
    v11 = *((_DWORD *)&v9->m_nPedFlags + 1) & 0xFFFFFFBF;
    v12 = *((_DWORD *)&v9->m_nPedFlags + 3);
    *(_DWORD *)&v9->m_nPedFlags = v9->m_nPedFlags;
    *((_DWORD *)&v9->m_nPedFlags + 1) = v11;
    *((_DWORD *)&v9->m_nPedFlags + 2) = v10;
    *((_DWORD *)&v9->m_nPedFlags + 3) = v12;
    this->m_aCriminalsImAfter[1]->fRemoveRangeMultiplier = 1.0;
    v13 = this->m_aCriminalsImAfter[1];
    if ( v13 )
      CEntity::CleanUpOldReference(v13, &this->m_aCriminalsImAfter[1]);
    this->m_aCriminalsImAfter[1] = 0;
  }
  v14 = this->m_aCriminalsImAfter[2];
  if ( v14 )
  {
    v14->DontUseSmallerRemovalRange = CTimer::m_snTimeInMilliseconds;
    v15 = this->m_aCriminalsImAfter[2];
    v16 = *((_DWORD *)&v15->m_nPedFlags + 2);
    v17 = *((_DWORD *)&v15->m_nPedFlags + 1) & 0xFFFFFFBF;
    v18 = *((_DWORD *)&v15->m_nPedFlags + 3);
    *(_DWORD *)&v15->m_nPedFlags = v15->m_nPedFlags;
    *((_DWORD *)&v15->m_nPedFlags + 1) = v17;
    *((_DWORD *)&v15->m_nPedFlags + 2) = v16;
    *((_DWORD *)&v15->m_nPedFlags + 3) = v18;
    this->m_aCriminalsImAfter[2]->fRemoveRangeMultiplier = 1.0;
    v19 = this->m_aCriminalsImAfter[2];
    if ( v19 )
      CEntity::CleanUpOldReference(v19, &this->m_aCriminalsImAfter[2]);
    this->m_aCriminalsImAfter[2] = 0;
  }
  v20 = this->m_aCriminalsImAfter[3];
  if ( v20 )
  {
    v20->DontUseSmallerRemovalRange = CTimer::m_snTimeInMilliseconds;
    v21 = this->m_aCriminalsImAfter[3];
    v22 = *((_DWORD *)&v21->m_nPedFlags + 2);
    v23 = *((_DWORD *)&v21->m_nPedFlags + 1) & 0xFFFFFFBF;
    v24 = *((_DWORD *)&v21->m_nPedFlags + 3);
    *(_DWORD *)&v21->m_nPedFlags = v21->m_nPedFlags;
    *((_DWORD *)&v21->m_nPedFlags + 1) = v23;
    *((_DWORD *)&v21->m_nPedFlags + 2) = v22;
    *((_DWORD *)&v21->m_nPedFlags + 3) = v24;
    this->m_aCriminalsImAfter[3]->fRemoveRangeMultiplier = 1.0;
    v25 = this->m_aCriminalsImAfter[3];
    if ( v25 )
      CEntity::CleanUpOldReference(v25, &this->m_aCriminalsImAfter[3]);
    this->m_aCriminalsImAfter[3] = 0;
  }
  v26 = this->m_aCriminalsImAfter[4];
  if ( v26 )
  {
    v27 = &this->m_aCriminalsImAfter[4];
    v26->DontUseSmallerRemovalRange = CTimer::m_snTimeInMilliseconds;
    v28 = *v27;
    m_pRwObject = (*v27)[19].m_pRwObject;
    v30 = (int)(*v27)[19].m_pMat & 0xFFFFFFBF;
    m_nFlags = (int)(*v27)[19].m_nFlags;
    v28[19].m_transform.m_heading = (*v27)[19].m_transform.m_heading;
    v28[19].m_pMat = (CMatrix *)v30;
    v28[19].m_pRwObject = m_pRwObject;
    *(_DWORD *)&v28[19].m_nFlags = m_nFlags;
    (*v27)[32].m_pRwObject = (RwObject_0 *)1065353216;
    if ( *v27 )
      CEntity::CleanUpOldReference(*v27, v27);
    *v27 = 0;
  }
}

//----- (0049E9A4) --------------------------------------------------------
void __fastcall CCopPed::~CCopPed(CCopPed *this)
{
  CWanted *PlayerWanted; // r0
  CCopPed *m_pPartner; // r0
  void *v4; // r0

  this->_vptr$CPlaceable = (int (**)(void))&off_668B08;
  if ( FindPlayerPed(-1) )
  {
    PlayerWanted = FindPlayerWanted(-1);
    CWanted::RemovePursuitCop(PlayerWanted, this);
  }
  m_pPartner = this->m_pPartner;
  if ( m_pPartner )
    CEntity::CleanUpOldReference(m_pPartner, &this->m_pPartner);
  CCopPed::ClearCriminalsToKill(this);
  CPed::~CPed(this);
  sub_19B93C(v4);
}
// 49E9EC: variable 'v4' is possibly undefined
// 668B08: using guessed type void *off_668B08;

//----- (0049E9F4) --------------------------------------------------------
void __fastcall CCopPed::ProcessControl(CCopPed *this)
{
  CPedIntelligence *m_pPedIntelligence; // r0
  CVector *GameCamPosition; // r0
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  RwReal v6; // s0
  RwReal v7; // s2
  CVector vecEnd; // [sp+24h] [bp-44h] BYREF
  CEntity *refEntityPtr; // [sp+30h] [bp-38h] BYREF
  CColPoint colPoint; // [sp+34h] [bp-34h] BYREF

  if ( FindPlayerWanted(-1)->m_WantedLevel )
  {
    m_pPedIntelligence = this->m_pPedIntelligence;
    if ( m_pPedIntelligence->m_iDecisionMakerType == 7 )
      CPedIntelligence::SetPedDecisionMakerType(m_pPedIntelligence, 1);
  }
  CPed::ProcessControl(this);
  if ( (*(_BYTE *)&this->m_nFlags & 0x40) == 0 && this->m_nPedState != PED_DEAD )
  {
    CWeapon::Update(&this->m_WeaponSlots[this->m_nCurrentWeapon], this);
    if ( this->m_nPedState != PED_DIE )
    {
      if ( this->m_pEntLockOnTarget )
        CPed::Say(this, 0xDCu, 0, 1.0, 0, 0, 0);
      if ( this->m_bRemoveIfNonVisible )
      {
        if ( CEntity::GetIsOnScreen(this) )
        {
          if ( (((_BYTE)CTimer::m_FrameCounter + (unsigned __int8)this->RandomSeed) & 0x1F) == 17 )
          {
            refEntityPtr = 0;
            GameCamPosition = CCamera::GetGameCamPosition(&TheCamera);
            m_pMat = this->m_pMat;
            p_tx = (CSimpleTransform *)&m_pMat->tx;
            if ( !m_pMat )
              p_tx = &this->m_transform;
            v6 = p_tx->m_translate.x + 0.0;
            v7 = p_tx->m_translate.z + 0.7;
            vecEnd.y = p_tx->m_translate.y + 0.0;
            vecEnd.x = v6;
            vecEnd.z = v7;
            CWorld::ProcessLineOfSight(GameCamPosition, &vecEnd, &colPoint, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0, 0);
            if ( refEntityPtr )
              (*((void (__fastcall **)(CCopPed *))this->_vptr$CPlaceable + 22))(this);
          }
        }
        else
        {
          (*((void (__fastcall **)(CCopPed *))this->_vptr$CPlaceable + 22))(this);
        }
      }
    }
  }
}

//----- (0049EB20) --------------------------------------------------------
void __fastcall CCopPed::SetPartner(CCopPed *this, CCopPed *pPed)
{
  CCopPed *m_pPartner; // r0
  CCopPed **p_m_pPartner; // r5

  m_pPartner = this->m_pPartner;
  p_m_pPartner = &this->m_pPartner;
  if ( m_pPartner )
    CEntity::CleanUpOldReference(m_pPartner, &this->m_pPartner);
  *p_m_pPartner = pPed;
  if ( pPed )
    sub_196050(pPed, p_m_pPartner);
}

//----- (0049EB50) --------------------------------------------------------
int32 __fastcall CCopPed::AddCriminalToKill(CCopPed *this, CPed *pCriminal)
{
  int32 m_nPedType; // r0
  int32 v5; // r6
  CPed *v7; // r0
  CPed **m_aCriminalsImAfter; // r9
  CPed *v9; // r0
  CPed **v10; // r11
  CPed *v11; // r0
  CPed **v12; // r10
  CPed *v13; // r0
  CPed **v14; // r8
  CPed *v15; // r0
  CPed *v16; // r1
  bool v17; // zf
  CPed *v18; // r1
  bool v19; // zf
  bool v20; // zf
  CPed **v21; // r1
  int v22; // r3
  CVehicle *m_pMyVehicle; // r0
  uint32 v24; // r1
  CVehicle *v25; // r0
  int v26; // r2
  CCopPed *m_pPartner; // r0

  if ( !pCriminal )
    return -1;
  if ( CPed::IsPlayer(pCriminal) )
    return -1;
  m_nPedType = pCriminal->m_nPedType;
  if ( (unsigned int)m_nPedType <= 0x13 && ((1 << m_nPedType) & (unsigned int)"eObjectCarriedWithRopeEv") != 0 )
    return -1;
  if ( m_nPedType > 23 || pCriminal->CharCreatedBy == 2 )
    return -1;
  v7 = this->m_aCriminalsImAfter[0];
  m_aCriminalsImAfter = this->m_aCriminalsImAfter;
  if ( v7 && v7->m_nHealth <= 0.0 )
  {
    CEntity::CleanUpOldReference(v7, this->m_aCriminalsImAfter);
    *m_aCriminalsImAfter = 0;
  }
  v9 = this->m_aCriminalsImAfter[1];
  v10 = &this->m_aCriminalsImAfter[1];
  if ( v9 && v9->m_nHealth <= 0.0 )
  {
    CEntity::CleanUpOldReference(v9, &this->m_aCriminalsImAfter[1]);
    *v10 = 0;
  }
  v11 = this->m_aCriminalsImAfter[2];
  v12 = &this->m_aCriminalsImAfter[2];
  if ( v11 && v11->m_nHealth <= 0.0 )
  {
    CEntity::CleanUpOldReference(v11, &this->m_aCriminalsImAfter[2]);
    *v12 = 0;
  }
  v13 = this->m_aCriminalsImAfter[3];
  v14 = &this->m_aCriminalsImAfter[3];
  if ( v13 && v13->m_nHealth <= 0.0 )
  {
    CEntity::CleanUpOldReference(v13, &this->m_aCriminalsImAfter[3]);
    *v14 = 0;
  }
  v15 = this->m_aCriminalsImAfter[4];
  if ( v15 )
  {
    if ( v15->m_nHealth <= 0.0 )
    {
      CEntity::CleanUpOldReference(v15, &this->m_aCriminalsImAfter[4]);
      v15 = 0;
      this->m_aCriminalsImAfter[4] = 0;
    }
  }
  else
  {
    v15 = 0;
  }
  if ( pCriminal->m_nHealth <= 0.0 )
    return -1;
  if ( *m_aCriminalsImAfter )
  {
    if ( *m_aCriminalsImAfter == pCriminal )
      return 0;
    if ( !*v10 )
    {
      v16 = *v12;
      v5 = 1;
      goto LABEL_45;
    }
    v5 = -1;
    if ( *v10 == pCriminal )
      return 1;
  }
  else
  {
    v5 = 0;
    if ( *v10 == pCriminal )
      return 1;
  }
  v16 = *v12;
  v17 = v5 == -1;
  if ( v5 == -1 )
    v17 = v16 == 0;
  if ( v17 )
  {
    v18 = *v14;
    v5 = 2;
    goto LABEL_37;
  }
LABEL_45:
  if ( v16 == pCriminal )
    return 2;
  v18 = *v14;
  v20 = v5 == -1;
  if ( v5 == -1 )
    v20 = v18 == 0;
  if ( v20 )
  {
    v5 = 3;
    goto LABEL_51;
  }
LABEL_37:
  if ( v18 == pCriminal )
    return 3;
  v19 = v5 == -1;
  if ( v5 == -1 )
    v19 = v15 == 0;
  if ( !v19 )
  {
LABEL_51:
    if ( v15 == pCriminal )
      return 4;
    if ( v5 != -1 )
      goto LABEL_53;
    return -1;
  }
  v5 = 4;
LABEL_53:
  v21 = &this->m_aCriminalsImAfter[v5];
  *v21 = pCriminal;
  CEntity::RegisterReference(pCriminal, v21);
  v22 = *((_DWORD *)&pCriminal->m_nPedFlags + 3);
  m_pMyVehicle = pCriminal->m_pMyVehicle;
  v24 = CTimer::m_snTimeInMilliseconds;
  *((_DWORD *)&pCriminal->m_nPedFlags + 1) |= 0x40u;
  *((_DWORD *)&pCriminal->m_nPedFlags + 3) = v22 | 0x800;
  pCriminal->fRemoveRangeMultiplier = 0.3;
  pCriminal->DontUseSmallerRemovalRange = v24 + 300000;
  if ( m_pMyVehicle )
  {
    m_pMyVehicle->ExtendedRemovalRange = 255;
    v25 = pCriminal->m_pMyVehicle;
    v26 = *((_DWORD *)&v25->m_nVehicleFlags + 1) | 0x40;
    *(_DWORD *)&v25->m_nVehicleFlags = v25->m_nVehicleFlags;
    *((_DWORD *)&v25->m_nVehicleFlags + 1) = v26;
  }
  m_pPartner = this->m_pPartner;
  if ( m_pPartner )
    CCopPed::AddCriminalToKill(m_pPartner, pCriminal);
  return v5;
}

//----- (0049ED74) --------------------------------------------------------
void __fastcall CCopPed::RemoveCriminalToKill(CCopPed *this, CPed *pCriminal, int32 i)
{
  int (***v3)(void); // r1
  CEntity *v4; // r0
  _DWORD *v5; // r4

  v3 = &this->_vptr$CPlaceable + i;
  v4 = (CEntity *)v3[493];
  if ( v4 )
  {
    v5 = v3 + 493;
    CEntity::CleanUpOldReference(v4, (CEntity **)v3 + 493);
    *v5 = 0;
  }
}

//----- (0049ED9C) --------------------------------------------------------
void __fastcall CDummyPed::CDummyPed(CDummyPed *this)
{
  _DWORD *v1; // r0

  CDummy::CDummy(this);
  *v1 = &off_668B7C;
}
// 49EDAC: variable 'v1' is possibly undefined
// 668B7C: using guessed type void *;

//----- (0049EDB8) --------------------------------------------------------
void __fastcall CDummyPed::~CDummyPed(CDummyPed *this)
{
  void *v1; // r0

  CDummy::~CDummy(this);
  sub_18C680(v1);
}
// 49EDC4: variable 'v1' is possibly undefined

//----- (0049EDC8) --------------------------------------------------------
void __fastcall CEmergencyPed::CEmergencyPed(CEmergencyPed *this, uint32 pedType, uint32 pedModelId)
{
  CPed::CPed(this, pedType);
  this->_vptr$CPlaceable = (int (**)(void))&off_668BE0;
  CPed::SetModelIndex(this, pedModelId);
  CAEPedSpeechAudioEntity::Initialise(&this->m_PedSpeechAudioEntity, this);
}
// 668BE0: using guessed type void *;

//----- (0049EDF8) --------------------------------------------------------
void __fastcall CEmergencyPed::ProcessControl(CEmergencyPed *this)
{
  CPed::ProcessControl(this);
  if ( (*(_BYTE *)&this->m_nFlags & 0x40) == 0 && this->m_nPedState != PED_DEAD )
  {
    CWeapon::Update(&this->m_WeaponSlots[this->m_nCurrentWeapon], 0);
    if ( this->m_nPedState != PED_DIE )
      sub_18FD48(&this->m_WeaponSlots[this->m_nCurrentWeapon], 0);
  }
}

//----- (0049EE4C) --------------------------------------------------------
bool __fastcall CEmergencyPed::InRange(CEmergencyPed *this, CPed *pInjuredPed)
{
  CVehicle *m_pMyVehicle; // r0
  CMatrix *m_pMat; // r2
  CMatrix *v4; // r12
  CSimpleTransform *p_tx; // r3
  CSimpleTransform *p_m_transform; // r1
  float32x2_t v7; // d16
  unsigned __int64 v8; // d1

  m_pMyVehicle = this->m_pMyVehicle;
  if ( !m_pMyVehicle )
    return 1;
  m_pMat = pInjuredPed->m_pMat;
  v4 = m_pMyVehicle->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &pInjuredPed->m_transform;
  p_m_transform = (CSimpleTransform *)&v4->tx;
  if ( !v4 )
    p_m_transform = &m_pMyVehicle->m_transform;
  v7.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.y, *(float32x2_t *)&p_tx->m_translate.y).n64_u64[0];
  v8 = vmul_f32(v7, v7).n64_u64[0];
  return sqrtf(
           (float)((float)((float)(p_m_transform->m_translate.x - p_tx->m_translate.x)
                         * (float)(p_m_transform->m_translate.x - p_tx->m_translate.x))
                 + *(float *)&v8)
         + *((float *)&v8 + 1)) <= 30.0;
}

//----- (0049EEB0) --------------------------------------------------------
void __fastcall CEmergencyPed::~CEmergencyPed(CEmergencyPed *this)
{
  void *v1; // r0

  CPed::~CPed(this);
  sub_19B93C(v1);
}
// 49EEBC: variable 'v1' is possibly undefined

//----- (0049EEC0) --------------------------------------------------------
void __fastcall CGangs::SetWillAttackPlayerWithCops(ePedType pedType, bool b)
{
  unsigned __int32 v2; // r0

  v2 = pedType - 7;
  if ( v2 <= 9 )
    CGangs::GangAttackWithCops[v2] = b;
}

//----- (0049EED8) --------------------------------------------------------
bool __fastcall CGangs::GetWillAttackPlayerWithCops(ePedType pedType)
{
  unsigned __int32 v1; // r0

  v1 = pedType - 7;
  return v1 <= 9 && CGangs::GangAttackWithCops[v1];
}

//----- (0049EEF8) --------------------------------------------------------
void __fastcall CGangInfo::CGangInfo(CGangInfo *this)
{
  this->PedModelOverride = -1;
  this->FirstWeapon = WEAPONTYPE_UNARMED;
  this->SecondWeapon = WEAPONTYPE_UNARMED;
  this->ThirdWeapon = WEAPONTYPE_UNARMED;
}

//----- (0049EF08) --------------------------------------------------------
void CGangs::Initialise()
{
  CGangs::Gang[0].FirstWeapon = WEAPONTYPE_PISTOL;
  CGangs::Gang[0].SecondWeapon = WEAPONTYPE_MICRO_UZI;
  CGangs::Gang[0].ThirdWeapon = WEAPONTYPE_UNARMED;
  *(_QWORD *)&CGangs::Gang[1].FirstWeapon = 22LL;
  CGangs::Gang[1].ThirdWeapon = WEAPONTYPE_UNARMED;
  *(_QWORD *)&CGangs::Gang[2].FirstWeapon = 22LL;
  CGangs::Gang[2].ThirdWeapon = WEAPONTYPE_UNARMED;
  CGangs::Gang[4].FirstWeapon = WEAPONTYPE_PISTOL;
  CGangs::Gang[4].SecondWeapon = WEAPONTYPE_MICRO_UZI;
  CGangs::Gang[4].ThirdWeapon = WEAPONTYPE_UNARMED;
  CGangs::Gang[5].FirstWeapon = WEAPONTYPE_DESERT_EAGLE;
  CGangs::Gang[5].SecondWeapon = WEAPONTYPE_UNARMED;
  CGangs::Gang[5].ThirdWeapon = WEAPONTYPE_UNARMED;
  CGangs::Gang[6].FirstWeapon = WEAPONTYPE_PISTOL;
  CGangs::Gang[6].SecondWeapon = WEAPONTYPE_AK47;
  CGangs::Gang[6].ThirdWeapon = WEAPONTYPE_UNARMED;
  CGangs::Gang[7].FirstWeapon = WEAPONTYPE_PISTOL;
  CGangs::Gang[7].SecondWeapon = WEAPONTYPE_MICRO_UZI;
  CGangs::Gang[7].ThirdWeapon = WEAPONTYPE_UNARMED;
}

//----- (0049EF4C) --------------------------------------------------------
void __fastcall CGangs::SetGangWeapons(Int16 GangIndex, Int32 FirstWeap, Int32 SecondWeap, Int32 ThirdWeap)
{
  if ( FirstWeap >= 0 )
    CGangs::Gang[GangIndex].FirstWeapon = FirstWeap;
  if ( SecondWeap >= 0 )
    CGangs::Gang[GangIndex].SecondWeapon = SecondWeap;
  if ( ThirdWeap >= 0 )
    CGangs::Gang[GangIndex].ThirdWeapon = ThirdWeap;
}

//----- (0049EF94) --------------------------------------------------------
void __fastcall CGangs::SetGangPedModelOverride(Int16 GangIndex, Int8 PedModOverride)
{
  CGangs::Gang[GangIndex].PedModelOverride = PedModOverride;
}

//----- (0049EFA4) --------------------------------------------------------
uint32 __fastcall CGangs::ChooseGangPedModel(Int16 GangIndex)
{
  int v1; // r2
  int v2; // r0
  uint32 result; // r0
  int v4; // r9
  Int32 v5; // r4

  v1 = GangIndex;
  v2 = GangIndex + 18;
  if ( (unsigned __int8)CGangs::Gang[v1].PedModelOverride != 255 )
    return CPopulation::m_PedGroups[CPopulation::m_TranslationArray[v2][CPopulation::CurrentWorldZone]][0];
  v4 = v2;
  CCarCtrl::InitSequence(CPopulation::m_nNumPedsInGroup[CPopulation::m_TranslationArray[v2][0]]);
  if ( CPopulation::m_nNumPedsInGroup[CPopulation::m_TranslationArray[v4][0]] < 1 )
    return -1;
  v5 = 0;
  while ( 1 )
  {
    result = CPopulation::m_PedGroups[CPopulation::m_TranslationArray[v4][CPopulation::CurrentWorldZone]][CCarCtrl::FindSequenceElement(v5)];
    if ( CStreaming::ms_aInfoForModel[result].m_status == 1 )
      break;
    if ( ++v5 >= CPopulation::m_nNumPedsInGroup[CPopulation::m_TranslationArray[v4][0]] )
      return -1;
  }
  return result;
}

//----- (0049F0B0) --------------------------------------------------------
void __fastcall CPed::CPed(CPed *this, uint32 pedType)
{
  CEntity::CEntityInfo m_info; // r0
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r1
  bool v6; // zf
  int v7; // r0
  int v8; // r2
  int v9; // r3
  CPedIntelligence *m_pPedIntelligence; // r8
  CTaskComplexFacial *v11; // r6
  CTaskSimpleStandStill *v12; // r6
  __int64 v13; // kr00_8
  uint32 PedFlag; // r0
  CPlayerPed *PlayerPed; // r0
  CEventAcquaintancePed v16; // [sp+4h] [bp-3Ch] BYREF

  CPhysical::CPhysical(this);
  this->m_PedAudioEntity.ScratchSound.m_pPhysicalEntity = 0;
  this->m_PedAudioEntity.m_ShirtFlapTwinLoopSound.ScratchSound.m_pPhysicalEntity = 0;
  this->m_PedAudioEntity.m_ShirtFlapTwinLoopSound.m_pFirstSoundPtr = 0;
  this->m_PedAudioEntity.m_ShirtFlapTwinLoopSound.m_pSecondSoundPtr = 0;
  this->m_PedAudioEntity.m_ShirtFlapTwinLoopSound.m_bCurrentlyInUse = 0;
  this->m_PedAudioEntity.m_pParentPed = 0;
  this->m_PedAudioEntity.m_pJetPackThrustSound = 0;
  this->m_PedAudioEntity.m_pJetPackGasSound = 0;
  this->m_PedAudioEntity.m_pJetPackRoarSound = 0;
  this->m_PedAudioEntity.m_bInitialised = 0;
  this->_vptr$CPlaceable = (int (**)(void))&off_668C58;
  this->m_PedAudioEntity._vptr$CAEAudioEntity = (int (**)(void))&off_6677EC;
  this->m_PedAudioEntity.m_ShirtFlapTwinLoopSound._vptr$CAEAudioEntity = (int (**)(void))&off_6678F0;
  CAEPedSpeechAudioEntity::CAEPedSpeechAudioEntity(&this->m_PedSpeechAudioEntity);
  *(_QWORD *)&this->m_PedWeaponAudioEntity.m_nLastMiniGunFireTimeMs = 0LL;
  *(_QWORD *)&this->m_PedWeaponAudioEntity.m_nLastGunFireTimeMs = 0LL;
  *(_QWORD *)&this->m_PedWeaponAudioEntity.m_nLastFlameThrowerFireTimeMs = 0LL;
  *(_QWORD *)&this->m_PedWeaponAudioEntity.m_nLastFireExtFireTimeMs = 0LL;
  *(_QWORD *)&this->m_acquaintances.m_nAcquaintances[1] = 0LL;
  *(_QWORD *)&this->m_acquaintances.m_nAcquaintances[3] = 0LL;
  this->m_extractedVelocity = 0LL;
  *(_QWORD *)this->m_acquaintances.m_nAcquaintances = 0LL;
  this->m_PedWeaponAudioEntity.m_bMiniGunSpinActive = 0;
  *(_WORD *)&this->m_PedWeaponAudioEntity.m_bMiniGunFireActive = 0;
  this->m_PedWeaponAudioEntity.ScratchSound.m_pPhysicalEntity = 0;
  this->m_PedWeaponAudioEntity._vptr$CAEAudioEntity = (int (**)(void))&off_668DDC;
  this->m_PedWeaponAudioEntity.m_pParentPed = 0;
  this->m_PedWeaponAudioEntity.m_bInitialised = 0;
  CPedIK::CPedIK(&this->m_ik, this);
  this->m_nHealth = 100.0;
  this->m_nMaxHealth = 100.0;
  this->m_nArmour = 0.0;
  this->m_nPedType = pedType;
  this->m_WeaponSlots[0].m_pWeaponFxSys = 0;
  *(_WORD *)&this->m_WeaponSlots[0].m_bFirstPersonWeaponModeSelected = 0;
  this->m_WeaponSlots[1].m_pWeaponFxSys = 0;
  *(_WORD *)&this->m_WeaponSlots[1].m_bFirstPersonWeaponModeSelected = 0;
  this->m_WeaponSlots[2].m_pWeaponFxSys = 0;
  *(_WORD *)&this->m_WeaponSlots[2].m_bFirstPersonWeaponModeSelected = 0;
  this->m_WeaponSlots[3].m_pWeaponFxSys = 0;
  *(_WORD *)&this->m_WeaponSlots[3].m_bFirstPersonWeaponModeSelected = 0;
  this->m_WeaponSlots[4].m_pWeaponFxSys = 0;
  *(_WORD *)&this->m_WeaponSlots[4].m_bFirstPersonWeaponModeSelected = 0;
  this->m_WeaponSlots[5].m_pWeaponFxSys = 0;
  *(_WORD *)&this->m_WeaponSlots[5].m_bFirstPersonWeaponModeSelected = 0;
  this->m_WeaponSlots[6].m_pWeaponFxSys = 0;
  *(_WORD *)&this->m_WeaponSlots[6].m_bFirstPersonWeaponModeSelected = 0;
  this->m_WeaponSlots[7].m_pWeaponFxSys = 0;
  *(_WORD *)&this->m_WeaponSlots[7].m_bFirstPersonWeaponModeSelected = 0;
  *(_WORD *)&this->m_WeaponSlots[8].m_bFirstPersonWeaponModeSelected = 0;
  this->m_WeaponSlots[8].m_pWeaponFxSys = 0;
  *(_WORD *)&this->m_WeaponSlots[9].m_bFirstPersonWeaponModeSelected = 0;
  this->m_WeaponSlots[9].m_pWeaponFxSys = 0;
  *(_WORD *)&this->m_WeaponSlots[10].m_bFirstPersonWeaponModeSelected = 0;
  this->m_WeaponSlots[10].m_pWeaponFxSys = 0;
  *(_WORD *)&this->m_WeaponSlots[11].m_bFirstPersonWeaponModeSelected = 0;
  this->m_WeaponSlots[11].m_pWeaponFxSys = 0;
  this->m_WeaponSlots[12].m_pWeaponFxSys = 0;
  *(_WORD *)&this->m_WeaponSlots[12].m_bFirstPersonWeaponModeSelected = 0;
  *(_QWORD *)&this->m_nUnconsciousTimer = 0LL;
  *(_QWORD *)&this->m_nAttackTimer = 0LL;
  *(_QWORD *)&this->m_pGroundPhysical = 0LL;
  *(_QWORD *)&this->m_vecGroundOffset.y = 0LL;
  this->CharCreatedBy = 1;
  this->m_pMyVehicle = 0;
  this->m_nAntiSpazTimer = 0;
  this->m_vecCurrentVelocity.x = 0.0;
  this->m_vecCurrentVelocity.y = 0.0;
  this->m_fCurrentHeading = 0.0;
  this->m_fDesiredHeading = 0.0;
  this->m_fHeadingChangeRate = 15.0;
  this->m_fHeadingChangeRateAccel = 0.1;
  this->m_vecGroundNormal.y = 0.0;
  this->m_vecGroundNormal.x = 0.0;
  this->m_vecGroundNormal.z = 1.0;
  this->m_pAccident = 0;
  this->m_nShootRate = 40;
  this->m_pNOCollisionVehicle = 0;
  this->m_nPedState = PED_IDLE;
  this->m_eMoveState = PEDMOVE_STILL;
  this->m_eMoveStateAnim = PEDMOVE_NONE;
  this->m_pEntLockOnTarget = 0;
  this->m_pEntMagnetizeTarget = 0;
  this->m_pFire = 0;
  this->FireDamageMultiplier = 1.0;
  this->m_pEntLookEntity = 0;
  this->m_fLookHeading = 0.0;
  this->m_pEntityStandingOn = 0;
  this->m_fHitHeadHeight = 100000.0;
  this->m_fMass = 70.0;
  this->m_fTurnMass = 100.0;
  *(_QWORD *)&this->m_fAirResistance = 0x3D4CCCCD3BBB3EE7LL;
  m_info = this->m_info;
  this->m_nLimbRemoveIndex = -1;
  m_nPhysicalFlags = this->m_nPhysicalFlags;
  this->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&m_info & 0xF8 | 3);
  this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags | 0x10000010);
  *(_DWORD *)&this->m_nPedFlags = *(_DWORD *)&this->m_nPedFlags & 0xFFFE0000 | 0x2000;
  v6 = (rand() & 3) == 0;
  v7 = 0;
  v8 = *((_DWORD *)&this->m_nPedFlags + 2);
  v9 = *((_DWORD *)&this->m_nPedFlags + 3);
  if ( v6 )
    v7 = 1;
  *(_DWORD *)&this->m_nPedFlags = *(_DWORD *)&this->m_nPedFlags & 0x1FFFF | (v7 << 17) | 0x80000000;
  *((_DWORD *)&this->m_nPedFlags + 1) = 101711872;
  *((_DWORD *)&this->m_nPedFlags + 2) = v8 & 0x20000000 | 0x4000000;
  *((_DWORD *)&this->m_nPedFlags + 3) = v9 & 0xFFE00020 | 0x21000;
  CAEPedWeaponAudioEntity::Initialise(&this->m_PedWeaponAudioEntity, this);
  CAEPedAudioEntity::Initialise(&this->m_PedAudioEntity, this);
  this->m_acquaintances = *CPedType::GetPedTypeAcquaintances(this->m_nPedType);
  this->m_eStoredWeapon = WEAPONTYPE_UNIDENTIFIED;
  this->m_eDelayedWeapon = WEAPONTYPE_UNIDENTIFIED;
  this->m_nCurrentWeapon = 0;
  *(_QWORD *)&this->m_WeaponSlots[0].m_eWeaponType = 0LL;
  *(_QWORD *)&this->m_WeaponSlots[0].m_nAmmoInClip = 0LL;
  this->m_WeaponSlots[1].m_nTimer = 0;
  this->m_WeaponSlots[0].m_nTimer = 0;
  *(_QWORD *)&this->m_WeaponSlots[1].m_eWeaponType = 0LL;
  *(_QWORD *)&this->m_WeaponSlots[1].m_nAmmoInClip = 0LL;
  *(_QWORD *)&this->m_WeaponSlots[2].m_eWeaponType = 0LL;
  *(_QWORD *)&this->m_WeaponSlots[2].m_nAmmoInClip = 0LL;
  *(_QWORD *)&this->m_WeaponSlots[3].m_eWeaponType = 0LL;
  *(_QWORD *)&this->m_WeaponSlots[3].m_nAmmoInClip = 0LL;
  *(_QWORD *)&this->m_WeaponSlots[4].m_eWeaponType = 0LL;
  *(_QWORD *)&this->m_WeaponSlots[4].m_nAmmoInClip = 0LL;
  *(_QWORD *)&this->m_WeaponSlots[5].m_eWeaponType = 0LL;
  *(_QWORD *)&this->m_WeaponSlots[5].m_nAmmoInClip = 0LL;
  *(_QWORD *)&this->m_WeaponSlots[6].m_eWeaponType = 0LL;
  *(_QWORD *)&this->m_WeaponSlots[6].m_nAmmoInClip = 0LL;
  this->m_WeaponSlots[2].m_nTimer = 0;
  this->m_WeaponSlots[3].m_nTimer = 0;
  this->m_WeaponSlots[4].m_nTimer = 0;
  this->m_WeaponSlots[5].m_nTimer = 0;
  *(_QWORD *)&this->m_WeaponSlots[7].m_eWeaponType = 0LL;
  *(_QWORD *)&this->m_WeaponSlots[7].m_nAmmoInClip = 0LL;
  this->m_WeaponSlots[6].m_nTimer = 0;
  this->m_WeaponSlots[7].m_nTimer = 0;
  *(_QWORD *)&this->m_WeaponSlots[8].m_eWeaponType = 0LL;
  *(_QWORD *)&this->m_WeaponSlots[8].m_nAmmoInClip = 0LL;
  this->m_WeaponSlots[8].m_nTimer = 0;
  *(_QWORD *)&this->m_WeaponSlots[9].m_eWeaponType = 0LL;
  *(_QWORD *)&this->m_WeaponSlots[9].m_nAmmoInClip = 0LL;
  this->m_WeaponSlots[9].m_nTimer = 0;
  *(_QWORD *)&this->m_WeaponSlots[10].m_eWeaponType = 0LL;
  *(_QWORD *)&this->m_WeaponSlots[10].m_nAmmoInClip = 0LL;
  this->m_WeaponSlots[10].m_nTimer = 0;
  *(_QWORD *)&this->m_WeaponSlots[11].m_eWeaponType = 0LL;
  *(_QWORD *)&this->m_WeaponSlots[11].m_nAmmoInClip = 0LL;
  this->m_WeaponSlots[11].m_nTimer = 0;
  *(_QWORD *)&this->m_WeaponSlots[12].m_eWeaponType = 0LL;
  *(_QWORD *)&this->m_WeaponSlots[12].m_nAmmoInClip = 0LL;
  this->m_WeaponSlots[12].m_nTimer = 0;
  this->m_nExtraMeleeComboFlags = 0;
  *(_WORD *)&this->m_nWeaponSkill = 1025;
  CPed::GiveWeapon(this, WEAPONTYPE_UNARMED, 0, 0);
  this->m_nShootingAccuracy = 60;
  this->LastDamagedWeaponType = -1;
  this->pLastDamageEntity = 0;
  this->LastDamagedTime = 0;
  this->m_pAttachToEntity = 0;
  this->m_storedCollPoly.bValidPolyStored = 0;
  this->WeaponModelInHand = -1;
  this->m_distTravelledSinceLastHeightCheck = 0.0;
  this->DontUseSmallerRemovalRange = 0;
  this->m_pMyAccidentVehicle = 0;
  this->m_nOriginalWeaponAmmo = 0;
  this->m_pCoverPoint = 0;
  this->m_pLastEntryExit = 0;
  this->m_MoneyCarried = 0;
  this->BleedingFrames = 0;
  *(_DWORD *)&this->m_nGunFlashBlendAmount = 0;
  *(_DWORD *)&this->m_nGunFlashBlendAmount2 = 0;
  *(_QWORD *)&this->m_pWeaponClump = 0LL;
  *(_QWORD *)&this->m_pGogglesClump = 0LL;
  this->LastTalkSfx = -1;
  m_pPedIntelligence = (CPedIntelligence *)CPedIntelligence::operator new(0x298u);
  CPedIntelligence::CPedIntelligence(m_pPedIntelligence, this);
  this->m_pPedIntelligence = m_pPedIntelligence;
  this->m_pPlayerData = 0;
  if ( this->m_nPedType >= 2u )
  {
    v11 = (CTaskComplexFacial *)CTask::operator new(0x20u);
    CTaskComplexFacial::CTaskComplexFacial(v11);
    CTaskManager::SetTaskSecondary(&m_pPedIntelligence->m_taskManager, v11, 3);
    m_pPedIntelligence = this->m_pPedIntelligence;
  }
  v12 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
  CTaskSimpleStandStill::CTaskSimpleStandStill(v12, 0, 1, 0, 8.0);
  CTaskManager::SetTask(&m_pPedIntelligence->m_taskManager, v12, 4, 0);
  this->fRemoveRangeMultiplier = 1.0;
  this->m_wobble = 0.0;
  this->StreamedScriptBrainToLoad = -1;
  CPopulation::UpdatePedCount(this, 0);
  v13 = *((_QWORD *)&this->m_nPedFlags + 1);
  *((_DWORD *)&this->m_nPedFlags + 2) = v13 & 0xDFFFFFFF;
  *((_DWORD *)&this->m_nPedFlags + 3) = HIDWORD(v13) & 0xFFFFFFDF;
  if ( CCheat::m_aCheatsActive[22] )
  {
    if ( this->m_nPedType >= 2u )
    {
      PedFlag = CPedType::GetPedFlag(0);
      CAcquaintance::SetAsAcquaintance(&this->m_acquaintances, 4, PedFlag);
      PlayerPed = FindPlayerPed(-1);
      CEventAcquaintancePed::CEventAcquaintancePed(&v16, PlayerPed);
      v16.m_iTaskType = 1000;
      v16._vptr$CEvent = (int (**)(void))&off_665394;
      CEventGroup::Add(&this->m_pPedIntelligence->m_eventGroup, (CEvent *)&v16, 0);
      CEventAcquaintancePed::~CEventAcquaintancePed(&v16);
    }
  }
}
// 665394: using guessed type void *;
// 6677EC: using guessed type void *;
// 6678F0: using guessed type void *off_6678F0;
// 668C58: using guessed type void *;
// 668DDC: using guessed type void *;

//----- (0049F588) --------------------------------------------------------
int32 __fastcall CPed::GiveWeapon(
        CPed *this,
        eWeaponType weaponType,
        UInt32 ammoQuantity,
        bool GenerateOldWeaponPickup)
{
  int32 m_nWeaponSlot; // r4
  char *v8; // r5
  eWeaponType v9; // r0
  CWeaponInfo *WeaponInfo; // r0
  int32 v11; // r11
  int m_nCurrentWeapon; // r0
  bool v13; // zf
  CWeaponInfo *v14; // r0
  UInt32 v15; // r1

  m_nWeaponSlot = CWeaponInfo::GetWeaponInfo(weaponType, 1)->m_nWeaponSlot;
  if ( m_nWeaponSlot == -1 )
    return 0;
  v8 = (char *)this + 28 * m_nWeaponSlot;
  v9 = *((_DWORD *)v8 + 361);
  if ( v9 == weaponType )
  {
    if ( m_nWeaponSlot == 10 )
      return 10;
    v15 = 99999;
    if ( (int)(*((_DWORD *)v8 + 364) + ammoQuantity) < 99999 )
      v15 = *((_DWORD *)v8 + 364) + ammoQuantity;
    *((_DWORD *)v8 + 364) = v15;
    CWeapon::Reload((CWeapon *)(v8 + 1444), this);
    if ( *((_DWORD *)v8 + 362) == 3 && *((int *)v8 + 364) >= 1 )
      *((_DWORD *)v8 + 362) = 0;
  }
  else
  {
    if ( v9 )
    {
      if ( (unsigned int)(m_nWeaponSlot - 3) <= 2 )
        ammoQuantity += *((_DWORD *)v8 + 364);
      WeaponInfo = CWeaponInfo::GetWeaponInfo(v9, 1);
      CPed::RemoveWeaponModel(this, WeaponInfo->m_modelId);
      v11 = CWeaponInfo::GetWeaponInfo(weaponType, 1)->m_nWeaponSlot;
      if ( v11 == CWeaponInfo::GetWeaponInfo(WEAPONTYPE_INFRARED, 1)->m_nWeaponSlot )
        CPed::RemoveGogglesModel(this);
      CWeapon::Shutdown((CWeapon *)(v8 + 1444));
    }
    CWeapon::Initialise((CWeapon *)(v8 + 1444), weaponType, ammoQuantity, this);
    m_nCurrentWeapon = this->m_nCurrentWeapon;
    v13 = m_nWeaponSlot == m_nCurrentWeapon;
    if ( m_nWeaponSlot == m_nCurrentWeapon )
      v13 = *((unsigned __int8 *)&this->m_nPedFlags + 1) << 31 == 0;
    if ( v13 )
    {
      v14 = CWeaponInfo::GetWeaponInfo(*((eWeaponType *)v8 + 361), 1);
      CPed::AddWeaponModel(this, v14->m_modelId);
    }
  }
  if ( *((_DWORD *)v8 + 362) != 3 )
    *((_DWORD *)v8 + 362) = 0;
  return m_nWeaponSlot;
}

//----- (0049F68E) --------------------------------------------------------
bool __fastcall CPed::IsPlayer(const CPed *this)
{
  int32 m_nPedType; // r0

  m_nPedType = this->m_nPedType;
  if ( m_nPedType )
  {
    if ( m_nPedType != 1 )
      LOBYTE(m_nPedType) = 0;
  }
  else
  {
    LOBYTE(m_nPedType) = 1;
  }
  return m_nPedType;
}

//----- (0049F6A4) --------------------------------------------------------
void __fastcall CPed::~CPed(CPed *this)
{
  int v2; // r1
  CPedFlags *p_m_nPedFlags; // r5
  CVehicle *m_pMyVehicle; // r0
  CFire *m_pFire; // r0
  CCoverPoint *m_pCoverPoint; // r0
  CPedIntelligence *m_pPedIntelligence; // r0
  void *v8; // r0
  CEntity *m_pEntLookEntity; // r0

  v2 = *((unsigned __int8 *)&this->m_nPedFlags + 11);
  p_m_nPedFlags = &this->m_nPedFlags;
  this->_vptr$CPlaceable = (int (**)(void))&off_668C58;
  if ( v2 << 31 )
  {
    CStreaming::SetMissionDoesntRequireModel(CTheScripts::ScriptsForBrains.ScriptBrainArray[this->StreamedScriptBrainToLoad].StreamedScriptIndex + 26230);
    *((_DWORD *)p_m_nPedFlags + 2) &= ~0x1000000u;
    CTheScripts::RemoveFromWaitingForScriptBrainArray(this, this->StreamedScriptBrainToLoad);
    this->StreamedScriptBrainToLoad = -1;
  }
  CWorld::Remove(this);
  CRadar::ClearBlipForEntity(
    BLIPTYPE_CHAR,
    CPools::ms_pPedPool->m_aFlags[-1093107909 * (((char *)this - (char *)CPools::ms_pPedPool->m_aStorage) >> 2)] | (-662750464 * (((char *)this - (char *)CPools::ms_pPedPool->m_aStorage) >> 2)));
  CConversations::RemoveConversationForPed(this);
  m_pMyVehicle = this->m_pMyVehicle;
  if ( m_pMyVehicle )
    CEntity::CleanUpOldReference(m_pMyVehicle, &this->m_pMyVehicle);
  m_pFire = this->m_pFire;
  this->m_pMyVehicle = 0;
  if ( m_pFire )
    CFire::Extinguish(m_pFire);
  m_pCoverPoint = this->m_pCoverPoint;
  if ( m_pCoverPoint )
  {
    CCoverPoint::ReleaseCoverPointForPed(m_pCoverPoint, this);
    this->m_pCoverPoint = 0;
  }
  CPed::ClearWeapons(this);
  if ( *((unsigned __int8 *)p_m_nPedFlags + 6) << 31 )
    --CPopulation::NumMiamiViceCops;
  CPopulation::UpdatePedCount(this, 1u);
  CAEPedSpeechAudioEntity::Terminate(&this->m_PedSpeechAudioEntity);
  CAEPedWeaponAudioEntity::Terminate(&this->m_PedWeaponAudioEntity);
  CAEPedAudioEntity::Terminate(&this->m_PedAudioEntity);
  m_pPedIntelligence = this->m_pPedIntelligence;
  if ( m_pPedIntelligence )
  {
    CPedIntelligence::~CPedIntelligence(m_pPedIntelligence);
    CPedIntelligence::operator delete(v8);
  }
  m_pEntLookEntity = this->m_pEntLookEntity;
  if ( m_pEntLookEntity )
    CEntity::CleanUpOldReference(m_pEntLookEntity, &this->m_pEntLookEntity);
  this->m_PedWeaponAudioEntity._vptr$CAEAudioEntity = (int (**)(void))&off_667798;
  CAESound::~CAESound(&this->m_PedWeaponAudioEntity.ScratchSound);
  this->m_PedSpeechAudioEntity._vptr$CAEAudioEntity = (int (**)(void))&off_667798;
  CAESound::~CAESound(&this->m_PedSpeechAudioEntity.ScratchSound);
  this->m_PedAudioEntity._vptr$CAEAudioEntity = (int (**)(void))&off_6677EC;
  CAETwinLoopSoundEntity::~CAETwinLoopSoundEntity(&this->m_PedAudioEntity.m_ShirtFlapTwinLoopSound);
  this->m_PedAudioEntity._vptr$CAEAudioEntity = (int (**)(void))&off_667798;
  CAESound::~CAESound(&this->m_PedAudioEntity.ScratchSound);
  sub_194468(this);
}
// 49F79E: variable 'v8' is possibly undefined
// 667798: using guessed type void *off_667798;
// 6677EC: using guessed type void *off_6677EC;
// 668C58: using guessed type void *off_668C58;
// 676C84: using guessed type int CPools::ms_pPedPool[2];

//----- (0049F818) --------------------------------------------------------
void __fastcall CPed::ReleaseCoverPoint(CPed *this)
{
  CCoverPoint *m_pCoverPoint; // r0

  m_pCoverPoint = this->m_pCoverPoint;
  if ( m_pCoverPoint )
  {
    CCoverPoint::ReleaseCoverPointForPed(m_pCoverPoint, this);
    this->m_pCoverPoint = 0;
  }
}

//----- (0049F836) --------------------------------------------------------
void __fastcall CPed::ClearWeapons(CPed *this)
{
  int m_nWeaponSlot; // r1

  CPed::RemoveWeaponModel(this, -1);
  CPed::RemoveGogglesModel(this);
  CWeapon::Shutdown(this->m_WeaponSlots);
  CWeapon::Shutdown(&this->m_WeaponSlots[1]);
  CWeapon::Shutdown(&this->m_WeaponSlots[2]);
  CWeapon::Shutdown(&this->m_WeaponSlots[3]);
  CWeapon::Shutdown(&this->m_WeaponSlots[4]);
  CWeapon::Shutdown(&this->m_WeaponSlots[5]);
  CWeapon::Shutdown(&this->m_WeaponSlots[6]);
  CWeapon::Shutdown(&this->m_WeaponSlots[7]);
  CWeapon::Shutdown(&this->m_WeaponSlots[8]);
  CWeapon::Shutdown(&this->m_WeaponSlots[9]);
  CWeapon::Shutdown(&this->m_WeaponSlots[10]);
  CWeapon::Shutdown(&this->m_WeaponSlots[11]);
  CWeapon::Shutdown(&this->m_WeaponSlots[12]);
  m_nWeaponSlot = CWeaponInfo::GetWeaponInfo(WEAPONTYPE_UNARMED, 1)->m_nWeaponSlot;
  CPed::SetCurrentWeapon(this, m_nWeaponSlot);
}

//----- (0049F8C8) --------------------------------------------------------
void __fastcall CPed::~CPed(CPed *this)
{
  CPedPool *v1; // r1
  int v2; // r0
  int v3; // r0

  CPed::~CPed(this);
  v1 = CPools::ms_pPedPool;
  v3 = -1093107909 * ((signed int)(v2 - (unsigned int)CPools::ms_pPedPool->m_aStorage) >> 2);
  CPools::ms_pPedPool->m_aFlags[v3] |= 0x80u;
  if ( v3 < v1->m_nFreeIndex )
    v1->m_nFreeIndex = v3;
}
// 49F8DC: variable 'v2' is possibly undefined
// 676C84: using guessed type int CPools::ms_pPedPool[2];

//----- (0049F900) --------------------------------------------------------
void __fastcall CPed::operator delete(void *pVoid)
{
  CPedPool *v1; // r1
  int v2; // r0

  v1 = CPools::ms_pPedPool;
  v2 = -1093107909 * ((signed int)((int)pVoid - (unsigned int)CPools::ms_pPedPool->m_aStorage) >> 2);
  CPools::ms_pPedPool->m_aFlags[v2] |= 0x80u;
  if ( v2 < v1->m_nFreeIndex )
    v1->m_nFreeIndex = v2;
}

//----- (0049F930) --------------------------------------------------------
void *__fastcall CPed::operator new(size_t nSize)
{
  int v1; // lr
  CPedPool *v2; // r1
  void *result; // r0
  void *m_nSize; // r12
  uint8 *m_aFlags; // r2
  int v6; // r3

  v1 = 0;
  v2 = CPools::ms_pPedPool;
  result = (void *)CPools::ms_pPedPool->m_nFreeIndex;
  m_nSize = (void *)CPools::ms_pPedPool->m_nSize;
  do
  {
    result = (char *)result + 1;
    v2->m_nFreeIndex = (int32)result;
    if ( result == m_nSize )
    {
      result = 0;
      v2->m_nFreeIndex = 0;
      if ( v1 << 31 )
        return result;
      v1 = 1;
    }
    m_aFlags = v2->m_aFlags;
    v6 = *((char *)result + (_DWORD)m_aFlags);
  }
  while ( v6 > -1 );
  *((_BYTE *)result + (_DWORD)m_aFlags) = v6 & 0x7F;
  v2->m_aFlags[v2->m_nFreeIndex] = (v2->m_aFlags[v2->m_nFreeIndex] + 1) & 0x7F | v2->m_aFlags[v2->m_nFreeIndex] & 0x80;
  return v2->m_aStorage[v2->m_nFreeIndex];
}

//----- (0049F994) --------------------------------------------------------
void *__fastcall CPed::operator new(size_t nSize, int32 index)
{
  int32 v2; // r4
  CPedPool *v3; // r2
  __int64 v4; // kr00_8
  int32 v5; // r0
  uint8 *m_aFlags; // r1
  int v7; // r3

  v2 = index >> 8;
  v3 = CPools::ms_pPedPool;
  v4 = *(_QWORD *)&CPools::ms_pPedPool->m_aStorage;
  CPools::ms_pPedPool->m_aFlags[v2] &= ~0x80u;
  v3->m_aFlags[v2] = v3->m_aFlags[index >> 8] & 0x80 | index & 0x7F;
  v5 = 0;
  m_aFlags = v3->m_aFlags;
  do
  {
    v3->m_nFreeIndex = v5;
    v7 = (char)m_aFlags[v5++];
  }
  while ( v7 > -1 );
  return (void *)(v4 + 1996 * v2);
}

//----- (0049F9E8) --------------------------------------------------------
void __fastcall CPed::operator delete(void *pVoid, int32 index)
{
  CPedPool *v2; // r1
  int v3; // r0

  v2 = CPools::ms_pPedPool;
  v3 = -1093107909 * ((signed int)((int)pVoid - (unsigned int)CPools::ms_pPedPool->m_aStorage) >> 2);
  CPools::ms_pPedPool->m_aFlags[v3] |= 0x80u;
  if ( v3 < v2->m_nFreeIndex )
    v2->m_nFreeIndex = v3;
}

//----- (0049FA18) --------------------------------------------------------
void CPed::Initialise()
{
  CPedType::Initialise();
  sub_199B2C();
}

//----- (0049FA28) --------------------------------------------------------
void __fastcall CPed::SetCharCreatedBy(CPed *this, const UInt8 a)
{
  unsigned int m_nPedType; // r0
  CPedIntelligence *m_pPedIntelligence; // r0
  int m_iDefaultDecisionMaker; // r1
  CPedIntelligence *v6; // r0

  m_nPedType = this->m_nPedType;
  this->CharCreatedBy = a;
  if ( m_nPedType > 1 )
  {
    m_pPedIntelligence = this->m_pPedIntelligence;
    if ( a == 2 )
      m_iDefaultDecisionMaker = -1;
    else
      m_iDefaultDecisionMaker = this->m_pPedStats->m_iDefaultDecisionMaker;
  }
  else
  {
    m_pPedIntelligence = this->m_pPedIntelligence;
    m_iDefaultDecisionMaker = -2;
  }
  CPedIntelligence::SetPedDecisionMakerType(m_pPedIntelligence, m_iDefaultDecisionMaker);
  if ( this->CharCreatedBy == 2 )
  {
    CPedIntelligence::SetSeeingRange(this->m_pPedIntelligence, 30.0);
    CPedIntelligence::SetHearingRange(this->m_pPedIntelligence, 30.0);
    if ( this->m_nPedType >= 2u )
    {
      v6 = this->m_pPedIntelligence;
      v6->m_iMaxNumFriendsToInform = 0;
      v6->m_fMaxInformFriendDistance = 0.0;
    }
  }
}

//----- (0049FA9C) --------------------------------------------------------
void __fastcall CPed::SetPedDefaultDecisionMaker(CPed *this)
{
  if ( this->m_nPedType > 1u )
  {
    if ( this->CharCreatedBy == 2 )
      sub_19EF84(this->m_pPedIntelligence, -1);
    else
      sub_19EF84(this->m_pPedIntelligence, this->m_pPedStats->m_iDefaultDecisionMaker);
  }
  else
  {
    sub_19EF84(this->m_pPedIntelligence, -2);
  }
}

//----- (0049FAD4) --------------------------------------------------------
void __fastcall CPed::SetModelIndex(CPed *this, uint32 index)
{
  CBaseModelInfo *v3; // r5
  int v4; // r1
  CPedStats *v5; // r2
  CPedStats *v6; // r0
  unsigned int m_nPedType; // r3
  CPedIntelligence *m_pPedIntelligence; // r0
  int m_iDefaultDecisionMaker; // r1
  int v10; // r0
  AssocGroupId m_hashKey; // r1
  RpClump_0 *m_pRwObject; // r0

  *(_DWORD *)&this->m_nFlags |= 0x80u;
  CEntity::SetModelIndex(this, index);
  RpAnimBlendClumpInit((RpClump_0 *)this->m_pRwObject);
  RpAnimBlendClumpFillFrameArray((RpClump_0 *)this->m_pRwObject, this->m_aPedFrames);
  v3 = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
  v4 = *(_DWORD *)&v3[1].m_modelName[4];
  v5 = CPedStats::ms_apPedStats;
  v6 = &CPedStats::ms_apPedStats[v4];
  m_nPedType = this->m_nPedType;
  this->m_pPedStats = v6;
  this->m_fHeadingChangeRate = v6->m_fMaxHeadingChange;
  if ( m_nPedType > 1 )
  {
    m_pPedIntelligence = this->m_pPedIntelligence;
    if ( this->CharCreatedBy == 2 )
      m_iDefaultDecisionMaker = -1;
    else
      m_iDefaultDecisionMaker = v5[v4].m_iDefaultDecisionMaker;
  }
  else
  {
    m_pPedIntelligence = this->m_pPedIntelligence;
    m_iDefaultDecisionMaker = -2;
  }
  CPedIntelligence::SetPedDecisionMakerType(m_pPedIntelligence, m_iDefaultDecisionMaker);
  if ( CPopCycle::IsPedInGroup(this->m_nModelIndex, 1) || CPopCycle::IsPedInGroup(this->m_nModelIndex, 6) )
    LOWORD(v10) = rand() % 50 + 20;
  else
    v10 = rand() % 25;
  this->m_MoneyCarried = v10;
  if ( (int)(float)((float)((float)(unsigned __int16)rand() * 0.000015259) * 100.0) <= 2 )
    this->m_MoneyCarried = 400;
  m_hashKey = v3[1].m_hashKey;
  m_pRwObject = (RpClump_0 *)this->m_pRwObject;
  this->m_motionAnimGroup = m_hashKey;
  CAnimManager::AddAnimation(m_pRwObject, m_hashKey, ANIM_STD_IDLE);
  if ( (this->m_nPedState | 8) == 58 || (*((_BYTE *)&this->m_nPedFlags + 3) & 4) != 0 )
    this->m_ik.m_flags |= 2u;
  *(_DWORD *)(*(_DWORD *)(&this->m_pRwObject->type + ClumpOffset) + 12) = &this->m_extractedVelocity;
  if ( !*(_DWORD *)&v3[1].m_modelName[12] )
    CPedModelInfo::CreateHitColModelSkinned((CPedModelInfo *)v3, (RpClump_0 *)this->m_pRwObject);
  sub_190518(this);
}

//----- (0049FC4C) --------------------------------------------------------
void __fastcall CPed::SetPedStats(CPed *this, ePedStats nIndex)
{
  this->m_pPedStats = &CPedStats::ms_apPedStats[nIndex];
}

//----- (0049FC64) --------------------------------------------------------
bool __fastcall CPed::CanUseTorsoWhenLooking(CPed *this)
{
  return (this->m_nPedState | 8) != 58 && (*((_BYTE *)&this->m_nPedFlags + 3) & 4) == 0;
}

//----- (0049FC8C) --------------------------------------------------------
bool __fastcall CPed::CanSeeEntity(CPed *this, CEntity *pEntity, float viewAngle)
{
  CMatrix *m_pMat; // r4
  CMatrix *v5; // r0
  CSimpleTransform *p_tx; // r6
  CSimpleTransform *p_m_transform; // r3
  __int64 v9; // r2
  float v10; // s2
  float m_fCurrentHeading; // s6
  char v12; // r1
  char v13; // r0
  float v14; // s2

  m_pMat = pEntity->m_pMat;
  v5 = this->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  p_m_transform = (CSimpleTransform *)&v5->tx;
  if ( !v5 )
    p_m_transform = &this->m_transform;
  v9 = *(_QWORD *)&p_m_transform->m_translate.x;
  if ( !m_pMat )
    p_tx = &pEntity->m_transform;
  v10 = (float)(CGeneral::GetAngleBetweenPoints(
                  p_tx->m_translate.x,
                  p_tx->m_translate.y,
                  *(float *)&v9,
                  *((float *)&v9 + 1))
              * 3.1416)
      / 180.0;
  if ( v10 <= 6.2832 )
  {
    if ( v10 < 0.0 )
      v10 = v10 + 6.2832;
  }
  else
  {
    v10 = v10 + -6.2832;
  }
  m_fCurrentHeading = this->m_fCurrentHeading;
  if ( m_fCurrentHeading <= 6.2832 )
  {
    if ( m_fCurrentHeading < 0.0 )
      m_fCurrentHeading = m_fCurrentHeading + 6.2832;
  }
  else
  {
    m_fCurrentHeading = m_fCurrentHeading + -6.2832;
  }
  v12 = 0;
  v13 = 0;
  v14 = fabsf(v10 - m_fCurrentHeading);
  if ( v14 > (float)(6.2832 - viewAngle) )
    v12 = 1;
  if ( v14 < viewAngle )
    v13 = 1;
  return v13 | v12;
}

//----- (0049FD70) --------------------------------------------------------
bool __fastcall CPed::PositionPedOutOfCollision(CPed *this, int nDoor, CVehicle *pVehicle, bool bUseNodes)
{
  float32x2_t v4; // d3
  float32x2_t v5; // d5
  CVehicle *m_pMyVehicle; // r4
  bool v8; // zf
  CColModel *ColModel; // r9
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  __int64 v13; // d16
  CMatrix *v14; // r0
  CSimpleTransform *p_m_transform; // r2
  float x; // s18
  float y; // s20
  float z; // s22
  int m_nFlags; // r8
  uint32 bdummy; // r1
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r1
  int v22; // r0
  bool v23; // zf
  __int64 v24; // kr00_8
  CMatrix *v25; // r3
  RwReal v26; // r0
  float *p_tz; // r1
  __int64 v28; // kr08_8
  float v29; // s0
  CMatrix *v30; // r2
  float *v31; // r0
  _BOOL4 v32; // r6
  bool v33; // zf
  int v34; // r2
  __int64 v35; // kr10_8
  CMatrix *v36; // r3
  RwReal v37; // r0
  float *p_z; // r1
  _BOOL4 IsLineOfSightClear; // r6
  float *p_xx; // r0
  float v41; // s0
  float v42; // s16
  float v43; // s10
  float v44; // s2
  float v45; // s4
  float v46; // s0
  float v47; // s2
  CMatrix *v48; // r0
  float *v49; // r0
  int v50; // r6
  float v51; // s18
  float v52; // s20
  float *v53; // r0
  float v54; // s0
  float v55; // s4
  float v56; // s2
  float v57; // s0
  CMatrix *v58; // r0
  float *v59; // r0
  float *v60; // r0
  float v61; // s0
  float v62; // s4
  float v63; // s2
  float v64; // s0
  CMatrix *v65; // r0
  float *v66; // r0
  float *v67; // r0
  float v68; // s0
  float v69; // s4
  float v70; // s2
  float v71; // s0
  CMatrix *v72; // r0
  float *v73; // r0
  float *v74; // r0
  float v75; // s12
  float v76; // s8
  float v77; // s6
  float v78; // s10
  float v79; // s12
  float v80; // s2
  float v81; // s4
  CMatrix *v82; // r0
  float *v83; // r0
  float *v84; // r0
  float v85; // s12
  float v86; // s8
  float v87; // s6
  float v88; // s10
  float v89; // s12
  float v90; // s2
  float v91; // s4
  CMatrix *v92; // r0
  float *v93; // r0
  _BOOL4 v94; // r6
  float *v96; // r0
  float v97; // s0
  float v98; // s6
  float v99; // s4
  float v100; // s2
  CMatrix *v101; // r0
  float *v102; // r0
  CNodeAddress *NodeClosestToCoors; // r8
  CNodeAddress *v104; // r0
  CPathNode *v105; // r2
  RwReal v106; // s4
  RwReal v107; // s0
  RwReal *v108; // r6
  unsigned int v109; // r1
  CPathNode *v110; // r2
  CPathNode *v111; // r0
  int CoorsX; // r3
  float v113; // s4
  float CoorsZ; // s6
  float v115; // r1
  CMatrix *v116; // r3
  RwReal v117; // r0
  _BOOL4 v118; // r0
  CMatrix *v119; // r0
  float m_heading; // s0
  CMatrix *v121; // r0
  _BOOL4 bIgnoreInteriors; // [sp+1Ch] [bp-9Ch]
  bool bIgnoreInteriorsa; // [sp+1Ch] [bp-9Ch]
  CVector *p_m_vecMoveSpeed; // [sp+20h] [bp-98h]
  CPedFlags *p_m_nPedFlags; // [sp+24h] [bp-94h]
  int v126; // [sp+28h] [bp-90h]
  CEntity::CFlags *p_m_nFlags; // [sp+2Ch] [bp-8Ch]
  CVector v128; // [sp+38h] [bp-80h] BYREF
  CVector vecEnd; // [sp+48h] [bp-70h] BYREF
  CVector vecStart; // [sp+58h] [bp-60h] BYREF
  CVector v131; // 0:r2.8,8:^0.4
  CVector v132; // 0:r2.8,8:^0.4

  m_pMyVehicle = pVehicle;
  v8 = pVehicle == 0;
  if ( !pVehicle )
  {
    m_pMyVehicle = this->m_pMyVehicle;
    v8 = m_pMyVehicle == 0;
  }
  if ( v8 )
  {
LABEL_89:
    LOBYTE(v94) = 0;
  }
  else
  {
    if ( (*((_DWORD *)&this->m_nPedFlags + 2) & 1) == 0 )
    {
      p_m_nPedFlags = &this->m_nPedFlags;
      bIgnoreInteriors = bUseNodes;
      ColModel = CEntity::GetColModel(m_pMyVehicle);
      m_pMat = m_pMyVehicle->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &m_pMyVehicle->m_transform;
      v13 = *(_QWORD *)&p_tx->m_translate.x;
      vecStart.z = p_tx->m_translate.z;
      *(_QWORD *)&vecStart.x = v13;
      v14 = this->m_pMat;
      p_m_transform = (CSimpleTransform *)&v14->tx;
      if ( !v14 )
        p_m_transform = &this->m_transform;
      x = p_m_transform->m_translate.x;
      y = p_m_transform->m_translate.y;
      z = p_m_transform->m_translate.z;
      vecEnd.z = z;
      vecEnd.y = y;
      vecEnd.x = x;
      m_nFlags = (int)this->m_nFlags;
      bdummy = this->m_nFlags.bdummy;
      CWorld::pIgnoreEntity = m_pMyVehicle;
      this->m_nFlags.bdummy = bdummy;
      this->m_vecMoveSpeed.x = 0.0;
      m_nPhysicalFlags = this->m_nPhysicalFlags;
      *(_DWORD *)&this->m_nFlags = m_nFlags & 0xFFFFFFFE;
      this->m_vecMoveSpeed.y = 0.0;
      this->m_vecMoveSpeed.z = 0.0;
      p_m_vecMoveSpeed = &this->m_vecMoveSpeed;
      this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags | 0x10000);
      v22 = CVehicle::IsOnItsSide(m_pMyVehicle);
      v23 = v22 == 0;
      p_m_nFlags = &this->m_nFlags;
      if ( v22 )
        v23 = m_pMyVehicle->m_baseVehicleType == 9;
      if ( v23 )
      {
        if ( nDoor )
        {
          CCarEnterExit::GetPositionToOpenCarDoor(&v128, m_pMyVehicle, nDoor);
          vecEnd = v128;
          v24 = *(_QWORD *)&v128.x;
          v25 = this->m_pMat;
          v26 = v128.z;
          if ( v25 )
          {
            v25->tx = v128.x;
            this->m_pMat->ty = *((float *)&v24 + 1);
            p_tz = &this->m_pMat->tz;
          }
          else
          {
            *(_QWORD *)&this->m_transform.m_translate.x = *(_QWORD *)&v128.x;
            p_tz = &this->m_transform.m_translate.z;
          }
          *p_tz = v26;
          if ( CPhysical::CheckCollision(this)
            || (v32 = 1, !CWorld::GetIsLineOfSightClear(&vecStart, &vecEnd, 1, 0, 0, 1, 0, 0, 0)) )
          {
            v32 = 0;
            v33 = (nDoor | 1) == 11;
            if ( (nDoor | 1) == 11 )
              v33 = m_pMyVehicle->m_baseVehicleType == 9;
            if ( v33 )
            {
              v34 = 8;
              if ( nDoor == 11 )
                v34 = 9;
              CCarEnterExit::GetPositionToOpenCarDoor(&v128, m_pMyVehicle, v34);
              vecEnd = v128;
              v35 = *(_QWORD *)&v128.x;
              v36 = this->m_pMat;
              v37 = v128.z;
              if ( v36 )
              {
                v36->tx = v128.x;
                this->m_pMat->ty = *((float *)&v35 + 1);
                p_z = &this->m_pMat->tz;
              }
              else
              {
                *(_QWORD *)&this->m_transform.m_translate.x = *(_QWORD *)&v128.x;
                p_z = &this->m_transform.m_translate.z;
              }
              *p_z = v37;
              IsLineOfSightClear = 0;
              if ( !CPhysical::CheckCollision(this) )
                IsLineOfSightClear = CWorld::GetIsLineOfSightClear(&vecStart, &vecEnd, 1, 0, 0, 1, 0, 0, 0);
              v32 = IsLineOfSightClear;
            }
          }
        }
        else
        {
          v32 = 0;
        }
      }
      else
      {
        vecEnd = vecStart;
        v28 = *(_QWORD *)&vecStart.x;
        v29 = vecStart.z + (float)(ColModel->m_boxBound.m_vecMax.x + 1.0);
        vecEnd.z = v29;
        v30 = this->m_pMat;
        if ( v30 )
        {
          v30->tx = vecStart.x;
          this->m_pMat->ty = *((float *)&v28 + 1);
          v31 = &this->m_pMat->tz;
        }
        else
        {
          *(_QWORD *)&this->m_transform.m_translate.x = *(_QWORD *)&vecStart.x;
          v31 = &this->m_transform.m_translate.z;
        }
        *v31 = v29;
        v32 = 0;
        if ( !CPhysical::CheckCollision(this) )
          v32 = CWorld::GetIsLineOfSightClear(&vecStart, &vecEnd, 1, 0, 0, 1, 0, 0, 0);
      }
      v126 = m_nFlags & 1;
      p_xx = &m_pMyVehicle->m_pMat->xx;
      v4.n64_f32[0] = -ColModel->m_boxBound.m_vecMin.z;
      v41 = p_xx[2];
      v5.n64_u32[0] = LODWORD(ColModel->m_boxBound.m_vecMax.z);
      v42 = (float)(ColModel->m_boxBound.m_vecMin.x + -0.355) + (float)(vmax_f32(v5, v4).n64_f32[0] * fabsf(v41));
      if ( (nDoor | 1) == 9 )
        v42 = ColModel->m_boxBound.m_vecMax.x + 0.355;
      if ( !v32 )
      {
        v43 = p_xx[1];
        v44 = v42
            - (float)((float)((float)((float)(x - vecStart.x) * *p_xx) + (float)((float)(y - vecStart.y) * v43))
                    + (float)((float)(z - vecStart.z) * v41));
        v45 = x + (float)(*p_xx * v44);
        v46 = z + (float)(v41 * v44);
        v47 = y + (float)(v43 * v44);
        vecEnd.x = v45;
        vecEnd.y = v47;
        vecEnd.z = v46;
        v48 = this->m_pMat;
        if ( v48 )
        {
          v48->tx = v45;
          this->m_pMat->ty = v47;
          v49 = &this->m_pMat->tz;
        }
        else
        {
          v49 = &this->m_transform.m_translate.z;
          this->m_transform.m_translate.x = v45;
          this->m_transform.m_translate.y = v47;
        }
        *v49 = v46;
        if ( CPhysical::CheckCollision(this) || !CWorld::GetIsLineOfSightClear(&vecStart, &vecEnd, 1, 0, 0, 1, 0, 0, 0) )
        {
          v50 = -1;
          v51 = ColModel->m_boxBound.m_vecMin.y;
          v52 = (float)(ColModel->m_boxBound.m_vecMax.y - v51) / 3.0;
          while ( 1 )
          {
            ++v50;
            v53 = &m_pMyVehicle->m_pMat->xx;
            v54 = v51 + (float)(v52 * (float)v50);
            v55 = (float)((float)(v42 * *v53) + vecStart.x) + (float)(v54 * v53[4]);
            v56 = (float)((float)(v42 * v53[1]) + vecStart.y) + (float)(v54 * v53[5]);
            v57 = (float)((float)(v42 * v53[2]) + vecStart.z) + (float)(v54 * v53[6]);
            vecEnd.x = v55;
            vecEnd.y = v56;
            vecEnd.z = v57;
            v58 = this->m_pMat;
            if ( v58 )
            {
              v58->tx = v55;
              this->m_pMat->ty = v56;
              v59 = &this->m_pMat->tz;
            }
            else
            {
              this->m_transform.m_translate.x = v55;
              this->m_transform.m_translate.y = v56;
              v59 = &this->m_transform.m_translate.z;
            }
            *v59 = v57;
            if ( !CPhysical::CheckCollision(this)
              && CWorld::GetIsLineOfSightClear(&vecStart, &vecEnd, 1, 0, 0, 1, 0, 0, 0) )
            {
              break;
            }
            if ( v50 >= 3 )
            {
              v60 = &m_pMyVehicle->m_pMat->xx;
              v61 = ColModel->m_boxBound.m_vecMin.y + -0.355;
              v62 = (float)(v61 * v60[4]) + vecStart.x;
              v63 = (float)(v61 * v60[5]) + vecStart.y;
              v64 = (float)(v61 * v60[6]) + vecStart.z;
              vecEnd.x = v62;
              vecEnd.y = v63;
              vecEnd.z = v64;
              v65 = this->m_pMat;
              if ( v65 )
              {
                v65->tx = v62;
                this->m_pMat->ty = v63;
                v66 = &this->m_pMat->tz;
              }
              else
              {
                this->m_transform.m_translate.x = v62;
                this->m_transform.m_translate.y = v63;
                v66 = &this->m_transform.m_translate.z;
              }
              *v66 = v64;
              if ( !CPhysical::CheckCollision(this)
                && CWorld::GetIsLineOfSightClear(&vecStart, &vecEnd, 1, 0, 0, 1, 0, 0, 0) )
              {
                break;
              }
              v67 = &m_pMyVehicle->m_pMat->xx;
              v68 = ColModel->m_boxBound.m_vecMax.y + 0.355;
              v69 = (float)(v68 * v67[4]) + vecStart.x;
              v70 = (float)(v68 * v67[5]) + vecStart.y;
              v71 = (float)(v68 * v67[6]) + vecStart.z;
              vecEnd.x = v69;
              vecEnd.y = v70;
              vecEnd.z = v71;
              v72 = this->m_pMat;
              if ( v72 )
              {
                v72->tx = v69;
                this->m_pMat->ty = v70;
                v73 = &this->m_pMat->tz;
              }
              else
              {
                this->m_transform.m_translate.x = v69;
                this->m_transform.m_translate.y = v70;
                v73 = &this->m_transform.m_translate.z;
              }
              *v73 = v71;
              if ( !CPhysical::CheckCollision(this)
                && CWorld::GetIsLineOfSightClear(&vecStart, &vecEnd, 1, 0, 0, 1, 0, 0, 0) )
              {
                break;
              }
              v74 = &m_pMyVehicle->m_pMat->xx;
              v75 = ColModel->m_boxBound.m_vecMin.y;
              v76 = v75 * v74[5];
              v77 = v75 * v74[4];
              v78 = v75 * v74[6];
              v79 = vecStart.z - (float)(v42 * v74[2]);
              v80 = (float)(vecStart.y - (float)(v42 * v74[1])) + v76;
              v81 = (float)(vecStart.x - (float)(v42 * *v74)) + v77;
              vecEnd.x = v81;
              vecEnd.y = v80;
              vecEnd.z = v79 + v78;
              v82 = this->m_pMat;
              if ( v82 )
              {
                v82->tx = v81;
                this->m_pMat->ty = v80;
                v83 = &this->m_pMat->tz;
              }
              else
              {
                this->m_transform.m_translate.x = v81;
                this->m_transform.m_translate.y = v80;
                v83 = &this->m_transform.m_translate.z;
              }
              *v83 = v79 + v78;
              if ( !CPhysical::CheckCollision(this)
                && CWorld::GetIsLineOfSightClear(&vecStart, &vecEnd, 1, 0, 0, 1, 0, 0, 0) )
              {
                break;
              }
              v84 = &m_pMyVehicle->m_pMat->xx;
              v85 = ColModel->m_boxBound.m_vecMax.y;
              v86 = v85 * v84[5];
              v87 = v85 * v84[4];
              v88 = v85 * v84[6];
              v89 = vecStart.z - (float)(v42 * v84[2]);
              v90 = (float)(vecStart.y - (float)(v42 * v84[1])) + v86;
              v91 = (float)(vecStart.x - (float)(v42 * *v84)) + v87;
              vecEnd.x = v91;
              vecEnd.y = v90;
              vecEnd.z = v89 + v88;
              v92 = this->m_pMat;
              if ( v92 )
              {
                v92->tx = v91;
                this->m_pMat->ty = v90;
                v93 = &this->m_pMat->tz;
              }
              else
              {
                this->m_transform.m_translate.x = v91;
                this->m_transform.m_translate.y = v90;
                v93 = &this->m_transform.m_translate.z;
              }
              *v93 = v89 + v88;
              if ( !CPhysical::CheckCollision(this)
                && CWorld::GetIsLineOfSightClear(&vecStart, &vecEnd, 1, 0, 0, 1, 0, 0, 0) )
              {
                break;
              }
              if ( m_pMyVehicle->m_baseVehicleType )
                goto LABEL_83;
              v96 = &m_pMyVehicle->m_pMat->xx;
              v97 = ColModel->m_boxBound.m_vecMax.z;
              v98 = (float)(v97 * v96[10]) + vecStart.z;
              v99 = (float)(v97 * v96[8]) + vecStart.x;
              v100 = (float)(v97 * v96[9]) + vecStart.y;
              vecEnd.x = v99;
              vecEnd.y = v100;
              vecEnd.z = v98 + 1.0;
              v101 = this->m_pMat;
              if ( v101 )
              {
                v101->tx = v99;
                this->m_pMat->ty = v100;
                v102 = &this->m_pMat->tz;
              }
              else
              {
                this->m_transform.m_translate.x = v99;
                this->m_transform.m_translate.y = v100;
                v102 = &this->m_transform.m_translate.z;
              }
              *v102 = v98 + 1.0;
              if ( CPhysical::CheckCollision(this) )
              {
LABEL_83:
                CWorld::pIgnoreEntity = 0;
                *(_DWORD *)p_m_nFlags = *(_DWORD *)p_m_nFlags & 0xFFFFFFFE | v126;
                *(_DWORD *)&this->m_nPhysicalFlags &= ~0x10000u;
              }
              else
              {
                v118 = CWorld::GetIsLineOfSightClear(&vecStart, &vecEnd, 1, 0, 0, 1, 0, 0, 0);
                CWorld::pIgnoreEntity = 0;
                *(_DWORD *)p_m_nFlags = *(_DWORD *)p_m_nFlags & 0xFFFFFFFE | v126;
                *(_DWORD *)&this->m_nPhysicalFlags &= ~0x10000u;
                if ( v118 )
                  goto LABEL_73;
              }
              v94 = 0;
              if ( !bIgnoreInteriors )
                return v94;
              *(_QWORD *)&v131.x = *(_QWORD *)&vecStart.y;
              LODWORD(v131.z) = 1;
              NodeClosestToCoors = CPathFind::FindNodeClosestToCoors(
                                     (CNodeAddress *)&ThePaths,
                                     (CPathFind *)LODWORD(vecStart.x),
                                     v131,
                                     1000000.0,
                                     0.0,
                                     0,
                                     0,
                                     0,
                                     0,
                                     1);
              *(_QWORD *)&v132.x = *(_QWORD *)&vecStart.y;
              v132.z = 0.0;
              v104 = CPathFind::FindNodeClosestToCoors(
                       (CNodeAddress *)&ThePaths,
                       (CPathFind *)LODWORD(vecStart.x),
                       v132,
                       1000000.0,
                       0.0,
                       0,
                       0,
                       0,
                       0,
                       bIgnoreInteriorsa);
              if ( (unsigned __int16)NodeClosestToCoors != 0xFFFF )
              {
                v105 = &ThePaths.pNodes[(unsigned __int16)NodeClosestToCoors][(unsigned int)NodeClosestToCoors >> 16];
                v94 = 1;
                v106 = (float)v105->CoorsX * 0.125;
                v107 = (float)v105->CoorsZ * 0.125;
                vecEnd.y = (float)v105->CoorsY * 0.125;
                vecEnd.x = v106;
                vecEnd.z = v107;
              }
              if ( (unsigned __int16)v104 == 0xFFFF )
              {
                v8 = v94;
                v108 = &this->m_transform.m_translate.z;
                if ( !v8 )
                  goto LABEL_89;
              }
              else
              {
                v109 = (unsigned int)v104 >> 16;
                v110 = ThePaths.pNodes[(unsigned __int16)v104];
                v111 = &v110[(unsigned int)v104 >> 16];
                CoorsX = v111->CoorsX;
                v108 = &this->m_transform.m_translate.z;
                v113 = (float)v111->CoorsY * 0.125;
                if ( sqrtf(
                       (float)((float)((float)((float)CoorsX * 0.125) - vecStart.x)
                             * (float)((float)((float)CoorsX * 0.125) - vecStart.x))
                     + (float)((float)(v113 - vecStart.y) * (float)(v113 - vecStart.y))) < sqrtf(
                                                                                             (float)((float)(vecEnd.x - vecStart.x) * (float)(vecEnd.x - vecStart.x))
                                                                                           + (float)((float)(vecEnd.y - vecStart.y) * (float)(vecEnd.y - vecStart.y))) )
                {
                  CoorsZ = (float)v110[v109].CoorsZ;
                  vecEnd.y = (float)v111->CoorsY * 0.125;
                  vecEnd.x = (float)CoorsX * 0.125;
                  vecEnd.z = CoorsZ * 0.125;
                }
              }
              CPedPlacement::FindZCoorForPed(&vecEnd);
              v115 = vecEnd.y;
              v116 = this->m_pMat;
              v117 = vecEnd.z;
              if ( v116 )
              {
                v116->tx = vecEnd.x;
                this->m_pMat->ty = v115;
                v108 = &this->m_pMat->tz;
              }
              else
              {
                this->m_transform.m_translate.x = vecEnd.x;
                this->m_transform.m_translate.y = v115;
              }
              *v108 = v117;
              v119 = m_pMyVehicle->m_pMat;
              if ( v119 )
                m_heading = atan2f(COERCE_FLOAT(LODWORD(v119->xy) ^ 0x80000000), v119->yy);
              else
                m_heading = m_pMyVehicle->m_transform.m_heading;
              v121 = this->m_pMat;
              if ( v121 )
                CMatrix::SetRotateZOnly(v121, m_heading);
              else
                this->m_transform.m_heading = m_heading;
              *((_DWORD *)p_m_nPedFlags + 2) |= 1u;
              this->m_vecTurnSpeed.z = 0.0;
              *(_QWORD *)&p_m_vecMoveSpeed->x = 0LL;
              *(_QWORD *)&this->m_vecMoveSpeed.z = 0LL;
              this->m_vecTurnSpeed.y = 0.0;
              *(_QWORD *)&m_pMyVehicle->m_vecMoveSpeed.x = 0LL;
              *(_QWORD *)&m_pMyVehicle->m_vecMoveSpeed.z = 1017370378LL;
              m_pMyVehicle->m_vecTurnSpeed.y = 0.0;
              m_pMyVehicle->m_vecTurnSpeed.z = 0.0;
              goto LABEL_76;
            }
          }
        }
      }
      CWorld::pIgnoreEntity = 0;
      *(_DWORD *)p_m_nFlags = *(_DWORD *)p_m_nFlags & 0xFFFFFFFE | v126;
      *(_DWORD *)&this->m_nPhysicalFlags &= ~0x10000u;
LABEL_73:
      *((_DWORD *)p_m_nPedFlags + 2) |= 1u;
      this->m_vecTurnSpeed.z = 0.0;
      *(_QWORD *)&p_m_vecMoveSpeed->x = 0LL;
      *(_QWORD *)&this->m_vecMoveSpeed.z = 0LL;
      this->m_vecTurnSpeed.y = 0.0;
      if ( m_pMyVehicle->m_baseVehicleType != 9 || bIgnoreInteriors )
      {
        m_pMyVehicle->m_vecTurnSpeed.y = 0.0;
        m_pMyVehicle->m_vecTurnSpeed.z = 0.0;
        *(_QWORD *)&m_pMyVehicle->m_vecMoveSpeed.x = 0LL;
        *(_QWORD *)&m_pMyVehicle->m_vecMoveSpeed.z = 0LL;
        m_pMyVehicle->m_vecMoveSpeed.z = -0.05;
      }
    }
LABEL_76:
    LOBYTE(v94) = 1;
  }
  return v94;
}
// 49FFB0: variable 'v5' is possibly undefined
// 49FFB0: variable 'v4' is possibly undefined
// 4A055A: variable 'bIgnoreInteriorsa' is possibly undefined

//----- (004A077C) --------------------------------------------------------
bool __fastcall CPed::PositionAnyPedOutOfCollision(CPed *this)
{
  float z; // s18
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r1
  float v5; // r6
  CEntity *v6; // r5
  CSimpleTransform *p_tx; // r1
  int v8; // r10
  CMatrix *v9; // r0
  CSimpleTransform *v10; // r1
  float v11; // s22
  CMatrix *v12; // r0
  float v13; // r1
  float *p_tz; // r0
  float v16; // s0
  CMatrix *v17; // r0
  int v18; // [sp+20h] [bp-78h]
  CVector v19; // [sp+24h] [bp-74h] BYREF
  int v20; // [sp+30h] [bp-68h]
  RwReal x; // [sp+34h] [bp-64h]
  float y; // [sp+38h] [bp-60h]
  int v23; // [sp+3Ch] [bp-5Ch]
  int v24; // [sp+40h] [bp-58h]
  int v25; // [sp+44h] [bp-54h]
  CVector pCoors; // [sp+4Ch] [bp-4Ch] BYREF

  m_pMat = this->m_pMat;
  p_m_transform = &this->m_transform;
  LOWORD(v5) = -26214;
  if ( m_pMat )
    p_m_transform = (CSimpleTransform *)&m_pMat->tx;
  HIWORD(v5) = 16153;
  v6 = 0;
  pCoors.y = p_m_transform->m_translate.y + -3.5;
  pCoors.z = p_m_transform->m_translate.z;
  v24 = 999;
  v25 = 999;
  v20 = 0;
  v23 = 0;
  v18 = 0;
  memset(&v19, 0, sizeof(v19));
  y = 0.0;
  x = 0.0;
  while ( 1 )
  {
    p_tx = &this->m_transform;
    v8 = 15;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    pCoors.x = p_tx->m_translate.x + -3.5;
    do
    {
      CPedPlacement::FindZCoorForPed(&pCoors);
      if ( !CWorld::TestSphereAgainstWorld(pCoors, v5, this, 1, 0, 0, 1, 0, 0) )
      {
        v9 = this->m_pMat;
        v10 = &this->m_transform;
        if ( v9 )
          v10 = (CSimpleTransform *)&v9->tx;
        v11 = (float)((float)((float)(pCoors.x - v10->m_translate.x) * (float)(pCoors.x - v10->m_translate.x))
                    + (float)((float)(pCoors.y - v10->m_translate.y) * (float)(pCoors.y - v10->m_translate.y)))
            + (float)((float)(pCoors.z - v10->m_translate.z) * (float)(pCoors.z - v10->m_translate.z));
        v6 = CWorld::TestSphereAgainstWorld(pCoors, v5, this, 0, 1, 0, 0, 0, 0);
        if ( v6 )
        {
          if ( v11 < (float)v25 )
          {
            z = pCoors.z;
            y = pCoors.y;
            x = pCoors.x;
            v25 = (int)v11;
            v23 = 1;
          }
        }
        else if ( v11 >= (float)v24 )
        {
          v6 = 0;
        }
        else
        {
          v19 = pCoors;
          v6 = 0;
          v24 = (int)v11;
          v20 = 1;
        }
      }
      --v8;
      pCoors.x = pCoors.x + 0.5;
    }
    while ( v8 );
    pCoors.y = pCoors.y + 0.5;
    if ( v18 == 14 )
      break;
    ++v18;
    m_pMat = this->m_pMat;
  }
  if ( !((v23 | v20) << 31) )
    return 0;
  if ( v20 << 31 )
  {
    v12 = this->m_pMat;
    if ( v12 )
    {
      v12->tx = v19.x;
      this->m_pMat->ty = v19.y;
      v13 = v19.z;
      p_tz = &this->m_pMat->tz;
    }
    else
    {
      this->m_transform.m_translate.x = v19.x;
      this->m_transform.m_translate.y = v19.y;
      p_tz = &this->m_transform.m_translate.z;
      v13 = v19.z;
    }
  }
  else
  {
    v16 = CEntity::GetColModel(v6)->m_boxBound.m_vecMax.z;
    v17 = this->m_pMat;
    v13 = z + v16;
    if ( v17 )
    {
      v17->tx = x;
      this->m_pMat->ty = y;
      p_tz = &this->m_pMat->tz;
    }
    else
    {
      this->m_transform.m_translate.x = x;
      this->m_transform.m_translate.y = y;
      p_tz = &this->m_transform.m_translate.z;
    }
  }
  *p_tz = v13;
  return 1;
}
// 4A0964: variable 'z' is possibly undefined

//----- (004A09A8) --------------------------------------------------------
bool __fastcall CPed::OurPedCanSeeThisEntity(CPed *this, CEntity *pEntity, bool bForTargetingPurposes)
{
  CMatrix *m_pMat; // r4
  CMatrix *v4; // r3
  CSimpleTransform *p_tx; // r12
  CSimpleTransform *p_m_transform; // r0
  float v7; // s0
  float v8; // s2
  __int64 v9; // d16
  bool v10; // r4
  int v11; // r0
  CEntity *refEntityPtr; // [sp+20h] [bp-58h] BYREF
  CColPoint colPoint; // [sp+24h] [bp-54h] BYREF
  CVector vecEnd; // [sp+50h] [bp-28h] BYREF
  CVector vecStart; // [sp+60h] [bp-18h] BYREF

  m_pMat = this->m_pMat;
  v4 = pEntity->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &this->m_transform;
  p_m_transform = (CSimpleTransform *)&v4->tx;
  if ( !v4 )
    p_m_transform = &pEntity->m_transform;
  if ( !bForTargetingPurposes )
  {
    v7 = p_m_transform->m_translate.x - p_tx->m_translate.x;
    v8 = p_m_transform->m_translate.y - p_tx->m_translate.y;
    if ( (float)((float)(v7 * m_pMat->xy) + (float)(v8 * m_pMat->yy)) < 0.0
      || sqrtf((float)(v7 * v7) + (float)(v8 * v8)) >= 40.0 )
    {
      return 0;
    }
  }
  vecStart = p_tx->m_translate;
  vecStart.z = vecStart.z + 1.0;
  v9 = *(_QWORD *)&p_m_transform->m_translate.x;
  vecEnd.z = p_m_transform->m_translate.z;
  *(_QWORD *)&vecEnd.x = v9;
  if ( (*(_BYTE *)&pEntity->m_info & 7) == 3 )
    vecEnd.z = vecEnd.z + 1.0;
  v10 = 0;
  if ( bForTargetingPurposes )
    v11 = CWorld::ProcessLineOfSight(&vecStart, &vecEnd, &colPoint, &refEntityPtr, 1, 0, 0, 1, 0, 0, 0, 1);
  else
    v11 = CWorld::ProcessLineOfSight(&vecStart, &vecEnd, &colPoint, &refEntityPtr, 1, 0, 0, 0, 0, 0, 0, 0);
  if ( !v11 )
    return 1;
  return v10;
}

//----- (004A0AB0) --------------------------------------------------------
void __fastcall CPed::SortPeds(CPed *this, CPed **apPeds, int32 nStartIndex, int32 nEndIndex)
{
  int32 v4; // r12
  CPed **v7; // lr
  CMatrix *m_pMat; // r6
  CSimpleTransform *p_m_transform; // r3
  int v10; // r0
  int v11; // r1
  float x; // s0
  float y; // s2
  float z; // s4
  float *v15; // r3
  int32 v16; // r0
  int32 v17; // r1
  float v18; // s0
  CSimpleTransform *p_tx; // r3
  float v20; // s2
  float v21; // s4
  float v22; // s6
  CPed *v23; // r6
  CMatrix *v24; // r3
  float *p_x; // r4
  int32 v26; // r10
  CPed *v27; // r4
  CMatrix *v28; // r3
  float *v29; // r5
  int32 v30; // r3
  int32 v31; // r4

  v4 = nEndIndex;
  if ( nStartIndex < nEndIndex )
  {
    v7 = apPeds - 1;
    do
    {
      m_pMat = this->m_pMat;
      p_m_transform = &this->m_transform;
      v10 = *(int *)((char *)apPeds + ((2 * (nStartIndex + v4 + ((unsigned int)(nStartIndex + v4) >> 31))) & 0xFFFFFFFC));
      v11 = *(_DWORD *)(v10 + 20);
      if ( m_pMat )
        p_m_transform = (CSimpleTransform *)&m_pMat->tx;
      x = p_m_transform->m_translate.x;
      y = p_m_transform->m_translate.y;
      z = p_m_transform->m_translate.z;
      v15 = (float *)(v11 + 48);
      if ( !v11 )
        v15 = (float *)(v10 + 4);
      v16 = v4;
      v17 = nStartIndex;
      v18 = sqrtf(
              (float)((float)((float)(x - *v15) * (float)(x - *v15)) + (float)((float)(y - v15[1]) * (float)(y - v15[1])))
            + (float)((float)(z - v15[2]) * (float)(z - v15[2])));
      while ( 1 )
      {
        p_tx = &this->m_transform;
        if ( m_pMat )
          p_tx = (CSimpleTransform *)&m_pMat->tx;
        v20 = p_tx->m_translate.x;
        v21 = p_tx->m_translate.y;
        v22 = p_tx->m_translate.z;
        do
        {
          v23 = apPeds[v17++];
          v24 = v23->m_pMat;
          p_x = &v24->tx;
          if ( !v24 )
            p_x = &v23->m_transform.m_translate.x;
        }
        while ( sqrtf(
                  (float)((float)((float)(v20 - *p_x) * (float)(v20 - *p_x))
                        + (float)((float)(v21 - p_x[1]) * (float)(v21 - p_x[1])))
                + (float)((float)(v22 - p_x[2]) * (float)(v22 - p_x[2]))) < v18 );
        v26 = v17 - 1;
        do
        {
          v27 = apPeds[v16--];
          v28 = v27->m_pMat;
          v29 = &v28->tx;
          if ( !v28 )
            v29 = &v27->m_transform.m_translate.x;
        }
        while ( v18 < sqrtf(
                        (float)((float)((float)(v20 - *v29) * (float)(v20 - *v29))
                              + (float)((float)(v21 - v29[1]) * (float)(v21 - v29[1])))
                      + (float)((float)(v22 - v29[2]) * (float)(v22 - v29[2]))) );
        v30 = v16 + 1;
        if ( v26 <= v16 + 1 )
        {
          v7[v17] = v27;
          v26 = v17;
          apPeds[v16 + 1] = v23;
          v30 = v16;
        }
        if ( v26 > v30 )
          break;
        m_pMat = this->m_pMat;
        v16 = v30;
        v17 = v26;
      }
      v31 = v4;
      CPed::SortPeds(this, apPeds, nStartIndex, v30);
      v4 = v31;
      nStartIndex = v26;
    }
    while ( v26 < v31 );
  }
}

//----- (004A0C30) --------------------------------------------------------
void __fastcall CPed::SetMoveState(CPed *this, eMoveState MoveState)
{
  this->m_eMoveState = MoveState;
}

//----- (004A0C38) --------------------------------------------------------
void __fastcall CPed::SetMoveAnim(CPed *this)
{
  eMoveState m_eMoveState; // r0
  CPedFlags *p_m_nPedFlags; // r11
  eMoveState m_eMoveStateAnim; // r2
  float *p_m_fSlopePitch; // r5
  float m_fSlopePitch; // s0
  uint32 v7; // r1
  CAnimBlendAssociation *Association; // r0
  int v9; // r3
  float v10; // s0
  int v11; // r1
  int v12; // r1
  float v13; // s0
  AssocGroupId m_motionAnimGroup; // r9
  CAnimBlendAssociation *i; // r0
  int v16; // r0
  unsigned int v17; // r3
  int v18; // r10
  int v19; // lr
  uint32 m_flags; // r1
  CPlayerPedData *m_pPlayerData; // r1
  uint32 v22; // r5
  unsigned int v23; // r2
  ePedState m_nPedState; // r1
  unsigned int v25; // r1
  int v26; // r2
  RpClump_0 *m_pRwObject; // r0
  AssocGroupId v28; // r1
  AnimationId v29; // r2
  int v30; // r3
  CPedGroup *PedsGroup; // r0
  CPedGroup *v32; // r0
  int v33; // r3
  int v34; // r1
  float v35; // s2

  if ( (this->m_nPedState & 0xFFFFFFFE) == 54
    || (*((_BYTE *)&this->m_nPedFlags + 3) & 4) != 0
    || this->m_pAttachToEntity )
  {
    return;
  }
  m_eMoveState = this->m_eMoveState;
  p_m_nPedFlags = &this->m_nPedFlags;
  m_eMoveStateAnim = this->m_eMoveStateAnim;
  if ( m_eMoveStateAnim == m_eMoveState )
  {
    if ( m_eMoveStateAnim >= PEDMOVE_WALK )
    {
      p_m_fSlopePitch = &this->m_ik.m_fSlopePitch;
      m_fSlopePitch = this->m_ik.m_fSlopePitch;
      if ( m_fSlopePitch > 0.01 || m_fSlopePitch < -0.01 )
      {
        v7 = 0;
        if ( m_eMoveStateAnim == PEDMOVE_SPRINT )
          v7 = 2;
        if ( m_eMoveStateAnim == PEDMOVE_RUN )
          v7 = 1;
        Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)this->m_pRwObject, v7);
        if ( Association )
        {
          if ( (*((_DWORD *)&this->m_nPedFlags + 3) & 0x10000) == 0 )
          {
            v9 = 0;
            v10 = *p_m_fSlopePitch;
            v11 = 0;
            if ( *p_m_fSlopePitch < -0.3 )
              v9 = 1;
            if ( *p_m_fSlopePitch <= 0.3 )
              v11 = 1;
            v12 = v11 & v9;
            if ( this->CharCreatedBy == 2 )
            {
              if ( v12 )
              {
LABEL_67:
                v13 = 0.7;
                goto LABEL_76;
              }
LABEL_21:
              if ( v10 > 0.3 )
              {
                v13 = 1.3;
LABEL_76:
                Association->m_fSpeed = v13;
                return;
              }
              v35 = 1.0;
            }
            else
            {
LABEL_68:
              if ( v12 )
              {
                v10 = 0.9;
              }
              else if ( v10 <= 0.3 )
              {
                v10 = v10 + 1.2;
              }
              else
              {
                v10 = 1.5;
              }
              v35 = (float)((float)this->RandomSeed * -0.4) / 65535.0;
            }
            v13 = v10 + v35;
            goto LABEL_76;
          }
        }
      }
    }
  }
  else
  {
    if ( m_eMoveState )
    {
      m_motionAnimGroup = this->m_motionAnimGroup;
      this->m_eMoveStateAnim = m_eMoveState;
      if ( (unsigned int)m_eMoveState <= PEDMOVE_SPRINT && ((1 << m_eMoveState) & 0xD0) != 0 )
      {
        for ( i = RpAnimBlendClumpGetFirstAssociation((RpClump_0 *)this->m_pRwObject, 0x10u);
              i;
              i = RpAnimBlendGetNextAssociation(i, 0x10u) )
        {
          if ( (i->m_bitsFlag & 0x408) == 0 )
          {
            i->m_bitsFlag |= 4u;
            i->m_fBlendDelta = -2.0;
          }
        }
        v16 = *((_DWORD *)&this->m_nPedFlags + 1);
        v17 = *(_DWORD *)p_m_nPedFlags;
        v18 = *((_DWORD *)&this->m_nPedFlags + 3);
        v19 = *((_DWORD *)&this->m_nPedFlags + 2);
        if ( (*(_DWORD *)p_m_nPedFlags & 0x10) != 0 )
        {
          v17 = v17 & 0xFFFFFFCF | 0x20;
          *(_DWORD *)p_m_nPedFlags = v17;
          *((_DWORD *)&this->m_nPedFlags + 1) = v16;
          *((_DWORD *)&this->m_nPedFlags + 2) = v19;
          *((_DWORD *)&this->m_nPedFlags + 3) = v18;
          m_flags = this->m_ik.m_flags;
          this->m_nLookTimer = 0;
          this->m_ik.m_flags = m_flags & 0xFFFFFFFB;
        }
        m_pPlayerData = this->m_pPlayerData;
        if ( m_pPlayerData )
        {
          m_pPlayerData->m_fLookPitch = 0.0;
          v16 = *((_DWORD *)&this->m_nPedFlags + 1);
          v17 = *(_DWORD *)p_m_nPedFlags;
          v18 = *((_DWORD *)&this->m_nPedFlags + 3);
          v19 = *((_DWORD *)&this->m_nPedFlags + 2);
        }
        v22 = CTimer::m_snTimeInMilliseconds;
        do
        {
          v23 = v17;
          if ( (v17 & 4) == 0 )
            break;
          v16 &= ~0x800u;
          v17 = v17 & 0xFFFFFFF3 | 8;
          *(_DWORD *)p_m_nPedFlags = v17;
          *((_DWORD *)&this->m_nPedFlags + 1) = v16;
          *((_DWORD *)&this->m_nPedFlags + 2) = v19;
          *((_DWORD *)&this->m_nPedFlags + 3) = v18;
          m_nPedState = this->m_nPedState;
          if ( (m_nPedState | 8) != 58 && (v23 & 0x4000000) == 0 )
            this->m_ik.m_flags &= ~2u;
          v25 = m_nPedState & 0xFFFFFFFE;
          v26 = 4000;
          if ( this->m_nPedType < 2u )
            v26 = 2000;
          this->m_nLookTimer = v26 + v22;
        }
        while ( v25 == 2 );
        m_eMoveState = this->m_eMoveState;
      }
      switch ( m_eMoveState )
      {
        case PEDMOVE_STILL:
          m_pRwObject = (RpClump_0 *)this->m_pRwObject;
          v28 = m_motionAnimGroup;
          v29 = ANIM_STD_IDLE;
          v30 = 1082130432;
          goto LABEL_59;
        case PEDMOVE_TURN_L:
          m_pRwObject = (RpClump_0 *)this->m_pRwObject;
          v28 = ANIM_STD_PED;
          v29 = ANIM_STD_TURN_L;
          v30 = 1098907648;
          goto LABEL_59;
        case PEDMOVE_TURN_R:
          m_pRwObject = (RpClump_0 *)this->m_pRwObject;
          v28 = ANIM_STD_PED;
          v29 = ANIM_STD_TURN_R;
          v30 = 1098907648;
          goto LABEL_59;
        case PEDMOVE_WALK:
          m_pRwObject = (RpClump_0 *)this->m_pRwObject;
          v28 = m_motionAnimGroup;
          v29 = ANIM_STD_WALK;
          goto LABEL_58;
        case PEDMOVE_RUN:
          m_pRwObject = (RpClump_0 *)this->m_pRwObject;
          if ( this->m_nPedState == PED_FLEE_ENTITY )
          {
            v30 = 1077936128;
            v28 = m_motionAnimGroup;
            v29 = ANIM_STD_RUN;
          }
          else
          {
            v28 = m_motionAnimGroup;
            v29 = ANIM_STD_RUN;
LABEL_58:
            v30 = 1065353216;
          }
LABEL_59:
          Association = CAnimManager::BlendAnimation(m_pRwObject, v28, v29, *(float *)&v30);
          if ( !Association || (*((_DWORD *)&this->m_nPedFlags + 3) & 0x10000) != 0 )
            return;
          v33 = 0;
          v10 = this->m_ik.m_fSlopePitch;
          v34 = 0;
          if ( v10 < -0.3 )
            v33 = 1;
          if ( v10 <= 0.3 )
            v34 = 1;
          v12 = v34 & v33;
          if ( this->CharCreatedBy != 2 )
            goto LABEL_68;
          if ( v12 )
            goto LABEL_67;
          goto LABEL_21;
        case PEDMOVE_SPRINT:
          if ( CPedGroups::IsInPlayersGroup(this)
            && (PedsGroup = CPedGroups::GetPedsGroup(this), CPedGroupMembership::GetLeader(&PedsGroup->m_membership))
            && (v32 = CPedGroups::GetPedsGroup(this),
                CPedGroupMembership::GetLeader(&v32->m_membership)->m_eMoveState >= PEDMOVE_RUN) )
          {
            m_pRwObject = (RpClump_0 *)this->m_pRwObject;
            v28 = ANIM_PLAYER_PED;
          }
          else
          {
            m_pRwObject = (RpClump_0 *)this->m_pRwObject;
            v28 = m_motionAnimGroup;
          }
          v29 = ANIM_STD_RUNFAST;
          goto LABEL_58;
        default:
          return;
      }
    }
    this->m_eMoveStateAnim = PEDMOVE_NONE;
  }
}

//----- (004A0F6C) --------------------------------------------------------
void __fastcall CPed::SetMoveAnimSpeed(CPed *this, CAnimBlendAssociation *pAnim)
{
  int v2; // r3
  float m_fSlopePitch; // s0
  int v4; // r2
  int v5; // r2
  float v6; // s2

  v2 = 0;
  m_fSlopePitch = this->m_ik.m_fSlopePitch;
  v4 = 0;
  if ( m_fSlopePitch < -0.3 )
    v2 = 1;
  if ( m_fSlopePitch <= 0.3 )
    v4 = 1;
  v5 = v4 & v2;
  if ( this->CharCreatedBy == 2 )
  {
    if ( v5 )
    {
      pAnim->m_fSpeed = 0.7;
      return;
    }
    if ( m_fSlopePitch > 0.3 )
    {
      pAnim->m_fSpeed = 1.3;
      return;
    }
    v6 = 1.0;
  }
  else
  {
    if ( v5 )
    {
      m_fSlopePitch = 0.9;
    }
    else if ( m_fSlopePitch > 0.3 )
    {
      m_fSlopePitch = 1.5;
    }
    else
    {
      m_fSlopePitch = m_fSlopePitch + 1.2;
    }
    v6 = (float)((float)this->RandomSeed * -0.4) / 65535.0;
  }
  pAnim->m_fSpeed = m_fSlopePitch + v6;
}

//----- (004A1030) --------------------------------------------------------
void __fastcall CPed::ClearAimFlag(CPed *this)
{
  int m_nPedFlags; // r1
  int v2; // lr
  int v3; // r12
  int v4; // r3
  uint32 m_flags; // r1
  CPlayerPedData *m_pPlayerData; // r0

  m_nPedFlags = (int)this->m_nPedFlags;
  if ( (m_nPedFlags & 0x10) != 0 )
  {
    v2 = *((_DWORD *)&this->m_nPedFlags + 1);
    v3 = *((_DWORD *)&this->m_nPedFlags + 3);
    v4 = *((_DWORD *)&this->m_nPedFlags + 2);
    *(_DWORD *)&this->m_nPedFlags = m_nPedFlags & 0xFFFFFFCF | 0x20;
    *((_DWORD *)&this->m_nPedFlags + 1) = v2;
    *((_DWORD *)&this->m_nPedFlags + 2) = v4;
    *((_DWORD *)&this->m_nPedFlags + 3) = v3;
    m_flags = this->m_ik.m_flags;
    this->m_nLookTimer = 0;
    this->m_ik.m_flags = m_flags & 0xFFFFFFFB;
  }
  m_pPlayerData = this->m_pPlayerData;
  if ( m_pPlayerData )
    m_pPlayerData->m_fLookPitch = 0.0;
}

//----- (004A1080) --------------------------------------------------------
void __fastcall CPed::ClearLookFlag(CPed *this)
{
  unsigned int m_nPedFlags; // r5
  int v2; // r1
  int v3; // r12
  int v4; // lr
  uint32 v5; // r9
  unsigned int v6; // r4
  ePedState m_nPedState; // r6
  int v8; // r2

  m_nPedFlags = (unsigned int)this->m_nPedFlags;
  v2 = *((_DWORD *)&this->m_nPedFlags + 1);
  v3 = *((_DWORD *)&this->m_nPedFlags + 2);
  v4 = *((_DWORD *)&this->m_nPedFlags + 3);
  v5 = CTimer::m_snTimeInMilliseconds;
  do
  {
    v6 = m_nPedFlags;
    if ( (m_nPedFlags & 4) == 0 )
      break;
    v2 &= ~0x800u;
    m_nPedFlags = m_nPedFlags & 0xFFFFFFF3 | 8;
    *(_DWORD *)&this->m_nPedFlags = m_nPedFlags;
    *((_DWORD *)&this->m_nPedFlags + 1) = v2;
    *((_DWORD *)&this->m_nPedFlags + 2) = v3;
    *((_DWORD *)&this->m_nPedFlags + 3) = v4;
    m_nPedState = this->m_nPedState;
    if ( (m_nPedState | 8) != 58 && (v6 & 0x4000000) == 0 )
      this->m_ik.m_flags &= ~2u;
    v8 = 4000;
    if ( this->m_nPedType < 2u )
      v8 = 2000;
    this->m_nLookTimer = v8 + v5;
  }
  while ( (m_nPedState & 0xFFFFFFFE) == 2 );
}

//----- (004A1104) --------------------------------------------------------
void __fastcall CPed::StopNonPartialAnims(CPed *this)
{
  CAnimBlendAssociation *i; // r0
  uint16 m_bitsFlag; // r1

  for ( i = RpAnimBlendClumpGetFirstAssociation((RpClump_0 *)this->m_pRwObject); i; i = RpAnimBlendGetNextAssociation(i) )
  {
    m_bitsFlag = i->m_bitsFlag;
    if ( (m_bitsFlag & 0x10) == 0 )
      i->m_bitsFlag = m_bitsFlag & 0xFFFE;
  }
}

//----- (004A1128) --------------------------------------------------------
void __fastcall CPed::RestartNonPartialAnims(CPed *this)
{
  CAnimBlendAssociation *i; // r0
  uint16 m_bitsFlag; // r1

  for ( i = RpAnimBlendClumpGetFirstAssociation((RpClump_0 *)this->m_pRwObject); i; i = RpAnimBlendGetNextAssociation(i) )
  {
    m_bitsFlag = i->m_bitsFlag;
    if ( (m_bitsFlag & 0x10) == 0 )
      i->m_bitsFlag = m_bitsFlag | 1;
  }
}

//----- (004A114C) --------------------------------------------------------
void __fastcall CPed::SetLookFlag(CPed *this, float fLookHeading, bool isPersistant, bool bOverride)
{
  CEntity *m_pEntLookEntity; // r0
  int m_nPedFlags; // r1
  ePedState m_nPedState; // r0

  if ( this->m_nLookTimer < CTimer::m_snTimeInMilliseconds || bOverride )
  {
    m_pEntLookEntity = this->m_pEntLookEntity;
    m_nPedFlags = (int)this->m_nPedFlags;
    this->m_fLookHeading = fLookHeading;
    *(_DWORD *)&this->m_nPedFlags = m_nPedFlags & 0xFFFFFFF3 | 4;
    if ( m_pEntLookEntity )
      CEntity::CleanUpOldReference(m_pEntLookEntity, &this->m_pEntLookEntity);
    m_nPedState = this->m_nPedState;
    this->m_nLookTimer = 0;
    this->m_pEntLookEntity = 0;
    if ( (m_nPedState | 8) != 58 && (*((_BYTE *)&this->m_nPedFlags + 3) & 4) == 0 )
      this->m_ik.m_flags &= ~2u;
  }
}

//----- (004A11C8) --------------------------------------------------------
void __fastcall CPed::SetLookFlag(CPed *this, CEntity *pLookEntity, bool bIsPersistant, bool bOverride)
{
  CEntity *m_pEntLookEntity; // r0
  ePedState m_nPedState; // r0

  if ( this->m_nLookTimer < CTimer::m_snTimeInMilliseconds || bOverride )
  {
    m_pEntLookEntity = this->m_pEntLookEntity;
    *(_DWORD *)&this->m_nPedFlags = *(_DWORD *)&this->m_nPedFlags & 0xFFFFFFF3 | 4;
    if ( m_pEntLookEntity )
      CEntity::CleanUpOldReference(m_pEntLookEntity, &this->m_pEntLookEntity);
    this->m_pEntLookEntity = pLookEntity;
    CEntity::RegisterReference(pLookEntity, &this->m_pEntLookEntity);
    this->m_nLookTimer = 0;
    m_nPedState = this->m_nPedState;
    this->m_fLookHeading = 1000000.0;
    if ( (m_nPedState | 8) != 58 && (*((_BYTE *)&this->m_nPedFlags + 3) & 4) == 0 )
      this->m_ik.m_flags &= ~2u;
  }
}

//----- (004A125A) --------------------------------------------------------
void __fastcall CPed::SetAimFlag(CPed *this, float fLookHeading)
{
  int m_nPedFlags; // r2
  int v4; // r2
  CEntity *m_pEntLookEntity; // r0
  eWeaponType m_eWeaponType; // r5
  int8 WeaponSkill; // r0
  CWeaponInfo *WeaponInfo; // r0
  uint32 m_flags; // r1
  uint32 v10; // r2

  m_nPedFlags = (int)this->m_nPedFlags;
  this->m_fLookHeading = fLookHeading;
  this->m_nLookTimer = 0;
  v4 = m_nPedFlags & 0xFFFFFFCF | 0x10;
  m_pEntLookEntity = this->m_pEntLookEntity;
  *(_DWORD *)&this->m_nPedFlags = v4;
  if ( m_pEntLookEntity )
  {
    CEntity::CleanUpOldReference(m_pEntLookEntity, &this->m_pEntLookEntity);
    v4 = (int)this->m_nPedFlags;
  }
  this->m_pEntLookEntity = 0;
  if ( (v4 & 0x4000000) != 0 )
    this->m_ik.m_flags &= ~4u;
  m_eWeaponType = this->m_WeaponSlots[this->m_nCurrentWeapon].m_eWeaponType;
  WeaponSkill = CPed::GetWeaponSkill(this, m_eWeaponType);
  WeaponInfo = CWeaponInfo::GetWeaponInfo(m_eWeaponType, WeaponSkill);
  m_flags = this->m_ik.m_flags;
  v10 = m_flags & 0xFFFFFFFB;
  if ( (WeaponInfo->m_nFlags & 2) != 0 )
    v10 = m_flags | 4;
  this->m_ik.m_flags = v10;
}

//----- (004A12E2) --------------------------------------------------------
int8 __fastcall CPed::GetWeaponSkill(CPed *this)
{
  return CPed::GetWeaponSkill(this, this->m_WeaponSlots[this->m_nCurrentWeapon].m_eWeaponType);
}

//----- (004A12F6) --------------------------------------------------------
void __fastcall CPed::SetAimFlag(CPed *this, CEntity *pLookEntity)
{
  CEntity *m_pEntLookEntity; // r0

  m_pEntLookEntity = this->m_pEntLookEntity;
  *(_DWORD *)&this->m_nPedFlags = *(_DWORD *)&this->m_nPedFlags & 0xFFFFFFCF | 0x10;
  if ( m_pEntLookEntity )
    CEntity::CleanUpOldReference(m_pEntLookEntity, &this->m_pEntLookEntity);
  this->m_pEntLookEntity = pLookEntity;
  CEntity::RegisterReference(pLookEntity, &this->m_pEntLookEntity);
  this->m_nLookTimer = 0;
}

//----- (004A133A) --------------------------------------------------------
bool __fastcall CPed::CanWeRunAndFireWithWeapon(CPed *this)
{
  eWeaponType m_eWeaponType; // r4
  int8 WeaponSkill; // r0

  m_eWeaponType = this->m_WeaponSlots[this->m_nCurrentWeapon].m_eWeaponType;
  WeaponSkill = CPed::GetWeaponSkill(this, m_eWeaponType);
  return (LOBYTE(CWeaponInfo::GetWeaponInfo(m_eWeaponType, WeaponSkill)->m_nFlags) >> 1) & 1;
}

//----- (004A1364) --------------------------------------------------------
void __fastcall CPed::CalculateNewVelocity(CPed *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d2
  float32x2_t v4; // d3
  float32x2_t v5; // d8
  float32x2_t v6; // d9
  unsigned __int32 v8; // r0
  float m_fDesiredHeading; // r5
  float v10; // s18
  float v11; // s16
  float *p_m_fCurrentHeading; // r6
  float v13; // r0
  float v14; // s4
  float v15; // s2
  unsigned int m_nPedType; // r0
  float v17; // s16
  float m_fHeadingChangeRateAccel; // s4
  float *p_m_fHeadingChangeRateAccel; // r1
  int v20; // r2
  float v21; // s6
  int v22; // r2
  float v23; // s8
  eMoveState *p_m_eMoveState; // r5
  eMoveState m_eMoveState; // r0
  int v26; // r0
  CMatrix *m_pMat; // r0
  float y; // s0
  float x; // s14
  float z; // s10
  float *p_m_fSlopeRoll; // r5
  float v32; // s20
  int v33; // r0
  float v34; // s0
  int IsStairs; // r0
  bool v36; // zf
  float v37; // s22
  float m_fSlopeRoll; // s20
  __int64 v39; // r0
  float m_fSlopePitch; // s24
  float v41; // s0
  float v42; // s2
  CMatrix *v43; // r2
  float v44; // s8
  float v45; // s2
  float v46; // s8
  float v47; // s2
  float v48; // s4
  float v49; // s6
  float v50; // s4
  float v51; // s2
  float v52; // s0
  float v53; // s8

  if ( (*((_BYTE *)&this->m_nPedFlags + 1) & 6) == 0 )
  {
    v8 = this->m_nPedState - 54;
    if ( v8 > 9 || ((1 << v8) & 0x203) == 0 )
    {
      m_fDesiredHeading = this->m_fDesiredHeading;
      v10 = CTimer::ms_fTimeStep;
      v11 = (float)(this->m_fHeadingChangeRate * 3.1416) / 180.0;
      this->m_fCurrentHeading = CGeneral::LimitRadianAngle(this->m_fCurrentHeading);
      p_m_fCurrentHeading = &this->m_fCurrentHeading;
      v13 = CGeneral::LimitRadianAngle(m_fDesiredHeading);
      v1.n64_u32[0] = LODWORD(this->m_fCurrentHeading);
      v14 = v13;
      if ( (float)(v1.n64_f32[0] + 3.1416) >= v13 )
      {
        if ( (float)(v1.n64_f32[0] + -3.1416) <= v13 )
          goto LABEL_9;
        v15 = 6.2832;
      }
      else
      {
        v15 = -6.2832;
      }
      v14 = v13 + v15;
LABEL_9:
      v2.n64_f32[0] = v10 * v11;
      m_nPedType = this->m_nPedType;
      v17 = v14 - v1.n64_f32[0];
      if ( m_nPedType <= 1 )
      {
        m_fHeadingChangeRateAccel = 1.0;
        this->m_fHeadingChangeRateAccel = 1.0;
        p_m_fHeadingChangeRateAccel = &this->m_fHeadingChangeRateAccel;
        goto LABEL_18;
      }
      if ( v17 < 0.0
        || (p_m_fHeadingChangeRateAccel = &this->m_fHeadingChangeRateAccel, this->m_fHeadingChangeRateAccel >= 0.0) )
      {
        p_m_fHeadingChangeRateAccel = &this->m_fHeadingChangeRateAccel;
        m_fHeadingChangeRateAccel = this->m_fHeadingChangeRateAccel;
        if ( v17 >= 0.0 || m_fHeadingChangeRateAccel <= 0.0 )
        {
LABEL_18:
          v21 = v2.n64_f32[0] * fabsf(m_fHeadingChangeRateAccel);
          if ( v17 <= v21 )
          {
            if ( v17 >= (float)-v21 )
            {
              v4.n64_u32[0] = 1036831949;
              v23 = fabsf(v17);
              if ( v23 > (float)(v2.n64_f32[0] * 0.1) && m_nPedType >= 2 )
              {
                v22 = 0;
                *p_m_fCurrentHeading = (float)(v17 * 0.5) + v1.n64_f32[0];
                *p_m_fHeadingChangeRateAccel = m_fHeadingChangeRateAccel * 0.5;
                goto LABEL_28;
              }
              v2.n64_f32[0] = v23 / v2.n64_f32[0];
              v22 = 0;
              *p_m_fCurrentHeading = v17 + v1.n64_f32[0];
              v1.n64_u64[0] = vmax_f32(v2, v4).n64_u64[0];
            }
            else
            {
              *p_m_fCurrentHeading = v1.n64_f32[0] - v21;
              v22 = 1;
              v2.n64_u32[0] = -1.0;
              v1.n64_f32[0] = m_fHeadingChangeRateAccel + (float)(CTimer::ms_fTimeStep * -0.1);
              v1.n64_u64[0] = vmax_f32(v1, v2).n64_u64[0];
            }
          }
          else
          {
            *p_m_fCurrentHeading = v21 + v1.n64_f32[0];
            v22 = 1;
            v2.n64_u32[0] = 1.0;
            v1.n64_f32[0] = m_fHeadingChangeRateAccel + (float)(CTimer::ms_fTimeStep * 0.1);
            v1.n64_u64[0] = vmin_f32(v1, v2).n64_u64[0];
          }
          *p_m_fHeadingChangeRateAccel = v1.n64_f32[0];
          if ( m_nPedType <= 1 )
          {
            p_m_eMoveState = &this->m_eMoveState;
            goto LABEL_35;
          }
LABEL_28:
          m_eMoveState = this->m_eMoveState;
          p_m_eMoveState = &this->m_eMoveState;
          if ( m_eMoveState == PEDMOVE_STILL )
          {
            if ( v22 != 1 )
              goto LABEL_35;
          }
          else if ( m_eMoveState || v22 != 1 )
          {
            goto LABEL_35;
          }
          if ( !CPedIntelligence::GetTaskUseGun(this->m_pPedIntelligence)
            && !CPedIntelligence::GetTaskFighting(this->m_pPedIntelligence) )
          {
            if ( v17 > 0.0 )
              v26 = 2;
            else
              v26 = 3;
            goto LABEL_37;
          }
LABEL_35:
          if ( (*p_m_eMoveState & 0xFFFFFFFE) != 2 )
          {
LABEL_38:
            this->m_ik.m_fBodyRoll = 0.0;
            goto LABEL_39;
          }
          v26 = 1;
LABEL_37:
          *p_m_eMoveState = v26;
          goto LABEL_38;
        }
        v20 = -1110651699;
        m_fHeadingChangeRateAccel = -0.1;
      }
      else
      {
        v20 = 1036831949;
        m_fHeadingChangeRateAccel = 0.1;
      }
      *(_DWORD *)p_m_fHeadingChangeRateAccel = v20;
      goto LABEL_18;
    }
  }
LABEL_39:
  m_pMat = this->m_pMat;
  y = this->m_vecGroundNormal.y;
  x = this->m_vecGroundNormal.x;
  z = this->m_vecGroundNormal.z;
  v5.n64_f32[0] = (float)((float)(x * m_pMat->xx) + (float)(y * m_pMat->yx)) + (float)(z * m_pMat->zx);
  v6.n64_f32[0] = (float)((float)(x * m_pMat->xy) + (float)(y * m_pMat->yy)) + (float)(z * m_pMat->zy);
  if ( (this->m_ik.m_flags & 8) != 0 )
  {
    if ( this->m_nPedState != PED_DIE )
    {
      v33 = *((_DWORD *)&this->m_nPedFlags + 2);
      if ( (v33 & 0x100000) == 0 )
      {
        if ( this->m_eMoveState < PEDMOVE_WALK )
          goto LABEL_53;
        IsStairs = SurfaceInfos_c::IsStairs(&g_surfaceInfos, this->m_LastMaterialToHaveBeenStandingOn);
        v36 = IsStairs == 0;
        if ( !IsStairs )
          v36 = (*((_DWORD *)&this->m_nPedFlags + 3) & 0x4000) == 0;
        if ( !v36 )
        {
LABEL_53:
          p_m_fSlopeRoll = &this->m_ik.m_fSlopeRoll;
          v37 = 0.0;
          m_fSlopeRoll = this->m_ik.m_fSlopeRoll;
          v39 = 0LL;
          m_fSlopePitch = this->m_ik.m_fSlopePitch;
          v41 = 0.0;
          if ( m_fSlopeRoll != 0.0 )
            HIDWORD(v39) = 1;
          if ( m_fSlopePitch != 0.0 )
            LODWORD(v39) = 1;
          if ( v39 )
            v41 = powf(0.9, CTimer::ms_fTimeStep);
          v42 = fabsf(m_fSlopeRoll);
          if ( fabsf(m_fSlopePitch) > 0.01 )
            v37 = v41 * m_fSlopePitch;
          this->m_ik.m_fSlopePitch = v37;
          if ( v42 <= 0.02 )
            goto LABEL_63;
          *p_m_fSlopeRoll = v41 * m_fSlopeRoll;
          goto LABEL_64;
        }
        if ( this->m_nPedState == PED_DIE )
          goto LABEL_47;
        v33 = *((_DWORD *)&this->m_nPedFlags + 2);
      }
      if ( (v33 & 0x100000) == 0 )
      {
        v34 = 0.0;
        goto LABEL_48;
      }
    }
LABEL_47:
    v1.n64_u32[0] = -1.0;
    v2.n64_u32[0] = 1.0;
    v34 = asinf(vmin_f32(vmax_f32(v5, v1), v2).n64_f32[0]);
LABEL_48:
    v2.n64_u32[0] = -1.0;
    v3.n64_u32[0] = 1.0;
    this->m_ik.m_fSlopeRoll = v34;
    v2.n64_u64[0] = vmin_f32(vmax_f32(v6, v2), v3).n64_u64[0];
    this->m_ik.m_fSlopePitch = (float)(asinf(v2.n64_f32[0]) * 0.25) + (float)(this->m_ik.m_fSlopePitch * 0.75);
    goto LABEL_64;
  }
  if ( this->m_eMoveState >= PEDMOVE_WALK && this->m_nPedType >= 2u )
  {
    p_m_fSlopeRoll = &this->m_ik.m_fSlopeRoll;
    v32 = this->m_ik.m_fSlopeRoll;
    if ( fabsf(v32) > 0.02 )
      *p_m_fSlopeRoll = v32 * powf(0.9, CTimer::ms_fTimeStep);
LABEL_63:
    *p_m_fSlopeRoll = 0.0;
  }
LABEL_64:
  v3.n64_u32[0] = 0;
  v43 = this->m_pMat;
  v44 = this->m_extractedVelocity.y;
  this->m_vecCurrentVelocity.x = 0.0;
  this->m_vecCurrentVelocity.y = 0.0;
  v2.n64_f32[0] = 1.0 - (float)(v6.n64_f32[0] * v6.n64_f32[0]);
  v4.n64_f32[0] = 1.0 - (float)(v5.n64_f32[0] * v5.n64_f32[0]);
  v45 = sqrtf(vmax_f32(v2, v3).n64_f32[0]) * v44;
  v46 = (float)(v45 * v43->xy) + 0.0;
  v47 = (float)(v45 * v43->yy) + 0.0;
  v48 = sqrtf(vmax_f32(v4, v3).n64_f32[0]) * this->m_extractedVelocity.x;
  this->m_vecCurrentVelocity.x = v46;
  this->m_vecCurrentVelocity.y = v47;
  v49 = (float)(v48 * v43->xx) + v46;
  v50 = (float)(v48 * v43->yx) + v47;
  v51 = 0.01;
  this->m_vecCurrentVelocity.x = v49;
  this->m_vecCurrentVelocity.y = v50;
  if ( CTimer::ms_fTimeStep >= 0.01 || CTimer::bSlowMotionActive )
  {
    v53 = 1.0 / CTimer::ms_fTimeStep;
    v52 = (float)(1.0 / CTimer::ms_fTimeStep) * v49;
    v51 = v50;
  }
  else
  {
    v52 = v49 * 0.01;
    v53 = v50;
  }
  this->m_vecCurrentVelocity.x = v52;
  this->m_vecCurrentVelocity.y = v51 * v53;
}
// 4A14BA: variable 'v1' is possibly undefined
// 4A14BA: variable 'v2' is possibly undefined
// 4A153E: variable 'v4' is possibly undefined
// 4A1670: variable 'v5' is possibly undefined
// 4A1694: variable 'v6' is possibly undefined
// 4A1698: variable 'v3' is possibly undefined

//----- (004A18D0) --------------------------------------------------------
bool __fastcall CPed::IsPedInControl(CPed *this)
{
  ePedState m_nPedState; // r1
  bool result; // r0

  result = (*((_BYTE *)&this->m_nPedFlags + 1) & 6) == 0
        && (m_nPedState = this->m_nPedState, (m_nPedState & 0xFFFFFFFE) != 54)
        && m_nPedState != PED_ARRESTED;
  return result;
}

//----- (004A18F4) --------------------------------------------------------
float __fastcall CPed::WorkOutHeadingForMovingFirstPerson(CPed *this, float CurrentHeading)
{
  CPad *Pad; // r0
  int PedWalkLeftRight; // r5
  CPad *v6; // r0
  int PedWalkUpDown; // r0
  int RadianAngleBetweenPoints; // s0

  if ( this->m_nPedType > 1u || !this->m_pPlayerData )
    return 0.0;
  Pad = CPad::GetPad(0);
  PedWalkLeftRight = CPad::GetPedWalkLeftRight(Pad);
  v6 = CPad::GetPad(0);
  PedWalkUpDown = CPad::GetPedWalkUpDown(v6);
  if ( PedWalkUpDown )
  {
    RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(
                                 0.0,
                                 0.0,
                                 -(float)PedWalkLeftRight,
                                 (float)PedWalkUpDown);
  }
  else if ( PedWalkLeftRight <= 0 )
  {
    if ( PedWalkLeftRight >= 0 )
      return sub_192588(this->m_pPlayerData->m_fFPSMoveHeading + CurrentHeading);
    RadianAngleBetweenPoints = 1070141403;
  }
  else
  {
    RadianAngleBetweenPoints = -1077342245;
  }
  LODWORD(this->m_pPlayerData->m_fFPSMoveHeading) = RadianAngleBetweenPoints;
  return sub_192588(this->m_pPlayerData->m_fFPSMoveHeading + CurrentHeading);
}

//----- (004A1998) --------------------------------------------------------
void __fastcall CPed::UpdatePosition(CPed *this)
{
  CMatrix *r0_4; // r0
  CMatrix *m_pMat; // r0
  CTask *v4; // r0
  CPhysical *m_pGroundPhysical; // r1
  int v6; // r0
  bool v7; // zf
  float x; // s6
  float y; // s8
  float v10; // s2
  CPhysical *v11; // r0
  float v12; // s8
  float v13; // s4
  float v14; // s0
  float v15; // s6
  float v16; // s10
  float v17; // s2
  float v18; // s4
  float v19; // s0
  __int64 v20; // r0
  float v21; // s2
  float v22; // s2
  float v23; // s8
  CMatrix *v24; // r0
  CSimpleTransform *p_tx; // r2
  float v26; // s0
  CMatrix *v27; // r0
  float *p_x; // r2
  float v29; // s2
  float v30; // s3
  float v31; // s1
  float v32; // s14
  float v33; // s6
  float v34; // s10
  float v35; // s10
  CPhysical *v36; // r0
  float v37; // s10
  float v38; // s8
  float v39; // s8
  float v40; // s10
  RwReal z; // r1
  float v42; // s10
  bool v43; // fzf
  bool v44; // fnf
  CVector v45; // [sp+4h] [bp-24h] BYREF
  CVector v2; // [sp+10h] [bp-18h] BYREF

  if ( *(_BYTE *)&this->m_nPedFlags << 31 )
  {
    if ( this->m_pAttachToEntity )
      return;
    m_pMat = this->m_pMat;
    if ( m_pMat )
      CMatrix::SetRotateZOnly(m_pMat, this->m_fCurrentHeading);
    else
      this->m_transform.m_heading = this->m_fCurrentHeading;
    m_pGroundPhysical = this->m_pGroundPhysical;
    if ( m_pGroundPhysical )
    {
      if ( this->m_nPedType < 2u )
        goto LABEL_20;
      v6 = *(_BYTE *)&m_pGroundPhysical->m_info & 7;
      v7 = v6 == 2;
      if ( v6 == 2 )
        v7 = LODWORD(m_pGroundPhysical[4].m_vecCOM.z) == 5;
      if ( v7 )
      {
        v24 = this->m_pMat;
        p_tx = (CSimpleTransform *)&v24->tx;
        if ( !v24 )
          p_tx = &this->m_transform;
        v2 = p_tx->m_translate;
        v26 = v2.z + -1.0;
        v2.z = v2.z + -1.0;
        v27 = m_pGroundPhysical->m_pMat;
        p_x = &v27->tx;
        if ( !v27 )
          p_x = &m_pGroundPhysical->m_transform.m_translate.x;
        v2.x = v2.x - *p_x;
        v2.y = v2.y - p_x[1];
        v2.z = v26 - p_x[2];
        CrossProduct(&v45, &m_pGroundPhysical->m_vecTurnSpeed, &v2);
        v11 = this->m_pGroundPhysical;
        v29 = (float)((float)(v11->m_vecTurnSpeed.x * v11->m_vecTurnSpeed.x)
                    + (float)(v11->m_vecTurnSpeed.y * v11->m_vecTurnSpeed.y))
            + (float)(v11->m_vecTurnSpeed.z * v11->m_vecTurnSpeed.z);
        v30 = v2.z * v29;
        v31 = v2.y * v29;
        v32 = v2.x * v29;
        v10 = CTimer::ms_fTimeStep;
        y = (float)(v45.y + v11->m_vecMoveSpeed.y) - (float)(v31 * CTimer::ms_fTimeStep);
        x = (float)(v45.x + v11->m_vecMoveSpeed.x) - (float)(v32 * CTimer::ms_fTimeStep);
        this->m_vecMoveSpeed.z = (float)(v45.z + v11->m_vecMoveSpeed.z) - (float)(v30 * CTimer::ms_fTimeStep);
      }
      else
      {
LABEL_20:
        CPhysical::GetSpeed(&v2, m_pGroundPhysical, this->m_vecGroundOffset);
        x = v2.x;
        y = v2.y;
        v10 = CTimer::ms_fTimeStep;
        v11 = this->m_pGroundPhysical;
      }
      v12 = y + this->m_vecCurrentVelocity.y;
      v13 = this->m_vecMoveSpeed.x;
      v14 = this->m_vecMoveSpeed.y;
      v15 = (float)(x + this->m_vecCurrentVelocity.x) - v13;
      this->m_fCurrentHeading = this->m_fCurrentHeading + (float)(v11->m_vecTurnSpeed.z * v10);
      v16 = this->m_fDesiredHeading + (float)(v11->m_vecTurnSpeed.z * v10);
      v17 = v12 - v14;
      this->m_fDesiredHeading = v16;
    }
    else
    {
      if ( !SurfaceInfos_c::IsSteepSlope(&g_surfaceInfos, this->m_LastMaterialToHaveBeenStandingOn) )
        goto LABEL_30;
      v18 = this->m_vecGroundNormal.y;
      v19 = this->m_vecGroundNormal.x;
      v20 = 0LL;
      if ( v18 != 0.0 )
        HIDWORD(v20) = 1;
      if ( v19 != 0.0 )
        LODWORD(v20) = 1;
      if ( v20 )
      {
        v21 = (float)(v19 * v19) + (float)(v18 * v18);
        if ( v21 <= 0.0 )
        {
          v23 = 1.0;
        }
        else
        {
          v22 = 1.0 / sqrtf(v21);
          v18 = v18 * v22;
          v23 = v19 * v22;
        }
        v33 = this->m_vecCurrentVelocity.y;
        v34 = this->m_vecCurrentVelocity.x;
        this->m_vecMoveSpeed.x = 0.0;
        this->m_vecMoveSpeed.y = 0.0;
        this->m_vecMoveSpeed.z = -0.001;
        v17 = (float)(v18 * 0.02) + v33;
        v15 = (float)(v23 * 0.02) + v34;
        v35 = (float)(v23 * v15) + (float)(v18 * v17);
        v14 = 0.0;
        if ( v35 < 0.0 )
        {
          v17 = v17 - (float)(v18 * v35);
          v15 = v15 - (float)(v23 * v35);
        }
        v13 = 0.0;
      }
      else
      {
LABEL_30:
        v13 = this->m_vecMoveSpeed.x;
        v14 = this->m_vecMoveSpeed.y;
        v17 = this->m_vecCurrentVelocity.y - v14;
        v15 = this->m_vecCurrentVelocity.x - v13;
      }
    }
    v36 = this->m_pGroundPhysical;
    if ( !v36 || v36->m_pAttachToEntity || (*(_DWORD *)&v36->m_nPhysicalFlags & 0xC) == 4 )
    {
      if ( (*((_BYTE *)&this->m_nPedFlags + 10) & 0x10) == 0 || v36 )
      {
LABEL_48:
        this->m_vecMoveSpeed.x = v15 + v13;
        this->m_vecMoveSpeed.y = v17 + v14;
        return;
      }
      v37 = CTimer::ms_fTimeStep * 0.01;
      v38 = sqrtf((float)(v15 * v15) + (float)(v17 * v17));
LABEL_46:
      if ( v38 > v37 )
      {
        v39 = v37 / v38;
        v17 = v17 * v39;
        v15 = v15 * v39;
      }
      goto LABEL_48;
    }
    v40 = 0.01;
    v38 = sqrtf((float)(v15 * v15) + (float)(v17 * v17));
    if ( (*(_BYTE *)&v36->m_info & 7) == 2 )
    {
      if ( this->m_nPedState == PED_DIE )
      {
        v40 = 0.002;
      }
      else
      {
        z = v36[4].m_vecCOM.z;
        if ( z != 0.0 )
        {
          v37 = v38;
          if ( LODWORD(z) != 9 )
            goto LABEL_46;
          v42 = (float)((float)(v36->m_vecMoveSpeed.x * v36->m_vecMoveSpeed.x)
                      + (float)(v36->m_vecMoveSpeed.y * v36->m_vecMoveSpeed.y))
              + (float)(v36->m_vecMoveSpeed.z * v36->m_vecMoveSpeed.z);
          v43 = v42 == 0.04;
          v44 = v42 < 0.04;
          v37 = v38;
          if ( v44 || v43 )
            goto LABEL_46;
          v40 = 0.0002;
        }
      }
    }
    v37 = v40 * CTimer::ms_fTimeStep;
    goto LABEL_46;
  }
  if ( CPedIntelligence::GetTaskSwim(this->m_pPedIntelligence)
    || CPedIntelligence::GetTaskJetPack(this->m_pPedIntelligence)
    || (v4 = this->m_pPedIntelligence->m_taskManager.m_tasks[3]) != 0
    && (*((int (__fastcall **)(CTask *))v4->_vptr$CTask + 5))(v4) == 108 )
  {
    r0_4 = this->m_pMat;
    if ( r0_4 )
      sub_198CB0(r0_4, this->m_fCurrentHeading);
    else
      this->m_transform.m_heading = this->m_fCurrentHeading;
  }
}

//----- (004A1DC4) --------------------------------------------------------
void __fastcall CPed::CalculateNewOrientation(CPed *this)
{
  unsigned __int32 v2; // r0
  CMatrix *m_pMat; // r0
  float tx; // s16
  float ty; // s18
  float tz; // s20
  CMatrix *v7; // r0
  float v8; // s2
  float v9; // s4

  if ( (*((_BYTE *)&this->m_nPedFlags + 1) & 6) == 0 )
  {
    v2 = this->m_nPedState - 54;
    if ( v2 > 9 || ((1 << v2) & 0x203) == 0 )
    {
      m_pMat = this->m_pMat;
      if ( m_pMat )
      {
        tx = m_pMat->tx;
        ty = m_pMat->ty;
        tz = m_pMat->tz;
        CMatrix::SetRotate(m_pMat, 0.0, 0.0, this->m_fCurrentHeading);
        v7 = this->m_pMat;
        v8 = ty + v7->ty;
        v9 = tz + v7->tz;
        v7->tx = tx + v7->tx;
        v7->ty = v8;
        v7->tz = v9;
      }
      else
      {
        this->m_transform.m_heading = this->m_fCurrentHeading;
      }
    }
  }
}

//----- (004A1E50) --------------------------------------------------------
void __fastcall CPed::ClearAll(CPed *this)
{
  int m_nPedFlags; // r3
  ePedState m_nPedState; // r2
  int v3; // r12
  int v4; // lr
  int v5; // r1

  m_nPedFlags = (int)this->m_nPedFlags;
  m_nPedState = this->m_nPedState;
  v3 = *((_DWORD *)&this->m_nPedFlags + 2);
  v4 = *((_DWORD *)&this->m_nPedFlags + 3);
  if ( (m_nPedFlags & 0x600) != 0 )
  {
    if ( m_nPedState != PED_DEAD )
      return;
    goto LABEL_3;
  }
  if ( m_nPedState != PED_DIE && m_nPedState != PED_ARRESTED )
  {
LABEL_3:
    v5 = *((_DWORD *)&this->m_nPedFlags + 1) & 0x7FFFFFEF;
    this->m_nPedState = PED_NONE;
    this->m_eMoveState = PEDMOVE_NONE;
    *(_DWORD *)&this->m_nPedFlags = m_nPedFlags | 0x2000;
    *((_DWORD *)&this->m_nPedFlags + 1) = v5;
    *((_DWORD *)&this->m_nPedFlags + 2) = v3;
    *((_DWORD *)&this->m_nPedFlags + 3) = v4;
    this->m_pNOCollisionVehicle = 0;
  }
}

//----- (004A1EA4) --------------------------------------------------------
void __fastcall CPed::SetPedState(CPed *this, const ePedState pedState)
{
  CCoverPoint *m_pCoverPoint; // r0

  if ( (pedState | 1) == 55 )
  {
    m_pCoverPoint = this->m_pCoverPoint;
    if ( m_pCoverPoint )
    {
      CCoverPoint::ReleaseCoverPointForPed(m_pCoverPoint, this);
      this->m_pCoverPoint = 0;
    }
    if ( (*((_BYTE *)&this->m_nPedFlags + 9) & 0x20) != 0 )
      CRadar::ClearBlipForEntity(
        BLIPTYPE_CHAR,
        CPools::ms_pPedPool->m_aFlags[-1093107909 * (((char *)this - (char *)CPools::ms_pPedPool->m_aStorage) >> 2)] | (-662750464 * (((char *)this - (char *)CPools::ms_pPedPool->m_aStorage) >> 2)));
  }
  this->m_nPedState = pedState;
}

//----- (004A1F00) --------------------------------------------------------
void __fastcall CPed::ProcessBuoyancy(CPed *this)
{
  int *v2; // r1
  CPedFlags *p_m_nPedFlags; // r9
  bool v4; // zf
  CEntity *m_pEntityStandingOn; // r0
  int v6; // r1
  bool v7; // zf
  CPedIntelligence *v8; // r0
  CTask *SimplestActiveTask; // r0
  CPedIntelligence *m_pPedIntelligence; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r2
  CEntity *v13; // r5
  int v14; // r0
  bool v15; // zf
  CMatrix *v16; // r0
  float AmbientRed; // r8
  float m_fDirectionalLightMultiplier; // s18
  float AmbientGreen; // r10
  float v20; // s22
  float AmbientBlue; // r5
  float v22; // s0
  unsigned __int16 v23; // r0
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r0
  float z; // s0
  CMatrix *v26; // r0
  CSimpleTransform *p_m_transform; // r1
  float v28; // s0
  RwReal v29; // s4
  RwReal v30; // s0
  CMatrix *v31; // r0
  CSimpleTransform *v32; // r2
  CTaskSimpleSwim *TaskSwim; // r5
  CTask *v34; // r0
  int v35; // r1
  __int64 v36; // r0
  CTask *v37; // r0
  __int64 v38; // r0
  float v39; // r0
  float v40; // s0
  RwReal v41; // s6
  RpHAnimHierarchy_0 *AnimHierarchyFromSkinClump; // r5
  RwInt32 v43; // r6
  RwMatrix *MatrixArray; // r0
  CEntity *refEntityPtr; // [sp+1Ch] [bp-9Ch] BYREF
  CColPoint colPoint; // [sp+20h] [bp-98h] BYREF
  CVector vecStart; // [sp+50h] [bp-68h] BYREF
  CVector v48; // [sp+60h] [bp-58h] BYREF
  CVector pCentreOfBuoyancy; // [sp+6Ch] [bp-4Ch] BYREF

  if ( *((unsigned __int8 *)&this->m_nPedFlags + 1) << 31 )
    return;
  v2 = dword_4A2458;
  if ( (this->m_nPedState & 0xFFFFFFFE) == 54 )
    v2 = &dword_4A2458[1];
  if ( cBuoyancy::ProcessBuoyancy(
         &mod_Buoyancy,
         this,
         (float)(this->m_fMass * 0.008) * *(float *)v2,
         &pCentreOfBuoyancy,
         &v48) != 1 )
  {
    m_pPedIntelligence = this->m_pPedIntelligence;
    *(_DWORD *)&this->m_nPhysicalFlags &= ~0x8000000u;
    if ( CPedIntelligence::GetTaskSwim(m_pPedIntelligence) )
      CTaskManager::GetSimplestActiveTask(&this->m_pPedIntelligence->m_taskManager)[11]._vptr$CTask = (int (**)(void))1148846080;
    return;
  }
  p_m_nPedFlags = &this->m_nPedFlags;
  m_pEntityStandingOn = (CEntity *)(*(_BYTE *)&this->m_nPedFlags << 31);
  v4 = m_pEntityStandingOn == 0;
  if ( m_pEntityStandingOn )
  {
    m_pEntityStandingOn = this->m_pEntityStandingOn;
    v4 = m_pEntityStandingOn == 0;
  }
  if ( !v4 )
  {
    v6 = *(_BYTE *)&m_pEntityStandingOn->m_info & 7;
    v7 = v6 == 2;
    if ( v6 == 2 )
      v7 = m_pEntityStandingOn[24]._vptr$CPlaceable == (int (**)(void))&byte_5;
    if ( v7 && (HIBYTE(m_pEntityStandingOn[1].m_transform.m_translate.y) & 0x20) == 0 )
    {
      v8 = this->m_pPedIntelligence;
      *(_DWORD *)&this->m_nPhysicalFlags &= ~0x100u;
      if ( CPedIntelligence::GetTaskSwim(v8) )
      {
        SimplestActiveTask = CTaskManager::GetSimplestActiveTask(&this->m_pPedIntelligence->m_taskManager);
LABEL_49:
        *(float *)&SimplestActiveTask[11]._vptr$CTask = CTimer::ms_fTimeStep
                                                      + *(float *)&SimplestActiveTask[11]._vptr$CTask;
        return;
      }
      return;
    }
  }
  if ( this->m_pPlayerData )
  {
    m_pMat = this->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &this->m_transform;
    vecStart = p_tx->m_translate;
    if ( CWorld::ProcessVerticalLine(&vecStart, vecStart.z + -3.0, &colPoint, &refEntityPtr, 0, 1, 0, 0, 0, 0, 0) )
    {
      v13 = refEntityPtr;
      v14 = *(_BYTE *)&refEntityPtr->m_info & 7;
      v15 = v14 == 2;
      if ( v14 == 2 )
        v15 = refEntityPtr[24]._vptr$CPlaceable == (int (**)(void))&byte_5;
      if ( v15 && (HIBYTE(refEntityPtr[1].m_transform.m_translate.y) & 0x20) == 0 )
      {
        v16 = refEntityPtr->m_pMat;
        if ( !v16 )
        {
          CPlaceable::AllocateMatrix(refEntityPtr);
          CSimpleTransform::UpdateMatrix(&v13->m_transform, v13->m_pMat);
          v16 = v13->m_pMat;
        }
        if ( v16->zz > 0.0 )
        {
          *(_DWORD *)&this->m_nPhysicalFlags &= ~0x100u;
          return;
        }
      }
    }
  }
  AmbientRed = CTimeCycle::GetAmbientRed();
  m_fDirectionalLightMultiplier = CTimeCycle::m_CurrentColours.m_fDirectionalLightMultiplier;
  AmbientGreen = CTimeCycle::GetAmbientGreen();
  v20 = CTimeCycle::m_CurrentColours.m_fDirectionalLightMultiplier;
  AmbientBlue = CTimeCycle::GetAmbientBlue();
  v22 = CTimeCycle::m_CurrentColours.m_fDirectionalLightMultiplier * 255.0;
  v23 = rand();
  CRGBA::CRGBA(
    (CRGBA *)&refEntityPtr,
    (int)(float)((float)(AmbientRed + (float)((float)((float)(m_fDirectionalLightMultiplier * 255.0) * 0.0039062) * 0.5))
               * 127.5),
    (int)(float)((float)(AmbientGreen + (float)((float)((float)(v20 * 255.0) * 0.0039062) * 0.5)) * 127.5),
    (int)(float)((float)(AmbientBlue + (float)((float)(v22 * 0.0039062) * 0.5)) * 127.5),
    (int)(float)((float)((float)v23 * 0.000015259) * 48.0) + 48);
  m_nPhysicalFlags = this->m_nPhysicalFlags;
  if ( (*(_DWORD *)&m_nPhysicalFlags & 0x8000000) == 0 )
  {
    z = this->m_vecMoveSpeed.z;
    if ( z < -0.01 )
    {
      v26 = this->m_pMat;
      p_m_transform = (CSimpleTransform *)&v26->tx;
      v28 = CTimer::ms_fTimeStep * z;
      if ( !v26 )
        p_m_transform = &this->m_transform;
      v29 = (float)((float)(CTimer::ms_fTimeStep * this->m_vecMoveSpeed.y) * 4.0) + p_m_transform->m_translate.y;
      v30 = (float)(v28 * 4.0) + p_m_transform->m_translate.z;
      colPoint.m_vecPosition.x = (float)((float)(CTimer::ms_fTimeStep * this->m_vecMoveSpeed.x) * 4.0)
                               + p_m_transform->m_translate.x;
      colPoint.m_vecPosition.y = v29;
      colPoint.m_vecPosition.z = v30;
      if ( CWaterLevel::GetWaterLevel(colPoint.m_vecPosition.x, v29, v30, &vecStart.x, 1, 0) == 1 )
      {
        colPoint.m_vecPosition.z = vecStart.x;
        Fx_c::TriggerWaterSplash(&g_fx, &colPoint.m_vecPosition);
        CAudioEngine::ReportWaterSplash(&AudioEngine, this, -100.0, 1u);
      }
      m_nPhysicalFlags = this->m_nPhysicalFlags;
    }
  }
  this->m_nPhysicalFlags = (CPhysical::CPhysicalFlags)(*(_DWORD *)&m_nPhysicalFlags | 0x8000100);
  CPhysical::ApplyMoveForce(this, v48);
  if ( (float)(v48.z / this->m_fMass) > (float)(CTimer::ms_fTimeStep * 0.008) )
    goto LABEL_41;
  v31 = this->m_pMat;
  v32 = (CSimpleTransform *)&v31->tx;
  if ( !v31 )
    v32 = &this->m_transform;
  if ( mod_Buoyancy.fWaterLevel > (float)(v32->m_translate.z + 0.6) )
  {
LABEL_41:
    if ( this->m_nPedType > 1u )
    {
      v36 = *(_QWORD *)p_m_nPedFlags | 0x8000000000000LL;
      LODWORD(v36) = *(_DWORD *)p_m_nPedFlags & 0xFFFFFFFE;
      *(_QWORD *)p_m_nPedFlags = v36;
      CEventInWater::CEventInWater((CEventInWater *)&colPoint, 0.75);
      CEventGroup::Add(&this->m_pPedIntelligence->m_eventGroup, (CEvent *)&colPoint, 0);
      CEvent::~CEvent((CEvent *)&colPoint);
    }
    else
    {
      TaskSwim = CPedIntelligence::GetTaskSwim(this->m_pPedIntelligence);
      v34 = CTaskManager::GetSimplestActiveTask(&this->m_pPedIntelligence->m_taskManager);
      if ( TaskSwim )
      {
        v34[11]._vptr$CTask = 0;
LABEL_44:
        v35 = *((_DWORD *)&this->m_nPedFlags + 1);
        *(_DWORD *)p_m_nPedFlags &= ~1u;
        *((_DWORD *)&this->m_nPedFlags + 1) = v35 | 0x80000;
        return;
      }
      if ( v34 )
      {
        v37 = CTaskManager::GetSimplestActiveTask(&this->m_pPedIntelligence->m_taskManager);
        if ( (*((int (__fastcall **)(CTask *))v37->_vptr$CTask + 5))(v37) == 254 )
          goto LABEL_44;
      }
      CEventInWater::CEventInWater(
        (CEventInWater *)&colPoint,
        v48.z / (float)((float)(this->m_fMass * 0.008) * CTimer::ms_fTimeStep));
      CEventGroup::Add(&this->m_pPedIntelligence->m_eventGroup, (CEvent *)&colPoint, 0);
      CEvent::~CEvent((CEvent *)&colPoint);
      v38 = *(_QWORD *)p_m_nPedFlags | 0x8000000000000LL;
      LODWORD(v38) = *(_DWORD *)p_m_nPedFlags & 0xFFFFFFFE;
      *(_QWORD *)p_m_nPedFlags = v38;
    }
    v39 = powf(0.9, CTimer::ms_fTimeStep);
    v40 = this->m_vecMoveSpeed.z;
    v41 = v39 * this->m_vecMoveSpeed.y;
    this->m_vecMoveSpeed.x = v39 * this->m_vecMoveSpeed.x;
    this->m_vecMoveSpeed.y = v41;
    if ( v40 < 0.0 )
      this->m_vecMoveSpeed.z = v39 * v40;
    return;
  }
  if ( *(_BYTE *)p_m_nPedFlags << 31 && CPedIntelligence::GetTaskSwim(this->m_pPedIntelligence) )
  {
    SimplestActiveTask = CTaskManager::GetSimplestActiveTask(&this->m_pPedIntelligence->m_taskManager);
    goto LABEL_49;
  }
  if ( this->m_pPlayerData )
  {
    vecStart.x = 0.0;
    vecStart.y = 0.0;
    vecStart.z = 0.1;
    if ( (*((_BYTE *)&this->m_nPedFlags + 9) & 4) != 0 )
    {
      AnimHierarchyFromSkinClump = GetAnimHierarchyFromSkinClump((RpClump_0 *)this->m_pRwObject);
      v43 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, 5);
      MatrixArray = RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump);
      RwV3dTransformPoints(&vecStart, &vecStart, 1, &MatrixArray[v43]);
    }
    else
    {
      operator*(&colPoint.m_vecPosition, this->m_pMat, &aStdBonePosisions[5]);
      vecStart = colPoint.m_vecPosition;
    }
    if ( vecStart.z < mod_Buoyancy.fWaterLevel )
      CPlayerPed::HandlePlayerBreath((CPlayerPed *)this, 1, 1.0);
  }
}
// 5: using guessed type char byte_5;
// 4A2458: using guessed type int dword_4A2458[2];

//----- (004A24A8) --------------------------------------------------------
void __fastcall CPed::GetTransformedBonePosition(CPed *this, RwV3d_0 *posn, uint32 boneTag, bool bCalledFromCamera)
{
  int v7; // r0
  RpHAnimHierarchy_0 *AnimHierarchyFromSkinClump; // r6
  RwInt32 v9; // r5
  RwMatrix *MatrixArray; // r0
  __int64 v11; // d16
  CVector v12; // [sp+0h] [bp-28h] BYREF

  v7 = *((_DWORD *)&this->m_nPedFlags + 2) & 0x400;
  if ( bCalledFromCamera )
  {
    if ( !v7 )
    {
      CEntity::UpdateRpHAnim(this);
      *((_DWORD *)&this->m_nPedFlags + 2) |= 0x400u;
    }
    goto LABEL_5;
  }
  if ( v7 )
  {
LABEL_5:
    AnimHierarchyFromSkinClump = GetAnimHierarchyFromSkinClump((RpClump_0 *)this->m_pRwObject);
    v9 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, boneTag);
    MatrixArray = RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump);
    sub_1A1678(posn, posn, 1, &MatrixArray[v9]);
    return;
  }
  operator*(&v12, this->m_pMat, &aStdBonePosisions[boneTag]);
  v11 = *(_QWORD *)&v12.x;
  posn->z = v12.z;
  *(_QWORD *)&posn->x = v11;
}

//----- (004A2540) --------------------------------------------------------
void __fastcall CPed::ProcessControl(CPed *this)
{
  char *v2; // r5
  FxSystem_c **v3; // r8
  RpHAnimHierarchy_0 *AnimHierarchyFromSkinClump; // r5
  RwInt32 v5; // r6
  RwMatrix *MatrixArray; // r0
  FxSystem_c *v7; // r0
  FxSystem_c *v8; // r1
  CPedFlags *p_m_nPedFlags; // r6
  int ClumpAlpha; // r1
  int v11; // r12
  int v12; // lr
  bool v13; // zf
  int v14; // r3
  int v15; // r5
  CPhysical *m_pGroundPhysical; // r0
  bool v17; // zf
  CVehicle *m_pMyVehicle; // r0
  int32 v19; // r0
  float *p_m_fHitHeadHeight; // r2
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  int v23; // r3
  int m_nGunFlashBlendAmount; // r2
  unsigned int v25; // r1
  int16 v26; // r2
  int m_nGunFlashBlendAmount2; // r2
  unsigned int v28; // r1
  int16 v29; // r2
  CPlayerPed *PlayerPed; // r0
  CPlayerPedData *m_pPlayerData; // r0
  int m_wetness; // r1
  int8 v33; // r1
  int v34; // r1
  bool v35; // zf
  CPhysical *v36; // r0
  int v37; // r1
  bool v38; // zf
  int v39; // r8
  int v40; // r5
  float z; // s16
  float v42; // r0
  RwReal v43; // s2
  bool v44; // zf
  ePedState *p_m_nPedState; // r5
  int v46; // r0
  bool v47; // zf
  CMatrix *v48; // r1
  CSimpleTransform *p_m_transform; // r2
  CSimpleTransform *v50; // r1
  float32x2_t v51; // d16
  unsigned __int64 v52; // d1
  char v53; // r8
  float tx; // s16
  float ty; // s16
  RwTexture_0 *v56; // r9
  __int16 v57; // r0
  CPed *v58; // r0
  UInt8 v59; // r1
  unsigned __int32 v60; // r0
  TouchSense *v61; // r0
  int v62; // r1
  int v63; // r2
  int v64; // r3
  RwV3d_0 offsetPos; // [sp+2Ch] [bp-3Ch] BYREF

  CAEPedAudioEntity::Service(&this->m_PedAudioEntity);
  if ( this->m_nPedType <= 1u )
  {
    v2 = (char *)this + 28 * this->m_nCurrentWeapon;
    if ( *((_DWORD *)v2 + 361) == 18 )
    {
      if ( (*((_BYTE *)&this->m_nPedFlags + 8) & 2) != 0
        || (*(_BYTE *)&this->m_nFlags & 0x80) == 0
        || *((unsigned __int8 *)&this->m_nPhysicalFlags + 1) << 31
        && CPedIntelligence::GetTaskSwim(this->m_pPedIntelligence)
        || !this->m_pWeaponClump )
      {
        v8 = (FxSystem_c *)*((_DWORD *)v2 + 367);
        if ( v8 )
        {
          FxManager_c::DestroyFxSystem(&g_fxMan, v8);
          *((_DWORD *)v2 + 367) = 0;
        }
      }
      else if ( !*((_DWORD *)v2 + 367) )
      {
        v3 = (FxSystem_c **)(v2 + 1468);
        AnimHierarchyFromSkinClump = GetAnimHierarchyFromSkinClump((RpClump_0 *)this->m_pRwObject);
        v5 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, 24);
        MatrixArray = RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump);
        memset(&offsetPos, 0, sizeof(offsetPos));
        v7 = FxManager_c::CreateFxSystem(&g_fxMan, "molotov_flame", &offsetPos, &MatrixArray[v5], 0);
        *v3 = v7;
        if ( v7 )
        {
          FxSystem_c::SetLocalParticles(v7, 1u);
          FxSystem_c::CopyParentMatrix(*v3);
          FxSystem_c::Play(*v3);
        }
      }
    }
  }
  if ( (*((_BYTE *)&this->m_nPedFlags + 9) & 0x10) == 0
    || CGame::currArea == AREA_MAIN_MAP && (FindPlayerCoors((CVector *)&offsetPos, -1), offsetPos.z <= 950.0) )
  {
    p_m_nPedFlags = &this->m_nPedFlags;
    if ( !((CTimer::m_FrameCounter + this->RandomSeed) << 27) )
      CEntity::PruneReferences(this);
    ClumpAlpha = CVisibilityPlugins::GetClumpAlpha((RpClump_0 *)this->m_pRwObject);
    if ( (*((_BYTE *)&this->m_nPedFlags + 4) & 8) != 0 )
    {
      ClumpAlpha -= 8;
      if ( ClumpAlpha <= 0 )
        ClumpAlpha = 0;
    }
    else if ( ClumpAlpha <= 254 )
    {
      ClumpAlpha += 16;
      if ( ClumpAlpha >= 255 )
        ClumpAlpha = 255;
    }
    CVisibilityPlugins::SetClumpAlpha((RpClump_0 *)this->m_pRwObject, ClumpAlpha);
    v12 = *((_DWORD *)&this->m_nPedFlags + 1);
    v11 = *(_DWORD *)p_m_nPedFlags;
    v13 = v12 >= 0;
    v15 = *((_DWORD *)&this->m_nPedFlags + 3);
    v14 = *((_DWORD *)&this->m_nPedFlags + 2);
    if ( v12 < 0 )
      v13 = (v12 & 0x80000 | *(_DWORD *)p_m_nPedFlags & 1) == 0;
    if ( !v13 )
    {
      m_pGroundPhysical = this->m_pGroundPhysical;
      v17 = m_pGroundPhysical == 0;
      if ( !m_pGroundPhysical )
        v17 = (v12 & 0x200000) == 0;
      if ( v17
        && this->m_fHitHeadHeight == 100000.0
        && (float)((float)((float)(this->m_vecMoveSpeed.x * this->m_vecMoveSpeed.x)
                         + (float)(this->m_vecMoveSpeed.y * this->m_vecMoveSpeed.y))
                 + (float)(this->m_vecMoveSpeed.z * this->m_vecMoveSpeed.z)) < 0.01 )
      {
        m_pMyVehicle = this->m_pMyVehicle;
        if ( m_pMyVehicle )
        {
          v19 = CCollision::ProcessColModels(
                  this->m_pMat,
                  CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel,
                  m_pMyVehicle->m_pMat,
                  CModelInfo::ms_modelInfoPtrs[m_pMyVehicle->m_nModelIndex]->m_pColModel,
                  aTempPedColPts,
                  0,
                  0,
                  0);
          v12 = *((_DWORD *)&this->m_nPedFlags + 1);
          v11 = *(_DWORD *)p_m_nPedFlags;
          v15 = *((_DWORD *)&this->m_nPedFlags + 3);
          v14 = *((_DWORD *)&this->m_nPedFlags + 2);
          if ( !v19 )
          {
            v12 &= ~0x80000000;
            *(_DWORD *)p_m_nPedFlags = v11;
            *((_DWORD *)&this->m_nPedFlags + 1) = v12;
            *((_DWORD *)&this->m_nPedFlags + 2) = v14;
            *((_DWORD *)&this->m_nPedFlags + 3) = v15;
            this->m_pNOCollisionVehicle = 0;
          }
        }
        else
        {
          v12 &= ~0x80000000;
          *(_DWORD *)p_m_nPedFlags = v11;
          *((_DWORD *)&this->m_nPedFlags + 1) = v12;
          *((_DWORD *)&this->m_nPedFlags + 2) = v14;
          *((_DWORD *)&this->m_nPedFlags + 3) = v15;
        }
      }
    }
    p_m_fHitHeadHeight = &this->m_fHitHeadHeight;
    if ( !(~v12 & 0x200000 | ~v15 & 0x100) )
    {
      m_pMat = this->m_pMat;
      p_tx = (CSimpleTransform *)&m_pMat->tx;
      if ( !m_pMat )
        p_tx = &this->m_transform;
      if ( *p_m_fHitHeadHeight > (float)(p_tx->m_translate.z + 1.5) )
      {
        v12 &= ~0x200000u;
        *(_DWORD *)p_m_nPedFlags = v11;
        *((_DWORD *)&this->m_nPedFlags + 1) = v12;
        *((_DWORD *)&this->m_nPedFlags + 2) = v14;
        *((_DWORD *)&this->m_nPedFlags + 3) = v15;
      }
    }
    v23 = v14 & 0x7FFFFFFE;
    *(_DWORD *)&this->m_nPhysicalFlags &= ~0x100u;
    *(_DWORD *)p_m_nPedFlags = v11 & 0xFFFEFFFD;
    *((_DWORD *)&this->m_nPedFlags + 1) = v12 & 0xFFF7FFFF;
    *((_DWORD *)&this->m_nPedFlags + 2) = v23;
    *((_DWORD *)&this->m_nPedFlags + 3) = v15 & 0xFFEFBEFF;
    *p_m_fHitHeadHeight = 100000.0;
    m_nGunFlashBlendAmount = this->m_nGunFlashBlendAmount;
    if ( m_nGunFlashBlendAmount >= 1 )
    {
      v25 = this->m_nGunFlashBlendOutRate * (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0);
      if ( v25 >= m_nGunFlashBlendAmount )
        v26 = 0;
      else
        v26 = m_nGunFlashBlendAmount - v25;
      this->m_nGunFlashBlendAmount = v26;
    }
    m_nGunFlashBlendAmount2 = this->m_nGunFlashBlendAmount2;
    if ( m_nGunFlashBlendAmount2 >= 1 )
    {
      v28 = (unsigned int)(float)((float)(CTimer::ms_fTimeStep / 50.0) * 1000.0) * this->m_nGunFlashBlendOutRate2;
      if ( v28 >= m_nGunFlashBlendAmount2 )
        v29 = 0;
      else
        v29 = m_nGunFlashBlendAmount2 - v28;
      this->m_nGunFlashBlendAmount2 = v29;
    }
    if ( !(v11 << 31) )
    {
      *(_DWORD *)p_m_nPedFlags = v11 & 0xFFFEFFFD;
      *((_DWORD *)&this->m_nPedFlags + 1) = v12 & 0xFFD7FFFF;
      *((_DWORD *)&this->m_nPedFlags + 2) = v23;
      *((_DWORD *)&this->m_nPedFlags + 3) = v15 & 0xFFEFBEFF;
    }
    if ( this->CharCreatedBy == 2 && FindPlayerPed(-1) != this )
    {
      PlayerPed = FindPlayerPed(-1);
      if ( CPedGroupMembership::IsMember(
             &CPedGroups::ms_groups[PlayerPed->m_pPlayerData->m_PlayerGroup].m_membership,
             this) )
      {
        *((_DWORD *)&this->m_nPedFlags + 3) &= ~0x100u;
      }
    }
    CPed::ProcessBuoyancy(this);
    m_pPlayerData = this->m_pPlayerData;
    if ( m_pPlayerData )
    {
      if ( *((unsigned __int8 *)&this->m_nPhysicalFlags + 1) << 31 && m_pPlayerData->m_waterCoverPerc >= 0x33u )
      {
        m_wetness = m_pPlayerData->m_wetness;
        if ( m_wetness <= 99 )
        {
          v33 = m_wetness + 1;
LABEL_67:
          m_pPlayerData->m_wetness = v33;
        }
      }
      else
      {
        v34 = m_pPlayerData->m_wetness;
        if ( v34 >= 1 )
        {
          v33 = v34 - 1;
          goto LABEL_67;
        }
      }
    }
    if ( !CWorld::bForceProcessControl )
    {
      v36 = (CPhysical *)(*(_DWORD *)p_m_nPedFlags & 1);
      v35 = v36 == 0;
      if ( v36 )
      {
        v36 = this->m_pGroundPhysical;
        v35 = v36 == 0;
      }
      if ( !v35 )
      {
        if ( (*(_BYTE *)&v36->m_nFlags & 0x20) != 0 )
          goto LABEL_80;
        v37 = *(_BYTE *)&v36->m_info & 7;
        v38 = v37 == 2;
        if ( v37 == 2 )
          v38 = v36[4].m_listEntryInfo.m_pHead == (CEntryInfoNode *)&byte_6;
        if ( v38 )
        {
LABEL_80:
          *(_DWORD *)&this->m_nFlags |= 0x40u;
          return;
        }
      }
    }
    CPedIntelligence::ProcessFirst(this->m_pPedIntelligence);
    v39 = *(_DWORD *)p_m_nPedFlags;
    v40 = *(_DWORD *)p_m_nPedFlags & 1;
    if ( !v40 )
    {
      z = this->m_vecMoveSpeed.z;
      if ( z > 0.25 )
      {
        if ( this->m_pPlayerData )
        {
          this->m_vecMoveSpeed.z = 0.25;
        }
        else
        {
          v42 = powf(0.95, CTimer::ms_fTimeStep);
          v43 = v42 * this->m_vecMoveSpeed.y;
          this->m_vecMoveSpeed.x = v42 * this->m_vecMoveSpeed.x;
          this->m_vecMoveSpeed.y = v43;
          this->m_vecMoveSpeed.z = v42 * z;
        }
      }
    }
    if ( this->m_nPedType < 2u
      || !v40
      || this->m_vecMoveSpeed.x != 0.0
      || this->m_vecMoveSpeed.y != 0.0
      || this->m_eMoveState > (unsigned int)PEDMOVE_STILL
      || this->m_extractedVelocity.x != 0.0
      || this->m_extractedVelocity.y != 0.0
      || this->m_nPedState == PED_JUMP )
    {
      goto LABEL_93;
    }
    v44 = (v39 & 0x200) == 0;
    if ( (v39 & 0x200) == 0 )
      v44 = this->m_pGroundPhysical == 0;
    if ( v44 )
    {
      p_m_nPedState = &this->m_nPedState;
      CPhysical::SkipPhysics(this);
    }
    else
    {
LABEL_93:
      CPhysical::ProcessControl(this);
      p_m_nPedState = &this->m_nPedState;
    }
    CPed::RequestDelayedWeapon(this);
    CPed::PlayFootSteps(this);
    *((_DWORD *)&this->m_nPedFlags + 2) &= 0xFFEF7FFF;
    CPedIntelligence::Process(this->m_pPedIntelligence);
    if ( this->m_nPedState != PED_DEAD )
      CPed::CalculateNewVelocity(this);
    CPed::UpdatePosition(this);
    (*((void (__fastcall **)(CPed *))this->_vptr$CPlaceable + 24))(this);
    v46 = *(_DWORD *)p_m_nPedFlags;
    *((_DWORD *)&this->m_nPedFlags + 2) &= 0xFFF0FFFF;
    v47 = (v46 & 0x40000) == 0;
    if ( (v46 & 0x40000) == 0 )
      v47 = this->BleedingFrames == 0;
    if ( !v47 && CLocalisation::Blood() && !(*((unsigned __int8 *)&this->m_nPedFlags + 1) << 31) )
    {
      if ( this->BleedingFrames )
        --this->BleedingFrames;
      if ( !((unsigned __int8)CTimer::m_FrameCounter << 30) )
      {
        v48 = this->m_pMat;
        p_m_transform = (CSimpleTransform *)&v48->tx;
        if ( !v48 )
          p_m_transform = &this->m_transform;
        v50 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
        if ( !TheCamera.m_pMat )
          v50 = &TheCamera.m_transform;
        v51.n64_u64[0] = vsub_f32(*(float32x2_t *)&p_m_transform->m_translate.y, *(float32x2_t *)&v50->m_translate.y).n64_u64[0];
        v52 = vmul_f32(v51, v51).n64_u64[0];
        if ( (float)((float)((float)((float)(p_m_transform->m_translate.x - v50->m_translate.x)
                                   * (float)(p_m_transform->m_translate.x - v50->m_translate.x))
                           + *(float *)&v52)
                   + *((float *)&v52 + 1)) < 2500.0 )
        {
          v53 = rand();
          tx = this->m_pMat->tx;
          offsetPos.x = tx + (float)((float)((rand() & 0x7F) - 64) * 0.007);
          ty = this->m_pMat->ty;
          offsetPos.y = ty + (float)((float)((rand() & 0x7F) - 64) * 0.007);
          v56 = gpBloodPoolTex;
          offsetPos.z = this->m_pMat->tz + 1.0;
          v57 = rand();
          CShadows::AddPermanentShadow(
            1u,
            v56,
            (CVector *)&offsetPos,
            (float)((float)(v53 & 0x7F) * 0.0015) + 0.15,
            0.0,
            0.0,
            -(float)((float)((float)(v53 & 0x7F) * 0.0015) + 0.15),
            255,
            0xC8u,
            0,
            0,
            4.0,
            (v57 & 0xFFF) + 2000,
            1.0);
        }
      }
    }
    if ( (*(_DWORD *)p_m_nPedFlags & 0x100) != 0 )
    {
      if ( !this->m_pMyVehicle )
      {
        v62 = *((_DWORD *)&this->m_nPedFlags + 1);
        v63 = *((_DWORD *)&this->m_nPedFlags + 2);
        v64 = *((_DWORD *)&this->m_nPedFlags + 3);
        *(_DWORD *)p_m_nPedFlags &= ~0x100u;
        *((_DWORD *)&this->m_nPedFlags + 1) = v62;
        *((_DWORD *)&this->m_nPedFlags + 2) = v63;
        *((_DWORD *)&this->m_nPedFlags + 3) = v64;
LABEL_115:
        if ( !((CTimer::m_FrameCounter + this->RandomSeed) << 18) && (*((_BYTE *)&this->m_nPedFlags + 13) & 4) != 0 )
          CPed::Say(this, 0x51u, 0, 1.0, 0, 0, 0);
        if ( this->m_WeaponSlots[this->m_nCurrentWeapon].m_eWeaponType == WEAPONTYPE_CHAINSAW
          && *p_m_nPedState != PED_ATTACK
          && !(*((unsigned __int8 *)&this->m_nPedFlags + 1) << 31)
          && !CPedIntelligence::GetTaskSwim(this->m_pPedIntelligence) )
        {
          CAEPedWeaponAudioEntity::AddAudioEvent(&this->m_PedWeaponAudioEntity, 153);
        }
        CAEPedWeaponAudioEntity::Service(&this->m_PedWeaponAudioEntity);
        if ( FindPlayerPed(-1) == this && *p_m_nPedState != PED_ATTACK )
        {
          v60 = this->m_WeaponSlots[this->m_nCurrentWeapon].m_eWeaponType - 9;
          if ( v60 <= 0x1D && ((1 << v60) & 0x30000001) != 0 )
          {
            TouchSense::instance();
            TouchSense::stopContinuousEffect(v61);
          }
        }
        return;
      }
      v58 = this;
      v59 = 1;
    }
    else
    {
      v58 = this;
      v59 = 0;
    }
    CPopulation::UpdatePedCount(v58, v59);
    goto LABEL_115;
  }
}
// 4A2CCC: variable 'v61' is possibly undefined
// 6: using guessed type char byte_6;

//----- (004A2D48) --------------------------------------------------------
void __fastcall CPed::RequestDelayedWeapon(CPed *this)
{
  eWeaponType m_eDelayedWeapon; // r0
  int32 m_modelId; // r6
  int32 m_modelId2; // r5

  m_eDelayedWeapon = this->m_eDelayedWeapon;
  if ( m_eDelayedWeapon != WEAPONTYPE_UNIDENTIFIED )
  {
    m_modelId = CWeaponInfo::GetWeaponInfo(m_eDelayedWeapon, 1)->m_modelId;
    m_modelId2 = CWeaponInfo::GetWeaponInfo(this->m_eDelayedWeapon, 1)->m_modelId2;
    if ( m_modelId != -1 )
      CStreaming::RequestModel(m_modelId, 8);
    if ( m_modelId2 != -1 )
      CStreaming::RequestModel(m_modelId2, 8);
    if ( (m_modelId == -1 || CStreaming::ms_aInfoForModel[m_modelId].m_status == 1)
      && (m_modelId2 == -1 || CStreaming::ms_aInfoForModel[m_modelId2].m_status == 1) )
    {
      CPed::GiveWeapon(this, this->m_eDelayedWeapon, this->m_delayedAmmo, 0);
      this->m_eDelayedWeapon = WEAPONTYPE_UNIDENTIFIED;
    }
  }
}

//----- (004A2DE4) --------------------------------------------------------
void __fastcall CPed::PlayFootSteps(CPed *this)
{
  CAnimBlendAssociation *FirstAssociation; // r0
  bool8 v3; // r10
  int m_nPedFlags; // r2
  CPedFlags *p_m_nPedFlags; // r9
  CPedStats *m_pPedStats; // r11
  CPedStats *v7; // r1
  uint32 v8; // r4
  int v9; // r3
  int v10; // r6
  int v11; // r5
  float v12; // s20
  CPedStats *v13; // r4
  CAnimBlendAssociation *v14; // r6
  float v15; // s18
  uint16 m_bitsFlag; // r1
  float v17; // s16
  float m_fTotalTime; // s2
  float v19; // s4
  float v20; // s0
  float v21; // s2
  float v22; // s6
  float v23; // s0
  float v24; // s4
  CPlayerPedData *m_pPlayerData; // r0
  _BOOL4 IsWearingBalaclava; // r0
  eMoveState m_eMoveState; // r1
  float m_moveBlendRatio; // s0
  float v29; // s2
  eMoveState v30; // r0
  float v31; // s2
  float v32; // s0
  int *v33; // r5
  int32 AdhesionGroup; // r0
  float v35; // s2
  float m_fCurrentTime; // s0
  int v37; // r4
  float v38; // r0
  float v39; // s2
  bool v40; // zf
  float v41; // s6
  float v42; // s4
  tAudioEvent v43; // r1
  float v44; // s0
  float v45; // s2
  int m_animId; // r4
  float v47; // r0
  float v48; // s0
  float v49; // s2
  float v50; // s16
  int v51; // s0
  CPed *v52; // r0
  bool v53; // r1
  int v54; // r0
  CEntity **v55; // r4
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r2
  double v58; // d16
  CEventGlobalGroup *EventGlobalGroup; // r0
  eMoveState v60; // r0
  float v61; // s2
  float v62; // s0
  CTaskSimpleLand *SimplestActiveTask; // r5
  CPed *v64; // r0
  bool v65; // r1
  CEventEditableResponse v66; // [sp+10h] [bp-60h] BYREF
  CEntity *v67; // [sp+20h] [bp-50h]
  float v68; // [sp+24h] [bp-4Ch]
  uint32 v69; // [sp+28h] [bp-48h]
  double v70; // [sp+2Ch] [bp-44h]
  RwReal z; // [sp+34h] [bp-3Ch]

  FirstAssociation = RpAnimBlendClumpGetFirstAssociation((RpClump_0 *)this->m_pRwObject);
  v3 = 0;
  m_nPedFlags = (int)this->m_nPedFlags;
  p_m_nPedFlags = &this->m_nPedFlags;
  if ( (unsigned __int16)FirstAssociation->m_animId < 3u )
    v3 = 1;
  m_pPedStats = this->m_pPedStats;
  v7 = CPedStats::ms_apPedStats;
  if ( (m_nPedFlags & 0x10000000) != 0 )
  {
    v8 = this->m_nTimeOfDeath - 1;
    if ( v8 <= 0x12A )
    {
      v9 = *((_DWORD *)&this->m_nPedFlags + 1);
      v10 = *((_DWORD *)&this->m_nPedFlags + 2);
      v11 = *((_DWORD *)&this->m_nPedFlags + 3);
      this->m_nTimeOfDeath = v8;
      if ( !v8 )
      {
        m_nPedFlags &= ~0x10000000u;
        *(_DWORD *)p_m_nPedFlags = m_nPedFlags;
        *((_DWORD *)&this->m_nPedFlags + 1) = v9;
        *((_DWORD *)&this->m_nPedFlags + 2) = v10;
        *((_DWORD *)&this->m_nPedFlags + 3) = v11;
      }
    }
  }
  if ( !(m_nPedFlags << 31) )
    return;
  if ( FirstAssociation )
  {
    v12 = 0.0;
    v13 = v7 + 40;
    v14 = 0;
    v15 = 0.0;
    do
    {
      m_bitsFlag = FirstAssociation->m_bitsFlag;
      if ( (m_bitsFlag & 0x100) != 0 )
      {
        v14 = FirstAssociation;
        v15 = v15 + FirstAssociation->m_fBlendAmount;
      }
      else if ( (FirstAssociation->m_bitsFlag & 0x400) == 0
             && FirstAssociation->m_animId != 223
             && ((m_bitsFlag & 0x10) != 0 || (*((_BYTE *)&this->m_nPedFlags + 3) & 4) == 0) )
      {
        v12 = v12 + FirstAssociation->m_fBlendAmount;
      }
      FirstAssociation = RpAnimBlendGetNextAssociation(FirstAssociation);
    }
    while ( FirstAssociation );
    v17 = 1.0;
    if ( v12 < 1.0 && v15 > 0.5 && v14 )
    {
      m_fTotalTime = v14->m_pAnimBlendHierarchy->m_fTotalTime;
      v19 = m_fTotalTime * 0.066667;
      v20 = m_fTotalTime * 0.5;
      v21 = (float)(m_fTotalTime * 0.066667) + 0.2;
      v22 = v20 + v19;
      v23 = (float)(v20 + v19) + 0.2;
      if ( (*(_DWORD *)p_m_nPedFlags & 0x4000000) == 0 )
      {
        v21 = v19;
        v23 = v22;
      }
      if ( m_pPedStats == v13 )
      {
        CRGBA::CRGBA((CRGBA *)&v66, 0xAAu, 0xA5u, 0x8Cu, 0xFFu);
        v33 = dword_4A3390;
        if ( !v14->m_animId )
          v33 = &dword_4A3390[1];
        AdhesionGroup = SurfaceInfos_c::GetAdhesionGroup(&g_surfaceInfos, this->m_LastMaterialToHaveBeenStandingOn);
        if ( AdhesionGroup == 5 )
        {
          v44 = this->m_extractedVelocity.y * 0.3;
          this->m_extractedVelocity.x = this->m_extractedVelocity.x * 0.3;
          this->m_extractedVelocity.y = v44;
          goto LABEL_92;
        }
        if ( AdhesionGroup == 4 )
        {
          if ( (rand() & 0x3F) != 0 )
          {
            v45 = this->m_extractedVelocity.y * 0.2;
            this->m_extractedVelocity.x = this->m_extractedVelocity.x * 0.2;
            this->m_extractedVelocity.y = v45;
          }
        }
        else
        {
          if ( AdhesionGroup == 3 )
          {
            v17 = 0.5;
            if ( (rand() & 0x7F) != 0 )
            {
              v17 = 0.5;
              v35 = this->m_extractedVelocity.y * 0.5;
              this->m_extractedVelocity.x = this->m_extractedVelocity.x * 0.5;
              this->m_extractedVelocity.y = v35;
            }
          }
          m_fCurrentTime = v14->m_fCurrentTime;
          if ( m_fCurrentTime > 0.0 && (float)(m_fCurrentTime - v14->m_fTimeStep) <= 0.0 )
          {
            if ( !this->m_PedAudioEntity.m_bInitialised )
              goto LABEL_92;
            m_animId = (unsigned __int16)v14->m_animId;
            v47 = log10f(v17);
            v39 = 20.0;
            v40 = m_animId == 0;
            v41 = v47;
            v42 = 0.75;
            v43 = 56;
          }
          else
          {
            if ( m_fCurrentTime <= *(float *)v33
              || (float)(m_fCurrentTime - v14->m_fTimeStep) > *(float *)v33
              || !this->m_PedAudioEntity.m_bInitialised )
            {
              goto LABEL_92;
            }
            v37 = (unsigned __int16)v14->m_animId;
            v38 = log10f(v17);
            v39 = 20.0;
            v40 = v37 == 0;
            v41 = v38;
            v42 = 0.75;
            v43 = 57;
          }
          v48 = 1.0;
          v49 = v41 * v39;
          if ( v40 )
            v48 = v42;
          CAEPedAudioEntity::AddAudioEvent(&this->m_PedAudioEntity, v43, v49, v48, 0, 0, 0, 0);
        }
      }
      else
      {
        v24 = v14->m_fCurrentTime;
        if ( v24 >= v21 && (float)(v24 - v14->m_fTimeStep) < v21 )
        {
          if ( this->m_nPedType > 1u )
            goto LABEL_79;
          m_pPlayerData = this->m_pPlayerData;
          if ( !m_pPlayerData )
            goto LABEL_79;
          IsWearingBalaclava = CPedClothesDesc::GetIsWearingBalaclava(m_pPlayerData->m_pClothes);
          m_eMoveState = this->m_eMoveState;
          if ( (unsigned int)(m_eMoveState - 5) >= 2 )
          {
            if ( m_eMoveState != PEDMOVE_SPRINT )
              goto LABEL_79;
            v50 = 55.0;
            *(float *)&v51 = 65.0;
          }
          else
          {
            m_moveBlendRatio = this->m_pPlayerData->m_moveBlendRatio;
            if ( m_moveBlendRatio < 2.0 )
            {
              if ( IsWearingBalaclava && m_moveBlendRatio > 1.1 )
              {
                v29 = 20.0;
                goto LABEL_102;
              }
              if ( m_moveBlendRatio > 1.5 )
              {
                v29 = 15.0;
LABEL_102:
                v50 = (float)((float)(m_moveBlendRatio + -1.0) * v29) + 30.0;
                if ( v50 <= 0.0 )
                  goto LABEL_79;
LABEL_72:
                CEventEditableResponse::CEventEditableResponse(&v66);
                v55 = (CEntity **)(v54 + 16);
                v67 = this;
                v68 = v50;
                v69 = -1;
                v70 = 0.0;
                z = 0.0;
                v66._vptr$CEvent = (int (**)(void))&off_66714C;
                CEntity::RegisterReference(this, (CEntity **)(v54 + 16));
                if ( v69 == -1 )
                {
                  v69 = CTimer::m_snTimeInMilliseconds;
                  m_pMat = v67->m_pMat;
                  p_tx = (CSimpleTransform *)&m_pMat->tx;
                  if ( !m_pMat )
                    p_tx = &v67->m_transform;
                  v58 = *(double *)&p_tx->m_translate.x;
                  z = p_tx->m_translate.z;
                  v70 = v58;
                }
                EventGlobalGroup = GetEventGlobalGroup();
                CEventGroup::Add(EventGlobalGroup, (CEvent *)&v66, 0);
                v66._vptr$CEvent = (int (**)(void))&off_66714C;
                if ( v67 )
                  CEntity::CleanUpOldReference(v67, v55);
                CEvent::~CEvent((CEvent *)&v66);
              }
LABEL_79:
              if ( (*((_BYTE *)&this->m_nPedFlags + 3) & 4) != 0 )
              {
                v62 = -18.0;
                v61 = 0.8;
              }
              else
              {
                v60 = this->m_eMoveState;
                if ( v60 == PEDMOVE_RUN )
                {
                  v62 = -6.0;
                  v61 = 1.1;
                }
                else if ( v60 == PEDMOVE_SPRINT )
                {
                  v61 = 1.2;
                  v62 = 0.0;
                }
                else
                {
                  v62 = -12.0;
                  v61 = 0.9;
                }
                if ( this->m_motionAnimGroup == ANIM_PLAYER_SNEAK_PED )
                {
                  v61 = v61 + -0.1;
                  v62 = v62 + -6.0;
                }
              }
              if ( this->m_PedAudioEntity.m_bInitialised )
                CAEPedAudioEntity::AddAudioEvent(&this->m_PedAudioEntity, 54, v62, v61, 0, 0, 0, 0);
              v52 = this;
              v53 = 1;
LABEL_91:
              CPed::DoFootLanded(v52, v53, v3);
              goto LABEL_92;
            }
            v50 = 45.0;
            *(float *)&v51 = 55.0;
          }
          if ( IsWearingBalaclava )
            v50 = *(float *)&v51;
          goto LABEL_72;
        }
        if ( v24 >= v23 && (float)(v24 - v14->m_fTimeStep) < v23 )
        {
          if ( (*(_DWORD *)p_m_nPedFlags & 0x4000000) != 0 )
          {
            v32 = -18.0;
            v31 = 0.8;
          }
          else
          {
            v30 = this->m_eMoveState;
            if ( v30 == PEDMOVE_RUN )
            {
              v32 = -6.0;
              v31 = 1.1;
            }
            else if ( v30 == PEDMOVE_SPRINT )
            {
              v31 = 1.2;
              v32 = 0.0;
            }
            else
            {
              v32 = -12.0;
              v31 = 0.9;
            }
            if ( this->m_motionAnimGroup == ANIM_PLAYER_SNEAK_PED )
            {
              v31 = v31 + -0.1;
              v32 = v32 + -6.0;
            }
          }
          if ( this->m_PedAudioEntity.m_bInitialised )
            CAEPedAudioEntity::AddAudioEvent(&this->m_PedAudioEntity, 55, v32, v31, 0, 0, 0, 0);
          v52 = this;
          v53 = 0;
          goto LABEL_91;
        }
      }
    }
  }
LABEL_92:
  if ( (*((_BYTE *)&this->m_nPedFlags + 1) & 4) != 0 )
  {
    SimplestActiveTask = (CTaskSimpleLand *)CTaskManager::GetSimplestActiveTask(&this->m_pPedIntelligence->m_taskManager);
    if ( (*((int (__fastcall **)(CTaskSimpleLand *))SimplestActiveTask->_vptr$CTask + 5))(SimplestActiveTask) == 242 )
    {
      if ( CTaskSimpleLand::RightFootLanded(SimplestActiveTask) )
      {
        v64 = this;
        v65 = 0;
      }
      else
      {
        if ( !CTaskSimpleLand::LeftFootLanded(SimplestActiveTask) )
          return;
        v64 = this;
        v65 = 1;
      }
      CPed::DoFootLanded(v64, v65, 1u);
    }
  }
}
// 4A31DC: variable 'v54' is possibly undefined
// 4A3390: using guessed type int dword_4A3390[2];
// 66714C: using guessed type void *off_66714C;

//----- (004A339C) --------------------------------------------------------
int32 __fastcall CPed::ProcessEntityCollision(CPed *this, CEntity *pEntity, CColPoint *aColPoints)
{
  float32x2_t v3; // d0
  float32x2_t v4; // d1
  float32x2_t v5; // d2
  float32x2_t v6; // d10
  float m_heading; // s16
  CColModel *m_pColModel; // r10
  float v11; // s18
  CCollisionData *m_pColData; // r5
  CMatrix *m_pMat; // r6
  __int64 v14; // kr00_8
  float v15; // r0
  uint32 bdummy; // r0
  int v17; // r1
  bool v18; // zf
  int v19; // lr
  int v20; // r2
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r3
  bool v22; // zf
  float v23; // s0
  int v24; // r9
  float v25; // s22
  int v26; // r3
  int v27; // r0
  float *p_x; // r1
  float v29; // s0
  float v30; // s0
  CColLine *m_pLineArray; // r0
  CColLine *v32; // r0
  float z; // s0
  int v34; // r8
  CMatrix *v35; // r4
  const CMatrix *v36; // r5
  CColModel *ColModel; // r0
  float v38; // s18
  float tz; // s20
  CPedFlags *v40; // r6
  CEntity::CFlags *v41; // r8
  int v42; // r0
  CEntity *v43; // r9
  int v44; // r0
  int v45; // r10
  float v46; // s2
  int v47; // r1
  __int64 v48; // r4
  int v49; // r4
  int v50; // r2
  RwReal *p_z; // r1
  float v52; // s2
  int v53; // r3
  float v54; // s0
  int v55; // r1
  int v56; // r2
  int v57; // r4
  float v58; // s0
  int v59; // r0
  bool v60; // zf
  CMatrix *v61; // r0
  float v62; // s0
  float *v63; // r1
  RwReal v64; // s4
  float v65; // s6
  RwReal v66; // s2
  int v67; // r0
  bool v68; // zf
  __int64 v69; // kr18_8
  int v70; // r1
  int v71; // r3
  unsigned int v72; // r0
  int v73; // r1
  float *p_m_fHitHeadHeight; // r1
  int v75; // r0
  float v76; // s0
  int v77; // r0
  __int64 v78; // r2
  uint32 m_nSurfaceType; // r1
  __int64 v80; // d16
  int *v81; // r4
  ePedState m_nPedState; // r5
  float v83; // s28
  CAnimBlendAssociation *Association; // r0
  float x; // s22
  float v86; // s0
  float y; // s24
  float v88; // s26
  int v89; // r5
  int v90; // r2
  float v91; // s17
  CEntity *m_pNOCollisionVehicle; // r2
  bool v93; // zf
  float v94; // s28
  uint8 v95; // r0
  const CEventDamage *v96; // r0
  CPedDamageResponseCalculator *v97; // r0
  float i; // s0
  int v99; // s0
  char v100; // r1
  const CEventDamage *v101; // r0
  CMatrix *v102; // r4
  const CMatrix *v103; // r5
  CColModel *v104; // r0
  CMatrix *v105; // r6
  CSimpleTransform *p_tx; // r5
  int v107; // r10
  CColPoint *v108; // r0
  int v109; // r4
  int v110; // r12
  _BOOL4 v111; // r6
  int v112; // r5
  int v113; // r4
  const CColPoint *v114; // r4
  int v115; // r5
  int v116; // r6
  int v117; // r0
  bool v118; // zf
  unsigned int m_nPieceType; // r4
  __int64 v120; // kr38_8
  int v121; // lr
  int v122; // r0
  bool v123; // zf
  int v124; // r8
  CMatrix *v125; // r0
  int v126; // r5
  ColData *p_m_dataB; // r6
  __int64 v128; // d16
  float v129; // s0
  float v130; // s2
  float v131; // s4
  __int64 v132; // d16
  int IsSteepSlope; // r0
  CPedFlags *v134; // r1
  bool v135; // zf
  CColPoint *v136; // r5
  CPed *v137; // r6
  CMatrix *v138; // r0
  CSimpleTransform *p_m_transform; // r1
  RwReal v140; // s0
  RwReal v141; // s4
  int v142; // r5
  RwReal v144; // [sp+10h] [bp-138h]
  RwReal v145; // [sp+14h] [bp-134h]
  CColModel *colModelA; // [sp+18h] [bp-130h]
  _DWORD *p_m_heading; // [sp+1Ch] [bp-12Ch]
  CPhysical *v148; // [sp+20h] [bp-128h]
  CEntity *v149; // [sp+24h] [bp-124h]
  CEntity::CFlags *p_m_nFlags; // [sp+28h] [bp-120h]
  CPedFlags *p_m_nPedFlags; // [sp+30h] [bp-118h]
  CPedDamageResponseCalculator v153; // [sp+34h] [bp-114h] BYREF
  CEventDamage v154; // [sp+48h] [bp-100h] BYREF
  CColPoint v155; // [sp+88h] [bp-C0h] BYREF
  float v156; // [sp+BCh] [bp-8Ch]
  float aLineRatios; // [sp+E0h] [bp-68h] BYREF
  float v158; // [sp+E4h] [bp-64h]

  aLineRatios = 1.0;
  v158 = 1.0;
  m_heading = -1001.0;
  m_pColModel = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex]->m_pColModel;
  v11 = CTimer::ms_fTimeStep;
  m_pColData = m_pColModel->m_pColData;
  p_m_nFlags = &this->m_nFlags;
  if ( (*((_BYTE *)&this->m_nPedFlags + 9) & 0x80) != 0 && *(_BYTE *)&this->m_nFlags << 31 )
  {
    m_heading = -1001.0;
    if ( this->m_nPedType <= 1u
      && TheCamera.Cams[TheCamera.ActiveCam].Mode == 53
      && CPedIntelligence::GetTaskUseGun(this->m_pPedIntelligence)
      && CPedIntelligence::GetTaskUseGun(this->m_pPedIntelligence)->m_pWeaponInfo
      && (CPedIntelligence::GetTaskUseGun(this->m_pPedIntelligence)->m_pWeaponInfo->m_nFlags & 2) != 0 )
    {
      m_pMat = this->m_pMat;
      if ( m_pMat )
        m_heading = atan2f(COERCE_FLOAT(LODWORD(m_pMat->xy) ^ 0x80000000), m_pMat->yy);
      else
        m_heading = this->m_transform.m_heading;
      v14 = *(_QWORD *)&TheCamera.Cams[TheCamera.ActiveCam].Front.x;
      v15 = atan2f(COERCE_FLOAT(v14 ^ 0x80000000), *((float *)&v14 + 1));
      if ( m_pMat )
        CMatrix::SetRotateZOnly(m_pMat, v15);
      else
        this->m_transform.m_heading = v15;
    }
    m_pColModel = &CTempColModels::ms_colModelPed2;
    m_pColData = CTempColModels::ms_colModelPed2.m_pColData;
  }
  bdummy = p_m_nFlags->bdummy;
  v17 = *(_DWORD *)p_m_nFlags;
  v18 = (*(_DWORD *)p_m_nFlags & 1) == 0;
  if ( (*(_DWORD *)p_m_nFlags & 1) == 0 )
    v18 = *((unsigned __int8 *)&this->m_nPhysicalFlags + 2) << 31 == 0;
  if ( v18 )
    return 0;
  p_m_nPedFlags = &this->m_nPedFlags;
  v19 = 0;
  v20 = *(_BYTE *)&pEntity->m_info & 7;
  if ( v20 == 2 && pEntity[24]._vptr$CPlaceable == (int (**)(void))&byte_5 )
    v19 = 1;
  m_nPhysicalFlags = this->m_nPhysicalFlags;
  v22 = (*(_DWORD *)&m_nPhysicalFlags & 0x19000) == 0;
  if ( (*(_DWORD *)&m_nPhysicalFlags & 0x19000) == 0 )
    v22 = this->m_pAttachToEntity == 0;
  if ( !v22 || v20 == 3 )
  {
    v23 = -1.0;
    v24 = 0;
    v25 = 0.94;
    m_pColData->_anon_0.m_nNoOfLines = 0;
    m_pColModel->m_boxBound.m_vecMax.z = 0.95;
    m_pColModel->m_sphereBound.m_fRadius = 1.0;
  }
  else
  {
    if ( (v17 & 2) == 0 )
    {
      *(_DWORD *)p_m_nFlags = v17 | 2;
      p_m_nFlags->bdummy = bdummy;
    }
    m_pColData->_anon_1.m_pLineArray->m_vecStart.z = 0.0;
    m_pColData->_anon_1.m_pLineArray->m_vecEnd.z = -1.0;
    if ( (*(_DWORD *)p_m_nPedFlags & 2) != 0 )
      m_pColData->_anon_1.m_pLineArray->m_vecEnd.z = m_pColData->_anon_1.m_pLineArray->m_vecEnd.z - (float)(v11 * 0.15);
    v27 = *((_DWORD *)&this->m_nPedFlags + 3);
    p_x = &m_pColData->m_pSphereArray->m_vecCentre.x;
    v25 = p_x[12] + p_x[13];
    if ( (v27 & 0x100) != 0 )
    {
      v29 = p_x[2] - p_x[3];
      m_pColData->_anon_1.m_pLineArray[1].m_vecStart.z = v25;
      v30 = v29 + 1.0;
      m_pColData->_anon_1.m_pLineArray[1].m_vecStart.z = m_pColData->_anon_1.m_pLineArray[1].m_vecStart.z - v30;
      m_pColData->_anon_1.m_pLineArray[1].m_vecEnd.z = v25;
      m_pColData->_anon_1.m_pLineArray[1].m_vecEnd.z = v30 + m_pColData->_anon_1.m_pLineArray[1].m_vecEnd.z;
      v27 = *((_DWORD *)&this->m_nPedFlags + 3);
    }
    if ( (v27 & 0x100) != 0 )
    {
      m_pLineArray = m_pColData->_anon_1.m_pLineArray;
      m_pColData->_anon_0.m_nNoOfLines = 2;
      v24 = 1;
      m_pColModel->m_sphereBound.m_fRadius = m_pLineArray[1].m_vecEnd.z;
      m_pColModel->m_boxBound.m_vecMax.z = m_pColData->_anon_1.m_pLineArray[1].m_vecEnd.z;
    }
    else
    {
      v32 = m_pColData->_anon_1.m_pLineArray;
      v24 = 1;
      m_pColData->_anon_0.m_nNoOfLines = 1;
      z = v32->m_vecEnd.z;
      m_pColModel->m_boxBound.m_vecMax.z = 0.95;
      m_pColModel->m_sphereBound.m_fRadius = fabsf(z);
    }
    v23 = m_pColData->_anon_1.m_pLineArray->m_vecEnd.z;
  }
  m_pColModel->m_boxBound.m_vecMin.z = v23;
  v149 = pEntity;
  v148 = (CPhysical *)m_pColData;
  v34 = (*(_BYTE *)p_m_nFlags & 0x10) != 0
     && ((*(_BYTE *)&pEntity->m_info & 7) == 1 || (LOBYTE(pEntity[1].m_transform.m_translate.y) & 4) != 0);
  v35 = this->m_pMat;
  v36 = v149->m_pMat;
  if ( !v36 )
  {
    CPlaceable::AllocateMatrix(v149);
    CSimpleTransform::UpdateMatrix(&v149->m_transform, v149->m_pMat);
    v36 = v149->m_pMat;
  }
  ColModel = CEntity::GetColModel(v149);
  v26 = CCollision::ProcessColModels(v35, m_pColModel, v36, ColModel, aColPoints, &v155, &aLineRatios, v34);
  if ( v24 == 1 )
  {
    v38 = 1.0;
    tz = this->m_pMat->tz;
    BYTE2(v148->m_transform.m_translate.x) = 0;
    m_pColModel->m_boxBound.m_vecMax.z = 0.95;
    m_pColModel->m_sphereBound.m_fRadius = 1.0;
    m_pColModel->m_boxBound.m_vecMin.z = -1.0;
    v40 = &this->m_nPedFlags;
    v41 = p_m_nFlags;
    v42 = *(_DWORD *)p_m_nPedFlags;
    if ( aLineRatios >= 1.0 )
    {
      v55 = *((_DWORD *)&this->m_nPedFlags + 2);
      v56 = *((_DWORD *)&this->m_nPedFlags + 1);
      v57 = *((_DWORD *)&this->m_nPedFlags + 3);
      if ( (v57 & 0x100) != 0 && v158 < 1.0 )
      {
        v58 = v156;
        if ( v156 < this->m_fHitHeadHeight )
        {
          if ( ((unsigned __int8)((*(_BYTE *)&v149->m_info & 7) - 2) > 2u
             || (LOBYTE(v149[1].m_transform.m_translate.y) & 8) != 0)
            && (this->m_fHitHeadHeight = v156, v42 << 31) )
          {
            v105 = this->m_pMat;
            p_tx = (CSimpleTransform *)&v105->tx;
            if ( !v105 )
              p_tx = &this->m_transform;
            v41 = p_m_nFlags;
            if ( v58 < (float)(v25 + p_tx->m_translate.z) )
            {
              v105->tz = v58 - v25;
              v56 = *((_DWORD *)&this->m_nPedFlags + 1);
              v42 = *(_DWORD *)p_m_nPedFlags;
              v57 = *((_DWORD *)&this->m_nPedFlags + 3);
              v55 = *((_DWORD *)&this->m_nPedFlags + 2);
            }
          }
          else
          {
            v41 = p_m_nFlags;
          }
        }
      }
      v40 = &this->m_nPedFlags;
      *(_DWORD *)p_m_nPedFlags = v42;
      *((_DWORD *)&this->m_nPedFlags + 1) = v56 & 0xFFFFFFFD;
      *((_DWORD *)&this->m_nPedFlags + 2) = v55;
      *((_DWORD *)&this->m_nPedFlags + 3) = v57;
      v43 = v149;
      v145 = 0.0;
      v144 = 0.0;
      goto LABEL_163;
    }
    v43 = v149;
    v44 = *(_DWORD *)p_m_nPedFlags & 1;
    colModelA = m_pColModel;
    v45 = v26;
    if ( v44 )
    {
      v38 = 1.0;
      v46 = this->m_pMat->tz;
      if ( v46 >= (float)(v155.m_vecPosition.z + 1.0) )
      {
        v47 = 0;
        v48 = 0LL;
        if ( v46 < (float)(v155.m_vecPosition.z + 3.0) )
          v47 = 1;
        if ( (v47 & v19) != 1 )
        {
LABEL_113:
          v144 = *((float *)&v48 + 1);
          v145 = *(float *)&v48;
          v81 = dword_4A42D4;
          m_nPedState = this->m_nPedState;
          v83 = -0.375;
          if ( m_nPedState == PED_IDLE )
            v81 = &dword_4A42D4[1];
          Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)this->m_pRwObject, 0x78u);
          x = this->m_vecMoveSpeed.x;
          v86 = -0.25;
          y = this->m_vecMoveSpeed.y;
          v88 = this->m_vecMoveSpeed.z;
          if ( m_nPedState == PED_IDLE )
            v86 = -0.375;
          if ( (unsigned __int8)((*(_BYTE *)&v149->m_info & 7) - 2) <= 2u )
          {
            x = x - v149[1].m_transform.m_translate.z;
            y = y - v149[1].m_transform.m_heading;
            v88 = v88 - *(float *)&v149[1].m_pMat;
          }
          v26 = v45;
          v41 = p_m_nFlags;
          if ( (*(_DWORD *)p_m_nPedFlags & 2) != 0 )
            goto LABEL_152;
          v89 = 0;
          v90 = 0;
          v91 = sqrtf((float)(x * x) + (float)(y * y));
          if ( v91 > *(float *)v81 )
            v89 = 1;
          v43 = v149;
          if ( (*((_DWORD *)&this->m_nPedFlags + 1) & 0x8000000) == 0 )
            v90 = 1;
          if ( v88 >= v86 && (v90 & v89) != 1 )
            goto LABEL_138;
          m_pNOCollisionVehicle = this->m_pNOCollisionVehicle;
          v93 = m_pNOCollisionVehicle == v149;
          if ( m_pNOCollisionVehicle != v149 )
            v93 = this->m_pMyVehicle == v149;
          if ( v93 )
          {
LABEL_138:
            v40 = &this->m_nPedFlags;
            if ( !Association || v88 >= (float)(CTimer::ms_fTimeStep * -0.016) || this->m_pMyVehicle == v149 )
            {
LABEL_152:
              this->m_vecMoveSpeed.z = 0.0;
              *(_DWORD *)v40 |= 1u;
              v102 = this->m_pMat;
              if ( v102->tz > (float)(tz + 0.1) && !BYTE2(v148->m_transform.m_translate.x) && this->m_nPedType <= 1u )
              {
                v103 = v43->m_pMat;
                if ( !v103 )
                {
                  CPlaceable::AllocateMatrix(v43);
                  CSimpleTransform::UpdateMatrix(&v43->m_transform, v43->m_pMat);
                  v103 = v43->m_pMat;
                }
                v104 = CEntity::GetColModel(v43);
                v26 = CCollision::ProcessColModels(v102, colModelA, v103, v104, aColPoints, 0, 0, 0);
                v41 = p_m_nFlags;
              }
              goto LABEL_163;
            }
            CEventDamage::CEventDamage(
              &v154,
              v149,
              CTimer::m_snTimeInMilliseconds,
              WEAPONTYPE_FALL,
              PED_SPHERE_CHEST,
              2u,
              0,
              0);
            if ( !CEventDamage::AffectsPed(v96, this) )
            {
LABEL_151:
              CEventDamage::~CEventDamage(&v154);
              v43 = v149;
              v41 = p_m_nFlags;
              v26 = v45;
              v40 = &this->m_nPedFlags;
              goto LABEL_152;
            }
            CPedDamageResponseCalculator::CPedDamageResponseCalculator(
              &v153,
              v149,
              15.0,
              WEAPONTYPE_FALL,
              PED_SPHERE_CHEST,
              0);
          }
          else
          {
            v3.n64_u32[0] = 0.375;
            if ( !SurfaceInfos_c::IsSoftLanding(&g_surfaceInfos, v155.m_dataB.m_nSurfaceType) )
            {
              v3.n64_u32[0] = 0.25;
              v83 = -0.25;
            }
            v4.n64_u32[0] = 0;
            v3.n64_f32[0] = v91 - v3.n64_f32[0];
            v5.n64_f32[0] = v83 - v88;
            v5.n64_u64[0] = vmax_f32(v5, v4).n64_u64[0];
            v94 = (float)(vmax_f32(v3, v4).n64_f32[0] * 100.0) + (float)(v5.n64_f32[0] * 400.0);
            if ( v88 < -0.6 )
              v94 = 500.0;
            if ( x > 0.01 || x < -0.01 || y > 0.01 || y < -0.01 )
            {
              for ( i = (float)(atan2f(x, COERCE_FLOAT(LODWORD(y) ^ 0x80000000)) - this->m_fCurrentHeading) + 0.7854;
                    i < 0.0;
                    i = i + 6.2832 )
              {
                ;
              }
              v99 = (int)(float)(i / 1.5708);
              v100 = ~(_BYTE)v99;
              if ( ~v99 < -4 || v99 == 3 )
                v100 = -4;
              v95 = v99 - ((v100 + v99 + 4) & 0xFC);
            }
            else
            {
              v95 = 2;
            }
            CEventDamage::CEventDamage(
              &v154,
              v149,
              CTimer::m_snTimeInMilliseconds,
              WEAPONTYPE_FALL,
              PED_SPHERE_CHEST,
              v95,
              0,
              0);
            if ( !CEventDamage::AffectsPed(v101, this) )
              goto LABEL_151;
            CPedDamageResponseCalculator::CPedDamageResponseCalculator(
              &v153,
              v149,
              v94,
              WEAPONTYPE_FALL,
              PED_SPHERE_CHEST,
              0);
          }
          CPedDamageResponseCalculator::ComputeDamageResponse(v97, this, &v154.m_pedDamageResponse, 1);
          CEventGroup::Add(&this->m_pPedIntelligence->m_eventGroup, (CEvent *)&v154, 0);
          CPedDamageResponseCalculator::~CPedDamageResponseCalculator(&v153);
          goto LABEL_151;
        }
      }
    }
    v49 = 0;
    if ( v26 >= 1 )
    {
      v50 = v26;
      p_z = &aColPoints->m_vecNormal.z;
      do
      {
        v52 = *p_z;
        v53 = 0;
        p_z += 11;
        if ( v52 < -0.867 )
          v53 = 1;
        --v50;
        v49 |= v53;
      }
      while ( v50 );
    }
    if ( this->m_nPedType >= 2u )
      v54 = (float)(CCustomBuildingDNPipeline::m_fDNBalanceParam
                  * (float)((float)((float)(v155.m_dataB.m_lighting >> 4) * 0.5) / 15.0))
          + (float)((float)(1.0 - CCustomBuildingDNPipeline::m_fDNBalanceParam)
                  * (float)((float)((float)(v155.m_dataB.m_lighting & 0xF) * 0.5) / 15.0));
    else
      v54 = (float)((float)(1.0 - (float)(CTimer::ms_fTimeStep * 0.1)) * this->m_lightingFromCollision)
          + (float)((float)(CTimer::ms_fTimeStep * 0.1)
                  * (float)((float)(CCustomBuildingDNPipeline::m_fDNBalanceParam
                                  * (float)((float)((float)(v155.m_dataB.m_lighting >> 4) * 0.5) / 15.0))
                          + (float)((float)(1.0 - CCustomBuildingDNPipeline::m_fDNBalanceParam)
                                  * (float)((float)((float)(v155.m_dataB.m_lighting & 0xF) * 0.5) / 15.0))));
    this->m_lightingFromCollision = v54;
    if ( v44 )
      goto LABEL_78;
    v59 = *(_BYTE *)&v149->m_info & 7;
    v60 = v59 == 4;
    if ( v59 != 4 )
      v60 = v59 == 2;
    if ( v60 )
    {
      this->m_pGroundPhysical = (CPhysical *)v149;
      CEntity::RegisterReference(v149, &this->m_pGroundPhysical);
      v61 = v149->m_pMat;
      v62 = v155.m_vecPosition.x;
      v63 = &v61->tx;
      if ( !v61 )
        v63 = &v149->m_transform.m_translate.x;
      v64 = v155.m_vecPosition.z - v63[2];
      v65 = *v63;
      v66 = v155.m_vecPosition.y - v63[1];
      this->m_pEntityStandingOn = v149;
      this->m_vecGroundOffset.z = v64;
      this->m_vecGroundOffset.y = v66;
      this->m_vecGroundOffset.x = v62 - v65;
      CEntity::RegisterReference(v149, &this->m_pEntityStandingOn);
      v67 = *(_BYTE *)&v149->m_info & 7;
      v68 = v67 == 2;
      if ( v67 == 2 )
        v68 = v149[24]._vptr$CPlaceable == (int (**)(void))&byte_5;
      v69 = *(_QWORD *)p_m_nPedFlags;
      v70 = *((_DWORD *)&this->m_nPedFlags + 3);
      v71 = *((_DWORD *)&this->m_nPedFlags + 2);
      if ( v68 )
        v72 = *((_DWORD *)&this->m_nPedFlags + 1) | 2;
      else
        v72 = *((_DWORD *)&this->m_nPedFlags + 1) & 0xFFFFFFFD;
      *(_DWORD *)p_m_nPedFlags = v69;
      *((_DWORD *)&this->m_nPedFlags + 1) = HIDWORD(v69);
      *((_DWORD *)&this->m_nPedFlags + 2) = v71;
      *((_DWORD *)&this->m_nPedFlags + 3) = v70;
      if ( (*(_BYTE *)&v149->m_info & 7) == 2 )
        this->m_lightingFromCollision = this->m_pGroundPhysical->m_lightingFromCollision;
      if ( (v70 & 0x100) == 0 )
        goto LABEL_92;
    }
    else
    {
LABEL_78:
      this->m_pEntityStandingOn = v149;
      CEntity::RegisterReference(v149, &this->m_pEntityStandingOn);
      v73 = *((_DWORD *)&this->m_nPedFlags + 3);
      v72 = *((_DWORD *)&this->m_nPedFlags + 1) & 0xFFFFFF7D;
      *((_DWORD *)&this->m_nPedFlags + 1) = v72;
      if ( (v73 & 0x100) == 0 )
        goto LABEL_92;
    }
    if ( v158 < 1.0 )
    {
      p_m_fHitHeadHeight = &this->m_fHitHeadHeight;
      if ( v156 < this->m_fHitHeadHeight )
      {
        if ( (unsigned __int8)((*(_BYTE *)&v149->m_info & 7) - 2) <= 2u )
        {
          if ( (LOBYTE(v149[1].m_transform.m_translate.y) & 8) != 0 )
            *p_m_fHitHeadHeight = v156;
          v75 = v72 & 0x200000;
          if ( !v75 )
            goto LABEL_94;
LABEL_93:
          v76 = v155.m_vecPosition.z;
          if ( (float)(v155.m_vecPosition.z + 1.0) >= this->m_pMat->tz )
          {
            if ( (*(_BYTE *)&v149->m_info & 7) != 1
              || (((float)((float)((float)(v155.m_vecNormal.x * this->m_vecMoveSpeed.x)
                                 + (float)(v155.m_vecNormal.y * this->m_vecMoveSpeed.y))
                         + (float)(v155.m_vecNormal.z * this->m_vecMoveSpeed.z)) <= 0.0) | v49) << 31 )
            {
LABEL_103:
              if ( (*(_BYTE *)&v149->m_info & 7) == 2 )
              {
LABEL_104:
                v38 = 1.0;
LABEL_107:
                v48 = 0LL;
                goto LABEL_111;
              }
              v38 = v155.m_vecNormal.z;
              v48 = *(_QWORD *)&v155.m_vecNormal.x;
LABEL_111:
              m_nSurfaceType = v155.m_dataB.m_nSurfaceType;
              this->m_LastMaterialToHaveBeenStandingOn = v155.m_dataB.m_nSurfaceType;
              v80 = *(_QWORD *)&v155.m_vecNormal.x;
              this->m_vecGroundNormal.z = v155.m_vecNormal.z;
              *(_QWORD *)&this->m_vecGroundNormal.x = v80;
              if ( SurfaceInfos_c::IsSteepSlope(&g_surfaceInfos, m_nSurfaceType) )
                *((_DWORD *)&this->m_nPedFlags + 1) |= 0x20u;
              goto LABEL_113;
            }
LABEL_98:
            v38 = 1.0;
            v4.n64_u32[0] = LODWORD(this->m_fHitHeadHeight);
            v3.n64_f32[0] = v76 + 1.0;
            if ( v4.n64_f32[0] >= 100000.0 )
            {
              LODWORD(this->m_pMat->tz) = v3.n64_u32[0];
              v77 = *((_DWORD *)&this->m_nPedFlags + 1);
              if ( (v77 & 0x200000) != 0 )
              {
                v78 = *((_QWORD *)&this->m_nPedFlags + 1);
                *(_DWORD *)p_m_nPedFlags = *(_DWORD *)p_m_nPedFlags;
                *((_DWORD *)&this->m_nPedFlags + 1) = v77 & 0xFFDFFFFF;
                *((_QWORD *)&this->m_nPedFlags + 1) = v78;
              }
              goto LABEL_107;
            }
            if ( (float)(v25 + v3.n64_f32[0]) <= v4.n64_f32[0] )
            {
              v38 = 1.0;
              v48 = 0LL;
            }
            else
            {
              v4.n64_f32[0] = v4.n64_f32[0] - v25;
              v48 = *(_QWORD *)&v155.m_vecNormal.x;
              v38 = v155.m_vecNormal.z;
              v3.n64_u64[0] = vmin_f32(v4, v3).n64_u64[0];
            }
            LODWORD(this->m_pMat->tz) = v3.n64_u32[0];
            goto LABEL_111;
          }
LABEL_94:
          if ( v49 << 31 )
          {
            if ( !v75 )
              goto LABEL_104;
            goto LABEL_103;
          }
          v76 = v155.m_vecPosition.z;
          goto LABEL_98;
        }
        *p_m_fHitHeadHeight = v156;
      }
    }
LABEL_92:
    v75 = v72 & 0x200000;
    if ( !v75 )
      goto LABEL_94;
    goto LABEL_93;
  }
  v38 = 1.0;
  v145 = 0.0;
  v144 = 0.0;
  v43 = v149;
  v41 = p_m_nFlags;
  v40 = &this->m_nPedFlags;
LABEL_163:
  if ( v26 >= 1 )
  {
    v107 = 0;
    p_m_heading = (_DWORD *)&v43[19].m_transform.m_heading;
    do
    {
      v117 = *((_DWORD *)v40 + 2);
      v118 = (v117 & 0x8000) == 0;
      if ( (v117 & 0x8000) != 0 )
        v118 = *(_BYTE *)v41 << 31 == 0;
      if ( v118 || (m_nPieceType = aColPoints[v107].m_dataA.m_nPieceType, m_nPieceType < 3) )
      {
        v122 = *(_BYTE *)&v43->m_info & 7;
        v123 = v122 == 2;
        if ( v122 == 2 )
          v123 = LODWORD(v43[24].m_transform.m_translate.x) == 6;
        if ( v123 && (LOBYTE(v43[1].m_transform.m_translate.y) & 4) != 0 )
        {
          v108 = &aColPoints[v107];
          if ( v108->m_vecNormal.z < 0.0 )
          {
            v109 = v26;
            v108->m_vecNormal.z = 0.0;
            CVector::Normalise(&v108->m_vecNormal);
            v26 = v109;
          }
        }
        goto LABEL_194;
      }
      v120 = *(_QWORD *)v40;
      v121 = *((_DWORD *)v40 + 3);
      if ( (*(_BYTE *)&v43->m_info & 7) == 3 )
      {
        if ( (p_m_heading[2] & 0x100000) != 0 )
          goto LABEL_179;
        v110 = 1;
        v111 = (*p_m_heading & 0x4000000) == 0;
      }
      else
      {
        v110 = 0;
        v111 = 1;
      }
      v112 = !v111;
      if ( m_nPieceType != 6 || v112 == 1 )
      {
        if ( (m_nPieceType != 5) | v112 )
        {
          if ( m_nPieceType == 8 )
          {
            v113 = 0x40000;
          }
          else
          {
            v41 = p_m_nFlags;
            if ( (m_nPieceType != 4) | v110 )
              goto LABEL_179;
            v113 = 0x80000;
          }
        }
        else
        {
          v113 = 0x20000;
        }
      }
      else
      {
        v113 = 0x10000;
      }
      *(_DWORD *)p_m_nPedFlags = v120;
      *((_DWORD *)&this->m_nPedFlags + 1) = HIDWORD(v120);
      *((_DWORD *)&this->m_nPedFlags + 2) = v117 | v113;
      *((_DWORD *)&this->m_nPedFlags + 3) = v121;
      v41 = p_m_nFlags;
LABEL_179:
      if ( v107 >= --v26 )
      {
        v43 = v149;
        v40 = &this->m_nPedFlags;
      }
      else
      {
        v114 = &aColPoints[v107 + 1];
        v43 = v149;
        v115 = v26 - v107;
        v116 = v26;
        do
        {
          CColPoint::operator=((CColPoint *)&v114[-1], v114);
          ++v114;
          --v115;
        }
        while ( v115 );
        v26 = v116;
        --v107;
        v41 = p_m_nFlags;
        v40 = &this->m_nPedFlags;
      }
LABEL_194:
      ++v107;
    }
    while ( v107 < v26 );
  }
  v124 = v26;
  if ( m_heading > -1000.0 )
  {
    v125 = this->m_pMat;
    if ( v125 )
    {
      CMatrix::SetRotateZOnly(v125, m_heading);
      v26 = v124;
    }
    else
    {
      this->m_transform.m_heading = m_heading;
    }
  }
  if ( ((*(_BYTE *)&v43->m_info & 7) == 1 || (*(_DWORD *)&v149->m_nFlags & 0x40004) != 0)
    && (*(_DWORD *)p_m_nPedFlags & 2) != 0
    && v26 >= 1 )
  {
    v126 = v26;
    p_m_dataB = &aColPoints->m_dataB;
    v6.n64_u32[0] = 981668463;
    do
    {
      v128 = *(_QWORD *)&p_m_dataB[-7].m_lighting;
      *(_DWORD *)&v154.m_bIsPersistent = *(_DWORD *)&p_m_dataB[-4].m_nPieceType;
      *(_QWORD *)&v154._vptr$CEvent = v128;
      if ( *(float *)&v154.m_bIsPersistent < -0.99 && p_m_dataB[-1].m_nPieceType == 2 && this->m_nPedType <= 1u )
      {
        v129 = this->m_vecMoveSpeed.x;
        v130 = this->m_vecMoveSpeed.y;
        v5.n64_f32[0] = sqrtf((float)(v129 * v129) + (float)(v130 * v130));
        v5.n64_u64[0] = vmax_f32(v5, v6).n64_u64[0];
        *(float *)&v154.m_iAccumulatedTime = (float)-v130 / v5.n64_f32[0];
        *(float *)&v154._vptr$CEvent = (float)-v129 / v5.n64_f32[0];
        this->m_pMat->tz = this->m_pMat->tz + -0.05;
        *((_DWORD *)&this->m_nPedFlags + 1) |= 0x200020u;
      }
      else
      {
        v131 = sqrtf(
                 (float)(*(float *)&v154._vptr$CEvent * *(float *)&v154._vptr$CEvent)
               + (float)(*(float *)&v154.m_iAccumulatedTime * *(float *)&v154.m_iAccumulatedTime));
        if ( v131 != 0.0 )
        {
          *(float *)&v154.m_iAccumulatedTime = *(float *)&v154.m_iAccumulatedTime / v131;
          *(float *)&v154._vptr$CEvent = *(float *)&v154._vptr$CEvent / v131;
        }
      }
      CVector::Normalise((CVector *)&v154);
      v132 = *(_QWORD *)&v154._vptr$CEvent;
      *(_DWORD *)&p_m_dataB[-4].m_nPieceType = *(_DWORD *)&v154.m_bIsPersistent;
      *(_QWORD *)&p_m_dataB[-7].m_lighting = v132;
      IsSteepSlope = SurfaceInfos_c::IsSteepSlope(&g_surfaceInfos, p_m_dataB->m_nSurfaceType);
      v135 = IsSteepSlope == 0;
      p_m_dataB = (ColData *)((char *)p_m_dataB + 44);
      if ( IsSteepSlope )
      {
        v134 = &this->m_nPedFlags;
        IsSteepSlope = *((_DWORD *)&this->m_nPedFlags + 1) | 0x20;
      }
      v26 = v124;
      if ( !v135 )
        *((_DWORD *)v134 + 1) = IsSteepSlope;
      --v126;
    }
    while ( v126 );
  }
  if ( v38 >= 1.0 )
  {
    v137 = this;
  }
  else
  {
    v136 = &aColPoints[v26];
    v136->m_vecNormal.y = v144;
    v136->m_vecNormal.z = 0.0;
    v136->m_vecNormal.x = v145;
    CVector::Normalise(&v136->m_vecNormal);
    v137 = this;
    v26 = v124 + 1;
    v138 = this->m_pMat;
    p_m_transform = (CSimpleTransform *)&v138->tx;
    if ( !v138 )
      p_m_transform = &this->m_transform;
    v140 = p_m_transform->m_translate.y - (float)(v136->m_vecNormal.y * 0.35);
    v141 = p_m_transform->m_translate.z - (float)(v136->m_vecNormal.z * 0.35);
    v136->m_vecPosition.x = p_m_transform->m_translate.x - (float)(v136->m_vecNormal.x * 0.35);
    v136->m_vecPosition.y = v140;
    v136->m_vecPosition.z = v141;
    *((_DWORD *)&this->m_nPedFlags + 1) |= 0x20u;
  }
  if ( v26 > 0 || aLineRatios < 1.0 )
  {
    v142 = v26;
    CPhysical::AddCollisionRecord(v137, v149);
    if ( (*(_BYTE *)&v149->m_info & 7) != 1 )
      CPhysical::AddCollisionRecord((CPhysical *)v149, v137);
    v26 = v142;
    if ( v142 >= 1 && ((*(_BYTE *)&v149->m_info & 7) == 1 || (*(_DWORD *)&v149->m_nFlags & 0x40004) != 0) )
      *(_DWORD *)p_m_nFlags |= 0x1000u;
  }
  return v26;
}
// 4A3C8E: conditional instruction was optimized away because r1.4==0
// 4A3A50: variable 'v4' is possibly undefined
// 4A3A50: variable 'v3' is possibly undefined
// 4A3C2A: variable 'v5' is possibly undefined
// 4A3CE2: variable 'v96' is possibly undefined
// 4A3DBC: variable 'v101' is possibly undefined
// 4A3DE0: variable 'v97' is possibly undefined
// 4A411C: variable 'v6' is possibly undefined
// 4A41B0: variable 'v134' is possibly undefined
// 5: using guessed type char byte_5;
// 4A42D4: using guessed type int dword_4A42D4[2];

//----- (004A4304) --------------------------------------------------------
int32 __fastcall CPed::GetLocalDirection(CPed *this, const CVector2D *dir)
{
  float i; // s0
  int v3; // s0
  int v4; // r1

  for ( i = (float)(atan2f(COERCE_FLOAT(LODWORD(dir->x) ^ 0x80000000), dir->y) - this->m_fCurrentHeading) + 0.7854;
        i < 0.0;
        i = i + 6.2832 )
  {
    ;
  }
  v3 = (int)(float)(i / 1.5708);
  v4 = ~v3;
  if ( ~v3 < -4 || v3 == 3 )
    v4 = -4;
  return v3 - ((v4 + v3 + 4) & 0xFFFFFFFC);
}

//----- (004A4380) --------------------------------------------------------
void __fastcall CPed::DoFootLanded(CPed *this, bool left, bool8 doWobble)
{
  int v4; // r8
  _BOOL4 v5; // r6
  CPedFlags *p_m_nPedFlags; // r9
  RpHAnimHierarchy_0 *AnimHierarchyFromSkinClump; // r0
  RpHAnimHierarchy_0 *v8; // r5
  RwInt32 v9; // r1
  RwInt32 v10; // r6
  RwMatrix *v11; // r0
  __int64 v12; // d16
  RwReal z; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  CMatrix *v16; // r0
  float xy; // s26
  float yy; // s24
  float xx; // s22
  float yx; // s20
  RwReal v21; // s0
  uint32 m_nTimeOfDeath; // r0
  CMatrix *v23; // r1
  CSimpleTransform *p_m_transform; // r2
  CSimpleTransform *v25; // r1
  float32x2_t v26; // d16
  unsigned __int64 v27; // d0
  UInt32 Duration; // r0
  int v29; // r0
  bool v30; // zf
  CSimpleTransform *v31; // r2
  float32x2_t v32; // d16
  unsigned __int64 v33; // d0
  int v34; // r9
  CMatrix *v35; // r0
  float zy; // s4
  RwReal v37; // s0
  CSimpleTransform *v38; // r2
  float32x2_t v39; // d16
  unsigned __int64 v40; // d0
  int v41; // r6
  int v42; // r0
  float v43; // s0
  float v44; // s2
  float v45; // s18
  CMatrix *v46; // r0
  float v47; // s4
  float v48; // s2
  float v49; // s0
  CMatrix *v50; // r0
  CSimpleTransform *v51; // r1
  float v52; // s20
  float x; // s16
  float y; // s18
  float v55; // s2
  float m_heading; // r5
  float v57; // r6
  CVector pCoors; // [sp+38h] [bp-A8h] BYREF
  RwV3d_0 v59; // [sp+44h] [bp-9Ch] BYREF
  RwV3d_0 vel; // [sp+50h] [bp-90h] BYREF
  RwV3d_0 pos; // [sp+60h] [bp-80h] BYREF
  FxPrtMult_c fxMults; // [sp+70h] [bp-70h] BYREF

  v4 = doWobble;
  v5 = left;
  if ( (*((_BYTE *)&this->m_nPedFlags + 9) & 4) == 0 || *((unsigned __int8 *)&this->m_nFlags + 2) >> 7 )
    return;
  p_m_nPedFlags = &this->m_nPedFlags;
  AnimHierarchyFromSkinClump = GetAnimHierarchyFromSkinClump((RpClump_0 *)this->m_pRwObject);
  v8 = AnimHierarchyFromSkinClump;
  if ( !v5 )
  {
    if ( AnimHierarchyFromSkinClump )
    {
      v9 = 53;
      goto LABEL_8;
    }
LABEL_9:
    m_pMat = this->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &this->m_transform;
    v12 = *(_QWORD *)&p_tx->m_translate.x;
    z = p_tx->m_translate.z;
    goto LABEL_12;
  }
  if ( !AnimHierarchyFromSkinClump )
    goto LABEL_9;
  v9 = 43;
LABEL_8:
  v10 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, v9);
  v11 = &RpHAnimHierarchyGetMatrixArray(v8)[v10];
  v12 = *(_QWORD *)&v11->pos.x;
  z = v11->pos.z;
LABEL_12:
  pCoors.z = z;
  *(_QWORD *)&pCoors.x = v12;
  v16 = this->m_pMat;
  xy = v16->xy;
  yy = v16->yy;
  xx = v16->xx;
  yx = v16->yx;
  v21 = (float)(v16->zy * 0.2) + (float)(pCoors.z + -0.1);
  pCoors.x = (float)(xy * 0.2) + *(float *)&v12;
  pCoors.y = (float)(yy * 0.2) + *((float *)&v12 + 1);
  pCoors.z = v21;
  if ( (*((_BYTE *)&this->m_nPedFlags + 3) & 0x10) != 0 && CLocalisation::Blood() )
  {
    CShadows::AddPermanentShadow(
      1u,
      gpBloodPoolTex,
      &pCoors,
      xy * 0.26,
      yy * 0.26,
      xx * 0.14,
      yx * 0.14,
      255,
      0xC8u,
      0,
      0,
      4.0,
      0xBB8u,
      1.0);
    m_nTimeOfDeath = this->m_nTimeOfDeath;
    if ( m_nTimeOfDeath < 0x15 )
    {
      this->m_nTimeOfDeath = 0;
      *(_DWORD *)p_m_nPedFlags &= ~0x10000000u;
    }
    else
    {
      this->m_nTimeOfDeath = m_nTimeOfDeath - 20;
    }
  }
  if ( SurfaceInfos_c::LeavesFootsteps(&g_surfaceInfos, this->m_LastMaterialToHaveBeenStandingOn) )
  {
    v23 = this->m_pMat;
    p_m_transform = (CSimpleTransform *)&v23->tx;
    if ( !v23 )
      p_m_transform = &this->m_transform;
    v25 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
    if ( !TheCamera.m_pMat )
      v25 = &TheCamera.m_transform;
    v26.n64_u64[0] = vsub_f32(*(float32x2_t *)&v25->m_translate.x, *(float32x2_t *)&p_m_transform->m_translate.x).n64_u64[0];
    v27 = vmul_f32(v26, v26).n64_u64[0];
    if ( sqrtf(*(float *)&v27 + *((float *)&v27 + 1)) < 10.0 )
    {
      Duration = 2000;
      if ( this->m_nPedType < 2u )
        Duration = 5000;
      CShadows::AddPermanentShadow(
        1u,
        gpShadowPedTex,
        &pCoors,
        xy * -0.26,
        yy * -0.26,
        xx * -0.1,
        yx * -0.1,
        120,
        0xFAu,
        0xFAu,
        0x32u,
        4.0,
        Duration,
        1.0);
    }
  }
  if ( CWeather::Rain > 0.1 && !CCullZones::CamNoRain() )
  {
    v29 = CCullZones::PlayerNoRain();
    v30 = CGame::currArea == AREA_MAIN_MAP;
    if ( CGame::currArea == AREA_MAIN_MAP )
      v30 = v29 == 0;
    if ( v30 && CEntity::GetIsOnScreen(this) )
    {
      v31 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
      if ( !TheCamera.m_pMat )
        v31 = &TheCamera.m_transform;
      v32.n64_u64[0] = vsub_f32(*(float32x2_t *)&pCoors.x, *(float32x2_t *)&v31->m_translate.x).n64_u64[0];
      v33 = vmul_f32(v32, v32).n64_u64[0];
      if ( (float)((float)(*(float *)&v33 + *((float *)&v33 + 1)) + 0.0) <= 100.0 )
      {
        FxPrtMult_c::FxPrtMult_c(&fxMults, 1.0, 1.0, 1.0, 0.1, 0.15, 0.0, 0.15);
        v34 = 4;
        do
        {
          pos = pCoors.RwV3d_0;
          pos.x = pos.x + (float)((float)((float)((float)rand() * 4.6566e-10) * 0.2) + -0.1);
          pos.y = pos.y + (float)((float)((float)((float)rand() * 4.6566e-10) * 0.2) + -0.1);
          memset(&vel, 0, sizeof(vel));
          v35 = this->m_pMat;
          zy = v35->zy;
          v37 = v35->xy * 1.5;
          v59.y = v35->yy * 1.5;
          v59.x = v37;
          v59.z = zy * 1.5;
          FxSystem_c::AddParticle(g_fx.m_fxSysSplash, &pos, &vel, 0.0, &fxMults, -1.0, 1.2, 0.6, 0);
          FxSystem_c::AddParticle(g_fx.m_fxSysSplash, &pos, &v59, 0.0, &fxMults, -1.0, 1.2, 0.6, 0);
          --v34;
        }
        while ( v34 );
      }
    }
  }
  if ( CEntity::GetIsOnScreen(this) )
  {
    v38 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
    if ( !TheCamera.m_pMat )
      v38 = &TheCamera.m_transform;
    v39.n64_u64[0] = vsub_f32(*(float32x2_t *)&pCoors.x, *(float32x2_t *)&v38->m_translate.x).n64_u64[0];
    v40 = vmul_f32(v39, v39).n64_u64[0];
    if ( (float)((float)(*(float *)&v40 + *((float *)&v40 + 1)) + 0.0) <= 100.0 )
    {
      FxPrtMult_c::FxPrtMult_c(&fxMults, 1.0, 1.0, 1.0, 0.1, 0.15, 0.0, 0.15);
      if ( SurfaceInfos_c::ProducesFootDust(&g_surfaceInfos, this->m_LastMaterialToHaveBeenStandingOn) )
      {
        v41 = 4;
        do
        {
          while ( 1 )
          {
            pos = pCoors.RwV3d_0;
            pos.x = pos.x + (float)((float)((float)((float)rand() * 4.6566e-10) * 0.2) + -0.1);
            pos.y = pos.y + (float)((float)((float)((float)rand() * 4.6566e-10) * 0.2) + -0.1);
            vel.x = (float)((float)((float)rand() * 4.6566e-10) * 0.3) + -0.15;
            v42 = rand();
            vel.z = 0.0;
            vel.y = (float)((float)((float)v42 * 4.6566e-10) * 0.3) + -0.15;
            if ( !g_bUsingAnimViewer )
              break;
            if ( !--v41 )
              goto LABEL_48;
          }
          FxSystem_c::AddParticle(g_fx.m_fxSysSmoke2, &pos, &vel, 0.0, &fxMults, -1.0, 1.2, 0.6, 0);
          --v41;
        }
        while ( v41 );
      }
    }
  }
LABEL_48:
  if ( v4 )
  {
    v43 = this->m_vecCurrentVelocity.y * this->m_vecCurrentVelocity.y;
    v44 = this->m_vecCurrentVelocity.x * this->m_vecCurrentVelocity.x;
    this->m_wobble = 6.2832;
    this->m_wobbleSpeed = (float)((float)(v44 + v43) * 20.0) + 0.4;
  }
  if ( *((unsigned __int8 *)&this->m_nPhysicalFlags + 1) << 31 )
  {
    v50 = this->m_pMat;
    v51 = (CSimpleTransform *)&v50->tx;
    if ( !v50 )
      v51 = &this->m_transform;
    v52 = v51->m_translate.z;
    x = v51->m_translate.x;
    y = v51->m_translate.y;
    CWaterLevel::GetWaterLevel(v51->m_translate.x, y, v52 + 1.5, &pos.x, 1, 0);
    v55 = y
        + (float)((float)(CTimer::ms_fTimeStep * this->m_vecMoveSpeed.y)
                + (float)(CTimer::ms_fTimeStep * this->m_vecMoveSpeed.y));
    fxMults.m_red = x
                  + (float)((float)(CTimer::ms_fTimeStep * this->m_vecMoveSpeed.x)
                          + (float)(CTimer::ms_fTimeStep * this->m_vecMoveSpeed.x));
    fxMults.m_green = v55;
    fxMults.m_blue = pos.x;
    if ( (float)(v52 + -0.4) > pos.x )
    {
      Fx_c::TriggerFootSplash(&g_fx, (CVector *)&fxMults);
      CAEPedAudioEntity::AddAudioEvent(&this->m_PedAudioEntity, 54, 0.0, 1.0, 0, 0x27u, 0, 0);
    }
  }
  else if ( SurfaceInfos_c::IsShallowWater(&g_surfaceInfos, this->m_LastMaterialToHaveBeenStandingOn) )
  {
    v45 = pCoors.z + 0.3;
    *(_QWORD *)&fxMults.m_red = *(_QWORD *)&pCoors.x;
    fxMults.m_blue = pCoors.z + 0.3;
    v46 = this->m_pMat;
    if ( v46 )
    {
      v47 = v46->xy;
      v48 = v46->yy;
      v49 = v46->zy * -0.2;
    }
    else
    {
      m_heading = this->m_transform.m_heading;
      v57 = sinf(m_heading);
      v48 = cosf(m_heading);
      v49 = -0.0;
      LODWORD(v47) = LODWORD(v57) ^ 0x80000000;
    }
    fxMults.m_red = fxMults.m_red - (float)(v47 * 0.2);
    fxMults.m_blue = v49 + v45;
    fxMults.m_green = fxMults.m_green - (float)(v48 * 0.2);
    Fx_c::TriggerFootSplash(&g_fx, (CVector *)&fxMults);
    CAEPedAudioEntity::AddAudioEvent(&this->m_PedAudioEntity, 54, 0.0, 1.0, 0, 0x27u, 0, 0);
  }
}

//----- (004A4B0C) --------------------------------------------------------
void __fastcall CPed::GetBonePosition(CPed *this, RwV3d_0 *posn, uint32 boneTag, bool bCalledFromCamera)
{
  int v7; // r0
  RpHAnimHierarchy_0 *AnimHierarchyFromSkinClump; // r0
  RpHAnimHierarchy_0 *v9; // r5
  RwInt32 v10; // r6
  RwMatrix *v11; // r0
  __int64 v12; // d16
  RwReal z; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  CVector v16; // [sp+0h] [bp-28h] BYREF

  v7 = *((_DWORD *)&this->m_nPedFlags + 2) & 0x400;
  if ( bCalledFromCamera )
  {
    if ( !v7 )
    {
      CEntity::UpdateRpHAnim(this);
      *((_DWORD *)&this->m_nPedFlags + 2) |= 0x400u;
    }
  }
  else if ( !v7 )
  {
    operator*(&v16, this->m_pMat, &aStdBonePosisions[boneTag]);
    v12 = *(_QWORD *)&v16.x;
    z = v16.z;
    goto LABEL_11;
  }
  AnimHierarchyFromSkinClump = GetAnimHierarchyFromSkinClump((RpClump_0 *)this->m_pRwObject);
  v9 = AnimHierarchyFromSkinClump;
  if ( AnimHierarchyFromSkinClump )
  {
    v10 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, boneTag);
    v11 = &RpHAnimHierarchyGetMatrixArray(v9)[v10];
    v12 = *(_QWORD *)&v11->pos.x;
    z = v11->pos.z;
  }
  else
  {
    m_pMat = this->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &this->m_transform;
    z = p_tx->m_translate.z;
    v12 = *(_QWORD *)&p_tx->m_translate.x;
  }
LABEL_11:
  posn->z = z;
  *(_QWORD *)&posn->x = v12;
}

//----- (004A4BAC) --------------------------------------------------------
bool __fastcall CPed::IsAlive(const CPed *this)
{
  return (this->m_nPedState & 0xFFFFFFFE) != 54;
}

//----- (004A4BBE) --------------------------------------------------------
bool __fastcall CPed::IsPedShootable(CPed *this)
{
  return this->m_nPedState < PED_ENTER_TRAIN;
}

//----- (004A4BCC) --------------------------------------------------------
bool __fastcall CPed::UseGroundColModel(CPed *this)
{
  unsigned __int32 v1; // r0
  _BOOL4 v2; // r0

  v1 = this->m_nPedState - 42;
  if ( v1 <= 0xD )
    return (0x3009u >> v1) & 1;
  else
    LOBYTE(v2) = 0;
  return v2;
}

//----- (004A4BEC) --------------------------------------------------------
bool __fastcall CPed::CanSetPedState(CPed *this)
{
  unsigned __int32 v1; // r0
  _BOOL4 v2; // r0

  v1 = this->m_nPedState - 54;
  if ( v1 <= 9 )
    return (0x194u >> v1) & 1;
  else
    LOBYTE(v2) = 1;
  return v2;
}

//----- (004A4C0C) --------------------------------------------------------
bool __fastcall CPed::CanBeArrested(CPed *this)
{
  unsigned __int32 v1; // r0
  _BOOL4 v2; // r0

  v1 = this->m_nPedState - 54;
  if ( v1 <= 9 )
    return (0x15Cu >> v1) & 1;
  else
    LOBYTE(v2) = 1;
  return v2;
}

//----- (004A4C2C) --------------------------------------------------------
bool __fastcall CPed::CanStrafeOrMouseControl(CPed *this)
{
  ePedState m_nPedState; // r1
  bool result; // r0

  m_nPedState = this->m_nPedState;
  result = 1;
  switch ( m_nPedState )
  {
    case PED_NONE:
    case PED_IDLE:
    case PED_FLEE_POSITION:
    case PED_FLEE_ENTITY:
    case PED_ATTACK:
    case PED_FIGHT:
    case PED_AIMGUN:
    case PED_ANSWER_MOBILE:
    case PED_JUMP:
      return result;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (004A4C6A) --------------------------------------------------------
RwObject_0 *__fastcall SetAtomicVisibilityCB(RwObject_0 *pObject, void *data)
{
  void *AtomicId; // r0
  RwUInt8 v5; // r1
  RwObject_0 *result; // r0

  AtomicId = (void *)CVisibilityPlugins::GetAtomicId((RpAtomic_0 *)pObject);
  v5 = 0;
  if ( AtomicId == data )
    v5 = 4;
  result = pObject;
  pObject->flags = v5;
  return result;
}

//----- (004A4C88) --------------------------------------------------------
Bool8 __fastcall CPed::CanBeDeleted(CPed *this)
{
  CPlayerPed *PlayerPed; // r0
  int CharCreatedBy; // r0
  bool v4; // zf

  if ( *((unsigned __int8 *)&this->m_nPedFlags + 1) << 31 )
    return 0;
  PlayerPed = FindPlayerPed(-1);
  if ( CPedGroupMembership::IsFollower(
         &CPedGroups::ms_groups[PlayerPed->m_pPlayerData->m_PlayerGroup].m_membership,
         this) )
  {
    return 0;
  }
  CharCreatedBy = this->CharCreatedBy;
  v4 = CharCreatedBy == 3;
  if ( CharCreatedBy != 3 )
    v4 = CharCreatedBy == 2;
  return !v4;
}

//----- (004A4CD4) --------------------------------------------------------
Bool8 __fastcall CPed::CanBeDeletedEvenInVehicle(CPed *this)
{
  int CharCreatedBy; // r0
  bool v2; // zf

  CharCreatedBy = this->CharCreatedBy;
  v2 = CharCreatedBy == 3;
  if ( CharCreatedBy != 3 )
    v2 = CharCreatedBy == 2;
  return !v2;
}

//----- (004A4CE8) --------------------------------------------------------
void __fastcall CPed::AddWeaponModel(CPed *this, int32 weaponId)
{
  CBaseModelInfo *v4; // r6
  RpClump_0 *v5; // r0
  RwFrame_0 *FrameFromName; // r0
  unsigned int m_nPedType; // r0
  char *v8; // r0
  int v9; // r1
  bool v10; // zf
  FxSystem_c **v11; // r8
  RpHAnimHierarchy_0 *AnimHierarchyFromSkinClump; // r4
  RwInt32 v13; // r5
  RwMatrix *MatrixArray; // r0
  FxSystem_c *v15; // r0
  RwV3d_0 offsetPos; // [sp+4h] [bp-1Ch] BYREF

  if ( weaponId != -1 && !this->m_WeaponSlots[this->m_nCurrentWeapon].m_bDontPlaceInHand )
  {
    v4 = CModelInfo::ms_modelInfoPtrs[weaponId];
    if ( this->m_pWeaponClump )
      CPed::RemoveWeaponModel(this, -1);
    v5 = (RpClump_0 *)(*((int (__fastcall **)(CBaseModelInfo *))v4->_vptr$CBaseModelInfo + 11))(v4);
    this->m_pWeaponClump = v5;
    if ( v5 )
      FrameFromName = CClumpModelInfo::GetFrameFromName(v5, "gunflash");
    else
      FrameFromName = 0;
    this->m_pWeaponFlashFrame = FrameFromName;
    CBaseModelInfo::AddRef(v4);
    m_nPedType = this->m_nPedType;
    this->WeaponModelInHand = weaponId;
    if ( m_nPedType <= 1 && weaponId == 344 )
    {
      v8 = (char *)this + 28 * this->m_nCurrentWeapon;
      v9 = *((_DWORD *)v8 + 361);
      v10 = v9 == 18;
      if ( v9 == 18 )
        v10 = *((_DWORD *)v8 + 367) == 0;
      if ( v10 )
      {
        v11 = (FxSystem_c **)(v8 + 1468);
        AnimHierarchyFromSkinClump = GetAnimHierarchyFromSkinClump((RpClump_0 *)this->m_pRwObject);
        v13 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, 24);
        MatrixArray = RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump);
        memset(&offsetPos, 0, sizeof(offsetPos));
        v15 = FxManager_c::CreateFxSystem(&g_fxMan, "molotov_flame", &offsetPos, &MatrixArray[v13], 0);
        *v11 = v15;
        if ( v15 )
        {
          FxSystem_c::SetLocalParticles(v15, 1u);
          FxSystem_c::CopyParentMatrix(*v11);
          FxSystem_c::Play(*v11);
        }
      }
    }
  }
}

//----- (004A4DF4) --------------------------------------------------------
void __fastcall CPed::RemoveWeaponModel(CPed *this, int32 weaponId)
{
  char *v4; // r0
  FxSystem_c *v5; // r1
  _DWORD *v6; // r6
  RpClump_0 *m_pWeaponClump; // r0
  CClumpModelInfo *ClumpModelInfo; // r0
  RpAtomic_0 *FirstAtomic; // r0

  if ( this->m_nPedType <= 1u )
  {
    v4 = (char *)this + 28 * this->m_nCurrentWeapon;
    v5 = (FxSystem_c *)*((_DWORD *)v4 + 367);
    if ( v5 )
    {
      v6 = v4 + 1468;
      FxManager_c::DestroyFxSystem(&g_fxMan, v5);
      *v6 = 0;
    }
  }
  m_pWeaponClump = this->m_pWeaponClump;
  if ( m_pWeaponClump )
  {
    if ( weaponId != -1 )
    {
      if ( CVisibilityPlugins::GetClumpModelInfo(m_pWeaponClump) != CModelInfo::ms_modelInfoPtrs[weaponId] )
        goto LABEL_12;
      m_pWeaponClump = this->m_pWeaponClump;
    }
    ClumpModelInfo = CVisibilityPlugins::GetClumpModelInfo(m_pWeaponClump);
    CBaseModelInfo::RemoveRef(ClumpModelInfo);
    FirstAtomic = GetFirstAtomic(this->m_pWeaponClump);
    if ( FirstAtomic && j_RpSkinGeometryGetSkin(FirstAtomic->geometry) )
      RpClumpForAllAtomics(this->m_pWeaponClump, AtomicRemoveAnimFromSkinCB, 0);
    RpClumpDestroy(this->m_pWeaponClump);
    this->m_pWeaponClump = 0;
    this->m_pWeaponFlashFrame = 0;
  }
LABEL_12:
  this->m_nGunFlashBlendAmount = 0;
  this->WeaponModelInHand = -1;
  this->m_nGunFlashBlendAmount2 = 0;
}

//----- (004A4EAC) --------------------------------------------------------
void __fastcall CPed::AddGogglesModel(CPed *this, int32 weaponId, bool *pbEffectFlag)
{
  CBaseModelInfo *v5; // r6

  if ( weaponId != -1 )
  {
    v5 = CModelInfo::ms_modelInfoPtrs[weaponId];
    if ( this->m_pGogglesClump )
      CPed::RemoveGogglesModel(this);
    this->m_pGogglesClump = (RpClump_0 *)(*((int (__fastcall **)(CBaseModelInfo *))v5->_vptr$CBaseModelInfo + 11))(v5);
    CBaseModelInfo::AddRef(v5);
    this->m_pbGogglesEffect = pbEffectFlag;
    *pbEffectFlag = 1;
  }
}

//----- (004A4EF8) --------------------------------------------------------
void __fastcall CPed::RemoveGogglesModel(CPed *this)
{
  RpClump_0 *m_pGogglesClump; // r0
  CClumpModelInfo *ClumpModelInfo; // r0
  RpAtomic_0 *FirstAtomic; // r0
  bool *m_pbGogglesEffect; // r0

  m_pGogglesClump = this->m_pGogglesClump;
  if ( m_pGogglesClump )
  {
    ClumpModelInfo = CVisibilityPlugins::GetClumpModelInfo(m_pGogglesClump);
    CBaseModelInfo::RemoveRef(ClumpModelInfo);
    FirstAtomic = GetFirstAtomic(this->m_pGogglesClump);
    if ( FirstAtomic && j_RpSkinGeometryGetSkin(FirstAtomic->geometry) )
      RpClumpForAllAtomics(this->m_pGogglesClump, AtomicRemoveAnimFromSkinCB, 0);
    RpClumpDestroy(this->m_pGogglesClump);
    m_pbGogglesEffect = this->m_pbGogglesEffect;
    this->m_pGogglesClump = 0;
    if ( m_pbGogglesEffect )
    {
      *m_pbGogglesEffect = 0;
      this->m_pbGogglesEffect = 0;
    }
  }
}

//----- (004A4F54) --------------------------------------------------------
void __fastcall CPed::PutOnGoggles(CPed *this)
{
  int32 m_nWeaponSlot; // r10
  char *v3; // r5
  eWeaponType v4; // r0
  int32 m_modelId; // r9
  CBaseModelInfo *v6; // r8
  char **v7; // r0
  CBaseModelInfo *v8; // r8
  bool *v9; // r0

  m_nWeaponSlot = CWeaponInfo::GetWeaponInfo(WEAPONTYPE_INFRARED, 1)->m_nWeaponSlot;
  v3 = (char *)this + 28 * m_nWeaponSlot;
  v4 = *((_DWORD *)v3 + 361);
  if ( (v4 & 0xFFFFFFFE) == 44 )
  {
    m_modelId = CWeaponInfo::GetWeaponInfo(v4, 1)->m_modelId;
    if ( *((_DWORD *)v3 + 361) == 45 )
    {
      if ( m_modelId == -1 )
        goto LABEL_12;
      v6 = CModelInfo::ms_modelInfoPtrs[m_modelId];
      if ( this->m_pGogglesClump )
        CPed::RemoveGogglesModel(this);
      this->m_pGogglesClump = (RpClump_0 *)(*((int (__fastcall **)(CBaseModelInfo *))v6->_vptr$CBaseModelInfo + 11))(v6);
      CBaseModelInfo::AddRef(v6);
      v7 = &CPostEffects::m_bInfraredVision;
    }
    else
    {
      if ( m_modelId == -1 )
        goto LABEL_12;
      v8 = CModelInfo::ms_modelInfoPtrs[m_modelId];
      if ( this->m_pGogglesClump )
        CPed::RemoveGogglesModel(this);
      this->m_pGogglesClump = (RpClump_0 *)(*((int (__fastcall **)(CBaseModelInfo *))v8->_vptr$CBaseModelInfo + 11))(v8);
      CBaseModelInfo::AddRef(v8);
      v7 = CPostEffects::m_bNightVision;
    }
    v9 = (bool *)*v7;
    this->m_pbGogglesEffect = v9;
    *v9 = 1;
LABEL_12:
    v3[1465] = 1;
    if ( m_nWeaponSlot == this->m_nCurrentWeapon )
      CPed::RemoveWeaponModel(this, m_modelId);
  }
}
// 676668: using guessed type char *CPostEffects::m_bNightVision[2];
// 678FE0: using guessed type char *CPostEffects::m_bInfraredVision;

//----- (004A503C) --------------------------------------------------------
void __fastcall CPed::TakeOffGoggles(CPed *this)
{
  int32 m_nWeaponSlot; // r6
  char *v3; // r5
  eWeaponType v4; // r0
  int32 m_modelId; // r8

  m_nWeaponSlot = CWeaponInfo::GetWeaponInfo(WEAPONTYPE_INFRARED, 1)->m_nWeaponSlot;
  v3 = (char *)this + 28 * m_nWeaponSlot;
  v4 = *((_DWORD *)v3 + 361);
  if ( (v4 & 0xFFFFFFFE) == 44 )
  {
    m_modelId = CWeaponInfo::GetWeaponInfo(v4, 1)->m_modelId;
    CPed::RemoveGogglesModel(this);
    v3[1465] = 0;
    if ( m_nWeaponSlot == this->m_nCurrentWeapon )
      CPed::AddWeaponModel(this, m_modelId);
  }
}

//----- (004A5096) --------------------------------------------------------
void __fastcall CPed::GiveDelayedWeapon(CPed *this, eWeaponType weaponType, UInt32 ammo)
{
  CTaskSimpleHoldEntity *TaskHold; // r0
  bool v7; // zf

  if ( this->m_nPedType >= 2u )
  {
    TaskHold = CPedIntelligence::GetTaskHold(this->m_pPedIntelligence, 0);
    v7 = TaskHold == 0;
    if ( TaskHold )
      v7 = TaskHold->m_pHoldEntity == 0;
    if ( !v7 && TaskHold->m_nBoneId == 6 )
      CPed::DropEntityThatThisPedIsHolding(this, 1u);
  }
  if ( this->m_eDelayedWeapon == WEAPONTYPE_UNIDENTIFIED )
  {
    this->m_eDelayedWeapon = weaponType;
    this->m_delayedAmmo = ammo;
    CPed::RequestDelayedWeapon(this);
  }
}

//----- (004A50F2) --------------------------------------------------------
void __fastcall CPed::DropEntityThatThisPedIsHolding(CPed *this, bool8 deleteObj)
{
  int v3; // r4
  CTaskSimpleHoldEntity *ActiveTaskByType; // r0
  CEntity *m_pHoldEntity; // r6
  bool v6; // zf
  int v7; // r0
  bool v8; // zf

  v3 = deleteObj;
  ActiveTaskByType = (CTaskSimpleHoldEntity *)CTaskManager::FindActiveTaskByType(
                                                &this->m_pPedIntelligence->m_taskManager,
                                                307);
  if ( ActiveTaskByType
    || (ActiveTaskByType = (CTaskSimpleHoldEntity *)CTaskManager::FindActiveTaskByType(
                                                      &this->m_pPedIntelligence->m_taskManager,
                                                      308)) != 0
    || (ActiveTaskByType = (CTaskSimpleHoldEntity *)CTaskManager::FindActiveTaskByType(
                                                      &this->m_pPedIntelligence->m_taskManager,
                                                      309)) != 0 )
  {
    m_pHoldEntity = ActiveTaskByType->m_pHoldEntity;
    CTaskSimpleHoldEntity::DropEntity(ActiveTaskByType, this, 1);
    v6 = v3 == 0;
    if ( v3 )
      v6 = m_pHoldEntity == 0;
    if ( !v6 )
    {
      v7 = *(_BYTE *)&m_pHoldEntity->m_info & 7;
      v8 = v7 == 4;
      if ( v7 == 4 )
        v8 = LOBYTE(m_pHoldEntity[5].m_pMat) == 2;
      if ( !v8 )
      {
        (*((void (__fastcall **)(CEntity *))m_pHoldEntity->_vptr$CPlaceable + 9))(m_pHoldEntity);
        CWorld::Remove(m_pHoldEntity);
        (*((void (__fastcall **)(CEntity *))m_pHoldEntity->_vptr$CPlaceable + 1))(m_pHoldEntity);
      }
    }
  }
}

//----- (004A5178) --------------------------------------------------------
int32 __fastcall CPed::GetWeaponSlot(CPed *this, eWeaponType weaponType)
{
  return CWeaponInfo::GetWeaponInfo(weaponType, 1)->m_nWeaponSlot;
}

//----- (004A5188) --------------------------------------------------------
void __fastcall CPed::SetCurrentWeapon(CPed *this, int weaponSlot)
{
  eWeaponType m_eWeaponType; // r0
  CWeaponInfo *WeaponInfo; // r0
  CWeaponInfo *v6; // r0
  CPlayerPedData *m_pPlayerData; // r0
  int32 m_modelId; // r1

  if ( weaponSlot != -1 )
  {
    m_eWeaponType = this->m_WeaponSlots[this->m_nCurrentWeapon].m_eWeaponType;
    if ( this->m_nCurrentWeapon && m_eWeaponType == WEAPONTYPE_UNARMED )
    {
      WeaponInfo = CWeaponInfo::GetWeaponInfo(WEAPONTYPE_UNARMED, 1);
      CPed::RemoveWeaponModel(this, WeaponInfo->m_modelId);
      m_eWeaponType = this->m_WeaponSlots[this->m_nCurrentWeapon].m_eWeaponType;
    }
    if ( m_eWeaponType )
    {
      v6 = CWeaponInfo::GetWeaponInfo(m_eWeaponType, 1);
      CPed::RemoveWeaponModel(this, v6->m_modelId);
    }
    m_pPlayerData = this->m_pPlayerData;
    this->m_nCurrentWeapon = weaponSlot;
    if ( m_pPlayerData )
      m_pPlayerData->m_nChosenWeapon = weaponSlot;
    if ( this->m_WeaponSlots[weaponSlot].m_eWeaponType )
    {
      m_modelId = CWeaponInfo::GetWeaponInfo(this->m_WeaponSlots[this->m_nCurrentWeapon].m_eWeaponType, 1)->m_modelId;
      CPed::AddWeaponModel(this, m_modelId);
    }
  }
}

//----- (004A521C) --------------------------------------------------------
void __fastcall CPed::SetCurrentWeapon(CPed *this, eWeaponType weaponType)
{
  int m_nWeaponSlot; // r1

  m_nWeaponSlot = CWeaponInfo::GetWeaponInfo(weaponType, 1)->m_nWeaponSlot;
  CPed::SetCurrentWeapon(this, m_nWeaponSlot);
}

//----- (004A5234) --------------------------------------------------------
void __fastcall CPed::GrantAmmo(CPed *this, eWeaponType weaponType, UInt32 ammoQuantity)
{
  int32 m_nWeaponSlot; // r0
  UInt32 v6; // r3
  char *v7; // r0
  int v8; // r1
  signed int v9; // r2

  m_nWeaponSlot = CWeaponInfo::GetWeaponInfo(weaponType, 1)->m_nWeaponSlot;
  if ( m_nWeaponSlot != -1 )
  {
    v6 = 99999;
    v7 = (char *)this + 28 * m_nWeaponSlot;
    v8 = *((_DWORD *)v7 + 362);
    v9 = *((_DWORD *)v7 + 364) + ammoQuantity;
    if ( v9 < 99999 )
      v6 = *((_DWORD *)v7 + 364) + ammoQuantity;
    *((_DWORD *)v7 + 364) = v6;
    if ( v9 >= 1 && v8 == 3 )
      *((_DWORD *)v7 + 362) = 0;
  }
}

//----- (004A5282) --------------------------------------------------------
void __fastcall CPed::SetAmmo(CPed *this, eWeaponType weaponType, UInt32 ammoQuantity)
{
  int32 m_nWeaponSlot; // r0
  signed int v6; // r1
  int (***v7)(void); // r0
  signed int v8; // r3
  int (**v9)(void); // r2

  m_nWeaponSlot = CWeaponInfo::GetWeaponInfo(weaponType, 1)->m_nWeaponSlot;
  if ( m_nWeaponSlot != -1 )
  {
    v6 = 99999;
    v7 = &this->_vptr$CPlaceable + 7 * m_nWeaponSlot;
    v8 = (signed int)v7[363];
    v9 = v7[362];
    if ( (int)ammoQuantity < 99999 )
      v6 = ammoQuantity;
    if ( v6 < v8 )
      v8 = v6;
    v7[363] = (int (**)(void))v8;
    v7[364] = (int (**)(void))v6;
    if ( v9 == (int (**)(void))((char *)&dword_0 + 3) && (int)ammoQuantity >= 1 )
      v7[362] = 0;
  }
}
// 0: using guessed type int dword_0;

//----- (004A52D8) --------------------------------------------------------
void __fastcall CPed::ClearWeapon(CPed *this, eWeaponType weaponType)
{
  int32 m_nWeaponSlot; // r0
  char *v5; // r1
  CWeapon *v6; // r6
  CWeaponInfo *WeaponInfo; // r0

  m_nWeaponSlot = CWeaponInfo::GetWeaponInfo(weaponType, 1)->m_nWeaponSlot;
  if ( m_nWeaponSlot != -1 )
  {
    v5 = (char *)this + 28 * m_nWeaponSlot;
    if ( *((_DWORD *)v5 + 361) == weaponType )
    {
      v6 = (CWeapon *)(v5 + 1444);
      if ( m_nWeaponSlot == this->m_nCurrentWeapon )
      {
        WeaponInfo = CWeaponInfo::GetWeaponInfo(WEAPONTYPE_UNARMED, 1);
        CPed::SetCurrentWeapon(this, WeaponInfo->m_nWeaponSlot);
      }
      CWeapon::Shutdown(v6);
      if ( (weaponType | 1) == 45 )
        CPed::RemoveGogglesModel(this);
    }
  }
}

//----- (004A533E) --------------------------------------------------------
bool __fastcall CPed::DoWeHaveWeaponAvailable(CPed *this, eWeaponType weaponType)
{
  int32 m_nWeaponSlot; // r0

  m_nWeaponSlot = CWeaponInfo::GetWeaponInfo(weaponType, 1)->m_nWeaponSlot;
  return m_nWeaponSlot != -1 && this->m_WeaponSlots[m_nWeaponSlot].m_eWeaponType == weaponType;
}

//----- (004A536C) --------------------------------------------------------
void __fastcall CPed::RemoveWeaponWhenEnteringVehicle(CPed *this, int32 nVehicleType)
{
  CPlayerPedData *m_pPlayerData; // r0
  eWeaponType m_eWeaponType; // r0
  bool v6; // zf
  int v7; // r0
  int m_nWeaponSlot; // r1
  int32 m_modelId; // r1

  m_pPlayerData = this->m_pPlayerData;
  if ( m_pPlayerData )
    *((_WORD *)m_pPlayerData + 26) |= 0x800u;
  if ( this->m_eStoredWeapon == WEAPONTYPE_UNIDENTIFIED )
  {
    if ( this->m_nPedType <= 1u && CPlayerPed::GetPlayerInfoForThisPlayerPed((CPlayerPed *)this)->bCanDoDriveBy )
    {
      m_eWeaponType = this->m_WeaponSlots[4].m_eWeaponType;
      v6 = m_eWeaponType == WEAPONTYPE_MICRO_UZI;
      if ( m_eWeaponType != WEAPONTYPE_MICRO_UZI )
        v6 = m_eWeaponType == WEAPONTYPE_TEC9;
      if ( (v6 || nVehicleType != 1 && m_eWeaponType == WEAPONTYPE_MP5) && this->m_WeaponSlots[4].m_nAmmoTotal > 0 )
      {
        v7 = 4;
LABEL_19:
        if ( this->m_eStoredWeapon == WEAPONTYPE_UNIDENTIFIED )
          this->m_eStoredWeapon = this->m_WeaponSlots[this->m_nCurrentWeapon].m_eWeaponType;
        m_nWeaponSlot = CWeaponInfo::GetWeaponInfo(this->m_WeaponSlots[v7].m_eWeaponType, 1)->m_nWeaponSlot;
        CPed::SetCurrentWeapon(this, m_nWeaponSlot);
        return;
      }
      if ( nVehicleType == 1
        && (this->m_WeaponSlots[3].m_eWeaponType == WEAPONTYPE_SAWNOFF_SHOTGUN
         && this->m_WeaponSlots[3].m_nAmmoTotal > 0
         || this->m_WeaponSlots[2].m_eWeaponType == WEAPONTYPE_PISTOL && this->m_WeaponSlots[2].m_nAmmoTotal >= 1) )
      {
        v7 = 2;
        goto LABEL_19;
      }
    }
    m_modelId = CWeaponInfo::GetWeaponInfo(this->m_WeaponSlots[this->m_nCurrentWeapon].m_eWeaponType, 1)->m_modelId;
    CPed::RemoveWeaponModel(this, m_modelId);
  }
}

//----- (004A5442) --------------------------------------------------------
void __fastcall CPed::ReplaceWeaponWhenExitingVehicle(CPed *this)
{
  CPlayerPedData *m_pPlayerData; // r0
  eWeaponType m_eStoredWeapon; // r0
  int32 m_modelId; // r1
  CWeaponInfo *WeaponInfo; // r0

  m_pPlayerData = this->m_pPlayerData;
  if ( m_pPlayerData )
    *((_WORD *)m_pPlayerData + 26) &= ~0x800u;
  if ( this->m_nPedType > 1u || (m_eStoredWeapon = this->m_eStoredWeapon, m_eStoredWeapon == WEAPONTYPE_UNIDENTIFIED) )
  {
    m_modelId = CWeaponInfo::GetWeaponInfo(this->m_WeaponSlots[this->m_nCurrentWeapon].m_eWeaponType, 1)->m_modelId;
    CPed::AddWeaponModel(this, m_modelId);
  }
  else
  {
    WeaponInfo = CWeaponInfo::GetWeaponInfo(m_eStoredWeapon, 1);
    CPed::SetCurrentWeapon(this, WeaponInfo->m_nWeaponSlot);
    this->m_eStoredWeapon = WEAPONTYPE_UNIDENTIFIED;
  }
}

//----- (004A549E) --------------------------------------------------------
void __fastcall CPed::RemoveWeaponForScriptedCutscene(CPed *this)
{
  this->m_eStoredWeapon = this->m_WeaponSlots[this->m_nCurrentWeapon].m_eWeaponType;
  CPed::SetCurrentWeapon(this, 0);
}

//----- (004A54B6) --------------------------------------------------------
void __fastcall CPed::ReplaceWeaponForScriptedCutscene(CPed *this)
{
  eWeaponType m_eStoredWeapon; // r0
  CWeaponInfo *WeaponInfo; // r0

  m_eStoredWeapon = this->m_eStoredWeapon;
  if ( m_eStoredWeapon != WEAPONTYPE_UNIDENTIFIED )
  {
    WeaponInfo = CWeaponInfo::GetWeaponInfo(m_eStoredWeapon, 1);
    CPed::SetCurrentWeapon(this, WeaponInfo->m_nWeaponSlot);
    this->m_eStoredWeapon = WEAPONTYPE_UNIDENTIFIED;
  }
}

//----- (004A54DC) --------------------------------------------------------
bool __fastcall CPed::DoGunFlash(CPed *this, int32 nDuration, bool bLHand)
{
  RpClump_0 *m_pWeaponClump; // r0
  bool v5; // zf
  int v6; // r0
  int v8; // r0

  m_pWeaponClump = this->m_pWeaponClump;
  v5 = m_pWeaponClump == 0;
  if ( m_pWeaponClump )
    v5 = this->m_pWeaponFlashFrame == 0;
  if ( v5 )
    return 0;
  v6 = CPed::m_sGunFlashBlendStart;
  if ( bLHand )
  {
    this->m_nGunFlashBlendAmount2 = CPed::m_sGunFlashBlendStart;
    this->m_nGunFlashBlendOutRate2 = v6 / nDuration;
  }
  else
  {
    this->m_nGunFlashBlendAmount = CPed::m_sGunFlashBlendStart;
    this->m_nGunFlashBlendOutRate = v6 / nDuration;
  }
  v8 = rand();
  RwMatrixRotate(
    &this->m_pWeaponFlashFrame->modelling,
    &CPedIK::XaxisIK,
    (float)((float)((float)v8 * 4.6566e-10) * 720.0) + -360.0,
    rwCOMBINEPRECONCAT);
  return 1;
}

//----- (004A5574) --------------------------------------------------------
void __fastcall CPed::SetGunFlashAlpha(CPed *this, bool bLHand)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  _BOOL4 v4; // r4
  int16 *p_m_nGunFlashBlendAmount; // r6
  RwFrame_0 *m_pWeaponFlashFrame; // r0
  int16 *p_m_nGunFlashBlendAmount2; // r5
  int16 *v9; // r1
  int v10; // r10
  int v11; // r1
  bool v12; // cc
  RpAtomic_0 *FirstObject; // r0
  RpAtomic_0 *v14; // r8
  int32 v15; // r1

  v4 = bLHand;
  p_m_nGunFlashBlendAmount = &this->m_nGunFlashBlendAmount;
  m_pWeaponFlashFrame = this->m_pWeaponFlashFrame;
  p_m_nGunFlashBlendAmount2 = &this->m_nGunFlashBlendAmount2;
  v9 = p_m_nGunFlashBlendAmount;
  if ( v4 )
    v9 = p_m_nGunFlashBlendAmount2;
  if ( m_pWeaponFlashFrame )
  {
    v10 = *v9;
    v11 = *p_m_nGunFlashBlendAmount;
    v12 = v11 <= -1;
    if ( v11 <= -1 )
      v12 = *p_m_nGunFlashBlendAmount2 <= -1;
    if ( !v12 )
    {
      FirstObject = (RpAtomic_0 *)GetFirstObject(m_pWeaponFlashFrame);
      v14 = FirstObject;
      if ( FirstObject )
      {
        v2.n64_u32[0] = 1132396544;
        v3.n64_f32[0] = (float)(350 * (__int16)v10 / CPed::m_sGunFlashBlendStart);
        v15 = (int)vmin_f32(v3, v2).n64_f32[0];
        if ( v10 < 1 )
          v15 = 0;
        CVehicle::SetComponentAtomicAlpha(FirstObject, v15);
        v14->object.object.flags = 4;
      }
      if ( v4 )
      {
        if ( !*p_m_nGunFlashBlendAmount2 )
          *p_m_nGunFlashBlendAmount2 = -1;
      }
      else if ( !*p_m_nGunFlashBlendAmount )
      {
        *p_m_nGunFlashBlendAmount = -1;
      }
    }
  }
}
// 4A55E2: variable 'v3' is possibly undefined
// 4A55E2: variable 'v2' is possibly undefined

//----- (004A562C) --------------------------------------------------------
void __fastcall CPed::ResetGunFlashAlpha(CPed *this)
{
  RwFrame_0 *m_pWeaponFlashFrame; // r0
  RpAtomic_0 *FirstObject; // r0

  m_pWeaponFlashFrame = this->m_pWeaponFlashFrame;
  if ( m_pWeaponFlashFrame )
  {
    FirstObject = (RpAtomic_0 *)GetFirstObject(m_pWeaponFlashFrame);
    if ( FirstObject )
    {
      FirstObject->object.object.flags = 0;
      sub_196CD8(FirstObject, 0);
    }
  }
}

//----- (004A5652) --------------------------------------------------------
int8 __fastcall CPed::GetWeaponSkill(CPed *this, eWeaponType weaponType)
{
  unsigned int m_nPedType; // r1
  UInt16 SkillStatIndex; // r8
  float StatValue; // r6
  int8 v6; // r5
  float v7; // s2
  bool v8; // zf

  if ( (unsigned int)(weaponType - 22) > 0xA )
    return 1;
  m_nPedType = this->m_nPedType;
  if ( m_nPedType > 1 )
  {
    v8 = weaponType == WEAPONTYPE_PISTOL;
    if ( weaponType == WEAPONTYPE_PISTOL )
      v8 = m_nPedType == 6;
    if ( v8 )
      return 3;
    else
      return this->m_nWeaponSkill;
  }
  else
  {
    SkillStatIndex = CWeaponInfo::GetSkillStatIndex(weaponType);
    StatValue = CStats::GetStatValue(SkillStatIndex);
    v6 = 2;
    if ( StatValue < (float)CWeaponInfo::GetWeaponInfo(weaponType, 2)->m_nReqStatLevel )
    {
      v7 = CStats::GetStatValue(SkillStatIndex);
      return v7 >= (float)CWeaponInfo::GetWeaponInfo(weaponType, 1)->m_nReqStatLevel;
    }
  }
  return v6;
}

//----- (004A56E6) --------------------------------------------------------
void __fastcall CPed::SetWeaponSkill(CPed *this, eWeaponType weaponType, int8 weaponSkill)
{
  if ( this->m_nPedType >= 2u )
    this->m_nWeaponSkill = weaponSkill;
}

//----- (004A56F4) --------------------------------------------------------
float __fastcall CPed::GetBikeRidingSkill(CPed *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float result; // r0
  float v4; // s0

  if ( this->m_pPlayerData )
  {
    v1.n64_f32[0] = CStats::GetStatValue(0xE5u) / 1000.0;
    v2.n64_u32[0] = 1.0;
    LODWORD(result) = vmin_f32(v1, v2).n64_u32[0];
  }
  else
  {
    v4 = 0.0;
    if ( this->CharCreatedBy == 2 )
      return 1.0;
    return v4;
  }
  return result;
}
// 4A5714: variable 'v1' is possibly undefined
// 4A5714: variable 'v2' is possibly undefined

//----- (004A5740) --------------------------------------------------------
void __fastcall CPed::ShoulderBoneRotation(RpClump_0 *pClump)
{
  RpHAnimHierarchy_0 *AnimHierarchyFromSkinClump; // r6
  RwInt32 v2; // r8
  RwMatrix *MatrixArray; // r5
  RwInt32 v4; // r4
  RwMatrix *v5; // r0
  __int64 v6; // d16
  __int64 v7; // d17
  __int64 v8; // d18
  __int64 v9; // d19
  __int64 *p_at; // r1
  __int64 v11; // d20
  __int64 v12; // d21
  RwMatrix *v13; // r1
  __int64 v14; // d23
  RwInt32 v15; // r5
  RwMatrix *v16; // r0
  RwInt32 v17; // r5
  RwMatrix *v18; // r10
  RwInt32 v19; // r11
  RwMatrix *v20; // r0
  __int64 v21; // d17
  RwMatrix *v22; // r1
  __int64 v23; // d17
  __int64 v24; // d16
  __int64 v25; // d17
  __int64 v26; // d17
  RwInt32 v27; // r5
  RwMatrix *v28; // r0
  CMatrix v29; // [sp+4h] [bp-154h] BYREF
  CMatrix v30; // [sp+4Ch] [bp-10Ch] BYREF
  CMatrix v31; // [sp+94h] [bp-C4h] BYREF
  CMatrix v32; // [sp+DCh] [bp-7Ch] BYREF
  float z; // [sp+124h] [bp-34h] BYREF
  float y; // [sp+128h] [bp-30h] BYREF
  float x[11]; // [sp+12Ch] [bp-2Ch] BYREF

  AnimHierarchyFromSkinClump = GetAnimHierarchyFromSkinClump(pClump);
  v2 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, 302);
  MatrixArray = RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump);
  v4 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, 32);
  v5 = &RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump)[v4];
  v6 = *(_QWORD *)&v5->right.x;
  v7 = *(_QWORD *)&v5->right.z;
  v8 = *(_QWORD *)&v5->up.x;
  v9 = *(_QWORD *)&v5->up.z;
  p_at = (__int64 *)&v5->at;
  v5 = (RwMatrix *)((char *)v5 + 48);
  v11 = *p_at;
  v12 = p_at[1];
  v13 = &MatrixArray[v2];
  v14 = *(_QWORD *)&v5->right.z;
  *(_QWORD *)&v13->pos.x = *(_QWORD *)&v5->right.x;
  *(_QWORD *)&v13->pos.z = v14;
  *(_QWORD *)&v13->at.x = v11;
  *(_QWORD *)&v13->at.z = v12;
  *(_QWORD *)&v13->right.x = v6;
  *(_QWORD *)&v13->right.z = v7;
  *(_QWORD *)&v13->up.x = v8;
  *(_QWORD *)&v13->up.z = v9;
  CMatrix::CMatrix(&v32, v13, 0);
  v15 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, 31);
  v16 = RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump);
  CMatrix::CMatrix(&v31, &v16[v15], 0);
  Invert(&v30, &v31);
  operator*(&v29, &v30, &v32);
  CMatrix::operator=(&v32, &v29);
  CMatrix::~CMatrix(&v29);
  CMatrix::ConvertToEulerAngles(&v32, x, &y, &z, 21);
  x[0] = x[0] * 0.5;
  CMatrix::ConvertFromEulerAngles(&v32, x[0], y, z, 21);
  operator*(&v29, &v31, &v32);
  CMatrix::operator=(&v32, &v29);
  CMatrix::~CMatrix(&v29);
  CMatrix::UpdateRW(&v32);
  v17 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, 301);
  v18 = RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump);
  v19 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, 22);
  v20 = &RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump)[v19];
  v21 = *(_QWORD *)&v20->pos.z;
  v22 = &v18[v17];
  *(_QWORD *)&v22->pos.x = *(_QWORD *)&v20->pos.x;
  *(_QWORD *)&v22->pos.z = v21;
  v23 = *(_QWORD *)&v20->at.z;
  *(_QWORD *)&v22->at.x = *(_QWORD *)&v20->at.x;
  *(_QWORD *)&v22->at.z = v23;
  v24 = *(_QWORD *)&v20->right.x;
  v25 = *(_QWORD *)&v20->right.z;
  v20 = (RwMatrix *)((char *)v20 + 16);
  *(_QWORD *)&v22->right.x = v24;
  *(_QWORD *)&v22->right.z = v25;
  v26 = *(_QWORD *)&v20->right.z;
  *(_QWORD *)&v22->up.x = *(_QWORD *)&v20->right.x;
  *(_QWORD *)&v22->up.z = v26;
  CMatrix::Attach(&v32, v22, 0);
  v27 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, 21);
  v28 = RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump);
  CMatrix::Attach(&v31, &v28[v27], 0);
  Invert(&v29, &v31);
  CMatrix::operator=(&v30, &v29);
  CMatrix::~CMatrix(&v29);
  operator*(&v29, &v30, &v32);
  CMatrix::operator=(&v32, &v29);
  CMatrix::~CMatrix(&v29);
  CMatrix::ConvertToEulerAngles(&v32, x, &y, &z, 21);
  x[0] = x[0] * 0.5;
  CMatrix::ConvertFromEulerAngles(&v32, x[0], y, z, 21);
  operator*(&v29, &v31, &v32);
  CMatrix::operator=(&v32, &v29);
  CMatrix::~CMatrix(&v29);
  CMatrix::UpdateRW(&v32);
  CMatrix::~CMatrix(&v30);
  CMatrix::~CMatrix(&v31);
  CMatrix::~CMatrix(&v32);
}

//----- (004A5972) --------------------------------------------------------
void __fastcall CPed::PreRender(CPed *this)
{
  if ( this->m_nPedState != PED_DRIVING )
    CPed::PreRenderAfterTest(this);
}

//----- (004A5980) --------------------------------------------------------
void __fastcall CPed::PreRenderAfterTest(CPed *this)
{
  CTaskSimpleSwim *TaskSwim; // r1
  CPedIntelligence *m_pPedIntelligence; // r0
  CTaskSimpleSwim *v4; // r0
  CTaskSimpleJetPack *TaskJetPack; // r0
  CTaskSimpleInAir *TaskInAir; // r0
  CPedFlags *p_m_nPedFlags; // r11
  RpClump_0 *m_pWeaponClump; // r0
  bool v9; // zf
  RwFrame_0 *FrameFromName; // r0
  CTaskManager *p_m_taskManager; // r0
  CTask *ActiveTaskByType; // r8
  int v13; // r6
  _BOOL4 v14; // r4
  bool v15; // zf
  RpHAnimHierarchy_0 *AnimHierarchyFromSkinClump; // r0
  RpHAnimHierarchy_0 *v17; // r5
  RwInt32 v18; // r4
  RwMatrix *v19; // r0
  float x; // s0
  float y; // s2
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  CSimpleTransform *p_m_transform; // r2
  int v25; // r0
  int32 value; // r1
  int v27; // r4
  float z; // s0
  CVehicle *m_pMyVehicle; // r2
  unsigned int m_vehicleType; // r2
  bool v31; // zf
  unsigned int v32; // r1
  RpHAnimHierarchy_0 *v33; // r0
  RpHAnimHierarchy_0 *v34; // r5
  RwInt32 v35; // r6
  CMatrix *v36; // r0
  CSimpleTransform *v37; // r1
  CMatrix *v38; // r0
  CSimpleTransform *v39; // r1
  RpHAnimHierarchy_0 *v40; // r5
  CMatrix *v41; // r0
  CSimpleTransform *v42; // r2
  int v43; // r6
  CVehicle *v44; // r0
  int32 m_baseVehicleType; // r1
  _BOOL4 v46; // r9
  CPlayerPedData *m_pPlayerData; // r0
  uint32 v48; // r4
  uint32 v49; // r4
  CVehicle *v50; // r0
  float v51; // s22
  float v52; // s0
  float v53; // s16
  float v54; // s20
  RwInt32 v55; // r6
  RwMatrix *MatrixArray; // r0
  float v57; // s0
  float v58; // s22
  float v59; // s24
  RwInt32 v60; // r6
  RwMatrix *v61; // r0
  RwInt32 v62; // r6
  RwMatrix *v63; // r0
  RwInt32 v64; // r6
  RwMatrix *v65; // r0
  RwInt32 v66; // r6
  RwMatrix *v67; // r0
  RwInt32 v68; // r4
  RwMatrix *v69; // r0
  RwInt32 v70; // r4
  RwMatrix *v71; // r0
  RwInt32 v72; // r4
  RwMatrix *v73; // r0
  RwInt32 v74; // r4
  RwMatrix *v75; // r0
  RwInt32 v76; // r4
  RwMatrix *v77; // r0
  float m_wobble; // s0
  float v79; // s18
  float v80; // r0
  float v81; // s16
  RwInt32 v82; // r4
  RwMatrix *v83; // r0
  RwInt32 v84; // r4
  RwMatrix *v85; // r0
  RwInt32 v86; // r4
  RwMatrix *v87; // r0
  float v88; // s16
  float v89; // s0
  RwInt32 v90; // r4
  RwMatrix *v91; // r0
  RwInt32 v92; // r4
  RwMatrix *v93; // r0
  RwInt32 v94; // r4
  RwMatrix *v95; // r0
  RwInt32 v96; // r4
  RwMatrix *v97; // r0
  RwInt32 v98; // r4
  RwMatrix *v99; // r0
  RwInt32 v100; // r4
  RwMatrix *v101; // r0
  RwInt32 v102; // r4
  RwMatrix *v103; // r0
  RwInt32 v104; // r4
  RwMatrix *v105; // r0
  RwInt32 v106; // r4
  RwMatrix *v107; // r0
  RwInt32 v108; // r4
  RwMatrix *v109; // r0
  RwInt32 v110; // r4
  RwMatrix *v111; // r0
  RpHAnimHierarchy_0 *v112; // r4
  RwInt32 v113; // r5
  RwMatrix *v114; // r0
  __int64 v115; // d16
  CMatrix *v116; // r0
  float zz; // s6
  RwReal v118; // s2
  CMatrix *v119; // r0
  CSimpleTransform *v120; // r4
  CSimpleTransform *v121; // r1
  CMatrix *v122; // r1
  CSimpleTransform *v123; // r1
  float32x2_t v124; // d16
  unsigned __int64 v125; // d1
  CPedModelInfo *v126; // r4
  CColModel *m_pHitColModel; // r4
  const CVector *PlayerSpeed; // r0
  float v129; // s20
  float v130; // s18
  float v131; // s16
  ePedState m_nPedState; // r0
  CPlayerPedData *v133; // r0
  CMatrix *v134; // r0
  CSimpleTransform *v135; // r1
  __int64 v136; // d16
  CVehicle *v137; // r0
  int m_nNoOfSpheres; // r6
  int v139; // r8
  float v140; // s16
  float v141; // s18
  float v142; // s20
  CColSphere *m_pSphereArray; // r5
  unsigned int v144; // r0
  int v145; // r5
  __int64 v146; // d16
  float v147; // s0
  _BOOL4 v148; // [sp+18h] [bp-A8h]
  _BOOL4 v149; // [sp+18h] [bp-A8h]
  CCollisionData *m_pColData; // [sp+18h] [bp-A8h]
  RwV3d_0 vel; // [sp+1Ch] [bp-A4h] BYREF
  FxPrtMult_c pos; // [sp+28h] [bp-98h] BYREF
  CVector dir; // [sp+48h] [bp-78h] BYREF
  RwV3d_0 axis; // [sp+58h] [bp-68h] BYREF
  float pX[23]; // [sp+64h] [bp-5Ch] BYREF

  TaskSwim = CPedIntelligence::GetTaskSwim(this->m_pPedIntelligence);
  m_pPedIntelligence = this->m_pPedIntelligence;
  if ( TaskSwim )
  {
    v4 = CPedIntelligence::GetTaskSwim(m_pPedIntelligence);
    CTaskSimpleSwim::ApplyRollAndPitch(v4, this);
LABEL_5:
    this->m_ik.m_flags &= ~8u;
    goto LABEL_6;
  }
  if ( CPedIntelligence::GetTaskJetPack(m_pPedIntelligence) )
  {
    TaskJetPack = CPedIntelligence::GetTaskJetPack(this->m_pPedIntelligence);
    CTaskSimpleJetPack::ApplyRollAndPitch(TaskJetPack, this);
    goto LABEL_5;
  }
LABEL_6:
  if ( CPedIntelligence::GetTaskInAir(this->m_pPedIntelligence) )
  {
    TaskInAir = CPedIntelligence::GetTaskInAir(this->m_pPedIntelligence);
    CTaskSimpleInAir::ApplyRollAndPitch(TaskInAir, this);
    this->m_ik.m_flags &= ~8u;
  }
  else if ( (this->m_ik.m_flags & 8) != 0 || this->m_nPedType >= 2u && this->m_ik.m_fSlopePitch != 0.0 )
  {
    CPedIK::PitchForSlope(&this->m_ik);
  }
  *((_DWORD *)&this->m_nPedFlags + 2) |= 0x400u;
  CEntity::UpdateRpHAnim(this);
  p_m_nPedFlags = &this->m_nPedFlags;
  if ( !CTimer::bSkipProcessThisFrame )
  {
    m_pWeaponClump = this->m_pWeaponClump;
    v9 = m_pWeaponClump == 0;
    if ( m_pWeaponClump )
      v9 = this->m_pPlayerData == 0;
    if ( !v9 && this->m_WeaponSlots[this->m_nCurrentWeapon].m_eWeaponType == WEAPONTYPE_MINIGUN )
    {
      FrameFromName = CClumpModelInfo::GetFrameFromName(m_pWeaponClump, "minigun2");
      if ( FrameFromName )
        RwMatrixRotate(
          &FrameFromName->modelling,
          &CPedIK::XaxisIK,
          (float)((float)(this->m_pPlayerData->m_fGunSpinSpeed * CTimer::ms_fTimeStep) * 180.0) / 3.1416,
          rwCOMBINEPRECONCAT);
    }
  }
  if ( (*(_BYTE *)&this->m_nFlags & 0x80) != 0
    && (CTimeCycle::m_CurrentColours.m_nShadowStrength || CPostEffects::IsVisionFXActive()) )
  {
    p_m_taskManager = &this->m_pPedIntelligence->m_taskManager;
    if ( *((unsigned __int8 *)&this->m_nPedFlags + 1) << 31 )
    {
      if ( CTaskManager::FindActiveTaskByType(p_m_taskManager, 704) )
      {
        ActiveTaskByType = 0;
        v14 = 1;
      }
      else
      {
        v14 = CTaskManager::FindActiveTaskByType(&this->m_pPedIntelligence->m_taskManager, 703) != 0;
        ActiveTaskByType = 0;
      }
      v13 = 0;
    }
    else
    {
      ActiveTaskByType = CTaskManager::FindActiveTaskByType(p_m_taskManager, 701);
      v13 = (int)ActiveTaskByType;
      v14 = 0;
      if ( ActiveTaskByType )
        v13 = 1;
    }
    v15 = MobileSettings::settings[5].value == 2;
    if ( MobileSettings::settings[5].value != 2 )
      v15 = this->m_nPedType == 0;
    if ( !v15 || this->m_areaCode )
      goto LABEL_35;
    if ( (*((_DWORD *)&this->m_nPedFlags + 2) & 0x400) != 0 )
    {
      AnimHierarchyFromSkinClump = GetAnimHierarchyFromSkinClump((RpClump_0 *)this->m_pRwObject);
      v17 = AnimHierarchyFromSkinClump;
      if ( AnimHierarchyFromSkinClump )
      {
        v148 = v14;
        v18 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, 0);
        v19 = &RpHAnimHierarchyGetMatrixArray(v17)[v18];
        v14 = v148;
        x = v19->pos.x;
        y = v19->pos.y;
      }
      else
      {
        m_pMat = this->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &this->m_transform;
        x = p_tx->m_translate.x;
        y = p_tx->m_translate.y;
      }
    }
    else
    {
      operator*((CVector *)&pos, this->m_pMat, aStdBonePosisions);
      x = pos.m_red;
      y = pos.m_green;
    }
    p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
    if ( !TheCamera.m_pMat )
      p_m_transform = &TheCamera.m_transform;
    if ( (float)((float)((float)(x - p_m_transform->m_translate.x) * (float)(x - p_m_transform->m_translate.x))
               + (float)((float)(y - p_m_transform->m_translate.y) * (float)(y - p_m_transform->m_translate.y))) <= MAX_DISTANCE_PED_SHADOWS_SQR
      && !(*((unsigned __int8 *)&this->m_nPhysicalFlags + 1) << 31) )
    {
      v25 = *((_DWORD *)&this->m_nPedFlags + 2);
      v149 = v14;
      value = MobileSettings::settings[5].value;
      if ( (*(_DWORD *)p_m_nPedFlags & 0x100) != 0 )
      {
        if ( v14 && MobileSettings::settings[5].value == 2 )
        {
          v27 = 1;
          if ( (v25 & 0x400) != 0 )
            goto LABEL_68;
          goto LABEL_55;
        }
        m_pMyVehicle = this->m_pMyVehicle;
        v27 = 0;
        if ( m_pMyVehicle )
        {
          m_vehicleType = m_pMyVehicle->m_vehicleType;
          if ( m_vehicleType <= 0xA && ((1 << m_vehicleType) & 0x604) != 0 )
            v27 = 1;
        }
        if ( !v13 )
        {
LABEL_67:
          if ( (v25 & 0x400) != 0 )
          {
LABEL_68:
            v33 = GetAnimHierarchyFromSkinClump((RpClump_0 *)this->m_pRwObject);
            v34 = v33;
            if ( v33 )
            {
              v35 = RpHAnimIDGetIndex(v33, 3);
              z = RpHAnimHierarchyGetMatrixArray(v34)[v35].pos.z;
            }
            else
            {
              v36 = this->m_pMat;
              v37 = (CSimpleTransform *)&v36->tx;
              if ( !v36 )
                v37 = &this->m_transform;
              z = v37->m_translate.z;
            }
LABEL_73:
            if ( MobileSettings::settings[5].value != 2 )
            {
              if ( (this->m_nPedState & 0xFFFFFFFE) == 54 )
                goto LABEL_78;
              v38 = this->m_pMat;
              v39 = (CSimpleTransform *)&v38->tx;
              if ( !v38 )
                v39 = &this->m_transform;
              if ( z < (float)(v39->m_translate.z + -0.2) )
LABEL_78:
                v27 = (*(_DWORD *)p_m_nPedFlags >> 26) & 1;
            }
            v9 = v27 == 0;
            v14 = v149;
            if ( !v9 )
            {
              CRealTimeShadowManager::DoShadowThisFrame(&g_realTimeShadowMan, this);
              if ( !this->m_pRealTimeShadow )
              {
LABEL_35:
                if ( v14 || (*(_DWORD *)p_m_nPedFlags & 0x100) == 0 )
                  CShadows::StoreShadowForPedObject(
                    this,
                    CTimeCycle::m_fShadowDisplacementX[CTimeCycle::m_CurrentStoredValue],
                    CTimeCycle::m_fShadowDisplacementY[CTimeCycle::m_CurrentStoredValue],
                    CTimeCycle::m_fShadowFrontX[CTimeCycle::m_CurrentStoredValue],
                    CTimeCycle::m_fShadowFrontY[CTimeCycle::m_CurrentStoredValue],
                    CTimeCycle::m_fShadowSideX[CTimeCycle::m_CurrentStoredValue],
                    CTimeCycle::m_fShadowSideY[CTimeCycle::m_CurrentStoredValue]);
                goto LABEL_81;
              }
            }
            goto LABEL_81;
          }
LABEL_55:
          operator*((CVector *)&pos, this->m_pMat, &aStdBonePosisions[3]);
          z = pos.m_blue;
          goto LABEL_73;
        }
      }
      else
      {
        v27 = 1;
        if ( !v13 )
          goto LABEL_67;
      }
      v31 = MobileSettings::settings[5].value == 2;
      if ( MobileSettings::settings[5].value != 2 )
      {
        value = (int32)ActiveTaskByType[1].m_pParent;
        v27 = 0;
        v31 = value == 0;
      }
      if ( !v31 )
      {
        v32 = *(_DWORD *)(value + 1444);
        if ( v32 <= 0xA && ((1 << v32) & 0x604) != 0 )
          v27 = 1;
      }
      goto LABEL_67;
    }
  }
LABEL_81:
  if ( !this->m_nModelIndex )
  {
    CPed::ShoulderBoneRotation((RpClump_0 *)this->m_pRwObject);
    *(_DWORD *)&this->m_nFlags |= 0x800000u;
  }
  v40 = GetAnimHierarchyFromSkinClump((RpClump_0 *)this->m_pRwObject);
  pX[0] = 1.0;
  if ( this->m_nPedType > 1u )
    goto LABEL_88;
  v41 = this->m_pMat;
  v42 = (CSimpleTransform *)&v41->tx;
  if ( !v41 )
    v42 = &this->m_transform;
  if ( CWindModifiers::FindWindModifier(v42->m_translate, pX, pX) == 1 )
    v43 = CCullZones::PlayerNoRain() ^ 1;
  else
LABEL_88:
    v43 = 0;
  v46 = 0;
  if ( this->m_nPedState == PED_DRIVING )
  {
    v44 = this->m_pMyVehicle;
    if ( v44 )
    {
      m_baseVehicleType = v44->m_baseVehicleType;
      if ( m_baseVehicleType == 9
        || !m_baseVehicleType && (*((int (__fastcall **)(CVehicle *))v44->_vptr$CPlaceable + 40))(v44) == 1 )
      {
        v46 = 1;
      }
    }
  }
  m_pPlayerData = this->m_pPlayerData;
  if ( m_pPlayerData )
  {
    v48 = m_pPlayerData->m_pClothes->modelsKeyArray[0];
    if ( v48 == CKeyGen::GetUppercaseKey("vest")
      || (v49 = this->m_pPlayerData->m_pClothes->modelsKeyArray[0], v49 == CKeyGen::GetUppercaseKey("torso")) )
    {
      v46 = 0;
      v43 = 0;
    }
  }
  if ( v46 || v43 == 1 )
  {
    if ( v46 )
    {
      v50 = this->m_pMyVehicle;
      v51 = (float)((float)(v50->m_vecMoveSpeed.x * v50->m_pMat->xy) + (float)(v50->m_vecMoveSpeed.y * v50->m_pMat->yy))
          + (float)(v50->m_vecMoveSpeed.z * v50->m_pMat->zy);
      if ( v43 != 1 )
      {
LABEL_108:
        v53 = 1.0 - (float)(v51 * 0.2);
        v54 = (float)((float)(v51 * 0.2) + 1.0) - v53;
        pos.m_red = v53 + (float)(v54 * (float)((float)rand() * 4.6566e-10));
        pos.m_green = v53 + (float)(v54 * (float)((float)rand() * 4.6566e-10));
        pos.m_blue = v53 + (float)(v54 * (float)((float)rand() * 4.6566e-10));
        v55 = RpHAnimIDGetIndex(v40, 4);
        MatrixArray = RpHAnimHierarchyGetMatrixArray(v40);
        RwMatrixScale(&MatrixArray[v55], (const RwV3d_0 *)&pos, rwCOMBINEPRECONCAT);
        v57 = v51 * 0.1;
        v58 = 1.0 - (float)(v51 * 0.1);
        v59 = (float)(v57 + 1.0) - v58;
        pos.m_red = v58 + (float)(v59 * (float)((float)rand() * 4.6566e-10));
        pos.m_green = v58 + (float)(v59 * (float)((float)rand() * 4.6566e-10));
        pos.m_blue = v58 + (float)(v59 * (float)((float)rand() * 4.6566e-10));
        v60 = RpHAnimIDGetIndex(v40, 31);
        v61 = RpHAnimHierarchyGetMatrixArray(v40);
        RwMatrixScale(&v61[v60], (const RwV3d_0 *)&pos, rwCOMBINEPRECONCAT);
        v62 = RpHAnimIDGetIndex(v40, 21);
        v63 = RpHAnimHierarchyGetMatrixArray(v40);
        RwMatrixScale(&v63[v62], (const RwV3d_0 *)&pos, rwCOMBINEPRECONCAT);
        if ( v46 || !CPedIntelligence::GetTaskJetPack(this->m_pPedIntelligence) )
        {
          v64 = RpHAnimIDGetIndex(v40, 3);
          v65 = RpHAnimHierarchyGetMatrixArray(v40);
          RwMatrixScale(&v65[v64], (const RwV3d_0 *)&pos, rwCOMBINEPRECONCAT);
        }
        pos.m_red = v53 + (float)(v54 * (float)((float)rand() * 4.6566e-10));
        pos.m_green = v53 + (float)(v54 * (float)((float)rand() * 4.6566e-10));
        pos.m_blue = v53 + (float)(v54 * (float)((float)rand() * 4.6566e-10));
        v66 = RpHAnimIDGetIndex(v40, 32);
        v67 = RpHAnimHierarchyGetMatrixArray(v40);
        RwMatrixScale(&v67[v66], (const RwV3d_0 *)&pos, rwCOMBINEPRECONCAT);
        v68 = RpHAnimIDGetIndex(v40, 22);
        v69 = RpHAnimHierarchyGetMatrixArray(v40);
        RwMatrixScale(&v69[v68], (const RwV3d_0 *)&pos, rwCOMBINEPRECONCAT);
        goto LABEL_112;
      }
    }
    else
    {
      v51 = 0.0;
      if ( v43 != 1 )
        goto LABEL_108;
    }
    v52 = fabsf(pX[0] + -1.0);
    if ( v52 > v51 )
      v51 = v52;
    goto LABEL_108;
  }
LABEL_112:
  if ( (*((_BYTE *)&this->m_nPedFlags + 1) & 0x80) != 0 && this->m_nLimbRemoveIndex == 2 )
  {
    v70 = RpHAnimIDGetIndex(v40, 5);
    v71 = RpHAnimHierarchyGetMatrixArray(v40);
    memset(&pos, 0, 12);
    RwMatrixScale(&v71[v70], (const RwV3d_0 *)&pos, rwCOMBINEPRECONCAT);
    v72 = RpHAnimIDGetIndex(v40, 8);
    v73 = RpHAnimHierarchyGetMatrixArray(v40);
    RwMatrixScale(&v73[v72], (const RwV3d_0 *)&pos, rwCOMBINEPRECONCAT);
    v74 = RpHAnimIDGetIndex(v40, 6);
    v75 = RpHAnimHierarchyGetMatrixArray(v40);
    RwMatrixScale(&v75[v74], (const RwV3d_0 *)&pos, rwCOMBINEPRECONCAT);
    v76 = RpHAnimIDGetIndex(v40, 7);
    v77 = RpHAnimHierarchyGetMatrixArray(v40);
    RwMatrixScale(&v77[v76], (const RwV3d_0 *)&pos, rwCOMBINEPRECONCAT);
  }
  axis.z = 1.0;
  *(_QWORD *)&axis.x = unk_61DA28;
  m_wobble = this->m_wobble;
  if ( m_wobble > 0.0 )
  {
    v79 = m_wobble - (float)(this->m_wobbleSpeed * CTimer::ms_fTimeStep);
    v80 = sinf(this->m_wobble);
    this->m_wobble = v79;
    v81 = v80 * -5.0;
    if ( this->m_nPedType >= 2u )
    {
      v82 = RpHAnimIDGetIndex(v40, 302);
      v83 = RpHAnimHierarchyGetMatrixArray(v40);
      RwMatrixRotate(&v83[v82], &axis, v81, rwCOMBINEPRECONCAT);
      v84 = RpHAnimIDGetIndex(v40, 301);
      v85 = RpHAnimHierarchyGetMatrixArray(v40);
      RwMatrixRotate(&v85[v84], &axis, v81, rwCOMBINEPRECONCAT);
    }
    v86 = RpHAnimIDGetIndex(v40, 201);
    v87 = RpHAnimHierarchyGetMatrixArray(v40);
    RwMatrixRotate(&v87[v86], &axis, v81, rwCOMBINEPRECONCAT);
  }
  v88 = CWeather::Earthquake;
  if ( CWeather::Earthquake > 0.0 )
  {
    v89 = (float)((float)(v88 + v88) * (float)((float)rand() * 4.6566e-10)) - v88;
    v90 = RpHAnimIDGetIndex(v40, 42);
    v91 = RpHAnimHierarchyGetMatrixArray(v40);
    RwMatrixRotate(&v91[v90], &axis, v89 * 0.0025, rwCOMBINEPOSTCONCAT);
    v92 = RpHAnimIDGetIndex(v40, 52);
    v93 = RpHAnimHierarchyGetMatrixArray(v40);
    RwMatrixRotate(&v93[v92], &axis, v89 * 0.0025, rwCOMBINEPOSTCONCAT);
    v94 = RpHAnimIDGetIndex(v40, 33);
    v95 = RpHAnimHierarchyGetMatrixArray(v40);
    RwMatrixRotate(&v95[v94], &axis, v89 * 0.0025, rwCOMBINEPOSTCONCAT);
    v96 = RpHAnimIDGetIndex(v40, 23);
    v97 = RpHAnimHierarchyGetMatrixArray(v40);
    RwMatrixRotate(&v97[v96], &axis, v89 * 0.0025, rwCOMBINEPOSTCONCAT);
    v98 = RpHAnimIDGetIndex(v40, 32);
    v99 = RpHAnimHierarchyGetMatrixArray(v40);
    RwMatrixRotate(&v99[v98], &axis, v89 * 0.0025, rwCOMBINEPOSTCONCAT);
    v100 = RpHAnimIDGetIndex(v40, 22);
    v101 = RpHAnimHierarchyGetMatrixArray(v40);
    RwMatrixRotate(&v101[v100], &axis, v89 * 0.0025, rwCOMBINEPOSTCONCAT);
    v102 = RpHAnimIDGetIndex(v40, 43);
    v103 = RpHAnimHierarchyGetMatrixArray(v40);
    RwMatrixRotate(&v103[v102], &axis, v89 * 0.0025, rwCOMBINEPOSTCONCAT);
    v104 = RpHAnimIDGetIndex(v40, 53);
    v105 = RpHAnimHierarchyGetMatrixArray(v40);
    RwMatrixRotate(&v105[v104], &axis, v89 * 0.0025, rwCOMBINEPOSTCONCAT);
    v106 = RpHAnimIDGetIndex(v40, 34);
    v107 = RpHAnimHierarchyGetMatrixArray(v40);
    RwMatrixRotate(&v107[v106], &axis, v89 * 0.0025, rwCOMBINEPOSTCONCAT);
    v108 = RpHAnimIDGetIndex(v40, 24);
    v109 = RpHAnimHierarchyGetMatrixArray(v40);
    RwMatrixRotate(&v109[v108], &axis, v89 * 0.0025, rwCOMBINEPOSTCONCAT);
    v110 = RpHAnimIDGetIndex(v40, 5);
    v111 = RpHAnimHierarchyGetMatrixArray(v40);
    RwMatrixRotate(&v111[v110], &axis, v89 * 0.0025, rwCOMBINEPOSTCONCAT);
  }
  if ( (*(_DWORD *)p_m_nPedFlags & 0x8000) != 0
    && this->m_nLimbRemoveIndex == 2
    && (*((_DWORD *)&this->m_nPedFlags + 3) & 0x20) == 0
    && this->m_nPedState != PED_DEAD
    && (CTimer::m_FrameCounter & 4) != 0 )
  {
    v112 = GetAnimHierarchyFromSkinClump((RpClump_0 *)this->m_pRwObject);
    v113 = RpHAnimIDGetIndex(v112, 5);
    v114 = &RpHAnimHierarchyGetMatrixArray(v112)[v113];
    v115 = *(_QWORD *)&v114->pos.x;
    pos.m_blue = v114->pos.z;
    *(_QWORD *)&pos.m_red = v115;
    v116 = this->m_pMat;
    zz = v116->zz;
    v118 = v116->xz * 0.6;
    dir.y = v116->yz * 0.6;
    dir.x = v118;
    dir.z = zz * 0.6;
    Fx_c::AddBlood(&g_fx, (CVector *)&pos, &dir, 16, this->m_lightingFromCollision);
  }
  if ( CWeather::Rain > 0.3
    && TheCamera.SoundDistUp > 15.0
    && (*(_DWORD *)p_m_nPedFlags & 0x100) == 0
    && CGame::currArea == AREA_MAIN_MAP )
  {
    v119 = this->m_pMat;
    v120 = &this->m_transform;
    v121 = &this->m_transform;
    if ( v119 )
      v121 = (CSimpleTransform *)&v119->tx;
    if ( v121->m_translate.z < 900.0 && !CCullZones::CamNoRain() )
    {
      v122 = this->m_pMat;
      if ( v122 )
        v120 = (CSimpleTransform *)&v122->tx;
      v123 = (CSimpleTransform *)&TheCamera.m_pMat->tx;
      if ( !TheCamera.m_pMat )
        v123 = &TheCamera.m_transform;
      v124.n64_u64[0] = vsub_f32(*(float32x2_t *)&v123->m_translate.y, *(float32x2_t *)&v120->m_translate.y).n64_u64[0];
      v125 = vmul_f32(v124, v124).n64_u64[0];
      if ( sqrtf(
             (float)((float)((float)(v123->m_translate.x - v120->m_translate.x)
                           * (float)(v123->m_translate.x - v120->m_translate.x))
                   + *(float *)&v125)
           + *((float *)&v125 + 1)) < 25.0 )
      {
        v126 = (CPedModelInfo *)CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
        CPedModelInfo::AnimatePedColModelSkinnedWorld(v126, (RpClump_0 *)this->m_pRwObject);
        m_pHitColModel = v126->m_pHitColModel;
        PlayerSpeed = FindPlayerSpeed(-1);
        v129 = PlayerSpeed->x;
        if ( fabsf(PlayerSpeed->x) <= 0.05 )
        {
          v130 = PlayerSpeed->y;
          if ( fabsf(v130) <= 0.05 )
          {
            v131 = PlayerSpeed->z;
            m_nPedState = this->m_nPedState;
            if ( ((unsigned int)(m_nPedState - 42) > 0xD || ((1 << (m_nPedState - 42)) & 0x3001) == 0)
              && (unsigned int)(m_nPedState - 16) >= 2 )
            {
              if ( CPed::IsPedHeadAbovePos(this, 0.3) )
              {
                if ( !RpAnimBlendClumpGetAssociation((RpClump_0 *)this->m_pRwObject, 0xAu) )
                {
                  m_pColData = m_pHitColModel->m_pColData;
                  m_nNoOfSpheres = m_pColData->m_nNoOfSpheres;
                  if ( m_nNoOfSpheres >= 1 )
                  {
                    v139 = 17;
                    v140 = v131 * 50.0;
                    v141 = v130 * 50.0;
                    v142 = v129 * 50.0;
                    do
                    {
                      m_pSphereArray = m_pColData->m_pSphereArray;
                      v144 = *((unsigned __int8 *)&m_pSphereArray->m_vecCentre.x + v139);
                      if ( v144 <= 9 && ((1 << v144) & 0x260) != 0 )
                      {
                        FxPrtMult_c::FxPrtMult_c(&pos, 1.0, 1.0, 1.0, 0.35, 0.01, 0.0, 0.03);
                        v145 = (int)m_pSphereArray + v139;
                        v146 = *(_QWORD *)(v145 - 17);
                        dir.z = *(RwReal *)(v145 - 9);
                        *(_QWORD *)&dir.x = v146;
                        dir.x = *(float *)&v146 + (float)((float)((float)((float)rand() * 4.6566e-10) * 0.16) + -0.08);
                        dir.y = dir.y + (float)((float)((float)((float)rand() * 4.6566e-10) * 0.16) + -0.08);
                        v147 = *(float *)(v145 - 5) * 0.75;
                        vel.y = v141;
                        vel.x = v142;
                        vel.z = v140;
                        dir.z = dir.z + v147;
                        FxSystem_c::AddParticle(g_fx.m_fxSysSplash, &dir, &vel, 0.0, &pos, -1.0, 1.2, 0.6, 0);
                      }
                      v139 += 20;
                      --m_nNoOfSpheres;
                    }
                    while ( m_nNoOfSpheres );
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  v133 = this->m_pPlayerData;
  if ( v133 && v133->m_wetness >= 1 && v133->m_waterCoverPerc <= 0x1Du )
  {
    FxPrtMult_c::FxPrtMult_c(&pos, 1.0, 1.0, 1.0, 0.2, 0.15, 0.0, 0.1);
    v134 = this->m_pMat;
    v135 = (CSimpleTransform *)&v134->tx;
    if ( !v134 )
      v135 = &this->m_transform;
    v136 = *(_QWORD *)&v135->m_translate.x;
    dir.z = v135->m_translate.z;
    *(_QWORD *)&dir.x = v136;
    dir.x = *(float *)&v136 + (float)((float)((float)((float)rand() * 4.6566e-10) * 0.6) + -0.3);
    dir.y = dir.y + (float)((float)((float)((float)rand() * 4.6566e-10) * 0.6) + -0.3);
    dir.z = dir.z + (float)((float)((float)rand() * 4.6566e-10) + -0.8);
    memset(&vel, 0, sizeof(vel));
    pos.m_alpha = pos.m_alpha * (float)((float)this->m_pPlayerData->m_wetness / 100.0);
    FxSystem_c::AddParticle(g_fx.m_fxSysWaterSplash, &dir, &vel, 0.0, &pos, -1.0, 1.2, 0.6, 0);
  }
  if ( *((unsigned __int8 *)&this->m_nPedFlags + 1) << 31 )
  {
    v137 = this->m_pMyVehicle;
    if ( v137 )
      this->m_lightingFromCollision = v137->m_lightingFromCollision;
  }
}

//----- (004A6964) --------------------------------------------------------
void __fastcall CPed::Render(CPed *this)
{
  CPlayerPedData *m_pPlayerData; // r0
  int v3; // r0
  RpHAnimHierarchy_0 *AnimHierarchyFromSkinClump; // r5
  RwMatrix *MatrixArray; // r6
  RwMatrix *v6; // r3
  __int64 v7; // d16
  __int64 v8; // d17
  _QWORD *parent; // r5
  __int64 v10; // d20
  __int64 v11; // d21
  __int64 v12; // d23
  __int64 v13; // d18
  __int64 v14; // d19
  __int64 v15; // d16
  CTaskSimpleJetPack *TaskJetPack; // r0
  CLink<CPed *> *m_pNext; // r0
  __int64 v18; // kr00_8
  int m_nGunFlashBlendAmount; // r0
  bool v20; // cc
  RwFrame_0 *m_pWeaponFlashFrame; // r0
  RpAtomic_0 *FirstObject; // r0
  CVehicle *m_pMyVehicle; // r1
  int32 m_baseVehicleType; // r0
  bool v25; // zf
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r3
  CSimpleTransform *p_m_transform; // r2
  float v29; // s0
  float v30; // s4
  RwV3d_0 v31; // [sp+0h] [bp-20h] BYREF
  void *value; // [sp+Ch] [bp-14h] BYREF

  if ( CMirrors::TypeOfMirror != 3 )
  {
    value = &dword_0 + 1;
    if ( this->m_nPedType <= 1u )
    {
      RwRenderStateGet(rwRENDERSTATEALPHATESTFUNCTIONREF, &value);
      RwRenderStateSet(rwRENDERSTATEALPHATESTFUNCTIONREF, (char *)&dword_0 + 1);
    }
    if ( (*((_DWORD *)&this->m_nPedFlags + 2) & 2) == 0
      && (*(_BYTE *)&this->m_nFlags >> 7 || CMirrors::bRenderingReflection && CMirrors::TypeOfMirror != 2) )
    {
      if ( (*(_DWORD *)&this->m_nPedFlags & 0x100) == 0
        || !this->m_pMyVehicle
        || CTaskManager::FindActiveTaskByType(&this->m_pPedIntelligence->m_taskManager, 704)
        || CTaskManager::FindActiveTaskByType(&this->m_pPedIntelligence->m_taskManager, 824) )
      {
        goto LABEL_12;
      }
      if ( (*((_BYTE *)&this->m_nPedFlags + 1) & 0x20) != 0 )
      {
        m_pMyVehicle = this->m_pMyVehicle;
        m_baseVehicleType = m_pMyVehicle->m_baseVehicleType;
        v25 = m_baseVehicleType == 9;
        if ( m_baseVehicleType != 9 )
          v25 = m_pMyVehicle->m_vehicleType == 2;
        if ( v25 || this->m_nPedType < 2u )
          goto LABEL_12;
        m_pMat = this->m_pMat;
        p_tx = (CSimpleTransform *)&m_pMat->tx;
        if ( !m_pMat )
          p_tx = &this->m_transform;
        p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
        if ( !TheCamera.m_pMat )
          p_m_transform = &TheCamera.m_transform;
        v29 = 1.0;
        if ( MobileSettings::settings[0].value == 1 )
          v29 = 0.83;
        if ( !MobileSettings::settings[0].value )
          v29 = 0.65;
        v30 = m_baseVehicleType == 5 ? 40.0 : 25.0;
        if ( (float)((float)((float)((float)(p_m_transform->m_translate.x - p_tx->m_translate.x)
                                   * (float)(p_m_transform->m_translate.x - p_tx->m_translate.x))
                           + (float)((float)(p_m_transform->m_translate.y - p_tx->m_translate.y)
                                   * (float)(p_m_transform->m_translate.y - p_tx->m_translate.y)))
                   + (float)((float)(p_m_transform->m_translate.z - p_tx->m_translate.z)
                           * (float)(p_m_transform->m_translate.z - p_tx->m_translate.z))) <= (float)((float)((float)(v29 * v30) * TheCamera.LODDistMultiplier) * (float)((float)(v29 * v30) * TheCamera.LODDistMultiplier)) )
        {
LABEL_12:
          if ( CPostEffects::IsVisionFXActive() )
          {
            CPostEffects::InfraredVisionStoreAndSetLightsForHeatObjects(this);
            CPostEffects::NightVisionSetLights();
            CEntity::Render(this);
            CPostEffects::InfraredVisionRestoreLightsForHeatObjects();
          }
          else
          {
            CEntity::Render(this);
          }
          m_pPlayerData = this->m_pPlayerData;
          if ( m_pPlayerData )
            v3 = (*((unsigned __int8 *)m_pPlayerData + 53) >> 4) & 1;
          else
            v3 = 1;
          if ( v3 == 1
            && this->m_pWeaponClump
            && (!(*((unsigned __int8 *)&this->m_nPhysicalFlags + 1) << 31)
             || !CPedIntelligence::GetTaskSwim(this->m_pPedIntelligence))
            && !CPedIntelligence::GetTaskHold(this->m_pPedIntelligence, 0) )
          {
            m_pNext = CVisibilityPlugins::ms_weaponPedsForPC.m_firstFreeLink.m_pNext;
            if ( CVisibilityPlugins::ms_weaponPedsForPC.m_firstFreeLink.m_pNext != &CVisibilityPlugins::ms_weaponPedsForPC.m_lastFreeLink )
            {
              v18 = *(_QWORD *)&CVisibilityPlugins::ms_weaponPedsForPC.m_firstFreeLink.m_pNext->m_pPrev;
              CVisibilityPlugins::ms_weaponPedsForPC.m_firstFreeLink.m_pNext->item = this;
              *(_DWORD *)(HIDWORD(v18) + 4) = v18;
              m_pNext->m_pPrev->m_pNext = m_pNext->m_pNext;
              m_pNext->m_pNext = CVisibilityPlugins::ms_weaponPedsForPC.m_firstLink.m_pNext;
              CVisibilityPlugins::ms_weaponPedsForPC.m_firstLink.m_pNext->m_pPrev = m_pNext;
              m_pNext->m_pPrev = (CLink<CPed *> *)&CVisibilityPlugins::ms_weaponPedsForPC;
              CVisibilityPlugins::ms_weaponPedsForPC.m_firstLink.m_pNext = m_pNext;
            }
            m_nGunFlashBlendAmount = this->m_nGunFlashBlendAmount;
            v20 = m_nGunFlashBlendAmount < 0;
            if ( m_nGunFlashBlendAmount <= 0 )
              v20 = this->m_nGunFlashBlendAmount2 < 1;
            if ( !v20 )
            {
              m_pWeaponFlashFrame = this->m_pWeaponFlashFrame;
              if ( m_pWeaponFlashFrame )
              {
                FirstObject = (RpAtomic_0 *)GetFirstObject(m_pWeaponFlashFrame);
                if ( FirstObject )
                {
                  FirstObject->object.object.flags = 0;
                  CVehicle::SetComponentAtomicAlpha(FirstObject, 0);
                }
              }
            }
          }
          if ( this->m_pGogglesClump )
          {
            AnimHierarchyFromSkinClump = GetAnimHierarchyFromSkinClump((RpClump_0 *)this->m_pRwObject);
            MatrixArray = RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump);
            v6 = &MatrixArray[RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, 5)];
            v7 = *(_QWORD *)&v6->right.x;
            v8 = *(_QWORD *)&v6->right.z;
            parent = this->m_pGogglesClump->object.parent;
            v10 = *(_QWORD *)&v6->up.x;
            v11 = *(_QWORD *)&v6->up.z;
            v12 = *(_QWORD *)&v6->pos.z;
            v13 = *(_QWORD *)&v6->at.x;
            v14 = *(_QWORD *)&v6->at.z;
            parent[8] = *(_QWORD *)&v6->pos.x;
            parent[9] = v12;
            parent[6] = v13;
            parent[7] = v14;
            parent[4] = v10;
            parent[5] = v11;
            parent[2] = v7;
            parent[3] = v8;
            *(_QWORD *)&v31.x = 0x3DAC083100000000LL;
            v31.z = 0.0;
            RwV3dTransformPoints(&v31, &v31, 1, v6);
            v15 = *(_QWORD *)&v31.x;
            *((_DWORD *)parent + 18) = LODWORD(v31.z);
            parent[8] = v15;
            RwFrameUpdateObjects((RwFrame_0 *)parent);
            RpClumpRender(this->m_pGogglesClump);
          }
          if ( CPedIntelligence::GetTaskJetPack(this->m_pPedIntelligence) )
          {
            TaskJetPack = CPedIntelligence::GetTaskJetPack(this->m_pPedIntelligence);
            CTaskSimpleJetPack::RenderJetPack(TaskJetPack, this);
          }
          *((_DWORD *)&this->m_nPedFlags + 2) |= 0x20000000u;
          if ( this->m_nPedType <= 1u )
            RwRenderStateSet(rwRENDERSTATEALPHATESTFUNCTIONREF, value);
        }
      }
    }
  }
}
// 0: using guessed type int dword_0;

//----- (004A6C9C) --------------------------------------------------------
void __fastcall CPed::SpecialEntityPreCollisionStuff(
        CPed *this,
        CPhysical *pPhysical,
        int bDoingShift,
        bool *bSkipTestEntirely,
        bool *a5,
        bool *a6,
        bool *a7)
{
  CPed *v7; // r5
  int v9; // r0
  CPhysical *m_pNOCollisionVehicle; // r6
  bool *v11; // lr
  bool v12; // zf
  CPhysical *m_pAttachToEntity; // r6
  bool v14; // zf
  bool v15; // zf
  CPhysical::CPhysicalFlags m_nPhysicalFlags; // r5
  bool v17; // zf
  int m_nModelIndex; // r0
  bool v19; // zf

  v9 = *(_BYTE *)&pPhysical->m_info & 7;
  if ( v9 == 2 && (*((_BYTE *)&this->m_nPedFlags + 7) & 0x80) != 0 && this->m_pMyVehicle == pPhysical )
  {
LABEL_23:
    *bSkipTestEntirely = 1;
    goto LABEL_24;
  }
  m_pNOCollisionVehicle = (CPhysical *)this->m_pNOCollisionVehicle;
  v11 = a5;
  v12 = m_pNOCollisionVehicle == pPhysical;
  if ( m_pNOCollisionVehicle != pPhysical )
    v12 = pPhysical->m_pNOCollisionVehicle == this;
  if ( v12 )
  {
    *a5 = 1;
    if ( (*((_DWORD *)&this->m_nPedFlags + 1) & 0x80000010) == 0x10 )
      goto LABEL_24;
    goto LABEL_9;
  }
  m_pAttachToEntity = (CPhysical *)this->m_pAttachToEntity;
  v14 = m_pAttachToEntity == pPhysical;
  if ( m_pAttachToEntity != pPhysical )
  {
    v7 = (CPed *)pPhysical->m_pAttachToEntity;
    v14 = v7 == this;
  }
  if ( v14 )
    goto LABEL_23;
  v15 = m_pAttachToEntity == 0;
  if ( m_pAttachToEntity )
    v15 = v7 == 0;
  if ( !v15 )
    goto LABEL_23;
  m_nPhysicalFlags = pPhysical->m_nPhysicalFlags;
  if ( (*(_BYTE *)&m_nPhysicalFlags & 0x20) != 0 )
  {
    v17 = (*(_DWORD *)&m_nPhysicalFlags & 0x40000004) == 0;
    if ( (*(_DWORD *)&m_nPhysicalFlags & 0x40000004) != 0 )
      bSkipTestEntirely = a6;
    else
      v17 = bDoingShift == 0;
    if ( v17 )
    {
      if ( (*(_BYTE *)&this->m_nFlags & 0x10) != 0 )
      {
        bSkipTestEntirely = a7;
      }
      else
      {
        bSkipTestEntirely = a7;
        if ( (*(_BYTE *)&pPhysical->m_nFlags & 0x10) == 0 )
          goto LABEL_9;
      }
    }
    *bSkipTestEntirely = 1;
    goto LABEL_9;
  }
  if ( (*(_BYTE *)&m_nPhysicalFlags & 0xC0) != 0 )
  {
    if ( !bDoingShift )
    {
      if ( (*(_BYTE *)&this->m_nFlags & 0x10) == 0 )
      {
        v11 = a7;
        if ( (*(_BYTE *)&pPhysical->m_nFlags & 0x10) != 0 )
          goto LABEL_56;
LABEL_9:
        *(_DWORD *)&this->m_nPhysicalFlags |= 0x1000u;
        goto LABEL_24;
      }
      v11 = a7;
    }
LABEL_56:
    *v11 = 1;
    goto LABEL_9;
  }
  if ( v9 != 4 )
  {
    m_nModelIndex = pPhysical->m_nModelIndex;
    if ( m_nModelIndex == 441 )
      goto LABEL_56;
    v19 = m_nModelIndex == 594;
    if ( m_nModelIndex != 594 )
      v19 = m_nModelIndex == 564;
    if ( v19 )
      goto LABEL_56;
    goto LABEL_53;
  }
  if ( BYTE1(pPhysical[1].m_transform.m_translate.y) << 31 && pPhysical->m_pMat->zz < 0.66
    || pPhysical->m_nModelIndex == 342 && pPhysical->m_pMat->tz < this->m_pMat->tz )
  {
    goto LABEL_56;
  }
  if ( *(float *)&pPhysical[1].pReferences[2].ppReferenceAddress <= 0.0 && (*(_BYTE *)&m_nPhysicalFlags & 4) == 0
    || fabsf(pPhysical->m_vecMoveSpeed.x) >= 0.001
    || fabsf(pPhysical->m_vecMoveSpeed.y) >= 0.001
    || fabsf(pPhysical->m_vecMoveSpeed.z) >= 0.001 )
  {
LABEL_53:
    if ( (*(_BYTE *)&pPhysical->m_nFlags & 0x10) == 0 )
      goto LABEL_24;
  }
  *a6 = 1;
LABEL_24:
  if ( this->m_nPedType <= 1u )
  {
    if ( CPedIntelligence::GetTaskClimb(this->m_pPedIntelligence) )
      *(_DWORD *)&this->m_nPhysicalFlags |= 0x1000u;
  }
}
// 4A6D0C: variable 'v7' is possibly undefined

//----- (004A6E58) --------------------------------------------------------
uint8 __fastcall CPed::SpecialEntityCalcCollisionSteps(
        CPed *this,
        bool *bDoPreCheckAtFullSpeed,
        bool *bDoPreCheckAtHalfSpeed)
{
  unsigned int v4; // r0
  CPlayerPedData *m_pPlayerData; // r0
  float x; // s0
  float y; // s4
  float z; // s2
  float v9; // s6
  float v10; // s0
  float v11; // r0
  float v12; // s0

  if ( this->m_pAttachToEntity )
  {
    LOBYTE(v4) = 1;
  }
  else
  {
    m_pPlayerData = this->m_pPlayerData;
    x = this->m_vecMoveSpeed.x;
    if ( m_pPlayerData )
    {
      y = this->m_vecMoveSpeed.y;
      z = this->m_vecMoveSpeed.z;
      v9 = CTimer::ms_fTimeStep;
    }
    else
    {
      y = this->m_vecMoveSpeed.y;
      z = this->m_vecMoveSpeed.z;
      v9 = CTimer::ms_fTimeStep;
      if ( (float)(CTimer::ms_fTimeStep
                 * (float)(CTimer::ms_fTimeStep * (float)((float)((float)(x * x) + (float)(y * y)) + (float)(z * z)))) < 0.09 )
      {
        LOBYTE(v4) = 1;
        return v4;
      }
    }
    v10 = v9 * sqrtf((float)((float)(x * x) + (float)(y * y)) + (float)(z * z));
    if ( m_pPlayerData )
    {
      if ( this->m_pGroundPhysical )
      {
        v11 = ceilf((float)(v10 + v10) / 0.3);
        v12 = 4.0;
      }
      else
      {
        v11 = ceilf(v10 / 0.3);
        v12 = 2.0;
      }
      if ( v11 >= v12 )
        return (unsigned int)v11;
      return (unsigned int)v12;
    }
    else
    {
      v4 = (unsigned int)ceilf((float)(v10 * 1.5) / 0.3);
      this->m_fElasticity = this->m_fElasticity + this->m_fElasticity;
    }
  }
  return v4;
}

//----- (004A6F7C) --------------------------------------------------------
void __fastcall CPed::SetIdle(CPed *this)
{
  switch ( this->m_nPedState )
  {
    case PED_IDLE:
    case PED_FLEE_ENTITY:
    case PED_MUG:
      return;
    case PED_AIMGUN:
      this->m_nPedState = PED_IDLE;
      goto LABEL_3;
    default:
LABEL_3:
      this->m_eMoveState = PEDMOVE_STILL;
      break;
  }
}

//----- (004A6FB0) --------------------------------------------------------
void __fastcall CPed::SetLook(CPed *this, float fLookHeading)
{
  int m_nPedFlags; // r0
  int v4; // r12
  int v5; // r3
  unsigned __int32 v6; // r6
  int v7; // r5
  uint32 m_nLookTimer; // r6
  CEntity *m_pEntLookEntity; // r0
  ePedState m_nPedState; // r0

  m_nPedFlags = (int)this->m_nPedFlags;
  if ( (m_nPedFlags & 0x600) == 0 )
  {
    v4 = *((_DWORD *)&this->m_nPedFlags + 1);
    v5 = *((_DWORD *)&this->m_nPedFlags + 2);
    v6 = this->m_nPedState - 54;
    v7 = *((_DWORD *)&this->m_nPedFlags + 3);
    if ( v6 > 9 || ((1 << v6) & 0x203) == 0 )
    {
      m_nLookTimer = this->m_nLookTimer;
      this->m_nPedState = PED_LOOK_HEADING;
      if ( m_nLookTimer < CTimer::m_snTimeInMilliseconds )
      {
        *(_DWORD *)&this->m_nPedFlags = m_nPedFlags & 0xFFFFFFF3 | 4;
        *((_DWORD *)&this->m_nPedFlags + 1) = v4;
        *((_DWORD *)&this->m_nPedFlags + 2) = v5;
        *((_DWORD *)&this->m_nPedFlags + 3) = v7;
        this->m_fLookHeading = fLookHeading;
        m_pEntLookEntity = this->m_pEntLookEntity;
        if ( m_pEntLookEntity )
        {
          CEntity::CleanUpOldReference(m_pEntLookEntity, &this->m_pEntLookEntity);
          m_nPedState = this->m_nPedState;
          this->m_pEntLookEntity = 0;
          this->m_nLookTimer = 0;
          if ( (m_nPedState | 8) == 58 )
            return;
        }
        else
        {
          this->m_nLookTimer = 0;
          this->m_pEntLookEntity = 0;
        }
        if ( (*((_BYTE *)&this->m_nPedFlags + 3) & 4) == 0 )
          this->m_ik.m_flags &= ~2u;
      }
    }
  }
}

//----- (004A7070) --------------------------------------------------------
void __fastcall CPed::SetLook(CPed *this, CEntity *pLookEntity)
{
  int m_nPedFlags; // r0
  int v5; // r12
  __int64 v6; // r2
  unsigned __int32 v7; // r6
  uint32 m_nLookTimer; // r6
  CEntity *m_pEntLookEntity; // r0
  ePedState m_nPedState; // r0

  m_nPedFlags = (int)this->m_nPedFlags;
  if ( (m_nPedFlags & 0x600) == 0 )
  {
    v5 = *((_DWORD *)&this->m_nPedFlags + 1);
    v6 = *((_QWORD *)&this->m_nPedFlags + 1);
    v7 = this->m_nPedState - 54;
    if ( v7 > 9 || ((1 << v7) & 0x203) == 0 )
    {
      m_nLookTimer = this->m_nLookTimer;
      this->m_nPedState = PED_LOOK_ENTITY;
      if ( m_nLookTimer < CTimer::m_snTimeInMilliseconds )
      {
        *(_DWORD *)&this->m_nPedFlags = m_nPedFlags & 0xFFFFFFF3 | 4;
        *((_DWORD *)&this->m_nPedFlags + 1) = v5;
        *((_QWORD *)&this->m_nPedFlags + 1) = v6;
        m_pEntLookEntity = this->m_pEntLookEntity;
        if ( m_pEntLookEntity )
          CEntity::CleanUpOldReference(m_pEntLookEntity, &this->m_pEntLookEntity);
        this->m_pEntLookEntity = pLookEntity;
        CEntity::RegisterReference(pLookEntity, &this->m_pEntLookEntity);
        this->m_nLookTimer = 0;
        m_nPedState = this->m_nPedState;
        this->m_fLookHeading = 1000000.0;
        if ( (m_nPedState | 8) != 58 && (*((_BYTE *)&this->m_nPedFlags + 3) & 4) == 0 )
          this->m_ik.m_flags &= ~2u;
      }
    }
  }
}

//----- (004A7134) --------------------------------------------------------
void __fastcall CPed::SetLookTimer(CPed *this, uint32 nTime)
{
  if ( CTimer::m_snTimeInMilliseconds > this->m_nLookTimer )
    this->m_nLookTimer = nTime + CTimer::m_snTimeInMilliseconds;
}

//----- (004A7154) --------------------------------------------------------
bool __fastcall CPed::TurnBody(CPed *this)
{
  CEntity *m_pEntLookEntity; // r0
  CMatrix *m_pMat; // r1
  CMatrix *v4; // r5
  CSimpleTransform *p_tx; // r3
  float *p_x; // r1
  __int64 v7; // r2
  float RadianAngleBetweenPoints; // s0
  float *p_m_fLookHeading; // r5
  float v10; // r0
  float m_fCurrentHeading; // s0
  float v12; // s2
  float v13; // s4
  bool result; // r0

  m_pEntLookEntity = this->m_pEntLookEntity;
  if ( m_pEntLookEntity )
  {
    m_pMat = this->m_pMat;
    v4 = m_pEntLookEntity->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &this->m_transform;
    p_x = &v4->tx;
    v7 = *(_QWORD *)&p_tx->m_translate.x;
    if ( !v4 )
      p_x = &m_pEntLookEntity->m_transform.m_translate.x;
    RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(*p_x, p_x[1], *(float *)&v7, *((float *)&v7 + 1));
    p_m_fLookHeading = &this->m_fLookHeading;
    this->m_fLookHeading = RadianAngleBetweenPoints;
  }
  else
  {
    p_m_fLookHeading = &this->m_fLookHeading;
    RadianAngleBetweenPoints = this->m_fLookHeading;
  }
  v10 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
  m_fCurrentHeading = this->m_fCurrentHeading;
  v12 = v10;
  if ( (float)(m_fCurrentHeading + 3.1416) >= v10 )
  {
    if ( (float)(m_fCurrentHeading + -3.1416) <= v10 )
      goto LABEL_13;
    v13 = 6.2832;
  }
  else
  {
    v13 = -6.2832;
  }
  v12 = v10 + v13;
LABEL_13:
  this->m_fDesiredHeading = v12;
  if ( fabsf(m_fCurrentHeading - v12) <= 0.05 )
  {
    result = 1;
  }
  else
  {
    result = 0;
    m_fCurrentHeading = m_fCurrentHeading + (float)((float)(m_fCurrentHeading - v12) / -5.0);
  }
  this->m_fCurrentHeading = m_fCurrentHeading;
  *p_m_fLookHeading = v12;
  return result;
}

//----- (004A7230) --------------------------------------------------------
void __fastcall CPed::Teleport(CPed *this, CVector NewCoors, Bool8 bClearOrientation)
{
  RwReal x; // r5
  int v5; // r1
  RwReal z; // r8
  float y; // r6
  CPedIntelligence *m_pPedIntelligence; // r0
  CMatrix *m_pMat; // r0
  float *p_tz; // r0
  CEntity *m_pDamageEntity; // r0

  x = NewCoors.x;
  LODWORD(NewCoors.x) = this->m_nPedType;
  z = NewCoors.z;
  y = NewCoors.y;
  if ( !LODWORD(NewCoors.x) )
  {
LABEL_4:
    m_pPedIntelligence = this->m_pPedIntelligence;
    goto LABEL_5;
  }
  m_pPedIntelligence = this->m_pPedIntelligence;
  if ( v5 != 1 )
  {
    if ( !CTaskManager::FindActiveTaskByType(&m_pPedIntelligence->m_taskManager, 704) )
      goto LABEL_6;
    goto LABEL_4;
  }
LABEL_5:
  CPedIntelligence::FlushImmediately(m_pPedIntelligence, 1);
LABEL_6:
  CWorld::Remove(this);
  m_pMat = this->m_pMat;
  if ( m_pMat )
  {
    m_pMat->tx = x;
    this->m_pMat->ty = y;
    p_tz = &this->m_pMat->tz;
  }
  else
  {
    p_tz = &this->m_transform.m_translate.z;
    this->m_transform.m_translate.x = x;
    this->m_transform.m_translate.y = y;
  }
  *p_tz = z;
  m_pDamageEntity = this->m_pDamageEntity;
  *(_DWORD *)&this->m_nPedFlags &= ~1u;
  if ( m_pDamageEntity )
    CEntity::CleanUpOldReference(m_pDamageEntity, &this->m_pDamageEntity);
  this->m_pDamageEntity = 0;
  CWorld::Add(this);
  *(_QWORD *)&this->m_vecMoveSpeed.x = 0LL;
  *(_QWORD *)&this->m_vecMoveSpeed.z = 0LL;
  this->m_vecTurnSpeed.y = 0.0;
  this->m_vecTurnSpeed.z = 0.0;
}

//----- (004A72C4) --------------------------------------------------------
bool __fastcall IsPedPointerValid(CPed *pPed)
{
  int v2; // r1
  int32 v3; // r1
  bool v4; // zf
  CVehicle *m_pMyVehicle; // r0

  v2 = (char *)pPed - (char *)CPools::ms_pPedPool->m_aStorage;
  if ( v2 < 0 )
    return 0;
  v3 = -1093107909 * (v2 >> 2);
  if ( v3 >= CPools::ms_pPedPool->m_nSize || (CPools::ms_pPedPool->m_aFlags[v3] & 0x80u) != 0 )
    return 0;
  m_pMyVehicle = (CVehicle *)(*((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31);
  v4 = *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 == 0;
  if ( m_pMyVehicle )
  {
    m_pMyVehicle = pPed->m_pMyVehicle;
    v4 = m_pMyVehicle == 0;
  }
  if ( !v4 )
    return sub_1986C4(m_pMyVehicle);
  if ( pPed->m_listEntryInfo.m_pHead )
    return 1;
  return FindPlayerPed(-1) == pPed;
}

//----- (004A7334) --------------------------------------------------------
bool __fastcall IsPedPointerValid_NotInWorld(CPed *pPed)
{
  int v1; // r0
  bool result; // r0
  int32 v3; // r2

  v1 = (char *)pPed - (char *)CPools::ms_pPedPool->m_aStorage;
  if ( v1 < 0 )
    return 0;
  v3 = -1093107909 * (v1 >> 2);
  result = 0;
  if ( v3 < CPools::ms_pPedPool->m_nSize && (char)CPools::ms_pPedPool->m_aFlags[v3] > -1 )
    return 1;
  return result;
}

//----- (004A7370) --------------------------------------------------------
bool __fastcall CPed::IsPointerValid(CPed *this)
{
  return (unsigned int)(-1093107909 * (((char *)this - (char *)CPools::ms_pPedPool->m_aStorage) >> 2)) <= 0x8B
      && (this->m_listEntryInfo.m_pHead || FindPlayerPed(-1) == this);
}

//----- (004A73B0) --------------------------------------------------------
void __fastcall CPed::SetPedPositionInCar(CPed *this)
{
  CVehicle *m_pMyVehicle; // r1
  CBaseModelInfo *v3; // r5
  CVehicle *v4; // r0
  uint32 v5; // r2
  RwReal v6; // r1
  __int64 v7; // d16
  uint32 m_hashKey; // r2
  __int64 v9; // d16
  int32 m_baseVehicleType; // r1
  int32 v11; // r1
  bool v12; // zf
  uint32 v13; // r1
  RwReal y; // r0
  float tz; // s16
  CVehicle *v16; // r0
  CMatrix *v17; // r1
  CPed *v18; // r5
  float v19; // s0
  CMatrix *v20; // r1
  CMatrix *m_pMat; // r1
  float m_heading; // s0
  float *p_m_fCurrentHeading; // r5
  CMatrix v24; // [sp+0h] [bp-108h] BYREF
  CMatrix m1; // [sp+48h] [bp-C0h] BYREF
  CVector v; // [sp+90h] [bp-78h] BYREF
  CMatrix v27; // [sp+A0h] [bp-68h] BYREF

  m_pMyVehicle = this->m_pMyVehicle;
  v3 = CModelInfo::ms_modelInfoPtrs[m_pMyVehicle->m_nModelIndex];
  CMatrix::CMatrix(&m1, m_pMyVehicle->m_pMat);
  v24.m_pRwMat = 0;
  v24.m_owner = 0;
  v4 = this->m_pMyVehicle;
  if ( v4->pDriver == this )
  {
    m_hashKey = v3[2].m_hashKey;
    if ( *(_DWORD *)&v3[1].m_modelName[20] != 5 )
      m_hashKey += 48;
    v9 = *(_QWORD *)m_hashKey;
    v.z = *(RwReal *)(m_hashKey + 8);
    *(_QWORD *)&v.x = v9;
    m_baseVehicleType = v4->m_baseVehicleType;
    if ( m_baseVehicleType != 5 && m_baseVehicleType != 9 )
      v.x = -v.x;
    if ( v4->m_vehicleType == 10 )
      v.z = v.z + (float)(fabsf(*(float *)&v4[1].m_VehicleAudioEntity.m_EngineSounds[10].SoundPtr) * -0.001);
  }
  else
  {
    if ( v4->pPassengers[0] == this )
    {
      v11 = v4->m_baseVehicleType;
      v12 = v11 == 9;
      if ( v11 != 9 )
        v12 = v4->m_vehicleType == 2;
      if ( !v12 )
        goto LABEL_5;
      goto LABEL_19;
    }
    if ( v4->pPassengers[1] != this )
    {
      if ( v4->pPassengers[2] != this )
      {
LABEL_5:
        v5 = v3[2].m_hashKey;
        if ( *(_DWORD *)&v3[1].m_modelName[20] != 5 )
          v5 += 48;
        v6 = *(float *)(v5 + 8);
        v7 = *(_QWORD *)v5;
        goto LABEL_20;
      }
LABEL_19:
      v13 = v3[2].m_hashKey;
      v7 = *(_QWORD *)(v13 + 60);
      v6 = *(float *)(v13 + 68);
LABEL_20:
      v.z = v6;
      *(_QWORD *)&v.x = v7;
      goto LABEL_22;
    }
    v = *(CVector *)(v3[2].m_hashKey + 60);
    v.x = -v.x;
  }
LABEL_22:
  if ( v4->m_baseVehicleType == 9 )
  {
    CBike::CalculateLeanMatrix((CBike *)v4);
    CMatrix::operator=(&m1, (const CMatrix *)&this->m_pMyVehicle[1].m_pLastRenderedLink);
  }
  else if ( v4->m_nModelIndex == 532 )
  {
    y = v4[1].m_vecCOM.y;
    if ( y == 0.0 )
    {
      tz = 0.0;
    }
    else
    {
      CMatrix::Attach(&v24, (RwMatrix *)(LODWORD(y) + 16), 0);
      tz = v24.tz;
      CMatrix::Detach(&v24);
    }
    CMatrix::SetTranslate(&v24, 0.0, 0.0, COERCE_FLOAT(LODWORD(tz) ^ 0x80000000));
    CMatrix::RotateY(&v24, *(float *)&this->m_pMyVehicle[1].AutoPilot.VeryOldLink.Address);
    v24.tx = v24.tx + 0.0;
    v24.ty = v24.ty + 0.0;
    v24.tz = tz + v24.tz;
    operator*(&v27, &m1, &v24);
    CMatrix::operator=(&m1, &v27);
    CMatrix::~CMatrix(&v27);
  }
  Multiply3x3((CVector *)&v27, &m1, &v);
  m1.tx = v27.xx + m1.tx;
  m1.ty = v27.yx + m1.ty;
  m1.tz = v27.zx + m1.tz;
  CMatrix::SetUnity(&v24);
  v16 = this->m_pMyVehicle;
  if ( v16->pHandling->AnimGroup == 13 )
  {
    if ( v16->pPassengers[1] == this )
    {
      m_pMat = v16->m_pMat;
      if ( m_pMat )
        m_heading = atan2f(COERCE_FLOAT(LODWORD(m_pMat->xy) ^ 0x80000000), m_pMat->yy);
      else
        m_heading = v16->m_transform.m_heading;
      p_m_fCurrentHeading = &this->m_fCurrentHeading;
      this->m_fCurrentHeading = m_heading + -1.5708;
      CMatrix::SetTranslate(&v24, 0.0, 0.0, 0.0);
      CMatrix::RotateZ(&v24, -1.5708);
      v24.tx = v24.tx + 0.0;
      v24.ty = v24.ty + 0.6;
      v24.tz = v24.tz + 0.0;
      goto LABEL_44;
    }
    v17 = v16->m_pMat;
    v18 = v16->pPassengers[2];
    if ( v17 )
    {
      v19 = atan2f(COERCE_FLOAT(LODWORD(v17->xy) ^ 0x80000000), v17->yy);
      if ( v18 == this )
        goto LABEL_41;
    }
    else
    {
      v19 = v16->m_transform.m_heading;
      if ( v18 == this )
      {
LABEL_41:
        p_m_fCurrentHeading = &this->m_fCurrentHeading;
        this->m_fCurrentHeading = v19 + 1.5708;
        CMatrix::SetTranslate(&v24, 0.0, 0.0, 0.0);
        CMatrix::RotateZ(&v24, 1.5708);
LABEL_44:
        operator*(&v27, &m1, &v24);
        CMatrix::operator=(&m1, &v27);
        CMatrix::~CMatrix(&v27);
        goto LABEL_45;
      }
    }
  }
  else
  {
    v20 = v16->m_pMat;
    if ( v20 )
      v19 = atan2f(COERCE_FLOAT(LODWORD(v20->xy) ^ 0x80000000), v20->yy);
    else
      v19 = v16->m_transform.m_heading;
  }
  p_m_fCurrentHeading = &this->m_fCurrentHeading;
  this->m_fCurrentHeading = v19;
LABEL_45:
  this->m_fDesiredHeading = *p_m_fCurrentHeading;
  CPlaceable::SetMatrix(this, &m1);
  CMatrix::~CMatrix(&v24);
  CMatrix::~CMatrix(&m1);
}

//----- (004A76F8) --------------------------------------------------------
void __fastcall RemoveAnimsFromAnimationBlock(RpClump_0 *pClump, const unsigned __int8 *pAnimBlock)
{
  CAnimBlock *AnimationBlock; // r4
  CAnimBlendAssociation *i; // r0
  int m_animIndex; // r2
  int v6; // r1

  AnimationBlock = CAnimManager::GetAnimationBlock(pAnimBlock);
  for ( i = RpAnimBlendClumpGetFirstAssociation(pClump); i; i = RpAnimBlendGetNextAssociation(i) )
  {
    m_animIndex = AnimationBlock->m_animIndex;
    v6 = -1431655765 * (((char *)i->m_pAnimBlendHierarchy - (char *)CAnimManager::ms_aAnimations) >> 3);
    if ( v6 >= m_animIndex && v6 < m_animIndex + AnimationBlock->m_numAnims )
      i->m_fBlendDelta = -1000.0;
  }
}

//----- (004A7756) --------------------------------------------------------
void __fastcall CPed::RestoreHeadingRate(CPed *this)
{
  this->m_fHeadingChangeRate = this->m_pPedStats->m_fMaxHeadingChange;
}

//----- (004A7762) --------------------------------------------------------
void __fastcall CPed::RestoreHeadingRateCB(CAnimBlendAssociation *pAnim, void *pData)
{
  *((_DWORD *)pData + 345) = *(_DWORD *)(*((_DWORD *)pData + 360) + 32);
}

//----- (004A7770) --------------------------------------------------------
void __fastcall CPed::FlagToDestroyWhenNextProcessed(CPed *this)
{
  int v2; // r1
  bool v3; // zf
  CVehicle *m_pMyVehicle; // r0
  CEntity **p_m_pMyVehicle; // r5
  CEntity::CEntityInfo m_info; // r1
  int CharCreatedBy; // r1
  ePedState v8; // r0
  CCoverPoint *m_pCoverPoint; // r0

  v2 = *((unsigned __int8 *)&this->m_nPedFlags + 1);
  *(_DWORD *)&this->m_nFlags |= 0x800u;
  m_pMyVehicle = (CVehicle *)(v2 << 31);
  v3 = v2 << 31 == 0;
  if ( v2 << 31 )
  {
    m_pMyVehicle = this->m_pMyVehicle;
    v3 = m_pMyVehicle == 0;
  }
  if ( !v3 )
  {
    p_m_pMyVehicle = &this->m_pMyVehicle;
    if ( m_pMyVehicle->pDriver == this )
    {
      CEntity::CleanUpOldReference(this, &m_pMyVehicle->pDriver);
      this->m_pMyVehicle->pDriver = 0;
      if ( this->m_nPedType <= 1u )
      {
        m_info = (*p_m_pMyVehicle)->m_info;
        if ( (*(_BYTE *)&m_info & 0xF8) != 40 )
          (*p_m_pMyVehicle)->m_info = (CEntity::CEntityInfo)(*(_BYTE *)&m_info & 7 | 0x20);
      }
    }
    else
    {
      CVehicle::RemovePassenger(m_pMyVehicle, this);
    }
    *(_DWORD *)&this->m_nPedFlags &= ~0x100u;
    if ( IsVehiclePointerValid((CVehicle *)*p_m_pMyVehicle) && *p_m_pMyVehicle )
      CEntity::CleanUpOldReference(*p_m_pMyVehicle, &this->m_pMyVehicle);
    CharCreatedBy = this->CharCreatedBy;
    v8 = PED_NONE;
    this->m_pMyVehicle = 0;
    if ( CharCreatedBy == 2 )
    {
      m_pCoverPoint = this->m_pCoverPoint;
      if ( m_pCoverPoint )
      {
        CCoverPoint::ReleaseCoverPointForPed(m_pCoverPoint, this);
        this->m_pCoverPoint = 0;
      }
      if ( (*((_BYTE *)&this->m_nPedFlags + 9) & 0x20) != 0 )
        CRadar::ClearBlipForEntity(
          BLIPTYPE_CHAR,
          CPools::ms_pPedPool->m_aFlags[-1093107909 * (((char *)this - (char *)CPools::ms_pPedPool->m_aStorage) >> 2)] | (-662750464 * (((char *)this - (char *)CPools::ms_pPedPool->m_aStorage) >> 2)));
      v8 = PED_DEAD;
    }
    this->m_nPedState = v8;
  }
}
// 676C84: using guessed type int CPools::ms_pPedPool[2];

//----- (004A7860) --------------------------------------------------------
void __fastcall CPed::SetRadioStation(CPed *this)
{
  CVehicle *m_pMyVehicle; // r0
  CBaseModelInfo *v3; // r5
  Int8 *v4; // r6

  if ( this->m_nPedType >= 2u )
  {
    m_pMyVehicle = this->m_pMyVehicle;
    if ( m_pMyVehicle )
    {
      if ( m_pMyVehicle->pDriver == this )
      {
        v3 = CModelInfo::ms_modelInfoPtrs[this->m_nModelIndex];
        v4 = (Int8 *)&v3[1].m_modelName[16];
        if ( (rand() & 1) == 0 )
          v4 = (Int8 *)&v3[1].m_modelName[17];
        this->m_pMyVehicle->m_VehicleAudioEntity.m_VehicleAudioSetting.RadioStation = *v4;
      }
    }
  }
}

//----- (004A78BC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
CEntity *__fastcall CPed::AttachPedToEntity(
        CPed *this,
        CEntity *pEnt,
        CVector vecPos,
        uint16 nHeading,
        float fHeadingLimit,
        eWeaponType nWeaponType)
{
  CEntity *v6; // r8
  RwReal y; // r6
  RwReal x; // r4
  unsigned int m_nPedType; // r4
  char *v11; // r0
  Int16 v12; // r1
  CWeaponInfo *WeaponInfo; // r0

  v6 = pEnt;
  y = vecPos.y;
  x = vecPos.x;
  if ( pEnt && !(*((unsigned __int8 *)&this->m_nPedFlags + 1) << 31) )
  {
    this->m_pAttachToEntity = pEnt;
    CEntity::RegisterReference(pEnt, &this->m_pAttachToEntity);
    this->m_vecAttachOffset.x = x;
    this->m_vecAttachOffset.y = y;
    this->m_vecAttachOffset.z = vecPos.z;
    this->m_fAttachHeadingLimit = fHeadingLimit;
    m_nPedType = this->m_nPedType;
    this->m_nAttachLookDirn = nHeading;
    if ( m_nPedType > 1 )
    {
      if ( (*(_BYTE *)&v6->m_info & 7) == 2 )
        this->m_pNOCollisionVehicle = v6;
    }
    else
    {
      *(_DWORD *)&this->m_nFlags &= ~1u;
    }
    if ( this->m_eStoredWeapon == WEAPONTYPE_UNIDENTIFIED )
    {
      v11 = (char *)this + 28 * this->m_nCurrentWeapon;
      this->m_eStoredWeapon = *((_DWORD *)v11 + 361);
      this->m_nOriginalWeaponAmmo = *((_DWORD *)v11 + 364);
      if ( CTheScripts::pActiveScripts )
      {
        if ( !strcmp((const char *)CTheScripts::pActiveScripts->ScriptName, "heist5") )
        {
          this->m_nOriginalWeaponAmmo = 400;
          this->m_eStoredWeapon = WEAPONTYPE_MINIGUN;
        }
      }
    }
    if ( m_nPedType > 1 )
    {
      CPed::GiveWeapon(this, nWeaponType, 0x7530u, 0);
      WeaponInfo = CWeaponInfo::GetWeaponInfo(nWeaponType, 1);
      CPed::SetCurrentWeapon(this, WeaponInfo->m_nWeaponSlot);
LABEL_24:
      CPed::PositionAttachedPed(this);
      return v6;
    }
    if ( nWeaponType )
      CPed::GiveWeapon(this, nWeaponType, 0x7530u, 0);
    this->m_pPlayerData->m_nChosenWeapon = nWeaponType;
    CPlayerPed::MakeChangesForNewWeapon((CPlayerPed *)this, nWeaponType);
    if ( nWeaponType == WEAPONTYPE_CAMERA )
    {
      v12 = 46;
    }
    else
    {
      if ( v6->m_nModelIndex == 338 && (CWeaponInfo::GetWeaponInfo(nWeaponType, 1)->m_nFlags & 4) == 0 )
      {
        CCamera::SetNewPlayerWeaponMode(&TheCamera, 65, 0, 0);
        *((_WORD *)this->m_pPlayerData + 26) |= 8u;
LABEL_23:
        this->m_nPedState = PED_SNIPER_MODE;
        goto LABEL_24;
      }
      v12 = 45;
    }
    CCamera::SetNewPlayerWeaponMode(&TheCamera, v12, 0, 0);
    goto LABEL_23;
  }
  return 0;
}
// 4A78BC: fragmented variable at 0:r2.8,8:^28.4 may be wrong
// 4A78BC: variables would overlap: 0:r2.8,8:^28.4 and ^28.4

//----- (004A7A48) --------------------------------------------------------
void __fastcall CPed::PositionAttachedPed(CPed *this)
{
  CEntity *m_pAttachToEntity; // r5
  RwFrame_0 *bdummy; // r0
  RwMatrix *LTM; // r0
  const CMatrix *m_pMat; // r1
  __int64 v6; // d16
  float v7; // s16
  float m_fCurrentHeading; // s0
  int m_nAttachLookDirn; // r0
  float v10; // s0
  float v11; // s0
  float v12; // s18
  float v13; // s0
  float *p_m_fCurrentHeading; // r5
  float v15; // s2
  float v16; // s4
  float m_fAttachHeadingLimit; // s4
  CEntity *v18; // r0
  int v19; // r1
  bool v20; // zf
  __int64 v21; // d16
  __int64 v22; // d16
  int m_nPedFlags; // r0
  CVector m_vecAttachOffset; // [sp+0h] [bp-108h] BYREF
  CMatrix v25; // [sp+10h] [bp-F8h] BYREF
  CMatrix m; // [sp+58h] [bp-B0h] BYREF
  CMatrix v27; // [sp+A0h] [bp-68h] BYREF

  m_pAttachToEntity = this->m_pAttachToEntity;
  if ( !m_pAttachToEntity )
    return;
  m.m_pRwMat = 0;
  m.m_owner = 0;
  v25.m_pRwMat = 0;
  v25.m_owner = 0;
  if ( m_pAttachToEntity->m_nModelIndex == 544
    && (bdummy = (RwFrame_0 *)m_pAttachToEntity[28].m_nFlags.bdummy) != 0
    && this->m_vecAttachOffset.z < -900.0 )
  {
    LTM = RwFrameGetLTM(bdummy);
    CMatrix::Attach(&m, LTM, 0);
    CMatrix::Detach(&m);
    m_vecAttachOffset = this->m_vecAttachOffset;
    m_vecAttachOffset.z = m_vecAttachOffset.z + 1000.0;
  }
  else
  {
    m_pMat = m_pAttachToEntity->m_pMat;
    if ( !m_pMat )
    {
      CPlaceable::AllocateMatrix(m_pAttachToEntity);
      CSimpleTransform::UpdateMatrix(&m_pAttachToEntity->m_transform, m_pAttachToEntity->m_pMat);
      m_pMat = m_pAttachToEntity->m_pMat;
    }
    CMatrix::operator=(&m, m_pMat);
    v6 = *(_QWORD *)&this->m_vecAttachOffset.x;
    m_vecAttachOffset.z = this->m_vecAttachOffset.z;
    *(_QWORD *)&m_vecAttachOffset.x = v6;
  }
  Multiply3x3((CVector *)&v27, &m, &m_vecAttachOffset);
  m.ty = v27.yx + m.ty;
  m.tx = v27.xx + m.tx;
  m.tz = v27.zx + m.tz;
  v7 = atan2f(COERCE_FLOAT(LODWORD(m.xy) ^ 0x80000000), m.yy);
  if ( this->m_nPedType > 1u )
  {
    m_nAttachLookDirn = this->m_nAttachLookDirn;
    if ( m_nAttachLookDirn == 3 )
    {
      v11 = -1.5708;
    }
    else if ( m_nAttachLookDirn == 2 )
    {
      v11 = 3.1416;
    }
    else
    {
      v10 = v7;
      if ( m_nAttachLookDirn != 1 )
        goto LABEL_18;
      v11 = 1.5708;
    }
    v10 = v7 + v11;
LABEL_18:
    v12 = CGeneral::LimitRadianAngle(v10);
    v13 = CGeneral::LimitRadianAngle(this->m_fCurrentHeading);
    p_m_fCurrentHeading = &this->m_fCurrentHeading;
    this->m_fCurrentHeading = v13;
    v15 = v13 - v12;
    if ( (float)(v13 - v12) <= 3.1416 )
    {
      if ( v15 >= -3.1416 )
        goto LABEL_23;
      v16 = 6.2832;
    }
    else
    {
      v16 = -6.2832;
    }
    v15 = v15 + v16;
LABEL_23:
    m_fAttachHeadingLimit = this->m_fAttachHeadingLimit;
    if ( v15 <= m_fAttachHeadingLimit )
    {
      if ( v15 >= (float)-m_fAttachHeadingLimit )
      {
LABEL_28:
        m_fCurrentHeading = CGeneral::LimitRadianAngle(v13);
        *p_m_fCurrentHeading = m_fCurrentHeading;
        goto LABEL_29;
      }
      v13 = v12 - m_fAttachHeadingLimit;
    }
    else
    {
      v13 = v12 + m_fAttachHeadingLimit;
    }
    *p_m_fCurrentHeading = v13;
    goto LABEL_28;
  }
  m_fCurrentHeading = this->m_fCurrentHeading;
LABEL_29:
  CMatrix::SetRotateZ(&v25, m_fCurrentHeading - v7);
  operator*(&v27, &m, &v25);
  CMatrix::operator=(&m, &v27);
  CMatrix::~CMatrix(&v27);
  CPlaceable::SetMatrix(this, &m);
  v18 = this->m_pAttachToEntity;
  v19 = *(_BYTE *)&v18->m_info & 7;
  v20 = v19 == 4;
  if ( v19 != 4 )
    v20 = v19 == 2;
  if ( v20 )
  {
    v21 = *(_QWORD *)&v18[1].m_transform.m_translate.z;
    LODWORD(this->m_vecMoveSpeed.z) = v18[1].m_pMat;
    *(_QWORD *)&this->m_vecMoveSpeed.x = v21;
    v22 = *(_QWORD *)&v18[1].m_pRwObject;
    LODWORD(this->m_vecTurnSpeed.z) = v18[1].m_nFlags.bdummy;
    *(_QWORD *)&this->m_vecTurnSpeed.x = v22;
  }
  m_nPedFlags = (int)this->m_nPedFlags;
  this->m_pGroundPhysical = 0;
  *(_DWORD *)&this->m_nPedFlags = m_nPedFlags | 1;
  CMatrix::~CMatrix(&v25);
  CMatrix::~CMatrix(&m);
}

//----- (004A7CB4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
CEntity *__fastcall CPed::AttachPedToBike(
        CPed *this,
        CEntity *pEnt,
        CVector vecPos,
        uint16 nHeading,
        float fHeadingLimit,
        float fVerticalLimit,
        eWeaponType nWeaponType)
{
  CEntity *v7; // r4
  __int64 v10; // [sp+0h] [bp-18h]

  v7 = pEnt;
  v10 = *(_QWORD *)&vecPos.z;
  if ( !CPed::AttachPedToEntity(this, pEnt, vecPos, WORD2(v10), fHeadingLimit, nWeaponType) )
    return 0;
  this->m_fAttachVerticalLimit = fVerticalLimit;
  return v7;
}
// 4A7CB4: fragmented variable at 0:r2.8,8:^20.4 may be wrong
// 4A7CB4: variables would overlap: 0:r2.8,8:^20.4 and ^20.8

//----- (004A7CF4) --------------------------------------------------------
void __fastcall CPed::DettachPedFromEntity(CPed *this)
{
  ePedState m_nPedState; // r0
  CEntity *m_pAttachToEntity; // r5
  float *p_xx; // r0
  eWeaponType m_eStoredWeapon; // r1
  CWeaponInfo *WeaponInfo; // r0
  CVector v7; // 0:r1.12

  m_nPedState = this->m_nPedState;
  m_pAttachToEntity = this->m_pAttachToEntity;
  this->m_pAttachToEntity = 0;
  if ( m_nPedState != PED_DEAD )
  {
    if ( m_nPedState == PED_DIE )
    {
      this->m_pNOCollisionVehicle = m_pAttachToEntity;
      p_xx = &m_pAttachToEntity->m_pMat->xx;
      if ( !p_xx )
      {
        CPlaceable::AllocateMatrix(m_pAttachToEntity);
        CSimpleTransform::UpdateMatrix(&m_pAttachToEntity->m_transform, m_pAttachToEntity->m_pMat);
        p_xx = &m_pAttachToEntity->m_pMat->xx;
      }
      v7.x = 0.0 - (float)(p_xx[4] * 4.0);
      v7.y = 0.0 - (float)(p_xx[5] * 4.0);
      v7.z = 4.0 - (float)(p_xx[6] * 4.0);
      CPhysical::ApplyMoveForce(this, v7);
      *(_DWORD *)&this->m_nPedFlags &= ~1u;
    }
    else
    {
      CAnimManager::BlendAnimation((RpClump_0 *)this->m_pRwObject, this->m_motionAnimGroup, ANIM_STD_IDLE, 1000.0);
      m_eStoredWeapon = this->m_eStoredWeapon;
      *(_DWORD *)&this->m_nFlags |= 1u;
      if ( m_eStoredWeapon != WEAPONTYPE_UNIDENTIFIED )
      {
        this->m_WeaponSlots[this->m_nCurrentWeapon].m_nAmmoInClip = 0;
        this->m_WeaponSlots[this->m_nCurrentWeapon].m_nAmmoTotal = 0;
        WeaponInfo = CWeaponInfo::GetWeaponInfo(this->m_eStoredWeapon, 1);
        CPed::SetCurrentWeapon(this, WeaponInfo->m_nWeaponSlot);
        this->m_WeaponSlots[this->m_nCurrentWeapon].m_nAmmoTotal = this->m_nOriginalWeaponAmmo;
        this->m_eStoredWeapon = WEAPONTYPE_UNIDENTIFIED;
      }
      if ( this->m_nPedType <= 1u )
        sub_18B1E4((CPlayerPed *)this);
    }
  }
}

//----- (004A7DFC) --------------------------------------------------------
void __fastcall CPed::Undress(CPed *this, unsigned __int8 *ModelFilename)
{
  int32 m_nModelIndex; // r6

  m_nModelIndex = this->m_nModelIndex;
  (*((void (__fastcall **)(CPed *))this->_vptr$CPlaceable + 9))(this);
  if ( this->m_nPedType < 2u )
    m_nModelIndex = 0;
  CStreaming::RequestSpecialModel(m_nModelIndex, ModelFilename, 12);
  sub_19E5E8(this);
}

//----- (004A7E36) --------------------------------------------------------
void __fastcall CPed::Dress(CPed *this)
{
  int (**v2)(void); // r0
  int m_nModelIndex; // r1

  v2 = this->_vptr$CPlaceable;
  m_nModelIndex = this->m_nModelIndex;
  this->m_nModelIndex = -1;
  ((void (__fastcall *)(CPed *, int))v2[6])(this, m_nModelIndex);
  if ( this->m_nPedState != PED_DRIVING )
    this->m_nPedState = PED_IDLE;
  CWorld::Add(this);
  this->m_fHeadingChangeRate = this->m_pPedStats->m_fMaxHeadingChange;
}

//----- (004A7E70) --------------------------------------------------------
CTaskSimpleHoldEntity *__fastcall CPed::GetHoldingTask(CPed *this)
{
  CTaskSimpleHoldEntity *result; // r0

  result = (CTaskSimpleHoldEntity *)CTaskManager::FindActiveTaskByType(&this->m_pPedIntelligence->m_taskManager, 307);
  if ( !result )
  {
    result = (CTaskSimpleHoldEntity *)CTaskManager::FindActiveTaskByType(&this->m_pPedIntelligence->m_taskManager, 308);
    if ( !result )
      return (CTaskSimpleHoldEntity *)CTaskManager::FindActiveTaskByType(&this->m_pPedIntelligence->m_taskManager, 309);
  }
  return result;
}

//----- (004A7EAC) --------------------------------------------------------
CEntity *__fastcall CPed::GetEntityThatThisPedIsHolding(CPed *this)
{
  CTask *ActiveTaskByType; // r0
  CTask *v4; // r0

  ActiveTaskByType = CTaskManager::FindActiveTaskByType(&this->m_pPedIntelligence->m_taskManager, 307);
  if ( ActiveTaskByType )
    return (CEntity *)ActiveTaskByType[1]._vptr$CTask;
  ActiveTaskByType = CTaskManager::FindActiveTaskByType(&this->m_pPedIntelligence->m_taskManager, 308);
  if ( ActiveTaskByType )
    return (CEntity *)ActiveTaskByType[1]._vptr$CTask;
  ActiveTaskByType = CTaskManager::FindActiveTaskByType(&this->m_pPedIntelligence->m_taskManager, 309);
  if ( ActiveTaskByType )
    return (CEntity *)ActiveTaskByType[1]._vptr$CTask;
  v4 = CTaskManager::FindActiveTaskByType(&this->m_pPedIntelligence->m_taskManager, 310);
  if ( v4 )
    return (CEntity *)v4[1].m_pParent;
  else
    return 0;
}

//----- (004A7F02) --------------------------------------------------------
bool8 __fastcall CPed::CanThrowEntityThatThisPedIsHolding(CPed *this)
{
  CTaskSimpleHoldEntity *ActiveTaskByType; // r0

  ActiveTaskByType = (CTaskSimpleHoldEntity *)CTaskManager::FindActiveTaskByType(
                                                &this->m_pPedIntelligence->m_taskManager,
                                                307);
  return (ActiveTaskByType
       || (ActiveTaskByType = (CTaskSimpleHoldEntity *)CTaskManager::FindActiveTaskByType(
                                                         &this->m_pPedIntelligence->m_taskManager,
                                                         308)) != 0
       || (ActiveTaskByType = (CTaskSimpleHoldEntity *)CTaskManager::FindActiveTaskByType(
                                                         &this->m_pPedIntelligence->m_taskManager,
                                                         309)) != 0)
      && CTaskSimpleHoldEntity::CanThrowEntity(ActiveTaskByType);
}

//----- (004A7F42) --------------------------------------------------------
CEntity *__fastcall CPed::GiveObjectToPedToHold(CPed *this, int32 modelIndex, bool8 dropCurrentObj)
{
  int v5; // r6
  CTask *ActiveTaskByType; // r5
  CTask *v7; // r0
  _DWORD *p_m_pParent; // r0
  bool v9; // zf
  char *v10; // r6
  CMatrix *m_pMat; // r0
  int v12; // r1
  CSimpleTransform *p_tx; // r5
  __int64 v14; // kr00_8
  RwReal z; // r0
  RwReal *v16; // r1
  CPedIntelligence *m_pPedIntelligence; // r8
  CTaskSimpleHoldEntity *v18; // r4
  CTask *v19; // r0
  CVector pVecOffset; // [sp+14h] [bp-1Ch] BYREF

  v5 = dropCurrentObj;
  ActiveTaskByType = CTaskManager::FindActiveTaskByType(&this->m_pPedIntelligence->m_taskManager, 307);
  v7 = CTaskManager::FindActiveTaskByType(&this->m_pPedIntelligence->m_taskManager, 307);
  if ( v7
    || (v7 = CTaskManager::FindActiveTaskByType(&this->m_pPedIntelligence->m_taskManager, 308)) != 0
    || (v7 = CTaskManager::FindActiveTaskByType(&this->m_pPedIntelligence->m_taskManager, 309)) != 0 )
  {
    p_m_pParent = &v7[1]._vptr$CTask;
  }
  else
  {
    v19 = CTaskManager::FindActiveTaskByType(&this->m_pPedIntelligence->m_taskManager, 310);
    if ( !v19 )
      goto LABEL_17;
    p_m_pParent = &v19[1].m_pParent;
  }
  v9 = v5 == 0;
  if ( v5 )
    v9 = *p_m_pParent == 0;
  if ( !v9 )
  {
    CPed::DropEntityThatThisPedIsHolding(this, 1u);
    goto LABEL_9;
  }
LABEL_17:
  if ( ActiveTaskByType )
    return 0;
LABEL_9:
  v10 = (char *)CObject::operator new(0x184u);
  CObject::CObject((CObject *)v10, modelIndex, 0);
  m_pMat = this->m_pMat;
  v12 = *((_DWORD *)v10 + 5);
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &this->m_transform;
  v14 = *(_QWORD *)&p_tx->m_translate.x;
  z = p_tx->m_translate.z;
  if ( v12 )
  {
    *(_DWORD *)(v12 + 48) = v14;
    *(_DWORD *)(*((_DWORD *)v10 + 5) + 52) = HIDWORD(v14);
    v16 = (RwReal *)(*((_DWORD *)v10 + 5) + 56);
  }
  else
  {
    v16 = (RwReal *)(v10 + 12);
    *(_QWORD *)(v10 + 4) = v14;
  }
  *v16 = z;
  CWorld::Add((CEntity *)v10);
  memset(&pVecOffset, 0, sizeof(pVecOffset));
  m_pPedIntelligence = this->m_pPedIntelligence;
  v18 = (CTaskSimpleHoldEntity *)CTask::operator new(0x3Cu);
  CTaskSimpleHoldEntity::CTaskSimpleHoldEntity(
    v18,
    (CEntity *)v10,
    &pVecOffset,
    6u,
    0x10u,
    ANIM_STD_NUM,
    ANIM_STD_PED,
    1);
  CTaskManager::SetTaskSecondary(&m_pPedIntelligence->m_taskManager, v18, 4);
  return (CEntity *)v10;
}

//----- (004A804E) --------------------------------------------------------
void __fastcall CPed::GiveWeaponAtStartOfFight(CPed *this)
{
  unsigned int m_nPedType; // r0
  int v3; // r0
  CTaskSimpleHoldEntity *v4; // r0
  bool v5; // zf
  int m_nWeaponSlot; // r1
  unsigned int RandomSeed; // r0
  CTaskSimpleHoldEntity *TaskHold; // r0
  bool v9; // zf
  CWeaponInfo *WeaponInfo; // r0

  if ( this->CharCreatedBy != 2 && this->m_WeaponSlots[this->m_nCurrentWeapon].m_eWeaponType == WEAPONTYPE_UNARMED )
  {
    m_nPedType = this->m_nPedType;
    if ( m_nPedType <= 0x16 )
    {
      v3 = 1 << m_nPedType;
      if ( (v3 & (unsigned int)&elf_hash_chain[16262]) != 0 )
      {
        if ( ((this->RandomSeed >> 4) & 0x3Fu) <= 0x18 && this->m_eDelayedWeapon == WEAPONTYPE_UNIDENTIFIED )
          goto LABEL_8;
      }
      else if ( (v3 & 0x520000) != 0 )
      {
        RandomSeed = this->RandomSeed;
        if ( (RandomSeed & 0x3F8) <= 0xC7 && this->m_eDelayedWeapon == WEAPONTYPE_UNIDENTIFIED )
        {
          TaskHold = CPedIntelligence::GetTaskHold(this->m_pPedIntelligence, 0);
          v9 = TaskHold == 0;
          if ( TaskHold )
            v9 = TaskHold->m_pHoldEntity == 0;
          if ( !v9 && TaskHold->m_nBoneId == 6 )
            CPed::DropEntityThatThisPedIsHolding(this, 1u);
          if ( this->m_eDelayedWeapon == WEAPONTYPE_UNIDENTIFIED )
          {
            this->m_eDelayedWeapon = WEAPONTYPE_KNIFE;
            this->m_delayedAmmo = 50;
            CPed::RequestDelayedWeapon(this);
          }
          WeaponInfo = CWeaponInfo::GetWeaponInfo(WEAPONTYPE_KNIFE, 1);
          CPed::SetCurrentWeapon(this, WeaponInfo->m_nWeaponSlot);
          RandomSeed = this->RandomSeed;
        }
        if ( ((RandomSeed >> 4) & 0x3F) <= 0x18 && this->m_eDelayedWeapon == WEAPONTYPE_UNIDENTIFIED )
        {
          if ( this->m_nPedType < 2u )
          {
LABEL_14:
            this->m_eDelayedWeapon = WEAPONTYPE_PISTOL;
            this->m_delayedAmmo = 50;
            CPed::RequestDelayedWeapon(this);
LABEL_15:
            m_nWeaponSlot = CWeaponInfo::GetWeaponInfo(WEAPONTYPE_PISTOL, 1)->m_nWeaponSlot;
            CPed::SetCurrentWeapon(this, m_nWeaponSlot);
            return;
          }
LABEL_8:
          v4 = CPedIntelligence::GetTaskHold(this->m_pPedIntelligence, 0);
          v5 = v4 == 0;
          if ( v4 )
            v5 = v4->m_pHoldEntity == 0;
          if ( !v5 && v4->m_nBoneId == 6 )
            CPed::DropEntityThatThisPedIsHolding(this, 1u);
          if ( this->m_eDelayedWeapon != WEAPONTYPE_UNIDENTIFIED )
            goto LABEL_15;
          goto LABEL_14;
        }
      }
    }
  }
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (004A8174) --------------------------------------------------------
void __fastcall CPed::GiveWeaponWhenJoiningGang(CPed *this)
{
  eWeaponType m_eWeaponType; // r0
  bool v3; // zf
  CTaskSimpleHoldEntity *TaskHold; // r0
  bool v5; // zf
  eWeaponType v6; // r0
  unsigned int m_nPedType; // r0
  CTaskSimpleHoldEntity *v8; // r0
  bool v9; // zf
  CTaskSimpleHoldEntity *v10; // r0
  bool v11; // zf
  int m_nWeaponSlot; // r1

  m_eWeaponType = this->m_WeaponSlots[this->m_nCurrentWeapon].m_eWeaponType;
  v3 = m_eWeaponType == WEAPONTYPE_UNARMED;
  if ( m_eWeaponType == WEAPONTYPE_UNARMED )
    v3 = this->m_eDelayedWeapon == WEAPONTYPE_UNIDENTIFIED;
  if ( v3 )
  {
    if ( CCheat::m_aCheatsActive[85] )
    {
      if ( this->m_nPedType >= 2u )
      {
        TaskHold = CPedIntelligence::GetTaskHold(this->m_pPedIntelligence, 0);
        v5 = TaskHold == 0;
        if ( TaskHold )
          v5 = TaskHold->m_pHoldEntity == 0;
        if ( !v5 && TaskHold->m_nBoneId == 6 )
          CPed::DropEntityThatThisPedIsHolding(this, 1u);
      }
      if ( this->m_eDelayedWeapon == WEAPONTYPE_UNIDENTIFIED )
      {
        this->m_eDelayedWeapon = WEAPONTYPE_AK47;
        this->m_delayedAmmo = 200;
        CPed::RequestDelayedWeapon(this);
      }
      v6 = WEAPONTYPE_AK47;
    }
    else
    {
      m_nPedType = this->m_nPedType;
      if ( CCheat::m_aCheatsActive[86] )
      {
        if ( m_nPedType >= 2 )
        {
          v8 = CPedIntelligence::GetTaskHold(this->m_pPedIntelligence, 0);
          v9 = v8 == 0;
          if ( v8 )
            v9 = v8->m_pHoldEntity == 0;
          if ( !v9 && v8->m_nBoneId == 6 )
            CPed::DropEntityThatThisPedIsHolding(this, 1u);
        }
        if ( this->m_eDelayedWeapon == WEAPONTYPE_UNIDENTIFIED )
        {
          this->m_eDelayedWeapon = WEAPONTYPE_ROCKETLAUNCHER;
          this->m_delayedAmmo = 200;
          CPed::RequestDelayedWeapon(this);
        }
        v6 = WEAPONTYPE_ROCKETLAUNCHER;
      }
      else
      {
        if ( m_nPedType >= 2 )
        {
          v10 = CPedIntelligence::GetTaskHold(this->m_pPedIntelligence, 0);
          v11 = v10 == 0;
          if ( v10 )
            v11 = v10->m_pHoldEntity == 0;
          if ( !v11 && v10->m_nBoneId == 6 )
            CPed::DropEntityThatThisPedIsHolding(this, 1u);
        }
        if ( this->m_eDelayedWeapon == WEAPONTYPE_UNIDENTIFIED )
        {
          this->m_eDelayedWeapon = WEAPONTYPE_PISTOL;
          this->m_delayedAmmo = 200;
          CPed::RequestDelayedWeapon(this);
        }
        v6 = WEAPONTYPE_PISTOL;
      }
    }
    m_nWeaponSlot = CWeaponInfo::GetWeaponInfo(v6, 1)->m_nWeaponSlot;
    CPed::SetCurrentWeapon(this, m_nWeaponSlot);
  }
}

//----- (004A829C) --------------------------------------------------------
bool8 __fastcall CPed::IsPlayingHandSignal(CPed *this)
{
  return CTaskManager::FindActiveTaskByType(&this->m_pPedIntelligence->m_taskManager, 426) != 0;
}

//----- (004A82B6) --------------------------------------------------------
void __fastcall CPed::StopPlayingHandSignal(CPed *this)
{
  CTask *ActiveTaskByType; // r0

  ActiveTaskByType = CTaskManager::FindActiveTaskByType(&this->m_pPedIntelligence->m_taskManager, 426);
  if ( ActiveTaskByType )
    (*((void (__fastcall **)(CTask *, CPed *, int, _DWORD))ActiveTaskByType->_vptr$CTask + 7))(
      ActiveTaskByType,
      this,
      1,
      0);
}

//----- (004A82E0) --------------------------------------------------------
float __fastcall CPed::GetWalkAnimSpeed(CPed *this)
{
  CAnimBlendHierarchy *m_pAnimBlendHierarchy; // r4
  CAnimBlendSequence *m_pSequences; // r5
  int m_iNumKeyFrames; // r0
  int v4; // r0
  int v5; // r3

  m_pAnimBlendHierarchy = CAnimManager::GetAnimAssociation(this->m_motionAnimGroup, ANIM_STD_WALK)->m_pAnimBlendHierarchy;
  m_pSequences = m_pAnimBlendHierarchy->m_pSequences;
  CAnimManager::UncompressAnimation(m_pAnimBlendHierarchy);
  m_iNumKeyFrames = m_pSequences->m_iNumKeyFrames;
  if ( m_iNumKeyFrames < 1 )
    return 0.0;
  v4 = m_iNumKeyFrames - 1;
  v5 = 20 * v4;
  if ( (m_pSequences->m_bitsFlag & 2) != 0 )
    v5 = 32 * v4;
  return (float)(*(float *)&m_pSequences->m_pKeyFrames[v5 + 24] - *((float *)m_pSequences->m_pKeyFrames + 6))
       / m_pAnimBlendHierarchy->m_fTotalTime;
}

//----- (004A8340) --------------------------------------------------------
bool __fastcall CPed::UseFreeAimMagnetize(CPed *this)
{
  return 0;
}

//----- (004A8344) --------------------------------------------------------
void __fastcall CPed::SetWeaponLockOnTarget(CPed *this, CEntity *pEntLockOnTarget)
{
  CEntity **p_m_pEntLockOnTarget; // r9
  int v5; // r1
  CEntity *v6; // r0
  CEntity *m_pEntMagnetizeTarget; // r0

  p_m_pEntLockOnTarget = &this->m_pEntLockOnTarget;
  if ( this->m_pEntLockOnTarget )
  {
    v5 = rand();
    v6 = *p_m_pEntLockOnTarget;
    CPlayerPed::bSwipeTargetHeads = v5 % 10 == 0;
    if ( v6 )
      CEntity::CleanUpOldReference(v6, p_m_pEntLockOnTarget);
  }
  else
  {
    CPlayerPed::bSwipeTargetHeads = 0;
  }
  this->m_pEntLockOnTarget = 0;
  m_pEntMagnetizeTarget = this->m_pEntMagnetizeTarget;
  if ( m_pEntMagnetizeTarget )
    CEntity::CleanUpOldReference(m_pEntMagnetizeTarget, &this->m_pEntMagnetizeTarget);
  this->m_pEntMagnetizeTarget = 0;
  if ( pEntLockOnTarget )
  {
    if ( !CPedIntelligence::IsInACarOrEnteringOne(this->m_pPedIntelligence) )
    {
      *p_m_pEntLockOnTarget = pEntLockOnTarget;
      sub_196050(pEntLockOnTarget, p_m_pEntLockOnTarget);
    }
  }
}

//----- (004A83F0) --------------------------------------------------------
void __fastcall CPed::GetHeadAndFootPositions(CPed *this, CVector *vecPedHead, CVector *vecPedFeet, bool bOffset)
{
  _BOOL4 v5; // r8
  RpHAnimHierarchy_0 *AnimHierarchyFromSkinClump; // r6
  RwInt32 v9; // r4
  RwMatrix *v10; // r0
  __int64 v11; // d16
  RwInt32 v12; // r11
  RwMatrix *MatrixArray; // r4
  RwInt32 v14; // r5
  float *p_x; // r4
  RwMatrix *v16; // r0
  RwReal v17; // s2
  RwReal v18; // s4
  RwReal v19; // s2
  RwReal v20; // s4
  RwReal v21; // s2
  RwReal v22; // s4
  RwV3d_0 v23; // [sp+4h] [bp-4Ch] BYREF
  RwV3d_0 vectorsIn; // [sp+10h] [bp-40h] BYREF
  RwV3d_0 v25; // [sp+1Ch] [bp-34h] BYREF
  RwV3d_0 vectorsOut; // [sp+28h] [bp-28h] BYREF

  v5 = bOffset;
  AnimHierarchyFromSkinClump = GetAnimHierarchyFromSkinClump((RpClump_0 *)this->m_pRwObject);
  v9 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, this->m_aPedFrames[2]->boneTag);
  v10 = &RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump)[v9];
  v11 = *(_QWORD *)&v10->pos.x;
  vecPedHead->z = v10->pos.z;
  *(_QWORD *)&vecPedHead->x = v11;
  v12 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, this->m_aPedFrames[9]->boneTag);
  MatrixArray = RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump);
  v14 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, this->m_aPedFrames[10]->boneTag);
  p_x = &MatrixArray[v12].right.x;
  v16 = &RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump)[v14];
  v17 = (float)(p_x[13] + v16->pos.y) * 0.5;
  v18 = (float)(p_x[14] + v16->pos.z) * 0.5;
  vecPedFeet->x = (float)(p_x[12] + v16->pos.x) * 0.5;
  vecPedFeet->y = v17;
  vecPedFeet->z = v18;
  if ( v5 )
  {
    memset(&v25, 0, sizeof(v25));
    memset(&vectorsOut, 0, sizeof(vectorsOut));
    vectorsIn.y = 0.0;
    v23.y = 0.0;
    v23.x = -0.5;
    vectorsIn.x = 0.5;
    v23.z = -0.2;
    vectorsIn.z = 0.2;
    RwV3dTransformVectors(&vectorsOut, &vectorsIn, 1, (const RwMatrix *)&TheCamera.m_cameraMatrix);
    RwV3dTransformVectors(&v25, &v23, 1, (const RwMatrix *)&TheCamera.m_cameraMatrix);
    v19 = vectorsOut.y + vecPedHead->y;
    v20 = vectorsOut.z + vecPedHead->z;
    vecPedHead->x = vectorsOut.x + vecPedHead->x;
    vecPedHead->y = v19;
    vecPedHead->z = v20;
    v21 = v25.y + vecPedFeet->y;
    v22 = v25.z + vecPedFeet->z;
    vecPedFeet->x = v25.x + vecPedFeet->x;
    vecPedFeet->y = v21;
    vecPedFeet->z = v22;
  }
}

//----- (004A8568) --------------------------------------------------------
const unsigned __int8 *__fastcall CPed::GetPedStateString(CPed *this)
{
  ePedState m_nPedState; // r0

  m_nPedState = this->m_nPedState;
  if ( (unsigned int)m_nPedState <= PED_DEPLOY_STINGER )
    return (const unsigned __int8 *)off_668CD0[m_nPedState];
  else
    return "UNKNOWN STATE";
}
// 668CD0: using guessed type char *off_668CD0[14];

//----- (004A8594) --------------------------------------------------------
void __fastcall CPedTaskPair::Flush(CPedTaskPair *this)
{
  CTask *m_pTask; // r0

  m_pTask = this->m_pTask;
  this->m_pPed = 0;
  if ( m_pTask )
    (*((void (__fastcall **)(CTask *))m_pTask->_vptr$CTask + 1))(m_pTask);
  this->m_pTask = 0;
  this->m_iSlot = -1;
}

//----- (004A85B4) --------------------------------------------------------
void __fastcall CPedAttractor::CPedAttractor(
        CPedAttractor *this,
        C2dEffect *pEffect,
        CEntity *pEntity,
        const int iMoveState,
        const int iMaxNoOfPeds,
        const float fSpacing,
        const float fAchieveQueueTime,
        const float fAchieveQueueShuffleTime,
        const float fArriveRange,
        const float fHeadingRange,
        const float fDeltaPos,
        const float fDeltaHeading)
{
  CVector *p_m_vUseDir; // r9
  CVector *p_m_vQueueDir; // r10
  CVector *p_m_vPos; // r8
  CEntity **p_m_pEntity; // r6
  CPlaceable *v18; // r6
  const CMatrix *m_pMat; // r1
  __int64 v20; // d16
  __int64 v21; // d16
  __int64 v22; // d16
  __int64 v23; // d16
  CMatrix v24; // [sp+0h] [bp-80h] BYREF
  CVector v; // [sp+48h] [bp-38h] BYREF
  CVector v26; // [sp+58h] [bp-28h] BYREF

  this->m_pEffect = pEffect;
  this->m_pedTaskPairs.dataPtr = 0;
  this->m_iMaxNoOfPeds = iMaxNoOfPeds;
  p_m_vUseDir = &this->m_vUseDir;
  p_m_vQueueDir = &this->m_vQueueDir;
  p_m_vPos = &this->m_vPos;
  this->m_iMoveState = iMoveState;
  this->m_fSpacing = fSpacing;
  this->m_fAchieveQueueTime = fAchieveQueueTime;
  this->m_fAchieveQueueShuffleTime = fAchieveQueueShuffleTime;
  this->m_fArriveRange = fArriveRange;
  this->m_fHeadingRange = fHeadingRange;
  *(_QWORD *)&this->m_arrivedPeds.numEntries = 0LL;
  *(_QWORD *)&this->m_pedTaskPairs.numAlloced = 0LL;
  this->m_fDeltaPos = fDeltaPos;
  *(_QWORD *)&this->m_attractPeds.numAlloced = 0LL;
  *(_QWORD *)&this->m_attractPeds.dataPtr = 0LL;
  this->m_fDeltaHeading = fDeltaHeading;
  this->_vptr$CPedAttractor = (int (**)(void))&off_668DE8;
  this->m_pEntity = pEntity;
  p_m_pEntity = &this->m_pEntity;
  if ( pEntity )
  {
    CEntity::RegisterReference(pEntity, &this->m_pEntity);
    v18 = *p_m_pEntity;
  }
  else
  {
    v18 = 0;
  }
  v24.m_pRwMat = 0;
  v24.m_owner = 0;
  if ( v18 )
  {
    m_pMat = v18->m_pMat;
    if ( !m_pMat )
    {
      CPlaceable::AllocateMatrix(v18);
      CSimpleTransform::UpdateMatrix(&v18->m_transform, v18->m_pMat);
      m_pMat = v18->m_pMat;
    }
    CMatrix::operator=(&v24, m_pMat);
  }
  else
  {
    CMatrix::SetScale(&v24, 1.0);
  }
  CVector::FromMultiply(p_m_vPos, &v24, &pEffect->m_posn);
  v20 = *(_QWORD *)&pEffect->attr.l.m_colour._anon_0._anon_0.red;
  v.z = pEffect->attr.l.m_size;
  *(_QWORD *)&v.x = v20;
  Multiply3x3(&v26, &v24, &v);
  v21 = *(_QWORD *)&v26.x;
  p_m_vQueueDir->z = v26.z;
  *(_QWORD *)&p_m_vQueueDir->x = v21;
  v22 = *(_QWORD *)&pEffect->attr.es.Coors2X;
  v.z = pEffect->attr.q.m_useDir.z;
  *(_QWORD *)&v.x = v22;
  Multiply3x3(&v26, &v24, &v);
  v23 = *(_QWORD *)&v26.x;
  p_m_vUseDir->z = v26.z;
  *(_QWORD *)&p_m_vUseDir->x = v23;
  sprintf(this->m_scriptName, this->m_pEffect->attr.q.m_scriptName);
  CMatrix::~CMatrix(&v24);
}
// 668DE8: using guessed type void *off_668DE8;

//----- (004A86F0) --------------------------------------------------------
void __fastcall CPedAttractorManager::ComputeEffectPos(const C2dEffect *pEffect, const CMatrix *mat, CVector *vPos)
{
  sub_198720(vPos, mat, &pEffect->m_posn);
}

//----- (004A86FA) --------------------------------------------------------
void __fastcall CPedAttractorManager::ComputeEffectQueueDir(
        const C2dEffect *pEffect,
        const CMatrix *mat,
        CVector *vQueueDir)
{
  __int64 v3; // d16
  __int64 v5; // d16
  CVector v6; // [sp+0h] [bp-28h] BYREF
  CVector v7; // [sp+10h] [bp-18h] BYREF

  v3 = *(_QWORD *)&pEffect->attr.l.m_colour._anon_0._anon_0.red;
  v6.z = pEffect->attr.l.m_size;
  *(_QWORD *)&v6.x = v3;
  Multiply3x3(&v7, mat, &v6);
  v5 = *(_QWORD *)&v7.x;
  vQueueDir->z = v7.z;
  *(_QWORD *)&vQueueDir->x = v5;
}

//----- (004A8726) --------------------------------------------------------
void __fastcall CPedAttractorManager::ComputeEffectUseDir(
        const C2dEffect *pEffect,
        const CMatrix *mat,
        CVector *vUseDir)
{
  __int64 v3; // d16
  __int64 v5; // d16
  CVector v6; // [sp+0h] [bp-28h] BYREF
  CVector v7; // [sp+10h] [bp-18h] BYREF

  v3 = *(_QWORD *)&pEffect->attr.es.Coors2X;
  v6.z = pEffect->attr.q.m_useDir.z;
  *(_QWORD *)&v6.x = v3;
  Multiply3x3(&v7, mat, &v6);
  v5 = *(_QWORD *)&v7.x;
  vUseDir->z = v7.z;
  *(_QWORD *)&vUseDir->x = v5;
}

//----- (004A8752) --------------------------------------------------------
int __fastcall CPedAttractor::ComputeFreeSlot(const CPedAttractor *this)
{
  return this->m_arrivedPeds.numEntries;
}

//----- (004A8756) --------------------------------------------------------
int __fastcall CPedAttractor::GetNoOfRegisteredPeds(const CPedAttractor *this)
{
  return this->m_arrivedPeds.numEntries + this->m_attractPeds.numEntries;
}

//----- (004A8760) --------------------------------------------------------
CTask *__fastcall CPedAttractor::GetTaskForPed(const CPedAttractor *this, CPed *pPed)
{
  signed int numEntries; // r2
  bool *p_m_bUsedTask; // r5
  signed int v4; // r0
  CTask *v6; // r4
  size_t v7; // r2
  unsigned int v8; // r3
  const CTask **dataPtr; // r0

  numEntries = this->m_pedTaskPairs.numEntries;
  if ( numEntries < 1 )
    return 0;
  p_m_bUsedTask = &this->m_pedTaskPairs.dataPtr->m_bUsedTask;
  v4 = 0;
  while ( *((CPed **)p_m_bUsedTask - 4) != pPed )
  {
    ++v4;
    p_m_bUsedTask += 20;
    if ( v4 >= numEntries )
      return 0;
  }
  v6 = (CTask *)*((_DWORD *)p_m_bUsedTask - 3);
  if ( !*p_m_bUsedTask && CPedAttractor::ms_tasks.numEntries )
  {
    v7 = 4 * CPedAttractor::ms_tasks.numEntries - 4;
    v8 = 0;
    dataPtr = CPedAttractor::ms_tasks.dataPtr;
    while ( *dataPtr != v6 )
    {
      ++v8;
      ++dataPtr;
      v7 -= 4;
      if ( v8 >= CPedAttractor::ms_tasks.numEntries )
        goto LABEL_7;
    }
    memmove(dataPtr, dataPtr + 1, v7);
    --CPedAttractor::ms_tasks.numEntries;
  }
LABEL_7:
  *p_m_bUsedTask = 1;
  return v6;
}

//----- (004A87EC) --------------------------------------------------------
void __fastcall CPedAttractor::SetTaskForPed(CPedAttractor *this, CPed *pPed, CTask *pTask)
{
  signed int numEntries; // r5
  bool *p_m_bUsedTask; // r4
  signed int v8; // r0
  unsigned int v9; // r11
  CPedTaskPair *v10; // r0
  CPedTaskPair *v11; // r9
  CPedTaskPair *dataPtr; // r4
  CPedTaskPair *v13; // r1
  unsigned int v14; // r6
  unsigned int v15; // r9
  void *v16; // r5
  const CTask **v17; // r4
  const CTask *v18; // r0
  unsigned int v19; // r6
  size_t v20; // r2
  const CTask **v21; // r3
  unsigned int v22; // r9
  const CTask **v23; // r4
  __int16 v24; // [sp+1h] [bp-1Fh]
  bool v25; // [sp+3h] [bp-1Dh]

  numEntries = this->m_pedTaskPairs.numEntries;
  if ( numEntries < 1 )
  {
LABEL_5:
    if ( this->m_pedTaskPairs.numAlloced >= numEntries + 1 )
    {
      dataPtr = this->m_pedTaskPairs.dataPtr;
    }
    else
    {
      v9 = 4 * (numEntries + 1) / 3u + 3;
      v10 = (CPedTaskPair *)malloc(20 * v9);
      v11 = this->m_pedTaskPairs.dataPtr;
      dataPtr = v10;
      if ( v11 )
      {
        memmove(v10, this->m_pedTaskPairs.dataPtr, 20 * numEntries);
        free(v11);
        numEntries = this->m_pedTaskPairs.numEntries;
      }
      this->m_pedTaskPairs.dataPtr = dataPtr;
      this->m_pedTaskPairs.numAlloced = v9;
    }
    dataPtr[numEntries].m_pPed = pPed;
    v13 = &dataPtr[numEntries];
    v13->m_pTask = pTask;
    v13->m_iSlot = -1;
    v13->m_matchID = 0;
    v13->m_bUsedTask = 0;
    *(&v13->m_bUsedTask + 3) = v25;
    *(_WORD *)(&v13->m_bUsedTask + 1) = v24;
    ++this->m_pedTaskPairs.numEntries;
    v14 = CPedAttractor::ms_tasks.numEntries;
    if ( CPedAttractor::ms_tasks.numAlloced >= CPedAttractor::ms_tasks.numEntries + 1 )
    {
      v16 = CPedAttractor::ms_tasks.dataPtr;
    }
    else
    {
      v15 = 4 * (CPedAttractor::ms_tasks.numEntries + 1) / 3 + 3;
      v16 = malloc(4 * v15);
      v17 = CPedAttractor::ms_tasks.dataPtr;
      if ( CPedAttractor::ms_tasks.dataPtr )
      {
        memmove(v16, CPedAttractor::ms_tasks.dataPtr, 4 * v14);
        free(v17);
        v14 = CPedAttractor::ms_tasks.numEntries;
      }
      CPedAttractor::ms_tasks.dataPtr = (const CTask **)v16;
      CPedAttractor::ms_tasks.numAlloced = v15;
    }
  }
  else
  {
    p_m_bUsedTask = &this->m_pedTaskPairs.dataPtr->m_bUsedTask;
    v8 = 0;
    while ( *((CPed **)p_m_bUsedTask - 4) != pPed )
    {
      ++v8;
      p_m_bUsedTask += 20;
      if ( v8 >= numEntries )
        goto LABEL_5;
    }
    if ( !*p_m_bUsedTask )
    {
      v18 = (const CTask *)*((_DWORD *)p_m_bUsedTask - 3);
      if ( v18 )
      {
        if ( !CPedAttractor::ms_tasks.numEntries )
          goto LABEL_25;
        v19 = 0;
        v20 = 4 * CPedAttractor::ms_tasks.numEntries - 4;
        v21 = CPedAttractor::ms_tasks.dataPtr;
        while ( *v21 != v18 )
        {
          ++v19;
          ++v21;
          v20 -= 4;
          if ( v19 >= CPedAttractor::ms_tasks.numEntries )
            goto LABEL_24;
        }
        memmove(v21, v21 + 1, v20);
        --CPedAttractor::ms_tasks.numEntries;
        v18 = (const CTask *)*((_DWORD *)p_m_bUsedTask - 3);
LABEL_24:
        if ( v18 )
LABEL_25:
          (*((void (__fastcall **)(const CTask *))v18->_vptr$CTask + 1))(v18);
      }
    }
    *p_m_bUsedTask = 0;
    *((_DWORD *)p_m_bUsedTask - 3) = pTask;
    v14 = CPedAttractor::ms_tasks.numEntries;
    if ( CPedAttractor::ms_tasks.numAlloced >= CPedAttractor::ms_tasks.numEntries + 1 )
    {
      v16 = CPedAttractor::ms_tasks.dataPtr;
    }
    else
    {
      v22 = 4 * (CPedAttractor::ms_tasks.numEntries + 1) / 3 + 3;
      v16 = malloc(4 * v22);
      v23 = CPedAttractor::ms_tasks.dataPtr;
      if ( CPedAttractor::ms_tasks.dataPtr )
      {
        memmove(v16, CPedAttractor::ms_tasks.dataPtr, 4 * v14);
        free(v23);
        v14 = CPedAttractor::ms_tasks.numEntries;
      }
      CPedAttractor::ms_tasks.dataPtr = (const CTask **)v16;
      CPedAttractor::ms_tasks.numAlloced = v22;
    }
  }
  *((_DWORD *)v16 + v14) = pTask;
  ++CPedAttractor::ms_tasks.numEntries;
}
// 4A88A0: variable 'v25' is possibly undefined
// 4A88A2: variable 'v24' is possibly undefined

//----- (004A8A3C) --------------------------------------------------------
bool __fastcall CPedAttractor::IsRegisteredWithPed(const CPedAttractor *this, const CPed *pPed)
{
  signed int numEntries; // r12
  int v3; // r2
  signed int v4; // r12
  CPed **dataPtr; // r0
  int v7; // r3

  numEntries = this->m_attractPeds.numEntries;
  if ( numEntries < 1 )
  {
LABEL_5:
    v4 = this->m_arrivedPeds.numEntries;
    if ( v4 < 1 )
      return 0;
    dataPtr = this->m_arrivedPeds.dataPtr;
    v7 = 0;
    while ( dataPtr[v7] != pPed )
    {
      if ( ++v7 >= v4 )
        return 0;
    }
  }
  else
  {
    v3 = 0;
    while ( this->m_attractPeds.dataPtr[v3] != pPed )
    {
      if ( ++v3 >= numEntries )
        goto LABEL_5;
    }
  }
  return 1;
}

//----- (004A8A86) --------------------------------------------------------
bool __fastcall CPedAttractor::RegisterPed(CPedAttractor *this, CPed *pPed)
{
  unsigned int numEntries; // r6
  size_t v5; // r2
  CPed **dataPtr; // r0
  unsigned int v7; // r1
  unsigned int v8; // r10
  CPed **v9; // r0
  CPed **v10; // r8
  CPed **v11; // r9
  unsigned int v13; // r9
  float m_fAchieveQueueTime; // s16
  CTaskComplexGoToAttractor *v15; // r6
  float fAttractHeading; // [sp+10h] [bp-30h] BYREF
  CVector v17[3]; // [sp+14h] [bp-2Ch] BYREF

  numEntries = this->m_attractPeds.numEntries;
  if ( numEntries )
  {
    v5 = 4 * numEntries - 4;
    dataPtr = this->m_attractPeds.dataPtr;
    v7 = 0;
    while ( *dataPtr != pPed )
    {
      ++v7;
      ++dataPtr;
      v5 -= 4;
      if ( v7 >= numEntries )
        goto LABEL_5;
    }
    memmove(dataPtr, dataPtr + 1, v5);
    --this->m_attractPeds.numEntries;
    return 0;
  }
  else
  {
LABEL_5:
    if ( (signed int)(this->m_arrivedPeds.numEntries + numEntries) >= this->m_iMaxNoOfPeds )
    {
      return 0;
    }
    else
    {
      if ( this->m_attractPeds.numAlloced >= numEntries + 1 )
      {
        v11 = this->m_attractPeds.dataPtr;
      }
      else
      {
        v8 = 4 * (numEntries + 1) / 3 + 3;
        v9 = (CPed **)malloc(4 * v8);
        v10 = this->m_attractPeds.dataPtr;
        v11 = v9;
        if ( v10 )
        {
          memmove(v9, this->m_attractPeds.dataPtr, 4 * numEntries);
          free(v10);
          numEntries = this->m_attractPeds.numEntries;
        }
        this->m_attractPeds.dataPtr = v11;
        this->m_attractPeds.numAlloced = v8;
      }
      v11[numEntries] = pPed;
      v13 = this->m_arrivedPeds.numEntries;
      ++this->m_attractPeds.numEntries;
      (*((void (__fastcall **)(CPedAttractor *, unsigned int, CVector *))this->_vptr$CPedAttractor + 4))(this, v13, v17);
      (*((void (__fastcall **)(CPedAttractor *, unsigned int, float *))this->_vptr$CPedAttractor + 5))(
        this,
        v13,
        &fAttractHeading);
      m_fAchieveQueueTime = this->m_fAchieveQueueTime;
      v15 = (CTaskComplexGoToAttractor *)CTask::operator new(0x2Cu);
      CTaskComplexGoToAttractor::CTaskComplexGoToAttractor(
        v15,
        this,
        v17,
        fAttractHeading,
        m_fAchieveQueueTime,
        v13,
        this->m_iMoveState);
      CPedAttractor::SetTaskForPed(this, pPed, v15);
      return 1;
    }
  }
}

//----- (004A8B8A) --------------------------------------------------------
void __fastcall CPedAttractor::ComputeAttractTime(
        const CPedAttractor *this,
        const int iSlot,
        bool bHasArrived,
        float *fAttractTime)
{
  float *p_m_fAchieveQueueTime; // r1

  p_m_fAchieveQueueTime = &this->m_fAchieveQueueTime;
  if ( bHasArrived )
    p_m_fAchieveQueueTime = &this->m_fAchieveQueueShuffleTime;
  *fAttractTime = *p_m_fAchieveQueueTime;
}

//----- (004A8B9C) --------------------------------------------------------
void __fastcall CPedAttractor::ComputeAttractPos(const CPedAttractor *this, const int iSlot, CVector *vAttractPos)
{
  float m_fSpacing; // s12
  RwReal v6; // s4
  RwReal v7; // s0
  float m_fDeltaPos; // s16
  float v9; // s16

  if ( this->m_pEffect )
  {
    m_fSpacing = this->m_fSpacing;
    v6 = this->m_vPos.y - (float)((float)(this->m_vQueueDir.y * (float)iSlot) * m_fSpacing);
    v7 = this->m_vPos.z - (float)((float)(this->m_vQueueDir.z * (float)iSlot) * m_fSpacing);
    vAttractPos->x = this->m_vPos.x - (float)((float)(this->m_vQueueDir.x * (float)iSlot) * m_fSpacing);
    vAttractPos->y = v6;
    vAttractPos->z = v7;
    if ( iSlot )
    {
      m_fDeltaPos = this->m_fDeltaPos;
      vAttractPos->x = vAttractPos->x
                     + (float)((float)((float)(m_fDeltaPos + m_fDeltaPos) * (float)((float)rand() * 4.6566e-10))
                             - m_fDeltaPos);
      v9 = this->m_fDeltaPos;
      vAttractPos->y = vAttractPos->y + (float)((float)((float)(v9 + v9) * (float)((float)rand() * 4.6566e-10)) - v9);
    }
  }
}

//----- (004A8C6C) --------------------------------------------------------
float __fastcall CPedAttractor::ComputeDeltaPos(const CPedAttractor *this)
{
  float m_fDeltaPos; // s16

  m_fDeltaPos = this->m_fDeltaPos;
  return (float)((float)(m_fDeltaPos + m_fDeltaPos) * (float)((float)rand() * 4.6566e-10)) - m_fDeltaPos;
}

//----- (004A8CA8) --------------------------------------------------------
void __fastcall CPedAttractor::ComputeAttractHeading(
        const CPedAttractor *this,
        const int iSlot,
        float *fAttractHeading)
{
  float m_fDeltaHeading; // s16
  float RadianAngleBetweenPoints; // s0

  if ( this->m_pEffect )
  {
    if ( iSlot )
    {
      *fAttractHeading = CGeneral::GetRadianAngleBetweenPoints(this->m_vQueueDir.x, this->m_vQueueDir.y, 0.0, 0.0);
      m_fDeltaHeading = this->m_fDeltaHeading;
      RadianAngleBetweenPoints = *fAttractHeading
                               + (float)((float)((float)(m_fDeltaHeading + m_fDeltaHeading)
                                               * (float)((float)rand() * 4.6566e-10))
                                       - m_fDeltaHeading);
    }
    else
    {
      RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(this->m_vUseDir.x, this->m_vUseDir.y, 0.0, 0.0);
    }
    *fAttractHeading = RadianAngleBetweenPoints;
  }
}

//----- (004A8D14) --------------------------------------------------------
float __fastcall CPedAttractor::ComputeDeltaHeading(const CPedAttractor *this)
{
  float m_fDeltaHeading; // s16

  m_fDeltaHeading = this->m_fDeltaHeading;
  return (float)((float)(m_fDeltaHeading + m_fDeltaHeading) * (float)((float)rand() * 4.6566e-10)) - m_fDeltaHeading;
}

//----- (004A8D50) --------------------------------------------------------
bool __fastcall CPedAttractor::BroadcastArrival(CPedAttractor *this, CPed *pPed)
{
  unsigned int numEntries; // r4
  int v5; // r0
  unsigned int v6; // r2
  CPed *v7; // r3
  int v8; // r6
  unsigned int v9; // r9
  CPed **v10; // r0
  CPed **v11; // r8
  CPed **dataPtr; // r6
  unsigned int v13; // r1
  size_t v14; // r2
  CPed **v15; // r0
  unsigned int v16; // r3
  unsigned int v17; // r0
  unsigned int v18; // r8
  unsigned int v19; // r4
  CPed *v20; // r11
  float m_fAchieveQueueTime; // s16
  CTaskComplexGoToAttractor *v22; // r6
  CTaskComplexUsePairedAttractor *v23; // r4
  CTaskComplexWaitAtAttractor *v24; // r6
  signed int v25; // r0
  int v26; // r1
  int v27; // r2
  CPed *v28; // r4
  CPedAttractor *v29; // r0
  CPed *v30; // r1
  CTask *v31; // r2
  float fAttractHeading; // [sp+10h] [bp-38h] BYREF
  CVector v34[4]; // [sp+14h] [bp-34h] BYREF

  numEntries = this->m_arrivedPeds.numEntries;
  if ( !numEntries )
    goto LABEL_38;
  v5 = 0;
  v6 = 0;
  do
  {
    v7 = this->m_arrivedPeds.dataPtr[v6];
    v8 = 0;
    ++v6;
    if ( v7 == pPed )
      v8 = 1;
    v5 |= v8;
  }
  while ( v6 < numEntries && v7 != pPed );
  if ( !(v5 << 31) )
  {
LABEL_38:
    if ( this->m_arrivedPeds.numAlloced >= numEntries + 1 )
    {
      dataPtr = this->m_arrivedPeds.dataPtr;
    }
    else
    {
      v9 = 4 * (numEntries + 1) / 3 + 3;
      v10 = (CPed **)malloc(4 * v9);
      v11 = this->m_arrivedPeds.dataPtr;
      dataPtr = v10;
      if ( v11 )
      {
        memmove(v10, this->m_arrivedPeds.dataPtr, 4 * numEntries);
        free(v11);
        numEntries = this->m_arrivedPeds.numEntries;
      }
      this->m_arrivedPeds.dataPtr = dataPtr;
      this->m_arrivedPeds.numAlloced = v9;
    }
    dataPtr[numEntries] = pPed;
    v13 = this->m_attractPeds.numEntries;
    ++this->m_arrivedPeds.numEntries;
    if ( v13 )
    {
      v14 = 4 * v13 - 4;
      v15 = this->m_attractPeds.dataPtr;
      v16 = 0;
      while ( *v15 != pPed )
      {
        ++v16;
        ++v15;
        v14 -= 4;
        if ( v16 >= v13 )
          goto LABEL_19;
      }
      memmove(v15, v15 + 1, v14);
      v17 = this->m_attractPeds.numEntries - 1;
      this->m_attractPeds.numEntries = v17;
      if ( !v17 )
        goto LABEL_21;
LABEL_19:
      v18 = 0;
      do
      {
        v19 = this->m_arrivedPeds.numEntries;
        v20 = this->m_attractPeds.dataPtr[v18];
        (*((void (__fastcall **)(CPedAttractor *, unsigned int, CVector *))this->_vptr$CPedAttractor + 4))(
          this,
          v19,
          v34);
        (*((void (__fastcall **)(CPedAttractor *, unsigned int, float *))this->_vptr$CPedAttractor + 5))(
          this,
          v19,
          &fAttractHeading);
        m_fAchieveQueueTime = this->m_fAchieveQueueTime;
        v22 = (CTaskComplexGoToAttractor *)CTask::operator new(0x2Cu);
        CTaskComplexGoToAttractor::CTaskComplexGoToAttractor(
          v22,
          this,
          v34,
          fAttractHeading,
          m_fAchieveQueueTime,
          v19,
          4);
        CPedAttractor::SetTaskForPed(this, v20, v22);
        ++v18;
      }
      while ( v18 < this->m_attractPeds.numEntries );
    }
  }
LABEL_21:
  if ( (*((int (__fastcall **)(CPedAttractor *, CPed *))this->_vptr$CPedAttractor + 3))(this, pPed) == 1 )
  {
    if ( ((int (__fastcall *)(CPedAttractor *))*this->_vptr$CPedAttractor)(this) == 7 )
    {
      v23 = (CTaskComplexUsePairedAttractor *)CTask::operator new(0x24u);
      CTaskComplexUsePairedAttractor::CTaskComplexUsePairedAttractor(v23, this);
    }
    else
    {
      v23 = (CTaskComplexUsePairedAttractor *)CTask::operator new(0x10u);
      CTaskComplexUseAttractor::CTaskComplexUseAttractor((CTaskComplexUseAttractor *)v23, this);
    }
    v29 = this;
    v30 = pPed;
    v31 = v23;
  }
  else
  {
    v24 = (CTaskComplexWaitAtAttractor *)CTask::operator new(0x14u);
    v25 = this->m_arrivedPeds.numEntries;
    if ( v25 < 1 )
    {
      v27 = -1;
    }
    else
    {
      v26 = 0;
      v27 = -1;
      do
      {
        v28 = this->m_arrivedPeds.dataPtr[v26];
        if ( v28 == pPed )
          v27 = v26;
        ++v26;
      }
      while ( v26 < v25 && v28 != pPed );
    }
    CTaskComplexWaitAtAttractor::CTaskComplexWaitAtAttractor(v24, this, v27);
    v29 = this;
    v30 = pPed;
    v31 = v24;
  }
  CPedAttractor::SetTaskForPed(v29, v30, v31);
  return 1;
}

//----- (004A8F06) --------------------------------------------------------
int __fastcall CPedAttractor::GetQueueSlot(const CPedAttractor *this, const CPed *pPed)
{
  signed int numEntries; // r12
  int result; // r0
  CPed **dataPtr; // lr
  int v5; // r3
  const CPed *v6; // r2

  numEntries = this->m_arrivedPeds.numEntries;
  if ( numEntries < 1 )
    return -1;
  dataPtr = this->m_arrivedPeds.dataPtr;
  v5 = 0;
  result = -1;
  do
  {
    v6 = dataPtr[v5];
    if ( v6 == pPed )
      result = v5;
    ++v5;
  }
  while ( v5 < numEntries && v6 != pPed );
  return result;
}

//----- (004A8F3C) --------------------------------------------------------
bool __fastcall CPedAttractor::IsAtHeadOfQueue(const CPedAttractor *this, CPed *pPed)
{
  return *this->m_arrivedPeds.dataPtr == pPed;
}

//----- (004A8F4A) --------------------------------------------------------
CPed *__fastcall CPedAttractor::GetHeadOfQueue(const CPedAttractor *this)
{
  if ( this->m_arrivedPeds.numEntries )
    return **(CPed ***)((char *)&dword_20 + (_DWORD)this);
  else
    return 0;
}
// 20: using guessed type int dword_20;

//----- (004A8F58) --------------------------------------------------------
CPed *__fastcall CPedAttractor::GetTailOfQueue(const CPedAttractor *this)
{
  unsigned int numEntries; // r1

  numEntries = this->m_arrivedPeds.numEntries;
  if ( numEntries )
    return *(CPed **)(*(int *)((char *)&dword_20 + (_DWORD)this) + 4 * numEntries - 4);
  else
    return 0;
}
// 20: using guessed type int dword_20;

//----- (004A8F6C) --------------------------------------------------------
bool __fastcall CPedAttractor::BroadcastDeparture(CPedAttractor *this, CPed *pLeavingPed)
{
  signed int v3; // r0
  signed int numEntries; // r5
  int v5; // r11
  CPed *v6; // r2
  int v7; // r10
  int v8; // r6
  float m_fAchieveQueueShuffleTime; // s16
  CTaskComplexSequence *v10; // r9
  CTaskSimpleStandStill *v11; // r8
  CTaskComplexGoToAttractor *v12; // r5
  unsigned int v13; // r1
  CPedTaskPair *dataPtr; // r0
  size_t v15; // r2
  unsigned int v16; // r3
  signed int v17; // r0
  unsigned int v18; // r6
  int v19; // r11
  int i; // r8
  CPed *v21; // r10
  float m_fAchieveQueueTime; // s16
  CTaskComplexGoToAttractor *v23; // r5
  unsigned int v26; // [sp+14h] [bp-44h]
  CPed *pPed; // [sp+1Ch] [bp-3Ch]
  float fAttractHeading; // [sp+20h] [bp-38h] BYREF
  CVector vAttractPos; // [sp+24h] [bp-34h] BYREF

  v3 = 0;
  numEntries = this->m_arrivedPeds.numEntries;
  if ( numEntries >= 1 )
  {
    v5 = -1;
    do
    {
      v6 = this->m_arrivedPeds.dataPtr[v3];
      if ( v6 == pLeavingPed )
        v5 = v3;
      ++v3;
    }
    while ( v3 < numEntries && v6 != pLeavingPed );
    if ( v5 < 0 )
    {
      LOBYTE(v3) = 0;
    }
    else
    {
      v7 = v5 + 1;
      if ( v5 + 1 < numEntries )
      {
        v26 = this->m_arrivedPeds.numEntries;
        v8 = 2000 * v5 + 2000;
        do
        {
          pPed = this->m_arrivedPeds.dataPtr[v7];
          (*((void (__fastcall **)(CPedAttractor *, int, CVector *))this->_vptr$CPedAttractor + 4))(
            this,
            v7 - 1,
            &vAttractPos);
          (*((void (__fastcall **)(CPedAttractor *, int, float *))this->_vptr$CPedAttractor + 5))(
            this,
            v7 - 1,
            &fAttractHeading);
          m_fAchieveQueueShuffleTime = this->m_fAchieveQueueShuffleTime;
          v10 = (CTaskComplexSequence *)CTask::operator new(0x40u);
          CTaskComplexSequence::CTaskComplexSequence(v10);
          v11 = (CTaskSimpleStandStill *)CTask::operator new(0x20u);
          CTaskSimpleStandStill::CTaskSimpleStandStill(v11, v8, 0, 0, 8.0);
          CTaskComplexSequence::AddTask(v10, v11);
          v12 = (CTaskComplexGoToAttractor *)CTask::operator new(0x2Cu);
          CTaskComplexGoToAttractor::CTaskComplexGoToAttractor(
            v12,
            this,
            &vAttractPos,
            fAttractHeading,
            m_fAchieveQueueShuffleTime,
            v7 - 1,
            4);
          CTaskComplexSequence::AddTask(v10, v12);
          CPedAttractor::SetTaskForPed(this, pPed, v10);
          ++v7;
          v8 += 2000;
        }
        while ( v26 != v7 );
      }
      v13 = this->m_pedTaskPairs.numEntries;
      if ( v13 )
      {
        dataPtr = this->m_pedTaskPairs.dataPtr;
        v15 = 20 * v13 - 20;
        v16 = 0;
        while ( dataPtr->m_pPed != pLeavingPed )
        {
          ++v16;
          ++dataPtr;
          v15 -= 20;
          if ( v16 >= v13 )
            goto LABEL_18;
        }
        memmove(dataPtr, &dataPtr[1], v15);
        --this->m_pedTaskPairs.numEntries;
      }
LABEL_18:
      memmove(
        &this->m_arrivedPeds.dataPtr[v5],
        &this->m_arrivedPeds.dataPtr[v5 + 1],
        4 * (this->m_arrivedPeds.numEntries + 0x3FFFFFFF - v5));
      v17 = this->m_attractPeds.numEntries;
      v18 = this->m_arrivedPeds.numEntries - 1;
      this->m_arrivedPeds.numEntries = v18;
      if ( v17 >= 1 )
      {
        v19 = v17 - 1;
        for ( i = 0; ; ++i )
        {
          v21 = this->m_attractPeds.dataPtr[i];
          (*((void (__fastcall **)(CPedAttractor *, unsigned int, CVector *))this->_vptr$CPedAttractor + 4))(
            this,
            v18,
            &vAttractPos);
          (*((void (__fastcall **)(CPedAttractor *, unsigned int, float *))this->_vptr$CPedAttractor + 5))(
            this,
            v18,
            &fAttractHeading);
          m_fAchieveQueueTime = this->m_fAchieveQueueTime;
          v23 = (CTaskComplexGoToAttractor *)CTask::operator new(0x2Cu);
          CTaskComplexGoToAttractor::CTaskComplexGoToAttractor(
            v23,
            this,
            &vAttractPos,
            fAttractHeading,
            m_fAchieveQueueTime,
            v18,
            4);
          CPedAttractor::SetTaskForPed(this, v21, v23);
          if ( v19 == i )
            break;
          v18 = this->m_arrivedPeds.numEntries;
        }
      }
      LOBYTE(v3) = 1;
    }
  }
  return v3;
}

//----- (004A912A) --------------------------------------------------------
bool __fastcall CPedAttractor::DeRegisterPed(CPedAttractor *this, CPed *pPed)
{
  unsigned int numEntries; // r1
  CPedTaskPair *dataPtr; // r0
  size_t v6; // r2
  unsigned int v7; // r3
  unsigned int v8; // r1
  size_t v9; // r2
  CPed **v10; // r0
  unsigned int v11; // r3

  numEntries = this->m_pedTaskPairs.numEntries;
  if ( numEntries )
  {
    dataPtr = this->m_pedTaskPairs.dataPtr;
    v6 = 20 * numEntries - 20;
    v7 = 0;
    while ( dataPtr->m_pPed != pPed )
    {
      ++v7;
      ++dataPtr;
      v6 -= 20;
      if ( v7 >= numEntries )
        goto LABEL_7;
    }
    memmove(dataPtr, &dataPtr[1], v6);
    --this->m_pedTaskPairs.numEntries;
  }
LABEL_7:
  v8 = this->m_attractPeds.numEntries;
  if ( !v8 )
    return (*((int (__fastcall **)(CPedAttractor *, CPed *))this->_vptr$CPedAttractor + 6))(this, pPed);
  v9 = 4 * v8 - 4;
  v10 = this->m_attractPeds.dataPtr;
  v11 = 0;
  while ( *v10 != pPed )
  {
    ++v11;
    ++v10;
    v9 -= 4;
    if ( v11 >= v8 )
      return (*((int (__fastcall **)(CPedAttractor *, CPed *))this->_vptr$CPedAttractor + 6))(this, pPed);
  }
  memmove(v10, v10 + 1, v9);
  --this->m_attractPeds.numEntries;
  return 1;
}

//----- (004A91B0) --------------------------------------------------------
void __fastcall CPedAttractor::AbortPedTasks(CPedAttractor *this)
{
  signed int numEntries; // r5
  int v3; // r4
  CPedTaskPair *v4; // r6
  CTask *m_pTask; // r0

  numEntries = this->m_pedTaskPairs.numEntries;
  if ( numEntries >= 1 )
  {
    v3 = 0;
    do
    {
      v4 = &this->m_pedTaskPairs.dataPtr[v3];
      m_pTask = v4->m_pTask;
      v4->m_pPed = 0;
      if ( m_pTask )
        (*((void (__fastcall **)(CTask *))m_pTask->_vptr$CTask + 1))(m_pTask);
      ++v3;
      --numEntries;
      v4->m_pTask = 0;
      v4->m_iSlot = -1;
    }
    while ( numEntries );
  }
}

//----- (004A91F4) --------------------------------------------------------
void *__fastcall CPedAttractor::operator new(size_t nSize)
{
  int v1; // lr
  CPedAttractorPool *v2; // r1
  void *result; // r0
  void *m_nSize; // r12
  uint8 *m_aFlags; // r2
  int v6; // r3

  v1 = 0;
  v2 = CPools::ms_pPedAttractorPool;
  result = (void *)CPools::ms_pPedAttractorPool->m_nFreeIndex;
  m_nSize = (void *)CPools::ms_pPedAttractorPool->m_nSize;
  do
  {
    result = (char *)result + 1;
    v2->m_nFreeIndex = (int32)result;
    if ( result == m_nSize )
    {
      result = 0;
      v2->m_nFreeIndex = 0;
      if ( v1 << 31 )
        return result;
      v1 = 1;
    }
    m_aFlags = v2->m_aFlags;
    v6 = *((char *)result + (_DWORD)m_aFlags);
  }
  while ( v6 > -1 );
  *((_BYTE *)result + (_DWORD)m_aFlags) = v6 & 0x7F;
  v2->m_aFlags[v2->m_nFreeIndex] = (v2->m_aFlags[v2->m_nFreeIndex] + 1) & 0x7F | v2->m_aFlags[v2->m_nFreeIndex] & 0x80;
  return v2->m_aStorage[v2->m_nFreeIndex];
}

//----- (004A9258) --------------------------------------------------------
void __fastcall CPedAttractor::operator delete(void *pVoid)
{
  CPedAttractorPool *v1; // r1
  int v2; // r0

  v1 = CPools::ms_pPedAttractorPool;
  v2 = -1601513229 * ((signed int)((int)pVoid - (unsigned int)CPools::ms_pPedAttractorPool->m_aStorage) >> 2);
  CPools::ms_pPedAttractorPool->m_aFlags[v2] |= 0x80u;
  if ( v2 < v1->m_nFreeIndex )
    v1->m_nFreeIndex = v2;
}

//----- (004A9288) --------------------------------------------------------
bool __fastcall CPedShelterAttractor::IsAtHeadOfQueue(const CPedShelterAttractor *this, CPed *pPed)
{
  return 1;
}

//----- (004A928C) --------------------------------------------------------
void __fastcall CPedShelterAttractor::ComputeAttractPos(
        const CPedShelterAttractor *this,
        const int iSlot,
        CVector *vAttractPos)
{
  const CVector *Displacement; // r0
  RwReal v6; // s2
  RwReal v7; // s4

  if ( this->m_pEffect )
  {
    Displacement = CPedShelterAttractor::GetDisplacement(iSlot);
    v6 = this->m_vPos.y + Displacement->y;
    v7 = this->m_vPos.z + Displacement->z;
    vAttractPos->x = this->m_vPos.x + Displacement->x;
    vAttractPos->y = v6;
    vAttractPos->z = v7;
  }
}

//----- (004A92D4) --------------------------------------------------------
const CVector *__fastcall CPedShelterAttractor::GetDisplacement(const int iSlot)
{
  int v1; // r11
  float v2; // r5
  float v3; // r6
  float v4; // r5
  int v5; // r0
  unsigned int numEntries; // r9
  float v7; // s0
  float v8; // s24
  float v9; // s26
  signed int v10; // r1
  int v11; // r2
  CVector *v12; // r3
  unsigned int v13; // r8
  CVector *dataPtr; // r5
  CVector *v15; // r6
  CVector *v16; // r0

  if ( !CPedShelterAttractor::ms_displacements.numEntries )
  {
    v1 = 0;
    do
    {
      do
      {
        v2 = (float)((float)((float)rand() * 4.6566e-10) * 6.2832) + 0.0;
        v3 = cosf(v2);
        v4 = sinf(v2);
        v5 = rand();
        numEntries = CPedShelterAttractor::ms_displacements.numEntries;
        v7 = (float)((float)((float)v5 * 4.6566e-10) + (float)((float)v5 * 4.6566e-10)) + 0.0;
        v8 = v4 * v7;
        v9 = v3 * v7;
        if ( (int)CPedShelterAttractor::ms_displacements.numEntries < 1 )
          break;
        v10 = 0;
        v11 = 0;
        do
        {
          v12 = &CPedShelterAttractor::ms_displacements.dataPtr[v10];
          if ( (float)((float)(v12->z * v12->z)
                     + (float)((float)((float)(v12->x - v9) * (float)(v12->x - v9))
                             + (float)((float)(v12->y - v8) * (float)(v12->y - v8)))) < 1.0 )
          {
            v11 = 1;
            v10 = CPedShelterAttractor::ms_displacements.numEntries;
          }
          ++v10;
        }
        while ( v10 < (int)CPedShelterAttractor::ms_displacements.numEntries );
      }
      while ( v11 << 31 );
      if ( CPedShelterAttractor::ms_displacements.numAlloced >= CPedShelterAttractor::ms_displacements.numEntries + 1 )
      {
        dataPtr = CPedShelterAttractor::ms_displacements.dataPtr;
      }
      else
      {
        v13 = 4 * (CPedShelterAttractor::ms_displacements.numEntries + 1) / 3 + 3;
        dataPtr = (CVector *)malloc(12 * v13);
        v15 = CPedShelterAttractor::ms_displacements.dataPtr;
        if ( CPedShelterAttractor::ms_displacements.dataPtr )
        {
          memmove(dataPtr, CPedShelterAttractor::ms_displacements.dataPtr, 12 * numEntries);
          free(v15);
          numEntries = CPedShelterAttractor::ms_displacements.numEntries;
        }
        CPedShelterAttractor::ms_displacements.dataPtr = dataPtr;
        CPedShelterAttractor::ms_displacements.numAlloced = v13;
      }
      ++v1;
      v16 = &dataPtr[numEntries];
      v16->z = 0.0;
      v16->x = v9;
      v16->y = v8;
      ++CPedShelterAttractor::ms_displacements.numEntries;
    }
    while ( v1 != 5 );
  }
  return &CPedShelterAttractor::ms_displacements.dataPtr[iSlot];
}

//----- (004A94D4) --------------------------------------------------------
void __fastcall CPedShelterAttractor::ComputeAttractHeading(
        const CPedShelterAttractor *this,
        const int iSlot,
        float *fAttractHeading)
{
  *fAttractHeading = (float)((float)((float)rand() * 4.6566e-10) * 6.2832) + 0.0;
}

//----- (004A9510) --------------------------------------------------------
bool __fastcall CPedShelterAttractor::BroadcastDeparture(CPedShelterAttractor *this, CPed *pLeavingPed)
{
  signed int v3; // r0
  signed int numEntries; // lr
  int v5; // r5
  CPed *v6; // r6
  unsigned int v7; // r12
  CPedTaskPair *dataPtr; // r0
  size_t v9; // r2
  unsigned int v10; // r6
  signed int v11; // r0
  unsigned int v12; // r6
  int v13; // r11
  int i; // r8
  CPed *v15; // r10
  float m_fAchieveQueueTime; // s16
  CTaskComplexGoToAttractor *v17; // r5
  float fAttractHeading; // [sp+10h] [bp-38h] BYREF
  CVector v20[4]; // [sp+14h] [bp-34h] BYREF

  v3 = 0;
  numEntries = this->m_arrivedPeds.numEntries;
  if ( numEntries >= 1 )
  {
    v5 = -1;
    do
    {
      v6 = this->m_arrivedPeds.dataPtr[v3];
      if ( v6 == pLeavingPed )
        v5 = v3;
      ++v3;
    }
    while ( v3 < numEntries && v6 != pLeavingPed );
    if ( v5 < 0 )
    {
      LOBYTE(v3) = 0;
    }
    else
    {
      v7 = this->m_pedTaskPairs.numEntries;
      if ( v7 )
      {
        dataPtr = this->m_pedTaskPairs.dataPtr;
        v9 = 20 * v7 - 20;
        v10 = 0;
        while ( dataPtr->m_pPed != pLeavingPed )
        {
          ++v10;
          ++dataPtr;
          v9 -= 20;
          if ( v10 >= v7 )
            goto LABEL_15;
        }
        memmove(dataPtr, &dataPtr[1], v9);
        numEntries = this->m_arrivedPeds.numEntries;
        --this->m_pedTaskPairs.numEntries;
      }
LABEL_15:
      memmove(
        &this->m_arrivedPeds.dataPtr[v5],
        &this->m_arrivedPeds.dataPtr[v5 + 1],
        4 * (0x3FFFFFFF - v5 + numEntries));
      v11 = this->m_attractPeds.numEntries;
      v12 = this->m_arrivedPeds.numEntries - 1;
      this->m_arrivedPeds.numEntries = v12;
      if ( v11 >= 1 )
      {
        v13 = v11 - 1;
        for ( i = 0; ; ++i )
        {
          v15 = this->m_attractPeds.dataPtr[i];
          (*((void (__fastcall **)(CPedShelterAttractor *, unsigned int, CVector *))this->_vptr$CPedAttractor + 4))(
            this,
            v12,
            v20);
          (*((void (__fastcall **)(CPedShelterAttractor *, unsigned int, float *))this->_vptr$CPedAttractor + 5))(
            this,
            v12,
            &fAttractHeading);
          m_fAchieveQueueTime = this->m_fAchieveQueueTime;
          v17 = (CTaskComplexGoToAttractor *)CTask::operator new(0x2Cu);
          CTaskComplexGoToAttractor::CTaskComplexGoToAttractor(
            v17,
            this,
            v20,
            fAttractHeading,
            m_fAchieveQueueTime,
            v12,
            4);
          CPedAttractor::SetTaskForPed(this, v15, v17);
          if ( v13 == i )
            break;
          v12 = this->m_arrivedPeds.numEntries;
        }
      }
      LOBYTE(v3) = 1;
    }
  }
  return v3;
}

//----- (004A9624) --------------------------------------------------------
CPedAttractorManager *GetPedAttractorManager()
{
  CPedAttractorManager *result; // r0

  result = GetPedAttractorManager(void)::p;
  if ( !GetPedAttractorManager(void)::p )
  {
    result = (CPedAttractorManager *)operator new(0x78u);
    result->m_steps.numEntries = 0;
    result->m_steps.dataPtr = 0;
    *(_QWORD *)&result->m_parks.numAlloced = 0LL;
    *(_QWORD *)&result->m_parks.dataPtr = 0LL;
    *(_QWORD *)&result->m_lookAts.dataPtr = 0LL;
    *(_QWORD *)&result->m_scripted.numEntries = 0LL;
    *(_QWORD *)&result->m_triggerScripts.numEntries = 0LL;
    *(_QWORD *)&result->m_lookAts.numAlloced = 0LL;
    *(_QWORD *)&result->m_shelters.numAlloced = 0LL;
    *(_QWORD *)&result->m_shelters.dataPtr = 0LL;
    *(_QWORD *)&result->m_stops.dataPtr = 0LL;
    *(_QWORD *)&result->m_pizzas.numEntries = 0LL;
    *(_QWORD *)&result->m_seats.numAlloced = 0LL;
    *(_QWORD *)&result->m_seats.dataPtr = 0LL;
    *(_QWORD *)&result->m_atms.numEntries = 0LL;
    *(_QWORD *)&result->m_stops.numAlloced = 0LL;
    GetPedAttractorManager(void)::p = result;
  }
  return result;
}

//----- (004A968C) --------------------------------------------------------
void __fastcall CPedAttractorManager::RestoreStuffFromMem(CPedAttractorManager *this)
{
  CPedAttractorPool *v2; // r10
  int32 m_nSize; // r0
  int v4; // r4
  int v5; // r5
  CPedAttractor *v6; // r9
  unsigned int numEntries; // r8
  CPedAttractor **v8; // r0
  CPedAttractor **v9; // r1
  CPedAttractor **dataPtr; // r6
  size_t v11; // r2
  CPedAttractor **v12; // r8
  unsigned int v13; // r8
  CPedAttractor **v14; // r0
  CPedAttractor **v15; // r1
  CPedAttractor **v16; // r6
  size_t v17; // r2
  CPedAttractor **v18; // r8
  unsigned int v19; // r8
  CPedAttractor **v20; // r0
  CPedAttractor **v21; // r1
  CPedAttractor **v22; // r6
  size_t v23; // r2
  CPedAttractor **v24; // r8
  unsigned int v25; // r8
  CPedAttractor **v26; // r0
  CPedAttractor **v27; // r1
  CPedAttractor **v28; // r6
  size_t v29; // r2
  CPedAttractor **v30; // r8
  unsigned int v31; // r8
  CPedAttractor **v32; // r0
  CPedAttractor **v33; // r1
  CPedAttractor **v34; // r6
  size_t v35; // r2
  CPedAttractor **v36; // r8
  unsigned int v37; // r8
  CPedAttractor **v38; // r0
  CPedAttractor **v39; // r1
  CPedAttractor **v40; // r6
  size_t v41; // r2
  CPedAttractor **v42; // r8
  unsigned int v43; // r8
  CPedAttractor **v44; // r0
  CPedAttractor **v45; // r1
  CPedAttractor **v46; // r6
  size_t v47; // r2
  CPedAttractor **v48; // r8
  unsigned int v49; // r8
  CPedAttractor **v50; // r0
  CPedAttractor **v51; // r1
  CPedAttractor **v52; // r6
  size_t v53; // r2
  CPedAttractor **v54; // r8
  unsigned int v55; // r8
  CPedAttractor **v56; // r0
  CPedAttractor **v57; // r1
  CPedAttractor **v58; // r6
  size_t v59; // r2
  CPedAttractor **v60; // r8
  unsigned int v61; // r8
  CPedAttractor **v62; // r0
  CPedAttractor **v63; // r1
  CPedAttractor **v64; // r6
  size_t v65; // r2
  CPedAttractor **v66; // r8
  unsigned int v67; // [sp+0h] [bp-20h]
  unsigned int v68; // [sp+0h] [bp-20h]
  unsigned int v69; // [sp+0h] [bp-20h]
  unsigned int v70; // [sp+0h] [bp-20h]
  unsigned int v71; // [sp+0h] [bp-20h]
  unsigned int v72; // [sp+0h] [bp-20h]
  unsigned int v73; // [sp+0h] [bp-20h]
  unsigned int v74; // [sp+0h] [bp-20h]
  unsigned int v75; // [sp+0h] [bp-20h]
  unsigned int v76; // [sp+0h] [bp-20h]

  this->m_atms.numEntries = 0;
  this->m_seats.numEntries = 0;
  this->m_stops.numEntries = 0;
  this->m_pizzas.numEntries = 0;
  this->m_shelters.numEntries = 0;
  this->m_triggerScripts.numEntries = 0;
  this->m_lookAts.numEntries = 0;
  this->m_scripted.numEntries = 0;
  this->m_parks.numEntries = 0;
  this->m_steps.numEntries = 0;
  v2 = CPools::ms_pPedAttractorPool;
  m_nSize = CPools::ms_pPedAttractorPool->m_nSize;
  if ( m_nSize )
  {
    v4 = m_nSize - 1;
    v5 = 236 * m_nSize - 236;
    do
    {
      if ( (v2->m_aFlags[v4] & 0x80u) == 0 )
      {
        v6 = (CPedAttractor *)&(*v2->m_aStorage)[v5];
        if ( v6 )
        {
          switch ( (**(int (__fastcall ***)(uint8 *))&(*v2->m_aStorage)[v5])(&(*v2->m_aStorage)[v5]) )
          {
            case 0:
              numEntries = this->m_atms.numEntries;
              if ( this->m_atms.numAlloced >= numEntries + 1 )
              {
                dataPtr = this->m_atms.dataPtr;
              }
              else
              {
                v67 = 4 * (numEntries + 1) / 3 + 3;
                v8 = (CPedAttractor **)malloc(4 * v67);
                v9 = this->m_atms.dataPtr;
                dataPtr = v8;
                if ( v9 )
                {
                  v11 = 4 * numEntries;
                  v12 = this->m_atms.dataPtr;
                  memmove(v8, v9, v11);
                  free(v12);
                  numEntries = this->m_atms.numEntries;
                }
                this->m_atms.dataPtr = dataPtr;
                this->m_atms.numAlloced = v67;
              }
              dataPtr[numEntries] = v6;
              ++this->m_atms.numEntries;
              break;
            case 1:
              v13 = this->m_seats.numEntries;
              if ( this->m_seats.numAlloced >= v13 + 1 )
              {
                v16 = this->m_seats.dataPtr;
              }
              else
              {
                v68 = 4 * (v13 + 1) / 3 + 3;
                v14 = (CPedAttractor **)malloc(4 * v68);
                v15 = this->m_seats.dataPtr;
                v16 = v14;
                if ( v15 )
                {
                  v17 = 4 * v13;
                  v18 = this->m_seats.dataPtr;
                  memmove(v14, v15, v17);
                  free(v18);
                  v13 = this->m_seats.numEntries;
                }
                this->m_seats.dataPtr = v16;
                this->m_seats.numAlloced = v68;
              }
              v16[v13] = v6;
              ++this->m_seats.numEntries;
              break;
            case 2:
              v19 = this->m_stops.numEntries;
              if ( this->m_stops.numAlloced >= v19 + 1 )
              {
                v22 = this->m_stops.dataPtr;
              }
              else
              {
                v69 = 4 * (v19 + 1) / 3 + 3;
                v20 = (CPedAttractor **)malloc(4 * v69);
                v21 = this->m_stops.dataPtr;
                v22 = v20;
                if ( v21 )
                {
                  v23 = 4 * v19;
                  v24 = this->m_stops.dataPtr;
                  memmove(v20, v21, v23);
                  free(v24);
                  v19 = this->m_stops.numEntries;
                }
                this->m_stops.dataPtr = v22;
                this->m_stops.numAlloced = v69;
              }
              v22[v19] = v6;
              ++this->m_stops.numEntries;
              break;
            case 3:
              v25 = this->m_pizzas.numEntries;
              if ( this->m_pizzas.numAlloced >= v25 + 1 )
              {
                v28 = this->m_pizzas.dataPtr;
              }
              else
              {
                v70 = 4 * (v25 + 1) / 3 + 3;
                v26 = (CPedAttractor **)malloc(4 * v70);
                v27 = this->m_pizzas.dataPtr;
                v28 = v26;
                if ( v27 )
                {
                  v29 = 4 * v25;
                  v30 = this->m_pizzas.dataPtr;
                  memmove(v26, v27, v29);
                  free(v30);
                  v25 = this->m_pizzas.numEntries;
                }
                this->m_pizzas.dataPtr = v28;
                this->m_pizzas.numAlloced = v70;
              }
              v28[v25] = v6;
              ++this->m_pizzas.numEntries;
              break;
            case 4:
              v31 = this->m_shelters.numEntries;
              if ( this->m_shelters.numAlloced >= v31 + 1 )
              {
                v34 = this->m_shelters.dataPtr;
              }
              else
              {
                v71 = 4 * (v31 + 1) / 3 + 3;
                v32 = (CPedAttractor **)malloc(4 * v71);
                v33 = this->m_shelters.dataPtr;
                v34 = v32;
                if ( v33 )
                {
                  v35 = 4 * v31;
                  v36 = this->m_shelters.dataPtr;
                  memmove(v32, v33, v35);
                  free(v36);
                  v31 = this->m_shelters.numEntries;
                }
                this->m_shelters.dataPtr = v34;
                this->m_shelters.numAlloced = v71;
              }
              v34[v31] = v6;
              ++this->m_shelters.numEntries;
              break;
            case 5:
              v37 = this->m_triggerScripts.numEntries;
              if ( this->m_triggerScripts.numAlloced >= v37 + 1 )
              {
                v40 = this->m_triggerScripts.dataPtr;
              }
              else
              {
                v72 = 4 * (v37 + 1) / 3 + 3;
                v38 = (CPedAttractor **)malloc(4 * v72);
                v39 = this->m_triggerScripts.dataPtr;
                v40 = v38;
                if ( v39 )
                {
                  v41 = 4 * v37;
                  v42 = this->m_triggerScripts.dataPtr;
                  memmove(v38, v39, v41);
                  free(v42);
                  v37 = this->m_triggerScripts.numEntries;
                }
                this->m_triggerScripts.dataPtr = v40;
                this->m_triggerScripts.numAlloced = v72;
              }
              v40[v37] = v6;
              ++this->m_triggerScripts.numEntries;
              break;
            case 6:
              v43 = this->m_lookAts.numEntries;
              if ( this->m_lookAts.numAlloced >= v43 + 1 )
              {
                v46 = this->m_lookAts.dataPtr;
              }
              else
              {
                v73 = 4 * (v43 + 1) / 3 + 3;
                v44 = (CPedAttractor **)malloc(4 * v73);
                v45 = this->m_lookAts.dataPtr;
                v46 = v44;
                if ( v45 )
                {
                  v47 = 4 * v43;
                  v48 = this->m_lookAts.dataPtr;
                  memmove(v44, v45, v47);
                  free(v48);
                  v43 = this->m_lookAts.numEntries;
                }
                this->m_lookAts.dataPtr = v46;
                this->m_lookAts.numAlloced = v73;
              }
              v46[v43] = v6;
              ++this->m_lookAts.numEntries;
              break;
            case 7:
              v49 = this->m_scripted.numEntries;
              if ( this->m_scripted.numAlloced >= v49 + 1 )
              {
                v52 = this->m_scripted.dataPtr;
              }
              else
              {
                v74 = 4 * (v49 + 1) / 3 + 3;
                v50 = (CPedAttractor **)malloc(4 * v74);
                v51 = this->m_scripted.dataPtr;
                v52 = v50;
                if ( v51 )
                {
                  v53 = 4 * v49;
                  v54 = this->m_scripted.dataPtr;
                  memmove(v50, v51, v53);
                  free(v54);
                  v49 = this->m_scripted.numEntries;
                }
                this->m_scripted.dataPtr = v52;
                this->m_scripted.numAlloced = v74;
              }
              v52[v49] = v6;
              ++this->m_scripted.numEntries;
              break;
            case 8:
              v55 = this->m_parks.numEntries;
              if ( this->m_parks.numAlloced >= v55 + 1 )
              {
                v58 = this->m_parks.dataPtr;
              }
              else
              {
                v75 = 4 * (v55 + 1) / 3 + 3;
                v56 = (CPedAttractor **)malloc(4 * v75);
                v57 = this->m_parks.dataPtr;
                v58 = v56;
                if ( v57 )
                {
                  v59 = 4 * v55;
                  v60 = this->m_parks.dataPtr;
                  memmove(v56, v57, v59);
                  free(v60);
                  v55 = this->m_parks.numEntries;
                }
                this->m_parks.dataPtr = v58;
                this->m_parks.numAlloced = v75;
              }
              v58[v55] = v6;
              ++this->m_parks.numEntries;
              break;
            case 9:
              v61 = this->m_steps.numEntries;
              if ( this->m_steps.numAlloced >= v61 + 1 )
              {
                v64 = this->m_steps.dataPtr;
              }
              else
              {
                v76 = 4 * (v61 + 1) / 3 + 3;
                v62 = (CPedAttractor **)malloc(4 * v76);
                v63 = this->m_steps.dataPtr;
                v64 = v62;
                if ( v63 )
                {
                  v65 = 4 * v61;
                  v66 = this->m_steps.dataPtr;
                  memmove(v62, v63, v65);
                  free(v66);
                  v61 = this->m_steps.numEntries;
                }
                this->m_steps.dataPtr = v64;
                this->m_steps.numAlloced = v76;
              }
              v64[v61] = v6;
              ++this->m_steps.numEntries;
              break;
            default:
              break;
          }
        }
      }
      --v4;
      v5 -= 236;
    }
    while ( v4 != -1 );
  }
}

//----- (004A9B58) --------------------------------------------------------
CPedAttractor *__fastcall CPedAttractorManager::RegisterPedWithAttractor(
        CPedAttractorManager *this,
        CPed *pPed,
        C2dEffect *pEffect,
        CEntity *pEntity,
        const int iMoveState)
{
  _BOOL4 IsPedRegisteredWithEffect; // r0
  bool v10; // zf
  CPedAttractor *result; // r0
  SArray<CPedAttractor *> *p_m_atms; // r1

  if ( CScripted2dEffects::GetIndex(pEffect) <= -1 && !CEventAttractor::IsEffectActive(pEntity, pEffect) )
    return 0;
  IsPedRegisteredWithEffect = CPedAttractorManager::IsPedRegisteredWithEffect(this, pPed, pEffect, pEntity);
  v10 = !IsPedRegisteredWithEffect;
  if ( !IsPedRegisteredWithEffect )
    v10 = pEffect->m_type == 3;
  if ( !v10 )
    return 0;
  switch ( pEffect->attr.q.m_type )
  {
    case 0u:
      p_m_atms = &this->m_atms;
      goto LABEL_18;
    case 1u:
      return CPedAttractorManager::RegisterPed(
               (CPedAttractorManager *)iMoveState,
               pPed,
               pEffect,
               pEntity,
               iMoveState,
               (int)this);
    case 2u:
      p_m_atms = &this->m_stops;
      goto LABEL_18;
    case 3u:
      p_m_atms = &this->m_pizzas;
      goto LABEL_18;
    case 4u:
      p_m_atms = &this->m_shelters;
      goto LABEL_18;
    case 5u:
      p_m_atms = &this->m_triggerScripts;
      goto LABEL_18;
    case 6u:
      p_m_atms = &this->m_lookAts;
      goto LABEL_18;
    case 7u:
      p_m_atms = &this->m_scripted;
      goto LABEL_18;
    case 8u:
      p_m_atms = &this->m_parks;
      goto LABEL_18;
    case 9u:
      p_m_atms = &this->m_steps;
LABEL_18:
      result = CPedAttractorManager::RegisterPed(
                 (CPedAttractorManager *)iMoveState,
                 pPed,
                 pEffect,
                 pEntity,
                 iMoveState,
                 (int)p_m_atms);
      break;
    default:
      return 0;
  }
  return result;
}

//----- (004A9C04) --------------------------------------------------------
bool __fastcall CPedAttractorManager::IsPedRegisteredWithEffect(
        const CPedAttractorManager *this,
        CPed *pPed,
        const C2dEffect *pEffect,
        const CEntity *pEntity)
{
  signed int numEntries; // r12
  signed int i; // r4
  int v6; // r8
  int j; // r6
  int v8; // r8
  int k; // r6
  CPedAttractor *v10; // r10
  const C2dEffect *m_pEffect; // r6
  bool v12; // zf
  signed int v13; // r12
  signed int m; // r4
  int v15; // r8
  int n; // r6
  int v17; // r8
  int ii; // r6
  CPedAttractor *v19; // r10
  const C2dEffect *v20; // r6
  bool v21; // zf
  signed int v22; // r12
  signed int jj; // r4
  int v24; // r8
  int kk; // r6
  int v26; // r8
  int mm; // r6
  CPedAttractor *v28; // r10
  const C2dEffect *v29; // r6
  bool v30; // zf
  signed int v31; // r12
  signed int nn; // r4
  int v33; // r8
  int i1; // r6
  int v35; // r8
  int i2; // r6
  CPedAttractor *v37; // r10
  const C2dEffect *v38; // r6
  bool v39; // zf
  signed int v40; // r12
  signed int i3; // r4
  int v42; // r8
  int i4; // r6
  int v44; // r8
  int i5; // r6
  CPedAttractor *v46; // r10
  const C2dEffect *v47; // r6
  bool v48; // zf
  signed int v49; // r12
  signed int i6; // r4
  int v51; // r8
  int i7; // r6
  int v53; // r8
  int i8; // r6
  CPedAttractor *v55; // r10
  const C2dEffect *v56; // r6
  bool v57; // zf
  signed int v58; // r12
  signed int i9; // r4
  int v60; // r8
  int i10; // r6
  int v62; // r8
  int i11; // r6
  CPedAttractor *v64; // r10
  const C2dEffect *v65; // r6
  bool v66; // zf
  signed int v67; // r12
  signed int i12; // r4
  int v69; // r8
  int i13; // r6
  int v71; // r8
  int i14; // r6
  CPedAttractor *v73; // r10
  const C2dEffect *v74; // r6
  bool v75; // zf
  signed int v76; // r12
  signed int i15; // r4
  int v78; // r8
  int i16; // r6
  int v80; // r8
  int i17; // r6
  CPedAttractor *v82; // r10
  const C2dEffect *v83; // r6
  bool v84; // zf
  signed int v85; // r12
  CPedAttractor **dataPtr; // lr
  signed int v87; // r4
  int v88; // r8
  int v89; // r5
  int v90; // r8
  CPed **v91; // r0
  int v92; // r6
  CPedAttractor *v93; // r0
  const C2dEffect *v94; // r5
  bool v95; // zf
  bool result; // r0

  numEntries = this->m_seats.numEntries;
  if ( numEntries >= 1 )
  {
    for ( i = 0; i < numEntries; ++i )
    {
      v10 = this->m_seats.dataPtr[i];
      m_pEffect = v10->m_pEffect;
      v12 = m_pEffect == pEffect;
      if ( m_pEffect == pEffect )
        v12 = v10->m_pEntity == pEntity;
      if ( v12 )
      {
        v6 = v10->m_attractPeds.numEntries;
        if ( v6 >= 1 )
        {
          for ( j = 0; j < v6; ++j )
          {
            if ( v10->m_attractPeds.dataPtr[j] == pPed )
              return 1;
          }
        }
        v8 = v10->m_arrivedPeds.numEntries;
        if ( v8 >= 1 )
        {
          for ( k = 0; k < v8; ++k )
          {
            if ( v10->m_arrivedPeds.dataPtr[k] == pPed )
              return 1;
          }
        }
      }
    }
  }
  v13 = this->m_atms.numEntries;
  if ( v13 >= 1 )
  {
    for ( m = 0; m < v13; ++m )
    {
      v19 = this->m_atms.dataPtr[m];
      v20 = v19->m_pEffect;
      v21 = v20 == pEffect;
      if ( v20 == pEffect )
        v21 = v19->m_pEntity == pEntity;
      if ( v21 )
      {
        v15 = v19->m_attractPeds.numEntries;
        if ( v15 >= 1 )
        {
          for ( n = 0; n < v15; ++n )
          {
            if ( v19->m_attractPeds.dataPtr[n] == pPed )
              return 1;
          }
        }
        v17 = v19->m_arrivedPeds.numEntries;
        if ( v17 >= 1 )
        {
          for ( ii = 0; ii < v17; ++ii )
          {
            if ( v19->m_arrivedPeds.dataPtr[ii] == pPed )
              return 1;
          }
        }
      }
    }
  }
  v22 = this->m_stops.numEntries;
  if ( v22 >= 1 )
  {
    for ( jj = 0; jj < v22; ++jj )
    {
      v28 = this->m_stops.dataPtr[jj];
      v29 = v28->m_pEffect;
      v30 = v29 == pEffect;
      if ( v29 == pEffect )
        v30 = v28->m_pEntity == pEntity;
      if ( v30 )
      {
        v24 = v28->m_attractPeds.numEntries;
        if ( v24 >= 1 )
        {
          for ( kk = 0; kk < v24; ++kk )
          {
            if ( v28->m_attractPeds.dataPtr[kk] == pPed )
              return 1;
          }
        }
        v26 = v28->m_arrivedPeds.numEntries;
        if ( v26 >= 1 )
        {
          for ( mm = 0; mm < v26; ++mm )
          {
            if ( v28->m_arrivedPeds.dataPtr[mm] == pPed )
              return 1;
          }
        }
      }
    }
  }
  v31 = this->m_pizzas.numEntries;
  if ( v31 >= 1 )
  {
    for ( nn = 0; nn < v31; ++nn )
    {
      v37 = this->m_pizzas.dataPtr[nn];
      v38 = v37->m_pEffect;
      v39 = v38 == pEffect;
      if ( v38 == pEffect )
        v39 = v37->m_pEntity == pEntity;
      if ( v39 )
      {
        v33 = v37->m_attractPeds.numEntries;
        if ( v33 >= 1 )
        {
          for ( i1 = 0; i1 < v33; ++i1 )
          {
            if ( v37->m_attractPeds.dataPtr[i1] == pPed )
              return 1;
          }
        }
        v35 = v37->m_arrivedPeds.numEntries;
        if ( v35 >= 1 )
        {
          for ( i2 = 0; i2 < v35; ++i2 )
          {
            if ( v37->m_arrivedPeds.dataPtr[i2] == pPed )
              return 1;
          }
        }
      }
    }
  }
  v40 = this->m_shelters.numEntries;
  if ( v40 >= 1 )
  {
    for ( i3 = 0; i3 < v40; ++i3 )
    {
      v46 = this->m_shelters.dataPtr[i3];
      v47 = v46->m_pEffect;
      v48 = v47 == pEffect;
      if ( v47 == pEffect )
        v48 = v46->m_pEntity == pEntity;
      if ( v48 )
      {
        v42 = v46->m_attractPeds.numEntries;
        if ( v42 >= 1 )
        {
          for ( i4 = 0; i4 < v42; ++i4 )
          {
            if ( v46->m_attractPeds.dataPtr[i4] == pPed )
              return 1;
          }
        }
        v44 = v46->m_arrivedPeds.numEntries;
        if ( v44 >= 1 )
        {
          for ( i5 = 0; i5 < v44; ++i5 )
          {
            if ( v46->m_arrivedPeds.dataPtr[i5] == pPed )
              return 1;
          }
        }
      }
    }
  }
  v49 = this->m_triggerScripts.numEntries;
  if ( v49 >= 1 )
  {
    for ( i6 = 0; i6 < v49; ++i6 )
    {
      v55 = this->m_triggerScripts.dataPtr[i6];
      v56 = v55->m_pEffect;
      v57 = v56 == pEffect;
      if ( v56 == pEffect )
        v57 = v55->m_pEntity == pEntity;
      if ( v57 )
      {
        v51 = v55->m_attractPeds.numEntries;
        if ( v51 >= 1 )
        {
          for ( i7 = 0; i7 < v51; ++i7 )
          {
            if ( v55->m_attractPeds.dataPtr[i7] == pPed )
              return 1;
          }
        }
        v53 = v55->m_arrivedPeds.numEntries;
        if ( v53 >= 1 )
        {
          for ( i8 = 0; i8 < v53; ++i8 )
          {
            if ( v55->m_arrivedPeds.dataPtr[i8] == pPed )
              return 1;
          }
        }
      }
    }
  }
  v58 = this->m_lookAts.numEntries;
  if ( v58 >= 1 )
  {
    for ( i9 = 0; i9 < v58; ++i9 )
    {
      v64 = this->m_lookAts.dataPtr[i9];
      v65 = v64->m_pEffect;
      v66 = v65 == pEffect;
      if ( v65 == pEffect )
        v66 = v64->m_pEntity == pEntity;
      if ( v66 )
      {
        v60 = v64->m_attractPeds.numEntries;
        if ( v60 >= 1 )
        {
          for ( i10 = 0; i10 < v60; ++i10 )
          {
            if ( v64->m_attractPeds.dataPtr[i10] == pPed )
              return 1;
          }
        }
        v62 = v64->m_arrivedPeds.numEntries;
        if ( v62 >= 1 )
        {
          for ( i11 = 0; i11 < v62; ++i11 )
          {
            if ( v64->m_arrivedPeds.dataPtr[i11] == pPed )
              return 1;
          }
        }
      }
    }
  }
  v67 = this->m_scripted.numEntries;
  if ( v67 >= 1 )
  {
    for ( i12 = 0; i12 < v67; ++i12 )
    {
      v73 = this->m_scripted.dataPtr[i12];
      v74 = v73->m_pEffect;
      v75 = v74 == pEffect;
      if ( v74 == pEffect )
        v75 = v73->m_pEntity == pEntity;
      if ( v75 )
      {
        v69 = v73->m_attractPeds.numEntries;
        if ( v69 >= 1 )
        {
          for ( i13 = 0; i13 < v69; ++i13 )
          {
            if ( v73->m_attractPeds.dataPtr[i13] == pPed )
              return 1;
          }
        }
        v71 = v73->m_arrivedPeds.numEntries;
        if ( v71 >= 1 )
        {
          for ( i14 = 0; i14 < v71; ++i14 )
          {
            if ( v73->m_arrivedPeds.dataPtr[i14] == pPed )
              return 1;
          }
        }
      }
    }
  }
  v76 = this->m_parks.numEntries;
  if ( v76 >= 1 )
  {
    for ( i15 = 0; i15 < v76; ++i15 )
    {
      v82 = this->m_parks.dataPtr[i15];
      v83 = v82->m_pEffect;
      v84 = v83 == pEffect;
      if ( v83 == pEffect )
        v84 = v82->m_pEntity == pEntity;
      if ( v84 )
      {
        v78 = v82->m_attractPeds.numEntries;
        if ( v78 >= 1 )
        {
          for ( i16 = 0; i16 < v78; ++i16 )
          {
            if ( v82->m_attractPeds.dataPtr[i16] == pPed )
              return 1;
          }
        }
        v80 = v82->m_arrivedPeds.numEntries;
        if ( v80 >= 1 )
        {
          for ( i17 = 0; i17 < v80; ++i17 )
          {
            if ( v82->m_arrivedPeds.dataPtr[i17] == pPed )
              return 1;
          }
        }
      }
    }
  }
  v85 = this->m_steps.numEntries;
  if ( v85 < 1 )
    return 0;
  dataPtr = this->m_steps.dataPtr;
  v87 = 0;
  while ( 1 )
  {
    v93 = dataPtr[v87];
    v94 = v93->m_pEffect;
    v95 = v94 == pEffect;
    if ( v94 == pEffect )
      v95 = v93->m_pEntity == pEntity;
    if ( !v95 )
      goto LABEL_150;
    v88 = v93->m_attractPeds.numEntries;
    if ( v88 >= 1 )
      break;
LABEL_142:
    v90 = v93->m_arrivedPeds.numEntries;
    if ( v90 >= 1 )
    {
      v91 = v93->m_arrivedPeds.dataPtr;
      v92 = 0;
      while ( v91[v92] != pPed )
      {
        if ( ++v92 >= v90 )
          goto LABEL_150;
      }
      return 1;
    }
LABEL_150:
    ++v87;
    result = 0;
    if ( v87 >= v85 )
      return result;
  }
  v89 = 0;
  while ( v93->m_attractPeds.dataPtr[v89] != pPed )
  {
    if ( ++v89 >= v88 )
      goto LABEL_142;
  }
  return 1;
}

//----- (004AA060) --------------------------------------------------------
CPedAttractor *__fastcall CPedAttractorManager::RegisterPed(
        CPedAttractorManager *this,
        CPed *pPed,
        C2dEffect *pEffect,
        CEntity *pEntity,
        int a5,
        int a6)
{
  int v7; // r0
  int v8; // r6
  CPedAttractor *m_nFreeIndex; // r5
  C2dEffect *m_pEffect; // r4
  bool v11; // zf
  int v12; // r6
  CPedAttractorPool *v13; // r0
  int32 m_nSize; // lr
  uint8 *m_aFlags; // r4
  int v16; // r1
  void **v17; // r0
  int v18; // r6
  CPedAttractorPool *v19; // r0
  int32 v20; // lr
  uint8 *v21; // r4
  int v22; // r1
  int v23; // r6
  CPedAttractorPool *v24; // r0
  int32 v25; // lr
  uint8 *v26; // r4
  int v27; // r1
  int v28; // r6
  CPedAttractorPool *v29; // r0
  int32 v30; // lr
  uint8 *v31; // r4
  int v32; // r1
  int v33; // r6
  CPedAttractorPool *v34; // r0
  int32 v35; // lr
  uint8 *v36; // r4
  int v37; // r1
  int v38; // r6
  CPedAttractorPool *v39; // r0
  int32 v40; // lr
  uint8 *v41; // r4
  int v42; // r1
  int v43; // r6
  CPedAttractorPool *v44; // r0
  int32 v45; // lr
  uint8 *v46; // r4
  int v47; // r1
  int v48; // r6
  CPedAttractorPool *v49; // r0
  int32 v50; // lr
  uint8 *v51; // r4
  int v52; // r1
  int v53; // r6
  CPedAttractorPool *v54; // r0
  int32 v55; // lr
  uint8 *v56; // r4
  int v57; // r1
  int v58; // r6
  CPedAttractorPool *v59; // r0
  int32 v60; // lr
  uint8 *v61; // r4
  int v62; // r1
  int v63; // r4
  unsigned int v64; // r11
  _DWORD *v65; // r0
  void *v66; // r10
  _DWORD *v67; // r6

  v7 = *(_DWORD *)(a6 + 4);
  if ( v7 >= 1 )
  {
    v8 = 0;
    while ( 1 )
    {
      m_nFreeIndex = *(CPedAttractor **)(*(_DWORD *)(a6 + 8) + 4 * v8);
      m_pEffect = m_nFreeIndex->m_pEffect;
      v11 = m_pEffect == pEffect;
      if ( m_pEffect == pEffect )
        v11 = m_nFreeIndex->m_pEntity == pEntity;
      if ( v11 )
        break;
      if ( ++v8 >= v7 )
        goto LABEL_7;
    }
    if ( m_nFreeIndex )
      goto LABEL_87;
  }
LABEL_7:
  switch ( pEffect->attr.q.m_type )
  {
    case 0u:
      v12 = 0;
      v13 = CPools::ms_pPedAttractorPool;
      m_nFreeIndex = (CPedAttractor *)CPools::ms_pPedAttractorPool->m_nFreeIndex;
      m_nSize = CPools::ms_pPedAttractorPool->m_nSize;
      while ( 1 )
      {
        m_nFreeIndex = (CPedAttractor *)((char *)m_nFreeIndex + 1);
        v13->m_nFreeIndex = (int32)m_nFreeIndex;
        if ( m_nFreeIndex == (CPedAttractor *)m_nSize )
        {
          m_nFreeIndex = 0;
          v13->m_nFreeIndex = 0;
          if ( v12 << 31 )
            goto LABEL_14;
          v12 = 1;
        }
        m_aFlags = v13->m_aFlags;
        v16 = *((char *)&m_nFreeIndex->_vptr$CPedAttractor + (_DWORD)m_aFlags);
        if ( v16 <= -1 )
        {
          *((_BYTE *)&m_nFreeIndex->_vptr$CPedAttractor + (_DWORD)m_aFlags) = v16 & 0x7F;
          v13->m_aFlags[v13->m_nFreeIndex] = (v13->m_aFlags[v13->m_nFreeIndex] + 1) & 0x7F | v13->m_aFlags[v13->m_nFreeIndex] & 0x80;
          m_nFreeIndex = (CPedAttractor *)v13->m_aStorage[v13->m_nFreeIndex];
LABEL_14:
          CPedAttractor::CPedAttractor(m_nFreeIndex, pEffect, pEntity, a5, 5, 1.0, 30000.0, 3000.0, 0.2, 0.15, 0.1, 0.1);
          v17 = &`vtable for'CPedAtmAttractor;
          goto LABEL_81;
        }
      }
    case 1u:
      v18 = 0;
      v19 = CPools::ms_pPedAttractorPool;
      m_nFreeIndex = (CPedAttractor *)CPools::ms_pPedAttractorPool->m_nFreeIndex;
      v20 = CPools::ms_pPedAttractorPool->m_nSize;
      do
      {
        m_nFreeIndex = (CPedAttractor *)((char *)m_nFreeIndex + 1);
        v19->m_nFreeIndex = (int32)m_nFreeIndex;
        if ( m_nFreeIndex == (CPedAttractor *)v20 )
        {
          m_nFreeIndex = 0;
          v19->m_nFreeIndex = 0;
          if ( v18 << 31 )
            goto LABEL_24;
          v18 = 1;
        }
        v21 = v19->m_aFlags;
        v22 = *((char *)&m_nFreeIndex->_vptr$CPedAttractor + (_DWORD)v21);
      }
      while ( v22 > -1 );
      *((_BYTE *)&m_nFreeIndex->_vptr$CPedAttractor + (_DWORD)v21) = v22 & 0x7F;
      v19->m_aFlags[v19->m_nFreeIndex] = (v19->m_aFlags[v19->m_nFreeIndex] + 1) & 0x7F | v19->m_aFlags[v19->m_nFreeIndex] & 0x80;
      m_nFreeIndex = (CPedAttractor *)v19->m_aStorage[v19->m_nFreeIndex];
LABEL_24:
      CPedAttractor::CPedAttractor(m_nFreeIndex, pEffect, pEntity, a5, 1, 1.0, 30000.0, 3000.0, 0.125, 0.1, 0.1, 0.1);
      v17 = &`vtable for'CPedSeatAttractor;
      goto LABEL_81;
    case 2u:
      v23 = 0;
      v24 = CPools::ms_pPedAttractorPool;
      m_nFreeIndex = (CPedAttractor *)CPools::ms_pPedAttractorPool->m_nFreeIndex;
      v25 = CPools::ms_pPedAttractorPool->m_nSize;
      do
      {
        m_nFreeIndex = (CPedAttractor *)((char *)m_nFreeIndex + 1);
        v24->m_nFreeIndex = (int32)m_nFreeIndex;
        if ( m_nFreeIndex == (CPedAttractor *)v25 )
        {
          m_nFreeIndex = 0;
          v24->m_nFreeIndex = 0;
          if ( v23 << 31 )
            goto LABEL_31;
          v23 = 1;
        }
        v26 = v24->m_aFlags;
        v27 = *((char *)&m_nFreeIndex->_vptr$CPedAttractor + (_DWORD)v26);
      }
      while ( v27 > -1 );
      *((_BYTE *)&m_nFreeIndex->_vptr$CPedAttractor + (_DWORD)v26) = v27 & 0x7F;
      v24->m_aFlags[v24->m_nFreeIndex] = (v24->m_aFlags[v24->m_nFreeIndex] + 1) & 0x7F | v24->m_aFlags[v24->m_nFreeIndex] & 0x80;
      m_nFreeIndex = (CPedAttractor *)v24->m_aStorage[v24->m_nFreeIndex];
LABEL_31:
      CPedAttractor::CPedAttractor(m_nFreeIndex, pEffect, pEntity, a5, 5, 1.0, 30000.0, 3000.0, 0.2, 0.1, 0.1, 0.1);
      v17 = &`vtable for'CPedStopAttractor;
      goto LABEL_81;
    case 3u:
      v28 = 0;
      v29 = CPools::ms_pPedAttractorPool;
      m_nFreeIndex = (CPedAttractor *)CPools::ms_pPedAttractorPool->m_nFreeIndex;
      v30 = CPools::ms_pPedAttractorPool->m_nSize;
      do
      {
        m_nFreeIndex = (CPedAttractor *)((char *)m_nFreeIndex + 1);
        v29->m_nFreeIndex = (int32)m_nFreeIndex;
        if ( m_nFreeIndex == (CPedAttractor *)v30 )
        {
          m_nFreeIndex = 0;
          v29->m_nFreeIndex = 0;
          if ( v28 << 31 )
            goto LABEL_38;
          v28 = 1;
        }
        v31 = v29->m_aFlags;
        v32 = *((char *)&m_nFreeIndex->_vptr$CPedAttractor + (_DWORD)v31);
      }
      while ( v32 > -1 );
      *((_BYTE *)&m_nFreeIndex->_vptr$CPedAttractor + (_DWORD)v31) = v32 & 0x7F;
      v29->m_aFlags[v29->m_nFreeIndex] = (v29->m_aFlags[v29->m_nFreeIndex] + 1) & 0x7F | v29->m_aFlags[v29->m_nFreeIndex] & 0x80;
      m_nFreeIndex = (CPedAttractor *)v29->m_aStorage[v29->m_nFreeIndex];
LABEL_38:
      CPedAttractor::CPedAttractor(m_nFreeIndex, pEffect, pEntity, a5, 5, 1.0, 30000.0, 3000.0, 0.2, 0.1, 0.1, 0.1);
      v17 = &`vtable for'CPedPizzaAttractor;
      goto LABEL_81;
    case 4u:
      v33 = 0;
      v34 = CPools::ms_pPedAttractorPool;
      m_nFreeIndex = (CPedAttractor *)CPools::ms_pPedAttractorPool->m_nFreeIndex;
      v35 = CPools::ms_pPedAttractorPool->m_nSize;
      do
      {
        m_nFreeIndex = (CPedAttractor *)((char *)m_nFreeIndex + 1);
        v34->m_nFreeIndex = (int32)m_nFreeIndex;
        if ( m_nFreeIndex == (CPedAttractor *)v35 )
        {
          m_nFreeIndex = 0;
          v34->m_nFreeIndex = 0;
          if ( v33 << 31 )
            goto LABEL_45;
          v33 = 1;
        }
        v36 = v34->m_aFlags;
        v37 = *((char *)&m_nFreeIndex->_vptr$CPedAttractor + (_DWORD)v36);
      }
      while ( v37 > -1 );
      *((_BYTE *)&m_nFreeIndex->_vptr$CPedAttractor + (_DWORD)v36) = v37 & 0x7F;
      v34->m_aFlags[v34->m_nFreeIndex] = (v34->m_aFlags[v34->m_nFreeIndex] + 1) & 0x7F | v34->m_aFlags[v34->m_nFreeIndex] & 0x80;
      m_nFreeIndex = (CPedAttractor *)v34->m_aStorage[v34->m_nFreeIndex];
LABEL_45:
      CPedAttractor::CPedAttractor(m_nFreeIndex, pEffect, pEntity, a5, 5, 1.0, 30000.0, 3000.0, 0.5, 6.28, 0.1, 0.1);
      v17 = &`vtable for'CPedShelterAttractor;
      goto LABEL_81;
    case 5u:
      v38 = 0;
      v39 = CPools::ms_pPedAttractorPool;
      m_nFreeIndex = (CPedAttractor *)CPools::ms_pPedAttractorPool->m_nFreeIndex;
      v40 = CPools::ms_pPedAttractorPool->m_nSize;
      do
      {
        m_nFreeIndex = (CPedAttractor *)((char *)m_nFreeIndex + 1);
        v39->m_nFreeIndex = (int32)m_nFreeIndex;
        if ( m_nFreeIndex == (CPedAttractor *)v40 )
        {
          m_nFreeIndex = 0;
          v39->m_nFreeIndex = 0;
          if ( v38 << 31 )
            goto LABEL_52;
          v38 = 1;
        }
        v41 = v39->m_aFlags;
        v42 = *((char *)&m_nFreeIndex->_vptr$CPedAttractor + (_DWORD)v41);
      }
      while ( v42 > -1 );
      *((_BYTE *)&m_nFreeIndex->_vptr$CPedAttractor + (_DWORD)v41) = v42 & 0x7F;
      v39->m_aFlags[v39->m_nFreeIndex] = (v39->m_aFlags[v39->m_nFreeIndex] + 1) & 0x7F | v39->m_aFlags[v39->m_nFreeIndex] & 0x80;
      m_nFreeIndex = (CPedAttractor *)v39->m_aStorage[v39->m_nFreeIndex];
LABEL_52:
      CPedAttractor::CPedAttractor(m_nFreeIndex, pEffect, pEntity, a5, 1, 1.0, 30000.0, 3000.0, 0.125, 0.1, 0.1, 0.1);
      v17 = &`vtable for'CPedTriggerScriptAttractor;
      goto LABEL_81;
    case 6u:
      v43 = 0;
      v44 = CPools::ms_pPedAttractorPool;
      m_nFreeIndex = (CPedAttractor *)CPools::ms_pPedAttractorPool->m_nFreeIndex;
      v45 = CPools::ms_pPedAttractorPool->m_nSize;
      do
      {
        m_nFreeIndex = (CPedAttractor *)((char *)m_nFreeIndex + 1);
        v44->m_nFreeIndex = (int32)m_nFreeIndex;
        if ( m_nFreeIndex == (CPedAttractor *)v45 )
        {
          m_nFreeIndex = 0;
          v44->m_nFreeIndex = 0;
          if ( v43 << 31 )
            goto LABEL_59;
          v43 = 1;
        }
        v46 = v44->m_aFlags;
        v47 = *((char *)&m_nFreeIndex->_vptr$CPedAttractor + (_DWORD)v46);
      }
      while ( v47 > -1 );
      *((_BYTE *)&m_nFreeIndex->_vptr$CPedAttractor + (_DWORD)v46) = v47 & 0x7F;
      v44->m_aFlags[v44->m_nFreeIndex] = (v44->m_aFlags[v44->m_nFreeIndex] + 1) & 0x7F | v44->m_aFlags[v44->m_nFreeIndex] & 0x80;
      m_nFreeIndex = (CPedAttractor *)v44->m_aStorage[v44->m_nFreeIndex];
LABEL_59:
      CPedAttractor::CPedAttractor(m_nFreeIndex, pEffect, pEntity, a5, 1, 1.0, 30000.0, 3000.0, 0.125, 0.1, 0.1, 0.1);
      v17 = &`vtable for'CPedLookAtAttractor;
      goto LABEL_81;
    case 7u:
      v48 = 0;
      v49 = CPools::ms_pPedAttractorPool;
      m_nFreeIndex = (CPedAttractor *)CPools::ms_pPedAttractorPool->m_nFreeIndex;
      v50 = CPools::ms_pPedAttractorPool->m_nSize;
      do
      {
        m_nFreeIndex = (CPedAttractor *)((char *)m_nFreeIndex + 1);
        v49->m_nFreeIndex = (int32)m_nFreeIndex;
        if ( m_nFreeIndex == (CPedAttractor *)v50 )
        {
          m_nFreeIndex = 0;
          v49->m_nFreeIndex = 0;
          if ( v48 << 31 )
            goto LABEL_66;
          v48 = 1;
        }
        v51 = v49->m_aFlags;
        v52 = *((char *)&m_nFreeIndex->_vptr$CPedAttractor + (_DWORD)v51);
      }
      while ( v52 > -1 );
      *((_BYTE *)&m_nFreeIndex->_vptr$CPedAttractor + (_DWORD)v51) = v52 & 0x7F;
      v49->m_aFlags[v49->m_nFreeIndex] = (v49->m_aFlags[v49->m_nFreeIndex] + 1) & 0x7F | v49->m_aFlags[v49->m_nFreeIndex] & 0x80;
      m_nFreeIndex = (CPedAttractor *)v49->m_aStorage[v49->m_nFreeIndex];
LABEL_66:
      CPedAttractor::CPedAttractor(m_nFreeIndex, pEffect, pEntity, a5, 1, 1.0, 30000.0, 3000.0, 0.125, 0.1, 0.1, 0.1);
      v17 = &`vtable for'CPedScriptedAttractor;
      goto LABEL_81;
    case 8u:
      v53 = 0;
      v54 = CPools::ms_pPedAttractorPool;
      m_nFreeIndex = (CPedAttractor *)CPools::ms_pPedAttractorPool->m_nFreeIndex;
      v55 = CPools::ms_pPedAttractorPool->m_nSize;
      do
      {
        m_nFreeIndex = (CPedAttractor *)((char *)m_nFreeIndex + 1);
        v54->m_nFreeIndex = (int32)m_nFreeIndex;
        if ( m_nFreeIndex == (CPedAttractor *)v55 )
        {
          m_nFreeIndex = 0;
          v54->m_nFreeIndex = 0;
          if ( v53 << 31 )
            goto LABEL_73;
          v53 = 1;
        }
        v56 = v54->m_aFlags;
        v57 = *((char *)&m_nFreeIndex->_vptr$CPedAttractor + (_DWORD)v56);
      }
      while ( v57 > -1 );
      *((_BYTE *)&m_nFreeIndex->_vptr$CPedAttractor + (_DWORD)v56) = v57 & 0x7F;
      v54->m_aFlags[v54->m_nFreeIndex] = (v54->m_aFlags[v54->m_nFreeIndex] + 1) & 0x7F | v54->m_aFlags[v54->m_nFreeIndex] & 0x80;
      m_nFreeIndex = (CPedAttractor *)v54->m_aStorage[v54->m_nFreeIndex];
LABEL_73:
      CPedAttractor::CPedAttractor(m_nFreeIndex, pEffect, pEntity, a5, 1, 1.0, 30000.0, 3000.0, 0.125, 0.1, 0.1, 0.1);
      v17 = &`vtable for'CPedParkAttractor;
      goto LABEL_81;
    case 9u:
      v58 = 0;
      v59 = CPools::ms_pPedAttractorPool;
      m_nFreeIndex = (CPedAttractor *)CPools::ms_pPedAttractorPool->m_nFreeIndex;
      v60 = CPools::ms_pPedAttractorPool->m_nSize;
      break;
    default:
      return 0;
  }
  do
  {
    m_nFreeIndex = (CPedAttractor *)((char *)m_nFreeIndex + 1);
    v59->m_nFreeIndex = (int32)m_nFreeIndex;
    if ( m_nFreeIndex == (CPedAttractor *)v60 )
    {
      m_nFreeIndex = 0;
      v59->m_nFreeIndex = 0;
      if ( v58 << 31 )
        goto LABEL_80;
      v58 = 1;
    }
    v61 = v59->m_aFlags;
    v62 = *((char *)&m_nFreeIndex->_vptr$CPedAttractor + (_DWORD)v61);
  }
  while ( v62 > -1 );
  *((_BYTE *)&m_nFreeIndex->_vptr$CPedAttractor + (_DWORD)v61) = v62 & 0x7F;
  v59->m_aFlags[v59->m_nFreeIndex] = (v59->m_aFlags[v59->m_nFreeIndex] + 1) & 0x7F | v59->m_aFlags[v59->m_nFreeIndex] & 0x80;
  m_nFreeIndex = (CPedAttractor *)v59->m_aStorage[v59->m_nFreeIndex];
LABEL_80:
  CPedAttractor::CPedAttractor(m_nFreeIndex, pEffect, pEntity, a5, 1, 1.0, 30000.0, 3000.0, 0.125, 0.1, 0.1, 0.1);
  v17 = &`vtable for'CPedStepAttractor;
LABEL_81:
  m_nFreeIndex->_vptr$CPedAttractor = (int (**)(void))((char *)*v17 + 8);
  v63 = *(_DWORD *)(a6 + 4);
  if ( *(_DWORD *)a6 >= (unsigned int)(v63 + 1) )
  {
    v67 = *(_DWORD **)(a6 + 8);
  }
  else
  {
    v64 = 4 * (v63 + 1) / 3u + 3;
    v65 = malloc(4 * v64);
    v66 = *(void **)(a6 + 8);
    v67 = v65;
    if ( v66 )
    {
      memmove(v65, *(const void **)(a6 + 8), 4 * v63);
      free(v66);
      v63 = *(_DWORD *)(a6 + 4);
    }
    *(_DWORD *)(a6 + 8) = v67;
    *(_DWORD *)a6 = v64;
  }
  v67[v63] = m_nFreeIndex;
  ++*(_DWORD *)(a6 + 4);
  if ( m_nFreeIndex )
LABEL_87:
    CPedAttractor::RegisterPed(m_nFreeIndex, pPed);
  return m_nFreeIndex;
}
// 675EC8: using guessed type void *`vtable for'CPedLookAtAttractor;
// 6763FC: using guessed type void *`vtable for'CPedStopAttractor;
// 67655C: using guessed type void *`vtable for'CPedScriptedAttractor;
// 6767C4: using guessed type void *`vtable for'CPedTriggerScriptAttractor;
// 676A9C: using guessed type void *`vtable for'CPedPizzaAttractor;
// 676FD0: using guessed type void *`vtable for'CPedSeatAttractor;
// 677338: using guessed type void *`vtable for'CPedShelterAttractor;
// 677C98: using guessed type void *`vtable for'CPedStepAttractor;
// 677E1C: using guessed type void *`vtable for'CPedAtmAttractor;
// 678368: using guessed type void *`vtable for'CPedParkAttractor;

//----- (004AA778) --------------------------------------------------------
bool __fastcall CPedAttractorManager::BroadcastArrival(
        CPedAttractorManager *this,
        CPed *pPed,
        CPedAttractor *pAttractor)
{
  signed int numEntries; // r1
  CPedAttractor **dataPtr; // r2
  CPedAttractor *v8; // r0
  signed int v9; // r3
  CPedAttractor *v10; // r6
  signed int v11; // r1
  CPedAttractor **v12; // r2
  signed int v13; // r3
  CPedAttractor *v14; // r6
  signed int v15; // r1
  CPedAttractor **v16; // r2
  signed int v17; // r3
  CPedAttractor *v18; // r6
  signed int v19; // r1
  CPedAttractor **v20; // r2
  signed int v21; // r3
  CPedAttractor *v22; // r6
  signed int v23; // r1
  CPedAttractor **v24; // r2
  signed int v25; // r3
  CPedAttractor *v26; // r6
  signed int v27; // r1
  CPedAttractor **v28; // r2
  signed int v29; // r3
  CPedAttractor *v30; // r6
  signed int v31; // r1
  CPedAttractor **v32; // r2
  signed int v33; // r3
  CPedAttractor *v34; // r6
  signed int v35; // r1
  CPedAttractor **v36; // r2
  signed int v37; // r3
  CPedAttractor *v38; // r6
  signed int v39; // r1
  CPedAttractor **v40; // r2
  signed int v41; // r3
  CPedAttractor *v42; // r6
  signed int v43; // r1
  CPedAttractor **v44; // r2
  signed int v45; // r3
  CPedAttractor *v46; // r6

  if ( !pAttractor || !CPedAttractorManager::IsPedRegisteredWithEffect(this, pPed) )
    return 0;
  switch ( ((int (__fastcall *)(CPedAttractor *))*pAttractor->_vptr$CPedAttractor)(pAttractor) )
  {
    case 0:
      numEntries = this->m_atms.numEntries;
      if ( numEntries < 1 )
        return 0;
      dataPtr = this->m_atms.dataPtr;
      v8 = 0;
      v9 = 0;
      do
      {
        v10 = dataPtr[v9++];
        if ( v10 == pAttractor )
          v8 = v10;
      }
      while ( v9 < numEntries && v10 != pAttractor );
      break;
    case 1:
      v11 = this->m_seats.numEntries;
      if ( v11 < 1 )
        return 0;
      v12 = this->m_seats.dataPtr;
      v8 = 0;
      v13 = 0;
      do
      {
        v14 = v12[v13++];
        if ( v14 == pAttractor )
          v8 = v14;
      }
      while ( v13 < v11 && v14 != pAttractor );
      break;
    case 2:
      v15 = this->m_stops.numEntries;
      if ( v15 < 1 )
        return 0;
      v16 = this->m_stops.dataPtr;
      v8 = 0;
      v17 = 0;
      do
      {
        v18 = v16[v17++];
        if ( v18 == pAttractor )
          v8 = v18;
      }
      while ( v17 < v15 && v18 != pAttractor );
      break;
    case 3:
      v19 = this->m_pizzas.numEntries;
      if ( v19 < 1 )
        return 0;
      v20 = this->m_pizzas.dataPtr;
      v8 = 0;
      v21 = 0;
      do
      {
        v22 = v20[v21++];
        if ( v22 == pAttractor )
          v8 = v22;
      }
      while ( v21 < v19 && v22 != pAttractor );
      break;
    case 4:
      v23 = this->m_shelters.numEntries;
      if ( v23 < 1 )
        return 0;
      v24 = this->m_shelters.dataPtr;
      v8 = 0;
      v25 = 0;
      do
      {
        v26 = v24[v25++];
        if ( v26 == pAttractor )
          v8 = v26;
      }
      while ( v25 < v23 && v26 != pAttractor );
      break;
    case 5:
      v27 = this->m_triggerScripts.numEntries;
      if ( v27 < 1 )
        return 0;
      v28 = this->m_triggerScripts.dataPtr;
      v8 = 0;
      v29 = 0;
      do
      {
        v30 = v28[v29++];
        if ( v30 == pAttractor )
          v8 = v30;
      }
      while ( v29 < v27 && v30 != pAttractor );
      break;
    case 6:
      v31 = this->m_lookAts.numEntries;
      if ( v31 < 1 )
        return 0;
      v32 = this->m_lookAts.dataPtr;
      v8 = 0;
      v33 = 0;
      do
      {
        v34 = v32[v33++];
        if ( v34 == pAttractor )
          v8 = v34;
      }
      while ( v33 < v31 && v34 != pAttractor );
      break;
    case 7:
      v35 = this->m_scripted.numEntries;
      if ( v35 < 1 )
        return 0;
      v36 = this->m_scripted.dataPtr;
      v8 = 0;
      v37 = 0;
      do
      {
        v38 = v36[v37++];
        if ( v38 == pAttractor )
          v8 = v38;
      }
      while ( v37 < v35 && v38 != pAttractor );
      break;
    case 8:
      v39 = this->m_parks.numEntries;
      if ( v39 < 1 )
        return 0;
      v40 = this->m_parks.dataPtr;
      v8 = 0;
      v41 = 0;
      do
      {
        v42 = v40[v41++];
        if ( v42 == pAttractor )
          v8 = v42;
      }
      while ( v41 < v39 && v42 != pAttractor );
      break;
    case 9:
      v43 = this->m_steps.numEntries;
      if ( v43 < 1 )
        return 0;
      v44 = this->m_steps.dataPtr;
      v8 = 0;
      v45 = 0;
      do
      {
        v46 = v44[v45++];
        if ( v46 == pAttractor )
          v8 = v46;
      }
      while ( v45 < v43 && v46 != pAttractor );
      break;
    default:
      return 0;
  }
  if ( !v8 )
    return 0;
  CPedAttractor::BroadcastArrival(v8, pPed);
  return 1;
}

//----- (004AA92A) --------------------------------------------------------
bool __fastcall CPedAttractorManager::IsPedRegisteredWithEffect(const CPedAttractorManager *this, CPed *pPed)
{
  signed int numEntries; // lr
  int v3; // r8
  CPedAttractor *v4; // r2
  int v5; // r4
  int v6; // r6
  int v7; // r4
  CPed **dataPtr; // r2
  int v9; // r5
  signed int v10; // lr
  int v11; // r8
  CPedAttractor *v12; // r2
  int v13; // r4
  int v14; // r6
  int v15; // r4
  CPed **v16; // r2
  int v17; // r5
  signed int v18; // lr
  int v19; // r8
  CPedAttractor *v20; // r2
  int v21; // r4
  int v22; // r6
  int v23; // r4
  CPed **v24; // r2
  int v25; // r5
  signed int v26; // lr
  int v27; // r8
  CPedAttractor *v28; // r2
  int v29; // r4
  int v30; // r6
  int v31; // r4
  CPed **v32; // r2
  int v33; // r5
  signed int v34; // lr
  int v35; // r8
  CPedAttractor *v36; // r2
  int v37; // r4
  int v38; // r6
  int v39; // r4
  CPed **v40; // r2
  int v41; // r5
  signed int v42; // lr
  int v43; // r8
  CPedAttractor *v44; // r2
  int v45; // r4
  int v46; // r6
  int v47; // r4
  CPed **v48; // r2
  int v49; // r5
  signed int v50; // lr
  int v51; // r8
  CPedAttractor *v52; // r2
  int v53; // r4
  int v54; // r6
  int v55; // r4
  CPed **v56; // r2
  int v57; // r5
  signed int v58; // lr
  int v59; // r8
  CPedAttractor *v60; // r2
  int v61; // r4
  int v62; // r6
  int v63; // r4
  CPed **v64; // r2
  int v65; // r5
  signed int v66; // lr
  int v67; // r8
  CPedAttractor *v68; // r2
  int v69; // r4
  int v70; // r6
  int v71; // r4
  CPed **v72; // r2
  int v73; // r5
  signed int v74; // lr
  CPedAttractor **v75; // r12
  signed int v76; // r3
  CPedAttractor *v77; // r0
  int v78; // r4
  int v79; // r6
  int v80; // r4
  CPed **v81; // r0
  int v82; // r6
  bool result; // r0

  numEntries = this->m_seats.numEntries;
  if ( numEntries >= 1 )
  {
    v3 = 0;
    while ( 1 )
    {
      v4 = this->m_seats.dataPtr[v3];
      v5 = v4->m_attractPeds.numEntries;
      if ( v5 >= 1 )
        break;
LABEL_7:
      v7 = v4->m_arrivedPeds.numEntries;
      if ( v7 >= 1 )
      {
        dataPtr = v4->m_arrivedPeds.dataPtr;
        v9 = 0;
        while ( dataPtr[v9] != pPed )
        {
          if ( ++v9 >= v7 )
            goto LABEL_11;
        }
        return 1;
      }
LABEL_11:
      if ( ++v3 >= numEntries )
        goto LABEL_12;
    }
    v6 = 0;
    while ( v4->m_attractPeds.dataPtr[v6] != pPed )
    {
      if ( ++v6 >= v5 )
        goto LABEL_7;
    }
    return 1;
  }
LABEL_12:
  v10 = this->m_atms.numEntries;
  if ( v10 >= 1 )
  {
    v11 = 0;
    while ( 1 )
    {
      v12 = this->m_atms.dataPtr[v11];
      v13 = v12->m_attractPeds.numEntries;
      if ( v13 >= 1 )
        break;
LABEL_18:
      v15 = v12->m_arrivedPeds.numEntries;
      if ( v15 >= 1 )
      {
        v16 = v12->m_arrivedPeds.dataPtr;
        v17 = 0;
        while ( v16[v17] != pPed )
        {
          if ( ++v17 >= v15 )
            goto LABEL_22;
        }
        return 1;
      }
LABEL_22:
      if ( ++v11 >= v10 )
        goto LABEL_23;
    }
    v14 = 0;
    while ( v12->m_attractPeds.dataPtr[v14] != pPed )
    {
      if ( ++v14 >= v13 )
        goto LABEL_18;
    }
    return 1;
  }
LABEL_23:
  v18 = this->m_stops.numEntries;
  if ( v18 >= 1 )
  {
    v19 = 0;
    while ( 1 )
    {
      v20 = this->m_stops.dataPtr[v19];
      v21 = v20->m_attractPeds.numEntries;
      if ( v21 >= 1 )
        break;
LABEL_29:
      v23 = v20->m_arrivedPeds.numEntries;
      if ( v23 >= 1 )
      {
        v24 = v20->m_arrivedPeds.dataPtr;
        v25 = 0;
        while ( v24[v25] != pPed )
        {
          if ( ++v25 >= v23 )
            goto LABEL_33;
        }
        return 1;
      }
LABEL_33:
      if ( ++v19 >= v18 )
        goto LABEL_34;
    }
    v22 = 0;
    while ( v20->m_attractPeds.dataPtr[v22] != pPed )
    {
      if ( ++v22 >= v21 )
        goto LABEL_29;
    }
    return 1;
  }
LABEL_34:
  v26 = this->m_pizzas.numEntries;
  if ( v26 >= 1 )
  {
    v27 = 0;
    while ( 1 )
    {
      v28 = this->m_pizzas.dataPtr[v27];
      v29 = v28->m_attractPeds.numEntries;
      if ( v29 >= 1 )
        break;
LABEL_40:
      v31 = v28->m_arrivedPeds.numEntries;
      if ( v31 >= 1 )
      {
        v32 = v28->m_arrivedPeds.dataPtr;
        v33 = 0;
        while ( v32[v33] != pPed )
        {
          if ( ++v33 >= v31 )
            goto LABEL_44;
        }
        return 1;
      }
LABEL_44:
      if ( ++v27 >= v26 )
        goto LABEL_45;
    }
    v30 = 0;
    while ( v28->m_attractPeds.dataPtr[v30] != pPed )
    {
      if ( ++v30 >= v29 )
        goto LABEL_40;
    }
    return 1;
  }
LABEL_45:
  v34 = this->m_shelters.numEntries;
  if ( v34 >= 1 )
  {
    v35 = 0;
    while ( 1 )
    {
      v36 = this->m_shelters.dataPtr[v35];
      v37 = v36->m_attractPeds.numEntries;
      if ( v37 >= 1 )
        break;
LABEL_51:
      v39 = v36->m_arrivedPeds.numEntries;
      if ( v39 >= 1 )
      {
        v40 = v36->m_arrivedPeds.dataPtr;
        v41 = 0;
        while ( v40[v41] != pPed )
        {
          if ( ++v41 >= v39 )
            goto LABEL_55;
        }
        return 1;
      }
LABEL_55:
      if ( ++v35 >= v34 )
        goto LABEL_56;
    }
    v38 = 0;
    while ( v36->m_attractPeds.dataPtr[v38] != pPed )
    {
      if ( ++v38 >= v37 )
        goto LABEL_51;
    }
    return 1;
  }
LABEL_56:
  v42 = this->m_triggerScripts.numEntries;
  if ( v42 >= 1 )
  {
    v43 = 0;
    while ( 1 )
    {
      v44 = this->m_triggerScripts.dataPtr[v43];
      v45 = v44->m_attractPeds.numEntries;
      if ( v45 >= 1 )
        break;
LABEL_62:
      v47 = v44->m_arrivedPeds.numEntries;
      if ( v47 >= 1 )
      {
        v48 = v44->m_arrivedPeds.dataPtr;
        v49 = 0;
        while ( v48[v49] != pPed )
        {
          if ( ++v49 >= v47 )
            goto LABEL_66;
        }
        return 1;
      }
LABEL_66:
      if ( ++v43 >= v42 )
        goto LABEL_67;
    }
    v46 = 0;
    while ( v44->m_attractPeds.dataPtr[v46] != pPed )
    {
      if ( ++v46 >= v45 )
        goto LABEL_62;
    }
    return 1;
  }
LABEL_67:
  v50 = this->m_lookAts.numEntries;
  if ( v50 >= 1 )
  {
    v51 = 0;
    while ( 1 )
    {
      v52 = this->m_lookAts.dataPtr[v51];
      v53 = v52->m_attractPeds.numEntries;
      if ( v53 >= 1 )
        break;
LABEL_73:
      v55 = v52->m_arrivedPeds.numEntries;
      if ( v55 >= 1 )
      {
        v56 = v52->m_arrivedPeds.dataPtr;
        v57 = 0;
        while ( v56[v57] != pPed )
        {
          if ( ++v57 >= v55 )
            goto LABEL_77;
        }
        return 1;
      }
LABEL_77:
      if ( ++v51 >= v50 )
        goto LABEL_78;
    }
    v54 = 0;
    while ( v52->m_attractPeds.dataPtr[v54] != pPed )
    {
      if ( ++v54 >= v53 )
        goto LABEL_73;
    }
    return 1;
  }
LABEL_78:
  v58 = this->m_scripted.numEntries;
  if ( v58 >= 1 )
  {
    v59 = 0;
    while ( 1 )
    {
      v60 = this->m_scripted.dataPtr[v59];
      v61 = v60->m_attractPeds.numEntries;
      if ( v61 >= 1 )
        break;
LABEL_84:
      v63 = v60->m_arrivedPeds.numEntries;
      if ( v63 >= 1 )
      {
        v64 = v60->m_arrivedPeds.dataPtr;
        v65 = 0;
        while ( v64[v65] != pPed )
        {
          if ( ++v65 >= v63 )
            goto LABEL_88;
        }
        return 1;
      }
LABEL_88:
      if ( ++v59 >= v58 )
        goto LABEL_89;
    }
    v62 = 0;
    while ( v60->m_attractPeds.dataPtr[v62] != pPed )
    {
      if ( ++v62 >= v61 )
        goto LABEL_84;
    }
    return 1;
  }
LABEL_89:
  v66 = this->m_parks.numEntries;
  if ( v66 >= 1 )
  {
    v67 = 0;
    while ( 1 )
    {
      v68 = this->m_parks.dataPtr[v67];
      v69 = v68->m_attractPeds.numEntries;
      if ( v69 >= 1 )
        break;
LABEL_95:
      v71 = v68->m_arrivedPeds.numEntries;
      if ( v71 >= 1 )
      {
        v72 = v68->m_arrivedPeds.dataPtr;
        v73 = 0;
        while ( v72[v73] != pPed )
        {
          if ( ++v73 >= v71 )
            goto LABEL_99;
        }
        return 1;
      }
LABEL_99:
      if ( ++v67 >= v66 )
        goto LABEL_100;
    }
    v70 = 0;
    while ( v68->m_attractPeds.dataPtr[v70] != pPed )
    {
      if ( ++v70 >= v69 )
        goto LABEL_95;
    }
    return 1;
  }
LABEL_100:
  v74 = this->m_steps.numEntries;
  if ( v74 >= 1 )
  {
    v75 = this->m_steps.dataPtr;
    v76 = 0;
    while ( 1 )
    {
      v77 = v75[v76];
      v78 = v77->m_attractPeds.numEntries;
      if ( v78 >= 1 )
        break;
LABEL_106:
      v80 = v77->m_arrivedPeds.numEntries;
      if ( v80 >= 1 )
      {
        v81 = v77->m_arrivedPeds.dataPtr;
        v82 = 0;
        while ( v81[v82] != pPed )
        {
          if ( ++v82 >= v80 )
            goto LABEL_110;
        }
        return 1;
      }
LABEL_110:
      ++v76;
      result = 0;
      if ( v76 >= v74 )
        return result;
    }
    v79 = 0;
    while ( v77->m_attractPeds.dataPtr[v79] != pPed )
    {
      if ( ++v79 >= v78 )
        goto LABEL_106;
    }
    return 1;
  }
  return 0;
}

//----- (004AAC6C) --------------------------------------------------------
bool __fastcall CPedAttractorManager::BroadcastArrival(
        CPedAttractorManager *this,
        CPed *pPed,
        CPedAttractor *pInputAttractor,
        SArray<CPedAttractor *> *attractors)
{
  signed int numEntries; // r12
  CPedAttractor **dataPtr; // lr
  CPedAttractor *v6; // r0
  signed int v7; // r3
  CPedAttractor *v8; // r4

  if ( !pInputAttractor )
    return 0;
  numEntries = attractors->numEntries;
  if ( numEntries < 1 )
    return 0;
  dataPtr = attractors->dataPtr;
  v6 = 0;
  v7 = 0;
  do
  {
    v8 = dataPtr[v7++];
    if ( v8 == pInputAttractor )
      v6 = v8;
  }
  while ( v7 < numEntries && v8 != pInputAttractor );
  if ( !v6 )
    return 0;
  CPedAttractor::BroadcastArrival(v6, pPed);
  return 1;
}

//----- (004AACA8) --------------------------------------------------------
bool __fastcall CPedAttractorManager::DeRegisterPed(CPedAttractorManager *this, CPed *pPed, CPedAttractor *pAttractor)
{
  CPedAttractorManager *v6; // r0
  CPedAttractorManager *p_m_atms; // r3
  bool result; // r0
  CPed *v9; // r1
  CPedAttractor *v10; // r2

  if ( !pAttractor || !CPedAttractorManager::IsPedRegisteredWithEffect(this, pPed) )
    return 0;
  v6 = (CPedAttractorManager *)((int (__fastcall *)(CPedAttractor *))*pAttractor->_vptr$CPedAttractor)(pAttractor);
  switch ( (unsigned int)v6 )
  {
    case 0u:
      p_m_atms = (CPedAttractorManager *)&this->m_atms;
      goto LABEL_15;
    case 1u:
      v9 = pPed;
      v10 = pAttractor;
      p_m_atms = this;
      goto LABEL_16;
    case 2u:
      p_m_atms = (CPedAttractorManager *)&this->m_stops;
      goto LABEL_15;
    case 3u:
      p_m_atms = (CPedAttractorManager *)&this->m_pizzas;
      goto LABEL_15;
    case 4u:
      p_m_atms = (CPedAttractorManager *)&this->m_shelters;
      goto LABEL_15;
    case 5u:
      p_m_atms = (CPedAttractorManager *)&this->m_triggerScripts;
      goto LABEL_15;
    case 6u:
      p_m_atms = (CPedAttractorManager *)&this->m_lookAts;
      goto LABEL_15;
    case 7u:
      p_m_atms = (CPedAttractorManager *)&this->m_scripted;
      goto LABEL_15;
    case 8u:
      p_m_atms = (CPedAttractorManager *)&this->m_parks;
      goto LABEL_15;
    case 9u:
      p_m_atms = (CPedAttractorManager *)&this->m_steps;
LABEL_15:
      v9 = pPed;
      v10 = pAttractor;
LABEL_16:
      result = CPedAttractorManager::DeRegisterPed(v6, v9, v10, &p_m_atms->m_seats);
      break;
    default:
      return 0;
  }
  return result;
}

//----- (004AAD30) --------------------------------------------------------
bool __fastcall CPedAttractorManager::DeRegisterPed(
        CPedAttractorManager *this,
        CPed *pPed,
        CPedAttractor *pInputAttractor,
        SArray<CPedAttractor *> *attractors)
{
  signed int numEntries; // r0
  CPedAttractor *v7; // r5
  signed int v8; // r3
  CPedAttractor *v9; // r4
  unsigned int v10; // r1
  CPed **p_m_pPed; // r0
  size_t v12; // r2
  unsigned int v13; // r3
  unsigned int v15; // r1
  size_t v16; // r2
  CPed **dataPtr; // r0
  unsigned int v18; // r3
  int v19; // r0
  unsigned int v20; // r1
  size_t v21; // r2
  CPedAttractor **v22; // r0
  unsigned int v23; // r3

  if ( !pInputAttractor )
    return 0;
  numEntries = attractors->numEntries;
  if ( numEntries < 1 )
    return 0;
  v7 = 0;
  v8 = 0;
  do
  {
    v9 = attractors->dataPtr[v8++];
    if ( v9 == pInputAttractor )
      v7 = v9;
  }
  while ( v8 < numEntries && v9 != pInputAttractor );
  if ( !v7 )
    return 0;
  v10 = v7->m_pedTaskPairs.numEntries;
  if ( v10 )
  {
    p_m_pPed = &v7->m_pedTaskPairs.dataPtr->m_pPed;
    v12 = 20 * v10 - 20;
    v13 = 0;
    while ( *p_m_pPed != pPed )
    {
      ++v13;
      p_m_pPed += 5;
      v12 -= 20;
      if ( v13 >= v10 )
        goto LABEL_16;
    }
    memmove(p_m_pPed, p_m_pPed + 5, v12);
    --v7->m_pedTaskPairs.numEntries;
  }
LABEL_16:
  v15 = v7->m_attractPeds.numEntries;
  if ( v15 )
  {
    v16 = 4 * v15 - 4;
    dataPtr = v7->m_attractPeds.dataPtr;
    v18 = 0;
    while ( *dataPtr != pPed )
    {
      ++v18;
      ++dataPtr;
      v16 -= 4;
      if ( v18 >= v15 )
        goto LABEL_20;
    }
    memmove(dataPtr, dataPtr + 1, v16);
    v19 = v7->m_attractPeds.numEntries - 1;
    v7->m_attractPeds.numEntries = v19;
  }
  else
  {
LABEL_20:
    (*((void (__fastcall **)(CPedAttractor *, CPed *))v7->_vptr$CPedAttractor + 6))(v7, pPed);
    v19 = v7->m_attractPeds.numEntries;
  }
  if ( !(v19 + v7->m_arrivedPeds.numEntries) )
  {
    v20 = attractors->numEntries;
    if ( v20 )
    {
      v21 = 4 * v20 - 4;
      v22 = attractors->dataPtr;
      v23 = 0;
      while ( *v22 != v7 )
      {
        ++v23;
        ++v22;
        v21 -= 4;
        if ( v23 >= v20 )
          goto LABEL_29;
      }
      memmove(v22, v22 + 1, v21);
      --attractors->numEntries;
    }
LABEL_29:
    (*((void (__fastcall **)(CPedAttractor *))v7->_vptr$CPedAttractor + 2))(v7);
  }
  return 1;
}

//----- (004AAE28) --------------------------------------------------------
bool __fastcall CPedAttractorManager::RemoveEffect(const CPedAttractorManager *this, const C2dEffect *pEffect)
{
  int i; // r10
  CPedAttractor *v3; // r5
  int v4; // r8
  int v5; // r6
  CPedTaskPair *v6; // r4
  CTask *m_pTask; // r0
  int j; // r4
  CPedAttractor *v9; // r5
  int v10; // r8
  int v11; // r9
  CPedTaskPair *v12; // r10
  CTask *v13; // r0
  int k; // r10
  CPedAttractor *v15; // r5
  int v16; // r8
  int v17; // r6
  CPedTaskPair *v18; // r4
  CTask *v19; // r0
  int m; // r10
  CPedAttractor *v21; // r5
  int v22; // r8
  int v23; // r6
  CPedTaskPair *v24; // r4
  CTask *v25; // r0
  int n; // r10
  CPedAttractor *v27; // r5
  int v28; // r8
  int v29; // r6
  CPedTaskPair *v30; // r4
  CTask *v31; // r0
  int ii; // r10
  CPedAttractor *v33; // r5
  int v34; // r8
  int v35; // r6
  CPedTaskPair *v36; // r4
  CTask *v37; // r0
  int jj; // r10
  CPedAttractor *v39; // r5
  int v40; // r8
  int v41; // r6
  CPedTaskPair *v42; // r4
  CTask *v43; // r0
  int kk; // r10
  CPedAttractor *v45; // r5
  int v46; // r8
  int v47; // r6
  CPedTaskPair *v48; // r4
  CTask *v49; // r0
  int mm; // r10
  CPedAttractor *v51; // r5
  int v52; // r8
  int v53; // r6
  CPedTaskPair *v54; // r4
  CTask *v55; // r0
  int nn; // r10
  CPedAttractor *v57; // r5
  int v58; // r8
  int v59; // r6
  CPedTaskPair *v60; // r4
  CTask *v61; // r0
  signed int numEntries; // [sp+0h] [bp-28h]
  signed int v64; // [sp+0h] [bp-28h]
  signed int v65; // [sp+0h] [bp-28h]
  signed int v66; // [sp+0h] [bp-28h]
  signed int v67; // [sp+0h] [bp-28h]
  signed int v68; // [sp+0h] [bp-28h]
  signed int v69; // [sp+0h] [bp-28h]
  signed int v70; // [sp+0h] [bp-28h]
  signed int v71; // [sp+0h] [bp-28h]
  signed int v72; // [sp+0h] [bp-28h]

  switch ( pEffect->attr.q.m_type )
  {
    case 0u:
      numEntries = this->m_atms.numEntries;
      if ( numEntries >= 1 )
      {
        for ( i = 0; i != numEntries; ++i )
        {
          v3 = this->m_atms.dataPtr[i];
          if ( v3->m_pEffect == pEffect )
          {
            v4 = v3->m_pedTaskPairs.numEntries;
            if ( v4 >= 1 )
            {
              v5 = 0;
              do
              {
                v6 = &v3->m_pedTaskPairs.dataPtr[v5];
                m_pTask = v6->m_pTask;
                v6->m_pPed = 0;
                if ( m_pTask )
                  (*((void (__fastcall **)(CTask *))m_pTask->_vptr$CTask + 1))(m_pTask);
                ++v5;
                --v4;
                v6->m_pTask = 0;
                v6->m_iSlot = -1;
              }
              while ( v4 );
            }
          }
        }
      }
      break;
    case 1u:
      v64 = this->m_seats.numEntries;
      if ( v64 >= 1 )
      {
        for ( j = 0; j != v64; ++j )
        {
          v9 = this->m_seats.dataPtr[j];
          if ( v9->m_pEffect == pEffect )
          {
            v10 = v9->m_pedTaskPairs.numEntries;
            if ( v10 >= 1 )
            {
              v11 = 0;
              do
              {
                v12 = &v9->m_pedTaskPairs.dataPtr[v11];
                v13 = v12->m_pTask;
                v12->m_pPed = 0;
                if ( v13 )
                  (*((void (__fastcall **)(CTask *))v13->_vptr$CTask + 1))(v13);
                ++v11;
                --v10;
                v12->m_pTask = 0;
                v12->m_iSlot = -1;
              }
              while ( v10 );
            }
          }
        }
      }
      break;
    case 2u:
      v65 = this->m_stops.numEntries;
      if ( v65 >= 1 )
      {
        for ( k = 0; k != v65; ++k )
        {
          v15 = this->m_stops.dataPtr[k];
          if ( v15->m_pEffect == pEffect )
          {
            v16 = v15->m_pedTaskPairs.numEntries;
            if ( v16 >= 1 )
            {
              v17 = 0;
              do
              {
                v18 = &v15->m_pedTaskPairs.dataPtr[v17];
                v19 = v18->m_pTask;
                v18->m_pPed = 0;
                if ( v19 )
                  (*((void (__fastcall **)(CTask *))v19->_vptr$CTask + 1))(v19);
                ++v17;
                --v16;
                v18->m_pTask = 0;
                v18->m_iSlot = -1;
              }
              while ( v16 );
            }
          }
        }
      }
      break;
    case 3u:
      v66 = this->m_pizzas.numEntries;
      if ( v66 >= 1 )
      {
        for ( m = 0; m != v66; ++m )
        {
          v21 = this->m_pizzas.dataPtr[m];
          if ( v21->m_pEffect == pEffect )
          {
            v22 = v21->m_pedTaskPairs.numEntries;
            if ( v22 >= 1 )
            {
              v23 = 0;
              do
              {
                v24 = &v21->m_pedTaskPairs.dataPtr[v23];
                v25 = v24->m_pTask;
                v24->m_pPed = 0;
                if ( v25 )
                  (*((void (__fastcall **)(CTask *))v25->_vptr$CTask + 1))(v25);
                ++v23;
                --v22;
                v24->m_pTask = 0;
                v24->m_iSlot = -1;
              }
              while ( v22 );
            }
          }
        }
      }
      break;
    case 4u:
      v67 = this->m_shelters.numEntries;
      if ( v67 >= 1 )
      {
        for ( n = 0; n != v67; ++n )
        {
          v27 = this->m_shelters.dataPtr[n];
          if ( v27->m_pEffect == pEffect )
          {
            v28 = v27->m_pedTaskPairs.numEntries;
            if ( v28 >= 1 )
            {
              v29 = 0;
              do
              {
                v30 = &v27->m_pedTaskPairs.dataPtr[v29];
                v31 = v30->m_pTask;
                v30->m_pPed = 0;
                if ( v31 )
                  (*((void (__fastcall **)(CTask *))v31->_vptr$CTask + 1))(v31);
                ++v29;
                --v28;
                v30->m_pTask = 0;
                v30->m_iSlot = -1;
              }
              while ( v28 );
            }
          }
        }
      }
      break;
    case 5u:
      v68 = this->m_triggerScripts.numEntries;
      if ( v68 >= 1 )
      {
        for ( ii = 0; ii != v68; ++ii )
        {
          v33 = this->m_triggerScripts.dataPtr[ii];
          if ( v33->m_pEffect == pEffect )
          {
            v34 = v33->m_pedTaskPairs.numEntries;
            if ( v34 >= 1 )
            {
              v35 = 0;
              do
              {
                v36 = &v33->m_pedTaskPairs.dataPtr[v35];
                v37 = v36->m_pTask;
                v36->m_pPed = 0;
                if ( v37 )
                  (*((void (__fastcall **)(CTask *))v37->_vptr$CTask + 1))(v37);
                ++v35;
                --v34;
                v36->m_pTask = 0;
                v36->m_iSlot = -1;
              }
              while ( v34 );
            }
          }
        }
      }
      break;
    case 6u:
      v69 = this->m_lookAts.numEntries;
      if ( v69 >= 1 )
      {
        for ( jj = 0; jj != v69; ++jj )
        {
          v39 = this->m_lookAts.dataPtr[jj];
          if ( v39->m_pEffect == pEffect )
          {
            v40 = v39->m_pedTaskPairs.numEntries;
            if ( v40 >= 1 )
            {
              v41 = 0;
              do
              {
                v42 = &v39->m_pedTaskPairs.dataPtr[v41];
                v43 = v42->m_pTask;
                v42->m_pPed = 0;
                if ( v43 )
                  (*((void (__fastcall **)(CTask *))v43->_vptr$CTask + 1))(v43);
                ++v41;
                --v40;
                v42->m_pTask = 0;
                v42->m_iSlot = -1;
              }
              while ( v40 );
            }
          }
        }
      }
      break;
    case 7u:
      v70 = this->m_scripted.numEntries;
      if ( v70 >= 1 )
      {
        for ( kk = 0; kk != v70; ++kk )
        {
          v45 = this->m_scripted.dataPtr[kk];
          if ( v45->m_pEffect == pEffect )
          {
            v46 = v45->m_pedTaskPairs.numEntries;
            if ( v46 >= 1 )
            {
              v47 = 0;
              do
              {
                v48 = &v45->m_pedTaskPairs.dataPtr[v47];
                v49 = v48->m_pTask;
                v48->m_pPed = 0;
                if ( v49 )
                  (*((void (__fastcall **)(CTask *))v49->_vptr$CTask + 1))(v49);
                ++v47;
                --v46;
                v48->m_pTask = 0;
                v48->m_iSlot = -1;
              }
              while ( v46 );
            }
          }
        }
      }
      break;
    case 8u:
      v71 = this->m_parks.numEntries;
      if ( v71 >= 1 )
      {
        for ( mm = 0; mm != v71; ++mm )
        {
          v51 = this->m_parks.dataPtr[mm];
          if ( v51->m_pEffect == pEffect )
          {
            v52 = v51->m_pedTaskPairs.numEntries;
            if ( v52 >= 1 )
            {
              v53 = 0;
              do
              {
                v54 = &v51->m_pedTaskPairs.dataPtr[v53];
                v55 = v54->m_pTask;
                v54->m_pPed = 0;
                if ( v55 )
                  (*((void (__fastcall **)(CTask *))v55->_vptr$CTask + 1))(v55);
                ++v53;
                --v52;
                v54->m_pTask = 0;
                v54->m_iSlot = -1;
              }
              while ( v52 );
            }
          }
        }
      }
      break;
    case 9u:
      v72 = this->m_steps.numEntries;
      if ( v72 >= 1 )
      {
        for ( nn = 0; nn != v72; ++nn )
        {
          v57 = this->m_steps.dataPtr[nn];
          if ( v57->m_pEffect == pEffect )
          {
            v58 = v57->m_pedTaskPairs.numEntries;
            if ( v58 >= 1 )
            {
              v59 = 0;
              do
              {
                v60 = &v57->m_pedTaskPairs.dataPtr[v59];
                v61 = v60->m_pTask;
                v60->m_pPed = 0;
                if ( v61 )
                  (*((void (__fastcall **)(CTask *))v61->_vptr$CTask + 1))(v61);
                ++v59;
                --v58;
                v60->m_pTask = 0;
                v60->m_iSlot = -1;
              }
              while ( v58 );
            }
          }
        }
      }
      break;
    default:
      return 0;
  }
  return 0;
}

//----- (004AB234) --------------------------------------------------------
bool __fastcall CPedAttractorManager::RemoveEffect(
        const CPedAttractorManager *this,
        const C2dEffect *pEffect,
        const SArray<CPedAttractor *> *attractors)
{
  int i; // r6
  CPedAttractor *v4; // r4
  int v5; // r8
  int v6; // r9
  CPedTaskPair *v7; // r10
  CTask *m_pTask; // r0
  signed int numEntries; // [sp+0h] [bp-28h]

  numEntries = attractors->numEntries;
  if ( numEntries >= 1 )
  {
    for ( i = 0; i != numEntries; ++i )
    {
      v4 = attractors->dataPtr[i];
      if ( v4->m_pEffect == pEffect )
      {
        v5 = v4->m_pedTaskPairs.numEntries;
        if ( v5 >= 1 )
        {
          v6 = 0;
          do
          {
            v7 = &v4->m_pedTaskPairs.dataPtr[v6];
            m_pTask = v7->m_pTask;
            v7->m_pPed = 0;
            if ( m_pTask )
              (*((void (__fastcall **)(CTask *))m_pTask->_vptr$CTask + 1))(m_pTask);
            ++v6;
            --v5;
            v7->m_pTask = 0;
            v7->m_iSlot = -1;
          }
          while ( v5 );
        }
      }
    }
  }
  return 0;
}

//----- (004AB2AC) --------------------------------------------------------
bool __fastcall CPedAttractorManager::HasEmptySlot(
        const CPedAttractorManager *this,
        const C2dEffect *pEffect,
        const CEntity *pEntity)
{
  signed int numEntries; // r12
  CPedAttractor **dataPtr; // lr
  int v6; // r3
  CPedAttractor *v7; // r0
  const C2dEffect *m_pEffect; // r4
  bool v9; // zf

  if ( !pEffect || pEffect->m_type != 3 )
    return 0;
  switch ( pEffect->attr.q.m_type )
  {
    case 0u:
      this = (const CPedAttractorManager *)((char *)this + 12);
      goto LABEL_14;
    case 1u:
      goto LABEL_14;
    case 2u:
      this = (const CPedAttractorManager *)((char *)this + 24);
      goto LABEL_14;
    case 3u:
      this = (const CPedAttractorManager *)((char *)this + 36);
      goto LABEL_14;
    case 4u:
      this = (const CPedAttractorManager *)((char *)this + 48);
      goto LABEL_14;
    case 5u:
      this = (const CPedAttractorManager *)((char *)this + 60);
      goto LABEL_14;
    case 6u:
      this = (const CPedAttractorManager *)((char *)this + 72);
      goto LABEL_14;
    case 7u:
      this = (const CPedAttractorManager *)((char *)this + 84);
      goto LABEL_14;
    case 8u:
      this = (const CPedAttractorManager *)((char *)this + 96);
      goto LABEL_14;
    case 9u:
      this = (const CPedAttractorManager *)((char *)this + 108);
LABEL_14:
      numEntries = this->m_seats.numEntries;
      if ( numEntries < 1 )
        return 1;
      dataPtr = this->m_seats.dataPtr;
      v6 = 0;
      break;
    default:
      return 1;
  }
  while ( 1 )
  {
    v7 = dataPtr[v6];
    m_pEffect = v7->m_pEffect;
    v9 = m_pEffect == pEffect;
    if ( m_pEffect == pEffect )
      v9 = v7->m_pEntity == pEntity;
    if ( v9 )
      break;
    if ( ++v6 >= numEntries )
      return 1;
  }
  return (signed int)(v7->m_attractPeds.numEntries + v7->m_arrivedPeds.numEntries) < v7->m_iMaxNoOfPeds;
}

//----- (004AB336) --------------------------------------------------------
CPedAttractor *__fastcall CPedAttractorManager::FindAssociatedAttractor(
        const CPedAttractorManager *this,
        const C2dEffect *pEffect,
        const CEntity *pEntity,
        const SArray<CPedAttractor *> *attractors)
{
  signed int numEntries; // r12
  CPedAttractor **dataPtr; // lr
  int v6; // r3
  CPedAttractor *result; // r0
  C2dEffect *m_pEffect; // r4
  bool v9; // zf

  numEntries = attractors->numEntries;
  if ( numEntries < 1 )
    return 0;
  dataPtr = attractors->dataPtr;
  v6 = 0;
  while ( 1 )
  {
    result = dataPtr[v6];
    m_pEffect = result->m_pEffect;
    v9 = m_pEffect == pEffect;
    if ( m_pEffect == pEffect )
      v9 = result->m_pEntity == pEntity;
    if ( v9 )
      break;
    if ( ++v6 >= numEntries )
      return 0;
  }
  return result;
}

//----- (004AB364) --------------------------------------------------------
bool __fastcall CPedAttractorManager::HasQueueTailArrivedAtSlot(
        CPedAttractorManager *this,
        const C2dEffect *pEffect,
        const CEntity *pEntity)
{
  bool result; // r0
  signed int numEntries; // r12
  CPedAttractor **dataPtr; // lr
  int v6; // r4
  CPedAttractor *v7; // r3
  const C2dEffect *m_pEffect; // r0
  bool v9; // zf
  unsigned int v10; // r0
  int (**v11)(void); // r4
  CPed **v12; // r0
  CPed *v13; // r1
  CPed *v14; // r3
  const CTaskManager *p_m_taskManager; // r0
  CTask *ActiveTaskByType; // r1

  if ( !pEffect || pEffect->m_type != 3 )
    return 0;
  switch ( pEffect->attr.q.m_type )
  {
    case 0u:
      this = (CPedAttractorManager *)((char *)this + 12);
      goto LABEL_14;
    case 1u:
      goto LABEL_14;
    case 2u:
      this = (CPedAttractorManager *)((char *)this + 24);
      goto LABEL_14;
    case 3u:
      this = (CPedAttractorManager *)((char *)this + 36);
      goto LABEL_14;
    case 4u:
      this = (CPedAttractorManager *)((char *)this + 48);
      goto LABEL_14;
    case 5u:
      this = (CPedAttractorManager *)((char *)this + 60);
      goto LABEL_14;
    case 6u:
      this = (CPedAttractorManager *)((char *)this + 72);
      goto LABEL_14;
    case 7u:
      this = (CPedAttractorManager *)((char *)this + 84);
      goto LABEL_14;
    case 8u:
      this = (CPedAttractorManager *)((char *)this + 96);
      goto LABEL_14;
    case 9u:
      this = (CPedAttractorManager *)((char *)this + 108);
LABEL_14:
      numEntries = this->m_seats.numEntries;
      if ( numEntries < 1 )
        return 1;
      dataPtr = this->m_seats.dataPtr;
      v6 = 0;
      break;
    default:
      return 1;
  }
  while ( 1 )
  {
    v7 = dataPtr[v6];
    m_pEffect = v7->m_pEffect;
    v9 = m_pEffect == pEffect;
    if ( m_pEffect == pEffect )
      v9 = v7->m_pEntity == pEntity;
    if ( v9 )
      break;
    if ( ++v6 >= numEntries )
      return 1;
  }
  v10 = v7->m_arrivedPeds.numEntries;
  if ( !v10 )
    return 1;
  v11 = (int (**)(void))(v10 - 1);
  v12 = v7->m_arrivedPeds.dataPtr;
  v13 = v12[(_DWORD)v11];
  if ( !v13 )
    return 1;
  v14 = *v12;
  p_m_taskManager = &v13->m_pPedIntelligence->m_taskManager;
  if ( v13 == v14 )
    return CTaskManager::FindActiveTaskByType(p_m_taskManager, 235) != 0;
  ActiveTaskByType = CTaskManager::FindActiveTaskByType(p_m_taskManager, 234);
  result = 0;
  if ( ActiveTaskByType )
  {
    if ( ActiveTaskByType[2]._vptr$CTask == v11 )
      return 1;
  }
  return result;
}

//----- (004AB41C) --------------------------------------------------------
bool __fastcall CPedAttractorManager::BroadcastDeparture(
        CPedAttractorManager *this,
        CPed *pPed,
        CPedAttractor *pAttractor)
{
  signed int numEntries; // r0
  CPedAttractor *v7; // r4
  signed int v8; // r2
  CPedAttractor *v9; // r3
  unsigned int v10; // r1
  size_t v11; // r2
  CPedAttractor **dataPtr; // r0
  unsigned int v13; // r3
  signed int v14; // r0
  signed int v15; // r2
  CPedAttractor *v16; // r3
  unsigned int v17; // r1
  size_t v18; // r2
  CPedAttractor **v19; // r0
  unsigned int v20; // r3
  signed int v21; // r0
  signed int v22; // r2
  CPedAttractor *v23; // r3
  unsigned int v24; // r1
  size_t v25; // r2
  CPedAttractor **v26; // r0
  unsigned int v27; // r3
  signed int v28; // r0
  signed int v29; // r2
  CPedAttractor *v30; // r3
  unsigned int v31; // r1
  size_t v32; // r2
  CPedAttractor **v33; // r0
  unsigned int v34; // r3
  signed int v35; // r0
  signed int v36; // r2
  CPedAttractor *v37; // r3
  unsigned int v38; // r1
  size_t v39; // r2
  CPedAttractor **v40; // r0
  unsigned int v41; // r3
  signed int v42; // r0
  signed int v43; // r2
  CPedAttractor *v44; // r3
  unsigned int v45; // r1
  size_t v46; // r2
  CPedAttractor **v47; // r0
  unsigned int v48; // r3
  signed int v49; // r0
  signed int v50; // r2
  CPedAttractor *v51; // r3
  unsigned int v52; // r1
  size_t v53; // r2
  CPedAttractor **v54; // r0
  unsigned int v55; // r3
  signed int v56; // r0
  signed int v57; // r2
  CPedAttractor *v58; // r3
  unsigned int v59; // r1
  size_t v60; // r2
  CPedAttractor **v61; // r0
  unsigned int v62; // r3
  signed int v63; // r0
  signed int v64; // r2
  CPedAttractor *v65; // r3
  unsigned int v66; // r1
  size_t v67; // r2
  CPedAttractor **v68; // r0
  unsigned int v69; // r3
  signed int v70; // r0
  signed int v71; // r2
  CPedAttractor *v72; // r3
  unsigned int v73; // r1
  size_t v74; // r2
  CPedAttractor **v75; // r0
  unsigned int v76; // r3

  if ( !pAttractor || !CPedAttractorManager::IsPedRegisteredWithEffect(this, pPed) )
    return 0;
  switch ( ((int (__fastcall *)(CPedAttractor *))*pAttractor->_vptr$CPedAttractor)(pAttractor) )
  {
    case 0:
      numEntries = this->m_atms.numEntries;
      if ( numEntries < 1 )
        return 0;
      v7 = 0;
      v8 = 0;
      do
      {
        v9 = this->m_atms.dataPtr[v8++];
        if ( v9 == pAttractor )
          v7 = v9;
      }
      while ( v8 < numEntries && v9 != pAttractor );
      if ( !v7 )
        return 0;
      (*((void (__fastcall **)(CPedAttractor *, CPed *))v7->_vptr$CPedAttractor + 6))(v7, pPed);
      if ( v7->m_attractPeds.numEntries + v7->m_arrivedPeds.numEntries )
        return 1;
      v10 = this->m_atms.numEntries;
      if ( !v10 )
        goto LABEL_145;
      v11 = 4 * v10 - 4;
      dataPtr = this->m_atms.dataPtr;
      v13 = 0;
      while ( *dataPtr != v7 )
      {
        ++v13;
        ++dataPtr;
        v11 -= 4;
        if ( v13 >= v10 )
          goto LABEL_145;
      }
      memmove(dataPtr, dataPtr + 1, v11);
      --this->m_atms.numEntries;
      goto LABEL_145;
    case 1:
      v14 = this->m_seats.numEntries;
      if ( v14 < 1 )
        return 0;
      v7 = 0;
      v15 = 0;
      do
      {
        v16 = this->m_seats.dataPtr[v15++];
        if ( v16 == pAttractor )
          v7 = v16;
      }
      while ( v15 < v14 && v16 != pAttractor );
      if ( !v7 )
        return 0;
      (*((void (__fastcall **)(CPedAttractor *, CPed *))v7->_vptr$CPedAttractor + 6))(v7, pPed);
      if ( v7->m_attractPeds.numEntries + v7->m_arrivedPeds.numEntries )
        return 1;
      v17 = this->m_seats.numEntries;
      if ( !v17 )
        goto LABEL_145;
      v18 = 4 * v17 - 4;
      v19 = this->m_seats.dataPtr;
      v20 = 0;
      while ( *v19 != v7 )
      {
        ++v20;
        ++v19;
        v18 -= 4;
        if ( v20 >= v17 )
          goto LABEL_145;
      }
      memmove(v19, v19 + 1, v18);
      --this->m_seats.numEntries;
      goto LABEL_145;
    case 2:
      v21 = this->m_stops.numEntries;
      if ( v21 < 1 )
        return 0;
      v7 = 0;
      v22 = 0;
      do
      {
        v23 = this->m_stops.dataPtr[v22++];
        if ( v23 == pAttractor )
          v7 = v23;
      }
      while ( v22 < v21 && v23 != pAttractor );
      if ( !v7 )
        return 0;
      (*((void (__fastcall **)(CPedAttractor *, CPed *))v7->_vptr$CPedAttractor + 6))(v7, pPed);
      if ( v7->m_attractPeds.numEntries + v7->m_arrivedPeds.numEntries )
        return 1;
      v24 = this->m_stops.numEntries;
      if ( !v24 )
        goto LABEL_145;
      v25 = 4 * v24 - 4;
      v26 = this->m_stops.dataPtr;
      v27 = 0;
      while ( *v26 != v7 )
      {
        ++v27;
        ++v26;
        v25 -= 4;
        if ( v27 >= v24 )
          goto LABEL_145;
      }
      memmove(v26, v26 + 1, v25);
      --this->m_stops.numEntries;
      goto LABEL_145;
    case 3:
      v28 = this->m_pizzas.numEntries;
      if ( v28 < 1 )
        return 0;
      v7 = 0;
      v29 = 0;
      do
      {
        v30 = this->m_pizzas.dataPtr[v29++];
        if ( v30 == pAttractor )
          v7 = v30;
      }
      while ( v29 < v28 && v30 != pAttractor );
      if ( !v7 )
        return 0;
      (*((void (__fastcall **)(CPedAttractor *, CPed *))v7->_vptr$CPedAttractor + 6))(v7, pPed);
      if ( v7->m_attractPeds.numEntries + v7->m_arrivedPeds.numEntries )
        return 1;
      v31 = this->m_pizzas.numEntries;
      if ( !v31 )
        goto LABEL_145;
      v32 = 4 * v31 - 4;
      v33 = this->m_pizzas.dataPtr;
      v34 = 0;
      while ( *v33 != v7 )
      {
        ++v34;
        ++v33;
        v32 -= 4;
        if ( v34 >= v31 )
          goto LABEL_145;
      }
      memmove(v33, v33 + 1, v32);
      --this->m_pizzas.numEntries;
      goto LABEL_145;
    case 4:
      v35 = this->m_shelters.numEntries;
      if ( v35 < 1 )
        return 0;
      v7 = 0;
      v36 = 0;
      do
      {
        v37 = this->m_shelters.dataPtr[v36++];
        if ( v37 == pAttractor )
          v7 = v37;
      }
      while ( v36 < v35 && v37 != pAttractor );
      if ( !v7 )
        return 0;
      (*((void (__fastcall **)(CPedAttractor *, CPed *))v7->_vptr$CPedAttractor + 6))(v7, pPed);
      if ( v7->m_attractPeds.numEntries + v7->m_arrivedPeds.numEntries )
        return 1;
      v38 = this->m_shelters.numEntries;
      if ( !v38 )
        goto LABEL_145;
      v39 = 4 * v38 - 4;
      v40 = this->m_shelters.dataPtr;
      v41 = 0;
      while ( *v40 != v7 )
      {
        ++v41;
        ++v40;
        v39 -= 4;
        if ( v41 >= v38 )
          goto LABEL_145;
      }
      memmove(v40, v40 + 1, v39);
      --this->m_shelters.numEntries;
      goto LABEL_145;
    case 5:
      v42 = this->m_triggerScripts.numEntries;
      if ( v42 < 1 )
        return 0;
      v7 = 0;
      v43 = 0;
      do
      {
        v44 = this->m_triggerScripts.dataPtr[v43++];
        if ( v44 == pAttractor )
          v7 = v44;
      }
      while ( v43 < v42 && v44 != pAttractor );
      if ( !v7 )
        return 0;
      (*((void (__fastcall **)(CPedAttractor *, CPed *))v7->_vptr$CPedAttractor + 6))(v7, pPed);
      if ( v7->m_attractPeds.numEntries + v7->m_arrivedPeds.numEntries )
        return 1;
      v45 = this->m_triggerScripts.numEntries;
      if ( !v45 )
        goto LABEL_145;
      v46 = 4 * v45 - 4;
      v47 = this->m_triggerScripts.dataPtr;
      v48 = 0;
      while ( *v47 != v7 )
      {
        ++v48;
        ++v47;
        v46 -= 4;
        if ( v48 >= v45 )
          goto LABEL_145;
      }
      memmove(v47, v47 + 1, v46);
      --this->m_triggerScripts.numEntries;
      goto LABEL_145;
    case 6:
      v49 = this->m_lookAts.numEntries;
      if ( v49 < 1 )
        return 0;
      v7 = 0;
      v50 = 0;
      do
      {
        v51 = this->m_lookAts.dataPtr[v50++];
        if ( v51 == pAttractor )
          v7 = v51;
      }
      while ( v50 < v49 && v51 != pAttractor );
      if ( !v7 )
        return 0;
      (*((void (__fastcall **)(CPedAttractor *, CPed *))v7->_vptr$CPedAttractor + 6))(v7, pPed);
      if ( v7->m_attractPeds.numEntries + v7->m_arrivedPeds.numEntries )
        return 1;
      v52 = this->m_lookAts.numEntries;
      if ( !v52 )
        goto LABEL_145;
      v53 = 4 * v52 - 4;
      v54 = this->m_lookAts.dataPtr;
      v55 = 0;
      while ( *v54 != v7 )
      {
        ++v55;
        ++v54;
        v53 -= 4;
        if ( v55 >= v52 )
          goto LABEL_145;
      }
      memmove(v54, v54 + 1, v53);
      --this->m_lookAts.numEntries;
      goto LABEL_145;
    case 7:
      v56 = this->m_scripted.numEntries;
      if ( v56 < 1 )
        return 0;
      v7 = 0;
      v57 = 0;
      do
      {
        v58 = this->m_scripted.dataPtr[v57++];
        if ( v58 == pAttractor )
          v7 = v58;
      }
      while ( v57 < v56 && v58 != pAttractor );
      if ( !v7 )
        return 0;
      (*((void (__fastcall **)(CPedAttractor *, CPed *))v7->_vptr$CPedAttractor + 6))(v7, pPed);
      if ( v7->m_attractPeds.numEntries + v7->m_arrivedPeds.numEntries )
        return 1;
      v59 = this->m_scripted.numEntries;
      if ( !v59 )
        goto LABEL_145;
      v60 = 4 * v59 - 4;
      v61 = this->m_scripted.dataPtr;
      v62 = 0;
      while ( *v61 != v7 )
      {
        ++v62;
        ++v61;
        v60 -= 4;
        if ( v62 >= v59 )
          goto LABEL_145;
      }
      memmove(v61, v61 + 1, v60);
      --this->m_scripted.numEntries;
      goto LABEL_145;
    case 8:
      v63 = this->m_parks.numEntries;
      if ( v63 < 1 )
        return 0;
      v7 = 0;
      v64 = 0;
      do
      {
        v65 = this->m_parks.dataPtr[v64++];
        if ( v65 == pAttractor )
          v7 = v65;
      }
      while ( v64 < v63 && v65 != pAttractor );
      if ( !v7 )
        return 0;
      (*((void (__fastcall **)(CPedAttractor *, CPed *))v7->_vptr$CPedAttractor + 6))(v7, pPed);
      if ( v7->m_attractPeds.numEntries + v7->m_arrivedPeds.numEntries )
        return 1;
      v66 = this->m_parks.numEntries;
      if ( !v66 )
        goto LABEL_145;
      v67 = 4 * v66 - 4;
      v68 = this->m_parks.dataPtr;
      v69 = 0;
      while ( *v68 != v7 )
      {
        ++v69;
        ++v68;
        v67 -= 4;
        if ( v69 >= v66 )
          goto LABEL_145;
      }
      memmove(v68, v68 + 1, v67);
      --this->m_parks.numEntries;
      goto LABEL_145;
    case 9:
      v70 = this->m_steps.numEntries;
      if ( v70 < 1 )
        return 0;
      v7 = 0;
      v71 = 0;
      do
      {
        v72 = this->m_steps.dataPtr[v71++];
        if ( v72 == pAttractor )
          v7 = v72;
      }
      while ( v71 < v70 && v72 != pAttractor );
      if ( !v7 )
        return 0;
      (*((void (__fastcall **)(CPedAttractor *, CPed *))v7->_vptr$CPedAttractor + 6))(v7, pPed);
      if ( v7->m_attractPeds.numEntries + v7->m_arrivedPeds.numEntries )
        return 1;
      v73 = this->m_steps.numEntries;
      if ( !v73 )
        goto LABEL_145;
      v74 = 4 * v73 - 4;
      v75 = this->m_steps.dataPtr;
      v76 = 0;
      break;
    default:
      return 0;
  }
  while ( *v75 != v7 )
  {
    ++v76;
    ++v75;
    v74 -= 4;
    if ( v76 >= v73 )
      goto LABEL_145;
  }
  memmove(v75, v75 + 1, v74);
  --this->m_steps.numEntries;
LABEL_145:
  (*((void (__fastcall **)(CPedAttractor *))v7->_vptr$CPedAttractor + 2))(v7);
  return 1;
}

//----- (004AB956) --------------------------------------------------------
bool __fastcall CPedAttractorManager::BroadcastDeparture(
        CPedAttractorManager *this,
        CPed *pPed,
        CPedAttractor *pInputAttractor,
        SArray<CPedAttractor *> *attractors)
{
  signed int numEntries; // r0
  CPedAttractor **dataPtr; // r3
  CPedAttractor *v7; // r5
  signed int v8; // r4
  CPedAttractor *v9; // r6
  unsigned int v10; // r1
  size_t v11; // r2
  CPedAttractor **v12; // r0
  unsigned int v13; // r3

  if ( !pInputAttractor )
    return 0;
  numEntries = attractors->numEntries;
  if ( numEntries < 1 )
    return 0;
  dataPtr = attractors->dataPtr;
  v7 = 0;
  v8 = 0;
  do
  {
    v9 = dataPtr[v8++];
    if ( v9 == pInputAttractor )
      v7 = v9;
  }
  while ( v8 < numEntries && v9 != pInputAttractor );
  if ( !v7 )
    return 0;
  (*((void (__fastcall **)(CPedAttractor *, CPed *))v7->_vptr$CPedAttractor + 6))(v7, pPed);
  if ( !(v7->m_attractPeds.numEntries + v7->m_arrivedPeds.numEntries) )
  {
    v10 = attractors->numEntries;
    if ( v10 )
    {
      v11 = 4 * v10 - 4;
      v12 = attractors->dataPtr;
      v13 = 0;
      while ( *v12 != v7 )
      {
        ++v13;
        ++v12;
        v11 -= 4;
        if ( v13 >= v10 )
          goto LABEL_17;
      }
      memmove(v12, v12 + 1, v11);
      --attractors->numEntries;
    }
LABEL_17:
    (*((void (__fastcall **)(CPedAttractor *))v7->_vptr$CPedAttractor + 2))(v7);
  }
  return 1;
}

//----- (004AB9E6) --------------------------------------------------------
bool __fastcall CPedAttractorManager::IsPedRegistered(
        const CPedAttractorManager *this,
        CPed *pPed,
        const SArray<CPedAttractor *> *attractors)
{
  signed int numEntries; // lr
  CPedAttractor **dataPtr; // r12
  int v5; // r3
  CPedAttractor *v6; // r2
  int v7; // r0
  int v8; // r5
  int v9; // r0
  CPed **v10; // r2
  int v11; // r4

  numEntries = attractors->numEntries;
  if ( numEntries < 1 )
    return 0;
  dataPtr = attractors->dataPtr;
  v5 = 0;
  while ( 1 )
  {
    v6 = dataPtr[v5];
    v7 = v6->m_attractPeds.numEntries;
    if ( v7 >= 1 )
      break;
LABEL_7:
    v9 = v6->m_arrivedPeds.numEntries;
    if ( v9 >= 1 )
    {
      v10 = v6->m_arrivedPeds.dataPtr;
      v11 = 0;
      while ( v10[v11] != pPed )
      {
        if ( ++v11 >= v9 )
          goto LABEL_11;
      }
      return 1;
    }
LABEL_11:
    if ( ++v5 >= numEntries )
      return 0;
  }
  v8 = 0;
  while ( v6->m_attractPeds.dataPtr[v8] != pPed )
  {
    if ( ++v8 >= v7 )
      goto LABEL_7;
  }
  return 1;
}

//----- (004ABA48) --------------------------------------------------------
int __fastcall CPedAttractorManager::IsPedRegisteredWithEffect(
        const CPedAttractorManager *this,
        CPed *pPed,
        const C2dEffect *pEffect,
        const CEntity *pEntity,
        const SArray<CPedAttractor *> *attractors)
{
  signed int numEntries; // lr
  int v6; // r0
  int v7; // r8
  int v8; // r5
  int v9; // r8
  CPed **dataPtr; // r4
  int v11; // r6
  CPedAttractor *v12; // r4
  const C2dEffect *m_pEffect; // r5
  bool v14; // zf

  numEntries = attractors->numEntries;
  if ( numEntries < 1 )
    return 0;
  v6 = 0;
  while ( 1 )
  {
    v12 = attractors->dataPtr[v6];
    m_pEffect = v12->m_pEffect;
    v14 = m_pEffect == pEffect;
    if ( m_pEffect == pEffect )
      v14 = v12->m_pEntity == pEntity;
    if ( !v14 )
      goto LABEL_15;
    v7 = v12->m_attractPeds.numEntries;
    if ( v7 >= 1 )
      break;
LABEL_7:
    v9 = v12->m_arrivedPeds.numEntries;
    if ( v9 >= 1 )
    {
      dataPtr = v12->m_arrivedPeds.dataPtr;
      v11 = 0;
      while ( dataPtr[v11] != pPed )
      {
        if ( ++v11 >= v9 )
          goto LABEL_15;
      }
      return 1;
    }
LABEL_15:
    if ( ++v6 >= numEntries )
      return 0;
  }
  v8 = 0;
  while ( v12->m_attractPeds.dataPtr[v8] != pPed )
  {
    if ( ++v8 >= v7 )
      goto LABEL_7;
  }
  return 1;
}

//----- (004ABAC8) --------------------------------------------------------
CPed *__fastcall CPedAttractorManager::GetPedUsingEffect(
        CPedAttractorManager *this,
        const C2dEffect *pEffect,
        const CEntity *pEntity)
{
  signed int numEntries; // r12
  CPedAttractor **dataPtr; // lr
  int v5; // r3
  CPedAttractor *v6; // r0
  const C2dEffect *m_pEffect; // r4
  bool v8; // zf

  switch ( pEffect->attr.q.m_type )
  {
    case 0u:
      this = (CPedAttractorManager *)((char *)this + 12);
      goto LABEL_11;
    case 1u:
      goto LABEL_11;
    case 2u:
      this = (CPedAttractorManager *)((char *)this + 24);
      goto LABEL_11;
    case 3u:
      this = (CPedAttractorManager *)((char *)this + 36);
      goto LABEL_11;
    case 4u:
      this = (CPedAttractorManager *)((char *)this + 48);
      goto LABEL_11;
    case 5u:
      this = (CPedAttractorManager *)((char *)this + 60);
      goto LABEL_11;
    case 6u:
      this = (CPedAttractorManager *)((char *)this + 72);
      goto LABEL_11;
    case 7u:
      this = (CPedAttractorManager *)((char *)this + 84);
      goto LABEL_11;
    case 8u:
      this = (CPedAttractorManager *)((char *)this + 96);
      goto LABEL_11;
    case 9u:
      this = (CPedAttractorManager *)((char *)this + 108);
LABEL_11:
      numEntries = this->m_seats.numEntries;
      if ( numEntries < 1 )
        return 0;
      dataPtr = this->m_seats.dataPtr;
      v5 = 0;
      break;
    default:
      return 0;
  }
  while ( 1 )
  {
    v6 = dataPtr[v5];
    m_pEffect = v6->m_pEffect;
    v8 = m_pEffect == pEffect;
    if ( m_pEffect == pEffect )
      v8 = v6->m_pEntity == pEntity;
    if ( v8 )
      break;
    if ( ++v5 >= numEntries )
      return 0;
  }
  if ( v6->m_arrivedPeds.numEntries )
    return *v6->m_arrivedPeds.dataPtr;
  else
    return 0;
}

//----- (004ABB40) --------------------------------------------------------
CPed *__fastcall CPedAttractorManager::GetPedUsingEffect(
        CPedAttractorManager *this,
        const C2dEffect *pEffect,
        const CEntity *pEntity,
        const SArray<CPedAttractor *> *attractors)
{
  signed int numEntries; // r12
  CPedAttractor **dataPtr; // lr
  int v6; // r0
  CPedAttractor *v7; // r3
  const C2dEffect *m_pEffect; // r4
  bool v9; // zf

  numEntries = attractors->numEntries;
  if ( numEntries < 1 )
    return 0;
  dataPtr = attractors->dataPtr;
  v6 = 0;
  while ( 1 )
  {
    v7 = dataPtr[v6];
    m_pEffect = v7->m_pEffect;
    v9 = m_pEffect == pEffect;
    if ( m_pEffect == pEffect )
      v9 = v7->m_pEntity == pEntity;
    if ( v9 )
      break;
    if ( ++v6 >= numEntries )
      return 0;
  }
  if ( v7->m_arrivedPeds.numEntries )
    return *v7->m_arrivedPeds.dataPtr;
  else
    return 0;
}

//----- (004ABB7E) --------------------------------------------------------
const CPedAttractor *__fastcall CPedAttractorManager::GetRelevantAttractor(
        const CPedAttractorManager *this,
        const CPed *pPed,
        const C2dEffect *pEffect,
        const CEntity *pEntity)
{
  signed int numEntries; // lr
  int v5; // r5
  int v6; // r9
  int v7; // r6
  int v8; // r9
  int v9; // r6
  CPedAttractor *v10; // r12
  const C2dEffect *m_pEffect; // r4
  bool v12; // zf
  signed int v13; // lr
  int v14; // r5
  int v15; // r9
  int v16; // r6
  int v17; // r9
  int v18; // r6
  const C2dEffect *v19; // r4
  bool v20; // zf
  signed int v21; // lr
  int v22; // r5
  int v23; // r9
  int v24; // r6
  int v25; // r9
  int v26; // r6
  const C2dEffect *v27; // r4
  bool v28; // zf
  signed int v29; // lr
  int v30; // r5
  int v31; // r9
  int v32; // r6
  int v33; // r9
  int v34; // r6
  const C2dEffect *v35; // r4
  bool v36; // zf
  signed int v37; // lr
  int v38; // r5
  int v39; // r9
  int v40; // r6
  int v41; // r9
  int v42; // r6
  const C2dEffect *v43; // r4
  bool v44; // zf
  signed int v45; // lr
  int v46; // r5
  int v47; // r9
  int v48; // r6
  int v49; // r9
  int v50; // r6
  const C2dEffect *v51; // r4
  bool v52; // zf
  signed int v53; // lr
  int v54; // r5
  int v55; // r9
  int v56; // r6
  int v57; // r9
  int v58; // r6
  const C2dEffect *v59; // r4
  bool v60; // zf
  signed int v61; // lr
  int v62; // r5
  int v63; // r9
  int v64; // r6
  int v65; // r9
  int v66; // r6
  const C2dEffect *v67; // r4
  bool v68; // zf
  signed int v69; // lr
  int v70; // r5
  int v71; // r9
  int v72; // r6
  int v73; // r9
  int v74; // r6
  const C2dEffect *v75; // r4
  bool v76; // zf
  signed int v77; // lr
  CPedAttractor **dataPtr; // r8
  signed int v79; // r4
  int v80; // r9
  int v81; // r0
  int v82; // r9
  int v83; // r0
  const C2dEffect *v84; // r0
  bool v85; // zf

  numEntries = this->m_atms.numEntries;
  if ( numEntries < 1 )
    goto LABEL_18;
  v5 = 0;
  while ( 1 )
  {
    v10 = this->m_atms.dataPtr[v5];
    m_pEffect = v10->m_pEffect;
    v12 = m_pEffect == pEffect;
    if ( m_pEffect == pEffect )
      v12 = v10->m_pEntity == pEntity;
    if ( !v12 )
      goto LABEL_15;
    v6 = v10->m_attractPeds.numEntries;
    if ( v6 >= 1 )
      break;
LABEL_7:
    v8 = v10->m_arrivedPeds.numEntries;
    if ( v8 >= 1 )
    {
      v9 = 0;
      while ( v10->m_arrivedPeds.dataPtr[v9] != pPed )
      {
        if ( ++v9 >= v8 )
          goto LABEL_15;
      }
      goto LABEL_17;
    }
LABEL_15:
    if ( ++v5 >= numEntries )
      goto LABEL_18;
  }
  v7 = 0;
  while ( v10->m_attractPeds.dataPtr[v7] != pPed )
  {
    if ( ++v7 >= v6 )
      goto LABEL_7;
  }
LABEL_17:
  if ( v10 )
    return v10;
LABEL_18:
  v13 = this->m_seats.numEntries;
  if ( v13 < 1 )
    goto LABEL_35;
  v14 = 0;
  while ( 2 )
  {
    v10 = this->m_seats.dataPtr[v14];
    v19 = v10->m_pEffect;
    v20 = v19 == pEffect;
    if ( v19 == pEffect )
      v20 = v10->m_pEntity == pEntity;
    if ( !v20 )
    {
LABEL_32:
      if ( ++v14 >= v13 )
        goto LABEL_35;
      continue;
    }
    break;
  }
  v15 = v10->m_attractPeds.numEntries;
  if ( v15 < 1 )
  {
LABEL_24:
    v17 = v10->m_arrivedPeds.numEntries;
    if ( v17 >= 1 )
    {
      v18 = 0;
      while ( v10->m_arrivedPeds.dataPtr[v18] != pPed )
      {
        if ( ++v18 >= v17 )
          goto LABEL_32;
      }
      goto LABEL_34;
    }
    goto LABEL_32;
  }
  v16 = 0;
  while ( v10->m_attractPeds.dataPtr[v16] != pPed )
  {
    if ( ++v16 >= v15 )
      goto LABEL_24;
  }
LABEL_34:
  if ( v10 )
    return v10;
LABEL_35:
  v21 = this->m_stops.numEntries;
  if ( v21 < 1 )
    goto LABEL_52;
  v22 = 0;
  while ( 2 )
  {
    v10 = this->m_stops.dataPtr[v22];
    v27 = v10->m_pEffect;
    v28 = v27 == pEffect;
    if ( v27 == pEffect )
      v28 = v10->m_pEntity == pEntity;
    if ( !v28 )
    {
LABEL_49:
      if ( ++v22 >= v21 )
        goto LABEL_52;
      continue;
    }
    break;
  }
  v23 = v10->m_attractPeds.numEntries;
  if ( v23 < 1 )
  {
LABEL_41:
    v25 = v10->m_arrivedPeds.numEntries;
    if ( v25 >= 1 )
    {
      v26 = 0;
      while ( v10->m_arrivedPeds.dataPtr[v26] != pPed )
      {
        if ( ++v26 >= v25 )
          goto LABEL_49;
      }
      goto LABEL_51;
    }
    goto LABEL_49;
  }
  v24 = 0;
  while ( v10->m_attractPeds.dataPtr[v24] != pPed )
  {
    if ( ++v24 >= v23 )
      goto LABEL_41;
  }
LABEL_51:
  if ( v10 )
    return v10;
LABEL_52:
  v29 = this->m_pizzas.numEntries;
  if ( v29 < 1 )
    goto LABEL_69;
  v30 = 0;
  while ( 2 )
  {
    v10 = this->m_pizzas.dataPtr[v30];
    v35 = v10->m_pEffect;
    v36 = v35 == pEffect;
    if ( v35 == pEffect )
      v36 = v10->m_pEntity == pEntity;
    if ( !v36 )
    {
LABEL_66:
      if ( ++v30 >= v29 )
        goto LABEL_69;
      continue;
    }
    break;
  }
  v31 = v10->m_attractPeds.numEntries;
  if ( v31 < 1 )
  {
LABEL_58:
    v33 = v10->m_arrivedPeds.numEntries;
    if ( v33 >= 1 )
    {
      v34 = 0;
      while ( v10->m_arrivedPeds.dataPtr[v34] != pPed )
      {
        if ( ++v34 >= v33 )
          goto LABEL_66;
      }
      goto LABEL_68;
    }
    goto LABEL_66;
  }
  v32 = 0;
  while ( v10->m_attractPeds.dataPtr[v32] != pPed )
  {
    if ( ++v32 >= v31 )
      goto LABEL_58;
  }
LABEL_68:
  if ( v10 )
    return v10;
LABEL_69:
  v37 = this->m_shelters.numEntries;
  if ( v37 < 1 )
    goto LABEL_86;
  v38 = 0;
  while ( 2 )
  {
    v10 = this->m_shelters.dataPtr[v38];
    v43 = v10->m_pEffect;
    v44 = v43 == pEffect;
    if ( v43 == pEffect )
      v44 = v10->m_pEntity == pEntity;
    if ( !v44 )
    {
LABEL_83:
      if ( ++v38 >= v37 )
        goto LABEL_86;
      continue;
    }
    break;
  }
  v39 = v10->m_attractPeds.numEntries;
  if ( v39 < 1 )
  {
LABEL_75:
    v41 = v10->m_arrivedPeds.numEntries;
    if ( v41 >= 1 )
    {
      v42 = 0;
      while ( v10->m_arrivedPeds.dataPtr[v42] != pPed )
      {
        if ( ++v42 >= v41 )
          goto LABEL_83;
      }
      goto LABEL_85;
    }
    goto LABEL_83;
  }
  v40 = 0;
  while ( v10->m_attractPeds.dataPtr[v40] != pPed )
  {
    if ( ++v40 >= v39 )
      goto LABEL_75;
  }
LABEL_85:
  if ( v10 )
    return v10;
LABEL_86:
  v45 = this->m_triggerScripts.numEntries;
  if ( v45 < 1 )
    goto LABEL_103;
  v46 = 0;
  while ( 2 )
  {
    v10 = this->m_triggerScripts.dataPtr[v46];
    v51 = v10->m_pEffect;
    v52 = v51 == pEffect;
    if ( v51 == pEffect )
      v52 = v10->m_pEntity == pEntity;
    if ( !v52 )
    {
LABEL_100:
      if ( ++v46 >= v45 )
        goto LABEL_103;
      continue;
    }
    break;
  }
  v47 = v10->m_attractPeds.numEntries;
  if ( v47 < 1 )
  {
LABEL_92:
    v49 = v10->m_arrivedPeds.numEntries;
    if ( v49 >= 1 )
    {
      v50 = 0;
      while ( v10->m_arrivedPeds.dataPtr[v50] != pPed )
      {
        if ( ++v50 >= v49 )
          goto LABEL_100;
      }
      goto LABEL_102;
    }
    goto LABEL_100;
  }
  v48 = 0;
  while ( v10->m_attractPeds.dataPtr[v48] != pPed )
  {
    if ( ++v48 >= v47 )
      goto LABEL_92;
  }
LABEL_102:
  if ( v10 )
    return v10;
LABEL_103:
  v53 = this->m_lookAts.numEntries;
  if ( v53 < 1 )
    goto LABEL_120;
  v54 = 0;
  while ( 2 )
  {
    v10 = this->m_lookAts.dataPtr[v54];
    v59 = v10->m_pEffect;
    v60 = v59 == pEffect;
    if ( v59 == pEffect )
      v60 = v10->m_pEntity == pEntity;
    if ( !v60 )
    {
LABEL_117:
      if ( ++v54 >= v53 )
        goto LABEL_120;
      continue;
    }
    break;
  }
  v55 = v10->m_attractPeds.numEntries;
  if ( v55 < 1 )
  {
LABEL_109:
    v57 = v10->m_arrivedPeds.numEntries;
    if ( v57 >= 1 )
    {
      v58 = 0;
      while ( v10->m_arrivedPeds.dataPtr[v58] != pPed )
      {
        if ( ++v58 >= v57 )
          goto LABEL_117;
      }
      goto LABEL_119;
    }
    goto LABEL_117;
  }
  v56 = 0;
  while ( v10->m_attractPeds.dataPtr[v56] != pPed )
  {
    if ( ++v56 >= v55 )
      goto LABEL_109;
  }
LABEL_119:
  if ( v10 )
    return v10;
LABEL_120:
  v61 = this->m_scripted.numEntries;
  if ( v61 < 1 )
    goto LABEL_137;
  v62 = 0;
  while ( 2 )
  {
    v10 = this->m_scripted.dataPtr[v62];
    v67 = v10->m_pEffect;
    v68 = v67 == pEffect;
    if ( v67 == pEffect )
      v68 = v10->m_pEntity == pEntity;
    if ( !v68 )
    {
LABEL_134:
      if ( ++v62 >= v61 )
        goto LABEL_137;
      continue;
    }
    break;
  }
  v63 = v10->m_attractPeds.numEntries;
  if ( v63 < 1 )
  {
LABEL_126:
    v65 = v10->m_arrivedPeds.numEntries;
    if ( v65 >= 1 )
    {
      v66 = 0;
      while ( v10->m_arrivedPeds.dataPtr[v66] != pPed )
      {
        if ( ++v66 >= v65 )
          goto LABEL_134;
      }
      goto LABEL_136;
    }
    goto LABEL_134;
  }
  v64 = 0;
  while ( v10->m_attractPeds.dataPtr[v64] != pPed )
  {
    if ( ++v64 >= v63 )
      goto LABEL_126;
  }
LABEL_136:
  if ( v10 )
    return v10;
LABEL_137:
  v69 = this->m_parks.numEntries;
  if ( v69 < 1 )
    goto LABEL_154;
  v70 = 0;
  while ( 2 )
  {
    v10 = this->m_parks.dataPtr[v70];
    v75 = v10->m_pEffect;
    v76 = v75 == pEffect;
    if ( v75 == pEffect )
      v76 = v10->m_pEntity == pEntity;
    if ( !v76 )
    {
LABEL_151:
      if ( ++v70 >= v69 )
        goto LABEL_154;
      continue;
    }
    break;
  }
  v71 = v10->m_attractPeds.numEntries;
  if ( v71 < 1 )
  {
LABEL_143:
    v73 = v10->m_arrivedPeds.numEntries;
    if ( v73 >= 1 )
    {
      v74 = 0;
      while ( v10->m_arrivedPeds.dataPtr[v74] != pPed )
      {
        if ( ++v74 >= v73 )
          goto LABEL_151;
      }
      goto LABEL_153;
    }
    goto LABEL_151;
  }
  v72 = 0;
  while ( v10->m_attractPeds.dataPtr[v72] != pPed )
  {
    if ( ++v72 >= v71 )
      goto LABEL_143;
  }
LABEL_153:
  if ( v10 )
    return v10;
LABEL_154:
  v77 = this->m_steps.numEntries;
  if ( v77 < 1 )
    return 0;
  dataPtr = this->m_steps.dataPtr;
  v79 = 0;
  while ( 2 )
  {
    v10 = dataPtr[v79];
    v84 = v10->m_pEffect;
    v85 = v84 == pEffect;
    if ( v84 == pEffect )
      v85 = v10->m_pEntity == pEntity;
    if ( !v85 )
    {
LABEL_168:
      ++v79;
      v10 = 0;
      if ( v79 >= v77 )
        return v10;
      continue;
    }
    break;
  }
  v80 = v10->m_attractPeds.numEntries;
  if ( v80 < 1 )
  {
LABEL_160:
    v82 = v10->m_arrivedPeds.numEntries;
    if ( v82 >= 1 )
    {
      v83 = 0;
      while ( v10->m_arrivedPeds.dataPtr[v83] != pPed )
      {
        if ( ++v83 >= v82 )
          goto LABEL_168;
      }
      return v10;
    }
    goto LABEL_168;
  }
  v81 = 0;
  while ( v10->m_attractPeds.dataPtr[v81] != pPed )
  {
    if ( ++v81 >= v80 )
      goto LABEL_160;
  }
  return v10;
}

//----- (004AC012) --------------------------------------------------------
CPedAttractor *__fastcall CPedAttractorManager::GetRelevantAttractor(
        const CPedAttractorManager *this,
        const CPed *pPed,
        const C2dEffect *pEffect,
        const CEntity *pEntity,
        const SArray<CPedAttractor *> *attractors)
{
  signed int numEntries; // r12
  int v6; // r4
  signed int v7; // r8
  int v8; // r5
  signed int v9; // r8
  int v10; // r5
  CPedAttractor *result; // r0
  C2dEffect *m_pEffect; // r5
  bool v13; // zf

  numEntries = attractors->numEntries;
  if ( numEntries < 1 )
    return 0;
  v6 = 0;
  while ( 1 )
  {
    result = attractors->dataPtr[v6];
    m_pEffect = result->m_pEffect;
    v13 = m_pEffect == pEffect;
    if ( m_pEffect == pEffect )
      v13 = result->m_pEntity == pEntity;
    if ( !v13 )
      goto LABEL_15;
    v7 = result->m_attractPeds.numEntries;
    if ( v7 >= 1 )
      break;
LABEL_7:
    v9 = result->m_arrivedPeds.numEntries;
    if ( v9 >= 1 )
    {
      v10 = 0;
      while ( result->m_arrivedPeds.dataPtr[v10] != pPed )
      {
        if ( ++v10 >= v9 )
          goto LABEL_15;
      }
      return result;
    }
LABEL_15:
    if ( ++v6 >= numEntries )
      return 0;
  }
  v8 = 0;
  while ( result->m_attractPeds.dataPtr[v8] != pPed )
  {
    if ( ++v8 >= v7 )
      goto LABEL_7;
  }
  return result;
}

//----- (004AC08A) --------------------------------------------------------
void __fastcall CPedAttractorManager::ComputeEffectForwardDir(
        const C2dEffect *pEffect,
        const CMatrix *mat,
        CVector *vForwardDir)
{
  __int64 v3; // d16
  __int64 v5; // d16
  CVector v6; // [sp+0h] [bp-28h] BYREF
  CVector v7; // [sp+10h] [bp-18h] BYREF

  v3 = *(_QWORD *)&pEffect->attr.es.Coors3X;
  LODWORD(v6.z) = pEffect->attr.l.m_pCoronaTex;
  *(_QWORD *)&v6.x = v3;
  Multiply3x3(&v7, mat, &v6);
  v5 = *(_QWORD *)&v7.x;
  vForwardDir->z = v7.z;
  *(_QWORD *)&vForwardDir->x = v5;
}

//----- (004AC0B6) --------------------------------------------------------
bool __fastcall CPedAttractorManager::IsApproachable(
        C2dEffect *pEffect,
        const CMatrix *mat,
        const int iSlot,
        CPed *pPed)
{
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r0
  bool result; // r0
  __int64 v10; // d16
  float x; // s16
  float y; // s20
  float z; // s18
  CMatrix *v14; // r0
  CSimpleTransform *p_m_transform; // r5
  float v16; // s4
  float v17; // s6
  CVector v; // [sp+18h] [bp-40h] BYREF
  CVector vEnd; // [sp+24h] [bp-34h] BYREF

  if ( pEffect->attr.q.m_type == 4 )
  {
    CVector::FromMultiply(&vEnd, mat, &pEffect->m_posn);
    m_pMat = pPed->m_pMat;
    p_tx = (CSimpleTransform *)&m_pMat->tx;
    if ( !m_pMat )
      p_tx = &pPed->m_transform;
    return CWorld::GetIsLineOfSightClear(&p_tx->m_translate, &vEnd, 1, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    v10 = *(_QWORD *)&pEffect->attr.es.Coors3X;
    LODWORD(v.z) = pEffect->attr.l.m_pCoronaTex;
    *(_QWORD *)&v.x = v10;
    Multiply3x3(&vEnd, mat, &v);
    x = vEnd.x;
    y = vEnd.y;
    z = vEnd.z;
    CVector::FromMultiply(&vEnd, mat, &pEffect->m_posn);
    v14 = pPed->m_pMat;
    p_m_transform = (CSimpleTransform *)&v14->tx;
    if ( !v14 )
      p_m_transform = &pPed->m_transform;
    v16 = p_m_transform->m_translate.x;
    v17 = p_m_transform->m_translate.y;
    result = 0;
    if ( (float)((float)((float)((float)(x * p_m_transform->m_translate.x) + (float)(y * v17))
                       + (float)(z * p_m_transform->m_translate.z))
               - (float)((float)((float)(x * vEnd.x) + (float)(y * vEnd.y)) + (float)(z * vEnd.z))) > 0.0 )
    {
      v.z = 0.0;
      v.y = v17 - vEnd.y;
      v.x = v16 - vEnd.x;
      CVector::Normalise(&v);
      return (float)((float)((float)(x * v.x) + (float)(y * v.y)) + (float)(z * v.z)) > 0.25
          && CPedGeometryAnalyser::IsWanderPathClear(&p_m_transform->m_translate, &vEnd, 2.0, 0) == 4;
    }
  }
  return result;
}

//----- (004AC1F6) --------------------------------------------------------
void __fastcall CPedAttractorPedPlacer::PlacePedAtEffect(
        const C2dEffect *effect,
        CEntity *pEntity,
        CPed *pPed,
        float dist)
{
  CMatrix *m_pMat; // r1
  __int64 v9; // d16
  __int64 v10; // d16
  float x; // s18
  float y; // s20
  __int64 v13; // d16
  float v14; // s22
  float v15; // s24
  float z; // s26
  float v17; // r1
  CMatrix *v18; // r3
  RwReal v19; // r0
  float *p_tz; // r1
  float RadianAngleBetweenPoints; // r0
  float v22; // r1
  CMatrix *v23; // r0
  float v24; // r0
  float v25; // r0
  CVector v26; // [sp+4h] [bp-B4h] BYREF
  CMatrix m; // [sp+10h] [bp-A8h] BYREF
  CVector v; // [sp+58h] [bp-60h] BYREF
  CVector pCoors; // [sp+64h] [bp-54h] BYREF

  m.m_pRwMat = 0;
  m.m_owner = 0;
  if ( pEntity )
  {
    m_pMat = pEntity->m_pMat;
    if ( !m_pMat )
    {
      CPlaceable::AllocateMatrix(pEntity);
      CSimpleTransform::UpdateMatrix(&pEntity->m_transform, pEntity->m_pMat);
      m_pMat = pEntity->m_pMat;
    }
    CMatrix::operator=(&m, m_pMat);
  }
  else
  {
    CMatrix::SetUnity(&m);
  }
  CVector::FromMultiply(&v26, &m, &effect->m_posn);
  v9 = *(_QWORD *)&effect->attr.es.Coors2X;
  v.z = effect->attr.q.m_useDir.z;
  *(_QWORD *)&v.x = v9;
  Multiply3x3(&pCoors, &m, &v);
  v10 = *(_QWORD *)&effect->attr.es.Coors3X;
  LODWORD(v.z) = effect->attr.l.m_pCoronaTex;
  x = pCoors.x;
  y = pCoors.y;
  *(_QWORD *)&v.x = v10;
  Multiply3x3(&pCoors, &m, &v);
  v13 = *(_QWORD *)&effect->attr.l.m_colour._anon_0._anon_0.red;
  v.z = effect->attr.l.m_size;
  v14 = pCoors.x;
  v15 = pCoors.y;
  z = pCoors.z;
  *(_QWORD *)&v.x = v13;
  Multiply3x3(&pCoors, &m, &v);
  pCoors.x = (float)(v14 * dist) + v26.x;
  pCoors.y = (float)(v15 * dist) + v26.y;
  pCoors.z = (float)(z * dist) + v26.z;
  CPedPlacement::FindZCoorForPed(&pCoors);
  v17 = pCoors.y;
  v18 = pPed->m_pMat;
  v19 = pCoors.z;
  if ( v18 )
  {
    v18->tx = pCoors.x;
    pPed->m_pMat->ty = v17;
    p_tz = &pPed->m_pMat->tz;
  }
  else
  {
    pPed->m_transform.m_translate.x = pCoors.x;
    pPed->m_transform.m_translate.y = v17;
    p_tz = &pPed->m_transform.m_translate.z;
  }
  *p_tz = v19;
  RadianAngleBetweenPoints = CGeneral::GetRadianAngleBetweenPoints(x, y, 0.0, 0.0);
  v22 = CGeneral::LimitRadianAngle(RadianAngleBetweenPoints);
  pPed->m_fCurrentHeading = v22;
  pPed->m_fDesiredHeading = v22;
  v23 = pPed->m_pMat;
  if ( v23 )
    CMatrix::SetRotateZOnly(v23, v22);
  else
    pPed->m_transform.m_heading = v22;
  v24 = CGeneral::GetRadianAngleBetweenPoints(x, y, 0.0, 0.0);
  v25 = CGeneral::LimitRadianAngle(v24);
  pPed->m_fDesiredHeading = v25;
  pPed->m_fCurrentHeading = v25;
  CMatrix::~CMatrix(&m);
}

//----- (004AC358) --------------------------------------------------------
void __fastcall SArray<CTask const*>::~SArray(SArray<const CTask *> *this)
{
  const CTask **dataPtr; // r0

  dataPtr = this->dataPtr;
  this->numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->dataPtr = 0;
  }
  this->numAlloced = 0;
}

//----- (004AC372) --------------------------------------------------------
void __fastcall SArray<CVector>::~SArray(SArray<CVector> *this)
{
  CVector *dataPtr; // r0

  dataPtr = this->dataPtr;
  this->numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->dataPtr = 0;
  }
  this->numAlloced = 0;
}

//----- (004AC38E) --------------------------------------------------------
int __fastcall CPedShelterAttractor::GetType(const CPedShelterAttractor *this)
{
  return 4;
}

//----- (004AC394) --------------------------------------------------------
void __fastcall CPedShelterAttractor::~CPedShelterAttractor(CPedShelterAttractor *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1
  CPedTaskPair *dataPtr; // r0
  CPed **v5; // r0
  CPed **v6; // r0
  CPedAttractorPool *v7; // r0
  int v8; // r1

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CPedAttractor = (int (**)(void))&off_668DE8;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  dataPtr = this->m_pedTaskPairs.dataPtr;
  this->m_pedTaskPairs.numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->m_pedTaskPairs.dataPtr = 0;
  }
  v5 = this->m_arrivedPeds.dataPtr;
  this->m_arrivedPeds.numEntries = 0;
  this->m_pedTaskPairs.numAlloced = 0;
  if ( v5 )
  {
    free(v5);
    this->m_arrivedPeds.dataPtr = 0;
  }
  v6 = this->m_attractPeds.dataPtr;
  this->m_attractPeds.numEntries = 0;
  this->m_arrivedPeds.numAlloced = 0;
  if ( v6 )
  {
    free(v6);
    this->m_attractPeds.dataPtr = 0;
  }
  this->m_attractPeds.numAlloced = 0;
  v7 = CPools::ms_pPedAttractorPool;
  v8 = -1601513229 * (((char *)this - (char *)CPools::ms_pPedAttractorPool->m_aStorage) >> 2);
  CPools::ms_pPedAttractorPool->m_aFlags[v8] |= 0x80u;
  if ( v8 < v7->m_nFreeIndex )
    v7->m_nFreeIndex = v8;
}
// 668DE8: using guessed type void *;

//----- (004AC41C) --------------------------------------------------------
int __fastcall CPedAtmAttractor::GetType(const CPedAtmAttractor *this)
{
  return 0;
}

//----- (004AC420) --------------------------------------------------------
void __fastcall CPedAtmAttractor::~CPedAtmAttractor(CPedAtmAttractor *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1
  CPedTaskPair *dataPtr; // r0
  CPed **v5; // r0
  CPed **v6; // r0
  CPedAttractorPool *v7; // r0
  int v8; // r1

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CPedAttractor = (int (**)(void))&off_668DE8;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  dataPtr = this->m_pedTaskPairs.dataPtr;
  this->m_pedTaskPairs.numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->m_pedTaskPairs.dataPtr = 0;
  }
  v5 = this->m_arrivedPeds.dataPtr;
  this->m_arrivedPeds.numEntries = 0;
  this->m_pedTaskPairs.numAlloced = 0;
  if ( v5 )
  {
    free(v5);
    this->m_arrivedPeds.dataPtr = 0;
  }
  v6 = this->m_attractPeds.dataPtr;
  this->m_attractPeds.numEntries = 0;
  this->m_arrivedPeds.numAlloced = 0;
  if ( v6 )
  {
    free(v6);
    this->m_attractPeds.dataPtr = 0;
  }
  this->m_attractPeds.numAlloced = 0;
  v7 = CPools::ms_pPedAttractorPool;
  v8 = -1601513229 * (((char *)this - (char *)CPools::ms_pPedAttractorPool->m_aStorage) >> 2);
  CPools::ms_pPedAttractorPool->m_aFlags[v8] |= 0x80u;
  if ( v8 < v7->m_nFreeIndex )
    v7->m_nFreeIndex = v8;
}
// 668DE8: using guessed type void *off_668DE8;

//----- (004AC4A8) --------------------------------------------------------
int __fastcall CPedSeatAttractor::GetType(const CPedSeatAttractor *this)
{
  return 1;
}

//----- (004AC4AC) --------------------------------------------------------
void __fastcall CPedAttractor::~CPedAttractor(CPedAttractor *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1
  CPedTaskPair *dataPtr; // r0
  CPed **v5; // r0
  CPed **v6; // r0

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CPedAttractor = (int (**)(void))&off_668DE8;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  dataPtr = this->m_pedTaskPairs.dataPtr;
  this->m_pedTaskPairs.numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->m_pedTaskPairs.dataPtr = 0;
  }
  v5 = this->m_arrivedPeds.dataPtr;
  this->m_arrivedPeds.numEntries = 0;
  this->m_pedTaskPairs.numAlloced = 0;
  if ( v5 )
  {
    free(v5);
    this->m_arrivedPeds.dataPtr = 0;
  }
  v6 = this->m_attractPeds.dataPtr;
  this->m_attractPeds.numEntries = 0;
  this->m_arrivedPeds.numAlloced = 0;
  if ( v6 )
  {
    free(v6);
    this->m_attractPeds.dataPtr = 0;
  }
  this->m_attractPeds.numAlloced = 0;
}
// 668DE8: using guessed type void *off_668DE8;

//----- (004AC508) --------------------------------------------------------
void __fastcall CPedSeatAttractor::~CPedSeatAttractor(CPedSeatAttractor *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1
  CPedTaskPair *dataPtr; // r0
  CPed **v5; // r0
  CPed **v6; // r0
  CPedAttractorPool *v7; // r0
  int v8; // r1

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CPedAttractor = (int (**)(void))&off_668DE8;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  dataPtr = this->m_pedTaskPairs.dataPtr;
  this->m_pedTaskPairs.numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->m_pedTaskPairs.dataPtr = 0;
  }
  v5 = this->m_arrivedPeds.dataPtr;
  this->m_arrivedPeds.numEntries = 0;
  this->m_pedTaskPairs.numAlloced = 0;
  if ( v5 )
  {
    free(v5);
    this->m_arrivedPeds.dataPtr = 0;
  }
  v6 = this->m_attractPeds.dataPtr;
  this->m_attractPeds.numEntries = 0;
  this->m_arrivedPeds.numAlloced = 0;
  if ( v6 )
  {
    free(v6);
    this->m_attractPeds.dataPtr = 0;
  }
  this->m_attractPeds.numAlloced = 0;
  v7 = CPools::ms_pPedAttractorPool;
  v8 = -1601513229 * (((char *)this - (char *)CPools::ms_pPedAttractorPool->m_aStorage) >> 2);
  CPools::ms_pPedAttractorPool->m_aFlags[v8] |= 0x80u;
  if ( v8 < v7->m_nFreeIndex )
    v7->m_nFreeIndex = v8;
}
// 668DE8: using guessed type void *off_668DE8;

//----- (004AC590) --------------------------------------------------------
int __fastcall CPedStopAttractor::GetType(const CPedStopAttractor *this)
{
  return 2;
}

//----- (004AC594) --------------------------------------------------------
void __fastcall CPedStopAttractor::~CPedStopAttractor(CPedStopAttractor *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1
  CPedTaskPair *dataPtr; // r0
  CPed **v5; // r0
  CPed **v6; // r0
  CPedAttractorPool *v7; // r0
  int v8; // r1

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CPedAttractor = (int (**)(void))&off_668DE8;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  dataPtr = this->m_pedTaskPairs.dataPtr;
  this->m_pedTaskPairs.numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->m_pedTaskPairs.dataPtr = 0;
  }
  v5 = this->m_arrivedPeds.dataPtr;
  this->m_arrivedPeds.numEntries = 0;
  this->m_pedTaskPairs.numAlloced = 0;
  if ( v5 )
  {
    free(v5);
    this->m_arrivedPeds.dataPtr = 0;
  }
  v6 = this->m_attractPeds.dataPtr;
  this->m_attractPeds.numEntries = 0;
  this->m_arrivedPeds.numAlloced = 0;
  if ( v6 )
  {
    free(v6);
    this->m_attractPeds.dataPtr = 0;
  }
  this->m_attractPeds.numAlloced = 0;
  v7 = CPools::ms_pPedAttractorPool;
  v8 = -1601513229 * (((char *)this - (char *)CPools::ms_pPedAttractorPool->m_aStorage) >> 2);
  CPools::ms_pPedAttractorPool->m_aFlags[v8] |= 0x80u;
  if ( v8 < v7->m_nFreeIndex )
    v7->m_nFreeIndex = v8;
}
// 668DE8: using guessed type void *off_668DE8;

//----- (004AC61C) --------------------------------------------------------
int __fastcall CPedPizzaAttractor::GetType(const CPedPizzaAttractor *this)
{
  return 3;
}

//----- (004AC620) --------------------------------------------------------
void __fastcall CPedPizzaAttractor::~CPedPizzaAttractor(CPedPizzaAttractor *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1
  CPedTaskPair *dataPtr; // r0
  CPed **v5; // r0
  CPed **v6; // r0
  CPedAttractorPool *v7; // r0
  int v8; // r1

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CPedAttractor = (int (**)(void))&off_668DE8;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  dataPtr = this->m_pedTaskPairs.dataPtr;
  this->m_pedTaskPairs.numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->m_pedTaskPairs.dataPtr = 0;
  }
  v5 = this->m_arrivedPeds.dataPtr;
  this->m_arrivedPeds.numEntries = 0;
  this->m_pedTaskPairs.numAlloced = 0;
  if ( v5 )
  {
    free(v5);
    this->m_arrivedPeds.dataPtr = 0;
  }
  v6 = this->m_attractPeds.dataPtr;
  this->m_attractPeds.numEntries = 0;
  this->m_arrivedPeds.numAlloced = 0;
  if ( v6 )
  {
    free(v6);
    this->m_attractPeds.dataPtr = 0;
  }
  this->m_attractPeds.numAlloced = 0;
  v7 = CPools::ms_pPedAttractorPool;
  v8 = -1601513229 * (((char *)this - (char *)CPools::ms_pPedAttractorPool->m_aStorage) >> 2);
  CPools::ms_pPedAttractorPool->m_aFlags[v8] |= 0x80u;
  if ( v8 < v7->m_nFreeIndex )
    v7->m_nFreeIndex = v8;
}
// 668DE8: using guessed type void *off_668DE8;

//----- (004AC6A8) --------------------------------------------------------
float __fastcall CPedPizzaAttractor::GetHeadOfQueueWaitTime(CPedPizzaAttractor *this)
{
  return 2000.0;
}

//----- (004AC6B0) --------------------------------------------------------
int __fastcall CPedTriggerScriptAttractor::GetType(const CPedTriggerScriptAttractor *this)
{
  return 5;
}

//----- (004AC6B4) --------------------------------------------------------
void __fastcall CPedTriggerScriptAttractor::~CPedTriggerScriptAttractor(CPedTriggerScriptAttractor *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1
  CPedTaskPair *dataPtr; // r0
  CPed **v5; // r0
  CPed **v6; // r0
  CPedAttractorPool *v7; // r0
  int v8; // r1

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CPedAttractor = (int (**)(void))&off_668DE8;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  dataPtr = this->m_pedTaskPairs.dataPtr;
  this->m_pedTaskPairs.numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->m_pedTaskPairs.dataPtr = 0;
  }
  v5 = this->m_arrivedPeds.dataPtr;
  this->m_arrivedPeds.numEntries = 0;
  this->m_pedTaskPairs.numAlloced = 0;
  if ( v5 )
  {
    free(v5);
    this->m_arrivedPeds.dataPtr = 0;
  }
  v6 = this->m_attractPeds.dataPtr;
  this->m_attractPeds.numEntries = 0;
  this->m_arrivedPeds.numAlloced = 0;
  if ( v6 )
  {
    free(v6);
    this->m_attractPeds.dataPtr = 0;
  }
  this->m_attractPeds.numAlloced = 0;
  v7 = CPools::ms_pPedAttractorPool;
  v8 = -1601513229 * (((char *)this - (char *)CPools::ms_pPedAttractorPool->m_aStorage) >> 2);
  CPools::ms_pPedAttractorPool->m_aFlags[v8] |= 0x80u;
  if ( v8 < v7->m_nFreeIndex )
    v7->m_nFreeIndex = v8;
}
// 668DE8: using guessed type void *off_668DE8;

//----- (004AC73C) --------------------------------------------------------
int __fastcall CPedLookAtAttractor::GetType(const CPedLookAtAttractor *this)
{
  return 6;
}

//----- (004AC740) --------------------------------------------------------
void __fastcall CPedLookAtAttractor::~CPedLookAtAttractor(CPedLookAtAttractor *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1
  CPedTaskPair *dataPtr; // r0
  CPed **v5; // r0
  CPed **v6; // r0
  CPedAttractorPool *v7; // r0
  int v8; // r1

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CPedAttractor = (int (**)(void))&off_668DE8;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  dataPtr = this->m_pedTaskPairs.dataPtr;
  this->m_pedTaskPairs.numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->m_pedTaskPairs.dataPtr = 0;
  }
  v5 = this->m_arrivedPeds.dataPtr;
  this->m_arrivedPeds.numEntries = 0;
  this->m_pedTaskPairs.numAlloced = 0;
  if ( v5 )
  {
    free(v5);
    this->m_arrivedPeds.dataPtr = 0;
  }
  v6 = this->m_attractPeds.dataPtr;
  this->m_attractPeds.numEntries = 0;
  this->m_arrivedPeds.numAlloced = 0;
  if ( v6 )
  {
    free(v6);
    this->m_attractPeds.dataPtr = 0;
  }
  this->m_attractPeds.numAlloced = 0;
  v7 = CPools::ms_pPedAttractorPool;
  v8 = -1601513229 * (((char *)this - (char *)CPools::ms_pPedAttractorPool->m_aStorage) >> 2);
  CPools::ms_pPedAttractorPool->m_aFlags[v8] |= 0x80u;
  if ( v8 < v7->m_nFreeIndex )
    v7->m_nFreeIndex = v8;
}
// 668DE8: using guessed type void *off_668DE8;

//----- (004AC7C8) --------------------------------------------------------
int __fastcall CPedScriptedAttractor::GetType(const CPedScriptedAttractor *this)
{
  return 7;
}

//----- (004AC7CC) --------------------------------------------------------
void __fastcall CPedScriptedAttractor::~CPedScriptedAttractor(CPedScriptedAttractor *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1
  CPedTaskPair *dataPtr; // r0
  CPed **v5; // r0
  CPed **v6; // r0
  CPedAttractorPool *v7; // r0
  int v8; // r1

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CPedAttractor = (int (**)(void))&off_668DE8;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  dataPtr = this->m_pedTaskPairs.dataPtr;
  this->m_pedTaskPairs.numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->m_pedTaskPairs.dataPtr = 0;
  }
  v5 = this->m_arrivedPeds.dataPtr;
  this->m_arrivedPeds.numEntries = 0;
  this->m_pedTaskPairs.numAlloced = 0;
  if ( v5 )
  {
    free(v5);
    this->m_arrivedPeds.dataPtr = 0;
  }
  v6 = this->m_attractPeds.dataPtr;
  this->m_attractPeds.numEntries = 0;
  this->m_arrivedPeds.numAlloced = 0;
  if ( v6 )
  {
    free(v6);
    this->m_attractPeds.dataPtr = 0;
  }
  this->m_attractPeds.numAlloced = 0;
  v7 = CPools::ms_pPedAttractorPool;
  v8 = -1601513229 * (((char *)this - (char *)CPools::ms_pPedAttractorPool->m_aStorage) >> 2);
  CPools::ms_pPedAttractorPool->m_aFlags[v8] |= 0x80u;
  if ( v8 < v7->m_nFreeIndex )
    v7->m_nFreeIndex = v8;
}
// 668DE8: using guessed type void *off_668DE8;

//----- (004AC854) --------------------------------------------------------
int __fastcall CPedParkAttractor::GetType(const CPedParkAttractor *this)
{
  return 8;
}

//----- (004AC858) --------------------------------------------------------
void __fastcall CPedParkAttractor::~CPedParkAttractor(CPedParkAttractor *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1
  CPedTaskPair *dataPtr; // r0
  CPed **v5; // r0
  CPed **v6; // r0
  CPedAttractorPool *v7; // r0
  int v8; // r1

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CPedAttractor = (int (**)(void))&off_668DE8;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  dataPtr = this->m_pedTaskPairs.dataPtr;
  this->m_pedTaskPairs.numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->m_pedTaskPairs.dataPtr = 0;
  }
  v5 = this->m_arrivedPeds.dataPtr;
  this->m_arrivedPeds.numEntries = 0;
  this->m_pedTaskPairs.numAlloced = 0;
  if ( v5 )
  {
    free(v5);
    this->m_arrivedPeds.dataPtr = 0;
  }
  v6 = this->m_attractPeds.dataPtr;
  this->m_attractPeds.numEntries = 0;
  this->m_arrivedPeds.numAlloced = 0;
  if ( v6 )
  {
    free(v6);
    this->m_attractPeds.dataPtr = 0;
  }
  this->m_attractPeds.numAlloced = 0;
  v7 = CPools::ms_pPedAttractorPool;
  v8 = -1601513229 * (((char *)this - (char *)CPools::ms_pPedAttractorPool->m_aStorage) >> 2);
  CPools::ms_pPedAttractorPool->m_aFlags[v8] |= 0x80u;
  if ( v8 < v7->m_nFreeIndex )
    v7->m_nFreeIndex = v8;
}
// 668DE8: using guessed type void *off_668DE8;

//----- (004AC8E0) --------------------------------------------------------
int __fastcall CPedStepAttractor::GetType(const CPedStepAttractor *this)
{
  return 9;
}

//----- (004AC8E4) --------------------------------------------------------
void __fastcall CPedStepAttractor::~CPedStepAttractor(CPedStepAttractor *this)
{
  CEntity *m_pEntity; // r0
  CEntity **p_m_pEntity; // r1
  CPedTaskPair *dataPtr; // r0
  CPed **v5; // r0
  CPed **v6; // r0
  CPedAttractorPool *v7; // r0
  int v8; // r1

  p_m_pEntity = &this->m_pEntity;
  m_pEntity = this->m_pEntity;
  this->_vptr$CPedAttractor = (int (**)(void))&off_668DE8;
  if ( m_pEntity )
    CEntity::CleanUpOldReference(m_pEntity, p_m_pEntity);
  dataPtr = this->m_pedTaskPairs.dataPtr;
  this->m_pedTaskPairs.numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->m_pedTaskPairs.dataPtr = 0;
  }
  v5 = this->m_arrivedPeds.dataPtr;
  this->m_arrivedPeds.numEntries = 0;
  this->m_pedTaskPairs.numAlloced = 0;
  if ( v5 )
  {
    free(v5);
    this->m_arrivedPeds.dataPtr = 0;
  }
  v6 = this->m_attractPeds.dataPtr;
  this->m_attractPeds.numEntries = 0;
  this->m_arrivedPeds.numAlloced = 0;
  if ( v6 )
  {
    free(v6);
    this->m_attractPeds.dataPtr = 0;
  }
  this->m_attractPeds.numAlloced = 0;
  v7 = CPools::ms_pPedAttractorPool;
  v8 = -1601513229 * (((char *)this - (char *)CPools::ms_pPedAttractorPool->m_aStorage) >> 2);
  CPools::ms_pPedAttractorPool->m_aFlags[v8] |= 0x80u;
  if ( v8 < v7->m_nFreeIndex )
    v7->m_nFreeIndex = v8;
}
// 668DE8: using guessed type void *off_668DE8;

//----- (004AC96C) --------------------------------------------------------
Bool8 __fastcall CPed::GetPedTalking(CPed *this)
{
  return sub_19DA74(&this->m_PedSpeechAudioEntity);
}

//----- (004AC974) --------------------------------------------------------
void __fastcall CPed::DisablePedSpeech(CPed *this, Int16 Curtail)
{
  sub_190A54(&this->m_PedSpeechAudioEntity, Curtail);
}

//----- (004AC97C) --------------------------------------------------------
void __fastcall CPed::EnablePedSpeech(CPed *this)
{
  sub_194D04(&this->m_PedSpeechAudioEntity);
}

//----- (004AC984) --------------------------------------------------------
void __fastcall CPed::DisablePedSpeechForScriptSpeech(CPed *this, Int16 Curtail)
{
  sub_199840(&this->m_PedSpeechAudioEntity, Curtail);
}

//----- (004AC98C) --------------------------------------------------------
void __fastcall CPed::EnablePedSpeechForScriptSpeech(CPed *this)
{
  sub_18B3F0(&this->m_PedSpeechAudioEntity);
}

//----- (004AC994) --------------------------------------------------------
Bool8 __fastcall CPed::CanPedHoldConversation(CPed *this)
{
  return sub_1987B4(&this->m_PedSpeechAudioEntity);
}

//----- (004AC99C) --------------------------------------------------------
void __fastcall CPed::SayScript(
        CPed *this,
        tAudioEvent ScriptID,
        Bool8 OverideSilence,
        Bool8 bForceAudible,
        Bool8 bFrontEnd)
{
  CAEPedSpeechAudioEntity::AddScriptSayEvent(
    &this->m_PedSpeechAudioEntity,
    53,
    ScriptID,
    OverideSilence,
    bForceAudible,
    bFrontEnd);
}

//----- (004AC9BC) --------------------------------------------------------
int __fastcall CPed::Say(
        CPed *this,
        int Phrase,
        UInt32 StartTimeDelay,
        float Probability,
        int bOverideSilence,
        int bForceAudible,
        int bFrontEnd)
{
  if ( Phrase )
    return CAEPedSpeechAudioEntity::AddSayEvent(
             &this->m_PedSpeechAudioEntity,
             52,
             Phrase,
             StartTimeDelay,
             Probability,
             bOverideSilence,
             bForceAudible,
             bFrontEnd);
  else
    return -1;
}

//----- (004AC9F8) --------------------------------------------------------
const unsigned __int8 *__fastcall CMoveStateStrings::GetMoveStateString(CMoveStateStrings *this, const int iMoveState)
{
  const unsigned __int8 *result; // r0

  switch ( iMoveState )
  {
    case 1:
      result = this->m_sMoveStateStill;
      break;
    case 2:
      result = this->m_sMoveStateTurnL;
      break;
    case 3:
      result = this->m_sMoveStateTurnR;
      break;
    case 4:
      result = this->m_sMoveStateWalk;
      break;
    case 6:
      result = this->m_sMoveStateRun;
      break;
    case 7:
      result = this->m_sMoveStateSprint;
      break;
    default:
      result = this->m_sMoveStateNone;
      break;
  }
  return result;
}

//----- (004ACA30) --------------------------------------------------------
void __fastcall CPedDebugVisualiser::VisualisePedsNearPlayer(CPedDebugVisualiser *this)
{
  if ( !TheCamera.WorldViewerBeingUsed )
    sub_19846C(-1);
}

//----- (004ACA4C) --------------------------------------------------------
void __fastcall CPedDebugVisualiser::VisualiseNearbyAttractors(const CPedDebugVisualiser *this, const CPed *ped)
{
  CMatrix *m_pMat; // r2
  CSimpleTransform *p_tx; // r3
  float x; // s16
  float y; // s18
  float v7; // s26
  float v8; // r5
  float v9; // r6
  float v10; // r0
  const CPed *v11; // r2
  int v12; // r1
  int v13; // r11
  int v14; // r3
  int v15; // r0
  int v16; // r10
  int v17; // r8
  int v18; // r0
  const CPed *v19; // r2
  int v21; // [sp+4h] [bp-5Ch]
  const CPed *v22; // [sp+8h] [bp-58h]
  int v23; // [sp+Ch] [bp-54h]

  m_pMat = ped->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &ped->m_transform;
  x = p_tx->m_translate.x;
  y = p_tx->m_translate.y;
  v7 = floorf((float)((float)(p_tx->m_translate.x - 15.0) / 50.0) + 60.0);
  v8 = floorf((float)((float)(y - 15.0) / 50.0) + 60.0);
  v9 = floorf((float)((float)(x + 15.0) / 50.0) + 60.0);
  v10 = floorf((float)((float)(y + 15.0) / 50.0) + 60.0);
  v11 = 0;
  v12 = (int)v10;
  v13 = (int)v9;
  v14 = (int)v8;
  if ( (int)v10 >= 119 )
    v12 = 119;
  if ( v13 >= 119 )
    v13 = 119;
  if ( v14 <= 0 )
    v14 = 0;
  if ( (int)v7 > 0 )
    v11 = (const CPed *)(int)v7;
  v21 = v12;
  v22 = v11;
  v23 = v14;
  if ( v14 <= v12 )
  {
    do
    {
      if ( (int)v22 <= v13 )
      {
        v15 = 119;
        if ( v23 < 119 )
          v15 = v23;
        v16 = (int)v22;
        v17 = 120 * v15;
        do
        {
          v18 = 119;
          if ( v16 < 119 )
            v18 = v16;
          CPedDebugVisualiser::VisualiseAttractorsInPtrList(
            this,
            &CWorld::ms_aSectors[v18 + v17].m_buildingPtrListArray,
            v11);
          CPedDebugVisualiser::VisualiseAttractorsInPtrList(
            this,
            &CWorld::ms_aRepeatSectors[v16 & 0xF | (unsigned __int8)(16 * v23)].m_ptrListArray[2],
            v19);
        }
        while ( v16++ < v13 );
      }
      v11 = (const CPed *)v23++;
    }
    while ( (int)v11 < v21 );
  }
}
// 4ACB72: variable 'v11' is possibly undefined
// 4ACB8C: variable 'v19' is possibly undefined

//----- (004ACBC8) --------------------------------------------------------
void __fastcall CPedDebugVisualiser::VisualiseAttractorsInPtrList(
        const CPedDebugVisualiser *this,
        CPtrList *ptrList,
        const CPed *ped)
{
  CPtrNode *m_pHead; // r1
  CPtrNode v4; // kr00_8
  CBaseModelInfo *v5; // r6
  int32 v6; // r9
  C2dEffect *v7; // r10
  __int64 v8; // d16
  __int64 v9; // d16
  const CMatrix *v10; // r1
  __int64 v11; // d16
  CPtrNode *m_pNext; // [sp+4h] [bp-64h]
  CVector v; // [sp+8h] [bp-60h] BYREF
  CVector v14; // [sp+18h] [bp-50h] BYREF
  CVector v15; // [sp+28h] [bp-40h] BYREF
  CVector v16; // [sp+34h] [bp-34h] BYREF
  CVector v17; // [sp+40h] [bp-28h] BYREF

  m_pHead = ptrList->m_pHead;
  if ( m_pHead )
  {
    do
    {
      v4 = *m_pHead;
      m_pNext = m_pHead->m_pNext;
      if ( (*((_BYTE *)m_pHead->m_pVoid + 58) & 7) != 4
        || (*((_DWORD *)v4.m_pVoid + 7) & 0x40004) != 0 && (*((_BYTE *)v4.m_pVoid + 324) & 0x40) == 0 )
      {
        v5 = CModelInfo::ms_modelInfoPtrs[*((__int16 *)v4.m_pVoid + 19)];
        if ( v5->m_num2dEffects )
        {
          v6 = 0;
          do
          {
            v7 = CBaseModelInfo::Get2dEffect(v5, v6);
            if ( v7->m_type == 3 )
            {
              if ( !*((_DWORD *)v4.m_pVoid + 5) )
              {
                CPlaceable::AllocateMatrix((CPlaceable *)v4.m_pVoid);
                CSimpleTransform::UpdateMatrix(
                  (const CSimpleTransform *)((char *)v4.m_pVoid + 4),
                  *((CMatrix **)v4.m_pVoid + 5));
              }
              CVector::FromMultiply(&v17, (const CMatrix *)v4.m_pNext, &v7->m_posn);
              if ( !*((_DWORD *)v4.m_pVoid + 5) )
              {
                CPlaceable::AllocateMatrix((CPlaceable *)v4.m_pVoid);
                CSimpleTransform::UpdateMatrix(
                  (const CSimpleTransform *)((char *)v4.m_pVoid + 4),
                  *((CMatrix **)v4.m_pVoid + 5));
              }
              v8 = *(_QWORD *)&v7->attr.l.m_colour._anon_0._anon_0.red;
              v15.z = v7->attr.l.m_size;
              *(_QWORD *)&v15.x = v8;
              CVector::FromMultiply3X3(&v16, (const CMatrix *)v4.m_pNext, &v15);
              if ( !*((_DWORD *)v4.m_pVoid + 5) )
              {
                CPlaceable::AllocateMatrix((CPlaceable *)v4.m_pVoid);
                CSimpleTransform::UpdateMatrix(
                  (const CSimpleTransform *)((char *)v4.m_pVoid + 4),
                  *((CMatrix **)v4.m_pVoid + 5));
              }
              v9 = *(_QWORD *)&v7->attr.es.Coors2X;
              v14.z = v7->attr.q.m_useDir.z;
              *(_QWORD *)&v14.x = v9;
              CVector::FromMultiply3X3(&v15, (const CMatrix *)v4.m_pNext, &v14);
              v10 = (const CMatrix *)*((_DWORD *)v4.m_pVoid + 5);
              if ( !v10 )
              {
                CPlaceable::AllocateMatrix((CPlaceable *)v4.m_pVoid);
                CSimpleTransform::UpdateMatrix(
                  (const CSimpleTransform *)((char *)v4.m_pVoid + 4),
                  *((CMatrix **)v4.m_pVoid + 5));
                v10 = (const CMatrix *)*((_DWORD *)v4.m_pVoid + 5);
              }
              v11 = *(_QWORD *)&v7->attr.es.Coors3X;
              LODWORD(v.z) = v7->attr.l.m_pCoronaTex;
              *(_QWORD *)&v.x = v11;
              CVector::FromMultiply3X3(&v14, v10, &v);
            }
            ++v6;
          }
          while ( v6 < v5->m_num2dEffects );
        }
      }
      m_pHead = m_pNext;
    }
    while ( m_pNext );
  }
}

//----- (004ACCF2) --------------------------------------------------------
void __fastcall CPedDebugVisualiser::SetRenderStates(CPedDebugVisualiser *this)
{
  CRGBA v1; // r0
  CRGBA v2; // r0
  CRGBA v3; // [sp+8h] [bp-10h] BYREF
  CRGBA v4; // [sp+Ch] [bp-Ch] BYREF

  RwRenderStateSet(rwRENDERSTATETEXTUREADDRESS, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATETEXTUREPERSPECTIVE, 0);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
  RwRenderStateSet(rwRENDERSTATESHADEMODE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, 0);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  RwRenderStateSet(rwRENDERSTATEBORDERCOLOR, (void *)0xFF000000);
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
  RwRenderStateSet(rwRENDERSTATECULLMODE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATEALPHATESTFUNCTION, &byte_5);
  RwRenderStateSet(rwRENDERSTATEALPHATESTFUNCTIONREF, (char *)&dword_0 + 2);
  CFont::SetFontStyle(1u);
  CFont::SetBackground(0, 0);
  CFont::SetWrapx(640.0);
  CFont::SetOrientation(0);
  CFont::SetProportional(1u);
  CRGBA::CRGBA(&v4, 0xFFu, 0xFFu, 0, 0xC8u);
  CFont::SetColor(v1);
  CFont::SetEdge(1);
  CRGBA::CRGBA(&v3, 0, 0, 0, 0xFFu);
  CFont::SetDropColor(v2);
}
// 4ACDA8: variable 'v1' is possibly undefined
// 4ACDC0: variable 'v2' is possibly undefined
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (004ACDC8) --------------------------------------------------------
void __fastcall CPedDebugVisualiser::VisualiseText(const CPedDebugVisualiser *this, const CPed *ped)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  CMatrix *m_pMat; // r1
  CSimpleTransform *p_tx; // r2
  float x; // s0
  CSimpleTransform *p_m_transform; // r1
  float z; // s4
  float pScaleY; // [sp+8h] [bp-28h] BYREF
  float pScaleX; // [sp+Ch] [bp-24h] BYREF
  RwV3d_0 In; // [sp+10h] [bp-20h] BYREF
  RwV3d_0 pResult; // [sp+1Ch] [bp-14h] BYREF

  if ( !TheCamera.WorldViewerBeingUsed )
    FindPlayerPed(-1);
  m_pMat = ped->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &ped->m_transform;
  x = p_tx->m_translate.x;
  p_m_transform = (CSimpleTransform *)&TheCamera.m_pMat->tx;
  z = p_tx->m_translate.z;
  if ( !TheCamera.m_pMat )
    p_m_transform = &TheCamera.m_transform;
  if ( (float)((float)((float)((float)(x - p_m_transform->m_translate.x) * (float)(x - p_m_transform->m_translate.x))
                     + (float)((float)(p_tx->m_translate.y - p_m_transform->m_translate.y)
                             * (float)(p_tx->m_translate.y - p_m_transform->m_translate.y)))
             + (float)((float)(z - p_m_transform->m_translate.z) * (float)(z - p_m_transform->m_translate.z))) <= 900.0 )
  {
    In.y = p_tx->m_translate.y;
    In.x = x;
    In.z = z + 2.0;
    if ( CSprite::CalcScreenCoors(&In, &pResult, &pScaleX, &pScaleY, 1, 1) == 1 )
    {
      v2.n64_f32[0] = pScaleY / 60.0;
      v3.n64_u32[0] = 1060320051;
      CFont::SetScale(vmin_f32(v2, v3).n64_f32[0]);
      CTaskManager::GetActiveTask(&ped->m_pPedIntelligence->m_taskManager);
    }
  }
}
// 4ACE84: variable 'v2' is possibly undefined
// 4ACE84: variable 'v3' is possibly undefined

//----- (004ACEB6) --------------------------------------------------------
void __fastcall CPedDebugVisualiser::VisualiseBoundingVolumes(const CPedDebugVisualiser *this, CPed *ped)
{
  CSimpleTransform *p_m_transform; // r5
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  CMatrix *v6; // r0
  CVector vCentre; // [sp+4h] [bp-44h] BYREF
  CVector corners; // [sp+10h] [bp-38h] BYREF

  p_m_transform = &ped->m_transform;
  m_pMat = ped->m_pMat;
  p_tx = &ped->m_transform;
  if ( m_pMat )
    p_tx = (CSimpleTransform *)&m_pMat->tx;
  CPedGeometryAnalyser::ComputeEntityBoundingBoxCorners(p_tx->m_translate.z, ped, &corners);
  v6 = ped->m_pMat;
  if ( v6 )
    p_m_transform = (CSimpleTransform *)&v6->tx;
  CPedGeometryAnalyser::ComputeEntityBoundingBoxCentre(p_m_transform->m_translate.z, ped, &vCentre);
}

//----- (004ACEEE) --------------------------------------------------------
void __fastcall CPedDebugVisualiser::VisualiseHitSidesToPlayer(const CPedDebugVisualiser *this, CPed *ped)
{
  CPlayerPed *PlayerPed; // r0
  CVehicle *m_pMyVehicle; // r1
  bool v5; // zf
  const CEntity *v6; // r0
  CVector v7[4]; // [sp+0h] [bp-38h] BYREF

  PlayerPed = FindPlayerPed(-1);
  m_pMyVehicle = ped->m_pMyVehicle;
  v5 = m_pMyVehicle == 0;
  if ( m_pMyVehicle )
    v5 = *((unsigned __int8 *)&ped->m_nPedFlags + 1) << 31 == 0;
  if ( v5 )
  {
    CPedGeometryAnalyser::ComputeEntityHitSide(PlayerPed, ped);
    v6 = ped;
  }
  else
  {
    CPedGeometryAnalyser::ComputeEntityHitSide(PlayerPed, m_pMyVehicle);
    v6 = ped->m_pMyVehicle;
  }
  CPedGeometryAnalyser::ComputeEntityDirs(v6, v7);
}

//----- (004ACF36) --------------------------------------------------------
void __fastcall CPedDebugVisualiser::CTextDisplayFlags::CTextDisplayFlags(CPedDebugVisualiser::CTextDisplayFlags *this)
{
  *this = 0;
}

//----- (004ACF40) --------------------------------------------------------
RwObject_0 *__fastcall SetPedAtomicVisibilityCB(RwObject_0 *pObject, void *pData)
{
  if ( !pData )
    pObject->flags = 0;
  return pObject;
}

//----- (004ACF4C) --------------------------------------------------------
RwFrame_0 *__fastcall RecurseFrameChildrenVisibilityCB(RwFrame_0 *pFrame, void *pData)
{
  RwFrameForAllObjects(pFrame, SetPedAtomicVisibilityCB, pData);
  RwFrameForAllChildren(pFrame, RecurseFrameChildrenVisibilityCB, 0);
  return pFrame;
}

//----- (004ACF7C) --------------------------------------------------------
RwObject_0 *__fastcall CloneAtomicToFrameCB(RwObject_0 *pObject, void *pData)
{
  RpAtomic_0 *v4; // r6

  v4 = RpAtomicClone((RpAtomic_0 *)pObject);
  RpAtomicSetFrame(v4, (RwFrame_0 *)pData);
  RpClumpAddAtomic(pNastyClump, v4);
  CVisibilityPlugins::SetAtomicRenderCallback(v4, 0);
  return pObject;
}

//----- (004ACFB8) --------------------------------------------------------
RwFrame_0 *__fastcall RecurseFrameChildrenToCloneCB(RwFrame_0 *pFrame, void *pData)
{
  RwFrame_0 *v4; // r6

  v4 = RwFrameCreate();
  RwFrameAddChild((RwFrame_0 *)pData, v4);
  RwFrameTransform(v4, &pFrame->modelling, rwCOMBINEREPLACE);
  RwFrameForAllObjects(pFrame, CloneAtomicToFrameCB, v4);
  RwFrameForAllChildren(pFrame, RecurseFrameChildrenToCloneCB, v4);
  return v4;
}

//----- (004AD00C) --------------------------------------------------------
void __fastcall CPed::RemoveBodyPart(CPed *this, int32 index, int8 dirn)
{
  int8 v3; // r5
  int m_nPedFlags; // r0

  v3 = index;
  if ( this->m_aPedFrames[index]->_anon_1.pFrame )
  {
    if ( CLocalisation::ShootLimbs() )
    {
      m_nPedFlags = (int)this->m_nPedFlags;
      this->m_nLimbRemoveIndex = v3;
      *(_DWORD *)&this->m_nPedFlags = m_nPedFlags | 0x8000;
    }
  }
}

//----- (004AD040) --------------------------------------------------------
uint8 __fastcall CPed::DoesLOSBulletHitPed(CPed *this, CColPoint *colPoint)
{
  RpHAnimHierarchy_0 *AnimHierarchyFromSkinClump; // r6
  RwInt32 v5; // r4
  const RwMatrix *v6; // r3
  uint8 v7; // r4
  float z; // s0
  RwV3d_0 pointsIn; // [sp+4h] [bp-1Ch] BYREF

  memset(&pointsIn, 0, sizeof(pointsIn));
  AnimHierarchyFromSkinClump = GetAnimHierarchyFromSkinClump((RpClump_0 *)this->m_pRwObject);
  v5 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, this->m_aPedFrames[2]->boneTag);
  v6 = &RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump)[v5];
  v7 = 1;
  RwV3dTransformPoints(&pointsIn, &pointsIn, 1, v6);
  if ( this->m_nPedState != PED_FALL )
  {
    z = colPoint->m_vecPosition.z;
    if ( z >= pointsIn.z )
    {
      v7 = 0;
      if ( z < (float)(pointsIn.z + 0.2) )
        return 2;
    }
    else
    {
      return 1;
    }
  }
  return v7;
}

//----- (004AD0C4) --------------------------------------------------------
uint8 __fastcall CPed::IsPedHeadAbovePos(CPed *this, float fTestHeight)
{
  uint8 v2; // r4
  RpHAnimHierarchy_0 *AnimHierarchyFromSkinClump; // r6
  RwInt32 v6; // r9
  RwMatrix *MatrixArray; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_tx; // r1
  RwV3d_0 pointsIn; // [sp+4h] [bp-24h] BYREF

  v2 = 0;
  memset(&pointsIn, 0, sizeof(pointsIn));
  AnimHierarchyFromSkinClump = GetAnimHierarchyFromSkinClump((RpClump_0 *)this->m_pRwObject);
  v6 = RpHAnimIDGetIndex(AnimHierarchyFromSkinClump, this->m_aPedFrames[2]->boneTag);
  MatrixArray = RpHAnimHierarchyGetMatrixArray(AnimHierarchyFromSkinClump);
  RwV3dTransformPoints(&pointsIn, &pointsIn, 1, &MatrixArray[v6]);
  m_pMat = this->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &this->m_transform;
  if ( pointsIn.z > (float)(p_tx->m_translate.z + fTestHeight) )
    return 1;
  return v2;
}

//----- (004AD138) --------------------------------------------------------
void __fastcall CPed::KillPedWithCar(CPed *this, CVehicle *pVehicle, float fImpulse, bool bAddAnims)
{
  float32x2_t v4; // d0
  float32x2_t v5; // d2
  float32x2_t v6; // d4
  float32x2_t v7; // d5
  float32x2_t v8; // d8
  _BOOL4 v10; // r10
  CTask *SimplestActiveTask; // r0
  int v14; // r0
  CEntity *m_pNOCollisionVehicle; // r0
  bool v16; // cc
  CEntity *m_pEntityStandingOn; // r0
  CVehicle *m_pMyVehicle; // r0
  int32 m_baseVehicleType; // r0
  bool v20; // zf
  CTask *ActiveTaskByType; // r0
  CMatrix *m_pMat; // r0
  CSimpleTransform *p_m_transform; // r11
  CMatrix *v24; // r1
  CSimpleTransform *v25; // r9
  CSimpleTransform *p_tx; // r2
  CSimpleTransform *v27; // r0
  RwReal v28; // s0
  RwReal v29; // s4
  float v30; // s0
  int32 LocalDirection; // r8
  float v32; // s0
  CPedFlags *p_m_nPedFlags; // r11
  const CEventDamage *v34; // r0
  AnimationId v35; // r8
  int v36; // r0
  RwReal *p_z; // r0
  _BOOL4 IsPlayer; // r0
  char v39; // r6
  unsigned int v40; // s0
  CPad *Pad; // r0
  RwReal v42; // s0
  int32 v43; // r8
  CColModel *ColModel; // r0
  float v45; // s2
  RwReal v46; // s4
  eWeaponType v47; // r9
  RwReal v48; // s6
  RwReal v49; // s4
  CMatrix *v50; // r1
  float v51; // s0
  float v52; // s2
  float xy; // s4
  float yy; // s8
  float zy; // s6
  __int64 v56; // d16
  float x; // s0
  float y; // s2
  float z; // s4
  float v60; // s12
  RwReal v61; // s4
  RwReal v62; // s0
  RwReal v63; // s2
  RwReal v64; // s2
  RwReal v65; // s4
  float v66; // s18
  float v67; // s20
  float v68; // s2
  int v69; // r0
  float v70; // s0
  float v71; // s2
  float v72; // s2
  RwReal v73; // s4
  float v74; // s18
  float v75; // s20
  CColModel *v76; // r0
  CMatrix *v77; // r1
  float v78; // s2
  float v79; // s0
  CSimpleTransform *v80; // r0
  float v81; // s0
  float v82; // s2
  float v83; // s20
  int v84; // r0
  CSimpleTransform *v85; // r0
  float v86; // s2
  float v87; // s0
  CMatrix *v88; // r0
  CSimpleTransform *v89; // r1
  float v90; // s0
  CSimpleTransform *v91; // r1
  CMatrix *v92; // r0
  CMatrix *v93; // r0
  CSimpleTransform *v94; // r1
  float v95; // s22
  float v96; // s24
  float v97; // s26
  float v98; // s28
  unsigned __int8 v99; // r6
  __int64 v100; // d16
  float v101; // s0
  unsigned int v102; // s4
  unsigned int v103; // s2
  int v104; // r0
  CPhysical *v105; // r6
  char v106; // r0
  CMatrix *v107; // r1
  float v108; // s4
  float v109; // s2
  float v110; // s0
  float v111; // s6
  float v112; // s0
  float v113; // s4
  float v114; // s2
  float v115; // s12
  float v116; // s10
  CMatrix *v117; // r0
  CMatrix *v118; // r0
  CMatrix *v119; // r1
  RwReal v120; // s0
  RwReal v121; // s4
  CPed *pDriver; // r2
  eCrimeType v123; // r0
  unsigned int v124; // r0
  AnimationId v125; // r6
  int v126; // r1
  float v127; // s0
  float v128; // s16
  float v129; // s18
  int v130; // r0
  unsigned int v131; // r1
  CMatrix *v132; // r0
  float xz; // s6
  float yz; // s8
  float zz; // s10
  float v136; // s12
  float v137; // s14
  float v138; // s4
  float v139; // s10
  float v140; // s6
  float v141; // s6
  float32x2_t v142; // d4
  float v143; // s6
  float v144; // s6
  CVector ePieceType; // [sp+0h] [bp-F0h]
  int v146; // [sp+10h] [bp-E0h]
  CVector v147; // [sp+18h] [bp-D8h] BYREF
  CVector2D dir; // [sp+28h] [bp-C8h] BYREF
  CEventDamage v149; // [sp+30h] [bp-C0h] BYREF
  CPedDamageResponseCalculator v150; // [sp+74h] [bp-7Ch] BYREF
  CVector v151; // [sp+88h] [bp-68h] BYREF
  CVector v152; // 0:r1.12
  CVector v153; // 0:r1.12

  v10 = bAddAnims;
  if ( CTaskManager::GetSimplestActiveTask(&this->m_pPedIntelligence->m_taskManager) )
  {
    SimplestActiveTask = CTaskManager::GetSimplestActiveTask(&this->m_pPedIntelligence->m_taskManager);
    v14 = (*((int (__fastcall **)(CTask *))SimplestActiveTask->_vptr$CTask + 5))(SimplestActiveTask);
    switch ( v14 )
    {
      case 207:
        goto LABEL_5;
      case 218:
        return;
      case 212:
LABEL_5:
        m_pNOCollisionVehicle = this->m_pNOCollisionVehicle;
        v16 = m_pNOCollisionVehicle != 0;
        if ( m_pNOCollisionVehicle )
          v16 = *(_BYTE *)&pVehicle->m_info > 7u;
        if ( !v16 )
          this->m_pNOCollisionVehicle = pVehicle;
        return;
    }
  }
  m_pEntityStandingOn = this->m_pEntityStandingOn;
  if ( m_pEntityStandingOn && (*(_BYTE *)&m_pEntityStandingOn->m_info & 7) == 2 )
  {
    if ( m_pEntityStandingOn[24]._vptr$CPlaceable == (int (**)(void))&byte_5 || CPed::IsPlayer(this) )
      return;
LABEL_19:
    ActiveTaskByType = CTaskManager::FindActiveTaskByType(&this->m_pPedIntelligence->m_taskManager, 1004);
    if ( ActiveTaskByType
      && (CVehicle *)ActiveTaskByType[2]._vptr$CTask == pVehicle
      && (float)((float)((float)(pVehicle->m_vecMoveSpeed.x * pVehicle->m_vecMoveSpeed.x)
                       + (float)(pVehicle->m_vecMoveSpeed.y * pVehicle->m_vecMoveSpeed.y))
               + (float)(pVehicle->m_vecMoveSpeed.z * pVehicle->m_vecMoveSpeed.z)) < 0.0225 )
    {
      return;
    }
    m_pMat = pVehicle->m_pMat;
    p_m_transform = &pVehicle->m_transform;
    v24 = this->m_pMat;
    v25 = &this->m_transform;
    p_tx = &pVehicle->m_transform;
    if ( m_pMat )
      p_tx = (CSimpleTransform *)&m_pMat->tx;
    v27 = &this->m_transform;
    if ( v24 )
      v27 = (CSimpleTransform *)&v24->tx;
    v28 = v27->m_translate.x - p_tx->m_translate.x;
    v29 = v27->m_translate.z - p_tx->m_translate.z;
    v151.y = v27->m_translate.y - p_tx->m_translate.y;
    v151.x = v28;
    v151.z = v29;
    if ( fImpulse <= 12.0 || CPed::IsPlayer(this) )
    {
      if ( fImpulse <= 3.0 || this->m_vecDamageNormal.z >= -0.8 )
      {
        if ( fImpulse <= 6.0 )
          return;
        IsPlayer = CPed::IsPlayer(this);
        if ( fImpulse <= 10.0 && IsPlayer )
          return;
      }
      *(_DWORD *)&this->m_nPedFlags &= ~1u;
      v30 = -pVehicle->m_vecMoveSpeed.x;
      dir.y = -pVehicle->m_vecMoveSpeed.y;
      dir.x = v30;
      LocalDirection = CPed::GetLocalDirection(this, &dir);
      v32 = 30.0;
      p_m_nPedFlags = &this->m_nPedFlags;
      if ( CPed::IsPlayer(this) && pVehicle->m_vehicleType == 6 )
        v32 = 150.0;
      CPedDamageResponseCalculator::CPedDamageResponseCalculator(
        &v150,
        pVehicle,
        v32,
        WEAPONTYPE_RAMMEDBYCAR,
        PED_SPHERE_CHEST,
        0);
      CEventDamage::CEventDamage(
        &v149,
        pVehicle,
        CTimer::m_snTimeInMilliseconds,
        WEAPONTYPE_RAMMEDBYCAR,
        PED_SPHERE_CHEST,
        LocalDirection,
        0,
        *(_DWORD *)p_m_nPedFlags & 0x100);
      if ( CEventDamage::AffectsPed(v34, this) )
      {
        v35 = LocalDirection + 24;
        CPedDamageResponseCalculator::ComputeDamageResponse(&v150, this, &v149.m_pedDamageResponse, 1);
        v149.m_nAnimGroup = ANIM_STD_PED;
        v149.m_nAnimId = v35;
        v149.m_fAnimBlendSpeed = 8.0;
        v149.m_fAnimPlaySpeed = 1.0;
        if ( v10 )
        {
          CAnimManager::BlendAnimation((RpClump_0 *)this->m_pRwObject, ANIM_STD_PED, v35, 8.0)->m_fSpeed = 1.0;
          *((_BYTE *)&v149 + 33) |= 4u;
        }
        CEventGroup::Add(&this->m_pPedIntelligence->m_eventGroup, (CEvent *)&v149, 0);
        if ( !CPed::IsPlayer(this) || (*((_BYTE *)&this->m_nFlags + 1) & 0x10) != 0 || pVehicle->m_vehicleType == 6 )
        {
          this->m_pNOCollisionVehicle = pVehicle;
        }
        else if ( this->m_vecDamageNormal.z < -0.8 )
        {
          this->m_pNOCollisionVehicle = pVehicle;
        }
        this->m_pPedIntelligence->m_collisionEventScanner.m_bAlreadyHitByCar = 1;
      }
      *((_DWORD *)&this->m_nPedFlags + 1) &= ~0x10u;
      v36 = *(_DWORD *)&this->m_nFlags & 0x1000;
      if ( pVehicle->m_vehicleType == 6 )
      {
        if ( v36 )
        {
          this->m_vecMoveSpeed.z = 0.0;
          p_z = &this->m_vecMoveSpeed.z;
          this->m_vecMoveSpeed.x = 0.0;
          this->m_vecMoveSpeed.y = 0.0;
LABEL_64:
          *p_z = 0.0;
          if ( CLocalisation::KnockDownPeds() )
            CAEVehicleAudioEntity::AddAudioEvent(&pVehicle->m_VehicleAudioEntity, 121, 0.0);
          CPed::Say(this, 0x159u, 0, 1.0, 0, 0, 0);
LABEL_153:
          CEventDamage::~CEventDamage(&v149);
          CPedDamageResponseCalculator::~CPedDamageResponseCalculator(&v150);
          v132 = pVehicle->m_pMat;
          xz = v132->xz;
          yz = v132->yz;
          zz = v132->zz;
          v136 = (float)((float)(v151.x * xz) + (float)(v151.y * yz)) + (float)(v151.z * zz);
          v151.x = v151.x - (float)(xz * v136);
          v151.y = v151.y - (float)(yz * v136);
          v151.z = v151.z - (float)(zz * v136);
          *(RwReal *)&v149.m_bIsPersistent = v151.z;
          *(_QWORD *)&v149._vptr$CEvent = *(_QWORD *)&v151.x;
          CVector::Normalise((CVector *)&v149);
          v137 = -0.5;
          v138 = *(float *)&v149.m_bIsPersistent;
          v139 = *(float *)&v149.m_bIsPersistent * pVehicle->m_vecMoveSpeed.z;
          v140 = (float)(*(float *)&v149._vptr$CEvent * pVehicle->m_vecMoveSpeed.x)
               + (float)(*(float *)&v149.m_iAccumulatedTime * pVehicle->m_vecMoveSpeed.y);
          if ( (*((_BYTE *)p_m_nPedFlags + 4) & 0x10) == 0 )
          {
            v138 = *(float *)&v149.m_bIsPersistent + -0.2;
            *(float *)&v149.m_bIsPersistent = *(float *)&v149.m_bIsPersistent + -0.2;
          }
          v6.n64_u32[0] = 1153957888;
          v141 = v140 + v139;
          v7.n64_u32[0] = LODWORD(pVehicle->m_fMass);
          if ( pVehicle->m_baseVehicleType == 9 )
            v137 = -0.75;
          v8.n64_f32[0] = v7.n64_f32[0] / 1600.0;
          v142.n64_u64[0] = vmin_f32(v7, v6).n64_u64[0];
          v143 = v142.n64_f32[0] * (float)(v141 * v137);
          v142.n64_u32[0] = 1.0;
          v144 = v143 * vmin_f32(v8, v142).n64_f32[0];
          v153.x = *(float *)&v149._vptr$CEvent * v144;
          v153.y = *(float *)&v149.m_iAccumulatedTime * v144;
          v153.z = v138 * v144;
          ePieceType.x = v151.x * 0.25;
          ePieceType.y = v151.y * 0.25;
          ePieceType.z = v151.z * 0.25;
          CPhysical::ApplyForce(pVehicle, v153, ePieceType, 1);
          return;
        }
        v56 = *(_QWORD *)&pVehicle->m_vecMoveSpeed.x;
        v147.z = pVehicle->m_vecMoveSpeed.z;
        *(_QWORD *)&v147.x = v56;
        CVector::Normalise(&v147);
        x = this->m_vecMoveSpeed.x;
        y = this->m_vecMoveSpeed.y;
        z = this->m_vecMoveSpeed.z;
        v60 = (float)((float)(x * v147.x) + (float)(y * v147.y)) + (float)(z * v147.z);
        v61 = z - (float)(v147.z * v60);
        v62 = x - (float)(v147.x * v60);
        v63 = y - (float)(v147.y * v60);
        this->m_vecMoveSpeed.x = v62;
        this->m_vecMoveSpeed.y = v63;
        this->m_vecMoveSpeed.z = v61;
        v64 = (float)(pVehicle->m_vecMoveSpeed.y * 0.3) + v63;
        v65 = (float)(pVehicle->m_vecMoveSpeed.z * 0.3) + v61;
        this->m_vecMoveSpeed.x = (float)(pVehicle->m_vecMoveSpeed.x * 0.3) + v62;
        this->m_vecMoveSpeed.y = v64;
        this->m_vecMoveSpeed.z = v65;
      }
      else if ( !v36 )
      {
        v48 = pVehicle->m_vecMoveSpeed.z * 0.75;
        v49 = pVehicle->m_vecMoveSpeed.y * 0.75;
        this->m_vecMoveSpeed.x = pVehicle->m_vecMoveSpeed.x * 0.75;
        this->m_vecMoveSpeed.y = v49;
        this->m_vecMoveSpeed.z = v48;
      }
      p_z = &this->m_vecMoveSpeed.z;
      goto LABEL_64;
    }
    v39 = rand();
    if ( FindPlayerVehicle(-1, 0) == pVehicle )
    {
      v5.n64_u32[0] = 1132068864;
      v4.n64_f32[0] = (float)((float)((float)(sqrtf(
                                                (float)((float)(pVehicle->m_vecMoveSpeed.x * pVehicle->m_vecMoveSpeed.x)
                                                      + (float)(pVehicle->m_vecMoveSpeed.y * pVehicle->m_vecMoveSpeed.y))
                                              + (float)(pVehicle->m_vecMoveSpeed.z * pVehicle->m_vecMoveSpeed.z))
                                            * 100.0)
                                    * 2000.0)
                            / pVehicle->m_fMass)
                    + 80.0;
      v40 = (unsigned int)vmin_f32(v4, v5).n64_f32[0];
      Pad = CPad::GetPad(0);
      CPad::StartShake(Pad, 0x9C40 / v40, v40, 0);
    }
    *(_DWORD *)&this->m_nPedFlags &= ~1u;
    v42 = -pVehicle->m_vecMoveSpeed.x;
    v147.y = -pVehicle->m_vecMoveSpeed.y;
    v147.x = v42;
    v43 = CPed::GetLocalDirection(this, (const CVector2D *)&v147);
    ColModel = CEntity::GetColModel(pVehicle);
    if ( pVehicle->m_vehicleType == 6 )
    {
      v45 = pVehicle->m_vecMoveSpeed.x;
      v46 = pVehicle->m_vecMoveSpeed.y * 0.9;
      this->m_vecMoveSpeed.z = 0.0;
      this->m_vecMoveSpeed.x = v45 * 0.9;
      this->m_vecMoveSpeed.y = v46;
LABEL_52:
      if ( (v43 | 2) == 3 )
        v43 = 2;
      if ( CLocalisation::KnockDownPeds() )
        CAEVehicleAudioEntity::AddAudioEvent(&pVehicle->m_VehicleAudioEntity, 119, 0.0);
      v47 = WEAPONTYPE_RUNOVERBYCAR;
      v146 = 2;
      goto LABEL_119;
    }
    v50 = pVehicle->m_pMat;
    v51 = pVehicle->m_vecMoveSpeed.x;
    v52 = pVehicle->m_vecMoveSpeed.y;
    xy = v50->xy;
    yy = v50->yy;
    zy = v50->zy;
    if ( (float)((float)((float)(v51 * xy) + (float)(v52 * yy)) + (float)(pVehicle->m_vecMoveSpeed.z * zy)) >= 0.0 )
    {
      v66 = (float)((float)(v151.x * v50->xx) + (float)(v151.y * v50->yx)) + (float)(v151.z * v50->zx);
      if ( fabsf(v66) > (float)(ColModel->m_boxBound.m_vecMax.x * 0.99) )
      {
        v67 = (float)((float)(v151.x * xy) + (float)(v151.y * yy)) + (float)(v151.z * zy);
        v68 = CEntity::GetColModel(pVehicle)->m_boxBound.m_vecMax.y;
        v69 = 3;
        v70 = v68 * 0.85;
        v71 = fabsf(v67);
        if ( v66 > 0.0 )
          v69 = 4;
        v146 = v69;
        if ( v71 < v70 )
        {
          v47 = WEAPONTYPE_RUNOVERBYCAR;
          v72 = pVehicle->m_vecMoveSpeed.x;
          v73 = pVehicle->m_vecMoveSpeed.y * 0.9;
          this->m_vecMoveSpeed.z = 0.0;
          this->m_vecMoveSpeed.x = v72 * 0.9;
          this->m_vecMoveSpeed.y = v73;
          if ( (v43 | 2) == 3 )
            v43 = 2;
        }
        else
        {
          v47 = WEAPONTYPE_RAMMEDBYCAR;
        }
        if ( CLocalisation::KnockDownPeds() )
          CAEVehicleAudioEntity::AddAudioEvent(&pVehicle->m_VehicleAudioEntity, 119, 0.0);
        goto LABEL_119;
      }
      if ( (v39 & 3) != 0
        && ((v39 & 3) == 1
         || (float)((float)((float)(v151.x * v50->xz) + (float)(v151.y * v50->yz)) + (float)(v151.z * v50->zz)) <= 0.1)
        || (pVehicle->pHandling->mFlags & 8) != 0 )
      {
        this->m_vecMoveSpeed.z = 0.0;
        this->m_vecMoveSpeed.x = v51 * 0.9;
        this->m_vecMoveSpeed.y = v52 * 0.9;
        goto LABEL_52;
      }
      v74 = CEntity::GetColModel(pVehicle)->m_boxBound.m_vecMax.y;
      v75 = CEntity::GetColModel(pVehicle)->m_boxBound.m_vecMin.y;
      v76 = CEntity::GetColModel(pVehicle);
      v77 = pVehicle->m_pMat;
      v78 = v76->m_boxBound.m_vecMax.z;
      v79 = v77->zy;
      if ( v79 >= -0.2 )
      {
        v85 = &pVehicle->m_transform;
        v86 = v78 * v77->zz;
        if ( v77 )
          v85 = (CSimpleTransform *)&v77->tx;
        v83 = v85->m_translate.z + v86;
        if ( v79 <= 0.1 )
        {
          v74 = CEntity::GetColModel(pVehicle)->m_boxBound.m_vecMax.y;
        }
        else
        {
          v87 = v74 * v79;
          v88 = this->m_pMat;
          v89 = &this->m_transform;
          if ( v88 )
            v89 = (CSimpleTransform *)&v88->tx;
          v83 = v87 + v83;
          v90 = v83 - v89->m_translate.z;
          if ( v90 > 0.0 )
          {
            v91 = &this->m_transform;
            v88->tz = (float)(v90 * 0.5) + v88->tz;
            v92 = this->m_pMat;
            if ( v92 )
              v91 = (CSimpleTransform *)&v92->tx;
            v83 = v83 + (float)((float)(v83 - v91->m_translate.z) * 0.25);
          }
        }
      }
      else
      {
        v80 = &pVehicle->m_transform;
        v81 = v75 * v79;
        v82 = v78 * v77->zz;
        if ( v77 )
          v80 = (CSimpleTransform *)&v77->tx;
        v74 = v74 - v75;
        v83 = v81 + (float)(v80->m_translate.z + v82);
      }
      v93 = this->m_pMat;
      v94 = &this->m_transform;
      v95 = pVehicle->m_vecMoveSpeed.x;
      v96 = pVehicle->m_vecMoveSpeed.y;
      v97 = pVehicle->m_vecMoveSpeed.z;
      if ( v93 )
        v94 = (CSimpleTransform *)&v93->tx;
      v98 = v94->m_translate.z;
      v99 = rand();
      v100 = *(_QWORD *)&pVehicle->m_vecMoveSpeed.x;
      v151.z = pVehicle->m_vecMoveSpeed.z;
      *(_QWORD *)&v151.x = v100;
      CVector::Normalise(&v151);
      v101 = ((double)v99 * 0.002 + 1.5)
           * (float)((float)(v83 - v98)
                   / (float)(v74 / sqrtf((float)((float)(v95 * v95) + (float)(v96 * v96)) + (float)(v97 * v97))));
      *(float *)&v102 = v151.x * (float)(v101 * 0.2);
      *(float *)&v103 = v151.y * (float)(v101 * 0.2);
      *(_QWORD *)&v151.x = __PAIR64__(v103, v102);
      v151.z = (float)(v151.z * (float)(v101 * 0.2)) + v101;
      *(_QWORD *)&this->m_vecMoveSpeed.x = __PAIR64__(v103, v102);
      this->m_vecMoveSpeed.z = v151.z;
      v104 = 2;
      if ( v43 > 1 )
        v104 = -2;
      v43 += v104;
      if ( !pVehicle->m_baseVehicleType )
      {
        v105 = CAutomobile::RemoveBonnetInPedCollision((CAutomobile *)pVehicle);
        if ( v105 )
        {
          v106 = rand();
          v107 = pVehicle->m_pMat;
          v108 = v107->yx * 0.1;
          v109 = v107->zx * 0.1;
          v110 = v107->xx * 0.1;
          v111 = this->m_vecMoveSpeed.x;
          if ( (v106 & 1) != 0 )
          {
            v112 = v110 + v111;
            v113 = v108 + this->m_vecMoveSpeed.y;
            v114 = v109 + this->m_vecMoveSpeed.z;
          }
          else
          {
            v112 = v111 - v110;
            v113 = this->m_vecMoveSpeed.y - v108;
            v114 = this->m_vecMoveSpeed.z - v109;
          }
          v115 = v107->zz * 0.5;
          v116 = v107->yz * 0.5;
          v105->m_vecMoveSpeed.x = v112 + (float)(v107->xz * 0.5);
          v105->m_vecMoveSpeed.y = v113 + v116;
          v105->m_vecMoveSpeed.z = v114 + v115;
          v117 = pVehicle->m_pMat;
          v152.x = v117->xz * 10.0;
          v152.y = v117->yz * 10.0;
          v152.z = v117->zz * 10.0;
          CPhysical::ApplyTurnForce(v105, v152, *(CVector *)&v117->xy);
        }
      }
      v118 = pVehicle->m_pMat;
      v119 = this->m_pMat;
      if ( v118 )
        p_m_transform = (CSimpleTransform *)&v118->tx;
      if ( v119 )
        v25 = (CSimpleTransform *)&v119->tx;
      v120 = v25->m_translate.x - p_m_transform->m_translate.x;
      v121 = v25->m_translate.z - p_m_transform->m_translate.z;
      v151.y = v25->m_translate.y - p_m_transform->m_translate.y;
      v151.x = v120;
      v151.z = v121;
      if ( CLocalisation::KnockDownPeds() )
        CAEVehicleAudioEntity::AddAudioEvent(&pVehicle->m_VehicleAudioEntity, 122, 0.0);
      v84 = 1;
    }
    else
    {
      if ( CLocalisation::KnockDownPeds() )
      {
        v146 = 0;
        CAEVehicleAudioEntity::AddAudioEvent(&pVehicle->m_VehicleAudioEntity, 119, 0.0);
LABEL_118:
        v47 = WEAPONTYPE_RAMMEDBYCAR;
LABEL_119:
        pDriver = pVehicle->pDriver;
        if ( pDriver )
        {
          if ( this->m_nPedType == 6 )
            v123 = CRIME_RUNOVER_COP;
          else
            v123 = CRIME_RUNOVER_PED;
          CCrime::ReportCrime(v123, this, pDriver);
        }
        CPedDamageResponseCalculator::CPedDamageResponseCalculator(&v150, pVehicle, 1000.0, v47, PED_SPHERE_CHEST, 0);
        CEventDamage::CEventDamage(
          &v149,
          pVehicle,
          CTimer::m_snTimeInMilliseconds,
          v47,
          PED_SPHERE_CHEST,
          v43,
          0,
          *(_DWORD *)&this->m_nPedFlags & 0x100);
        v124 = rand() & 3;
        p_m_nPedFlags = &this->m_nPedFlags;
        switch ( v43 )
        {
          case 0:
            if ( v146 != 3 || v124 <= 1 )
            {
              v125 = ANIM_STD_HIGHIMPACT_FRONT;
              v126 = 24;
              if ( v124 > 1 )
                v125 = ANIM_STD_HIGHIMPACT_RIGHT;
              goto LABEL_138;
            }
            v125 = ANIM_STD_HIGHIMPACT_LEFT;
            break;
          case 1:
            goto LABEL_131;
          case 2:
            if ( v146 == 3 && v124 > 1 )
            {
LABEL_131:
              v125 = ANIM_STD_SPINFORWARD_LEFT;
            }
            else
            {
              v125 = ANIM_STD_HIGHIMPACT_BACK;
              v126 = 26;
              if ( v124 > 1 )
                v125 = ANIM_STD_SPINFORWARD_RIGHT;
LABEL_138:
              if ( v146 != 4 )
                v125 = v126;
            }
            break;
          case 3:
            v125 = ANIM_STD_SPINFORWARD_RIGHT;
            break;
          default:
            v125 = ANIM_STD_NUM;
            p_m_nPedFlags = &this->m_nPedFlags;
            break;
        }
        if ( CEventDamage::AffectsPed(&v149, this) )
        {
          v127 = sqrtf(
                   (float)((float)(pVehicle->m_vecMoveSpeed.x * pVehicle->m_vecMoveSpeed.x)
                         + (float)(pVehicle->m_vecMoveSpeed.y * pVehicle->m_vecMoveSpeed.y))
                 + (float)(pVehicle->m_vecMoveSpeed.z * pVehicle->m_vecMoveSpeed.z));
          if ( v47 == WEAPONTYPE_RAMMEDBYCAR )
          {
            v128 = 1.0;
            v129 = v127 * 8.0;
          }
          else
          {
            v129 = v127 * 12.0;
            v128 = (float)(v127 * 16.0) + 1.0;
          }
          CPedDamageResponseCalculator::ComputeDamageResponse(&v150, this, &v149.m_pedDamageResponse, 1);
          v149.m_nAnimId = v125;
          v149.m_nAnimGroup = ANIM_STD_PED;
          v149.m_fAnimPlaySpeed = v128;
          v149.m_fAnimBlendSpeed = v129 + 4.0;
          if ( v10 )
          {
            CAnimManager::BlendAnimation((RpClump_0 *)this->m_pRwObject, ANIM_STD_PED, v125, v129 + 4.0)->m_fSpeed = v128;
            *((_BYTE *)&v149 + 33) |= 4u;
          }
          CEventGroup::Add(&this->m_pPedIntelligence->m_eventGroup, (CEvent *)&v149, 0);
          if ( !this->m_pNOCollisionVehicle )
            this->m_pNOCollisionVehicle = pVehicle;
          v130 = *((_DWORD *)p_m_nPedFlags + 1);
          v131 = v130 & 0xFFFFFFEF;
          if ( v146 == 1 )
            v131 = v130 | 0x10;
          *((_DWORD *)p_m_nPedFlags + 1) = v131;
          this->m_pPedIntelligence->m_collisionEventScanner.m_bAlreadyHitByCar = 1;
        }
        else
        {
          *((_DWORD *)p_m_nPedFlags + 1) &= ~0x10u;
        }
        CPed::Say(this, 0x156u, 0, 1.0, 0, 0, 0);
        goto LABEL_153;
      }
      v84 = 0;
    }
    v146 = v84;
    goto LABEL_118;
  }
  m_pMyVehicle = this->m_pMyVehicle;
  if ( !m_pMyVehicle || m_pMyVehicle != pVehicle )
    goto LABEL_19;
  m_baseVehicleType = pVehicle->m_baseVehicleType;
  v20 = m_baseVehicleType == 5;
  if ( m_baseVehicleType != 5 )
    v20 = pVehicle->m_vehicleType == 4;
  if ( !v20 )
    goto LABEL_19;
}
// 4AD344: variable 'v34' is possibly undefined
// 4AD484: variable 'v4' is possibly undefined
// 4AD484: variable 'v5' is possibly undefined
// 4ADDAE: variable 'v7' is possibly undefined
// 4ADDAE: variable 'v6' is possibly undefined
// 4ADDBA: variable 'v8' is possibly undefined
// 5: using guessed type char byte_5;

//----- (004ADE24) --------------------------------------------------------
void __fastcall CPed::RemoveWeaponAnims(CPed *this, int32 nWeaponType, float fBlendDelta)
{
  int v6; // r6
  int v7; // r4
  CAnimBlendAssociation *Association; // r0
  uint16 m_bitsFlag; // r1

  v6 = 0;
  v7 = 34;
  do
  {
    Association = RpAnimBlendClumpGetAssociation((RpClump_0 *)this->m_pRwObject, 0xE0u);
    if ( Association )
    {
      m_bitsFlag = Association->m_bitsFlag;
      Association->m_bitsFlag = m_bitsFlag | 4;
      if ( (m_bitsFlag & 0x10) != 0 )
        Association->m_fBlendDelta = fBlendDelta;
      else
        v6 = 1;
    }
    --v7;
  }
  while ( v7 );
  if ( v6 << 31 )
    sub_197F5C(
      (RpClump_0 *)this->m_pRwObject,
      this->m_motionAnimGroup,
      ANIM_STD_IDLE,
      COERCE_FLOAT(LODWORD(fBlendDelta) ^ 0x80000000));
}

//----- (004ADE8C) --------------------------------------------------------
int __fastcall CPedGeometryAnalyser::ComputePedShotSide(const CPed *ped, const CVector *ShotOrigin)
{
  float x; // s0
  CMatrix *m_pMat; // r0
  float y; // s2
  CSimpleTransform *p_tx; // r1
  float v7; // s0

  x = ShotOrigin->x;
  m_pMat = ped->m_pMat;
  y = ShotOrigin->y;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &ped->m_transform;
  v7 = (float)(atan2f(-(float)(x - p_tx->m_translate.x), y - p_tx->m_translate.y) - ped->m_fCurrentHeading) + 0.7854;
  if ( v7 < 0.0 )
    v7 = v7 + 6.2832;
  return (int)(float)(v7 / 1.5708);
}

//----- (004ADF14) --------------------------------------------------------
int __fastcall CPedGeometryAnalyser::ComputePedHitSide(const CPed *ped, const CPhysical *physical)
{
  return CPedGeometryAnalyser::ComputePedHitSide(ped, &physical->m_vecMoveSpeed);
}

//----- (004ADF18) --------------------------------------------------------
int __fastcall CPedGeometryAnalyser::ComputePedHitSide(const CPed *ped, const CVector *vHitVel)
{
  float32x2_t v2; // d4
  float32x2_t v3; // d5
  float32x2_t v4; // d6
  float y; // s2
  float z; // s4
  CMatrix *m_pMat; // r0
  float xx; // s6
  float yx; // s16
  float zx; // s4
  float xy; // s18
  float yy; // s2
  float zy; // s0
  float m_heading; // r4
  int result; // r0
  float v17; // s6
  float v18; // s4
  float32x2_t v19; // d0
  float v20; // s2
  float v21; // s10
  float v22; // s4
  CVector v23; // [sp+4h] [bp-24h] BYREF

  y = vHitVel->y;
  z = vHitVel->z;
  v23.x = -vHitVel->x;
  v23.y = -y;
  v23.z = -z;
  CVector::Normalise(&v23);
  m_pMat = ped->m_pMat;
  if ( m_pMat )
  {
    xx = m_pMat->xx;
    yx = m_pMat->yx;
    zx = m_pMat->zx;
    xy = m_pMat->xy;
    yy = m_pMat->yy;
    zy = m_pMat->zy;
  }
  else
  {
    m_heading = ped->m_transform.m_heading;
    yx = sinf(m_heading);
    xy = -yx;
    zy = 0.0;
    yy = cosf(m_heading);
    zx = 0.0;
    xx = yy;
  }
  result = 0;
  v19.n64_f32[1] = v23.y * yy;
  v17 = xx * v23.x;
  v18 = zx * v23.z;
  v19.n64_f32[0] = v23.z * zy;
  v3.n64_u32[0] = -1.0;
  v4.n64_f32[0] = (float)((float)(v23.x * xy) + (float)(v23.y * yy)) + v19.n64_f32[0];
  v2.n64_f32[0] = (float)((float)-(float)(yx * v23.y) - v17) - v18;
  v19.n64_f32[0] = (float)((float)-(float)(v23.y * yy) - (float)(v23.x * xy)) - v19.n64_f32[0];
  v20 = (float)(v17 + (float)(yx * v23.y)) + v18;
  v21 = vmax_f32(v4, v3).n64_f32[0];
  if ( v2.n64_f32[0] >= v21 )
    result = 1;
  else
    v2.n64_f32[0] = v21;
  LODWORD(v22) = vmax_f32(v19, v2).n64_u32[0];
  if ( v19.n64_f32[0] >= v2.n64_f32[0] )
    result = 2;
  if ( v20 >= v22 )
    return 3;
  return result;
}
// 4ADFE4: variable 'v4' is possibly undefined
// 4ADFE4: variable 'v3' is possibly undefined
// 4AE002: variable 'v2' is possibly undefined

//----- (004AE024) --------------------------------------------------------
void __fastcall CPedGeometryAnalyser::ComputeEntityDirs(const CEntity *entity, CVector *dirs)
{
  CMatrix *m_pMat; // r1
  float xx; // s6
  float yx; // s16
  float zx; // s4
  float xy; // s18
  float yy; // s2
  float zy; // s0
  float m_heading; // r5

  m_pMat = entity->m_pMat;
  if ( m_pMat )
  {
    xx = m_pMat->xx;
    yx = m_pMat->yx;
    zx = m_pMat->zx;
    xy = m_pMat->xy;
    yy = m_pMat->yy;
    zy = m_pMat->zy;
  }
  else
  {
    m_heading = entity->m_transform.m_heading;
    yx = sinf(m_heading);
    xy = -yx;
    zy = 0.0;
    yy = cosf(m_heading);
    zx = 0.0;
    xx = yy;
  }
  dirs[2].z = -zy;
  dirs[3].x = xx;
  dirs[3].y = yx;
  dirs[3].z = zx;
  dirs->x = xy;
  dirs->y = yy;
  dirs->z = zy;
  dirs[1].x = -xx;
  dirs[1].y = -yx;
  dirs[1].z = -zx;
  dirs[2].x = -xy;
  dirs[2].y = -yy;
}

//----- (004AE0C4) --------------------------------------------------------
int __fastcall CPedGeometryAnalyser::ComputeEntityHitSide(const CPed *ped, CEntity *entity)
{
  CMatrix *m_pMat; // r3
  CSimpleTransform *p_tx; // r2

  m_pMat = ped->m_pMat;
  p_tx = (CSimpleTransform *)&m_pMat->tx;
  if ( !m_pMat )
    p_tx = &ped->m_transform;
  return CPedGeometryAnalyser::ComputeEntityHitSide(&p_tx->m_translate, entity);
}

//----- (004AE0D4) --------------------------------------------------------
int __fastcall CPedGeometryAnalyser::ComputeEntityHitSide(const CVector *vPos, CEntity *entity)
{
  int result; // r0
  float v4; // s8
  float v5; // s6
  float y; // s12
  float x; // s10
  float v8; // s7
  float v9; // s1
  float v10; // s11
  int v11; // r1
  float v12; // s3
  float v13; // s0
  int v14; // r1
  CVector v15; // [sp+0h] [bp-60h] BYREF
  float v16; // [sp+Ch] [bp-54h]
  float v17; // [sp+10h] [bp-50h]
  float v18; // [sp+14h] [bp-4Ch]
  float v19; // [sp+18h] [bp-48h]
  float v20; // [sp+1Ch] [bp-44h]
  float v21; // [sp+20h] [bp-40h]
  float v22; // [sp+24h] [bp-3Ch]
  float v23; // [sp+28h] [bp-38h]
  float v24; // [sp+2Ch] [bp-34h]

  CPedGeometryAnalyser::ComputeEntityBoundingBoxCornersUncached(vPos->z, entity, &v15);
  result = 0;
  v4 = (float)((float)((float)((float)(v15.y + 0.0) + v17) + v20) + v23) * 0.25;
  v5 = (float)((float)((float)((float)(v15.x + 0.0) + v16) + v19) + v22) * 0.25;
  y = vPos->y;
  x = vPos->x;
  v8 = vPos->z * 0.0;
  v9 = (float)((float)((float)(y * (float)(v22 - v5)) - (float)(vPos->x * (float)(v23 - v4))) + v8)
     - (float)((float)((float)(v23 * (float)(v22 - v5)) - (float)(v22 * (float)(v23 - v4))) + (float)(v24 * 0.0));
  v10 = (float)((float)((float)(y * (float)(v15.x - v5)) - (float)(vPos->x * (float)(v15.y - v4))) + v8)
      - (float)((float)((float)(v15.y * (float)(v15.x - v5)) - (float)(v15.x * (float)(v15.y - v4)))
              + (float)(v15.z * 0.0));
  if ( v9 < 0.0 || v10 >= 0.0 )
  {
    v11 = 0;
    v12 = (float)((float)((float)(x * (float)-(float)(v17 - v4)) + (float)(y * (float)(v16 - v5))) + v8)
        - (float)((float)((float)(v17 * (float)(v16 - v5)) + (float)(v16 * (float)-(float)(v17 - v4)))
                + (float)(v18 * 0.0));
    if ( v12 < 0.0 )
      v11 = 1;
    if ( v10 >= 0.0 )
      result = 1;
    result &= v11;
    if ( !result )
    {
      v13 = (float)((float)((float)(x * (float)-(float)(v20 - v4)) + (float)(y * (float)(v19 - v5))) + v8)
          - (float)((float)((float)(v20 * (float)(v19 - v5)) - (float)(v19 * (float)(v20 - v4))) + (float)(v21 * 0.0));
      if ( v12 < 0.0 || v13 >= 0.0 )
      {
        v14 = 0;
        if ( v13 >= 0.0 )
          v14 = 3;
        if ( v9 < 0.0 )
          return v14;
      }
      else
      {
        return 2;
      }
    }
  }
  return result;
}

//----- (004AE298) --------------------------------------------------------
int __fastcall CPedGeometryAnalyser::ComputeEntityHitSide(
        const CVector *vPos,
        const CVector *segmentplane_normals,
        const float *segmentplane_ds)
{
  float x; // s0
  float y; // s6
  float v5; // s2
  float v6; // s12
  float z; // s4
  int result; // r0
  float v9; // s2
  float v10; // s10
  int v11; // r3
  float v12; // s8
  float v13; // s10
  float v14; // s14
  float v15; // s6
  int v16; // r1
  float v17; // s0
  float v18; // s4
  int v19; // r2
  float v20; // s0
  int v21; // r1

  x = vPos->x;
  y = vPos->y;
  v5 = vPos->x * segmentplane_normals[3].x;
  v6 = vPos->x * segmentplane_normals->x;
  z = vPos->z;
  result = 0;
  v9 = segmentplane_ds[3]
     + (float)((float)(v5 + (float)(y * segmentplane_normals[3].y)) + (float)(z * segmentplane_normals[3].z));
  v10 = *segmentplane_ds
      + (float)((float)(v6 + (float)(y * segmentplane_normals->y)) + (float)(z * segmentplane_normals->z));
  if ( v9 < 0.0 || v10 >= 0.0 )
  {
    v11 = 0;
    v12 = segmentplane_ds[1]
        + (float)((float)((float)(x * segmentplane_normals[1].x) + (float)(y * segmentplane_normals[1].y))
                + (float)(z * segmentplane_no