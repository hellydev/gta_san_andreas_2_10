  goto LABEL_406;
              goto LABEL_404;
            }
            v284 = 0;
          }
          v277 = v285;
          v276 = v286;
LABEL_404:
          v288 = v283 - v284;
          do
          {
            v289 = *v276++;
            --v288;
            v277->n128_u8[0] = v289;
            v277 = (int64x2_t *)((char *)v277 + 1);
          }
          while ( v288 );
LABEL_406:
          v1688 = (int64x2_t *)((char *)v285 + v283);
          v1687 = &v286[v283];
          goto LABEL_407;
        case UserFmtShort:
          if ( !len )
            return;
          v290 = 0;
          v291 = numchans & 0xFFFFFFF8;
          while ( 1 )
          {
            v292 = numchans;
            if ( numchans )
              break;
LABEL_424:
            if ( ++v290 == len )
              return;
          }
          v293 = 0;
          if ( (unsigned int)numchans < 8 )
          {
            v295 = v1687;
            v294 = v1688;
            v296 = v1687;
          }
          else
          {
            v295 = v1687;
            v294 = v1688;
            v296 = v1687;
            if ( v291 )
            {
              v297 = (int8x8_t *)v1688;
              if ( v1688 >= (int64x2_t *)&v1687[2 * numchans] || (char *)v1688 + numchans <= (char *)v1687 )
              {
                v296 = &v1687[2 * v291];
                v294 = (int64x2_t *)((char *)v1688 + v291);
                v298 = numchans & 0xFFFFFFF8;
                v299 = (uint16x8_t *)v1687;
                do
                {
                  v300 = *v299++;
                  v301.n128_u64[0] = 0x80008000800080LL;
                  v301.n128_u64[1] = 0x80008000800080LL;
                  v298 -= 8;
                  v297->n64_u64[0] = vmovn_s16(vsraq_n_u16(v301, v300, 8u)).n64_u64[0];
                  ++v297;
                }
                while ( v298 );
                v292 = numchans;
                v293 = numchans & 0xFFFFFFF8;
                if ( v291 == numchans )
                  goto LABEL_423;
              }
              else
              {
                v294 = v1688;
                v293 = 0;
                v296 = v1687;
                v292 = numchans;
              }
            }
          }
          v302 = v292 - v293;
          do
          {
            v303 = *(_WORD *)v296;
            v296 += 2;
            --v302;
            v294->n128_u8[0] = HIBYTE(v303) + 0x80;
            v294 = (int64x2_t *)((char *)v294 + 1);
          }
          while ( v302 );
LABEL_423:
          v1688 = (int64x2_t *)((char *)v1688 + v292);
          v1687 = &v295[2 * v292];
          goto LABEL_424;
        case UserFmtUShort:
          if ( !len )
            return;
          v304 = 0;
          v305 = numchans & 0xFFFFFFF8;
          while ( 1 )
          {
            v312 = numchans;
            if ( numchans )
              break;
LABEL_443:
            if ( ++v304 == len )
              return;
          }
          v313 = 0;
          if ( (unsigned int)numchans < 8 )
          {
            v314 = v1688;
            v315 = v1687;
          }
          else
          {
            v314 = v1688;
            v315 = v1687;
            v307 = v1688;
            v306 = v1687;
            if ( !v305 )
              goto LABEL_440;
            if ( v1688 >= (int64x2_t *)&v1687[2 * numchans] || (char *)v1688 + numchans <= (char *)v1687 )
            {
              v306 = &v1687[2 * v305];
              v307 = (int64x2_t *)((char *)v1688 + v305);
              v308 = numchans & 0xFFFFFFF8;
              v309 = (int8x8_t *)v1688;
              v310 = (int16x8_t *)v1687;
              do
              {
                v311 = *v310++;
                v308 -= 8;
                v309->n64_u64[0] = vshrn_n_s16(v311, 8u).n64_u64[0];
                ++v309;
              }
              while ( v308 );
              v312 = numchans;
              v313 = numchans & 0xFFFFFFF8;
              if ( v305 == numchans )
                goto LABEL_442;
              goto LABEL_440;
            }
            v313 = 0;
          }
          v307 = v314;
          v306 = v315;
LABEL_440:
          v316 = v312 - v313;
          do
          {
            --v316;
            v307->n128_u8[0] = v306[1];
            v307 = (int64x2_t *)((char *)v307 + 1);
            v306 += 2;
          }
          while ( v316 );
LABEL_442:
          v1688 = (int64x2_t *)((char *)v314 + v312);
          v1687 = &v315[2 * v312];
          goto LABEL_443;
        case UserFmtInt:
          if ( !len )
            return;
          v317 = 0;
          v318 = numchans & 0xFFFFFFFC;
          while ( 1 )
          {
            v326 = numchans;
            if ( numchans )
              break;
LABEL_462:
            if ( ++v317 == len )
              return;
          }
          v327 = 0;
          if ( (unsigned int)numchans < 4 )
          {
            v328 = v1688;
            v329 = v1687;
          }
          else
          {
            v328 = v1688;
            v329 = v1687;
            v320 = v1688;
            v319 = v1687;
            if ( !v318 )
              goto LABEL_459;
            if ( v1688 >= (int64x2_t *)&v1687[4 * numchans] || (char *)v1688 + numchans <= (char *)v1687 )
            {
              v319 = &v1687[4 * v318];
              v320 = (int64x2_t *)((char *)v1688 + v318);
              v321 = numchans & 0xFFFFFFFC;
              v322 = v1688;
              v323 = (uint32x4_t *)v1687;
              do
              {
                v324 = *v323++;
                v325.n128_u64[0] = 0x8000000080LL;
                v325.n128_u64[1] = 0x8000000080LL;
                v321 -= 4;
                v322->n128_u32[0] = (unsigned int)vuzp_s8(
                                                    vmovn_s32(vsraq_n_u32(v325, v324, 0x18u)),
                                                    *(int8x8_t *)&v324.n128_i8[8]);
                v322 = (int64x2_t *)((char *)v322 + 8);
              }
              while ( v321 );
              v326 = numchans;
              v327 = numchans & 0xFFFFFFFC;
              if ( v318 == numchans )
                goto LABEL_461;
              goto LABEL_459;
            }
            v327 = 0;
          }
          v320 = v328;
          v319 = v329;
LABEL_459:
          v330 = v326 - v327;
          do
          {
            v331 = v319[3];
            --v330;
            v319 += 4;
            v320->n128_u8[0] = v331 + 0x80;
            v320 = (int64x2_t *)((char *)v320 + 1);
          }
          while ( v330 );
LABEL_461:
          v1688 = (int64x2_t *)((char *)v328 + v326);
          v1687 = &v329[4 * v326];
          goto LABEL_462;
        case UserFmtUInt:
          if ( !len )
            return;
          v332 = 0;
          v333 = numchans & 0xFFFFFFFC;
          while ( 1 )
          {
            v341 = numchans;
            if ( numchans )
              break;
LABEL_481:
            if ( ++v332 == len )
              return;
          }
          v342 = 0;
          if ( (unsigned int)numchans < 4 )
          {
            v343 = v1688;
            v344 = v1687;
          }
          else
          {
            v343 = v1688;
            v344 = v1687;
            v335 = v1688;
            v334 = v1687;
            if ( !v333 )
              goto LABEL_478;
            if ( v1688 >= (int64x2_t *)&v1687[4 * numchans] || (char *)v1688 + numchans <= (char *)v1687 )
            {
              v334 = &v1687[4 * v333];
              v335 = (int64x2_t *)((char *)v1688 + v333);
              v336 = numchans & 0xFFFFFFFC;
              v337 = v1688;
              v338 = (uint32x4_t *)v1687;
              do
              {
                v339 = *v338++;
                v336 -= 4;
                v340 = vshrq_n_u32(v339, 0x18u);
                v337->n128_u32[0] = (unsigned int)vuzp_s8(vmovn_s32(v340), *(int8x8_t *)&v340.n128_i8[8]);
                v337 = (int64x2_t *)((char *)v337 + 8);
              }
              while ( v336 );
              v341 = numchans;
              v342 = numchans & 0xFFFFFFFC;
              if ( v333 == numchans )
                goto LABEL_480;
              goto LABEL_478;
            }
            v342 = 0;
          }
          v335 = v343;
          v334 = v344;
LABEL_478:
          v345 = v341 - v342;
          do
          {
            --v345;
            v335->n128_u8[0] = v334[3];
            v335 = (int64x2_t *)((char *)v335 + 1);
            v334 += 4;
          }
          while ( v345 );
LABEL_480:
          v1688 = (int64x2_t *)((char *)v343 + v341);
          v1687 = &v344[4 * v341];
          goto LABEL_481;
        case UserFmtFloat:
          if ( len )
          {
            v346 = 0;
            do
            {
              v347 = numchans;
              if ( numchans )
              {
                v348 = len;
                v349 = (char *)v1688;
                v350 = (float *)v1687;
                do
                {
                  v351 = *v350++;
                  if ( v351 <= 1.0 )
                  {
                    if ( v351 >= -1.0 )
                      v352 = (int)(float)(v351 * 127.0) + 0x80;
                    else
                      v352 = 0;
                  }
                  else
                  {
                    v352 = -1;
                  }
                  *v349++ = v352;
                  --v347;
                }
                while ( v347 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += 4 * numchans;
              }
              else
              {
                v348 = len;
              }
              ++v346;
            }
            while ( v346 != v348 );
          }
          return;
        case UserFmtDouble:
          if ( len )
          {
            v353 = 0;
            do
            {
              v354 = numchans;
              if ( numchans )
              {
                v355 = len;
                v356 = (char *)v1688;
                v357 = (double *)v1687;
                do
                {
                  v358 = *v357++;
                  if ( v358 <= 1.0 )
                  {
                    if ( v358 >= -1.0 )
                      v359 = (int)(v358 * 127.0) + 0x80;
                    else
                      v359 = 0;
                  }
                  else
                  {
                    v359 = -1;
                  }
                  *v356++ = v359;
                  --v354;
                }
                while ( v354 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += 8 * numchans;
              }
              else
              {
                v355 = len;
              }
              ++v353;
            }
            while ( v353 != v355 );
          }
          return;
        case UserFmtByte3:
          if ( len )
          {
            v360 = 0;
            do
            {
              v361 = numchans;
              if ( numchans )
              {
                v362 = len;
                v363 = v1688;
                v364 = v1687;
                do
                {
                  v365 = v364[2];
                  --v361;
                  v364 += 3;
                  v363->n128_u8[0] = v365 + 0x80;
                  v363 = (int64x2_t *)((char *)v363 + 1);
                }
                while ( v361 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += 3 * numchans;
              }
              else
              {
                v362 = len;
              }
              ++v360;
            }
            while ( v360 != v362 );
          }
          return;
        case UserFmtUByte3:
          if ( len )
          {
            v366 = 0;
            do
            {
              v367 = numchans;
              if ( numchans )
              {
                v368 = len;
                v369 = v1688;
                v370 = v1687;
                do
                {
                  --v367;
                  v369->n128_u8[0] = v370[2];
                  v369 = (int64x2_t *)((char *)v369 + 1);
                  v370 += 3;
                }
                while ( v367 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += 3 * numchans;
              }
              else
              {
                v368 = len;
              }
              ++v366;
            }
            while ( v366 != v368 );
          }
          return;
        case UserFmtMulaw:
          if ( len )
          {
            for ( i = 0; i != len; ++i )
            {
              v372 = numchans;
              if ( numchans )
              {
                v373 = v1688;
                v374 = v1687;
                do
                {
                  v375 = *v374++;
                  --v372;
                  v373->n128_u8[0] = HIBYTE(muLawDecompressionTable[v375]) + 0x80;
                  v373 = (int64x2_t *)((char *)v373 + 1);
                }
                while ( v372 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += numchans;
              }
            }
          }
          return;
        case UserFmtAlaw:
          if ( len )
          {
            for ( j = 0; j != len; ++j )
            {
              v377 = numchans;
              if ( numchans )
              {
                v378 = v1688;
                v379 = v1687;
                do
                {
                  v380 = *v379++;
                  --v377;
                  v378->n128_u8[0] = HIBYTE(aLawDecompressionTable[v380]) + 0x80;
                  v378 = (int64x2_t *)((char *)v378 + 1);
                }
                while ( v377 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += numchans;
              }
            }
          }
          return;
        case UserFmtIMA4:
          v381 = numchans;
          if ( !len )
            return;
          v382 = numchans & 0xFFFFFFF8;
          v383 = 0;
          while ( 1 )
          {
            DecodeIMA4Block(v1689, v1687, v381);
            v1687 += 36 * numchans;
            if ( v383 < len )
              break;
            v384 = (int8x8_t *)v1688;
            v381 = numchans;
LABEL_565:
            v1688 = (int64x2_t *)v384;
            if ( v383 >= len )
              return;
          }
          v384 = (int8x8_t *)v1688;
          v381 = numchans;
          v385 = v1689;
          v386 = 0;
          break;
        default:
          return;
      }
      while ( 1 )
      {
        if ( !v381 )
          goto LABEL_561;
        v387 = 0;
        if ( v381 < 8 )
        {
          v388 = v384;
        }
        else
        {
          v388 = v384;
          if ( v382 )
          {
            if ( v384 >= (int8x8_t *)&v1689[v381 + v386 * v381] || (char *)v384 + v381 <= (char *)&v1689[v386 * v381] )
            {
              v388 = (int8x8_t *)((char *)v384 + v382);
              v389 = numchans & 0xFFFFFFF8;
              v390 = (uint16x8_t *)v385;
              v391 = v384;
              do
              {
                v392 = *v390++;
                v393.n128_u64[0] = 0x80008000800080LL;
                v393.n128_u64[1] = 0x80008000800080LL;
                v389 -= 8;
                v391->n64_u64[0] = vmovn_s16(vsraq_n_u16(v393, v392, 8u)).n64_u64[0];
                ++v391;
              }
              while ( v389 );
              v381 = numchans;
              v387 = numchans & 0xFFFFFFF8;
              if ( v382 == numchans )
                goto LABEL_560;
            }
            else
            {
              v387 = 0;
              v388 = v384;
            }
          }
        }
        do
        {
          v394 = v385[v387++];
          v388->n64_u8[0] = HIBYTE(v394) + 0x80;
          v388 = (int8x8_t *)((char *)v388 + 1);
        }
        while ( v381 != v387 );
LABEL_560:
        v384 = (int8x8_t *)((char *)v384 + v381);
LABEL_561:
        ++v386;
        ++v383;
        if ( v386 <= 0x40 )
        {
          v385 += numchans;
          if ( v383 < len )
            continue;
        }
        goto LABEL_565;
      }
    case UserFmtShort:
      switch ( srcType )
      {
        case UserFmtByte:
          if ( !len )
            return;
          v13 = 0;
          v14 = numchans & 0xFFFFFFF8;
          while ( 1 )
          {
            v119 = numchans;
            if ( numchans )
              break;
LABEL_171:
            if ( ++v13 == len )
              return;
          }
          v120 = 0;
          if ( (unsigned int)numchans < 8 )
          {
            v121 = v1688;
            v122 = v1687;
          }
          else
          {
            v121 = v1688;
            v122 = v1687;
            v114 = v1688;
            v113 = v1687;
            if ( !v14 )
              goto LABEL_168;
            if ( &v1687[numchans] <= (ALima4 *)v1688 || v1687 >= (ALima4 *)v1688 + 2 * numchans )
            {
              v113 = &v1687[v14];
              v114 = (int64x2_t *)((char *)v1688 + 2 * v14);
              v115 = numchans & 0xFFFFFFF8;
              v116 = v1688;
              v117 = (int8x8_t *)v1687;
              do
              {
                v118.n64_u64[0] = v117->n64_u64[0];
                ++v117;
                v115 -= 8;
                *v116++ = vshll_n_s8(v118, 8u);
              }
              while ( v115 );
              v119 = numchans;
              v120 = numchans & 0xFFFFFFF8;
              if ( v14 == numchans )
                goto LABEL_170;
              goto LABEL_168;
            }
            v120 = 0;
          }
          v114 = v121;
          v113 = v122;
LABEL_168:
          v123 = v119 - v120;
          do
          {
            v124 = *v113++;
            --v123;
            v114->n128_u16[0] = v124 << 8;
            v114 = (int64x2_t *)((char *)v114 + 2);
          }
          while ( v123 );
LABEL_170:
          v1688 = (int64x2_t *)((char *)v121 + 2 * v119);
          v1687 = &v122[v119];
          goto LABEL_171;
        case UserFmtUByte:
          if ( !len )
            return;
          v395.n128_u64[0] = 0x800000008000LL;
          v395.n128_u64[1] = 0x800000008000LL;
          v396 = 0;
          v397 = numchans & 0xFFFFFFF8;
          while ( 1 )
          {
            v398 = numchans;
            if ( numchans )
              break;
LABEL_582:
            if ( ++v396 == len )
              return;
          }
          v399 = 0;
          if ( (unsigned int)numchans < 8 )
          {
            v401 = v1687;
            v400 = v1688;
            v402 = v1687;
          }
          else
          {
            v401 = v1687;
            v400 = v1688;
            v402 = v1687;
            if ( v397 )
            {
              v403 = (int16x4_t *)v1688;
              if ( &v1687[numchans] <= (ALima4 *)v1688 || v1687 >= (ALima4 *)v1688 + 2 * numchans )
              {
                v402 = &v1687[v397];
                v400 = (int64x2_t *)((char *)v1688 + 2 * v397);
                v404 = numchans & 0xFFFFFFF8;
                v405 = (uint8x8_t *)v1687;
                do
                {
                  v406.n64_u64[0] = v405->n64_u64[0];
                  ++v405;
                  v404 -= 8;
                  v407 = vmovl_u8(v406);
                  v403->n64_u64[0] = vmovn_s32(vaddq_s32(vshll_n_u16((uint16x4_t)v407.n128_u64[0], 8u), v395)).n64_u64[0];
                  v403[1].n64_u64[0] = vmovn_s32(vaddq_s32(vshll_n_u16(*(uint16x4_t *)&v407.n128_i8[8], 8u), v395)).n64_u64[0];
                  v403 += 2;
                }
                while ( v404 );
                v398 = numchans;
                v399 = numchans & 0xFFFFFFF8;
                if ( v397 == numchans )
                  goto LABEL_581;
              }
              else
              {
                v400 = v1688;
                v399 = 0;
                v402 = v1687;
                v398 = numchans;
              }
            }
          }
          v408 = v398 - v399;
          do
          {
            v409 = *v402++;
            --v408;
            v400->n128_u16[0] = (v409 << 8) + 0x8000;
            v400 = (int64x2_t *)((char *)v400 + 2);
          }
          while ( v408 );
LABEL_581:
          v1688 = (int64x2_t *)((char *)v1688 + 2 * v398);
          v1687 = &v401[v398];
          goto LABEL_582;
        case UserFmtShort:
          if ( !len )
            return;
          v410 = 0;
          v411 = numchans & 0xFFFFFFF8;
          while ( 1 )
          {
            v419 = numchans;
            if ( numchans )
              break;
LABEL_602:
            if ( ++v410 == len )
              return;
          }
          v420 = 0;
          if ( (unsigned int)numchans < 8 )
          {
            v421 = v1688;
            v422 = v1687;
          }
          else
          {
            v421 = v1688;
            v422 = v1687;
            v413 = v1688;
            v412 = v1687;
            if ( !v411 )
              goto LABEL_599;
            v423 = &v1687[2 * numchans];
            v424 = v1688 >= (int64x2_t *)v423;
            if ( v1688 < (int64x2_t *)v423 )
              v424 = v1687 >= (ALima4 *)v1688 + 2 * numchans;
            if ( v424 )
            {
              v412 = &v1687[2 * v411];
              v413 = (int64x2_t *)((char *)v1688 + 2 * v411);
              v414 = numchans & 0xFFFFFFF8;
              v415 = v1688;
              v416 = v1687;
              do
              {
                v417 = *(_QWORD *)v416;
                v418 = *((_QWORD *)v416 + 1);
                v416 += 16;
                v414 -= 8;
                v415->n128_u64[0] = v417;
                v415->n128_u64[1] = v418;
                ++v415;
              }
              while ( v414 );
              v419 = numchans;
              v420 = numchans & 0xFFFFFFF8;
              if ( v411 == numchans )
                goto LABEL_601;
              goto LABEL_599;
            }
            v420 = 0;
          }
          v413 = v421;
          v412 = v422;
LABEL_599:
          v425 = v419 - v420;
          do
          {
            v426 = *(_WORD *)v412;
            v412 += 2;
            --v425;
            v413->n128_u16[0] = v426;
            v413 = (int64x2_t *)((char *)v413 + 2);
          }
          while ( v425 );
LABEL_601:
          v1688 = (int64x2_t *)((char *)v421 + 2 * v419);
          v1687 = &v422[2 * v419];
          goto LABEL_602;
        case UserFmtUShort:
          if ( !len )
            return;
          v427 = 0;
          v428 = numchans & 0xFFFFFFF8;
          while ( 1 )
          {
            v436 = numchans;
            if ( numchans )
              break;
LABEL_622:
            if ( ++v427 == len )
              return;
          }
          v437 = 0;
          if ( (unsigned int)numchans < 8 )
          {
            v438 = v1688;
            v439 = v1687;
          }
          else
          {
            v438 = v1688;
            v439 = v1687;
            v430 = v1688;
            v429 = v1687;
            if ( !v428 )
              goto LABEL_619;
            v440 = &v1687[2 * numchans];
            v441 = v1688 >= (int64x2_t *)v440;
            if ( v1688 < (int64x2_t *)v440 )
              v441 = v1687 >= (ALima4 *)v1688 + 2 * numchans;
            if ( v441 )
            {
              v429 = &v1687[2 * v428];
              v430 = (int64x2_t *)((char *)v1688 + 2 * v428);
              v431 = numchans & 0xFFFFFFF8;
              v432 = (unsigned __int64 *)v1688;
              v433 = v1687;
              do
              {
                v434 = *(_QWORD *)v433;
                v435 = *((_QWORD *)v433 + 1);
                v433 += 16;
                v431 -= 8;
                *v432 = v434 | 0x8000800080008000LL;
                v432[1] = v435 | 0x8000800080008000LL;
                v432 += 2;
              }
              while ( v431 );
              v436 = numchans;
              v437 = numchans & 0xFFFFFFF8;
              if ( v428 == numchans )
                goto LABEL_621;
              goto LABEL_619;
            }
            v437 = 0;
          }
          v430 = v438;
          v429 = v439;
LABEL_619:
          v442 = v436 - v437;
          do
          {
            v443 = *(_WORD *)v429;
            v429 += 2;
            --v442;
            v430->n128_u16[0] = v443 + 0x8000;
            v430 = (int64x2_t *)((char *)v430 + 2);
          }
          while ( v442 );
LABEL_621:
          v1688 = (int64x2_t *)((char *)v438 + 2 * v436);
          v1687 = &v439[2 * v436];
          goto LABEL_622;
        case UserFmtInt:
          if ( !len )
            return;
          v444 = 0;
          v445 = numchans & 0xFFFFFFFC;
          while ( 1 )
          {
            v452 = numchans;
            if ( numchans )
              break;
LABEL_642:
            if ( ++v444 == len )
              return;
          }
          v453 = 0;
          if ( (unsigned int)numchans < 4 )
          {
            v454 = v1688;
            v455 = v1687;
          }
          else
          {
            v454 = v1688;
            v455 = v1687;
            v447 = v1688;
            v446 = v1687;
            if ( !v445 )
              goto LABEL_639;
            v456 = &v1687[4 * numchans];
            v457 = v1688 >= (int64x2_t *)v456;
            if ( v1688 < (int64x2_t *)v456 )
              v457 = v1687 >= (ALima4 *)v1688 + 2 * numchans;
            if ( v457 )
            {
              v446 = &v1687[4 * v445];
              v447 = (int64x2_t *)((char *)v1688 + 2 * v445);
              v448 = numchans & 0xFFFFFFFC;
              v449 = (int16x4_t *)v1688;
              v450 = (int32x4_t *)v1687;
              do
              {
                v451 = *v450++;
                v448 -= 4;
                v449->n64_u64[0] = vshrn_n_s32(v451, 0x10u).n64_u64[0];
                ++v449;
              }
              while ( v448 );
              v452 = numchans;
              v453 = numchans & 0xFFFFFFFC;
              if ( v445 == numchans )
                goto LABEL_641;
              goto LABEL_639;
            }
            v453 = 0;
          }
          v447 = v454;
          v446 = v455;
LABEL_639:
          v458 = v452 - v453;
          do
          {
            --v458;
            v447->n128_u16[0] = *((_WORD *)v446 + 1);
            v447 = (int64x2_t *)((char *)v447 + 2);
            v446 += 4;
          }
          while ( v458 );
LABEL_641:
          v1688 = (int64x2_t *)((char *)v454 + 2 * v452);
          v1687 = &v455[4 * v452];
          goto LABEL_642;
        case UserFmtUInt:
          if ( !len )
            return;
          v459 = 0;
          v460 = numchans & 0xFFFFFFFC;
          while ( 1 )
          {
            v468 = numchans;
            if ( numchans )
              break;
LABEL_662:
            if ( ++v459 == len )
              return;
          }
          v469 = 0;
          if ( (unsigned int)numchans < 4 )
          {
            v470 = v1688;
            v471 = v1687;
          }
          else
          {
            v470 = v1688;
            v471 = v1687;
            v462 = v1688;
            v461 = v1687;
            if ( !v460 )
              goto LABEL_659;
            v472 = &v1687[4 * numchans];
            v473 = v1688 >= (int64x2_t *)v472;
            if ( v1688 < (int64x2_t *)v472 )
              v473 = v1687 >= (ALima4 *)v1688 + 2 * numchans;
            if ( v473 )
            {
              v461 = &v1687[4 * v460];
              v462 = (int64x2_t *)((char *)v1688 + 2 * v460);
              v463 = numchans & 0xFFFFFFFC;
              v464 = (int16x4_t *)v1688;
              v465 = (uint32x4_t *)v1687;
              do
              {
                v466 = *v465++;
                v467.n128_u64[0] = 0x800000008000LL;
                v467.n128_u64[1] = 0x800000008000LL;
                v463 -= 4;
                v464->n64_u64[0] = vmovn_s32(vsraq_n_u32(v467, v466, 0x10u)).n64_u64[0];
                ++v464;
              }
              while ( v463 );
              v468 = numchans;
              v469 = numchans & 0xFFFFFFFC;
              if ( v460 == numchans )
                goto LABEL_661;
              goto LABEL_659;
            }
            v469 = 0;
          }
          v462 = v470;
          v461 = v471;
LABEL_659:
          v474 = v468 - v469;
          do
          {
            v475 = *((_WORD *)v461 + 1);
            --v474;
            v461 += 4;
            v462->n128_u16[0] = v475 + 0x8000;
            v462 = (int64x2_t *)((char *)v462 + 2);
          }
          while ( v474 );
LABEL_661:
          v1688 = (int64x2_t *)((char *)v470 + 2 * v468);
          v1687 = &v471[4 * v468];
          goto LABEL_662;
        case UserFmtFloat:
          if ( len )
          {
            v476 = 0;
            do
            {
              v477 = numchans;
              if ( numchans )
              {
                v478 = len;
                v479 = v1688;
                v480 = (float *)v1687;
                do
                {
                  v481 = *v480++;
                  if ( v481 <= 1.0 )
                  {
                    if ( v481 >= -1.0 )
                      v482 = (int)(float)(v481 * 32767.0);
                    else
                      LOWORD(v482) = 0x8000;
                  }
                  else
                  {
                    LOWORD(v482) = 0x7FFF;
                  }
                  v479->n128_u16[0] = v482;
                  v479 = (int64x2_t *)((char *)v479 + 2);
                  --v477;
                }
                while ( v477 );
                v1688 = (int64x2_t *)((char *)v1688 + 2 * numchans);
                v1687 += 4 * numchans;
              }
              else
              {
                v478 = len;
              }
              ++v476;
            }
            while ( v476 != v478 );
          }
          return;
        case UserFmtDouble:
          if ( len )
          {
            v483 = 0;
            do
            {
              v484 = numchans;
              if ( numchans )
              {
                v485 = len;
                v486 = v1688;
                v487 = (double *)v1687;
                do
                {
                  v488 = *v487++;
                  if ( v488 <= 1.0 )
                  {
                    if ( v488 >= -1.0 )
                      v489 = (int)(v488 * 32767.0);
                    else
                      LOWORD(v489) = 0x8000;
                  }
                  else
                  {
                    LOWORD(v489) = 0x7FFF;
                  }
                  v486->n128_u16[0] = v489;
                  v486 = (int64x2_t *)((char *)v486 + 2);
                  --v484;
                }
                while ( v484 );
                v1688 = (int64x2_t *)((char *)v1688 + 2 * numchans);
                v1687 += 8 * numchans;
              }
              else
              {
                v485 = len;
              }
              ++v483;
            }
            while ( v483 != v485 );
          }
          return;
        case UserFmtByte3:
          if ( len )
          {
            v490 = 0;
            do
            {
              v491 = numchans;
              if ( numchans )
              {
                v492 = len;
                v493 = v1688;
                v494 = v1687;
                do
                {
                  v495 = v494[2];
                  --v491;
                  v496 = *(unsigned __int16 *)v494;
                  v494 += 3;
                  v493->n128_u16[0] = (v496 | (unsigned int)(v495 << 16)) >> 8;
                  v493 = (int64x2_t *)((char *)v493 + 2);
                }
                while ( v491 );
                v1688 = (int64x2_t *)((char *)v1688 + 2 * numchans);
                v1687 += 3 * numchans;
              }
              else
              {
                v492 = len;
              }
              ++v490;
            }
            while ( v490 != v492 );
          }
          return;
        case UserFmtUByte3:
          if ( len )
          {
            for ( k = 0; k != len; ++k )
            {
              v498 = numchans;
              if ( numchans )
              {
                v499 = v1688;
                v500 = v1687;
                do
                {
                  v501 = v500[2];
                  --v498;
                  v502 = *(unsigned __int16 *)v500;
                  v500 += 3;
                  v499->n128_u16[0] = ((v502 | (unsigned int)(v501 << 16)) >> 8) + 0x8000;
                  v499 = (int64x2_t *)((char *)v499 + 2);
                }
                while ( v498 );
                v1688 = (int64x2_t *)((char *)v1688 + 2 * numchans);
                v1687 += 3 * numchans;
              }
            }
          }
          return;
        case UserFmtMulaw:
          if ( len )
          {
            v503 = 0;
            do
            {
              v504 = numchans;
              if ( numchans )
              {
                v505 = len;
                v506 = v1688;
                v507 = v1687;
                do
                {
                  v508 = *v507++;
                  --v504;
                  v506->n128_u16[0] = muLawDecompressionTable[v508];
                  v506 = (int64x2_t *)((char *)v506 + 2);
                }
                while ( v504 );
                v1688 = (int64x2_t *)((char *)v1688 + 2 * numchans);
                v1687 += numchans;
              }
              else
              {
                v505 = len;
              }
              ++v503;
            }
            while ( v503 != v505 );
          }
          return;
        case UserFmtAlaw:
          if ( len )
          {
            v509 = 0;
            do
            {
              v510 = numchans;
              if ( numchans )
              {
                v511 = len;
                v512 = v1688;
                v513 = v1687;
                do
                {
                  v514 = *v513++;
                  --v510;
                  v512->n128_u16[0] = aLawDecompressionTable[v514];
                  v512 = (int64x2_t *)((char *)v512 + 2);
                }
                while ( v510 );
                v1688 = (int64x2_t *)((char *)v1688 + 2 * numchans);
                v1687 += numchans;
              }
              else
              {
                v511 = len;
              }
              ++v509;
            }
            while ( v509 != v511 );
          }
          return;
        case UserFmtIMA4:
          v515 = numchans;
          if ( !len )
            return;
          v516 = numchans & 0xFFFFFFF8;
          v517 = 0;
          while ( 1 )
          {
            DecodeIMA4Block(v1689, v1687, v515);
            v1687 += 36 * numchans;
            if ( v517 < len )
              break;
            v518 = v1688;
            v515 = numchans;
LABEL_748:
            v1688 = v518;
            if ( v517 >= len )
              return;
          }
          v518 = v1688;
          v515 = numchans;
          v519 = v1689;
          v520 = 0;
          break;
        default:
          return;
      }
      while ( 1 )
      {
        if ( !v515 )
          goto LABEL_744;
        v521 = 0;
        if ( v515 < 8 )
        {
          v522 = v518;
        }
        else
        {
          v522 = v518;
          if ( v516 )
          {
            v523 = &v1689[v515 + v520 * v515];
            v524 = v518 >= (int64x2_t *)v523;
            if ( v518 < (int64x2_t *)v523 )
              v524 = &v1689[v520 * v515] >= (ALshort *)v518 + v515;
            if ( v524 )
            {
              v522 = (int64x2_t *)((char *)v518 + 2 * v516);
              v525 = numchans & 0xFFFFFFF8;
              v526 = v519;
              v527 = v518;
              do
              {
                v528 = *(_QWORD *)v526;
                v529 = *((_QWORD *)v526 + 1);
                v526 += 8;
                v525 -= 8;
                v527->n128_u64[0] = v528;
                v527->n128_u64[1] = v529;
                ++v527;
              }
              while ( v525 );
              v515 = numchans;
              v521 = numchans & 0xFFFFFFF8;
              if ( v516 == numchans )
                goto LABEL_743;
            }
            else
            {
              v521 = 0;
              v522 = v518;
            }
          }
        }
        do
        {
          v530 = v519[v521++];
          v522->n128_u16[0] = v530;
          v522 = (int64x2_t *)((char *)v522 + 2);
        }
        while ( v515 != v521 );
LABEL_743:
        v518 = (int64x2_t *)((char *)v518 + 2 * v515);
LABEL_744:
        ++v520;
        ++v517;
        if ( v520 <= 0x40 )
        {
          v519 += numchans;
          if ( v517 < len )
            continue;
        }
        goto LABEL_748;
      }
    case UserFmtUShort:
      switch ( srcType )
      {
        case UserFmtByte:
          if ( !len )
            return;
          v15.n128_u64[0] = 0x800000008000LL;
          v15.n128_u64[1] = 0x800000008000LL;
          v16 = 0;
          v17 = numchans & 0xFFFFFFF8;
          while ( 1 )
          {
            v18 = numchans;
            if ( numchans )
              break;
LABEL_27:
            if ( ++v16 == len )
              return;
          }
          v19 = 0;
          if ( (unsigned int)numchans < 8 )
          {
            v21 = v1687;
            v20 = v1688;
            v22 = v1687;
          }
          else
          {
            v21 = v1687;
            v20 = v1688;
            v22 = v1687;
            if ( v17 )
            {
              v23 = (int16x4_t *)v1688;
              if ( &v1687[numchans] <= (ALima4 *)v1688 || v1687 >= (ALima4 *)v1688 + 2 * numchans )
              {
                v22 = &v1687[v17];
                v20 = (int64x2_t *)((char *)v1688 + 2 * v17);
                v24 = numchans & 0xFFFFFFF8;
                v25 = (int8x8_t *)v1687;
                do
                {
                  v26.n64_u64[0] = v25->n64_u64[0];
                  ++v25;
                  v24 -= 8;
                  v27 = vmovl_s8(v26);
                  v23->n64_u64[0] = vmovn_s32(vaddq_s32(vshll_n_s16((int16x4_t)v27.n128_u64[0], 8u), v15)).n64_u64[0];
                  v23[1].n64_u64[0] = vmovn_s32(vaddq_s32(vshll_n_s16(*(int16x4_t *)&v27.n128_i8[8], 8u), v15)).n64_u64[0];
                  v23 += 2;
                }
                while ( v24 );
                v18 = numchans;
                v19 = numchans & 0xFFFFFFF8;
                if ( v17 == numchans )
                  goto LABEL_26;
              }
              else
              {
                v20 = v1688;
                v19 = 0;
                v22 = v1687;
                v18 = numchans;
              }
            }
          }
          v28 = v18 - v19;
          do
          {
            v29 = *v22++;
            --v28;
            v20->n128_u16[0] = (v29 << 8) + 0x8000;
            v20 = (int64x2_t *)((char *)v20 + 2);
          }
          while ( v28 );
LABEL_26:
          v1688 = (int64x2_t *)((char *)v1688 + 2 * v18);
          v1687 = &v21[v18];
          goto LABEL_27;
        case UserFmtUByte:
          if ( !len )
            return;
          v531 = 0;
          v532 = numchans & 0xFFFFFFF8;
          while ( 1 )
          {
            v539 = numchans;
            if ( numchans )
              break;
LABEL_767:
            if ( ++v531 == len )
              return;
          }
          v540 = 0;
          if ( (unsigned int)numchans < 8 )
          {
            v541 = v1688;
            v542 = v1687;
          }
          else
          {
            v541 = v1688;
            v542 = v1687;
            v534 = v1688;
            v533 = v1687;
            if ( !v532 )
              goto LABEL_764;
            if ( &v1687[numchans] <= (ALima4 *)v1688 || v1687 >= (ALima4 *)v1688 + 2 * numchans )
            {
              v533 = &v1687[v532];
              v534 = (int64x2_t *)((char *)v1688 + 2 * v532);
              v535 = numchans & 0xFFFFFFF8;
              v536 = v1688;
              v537 = (int8x8_t *)v1687;
              do
              {
                v538.n64_u64[0] = v537->n64_u64[0];
                ++v537;
                v535 -= 8;
                *v536++ = vshll_n_s8(v538, 8u);
              }
              while ( v535 );
              v539 = numchans;
              v540 = numchans & 0xFFFFFFF8;
              if ( v532 == numchans )
                goto LABEL_766;
              goto LABEL_764;
            }
            v540 = 0;
          }
          v534 = v541;
          v533 = v542;
LABEL_764:
          v543 = v539 - v540;
          do
          {
            v544 = *v533++;
            --v543;
            v534->n128_u16[0] = v544 << 8;
            v534 = (int64x2_t *)((char *)v534 + 2);
          }
          while ( v543 );
LABEL_766:
          v1688 = (int64x2_t *)((char *)v541 + 2 * v539);
          v1687 = &v542[v539];
          goto LABEL_767;
        case UserFmtShort:
          if ( !len )
            return;
          v545 = 0;
          v546 = numchans & 0xFFFFFFF8;
          while ( 1 )
          {
            v554 = numchans;
            if ( numchans )
              break;
LABEL_787:
            if ( ++v545 == len )
              return;
          }
          v555 = 0;
          if ( (unsigned int)numchans < 8 )
          {
            v556 = v1688;
            v557 = v1687;
          }
          else
          {
            v556 = v1688;
            v557 = v1687;
            v548 = v1688;
            v547 = v1687;
            if ( !v546 )
              goto LABEL_784;
            v558 = &v1687[2 * numchans];
            v559 = v1688 >= (int64x2_t *)v558;
            if ( v1688 < (int64x2_t *)v558 )
              v559 = v1687 >= (ALima4 *)v1688 + 2 * numchans;
            if ( v559 )
            {
              v547 = &v1687[2 * v546];
              v548 = (int64x2_t *)((char *)v1688 + 2 * v546);
              v549 = numchans & 0xFFFFFFF8;
              v550 = (unsigned __int64 *)v1688;
              v551 = v1687;
              do
              {
                v552 = *(_QWORD *)v551;
                v553 = *((_QWORD *)v551 + 1);
                v551 += 16;
                v549 -= 8;
                *v550 = v552 | 0x8000800080008000LL;
                v550[1] = v553 | 0x8000800080008000LL;
                v550 += 2;
              }
              while ( v549 );
              v554 = numchans;
              v555 = numchans & 0xFFFFFFF8;
              if ( v546 == numchans )
                goto LABEL_786;
              goto LABEL_784;
            }
            v555 = 0;
          }
          v548 = v556;
          v547 = v557;
LABEL_784:
          v560 = v554 - v555;
          do
          {
            v561 = *(_WORD *)v547;
            v547 += 2;
            --v560;
            v548->n128_u16[0] = v561 + 0x8000;
            v548 = (int64x2_t *)((char *)v548 + 2);
          }
          while ( v560 );
LABEL_786:
          v1688 = (int64x2_t *)((char *)v556 + 2 * v554);
          v1687 = &v557[2 * v554];
          goto LABEL_787;
        case UserFmtUShort:
          if ( !len )
            return;
          v562 = 0;
          v563 = numchans & 0xFFFFFFF8;
          while ( 1 )
          {
            v571 = numchans;
            if ( numchans )
              break;
LABEL_807:
            if ( ++v562 == len )
              return;
          }
          v572 = 0;
          if ( (unsigned int)numchans < 8 )
          {
            v573 = v1688;
            v574 = v1687;
          }
          else
          {
            v573 = v1688;
            v574 = v1687;
            v565 = v1688;
            v564 = v1687;
            if ( !v563 )
              goto LABEL_804;
            v575 = &v1687[2 * numchans];
            v576 = v1688 >= (int64x2_t *)v575;
            if ( v1688 < (int64x2_t *)v575 )
              v576 = v1687 >= (ALima4 *)v1688 + 2 * numchans;
            if ( v576 )
            {
              v564 = &v1687[2 * v563];
              v565 = (int64x2_t *)((char *)v1688 + 2 * v563);
              v566 = numchans & 0xFFFFFFF8;
              v567 = v1688;
              v568 = v1687;
              do
              {
                v569 = *(_QWORD *)v568;
                v570 = *((_QWORD *)v568 + 1);
                v568 += 16;
                v566 -= 8;
                v567->n128_u64[0] = v569;
                v567->n128_u64[1] = v570;
                ++v567;
              }
              while ( v566 );
              v571 = numchans;
              v572 = numchans & 0xFFFFFFF8;
              if ( v563 == numchans )
                goto LABEL_806;
              goto LABEL_804;
            }
            v572 = 0;
          }
          v565 = v573;
          v564 = v574;
LABEL_804:
          v577 = v571 - v572;
          do
          {
            v578 = *(_WORD *)v564;
            v564 += 2;
            --v577;
            v565->n128_u16[0] = v578;
            v565 = (int64x2_t *)((char *)v565 + 2);
          }
          while ( v577 );
LABEL_806:
          v1688 = (int64x2_t *)((char *)v573 + 2 * v571);
          v1687 = &v574[2 * v571];
          goto LABEL_807;
        case UserFmtInt:
          if ( !len )
            return;
          v579 = 0;
          v580 = numchans & 0xFFFFFFFC;
          while ( 1 )
          {
            v588 = numchans;
            if ( numchans )
              break;
LABEL_827:
            if ( ++v579 == len )
              return;
          }
          v589 = 0;
          if ( (unsigned int)numchans < 4 )
          {
            v590 = v1688;
            v591 = v1687;
          }
          else
          {
            v590 = v1688;
            v591 = v1687;
            v582 = v1688;
            v581 = v1687;
            if ( !v580 )
              goto LABEL_824;
            v592 = &v1687[4 * numchans];
            v593 = v1688 >= (int64x2_t *)v592;
            if ( v1688 < (int64x2_t *)v592 )
              v593 = v1687 >= (ALima4 *)v1688 + 2 * numchans;
            if ( v593 )
            {
              v581 = &v1687[4 * v580];
              v582 = (int64x2_t *)((char *)v1688 + 2 * v580);
              v583 = numchans & 0xFFFFFFFC;
              v584 = (int16x4_t *)v1688;
              v585 = (uint32x4_t *)v1687;
              do
              {
                v586 = *v585++;
                v587.n128_u64[0] = 0x800000008000LL;
                v587.n128_u64[1] = 0x800000008000LL;
                v583 -= 4;
                v584->n64_u64[0] = vmovn_s32(vsraq_n_u32(v587, v586, 0x10u)).n64_u64[0];
                ++v584;
              }
              while ( v583 );
              v588 = numchans;
              v589 = numchans & 0xFFFFFFFC;
              if ( v580 == numchans )
                goto LABEL_826;
              goto LABEL_824;
            }
            v589 = 0;
          }
          v582 = v590;
          v581 = v591;
LABEL_824:
          v594 = v588 - v589;
          do
          {
            v595 = *((_WORD *)v581 + 1);
            --v594;
            v581 += 4;
            v582->n128_u16[0] = v595 + 0x8000;
            v582 = (int64x2_t *)((char *)v582 + 2);
          }
          while ( v594 );
LABEL_826:
          v1688 = (int64x2_t *)((char *)v590 + 2 * v588);
          v1687 = &v591[4 * v588];
          goto LABEL_827;
        case UserFmtUInt:
          if ( !len )
            return;
          v596 = 0;
          v597 = numchans & 0xFFFFFFFC;
          while ( 1 )
          {
            v604 = numchans;
            if ( numchans )
              break;
LABEL_847:
            if ( ++v596 == len )
              return;
          }
          v605 = 0;
          if ( (unsigned int)numchans < 4 )
          {
            v606 = v1688;
            v607 = v1687;
          }
          else
          {
            v606 = v1688;
            v607 = v1687;
            v599 = v1688;
            v598 = v1687;
            if ( !v597 )
              goto LABEL_844;
            v608 = &v1687[4 * numchans];
            v609 = v1688 >= (int64x2_t *)v608;
            if ( v1688 < (int64x2_t *)v608 )
              v609 = v1687 >= (ALima4 *)v1688 + 2 * numchans;
            if ( v609 )
            {
              v598 = &v1687[4 * v597];
              v599 = (int64x2_t *)((char *)v1688 + 2 * v597);
              v600 = numchans & 0xFFFFFFFC;
              v601 = (int16x4_t *)v1688;
              v602 = (int32x4_t *)v1687;
              do
              {
                v603 = *v602++;
                v600 -= 4;
                v601->n64_u64[0] = vshrn_n_s32(v603, 0x10u).n64_u64[0];
                ++v601;
              }
              while ( v600 );
              v604 = numchans;
              v605 = numchans & 0xFFFFFFFC;
              if ( v597 == numchans )
                goto LABEL_846;
              goto LABEL_844;
            }
            v605 = 0;
          }
          v599 = v606;
          v598 = v607;
LABEL_844:
          v610 = v604 - v605;
          do
          {
            --v610;
            v599->n128_u16[0] = *((_WORD *)v598 + 1);
            v599 = (int64x2_t *)((char *)v599 + 2);
            v598 += 4;
          }
          while ( v610 );
LABEL_846:
          v1688 = (int64x2_t *)((char *)v606 + 2 * v604);
          v1687 = &v607[4 * v604];
          goto LABEL_847;
        case UserFmtFloat:
          if ( len )
          {
            v611 = 0;
            do
            {
              v612 = numchans;
              if ( numchans )
              {
                v613 = len;
                v614 = v1688;
                v615 = (float *)v1687;
                do
                {
                  v616 = *v615++;
                  LOWORD(v617) = -1;
                  if ( v616 <= 1.0 )
                  {
                    if ( v616 >= -1.0 )
                      v617 = (int)(float)(v616 * 32767.0) + 0x8000;
                    else
                      LOWORD(v617) = 0;
                  }
                  v614->n128_u16[0] = v617;
                  v614 = (int64x2_t *)((char *)v614 + 2);
                  --v612;
                }
                while ( v612 );
                v1688 = (int64x2_t *)((char *)v1688 + 2 * numchans);
                v1687 += 4 * numchans;
              }
              else
              {
                v613 = len;
              }
              ++v611;
            }
            while ( v611 != v613 );
          }
          return;
        case UserFmtDouble:
          if ( len )
          {
            v618 = 0;
            do
            {
              v619 = numchans;
              if ( numchans )
              {
                v620 = len;
                v621 = v1688;
                v622 = (double *)v1687;
                do
                {
                  v623 = *v622++;
                  LOWORD(v624) = -1;
                  if ( v623 <= 1.0 )
                  {
                    if ( v623 >= -1.0 )
                      v624 = (int)(v623 * 32767.0) + 0x8000;
                    else
                      LOWORD(v624) = 0;
                  }
                  v621->n128_u16[0] = v624;
                  v621 = (int64x2_t *)((char *)v621 + 2);
                  --v619;
                }
                while ( v619 );
                v1688 = (int64x2_t *)((char *)v1688 + 2 * numchans);
                v1687 += 8 * numchans;
              }
              else
              {
                v620 = len;
              }
              ++v618;
            }
            while ( v618 != v620 );
          }
          return;
        case UserFmtByte3:
          if ( len )
          {
            for ( m = 0; m != len; ++m )
            {
              if ( numchans )
              {
                v626 = v1688;
                v627 = numchans;
                v628 = v1687;
                do
                {
                  v629 = v628[2];
                  --v627;
                  v630 = *(unsigned __int16 *)v628;
                  v628 += 3;
                  v626->n128_u16[0] = (((v630 | (v629 << 16)) & 0xFFFF00u) >> 8) + 0x8000;
                  v626 = (int64x2_t *)((char *)v626 + 2);
                }
                while ( v627 );
                v1688 = (int64x2_t *)((char *)v1688 + 2 * numchans);
                v1687 += 3 * numchans;
              }
            }
          }
          return;
        case UserFmtUByte3:
          if ( len )
          {
            v631 = 0;
            do
            {
              v632 = numchans;
              if ( numchans )
              {
                v633 = len;
                v634 = v1688;
                v635 = v1687;
                do
                {
                  v636 = v635[2];
                  --v632;
                  v637 = *(unsigned __int16 *)v635;
                  v635 += 3;
                  v634->n128_u16[0] = (v637 | (unsigned int)(v636 << 16)) >> 8;
                  v634 = (int64x2_t *)((char *)v634 + 2);
                }
                while ( v632 );
                v1688 = (int64x2_t *)((char *)v1688 + 2 * numchans);
                v1687 += 3 * numchans;
              }
              else
              {
                v633 = len;
              }
              ++v631;
            }
            while ( v631 != v633 );
          }
          return;
        case UserFmtMulaw:
          if ( len )
          {
            v638 = 0;
            do
            {
              v639 = numchans;
              if ( numchans )
              {
                v640 = len;
                v641 = v1688;
                v642 = v1687;
                do
                {
                  v643 = *v642++;
                  --v639;
                  v641->n128_u16[0] = muLawDecompressionTable[v643] + 0x8000;
                  v641 = (int64x2_t *)((char *)v641 + 2);
                }
                while ( v639 );
                v1688 = (int64x2_t *)((char *)v1688 + 2 * numchans);
                v1687 += numchans;
              }
              else
              {
                v640 = len;
              }
              ++v638;
            }
            while ( v638 != v640 );
          }
          return;
        case UserFmtAlaw:
          if ( len )
          {
            v644 = 0;
            do
            {
              v645 = numchans;
              if ( numchans )
              {
                v646 = len;
                v647 = v1688;
                v648 = v1687;
                do
                {
                  v649 = *v648++;
                  --v645;
                  v647->n128_u16[0] = aLawDecompressionTable[v649] + 0x8000;
                  v647 = (int64x2_t *)((char *)v647 + 2);
                }
                while ( v645 );
                v1688 = (int64x2_t *)((char *)v1688 + 2 * numchans);
                v1687 += numchans;
              }
              else
              {
                v646 = len;
              }
              ++v644;
            }
            while ( v644 != v646 );
          }
          return;
        case UserFmtIMA4:
          v650 = numchans;
          if ( !len )
            return;
          v651 = numchans & 0xFFFFFFF8;
          v652 = 0;
          while ( 1 )
          {
            DecodeIMA4Block(v1689, v1687, v650);
            v1687 += 36 * numchans;
            if ( v652 < len )
              break;
            v653 = v1688;
LABEL_931:
            v1688 = v653;
            v650 = numchans;
            if ( v652 >= len )
              return;
          }
          v653 = v1688;
          v654 = v1689;
          v655 = 0;
          break;
        default:
          return;
      }
      while ( 1 )
      {
        if ( !numchans )
          goto LABEL_927;
        v656 = 0;
        if ( (unsigned int)numchans < 8 )
        {
          v658 = v653;
          v657 = numchans;
        }
        else
        {
          v657 = numchans;
          v658 = v653;
          if ( v651 )
          {
            v659 = &v1689[numchans + v655 * numchans];
            v660 = v653 >= (int64x2_t *)v659;
            if ( v653 < (int64x2_t *)v659 )
              v660 = &v1689[v655 * numchans] >= (ALshort *)v653 + numchans;
            if ( v660 )
            {
              v658 = (int64x2_t *)((char *)v653 + 2 * v651);
              v661 = numchans & 0xFFFFFFF8;
              v662 = v654;
              v663 = (unsigned __int64 *)v653;
              do
              {
                v664 = *(_QWORD *)v662;
                v665 = *((_QWORD *)v662 + 1);
                v662 += 8;
                v661 -= 8;
                *v663 = v664 | 0x8000800080008000LL;
                v663[1] = v665 | 0x8000800080008000LL;
                v663 += 2;
              }
              while ( v661 );
              v657 = numchans;
              v656 = numchans & 0xFFFFFFF8;
              if ( v651 == numchans )
                goto LABEL_926;
            }
            else
            {
              v656 = 0;
              v658 = v653;
            }
          }
        }
        do
        {
          v666 = v654[v656++];
          v658->n128_u16[0] = v666 + 0x8000;
          v658 = (int64x2_t *)((char *)v658 + 2);
        }
        while ( v657 != v656 );
LABEL_926:
        v653 = (int64x2_t *)((char *)v653 + 2 * v657);
LABEL_927:
        ++v655;
        ++v652;
        if ( v655 <= 0x40 )
        {
          v654 += numchans;
          if ( v652 < len )
            continue;
        }
        goto LABEL_931;
      }
    case UserFmtInt:
      switch ( srcType )
      {
        case UserFmtByte:
          if ( !len )
            return;
          v30 = 0;
          v31 = numchans & 0xFFFFFFFC;
          while ( 1 )
          {
            v32 = numchans;
            if ( numchans )
              break;
LABEL_45:
            if ( ++v30 == len )
              return;
          }
          v33 = 0;
          if ( (unsigned int)numchans < 4 )
          {
            v35 = v1687;
            v34 = v1688;
            v36 = v1687;
          }
          else
          {
            v35 = v1687;
            v34 = v1688;
            v36 = v1687;
            if ( v31 )
            {
              if ( &v1687[numchans] <= (ALima4 *)v1688 || v1687 >= (ALima4 *)v1688 + 4 * numchans )
              {
                v36 = &v1687[v31];
                v34 = (int64x2_t *)((char *)v1688 + 4 * v31);
                v37 = numchans & 0xFFFFFFFC;
                v38 = v1688;
                v39 = v1687;
                do
                {
                  v40 = *(_DWORD *)v39;
                  v39 += 4;
                  v37 -= 4;
                  v6.n128_u32[0] = v40;
                  v6 = vshlq_n_s32(vmovl_u16((uint16x4_t)vmovl_u8((uint8x8_t)v6.n128_u64[0]).n128_u64[0]), 0x18u);
                  *v38++ = v6;
                }
                while ( v37 );
                v32 = numchans;
                v33 = numchans & 0xFFFFFFFC;
                if ( v31 == numchans )
                  goto LABEL_44;
              }
              else
              {
                v33 = 0;
                v34 = v1688;
                v36 = v1687;
              }
            }
          }
          v41 = v32 - v33;
          do
          {
            v42 = *v36++;
            --v41;
            v34->n128_u32[0] = v42 << 24;
            v34 = (int64x2_t *)((char *)v34 + 4);
          }
          while ( v41 );
LABEL_44:
          v1688 = (int64x2_t *)((char *)v1688 + 4 * v32);
          v1687 = &v35[v32];
          goto LABEL_45;
        case UserFmtUByte:
          if ( !len )
            return;
          v667.n128_u64[0] = 0x8000000080000000LL;
          v667.n128_u64[1] = 0x8000000080000000LL;
          v668 = 0;
          v669 = numchans & 0xFFFFFFFC;
          while ( 1 )
          {
            v670 = numchans;
            if ( numchans )
              break;
LABEL_948:
            if ( ++v668 == len )
              return;
          }
          v671 = 0;
          if ( (unsigned int)numchans < 4 )
          {
            v673 = v1687;
            v672 = (unsigned int *)v1688;
            v674 = v1687;
          }
          else
          {
            v673 = v1687;
            v672 = (unsigned int *)v1688;
            v674 = v1687;
            if ( v669 )
            {
              if ( &v1687[numchans] <= (ALima4 *)v1688 || v1687 >= (ALima4 *)v1688 + 4 * numchans )
              {
                v674 = &v1687[v669];
                v672 = (unsigned int *)v1688 + v669;
                v675 = numchans & 0xFFFFFFFC;
                v676 = v1688;
                v677 = v1687;
                do
                {
                  v678 = *(_DWORD *)v677;
                  v677 += 4;
                  v675 -= 4;
                  v7.n128_u32[0] = v678;
                  v7 = veorq_s64(
                         vshlq_n_s32(vmovl_u16((uint16x4_t)vmovl_u8((uint8x8_t)v7.n128_u64[0]).n128_u64[0]), 0x18u),
                         v667);
                  *v676++ = v7;
                }
                while ( v675 );
                v670 = numchans;
                v671 = numchans & 0xFFFFFFFC;
                if ( v669 == numchans )
                  goto LABEL_947;
              }
              else
              {
                v671 = 0;
                v672 = (unsigned int *)v1688;
                v674 = v1687;
              }
            }
          }
          v679 = v670 - v671;
          do
          {
            v680 = *v674++;
            --v679;
            *v672++ = (v680 << 24) ^ 0x80000000;
          }
          while ( v679 );
LABEL_947:
          v1688 = (int64x2_t *)((char *)v1688 + 4 * v670);
          v1687 = &v673[v670];
          goto LABEL_948;
        case UserFmtShort:
          if ( !len )
            return;
          v681 = 0;
          v682 = numchans & 0xFFFFFFFC;
          while ( 1 )
          {
            v689 = numchans;
            if ( numchans )
              break;
LABEL_968:
            if ( ++v681 == len )
              return;
          }
          v690 = 0;
          if ( (unsigned int)numchans < 4 )
          {
            v691 = v1688;
            v692 = v1687;
          }
          else
          {
            v691 = v1688;
            v692 = v1687;
            v684 = v1688;
            v683 = v1687;
            if ( !v682 )
              goto LABEL_965;
            v693 = &v1687[2 * numchans];
            v694 = v1688 >= (int64x2_t *)v693;
            if ( v1688 < (int64x2_t *)v693 )
              v694 = v1687 >= (ALima4 *)v1688 + 4 * numchans;
            if ( v694 )
            {
              v683 = &v1687[2 * v682];
              v684 = (int64x2_t *)((char *)v1688 + 4 * v682);
              v685 = numchans & 0xFFFFFFFC;
              v686 = v1688;
              v687 = (int16x4_t *)v1687;
              do
              {
                v688.n64_u64[0] = v687->n64_u64[0];
                ++v687;
                v685 -= 4;
                *v686++ = vshll_n_s16(v688, 0x10u);
              }
              while ( v685 );
              v689 = numchans;
              v690 = numchans & 0xFFFFFFFC;
              if ( v682 == numchans )
                goto LABEL_967;
              goto LABEL_965;
            }
            v690 = 0;
          }
          v684 = v691;
          v683 = v692;
LABEL_965:
          v695 = v689 - v690;
          do
          {
            v696 = *(unsigned __int16 *)v683;
            v683 += 2;
            --v695;
            v684->n128_u32[0] = v696 << 16;
            v684 = (int64x2_t *)((char *)v684 + 4);
          }
          while ( v695 );
LABEL_967:
          v1688 = (int64x2_t *)((char *)v691 + 4 * v689);
          v1687 = &v692[2 * v689];
          goto LABEL_968;
        case UserFmtUShort:
          if ( !len )
            return;
          v697.n128_u64[0] = 0x8000000080000000LL;
          v697.n128_u64[1] = 0x8000000080000000LL;
          v698 = 0;
          v699 = numchans & 0xFFFFFFFC;
          while ( 1 )
          {
            v700 = numchans;
            if ( numchans )
              break;
LABEL_986:
            if ( ++v698 == len )
              return;
          }
          v701 = 0;
          if ( (unsigned int)numchans < 4 )
          {
            v703 = v1687;
            v702 = (unsigned int *)v1688;
            v704 = v1687;
          }
          else
          {
            v703 = v1687;
            v702 = (unsigned int *)v1688;
            v704 = v1687;
            if ( v699 )
            {
              v705 = &v1687[2 * numchans];
              v706 = v1688;
              v707 = v1688 >= (int64x2_t *)v705;
              if ( v1688 < (int64x2_t *)v705 )
                v707 = v1687 >= (ALima4 *)v1688 + 4 * numchans;
              if ( v707 )
              {
                v704 = &v1687[2 * v699];
                v702 = (unsigned int *)v1688 + v699;
                v708 = numchans & 0xFFFFFFFC;
                v709 = (int16x4_t *)v1687;
                do
                {
                  v710.n64_u64[0] = v709->n64_u64[0];
                  ++v709;
                  v708 -= 4;
                  *v706++ = veorq_s64(vshll_n_s16(v710, 0x10u), v697);
                }
                while ( v708 );
                v700 = numchans;
                v701 = numchans & 0xFFFFFFFC;
                if ( v699 == numchans )
                  goto LABEL_985;
              }
              else
              {
                v702 = (unsigned int *)v1688;
                v701 = 0;
                v704 = v1687;
                v700 = numchans;
              }
            }
          }
          v711 = v700 - v701;
          do
          {
            v712 = *(unsigned __int16 *)v704;
            v704 += 2;
            --v711;
            *v702++ = (v712 << 16) ^ 0x80000000;
          }
          while ( v711 );
LABEL_985:
          v1688 = (int64x2_t *)((char *)v1688 + 4 * v700);
          v1687 = &v703[2 * v700];
          goto LABEL_986;
        case UserFmtInt:
          if ( !len )
            return;
          v713 = 0;
          v714 = numchans & 0xFFFFFFFC;
          while ( 1 )
          {
            v722 = numchans;
            if ( numchans )
              break;
LABEL_1006:
            if ( ++v713 == len )
              return;
          }
          v723 = 0;
          if ( (unsigned int)numchans < 4 )
          {
            v724 = v1688;
            v725 = v1687;
          }
          else
          {
            v724 = v1688;
            v725 = v1687;
            v716 = v1688;
            v715 = v1687;
            if ( !v714 )
              goto LABEL_1003;
            v726 = &v1687[4 * numchans];
            v727 = v1688 >= (int64x2_t *)v726;
            if ( v1688 < (int64x2_t *)v726 )
              v727 = v1687 >= (ALima4 *)v1688 + 4 * numchans;
            if ( v727 )
            {
              v715 = &v1687[4 * v714];
              v716 = (int64x2_t *)((char *)v1688 + 4 * v714);
              v717 = numchans & 0xFFFFFFFC;
              v718 = v1688;
              v719 = v1687;
              do
              {
                v720 = *(_QWORD *)v719;
                v721 = *((_QWORD *)v719 + 1);
                v719 += 16;
                v717 -= 4;
                v718->n128_u64[0] = v720;
                v718->n128_u64[1] = v721;
                ++v718;
              }
              while ( v717 );
              v722 = numchans;
              v723 = numchans & 0xFFFFFFFC;
              if ( v714 == numchans )
                goto LABEL_1005;
              goto LABEL_1003;
            }
            v723 = 0;
          }
          v716 = v724;
          v715 = v725;
LABEL_1003:
          v728 = v722 - v723;
          do
          {
            v729 = *(_DWORD *)v715;
            v715 += 4;
            --v728;
            v716->n128_u32[0] = v729;
            v716 = (int64x2_t *)((char *)v716 + 4);
          }
          while ( v728 );
LABEL_1005:
          v1688 = (int64x2_t *)((char *)v724 + 4 * v722);
          v1687 = &v725[4 * v722];
          goto LABEL_1006;
        case UserFmtUInt:
          if ( !len )
            return;
          v730.n128_u64[0] = 0x8000000080000000LL;
          v730.n128_u64[1] = 0x8000000080000000LL;
          v731 = 0;
          v732 = numchans & 0xFFFFFFFC;
          while ( 1 )
          {
            v739 = numchans;
            if ( numchans )
              break;
LABEL_1026:
            if ( ++v731 == len )
              return;
          }
          v740 = 0;
          if ( (unsigned int)numchans < 4 )
          {
            v741 = v1688;
            v742 = v1687;
          }
          else
          {
            v741 = v1688;
            v742 = v1687;
            v734 = (unsigned int *)v1688;
            v733 = v1687;
            if ( !v732 )
              goto LABEL_1023;
            v743 = &v1687[4 * numchans];
            v744 = v1688 >= (int64x2_t *)v743;
            if ( v1688 < (int64x2_t *)v743 )
              v744 = v1687 >= (ALima4 *)v1688 + 4 * numchans;
            if ( v744 )
            {
              v733 = &v1687[4 * v732];
              v734 = (unsigned int *)v1688 + v732;
              v735 = numchans & 0xFFFFFFFC;
              v736 = v1688;
              v737 = (int64x2_t *)v1687;
              do
              {
                v738 = *v737++;
                v735 -= 4;
                *v736++ = veorq_s64(v738, v730);
              }
              while ( v735 );
              v739 = numchans;
              v740 = numchans & 0xFFFFFFFC;
              if ( v732 == numchans )
                goto LABEL_1025;
              goto LABEL_1023;
            }
            v740 = 0;
          }
          v734 = (unsigned int *)v741;
          v733 = v742;
LABEL_1023:
          v745 = v739 - v740;
          do
          {
            v746 = *(_DWORD *)v733;
            v733 += 4;
            --v745;
            *v734++ = v746 ^ 0x80000000;
          }
          while ( v745 );
LABEL_1025:
          v1688 = (int64x2_t *)((char *)v741 + 4 * v739);
          v1687 = &v742[4 * v739];
          goto LABEL_1026;
        case UserFmtFloat:
          if ( len )
          {
            v747 = 0;
            do
            {
              v748 = numchans;
              if ( numchans )
              {
                v749 = len;
                v750 = (int *)v1688;
                v751 = (float *)v1687;
                do
                {
                  v752 = *v751++;
                  if ( v752 <= 1.0 )
                  {
                    if ( v752 >= -1.0 )
                      v753 = (int)(v752 * 2147483650.0);
                    else
                      v753 = 0x80000000;
                  }
                  else
                  {
                    v753 = 0x7FFFFFFF;
                  }
                  *v750++ = v753;
                  --v748;
                }
                while ( v748 );
                v1688 = (int64x2_t *)((char *)v1688 + 4 * numchans);
                v1687 += 4 * numchans;
              }
              else
              {
                v749 = len;
              }
              ++v747;
            }
            while ( v747 != v749 );
          }
          return;
        case UserFmtDouble:
          if ( len )
          {
            v754 = 0;
            do
            {
              v755 = numchans;
              if ( numchans )
              {
                v756 = len;
                v757 = (int *)v1688;
                v758 = (double *)v1687;
                do
                {
                  v759 = *v758++;
                  if ( v759 <= 1.0 )
                  {
                    if ( v759 >= -1.0 )
                      v760 = (int)(v759 * 2147483650.0);
                    else
                      v760 = 0x80000000;
                  }
                  else
                  {
                    v760 = 0x7FFFFFFF;
                  }
                  *v757++ = v760;
                  --v755;
                }
                while ( v755 );
                v1688 = (int64x2_t *)((char *)v1688 + 4 * numchans);
                v1687 += 8 * numchans;
              }
              else
              {
                v756 = len;
              }
              ++v754;
            }
            while ( v754 != v756 );
          }
          return;
        case UserFmtByte3:
          if ( len )
          {
            v761 = 0;
            do
            {
              v762 = numchans;
              if ( numchans )
              {
                v763 = len;
                v764 = v1688;
                v765 = v1687;
                do
                {
                  v766 = v765[2];
                  --v762;
                  v767 = *(unsigned __int16 *)v765;
                  v765 += 3;
                  v764->n128_u32[0] = (v767 | (v766 << 16)) << 8;
                  v764 = (int64x2_t *)((char *)v764 + 4);
                }
                while ( v762 );
                v1688 = (int64x2_t *)((char *)v1688 + 4 * numchans);
                v1687 += 3 * numchans;
              }
              else
              {
                v763 = len;
              }
              ++v761;
            }
            while ( v761 != v763 );
          }
          return;
        case UserFmtUByte3:
          if ( len )
          {
            for ( n = 0; n != len; ++n )
            {
              v769 = numchans;
              if ( numchans )
              {
                v770 = (unsigned int *)v1688;
                v771 = v1687;
                do
                {
                  v772 = v771[2];
                  --v769;
                  v773 = *(unsigned __int16 *)v771;
                  v771 += 3;
                  *v770++ = ((v773 | (v772 << 16)) << 8) ^ 0x80000000;
                }
                while ( v769 );
                v1688 = (int64x2_t *)((char *)v1688 + 4 * numchans);
                v1687 += 3 * numchans;
              }
            }
          }
          return;
        case UserFmtMulaw:
          if ( len )
          {
            v774 = 0;
            do
            {
              v775 = numchans;
              if ( numchans )
              {
                v776 = len;
                v777 = v1688;
                v778 = v1687;
                do
                {
                  v779 = *v778++;
                  --v775;
                  v777->n128_u32[0] = (unsigned __int16)muLawDecompressionTable[v779] << 16;
                  v777 = (int64x2_t *)((char *)v777 + 4);
                }
                while ( v775 );
                v1688 = (int64x2_t *)((char *)v1688 + 4 * numchans);
                v1687 += numchans;
              }
              else
              {
                v776 = len;
              }
              ++v774;
            }
            while ( v774 != v776 );
          }
          return;
        case UserFmtAlaw:
          if ( len )
          {
            v780 = 0;
            do
            {
              v781 = numchans;
              if ( numchans )
              {
                v782 = len;
                v783 = v1688;
                v784 = v1687;
                do
                {
                  v785 = *v784++;
                  --v781;
                  v783->n128_u32[0] = (unsigned __int16)aLawDecompressionTable[v785] << 16;
                  v783 = (int64x2_t *)((char *)v783 + 4);
                }
                while ( v781 );
                v1688 = (int64x2_t *)((char *)v1688 + 4 * numchans);
                v1687 += numchans;
              }
              else
              {
                v782 = len;
              }
              ++v780;
            }
            while ( v780 != v782 );
          }
          return;
        case UserFmtIMA4:
          v786 = numchans;
          if ( !len )
            return;
          v787 = numchans & 0xFFFFFFFC;
          v788 = 0;
          while ( 1 )
          {
            DecodeIMA4Block(v1689, v1687, v786);
            v1687 += 36 * numchans;
            if ( v788 < len )
              break;
            v789 = v1688;
            v786 = numchans;
LABEL_1112:
            v1688 = v789;
            if ( v788 >= len )
              return;
          }
          v789 = v1688;
          v786 = numchans;
          v790 = v1689;
          v791 = 0;
          break;
        default:
          return;
      }
      while ( 1 )
      {
        if ( !v786 )
          goto LABEL_1108;
        v792 = 0;
        if ( v786 < 4 )
        {
          v793 = v789;
        }
        else
        {
          v793 = v789;
          if ( v787 )
          {
            v794 = &v1689[v786 + v791 * v786];
            v795 = v789 >= (int64x2_t *)v794;
            if ( v789 < (int64x2_t *)v794 )
              v795 = &v1689[v791 * v786] >= (ALshort *)v789 + 2 * v786;
            if ( v795 )
            {
              v793 = (int64x2_t *)((char *)v789 + 4 * v787);
              v796 = numchans & 0xFFFFFFFC;
              v797 = (int16x4_t *)v790;
              v798 = v789;
              do
              {
                v799.n64_u64[0] = v797->n64_u64[0];
                ++v797;
                v796 -= 4;
                *v798++ = vshll_n_s16(v799, 0x10u);
              }
              while ( v796 );
              v786 = numchans;
              v792 = numchans & 0xFFFFFFFC;
              if ( v787 == numchans )
                goto LABEL_1107;
            }
            else
            {
              v792 = 0;
              v793 = v789;
            }
          }
        }
        do
        {
          v800 = (unsigned __int16)v790[v792++];
          v793->n128_u32[0] = v800 << 16;
          v793 = (int64x2_t *)((char *)v793 + 4);
        }
        while ( v786 != v792 );
LABEL_1107:
        v789 = (int64x2_t *)((char *)v789 + 4 * v786);
LABEL_1108:
        ++v791;
        ++v788;
        if ( v791 <= 0x40 )
        {
          v790 += numchans;
          if ( v788 < len )
            continue;
        }
        goto LABEL_1112;
      }
    case UserFmtUInt:
      switch ( srcType )
      {
        case UserFmtByte:
          if ( !len )
            return;
          v43.n128_u64[0] = 0x8000000080000000LL;
          v43.n128_u64[1] = 0x8000000080000000LL;
          v44 = 0;
          v45 = numchans & 0xFFFFFFFC;
          while ( 1 )
          {
            v46 = numchans;
            if ( numchans )
              break;
LABEL_63:
            if ( ++v44 == len )
              return;
          }
          v47 = 0;
          if ( (unsigned int)numchans < 4 )
          {
            v49 = v1687;
            v48 = (unsigned int *)v1688;
            v50 = v1687;
          }
          else
          {
            v49 = v1687;
            v48 = (unsigned int *)v1688;
            v50 = v1687;
            if ( v45 )
            {
              if ( &v1687[numchans] <= (ALima4 *)v1688 || v1687 >= (ALima4 *)v1688 + 4 * numchans )
              {
                v50 = &v1687[v45];
                v48 = (unsigned int *)v1688 + v45;
                v51 = numchans & 0xFFFFFFFC;
                v52 = v1688;
                v53 = v1687;
                do
                {
                  v54 = *(_DWORD *)v53;
                  v53 += 4;
                  v51 -= 4;
                  v7.n128_u32[0] = v54;
                  v7 = veorq_s64(
                         vshlq_n_s32(vmovl_u16((uint16x4_t)vmovl_u8((uint8x8_t)v7.n128_u64[0]).n128_u64[0]), 0x18u),
                         v43);
                  *v52++ = v7;
                }
                while ( v51 );
                v46 = numchans;
                v47 = numchans & 0xFFFFFFFC;
                if ( v45 == numchans )
                  goto LABEL_62;
              }
              else
              {
                v47 = 0;
                v48 = (unsigned int *)v1688;
                v50 = v1687;
              }
            }
          }
          v55 = v46 - v47;
          do
          {
            v56 = *v50++;
            --v55;
            *v48++ = (v56 << 24) ^ 0x80000000;
          }
          while ( v55 );
LABEL_62:
          v1688 = (int64x2_t *)((char *)v1688 + 4 * v46);
          v1687 = &v49[v46];
          goto LABEL_63;
        case UserFmtUByte:
          if ( !len )
            return;
          v801 = 0;
          v802 = numchans & 0xFFFFFFFC;
          while ( 1 )
          {
            v803 = numchans;
            if ( numchans )
              break;
LABEL_1129:
            if ( ++v801 == len )
              return;
          }
          v804 = 0;
          if ( (unsigned int)numchans < 4 )
          {
            v806 = v1687;
            v805 = v1688;
            v807 = v1687;
          }
          else
          {
            v806 = v1687;
            v805 = v1688;
            v807 = v1687;
            if ( v802 )
            {
              if ( &v1687[numchans] <= (ALima4 *)v1688 || v1687 >= (ALima4 *)v1688 + 4 * numchans )
              {
                v807 = &v1687[v802];
                v805 = (int64x2_t *)((char *)v1688 + 4 * v802);
                v808 = numchans & 0xFFFFFFFC;
                v809 = v1688;
                v810 = v1687;
                do
                {
                  v811 = *(_DWORD *)v810;
                  v810 += 4;
                  v808 -= 4;
                  v6.n128_u32[0] = v811;
                  v6 = vshlq_n_s32(vmovl_u16((uint16x4_t)vmovl_u8((uint8x8_t)v6.n128_u64[0]).n128_u64[0]), 0x18u);
                  *v809++ = v6;
                }
                while ( v808 );
                v803 = numchans;
                v804 = numchans & 0xFFFFFFFC;
                if ( v802 == numchans )
                  goto LABEL_1128;
              }
              else
              {
                v804 = 0;
                v805 = v1688;
                v807 = v1687;
              }
            }
          }
          v812 = v803 - v804;
          do
          {
            v813 = *v807++;
            --v812;
            v805->n128_u32[0] = v813 << 24;
            v805 = (int64x2_t *)((char *)v805 + 4);
          }
          while ( v812 );
LABEL_1128:
          v1688 = (int64x2_t *)((char *)v1688 + 4 * v803);
          v1687 = &v806[v803];
          goto LABEL_1129;
        case UserFmtShort:
          if ( !len )
            return;
          v814.n128_u64[0] = 0x8000000080000000LL;
          v814.n128_u64[1] = 0x8000000080000000LL;
          v815 = 0;
          v816 = numchans & 0xFFFFFFFC;
          while ( 1 )
          {
            v817 = numchans;
            if ( numchans )
              break;
LABEL_1147:
            if ( ++v815 == len )
              return;
          }
          v818 = 0;
          if ( (unsigned int)numchans < 4 )
          {
            v820 = v1687;
            v819 = (unsigned int *)v1688;
            v821 = v1687;
          }
          else
          {
            v820 = v1687;
            v819 = (unsigned int *)v1688;
            v821 = v1687;
            if ( v816 )
            {
              v822 = &v1687[2 * numchans];
              v823 = v1688;
              v824 = v1688 >= (int64x2_t *)v822;
              if ( v1688 < (int64x2_t *)v822 )
                v824 = v1687 >= (ALima4 *)v1688 + 4 * numchans;
              if ( v824 )
              {
                v821 = &v1687[2 * v816];
                v819 = (unsigned int *)v1688 + v816;
                v825 = numchans & 0xFFFFFFFC;
                v826 = (int16x4_t *)v1687;
                do
                {
                  v827.n64_u64[0] = v826->n64_u64[0];
                  ++v826;
                  v825 -= 4;
                  *v823++ = veorq_s64(vshll_n_s16(v827, 0x10u), v814);
                }
                while ( v825 );
                v817 = numchans;
                v818 = numchans & 0xFFFFFFFC;
                if ( v816 == numchans )
                  goto LABEL_1146;
              }
              else
              {
                v819 = (unsigned int *)v1688;
                v818 = 0;
                v821 = v1687;
                v817 = numchans;
              }
            }
          }
          v828 = v817 - v818;
          do
          {
            v829 = *(unsigned __int16 *)v821;
            v821 += 2;
            --v828;
            *v819++ = (v829 << 16) ^ 0x80000000;
          }
          while ( v828 );
LABEL_1146:
          v1688 = (int64x2_t *)((char *)v1688 + 4 * v817);
          v1687 = &v820[2 * v817];
          goto LABEL_1147;
        case UserFmtUShort:
          if ( !len )
            return;
          v830 = 0;
          v831 = numchans & 0xFFFFFFFC;
          while ( 1 )
          {
            v838 = numchans;
            if ( numchans )
              break;
LABEL_1167:
            if ( ++v830 == len )
              return;
          }
          v839 = 0;
          if ( (unsigned int)numchans < 4 )
          {
            v840 = v1688;
            v841 = v1687;
          }
          else
          {
            v840 = v1688;
            v841 = v1687;
            v833 = v1688;
            v832 = v1687;
            if ( !v831 )
              goto LABEL_1164;
            v842 = &v1687[2 * numchans];
            v843 = v1688 >= (int64x2_t *)v842;
            if ( v1688 < (int64x2_t *)v842 )
              v843 = v1687 >= (ALima4 *)v1688 + 4 * numchans;
            if ( v843 )
            {
              v832 = &v1687[2 * v831];
              v833 = (int64x2_t *)((char *)v1688 + 4 * v831);
              v834 = numchans & 0xFFFFFFFC;
              v835 = v1688;
              v836 = (int16x4_t *)v1687;
              do
              {
                v837.n64_u64[0] = v836->n64_u64[0];
                ++v836;
                v834 -= 4;
                *v835++ = vshll_n_s16(v837, 0x10u);
              }
              while ( v834 );
              v838 = numchans;
              v839 = numchans & 0xFFFFFFFC;
              if ( v831 == numchans )
                goto LABEL_1166;
              goto LABEL_1164;
            }
            v839 = 0;
          }
          v833 = v840;
          v832 = v841;
LABEL_1164:
          v844 = v838 - v839;
          do
          {
            v845 = *(unsigned __int16 *)v832;
            v832 += 2;
            --v844;
            v833->n128_u32[0] = v845 << 16;
            v833 = (int64x2_t *)((char *)v833 + 4);
          }
          while ( v844 );
LABEL_1166:
          v1688 = (int64x2_t *)((char *)v840 + 4 * v838);
          v1687 = &v841[2 * v838];
          goto LABEL_1167;
        case UserFmtInt:
          if ( !len )
            return;
          v846.n128_u64[0] = 0x8000000080000000LL;
          v846.n128_u64[1] = 0x8000000080000000LL;
          v847 = 0;
          v848 = numchans & 0xFFFFFFFC;
          while ( 1 )
          {
            v855 = numchans;
            if ( numchans )
              break;
LABEL_1187:
            if ( ++v847 == len )
              return;
          }
          v856 = 0;
          if ( (unsigned int)numchans < 4 )
          {
            v857 = v1688;
            v858 = v1687;
          }
          else
          {
            v857 = v1688;
            v858 = v1687;
            v850 = (unsigned int *)v1688;
            v849 = v1687;
            if ( !v848 )
              goto LABEL_1184;
            v859 = &v1687[4 * numchans];
            v860 = v1688 >= (int64x2_t *)v859;
            if ( v1688 < (int64x2_t *)v859 )
              v860 = v1687 >= (ALima4 *)v1688 + 4 * numchans;
            if ( v860 )
            {
              v849 = &v1687[4 * v848];
              v850 = (unsigned int *)v1688 + v848;
              v851 = numchans & 0xFFFFFFFC;
              v852 = v1688;
              v853 = (int64x2_t *)v1687;
              do
              {
                v854 = *v853++;
                v851 -= 4;
                *v852++ = veorq_s64(v854, v846);
              }
              while ( v851 );
              v855 = numchans;
              v856 = numchans & 0xFFFFFFFC;
              if ( v848 == numchans )
                goto LABEL_1186;
              goto LABEL_1184;
            }
            v856 = 0;
          }
          v850 = (unsigned int *)v857;
          v849 = v858;
LABEL_1184:
          v861 = v855 - v856;
          do
          {
            v862 = *(_DWORD *)v849;
            v849 += 4;
            --v861;
            *v850++ = v862 ^ 0x80000000;
          }
          while ( v861 );
LABEL_1186:
          v1688 = (int64x2_t *)((char *)v857 + 4 * v855);
          v1687 = &v858[4 * v855];
          goto LABEL_1187;
        case UserFmtUInt:
          if ( !len )
            return;
          v863 = 0;
          v864 = numchans & 0xFFFFFFFC;
          while ( 1 )
          {
            v872 = numchans;
            if ( numchans )
              break;
LABEL_1207:
            if ( ++v863 == len )
              return;
          }
          v873 = 0;
          if ( (unsigned int)numchans < 4 )
          {
            v874 = v1688;
            v875 = v1687;
          }
          else
          {
            v874 = v1688;
            v875 = v1687;
            v866 = v1688;
            v865 = v1687;
            if ( !v864 )
              goto LABEL_1204;
            v876 = &v1687[4 * numchans];
            v877 = v1688 >= (int64x2_t *)v876;
            if ( v1688 < (int64x2_t *)v876 )
              v877 = v1687 >= (ALima4 *)v1688 + 4 * numchans;
            if ( v877 )
            {
              v865 = &v1687[4 * v864];
              v866 = (int64x2_t *)((char *)v1688 + 4 * v864);
              v867 = numchans & 0xFFFFFFFC;
              v868 = v1688;
              v869 = v1687;
              do
              {
                v870 = *(_QWORD *)v869;
                v871 = *((_QWORD *)v869 + 1);
                v869 += 16;
                v867 -= 4;
                v868->n128_u64[0] = v870;
                v868->n128_u64[1] = v871;
                ++v868;
              }
              while ( v867 );
              v872 = numchans;
              v873 = numchans & 0xFFFFFFFC;
              if ( v864 == numchans )
                goto LABEL_1206;
              goto LABEL_1204;
            }
            v873 = 0;
          }
          v866 = v874;
          v865 = v875;
LABEL_1204:
          v878 = v872 - v873;
          do
          {
            v879 = *(_DWORD *)v865;
            v865 += 4;
            --v878;
            v866->n128_u32[0] = v879;
            v866 = (int64x2_t *)((char *)v866 + 4);
          }
          while ( v878 );
LABEL_1206:
          v1688 = (int64x2_t *)((char *)v874 + 4 * v872);
          v1687 = &v875[4 * v872];
          goto LABEL_1207;
        case UserFmtFloat:
          if ( len )
          {
            v880 = 0;
            do
            {
              v881 = numchans;
              if ( numchans )
              {
                v882 = len;
                v883 = (unsigned int *)v1688;
                v884 = (float *)v1687;
                do
                {
                  v885 = *v884++;
                  if ( v885 <= 1.0 )
                  {
                    if ( v885 >= -1.0 )
                      v886 = (int)(v885 * 2147483650.0) ^ 0x80000000;
                    else
                      v886 = 0;
                  }
                  else
                  {
                    v886 = -1;
                  }
                  *v883++ = v886;
                  --v881;
                }
                while ( v881 );
                v1688 = (int64x2_t *)((char *)v1688 + 4 * numchans);
                v1687 += 4 * numchans;
              }
              else
              {
                v882 = len;
              }
              ++v880;
            }
            while ( v880 != v882 );
          }
          return;
        case UserFmtDouble:
          if ( len )
          {
            v887 = 0;
            do
            {
              v888 = numchans;
              if ( numchans )
              {
                v889 = len;
                v890 = (unsigned int *)v1688;
                v891 = (double *)v1687;
                do
                {
                  v892 = *v891++;
                  if ( v892 <= 1.0 )
                  {
                    if ( v892 >= -1.0 )
                      v893 = (int)(v892 * 2147483650.0) ^ 0x80000000;
                    else
                      v893 = 0;
                  }
                  else
                  {
                    v893 = -1;
                  }
                  *v890++ = v893;
                  --v888;
                }
                while ( v888 );
                v1688 = (int64x2_t *)((char *)v1688 + 4 * numchans);
                v1687 += 8 * numchans;
              }
              else
              {
                v889 = len;
              }
              ++v887;
            }
            while ( v887 != v889 );
          }
          return;
        case UserFmtByte3:
          if ( len )
          {
            for ( ii = 0; ii != len; ++ii )
            {
              v895 = numchans;
              if ( numchans )
              {
                v896 = (unsigned int *)v1688;
                v897 = v1687;
                do
                {
                  v898 = v897[2];
                  --v895;
                  v899 = *(unsigned __int16 *)v897;
                  v897 += 3;
                  *v896++ = ((v899 | (v898 << 16)) << 8) ^ 0x80000000;
                }
                while ( v895 );
                v1688 = (int64x2_t *)((char *)v1688 + 4 * numchans);
                v1687 += 3 * numchans;
              }
            }
          }
          return;
        case UserFmtUByte3:
          if ( len )
          {
            v900 = 0;
            do
            {
              v901 = numchans;
              if ( numchans )
              {
                v902 = len;
                v903 = v1688;
                v904 = v1687;
                do
                {
                  v905 = v904[2];
                  --v901;
                  v906 = *(unsigned __int16 *)v904;
                  v904 += 3;
                  v903->n128_u32[0] = (v906 | (v905 << 16)) << 8;
                  v903 = (int64x2_t *)((char *)v903 + 4);
                }
                while ( v901 );
                v1688 = (int64x2_t *)((char *)v1688 + 4 * numchans);
                v1687 += 3 * numchans;
              }
              else
              {
                v902 = len;
              }
              ++v900;
            }
            while ( v900 != v902 );
          }
          return;
        case UserFmtMulaw:
          if ( len )
          {
            for ( jj = 0; jj != len; ++jj )
            {
              v908 = numchans;
              if ( numchans )
              {
                v909 = (unsigned int *)v1688;
                v910 = v1687;
                do
                {
                  v911 = *v910++;
                  --v908;
                  *v909++ = ((unsigned __int16)muLawDecompressionTable[v911] << 16) ^ 0x80000000;
                }
                while ( v908 );
                v1688 = (int64x2_t *)((char *)v1688 + 4 * numchans);
                v1687 += numchans;
              }
            }
          }
          return;
        case UserFmtAlaw:
          if ( len )
          {
            for ( kk = 0; kk != len; ++kk )
            {
              v913 = numchans;
              if ( numchans )
              {
                v914 = (unsigned int *)v1688;
                v915 = v1687;
                do
                {
                  v916 = *v915++;
                  --v913;
                  *v914++ = ((unsigned __int16)aLawDecompressionTable[v916] << 16) ^ 0x80000000;
                }
                while ( v913 );
                v1688 = (int64x2_t *)((char *)v1688 + 4 * numchans);
                v1687 += numchans;
              }
            }
          }
          return;
        case UserFmtIMA4:
          v917 = numchans;
          if ( !len )
            return;
          v918 = numchans & 0xFFFFFFFC;
          v919 = 0;
          v920.n128_u64[0] = 0x8000000080000000LL;
          v920.n128_u64[1] = 0x8000000080000000LL;
          while ( 1 )
          {
            DecodeIMA4Block(v1689, v1687, v917);
            v1687 += 36 * numchans;
            if ( v919 < len )
              break;
            v921 = v1688;
            v917 = numchans;
LABEL_1291:
            v1688 = v921;
            if ( v919 >= len )
              return;
          }
          v921 = v1688;
          v917 = numchans;
          v922 = v1689;
          v923 = 0;
          break;
        default:
          return;
      }
      while ( 1 )
      {
        if ( !v917 )
          goto LABEL_1287;
        v924 = 0;
        if ( v917 < 4 )
        {
          v925 = (unsigned int *)v921;
        }
        else
        {
          v925 = (unsigned int *)v921;
          if ( v918 )
          {
            v926 = &v1689[v917 + v923 * v917];
            v927 = v921 >= (int64x2_t *)v926;
            if ( v921 < (int64x2_t *)v926 )
              v927 = &v1689[v923 * v917] >= (ALshort *)v921 + 2 * v917;
            if ( v927 )
            {
              v925 = (unsigned int *)v921 + v918;
              v928 = numchans & 0xFFFFFFFC;
              v929 = (int16x4_t *)v922;
              v930 = v921;
              do
              {
                v931.n64_u64[0] = v929->n64_u64[0];
                ++v929;
                v928 -= 4;
                *v930++ = veorq_s64(vshll_n_s16(v931, 0x10u), v920);
              }
              while ( v928 );
              v917 = numchans;
              v924 = numchans & 0xFFFFFFFC;
              if ( v918 == numchans )
                goto LABEL_1286;
            }
            else
            {
              v924 = 0;
              v925 = (unsigned int *)v921;
            }
          }
        }
        do
        {
          v932 = (unsigned __int16)v922[v924++];
          *v925++ = (v932 << 16) ^ 0x80000000;
        }
        while ( v917 != v924 );
LABEL_1286:
        v921 = (int64x2_t *)((char *)v921 + 4 * v917);
LABEL_1287:
        ++v923;
        ++v919;
        if ( v923 <= 0x40 )
        {
          v922 += numchans;
          if ( v919 < len )
            continue;
        }
        goto LABEL_1291;
      }
    case UserFmtFloat:
      switch ( srcType )
      {
        case UserFmtByte:
          if ( len )
          {
            v57 = 0;
            do
            {
              v58 = numchans;
              if ( numchans )
              {
                v59 = len;
                v60 = (float *)v1688;
                v61 = v1687;
                do
                {
                  v62 = (char)*v61++;
                  --v58;
                  *v60++ = (float)v62 * 0.007874;
                }
                while ( v58 );
                v1688 = (int64x2_t *)((char *)v1688 + 4 * numchans);
                v1687 += numchans;
              }
              else
              {
                v59 = len;
              }
              ++v57;
            }
            while ( v57 != v59 );
          }
          return;
        case UserFmtUByte:
          if ( len )
          {
            v933 = 0;
            do
            {
              v934 = numchans;
              if ( numchans )
              {
                v935 = len;
                v936 = (float *)v1688;
                v937 = v1687;
                do
                {
                  v938 = *v937++;
                  --v934;
                  *v936++ = (float)(v938 - 128) * 0.007874;
                }
                while ( v934 );
                v1688 = (int64x2_t *)((char *)v1688 + 4 * numchans);
                v1687 += numchans;
              }
              else
              {
                v935 = len;
              }
              ++v933;
            }
            while ( v933 != v935 );
          }
          return;
        case UserFmtShort:
          if ( len )
          {
            v939 = 0;
            do
            {
              v940 = numchans;
              if ( numchans )
              {
                v941 = len;
                v942 = (float *)v1688;
                v943 = v1687;
                do
                {
                  v944 = *(__int16 *)v943;
                  v943 += 2;
                  --v940;
                  *v942++ = (float)v944 * 0.000030519;
                }
                while ( v940 );
                v1688 = (int64x2_t *)((char *)v1688 + 4 * numchans);
                v1687 += 2 * numchans;
              }
              else
              {
                v941 = len;
              }
              ++v939;
            }
            while ( v939 != v941 );
          }
          return;
        case UserFmtUShort:
          if ( len )
          {
            v945 = 0;
            do
            {
              v946 = numchans;
              if ( numchans )
              {
                v947 = len;
                v948 = (float *)v1688;
                v949 = v1687;
                do
                {
                  v950 = *(unsigned __int16 *)v949;
                  v949 += 2;
                  --v946;
                  *v948++ = (float)(v950 - 0x8000) * 0.000030519;
                }
                while ( v946 );
                v1688 = (int64x2_t *)((char *)v1688 + 4 * numchans);
                v1687 += 2 * numchans;
              }
              else
              {
                v947 = len;
              }
              ++v945;
            }
            while ( v945 != v947 );
          }
          return;
        case UserFmtInt:
          if ( len )
          {
            v951 = 0;
            do
            {
              v952 = numchans;
              if ( numchans )
              {
                v953 = len;
                v954 = (float *)v1688;
                v955 = (int *)v1687;
                do
                {
                  v956 = *v955++;
                  --v952;
                  v957 = (double)v956 * 4.65661288e-10;
                  *v954++ = v957;
                }
                while ( v952 );
                v1688 = (int64x2_t *)((char *)v1688 + 4 * numchans);
                v1687 += 4 * numchans;
              }
              else
              {
                v953 = len;
              }
              ++v951;
            }
            while ( v951 != v953 );
          }
          return;
        case UserFmtUInt:
          if ( len )
          {
            v958 = 0;
            do
            {
              v959 = numchans;
              if ( numchans )
              {
                v960 = len;
                v961 = (float *)v1688;
                v962 = v1687;
                do
                {
                  v963 = *(_DWORD *)v962;
                  v962 += 4;
                  --v959;
                  v964 = (double)(int)(v963 ^ 0x80000000) * 4.65661288e-10;
                  *v961++ = v964;
                }
                while ( v959 );
                v1688 = (int64x2_t *)((char *)v1688 + 4 * numchans);
                v1687 += 4 * numchans;
              }
              else
              {
                v960 = len;
              }
              ++v958;
            }
            while ( v958 != v960 );
          }
          return;
        case UserFmtFloat:
          if ( !len )
            return;
          v965 = 0;
          v966 = numchans & 0xFFFFFFFC;
          while ( 1 )
          {
            v974 = numchans;
            if ( numchans )
              break;
LABEL_1356:
            if ( ++v965 == len )
              return;
          }
          v975 = 0;
          if ( (unsigned int)numchans < 4 )
          {
            v976 = v1688;
            v977 = v1687;
          }
          else
          {
            v976 = v1688;
            v977 = v1687;
            v968 = v1688;
            v967 = v1687;
            if ( !v966 )
              goto LABEL_1353;
            v978 = &v1687[4 * numchans];
            v979 = v1688 >= (int64x2_t *)v978;
            if ( v1688 < (int64x2_t *)v978 )
              v979 = v1687 >= (ALima4 *)v1688 + 4 * numchans;
            if ( v979 )
            {
              v967 = &v1687[4 * v966];
              v968 = (int64x2_t *)((char *)v1688 + 4 * v966);
              v969 = numchans & 0xFFFFFFFC;
              v970 = v1688;
              v971 = v1687;
              do
              {
                v972 = *(_QWORD *)v971;
                v973 = *((_QWORD *)v971 + 1);
                v971 += 16;
                v969 -= 4;
                v970->n128_u64[0] = v972;
                v970->n128_u64[1] = v973;
                ++v970;
              }
              while ( v969 );
              v974 = numchans;
              v975 = numchans & 0xFFFFFFFC;
              if ( v966 == numchans )
                goto LABEL_1355;
              goto LABEL_1353;
            }
            v975 = 0;
          }
          v968 = v976;
          v967 = v977;
LABEL_1353:
          v980 = v974 - v975;
          do
          {
            v981 = *(_DWORD *)v967;
            v967 += 4;
            --v980;
            v968->n128_u32[0] = v981;
            v968 = (int64x2_t *)((char *)v968 + 4);
          }
          while ( v980 );
LABEL_1355:
          v1688 = (int64x2_t *)((char *)v976 + 4 * v974);
          v1687 = &v977[4 * v974];
          goto LABEL_1356;
        case UserFmtDouble:
          if ( !len )
            return;
          v982 = 0;
          v983 = numchans & 0xFFFFFFFE;
          break;
        case UserFmtByte3:
          if ( len )
          {
            v1001 = 0;
            do
            {
              v1002 = numchans;
              if ( numchans )
              {
                v1003 = len;
                v1004 = (float *)v1688;
                v1005 = v1687;
                do
                {
                  --v1002;
                  v1006 = *(_WORD *)v1005;
                  v1005 += 3;
                  v1007 = (double)v1006 * 0.000000119209304;
                  *v1004++ = v1007;
                }
                while ( v1002 );
                v1688 = (int64x2_t *)((char *)v1688 + 4 * numchans);
                v1687 += 3 * numchans;
              }
              else
              {
                v1003 = len;
              }
              ++v1001;
            }
            while ( v1001 != v1003 );
          }
          return;
        case UserFmtUByte3:
          if ( len )
          {
            v1008 = 0;
            do
            {
              v1009 = numchans;
              if ( numchans )
              {
                v1010 = len;
                v1011 = (float *)v1688;
                v1012 = v1687;
                do
                {
                  v1013 = v1012[2];
                  --v1009;
                  v1014 = *(unsigned __int16 *)v1012;
                  v1012 += 3;
                  v1015 = (double)((v1014 | (v1013 << 16)) - 0x800000) * 0.000000119209304;
                  *v1011++ = v1015;
                }
                while ( v1009 );
                v1688 = (int64x2_t *)((char *)v1688 + 4 * numchans);
                v1687 += 3 * numchans;
              }
              else
              {
                v1010 = len;
              }
              ++v1008;
            }
            while ( v1008 != v1010 );
          }
          return;
        case UserFmtMulaw:
          if ( len )
          {
            v1016 = 0;
            do
            {
              v1017 = numchans;
              if ( numchans )
              {
                v1018 = len;
                v1019 = (float *)v1688;
                v1020 = v1687;
                do
                {
                  v1021 = *v1020++;
                  --v1017;
                  *v1019++ = (float)muLawDecompressionTable[v1021] * 0.000030519;
                }
                while ( v1017 );
                v1688 = (int64x2_t *)((char *)v1688 + 4 * numchans);
                v1687 += numchans;
              }
              else
              {
                v1018 = len;
              }
              ++v1016;
            }
            while ( v1016 != v1018 );
          }
          return;
        case UserFmtAlaw:
          if ( len )
          {
            v1022 = 0;
            do
            {
              v1023 = numchans;
              if ( numchans )
              {
                v1024 = len;
                v1025 = (float *)v1688;
                v1026 = v1687;
                do
                {
                  v1027 = *v1026++;
                  --v1023;
                  *v1025++ = (float)aLawDecompressionTable[v1027] * 0.000030519;
                }
                while ( v1023 );
                v1688 = (int64x2_t *)((char *)v1688 + 4 * numchans);
                v1687 += numchans;
              }
              else
              {
                v1024 = len;
              }
              ++v1022;
            }
            while ( v1022 != v1024 );
          }
          return;
        case UserFmtIMA4:
          if ( len )
          {
            v1028 = 0;
            do
            {
              DecodeIMA4Block(v1689, v1687, numchans);
              v1687 += 36 * numchans;
              if ( v1028 >= len )
              {
                v1029 = (float *)v1688;
              }
              else
              {
                v1029 = (float *)v1688;
                v1030 = v1689;
                v1031 = 0;
                do
                {
                  v1032 = numchans;
                  if ( numchans )
                  {
                    v1033 = v1030;
                    v1034 = v1029;
                    do
                    {
                      v1035 = *v1033++;
                      --v1032;
                      *v1034++ = (float)v1035 * 0.000030519;
                    }
                    while ( v1032 );
                    v1029 += numchans;
                  }
                  ++v1031;
                  ++v1028;
                  if ( v1031 > 0x40 )
                    break;
                  v1030 += numchans;
                }
                while ( v1028 < len );
              }
              v1688 = (int64x2_t *)v1029;
            }
            while ( v1028 < len );
          }
          return;
        default:
          return;
      }
      while ( 1 )
      {
        v984 = numchans;
        if ( numchans )
          break;
LABEL_1377:
        if ( ++v982 == len )
          return;
      }
      if ( numchans == 1 )
      {
        v985 = (float *)v1688;
        v986 = 0;
        v987 = (double *)v1687;
      }
      else
      {
        v987 = (double *)v1687;
        v985 = (float *)v1688;
        if ( v983 )
        {
          v988 = &v1687[8 * numchans];
          v989 = v1688 >= (int64x2_t *)v988;
          if ( v1688 < (int64x2_t *)v988 )
            v989 = v1687 >= (ALima4 *)v1688 + 4 * numchans;
          if ( v989 )
          {
            v990 = (double *)&v1687[8 * v983];
            v991 = (float *)v1688 + v983;
            v992 = numchans & 0xFFFFFFFE;
            v993 = v1688;
            v994 = (double *)v1687;
            do
            {
              v995 = *v994;
              v996 = v994[1];
              v994 += 2;
              v992 -= 2;
              *((float *)&v997 + 1) = v996;
              *(float *)&v997 = v995;
              v993->n128_u64[0] = v997;
              v993 = (int64x2_t *)((char *)v993 + 8);
            }
            while ( v992 );
            v984 = numchans;
            v986 = numchans & 0xFFFFFFFE;
            if ( v983 == numchans )
              goto LABEL_1376;
            goto LABEL_1374;
          }
        }
        v986 = 0;
      }
      v991 = v985;
      v990 = v987;
LABEL_1374:
      v998 = v984 - v986;
      do
      {
        v999 = *v990;
        --v998;
        ++v990;
        v1000 = v999;
        *v991++ = v1000;
      }
      while ( v998 );
LABEL_1376:
      v1688 = (int64x2_t *)&v985[v984];
      v1687 = (ALima4 *)&v987[v984];
      goto LABEL_1377;
    case UserFmtDouble:
      switch ( srcType )
      {
        case UserFmtByte:
          if ( len )
          {
            v63 = 0;
            do
            {
              v64 = numchans;
              if ( numchans )
              {
                v65 = len;
                v66 = (double *)v1688;
                v67 = v1687;
                do
                {
                  v68 = (char)*v67++;
                  --v64;
                  *v66++ = (double)v68 * 0.00787401575;
                }
                while ( v64 );
                v1688 = (int64x2_t *)((char *)v1688 + 8 * numchans);
                v1687 += numchans;
              }
              else
              {
                v65 = len;
              }
              ++v63;
            }
            while ( v63 != v65 );
          }
          return;
        case UserFmtUByte:
          if ( len )
          {
            v1036 = 0;
            do
            {
              v1037 = numchans;
              if ( numchans )
              {
                v1038 = len;
                v1039 = (double *)v1688;
                v1040 = v1687;
                do
                {
                  v1041 = *v1040++;
                  --v1037;
                  *v1039++ = (double)(v1041 - 128) * 0.00787401575;
                }
                while ( v1037 );
                v1688 = (int64x2_t *)((char *)v1688 + 8 * numchans);
                v1687 += numchans;
              }
              else
              {
                v1038 = len;
              }
              ++v1036;
            }
            while ( v1036 != v1038 );
          }
          return;
        case UserFmtShort:
          if ( len )
          {
            v1042 = 0;
            do
            {
              v1043 = numchans;
              if ( numchans )
              {
                v1044 = len;
                v1045 = (double *)v1688;
                v1046 = v1687;
                do
                {
                  v1047 = *(__int16 *)v1046;
                  v1046 += 2;
                  --v1043;
                  *v1045++ = (double)v1047 * 0.0000305185095;
                }
                while ( v1043 );
                v1688 = (int64x2_t *)((char *)v1688 + 8 * numchans);
                v1687 += 2 * numchans;
              }
              else
              {
                v1044 = len;
              }
              ++v1042;
            }
            while ( v1042 != v1044 );
          }
          return;
        case UserFmtUShort:
          if ( len )
          {
            v1048 = 0;
            do
            {
              v1049 = numchans;
              if ( numchans )
              {
                v1050 = len;
                v1051 = (double *)v1688;
                v1052 = v1687;
                do
                {
                  v1053 = *(unsigned __int16 *)v1052;
                  v1052 += 2;
                  --v1049;
                  *v1051++ = (double)(v1053 - 0x8000) * 0.0000305185095;
                }
                while ( v1049 );
                v1688 = (int64x2_t *)((char *)v1688 + 8 * numchans);
                v1687 += 2 * numchans;
              }
              else
              {
                v1050 = len;
              }
              ++v1048;
            }
            while ( v1048 != v1050 );
          }
          return;
        case UserFmtInt:
          if ( len )
          {
            v1054 = 0;
            do
            {
              v1055 = numchans;
              if ( numchans )
              {
                v1056 = len;
                v1057 = (double *)v1688;
                v1058 = (int *)v1687;
                do
                {
                  v1059 = *v1058++;
                  --v1055;
                  *v1057++ = (double)v1059 * 4.65661288e-10;
                }
                while ( v1055 );
                v1688 = (int64x2_t *)((char *)v1688 + 8 * numchans);
                v1687 += 4 * numchans;
              }
              else
              {
                v1056 = len;
              }
              ++v1054;
            }
            while ( v1054 != v1056 );
          }
          return;
        case UserFmtUInt:
          if ( len )
          {
            v1060 = 0;
            do
            {
              v1061 = numchans;
              if ( numchans )
              {
                v1062 = len;
                v1063 = (double *)v1688;
                v1064 = v1687;
                do
                {
                  v1065 = *(_DWORD *)v1064;
                  v1064 += 4;
                  --v1061;
                  *v1063++ = (double)(int)(v1065 ^ 0x80000000) * 4.65661288e-10;
                }
                while ( v1061 );
                v1688 = (int64x2_t *)((char *)v1688 + 8 * numchans);
                v1687 += 4 * numchans;
              }
              else
              {
                v1062 = len;
              }
              ++v1060;
            }
            while ( v1060 != v1062 );
          }
          return;
        case UserFmtFloat:
          if ( !len )
            return;
          v1066 = 0;
          v1067 = numchans & 0xFFFFFFFE;
          while ( 1 )
          {
            v1068 = numchans;
            if ( numchans )
              break;
LABEL_1493:
            if ( ++v1066 == len )
              return;
          }
          if ( numchans == 1 )
          {
            v1069 = (double *)v1688;
            v1070 = 0;
            v1071 = (float *)v1687;
          }
          else
          {
            v1071 = (float *)v1687;
            v1069 = (double *)v1688;
            if ( v1067 )
            {
              v1072 = &v1687[4 * numchans];
              v1073 = v1688 >= (int64x2_t *)v1072;
              if ( v1688 < (int64x2_t *)v1072 )
                v1073 = v1687 >= &v1688->n128_u8[8 * numchans];
              if ( v1073 )
              {
                v1074 = (float *)&v1687[4 * v1067];
                v1075 = &v1688->n128_f64[v1067];
                v1076 = numchans & 0xFFFFFFFE;
                v1077 = (double *)v1688;
                v1078 = v1687;
                do
                {
                  v1079 = *(_QWORD *)v1078;
                  v1078 += 8;
                  v1076 -= 2;
                  *v1077 = *(float *)&v1079;
                  v1077[1] = *((float *)&v1079 + 1);
                  v1077 += 2;
                }
                while ( v1076 );
                v1068 = numchans;
                v1070 = numchans & 0xFFFFFFFE;
                if ( v1067 == numchans )
                  goto LABEL_1492;
                goto LABEL_1490;
              }
            }
            v1070 = 0;
          }
          v1075 = v1069;
          v1074 = v1071;
LABEL_1490:
          v1080 = v1068 - v1070;
          do
          {
            v1081 = *v1074;
            --v1080;
            ++v1074;
            *v1075++ = v1081;
          }
          while ( v1080 );
LABEL_1492:
          v1688 = (int64x2_t *)&v1069[v1068];
          v1687 = (ALima4 *)&v1071[v1068];
          goto LABEL_1493;
        case UserFmtDouble:
          if ( !len )
            return;
          v1082 = 0;
          v1083 = numchans & 0xFFFFFFFE;
          break;
        case UserFmtByte3:
          if ( len )
          {
            v1099 = 0;
            do
            {
              v1100 = numchans;
              if ( numchans )
              {
                v1101 = len;
                v1102 = (double *)v1688;
                v1103 = v1687;
                do
                {
                  --v1100;
                  v1104 = *(_WORD *)v1103;
                  v1103 += 3;
                  *v1102++ = (double)v1104 * 0.000000119209304;
                }
                while ( v1100 );
                v1688 = (int64x2_t *)((char *)v1688 + 8 * numchans);
                v1687 += 3 * numchans;
              }
              else
              {
                v1101 = len;
              }
              ++v1099;
            }
            while ( v1099 != v1101 );
          }
          return;
        case UserFmtUByte3:
          if ( len )
          {
            v1105 = 0;
            do
            {
              v1106 = numchans;
              if ( numchans )
              {
                v1107 = len;
                v1108 = (double *)v1688;
                v1109 = v1687;
                do
                {
                  v1110 = v1109[2];
                  --v1106;
                  v1111 = *(unsigned __int16 *)v1109;
                  v1109 += 3;
                  *v1108++ = (double)((v1111 | (v1110 << 16)) - 0x800000) * 0.000000119209304;
                }
                while ( v1106 );
                v1688 = (int64x2_t *)((char *)v1688 + 8 * numchans);
                v1687 += 3 * numchans;
              }
              else
              {
                v1107 = len;
              }
              ++v1105;
            }
            while ( v1105 != v1107 );
          }
          return;
        case UserFmtMulaw:
          if ( len )
          {
            v1112 = 0;
            do
            {
              v1113 = numchans;
              if ( numchans )
              {
                v1114 = len;
                v1115 = (double *)v1688;
                v1116 = v1687;
                do
                {
                  v1117 = *v1116++;
                  --v1113;
                  *v1115++ = (double)muLawDecompressionTable[v1117] * 0.0000305185095;
                }
                while ( v1113 );
                v1688 = (int64x2_t *)((char *)v1688 + 8 * numchans);
                v1687 += numchans;
              }
              else
              {
                v1114 = len;
              }
              ++v1112;
            }
            while ( v1112 != v1114 );
          }
          return;
        case UserFmtAlaw:
          if ( len )
          {
            v1118 = 0;
            do
            {
              v1119 = numchans;
              if ( numchans )
              {
                v1120 = len;
                v1121 = (double *)v1688;
                v1122 = v1687;
                do
                {
                  v1123 = *v1122++;
                  --v1119;
                  *v1121++ = (double)aLawDecompressionTable[v1123] * 0.0000305185095;
                }
                while ( v1119 );
                v1688 = (int64x2_t *)((char *)v1688 + 8 * numchans);
                v1687 += numchans;
              }
              else
              {
                v1120 = len;
              }
              ++v1118;
            }
            while ( v1118 != v1120 );
          }
          return;
        case UserFmtIMA4:
          if ( len )
          {
            v1124 = 0;
            do
            {
              DecodeIMA4Block(v1689, v1687, numchans);
              v1687 += 36 * numchans;
              if ( v1124 >= len )
              {
                v1125 = (double *)v1688;
              }
              else
              {
                v1125 = (double *)v1688;
                v1126 = v1689;
                v1127 = 0;
                do
                {
                  v1128 = numchans;
                  if ( numchans )
                  {
                    v1129 = v1126;
                    v1130 = v1125;
                    do
                    {
                      v1131 = *v1129++;
                      --v1128;
                      *v1130++ = (double)v1131 * 0.0000305185095;
                    }
                    while ( v1128 );
                    v1125 += numchans;
                  }
                  ++v1127;
                  ++v1124;
                  if ( v1127 > 0x40 )
                    break;
                  v1126 += numchans;
                }
                while ( v1124 < len );
              }
              v1688 = (int64x2_t *)v1125;
            }
            while ( v1124 < len );
          }
          return;
        default:
          return;
      }
      while ( 1 )
      {
        v1084 = numchans;
        if ( numchans )
          break;
LABEL_1514:
        if ( ++v1082 == len )
          return;
      }
      if ( numchans == 1 )
      {
        v1085 = v1688;
        v1086 = 0;
        v1087 = v1687;
      }
      else
      {
        v1087 = v1687;
        v1085 = v1688;
        if ( v1083 )
        {
          v1088 = &v1687[8 * numchans];
          v1089 = v1688 >= (int64x2_t *)v1088;
          if ( v1688 < (int64x2_t *)v1088 )
            v1089 = v1687 >= &v1688->n128_u8[8 * numchans];
          if ( v1089 )
          {
            v1090 = &v1687[8 * v1083];
            v1091 = &v1688->n128_u64[v1083];
            v1092 = numchans & 0xFFFFFFFE;
            v1093 = v1688;
            v1094 = v1687;
            do
            {
              v1095 = *(_QWORD *)v1094;
              v1096 = *((_QWORD *)v1094 + 1);
              v1094 += 16;
              v1092 -= 2;
              v1093->n128_u64[0] = v1095;
              v1093->n128_u64[1] = v1096;
              ++v1093;
            }
            while ( v1092 );
            v1084 = numchans;
            v1086 = numchans & 0xFFFFFFFE;
            if ( v1083 == numchans )
              goto LABEL_1513;
            goto LABEL_1511;
          }
        }
        v1086 = 0;
      }
      v1091 = (unsigned __int64 *)v1085;
      v1090 = v1087;
LABEL_1511:
      v1097 = v1084 - v1086;
      do
      {
        v1098 = *(_QWORD *)v1090;
        --v1097;
        v1090 += 8;
        *v1091++ = v1098;
      }
      while ( v1097 );
LABEL_1513:
      v1688 = (int64x2_t *)((char *)v1085 + 8 * v1084);
      v1687 = &v1087[8 * v1084];
      goto LABEL_1514;
    case UserFmtByte3:
      switch ( srcType )
      {
        case UserFmtByte:
          if ( len )
          {
            v69 = 0;
            do
            {
              v70 = numchans;
              if ( numchans )
              {
                v71 = len;
                v72 = v1688;
                v73 = v1687;
                do
                {
                  v74 = *v73++;
                  --v70;
                  v72->n128_u8[2] = v74;
                  v72->n128_u16[0] = 0;
                  v72 = (int64x2_t *)((char *)v72 + 3);
                }
                while ( v70 );
                v1687 += numchans;
                v1688 = (int64x2_t *)((char *)v1688 + 3 * numchans);
              }
              else
              {
                v71 = len;
              }
              ++v69;
            }
            while ( v69 != v71 );
          }
          break;
        case UserFmtUByte:
          if ( len )
          {
            v1132 = 0;
            do
            {
              v1133 = numchans;
              if ( numchans )
              {
                v1134 = len;
                v1135 = v1688;
                v1136 = v1687;
                do
                {
                  v1137 = *v1136++;
                  --v1133;
                  v1135->n128_u16[0] = 0;
                  v1135->n128_u8[2] = v1137 ^ 0x80;
                  v1135 = (int64x2_t *)((char *)v1135 + 3);
                }
                while ( v1133 );
                v1687 += numchans;
                v1688 = (int64x2_t *)((char *)v1688 + 3 * numchans);
              }
              else
              {
                v1134 = len;
              }
              ++v1132;
            }
            while ( v1132 != v1134 );
          }
          break;
        case UserFmtShort:
          if ( len )
          {
            v1138 = 0;
            do
            {
              v1139 = numchans;
              if ( numchans )
              {
                v1140 = len;
                v1141 = v1688;
                v1142 = v1687;
                do
                {
                  v1143 = *(_WORD *)v1142;
                  v1142 += 2;
                  --v1139;
                  v1141->n128_u8[2] = HIBYTE(v1143);
                  v1141->n128_u16[0] = v1143 << 8;
                  v1141 = (int64x2_t *)((char *)v1141 + 3);
                }
                while ( v1139 );
                v1687 += 2 * numchans;
                v1688 = (int64x2_t *)((char *)v1688 + 3 * numchans);
              }
              else
              {
                v1140 = len;
              }
              ++v1138;
            }
            while ( v1138 != v1140 );
          }
          break;
        case UserFmtUShort:
          if ( len )
          {
            for ( mm = 0; mm != len; ++mm )
            {
              v1145 = numchans;
              if ( numchans )
              {
                v1146 = v1688;
                v1147 = v1687;
                do
                {
                  v1148 = *(_WORD *)v1147;
                  v1147 += 2;
                  --v1145;
                  v1146->n128_u8[2] = HIBYTE(v1148) ^ 0x80;
                  v1146->n128_u16[0] = v1148 << 8;
                  v1146 = (int64x2_t *)((char *)v1146 + 3);
                }
                while ( v1145 );
                v1687 += 2 * numchans;
                v1688 = (int64x2_t *)((char *)v1688 + 3 * numchans);
              }
            }
          }
          break;
        case UserFmtInt:
          if ( len )
          {
            v1149 = 0;
            do
            {
              v1150 = numchans;
              if ( numchans )
              {
                v1151 = len;
                v1152 = v1688;
                v1153 = v1687;
                do
                {
                  v1154 = *(_DWORD *)v1153;
                  v1153 += 4;
                  --v1150;
                  v1152->n128_u8[2] = HIBYTE(v1154);
                  v1152->n128_u16[0] = v1154 >> 8;
                  v1152 = (int64x2_t *)((char *)v1152 + 3);
                }
                while ( v1150 );
                v1687 += 4 * numchans;
                v1688 = (int64x2_t *)((char *)v1688 + 3 * numchans);
              }
              else
              {
                v1151 = len;
              }
              ++v1149;
            }
            while ( v1149 != v1151 );
          }
          break;
        case UserFmtUInt:
          if ( len )
          {
            for ( nn = 0; nn != len; ++nn )
            {
              v1156 = numchans;
              if ( numchans )
              {
                v1157 = v1688;
                v1158 = v1687;
                do
                {
                  v1159 = *(_DWORD *)v1158;
                  v1158 += 4;
                  --v1156;
                  v1157->n128_u8[2] = HIBYTE(v1159) ^ 0x80;
                  v1157->n128_u16[0] = v1159 >> 8;
                  v1157 = (int64x2_t *)((char *)v1157 + 3);
                }
                while ( v1156 );
                v1687 += 4 * numchans;
                v1688 = (int64x2_t *)((char *)v1688 + 3 * numchans);
              }
            }
          }
          break;
        case UserFmtFloat:
          if ( len )
          {
            for ( i1 = 0; i1 != len; ++i1 )
            {
              if ( numchans )
              {
                v1161 = numchans;
                v1162 = v1688;
                v1163 = (float *)v1687;
                do
                {
                  v1164 = *v1163++;
                  v1165 = v1162;
                  v1162 = (int64x2_t *)((char *)v1162 + 3);
                  v1166 = 0x7FFFFF;
                  if ( v1164 <= 1.0 )
                  {
                    if ( v1164 >= -1.0 )
                      v1166 = (unsigned int)(int)(v1164 * 2147483650.0) >> 8;
                    else
                      v1166 = 0x800000;
                  }
                  --v1161;
                  v1165->n128_u16[0] = v1166;
                  v1165->n128_u8[2] = BYTE2(v1166);
                }
                while ( v1161 );
                v1687 += 4 * numchans;
                v1688 = (int64x2_t *)((char *)v1688 + 3 * numchans);
              }
            }
          }
          break;
        case UserFmtDouble:
          if ( len )
          {
            for ( i2 = 0; i2 != len; ++i2 )
            {
              if ( numchans )
              {
                v1168 = numchans;
                v1169 = v1688;
                v1170 = (double *)v1687;
                do
                {
                  v1171 = *v1170++;
                  v1172 = v1169;
                  v1169 = (int64x2_t *)((char *)v1169 + 3);
                  v1173 = 0x7FFFFF;
                  if ( v1171 <= 1.0 )
                  {
                    if ( v1171 >= -1.0 )
                      v1173 = (unsigned int)(int)(v1171 * 2147483650.0) >> 8;
                    else
                      v1173 = 0x800000;
                  }
                  --v1168;
                  v1172->n128_u16[0] = v1173;
                  v1172->n128_u8[2] = BYTE2(v1173);
                }
                while ( v1168 );
                v1687 += 8 * numchans;
                v1688 = (int64x2_t *)((char *)v1688 + 3 * numchans);
              }
            }
          }
          break;
        case UserFmtByte3:
          if ( len )
          {
            for ( i3 = 0; i3 != len; ++i3 )
            {
              v1175 = numchans;
              if ( numchans )
              {
                v1176 = v1688;
                v1177 = v1687;
                do
                {
                  v1178 = *(_WORD *)v1177;
                  --v1175;
                  v1179 = v1177[2];
                  v1177 += 3;
                  v1176->n128_u8[2] = v1179;
                  v1176->n128_u16[0] = v1178;
                  v1176 = (int64x2_t *)((char *)v1176 + 3);
                }
                while ( v1175 );
                v1687 += 3 * numchans;
                v1688 = (int64x2_t *)((char *)v1688 + 3 * numchans);
              }
            }
          }
          break;
        case UserFmtUByte3:
          if ( len )
          {
            v1180 = 0;
            do
            {
              v1181 = numchans;
              if ( numchans )
              {
                v1182 = len;
                v1183 = v1688;
                v1184 = v1687;
                do
                {
                  v1185 = v1184[2];
                  --v1181;
                  v1186 = *(_WORD *)v1184;
                  v1184 += 3;
                  v1183->n128_u16[0] = v1186;
                  v1183->n128_u8[2] = v1185 ^ 0x80;
                  v1183 = (int64x2_t *)((char *)v1183 + 3);
                }
                while ( v1181 );
                v1687 += 3 * numchans;
                v1688 = (int64x2_t *)((char *)v1688 + 3 * numchans);
              }
              else
              {
                v1182 = len;
              }
              ++v1180;
            }
            while ( v1180 != v1182 );
          }
          break;
        case UserFmtMulaw:
          if ( len )
          {
            for ( i4 = 0; i4 != len; ++i4 )
            {
              v1188 = numchans;
              if ( numchans )
              {
                v1189 = v1688;
                v1190 = v1687;
                do
                {
                  v1191 = *v1190++;
                  --v1188;
                  v1192 = muLawDecompressionTable[v1191];
                  v1189->n128_u8[2] = HIBYTE(v1192);
                  v1189->n128_u16[0] = v1192 << 8;
                  v1189 = (int64x2_t *)((char *)v1189 + 3);
                }
                while ( v1188 );
                v1687 += numchans;
                v1688 = (int64x2_t *)((char *)v1688 + 3 * numchans);
              }
            }
          }
          break;
        case UserFmtAlaw:
          if ( len )
          {
            for ( i5 = 0; i5 != len; ++i5 )
            {
              v1194 = numchans;
              if ( numchans )
              {
                v1195 = v1688;
                v1196 = v1687;
                do
                {
                  v1197 = *v1196++;
                  --v1194;
                  v1198 = aLawDecompressionTable[v1197];
                  v1195->n128_u8[2] = HIBYTE(v1198);
                  v1195->n128_u16[0] = v1198 << 8;
                  v1195 = (int64x2_t *)((char *)v1195 + 3);
                }
                while ( v1194 );
                v1687 += numchans;
                v1688 = (int64x2_t *)((char *)v1688 + 3 * numchans);
              }
            }
          }
          break;
        case UserFmtIMA4:
          v1199 = numchans;
          if ( len )
          {
            v1200 = 0;
            do
            {
              DecodeIMA4Block(v1689, v1687, v1199);
              v1687 += 36 * numchans;
              if ( v1200 >= len )
              {
                v1201 = v1688;
                v1199 = numchans;
              }
              else
              {
                v1201 = v1688;
                v1199 = numchans;
                v1202 = v1689;
                v1203 = 0;
                do
                {
                  if ( v1199 )
                  {
                    v1204 = v1199;
                    v1205 = v1202;
                    v1206 = v1201;
                    do
                    {
                      v1207 = *v1205++;
                      --v1204;
                      v1206->n128_u8[2] = HIBYTE(v1207);
                      v1206->n128_u16[0] = v1207 << 8;
                      v1206 = (int64x2_t *)((char *)v1206 + 3);
                    }
                    while ( v1204 );
                    v1199 = numchans;
                    v1201 = (int64x2_t *)((char *)v1201 + 3 * numchans);
                  }
                  ++v1203;
                  ++v1200;
                  if ( v1203 > 0x40 )
                    break;
                  v1202 += numchans;
                }
                while ( v1200 < len );
              }
              v1688 = v1201;
            }
            while ( v1200 < len );
          }
          break;
        default:
          return;
      }
      return;
    case UserFmtUByte3:
      switch ( srcType )
      {
        case UserFmtByte:
          if ( len )
          {
            v75 = 0;
            do
            {
              v76 = numchans;
              if ( numchans )
              {
                v77 = len;
                v78 = v1688;
                v79 = v1687;
                do
                {
                  v80 = *v79++;
                  --v76;
                  v78->n128_u16[0] = 0;
                  v78->n128_u8[2] = v80 ^ 0x80;
                  v78 = (int64x2_t *)((char *)v78 + 3);
                }
                while ( v76 );
                v1687 += numchans;
                v1688 = (int64x2_t *)((char *)v1688 + 3 * numchans);
              }
              else
              {
                v77 = len;
              }
              ++v75;
            }
            while ( v75 != v77 );
          }
          break;
        case UserFmtUByte:
          if ( len )
          {
            v1208 = 0;
            do
            {
              v1209 = numchans;
              if ( numchans )
              {
                v1210 = len;
                v1211 = v1688;
                v1212 = v1687;
                do
                {
                  v1213 = *v1212++;
                  --v1209;
                  v1211->n128_u8[2] = v1213;
                  v1211->n128_u16[0] = 0;
                  v1211 = (int64x2_t *)((char *)v1211 + 3);
                }
                while ( v1209 );
                v1687 += numchans;
                v1688 = (int64x2_t *)((char *)v1688 + 3 * numchans);
              }
              else
              {
                v1210 = len;
              }
              ++v1208;
            }
            while ( v1208 != v1210 );
          }
          break;
        case UserFmtShort:
          if ( len )
          {
            for ( i6 = 0; i6 != len; ++i6 )
            {
              v1215 = numchans;
              if ( numchans )
              {
                v1216 = v1688;
                v1217 = v1687;
                do
                {
                  v1218 = *(_WORD *)v1217;
                  v1217 += 2;
                  --v1215;
                  v1216->n128_u8[2] = HIBYTE(v1218) ^ 0x80;
                  v1216->n128_u16[0] = v1218 << 8;
                  v1216 = (int64x2_t *)((char *)v1216 + 3);
                }
                while ( v1215 );
                v1687 += 2 * numchans;
                v1688 = (int64x2_t *)((char *)v1688 + 3 * numchans);
              }
            }
          }
          break;
        case UserFmtUShort:
          if ( len )
          {
            v1219 = 0;
            do
            {
              v1220 = numchans;
              if ( numchans )
              {
                v1221 = len;
                v1222 = v1688;
                v1223 = v1687;
                do
                {
                  v1224 = *(_WORD *)v1223;
                  v1223 += 2;
                  --v1220;
                  v1222->n128_u8[2] = HIBYTE(v1224);
                  v1222->n128_u16[0] = v1224 << 8;
                  v1222 = (int64x2_t *)((char *)v1222 + 3);
                }
                while ( v1220 );
                v1687 += 2 * numchans;
                v1688 = (int64x2_t *)((char *)v1688 + 3 * numchans);
              }
              else
              {
                v1221 = len;
              }
              ++v1219;
            }
            while ( v1219 != v1221 );
          }
          break;
        case UserFmtInt:
          if ( len )
          {
            for ( i7 = 0; i7 != len; ++i7 )
            {
              v1226 = numchans;
              if ( numchans )
              {
                v1227 = v1688;
                v1228 = v1687;
                do
                {
                  v1229 = *(_DWORD *)v1228;
                  v1228 += 4;
                  --v1226;
                  v1227->n128_u8[2] = HIBYTE(v1229) ^ 0x80;
                  v1227->n128_u16[0] = v1229 >> 8;
                  v1227 = (int64x2_t *)((char *)v1227 + 3);
                }
                while ( v1226 );
                v1687 += 4 * numchans;
                v1688 = (int64x2_t *)((char *)v1688 + 3 * numchans);
              }
            }
          }
          break;
        case UserFmtUInt:
          if ( len )
          {
            v1230 = 0;
            do
            {
              v1231 = numchans;
              if ( numchans )
              {
                v1232 = len;
                v1233 = v1688;
                v1234 = v1687;
                do
                {
                  v1235 = *(_DWORD *)v1234;
                  v1234 += 4;
                  --v1231;
                  v1233->n128_u8[2] = HIBYTE(v1235);
                  v1233->n128_u16[0] = v1235 >> 8;
                  v1233 = (int64x2_t *)((char *)v1233 + 3);
                }
                while ( v1231 );
                v1687 += 4 * numchans;
                v1688 = (int64x2_t *)((char *)v1688 + 3 * numchans);
              }
              else
              {
                v1232 = len;
              }
              ++v1230;
            }
            while ( v1230 != v1232 );
          }
          break;
        case UserFmtFloat:
          if ( len )
          {
            for ( i8 = 0; i8 != len; ++i8 )
            {
              if ( numchans )
              {
                v1237 = numchans;
                v1238 = v1688;
                v1239 = (float *)v1687;
                do
                {
                  v1240 = *v1239++;
                  v1241 = v1238;
                  v1238 = (int64x2_t *)((char *)v1238 + 3);
                  if ( v1240 <= 1.0 )
                  {
                    if ( v1240 >= -1.0 )
                      v1242 = ((unsigned int)(int)(v1240 * 2147483650.0) >> 8) ^ 0x800000;
                    else
                      v1242 = 0;
                  }
                  else
                  {
                    v1242 = 0xFFFFFF;
                  }
                  v1241->n128_u16[0] = v1242;
                  v1241->n128_u8[2] = BYTE2(v1242);
                  --v1237;
                }
                while ( v1237 );
                v1687 += 4 * numchans;
                v1688 = (int64x2_t *)((char *)v1688 + 3 * numchans);
              }
            }
          }
          break;
        case UserFmtDouble:
          if ( len )
          {
            for ( i9 = 0; i9 != len; ++i9 )
            {
              if ( numchans )
              {
                v1244 = numchans;
                v1245 = v1688;
                v1246 = (double *)v1687;
                do
                {
                  v1247 = *v1246++;
                  v1248 = v1245;
                  v1245 = (int64x2_t *)((char *)v1245 + 3);
                  if ( v1247 <= 1.0 )
                  {
                    if ( v1247 >= -1.0 )
                      v1249 = ((unsigned int)(int)(v1247 * 2147483650.0) >> 8) ^ 0x800000;
                    else
                      v1249 = 0;
                  }
                  else
                  {
                    v1249 = 0xFFFFFF;
                  }
                  v1248->n128_u16[0] = v1249;
                  v1248->n128_u8[2] = BYTE2(v1249);
                  --v1244;
                }
                while ( v1244 );
                v1687 += 8 * numchans;
                v1688 = (int64x2_t *)((char *)v1688 + 3 * numchans);
              }
            }
          }
          break;
        case UserFmtByte3:
          if ( len )
          {
            v1250 = 0;
            do
            {
              v1251 = numchans;
              if ( numchans )
              {
                v1252 = len;
                v1253 = v1688;
                v1254 = v1687;
                do
                {
                  v1255 = v1254[2];
                  --v1251;
                  v1256 = *(_WORD *)v1254;
                  v1254 += 3;
                  v1253->n128_u16[0] = v1256;
                  v1253->n128_u8[2] = v1255 ^ 0x80;
                  v1253 = (int64x2_t *)((char *)v1253 + 3);
                }
                while ( v1251 );
                v1687 += 3 * numchans;
                v1688 = (int64x2_t *)((char *)v1688 + 3 * numchans);
              }
              else
              {
                v1252 = len;
              }
              ++v1250;
            }
            while ( v1250 != v1252 );
          }
          break;
        case UserFmtUByte3:
          if ( len )
          {
            v1257 = 0;
            do
            {
              v1258 = numchans;
              if ( numchans )
              {
                v1259 = len;
                v1260 = v1688;
                v1261 = v1687;
                do
                {
                  v1262 = *(_WORD *)v1261;
                  --v1258;
                  v1263 = v1261[2];
                  v1261 += 3;
                  v1260->n128_u8[2] = v1263;
                  v1260->n128_u16[0] = v1262;
                  v1260 = (int64x2_t *)((char *)v1260 + 3);
                }
                while ( v1258 );
                v1687 += 3 * numchans;
                v1688 = (int64x2_t *)((char *)v1688 + 3 * numchans);
              }
              else
              {
                v1259 = len;
              }
              ++v1257;
            }
            while ( v1257 != v1259 );
          }
          break;
        case UserFmtMulaw:
          if ( len )
          {
            for ( i10 = 0; i10 != len; ++i10 )
            {
              if ( numchans )
              {
                v1265 = v1688;
                v1266 = numchans;
                v1267 = v1687;
                do
                {
                  v1268 = *v1267++;
                  --v1266;
                  v1269 = muLawDecompressionTable[v1268];
                  v1265->n128_u8[2] = HIBYTE(v1269) ^ 0x80;
                  v1265->n128_u16[0] = v1269 << 8;
                  v1265 = (int64x2_t *)((char *)v1265 + 3);
                }
                while ( v1266 );
                v1687 += numchans;
                v1688 = (int64x2_t *)((char *)v1688 + 3 * numchans);
              }
            }
          }
          break;
        case UserFmtAlaw:
          if ( len )
          {
            for ( i11 = 0; i11 != len; ++i11 )
            {
              if ( numchans )
              {
                v1271 = v1688;
                v1272 = numchans;
                v1273 = v1687;
                do
                {
                  v1274 = *v1273++;
                  --v1272;
                  v1275 = aLawDecompressionTable[v1274];
                  v1271->n128_u8[2] = HIBYTE(v1275) ^ 0x80;
                  v1271->n128_u16[0] = v1275 << 8;
                  v1271 = (int64x2_t *)((char *)v1271 + 3);
                }
                while ( v1272 );
                v1687 += numchans;
                v1688 = (int64x2_t *)((char *)v1688 + 3 * numchans);
              }
            }
          }
          break;
        case UserFmtIMA4:
          v1276 = len;
          v1277 = numchans;
          if ( len )
          {
            v1278 = 0;
            do
            {
              v1279 = v1276;
              DecodeIMA4Block(v1689, v1687, v1277);
              v1687 += 36 * numchans;
              if ( v1278 >= v1279 )
              {
                v1280 = v1688;
                v1277 = numchans;
              }
              else
              {
                v1280 = v1688;
                v1277 = numchans;
                v1281 = v1689;
                v1282 = 0;
                do
                {
                  if ( v1277 )
                  {
                    v1283 = v1281;
                    v1284 = v1280;
                    do
                    {
                      v1285 = *v1283++;
                      --v1277;
                      v1284->n128_u8[2] = HIBYTE(v1285) ^ 0x80;
                      v1284->n128_u16[0] = v1285 << 8;
                      v1284 = (int64x2_t *)((char *)v1284 + 3);
                    }
                    while ( v1277 );
                    v1277 = numchans;
                    v1280 = (int64x2_t *)((char *)v1280 + 3 * numchans);
                  }
                  ++v1282;
                  ++v1278;
                  if ( v1282 > 0x40 )
                    break;
                  v1281 += numchans;
                }
                while ( v1278 < len );
              }
              v1688 = v1280;
              v1276 = len;
            }
            while ( v1278 < len );
          }
          break;
        default:
          return;
      }
      return;
    case UserFmtMulaw:
      switch ( srcType )
      {
        case UserFmtByte:
          if ( len )
          {
            for ( i12 = 0; i12 != len; ++i12 )
            {
              if ( numchans )
              {
                v82 = v1688;
                v83 = numchans;
                v84 = v1687;
                do
                {
                  v85 = (char)*v84++;
                  v86 = v85 & 0x80;
                  v87 = v85 << 8;
                  if ( (v85 & 0x80) != 0 )
                  {
                    if ( v87 <= -32767 )
                      v87 = -32767;
                    v87 = -v87;
                  }
                  v87 = (__int16)v87;
                  if ( (__int16)v87 >= 32635 )
                    v87 = 32635;
                  --v83;
                  v88 = (v87 << 16) + 8650752;
                  v89 = muLawCompressTable[(unsigned __int8)((unsigned int)v88 >> 23)];
                  v82->n128_u8[0] = ~(v86 | (16 * v89) | (v88 >> 16 >> (v89 + 3)) & 0xF);
                  v82 = (int64x2_t *)((char *)v82 + 1);
                }
                while ( v83 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += numchans;
              }
            }
          }
          return;
        case UserFmtUByte:
          if ( len )
          {
            for ( i13 = 0; i13 != len; ++i13 )
            {
              if ( numchans )
              {
                v1287 = numchans;
                v1289 = v1687;
                v1288 = v1688;
                do
                {
                  v1290 = *v1289++;
                  LOWORD(v1291) = (v1290 << 8) + 0x8000;
                  v1292 = (__int16)v1291;
                  v1293 = ((unsigned int)(__int16)v1291 >> 8) & 0x80;
                  if ( v1293 )
                  {
                    if ( (__int16)v1291 <= -32767 )
                      v1292 = -32767;
                    v1291 = -v1292;
                  }
                  v1291 = (__int16)v1291;
                  if ( (__int16)v1291 >= 32635 )
                    v1291 = 32635;
                  --v1287;
                  v1294 = (v1291 << 16) + 8650752;
                  v1295 = muLawCompressTable[(unsigned __int8)((unsigned int)v1294 >> 23)];
                  v1288->n128_u8[0] = ~(v1293 | (16 * v1295) | (v1294 >> 16 >> (v1295 + 3)) & 0xF);
                  v1288 = (int64x2_t *)((char *)v1288 + 1);
                }
                while ( v1287 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += numchans;
              }
            }
          }
          return;
        case UserFmtShort:
          if ( len )
          {
            for ( i14 = 0; i14 != len; ++i14 )
            {
              if ( numchans )
              {
                v1297 = numchans;
                v1298 = v1687;
                v1299 = v1688;
                do
                {
                  v1301 = *(__int16 *)v1298;
                  v1298 += 2;
                  v1300 = v1301;
                  v1302 = (v1301 >> 8) & 0x80;
                  if ( v1302 )
                  {
                    if ( v1300 <= -32767 )
                      v1300 = -32767;
                    v1300 = -v1300;
                  }
                  v1300 = (__int16)v1300;
                  if ( (__int16)v1300 >= 32635 )
                    v1300 = 32635;
                  --v1297;
                  v1303 = (v1300 << 16) + 8650752;
                  v1304 = muLawCompressTable[(unsigned __int8)((unsigned int)v1303 >> 23)];
                  v1299->n128_u8[0] = ~(v1302 | (16 * v1304) | (v1303 >> 16 >> (v1304 + 3)) & 0xF);
                  v1299 = (int64x2_t *)((char *)v1299 + 1);
                }
                while ( v1297 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += 2 * numchans;
              }
            }
          }
          return;
        case UserFmtUShort:
          if ( len )
          {
            for ( i15 = 0; i15 != len; ++i15 )
            {
              if ( numchans )
              {
                v1306 = numchans;
                v1307 = v1687;
                v1308 = v1688;
                do
                {
                  v1309 = *(_WORD *)v1307;
                  v1307 += 2;
                  LOWORD(v1310) = v1309 + 0x8000;
                  v1311 = (__int16)(v1309 + 0x8000);
                  v1312 = ((unsigned int)v1311 >> 8) & 0x80;
                  if ( v1312 )
                  {
                    if ( v1311 <= -32767 )
                      v1311 = -32767;
                    v1310 = -v1311;
                  }
                  v1310 = (__int16)v1310;
                  if ( (__int16)v1310 >= 32635 )
                    v1310 = 32635;
                  --v1306;
                  v1313 = (v1310 << 16) + 8650752;
                  v1314 = muLawCompressTable[(unsigned __int8)((unsigned int)v1313 >> 23)];
                  v1308->n128_u8[0] = ~(v1312 | (16 * v1314) | (v1313 >> 16 >> (v1314 + 3)) & 0xF);
                  v1308 = (int64x2_t *)((char *)v1308 + 1);
                }
                while ( v1306 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += 2 * numchans;
              }
            }
          }
          return;
        case UserFmtInt:
          if ( len )
          {
            for ( i16 = 0; i16 != len; ++i16 )
            {
              if ( numchans )
              {
                v1316 = numchans;
                v1317 = (int *)v1687;
                v1318 = v1688;
                do
                {
                  v1320 = *v1317++;
                  v1319 = v1320;
                  v1321 = v1320 >> 16;
                  v1322 = ((unsigned int)(v1320 >> 16) >> 8) & 0x80;
                  if ( v1322 )
                  {
                    if ( v1321 <= -32767 )
                      v1321 = -32767;
                    v1323 = -v1321;
                  }
                  else
                  {
                    v1323 = HIWORD(v1319);
                  }
                  v1323 = (__int16)v1323;
                  if ( (__int16)v1323 >= 32635 )
                    v1323 = 32635;
                  --v1316;
                  v1324 = (v1323 << 16) + 8650752;
                  v1325 = muLawCompressTable[(unsigned __int8)((unsigned int)v1324 >> 23)];
                  v1318->n128_u8[0] = ~(v1322 | (16 * v1325) | (v1324 >> 16 >> (v1325 + 3)) & 0xF);
                  v1318 = (int64x2_t *)((char *)v1318 + 1);
                }
                while ( v1316 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += 4 * numchans;
              }
            }
          }
          return;
        case UserFmtUInt:
          if ( len )
          {
            for ( i17 = 0; i17 != len; ++i17 )
            {
              if ( numchans )
              {
                v1327 = numchans;
                v1328 = v1687;
                v1329 = v1688;
                do
                {
                  v1330 = *((_WORD *)v1328 + 1);
                  v1328 += 4;
                  LOWORD(v1331) = v1330 + 0x8000;
                  v1332 = (__int16)(v1330 + 0x8000);
                  v1333 = ((unsigned int)v1332 >> 8) & 0x80;
                  if ( v1333 )
                  {
                    if ( v1332 <= -32767 )
                      v1332 = -32767;
                    v1331 = -v1332;
                  }
                  v1331 = (__int16)v1331;
                  if ( (__int16)v1331 >= 32635 )
                    v1331 = 32635;
                  --v1327;
                  v1334 = (v1331 << 16) + 8650752;
                  v1335 = muLawCompressTable[(unsigned __int8)((unsigned int)v1334 >> 23)];
                  v1329->n128_u8[0] = ~(v1333 | (16 * v1335) | (v1334 >> 16 >> (v1335 + 3)) & 0xF);
                  v1329 = (int64x2_t *)((char *)v1329 + 1);
                }
                while ( v1327 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += 4 * numchans;
              }
            }
          }
          return;
        case UserFmtFloat:
          if ( len )
          {
            for ( i18 = 0; i18 != len; ++i18 )
            {
              if ( numchans )
              {
                v1337 = numchans;
                v1338 = (float *)v1687;
                v1339 = v1688;
                do
                {
                  v1340 = *v1338;
                  if ( *v1338 <= 1.0 )
                  {
                    if ( v1340 >= -1.0 )
                      v1341 = (int)(float)(v1340 * 32767.0);
                    else
                      LOWORD(v1341) = 0x8000;
                  }
                  else
                  {
                    LOWORD(v1341) = 0x7FFF;
                  }
                  v1342 = (__int16)v1341;
                  ++v1338;
                  v1343 = ((unsigned int)(__int16)v1341 >> 8) & 0x80;
                  if ( v1343 )
                  {
                    if ( (__int16)v1341 <= -32767 )
                      v1342 = -32767;
                    v1341 = -v1342;
                  }
                  v1341 = (__int16)v1341;
                  if ( (__int16)v1341 >= 32635 )
                    v1341 = 32635;
                  --v1337;
                  v1344 = (v1341 << 16) + 8650752;
                  v1345 = muLawCompressTable[(unsigned __int8)((unsigned int)v1344 >> 23)];
                  v1339->n128_u8[0] = ~(v1343 | (16 * v1345) | (v1344 >> 16 >> (v1345 + 3)) & 0xF);
                  v1339 = (int64x2_t *)((char *)v1339 + 1);
                }
                while ( v1337 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += 4 * numchans;
              }
            }
          }
          return;
        case UserFmtDouble:
          if ( len )
          {
            for ( i19 = 0; i19 != len; ++i19 )
            {
              if ( numchans )
              {
                v1347 = numchans;
                v1348 = (double *)v1687;
                v1349 = v1688;
                do
                {
                  v1350 = *v1348;
                  if ( *v1348 <= 1.0 )
                  {
                    if ( v1350 >= -1.0 )
                      v1351 = (int)(v1350 * 32767.0);
                    else
                      LOWORD(v1351) = 0x8000;
                  }
                  else
                  {
                    LOWORD(v1351) = 0x7FFF;
                  }
                  v1352 = (__int16)v1351;
                  ++v1348;
                  v1353 = ((unsigned int)(__int16)v1351 >> 8) & 0x80;
                  if ( v1353 )
                  {
                    if ( (__int16)v1351 <= -32767 )
                      v1352 = -32767;
                    v1351 = -v1352;
                  }
                  v1351 = (__int16)v1351;
                  if ( (__int16)v1351 >= 32635 )
                    v1351 = 32635;
                  --v1347;
                  v1354 = (v1351 << 16) + 8650752;
                  v1355 = muLawCompressTable[(unsigned __int8)((unsigned int)v1354 >> 23)];
                  v1349->n128_u8[0] = ~(v1353 | (16 * v1355) | (v1354 >> 16 >> (v1355 + 3)) & 0xF);
                  v1349 = (int64x2_t *)((char *)v1349 + 1);
                }
                while ( v1347 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += 8 * numchans;
              }
            }
          }
          return;
        case UserFmtByte3:
          if ( len )
          {
            for ( i20 = 0; i20 != len; ++i20 )
            {
              if ( numchans )
              {
                v1357 = numchans;
                v1358 = v1687;
                v1359 = v1688;
                do
                {
                  v1360 = v1358[2];
                  v1361 = *(unsigned __int16 *)v1358;
                  v1358 += 3;
                  v1362 = v1361 & 0xFF00 | ((v1361 | (v1360 << 16)) << 8 >> 24 << 16);
                  v1363 = v1362 >> 8;
                  v1364 = ((unsigned int)(v1362 >> 8) >> 8) & 0x80;
                  if ( v1364 )
                  {
                    if ( v1363 <= -32767 )
                      v1363 = -32767;
                    v1365 = -v1363;
                  }
                  else
                  {
                    v1365 = (unsigned int)v1362 >> 8;
                  }
                  v1365 = (__int16)v1365;
                  if ( (__int16)v1365 >= 32635 )
                    v1365 = 32635;
                  --v1357;
                  v1366 = (v1365 << 16) + 8650752;
                  v1367 = muLawCompressTable[(unsigned __int8)((unsigned int)v1366 >> 23)];
                  v1359->n128_u8[0] = ~(v1364 | (16 * v1367) | (v1366 >> 16 >> (v1367 + 3)) & 0xF);
                  v1359 = (int64x2_t *)((char *)v1359 + 1);
                }
                while ( v1357 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += 3 * numchans;
              }
            }
          }
          return;
        case UserFmtUByte3:
          if ( len )
          {
            for ( i21 = 0; i21 != len; ++i21 )
            {
              if ( numchans )
              {
                v1369 = numchans;
                v1371 = v1687;
                v1370 = v1688;
                do
                {
                  v1372 = v1371[2];
                  v1373 = *(unsigned __int16 *)v1371;
                  v1371 += 3;
                  v1374 = ((v1373 | (unsigned int)(v1372 << 16)) >> 8) + 0x8000;
                  v1375 = (__int16)v1374;
                  v1376 = ((unsigned int)(__int16)v1374 >> 8) & 0x80;
                  if ( v1376 )
                  {
                    if ( (__int16)v1374 <= -32767 )
                      v1375 = -32767;
                    v1374 = -v1375;
                  }
                  v1374 = (__int16)v1374;
                  if ( (__int16)v1374 >= 32635 )
                    v1374 = 32635;
                  --v1369;
                  v1377 = (v1374 << 16) + 8650752;
                  v1378 = muLawCompressTable[(unsigned __int8)((unsigned int)v1377 >> 23)];
                  v1370->n128_u8[0] = ~(v1376 | (16 * v1378) | (v1377 >> 16 >> (v1378 + 3)) & 0xF);
                  v1370 = (int64x2_t *)((char *)v1370 + 1);
                }
                while ( v1369 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += 3 * numchans;
              }
            }
          }
          return;
        case UserFmtMulaw:
          if ( !len )
            return;
          v1379 = 0;
          v1380 = numchans & 0xFFFFFFF0;
          break;
        case UserFmtAlaw:
          if ( len )
          {
            for ( i22 = 0; i22 != len; ++i22 )
            {
              if ( numchans )
              {
                v1396 = numchans;
                v1398 = v1687;
                v1397 = v1688;
                do
                {
                  v1399 = *v1398++;
                  v1400 = aLawDecompressionTable[v1399];
                  v1401 = ((unsigned int)v1400 >> 8) & 0x80;
                  if ( v1401 )
                  {
                    if ( v1400 <= -32767 )
                      v1400 = -32767;
                    v1400 = -v1400;
                  }
                  v1400 = (__int16)v1400;
                  if ( (__int16)v1400 >= 32635 )
                    v1400 = 32635;
                  --v1396;
                  v1402 = (v1400 << 16) + 8650752;
                  v1403 = muLawCompressTable[(unsigned __int8)((unsigned int)v1402 >> 23)];
                  v1397->n128_u8[0] = ~(v1401 | (16 * v1403) | (v1402 >> 16 >> (v1403 + 3)) & 0xF);
                  v1397 = (int64x2_t *)((char *)v1397 + 1);
                }
                while ( v1396 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += numchans;
              }
            }
          }
          return;
        case UserFmtIMA4:
          v1404 = len;
          if ( len )
          {
            v1405 = 0;
            do
            {
              v1406 = v1405;
              v1407 = v1404;
              DecodeIMA4Block(v1689, v1687, numchans);
              v1405 = v1406;
              v1687 += 36 * numchans;
              if ( v1406 < v1407 )
              {
                v1408 = v1689;
                v1409 = 0;
                do
                {
                  if ( numchans )
                  {
                    v1686 = v1405;
                    v1410 = numchans;
                    v1411 = v1688;
                    v1412 = v1408;
                    do
                    {
                      v1413 = *v1412;
                      v1414 = ((unsigned int)v1413 >> 8) & 0x80;
                      if ( v1414 )
                      {
                        if ( v1413 <= -32767 )
                          v1413 = -32767;
                        v1413 = -v1413;
                      }
                      v1413 = (__int16)v1413;
                      if ( (__int16)v1413 >= 32635 )
                        v1413 = 32635;
                      --v1410;
                      v1415 = (v1413 << 16) + 8650752;
                      ++v1412;
                      v1416 = muLawCompressTable[(unsigned __int8)((unsigned int)v1415 >> 23)];
                      v1411->n128_u8[0] = ~((v1415 >> 16 >> (v1416 + 3)) & 0xF | v1414 | (16 * v1416));
                      v1411 = (int64x2_t *)((char *)v1411 + 1);
                    }
                    while ( v1410 );
                    v1688 = (int64x2_t *)((char *)v1688 + numchans);
                    v1405 = v1686;
                  }
                  ++v1409;
                  ++v1405;
                  if ( v1409 > 0x40 )
                    break;
                  v1408 += numchans;
                }
                while ( v1405 < len );
              }
              v1404 = len;
            }
            while ( v1405 < len );
          }
          return;
        default:
          return;
      }
      while ( 1 )
      {
        v1388 = numchans;
        if ( numchans )
          break;
LABEL_1953:
        if ( ++v1379 == len )
          return;
      }
      v1389 = 0;
      if ( (unsigned int)numchans < 0x10 )
      {
        v1390 = v1688;
        v1391 = v1687;
      }
      else
      {
        v1390 = v1688;
        v1391 = v1687;
        v1382 = v1688;
        v1381 = v1687;
        if ( !v1380 )
          goto LABEL_1950;
        v1392 = v1688 >= (int64x2_t *)&v1687[numchans];
        if ( v1688 < (int64x2_t *)&v1687[numchans] )
          v1392 = v1687 >= (ALima4 *)v1688 + numchans;
        if ( v1392 )
        {
          v1381 = &v1687[v1380];
          v1382 = (int64x2_t *)((char *)v1688 + v1380);
          v1383 = numchans & 0xFFFFFFF0;
          v1384 = v1688;
          v1385 = v1687;
          do
          {
            v1386 = *(_QWORD *)v1385;
            v1387 = *((_QWORD *)v1385 + 1);
            v1385 += 16;
            v1383 -= 16;
            v1384->n128_u64[0] = v1386;
            v1384->n128_u64[1] = v1387;
            ++v1384;
          }
          while ( v1383 );
          v1388 = numchans;
          v1389 = numchans & 0xFFFFFFF0;
          if ( v1380 == numchans )
            goto LABEL_1952;
          goto LABEL_1950;
        }
        v1389 = 0;
      }
      v1382 = v1390;
      v1381 = v1391;
LABEL_1950:
      v1393 = v1388 - v1389;
      do
      {
        v1394 = *v1381++;
        --v1393;
        v1382->n128_u8[0] = v1394;
        v1382 = (int64x2_t *)((char *)v1382 + 1);
      }
      while ( v1393 );
LABEL_1952:
      v1688 = (int64x2_t *)((char *)v1390 + v1388);
      v1687 = &v1391[v1388];
      goto LABEL_1953;
    case UserFmtAlaw:
      switch ( srcType )
      {
        case UserFmtByte:
          if ( len )
          {
            for ( i23 = 0; i23 != len; ++i23 )
            {
              if ( numchans )
              {
                v91 = v1688;
                v92 = numchans;
                v93 = v1687;
                do
                {
                  v94 = (char)*v93++;
                  v95 = v94 & 0x80;
                  v96 = v94 << 8;
                  if ( (v94 & 0x80) != 0 )
                  {
                    if ( v96 <= -32767 )
                      v96 = -32767;
                    v96 = -v96;
                  }
                  v96 = (__int16)v96;
                  if ( (__int16)v96 >= 32635 )
                    v96 = 32635;
                  v97 = v95 ^ 0x80;
                  if ( v96 < 256 )
                  {
                    v96 >>= 4;
                    v99 = 0;
                  }
                  else
                  {
                    v98 = aLawCompressTable[((unsigned int)v96 >> 8) & 0x7F];
                    v99 = 16 * v98;
                    LOBYTE(v96) = ((unsigned __int16)v96 >> (v98 + 3)) & 0xF;
                  }
                  v91->n128_u8[0] = (v96 | v99) ^ (v97 | 0x55);
                  v91 = (int64x2_t *)((char *)v91 + 1);
                  --v92;
                }
                while ( v92 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += numchans;
              }
            }
          }
          return;
        case UserFmtUByte:
          if ( len )
          {
            for ( i24 = 0; i24 != len; ++i24 )
            {
              if ( numchans )
              {
                v1419 = v1687;
                v1418 = v1688;
                v1420 = numchans;
                do
                {
                  v1421 = *v1419++;
                  LOWORD(v1422) = (v1421 << 8) + 0x8000;
                  v1423 = (__int16)v1422;
                  v1424 = ((unsigned int)(__int16)v1422 >> 8) & 0x80;
                  if ( v1424 )
                  {
                    if ( (__int16)v1422 <= -32767 )
                      v1423 = -32767;
                    v1422 = -v1423;
                  }
                  v1425 = (__int16)v1422;
                  if ( (__int16)v1422 >= 32635 )
                    v1425 = 32635;
                  v1426 = v1424 ^ 0x80;
                  if ( v1425 < 256 )
                  {
                    v1425 >>= 4;
                    v1428 = 0;
                  }
                  else
                  {
                    v1427 = aLawCompressTable[((unsigned int)v1425 >> 8) & 0x7F];
                    v1428 = 16 * v1427;
                    LOBYTE(v1425) = ((unsigned __int16)v1425 >> (v1427 + 3)) & 0xF;
                  }
                  v1418->n128_u8[0] = (v1426 | 0x55) ^ (v1428 | v1425);
                  v1418 = (int64x2_t *)((char *)v1418 + 1);
                  --v1420;
                }
                while ( v1420 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += numchans;
              }
            }
          }
          return;
        case UserFmtShort:
          if ( len )
          {
            for ( i25 = 0; i25 != len; ++i25 )
            {
              if ( numchans )
              {
                v1430 = v1688;
                v1431 = numchans;
                v1432 = v1687;
                do
                {
                  v1434 = *(__int16 *)v1432;
                  v1432 += 2;
                  v1433 = v1434;
                  v1435 = (v1434 >> 8) & 0x80;
                  if ( v1435 )
                  {
                    if ( v1433 <= -32767 )
                      v1433 = -32767;
                    v1433 = -v1433;
                  }
                  v1433 = (__int16)v1433;
                  if ( (__int16)v1433 >= 32635 )
                    v1433 = 32635;
                  v1436 = v1435 ^ 0x80;
                  if ( v1433 < 256 )
                  {
                    v1439 = v1433 >> 4;
                    v1438 = 0;
                  }
                  else
                  {
                    v1437 = aLawCompressTable[((unsigned int)v1433 >> 8) & 0x7F];
                    v1438 = 16 * v1437;
                    v1439 = ((unsigned __int16)v1433 >> (v1437 + 3)) & 0xF;
                  }
                  v1430->n128_u8[0] = (v1438 | v1439) ^ (v1436 | 0x55);
                  v1430 = (int64x2_t *)((char *)v1430 + 1);
                  --v1431;
                }
                while ( v1431 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += 2 * numchans;
              }
            }
          }
          return;
        case UserFmtUShort:
          if ( len )
          {
            for ( i26 = 0; i26 != len; ++i26 )
            {
              if ( numchans )
              {
                v1441 = v1688;
                v1442 = numchans;
                v1443 = v1687;
                do
                {
                  v1444 = *(_WORD *)v1443;
                  v1443 += 2;
                  LOWORD(v1445) = v1444 + 0x8000;
                  v1446 = (__int16)(v1444 + 0x8000);
                  v1447 = ((unsigned int)v1446 >> 8) & 0x80;
                  if ( v1447 )
                  {
                    if ( v1446 <= -32767 )
                      v1446 = -32767;
                    v1445 = -v1446;
                  }
                  v1445 = (__int16)v1445;
                  if ( (__int16)v1445 >= 32635 )
                    v1445 = 32635;
                  v1448 = v1447 ^ 0x80;
                  if ( v1445 < 256 )
                  {
                    v1451 = v1445 >> 4;
                    v1450 = 0;
                  }
                  else
                  {
                    v1449 = aLawCompressTable[((unsigned int)v1445 >> 8) & 0x7F];
                    v1450 = 16 * v1449;
                    v1451 = ((unsigned __int16)v1445 >> (v1449 + 3)) & 0xF;
                  }
                  v1441->n128_u8[0] = (v1450 | v1451) ^ (v1448 | 0x55);
                  v1441 = (int64x2_t *)((char *)v1441 + 1);
                  --v1442;
                }
                while ( v1442 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += 2 * numchans;
              }
            }
          }
          return;
        case UserFmtInt:
          if ( len )
          {
            for ( i27 = 0; i27 != len; ++i27 )
            {
              if ( numchans )
              {
                v1453 = v1688;
                v1454 = numchans;
                v1455 = (int *)v1687;
                do
                {
                  v1457 = *v1455++;
                  v1456 = v1457;
                  v1458 = v1457 >> 16;
                  v1459 = ((unsigned int)(v1457 >> 16) >> 8) & 0x80;
                  if ( v1459 )
                  {
                    if ( v1458 <= -32767 )
                      v1458 = -32767;
                    v1460 = -v1458;
                  }
                  else
                  {
                    v1460 = HIWORD(v1456);
                  }
                  v1460 = (__int16)v1460;
                  if ( (__int16)v1460 >= 32635 )
                    v1460 = 32635;
                  v1461 = v1459 ^ 0x80;
                  if ( v1460 < 256 )
                  {
                    v1464 = v1460 >> 4;
                    v1463 = 0;
                  }
                  else
                  {
                    v1462 = aLawCompressTable[((unsigned int)v1460 >> 8) & 0x7F];
                    v1463 = 16 * v1462;
                    v1464 = ((unsigned __int16)v1460 >> (v1462 + 3)) & 0xF;
                  }
                  v1453->n128_u8[0] = (v1463 | v1464) ^ (v1461 | 0x55);
                  v1453 = (int64x2_t *)((char *)v1453 + 1);
                  --v1454;
                }
                while ( v1454 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += 4 * numchans;
              }
            }
          }
          return;
        case UserFmtUInt:
          if ( len )
          {
            for ( i28 = 0; i28 != len; ++i28 )
            {
              if ( numchans )
              {
                v1466 = v1688;
                v1467 = numchans;
                v1468 = v1687;
                do
                {
                  LOWORD(v1469) = *((_WORD *)v1468 + 1) + 0x8000;
                  v1470 = (__int16)v1469;
                  v1471 = ((unsigned int)(__int16)v1469 >> 8) & 0x80;
                  if ( v1471 )
                  {
                    if ( (__int16)v1469 <= -32767 )
                      v1470 = -32767;
                    v1469 = -v1470;
                  }
                  v1469 = (__int16)v1469;
                  if ( (__int16)v1469 >= 32635 )
                    v1469 = 32635;
                  v1468 += 4;
                  v1472 = v1471 ^ 0x80;
                  if ( v1469 < 256 )
                  {
                    v1475 = v1469 >> 4;
                    v1474 = 0;
                  }
                  else
                  {
                    v1473 = aLawCompressTable[((unsigned int)v1469 >> 8) & 0x7F];
                    v1474 = 16 * v1473;
                    v1475 = ((unsigned __int16)v1469 >> (v1473 + 3)) & 0xF;
                  }
                  v1466->n128_u8[0] = (v1474 | v1475) ^ (v1472 | 0x55);
                  v1466 = (int64x2_t *)((char *)v1466 + 1);
                  --v1467;
                }
                while ( v1467 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += 4 * numchans;
              }
            }
          }
          return;
        case UserFmtFloat:
          if ( len )
          {
            for ( i29 = 0; i29 != len; ++i29 )
            {
              if ( numchans )
              {
                v1477 = v1688;
                v1478 = numchans;
                v1479 = (float *)v1687;
                do
                {
                  v1480 = *v1479;
                  if ( *v1479 <= 1.0 )
                  {
                    if ( v1480 >= -1.0 )
                      v1481 = (int)(float)(v1480 * 32767.0);
                    else
                      LOWORD(v1481) = 0x8000;
                  }
                  else
                  {
                    LOWORD(v1481) = 0x7FFF;
                  }
                  v1482 = (__int16)v1481;
                  v1483 = ((unsigned int)(__int16)v1481 >> 8) & 0x80;
                  if ( v1483 )
                  {
                    if ( (__int16)v1481 <= -32767 )
                      v1482 = -32767;
                    v1481 = -v1482;
                  }
                  v1484 = v1483 ^ 0x80;
                  v1485 = (__int16)v1481;
                  ++v1479;
                  if ( (__int16)v1481 >= 32635 )
                    v1485 = 32635;
                  if ( v1485 < 256 )
                  {
                    v1488 = v1485 >> 4;
                    v1487 = 0;
                  }
                  else
                  {
                    v1486 = aLawCompressTable[((unsigned int)v1485 >> 8) & 0x7F];
                    v1487 = 16 * v1486;
                    v1488 = ((unsigned __int16)v1485 >> (v1486 + 3)) & 0xF;
                  }
                  v1477->n128_u8[0] = (v1487 | v1488) ^ (v1484 | 0x55);
                  v1477 = (int64x2_t *)((char *)v1477 + 1);
                  --v1478;
                }
                while ( v1478 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += 4 * numchans;
              }
            }
          }
          return;
        case UserFmtDouble:
          if ( len )
          {
            for ( i30 = 0; i30 != len; ++i30 )
            {
              if ( numchans )
              {
                v1490 = v1688;
                v1491 = numchans;
                v1492 = (double *)v1687;
                do
                {
                  v1493 = *v1492;
                  if ( *v1492 <= 1.0 )
                  {
                    if ( v1493 >= -1.0 )
                      v1494 = (int)(v1493 * 32767.0);
                    else
                      LOWORD(v1494) = 0x8000;
                  }
                  else
                  {
                    LOWORD(v1494) = 0x7FFF;
                  }
                  v1495 = (__int16)v1494;
                  v1496 = ((unsigned int)(__int16)v1494 >> 8) & 0x80;
                  if ( v1496 )
                  {
                    if ( (__int16)v1494 <= -32767 )
                      v1495 = -32767;
                    v1494 = -v1495;
                  }
                  v1497 = v1496 ^ 0x80;
                  v1498 = (__int16)v1494;
                  ++v1492;
                  if ( (__int16)v1494 >= 32635 )
                    v1498 = 32635;
                  if ( v1498 < 256 )
                  {
                    v1501 = v1498 >> 4;
                    v1500 = 0;
                  }
                  else
                  {
                    v1499 = aLawCompressTable[((unsigned int)v1498 >> 8) & 0x7F];
                    v1500 = 16 * v1499;
                    v1501 = ((unsigned __int16)v1498 >> (v1499 + 3)) & 0xF;
                  }
                  v1490->n128_u8[0] = (v1500 | v1501) ^ (v1497 | 0x55);
                  v1490 = (int64x2_t *)((char *)v1490 + 1);
                  --v1491;
                }
                while ( v1491 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += 8 * numchans;
              }
            }
          }
          return;
        case UserFmtByte3:
          if ( len )
          {
            for ( i31 = 0; i31 != len; ++i31 )
            {
              if ( numchans )
              {
                v1503 = v1688;
                v1504 = numchans;
                v1505 = v1687;
                do
                {
                  v1506 = *(_WORD *)v1505 & 0xFF00 | ((*(unsigned __int16 *)v1505 | (v1505[2] << 16)) << 8 >> 24 << 16);
                  v1507 = v1506 >> 8;
                  v1508 = ((unsigned int)(v1506 >> 8) >> 8) & 0x80;
                  if ( v1508 )
                  {
                    if ( v1507 <= -32767 )
                      v1507 = -32767;
                    v1509 = -v1507;
                  }
                  else
                  {
                    v1509 = (unsigned int)v1506 >> 8;
                  }
                  v1509 = (__int16)v1509;
                  if ( (__int16)v1509 >= 32635 )
                    v1509 = 32635;
                  v1505 += 3;
                  v1510 = v1508 ^ 0x80;
                  if ( v1509 < 256 )
                  {
                    v1513 = v1509 >> 4;
                    v1512 = 0;
                  }
                  else
                  {
                    v1511 = aLawCompressTable[((unsigned int)v1509 >> 8) & 0x7F];
                    v1512 = 16 * v1511;
                    v1513 = ((unsigned __int16)v1509 >> (v1511 + 3)) & 0xF;
                  }
                  v1503->n128_u8[0] = (v1512 | v1513) ^ (v1510 | 0x55);
                  v1503 = (int64x2_t *)((char *)v1503 + 1);
                  --v1504;
                }
                while ( v1504 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += 3 * numchans;
              }
            }
          }
          return;
        case UserFmtUByte3:
          if ( len )
          {
            for ( i32 = 0; i32 != len; ++i32 )
            {
              if ( numchans )
              {
                v1516 = v1687;
                v1515 = v1688;
                v1517 = numchans;
                do
                {
                  v1518 = ((unsigned int)(*(unsigned __int16 *)v1516 | (v1516[2] << 16)) >> 8) + 0x8000;
                  v1519 = (__int16)v1518;
                  v1520 = ((unsigned int)(__int16)v1518 >> 8) & 0x80;
                  if ( v1520 )
                  {
                    if ( (__int16)v1518 <= -32767 )
                      v1519 = -32767;
                    v1518 = -v1519;
                  }
                  v1521 = (__int16)v1518;
                  if ( (__int16)v1518 >= 32635 )
                    v1521 = 32635;
                  v1516 += 3;
                  v1522 = v1520 ^ 0x80;
                  if ( v1521 < 256 )
                  {
                    v1521 >>= 4;
                    v1524 = 0;
                  }
                  else
                  {
                    v1523 = aLawCompressTable[((unsigned int)v1521 >> 8) & 0x7F];
                    v1524 = 16 * v1523;
                    LOBYTE(v1521) = ((unsigned __int16)v1521 >> (v1523 + 3)) & 0xF;
                  }
                  v1515->n128_u8[0] = (v1522 | 0x55) ^ (v1524 | v1521);
                  v1515 = (int64x2_t *)((char *)v1515 + 1);
                  --v1517;
                }
                while ( v1517 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += 3 * numchans;
              }
            }
          }
          return;
        case UserFmtMulaw:
          if ( len )
          {
            for ( i33 = 0; i33 != len; ++i33 )
            {
              if ( numchans )
              {
                v1527 = v1687;
                v1526 = v1688;
                v1528 = numchans;
                do
                {
                  v1529 = *v1527++;
                  v1530 = muLawDecompressionTable[v1529];
                  v1531 = ((unsigned int)v1530 >> 8) & 0x80;
                  if ( v1531 )
                  {
                    if ( v1530 <= -32767 )
                      v1530 = -32767;
                    v1530 = -v1530;
                  }
                  v1532 = (__int16)v1530;
                  if ( (__int16)v1530 >= 32635 )
                    v1532 = 32635;
                  v1533 = v1531 ^ 0x80;
                  if ( v1532 < 256 )
                  {
                    v1532 >>= 4;
                    v1535 = 0;
                  }
                  else
                  {
                    v1534 = aLawCompressTable[((unsigned int)v1532 >> 8) & 0x7F];
                    v1535 = 16 * v1534;
                    LOBYTE(v1532) = ((unsigned __int16)v1532 >> (v1534 + 3)) & 0xF;
                  }
                  v1526->n128_u8[0] = (v1533 | 0x55) ^ (v1535 | v1532);
                  v1526 = (int64x2_t *)((char *)v1526 + 1);
                  --v1528;
                }
                while ( v1528 );
                v1688 = (int64x2_t *)((char *)v1688 + numchans);
                v1687 += numchans;
              }
            }
          }
          return;
        case UserFmtAlaw:
          if ( !len )
            return;
          v1536 = 0;
          v1537 = numchans & 0xFFFFFFF0;
          break;
        case UserFmtIMA4:
          v1552 = len;
          v1553 = numchans;
          if ( len )
          {
            v1554 = 0;
            do
            {
              v1555 = v1552;
              DecodeIMA4Block(v1689, v1687, v1553);
              v1687 += 36 * numchans;
              if ( v1554 >= v1555 )
              {
                v1553 = numchans;
              }
              else
              {
                v1553 = numchans;
                v1556 = v1689;
                v1557 = 0;
                do
                {
                  if ( v1553 )
                  {
                    v1558 = v1688;
                    v1559 = v1553;
                    v1560 = v1556;
                    do
                    {
                      v1561 = *v1560;
                      v1562 = ((unsigned int)v1561 >> 8) & 0x80;
                      if ( v1562 )
                      {
                        if ( v1561 <= -32767 )
                          v1561 = -32767;
                        v1561 = -v1561;
                      }
                      v1561 = (__int16)v1561;
                      if ( (__int16)v1561 >= 32635 )
                        v1561 = 32635;
                      v1563 = v1562 ^ 0x80;
                      if ( v1561 < 256 )
                      {
                        v1566 = v1561 >> 4;
                        v1565 = 0;
                      }
                      else
                      {
                        v1564 = aLawCompressTable[((unsigned int)v1561 >> 8) & 0x7F];
                        v1565 = 16 * v1564;
                        v1566 = ((unsigned __int16)v1561 >> (v1564 + 3)) & 0xF;
                      }
                      v1558->n128_u8[0] = (v1565 | v1566) ^ (v1563 | 0x55);
                      v1558 = (int64x2_t *)((char *)v1558 + 1);
                      v1553 = numchans;
                      --v1559;
                      ++v1560;
                    }
                    while ( v1559 );
                    v1688 = (int64x2_t *)((char *)v1688 + numchans);
                  }
                  ++v1557;
                  ++v1554;
                  if ( v1557 > 0x40 )
                    break;
                  v1556 += numchans;
                }
                while ( v1554 < len );
              }
              v1552 = len;
            }
            while ( v1554 < len );
          }
          return;
        default:
          return;
      }
      while ( 1 )
      {
        v1545 = numchans;
        if ( numchans )
          break;
LABEL_2187:
        if ( ++v1536 == len )
          return;
      }
      v1546 = 0;
      if ( (unsigned int)numchans < 0x10 )
      {
        v1547 = v1688;
        v1548 = v1687;
      }
      else
      {
        v1547 = v1688;
        v1548 = v1687;
        v1539 = v1688;
        v1538 = v1687;
        if ( !v1537 )
          goto LABEL_2184;
        v1549 = v1688 >= (int64x2_t *)&v1687[numchans];
        if ( v1688 < (int64x2_t *)&v1687[numchans] )
          v1549 = v1687 >= (ALima4 *)v1688 + numchans;
        if ( v1549 )
        {
          v1538 = &v1687[v1537];
          v1539 = (int64x2_t *)((char *)v1688 + v1537);
          v1540 = numchans & 0xFFFFFFF0;
          v1541 = v1688;
          v1542 = v1687;
          do
          {
            v1543 = *(_QWORD *)v1542;
            v1544 = *((_QWORD *)v1542 + 1);
            v1542 += 16;
            v1540 -= 16;
            v1541->n128_u64[0] = v1543;
            v1541->n128_u64[1] = v1544;
            ++v1541;
          }
          while ( v1540 );
          v1545 = numchans;
          v1546 = numchans & 0xFFFFFFF0;
          if ( v1537 == numchans )
            goto LABEL_2186;
          goto LABEL_2184;
        }
        v1546 = 0;
      }
      v1539 = v1547;
      v1538 = v1548;
LABEL_2184:
      v1550 = v1545 - v1546;
      do
      {
        v1551 = *v1538++;
        --v1550;
        v1539->n128_u8[0] = v1551;
        v1539 = (int64x2_t *)((char *)v1539 + 1);
      }
      while ( v1550 );
LABEL_2186:
      v1688 = (int64x2_t *)((char *)v1547 + v1545);
      v1687 = &v1548[v1545];
      goto LABEL_2187;
    case UserFmtIMA4:
      switch ( srcType )
      {
        case UserFmtByte:
          sample = 0LL;
          v1696 = 0LL;
          index = 0LL;
          v1691 = 0LL;
          v1697 = 0LL;
          v1698 = 0LL;
          v1692 = 0LL;
          v1693 = 0LL;
          v1699 = 0;
          v1694 = 0;
          v100 = (ALima4 *)dst;
          if ( !len )
            return;
          v101 = 0;
          v102 = 65 * numchans;
          v103 = (65 * numchans) & 0xFFFFFFF8;
          while ( !v102 )
          {
LABEL_154:
            EncodeIMA4Block(v100, v1689, (ALint *)&sample, (ALint *)&index, numchans);
            v101 += 65;
            v100 += 36 * numchans;
            if ( v101 >= len )
              return;
          }
          v104 = 0;
          if ( v102 < 8 )
          {
            v105 = v1687;
          }
          else
          {
            v105 = v1687;
            if ( v103 )
            {
              v106 = (int8x8_t *)v1687;
              if ( &v1687[v102] <= (ALima4 *)v1689 || v1687 >= (ALima4 *)&v1689[65 * numchans] )
              {
                v105 = &v1687[v103];
                v107 = (int16x8_t *)v1689;
                v108 = (65 * numchans) & 0xFFFFFFF8;
                do
                {
                  v109.n64_u64[0] = v106->n64_u64[0];
                  ++v106;
                  v108 -= 8;
                  *v107++ = vshll_n_s8(v109, 8u);
                }
                while ( v108 );
                v104 = (65 * numchans) & 0xFFFFFFF8;
                if ( v102 == v103 )
                  goto LABEL_153;
              }
              else
              {
                v104 = 0;
                v105 = v1687;
              }
            }
          }
          v110 = &v1689[v104];
          v111 = v102 - v104;
          do
          {
            v112 = *v105++;
            --v111;
            *v110++ = v112 << 8;
          }
          while ( v111 );
LABEL_153:
          v1687 += v102;
          goto LABEL_154;
        case UserFmtUByte:
          sample = 0LL;
          v1696 = 0LL;
          index = 0LL;
          v1691 = 0LL;
          v1697 = 0LL;
          v1698 = 0LL;
          v1692 = 0LL;
          v1693 = 0LL;
          v1699 = 0;
          v1694 = 0;
          v1567 = (ALima4 *)dst;
          if ( !len )
            return;
          v1568.n128_u64[0] = 0x800000008000LL;
          v1568.n128_u64[1] = 0x800000008000LL;
          v1569 = 0;
          v1570 = 65 * numchans;
          v1571 = (65 * numchans) & 0xFFFFFFF8;
          while ( !v1570 )
          {
LABEL_2227:
            EncodeIMA4Block(v1567, v1689, (ALint *)&sample, (ALint *)&index, numchans);
            v1569 += 65;
            v1567 += 36 * numchans;
            if ( v1569 >= len )
              return;
          }
          v1572 = 0;
          if ( v1570 < 8 )
          {
            v1573 = v1687;
          }
          else
          {
            v1573 = v1687;
            if ( v1571 )
            {
              v1574 = (uint8x8_t *)v1687;
              if ( &v1687[v1570] <= (ALima4 *)v1689 || v1687 >= (ALima4 *)&v1689[65 * numchans] )
              {
                v1573 = &v1687[v1571];
                v1575 = (int16x4_t *)v1689;
                v1576 = (65 * numchans) & 0xFFFFFFF8;
                do
                {
                  v1577.n64_u64[0] = v1574->n64_u64[0];
                  ++v1574;
                  v1576 -= 8;
                  v1578 = vmovl_u8(v1577);
                  v1575->n64_u64[0] = vmovn_s32(vaddq_s32(vshll_n_u16((uint16x4_t)v1578.n128_u64[0], 8u), v1568)).n64_u64[0];
                  v1575[1].n64_u64[0] = vmovn_s32(vaddq_s32(vshll_n_u16(*(uint16x4_t *)&v1578.n128_i8[8], 8u), v1568)).n64_u64[0];
                  v1575 += 2;
                }
                while ( v1576 );
                v1572 = (65 * numchans) & 0xFFFFFFF8;
                if ( v1570 == v1571 )
                  goto LABEL_2226;
              }
              else
              {
                v1572 = 0;
                v1573 = v1687;
              }
            }
          }
          v1579 = &v1689[v1572];
          v1580 = v1570 - v1572;
          do
          {
            v1581 = *v1573++;
            --v1580;
            *v1579++ = (v1581 << 8) + 0x8000;
          }
          while ( v1580 );
LABEL_2226:
          v1687 += v1570;
          goto LABEL_2227;
        case UserFmtShort:
          sample = 0LL;
          v1696 = 0LL;
          index = 0LL;
          v1691 = 0LL;
          v1697 = 0LL;
          v1698 = 0LL;
          v1692 = 0LL;
          v1693 = 0LL;
          v1699 = 0;
          v1694 = 0;
          v1582 = (ALima4 *)dst;
          if ( !len )
            return;
          v1583 = 0;
          v1584 = 65 * numchans;
          v1585 = (65 * numchans) & 0xFFFFFFF8;
          while ( !v1584 )
          {
LABEL_2245:
            EncodeIMA4Block(v1582, v1689, (ALint *)&sample, (ALint *)&index, numchans);
            v1583 += 65;
            v1582 += 36 * numchans;
            if ( v1583 >= len )
              return;
          }
          v1586 = 0;
          if ( v1584 < 8 )
          {
            v1587 = v1687;
          }
          else
          {
            v1587 = v1687;
            if ( v1585 )
            {
              v1588 = v1687;
              v1589 = &v1687[130 * numchans];
              v1590 = v1689 >= (ALshort *)v1589;
              if ( v1689 < (ALshort *)v1589 )
                v1590 = v1687 >= (ALima4 *)&v1689[65 * numchans];
              if ( v1590 )
              {
                v1587 = &v1687[2 * v1585];
                v1591 = v1689;
                v1592 = (65 * numchans) & 0xFFFFFFF8;
                do
                {
                  v1593 = *(_QWORD *)v1588;
                  v1594 = *((_QWORD *)v1588 + 1);
                  v1588 += 16;
                  v1592 -= 8;
                  *(_QWORD *)v1591 = v1593;
                  *((_QWORD *)v1591 + 1) = v1594;
                  v1591 += 8;
                }
                while ( v1592 );
                v1586 = (65 * numchans) & 0xFFFFFFF8;
                if ( v1584 == v1585 )
                  goto LABEL_2244;
              }
              else
              {
                v1586 = 0;
                v1587 = v1687;
              }
            }
          }
          v1595 = &v1689[v1586];
          v1596 = v1584 - v1586;
          do
          {
            v1597 = *(_WORD *)v1587;
            v1587 += 2;
            --v1596;
            *v1595++ = v1597;
          }
          while ( v1596 );
LABEL_2244:
          v1687 += 130 * numchans;
          goto LABEL_2245;
        case UserFmtUShort:
          sample = 0LL;
          v1696 = 0LL;
          index = 0LL;
          v1691 = 0LL;
          v1697 = 0LL;
          v1698 = 0LL;
          v1692 = 0LL;
          v1693 = 0LL;
          v1699 = 0;
          v1694 = 0;
          v1598 = (ALima4 *)dst;
          if ( !len )
            return;
          v1599 = 0;
          v1600 = 65 * numchans;
          v1601 = (65 * numchans) & 0xFFFFFFF8;
          while ( !v1600 )
          {
LABEL_2263:
            EncodeIMA4Block(v1598, v1689, (ALint *)&sample, (ALint *)&index, numchans);
            v1599 += 65;
            v1598 += 36 * numchans;
            if ( v1599 >= len )
              return;
          }
          v1602 = 0;
          if ( v1600 < 8 )
          {
            v1603 = v1687;
          }
          else
          {
            v1603 = v1687;
            if ( v1601 )
            {
              v1604 = v1687;
              v1605 = &v1687[130 * numchans];
              v1606 = v1689 >= (ALshort *)v1605;
              if ( v1689 < (ALshort *)v1605 )
                v1606 = v1687 >= (ALima4 *)&v1689[65 * numchans];
              if ( v1606 )
              {
                v1603 = &v1687[2 * v1601];
                v1607 = v1689;
                v1608 = (65 * numchans) & 0xFFFFFFF8;
                do
                {
                  v1609 = *(_QWORD *)v1604;
                  v1610 = *((_QWORD *)v1604 + 1);
                  v1604 += 16;
                  v1608 -= 8;
                  *(_QWORD *)v1607 = v1609 | 0x8000800080008000LL;
                  *((_QWORD *)v1607 + 1) = v1610 | 0x8000800080008000LL;
                  v1607 += 8;
                }
                while ( v1608 );
                v1602 = (65 * numchans) & 0xFFFFFFF8;
                if ( v1600 == v1601 )
                  goto LABEL_2262;
              }
              else
              {
                v1602 = 0;
                v1603 = v1687;
              }
            }
          }
          v1611 = &v1689[v1602];
          v1612 = v1600 - v1602;
          do
          {
            v1613 = *(_WORD *)v1603;
            v1603 += 2;
            --v1612;
            *v1611++ = v1613 + 0x8000;
          }
          while ( v1612 );
LABEL_2262:
          v1687 += 130 * numchans;
          goto LABEL_2263;
        case UserFmtInt:
          sample = 0LL;
          v1696 = 0LL;
          index = 0LL;
          v1691 = 0LL;
          v1697 = 0LL;
          v1698 = 0LL;
          v1692 = 0LL;
          v1693 = 0LL;
          v1699 = 0;
          v1694 = 0;
          v1614 = (ALima4 *)dst;
          if ( !len )
            return;
          v1615 = 0;
          v1616 = 65 * numchans;
          v1617 = (65 * numchans) & 0xFFFFFFFC;
          while ( !v1616 )
          {
LABEL_2281:
            EncodeIMA4Block(v1614, v1689, (ALint *)&sample, (ALint *)&index, numchans);
            v1615 += 65;
            v1614 += 36 * numchans;
            if ( v1615 >= len )
              return;
          }
          v1618 = 0;
          if ( v1616 < 4 )
          {
            v1619 = v1687;
          }
          else
          {
            v1619 = v1687;
            if ( v1617 )
            {
              v1620 = (int32x4_t *)v1687;
              v1621 = &v1687[260 * numchans];
              v1622 = v1689 >= (ALshort *)v1621;
              if ( v1689 < (ALshort *)v1621 )
                v1622 = v1687 >= (ALima4 *)&v1689[65 * numchans];
              if ( v1622 )
              {
                v1619 = &v1687[4 * v1617];
                v1623 = (int16x4_t *)v1689;
                v1624 = (65 * numchans) & 0xFFFFFFFC;
                do
                {
                  v1625 = *v1620++;
                  v1624 -= 4;
                  v1623->n64_u64[0] = vshrn_n_s32(v1625, 0x10u).n64_u64[0];
                  ++v1623;
                }
                while ( v1624 );
                v1618 = (65 * numchans) & 0xFFFFFFFC;
                if ( v1616 == v1617 )
                  goto LABEL_2280;
              }
              else
              {
                v1618 = 0;
                v1619 = v1687;
              }
            }
          }
          v1626 = &v1689[v1618];
          v1627 = v1616 - v1618;
          do
          {
            --v1627;
            *v1626++ = *((_WORD *)v1619 + 1);
            v1619 += 4;
          }
          while ( v1627 );
LABEL_2280:
          v1687 += 260 * numchans;
          goto LABEL_2281;
        case UserFmtUInt:
          sample = 0LL;
          v1696 = 0LL;
          index = 0LL;
          v1691 = 0LL;
          v1697 = 0LL;
          v1698 = 0LL;
          v1692 = 0LL;
          v1693 = 0LL;
          v1699 = 0;
          v1694 = 0;
          v1628 = (ALima4 *)dst;
          if ( !len )
            return;
          v1629 = 0;
          v1630 = 65 * numchans;
          v1631 = (65 * numchans) & 0xFFFFFFFC;
          break;
        case UserFmtFloat:
          sample = 0LL;
          v1696 = 0LL;
          index = 0LL;
          v1691 = 0LL;
          v1697 = 0LL;
          v1698 = 0LL;
          v1692 = 0LL;
          v1693 = 0LL;
          v1699 = 0;
          v1694 = 0;
          v1644 = (ALima4 *)dst;
          if ( len )
          {
            for ( i34 = 0; i34 < len; i34 += 65 )
            {
              if ( 65 * numchans )
              {
                v1646 = (float *)v1687;
                v1647 = v1689;
                v1648 = 65 * numchans;
                do
                {
                  v1649 = *v1646++;
                  if ( v1649 <= 1.0 )
                  {
                    if ( v1649 >= -1.0 )
                      v1650 = (int)(float)(v1649 * 32767.0);
                    else
                      LOWORD(v1650) = 0x8000;
                  }
                  else
                  {
                    LOWORD(v1650) = 0x7FFF;
                  }
                  *v1647++ = v1650;
                  --v1648;
                }
                while ( v1648 );
                v1687 += 260 * numchans;
              }
              EncodeIMA4Block(v1644, v1689, (ALint *)&sample, (ALint *)&index, numchans);
              v1644 += 36 * numchans;
            }
          }
          return;
        case UserFmtDouble:
          sample = 0LL;
          v1696 = 0LL;
          index = 0LL;
          v1691 = 0LL;
          v1697 = 0LL;
          v1698 = 0LL;
          v1692 = 0LL;
          v1693 = 0LL;
          v1699 = 0;
          v1694 = 0;
          v1651 = (ALima4 *)dst;
          if ( len )
          {
            for ( i35 = 0; i35 < len; i35 += 65 )
            {
              if ( 65 * numchans )
              {
                v1653 = (double *)v1687;
                v1654 = v1689;
                v1655 = 65 * numchans;
                do
                {
                  v1656 = *v1653++;
                  if ( v1656 <= 1.0 )
                  {
                    if ( v1656 >= -1.0 )
                      v1657 = (int)(v1656 * 32767.0);
                    else
                      LOWORD(v1657) = 0x8000;
                  }
                  else
                  {
                    LOWORD(v1657) = 0x7FFF;
                  }
                  *v1654++ = v1657;
                  --v1655;
                }
                while ( v1655 );
                v1687 += 520 * numchans;
              }
              EncodeIMA4Block(v1651, v1689, (ALint *)&sample, (ALint *)&index, numchans);
              v1651 += 36 * numchans;
            }
          }
          return;
        case UserFmtByte3:
          sample = 0LL;
          v1696 = 0LL;
          index = 0LL;
          v1691 = 0LL;
          v1697 = 0LL;
          v1698 = 0LL;
          v1692 = 0LL;
          v1693 = 0LL;
          v1699 = 0;
          v1694 = 0;
          if ( len )
          {
            for ( i36 = 0; i36 < len; i36 += 65 )
            {
              if ( 65 * numchans )
              {
                v1659 = v1687;
                v1660 = v1689;
                v1661 = 65 * numchans;
                do
                {
                  v1662 = v1659[2];
                  --v1661;
                  v1663 = *(unsigned __int16 *)v1659;
                  v1659 += 3;
                  *v1660++ = (v1663 | (unsigned int)(v1662 << 16)) >> 8;
                }
                while ( v1661 );
                v1687 += 195 * numchans;
              }
              v1664 = (char *)dst;
              EncodeIMA4Block((ALima4 *)dst, v1689, (ALint *)&sample, (ALint *)&index, numchans);
              dst = &v1664[36 * numchans];
            }
          }
          return;
        case UserFmtUByte3:
          sample = 0LL;
          v1696 = 0LL;
          index = 0LL;
          v1691 = 0LL;
          v1697 = 0LL;
          v1698 = 0LL;
          v1692 = 0LL;
          v1693 = 0LL;
          v1699 = 0;
          v1694 = 0;
          if ( len )
          {
            for ( i37 = 0; i37 < len; i37 += 65 )
            {
              if ( 65 * numchans )
              {
                v1666 = v1687;
                v1667 = v1689;
                v1668 = 65 * numchans;
                do
                {
                  v1669 = v1666[2];
                  --v1668;
                  v1670 = *(unsigned __int16 *)v1666;
                  v1666 += 3;
                  *v1667++ = ((v1670 | (unsigned int)(v1669 << 16)) >> 8) + 0x8000;
                }
                while ( v1668 );
                v1687 += 195 * numchans;
              }
              v1671 = (char *)dst;
              EncodeIMA4Block((ALima4 *)dst, v1689, (ALint *)&sample, (ALint *)&index, numchans);
              dst = &v1671[36 * numchans];
            }
          }
          return;
        case UserFmtMulaw:
          sample = 0LL;
          v1696 = 0LL;
          index = 0LL;
          v1691 = 0LL;
          v1697 = 0LL;
          v1698 = 0LL;
          v1692 = 0LL;
          v1693 = 0LL;
          v1699 = 0;
          v1694 = 0;
          v1672 = (ALima4 *)dst;
          if ( len )
          {
            v1673 = 0;
            v1674 = 65 * numchans;
            do
            {
              if ( v1674 )
              {
                v1675 = v1687;
                v1676 = v1689;
                v1677 = 65 * numchans;
                do
                {
                  v1678 = *v1675++;
                  --v1677;
                  *v1676++ = muLawDecompressionTable[v1678];
                }
                while ( v1677 );
                v1687 += v1674;
              }
              EncodeIMA4Block(v1672, v1689, (ALint *)&sample, (ALint *)&index, numchans);
              v1673 += 65;
              v1672 += 36 * numchans;
            }
            while ( v1673 < len );
          }
          return;
        case UserFmtAlaw:
          sample = 0LL;
          v1696 = 0LL;
          index = 0LL;
          v1691 = 0LL;
          v1697 = 0LL;
          v1698 = 0LL;
          v1692 = 0LL;
          v1693 = 0LL;
          v1699 = 0;
          v1694 = 0;
          v1679 = (ALima4 *)dst;
          if ( len )
          {
            v1680 = 0;
            v1681 = 65 * numchans;
            do
            {
              if ( v1681 )
              {
                v1682 = v1687;
                v1683 = v1689;
                v1684 = 65 * numchans;
                do
                {
                  v1685 = *v1682++;
                  --v1684;
                  *v1683++ = aLawDecompressionTable[v1685];
                }
                while ( v1684 );
                v1687 += v1681;
              }
              EncodeIMA4Block(v1679, v1689, (ALint *)&sample, (ALint *)&index, numchans);
              v1680 += 65;
              v1679 += 36 * numchans;
            }
            while ( v1680 < len );
          }
          return;
        case UserFmtIMA4:
          sub_19EA98(dst, src, 36 * len * numchans);
          return;
        default:
          return;
      }
      break;
    default:
      return;
  }
  do
  {
    if ( !v1630 )
      goto LABEL_2299;
    v1632 = 0;
    if ( v1630 < 4 )
    {
      v1633 = v1687;
    }
    else
    {
      v1633 = v1687;
      if ( v1631 )
      {
        v1634 = (uint32x4_t *)v1687;
        v1635 = &v1687[260 * numchans];
        v1636 = v1689 >= (ALshort *)v1635;
        if ( v1689 < (ALshort *)v1635 )
          v1636 = v1687 >= (ALima4 *)&v1689[65 * numchans];
        if ( v1636 )
        {
          v1633 = &v1687[4 * v1631];
          v1637 = (int16x4_t *)v1689;
          v1638 = (65 * numchans) & 0xFFFFFFFC;
          do
          {
            v1639 = *v1634++;
            v1640.n128_u64[0] = 0x800000008000LL;
            v1640.n128_u64[1] = 0x800000008000LL;
            v1638 -= 4;
            v1637->n64_u64[0] = vmovn_s32(vsraq_n_u32(v1640, v1639, 0x10u)).n64_u64[0];
            ++v1637;
          }
          while ( v1638 );
          v1632 = (65 * numchans) & 0xFFFFFFFC;
          if ( v1630 == v1631 )
            goto LABEL_2298;
        }
        else
        {
          v1632 = 0;
          v1633 = v1687;
        }
      }
    }
    v1641 = &v1689[v1632];
    v1642 = v1630 - v1632;
    do
    {
      v1643 = *((_WORD *)v1633 + 1);
      --v1642;
      v1633 += 4;
      *v1641++ = v1643 + 0x8000;
    }
    while ( v1642 );
LABEL_2298:
    v1687 += 260 * numchans;
LABEL_2299:
    EncodeIMA4Block(v1628, v1689, (ALint *)&sample, (ALint *)&index, numchans);
    v1629 += 65;
    v1628 += 36 * numchans;
  }
  while ( v1629 < len );
}
// 2406CC: variable 'v6' is possibly undefined
// 2407AC: variable 'v7' is possibly undefined

//----- (00246148) --------------------------------------------------------
void __fastcall alBufferSamplesSOFT(
        ALuint buffer,
        ALuint samplerate,
        ALenum internalformat,
        ALsizei samples,
        UserFmtChannels SrcChannels,
        UserFmtType a6,
        const ALvoid *a7)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v11; // r11
  ALbuffer_0 *v12; // r0
  bool v13; // cf
  unsigned int *p_LastError; // r0
  unsigned int *v18; // r0
  unsigned int *v21; // r0
  ALenum Data; // r0
  unsigned int v24; // r5
  unsigned int *v26; // r0

  ContextRef = j_GetContextRef();
  v11 = ContextRef;
  if ( ContextRef )
  {
    v12 = (ALbuffer_0 *)j_LookupUIntMapKey(&ContextRef->Device->BufferMap, buffer);
    if ( v12 )
    {
      if ( samplerate && samples > -1 )
      {
        v13 = (unsigned int)(SrcChannels - 5376) >= 6;
        if ( (unsigned int)(SrcChannels - 5376) <= 6 )
          v13 = (unsigned int)(a6 - 5120) >= 0xA;
        if ( v13 )
        {
          if ( TrapALError )
            raise(5);
          if ( !__ldrex((unsigned int *)&v11->ref) )
          {
            p_LastError = (unsigned int *)&v11->LastError;
            __dmb(0xBu);
            while ( __strex(0xA002u, p_LastError) )
            {
              if ( __ldrex(p_LastError) )
                goto LABEL_38;
            }
            goto LABEL_39;
          }
        }
        else
        {
          Data = LoadData(v12, samplerate, internalformat, samples, SrcChannels, a6, a7, 0);
          v24 = Data;
          if ( !Data )
            goto LABEL_40;
          if ( TrapALError )
            raise(5);
          if ( !__ldrex((unsigned int *)&v11->ref) )
          {
            v26 = (unsigned int *)&v11->LastError;
            __dmb(0xBu);
            while ( __strex(v24, v26) )
            {
              if ( __ldrex(v26) )
                goto LABEL_38;
            }
            goto LABEL_39;
          }
        }
      }
      else
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v11->ref) )
        {
          v21 = (unsigned int *)&v11->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, v21) )
          {
            if ( __ldrex(v21) )
              goto LABEL_38;
          }
          goto LABEL_39;
        }
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v11->ref) )
      {
        v18 = (unsigned int *)&v11->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v18) )
        {
          if ( __ldrex(v18) )
            goto LABEL_38;
        }
        goto LABEL_39;
      }
    }
LABEL_38:
    __clrex();
LABEL_39:
    __dmb(0xBu);
LABEL_40:
    ALCcontext_DecRef(v11);
  }
}

//----- (002462B0) --------------------------------------------------------
void __fastcall alBufferSubSamplesSOFT(
        ALuint buffer,
        ALsizei offset,
        ALsizei samples,
        ALenum channels,
        UserFmtType a5,
        const ALvoid *a6)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v11; // r11
  char *v12; // r0
  unsigned int *v13; // r9
  unsigned int v14; // r0
  unsigned int *v15; // r5
  unsigned int v16; // r0
  unsigned int v17; // r0
  char *v18; // r5
  unsigned int *v19; // r10
  unsigned int v20; // r0
  unsigned int v21; // r0
  __int64 v22; // kr00_8
  int v23; // r0
  unsigned int *v25; // r0
  unsigned int *p_LastError; // r0
  unsigned int *v31; // r0
  int v33; // r3
  int v34; // r2
  ALvoid *v35; // r0
  ALsizei numchans; // r3
  unsigned int v37; // r0
  unsigned int *v38; // r0
  unsigned int v39; // r0
  unsigned int *v40; // r0
  unsigned int *v42; // r0
  unsigned int v44; // r0
  unsigned int *v45; // r0
  unsigned int *v47; // r0
  ALenum v49; // [sp+14h] [bp-24h]
  char *v50; // [sp+18h] [bp-20h]

  ContextRef = j_GetContextRef();
  v11 = ContextRef;
  if ( ContextRef )
  {
    v12 = (char *)j_LookupUIntMapKey(&ContextRef->Device->BufferMap, buffer);
    if ( v12 )
    {
      if ( (samples | offset) <= -1 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v11->ref) )
        {
          p_LastError = (unsigned int *)&v11->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_90;
          }
          goto LABEL_91;
        }
      }
      else if ( (unsigned int)(a5 - 5120) >= 0xA )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v11->ref) )
        {
          v31 = (unsigned int *)&v11->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, v31) )
          {
            if ( __ldrex(v31) )
              goto LABEL_90;
          }
          goto LABEL_91;
        }
      }
      else
      {
        v13 = (unsigned int *)(v12 + 52);
        __dmb(0xBu);
        v50 = v12;
        do
          v14 = __ldrex(v13);
        while ( __strex(v14 + 1, v13) );
        __dmb(0xBu);
        if ( !v14 )
        {
          __dmb(0xBu);
          v15 = (unsigned int *)(v50 + 56);
          do
            v16 = __ldrex(v15);
          while ( __strex(1u, v15) );
          __dmb(0xBu);
          if ( v16 == 1 )
          {
            do
            {
              sched_yield();
              __dmb(0xBu);
              do
                v17 = __ldrex(v15);
              while ( __strex(1u, v15) );
              __dmb(0xBu);
            }
            while ( v17 == 1 );
          }
        }
        v49 = channels;
        __dmb(0xBu);
        v18 = v50;
        v19 = (unsigned int *)(v50 + 64);
        do
          v20 = __ldrex(v19);
        while ( __strex(1u, v19) );
        __dmb(0xBu);
        if ( v20 == 1 )
        {
          do
          {
            sched_yield();
            __dmb(0xBu);
            do
              v21 = __ldrex(v19);
            while ( __strex(1u, v19) );
            __dmb(0xBu);
          }
          while ( v21 == 1 );
        }
        v22 = *((_QWORD *)v50 + 2);
        if ( (unsigned int)(v22 - 5376) > 6 )
          v23 = 0;
        else
          v23 = dword_60A3C0[(_DWORD)v22 - 5376];
        if ( (unsigned int)(HIDWORD(v22) - 5120) > 6 )
        {
          v33 = 0;
        }
        else
        {
          v33 = dword_60A2C0[HIDWORD(v22) - 5120];
          v18 = v50;
        }
        if ( (_DWORD)v22 == v49 )
        {
          v34 = *((_DWORD *)v18 + 3);
          if ( v34 >= offset )
          {
            v18 = v50;
            if ( v34 - offset >= samples )
            {
              v35 = (ALvoid *)(*(_DWORD *)v50 + v23 * offset * v33);
              numchans = 0;
              if ( (unsigned int)(v49 - 5376) <= 6 )
                numchans = dword_60A3C0[v49 - 5376];
              ConvertData(v35, SHIDWORD(v22), a6, a5, numchans, samples);
              __dmb(0xBu);
              do
                __ldrex(v19);
              while ( __strex(0, v19) );
              __dmb(0xBu);
              __dmb(0xBu);
              do
                v37 = __ldrex(v13);
              while ( __strex(v37 - 1, v13) );
              __dmb(0xBu);
              if ( v37 != 1 )
                goto LABEL_92;
              v38 = (unsigned int *)(v50 + 56);
              __dmb(0xBu);
              do
                __ldrex(v38);
              while ( __strex(0, v38) );
LABEL_91:
              __dmb(0xBu);
LABEL_92:
              ALCcontext_DecRef(v11);
              return;
            }
          }
          __dmb(0xBu);
          do
            __ldrex(v19);
          while ( __strex(0, v19) );
          __dmb(0xBu);
          __dmb(0xBu);
          do
            v44 = __ldrex(v13);
          while ( __strex(v44 - 1, v13) );
          __dmb(0xBu);
          if ( v44 == 1 )
          {
            v45 = (unsigned int *)(v18 + 56);
            __dmb(0xBu);
            do
              __ldrex(v45);
            while ( __strex(0, v45) );
            __dmb(0xBu);
          }
          if ( TrapALError )
            raise(5);
          if ( !__ldrex((unsigned int *)&v11->ref) )
          {
            v47 = (unsigned int *)&v11->LastError;
            __dmb(0xBu);
            while ( __strex(0xA003u, v47) )
            {
              if ( __ldrex(v47) )
                goto LABEL_90;
            }
            goto LABEL_91;
          }
        }
        else
        {
          __dmb(0xBu);
          do
            __ldrex(v19);
          while ( __strex(0, v19) );
          __dmb(0xBu);
          __dmb(0xBu);
          do
            v39 = __ldrex(v13);
          while ( __strex(v39 - 1, v13) );
          __dmb(0xBu);
          if ( v39 == 1 )
          {
            v40 = (unsigned int *)(v18 + 56);
            __dmb(0xBu);
            do
              __ldrex(v40);
            while ( __strex(0, v40) );
            __dmb(0xBu);
          }
          if ( TrapALError )
            raise(5);
          if ( !__ldrex((unsigned int *)&v11->ref) )
          {
            v42 = (unsigned int *)&v11->LastError;
            __dmb(0xBu);
            while ( __strex(0xA002u, v42) )
            {
              if ( __ldrex(v42) )
                goto LABEL_90;
            }
            goto LABEL_91;
          }
        }
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v11->ref) )
      {
        v25 = (unsigned int *)&v11->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v25) )
        {
          if ( __ldrex(v25) )
            goto LABEL_90;
        }
        goto LABEL_91;
      }
    }
LABEL_90:
    __clrex();
    goto LABEL_91;
  }
}
// 60A2C0: using guessed type _DWORD dword_60A2C0[8];
// 60A3C0: using guessed type _DWORD dword_60A3C0[8];

//----- (00246650) --------------------------------------------------------
void __fastcall alGetBufferSamplesSOFT(
        ALuint buffer,
        ALsizei offset,
        ALsizei samples,
        ALenum channels,
        UserFmtType a5,
        ALvoid *a6)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v11; // r8
  char *v12; // r5
  unsigned int *v13; // r9
  unsigned int *v14; // r10
  unsigned int v15; // r0
  unsigned int v16; // r0
  unsigned int *v17; // r8
  ALsizei v18; // r4
  unsigned int v19; // r0
  unsigned int v20; // r0
  unsigned int v21; // r0
  unsigned int *v22; // r11
  unsigned int v23; // r0
  unsigned int v24; // r0
  __int64 v25; // r2
  int v26; // r12
  unsigned int *v28; // r0
  unsigned int *p_LastError; // r0
  unsigned int *v34; // r0
  int v36; // lr
  unsigned int v37; // r0
  unsigned int *v38; // r0
  unsigned int *v40; // r0
  ALsizei v42; // r2
  bool v43; // cc
  unsigned int v44; // r0
  unsigned int *v45; // r0
  unsigned int *v47; // r0
  unsigned int v49; // r0
  unsigned int *v50; // r0
  unsigned int *v52; // r0
  ALsizei numchans; // r0
  unsigned int v55; // r0
  unsigned int *v56; // r0
  ALsizei v57; // [sp+10h] [bp-28h]
  ALenum v58; // [sp+14h] [bp-24h]
  unsigned int *p_ref; // [sp+18h] [bp-20h]

  ContextRef = j_GetContextRef();
  v11 = ContextRef;
  if ( ContextRef )
  {
    v12 = (char *)j_LookupUIntMapKey(&ContextRef->Device->BufferMap, buffer);
    if ( v12 )
    {
      if ( (samples | offset) <= -1 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v11->ref) )
        {
          p_LastError = (unsigned int *)&v11->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_102;
          }
          goto LABEL_103;
        }
      }
      else if ( (unsigned int)(a5 - 5120) >= 0xA )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v11->ref) )
        {
          v34 = (unsigned int *)&v11->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, v34) )
          {
            if ( __ldrex(v34) )
              goto LABEL_102;
          }
          goto LABEL_103;
        }
      }
      else
      {
        v57 = offset;
        v58 = channels;
        v13 = (unsigned int *)(v12 + 48);
        v14 = (unsigned int *)(v12 + 60);
        __dmb(0xBu);
        do
          v15 = __ldrex(v14);
        while ( __strex(1u, v14) );
        __dmb(0xBu);
        if ( v15 == 1 )
        {
          do
          {
            sched_yield();
            __dmb(0xBu);
            do
              v16 = __ldrex(v14);
            while ( __strex(1u, v14) );
            __dmb(0xBu);
          }
          while ( v16 == 1 );
        }
        p_ref = (unsigned int *)&v11->ref;
        v17 = (unsigned int *)(v12 + 56);
        v18 = samples;
        __dmb(0xBu);
        do
          v19 = __ldrex(v17);
        while ( __strex(1u, v17) );
        __dmb(0xBu);
        if ( v19 == 1 )
        {
          do
          {
            sched_yield();
            __dmb(0xBu);
            do
              v20 = __ldrex(v17);
            while ( __strex(1u, v17) );
            __dmb(0xBu);
          }
          while ( v20 == 1 );
        }
        __dmb(0xBu);
        do
          v21 = __ldrex(v13);
        while ( __strex(v21 + 1, v13) );
        __dmb(0xBu);
        if ( !v21 )
        {
          v22 = (unsigned int *)(v12 + 64);
          __dmb(0xBu);
          do
            v23 = __ldrex(v22);
          while ( __strex(1u, v22) );
          __dmb(0xBu);
          if ( v23 == 1 )
          {
            do
            {
              sched_yield();
              __dmb(0xBu);
              do
                v24 = __ldrex(v22);
              while ( __strex(1u, v22) );
              __dmb(0xBu);
            }
            while ( v24 == 1 );
          }
        }
        __dmb(0xBu);
        do
          __ldrex(v17);
        while ( __strex(0, v17) );
        __dmb(0xBu);
        __dmb(0xBu);
        do
          __ldrex(v14);
        while ( __strex(0, v14) );
        __dmb(0xBu);
        v25 = *((_QWORD *)v12 + 2);
        v11 = (ALCcontext *)p_ref;
        if ( (unsigned int)(v25 - 5376) > 6 )
          v26 = 0;
        else
          v26 = dword_60A3C0[(_DWORD)v25 - 5376];
        if ( (unsigned int)(HIDWORD(v25) - 5120) > 6 )
        {
          v36 = 0;
          if ( (_DWORD)v25 != v58 )
            goto LABEL_57;
        }
        else
        {
          v36 = dword_60A2C0[HIDWORD(v25) - 5120];
          if ( (_DWORD)v25 != v58 )
          {
LABEL_57:
            __dmb(0xBu);
            do
              v37 = __ldrex(v13);
            while ( __strex(v37 - 1, v13) );
            __dmb(0xBu);
            if ( v37 == 1 )
            {
              v38 = (unsigned int *)(v12 + 64);
              __dmb(0xBu);
              do
                __ldrex(v38);
              while ( __strex(0, v38) );
              __dmb(0xBu);
            }
            if ( TrapALError )
              raise(5);
            if ( !__ldrex(p_ref) )
            {
              v40 = p_ref + 20;
              __dmb(0xBu);
              while ( __strex(0xA002u, v40) )
              {
                if ( __ldrex(v40) )
                  goto LABEL_102;
              }
              goto LABEL_103;
            }
            goto LABEL_102;
          }
        }
        v42 = *((_DWORD *)v12 + 3);
        v43 = v42 < v57;
        if ( v42 >= v57 )
          v43 = v42 - v57 < v18;
        if ( v43 )
        {
          __dmb(0xBu);
          do
            v44 = __ldrex(v13);
          while ( __strex(v44 - 1, v13) );
          __dmb(0xBu);
          if ( v44 == 1 )
          {
            v45 = (unsigned int *)(v12 + 64);
            __dmb(0xBu);
            do
              __ldrex(v45);
            while ( __strex(0, v45) );
            __dmb(0xBu);
          }
          if ( TrapALError )
            raise(5);
          if ( !__ldrex(p_ref) )
          {
            v47 = p_ref + 20;
            __dmb(0xBu);
            while ( __strex(0xA003u, v47) )
            {
              if ( __ldrex(v47) )
                goto LABEL_102;
            }
            goto LABEL_103;
          }
        }
        else
        {
          if ( !(v18 % 65) || a5 != UserFmtIMA4 )
          {
            if ( (unsigned int)(v58 - 5376) > 6 )
              numchans = 0;
            else
              numchans = dword_60A3C0[v58 - 5376];
            ConvertData(a6, a5, (const ALvoid *)(*(_DWORD *)v12 + v26 * v57 * v36), SHIDWORD(v25), numchans, v18);
            __dmb(0xBu);
            do
              v55 = __ldrex(v13);
            while ( __strex(v55 - 1, v13) );
            __dmb(0xBu);
            if ( v55 != 1 )
              goto LABEL_104;
            v56 = (unsigned int *)(v12 + 64);
            __dmb(0xBu);
            do
              __ldrex(v56);
            while ( __strex(0, v56) );
LABEL_103:
            __dmb(0xBu);
LABEL_104:
            ALCcontext_DecRef(v11);
            return;
          }
          __dmb(0xBu);
          do
            v49 = __ldrex(v13);
          while ( __strex(v49 - 1, v13) );
          __dmb(0xBu);
          if ( v49 == 1 )
          {
            v50 = (unsigned int *)(v12 + 64);
            __dmb(0xBu);
            do
              __ldrex(v50);
            while ( __strex(0, v50) );
            __dmb(0xBu);
          }
          if ( TrapALError )
            raise(5);
          if ( !__ldrex(p_ref) )
          {
            v52 = p_ref + 20;
            __dmb(0xBu);
            while ( __strex(0xA003u, v52) )
            {
              if ( __ldrex(v52) )
                goto LABEL_102;
            }
            goto LABEL_103;
          }
        }
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v11->ref) )
      {
        v28 = (unsigned int *)&v11->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v28) )
        {
          if ( __ldrex(v28) )
            goto LABEL_102;
        }
        goto LABEL_103;
      }
    }
LABEL_102:
    __clrex();
    goto LABEL_103;
  }
}
// 60A2C0: using guessed type _DWORD dword_60A2C0[8];
// 60A3C0: using guessed type _DWORD dword_60A3C0[8];

//----- (00246AB0) --------------------------------------------------------
void __fastcall ReadLock(RWLock *lock)
{
  unsigned int *p_read_entry_lock; // r5
  unsigned int v3; // r0
  unsigned int v4; // r0
  unsigned int *p_read_lock; // r6
  unsigned int v6; // r0
  unsigned int v7; // r0
  unsigned int v8; // r0
  unsigned int *p_write_lock; // r4
  unsigned int v10; // r0
  unsigned int v11; // r0

  p_read_entry_lock = (unsigned int *)&lock->read_entry_lock;
  __dmb(0xBu);
  do
    v3 = __ldrex(p_read_entry_lock);
  while ( __strex(1u, p_read_entry_lock) );
  __dmb(0xBu);
  if ( v3 == 1 )
  {
    do
    {
      sched_yield();
      __dmb(0xBu);
      do
        v4 = __ldrex(p_read_entry_lock);
      while ( __strex(1u, p_read_entry_lock) );
      __dmb(0xBu);
    }
    while ( v4 == 1 );
  }
  p_read_lock = (unsigned int *)&lock->read_lock;
  __dmb(0xBu);
  do
    v6 = __ldrex(p_read_lock);
  while ( __strex(1u, p_read_lock) );
  __dmb(0xBu);
  if ( v6 == 1 )
  {
    do
    {
      sched_yield();
      __dmb(0xBu);
      do
        v7 = __ldrex(p_read_lock);
      while ( __strex(1u, p_read_lock) );
      __dmb(0xBu);
    }
    while ( v7 == 1 );
  }
  __dmb(0xBu);
  do
    v8 = __ldrex((unsigned int *)&lock->read_count);
  while ( __strex(v8 + 1, (unsigned int *)&lock->read_count) );
  __dmb(0xBu);
  if ( !v8 )
  {
    p_write_lock = (unsigned int *)&lock->write_lock;
    __dmb(0xBu);
    do
      v10 = __ldrex(p_write_lock);
    while ( __strex(1u, p_write_lock) );
    __dmb(0xBu);
    if ( v10 == 1 )
    {
      do
      {
        sched_yield();
        __dmb(0xBu);
        do
          v11 = __ldrex(p_write_lock);
        while ( __strex(1u, p_write_lock) );
        __dmb(0xBu);
      }
      while ( v11 == 1 );
    }
  }
  __dmb(0xBu);
  do
    __ldrex(p_read_lock);
  while ( __strex(0, p_read_lock) );
  __dmb(0xBu);
  __dmb(0xBu);
  do
    __ldrex(p_read_entry_lock);
  while ( __strex(0, p_read_entry_lock) );
  __dmb(0xBu);
}

//----- (00246BBC) --------------------------------------------------------
void __fastcall ReadUnlock(RWLock *lock)
{
  unsigned int v1; // r1
  unsigned int *p_write_lock; // r0

  __dmb(0xBu);
  do
    v1 = __ldrex((unsigned int *)&lock->read_count);
  while ( __strex(v1 - 1, (unsigned int *)&lock->read_count) );
  __dmb(0xBu);
  if ( v1 == 1 )
  {
    p_write_lock = (unsigned int *)&lock->write_lock;
    __dmb(0xBu);
    do
      __ldrex(p_write_lock);
    while ( __strex(0, p_write_lock) );
    __dmb(0xBu);
  }
}

//----- (00246BF2) --------------------------------------------------------
ALboolean __fastcall alIsBufferFormatSupportedSOFT(ALenum format)
{
  ALCcontext *ContextRef; // r0
  bool v3; // r4

  ContextRef = j_GetContextRef();
  if ( !ContextRef )
    return 0;
  v3 = (unsigned int)(format - 4612) < 0xF
    || (unsigned int)(format - 65540) <= 0xD && ((1 << (format - 4)) & 0x3003) != 0
    || (unsigned int)(format - 4352) < 4;
  j_ALCcontext_DecRef(ContextRef);
  return v3;
}

//----- (00246C3C) --------------------------------------------------------
void __fastcall alBufferf(ALuint buffer, ALenum param, ALfloat value)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v5; // r4
  unsigned int *p_LastError; // r0
  unsigned int *v10; // r0

  ContextRef = j_GetContextRef();
  v5 = ContextRef;
  if ( ContextRef )
  {
    if ( j_LookupUIntMapKey(&ContextRef->Device->BufferMap, buffer) )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v5->ref) )
      {
        p_LastError = (unsigned int *)&v5->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_16;
        }
        goto LABEL_17;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v5->ref) )
      {
        v10 = (unsigned int *)&v5->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v10) )
        {
          if ( __ldrex(v10) )
            goto LABEL_16;
        }
        goto LABEL_17;
      }
    }
LABEL_16:
    __clrex();
LABEL_17:
    __dmb(0xBu);
    ALCcontext_DecRef(v5);
  }
}

//----- (00246CD4) --------------------------------------------------------
void __fastcall alBuffer3f(ALuint buffer, ALenum param, ALfloat value1, ALfloat value2, ALfloat value3)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  unsigned int *p_LastError; // r0
  unsigned int *v12; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    if ( j_LookupUIntMapKey(&ContextRef->Device->BufferMap, buffer) )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        p_LastError = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_16;
        }
        goto LABEL_17;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        v12 = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v12) )
        {
          if ( __ldrex(v12) )
            goto LABEL_16;
        }
        goto LABEL_17;
      }
    }
LABEL_16:
    __clrex();
LABEL_17:
    __dmb(0xBu);
    ALCcontext_DecRef(v7);
  }
}

//----- (00246D6C) --------------------------------------------------------
void __fastcall alBufferfv(ALuint buffer, ALenum param, const ALfloat *values)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v6; // r4
  unsigned int *p_LastError; // r0
  unsigned int *v11; // r0
  unsigned int *v14; // r0

  ContextRef = j_GetContextRef();
  v6 = ContextRef;
  if ( ContextRef )
  {
    if ( j_LookupUIntMapKey(&ContextRef->Device->BufferMap, buffer) )
    {
      if ( values )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v6->ref) )
        {
          p_LastError = (unsigned int *)&v6->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_25;
          }
          goto LABEL_26;
        }
      }
      else
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v6->ref) )
        {
          v14 = (unsigned int *)&v6->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, v14) )
          {
            if ( __ldrex(v14) )
              goto LABEL_25;
          }
          goto LABEL_26;
        }
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v6->ref) )
      {
        v11 = (unsigned int *)&v6->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v11) )
        {
          if ( __ldrex(v11) )
            goto LABEL_25;
        }
        goto LABEL_26;
      }
    }
LABEL_25:
    __clrex();
LABEL_26:
    __dmb(0xBu);
    ALCcontext_DecRef(v6);
  }
}

//----- (00246E4C) --------------------------------------------------------
void __fastcall alBufferi(ALuint buffer, ALenum param, ALint value)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v5; // r4
  unsigned int *p_LastError; // r0
  unsigned int *v10; // r0

  ContextRef = j_GetContextRef();
  v5 = ContextRef;
  if ( ContextRef )
  {
    if ( j_LookupUIntMapKey(&ContextRef->Device->BufferMap, buffer) )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v5->ref) )
      {
        p_LastError = (unsigned int *)&v5->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_16;
        }
        goto LABEL_17;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v5->ref) )
      {
        v10 = (unsigned int *)&v5->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v10) )
        {
          if ( __ldrex(v10) )
            goto LABEL_16;
        }
        goto LABEL_17;
      }
    }
LABEL_16:
    __clrex();
LABEL_17:
    __dmb(0xBu);
    ALCcontext_DecRef(v5);
  }
}

//----- (00246EE4) --------------------------------------------------------
void __fastcall alBuffer3i(ALuint buffer, ALenum param, ALint value1, ALint value2, ALint value3)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  unsigned int *p_LastError; // r0
  unsigned int *v12; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    if ( j_LookupUIntMapKey(&ContextRef->Device->BufferMap, buffer) )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        p_LastError = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_16;
        }
        goto LABEL_17;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        v12 = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v12) )
        {
          if ( __ldrex(v12) )
            goto LABEL_16;
        }
        goto LABEL_17;
      }
    }
LABEL_16:
    __clrex();
LABEL_17:
    __dmb(0xBu);
    ALCcontext_DecRef(v7);
  }
}

//----- (00246F7C) --------------------------------------------------------
void __fastcall alBufferiv(ALuint buffer, ALenum param, const ALint *values)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r9
  unsigned int *v8; // r8
  unsigned int *v9; // r4
  unsigned int v10; // r0
  unsigned int *v11; // r5
  unsigned int v12; // r0
  unsigned int v13; // r0
  unsigned int *v14; // r5
  unsigned int v15; // r0
  unsigned int v16; // r0
  unsigned int v17; // r0
  unsigned int *v18; // r0
  unsigned int *p_LastError; // r0
  unsigned int *v23; // r0
  unsigned int *v26; // r0
  unsigned int *v29; // r0
  ALint v31; // r0
  ALint v32; // r1
  unsigned int v33; // r0
  unsigned int *v34; // r0
  unsigned int *v36; // r0
  unsigned int v38; // r0
  unsigned int *v39; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (unsigned int *)j_LookupUIntMapKey(&ContextRef->Device->BufferMap, buffer);
    if ( v8 )
    {
      if ( values )
      {
        if ( param == 8213 )
        {
          v9 = v8 + 13;
          __dmb(0xBu);
          do
            v10 = __ldrex(v9);
          while ( __strex(v10 + 1, v9) );
          __dmb(0xBu);
          if ( !v10 )
          {
            v11 = v8 + 14;
            __dmb(0xBu);
            do
              v12 = __ldrex(v11);
            while ( __strex(1u, v11) );
            __dmb(0xBu);
            if ( v12 == 1 )
            {
              do
              {
                sched_yield();
                __dmb(0xBu);
                do
                  v13 = __ldrex(v11);
                while ( __strex(1u, v11) );
                __dmb(0xBu);
              }
              while ( v13 == 1 );
            }
          }
          v14 = v8 + 16;
          __dmb(0xBu);
          do
            v15 = __ldrex(v14);
          while ( __strex(1u, v14) );
          __dmb(0xBu);
          if ( v15 == 1 )
          {
            do
            {
              sched_yield();
              __dmb(0xBu);
              do
                v16 = __ldrex(v14);
              while ( __strex(1u, v14) );
              __dmb(0xBu);
            }
            while ( v16 == 1 );
          }
          if ( v8[11] )
          {
            __dmb(0xBu);
            do
              __ldrex(v14);
            while ( __strex(0, v14) );
            __dmb(0xBu);
            __dmb(0xBu);
            do
              v17 = __ldrex(v9);
            while ( __strex(v17 - 1, v9) );
            __dmb(0xBu);
            if ( v17 == 1 )
            {
              v18 = v8 + 14;
              __dmb(0xBu);
              do
                __ldrex(v18);
              while ( __strex(0, v18) );
              __dmb(0xBu);
            }
            if ( TrapALError )
              raise(5);
            if ( !__ldrex((unsigned int *)&v7->ref) )
            {
              p_LastError = (unsigned int *)&v7->LastError;
              __dmb(0xBu);
              while ( __strex(0xA004u, p_LastError) )
              {
                if ( __ldrex(p_LastError) )
                  goto LABEL_75;
              }
              goto LABEL_76;
            }
          }
          else
          {
            v31 = *values;
            if ( *values >= 0 )
            {
              v32 = values[1];
              if ( v31 < v32 && v32 <= (int)v8[3] )
              {
                v8[9] = v31;
                v8[10] = values[1];
                __dmb(0xBu);
                do
                  __ldrex(v14);
                while ( __strex(0, v14) );
                __dmb(0xBu);
                __dmb(0xBu);
                do
                  v38 = __ldrex(v9);
                while ( __strex(v38 - 1, v9) );
                __dmb(0xBu);
                if ( v38 != 1 )
                  goto LABEL_77;
                v39 = v8 + 14;
                __dmb(0xBu);
                do
                  __ldrex(v39);
                while ( __strex(0, v39) );
LABEL_76:
                __dmb(0xBu);
LABEL_77:
                ALCcontext_DecRef(v7);
                return;
              }
            }
            __dmb(0xBu);
            do
              __ldrex(v14);
            while ( __strex(0, v14) );
            __dmb(0xBu);
            __dmb(0xBu);
            do
              v33 = __ldrex(v9);
            while ( __strex(v33 - 1, v9) );
            __dmb(0xBu);
            if ( v33 == 1 )
            {
              v34 = v8 + 14;
              __dmb(0xBu);
              do
                __ldrex(v34);
              while ( __strex(0, v34) );
              __dmb(0xBu);
            }
            if ( TrapALError )
              raise(5);
            if ( !__ldrex((unsigned int *)&v7->ref) )
            {
              v36 = (unsigned int *)&v7->LastError;
              __dmb(0xBu);
              while ( __strex(0xA003u, v36) )
              {
                if ( __ldrex(v36) )
                  goto LABEL_75;
              }
              goto LABEL_76;
            }
          }
        }
        else
        {
          if ( TrapALError )
            raise(5);
          if ( !__ldrex((unsigned int *)&v7->ref) )
          {
            v29 = (unsigned int *)&v7->LastError;
            __dmb(0xBu);
            while ( __strex(0xA002u, v29) )
            {
              if ( __ldrex(v29) )
                goto LABEL_75;
            }
            goto LABEL_76;
          }
        }
      }
      else
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          v26 = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, v26) )
          {
            if ( __ldrex(v26) )
              goto LABEL_75;
          }
          goto LABEL_76;
        }
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        v23 = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v23) )
        {
          if ( __ldrex(v23) )
            goto LABEL_75;
        }
        goto LABEL_76;
      }
    }
LABEL_75:
    __clrex();
    goto LABEL_76;
  }
}

//----- (002472AC) --------------------------------------------------------
void __fastcall alGetBufferf(ALuint buffer, ALenum param, ALfloat *value)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r10
  unsigned int *v8; // r9
  unsigned int *v9; // r6
  unsigned int *v10; // r11
  unsigned int v11; // r0
  unsigned int v12; // r0
  unsigned int *v13; // r4
  unsigned int v14; // r0
  unsigned int v15; // r0
  unsigned int v16; // r0
  unsigned int *v17; // r5
  unsigned int v18; // r0
  unsigned int v19; // r0
  int v20; // r0
  float v21; // s0
  unsigned int *v23; // r0
  unsigned int *v26; // r0
  unsigned int *p_LastError; // r0
  unsigned int v31; // r0
  unsigned int *v32; // r0
  ALfloat *v33; // [sp+0h] [bp-20h]

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (unsigned int *)j_LookupUIntMapKey(&ContextRef->Device->BufferMap, buffer);
    if ( v8 )
    {
      if ( value )
      {
        if ( param == 8203 )
        {
          v9 = v8 + 15;
          v10 = v8 + 12;
          v33 = value;
          __dmb(0xBu);
          do
            v11 = __ldrex(v9);
          while ( __strex(1u, v9) );
          __dmb(0xBu);
          if ( v11 == 1 )
          {
            do
            {
              sched_yield();
              __dmb(0xBu);
              do
                v12 = __ldrex(v9);
              while ( __strex(1u, v9) );
              __dmb(0xBu);
            }
            while ( v12 == 1 );
          }
          v13 = v8 + 14;
          __dmb(0xBu);
          do
            v14 = __ldrex(v13);
          while ( __strex(1u, v13) );
          __dmb(0xBu);
          if ( v14 == 1 )
          {
            do
            {
              sched_yield();
              __dmb(0xBu);
              do
                v15 = __ldrex(v13);
              while ( __strex(1u, v13) );
              __dmb(0xBu);
            }
            while ( v15 == 1 );
          }
          __dmb(0xBu);
          do
            v16 = __ldrex(v10);
          while ( __strex(v16 + 1, v10) );
          __dmb(0xBu);
          if ( !v16 )
          {
            v17 = v8 + 16;
            __dmb(0xBu);
            do
              v18 = __ldrex(v17);
            while ( __strex(1u, v17) );
            __dmb(0xBu);
            if ( v18 == 1 )
            {
              do
              {
                sched_yield();
                __dmb(0xBu);
                do
                  v19 = __ldrex(v17);
                while ( __strex(1u, v17) );
                __dmb(0xBu);
              }
              while ( v19 == 1 );
            }
          }
          __dmb(0xBu);
          do
            __ldrex(v13);
          while ( __strex(0, v13) );
          __dmb(0xBu);
          __dmb(0xBu);
          do
            __ldrex(v9);
          while ( __strex(0, v9) );
          __dmb(0xBu);
          v20 = v8[3];
          if ( v20 )
            v21 = (float)v20 / (float)(int)v8[1];
          else
            v21 = 0.0;
          *v33 = v21;
          __dmb(0xBu);
          do
            v31 = __ldrex(v10);
          while ( __strex(v31 - 1, v10) );
          __dmb(0xBu);
          if ( v31 != 1 )
            goto LABEL_55;
          v32 = v8 + 16;
          __dmb(0xBu);
          do
            __ldrex(v32);
          while ( __strex(0, v32) );
LABEL_54:
          __dmb(0xBu);
LABEL_55:
          ALCcontext_DecRef(v7);
          return;
        }
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          p_LastError = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_53;
          }
          goto LABEL_54;
        }
      }
      else
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          v26 = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, v26) )
          {
            if ( __ldrex(v26) )
              goto LABEL_53;
          }
          goto LABEL_54;
        }
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        v23 = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v23) )
        {
          if ( __ldrex(v23) )
            goto LABEL_53;
        }
        goto LABEL_54;
      }
    }
LABEL_53:
    __clrex();
    goto LABEL_54;
  }
}

//----- (00247518) --------------------------------------------------------
void __fastcall alGetBuffer3f(ALuint buffer, ALenum param, ALfloat *value1, ALfloat *value2, int a5)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v9; // r4
  bool v10; // zf
  unsigned int *v12; // r0
  unsigned int *v15; // r0
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  v9 = ContextRef;
  if ( ContextRef )
  {
    if ( j_LookupUIntMapKey(&ContextRef->Device->BufferMap, buffer) )
    {
      v10 = value1 == 0;
      if ( value1 )
        v10 = value2 == 0;
      if ( v10 || !a5 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v9->ref) )
        {
          p_LastError = (unsigned int *)&v9->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_28;
          }
          goto LABEL_29;
        }
      }
      else
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v9->ref) )
        {
          v12 = (unsigned int *)&v9->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, v12) )
          {
            if ( __ldrex(v12) )
              goto LABEL_28;
          }
          goto LABEL_29;
        }
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v9->ref) )
      {
        v15 = (unsigned int *)&v9->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v15) )
        {
          if ( __ldrex(v15) )
            goto LABEL_28;
        }
        goto LABEL_29;
      }
    }
LABEL_28:
    __clrex();
LABEL_29:
    __dmb(0xBu);
    ALCcontext_DecRef(v9);
  }
}

//----- (00247608) --------------------------------------------------------
void __fastcall alGetBufferfv(ALuint buffer, ALenum param, ALfloat *values)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v6; // r4
  unsigned int *p_LastError; // r0
  unsigned int *v11; // r0
  unsigned int *v14; // r0

  if ( param == 8203 )
  {
    alGetBufferf(buffer, 8203, values);
    return;
  }
  ContextRef = j_GetContextRef();
  v6 = ContextRef;
  if ( ContextRef )
  {
    if ( j_LookupUIntMapKey(&ContextRef->Device->BufferMap, buffer) )
    {
      if ( values )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v6->ref) )
        {
          p_LastError = (unsigned int *)&v6->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_27;
          }
          goto LABEL_28;
        }
      }
      else
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v6->ref) )
        {
          v14 = (unsigned int *)&v6->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, v14) )
          {
            if ( __ldrex(v14) )
              goto LABEL_27;
          }
          goto LABEL_28;
        }
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v6->ref) )
      {
        v11 = (unsigned int *)&v6->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v11) )
        {
          if ( __ldrex(v11) )
            goto LABEL_27;
        }
        goto LABEL_28;
      }
    }
LABEL_27:
    __clrex();
LABEL_28:
    __dmb(0xBu);
    ALCcontext_DecRef(v6);
  }
}

//----- (00247700) --------------------------------------------------------
void __fastcall alGetBufferi(ALuint buffer, ALenum param, ALint *value)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r10
  ALint *v8; // r9
  unsigned int *v10; // r0
  unsigned int *v13; // r0
  unsigned int v15; // r0
  int *v16; // r1
  unsigned int *v17; // r6
  unsigned int *v18; // r11
  unsigned int v19; // r0
  unsigned int v20; // r0
  unsigned int *v21; // r4
  unsigned int v22; // r0
  unsigned int v23; // r0
  unsigned int v24; // r0
  unsigned int *v25; // r5
  unsigned int v26; // r0
  unsigned int v27; // r0
  unsigned int v28; // r1
  int v29; // r1
  unsigned int *p_LastError; // r0
  unsigned int v33; // r2
  int v34; // r2
  unsigned int v35; // r0
  unsigned int *v36; // r0
  ALint *v37; // [sp+0h] [bp-20h]

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( !ContextRef )
    return;
  v8 = (ALint *)j_LookupUIntMapKey(&ContextRef->Device->BufferMap, buffer);
  if ( v8 )
  {
    if ( value )
    {
      switch ( param )
      {
        case 8193:
          *value = v8[1];
          goto LABEL_61;
        case 8194:
          v15 = v8[5] - 5120;
          if ( v15 > 6 )
            goto LABEL_65;
          v16 = dword_2479EC;
          goto LABEL_25;
        case 8195:
          v15 = v8[4] - 5376;
          if ( v15 > 6 )
          {
LABEL_65:
            *value = 0;
          }
          else
          {
            v16 = dword_60A3C0;
LABEL_25:
            *value = v16[v15];
          }
          goto LABEL_61;
        case 8196:
          v17 = (unsigned int *)(v8 + 15);
          v18 = (unsigned int *)(v8 + 12);
          v37 = value;
          __dmb(0xBu);
          do
            v19 = __ldrex(v17);
          while ( __strex(1u, v17) );
          __dmb(0xBu);
          if ( v19 == 1 )
          {
            do
            {
              sched_yield();
              __dmb(0xBu);
              do
                v20 = __ldrex(v17);
              while ( __strex(1u, v17) );
              __dmb(0xBu);
            }
            while ( v20 == 1 );
          }
          v21 = (unsigned int *)(v8 + 14);
          __dmb(0xBu);
          do
            v22 = __ldrex(v21);
          while ( __strex(1u, v21) );
          __dmb(0xBu);
          if ( v22 == 1 )
          {
            do
            {
              sched_yield();
              __dmb(0xBu);
              do
                v23 = __ldrex(v21);
              while ( __strex(1u, v21) );
              __dmb(0xBu);
            }
            while ( v23 == 1 );
          }
          __dmb(0xBu);
          do
            v24 = __ldrex(v18);
          while ( __strex(v24 + 1, v18) );
          __dmb(0xBu);
          if ( !v24 )
          {
            v25 = (unsigned int *)(v8 + 16);
            __dmb(0xBu);
            do
              v26 = __ldrex(v25);
            while ( __strex(1u, v25) );
            __dmb(0xBu);
            if ( v26 == 1 )
            {
              do
              {
                sched_yield();
                __dmb(0xBu);
                do
                  v27 = __ldrex(v25);
                while ( __strex(1u, v25) );
                __dmb(0xBu);
              }
              while ( v27 == 1 );
            }
          }
          __dmb(0xBu);
          do
            __ldrex(v21);
          while ( __strex(0, v21) );
          __dmb(0xBu);
          __dmb(0xBu);
          do
            __ldrex(v17);
          while ( __strex(0, v17) );
          __dmb(0xBu);
          v28 = v8[4] - 5376;
          if ( v28 > 6 )
            v29 = 0;
          else
            v29 = dword_60A3C0[v28];
          v33 = v8[5] - 5120;
          if ( v33 > 6 )
            v34 = 0;
          else
            v34 = dword_60A2C0[v33];
          *v37 = v8[3] * v29 * v34;
          __dmb(0xBu);
          do
            v35 = __ldrex(v18);
          while ( __strex(v35 - 1, v18) );
          __dmb(0xBu);
          if ( v35 != 1 )
            goto LABEL_61;
          v36 = (unsigned int *)(v8 + 16);
          __dmb(0xBu);
          do
            __ldrex(v36);
          while ( __strex(0, v36) );
          goto LABEL_60;
        case 8200:
          *value = v8[2];
          goto LABEL_61;
        case 8201:
          *value = v8[8];
          goto LABEL_61;
        case 8202:
          *value = v8[3];
          goto LABEL_61;
        default:
          if ( TrapALError )
            raise(5);
          if ( __ldrex((unsigned int *)&v7->ref) )
            goto LABEL_59;
          p_LastError = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          break;
      }
      while ( __strex(0xA002u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
          goto LABEL_59;
      }
      goto LABEL_60;
    }
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&v7->ref) )
    {
      v13 = (unsigned int *)&v7->LastError;
      __dmb(0xBu);
      while ( __strex(0xA003u, v13) )
      {
        if ( __ldrex(v13) )
          goto LABEL_59;
      }
      goto LABEL_60;
    }
  }
  else
  {
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&v7->ref) )
    {
      v10 = (unsigned int *)&v7->LastError;
      __dmb(0xBu);
      while ( __strex(0xA001u, v10) )
      {
        if ( __ldrex(v10) )
          goto LABEL_59;
      }
      goto LABEL_60;
    }
  }
LABEL_59:
  __clrex();
LABEL_60:
  __dmb(0xBu);
LABEL_61:
  ALCcontext_DecRef(v7);
}
// 2479EC: using guessed type int dword_2479EC[2];
// 60A2C0: using guessed type _DWORD dword_60A2C0[8];
// 60A3C0: using guessed type _DWORD dword_60A3C0[8];

//----- (00247A14) --------------------------------------------------------
void __fastcall alGetBuffer3i(ALuint buffer, ALenum param, ALint *value1, ALint *value2, int a5)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v9; // r4
  bool v10; // zf
  unsigned int *v12; // r0
  unsigned int *v15; // r0
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  v9 = ContextRef;
  if ( ContextRef )
  {
    if ( j_LookupUIntMapKey(&ContextRef->Device->BufferMap, buffer) )
    {
      v10 = value1 == 0;
      if ( value1 )
        v10 = value2 == 0;
      if ( v10 || !a5 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v9->ref) )
        {
          p_LastError = (unsigned int *)&v9->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_28;
          }
          goto LABEL_29;
        }
      }
      else
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v9->ref) )
        {
          v12 = (unsigned int *)&v9->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, v12) )
          {
            if ( __ldrex(v12) )
              goto LABEL_28;
          }
          goto LABEL_29;
        }
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v9->ref) )
      {
        v15 = (unsigned int *)&v9->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v15) )
        {
          if ( __ldrex(v15) )
            goto LABEL_28;
        }
        goto LABEL_29;
      }
    }
LABEL_28:
    __clrex();
LABEL_29:
    __dmb(0xBu);
    ALCcontext_DecRef(v9);
  }
}

//----- (00247B04) --------------------------------------------------------
void __fastcall alGetBufferiv(ALuint buffer, ALenum param, ALint *values)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r9
  unsigned int *v8; // r5
  unsigned int *v9; // r6
  unsigned int *v10; // r11
  unsigned int v11; // r0
  unsigned int v12; // r0
  unsigned int *v13; // r5
  unsigned int v14; // r0
  unsigned int v15; // r0
  unsigned int v16; // r0
  unsigned int *v17; // r4
  unsigned int v18; // r0
  unsigned int v19; // r0
  unsigned int v20; // r0
  unsigned int *v21; // r0
  unsigned int *v23; // r0
  unsigned int *v26; // r0
  unsigned int *p_LastError; // r0
  unsigned int *v31; // [sp+0h] [bp-20h]

  if ( (unsigned int)(param - 8193) <= 9 && ((1 << (param - 1)) & 0x38F) != 0 )
  {
    alGetBufferi(buffer, param, values);
    return;
  }
  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (unsigned int *)j_LookupUIntMapKey(&ContextRef->Device->BufferMap, buffer);
    if ( v8 )
    {
      if ( values )
      {
        if ( param == 8213 )
        {
          v9 = v8 + 15;
          v10 = v8 + 12;
          __dmb(0xBu);
          do
            v11 = __ldrex(v9);
          while ( __strex(1u, v9) );
          __dmb(0xBu);
          if ( v11 == 1 )
          {
            do
            {
              sched_yield();
              __dmb(0xBu);
              do
                v12 = __ldrex(v9);
              while ( __strex(1u, v9) );
              __dmb(0xBu);
            }
            while ( v12 == 1 );
          }
          __dmb(0xBu);
          v31 = v8;
          v13 = v8 + 14;
          do
            v14 = __ldrex(v13);
          while ( __strex(1u, v13) );
          __dmb(0xBu);
          if ( v14 == 1 )
          {
            do
            {
              sched_yield();
              __dmb(0xBu);
              do
                v15 = __ldrex(v13);
              while ( __strex(1u, v13) );
              __dmb(0xBu);
            }
            while ( v15 == 1 );
          }
          __dmb(0xBu);
          do
            v16 = __ldrex(v10);
          while ( __strex(v16 + 1, v10) );
          __dmb(0xBu);
          if ( !v16 )
          {
            __dmb(0xBu);
            v17 = v31 + 16;
            do
              v18 = __ldrex(v17);
            while ( __strex(1u, v17) );
            __dmb(0xBu);
            if ( v18 == 1 )
            {
              do
              {
                sched_yield();
                __dmb(0xBu);
                do
                  v19 = __ldrex(v17);
                while ( __strex(1u, v17) );
                __dmb(0xBu);
              }
              while ( v19 == 1 );
            }
          }
          __dmb(0xBu);
          do
            __ldrex(v13);
          while ( __strex(0, v13) );
          __dmb(0xBu);
          __dmb(0xBu);
          do
            __ldrex(v9);
          while ( __strex(0, v9) );
          __dmb(0xBu);
          *values = v31[9];
          values[1] = v31[10];
          __dmb(0xBu);
          do
            v20 = __ldrex(v10);
          while ( __strex(v20 - 1, v10) );
          __dmb(0xBu);
          if ( v20 != 1 )
            goto LABEL_62;
          v21 = v31 + 16;
          __dmb(0xBu);
          do
            __ldrex(v21);
          while ( __strex(0, v21) );
LABEL_61:
          __dmb(0xBu);
LABEL_62:
          ALCcontext_DecRef(v7);
          return;
        }
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          p_LastError = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_60;
          }
          goto LABEL_61;
        }
      }
      else
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          v26 = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, v26) )
          {
            if ( __ldrex(v26) )
              goto LABEL_60;
          }
          goto LABEL_61;
        }
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        v23 = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v23) )
        {
          if ( __ldrex(v23) )
            goto LABEL_60;
        }
        goto LABEL_61;
      }
    }
LABEL_60:
    __clrex();
    goto LABEL_61;
  }
}

//----- (00247D80) --------------------------------------------------------
ALvoid __fastcall ReleaseALBuffers(ALCdevice *device)
{
  int v1; // r2
  UIntMap::$8A70C81DF3844826C6730DC5B9E2C72C *v2; // r0
  unsigned int v3; // r0
  unsigned int v4; // r0
  unsigned int v5; // r0
  unsigned int v6; // r0
  ALenum *v7; // r1
  unsigned int *v8; // r0
  unsigned int v9; // r0
  ALCdevice *v10; // [sp+4h] [bp-2Ch]
  char *v11; // [sp+8h] [bp-28h]
  int v12; // [sp+Ch] [bp-24h]
  void **p; // [sp+10h] [bp-20h]

  if ( device->BufferMap.size >= 1 )
  {
    v1 = 0;
    v10 = device;
    do
    {
      v12 = v1;
      v2 = &device->BufferMap.array[v1];
      p = (void **)v2->value;
      v2->value = 0;
      free(*p);
      v11 = (char *)p[17];
      __dmb(0xBu);
      do
        v3 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
      while ( 1 )
      {
        __dmb(0xBu);
        if ( v3 != 1 )
          break;
        sched_yield();
        __dmb(0xBu);
        do
          v3 = __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
      }
      __dmb(0xBu);
      do
        v4 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
      while ( 1 )
      {
        __dmb(0xBu);
        if ( v4 != 1 )
          break;
        sched_yield();
        __dmb(0xBu);
        do
          v4 = __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
      }
      __dmb(0xBu);
      do
        v5 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(v5 + 1, (unsigned int *)&ThunkLock.read_count) );
      __dmb(0xBu);
      if ( !v5 )
      {
        __dmb(0xBu);
        do
          v6 = __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
        while ( 1 )
        {
          __dmb(0xBu);
          if ( v6 != 1 )
            break;
          sched_yield();
          __dmb(0xBu);
          do
            v6 = __ldrex((unsigned int *)&ThunkLock.read_count);
          while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
        }
      }
      __dmb(0xBu);
      do
        __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(0, (unsigned int *)&ThunkLock.read_lock) );
      __dmb(0xBu);
      __dmb(0xBu);
      do
        __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(0, (unsigned int *)&ThunkLock.read_entry_lock) );
      __dmb(0xBu);
      if ( (unsigned int)(v11 - 1) < ThunkArraySize )
      {
        v7 = ThunkArray;
        __dmb(0xBu);
        v8 = (unsigned int *)&v7[(_DWORD)(v11 - 1)];
        do
          __ldrex(v8);
        while ( __strex(0, v8) );
        __dmb(0xBu);
      }
      __dmb(0xBu);
      do
        v9 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(v9 - 1, (unsigned int *)&ThunkLock.read_count) );
      __dmb(0xBu);
      if ( v9 == 1 )
      {
        __dmb(0xBu);
        do
          __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(0, (unsigned int *)&ThunkLock.write_lock) );
        __dmb(0xBu);
      }
      free(p);
      device = v10;
      v1 = v12 + 1;
    }
    while ( v12 + 1 < v10->BufferMap.size );
  }
}

//----- (00247F60) --------------------------------------------------------
void __fastcall AudioSetHRTF(ALCdevice *device, int value)
{
  ALboolean v3; // r5

  v3 = value;
  if ( (unsigned int)LogLevel_0 >= LogTrace )
    j_al_print("(II)", "AudioSetHRTF", "AudioSetHRTF %d", value);
  alcDeviceEnableHrtfMOB(device, v3);
}

//----- (00247FB4) --------------------------------------------------------
void al_print(const unsigned __int8 *type, const unsigned __int8 *func, const unsigned __int8 *fmt, ...)
{
  signed int v4; // r0
  unsigned __int8 s[256]; // [sp+8h] [bp-114h] BYREF
  va_list va; // [sp+124h] [bp+8h] BYREF

  va_start(va, fmt);
  v4 = snprintf(s, 0x100u, "AL lib: %s %s: ", (const char *)type, (const char *)func);
  if ( v4 >= 1 && (unsigned int)v4 <= 0xFF )
    vsnprintf(&s[v4], 256 - v4, fmt, va);
  s[255] = 0;
  fputs((const char *)s, LogFile);
  fflush(LogFile);
  _android_log_print(4, "OpenAL_alSource.c", (const char *)s);
}

//----- (00248078) --------------------------------------------------------
ALboolean __fastcall alcDeviceEnableHrtfMOB(ALCdevice *device, ALboolean enable)
{
  char v3; // r0

  if ( !enable )
  {
    v3 = 0;
    goto LABEL_8;
  }
  if ( device->Hrtf )
  {
LABEL_6:
    v3 = 1;
LABEL_8:
    *((_BYTE *)&elf_hash_chain[6163] + (_DWORD)device) = v3;
    return 1;
  }
  if ( pthread_mutex_lock(&ListLock) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      363,
      "void EnterCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    goto LABEL_11;
  }
  device->Hrtf = j_GetHrtf(device);
  if ( pthread_mutex_unlock(&ListLock) )
  {
LABEL_11:
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      369,
      "void LeaveCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    JUMPOUT(0x2480F0);
  }
  if ( device->Hrtf )
    goto LABEL_6;
  return 0;
}
// 2480EC: control flows out of bounds to 2480F0
// 10168: using guessed type int elf_hash_chain[22025];
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00248110) --------------------------------------------------------
void __fastcall PauseOpenSLES(ALCdevice *Device, int value)
{
  int v2; // r5
  int v3; // r0
  unsigned int v4; // r0
  const char *v5; // r1
  int v6; // r0
  unsigned int v7; // r0
  const char *v8; // r1
  int v9; // r0
  void *v10; // r0
  int (***v11)(void); // [sp+4h] [bp-Ch] BYREF

  v2 = *(int *)((char *)&elf_hash_chain[6162] + (_DWORD)Device);
  v3 = (*(int (__fastcall **)(_DWORD, _DWORD, int (****)(void)))(**(_DWORD **)(v2 + 12) + 12))(
         *(_DWORD *)(v2 + 12),
         SL_IID_PLAY,
         &v11);
  if ( v3 && LogLevel_0 )
  {
    v4 = v3 - 1;
    if ( v4 > 0xF )
      v5 = "Unknown error code";
    else
      v5 = (&off_661DE0)[v4];
    j_al_print("(EE)", "alc_opensl_pause_player", (const unsigned __int8 *)"%s: %s\n", "bufferQueue->GetInterface", v5);
  }
  else if ( !v3 )
  {
    v6 = (**v11)();
    if ( v6 && LogLevel_0 )
    {
      v7 = v6 - 1;
      if ( v7 > 0xF )
        v8 = "Unknown error code";
      else
        v8 = (&off_661DE0)[v7];
      j_al_print("(EE)", "alc_opensl_pause_player", (const unsigned __int8 *)"%s: %s\n", "player->SetPlayState", v8);
    }
    else if ( !v6 )
    {
      return;
    }
  }
  v9 = *(_DWORD *)(v2 + 12);
  if ( v9 )
    (*(void (__fastcall **)(int))(*(_DWORD *)v9 + 24))(v9);
  v10 = *(void **)(v2 + 16);
  *(_DWORD *)(v2 + 12) = 0;
  free(v10);
  *(_DWORD *)(v2 + 16) = 0;
  *(_DWORD *)(v2 + 20) = 0;
}
// 10168: using guessed type int elf_hash_chain[22025];
// 661DE0: using guessed type char *off_661DE0;

//----- (0024821C) --------------------------------------------------------
void alc_init()
{
  char *v0; // r0
  const char *v1; // r4
  char *v2; // r0
  const char *v3; // r4

  LogFile = (FILE *)stderr;
  v0 = getenv("__ALSOFT_HALF_ANGLE_CONES");
  v1 = v0;
  if ( v0 && (!strcasecmp(v0, "true") || strtol(v1, 0, 0) == 1) )
    ConeScale = ConeScale * 0.5;
  v2 = getenv("__ALSOFT_REVERSE_Z");
  v3 = v2;
  if ( v2 && (!strcasecmp(v2, "true") || strtol(v3, 0, 0) == 1) )
    ZScale = -ZScale;
  pthread_key_create(&LocalContext, ReleaseThreadCtx);
  j_InitializeCriticalSection(&ListLock);
  ThunkLock.read_count = 0;
  ThunkLock.write_count = 0;
  ThunkLock.read_lock = 0;
  ThunkLock.read_entry_lock = 0;
  ThunkArraySize = 1;
  ThunkLock.write_lock = 0;
  ThunkArray = (ALenum *)calloc(1u, 4u);
}

//----- (0024833C) --------------------------------------------------------
void __fastcall ReleaseThreadCtx(void *ptr)
{
  if ( (unsigned int)LogLevel_0 >= LogWarning )
    j_al_print("(WW)", "ReleaseThreadCtx", "%p current for thread being destroyed\n", ptr);
  ALCcontext_DecRef((ALCcontext *)ptr);
}

//----- (002483AC) --------------------------------------------------------
void __fastcall InitializeCriticalSection(CRITICAL_SECTION *cs)
{
  pthread_mutexattr_t attr[3]; // [sp+4h] [bp-Ch] BYREF

  if ( pthread_mutexattr_init(attr) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      340,
      "void InitializeCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    goto LABEL_6;
  }
  if ( pthread_mutexattr_settype(attr, 1) )
  {
LABEL_6:
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      347,
      "void InitializeCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    goto LABEL_7;
  }
  if ( pthread_mutex_init(cs, attr) )
  {
LABEL_7:
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      349,
      "void InitializeCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    JUMPOUT(0x248410);
  }
  pthread_mutexattr_destroy(attr);
}
// 24840C: control flows out of bounds to 248410
// 19EE74: using guessed type int __fastcall pthread_mutexattr_settype(_DWORD, _DWORD);
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0024845C) --------------------------------------------------------
void ThunkInit()
{
  ThunkLock.read_count = 0;
  ThunkLock.write_count = 0;
  ThunkLock.read_lock = 0;
  ThunkLock.read_entry_lock = 0;
  ThunkArraySize = 1;
  ThunkLock.write_lock = 0;
  ThunkArray = (ALenum *)calloc(1u, 4u);
}

//----- (00248494) --------------------------------------------------------
void alc_deinit()
{
  void (*Deinit)(void); // r0
  void (**p_Deinit)(void); // r4
  void (*v2)(void); // t1
  Hrtf *i; // r4

  alc_cleanup();
  PlaybackBackend.Funcs.Unlock = 0;
  PlaybackBackend.Funcs.GetLatency = 0;
  CaptureBackend.Funcs.Unlock = 0;
  CaptureBackend.Funcs.GetLatency = 0;
  Deinit = BackendList[0].Deinit;
  *(_QWORD *)&PlaybackBackend.Funcs.StopCapture = 0LL;
  *(_QWORD *)&PlaybackBackend.Funcs.AvailableSamples = 0LL;
  *(_QWORD *)&PlaybackBackend.Funcs.StopPlayback = 0LL;
  *(_QWORD *)&PlaybackBackend.Funcs.CloseCapture = 0LL;
  *(_QWORD *)&PlaybackBackend.name = 0LL;
  *(_QWORD *)&PlaybackBackend.Deinit = 0LL;
  *(_QWORD *)&PlaybackBackend.Funcs.OpenPlayback = 0LL;
  *(_QWORD *)&PlaybackBackend.Funcs.ResetPlayback = 0LL;
  *(_QWORD *)&CaptureBackend.Funcs.StopCapture = 0LL;
  *(_QWORD *)&CaptureBackend.Funcs.AvailableSamples = 0LL;
  *(_QWORD *)&CaptureBackend.Funcs.StopPlayback = 0LL;
  *(_QWORD *)&CaptureBackend.Funcs.CloseCapture = 0LL;
  *(_QWORD *)&CaptureBackend.name = 0LL;
  *(_QWORD *)&CaptureBackend.Deinit = 0LL;
  *(_QWORD *)&CaptureBackend.Funcs.OpenPlayback = 0LL;
  *(_QWORD *)&CaptureBackend.Funcs.ResetPlayback = 0LL;
  if ( BackendList[0].Deinit )
  {
    p_Deinit = &BackendList[1].Deinit;
    do
    {
      Deinit();
      v2 = *p_Deinit;
      p_Deinit += 18;
      Deinit = v2;
    }
    while ( v2 );
  }
  BackendLoopback.Deinit();
  alc_cleanup();
  for ( i = LoadedHrtfs; LoadedHrtfs; i = LoadedHrtfs )
  {
    LoadedHrtfs = i->next;
    free((void *)i->azCount);
    free((void *)i->evOffset);
    free((void *)i->coeffs);
    free((void *)i->delays);
    free(i);
  }
  free(ThunkArray);
  ThunkArray = 0;
  ThunkArraySize = 0;
  if ( pthread_mutex_destroy(&ListLock) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      357,
      "void DeleteCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    JUMPOUT(0x2485A0);
  }
  pthread_key_delete(LocalContext);
  if ( LogFile != (FILE *)stderr )
    fclose(LogFile);
  LogFile = 0;
}
// 24859C: control flows out of bounds to 2485A0
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (002485E4) --------------------------------------------------------
void alc_cleanup()
{
  unsigned int v0; // r0
  unsigned int v1; // r3
  const char *v2; // r2

  free(alcAllDevicesList);
  alcAllDevicesList = 0;
  alcAllDevicesListSize = 0;
  free(alcCaptureDeviceList);
  alcCaptureDeviceList = 0;
  alcCaptureDeviceListSize = 0;
  free(alcDefaultAllDevicesSpecifier);
  alcDefaultAllDevicesSpecifier = 0;
  free(alcCaptureDefaultDeviceSpecifier);
  alcCaptureDefaultDeviceSpecifier = 0;
  __dmb(0xBu);
  do
    v0 = __ldrex((unsigned int *)&DeviceList);
  while ( __strex(0, (unsigned int *)&DeviceList) );
  __dmb(0xBu);
  if ( v0 )
  {
    v1 = 0;
    do
    {
      v0 = *(int *)((char *)&elf_hash_chain[6164] + v0);
      ++v1;
    }
    while ( v0 );
    if ( LogLevel_0 )
    {
      v2 = (const char *)&dword_2486B0;
      if ( v1 <= 1 )
        v2 = &byte_61CADE;
      j_al_print("(EE)", "alc_cleanup", "%u device%s not closed\n", v1, v2);
    }
  }
}
// 10168: using guessed type int elf_hash_chain[22025];
// 2486B0: using guessed type int dword_2486B0;
// 61CADE: using guessed type char byte_61CADE;

//----- (002486D8) --------------------------------------------------------
void __fastcall AppendAllDevicesList(const ALCchar *name)
{
  size_t v2; // r5
  ALCchar *v3; // r0
  ALCchar *v4; // r6
  size_t v5; // r5
  size_t v6; // r9

  v2 = strlen((const char *)name);
  if ( v2 )
  {
    v3 = (ALCchar *)realloc(alcAllDevicesList, v2 + alcAllDevicesListSize + 2);
    v4 = v3;
    if ( v3 )
    {
      v5 = v2 + 1;
      v6 = alcAllDevicesListSize;
      alcAllDevicesList = v3;
      qmemcpy(&v3[alcAllDevicesListSize], name, v5);
      alcAllDevicesListSize = v6 + v5;
      v4[v6 + v5] = 0;
    }
    else if ( LogLevel_0 )
    {
      al_print("(EE)", "AppendList", "Realloc failed to add %s!\n", (const char *)name);
    }
  }
}

//----- (00248778) --------------------------------------------------------
void __fastcall AppendCaptureDeviceList(const ALCchar *name)
{
  size_t v2; // r5
  ALCchar *v3; // r0
  ALCchar *v4; // r6
  size_t v5; // r5
  size_t v6; // r9

  v2 = strlen((const char *)name);
  if ( v2 )
  {
    v3 = (ALCchar *)realloc(alcCaptureDeviceList, v2 + alcCaptureDeviceListSize + 2);
    v4 = v3;
    if ( v3 )
    {
      v5 = v2 + 1;
      v6 = alcCaptureDeviceListSize;
      alcCaptureDeviceList = v3;
      qmemcpy(&v3[alcCaptureDeviceListSize], name, v5);
      alcCaptureDeviceListSize = v6 + v5;
      v4[v6 + v5] = 0;
    }
    else if ( LogLevel_0 )
    {
      al_print("(EE)", "AppendList", "Realloc failed to add %s!\n", (const char *)name);
    }
  }
}

//----- (0024881C) --------------------------------------------------------
const ALCchar *__fastcall DevFmtTypeString(DevFmtType type)
{
  unsigned __int32 v1; // r0

  v1 = type - 5120;
  if ( v1 > 6 )
    return (const ALCchar *)"(unknown type)";
  else
    return (const ALCchar *)off_661DC0[v1];
}
// 661DC0: using guessed type char *off_661DC0[6];

//----- (0024883C) --------------------------------------------------------
const ALCchar *__fastcall DevFmtChannelsString(DevFmtChannels chans)
{
  __int32 v1; // r1
  const ALCchar *result; // r0

  v1 = chans - 5376;
  result = (const ALCchar *)"Mono";
  switch ( v1 )
  {
    case 0:
      return result;
    case 1:
      result = (const ALCchar *)"Stereo";
      break;
    case 2:
      goto LABEL_5;
    case 3:
      result = (const ALCchar *)"Quadraphonic";
      break;
    case 4:
      result = (const ALCchar *)"5.1 Surround";
      break;
    case 5:
      result = (const ALCchar *)"6.1 Surround";
      break;
    case 6:
      result = (const ALCchar *)"7.1 Surround";
      break;
    default:
      if ( 0x805F56C3 )
LABEL_5:
        result = (const ALCchar *)"(unknown channels)";
      else
        result = (const ALCchar *)"5.1 Side";
      break;
  }
  return result;
}

//----- (002488A4) --------------------------------------------------------
ALuint __fastcall BytesFromDevFmt(DevFmtType type)
{
  unsigned __int32 v1; // r0

  v1 = type - 5120;
  if ( v1 <= 6 )
    return dword_60A410[v1];
  else
    return 0;
}
// 60A410: using guessed type _DWORD dword_60A410[7];

//----- (002488C0) --------------------------------------------------------
ALuint __fastcall ChannelsFromDevFmt(DevFmtChannels chans)
{
  __int32 v1; // r1
  ALuint result; // r0

  v1 = chans - 5376;
  result = 1;
  switch ( v1 )
  {
    case 0:
      return result;
    case 1:
      result = 2;
      break;
    case 3:
      result = 4;
      break;
    case 4:
      result = 6;
      break;
    case 5:
      result = 7;
      break;
    case 6:
      result = 8;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (002488F4) --------------------------------------------------------
void __fastcall ALCdevice_LockDefault(ALCdevice *device)
{
  if ( pthread_mutex_lock(&device->Mutex) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      363,
      "void EnterCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    JUMPOUT(0x248918);
  }
}
// 248914: control flows out of bounds to 248918
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00248924) --------------------------------------------------------
void __fastcall EnterCriticalSection(CRITICAL_SECTION *cs)
{
  if ( pthread_mutex_lock(cs) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      363,
      "void EnterCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    JUMPOUT(0x248948);
  }
}
// 248946: control flows out of bounds to 248948
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00248954) --------------------------------------------------------
void __fastcall ALCdevice_UnlockDefault(ALCdevice *device)
{
  if ( pthread_mutex_unlock(&device->Mutex) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      369,
      "void LeaveCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    JUMPOUT(0x248978);
  }
}
// 248974: control flows out of bounds to 248978
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00248984) --------------------------------------------------------
void __fastcall LeaveCriticalSection(CRITICAL_SECTION *cs)
{
  if ( pthread_mutex_unlock(cs) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      369,
      "void LeaveCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    JUMPOUT(0x2489A8);
  }
}
// 2489A6: control flows out of bounds to 2489A8
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (002489B4) --------------------------------------------------------
ALint64 __fastcall ALCdevice_GetLatencyDefault(ALCdevice *device)
{
  return 0LL;
}

//----- (002489BC) --------------------------------------------------------
void __fastcall SetDefaultWFXChannelOrder(ALCdevice *device)
{
  ALuint *ChannelOffsets; // r9
  int v3; // r11
  int v4; // r12
  int v5; // lr
  int v6; // r0
  ALuint v7; // r8
  int v8; // r2
  int v9; // r10
  int v10; // r6
  int v11; // r3
  int v12; // r1
  int v13; // r3
  volatile RefCount *v14; // r1

  ChannelOffsets = device->ChannelOffsets;
  memset(device->ChannelOffsets, 255, sizeof(device->ChannelOffsets));
  v3 = 3;
  v4 = 5;
  v5 = 4;
  v6 = 1;
  v7 = 0;
  v8 = 2;
  v9 = 1;
  v10 = 0;
  v11 = 1;
  switch ( device->FmtChans )
  {
    case DevFmtMono:
      goto LABEL_8;
    case DevFmtStereo:
      goto LABEL_7;
    case DevFmtQuad:
      goto LABEL_6;
    case DevFmtX51:
      v4 = 5;
      v5 = 4;
      v6 = 3;
      v7 = 2;
      v12 = 1;
      v13 = 0;
      v9 = 3;
      v8 = 4;
      v3 = 5;
      goto LABEL_5;
    case DevFmtX61:
      v4 = 8;
      *ChannelOffsets = 0;
      v8 = 5;
      v5 = 7;
      v9 = 4;
      v6 = 6;
      v7 = 3;
      v12 = 2;
      v13 = 1;
      v3 = 6;
      goto LABEL_5;
    case DevFmtX71:
      device->ChannelOffsets[0] = 0;
      device->ChannelOffsets[1] = 1;
      v4 = 8;
      v8 = 6;
      v5 = 7;
      v6 = 5;
      v7 = 4;
      v12 = 3;
      v13 = 2;
      v9 = 5;
      v3 = 7;
LABEL_5:
      ChannelOffsets[v13] = v13;
      ChannelOffsets[v12] = v12;
LABEL_6:
      ChannelOffsets[v7] = v7;
      v7 = v5;
      v10 = v8;
      ChannelOffsets[v6] = v9;
      v6 = v4;
      v11 = v3;
LABEL_7:
      v14 = &device->ref + v7;
      v8 = v6;
      v7 = v11;
      *((_DWORD *)v14 + 47) = v10;
LABEL_8:
      device->ChannelOffsets[v8] = v7;
      break;
    default:
      return;
  }
}

//----- (00248ABC) --------------------------------------------------------
void __fastcall SetDefaultChannelOrder(ALCdevice *device)
{
  ALuint *ChannelOffsets; // r5
  DevFmtChannels FmtChans; // r6
  int v4; // r0
  int v5; // r4
  int v6; // r12
  int v7; // r1
  int v8; // r6
  int v9; // r11
  ALuint v10; // r9
  int v11; // r8
  int v12; // r3
  int v13; // lr
  int v14; // r6
  int v15; // r1
  __int32 v16; // r12
  int v17; // r3
  int v18; // r2
  volatile RefCount *v19; // r0
  int v20; // [sp+4h] [bp-24h]
  int v21; // [sp+8h] [bp-20h]

  ChannelOffsets = device->ChannelOffsets;
  memset(device->ChannelOffsets, 255, sizeof(device->ChannelOffsets));
  FmtChans = device->FmtChans;
  if ( FmtChans == DevFmtX51 )
  {
    v21 = 2;
    v12 = 3;
    v11 = 5;
    v10 = 4;
    v7 = 1;
    v9 = 0;
    v8 = 0;
    v6 = 1;
    v5 = 2;
    v4 = 4;
    v20 = 3;
    v13 = 5;
LABEL_5:
    ChannelOffsets[v9] = v8;
    v14 = v12;
    ChannelOffsets[v7] = v6;
    v15 = v20;
LABEL_7:
    v17 = v4;
    ChannelOffsets[v10] = v21;
    v10 = v5;
    v18 = v13;
    ChannelOffsets[v11] = v14;
    v11 = v15;
LABEL_8:
    v19 = &device->ref + v10;
    v10 = v18;
    *((_DWORD *)v19 + 47) = v17;
    v4 = v11;
LABEL_9:
    device->ChannelOffsets[v4] = v10;
    return;
  }
  if ( FmtChans == DevFmtX71 )
  {
    device->ChannelOffsets[0] = 0;
    device->ChannelOffsets[1] = 1;
    v20 = 8;
    v4 = 6;
    v5 = 7;
    v6 = 3;
    v7 = 5;
    v8 = 2;
    v9 = 4;
    v10 = 2;
    v21 = 4;
    v11 = 3;
    v12 = 5;
    v13 = 7;
    goto LABEL_5;
  }
  memset(ChannelOffsets, 255, 0x24u);
  v16 = FmtChans - 5376;
  v13 = 3;
  v15 = 5;
  v5 = 4;
  v11 = 1;
  v10 = 0;
  v4 = 2;
  v14 = 1;
  v21 = 0;
  v17 = 0;
  v18 = 1;
  switch ( v16 )
  {
    case 0:
      goto LABEL_9;
    case 1:
      goto LABEL_8;
    case 3:
      goto LABEL_7;
    case 5:
      v5 = 7;
      *ChannelOffsets = 0;
      v20 = 8;
      v4 = 5;
      v12 = 4;
      v11 = 6;
      v10 = 3;
      v7 = 2;
      v9 = 1;
      v8 = 1;
      v6 = 2;
      v13 = 6;
      v21 = 3;
      goto LABEL_5;
    default:
      return;
  }
}

//----- (00248C10) --------------------------------------------------------
void __fastcall ALCdevice_IncRef(ALCdevice *device)
{
  unsigned int v2; // r0

  __dmb(0xBu);
  do
    v2 = __ldrex((unsigned int *)&device->ref);
  while ( __strex(v2 + 1, (unsigned int *)&device->ref) );
  __dmb(0xBu);
  if ( (unsigned int)LogLevel_0 >= LogRef )
    j_al_print("(--)", "ALCdevice_IncRef", "%p increasing refcount to %u\n", device, v2 + 1);
}

//----- (00248C64) --------------------------------------------------------
void __fastcall ALCdevice_DecRef(ALCdevice *device)
{
  unsigned int v2; // r0
  unsigned int v3; // r5
  int v4; // r0
  int v5; // r0
  unsigned int *p_write_count; // r5
  unsigned int v7; // r0
  unsigned int *p_read_lock; // r6
  unsigned int v9; // r0
  unsigned int v10; // r0
  unsigned int *p_write_lock; // r6
  unsigned int v12; // r0
  unsigned int v13; // r0
  unsigned int v14; // r0
  unsigned int *v15; // r0
  unsigned int *v16; // r5
  unsigned int v17; // r0
  unsigned int *v18; // r6
  unsigned int v19; // r0
  unsigned int v20; // r0
  unsigned int *v21; // r6
  unsigned int v22; // r0
  unsigned int v23; // r0
  unsigned int v24; // r0
  unsigned int *v25; // r0
  unsigned int *v26; // r5
  unsigned int v27; // r0
  unsigned int *v28; // r6
  unsigned int v29; // r0
  unsigned int v30; // r0
  unsigned int *v31; // r6
  unsigned int v32; // r0
  unsigned int v33; // r0
  unsigned int v34; // r0
  unsigned int *v35; // r0
  ALCchar *DeviceName; // r0
  int v37; // t1

  __dmb(0xBu);
  do
  {
    v2 = __ldrex((unsigned int *)&device->ref);
    v3 = v2 - 1;
  }
  while ( __strex(v2 - 1, (unsigned int *)&device->ref) );
  __dmb(0xBu);
  if ( (unsigned int)LogLevel_0 >= LogRef )
    j_al_print("(--)", "ALCdevice_DecRef", "%p decreasing refcount to %u\n", device, v3);
  if ( !v3 )
  {
    if ( (unsigned int)LogLevel_0 >= LogTrace )
      j_al_print("(II)", "FreeDevice", "%p\n", device);
    v4 = *(int *)((char *)&elf_hash_chain[6161] + (_DWORD)device);
    if ( device->Type == Capture )
      (*(void (__fastcall **)(ALCdevice *))(v4 + 24))(device);
    else
      (*(void (__fastcall **)(ALCdevice *))(v4 + 4))(device);
    v5 = *(int *)((char *)&elf_hash_chain[6159] + (_DWORD)device);
    if ( v5 )
    {
      (**(void (***)(void))(v5 + 196))();
      *(_DWORD *)(*(int *)((char *)&elf_hash_chain[6159] + (_DWORD)device) + 196) = 0;
    }
    if ( device->BufferMap.size >= 1 )
    {
      if ( (unsigned int)LogLevel_0 >= LogWarning )
        j_al_print("(WW)", "FreeDevice", "(%p) Deleting %d Buffer(s)\n", device, device->BufferMap.size);
      j_ReleaseALBuffers(device);
    }
    p_write_count = (unsigned int *)&device->BufferMap.lock.write_count;
    __dmb(0xBu);
    do
      v7 = __ldrex(p_write_count);
    while ( __strex(v7 + 1, p_write_count) );
    __dmb(0xBu);
    if ( !v7 )
    {
      p_read_lock = (unsigned int *)&device->BufferMap.lock.read_lock;
      __dmb(0xBu);
      do
        v9 = __ldrex(p_read_lock);
      while ( __strex(1u, p_read_lock) );
      __dmb(0xBu);
      if ( v9 == 1 )
      {
        do
        {
          sched_yield();
          __dmb(0xBu);
          do
            v10 = __ldrex(p_read_lock);
          while ( __strex(1u, p_read_lock) );
          __dmb(0xBu);
        }
        while ( v10 == 1 );
      }
    }
    p_write_lock = (unsigned int *)&device->BufferMap.lock.write_lock;
    __dmb(0xBu);
    do
      v12 = __ldrex(p_write_lock);
    while ( __strex(1u, p_write_lock) );
    __dmb(0xBu);
    if ( v12 == 1 )
    {
      do
      {
        sched_yield();
        __dmb(0xBu);
        do
          v13 = __ldrex(p_write_lock);
        while ( __strex(1u, p_write_lock) );
        __dmb(0xBu);
      }
      while ( v13 == 1 );
    }
    free(device->BufferMap.array);
    device->BufferMap.array = 0;
    device->BufferMap.size = 0;
    device->BufferMap.maxsize = 0;
    __dmb(0xBu);
    do
      __ldrex(p_write_lock);
    while ( __strex(0, p_write_lock) );
    __dmb(0xBu);
    __dmb(0xBu);
    do
      v14 = __ldrex(p_write_count);
    while ( __strex(v14 - 1, p_write_count) );
    __dmb(0xBu);
    if ( v14 == 1 )
    {
      v15 = (unsigned int *)&device->BufferMap.lock.read_lock;
      __dmb(0xBu);
      do
        __ldrex(v15);
      while ( __strex(0, v15) );
      __dmb(0xBu);
    }
    if ( device->EffectMap.size >= 1 )
    {
      if ( (unsigned int)LogLevel_0 >= LogWarning )
        j_al_print("(WW)", "FreeDevice", "(%p) Deleting %d Effect(s)\n", device, device->EffectMap.size);
      j_ReleaseALEffects(device);
    }
    v16 = (unsigned int *)&device->EffectMap.lock.write_count;
    __dmb(0xBu);
    do
      v17 = __ldrex(v16);
    while ( __strex(v17 + 1, v16) );
    __dmb(0xBu);
    if ( !v17 )
    {
      v18 = (unsigned int *)&device->EffectMap.lock.read_lock;
      __dmb(0xBu);
      do
        v19 = __ldrex(v18);
      while ( __strex(1u, v18) );
      __dmb(0xBu);
      if ( v19 == 1 )
      {
        do
        {
          sched_yield();
          __dmb(0xBu);
          do
            v20 = __ldrex(v18);
          while ( __strex(1u, v18) );
          __dmb(0xBu);
        }
        while ( v20 == 1 );
      }
    }
    v21 = (unsigned int *)&device->EffectMap.lock.write_lock;
    __dmb(0xBu);
    do
      v22 = __ldrex(v21);
    while ( __strex(1u, v21) );
    __dmb(0xBu);
    if ( v22 == 1 )
    {
      do
      {
        sched_yield();
        __dmb(0xBu);
        do
          v23 = __ldrex(v21);
        while ( __strex(1u, v21) );
        __dmb(0xBu);
      }
      while ( v23 == 1 );
    }
    free(device->EffectMap.array);
    device->EffectMap.array = 0;
    device->EffectMap.size = 0;
    device->EffectMap.maxsize = 0;
    __dmb(0xBu);
    do
      __ldrex(v21);
    while ( __strex(0, v21) );
    __dmb(0xBu);
    __dmb(0xBu);
    do
      v24 = __ldrex(v16);
    while ( __strex(v24 - 1, v16) );
    __dmb(0xBu);
    if ( v24 == 1 )
    {
      v25 = (unsigned int *)&device->EffectMap.lock.read_lock;
      __dmb(0xBu);
      do
        __ldrex(v25);
      while ( __strex(0, v25) );
      __dmb(0xBu);
    }
    if ( device->FilterMap.size >= 1 )
    {
      if ( (unsigned int)LogLevel_0 >= LogWarning )
        j_al_print("(WW)", "FreeDevice", "(%p) Deleting %d Filter(s)\n", device, device->FilterMap.size);
      j_ReleaseALFilters(device);
    }
    v26 = (unsigned int *)&device->FilterMap.lock.write_count;
    __dmb(0xBu);
    do
      v27 = __ldrex(v26);
    while ( __strex(v27 + 1, v26) );
    __dmb(0xBu);
    if ( !v27 )
    {
      v28 = (unsigned int *)&device->FilterMap.lock.read_lock;
      __dmb(0xBu);
      do
        v29 = __ldrex(v28);
      while ( __strex(1u, v28) );
      __dmb(0xBu);
      if ( v29 == 1 )
      {
        do
        {
          sched_yield();
          __dmb(0xBu);
          do
            v30 = __ldrex(v28);
          while ( __strex(1u, v28) );
          __dmb(0xBu);
        }
        while ( v30 == 1 );
      }
    }
    v31 = (unsigned int *)&device->FilterMap.lock.write_lock;
    __dmb(0xBu);
    do
      v32 = __ldrex(v31);
    while ( __strex(1u, v31) );
    __dmb(0xBu);
    if ( v32 == 1 )
    {
      do
      {
        sched_yield();
        __dmb(0xBu);
        do
          v33 = __ldrex(v31);
        while ( __strex(1u, v31) );
        __dmb(0xBu);
      }
      while ( v33 == 1 );
    }
    free(device->FilterMap.array);
    device->FilterMap.array = 0;
    device->FilterMap.size = 0;
    device->FilterMap.maxsize = 0;
    __dmb(0xBu);
    do
      __ldrex(v31);
    while ( __strex(0, v31) );
    __dmb(0xBu);
    __dmb(0xBu);
    do
      v34 = __ldrex(v26);
    while ( __strex(v34 - 1, v26) );
    __dmb(0xBu);
    if ( v34 == 1 )
    {
      v35 = (unsigned int *)&device->FilterMap.lock.read_lock;
      __dmb(0xBu);
      do
        __ldrex(v35);
      while ( __strex(0, v35) );
      __dmb(0xBu);
    }
    free(device->Bs2b);
    DeviceName = device->DeviceName;
    device->Bs2b = 0;
    free(DeviceName);
    device->DeviceName = 0;
    if ( pthread_mutex_destroy(&device->Mutex) )
    {
      _assert2(
        "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
        357,
        "void DeleteCriticalSection(CRITICAL_SECTION *)",
        "ret == 0");
      JUMPOUT(0x2490C0);
    }
    do
    {
      v37 = *((unsigned __int8 *)&device[-1].next + 7);
      device = (ALCdevice *)((char *)device - 1);
    }
    while ( v37 == 85 );
    j_free(device);
  }
}
// 2490BE: control flows out of bounds to 2490C0
// 10168: using guessed type int elf_hash_chain[22025];
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00249170) --------------------------------------------------------
void __fastcall ALCcontext_IncRef(ALCcontext *context)
{
  unsigned int v2; // r0

  __dmb(0xBu);
  do
    v2 = __ldrex((unsigned int *)&context->ref);
  while ( __strex(v2 + 1, (unsigned int *)&context->ref) );
  __dmb(0xBu);
  if ( (unsigned int)LogLevel_0 >= LogRef )
    j_al_print("(--)", "ALCcontext_IncRef", "%p increasing refcount to %u\n", context, v2 + 1);
}

//----- (002491C4) --------------------------------------------------------
void UnlockLists()
{
  if ( pthread_mutex_unlock(&ListLock) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      369,
      "void LeaveCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    JUMPOUT(0x2491EC);
  }
}
// 2491EA: control flows out of bounds to 2491EC
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (002491FC) --------------------------------------------------------
ALCenum __fastcall alcGetError(ALCdevice *device)
{
  ALCdevice **v2; // r1
  ALCdevice *v3; // r5
  bool v4; // zf
  unsigned int v5; // r0
  unsigned int *p_LastError; // r0
  ALCenum v7; // r5

  if ( !device )
    goto LABEL_18;
  if ( pthread_mutex_lock(&ListLock) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      363,
      "void EnterCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    goto LABEL_23;
  }
  v2 = (ALCdevice **)&DeviceList;
  do
  {
    v3 = *v2;
    v4 = *v2 == 0;
    if ( *v2 )
    {
      v2 = (ALCdevice **)((char *)&elf_hash_chain[6164] + (_DWORD)v3);
      v4 = v3 == device;
    }
  }
  while ( !v4 );
  if ( v3 )
  {
    __dmb(0xBu);
    do
      v5 = __ldrex((unsigned int *)&v3->ref);
    while ( __strex(v5 + 1, (unsigned int *)&v3->ref) );
    __dmb(0xBu);
    if ( (unsigned int)LogLevel_0 >= LogRef )
      j_al_print("(--)", "ALCdevice_IncRef", "%p increasing refcount to %u\n", v3, v5 + 1);
  }
  if ( pthread_mutex_unlock(&ListLock) )
  {
LABEL_23:
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      369,
      "void LeaveCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    JUMPOUT(0x2492DC);
  }
  if ( v3 )
  {
    p_LastError = (unsigned int *)&device->LastError;
    __dmb(0xBu);
    do
      v7 = __ldrex(p_LastError);
    while ( __strex(0, p_LastError) );
    __dmb(0xBu);
    j_ALCdevice_DecRef(device);
    return v7;
  }
LABEL_18:
  __dmb(0xBu);
  do
    v7 = __ldrex((unsigned int *)&LastNullDeviceError);
  while ( __strex(0, (unsigned int *)&LastNullDeviceError) );
  __dmb(0xBu);
  return v7;
}
// 2492D8: control flows out of bounds to 2492DC
// 10168: using guessed type int elf_hash_chain[22025];
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00249318) --------------------------------------------------------
const ALCchar *__fastcall alcGetString(ALCdevice *Device, ALCenum param)
{
  ALCdevice **v3; // r1
  ALCdevice *v4; // r6
  bool v5; // zf
  unsigned int v6; // r0
  unsigned __int8 *DeviceName; // r5
  ALCdevice **v8; // r1
  ALCdevice *v9; // r5
  bool v10; // zf
  unsigned int v11; // r0
  ALCdevice **v12; // r1
  ALCdevice *v13; // r5
  bool v14; // zf
  unsigned int v15; // r0
  const unsigned __int8 *v16; // r0
  unsigned __int8 **v17; // r0
  ALCdevice **v18; // r1
  ALCdevice *v19; // r5
  bool v20; // zf
  unsigned int v21; // r0
  ALCdevice **v22; // r1
  bool v23; // zf
  unsigned int v24; // r0
  ALCdevice **v25; // r1
  ALCdevice *v26; // r5
  bool v27; // zf
  unsigned int v28; // r0
  unsigned __int8 **v29; // r0
  const unsigned __int8 *v30; // r0

  if ( param > 4099 )
  {
LABEL_27:
    switch ( param )
    {
      case 4100:
        return alcDefaultName;
      case 4101:
        return alcDefaultName;
      case 4102:
        if ( !Device )
          return alcNoDeviceExtList;
        if ( pthread_mutex_lock(&ListLock) )
          goto LABEL_163;
        v18 = (ALCdevice **)&DeviceList;
        do
        {
          v19 = *v18;
          v20 = *v18 == 0;
          if ( *v18 )
          {
            v18 = (ALCdevice **)((char *)&elf_hash_chain[6164] + (_DWORD)v19);
            v20 = v19 == Device;
          }
        }
        while ( !v20 );
        if ( v19 )
        {
          __dmb(0xBu);
          do
            v21 = __ldrex((unsigned int *)&v19->ref);
          while ( __strex(v21 + 1, (unsigned int *)&v19->ref) );
          __dmb(0xBu);
          if ( (unsigned int)LogLevel_0 >= LogRef )
            j_al_print("(--)", "ALCdevice_IncRef", "%p increasing refcount to %u\n", v19, v21 + 1);
        }
        if ( pthread_mutex_unlock(&ListLock) )
          goto LABEL_164;
        if ( !v19 )
          return alcNoDeviceExtList;
        j_ALCdevice_DecRef(Device);
        return alcExtensionList;
      case 4103:
      case 4104:
      case 4105:
      case 4106:
      case 4107:
      case 4108:
      case 4109:
      case 4110:
      case 4111:
      case 4112:
      case 4113:
        goto LABEL_45;
      case 4114:
        if ( alcAllDevicesList )
          goto LABEL_104;
        pthread_once(&alc_config_once, alc_initconfig);
        if ( pthread_mutex_lock(&ListLock) )
          goto LABEL_170;
        free(alcAllDevicesList);
        alcAllDevicesListSize = 0;
        alcAllDevicesList = 0;
        if ( PlaybackBackend.Probe )
          PlaybackBackend.Probe(ALL_DEVICE_PROBE);
        if ( pthread_mutex_unlock(&ListLock) )
          goto LABEL_171;
LABEL_104:
        if ( !Device )
        {
          v4 = 0;
          goto LABEL_145;
        }
        if ( !pthread_mutex_lock(&ListLock) )
        {
          v22 = (ALCdevice **)&DeviceList;
          do
          {
            v4 = *v22;
            v23 = *v22 == 0;
            if ( *v22 )
            {
              v22 = (ALCdevice **)((char *)&elf_hash_chain[6164] + (_DWORD)v4);
              v23 = v4 == Device;
            }
          }
          while ( !v23 );
          if ( v4 )
          {
            __dmb(0xBu);
            do
              v24 = __ldrex((unsigned int *)&v4->ref);
            while ( __strex(v24 + 1, (unsigned int *)&v4->ref) );
            __dmb(0xBu);
            if ( (unsigned int)LogLevel_0 >= LogRef )
              j_al_print("(--)", "ALCdevice_IncRef", "%p increasing refcount to %u\n", v4, v24 + 1);
          }
          if ( pthread_mutex_unlock(&ListLock) )
          {
            _assert2(
              "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
              369,
              "void LeaveCriticalSection(CRITICAL_SECTION *)",
              "ret == 0");
LABEL_118:
            if ( !Device )
            {
LABEL_132:
              pthread_once(&alc_config_once, alc_initconfig);
              if ( !pthread_mutex_lock(&ListLock) )
              {
                free(alcAllDevicesList);
                alcAllDevicesListSize = 0;
                alcAllDevicesList = 0;
                if ( PlaybackBackend.Probe )
                  PlaybackBackend.Probe(ALL_DEVICE_PROBE);
                if ( !pthread_mutex_unlock(&ListLock) )
                  return alcAllDevicesList;
LABEL_169:
                _assert2(
                  "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
                  369,
                  "void LeaveCriticalSection(CRITICAL_SECTION *)",
                  "ret == 0");
LABEL_170:
                _assert2(
                  "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
                  363,
                  "void EnterCriticalSection(CRITICAL_SECTION *)",
                  "ret == 0");
LABEL_171:
                _assert2(
                  "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
                  369,
                  "void LeaveCriticalSection(CRITICAL_SECTION *)",
                  "ret == 0");
                JUMPOUT(0x249B24);
              }
LABEL_168:
              _assert2(
                "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
                363,
                "void EnterCriticalSection(CRITICAL_SECTION *)",
                "ret == 0");
              goto LABEL_169;
            }
            if ( !pthread_mutex_lock(&ListLock) )
            {
              v25 = (ALCdevice **)&DeviceList;
              do
              {
                v26 = *v25;
                v27 = *v25 == 0;
                if ( *v25 )
                {
                  v25 = (ALCdevice **)((char *)&elf_hash_chain[6164] + (_DWORD)v26);
                  v27 = v26 == Device;
                }
              }
              while ( !v27 );
              if ( v26 )
              {
                __dmb(0xBu);
                do
                  v28 = __ldrex((unsigned int *)&v26->ref);
                while ( __strex(v28 + 1, (unsigned int *)&v26->ref) );
                __dmb(0xBu);
                if ( (unsigned int)LogLevel_0 >= LogRef )
                  j_al_print("(--)", "ALCdevice_IncRef", "%p increasing refcount to %u\n", v26, v28 + 1);
              }
              if ( !pthread_mutex_unlock(&ListLock) )
              {
                if ( !v26 )
                  goto LABEL_132;
                goto LABEL_44;
              }
LABEL_167:
              _assert2(
                "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
                369,
                "void LeaveCriticalSection(CRITICAL_SECTION *)",
                "ret == 0");
              goto LABEL_168;
            }
LABEL_166:
            _assert2(
              "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
              363,
              "void EnterCriticalSection(CRITICAL_SECTION *)",
              "ret == 0");
            goto LABEL_167;
          }
LABEL_145:
          free(alcDefaultAllDevicesSpecifier);
          v30 = (const unsigned __int8 *)&byte_61CADE;
          if ( alcAllDevicesList )
            v30 = alcAllDevicesList;
          DeviceName = j_strdup(v30);
          alcDefaultAllDevicesSpecifier = DeviceName;
          if ( !DeviceName )
          {
            if ( TrapALCError )
              raise(5);
            if ( v4 )
            {
              v17 = &alcDefaultAllDevicesSpecifier;
              goto LABEL_74;
            }
            v29 = &alcDefaultAllDevicesSpecifier;
            goto LABEL_142;
          }
          goto LABEL_68;
        }
        break;
      case 4115:
        goto LABEL_118;
      default:
        switch ( param )
        {
          case 40961:
            return alcErrInvalidDevice;
          case 40962:
            return alcErrInvalidContext;
          case 40963:
            return alcErrInvalidEnum;
          case 40964:
            return alcErrInvalidValue;
          case 40965:
            return alcErrOutOfMemory;
          default:
            goto LABEL_45;
        }
    }
LABEL_165:
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      363,
      "void EnterCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    goto LABEL_166;
  }
  switch ( param )
  {
    case 0:
      return alcNoError;
    case 784:
      if ( Device )
      {
        if ( pthread_mutex_lock(&ListLock) )
        {
LABEL_156:
          _assert2(
            "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
            363,
            "void EnterCriticalSection(CRITICAL_SECTION *)",
            "ret == 0");
LABEL_157:
          _assert2(
            "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
            369,
            "void LeaveCriticalSection(CRITICAL_SECTION *)",
            "ret == 0");
          goto LABEL_158;
        }
        v8 = (ALCdevice **)&DeviceList;
        do
        {
          v9 = *v8;
          v10 = *v8 == 0;
          if ( *v8 )
          {
            v8 = (ALCdevice **)((char *)&elf_hash_chain[6164] + (_DWORD)v9);
            v10 = v9 == Device;
          }
        }
        while ( !v10 );
        if ( v9 )
        {
          __dmb(0xBu);
          do
            v11 = __ldrex((unsigned int *)&v9->ref);
          while ( __strex(v11 + 1, (unsigned int *)&v9->ref) );
          __dmb(0xBu);
          if ( (unsigned int)LogLevel_0 >= LogRef )
            j_al_print("(--)", "ALCdevice_IncRef", "%p increasing refcount to %u\n", v9, v11 + 1);
        }
        if ( pthread_mutex_unlock(&ListLock) )
          goto LABEL_157;
        if ( v9 )
        {
LABEL_44:
          DeviceName = Device->DeviceName;
          j_ALCdevice_DecRef(Device);
          return DeviceName;
        }
      }
LABEL_59:
      pthread_once(&alc_config_once, alc_initconfig);
      if ( !pthread_mutex_lock(&ListLock) )
      {
        free(alcCaptureDeviceList);
        alcCaptureDeviceListSize = 0;
        alcCaptureDeviceList = 0;
        if ( CaptureBackend.Probe )
          CaptureBackend.Probe(CAPTURE_DEVICE_PROBE);
        if ( !pthread_mutex_unlock(&ListLock) )
          return alcCaptureDeviceList;
        goto LABEL_159;
      }
LABEL_158:
      _assert2(
        "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
        363,
        "void EnterCriticalSection(CRITICAL_SECTION *)",
        "ret == 0");
LABEL_159:
      _assert2(
        "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
        369,
        "void LeaveCriticalSection(CRITICAL_SECTION *)",
        "ret == 0");
      goto LABEL_160;
    case 785:
      if ( !alcCaptureDeviceList )
      {
        pthread_once(&alc_config_once, alc_initconfig);
        if ( pthread_mutex_lock(&ListLock) )
        {
LABEL_161:
          _assert2(
            "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
            363,
            "void EnterCriticalSection(CRITICAL_SECTION *)",
            "ret == 0");
LABEL_162:
          _assert2(
            "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
            369,
            "void LeaveCriticalSection(CRITICAL_SECTION *)",
            "ret == 0");
LABEL_163:
          _assert2(
            "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
            363,
            "void EnterCriticalSection(CRITICAL_SECTION *)",
            "ret == 0");
LABEL_164:
          _assert2(
            "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
            369,
            "void LeaveCriticalSection(CRITICAL_SECTION *)",
            "ret == 0");
          goto LABEL_165;
        }
        free(alcCaptureDeviceList);
        alcCaptureDeviceListSize = 0;
        alcCaptureDeviceList = 0;
        if ( CaptureBackend.Probe )
          CaptureBackend.Probe(CAPTURE_DEVICE_PROBE);
        if ( pthread_mutex_unlock(&ListLock) )
          goto LABEL_162;
      }
      if ( !Device )
      {
        v4 = 0;
        goto LABEL_65;
      }
      if ( !pthread_mutex_lock(&ListLock) )
      {
        v3 = (ALCdevice **)&DeviceList;
        do
        {
          v4 = *v3;
          v5 = *v3 == 0;
          if ( *v3 )
          {
            v3 = (ALCdevice **)((char *)&elf_hash_chain[6164] + (_DWORD)v4);
            v5 = v4 == Device;
          }
        }
        while ( !v5 );
        if ( v4 )
        {
          __dmb(0xBu);
          do
            v6 = __ldrex((unsigned int *)&v4->ref);
          while ( __strex(v6 + 1, (unsigned int *)&v4->ref) );
          __dmb(0xBu);
          if ( (unsigned int)LogLevel_0 >= LogRef )
            j_al_print("(--)", "ALCdevice_IncRef", "%p increasing refcount to %u\n", v4, v6 + 1);
        }
        if ( pthread_mutex_unlock(&ListLock) )
        {
          _assert2(
            "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
            369,
            "void LeaveCriticalSection(CRITICAL_SECTION *)",
            "ret == 0");
          goto LABEL_27;
        }
LABEL_65:
        free(alcCaptureDefaultDeviceSpecifier);
        v16 = (const unsigned __int8 *)&byte_61CADE;
        if ( alcCaptureDeviceList )
          v16 = alcCaptureDeviceList;
        DeviceName = j_strdup(v16);
        alcCaptureDefaultDeviceSpecifier = DeviceName;
        if ( !DeviceName )
        {
          if ( TrapALCError )
            raise(5);
          if ( v4 )
          {
            v17 = &alcCaptureDefaultDeviceSpecifier;
LABEL_74:
            v4->LastError = 40965;
            DeviceName = *v17;
LABEL_75:
            j_ALCdevice_DecRef(v4);
            return DeviceName;
          }
          v29 = &alcCaptureDefaultDeviceSpecifier;
LABEL_142:
          DeviceName = *v29;
          LastNullDeviceError = 40965;
          return DeviceName;
        }
LABEL_68:
        if ( !v4 )
          return DeviceName;
        goto LABEL_75;
      }
      _assert2(
        "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
        363,
        "void EnterCriticalSection(CRITICAL_SECTION *)",
        "ret == 0");
      goto LABEL_156;
  }
LABEL_45:
  if ( Device )
  {
    if ( pthread_mutex_lock(&ListLock) )
    {
LABEL_160:
      _assert2(
        "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
        363,
        "void EnterCriticalSection(CRITICAL_SECTION *)",
        "ret == 0");
      goto LABEL_161;
    }
    v12 = (ALCdevice **)&DeviceList;
    do
    {
      v13 = *v12;
      v14 = *v12 == 0;
      if ( *v12 )
      {
        v12 = (ALCdevice **)((char *)&elf_hash_chain[6164] + (_DWORD)v13);
        v14 = v13 == Device;
      }
    }
    while ( !v14 );
    if ( v13 )
    {
      __dmb(0xBu);
      do
        v15 = __ldrex((unsigned int *)&v13->ref);
      while ( __strex(v15 + 1, (unsigned int *)&v13->ref) );
      __dmb(0xBu);
      if ( (unsigned int)LogLevel_0 >= LogRef )
        j_al_print("(--)", "ALCdevice_IncRef", "%p increasing refcount to %u\n", v13, v15 + 1);
    }
    if ( pthread_mutex_unlock(&ListLock) )
    {
      _assert2(
        "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
        369,
        "void LeaveCriticalSection(CRITICAL_SECTION *)",
        "ret == 0");
      goto LABEL_59;
    }
  }
  else
  {
    v13 = 0;
  }
  if ( TrapALCError )
    raise(5);
  if ( v13 )
  {
    v13->LastError = 40963;
    j_ALCdevice_DecRef(v13);
  }
  else
  {
    LastNullDeviceError = 40963;
  }
  return 0;
}
// 249B22: control flows out of bounds to 249B24
// 249458: variable 'param' is possibly undefined
// 10168: using guessed type int elf_hash_chain[22025];
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);
// 61CADE: using guessed type char byte_61CADE;

//----- (00249DA8) --------------------------------------------------------
void __fastcall alcGetIntegerv(ALCdevice *device, ALCenum param, ALsizei size, ALCint *data)
{
  ALCdevice **v8; // r1
  ALCdevice *v9; // r4
  bool v10; // zf
  unsigned int v11; // r0
  bool v12; // zf
  DeviceType Type; // r0
  volatile ALCenum v14; // r1
  bool v15; // zf
  int Connected; // r0
  __int64 v17; // r0
  __int64 v18; // r0

  if ( !device )
    goto LABEL_15;
  if ( pthread_mutex_lock(&ListLock) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      363,
      "void EnterCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    JUMPOUT(0x24A0BC);
  }
  v8 = (ALCdevice **)&DeviceList;
  do
  {
    v9 = *v8;
    v10 = *v8 == 0;
    if ( *v8 )
    {
      v8 = (ALCdevice **)((char *)&elf_hash_chain[6164] + (_DWORD)v9);
      v10 = v9 == device;
    }
  }
  while ( !v10 );
  if ( v9 )
  {
    __dmb(0xBu);
    do
      v11 = __ldrex((unsigned int *)&v9->ref);
    while ( __strex(v11 + 1, (unsigned int *)&v9->ref) );
    __dmb(0xBu);
    if ( (unsigned int)LogLevel_0 >= LogRef )
      j_al_print("(--)", "ALCdevice_IncRef", "%p increasing refcount to %u\n", v9, v11 + 1);
  }
  if ( pthread_mutex_unlock(&ListLock) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      369,
      "void LeaveCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
LABEL_15:
    v9 = 0;
  }
  v12 = size == 0;
  if ( size )
    v12 = data == 0;
  if ( v12 )
  {
    if ( TrapALCError )
      raise(5);
    if ( v9 )
      goto LABEL_23;
    v14 = 40964;
LABEL_45:
    LastNullDeviceError = v14;
    return;
  }
  if ( !v9 )
  {
    if ( (unsigned int)(param - 4096) <= 0x11 )
    {
      if ( ((1 << param) & (unsigned int)&stru_3038C) != 0 )
      {
LABEL_42:
        if ( TrapALCError )
          raise(5);
        v14 = 40961;
        goto LABEL_45;
      }
      v15 = param == 4096;
      if ( param != 4096 )
        v15 = param == 4097;
      if ( v15 )
      {
        *data = 1;
        return;
      }
    }
    if ( (unsigned int)(param - 6544) >= 2 && param != 786 )
    {
      if ( TrapALCError )
        raise(5);
      v14 = 40963;
      goto LABEL_45;
    }
    goto LABEL_42;
  }
  Type = v9->Type;
  if ( Type == Capture )
  {
    if ( param != 787 )
    {
      if ( param == 786 )
      {
        (*(void (__fastcall **)(ALCdevice *))(*(int *)((char *)&elf_hash_chain[6161] + (_DWORD)v9) + 44))(v9);
        *data = (*(int (__fastcall **)(ALCdevice *))(*(int *)((char *)&elf_hash_chain[6161] + (_DWORD)v9) + 40))(v9);
        (*(void (__fastcall **)(ALCdevice *))(*(int *)((char *)&elf_hash_chain[6161] + (_DWORD)v9) + 48))(v9);
        goto LABEL_65;
      }
LABEL_51:
      if ( TrapALCError )
        raise(5);
      v9->LastError = 40963;
      goto LABEL_65;
    }
LABEL_63:
    Connected = v9->Connected;
    goto LABEL_64;
  }
  if ( param > 6543 )
  {
    if ( param <= 0x20000 )
    {
      if ( param == 6544 )
      {
        if ( Type == Loopback )
        {
          Connected = v9->FmtChans;
          goto LABEL_64;
        }
      }
      else
      {
        if ( param != 6545 )
          goto LABEL_51;
        if ( Type == Loopback )
        {
          Connected = v9->FmtType;
          goto LABEL_64;
        }
      }
LABEL_83:
      if ( TrapALCError )
        raise(5);
      v9->LastError = 40961;
      goto LABEL_65;
    }
    switch ( param )
    {
      case 131073:
LABEL_54:
        Connected = 1;
        break;
      case 131074:
LABEL_75:
        Connected = 0;
        break;
      case 131075:
        Connected = v9->NumAuxSends;
        break;
      default:
        goto LABEL_51;
    }
LABEL_64:
    *data = Connected;
    goto LABEL_65;
  }
  switch ( param )
  {
    case 4096:
    case 4097:
      goto LABEL_54;
    case 4098:
      Connected = 13;
      goto LABEL_64;
    case 4099:
      if ( size > 12 )
      {
        *data = 4103;
        data[1] = v9->Frequency;
        if ( v9->Type == Loopback )
        {
          HIDWORD(v17) = 6545;
          data[2] = 6544;
          LODWORD(v17) = v9->FmtChans;
          *(_QWORD *)(data + 3) = v17;
          LODWORD(v17) = v9->FmtType;
        }
        else
        {
          data[2] = 4104;
          v17 = *(_QWORD *)&v9->Frequency;
          data[4] = 4105;
          data[3] = (unsigned int)v17 / HIDWORD(v17);
          LODWORD(v17) = 0;
        }
        HIDWORD(v17) = 4112;
        *(_QWORD *)(data + 5) = v17;
        HIDWORD(v18) = 4113;
        LODWORD(v18) = v9->NumMonoSources;
        *(_QWORD *)(data + 7) = v18;
        HIDWORD(v18) = (char *)&elf_hash_chain[16294] + 3;
        LODWORD(v18) = v9->NumStereoSources;
        *(_QWORD *)(data + 9) = v18;
        *(_QWORD *)(data + 11) = v9->NumAuxSends;
        goto LABEL_65;
      }
      if ( TrapALCError )
        raise(5);
      break;
    case 4100:
    case 4101:
    case 4102:
    case 4106:
    case 4107:
    case 4108:
    case 4109:
    case 4110:
    case 4111:
      goto LABEL_51;
    case 4103:
      Connected = v9->Frequency;
      goto LABEL_64;
    case 4104:
      if ( Type == Loopback )
        goto LABEL_83;
      Connected = v9->Frequency / v9->UpdateSize;
      goto LABEL_64;
    case 4105:
      if ( Type != Loopback )
        goto LABEL_75;
      goto LABEL_83;
    case 4112:
      Connected = v9->NumMonoSources;
      goto LABEL_64;
    case 4113:
      Connected = v9->NumStereoSources;
      goto LABEL_64;
    default:
      if ( param == 787 )
        goto LABEL_63;
      goto LABEL_51;
  }
LABEL_23:
  v9->LastError = 40964;
LABEL_65:
  ALCdevice_DecRef(v9);
}
// 24A0BA: control flows out of bounds to 24A0BC
// 10168: using guessed type int elf_hash_chain[22025];
// 3038C: using guessed type Elf32_Sym stru_3038C;
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0024A124) --------------------------------------------------------
ALCboolean __fastcall alcIsExtensionPresent(ALCdevice *device, const ALCchar *extName)
{
  ALCdevice **v4; // r1
  ALCdevice *v5; // r4
  bool v6; // zf
  unsigned int v7; // r0
  char *v8; // r6
  int v9; // r5
  size_t v10; // r9
  int v11; // t1
  ALCboolean v12; // r5

  if ( device )
  {
    if ( pthread_mutex_lock(&ListLock) )
    {
      _assert2(
        "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
        363,
        "void EnterCriticalSection(CRITICAL_SECTION *)",
        "ret == 0");
    }
    else
    {
      v4 = (ALCdevice **)&DeviceList;
      do
      {
        v5 = *v4;
        v6 = *v4 == 0;
        if ( *v4 )
        {
          v4 = (ALCdevice **)((char *)&elf_hash_chain[6164] + (_DWORD)v5);
          v6 = v5 == device;
        }
      }
      while ( !v6 );
      if ( v5 )
      {
        __dmb(0xBu);
        do
          v7 = __ldrex((unsigned int *)&v5->ref);
        while ( __strex(v7 + 1, (unsigned int *)&v5->ref) );
        __dmb(0xBu);
        if ( (unsigned int)LogLevel_0 >= LogRef )
          j_al_print("(--)", "ALCdevice_IncRef", "%p increasing refcount to %u\n", v5, v7 + 1);
      }
      if ( !pthread_mutex_unlock(&ListLock) )
      {
        if ( extName )
          goto LABEL_15;
        goto LABEL_27;
      }
    }
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      369,
      "void LeaveCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    JUMPOUT(0x24A268);
  }
  v5 = 0;
  if ( extName )
  {
LABEL_15:
    v8 = (char *)alcExtensionList;
    if ( !v5 )
      v8 = (char *)alcNoDeviceExtList;
    v9 = (unsigned __int8)*v8;
    v10 = strlen((const char *)extName);
    while ( 1 )
    {
      if ( !v9 )
      {
LABEL_24:
        v12 = 0;
        if ( v5 )
          goto LABEL_33;
        return v12;
      }
      if ( !strncasecmp(v8, (const char *)extName, v10) && (!v8[v10] || isspace((unsigned __int8)v8[v10])) )
        break;
      v8 = strchr(v8, 32);
      if ( !v8 )
        goto LABEL_24;
      do
      {
        v11 = (unsigned __int8)*++v8;
        v9 = v11;
      }
      while ( isspace(v11) );
    }
    v12 = 1;
    if ( !v5 )
      return v12;
    goto LABEL_33;
  }
LABEL_27:
  if ( TrapALCError )
    raise(5);
  if ( v5 )
  {
    v12 = 0;
    v5->LastError = 40964;
LABEL_33:
    j_ALCdevice_DecRef(v5);
    return v12;
  }
  v12 = 0;
  LastNullDeviceError = 40964;
  return v12;
}
// 24A264: control flows out of bounds to 24A268
// 10168: using guessed type int elf_hash_chain[22025];
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0024A2AC) --------------------------------------------------------
void *__fastcall alcGetProcAddress(ALCdevice *device, const ALCchar *funcName)
{
  int v4; // r5
  ALCdevice **v6; // r1
  ALCdevice *v7; // r4
  bool v8; // zf
  unsigned int v9; // r0

  if ( !funcName )
  {
    if ( device )
    {
      if ( pthread_mutex_lock(&ListLock) )
      {
        _assert2(
          "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
          363,
          "void EnterCriticalSection(CRITICAL_SECTION *)",
          "ret == 0");
        JUMPOUT(0x24A3AC);
      }
      v6 = (ALCdevice **)&DeviceList;
      do
      {
        v7 = *v6;
        v8 = *v6 == 0;
        if ( *v6 )
        {
          v6 = (ALCdevice **)((char *)&elf_hash_chain[6164] + (_DWORD)v7);
          v8 = v7 == device;
        }
      }
      while ( !v8 );
      if ( v7 )
      {
        __dmb(0xBu);
        do
          v9 = __ldrex((unsigned int *)&v7->ref);
        while ( __strex(v9 + 1, (unsigned int *)&v7->ref) );
        __dmb(0xBu);
        if ( (unsigned int)LogLevel_0 >= LogRef )
          j_al_print("(--)", "ALCdevice_IncRef", "%p increasing refcount to %u\n", v7, v9 + 1);
      }
      if ( !pthread_mutex_unlock(&ListLock) )
        goto LABEL_22;
      _assert2(
        "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
        369,
        "void LeaveCriticalSection(CRITICAL_SECTION *)",
        "ret == 0");
    }
    v7 = 0;
LABEL_22:
    if ( TrapALCError )
      raise(5);
    if ( v7 )
    {
      v7->LastError = 40964;
      j_ALCdevice_DecRef(v7);
    }
    else
    {
      LastNullDeviceError = 40964;
    }
    return 0;
  }
  v4 = 0;
  while ( strcmp((const char *)alcFunctions[v4].funcName, (const char *)funcName) )
  {
    if ( ++v4 == 152 )
    {
      v4 = 152;
      return alcFunctions[v4].address;
    }
  }
  return alcFunctions[v4].address;
}
// 24A3AA: control flows out of bounds to 24A3AC
// 10168: using guessed type int elf_hash_chain[22025];
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0024A3F0) --------------------------------------------------------
ALCenum __fastcall alcGetEnumValue(ALCdevice *device, const ALCchar *enumName)
{
  ALCdevice *v3; // r5
  int v4; // r0
  ALCdevice **v5; // r1
  ALCdevice *v6; // r4
  bool v7; // zf
  unsigned int v8; // r0

  v3 = device;
  if ( enumName )
  {
    v3 = 0;
    while ( strcmp((const char *)enumeration[(_DWORD)v3].enumName, (const char *)enumName) )
    {
      v3 = (ALCdevice *)((char *)v3 + 1);
      v4 = 259;
      if ( v3 == (ALCdevice *)((char *)&elf_hash_bucket[1] + 3) )
        return enumeration[v4].value;
    }
    goto LABEL_20;
  }
  if ( !device )
  {
    v6 = 0;
LABEL_23:
    if ( TrapALCError )
      raise(5);
    if ( v6 )
    {
      v6->LastError = 40964;
      j_ALCdevice_DecRef(v6);
    }
    else
    {
      LastNullDeviceError = 40964;
    }
    return 0;
  }
  if ( pthread_mutex_lock(&ListLock) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      363,
      "void EnterCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    JUMPOUT(0x24A4F8);
  }
  v5 = (ALCdevice **)&DeviceList;
  do
  {
    v6 = *v5;
    v7 = *v5 == 0;
    if ( *v5 )
    {
      v5 = (ALCdevice **)((char *)&elf_hash_chain[6164] + (_DWORD)v6);
      v7 = v6 == v3;
    }
  }
  while ( !v7 );
  if ( v6 )
  {
    __dmb(0xBu);
    do
      v8 = __ldrex((unsigned int *)&v6->ref);
    while ( __strex(v8 + 1, (unsigned int *)&v6->ref) );
    __dmb(0xBu);
    if ( (unsigned int)LogLevel_0 >= LogRef )
      j_al_print("(--)", "ALCdevice_IncRef", "%p increasing refcount to %u\n", v6, v8 + 1);
  }
  if ( !pthread_mutex_unlock(&ListLock) )
    goto LABEL_23;
  _assert2(
    "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
    369,
    "void LeaveCriticalSection(CRITICAL_SECTION *)",
    "ret == 0");
LABEL_20:
  v4 = (int)v3;
  return enumeration[v4].value;
}
// 24A4F4: control flows out of bounds to 24A4F8
// FC: using guessed type int elf_hash_bucket[16411];
// 10168: using guessed type int elf_hash_chain[22025];
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0024A540) --------------------------------------------------------
ALCcontext *__fastcall alcCreateContext(ALCdevice *device, const ALCint *attrList)
{
  ALCdevice **v4; // r1
  ALCdevice *v5; // r11
  bool v6; // zf
  unsigned int v7; // r0
  DeviceType Type; // r0
  bool v9; // zf
  int v10; // r0
  unsigned int v11; // r5
  ALuint v13; // r8
  const ALCint *v14; // r1
  DevFmtType FmtType; // r9
  ALCuint v16; // r6
  int v17; // r0
  int *v18; // r3
  int v19; // r10
  ALuint v20; // r3
  MOB_ConfigKey v21; // r1
  unsigned int v22; // r5
  int v23; // r10
  MOB_ConfigValue *v24; // r0
  bool v25; // zf
  int Flags; // r0
  unsigned int Frequency; // r2
  const ALCint *v28; // r1
  ALCuint NumStereoSources; // r6
  ALCuint NumMonoSources; // r9
  char *key; // r5
  unsigned int NumAuxSends; // r8
  int v33; // r0
  unsigned int intVal; // r10
  int *v35; // r4
  ALuint MaxNoOfSources; // r4
  bool v37; // zf
  MOB_ConfigValue *p_value; // r0
  char *stringVal; // r1
  MOB_ConfigValue *v40; // r3
  ALuint v41; // r0
  int v42; // r0
  int v43; // r1
  ALuint v44; // r4
  __int64 v45; // kr10_8
  const char *v46; // r3
  const char *v47; // lr
  unsigned int v48; // r0
  char *v49; // r4
  const char *v50; // r2
  const char *v51; // r9
  ALuint v52; // r1
  DevFmtChannels FmtChans; // r0
  bool v54; // zf
  const char *v55; // r3
  const char *v56; // r1
  unsigned int v57; // r0
  bool v58; // zf
  const char *v59; // r3
  unsigned int v60; // r0
  const char *v61; // r1
  ALuint v62; // r1
  bool v63; // zf
  DevFmtChannels v64; // r1
  const char *v65; // r3
  unsigned int v66; // r0
  const char *v67; // r1
  const Hrtf *Hrtf; // r0
  DeviceType v69; // r3
  MOB_ConfigKey v70; // r0
  MOB_ConfigValue *v71; // r1
  const char *v72; // r3
  ALCint Bs2bLevel; // r6
  bs2b *Bs2b; // r5
  int v75; // r0
  int v76; // r3
  unsigned int v77; // r2
  double v78; // d16
  double v79; // d9
  double v80; // d8
  double v81; // d10
  MOB_ConfigKey v82; // r2
  ALuint v83; // r0
  const Hrtf *v84; // r1
  bool v85; // zf
  MOB_ConfigValue *v86; // r1
  ALuint UpdateSize; // r3
  unsigned int *v88; // r1
  unsigned int *v89; // r5
  unsigned int v90; // r0
  unsigned int *v91; // r10
  unsigned int v92; // r0
  unsigned int *v93; // r8
  unsigned int v94; // r0
  unsigned int *v95; // r4
  unsigned int v96; // r0
  unsigned int *v97; // r3
  int v98; // r4
  unsigned int *v99; // r6
  int v100; // r5
  int v101; // r0
  unsigned int v102; // r0
  unsigned int *v103; // r0
  unsigned int *v104; // r8
  unsigned int v105; // r0
  unsigned int *v106; // r5
  unsigned int v107; // r0
  unsigned int *v108; // r10
  unsigned int v109; // r0
  unsigned int *v110; // r4
  unsigned int v111; // r0
  unsigned int *v112; // r1
  int v113; // r8
  unsigned int v114; // r3
  int v115; // r0
  _DWORD *v116; // r12
  int v117; // r4
  unsigned int *v118; // r4
  unsigned int v119; // r5
  void (*v120)(void); // r2
  unsigned int v121; // r0
  unsigned int *v122; // r0
  int v123; // r6
  int v124; // r0
  _DWORD *v125; // r0
  void *v126; // r0
  unsigned int v127; // r0
  int v128; // r2
  int v129; // r3
  int v130; // r2
  unsigned int *p_ContextList; // r0
  int v132; // r1
  unsigned int v133; // r2
  unsigned int v134; // r2
  unsigned int v135; // r0
  unsigned int *v136; // r0
  int v137; // r0
  _DWORD *v138; // r2
  int v139; // r4
  int v140; // r5
  int v141; // r4
  _DWORD *v142; // r1
  double v143; // d11
  double v144; // r0
  double v145; // r0
  double v146; // d17
  float v147; // s2
  int srate; // r0
  unsigned int v149; // r1
  double v150; // d16
  double v151; // d9
  double v152; // d8
  double v153; // d10
  double v154; // d11
  double v155; // r0
  double v156; // r0
  double v157; // d17
  float v158; // s2
  const char *v159; // [sp+4h] [bp-64h]
  int rounding_direction; // [sp+1Ch] [bp-4Ch]
  int rounding_directiona; // [sp+1Ch] [bp-4Ch]
  ALCuint v162; // [sp+20h] [bp-48h]
  char *v163; // [sp+20h] [bp-48h]
  unsigned int v164; // [sp+24h] [bp-44h]
  unsigned int *v165; // [sp+24h] [bp-44h]

  if ( pthread_mutex_lock(&ListLock) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      363,
      "void EnterCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
LABEL_373:
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      363,
      "void EnterCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
LABEL_374:
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      369,
      "void LeaveCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
LABEL_375:
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      369,
      "void LeaveCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    goto LABEL_376;
  }
  if ( !device )
    goto LABEL_26;
  if ( pthread_mutex_lock(&ListLock) )
    goto LABEL_373;
  v4 = (ALCdevice **)&DeviceList;
  do
  {
    v5 = *v4;
    v6 = *v4 == 0;
    if ( *v4 )
    {
      v4 = (ALCdevice **)((char *)&elf_hash_chain[6164] + (_DWORD)v5);
      v6 = v5 == device;
    }
  }
  while ( !v6 );
  if ( v5 )
  {
    __dmb(0xBu);
    do
      v7 = __ldrex((unsigned int *)&v5->ref);
    while ( __strex(v7 + 1, (unsigned int *)&v5->ref) );
    __dmb(0xBu);
    if ( (unsigned int)LogLevel_0 >= LogRef )
      j_al_print("(--)", "ALCdevice_IncRef", "%p increasing refcount to %u\n", v5, v7 + 1);
  }
  if ( pthread_mutex_unlock(&ListLock) )
    goto LABEL_374;
  if ( !v5 )
  {
LABEL_26:
    if ( !pthread_mutex_unlock(&ListLock) )
    {
      if ( TrapALCError )
        raise(5);
      v11 = 0;
      LastNullDeviceError = 40961;
      return (ALCcontext *)v11;
    }
    goto LABEL_375;
  }
  Type = v5->Type;
  v9 = Type == Capture;
  if ( Type != Capture )
    v9 = v5->Connected == 0;
  if ( v9 )
  {
    if ( !pthread_mutex_unlock(&ListLock) )
    {
      if ( TrapALCError )
        raise(5);
      v10 = 40961;
      goto LABEL_24;
    }
LABEL_376:
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      369,
      "void LeaveCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
LABEL_377:
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      369,
      "void LeaveCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    goto LABEL_378;
  }
  v5->LastError = 0;
  if ( Type != Loopback )
  {
    v25 = attrList == 0;
    if ( attrList )
      v25 = *attrList == 0;
    if ( v25 )
      goto LABEL_111;
    Flags = v5->Flags;
    if ( Flags <= -1 )
    {
      (*(void (__fastcall **)(ALCdevice *))(*(int *)((char *)&elf_hash_chain[6161] + (_DWORD)v5) + 16))(v5);
      Flags = v5->Flags;
    }
    Frequency = v5->Frequency;
    v28 = attrList + 1;
    NumStereoSources = v5->NumStereoSources;
    NumMonoSources = v5->NumMonoSources;
    key = (char *)&elf_hash_chain[16294] + 3;
    NumAuxSends = v5->NumAuxSends;
    v33 = Flags & 0x7FFFFFFF;
    intVal = Frequency;
    v5->Flags = v33;
    while ( 1 )
    {
      while ( 1 )
      {
        v35 = (int *)*(v28 - 1);
        if ( v35 != (int *)((char *)&elf_hash_bucket[962] + 3) )
          break;
        intVal = *v28;
        v33 |= 2u;
        v5->Flags = v33;
        v35 = (int *)*(v28 - 1);
        if ( v35 != (int *)((char *)&elf_hash_chain[16294] + 3) )
          goto LABEL_70;
LABEL_75:
        NumAuxSends = *v28;
LABEL_66:
        v28 += 2;
      }
      if ( !v35 )
      {
        v37 = g_mob_configGlobals.keyValues == 0;
        if ( g_mob_configGlobals.keyValues )
        {
          key = (char *)g_mob_configGlobals.keyValues->key;
          v37 = g_mob_configGlobals.keyValues->key == MOB_ConfigKey_NULL;
        }
        if ( v37 )
        {
          if ( intVal <= 0x1F40 )
            intVal = 8000;
        }
        else
        {
          p_value = &g_mob_configGlobals.keyValues->value;
          stringVal = key;
          v40 = &g_mob_configGlobals.keyValues->value;
          while ( stringVal != byte_9 )
          {
            stringVal = (char *)v40[1].stringVal;
            v40 += 2;
            if ( !stringVal )
              goto LABEL_93;
          }
          intVal = v40->intVal;
LABEL_93:
          if ( intVal <= 0x1F40 )
            intVal = 8000;
          while ( key != byte_8 )
          {
            key = (char *)p_value[1].stringVal;
            p_value += 2;
            if ( !key )
              goto LABEL_99;
          }
          NumAuxSends = p_value->intVal;
        }
LABEL_99:
        v41 = v5->UpdateSize * (unsigned __int64)intVal / Frequency;
        v5->UpdateSize = v41;
        if ( NumAuxSends >= 4 )
          NumAuxSends = 4;
        if ( (unsigned __int8)CPUCapFlags << 31 )
          v5->UpdateSize = (v41 + 3) & 0xFFFFFFFC;
        v5->Frequency = intVal;
        v5->NumMonoSources = NumMonoSources;
        v5->NumStereoSources = NumStereoSources;
        v5->NumAuxSends = NumAuxSends;
        goto LABEL_111;
      }
      if ( v35 == (int *)((char *)&elf_hash_chain[16294] + 3) )
        goto LABEL_75;
LABEL_70:
      if ( v35 != (int *)((char *)&elf_hash_bucket[965] + 1) )
        goto LABEL_66;
      NumStereoSources = *v28;
      v28 += 2;
      MaxNoOfSources = v5->MaxNoOfSources;
      if ( NumStereoSources > MaxNoOfSources )
        NumStereoSources = v5->MaxNoOfSources;
      NumMonoSources = MaxNoOfSources - NumStereoSources;
    }
  }
  if ( !attrList )
  {
    if ( (unsigned int)LogLevel_0 >= LogWarning )
    {
      j_al_print("(WW)", "UpdateDeviceParams", "Missing attributes for loopback device\n");
LABEL_87:
      v19 = 40964;
      goto LABEL_343;
    }
LABEL_88:
    v19 = 40964;
    goto LABEL_343;
  }
  v13 = v5->Frequency;
  v14 = attrList + 1;
  rounding_direction = v5->FmtChans;
  FmtType = v5->FmtType;
  v162 = v5->NumMonoSources;
  v16 = v5->NumStereoSources;
  v164 = v5->NumAuxSends;
  v17 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v18 = (int *)*(v14 - 1);
          if ( (int)v18 <= 6543 )
            break;
          if ( v18 == (int *)((char *)&elf_hash_chain[16294] + 3) )
          {
            v164 = *v14;
            goto LABEL_34;
          }
          if ( v18 == (int *)((char *)&elf_hash_bucket[1573] + 1) )
          {
            FmtType = *v14;
            if ( (unsigned int)(*v14 - 5120) > 6 )
              goto LABEL_88;
            v17 |= 4u;
            v14 += 2;
          }
          else
          {
            if ( v18 != &elf_hash_bucket[1573] )
              goto LABEL_34;
            v19 = 40964;
            if ( (unsigned int)(*v14 - 5376) > 6 || *v14 == 5378 )
              goto LABEL_343;
            rounding_direction = *v14;
            v17 |= 2u;
            v14 += 2;
          }
        }
        if ( v18 != (int *)((char *)&elf_hash_bucket[962] + 3) )
          break;
        v13 = *v14;
        if ( *v14 < 0x1F40u )
          goto LABEL_88;
        v17 |= 1u;
        v14 += 2;
      }
      if ( v18 != (int *)((char *)&elf_hash_bucket[965] + 1) )
        break;
      v16 = *v14;
      v14 += 2;
      v20 = v5->MaxNoOfSources;
      if ( v16 > v20 )
        v16 = v5->MaxNoOfSources;
      v162 = v20 - v16;
    }
    if ( !v18 )
      break;
LABEL_34:
    v14 += 2;
  }
  if ( v17 != 7 )
  {
    if ( (unsigned int)LogLevel_0 >= LogWarning )
    {
      j_al_print("(WW)", "UpdateDeviceParams", "Missing format for loopback device\n");
      goto LABEL_87;
    }
    goto LABEL_88;
  }
  if ( g_mob_configGlobals.keyValues )
  {
    v21 = g_mob_configGlobals.keyValues->key;
    v22 = v164;
    v23 = rounding_direction;
    if ( g_mob_configGlobals.keyValues->key )
    {
      v24 = &g_mob_configGlobals.keyValues->value;
      while ( v21 != MOB_ConfigKey_root_sends )
      {
        v21 = (MOB_ConfigKey)v24[1].stringVal;
        v24 += 2;
        if ( v21 == MOB_ConfigKey_NULL )
          goto LABEL_106;
      }
      v22 = v24->intVal;
    }
  }
  else
  {
    v22 = v164;
    v23 = rounding_direction;
  }
LABEL_106:
  v42 = v5->Flags;
  if ( v22 >= 4 )
    v22 = 4;
  if ( v42 <= -1 )
  {
    (*(void (__fastcall **)(ALCdevice *))(*(int *)((char *)&elf_hash_chain[6161] + (_DWORD)v5) + 16))(v5);
    v42 = v5->Flags;
  }
  v5->Frequency = v13;
  v5->Flags = v42 & 0x7FFFFFFF;
  v5->FmtChans = v23;
  v5->FmtType = FmtType;
  v5->NumMonoSources = v162;
  v5->NumStereoSources = v16;
  v5->NumAuxSends = v22;
LABEL_111:
  v43 = v5->Flags;
  if ( v43 < 0 )
  {
LABEL_315:
    v125 = calloc(1u, 0x127u);
    v11 = (unsigned int)v125;
    if ( v125 )
    {
      *v125 = 1;
      v125[30] = 256;
      v125[1] = ((unsigned int)v125 + 163) & 0xFFFFFFF0;
      v126 = malloc(0x400u);
      *(_DWORD *)(v11 + 112) = v126;
      if ( v126 )
      {
        *(_DWORD *)(v11 + 136) = v5;
        __dmb(0xBu);
        do
          v127 = __ldrex((unsigned int *)&v5->ref);
        while ( __strex(v127 + 1, (unsigned int *)&v5->ref) );
        __dmb(0xBu);
        if ( (unsigned int)LogLevel_0 >= LogRef )
          j_al_print("(--)", "ALCdevice_IncRef", "%p increasing refcount to %u\n", v5, v127 + 1);
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 48) = 1065353216;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 52) = 1065353216;
        **(_DWORD **)(v11 + 4) = 0;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 4) = 0;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 8) = 0;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 12) = 0;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 16) = 0;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 20) = 0;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 24) = 0;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 28) = 0;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 32) = -1082130432;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 36) = 0;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 40) = 1065353216;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 44) = 0;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 56) = 1065353216;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 60) = 0;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 64) = 0;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 68) = 0;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 72) = 0;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 76) = 1065353216;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 80) = 0;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 84) = 0;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 88) = 0;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 92) = 0;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 96) = 1065353216;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 100) = 0;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 104) = 0;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 108) = 0;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 112) = 0;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 116) = 1065353216;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 120) = 0;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 124) = 0;
        *(_DWORD *)(*(_DWORD *)(v11 + 4) + 128) = 0;
        v128 = *(_DWORD *)(v11 + 136);
        *(_DWORD *)(v11 + 84) = 0;
        *(_DWORD *)(v11 + 80) = 0;
        *(_DWORD *)(v11 + 116) = 0;
        v129 = *(_DWORD *)(v128 + 44);
        *(_DWORD *)(v11 + 24) = 0;
        *(_DWORD *)(v11 + 28) = 0;
        *(_DWORD *)(v11 + 32) = 0;
        *(_DWORD *)(v11 + 36) = 0;
        *(_DWORD *)(v11 + 8) = 0;
        *(_DWORD *)(v11 + 12) = 0;
        *(_DWORD *)(v11 + 16) = 0;
        *(_DWORD *)(v11 + 20) = v129;
        *(_DWORD *)(v11 + 40) = 0;
        v130 = *(_DWORD *)(v128 + 48);
        *(_DWORD *)(v11 + 60) = 0;
        *(_DWORD *)(v11 + 64) = 0;
        *(_DWORD *)(v11 + 68) = 0;
        *(_DWORD *)(v11 + 72) = 0;
        *(_DWORD *)(v11 + 76) = 0;
        *(_DWORD *)(v11 + 88) = 53250;
        *(_BYTE *)(v11 + 92) = 0;
        *(_DWORD *)(v11 + 44) = 0;
        *(_DWORD *)(v11 + 48) = 0;
        *(_DWORD *)(v11 + 52) = 0;
        *(_DWORD *)(v11 + 56) = v130;
        *(_DWORD *)(v11 + 140) = alExtList;
        *(_DWORD *)(v11 + 96) = 1065353216;
        *(_DWORD *)(v11 + 100) = 1065353216;
        *(_DWORD *)(v11 + 104) = 1135322726;
        p_ContextList = (unsigned int *)&v5->ContextList;
        *(_DWORD *)(v11 + 108) = 0;
        while ( 1 )
        {
          *(_DWORD *)(v11 + 144) = *p_ContextList;
          v132 = *(_DWORD *)(v11 + 144);
          v133 = __ldrex(p_ContextList);
          if ( v133 == v132 )
            break;
LABEL_322:
          __clrex();
          __dmb(0xBu);
        }
        __dmb(0xBu);
        while ( __strex(v11, p_ContextList) )
        {
          v134 = __ldrex(p_ContextList);
          if ( v134 != v132 )
            goto LABEL_322;
        }
        __dmb(0xBu);
        if ( !pthread_mutex_unlock(&ListLock) )
        {
          j_ALCdevice_DecRef(v5);
          if ( (unsigned int)LogLevel_0 >= LogTrace )
            j_al_print("(II)", "alcCreateContext", "Created context %p\n", (const void *)v11);
          return (ALCcontext *)v11;
        }
LABEL_379:
        _assert2(
          "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
          369,
          "void LeaveCriticalSection(CRITICAL_SECTION *)",
          "ret == 0");
        JUMPOUT(0x24B8E8);
      }
    }
    if ( !*(int *)((char *)&elf_hash_chain[6160] + (_DWORD)v5) )
    {
      (*(void (__fastcall **)(ALCdevice *))(*(int *)((char *)&elf_hash_chain[6161] + (_DWORD)v5) + 16))(v5);
      v5->Flags &= ~0x80000000;
    }
    if ( pthread_mutex_unlock(&ListLock) )
    {
LABEL_378:
      _assert2(
        "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
        369,
        "void LeaveCriticalSection(CRITICAL_SECTION *)",
        "ret == 0");
      goto LABEL_379;
    }
    free((void *)v11);
    if ( TrapALCError )
      raise(5);
    v10 = 40965;
LABEL_24:
    v5->LastError = v10;
    goto LABEL_25;
  }
  v44 = v5->Frequency;
  v45 = *(_QWORD *)&v5->FmtChans;
  if ( (unsigned int)LogLevel_0 >= LogTrace )
  {
    v46 = &byte_61CADE;
    if ( (v43 & 4) != 0 )
      v46 = (const char *)&off_24B1A8;
    v47 = "Mono";
    switch ( (int)v45 )
    {
      case 5376:
        break;
      case 5377:
        v47 = "Stereo";
        break;
      case 5378:
        goto LABEL_119;
      case 5379:
        v47 = "Quadraphonic";
        break;
      case 5380:
        v47 = "5.1 Surround";
        break;
      case 5381:
        v47 = "6.1 Surround";
        break;
      case 5382:
        v47 = "7.1 Surround";
        break;
      default:
        if ( (_DWORD)v45 == 0x80000000 )
          v47 = "5.1 Side";
        else
LABEL_119:
          v47 = "(unknown channels)";
        break;
    }
    v48 = HIDWORD(v45) - 5120;
    v49 = &byte_61CADE;
    if ( (v43 & 8) != 0 )
      v49 = (char *)&off_24B1A8;
    if ( v48 > 6 )
      v50 = "(unknown type)";
    else
      v50 = off_661DC0[v48];
    v51 = &byte_61CADE;
    if ( (v43 & 2) != 0 )
      v51 = (const char *)&off_24B1A8;
    v159 = v49;
    v44 = v5->Frequency;
    j_al_print(
      "(II)",
      "UpdateDeviceParams",
      "Pre-reset: %s%s, %s%s, %s%uhz, %u update size x%d\n",
      v46,
      v47,
      v159,
      v50,
      v51,
      v44,
      v5->UpdateSize,
      v5->NumUpdates);
  }
  if ( !(*(int (__fastcall **)(ALCdevice *))(*(int *)((char *)&elf_hash_chain[6161] + (_DWORD)v5) + 8))(v5) )
    goto LABEL_342;
  FmtChans = v5->FmtChans;
  v54 = FmtChans == (_DWORD)v45;
  if ( FmtChans != (_DWORD)v45 )
  {
    v52 = v5->Flags;
    v54 = (v52 & 4) == 0;
  }
  if ( !v54 )
  {
    if ( LogLevel_0 )
    {
      v55 = "Mono";
      switch ( (int)v45 )
      {
        case 5376:
          break;
        case 5377:
          v55 = "Stereo";
          break;
        case 5378:
          goto LABEL_141;
        case 5379:
          v55 = "Quadraphonic";
          break;
        case 5380:
          v55 = "5.1 Surround";
          break;
        case 5381:
          v55 = "6.1 Surround";
          break;
        case 5382:
          v55 = "7.1 Surround";
          break;
        default:
          if ( (_DWORD)v45 == 0x80000000 )
            v55 = "5.1 Side";
          else
LABEL_141:
            v55 = "(unknown channels)";
          break;
      }
      v56 = "Mono";
      switch ( FmtChans )
      {
        case DevFmtMono:
          break;
        case DevFmtStereo:
          v56 = "Stereo";
          break;
        case DevFmtMono|0x2:
          goto LABEL_150;
        case DevFmtQuad:
          v56 = "Quadraphonic";
          break;
        case DevFmtX51:
          v56 = "5.1 Surround";
          break;
        case DevFmtX61:
          v56 = "6.1 Surround";
          break;
        case DevFmtX71:
          v56 = "7.1 Surround";
          break;
        default:
          if ( FmtChans == 0x80000000 )
            v56 = "5.1 Side";
          else
LABEL_150:
            v56 = "(unknown channels)";
          break;
      }
      j_al_print("(EE)", "UpdateDeviceParams", "Failed to set %s, got %s instead\n", v55, v56);
      v52 = v5->Flags;
    }
    v5->Flags = v52 & 0xFFFFFFFB;
  }
  v57 = v5->FmtType;
  v58 = v57 == HIDWORD(v45);
  if ( v57 != HIDWORD(v45) )
  {
    v52 = v5->Flags;
    v58 = (v52 & 8) == 0;
  }
  if ( !v58 )
  {
    if ( LogLevel_0 )
    {
      if ( (unsigned int)(HIDWORD(v45) - 5120) > 6 )
        v59 = "(unknown type)";
      else
        v59 = off_661DC0[HIDWORD(v45) - 5120];
      v60 = v57 - 5120;
      if ( v60 > 6 )
        v61 = "(unknown type)";
      else
        v61 = off_661DC0[v60];
      j_al_print("(EE)", "UpdateDeviceParams", "Failed to set %s, got %s instead\n", v59, v61);
      v52 = v5->Flags;
    }
    v57 = v52 & 0xFFFFFFF7;
    v5->Flags = v52 & 0xFFFFFFF7;
  }
  v62 = v5->Frequency;
  v63 = v62 == v44;
  if ( v62 != v44 )
  {
    v57 = v5->Flags;
    v63 = (v57 & 2) == 0;
  }
  if ( !v63 )
  {
    if ( LogLevel_0 )
    {
      j_al_print("(EE)", "UpdateDeviceParams", "Failed to set %uhz, got %uhz instead\n", v44, v5->Frequency);
      v57 = v5->Flags;
    }
    v5->Flags = v57 & 0xFFFFFFFD;
  }
  if ( (unsigned int)LogLevel_0 >= LogTrace )
  {
    v64 = v5->FmtChans;
    v65 = "Mono";
    switch ( v64 )
    {
      case DevFmtMono:
        break;
      case DevFmtStereo:
        v65 = "Stereo";
        break;
      case DevFmtMono|0x2:
        goto LABEL_180;
      case DevFmtQuad:
        v65 = "Quadraphonic";
        break;
      case DevFmtX51:
        v65 = "5.1 Surround";
        break;
      case DevFmtX61:
        v65 = "6.1 Surround";
        break;
      case DevFmtX71:
        v65 = "7.1 Surround";
        break;
      default:
        if ( v64 == 0x80000000 )
          v65 = "5.1 Side";
        else
LABEL_180:
          v65 = "(unknown channels)";
        break;
    }
    v66 = v5->FmtType - 5120;
    if ( v66 > 6 )
      v67 = "(unknown type)";
    else
      v67 = off_661DC0[v66];
    j_al_print(
      "(II)",
      "UpdateDeviceParams",
      "Post-reset: %s, %s, %uhz, %u update size x%d\n",
      v65,
      v67,
      v5->Frequency,
      v5->UpdateSize,
      v5->NumUpdates);
  }
  j_aluInitPanning(v5);
  Hrtf = 0;
  *(int *)((char *)&elf_hash_chain[6146] + (_DWORD)v5) = 0;
  *(int *)((char *)&elf_hash_chain[6158] + (_DWORD)v5) = 0;
  *((_BYTE *)&elf_hash_chain[6163] + (_DWORD)v5) = 0;
  v5->Hrtf = 0;
  v69 = v5->Type;
  *(_QWORD *)&v5->ClickRemoval[4] = 0LL;
  *(_QWORD *)&v5->ClickRemoval[6] = 0LL;
  *(_QWORD *)v5->ClickRemoval = 0LL;
  *(_QWORD *)&v5->ClickRemoval[2] = 0LL;
  *(_QWORD *)&v5->PendingClicks[4] = 0LL;
  *(_QWORD *)&v5->PendingClicks[6] = 0LL;
  *(_QWORD *)v5->PendingClicks = 0LL;
  *(_QWORD *)&v5->PendingClicks[2] = 0LL;
  if ( v69 != Loopback )
  {
    if ( !g_mob_configGlobals.keyValues )
      goto LABEL_200;
    v70 = g_mob_configGlobals.keyValues->key;
    if ( g_mob_configGlobals.keyValues->key == MOB_ConfigKey_NULL )
      goto LABEL_200;
    v71 = &g_mob_configGlobals.keyValues->value;
    while ( v70 != MOB_ConfigKey_root_hrtf )
    {
      v70 = (MOB_ConfigKey)v71[1].stringVal;
      v71 += 2;
      if ( v70 == MOB_ConfigKey_NULL )
        goto LABEL_200;
    }
    if ( v71->intVal )
    {
      Hrtf = j_GetHrtf(v5);
      v5->Hrtf = Hrtf;
      if ( Hrtf )
        *((_BYTE *)&elf_hash_chain[6163] + (_DWORD)v5) = 1;
      else
        Hrtf = 0;
    }
    else
    {
LABEL_200:
      Hrtf = 0;
    }
  }
  if ( (unsigned int)LogLevel_0 >= LogTrace )
  {
    v72 = "enabled";
    if ( !Hrtf )
      v72 = "disabled";
    j_al_print("(II)", "UpdateDeviceParams", "HRTF %s\n", v72);
    Hrtf = v5->Hrtf;
  }
  if ( Hrtf || (Bs2bLevel = v5->Bs2bLevel, (unsigned int)(Bs2bLevel - 1) > 5) )
  {
    free(v5->Bs2b);
    v5->Bs2b = 0;
    if ( (unsigned int)LogLevel_0 >= LogTrace )
      j_al_print("(II)", "UpdateDeviceParams", "BS2B disabled\n");
  }
  else
  {
    Bs2b = v5->Bs2b;
    if ( !Bs2b )
    {
      Bs2b = (bs2b *)calloc(1u, 0x68u);
      v5->Bs2b = Bs2b;
      Bs2b->last_sample.hi[0] = 0.0;
      Bs2b->last_sample.hi[1] = 0.0;
      Bs2b->last_sample.lo[0] = 0.0;
      Bs2b->last_sample.lo[1] = 0.0;
      Bs2b->last_sample.asis[0] = 0.0;
      Bs2b->last_sample.asis[1] = 0.0;
    }
    v75 = v5->Frequency;
    if ( Bs2b->srate != v75 )
    {
      v76 = v5->Frequency;
      v77 = Bs2b->level - 1;
      if ( v75 - 2000 > (unsigned int)&stru_2E62C.st_value )
        v76 = 44100;
      Bs2b->srate = v76;
      if ( v77 >= 5 )
      {
        v78 = -4398.22972;
        v80 = 0.205671765;
        v79 = 0.398107171;
        v81 = -6126.10567;
        Bs2b->level = 6;
      }
      else
      {
        v78 = dbl_60A370[v77];
        v79 = dbl_60A310[v77];
        v80 = dbl_60A340[v77];
        v81 = dbl_60A2E0[v77];
      }
      v143 = (double)v75;
      if ( v75 - 2000 > (unsigned int)&stru_2E62C.st_value )
        v143 = 44100.0;
      v144 = exp(v78 / v143);
      Bs2b->a0_lo = v79 * (1.0 - v144);
      Bs2b->b1_lo = v144;
      v145 = exp(v81 / v143);
      v146 = v145;
      HIDWORD(v145) ^= 0x80000000;
      v147 = v79 + 1.0 - v80;
      Bs2b->gain = 1.0 / v147;
      Bs2b->a0_hi = 1.0 - v80 * (1.0 - v146);
      Bs2b->a1_hi = v145;
      Bs2b->b1_hi = v146;
      Bs2bLevel = v5->Bs2bLevel;
      Bs2b = v5->Bs2b;
    }
    if ( Bs2b->level != Bs2bLevel )
    {
      srate = Bs2b->srate;
      Bs2b->level = Bs2bLevel;
      v149 = Bs2bLevel - 1;
      if ( srate - 2000 > (unsigned int)&stru_2E62C.st_value )
      {
        srate = 44100;
        Bs2b->srate = 44100;
      }
      if ( v149 >= 5 )
      {
        v150 = -4398.22972;
        v152 = 0.205671765;
        v151 = 0.398107171;
        v153 = -6126.10567;
        Bs2b->level = 6;
      }
      else
      {
        v150 = dbl_60A370[v149];
        v151 = dbl_60A310[v149];
        v152 = dbl_60A340[v149];
        v153 = dbl_60A2E0[v149];
      }
      v154 = (double)srate;
      v155 = exp(v150 / (double)srate);
      Bs2b->a0_lo = v151 * (1.0 - v155);
      Bs2b->b1_lo = v155;
      v156 = exp(v153 / v154);
      v157 = v156;
      HIDWORD(v156) ^= 0x80000000;
      v158 = v151 + 1.0 - v152;
      Bs2b->gain = 1.0 / v158;
      Bs2b->a0_hi = 1.0 - v152 * (1.0 - v157);
      Bs2b->a1_hi = v156;
      Bs2b->b1_hi = v157;
    }
    if ( (unsigned int)LogLevel_0 >= LogTrace )
      j_al_print("(II)", "UpdateDeviceParams", "BS2B level %d\n", v5->Bs2bLevel);
  }
  v82 = v5->Type;
  v83 = v5->Flags;
  v84 = v5->Hrtf;
  v5->Flags = v83 & 0xFFFEFFFF;
  if ( v82 == MOB_ConfigKey_root_rt_prio )
  {
    if ( !v84 )
      goto LABEL_229;
  }
  else if ( !v84 )
  {
    v85 = g_mob_configGlobals.keyValues == 0;
    if ( g_mob_configGlobals.keyValues )
    {
      v82 = g_mob_configGlobals.keyValues->key;
      v85 = g_mob_configGlobals.keyValues->key == MOB_ConfigKey_NULL;
    }
    if ( !v85 )
    {
      v86 = &g_mob_configGlobals.keyValues->value;
      while ( v82 != MOB_ConfigKey_root_wide_stereo )
      {
        v82 = (MOB_ConfigKey)v86[1].stringVal;
        v86 += 2;
        if ( v82 == MOB_ConfigKey_NULL )
          goto LABEL_229;
      }
      if ( v86->intVal )
        v5->Flags = v83 | 0x10000;
    }
LABEL_229:
    UpdateSize = v5->UpdateSize;
    if ( (UpdateSize & 3) != 0 && CPUCapFlags << 31 && (unsigned int)LogLevel_0 >= LogWarning )
      j_al_print("(WW)", "UpdateDeviceParams", "SSE performs best with multiple of 4 update sizes (%u)\n", UpdateSize);
  }
  rounding_directiona = fegetround();
  fesetround(3);
  v163 = (char *)&elf_hash_chain[6161] + (_DWORD)v5;
  (*(void (__fastcall **)(ALCdevice *))(*(int *)((char *)&elf_hash_chain[6161] + (_DWORD)v5) + 44))(v5);
  v88 = *(unsigned int **)((char *)&elf_hash_chain[6160] + (_DWORD)v5);
  if ( v88 )
  {
    while ( 1 )
    {
      v89 = v88 + 18;
      v88[21] = 0;
      __dmb(0xBu);
      v165 = v88;
      do
        v90 = __ldrex(v89);
      while ( __strex(1u, v89) );
      while ( 1 )
      {
        __dmb(0xBu);
        if ( v90 != 1 )
          break;
        sched_yield();
        __dmb(0xBu);
        do
          v90 = __ldrex(v89);
        while ( __strex(1u, v89) );
      }
      __dmb(0xBu);
      v91 = v165 + 17;
      do
        v92 = __ldrex(v91);
      while ( __strex(1u, v91) );
      while ( 1 )
      {
        __dmb(0xBu);
        if ( v92 != 1 )
          break;
        sched_yield();
        __dmb(0xBu);
        do
          v92 = __ldrex(v91);
        while ( __strex(1u, v91) );
      }
      __dmb(0xBu);
      v93 = v165 + 15;
      do
        v94 = __ldrex(v93);
      while ( __strex(v94 + 1, v93) );
      __dmb(0xBu);
      if ( !v94 )
      {
        __dmb(0xBu);
        v95 = v165 + 19;
        do
          v96 = __ldrex(v95);
        while ( __strex(1u, v95) );
        while ( 1 )
        {
          __dmb(0xBu);
          if ( v96 != 1 )
            break;
          sched_yield();
          __dmb(0xBu);
          do
            v96 = __ldrex(v95);
          while ( __strex(1u, v95) );
        }
      }
      __dmb(0xBu);
      do
        __ldrex(v91);
      while ( __strex(0, v91) );
      __dmb(0xBu);
      __dmb(0xBu);
      v97 = v165;
      do
        __ldrex(v89);
      while ( __strex(0, v89) );
      __dmb(0xBu);
      if ( (int)v165[12] >= 1 )
        break;
LABEL_263:
      __dmb(0xBu);
      do
        v102 = __ldrex(v93);
      while ( __strex(v102 - 1, v93) );
      __dmb(0xBu);
      if ( v102 == 1 )
      {
        v103 = v97 + 19;
        __dmb(0xBu);
        do
          __ldrex(v103);
        while ( __strex(0, v103) );
        __dmb(0xBu);
      }
      v104 = v97 + 9;
      __dmb(0xBu);
      do
        v105 = __ldrex(v104);
      while ( __strex(1u, v104) );
      while ( 1 )
      {
        __dmb(0xBu);
        if ( v105 != 1 )
          break;
        sched_yield();
        __dmb(0xBu);
        do
          v105 = __ldrex(v104);
        while ( __strex(1u, v104) );
      }
      __dmb(0xBu);
      v106 = v165 + 8;
      do
        v107 = __ldrex(v106);
      while ( __strex(1u, v106) );
      while ( 1 )
      {
        __dmb(0xBu);
        if ( v107 != 1 )
          break;
        sched_yield();
        __dmb(0xBu);
        do
          v107 = __ldrex(v106);
        while ( __strex(1u, v106) );
      }
      __dmb(0xBu);
      v108 = v165 + 6;
      do
        v109 = __ldrex(v108);
      while ( __strex(v109 + 1, v108) );
      __dmb(0xBu);
      if ( !v109 )
      {
        __dmb(0xBu);
        v110 = v165 + 10;
        do
          v111 = __ldrex(v110);
        while ( __strex(1u, v110) );
        while ( 1 )
        {
          __dmb(0xBu);
          if ( v111 != 1 )
            break;
          sched_yield();
          __dmb(0xBu);
          do
            v111 = __ldrex(v110);
          while ( __strex(1u, v110) );
        }
      }
      __dmb(0xBu);
      do
        __ldrex(v106);
      while ( __strex(0, v106) );
      __dmb(0xBu);
      __dmb(0xBu);
      v112 = v165;
      do
        __ldrex(v104);
      while ( __strex(0, v104) );
      __dmb(0xBu);
      if ( (int)v165[3] >= 1 )
      {
        v113 = 0;
        do
        {
          v114 = v5->NumAuxSends;
          v115 = *(_DWORD *)(v112[2] + 8 * v113 + 4);
          if ( v114 <= 3 )
          {
            do
            {
              v116 = (_DWORD *)(v115 + 12 * v114);
              v117 = v116[43];
              if ( v117 )
              {
                v118 = (unsigned int *)(v117 + 8408);
                __dmb(0xBu);
                do
                  v119 = __ldrex(v118);
                while ( __strex(v119 - 1, v118) );
                __dmb(0xBu);
              }
              ++v114;
              v116[43] = 0;
              v116[44] = 1065353216;
              v116[45] = 1065353216;
            }
            while ( v114 != 4 );
          }
          v120 = *(void (**)(void))(v115 + 22916);
          *(_DWORD *)(v115 + 22912) = 0;
          v120();
          v112 = v165;
          ++v113;
        }
        while ( v113 < (int)v165[3] );
      }
      __dmb(0xBu);
      do
        v121 = __ldrex(v108);
      while ( __strex(v121 - 1, v108) );
      __dmb(0xBu);
      if ( v121 == 1 )
      {
        v122 = v112 + 10;
        __dmb(0xBu);
        do
          __ldrex(v122);
        while ( __strex(0, v122) );
        __dmb(0xBu);
      }
      v88 = (unsigned int *)v112[36];
      if ( !v88 )
        goto LABEL_310;
    }
    v98 = 0;
    while ( 1 )
    {
      v99 = v97;
      v100 = *(_DWORD *)(v97[11] + 8 * v98 + 4);
      if ( !(*(int (**)(void))(*(_DWORD *)(v100 + 196) + 4))() )
        break;
      v101 = *(_DWORD *)(v100 + 196);
      *(_DWORD *)(v100 + 192) = 0;
      (*(void (**)(void))(v101 + 8))();
      ++v98;
      v97 = v99;
      if ( v98 >= (int)v99[12] )
        goto LABEL_263;
    }
    __dmb(0xBu);
    do
      v135 = __ldrex(v93);
    while ( __strex(v135 - 1, v93) );
    __dmb(0xBu);
    if ( v135 == 1 )
    {
      v136 = v165 + 19;
      __dmb(0xBu);
      do
        __ldrex(v136);
      while ( __strex(0, v136) );
      __dmb(0xBu);
    }
    v137 = *(_DWORD *)v163;
LABEL_341:
    (*(void (__fastcall **)(ALCdevice *))(v137 + 48))(v5);
    fesetround(rounding_directiona);
    goto LABEL_342;
  }
LABEL_310:
  v123 = *(int *)((char *)&elf_hash_chain[6159] + (_DWORD)v5);
  if ( v123 )
  {
    if ( !(*(int (**)(void))(*(_DWORD *)(v123 + 196) + 4))() )
    {
      v137 = *(_DWORD *)v163;
      goto LABEL_341;
    }
    v124 = *(_DWORD *)(v123 + 196);
    *(_DWORD *)(v123 + 192) = 0;
    (*(void (**)(void))(v124 + 8))();
  }
  (*(void (__fastcall **)(ALCdevice *))(*(_DWORD *)v163 + 48))(v5);
  fesetround(rounding_directiona);
  if ( (*(int (__fastcall **)(ALCdevice *))(*(_DWORD *)v163 + 12))(v5) )
  {
    v5->Flags |= 0x80000000;
    goto LABEL_315;
  }
LABEL_342:
  v19 = 40961;
LABEL_343:
  if ( pthread_mutex_unlock(&ListLock) )
    goto LABEL_377;
  if ( TrapALCError )
    raise(5);
  v5->LastError = v19;
  if ( v19 == 40961 )
  {
    (*(void (__fastcall **)(ALCdevice *))(*(int *)((char *)&elf_hash_chain[6161] + (_DWORD)v5) + 44))(v5);
    v138 = *(_DWORD **)((char *)&elf_hash_chain[6160] + (_DWORD)v5);
    v5->Connected = 0;
    if ( v138 )
    {
      do
      {
        v139 = v138[29];
        if ( v139 )
        {
          v140 = v138[28];
          v141 = 4 * v139;
          do
          {
            if ( *(_DWORD *)(*(_DWORD *)v140 + 128) == 4114 )
            {
              *(_DWORD *)(*(_DWORD *)v140 + 128) = 4116;
              *(_DWORD *)(*(_DWORD *)v140 + 152) = *(_DWORD *)(*(_DWORD *)v140 + 148);
              *(_DWORD *)(*(_DWORD *)v140 + 136) = 0;
              *(_DWORD *)(*(_DWORD *)v140 + 140) = 0;
            }
            v141 -= 4;
            v140 += 4;
          }
          while ( v141 );
        }
        v142 = (_DWORD *)v138[36];
        v138[29] = 0;
        v138 = v142;
      }
      while ( v142 );
    }
    (*(void (__fastcall **)(ALCdevice *))(*(int *)((char *)&elf_hash_chain[6161] + (_DWORD)v5) + 48))(v5);
  }
LABEL_25:
  j_ALCdevice_DecRef(v5);
  return 0;
}
// 24B8E6: control flows out of bounds to 24B8E8
// 24AB2E: variable 'v52' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 10168: using guessed type int elf_hash_chain[22025];
// 2E62C: using guessed type Elf32_Sym stru_2E62C;
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);
// 24B1A8: using guessed type __int16 *off_24B1A8;
// 60A2E0: using guessed type double dbl_60A2E0[6];
// 60A310: using guessed type double dbl_60A310[6];
// 60A340: using guessed type double dbl_60A340[6];
// 60A370: using guessed type double dbl_60A370[6];
// 61CADE: using guessed type char byte_61CADE;
// 661DC0: using guessed type char *off_661DC0[6];

//----- (0024BAD8) --------------------------------------------------------
ALvoid __fastcall aluHandleDisconnect(ALCdevice *device)
{
  _DWORD *v1; // lr
  int v2; // r2
  int v3; // r3
  int v4; // r2
  _DWORD *v5; // r2

  v1 = *(_DWORD **)((char *)&elf_hash_chain[6160] + (_DWORD)device);
  device->Connected = 0;
  if ( v1 )
  {
    do
    {
      v2 = v1[29];
      if ( v2 )
      {
        v3 = v1[28];
        v4 = 4 * v2;
        do
        {
          if ( *(_DWORD *)(*(_DWORD *)v3 + 128) == 4114 )
          {
            *(_DWORD *)(*(_DWORD *)v3 + 128) = 4116;
            *(_DWORD *)(*(_DWORD *)v3 + 152) = *(_DWORD *)(*(_DWORD *)v3 + 148);
            *(_DWORD *)(*(_DWORD *)v3 + 136) = 0;
            *(_DWORD *)(*(_DWORD *)v3 + 140) = 0;
          }
          v4 -= 4;
          v3 += 4;
        }
        while ( v4 );
      }
      v5 = (_DWORD *)v1[36];
      v1[29] = 0;
      v1 = v5;
    }
    while ( v5 );
  }
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (0024BB44) --------------------------------------------------------
void __fastcall alcDestroyContext(ALCcontext *context)
{
  ALCcontext *v2; // r0
  ALCdevice *Device; // r5

  if ( pthread_mutex_lock(&ListLock) )
  {
LABEL_11:
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      363,
      "void EnterCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    JUMPOUT(0x24BBEC);
  }
  v2 = VerifyContext(context);
  if ( v2 )
  {
    Device = v2->Device;
    j_ALCcontext_DecRef(v2);
    if ( Device )
    {
      ReleaseContext(context, Device);
      if ( !*(int *)((char *)&elf_hash_chain[6160] + (_DWORD)Device) )
      {
        (*(void (__fastcall **)(ALCdevice *))(*(int *)((char *)&elf_hash_chain[6161] + (_DWORD)Device) + 16))(Device);
        Device->Flags &= ~0x80000000;
      }
    }
  }
  else
  {
    if ( TrapALCError )
      raise(5);
    LastNullDeviceError = 40962;
  }
  if ( pthread_mutex_unlock(&ListLock) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      369,
      "void LeaveCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    goto LABEL_11;
  }
}
// 24BBEA: control flows out of bounds to 24BBEC
// 10168: using guessed type int elf_hash_chain[22025];
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0024BC14) --------------------------------------------------------
ALCdevice *__fastcall alcGetContextsDevice(ALCcontext *Context)
{
  ALCcontext *v1; // r0
  ALCdevice *Device; // r4

  v1 = VerifyContext(Context);
  if ( v1 )
  {
    Device = v1->Device;
    j_ALCcontext_DecRef(v1);
    return Device;
  }
  else
  {
    if ( TrapALCError )
      raise(5);
    LastNullDeviceError = 40962;
    return 0;
  }
}

//----- (0024BC54) --------------------------------------------------------
void __fastcall ReleaseContext(ALCcontext *context, ALCdevice *device)
{
  ALCcontext *v4; // r0
  ALCcontext *v5; // r3
  unsigned int *v6; // r1
  ALCcontext *volatile next; // r2
  ALCcontext *v8; // r3
  ALCcontext *v9; // r3
  unsigned int v10; // r1
  int v11; // t1

  if ( pthread_getspecific(LocalContext) == context )
  {
    if ( (unsigned int)LogLevel_0 >= LogWarning )
      j_al_print("(WW)", "ReleaseContext", "%p released while current on thread\n", context);
    pthread_setspecific(LocalContext, 0);
    j_ALCcontext_DecRef(context);
  }
  v4 = (ALCcontext *)__ldrex((unsigned int *)&GlobalContext);
  if ( v4 == context )
  {
    __dmb(0xBu);
    while ( __strex(0, (unsigned int *)&GlobalContext) )
    {
      v5 = (ALCcontext *)__ldrex((unsigned int *)&GlobalContext);
      if ( v5 != context )
        goto LABEL_9;
    }
    __dmb(0xBu);
    j_ALCcontext_DecRef(context);
  }
  else
  {
LABEL_9:
    __clrex();
    __dmb(0xBu);
  }
  (*(void (__fastcall **)(ALCdevice *))(*(int *)((char *)&elf_hash_chain[6161] + (_DWORD)device) + 44))(device);
  if ( *(int *)((char *)&elf_hash_chain[6160] + (_DWORD)device) )
  {
    v6 = (unsigned int *)((char *)&elf_hash_chain[6160] + (_DWORD)device);
    while ( 1 )
    {
      next = context->next;
      v8 = (ALCcontext *)__ldrex(v6);
      if ( v8 == context )
        break;
LABEL_17:
      __clrex();
      __dmb(0xBu);
      v10 = *v6;
      v11 = *(_DWORD *)(v10 + 144);
      v6 = (unsigned int *)(v10 + 144);
      if ( !v11 )
        goto LABEL_20;
    }
    __dmb(0xBu);
    while ( __strex((unsigned int)next, v6) )
    {
      v9 = (ALCcontext *)__ldrex(v6);
      if ( v9 != context )
        goto LABEL_17;
    }
    __dmb(0xBu);
  }
LABEL_20:
  (*(void (__fastcall **)(ALCdevice *))(*(int *)((char *)&elf_hash_chain[6161] + (_DWORD)device) + 48))(device);
  ALCcontext_DecRef(context);
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (0024BD98) --------------------------------------------------------
ALCcontext *alcGetCurrentContext()
{
  ALCcontext *result; // r0

  result = (ALCcontext *)pthread_getspecific(LocalContext);
  if ( !result )
    return GlobalContext;
  return result;
}

//----- (0024BDBC) --------------------------------------------------------
ALCcontext *alcGetThreadContext()
{
  return (ALCcontext *)sub_199500(LocalContext);
}

//----- (0024BDCC) --------------------------------------------------------
ALCboolean __fastcall alcMakeContextCurrent(ALCcontext *context)
{
  ALCcontext *v1; // r0
  ALCcontext *v3; // r1
  ALCcontext *v4; // r4

  if ( context )
  {
    v1 = VerifyContext(context);
    if ( !v1 )
    {
      if ( TrapALCError )
        raise(5);
      LastNullDeviceError = 40962;
      return 0;
    }
  }
  else
  {
    v1 = 0;
  }
  __dmb(0xBu);
  do
    v3 = (ALCcontext *)__ldrex((unsigned int *)&GlobalContext);
  while ( __strex((unsigned int)v1, (unsigned int *)&GlobalContext) );
  __dmb(0xBu);
  if ( v3 )
    j_ALCcontext_DecRef(v3);
  v4 = (ALCcontext *)pthread_getspecific(LocalContext);
  if ( v4 )
  {
    pthread_setspecific(LocalContext, 0);
    j_ALCcontext_DecRef(v4);
  }
  return 1;
}

//----- (0024BE54) --------------------------------------------------------
ALCcontext *__fastcall VerifyContext(ALCcontext *context)
{
  ALCdevice *volatile v2; // r0
  ALCcontext *v3; // r3

  if ( pthread_mutex_lock(&ListLock) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      363,
      "void EnterCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    JUMPOUT(0x24BEC4);
  }
  v2 = DeviceList;
  if ( DeviceList )
  {
    while ( 1 )
    {
      v3 = *(ALCcontext **)((char *)&elf_hash_chain[6160] + (_DWORD)v2);
      if ( v3 )
        break;
LABEL_8:
      v2 = *(ALCdevice *volatile *)((char *)&elf_hash_chain[6164] + (_DWORD)v2);
      if ( !v2 )
        goto LABEL_9;
    }
    while ( v3 != context )
    {
      v3 = v3->next;
      if ( !v3 )
        goto LABEL_8;
    }
    j_ALCcontext_IncRef(context);
    UnlockLists();
    return context;
  }
  else
  {
LABEL_9:
    UnlockLists();
    return 0;
  }
}
// 24BEC2: control flows out of bounds to 24BEC4
// 10168: using guessed type int elf_hash_chain[22025];
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0024BED8) --------------------------------------------------------
ALCboolean __fastcall alcSetThreadContext(ALCcontext *context)
{
  ALCcontext *v1; // r4
  ALCcontext *v3; // r5

  if ( context )
  {
    v1 = VerifyContext(context);
    if ( !v1 )
    {
      if ( TrapALCError )
        raise(5);
      LastNullDeviceError = 40962;
      return 0;
    }
  }
  else
  {
    v1 = 0;
  }
  v3 = (ALCcontext *)pthread_getspecific(LocalContext);
  pthread_setspecific(LocalContext, v1);
  if ( v3 )
    j_ALCcontext_DecRef(v3);
  return 1;
}

//----- (0024BF40) --------------------------------------------------------
ALCdevice *__fastcall alcOpenDevice(const ALCchar *deviceName)
{
  bool v2; // zf
  _BYTE *v3; // r0
  unsigned int i; // r4
  unsigned int uintVal; // r3
  unsigned int *v6; // r9
  MOB_ConfigKey v7; // r2
  const MOB_ConfigKeyValue *keyValues; // r11
  MOB_ConfigKey key; // r0
  MOB_ConfigValue *p_value; // r1
  volatile ALCenum v11; // r1
  const char *intVal; // r6
  int v13; // r0
  MOB_ConfigKey stringVal; // r0
  MOB_ConfigValue *v15; // r1
  const char *v16; // r6
  int v17; // r0
  const unsigned __int8 *ConfigValue; // r6
  int v19; // r0
  int v20; // r1
  const MOB_ConfigKeyValue *v21; // r0
  MOB_ConfigValue *v22; // r1
  MOB_ConfigValue *v23; // r1
  unsigned int v24; // r1
  bool v25; // zf
  MOB_ConfigValue *v26; // r1
  unsigned int v27; // r1
  int v28; // r2
  int v29; // r2
  bool v30; // zf
  MOB_ConfigValue *v31; // r1
  int v32; // r1
  bool v33; // zf
  MOB_ConfigValue *v34; // r2
  int v35; // r2
  bool v36; // zf
  MOB_ConfigValue *v37; // r2
  unsigned int v38; // r2
  bool v39; // zf
  MOB_ConfigValue *v40; // r0
  __int64 v41; // r0
  int v42; // r5
  int v43; // t1
  unsigned int v44; // r5
  _DWORD *v45; // r0
  __int64 v46; // r2
  int v47; // r6
  unsigned int v48; // r5
  unsigned int v49; // r5
  char *v51; // [sp+4h] [bp-24h]

  pthread_once(&alc_config_once, alc_initconfig);
  if ( !PlaybackBackend.name )
  {
    if ( TrapALCError )
      raise(5);
    v11 = 40964;
    goto LABEL_25;
  }
  v2 = deviceName == 0;
  if ( deviceName )
    v2 = *deviceName == 0;
  if ( v2 || !strcasecmp((const char *)deviceName, (const char *)alcDefaultName) )
  {
    deviceName = 0;
  }
  else if ( !strcasecmp((const char *)deviceName, "openal-soft") )
  {
    deviceName = 0;
  }
  v3 = malloc(0x182BFu);
  if ( !v3 )
  {
    if ( TrapALCError )
      raise(5);
    v11 = 40965;
LABEL_25:
    LastNullDeviceError = v11;
    return 0;
  }
  *v3 = 0;
  for ( i = (unsigned int)(v3 + 1); (i & 0xF) != 0; *(_BYTE *)i++ = 85 )
    ;
  memset((void *)i, 0, (size_t)&elf_hash_chain[8273] + 3);
  *(int *)((char *)&elf_hash_chain[6161] + i) = (int)&PlaybackBackend.Funcs;
  *(_BYTE *)(i + 4) = 1;
  *(_DWORD *)i = 1;
  *(_DWORD *)(i + 8) = 0;
  j_InitializeCriticalSection((CRITICAL_SECTION *)(i + 12));
  *(_DWORD *)(i + 40) = 0;
  v6 = (unsigned int *)(i + 16);
  *(_DWORD *)(i + 176) = 0;
  *(_DWORD *)(i + 180) = 0;
  *(_DWORD *)(i + 184) = 0;
  *(_DWORD *)(i + 36) = 0;
  *(int *)((char *)&elf_hash_chain[6160] + i) = 0;
  *(_DWORD *)(i + 80) = 0;
  *(_DWORD *)(i + 84) = 0;
  *(_DWORD *)(i + 88) = 0;
  *(_DWORD *)(i + 92) = 0;
  *(_DWORD *)(i + 96) = 0;
  *(_DWORD *)(i + 116) = 0;
  *(_DWORD *)(i + 120) = 0;
  *(_DWORD *)(i + 124) = 0;
  *(_DWORD *)(i + 44) = 256;
  *(_DWORD *)(i + 48) = 4;
  v7 = -1;
  *(_DWORD *)(i + 128) = 0;
  *(_DWORD *)(i + 132) = 0;
  *(_DWORD *)(i + 60) = 4;
  *(_DWORD *)(i + 64) = 0;
  *(_DWORD *)(i + 68) = 0;
  *(_DWORD *)(i + 72) = 0;
  *(_DWORD *)(i + 76) = -1;
  *(_DWORD *)(i + 100) = 0;
  *(_DWORD *)(i + 104) = 0;
  *(_DWORD *)(i + 108) = 0;
  *(_DWORD *)(i + 112) = -1;
  *(_DWORD *)(i + 152) = 0;
  *(_DWORD *)(i + 156) = 0;
  *(_DWORD *)(i + 160) = 0;
  *(_DWORD *)(i + 164) = 0;
  *(_DWORD *)(i + 136) = 0;
  *(_DWORD *)(i + 140) = 0;
  *(_DWORD *)(i + 144) = 0;
  *(_DWORD *)(i + 148) = -1;
  *(_DWORD *)(i + 168) = 0;
  keyValues = g_mob_configGlobals.keyValues;
  *(_DWORD *)(i + 32) = 5126;
  *(_QWORD *)(i + 16) = loc_24C840;
  *(_QWORD *)(i + 24) = loc_24C848;
  if ( keyValues )
  {
    key = keyValues->key;
    if ( keyValues->key == MOB_ConfigKey_NULL )
      goto LABEL_42;
    p_value = &keyValues->value;
    while ( key != MOB_ConfigKey_root_channels )
    {
      key = (MOB_ConfigKey)p_value[1].stringVal;
      p_value += 2;
      if ( key == MOB_ConfigKey_NULL )
        goto LABEL_42;
    }
    intVal = (const char *)p_value->intVal;
    if ( !strcasecmp("mono", (const char *)p_value->stringVal) )
    {
      v13 = 0;
    }
    else if ( !strcasecmp("stereo", intVal) )
    {
      v13 = 1;
    }
    else if ( !strcasecmp("quad", intVal) )
    {
      v13 = 2;
    }
    else if ( !strcasecmp("surround51", intVal) )
    {
      v13 = 3;
    }
    else if ( !strcasecmp("surround61", intVal) )
    {
      v13 = 4;
    }
    else
    {
      if ( strcasecmp((const char *)&dword_5F8128, intVal) )
      {
        if ( LogLevel_0 )
        {
          j_al_print("(EE)", "alcOpenDevice", "Unsupported channels: %s\n", intVal);
          keyValues = g_mob_configGlobals.keyValues;
          if ( !g_mob_configGlobals.keyValues )
            goto LABEL_64;
        }
LABEL_42:
        stringVal = keyValues->key;
        if ( keyValues->key == MOB_ConfigKey_NULL )
          goto LABEL_64;
        v15 = &keyValues->value;
        while ( stringVal != MOB_ConfigKey_root_sample_type )
        {
          stringVal = (MOB_ConfigKey)v15[1].stringVal;
          v15 += 2;
          if ( stringVal == MOB_ConfigKey_NULL )
            goto LABEL_64;
        }
        v16 = (const char *)v15->intVal;
        if ( !strcasecmp("int8", (const char *)v15->stringVal) )
        {
          v17 = 0;
        }
        else if ( !strcasecmp("uint8", v16) )
        {
          v17 = 1;
        }
        else if ( !strcasecmp("int16", v16) )
        {
          v17 = 2;
        }
        else if ( !strcasecmp("uint16", v16) )
        {
          v17 = 3;
        }
        else if ( !strcasecmp("int32", v16) )
        {
          v17 = 4;
        }
        else if ( !strcasecmp("uint32", v16) )
        {
          v17 = 5;
        }
        else
        {
          if ( strcasecmp((const char *)&dword_5F81B4, v16) )
          {
            if ( LogLevel_0 )
              j_al_print("(EE)", "alcOpenDevice", "Unsupported sample-type: %s\n", v16);
            goto LABEL_64;
          }
          v17 = 6;
        }
        v7 = *(_DWORD *)(i + 184);
        *(_DWORD *)(i + 184) = v7 | 8;
        *(_DWORD *)(i + 32) = *(_DWORD *)&alcOpenDevice_typelist[20 * v17 + 16];
        goto LABEL_64;
      }
      v13 = 5;
    }
    v7 = *(_DWORD *)(i + 184);
    *(_DWORD *)(i + 184) = v7 | 4;
    *(_DWORD *)(i + 28) = *(_DWORD *)&alcOpenDevice_chanlist[20 * v13 + 16];
    goto LABEL_42;
  }
LABEL_64:
  if ( (*(_DWORD *)(i + 184) & 0xC) != 12 )
  {
    ConfigValue = j_GetConfigValue(0, "format", (const unsigned __int8 *)&byte_61CADE);
    if ( *ConfigValue )
    {
      if ( LogLevel_0 )
        j_al_print("(EE)", "alcOpenDevice", "Option 'format' is deprecated, please use 'channels' and 'sample-type'\n");
      if ( !strcasecmp((const char *)ConfigValue, "AL_FORMAT_MONO32") )
      {
        v19 = 0;
      }
      else if ( !strcasecmp((const char *)ConfigValue, "AL_FORMAT_STEREO32") )
      {
        v19 = 1;
      }
      else if ( !strcasecmp((const char *)ConfigValue, "AL_FORMAT_QUAD32") )
      {
        v19 = 2;
      }
      else if ( !strcasecmp((const char *)ConfigValue, "AL_FORMAT_51CHN32") )
      {
        v19 = 3;
      }
      else if ( !strcasecmp((const char *)ConfigValue, "AL_FORMAT_61CHN32") )
      {
        v19 = 4;
      }
      else if ( !strcasecmp((const char *)ConfigValue, "AL_FORMAT_71CHN32") )
      {
        v19 = 5;
      }
      else if ( !strcasecmp((const char *)ConfigValue, "AL_FORMAT_MONO16") )
      {
        v19 = 6;
      }
      else if ( !strcasecmp((const char *)ConfigValue, "AL_FORMAT_STEREO16") )
      {
        v19 = 7;
      }
      else if ( !strcasecmp((const char *)ConfigValue, "AL_FORMAT_QUAD16") )
      {
        v19 = 8;
      }
      else if ( !strcasecmp((const char *)ConfigValue, "AL_FORMAT_51CHN16") )
      {
        v19 = 9;
      }
      else if ( !strcasecmp((const char *)ConfigValue, "AL_FORMAT_61CHN16") )
      {
        v19 = 10;
      }
      else if ( !strcasecmp((const char *)ConfigValue, "AL_FORMAT_71CHN16") )
      {
        v19 = 11;
      }
      else if ( !strcasecmp((const char *)ConfigValue, "AL_FORMAT_MONO8") )
      {
        v19 = 12;
      }
      else if ( !strcasecmp((const char *)ConfigValue, "AL_FORMAT_STEREO8") )
      {
        v19 = 13;
      }
      else if ( !strcasecmp((const char *)ConfigValue, "AL_FORMAT_QUAD8") )
      {
        v19 = 14;
      }
      else if ( !strcasecmp((const char *)ConfigValue, (const char *)&dword_5F8420) )
      {
        v19 = 15;
      }
      else if ( !strcasecmp((const char *)ConfigValue, (const char *)&dword_5F8448) )
      {
        v19 = 16;
      }
      else
      {
        if ( strcasecmp((const char *)ConfigValue, (const char *)&dword_5F8470) )
        {
          if ( LogLevel_0 )
            j_al_print("(EE)", "alcOpenDevice", "Unsupported format: %s\n", (const char *)ConfigValue);
          goto LABEL_111;
        }
        v19 = 17;
      }
      v20 = *(_DWORD *)(i + 184);
      if ( (v20 & 4) == 0 )
      {
        uintVal = 5 * v19;
        *(_DWORD *)(i + 28) = *(_DWORD *)&alcOpenDevice_formats[40 * v19 + 32];
      }
      v7 = v20 << 28;
      if ( (v20 & 8) == 0 )
      {
        v7 = (MOB_ConfigKey)"AL_FORMAT_MONO32";
        *(_DWORD *)(i + 32) = *(_DWORD *)&alcOpenDevice_formats[40 * v19 + 36];
      }
      *(_DWORD *)(i + 184) = v20 | 0xC;
    }
  }
LABEL_111:
  v21 = g_mob_configGlobals.keyValues;
  if ( g_mob_configGlobals.keyValues )
  {
    v7 = g_mob_configGlobals.keyValues->key;
    if ( g_mob_configGlobals.keyValues->key == MOB_ConfigKey_NULL )
      goto LABEL_126;
    v22 = &g_mob_configGlobals.keyValues->value;
    while ( v7 != MOB_ConfigKey_root_frequency )
    {
      v7 = (MOB_ConfigKey)v22[1].stringVal;
      v22 += 2;
      if ( v7 == MOB_ConfigKey_NULL )
        goto LABEL_125;
    }
    v7 = *(_DWORD *)(i + 184);
    uintVal = v22->intVal;
    *(MOB_ConfigValue *)(i + 16) = (MOB_ConfigValue)v22->stringVal;
    *(_DWORD *)(i + 184) = v7 | 2;
    if ( uintVal >> 6 <= 0x7C && LogLevel_0 )
    {
      j_al_print("(EE)", "alcOpenDevice", "%uhz request clamped to %uhz minimum\n", uintVal, 8000);
      uintVal = *v6;
      v21 = g_mob_configGlobals.keyValues;
    }
    if ( uintVal <= 0x1F40 )
      uintVal = 8000;
    *v6 = uintVal;
LABEL_125:
    if ( !v21 )
    {
      v21 = 0;
    }
    else
    {
LABEL_126:
      v7 = v21->key;
      if ( v21->key )
      {
        v23 = &v21->value;
        while ( v7 != MOB_ConfigKey_root_periods )
        {
          v7 = (MOB_ConfigKey)v23[1].stringVal;
          v23 += 2;
          if ( v7 == MOB_ConfigKey_NULL )
            goto LABEL_133;
        }
        *(MOB_ConfigValue *)(i + 24) = (MOB_ConfigValue)v23->stringVal;
      }
    }
  }
  else
  {
    v21 = 0;
  }
LABEL_133:
  v24 = *(_DWORD *)(i + 24);
  if ( v24 <= 2 )
    v24 = 2;
  if ( v24 >= 0x10 )
    v24 = 16;
  v25 = v21 == 0;
  *(_DWORD *)(i + 24) = v24;
  if ( v21 )
  {
    v7 = v21->key;
    v25 = v21->key == MOB_ConfigKey_NULL;
  }
  if ( !v25 )
  {
    v26 = &v21->value;
    while ( v7 != MOB_ConfigKey_root_period_size )
    {
      v7 = (MOB_ConfigKey)v26[1].stringVal;
      v26 += 2;
      if ( v7 == MOB_ConfigKey_NULL )
        goto LABEL_145;
    }
    *(MOB_ConfigValue *)(i + 20) = (MOB_ConfigValue)v26->stringVal;
  }
LABEL_145:
  v27 = *(_DWORD *)(i + 20);
  if ( v27 <= 0x40 )
    v27 = 64;
  if ( v27 >= 0x2000 )
    v27 = 0x2000;
  v28 = (unsigned __int8)CPUCapFlags;
  *(_DWORD *)(i + 20) = v27;
  v29 = v28 << 31;
  if ( v29 )
  {
    v29 = 32764;
    *(_DWORD *)(i + 20) = (v27 + 3) & 0x7FFC;
  }
  v30 = v21 == 0;
  if ( v21 )
  {
    v29 = v21->key;
    v30 = v21->key == MOB_ConfigKey_NULL;
  }
  if ( v30 )
  {
LABEL_157:
    v32 = *(_DWORD *)(i + 44);
  }
  else
  {
    v31 = &v21->value;
    while ( v29 != 16 )
    {
      v29 = v31[1].intVal;
      v31 += 2;
      if ( !v29 )
        goto LABEL_157;
    }
    v32 = v31->intVal;
    *(_DWORD *)(i + 44) = v32;
  }
  if ( !v32 )
  {
    v32 = 256;
    *(_DWORD *)(i + 44) = 256;
  }
  v33 = v21 == 0;
  if ( v21 )
  {
    uintVal = v21->key;
    v33 = v21->key == MOB_ConfigKey_NULL;
  }
  if ( v33 )
  {
LABEL_167:
    v35 = *(_DWORD *)(i + 48);
  }
  else
  {
    v34 = &v21->value;
    while ( uintVal != 17 )
    {
      uintVal = v34[1].uintVal;
      v34 += 2;
      if ( !uintVal )
        goto LABEL_167;
    }
    v35 = v34->intVal;
    *(_DWORD *)(i + 48) = v35;
  }
  if ( !v35 )
    *(_DWORD *)(i + 48) = 4;
  v36 = v21 == 0;
  if ( v21 )
  {
    uintVal = v21->key;
    v36 = v21->key == MOB_ConfigKey_NULL;
  }
  if ( v36 )
  {
LABEL_177:
    v38 = *(_DWORD *)(i + 60);
  }
  else
  {
    v37 = &v21->value;
    while ( uintVal != 8 )
    {
      uintVal = v37[1].uintVal;
      v37 += 2;
      if ( !uintVal )
        goto LABEL_177;
    }
    v38 = v37->intVal;
    *(_DWORD *)(i + 60) = v38;
  }
  if ( v38 >= 5 )
  {
    v38 = 4;
    *(_DWORD *)(i + 60) = 4;
  }
  v39 = v21 == 0;
  if ( v21 )
  {
    v38 = v21->key;
    v39 = v21->key == MOB_ConfigKey_NULL;
  }
  if ( !v39 )
  {
    v40 = &v21->value;
    while ( v38 != 18 )
    {
      v38 = v40[1].uintVal;
      v40 += 2;
      if ( !v38 )
        goto LABEL_189;
    }
    *(MOB_ConfigValue *)(i + 180) = (MOB_ConfigValue)v40->stringVal;
  }
LABEL_189:
  LODWORD(v41) = v32 - 1;
  HIDWORD(v41) = 1;
  *(_QWORD *)(i + 52) = v41;
  v42 = (**(int (__fastcall ***)(unsigned int, const ALCchar *))((char *)&elf_hash_chain[6161] + i))(i, deviceName);
  if ( v42 )
  {
    if ( pthread_mutex_destroy((pthread_mutex_t *)(i + 12)) )
    {
      _assert2(
        "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
        357,
        "void DeleteCriticalSection(CRITICAL_SECTION *)",
        "ret == 0");
      JUMPOUT(0x24C850);
    }
    do
      v43 = *(unsigned __int8 *)--i;
    while ( v43 == 85 );
    free((void *)i);
    if ( TrapALCError )
      raise(5);
    i = 0;
    LastNullDeviceError = v42;
  }
  else
  {
    if ( DefaultEffect.type )
    {
      v51 = (char *)&elf_hash_chain[6159] + i;
      v44 = ((unsigned int)&elf_hash_chain[6169] + i + 3) & 0xFFFFFFF0;
      *(int *)((char *)&elf_hash_chain[6159] + i) = v44;
      v45 = calloc(1u, 0x10u);
      if ( v45 )
      {
        HIDWORD(v46) = NoneProcess;
        *v45 = NoneDestroy;
        v45[1] = NoneDeviceUpdate;
        LODWORD(v46) = NoneUpdate;
        *((_QWORD *)v45 + 1) = v46;
        *(int *)((char *)&dword_B8 + ((unsigned int)(v51 + 43) & 0xFFFFFFF0)) = 1065353216;
        *(int *)((char *)&dword_C4 + ((unsigned int)(v51 + 43) & 0xFFFFFFF0)) = (int)v45;
        *((_BYTE *)&dword_BC + ((unsigned int)(v51 + 43) & 0xFFFFFFF0)) = 1;
        *(int *)((char *)&dword_C0 + ((unsigned int)(v51 + 43) & 0xFFFFFFF0)) = 0;
        memset((void *)(v44 + 208), 0, 0x200Cu);
        if ( j_InitializeEffect((ALCdevice *)i, *(ALeffectslot_0 **)((char *)&elf_hash_chain[6159] + i), &DefaultEffect) )
        {
          (**(void (***)(void))(*(int *)((char *)&elf_hash_chain[6159] + i) + 196))();
          *(int *)((char *)&elf_hash_chain[6159] + i) = 0;
          if ( LogLevel_0 )
            j_al_print("(EE)", "alcOpenDevice", "Failed to initialize the default effect\n");
        }
      }
      else
      {
        *(int *)((char *)&dword_C4 + ((unsigned int)(v51 + 43) & 0xFFFFFFF0)) = 0;
        *(int *)((char *)&elf_hash_chain[6159] + i) = 0;
        if ( LogLevel_0 )
          j_al_print("(EE)", "alcOpenDevice", "Failed to initialize the default effect slot\n");
      }
    }
    while ( 1 )
    {
      *(int *)((char *)&elf_hash_chain[6164] + i) = (int)DeviceList;
      v47 = *(int *)((char *)&elf_hash_chain[6164] + i);
      v48 = __ldrex((unsigned int *)&DeviceList);
      if ( v48 == v47 )
        break;
LABEL_203:
      __clrex();
      __dmb(0xBu);
    }
    __dmb(0xBu);
    while ( __strex(i, (unsigned int *)&DeviceList) )
    {
      v49 = __ldrex((unsigned int *)&DeviceList);
      if ( v49 != v47 )
        goto LABEL_203;
    }
    __dmb(0xBu);
    if ( (unsigned int)LogLevel_0 > LogWarning )
      j_al_print("(II)", "alcOpenDevice", "Created device %p, \"%s\"\n", (const void *)i, *(const char **)(i + 36));
  }
  return (ALCdevice *)i;
}
// 24C84E: control flows out of bounds to 24C850
// 24C1C0: conditional instruction was optimized away because r11.4!=0
// 24C5DE: variable 'v7' is possibly undefined
// 24C652: variable 'uintVal' is possibly undefined
// B8: using guessed type int dword_B8;
// BC: using guessed type int dword_BC;
// C0: using guessed type int dword_C0;
// C4: using guessed type int dword_C4;
// 10168: using guessed type int elf_hash_chain[22025];
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);
// 5F8128: using guessed type int dword_5F8128;
// 5F81B4: using guessed type int dword_5F81B4;
// 5F8420: using guessed type int dword_5F8420;
// 5F8448: using guessed type int dword_5F8448;
// 5F8470: using guessed type int dword_5F8470;
// 61CADE: using guessed type char byte_61CADE;

//----- (0024CA48) --------------------------------------------------------
void alc_initconfig()
{
  char *v0; // r0
  unsigned int v1; // r0
  char *v2; // r0
  const char *v3; // r4
  bool v4; // zf
  FILE *v5; // r0
  size_t v6; // r0
  MOB_ConfigKey key; // r1
  const unsigned __int8 *name; // r3
  size_t v9; // r5
  BackendInfo *v10; // r4
  size_t v11; // r0
  const unsigned __int8 *v12; // t1
  bool v13; // zf
  MOB_ConfigValue *p_value; // r0
  const char *intVal; // r5
  char *v16; // r0
  const char *v17; // r5
  char *v18; // r6
  int v19; // r4
  int v20; // t1
  bool v21; // zf
  size_t v22; // r8
  ALint *stringVal; // r3
  bool v24; // zf
  MOB_ConfigValue *v25; // r0
  MOB_ConfigValue *v26; // r2
  MOB_ConfigKey v27; // r1
  const char *v28; // r4
  unsigned int v29; // r0
  Resampler v30; // r1
  char *v31; // r0
  const char *v32; // r4
  const MOB_ConfigKeyValue *keyValues; // r5
  int v34; // r0
  char *v35; // r0
  MOB_ConfigKey v36; // r2
  const char *v37; // r4
  int v38; // r1
  bool v39; // zf
  MOB_ConfigValue *v40; // r0
  char *v41; // r0
  const char *v42; // r4
  MOB_ConfigGlobals_0 *v43; // r2
  bool v44; // zf
  MOB_ConfigValue *v45; // r1
  bool v46; // zf
  ALCboolean *v47; // r1
  MOB_ConfigValue *v48; // r4
  MOB_ConfigValue *v49; // r0
  MOB_ConfigKey v50; // r0
  int v51; // r1
  char *v52; // r0
  MOB_ConfigKey v53; // r1
  const char *v54; // r4
  bool v55; // zf
  bool v56; // zf
  MOB_ConfigValue *v57; // r0
  int v58; // r9
  char *v59; // r6
  const char *v60; // r10
  int v61; // r11
  int v62; // r0
  int v63; // r1
  bool v64; // zf
  size_t v65; // r5
  int v66; // r8
  BackendInfo *v67; // r4
  ALCboolean (**p_Init)(BackendFuncs *); // r9
  ALCboolean (*Init)(BackendFuncs *); // r1
  ALCboolean (*v70)(BackendFuncs *); // t1
  BackendInfo *v71; // r0
  ALCboolean (*v72)(BackendFuncs *); // r1
  BackendInfo *v73; // r4
  bool v74; // zf
  const unsigned __int8 *ConfigValue; // r4
  int v76; // r6
  char *v77; // r8
  bool v78; // zf
  size_t v79; // r9
  char *v80; // r0
  MOB_ConfigKey v81; // r1
  bool v82; // zf
  bool v83; // zf
  MOB_ConfigValue *v84; // r0
  int v85; // [sp+14h] [bp-42Ch]
  int v86; // [sp+1Ch] [bp-424h]
  char *v87[256]; // [sp+20h] [bp-420h] BYREF

  v0 = getenv("ALSOFT_LOGLEVEL");
  if ( v0 )
  {
    v1 = strtol(v0, 0, 0);
    if ( v1 <= 4 )
      LogLevel_0 = v1;
  }
  v2 = getenv("ALSOFT_LOGFILE");
  v3 = v2;
  v4 = v2 == 0;
  if ( v2 )
    v4 = *v2 == 0;
  if ( !v4 )
  {
    v5 = fopen(v2, "wat");
    if ( v5 )
    {
      LogFile = v5;
    }
    else if ( LogLevel_0 )
    {
      j_al_print("(EE)", "alc_initconfig", "Failed to open log file '%s'\n", v3);
    }
  }
  memset(v87, 0, sizeof(v87));
  v6 = snprintf((unsigned __int8 *)v87, 0x400u, (const unsigned __int8 *)&dword_24D368, BackendList[0].name);
  name = BackendList[1].name;
  v9 = v6;
  if ( BackendList[1].name )
  {
    v10 = &BackendList[2];
    do
    {
      v11 = snprintf((unsigned __int8 *)v87 + v9, 1024 - v9, ", %s", (const char *)name);
      v12 = v10->name;
      ++v10;
      name = v12;
      v9 += v11;
    }
    while ( v12 );
  }
  if ( (unsigned int)LogLevel_0 >= LogTrace )
    j_al_print("(II)", "alc_initconfig", "Supported backends: %s\n", (const char *)v87);
  v13 = g_mob_configGlobals.keyValues == 0;
  if ( g_mob_configGlobals.keyValues )
  {
    key = g_mob_configGlobals.keyValues->key;
    v13 = g_mob_configGlobals.keyValues->key == MOB_ConfigKey_NULL;
  }
  if ( !v13 )
  {
    p_value = &g_mob_configGlobals.keyValues->value;
    while ( key != MOB_ConfigKey_root_disable_cpu_exts )
    {
      key = (MOB_ConfigKey)p_value[1].stringVal;
      p_value += 2;
      if ( key == MOB_ConfigKey_NULL )
        goto LABEL_37;
    }
    intVal = (const char *)p_value->intVal;
    if ( strcasecmp((const char *)p_value->stringVal, (const char *)&dword_24D39C) )
    {
      do
      {
        v16 = strchr(intVal, 44);
        v17 = intVal - 1;
        v18 = v16;
        do
        {
          v20 = *(unsigned __int8 *)++v17;
          v19 = v20;
        }
        while ( isspace(v20) );
        v21 = v19 == 0;
        if ( v19 )
          v21 = v19 == 44;
        if ( !v21 )
        {
          v22 = v18 ? v18 - v17 : strlen(v17);
          if ( strncasecmp(v17, (const char *)&off_24D3A0, v22)
            && strncasecmp(v17, "neon", v22)
            && (unsigned int)LogLevel_0 >= LogWarning )
          {
            j_al_print("(WW)", "alc_initconfig", "Invalid CPU extension \"%s\"\n", v17);
          }
        }
        intVal = v18 + 1;
      }
      while ( v18 );
    }
  }
LABEL_37:
  if ( (unsigned int)LogLevel_0 >= LogTrace )
    j_al_print("(II)", "FillCPUCaps", "Got caps:%s%s%s\n", &byte_61CADE, &byte_61CADE, " -none-");
  stringVal = &RTPrioLevel;
  RTPrioLevel = 0;
  CPUCapFlags = 0;
  v24 = g_mob_configGlobals.keyValues == 0;
  if ( g_mob_configGlobals.keyValues )
  {
    stringVal = (ALint *)g_mob_configGlobals.keyValues->key;
    v24 = g_mob_configGlobals.keyValues->key == MOB_ConfigKey_NULL;
  }
  if ( !v24 )
  {
    v25 = &g_mob_configGlobals.keyValues->value;
    v26 = &g_mob_configGlobals.keyValues->value;
    while ( stringVal != (int *)((char *)&dword_0 + 2) )
    {
      stringVal = (ALint *)v26[1].stringVal;
      v26 += 2;
      if ( !stringVal )
        goto LABEL_47;
    }
    RTPrioLevel = v26->intVal;
LABEL_47:
    v27 = g_mob_configGlobals.keyValues->key;
    if ( g_mob_configGlobals.keyValues->key )
    {
      while ( v27 != MOB_ConfigKey_root_resampler )
      {
        v27 = (MOB_ConfigKey)v25[1].stringVal;
        v25 += 2;
        if ( v27 == MOB_ConfigKey_NULL )
          goto LABEL_60;
      }
      v28 = (const char *)v25->intVal;
      if ( !strcasecmp((const char *)v25->stringVal, "point") || !strcasecmp(v28, "none") )
      {
        v30 = PointResampler;
      }
      else if ( !strcasecmp(v28, "linear") )
      {
        v30 = LinearResampler;
      }
      else
      {
        if ( strcasecmp(v28, "cubic") )
        {
          v29 = strtol(v28, v87, 0);
          if ( v29 > 2 || *v87[0] )
          {
            if ( (unsigned int)LogLevel_0 >= LogWarning )
              j_al_print("(WW)", "alc_initconfig", "Invalid resampler: %s\n", v28);
          }
          else
          {
            DefaultResampler = v29;
          }
          goto LABEL_60;
        }
        v30 = CubicResampler;
      }
      DefaultResampler = v30;
    }
  }
LABEL_60:
  v31 = getenv("ALSOFT_TRAP_ERROR");
  v32 = v31;
  if ( v31 && (!strcasecmp(v31, "true") || strtol(v32, 0, 0) == 1) )
  {
    keyValues = g_mob_configGlobals.keyValues;
    LOBYTE(v34) = 1;
    TrapALError = 1;
  }
  else
  {
    v35 = getenv("ALSOFT_TRAP_AL_ERROR");
    v37 = v35;
    if ( v35 && (!strcasecmp(v35, "true") || strtol(v37, 0, 0) == 1) )
      TrapALError = 1;
    LOBYTE(v38) = TrapALError;
    v39 = g_mob_configGlobals.keyValues == 0;
    if ( g_mob_configGlobals.keyValues )
    {
      v36 = g_mob_configGlobals.keyValues->key;
      v39 = g_mob_configGlobals.keyValues->key == MOB_ConfigKey_NULL;
    }
    if ( !v39 )
    {
      v40 = &g_mob_configGlobals.keyValues->value;
      while ( v36 != MOB_ConfigKey_root_trap_al_error )
      {
        v36 = (MOB_ConfigKey)v40[1].stringVal;
        v40 += 2;
        if ( v36 == MOB_ConfigKey_NULL )
          goto LABEL_77;
      }
      v38 = v40->intVal;
      if ( v40->intVal )
        LOBYTE(v38) = 1;
    }
LABEL_77:
    TrapALError = v38;
    v41 = getenv("ALSOFT_TRAP_ALC_ERROR");
    v42 = v41;
    if ( v41 && (!strcasecmp(v41, "true") || strtol(v42, 0, 0) == 1) )
      TrapALCError = 1;
    v43 = &g_mob_configGlobals;
    LOBYTE(v34) = TrapALCError;
    keyValues = g_mob_configGlobals.keyValues;
    v44 = g_mob_configGlobals.keyValues == 0;
    if ( g_mob_configGlobals.keyValues )
    {
      v43 = (MOB_ConfigGlobals_0 *)g_mob_configGlobals.keyValues->key;
      v44 = g_mob_configGlobals.keyValues->key == MOB_ConfigKey_NULL;
    }
    if ( !v44 )
    {
      v45 = &g_mob_configGlobals.keyValues->value;
      while ( v43 != (MOB_ConfigGlobals_0 *)&byte_5 )
      {
        v43 = (MOB_ConfigGlobals_0 *)v45[1].stringVal;
        v45 += 2;
        if ( !v43 )
          goto LABEL_90;
      }
      v34 = v45->intVal;
      if ( v45->intVal )
        LOBYTE(v34) = 1;
    }
  }
LABEL_90:
  v46 = keyValues == 0;
  v47 = &TrapALCError;
  TrapALCError = v34;
  if ( keyValues )
  {
    v47 = (ALCboolean *)keyValues->key;
    v46 = keyValues->key == MOB_ConfigKey_NULL;
  }
  if ( v46 )
    goto LABEL_101;
  v48 = &keyValues->value;
  v49 = &keyValues->value;
  while ( v47 != (_BYTE *)&off_18 + 3 )
  {
    v47 = (ALCboolean *)v49[1].stringVal;
    v49 += 2;
    if ( !v47 )
      goto LABEL_98;
  }
  ReverbBoost = powf(10.0, v49->floatVal / 20.0) * ReverbBoost;
LABEL_98:
  v50 = keyValues->key;
  if ( keyValues->key == MOB_ConfigKey_NULL )
  {
LABEL_101:
    LOBYTE(v51) = 0;
  }
  else
  {
    while ( v50 != MOB_ConfigKey_reverb_emulate_eax )
    {
      v50 = (MOB_ConfigKey)v48[1].stringVal;
      v48 += 2;
      if ( v50 == MOB_ConfigKey_NULL )
        goto LABEL_101;
    }
    v51 = v48->intVal;
    if ( v48->intVal )
      LOBYTE(v51) = 1;
  }
  EmulateEAXReverb = v51;
  v52 = getenv("ALSOFT_DRIVERS");
  v54 = v52;
  v55 = v52 == 0;
  if ( v52 )
    v55 = *v52 == 0;
  if ( v55 )
  {
    v56 = keyValues == 0;
    if ( keyValues )
    {
      v53 = keyValues->key;
      v56 = keyValues->key == MOB_ConfigKey_NULL;
    }
    if ( v56 )
      goto LABEL_144;
    v57 = &keyValues->value;
    while ( v53 != MOB_ConfigKey_root_drivers )
    {
      v53 = (MOB_ConfigKey)v57[1].stringVal;
      v57 += 2;
      if ( v53 == MOB_ConfigKey_NULL )
        goto LABEL_144;
    }
    v54 = (const char *)v57->intVal;
  }
  v58 = 0;
  do
  {
    v59 = strchr(v54, 44);
    v60 = v54 + 1;
    v61 = *(unsigned __int8 *)v54;
    v62 = 0;
    if ( v61 != 45 )
      v60 = v54;
    v63 = *(unsigned __int8 *)v60;
    v64 = v63 == 0;
    if ( *v60 )
      v64 = v63 == 44;
    if ( !v64 )
    {
      if ( v59 )
        v65 = v59 - v60;
      else
        v65 = strlen(v60);
      if ( BackendList[v58].Init )
      {
        v66 = v58;
        v85 = v58;
        v67 = &BackendList[v58];
        v86 = v58;
        p_Init = &v67[1].Init;
        while ( v65 != strlen((const char *)v67->name) || strncmp((const char *)v67->name, v60, v65) )
        {
          Init = v67[1].Init;
          p_Init += 18;
          ++v66;
          ++v67;
          if ( !Init )
          {
            v58 = v86;
LABEL_140:
            v62 = 1;
            goto LABEL_141;
          }
        }
        if ( v61 != 45 )
        {
          qmemcpy(v87, v67, 0x48u);
          if ( v66 > v86 )
          {
            do
            {
              qmemcpy(v67, &v67[-1], sizeof(BackendInfo));
              --v66;
              --v67;
            }
            while ( v66 > v86 );
            v67 = &BackendList[v85];
          }
          qmemcpy(v67, v87, sizeof(BackendInfo));
          v58 = v86 + 1;
          goto LABEL_140;
        }
        do
        {
          qmemcpy(p_Init - 19, p_Init - 1, 0x48u);
          v70 = *p_Init;
          p_Init += 18;
        }
        while ( v70 );
        v62 = 1;
        v58 = v86;
      }
      else
      {
        v62 = 1;
      }
    }
LABEL_141:
    v54 = v59 + 1;
  }
  while ( v59 );
  if ( v62 )
  {
    v71 = &BackendList[v58];
    *(_QWORD *)&v71->name = 0LL;
    *(_QWORD *)&v71->Deinit = 0LL;
  }
LABEL_144:
  v72 = BackendList[0].Init;
  if ( BackendList[0].Init )
  {
    v73 = BackendList;
    do
    {
      v74 = PlaybackBackend.name == 0;
      if ( PlaybackBackend.name )
        v74 = CaptureBackend.name == 0;
      if ( !v74 )
        break;
      if ( v72(&v73->Funcs) )
      {
        if ( (unsigned int)LogLevel_0 >= LogTrace )
          j_al_print("(II)", "alc_initconfig", "Initialized backend \"%s\"\n", (const char *)v73->name);
        if ( v73->Funcs.OpenPlayback )
        {
          if ( !PlaybackBackend.name )
          {
            qmemcpy(&PlaybackBackend, v73, sizeof(PlaybackBackend));
            if ( (unsigned int)LogLevel_0 >= LogTrace )
              j_al_print("(II)", "alc_initconfig", "Added \"%s\" for playback\n", (const char *)PlaybackBackend.name);
          }
        }
        if ( v73->Funcs.OpenCapture )
        {
          if ( !CaptureBackend.name )
          {
            qmemcpy(&CaptureBackend, v73, sizeof(CaptureBackend));
            if ( (unsigned int)LogLevel_0 >= LogTrace )
              j_al_print("(II)", "alc_initconfig", "Added \"%s\" for capture\n", CaptureBackend.name);
          }
        }
      }
      else if ( (unsigned int)LogLevel_0 >= LogWarning )
      {
        j_al_print("(WW)", "alc_initconfig", "Failed to initialize backend \"%s\"\n", v73->name);
      }
      v72 = v73[1].Init;
      ++v73;
    }
    while ( v72 );
  }
  BackendLoopback.Init(&BackendLoopback.Funcs);
  ConfigValue = j_GetConfigValue(0, "excludefx", (const unsigned __int8 *)&byte_61CADE);
  v76 = *ConfigValue;
  if ( *ConfigValue )
  {
    while ( 1 )
    {
      v77 = strchr((const char *)ConfigValue, 44);
      v78 = v77 == (char *)ConfigValue;
      if ( v77 != (char *)ConfigValue )
        v78 = v76 << 24 == 0;
      if ( v78 )
        goto LABEL_182;
      if ( v77 )
      {
        v79 = v77 - (char *)ConfigValue;
        if ( v77 - (char *)ConfigValue == 4 )
          goto LABEL_185;
      }
      else
      {
        v79 = strlen((const char *)ConfigValue);
        if ( v79 == 4 )
        {
LABEL_185:
          if ( !strncmp("echo", (const char *)ConfigValue, v79) )
            DisabledEffects[2] = 1;
          if ( !v77 )
            break;
          goto LABEL_166;
        }
      }
      if ( v79 != 6 )
      {
        if ( v79 == 9 )
        {
          if ( !strncmp("eaxreverb", (const char *)ConfigValue, 9u) )
            DisabledEffects[0] = 1;
          if ( !strncmp("modulator", (const char *)ConfigValue, 9u) )
            DisabledEffects[3] = 1;
          if ( !strncmp("dedicated", (const char *)ConfigValue, 9u) )
            DisabledEffects[4] = 1;
          if ( !strncmp("dedicated", (const char *)ConfigValue, 9u) )
            DisabledEffects[4] = 1;
        }
LABEL_182:
        if ( !v77 )
          break;
        goto LABEL_166;
      }
      if ( !strncmp("reverb", (const char *)ConfigValue, 6u) )
        DisabledEffects[1] = 1;
      if ( !v77 )
        break;
LABEL_166:
      ConfigValue = (const unsigned __int8 *)(v77 + 1);
      v76 = (unsigned __int8)v77[1];
    }
  }
  DefaultEffect.SetParamiv = alEffect_null_SetParamiv;
  DefaultEffect.SetParami = alEffect_null_SetParami;
  DefaultEffect.SetParamf = alEffect_null_SetParamf;
  DefaultEffect.SetParamfv = alEffect_null_SetParamfv;
  DefaultEffect.GetParami = alEffect_null_GetParami;
  DefaultEffect.GetParamiv = alEffect_null_GetParamiv;
  DefaultEffect.GetParamf = alEffect_null_GetParamf;
  DefaultEffect.GetParamfv = alEffect_null_GetParamfv;
  DefaultEffect.type = 0;
  v80 = getenv("ALSOFT_DEFAULT_REVERB");
  v82 = v80 == 0;
  if ( v80 )
  {
    v81 = (unsigned __int8)*v80;
    v82 = v81 == MOB_ConfigKey_NULL;
  }
  if ( !v82 )
    goto LABEL_204;
  v83 = g_mob_configGlobals.keyValues == 0;
  if ( g_mob_configGlobals.keyValues )
  {
    v81 = g_mob_configGlobals.keyValues->key;
    v83 = g_mob_configGlobals.keyValues->key == MOB_ConfigKey_NULL;
  }
  if ( !v83 )
  {
    v84 = &g_mob_configGlobals.keyValues->value;
    while ( v81 != MOB_ConfigKey_root_default_reverb )
    {
      v81 = (MOB_ConfigKey)v84[1].stringVal;
      v84 += 2;
      if ( v81 == MOB_ConfigKey_NULL )
        return;
    }
    v80 = (char *)v84->intVal;
LABEL_204:
    j_LoadReverbPreset((const unsigned __int8 *)v80, &DefaultEffect);
  }
}
// 24CB5A: variable 'key' is possibly undefined
// 24CD8A: variable 'v36' is possibly undefined
// 24CEAC: variable 'v53' is possibly undefined
// 24D296: variable 'v81' is possibly undefined
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 18: using guessed type int (*off_18)();
// 24D368: using guessed type int dword_24D368;
// 24D39C: using guessed type int dword_24D39C;
// 24D3A0: using guessed type void *off_24D3A0;
// 61CADE: using guessed type char byte_61CADE;

//----- (0024D54C) --------------------------------------------------------
void __fastcall InitUIntMap(UIntMap_0 *map, ALsizei limit)
{
  map->lock.read_count = 0;
  map->lock.write_count = 0;
  map->lock.read_lock = 0;
  map->lock.read_entry_lock = 0;
  map->array = 0;
  map->size = 0;
  map->maxsize = 0;
  map->limit = limit;
  map->lock.write_lock = 0;
}

//----- (0024D564) --------------------------------------------------------
int __fastcall MOB_Local_ConfigValueStr(MOB_ConfigKey key, const unsigned __int8 **ret)
{
  MOB_ConfigGlobals_0 *v2; // r2
  bool v3; // zf
  MOB_ConfigValue *p_value; // r3
  MOB_ConfigValue v5; // r2

  v2 = &g_mob_configGlobals;
  v3 = g_mob_configGlobals.keyValues == 0;
  if ( g_mob_configGlobals.keyValues )
  {
    v2 = (MOB_ConfigGlobals_0 *)g_mob_configGlobals.keyValues->key;
    v3 = g_mob_configGlobals.keyValues->key == MOB_ConfigKey_NULL;
  }
  if ( v3 )
    return 0;
  p_value = &g_mob_configGlobals.keyValues->value;
  if ( v2 == (MOB_ConfigGlobals_0 *)key )
  {
LABEL_8:
    *ret = (const unsigned __int8 *)p_value->intVal;
    return 1;
  }
  else
  {
    while ( 1 )
    {
      v5.stringVal = p_value[1].stringVal;
      p_value += 2;
      if ( !v5.intVal )
        return 0;
      if ( v5.intVal == key )
        goto LABEL_8;
    }
  }
}

//----- (0024D5A0) --------------------------------------------------------
int __fastcall ConfigValueStr(
        const unsigned __int8 *blockName,
        const unsigned __int8 *keyName,
        const unsigned __int8 **ret)
{
  const unsigned __int8 *ConfigValue; // r0

  ConfigValue = j_GetConfigValue(blockName, keyName, (const unsigned __int8 *)&byte_61CADE);
  if ( !*ConfigValue )
    return 0;
  *ret = ConfigValue;
  return 1;
}
// 61CADE: using guessed type char byte_61CADE;

//----- (0024D5C0) --------------------------------------------------------
int __fastcall MOB_Local_ConfigValueUInt(MOB_ConfigKey key, unsigned int *ret)
{
  MOB_ConfigGlobals_0 *v2; // r2
  bool v3; // zf
  MOB_ConfigValue *p_value; // r3
  MOB_ConfigValue v5; // r2

  v2 = &g_mob_configGlobals;
  v3 = g_mob_configGlobals.keyValues == 0;
  if ( g_mob_configGlobals.keyValues )
  {
    v2 = (MOB_ConfigGlobals_0 *)g_mob_configGlobals.keyValues->key;
    v3 = g_mob_configGlobals.keyValues->key == MOB_ConfigKey_NULL;
  }
  if ( v3 )
    return 0;
  p_value = &g_mob_configGlobals.keyValues->value;
  if ( v2 == (MOB_ConfigGlobals_0 *)key )
  {
LABEL_8:
    *ret = p_value->intVal;
    return 1;
  }
  else
  {
    while ( 1 )
    {
      v5.stringVal = p_value[1].stringVal;
      p_value += 2;
      if ( !v5.intVal )
        return 0;
      if ( v5.intVal == key )
        goto LABEL_8;
    }
  }
}

//----- (0024D5FC) --------------------------------------------------------
int __fastcall MOB_Local_ConfigValueInt(MOB_ConfigKey key, int *ret)
{
  MOB_ConfigGlobals_0 *v2; // r2
  bool v3; // zf
  MOB_ConfigValue *p_value; // r3
  MOB_ConfigValue v5; // r2

  v2 = &g_mob_configGlobals;
  v3 = g_mob_configGlobals.keyValues == 0;
  if ( g_mob_configGlobals.keyValues )
  {
    v2 = (MOB_ConfigGlobals_0 *)g_mob_configGlobals.keyValues->key;
    v3 = g_mob_configGlobals.keyValues->key == MOB_ConfigKey_NULL;
  }
  if ( v3 )
    return 0;
  p_value = &g_mob_configGlobals.keyValues->value;
  if ( v2 == (MOB_ConfigGlobals_0 *)key )
  {
LABEL_8:
    *ret = p_value->intVal;
    return 1;
  }
  else
  {
    while ( 1 )
    {
      v5.stringVal = p_value[1].stringVal;
      p_value += 2;
      if ( !v5.intVal )
        return 0;
      if ( v5.intVal == key )
        goto LABEL_8;
    }
  }
}

//----- (0024D638) --------------------------------------------------------
void __fastcall DeleteCriticalSection(CRITICAL_SECTION *cs)
{
  if ( pthread_mutex_destroy(cs) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      357,
      "void DeleteCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    JUMPOUT(0x24D65C);
  }
}
// 24D65A: control flows out of bounds to 24D65C
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0024D668) --------------------------------------------------------
ALCboolean __fastcall alcCloseDevice(ALCdevice *Device)
{
  ALCdevice *volatile *v2; // r1
  ALCdevice *v3; // r0
  ALCdevice *volatile v4; // r3
  bool v5; // zf
  ALCdevice *volatile v6; // r4
  ALCcontext *v7; // r5
  ALCcontext **v8; // r11
  signed int Flags; // r0

  if ( pthread_mutex_lock(&ListLock) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      363,
      "void EnterCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
LABEL_29:
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      369,
      "void LeaveCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    goto LABEL_30;
  }
  v2 = &DeviceList;
  v3 = DeviceList;
  if ( DeviceList )
  {
    v2 = &DeviceList;
    while ( 1 )
    {
      v4 = *v2;
      if ( v3 == Device )
        break;
      v2 = (ALCdevice *volatile *)((char *)&elf_hash_chain[6164] + (_DWORD)v4);
      v3 = *(ALCdevice **)((char *)&elf_hash_chain[6164] + (_DWORD)v4);
      if ( !v3 )
        goto LABEL_8;
    }
    v3 = *v2;
  }
LABEL_8:
  v5 = v3 == 0;
  if ( v3 )
    v5 = (*v2)->Type == Capture;
  if ( v5 )
  {
    v6 = *v2;
    if ( TrapALCError )
      raise(5);
    if ( v6 )
      v6->LastError = 40961;
    else
      LastNullDeviceError = 40961;
    if ( !pthread_mutex_unlock(&ListLock) )
      return 0;
    goto LABEL_29;
  }
  *v2 = *(ALCdevice *volatile *)((char *)&(*v2)->ref + (unsigned int)&elf_hash_chain[6164]);
  if ( pthread_mutex_unlock(&ListLock) )
  {
LABEL_30:
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      369,
      "void LeaveCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    JUMPOUT(0x24D7C4);
  }
  v7 = *(ALCcontext **)((char *)&elf_hash_chain[6160] + (_DWORD)Device);
  if ( v7 )
  {
    v8 = (ALCcontext **)((char *)&elf_hash_chain[6160] + (_DWORD)Device);
    do
    {
      if ( (unsigned int)LogLevel_0 >= LogWarning )
        j_al_print("(WW)", "alcCloseDevice", "Releasing context %p\n", v7);
      ReleaseContext(v7, Device);
      v7 = *v8;
    }
    while ( *v8 );
  }
  Flags = Device->Flags;
  if ( Flags <= -1 )
  {
    (*(void (__fastcall **)(ALCdevice *))(*(int *)((char *)&elf_hash_chain[6161] + (_DWORD)Device) + 16))(Device);
    Flags = Device->Flags;
  }
  Device->Flags = Flags & 0x7FFFFFFF;
  j_ALCdevice_DecRef(Device);
  return 1;
}
// 24D7C0: control flows out of bounds to 24D7C4
// 10168: using guessed type int elf_hash_chain[22025];
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0024D828) --------------------------------------------------------
ALCint __fastcall alcGetDeviceReferenceCount(ALCdevice *device)
{
  ALCdevice *volatile *v2; // r0
  ALCdevice *v3; // r1
  ALCdevice *volatile v4; // r3
  bool v5; // zf
  ALCdevice *volatile v6; // r4
  ALCint ref; // r4

  if ( pthread_mutex_lock(&ListLock) )
  {
LABEL_23:
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      363,
      "void EnterCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    JUMPOUT(0x24D8F8);
  }
  v2 = &DeviceList;
  v3 = DeviceList;
  if ( DeviceList )
  {
    v2 = &DeviceList;
    while ( 1 )
    {
      v4 = *v2;
      if ( v3 == device )
        break;
      v2 = (ALCdevice *volatile *)((char *)&elf_hash_chain[6164] + (_DWORD)v4);
      v3 = *(ALCdevice **)((char *)&elf_hash_chain[6164] + (_DWORD)v4);
      if ( !v3 )
        goto LABEL_8;
    }
    v3 = *v2;
  }
LABEL_8:
  v5 = v3 == 0;
  if ( v3 )
    v5 = (*v2)->Type == Capture;
  if ( v5 )
  {
    v6 = *v2;
    if ( TrapALCError )
      raise(5);
    if ( v6 )
    {
      v6->LastError = 40961;
      goto LABEL_20;
    }
  }
  else
  {
    ref = device->ref;
    if ( !pthread_mutex_unlock(&ListLock) )
      return ref;
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      369,
      "void LeaveCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
  }
  LastNullDeviceError = 40961;
LABEL_20:
  if ( pthread_mutex_unlock(&ListLock) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      369,
      "void LeaveCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    goto LABEL_23;
  }
  return -1;
}
// 24D8F4: control flows out of bounds to 24D8F8
// 10168: using guessed type int elf_hash_chain[22025];
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0024D938) --------------------------------------------------------
ALCdevice *__fastcall alcCaptureOpenDevice(
        const ALCchar *deviceName,
        ALCuint frequency,
        ALCenum format,
        ALCsizei samples)
{
  bool v8; // zf
  int v9; // r8
  _BYTE *v10; // r0
  int v11; // r11
  unsigned int i; // r4
  int v13; // r0
  volatile ALCenum v14; // r1
  int v16; // t1
  __int64 v17; // kr00_8
  int v18; // r5
  int v19; // t1
  int v20; // r6
  unsigned int v21; // r5
  unsigned int v22; // r5

  pthread_once(&alc_config_once, alc_initconfig);
  if ( !CaptureBackend.name )
  {
    if ( TrapALCError )
      raise(5);
    goto LABEL_22;
  }
  if ( samples <= 0 )
  {
    if ( TrapALCError )
      raise(5);
LABEL_22:
    v14 = 40964;
    goto LABEL_23;
  }
  v8 = deviceName == 0;
  LOWORD(v9) = (unsigned __int16)&elf_hash_chain[6161];
  if ( deviceName )
    v8 = *deviceName == 0;
  HIWORD(v9) = (unsigned int)&elf_hash_chain[6161] >> 16;
  if ( v8 || !strcasecmp((const char *)deviceName, (const char *)alcDefaultName) )
  {
    deviceName = 0;
  }
  else if ( !strcasecmp((const char *)deviceName, "openal-soft") )
  {
    deviceName = 0;
  }
  v10 = malloc(v9 + 36);
  if ( !v10 )
  {
    if ( TrapALCError )
      raise(5);
    v14 = 40965;
    goto LABEL_23;
  }
  v11 = 0;
  *v10 = 0;
  for ( i = (unsigned int)(v10 + 1); (i & 0xF) != 0; *(_BYTE *)i++ = 85 )
    ;
  memset((void *)i, 0, (size_t)&elf_hash_chain[6166]);
  *(_DWORD *)(i + v9) = &CaptureBackend.Funcs;
  *(_BYTE *)(i + 4) = 1;
  *(_DWORD *)i = 1;
  *(_DWORD *)(i + 8) = 1;
  j_InitializeCriticalSection((CRITICAL_SECTION *)(i + 12));
  *(_DWORD *)(i + 80) = 0;
  *(_DWORD *)(i + 84) = 0;
  *(_DWORD *)(i + 88) = 0;
  *(_DWORD *)(i + 92) = 0;
  *(_DWORD *)(i + 96) = 0;
  *(_DWORD *)(i + 116) = 0;
  *(_DWORD *)(i + 120) = 0;
  *(_DWORD *)(i + 124) = 0;
  *(_DWORD *)(i + 128) = 0;
  *(_DWORD *)(i + 132) = 0;
  *(_DWORD *)(i + 152) = 0;
  *(_DWORD *)(i + 64) = 0;
  *(_DWORD *)(i + 68) = 0;
  *(_DWORD *)(i + 72) = 0;
  *(_DWORD *)(i + 76) = -1;
  *(_DWORD *)(i + 100) = 0;
  *(_DWORD *)(i + 104) = 0;
  *(_DWORD *)(i + 108) = 0;
  *(_DWORD *)(i + 112) = -1;
  *(_DWORD *)(i + 156) = 0;
  *(_DWORD *)(i + 160) = 0;
  *(_DWORD *)(i + 164) = 0;
  *(_DWORD *)(i + 136) = 0;
  *(_DWORD *)(i + 140) = 0;
  *(_DWORD *)(i + 144) = 0;
  *(_DWORD *)(i + 148) = -1;
  *(_DWORD *)(i + 168) = 0;
  *(_DWORD *)(i + 36) = 0;
  v13 = *(_DWORD *)(i + 184);
  *(_DWORD *)(i + 16) = frequency;
  *(_DWORD *)(i + 184) = v13 | 0xE;
  if ( format <= 4611 )
  {
    switch ( format )
    {
      case 4352:
        goto LABEL_52;
      case 4353:
        v11 = 1;
        goto LABEL_52;
      case 4354:
        v11 = 3;
        goto LABEL_52;
      case 4355:
        v11 = 4;
        goto LABEL_52;
      default:
        goto LABEL_33;
    }
  }
  switch ( format )
  {
    case 4612:
      v11 = 6;
      goto LABEL_52;
    case 4613:
      v11 = 7;
      goto LABEL_52;
    case 4614:
      v11 = 8;
      goto LABEL_52;
    case 4615:
    case 4616:
    case 4617:
      goto LABEL_33;
    case 4618:
      v11 = 9;
      goto LABEL_52;
    case 4619:
      v11 = 10;
      goto LABEL_52;
    case 4620:
      v11 = 11;
      goto LABEL_52;
    case 4621:
      v11 = 12;
      goto LABEL_52;
    case 4622:
      v11 = 13;
      goto LABEL_52;
    case 4623:
      v11 = 14;
      goto LABEL_52;
    case 4624:
      v11 = 15;
      goto LABEL_52;
    case 4625:
      v11 = 16;
      goto LABEL_52;
    case 4626:
      v11 = 17;
      goto LABEL_52;
    default:
      if ( format != 65552 )
      {
        if ( format == 65553 )
        {
          v11 = 5;
          goto LABEL_52;
        }
LABEL_33:
        if ( pthread_mutex_destroy((pthread_mutex_t *)(i + 12)) )
          goto LABEL_68;
        do
          v16 = *(unsigned __int8 *)--i;
        while ( v16 == 85 );
        free((void *)i);
        if ( TrapALCError )
          raise(5);
        v14 = 40963;
LABEL_23:
        LastNullDeviceError = v14;
        return 0;
      }
      v11 = 2;
LABEL_52:
      *(_DWORD *)(i + 20) = samples;
      v17 = *(_QWORD *)(&DecomposeDevFormat_list + 3 * v11 + 1);
      *(_DWORD *)(i + 32) = HIDWORD(v17);
      *(_DWORD *)(i + 24) = 1;
      *(_DWORD *)(i + 28) = v17;
      v18 = (*(int (__fastcall **)(unsigned int, const ALCchar *))(*(int *)((char *)&elf_hash_chain[6161] + i) + 20))(
              i,
              deviceName);
      if ( v18 )
      {
        if ( !pthread_mutex_destroy((pthread_mutex_t *)(i + 12)) )
        {
          do
            v19 = *(unsigned __int8 *)--i;
          while ( v19 == 85 );
          free((void *)i);
          if ( TrapALCError )
            raise(5);
          i = 0;
          LastNullDeviceError = v18;
          return (ALCdevice *)i;
        }
        _assert2(
          "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
          357,
          "void DeleteCriticalSection(CRITICAL_SECTION *)",
          "ret == 0");
LABEL_68:
        _assert2(
          "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
          357,
          "void DeleteCriticalSection(CRITICAL_SECTION *)",
          "ret == 0");
        JUMPOUT(0x24DC8C);
      }
      while ( 1 )
      {
        *(int *)((char *)&elf_hash_chain[6164] + i) = (int)DeviceList;
        v20 = *(int *)((char *)&elf_hash_chain[6164] + i);
        v21 = __ldrex((unsigned int *)&DeviceList);
        if ( v21 == v20 )
          break;
LABEL_59:
        __clrex();
        __dmb(0xBu);
      }
      __dmb(0xBu);
      while ( __strex(i, (unsigned int *)&DeviceList) )
      {
        v22 = __ldrex((unsigned int *)&DeviceList);
        if ( v22 != v20 )
          goto LABEL_59;
      }
      __dmb(0xBu);
      if ( (unsigned int)LogLevel_0 > LogWarning )
        j_al_print(
          "(II)",
          "alcCaptureOpenDevice",
          "Created device %p, \"%s\"\n",
          (const void *)i,
          *(const char **)(i + 36));
      return (ALCdevice *)i;
  }
}
// 24DC88: control flows out of bounds to 24DC8C
// 10168: using guessed type int elf_hash_chain[22025];
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);
// 5FCF4C: using guessed type void *DecomposeDevFormat_list;

//----- (0024DD04) --------------------------------------------------------
ALCboolean __fastcall alcCaptureCloseDevice(ALCdevice *Device)
{
  ALCdevice *volatile *v2; // r1
  ALCdevice *v3; // r0
  ALCdevice *volatile v4; // r3
  ALCdevice *volatile v6; // r4

  if ( pthread_mutex_lock(&ListLock) )
    goto LABEL_20;
  v2 = &DeviceList;
  v3 = DeviceList;
  if ( DeviceList )
  {
    v2 = &DeviceList;
    while ( 1 )
    {
      v4 = *v2;
      if ( v3 == Device )
        break;
      v2 = (ALCdevice *volatile *)((char *)&elf_hash_chain[6164] + (_DWORD)v4);
      v3 = *(ALCdevice **)((char *)&elf_hash_chain[6164] + (_DWORD)v4);
      if ( !v3 )
        goto LABEL_6;
    }
    if ( !v4 )
      goto LABEL_12;
  }
  else
  {
LABEL_6:
    if ( !v3 )
      goto LABEL_12;
  }
  if ( (*v2)->Type == Capture )
  {
    *v2 = *(ALCdevice *volatile *)((char *)&(*v2)->ref + (unsigned int)&elf_hash_chain[6164]);
    if ( !pthread_mutex_unlock(&ListLock) )
    {
      j_ALCdevice_DecRef(Device);
      return 1;
    }
LABEL_21:
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      369,
      "void LeaveCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    JUMPOUT(0x24DDE4);
  }
LABEL_12:
  v6 = *v2;
  if ( TrapALCError )
    raise(5);
  if ( v6 )
    v6->LastError = 40961;
  else
    LastNullDeviceError = 40961;
  if ( pthread_mutex_unlock(&ListLock) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      369,
      "void LeaveCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
LABEL_20:
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      363,
      "void EnterCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    goto LABEL_21;
  }
  return 0;
}
// 24DDE2: control flows out of bounds to 24DDE4
// 10168: using guessed type int elf_hash_chain[22025];
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0024DE24) --------------------------------------------------------
void __fastcall alcCaptureStart(ALCdevice *device)
{
  ALCdevice **v2; // r1
  ALCdevice *v3; // r4
  bool v4; // zf
  unsigned int v5; // r0
  char *v6; // r5
  int Flags; // r0
  int v8; // r5

  if ( !device )
    goto LABEL_21;
  if ( pthread_mutex_lock(&ListLock) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      363,
      "void EnterCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    goto LABEL_33;
  }
  v2 = (ALCdevice **)&DeviceList;
  do
  {
    v3 = *v2;
    v4 = *v2 == 0;
    if ( *v2 )
    {
      v2 = (ALCdevice **)((char *)&elf_hash_chain[6164] + (_DWORD)v3);
      v4 = v3 == device;
    }
  }
  while ( !v4 );
  if ( v3 )
  {
    __dmb(0xBu);
    do
      v5 = __ldrex((unsigned int *)&v3->ref);
    while ( __strex(v5 + 1, (unsigned int *)&v3->ref) );
    __dmb(0xBu);
    if ( (unsigned int)LogLevel_0 >= LogRef )
      j_al_print("(--)", "ALCdevice_IncRef", "%p increasing refcount to %u\n", v3, v5 + 1);
  }
  if ( pthread_mutex_unlock(&ListLock) )
  {
LABEL_33:
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      369,
      "void LeaveCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    JUMPOUT(0x24DF4C);
  }
  if ( !v3 )
  {
LABEL_21:
    v8 = 0;
    v3 = 0;
    goto LABEL_23;
  }
  if ( v3->Type == Capture )
  {
    (*(void (__fastcall **)(ALCdevice *))(*(int *)((char *)&elf_hash_chain[6161] + (_DWORD)v3) + 44))(v3);
    v6 = (char *)&elf_hash_chain[6161] + (_DWORD)v3;
    if ( v3->Connected )
    {
      Flags = v3->Flags;
      if ( Flags >= 0 )
      {
        (*(void (__fastcall **)(ALCdevice *))(*(_DWORD *)v6 + 28))(v3);
        Flags = v3->Flags;
      }
      v3->Flags = Flags | 0x80000000;
    }
    (*(void (__fastcall **)(ALCdevice *))(*(_DWORD *)v6 + 48))(v3);
    goto LABEL_30;
  }
  v8 = 1;
LABEL_23:
  if ( TrapALCError )
    raise(5);
  if ( v3 )
  {
    v3->LastError = 40961;
    if ( !v8 )
      return;
LABEL_30:
    ALCdevice_DecRef(v3);
    return;
  }
  LastNullDeviceError = 40961;
  if ( v8 == 1 )
  {
    v3 = 0;
    goto LABEL_30;
  }
}
// 24DF4A: control flows out of bounds to 24DF4C
// 10168: using guessed type int elf_hash_chain[22025];
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0024DF88) --------------------------------------------------------
void __fastcall alcCaptureStop(ALCdevice *device)
{
  ALCdevice **v2; // r1
  ALCdevice *v3; // r4
  bool v4; // zf
  unsigned int v5; // r0
  int Flags; // r0
  char *v7; // r5
  int v8; // r5

  if ( !device )
    goto LABEL_19;
  if ( pthread_mutex_lock(&ListLock) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      363,
      "void EnterCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    goto LABEL_31;
  }
  v2 = (ALCdevice **)&DeviceList;
  do
  {
    v3 = *v2;
    v4 = *v2 == 0;
    if ( *v2 )
    {
      v2 = (ALCdevice **)((char *)&elf_hash_chain[6164] + (_DWORD)v3);
      v4 = v3 == device;
    }
  }
  while ( !v4 );
  if ( v3 )
  {
    __dmb(0xBu);
    do
      v5 = __ldrex((unsigned int *)&v3->ref);
    while ( __strex(v5 + 1, (unsigned int *)&v3->ref) );
    __dmb(0xBu);
    if ( (unsigned int)LogLevel_0 >= LogRef )
      j_al_print("(--)", "ALCdevice_IncRef", "%p increasing refcount to %u\n", v3, v5 + 1);
  }
  if ( pthread_mutex_unlock(&ListLock) )
  {
LABEL_31:
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      369,
      "void LeaveCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    JUMPOUT(0x24E0AC);
  }
  if ( !v3 )
  {
LABEL_19:
    v8 = 0;
    v3 = 0;
    goto LABEL_21;
  }
  if ( v3->Type == Capture )
  {
    (*(void (__fastcall **)(ALCdevice *))(*(int *)((char *)&elf_hash_chain[6161] + (_DWORD)v3) + 44))(v3);
    Flags = v3->Flags;
    v7 = (char *)&elf_hash_chain[6161] + (_DWORD)v3;
    if ( Flags <= -1 )
    {
      (*(void (__fastcall **)(ALCdevice *))(*(_DWORD *)v7 + 32))(v3);
      Flags = v3->Flags;
    }
    v3->Flags = Flags & 0x7FFFFFFF;
    (*(void (__fastcall **)(ALCdevice *))(*(_DWORD *)v7 + 48))(v3);
    goto LABEL_28;
  }
  v8 = 1;
LABEL_21:
  if ( TrapALCError )
    raise(5);
  if ( v3 )
  {
    v3->LastError = 40961;
    if ( !v8 )
      return;
LABEL_28:
    ALCdevice_DecRef(v3);
    return;
  }
  LastNullDeviceError = 40961;
  if ( v8 == 1 )
  {
    v3 = 0;
    goto LABEL_28;
  }
}
// 24E0A8: control flows out of bounds to 24E0AC
// 10168: using guessed type int elf_hash_chain[22025];
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0024E0E8) --------------------------------------------------------
void __fastcall alcCaptureSamples(ALCdevice *device, ALCvoid *buffer, ALCsizei samples)
{
  ALCdevice **v6; // r1
  ALCdevice *v7; // r4
  bool v8; // zf
  unsigned int v9; // r0
  char *v10; // r6
  int v11; // r5

  if ( !device )
    goto LABEL_20;
  if ( pthread_mutex_lock(&ListLock) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      363,
      "void EnterCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    goto LABEL_31;
  }
  v6 = (ALCdevice **)&DeviceList;
  do
  {
    v7 = *v6;
    v8 = *v6 == 0;
    if ( *v6 )
    {
      v6 = (ALCdevice **)((char *)&elf_hash_chain[6164] + (_DWORD)v7);
      v8 = v7 == device;
    }
  }
  while ( !v8 );
  if ( v7 )
  {
    __dmb(0xBu);
    do
      v9 = __ldrex((unsigned int *)&v7->ref);
    while ( __strex(v9 + 1, (unsigned int *)&v7->ref) );
    __dmb(0xBu);
    if ( (unsigned int)LogLevel_0 >= LogRef )
      j_al_print("(--)", "ALCdevice_IncRef", "%p increasing refcount to %u\n", v7, v9 + 1);
  }
  if ( pthread_mutex_unlock(&ListLock) )
  {
LABEL_31:
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      369,
      "void LeaveCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    JUMPOUT(0x24E234);
  }
  if ( v7 )
  {
    (*(void (__fastcall **)(ALCdevice *))(*(int *)((char *)&elf_hash_chain[6161] + (_DWORD)v7) + 44))(v7);
    v10 = (char *)&elf_hash_chain[6161] + (_DWORD)v7;
    if ( samples >= 0 && (*(int (__fastcall **)(ALCdevice *))(*(_DWORD *)v10 + 40))(v7) >= (unsigned int)samples )
      v11 = (*(int (__fastcall **)(ALCdevice *, ALCvoid *, ALCsizei))(*(_DWORD *)v10 + 36))(v7, buffer, samples);
    else
      v11 = 40964;
    (*(void (__fastcall **)(ALCdevice *))(*(_DWORD *)v10 + 48))(v7);
    if ( v11 )
    {
      if ( TrapALCError )
        raise(5);
      v7->LastError = v11;
    }
    ALCdevice_DecRef(v7);
    return;
  }
LABEL_20:
  if ( TrapALCError )
    raise(5);
  LastNullDeviceError = 40961;
}
// 24E230: control flows out of bounds to 24E234
// 24E1EC: conditional instruction was optimized away because r9.4==1
// 24E202: conditional instruction was optimized away because r9.4==1
// 10168: using guessed type int elf_hash_chain[22025];
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0024E280) --------------------------------------------------------
ALCdevice *__fastcall alcLoopbackOpenDeviceSOFT(const ALCchar *deviceName)
{
  volatile ALCenum v2; // r1
  _BYTE *v3; // r0
  unsigned int i; // r4
  MOB_ConfigKey stringVal; // r3
  MOB_ConfigKey key; // r2
  const MOB_ConfigKeyValue *keyValues; // r1
  bool v8; // zf
  MOB_ConfigValue *p_value; // r0
  __int64 v10; // r0
  bool v11; // zf
  MOB_ConfigValue *v12; // r2
  int intVal; // r2
  bool v14; // zf
  MOB_ConfigValue *v15; // r1
  int v16; // r6
  unsigned int v17; // r5
  unsigned int v18; // r5

  pthread_once(&alc_config_once, alc_initconfig);
  if ( deviceName && strcmp((const char *)deviceName, (const char *)alcDefaultName) )
  {
    if ( TrapALCError )
      raise(5);
    v2 = 40964;
LABEL_19:
    LastNullDeviceError = v2;
    return 0;
  }
  v3 = malloc((size_t)&elf_hash_chain[6170]);
  if ( !v3 )
  {
    if ( TrapALCError )
      raise(5);
    v2 = 40965;
    goto LABEL_19;
  }
  *v3 = 0;
  for ( i = (unsigned int)(v3 + 1); (i & 0xF) != 0; *(_BYTE *)i++ = 85 )
    ;
  memset((void *)i, 0, (size_t)&elf_hash_chain[6166]);
  *(int *)((char *)&elf_hash_chain[6161] + i) = (int)&BackendLoopback.Funcs;
  *(_BYTE *)(i + 4) = 1;
  *(_DWORD *)i = 1;
  *(_DWORD *)(i + 8) = 2;
  j_InitializeCriticalSection((CRITICAL_SECTION *)(i + 12));
  *(_DWORD *)(i + 40) = 0;
  *(_DWORD *)(i + 176) = 0;
  *(_DWORD *)(i + 180) = 0;
  *(_DWORD *)(i + 184) = 0;
  *(_DWORD *)(i + 36) = 0;
  *(int *)((char *)&elf_hash_chain[6160] + i) = 0;
  *(_DWORD *)(i + 80) = 0;
  *(_DWORD *)(i + 84) = 0;
  *(_DWORD *)(i + 88) = 0;
  *(_DWORD *)(i + 92) = 0;
  *(_DWORD *)(i + 96) = 0;
  *(_DWORD *)(i + 116) = 0;
  *(_DWORD *)(i + 120) = 0;
  *(_DWORD *)(i + 124) = 0;
  *(_DWORD *)(i + 44) = 256;
  *(_DWORD *)(i + 48) = 4;
  key = -1;
  *(_DWORD *)(i + 128) = 0;
  *(_DWORD *)(i + 132) = 0;
  *(_DWORD *)(i + 60) = 4;
  *(_DWORD *)(i + 64) = 0;
  *(_DWORD *)(i + 68) = 0;
  *(_DWORD *)(i + 72) = 0;
  *(_DWORD *)(i + 76) = -1;
  *(_DWORD *)(i + 100) = 0;
  *(_DWORD *)(i + 104) = 0;
  *(_DWORD *)(i + 108) = 0;
  *(_DWORD *)(i + 112) = -1;
  *(_DWORD *)(i + 152) = 0;
  *(_DWORD *)(i + 156) = 0;
  *(_DWORD *)(i + 160) = 0;
  *(_DWORD *)(i + 164) = 0;
  *(_DWORD *)(i + 136) = 0;
  *(_DWORD *)(i + 140) = 0;
  *(_DWORD *)(i + 144) = 0;
  *(_DWORD *)(i + 148) = -1;
  *(_DWORD *)(i + 168) = 0;
  *(_QWORD *)(i + 16) = 44100LL;
  *(_QWORD *)(i + 24) = 0x150100000000LL;
  *(_DWORD *)(i + 32) = 5126;
  keyValues = g_mob_configGlobals.keyValues;
  v8 = g_mob_configGlobals.keyValues == 0;
  if ( g_mob_configGlobals.keyValues )
  {
    key = g_mob_configGlobals.keyValues->key;
    v8 = g_mob_configGlobals.keyValues->key == MOB_ConfigKey_NULL;
  }
  if ( v8 )
  {
LABEL_15:
    LODWORD(v10) = *(_DWORD *)(i + 44);
  }
  else
  {
    p_value = &g_mob_configGlobals.keyValues->value;
    while ( key != MOB_ConfigKey_root_sources )
    {
      key = (MOB_ConfigKey)p_value[1].stringVal;
      p_value += 2;
      if ( key == MOB_ConfigKey_NULL )
        goto LABEL_15;
    }
    LODWORD(v10) = (MOB_ConfigValue)p_value->stringVal;
    *(_DWORD *)(i + 44) = v10;
  }
  if ( !(_DWORD)v10 )
  {
    LODWORD(v10) = 256;
    *(_DWORD *)(i + 44) = 256;
  }
  v11 = keyValues == 0;
  if ( keyValues )
  {
    stringVal = keyValues->key;
    v11 = keyValues->key == MOB_ConfigKey_NULL;
  }
  if ( v11 )
  {
LABEL_29:
    intVal = *(_DWORD *)(i + 48);
  }
  else
  {
    v12 = &keyValues->value;
    while ( stringVal != MOB_ConfigKey_root_slots )
    {
      stringVal = (MOB_ConfigKey)v12[1].stringVal;
      v12 += 2;
      if ( stringVal == MOB_ConfigKey_NULL )
        goto LABEL_29;
    }
    intVal = v12->intVal;
    *(_DWORD *)(i + 48) = intVal;
  }
  if ( !intVal )
  {
    intVal = 4;
    *(_DWORD *)(i + 48) = 4;
  }
  v14 = keyValues == 0;
  if ( keyValues )
  {
    intVal = keyValues->key;
    v14 = keyValues->key == MOB_ConfigKey_NULL;
  }
  if ( v14 )
  {
LABEL_39:
    HIDWORD(v10) = *(_DWORD *)(i + 60);
  }
  else
  {
    v15 = &keyValues->value;
    while ( intVal != 8 )
    {
      intVal = v15[1].intVal;
      v15 += 2;
      if ( !intVal )
        goto LABEL_39;
    }
    HIDWORD(v10) = (MOB_ConfigValue)v15->stringVal;
    *(_DWORD *)(i + 60) = HIDWORD(v10);
  }
  LODWORD(v10) = v10 - 1;
  if ( HIDWORD(v10) >= 5 )
    *(_DWORD *)(i + 60) = 4;
  HIDWORD(v10) = 1;
  *(_QWORD *)(i + 52) = v10;
  (**(void (__fastcall ***)(unsigned int, const char *))((char *)&elf_hash_chain[6161] + i))(i, "Loopback");
  while ( 1 )
  {
    *(int *)((char *)&elf_hash_chain[6164] + i) = (int)DeviceList;
    v16 = *(int *)((char *)&elf_hash_chain[6164] + i);
    v17 = __ldrex((unsigned int *)&DeviceList);
    if ( v17 == v16 )
      break;
LABEL_44:
    __clrex();
    __dmb(0xBu);
  }
  __dmb(0xBu);
  while ( __strex(i, (unsigned int *)&DeviceList) )
  {
    v18 = __ldrex((unsigned int *)&DeviceList);
    if ( v18 != v16 )
      goto LABEL_44;
  }
  __dmb(0xBu);
  if ( (unsigned int)LogLevel_0 > LogWarning )
    j_al_print("(II)", "alcLoopbackOpenDeviceSOFT", "Created device %p\n", (const void *)i);
  return (ALCdevice *)i;
}
// 24E3EE: variable 'stringVal' is possibly undefined
// 10168: using guessed type int elf_hash_chain[22025];

//----- (0024E51C) --------------------------------------------------------
ALCboolean __fastcall alcIsRenderFormatSupportedSOFT(ALCdevice *device, ALCsizei freq, ALCenum channels, ALCenum type)
{
  ALCdevice **v8; // r1
  ALCdevice *v9; // r4
  bool v10; // zf
  unsigned int v11; // r0
  bool v12; // r6
  int v13; // r5

  if ( !device )
    goto LABEL_21;
  if ( pthread_mutex_lock(&ListLock) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      363,
      "void EnterCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    goto LABEL_37;
  }
  v8 = (ALCdevice **)&DeviceList;
  do
  {
    v9 = *v8;
    v10 = *v8 == 0;
    if ( *v8 )
    {
      v8 = (ALCdevice **)((char *)&elf_hash_chain[6164] + (_DWORD)v9);
      v10 = v9 == device;
    }
  }
  while ( !v10 );
  if ( v9 )
  {
    __dmb(0xBu);
    do
      v11 = __ldrex((unsigned int *)&v9->ref);
    while ( __strex(v11 + 1, (unsigned int *)&v9->ref) );
    __dmb(0xBu);
    if ( (unsigned int)LogLevel_0 >= LogRef )
      j_al_print("(--)", "ALCdevice_IncRef", "%p increasing refcount to %u\n", v9, v11 + 1);
  }
  if ( pthread_mutex_unlock(&ListLock) )
  {
LABEL_37:
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      369,
      "void LeaveCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    JUMPOUT(0x24E65C);
  }
  if ( !v9 )
  {
LABEL_21:
    v13 = 0;
    v9 = 0;
    goto LABEL_23;
  }
  if ( v9->Type == Loopback )
  {
    if ( freq <= 0 )
    {
      if ( TrapALCError )
        raise(5);
      v12 = 0;
      v9->LastError = 40964;
    }
    else if ( (unsigned int)(type - 5120) > 6 )
    {
      v12 = 0;
    }
    else
    {
      v12 = 0;
      if ( (unsigned int)(channels - 5376) <= 6 && channels != 5378 )
        v12 = freq >= 8000;
    }
    goto LABEL_34;
  }
  v13 = 1;
LABEL_23:
  if ( TrapALCError )
    raise(5);
  if ( v9 )
  {
    v12 = 0;
    v9->LastError = 40961;
    if ( !v13 )
      return v12;
  }
  else
  {
    v12 = 0;
    v9 = 0;
    LastNullDeviceError = 40961;
    if ( v13 != 1 )
      return v12;
  }
LABEL_34:
  j_ALCdevice_DecRef(v9);
  return v12;
}
// 24E65A: control flows out of bounds to 24E65C
// 10168: using guessed type int elf_hash_chain[22025];
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0024E69C) --------------------------------------------------------
void __fastcall alcRenderSamplesSOFT(ALCdevice *device, ALCvoid *buffer, ALCsizei samples)
{
  ALCdevice **v6; // r1
  ALCdevice *v7; // r4
  bool v8; // zf
  unsigned int v9; // r0
  int v10; // r5

  if ( !device )
    goto LABEL_22;
  if ( pthread_mutex_lock(&ListLock) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      363,
      "void EnterCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    goto LABEL_35;
  }
  v6 = (ALCdevice **)&DeviceList;
  do
  {
    v7 = *v6;
    v8 = *v6 == 0;
    if ( *v6 )
    {
      v6 = (ALCdevice **)((char *)&elf_hash_chain[6164] + (_DWORD)v7);
      v8 = v7 == device;
    }
  }
  while ( !v8 );
  if ( v7 )
  {
    __dmb(0xBu);
    do
      v9 = __ldrex((unsigned int *)&v7->ref);
    while ( __strex(v9 + 1, (unsigned int *)&v7->ref) );
    __dmb(0xBu);
    if ( (unsigned int)LogLevel_0 >= LogRef )
      j_al_print("(--)", "ALCdevice_IncRef", "%p increasing refcount to %u\n", v7, v9 + 1);
  }
  if ( pthread_mutex_unlock(&ListLock) )
  {
LABEL_35:
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      369,
      "void LeaveCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    JUMPOUT(0x24E7C8);
  }
  if ( !v7 )
  {
LABEL_22:
    v10 = 0;
    v7 = 0;
    goto LABEL_24;
  }
  if ( v7->Type == Loopback )
  {
    if ( samples >= 0 && (buffer || !samples) )
    {
      j_aluMixData(v7, buffer, samples);
    }
    else
    {
      if ( TrapALCError )
        raise(5);
      v7->LastError = 40964;
    }
    goto LABEL_33;
  }
  v10 = 1;
LABEL_24:
  if ( TrapALCError )
    raise(5);
  if ( v7 )
  {
    v7->LastError = 40961;
    if ( v10 )
      goto LABEL_33;
  }
  else
  {
    LastNullDeviceError = 40961;
    if ( v10 == 1 )
    {
      v7 = 0;
LABEL_33:
      ALCdevice_DecRef(v7);
    }
  }
}
// 24E7C6: control flows out of bounds to 24E7C8
// 10168: using guessed type int elf_hash_chain[22025];
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0024E808) --------------------------------------------------------
ALvoid __fastcall aluMixData(ALCdevice *device, ALvoid *buffer, ALsizei size)
{
  unsigned int v5; // r10
  ALCcontext *volatile i; // r8
  volatile ALenum DeferUpdates; // r11
  unsigned int v8; // r9
  unsigned int *p_UpdateSources; // r0
  ALlistener *Listener; // r0
  float v11; // s4
  float v12; // s2
  float v13; // s0
  float v14; // s6
  float v15; // s6
  float v16; // s10
  float v17; // s8
  float v18; // s6
  float v19; // s12
  float v20; // s12
  float v21; // s14
  float v22; // s1
  float v23; // s12
  float v24; // s3
  float v25; // s3
  float v26; // s5
  float v27; // s15
  float v28; // s13
  float v29; // s3
  float v30; // s5
  float v31; // s7
  float v32; // s3
  float v33; // s9
  float v34; // s11
  float v35; // s1
  float v36; // s10
  float v37; // s4
  float v38; // s9
  ALsizei ActiveSourceCount; // r0
  ALsource_0 **ActiveSources; // r5
  ALsource_0 **v41; // r6
  ALsource_0 *v42; // r0
  ALsource_0 *v43; // t1
  unsigned int *p_NeedsUpdate; // r0
  unsigned int v45; // r1
  ALsource_0 *v46; // t1
  ALsizei ActiveEffectSlotCount; // r0
  float **ActiveEffectSlots; // r6
  float **v49; // r9
  float *v50; // r0
  float v51; // s2
  float v52; // s0
  unsigned int v53; // r0
  int v54; // r1
  float *v55; // r2
  float v56; // s4
  float *v57; // r0
  unsigned int *v58; // r0
  unsigned int v59; // r1
  unsigned int v60; // r0
  int v61; // r1
  float *v62; // r0
  float v63; // s0
  float v64; // s0
  float v65; // s4
  ALeffectslot **v66; // r3
  unsigned int v67; // r0
  int v68; // r1
  float *v69; // r2
  float v70; // s4
  ALeffectslot *v71; // r0
  unsigned int *v72; // r0
  unsigned int v73; // r1
  unsigned int v74; // r0
  int v75; // r1
  DevFmtChannels FmtChans; // r0
  float v77; // s0
  ALfloat (*v78)[2048]; // r1
  unsigned int v79; // r0
  ALfloat v80; // s2
  float v81; // s0
  float *v82; // r1
  unsigned int v83; // r0
  float v84; // s2
  bs2b *Bs2b; // r0
  bool v86; // zf
  float *v87; // r2
  unsigned int mm; // r1
  double v89; // d27
  double v90; // d28
  double a0_lo; // d16
  double b1_lo; // d17
  double a0_hi; // d18
  double a1_hi; // d19
  double b1_hi; // d20
  double v96; // d22
  double v97; // d24
  double v98; // d16
  double v99; // d17
  double v100; // d21
  float v101; // s0
  float v102; // s2
  float gain; // s4
  float v104; // s0
  float *v105; // r1
  unsigned int v106; // r0
  float v107; // s2
  ALfloat (*v108)[2048]; // r5
  int v109; // r0
  volatile RefCount *v110; // r2
  float v111; // s0
  unsigned int v112; // r6
  float *v113; // r1
  float v114; // s2
  int v115; // r0
  int v116; // r0
  DevFmtChannels v117; // r1
  int v118; // r12
  DevFmtChannels v119; // r1
  DevFmtChannels v120; // r1
  int v121; // r12
  int v122; // lr
  DevFmtChannels v123; // r1
  int v124; // r12
  int v125; // r11
  DevFmtChannels v126; // r1
  ALfloat (*DryBuffer)[2048]; // r12
  int j; // r1
  ALuint v129; // r2
  bool v130; // zf
  char *v131; // r3
  float *v132; // r2
  unsigned int v133; // r5
  float v134; // s0
  float v135; // s0
  float v136; // s0
  ALfloat (*v137)[2048]; // r12
  int k; // r1
  ALuint v139; // r2
  bool v140; // zf
  char *v141; // r3
  float *v142; // r2
  unsigned int v143; // r5
  float v144; // s0
  float v145; // s0
  float v146; // s0
  ALfloat (*v147)[2048]; // lr
  int m; // r2
  ALuint v149; // r0
  bool v150; // zf
  char *v151; // r6
  float *v152; // r3
  unsigned int v153; // r0
  float v154; // s0
  float v155; // s0
  float v156; // s0
  ALfloat (*v157)[2048]; // lr
  int n; // r2
  ALuint v159; // r0
  bool v160; // zf
  char *v161; // r6
  float *v162; // r3
  unsigned int v163; // r0
  float v164; // s0
  float v165; // s0
  float v166; // s0
  ALfloat (*v167)[2048]; // r5
  int ii; // r2
  ALuint v169; // r0
  bool v170; // zf
  char *v171; // r6
  float *v172; // r3
  unsigned int v173; // r0
  float v174; // s0
  float v175; // s0
  float v176; // s0
  ALfloat (*v177)[2048]; // lr
  int jj; // r2
  ALuint v179; // r0
  bool v180; // zf
  unsigned int *v181; // r6
  float *v182; // r3
  unsigned int v183; // r0
  float v184; // s0
  float v185; // s0
  float v186; // s0
  ALfloat (*v187)[2048]; // lr
  int kk; // r2
  ALuint v189; // r0
  bool v190; // zf
  char *v191; // r6
  ALfloat (*v192)[2048]; // r3
  unsigned int v193; // r0
  ALfloat v194; // t1
  int rounding_direction; // [sp+4h] [bp-BCh]
  float *v196; // [sp+8h] [bp-B8h]
  float *v197; // [sp+Ch] [bp-B4h]
  float *v198; // [sp+10h] [bp-B0h]
  float *v199; // [sp+14h] [bp-ACh]
  float *v200; // [sp+18h] [bp-A8h]
  float *v201; // [sp+1Ch] [bp-A4h]
  ALCcontext *volatile *p_ContextList; // [sp+20h] [bp-A0h]
  char *v203; // [sp+48h] [bp-78h]
  ALsizei v204; // [sp+4Ch] [bp-74h]
  BackendFuncs **p_Funcs; // [sp+50h] [bp-70h]
  ALeffectslot **p_DefaultSlot; // [sp+54h] [bp-6Ch]

  rounding_direction = fegetround();
  fesetround(3);
  if ( size >= 1 )
  {
    v198 = &device->PendingClicks[1];
    v201 = &device->ClickRemoval[1];
    v197 = (float *)((char *)&elf_hash_chain[6150] + (_DWORD)device);
    v200 = (float *)((char *)&elf_hash_chain[6138] + (_DWORD)device);
    v196 = &device->PendingClicks[2];
    v199 = &device->ClickRemoval[2];
    p_ContextList = &device->ContextList;
    p_Funcs = &device->Funcs;
    p_DefaultSlot = &device->DefaultSlot;
    do
    {
      v5 = size;
      v203 = (char *)buffer;
      v204 = size;
      if ( (unsigned int)size >= 0x800 )
        v5 = 2048;
      memset(device->DryBuffer, 0, 4 * v5);
      memset(device->DryBuffer[1], 0, 4 * v5);
      memset(device->DryBuffer[2], 0, 4 * v5);
      memset(device->DryBuffer[3], 0, 4 * v5);
      memset(device->DryBuffer[4], 0, 4 * v5);
      memset(device->DryBuffer[5], 0, 4 * v5);
      memset(device->DryBuffer[6], 0, 4 * v5);
      memset(device->DryBuffer[7], 0, 4 * v5);
      memset(device->DryBuffer[8], 0, 4 * v5);
      (*p_Funcs)->Lock(device);
      for ( i = *p_ContextList; i; i = i->next )
      {
        DeferUpdates = i->DeferUpdates;
        if ( DeferUpdates )
          goto LABEL_7;
        p_UpdateSources = (unsigned int *)&i->UpdateSources;
        __dmb(0xBu);
        do
          v8 = __ldrex(p_UpdateSources);
        while ( __strex(0, p_UpdateSources) );
        __dmb(0xBu);
        if ( !v8 )
        {
LABEL_7:
          v8 = 0;
        }
        else
        {
          Listener = i->Listener;
          v11 = Listener->Forward[0];
          v12 = Listener->Forward[1];
          v13 = Listener->Forward[2];
          v14 = (float)((float)(v11 * v11) + (float)(v12 * v12)) + (float)(v13 * v13);
          if ( v14 > 0.0 )
          {
            v15 = 1.0 / sqrtf(v14);
            v13 = v13 * v15;
            v12 = v12 * v15;
            v11 = v11 * v15;
          }
          v16 = Listener->Up[0];
          v17 = Listener->Up[1];
          v18 = Listener->Up[2];
          v19 = (float)((float)(v16 * v16) + (float)(v17 * v17)) + (float)(v18 * v18);
          if ( v19 > 0.0 )
          {
            v20 = 1.0 / sqrtf(v19);
            v18 = v18 * v20;
            v17 = v17 * v20;
            v16 = v16 * v20;
          }
          v21 = (float)(v13 * v16) - (float)(v11 * v18);
          v22 = (float)(v12 * v18) - (float)(v13 * v17);
          v23 = (float)(v11 * v17) - (float)(v12 * v16);
          v24 = (float)(v23 * v23) + (float)((float)(v22 * v22) + (float)(v21 * v21));
          if ( v24 > 0.0 )
          {
            v25 = 1.0 / sqrtf(v24);
            v23 = v23 * v25;
            v21 = v21 * v25;
            v22 = v22 * v25;
          }
          Listener->Params.Matrix[0][3] = 0.0;
          Listener->Params.Matrix[1][3] = 0.0;
          Listener->Params.Matrix[2][3] = 0.0;
          Listener->Params.Matrix[0][0] = v22;
          Listener->Params.Matrix[0][1] = v16;
          Listener->Params.Matrix[0][2] = -v11;
          Listener->Params.Matrix[1][0] = v21;
          Listener->Params.Matrix[1][1] = v17;
          Listener->Params.Matrix[1][2] = -v12;
          Listener->Params.Matrix[2][0] = v23;
          Listener->Params.Matrix[2][1] = v18;
          Listener->Params.Matrix[2][2] = -v13;
          Listener->Params.Matrix[3][3] = 1.0;
          v26 = Listener->Position[1];
          v27 = Listener->Position[2];
          v28 = v26 * v12;
          v29 = (float)(v16 * Listener->Position[0]) + (float)(v17 * v26);
          v30 = (float)((float)((float)(v22 * Listener->Position[0]) + (float)(v21 * v26)) + (float)(v23 * v27)) + 0.0;
          v31 = (float)((float)((float)-(float)(v11 * Listener->Position[0]) - v28) - (float)(v27 * v13)) + 0.0;
          v32 = (float)(v29 + (float)(v18 * v27)) + 0.0;
          Listener->Params.Matrix[3][0] = -v30;
          Listener->Params.Matrix[3][1] = -v32;
          Listener->Params.Matrix[3][2] = -v31;
          v33 = Listener->Velocity[0];
          v34 = Listener->Velocity[1];
          v35 = v22 * v33;
          v36 = v16 * v33;
          v37 = -(float)(v11 * v33);
          v38 = Listener->Velocity[2];
          Listener->Params.Velocity[0] = (float)((float)(v35 + (float)(v21 * v34)) + (float)(v23 * v38))
                                       - (float)(v30 * 0.0);
          Listener->Params.Velocity[1] = (float)((float)(v36 + (float)(v17 * v34)) + (float)(v18 * v38))
                                       - (float)(v32 * 0.0);
          Listener->Params.Velocity[2] = (float)((float)(v37 - (float)(v34 * v12)) - (float)(v38 * v13))
                                       - (float)(v31 * 0.0);
        }
        ActiveSourceCount = i->ActiveSourceCount;
        if ( ActiveSourceCount )
        {
          ActiveSources = i->ActiveSources;
          v41 = &ActiveSources[ActiveSourceCount];
          do
          {
            v42 = *ActiveSources;
            while ( v42->state != 4114 )
            {
              --i->ActiveSourceCount;
              v43 = *--v41;
              v42 = v43;
              *ActiveSources = v43;
              if ( ActiveSources == v41 )
                goto LABEL_30;
            }
            if ( !DeferUpdates )
            {
              p_NeedsUpdate = (unsigned int *)&v42->NeedsUpdate;
              __dmb(0xBu);
              do
                v45 = __ldrex(p_NeedsUpdate);
              while ( __strex(0, p_NeedsUpdate) );
              __dmb(0xBu);
              if ( v45 | v8 )
                ((void (*)(void))(*ActiveSources)->Update)();
            }
            v46 = *ActiveSources++;
            j_MixSource(v46, device, v5);
          }
          while ( ActiveSources != v41 );
        }
LABEL_30:
        ActiveEffectSlotCount = i->ActiveEffectSlotCount;
        if ( ActiveEffectSlotCount )
        {
          ActiveEffectSlots = (float **)i->ActiveEffectSlots;
          v49 = &ActiveEffectSlots[ActiveEffectSlotCount];
          do
          {
            v50 = *ActiveEffectSlots;
            v51 = (*ActiveEffectSlots)[2100];
            if ( v51 >= 0.000030518 )
            {
              v52 = v51 + (float)(v51 * -0.0039062);
              v50[52] = v51 + v50[52];
              if ( v5 >= 2 )
              {
                v53 = 1;
                v54 = 53;
                do
                {
                  ++v53;
                  v55 = &(*ActiveEffectSlots)[v54++];
                  v56 = v52 + *v55;
                  v52 = v52 + (float)(v52 * -0.0039062);
                  *v55 = v56;
                }
                while ( v53 < v5 );
              }
              v50 = *ActiveEffectSlots;
            }
            else
            {
              v52 = 0.0;
            }
            v50[2100] = v52 + v50[2101];
            (*ActiveEffectSlots)[2101] = 0.0;
            if ( !DeferUpdates )
            {
              v57 = *ActiveEffectSlots;
              __dmb(0xBu);
              v58 = (unsigned int *)(v57 + 48);
              do
                v59 = __ldrex(v58);
              while ( __strex(0, v58) );
              __dmb(0xBu);
              if ( v59 )
                (*(void (**)(void))(*((_DWORD *)*ActiveEffectSlots + 49) + 8))();
            }
            (*(void (**)(void))(*((_DWORD *)*ActiveEffectSlots + 49) + 12))();
            v60 = 0;
            v61 = 52;
            do
            {
              ++v60;
              (*ActiveEffectSlots)[v61++] = 0.0;
            }
            while ( v60 < v5 );
            ++ActiveEffectSlots;
          }
          while ( ActiveEffectSlots != v49 );
        }
      }
      v62 = (float *)*p_DefaultSlot;
      if ( *p_DefaultSlot )
      {
        v63 = v62[2100];
        if ( v63 >= 0.000030518 )
        {
          v65 = v63 + v62[52];
          v64 = v63 + (float)(v63 * -0.0039062);
          v62[52] = v65;
          if ( v5 == 1 )
          {
            v66 = &device->DefaultSlot;
          }
          else
          {
            v66 = &device->DefaultSlot;
            v67 = 1;
            v68 = 212;
            do
            {
              ++v67;
              v69 = (float *)((char *)&(*p_DefaultSlot)->effect.type + v68);
              v68 += 4;
              v70 = v64 + *v69;
              v64 = v64 + (float)(v64 * -0.0039062);
              *v69 = v70;
            }
            while ( v67 < v5 );
          }
          v62 = (float *)*v66;
        }
        else
        {
          v64 = 0.0;
        }
        v62[2100] = v64 + v62[2101];
        (*p_DefaultSlot)->PendingClicks[0] = 0.0;
        v71 = *p_DefaultSlot;
        __dmb(0xBu);
        v72 = (unsigned int *)&v71->NeedsUpdate;
        do
          v73 = __ldrex(v72);
        while ( __strex(0, v72) );
        __dmb(0xBu);
        if ( v73 )
          ((void (*)(void))(*p_DefaultSlot)->EffectState->Update)();
        ((void (*)(void))(*p_DefaultSlot)->EffectState->Process)();
        v74 = 0;
        v75 = 208;
        do
        {
          ++v74;
          *(ALenum *)((char *)&(*p_DefaultSlot)->effect.type + v75) = 0;
          v75 += 4;
        }
        while ( v74 < v5 );
      }
      (*p_Funcs)->Unlock(device);
      FmtChans = device->FmtChans;
      if ( FmtChans == DevFmtMono )
      {
        v104 = 0.0;
        if ( *v199 >= 0.000030518 )
        {
          v104 = *v199;
          v105 = device->DryBuffer[2];
          v106 = 0;
          do
          {
            ++v106;
            v107 = v104 + *v105;
            v104 = v104 + (float)(v104 * -0.0039062);
            *v105++ = v107;
          }
          while ( v106 < v5 );
        }
        *v199 = v104 + *v196;
        *v196 = 0.0;
        if ( v203 )
        {
LABEL_89:
          switch ( device->FmtType )
          {
            case DevFmtByte:
              v115 = 1;
              switch ( device->FmtChans )
              {
                case DevFmtMono:
                  break;
                case DevFmtStereo:
                  v115 = 2;
                  break;
                case DevFmtQuad:
                  v115 = 4;
                  break;
                case DevFmtX51:
                  v115 = 6;
                  break;
                case DevFmtX61:
                  v115 = 7;
                  break;
                case DevFmtX71:
                  v115 = 8;
                  break;
                default:
                  v115 = 0;
                  break;
              }
              DryBuffer = device->DryBuffer;
              for ( j = 0; j != 9; ++j )
              {
                v129 = device->ChannelOffsets[j];
                v130 = v129 == -1;
                if ( v129 != -1 )
                  v130 = v5 == 0;
                if ( !v130 )
                {
                  v131 = &v203[v129];
                  v132 = (float *)DryBuffer;
                  v133 = v5;
                  do
                  {
                    v134 = *v132++;
                    --v133;
                    v135 = (float)(v134 + 1.0) - fabsf(v134 + -1.0);
                    v136 = (float)((float)((float)(v135 + -2.0) + fabsf(v135 + 2.0)) * 0.25) * 2147483650.0;
                    *v131 = (unsigned int)(int)v136 >> 24;
                    v131 += v115;
                  }
                  while ( v133 );
                }
                ++DryBuffer;
              }
              goto LABEL_147;
            case DevFmtUByte:
              v115 = 1;
              switch ( device->FmtChans )
              {
                case DevFmtMono:
                  break;
                case DevFmtStereo:
                  v115 = 2;
                  break;
                case DevFmtQuad:
                  v115 = 4;
                  break;
                case DevFmtX51:
                  v115 = 6;
                  break;
                case DevFmtX61:
                  v115 = 7;
                  break;
                case DevFmtX71:
                  v115 = 8;
                  break;
                default:
                  v115 = 0;
                  break;
              }
              v137 = device->DryBuffer;
              for ( k = 0; k != 9; ++k )
              {
                v139 = device->ChannelOffsets[k];
                v140 = v139 == -1;
                if ( v139 != -1 )
                  v140 = v5 == 0;
                if ( !v140 )
                {
                  v141 = &v203[v139];
                  v142 = (float *)v137;
                  v143 = v5;
                  do
                  {
                    v144 = *v142++;
                    --v143;
                    v145 = (float)(v144 + 1.0) - fabsf(v144 + -1.0);
                    v146 = (float)((float)((float)(v145 + -2.0) + fabsf(v145 + 2.0)) * 0.25) * 2147483650.0;
                    *v141 = ((unsigned int)(int)v146 >> 24) + 0x80;
                    v141 += v115;
                  }
                  while ( v143 );
                }
                ++v137;
              }
LABEL_147:
              v116 = v115 * v5;
              break;
            case DevFmtShort:
              v117 = device->FmtChans;
              v118 = 1;
              switch ( v117 )
              {
                case DevFmtMono:
                  goto LABEL_151;
                case DevFmtStereo:
                  v118 = 2;
                  goto LABEL_151;
                case DevFmtMono|0x2:
                  goto LABEL_121;
                case DevFmtQuad:
                  v118 = 4;
                  goto LABEL_151;
                case DevFmtX51:
                  goto LABEL_110;
                case DevFmtX61:
                  v118 = 7;
                  goto LABEL_151;
                case DevFmtX71:
                  v118 = 8;
                  goto LABEL_151;
                default:
                  if ( v117 == 0x80000000 )
LABEL_110:
                    v118 = 6;
                  else
LABEL_121:
                    v118 = 0;
LABEL_151:
                  v147 = device->DryBuffer;
                  for ( m = 0; m != 9; ++m )
                  {
                    v149 = device->ChannelOffsets[m];
                    v150 = v149 == -1;
                    if ( v149 != -1 )
                      v150 = v5 == 0;
                    if ( !v150 )
                    {
                      v151 = &v203[2 * v149];
                      v152 = (float *)v147;
                      v153 = v5;
                      do
                      {
                        v154 = *v152++;
                        --v153;
                        v155 = (float)(v154 + 1.0) - fabsf(v154 + -1.0);
                        v156 = (float)((float)((float)(v155 + -2.0) + fabsf(v155 + 2.0)) * 0.25) * 2147483650.0;
                        *(_WORD *)v151 = (unsigned int)(int)v156 >> 16;
                        v151 += 2 * v118;
                      }
                      while ( v153 );
                    }
                    ++v147;
                  }
                  break;
              }
              goto LABEL_169;
            case DevFmtUShort:
              v119 = device->FmtChans;
              v118 = 1;
              switch ( v119 )
              {
                case DevFmtMono:
                  goto LABEL_162;
                case DevFmtStereo:
                  v118 = 2;
                  goto LABEL_162;
                case DevFmtMono|0x2:
                  goto LABEL_122;
                case DevFmtQuad:
                  v118 = 4;
                  goto LABEL_162;
                case DevFmtX51:
                  goto LABEL_112;
                case DevFmtX61:
                  v118 = 7;
                  goto LABEL_162;
                case DevFmtX71:
                  v118 = 8;
                  goto LABEL_162;
                default:
                  if ( v119 == 0x80000000 )
LABEL_112:
                    v118 = 6;
                  else
LABEL_122:
                    v118 = 0;
LABEL_162:
                  v157 = device->DryBuffer;
                  for ( n = 0; n != 9; ++n )
                  {
                    v159 = device->ChannelOffsets[n];
                    v160 = v159 == -1;
                    if ( v159 != -1 )
                      v160 = v5 == 0;
                    if ( !v160 )
                    {
                      v161 = &v203[2 * v159];
                      v162 = (float *)v157;
                      v163 = v5;
                      do
                      {
                        v164 = *v162++;
                        --v163;
                        v165 = (float)(v164 + 1.0) - fabsf(v164 + -1.0);
                        v166 = (float)((float)((float)(v165 + -2.0) + fabsf(v165 + 2.0)) * 0.25) * 2147483650.0;
                        *(_WORD *)v161 = ((unsigned int)(int)v166 >> 16) + 0x8000;
                        v161 += 2 * v118;
                      }
                      while ( v163 );
                    }
                    ++v157;
                  }
                  break;
              }
LABEL_169:
              v116 = 2 * v5 * v118;
              break;
            case DevFmtInt:
              v120 = device->FmtChans;
              v121 = 1;
              v122 = 4 * v5;
              switch ( v120 )
              {
                case DevFmtMono:
                  goto LABEL_173;
                case DevFmtStereo:
                  v121 = 2;
                  goto LABEL_173;
                case DevFmtMono|0x2:
                  goto LABEL_123;
                case DevFmtQuad:
                  v121 = 4;
                  goto LABEL_173;
                case DevFmtX51:
                  goto LABEL_114;
                case DevFmtX61:
                  v121 = 7;
                  goto LABEL_173;
                case DevFmtX71:
                  v121 = 8;
                  goto LABEL_173;
                default:
                  v122 = 4 * v5;
                  if ( v120 == 0x80000000 )
LABEL_114:
                    v121 = 6;
                  else
LABEL_123:
                    v121 = 0;
LABEL_173:
                  v167 = device->DryBuffer;
                  for ( ii = 0; ii != 9; ++ii )
                  {
                    v169 = device->ChannelOffsets[ii];
                    v170 = v169 == -1;
                    if ( v169 != -1 )
                      v170 = v5 == 0;
                    if ( !v170 )
                    {
                      v171 = &v203[4 * v169];
                      v172 = (float *)v167;
                      v173 = v5;
                      do
                      {
                        v174 = *v172++;
                        --v173;
                        v175 = (float)(v174 + 1.0) - fabsf(v174 + -1.0);
                        v176 = (float)((float)((float)(v175 + -2.0) + fabsf(v175 + 2.0)) * 0.25) * 2147483650.0;
                        *(_DWORD *)v171 = (int)v176;
                        v171 += 4 * v121;
                      }
                      while ( v173 );
                    }
                    ++v167;
                  }
                  v116 = v122 * v121;
                  break;
              }
              break;
            case DevFmtUInt:
              v123 = device->FmtChans;
              v124 = 1;
              v125 = 4 * v5;
              switch ( v123 )
              {
                case DevFmtMono:
                  goto LABEL_184;
                case DevFmtStereo:
                  v124 = 2;
                  goto LABEL_184;
                case DevFmtMono|0x2:
                  goto LABEL_124;
                case DevFmtQuad:
                  v124 = 4;
                  goto LABEL_184;
                case DevFmtX51:
                  goto LABEL_116;
                case DevFmtX61:
                  v124 = 7;
                  goto LABEL_184;
                case DevFmtX71:
                  v124 = 8;
                  goto LABEL_184;
                default:
                  v125 = 4 * v5;
                  if ( v123 == 0x80000000 )
LABEL_116:
                    v124 = 6;
                  else
LABEL_124:
                    v124 = 0;
LABEL_184:
                  v177 = device->DryBuffer;
                  for ( jj = 0; jj != 9; ++jj )
                  {
                    v179 = device->ChannelOffsets[jj];
                    v180 = v179 == -1;
                    if ( v179 != -1 )
                      v180 = v5 == 0;
                    if ( !v180 )
                    {
                      v181 = (unsigned int *)&v203[4 * v179];
                      v182 = (float *)v177;
                      v183 = v5;
                      do
                      {
                        v184 = *v182++;
                        --v183;
                        v185 = (float)(v184 + 1.0) - fabsf(v184 + -1.0);
                        v186 = (float)((float)((float)(v185 + -2.0) + fabsf(v185 + 2.0)) * 0.25) * 2147483650.0;
                        *v181 = (int)v186 ^ 0x80000000;
                        v181 += v124;
                      }
                      while ( v183 );
                    }
                    ++v177;
                  }
                  break;
              }
              goto LABEL_202;
            case DevFmtFloat:
              v126 = device->FmtChans;
              v124 = 1;
              v125 = 4 * v5;
              switch ( v126 )
              {
                case DevFmtMono:
                  goto LABEL_195;
                case DevFmtStereo:
                  v124 = 2;
                  goto LABEL_195;
                case DevFmtMono|0x2:
                  goto LABEL_125;
                case DevFmtQuad:
                  v124 = 4;
                  goto LABEL_195;
                case DevFmtX51:
                  goto LABEL_118;
                case DevFmtX61:
                  v124 = 7;
                  goto LABEL_195;
                case DevFmtX71:
                  v124 = 8;
                  goto LABEL_195;
                default:
                  v125 = 4 * v5;
                  if ( v126 == 0x80000000 )
LABEL_118:
                    v124 = 6;
                  else
LABEL_125:
                    v124 = 0;
LABEL_195:
                  v187 = device->DryBuffer;
                  for ( kk = 0; kk != 9; ++kk )
                  {
                    v189 = device->ChannelOffsets[kk];
                    v190 = v189 == -1;
                    if ( v189 != -1 )
                      v190 = v5 == 0;
                    if ( !v190 )
                    {
                      v191 = &v203[4 * v189];
                      v192 = v187;
                      v193 = v5;
                      do
                      {
                        v194 = (*v192)[0];
                        v192 = (ALfloat (*)[2048])((char *)v192 + 4);
                        --v193;
                        *(ALfloat *)v191 = v194;
                        v191 += 4 * v124;
                      }
                      while ( v193 );
                    }
                    ++v187;
                  }
                  break;
              }
LABEL_202:
              v116 = v125 * v124;
              break;
            default:
              v116 = 0;
              break;
          }
          buffer = &v203[v116];
          goto LABEL_204;
        }
      }
      else
      {
        if ( FmtChans == DevFmtStereo )
        {
          if ( *v200 >= 0.000030518 )
          {
            v77 = *v200;
            v78 = device->DryBuffer;
            v79 = 0;
            do
            {
              ++v79;
              v80 = v77 + (*v78)[0];
              v77 = v77 + (float)(v77 * -0.0039062);
              (*v78)[0] = v80;
              v78 = (ALfloat (*)[2048])((char *)v78 + 4);
            }
            while ( v79 < v5 );
          }
          else
          {
            v77 = 0.0;
          }
          *v200 = v77 + *v197;
          *v197 = 0.0;
          if ( *v201 >= 0.000030518 )
          {
            v81 = *v201;
            v82 = device->DryBuffer[1];
            v83 = 0;
            do
            {
              ++v83;
              v84 = v81 + *v82;
              v81 = v81 + (float)(v81 * -0.0039062);
              *v82++ = v84;
            }
            while ( v83 < v5 );
          }
          else
          {
            v81 = 0.0;
          }
          *v201 = v81 + *v198;
          *v198 = 0.0;
          Bs2b = device->Bs2b;
          v86 = Bs2b == 0;
          if ( Bs2b )
            v86 = v5 == 0;
          if ( !v86 )
          {
            v87 = device->DryBuffer[0];
            for ( mm = 1; ; ++mm )
            {
              v89 = *v87;
              v90 = v87[2048];
              a0_lo = Bs2b->a0_lo;
              b1_lo = Bs2b->b1_lo;
              a0_hi = Bs2b->a0_hi;
              a1_hi = Bs2b->a1_hi;
              b1_hi = Bs2b->b1_hi;
              v96 = b1_lo * Bs2b->last_sample.lo[1];
              v97 = a0_lo * v90;
              v98 = a0_lo * v89 + b1_lo * Bs2b->last_sample.lo[0];
              v99 = a0_hi * v90 + a1_hi * Bs2b->last_sample.asis[1] + b1_hi * Bs2b->last_sample.hi[1];
              v100 = a0_hi * v89 + a1_hi * Bs2b->last_sample.asis[0] + b1_hi * Bs2b->last_sample.hi[0];
              v101 = v97 + v96 + v100;
              v102 = v99 + v98;
              gain = Bs2b->gain;
              Bs2b->last_sample.asis[0] = v89;
              Bs2b->last_sample.asis[1] = v90;
              Bs2b->last_sample.lo[0] = v98;
              Bs2b->last_sample.lo[1] = v97 + v96;
              Bs2b->last_sample.hi[0] = v100;
              Bs2b->last_sample.hi[1] = v99;
              *v87 = gain * v101;
              v87[2048] = gain * v102;
              if ( mm >= v5 )
                break;
              ++v87;
              Bs2b = device->Bs2b;
            }
          }
        }
        else
        {
          v108 = device->DryBuffer;
          v109 = 0;
          do
          {
            v110 = &device->ref + v109;
            if ( *(float *)((char *)&elf_hash_chain[6138] + (_DWORD)v110) >= 0.000030518 )
            {
              v111 = *(float *)((char *)&elf_hash_chain[6138] + (_DWORD)v110);
              v112 = 0;
              v113 = (float *)v108;
              do
              {
                ++v112;
                v114 = v111 + *v113;
                v111 = v111 + (float)(v111 * -0.0039062);
                *v113++ = v114;
              }
              while ( v112 < v5 );
            }
            else
            {
              v111 = 0.0;
            }
            ++v109;
            ++v108;
            *(float *)((char *)&elf_hash_chain[6138] + (_DWORD)v110) = v111
                                                                     + *(float *)((char *)&elf_hash_chain[6150]
                                                                                + (_DWORD)v110);
            *(int *)((char *)&elf_hash_chain[6150] + (_DWORD)v110) = 0;
          }
          while ( v109 != 9 );
        }
        if ( v203 )
          goto LABEL_89;
      }
      buffer = 0;
LABEL_204:
      size = v204 - v5;
    }
    while ( (int)(v204 - v5) > 0 );
  }
  sub_18F050(rounding_direction);
}
// 24ED4A: conditional instruction was optimized away because r10.4>=1
// 24EDF0: conditional instruction was optimized away because r10.4>=1
// 24EE4E: conditional instruction was optimized away because r10.4>=1
// 24EEA2: conditional instruction was optimized away because r10.4>=1
// 24EFBE: conditional instruction was optimized away because r10.4>=1
// 24F010: conditional instruction was optimized away because r10.4>=1
// 10168: using guessed type int elf_hash_chain[22025];

//----- (0024F5F4) --------------------------------------------------------
const Hrtf *__fastcall GetHrtf(ALCdevice *device)
{
  ALCdevice *v1; // r2
  MOB_ConfigKey key; // r1
  ALuint Frequency; // r8
  Hrtf *i; // r4
  bool v5; // zf
  MOB_ConfigValue *p_value; // r0
  const char *intVal; // r10
  int v8; // r0
  int v9; // r4
  int v10; // r4
  int v11; // r4
  int v12; // r6
  int v13; // r4
  unsigned __int16 v14; // r8
  ALubyte v15; // r2
  int v16; // r0
  int v17; // r4
  int v18; // r4
  int v19; // r4
  int v20; // r6
  unsigned __int8 v21; // r4
  ALubyte v22; // r2
  int v23; // r0
  ALubyte v24; // r6
  ALubyte v25; // r4
  int v26; // r4
  unsigned __int8 *v27; // r6
  _WORD *v28; // r0
  _WORD *v29; // r8
  bool v30; // zf
  ALubyte v31; // r8
  ALuint v32; // r3
  ALubyte v33; // r8
  unsigned int v34; // r8
  unsigned __int8 *v35; // r4
  void *v36; // r0
  unsigned __int8 *v37; // r1
  bool v38; // zf
  void *v39; // r4
  int v40; // r4
  int v41; // r6
  unsigned __int8 v42; // r0
  void *v43; // r6
  const ALubyte *v44; // r8
  int v45; // r4
  int v46; // r8
  unsigned __int16 *v47; // r6
  __int16 v48; // r0
  unsigned int v49; // r1
  unsigned __int16 v50; // r0
  unsigned __int8 v51; // r0
  ALuint v52; // r2
  unsigned int v53; // r0
  int v54; // r3
  unsigned __int8 v55; // r0
  void *v56; // r8
  const ALubyte *v57; // r4
  ALubyte *v58; // r0
  unsigned __int8 *v59; // r6
  unsigned __int8 v60; // r0
  _WORD *v61; // r1
  unsigned __int8 *v62; // r2
  unsigned int v63; // r3
  __int16 v64; // r6
  size_t v65; // r4
  int v66; // t1
  _WORD *v67; // r8
  const ALubyte *v68; // r0
  bool v69; // zf
  ALuint v70; // r8
  _WORD *v71; // r6
  int v72; // r2
  __int16 v73; // r4
  int v74; // r4
  int v75; // r8
  ALubyte v76; // r0
  const ALubyte *v77; // r0
  bool v78; // zf
  ALuint v79; // r6
  _WORD *v80; // r8
  int v81; // r2
  __int16 v82; // r4
  int v83; // r4
  int v84; // r6
  ALubyte v85; // r0
  int j; // r4
  int v87; // t1
  int v88; // r0
  unsigned int v89; // r6
  size_t v90; // r0
  bool v91; // zf
  int v92; // r3
  int v93; // r5
  bool v94; // zf
  char *v95; // r4
  bool v96; // zf
  char *v97; // r0
  int v98; // t1
  unsigned int v99; // r4
  FILE *v101; // r5
  DevFmtChannels FmtChans; // r1
  const char *v103; // r3
  ALuint v105; // [sp+0h] [bp-10E0h]
  unsigned int v106; // [sp+10h] [bp-10D0h]
  size_t v107; // [sp+10h] [bp-10D0h]
  const ALubyte *v108; // [sp+14h] [bp-10CCh]
  ALubyte v109; // [sp+18h] [bp-10C8h]
  unsigned int v110; // [sp+1Ch] [bp-10C4h]
  unsigned int v111; // [sp+1Ch] [bp-10C4h]
  ALuint v112; // [sp+5Ch] [bp-1084h]
  int v113; // [sp+6Ch] [bp-1074h]
  _WORD *v114; // [sp+6Ch] [bp-1074h]
  int v115; // [sp+78h] [bp-1068h]
  int v116; // [sp+8Ch] [bp-1054h]
  _WORD *k; // [sp+8Ch] [bp-1054h]
  _WORD *m; // [sp+8Ch] [bp-1054h]
  int v119; // [sp+90h] [bp-1050h]
  __int16 v120; // [sp+90h] [bp-1050h]
  int v121; // [sp+90h] [bp-1050h]
  int v122; // [sp+90h] [bp-1050h]
  int v123; // [sp+90h] [bp-1050h]
  _WORD *v124; // [sp+98h] [bp-1048h]
  unsigned __int8 *p; // [sp+9Ch] [bp-1044h]
  ALuint v127; // [sp+A8h] [bp-1038h]
  char v128[8]; // [sp+B4h] [bp-102Ch] BYREF
  char v129[4096]; // [sp+BCh] [bp-1024h] BYREF

  v1 = device;
  key = 5377;
  if ( device->FmtChans != DevFmtStereo )
  {
LABEL_212:
    if ( LogLevel_0 )
    {
      FmtChans = v1->FmtChans;
      v103 = "Mono";
      switch ( FmtChans )
      {
        case DevFmtMono:
          break;
        case DevFmtStereo:
          v103 = "Stereo";
          break;
        case DevFmtMono|0x2:
          goto LABEL_217;
        case DevFmtQuad:
          v103 = "Quadraphonic";
          break;
        case DevFmtX51:
          v103 = "5.1 Surround";
          break;
        case DevFmtX61:
          v103 = "6.1 Surround";
          break;
        case DevFmtX71:
          v103 = "7.1 Surround";
          break;
        default:
          if ( FmtChans == 0x80000000 )
            v103 = "5.1 Side";
          else
LABEL_217:
            v103 = "(unknown channels)";
          break;
      }
      j_al_print("(EE)", "GetHrtf", "Incompatible format: %s %uhz\n", v103, v1->Frequency);
    }
    return 0;
  }
  Frequency = device->Frequency;
  for ( i = LoadedHrtfs; i; i = i->next )
  {
    if ( Frequency == i->sampleRate )
      return i;
  }
  v5 = g_mob_configGlobals.keyValues == 0;
  if ( g_mob_configGlobals.keyValues )
  {
    key = g_mob_configGlobals.keyValues->key;
    v5 = g_mob_configGlobals.keyValues->key == MOB_ConfigKey_NULL;
  }
  if ( v5 )
    goto LABEL_210;
  p_value = &g_mob_configGlobals.keyValues->value;
  while ( key != MOB_ConfigKey_root_hrtf_tables )
  {
    key = (MOB_ConfigKey)p_value[1].stringVal;
    p_value += 2;
    if ( key == MOB_ConfigKey_NULL )
      goto LABEL_210;
  }
  intVal = (const char *)p_value->intVal;
  v8 = *p_value->stringVal;
  if ( !v8 )
  {
LABEL_210:
    v1 = device;
    if ( device->Frequency == 44100 )
      return &DefaultHrtf;
    goto LABEL_212;
  }
  v127 = Frequency;
  while ( 1 )
  {
    for ( j = (unsigned __int8)v8; ; j = v87 )
    {
      v88 = isspace(j);
      if ( j != 44 && !v88 )
        break;
      v87 = *(unsigned __int8 *)++intVal;
    }
    v89 = 0;
    while ( 1 )
    {
      v93 = *(unsigned __int8 *)intVal;
      v94 = v93 == 0;
      if ( *intVal )
        v94 = v93 == 44;
      if ( v94 )
        break;
      v95 = strpbrk(intVal, (const char *)&dword_2501E0);
      v96 = v95 == intVal;
      if ( v95 != intVal )
        v96 = v93 == 0;
      if ( !v96 && !(v89 >> 12) )
      {
        v97 = (char *)(intVal + 1);
        while ( 1 )
        {
          v129[v89++] = v93;
          if ( v95 == v97 )
            break;
          v98 = (unsigned __int8)*v97++;
          LOBYTE(v93) = v98;
          if ( !v98 || v89 >= 0x1000 )
          {
            intVal = v97 - 1;
            goto LABEL_165;
          }
        }
        intVal = v95;
      }
LABEL_165:
      v91 = v95 == 0;
      if ( v95 )
        v91 = *v95 == 44;
      if ( v91 )
        break;
      intVal = v95 + 1;
      v92 = (unsigned __int8)v95[1];
      if ( v92 == 37 )
      {
        if ( !(v89 >> 12) )
          v129[v89++] = 37;
        intVal = v95 + 2;
      }
      else if ( v92 == 114 )
      {
        v90 = snprintf((unsigned __int8 *)&v129[v89], 4096 - v89, (const unsigned __int8 *)&dword_2501E4, Frequency);
        intVal = v95 + 2;
        if ( v90 > 4096 - v89 )
          v90 = 4096 - v89;
        v89 += v90;
      }
      else if ( LogLevel_0 )
      {
        j_al_print("(EE)", "LoadHrtf", "Invalid marker '%%%c'\n", v92);
      }
    }
    if ( v89 >= 0xFFF )
      v89 = 4095;
    v129[v89] = 0;
    v99 = v89 + 1;
    while ( v99 != 1 )
    {
      if ( !isspace((unsigned __int8)v128[v99-- + 6]) )
        goto LABEL_194;
    }
    v99 = 0;
LABEL_194:
    v129[v99] = 0;
    if ( !v129[0] )
      goto LABEL_209;
    if ( (unsigned int)LogLevel_0 >= LogTrace )
      j_al_print("(II)", "LoadHrtf", "Loading %s...\n", v129);
    v101 = fopen(v129, "rb");
    if ( !v101 )
    {
      if ( LogLevel_0 )
        j_al_print("(EE)", "LoadHrtf", "Could not open %s\n", v129);
      goto LABEL_209;
    }
    if ( fread(v128, 1u, 8u, v101) != 8 )
    {
      if ( LogLevel_0 )
        j_al_print("(EE)", "LoadHrtf", "Failed to read header from %s\n", v129);
      goto LABEL_207;
    }
    if ( !memcmp(v128, magicMarker00, 8u) )
    {
      if ( (unsigned int)LogLevel_0 >= LogTrace )
        j_al_print("(II)", "LoadHrtf", "Detected data set format v0\n");
      v9 = fgetc(v101);
      v10 = v9 | (fgetc(v101) << 8);
      v11 = v10 | (fgetc(v101) << 16);
      v12 = v11 | (fgetc(v101) << 24);
      v113 = fgetc(v101);
      v119 = fgetc(v101);
      v13 = fgetc(v101);
      v14 = v13 | ((unsigned __int16)fgetc(v101) << 8);
      v15 = fgetc(v101);
      v115 = v12;
      if ( v12 == v127 )
      {
        v16 = 0;
      }
      else
      {
        if ( LogLevel_0 )
        {
          v24 = v15;
          j_al_print("(EE)", "LoadHrtf00", "HRIR rate does not match device rate: rate=%d (%d)\n", v115, v127);
          v15 = v24;
        }
        v16 = 1;
      }
      if ( v13 << 29 || (unsigned int)v14 - 8 >= 0x79 )
      {
        if ( LogLevel_0 )
        {
          v25 = v15;
          j_al_print("(EE)", "LoadHrtf00", "Unsupported HRIR size: irSize=%d (%d to %d by %d)\n", v14, 8, 128, 8);
          v15 = v25;
        }
        v16 = 1;
      }
      v26 = v15;
      if ( (unsigned int)v15 - 5 >= 0x7C )
      {
        if ( LogLevel_0 )
          j_al_print("(EE)", "LoadHrtf00", "Unsupported elevation count: evCount=%d (%d to %d)\n", v15, 5, 128);
        goto LABEL_207;
      }
      if ( v16 )
        goto LABEL_207;
      v112 = v14;
      v109 = v15;
      v27 = (unsigned __int8 *)malloc(v15);
      v28 = malloc(2 * v26);
      v29 = v28;
      v30 = v27 == 0;
      v124 = v28;
      if ( v27 )
        v30 = v28 == 0;
      if ( v30 )
      {
        if ( LogLevel_0 )
          j_al_print("(EE)", "LoadHrtf00", "Out of memory.\n");
      }
      else
      {
        v110 = v113 | (v119 << 8);
        v120 = fgetc(v101);
        p = v27;
        *v29 = v120 | ((unsigned __int16)fgetc(v101) << 8);
        v121 = v26 - 1;
        v45 = 0;
        v116 = 0;
        do
        {
          v46 = v45;
          v47 = &v124[v45];
          v47[1] = fgetc(v101);
          v48 = fgetc(v101);
          v49 = *v47;
          ++v45;
          v50 = v47[1] | (v48 << 8);
          v47[1] = v50;
          if ( v50 <= v49 )
          {
            if ( LogLevel_0 )
            {
              j_al_print("(EE)", "LoadHrtf00", "Invalid evOffset: evOffset[%d]=%d (last=%d)\n", v46 + 1, v50, v49);
              LOWORD(v49) = v124[v46];
              v50 = v47[1];
            }
            v116 = 1;
          }
          v27 = p;
          v51 = v50 - v49;
          p[v46] = v51;
          if ( (unsigned int)v51 - 1 >= 0x80 )
          {
            v116 = 1;
            if ( LogLevel_0 )
              j_al_print(
                "(EE)",
                "LoadHrtf00",
                "Unsupported azimuth count: azCount[%d]=%d (%d to %d)\n",
                v46,
                v51,
                1,
                128);
          }
        }
        while ( v121 != v45 );
        v52 = v112;
        v53 = (unsigned __int16)v124[v121];
        if ( v110 <= v53 )
        {
          if ( LogLevel_0 )
          {
            j_al_print(
              "(EE)",
              "LoadHrtf00",
              "Invalid evOffset: evOffset[%d]=%d (irCount=%d)\n",
              v121,
              (unsigned __int16)v124[v121],
              v110);
            LOWORD(v53) = v124[v121];
            v52 = v112;
          }
          v54 = 1;
        }
        else
        {
          v54 = v116;
        }
        v55 = v113 - v53;
        p[v121] = v55;
        if ( (unsigned int)v55 - 1 >= 0x80 )
        {
          v56 = v124;
          if ( LogLevel_0 )
            j_al_print(
              "(EE)",
              "LoadHrtf00",
              "Unsupported azimuth count: azCount[%d]=%d (%d to %d)\n",
              v121,
              v55,
              1,
              128);
          v57 = 0;
          v114 = 0;
          goto LABEL_82;
        }
        if ( !(v54 << 24) )
        {
          v106 = v110 * v52;
          v67 = malloc(2 * v110 * v52);
          v68 = (const ALubyte *)malloc(v110);
          v69 = v67 == 0;
          v114 = v67;
          v108 = v68;
          if ( v67 )
            v69 = v68 == 0;
          if ( !v69 )
          {
            v70 = v112;
            if ( v106 )
            {
              v71 = v114;
              v72 = 0;
              do
              {
                v122 = v72;
                for ( k = v71; v70; --v70 )
                {
                  v73 = fgetc(v101);
                  *v71++ = v73 | ((unsigned __int16)fgetc(v101) << 8);
                }
                v70 = v112;
                v71 = &k[v112];
                v72 = v122 + v112;
              }
              while ( v122 + v112 < v106 );
            }
            if ( v110 )
            {
              v74 = 0;
              v75 = 0;
              do
              {
                v76 = fgetc(v101);
                v108[v74] = v76;
                if ( v76 >= 0x40u )
                {
                  if ( LogLevel_0 )
                    j_al_print("(EE)", "LoadHrtf00", "Invalid delays[%d]: %d (%d)\n", v74, v76, 63);
                  v75 = 1;
                }
                ++v74;
              }
              while ( v110 != v74 );
            }
            else
            {
              v75 = 0;
            }
            if ( feof(v101) )
            {
              v56 = v124;
              v27 = p;
              if ( LogLevel_0 )
                j_al_print("(EE)", "LoadHrtf00", "Premature end of data\n");
            }
            else
            {
              if ( !(v75 << 24) )
              {
                i = (Hrtf *)malloc(0x20u);
                if ( i )
                  goto LABEL_225;
                if ( LogLevel_0 )
                  j_al_print("(EE)", "LoadHrtf00", "Out of memory.\n");
              }
              v56 = v124;
              v27 = p;
            }
            v57 = v108;
            goto LABEL_82;
          }
          if ( LogLevel_0 )
            j_al_print("(EE)", "LoadHrtf00", "Out of memory.\n");
          v57 = v108;
          goto LABEL_81;
        }
      }
      v57 = 0;
      v114 = 0;
LABEL_81:
      v56 = v124;
LABEL_82:
      free(v27);
      free(v56);
      free(v114);
      v58 = (ALubyte *)v57;
LABEL_87:
      free(v58);
      goto LABEL_207;
    }
    if ( memcmp(v128, magicMarker01, 8u) )
    {
      if ( LogLevel_0 )
        j_al_print("(EE)", "LoadHrtf", "Invalid header in %s: \"%.8s\"\n", v129, v128);
      goto LABEL_207;
    }
    if ( (unsigned int)LogLevel_0 >= LogTrace )
      j_al_print("(II)", "LoadHrtf", "Detected data set format v1\n");
    v17 = fgetc(v101);
    v18 = v17 | (fgetc(v101) << 8);
    v19 = v18 | (fgetc(v101) << 16);
    v20 = v19 | (fgetc(v101) << 24);
    v21 = fgetc(v101);
    v22 = fgetc(v101);
    if ( v20 == Frequency )
    {
      v23 = 0;
    }
    else
    {
      if ( LogLevel_0 )
      {
        v105 = Frequency;
        v31 = v22;
        j_al_print("(EE)", "LoadHrtf01", "HRIR rate does not match device rate: rate=%d (%d)\n", v20, v105);
        v22 = v31;
      }
      v23 = 1;
    }
    v32 = v21;
    if ( (v21 & 7) != 0 || (unsigned int)v21 - 8 >= 0x79 )
    {
      if ( LogLevel_0 )
      {
        v33 = v22;
        j_al_print("(EE)", "LoadHrtf01", "Unsupported HRIR size: irSize=%d (%d to %d by %d)\n", v21, 8, 128, 8);
        v32 = v21;
        v22 = v33;
      }
      v23 = 1;
    }
    v34 = v22;
    if ( (unsigned int)v22 - 5 >= 0x7C )
    {
      if ( LogLevel_0 )
        j_al_print("(EE)", "LoadHrtf01", "Unsupported elevation count: evCount=%d (%d to %d)\n", v22, 5, 128);
      goto LABEL_207;
    }
    v115 = v20;
    if ( !v23 )
      break;
LABEL_207:
    fclose(v101);
    Frequency = v127;
    if ( LogLevel_0 )
      j_al_print("(EE)", "LoadHrtf", "Failed to load %s\n", v129);
LABEL_209:
    LOBYTE(v8) = *intVal;
    if ( !*intVal )
      goto LABEL_210;
  }
  v112 = v32;
  v109 = v22;
  v35 = (unsigned __int8 *)malloc(v22);
  v36 = malloc(2 * v34);
  v37 = v35;
  v38 = v35 == 0;
  v39 = v36;
  if ( !v38 )
    v38 = v36 == 0;
  if ( v38 )
  {
    if ( LogLevel_0 )
    {
      v59 = v37;
      j_al_print("(EE)", "LoadHrtf01", "Out of memory.\n");
      v37 = v59;
    }
    v43 = 0;
    v44 = 0;
    goto LABEL_86;
  }
  v124 = v36;
  p = v37;
  v40 = 0;
  v41 = 0;
  do
  {
    v42 = fgetc(v101);
    p[v40] = v42;
    if ( (unsigned int)v42 - 1 >= 0x80 )
    {
      v41 = 1;
      if ( LogLevel_0 )
        j_al_print("(EE)", "LoadHrtf01", "Unsupported azimuth count: azCount[%d]=%d (%d to %d)\n", v40, v42, 1, 128);
    }
    ++v40;
  }
  while ( v34 != v40 );
  if ( v41 << 24 )
  {
    v43 = 0;
    v44 = 0;
    v39 = v124;
    v37 = p;
    goto LABEL_86;
  }
  *v124 = 0;
  v60 = *p;
  if ( v34 < 2 )
  {
    v65 = *p;
  }
  else
  {
    v61 = v124 + 1;
    v62 = p + 1;
    v63 = v34 - 1;
    v64 = 0;
    v65 = *p;
    do
    {
      --v63;
      v64 += v60;
      v66 = *v62++;
      v60 = v66;
      *v61++ = v64;
      v65 += v66;
    }
    while ( v63 );
  }
  v111 = v112 * v65;
  v43 = malloc(2 * v112 * v65);
  v77 = (const ALubyte *)malloc(v65);
  v78 = v43 == 0;
  if ( v43 )
    v78 = v77 == 0;
  if ( v78 )
  {
    v44 = v77;
    v37 = p;
    if ( LogLevel_0 )
    {
      j_al_print("(EE)", "LoadHrtf01", "Out of memory.\n");
      v37 = p;
    }
    v39 = v124;
LABEL_86:
    free(v37);
    free(v39);
    free(v43);
    v58 = (ALubyte *)v44;
    goto LABEL_87;
  }
  v107 = v65;
  v108 = v77;
  v114 = v43;
  v79 = v112;
  if ( v111 )
  {
    v80 = v114;
    v81 = 0;
    do
    {
      v123 = v81;
      for ( m = v80; v79; --v79 )
      {
        v82 = fgetc(v101);
        *v80++ = v82 | ((unsigned __int16)fgetc(v101) << 8);
      }
      v79 = v112;
      v80 = &m[v112];
      v81 = v123 + v112;
    }
    while ( v123 + v112 < v111 );
  }
  if ( v107 )
  {
    v83 = 0;
    v84 = 0;
    do
    {
      v85 = fgetc(v101);
      v108[v83] = v85;
      if ( v85 >= 0x40u )
      {
        if ( LogLevel_0 )
          j_al_print("(EE)", "LoadHrtf01", "Invalid delays[%d]: %d (%d)\n", v83, v85, 63);
        v84 = 1;
      }
      ++v83;
    }
    while ( v107 != v83 );
  }
  else
  {
    v84 = 0;
  }
  if ( feof(v101) )
  {
    v39 = v124;
    v37 = p;
    v43 = v114;
    if ( LogLevel_0 )
    {
      j_al_print("(EE)", "LoadHrtf01", "Premature end of data\n");
      v37 = p;
    }
    v44 = v108;
    goto LABEL_86;
  }
  v5 = v84 << 24 == 0;
  v43 = v114;
  if ( !v5 )
  {
    v39 = v124;
    v37 = p;
    v44 = v108;
    goto LABEL_86;
  }
  i = (Hrtf *)malloc(0x20u);
  if ( !i )
  {
    v39 = v124;
    if ( LogLevel_0 )
      j_al_print("(EE)", "LoadHrtf01", "Out of memory.\n");
    v44 = v108;
    v37 = p;
    goto LABEL_86;
  }
LABEL_225:
  i->sampleRate = v115;
  i->irSize = v112;
  i->evCount = v109;
  i->azCount = p;
  i->evOffset = v124;
  i->coeffs = v114;
  i->delays = v108;
  i->next = 0;
  fclose(v101);
  i->next = LoadedHrtfs;
  LoadedHrtfs = i;
  if ( (unsigned int)LogLevel_0 >= LogTrace )
    j_al_print("(II)", "LoadHrtf", "Loaded HRTF support for format: %s %uhz\n", "Stereo", i->sampleRate);
  return i;
}
// 2501E0: using guessed type int dword_2501E0;
// 2501E4: using guessed type int dword_2501E4;
// 24F5F4: using guessed type char var_1024[4096];

//----- (0025046C) --------------------------------------------------------
void ReadALConfig()
{
  FILE *v0; // r0
  FILE *v1; // r4
  char *v2; // r0
  bool v3; // zf
  FILE *v4; // r0
  FILE *v5; // r4
  char *v6; // r0
  bool v7; // zf
  FILE *v8; // r0
  FILE *v9; // r4

  cfgBlocks = (ConfigBlock_0 *)calloc(1u, 0xCu);
  cfgBlocks->name = j_strdup("general");
  cfgCount = 1;
  v0 = fopen("/etc/openal/alsoft.conf", "r");
  v1 = v0;
  if ( v0 )
  {
    LoadConfigFromFile(v0);
    fclose(v1);
  }
  v2 = getenv("HOME");
  v3 = v2 == 0;
  if ( v2 )
    v3 = *v2 == 0;
  if ( !v3 )
  {
    snprintf(buffer, 0x400u, "%s/.alsoftrc", v2);
    v4 = fopen((const char *)buffer, "r");
    v5 = v4;
    if ( v4 )
    {
      LoadConfigFromFile(v4);
      fclose(v5);
    }
  }
  v6 = getenv("ALSOFT_CONF");
  v7 = v6 == 0;
  if ( v6 )
    v7 = *v6 == 0;
  if ( !v7 )
  {
    v8 = fopen(v6, "r");
    v9 = v8;
    if ( v8 )
    {
      LoadConfigFromFile(v8);
      sub_1A04C4(v9);
    }
  }
}

//----- (00250568) --------------------------------------------------------
void __fastcall LoadConfigFromFile(FILE *f)
{
  FILE *v1; // r8
  ConfigBlock_0 *v2; // r5
  int v3; // r5
  unsigned __int8 *v4; // r2
  int v5; // r0
  unsigned __int8 *v6; // r1
  unsigned __int8 *v7; // r6
  int v8; // r1
  bool v9; // zf
  int v10; // r5
  unsigned int v12; // r8
  unsigned int v13; // r4
  const char *name; // r6
  int i; // r4
  unsigned __int8 *v16; // r0
  bool v17; // zf
  bool v18; // zf
  int v19; // r5
  unsigned __int8 *v20; // r8
  int v21; // t1
  unsigned int entryCount; // r4
  const char **entries; // r5
  const char **v24; // r6
  ConfigEntry_0 *v25; // r0
  ConfigEntry_0 *v26; // r5
  unsigned int v27; // r4
  int v28; // r4
  int v29; // r0
  bool v30; // zf
  int v31; // r6
  unsigned __int8 *v32; // r0
  ConfigBlock_0 *v33; // r5
  unsigned int v34; // r0
  int v35; // r4
  unsigned __int8 *v36; // r3
  char *v37; // r6
  ConfigBlock_0 *v38; // r9
  int v39; // r5
  int v40; // t1
  FILE *v41; // [sp+2Ch] [bp-24h]

  v1 = f;
  v2 = cfgBlocks;
  if ( fgets((char *)buffer, 1024, f) )
  {
    v41 = v1;
    while ( 1 )
    {
      v37 = &algn_6D6414[3];
      v38 = v2;
      do
      {
        v40 = (unsigned __int8)*++v37;
        v39 = v40;
      }
      while ( isspace(v40) );
      if ( !v39 || v39 == 35 )
        goto LABEL_87;
      memmove(buffer, v37, strlen(v37) + 1);
      v3 = buffer[0];
      if ( buffer[0] == 91 )
        break;
      for ( i = 0; ; ++i )
      {
        if ( !(_BYTE)v3 )
          goto LABEL_33;
        v17 = (unsigned __int8)v3 == 35;
        if ( (unsigned __int8)v3 != 35 )
          v17 = (unsigned __int8)v3 == 61;
        if ( v17 )
          goto LABEL_29;
        if ( isspace((unsigned __int8)v3) )
          break;
        v16 = &buffer[i];
        v3 = v16[1];
      }
      if ( !(v3 << 24) )
      {
LABEL_33:
        if ( LogLevel_0 )
          j_al_print(
            "(EE)",
            "LoadConfigFromFile",
            "config parse error: malformed option line: \"%s\"\n",
            (const char *)buffer);
        v2 = v38;
        goto LABEL_88;
      }
LABEL_29:
      v18 = i == 0;
      if ( i )
        v18 = (unsigned __int8)v3 == 35;
      if ( v18 )
        goto LABEL_33;
      if ( (unsigned __int8)v3 == 61 )
        goto LABEL_42;
      buffer[i] = 0;
      do
        v19 = buffer[++i];
      while ( isspace(v19) );
      if ( v19 == 61 )
      {
LABEL_42:
        v20 = &buffer[i];
        buffer[i] = 0;
        do
          v21 = *++v20;
        while ( isspace(v21) );
        entryCount = v38->entryCount;
        entries = (const char **)v38->entries;
        v24 = entries;
        if ( entryCount )
        {
          entries = (const char **)v38->entries;
          do
          {
            if ( !strcasecmp(*entries, (const char *)buffer) )
              break;
            entries += 2;
          }
          while ( ((char *)entries - (char *)v24) >> 3 < entryCount );
        }
        if ( ((char *)entries - (char *)v24) >> 3 < entryCount )
          goto LABEL_51;
        v25 = (ConfigEntry_0 *)realloc(v24, 8 * entryCount + 8);
        v26 = v25;
        if ( v25 )
        {
          v27 = v38->entryCount;
          v38->entries = v25;
          v38->entryCount = v27 + 1;
          v25[v27].key = j_strdup(buffer);
          entries = (const char **)&v26[v27];
          entries[1] = 0;
LABEL_51:
          memmove(buffer, v20, strlen((const char *)v20) + 1);
          v28 = 0;
          v1 = v41;
          while ( 1 )
          {
            v29 = buffer[v28];
            if ( !buffer[v28] )
              break;
            v30 = v29 == 35;
            if ( v29 != 35 )
              v30 = v29 == 10;
            if ( v30 )
              break;
            ++v28;
          }
          do
          {
            v31 = v28;
            if ( v28 < 1 )
              break;
            --v28;
          }
          while ( isspace(buffer[v31 - 1]) );
          buffer[v31] = 0;
          free((void *)entries[1]);
          v32 = j_strdup(buffer);
          entries[1] = (const char *)v32;
          if ( (unsigned int)LogLevel_0 > LogWarning )
            j_al_print("(II)", "LoadConfigFromFile", "found '%s' = '%s'\n", *entries, (const char *)v32);
          v2 = v38;
          goto LABEL_88;
        }
        if ( LogLevel_0 )
          j_al_print("(EE)", "LoadConfigFromFile", "config parse error: error reallocating config entries\n");
        v2 = v38;
        v1 = v41;
      }
      else
      {
        if ( LogLevel_0 )
          j_al_print(
            "(EE)",
            "LoadConfigFromFile",
            "config parse error: option without a value: \"%s\"\n",
            (const char *)buffer);
        v2 = v38;
        v1 = v41;
      }
LABEL_88:
      if ( !fgets((char *)buffer, 1024, v1) )
        return;
    }
    v4 = &buffer[1];
    v5 = 0;
    do
    {
      v6 = &buffer[v5];
      v7 = v4;
      ++v5;
      v8 = v6[1];
      v9 = v8 == 93;
      if ( v8 != 93 )
      {
        ++v4;
        v9 = v8 == 0;
      }
    }
    while ( !v9 );
    if ( v8 )
    {
      buffer[v5] = 0;
      while ( 1 )
      {
        v10 = v7[1];
        if ( !v7[1] )
          break;
        if ( !isspace(*++v7) )
        {
          if ( v10 != 35 && (unsigned int)LogLevel_0 >= LogWarning )
            j_al_print(
              "(WW)",
              "LoadConfigFromFile",
              "config warning: extra data after block: \"%s\"\n",
              (const char *)v7);
          break;
        }
      }
      v12 = cfgCount;
      if ( cfgCount )
      {
        v13 = 0;
        v2 = cfgBlocks;
        while ( 1 )
        {
          name = (const char *)v2->name;
          if ( !strcasecmp((const char *)v2->name, (const char *)&buffer[1]) )
            break;
          ++v13;
          ++v2;
          if ( v13 >= v12 )
            goto LABEL_68;
        }
        if ( (unsigned int)LogLevel_0 >= LogTrace )
          j_al_print("(II)", "LoadConfigFromFile", "found block '%s'\n", name);
        v1 = v41;
        if ( v2 )
          goto LABEL_88;
        v12 = cfgCount;
      }
      else
      {
        v12 = 0;
      }
LABEL_68:
      v33 = (ConfigBlock_0 *)realloc(cfgBlocks, 12 * v12 + 12);
      if ( v33 )
      {
        v34 = cfgCount;
        cfgBlocks = v33;
        ++cfgCount;
        v35 = v34;
        v36 = j_strdup(&buffer[1]);
        v33[v35].name = v36;
        v2 = &v33[v35];
        v2->entries = 0;
        v2->entryCount = 0;
        v1 = v41;
        if ( (unsigned int)LogLevel_0 >= LogTrace )
          j_al_print("(II)", "LoadConfigFromFile", "found new block '%s'\n", (const char *)v36);
        goto LABEL_88;
      }
      v1 = v41;
      if ( LogLevel_0 )
        j_al_print("(EE)", "LoadConfigFromFile", "config parse error: error reallocating config blocks\n");
    }
    else if ( LogLevel_0 )
    {
      j_al_print("(EE)", "LoadConfigFromFile", "config parse error: bad line \"%s\"\n", (const char *)buffer);
    }
LABEL_87:
    v2 = v38;
    goto LABEL_88;
  }
}

//----- (00250B4C) --------------------------------------------------------
void FreeALConfig()
{
  unsigned int v0; // r11
  __int64 v1; // r0
  unsigned int v2; // r4

  if ( cfgCount )
  {
    v0 = 0;
    do
    {
      v1 = *(_QWORD *)&cfgBlocks[v0].entries;
      if ( HIDWORD(v1) )
      {
        v2 = 0;
        do
        {
          free(*(void **)(v1 + 8 * v2));
          free(cfgBlocks[v0].entries[v2++].value);
          v1 = *(_QWORD *)&cfgBlocks[v0].entries;
        }
        while ( v2 < HIDWORD(v1) );
      }
      free((void *)v1);
      free(cfgBlocks[v0++].name);
    }
    while ( v0 < cfgCount );
  }
  free(cfgBlocks);
  cfgBlocks = 0;
  cfgCount = 0;
}

//----- (00250C0C) --------------------------------------------------------
const unsigned __int8 *__fastcall GetConfigValue(
        const unsigned __int8 *blockName,
        const unsigned __int8 *keyName,
        const unsigned __int8 *def)
{
  const unsigned __int8 *v4; // r4
  const unsigned __int8 *v5; // r2
  int v6; // r8
  ConfigBlock_0 *v7; // r11
  ConfigBlock_0 *v8; // r0
  unsigned int entryCount; // r10
  ConfigEntry_0 *entries; // r9
  int v11; // r5
  unsigned int v14; // [sp+Ch] [bp-24h]
  char *v15; // [sp+10h] [bp-20h]

  v4 = def;
  if ( keyName )
  {
    v5 = "general";
    if ( blockName )
      v5 = blockName;
    v15 = (char *)v5;
    v14 = cfgCount;
    if ( cfgCount )
    {
      v6 = 0;
      v7 = cfgBlocks;
      while ( 1 )
      {
        if ( !strcasecmp((const char *)v7[v6].name, v15) )
        {
          v8 = &v7[v6];
          entryCount = v8->entryCount;
          if ( entryCount )
            break;
        }
LABEL_12:
        if ( ++v6 >= v14 )
          goto LABEL_13;
      }
      entries = v8->entries;
      v11 = 0;
      while ( strcasecmp((const char *)entries[v11].key, (const char *)keyName) )
      {
        if ( ++v11 >= entryCount )
          goto LABEL_12;
      }
      if ( (unsigned int)LogLevel_0 >= LogTrace )
      {
        j_al_print(
          "(II)",
          "GetConfigValue",
          "Found %s:%s = \"%s\"\n",
          v15,
          (const char *)keyName,
          (const char *)entries[v11].value);
        entries = cfgBlocks[v6].entries;
      }
      v4 = def;
      if ( *entries[v11].value )
        return entries[v11].value;
    }
    else
    {
LABEL_13:
      v4 = def;
      if ( (unsigned int)LogLevel_0 >= LogTrace )
        j_al_print("(II)", "GetConfigValue", "Key %s:%s not found\n", v15, (const char *)keyName);
    }
  }
  return v4;
}

//----- (00250D54) --------------------------------------------------------
int __fastcall ConfigValueExists(const unsigned __int8 *blockName, const unsigned __int8 *keyName)
{
  return *j_GetConfigValue(blockName, keyName, (const unsigned __int8 *)&byte_61CADE) != 0;
}
// 61CADE: using guessed type char byte_61CADE;

//----- (00250D70) --------------------------------------------------------
int __fastcall ConfigValueInt(const unsigned __int8 *blockName, const unsigned __int8 *keyName, int *ret)
{
  const char *ConfigValue; // r0

  ConfigValue = (const char *)j_GetConfigValue(blockName, keyName, (const unsigned __int8 *)&byte_61CADE);
  if ( !*ConfigValue )
    return 0;
  *ret = strtol(ConfigValue, 0, 0);
  return 1;
}
// 61CADE: using guessed type char byte_61CADE;

//----- (00250D98) --------------------------------------------------------
int __fastcall ConfigValueUInt(const unsigned __int8 *blockName, const unsigned __int8 *keyName, unsigned int *ret)
{
  const char *ConfigValue; // r0

  ConfigValue = (const char *)j_GetConfigValue(blockName, keyName, (const unsigned __int8 *)&byte_61CADE);
  if ( !*ConfigValue )
    return 0;
  *ret = strtoul(ConfigValue, 0, 0);
  return 1;
}
// 61CADE: using guessed type char byte_61CADE;

//----- (00250DC0) --------------------------------------------------------
int __fastcall ConfigValueFloat(const unsigned __int8 *blockName, const unsigned __int8 *keyName, float *ret)
{
  const char *ConfigValue; // r0

  ConfigValue = (const char *)j_GetConfigValue(blockName, keyName, (const unsigned __int8 *)&byte_61CADE);
  if ( !*ConfigValue )
    return 0;
  *ret = strtof(ConfigValue, 0);
  return 1;
}
// 61CADE: using guessed type char byte_61CADE;

//----- (00250DE8) --------------------------------------------------------
int __fastcall GetConfigValueBool(const unsigned __int8 *blockName, const unsigned __int8 *keyName, int def)
{
  const char *ConfigValue; // r5

  ConfigValue = (const char *)j_GetConfigValue(blockName, keyName, (const unsigned __int8 *)&byte_61CADE);
  if ( !*ConfigValue )
    return def != 0;
  if ( strcasecmp(ConfigValue, "true")
    && strcasecmp(ConfigValue, (const char *)&dword_250E3C)
    && strcasecmp(ConfigValue, (const char *)&dword_250E40) )
  {
    def = atoi(ConfigValue);
    return def != 0;
  }
  return 1;
}
// 250E3C: using guessed type int dword_250E3C;
// 250E40: using guessed type int dword_250E40;
// 61CADE: using guessed type char byte_61CADE;

//----- (00250E44) --------------------------------------------------------
ALvoid __fastcall EchoDestroy(ALeffectState_0 *effect)
{
  if ( effect )
  {
    free(effect[1].Destroy);
    j_free(effect);
  }
}

//----- (00250E60) --------------------------------------------------------
ALboolean __fastcall EchoDeviceUpdate(ALeffectState_0 *effect, ALCdevice *Device)
{
  int v3; // r0
  int v4; // r5
  unsigned int v5; // r0
  unsigned int v6; // r0
  ALvoid (*v7)(ALeffectState *); // r0
  int v8; // r1
  ALboolean (*v9)(ALeffectState *, ALCdevice *); // r2

  v3 = (int)(float)((float)Device->Frequency * 0.404) + (int)(float)((float)Device->Frequency * 0.207);
  if ( v3 == -2 )
  {
    v4 = 1;
  }
  else
  {
    v5 = (v3 + 1) | ((unsigned int)(v3 + 1) >> 1) | (((v3 + 1) | ((unsigned int)(v3 + 1) >> 1)) >> 2);
    v6 = v5 | (v5 >> 4) | ((v5 | (v5 >> 4)) >> 8);
    v4 = (v6 | HIWORD(v6)) + 1;
  }
  if ( (ALboolean (*)(ALeffectState *, ALCdevice *))v4 != effect[1].DeviceUpdate )
  {
    v7 = (ALvoid (*)(ALeffectState *))realloc(effect[1].Destroy, 4 * v4);
    if ( !v7 )
      return 0;
    effect[1].Destroy = v7;
    effect[1].DeviceUpdate = (ALboolean (*)(ALeffectState *, ALCdevice *))v4;
  }
  if ( v4 )
  {
    v8 = 0;
    v9 = 0;
    do
    {
      v9 = (ALboolean (*)(ALeffectState *, ALCdevice *))((char *)v9 + 1);
      *(_DWORD *)((char *)effect[1].Destroy + v8) = 0;
      v8 += 4;
    }
    while ( (char *)v9 < (char *)effect[1].DeviceUpdate );
  }
  return 1;
}

//----- (00250EEC) --------------------------------------------------------
ALvoid __fastcall EchoUpdate(ALeffectState_0 *effect, ALCdevice *Device, const ALeffectslot_0 *Slot)
{
  float32x2_t v3; // d0
  float32x2_t v4; // d3
  float Frequency; // s0
  ALvoid (*v9)(ALeffectState *, ALCdevice *, const ALeffectslot *); // r4
  int v10; // s18
  float v11; // r0
  float Spread; // s18
  float v13; // s0
  float v14; // s0
  ALfloat Gain; // s20
  float v16; // r0
  ALfloat v17; // s0
  float v18; // r0

  Frequency = (float)Device->Frequency;
  v9 = (ALvoid (*)(ALeffectState *, ALCdevice *, const ALeffectslot *))((int)(float)(Slot->effect.Echo.Delay * Frequency)
                                                                      + 1);
  effect[1].Update = v9;
  v10 = (int)(float)(Slot->effect.Echo.LRDelay * Frequency);
  v11 = cosf(31416.0 / Frequency);
  effect[1].Process = (ALvoid (*)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]))((char *)v9 + v10);
  Spread = Slot->effect.Echo.Spread;
  effect[6].Process = (ALvoid (*)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]))LODWORD(Slot->effect.Echo.Feedback);
  v3.n64_f32[0] = 1.0 - Slot->effect.Echo.Damping;
  if ( v3.n64_f32[0] >= 0.9999 )
  {
    v14 = 0.0;
  }
  else
  {
    v4.n64_u32[0] = 981668463;
    v13 = vmax_f32(v3, v4).n64_f32[0];
    v14 = (float)((float)(1.0 - (float)(v11 * v13))
                - sqrtf(
                    (float)((float)(1.0 - v11) * (float)(v13 + v13))
                  - (float)((float)(1.0 - (float)(v11 * v11)) * (float)(v13 * v13))))
        / (float)(1.0 - v13);
  }
  *(float *)&effect[7].Destroy = v14;
  Gain = Slot->Gain;
  *(_QWORD *)&effect[4].Update = 0LL;
  *(_QWORD *)&effect[5].Destroy = 0LL;
  *(_QWORD *)&effect[3].DeviceUpdate = 0LL;
  *(_QWORD *)&effect[3].Process = 0LL;
  *(_QWORD *)&effect[2].DeviceUpdate = 0LL;
  *(_QWORD *)&effect[2].Process = 0LL;
  effect[4].DeviceUpdate = 0;
  effect[5].Update = 0;
  effect[5].Process = 0;
  effect[6].Destroy = 0;
  effect[6].DeviceUpdate = 0;
  effect[6].Update = 0;
  v16 = atan2f(COERCE_FLOAT(LODWORD(Spread) ^ 0x80000000), 0.0);
  v17 = (float)(1.0 - fabsf(Spread)) * 3.1416;
  j_ComputeAngleGains(Device, v16, v17, Gain, (int)&effect[2].DeviceUpdate);
  v18 = atan2f(Spread, 0.0);
  j_ComputeAngleGains(Device, v18, v17, Gain, (int)&effect[4].Update);
}
// 250F6E: variable 'v3' is possibly undefined
// 250F6E: variable 'v4' is possibly undefined

//----- (0025104C) --------------------------------------------------------
ALvoid __fastcall EchoProcess(
        ALeffectState_0 *effect,
        ALuint SamplesToDo,
        const ALfloat *SamplesIn,
        ALfloat (*SamplesOut)[2048])
{
  ALvoid (*Destroy)(ALeffectState *); // r5
  ALuint v5; // r10
  int v6; // r6
  ALvoid (*v7)(ALeffectState *); // r4
  ALvoid (*Process)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]); // s12
  float v9; // s4
  float v10; // s10
  float *v11; // r2
  float *v12; // r8
  ALboolean (*DeviceUpdate)(ALeffectState *, ALCdevice *); // s0
  float *v14; // r12
  float v15; // s6
  float *v16; // r1
  float v17; // s7
  float *v18; // r11
  float *v19; // r3
  ALvoid (*v20)(ALeffectState *); // s14
  ALboolean (*v21)(ALeffectState *, ALCdevice *); // s1
  ALvoid (*Update)(ALeffectState *, ALCdevice *, const ALeffectslot *); // s3
  float v23; // s8
  float v24; // s11
  float v25; // s5
  float v26; // s13
  float v27; // s20
  float v28; // s15
  float v29; // s16
  float v30; // s7
  float v31; // s18
  float v32; // s2
  float *v33; // r1
  ALvoid (*v34)(ALeffectState *); // s4
  float v35; // s0
  ALvoid (*v36)(ALeffectState *); // r1
  float v37; // s0
  float v38; // s2
  ALvoid (*v39)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]); // s4
  float v40; // s2
  int v41; // r2
  ALvoid (*v43)(ALeffectState *); // [sp+4h] [bp-54h]
  int v44; // [sp+8h] [bp-50h]
  int v45; // [sp+Ch] [bp-4Ch]
  ALfloat (*v47)[2048]; // [sp+14h] [bp-44h]
  unsigned int v48; // [sp+1Ch] [bp-3Ch]

  Destroy = effect[2].Destroy;
  if ( SamplesToDo )
  {
    v5 = SamplesToDo;
    v48 = (unsigned int)effect[1].DeviceUpdate - 1;
    v45 = -(int)effect[1].Process;
    v44 = -(int)effect[1].Update;
    v6 = 0;
    v43 = effect[2].Destroy;
    v47 = SamplesOut;
    do
    {
      --v5;
      v7 = effect[1].Destroy;
      Process = effect[2].Process;
      v9 = *((float *)v7 + (((unsigned int)Destroy + v44) & v48));
      v10 = v9 * *(float *)&effect[2].Update;
      v11 = &(*SamplesOut)[v6];
      v12 = &(*SamplesOut)[v6 + 4096];
      DeviceUpdate = effect[4].DeviceUpdate;
      v14 = &(*SamplesOut)[v6 + 10240];
      v15 = *((float *)v7 + (((unsigned int)Destroy + v45) & v48));
      v16 = &(*SamplesOut)[v6 + 0x4000];
      v17 = (*SamplesOut)[v6] + (float)(v9 * *(float *)&effect[2].DeviceUpdate);
      v18 = &(*SamplesOut)[v6 + 14336];
      v19 = &(*SamplesOut)[v6 + 0x2000];
      v20 = effect[3].Destroy;
      v21 = effect[3].DeviceUpdate;
      Update = effect[3].Update;
      v23 = v9 * *(float *)&effect[3].Process;
      v24 = *v16;
      v25 = v17 + (float)(v15 * *(float *)&effect[4].Update);
      v26 = v11[12288];
      v27 = v11[2048];
      v28 = *v14;
      v29 = *v19;
      v30 = v11[6144];
      v31 = *v12;
      v32 = *v18 + (float)(v9 * *(float *)&effect[4].Destroy);
      *v11 = v25;
      v11[2048] = (float)(v27 + v10) + (float)(v15 * *(float *)&effect[4].Process);
      *v12 = (float)(v31 + (float)(v9 * *(float *)&Process)) + (float)(v15 * *(float *)&effect[5].Destroy);
      v11[6144] = (float)(v30 + (float)(v9 * *(float *)&v20)) + (float)(v15 * *(float *)&effect[5].DeviceUpdate);
      *v19 = (float)(v29 + (float)(v9 * *(float *)&v21)) + (float)(v15 * *(float *)&effect[5].Update);
      *v14 = (float)(v28 + (float)(v9 * *(float *)&Update)) + (float)(v15 * *(float *)&effect[5].Process);
      SamplesOut = v47;
      v11[12288] = (float)(v26 + v23) + (float)(v15 * *(float *)&effect[6].Destroy);
      *v18 = v32 + (float)(v15 * *(float *)&effect[6].DeviceUpdate);
      *v16 = (float)(v24 + (float)(v9 * *(float *)&DeviceUpdate)) + (float)(v15 * *(float *)&effect[6].Update);
      v33 = (float *)&SamplesIn[v6++];
      v34 = effect[7].Destroy;
      v35 = v15 + *v33;
      v36 = effect[1].Destroy;
      v37 = v35 + (float)(*(float *)&v34 * (float)(*(float *)&effect[7].DeviceUpdate - v35));
      v38 = *(float *)&v34 * (float)(*(float *)&effect[7].Update - v37);
      v39 = effect[6].Process;
      *(float *)&effect[7].DeviceUpdate = v37;
      v40 = v37 + v38;
      *(float *)&effect[7].Update = v40;
      v41 = v48 & (unsigned int)Destroy;
      Destroy = (ALvoid (*)(ALeffectState *))((char *)Destroy + 1);
      *((float *)v36 + v41) = *(float *)&v39 * v40;
    }
    while ( v5 );
    Destroy = (ALvoid (*)(ALeffectState *))((char *)v43 + SamplesToDo);
  }
  effect[2].Destroy = Destroy;
}

//----- (00251272) --------------------------------------------------------
ALboolean __fastcall ModulatorDeviceUpdate(ALeffectState_0 *effect, ALCdevice *Device)
{
  return 1;
}

//----- (00251278) --------------------------------------------------------
ALvoid __fastcall ModulatorUpdate(ALeffectState_0 *effect, ALCdevice *Device, const ALeffectslot_0 *Slot)
{
  ALvoid (*Waveform)(ALeffectState *); // r0
  int v7; // r0
  float v8; // r0
  float NumChan; // s0
  float Gain; // s2
  ALuint v11; // r2
  float v12; // s0
  Channel v13; // r3

  Waveform = (ALvoid (*)(ALeffectState *))Slot->effect.Modulator.Waveform;
  if ( (unsigned int)Waveform <= 2 )
    effect[1].Destroy = Waveform;
  v7 = (int)(float)((float)(Slot->effect.Modulator.Frequency * 65536.0) / (float)Device->Frequency);
  if ( !v7 )
    v7 = 1;
  effect[1].Update = (ALvoid (*)(ALeffectState *, ALCdevice *, const ALeffectslot *))v7;
  v8 = cosf((float)(Slot->effect.Modulator.HighPassCutoff * 6.2832) / (float)Device->Frequency);
  *(float *)&effect[4].Destroy = (float)(2.0 - v8) - sqrtf((float)((float)(2.0 - v8) * (float)(2.0 - v8)) + -1.0);
  NumChan = (float)Device->NumChan;
  Gain = Slot->Gain;
  *(_QWORD *)&effect[2].Process = 0LL;
  *(_QWORD *)&effect[3].DeviceUpdate = 0LL;
  *(_QWORD *)&effect[1].Process = 0LL;
  *(_QWORD *)&effect[2].DeviceUpdate = 0LL;
  effect[3].Process = 0;
  if ( Device->NumChan )
  {
    v11 = 0;
    v12 = Gain * sqrtf(1.0 / NumChan);
    do
    {
      v13 = Device->Speaker2Chan[v11++];
      *((float *)&effect[1].Process + v13) = v12;
    }
    while ( v11 < Device->NumChan );
  }
}

//----- (00251364) --------------------------------------------------------
ALvoid __fastcall ModulatorProcess(
        ALeffectState_0 *effect,
        ALuint SamplesToDo,
        const ALfloat *SamplesIn,
        ALfloat (*SamplesOut)[2048])
{
  ALvoid (*Destroy)(ALeffectState *); // r1
  ALboolean (*v8)(ALeffectState *, ALCdevice *); // r8
  int v9; // r6
  ALvoid (*v10)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]); // s16
  ALvoid (*v11)(ALeffectState *); // s18
  ALboolean (*v12)(ALeffectState *, ALCdevice *); // s20
  ALvoid (*v13)(ALeffectState *, ALCdevice *, const ALeffectslot *); // s22
  ALvoid (*v14)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]); // s24
  ALvoid (*v15)(ALeffectState *); // s26
  ALboolean (*v16)(ALeffectState *, ALCdevice *); // s28
  ALvoid (*v17)(ALeffectState *, ALCdevice *, const ALeffectslot *); // s30
  ALvoid (*v18)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]); // s17
  ALvoid (*v19)(ALeffectState *); // s19
  float v20; // s21
  float v21; // s25
  float v22; // s0
  float *v23; // r0
  float *v24; // r2
  float *v25; // r1
  float v26; // s0
  float v27; // s8
  float *v28; // r3
  float *v29; // r5
  float *v30; // r4
  float v31; // s0
  float v32; // s4
  float v33; // s6
  float *v34; // r1
  float *v35; // r2
  float v36; // s2
  float v37; // s4
  float v38; // s8
  float v39; // s10
  float v40; // s6
  float v41; // s0
  ALboolean (*DeviceUpdate)(ALeffectState *, ALCdevice *); // r2
  ALvoid (*Update)(ALeffectState *, ALCdevice *, const ALeffectslot *); // r12
  ALvoid (*Process)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]); // s0
  ALeffectState_0 *v45; // r8
  ALvoid (*v46)(ALeffectState *); // s2
  int v47; // r1
  ALboolean (*v48)(ALeffectState *, ALCdevice *); // s4
  ALvoid (*v49)(ALeffectState *, ALCdevice *, const ALeffectslot *); // s6
  ALvoid (*v50)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]); // s8
  ALvoid (*v51)(ALeffectState *); // s10
  ALboolean (*v52)(ALeffectState *, ALCdevice *); // s12
  ALvoid (*v53)(ALeffectState *, ALCdevice *, const ALeffectslot *); // s14
  ALvoid (*v54)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]); // s1
  ALvoid (*v55)(ALeffectState *); // s3
  float v56; // s5
  unsigned __int16 v57; // lr
  float v58; // s9
  float v59; // s11
  float *v60; // r3
  float *v61; // r4
  float *v62; // r0
  float *v63; // r2
  float v64; // s9
  float v65; // s9
  float v66; // s13
  float v67; // s15
  float *v68; // r6
  float *v69; // r5
  float v70; // s11
  float v71; // s13
  float v72; // s15
  float v73; // s16
  float v74; // s18
  float v75; // s9
  ALboolean (*v76)(ALeffectState *, ALCdevice *); // lr
  ALvoid (*v77)(ALeffectState *, ALCdevice *, const ALeffectslot *); // r12
  ALvoid (*v78)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]); // s0
  ALeffectState_0 *v79; // r8
  ALvoid (*v80)(ALeffectState *); // s2
  int v81; // r2
  ALboolean (*v82)(ALeffectState *, ALCdevice *); // s4
  ALvoid (*v83)(ALeffectState *, ALCdevice *, const ALeffectslot *); // s6
  ALvoid (*v84)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]); // s8
  ALvoid (*v85)(ALeffectState *); // s10
  ALboolean (*v86)(ALeffectState *, ALCdevice *); // s12
  ALvoid (*v87)(ALeffectState *, ALCdevice *, const ALeffectslot *); // s14
  ALvoid (*v88)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]); // s1
  ALvoid (*v89)(ALeffectState *); // s3
  float v90; // s5
  float v91; // s13
  float *v92; // r3
  float *v93; // r4
  float *v94; // r1
  float *v95; // r0
  float v96; // s11
  float v97; // s11
  float v98; // s15
  float v99; // s16
  float *v100; // r6
  float *v101; // r5
  float v102; // s13
  float v103; // s15
  float v104; // s18
  float v105; // s20
  float v106; // s16
  float v107; // s11
  ALeffectState_0 *v108; // [sp+0h] [bp-68h]
  ALvoid (*v109)(ALeffectState *, ALCdevice *, const ALeffectslot *); // [sp+4h] [bp-64h]

  Destroy = effect[1].Destroy;
  if ( Destroy == (ALvoid (*)(ALeffectState *))((char *)&dword_0 + 2) )
  {
    DeviceUpdate = effect[1].DeviceUpdate;
    if ( SamplesToDo )
    {
      Update = effect[1].Update;
      Process = effect[1].Process;
      v45 = effect;
      v46 = effect[2].Destroy;
      v47 = 0;
      v48 = effect[2].DeviceUpdate;
      v49 = effect[2].Update;
      v50 = effect[2].Process;
      v51 = effect[3].Destroy;
      v52 = effect[3].DeviceUpdate;
      v53 = effect[3].Update;
      v54 = effect[3].Process;
      v55 = effect[4].Destroy;
      v56 = *(float *)&effect[4].DeviceUpdate;
      do
      {
        v57 = (_WORD)DeviceUpdate + (_WORD)Update;
        --SamplesToDo;
        v58 = (float)((((unsigned int)Update + (unsigned int)DeviceUpdate) >> 15) & 1);
        v59 = SamplesIn[v47];
        v60 = &(*SamplesOut)[v47++];
        v61 = v60 + 12288;
        v62 = v60 + 10240;
        v63 = v60 + 0x2000;
        v64 = v59 * (float)((float)(v58 + v58) + -1.0);
        v56 = v64 + (float)(*(float *)&v55 * (float)(v56 - v64));
        v65 = v64 - v56;
        v66 = v60[2048] + (float)(*(float *)&v46 * v65);
        v67 = v60[4096] + (float)(*(float *)&v48 * v65);
        *v60 = *v60 + (float)(*(float *)&Process * v65);
        v60[2048] = v66;
        v60[4096] = v67;
        v68 = v60 + 0x4000;
        v69 = v60 + 14336;
        v60 += 6144;
        v70 = *v60 + (float)(*(float *)&v49 * v65);
        v71 = *v63 + (float)(*(float *)&v50 * v65);
        v72 = *v62 + (float)(*(float *)&v51 * v65);
        v73 = (float)(*(float *)&v52 * v65) + *v61;
        v74 = (float)(*(float *)&v53 * v65) + *v69;
        v75 = (float)(*(float *)&v54 * v65) + *v68;
        *v60 = v70;
        *v63 = v71;
        DeviceUpdate = (ALboolean (*)(ALeffectState *, ALCdevice *))v57;
        *v62 = v72;
        *v61 = v73;
        *v69 = v74;
        *v68 = v75;
      }
      while ( SamplesToDo );
      effect = v45;
      *(float *)&v45[4].DeviceUpdate = v56;
    }
    effect[1].DeviceUpdate = DeviceUpdate;
  }
  else if ( Destroy == (ALvoid (*)(ALeffectState *))((char *)&dword_0 + 1) )
  {
    v76 = effect[1].DeviceUpdate;
    if ( SamplesToDo )
    {
      v77 = effect[1].Update;
      v78 = effect[1].Process;
      v79 = effect;
      v80 = effect[2].Destroy;
      v81 = 0;
      v82 = effect[2].DeviceUpdate;
      v83 = effect[2].Update;
      v84 = effect[2].Process;
      v85 = effect[3].Destroy;
      v86 = effect[3].DeviceUpdate;
      v87 = effect[3].Update;
      v88 = effect[3].Process;
      v89 = effect[4].Destroy;
      v90 = *(float *)&effect[4].DeviceUpdate;
      do
      {
        --SamplesToDo;
        v76 = (ALboolean (*)(ALeffectState *, ALCdevice *))(unsigned __int16)((_WORD)v76 + (_WORD)v77);
        v91 = SamplesIn[v81];
        v92 = &(*SamplesOut)[v81++];
        v93 = v92 + 12288;
        v94 = v92 + 10240;
        v95 = v92 + 0x2000;
        v96 = v91 * (float)((float)((float)(unsigned int)v76 * 0.000030518) + -1.0);
        v90 = v96 + (float)(*(float *)&v89 * (float)(v90 - v96));
        v97 = v96 - v90;
        v98 = v92[2048] + (float)(*(float *)&v80 * v97);
        v99 = v92[4096] + (float)(*(float *)&v82 * v97);
        *v92 = *v92 + (float)(*(float *)&v78 * v97);
        v92[2048] = v98;
        v92[4096] = v99;
        v100 = v92 + 0x4000;
        v101 = v92 + 14336;
        v92 += 6144;
        v102 = *v92 + (float)(*(float *)&v83 * v97);
        v103 = *v95 + (float)(*(float *)&v84 * v97);
        v104 = (float)(*(float *)&v86 * v97) + *v93;
        v105 = (float)(*(float *)&v87 * v97) + *v101;
        v106 = (float)(*(float *)&v85 * v97) + *v94;
        v107 = (float)(*(float *)&v88 * v97) + *v100;
        *v92 = v102;
        *v95 = v103;
        *v94 = v106;
        *v93 = v104;
        *v101 = v105;
        *v100 = v107;
      }
      while ( SamplesToDo );
      effect = v79;
      *(float *)&v79[4].DeviceUpdate = v90;
    }
    effect[1].DeviceUpdate = v76;
  }
  else if ( !Destroy )
  {
    v8 = effect[1].DeviceUpdate;
    if ( SamplesToDo )
    {
      v9 = 0;
      v109 = effect[1].Update;
      v10 = effect[1].Process;
      v11 = effect[2].Destroy;
      v12 = effect[2].DeviceUpdate;
      v13 = effect[2].Update;
      v14 = effect[2].Process;
      v15 = effect[3].Destroy;
      v16 = effect[3].DeviceUpdate;
      v17 = effect[3].Update;
      v18 = effect[3].Process;
      v19 = effect[4].Destroy;
      v108 = effect;
      v20 = *(float *)&effect[4].DeviceUpdate;
      do
      {
        v8 = (ALboolean (*)(ALeffectState *, ALCdevice *))(unsigned __int16)((_WORD)v109 + (_WORD)v8);
        v21 = SamplesIn[v9];
        v22 = sinf((float)(unsigned int)v8 * 0.000095874);
        v23 = &(*SamplesOut)[v9];
        v24 = &(*SamplesOut)[v9 + 2048];
        v25 = &(*SamplesOut)[v9 + 4096];
        v26 = v21 * v22;
        v27 = (*SamplesOut)[v9];
        v28 = &(*SamplesOut)[v9 + 12288];
        v29 = &(*SamplesOut)[v9 + 10240];
        v30 = &(*SamplesOut)[v9 + 0x2000];
        ++v9;
        --SamplesToDo;
        v20 = v26 + (float)(*(float *)&v19 * (float)(v20 - v26));
        v31 = v26 - v20;
        v32 = *v24 + (float)(*(float *)&v11 * v31);
        v33 = *v25 + (float)(*(float *)&v12 * v31);
        *v23 = v27 + (float)(*(float *)&v10 * v31);
        *v24 = v32;
        *v25 = v33;
        v34 = v23 + 0x4000;
        v35 = v23 + 14336;
        v23 += 6144;
        v36 = (float)(*(float *)&v13 * v31) + *v23;
        v37 = (float)(*(float *)&v14 * v31) + *v30;
        v38 = (float)(*(float *)&v16 * v31) + *v28;
        v39 = (float)(*(float *)&v17 * v31) + *v35;
        v40 = (float)(*(float *)&v15 * v31) + *v29;
        v41 = (float)(*(float *)&v18 * v31) + *v34;
        *v23 = v36;
        *v30 = v37;
        *v29 = v40;
        *v28 = v38;
        *v35 = v39;
        *v34 = v41;
      }
      while ( SamplesToDo );
      effect = v108;
      *(float *)&v108[4].DeviceUpdate = v20;
    }
    effect[1].DeviceUpdate = v8;
  }
}
// 0: using guessed type int dword_0;

//----- (00251774) --------------------------------------------------------
ALvoid __fastcall ReverbDestroy(ALeffectState_0 *effect)
{
  if ( effect )
  {
    free(effect[1].Destroy);
    j_free(effect);
  }
}

//----- (00251790) --------------------------------------------------------
ALboolean __fastcall ReverbDeviceUpdate(ALeffectState_0 *effect, ALCdevice *Device)
{
  float Frequency; // s16
  unsigned int v4; // r0
  unsigned int v5; // r0
  unsigned int v6; // r0
  ALboolean (*v7)(ALeffectState *, ALCdevice *); // lr
  unsigned int v8; // r0
  unsigned int v9; // r0
  unsigned int v10; // r0
  int v11; // r0
  ALvoid (*v12)(ALeffectState *, ALCdevice *, const ALeffectslot *); // r9
  unsigned int v13; // r1
  unsigned int v14; // r0
  unsigned int v15; // r0
  int v16; // r0
  ALvoid (*v17)(ALeffectState *); // r10
  unsigned int v18; // r1
  unsigned int v19; // r0
  unsigned int v20; // r0
  int v21; // r0
  ALvoid (*v22)(ALeffectState *, ALCdevice *, const ALeffectslot *); // r3
  unsigned int v23; // r1
  unsigned int v24; // r0
  unsigned int v25; // r0
  int v26; // r0
  ALvoid (*v27)(ALeffectState *); // r2
  unsigned int v28; // r1
  unsigned int v29; // r0
  unsigned int v30; // r0
  int v31; // r0
  ALvoid (*v32)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]); // r8
  unsigned int v33; // r0
  unsigned int v34; // r0
  unsigned int v35; // r0
  int v36; // r0
  ALvoid (*v37)(ALeffectState *); // r12
  unsigned int v38; // r1
  unsigned int v39; // r0
  unsigned int v40; // r0
  int v41; // r0
  ALvoid (*v42)(ALeffectState *, ALCdevice *, const ALeffectslot *); // r3
  unsigned int v43; // r1
  unsigned int v44; // r0
  unsigned int v45; // r0
  int v46; // r0
  ALvoid (*v47)(ALeffectState *); // r2
  unsigned int v48; // r1
  unsigned int v49; // r0
  unsigned int v50; // r0
  int v51; // r0
  unsigned int v52; // r1
  unsigned int v53; // r0
  unsigned int v54; // r0
  int v55; // r0
  ALvoid (*v56)(ALeffectState *); // r5
  unsigned int v57; // r0
  unsigned int v58; // r0
  unsigned int v59; // r0
  int v60; // r0
  ALvoid (*v61)(ALeffectState *, ALCdevice *, const ALeffectslot *); // r6
  unsigned int v62; // r0
  unsigned int v63; // r0
  unsigned int v64; // r0
  int v65; // r0
  ALvoid (*v66)(ALeffectState *); // lr
  unsigned int v67; // r0
  unsigned int v68; // r0
  unsigned int v69; // r0
  int v70; // r0
  ALvoid (*v71)(ALeffectState *, ALCdevice *, const ALeffectslot *); // r2
  unsigned int v72; // r0
  unsigned int v73; // r0
  unsigned int v74; // r0
  int v75; // r0
  ALvoid (*v76)(ALeffectState *); // r3
  unsigned int v77; // r11
  unsigned int v78; // r0
  unsigned int v79; // r0
  int v80; // r0
  ALvoid (*v81)(ALeffectState *, ALCdevice *, const ALeffectslot *); // r9
  unsigned int v82; // r0
  unsigned int v83; // r0
  unsigned int v84; // r0
  int v85; // r0
  ALboolean (*v86)(ALeffectState *, ALCdevice *); // r5
  ALvoid (*Destroy)(ALeffectState *); // r0
  ALvoid (*v88)(ALeffectState *); // r1
  ALvoid (*Process)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]); // r6
  ALboolean (*DeviceUpdate)(ALeffectState *, ALCdevice *); // r11
  ALvoid (*v91)(ALeffectState *, ALCdevice *, const ALeffectslot *); // r8
  ALvoid (*v92)(ALeffectState *); // r10
  ALvoid (*v93)(ALeffectState *, ALCdevice *, const ALeffectslot *); // r12
  ALboolean (*v94)(ALeffectState *, ALCdevice *); // r0
  int v95; // r2
  ALvoid (*v97)(ALeffectState *, ALCdevice *, const ALeffectslot *); // [sp+8h] [bp-78h]
  ALvoid (*v98)(ALeffectState *); // [sp+Ch] [bp-74h]
  ALvoid (*v99)(ALeffectState *, ALCdevice *, const ALeffectslot *); // [sp+10h] [bp-70h]
  ALboolean (*v100)(ALeffectState *, ALCdevice *); // [sp+14h] [bp-6Ch]
  ALvoid (*Update)(ALeffectState *, ALCdevice *, const ALeffectslot *); // [sp+18h] [bp-68h]
  ALboolean (*v102)(ALeffectState *, ALCdevice *); // [sp+1Ch] [bp-64h]
  ALvoid (*v103)(ALeffectState *, ALCdevice *, const ALeffectslot *); // [sp+20h] [bp-60h]
  ALboolean (*v104)(ALeffectState *, ALCdevice *); // [sp+24h] [bp-5Ch]
  ALvoid (*v105)(ALeffectState *); // [sp+28h] [bp-58h]
  ALvoid (*v106)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]); // [sp+2Ch] [bp-54h]
  ALvoid (*v107)(ALeffectState *); // [sp+30h] [bp-50h]
  ALvoid (*v108)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]); // [sp+34h] [bp-4Ch]
  ALvoid (*v109)(ALeffectState *, ALCdevice *, const ALeffectslot *); // [sp+38h] [bp-48h]
  ALboolean (*v110)(ALeffectState *, ALCdevice *); // [sp+3Ch] [bp-44h]
  ALvoid (*v111)(ALeffectState *, ALCdevice *, const ALeffectslot *); // [sp+40h] [bp-40h]
  ALvoid (*v112)(ALeffectState *); // [sp+44h] [bp-3Ch]
  ALvoid (*v113)(ALeffectState *); // [sp+48h] [bp-38h]
  ALvoid (*v114)(ALeffectState *); // [sp+4Ch] [bp-34h]
  ALvoid (*v115)(ALeffectState *, ALCdevice *, const ALeffectslot *); // [sp+50h] [bp-30h]
  ALvoid (*v116)(ALeffectState *, ALCdevice *, const ALeffectslot *); // [sp+54h] [bp-2Ch]

  Frequency = (float)Device->Frequency;
  v4 = (int)(float)((float)((float)(1.0 / Frequency) + 0.2) * Frequency);
  if ( v4 == -1 )
  {
    v7 = (ALboolean (*)(ALeffectState *, ALCdevice *))(&dword_0 + 1);
  }
  else
  {
    v5 = v4 | (v4 >> 1) | ((v4 | (v4 >> 1)) >> 2);
    v6 = v5 | (v5 >> 4) | ((v5 | (v5 >> 4)) >> 8);
    v7 = (ALboolean (*)(ALeffectState *, ALCdevice *))((v6 | HIWORD(v6)) + 1);
  }
  effect[2].Update = 0;
  effect[2].DeviceUpdate = (ALboolean (*)(ALeffectState *, ALCdevice *))((char *)v7 - 1);
  v8 = (int)(float)(Frequency * 0.4);
  if ( v8 == -1 )
  {
    v11 = 1;
  }
  else
  {
    v9 = v8 | (v8 >> 1) | ((v8 | (v8 >> 1)) >> 2);
    v10 = v9 | (v9 >> 4) | ((v9 | (v9 >> 4)) >> 8);
    v11 = (v10 | HIWORD(v10)) + 1;
  }
  effect[4].DeviceUpdate = v7;
  v12 = (ALvoid (*)(ALeffectState *, ALCdevice *, const ALeffectslot *))((char *)v7 + v11);
  effect[4].Destroy = (ALvoid (*)(ALeffectState *))(v11 - 1);
  v13 = (int)(float)(Frequency * 0.0015);
  v110 = (ALboolean (*)(ALeffectState *, ALCdevice *))v13;
  if ( v13 == -1 )
  {
    v16 = 1;
  }
  else
  {
    v14 = v13 | (v13 >> 1) | ((v13 | (v13 >> 1)) >> 2);
    v15 = v14 | (v14 >> 4) | ((v14 | (v14 >> 4)) >> 8);
    v16 = (v15 | HIWORD(v15)) + 1;
  }
  effect[6].Update = v12;
  v17 = (ALvoid (*)(ALeffectState *))((char *)v12 + v16);
  effect[6].DeviceUpdate = (ALboolean (*)(ALeffectState *, ALCdevice *))(v16 - 1);
  v18 = (int)(float)(Frequency * 0.0045);
  v109 = (ALvoid (*)(ALeffectState *, ALCdevice *, const ALeffectslot *))v18;
  if ( v18 == -1 )
  {
    v21 = 1;
  }
  else
  {
    v19 = v18 | (v18 >> 1) | ((v18 | (v18 >> 1)) >> 2);
    v20 = v19 | (v19 >> 4) | ((v19 | (v19 >> 4)) >> 8);
    v21 = (v20 | HIWORD(v20)) + 1;
  }
  effect[7].Destroy = v17;
  v22 = (ALvoid (*)(ALeffectState *, ALCdevice *, const ALeffectslot *))((char *)v17 + v21);
  effect[6].Process = (ALvoid (*)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]))(v21 - 1);
  v23 = (int)(float)(Frequency * 0.0135);
  v108 = (ALvoid (*)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]))v23;
  if ( v23 == -1 )
  {
    v26 = 1;
  }
  else
  {
    v24 = v23 | (v23 >> 1) | ((v23 | (v23 >> 1)) >> 2);
    v25 = v24 | (v24 >> 4) | ((v24 | (v24 >> 4)) >> 8);
    v26 = (v25 | HIWORD(v25)) + 1;
  }
  effect[7].Update = v22;
  v27 = (ALvoid (*)(ALeffectState *))((char *)v22 + v26);
  effect[7].DeviceUpdate = (ALboolean (*)(ALeffectState *, ALCdevice *))(v26 - 1);
  v28 = (int)(float)(Frequency * 0.0405);
  v107 = (ALvoid (*)(ALeffectState *))v28;
  if ( v28 == -1 )
  {
    v31 = 1;
  }
  else
  {
    v29 = v28 | (v28 >> 1) | ((v28 | (v28 >> 1)) >> 2);
    v30 = v29 | (v29 >> 4) | ((v29 | (v29 >> 4)) >> 8);
    v31 = (v30 | HIWORD(v30)) + 1;
  }
  effect[8].Destroy = v27;
  v32 = (ALvoid (*)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]))((char *)v27 + v31);
  effect[7].Process = (ALvoid (*)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]))(v31 - 1);
  v33 = (int)(float)(Frequency * 0.0633);
  if ( v33 == -1 )
  {
    v36 = 1;
  }
  else
  {
    v34 = v33 | (v33 >> 1) | ((v33 | (v33 >> 1)) >> 2);
    v35 = v34 | (v34 >> 4) | ((v34 | (v34 >> 4)) >> 8);
    v36 = (v35 | HIWORD(v35)) + 1;
  }
  effect[11].Process = v32;
  v37 = (ALvoid (*)(ALeffectState *))((char *)v32 + v36);
  effect[11].Update = (ALvoid (*)(ALeffectState *, ALCdevice *, const ALeffectslot *))(v36 - 1);
  v111 = v22;
  v38 = (int)(float)(Frequency * 0.0151);
  v106 = (ALvoid (*)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]))v38;
  if ( v38 == -1 )
  {
    v41 = 1;
  }
  else
  {
    v39 = v38 | (v38 >> 1) | ((v38 | (v38 >> 1)) >> 2);
    v40 = v39 | (v39 >> 4) | ((v39 | (v39 >> 4)) >> 8);
    v41 = (v40 | HIWORD(v40)) + 1;
  }
  effect[15].Destroy = v37;
  v42 = (ALvoid (*)(ALeffectState *, ALCdevice *, const ALeffectslot *))((char *)v37 + v41);
  effect[14].Process = (ALvoid (*)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]))(v41 - 1);
  v112 = v27;
  v43 = (int)(float)(Frequency * 0.0167);
  v105 = (ALvoid (*)(ALeffectState *))v43;
  if ( v43 == -1 )
  {
    v46 = 1;
  }
  else
  {
    v44 = v43 | (v43 >> 1) | ((v43 | (v43 >> 1)) >> 2);
    v45 = v44 | (v44 >> 4) | ((v44 | (v44 >> 4)) >> 8);
    v46 = (v45 | HIWORD(v45)) + 1;
  }
  effect[15].Update = v42;
  v47 = (ALvoid (*)(ALeffectState *))((char *)v42 + v46);
  effect[15].DeviceUpdate = (ALboolean (*)(ALeffectState *, ALCdevice *))(v46 - 1);
  v48 = (int)(float)(Frequency * 0.0183);
  v104 = (ALboolean (*)(ALeffectState *, ALCdevice *))v48;
  if ( v48 == -1 )
  {
    v51 = 1;
  }
  else
  {
    v49 = v48 | (v48 >> 1) | ((v48 | (v48 >> 1)) >> 2);
    v50 = v49 | (v49 >> 4) | ((v49 | (v49 >> 4)) >> 8);
    v51 = (v50 | HIWORD(v50)) + 1;
  }
  effect[16].Destroy = v47;
  effect[15].Process = (ALvoid (*)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]))(v51 - 1);
  v116 = (ALvoid (*)(ALeffectState *, ALCdevice *, const ALeffectslot *))((char *)v47 + v51);
  v52 = (int)(float)(Frequency * 0.02);
  v103 = (ALvoid (*)(ALeffectState *, ALCdevice *, const ALeffectslot *))v52;
  if ( v52 == -1 )
  {
    v55 = 1;
  }
  else
  {
    v53 = v52 | (v52 >> 1) | ((v52 | (v52 >> 1)) >> 2);
    v54 = v53 | (v53 >> 4) | ((v53 | (v53 >> 4)) >> 8);
    v55 = (v54 | HIWORD(v54)) + 1;
  }
  effect[16].Update = v116;
  v56 = (ALvoid (*)(ALeffectState *))((char *)v116 + v55);
  effect[16].DeviceUpdate = (ALboolean (*)(ALeffectState *, ALCdevice *))(v55 - 1);
  v57 = (int)(float)(Frequency * 0.1055);
  if ( v57 == -1 )
  {
    v60 = 1;
  }
  else
  {
    v58 = v57 | (v57 >> 1) | ((v57 | (v57 >> 1)) >> 2);
    v59 = v58 | (v58 >> 4) | ((v58 | (v58 >> 4)) >> 8);
    v60 = (v59 | HIWORD(v59)) + 1;
  }
  effect[19].Destroy = v56;
  v61 = (ALvoid (*)(ALeffectState *, ALCdevice *, const ALeffectslot *))((char *)v56 + v60);
  effect[18].Process = (ALvoid (*)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]))(v60 - 1);
  v99 = v42;
  v100 = v7;
  v113 = v47;
  v114 = v17;
  v62 = (int)(float)(Frequency * 0.1555);
  if ( v62 == -1 )
  {
    v65 = 1;
  }
  else
  {
    v63 = v62 | (v62 >> 1) | ((v62 | (v62 >> 1)) >> 2);
    v64 = v63 | (v63 >> 4) | ((v63 | (v63 >> 4)) >> 8);
    v65 = (v64 | HIWORD(v64)) + 1;
  }
  effect[19].Update = v61;
  v66 = (ALvoid (*)(ALeffectState *))((char *)v61 + v65);
  effect[19].DeviceUpdate = (ALboolean (*)(ALeffectState *, ALCdevice *))(v65 - 1);
  v115 = v12;
  v67 = (int)(float)(Frequency * 0.2305);
  if ( v67 == -1 )
  {
    v70 = 1;
  }
  else
  {
    v68 = v67 | (v67 >> 1) | ((v67 | (v67 >> 1)) >> 2);
    v69 = v68 | (v68 >> 4) | ((v68 | (v68 >> 4)) >> 8);
    v70 = (v69 | HIWORD(v69)) + 1;
  }
  effect[20].Destroy = v66;
  effect[19].Process = (ALvoid (*)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]))(v70 - 1);
  v71 = (ALvoid (*)(ALeffectState *, ALCdevice *, const ALeffectslot *))((char *)v66 + v70);
  v97 = v61;
  v98 = v56;
  v72 = (int)(float)(Frequency * 0.34);
  if ( v72 == -1 )
  {
    v75 = 1;
  }
  else
  {
    v73 = v72 | (v72 >> 1) | ((v72 | (v72 >> 1)) >> 2);
    v74 = v73 | (v73 >> 4) | ((v73 | (v73 >> 4)) >> 8);
    v75 = (v74 | HIWORD(v74)) + 1;
  }
  effect[20].Update = v71;
  effect[20].DeviceUpdate = (ALboolean (*)(ALeffectState *, ALCdevice *))(v75 - 1);
  v76 = (ALvoid (*)(ALeffectState *))((char *)v71 + v75);
  v77 = (int)(float)(Frequency * 0.0133);
  if ( v77 == -1 )
  {
    v80 = 1;
  }
  else
  {
    v78 = v77 | (v77 >> 1) | ((v77 | (v77 >> 1)) >> 2);
    v79 = v78 | (v78 >> 4) | ((v78 | (v78 >> 4)) >> 8);
    v80 = (v79 | HIWORD(v79)) + 1;
  }
  effect[27].Destroy = v76;
  v81 = (ALvoid (*)(ALeffectState *, ALCdevice *, const ALeffectslot *))((char *)v76 + v80);
  effect[26].Process = (ALvoid (*)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]))(v80 - 1);
  v82 = (int)(float)(Frequency * 0.25);
  if ( v82 == -1 )
  {
    v85 = 1;
  }
  else
  {
    v83 = v82 | (v82 >> 1) | ((v82 | (v82 >> 1)) >> 2);
    v84 = v83 | (v83 >> 4) | ((v83 | (v83 >> 4)) >> 8);
    v85 = (v84 | HIWORD(v84)) + 1;
  }
  effect[26].DeviceUpdate = (ALboolean (*)(ALeffectState *, ALCdevice *))(v85 - 1);
  effect[26].Update = v81;
  v86 = (ALboolean (*)(ALeffectState *, ALCdevice *))((char *)v81 + v85);
  if ( (char *)v81 + v85 == (char *)effect[1].DeviceUpdate )
  {
    v102 = (ALboolean (*)(ALeffectState *, ALCdevice *))(int)(float)(Frequency * 0.0133);
    Destroy = effect[1].Destroy;
    v88 = v37;
    Update = 0;
    Process = v32;
    DeviceUpdate = v100;
    v91 = v99;
    v93 = v97;
    v92 = v98;
  }
  else
  {
    if ( (unsigned int)LogLevel_0 >= LogTrace )
      j_al_print(
        "(II)",
        "AllocLines",
        "New reverb buffer length: %u samples (%f sec)\n",
        v86,
        (float)((float)(unsigned int)v86 / Frequency));
    Destroy = (ALvoid (*)(ALeffectState *))realloc(effect[1].Destroy, 4 * (_DWORD)v86);
    if ( !Destroy )
      return 0;
    v102 = (ALboolean (*)(ALeffectState *, ALCdevice *))(int)(float)(Frequency * 0.0133);
    Update = effect[2].Update;
    DeviceUpdate = effect[4].DeviceUpdate;
    v115 = effect[6].Update;
    v114 = effect[7].Destroy;
    v81 = effect[26].Update;
    v76 = effect[27].Destroy;
    effect[1].DeviceUpdate = v86;
    v71 = effect[20].Update;
    v116 = effect[16].Update;
    v112 = effect[8].Destroy;
    v66 = effect[20].Destroy;
    v113 = effect[16].Destroy;
    v111 = effect[7].Update;
    v93 = effect[19].Update;
    v91 = effect[15].Update;
    v92 = effect[19].Destroy;
    v88 = effect[15].Destroy;
    effect[1].Destroy = Destroy;
    Process = effect[11].Process;
  }
  effect[11].Process = (ALvoid (*)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]))((char *)Destroy
                                                                                               + 4 * (_DWORD)Process);
  effect[4].DeviceUpdate = (ALboolean (*)(ALeffectState *, ALCdevice *))((char *)Destroy + 4 * (_DWORD)DeviceUpdate);
  effect[6].Update = (ALvoid (*)(ALeffectState *, ALCdevice *, const ALeffectslot *))((char *)Destroy + 4 * (_DWORD)v115);
  effect[15].Destroy = (ALvoid (*)(ALeffectState *))((char *)Destroy + 4 * (_DWORD)v88);
  effect[19].Destroy = (ALvoid (*)(ALeffectState *))((char *)Destroy + 4 * (_DWORD)v92);
  effect[7].Destroy = (ALvoid (*)(ALeffectState *))((char *)Destroy + 4 * (_DWORD)v114);
  effect[15].Update = (ALvoid (*)(ALeffectState *, ALCdevice *, const ALeffectslot *))((char *)Destroy + 4 * (_DWORD)v91);
  effect[19].Update = (ALvoid (*)(ALeffectState *, ALCdevice *, const ALeffectslot *))((char *)Destroy + 4 * (_DWORD)v93);
  effect[7].Update = (ALvoid (*)(ALeffectState *, ALCdevice *, const ALeffectslot *))((char *)Destroy + 4 * (_DWORD)v111);
  effect[16].Destroy = (ALvoid (*)(ALeffectState *))((char *)Destroy + 4 * (_DWORD)v113);
  effect[20].Destroy = (ALvoid (*)(ALeffectState *))((char *)Destroy + 4 * (_DWORD)v66);
  effect[8].Destroy = (ALvoid (*)(ALeffectState *))((char *)Destroy + 4 * (_DWORD)v112);
  effect[16].Update = (ALvoid (*)(ALeffectState *, ALCdevice *, const ALeffectslot *))((char *)Destroy + 4 * (_DWORD)v116);
  effect[20].Update = (ALvoid (*)(ALeffectState *, ALCdevice *, const ALeffectslot *))((char *)Destroy + 4 * (_DWORD)v71);
  effect[2].Update = (ALvoid (*)(ALeffectState *, ALCdevice *, const ALeffectslot *))((char *)Destroy
                                                                                    + 4 * (_DWORD)Update);
  effect[27].Destroy = (ALvoid (*)(ALeffectState *))((char *)Destroy + 4 * (_DWORD)v76);
  effect[26].Update = (ALvoid (*)(ALeffectState *, ALCdevice *, const ALeffectslot *))((char *)Destroy + 4 * (_DWORD)v81);
  if ( v86 )
  {
    *(_DWORD *)Destroy = 0;
    if ( (char *)effect[1].DeviceUpdate >= (char *)((char *)&dword_0 + 2) )
    {
      v94 = (ALboolean (*)(ALeffectState *, ALCdevice *))(&dword_0 + 1);
      v95 = 4;
      do
      {
        v94 = (ALboolean (*)(ALeffectState *, ALCdevice *))((char *)v94 + 1);
        *(_DWORD *)((char *)effect[1].Destroy + v95) = 0;
        v95 += 4;
      }
      while ( (char *)v94 < (char *)effect[1].DeviceUpdate );
    }
  }
  effect[8].DeviceUpdate = v110;
  effect[8].Update = v109;
  effect[8].Process = v108;
  effect[9].Destroy = v107;
  effect[16].Process = v106;
  effect[17].Destroy = v105;
  effect[17].DeviceUpdate = v104;
  effect[17].Update = v103;
  effect[28].DeviceUpdate = v102;
  *(float *)&effect[3].Update = powf(0.048, 100000.0 / Frequency);
  return 1;
}
// 0: using guessed type int dword_0;

//----- (00251E0C) --------------------------------------------------------
ALvoid __fastcall ReverbUpdate(ALeffectState_0 *effect, ALCdevice *Device, const ALeffectslot_0 *Slot)
{
  float32x2_t v3; // d0
  float32x2_t v4; // d1
  float32x2_t v5; // d3
  float32x2_t v6; // d6
  float32x2_t v7; // d8
  float32x2_t v8; // d13
  ALenum type; // r2
  bool v13; // zf
  ALuint Frequency; // r0
  float v15; // s0
  int v16; // r4
  float v17; // s22
  float v18; // r0
  float v19; // s19
  float ModulationTime; // s2
  __int64 v21; // kr00_8
  float v22; // s0
  unsigned int v23; // r3
  float ReflectionsDelay; // s0
  float v25; // s2
  float LateReverbDelay; // s6
  float v27; // s0
  float v28; // r4
  float v29; // r6
  float v30; // s30
  float DecayTime; // s18
  float v32; // s31
  float Diffusion; // s18
  float Gain; // s20
  float v35; // s23
  float v36; // r0
  float v37; // s2
  float v38; // s6
  unsigned __int64 v39; // d12
  int v40; // r5
  float v41; // s28
  float v42; // s19
  float v43; // s21
  float v44; // r6
  float *v45; // r11
  float v46; // s18
  float32x2_t v47; // d0
  float v48; // r0
  float v49; // s23
  float EchoTime; // s25
  float v51; // s30
  float v52; // s20
  float LateReverbGain; // s24
  float v54; // s31
  float v55; // s0
  float EchoDepth; // s22
  float v57; // r0
  const ALCdevice *v58; // r6
  float v59; // s0
  float NumChan; // s2
  float v61; // s4
  ALuint v62; // r1
  float v63; // s0
  Channel v64; // r2
  ALvoid (*v65)(ALeffectState *, ALCdevice *, const ALeffectslot *); // s0
  float v66; // s18
  float v67; // s20
  float v68; // s0
  float v69; // s2
  float v70; // s22
  float v71; // s10
  float v72; // s10
  float v73; // s24
  float v74; // s4
  float v75; // s4
  float v76; // s26
  float v77; // r0
  float v78; // s21
  float v79; // r0
  ALCdevice *v80; // [sp+4h] [bp-6Ch]
  const ALeffectslot_0 *v81; // [sp+8h] [bp-68h]
  int v82; // [sp+Ch] [bp-64h]

  type = Slot->effect.type;
  v13 = type == 0x8000;
  Frequency = Device->Frequency;
  if ( type == 0x8000 )
    v13 = EmulateEAXReverb == 0;
  if ( v13 )
  {
    v16 = 1;
    effect->Process = EAXVerbProcess;
    v15 = Slot->effect.Reverb.HFReference * 6.2832;
  }
  else
  {
    v15 = 31416.0;
    if ( type == 1 || EmulateEAXReverb )
    {
      v16 = 0;
      effect->Process = VerbProcess;
    }
    else
    {
      v16 = 0;
    }
  }
  v17 = (float)Frequency;
  v18 = cosf(v15 / (float)Frequency);
  v19 = v18;
  v3.n64_u32[0] = LODWORD(Slot->effect.Reverb.GainHF);
  if ( v3.n64_f32[0] >= 0.9999 )
  {
    v3.n64_u32[0] = 0;
  }
  else
  {
    v5.n64_u32[0] = 981668463;
    v3.n64_u64[0] = vmax_f32(v3, v5).n64_u64[0];
    v3.n64_f32[0] = (float)((float)(1.0 - (float)(v18 * v3.n64_f32[0]))
                          - sqrtf(
                              (float)((float)(1.0 - v18) * (float)(v3.n64_f32[0] + v3.n64_f32[0]))
                            - (float)((float)(1.0 - (float)(v18 * v18)) * (float)(v3.n64_f32[0] * v3.n64_f32[0]))))
                  / (float)(1.0 - v3.n64_f32[0]);
  }
  effect[1].Update = (ALvoid (*)(ALeffectState *, ALCdevice *, const ALeffectslot *))v3.n64_u32[0];
  v82 = v16;
  if ( v16 == 1 )
  {
    ModulationTime = Slot->effect.Reverb.ModulationTime;
    v21 = *(_QWORD *)&effect[2].Process;
    v22 = (float)((float)(ModulationTime * (float)(Slot->effect.Reverb.ModulationDepth * 0.1)) * 0.5) * 0.5;
    v23 = (int)(float)(ModulationTime * v17);
    if ( v23 <= 1 )
      v23 = 1;
    effect[3].Destroy = (ALvoid (*)(ALeffectState *))v23;
    effect[2].Process = (ALvoid (*)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]))(v23
                                                                                                * (unsigned __int64)(unsigned int)v21
                                                                                                / HIDWORD(v21));
    *(float *)&effect[3].DeviceUpdate = v22 * v17;
  }
  ReflectionsDelay = Slot->effect.Reverb.ReflectionsDelay;
  v25 = ReflectionsDelay + Slot->effect.Reverb.LateReverbDelay;
  effect[4].Update = (ALvoid (*)(ALeffectState *, ALCdevice *, const ALeffectslot *))(int)(float)(ReflectionsDelay * v17);
  effect[4].Process = (ALvoid (*)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]))(int)(float)(v25 * v17);
  LateReverbDelay = Slot->effect.Reverb.LateReverbDelay;
  *(float *)&effect[5].Destroy = (float)(Slot->effect.Reverb.Gain * 0.5) * Slot->effect.Reverb.ReflectionsGain;
  *(float *)&effect[5].Update = powf(0.001, 0.0045 / LateReverbDelay);
  *(float *)&effect[5].DeviceUpdate = powf(0.001, 0.0015 / LateReverbDelay);
  *(float *)&effect[5].Process = powf(0.001, 0.0135 / LateReverbDelay);
  *(float *)&effect[6].Destroy = powf(0.001, 0.0405 / LateReverbDelay);
  v7.n64_u32[0] = 1.0;
  v27 = (float)(Slot->effect.Reverb.Density * 4.0) + 1.0;
  effect[12].Destroy = (ALvoid (*)(ALeffectState *))(int)(float)((float)(v27 * 0.003165) * v17);
  effect[12].DeviceUpdate = (ALboolean (*)(ALeffectState *, ALCdevice *))(int)(float)((float)(v27 * 0.00633) * v17);
  effect[12].Update = (ALvoid (*)(ALeffectState *, ALCdevice *, const ALeffectslot *))(int)(float)((float)(v27 * 0.01266)
                                                                                                 * v17);
  v28 = Slot->effect.Reverb.Diffusion * 1.0472;
  v29 = cosf(v28);
  v30 = v29;
  *(float *)&effect[13].Update = (float)(sinf(v28) / 1.7321) / v29;
  v8.n64_u32[0] = LODWORD(Slot->effect.Reverb.DecayHFRatio);
  v80 = Device;
  if ( Slot->effect.Reverb.DecayHFLimit && Slot->effect.Reverb.AirAbsorptionGainHF < 1.0 )
  {
    DecayTime = Slot->effect.Reverb.DecayTime;
    v4.n64_u32[0] = 1036831949;
    v3.n64_f32[0] = 1.0
                  / (float)((float)((float)(DecayTime * log10f(Slot->effect.Reverb.AirAbsorptionGainHF)) / -3.0) * 343.3);
    v8.n64_u32[0] = vmin_f32(vmax_f32(v3, v4), v8).n64_u32[0];
  }
  v32 = Slot->effect.Reverb.DecayTime;
  Diffusion = Slot->effect.Reverb.Diffusion;
  Gain = Slot->effect.Reverb.Gain;
  v35 = (float)(Slot->effect.Reverb.Density * 4.0) + 1.0;
  v36 = powf(0.001, (float)(v35 * 0.041575) / v32);
  v81 = Slot;
  v37 = Gain * Slot->effect.Reverb.LateReverbGain;
  v38 = v19 * v19;
  LODWORD(v39) = 0;
  v40 = 0;
  v41 = v19;
  v42 = 1.0 - v19;
  v43 = 1.0 - v38;
  *(float *)&effect[12].Process = v29 * v37;
  *(float *)&effect[13].Destroy = sqrtf(1.0 - (float)(v36 * v36));
  *(float *)&effect[13].DeviceUpdate = (float)(Diffusion * Diffusion) * 0.5;
  do
  {
    v44 = powf(0.001, ALLPASS_LINE_LENGTH[v40] / v32);
    v45 = (float *)((char *)effect + v40 * 4);
    v46 = v35 * LATE_LINE_LENGTH[v40];
    *(ALvoid (**)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]))((char *)&effect[20].Process + v40 * 4) = (ALvoid (*)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]))(int)(float)(v46 * v17);
    HIDWORD(v39) = powf(0.001, v46 / v32);
    v45[55] = v44;
    v47.n64_u64[0] = v39;
    v45[71] = *((float *)&v39 + 1);
    if ( v8.n64_f32[0] < 1.0 )
    {
      v48 = powf(0.001, v46 / (float)(v8.n64_f32[0] * v32));
      v4.n64_u64[0] = v39;
      v47.n64_f32[0] = (float)(v48 / *((float *)&v39 + 1)) * (float)(v48 / *((float *)&v39 + 1));
      if ( v47.n64_f32[0] < 0.9999 )
      {
        v4.n64_u32[0] = 981668463;
        v47.n64_u64[0] = vmax_f32(v47, v4).n64_u64[0];
        v4.n64_f32[0] = (float)((float)(1.0 - (float)(v41 * v47.n64_f32[0]))
                              - sqrtf(
                                  (float)(v42 * (float)(v47.n64_f32[0] + v47.n64_f32[0]))
                                - (float)(v43 * (float)(v47.n64_f32[0] * v47.n64_f32[0]))))
                      / (float)(1.0 - v47.n64_f32[0]);
      }
      v47.n64_u32[0] = 1065017672;
      v47.n64_u64[0] = vmin_f32(v4, v47).n64_u64[0];
    }
    ++v40;
    v45[87] = v47.n64_f32[0];
    v45[71] = v30 * *((float *)&v39 + 1);
  }
  while ( v40 != 4 );
  if ( v82 == 1 )
  {
    v49 = v81->effect.Reverb.DecayTime;
    EchoTime = v81->effect.Reverb.EchoTime;
    v51 = v81->effect.Reverb.Diffusion;
    v52 = v81->effect.Reverb.Gain;
    LateReverbGain = v81->effect.Reverb.LateReverbGain;
    v54 = powf(0.001, EchoTime / v49);
    v55 = EchoTime * v17;
    EchoDepth = v81->effect.Reverb.EchoDepth;
    effect[28].Destroy = (ALvoid (*)(ALeffectState *))(int)v55;
    *(float *)&effect[27].Update = (float)(v51 * v51) * 0.5;
    *(float *)&effect[27].DeviceUpdate = v54;
    *(float *)&effect[27].Process = powf(0.001, 0.0133 / v49);
    *(float *)&effect[26].Destroy = sqrtf(1.0 - (float)(v54 * v54));
    if ( v8.n64_f32[0] >= 1.0 )
    {
      v65 = 0;
      v58 = v80;
    }
    else
    {
      v57 = powf(0.001, EchoTime / (float)(v8.n64_f32[0] * v49));
      v58 = v80;
      v47.n64_f32[0] = (float)(v57 / v54) * (float)(v57 / v54);
      if ( v47.n64_f32[0] >= 0.9999 )
      {
        v47.n64_u32[0] = 0;
      }
      else
      {
        v4.n64_u32[0] = 981668463;
        v47.n64_u64[0] = vmax_f32(v47, v4).n64_u64[0];
        v47.n64_f32[0] = (float)((float)(1.0 - (float)(v41 * v47.n64_f32[0]))
                               - sqrtf(
                                   (float)(v42 * (float)(v47.n64_f32[0] + v47.n64_f32[0]))
                                 - (float)(v43 * (float)(v47.n64_f32[0] * v47.n64_f32[0]))))
                       / (float)(1.0 - v47.n64_f32[0]);
      }
      v4.n64_u32[0] = 1065017672;
      v65 = (ALvoid (*)(ALeffectState *, ALCdevice *, const ALeffectslot *))vmin_f32(v47, v4).n64_u32[0];
    }
    effect[28].Update = v65;
    *(float *)&effect[29].Destroy = (float)(v52 * LateReverbGain) * EchoDepth;
    *(float *)&effect[29].DeviceUpdate = (float)((float)(1.0 - v51) * (float)(EchoDepth * -0.5)) + 1.0;
    v66 = v81->effect.Reverb.LateReverbPan[0];
    v67 = v81->effect.Reverb.LateReverbPan[2];
    v68 = v81->effect.Reverb.ReflectionsPan[0];
    v6.n64_f32[0] = sqrtf(2.0 / (float)v58->NumChan);
    v69 = v81->effect.Reverb.ReflectionsPan[2];
    LODWORD(v70) = vmin_f32(v6, v7).n64_u32[0];
    v71 = (float)((float)(v68 * v68)
                + (float)(v81->effect.Reverb.ReflectionsPan[1] * v81->effect.Reverb.ReflectionsPan[1]))
        + (float)(v69 * v69);
    if ( v71 > 1.0 )
    {
      v72 = 1.0 / sqrtf(v71);
      v69 = v69 * v72;
      v68 = v68 * v72;
    }
    v73 = (float)v81->Gain * ReverbBoost;
    v74 = (float)((float)(v66 * v66) + (float)(v81->effect.Reverb.LateReverbPan[1] * v81->effect.Reverb.LateReverbPan[1]))
        + (float)(v67 * v67);
    if ( v74 > 1.0 )
    {
      v75 = 1.0 / sqrtf(v74);
      v67 = v67 * v75;
      v66 = v66 * v75;
    }
    effect[11].DeviceUpdate = 0;
    *(_QWORD *)&effect[10].DeviceUpdate = 0LL;
    *(_QWORD *)&effect[10].Process = 0LL;
    *(_QWORD *)&effect[9].DeviceUpdate = 0LL;
    *(_QWORD *)&effect[9].Process = 0LL;
    v76 = sqrtf((float)(v69 * v69) + (float)(v68 * v68));
    v77 = atan2f(v68, v69);
    j_ComputeAngleGains(
      v58,
      v77,
      (float)(1.0 - v76) * 3.1416,
      v73 * (float)(v70 + (float)((float)(1.0 - v70) * v76)),
      (int)&effect[9].DeviceUpdate);
    *(_QWORD *)&effect[24].Process = 0LL;
    *(_QWORD *)&effect[25].DeviceUpdate = 0LL;
    *(_QWORD *)&effect[23].Process = 0LL;
    *(_QWORD *)&effect[24].DeviceUpdate = 0LL;
    effect[25].Process = 0;
    v78 = sqrtf((float)(v67 * v67) + (float)(v66 * v66));
    v79 = atan2f(v66, v67);
    j_ComputeAngleGains(
      v58,
      v79,
      (float)(1.0 - v78) * 3.1416,
      v73 * (float)(v70 + (float)((float)(1.0 - v70) * v78)),
      (int)&effect[23].Process);
  }
  else
  {
    v59 = v81->Gain;
    NumChan = (float)v80->NumChan;
    v61 = ReverbBoost;
    *(_DWORD *)effect[29].Process = 0;
    *((_DWORD *)effect[29].Process + 1) = 0;
    *((_DWORD *)effect[29].Process + 2) = 0;
    *((_DWORD *)effect[29].Process + 3) = 0;
    *((_DWORD *)effect[29].Process + 4) = 0;
    *((_DWORD *)effect[29].Process + 5) = 0;
    *((_DWORD *)effect[29].Process + 6) = 0;
    *((_DWORD *)effect[29].Process + 7) = 0;
    *((_DWORD *)effect[29].Process + 8) = 0;
    if ( v80->NumChan )
    {
      v62 = 0;
      v63 = v59 * (float)(v61 * sqrtf(2.0 / NumChan));
      do
      {
        v64 = v80->Speaker2Chan[v62++];
        *((float *)effect[29].Process + v64) = v63;
      }
      while ( v62 < v80->NumChan );
    }
  }
}
// 251EA6: variable 'v3' is possibly undefined
// 251EA6: variable 'v5' is possibly undefined
// 2520F8: variable 'v4' is possibly undefined
// 2520FC: variable 'v8' is possibly undefined
// 252454: variable 'v6' is possibly undefined
// 252454: variable 'v7' is possibly undefined

//----- (002525C8) --------------------------------------------------------
ALvoid __fastcall VerbProcess(
        ALeffectState_0 *effect,
        ALuint SamplesToDo,
        const ALfloat *SamplesIn,
        ALfloat (*SamplesOut)[2048])
{
  int32x2_t v4; // d2
  ALvoid (*Update)(ALeffectState *, ALCdevice *, const ALeffectslot *); // r0
  float32x4_t *v9; // r1
  ALuint v10; // r8
  ALvoid (*v11)(ALeffectState *, ALCdevice *, const ALeffectslot *); // s2
  float *v12; // r0
  float v13; // s0
  float v14; // s2
  ALvoid (*v15)(ALeffectState *, ALCdevice *, const ALeffectslot *); // r0
  ALboolean (*DeviceUpdate)(ALeffectState *, ALCdevice *); // r1
  float32x4_t v17; // q0
  ALvoid (*v18)(ALeffectState *, ALCdevice *, const ALeffectslot *); // r3
  float32x4_t v19; // q0
  float32x4_t v20; // q5
  ALvoid (*v21)(ALeffectState *, ALCdevice *, const ALeffectslot *); // r1
  const float *v22; // r0
  ALvoid (*v23)(ALeffectState *, ALCdevice *, const ALeffectslot *); // r0
  ALvoid (*Process)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]); // r1
  ALboolean (*v25)(ALeffectState *, ALCdevice *); // r3
  ALvoid (*v26)(ALeffectState *, ALCdevice *, const ALeffectslot *); // r4
  ALvoid (*v27)(ALeffectState *, ALCdevice *, const ALeffectslot *); // r6
  ALvoid (*v28)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]); // r0
  char v29; // r1
  int i; // r2
  float v31; // s2
  ALuint v32; // r6
  ALfloat (*v33)[2048]; // r4
  float *v34; // r3
  float v35; // s4
  ALeffectState_0 *v36; // [sp+0h] [bp-78h]
  float32x4_t *v38; // [sp+Ch] [bp-6Ch]
  ALfloat in[4]; // [sp+10h] [bp-68h] BYREF
  float32x4_t v40; // [sp+20h] [bp-58h] BYREF
  float32x4_t v41; // 0:d12.8,8:d13.8

  v36 = effect + 30;
  if ( SamplesToDo )
  {
    Update = effect[29].Update;
    v9 = (float32x4_t *)v36;
    v10 = SamplesToDo;
    do
    {
      v38 = v9;
      v11 = effect[1].Update;
      v12 = (float *)((char *)effect[4].DeviceUpdate + 4 * ((unsigned int)Update & (unsigned int)effect[4].Destroy));
      v13 = *SamplesIn + (float)(*(float *)&v11 * (float)(*(float *)&effect[1].Process - *SamplesIn));
      v4.n64_f32[0] = *(float *)&effect[2].Destroy - v13;
      *(float *)&effect[1].Process = v13;
      v14 = v13 + (float)(*(float *)&v11 * v4.n64_f32[0]);
      *(float *)&effect[2].Destroy = v14;
      *v12 = v14;
      v15 = effect[29].Update;
      DeviceUpdate = effect[6].DeviceUpdate;
      v17.n128_u32[3] = *((_DWORD *)effect[8].Destroy
                        + (((char *)v15 - (char *)effect[9].Destroy) & (unsigned int)effect[7].Process));
      v17.n128_u32[2] = *((_DWORD *)effect[7].Update
                        + (((char *)v15 - (char *)effect[8].Process) & (unsigned int)effect[7].DeviceUpdate));
      v18 = effect[6].Update;
      v17.n128_u32[1] = *((_DWORD *)effect[7].Destroy
                        + (((char *)v15 - (char *)effect[8].Update) & (unsigned int)effect[6].Process));
      v17.n128_u32[0] = *((_DWORD *)v18 + (((char *)v15 - (char *)effect[8].DeviceUpdate) & (unsigned int)DeviceUpdate));
      v19 = vmulq_f32(*(float32x4_t *)&effect[5].DeviceUpdate, v17);
      v4.n64_f32[0] = *((float *)effect[4].DeviceUpdate
                      + (((char *)v15 - (char *)effect[4].Update) & (unsigned int)effect[4].Destroy))
                    + (float)((float)((float)((float)(v19.n128_f32[0] + v19.n128_f32[1]) + v19.n128_f32[2])
                                    + v19.n128_f32[3])
                            * 0.5);
      v20 = vsubq_f32(vdupq_lane_s32(v4, 0), v19);
      *((_DWORD *)v18 + ((unsigned int)v15 & (unsigned int)DeviceUpdate)) = v20.n128_u32[0];
      *((_DWORD *)effect[7].Destroy + ((int)effect[6].Process & (int)effect[29].Update)) = v20.n128_u32[1];
      *((_DWORD *)effect[7].Update + ((int)effect[7].DeviceUpdate & (int)effect[29].Update)) = v20.n128_u32[2];
      *((_DWORD *)effect[8].Destroy + ((int)effect[7].Process & (int)effect[29].Update)) = v20.n128_u32[3];
      v21 = effect[29].Update;
      v22 = (const float *)&effect[5];
      v19.n128_f32[0] = *((float *)effect[4].DeviceUpdate
                        + (((char *)v21 - (char *)effect[4].Process) & (unsigned int)effect[4].Destroy))
                      * *(float *)&effect[13].Destroy;
      v41 = (float32x4_t)vld1q_dup_f32(v22);
      *((_DWORD *)effect[11].Process + ((int)effect[11].Update & (unsigned int)v21)) = v19.n128_u32[0];
      in[0] = v19.n128_f32[0];
      v23 = effect[11].Update;
      Process = effect[11].Process;
      v25 = effect[12].DeviceUpdate;
      v26 = effect[12].Update;
      v27 = effect[29].Update;
      in[1] = *((ALfloat *)Process + (((char *)v27 - (char *)effect[12].Destroy) & (unsigned int)v23));
      in[2] = *((ALfloat *)Process + (((char *)v27 - (char *)v25) & (unsigned int)v23));
      in[3] = *((ALfloat *)Process + ((unsigned int)v23 & ((char *)v27 - (char *)v26)));
      LateReverb((ALverbState_0 *)effect, in, (ALfloat *)&v40);
      --v10;
      ++SamplesIn;
      *v38 = vaddq_f32(vmulq_f32(v20, v41), v40);
      v9 = v38 + 1;
      Update = (ALvoid (*)(ALeffectState *, ALCdevice *, const ALeffectslot *))((char *)effect[29].Update + 1);
      effect[29].Update = Update;
    }
    while ( v10 );
  }
  v28 = effect[29].Process;
  v29 = 0;
  for ( i = 0; i != 9; ++i )
  {
    v31 = *((float *)v28 + i);
    if ( v31 > 0.00001 && SamplesToDo )
    {
      v32 = SamplesToDo;
      v33 = SamplesOut;
      v34 = (float *)(&v36->Destroy + (v29 & 3));
      do
      {
        v35 = *v34;
        v34 += 4;
        --v32;
        (*v33)[0] = (*v33)[0] + (float)(v31 * v35);
        v33 = (ALfloat (*)[2048])((char *)v33 + 4);
      }
      while ( v32 );
    }
    ++v29;
    ++SamplesOut;
  }
}
// 2526E2: variable 'v4' is possibly undefined

//----- (0025282C) --------------------------------------------------------
RingBuffer_0 *__fastcall CreateRingBuffer(ALsizei frame_size, ALsizei length)
{
  int v2; // r6
  CRITICAL_SECTION *v4; // r0
  RingBuffer_0 *v5; // r5

  v2 = length + 1;
  v4 = (CRITICAL_SECTION *)calloc(1u, (length + 1) * frame_size + 24);
  v5 = (RingBuffer_0 *)v4;
  if ( v4 )
  {
    v4->__private[0] = (int32_t_0)v4[6].__private;
    v4[1].__private[0] = frame_size;
    v4[2].__private[0] = v2;
    j_InitializeCriticalSection(v4 + 5);
  }
  return v5;
}

//----- (00252864) --------------------------------------------------------
void __fastcall DestroyRingBuffer(RingBuffer_0 *ring)
{
  if ( ring )
  {
    if ( pthread_mutex_destroy(&ring->cs) )
    {
      _assert2(
        "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
        357,
        "void DeleteCriticalSection(CRITICAL_SECTION *)",
        "ret == 0");
      JUMPOUT(0x25289C);
    }
    j_free(ring);
  }
}
// 25289A: control flows out of bounds to 25289C
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (002528A8) --------------------------------------------------------
ALsizei __fastcall RingBufferSize(RingBuffer_0 *ring)
{
  CRITICAL_SECTION *p_cs; // r6
  __int64 v3; // kr00_8
  ALint write_pos; // r5

  p_cs = &ring->cs;
  if ( pthread_mutex_lock(&ring->cs) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      363,
      "void EnterCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    goto LABEL_5;
  }
  v3 = *(_QWORD *)&ring->length;
  write_pos = ring->write_pos;
  if ( pthread_mutex_unlock(p_cs) )
  {
LABEL_5:
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      369,
      "void LeaveCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    JUMPOUT(0x252908);
  }
  return (write_pos - HIDWORD(v3) + (int)v3) % (int)v3;
}
// 252904: control flows out of bounds to 252908
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00252920) --------------------------------------------------------
void __fastcall WriteRingBuffer(RingBuffer_0 *ring, const ALubyte *data, ALsizei len)
{
  CRITICAL_SECTION *p_cs; // r9
  ALint write_pos; // r6
  int v8; // r4
  __int64 v9; // r0
  size_t v10; // r2

  p_cs = &ring->cs;
  if ( pthread_mutex_lock(&ring->cs) )
  {
LABEL_11:
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      363,
      "void EnterCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    JUMPOUT(0x2529D0);
  }
  write_pos = ring->write_pos;
  if ( (ring->read_pos - 1 - write_pos + ring->length) % ring->length < len )
    len = (ring->read_pos - 1 - write_pos + ring->length) % ring->length;
  if ( len >= 1 )
  {
    v9 = *(_QWORD *)&ring->mem;
    v8 = ring->length - write_pos;
    LODWORD(v9) = v9 + HIDWORD(v9) * write_pos;
    if ( len <= v8 )
    {
      v10 = HIDWORD(v9) * len;
      HIDWORD(v9) = data;
    }
    else
    {
      qmemcpy((void *)v9, data, HIDWORD(v9) * v8);
      LODWORD(v9) = ring->mem;
      HIDWORD(v9) = &data[ring->frame_size * v8];
      v10 = ring->frame_size * (len - v8);
    }
    qmemcpy((void *)v9, (const void *)HIDWORD(v9), v10);
    ring->write_pos = (ring->write_pos + len) % ring->length;
  }
  if ( pthread_mutex_unlock(p_cs) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      369,
      "void LeaveCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    goto LABEL_11;
  }
}
// 2529CC: control flows out of bounds to 2529D0
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (002529E8) --------------------------------------------------------
void __fastcall ReadRingBuffer(RingBuffer_0 *ring, ALubyte *data, ALsizei len)
{
  CRITICAL_SECTION *p_cs; // r8
  ALsizei frame_size; // r0
  __int64 v8; // r2
  ALubyte *mem; // r1
  int v10; // r5
  ALubyte *v11; // r0
  size_t v12; // r2

  p_cs = &ring->cs;
  if ( pthread_mutex_lock(&ring->cs) )
  {
LABEL_7:
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      363,
      "void EnterCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    JUMPOUT(0x252A7C);
  }
  frame_size = ring->frame_size;
  v8 = *(_QWORD *)&ring->length;
  mem = &ring->mem[frame_size * HIDWORD(v8)];
  v10 = v8 - HIDWORD(v8);
  if ( (int)v8 - HIDWORD(v8) >= len )
  {
    v12 = frame_size * len;
    v11 = data;
  }
  else
  {
    qmemcpy(data, mem, frame_size * v10);
    mem = ring->mem;
    v11 = &data[ring->frame_size * v10];
    v12 = ring->frame_size * (len - v10);
  }
  qmemcpy(v11, mem, v12);
  ring->read_pos = (ring->read_pos + len) % ring->length;
  if ( pthread_mutex_unlock(p_cs) )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/helpers.c",
      369,
      "void LeaveCriticalSection(CRITICAL_SECTION *)",
      "ret == 0");
    goto LABEL_7;
  }
}
// 252A7A: control flows out of bounds to 252A7C
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00252A94) --------------------------------------------------------
ALvoid *__fastcall StartThread(ALuint (*func)(ALvoid *), ALvoid *ptr)
{
  pthread_t *v4; // r4
  int v5; // r6
  pthread_attr_t v7; // [sp+0h] [bp-28h] BYREF

  v4 = (pthread_t *)malloc(0x10u);
  if ( !v4 )
    return 0;
  if ( pthread_attr_init(&v7) )
  {
LABEL_6:
    free(v4);
    return 0;
  }
  if ( pthread_attr_setstacksize(&v7, 0x100000u) )
  {
    pthread_attr_destroy(&v7);
    goto LABEL_6;
  }
  *v4 = (pthread_t)func;
  v4[1] = (pthread_t)ptr;
  v5 = pthread_create(v4 + 3, &v7, StarterFunc, v4);
  pthread_attr_destroy(&v7);
  if ( v5 )
    goto LABEL_6;
  return v4;
}

//----- (00252B00) --------------------------------------------------------
void *__fastcall StarterFunc(void *ptr)
{
  *((_DWORD *)ptr + 2) = (*(int (__fastcall **)(_DWORD))ptr)(*((_DWORD *)ptr + 1));
  return 0;
}

//----- (00252B12) --------------------------------------------------------
ALuint __fastcall StopThread(ALvoid *thread)
{
  ALuint v2; // r5

  pthread_join(*((_DWORD *)thread + 3), 0);
  v2 = *((_DWORD *)thread + 2);
  free(thread);
  return v2;
}

//----- (00252B2C) --------------------------------------------------------
ALvoid __fastcall alGenEffects(ALsizei n, ALuint *effects)
{
  ALCcontext *ContextRef; // r0
  unsigned int *p_LastError; // r4
  int v5; // r4
  ALuint *v6; // r0
  ALuint *v7; // r6
  ALenum v8; // r0
  ALuint v9; // r4
  unsigned int v10; // r5
  ALenum inserted; // r0
  unsigned int v12; // r0
  unsigned int v13; // r0
  unsigned int v14; // r0
  unsigned int v15; // r0
  ALenum *v16; // r1
  unsigned int *v17; // r0
  unsigned int v18; // r0
  bool v21; // zf
  unsigned int *v26; // [sp+4h] [bp-34h]
  ALCcontext *v27; // [sp+8h] [bp-30h]
  ALsizei v28; // [sp+Ch] [bp-2Ch]
  UIntMap_0 *map; // [sp+14h] [bp-24h]
  int v31; // [sp+18h] [bp-20h]

  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    v27 = ContextRef;
    p_LastError = (unsigned int *)&ContextRef->LastError;
    v26 = (unsigned int *)&ContextRef->LastError;
    v28 = n;
    while ( n >= 0 )
    {
      if ( n < 1 )
        goto LABEL_66;
      v5 = 0;
      map = &v27->Device->EffectMap;
      while ( 1 )
      {
        v6 = (ALuint *)calloc(1u, 0xB8u);
        v7 = v6;
        v31 = v5;
        if ( !v6 )
        {
          if ( TrapALError )
            raise(5);
          if ( __ldrex(v26) )
          {
LABEL_62:
            __clrex();
          }
          else
          {
            __dmb(0xBu);
            while ( __strex(0xA005u, v26) )
            {
              if ( __ldrex(v26) )
                goto LABEL_62;
            }
          }
          __dmb(0xBu);
          goto LABEL_64;
        }
        v6[37] = (ALuint)alEffect_null_SetParami;
        v6[38] = (ALuint)alEffect_null_SetParamiv;
        v6[39] = (ALuint)alEffect_null_SetParamf;
        v6[40] = (ALuint)alEffect_null_SetParamfv;
        v6[41] = (ALuint)alEffect_null_GetParami;
        v6[42] = (ALuint)alEffect_null_GetParamiv;
        v6[43] = (ALuint)alEffect_null_GetParamf;
        v6[44] = (ALuint)alEffect_null_GetParamfv;
        v8 = j_NewThunkEntry(v6 + 45);
        v9 = v7[45];
        v10 = v8;
        if ( v8 )
          break;
        inserted = j_InsertUIntMapEntry(map, v7[45], v7);
        v9 = v7[45];
        v10 = inserted;
        if ( inserted )
          break;
        effects[v31] = v9;
        v5 = v31 + 1;
        if ( v31 + 1 >= v28 )
          goto LABEL_66;
      }
      __dmb(0xBu);
      do
        v12 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
      while ( 1 )
      {
        __dmb(0xBu);
        if ( v12 != 1 )
          break;
        sched_yield();
        __dmb(0xBu);
        do
          v12 = __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
      }
      __dmb(0xBu);
      do
        v13 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
      while ( 1 )
      {
        __dmb(0xBu);
        if ( v13 != 1 )
          break;
        sched_yield();
        __dmb(0xBu);
        do
          v13 = __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
      }
      __dmb(0xBu);
      do
        v14 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(v14 + 1, (unsigned int *)&ThunkLock.read_count) );
      __dmb(0xBu);
      if ( !v14 )
      {
        __dmb(0xBu);
        do
          v15 = __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
        while ( 1 )
        {
          __dmb(0xBu);
          if ( v15 != 1 )
            break;
          sched_yield();
          __dmb(0xBu);
          do
            v15 = __ldrex((unsigned int *)&ThunkLock.read_count);
          while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
        }
      }
      __dmb(0xBu);
      do
        __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(0, (unsigned int *)&ThunkLock.read_lock) );
      __dmb(0xBu);
      __dmb(0xBu);
      do
        __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(0, (unsigned int *)&ThunkLock.read_entry_lock) );
      __dmb(0xBu);
      if ( v9 - 1 < ThunkArraySize )
      {
        v16 = ThunkArray;
        __dmb(0xBu);
        v17 = (unsigned int *)&v16[v9 - 1];
        do
          __ldrex(v17);
        while ( __strex(0, v17) );
        __dmb(0xBu);
      }
      __dmb(0xBu);
      do
        v18 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(v18 - 1, (unsigned int *)&ThunkLock.read_count) );
      __dmb(0xBu);
      if ( v18 == 1 )
      {
        __dmb(0xBu);
        do
          __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(0, (unsigned int *)&ThunkLock.write_lock) );
        __dmb(0xBu);
      }
      free(v7);
      if ( TrapALError )
        raise(5);
      p_LastError = v26;
      if ( __ldrex(v26) )
      {
LABEL_52:
        __clrex();
      }
      else
      {
        __dmb(0xBu);
        while ( __strex(v10, v26) )
        {
          if ( __ldrex(v26) )
            goto LABEL_52;
        }
      }
      __dmb(0xBu);
      v21 = v10 == 0;
      n = v28;
      if ( !v21 )
      {
LABEL_64:
        if ( v31 >= 1 )
          j_alDeleteEffects(v31, effects);
        goto LABEL_66;
      }
    }
    if ( TrapALError )
      raise(5);
    if ( __ldrex(p_LastError) )
    {
LABEL_73:
      __clrex();
    }
    else
    {
      __dmb(0xBu);
      while ( __strex(0xA003u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
          goto LABEL_73;
      }
    }
    __dmb(0xBu);
LABEL_66:
    ALCcontext_DecRef(v27);
  }
}

//----- (00252E88) --------------------------------------------------------
ALenum __fastcall InitEffect(ALeffect_0 *effect)
{
  effect->SetParamiv = alEffect_null_SetParamiv;
  effect->SetParami = alEffect_null_SetParami;
  effect->type = 0;
  effect->SetParamf = alEffect_null_SetParamf;
  effect->SetParamfv = alEffect_null_SetParamfv;
  effect->GetParami = alEffect_null_GetParami;
  effect->GetParamiv = alEffect_null_GetParamiv;
  effect->GetParamf = alEffect_null_GetParamf;
  effect->GetParamfv = alEffect_null_GetParamfv;
  return 0;
}

//----- (00252EEC) --------------------------------------------------------
ALvoid __fastcall alDeleteEffects(ALsizei n, const ALuint *effects)
{
  ALCcontext *ContextRef; // r0
  unsigned int *p_ref; // r4
  int v6; // r4
  UIntMap_0 *p_EffectMap; // r9
  ALuint v8; // r1
  int v9; // r1
  ALvoid *v10; // r0
  unsigned int v11; // r0
  unsigned int v12; // r0
  unsigned int v13; // r0
  unsigned int v14; // r0
  ALenum *v15; // r1
  unsigned int *v16; // r0
  unsigned int v17; // r0
  unsigned int *v19; // r0
  unsigned int *p_LastError; // r0
  ALCcontext *v24; // [sp+0h] [bp-38h]
  int v25; // [sp+10h] [bp-28h]
  void *p; // [sp+14h] [bp-24h]
  int v27; // [sp+18h] [bp-20h]

  ContextRef = j_GetContextRef();
  p_ref = (unsigned int *)&ContextRef->ref;
  if ( ContextRef )
  {
    v24 = ContextRef;
    if ( n < 0 )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex(p_ref) )
      {
        v19 = p_ref + 20;
        __dmb(0xBu);
        while ( __strex(0xA003u, v19) )
        {
          if ( __ldrex(v19) )
            goto LABEL_62;
        }
        goto LABEL_63;
      }
    }
    else
    {
      if ( !n )
      {
LABEL_64:
        ALCcontext_DecRef(v24);
        return;
      }
      v6 = 0;
      p_EffectMap = &ContextRef->Device->EffectMap;
      while ( 1 )
      {
        v8 = effects[v6];
        if ( v8 )
        {
          if ( !j_LookupUIntMapKey(p_EffectMap, v8) )
            break;
        }
        if ( ++v6 >= n )
        {
          v9 = 0;
          do
          {
            v27 = v9;
            v10 = j_RemoveUIntMapKey(p_EffectMap, effects[v9]);
            if ( v10 )
            {
              p = v10;
              v25 = *((_DWORD *)v10 + 45);
              __dmb(0xBu);
              do
                v11 = __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
              while ( 1 )
              {
                __dmb(0xBu);
                if ( v11 != 1 )
                  break;
                sched_yield();
                __dmb(0xBu);
                do
                  v11 = __ldrex((unsigned int *)&ThunkLock.read_count);
                while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
              }
              __dmb(0xBu);
              do
                v12 = __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
              while ( 1 )
              {
                __dmb(0xBu);
                if ( v12 != 1 )
                  break;
                sched_yield();
                __dmb(0xBu);
                do
                  v12 = __ldrex((unsigned int *)&ThunkLock.read_count);
                while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
              }
              __dmb(0xBu);
              do
                v13 = __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(v13 + 1, (unsigned int *)&ThunkLock.read_count) );
              __dmb(0xBu);
              if ( !v13 )
              {
                __dmb(0xBu);
                do
                  v14 = __ldrex((unsigned int *)&ThunkLock.read_count);
                while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
                while ( 1 )
                {
                  __dmb(0xBu);
                  if ( v14 != 1 )
                    break;
                  sched_yield();
                  __dmb(0xBu);
                  do
                    v14 = __ldrex((unsigned int *)&ThunkLock.read_count);
                  while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
                }
              }
              __dmb(0xBu);
              do
                __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(0, (unsigned int *)&ThunkLock.read_lock) );
              __dmb(0xBu);
              __dmb(0xBu);
              do
                __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(0, (unsigned int *)&ThunkLock.read_entry_lock) );
              __dmb(0xBu);
              if ( v25 - 1 < ThunkArraySize )
              {
                v15 = ThunkArray;
                __dmb(0xBu);
                v16 = (unsigned int *)&v15[v25 - 1];
                do
                  __ldrex(v16);
                while ( __strex(0, v16) );
                __dmb(0xBu);
              }
              __dmb(0xBu);
              do
                v17 = __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(v17 - 1, (unsigned int *)&ThunkLock.read_count) );
              __dmb(0xBu);
              if ( v17 == 1 )
              {
                __dmb(0xBu);
                do
                  __ldrex((unsigned int *)&ThunkLock.read_count);
                while ( __strex(0, (unsigned int *)&ThunkLock.write_lock) );
                __dmb(0xBu);
              }
              free(p);
            }
            v9 = v27 + 1;
          }
          while ( v27 + 1 != n );
          goto LABEL_64;
        }
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v24->ref) )
      {
        p_LastError = (unsigned int *)&v24->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_62;
        }
        goto LABEL_63;
      }
    }
LABEL_62:
    __clrex();
LABEL_63:
    __dmb(0xBu);
    goto LABEL_64;
  }
}
// 252F46: conditional instruction was optimized away because r6.4>=1

//----- (0025319C) --------------------------------------------------------
ALboolean __fastcall alIsEffect(ALuint effect)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v3; // r4
  bool v4; // r5

  ContextRef = j_GetContextRef();
  v3 = ContextRef;
  if ( !ContextRef )
    return 0;
  if ( effect )
    v4 = j_LookupUIntMapKey(&ContextRef->Device->EffectMap, effect) != 0;
  else
    v4 = 1;
  j_ALCcontext_DecRef(v3);
  return v4;
}

//----- (002531E0) --------------------------------------------------------
ALvoid __fastcall alEffecti(ALuint effect, ALenum param, ALint value)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r8
  char *v8; // r0
  int v9; // r1
  _BOOL4 v10; // r4
  void (__fastcall *v12)(ALeffect_0 *, ALCcontext *, ALenum, ALfloat *); // r12
  void (__fastcall *v13)(ALeffect_0 *, ALCcontext *, ALenum, ALfloat *); // lr
  void (__fastcall *v14)(ALeffect_0 *, ALCcontext *, ALenum, ALint *); // r9
  void (__fastcall *v15)(ALeffect_0 *, ALCcontext *, ALenum, ALint *); // r6
  void (__fastcall *v16)(ALeffect_0 *, ALCcontext *, ALenum, const ALfloat *); // r4
  void (__fastcall *v17)(ALeffect_0 *, ALCcontext *, ALenum, ALfloat); // r1
  void (__fastcall *v18)(ALeffect_0 *, ALCcontext *, ALenum, const ALint *); // r2
  void (__fastcall *v19)(ALeffect_0 *, ALCcontext *, ALenum, ALint); // r3
  unsigned int *v21; // r0
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (char *)j_LookupUIntMapKey(&ContextRef->Device->EffectMap, effect);
    if ( v8 )
    {
      if ( param != 32769 )
      {
        (*((void (__fastcall **)(char *, ALCcontext *, ALenum, ALint))v8 + 37))(v8, v7, param, value);
LABEL_43:
        ALCcontext_DecRef(v7);
        return;
      }
      if ( !value )
      {
        v12 = alEffect_null_GetParamfv;
        v13 = alEffect_null_GetParamf;
        v14 = alEffect_null_GetParamiv;
        v15 = alEffect_null_GetParami;
        v16 = alEffect_null_SetParamfv;
        v17 = alEffect_null_SetParamf;
        v18 = alEffect_null_SetParamiv;
        v19 = alEffect_null_SetParami;
LABEL_42:
        *((_DWORD *)v8 + 37) = v19;
        *((_DWORD *)v8 + 38) = v18;
        *((_DWORD *)v8 + 39) = v17;
        *((_DWORD *)v8 + 40) = v16;
        *((_DWORD *)v8 + 41) = v15;
        *((_DWORD *)v8 + 42) = v14;
        *((_DWORD *)v8 + 43) = v13;
        *((_DWORD *)v8 + 44) = v12;
        *(_DWORD *)v8 = value;
        goto LABEL_43;
      }
      v9 = 0;
      do
      {
        if ( EffectList_0[v9].val == value )
        {
          v10 = DisabledEffects[EffectList_0[v9].type] == 0;
          if ( !DisabledEffects[EffectList_0[v9].type] )
            break;
        }
        else
        {
          v10 = 0;
        }
      }
      while ( v9++ != 5 );
      if ( v10 )
      {
        v12 = alEffect_null_GetParamfv;
        v13 = alEffect_null_GetParamf;
        v14 = alEffect_null_GetParamiv;
        v15 = alEffect_null_GetParami;
        v16 = alEffect_null_SetParamfv;
        v17 = alEffect_null_SetParamf;
        v18 = alEffect_null_SetParamiv;
        v19 = alEffect_null_SetParami;
        if ( value >= 0x8000 )
        {
          if ( (unsigned int)(value - 36864) >= 2 )
          {
            if ( value == 0x8000 )
            {
              *(_QWORD *)(v8 + 20) = 0x3F547AE13FBEB852LL;
              *(_QWORD *)(v8 + 28) = 0x3BE560423D4CCCCDLL;
              *(_QWORD *)(v8 + 4) = 0x3F8000003F800000LL;
              *(_QWORD *)(v8 + 12) = 0x3F63D70A3EA3D70ALL;
              *((_QWORD *)v8 + 7) = 0x3F8000003F800000LL;
              *((_QWORD *)v8 + 8) = 0LL;
              *((_QWORD *)v8 + 10) = 0LL;
              *((_QWORD *)v8 + 11) = 1048576000LL;
              *((_DWORD *)v8 + 18) = 0;
              *((_DWORD *)v8 + 19) = 0;
              *((_DWORD *)v8 + 9) = 1067534254;
              *((_DWORD *)v8 + 10) = 1010055512;
              *((_DWORD *)v8 + 11) = 1065252553;
              *((_DWORD *)v8 + 12) = 0;
              v12 = eaxreverb_GetParamfv;
              v13 = eaxreverb_GetParamf;
              v14 = eaxreverb_GetParamiv;
              v15 = eaxreverb_GetParami;
              v8[52] = 1;
              v16 = eaxreverb_SetParamfv;
              v17 = eaxreverb_SetParamf;
              *((_QWORD *)v8 + 12) = 1048576000LL;
              *((_QWORD *)v8 + 13) = 0x437A0000459C4000LL;
              v18 = eaxreverb_SetParamiv;
              v19 = eaxreverb_SetParami;
            }
          }
          else
          {
            v12 = ded_GetParamfv;
            v13 = ded_GetParamf;
            v14 = ded_GetParamiv;
            v15 = ded_GetParami;
            v16 = ded_SetParamfv;
            *((_DWORD *)v8 + 36) = 1065353216;
            v17 = ded_SetParamf;
            v18 = ded_SetParamiv;
            v19 = ded_SetParami;
          }
        }
        else
        {
          switch ( value )
          {
            case 1:
              *(_QWORD *)(v8 + 20) = 0x3F547AE13FBEB852LL;
              *(_QWORD *)(v8 + 28) = 0x3BE560423D4CCCCDLL;
              *(_QWORD *)(v8 + 4) = 0x3F8000003F800000LL;
              *(_QWORD *)(v8 + 12) = 0x3F63D70A3EA3D70ALL;
              v12 = reverb_GetParamfv;
              v13 = reverb_GetParamf;
              v14 = reverb_GetParamiv;
              v15 = reverb_GetParami;
              v8[52] = 1;
              v16 = reverb_SetParamfv;
              v17 = reverb_SetParamf;
              *(_QWORD *)(v8 + 36) = 0x3C3439583FA147AELL;
              *(_QWORD *)(v8 + 44) = 1065252553LL;
              v18 = reverb_SetParamiv;
              v19 = reverb_SetParami;
              break;
            case 4:
              v12 = echo_GetParamfv;
              v13 = echo_GetParamf;
              v14 = echo_GetParamiv;
              v15 = echo_GetParami;
              *((_DWORD *)v8 + 32) = -1082130432;
              v16 = echo_SetParamfv;
              v17 = echo_SetParamf;
              *((_QWORD *)v8 + 14) = 0x3DCCCCCD3DCCCCCDLL;
              *((_QWORD *)v8 + 15) = 0x3F0000003F000000LL;
              v18 = echo_SetParamiv;
              v19 = echo_SetParami;
              break;
            case 9:
              *((_DWORD *)v8 + 34) = 1145569280;
              v12 = mod_GetParamfv;
              v13 = mod_GetParamf;
              v14 = mod_GetParamiv;
              v15 = mod_GetParami;
              *((_DWORD *)v8 + 33) = 1138491392;
              v16 = mod_SetParamfv;
              v17 = mod_SetParamf;
              *((_DWORD *)v8 + 35) = 0;
              v18 = mod_SetParamiv;
              v19 = mod_SetParami;
              break;
          }
        }
        goto LABEL_42;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        p_LastError = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_34;
        }
        goto LABEL_35;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        v21 = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v21) )
        {
          if ( __ldrex(v21) )
            goto LABEL_34;
        }
        goto LABEL_35;
      }
    }
LABEL_34:
    __clrex();
LABEL_35:
    __dmb(0xBu);
    goto LABEL_43;
  }
}

//----- (00253694) --------------------------------------------------------
ALvoid __fastcall alEffectiv(ALuint effect, ALenum param, const ALint *values)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r8
  void (__fastcall **v8)(ALvoid *, ALCcontext *, ALenum, const ALint *); // r0
  unsigned int *p_LastError; // r0

  if ( param == 32769 )
  {
    alEffecti(effect, 32769, *values);
  }
  else
  {
    ContextRef = j_GetContextRef();
    v7 = ContextRef;
    if ( ContextRef )
    {
      v8 = (void (__fastcall **)(ALvoid *, ALCcontext *, ALenum, const ALint *))j_LookupUIntMapKey(
                                                                                  &ContextRef->Device->EffectMap,
                                                                                  effect);
      if ( v8 )
      {
        v8[38](v8, v7, param, values);
      }
      else
      {
        if ( TrapALError )
          raise(5);
        if ( __ldrex((unsigned int *)&v7->ref) )
        {
LABEL_13:
          __clrex();
        }
        else
        {
          p_LastError = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA001u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_13;
          }
        }
        __dmb(0xBu);
      }
      ALCcontext_DecRef(v7);
    }
  }
}

//----- (00253738) --------------------------------------------------------
ALvoid __fastcall alEffectf(ALuint effect, ALenum param, ALfloat value)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  void (__fastcall **v8)(ALvoid *, ALCcontext *, ALenum, _DWORD); // r0
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (void (__fastcall **)(ALvoid *, ALCcontext *, ALenum, _DWORD))j_LookupUIntMapKey(
                                                                         &ContextRef->Device->EffectMap,
                                                                         effect);
    if ( v8 )
    {
      v8[39](v8, v7, param, LODWORD(value));
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&v7->ref) )
      {
LABEL_11:
        __clrex();
      }
      else
      {
        p_LastError = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_11;
        }
      }
      __dmb(0xBu);
    }
    ALCcontext_DecRef(v7);
  }
}

//----- (002537BC) --------------------------------------------------------
ALvoid __fastcall alEffectfv(ALuint effect, ALenum param, const ALfloat *values)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  void (__fastcall **v8)(ALvoid *, ALCcontext *, ALenum, const ALfloat *); // r0
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (void (__fastcall **)(ALvoid *, ALCcontext *, ALenum, const ALfloat *))j_LookupUIntMapKey(
                                                                                  &ContextRef->Device->EffectMap,
                                                                                  effect);
    if ( v8 )
    {
      v8[40](v8, v7, param, values);
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&v7->ref) )
      {
LABEL_11:
        __clrex();
      }
      else
      {
        p_LastError = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_11;
        }
      }
      __dmb(0xBu);
    }
    ALCcontext_DecRef(v7);
  }
}

//----- (00253840) --------------------------------------------------------
ALvoid __fastcall alGetEffecti(ALuint effect, ALenum param, ALint *value)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  ALint *v8; // r0
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (ALint *)j_LookupUIntMapKey(&ContextRef->Device->EffectMap, effect);
    if ( v8 )
    {
      if ( param == 32769 )
        *value = *v8;
      else
        ((void (__fastcall *)(ALint *, ALCcontext *, ALenum, ALint *))v8[41])(v8, v7, param, value);
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&v7->ref) )
      {
LABEL_12:
        __clrex();
        __dmb(0xBu);
      }
      else
      {
        p_LastError = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_12;
        }
        __dmb(0xBu);
      }
    }
    ALCcontext_DecRef(v7);
  }
}

//----- (002538DC) --------------------------------------------------------
ALvoid __fastcall alGetEffectiv(ALuint effect, ALenum param, ALint *values)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  ALint *v8; // r0
  ALCcontext *v9; // r0
  void (__fastcall **v10)(ALvoid *, ALCcontext *, ALenum, ALint *); // r0
  unsigned int *p_LastError; // r0
  unsigned int *v15; // r0

  if ( param == 32769 )
  {
    ContextRef = j_GetContextRef();
    v7 = ContextRef;
    if ( ContextRef )
    {
      v8 = (ALint *)j_LookupUIntMapKey(&ContextRef->Device->EffectMap, effect);
      if ( v8 )
      {
        *values = *v8;
LABEL_24:
        ALCcontext_DecRef(v7);
        return;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        p_LastError = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_22;
        }
        goto LABEL_23;
      }
LABEL_22:
      __clrex();
LABEL_23:
      __dmb(0xBu);
      goto LABEL_24;
    }
  }
  else
  {
    v9 = j_GetContextRef();
    v7 = v9;
    if ( v9 )
    {
      v10 = (void (__fastcall **)(ALvoid *, ALCcontext *, ALenum, ALint *))j_LookupUIntMapKey(
                                                                             &v9->Device->EffectMap,
                                                                             effect);
      if ( v10 )
      {
        v10[42](v10, v7, param, values);
        goto LABEL_24;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        v15 = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v15) )
        {
          if ( __ldrex(v15) )
            goto LABEL_22;
        }
        goto LABEL_23;
      }
      goto LABEL_22;
    }
  }
}

//----- (002539C0) --------------------------------------------------------
ALvoid __fastcall alGetEffectf(ALuint effect, ALenum param, ALfloat *value)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  void (__fastcall **v8)(ALvoid *, ALCcontext *, ALenum, ALfloat *); // r0
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (void (__fastcall **)(ALvoid *, ALCcontext *, ALenum, ALfloat *))j_LookupUIntMapKey(
                                                                            &ContextRef->Device->EffectMap,
                                                                            effect);
    if ( v8 )
    {
      v8[43](v8, v7, param, value);
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&v7->ref) )
      {
LABEL_11:
        __clrex();
      }
      else
      {
        p_LastError = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_11;
        }
      }
      __dmb(0xBu);
    }
    ALCcontext_DecRef(v7);
  }
}

//----- (00253A44) --------------------------------------------------------
ALvoid __fastcall alGetEffectfv(ALuint effect, ALenum param, ALfloat *values)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  void (__fastcall **v8)(ALvoid *, ALCcontext *, ALenum, ALfloat *); // r0
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (void (__fastcall **)(ALvoid *, ALCcontext *, ALenum, ALfloat *))j_LookupUIntMapKey(
                                                                            &ContextRef->Device->EffectMap,
                                                                            effect);
    if ( v8 )
    {
      v8[44](v8, v7, param, values);
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&v7->ref) )
      {
LABEL_11:
        __clrex();
      }
      else
      {
        p_LastError = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_11;
        }
      }
      __dmb(0xBu);
    }
    ALCcontext_DecRef(v7);
  }
}

//----- (00253AC8) --------------------------------------------------------
ALvoid __fastcall ReleaseALEffects(ALCdevice *device)
{
  int v1; // r3
  UIntMap::$8A70C81DF3844826C6730DC5B9E2C72C *v2; // r0
  _DWORD *value; // r1
  unsigned int v4; // r0
  unsigned int v5; // r0
  unsigned int v6; // r0
  unsigned int v7; // r0
  ALenum *v8; // r1
  unsigned int *v9; // r0
  unsigned int v10; // r0
  ALCdevice *v11; // [sp+4h] [bp-2Ch]
  int v12; // [sp+8h] [bp-28h]
  void *p; // [sp+Ch] [bp-24h]
  int v14; // [sp+10h] [bp-20h]

  if ( device->EffectMap.size >= 1 )
  {
    v1 = 0;
    v11 = device;
    do
    {
      v14 = v1;
      v2 = &device->EffectMap.array[v1];
      value = v2->value;
      v2->value = 0;
      p = value;
      v12 = value[45];
      __dmb(0xBu);
      do
        v4 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
      while ( 1 )
      {
        __dmb(0xBu);
        if ( v4 != 1 )
          break;
        sched_yield();
        __dmb(0xBu);
        do
          v4 = __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
      }
      __dmb(0xBu);
      do
        v5 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
      while ( 1 )
      {
        __dmb(0xBu);
        if ( v5 != 1 )
          break;
        sched_yield();
        __dmb(0xBu);
        do
          v5 = __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
      }
      __dmb(0xBu);
      do
        v6 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(v6 + 1, (unsigned int *)&ThunkLock.read_count) );
      __dmb(0xBu);
      if ( !v6 )
      {
        __dmb(0xBu);
        do
          v7 = __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
        while ( 1 )
        {
          __dmb(0xBu);
          if ( v7 != 1 )
            break;
          sched_yield();
          __dmb(0xBu);
          do
            v7 = __ldrex((unsigned int *)&ThunkLock.read_count);
          while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
        }
      }
      __dmb(0xBu);
      do
        __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(0, (unsigned int *)&ThunkLock.read_lock) );
      __dmb(0xBu);
      __dmb(0xBu);
      do
        __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(0, (unsigned int *)&ThunkLock.read_entry_lock) );
      __dmb(0xBu);
      if ( v12 - 1 < ThunkArraySize )
      {
        v8 = ThunkArray;
        __dmb(0xBu);
        v9 = (unsigned int *)&v8[v12 - 1];
        do
          __ldrex(v9);
        while ( __strex(0, v9) );
        __dmb(0xBu);
      }
      __dmb(0xBu);
      do
        v10 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(v10 - 1, (unsigned int *)&ThunkLock.read_count) );
      __dmb(0xBu);
      if ( v10 == 1 )
      {
        __dmb(0xBu);
        do
          __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(0, (unsigned int *)&ThunkLock.write_lock) );
        __dmb(0xBu);
      }
      free(p);
      device = v11;
      v1 = v14 + 1;
    }
    while ( v14 + 1 < v11->EffectMap.size );
  }
}

//----- (00253CB0) --------------------------------------------------------
ALvoid __fastcall LoadReverbPreset(const unsigned __int8 *name, ALeffect_0 *effect)
{
  ALenum v4; // r1
  void (*v5)(ALeffect *, ALCcontext *, ALenum, ALfloat *); // r12
  void (*v6)(ALeffect *, ALCcontext *, ALenum, ALfloat *); // lr
  void (*v7)(ALeffect *, ALCcontext *, ALenum, ALint *); // r8
  void (*v8)(ALeffect *, ALCcontext *, ALenum, ALint *); // r3
  void (*v9)(ALeffect *, ALCcontext *, ALenum, const ALfloat *); // r6
  void (*v10)(ALeffect *, ALCcontext *, ALenum, ALfloat); // r0
  void (*v11)(ALeffect *, ALCcontext *, ALenum, const ALint *); // r2
  void (*v12)(ALeffect *, ALCcontext *, ALenum, ALint); // r5
  const char *v13; // r2
  const unsigned __int8 *v14; // r3
  const char *v15; // r0
  int *p_iDecayHFLimit; // r5
  int v17; // r4

  if ( !strcasecmp((const char *)name, "NONE") )
  {
    effect->type = 0;
    effect->SetParamiv = alEffect_null_SetParamiv;
    effect->SetParami = alEffect_null_SetParami;
    effect->SetParamf = alEffect_null_SetParamf;
    effect->SetParamfv = alEffect_null_SetParamfv;
    effect->GetParami = alEffect_null_GetParami;
    effect->GetParamiv = alEffect_null_GetParamiv;
    effect->GetParamf = alEffect_null_GetParamf;
    effect->GetParamfv = alEffect_null_GetParamfv;
    if ( (unsigned int)LogLevel_0 >= LogTrace )
    {
      v13 = "Loading reverb '%s'\n";
      v14 = "NONE";
      v15 = "(II)";
LABEL_16:
      al_print((const unsigned __int8 *)v15, "LoadReverbPreset", (const unsigned __int8 *)v13, v14);
    }
    return;
  }
  if ( DisabledEffects[0] )
  {
    if ( DisabledEffects[1] )
    {
      v4 = 0;
      v5 = alEffect_null_GetParamfv;
      v6 = alEffect_null_GetParamf;
      v7 = alEffect_null_GetParamiv;
      v8 = alEffect_null_GetParami;
      v9 = alEffect_null_SetParamfv;
      v10 = alEffect_null_SetParamf;
      v11 = alEffect_null_SetParamiv;
      v12 = alEffect_null_SetParami;
      goto LABEL_10;
    }
    *(_QWORD *)&effect->Reverb.DecayTime = 0x3F547AE13FBEB852LL;
    *(_QWORD *)&effect->Reverb.ReflectionsGain = 0x3BE560423D4CCCCDLL;
    *(_QWORD *)&effect->Reverb.Density = 0x3F8000003F800000LL;
    *(_QWORD *)&effect->Reverb.Gain = 0x3F63D70A3EA3D70ALL;
    effect->Reverb.LateReverbGain = 1.26;
    v5 = reverb_GetParamfv;
    v6 = reverb_GetParamf;
    v7 = reverb_GetParamiv;
    v8 = reverb_GetParami;
    v9 = reverb_SetParamfv;
    v10 = reverb_SetParamf;
    effect->Reverb.LateReverbDelay = 0.011;
    v11 = reverb_SetParamiv;
    v12 = reverb_SetParami;
    effect->Reverb.AirAbsorptionGainHF = 0.994;
    v4 = 1;
  }
  else
  {
    effect->Reverb.LateReverbDelay = 0.011;
    *(_QWORD *)&effect->Reverb.GainLF = 0x3F8000003F800000LL;
    *(_QWORD *)effect->Reverb.ReflectionsPan = 0LL;
    *(_QWORD *)&effect->Reverb.DecayTime = 0x3F547AE13FBEB852LL;
    *(_QWORD *)&effect->Reverb.ReflectionsGain = 0x3BE560423D4CCCCDLL;
    *(_QWORD *)&effect->Reverb.Density = 0x3F8000003F800000LL;
    *(_QWORD *)&effect->Reverb.Gain = 0x3F63D70A3EA3D70ALL;
    *(_QWORD *)&effect->Reverb.LateReverbPan[1] = 0LL;
    *(_QWORD *)&effect->Reverb.EchoTime = 1048576000LL;
    *(_QWORD *)&effect->Reverb.ModulationTime = 1048576000LL;
    *(_QWORD *)&effect->Reverb.HFReference = 0x437A0000459C4000LL;
    effect->Reverb.LateReverbGain = 1.26;
    v5 = eaxreverb_GetParamfv;
    v6 = eaxreverb_GetParamf;
    v7 = eaxreverb_GetParamiv;
    v8 = eaxreverb_GetParami;
    v9 = eaxreverb_SetParamfv;
    v10 = eaxreverb_SetParamf;
    effect->Reverb.ReflectionsPan[2] = 0.0;
    effect->Reverb.LateReverbPan[0] = 0.0;
    v11 = eaxreverb_SetParamiv;
    effect->Reverb.AirAbsorptionGainHF = 0.994;
    v4 = 0x8000;
    v12 = eaxreverb_SetParami;
  }
  effect->Reverb.DecayHFLimit = 1;
  effect->Reverb.RoomRolloffFactor = 0.0;
LABEL_10:
  effect->SetParami = v12;
  effect->SetParamiv = v11;
  effect->SetParamf = v10;
  effect->SetParamfv = v9;
  p_iDecayHFLimit = &reverblist[0].props.iDecayHFLimit;
  v17 = -1;
  effect->GetParami = v8;
  effect->GetParamiv = v7;
  effect->GetParamf = v6;
  effect->GetParamfv = v5;
  effect->type = v4;
  do
  {
    if ( !strcasecmp((const char *)name, (const char *)p_iDecayHFLimit - 136) )
    {
      if ( (unsigned int)LogLevel_0 >= LogTrace )
        j_al_print("(II)", "LoadReverbPreset", "Loading reverb '%s'\n", (const char *)p_iDecayHFLimit - 136);
      LODWORD(effect->Reverb.Density) = *(p_iDecayHFLimit - 26);
      LODWORD(effect->Reverb.Diffusion) = *(p_iDecayHFLimit - 25);
      LODWORD(effect->Reverb.Gain) = *(p_iDecayHFLimit - 24);
      LODWORD(effect->Reverb.GainHF) = *(p_iDecayHFLimit - 23);
      LODWORD(effect->Reverb.GainLF) = *(p_iDecayHFLimit - 22);
      LODWORD(effect->Reverb.DecayTime) = *(p_iDecayHFLimit - 21);
      LODWORD(effect->Reverb.DecayHFRatio) = *(p_iDecayHFLimit - 20);
      LODWORD(effect->Reverb.DecayLFRatio) = *(p_iDecayHFLimit - 19);
      LODWORD(effect->Reverb.ReflectionsGain) = *(p_iDecayHFLimit - 18);
      LODWORD(effect->Reverb.ReflectionsDelay) = *(p_iDecayHFLimit - 17);
      LODWORD(effect->Reverb.ReflectionsPan[0]) = *(p_iDecayHFLimit - 16);
      LODWORD(effect->Reverb.ReflectionsPan[1]) = *(p_iDecayHFLimit - 15);
      LODWORD(effect->Reverb.ReflectionsPan[2]) = *(p_iDecayHFLimit - 14);
      LODWORD(effect->Reverb.LateReverbGain) = *(p_iDecayHFLimit - 13);
      LODWORD(effect->Reverb.LateReverbDelay) = *(p_iDecayHFLimit - 12);
      LODWORD(effect->Reverb.LateReverbPan[0]) = *(p_iDecayHFLimit - 11);
      LODWORD(effect->Reverb.LateReverbPan[1]) = *(p_iDecayHFLimit - 10);
      LODWORD(effect->Reverb.LateReverbPan[2]) = *(p_iDecayHFLimit - 9);
      LODWORD(effect->Reverb.EchoTime) = *(p_iDecayHFLimit - 8);
      LODWORD(effect->Reverb.EchoDepth) = *(p_iDecayHFLimit - 7);
      LODWORD(effect->Reverb.ModulationTime) = *(p_iDecayHFLimit - 6);
      LODWORD(effect->Reverb.ModulationDepth) = *(p_iDecayHFLimit - 5);
      LODWORD(effect->Reverb.AirAbsorptionGainHF) = *(p_iDecayHFLimit - 4);
      LODWORD(effect->Reverb.HFReference) = *(p_iDecayHFLimit - 3);
      LODWORD(effect->Reverb.LFReference) = *(p_iDecayHFLimit - 2);
      LODWORD(effect->Reverb.RoomRolloffFactor) = *(p_iDecayHFLimit - 1);
      effect->Reverb.DecayHFLimit = *p_iDecayHFLimit;
      return;
    }
    ++v17;
    p_iDecayHFLimit += 35;
  }
  while ( v17 < 112 );
  if ( v17 == 112 && (unsigned int)LogLevel_0 >= LogWarning )
  {
    v13 = "Reverb preset '%s' not found\n";
    v14 = name;
    v15 = "(WW)";
    goto LABEL_16;
  }
}

//----- (00254128) --------------------------------------------------------
unsigned int alGetError()
{
  ALCcontext *ContextRef; // r0
  unsigned int *p_LastError; // r1
  unsigned int v2; // r4

  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    p_LastError = (unsigned int *)&ContextRef->LastError;
    __dmb(0xBu);
    do
      v2 = __ldrex(p_LastError);
    while ( __strex(0, p_LastError) );
    __dmb(0xBu);
    j_ALCcontext_DecRef(ContextRef);
    return v2;
  }
  else
  {
    if ( TrapALError )
      raise(5);
    return 40964;
  }
}

//----- (00254174) --------------------------------------------------------
ALboolean __fastcall alIsExtensionPresent(const ALchar *extName)
{
  ALCcontext *ContextRef; // r8
  char *ExtensionList; // r4
  size_t v4; // r9
  int v5; // r6
  int v6; // t1
  ALboolean v7; // r4
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    if ( extName )
    {
      ExtensionList = (char *)ContextRef->ExtensionList;
      v4 = strlen((const char *)extName);
      if ( ExtensionList && *ExtensionList )
      {
        while ( strncasecmp(ExtensionList, (const char *)extName, v4)
             || ExtensionList[v4] && !isspace((unsigned __int8)ExtensionList[v4]) )
        {
          ExtensionList = strchr(ExtensionList, 32);
          if ( ExtensionList )
          {
            do
            {
              v6 = (unsigned __int8)*++ExtensionList;
              v5 = v6;
            }
            while ( isspace(v6) );
            if ( v5 )
              continue;
          }
          goto LABEL_21;
        }
        v7 = 1;
        goto LABEL_22;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&ContextRef->ref) )
      {
LABEL_19:
        __clrex();
      }
      else
      {
        p_LastError = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_19;
        }
      }
      __dmb(0xBu);
    }
LABEL_21:
    v7 = 0;
LABEL_22:
    j_ALCcontext_DecRef(ContextRef);
    return v7;
  }
  return 0;
}

//----- (0025422C) --------------------------------------------------------
void *__fastcall alGetProcAddress(const ALchar *funcName)
{
  int v2; // r5

  if ( !funcName )
    return 0;
  v2 = 0;
  while ( strcmp((const char *)alcFunctions[v2].funcName, (const char *)funcName) )
  {
    if ( ++v2 == 152 )
    {
      v2 = 152;
      return alcFunctions[v2].address;
    }
  }
  return alcFunctions[v2].address;
}

//----- (00254274) --------------------------------------------------------
ALenum __fastcall alGetEnumValue(const ALchar *enumName)
{
  int v2; // r5
  int v3; // r0

  if ( !enumName )
    return 0;
  v2 = 0;
  while ( strcmp((const char *)enumeration[v2].enumName, (const char *)enumName) )
  {
    ++v2;
    v3 = 259;
    if ( v2 == 259 )
      return enumeration[v3].value;
  }
  v3 = v2;
  return enumeration[v3].value;
}

//----- (002542C0) --------------------------------------------------------
ALvoid __fastcall alGenFilters(ALsizei n, ALuint *filters)
{
  ALCcontext *ContextRef; // r0
  unsigned int *p_LastError; // r4
  int v5; // r4
  ALuint *v6; // r0
  ALuint *v7; // r6
  ALenum v8; // r0
  ALuint v9; // r4
  unsigned int v10; // r5
  ALenum inserted; // r0
  unsigned int v12; // r0
  unsigned int v13; // r0
  unsigned int v14; // r0
  unsigned int v15; // r0
  ALenum *v16; // r1
  unsigned int *v17; // r0
  unsigned int v18; // r0
  bool v21; // zf
  unsigned int *v26; // [sp+4h] [bp-34h]
  ALCcontext *v27; // [sp+8h] [bp-30h]
  ALsizei v28; // [sp+Ch] [bp-2Ch]
  UIntMap_0 *map; // [sp+14h] [bp-24h]
  int v31; // [sp+18h] [bp-20h]

  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    v27 = ContextRef;
    p_LastError = (unsigned int *)&ContextRef->LastError;
    v26 = (unsigned int *)&ContextRef->LastError;
    v28 = n;
    while ( n >= 0 )
    {
      if ( n < 1 )
        goto LABEL_66;
      v5 = 0;
      map = &v27->Device->FilterMap;
      while ( 1 )
      {
        v6 = (ALuint *)calloc(1u, 0x30u);
        v7 = v6;
        v31 = v5;
        if ( !v6 )
        {
          if ( TrapALError )
            raise(5);
          if ( __ldrex(v26) )
          {
LABEL_62:
            __clrex();
          }
          else
          {
            __dmb(0xBu);
            while ( __strex(0xA005u, v26) )
            {
              if ( __ldrex(v26) )
                goto LABEL_62;
            }
          }
          __dmb(0xBu);
          goto LABEL_64;
        }
        v6[3] = (ALuint)null_SetParami;
        v6[4] = (ALuint)null_SetParamiv;
        v6[5] = (ALuint)null_SetParamf;
        v6[6] = (ALuint)null_SetParamfv;
        v6[7] = (ALuint)null_GetParami;
        v6[8] = (ALuint)null_GetParamiv;
        v6[9] = (ALuint)null_GetParamf;
        v6[10] = (ALuint)null_GetParamfv;
        v8 = j_NewThunkEntry(v6 + 11);
        v9 = v7[11];
        v10 = v8;
        if ( v8 )
          break;
        inserted = j_InsertUIntMapEntry(map, v7[11], v7);
        v9 = v7[11];
        v10 = inserted;
        if ( inserted )
          break;
        filters[v31] = v9;
        v5 = v31 + 1;
        if ( v31 + 1 >= v28 )
          goto LABEL_66;
      }
      __dmb(0xBu);
      do
        v12 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
      while ( 1 )
      {
        __dmb(0xBu);
        if ( v12 != 1 )
          break;
        sched_yield();
        __dmb(0xBu);
        do
          v12 = __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
      }
      __dmb(0xBu);
      do
        v13 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
      while ( 1 )
      {
        __dmb(0xBu);
        if ( v13 != 1 )
          break;
        sched_yield();
        __dmb(0xBu);
        do
          v13 = __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
      }
      __dmb(0xBu);
      do
        v14 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(v14 + 1, (unsigned int *)&ThunkLock.read_count) );
      __dmb(0xBu);
      if ( !v14 )
      {
        __dmb(0xBu);
        do
          v15 = __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
        while ( 1 )
        {
          __dmb(0xBu);
          if ( v15 != 1 )
            break;
          sched_yield();
          __dmb(0xBu);
          do
            v15 = __ldrex((unsigned int *)&ThunkLock.read_count);
          while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
        }
      }
      __dmb(0xBu);
      do
        __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(0, (unsigned int *)&ThunkLock.read_lock) );
      __dmb(0xBu);
      __dmb(0xBu);
      do
        __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(0, (unsigned int *)&ThunkLock.read_entry_lock) );
      __dmb(0xBu);
      if ( v9 - 1 < ThunkArraySize )
      {
        v16 = ThunkArray;
        __dmb(0xBu);
        v17 = (unsigned int *)&v16[v9 - 1];
        do
          __ldrex(v17);
        while ( __strex(0, v17) );
        __dmb(0xBu);
      }
      __dmb(0xBu);
      do
        v18 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(v18 - 1, (unsigned int *)&ThunkLock.read_count) );
      __dmb(0xBu);
      if ( v18 == 1 )
      {
        __dmb(0xBu);
        do
          __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(0, (unsigned int *)&ThunkLock.write_lock) );
        __dmb(0xBu);
      }
      free(v7);
      if ( TrapALError )
        raise(5);
      p_LastError = v26;
      if ( __ldrex(v26) )
      {
LABEL_52:
        __clrex();
      }
      else
      {
        __dmb(0xBu);
        while ( __strex(v10, v26) )
        {
          if ( __ldrex(v26) )
            goto LABEL_52;
        }
      }
      __dmb(0xBu);
      v21 = v10 == 0;
      n = v28;
      if ( !v21 )
      {
LABEL_64:
        if ( v31 >= 1 )
          j_alDeleteFilters(v31, filters);
        goto LABEL_66;
      }
    }
    if ( TrapALError )
      raise(5);
    if ( __ldrex(p_LastError) )
    {
LABEL_73:
      __clrex();
    }
    else
    {
      __dmb(0xBu);
      while ( __strex(0xA003u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
          goto LABEL_73;
      }
    }
    __dmb(0xBu);
LABEL_66:
    ALCcontext_DecRef(v27);
  }
}

//----- (00254604) --------------------------------------------------------
ALvoid __fastcall alDeleteFilters(ALsizei n, const ALuint *filters)
{
  ALCcontext *ContextRef; // r0
  unsigned int *p_ref; // r4
  int v6; // r4
  UIntMap_0 *p_FilterMap; // r9
  ALuint v8; // r1
  int v9; // r1
  ALvoid *v10; // r0
  unsigned int v11; // r0
  unsigned int v12; // r0
  unsigned int v13; // r0
  unsigned int v14; // r0
  ALenum *v15; // r1
  unsigned int *v16; // r0
  unsigned int v17; // r0
  unsigned int *v19; // r0
  unsigned int *p_LastError; // r0
  ALCcontext *v24; // [sp+0h] [bp-38h]
  int v25; // [sp+10h] [bp-28h]
  void *p; // [sp+14h] [bp-24h]
  int v27; // [sp+18h] [bp-20h]

  ContextRef = j_GetContextRef();
  p_ref = (unsigned int *)&ContextRef->ref;
  if ( ContextRef )
  {
    v24 = ContextRef;
    if ( n < 0 )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex(p_ref) )
      {
        v19 = p_ref + 20;
        __dmb(0xBu);
        while ( __strex(0xA003u, v19) )
        {
          if ( __ldrex(v19) )
            goto LABEL_62;
        }
        goto LABEL_63;
      }
    }
    else
    {
      if ( !n )
      {
LABEL_64:
        ALCcontext_DecRef(v24);
        return;
      }
      v6 = 0;
      p_FilterMap = &ContextRef->Device->FilterMap;
      while ( 1 )
      {
        v8 = filters[v6];
        if ( v8 )
        {
          if ( !j_LookupUIntMapKey(p_FilterMap, v8) )
            break;
        }
        if ( ++v6 >= n )
        {
          v9 = 0;
          do
          {
            v27 = v9;
            v10 = j_RemoveUIntMapKey(p_FilterMap, filters[v9]);
            if ( v10 )
            {
              p = v10;
              v25 = *((_DWORD *)v10 + 11);
              __dmb(0xBu);
              do
                v11 = __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
              while ( 1 )
              {
                __dmb(0xBu);
                if ( v11 != 1 )
                  break;
                sched_yield();
                __dmb(0xBu);
                do
                  v11 = __ldrex((unsigned int *)&ThunkLock.read_count);
                while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
              }
              __dmb(0xBu);
              do
                v12 = __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
              while ( 1 )
              {
                __dmb(0xBu);
                if ( v12 != 1 )
                  break;
                sched_yield();
                __dmb(0xBu);
                do
                  v12 = __ldrex((unsigned int *)&ThunkLock.read_count);
                while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
              }
              __dmb(0xBu);
              do
                v13 = __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(v13 + 1, (unsigned int *)&ThunkLock.read_count) );
              __dmb(0xBu);
              if ( !v13 )
              {
                __dmb(0xBu);
                do
                  v14 = __ldrex((unsigned int *)&ThunkLock.read_count);
                while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
                while ( 1 )
                {
                  __dmb(0xBu);
                  if ( v14 != 1 )
                    break;
                  sched_yield();
                  __dmb(0xBu);
                  do
                    v14 = __ldrex((unsigned int *)&ThunkLock.read_count);
                  while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
                }
              }
              __dmb(0xBu);
              do
                __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(0, (unsigned int *)&ThunkLock.read_lock) );
              __dmb(0xBu);
              __dmb(0xBu);
              do
                __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(0, (unsigned int *)&ThunkLock.read_entry_lock) );
              __dmb(0xBu);
              if ( v25 - 1 < ThunkArraySize )
              {
                v15 = ThunkArray;
                __dmb(0xBu);
                v16 = (unsigned int *)&v15[v25 - 1];
                do
                  __ldrex(v16);
                while ( __strex(0, v16) );
                __dmb(0xBu);
              }
              __dmb(0xBu);
              do
                v17 = __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(v17 - 1, (unsigned int *)&ThunkLock.read_count) );
              __dmb(0xBu);
              if ( v17 == 1 )
              {
                __dmb(0xBu);
                do
                  __ldrex((unsigned int *)&ThunkLock.read_count);
                while ( __strex(0, (unsigned int *)&ThunkLock.write_lock) );
                __dmb(0xBu);
              }
              free(p);
            }
            v9 = v27 + 1;
          }
          while ( v27 + 1 != n );
          goto LABEL_64;
        }
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v24->ref) )
      {
        p_LastError = (unsigned int *)&v24->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_62;
        }
        goto LABEL_63;
      }
    }
LABEL_62:
    __clrex();
LABEL_63:
    __dmb(0xBu);
    goto LABEL_64;
  }
}
// 25465E: conditional instruction was optimized away because r6.4>=1

//----- (002548B4) --------------------------------------------------------
ALboolean __fastcall alIsFilter(ALuint filter)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v3; // r4
  bool v4; // r5

  ContextRef = j_GetContextRef();
  v3 = ContextRef;
  if ( !ContextRef )
    return 0;
  if ( filter )
    v4 = j_LookupUIntMapKey(&ContextRef->Device->FilterMap, filter) != 0;
  else
    v4 = 1;
  j_ALCcontext_DecRef(v3);
  return v4;
}

//----- (002548EC) --------------------------------------------------------
ALvoid __fastcall alFilteri(ALuint filter, ALenum param, ALint value)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  void (__fastcall **v8)(ALvoid *, ALCcontext *, ALenum, ALint); // r0
  void (__fastcall *v9)(ALfilter_0 *, ALCcontext *, ALenum, ALfloat *); // r12
  void (__fastcall *v10)(ALfilter_0 *, ALCcontext *, ALenum, ALfloat *); // lr
  void (__fastcall *v11)(ALfilter_0 *, ALCcontext *, ALenum, ALint *); // r9
  void (__fastcall *v12)(ALfilter_0 *, ALCcontext *, ALenum, ALint *); // r6
  void (__fastcall *v13)(ALfilter_0 *, ALCcontext *, ALenum, const ALfloat *); // r5
  void (__fastcall *v14)(ALfilter_0 *, ALCcontext *, ALenum, ALfloat); // r1
  void (__fastcall *v15)(ALfilter_0 *, ALCcontext *, ALenum, const ALint *); // r2
  void (__fastcall *v16)(ALfilter_0 *, ALCcontext *, ALenum, ALint); // r3
  unsigned int *v18; // r0
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (void (__fastcall **)(ALvoid *, ALCcontext *, ALenum, ALint))j_LookupUIntMapKey(
                                                                        &ContextRef->Device->FilterMap,
                                                                        filter);
    if ( v8 )
    {
      if ( param != 32769 )
      {
        v8[3](v8, v7, param, value);
LABEL_26:
        ALCcontext_DecRef(v7);
        return;
      }
      if ( (unsigned int)value <= 1 )
      {
        if ( value == 1 )
        {
          v9 = lp_GetParamfv;
          v10 = lp_GetParamf;
          v11 = lp_GetParamiv;
          v12 = lp_GetParami;
          v13 = lp_SetParamfv;
          v8[1] = (void (__fastcall *)(ALvoid *, ALCcontext *, ALenum, ALint))1065353216;
          v8[2] = (void (__fastcall *)(ALvoid *, ALCcontext *, ALenum, ALint))1065353216;
          v14 = lp_SetParamf;
          v15 = lp_SetParamiv;
          v16 = lp_SetParami;
        }
        else
        {
          v9 = null_GetParamfv;
          v10 = null_GetParamf;
          v11 = null_GetParamiv;
          v12 = null_GetParami;
          v13 = null_SetParamfv;
          v14 = null_SetParamf;
          v15 = null_SetParamiv;
          v16 = null_SetParami;
        }
        v8[3] = (void (__fastcall *)(ALvoid *, ALCcontext *, ALenum, ALint))v16;
        v8[4] = (void (__fastcall *)(ALvoid *, ALCcontext *, ALenum, ALint))v15;
        v8[5] = (void (__fastcall *)(ALvoid *, ALCcontext *, ALenum, ALint))v14;
        v8[6] = (void (__fastcall *)(ALvoid *, ALCcontext *, ALenum, ALint))v13;
        v8[7] = (void (__fastcall *)(ALvoid *, ALCcontext *, ALenum, ALint))v12;
        v8[8] = (void (__fastcall *)(ALvoid *, ALCcontext *, ALenum, ALint))v11;
        v8[9] = (void (__fastcall *)(ALvoid *, ALCcontext *, ALenum, ALint))v10;
        v8[10] = (void (__fastcall *)(ALvoid *, ALCcontext *, ALenum, ALint))v9;
        *v8 = (void (__fastcall *)(ALvoid *, ALCcontext *, ALenum, ALint))value;
        goto LABEL_26;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        p_LastError = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_22;
        }
        goto LABEL_23;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        v18 = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v18) )
        {
          if ( __ldrex(v18) )
            goto LABEL_22;
        }
        goto LABEL_23;
      }
    }
LABEL_22:
    __clrex();
LABEL_23:
    __dmb(0xBu);
    goto LABEL_26;
  }
}

//----- (00254A68) --------------------------------------------------------
ALvoid __fastcall alFilteriv(ALuint filter, ALenum param, const ALint *values)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r8
  void (__fastcall **v8)(ALvoid *, ALCcontext *, ALenum, const ALint *); // r0
  unsigned int *p_LastError; // r0

  if ( param == 32769 )
  {
    alFilteri(filter, 32769, *values);
  }
  else
  {
    ContextRef = j_GetContextRef();
    v7 = ContextRef;
    if ( ContextRef )
    {
      v8 = (void (__fastcall **)(ALvoid *, ALCcontext *, ALenum, const ALint *))j_LookupUIntMapKey(
                                                                                  &ContextRef->Device->FilterMap,
                                                                                  filter);
      if ( v8 )
      {
        v8[4](v8, v7, param, values);
      }
      else
      {
        if ( TrapALError )
          raise(5);
        if ( __ldrex((unsigned int *)&v7->ref) )
        {
LABEL_13:
          __clrex();
        }
        else
        {
          p_LastError = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA001u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_13;
          }
        }
        __dmb(0xBu);
      }
      ALCcontext_DecRef(v7);
    }
  }
}

//----- (00254B08) --------------------------------------------------------
ALvoid __fastcall alFilterf(ALuint filter, ALenum param, ALfloat value)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  void (__fastcall **v8)(ALvoid *, ALCcontext *, ALenum, _DWORD); // r0
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (void (__fastcall **)(ALvoid *, ALCcontext *, ALenum, _DWORD))j_LookupUIntMapKey(
                                                                         &ContextRef->Device->FilterMap,
                                                                         filter);
    if ( v8 )
    {
      v8[5](v8, v7, param, LODWORD(value));
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&v7->ref) )
      {
LABEL_11:
        __clrex();
      }
      else
      {
        p_LastError = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_11;
        }
      }
      __dmb(0xBu);
    }
    ALCcontext_DecRef(v7);
  }
}

//----- (00254B8C) --------------------------------------------------------
ALvoid __fastcall alFilterfv(ALuint filter, ALenum param, const ALfloat *values)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  void (__fastcall **v8)(ALvoid *, ALCcontext *, ALenum, const ALfloat *); // r0
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (void (__fastcall **)(ALvoid *, ALCcontext *, ALenum, const ALfloat *))j_LookupUIntMapKey(
                                                                                  &ContextRef->Device->FilterMap,
                                                                                  filter);
    if ( v8 )
    {
      v8[6](v8, v7, param, values);
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&v7->ref) )
      {
LABEL_11:
        __clrex();
      }
      else
      {
        p_LastError = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_11;
        }
      }
      __dmb(0xBu);
    }
    ALCcontext_DecRef(v7);
  }
}

//----- (00254C10) --------------------------------------------------------
ALvoid __fastcall alGetFilteri(ALuint filter, ALenum param, ALint *value)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  ALint *v8; // r0
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (ALint *)j_LookupUIntMapKey(&ContextRef->Device->FilterMap, filter);
    if ( v8 )
    {
      if ( param == 32769 )
        *value = *v8;
      else
        ((void (__fastcall *)(ALint *, ALCcontext *, ALenum, ALint *))v8[7])(v8, v7, param, value);
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&v7->ref) )
      {
LABEL_12:
        __clrex();
        __dmb(0xBu);
      }
      else
      {
        p_LastError = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_12;
        }
        __dmb(0xBu);
      }
    }
    ALCcontext_DecRef(v7);
  }
}

//----- (00254CA8) --------------------------------------------------------
ALvoid __fastcall alGetFilteriv(ALuint filter, ALenum param, ALint *values)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  ALint *v8; // r0
  ALCcontext *v9; // r0
  void (__fastcall **v10)(ALvoid *, ALCcontext *, ALenum, ALint *); // r0
  unsigned int *p_LastError; // r0
  unsigned int *v15; // r0

  if ( param == 32769 )
  {
    ContextRef = j_GetContextRef();
    v7 = ContextRef;
    if ( ContextRef )
    {
      v8 = (ALint *)j_LookupUIntMapKey(&ContextRef->Device->FilterMap, filter);
      if ( v8 )
      {
        *values = *v8;
LABEL_24:
        ALCcontext_DecRef(v7);
        return;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        p_LastError = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_22;
        }
        goto LABEL_23;
      }
LABEL_22:
      __clrex();
LABEL_23:
      __dmb(0xBu);
      goto LABEL_24;
    }
  }
  else
  {
    v9 = j_GetContextRef();
    v7 = v9;
    if ( v9 )
    {
      v10 = (void (__fastcall **)(ALvoid *, ALCcontext *, ALenum, ALint *))j_LookupUIntMapKey(
                                                                             &v9->Device->FilterMap,
                                                                             filter);
      if ( v10 )
      {
        v10[8](v10, v7, param, values);
        goto LABEL_24;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        v15 = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v15) )
        {
          if ( __ldrex(v15) )
            goto LABEL_22;
        }
        goto LABEL_23;
      }
      goto LABEL_22;
    }
  }
}

//----- (00254D88) --------------------------------------------------------
ALvoid __fastcall alGetFilterf(ALuint filter, ALenum param, ALfloat *value)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  void (__fastcall **v8)(ALvoid *, ALCcontext *, ALenum, ALfloat *); // r0
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (void (__fastcall **)(ALvoid *, ALCcontext *, ALenum, ALfloat *))j_LookupUIntMapKey(
                                                                            &ContextRef->Device->FilterMap,
                                                                            filter);
    if ( v8 )
    {
      v8[9](v8, v7, param, value);
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&v7->ref) )
      {
LABEL_11:
        __clrex();
      }
      else
      {
        p_LastError = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_11;
        }
      }
      __dmb(0xBu);
    }
    ALCcontext_DecRef(v7);
  }
}

//----- (00254E0C) --------------------------------------------------------
ALvoid __fastcall alGetFilterfv(ALuint filter, ALenum param, ALfloat *values)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  void (__fastcall **v8)(ALvoid *, ALCcontext *, ALenum, ALfloat *); // r0
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (void (__fastcall **)(ALvoid *, ALCcontext *, ALenum, ALfloat *))j_LookupUIntMapKey(
                                                                            &ContextRef->Device->FilterMap,
                                                                            filter);
    if ( v8 )
    {
      v8[10](v8, v7, param, values);
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&v7->ref) )
      {
LABEL_11:
        __clrex();
      }
      else
      {
        p_LastError = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_11;
        }
      }
      __dmb(0xBu);
    }
    ALCcontext_DecRef(v7);
  }
}

//----- (00254E90) --------------------------------------------------------
ALfloat __fastcall lpCoeffCalc(ALfloat g, ALfloat cw)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d4
  float v5; // s0

  v2.n64_f32[0] = g;
  if ( g >= 0.9999 )
    return 0.0;
  v3.n64_u32[0] = 981668463;
  v5 = vmax_f32(v2, v3).n64_f32[0];
  return (float)((float)(1.0 - (float)(v5 * cw))
               - sqrtf(
                   (float)((float)(1.0 - cw) * (float)(v5 + v5))
                 - (float)((float)(v5 * v5) * (float)(1.0 - (float)(cw * cw)))))
       / (float)(1.0 - v5);
}
// 254EBC: variable 'v2' is possibly undefined
// 254EBC: variable 'v3' is possibly undefined

//----- (00254F08) --------------------------------------------------------
ALvoid __fastcall ReleaseALFilters(ALCdevice *device)
{
  int v1; // r3
  UIntMap::$8A70C81DF3844826C6730DC5B9E2C72C *v2; // r0
  _DWORD *value; // r1
  unsigned int v4; // r0
  unsigned int v5; // r0
  unsigned int v6; // r0
  unsigned int v7; // r0
  ALenum *v8; // r1
  unsigned int *v9; // r0
  unsigned int v10; // r0
  ALCdevice *v11; // [sp+4h] [bp-2Ch]
  int v12; // [sp+8h] [bp-28h]
  void *p; // [sp+Ch] [bp-24h]
  int v14; // [sp+10h] [bp-20h]

  if ( device->FilterMap.size >= 1 )
  {
    v1 = 0;
    v11 = device;
    do
    {
      v14 = v1;
      v2 = &device->FilterMap.array[v1];
      value = v2->value;
      v2->value = 0;
      p = value;
      v12 = value[11];
      __dmb(0xBu);
      do
        v4 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
      while ( 1 )
      {
        __dmb(0xBu);
        if ( v4 != 1 )
          break;
        sched_yield();
        __dmb(0xBu);
        do
          v4 = __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
      }
      __dmb(0xBu);
      do
        v5 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
      while ( 1 )
      {
        __dmb(0xBu);
        if ( v5 != 1 )
          break;
        sched_yield();
        __dmb(0xBu);
        do
          v5 = __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
      }
      __dmb(0xBu);
      do
        v6 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(v6 + 1, (unsigned int *)&ThunkLock.read_count) );
      __dmb(0xBu);
      if ( !v6 )
      {
        __dmb(0xBu);
        do
          v7 = __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
        while ( 1 )
        {
          __dmb(0xBu);
          if ( v7 != 1 )
            break;
          sched_yield();
          __dmb(0xBu);
          do
            v7 = __ldrex((unsigned int *)&ThunkLock.read_count);
          while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
        }
      }
      __dmb(0xBu);
      do
        __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(0, (unsigned int *)&ThunkLock.read_lock) );
      __dmb(0xBu);
      __dmb(0xBu);
      do
        __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(0, (unsigned int *)&ThunkLock.read_entry_lock) );
      __dmb(0xBu);
      if ( v12 - 1 < ThunkArraySize )
      {
        v8 = ThunkArray;
        __dmb(0xBu);
        v9 = (unsigned int *)&v8[v12 - 1];
        do
          __ldrex(v9);
        while ( __strex(0, v9) );
        __dmb(0xBu);
      }
      __dmb(0xBu);
      do
        v10 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(v10 - 1, (unsigned int *)&ThunkLock.read_count) );
      __dmb(0xBu);
      if ( v10 == 1 )
      {
        __dmb(0xBu);
        do
          __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(0, (unsigned int *)&ThunkLock.write_lock) );
        __dmb(0xBu);
      }
      free(p);
      device = v11;
      v1 = v14 + 1;
    }
    while ( v14 + 1 < v11->FilterMap.size );
  }
}

//----- (002550EC) --------------------------------------------------------
void __fastcall alListenerf(ALenum param, ALfloat value)
{
  ALCcontext *ContextRef; // r4
  ALfloat *p_MetersPerUnit; // r0
  unsigned int *v7; // r0
  unsigned int *v10; // r0
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    if ( (int *)param == &elf_hash_chain[16295] )
    {
      if ( value >= 0.0 && fabsf(value) != INFINITY )
      {
        p_MetersPerUnit = (ALfloat *)&ContextRef->Listener->MetersPerUnit;
        goto LABEL_11;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        p_LastError = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_32;
        }
        goto LABEL_33;
      }
    }
    else if ( param == 4106 )
    {
      if ( value >= 0.0 && fabsf(value) != INFINITY )
      {
        p_MetersPerUnit = (ALfloat *)&ContextRef->Listener->Gain;
LABEL_11:
        *p_MetersPerUnit = value;
        ContextRef->UpdateSources = 1;
LABEL_34:
        ALCcontext_DecRef(ContextRef);
        return;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        v10 = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v10) )
        {
          if ( __ldrex(v10) )
            goto LABEL_32;
        }
        goto LABEL_33;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        v7 = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, v7) )
        {
          if ( __ldrex(v7) )
            goto LABEL_32;
        }
        goto LABEL_33;
      }
    }
LABEL_32:
    __clrex();
LABEL_33:
    __dmb(0xBu);
    goto LABEL_34;
  }
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (0025522C) --------------------------------------------------------
void __fastcall alListener3f(ALenum param, ALfloat value1, ALfloat value2, ALfloat value3)
{
  ALCcontext *ContextRef; // r8
  ALCdevice *Device; // r0
  unsigned int *v11; // r0
  unsigned int *v14; // r0
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    if ( param == 4102 )
    {
      if ( fabsf(value1) != INFINITY && fabsf(value3) != INFINITY )
      {
        (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref + (unsigned int)&elf_hash_chain[6161])
                          + 44))();
        ContextRef->Listener->Velocity[0] = value1;
        ContextRef->Listener->Velocity[1] = value2;
        ContextRef->Listener->Velocity[2] = value3;
        goto LABEL_11;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        p_LastError = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_32;
        }
        goto LABEL_33;
      }
    }
    else if ( param == 4100 )
    {
      if ( fabsf(value1) != INFINITY && fabsf(value3) != INFINITY )
      {
        (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref + (unsigned int)&elf_hash_chain[6161])
                          + 44))();
        ContextRef->Listener->Position[0] = value1;
        ContextRef->Listener->Position[1] = value2;
        ContextRef->Listener->Position[2] = value3;
LABEL_11:
        Device = ContextRef->Device;
        ContextRef->UpdateSources = 1;
        (*(void (**)(void))(*(int *)((char *)&elf_hash_chain[6161] + (_DWORD)Device) + 48))();
LABEL_34:
        ALCcontext_DecRef(ContextRef);
        return;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        v14 = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v14) )
        {
          if ( __ldrex(v14) )
            goto LABEL_32;
        }
        goto LABEL_33;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        v11 = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, v11) )
        {
          if ( __ldrex(v11) )
            goto LABEL_32;
        }
        goto LABEL_33;
      }
    }
LABEL_32:
    __clrex();
LABEL_33:
    __dmb(0xBu);
    goto LABEL_34;
  }
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (002553FC) --------------------------------------------------------
void __fastcall alListenerfv(ALenum param, const ALfloat *values)
{
  bool v4; // zf
  bool v5; // zf
  ALCcontext *ContextRef; // r4
  ALCdevice *Device; // r0
  unsigned int *v9; // r0
  unsigned int *v12; // r0
  unsigned int *p_LastError; // r0

  if ( values )
  {
    if ( param > 4105 )
    {
      v5 = param == 131076;
      if ( param != 131076 )
        v5 = param == 4106;
      if ( v5 )
      {
        alListenerf(param, *values);
        return;
      }
    }
    else
    {
      v4 = param == 4100;
      if ( param != 4100 )
        v4 = param == 4102;
      if ( v4 )
      {
        alListener3f(param, *values, values[1], values[2]);
        return;
      }
    }
  }
  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    if ( values )
    {
      if ( param == 4111 )
      {
        if ( fabsf(*values) != INFINITY
          && fabsf(values[1]) != INFINITY
          && fabsf(values[2]) != INFINITY
          && fabsf(values[3]) != INFINITY
          && fabsf(values[4]) != INFINITY
          && fabsf(values[5]) != INFINITY )
        {
          (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref
                                                   + (unsigned int)&elf_hash_chain[6161])
                            + 44))();
          ContextRef->Listener->Forward[0] = *values;
          ContextRef->Listener->Forward[1] = values[1];
          ContextRef->Listener->Forward[2] = values[2];
          ContextRef->Listener->Up[0] = values[3];
          ContextRef->Listener->Up[1] = values[4];
          ContextRef->Listener->Up[2] = values[5];
          Device = ContextRef->Device;
          ContextRef->UpdateSources = 1;
          (*(void (**)(void))(*(int *)((char *)&elf_hash_chain[6161] + (_DWORD)Device) + 48))();
LABEL_46:
          ALCcontext_DecRef(ContextRef);
          return;
        }
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&ContextRef->ref) )
        {
          p_LastError = (unsigned int *)&ContextRef->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_44;
          }
          goto LABEL_45;
        }
      }
      else
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&ContextRef->ref) )
        {
          v12 = (unsigned int *)&ContextRef->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, v12) )
          {
            if ( __ldrex(v12) )
              goto LABEL_44;
          }
          goto LABEL_45;
        }
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        v9 = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v9) )
        {
          if ( __ldrex(v9) )
            goto LABEL_44;
        }
        goto LABEL_45;
      }
    }
LABEL_44:
    __clrex();
LABEL_45:
    __dmb(0xBu);
    goto LABEL_46;
  }
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (002555E8) --------------------------------------------------------
void __fastcall alListeneri(ALenum param, ALint value)
{
  ALCcontext *ContextRef; // r4
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    if ( TrapALError )
      raise(5);
    if ( __ldrex((unsigned int *)&ContextRef->ref) )
    {
LABEL_8:
      __clrex();
    }
    else
    {
      p_LastError = (unsigned int *)&ContextRef->LastError;
      __dmb(0xBu);
      while ( __strex(0xA002u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
          goto LABEL_8;
      }
    }
    __dmb(0xBu);
    ALCcontext_DecRef(ContextRef);
  }
}

//----- (00255640) --------------------------------------------------------
void __fastcall alListener3i(ALenum param, ALint value1, ALint value2, ALint value3)
{
  ALCcontext *ContextRef; // r4
  unsigned int *p_LastError; // r0

  if ( (param | 2) == 4102 )
  {
    alListener3f(param, (float)value1, (float)value2, (float)value3);
  }
  else
  {
    ContextRef = j_GetContextRef();
    if ( ContextRef )
    {
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&ContextRef->ref) )
      {
LABEL_10:
        __clrex();
      }
      else
      {
        p_LastError = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_10;
        }
      }
      __dmb(0xBu);
      ALCcontext_DecRef(ContextRef);
    }
  }
}

//----- (002556D0) --------------------------------------------------------
void __fastcall alListeneriv(ALenum param, const ALint *values)
{
  ALCcontext *ContextRef; // r4
  unsigned int *p_LastError; // r0
  unsigned int *v8; // r0
  float32x4_t v10; // [sp+0h] [bp-20h] BYREF
  float v11; // [sp+10h] [bp-10h]
  float v12; // [sp+14h] [bp-Ch]

  if ( values )
  {
    switch ( param )
    {
      case 4100:
LABEL_5:
        j_alListener3f(param, (float)*values, (float)values[1], (float)values[2]);
        return;
      case 4111:
        v10 = vcvtq_f32_s32(*(int32x4_t *)values);
        v11 = (float)values[4];
        v12 = (float)values[5];
        j_alListenerfv(4111, (const ALfloat *)&v10);
        return;
      case 4102:
        goto LABEL_5;
    }
  }
  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    if ( values )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        p_LastError = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_23;
        }
        goto LABEL_24;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        v8 = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v8) )
        {
          if ( __ldrex(v8) )
            goto LABEL_23;
        }
        goto LABEL_24;
      }
    }
LABEL_23:
    __clrex();
LABEL_24:
    __dmb(0xBu);
    ALCcontext_DecRef(ContextRef);
  }
}

//----- (002557D8) --------------------------------------------------------
void __fastcall alGetListenerf(ALenum param, ALfloat *value)
{
  ALCcontext *ContextRef; // r4
  unsigned int *v6; // r0
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    if ( value )
    {
      if ( param == 131076 )
      {
        *value = ContextRef->Listener->MetersPerUnit;
        goto LABEL_23;
      }
      if ( param == 4106 )
      {
        *value = ContextRef->Listener->Gain;
LABEL_23:
        ALCcontext_DecRef(ContextRef);
        return;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        p_LastError = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_21;
        }
        goto LABEL_22;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        v6 = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v6) )
        {
          if ( __ldrex(v6) )
            goto LABEL_21;
        }
        goto LABEL_22;
      }
    }
LABEL_21:
    __clrex();
LABEL_22:
    __dmb(0xBu);
    goto LABEL_23;
  }
}

//----- (0025589C) --------------------------------------------------------
void __fastcall alGetListener3f(ALenum param, ALfloat *value1, ALfloat *value2, ALfloat *value3)
{
  ALCcontext *ContextRef; // r4
  bool v9; // zf
  volatile ALfloat v10; // r0
  unsigned int *p_LastError; // r0
  unsigned int *v15; // r0

  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    v9 = value1 == 0;
    if ( value1 )
      v9 = value2 == 0;
    if ( v9 || !value3 )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        p_LastError = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_25;
        }
        goto LABEL_26;
      }
    }
    else
    {
      if ( param == 4102 )
      {
        (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref + (unsigned int)&elf_hash_chain[6161])
                          + 44))();
        *value1 = ContextRef->Listener->Velocity[0];
        *value2 = ContextRef->Listener->Velocity[1];
        v10 = ContextRef->Listener->Velocity[2];
        goto LABEL_18;
      }
      if ( param == 4100 )
      {
        (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref + (unsigned int)&elf_hash_chain[6161])
                          + 44))();
        *value1 = ContextRef->Listener->Position[0];
        *value2 = ContextRef->Listener->Position[1];
        v10 = ContextRef->Listener->Position[2];
LABEL_18:
        *value3 = v10;
        (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref + (unsigned int)&elf_hash_chain[6161])
                          + 48))();
LABEL_27:
        ALCcontext_DecRef(ContextRef);
        return;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        v15 = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, v15) )
        {
          if ( __ldrex(v15) )
            goto LABEL_25;
        }
        goto LABEL_26;
      }
    }
LABEL_25:
    __clrex();
LABEL_26:
    __dmb(0xBu);
    goto LABEL_27;
  }
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (002559BC) --------------------------------------------------------
void __fastcall alGetListenerfv(ALenum param, ALfloat *values)
{
  bool v4; // zf
  bool v5; // zf
  ALCcontext *ContextRef; // r0
  unsigned int *p_ref; // r8
  ALCcontext *v8; // r4
  unsigned int *v10; // r0
  unsigned int *v13; // r0
  ALCcontext *v15; // r0
  unsigned int *v17; // r0
  unsigned int *p_LastError; // r0

  if ( param > 4105 )
  {
    v5 = param == 131076;
    if ( param != 131076 )
      v5 = param == 4106;
    if ( !v5 )
      goto LABEL_16;
    ContextRef = j_GetContextRef();
    p_ref = (unsigned int *)&ContextRef->ref;
    if ( !ContextRef )
      return;
    if ( values )
    {
      if ( param == 131076 )
      {
        *values = ContextRef->Listener->MetersPerUnit;
        goto LABEL_37;
      }
      if ( param == 4106 )
      {
        *values = ContextRef->Listener->Gain;
LABEL_37:
        v15 = (ALCcontext *)p_ref;
LABEL_54:
        ALCcontext_DecRef(v15);
        return;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex(p_ref) )
      {
        v13 = p_ref + 20;
        __dmb(0xBu);
        while ( __strex(0xA002u, v13) )
        {
          if ( __ldrex(v13) )
            goto LABEL_35;
        }
        goto LABEL_36;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex(p_ref) )
      {
        v10 = p_ref + 20;
        __dmb(0xBu);
        while ( __strex(0xA003u, v10) )
        {
          if ( __ldrex(v10) )
            goto LABEL_35;
        }
        goto LABEL_36;
      }
    }
LABEL_35:
    __clrex();
LABEL_36:
    __dmb(0xBu);
    goto LABEL_37;
  }
  v4 = param == 4100;
  if ( param != 4100 )
    v4 = param == 4102;
  if ( v4 )
  {
    alGetListener3f(param, values, values + 1, values + 2);
    return;
  }
LABEL_16:
  v8 = j_GetContextRef();
  if ( v8 )
  {
    if ( values )
    {
      if ( param == 4111 )
      {
        (*(void (**)(void))(*(volatile RefCount *)((char *)&v8->Device->ref + (unsigned int)&elf_hash_chain[6161]) + 44))();
        *values = v8->Listener->Forward[0];
        values[1] = v8->Listener->Forward[1];
        values[2] = v8->Listener->Forward[2];
        values[3] = v8->Listener->Up[0];
        values[4] = v8->Listener->Up[1];
        values[5] = v8->Listener->Up[2];
        (*(void (**)(void))(*(volatile RefCount *)((char *)&v8->Device->ref + (unsigned int)&elf_hash_chain[6161]) + 48))();
LABEL_53:
        v15 = v8;
        goto LABEL_54;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v8->ref) )
      {
        p_LastError = (unsigned int *)&v8->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_51;
        }
        goto LABEL_52;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v8->ref) )
      {
        v17 = (unsigned int *)&v8->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v17) )
        {
          if ( __ldrex(v17) )
            goto LABEL_51;
        }
        goto LABEL_52;
      }
    }
LABEL_51:
    __clrex();
LABEL_52:
    __dmb(0xBu);
    goto LABEL_53;
  }
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (00255B90) --------------------------------------------------------
void __fastcall alGetListeneri(ALenum param, ALint *value)
{
  ALCcontext *ContextRef; // r4
  unsigned int *p_LastError; // r0
  unsigned int *v8; // r0

  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    if ( value )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        p_LastError = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_16;
        }
        goto LABEL_17;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        v8 = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v8) )
        {
          if ( __ldrex(v8) )
            goto LABEL_16;
        }
        goto LABEL_17;
      }
    }
LABEL_16:
    __clrex();
LABEL_17:
    __dmb(0xBu);
    ALCcontext_DecRef(ContextRef);
  }
}

//----- (00255C1C) --------------------------------------------------------
void __fastcall alGetListener3i(ALenum param, ALint *value1, ALint *value2, ALint *value3)
{
  ALCcontext *ContextRef; // r4
  bool v9; // zf
  float v10; // s0
  unsigned int *p_LastError; // r0
  unsigned int *v15; // r0

  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    v9 = value1 == 0;
    if ( value1 )
      v9 = value2 == 0;
    if ( v9 || !value3 )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        p_LastError = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_25;
        }
        goto LABEL_26;
      }
    }
    else
    {
      if ( param == 4102 )
      {
        (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref + (unsigned int)&elf_hash_chain[6161])
                          + 44))();
        *value1 = (int)ContextRef->Listener->Velocity[0];
        *value2 = (int)ContextRef->Listener->Velocity[1];
        v10 = ContextRef->Listener->Velocity[2];
        goto LABEL_18;
      }
      if ( param == 4100 )
      {
        (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref + (unsigned int)&elf_hash_chain[6161])
                          + 44))();
        *value1 = (int)ContextRef->Listener->Position[0];
        *value2 = (int)ContextRef->Listener->Position[1];
        v10 = ContextRef->Listener->Position[2];
LABEL_18:
        *value3 = (int)v10;
        (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref + (unsigned int)&elf_hash_chain[6161])
                          + 48))();
LABEL_27:
        ALCcontext_DecRef(ContextRef);
        return;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        v15 = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, v15) )
        {
          if ( __ldrex(v15) )
            goto LABEL_25;
        }
        goto LABEL_26;
      }
    }
LABEL_25:
    __clrex();
LABEL_26:
    __dmb(0xBu);
    goto LABEL_27;
  }
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (00255D60) --------------------------------------------------------
void __fastcall alGetListeneriv(ALenum param, ALint *values)
{
  ALCcontext *ContextRef; // r4
  unsigned int *v6; // r0
  unsigned int *p_LastError; // r0

  if ( (param | 2) == 4102 )
  {
    alGetListener3i(param, values, values + 1, values + 2);
    return;
  }
  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    if ( values )
    {
      if ( param == 4111 )
      {
        (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref + (unsigned int)&elf_hash_chain[6161])
                          + 44))();
        *values = (int)ContextRef->Listener->Forward[0];
        values[1] = (int)ContextRef->Listener->Forward[1];
        values[2] = (int)ContextRef->Listener->Forward[2];
        values[3] = (int)ContextRef->Listener->Up[0];
        values[4] = (int)ContextRef->Listener->Up[1];
        values[5] = (int)ContextRef->Listener->Up[2];
        (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref + (unsigned int)&elf_hash_chain[6161])
                          + 48))();
LABEL_23:
        ALCcontext_DecRef(ContextRef);
        return;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        p_LastError = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_21;
        }
        goto LABEL_22;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        v6 = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v6) )
        {
          if ( __ldrex(v6) )
            goto LABEL_21;
        }
        goto LABEL_22;
      }
    }
LABEL_21:
    __clrex();
LABEL_22:
    __dmb(0xBu);
    goto LABEL_23;
  }
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (00255E9C) --------------------------------------------------------
void __fastcall alGenSources(ALsizei n, ALuint *sources)
{
  ALCcontext *ContextRef; // r0
  unsigned int *p_LastError; // r4
  ALsizei v5; // r6
  _BYTE *v6; // r0
  ALuint *v7; // r4
  Resampler v8; // r0
  ALenum inserted; // r0
  ALuint v10; // r8
  unsigned int v11; // r0
  unsigned int v12; // r0
  unsigned int v13; // r0
  unsigned int v14; // r0
  unsigned int v15; // r0
  ALenum *v16; // r1
  unsigned int *v17; // r0
  unsigned int v18; // r0
  int v19; // t1
  unsigned int v26; // [sp+4h] [bp-3Ch]
  ALCcontext *v27; // [sp+Ch] [bp-34h]
  unsigned int *v28; // [sp+10h] [bp-30h]
  UIntMap_0 *map; // [sp+14h] [bp-2Ch]
  ALsizei v30; // [sp+1Ch] [bp-24h]

  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    map = &ContextRef->SourceMap;
    v27 = ContextRef;
    p_LastError = (unsigned int *)&ContextRef->LastError;
    v30 = n;
    v28 = (unsigned int *)&ContextRef->LastError;
    if ( n < 0 )
    {
      if ( TrapALError )
        raise(5);
      if ( __ldrex(p_LastError) )
      {
LABEL_74:
        __clrex();
      }
      else
      {
        __dmb(0xBu);
        while ( __strex(0xA003u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_74;
        }
      }
      __dmb(0xBu);
    }
    else if ( n >= 1 )
    {
      v5 = 0;
      while ( 1 )
      {
        v6 = malloc(0x59A0u);
        if ( !v6 )
          break;
        *v6 = 0;
        v7 = (ALuint *)(v6 + 1);
        if ( ((unsigned int)(v6 + 1) & 0xF) != 0 )
        {
          do
          {
            *(_BYTE *)v7 = 85;
            v7 = (ALuint *)((char *)v7 + 1);
          }
          while ( ((unsigned __int8)v7 & 0xF) != 0 );
        }
        memset(v7, 0, 0x5990u);
        v7[5] = 1135869952;
        v7[6] = 1135869952;
        *v7 = 1065353216;
        v7[10] = 0;
        v7[11] = 0;
        v7[12] = 0;
        v7[16] = 0;
        v7[17] = 0;
        v7[18] = 0;
        v7[13] = 0;
        v7[14] = 0;
        v7[15] = 0;
        v7[7] = 1065353216;
        v7[8] = 2139095039;
        v7[9] = 1065353216;
        *((_BYTE *)v7 + 77) = 0;
        v7[1] = 1065353216;
        v7[3] = 0;
        v7[4] = 1065353216;
        v7[2] = 0;
        v7[22] = 1065353216;
        *((_BYTE *)v7 + 85) = 1;
        *((_BYTE *)v7 + 86) = 1;
        *((_BYTE *)v7 + 87) = 1;
        v7[23] = 0;
        v7[24] = 0;
        v7[25] = 1065353216;
        *((_BYTE *)v7 + 84) = 0;
        v7[20] = 53250;
        v8 = DefaultResampler;
        v7[32] = 4113;
        v7[31] = 4144;
        v7[5728] = 1;
        v7[26] = v8;
        v7[33] = 0;
        v7[28] = 0;
        v7[29] = -1074790400;
        v7[41] = 1065353216;
        v7[42] = 1065353216;
        v7[44] = 1065353216;
        v7[45] = 1065353216;
        v7[47] = 1065353216;
        v7[48] = 1065353216;
        v7[50] = 1065353216;
        v7[51] = 1065353216;
        v7[53] = 1065353216;
        v7[54] = 1065353216;
        *((_BYTE *)v7 + 224) = 0;
        v7[57] = 0;
        inserted = j_NewThunkEntry(v7 + 5730);
        v10 = v7[5730];
        if ( inserted || (inserted = j_InsertUIntMapEntry(map, v10, v7), v10 = v7[5730], inserted) )
        {
          v26 = inserted;
          __dmb(0xBu);
          do
            v11 = __ldrex((unsigned int *)&ThunkLock.read_count);
          while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
          __dmb(0xBu);
          if ( v11 == 1 )
          {
            do
            {
              sched_yield();
              __dmb(0xBu);
              do
                v12 = __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
              __dmb(0xBu);
            }
            while ( v12 == 1 );
          }
          __dmb(0xBu);
          do
            v13 = __ldrex((unsigned int *)&ThunkLock.read_count);
          while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
          while ( 1 )
          {
            __dmb(0xBu);
            if ( v13 != 1 )
              break;
            sched_yield();
            __dmb(0xBu);
            do
              v13 = __ldrex((unsigned int *)&ThunkLock.read_count);
            while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
          }
          __dmb(0xBu);
          do
            v14 = __ldrex((unsigned int *)&ThunkLock.read_count);
          while ( __strex(v14 + 1, (unsigned int *)&ThunkLock.read_count) );
          __dmb(0xBu);
          if ( !v14 )
          {
            __dmb(0xBu);
            do
              v15 = __ldrex((unsigned int *)&ThunkLock.read_count);
            while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
            while ( 1 )
            {
              __dmb(0xBu);
              if ( v15 != 1 )
                break;
              sched_yield();
              __dmb(0xBu);
              do
                v15 = __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
            }
          }
          __dmb(0xBu);
          do
            __ldrex((unsigned int *)&ThunkLock.read_count);
          while ( __strex(0, (unsigned int *)&ThunkLock.read_lock) );
          __dmb(0xBu);
          __dmb(0xBu);
          do
            __ldrex((unsigned int *)&ThunkLock.read_count);
          while ( __strex(0, (unsigned int *)&ThunkLock.read_entry_lock) );
          __dmb(0xBu);
          if ( v10 - 1 < ThunkArraySize )
          {
            v16 = ThunkArray;
            __dmb(0xBu);
            v17 = (unsigned int *)&v16[v10 - 1];
            do
              __ldrex(v17);
            while ( __strex(0, v17) );
            __dmb(0xBu);
          }
          __dmb(0xBu);
          do
            v18 = __ldrex((unsigned int *)&ThunkLock.read_count);
          while ( __strex(v18 - 1, (unsigned int *)&ThunkLock.read_count) );
          __dmb(0xBu);
          if ( v18 == 1 )
          {
            __dmb(0xBu);
            do
              __ldrex((unsigned int *)&ThunkLock.read_count);
            while ( __strex(0, (unsigned int *)&ThunkLock.write_lock) );
            __dmb(0xBu);
          }
          memset(v7, 0, 0x5990u);
          do
          {
            v19 = *((unsigned __int8 *)v7 - 1);
            v7 = (ALuint *)((char *)v7 - 1);
          }
          while ( v19 == 85 );
          free(v7);
          if ( TrapALError )
            raise(5);
          if ( __ldrex(v28) )
          {
LABEL_55:
            __clrex();
          }
          else
          {
            __dmb(0xBu);
            while ( __strex(v26, v28) )
            {
              if ( __ldrex(v28) )
                goto LABEL_55;
            }
          }
          goto LABEL_65;
        }
        sources[v5++] = v10;
        if ( v5 >= v30 )
          goto LABEL_67;
      }
      if ( TrapALError )
        raise(5);
      if ( __ldrex(v28) )
      {
LABEL_64:
        __clrex();
      }
      else
      {
        __dmb(0xBu);
        while ( __strex(0xA005u, v28) )
        {
          if ( __ldrex(v28) )
            goto LABEL_64;
        }
      }
LABEL_65:
      __dmb(0xBu);
      if ( v5 >= 1 )
        j_alDeleteSources(v5, sources);
    }
LABEL_67:
    ALCcontext_DecRef(v27);
  }
}
// 2561C6: conditional instruction was optimized away because r1.4!=0

//----- (002562A4) --------------------------------------------------------
void __fastcall alDeleteSources(ALsizei n, const ALuint *sources)
{
  int v4; // r4
  UIntMap_0 *p_SourceMap; // r6
  int v6; // r0
  ALsource *v7; // r5
  unsigned int v8; // r0
  unsigned int v9; // r0
  unsigned int v10; // r0
  unsigned int v11; // r0
  ALenum *v12; // r1
  unsigned int *v13; // r0
  unsigned int v14; // r0
  ALsizei ActiveSourceCount; // r0
  int v16; // r3
  ALsource **ActiveSources; // r1
  ALsource **v18; // r12
  ALbufferlistitem_0 *queue; // r0
  unsigned int *p_ref; // r1
  unsigned int v21; // r2
  ALeffectslot *Slot; // r0
  unsigned int *v23; // r0
  unsigned int v24; // r1
  ALeffectslot *v25; // r0
  unsigned int *v26; // r0
  unsigned int v27; // r1
  ALeffectslot *v28; // r0
  unsigned int *v29; // r0
  unsigned int v30; // r1
  ALeffectslot *v31; // r0
  unsigned int *v32; // r0
  unsigned int v33; // r1
  int v34; // t1
  ALCcontext *v36; // r0
  unsigned int *p_LastError; // r0
  ALCcontext *v40; // r0
  unsigned int *v41; // r0
  const ALuint *v43; // [sp+4h] [bp-34h]
  ALsizei v44; // [sp+8h] [bp-30h]
  ALuint id; // [sp+10h] [bp-28h]
  int v46; // [sp+14h] [bp-24h]
  ALCcontext *ContextRef; // [sp+18h] [bp-20h]

  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    if ( n < 0 )
    {
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&ContextRef->ref) )
      {
LABEL_92:
        __clrex();
      }
      else
      {
        v36 = ContextRef;
        __dmb(0xBu);
        p_LastError = (unsigned int *)&v36->LastError;
        while ( __strex(0xA003u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_92;
        }
      }
    }
    else
    {
      if ( !n )
      {
LABEL_94:
        ALCcontext_DecRef(ContextRef);
        return;
      }
      v4 = 0;
      p_SourceMap = &ContextRef->SourceMap;
      while ( j_LookupUIntMapKey(p_SourceMap, sources[v4]) )
      {
        if ( ++v4 >= n )
        {
          v6 = 0;
          v43 = sources;
          v44 = n;
          do
          {
            v46 = v6;
            v7 = (ALsource *)j_RemoveUIntMapKey(p_SourceMap, sources[v6]);
            if ( v7 )
            {
              id = v7->id;
              __dmb(0xBu);
              do
                v8 = __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
              while ( 1 )
              {
                __dmb(0xBu);
                if ( v8 != 1 )
                  break;
                sched_yield();
                __dmb(0xBu);
                do
                  v8 = __ldrex((unsigned int *)&ThunkLock.read_count);
                while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
              }
              __dmb(0xBu);
              do
                v9 = __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
              while ( 1 )
              {
                __dmb(0xBu);
                if ( v9 != 1 )
                  break;
                sched_yield();
                __dmb(0xBu);
                do
                  v9 = __ldrex((unsigned int *)&ThunkLock.read_count);
                while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
              }
              __dmb(0xBu);
              do
                v10 = __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(v10 + 1, (unsigned int *)&ThunkLock.read_count) );
              __dmb(0xBu);
              if ( !v10 )
              {
                __dmb(0xBu);
                do
                  v11 = __ldrex((unsigned int *)&ThunkLock.read_count);
                while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
                while ( 1 )
                {
                  __dmb(0xBu);
                  if ( v11 != 1 )
                    break;
                  sched_yield();
                  __dmb(0xBu);
                  do
                    v11 = __ldrex((unsigned int *)&ThunkLock.read_count);
                  while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
                }
              }
              __dmb(0xBu);
              do
                __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(0, (unsigned int *)&ThunkLock.read_lock) );
              __dmb(0xBu);
              __dmb(0xBu);
              do
                __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(0, (unsigned int *)&ThunkLock.read_entry_lock) );
              __dmb(0xBu);
              if ( id - 1 < ThunkArraySize )
              {
                v12 = ThunkArray;
                __dmb(0xBu);
                v13 = (unsigned int *)&v12[id - 1];
                do
                  __ldrex(v13);
                while ( __strex(0, v13) );
                __dmb(0xBu);
              }
              __dmb(0xBu);
              do
                v14 = __ldrex((unsigned int *)&ThunkLock.read_count);
              while ( __strex(v14 - 1, (unsigned int *)&ThunkLock.read_count) );
              __dmb(0xBu);
              if ( v14 == 1 )
              {
                __dmb(0xBu);
                do
                  __ldrex((unsigned int *)&ThunkLock.read_count);
                while ( __strex(0, (unsigned int *)&ThunkLock.write_lock) );
                __dmb(0xBu);
              }
              (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref
                                                       + (unsigned int)&elf_hash_chain[6161])
                                + 44))();
              ActiveSourceCount = ContextRef->ActiveSourceCount;
              sources = v43;
              if ( ActiveSourceCount )
              {
                v16 = 4 * ActiveSourceCount;
                ActiveSources = ContextRef->ActiveSources;
                v18 = &ActiveSources[ActiveSourceCount];
                while ( *ActiveSources != v7 )
                {
                  v16 -= 4;
                  ++ActiveSources;
                  if ( !v16 )
                    goto LABEL_50;
                }
                ContextRef->ActiveSourceCount = ActiveSourceCount - 1;
                *ActiveSources = *(v18 - 1);
              }
LABEL_50:
              (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref
                                                       + (unsigned int)&elf_hash_chain[6161])
                                + 48))();
              while ( 1 )
              {
                queue = v7->queue;
                if ( !queue )
                  break;
                v7->queue = queue->next;
                if ( queue->buffer )
                {
                  p_ref = &queue->buffer->ref;
                  __dmb(0xBu);
                  do
                    v21 = __ldrex(p_ref);
                  while ( __strex(v21 - 1, p_ref) );
                  __dmb(0xBu);
                }
                free(queue);
              }
              Slot = v7->Send[0].Slot;
              if ( Slot )
              {
                v23 = &Slot->ref;
                __dmb(0xBu);
                do
                  v24 = __ldrex(v23);
                while ( __strex(v24 - 1, v23) );
                __dmb(0xBu);
              }
              v25 = v7->Send[1].Slot;
              v7->Send[0].Slot = 0;
              if ( v25 )
              {
                v26 = &v25->ref;
                __dmb(0xBu);
                do
                  v27 = __ldrex(v26);
                while ( __strex(v27 - 1, v26) );
                __dmb(0xBu);
              }
              v28 = v7->Send[2].Slot;
              v7->Send[1].Slot = 0;
              if ( v28 )
              {
                v29 = &v28->ref;
                __dmb(0xBu);
                do
                  v30 = __ldrex(v29);
                while ( __strex(v30 - 1, v29) );
                __dmb(0xBu);
              }
              v31 = v7->Send[3].Slot;
              v7->Send[2].Slot = 0;
              if ( v31 )
              {
                v32 = &v31->ref;
                __dmb(0xBu);
                do
                  v33 = __ldrex(v32);
                while ( __strex(v33 - 1, v32) );
                __dmb(0xBu);
              }
              memset(v7, 0, sizeof(ALsource));
              do
              {
                v34 = *((unsigned __int8 *)&v7[-1].id + 7);
                v7 = (ALsource *)((char *)v7 - 1);
              }
              while ( v34 == 85 );
              free(v7);
            }
            v6 = v46 + 1;
          }
          while ( v46 + 1 != v44 );
          goto LABEL_94;
        }
      }
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&ContextRef->ref) )
        goto LABEL_92;
      v40 = ContextRef;
      __dmb(0xBu);
      v41 = (unsigned int *)&v40->LastError;
      while ( __strex(0xA001u, v41) )
      {
        if ( __ldrex(v41) )
          goto LABEL_92;
      }
    }
    __dmb(0xBu);
    goto LABEL_94;
  }
}
// 2562EA: conditional instruction was optimized away because r5.4>=1
// 10168: using guessed type int elf_hash_chain[22025];

//----- (0025666C) --------------------------------------------------------
ALboolean __fastcall alIsSource(ALuint source)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v3; // r5
  ALvoid *v4; // r4

  ContextRef = j_GetContextRef();
  v3 = ContextRef;
  if ( !ContextRef )
    return 0;
  v4 = j_LookupUIntMapKey(&ContextRef->SourceMap, source);
  j_ALCcontext_DecRef(v3);
  return v4 != 0;
}

//----- (0025669C) --------------------------------------------------------
void __fastcall alSourcef(ALuint source, ALenum param, ALfloat value)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v6; // r4
  ALsource_0 *v7; // r0
  unsigned int *v9; // r0
  bool v11; // zf
  unsigned int *p_LastError; // r0
  ALfloat values[5]; // [sp+4h] [bp-14h] BYREF

  values[0] = value;
  ContextRef = j_GetContextRef();
  v6 = ContextRef;
  if ( ContextRef )
  {
    v7 = (ALsource_0 *)j_LookupUIntMapKey(&ContextRef->SourceMap, source);
    if ( v7 )
    {
      if ( param < 49152 )
      {
        switch ( param )
        {
          case 4097:
          case 4098:
          case 4099:
          case 4103:
          case 4105:
          case 4106:
          case 4109:
          case 4110:
          case 4112:
          case 4117:
          case 4118:
          case 4128:
          case 4129:
          case 4130:
          case 4131:
          case 4132:
          case 4133:
          case 4134:
          case 4135:
          case 4147:
            goto LABEL_17;
          case 4100:
          case 4101:
          case 4102:
          case 4104:
          case 4107:
          case 4108:
          case 4111:
          case 4113:
          case 4114:
          case 4115:
          case 4116:
          case 4119:
          case 4120:
          case 4121:
          case 4122:
          case 4123:
          case 4124:
          case 4125:
          case 4126:
          case 4127:
          case 4136:
          case 4137:
          case 4138:
          case 4139:
          case 4140:
          case 4141:
          case 4142:
          case 4143:
          case 4144:
          case 4145:
          case 4146:
            goto LABEL_19;
          default:
            if ( param != 514 )
              goto LABEL_19;
            goto LABEL_17;
        }
      }
      if ( (unsigned int)(param - 131079) < 6 )
        goto LABEL_17;
      v11 = param == 49152;
      if ( param != 49152 )
        v11 = param == 53248;
      if ( v11 )
      {
LABEL_17:
        SetSourcefv(v7, v6, (SrcFloatProp_0)param, values);
LABEL_27:
        j_ALCcontext_DecRef(v6);
        return;
      }
LABEL_19:
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v6->ref) )
      {
        p_LastError = (unsigned int *)&v6->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_25;
        }
        goto LABEL_26;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v6->ref) )
      {
        v9 = (unsigned int *)&v6->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v9) )
        {
          if ( __ldrex(v9) )
            goto LABEL_25;
        }
        goto LABEL_26;
      }
    }
LABEL_25:
    __clrex();
LABEL_26:
    __dmb(0xBu);
    goto LABEL_27;
  }
}
// 25669C: using guessed type ALfloat values[5];

//----- (002567C0) --------------------------------------------------------
ALenum __fastcall SetSourcefv(ALsource_0 *Source, ALCcontext *Context, SrcFloatProp_0 prop, const ALfloat *values)
{
  ALint v8; // s0
  float v9; // s0
  ALenum result; // r0
  unsigned int *v12; // r0
  unsigned int *v15; // r0
  volatile ALenum state; // r0
  unsigned int *v19; // r0
  float v21; // s0
  float v22; // s0
  unsigned int *v24; // r0
  unsigned int *v27; // r0
  float v29; // s0
  float v30; // s0
  unsigned int *v32; // r0
  unsigned int *v35; // r0
  float v37; // s0
  unsigned int *v39; // r0
  float v41; // s0
  float v42; // s0
  unsigned int *v44; // r0
  float v46; // s0
  unsigned int *v48; // r0
  unsigned int *v51; // r0
  unsigned int *v54; // r0
  unsigned int *v57; // r0
  unsigned int *p_LastError; // r0
  unsigned int *v63; // r0
  unsigned int *v66; // r0
  unsigned int *v69; // r0
  unsigned int *v72; // r0
  unsigned int *v75; // r0
  unsigned int *v78; // r0
  unsigned int *v81; // r0
  unsigned int *v84; // r0
  ALint v86[7]; // [sp+4h] [bp-1Ch] BYREF

  if ( prop <= 4608 )
  {
    switch ( prop )
    {
      case 4097:
        v21 = *values;
        if ( *values >= 0.0 && v21 <= 360.0 )
        {
          Source->InnerAngle = v21;
          goto LABEL_198;
        }
        if ( TrapALError )
          raise(5);
        if ( __ldrex((unsigned int *)&Context->ref) )
          goto LABEL_226;
        p_LastError = (unsigned int *)&Context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_226;
        }
        goto LABEL_227;
      case 4098:
        v22 = *values;
        if ( *values >= 0.0 && v22 <= 360.0 )
        {
          Source->OuterAngle = v22;
          goto LABEL_198;
        }
        if ( TrapALError )
          raise(5);
        if ( __ldrex((unsigned int *)&Context->ref) )
          goto LABEL_226;
        v63 = (unsigned int *)&Context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v63) )
        {
          if ( __ldrex(v63) )
            goto LABEL_226;
        }
        goto LABEL_227;
      case 4099:
        if ( *values >= 0.0 )
        {
          Source->Pitch = *values;
          goto LABEL_198;
        }
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&Context->ref) )
        {
          v24 = (unsigned int *)&Context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v24) )
              goto LABEL_227;
          }
          while ( !__ldrex(v24) );
        }
        goto LABEL_226;
      case 4100:
        if ( fabsf(*values) != INFINITY && fabsf(values[1]) != INFINITY && fabsf(values[2]) != INFINITY )
        {
          (*(void (**)(void))(*(volatile RefCount *)((char *)&Context->Device->ref + (unsigned int)&elf_hash_chain[6161])
                            + 44))();
          Source->Position[0] = *values;
          Source->Position[1] = values[1];
          Source->Position[2] = values[2];
          goto LABEL_71;
        }
        if ( TrapALError )
          raise(5);
        if ( __ldrex((unsigned int *)&Context->ref) )
          goto LABEL_226;
        v48 = (unsigned int *)&Context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v48) )
        {
          if ( __ldrex(v48) )
            goto LABEL_226;
        }
        goto LABEL_227;
      case 4101:
        if ( fabsf(*values) != INFINITY && fabsf(values[1]) != INFINITY && fabsf(values[2]) != INFINITY )
        {
          (*(void (**)(void))(*(volatile RefCount *)((char *)&Context->Device->ref + (unsigned int)&elf_hash_chain[6161])
                            + 44))();
          Source->Orientation[0] = *values;
          Source->Orientation[1] = values[1];
          Source->Orientation[2] = values[2];
          goto LABEL_71;
        }
        if ( TrapALError )
          raise(5);
        if ( __ldrex((unsigned int *)&Context->ref) )
          goto LABEL_226;
        v51 = (unsigned int *)&Context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v51) )
        {
          if ( __ldrex(v51) )
            goto LABEL_226;
        }
        goto LABEL_227;
      case 4102:
        if ( fabsf(*values) != INFINITY && fabsf(values[1]) != INFINITY && fabsf(values[2]) != INFINITY )
        {
          (*(void (**)(void))(*(volatile RefCount *)((char *)&Context->Device->ref + (unsigned int)&elf_hash_chain[6161])
                            + 44))();
          Source->Velocity[0] = *values;
          Source->Velocity[1] = values[1];
          Source->Velocity[2] = values[2];
LABEL_71:
          (*(void (**)(void))(*(volatile RefCount *)((char *)&Context->Device->ref + (unsigned int)&elf_hash_chain[6161])
                            + 48))();
          goto LABEL_198;
        }
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&Context->ref) )
        {
          v54 = (unsigned int *)&Context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v54) )
              goto LABEL_227;
          }
          while ( !__ldrex(v54) );
        }
        goto LABEL_226;
      case 4103:
      case 4112:
      case 4135:
      case 4147:
        goto LABEL_12;
      case 4104:
      case 4107:
      case 4108:
      case 4111:
      case 4113:
      case 4114:
      case 4115:
      case 4116:
      case 4119:
      case 4120:
      case 4121:
      case 4122:
      case 4123:
      case 4124:
      case 4125:
      case 4126:
      case 4127:
      case 4136:
      case 4137:
      case 4138:
      case 4139:
      case 4140:
      case 4141:
      case 4142:
      case 4143:
      case 4144:
        goto LABEL_35;
      case 4105:
      case 4117:
      case 4118:
        v8 = (unsigned int)*values;
        goto LABEL_13;
      case 4106:
        if ( *values >= 0.0 )
        {
          Source->Gain = *values;
          goto LABEL_198;
        }
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&Context->ref) )
        {
          v27 = (unsigned int *)&Context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v27) )
              goto LABEL_227;
          }
          while ( !__ldrex(v27) );
        }
        goto LABEL_226;
      case 4109:
        v29 = *values;
        if ( *values >= 0.0 && v29 <= 1.0 )
        {
          Source->MinGain = v29;
          goto LABEL_198;
        }
        if ( TrapALError )
          raise(5);
        if ( __ldrex((unsigned int *)&Context->ref) )
          goto LABEL_226;
        v66 = (unsigned int *)&Context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v66) )
        {
          if ( __ldrex(v66) )
            goto LABEL_226;
        }
        goto LABEL_227;
      case 4110:
        v30 = *values;
        if ( *values >= 0.0 && v30 <= 1.0 )
        {
          Source->MaxGain = v30;
          goto LABEL_198;
        }
        if ( TrapALError )
          raise(5);
        if ( __ldrex((unsigned int *)&Context->ref) )
          goto LABEL_226;
        v69 = (unsigned int *)&Context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v69) )
        {
          if ( __ldrex(v69) )
            goto LABEL_226;
        }
        goto LABEL_227;
      case 4128:
        if ( *values >= 0.0 )
        {
          Source->RefDistance = *values;
          goto LABEL_198;
        }
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&Context->ref) )
        {
          v32 = (unsigned int *)&Context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v32) )
              goto LABEL_227;
          }
          while ( !__ldrex(v32) );
        }
        goto LABEL_226;
      case 4129:
        if ( *values >= 0.0 )
        {
          Source->RollOffFactor = *values;
          goto LABEL_198;
        }
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&Context->ref) )
        {
          v35 = (unsigned int *)&Context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v35) )
              goto LABEL_227;
          }
          while ( !__ldrex(v35) );
        }
        goto LABEL_226;
      case 4130:
        v37 = *values;
        if ( *values >= 0.0 && v37 <= 1.0 )
        {
          Source->OuterGain = v37;
          goto LABEL_198;
        }
        if ( TrapALError )
          raise(5);
        if ( __ldrex((unsigned int *)&Context->ref) )
          goto LABEL_226;
        v72 = (unsigned int *)&Context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v72) )
        {
          if ( __ldrex(v72) )
            goto LABEL_226;
        }
        goto LABEL_227;
      case 4131:
        if ( *values >= 0.0 )
        {
          Source->MaxDistance = *values;
          goto LABEL_198;
        }
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&Context->ref) )
        {
          v39 = (unsigned int *)&Context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v39) )
              goto LABEL_227;
          }
          while ( !__ldrex(v39) );
        }
        goto LABEL_226;
      case 4132:
      case 4133:
      case 4134:
        if ( *values >= 0.0 )
        {
          (*(void (**)(void))(*(volatile RefCount *)((char *)&Context->Device->ref + (unsigned int)&elf_hash_chain[6161])
                            + 44))();
          Source->OffsetType = prop;
          state = Source->state;
          Source->Offset = *values;
          if ( state != 4114 && Source->state != 4115 || Context->DeferUpdates || j_ApplyOffset(Source) )
          {
            (*(void (**)(void))(*(volatile RefCount *)((char *)&Context->Device->ref
                                                     + (unsigned int)&elf_hash_chain[6161])
                              + 48))();
            return 0;
          }
          (*(void (**)(void))(*(volatile RefCount *)((char *)&Context->Device->ref + (unsigned int)&elf_hash_chain[6161])
                            + 48))();
          if ( TrapALError )
            raise(5);
          if ( !__ldrex((unsigned int *)&Context->ref) )
          {
            v84 = (unsigned int *)&Context->LastError;
            __dmb(0xBu);
            do
            {
              if ( !__strex(0xA003u, v84) )
                goto LABEL_227;
            }
            while ( !__ldrex(v84) );
          }
        }
        else
        {
          if ( TrapALError )
            raise(5);
          if ( !__ldrex((unsigned int *)&Context->ref) )
          {
            v12 = (unsigned int *)&Context->LastError;
            __dmb(0xBu);
            do
            {
              if ( !__strex(0xA003u, v12) )
                goto LABEL_227;
            }
            while ( !__ldrex(v12) );
          }
        }
        goto LABEL_226;
      case 4145:
      case 4146:
        if ( TrapALError )
          raise(5);
        if ( __ldrex((unsigned int *)&Context->ref) )
          goto LABEL_125;
        v15 = (unsigned int *)&Context->LastError;
        __dmb(0xBu);
        break;
      default:
        if ( prop != sfSourceRelative )
          goto LABEL_35;
        goto LABEL_12;
    }
    while ( __strex(0xA004u, v15) )
    {
      if ( __ldrex(v15) )
        goto LABEL_125;
    }
LABEL_126:
    result = 40964;
    __dmb(0xBu);
    return result;
  }
  if ( prop > 131078 )
  {
    switch ( prop )
    {
      case sfAirAbsorptionFactor:
        v9 = *values;
        if ( *values >= 0.0 && v9 <= 10.0 )
        {
          Source->AirAbsorptionFactor = v9;
          goto LABEL_198;
        }
        if ( TrapALError )
          raise(5);
        if ( __ldrex((unsigned int *)&Context->ref) )
          goto LABEL_226;
        v57 = (unsigned int *)&Context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v57) )
        {
          if ( __ldrex(v57) )
            goto LABEL_226;
        }
        goto LABEL_227;
      case sfRoomRolloffFactor:
        v41 = *values;
        if ( *values >= 0.0 && v41 <= 10.0 )
        {
          Source->RoomRolloffFactor = v41;
          goto LABEL_198;
        }
        if ( TrapALError )
          raise(5);
        if ( __ldrex((unsigned int *)&Context->ref) )
          goto LABEL_226;
        v75 = (unsigned int *)&Context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v75) )
        {
          if ( __ldrex(v75) )
            goto LABEL_226;
        }
        goto LABEL_227;
      case sfConeOuterGainHF:
        v42 = *values;
        if ( *values >= 0.0 && v42 <= 1.0 )
        {
          Source->OuterGainHF = v42;
          goto LABEL_198;
        }
        if ( TrapALError )
          raise(5);
        if ( __ldrex((unsigned int *)&Context->ref) )
          goto LABEL_226;
        v78 = (unsigned int *)&Context->LastError;
        __dmb(0xBu);
        break;
      case sfDirectFilterGainHFAuto:
      case sfAuxSendFilterGainAuto:
      case sfAuxSendFilterGainHFAuto:
        goto LABEL_12;
      default:
        goto LABEL_35;
    }
    while ( __strex(0xA003u, v78) )
    {
      if ( __ldrex(v78) )
        goto LABEL_226;
    }
LABEL_227:
    __dmb(0xBu);
    return 40963;
  }
  switch ( prop )
  {
    case sfSecOffsetLatencySOFT:
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&Context->ref) )
      {
LABEL_125:
        __clrex();
      }
      else
      {
        v44 = (unsigned int *)&Context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA004u, v44) )
        {
          if ( __ldrex(v44) )
            goto LABEL_125;
        }
      }
      goto LABEL_126;
    case sfDopplerFactor:
      v46 = *values;
      if ( *values < 0.0 || v46 > 1.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( __ldrex((unsigned int *)&Context->ref) )
        {
LABEL_226:
          __clrex();
        }
        else
        {
          v81 = (unsigned int *)&Context->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, v81) )
          {
            if ( __ldrex(v81) )
              goto LABEL_226;
          }
        }
        goto LABEL_227;
      }
      Source->DopplerFactor = v46;
LABEL_198:
      Source->NeedsUpdate = 1;
      return 0;
    case sfDistanceModel:
LABEL_12:
      v8 = (int)*values;
LABEL_13:
      v86[0] = v8;
      return SetSourceiv(Source, Context, (SrcIntProp_0)prop, v86);
    default:
LABEL_35:
      if ( LogLevel_0 )
        j_al_print("(EE)", "SetSourcefv", "Unexpected property: 0x%04x\n", prop);
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&Context->ref) )
      {
LABEL_43:
        __clrex();
      }
      else
      {
        v19 = (unsigned int *)&Context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, v19) )
        {
          if ( __ldrex(v19) )
            goto LABEL_43;
        }
      }
      __dmb(0xBu);
      return 40962;
  }
}
// 10168: using guessed type int elf_hash_chain[22025];
// 2567C0: using guessed type ALint var_1C[7];

//----- (00257208) --------------------------------------------------------
void __fastcall alSource3f(ALuint source, ALenum param, ALfloat value1, ALfloat value2, ALfloat value3)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v10; // r4
  ALsource_0 *v11; // r0
  unsigned int *v13; // r0
  unsigned int *p_LastError; // r0
  ALfloat values[9]; // [sp+4h] [bp-24h] BYREF

  ContextRef = j_GetContextRef();
  v10 = ContextRef;
  if ( ContextRef )
  {
    v11 = (ALsource_0 *)j_LookupUIntMapKey(&ContextRef->SourceMap, source);
    if ( v11 )
    {
      if ( (unsigned int)(param - 4100) < 3 )
      {
        values[1] = value2;
        values[0] = value1;
        values[2] = value3;
        SetSourcefv(v11, v10, (SrcFloatProp_0)param, values);
LABEL_20:
        j_ALCcontext_DecRef(v10);
        return;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v10->ref) )
      {
        p_LastError = (unsigned int *)&v10->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_18;
        }
        goto LABEL_19;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v10->ref) )
      {
        v13 = (unsigned int *)&v10->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v13) )
        {
          if ( __ldrex(v13) )
            goto LABEL_18;
        }
        goto LABEL_19;
      }
    }
LABEL_18:
    __clrex();
LABEL_19:
    __dmb(0xBu);
    goto LABEL_20;
  }
}

//----- (002572E4) --------------------------------------------------------
void __fastcall alSourcefv(ALuint source, ALenum param, const ALfloat *values)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  ALsource_0 *v8; // r0
  unsigned int *v10; // r0
  unsigned int *v13; // r0
  bool v15; // zf
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (ALsource_0 *)j_LookupUIntMapKey(&ContextRef->SourceMap, source);
    if ( v8 )
    {
      if ( values )
      {
        if ( param < 49152 )
        {
          switch ( param )
          {
            case 4097:
            case 4098:
            case 4099:
            case 4100:
            case 4101:
            case 4102:
            case 4103:
            case 4105:
            case 4106:
            case 4109:
            case 4110:
            case 4112:
            case 4117:
            case 4118:
            case 4128:
            case 4129:
            case 4130:
            case 4131:
            case 4132:
            case 4133:
            case 4134:
            case 4135:
            case 4145:
            case 4146:
            case 4147:
              goto LABEL_6;
            case 4104:
            case 4107:
            case 4108:
            case 4111:
            case 4113:
            case 4114:
            case 4115:
            case 4116:
            case 4119:
            case 4120:
            case 4121:
            case 4122:
            case 4123:
            case 4124:
            case 4125:
            case 4126:
            case 4127:
            case 4136:
            case 4137:
            case 4138:
            case 4139:
            case 4140:
            case 4141:
            case 4142:
            case 4143:
            case 4144:
              goto LABEL_30;
            default:
              if ( param != 514 )
                goto LABEL_30;
              goto LABEL_6;
          }
        }
        if ( (unsigned int)(param - 131079) < 6 )
          goto LABEL_6;
        v15 = param == 49152;
        if ( param != 49152 )
          v15 = param == 53248;
        if ( v15 )
        {
LABEL_6:
          SetSourcefv(v8, v7, (SrcFloatProp_0)param, values);
LABEL_23:
          ALCcontext_DecRef(v7);
          return;
        }
LABEL_30:
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          p_LastError = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_21;
          }
          goto LABEL_22;
        }
      }
      else
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          v13 = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, v13) )
          {
            if ( __ldrex(v13) )
              goto LABEL_21;
          }
          goto LABEL_22;
        }
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        v10 = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v10) )
        {
          if ( __ldrex(v10) )
            goto LABEL_21;
        }
        goto LABEL_22;
      }
    }
LABEL_21:
    __clrex();
LABEL_22:
    __dmb(0xBu);
    goto LABEL_23;
  }
}

//----- (00257454) --------------------------------------------------------
void __fastcall alSourcedSOFT(ALuint source, ALenum param, ALdouble value)
{
  unsigned int v3; // r8
  unsigned int v4; // r9
  ALCcontext *ContextRef; // r0
  ALCcontext *v8; // r4
  ALsource_0 *v9; // r0
  unsigned int *v11; // r0
  bool v13; // zf
  ALfloat v14; // s0
  unsigned int *p_LastError; // r0
  ALfloat values[7]; // [sp+4h] [bp-1Ch] BYREF

  v3 = HIDWORD(value);
  v4 = LODWORD(value);
  ContextRef = j_GetContextRef();
  v8 = ContextRef;
  if ( ContextRef )
  {
    v9 = (ALsource_0 *)j_LookupUIntMapKey(&ContextRef->SourceMap, source);
    if ( v9 )
    {
      if ( param < 49152 )
      {
        switch ( param )
        {
          case 4097:
          case 4098:
          case 4099:
          case 4103:
          case 4105:
          case 4106:
          case 4109:
          case 4110:
          case 4112:
          case 4117:
          case 4118:
          case 4128:
          case 4129:
          case 4130:
          case 4131:
          case 4132:
          case 4133:
          case 4134:
          case 4135:
          case 4147:
            goto LABEL_17;
          case 4100:
          case 4101:
          case 4102:
          case 4104:
          case 4107:
          case 4108:
          case 4111:
          case 4113:
          case 4114:
          case 4115:
          case 4116:
          case 4119:
          case 4120:
          case 4121:
          case 4122:
          case 4123:
          case 4124:
          case 4125:
          case 4126:
          case 4127:
          case 4136:
          case 4137:
          case 4138:
          case 4139:
          case 4140:
          case 4141:
          case 4142:
          case 4143:
          case 4144:
          case 4145:
          case 4146:
            goto LABEL_19;
          default:
            if ( param != 514 )
              goto LABEL_19;
            goto LABEL_17;
        }
      }
      if ( (unsigned int)(param - 131079) < 6 )
        goto LABEL_17;
      v13 = param == 49152;
      if ( param != 49152 )
        v13 = param == 53248;
      if ( v13 )
      {
LABEL_17:
        v14 = COERCE_DOUBLE(__PAIR64__(v3, v4));
        values[0] = v14;
        SetSourcefv(v9, v8, (SrcFloatProp_0)param, values);
LABEL_27:
        j_ALCcontext_DecRef(v8);
        return;
      }
LABEL_19:
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v8->ref) )
      {
        p_LastError = (unsigned int *)&v8->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_25;
        }
        goto LABEL_26;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v8->ref) )
      {
        v11 = (unsigned int *)&v8->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v11) )
        {
          if ( __ldrex(v11) )
            goto LABEL_25;
        }
        goto LABEL_26;
      }
    }
LABEL_25:
    __clrex();
LABEL_26:
    __dmb(0xBu);
    goto LABEL_27;
  }
}
// 257454: using guessed type ALfloat values[7];

//----- (00257588) --------------------------------------------------------
void __fastcall alSource3dSOFT(ALuint source, ALenum param, ALdouble value1, ALdouble value2, ALdouble value3)
{
  unsigned int v5; // r8
  unsigned int v6; // r9
  ALCcontext *ContextRef; // r0
  ALCcontext *v10; // r4
  ALsource_0 *v11; // r0
  ALfloat v12; // s2
  ALfloat v13; // s0
  ALfloat v14; // s4
  unsigned int *v16; // r0
  unsigned int *p_LastError; // r0
  ALfloat values[9]; // [sp+4h] [bp-24h] BYREF

  v5 = HIDWORD(value1);
  v6 = LODWORD(value1);
  ContextRef = j_GetContextRef();
  v10 = ContextRef;
  if ( ContextRef )
  {
    v11 = (ALsource_0 *)j_LookupUIntMapKey(&ContextRef->SourceMap, source);
    if ( v11 )
    {
      if ( (unsigned int)(param - 4100) < 3 )
      {
        v12 = COERCE_DOUBLE(__PAIR64__(v5, v6));
        v13 = value2;
        v14 = value3;
        values[1] = v13;
        values[0] = v12;
        values[2] = v14;
        SetSourcefv(v11, v10, (SrcFloatProp_0)param, values);
LABEL_20:
        j_ALCcontext_DecRef(v10);
        return;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v10->ref) )
      {
        p_LastError = (unsigned int *)&v10->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_18;
        }
        goto LABEL_19;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v10->ref) )
      {
        v16 = (unsigned int *)&v10->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v16) )
        {
          if ( __ldrex(v16) )
            goto LABEL_18;
        }
        goto LABEL_19;
      }
    }
LABEL_18:
    __clrex();
LABEL_19:
    __dmb(0xBu);
    goto LABEL_20;
  }
}

//----- (00257670) --------------------------------------------------------
void __fastcall alSourcedvSOFT(ALuint source, ALenum param, const ALdouble *values)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  ALsource_0 *v8; // r0
  int v9; // r1
  unsigned int *p_LastError; // r0
  unsigned int *v14; // r0
  bool v16; // zf
  ALfloat *v17; // r3
  int v18; // r2
  double v19; // d16
  ALfloat v20; // s0
  unsigned int *v22; // r0
  ALfloat v24[7]; // [sp+4h] [bp-1Ch] BYREF

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (ALsource_0 *)j_LookupUIntMapKey(&ContextRef->SourceMap, source);
    if ( !v8 )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        p_LastError = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_20;
        }
        goto LABEL_21;
      }
      goto LABEL_20;
    }
    if ( !values )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        v14 = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v14) )
        {
          if ( __ldrex(v14) )
            goto LABEL_20;
        }
        goto LABEL_21;
      }
      goto LABEL_20;
    }
    v9 = 1;
    if ( param <= 4608 )
    {
      switch ( param )
      {
        case 4097:
        case 4098:
        case 4099:
        case 4103:
        case 4105:
        case 4106:
        case 4109:
        case 4110:
        case 4112:
        case 4117:
        case 4118:
        case 4128:
        case 4129:
        case 4130:
        case 4131:
        case 4132:
        case 4133:
        case 4134:
        case 4135:
        case 4147:
          goto LABEL_32;
        case 4100:
        case 4101:
        case 4102:
          v9 = 3;
          goto LABEL_32;
        case 4104:
        case 4107:
        case 4108:
        case 4111:
        case 4113:
        case 4114:
        case 4115:
        case 4116:
        case 4119:
        case 4120:
        case 4121:
        case 4122:
        case 4123:
        case 4124:
        case 4125:
        case 4126:
        case 4127:
        case 4136:
        case 4137:
        case 4138:
        case 4139:
        case 4140:
        case 4141:
        case 4142:
        case 4143:
        case 4144:
          goto LABEL_37;
        case 4145:
        case 4146:
          goto LABEL_30;
        default:
          if ( param == 514 )
            goto LABEL_32;
          goto LABEL_37;
      }
    }
    if ( param <= 131078 )
    {
      if ( param == 4609 )
      {
LABEL_30:
        v9 = 2;
      }
      else
      {
        v16 = param == 49152;
        if ( param != 49152 )
          v16 = param == 53248;
        if ( !v16 )
        {
LABEL_37:
          if ( TrapALError )
            raise(5);
          if ( !__ldrex((unsigned int *)&v7->ref) )
          {
            v22 = (unsigned int *)&v7->LastError;
            __dmb(0xBu);
            while ( __strex(0xA002u, v22) )
            {
              if ( __ldrex(v22) )
                goto LABEL_20;
            }
            goto LABEL_21;
          }
LABEL_20:
          __clrex();
LABEL_21:
          __dmb(0xBu);
LABEL_35:
          j_ALCcontext_DecRef(v7);
          return;
        }
      }
    }
    else if ( (unsigned int)(param - 131079) >= 6 )
    {
      goto LABEL_37;
    }
LABEL_32:
    v17 = v24;
    v18 = 0;
    do
    {
      v19 = *values;
      ++v18;
      ++values;
      v20 = v19;
      *v17++ = v20;
    }
    while ( v18 < v9 );
    SetSourcefv(v8, v7, (SrcFloatProp_0)param, v24);
    goto LABEL_35;
  }
}

//----- (00257810) --------------------------------------------------------
void __fastcall alSourcei(ALuint source, ALenum param, ALint value)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v6; // r4
  ALsource_0 *v7; // r0
  unsigned int *v9; // r0
  bool v11; // zf
  unsigned int *p_LastError; // r0
  ALint values[5]; // [sp+4h] [bp-14h] BYREF

  values[0] = value;
  ContextRef = j_GetContextRef();
  v6 = ContextRef;
  if ( ContextRef )
  {
    v7 = (ALsource_0 *)j_LookupUIntMapKey(&ContextRef->SourceMap, source);
    if ( v7 )
    {
      if ( param < 49152 )
      {
        switch ( param )
        {
          case 4097:
          case 4098:
          case 4103:
          case 4105:
          case 4112:
          case 4117:
          case 4118:
          case 4128:
          case 4129:
          case 4131:
          case 4132:
          case 4133:
          case 4134:
          case 4135:
          case 4147:
            goto LABEL_18;
          case 4099:
          case 4100:
          case 4101:
          case 4102:
          case 4104:
          case 4106:
          case 4107:
          case 4108:
          case 4109:
          case 4110:
          case 4111:
          case 4113:
          case 4114:
          case 4115:
          case 4116:
          case 4119:
          case 4120:
          case 4121:
          case 4122:
          case 4123:
          case 4124:
          case 4125:
          case 4126:
          case 4127:
          case 4130:
          case 4136:
          case 4137:
          case 4138:
          case 4139:
          case 4140:
          case 4141:
          case 4142:
          case 4143:
          case 4144:
          case 4145:
          case 4146:
            goto LABEL_20;
          default:
            if ( param != 514 )
              goto LABEL_20;
            goto LABEL_18;
        }
      }
      if ( (unsigned int)(param - 131077) <= 7 && ((1 << (param - 5)) & 0xE1) != 0 )
        goto LABEL_18;
      v11 = param == 49152;
      if ( param != 49152 )
        v11 = param == 53248;
      if ( v11 )
      {
LABEL_18:
        SetSourceiv(v7, v6, (SrcIntProp_0)param, values);
LABEL_28:
        j_ALCcontext_DecRef(v6);
        return;
      }
LABEL_20:
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v6->ref) )
      {
        p_LastError = (unsigned int *)&v6->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_26;
        }
        goto LABEL_27;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v6->ref) )
      {
        v9 = (unsigned int *)&v6->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v9) )
        {
          if ( __ldrex(v9) )
            goto LABEL_26;
        }
        goto LABEL_27;
      }
    }
LABEL_26:
    __clrex();
LABEL_27:
    __dmb(0xBu);
    goto LABEL_28;
  }
}
// 257810: using guessed type ALint values[5];

//----- (00257944) --------------------------------------------------------
ALenum __fastcall SetSourceiv(ALsource_0 *Source, ALCcontext *Context, SrcIntProp_0 prop, const ALint *values)
{
  ALCdevice *Device; // r4
  ALfloat *v9; // r5
  unsigned int *v11; // r0
  ALenum result; // r0
  volatile ALenum state; // r0
  unsigned int *v16; // r0
  ALint v18; // r0
  unsigned int *v20; // r0
  unsigned int *v23; // r0
  unsigned int *v26; // r0
  char *v28; // r5
  unsigned int *v29; // r11
  unsigned int *v31; // r0
  unsigned int *v34; // r0
  unsigned int *v37; // r0
  unsigned int *v40; // r0
  unsigned int *v43; // r0
  unsigned int *v46; // r0
  ALfloat v48; // s0
  _DWORD *v49; // r0
  unsigned int *v50; // r1
  unsigned int v51; // r2
  unsigned int *p_queue; // r1
  unsigned int v53; // r4
  unsigned int *v54; // r5
  unsigned int v55; // r1
  unsigned int v56; // r0
  unsigned int *v57; // r10
  unsigned int v58; // r0
  unsigned int v59; // r0
  unsigned int *v60; // r6
  unsigned int v61; // r0
  unsigned int *v62; // r11
  unsigned int v63; // r0
  unsigned int v64; // r0
  unsigned int v65; // r0
  ALuint v66; // r0
  unsigned int *p_LastError; // r0
  unsigned int *v71; // r0
  unsigned int *v74; // r0
  unsigned int *v76; // r0
  ALuint v77; // r1
  ALfloat *v78; // r0
  unsigned int *v80; // r0
  unsigned int *v83; // r0
  unsigned int v85; // r0
  ALuint v86; // r0
  unsigned int v87; // r0
  unsigned int *v88; // r0
  unsigned int v89; // r3
  ALvoid (*v90)(ALsource *, const ALCcontext *); // r0
  void *v91; // r0
  __int64 v92; // kr00_8
  unsigned int *v93; // r1
  unsigned int v94; // r2
  int v95; // r1
  unsigned int *v96; // r1
  unsigned int v97; // r2
  ALint v98; // r1
  unsigned int *v99; // r2
  unsigned int v100; // r1
  unsigned int *v101; // r1
  unsigned int v102; // r2
  ALfloat v103; // s0
  unsigned int *v104; // [sp+4h] [bp-2Ch]
  ALfloat v105[10]; // [sp+8h] [bp-28h] BYREF

  Device = Context->Device;
  if ( prop >= siDopplerFactor )
  {
    switch ( prop )
    {
      case 131077:
        if ( !*values )
        {
          v9 = 0;
          goto LABEL_121;
        }
        v9 = (ALfloat *)j_LookupUIntMapKey(&Device->FilterMap, *values);
        if ( v9 )
        {
          Device = Context->Device;
LABEL_121:
          (*(void (__fastcall **)(ALCdevice *))(*(int *)((char *)&elf_hash_chain[6161] + (_DWORD)Device) + 44))(Device);
          if ( v9 )
          {
            Source->DirectGain = v9[1];
            v48 = v9[2];
          }
          else
          {
            v48 = 1.0;
            Source->DirectGain = 1.0;
          }
          Source->DirectGainHF = v48;
          (*(void (**)(void))(*(volatile RefCount *)((char *)&Context->Device->ref + (unsigned int)&elf_hash_chain[6161])
                            + 48))();
          goto LABEL_160;
        }
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&Context->ref) )
        {
          p_LastError = (unsigned int *)&Context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, p_LastError) )
              goto LABEL_197;
          }
          while ( !__ldrex(p_LastError) );
        }
        goto LABEL_196;
      case 131078:
        (*(void (__fastcall **)(ALCdevice *))(*(int *)((char *)&elf_hash_chain[6161] + (_DWORD)Device) + 44))(Device);
        if ( values[1] >= Device->NumAuxSends )
          goto LABEL_190;
        if ( *values )
        {
          v28 = (char *)j_LookupUIntMapKey(&Context->EffectSlotMap, *values);
          if ( !v28 )
          {
LABEL_190:
            (*(void (**)(void))(*(volatile RefCount *)((char *)&Context->Device->ref
                                                     + (unsigned int)&elf_hash_chain[6161])
                              + 48))();
            if ( TrapALError )
              raise(5);
            if ( !__ldrex((unsigned int *)&Context->ref) )
            {
              v80 = (unsigned int *)&Context->LastError;
              __dmb(0xBu);
              do
              {
                if ( !__strex(0xA003u, v80) )
                  goto LABEL_197;
              }
              while ( !__ldrex(v80) );
            }
LABEL_196:
            __clrex();
LABEL_197:
            __dmb(0xBu);
            return 40963;
          }
        }
        else
        {
          v28 = 0;
        }
        v77 = values[2];
        if ( v77 )
        {
          v78 = (ALfloat *)j_LookupUIntMapKey(&Device->FilterMap, v77);
          if ( !v78 )
            goto LABEL_190;
        }
        else
        {
          v78 = 0;
        }
        if ( v28 )
        {
          __dmb(0xBu);
          v96 = (unsigned int *)(v28 + 8408);
          do
            v97 = __ldrex(v96);
          while ( __strex(v97 + 1, v96) );
          __dmb(0xBu);
        }
        v98 = values[1];
        __dmb(0xBu);
        v99 = (unsigned int *)&Source->Send[v98];
        do
          v100 = __ldrex(v99);
        while ( __strex((unsigned int)v28, v99) );
        __dmb(0xBu);
        if ( v100 )
        {
          v101 = (unsigned int *)(v100 + 8408);
          __dmb(0xBu);
          do
            v102 = __ldrex(v101);
          while ( __strex(v102 - 1, v101) );
          __dmb(0xBu);
        }
        if ( v78 )
        {
          Source->Send[values[1]].Gain = v78[1];
          v103 = v78[2];
        }
        else
        {
          v103 = 1.0;
          Source->Send[values[1]].Gain = 1.0;
        }
        Source->Send[values[1]].GainHF = v103;
        Source->NeedsUpdate = 1;
LABEL_241:
        v95 = *(volatile RefCount *)((char *)&Context->Device->ref + (unsigned int)&elf_hash_chain[6161]);
LABEL_242:
        (*(void (**)(void))(v95 + 48))();
        return 0;
      case 131079:
      case 131080:
      case 131081:
        goto LABEL_51;
      case 131082:
        if ( *values < 2u )
        {
          Source->DryGainHFAuto = *values;
          goto LABEL_160;
        }
        if ( TrapALError )
          raise(5);
        if ( __ldrex((unsigned int *)&Context->ref) )
          goto LABEL_196;
        v31 = (unsigned int *)&Context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v31) )
        {
          if ( __ldrex(v31) )
            goto LABEL_196;
        }
        goto LABEL_197;
      case 131083:
        if ( *values < 2u )
        {
          Source->WetGainAuto = *values;
          goto LABEL_160;
        }
        if ( TrapALError )
          raise(5);
        if ( __ldrex((unsigned int *)&Context->ref) )
          goto LABEL_196;
        v34 = (unsigned int *)&Context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v34) )
        {
          if ( __ldrex(v34) )
            goto LABEL_196;
        }
        goto LABEL_197;
      case 131084:
        if ( *values < 2u )
        {
          Source->WetGainHFAuto = *values;
          goto LABEL_160;
        }
        if ( TrapALError )
          raise(5);
        if ( __ldrex((unsigned int *)&Context->ref) )
          goto LABEL_196;
        v37 = (unsigned int *)&Context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v37) )
        {
          if ( __ldrex(v37) )
            goto LABEL_196;
        }
        goto LABEL_197;
      default:
        if ( prop == siDopplerFactor )
        {
LABEL_3:
          v105[0] = (float)*values;
          return SetSourcefv(Source, Context, (SrcFloatProp_0)prop, v105);
        }
        if ( prop != siDistanceModel )
        {
LABEL_51:
          if ( LogLevel_0 )
            j_al_print("(EE)", "SetSourceiv", "Unexpected property: 0x%04x\n", prop);
          if ( TrapALError )
            raise(5);
          if ( __ldrex((unsigned int *)&Context->ref) )
          {
LABEL_59:
            __clrex();
          }
          else
          {
            v26 = (unsigned int *)&Context->LastError;
            __dmb(0xBu);
            while ( __strex(0xA002u, v26) )
            {
              if ( __ldrex(v26) )
                goto LABEL_59;
            }
          }
          __dmb(0xBu);
          return 40962;
        }
        v18 = *values;
        if ( (unsigned int)(*values - 53249) < 6 || !v18 )
        {
          Source->DistanceModel = v18;
          if ( Context->SourceDistanceModel )
LABEL_160:
            Source->NeedsUpdate = 1;
          return 0;
        }
        if ( TrapALError )
          raise(5);
        if ( __ldrex((unsigned int *)&Context->ref) )
          goto LABEL_196;
        v74 = (unsigned int *)&Context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v74) )
        {
          if ( __ldrex(v74) )
            goto LABEL_196;
        }
        goto LABEL_197;
    }
  }
  switch ( prop )
  {
    case 4097:
    case 4098:
    case 4128:
    case 4129:
    case 4131:
      goto LABEL_3;
    case 4099:
    case 4104:
    case 4106:
    case 4107:
    case 4108:
    case 4109:
    case 4110:
    case 4111:
    case 4113:
    case 4114:
    case 4115:
    case 4116:
    case 4119:
    case 4120:
    case 4121:
    case 4122:
    case 4123:
    case 4124:
    case 4125:
    case 4126:
    case 4127:
    case 4130:
    case 4136:
    case 4137:
    case 4138:
    case 4139:
    case 4140:
    case 4141:
    case 4142:
    case 4143:
    case 4144:
      goto LABEL_51;
    case 4100:
    case 4101:
    case 4102:
      v105[0] = (float)*values;
      v105[1] = (float)values[1];
      v105[2] = (float)values[2];
      return SetSourcefv(Source, Context, (SrcFloatProp_0)prop, v105);
    case 4103:
      if ( *values < 2u )
      {
        Source->Looping = *values;
        return 0;
      }
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&Context->ref) )
        goto LABEL_196;
      v40 = (unsigned int *)&Context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA003u, v40) )
      {
        if ( __ldrex(v40) )
          goto LABEL_196;
      }
      goto LABEL_197;
    case 4105:
      if ( *values )
      {
        v29 = (unsigned int *)j_LookupUIntMapKey(&Device->BufferMap, *values);
        if ( !v29 )
        {
          if ( TrapALError )
            raise(5);
          if ( !__ldrex((unsigned int *)&Context->ref) )
          {
            v71 = (unsigned int *)&Context->LastError;
            __dmb(0xBu);
            do
            {
              if ( !__strex(0xA003u, v71) )
                goto LABEL_197;
            }
            while ( !__ldrex(v71) );
          }
          goto LABEL_196;
        }
        Device = Context->Device;
      }
      else
      {
        v29 = 0;
      }
      (*(void (__fastcall **)(ALCdevice *))(*(int *)((char *)&elf_hash_chain[6161] + (_DWORD)Device) + 44))(Device);
      if ( Source->state == 4116 || Source->state == 4113 )
      {
        Source->BuffersInQueue = 0;
        Source->BuffersPlayed = 0;
        if ( v29 )
        {
          Source->SourceType = 4136;
          v49 = malloc(0xCu);
          v50 = v29 + 11;
          *v49 = v29;
          v49[1] = 0;
          v49[2] = 0;
          __dmb(0xBu);
          do
            v51 = __ldrex(v50);
          while ( __strex(v51 + 1, v50) );
          p_queue = (unsigned int *)&Source->queue;
          __dmb(0xBu);
          __dmb(0xBu);
          do
            v53 = __ldrex(p_queue);
          while ( __strex((unsigned int)v49, p_queue) );
          v54 = v29 + 15;
          __dmb(0xBu);
          Source->BuffersInQueue = 1;
          __dmb(0xBu);
          do
            v55 = __ldrex(v54);
          while ( __strex(1u, v54) );
          __dmb(0xBu);
          if ( v55 == 1 )
          {
            do
            {
              sched_yield();
              __dmb(0xBu);
              do
                v56 = __ldrex(v54);
              while ( __strex(1u, v54) );
              __dmb(0xBu);
            }
            while ( v56 == 1 );
          }
          v57 = v29 + 14;
          __dmb(0xBu);
          do
            v58 = __ldrex(v57);
          while ( __strex(1u, v57) );
          __dmb(0xBu);
          if ( v58 == 1 )
          {
            do
            {
              sched_yield();
              __dmb(0xBu);
              do
                v59 = __ldrex(v57);
              while ( __strex(1u, v57) );
              __dmb(0xBu);
            }
            while ( v59 == 1 );
          }
          v60 = v29 + 12;
          __dmb(0xBu);
          v104 = v29;
          do
            v61 = __ldrex(v60);
          while ( __strex(v61 + 1, v60) );
          __dmb(0xBu);
          if ( !v61 )
          {
            __dmb(0xBu);
            v62 = v29 + 16;
            do
              v63 = __ldrex(v62);
            while ( __strex(1u, v62) );
            __dmb(0xBu);
            if ( v63 == 1 )
            {
              do
              {
                sched_yield();
                __dmb(0xBu);
                do
                  v64 = __ldrex(v62);
                while ( __strex(1u, v62) );
                __dmb(0xBu);
              }
              while ( v64 == 1 );
            }
          }
          __dmb(0xBu);
          do
            __ldrex(v57);
          while ( __strex(0, v57) );
          __dmb(0xBu);
          __dmb(0xBu);
          do
            __ldrex(v54);
          while ( __strex(0, v54) );
          __dmb(0xBu);
          v65 = v104[4] - 5376;
          if ( v65 > 6 )
            v66 = 0;
          else
            v66 = dword_60A3C0[v65];
          Source->NumChannels = v66;
          v85 = v104[5] - 5120;
          if ( v85 > 6 )
            v86 = 0;
          else
            v86 = dword_60A2C0[v85];
          Source->SampleSize = v86;
          __dmb(0xBu);
          do
            v87 = __ldrex(v60);
          while ( __strex(v87 - 1, v60) );
          __dmb(0xBu);
          if ( v87 == 1 )
          {
            v88 = v104 + 16;
            __dmb(0xBu);
            do
              __ldrex(v88);
            while ( __strex(0, v88) );
            __dmb(0xBu);
          }
          v89 = v104[4];
          Source->NeedsUpdate = 1;
          v90 = CalcNonAttnSourceParams;
          if ( v89 == 5376 )
            v90 = CalcSourceParams;
          Source->Update = v90;
          if ( !v53 )
            goto LABEL_225;
        }
        else
        {
          Source->SourceType = 4144;
          v76 = (unsigned int *)&Source->queue;
          __dmb(0xBu);
          do
            v53 = __ldrex(v76);
          while ( __strex(0, v76) );
          __dmb(0xBu);
          if ( !v53 )
          {
LABEL_225:
            v95 = *(volatile RefCount *)((char *)&Context->Device->ref + (unsigned int)&elf_hash_chain[6161]);
            goto LABEL_242;
          }
        }
        v91 = (void *)v53;
        do
        {
          v92 = *(_QWORD *)v53;
          v53 = *(_DWORD *)(v53 + 4);
          if ( (_DWORD)v92 )
          {
            v93 = (unsigned int *)(v92 + 44);
            __dmb(0xBu);
            do
              v94 = __ldrex(v93);
            while ( __strex(v94 - 1, v93) );
            __dmb(0xBu);
          }
          free(v91);
          v91 = (void *)v53;
        }
        while ( v53 );
        goto LABEL_225;
      }
      (*(void (**)(void))(*(volatile RefCount *)((char *)&Context->Device->ref + (unsigned int)&elf_hash_chain[6161])
                        + 48))();
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&Context->ref) )
      {
        v83 = (unsigned int *)&Context->LastError;
        __dmb(0xBu);
        do
        {
          if ( !__strex(0xA004u, v83) )
            goto LABEL_205;
        }
        while ( !__ldrex(v83) );
      }
LABEL_204:
      __clrex();
LABEL_205:
      __dmb(0xBu);
      result = 40964;
      break;
    case 4112:
    case 4117:
    case 4118:
    case 4135:
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&Context->ref) )
        goto LABEL_204;
      v11 = (unsigned int *)&Context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA004u, v11) )
      {
        if ( __ldrex(v11) )
          goto LABEL_204;
      }
      goto LABEL_205;
    case 4132:
    case 4133:
    case 4134:
      if ( *values <= -1 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&Context->ref) )
        {
          v23 = (unsigned int *)&Context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v23) )
              goto LABEL_197;
          }
          while ( !__ldrex(v23) );
        }
      }
      else
      {
        (*(void (__fastcall **)(ALCdevice *))(*(int *)((char *)&elf_hash_chain[6161] + (_DWORD)Device) + 44))(Device);
        Source->OffsetType = prop;
        state = Source->state;
        Source->Offset = (double)*values;
        if ( state != 4114 && Source->state != 4115 || Context->DeferUpdates || j_ApplyOffset(Source) )
          goto LABEL_241;
        (*(void (**)(void))(*(volatile RefCount *)((char *)&Context->Device->ref + (unsigned int)&elf_hash_chain[6161])
                          + 48))();
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&Context->ref) )
        {
          v16 = (unsigned int *)&Context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v16) )
              goto LABEL_197;
          }
          while ( !__ldrex(v16) );
        }
      }
      goto LABEL_196;
    case 4145:
    case 4146:
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&Context->ref) )
        goto LABEL_204;
      v20 = (unsigned int *)&Context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA004u, v20) )
      {
        if ( __ldrex(v20) )
          goto LABEL_204;
      }
      goto LABEL_205;
    case 4147:
      if ( *values < 2u )
      {
        Source->DirectChannels = *values;
        goto LABEL_160;
      }
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&Context->ref) )
        goto LABEL_196;
      v43 = (unsigned int *)&Context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA003u, v43) )
      {
        if ( __ldrex(v43) )
          goto LABEL_196;
      }
      goto LABEL_197;
    default:
      if ( prop != siSourceRelative )
        goto LABEL_51;
      if ( *values < 2u )
      {
        Source->HeadRelative = *values;
        goto LABEL_160;
      }
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&Context->ref) )
        goto LABEL_196;
      v46 = (unsigned int *)&Context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA003u, v46) )
      {
        if ( __ldrex(v46) )
          goto LABEL_196;
      }
      goto LABEL_197;
  }
  return result;
}
// 10168: using guessed type int elf_hash_chain[22025];
// 60A2C0: using guessed type _DWORD dword_60A2C0[8];
// 60A3C0: using guessed type _DWORD dword_60A3C0[8];

//----- (002583C0) --------------------------------------------------------
void __fastcall alSource3i(ALuint source, ALenum param, ALint value1, ALint value2, ALint value3)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v10; // r4
  ALsource_0 *v11; // r0
  unsigned int *v13; // r0
  unsigned int *p_LastError; // r0
  ALint values[9]; // [sp+4h] [bp-24h] BYREF

  ContextRef = j_GetContextRef();
  v10 = ContextRef;
  if ( ContextRef )
  {
    v11 = (ALsource_0 *)j_LookupUIntMapKey(&ContextRef->SourceMap, source);
    if ( v11 )
    {
      if ( (unsigned int)(param - 4100) < 3 || param == 131078 )
      {
        values[0] = value1;
        values[1] = value2;
        values[2] = value3;
        SetSourceiv(v11, v10, (SrcIntProp_0)param, values);
LABEL_21:
        j_ALCcontext_DecRef(v10);
        return;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v10->ref) )
      {
        p_LastError = (unsigned int *)&v10->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_19;
        }
        goto LABEL_20;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v10->ref) )
      {
        v13 = (unsigned int *)&v10->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v13) )
        {
          if ( __ldrex(v13) )
            goto LABEL_19;
        }
        goto LABEL_20;
      }
    }
LABEL_19:
    __clrex();
LABEL_20:
    __dmb(0xBu);
    goto LABEL_21;
  }
}

//----- (00258494) --------------------------------------------------------
void __fastcall alSourceiv(ALuint source, ALenum param, const ALint *values)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  ALsource_0 *v8; // r0
  unsigned int *v10; // r0
  unsigned int *v13; // r0
  bool v15; // zf
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (ALsource_0 *)j_LookupUIntMapKey(&ContextRef->SourceMap, source);
    if ( v8 )
    {
      if ( values )
      {
        if ( param < 49152 )
        {
          switch ( param )
          {
            case 4097:
            case 4098:
            case 4100:
            case 4101:
            case 4102:
            case 4103:
            case 4105:
            case 4112:
            case 4117:
            case 4118:
            case 4128:
            case 4129:
            case 4131:
            case 4132:
            case 4133:
            case 4134:
            case 4135:
            case 4145:
            case 4146:
            case 4147:
              goto LABEL_27;
            case 4099:
            case 4104:
            case 4106:
            case 4107:
            case 4108:
            case 4109:
            case 4110:
            case 4111:
            case 4113:
            case 4114:
            case 4115:
            case 4116:
            case 4119:
            case 4120:
            case 4121:
            case 4122:
            case 4123:
            case 4124:
            case 4125:
            case 4126:
            case 4127:
            case 4130:
            case 4136:
            case 4137:
            case 4138:
            case 4139:
            case 4140:
            case 4141:
            case 4142:
            case 4143:
            case 4144:
              goto LABEL_29;
            default:
              if ( param != 514 )
                goto LABEL_29;
              goto LABEL_27;
          }
        }
        if ( (unsigned int)(param - 131077) <= 7 && ((1 << (param - 5)) & 0xE3) != 0 )
          goto LABEL_27;
        v15 = param == 49152;
        if ( param != 49152 )
          v15 = param == 53248;
        if ( v15 )
        {
LABEL_27:
          SetSourceiv(v8, v7, (SrcIntProp_0)param, values);
LABEL_37:
          ALCcontext_DecRef(v7);
          return;
        }
LABEL_29:
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          p_LastError = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_35;
          }
          goto LABEL_36;
        }
      }
      else
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          v13 = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, v13) )
          {
            if ( __ldrex(v13) )
              goto LABEL_35;
          }
          goto LABEL_36;
        }
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        v10 = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v10) )
        {
          if ( __ldrex(v10) )
            goto LABEL_35;
        }
        goto LABEL_36;
      }
    }
LABEL_35:
    __clrex();
LABEL_36:
    __dmb(0xBu);
    goto LABEL_37;
  }
}

//----- (00258610) --------------------------------------------------------
void __fastcall alSourcei64SOFT(ALuint a1, int a2, ALint64SOFT a3)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v6; // r4
  ALsource_0 *v7; // r0
  unsigned int *v9; // r0
  bool v11; // zf
  unsigned int *p_LastError; // r0
  ALint64SOFT v15[3]; // [sp+0h] [bp-18h] BYREF

  v15[0] = a3;
  ContextRef = j_GetContextRef();
  v6 = ContextRef;
  if ( ContextRef )
  {
    v7 = (ALsource_0 *)j_LookupUIntMapKey(&ContextRef->SourceMap, a1);
    if ( v7 )
    {
      if ( a2 < 49152 )
      {
        switch ( a2 )
        {
          case 4097:
          case 4098:
          case 4103:
          case 4105:
          case 4112:
          case 4117:
          case 4118:
          case 4128:
          case 4129:
          case 4131:
          case 4132:
          case 4133:
          case 4134:
          case 4135:
          case 4147:
            goto LABEL_19;
          case 4099:
          case 4100:
          case 4101:
          case 4102:
          case 4104:
          case 4106:
          case 4107:
          case 4108:
          case 4109:
          case 4110:
          case 4111:
          case 4113:
          case 4114:
          case 4115:
          case 4116:
          case 4119:
          case 4120:
          case 4121:
          case 4122:
          case 4123:
          case 4124:
          case 4125:
          case 4126:
          case 4127:
          case 4130:
          case 4136:
          case 4137:
          case 4138:
          case 4139:
          case 4140:
          case 4141:
          case 4142:
          case 4143:
          case 4144:
          case 4145:
          case 4146:
            goto LABEL_21;
          default:
            if ( a2 != 514 )
              goto LABEL_21;
            goto LABEL_19;
        }
      }
      if ( (unsigned int)(a2 - 131077) <= 7 && ((1 << (a2 - 5)) & 0xE1) != 0 )
        goto LABEL_19;
      v11 = a2 == 49152;
      if ( a2 != 49152 )
        v11 = a2 == 53248;
      if ( v11 )
      {
LABEL_19:
        SetSourcei64v(v7, v6, (SrcIntProp_0)a2, v15);
LABEL_29:
        ALCcontext_DecRef(v6);
        return;
      }
LABEL_21:
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v6->ref) )
      {
        p_LastError = (unsigned int *)&v6->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_27;
        }
        goto LABEL_28;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v6->ref) )
      {
        v9 = (unsigned int *)&v6->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v9) )
        {
          if ( __ldrex(v9) )
            goto LABEL_27;
        }
        goto LABEL_28;
      }
    }
LABEL_27:
    __clrex();
LABEL_28:
    __dmb(0xBu);
    goto LABEL_29;
  }
}
// 258610: using guessed type ALint64SOFT var_18[3];

//----- (0025874C) --------------------------------------------------------
unsigned int *__fastcall SetSourcei64v(
        ALsource_0 *Source,
        ALCcontext *Context,
        SrcIntProp_0 prop,
        const ALint64SOFT *values)
{
  int v6; // r0
  bool v7; // zf
  ALint v8; // r2
  ALint v9; // r1
  ALsource_0 *v10; // r0
  ALCcontext *v11; // r1
  unsigned int *result; // r0
  ALint64SOFT v14; // r0
  ALint v19[3]; // [sp+0h] [bp-28h] BYREF
  ALfloat valuesa[7]; // [sp+Ch] [bp-1Ch] BYREF

  if ( prop < siSampleOffsetLatencySOFT )
  {
    switch ( prop )
    {
      case 4097:
      case 4098:
      case 4128:
      case 4129:
      case 4131:
      case 4132:
        goto LABEL_3;
      case 4099:
      case 4104:
      case 4106:
      case 4107:
      case 4108:
      case 4109:
      case 4110:
      case 4111:
      case 4113:
      case 4114:
      case 4115:
      case 4116:
      case 4119:
      case 4120:
      case 4121:
      case 4122:
      case 4123:
      case 4124:
      case 4125:
      case 4126:
      case 4127:
      case 4130:
      case 4136:
      case 4137:
      case 4138:
      case 4139:
      case 4140:
      case 4141:
      case 4142:
      case 4143:
      case 4144:
        goto LABEL_40;
      case 4100:
      case 4101:
      case 4102:
        valuesa[0] = (float)*values;
        valuesa[1] = (float)values[1];
        valuesa[2] = (float)values[2];
        return (unsigned int *)SetSourcefv(Source, Context, (SrcFloatProp_0)prop, valuesa);
      case 4103:
      case 4112:
      case 4117:
      case 4118:
      case 4133:
      case 4134:
      case 4135:
      case 4147:
        goto LABEL_30;
      case 4105:
        goto LABEL_27;
      case 4145:
      case 4146:
        goto LABEL_18;
      default:
        if ( prop == siSourceRelative )
          goto LABEL_30;
        goto LABEL_40;
    }
  }
  if ( prop > 131076 )
  {
    if ( (unsigned int)(prop - 131082) >= 3 )
    {
      if ( prop != siDirectFilter )
      {
        if ( prop != siAuxSendFilter )
          goto LABEL_40;
        v6 = *((_DWORD *)values + 1);
        v7 = v6 == 0;
        if ( !v6 )
          v7 = *((_DWORD *)values + 3) == 0;
        if ( !v7 || *((_DWORD *)values + 5) )
        {
          if ( TrapALError )
            raise(5);
          result = (unsigned int *)__ldrex((unsigned int *)&Context->ref);
          if ( !result )
          {
            result = (unsigned int *)&Context->LastError;
            __dmb(0xBu);
            while ( __strex(0xA003u, result) )
            {
              if ( __ldrex(result) )
                goto LABEL_62;
            }
            goto LABEL_63;
          }
          goto LABEL_62;
        }
        v8 = *((_DWORD *)values + 4);
        v9 = *((_DWORD *)values + 2);
        v19[0] = *(_DWORD *)values;
        v19[1] = v9;
        v19[2] = v8;
        prop = siAuxSendFilter;
        v10 = Source;
        v11 = Context;
        return (unsigned int *)SetSourceiv(v10, v11, prop, v19);
      }
LABEL_27:
      if ( *((_DWORD *)values + 1) )
      {
        if ( TrapALError )
          raise(5);
        result = (unsigned int *)__ldrex((unsigned int *)&Context->ref);
        if ( !result )
        {
          result = (unsigned int *)&Context->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, result) )
          {
            if ( __ldrex(result) )
              goto LABEL_62;
          }
          goto LABEL_63;
        }
        goto LABEL_62;
      }
      LODWORD(v14) = *(_DWORD *)values;
LABEL_31:
      v19[0] = v14;
      v10 = Source;
      v11 = Context;
      return (unsigned int *)SetSourceiv(v10, v11, prop, v19);
    }
LABEL_30:
    v14 = *values;
    if ( (unsigned __int64)(*values + 0x80000000LL) >> 32 )
    {
      if ( TrapALError )
        raise(5);
      result = (unsigned int *)__ldrex((unsigned int *)&Context->ref);
      if ( !result )
      {
        result = (unsigned int *)&Context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, result) )
        {
          if ( __ldrex(result) )
            goto LABEL_62;
        }
        goto LABEL_63;
      }
      goto LABEL_62;
    }
    goto LABEL_31;
  }
  if ( prop == siSampleOffsetLatencySOFT )
  {
LABEL_18:
    if ( TrapALError )
      raise(5);
    result = (unsigned int *)__ldrex((unsigned int *)&Context->ref);
    if ( !result )
    {
      result = (unsigned int *)&Context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA004u, result) )
      {
        if ( __ldrex(result) )
          goto LABEL_62;
      }
      goto LABEL_63;
    }
    goto LABEL_62;
  }
  if ( prop != siDopplerFactor )
  {
    if ( prop != siDistanceModel )
    {
LABEL_40:
      if ( LogLevel_0 )
        j_al_print("(EE)", "SetSourcei64v", "Unexpected property: 0x%04x\n", prop);
      if ( TrapALError )
        raise(5);
      result = (unsigned int *)__ldrex((unsigned int *)&Context->ref);
      if ( !result )
      {
        result = (unsigned int *)&Context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, result) )
        {
          if ( __ldrex(result) )
            goto LABEL_62;
        }
        goto LABEL_63;
      }
LABEL_62:
      __clrex();
LABEL_63:
      __dmb(0xBu);
      return result;
    }
    goto LABEL_30;
  }
LABEL_3:
  valuesa[0] = (float)*values;
  return (unsigned int *)SetSourcefv(Source, Context, (SrcFloatProp_0)prop, valuesa);
}
// 25874C: using guessed type ALint var_28[3];

//----- (00258A18) --------------------------------------------------------
void __fastcall alSource3i64SOFT(
        ALuint a1,
        SrcIntProp_0 a2,
        unsigned int a3,
        unsigned int a4,
        ALint64SOFT a5,
        ALint64SOFT value2)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v10; // r4
  ALsource_0 *v11; // r0
  unsigned int *v13; // r0
  unsigned int *p_LastError; // r0
  ALint64SOFT values[7]; // [sp+8h] [bp-38h] BYREF

  ContextRef = j_GetContextRef();
  v10 = ContextRef;
  if ( ContextRef )
  {
    v11 = (ALsource_0 *)j_LookupUIntMapKey(&ContextRef->SourceMap, a1);
    if ( v11 )
    {
      if ( (unsigned int)(a2 - 4100) < 3 || a2 == siAuxSendFilter )
      {
        values[0] = __PAIR64__(a4, a3);
        values[2] = value2;
        values[1] = a5;
        SetSourcei64v(v11, v10, a2, values);
LABEL_22:
        ALCcontext_DecRef(v10);
        return;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v10->ref) )
      {
        p_LastError = (unsigned int *)&v10->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_20;
        }
        goto LABEL_21;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v10->ref) )
      {
        v13 = (unsigned int *)&v10->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v13) )
        {
          if ( __ldrex(v13) )
            goto LABEL_20;
        }
        goto LABEL_21;
      }
    }
LABEL_20:
    __clrex();
LABEL_21:
    __dmb(0xBu);
    goto LABEL_22;
  }
}
// 258A18: using guessed type ALint64SOFT arg_0;

//----- (00258B0C) --------------------------------------------------------
void __fastcall alSourcei64vSOFT(ALuint source, ALenum param, const ALint64SOFT *values)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  ALsource_0 *v8; // r0
  unsigned int *p_LastError; // r0
  unsigned int *v13; // r0
  bool v15; // zf
  unsigned int *v17; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (ALsource_0 *)j_LookupUIntMapKey(&ContextRef->SourceMap, source);
    if ( !v8 )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        p_LastError = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_21;
        }
        goto LABEL_22;
      }
      goto LABEL_21;
    }
    if ( !values )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        v13 = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v13) )
        {
          if ( __ldrex(v13) )
            goto LABEL_21;
        }
        goto LABEL_22;
      }
      goto LABEL_21;
    }
    if ( param < 4608 )
    {
      switch ( param )
      {
        case 4097:
        case 4098:
        case 4100:
        case 4101:
        case 4102:
        case 4103:
        case 4105:
        case 4112:
        case 4117:
        case 4118:
        case 4128:
        case 4129:
        case 4131:
        case 4132:
        case 4133:
        case 4134:
        case 4135:
        case 4145:
        case 4146:
        case 4147:
          goto LABEL_6;
        case 4099:
        case 4104:
        case 4106:
        case 4107:
        case 4108:
        case 4109:
        case 4110:
        case 4111:
        case 4113:
        case 4114:
        case 4115:
        case 4116:
        case 4119:
        case 4120:
        case 4121:
        case 4122:
        case 4123:
        case 4124:
        case 4125:
        case 4126:
        case 4127:
        case 4130:
        case 4136:
        case 4137:
        case 4138:
        case 4139:
        case 4140:
        case 4141:
        case 4142:
        case 4143:
        case 4144:
          goto LABEL_34;
        default:
          if ( param != 514 )
            goto LABEL_34;
          goto LABEL_6;
      }
    }
    if ( param <= 131076 )
    {
      v15 = param == 4608;
      if ( param != 4608 )
        v15 = param == 49152;
      if ( !v15 && param != 53248 )
      {
LABEL_34:
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          v17 = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, v17) )
          {
            if ( __ldrex(v17) )
              goto LABEL_21;
          }
          goto LABEL_22;
        }
LABEL_21:
        __clrex();
LABEL_22:
        __dmb(0xBu);
        goto LABEL_23;
      }
    }
    else if ( (unsigned int)(param - 131077) > 7 || ((1 << (param - 5)) & 0xE3) == 0 )
    {
      goto LABEL_34;
    }
LABEL_6:
    SetSourcei64v(v8, v7, (SrcIntProp_0)param, values);
LABEL_23:
    ALCcontext_DecRef(v7);
  }
}

//----- (00258C9C) --------------------------------------------------------
void __fastcall alGetSourcef(ALuint source, ALenum param, ALfloat *value)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  const ALsource_0 *v8; // r0
  unsigned int *v10; // r0
  unsigned int *v13; // r0
  bool v15; // zf
  ALfloat v16; // s0
  unsigned int *p_LastError; // r0
  ALdouble v20[3]; // [sp+0h] [bp-18h] BYREF

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (const ALsource_0 *)j_LookupUIntMapKey(&ContextRef->SourceMap, source);
    if ( v8 )
    {
      if ( value )
      {
        if ( param < 49152 )
        {
          switch ( param )
          {
            case 4097:
            case 4098:
            case 4099:
            case 4103:
            case 4105:
            case 4106:
            case 4109:
            case 4110:
            case 4112:
            case 4117:
            case 4118:
            case 4128:
            case 4129:
            case 4130:
            case 4131:
            case 4132:
            case 4133:
            case 4134:
            case 4135:
            case 4147:
              goto LABEL_25;
            case 4100:
            case 4101:
            case 4102:
            case 4104:
            case 4107:
            case 4108:
            case 4111:
            case 4113:
            case 4114:
            case 4115:
            case 4116:
            case 4119:
            case 4120:
            case 4121:
            case 4122:
            case 4123:
            case 4124:
            case 4125:
            case 4126:
            case 4127:
            case 4136:
            case 4137:
            case 4138:
            case 4139:
            case 4140:
            case 4141:
            case 4142:
            case 4143:
            case 4144:
            case 4145:
            case 4146:
              goto LABEL_28;
            default:
              if ( param != 514 )
                goto LABEL_28;
              goto LABEL_25;
          }
        }
        if ( (unsigned int)(param - 131079) < 6 )
          goto LABEL_25;
        v15 = param == 49152;
        if ( param != 49152 )
          v15 = param == 53248;
        if ( v15 )
        {
LABEL_25:
          if ( !GetSourcedv(v8, v7, (SrcFloatProp_0)param, v20) )
          {
            v16 = v20[0];
            *value = v16;
          }
          goto LABEL_36;
        }
LABEL_28:
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          p_LastError = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_34;
          }
          goto LABEL_35;
        }
      }
      else
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          v13 = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, v13) )
          {
            if ( __ldrex(v13) )
              goto LABEL_34;
          }
          goto LABEL_35;
        }
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        v10 = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v10) )
        {
          if ( __ldrex(v10) )
            goto LABEL_34;
        }
        goto LABEL_35;
      }
    }
LABEL_34:
    __clrex();
LABEL_35:
    __dmb(0xBu);
LABEL_36:
    j_ALCcontext_DecRef(v7);
  }
}
// 258C9C: using guessed type ALdouble var_18[3];

//----- (00258E18) --------------------------------------------------------
ALenum __fastcall GetSourcedv(const ALsource_0 *Source, ALCcontext *Context, SrcFloatProp_0 prop, ALdouble *values)
{
  int v8; // r3
  double v9; // d16
  float InnerAngle; // s0
  ALenum result; // r0
  int v12; // r3
  unsigned int *p_LastError; // r0
  float v16; // s0
  int v17; // r1
  ALuint BuffersPlayed; // r12
  ALbufferlistitem_0 *queue; // r2
  ALbufferlistitem_0 *v20; // r0
  ALbuffer *buffer; // r4
  double v22; // d16
  __int64 v23; // kr00_8
  bool v24; // zf
  unsigned __int64 v25; // r0
  unsigned int v26; // r6
  ALdouble v27; // [sp+0h] [bp-38h] BYREF
  ALdouble offset[5]; // [sp+10h] [bp-28h] BYREF

  if ( prop <= 4608 )
  {
    switch ( prop )
    {
      case 4097:
        InnerAngle = Source->InnerAngle;
        goto LABEL_49;
      case 4098:
        InnerAngle = Source->OuterAngle;
        goto LABEL_49;
      case 4099:
        InnerAngle = Source->Pitch;
        goto LABEL_49;
      case 4100:
        (*(void (**)(void))(*(volatile RefCount *)((char *)&Context->Device->ref + (unsigned int)&elf_hash_chain[6161])
                          + 44))();
        *values = Source->Position[0];
        values[1] = Source->Position[1];
        v16 = Source->Position[2];
        break;
      case 4101:
        (*(void (**)(void))(*(volatile RefCount *)((char *)&Context->Device->ref + (unsigned int)&elf_hash_chain[6161])
                          + 44))();
        *values = Source->Orientation[0];
        values[1] = Source->Orientation[1];
        v16 = Source->Orientation[2];
        break;
      case 4102:
        (*(void (**)(void))(*(volatile RefCount *)((char *)&Context->Device->ref + (unsigned int)&elf_hash_chain[6161])
                          + 44))();
        *values = Source->Velocity[0];
        values[1] = Source->Velocity[1];
        v16 = Source->Velocity[2];
        break;
      case 4103:
      case 4105:
      case 4112:
      case 4117:
      case 4118:
      case 4135:
      case 4147:
        goto LABEL_10;
      case 4104:
      case 4107:
      case 4108:
      case 4111:
      case 4113:
      case 4114:
      case 4115:
      case 4116:
      case 4119:
      case 4120:
      case 4121:
      case 4122:
      case 4123:
      case 4124:
      case 4125:
      case 4126:
      case 4127:
      case 4136:
      case 4137:
      case 4138:
      case 4139:
      case 4140:
      case 4141:
      case 4142:
      case 4143:
      case 4144:
        goto LABEL_14;
      case 4106:
        InnerAngle = Source->Gain;
        goto LABEL_49;
      case 4109:
        InnerAngle = Source->MinGain;
        goto LABEL_49;
      case 4110:
        InnerAngle = Source->MaxGain;
        goto LABEL_49;
      case 4128:
        InnerAngle = Source->RefDistance;
        goto LABEL_49;
      case 4129:
        InnerAngle = Source->RollOffFactor;
        goto LABEL_49;
      case 4130:
        InnerAngle = Source->OuterGain;
        goto LABEL_49;
      case 4131:
        InnerAngle = Source->MaxDistance;
        goto LABEL_49;
      case 4132:
      case 4133:
      case 4134:
        (*(void (**)(void))(*(volatile RefCount *)((char *)&Context->Device->ref + (unsigned int)&elf_hash_chain[6161])
                          + 44))();
        GetSourceOffsets(Source, prop, offset, v8, v27);
        (*(void (**)(void))(*(volatile RefCount *)((char *)&Context->Device->ref + (unsigned int)&elf_hash_chain[6161])
                          + 48))();
        v9 = offset[0];
        goto LABEL_50;
      case 4145:
      case 4146:
        (*(void (**)(void))(*(volatile RefCount *)((char *)&Context->Device->ref + (unsigned int)&elf_hash_chain[6161])
                          + 44))();
        GetSourceOffsets(Source, prop, values, v12, v27);
        goto LABEL_63;
      default:
        if ( prop != sfSourceRelative )
          goto LABEL_14;
        goto LABEL_10;
    }
    values[2] = v16;
    v17 = *(volatile RefCount *)((char *)&Context->Device->ref + (unsigned int)&elf_hash_chain[6161]);
    goto LABEL_64;
  }
  if ( prop > 131078 )
  {
    switch ( prop )
    {
      case sfAirAbsorptionFactor:
        InnerAngle = Source->AirAbsorptionFactor;
        goto LABEL_49;
      case sfRoomRolloffFactor:
        InnerAngle = Source->RoomRolloffFactor;
        goto LABEL_49;
      case sfConeOuterGainHF:
        InnerAngle = Source->OuterGainHF;
        goto LABEL_49;
      case sfDirectFilterGainHFAuto:
      case sfAuxSendFilterGainAuto:
      case sfAuxSendFilterGainHFAuto:
        goto LABEL_10;
      default:
        goto LABEL_14;
    }
  }
  switch ( prop )
  {
    case sfSecOffsetLatencySOFT:
      (*(void (**)(void))(*(volatile RefCount *)((char *)&Context->Device->ref + (unsigned int)&elf_hash_chain[6161])
                        + 44))();
      queue = Source->queue;
      if ( queue )
      {
        v20 = Source->queue;
        while ( 1 )
        {
          buffer = v20->buffer;
          if ( v20->buffer )
            break;
          v20 = v20->next;
          if ( !v20 )
            goto LABEL_44;
        }
      }
      else
      {
LABEL_44:
        buffer = 0;
      }
      if ( Source->state == 4114 )
      {
        if ( !buffer )
        {
          v22 = 0.0;
          goto LABEL_62;
        }
      }
      else
      {
        v22 = 0.0;
        if ( !buffer || Source->state != 4115 )
        {
LABEL_62:
          *values = v22;
          values[1] = (double)((__int64 (*)(void))*(_DWORD *)(*(volatile RefCount *)((char *)&Context->Device->ref
                                                                                   + (unsigned int)&elf_hash_chain[6161])
                                                            + 52))()
                    / 1000000000.0;
LABEL_63:
          v17 = *(volatile RefCount *)((char *)&Context->Device->ref + (unsigned int)&elf_hash_chain[6161]);
LABEL_64:
          (*(void (**)(void))(v17 + 48))();
          return 0;
        }
      }
      v23 = *(_QWORD *)&Source->position;
      v24 = queue == 0;
      if ( queue )
      {
        BuffersPlayed = Source->BuffersPlayed;
        v24 = BuffersPlayed == 0;
      }
      HIDWORD(v25) = (unsigned int)v23 >> 18;
      LODWORD(v25) = HIDWORD(v23) | ((_DWORD)v23 << 14);
      if ( !v24 )
      {
        v26 = 1;
        do
        {
          if ( queue->buffer )
            v25 += (__int64)queue->buffer->SampleLen << 14;
          if ( v26 >= BuffersPlayed )
            break;
          queue = queue->next;
          ++v26;
        }
        while ( queue );
      }
      v22 = (double)v25 * 0.0000610351562 / (double)buffer->Frequency;
      goto LABEL_62;
    case sfDopplerFactor:
      InnerAngle = Source->DopplerFactor;
LABEL_49:
      v9 = InnerAngle;
LABEL_50:
      *values = v9;
      return 0;
    case sfDistanceModel:
LABEL_10:
      result = GetSourceiv(Source, Context, (SrcIntProp_0)prop, (ALint *)&v27 + 1);
      if ( result )
        return result;
      v9 = (double)SHIDWORD(v27);
      goto LABEL_50;
  }
LABEL_14:
  if ( LogLevel_0 )
    j_al_print("(EE)", "GetSourcedv", "Unexpected property: 0x%04x\n", prop);
  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&Context->ref) )
  {
LABEL_22:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&Context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_22;
    }
  }
  result = 40962;
  __dmb(0xBu);
  return result;
}
// 258EDA: variable 'v8' is possibly undefined
// 258F7A: variable 'v12' is possibly undefined
// 259158: variable 'BuffersPlayed' is possibly undefined
// 10168: using guessed type int elf_hash_chain[22025];
// 258E18: using guessed type ALdouble offset[5];

//----- (002591E4) --------------------------------------------------------
void __fastcall alGetSource3f(ALuint source, ALenum param, ALfloat *value1, ALfloat *value2, float *a5)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v10; // r4
  const ALsource_0 *v11; // r0
  bool v12; // zf
  ALfloat v13; // s0
  ALfloat v14; // s0
  float v15; // s0
  unsigned int *v17; // r0
  unsigned int *p_LastError; // r0
  unsigned int *v23; // r0
  ALdouble v25[6]; // [sp+0h] [bp-30h] BYREF

  ContextRef = j_GetContextRef();
  v10 = ContextRef;
  if ( ContextRef )
  {
    v11 = (const ALsource_0 *)j_LookupUIntMapKey(&ContextRef->SourceMap, source);
    if ( v11 )
    {
      v12 = value1 == 0;
      if ( value1 )
        v12 = value2 == 0;
      if ( v12 || !a5 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v10->ref) )
        {
          p_LastError = (unsigned int *)&v10->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_30;
          }
          goto LABEL_31;
        }
      }
      else
      {
        if ( (unsigned int)(param - 4100) < 3 )
        {
          if ( !GetSourcedv(v11, v10, (SrcFloatProp_0)param, v25) )
          {
            v13 = v25[0];
            *value1 = v13;
            v14 = v25[1];
            *value2 = v14;
            v15 = v25[2];
            *a5 = v15;
          }
          goto LABEL_32;
        }
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v10->ref) )
        {
          v23 = (unsigned int *)&v10->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, v23) )
          {
            if ( __ldrex(v23) )
              goto LABEL_30;
          }
          goto LABEL_31;
        }
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v10->ref) )
      {
        v17 = (unsigned int *)&v10->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v17) )
        {
          if ( __ldrex(v17) )
            goto LABEL_30;
        }
        goto LABEL_31;
      }
    }
LABEL_30:
    __clrex();
LABEL_31:
    __dmb(0xBu);
LABEL_32:
    j_ALCcontext_DecRef(v10);
  }
}

//----- (0025931C) --------------------------------------------------------
void __fastcall alGetSourcefv(ALuint source, ALenum param, ALfloat *values)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r8
  const ALsource_0 *v8; // r0
  int v9; // r4
  unsigned int *v11; // r0
  unsigned int *v14; // r0
  bool v16; // zf
  int v17; // r0
  double *v18; // r1
  double v19; // d16
  ALfloat v20; // s0
  unsigned int *p_LastError; // r0
  ALdouble v24[5]; // [sp+0h] [bp-28h] BYREF

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (const ALsource_0 *)j_LookupUIntMapKey(&ContextRef->SourceMap, source);
    if ( v8 )
    {
      if ( values )
      {
        v9 = 1;
        if ( param < 49152 )
        {
          switch ( param )
          {
            case 4097:
            case 4098:
            case 4099:
            case 4103:
            case 4105:
            case 4106:
            case 4109:
            case 4110:
            case 4112:
            case 4117:
            case 4118:
            case 4128:
            case 4129:
            case 4130:
            case 4131:
            case 4132:
            case 4133:
            case 4134:
            case 4135:
            case 4147:
              goto LABEL_29;
            case 4100:
            case 4101:
            case 4102:
              v9 = 3;
              goto LABEL_29;
            case 4104:
            case 4107:
            case 4108:
            case 4111:
            case 4113:
            case 4114:
            case 4115:
            case 4116:
            case 4119:
            case 4120:
            case 4121:
            case 4122:
            case 4123:
            case 4124:
            case 4125:
            case 4126:
            case 4127:
            case 4136:
            case 4137:
            case 4138:
            case 4139:
            case 4140:
            case 4141:
            case 4142:
            case 4143:
            case 4144:
              goto LABEL_34;
            case 4145:
            case 4146:
              v9 = 2;
              goto LABEL_29;
            default:
              if ( param == 514 )
                goto LABEL_29;
              goto LABEL_34;
          }
        }
        if ( (unsigned int)(param - 131079) < 6 )
          goto LABEL_29;
        v16 = param == 49152;
        if ( param != 49152 )
          v16 = param == 53248;
        if ( v16 )
        {
LABEL_29:
          if ( !GetSourcedv(v8, v7, (SrcFloatProp_0)param, v24) )
          {
            v17 = 0;
            v18 = v24;
            do
            {
              v19 = *v18;
              ++v17;
              ++v18;
              v20 = v19;
              *values++ = v20;
            }
            while ( v17 < v9 );
          }
          goto LABEL_32;
        }
LABEL_34:
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          p_LastError = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_20;
          }
          goto LABEL_21;
        }
      }
      else
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          v14 = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, v14) )
          {
            if ( __ldrex(v14) )
              goto LABEL_20;
          }
          goto LABEL_21;
        }
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        v11 = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v11) )
        {
          if ( __ldrex(v11) )
            goto LABEL_20;
        }
        goto LABEL_21;
      }
    }
LABEL_20:
    __clrex();
LABEL_21:
    __dmb(0xBu);
LABEL_32:
    j_ALCcontext_DecRef(v7);
  }
}

//----- (002594AC) --------------------------------------------------------
void __fastcall alGetSourcedSOFT(ALuint source, ALenum param, ALdouble *value)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  const ALsource_0 *v8; // r0
  unsigned int *v10; // r0
  unsigned int *v13; // r0
  bool v15; // zf
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (const ALsource_0 *)j_LookupUIntMapKey(&ContextRef->SourceMap, source);
    if ( v8 )
    {
      if ( value )
      {
        if ( param < 49152 )
        {
          switch ( param )
          {
            case 4097:
            case 4098:
            case 4099:
            case 4103:
            case 4105:
            case 4106:
            case 4109:
            case 4110:
            case 4112:
            case 4117:
            case 4118:
            case 4128:
            case 4129:
            case 4130:
            case 4131:
            case 4132:
            case 4133:
            case 4134:
            case 4135:
            case 4147:
              goto LABEL_26;
            case 4100:
            case 4101:
            case 4102:
            case 4104:
            case 4107:
            case 4108:
            case 4111:
            case 4113:
            case 4114:
            case 4115:
            case 4116:
            case 4119:
            case 4120:
            case 4121:
            case 4122:
            case 4123:
            case 4124:
            case 4125:
            case 4126:
            case 4127:
            case 4136:
            case 4137:
            case 4138:
            case 4139:
            case 4140:
            case 4141:
            case 4142:
            case 4143:
            case 4144:
            case 4145:
            case 4146:
              goto LABEL_28;
            default:
              if ( param != 514 )
                goto LABEL_28;
              goto LABEL_26;
          }
        }
        if ( (unsigned int)(param - 131079) < 6 )
          goto LABEL_26;
        v15 = param == 49152;
        if ( param != 49152 )
          v15 = param == 53248;
        if ( v15 )
        {
LABEL_26:
          GetSourcedv(v8, v7, (SrcFloatProp_0)param, value);
LABEL_36:
          ALCcontext_DecRef(v7);
          return;
        }
LABEL_28:
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          p_LastError = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_34;
          }
          goto LABEL_35;
        }
      }
      else
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          v13 = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, v13) )
          {
            if ( __ldrex(v13) )
              goto LABEL_34;
          }
          goto LABEL_35;
        }
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        v10 = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v10) )
        {
          if ( __ldrex(v10) )
            goto LABEL_34;
        }
        goto LABEL_35;
      }
    }
LABEL_34:
    __clrex();
LABEL_35:
    __dmb(0xBu);
    goto LABEL_36;
  }
}

//----- (00259618) --------------------------------------------------------
void __fastcall alGetSource3dSOFT(ALuint source, ALenum param, ALdouble *value1, ALdouble *value2, ALdouble *a5)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v10; // r4
  const ALsource_0 *v11; // r0
  bool v12; // zf
  unsigned int *v14; // r0
  unsigned int *p_LastError; // r0
  unsigned int *v20; // r0
  ALdouble v22[6]; // [sp+0h] [bp-30h] BYREF

  ContextRef = j_GetContextRef();
  v10 = ContextRef;
  if ( ContextRef )
  {
    v11 = (const ALsource_0 *)j_LookupUIntMapKey(&ContextRef->SourceMap, source);
    if ( v11 )
    {
      v12 = value1 == 0;
      if ( value1 )
        v12 = value2 == 0;
      if ( v12 || !a5 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v10->ref) )
        {
          p_LastError = (unsigned int *)&v10->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_30;
          }
          goto LABEL_31;
        }
      }
      else
      {
        if ( (unsigned int)(param - 4100) < 3 )
        {
          if ( !GetSourcedv(v11, v10, (SrcFloatProp_0)param, v22) )
          {
            *value1 = v22[0];
            *value2 = v22[1];
            *a5 = v22[2];
          }
          goto LABEL_32;
        }
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v10->ref) )
        {
          v20 = (unsigned int *)&v10->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, v20) )
          {
            if ( __ldrex(v20) )
              goto LABEL_30;
          }
          goto LABEL_31;
        }
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v10->ref) )
      {
        v14 = (unsigned int *)&v10->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v14) )
        {
          if ( __ldrex(v14) )
            goto LABEL_30;
        }
        goto LABEL_31;
      }
    }
LABEL_30:
    __clrex();
LABEL_31:
    __dmb(0xBu);
LABEL_32:
    j_ALCcontext_DecRef(v10);
  }
}

//----- (00259740) --------------------------------------------------------
void __fastcall alGetSourcedvSOFT(ALuint source, ALenum param, ALdouble *values)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  const ALsource_0 *v8; // r0
  unsigned int *p_LastError; // r0
  unsigned int *v13; // r0
  bool v15; // zf
  unsigned int *v17; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (const ALsource_0 *)j_LookupUIntMapKey(&ContextRef->SourceMap, source);
    if ( !v8 )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        p_LastError = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_21;
        }
        goto LABEL_22;
      }
      goto LABEL_21;
    }
    if ( !values )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        v13 = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v13) )
        {
          if ( __ldrex(v13) )
            goto LABEL_21;
        }
        goto LABEL_22;
      }
      goto LABEL_21;
    }
    if ( param <= 4608 )
    {
      switch ( param )
      {
        case 4097:
        case 4098:
        case 4099:
        case 4100:
        case 4101:
        case 4102:
        case 4103:
        case 4105:
        case 4106:
        case 4109:
        case 4110:
        case 4112:
        case 4117:
        case 4118:
        case 4128:
        case 4129:
        case 4130:
        case 4131:
        case 4132:
        case 4133:
        case 4134:
        case 4135:
        case 4145:
        case 4146:
        case 4147:
          goto LABEL_6;
        case 4104:
        case 4107:
        case 4108:
        case 4111:
        case 4113:
        case 4114:
        case 4115:
        case 4116:
        case 4119:
        case 4120:
        case 4121:
        case 4122:
        case 4123:
        case 4124:
        case 4125:
        case 4126:
        case 4127:
        case 4136:
        case 4137:
        case 4138:
        case 4139:
        case 4140:
        case 4141:
        case 4142:
        case 4143:
        case 4144:
          goto LABEL_33;
        default:
          if ( param != 514 )
            goto LABEL_33;
          goto LABEL_6;
      }
    }
    if ( param <= 131078 )
    {
      v15 = param == 4609;
      if ( param != 4609 )
        v15 = param == 49152;
      if ( !v15 && param != 53248 )
      {
LABEL_33:
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          v17 = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, v17) )
          {
            if ( __ldrex(v17) )
              goto LABEL_21;
          }
          goto LABEL_22;
        }
LABEL_21:
        __clrex();
LABEL_22:
        __dmb(0xBu);
        goto LABEL_23;
      }
    }
    else if ( (unsigned int)(param - 131079) >= 6 )
    {
      goto LABEL_33;
    }
LABEL_6:
    GetSourcedv(v8, v7, (SrcFloatProp_0)param, values);
LABEL_23:
    ALCcontext_DecRef(v7);
  }
}

//----- (002598C4) --------------------------------------------------------
void __fastcall alGetSourcei(ALuint source, ALenum param, ALint *value)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  const ALsource_0 *v8; // r0
  unsigned int *v10; // r0
  unsigned int *v13; // r0
  bool v15; // zf
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (const ALsource_0 *)j_LookupUIntMapKey(&ContextRef->SourceMap, source);
    if ( v8 )
    {
      if ( value )
      {
        if ( param < 49152 )
        {
          switch ( param )
          {
            case 4097:
            case 4098:
            case 4103:
            case 4105:
            case 4112:
            case 4117:
            case 4118:
            case 4128:
            case 4129:
            case 4131:
            case 4132:
            case 4133:
            case 4134:
            case 4135:
            case 4147:
              goto LABEL_27;
            case 4099:
            case 4100:
            case 4101:
            case 4102:
            case 4104:
            case 4106:
            case 4107:
            case 4108:
            case 4109:
            case 4110:
            case 4111:
            case 4113:
            case 4114:
            case 4115:
            case 4116:
            case 4119:
            case 4120:
            case 4121:
            case 4122:
            case 4123:
            case 4124:
            case 4125:
            case 4126:
            case 4127:
            case 4130:
            case 4136:
            case 4137:
            case 4138:
            case 4139:
            case 4140:
            case 4141:
            case 4142:
            case 4143:
            case 4144:
            case 4145:
            case 4146:
              goto LABEL_29;
            default:
              if ( param != 514 )
                goto LABEL_29;
              goto LABEL_27;
          }
        }
        if ( (unsigned int)(param - 131077) <= 7 && ((1 << (param - 5)) & 0xE1) != 0 )
          goto LABEL_27;
        v15 = param == 49152;
        if ( param != 49152 )
          v15 = param == 53248;
        if ( v15 )
        {
LABEL_27:
          GetSourceiv(v8, v7, (SrcIntProp_0)param, value);
LABEL_37:
          ALCcontext_DecRef(v7);
          return;
        }
LABEL_29:
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          p_LastError = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_35;
          }
          goto LABEL_36;
        }
      }
      else
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          v13 = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, v13) )
          {
            if ( __ldrex(v13) )
              goto LABEL_35;
          }
          goto LABEL_36;
        }
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        v10 = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v10) )
        {
          if ( __ldrex(v10) )
            goto LABEL_35;
        }
        goto LABEL_36;
      }
    }
LABEL_35:
    __clrex();
LABEL_36:
    __dmb(0xBu);
    goto LABEL_37;
  }
}

//----- (00259A40) --------------------------------------------------------
ALenum __fastcall GetSourceiv(const ALsource_0 *Source, ALCcontext *Context, SrcIntProp_0 prop, ALint *values)
{
  ALenum result; // r0
  ALint Looping; // r0
  unsigned int *p_LastError; // r0
  ALuint SourceType; // r1
  ALbufferlistitem_0 *queue; // r0
  bool v14; // zf
  ALbuffer *buffer; // r0
  ALuint id; // r0
  ALdouble v17; // [sp+0h] [bp-28h] BYREF
  double v18; // [sp+8h] [bp-20h]
  double v19; // [sp+10h] [bp-18h]

  if ( prop < siDopplerFactor )
  {
    switch ( prop )
    {
      case 4097:
      case 4098:
      case 4128:
      case 4129:
      case 4131:
      case 4132:
      case 4133:
      case 4134:
        goto LABEL_3;
      case 4099:
      case 4104:
      case 4106:
      case 4107:
      case 4108:
      case 4109:
      case 4110:
      case 4111:
      case 4113:
      case 4114:
      case 4115:
      case 4116:
      case 4119:
      case 4120:
      case 4121:
      case 4122:
      case 4123:
      case 4124:
      case 4125:
      case 4126:
      case 4127:
      case 4130:
      case 4136:
      case 4137:
      case 4138:
      case 4139:
      case 4140:
      case 4141:
      case 4142:
      case 4143:
      case 4144:
        goto LABEL_19;
      case 4100:
      case 4101:
      case 4102:
        result = GetSourcedv(Source, Context, (SrcFloatProp_0)prop, &v17);
        if ( !result )
        {
          result = 0;
          *values = (int)v17;
          values[1] = (int)v18;
          values[2] = (int)v19;
        }
        return result;
      case 4103:
        Looping = Source->Looping;
        goto LABEL_46;
      case 4105:
        (*(void (**)(void))(*(volatile RefCount *)((char *)&Context->Device->ref + (unsigned int)&elf_hash_chain[6161])
                          + 44))();
        SourceType = Source->SourceType;
        queue = Source->queue;
        v14 = SourceType == 4136;
        if ( SourceType != 4136 )
        {
          SourceType = Source->BuffersPlayed;
          v14 = SourceType == 0;
        }
        if ( !v14 )
        {
          do
          {
            queue = queue->next;
            --SourceType;
          }
          while ( SourceType );
        }
        if ( !queue )
          goto LABEL_41;
        buffer = queue->buffer;
        if ( buffer )
          id = buffer->id;
        else
          id = 0;
        goto LABEL_52;
      case 4112:
        Looping = Source->state;
        goto LABEL_46;
      case 4117:
        Looping = Source->BuffersInQueue;
        goto LABEL_46;
      case 4118:
        (*(void (**)(void))(*(volatile RefCount *)((char *)&Context->Device->ref + (unsigned int)&elf_hash_chain[6161])
                          + 44))();
        if ( Source->Looping )
        {
LABEL_41:
          id = 0;
        }
        else if ( Source->SourceType == 4137 )
        {
          id = Source->BuffersPlayed;
        }
        else
        {
          id = 0;
        }
LABEL_52:
        *values = id;
        (*(void (**)(void))(*(volatile RefCount *)((char *)&Context->Device->ref + (unsigned int)&elf_hash_chain[6161])
                          + 48))();
        return 0;
      case 4135:
        Looping = Source->SourceType;
        goto LABEL_46;
      case 4145:
      case 4146:
        result = GetSourcedv(Source, Context, (SrcFloatProp_0)prop, &v17);
        if ( !result )
        {
          result = 0;
          *values = (int)v17;
          values[1] = (int)v18;
        }
        return result;
      case 4147:
        Looping = Source->DirectChannels;
        goto LABEL_46;
      default:
        if ( prop != siSourceRelative )
          goto LABEL_19;
        Looping = Source->HeadRelative;
        goto LABEL_46;
    }
  }
  if ( prop <= 131081 )
  {
    if ( prop == siDopplerFactor )
    {
LABEL_3:
      result = GetSourcedv(Source, Context, (SrcFloatProp_0)prop, &v17);
      if ( !result )
      {
        result = 0;
        *values = (int)v17;
      }
      return result;
    }
    if ( prop != siDistanceModel )
      goto LABEL_19;
    Looping = Source->DistanceModel;
LABEL_46:
    *values = Looping;
    return 0;
  }
  switch ( prop )
  {
    case siDirectFilterGainHFAuto:
      Looping = Source->DryGainHFAuto;
      goto LABEL_46;
    case siAuxSendFilterGainAutio:
      Looping = Source->WetGainAuto;
      goto LABEL_46;
    case siAuxSendFilterGainHFAuto:
      Looping = Source->WetGainHFAuto;
      goto LABEL_46;
  }
LABEL_19:
  if ( LogLevel_0 )
    j_al_print("(EE)", "GetSourceiv", "Unexpected property: 0x%04x\n", prop);
  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&Context->ref) )
  {
LABEL_27:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&Context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_27;
    }
  }
  result = 40962;
  __dmb(0xBu);
  return result;
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (00259CCC) --------------------------------------------------------
void __fastcall alGetSource3i(ALuint source, ALenum param, ALint *value1, ALint *value2, _DWORD *a5)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v10; // r4
  const ALsource_0 *v11; // r0
  bool v12; // zf
  unsigned int *v14; // r0
  unsigned int *p_LastError; // r0
  unsigned int *v20; // r0
  ALint values[9]; // [sp+4h] [bp-24h] BYREF

  ContextRef = j_GetContextRef();
  v10 = ContextRef;
  if ( ContextRef )
  {
    v11 = (const ALsource_0 *)j_LookupUIntMapKey(&ContextRef->SourceMap, source);
    if ( v11 )
    {
      v12 = value1 == 0;
      if ( value1 )
        v12 = value2 == 0;
      if ( v12 || !a5 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v10->ref) )
        {
          p_LastError = (unsigned int *)&v10->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_32;
          }
          goto LABEL_33;
        }
      }
      else
      {
        if ( (unsigned int)(param - 4100) < 3 || param == 131078 )
        {
          if ( !GetSourceiv(v11, v10, (SrcIntProp_0)param, values) )
          {
            *value1 = values[0];
            *value2 = values[1];
            *a5 = values[2];
          }
          goto LABEL_34;
        }
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v10->ref) )
        {
          v20 = (unsigned int *)&v10->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, v20) )
          {
            if ( __ldrex(v20) )
              goto LABEL_32;
          }
          goto LABEL_33;
        }
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v10->ref) )
      {
        v14 = (unsigned int *)&v10->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v14) )
        {
          if ( __ldrex(v14) )
            goto LABEL_32;
        }
        goto LABEL_33;
      }
    }
LABEL_32:
    __clrex();
LABEL_33:
    __dmb(0xBu);
LABEL_34:
    ALCcontext_DecRef(v10);
  }
}

//----- (00259E08) --------------------------------------------------------
void __fastcall alGetSourceiv(ALuint source, ALenum param, ALint *values)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  const ALsource_0 *v8; // r0
  unsigned int *v10; // r0
  unsigned int *v13; // r0
  bool v15; // zf
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (const ALsource_0 *)j_LookupUIntMapKey(&ContextRef->SourceMap, source);
    if ( v8 )
    {
      if ( values )
      {
        if ( param < 49152 )
        {
          switch ( param )
          {
            case 4097:
            case 4098:
            case 4100:
            case 4101:
            case 4102:
            case 4103:
            case 4105:
            case 4112:
            case 4117:
            case 4118:
            case 4128:
            case 4129:
            case 4131:
            case 4132:
            case 4133:
            case 4134:
            case 4135:
            case 4145:
            case 4146:
            case 4147:
              goto LABEL_27;
            case 4099:
            case 4104:
            case 4106:
            case 4107:
            case 4108:
            case 4109:
            case 4110:
            case 4111:
            case 4113:
            case 4114:
            case 4115:
            case 4116:
            case 4119:
            case 4120:
            case 4121:
            case 4122:
            case 4123:
            case 4124:
            case 4125:
            case 4126:
            case 4127:
            case 4130:
            case 4136:
            case 4137:
            case 4138:
            case 4139:
            case 4140:
            case 4141:
            case 4142:
            case 4143:
            case 4144:
              goto LABEL_29;
            default:
              if ( param != 514 )
                goto LABEL_29;
              goto LABEL_27;
          }
        }
        if ( (unsigned int)(param - 131077) <= 7 && ((1 << (param - 5)) & 0xE3) != 0 )
          goto LABEL_27;
        v15 = param == 49152;
        if ( param != 49152 )
          v15 = param == 53248;
        if ( v15 )
        {
LABEL_27:
          GetSourceiv(v8, v7, (SrcIntProp_0)param, values);
LABEL_37:
          ALCcontext_DecRef(v7);
          return;
        }
LABEL_29:
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          p_LastError = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_35;
          }
          goto LABEL_36;
        }
      }
      else
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          v13 = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, v13) )
          {
            if ( __ldrex(v13) )
              goto LABEL_35;
          }
          goto LABEL_36;
        }
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        v10 = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v10) )
        {
          if ( __ldrex(v10) )
            goto LABEL_35;
        }
        goto LABEL_36;
      }
    }
LABEL_35:
    __clrex();
LABEL_36:
    __dmb(0xBu);
    goto LABEL_37;
  }
}

//----- (00259F84) --------------------------------------------------------
void __fastcall alGetSourcei64SOFT(ALuint source, ALenum param, ALint64SOFT *value)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  const ALsource_0 *v8; // r0
  unsigned int *v10; // r0
  unsigned int *v13; // r0
  bool v15; // zf
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (const ALsource_0 *)j_LookupUIntMapKey(&ContextRef->SourceMap, source);
    if ( v8 )
    {
      if ( value )
      {
        if ( param < 49152 )
        {
          switch ( param )
          {
            case 4097:
            case 4098:
            case 4103:
            case 4105:
            case 4112:
            case 4117:
            case 4118:
            case 4128:
            case 4129:
            case 4131:
            case 4132:
            case 4133:
            case 4134:
            case 4135:
            case 4147:
              goto LABEL_27;
            case 4099:
            case 4100:
            case 4101:
            case 4102:
            case 4104:
            case 4106:
            case 4107:
            case 4108:
            case 4109:
            case 4110:
            case 4111:
            case 4113:
            case 4114:
            case 4115:
            case 4116:
            case 4119:
            case 4120:
            case 4121:
            case 4122:
            case 4123:
            case 4124:
            case 4125:
            case 4126:
            case 4127:
            case 4130:
            case 4136:
            case 4137:
            case 4138:
            case 4139:
            case 4140:
            case 4141:
            case 4142:
            case 4143:
            case 4144:
            case 4145:
            case 4146:
              goto LABEL_29;
            default:
              if ( param != 514 )
                goto LABEL_29;
              goto LABEL_27;
          }
        }
        if ( (unsigned int)(param - 131077) <= 7 && ((1 << (param - 5)) & 0xE1) != 0 )
          goto LABEL_27;
        v15 = param == 49152;
        if ( param != 49152 )
          v15 = param == 53248;
        if ( v15 )
        {
LABEL_27:
          GetSourcei64v(v8, v7, (SrcIntProp_0)param, value);
LABEL_37:
          ALCcontext_DecRef(v7);
          return;
        }
LABEL_29:
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          p_LastError = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_35;
          }
          goto LABEL_36;
        }
      }
      else
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          v13 = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, v13) )
          {
            if ( __ldrex(v13) )
              goto LABEL_35;
          }
          goto LABEL_36;
        }
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        v10 = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v10) )
        {
          if ( __ldrex(v10) )
            goto LABEL_35;
        }
        goto LABEL_36;
      }
    }
LABEL_35:
    __clrex();
LABEL_36:
    __dmb(0xBu);
    goto LABEL_37;
  }
}

//----- (0025A100) --------------------------------------------------------
ALenum __fastcall GetSourcei64v(const ALsource_0 *Source, ALCcontext *Context, SrcIntProp_0 prop, ALint64 *values)
{
  ALenum result; // r0
  ALint64 v8; // r0
  unsigned __int32 v9; // r1
  ALuint position_fraction; // r3
  ALbufferlistitem_0 *queue; // r2
  ALuint v12; // r1
  int v13; // r0
  bool v14; // zf
  unsigned int v15; // r6
  int v16; // r2
  unsigned int *p_LastError; // r0
  uint32x2_t v20; // [sp+0h] [bp-40h] BYREF
  unsigned __int32 v21; // [sp+8h] [bp-38h]
  ALdouble v22; // [sp+10h] [bp-30h] BYREF
  double v23; // [sp+18h] [bp-28h]
  double v24; // [sp+20h] [bp-20h]

  if ( prop < siSampleOffsetLatencySOFT )
  {
    switch ( prop )
    {
      case 4097:
      case 4098:
      case 4128:
      case 4129:
      case 4131:
      case 4132:
      case 4133:
      case 4134:
        goto LABEL_3;
      case 4099:
      case 4104:
      case 4106:
      case 4107:
      case 4108:
      case 4109:
      case 4110:
      case 4111:
      case 4113:
      case 4114:
      case 4115:
      case 4116:
      case 4119:
      case 4120:
      case 4121:
      case 4122:
      case 4123:
      case 4124:
      case 4125:
      case 4126:
      case 4127:
      case 4130:
      case 4136:
      case 4137:
      case 4138:
      case 4139:
      case 4140:
      case 4141:
      case 4142:
      case 4143:
      case 4144:
        goto LABEL_41;
      case 4100:
      case 4101:
      case 4102:
        result = GetSourcedv(Source, Context, (SrcFloatProp_0)prop, &v22);
        if ( result )
          return result;
        *values = (__int64)v22;
        values[1] = (__int64)v23;
        values[2] = (__int64)v24;
        break;
      case 4103:
      case 4112:
      case 4117:
      case 4118:
      case 4135:
      case 4147:
        goto LABEL_36;
      case 4105:
        goto LABEL_19;
      case 4145:
      case 4146:
        result = GetSourcedv(Source, Context, (SrcFloatProp_0)prop, &v22);
        if ( result )
          return result;
        *values = (__int64)v22;
        values[1] = (__int64)v23;
        break;
      default:
        if ( prop == siSourceRelative )
          goto LABEL_36;
        goto LABEL_41;
    }
    return 0;
  }
  if ( prop <= 131076 )
  {
    if ( prop == siSampleOffsetLatencySOFT )
    {
      (*(void (**)(void))(*(volatile RefCount *)((char *)&Context->Device->ref + (unsigned int)&elf_hash_chain[6161])
                        + 44))();
      if ( Source->state == 4114 || Source->state == 4115 )
      {
        position_fraction = Source->position_fraction;
        queue = Source->queue;
        v12 = Source->position | (position_fraction >> 14);
        v13 = position_fraction << 18;
        v14 = queue == 0;
        if ( queue )
        {
          position_fraction = Source->BuffersPlayed;
          v14 = position_fraction == 0;
        }
        if ( !v14 )
        {
          v15 = 1;
          do
          {
            if ( queue->buffer )
              v12 += queue->buffer->SampleLen;
            if ( v15 >= position_fraction )
              break;
            queue = queue->next;
            ++v15;
          }
          while ( queue );
        }
        v16 = 0x7FFFFFFF;
        if ( __CFSUB__(v12, 0x7FFFFFFF, v13 == -1) )
          v13 = -1;
        else
          v16 = v12;
      }
      else
      {
        v13 = 0;
        v16 = 0;
      }
      *(_DWORD *)values = v13;
      *((_DWORD *)values + 1) = v16;
      values[1] = ((__int64 (*)(void))*(_DWORD *)(*(volatile RefCount *)((char *)&Context->Device->ref
                                                                       + (unsigned int)&elf_hash_chain[6161])
                                                + 52))();
      (*(void (**)(void))(*(volatile RefCount *)((char *)&Context->Device->ref + (unsigned int)&elf_hash_chain[6161])
                        + 48))();
      return 0;
    }
    if ( prop == siDopplerFactor )
    {
LABEL_3:
      result = GetSourcedv(Source, Context, (SrcFloatProp_0)prop, &v22);
      if ( result )
        return result;
      v8 = (__int64)v22;
LABEL_38:
      *values = v8;
      return 0;
    }
    if ( prop != siDistanceModel )
      goto LABEL_41;
LABEL_36:
    result = GetSourceiv(Source, Context, prop, (ALint *)&v20);
    if ( result )
      return result;
    v8 = v20.n64_i32[0];
    goto LABEL_38;
  }
  if ( (unsigned int)(prop - 131082) < 3 )
    goto LABEL_36;
  if ( prop == siDirectFilter )
  {
LABEL_19:
    result = GetSourceiv(Source, Context, prop, (ALint *)&v20);
    if ( result )
      return result;
    v9 = v20.n64_u32[0];
LABEL_21:
    result = 0;
    *(_DWORD *)values = v9;
    *((_DWORD *)values + 1) = 0;
    return result;
  }
  if ( prop == siAuxSendFilter )
  {
    result = GetSourceiv(Source, Context, (SrcIntProp_0)((char *)&elf_hash_chain[16295] + 2), (ALint *)&v20);
    if ( result )
      return result;
    *(uint64x2_t *)values = vmovl_u32(v20);
    values += 2;
    v9 = v21;
    goto LABEL_21;
  }
LABEL_41:
  if ( LogLevel_0 )
    j_al_print("(EE)", "GetSourcei64v", "Unexpected property: 0x%04x\n", prop);
  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&Context->ref) )
  {
LABEL_49:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&Context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_49;
    }
  }
  __dmb(0xBu);
  return 40962;
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (0025A3F0) --------------------------------------------------------
void __fastcall alGetSource3i64SOFT(ALuint source, ALenum param, ALint64SOFT *value1, ALint64SOFT *value2, _QWORD *a5)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v10; // r4
  const ALsource_0 *v11; // r0
  bool v12; // zf
  unsigned int *v14; // r0
  unsigned int *p_LastError; // r0
  unsigned int *v20; // r0
  ALint64 v22[6]; // [sp+0h] [bp-30h] BYREF

  ContextRef = j_GetContextRef();
  v10 = ContextRef;
  if ( ContextRef )
  {
    v11 = (const ALsource_0 *)j_LookupUIntMapKey(&ContextRef->SourceMap, source);
    if ( v11 )
    {
      v12 = value1 == 0;
      if ( value1 )
        v12 = value2 == 0;
      if ( v12 || !a5 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v10->ref) )
        {
          p_LastError = (unsigned int *)&v10->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_32;
          }
          goto LABEL_33;
        }
      }
      else
      {
        if ( (unsigned int)(param - 4100) < 3 || param == 131078 )
        {
          if ( !GetSourcei64v(v11, v10, (SrcIntProp_0)param, v22) )
          {
            *value1 = v22[0];
            *value2 = v22[1];
            *a5 = v22[2];
          }
          goto LABEL_34;
        }
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v10->ref) )
        {
          v20 = (unsigned int *)&v10->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, v20) )
          {
            if ( __ldrex(v20) )
              goto LABEL_32;
          }
          goto LABEL_33;
        }
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v10->ref) )
      {
        v14 = (unsigned int *)&v10->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v14) )
        {
          if ( __ldrex(v14) )
            goto LABEL_32;
        }
        goto LABEL_33;
      }
    }
LABEL_32:
    __clrex();
LABEL_33:
    __dmb(0xBu);
LABEL_34:
    ALCcontext_DecRef(v10);
  }
}

//----- (0025A530) --------------------------------------------------------
void __fastcall alGetSourcei64vSOFT(ALuint source, ALenum param, ALint64SOFT *values)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r4
  const ALsource_0 *v8; // r0
  unsigned int *p_LastError; // r0
  unsigned int *v13; // r0
  bool v15; // zf
  unsigned int *v17; // r0

  ContextRef = j_GetContextRef();
  v7 = ContextRef;
  if ( ContextRef )
  {
    v8 = (const ALsource_0 *)j_LookupUIntMapKey(&ContextRef->SourceMap, source);
    if ( !v8 )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        p_LastError = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_21;
        }
        goto LABEL_22;
      }
      goto LABEL_21;
    }
    if ( !values )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&v7->ref) )
      {
        v13 = (unsigned int *)&v7->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v13) )
        {
          if ( __ldrex(v13) )
            goto LABEL_21;
        }
        goto LABEL_22;
      }
      goto LABEL_21;
    }
    if ( param < 4608 )
    {
      switch ( param )
      {
        case 4097:
        case 4098:
        case 4100:
        case 4101:
        case 4102:
        case 4103:
        case 4105:
        case 4112:
        case 4117:
        case 4118:
        case 4128:
        case 4129:
        case 4131:
        case 4132:
        case 4133:
        case 4134:
        case 4135:
        case 4145:
        case 4146:
        case 4147:
          goto LABEL_6;
        case 4099:
        case 4104:
        case 4106:
        case 4107:
        case 4108:
        case 4109:
        case 4110:
        case 4111:
        case 4113:
        case 4114:
        case 4115:
        case 4116:
        case 4119:
        case 4120:
        case 4121:
        case 4122:
        case 4123:
        case 4124:
        case 4125:
        case 4126:
        case 4127:
        case 4130:
        case 4136:
        case 4137:
        case 4138:
        case 4139:
        case 4140:
        case 4141:
        case 4142:
        case 4143:
        case 4144:
          goto LABEL_34;
        default:
          if ( param != 514 )
            goto LABEL_34;
          goto LABEL_6;
      }
    }
    if ( param <= 131076 )
    {
      v15 = param == 4608;
      if ( param != 4608 )
        v15 = param == 49152;
      if ( !v15 && param != 53248 )
      {
LABEL_34:
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          v17 = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, v17) )
          {
            if ( __ldrex(v17) )
              goto LABEL_21;
          }
          goto LABEL_22;
        }
LABEL_21:
        __clrex();
LABEL_22:
        __dmb(0xBu);
        goto LABEL_23;
      }
    }
    else if ( (unsigned int)(param - 131077) > 7 || ((1 << (param - 5)) & 0xE3) == 0 )
    {
      goto LABEL_34;
    }
LABEL_6:
    GetSourcei64v(v8, v7, (SrcIntProp_0)param, values);
LABEL_23:
    ALCcontext_DecRef(v7);
  }
}

//----- (0025A6C0) --------------------------------------------------------
void __fastcall alSourcePlay(ALuint source)
{
  ALuint sources; // [sp+4h] [bp-Ch] BYREF

  sources = source;
  j_alSourcePlayv(1, &sources);
}

//----- (0025A6D4) --------------------------------------------------------
void __fastcall alSourcePlayv(ALsizei n, const ALuint *sources)
{
  ALCcontext *ContextRef; // r8
  int v5; // r4
  __int64 v6; // r0
  int v7; // r4
  ALsource **v8; // r0
  ALsizei ActiveSourceCount; // r1
  bool v10; // cc
  ALsource_0 *v11; // r0
  unsigned int *p_LastError; // r0
  unsigned int *v16; // r0
  unsigned int *v19; // r0

  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    if ( n < 0 )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        p_LastError = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_38;
        }
        goto LABEL_39;
      }
    }
    else if ( n )
    {
      v5 = 0;
      while ( j_LookupUIntMapKey(&ContextRef->SourceMap, sources[v5]) )
      {
        if ( ++v5 >= n )
          goto LABEL_7;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        v16 = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v16) )
        {
          if ( __ldrex(v16) )
            goto LABEL_38;
        }
        goto LABEL_39;
      }
    }
    else
    {
LABEL_7:
      (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref + (unsigned int)&elf_hash_chain[6161])
                        + 44))();
      v6 = *(_QWORD *)&ContextRef->ActiveSourceCount;
      if ( HIDWORD(v6) - (int)v6 >= n )
      {
LABEL_11:
        if ( n >= 1 )
        {
          do
          {
            v11 = (ALsource_0 *)j_LookupUIntMapKey(&ContextRef->SourceMap, *sources);
            if ( ContextRef->DeferUpdates )
              v11->new_state = 4114;
            else
              j_SetSourceState(v11, ContextRef, 4114);
            --n;
            ++sources;
          }
          while ( n );
        }
        (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref + (unsigned int)&elf_hash_chain[6161])
                          + 48))();
        goto LABEL_40;
      }
      while ( 1 )
      {
        v7 = 2 * HIDWORD(v6);
        if ( 2 * HIDWORD(v6) < 1 )
          break;
        v8 = (ALsource **)realloc(ContextRef->ActiveSources, 8 * HIDWORD(v6));
        if ( !v8 )
          break;
        ActiveSourceCount = ContextRef->ActiveSourceCount;
        ContextRef->MaxActiveSources = v7;
        ContextRef->ActiveSources = v8;
        v10 = v7 - ActiveSourceCount < n;
        HIDWORD(v6) = v7;
        if ( !v10 )
          goto LABEL_11;
      }
      (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref + (unsigned int)&elf_hash_chain[6161])
                        + 48))();
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        v19 = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA005u, v19) )
        {
          if ( __ldrex(v19) )
            goto LABEL_38;
        }
        goto LABEL_39;
      }
    }
LABEL_38:
    __clrex();
LABEL_39:
    __dmb(0xBu);
LABEL_40:
    ALCcontext_DecRef(ContextRef);
  }
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (0025A864) --------------------------------------------------------
ALvoid __fastcall SetSourceState(ALsource_0 *Source, ALCcontext *Context, ALenum state)
{
  ALbufferlistitem_0 *queue; // r0
  bool v6; // zf
  int v7; // r8
  volatile ALenum v8; // r0
  ALsizei ActiveSourceCount; // r0
  ALsizei i; // r1
  ALuint BuffersInQueue; // r0
  ALsource **ActiveSources; // r1

  switch ( state )
  {
    case 4113:
      if ( Source->state != 4113 )
      {
        Source->state = 4113;
        Source->position = 0;
        Source->position_fraction = 0;
        Source->BuffersPlayed = 0;
        Source->Hrtf.Moving = 0;
        Source->Hrtf.Counter = 0;
      }
      goto LABEL_29;
    case 4114:
      queue = Source->queue;
      if ( !queue )
        goto LABEL_13;
      break;
    case 4115:
      if ( Source->state == 4114 )
      {
        Source->Hrtf.Moving = 0;
        Source->state = 4115;
        Source->Hrtf.Counter = 0;
      }
      return;
    case 4116:
      goto LABEL_27;
    default:
      return;
  }
  do
  {
    v6 = queue->buffer == 0;
    if ( queue->buffer )
      v6 = queue->buffer->SampleLen == 0;
    if ( !v6 )
    {
      v7 = 1;
      goto LABEL_14;
    }
    queue = queue->next;
  }
  while ( queue );
LABEL_13:
  v7 = 0;
LABEL_14:
  if ( Source->state != 4114 )
    memset(Source->Hrtf.History, 0, 0x2D00u);
  v8 = Source->state;
  Source->state = 4114;
  if ( v8 != 4115 )
  {
    Source->position = 0;
    Source->position_fraction = 0;
    Source->BuffersPlayed = 0;
  }
  if ( Source->Offset >= 0.0 )
    j_ApplyOffset(Source);
  if ( v7 == 1 && Context->Device->Connected )
  {
    ActiveSourceCount = Context->ActiveSourceCount;
    if ( ActiveSourceCount < 1 )
    {
      i = 0;
    }
    else
    {
      for ( i = 0; i < ActiveSourceCount; ++i )
      {
        if ( Context->ActiveSources[i] == Source )
          break;
      }
    }
    if ( i == ActiveSourceCount )
    {
      ActiveSources = Context->ActiveSources;
      Context->ActiveSourceCount = ActiveSourceCount + 1;
      ActiveSources[ActiveSourceCount] = Source;
    }
  }
  else
  {
LABEL_27:
    if ( Source->state != 4113 )
    {
      Source->state = 4116;
      BuffersInQueue = Source->BuffersInQueue;
      Source->Hrtf.Moving = 0;
      Source->Hrtf.Counter = 0;
      Source->BuffersPlayed = BuffersInQueue;
    }
LABEL_29:
    LODWORD(Source->Offset) = 0;
    HIDWORD(Source->Offset) = -1074790400;
  }
}

//----- (0025A9AA) --------------------------------------------------------
void __fastcall alSourcePause(ALuint source)
{
  ALuint sources; // [sp+4h] [bp-Ch] BYREF

  sources = source;
  j_alSourcePausev(1, &sources);
}

//----- (0025A9C0) --------------------------------------------------------
void __fastcall alSourcePausev(ALsizei n, const ALuint *sources)
{
  ALCcontext *ContextRef; // r8
  int v5; // r4
  _BYTE *v6; // r0
  int v7; // r1
  int v8; // r2
  unsigned int *p_LastError; // r0
  unsigned int *v13; // r0

  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    if ( n < 0 )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        p_LastError = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_29;
        }
        goto LABEL_30;
      }
      goto LABEL_29;
    }
    if ( n )
    {
      v5 = 0;
      while ( j_LookupUIntMapKey(&ContextRef->SourceMap, sources[v5]) )
      {
        if ( ++v5 >= n )
          goto LABEL_7;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        v13 = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v13) )
        {
          if ( __ldrex(v13) )
            goto LABEL_29;
        }
        goto LABEL_30;
      }
LABEL_29:
      __clrex();
LABEL_30:
      __dmb(0xBu);
      goto LABEL_31;
    }
LABEL_7:
    (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref + (unsigned int)&elf_hash_chain[6161])
                      + 44))();
    if ( n < 1 )
    {
LABEL_14:
      (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref + (unsigned int)&elf_hash_chain[6161])
                        + 48))();
LABEL_31:
      ALCcontext_DecRef(ContextRef);
      return;
    }
    while ( 1 )
    {
      v6 = j_LookupUIntMapKey(&ContextRef->SourceMap, *sources);
      if ( ContextRef->DeferUpdates )
        break;
      if ( *((_DWORD *)v6 + 32) == 4114 )
      {
        v7 = 0;
        v8 = 228;
        v6[224] = 0;
        *((_DWORD *)v6 + 32) = 4115;
        goto LABEL_12;
      }
LABEL_13:
      --n;
      ++sources;
      if ( !n )
        goto LABEL_14;
    }
    v7 = 4115;
    v8 = 132;
LABEL_12:
    *(_DWORD *)&v6[v8] = v7;
    goto LABEL_13;
  }
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (0025AAF0) --------------------------------------------------------
void __fastcall alSourceStop(ALuint source)
{
  ALuint sources; // [sp+4h] [bp-Ch] BYREF

  sources = source;
  j_alSourceStopv(1, &sources);
}

//----- (0025AB04) --------------------------------------------------------
void __fastcall alSourceStopv(ALsizei n, const ALuint *sources)
{
  ALCcontext *ContextRef; // r9
  int v5; // r4
  _DWORD *v6; // r0
  int v7; // r1
  int v8; // r1
  unsigned int *p_LastError; // r0
  unsigned int *v13; // r0

  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    if ( n < 0 )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        p_LastError = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_26;
        }
        goto LABEL_27;
      }
    }
    else
    {
      if ( !n )
      {
LABEL_7:
        (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref + (unsigned int)&elf_hash_chain[6161])
                          + 44))();
        if ( n >= 1 )
        {
          do
          {
            v6 = j_LookupUIntMapKey(&ContextRef->SourceMap, *sources);
            v7 = v6[32];
            v6[33] = 0;
            if ( v7 != 4113 )
            {
              v6[32] = 4116;
              v8 = v6[37];
              *((_BYTE *)v6 + 224) = 0;
              v6[57] = 0;
              v6[38] = v8;
            }
            --n;
            ++sources;
            v6[28] = 0;
            v6[29] = -1074790400;
          }
          while ( n );
        }
        (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref + (unsigned int)&elf_hash_chain[6161])
                          + 48))();
        goto LABEL_28;
      }
      v5 = 0;
      while ( j_LookupUIntMapKey(&ContextRef->SourceMap, sources[v5]) )
      {
        if ( ++v5 >= n )
          goto LABEL_7;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        v13 = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v13) )
        {
          if ( __ldrex(v13) )
            goto LABEL_26;
        }
        goto LABEL_27;
      }
    }
LABEL_26:
    __clrex();
LABEL_27:
    __dmb(0xBu);
LABEL_28:
    ALCcontext_DecRef(ContextRef);
  }
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (0025AC4C) --------------------------------------------------------
void __fastcall alSourceRewind(ALuint source)
{
  ALuint sources; // [sp+4h] [bp-Ch] BYREF

  sources = source;
  j_alSourceRewindv(1, &sources);
}

//----- (0025AC60) --------------------------------------------------------
void __fastcall alSourceRewindv(ALsizei n, const ALuint *sources)
{
  ALCcontext *ContextRef; // r8
  int v5; // r4
  _DWORD *v6; // r0
  int v7; // r1
  unsigned int *p_LastError; // r0
  unsigned int *v12; // r0

  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    if ( n < 0 )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        p_LastError = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_26;
        }
        goto LABEL_27;
      }
    }
    else
    {
      if ( !n )
      {
LABEL_7:
        (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref + (unsigned int)&elf_hash_chain[6161])
                          + 44))();
        if ( n >= 1 )
        {
          do
          {
            v6 = j_LookupUIntMapKey(&ContextRef->SourceMap, *sources);
            v7 = v6[32];
            v6[33] = 0;
            if ( v7 != 4113 )
            {
              v6[32] = 4113;
              v6[34] = 0;
              v6[35] = 0;
              v6[38] = 0;
              *((_BYTE *)v6 + 224) = 0;
              v6[57] = 0;
            }
            --n;
            ++sources;
            v6[28] = 0;
            v6[29] = -1074790400;
          }
          while ( n );
        }
        (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref + (unsigned int)&elf_hash_chain[6161])
                          + 48))();
        goto LABEL_28;
      }
      v5 = 0;
      while ( j_LookupUIntMapKey(&ContextRef->SourceMap, sources[v5]) )
      {
        if ( ++v5 >= n )
          goto LABEL_7;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        v12 = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA001u, v12) )
        {
          if ( __ldrex(v12) )
            goto LABEL_26;
        }
        goto LABEL_27;
      }
    }
LABEL_26:
    __clrex();
LABEL_27:
    __dmb(0xBu);
LABEL_28:
    ALCcontext_DecRef(ContextRef);
  }
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (0025AD98) --------------------------------------------------------
void __fastcall alSourceQueueBuffers(ALuint source, ALsizei nb, const ALuint *buffers)
{
  ALsizei v3; // r10
  _DWORD *v4; // r4
  unsigned int *p_LastError; // r6
  UIntMap_0 *p_SourceMap; // r1
  int v7; // r2
  _DWORD *v8; // r0
  ALCdevice *Device; // r9
  _DWORD *v10; // r8
  _DWORD *v11; // r0
  _DWORD *v12; // r2
  _DWORD *v13; // r3
  int v14; // r1
  _DWORD *v15; // r8
  ALuint v16; // r1
  _DWORD *v17; // r9
  unsigned int v18; // r0
  int v20; // r0
  _DWORD *v21; // r0
  unsigned int *v22; // r0
  unsigned int v23; // r1
  unsigned int *v24; // r10
  unsigned int v25; // r0
  unsigned int *v26; // r6
  unsigned int v27; // r0
  unsigned int *v28; // r8
  unsigned int v29; // r0
  unsigned int *v30; // r4
  unsigned int v31; // r0
  int v32; // r0
  unsigned int v33; // r0
  unsigned int *v34; // r0
  unsigned int v35; // r0
  unsigned int v37; // r0
  int v38; // r0
  _DWORD *v39; // r1
  unsigned int v40; // r0
  int v41; // r0
  ALvoid (__fastcall *v42)(ALsource_0 *, const ALCcontext *); // r0
  unsigned int v43; // r0
  unsigned int *v44; // r0
  bool v45; // zf
  _DWORD *v46; // r2
  _DWORD *v47; // r1
  _DWORD *v48; // r5
  __int64 v55; // kr00_8
  _DWORD *v56; // r3
  unsigned int *v57; // r0
  unsigned int v58; // r1
  _DWORD *v60; // [sp+Ch] [bp-5Ch]
  ALvoid (__fastcall **v61)(ALsource_0 *, const ALCcontext *); // [sp+10h] [bp-58h]
  _DWORD *v62; // [sp+1Ch] [bp-4Ch]
  _DWORD *v63; // [sp+20h] [bp-48h]
  ALsizei v64; // [sp+24h] [bp-44h]
  unsigned int *v65; // [sp+28h] [bp-40h]
  int v66; // [sp+2Ch] [bp-3Ch]
  UIntMap_0 *map; // [sp+30h] [bp-38h]
  _DWORD *v68; // [sp+34h] [bp-34h]
  ALCcontext *ContextRef; // [sp+38h] [bp-30h]
  _DWORD *v70; // [sp+3Ch] [bp-2Ch]
  _DWORD *v71; // [sp+40h] [bp-28h]
  int v73; // [sp+48h] [bp-20h]

  v3 = nb;
  if ( !nb )
    return;
  ContextRef = j_GetContextRef();
  if ( !ContextRef )
    return;
  v4 = 0;
  p_LastError = (unsigned int *)&ContextRef->LastError;
  p_SourceMap = &ContextRef->SourceMap;
  v7 = 0;
  v8 = 0;
  v64 = v3;
  v65 = (unsigned int *)&ContextRef->LastError;
LABEL_4:
  if ( v7 )
    goto LABEL_132;
  if ( v3 > -1 )
  {
    v63 = v8;
    Device = ContextRef->Device;
    v10 = j_LookupUIntMapKey(p_SourceMap, source);
    if ( !v10 )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex(p_LastError) )
      {
        __dmb(0xBu);
        while ( __strex(0xA001u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_130;
        }
        goto LABEL_131;
      }
      goto LABEL_130;
    }
    (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref + (unsigned int)&elf_hash_chain[6161])
                      + 44))();
    if ( v10[31] == 4136 )
    {
      (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref + (unsigned int)&elf_hash_chain[6161])
                        + 48))();
      if ( TrapALError )
        raise(5);
      if ( !__ldrex(p_LastError) )
      {
        __dmb(0xBu);
        while ( __strex(0xA004u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_130;
        }
        goto LABEL_131;
      }
LABEL_130:
      __clrex();
LABEL_131:
      __dmb(0xBu);
      v8 = v63;
LABEL_132:
      if ( !v4 )
        goto LABEL_107;
      do
      {
LABEL_133:
        v55 = *(_QWORD *)v4;
        v4 = (_DWORD *)v4[1];
        if ( (_DWORD)v55 )
        {
          v56 = v8;
          v57 = (unsigned int *)(v55 + 44);
          __dmb(0xBu);
          do
            v58 = __ldrex(v57);
          while ( __strex(v58 - 1, v57) );
          v8 = v56;
          __dmb(0xBu);
        }
        free(v8);
        v8 = v4;
      }
      while ( v4 );
      goto LABEL_107;
    }
    v11 = (_DWORD *)v10[36];
    v12 = v11;
    if ( v11 )
    {
      while ( 1 )
      {
        v13 = (_DWORD *)*v12;
        if ( *v12 )
          break;
        v12 = (_DWORD *)v12[1];
        if ( !v12 )
          goto LABEL_11;
      }
    }
    else
    {
LABEL_11:
      v12 = 0;
      v13 = 0;
    }
    v68 = v13;
    v62 = v10;
    if ( v3 < 1 )
    {
      v46 = v10;
LABEL_102:
      v46[31] = 4137;
      if ( v11 )
      {
        do
        {
          v47 = v11;
          v11 = (_DWORD *)v11[1];
        }
        while ( v11 );
        v4[2] = v47;
        v47[1] = v4;
        v46 = v62;
      }
      else
      {
        v46[36] = v4;
      }
      v46[37] += v3;
      (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref + (unsigned int)&elf_hash_chain[6161])
                        + 48))();
      goto LABEL_107;
    }
    v14 = 0;
    v61 = (ALvoid (__fastcall **)(ALsource_0 *, const ALCcontext *))(v10 + 5729);
    map = &Device->BufferMap;
    v60 = v10 + 5728;
    v66 = 0;
    while ( 1 )
    {
      v15 = v12;
      v73 = v14;
      v16 = buffers[v14];
      if ( v16 )
      {
        v17 = j_LookupUIntMapKey(map, v16);
        if ( !v17 )
        {
          (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref
                                                   + (unsigned int)&elf_hash_chain[6161])
                            + 48))();
          if ( TrapALError )
            raise(5);
          v18 = __ldrex(p_LastError);
          v12 = v15;
          if ( v18 )
          {
LABEL_22:
            __clrex();
          }
          else
          {
            __dmb(0xBu);
            while ( __strex(0xA001u, p_LastError) )
            {
              if ( __ldrex(p_LastError) )
                goto LABEL_22;
            }
          }
          v20 = 40961;
          __dmb(0xBu);
LABEL_75:
          v66 = v20;
          v32 = 4;
          goto LABEL_92;
        }
      }
      else
      {
        v17 = 0;
      }
      v21 = malloc(0xCu);
      if ( v4 )
      {
        v15[1] = v21;
        *v21 = v17;
        *(_DWORD *)(v15[1] + 4) = 0;
        *(_DWORD *)(v15[1] + 8) = v15;
        v12 = (_DWORD *)v15[1];
        if ( !v17 )
          goto LABEL_60;
      }
      else
      {
        *v21 = v17;
        v21[1] = 0;
        v4 = v21;
        v21[2] = 0;
        v12 = v21;
        v63 = v21;
        if ( !v17 )
        {
LABEL_60:
          v32 = 23;
          goto LABEL_92;
        }
      }
      v22 = v17 + 11;
      v70 = v12;
      __dmb(0xBu);
      do
        v23 = __ldrex(v22);
      while ( __strex(v23 + 1, v22) );
      v24 = v17 + 15;
      __dmb(0xBu);
      __dmb(0xBu);
      do
        v25 = __ldrex(v24);
      while ( __strex(1u, v24) );
      while ( 1 )
      {
        __dmb(0xBu);
        if ( v25 != 1 )
          break;
        sched_yield();
        __dmb(0xBu);
        do
          v25 = __ldrex(v24);
        while ( __strex(1u, v24) );
      }
      v26 = v17 + 14;
      __dmb(0xBu);
      do
        v27 = __ldrex(v26);
      while ( __strex(1u, v26) );
      while ( 1 )
      {
        __dmb(0xBu);
        if ( v27 != 1 )
          break;
        sched_yield();
        __dmb(0xBu);
        do
          v27 = __ldrex(v26);
        while ( __strex(1u, v26) );
      }
      v28 = v17 + 12;
      v71 = v4;
      __dmb(0xBu);
      do
        v29 = __ldrex(v28);
      while ( __strex(v29 + 1, v28) );
      __dmb(0xBu);
      if ( !v29 )
      {
        v30 = v17 + 16;
        __dmb(0xBu);
        do
          v31 = __ldrex(v30);
        while ( __strex(1u, v30) );
        while ( 1 )
        {
          __dmb(0xBu);
          if ( v31 != 1 )
            break;
          sched_yield();
          __dmb(0xBu);
          do
            v31 = __ldrex(v30);
          while ( __strex(1u, v30) );
        }
      }
      __dmb(0xBu);
      do
        __ldrex(v26);
      while ( __strex(0, v26) );
      __dmb(0xBu);
      __dmb(0xBu);
      do
        __ldrex(v24);
      while ( __strex(0, v24) );
      __dmb(0xBu);
      if ( v68 )
      {
        if ( v68[1] != v17[1] || v68[6] != v17[6] || v68[7] != v17[7] )
        {
          __dmb(0xBu);
          do
            v33 = __ldrex(v28);
          while ( __strex(v33 - 1, v28) );
          __dmb(0xBu);
          v4 = v71;
          v3 = v64;
          p_LastError = (unsigned int *)&ContextRef->LastError;
          if ( v33 == 1 )
          {
            v34 = v17 + 16;
            __dmb(0xBu);
            do
              __ldrex(v34);
            while ( __strex(0, v34) );
            __dmb(0xBu);
          }
          (*(void (**)(void))(*(volatile RefCount *)((char *)&ContextRef->Device->ref
                                                   + (unsigned int)&elf_hash_chain[6161])
                            + 48))();
          if ( TrapALError )
            raise(5);
          v35 = __ldrex(v65);
          v12 = v70;
          if ( v35 )
          {
LABEL_73:
            __clrex();
          }
          else
          {
            __dmb(0xBu);
            while ( __strex(0xA004u, v65) )
            {
              if ( __ldrex(v65) )
                goto LABEL_73;
            }
          }
          __dmb(0xBu);
          v20 = 40964;
          goto LABEL_75;
        }
        v3 = v64;
        p_LastError = (unsigned int *)&ContextRef->LastError;
      }
      else
      {
        v37 = v17[4] - 5376;
        if ( v37 > 6 )
          v38 = 0;
        else
          v38 = dword_60A3C0[v37];
        v3 = v64;
        p_LastError = (unsigned int *)&ContextRef->LastError;
        v39 = v62;
        v62[39] = v38;
        v40 = v17[5] - 5120;
        if ( v40 > 6 )
        {
          v41 = 0;
        }
        else
        {
          v41 = dword_60A2C0[v40];
          v39 = v62;
        }
        v39[40] = v41;
        v42 = CalcNonAttnSourceParams;
        if ( v17[4] == 5376 )
          v42 = CalcSourceParams;
        *v61 = v42;
        *v60 = 1;
        v68 = v17;
      }
      __dmb(0xBu);
      do
        v43 = __ldrex(v28);
      while ( __strex(v43 - 1, v28) );
      __dmb(0xBu);
      if ( v43 == 1 )
      {
        v44 = v17 + 16;
        __dmb(0xBu);
        do
          __ldrex(v44);
        while ( __strex(0, v44) );
        __dmb(0xBu);
      }
      v32 = 0;
      v12 = v70;
      v4 = v71;
LABEL_92:
      v45 = (v32 & 0x1F) == 23;
      if ( (v32 & 0x1F) != 23 )
        v45 = v32 == 0;
      if ( !v45 )
      {
        v45 = v32 == 0;
        v8 = v63;
        p_SourceMap = &ContextRef->SourceMap;
        v7 = v66;
        if ( v45 )
          goto LABEL_107;
        goto LABEL_4;
      }
      v14 = v73 + 1;
      if ( v73 + 1 >= v3 )
      {
        v46 = v62;
        v11 = (_DWORD *)v62[36];
        goto LABEL_102;
      }
    }
  }
  v48 = v8;
  if ( TrapALError )
    raise(5);
  if ( __ldrex(p_LastError) )
  {
LABEL_114:
    __clrex();
  }
  else
  {
    __dmb(0xBu);
    while ( __strex(0xA003u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_114;
    }
  }
  v8 = v48;
  __dmb(0xBu);
  if ( v4 )
    goto LABEL_133;
LABEL_107:
  ALCcontext_DecRef(ContextRef);
}
// 25B178: masking with 0x1F was optimized away because r0.4 <= 0x17
// 10168: using guessed type int elf_hash_chain[22025];
// 60A2C0: using guessed type _DWORD dword_60A2C0[8];
// 60A3C0: using guessed type _DWORD dword_60A3C0[8];

//----- (0025B310) --------------------------------------------------------
ALvoid __fastcall CalcSourceParams(ALsource_0 *ALSource, const ALCcontext *ALContext)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d3
  float32x2_t v4; // d4
  float32x2_t v5; // d5
  unsigned __int64 v6; // d11
  int32x2_t v7; // d13
  int32x2_t v8; // d14
  ALCdevice *Device; // r6
  __int64 v11; // d16
  __int64 v12; // d17
  ALlistener *Listener; // r1
  int NumAuxSends; // r2
  float Gain; // s24
  float v16; // s18
  float v17; // s31
  float32x2_t v18; // d8
  float v19; // s25
  float v20; // s4
  float v21; // s6
  float v22; // s8
  float32x2_t v23; // d18
  float32x2_t v24; // d1
  volatile ALfloat OuterAngle; // s0
  float32x2_t v26; // d7
  float RoomRolloffFactor; // s10
  SendParams_0 *Send; // r0
  ALeffectslot **p_DefaultSlot; // lr
  unsigned int v30; // r6
  float *v31; // r12
  int v32; // r4
  int type; // r1
  int AirAbsorptionGainHF_low; // s5
  ALeffectslot *Slot; // r8
  bool v36; // zf
  float *v37; // r1
  ALlistener *v38; // r9
  float v39; // s10
  float v40; // s25
  float v41; // s5
  float v42; // s21
  float v43; // s12
  float v44; // s31
  float v45; // s7
  float v46; // s13
  float v47; // s20
  float v48; // s31
  float v49; // s11
  float v50; // s10
  float v51; // s4
  float v52; // s12
  float v53; // s5
  int v54; // r10
  float v55; // s20
  float v56; // s19
  float v57; // s0
  float v58; // s4
  float v59; // s2
  float32x2_t v60; // d6
  float v61; // s6
  float v62; // s2
  int v63; // r0
  __int64 v64; // d16
  __int64 v65; // d17
  _QWORD *v66; // r1
  unsigned int v67; // r2
  int v68; // r1
  _DWORD *v69; // r0
  volatile DistanceModel *p_DistanceModel; // r1
  volatile DistanceModel v71; // r1
  float v72; // s4
  unsigned __int32 v73; // s22
  float32x2_t v74; // d16
  unsigned __int64 v75; // d16
  char *v76; // r0
  _DWORD *v77; // r1
  int v78; // r2
  float32x2_t v79; // d16
  float v80; // s0
  float *v81; // r0
  float *v82; // r1
  int v83; // r2
  float v84; // s0
  float32x2_t v85; // d16
  char *v86; // r4
  float *v87; // r5
  int v88; // r6
  int v89; // t1
  float v90; // s30
  float *v91; // r0
  float *v92; // r1
  int v93; // r2
  float v94; // s0
  float v95; // s18
  int v96; // r6
  float *v97; // r4
  float *v98; // r5
  float v99; // t1
  float *v100; // r4
  float *v101; // r5
  int v102; // r6
  float v103; // s0
  ALsource_0 *v104; // r6
  const ALCdevice *v105; // r8
  float v106; // s0
  float v107; // s2
  float OuterGainHF; // s0
  float OuterGain; // s2
  float *v110; // r0
  int v111; // r1
  float v112; // s16
  float *v113; // r0
  int v114; // r1
  float32x2_t v115; // d16
  float v116; // s30
  int v117; // r0
  float32x4_t v118; // q9
  float32x4_t *v119; // r1
  unsigned int v120; // r2
  float32x4_t v121; // q10
  int v122; // r1
  unsigned __int32 *v123; // r0
  float32x2_t v124; // d0
  float DirectGainHF; // s18
  float v126; // s4
  float DirectGain; // s2
  float *p_Gain; // r0
  float *v129; // r1
  float *v130; // r2
  int v131; // r3
  float v132; // s6
  float v133; // s8
  float v134; // s8
  float32x2_t v135; // d2
  float v136; // s2
  ALbufferlistitem_0 *queue; // r0
  int v138; // s4
  int v139; // r0
  float v140; // s4
  int v141; // r0
  ALint *p_Step; // r1
  int v143; // s4
  void (*v144)(const ALfloat *, ALuint, ALuint, ALfloat *, ALuint); // r0
  float v145; // s20
  _DWORD *p_DryMix; // r0
  float32x2_t v147; // d1
  float32x2_t v148; // d2
  float v149; // s22
  float v150; // s24
  float32x2_t v151; // d1
  float v152; // r0
  float v153; // s22
  float v154; // r0
  HrtfState_0 *p_Hrtf; // r11
  unsigned __int32 *v156; // r9
  float v157; // s0
  float32x2_t v158; // d1
  float v159; // s2
  float v160; // s4
  __int64 v161; // r0
  float *v162; // r0
  float32x2_t v163; // d0
  float v164; // s0
  const Hrtf *Hrtf; // r0
  ALuint irSize; // r0
  signed int v167; // r1
  Channel v168; // r3
  unsigned __int32 *v169; // r3
  int *v170; // r1
  _DWORD *v171; // r0
  int v172; // r2
  int v173; // t1
  float v174; // r0
  float v175; // s2
  float v176; // s8
  float v177; // s4
  float *p_coeff; // r0
  unsigned __int32 *v179; // r1
  float v180; // s1
  ALint counter; // [sp+4h] [bp-164h]
  ALint *delayStep; // [sp+14h] [bp-154h]
  unsigned __int32 v183; // [sp+2Ch] [bp-13Ch]
  Resampler Resampler; // [sp+30h] [bp-138h]
  float MetersPerUnit; // [sp+34h] [bp-134h]
  float v186; // [sp+38h] [bp-130h]
  float v187; // [sp+3Ch] [bp-12Ch]
  float v188; // [sp+40h] [bp-128h]
  float DopplerVelocity; // [sp+44h] [bp-124h]
  float SpeedOfSound; // [sp+48h] [bp-120h]
  float v191; // [sp+4Ch] [bp-11Ch]
  float InnerAngle; // [sp+50h] [bp-118h]
  float v193; // [sp+54h] [bp-114h]
  float v194; // [sp+54h] [bp-114h]
  int WetGainHFAuto; // [sp+58h] [bp-110h]
  int DryGainHFAuto; // [sp+5Ch] [bp-10Ch]
  const ALCcontext *v197; // [sp+60h] [bp-108h]
  unsigned __int64 v198; // [sp+60h] [bp-108h]
  float v199; // [sp+68h] [bp-100h]
  float DopplerFactor; // [sp+6Ch] [bp-FCh]
  int v201; // [sp+70h] [bp-F8h]
  unsigned __int32 v202; // [sp+74h] [bp-F4h]
  float32x2_t v203; // [sp+78h] [bp-F0h]
  float Pitch; // [sp+80h] [bp-E8h]
  unsigned int Frequency; // [sp+84h] [bp-E4h]
  int v206; // [sp+88h] [bp-E0h]
  unsigned __int64 v207; // [sp+88h] [bp-E0h]
  ALCdevice *v208; // [sp+90h] [bp-D8h]
  int WetGainAuto; // [sp+94h] [bp-D4h]
  float v210; // [sp+98h] [bp-D0h]
  _QWORD v212[3]; // [sp+A0h] [bp-C8h] BYREF
  _DWORD v213[4]; // [sp+B8h] [bp-B0h] BYREF
  char v214[16]; // [sp+C8h] [bp-A0h] BYREF
  char v215[16]; // [sp+D8h] [bp-90h] BYREF
  _DWORD v216[4]; // [sp+E8h] [bp-80h] BYREF
  float x[4]; // [sp+F8h] [bp-70h] BYREF
  float v218[4]; // [sp+FCh] [bp-6Ch] BYREF

  Device = ALContext->Device;
  *(float *)&v11 = 1.0;
  *((float *)&v11 + 1) = 1.0;
  *(float *)&v12 = 1.0;
  *((float *)&v12 + 1) = 1.0;
  v201 = *((unsigned __int8 *)&elf_hash_chain[6163] + (_DWORD)Device);
  v212[0] = v11;
  v212[1] = v12;
  DopplerFactor = ALContext->DopplerFactor;
  v199 = ALSource->DopplerFactor;
  SpeedOfSound = ALContext->SpeedOfSound;
  Listener = ALContext->Listener;
  v197 = ALContext;
  DopplerVelocity = ALContext->DopplerVelocity;
  Frequency = Device->Frequency;
  NumAuxSends = Device->NumAuxSends;
  Gain = Listener->Gain;
  MetersPerUnit = Listener->MetersPerUnit;
  v16 = ALSource->Gain;
  v8.n64_u32[0] = LODWORD(ALSource->MinGain);
  v7.n64_u32[0] = LODWORD(ALSource->MaxGain);
  Pitch = ALSource->Pitch;
  v210 = ALSource->Position[0];
  Resampler = ALSource->Resampler;
  *(ALfloat *)&v6 = ALSource->Position[1];
  v17 = ALSource->Position[2];
  v18.n64_u32[1] = LODWORD(ALSource->Orientation[0]);
  v18.n64_u32[0] = LODWORD(ALSource->Orientation[1]);
  ALSource->Params.Direct.OutBuffer = Device->DryBuffer;
  v19 = ALSource->Orientation[2];
  v20 = ALSource->Velocity[0];
  v21 = ALSource->Velocity[1];
  v22 = ALSource->Velocity[2];
  v2.n64_u32[0] = LODWORD(ALSource->RefDistance);
  v203.n64_u64[0] = v2.n64_u64[0];
  v2.n64_u32[0] = LODWORD(ALSource->MaxDistance);
  ALSource->Params.Direct.PendingClicks = Device->PendingClicks;
  v23.n64_u64[0] = v2.n64_u64[0];
  v24.n64_u32[1] = LODWORD(ALSource->RollOffFactor);
  InnerAngle = ALSource->InnerAngle;
  OuterAngle = ALSource->OuterAngle;
  v208 = Device;
  v26.n64_u32[1] = LODWORD(ALSource->AirAbsorptionFactor);
  DryGainHFAuto = ALSource->DryGainHFAuto;
  ALSource->Params.Direct.ClickRemoval = Device->ClickRemoval;
  WetGainAuto = ALSource->WetGainAuto;
  WetGainHFAuto = ALSource->WetGainHFAuto;
  RoomRolloffFactor = ALSource->RoomRolloffFactor;
  v206 = NumAuxSends;
  if ( NumAuxSends >= 1 )
  {
    Send = ALSource->Params.Send;
    p_DefaultSlot = &Device->DefaultSlot;
    v30 = 0;
    v2.n64_u32[1] = 1135322726;
    do
    {
      type = 3 * v30;
      Slot = ALSource->Send[v30 / 4].Slot;
      if ( !v30 && !Slot )
        Slot = *p_DefaultSlot;
      v36 = Slot == 0;
      if ( Slot )
      {
        type = Slot->effect.type;
        v36 = Slot->effect.type == 0;
      }
      if ( v36 )
      {
        Slot = 0;
        AirAbsorptionGainHF_low = 1.0;
        *(_DWORD *)&v215[v30] = 0;
        *(_DWORD *)&v214[v30] = 0;
      }
      else
      {
        v31 = (float *)&v215[v30];
        if ( Slot->AuxSendAuto )
        {
          v32 = 0;
          *v31 = RoomRolloffFactor;
          if ( type != 0x8000 )
            v32 = 1;
          if ( type != 1 )
            type = 0;
          if ( type != v32 )
          {
            AirAbsorptionGainHF_low = 1.0;
            *(_DWORD *)&v214[v30] = 0;
          }
          else
          {
            AirAbsorptionGainHF_low = LODWORD(Slot->effect.Reverb.AirAbsorptionGainHF);
            *v31 = RoomRolloffFactor + Slot->effect.Reverb.RoomRolloffFactor;
            v3.n64_f32[1] = Slot->effect.Reverb.DecayTime * 343.3;
            *(_DWORD *)&v214[v30] = v3.n64_u32[1];
          }
        }
        else
        {
          AirAbsorptionGainHF_low = 1065256915;
          *v31 = v24.n64_f32[1];
          *(_DWORD *)&v214[v30] = 0;
        }
      }
      v37 = &x[v30 / 4];
      --NumAuxSends;
      v30 += 4;
      *(_DWORD *)v37 = AirAbsorptionGainHF_low;
      Send->Slot = Slot;
      ++Send;
    }
    while ( NumAuxSends );
  }
  v191 = OuterAngle;
  v38 = v197->Listener;
  if ( ALSource->HeadRelative )
  {
    v188 = v22 + v38->Params.Velocity[2];
    v187 = v21 + v38->Params.Velocity[1];
    v186 = v20 + v38->Params.Velocity[0];
  }
  else
  {
    v26.n64_u32[0] = LODWORD(v38->Params.Matrix[1][2]);
    v2.n64_f32[0] = v19;
    v39 = v38->Params.Matrix[1][0];
    v40 = v17;
    v41 = v38->Params.Matrix[0][1];
    v42 = v18.n64_f32[0] * v26.n64_f32[0];
    v43 = v38->Params.Matrix[1][1];
    v44 = v18.n64_f32[1] * v41;
    v2.n64_u32[1] = LODWORD(v38->Params.Matrix[0][0]);
    v45 = v38->Params.Matrix[0][2];
    v24.n64_f32[0] = v18.n64_f32[1] * v2.n64_f32[1];
    v46 = v38->Params.Matrix[2][0];
    v183 = v26.n64_u32[1];
    v26.n64_u32[1] = LODWORD(v38->Params.Matrix[2][1]);
    v18.n64_f32[1] = v18.n64_f32[1] * v45;
    v47 = v38->Params.Matrix[2][2];
    v202 = v24.n64_u32[1];
    v24.n64_f32[0] = v24.n64_f32[0] + (float)(v18.n64_f32[0] * v39);
    v193 = v44 + (float)(v18.n64_f32[0] * v43);
    v18.n64_f32[0] = *(float *)&v6 * v39;
    v48 = v38->Params.Matrix[3][2];
    HIDWORD(v6) = LODWORD(v38->Params.Matrix[3][1]);
    v49 = v22 * v26.n64_f32[1];
    v4.n64_f32[1] = (float)((float)(v20 * v45) + (float)(v21 * v26.n64_f32[0])) + (float)(v22 * v47);
    v50 = (float)(v20 * v2.n64_f32[1]) + (float)(v21 * v39);
    v18.n64_f32[0] = (float)(v210 * v2.n64_f32[1]) + v18.n64_f32[0];
    v2.n64_f32[1] = v48 * 0.0;
    v26.n64_f32[0] = (float)(v210 * v45) + (float)(*(float *)&v6 * v26.n64_f32[0]);
    v3.n64_u32[1] = LODWORD(v38->Params.Matrix[3][0]);
    v4.n64_f32[0] = v50 + (float)(v22 * v46);
    v51 = (float)((float)(v20 * v41) + (float)(v21 * v43)) + v49;
    v5.n64_f32[1] = v40 * v26.n64_f32[1];
    v24.n64_f32[1] = v193 + (float)(v2.n64_f32[0] * v26.n64_f32[1]);
    v26.n64_u32[1] = v183;
    v5.n64_f32[0] = v18.n64_f32[0] + (float)(v40 * v46);
    v52 = (float)((float)(v210 * v41) + (float)(*(float *)&v6 * v43)) + v5.n64_f32[1];
    v53 = (float)(v18.n64_f32[1] + v42) + (float)(v2.n64_f32[0] * v47);
    v26.n64_f32[0] = v26.n64_f32[0] + (float)(v40 * v47);
    v18.n64_f32[0] = v24.n64_f32[1] + (float)(*((float *)&v6 + 1) * 0.0);
    v24.n64_u32[1] = v202;
    v188 = v4.n64_f32[1] + (float)(v48 * 0.0);
    v18.n64_f32[1] = (float)(v24.n64_f32[0] + (float)(v2.n64_f32[0] * v46)) + (float)(v3.n64_f32[1] * 0.0);
    *(float *)&v6 = *((float *)&v6 + 1) + v52;
    v19 = v53 + (float)(v48 * 0.0);
    v17 = v48 + v26.n64_f32[0];
    v187 = v51 + (float)(*((float *)&v6 + 1) * 0.0);
    v186 = v4.n64_f32[0] + (float)(v3.n64_f32[1] * 0.0);
    v210 = v3.n64_f32[1] + v5.n64_f32[0];
  }
  v54 = v206;
  v55 = -v17;
  v56 = -*(float *)&v6;
  v57 = -v210;
  v58 = (float)(v17 * v17) + (float)((float)(*(float *)&v6 * *(float *)&v6) + (float)(v210 * v210));
  if ( v58 > 0.0 )
  {
    v59 = 1.0 / sqrtf(v58);
    v55 = v59 * v55;
    v56 = v59 * v56;
    v57 = v59 * v57;
  }
  v60.n64_u64[0] = v203.n64_u64[0];
  v61 = (float)(v19 * v19)
      + (float)((float)(v18.n64_f32[0] * v18.n64_f32[0]) + (float)(v18.n64_f32[1] * v18.n64_f32[1]));
  if ( v61 > 0.0 )
  {
    v62 = 1.0 / sqrtf(v61);
    v19 = v19 * v62;
    v18.n64_f32[0] = v18.n64_f32[0] * v62;
    v18.n64_f32[1] = v18.n64_f32[1] * v62;
  }
  if ( v206 < 1 )
    goto LABEL_38;
  if ( (unsigned int)v206 < 4 || (v63 = v206 & 0x7FFFFFFC, (v206 & 0xFFFFFFFC) == 0) )
  {
    v63 = 0;
LABEL_36:
    v68 = v206 - v63;
    v69 = &v216[v63];
    do
    {
      *v69++ = 1065353216;
      --v68;
    }
    while ( v68 );
    goto LABEL_38;
  }
  *(float *)&v64 = 1.0;
  *((float *)&v64 + 1) = 1.0;
  *(float *)&v65 = 1.0;
  *((float *)&v65 + 1) = 1.0;
  v66 = v216;
  v67 = v206 & 0xFFFFFFFC;
  do
  {
    *v66 = v64;
    v66[1] = v65;
    v66 += 2;
    v67 -= 4;
  }
  while ( v67 );
  if ( v206 != v63 )
    goto LABEL_36;
LABEL_38:
  v194 = v57;
  v5.n64_u32[0] = 1.0;
  v2.n64_f32[0] = sqrtf(v58);
  p_DistanceModel = &ALSource->DistanceModel;
  if ( !v197->SourceDistanceModel )
    p_DistanceModel = &v197->DistanceModel;
  v71 = *p_DistanceModel;
  v198 = v2.n64_u64[0];
  v207 = v6;
  v72 = v2.n64_f32[0];
  v73 = v2.n64_u32[0];
  switch ( v71 )
  {
    case InverseDistance:
      v73 = v2.n64_u32[0];
      v72 = v2.n64_f32[0];
      if ( v203.n64_f32[0] > 0.0 )
        goto LABEL_54;
      goto LABEL_70;
    case InverseDistanceClamped:
      v79.n64_u64[0] = vmax_f32(v203, v2).n64_u64[0];
      v2.n64_u32[1] = v23.n64_u32[1];
      v73 = vmin_f32(v79, v23).n64_u32[0];
      if ( v203.n64_f32[0] <= 0.0 )
        goto LABEL_69;
      v72 = *(float *)&v73;
      if ( v23.n64_f32[0] < v203.n64_f32[0] )
        goto LABEL_70;
LABEL_54:
      v5.n64_u32[0] = 1.0;
      v80 = v203.n64_f32[0] + (float)(v24.n64_f32[1] * (float)(*(float *)&v73 - v203.n64_f32[0]));
      if ( v80 > 0.0 )
        v5.n64_f32[0] = v203.n64_f32[0] / v80;
      if ( v54 < 1 )
        goto LABEL_179;
      v81 = (float *)v215;
      v82 = (float *)v216;
      v83 = v54;
      do
      {
        v84 = v203.n64_f32[0] + (float)((float)(*(float *)&v73 - v203.n64_f32[0]) * *v81);
        if ( v84 > 0.0 )
          *v82 = v203.n64_f32[0] / v84;
        --v83;
        ++v82;
        ++v81;
      }
      while ( v83 );
      goto LABEL_69;
    case LinearDistance:
      goto LABEL_47;
    case LinearDistanceClamped:
      v74.n64_u64[0] = vmax_f32(v203, v2).n64_u64[0];
      v2.n64_u32[1] = v23.n64_u32[1];
      LODWORD(v72) = vmin_f32(v74, v23).n64_u32[0];
      if ( v23.n64_f32[0] < v203.n64_f32[0] )
        goto LABEL_70;
LABEL_47:
      v2.n64_u32[1] = v23.n64_u32[1];
      if ( v23.n64_f32[0] == v203.n64_f32[0] )
        goto LABEL_70;
      v4.n64_u32[0] = 0;
      v5.n64_f32[0] = 1.0
                    - (float)((float)(v24.n64_f32[1] * (float)(v72 - v203.n64_f32[0]))
                            / (float)(v23.n64_f32[0] - v203.n64_f32[0]));
      v5.n64_u64[0] = vmax_f32(v5, v4).n64_u64[0];
      if ( v54 < 1 )
      {
        *(float *)&v73 = v72;
        goto LABEL_179;
      }
      v75 = v5.n64_u64[0];
      v76 = v215;
      v77 = v216;
      v78 = v54;
      do
      {
        v5.n64_u32[0] = *(_DWORD *)v76;
        --v78;
        v76 += 4;
        v5.n64_f32[0] = 1.0
                      - (float)((float)((float)(v72 - v203.n64_f32[0]) * v5.n64_f32[0])
                              / (float)(v23.n64_f32[0] - v203.n64_f32[0]));
        v5.n64_u64[0] = vmax_f32(v5, v4).n64_u64[0];
        *v77++ = v5.n64_u32[0];
      }
      while ( v78 );
      v5.n64_u64[0] = v75;
      goto LABEL_70;
    case ExponentDistance:
      goto LABEL_63;
    case ExponentDistanceClamped:
      v85.n64_u64[0] = vmax_f32(v203, v2).n64_u64[0];
      v2.n64_u32[1] = v23.n64_u32[1];
      v73 = vmin_f32(v85, v23).n64_u32[0];
      if ( v23.n64_f32[0] < v203.n64_f32[0] )
        goto LABEL_69;
LABEL_63:
      if ( v203.n64_f32[0] <= 0.0 || *(float *)&v73 <= 0.0 )
      {
LABEL_69:
        v72 = *(float *)&v73;
LABEL_70:
        v90 = v16 * v5.n64_f32[0];
        if ( v54 >= 1 )
        {
          v91 = (float *)v216;
          v92 = (float *)v213;
          v93 = v54;
          do
          {
            v94 = *v91;
            --v93;
            ++v91;
            *v92++ = v16 * v94;
          }
          while ( v93 );
        }
        *(float *)&v73 = v72;
        goto LABEL_74;
      }
      v5.n64_u32[0] = powf(*(float *)&v73 / v203.n64_f32[0], COERCE_FLOAT(v24.n64_u32[1] ^ 0x80000000));
      if ( v54 >= 1 )
      {
        v86 = v215;
        v87 = (float *)v216;
        v88 = v54;
        do
        {
          v89 = *(_DWORD *)v86;
          v86 += 4;
          *v87++ = powf(*(float *)&v73 / v203.n64_f32[0], COERCE_FLOAT(v89 ^ 0x80000000));
          --v88;
        }
        while ( v88 );
        v72 = *(float *)&v73;
        v60.n64_u64[0] = v203.n64_u64[0];
        goto LABEL_70;
      }
      v60.n64_u64[0] = v203.n64_u64[0];
LABEL_179:
      v90 = v16 * v5.n64_f32[0];
LABEL_74:
      v95 = 1.0;
      if ( v26.n64_f32[1] > 0.0 )
      {
        v24.n64_f32[0] = *(float *)&v73 - v60.n64_f32[0];
        v2.n64_u32[0] = 0;
        v2.n64_u64[0] = vmax_f32(v24, v2).n64_u64[0];
        v2.n64_f32[0] = v26.n64_f32[1] * (float)(MetersPerUnit * v2.n64_f32[0]);
        v95 = powf(0.99426, v2.n64_f32[0]);
        if ( v54 >= 1 )
        {
          LODWORD(v212[0]) = powf(x[0], v2.n64_f32[0]);
          if ( v54 != 1 )
          {
            v96 = v54 - 1;
            v97 = v218;
            v98 = (float *)v212 + 1;
            do
            {
              v99 = *v97++;
              --v96;
              *v98 = powf(v99, v2.n64_f32[0]) * *v98;
              ++v98;
            }
            while ( v96 );
          }
        }
      }
      if ( WetGainAuto && v54 >= 1 )
      {
        v24.n64_u32[0] = 925353388;
        v100 = (float *)v214;
        v24.n64_u64[0] = vmax_f32(v5, v24).n64_u64[0];
        v101 = (float *)v213;
        v102 = v54;
        do
        {
          if ( *v100 > 0.0 )
            *v101 = powf(0.001, (float)((float)(1.0 / v24.n64_f32[0]) + -1.0) / *v100) * *v101;
          --v102;
          ++v101;
          ++v100;
        }
        while ( v102 );
      }
      v103 = (float)(acosf((float)(v55 * v19) + (float)((float)(v56 * v18.n64_f32[0]) + (float)(v194 * v18.n64_f32[1])))
                   * ConeScale)
           * 114.59;
      if ( v103 <= InnerAngle || v103 > v191 )
      {
        v104 = ALSource;
        v105 = v208;
        if ( v103 <= v191 )
        {
          OuterGainHF = 1.0;
          OuterGain = 1.0;
        }
        else
        {
          OuterGain = ALSource->OuterGain;
          OuterGainHF = ALSource->OuterGainHF;
        }
      }
      else
      {
        v104 = ALSource;
        v105 = v208;
        v106 = (float)(v103 - InnerAngle) / (float)(v191 - InnerAngle);
        v107 = v106 * (float)((float)ALSource->OuterGain + -1.0);
        OuterGainHF = (float)(v106 * (float)((float)ALSource->OuterGainHF + -1.0)) + 1.0;
        OuterGain = v107 + 1.0;
      }
      if ( WetGainAuto && v54 >= 1 )
      {
        v110 = (float *)v213;
        v111 = v54;
        do
        {
          --v111;
          *v110 = OuterGain * *v110;
          ++v110;
        }
        while ( v111 );
      }
      v24.n64_f32[0] = v90 * OuterGain;
      v112 = v95 * OuterGainHF;
      if ( !DryGainHFAuto )
        v112 = v95;
      if ( WetGainHFAuto && v54 >= 1 )
      {
        v113 = (float *)v212;
        v114 = v54;
        do
        {
          --v114;
          *v113 = OuterGainHF * *v113;
          ++v113;
        }
        while ( v114 );
      }
      v115.n64_u64[0] = vmax_f32(v8, v24).n64_u64[0];
      v116 = v17;
      if ( v54 < 1 )
        goto LABEL_113;
      if ( (unsigned int)v54 < 4 || (v117 = v54 & 0x7FFFFFFC, (v54 & 0xFFFFFFFC) == 0) )
      {
        v117 = 0;
LABEL_111:
        v122 = v54 - v117;
        v123 = &v213[v117];
        do
        {
          v2.n64_u32[0] = *v123;
          --v122;
          v2.n64_u64[0] = vmin_f32(vmax_f32(v8, v2), v7).n64_u64[0];
          *v123++ = v2.n64_u32[0];
        }
        while ( v122 );
        goto LABEL_113;
      }
      v118 = vdupq_lane_s32(v7, 0);
      v119 = (float32x4_t *)v213;
      v120 = v54 & 0xFFFFFFFC;
      v121 = vdupq_lane_s32(v8, 0);
      do
      {
        v120 -= 4;
        *v119 = vminq_f32(vmaxq_f32(v121, *v119), v118);
        ++v119;
      }
      while ( v120 );
      if ( v54 != v117 )
        goto LABEL_111;
LABEL_113:
      v124.n64_u64[0] = vmin_f32(v115, v7).n64_u64[0];
      DirectGainHF = v104->DirectGainHF;
      v126 = DopplerFactor * v199;
      DirectGain = v104->DirectGain;
      if ( v54 >= 1 )
      {
        p_Gain = &v104->Send[0].Gain;
        v129 = (float *)v213;
        v130 = (float *)v212;
        v131 = v54;
        do
        {
          --v131;
          v132 = Gain * *p_Gain;
          v133 = p_Gain[1];
          p_Gain += 3;
          *v129 = *v129 * v132;
          ++v129;
          *v130 = v133 * *v130;
          ++v130;
        }
        while ( v131 );
      }
      if ( v126 > 0.0 )
      {
        v134 = SpeedOfSound * DopplerVelocity;
        v3.n64_u32[0] = 1.0;
        if ( (float)(SpeedOfSound * DopplerVelocity) < 1.0 )
        {
          v126 = v126 * (float)(1.0 / v134);
          v134 = 1.0;
        }
        v135.n64_f32[1] = v187 * v56;
        v4.n64_f32[1] = v188 * v55;
        v60.n64_f32[0] = v134
                       - (float)((float)((float)(v188 * v55) + (float)((float)(v187 * v56) + (float)(v186 * v194)))
                               * v126);
        v135.n64_f32[0] = v134
                        - (float)(v126
                                * (float)((float)((float)(v194 * v38->Params.Velocity[0])
                                                + (float)(v56 * v38->Params.Velocity[1]))
                                        + (float)(v55 * v38->Params.Velocity[2])));
        v4.n64_f32[0] = (float)(v134 + v134) + -1.0;
        Pitch = Pitch
              * (float)(vmin_f32(vmax_f32(v135, v3), v4).n64_f32[0] / vmin_f32(vmax_f32(v60, v3), v4).n64_f32[0]);
      }
      v136 = Gain * DirectGain;
      queue = v104->queue;
      if ( queue )
      {
        while ( !queue->buffer )
        {
          queue = queue->next;
          if ( !queue )
            goto LABEL_138;
        }
        v138 = queue->buffer->Frequency;
        v139 = (int)&elf_hash_chain[16293] + 3;
        v140 = (float)(Pitch * (float)v138) / (float)Frequency;
        if ( 2047 - ResamplerPadding[Resampler] - ResamplerPrePadding[Resampler] < (int)&elf_hash_chain[16293] + 3 )
          v139 = 2047 - ResamplerPadding[Resampler] - ResamplerPrePadding[Resampler];
        if ( v140 <= (float)v139 )
        {
          v143 = (int)(float)(v140 * 16384.0);
          v104->Params.Step = v143;
          if ( v143 )
          {
            if ( v143 != 0x4000 )
            {
LABEL_133:
              v144 = Resample_point32_C;
              if ( Resampler == LinearResampler )
                v144 = Resample_lerp32_C;
              if ( Resampler == CubicResampler )
                v144 = Resample_cubic32_C;
              goto LABEL_137;
            }
LABEL_130:
            v144 = Resample_copy32_C;
LABEL_137:
            v104->Params.Resample = v144;
            goto LABEL_138;
          }
          p_Step = &v104->Params.Step;
          v141 = 1;
        }
        else
        {
          v141 = v139 << 14;
          p_Step = &v104->Params.Step;
        }
        *p_Step = v141;
        if ( v141 != 0x4000 )
          goto LABEL_133;
        goto LABEL_130;
      }
LABEL_138:
      v145 = v124.n64_f32[0] * v136;
      p_DryMix = &v104->Params.DryMix;
      if ( v201 )
      {
        *p_DryMix = MixDirect_Hrtf_C;
        v104->Params.WetMix = (WetMixerFunc)MixSend_C;
        v147.n64_u32[1] = HIDWORD(v198);
        if ( *(float *)&v198 <= 0.00000011921 )
        {
          v149 = 0.0;
          v150 = 0.0;
        }
        else
        {
          v124.n64_u32[0] = 1.0;
          v148.n64_u32[1] = HIDWORD(v207);
          v148.n64_f32[0] = *(float *)&v207 * (float)(1.0 / *(float *)&v198);
          v147.n64_u64[0] = __PAIR64__(HIDWORD(v198), -1.0);
          v207 = v148.n64_u64[0];
          v124.n64_u64[0] = vmin_f32(vmax_f32(v148, (float32x2_t)__PAIR64__(HIDWORD(v198), -1.0)), v124).n64_u64[0];
          v116 = v17 * (float)(1.0 / *(float *)&v198);
          v149 = asinf(v124.n64_f32[0]);
          v210 = v210 * (float)(1.0 / *(float *)&v198);
          v150 = atan2f(v210, -(float)(v116 * ZScale));
        }
        p_Hrtf = &v104->Hrtf;
        if ( v104->Hrtf.Moving )
        {
          v8.n64_u32[0] = 953267991;
          v156 = (unsigned __int32 *)&v104->Params.Direct.Hrtf;
          v157 = 0.0001;
          if ( v145 > 0.0001 )
            v157 = v145;
          v147.n64_u32[0] = *v156;
          v158.n64_u64[0] = vmax_f32(v147, v8).n64_u64[0];
          v7.n64_f32[0] = fabsf(log10f(v157 / v158.n64_f32[0]) * -0.25);
          v124.n64_u32[0] = 0;
          if ( v145 > 0.0001 )
          {
            v159 = v104->Params.Direct.Hrtf.Params.Dir[1];
            v160 = v104->Params.Direct.Hrtf.Params.Dir[0];
            v161 = 0LL;
            if ( (float)(*(float *)&v207 - v159) != 0.0 )
              HIDWORD(v161) = 1;
            if ( (float)(v210 - v160) != 0.0 )
              LODWORD(v161) = 1;
            v36 = v161 == 0;
            v162 = &v104->Params.Direct.Hrtf.Params.Dir[2];
            if ( !v36 || (float)(v116 - *v162) != 0.0 )
            {
              v124.n64_u32[1] = HIDWORD(v207);
              v124.n64_f32[0] = (float)(acosf(
                                          (float)((float)(v210 * v160) + (float)(*(float *)&v207 * v159))
                                        + (float)(v116 * *v162))
                                      / 3.1416)
                              * 25.0;
            }
          }
          v163.n64_u64[0] = vmax_f32(v124, v7).n64_u64[0];
          v158.n64_u32[0] = 1.0;
          v163.n64_f32[0] = v163.n64_f32[0] + v163.n64_f32[0];
          v164 = vmin_f32(v163, v158).n64_f32[0];
          if ( v164 <= 0.001 )
            goto LABEL_160;
          Hrtf = v105->Hrtf;
          counter = v104->Hrtf.Counter;
          delayStep = v104->Params.Direct.Hrtf.Params.DelayStep;
          v105 = v208;
          v104 = ALSource;
          ALSource->Hrtf.Counter = j_GetMovingHrtfCoeffs(
                                     Hrtf,
                                     v149,
                                     v150,
                                     v145,
                                     v164,
                                     counter,
                                     ALSource->Params.Direct.Hrtf.Params.Coeffs[0],
                                     ALSource->Params.Direct.Hrtf.Params.Delay[0],
                                     ALSource->Params.Direct.Hrtf.Params.CoeffStep,
                                     delayStep);
        }
        else
        {
          j_GetLerpedHrtfCoeffs(
            v105->Hrtf,
            v149,
            v150,
            v145,
            (ALuint *)v104->Params.Direct.Hrtf.Params.Coeffs,
            v104->Params.Direct.Hrtf.Params.Delay[0]);
          v104->Hrtf.Moving = 1;
          v104->Hrtf.Counter = 0;
          v156 = (unsigned __int32 *)&v104->Params.Direct.Hrtf;
        }
        *(float *)v156 = v145;
        v104->Params.Direct.Hrtf.Params.Dir[2] = v116;
        LODWORD(v104->Params.Direct.Hrtf.Params.Dir[1]) = v207;
        v104->Params.Direct.Hrtf.Params.Dir[0] = v210;
LABEL_160:
        irSize = v105->Hrtf->irSize;
        v104->Params.Direct.Hrtf.State = p_Hrtf;
        v104->Params.Direct.Hrtf.Params.IrSize = irSize;
        goto LABEL_165;
      }
      *p_DryMix = MixDirect_C;
      v104->Params.WetMix = (WetMixerFunc)MixSend_C;
      memset(v104->Params.Direct.Gains, 0, sizeof(v104->Params.Direct.Gains));
      v151.n64_u32[1] = HIDWORD(v198);
      if ( *(float *)&v198 <= 0.00000011921 )
      {
        v153 = 0.0;
      }
      else
      {
        v151.n64_u32[1] = HIDWORD(v198);
        v151.n64_f32[0] = v17 * (float)(1.0 / *(float *)&v198);
        v152 = v210 * (float)(1.0 / *(float *)&v198);
        v153 = sqrtf((float)(v152 * v152) + (float)(v151.n64_f32[0] * v151.n64_f32[0]));
        v154 = atan2f(v152, -(float)(v151.n64_f32[0] * ZScale));
        j_ComputeAngleGains(v105, v154, 0.0, v153 * v145, (int)v104->Params.Direct.Gains);
      }
      if ( (int)v105->NumChan >= 1 )
      {
        v167 = 0;
        v124.n64_f32[0] = (float)(1.0 - v153) * (float)(v145 * sqrtf(1.0 / (float)v105->NumChan));
        do
        {
          v168 = v105->Speaker2Chan[v167++];
          v169 = (unsigned __int32 *)((char *)v104->Params.Direct.Gains + 4 * v168);
          v151.n64_u32[0] = *v169;
          v151.n64_u64[0] = vmax_f32(v151, v124).n64_u64[0];
          *v169 = v151.n64_u32[0];
        }
        while ( v167 < (signed int)v105->NumChan );
      }
LABEL_165:
      v18.n64_f32[0] = v112 * DirectGainHF;
      if ( v54 >= 1 )
      {
        v170 = v213;
        v171 = (_DWORD *)&v104->Params.Send[0].Gain;
        v172 = v54;
        do
        {
          v173 = *v170++;
          --v172;
          *v171 = v173;
          v171 += 21;
        }
        while ( v172 );
      }
      v174 = cosf(31416.0 / (float)Frequency);
      v175 = v174;
      if ( v18.n64_f32[0] >= 0.9999 )
      {
        v177 = 0.0;
      }
      else
      {
        v4.n64_u32[0] = 981668463;
        v176 = vmax_f32(v18, v4).n64_f32[0];
        v177 = (float)((float)(1.0 - (float)(v176 * v174))
                     - sqrtf(
                         (float)((float)(v176 + v176) * (float)(1.0 - v174))
                       - (float)((float)(v176 * v176) * (float)(1.0 - (float)(v174 * v174)))))
             / (float)(1.0 - v176);
      }
      v104->Params.Direct.iirFilter.coeff = v177;
      if ( v54 >= 1 )
      {
        p_coeff = &v104->Params.Send[0].iirFilter.coeff;
        v179 = (unsigned __int32 *)v212;
        v60.n64_u32[0] = 981668463;
        do
        {
          v180 = 0.0;
          if ( *(float *)v179 < 0.9999 )
          {
            v26.n64_u32[0] = *v179;
            v26.n64_u64[0] = vmax_f32(v26, v60).n64_u64[0];
            v180 = (float)((float)(1.0 - (float)(v175 * v26.n64_f32[0]))
                         - sqrtf(
                             (float)((float)(1.0 - v175) * (float)(v26.n64_f32[0] + v26.n64_f32[0]))
                           - (float)((float)(1.0 - (float)(v175 * v175)) * (float)(v26.n64_f32[0] * v26.n64_f32[0]))))
                 / (float)(1.0 - v26.n64_f32[0]);
          }
          *p_coeff = v180;
          p_coeff += 21;
          --v54;
          ++v179;
        }
        while ( v54 );
      }
      return;
    default:
      if ( v71 )
        v72 = v2.n64_f32[0];
      else
        v72 = v203.n64_f32[0];
      goto LABEL_70;
  }
}
// 25B71E: mask 0xFFFFFFFC is shortened because %var_E0.4 <= 0x7FFFFFFF
// 25BBAA: mask 0xFFFFFFFC is shortened because r10.4 <= 0x7FFFFFFF
// 25B3DA: variable 'v2' is possibly undefined
// 25B780: variable 'v6' is possibly undefined
// 25B818: variable 'v5' is possibly undefined
// 25B818: variable 'v4' is possibly undefined
// 25BB96: variable 'v8' is possibly undefined
// 25BBB0: variable 'v7' is possibly undefined
// 25BCE6: variable 'v3' is possibly undefined
// 10168: using guessed type int elf_hash_chain[22025];
// 25B310: using guessed type float x[4];

//----- (0025C304) --------------------------------------------------------
ALvoid __fastcall CalcNonAttnSourceParams(ALsource_0 *ALSource, const ALCcontext *ALContext)
{
  float32x2_t v2; // d1
  float32x2_t v3; // d2
  float32x2_t v4; // d3
  float32x2_t v5; // d4
  float32x2_t v6; // d6
  float32x2_t v7; // d7
  float32x2_t v8; // d8
  ALCdevice *Device; // r11
  int v11; // r8
  int NumAuxSends; // r9
  float Gain; // s0
  ALbufferlistitem_0 *queue; // r2
  Resampler Resampler; // r0
  int DirectChannels; // r10
  ALbuffer *buffer; // r1
  int FmtChannels; // r5
  int v19; // r2
  float v20; // s8
  int v21; // r2
  ALint *p_Step; // r3
  ALint v23; // s8
  void (*v24)(const ALfloat *, ALuint, ALuint, ALfloat *, ALuint); // r2
  float DirectGain; // s8
  float v26; // s18
  ALvoid (*v27)(const DirectParams *, const ALfloat *, ALuint, ALuint, ALuint, ALuint); // r2
  ALfloat *p_Gain; // r0
  float *v29; // r1
  char *v30; // r2
  int v31; // r3
  int v32; // r4
  float v33; // s20
  float v34; // s0
  int v35; // r5
  const ChanMap *v36; // lr
  float v37; // s2
  int i; // r2
  int NumChan; // r6
  Channel channel; // r4
  int v41; // r3
  ALfloat *p_angle; // r8
  int v43; // r4
  ALuint (*Delay)[2]; // r10
  ALfloat (*delays)[128][2]; // r6
  ALuint irSize; // r0
  ALfloat *v47; // r6
  int Gains; // r4
  int v49; // r8
  float v50; // s4
  _DWORD *v51; // r0
  int v52; // r3
  int v53; // r4
  ALeffectslot *Slot; // r5
  ALeffectslot *type; // r1
  int v56; // r1
  float v57; // r0
  float v58; // s2
  float v59; // s8
  float v60; // s4
  float *p_coeff; // r0
  char *v62; // r1
  float v63; // s1
  int Frequency; // [sp+Ch] [bp-64h]
  ALsource_0 *v65; // [sp+14h] [bp-5Ch]
  char v66[16]; // [sp+18h] [bp-58h] BYREF
  char v67[72]; // [sp+28h] [bp-48h] BYREF

  Device = ALContext->Device;
  v11 = *((unsigned __int8 *)&elf_hash_chain[6163] + (_DWORD)Device);
  NumAuxSends = Device->NumAuxSends;
  Gain = ALContext->Listener->Gain;
  v3.n64_u32[0] = LODWORD(ALSource->Gain);
  v4.n64_u32[0] = LODWORD(ALSource->MinGain);
  v2.n64_u32[0] = LODWORD(ALSource->MaxGain);
  queue = ALSource->queue;
  Resampler = ALSource->Resampler;
  DirectChannels = ALSource->DirectChannels;
  Frequency = Device->Frequency;
  if ( !queue )
  {
LABEL_4:
    FmtChannels = 5376;
    goto LABEL_19;
  }
  while ( 1 )
  {
    buffer = queue->buffer;
    if ( queue->buffer )
      break;
    queue = queue->next;
    if ( !queue )
      goto LABEL_4;
  }
  v19 = 0x1FFFF;
  if ( 2047 - ResamplerPadding[Resampler] - ResamplerPrePadding[Resampler] < 0x1FFFF )
    v19 = 2047 - ResamplerPadding[Resampler] - ResamplerPrePadding[Resampler];
  v20 = (float)(ALSource->Pitch * (float)buffer->Frequency) / (float)(int)Device->Frequency;
  if ( v20 > (float)v19 )
  {
    v21 = v19 << 14;
    p_Step = &ALSource->Params.Step;
    goto LABEL_13;
  }
  v23 = (int)(float)(v20 * 16384.0);
  ALSource->Params.Step = v23;
  if ( !v23 )
  {
    p_Step = &ALSource->Params.Step;
    v21 = 1;
LABEL_13:
    *p_Step = v21;
    if ( v21 != 0x4000 )
      goto LABEL_14;
    goto LABEL_11;
  }
  if ( v23 != 0x4000 )
  {
LABEL_14:
    v24 = Resample_point32_C;
    if ( Resampler == LinearResampler )
      v24 = Resample_lerp32_C;
    if ( Resampler == CubicResampler )
      v24 = Resample_cubic32_C;
    goto LABEL_18;
  }
LABEL_11:
  v24 = Resample_copy32_C;
LABEL_18:
  ALSource->Params.Resample = v24;
  FmtChannels = buffer->FmtChannels;
LABEL_19:
  DirectGain = ALSource->DirectGain;
  LODWORD(v26) = vmin_f32(vmax_f32(v4, v3), v2).n64_u32[0];
  v8.n64_u32[0] = LODWORD(ALSource->DirectGainHF);
  ALSource->Params.WetMix = (WetMixerFunc)MixSend_C;
  v27 = (ALvoid (*)(const DirectParams *, const ALfloat *, ALuint, ALuint, ALuint, ALuint))MixDirect_C;
  if ( !DirectChannels )
    v27 = (ALvoid (*)(const DirectParams *, const ALfloat *, ALuint, ALuint, ALuint, ALuint))MixDirect_Hrtf_C;
  if ( !v11 )
    v27 = (ALvoid (*)(const DirectParams *, const ALfloat *, ALuint, ALuint, ALuint, ALuint))MixDirect_C;
  ALSource->Params.DryMix = v27;
  if ( NumAuxSends >= 1 )
  {
    p_Gain = &ALSource->Send[0].Gain;
    v29 = (float *)v67;
    v30 = v66;
    v31 = NumAuxSends;
    do
    {
      --v31;
      *v29++ = v26 * (float)(Gain * *p_Gain);
      v32 = *((_DWORD *)p_Gain + 1);
      p_Gain += 3;
      *(_DWORD *)v30 = v32;
      v30 += 4;
    }
    while ( v31 );
  }
  v33 = Gain * DirectGain;
  v65 = ALSource;
  memset(ALSource->Params.Direct.Gains, 0, sizeof(ALSource->Params.Direct.Gains));
  v34 = 0.0;
  switch ( FmtChannels )
  {
    case 5376:
      v35 = 1;
      v36 = CalcNonAttnSourceParams_MonoMap;
      break;
    case 5377:
      if ( BYTE2(Device->Flags) << 31 )
      {
        v35 = 2;
        v34 = 1.0472;
        v36 = CalcNonAttnSourceParams_StereoWideMap;
      }
      else
      {
        v35 = 2;
        v36 = CalcNonAttnSourceParams_StereoWideMap;
        if ( Device->FmtChans != DevFmtStereo )
          v36 = CalcNonAttnSourceParams_StereoMap;
        if ( v11 )
          v36 = CalcNonAttnSourceParams_StereoMap;
      }
      break;
    case 5378:
      v35 = 2;
      v36 = CalcNonAttnSourceParams_RearMap;
      break;
    case 5379:
      v35 = 4;
      v36 = CalcNonAttnSourceParams_QuadMap;
      break;
    case 5380:
      v35 = 6;
      v36 = CalcNonAttnSourceParams_X51Map;
      break;
    case 5381:
      v35 = 7;
      v36 = CalcNonAttnSourceParams_X61Map;
      break;
    case 5382:
      v35 = 8;
      v36 = CalcNonAttnSourceParams_X71Map;
      break;
    default:
      v35 = 0;
      v36 = 0;
      break;
  }
  v37 = v26 * v33;
  if ( DirectChannels )
  {
    if ( v35 )
    {
      for ( i = 0; i < v35; ++i )
      {
        NumChan = Device->NumChan;
        if ( NumChan >= 1 )
        {
          channel = v36[i].channel;
          v41 = 0;
          while ( Device->Speaker2Chan[v41] != channel )
          {
            if ( ++v41 >= NumChan )
              goto LABEL_50;
          }
          v65->Params.Direct.Gains[i][channel] = v37;
        }
LABEL_50:
        ;
      }
    }
  }
  else if ( v11 )
  {
    if ( v35 )
    {
      p_angle = &v36->angle;
      v43 = 0;
      Delay = ALSource->Params.Direct.Hrtf.Params.Delay;
      delays = ALSource->Params.Direct.Hrtf.Params.Coeffs;
      do
      {
        if ( *((_DWORD *)p_angle - 1) == 3 )
        {
          (*Delay)[0] = 0;
          (*Delay)[1] = 0;
          memset(delays, 0, sizeof(ALfloat[128][2]));
        }
        else
        {
          j_GetLerpedHrtfCoeffs(Device->Hrtf, 0.0, *p_angle, v26 * v33, (ALuint *)delays, Delay);
        }
        ++v43;
        ++Delay;
        p_angle += 2;
        ++delays;
      }
      while ( v43 < v35 );
    }
    v65->Hrtf.Counter = 0;
    irSize = Device->Hrtf->irSize;
    v65->Params.Direct.Hrtf.State = &v65->Hrtf;
    v65->Params.Direct.Hrtf.Params.IrSize = irSize;
  }
  else if ( v35 )
  {
    v47 = &v36->angle;
    Gains = (int)v65->Params.Direct.Gains;
    v49 = 0;
    v50 = (float)((float)(v34 / 3.1416) * (float)((float)(1.0 / sqrtf((float)Device->NumChan)) + -1.0)) + 1.0;
    do
    {
      if ( *((_DWORD *)v47 - 1) == 3 )
        *(float *)(Gains + 12) = v37 * v50;
      else
        j_ComputeAngleGains(Device, *v47, v34, v37 * v50, Gains);
      ++v49;
      Gains += 36;
      v47 += 2;
    }
    while ( v49 < v35 );
  }
  v65->Params.Direct.PendingClicks = Device->PendingClicks;
  v65->Params.Direct.ClickRemoval = Device->ClickRemoval;
  v65->Params.Direct.OutBuffer = Device->DryBuffer;
  if ( NumAuxSends >= 1 )
  {
    v51 = (_DWORD *)&v65->Params.Send[0].Gain;
    v52 = 0;
    v53 = NumAuxSends;
    do
    {
      Slot = v65->Send[v52].Slot;
      if ( !(v52 * 4) && !Slot )
        Slot = Device->DefaultSlot;
      if ( Slot )
      {
        type = (ALeffectslot *)Slot->effect.type;
        if ( Slot->effect.type )
          type = Slot;
      }
      else
      {
        type = 0;
      }
      *(v51 - 1) = type;
      --v53;
      v56 = *(_DWORD *)&v67[v52 * 4];
      ++v52;
      *v51 = v56;
      v51 += 21;
    }
    while ( v53 );
  }
  v57 = cosf(31416.0 / (float)Frequency);
  v58 = v57;
  if ( v8.n64_f32[0] >= 0.9999 )
  {
    v60 = 0.0;
  }
  else
  {
    v5.n64_u32[0] = 981668463;
    v59 = vmax_f32(v8, v5).n64_f32[0];
    v60 = (float)((float)(1.0 - (float)(v59 * v57))
                - sqrtf(
                    (float)((float)(v59 + v59) * (float)(1.0 - v57))
                  - (float)((float)(v59 * v59) * (float)(1.0 - (float)(v57 * v57)))))
        / (float)(1.0 - v59);
  }
  v65->Params.Direct.iirFilter.coeff = v60;
  if ( NumAuxSends >= 1 )
  {
    p_coeff = &v65->Params.Send[0].iirFilter.coeff;
    v62 = v66;
    v6.n64_u32[0] = 981668463;
    do
    {
      v63 = 0.0;
      if ( *(float *)v62 < 0.9999 )
      {
        v7.n64_u32[0] = *(_DWORD *)v62;
        v7.n64_u64[0] = vmax_f32(v7, v6).n64_u64[0];
        v63 = (float)((float)(1.0 - (float)(v58 * v7.n64_f32[0]))
                    - sqrtf(
                        (float)((float)(1.0 - v58) * (float)(v7.n64_f32[0] + v7.n64_f32[0]))
                      - (float)((float)(1.0 - (float)(v58 * v58)) * (float)(v7.n64_f32[0] * v7.n64_f32[0]))))
            / (float)(1.0 - v7.n64_f32[0]);
      }
      *p_coeff = v63;
      p_coeff += 21;
      --NumAuxSends;
      v62 += 4;
    }
    while ( NumAuxSends );
  }
}
// 25C426: variable 'v4' is possibly undefined
// 25C426: variable 'v3' is possibly undefined
// 25C440: variable 'v2' is possibly undefined
// 25C746: variable 'v8' is possibly undefined
// 25C746: variable 'v5' is possibly undefined
// 25C7C8: variable 'v7' is possibly undefined
// 25C7C8: variable 'v6' is possibly undefined
// 10168: using guessed type int elf_hash_chain[22025];

//----- (0025C878) --------------------------------------------------------
void __fastcall alSourceUnqueueBuffers(ALuint source, ALsizei nb, ALuint *buffers)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v7; // r8
  _DWORD *v8; // r4
  unsigned int v9; // r1
  unsigned int *v11; // r0
  unsigned int *p_LastError; // r0
  unsigned int *v17; // r0
  _DWORD *v19; // r0
  int v20; // r5
  __int64 v21; // r2
  int v22; // r1
  unsigned int *v23; // r1
  unsigned int v24; // r2

  if ( nb )
  {
    ContextRef = j_GetContextRef();
    v7 = ContextRef;
    if ( ContextRef )
    {
      if ( nb <= -1 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          p_LastError = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_29;
          }
          goto LABEL_30;
        }
      }
      else
      {
        v8 = j_LookupUIntMapKey(&ContextRef->SourceMap, source);
        if ( v8 )
        {
          (*(void (**)(void))(*(volatile RefCount *)((char *)&v7->Device->ref + (unsigned int)&elf_hash_chain[6161]) + 44))();
          if ( !*((_BYTE *)v8 + 77) && v8[31] == 4137 )
          {
            v9 = v8[38];
            if ( v9 >= nb )
            {
              v19 = (_DWORD *)v8[36];
              v20 = 0;
              while ( 1 )
              {
                LODWORD(v21) = v19[1];
                HIDWORD(v21) = v8[37] - 1;
                *((_QWORD *)v8 + 18) = v21;
                v8[38] = v9 - 1;
                if ( *v19 )
                {
                  buffers[v20] = *(_DWORD *)(*v19 + 68);
                  v22 = *v19;
                  __dmb(0xBu);
                  v23 = (unsigned int *)(v22 + 44);
                  do
                    v24 = __ldrex(v23);
                  while ( __strex(v24 - 1, v23) );
                  __dmb(0xBu);
                }
                else
                {
                  buffers[v20] = 0;
                }
                free(v19);
                v19 = (_DWORD *)v8[36];
                if ( ++v20 == nb )
                  break;
                v9 = v8[38];
              }
              if ( v19 )
                v19[2] = 0;
              (*(void (**)(void))(*(volatile RefCount *)((char *)&v7->Device->ref + (unsigned int)&elf_hash_chain[6161])
                                + 48))();
              goto LABEL_31;
            }
          }
          (*(void (**)(void))(*(volatile RefCount *)((char *)&v7->Device->ref + (unsigned int)&elf_hash_chain[6161]) + 48))();
          if ( TrapALError )
            raise(5);
          if ( !__ldrex((unsigned int *)&v7->ref) )
          {
            v11 = (unsigned int *)&v7->LastError;
            __dmb(0xBu);
            while ( __strex(0xA003u, v11) )
            {
              if ( __ldrex(v11) )
                goto LABEL_29;
            }
            goto LABEL_30;
          }
        }
        else
        {
          if ( TrapALError )
            raise(5);
          if ( !__ldrex((unsigned int *)&v7->ref) )
          {
            v17 = (unsigned int *)&v7->LastError;
            __dmb(0xBu);
            while ( __strex(0xA001u, v17) )
            {
              if ( __ldrex(v17) )
                goto LABEL_29;
            }
            goto LABEL_30;
          }
        }
      }
LABEL_29:
      __clrex();
LABEL_30:
      __dmb(0xBu);
LABEL_31:
      ALCcontext_DecRef(v7);
    }
  }
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (0025CA20) --------------------------------------------------------
ALboolean __fastcall ApplyOffset(ALsource_0 *Source)
{
  ALbufferlistitem_0 *queue; // r5
  ALbufferlistitem_0 *v3; // r1
  ALbuffer *buffer; // r0
  ALenum OffsetType; // r1
  ALdouble *p_Offset; // r6
  __int64 v7; // kr00_8
  unsigned int v8; // r2
  unsigned int v9; // r0
  unsigned int v10; // r1
  ALboolean v11; // r1
  double Offset; // d16
  signed int v14; // r0
  int v15; // r2
  int v16; // r1
  ALuint v17; // r1
  int v18; // r2
  signed int v19; // r6
  signed int SampleLen; // r3

  queue = Source->queue;
  if ( !queue )
    goto LABEL_12;
  v3 = Source->queue;
  while ( 1 )
  {
    buffer = v3->buffer;
    if ( v3->buffer )
      break;
    v3 = v3->next;
    if ( !v3 )
      goto LABEL_12;
  }
  OffsetType = Source->OffsetType;
  if ( OffsetType == 4132 )
  {
    p_Offset = &Source->Offset;
    Offset = Source->Offset * (double)buffer->Frequency;
LABEL_16:
    v14 = (int)Offset;
    goto LABEL_26;
  }
  if ( OffsetType == 4133 )
  {
    Offset = Source->Offset;
    p_Offset = &Source->Offset;
    goto LABEL_16;
  }
  if ( OffsetType != 4134 )
  {
LABEL_12:
    v11 = 0;
    LODWORD(Source->Offset) = 0;
    HIDWORD(Source->Offset) = -1074790400;
    return v11;
  }
  p_Offset = &Source->Offset;
  v7 = *(_QWORD *)&buffer->OriginalChannels;
  v8 = v7 - 5376;
  v9 = (int)Source->Offset;
  if ( HIDWORD(v7) == 5132 )
  {
    if ( v8 > 6 )
      v10 = 0;
    else
      v10 = off_60A3A0[v8];
    v14 = 65 * (v9 / v10);
  }
  else
  {
    if ( v8 > 6 )
      v15 = 0;
    else
      v15 = dword_60A3C0[v8];
    if ( (unsigned int)(HIDWORD(v7) - 5120) > 0xB )
      v16 = 0;
    else
      v16 = dword_60A3E0[HIDWORD(v7) - 5120];
    v14 = v9 / (v16 * v15);
  }
LABEL_26:
  v11 = 0;
  *(_DWORD *)p_Offset = 0;
  *((_DWORD *)p_Offset + 1) = -1074790400;
  if ( v14 != -1 )
  {
    v17 = 0;
    v18 = 0;
    do
    {
      v19 = v14 - v18;
      if ( queue->buffer )
        SampleLen = queue->buffer->SampleLen;
      else
        SampleLen = 0;
      if ( SampleLen <= v19 )
      {
        ++v17;
      }
      else if ( v14 >= v18 )
      {
        Source->BuffersPlayed = v17;
        v11 = 1;
        Source->position = v19;
        Source->position_fraction = 0;
        return v11;
      }
      queue = queue->next;
      v18 += SampleLen;
    }
    while ( queue );
    return 0;
  }
  return v11;
}
// 60A3A0: using guessed type int off_60A3A0[5];
// 60A3C0: using guessed type _DWORD dword_60A3C0[8];
// 60A3E0: using guessed type _DWORD dword_60A3E0[12];

//----- (0025CB4C) --------------------------------------------------------
ALvoid __fastcall ReleaseALSources(ALCcontext *Context)
{
  int v1; // r2
  UIntMap::$8A70C81DF3844826C6730DC5B9E2C72C *v2; // r0
  _DWORD *value; // r5
  _DWORD *v4; // r0
  unsigned int *v5; // r1
  unsigned int v6; // r2
  int v7; // r0
  unsigned int *v8; // r0
  unsigned int v9; // r1
  int v10; // r0
  unsigned int *v11; // r0
  unsigned int v12; // r1
  int v13; // r0
  unsigned int *v14; // r0
  unsigned int v15; // r1
  int v16; // r0
  unsigned int *v17; // r0
  unsigned int v18; // r1
  unsigned int v19; // r0
  unsigned int v20; // r0
  unsigned int v21; // r0
  unsigned int v22; // r0
  ALenum *v23; // r1
  unsigned int *v24; // r0
  unsigned int v25; // r0
  int v26; // t1
  ALCcontext *v27; // [sp+0h] [bp-28h]
  int v28; // [sp+4h] [bp-24h]
  int v29; // [sp+8h] [bp-20h]

  if ( Context->SourceMap.size >= 1 )
  {
    v1 = 0;
    v27 = Context;
    do
    {
      v29 = v1;
      v2 = &Context->SourceMap.array[v1];
      value = v2->value;
      v2->value = 0;
      while ( 1 )
      {
        v4 = (_DWORD *)value[36];
        if ( !v4 )
          break;
        value[36] = v4[1];
        if ( *v4 )
        {
          v5 = (unsigned int *)(*v4 + 44);
          __dmb(0xBu);
          do
            v6 = __ldrex(v5);
          while ( __strex(v6 - 1, v5) );
          __dmb(0xBu);
        }
        free(v4);
      }
      v7 = value[43];
      if ( v7 )
      {
        v8 = (unsigned int *)(v7 + 8408);
        __dmb(0xBu);
        do
          v9 = __ldrex(v8);
        while ( __strex(v9 - 1, v8) );
        __dmb(0xBu);
      }
      v10 = value[46];
      value[43] = 0;
      if ( v10 )
      {
        v11 = (unsigned int *)(v10 + 8408);
        __dmb(0xBu);
        do
          v12 = __ldrex(v11);
        while ( __strex(v12 - 1, v11) );
        __dmb(0xBu);
      }
      v13 = value[49];
      value[46] = 0;
      if ( v13 )
      {
        v14 = (unsigned int *)(v13 + 8408);
        __dmb(0xBu);
        do
          v15 = __ldrex(v14);
        while ( __strex(v15 - 1, v14) );
        __dmb(0xBu);
      }
      v16 = value[52];
      value[49] = 0;
      if ( v16 )
      {
        v17 = (unsigned int *)(v16 + 8408);
        __dmb(0xBu);
        do
          v18 = __ldrex(v17);
        while ( __strex(v18 - 1, v17) );
        __dmb(0xBu);
      }
      v28 = value[5730];
      value[52] = 0;
      __dmb(0xBu);
      do
        v19 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
      while ( 1 )
      {
        __dmb(0xBu);
        if ( v19 != 1 )
          break;
        sched_yield();
        __dmb(0xBu);
        do
          v19 = __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(1u, (unsigned int *)&ThunkLock.read_entry_lock) );
      }
      __dmb(0xBu);
      do
        v20 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
      while ( 1 )
      {
        __dmb(0xBu);
        if ( v20 != 1 )
          break;
        sched_yield();
        __dmb(0xBu);
        do
          v20 = __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(1u, (unsigned int *)&ThunkLock.read_lock) );
      }
      __dmb(0xBu);
      do
        v21 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(v21 + 1, (unsigned int *)&ThunkLock.read_count) );
      __dmb(0xBu);
      if ( !v21 )
      {
        __dmb(0xBu);
        do
          v22 = __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
        while ( 1 )
        {
          __dmb(0xBu);
          if ( v22 != 1 )
            break;
          sched_yield();
          __dmb(0xBu);
          do
            v22 = __ldrex((unsigned int *)&ThunkLock.read_count);
          while ( __strex(1u, (unsigned int *)&ThunkLock.write_lock) );
        }
      }
      __dmb(0xBu);
      do
        __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(0, (unsigned int *)&ThunkLock.read_lock) );
      __dmb(0xBu);
      __dmb(0xBu);
      do
        __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(0, (unsigned int *)&ThunkLock.read_entry_lock) );
      __dmb(0xBu);
      if ( v28 - 1 < ThunkArraySize )
      {
        v23 = ThunkArray;
        __dmb(0xBu);
        v24 = (unsigned int *)&v23[v28 - 1];
        do
          __ldrex(v24);
        while ( __strex(0, v24) );
        __dmb(0xBu);
      }
      __dmb(0xBu);
      do
        v25 = __ldrex((unsigned int *)&ThunkLock.read_count);
      while ( __strex(v25 - 1, (unsigned int *)&ThunkLock.read_count) );
      __dmb(0xBu);
      if ( v25 == 1 )
      {
        __dmb(0xBu);
        do
          __ldrex((unsigned int *)&ThunkLock.read_count);
        while ( __strex(0, (unsigned int *)&ThunkLock.write_lock) );
        __dmb(0xBu);
      }
      memset(value, 0, 0x5990u);
      if ( value )
      {
        do
        {
          v26 = *((unsigned __int8 *)value - 1);
          value = (_DWORD *)((char *)value - 1);
        }
        while ( v26 == 85 );
        free(value);
      }
      Context = v27;
      v1 = v29 + 1;
    }
    while ( v29 + 1 < v27->SourceMap.size );
  }
}

//----- (0025CDF8) --------------------------------------------------------
void __fastcall alEnable(ALenum capability)
{
  ALCcontext *ContextRef; // r4
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    if ( capability == 512 )
    {
      ContextRef->SourceDistanceModel = 1;
      ContextRef->UpdateSources = 1;
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&ContextRef->ref) )
      {
LABEL_10:
        __clrex();
      }
      else
      {
        p_LastError = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_10;
        }
      }
      __dmb(0xBu);
    }
    ALCcontext_DecRef(ContextRef);
  }
}

//----- (0025CE64) --------------------------------------------------------
void __fastcall alDisable(ALenum capability)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v3; // r4
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  v3 = ContextRef;
  if ( ContextRef )
  {
    if ( capability == 512 )
    {
      ContextRef->SourceDistanceModel = 0;
      ContextRef->UpdateSources = 1;
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&v3->ref) )
      {
LABEL_10:
        __clrex();
      }
      else
      {
        p_LastError = (unsigned int *)&v3->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_10;
        }
      }
      __dmb(0xBu);
    }
    ALCcontext_DecRef(v3);
  }
}

//----- (0025CED0) --------------------------------------------------------
ALboolean __fastcall alIsEnabled(ALenum capability)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v3; // r4
  ALboolean SourceDistanceModel; // r5
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  v3 = ContextRef;
  if ( !ContextRef )
    return 0;
  if ( capability == 512 )
  {
    SourceDistanceModel = ContextRef->SourceDistanceModel;
  }
  else
  {
    if ( TrapALError )
      raise(5);
    if ( __ldrex((unsigned int *)&v3->ref) )
    {
LABEL_11:
      __clrex();
    }
    else
    {
      p_LastError = (unsigned int *)&v3->LastError;
      __dmb(0xBu);
      while ( __strex(0xA002u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
          goto LABEL_11;
      }
    }
    SourceDistanceModel = 0;
    __dmb(0xBu);
  }
  j_ALCcontext_DecRef(v3);
  return SourceDistanceModel;
}

//----- (0025CF3C) --------------------------------------------------------
ALboolean __fastcall alGetBoolean(ALenum pname)
{
  ALCcontext *ContextRef; // r4
  float DopplerFactor; // s0
  volatile ALenum DeferUpdates; // r5
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  if ( !ContextRef )
    return 0;
  switch ( pname )
  {
    case 49152:
      DopplerFactor = ContextRef->DopplerFactor;
      goto LABEL_10;
    case 49153:
      DopplerFactor = ContextRef->DopplerVelocity;
      goto LABEL_10;
    case 49154:
      DeferUpdates = ContextRef->DeferUpdates;
      goto LABEL_21;
    case 49155:
      DopplerFactor = ContextRef->SpeedOfSound;
LABEL_10:
      if ( DopplerFactor == 0.0 )
        goto LABEL_20;
      LOBYTE(DeferUpdates) = 1;
      goto LABEL_21;
    default:
      if ( pname == 53248 )
      {
        LOBYTE(DeferUpdates) = ContextRef->DistanceModel == InverseDistanceClamped;
        goto LABEL_21;
      }
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&ContextRef->ref) )
        goto LABEL_18;
      p_LastError = (unsigned int *)&ContextRef->LastError;
      __dmb(0xBu);
      break;
  }
  while ( __strex(0xA002u, p_LastError) )
  {
    if ( __ldrex(p_LastError) )
    {
LABEL_18:
      __clrex();
      break;
    }
  }
  __dmb(0xBu);
LABEL_20:
  LOBYTE(DeferUpdates) = 0;
LABEL_21:
  j_ALCcontext_DecRef(ContextRef);
  return DeferUpdates;
}

//----- (0025CFE4) --------------------------------------------------------
ALdouble __fastcall alGetDouble(ALenum pname)
{
  ALCcontext *ContextRef; // r4
  double DopplerFactor; // d8
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  if ( !ContextRef )
    return 0.0;
  switch ( pname )
  {
    case 49152:
      DopplerFactor = ContextRef->DopplerFactor;
      break;
    case 49153:
      DopplerFactor = ContextRef->DopplerVelocity;
      break;
    case 49154:
      DopplerFactor = (double)(int)ContextRef->DeferUpdates;
      break;
    case 49155:
      DopplerFactor = ContextRef->SpeedOfSound;
      break;
    default:
      if ( pname == 53248 )
      {
        DopplerFactor = (double)(unsigned int)ContextRef->DistanceModel;
      }
      else
      {
        if ( TrapALError )
          raise(5);
        if ( __ldrex((unsigned int *)&ContextRef->ref) )
        {
LABEL_13:
          DopplerFactor = 0.0;
          __clrex();
        }
        else
        {
          p_LastError = (unsigned int *)&ContextRef->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_13;
          }
          DopplerFactor = 0.0;
        }
        __dmb(0xBu);
      }
      break;
  }
  j_ALCcontext_DecRef(ContextRef);
  return DopplerFactor;
}

//----- (0025D09C) --------------------------------------------------------
ALfloat __fastcall alGetFloat(ALenum pname)
{
  ALCcontext *ContextRef; // r4
  float DopplerFactor; // s16
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  if ( !ContextRef )
    return 0.0;
  switch ( pname )
  {
    case 49152:
      DopplerFactor = ContextRef->DopplerFactor;
      break;
    case 49153:
      DopplerFactor = ContextRef->DopplerVelocity;
      break;
    case 49154:
      DopplerFactor = (float)ContextRef->DeferUpdates;
      break;
    case 49155:
      DopplerFactor = ContextRef->SpeedOfSound;
      break;
    default:
      if ( pname == 53248 )
      {
        DopplerFactor = (float)(unsigned int)ContextRef->DistanceModel;
      }
      else
      {
        if ( TrapALError )
          raise(5);
        if ( __ldrex((unsigned int *)&ContextRef->ref) )
        {
LABEL_13:
          DopplerFactor = 0.0;
          __clrex();
        }
        else
        {
          p_LastError = (unsigned int *)&ContextRef->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, p_LastError) )
          {
            if ( __ldrex(p_LastError) )
              goto LABEL_13;
          }
          DopplerFactor = 0.0;
        }
        __dmb(0xBu);
      }
      break;
  }
  j_ALCcontext_DecRef(ContextRef);
  return DopplerFactor;
}

//----- (0025D14C) --------------------------------------------------------
ALint __fastcall alGetInteger(ALenum pname)
{
  ALCcontext *ContextRef; // r4
  float DopplerFactor; // s0
  ALint DeferUpdates; // r5
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  if ( !ContextRef )
    return 0;
  switch ( pname )
  {
    case 49152:
      DopplerFactor = ContextRef->DopplerFactor;
      goto LABEL_10;
    case 49153:
      DopplerFactor = ContextRef->DopplerVelocity;
      goto LABEL_10;
    case 49154:
      DeferUpdates = ContextRef->DeferUpdates;
      goto LABEL_19;
    case 49155:
      DopplerFactor = ContextRef->SpeedOfSound;
LABEL_10:
      DeferUpdates = (int)DopplerFactor;
      goto LABEL_19;
    default:
      if ( pname == 53248 )
      {
        DeferUpdates = ContextRef->DistanceModel;
        goto LABEL_19;
      }
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&ContextRef->ref) )
        goto LABEL_17;
      p_LastError = (unsigned int *)&ContextRef->LastError;
      __dmb(0xBu);
      break;
  }
  while ( __strex(0xA002u, p_LastError) )
  {
    if ( __ldrex(p_LastError) )
    {
LABEL_17:
      __clrex();
      break;
    }
  }
  DeferUpdates = 0;
  __dmb(0xBu);
LABEL_19:
  j_ALCcontext_DecRef(ContextRef);
  return DeferUpdates;
}

//----- (0025D1E4) --------------------------------------------------------
void __fastcall alGetBooleanv(ALenum pname, ALboolean *values)
{
  ALCcontext *v4; // r0
  ALCcontext *v5; // r8
  float DopplerFactor; // s0
  ALCcontext *ContextRef; // r5
  unsigned int *p_LastError; // r0
  volatile ALenum DeferUpdates; // r6
  unsigned int *v13; // r0
  unsigned int *v16; // r0

  if ( !values || (unsigned int)(pname - 49152) >= 4 && pname != 53248 )
  {
    ContextRef = j_GetContextRef();
    if ( !ContextRef )
      return;
    if ( values )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        p_LastError = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_23;
        }
        goto LABEL_24;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        v13 = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v13) )
        {
          if ( __ldrex(v13) )
            goto LABEL_23;
        }
        goto LABEL_24;
      }
    }
LABEL_23:
    __clrex();
LABEL_24:
    __dmb(0xBu);
    ALCcontext_DecRef(ContextRef);
    return;
  }
  v4 = j_GetContextRef();
  v5 = v4;
  if ( v4 )
  {
    switch ( pname )
    {
      case 49152:
        DopplerFactor = v4->DopplerFactor;
        goto LABEL_30;
      case 49153:
        DopplerFactor = v4->DopplerVelocity;
        goto LABEL_30;
      case 49154:
        DeferUpdates = v4->DeferUpdates;
        goto LABEL_41;
      case 49155:
        DopplerFactor = v4->SpeedOfSound;
LABEL_30:
        if ( DopplerFactor == 0.0 )
          goto LABEL_40;
        LOBYTE(DeferUpdates) = 1;
        goto LABEL_41;
      default:
        if ( pname == 53248 )
        {
          LOBYTE(DeferUpdates) = v4->DistanceModel == InverseDistanceClamped;
          goto LABEL_41;
        }
        if ( TrapALError )
          raise(5);
        if ( __ldrex((unsigned int *)&v5->ref) )
          goto LABEL_38;
        v16 = (unsigned int *)&v5->LastError;
        __dmb(0xBu);
        break;
    }
    while ( __strex(0xA002u, v16) )
    {
      if ( __ldrex(v16) )
      {
LABEL_38:
        __clrex();
        break;
      }
    }
    __dmb(0xBu);
LABEL_40:
    LOBYTE(DeferUpdates) = 0;
LABEL_41:
    j_ALCcontext_DecRef(v5);
  }
  else
  {
    LOBYTE(DeferUpdates) = 0;
  }
  *values = DeferUpdates;
}

//----- (0025D32C) --------------------------------------------------------
void __fastcall alGetDoublev(ALenum pname, ALdouble *values)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v5; // r8
  float DopplerFactor; // s0
  ALCcontext *v7; // r5
  unsigned int *v9; // r0
  double DeferUpdates; // d8
  unsigned int *v13; // r0
  unsigned int *p_LastError; // r0

  if ( values && ((unsigned int)(pname - 49152) < 4 || pname == 53248) )
  {
    ContextRef = j_GetContextRef();
    v5 = ContextRef;
    if ( ContextRef )
    {
      switch ( pname )
      {
        case 49152:
          DopplerFactor = ContextRef->DopplerFactor;
          goto LABEL_38;
        case 49153:
          DopplerFactor = ContextRef->DopplerVelocity;
          goto LABEL_38;
        case 49154:
          DeferUpdates = (double)(int)ContextRef->DeferUpdates;
          goto LABEL_39;
        case 49155:
          DopplerFactor = ContextRef->SpeedOfSound;
LABEL_38:
          DeferUpdates = DopplerFactor;
          goto LABEL_39;
        default:
          if ( pname == 53248 )
          {
            DeferUpdates = (double)(unsigned int)ContextRef->DistanceModel;
            goto LABEL_39;
          }
          if ( TrapALError )
            raise(5);
          if ( __ldrex((unsigned int *)&v5->ref) )
            goto LABEL_33;
          p_LastError = (unsigned int *)&v5->LastError;
          __dmb(0xBu);
          break;
      }
      while ( __strex(0xA002u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
        {
LABEL_33:
          DeferUpdates = 0.0;
          __clrex();
          goto LABEL_34;
        }
      }
      DeferUpdates = 0.0;
LABEL_34:
      __dmb(0xBu);
LABEL_39:
      j_ALCcontext_DecRef(v5);
    }
    else
    {
      DeferUpdates = 0.0;
    }
    *values = DeferUpdates;
  }
  else
  {
    v7 = j_GetContextRef();
    if ( v7 )
    {
      if ( values )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          v9 = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, v9) )
          {
            if ( __ldrex(v9) )
              goto LABEL_23;
          }
          goto LABEL_24;
        }
      }
      else
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          v13 = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, v13) )
          {
            if ( __ldrex(v13) )
              goto LABEL_23;
          }
          goto LABEL_24;
        }
      }
LABEL_23:
      __clrex();
LABEL_24:
      __dmb(0xBu);
      ALCcontext_DecRef(v7);
    }
  }
}

//----- (0025D480) --------------------------------------------------------
void __fastcall alGetFloatv(ALenum pname, ALfloat *values)
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v5; // r8
  float DopplerFactor; // s16
  ALCcontext *v7; // r5
  unsigned int *v9; // r0
  unsigned int *v12; // r0
  unsigned int *p_LastError; // r0

  if ( values && ((unsigned int)(pname - 49152) < 4 || pname == 53248) )
  {
    ContextRef = j_GetContextRef();
    v5 = ContextRef;
    if ( ContextRef )
    {
      switch ( pname )
      {
        case 49152:
          DopplerFactor = ContextRef->DopplerFactor;
          break;
        case 49153:
          DopplerFactor = ContextRef->DopplerVelocity;
          break;
        case 49154:
          DopplerFactor = (float)ContextRef->DeferUpdates;
          break;
        case 49155:
          DopplerFactor = ContextRef->SpeedOfSound;
          break;
        default:
          if ( pname == 53248 )
          {
            DopplerFactor = (float)(unsigned int)ContextRef->DistanceModel;
          }
          else
          {
            if ( TrapALError )
              raise(5);
            if ( __ldrex((unsigned int *)&v5->ref) )
            {
LABEL_33:
              DopplerFactor = 0.0;
              __clrex();
            }
            else
            {
              p_LastError = (unsigned int *)&v5->LastError;
              __dmb(0xBu);
              while ( __strex(0xA002u, p_LastError) )
              {
                if ( __ldrex(p_LastError) )
                  goto LABEL_33;
              }
              DopplerFactor = 0.0;
            }
            __dmb(0xBu);
          }
          break;
      }
      j_ALCcontext_DecRef(v5);
    }
    else
    {
      DopplerFactor = 0.0;
    }
    *values = DopplerFactor;
  }
  else
  {
    v7 = j_GetContextRef();
    if ( v7 )
    {
      if ( values )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          v9 = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA002u, v9) )
          {
            if ( __ldrex(v9) )
              goto LABEL_23;
          }
          goto LABEL_24;
        }
      }
      else
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&v7->ref) )
        {
          v12 = (unsigned int *)&v7->LastError;
          __dmb(0xBu);
          while ( __strex(0xA003u, v12) )
          {
            if ( __ldrex(v12) )
              goto LABEL_23;
          }
          goto LABEL_24;
        }
      }
LABEL_23:
      __clrex();
LABEL_24:
      __dmb(0xBu);
      ALCcontext_DecRef(v7);
    }
  }
}

//----- (0025D5D4) --------------------------------------------------------
void __fastcall alGetIntegerv(ALenum pname, ALint *values)
{
  ALCcontext *v4; // r0
  ALCcontext *v5; // r8
  float DopplerFactor; // s0
  ALCcontext *ContextRef; // r5
  unsigned int *p_LastError; // r0
  ALint DeferUpdates; // r6
  unsigned int *v13; // r0
  unsigned int *v16; // r0

  if ( !values || (unsigned int)(pname - 49152) >= 4 && pname != 53248 )
  {
    ContextRef = j_GetContextRef();
    if ( !ContextRef )
      return;
    if ( values )
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        p_LastError = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_23;
        }
        goto LABEL_24;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&ContextRef->ref) )
      {
        v13 = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v13) )
        {
          if ( __ldrex(v13) )
            goto LABEL_23;
        }
        goto LABEL_24;
      }
    }
LABEL_23:
    __clrex();
LABEL_24:
    __dmb(0xBu);
    ALCcontext_DecRef(ContextRef);
    return;
  }
  v4 = j_GetContextRef();
  v5 = v4;
  if ( v4 )
  {
    switch ( pname )
    {
      case 49152:
        DopplerFactor = v4->DopplerFactor;
        goto LABEL_30;
      case 49153:
        DopplerFactor = v4->DopplerVelocity;
        goto LABEL_30;
      case 49154:
        DeferUpdates = v4->DeferUpdates;
        goto LABEL_39;
      case 49155:
        DopplerFactor = v4->SpeedOfSound;
LABEL_30:
        DeferUpdates = (int)DopplerFactor;
        goto LABEL_39;
      default:
        if ( pname == 53248 )
        {
          DeferUpdates = v4->DistanceModel;
          goto LABEL_39;
        }
        if ( TrapALError )
          raise(5);
        if ( __ldrex((unsigned int *)&v5->ref) )
          goto LABEL_37;
        v16 = (unsigned int *)&v5->LastError;
        __dmb(0xBu);
        break;
    }
    while ( __strex(0xA002u, v16) )
    {
      if ( __ldrex(v16) )
      {
LABEL_37:
        __clrex();
        break;
      }
    }
    DeferUpdates = 0;
    __dmb(0xBu);
LABEL_39:
    j_ALCcontext_DecRef(v5);
  }
  else
  {
    DeferUpdates = 0;
  }
  *values = DeferUpdates;
}

//----- (0025D70C) --------------------------------------------------------
const ALchar *__fastcall alGetString(ALenum pname)
{
  ALCcontext *ContextRef; // r4
  int v3; // r0
  const ALchar *ExtensionList; // r5
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  if ( !ContextRef )
    return 0;
  switch ( pname )
  {
    case 40961:
      ExtensionList = alErrInvalidName;
      break;
    case 40962:
      ExtensionList = alErrInvalidEnum;
      break;
    case 40963:
      ExtensionList = alErrInvalidValue;
      break;
    case 40964:
      ExtensionList = alErrInvalidOp;
      break;
    case 40965:
      ExtensionList = alErrOutOfMemory;
      break;
    default:
      v3 = pname - 45057;
      ExtensionList = alVendor;
      switch ( v3 )
      {
        case 0:
          goto LABEL_24;
        case 1:
          ExtensionList = alVersion;
          break;
        case 2:
          ExtensionList = alRenderer;
          break;
        case 3:
          ExtensionList = ContextRef->ExtensionList;
          break;
        default:
          if ( alVendor )
          {
            if ( TrapALError )
              raise(5);
            if ( __ldrex((unsigned int *)&ContextRef->ref) )
            {
LABEL_22:
              __clrex();
            }
            else
            {
              p_LastError = (unsigned int *)&ContextRef->LastError;
              __dmb(0xBu);
              while ( __strex(0xA002u, p_LastError) )
              {
                if ( __ldrex(p_LastError) )
                  goto LABEL_22;
              }
            }
            ExtensionList = 0;
            __dmb(0xBu);
          }
          else
          {
            ExtensionList = alNoError;
          }
          break;
      }
      break;
  }
LABEL_24:
  j_ALCcontext_DecRef(ContextRef);
  return ExtensionList;
}

//----- (0025D7F0) --------------------------------------------------------
void __fastcall alDopplerFactor(ALfloat value)
{
  ALCcontext *ContextRef; // r4
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    if ( value < 0.0 || fabsf(value) == INFINITY )
    {
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&ContextRef->ref) )
      {
LABEL_11:
        __clrex();
      }
      else
      {
        p_LastError = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_11;
        }
      }
      __dmb(0xBu);
    }
    else
    {
      ContextRef->DopplerFactor = value;
      ContextRef->UpdateSources = 1;
    }
    ALCcontext_DecRef(ContextRef);
  }
}

//----- (0025D878) --------------------------------------------------------
void __fastcall alDopplerVelocity(ALfloat value)
{
  ALCcontext *ContextRef; // r4
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    if ( value < 0.0 || fabsf(value) == INFINITY )
    {
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&ContextRef->ref) )
      {
LABEL_11:
        __clrex();
      }
      else
      {
        p_LastError = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_11;
        }
      }
      __dmb(0xBu);
    }
    else
    {
      ContextRef->DopplerVelocity = value;
      ContextRef->UpdateSources = 1;
    }
    ALCcontext_DecRef(ContextRef);
  }
}

//----- (0025D900) --------------------------------------------------------
void __fastcall alSpeedOfSound(ALfloat value)
{
  ALCcontext *ContextRef; // r4
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    if ( value <= 0.0 || fabsf(value) == INFINITY )
    {
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&ContextRef->ref) )
      {
LABEL_11:
        __clrex();
      }
      else
      {
        p_LastError = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_11;
        }
      }
      __dmb(0xBu);
    }
    else
    {
      ContextRef->SpeedOfSound = value;
      ContextRef->UpdateSources = 1;
    }
    ALCcontext_DecRef(ContextRef);
  }
}

//----- (0025D988) --------------------------------------------------------
void __fastcall alDistanceModel(ALenum value)
{
  ALCcontext *ContextRef; // r4
  unsigned int *p_LastError; // r0

  ContextRef = j_GetContextRef();
  if ( ContextRef )
  {
    if ( (unsigned int)(value - 53249) >= 6 && value )
    {
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&ContextRef->ref) )
      {
LABEL_13:
        __clrex();
      }
      else
      {
        p_LastError = (unsigned int *)&ContextRef->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_13;
        }
      }
      __dmb(0xBu);
    }
    else
    {
      ContextRef->DistanceModel = value;
      if ( !ContextRef->SourceDistanceModel )
        ContextRef->UpdateSources = 1;
    }
    ALCcontext_DecRef(ContextRef);
  }
}

//----- (0025DA00) --------------------------------------------------------
void alDeferUpdatesSOFT()
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v1; // r4
  int v2; // r9
  unsigned int *p_UpdateSources; // r1
  unsigned __int8 v4; // r0
  ALsizei ActiveSourceCount; // r1
  ALsource **ActiveSources; // r6
  int v7; // r10
  ALsource **v8; // r5
  ALsource *v9; // r0
  ALsource *v10; // t1
  unsigned int *p_NeedsUpdate; // r0
  unsigned int v12; // r1
  ALsizei ActiveEffectSlotCount; // r0
  ALeffectslot **ActiveEffectSlots; // r5
  ALeffectslot **v15; // r8
  ALeffectslot *v16; // r0
  unsigned int *v17; // r0
  unsigned int v18; // r1

  ContextRef = j_GetContextRef();
  v1 = ContextRef;
  if ( ContextRef )
  {
    if ( !ContextRef->DeferUpdates )
    {
      v2 = fegetround();
      fesetround(3);
      (*(void (**)(void))(*(volatile RefCount *)((char *)&v1->Device->ref + (unsigned int)&elf_hash_chain[6161]) + 44))();
      p_UpdateSources = (unsigned int *)&v1->UpdateSources;
      v1->DeferUpdates = 1;
      __dmb(0xBu);
      do
        v4 = __ldrex(p_UpdateSources);
      while ( __strex(0, p_UpdateSources) );
      __dmb(0xBu);
      ActiveSourceCount = v1->ActiveSourceCount;
      if ( ActiveSourceCount )
      {
        ActiveSources = v1->ActiveSources;
        v7 = v4;
        v8 = &ActiveSources[ActiveSourceCount];
        do
        {
          v9 = *ActiveSources;
          while ( v9->state != 4114 )
          {
            --v1->ActiveSourceCount;
            v10 = *--v8;
            v9 = v10;
            *ActiveSources = v10;
            if ( ActiveSources == v8 )
              goto LABEL_16;
          }
          p_NeedsUpdate = (unsigned int *)&v9->NeedsUpdate;
          __dmb(0xBu);
          do
            v12 = __ldrex(p_NeedsUpdate);
          while ( __strex(0, p_NeedsUpdate) );
          __dmb(0xBu);
          if ( v12 | v7 )
            ((void (*)(void))(*ActiveSources)->Update)();
          ++ActiveSources;
        }
        while ( ActiveSources != v8 );
      }
LABEL_16:
      ActiveEffectSlotCount = v1->ActiveEffectSlotCount;
      if ( ActiveEffectSlotCount )
      {
        ActiveEffectSlots = v1->ActiveEffectSlots;
        v15 = &ActiveEffectSlots[ActiveEffectSlotCount];
        do
        {
          v16 = *ActiveEffectSlots;
          __dmb(0xBu);
          v17 = (unsigned int *)&v16->NeedsUpdate;
          do
            v18 = __ldrex(v17);
          while ( __strex(0, v17) );
          __dmb(0xBu);
          if ( v18 )
            ((void (*)(void))(*ActiveEffectSlots)->EffectState->Update)();
          ++ActiveEffectSlots;
        }
        while ( ActiveEffectSlots != v15 );
      }
      (*(void (**)(void))(*(volatile RefCount *)((char *)&v1->Device->ref + (unsigned int)&elf_hash_chain[6161]) + 48))();
      fesetround(v2);
    }
    ALCcontext_DecRef(v1);
  }
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (0025DB2C) --------------------------------------------------------
void alProcessUpdatesSOFT()
{
  ALCcontext *ContextRef; // r0
  ALCcontext *v1; // r9
  unsigned int *p_DeferUpdates; // r0
  unsigned int v3; // r1
  unsigned int *p_read_entry_lock; // r5
  unsigned int v5; // r0
  unsigned int v6; // r0
  unsigned int *p_read_lock; // r4
  unsigned int v8; // r0
  unsigned int v9; // r0
  unsigned int *p_read_count; // r11
  unsigned int v11; // r0
  unsigned int *p_write_lock; // r6
  unsigned int v13; // r0
  unsigned int v14; // r0
  ALsizei v15; // r8
  ALsource_0 *value; // r5
  volatile ALenum state; // r0
  bool v18; // zf
  unsigned int *p_new_state; // r0
  ALenum v20; // r2
  unsigned int v21; // r0
  unsigned int *v22; // r0

  ContextRef = j_GetContextRef();
  v1 = ContextRef;
  if ( ContextRef )
  {
    p_DeferUpdates = (unsigned int *)&ContextRef->DeferUpdates;
    __dmb(0xBu);
    do
      v3 = __ldrex(p_DeferUpdates);
    while ( __strex(0, p_DeferUpdates) );
    __dmb(0xBu);
    if ( v3 )
    {
      (*(void (**)(void))(*(volatile RefCount *)((char *)&v1->Device->ref + (unsigned int)&elf_hash_chain[6161]) + 44))();
      p_read_entry_lock = (unsigned int *)&v1->SourceMap.lock.read_entry_lock;
      __dmb(0xBu);
      do
        v5 = __ldrex(p_read_entry_lock);
      while ( __strex(1u, p_read_entry_lock) );
      __dmb(0xBu);
      if ( v5 == 1 )
      {
        do
        {
          sched_yield();
          __dmb(0xBu);
          do
            v6 = __ldrex(p_read_entry_lock);
          while ( __strex(1u, p_read_entry_lock) );
          __dmb(0xBu);
        }
        while ( v6 == 1 );
      }
      p_read_lock = (unsigned int *)&v1->SourceMap.lock.read_lock;
      __dmb(0xBu);
      do
        v8 = __ldrex(p_read_lock);
      while ( __strex(1u, p_read_lock) );
      __dmb(0xBu);
      if ( v8 == 1 )
      {
        do
        {
          sched_yield();
          __dmb(0xBu);
          do
            v9 = __ldrex(p_read_lock);
          while ( __strex(1u, p_read_lock) );
          __dmb(0xBu);
        }
        while ( v9 == 1 );
      }
      p_read_count = (unsigned int *)&v1->SourceMap.lock.read_count;
      __dmb(0xBu);
      do
        v11 = __ldrex(p_read_count);
      while ( __strex(v11 + 1, p_read_count) );
      __dmb(0xBu);
      if ( !v11 )
      {
        p_write_lock = (unsigned int *)&v1->SourceMap.lock.write_lock;
        __dmb(0xBu);
        do
          v13 = __ldrex(p_write_lock);
        while ( __strex(1u, p_write_lock) );
        __dmb(0xBu);
        if ( v13 == 1 )
        {
          do
          {
            sched_yield();
            __dmb(0xBu);
            do
              v14 = __ldrex(p_write_lock);
            while ( __strex(1u, p_write_lock) );
            __dmb(0xBu);
          }
          while ( v14 == 1 );
        }
      }
      __dmb(0xBu);
      do
        __ldrex(p_read_lock);
      while ( __strex(0, p_read_lock) );
      __dmb(0xBu);
      __dmb(0xBu);
      do
        __ldrex(p_read_entry_lock);
      while ( __strex(0, p_read_entry_lock) );
      __dmb(0xBu);
      if ( v1->SourceMap.size >= 1 )
      {
        v15 = 0;
        do
        {
          value = (ALsource_0 *)v1->SourceMap.array[v15].value;
          state = value->state;
          v18 = state == 4114;
          if ( state != 4114 )
            v18 = value->state == 4115;
          if ( v18 && value->Offset >= 0.0 )
            j_ApplyOffset((ALsource_0 *)v1->SourceMap.array[v15].value);
          p_new_state = (unsigned int *)&value->new_state;
          __dmb(0xBu);
          do
            v20 = __ldrex(p_new_state);
          while ( __strex(0, p_new_state) );
          __dmb(0xBu);
          if ( v20 )
            j_SetSourceState(value, v1, v20);
          ++v15;
        }
        while ( v15 < v1->SourceMap.size );
      }
      __dmb(0xBu);
      do
        v21 = __ldrex(p_read_count);
      while ( __strex(v21 - 1, p_read_count) );
      __dmb(0xBu);
      if ( v21 == 1 )
      {
        v22 = (unsigned int *)&v1->SourceMap.lock.write_lock;
        __dmb(0xBu);
        do
          __ldrex(v22);
        while ( __strex(0, v22) );
        __dmb(0xBu);
      }
      (*(void (**)(void))(*(volatile RefCount *)((char *)&v1->Device->ref + (unsigned int)&elf_hash_chain[6161]) + 48))();
    }
    ALCcontext_DecRef(v1);
  }
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (0025DD48) --------------------------------------------------------
void ThunkExit()
{
  free(ThunkArray);
  ThunkArray = 0;
  ThunkArraySize = 0;
}

//----- (0025DD6C) --------------------------------------------------------
void __fastcall GetLerpedHrtfCoeffs(
        const Hrtf *Hrtf,
        ALfloat elevation,
        ALfloat azimuth,
        ALfloat gain,
        ALuint *delays,
        _DWORD *a6)
{
  int v7; // r5
  const ALubyte *azCount; // r9
  float v9; // s16
  float v10; // s24
  unsigned int v11; // r8
  float v12; // s20
  unsigned int v13; // r10
  unsigned int v14; // r9
  float v15; // s22
  float v16; // r0
  const ALushort *evOffset; // r1
  const ALubyte *v18; // r2
  float v19; // s8
  int v20; // r10
  int v21; // r11
  float v22; // s12
  float v23; // s22
  float v24; // s16
  float v25; // s18
  float v26; // s20
  unsigned int v27; // r8
  int v28; // r5
  const ALubyte *v29; // r1
  int v30; // r0
  int v31; // r2
  ALuint irSize; // r1
  float v33; // s0
  int v34; // r9
  ALuint v35; // r3
  int v36; // r10
  int v37; // r11
  int v38; // lr
  int v39; // r8
  float *v40; // r2
  int v41; // r1
  const ALshort *coeffs; // r6
  const ALshort *v43; // r0
  float v44; // s2
  float v45; // s4
  int v46; // r6
  int v47; // r0
  ALuint *v48; // r0
  ALuint v49; // r2
  int v50; // [sp+4h] [bp-6Ch]
  int v51; // [sp+Ch] [bp-64h]
  float v52; // [sp+10h] [bp-60h]
  unsigned int v53; // [sp+14h] [bp-5Ch]
  unsigned int v54; // [sp+18h] [bp-58h]
  unsigned int v55; // [sp+18h] [bp-58h]
  unsigned int v56; // [sp+1Ch] [bp-54h]
  unsigned int v57; // [sp+20h] [bp-50h]
  int v58; // [sp+20h] [bp-50h]
  int v60; // [sp+24h] [bp-4Ch]

  v7 = Hrtf->evCount - 1;
  azCount = Hrtf->azCount;
  v9 = (float)((float)(elevation + 1.5708) * (float)v7) / 3.1416;
  v10 = azimuth + 6.2832;
  v11 = azCount[v9];
  v12 = (float)((float)(azimuth + 6.2832) * (float)v11) / 6.2832;
  v54 = (int)v12 % v11;
  v53 = (v54 + 1) % v11;
  v13 = (int)v9 + 1;
  v52 = floorf(v12);
  if ( v13 > v7 )
    v13 = v7;
  v14 = azCount[v13];
  v15 = (float)(v10 * (float)v14) / 6.2832;
  v56 = (int)v15 % v14;
  v57 = (v56 + 1) % v14;
  v16 = floorf(v15);
  evOffset = Hrtf->evOffset;
  v18 = Hrtf->delays;
  v19 = v15 - v16;
  v20 = evOffset[v13];
  v51 = v57 + v20;
  v21 = evOffset[v9];
  v50 = v54 + v21;
  v22 = v9 - (float)(unsigned int)(int)v9;
  v23 = v22 * (float)(v15 - v16);
  v24 = (float)(v12 - v52) * (float)(1.0 - v22);
  v25 = (float)(1.0 - (float)(v12 - v52)) * (float)(1.0 - v22);
  v26 = v22 * (float)(1.0 - v19);
  *a6 = (int)(float)((float)((float)((float)((float)(v25 * (float)v18[v54 + v21]) + (float)(v24 * (float)v18[v53 + v21]))
                                   + (float)(v26 * (float)v18[v56 + v20]))
                           + (float)((float)(v22 * v19) * (float)v18[v57 + v20]))
                   + 0.5) << 20;
  v55 = (v11 - v54) % v11;
  v27 = (v11 - v53) % v11;
  v28 = (v14 - v57) % v14 + v20;
  v29 = Hrtf->delays;
  v30 = (v14 - v56) % v14 + v20;
  v31 = v55 + v21;
  a6[1] = (int)(float)((float)((float)((float)((float)(v25 * (float)v29[v55 + v21])
                                             + (float)(v24 * (float)v29[v27 + v21]))
                                     + (float)(v26 * (float)v29[v30]))
                             + (float)(v23 * (float)v29[v28]))
                     + 0.5) << 20;
  irSize = Hrtf->irSize;
  if ( gain <= 0.0001 )
  {
    if ( irSize )
    {
      v48 = delays + 1;
      v49 = 0;
      do
      {
        *(v48 - 1) = 0;
        ++v49;
        *v48 = 0;
        v48 += 2;
      }
      while ( v49 < Hrtf->irSize );
    }
  }
  else if ( irSize )
  {
    v33 = gain * 0.000030519;
    v60 = v30 * irSize;
    v58 = (v27 + v21) * irSize;
    v34 = irSize * v51;
    v35 = 0;
    v36 = irSize * (v56 + v20);
    v37 = irSize * (v53 + v21);
    v38 = irSize * v50;
    v39 = v31 * irSize;
    v40 = (float *)(delays + 1);
    v41 = irSize * v28;
    do
    {
      coeffs = Hrtf->coeffs;
      *(v40 - 1) = v33
                 * (float)((float)((float)((float)(v25 * (float)coeffs[v38 + v35])
                                         + (float)(v24 * (float)coeffs[v37 + v35]))
                                 + (float)(v26 * (float)coeffs[v36 + v35]))
                         + (float)(v23 * (float)coeffs[v34 + v35]));
      v43 = Hrtf->coeffs;
      v44 = (float)v43[v58 + v35];
      v45 = (float)v43[v39 + v35];
      v46 = v43[v60 + v35];
      v47 = v43[v41 + v35++];
      *v40 = v33
           * (float)((float)((float)((float)(v25 * v45) + (float)(v24 * v44)) + (float)(v26 * (float)v46))
                   + (float)(v23 * (float)v47));
      v40 += 2;
    }
    while ( v35 < Hrtf->irSize );
  }
}

//----- (0025E108) --------------------------------------------------------
ALuint __fastcall GetHrtfIrSize(const Hrtf *Hrtf)
{
  return Hrtf->irSize;
}

//----- (0025E10C) --------------------------------------------------------
void __fastcall ComputeAngleGains(const ALCdevice *device, ALfloat angle, ALfloat hwidth, ALfloat ingain, int a5)
{
  ALuint v9; // r0
  ALuint NumChan; // r10
  float v11; // s16
  float v12; // s18
  ALfloat *SpeakerAngle; // r0
  ALuint i; // r5
  ALuint v15; // r0
  int v16; // r2
  unsigned int v17; // r0
  float *v18; // r1
  float v19; // s0
  float v20; // s0
  float v21; // s2
  float v22; // s0
  int v23; // r0
  volatile RefCount *v24; // r1
  ALuint v25; // r0
  float *v26; // r6
  float v27; // s2
  float *v28; // r5
  float *v29; // r2
  int v30; // r6
  int v31; // r1
  ALuint v32; // r1
  ALuint v33; // r0
  float v34; // s0
  float v35; // s2
  int *v36; // r12
  float *v37; // r2
  volatile RefCount *v38; // r3
  int v39; // r6
  ALuint v40; // r0
  volatile RefCount *v41; // r6
  float *v42; // r0
  ALuint v43; // r6
  float *v44; // r1
  float v45; // s0
  ALuint v46; // r1
  ALfloat *v47; // r1
  float *v48; // r0
  float v49; // s2
  float v50; // s0
  float v51; // s2
  float v52; // s4
  int v53; // r1
  unsigned int v54; // r0
  float v55; // s6
  float v56; // s8
  float *v57; // r1
  unsigned int j; // r2
  float v59; // s8
  int v60; // r5
  float v61; // s10
  float v62; // s10
  int v63; // r1
  float v64; // s6
  float v65; // s8
  ALuint v66; // r1
  Channel v67; // r2
  float v68; // [sp+0h] [bp-B8h] BYREF
  float v69[9]; // [sp+4h] [bp-B4h] BYREF
  int v70[10]; // [sp+28h] [bp-90h] BYREF
  int v71[26]; // [sp+50h] [bp-68h] BYREF

  memset(v71, 0, 36);
  v9 = 0;
  NumChan = device->NumChan;
  if ( NumChan )
  {
    qmemcpy(v70, device->Speaker2Chan, 4 * NumChan);
    qmemcpy(&v68, device->SpeakerAngle, 4 * NumChan);
    v9 = NumChan;
  }
  v11 = ingain;
  if ( hwidth >= 3.1416 || v9 == 1 )
  {
    if ( NumChan )
    {
      v15 = 0;
      do
      {
        v16 = v70[v15++];
        *(ALfloat *)(a5 + 4 * v16) = ingain;
      }
      while ( v15 < device->NumChan );
    }
  }
  else
  {
    v12 = angle;
    if ( hwidth > 0.0 )
    {
      if ( (float)(fabsf(angle) + hwidth) > 3.1416 )
      {
        if ( angle <= 0.0 )
        {
          v24 = &device->ref + v9;
          v25 = v9 - 1;
          v26 = (float *)(v24 + 64);
          do
          {
            if ( v25 >= NumChan )
            {
              v33 = NumChan - 1;
              goto LABEL_35;
            }
            v27 = *v26;
            --v25;
            --v26;
          }
          while ( (float)(v27 - angle) > 3.1416 );
          v28 = v26 + 1;
          v29 = &v68 + NumChan - 1;
          v30 = 0;
          do
          {
            *v29-- = *v28 - angle;
            v31 = *((_DWORD *)v28-- - 9);
            v70[NumChan - 1 + v30] = v31;
            v32 = v25 + v30--;
          }
          while ( v32 < NumChan );
          v33 = NumChan - 1 + v30;
LABEL_35:
          if ( v33 < NumChan )
          {
            v36 = &v70[v33];
            v37 = &v69[v33 - 1];
            v38 = &device->ref + NumChan;
            v39 = 0;
            do
            {
              --v33;
              v37[v39] = (float)(*(float *)&v38[v39 + 64] - angle) + -6.2832;
              v36[v39] = v38[v39 + 55];
              --v39;
            }
            while ( v33 < NumChan );
          }
          v12 = 0.0;
        }
        else
        {
          if ( NumChan )
          {
            SpeakerAngle = device->SpeakerAngle;
            for ( i = 0; i < NumChan; ++i )
            {
              if ( (float)(*SpeakerAngle - angle) >= -3.1416 )
                break;
              ++SpeakerAngle;
            }
          }
          else
          {
            i = 0;
          }
          if ( i >= NumChan )
          {
            v43 = 0;
          }
          else
          {
            v40 = i + 1;
            v41 = &device->ref + i;
            if ( NumChan > i + 1 )
              v40 = NumChan;
            qmemcpy(v70, (const void *)(v41 + 56), 4 * v40 - 4 * i);
            v42 = (float *)(v41 + 65);
            v43 = 0;
            v44 = &v68;
            do
            {
              v45 = *v42;
              ++v43;
              ++v42;
              *v44++ = v45 - angle;
            }
            while ( i + v43 < NumChan );
          }
          if ( v43 < NumChan )
          {
            v46 = v43 + 1;
            if ( NumChan > v43 + 1 )
              v46 = NumChan;
            qmemcpy(&v70[v43], device->Speaker2Chan, 4 * (v46 - v43));
            v47 = device->SpeakerAngle;
            v48 = &v69[v43 - 1];
            do
            {
              v49 = *v47;
              ++v43;
              ++v47;
              *v48++ = (float)(v49 - angle) + 6.2832;
            }
            while ( v43 < NumChan );
          }
          v12 = 0.0;
        }
      }
      v50 = v12 - hwidth;
      v51 = v68;
      v52 = v12 + hwidth;
      v53 = v70[0];
      v54 = NumChan - 1;
      if ( v68 >= (float)(v12 - hwidth) && v68 <= v52 )
      {
        v71[v70[0]] = 1065353216;
        if ( v54 < 2 )
          goto LABEL_77;
LABEL_66:
        v57 = v69;
        for ( j = 1; j < v54; ++j )
        {
          v59 = *v57;
          v60 = v70[j];
          if ( *v57 < v50 || v59 > v52 )
          {
            if ( v59 < v50 )
            {
              v61 = v57[1];
              if ( v61 > v50 )
                *(float *)&v71[v60] = *(float *)&v71[v60]
                                    + (float)((float)(1.0 - (float)((float)(v50 - v59) / (float)(v61 - v59)))
                                            * (float)(1.0 - *(float *)&v71[v60]));
            }
            if ( v59 > v52 )
            {
              v62 = *(v57 - 1);
              if ( v62 < v52 )
                *(float *)&v71[v60] = *(float *)&v71[v60]
                                    + (float)((float)((float)(v52 - v62) / (float)(v59 - v62))
                                            * (float)(1.0 - *(float *)&v71[v60]));
            }
          }
          else
          {
            v71[v60] = 1065353216;
          }
          ++v57;
        }
LABEL_77:
        v63 = v70[v54];
        v64 = v69[v54 - 1];
        if ( v64 >= v50 && v64 <= v52 )
        {
          v71[v63] = 1065353216;
          if ( !NumChan )
            return;
          goto LABEL_89;
        }
        if ( v64 > v52 )
        {
          v65 = v69[NumChan - 3];
          if ( v65 < v52 )
            *(float *)&v71[v63] = *(float *)&v71[v63]
                                + (float)((float)((float)(v52 - v65) / (float)(v64 - v65))
                                        * (float)(1.0 - *(float *)&v71[v63]));
        }
        if ( v64 >= v50 )
        {
          if ( v51 <= v50 )
            goto LABEL_88;
          v50 = v50 + 6.2832;
        }
        *(float *)&v71[v63] = *(float *)&v71[v63]
                            + (float)((float)(1.0 - *(float *)&v71[v63])
                                    * (float)(1.0 - (float)((float)(v50 - v64) / (float)((float)(v51 + 6.2832) - v64))));
LABEL_88:
        if ( !NumChan )
          return;
LABEL_89:
        v66 = 0;
        do
        {
          v67 = device->Speaker2Chan[v66++];
          *(float *)(a5 + 4 * v67) = sqrtf(*(float *)&v71[v67]) * v11;
        }
        while ( v66 < device->NumChan );
        return;
      }
      if ( v68 < v50 && v69[0] > v50 )
        *(float *)&v71[v70[0]] = *(float *)&v71[v70[0]]
                               + (float)((float)(1.0 - (float)((float)(v50 - v68) / (float)(v69[0] - v68)))
                                       * (float)(1.0 - *(float *)&v71[v70[0]]));
      if ( v51 <= v52 )
      {
        v55 = v69[v54 - 1];
        if ( v55 >= v52 )
          goto LABEL_65;
        v56 = v52 - v55;
      }
      else
      {
        v55 = v69[v54 - 1];
        v56 = (float)(v52 + 6.2832) - v55;
      }
      *(float *)&v71[v53] = *(float *)&v71[v53]
                          + (float)((float)(v56 / (float)((float)(v51 + 6.2832) - v55))
                                  * (float)(1.0 - *(float *)&v71[v53]));
LABEL_65:
      if ( v54 < 2 )
        goto LABEL_77;
      goto LABEL_66;
    }
    if ( NumChan == 1 )
    {
      v17 = 0;
LABEL_23:
      if ( v68 > angle )
        v12 = angle + 6.2832;
      v20 = (float)(v12 - v69[v17 - 1]) / (float)((float)(v68 + 6.2832) - v69[v17 - 1]);
      v21 = 1.0 - v20;
      v22 = sqrtf(v20) * ingain;
      *(float *)(a5 + 4 * v70[v17]) = sqrtf(v21) * ingain;
      v23 = v70[0];
    }
    else
    {
      v18 = v69;
      v17 = 0;
      while ( 1 )
      {
        v19 = *(v18 - 1);
        if ( v19 <= angle && *v18 > angle )
          break;
        ++v17;
        ++v18;
        if ( v17 >= NumChan - 1 )
          goto LABEL_23;
      }
      v34 = (float)(angle - v19) / (float)(*v18 - v19);
      v35 = 1.0 - v34;
      v22 = sqrtf(v34) * ingain;
      *(float *)(a5 + 4 * v70[v17]) = sqrtf(v35) * ingain;
      v23 = v70[v17 + 1];
    }
    *(float *)(a5 + 4 * v23) = v22;
  }
}
// 25E10C: using guessed type int var_90[10];

//----- (0025E6D8) --------------------------------------------------------
ALfloat __fastcall CalcHrtfDelta(ALfloat oldGain, ALfloat newGain, const ALfloat *olddir, const ALfloat *newdir)
{
  float32x2_t v4; // d0
  float32x2_t v5; // d1
  float32x2_t v6; // d8
  float32x2_t v7; // d9
  float32x2_t v11; // d1
  float v12; // s0
  float v13; // s6
  float v14; // s8
  float32x2_t v15; // d0
  ALfloat result; // r0

  v7.n64_u32[0] = 953267991;
  v5.n64_f32[0] = oldGain;
  v11.n64_u64[0] = vmax_f32(v5, v7).n64_u64[0];
  v12 = 0.0001;
  if ( newGain > 0.0001 )
    v12 = newGain;
  v6.n64_f32[0] = fabsf(log10f(v12 / v11.n64_f32[0]) * -0.25);
  v4.n64_u32[0] = 0;
  if ( newGain > 0.0001 )
  {
    if ( (float)(*newdir - *olddir) != 0.0 )
    {
      v13 = newdir[1];
      v14 = olddir[1];
LABEL_8:
      v4.n64_f32[0] = (float)(acosf(
                                (float)((float)(*olddir * *newdir) + (float)(v14 * v13))
                              + (float)(olddir[2] * newdir[2]))
                            / 3.1416)
                    * 25.0;
      goto LABEL_9;
    }
    v14 = olddir[1];
    v13 = newdir[1];
    if ( (float)(v13 - v14) != 0.0 || (float)(newdir[2] - olddir[2]) != 0.0 )
      goto LABEL_8;
  }
LABEL_9:
  v15.n64_u64[0] = vmax_f32(v4, v6).n64_u64[0];
  v11.n64_u32[0] = 1.0;
  v15.n64_f32[0] = v15.n64_f32[0] + v15.n64_f32[0];
  LODWORD(result) = vmin_f32(v15, v11).n64_u32[0];
  return result;
}
// 25E6F8: variable 'v5' is possibly undefined
// 25E6F8: variable 'v7' is possibly undefined
// 25E7BE: variable 'v4' is possibly undefined
// 25E7BE: variable 'v6' is possibly undefined

//----- (0025E7E4) --------------------------------------------------------
int __fastcall GetMovingHrtfCoeffs(
        const Hrtf *Hrtf,
        ALfloat elevation,
        ALfloat azimuth,
        ALfloat gain,
        ALfloat delta,
        ALint counter,
        ALfloat (*coeffs)[2],
        ALuint *delays,
        ALfloat (*coeffStep)[2],
        ALint *delayStep)
{
  float32x2_t v10; // d12
  int v12; // r4
  const ALubyte *azCount; // r5
  float v14; // s16
  unsigned int v15; // r6
  float v16; // s20
  unsigned int v17; // r9
  unsigned int v18; // r5
  float v19; // s22
  unsigned int v20; // r11
  float v21; // r0
  const ALushort *evOffset; // r1
  const ALubyte *v23; // r2
  float v24; // s8
  int v25; // r9
  float v26; // s10
  int v27; // r10
  float32x2_t v28; // d0
  float v29; // s12
  float v30; // s20
  float v31; // s22
  float v32; // s16
  float v33; // s18
  int v34; // r0
  int v35; // r9
  int v36; // r4
  __int64 v37; // kr00_8
  __int64 v38; // kr08_8
  float sampleRate; // s0
  const ALubyte *v40; // r5
  int v41; // r8
  int v42; // r6
  float v43; // s0
  float v44; // s2
  float *v45; // r1
  float *v46; // r2
  ALuint irSize; // r0
  float v48; // s6
  int v49; // r11
  int v50; // r10
  int v51; // r12
  int v52; // lr
  int v53; // r0
  int v54; // r3
  float v55; // s4
  const ALshort *v56; // r6
  float v57; // s3
  float v58; // s12
  float v59; // s10
  float v60; // s8
  const ALshort *v61; // r4
  int v62; // s5
  int v63; // s7
  int v64; // r5
  int v65; // r4
  float v66; // s8
  int v67; // r3
  float v68; // s4
  float *v69; // r6
  ALfloat *v70; // r5
  float v71; // s6
  float v72; // s10
  float v73; // s8
  float v74; // s12
  int v76; // [sp+8h] [bp-80h]
  int v77; // [sp+Ch] [bp-7Ch]
  int v78; // [sp+10h] [bp-78h]
  float v79; // [sp+14h] [bp-74h]
  ALuint v80; // [sp+14h] [bp-74h]
  unsigned int v81; // [sp+18h] [bp-70h]
  int v82; // [sp+18h] [bp-70h]
  unsigned int v83; // [sp+1Ch] [bp-6Ch]
  int v84; // [sp+1Ch] [bp-6Ch]
  int v86; // [sp+20h] [bp-68h]
  unsigned int v87; // [sp+24h] [bp-64h]
  const Hrtf *v88; // [sp+24h] [bp-64h]

  v12 = Hrtf->evCount - 1;
  azCount = Hrtf->azCount;
  v14 = (float)((float)(elevation + 1.5708) * (float)v12) / 3.1416;
  v10.n64_f32[0] = azimuth + 6.2832;
  v15 = azCount[v14];
  v16 = (float)((float)(azimuth + 6.2832) * (float)v15) / 6.2832;
  v83 = (int)v16 % v15;
  v81 = (v83 + 1) % v15;
  v17 = (int)v14 + 1;
  v79 = floorf(v16);
  if ( v17 > v12 )
    v17 = v12;
  v18 = azCount[v17];
  v19 = (float)(v10.n64_f32[0] * (float)v18) / 6.2832;
  v20 = (int)v19 % v18;
  v87 = (v20 + 1) % v18;
  v21 = floorf(v19);
  evOffset = Hrtf->evOffset;
  v23 = Hrtf->delays;
  v10.n64_u32[0] = 1.0;
  v24 = v19 - v21;
  v25 = evOffset[v17];
  v78 = v87 + v25;
  v26 = v16 - v79;
  v77 = v20 + v25;
  v27 = evOffset[v14];
  v28.n64_f32[1] = 1.0 - (float)(v16 - v79);
  v76 = v83 + v27;
  v29 = v14 - (float)(unsigned int)(int)v14;
  v30 = v29 * (float)(1.0 - (float)(v19 - v21));
  v31 = v29 * (float)(v19 - v21);
  v32 = v26 * (float)(1.0 - v29);
  v33 = v28.n64_f32[1] * (float)(1.0 - v29);
  v80 = (int)(float)((float)((float)((float)((float)(v33 * (float)v23[v83 + v27]) + (float)(v32 * (float)v23[v81 + v27]))
                                   + (float)(v30 * (float)v23[v20 + v25]))
                           + (float)((float)(v29 * v24) * (float)v23[v87 + v25]))
                   + 0.5) << 20;
  v34 = (v18 - v87) % v18 + v25;
  v35 = v25 + (v18 - v20) % v18;
  v36 = (v15 - v81) % v15 + v27;
  v37 = *(_QWORD *)delayStep;
  v38 = *(_QWORD *)delays;
  sampleRate = (float)Hrtf->sampleRate;
  *delays = v80;
  v88 = Hrtf;
  v40 = Hrtf->delays;
  v41 = v34;
  v42 = (v15 - v83) % v15 + v27;
  delays[1] = (int)(float)((float)((float)((float)((float)(v33 * (float)v40[v42]) + (float)(v32 * (float)v40[v36]))
                                         + (float)(v30 * (float)v40[v35]))
                                 + (float)(v31 * (float)v40[v34]))
                         + 0.5) << 20;
  v28.n64_u32[0] = floorf((float)((float)(sampleRate * 0.015) * delta) + 0.5);
  v43 = vmax_f32(v28, v10).n64_f32[0];
  v44 = 1.0 / v43;
  *delayStep = (int)(float)((float)(1.0 / v43) * (float)((float)v80 - (float)(unsigned int)(v38 - v37 * counter)));
  delayStep[1] = (int)(float)((float)(1.0 / v43)
                            * (float)((float)delays[1] - (float)(unsigned int)(HIDWORD(v38) - HIDWORD(v37) * counter)));
  if ( gain <= 0.0001 )
  {
    v67 = 0;
    v68 = (float)counter;
    do
    {
      v69 = &(*coeffStep)[v67];
      v70 = &(*coeffs)[v67];
      v71 = (*coeffStep)[v67] * v68;
      v72 = (*coeffs)[v67];
      v73 = (*coeffStep)[v67 + 1] * v68;
      v74 = (*coeffs)[v67 + 1];
      (*coeffs)[v67] = 0.0;
      v67 += 2;
      v70[1] = 0.0;
      *v69 = -(float)(v44 * (float)(v72 - v71));
      v69[1] = -(float)(v44 * (float)(v74 - v73));
    }
    while ( v67 != 256 );
  }
  else
  {
    v45 = &(*coeffStep)[1];
    v46 = &(*coeffs)[1];
    irSize = v88->irSize;
    v48 = gain * 0.000030519;
    v86 = irSize * v36;
    v49 = irSize * (v81 + v27);
    v84 = v42 * irSize;
    v82 = irSize * v78;
    v50 = v77 * irSize;
    v51 = irSize * v76;
    v52 = irSize * v35;
    v53 = irSize * v41;
    v54 = 0;
    v55 = (float)counter;
    do
    {
      v56 = v88->coeffs;
      v57 = *v45;
      v58 = *v46;
      v59 = *(v46 - 1) - (float)(*(v45 - 1) * v55);
      v60 = v48
          * (float)((float)((float)((float)(v33 * (float)v56[v51 + v54]) + (float)(v32 * (float)v56[v49 + v54]))
                          + (float)(v30 * (float)v56[v50 + v54]))
                  + (float)(v31 * (float)v56[v82 + v54]));
      *(v46 - 1) = v60;
      v61 = v88->coeffs;
      v62 = v61[v86 + v54];
      v63 = v61[v84 + v54];
      v64 = v61[v52 + v54];
      v65 = v61[v53 + v54++];
      *v46 = v48
           * (float)((float)((float)((float)(v33 * (float)v63) + (float)(v32 * (float)v62)) + (float)(v30 * (float)v64))
                   + (float)(v31 * (float)v65));
      *(v45 - 1) = v44 * (float)(v60 - v59);
      v66 = *v46;
      v46 += 2;
      *v45 = v44 * (float)(v66 - (float)(v58 - (float)(v57 * v55)));
      v45 += 2;
    }
    while ( v54 != 128 );
  }
  return (int)v43;
}
// 25EA60: variable 'v10' is possibly undefined

//----- (0025ECA8) --------------------------------------------------------
ALvoid __fastcall MixSource(ALsource_0 *Source, ALCdevice *Device, ALuint SamplesToDo)
{
  unsigned int Step; // r12
  volatile ALenum state; // r0
  ALuint position; // r4
  ALuint position_fraction; // r6
  ALuint BuffersPlayed; // r8
  Resampler Resampler; // r1
  ALbufferlistitem_0 *queue; // r3
  ALuint v11; // r2
  ALuint v12; // r3
  ALuint v13; // r2
  unsigned int v14; // r11
  unsigned int v15; // r1
  ALuint v16; // lr
  ALuint v17; // r8
  unsigned int v18; // r3
  ALuint v19; // r1
  int v20; // r0
  unsigned int v21; // r3
  ALbufferlistitem_0 *v22; // r5
  char *v23; // r4
  char *data; // r12
  unsigned int v25; // r1
  unsigned int v26; // r0
  unsigned int v27; // r6
  unsigned int v28; // r3
  int v29; // r2
  FmtType v30; // r1
  char *v31; // r2
  float *v32; // r3
  unsigned int v33; // r1
  int v34; // r4
  char *v35; // r2
  ALfloat *v36; // r3
  unsigned int v37; // r1
  int v38; // r4
  char *v39; // r2
  float *v40; // r3
  unsigned int v41; // r1
  unsigned int v42; // r3
  unsigned int v43; // r0
  unsigned int v44; // r6
  FILTER *p_iirFilter; // r11
  char *v46; // r12
  FmtType v47; // r1
  unsigned int v48; // r2
  float *v49; // r3
  char *v50; // r1
  int v51; // r4
  int *v52; // r3
  ALfloat *v53; // r2
  unsigned int v54; // r1
  int v55; // r4
  unsigned int v56; // r2
  float *v57; // r3
  __int16 *v58; // r1
  ALuint v59; // r4
  ALuint v60; // r12
  ALuint v61; // r2
  unsigned int v62; // r11
  ALbufferlistitem_0 *v63; // r0
  ALbuffer *buffer; // r6
  unsigned int LoopEnd; // r11
  unsigned int LoopStart; // r5
  int v67; // r5
  unsigned int v68; // r0
  ALuint v69; // r3
  int v70; // r2
  FmtType FmtType; // r1
  unsigned int v72; // r3
  unsigned int v73; // r6
  char *v74; // r2
  float *v75; // r3
  unsigned int v76; // r1
  int v77; // r4
  char *v78; // r2
  ALfloat *v79; // r3
  unsigned int v80; // r1
  int v81; // r4
  char *v82; // r2
  float *v83; // r3
  unsigned int v84; // r1
  unsigned int v85; // r0
  unsigned int SampleLen; // r0
  ALbufferlistitem_0 *v87; // r4
  ALbufferlistitem_0 *prev; // r1
  bool v89; // zf
  unsigned int i; // r0
  ALbuffer *v91; // r1
  unsigned int v92; // r3
  int v93; // r6
  char *v94; // r12
  FmtType v95; // r1
  unsigned int v96; // r4
  unsigned int v97; // r2
  char *v98; // r2
  float *v99; // r3
  unsigned int v100; // r1
  int v101; // r6
  int *v102; // r2
  ALfloat *v103; // r3
  unsigned int v104; // r1
  int v105; // r6
  char *v106; // r2
  float *v107; // r3
  unsigned int v108; // r1
  float coeff; // s2
  float *v110; // r1
  float *v111; // r0
  float v112; // s4
  float v113; // s0
  ALCdevice *v114; // r2
  ALuint v115; // r1
  float v116; // s6
  float v117; // s4
  ALuint v118; // r0
  ALuint NumAuxSends; // r0
  ALuint j; // r6
  char *v121; // r1
  const SendParams *v122; // r0
  float *v123; // r1
  float *v124; // r2
  float v125; // s0
  float v126; // s2
  float v127; // s4
  ALCdevice *v128; // r4
  float *v129; // r2
  ALuint v130; // r3
  float v131; // s6
  float v132; // s4
  ALuint v133; // r1
  ALuint k; // r0
  ALuint v135; // r6
  ALbuffer *v136; // r2
  ALuint v137; // r1
  ALuint v138; // r0
  ALsizei v139; // r11
  int v140; // r1
  ALuint Counter; // r0
  ALuint v142; // r0
  int v143; // [sp+8h] [bp-C8h]
  unsigned int v144; // [sp+10h] [bp-C0h]
  ALuint v145; // [sp+14h] [bp-BCh]
  volatile ALenum v146; // [sp+18h] [bp-B8h]
  size_t v147; // [sp+20h] [bp-B0h]
  ALuint v148; // [sp+24h] [bp-ACh]
  unsigned int v149; // [sp+28h] [bp-A8h]
  ALuint v150; // [sp+2Ch] [bp-A4h]
  unsigned int v151; // [sp+30h] [bp-A0h]
  _BOOL4 v152; // [sp+34h] [bp-9Ch]
  char *v153; // [sp+38h] [bp-98h]
  unsigned int v154; // [sp+3Ch] [bp-94h]
  ALbufferlistitem_0 *v155; // [sp+54h] [bp-7Ch]
  ALuint v156; // [sp+58h] [bp-78h]
  ALuint SampleSize; // [sp+5Ch] [bp-74h]
  ALuint v158; // [sp+60h] [bp-70h]
  ALuint v159; // [sp+64h] [bp-6Ch]
  ALbuffer *v160; // [sp+68h] [bp-68h]
  int Looping; // [sp+6Ch] [bp-64h]
  ALuint v162; // [sp+70h] [bp-60h]
  unsigned int v163; // [sp+74h] [bp-5Ch]
  ALuint NumChannels; // [sp+7Ch] [bp-54h]
  ALfloat *SampleData2; // [sp+84h] [bp-4Ch]
  ALuint v167; // [sp+88h] [bp-48h]
  ALuint v168; // [sp+88h] [bp-48h]
  ALuint v169; // [sp+8Ch] [bp-44h]
  ALfloat *SampleData1; // [sp+90h] [bp-40h]
  int v172; // [sp+98h] [bp-38h]
  int v173; // [sp+9Ch] [bp-34h]

  Step = Source->Params.Step;
  state = Source->state;
  position_fraction = Source->position_fraction;
  position = Source->position;
  BuffersPlayed = Source->BuffersPlayed;
  if ( Step == 0x4000 )
    Resampler = PointResampler;
  else
    Resampler = Source->Resampler;
  queue = Source->queue;
  NumChannels = Source->NumChannels;
  SampleSize = Source->SampleSize;
  Looping = Source->Looping;
  if ( BuffersPlayed )
  {
    v11 = Source->BuffersPlayed;
    do
    {
      queue = queue->next;
      --v11;
    }
    while ( v11 );
  }
  v155 = queue;
  v154 = ResamplerPrePadding[Resampler];
  v156 = Step;
  v144 = ResamplerPadding[Resampler] + v154;
  v172 = 4 * NumChannels;
  v173 = 2 * NumChannels;
  SampleData2 = Device->SampleData2;
  v12 = 0;
  v143 = -(Step - 1 < Step);
  v13 = SamplesToDo;
  SampleData1 = Device->SampleData1;
  do
  {
    v167 = v12;
    v145 = BuffersPlayed;
    v146 = state;
    v14 = (((v13 - v12 + 1) * (unsigned __int64)v156 + position_fraction + 0x3FFF) >> 14) + v144;
    v15 = (((v13 - v12 + 1) * (unsigned __int64)v156 + position_fraction + 0x3FFF) >> 14) + v144 < 0x800;
    if ( (((v13 - v12 + 1) * (unsigned __int64)v156 + position_fraction + 0x3FFF) >> 14) + v144 >= 0x800 )
      v14 = 2048;
    else
      v15 = ((((v13 - v12 + 1) * (unsigned __int64)v156 + position_fraction + 0x3FFF) >> 14) + v144) >> 32;
    v16 = (__int64)(__PAIR64__(v143, -1) - position_fraction + ((__PAIR64__(v15, v14) - v144) << 14)) / v156;
    if ( v13 - v12 < v16 )
      v16 = v13 - v12;
    if ( v12 + v16 < SamplesToDo )
      v16 &= 0xFFFFFFFC;
    v17 = NumChannels;
    if ( NumChannels )
    {
      v162 = 0;
      v18 = v14;
      v151 = v154 - position;
      if ( v154 - position < v14 )
        v18 = v154 - position;
      v152 = position >= v154 || v18 == 0;
      v19 = 0;
      v150 = position - v154;
      if ( position >= v154 )
        v19 = position - v154;
      v20 = 4 * v18;
      v148 = v19;
      v149 = v18;
      v21 = v14;
      v147 = v20;
      v158 = position;
      v159 = position_fraction;
      v22 = v155;
      v169 = v16;
      v163 = v14;
      while ( 1 )
      {
        if ( Source->SourceType == 4136 )
        {
          buffer = Source->queue->buffer;
          data = (char *)buffer->data;
          if ( !(Looping << 24) || (LoopEnd = buffer->LoopEnd, v158 >= LoopEnd) )
          {
            v153 = (char *)buffer->data;
            if ( v152 )
            {
              v68 = 0;
              v69 = v148;
            }
            else
            {
              memset(SampleData1, 0, v147);
              v68 = v149;
              v69 = 0;
            }
            v70 = v69 * v17;
            FmtType = buffer->FmtType;
            v72 = buffer->SampleLen - v69;
            p_iirFilter = &Source->Params.Direct.iirFilter;
            v73 = v163 - v68;
            if ( v163 - v68 > v72 )
              v73 = v72;
            v60 = v159;
            if ( FmtType == FmtFloat )
            {
              if ( v73 )
              {
                v78 = &v153[SampleSize * (v162 + v70)];
                v79 = &SampleData1[v68];
                v80 = v73;
                do
                {
                  --v80;
                  v81 = *(_DWORD *)v78;
                  v78 += v172;
                  *(_DWORD *)v79++ = v81;
                }
                while ( v80 );
              }
            }
            else if ( FmtType == FmtShort )
            {
              if ( v73 )
              {
                v82 = &v153[SampleSize * (v162 + v70)];
                v83 = &SampleData1[v68];
                v84 = v73;
                do
                {
                  --v84;
                  *v83++ = (float)*(__int16 *)v82 * 0.000030519;
                  v82 += v173;
                }
                while ( v84 );
              }
            }
            else if ( FmtType == FmtByte && v73 )
            {
              v74 = &v153[SampleSize * (v162 + v70)];
              v75 = &SampleData1[v68];
              v76 = v73;
              do
              {
                v77 = *v74;
                v74 += v17;
                --v76;
                *v75++ = (float)v77 * 0.007874;
              }
              while ( v76 );
            }
            v85 = v68 + v73;
            if ( v163 != v85 )
            {
              memset(&Device->SampleData1[v85], 0, 4 * (v163 - v85));
              v60 = v159;
            }
            v59 = SamplesToDo;
            Looping = 0;
            v16 = v169;
            goto LABEL_144;
          }
          LoopStart = buffer->LoopStart;
          v160 = Source->queue->buffer;
          if ( v158 >= LoopStart )
          {
            for ( i = v158 - LoopStart; i < v154; i += LoopEnd - LoopStart )
              ;
            v25 = LoopStart - v154 + i;
            v26 = 0;
          }
          else if ( v152 )
          {
            v26 = 0;
            v25 = v148;
          }
          else
          {
            v23 = (char *)buffer->data;
            memset(SampleData1, 0, v147);
            v21 = v163;
            data = v23;
            v16 = v169;
            v25 = 0;
            v26 = v149;
          }
          v27 = v21 - v26;
          v28 = LoopEnd - v25;
          v29 = v25 * v17;
          v30 = v160->FmtType;
          if ( v27 > v28 )
            v27 = v28;
          if ( v30 == FmtFloat )
          {
            if ( v27 )
            {
              v35 = &data[SampleSize * (v162 + v29)];
              v36 = &SampleData1[v26];
              v37 = v27;
              do
              {
                --v37;
                v38 = *(_DWORD *)v35;
                v35 += v172;
                *(_DWORD *)v36++ = v38;
              }
              while ( v37 );
            }
          }
          else if ( v30 == FmtShort )
          {
            if ( v27 )
            {
              v39 = &data[SampleSize * (v162 + v29)];
              v40 = &SampleData1[v26];
              v41 = v27;
              do
              {
                --v41;
                *v40++ = (float)*(__int16 *)v39 * 0.000030519;
                v39 += v173;
              }
              while ( v41 );
            }
          }
          else if ( v30 == FmtByte && v27 )
          {
            v31 = &data[SampleSize * (v162 + v29)];
            v32 = &SampleData1[v26];
            v33 = v27;
            do
            {
              v34 = *v31;
              v31 += v17;
              --v33;
              *v32++ = (float)v34 * 0.007874;
            }
            while ( v33 );
          }
          v42 = v163;
          v43 = v26 + v27;
          if ( v43 < v163 )
          {
            v44 = LoopEnd - LoopStart;
            p_iirFilter = &Source->Params.Direct.iirFilter;
            v46 = &data[SampleSize * (v162 + LoopStart * v17)];
            do
            {
              v47 = v160->FmtType;
              if ( v42 - v43 <= v44 )
                v44 = v42 - v43;
              if ( v47 == FmtFloat )
              {
                if ( v44 )
                {
                  v52 = (int *)v46;
                  v53 = &SampleData1[v43];
                  v54 = v44;
                  do
                  {
                    --v54;
                    v55 = *v52;
                    v52 = (int *)((char *)v52 + v172);
                    *(_DWORD *)v53++ = v55;
                  }
                  while ( v54 );
                }
              }
              else if ( v47 == FmtShort )
              {
                if ( v44 )
                {
                  v56 = v44;
                  v57 = &SampleData1[v43];
                  v58 = (__int16 *)v46;
                  do
                  {
                    --v56;
                    *v57++ = (float)*v58 * 0.000030519;
                    v58 = (__int16 *)((char *)v58 + v173);
                  }
                  while ( v56 );
                }
              }
              else if ( v47 == FmtByte && v44 )
              {
                v48 = v44;
                v49 = &SampleData1[v43];
                v50 = v46;
                do
                {
                  v51 = *v50;
                  v50 += v17;
                  --v48;
                  *v49++ = (float)v51 * 0.007874;
                }
                while ( v48 );
              }
              v42 = v163;
              v43 += v44;
              v59 = SamplesToDo;
            }
            while ( v43 < v163 );
            v60 = v159;
            goto LABEL_144;
          }
          v60 = v159;
          v59 = SamplesToDo;
        }
        else
        {
          if ( position < v154 )
          {
            v63 = v22;
            v62 = v151;
            v67 = Looping;
            while ( 1 )
            {
              v87 = v63;
              do
              {
                if ( !v62 )
                {
                  v62 = 0;
                  goto LABEL_111;
                }
                prev = v87->prev;
                v89 = Looping << 24 == 0;
                if ( !(Looping << 24) )
                  v89 = prev == 0;
                if ( v89 )
                {
                  if ( v62 >= v21 )
                    v62 = v21;
                  if ( v62 )
                  {
                    memset(SampleData1, 0, 4 * v62);
                    v21 = v163;
                    v61 = 0;
                    v16 = v169;
                    v63 = v87;
                    goto LABEL_112;
                  }
                  v62 = 0;
                  v63 = v87;
LABEL_111:
                  v61 = 0;
                  goto LABEL_112;
                }
                if ( !prev )
                {
                  do
                  {
                    prev = v87;
                    v87 = v87->next;
                  }
                  while ( v87 );
                }
                v87 = prev;
              }
              while ( !prev->buffer );
              SampleLen = prev->buffer->SampleLen;
              if ( v62 < SampleLen )
              {
                v61 = SampleLen - v62;
                v62 = 0;
                v63 = prev;
LABEL_112:
                v59 = SamplesToDo;
                goto LABEL_114;
              }
              v62 -= SampleLen;
              v63 = prev;
            }
          }
          v63 = v22;
          v62 = 0;
          v61 = v150;
          v59 = SamplesToDo;
          v67 = Looping;
LABEL_114:
          while ( v62 < v21 && v63 )
          {
            v91 = v63->buffer;
            if ( v63->buffer )
            {
              v92 = v91->SampleLen;
              if ( v92 <= v61 )
              {
                v61 -= v92;
              }
              else
              {
                v93 = v61 * v17;
                v94 = (char *)v91->data;
                v95 = v91->FmtType;
                v96 = v163 - v62;
                v97 = v92 - v61;
                if ( v163 - v62 > v97 )
                  v96 = v97;
                if ( v95 == FmtFloat )
                {
                  if ( v96 )
                  {
                    v102 = (int *)&v94[SampleSize * (v162 + v93)];
                    v103 = &SampleData1[v62];
                    v104 = v96;
                    do
                    {
                      --v104;
                      v105 = *v102;
                      v102 = (int *)((char *)v102 + v172);
                      *(_DWORD *)v103++ = v105;
                    }
                    while ( v104 );
                  }
                }
                else if ( v95 == FmtShort )
                {
                  if ( v96 )
                  {
                    v106 = &v94[SampleSize * (v162 + v93)];
                    v107 = &SampleData1[v62];
                    v108 = v96;
                    do
                    {
                      --v108;
                      *v107++ = (float)*(__int16 *)v106 * 0.000030519;
                      v106 += v173;
                    }
                    while ( v108 );
                  }
                }
                else if ( v95 == FmtByte && v96 )
                {
                  v98 = &v94[SampleSize * (v162 + v93)];
                  v99 = &SampleData1[v62];
                  v100 = v96;
                  do
                  {
                    v101 = *v98;
                    v98 += v17;
                    --v100;
                    *v99++ = (float)v101 * 0.007874;
                  }
                  while ( v100 );
                }
                v62 += v96;
                v59 = SamplesToDo;
                v67 = Looping;
                v61 = 0;
              }
              v21 = v163;
            }
            v63 = v63->next;
            if ( v67 << 24 && !v63 )
            {
              v63 = Source->queue;
            }
            else if ( !v63 )
            {
              if ( v21 != v62 )
              {
                memset(&Device->SampleData1[v62], 0, 4 * (v21 - v62));
                v16 = v169;
              }
              break;
            }
          }
          v60 = v159;
        }
        p_iirFilter = &Source->Params.Direct.iirFilter;
LABEL_144:
        Source->Params.Resample(&Device->SampleData1[v154], v60, v156, SampleData2, v16);
        coeff = p_iirFilter->coeff;
        v110 = (float *)(&Source->Pitch + 2 * v162);
        v111 = v110 + 5626;
        v112 = *SampleData2 + (float)(p_iirFilter->coeff * (float)(v110[5626] - *SampleData2));
        v113 = v110[5627];
        if ( v169 )
        {
          v114 = Device;
          v115 = v169;
          do
          {
            v116 = v112;
            --v115;
            v113 = v112 + (float)(coeff * (float)(v113 - v112));
            v111[1] = v113;
            v117 = v114->SampleData2[1];
            v114->SampleData1[0] = v113;
            v114 = (ALCdevice *)((char *)v114 + 4);
            coeff = p_iirFilter->coeff;
            v112 = v117 + (float)(p_iirFilter->coeff * (float)(v116 - v117));
          }
          while ( v115 );
          *v111 = v116;
          v118 = v169;
        }
        else
        {
          v118 = 0;
        }
        Device->SampleData1[v118] = v112 + (float)(coeff * (float)(v113 - v112));
        Source->Params.DryMix(&Source->Params.Direct, SampleData1, v162, v167, v59, v169);
        NumAuxSends = Device->NumAuxSends;
        if ( NumAuxSends )
        {
          for ( j = 0; j < NumAuxSends; ++j )
          {
            v121 = (char *)Source + 84 * j;
            if ( *((_DWORD *)v121 + 5644) )
            {
              v122 = (const SendParams *)(v121 + 22576);
              v123 = (float *)(v121 + 22584);
              v124 = &v123[2 * v162];
              v125 = v124[2];
              v126 = *v123;
              v127 = *SampleData2 + (float)(*v123 * (float)(v124[1] - *SampleData2));
              if ( v169 )
              {
                v128 = Device;
                v129 = v124 + 1;
                v130 = v169;
                do
                {
                  v131 = v127;
                  --v130;
                  v125 = v127 + (float)(v126 * (float)(v125 - v127));
                  v129[1] = v125;
                  v132 = v128->SampleData2[1];
                  v128->SampleData1[0] = v125;
                  v128 = (ALCdevice *)((char *)v128 + 4);
                  v126 = *v123;
                  v127 = v132 + (float)(*v123 * (float)(v131 - v132));
                }
                while ( v130 );
                *v129 = v131;
                v133 = v169;
                v59 = SamplesToDo;
              }
              else
              {
                v133 = 0;
              }
              Device->SampleData1[v133] = v127 + (float)(v126 * (float)(v125 - v127));
              Source->Params.WetMix(v122, SampleData1, v167, v59, v169);
              NumAuxSends = Device->NumAuxSends;
              v17 = NumChannels;
            }
          }
        }
        v89 = ++v162 == v17;
        position = v158;
        position_fraction = v159;
        v22 = v155;
        v16 = v169;
        v21 = v163;
        if ( v89 )
          goto LABEL_163;
      }
    }
    v22 = v155;
LABEL_163:
    for ( k = v16; k; position_fraction = v135 & 0x3FFF )
    {
      v135 = position_fraction + v156;
      --k;
      position += v135 >> 14;
    }
    BuffersPlayed = v145;
    v168 = v167 + v16;
    while ( 1 )
    {
      v136 = v22->buffer;
      if ( v22->buffer )
      {
        v137 = v136->LoopEnd;
        if ( v137 > position )
          goto LABEL_178;
        v138 = v136->SampleLen;
        v139 = v136->LoopStart;
      }
      else
      {
        v138 = 0;
        v139 = 0;
        v137 = 0;
      }
      if ( Looping << 24 && Source->SourceType == 4136 )
        break;
      if ( position < v138 )
        goto LABEL_178;
      v22 = v22->next;
      if ( v22 )
      {
        ++BuffersPlayed;
        position -= v138;
      }
      else
      {
        if ( !(Looping << 24) )
        {
          v140 = 0;
          v146 = 4116;
          position = 0;
          BuffersPlayed = Source->BuffersInQueue;
          position_fraction = 0;
          goto LABEL_184;
        }
        v22 = Source->queue;
        BuffersPlayed = 0;
        position -= v138;
      }
    }
    position = (position - v139) % (v137 - v139) + v139;
LABEL_178:
    state = 4114;
    v140 = 0;
    if ( v146 != 4114 )
    {
LABEL_184:
      v12 = v168;
      break;
    }
    v140 = 1;
    v13 = SamplesToDo;
    v12 = v168;
    v155 = v22;
  }
  while ( v168 < SamplesToDo );
  Source->Hrtf.Offset += v12;
  Source->BuffersPlayed = BuffersPlayed;
  Source->state = v146;
  Source->position = position;
  Source->position_fraction = position_fraction;
  if ( v140 )
  {
    Counter = Source->Hrtf.Counter;
    if ( Counter <= v12 )
      Counter = v12;
    v142 = Counter - v12;
  }
  else
  {
    v142 = 0;
    Source->Hrtf.Moving = 0;
  }
  Source->Hrtf.Counter = v142;
}

//----- (0025F5D0) --------------------------------------------------------
void __fastcall bs2b_cross_feed(bs2b *bs2b, float *sample)
{
  double a0_lo; // d16
  double b1_lo; // d17
  double a0_hi; // d18
  double a1_hi; // d19
  double v6; // d16
  double b1_hi; // d22
  double v8; // d17
  float v9; // s2
  float v10; // s0

  a0_lo = bs2b->a0_lo;
  b1_lo = bs2b->b1_lo;
  a0_hi = bs2b->a0_hi;
  a1_hi = bs2b->a1_hi;
  bs2b->last_sample.lo[0] = a0_lo * *sample + b1_lo * bs2b->last_sample.lo[0];
  v6 = a0_lo * sample[1] + b1_lo * bs2b->last_sample.lo[1];
  bs2b->last_sample.lo[1] = v6;
  b1_hi = bs2b->b1_hi;
  v8 = a0_hi * *sample + a1_hi * bs2b->last_sample.asis[0] + b1_hi * bs2b->last_sample.hi[0];
  bs2b->last_sample.hi[0] = v8;
  bs2b->last_sample.hi[1] = a0_hi * sample[1] + a1_hi * bs2b->last_sample.asis[1] + b1_hi * bs2b->last_sample.hi[1];
  v9 = v8 + v6;
  bs2b->last_sample.asis[0] = *sample;
  bs2b->last_sample.asis[1] = sample[1];
  *sample = v9;
  v10 = bs2b->last_sample.hi[1] + bs2b->last_sample.lo[0];
  sample[1] = v10;
  *sample = bs2b->gain * v9;
  sample[1] = bs2b->gain * v10;
}

//----- (0025F6B8) --------------------------------------------------------
jint __fastcall android_JNI_OnLoad(JavaVM *vm, void *reserved)
{
  if ( apportableOpenALFuncs.alc_android_set_java_vm )
    apportableOpenALFuncs.alc_android_set_java_vm(vm);
  javaVM = vm;
  return 65540;
}

//----- (0025F6E4) --------------------------------------------------------
void OpenAL_Android_Init()
{
  JavaVM_0 *JavaVM; // r0
  JavaVM *p_functions; // r4

  JavaVM = j_GetJavaVM();
  p_functions = &JavaVM->functions;
  javaVM = &JavaVM->functions;
  if ( apportableOpenALFuncs.alc_android_set_java_vm )
    apportableOpenALFuncs.alc_android_set_java_vm((JavaVM *)JavaVM);
  javaVM = p_functions;
}

//----- (0025F720) --------------------------------------------------------
JavaVM *alcGetJavaVM()
{
  JavaVM *p_functions; // r4
  JavaVM_0 *JavaVM; // r0

  p_functions = javaVM;
  if ( !javaVM )
  {
    JavaVM = j_GetJavaVM();
    p_functions = &JavaVM->functions;
    javaVM = &JavaVM->functions;
    if ( apportableOpenALFuncs.alc_android_set_java_vm )
      apportableOpenALFuncs.alc_android_set_java_vm((JavaVM *)JavaVM);
    javaVM = p_functions;
  }
  return p_functions;
}

//----- (0025F76C) --------------------------------------------------------
void __fastcall JNI_OnUnload(JavaVM *vm, void *reserved)
{
  if ( apportableOpenALFuncs.alc_android_set_java_vm )
    apportableOpenALFuncs.alc_android_set_java_vm(0);
}

//----- (0025F784) --------------------------------------------------------
void alcSuspend()
{
  if ( apportableOpenALFuncs.alc_android_suspend )
    apportableOpenALFuncs.alc_android_suspend();
}
// A98FCC: invalid function type has been ignored

//----- (0025F798) --------------------------------------------------------
void alcResume()
{
  if ( apportableOpenALFuncs.alc_android_resume )
    apportableOpenALFuncs.alc_android_resume();
}
// A98FD0: invalid function type has been ignored

//----- (0025F7B0) --------------------------------------------------------
void __fastcall bs2b_set_level(bs2b *bs2b, int level)
{
  int srate; // r0
  unsigned int v4; // r1
  double v5; // d16
  double v6; // d9
  double v7; // d8
  double v8; // d10
  double v9; // d11
  double v10; // r0
  double v11; // r0
  double v12; // d17
  float v13; // s2

  if ( bs2b->level != level )
  {
    srate = bs2b->srate;
    bs2b->level = level;
    v4 = level - 1;
    if ( (unsigned int)(srate - 2000) >= 0x2E631 )
    {
      srate = 44100;
      bs2b->srate = 44100;
    }
    if ( v4 >= 5 )
    {
      v5 = -4398.22972;
      v7 = 0.205671765;
      v6 = 0.398107171;
      v8 = -6126.10567;
      bs2b->level = 6;
    }
    else
    {
      v5 = dbl_60A370[v4];
      v6 = dbl_60A310[v4];
      v7 = dbl_60A340[v4];
      v8 = dbl_60A2E0[v4];
    }
    v9 = (double)srate;
    v10 = exp(v5 / (double)srate);
    bs2b->a0_lo = v6 * (1.0 - v10);
    bs2b->b1_lo = v10;
    v11 = exp(v8 / v9);
    v12 = v11;
    HIDWORD(v11) ^= 0x80000000;
    v13 = v6 + 1.0 - v7;
    bs2b->gain = 1.0 / v13;
    bs2b->a0_hi = 1.0 - v7 * (1.0 - v12);
    bs2b->a1_hi = v11;
    bs2b->b1_hi = v12;
  }
}
// 60A2E0: using guessed type double dbl_60A2E0[6];
// 60A310: using guessed type double dbl_60A310[6];
// 60A340: using guessed type double dbl_60A340[6];
// 60A370: using guessed type double dbl_60A370[6];

//----- (0025F8D8) --------------------------------------------------------
int __fastcall bs2b_get_level(bs2b *bs2b)
{
  return bs2b->level;
}

//----- (0025F8E0) --------------------------------------------------------
void __fastcall bs2b_set_srate(bs2b *bs2b, int srate)
{
  int v3; // r2
  unsigned int v4; // r3
  double v5; // d16
  double v6; // d9
  double v7; // d8
  double v8; // d10
  double v9; // d11
  double v10; // r0
  double v11; // r0
  double v12; // d17
  float v13; // s2

  if ( bs2b->srate != srate )
  {
    v3 = srate;
    v4 = bs2b->level - 1;
    if ( srate - 2000 > (unsigned int)&stru_2E62C.st_value )
      v3 = 44100;
    bs2b->srate = v3;
    if ( v4 >= 5 )
    {
      v5 = -4398.22972;
      v7 = 0.205671765;
      v6 = 0.398107171;
      v8 = -6126.10567;
      bs2b->level = 6;
    }
    else
    {
      v5 = dbl_60A370[v4];
      v6 = dbl_60A310[v4];
      v7 = dbl_60A340[v4];
      v8 = dbl_60A2E0[v4];
    }
    v9 = (double)srate;
    if ( srate - 2000 > (unsigned int)&stru_2E62C.st_value )
      v9 = 44100.0;
    v10 = exp(v5 / v9);
    bs2b->a0_lo = v6 * (1.0 - v10);
    bs2b->b1_lo = v10;
    v11 = exp(v8 / v9);
    v12 = v11;
    HIDWORD(v11) ^= 0x80000000;
    v13 = v6 + 1.0 - v7;
    bs2b->gain = 1.0 / v13;
    bs2b->a0_hi = 1.0 - v7 * (1.0 - v12);
    bs2b->a1_hi = v11;
    bs2b->b1_hi = v12;
  }
}
// 2E62C: using guessed type Elf32_Sym stru_2E62C;
// 60A2E0: using guessed type double dbl_60A2E0[6];
// 60A310: using guessed type double dbl_60A310[6];
// 60A340: using guessed type double dbl_60A340[6];
// 60A370: using guessed type double dbl_60A370[6];

//----- (0025FA28) --------------------------------------------------------
int __fastcall bs2b_get_srate(bs2b *bs2b)
{
  return bs2b->srate;
}

//----- (0025FA2C) --------------------------------------------------------
void __fastcall bs2b_clear(bs2b *bs2b)
{
  double *lo; // r1
  t_last_sample *p_last_sample; // r0

  bs2b->last_sample.hi[0] = 0.0;
  bs2b->last_sample.hi[1] = 0.0;
  lo = bs2b->last_sample.lo;
  p_last_sample = &bs2b->last_sample;
  *lo = 0.0;
  lo[1] = 0.0;
  p_last_sample->asis[0] = 0.0;
  p_last_sample->asis[1] = 0.0;
}

//----- (0025FA48) --------------------------------------------------------
ALCboolean __fastcall alc_null_init(BackendFuncs *func_list)
{
  void (**p_StopPlayback)(ALCdevice *); // r0

  *(_QWORD *)&func_list->StopCapture = *(_QWORD *)&null_funcs.StopCapture;
  *(_QWORD *)&func_list->AvailableSamples = *(_QWORD *)&null_funcs.AvailableSamples;
  *(_QWORD *)&func_list->Unlock = *(_QWORD *)&null_funcs.Unlock;
  *(_QWORD *)&func_list->OpenPlayback = *(_QWORD *)&null_funcs.OpenPlayback;
  *(_QWORD *)&func_list->ResetPlayback = *(_QWORD *)&null_funcs.ResetPlayback;
  p_StopPlayback = &func_list->StopPlayback;
  *(_QWORD *)p_StopPlayback = *(_QWORD *)&null_funcs.StopPlayback;
  *((_QWORD *)p_StopPlayback + 1) = *(_QWORD *)&null_funcs.CloseCapture;
  return 1;
}

//----- (0025FA84) --------------------------------------------------------
void __fastcall alc_null_probe(DevProbe type)
{
  ALCchar *v1; // r0
  size_t v2; // r2

  if ( type == ALL_DEVICE_PROBE )
  {
    v1 = (ALCchar *)realloc(alcAllDevicesList, alcAllDevicesListSize + 11);
    if ( v1 )
    {
      v2 = alcAllDevicesListSize;
      alcAllDevicesList = v1;
      strcpy((char *)&v1[alcAllDevicesListSize], "No Output");
      alcAllDevicesListSize = v2 + 10;
      v1[v2 + 10] = 0;
    }
    else if ( LogLevel_0 )
    {
      al_print("(EE)", "AppendList", "Realloc failed to add %s!\n", (const char *)nullDevice);
    }
  }
}

//----- (0025FB30) --------------------------------------------------------
ALvoid __fastcall aluInitPanning(ALCdevice *Device)
{
  ALfloat *SpeakerAngle; // r6
  DevFmtChannels FmtChans; // r0
  Channel *Speaker2Chan; // r5
  __int64 v5; // d16
  const char *v6; // r10
  unsigned __int64 v7; // d18
  Channel v8; // r0
  int v9; // s0
  int v10; // r0
  int v11; // r5
  signed int NumChan; // r11
  const MOB_ConfigKeyValue *keyValues; // r0
  MOB_ConfigKey v15; // r1
  MOB_ConfigKey v16; // t1
  MOB_ConfigKey key; // r1
  MOB_ConfigKey v18; // t1
  const char *v19; // r9
  const char *v20; // r8
  char *v21; // r0
  int v22; // t1
  int v23; // r0
  char *v24; // r0
  const char *v25; // r10
  bool v26; // zf
  const char *v27; // r5
  char *v28; // r4
  int v29; // t1
  int v30; // r0
  int v31; // r6
  int v32; // t1
  float *v33; // r5
  signed int v34; // r0
  int v35; // r0
  float *v36; // r6
  signed int v37; // r12
  signed int v38; // r2
  float *v39; // r0
  signed int v40; // r1
  signed int v41; // r3
  float v42; // s0
  float v43; // r0
  Channel v44; // r0
  const char *v45; // [sp+Ch] [bp-4Ch]
  ALCdevice *v46; // [sp+14h] [bp-44h]
  unsigned __int8 *v47; // [sp+18h] [bp-40h]
  Channel *v48; // [sp+20h] [bp-38h]
  float *v49; // [sp+24h] [bp-34h]

  SpeakerAngle = Device->SpeakerAngle;
  FmtChans = Device->FmtChans;
  Speaker2Chan = Device->Speaker2Chan;
  switch ( FmtChans )
  {
    case DevFmtMono:
      Device->Speaker2Chan[0] = FrontCenter;
      Device->NumChan = 1;
      Device->SpeakerAngle[0] = 0.0;
      return;
    case DevFmtStereo:
      Device->NumChan = 2;
      v10 = 1;
      Device->Speaker2Chan[0] = FrontLeft;
      Device->Speaker2Chan[1] = FrontRight;
      v6 = "layout_stereo";
      v9 = 1070141403;
      Device->SpeakerAngle[0] = -1.5708;
      goto LABEL_11;
    case DevFmtMono|0x2:
      return;
    case DevFmtQuad:
      Device->NumChan = 4;
      *(_QWORD *)Speaker2Chan = 4LL;
      *(_QWORD *)&Device->Speaker2Chan[2] = 0x500000001LL;
      v6 = "layout_quad";
      Device->SpeakerAngle[0] = -2.3562;
      Device->SpeakerAngle[1] = -0.7854;
      v10 = 3;
      v9 = 1075235812;
      Device->SpeakerAngle[2] = 0.7854;
      goto LABEL_11;
    case DevFmtX51:
      v5 = 4LL;
      v6 = "layout_surround51";
      v7 = 0xBF060A92BFF5BE0BLL;
      v8 = BackRight;
      v9 = 1073069579;
      Device->NumChan = 5;
      goto LABEL_8;
    case DevFmtX61:
      v6 = "layout_surround61";
      Device->NumChan = 6;
      *(_QWORD *)Speaker2Chan = 7LL;
      *(_QWORD *)&Device->Speaker2Chan[2] = 0x100000002LL;
      Device->Speaker2Chan[4] = SideRight;
      Device->Speaker2Chan[5] = BackCenter;
      *(_QWORD *)SpeakerAngle = 0xBF060A92BFC90FDBLL;
      *((_QWORD *)SpeakerAngle + 1) = 0x3F060A9200000000LL;
      Device->SpeakerAngle[4] = 1.5708;
      v10 = 5;
      v9 = 1078530011;
      goto LABEL_11;
    case DevFmtX71:
      Device->NumChan = 7;
      *(_QWORD *)Speaker2Chan = 0x700000004LL;
      *(_QWORD *)&Device->Speaker2Chan[2] = 0x200000000LL;
      v6 = "layout_surround71";
      Device->Speaker2Chan[4] = FrontRight;
      Device->Speaker2Chan[5] = SideRight;
      Device->Speaker2Chan[6] = BackRight;
      v9 = 1076333878;
      *(_QWORD *)SpeakerAngle = 0xBFC90FDBC0278D36LL;
      *((_QWORD *)SpeakerAngle + 1) = 3204844178LL;
      Device->SpeakerAngle[4] = 0.5236;
      Device->SpeakerAngle[5] = 1.5708;
      v10 = 6;
      goto LABEL_11;
    default:
      if ( FmtChans != 0x80000000 )
        return;
      v5 = 7LL;
      v6 = "layout_side51";
      v7 = 0xBF060A92BFC90FDBLL;
      Device->NumChan = 5;
      v8 = SideRight;
      v9 = 1070141403;
LABEL_8:
      *(_QWORD *)Speaker2Chan = v5;
      *(_QWORD *)&Device->Speaker2Chan[2] = 0x100000002LL;
      Device->Speaker2Chan[4] = v8;
      v10 = 4;
      *(_QWORD *)SpeakerAngle = v7;
      *((_QWORD *)SpeakerAngle + 1) = 0x3F060A9200000000LL;
LABEL_11:
      LODWORD(Device->SpeakerAngle[v10]) = v9;
      if ( Device->Type == Loopback )
        return;
      v48 = Device->Speaker2Chan;
      v49 = SpeakerAngle;
      v11 = 0;
      NumChan = Device->NumChan;
      break;
  }
  while ( strcmp((const char *)g_ex_configPairs[v11].block, "root")
       || strcmp((const char *)g_ex_configPairs[v11].key, v6) )
  {
    if ( v11++ >= 29 )
      goto LABEL_16;
  }
  if ( v11 < 0 )
    goto LABEL_16;
  keyValues = g_mob_configGlobals.keyValues;
  if ( !g_mob_configGlobals.keyValues )
    return;
  key = g_mob_configGlobals.keyValues->key;
  if ( g_mob_configGlobals.keyValues->key )
  {
    while ( key != v11 )
    {
      v18 = keyValues[1].key;
      ++keyValues;
      key = v18;
      if ( v18 == MOB_ConfigKey_NULL )
        goto LABEL_16;
    }
  }
  else
  {
LABEL_16:
    keyValues = g_mob_configGlobals.keyValues;
    if ( !g_mob_configGlobals.keyValues )
      return;
    v15 = g_mob_configGlobals.keyValues->key;
    if ( g_mob_configGlobals.keyValues->key == MOB_ConfigKey_NULL )
      return;
    while ( v15 != MOB_ConfigKey_root_layout )
    {
      v16 = keyValues[1].key;
      ++keyValues;
      v15 = v16;
      if ( v16 == MOB_ConfigKey_NULL )
        return;
    }
  }
  v45 = v6;
  v46 = Device;
  v47 = j_strdup(keyValues->value.stringVal);
  if ( v47 )
  {
    v19 = (const char *)v47;
    while ( 1 )
    {
      v20 = v19;
      if ( !*v19 )
        break;
      v21 = strchr(v19, 44);
      v19 = v21;
      if ( v21 )
      {
        *v21 = 0;
        do
        {
          do
          {
            v22 = *(unsigned __int8 *)++v19;
            v23 = isspace(v22);
          }
          while ( v22 == 44 );
        }
        while ( v23 );
      }
      else
      {
        v19 = 0;
      }
      v24 = strchr(v20, 61);
      v25 = v24;
      v26 = v24 == 0;
      if ( v24 )
        v26 = v20 == v24;
      if ( v26 )
      {
        if ( LogLevel_0 )
          j_al_print("(EE)", "SetSpeakerArrangement", "Malformed speaker key: %s\n", v20);
        goto LABEL_83;
      }
      v27 = v24 - 1;
      v28 = v24 - 1;
      do
      {
        v29 = (unsigned __int8)*v28--;
        v30 = isspace(v29);
        if ( v20 == v27 )
          break;
        v27 = v28;
      }
      while ( v30 );
      v31 = 0;
      v28[2] = 0;
      if ( strcmp(v20, (const char *)&dword_2600E0) )
      {
        if ( !strcmp(v20, "front-left") )
        {
          v31 = 0;
        }
        else if ( !strcmp(v20, "fr") || !strcmp(v20, "front-right") )
        {
          v31 = 1;
        }
        else if ( !strcmp(v20, "fc") || !strcmp(v20, "front-center") )
        {
          v31 = 2;
        }
        else if ( !strcmp(v20, "bl") || !strcmp(v20, "back-left") )
        {
          v31 = 4;
        }
        else if ( !strcmp(v20, "br") || !strcmp(v20, "back-right") )
        {
          v31 = 5;
        }
        else if ( !strcmp(v20, "bc") || !strcmp(v20, "back-center") )
        {
          v31 = 6;
        }
        else if ( !strcmp(v20, "sl") || !strcmp(v20, "side-left") )
        {
          v31 = 7;
        }
        else
        {
          if ( strcmp(v20, "sr") && strcmp(v20, "side-right") )
          {
            if ( LogLevel_0 )
              j_al_print("(EE)", "SetSpeakerArrangement", "Unknown speaker for %s: \"%s\"\n", v45, v20);
            goto LABEL_83;
          }
          v31 = 8;
        }
      }
      *v25 = 0;
      do
        v32 = *(unsigned __int8 *)++v25;
      while ( isspace(v32) );
      if ( NumChan < 1 )
      {
LABEL_83:
        if ( !v19 )
          break;
      }
      else
      {
        v33 = v49;
        v34 = 0;
        while ( *((_DWORD *)v33 - 9) != v31 )
        {
          ++v34;
          ++v33;
          if ( v34 >= NumChan )
            goto LABEL_83;
        }
        v35 = strtol(v25, 0, 10);
        if ( (unsigned int)(v35 + 180) > 0x168 )
        {
          if ( LogLevel_0 )
            j_al_print("(EE)", "SetSpeakerArrangement", "Invalid angle for speaker \"%s\": %ld\n", v20, v35);
          goto LABEL_83;
        }
        *v33 = (float)((float)v35 * 3.1416) / 180.0;
        if ( !v19 )
          break;
      }
    }
  }
  free(v47);
  if ( NumChan >= 1 )
  {
    v36 = &v46->SpeakerAngle[1];
    v37 = 0;
    do
    {
      v38 = v37++;
      if ( v37 < NumChan )
      {
        v39 = v36;
        v40 = v37;
        v41 = v38;
        do
        {
          v42 = *v39++;
          if ( v42 < v46->SpeakerAngle[v41] )
            v41 = v40;
          ++v40;
        }
        while ( NumChan != v40 );
        if ( v41 != v38 )
        {
          v43 = v49[v38];
          v49[v38] = v49[v41];
          v49[v41] = v43;
          v44 = v48[v38];
          v48[v38] = v48[v41];
          v48[v41] = v44;
        }
      }
      ++v36;
    }
    while ( v37 != NumChan );
  }
}
// 2600E0: using guessed type int dword_2600E0;

//----- (002601BC) --------------------------------------------------------
ALCboolean __fastcall alc_audiotrack_init(BackendFuncs *func_list)
{
  void (**p_StopPlayback)(ALCdevice *); // r0

  *(_QWORD *)&func_list->StopCapture = *(_QWORD *)&android_funcs.StopCapture;
  *(_QWORD *)&func_list->AvailableSamples = *(_QWORD *)&android_funcs.AvailableSamples;
  *(_QWORD *)&func_list->Unlock = *(_QWORD *)&android_funcs.Unlock;
  *(_QWORD *)&func_list->OpenPlayback = *(_QWORD *)&android_funcs.OpenPlayback;
  *(_QWORD *)&func_list->ResetPlayback = *(_QWORD *)&android_funcs.ResetPlayback;
  p_StopPlayback = &func_list->StopPlayback;
  *(_QWORD *)p_StopPlayback = *(_QWORD *)&android_funcs.StopPlayback;
  *((_QWORD *)p_StopPlayback + 1) = *(_QWORD *)&android_funcs.CloseCapture;
  return 1;
}

//----- (002601F4) --------------------------------------------------------
void alc_audiotrack_deinit()
{
  JavaVM *p_functions; // r4
  JavaVM_0 *JavaVM; // r0

  p_functions = javaVM;
  if ( !javaVM )
  {
    JavaVM = j_GetJavaVM();
    p_functions = &JavaVM->functions;
    javaVM = &JavaVM->functions;
    if ( apportableOpenALFuncs.alc_android_set_java_vm )
      apportableOpenALFuncs.alc_android_set_java_vm((JavaVM *)JavaVM);
    javaVM = p_functions;
  }
  (*env)->DeleteGlobalRef(env, cAudioTrack);
  (*p_functions)->DetachCurrentThread(p_functions);
  cAudioTrack = 0;
}

//----- (0026026A) --------------------------------------------------------
ALboolean __fastcall DedicatedDeviceUpdate(ALeffectState_0 *effect, ALCdevice *Device)
{
  return 1;
}

//----- (0026026E) --------------------------------------------------------
ALvoid __fastcall DedicatedUpdate(ALeffectState_0 *effect, ALCdevice *device, const ALeffectslot_0 *Slot)
{
  float Gain; // s0
  float v4; // s2
  float v5; // s0
  ALenum type; // r2

  Gain = Slot->effect.Dedicated.Gain;
  v4 = Slot->Gain;
  effect[3].Destroy = 0;
  v5 = v4 * Gain;
  *(_QWORD *)&effect[2].Destroy = 0LL;
  *(_QWORD *)&effect[2].Update = 0LL;
  *(_QWORD *)&effect[1].Destroy = 0LL;
  *(_QWORD *)&effect[1].Update = 0LL;
  type = Slot->effect.type;
  if ( type == 36864 )
  {
    *(float *)&effect[1].Process = v5;
  }
  else if ( type == 36865 )
  {
    j_ComputeAngleGains(device, 0.0, 0.0, v5, (int)&effect[1]);
  }
}

//----- (002602C6) --------------------------------------------------------
ALvoid __fastcall DedicatedProcess(
        ALeffectState_0 *effect,
        ALuint SamplesToDo,
        const ALfloat *SamplesIn,
        ALfloat (*SamplesOut)[2048])
{
  ALvoid (*Destroy)(ALeffectState *); // s0
  ALuint v5; // r12
  ALfloat (*v6)[2048]; // lr
  const ALfloat *v7; // r4
  float v8; // s2
  ALboolean (*DeviceUpdate)(ALeffectState *, ALCdevice *); // s0
  float *v10; // r12
  const ALfloat *v11; // lr
  ALuint v12; // r4
  float v13; // s2
  ALvoid (*Update)(ALeffectState *, ALCdevice *, const ALeffectslot *); // s0
  float *v15; // r12
  const ALfloat *v16; // lr
  ALuint v17; // r4
  float v18; // s2
  ALvoid (*Process)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]); // s0
  float *v20; // r12
  const ALfloat *v21; // lr
  ALuint v22; // r4
  float v23; // s2
  ALvoid (*v24)(ALeffectState *); // s0
  float *v25; // r12
  const ALfloat *v26; // lr
  ALuint v27; // r4
  float v28; // s2
  ALboolean (*v29)(ALeffectState *, ALCdevice *); // s0
  float *v30; // r12
  const ALfloat *v31; // lr
  ALuint v32; // r4
  float v33; // s2
  ALvoid (*v34)(ALeffectState *, ALCdevice *, const ALeffectslot *); // s0
  float *v35; // r12
  const ALfloat *v36; // lr
  ALuint v37; // r4
  float v38; // s2
  ALvoid (*v39)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]); // s0
  float *v40; // r12
  const ALfloat *v41; // lr
  ALuint v42; // r4
  float v43; // s2
  ALvoid (*v44)(ALeffectState *); // s0
  float *v45; // r0
  float v46; // s2

  if ( SamplesToDo )
  {
    Destroy = effect[1].Destroy;
    v5 = SamplesToDo;
    v6 = SamplesOut;
    v7 = SamplesIn;
    do
    {
      v8 = *v7;
      --v5;
      ++v7;
      (*v6)[0] = v8 * *(float *)&Destroy;
      v6 = (ALfloat (*)[2048])((char *)v6 + 4);
    }
    while ( v5 );
    DeviceUpdate = effect[1].DeviceUpdate;
    v10 = &(*SamplesOut)[2048];
    v11 = SamplesIn;
    v12 = SamplesToDo;
    do
    {
      v13 = *v11++;
      --v12;
      *v10++ = v13 * *(float *)&DeviceUpdate;
    }
    while ( v12 );
    Update = effect[1].Update;
    v15 = &(*SamplesOut)[4096];
    v16 = SamplesIn;
    v17 = SamplesToDo;
    do
    {
      v18 = *v16++;
      --v17;
      *v15++ = v18 * *(float *)&Update;
    }
    while ( v17 );
    Process = effect[1].Process;
    v20 = &(*SamplesOut)[6144];
    v21 = SamplesIn;
    v22 = SamplesToDo;
    do
    {
      v23 = *v21++;
      --v22;
      *v20++ = v23 * *(float *)&Process;
    }
    while ( v22 );
    v24 = effect[2].Destroy;
    v25 = &(*SamplesOut)[0x2000];
    v26 = SamplesIn;
    v27 = SamplesToDo;
    do
    {
      v28 = *v26++;
      --v27;
      *v25++ = v28 * *(float *)&v24;
    }
    while ( v27 );
    v29 = effect[2].DeviceUpdate;
    v30 = &(*SamplesOut)[10240];
    v31 = SamplesIn;
    v32 = SamplesToDo;
    do
    {
      v33 = *v31++;
      --v32;
      *v30++ = v33 * *(float *)&v29;
    }
    while ( v32 );
    v34 = effect[2].Update;
    v35 = &(*SamplesOut)[12288];
    v36 = SamplesIn;
    v37 = SamplesToDo;
    do
    {
      v38 = *v36++;
      --v37;
      *v35++ = v38 * *(float *)&v34;
    }
    while ( v37 );
    v39 = effect[2].Process;
    v40 = &(*SamplesOut)[14336];
    v41 = SamplesIn;
    v42 = SamplesToDo;
    do
    {
      v43 = *v41++;
      --v42;
      *v40++ = v43 * *(float *)&v39;
    }
    while ( v42 );
    v44 = effect[3].Destroy;
    v45 = &(*SamplesOut)[0x4000];
    do
    {
      v46 = *SamplesIn++;
      --SamplesToDo;
      *v45++ = v46 * *(float *)&v44;
    }
    while ( SamplesToDo );
  }
}
// 2602F6: conditional instruction was optimized away because r1.4!=0
// 260320: conditional instruction was optimized away because r1.4!=0
// 26034A: conditional instruction was optimized away because r1.4!=0
// 260372: conditional instruction was optimized away because r1.4!=0
// 26039A: conditional instruction was optimized away because r1.4!=0
// 2603C0: conditional instruction was optimized away because r1.4!=0
// 2603E6: conditional instruction was optimized away because r1.4!=0
// 26040E: conditional instruction was optimized away because r1.4!=0

//----- (00260434) --------------------------------------------------------
void __fastcall Resample_copy32_C(
        const ALfloat *data,
        ALuint frac,
        ALuint increment,
        ALfloat *OutBuffer,
        ALuint BufferSize)
{
  if ( increment != 0x4000 )
  {
    _assert2(
      "C:/Projects/OSWrapper\\OAL/Soft/mixer_c.c",
      22,
      "void Resample_copy32_C(const ALfloat *, ALuint, ALuint, ALfloat *restrict, ALuint)",
      "increment==FRACTIONONE");
    JUMPOUT(0x260460);
  }
  qmemcpy(OutBuffer, data, 4 * BufferSize + 4);
}
// 26045E: control flows out of bounds to 260460
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (002604A8) --------------------------------------------------------
void __fastcall Resample_point32_C(
        const ALfloat *data,
        ALuint frac,
        ALuint increment,
        ALfloat *OutBuffer,
        ALuint BufferSize)
{
  ALuint v5; // r12
  int v6; // lr
  ALuint v7; // r1

  v5 = BufferSize + 1;
  if ( BufferSize != -1 )
  {
    v6 = 0;
    do
    {
      v7 = frac + increment;
      *OutBuffer++ = data[v6];
      v6 += v7 >> 14;
      frac = v7 & 0x3FFF;
      --v5;
    }
    while ( v5 );
  }
}

//----- (002604D8) --------------------------------------------------------
void __fastcall Resample_lerp32_C(
        const ALfloat *data,
        ALuint frac,
        ALuint increment,
        ALfloat *OutBuffer,
        ALuint BufferSize)
{
  ALuint v5; // r12
  int v6; // lr
  ALuint v7; // s2
  const ALfloat *v8; // r4
  ALuint v9; // r1

  v5 = BufferSize + 1;
  if ( BufferSize != -1 )
  {
    v6 = 0;
    do
    {
      v7 = frac;
      v8 = &data[v6];
      v9 = frac + increment;
      --v5;
      v6 += v9 >> 14;
      frac = v9 & 0x3FFF;
      *OutBuffer++ = *v8 + (float)((float)((float)v7 * 0.000061035) * (float)(v8[1] - *v8));
    }
    while ( v5 );
  }
}

//----- (00260534) --------------------------------------------------------
void __fastcall Resample_cubic32_C(
        const ALfloat *data,
        ALuint frac,
        ALuint increment,
        ALfloat *OutBuffer,
        ALuint BufferSize)
{
  ALuint v5; // r12
  int v6; // lr
  const ALfloat *v7; // r4
  ALuint v8; // s11
  ALuint v9; // r1
  float v10; // s14
  float v11; // s7

  v5 = BufferSize + 1;
  if ( BufferSize != -1 )
  {
    v6 = 0;
    do
    {
      v7 = &data[v6];
      v8 = frac;
      v9 = frac + increment;
      --v5;
      v6 += v9 >> 14;
      v10 = v7[1];
      frac = v9 & 0x3FFF;
      v11 = (float)v8 * 0.000061035;
      *OutBuffer++ = *v7
                   + (float)((float)(v11 * (float)((float)(*(v7 - 1) * -0.5) + (float)(v10 * 0.5)))
                           + (float)((float)((float)(v11 * v11)
                                           * (float)((float)((float)(*(v7 - 1) + (float)(*v7 * -2.5))
                                                           + (float)(v10 + v10))
                                                   - (float)(v7[2] * 0.5)))
                                   + (float)((float)(v11 * v11)
                                           * (float)(v11
                                                   * (float)((float)((float)((float)(*(v7 - 1) * -0.5)
                                                                           + (float)(*v7 * 1.5))
                                                                   - (float)(v10 * 1.5))
                                                           + (float)(v7[2] * 0.5))))));
    }
    while ( v5 );
  }
}

//----- (002605F4) --------------------------------------------------------
void __fastcall MixDirect_Hrtf_C(
        const DirectParams_0 *params,
        const ALfloat *data,
        ALuint srcchan,
        ALuint OutPos,
        int a5,
        unsigned int a6)
{
  float v6; // s0
  float v7; // s2
  float v8; // s4
  float v9; // s6
  float v10; // s8
  HrtfState_0 *State; // r6
  ALuint IrSize; // r5
  char *v13; // r9
  ALuint Offset; // r8
  float **v15; // r12
  ALuint Counter; // r1
  int v17; // r11
  __int64 v18; // kr00_8
  float *v19; // r6
  float *v20; // r2
  ALuint v21; // r4
  float *v22; // r1
  float v23; // s2
  float v24; // s4
  bool v25; // zf
  ALuint v26; // r8
  float *v27; // r4
  unsigned int v28; // r9
  float *v29; // r1
  unsigned int v30; // r12
  ALuint v31; // r1
  char v32; // r3
  float *v33; // r4
  float v34; // s0
  char v35; // r3
  unsigned int v36; // r6
  unsigned int v37; // r2
  float v38; // s0
  ALuint v39; // r1
  float v40; // s2
  float v41; // s6
  ALuint v42; // r1
  char v43; // r0
  char v44; // r4
  float v45; // s2
  float v46; // s4
  float v47; // s10
  float v48; // s8
  float v49; // s6
  float v50; // s12
  ALuint v51; // r6
  ALint v52; // r1
  ALuint v53; // r0
  ALint v54; // r2
  ALuint v55; // r0
  float *v56; // r10
  float *v57; // lr
  int v58; // r1
  float v59; // s2
  float v60; // s4
  float v61; // s6
  char v62; // r2
  ALuint v63; // r2
  float v64; // s8
  float v65; // s10
  float v66; // s12
  ALuint v67; // r2
  float *v68; // r1
  float v69; // s4
  unsigned int v70; // r10
  int v71; // r4
  unsigned int v72; // r9
  ALuint v73; // r11
  ALuint v74; // r2
  ALuint v75; // r1
  float v76; // s2
  ALuint v77; // r12
  float v78; // s0
  float *v79; // r1
  int v80; // r2
  char v81; // r4
  ALuint v82; // r4
  float v83; // s4
  ALuint v84; // r1
  float *v85; // r0
  float *v86; // r2
  float v87; // s2
  ALfloat v88; // r1
  ALuint v89; // r2
  ALuint v90; // r1
  float v91; // s4
  float v92; // s2
  ALfloat *v93; // [sp+Ch] [bp-44Ch]
  char v94; // [sp+Ch] [bp-44Ch]
  ALint *v95; // [sp+10h] [bp-448h]
  ALuint v96; // [sp+10h] [bp-448h]
  ALint *DelayStep; // [sp+14h] [bp-444h]
  ALfloat (*OutBuffer)[2048]; // [sp+18h] [bp-440h]
  unsigned int v99; // [sp+1Ch] [bp-43Ch]
  unsigned int v100; // [sp+1Ch] [bp-43Ch]
  unsigned int v101; // [sp+20h] [bp-438h]
  unsigned int v102; // [sp+20h] [bp-438h]
  HrtfState_0 *v104; // [sp+28h] [bp-430h]
  float v106; // [sp+30h] [bp-428h]
  float v107[258]; // [sp+34h] [bp-424h] BYREF

  State = params->Hrtf.State;
  IrSize = params->Hrtf.Params.IrSize;
  DelayStep = params->Hrtf.Params.DelayStep;
  v13 = (char *)params + 8 * srcchan;
  Offset = State->Offset;
  v104 = State;
  v15 = (float **)(v13 + 10272);
  Counter = State->Counter;
  if ( Counter <= OutPos )
    Counter = OutPos;
  v17 = Counter - OutPos;
  OutBuffer = params->OutBuffer;
  v18 = *(_QWORD *)&params->ClickRemoval;
  if ( IrSize )
  {
    v19 = &params->Hrtf.Params.CoeffStep[0][1];
    v6 = (float)v17;
    v20 = v107;
    v21 = params->Hrtf.Params.IrSize;
    v22 = params->Hrtf.Params.Coeffs[srcchan][0];
    do
    {
      v23 = *(v19 - 1);
      --v21;
      v24 = *v19;
      v19 += 2;
      v9 = *v22;
      v10 = v22[1];
      v22 += 2;
      v7 = v9 - (float)(v23 * v6);
      v8 = v10 - (float)(v24 * v6);
      *(v20 - 1) = v7;
      *v20 = v8;
      v20 += 2;
    }
    while ( v21 );
  }
  v25 = OutPos == 0;
  v26 = Offset + OutPos;
  v27 = (float *)*DelayStep;
  v28 = *((_DWORD *)v13 + 2569) - params->Hrtf.Params.DelayStep[1] * v17;
  v29 = *v15;
  v30 = (unsigned int)*v15 - *DelayStep * v17;
  if ( !OutPos )
  {
    v31 = (ALuint)v104->History[srcchan];
    *(ALfloat *)(v31 + 4 * (v26 & 0x3F)) = *data;
    v32 = v26 - (v30 >> 20);
    v33 = (float *)(v31 + 4 * (v32 & 0x3F));
    v9 = 0.00000095367;
    v34 = (float)((float)((unsigned int)"Ev" & v30) * 0.00000095367)
        * (float)(*(float *)(v31 + 4 * ((v32 + 63) & 0x3F)) - *v33);
    v35 = v26 - (v28 >> 20);
    v8 = (float)((unsigned int)"Ev" & v28);
    v6 = *v33 + v34;
    v27 = (float *)(v31 + 4 * ((v35 + 63) & 0x3F));
    v29 = (float *)(v31 + 4 * (v35 & 0x3F));
    v7 = v106;
    OutPos = (ALuint)v104 + 1024 * srcchan;
    v10 = *v29;
    LOBYTE(v29) = v26 + 1;
  }
  v36 = a6;
  v37 = 0;
  if ( v25 )
  {
    v38 = v6 * v7;
    v39 = OutPos + 8 * ((unsigned __int8)v29 & 0x7F);
    v40 = (float)(v8 * v9) * (float)(*v27 - v10);
    v41 = *(float *)(v18 + 4);
    *(float *)v18 = *(float *)v18 - (float)(*(float *)(v39 + 2320) + v38);
    *(float *)(v18 + 4) = v41 - (float)(*(float *)(v39 + 2324) + (float)((float)(v10 + v40) * v107[0]));
    OutPos = 0;
  }
  v101 = v28;
  if ( v17 >= 1 && a6 )
  {
    v95 = &params->Hrtf.Params.DelayStep[1];
    v93 = &params->Hrtf.Params.CoeffStep[0][1];
    v37 = 0;
    do
    {
      v99 = v37;
      v42 = (ALuint)v104->History[srcchan];
      *(ALfloat *)(v42 + 4 * (v26 & 0x3F)) = data[v37];
      v43 = v26 - (v30 >> 20);
      v44 = v26 - (v101 >> 20);
      v45 = *(float *)(v42 + 4 * (v44 & 0x3F));
      v46 = *(float *)(v42 + 4 * ((v44 + 63) & 0x3F));
      v47 = (float)(v101 & 0xFFFFF);
      v48 = (float)(v30 & 0xFFFFF);
      v49 = *(float *)(v42 + 4 * (v43 & 0x3F));
      v50 = *(float *)(v42 + 4 * ((v43 + 63) & 0x3F));
      v51 = (ALuint)v104 + 1024 * srcchan;
      v52 = *DelayStep;
      v53 = v51 + 8 * (((_BYTE)v26 + (_BYTE)IrSize) & 0x7F);
      v54 = *v95;
      *(_DWORD *)(v53 + 2320) = 0;
      v30 += v52;
      *(_DWORD *)(v53 + 2324) = 0;
      v55 = v26 + 1;
      v101 += v54;
      if ( IrSize )
      {
        v56 = v107;
        v57 = v93;
        v58 = 0;
        v59 = v45 + (float)((float)(v47 * 0.00000095367) * (float)(v46 - v45));
        v60 = v49 + (float)((float)(v48 * 0.00000095367) * (float)(v50 - v49));
        do
        {
          v61 = *(v56 - 1);
          v62 = v26 + v58++ + 1;
          v63 = v51 + 8 * (v62 & 0x7F);
          *(float *)(v63 + 2320) = *(float *)(v63 + 2320) + (float)(v60 * v61);
          v64 = *v56;
          *(float *)(v63 + 2324) = *(float *)(v63 + 2324) + (float)(v59 * *v56);
          v65 = *(v57 - 1);
          v66 = *v57;
          v57 += 2;
          *(v56 - 1) = v61 + v65;
          *v56 = v64 + v66;
          v56 += 2;
        }
        while ( IrSize != v58 );
      }
      v67 = v51 + 8 * (v55 & 0x7F);
      v68 = &(*OutBuffer)[OutPos++];
      v69 = v68[2048];
      *v68 = *(float *)(v67 + 2320) + *v68;
      v68[2048] = *(float *)(v67 + 2324) + v69;
      v36 = a6;
      v37 = v99 + 1;
      if ( v17 < 2 )
        break;
      --v17;
      ++v26;
    }
    while ( v37 < a6 );
  }
  else
  {
    v55 = v26;
  }
  v70 = v30 >> 20;
  v71 = a5;
  v102 = v101 >> 20;
  if ( v37 < v36 )
  {
    v96 = OutPos + v36;
    v94 = v55 + v36;
    v72 = v37;
    v100 = v37;
    do
    {
      v73 = (ALuint)v104 + 1024 * srcchan;
      v74 = (ALuint)v104->History[srcchan];
      *(ALfloat *)(v74 + 4 * (v55 & 0x3F)) = data[v72];
      v75 = v73 + 8 * (((_BYTE)v55 + (_BYTE)IrSize) & 0x7F);
      v76 = *(float *)(v74 + 4 * (((_BYTE)v55 - (_BYTE)v70) & 0x3F));
      v77 = v55 + 1;
      v78 = *(float *)(v74 + 4 * (((_BYTE)v55 - (_BYTE)v102) & 0x3F));
      *(_DWORD *)(v75 + 2320) = 0;
      *(_DWORD *)(v75 + 2324) = 0;
      if ( IrSize )
      {
        v79 = v107;
        v80 = 0;
        do
        {
          v81 = v55 + v80++ + 1;
          v82 = v73 + 8 * (v81 & 0x7F);
          *(float *)(v82 + 2320) = *(float *)(v82 + 2320) + (float)(v76 * *(v79 - 1));
          v83 = *v79;
          v79 += 2;
          *(float *)(v82 + 2324) = *(float *)(v82 + 2324) + (float)(v78 * v83);
        }
        while ( IrSize != v80 );
      }
      ++v72;
      v84 = v73 + 8 * (v77 & 0x7F);
      v85 = &(*OutBuffer)[OutPos++];
      v86 = v85 + 2048;
      v87 = v85[2048];
      *v85 = *(float *)(v84 + 2320) + *v85;
      v55 = v77;
      *v86 = *(float *)(v84 + 2324) + v87;
    }
    while ( v72 != a6 );
    OutPos = v96 - v100;
    v37 = a6;
    v71 = a5;
    LOBYTE(v55) = v94 - v100;
  }
  if ( OutPos == v71 )
  {
    v88 = data[v37];
    v89 = (ALuint)v104->History[srcchan];
    *(ALfloat *)(v89 + 4 * (v55 & 0x3F)) = v88;
    v90 = (ALuint)v104 + 1024 * srcchan + 8 * (((_BYTE)v55 + 1) & 0x7F);
    v91 = *(float *)(HIDWORD(v18) + 4);
    v92 = *(float *)(v89 + 4 * (((_BYTE)v55 - (_BYTE)v102) & 0x3F));
    *(float *)HIDWORD(v18) = *(float *)HIDWORD(v18)
                           + (float)(*(float *)(v90 + 2320)
                                   + (float)(*(float *)(v89 + 4 * (((_BYTE)v55 - (_BYTE)v70) & 0x3F)) * v106));
    *(float *)(HIDWORD(v18) + 4) = v91 + (float)(*(float *)(v90 + 2324) + (float)(v92 * v107[0]));
  }
}
// 260780: variable 'v6' is possibly undefined
// 260780: variable 'v7' is possibly undefined
// 260792: variable 'v8' is possibly undefined
// 260792: variable 'v9' is possibly undefined
// 26078E: variable 'v10' is possibly undefined

//----- (00260B8C) --------------------------------------------------------
void __fastcall MixDirect_C(
        const DirectParams_0 *params,
        const ALfloat *data,
        ALuint srcchan,
        ALuint OutPos,
        int a5,
        int a6)
{
  int v7; // r5
  float *v8; // r11
  ALfloat *PendingClicks; // lr
  float v10; // s2
  float *v11; // r6
  int v12; // r4
  const ALfloat *v13; // r1
  float v14; // s4
  int v15; // r1
  ALfloat *ClickRemoval; // [sp+0h] [bp-20h]

  v7 = 0;
  ClickRemoval = params->ClickRemoval;
  v8 = &(*params->OutBuffer)[OutPos];
  PendingClicks = params->PendingClicks;
  do
  {
    v10 = params->Gains[srcchan][v7];
    if ( v10 < 0.00001 )
      goto LABEL_12;
    if ( OutPos )
    {
      if ( a6 )
        goto LABEL_5;
    }
    else
    {
      ClickRemoval[v7] = ClickRemoval[v7] - (float)(v10 * *data);
      if ( a6 )
      {
LABEL_5:
        v11 = v8;
        v12 = a6;
        v13 = data;
        do
        {
          v14 = *v13;
          --v12;
          ++v13;
          *v11 = *v11 + (float)(v10 * v14);
          ++v11;
        }
        while ( v12 );
        v15 = a6;
        goto LABEL_10;
      }
    }
    v15 = 0;
LABEL_10:
    if ( v15 + OutPos == a5 )
      PendingClicks[v7] = PendingClicks[v7] + (float)(v10 * data[v15]);
LABEL_12:
    ++v7;
    v8 += 2048;
  }
  while ( v7 != 9 );
}

//----- (00260C58) --------------------------------------------------------
void __fastcall MixSend_C(const SendParams_0 *params, const ALfloat *data, ALuint OutPos, ALuint SamplesToDo, int a5)
{
  float Gain; // s0
  int v6; // r12
  ALeffectslot *Slot; // lr
  int v8; // r4
  float *v9; // r0
  const ALfloat *v10; // r5
  float v11; // s2

  Gain = params->Gain;
  if ( Gain >= 0.00001 )
  {
    v6 = a5;
    Slot = params->Slot;
    if ( OutPos )
    {
      if ( a5 )
        goto LABEL_4;
    }
    else
    {
      Slot->ClickRemoval[0] = Slot->ClickRemoval[0] - (float)(Gain * *data);
      if ( a5 )
      {
LABEL_4:
        v8 = a5;
        v9 = &Slot->WetBuffer[0][OutPos];
        v10 = data;
        do
        {
          v11 = *v10;
          --v8;
          ++v10;
          *v9 = *v9 + (float)(Gain * v11);
          ++v9;
        }
        while ( v8 );
        goto LABEL_9;
      }
    }
    v6 = 0;
LABEL_9:
    if ( v6 + OutPos == SamplesToDo )
      Slot->PendingClicks[0] = Slot->PendingClicks[0] + (float)(Gain * data[v6]);
  }
}

//----- (00260CFC) --------------------------------------------------------
void __fastcall MixDirect_Hrtf_SUFFIX(
        const DirectParams_0 *params,
        const ALfloat *data,
        ALuint srcchan,
        ALuint OutPos,
        int a5,
        unsigned int a6)
{
  float v6; // s0
  float v7; // s2
  float v8; // s4
  float v9; // s6
  float v10; // s8
  HrtfState_0 *State; // r6
  ALuint IrSize; // r5
  char *v13; // r9
  ALuint Offset; // r8
  float **v15; // r12
  ALuint Counter; // r1
  int v17; // r11
  __int64 v18; // kr00_8
  float *v19; // r6
  float *v20; // r2
  ALuint v21; // r4
  float *v22; // r1
  float v23; // s2
  float v24; // s4
  bool v25; // zf
  ALuint v26; // r8
  float *v27; // r4
  unsigned int v28; // r9
  float *v29; // r1
  unsigned int v30; // r12
  ALuint v31; // r1
  char v32; // r3
  float *v33; // r4
  float v34; // s0
  char v35; // r3
  unsigned int v36; // r6
  unsigned int v37; // r2
  float v38; // s0
  ALuint v39; // r1
  float v40; // s2
  float v41; // s6
  ALuint v42; // r1
  char v43; // r0
  char v44; // r4
  float v45; // s2
  float v46; // s4
  float v47; // s10
  float v48; // s8
  float v49; // s6
  float v50; // s12
  ALuint v51; // r6
  ALint v52; // r1
  ALuint v53; // r0
  ALint v54; // r2
  ALuint v55; // r0
  float *v56; // r10
  float *v57; // lr
  int v58; // r1
  float v59; // s2
  float v60; // s4
  float v61; // s6
  char v62; // r2
  ALuint v63; // r2
  float v64; // s8
  float v65; // s10
  float v66; // s12
  ALuint v67; // r2
  float *v68; // r1
  float v69; // s4
  unsigned int v70; // r10
  int v71; // r4
  unsigned int v72; // r9
  ALuint v73; // r11
  ALuint v74; // r2
  ALuint v75; // r1
  float v76; // s2
  ALuint v77; // r12
  float v78; // s0
  float *v79; // r1
  int v80; // r2
  char v81; // r4
  ALuint v82; // r4
  float v83; // s4
  ALuint v84; // r1
  float *v85; // r0
  float *v86; // r2
  float v87; // s2
  ALfloat v88; // r1
  ALuint v89; // r2
  ALuint v90; // r1
  float v91; // s4
  float v92; // s2
  ALfloat *v93; // [sp+Ch] [bp-44Ch]
  char v94; // [sp+Ch] [bp-44Ch]
  ALint *v95; // [sp+10h] [bp-448h]
  ALuint v96; // [sp+10h] [bp-448h]
  ALint *DelayStep; // [sp+14h] [bp-444h]
  ALfloat (*OutBuffer)[2048]; // [sp+18h] [bp-440h]
  unsigned int v99; // [sp+1Ch] [bp-43Ch]
  unsigned int v100; // [sp+1Ch] [bp-43Ch]
  unsigned int v101; // [sp+20h] [bp-438h]
  unsigned int v102; // [sp+20h] [bp-438h]
  HrtfState_0 *v104; // [sp+28h] [bp-430h]
  float v106; // [sp+30h] [bp-428h]
  float v107[258]; // [sp+34h] [bp-424h] BYREF

  State = params->Hrtf.State;
  IrSize = params->Hrtf.Params.IrSize;
  DelayStep = params->Hrtf.Params.DelayStep;
  v13 = (char *)params + 8 * srcchan;
  Offset = State->Offset;
  v104 = State;
  v15 = (float **)(v13 + 10272);
  Counter = State->Counter;
  if ( Counter <= OutPos )
    Counter = OutPos;
  v17 = Counter - OutPos;
  OutBuffer = params->OutBuffer;
  v18 = *(_QWORD *)&params->ClickRemoval;
  if ( IrSize )
  {
    v19 = &params->Hrtf.Params.CoeffStep[0][1];
    v6 = (float)v17;
    v20 = v107;
    v21 = params->Hrtf.Params.IrSize;
    v22 = params->Hrtf.Params.Coeffs[srcchan][0];
    do
    {
      v23 = *(v19 - 1);
      --v21;
      v24 = *v19;
      v19 += 2;
      v9 = *v22;
      v10 = v22[1];
      v22 += 2;
      v7 = v9 - (float)(v23 * v6);
      v8 = v10 - (float)(v24 * v6);
      *(v20 - 1) = v7;
      *v20 = v8;
      v20 += 2;
    }
    while ( v21 );
  }
  v25 = OutPos == 0;
  v26 = Offset + OutPos;
  v27 = (float *)*DelayStep;
  v28 = *((_DWORD *)v13 + 2569) - params->Hrtf.Params.DelayStep[1] * v17;
  v29 = *v15;
  v30 = (unsigned int)*v15 - *DelayStep * v17;
  if ( !OutPos )
  {
    v31 = (ALuint)v104->History[srcchan];
    *(ALfloat *)(v31 + 4 * (v26 & 0x3F)) = *data;
    v32 = v26 - (v30 >> 20);
    v33 = (float *)(v31 + 4 * (v32 & 0x3F));
    v9 = 0.00000095367;
    v34 = (float)((float)((unsigned int)"Ev" & v30) * 0.00000095367)
        * (float)(*(float *)(v31 + 4 * ((v32 + 63) & 0x3F)) - *v33);
    v35 = v26 - (v28 >> 20);
    v8 = (float)((unsigned int)"Ev" & v28);
    v6 = *v33 + v34;
    v27 = (float *)(v31 + 4 * ((v35 + 63) & 0x3F));
    v29 = (float *)(v31 + 4 * (v35 & 0x3F));
    v7 = v106;
    OutPos = (ALuint)v104 + 1024 * srcchan;
    v10 = *v29;
    LOBYTE(v29) = v26 + 1;
  }
  v36 = a6;
  v37 = 0;
  if ( v25 )
  {
    v38 = v6 * v7;
    v39 = OutPos + 8 * ((unsigned __int8)v29 & 0x7F);
    v40 = (float)(v8 * v9) * (float)(*v27 - v10);
    v41 = *(float *)(v18 + 4);
    *(float *)v18 = *(float *)v18 - (float)(*(float *)(v39 + 2320) + v38);
    *(float *)(v18 + 4) = v41 - (float)(*(float *)(v39 + 2324) + (float)((float)(v10 + v40) * v107[0]));
    OutPos = 0;
  }
  v101 = v28;
  if ( v17 >= 1 && a6 )
  {
    v95 = &params->Hrtf.Params.DelayStep[1];
    v93 = &params->Hrtf.Params.CoeffStep[0][1];
    v37 = 0;
    do
    {
      v99 = v37;
      v42 = (ALuint)v104->History[srcchan];
      *(ALfloat *)(v42 + 4 * (v26 & 0x3F)) = data[v37];
      v43 = v26 - (v30 >> 20);
      v44 = v26 - (v101 >> 20);
      v45 = *(float *)(v42 + 4 * (v44 & 0x3F));
      v46 = *(float *)(v42 + 4 * ((v44 + 63) & 0x3F));
      v47 = (float)(v101 & 0xFFFFF);
      v48 = (float)(v30 & 0xFFFFF);
      v49 = *(float *)(v42 + 4 * (v43 & 0x3F));
      v50 = *(float *)(v42 + 4 * ((v43 + 63) & 0x3F));
      v51 = (ALuint)v104 + 1024 * srcchan;
      v52 = *DelayStep;
      v53 = v51 + 8 * (((_BYTE)v26 + (_BYTE)IrSize) & 0x7F);
      v54 = *v95;
      *(_DWORD *)(v53 + 2320) = 0;
      v30 += v52;
      *(_DWORD *)(v53 + 2324) = 0;
      v55 = v26 + 1;
      v101 += v54;
      if ( IrSize )
      {
        v56 = v107;
        v57 = v93;
        v58 = 0;
        v59 = v45 + (float)((float)(v47 * 0.00000095367) * (float)(v46 - v45));
        v60 = v49 + (float)((float)(v48 * 0.00000095367) * (float)(v50 - v49));
        do
        {
          v61 = *(v56 - 1);
          v62 = v26 + v58++ + 1;
          v63 = v51 + 8 * (v62 & 0x7F);
          *(float *)(v63 + 2320) = *(float *)(v63 + 2320) + (float)(v60 * v61);
          v64 = *v56;
          *(float *)(v63 + 2324) = *(float *)(v63 + 2324) + (float)(v59 * *v56);
          v65 = *(v57 - 1);
          v66 = *v57;
          v57 += 2;
          *(v56 - 1) = v61 + v65;
          *v56 = v64 + v66;
          v56 += 2;
        }
        while ( IrSize != v58 );
      }
      v67 = v51 + 8 * (v55 & 0x7F);
      v68 = &(*OutBuffer)[OutPos++];
      v69 = v68[2048];
      *v68 = *(float *)(v67 + 2320) + *v68;
      v68[2048] = *(float *)(v67 + 2324) + v69;
      v36 = a6;
      v37 = v99 + 1;
      if ( v17 < 2 )
        break;
      --v17;
      ++v26;
    }
    while ( v37 < a6 );
  }
  else
  {
    v55 = v26;
  }
  v70 = v30 >> 20;
  v71 = a5;
  v102 = v101 >> 20;
  if ( v37 < v36 )
  {
    v96 = OutPos + v36;
    v94 = v55 + v36;
    v72 = v37;
    v100 = v37;
    do
    {
      v73 = (ALuint)v104 + 1024 * srcchan;
      v74 = (ALuint)v104->History[srcchan];
      *(ALfloat *)(v74 + 4 * (v55 & 0x3F)) = data[v72];
      v75 = v73 + 8 * (((_BYTE)v55 + (_BYTE)IrSize) & 0x7F);
      v76 = *(float *)(v74 + 4 * (((_BYTE)v55 - (_BYTE)v70) & 0x3F));
      v77 = v55 + 1;
      v78 = *(float *)(v74 + 4 * (((_BYTE)v55 - (_BYTE)v102) & 0x3F));
      *(_DWORD *)(v75 + 2320) = 0;
      *(_DWORD *)(v75 + 2324) = 0;
      if ( IrSize )
      {
        v79 = v107;
        v80 = 0;
        do
        {
          v81 = v55 + v80++ + 1;
          v82 = v73 + 8 * (v81 & 0x7F);
          *(float *)(v82 + 2320) = *(float *)(v82 + 2320) + (float)(v76 * *(v79 - 1));
          v83 = *v79;
          v79 += 2;
          *(float *)(v82 + 2324) = *(float *)(v82 + 2324) + (float)(v78 * v83);
        }
        while ( IrSize != v80 );
      }
      ++v72;
      v84 = v73 + 8 * (v77 & 0x7F);
      v85 = &(*OutBuffer)[OutPos++];
      v86 = v85 + 2048;
      v87 = v85[2048];
      *v85 = *(float *)(v84 + 2320) + *v85;
      v55 = v77;
      *v86 = *(float *)(v84 + 2324) + v87;
    }
    while ( v72 != a6 );
    OutPos = v96 - v100;
    v37 = a6;
    v71 = a5;
    LOBYTE(v55) = v94 - v100;
  }
  if ( OutPos == v71 )
  {
    v88 = data[v37];
    v89 = (ALuint)v104->History[srcchan];
    *(ALfloat *)(v89 + 4 * (v55 & 0x3F)) = v88;
    v90 = (ALuint)v104 + 1024 * srcchan + 8 * (((_BYTE)v55 + 1) & 0x7F);
    v91 = *(float *)(HIDWORD(v18) + 4);
    v92 = *(float *)(v89 + 4 * (((_BYTE)v55 - (_BYTE)v102) & 0x3F));
    *(float *)HIDWORD(v18) = *(float *)HIDWORD(v18)
                           + (float)(*(float *)(v90 + 2320)
                                   + (float)(*(float *)(v89 + 4 * (((_BYTE)v55 - (_BYTE)v70) & 0x3F)) * v106));
    *(float *)(HIDWORD(v18) + 4) = v91 + (float)(*(float *)(v90 + 2324) + (float)(v92 * v107[0]));
  }
}
// 260E88: variable 'v6' is possibly undefined
// 260E88: variable 'v7' is possibly undefined
// 260E9A: variable 'v8' is possibly undefined
// 260E9A: variable 'v9' is possibly undefined
// 260E96: variable 'v10' is possibly undefined

//----- (00261294) --------------------------------------------------------
void __fastcall FillCPUCaps(ALuint capfilter)
{
  if ( (unsigned int)LogLevel_0 >= LogTrace )
    j_al_print("(II)", "FillCPUCaps", "Got caps:%s%s%s\n", &byte_61CADE, &byte_61CADE, " -none-");
  CPUCapFlags = 0;
}
// 61CADE: using guessed type char byte_61CADE;

//----- (002612F4) --------------------------------------------------------
void *__fastcall al_malloc(size_t alignment, size_t size)
{
  _BYTE *v3; // r1
  void *result; // r0
  unsigned int v5; // r1

  v3 = malloc(size + alignment);
  result = 0;
  if ( v3 )
  {
    *v3 = 0;
    v5 = (unsigned int)(v3 + 1);
    if ( ((alignment - 1) & v5) != 0 )
    {
      result = (void *)v5;
      do
      {
        *(_BYTE *)result = 85;
        result = (char *)result + 1;
      }
      while ( ((alignment - 1) & (unsigned int)result) != 0 );
    }
    else
    {
      return (void *)v5;
    }
  }
  return result;
}

//----- (00261328) --------------------------------------------------------
int timeGetTime()
{
  struct timespec v1; // [sp+0h] [bp-10h] BYREF

  if ( timeGetTime_hasmono <= 0
    && (timeGetTime_hasmono || (timeGetTime_hasmono = sysconf(100), timeGetTime_hasmono < 1))
    || clock_gettime(1, &v1) )
  {
    if ( clock_gettime(0, &v1) )
    {
      _assert2("C:/Projects/OSWrapper\\OAL/Soft/helpers.c", 392, "ALuint timeGetTime(void)", "ret == 0");
      JUMPOUT(0x261398);
    }
  }
  return v1.tv_nsec / 1000000 + 1000 * v1.tv_sec;
}
// 261396: control flows out of bounds to 261398
// 1A0134: using guessed type int __fastcall _assert2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (002613C4) --------------------------------------------------------
void __fastcall Sleep(ALuint t)
{
  _DWORD *v1; // r4
  struct timespec v2; // [sp+0h] [bp-20h] BYREF
  struct timespec requested_time; // [sp+8h] [bp-18h] BYREF

  requested_time.tv_sec = t / 0x3E8;
  requested_time.tv_nsec = (_DWORD)"ist_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly" * t
                         - 1000000000
                         * ((unsigned int)(((((unsigned int)"ist_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly"
                                            * t) >> 9)
                                          * (unsigned __int64)((unsigned int)&stru_44B7C.st_value + 3)) >> 32) >> 7);
  if ( nanosleep(&requested_time, &v2) == -1 )
  {
    v1 = (_DWORD *)_errno();
    do
    {
      if ( *v1 != 4 )
        break;
      requested_time = v2;
    }
    while ( nanosleep(&requested_time, &v2) == -1 );
  }
}
// 44B7C: using guessed type Elf32_Sym stru_44B7C;
// 19CEE8: using guessed type int _errno(void);

//----- (00261440) --------------------------------------------------------
void SetRTPriority()
{
  pthread_t v0; // r0
  struct sched_param param; // [sp+4h] [bp-Ch] BYREF

  if ( RTPrioLevel >= 1 )
  {
    param.sched_priority = sched_get_priority_min(2);
    v0 = pthread_self();
    if ( pthread_setschedparam(v0, 2, &param) )
    {
      if ( LogLevel_0 )
        j_al_print("(EE)", "SetRTPriority", "Failed to set priority level for thread\n");
    }
  }
}

//----- (002614CC) --------------------------------------------------------
void __fastcall ResetUIntMap(UIntMap_0 *map)
{
  unsigned int *p_write_count; // r5
  unsigned int v3; // r0
  unsigned int *p_read_lock; // r6
  unsigned int v5; // r0
  unsigned int v6; // r0
  unsigned int *p_write_lock; // r6
  unsigned int v8; // r0
  unsigned int v9; // r0
  unsigned int v10; // r0
  unsigned int *v11; // r0

  p_write_count = (unsigned int *)&map->lock.write_count;
  __dmb(0xBu);
  do
    v3 = __ldrex(p_write_count);
  while ( __strex(v3 + 1, p_write_count) );
  __dmb(0xBu);
  if ( !v3 )
  {
    p_read_lock = (unsigned int *)&map->lock.read_lock;
    __dmb(0xBu);
    do
      v5 = __ldrex(p_read_lock);
    while ( __strex(1u, p_read_lock) );
    __dmb(0xBu);
    if ( v5 == 1 )
    {
      do
      {
        sched_yield();
        __dmb(0xBu);
        do
          v6 = __ldrex(p_read_lock);
        while ( __strex(1u, p_read_lock) );
        __dmb(0xBu);
      }
      while ( v6 == 1 );
    }
  }
  p_write_lock = (unsigned int *)&map->lock.write_lock;
  __dmb(0xBu);
  do
    v8 = __ldrex(p_write_lock);
  while ( __strex(1u, p_write_lock) );
  __dmb(0xBu);
  if ( v8 == 1 )
  {
    do
    {
      sched_yield();
      __dmb(0xBu);
      do
        v9 = __ldrex(p_write_lock);
      while ( __strex(1u, p_write_lock) );
      __dmb(0xBu);
    }
    while ( v9 == 1 );
  }
  free(map->array);
  map->array = 0;
  map->size = 0;
  map->maxsize = 0;
  __dmb(0xBu);
  do
    __ldrex(p_write_lock);
  while ( __strex(0, p_write_lock) );
  __dmb(0xBu);
  __dmb(0xBu);
  do
    v10 = __ldrex(p_write_count);
  while ( __strex(v10 - 1, p_write_count) );
  __dmb(0xBu);
  if ( v10 == 1 )
  {
    v11 = (unsigned int *)&map->lock.read_lock;
    __dmb(0xBu);
    do
      __ldrex(v11);
    while ( __strex(0, v11) );
    __dmb(0xBu);
  }
}

//----- (002615CC) --------------------------------------------------------
void __fastcall alSetConfigMOB(const MOB_ConfigKeyValue *keyValues)
{
  g_mob_configGlobals.keyValues = keyValues;
}

//----- (002615E0) --------------------------------------------------------
int __fastcall MOB_ConfigGetEnumByName(const unsigned __int8 *blockName, const unsigned __int8 *keyName)
{
  int v3; // r4
  const char *v4; // r6

  v3 = 0;
  v4 = "root";
  if ( blockName )
    v4 = (const char *)blockName;
  while ( strcmp((const char *)g_ex_configPairs[v3].block, v4)
       || strcmp((const char *)g_ex_configPairs[v3].key, (const char *)keyName) )
  {
    if ( v3++ >= 29 )
      return -1;
  }
  return v3;
}

//----- (00261640) --------------------------------------------------------
int __fastcall MOB_ConfigValueStr_KeyStr(
        const unsigned __int8 *blockName,
        const unsigned __int8 *keyName,
        const unsigned __int8 **ret)
{
  const char *v5; // r6
  int v6; // r4
  MOB_ConfigGlobals_0 *key; // r0
  bool v10; // zf
  MOB_ConfigValue *p_value; // r1

  v5 = "root";
  v6 = 0;
  if ( blockName )
    v5 = (const char *)blockName;
  while ( strcmp((const char *)g_ex_configPairs[v6].block, v5)
       || strcmp((const char *)g_ex_configPairs[v6].key, (const char *)keyName) )
  {
    if ( v6++ >= 29 )
      return 0;
  }
  if ( v6 < 0 )
    return 0;
  key = &g_mob_configGlobals;
  v10 = g_mob_configGlobals.keyValues == 0;
  if ( g_mob_configGlobals.keyValues )
  {
    key = (MOB_ConfigGlobals_0 *)g_mob_configGlobals.keyValues->key;
    v10 = g_mob_configGlobals.keyValues->key == MOB_ConfigKey_NULL;
  }
  if ( v10 )
    return 0;
  p_value = &g_mob_configGlobals.keyValues->value;
  while ( key != (MOB_ConfigGlobals_0 *)v6 )
  {
    key = (MOB_ConfigGlobals_0 *)p_value[1].stringVal;
    p_value += 2;
    if ( !key )
      return 0;
  }
  *ret = (const unsigned __int8 *)p_value->intVal;
  return 1;
}

//----- (002616DC) --------------------------------------------------------
int __fastcall MOB_Local_FindConfigValue(MOB_ConfigKey key, MOB_ConfigValue *outValue)
{
  MOB_ConfigGlobals_0 *stringVal; // r2
  bool v3; // zf
  MOB_ConfigValue *p_value; // r3

  stringVal = &g_mob_configGlobals;
  v3 = g_mob_configGlobals.keyValues == 0;
  if ( g_mob_configGlobals.keyValues )
  {
    stringVal = (MOB_ConfigGlobals_0 *)g_mob_configGlobals.keyValues->key;
    v3 = g_mob_configGlobals.keyValues->key == MOB_ConfigKey_NULL;
  }
  if ( v3 )
    return 0;
  p_value = &g_mob_configGlobals.keyValues->value;
  while ( stringVal != (MOB_ConfigGlobals_0 *)key )
  {
    stringVal = (MOB_ConfigGlobals_0 *)p_value[1].stringVal;
    p_value += 2;
    if ( !stringVal )
      return 0;
  }
  outValue->stringVal = p_value->stringVal;
  return 1;
}

//----- (00261710) --------------------------------------------------------
int __fastcall MOB_Local_ConfigValueExists(MOB_ConfigKey key)
{
  MOB_ConfigKey v1; // r2
  bool v2; // zf
  const MOB_ConfigKeyValue *v3; // r1
  MOB_ConfigKey v5; // t1

  v2 = g_mob_configGlobals.keyValues == 0;
  if ( g_mob_configGlobals.keyValues )
  {
    v1 = g_mob_configGlobals.keyValues->key;
    v2 = g_mob_configGlobals.keyValues->key == MOB_ConfigKey_NULL;
  }
  if ( v2 )
    return 0;
  v3 = g_mob_configGlobals.keyValues + 1;
  while ( v1 != key )
  {
    v5 = v3->key;
    ++v3;
    v1 = v5;
    if ( v5 == MOB_ConfigKey_NULL )
      return 0;
  }
  return 1;
}
// 261726: variable 'v1' is possibly undefined

//----- (0026173C) --------------------------------------------------------
const unsigned __int8 *__fastcall MOB_Local_GetConfigValue(MOB_ConfigKey key, const unsigned __int8 *def)
{
  MOB_ConfigKey stringVal; // r3
  bool v3; // zf
  MOB_ConfigValue *p_value; // r2

  v3 = g_mob_configGlobals.keyValues == 0;
  if ( g_mob_configGlobals.keyValues )
  {
    stringVal = g_mob_configGlobals.keyValues->key;
    v3 = g_mob_configGlobals.keyValues->key == MOB_ConfigKey_NULL;
  }
  if ( v3 )
    return def;
  p_value = &g_mob_configGlobals.keyValues->value;
  while ( stringVal != key )
  {
    stringVal = (MOB_ConfigKey)p_value[1].stringVal;
    p_value += 2;
    if ( stringVal == MOB_ConfigKey_NULL )
      return def;
  }
  return (const unsigned __int8 *)p_value->intVal;
}
// 261752: variable 'stringVal' is possibly undefined

//----- (0026176C) --------------------------------------------------------
int __fastcall MOB_Local_GetConfigValueBool(MOB_ConfigKey key, int def)
{
  MOB_ConfigKey stringVal; // r3
  bool v3; // zf
  MOB_ConfigValue *p_value; // r2
  int intVal; // r1

  v3 = g_mob_configGlobals.keyValues == 0;
  if ( g_mob_configGlobals.keyValues )
  {
    stringVal = g_mob_configGlobals.keyValues->key;
    v3 = g_mob_configGlobals.keyValues->key == MOB_ConfigKey_NULL;
  }
  if ( v3 )
    return def;
  p_value = &g_mob_configGlobals.keyValues->value;
  while ( stringVal != key )
  {
    stringVal = (MOB_ConfigKey)p_value[1].stringVal;
    p_value += 2;
    if ( stringVal == MOB_ConfigKey_NULL )
      return def;
  }
  intVal = p_value->intVal;
  if ( p_value->intVal )
    return 1;
  return intVal;
}
// 261782: variable 'stringVal' is possibly undefined

//----- (002617A0) --------------------------------------------------------
int __fastcall MOB_Local_ConfigValueFloat(MOB_ConfigKey key, float *ret)
{
  MOB_ConfigGlobals_0 *v2; // r2
  bool v3; // zf
  MOB_ConfigValue *p_value; // r3
  MOB_ConfigValue v5; // r2

  v2 = &g_mob_configGlobals;
  v3 = g_mob_configGlobals.keyValues == 0;
  if ( g_mob_configGlobals.keyValues )
  {
    v2 = (MOB_ConfigGlobals_0 *)g_mob_configGlobals.keyValues->key;
    v3 = g_mob_configGlobals.keyValues->key == MOB_ConfigKey_NULL;
  }
  if ( v3 )
    return 0;
  p_value = &g_mob_configGlobals.keyValues->value;
  if ( v2 == (MOB_ConfigGlobals_0 *)key )
  {
LABEL_8:
    *ret = p_value->floatVal;
    return 1;
  }
  else
  {
    while ( 1 )
    {
      v5.stringVal = p_value[1].stringVal;
      p_value += 2;
      if ( !v5.intVal )
        return 0;
      if ( v5.intVal == key )
        goto LABEL_8;
    }
  }
}

//----- (002617DC) --------------------------------------------------------
void FreeHrtfs()
{
  Hrtf *i; // r4

  for ( i = LoadedHrtfs; LoadedHrtfs; i = LoadedHrtfs )
  {
    LoadedHrtfs = i->next;
    free((void *)i->azCount);
    free((void *)i->evOffset);
    free((void *)i->coeffs);
    free((void *)i->delays);
    free(i);
  }
}

//----- (00261824) --------------------------------------------------------
ALCboolean __fastcall alc_loopback_init(BackendFuncs *func_list)
{
  void (**p_StopPlayback)(ALCdevice *); // r0

  *(_QWORD *)&func_list->StopCapture = *(_QWORD *)&loopback_funcs.StopCapture;
  *(_QWORD *)&func_list->AvailableSamples = *(_QWORD *)&loopback_funcs.AvailableSamples;
  *(_QWORD *)&func_list->Unlock = *(_QWORD *)&loopback_funcs.Unlock;
  *(_QWORD *)&func_list->OpenPlayback = *(_QWORD *)&loopback_funcs.OpenPlayback;
  *(_QWORD *)&func_list->ResetPlayback = *(_QWORD *)&loopback_funcs.ResetPlayback;
  p_StopPlayback = &func_list->StopPlayback;
  *(_QWORD *)p_StopPlayback = *(_QWORD *)&loopback_funcs.StopPlayback;
  *((_QWORD *)p_StopPlayback + 1) = *(_QWORD *)&loopback_funcs.CloseCapture;
  return 1;
}

//----- (00261860) --------------------------------------------------------
ALCboolean __fastcall alc_opensl_init(BackendFuncs *func_list)
{
  void (**p_StopPlayback)(ALCdevice *); // r0

  *(_QWORD *)&func_list->StopCapture = *(_QWORD *)&opensl_funcs.StopCapture;
  *(_QWORD *)&func_list->AvailableSamples = *(_QWORD *)&opensl_funcs.AvailableSamples;
  *(_QWORD *)&func_list->Unlock = *(_QWORD *)&opensl_funcs.Unlock;
  *(_QWORD *)&func_list->OpenPlayback = *(_QWORD *)&opensl_funcs.OpenPlayback;
  *(_QWORD *)&func_list->ResetPlayback = *(_QWORD *)&opensl_funcs.ResetPlayback;
  p_StopPlayback = &func_list->StopPlayback;
  *(_QWORD *)p_StopPlayback = *(_QWORD *)&opensl_funcs.StopPlayback;
  *((_QWORD *)p_StopPlayback + 1) = *(_QWORD *)&opensl_funcs.CloseCapture;
  return 1;
}

//----- (0026189C) --------------------------------------------------------
void __fastcall alc_opensl_probe(DevProbe type)
{
  ALCchar *v1; // r0
  size_t v2; // r3

  if ( type == ALL_DEVICE_PROBE )
  {
    v1 = (ALCchar *)realloc(alcAllDevicesList, alcAllDevicesListSize + 8);
    if ( v1 )
    {
      v2 = alcAllDevicesListSize;
      alcAllDevicesList = v1;
      *(_DWORD *)&v1[alcAllDevicesListSize] = 1852141647;
      strcpy((char *)&v1[v2 + 4], "SL");
      alcAllDevicesListSize = v2 + 7;
      v1[v2 + 7] = 0;
    }
    else if ( LogLevel_0 )
    {
      al_print("(EE)", "AppendList", "Realloc failed to add %s!\n", (const char *)opensl_device);
    }
  }
}

//----- (0026193C) --------------------------------------------------------
void __fastcall DecodeIMA4Block(ALshort *dst, const ALima4 *src, ALint numchans)
{
  int16x4_t *v3; // r9
  const ALima4 *v4; // r10
  int v5; // r4
  ALshort *v6; // r5
  const ALima4 *v7; // r4
  int16x4_t *v8; // r3
  int v9; // r0
  int v10; // r12
  bool v11; // lr
  bool v12; // cc
  int16x4_t *v13; // r6
  int v14; // r9
  const ALima4 *v15; // r4
  int v16; // r8
  char v17; // r10
  bool v18; // zf
  int32x4_t v19; // q9
  int64x2_t v20; // q8
  int32x4_t *v21; // r4
  int64x2_t *v22; // r6
  int32x4_t v23; // q9
  int v24; // r11
  int32x4_t v25; // q11
  const ALima4 *v26; // r8
  __int64 v27; // d24
  __int64 v28; // d25
  uint16x4_t v29; // d26
  uint16x4_t v30; // d27
  uint16x4_t v31; // d29
  uint16x4_t v32; // d28
  unsigned __int16 v33; // r1
  unsigned __int16 v34; // r2
  int64x2_t v35; // q12
  int64x2_t v36; // q15
  int32x4_t v37; // q13
  int v38; // r12
  _WORD *v39; // lr
  int *v40; // r3
  ALima4 *v41; // r6
  int v42; // r0
  int v43; // r0
  int v44; // r5
  __int16 v45; // r4
  int v46; // r5
  char *v47; // r12
  int v48; // r8
  char *v49; // r4
  ALint v50; // r3
  const ALima4 *v51; // r6
  int v52; // r0
  int v53; // r0
  int v54; // r0
  int v55; // r5
  int v56; // r1
  _WORD *v57; // r8
  char *v58; // r1
  ALint v59; // r2
  int *v60; // r12
  int *v61; // r9
  int v62; // r0
  int v63; // r6
  int v64; // r0
  int v65; // r3
  int v66; // [sp+0h] [bp-B0h]
  int v67; // [sp+4h] [bp-ACh]
  int v68; // [sp+8h] [bp-A8h]
  int v69; // [sp+8h] [bp-A8h]
  int v70; // [sp+Ch] [bp-A4h]
  char *v71; // [sp+Ch] [bp-A4h]
  const ALima4 *v72; // [sp+10h] [bp-A0h]
  const ALima4 *v73; // [sp+10h] [bp-A0h]
  bool v74; // [sp+14h] [bp-9Ch]
  int v75; // [sp+14h] [bp-9Ch]
  int v76; // [sp+18h] [bp-98h]
  ALint v77; // [sp+1Ch] [bp-94h]
  int v78; // [sp+20h] [bp-90h]
  int16x4_t *v79; // [sp+24h] [bp-8Ch]
  _WORD *v80; // [sp+24h] [bp-8Ch]
  char v81[36]; // [sp+28h] [bp-88h] BYREF
  ALima4 v82[36]; // [sp+4Ch] [bp-64h] BYREF
  ALima4 v83[64]; // [sp+70h] [bp-40h] BYREF

  v3 = (int16x4_t *)dst;
  v66 = 4 * numchans;
  v77 = numchans;
  if ( numchans < 1 )
    goto LABEL_35;
  v4 = src;
  v5 = 0;
  if ( (unsigned int)numchans <= 3 )
    goto LABEL_28;
  v5 = 0;
  if ( numchans == (numchans & 3) )
    goto LABEL_27;
  v6 = &dst[numchans];
  v68 = numchans - (numchans & 3);
  v70 = numchans & 3;
  v7 = &src[4 * numchans];
  v8 = (int16x4_t *)&v82[4 * numchans];
  v74 = v7 > (const ALima4 *)dst;
  v9 = 0;
  v10 = 0;
  if ( v8 > (int16x4_t *)src )
    v9 = 1;
  if ( v7 > v82 )
    v10 = 1;
  v11 = v8 > v3;
  v12 = v7 > v83;
  v13 = v3;
  v14 = 0;
  v15 = &v83[4 * numchans];
  if ( v12 )
    v14 = 1;
  v16 = 0;
  v72 = src;
  if ( v15 > src )
    v16 = 1;
  v17 = 0;
  v79 = v13;
  if ( v15 > (const ALima4 *)v13 )
    v17 = 1;
  if ( v83 < (ALima4 *)v8 && v82 < v15 )
  {
    v3 = v13;
    v5 = 0;
    goto LABEL_27;
  }
  v18 = ((v83 < (ALima4 *)v6) & (unsigned __int8)v17) == 0;
  v5 = 0;
  if ( ((v83 < (ALima4 *)v6) & (unsigned __int8)v17) == 0 )
    v18 = (v14 & v16) == 0;
  if ( !v18 )
  {
    v3 = v13;
LABEL_27:
    v4 = src;
    goto LABEL_28;
  }
  v3 = v13;
  if ( v82 < (ALima4 *)v6 && v11 || (v9 & v10) != 0 )
    goto LABEL_27;
  v4 = src;
  if ( v6 > (ALshort *)src && v74 )
    goto LABEL_28;
  v19.n128_u64[0] = 0x1000000010LL;
  v19.n128_u64[1] = 0x1000000010LL;
  v20.n128_u64[0] = 0xFF000000FFLL;
  v20.n128_u64[1] = 0xFF000000FFLL;
  v21 = (int32x4_t *)v83;
  v22 = (int64x2_t *)v82;
  v23 = vnegq_s32(v19);
  v4 = &src[4 * v68];
  v24 = numchans - (numchans & 3);
  v25.n128_u64[0] = 0x5800000058LL;
  v25.n128_u64[1] = 0x5800000058LL;
  v26 = src;
  do
  {
    v27 = *(_QWORD *)v26;
    v28 = *((_QWORD *)v26 + 1);
    v26 += 16;
    v24 -= 4;
    v29.n64_u16[0] = BYTE3(v27);
    v30.n64_u16[0] = BYTE1(v27);
    v29.n64_u16[1] = HIBYTE(v27);
    v31.n64_u16[0] = (unsigned __int8)v27;
    v32.n64_u16[0] = BYTE2(v27);
    v30.n64_u16[1] = BYTE5(v27);
    v32.n64_u16[1] = BYTE6(v27);
    v29.n64_u16[2] = BYTE3(v28);
    v33 = BYTE6(v28);
    v31.n64_u16[1] = BYTE4(v27);
    v34 = BYTE4(v28);
    v32.n64_u16[2] = BYTE2(v28);
    v29.n64_u16[3] = HIBYTE(v28);
    v30.n64_u16[2] = BYTE1(v28);
    v31.n64_u16[2] = (unsigned __int8)v28;
    v30.n64_u16[3] = BYTE5(v28);
    v35 = vshlq_n_s32(vandq_s64(vmovl_u16(v29), v20), 8u);
    v32.n64_u16[3] = v33;
    v31.n64_u16[3] = v34;
    v36 = vandq_s64(vmovl_u16(v32), v20);
    *v22 = v36;
    v37 = vshlq_s32(
            v23,
            vshlq_n_s32(
              vorrq_s64(vshlq_n_s32(vandq_s64(vmovl_u16(v30), v20), 8u), vandq_s64(vmovl_u16(v31), v20)),
              0x10u));
    *v21++ = v37;
    *v22++ = vminq_s32(vmaxq_s32(vshlq_s32(v23, vshlq_n_s32(vorrq_s64(v35, v36), 0x10u)), (int32x4_t)0LL), v25);
    v3->n64_u64[0] = vmovn_s32(v37).n64_u64[0];
    ++v3;
  }
  while ( v24 );
  numchans = v77;
  src = v72;
  v3 = v79;
  v5 = v68;
  if ( v70 )
  {
LABEL_28:
    v38 = numchans - v5;
    v39 = (_WORD *)v3 + v5;
    v40 = (int *)&v82[4 * v5];
    v41 = &v83[4 * v5];
    do
    {
      v42 = *v4;
      *(_DWORD *)v41 = v42;
      v43 = (__int16)(v42 | (v4[1] << 8));
      *(_DWORD *)v41 = v43;
      v41 += 4;
      v44 = v4[2];
      *v40 = v44;
      v45 = v4[3];
      v4 += 4;
      v46 = (__int16)(v44 | (v45 << 8));
      if ( v46 <= 0 )
        v46 = 0;
      if ( v46 >= 88 )
        v46 = 88;
      --v38;
      *v40++ = v46;
      *v39++ = v43;
    }
    while ( v38 );
  }
  src += v66;
LABEL_35:
  v47 = (char *)v3 + 2 * numchans;
  v75 = 2 * numchans;
  v67 = 16 * numchans;
  v48 = 1;
  v76 = 9;
  do
  {
    if ( numchans >= 1 )
    {
      v49 = v81;
      v50 = numchans;
      v51 = src;
      do
      {
        v52 = *v51;
        --v50;
        *(_DWORD *)v49 = v52;
        v53 = v52 | (v51[1] << 8);
        *(_DWORD *)v49 = v53;
        v54 = v53 | (v51[2] << 16);
        *(_DWORD *)v49 = v54;
        v55 = v51[3];
        v51 += 4;
        *(_DWORD *)v49 = v54 | (v55 << 24);
        v49 += 4;
      }
      while ( v50 );
      src += v66;
    }
    v73 = src;
    v56 = v48;
    v80 = v47;
    v69 = v48;
    v71 = v47;
    do
    {
      v78 = v56;
      if ( numchans >= 1 )
      {
        v57 = v80;
        v58 = v81;
        v59 = v77;
        v60 = (int *)v82;
        v61 = (int *)v83;
        do
        {
          v62 = *(_DWORD *)v58 & 0xF;
          *(_DWORD *)v58 >>= 4;
          v58 += 4;
          v63 = IMA4Codeword[v62];
          v64 = IMA4Index_adjust[v62] + *v60;
          v65 = *v61 + IMAStep_size[*v60] * v63 / 8;
          if ( v65 <= -32768 )
            v65 = -32768;
          if ( v65 >= 0x7FFF )
            v65 = 0x7FFF;
          *v61++ = v65;
          if ( v64 <= 0 )
            v64 = 0;
          if ( v64 >= 88 )
            v64 = 88;
          --v59;
          *v60++ = v64;
          *v57++ = v65;
        }
        while ( v59 );
      }
      numchans = v77;
      v80 = (_WORD *)((char *)v80 + v75);
      v56 = v78 + 1;
    }
    while ( v78 + 1 != v76 );
    v47 = &v71[v67];
    v76 += 8;
    v48 = v69 + 8;
    src = v73;
  }
  while ( v69 <= 56 );
}
// 26193C: using guessed type ALima4 var_64[36];
// 26193C: using guessed type ALima4 var_40[64];

//----- (00261D34) --------------------------------------------------------
void __fastcall EncodeIMA4Block(ALima4 *dst, const ALshort *src, ALint *sample, ALint *index, int a5)
{
  int v5; // r5
  ALint *v6; // r4
  ALint *v8; // r8
  int v9; // r0
  ALint *v10; // r10
  const ALshort *v11; // r2
  ALima4 *v12; // r11
  int v13; // r9
  int v14; // r5
  int v15; // r0
  int v16; // r1
  unsigned int v17; // r0
  int v18; // r1
  int v19; // r0
  int v20; // r1
  int v21; // r0
  int v22; // t1
  int v23; // t1
  const ALshort *v24; // r10
  int v25; // r0
  int v26; // r8
  ALima4 *v27; // r11
  int v28; // r9
  ALint v29; // r5
  int v30; // r6
  int v31; // r0
  int v32; // r1
  unsigned int v33; // r0
  int v34; // r1
  int v35; // r6
  int v36; // r1
  int v37; // r1
  int v38; // [sp+0h] [bp-38h]
  const ALshort *v39; // [sp+4h] [bp-34h]
  int v40; // [sp+4h] [bp-34h]
  const ALshort *v41; // [sp+8h] [bp-30h]
  const ALshort *v42; // [sp+Ch] [bp-2Ch]
  int v43; // [sp+10h] [bp-28h]
  int v44; // [sp+10h] [bp-28h]
  ALint *v45; // [sp+18h] [bp-20h]

  v5 = a5;
  v6 = index;
  v45 = sample;
  if ( a5 > 0 )
  {
    v8 = sample;
    v9 = a5;
    v10 = index;
    v11 = src;
    v12 = dst;
    v39 = src;
    do
    {
      v43 = v9;
      v13 = IMAStep_size[*v10];
      v14 = *v11 - *v8;
      v15 = 2 * v13;
      v16 = v14;
      if ( v14 < 0 )
        v16 = *v8 - *v11;
      if ( v15 > v16 )
        v15 = v16;
      v17 = ((unsigned int)v14 >> 28) & 8 | ((8 * v15 / v13 - 1 + ((unsigned int)(8 * v15 / v13 - 1) >> 31)) >> 1);
      v18 = IMA4Codeword[v17];
      v19 = IMA4Index_adjust[v17];
      v20 = *v8 + v18 * v13 / 8;
      if ( v20 <= -32768 )
        v20 = -32768;
      if ( v20 >= 0x7FFF )
        v20 = 0x7FFF;
      *v8 = v20;
      v21 = v19 + *v10;
      if ( v21 <= 0 )
        v21 = 0;
      if ( v21 >= 88 )
        v21 = 88;
      *v10 = v21;
      *v12 = *v8;
      v22 = *v8++;
      v12[1] = BYTE1(v22);
      v12[2] = *v10;
      v23 = *v10++;
      v12[3] = BYTE1(v23);
      v12 += 4;
      ++v11;
      v9 = v43 - 1;
    }
    while ( v43 != 1 );
    sample = v45;
    v5 = a5;
    dst += 4 * a5;
    src = v39;
  }
  v24 = &src[v5];
  v44 = 2 * v5;
  v38 = 8 * v5;
  v25 = 1;
  do
  {
    v40 = v25;
    v41 = v24;
    if ( v5 >= 1 )
    {
      v26 = 0;
      v27 = dst;
      do
      {
        v28 = 0;
        v42 = v24;
        do
        {
          v29 = sample[v26];
          v30 = IMAStep_size[v6[v26]];
          v31 = 2 * v30;
          v32 = *v24 - v29;
          if ( v32 < 0 )
            v32 = v29 - *v24;
          if ( v31 > v32 )
            v31 = v32;
          v33 = ((unsigned int)(*v24 - v29) >> 28) & 8 | ((8 * v31 / v30 - 1) / 2);
          v34 = IMA4Codeword[v33] * v30;
          v35 = IMA4Index_adjust[v33];
          v36 = v29 + v34 / 8;
          if ( v36 <= -32768 )
            v36 = -32768;
          if ( v36 >= 0x7FFF )
            v36 = 0x7FFF;
          sample = v45;
          v45[v26] = v36;
          v6 = index;
          v37 = index[v26] + v35;
          dst = v27;
          if ( v37 <= 0 )
            v37 = 0;
          if ( v37 >= 88 )
            v37 = 88;
          index[v26] = v37;
          if ( v28 << 31 )
          {
            dst = v27 + 1;
            LOBYTE(v33) = *v27 | (16 * v33);
          }
          ++v28;
          *v27 = v33;
          v27 = dst;
          v24 = (const ALshort *)((char *)v24 + v44);
        }
        while ( v28 != 8 );
        ++v26;
        v27 = dst;
        v24 = v42 + 1;
        v5 = a5;
      }
      while ( v26 != a5 );
    }
    v24 = &v41[v38];
    v25 = v40 + 8;
  }
  while ( v40 < 57 );
}

//----- (00261F50) --------------------------------------------------------
ALvoid __fastcall EAXVerbProcess(
        ALeffectState_0 *effect,
        ALuint SamplesToDo,
        const ALfloat *SamplesIn,
        ALfloat (*SamplesOut)[2048])
{
  int32x2_t v4; // d1
  ALvoid (*Update)(ALeffectState *, ALCdevice *, const ALeffectslot *); // r11
  ALuint v8; // r0
  float *v9; // r10
  ALvoid (*v10)(ALeffectState *, ALCdevice *, const ALeffectslot *); // s22
  ALvoid (*Destroy)(ALeffectState *); // s24
  ALvoid (*Process)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]); // s26
  float v13; // s30
  float v14; // s28
  float v15; // s0
  __int64 v16; // r0
  float v17; // s0
  float v18; // s4
  unsigned int v19; // r2
  float v20; // s6
  float v21; // s8
  __int64 v22; // r4
  ALboolean (*DeviceUpdate)(ALeffectState *, ALCdevice *); // r12
  __int64 v24; // kr00_8
  ALvoid (*v25)(ALeffectState *, ALCdevice *, const ALeffectslot *); // r2
  float v26; // s0
  float v27; // s4
  float v28; // s6
  float v29; // s8
  float v30; // s0
  float v31; // s4
  float v32; // s6
  ALvoid (*v33)(ALeffectState *); // s8
  float v34; // s22
  float v35; // s0
  __int64 v36; // r0
  ALboolean (*v37)(ALeffectState *, ALCdevice *); // r3
  ALvoid (*v38)(ALeffectState *, ALCdevice *, const ALeffectslot *); // r0
  __int64 v39; // r2
  int v40; // r1
  float v41; // s4
  float32x4_t *v42; // r1
  float32x4_t v43; // q8
  float v44; // s0
  ALvoid (*v45)(ALeffectState *, ALCdevice *, const ALeffectslot *); // s4
  ALvoid (*v46)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]); // s6
  __int64 v47; // r2
  int v48; // r1
  float v49; // s0
  float v50; // s8
  ALeffectState_0 *v51; // r12
  ALvoid (**p_Process)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]); // r8
  ALboolean (**p_DeviceUpdate)(ALeffectState *, ALCdevice *); // r10
  int v54; // r3
  int i; // r5
  int v56; // r0
  float v57; // s4
  float v58; // s2
  float *v59; // r6
  ALuint v60; // r1
  ALfloat (*v61)[2048]; // r4
  float v62; // s6
  float *v63; // r0
  ALuint v64; // r1
  ALfloat (*v65)[2048]; // r4
  float v66; // s4
  ALeffectState_0 *v67; // [sp+0h] [bp-80h]
  ALuint v69; // [sp+8h] [bp-78h]
  const ALfloat *v70; // [sp+Ch] [bp-74h]
  ALfloat in[28]; // [sp+10h] [bp-70h] BYREF
  float32x4_t v72; // 0:d18.8,8:d19.8

  v67 = effect + 2078;
  if ( SamplesToDo )
  {
    Update = effect[29].Update;
    v9 = (float *)&effect[2078];
    v8 = SamplesToDo;
    do
    {
      v69 = v8;
      v70 = SamplesIn;
      v10 = effect[1].Update;
      Destroy = effect[2].Destroy;
      Process = effect[3].Process;
      v13 = *SamplesIn + (float)(*(float *)&v10 * (float)(*(float *)&effect[1].Process - *SamplesIn));
      v14 = (float)(*(float *)&effect[3].DeviceUpdate - *(float *)&Process) * *(float *)&effect[3].Update;
      v15 = cosf((float)((float)(unsigned int)effect[2].Process * 6.2832) / (float)(unsigned int)effect[3].Destroy);
      v16 = *(_QWORD *)&effect[2].DeviceUpdate;
      *(float *)&effect[1].Process = v13;
      v17 = (float)((float)(1.0 - v15) * (float)(*(float *)&Process + v14)) + 1.0;
      v18 = v13 + (float)(*(float *)&v10 * (float)(*(float *)&Destroy - v13));
      *(float *)&effect[3].Process = *(float *)&Process + v14;
      *(float *)&effect[2].Destroy = v18;
      v19 = (unsigned int)Update - (int)v17;
      v20 = *(float *)(HIDWORD(v16) + 4 * (v19 & v16));
      v21 = *(float *)(HIDWORD(v16) + 4 * ((v19 - 1) & v16));
      *(float *)(HIDWORD(v16) + 4 * (v16 & (unsigned int)Update)) = v18;
      v22 = *(_QWORD *)&effect[4].Destroy;
      LODWORD(v16) = effect[29].Update;
      effect[2].Process = (ALvoid (*)(ALeffectState *, ALuint, const ALfloat *, ALfloat (*)[2048]))(((unsigned int)effect[2].Process + 1)
                                                                                                  % (unsigned int)effect[3].Destroy);
      *(float *)(HIDWORD(v22) + 4 * (v16 & v22)) = v20
                                                 + (float)((float)(v21 - v20)
                                                         * (float)(v17 - (float)(unsigned int)(int)v17));
      LODWORD(v16) = effect[29].Update;
      DeviceUpdate = effect[6].DeviceUpdate;
      v24 = *(_QWORD *)&effect[8].Update;
      v25 = effect[6].Update;
      v4.n64_f32[0] = *(float *)&effect[5].Update
                    * *((float *)effect[7].Destroy + ((__int64)effect[6].Process & (v16 - v24)));
      v26 = *(float *)&effect[5].DeviceUpdate
          * *((float *)v25 + ((unsigned int)DeviceUpdate & (v16 - (unsigned int)effect[8].DeviceUpdate)));
      v27 = *(float *)&effect[5].Process
          * *((float *)effect[7].Update + ((v16 - HIDWORD(v24)) & (__int64)effect[7].DeviceUpdate));
      v28 = *(float *)&effect[6].Destroy
          * *((float *)effect[8].Destroy + ((__int64)effect[7].Process & (v16 - (unsigned int)effect[9].Destroy)));
      v29 = *((float *)effect[4].DeviceUpdate + ((__int64)effect[4].Destroy & (v16 - (unsigned int)effect[4].Update)))
          + (float)((float)((float)((float)(v26 + v4.n64_f32[0]) + v27) + v28) * 0.5);
      v30 = v29 - v26;
      v4.n64_f32[0] = v29 - v4.n64_f32[0];
      v31 = v29 - v27;
      v32 = v29 - v28;
      *((float *)v25 + (v16 & (unsigned int)DeviceUpdate)) = v30;
      *((_DWORD *)effect[7].Destroy + ((int)effect[6].Process & (int)effect[29].Update)) = v4.n64_u32[0];
      *((float *)effect[7].Update + ((int)effect[7].DeviceUpdate & (int)effect[29].Update)) = v31;
      *((float *)effect[8].Destroy + ((int)effect[7].Process & (int)effect[29].Update)) = v32;
      v33 = effect[5].Destroy;
      *v9 = v30 * *(float *)&v33;
      v9[1] = v4.n64_f32[0] * *(float *)&v33;
      v9[2] = v31 * *(float *)&v33;
      v9[3] = v32 * *(float *)&v33;
      HIDWORD(v16) = effect[29].Update;
      v34 = *((float *)effect[4].DeviceUpdate
            + ((HIDWORD(v16) - (unsigned int)effect[4].Process) & (unsigned int)effect[4].Destroy));
      v35 = v34 * *(float *)&effect[13].Destroy;
      *((float *)effect[11].Process + ((int)effect[11].Update & HIDWORD(v16))) = v35;
      in[0] = v35;
      v36 = *(_QWORD *)&effect[11].Update;
      v37 = effect[12].DeviceUpdate;
      HIDWORD(v22) = effect[12].Update;
      LODWORD(v22) = effect[29].Update;
      in[1] = *(ALfloat *)(HIDWORD(v36) + 4 * ((v22 - (unsigned int)effect[12].Destroy) & v36));
      in[2] = *(ALfloat *)(HIDWORD(v36) + 4 * ((v22 - (_DWORD)v37) & v36));
      in[3] = *(ALfloat *)(HIDWORD(v36) + 4 * (v36 & (v22 - HIDWORD(v22))));
      LateReverb((ALverbState_0 *)effect, in, v9 - 0x2000);
      v38 = effect[29].Update;
      v39 = *(_QWORD *)&effect[26].DeviceUpdate;
      v40 = ((char *)v38 - (char *)effect[28].Destroy) & v39;
      LODWORD(v39) = (char *)effect + 468;
      v72 = (float32x4_t)vld1q_dup_f32((const float *)v39);
      v41 = *(float *)(HIDWORD(v39) + 4 * v40);
      v42 = (float32x4_t *)(v9 - 0x2000);
      v43 = (float32x4_t)*((_OWORD *)v9 - 2048);
      v9 += 4;
      v44 = *(float *)&effect[27].DeviceUpdate * v41;
      v4.n64_f32[0] = *(float *)&effect[29].Destroy * v44;
      *v42 = vaddq_f32(vdupq_lane_s32(v4, 0), vmulq_f32(v72, v43));
      v45 = effect[27].Update;
      v46 = effect[27].Process;
      v47 = *(_QWORD *)&effect[26].Process;
      v48 = ((char *)v38 - (char *)effect[28].DeviceUpdate) & v47;
      v49 = (float)(v44 + (float)(v34 * *(float *)&effect[26].Destroy))
          + (float)(*(float *)&effect[28].Update
                  * (float)(*(float *)&effect[28].Process - (float)(v44 + (float)(v34 * *(float *)&effect[26].Destroy))));
      *(float *)&effect[28].Process = v49;
      v50 = *(float *)(HIDWORD(v47) + 4 * v48);
      *(float *)(HIDWORD(v47) + 4 * ((unsigned int)v38 & v47)) = v49
                                                               + (float)(*(float *)&v45
                                                                       * (float)(v50 - (float)(v49 * *(float *)&v45)));
      SamplesIn = v70 + 1;
      *((float *)effect[26].Update + ((int)effect[26].DeviceUpdate & (int)effect[29].Update)) = (float)(*(float *)&v46 * v50)
                                                                                              - (float)(v49 * *(float *)&v45);
      Update = (ALvoid (*)(ALeffectState *, ALCdevice *, const ALeffectslot *))((char *)effect[29].Update + 1);
      effect[29].Update = Update;
      v8 = v69 - 1;
    }
    while ( v69 != 1 );
  }
  v51 = effect + 30;
  p_Process = &effect[23].Process;
  p_DeviceUpdate = &effect[9].DeviceUpdate;
  v54 = 0;
  for ( i = 0; i != 9; ++i )
  {
    v56 = (4 * v54) & 0xC;
    v57 = *(float *)&p_DeviceUpdate[i];
    v58 = *(float *)&p_Process[i];
    if ( v57 > 0.00001 && SamplesToDo )
    {
      v59 = (float *)((char *)v67 + v56);
      v60 = SamplesToDo;
      v61 = SamplesOut;
      do
      {
        v62 = *v59;
        v59 += 4;
        --v60;
        (*v61)[0] = (*v61)[0] + (float)(v57 * v62);
        v61 = (ALfloat (*)[2048])((char *)v61 + 4);
      }
      while ( v60 );
    }
    if ( v58 > 0.00001 && SamplesToDo )
    {
      v63 = (float *)((char *)v51 + v56);
      v64 = SamplesToDo;
      v65 = SamplesOut;
      do
      {
        v66 = *v63;
        v63 += 4;
        --v64;
        (*v65)[0] = (*v65)[0] + (float)(v58 * v66);
        v65 = (ALfloat (*)[2048])((char *)v65 + 4);
      }
      while ( v64 );
    }
    ++v54;
    ++SamplesOut;
  }
}
// 26223A: variable 'v4' is possibly undefined

//----- (00262384) --------------------------------------------------------
ALvoid __fastcall LateReverb(ALverbState_0 *State, const ALfloat *in, ALfloat *out)
{
  ALuint Offset; // r12
  float ApFeedCoeff; // s6
  float v5; // s8
  float *v6; // r3
  float v7; // s0
  ALfloat v8; // s4
  float v9; // s0
  float v10; // s2
  float v11; // s2
  float *v12; // r3
  ALfloat v13; // s10
  float v14; // s2
  float v15; // s2
  float *v16; // r3
  ALfloat v17; // s12
  float v18; // s2
  DelayLine_0 v19; // kr00_8
  ALuint v20; // r5
  ALfloat v21; // s2
  float v22; // s14
  float v23; // s0
  float v24; // s4
  ALuint v25; // r3
  DelayLine_0 v26; // kr08_8
  float v27; // s3
  float v28; // s6
  float v29; // s4
  ALuint v30; // r3
  DelayLine_0 v31; // kr10_8
  float v32; // s7
  float v33; // s10
  float v34; // s4
  DelayLine_0 v35; // kr18_8
  ALuint v36; // r4
  float v37; // s1
  float v38; // s12
  float MixCoeff; // s3
  float Gain; // s2
  float v41; // s14
  float v42; // s1
  ALfloat v43; // s4
  ALfloat v44; // s6
  ALfloat v45; // s0

  Offset = State->Offset;
  ApFeedCoeff = State->Late.ApFeedCoeff;
  v5 = State->Late.Coeff[1];
  v6 = &State->Late.Delay[0].Line[(Offset - State->Late.Offset[0]) & State->Late.Delay[0].Mask];
  v7 = in[2]
     + (float)(State->Late.Coeff[2]
             * State->Late.Delay[2].Line[(Offset - State->Late.Offset[2]) & State->Late.Delay[2].Mask]);
  v8 = v7 + (float)(State->Late.LpCoeff[2] * (float)(State->Late.LpSample[2] - v7));
  v9 = State->Late.ApCoeff[0];
  v10 = State->Late.Coeff[0];
  State->Late.LpSample[2] = v8;
  v11 = v10 * *v6;
  v12 = &State->Late.Delay[3].Line[(Offset - State->Late.Offset[3]) & State->Late.Delay[3].Mask];
  v13 = (float)(*in + v11) + (float)(State->Late.LpCoeff[0] * (float)(State->Late.LpSample[0] - (float)(*in + v11)));
  v14 = State->Late.Coeff[3];
  State->Late.LpSample[0] = v13;
  v15 = v14 * *v12;
  v16 = &State->Late.Delay[1].Line[(Offset - State->Late.Offset[1]) & State->Late.Delay[1].Mask];
  v17 = (float)(in[3] + v15) + (float)(State->Late.LpCoeff[3] * (float)(State->Late.LpSample[3] - (float)(in[3] + v15)));
  State->Late.LpSample[3] = v17;
  v18 = in[1] + (float)(v5 * *v16);
  v19 = State->Late.ApDelay[0];
  v20 = (Offset - State->Late.ApOffset[0]) & v19.Mask;
  v21 = v18 + (float)(State->Late.LpCoeff[1] * (float)(State->Late.LpSample[1] - v18));
  State->Late.LpSample[1] = v21;
  v22 = v19.Line[v20];
  v23 = (float)(v9 * v22) - (float)(v8 * ApFeedCoeff);
  v19.Line[v19.Mask & Offset] = v8 + (float)(ApFeedCoeff * (float)(v22 - (float)(v8 * ApFeedCoeff)));
  v24 = State->Late.ApFeedCoeff;
  v25 = State->Offset;
  v26 = State->Late.ApDelay[1];
  v27 = v26.Line[(v25 - State->Late.ApOffset[1]) & v26.Mask];
  v28 = (float)(State->Late.ApCoeff[1] * v27) - (float)(v13 * v24);
  v26.Line[v26.Mask & v25] = v13 + (float)(v24 * (float)(v27 - (float)(v13 * v24)));
  v29 = State->Late.ApFeedCoeff;
  v30 = State->Offset;
  v31 = State->Late.ApDelay[2];
  v32 = v31.Line[(v30 - State->Late.ApOffset[2]) & v31.Mask];
  v33 = (float)(State->Late.ApCoeff[2] * v32) - (float)(v17 * v29);
  v31.Line[v31.Mask & v30] = v17 + (float)(v29 * (float)(v32 - (float)(v17 * v29)));
  v34 = State->Late.ApFeedCoeff;
  v35 = State->Late.ApDelay[3];
  v36 = State->Offset;
  v37 = v35.Line[(v36 - State->Late.ApOffset[3]) & v35.Mask];
  v38 = (float)(State->Late.ApCoeff[3] * v37) - (float)(v21 * v34);
  v35.Line[v35.Mask & v36] = v21 + (float)(v34 * (float)(v37 - (float)(v21 * v34)));
  MixCoeff = State->Late.MixCoeff;
  Gain = State->Late.Gain;
  v41 = MixCoeff * (float)((float)(v28 - v33) + v38);
  v42 = MixCoeff * (float)((float)(v23 - v28) + v38);
  v43 = v38 + (float)((float)((float)((float)-v28 - v23) - v33) * MixCoeff);
  v44 = v28 + (float)(MixCoeff * (float)((float)(v33 - v23) + v38));
  v45 = v23 + v41;
  *out = Gain * v45;
  out[1] = Gain * v44;
  out[2] = Gain * (float)(v33 + v42);
  out[3] = v43 * Gain;
  State->Late.Delay[0].Line[State->Late.Delay[0].Mask & State->Offset] = v45;
  State->Late.Delay[1].Line[State->Late.Delay[1].Mask & State->Offset] = v44;
  State->Late.Delay[2].Line[State->Late.Delay[2].Mask & State->Offset] = v33 + v42;
  State->Late.Delay[3].Line[State->Offset & State->Late.Delay[3].Mask] = v43;
}

//----- (00262650) --------------------------------------------------------
void __fastcall eaxreverb_SetParami(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALint val)
{
  unsigned int *p_LastError; // r0
  unsigned int *v9; // r0

  if ( param == 23 )
  {
    if ( (unsigned int)val <= 1 )
    {
      effect->Reverb.DecayHFLimit = val;
      return;
    }
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      p_LastError = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA003u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
          goto LABEL_17;
      }
      goto LABEL_18;
    }
  }
  else
  {
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      v9 = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA002u, v9) )
      {
        if ( __ldrex(v9) )
          goto LABEL_17;
      }
      goto LABEL_18;
    }
  }
LABEL_17:
  __clrex();
LABEL_18:
  __dmb(0xBu);
}

//----- (002626DC) --------------------------------------------------------
void __fastcall eaxreverb_SetParamiv(ALeffect_0 *effect, ALCcontext *context, ALenum param, const ALint *vals)
{
  unsigned int *p_LastError; // r0
  unsigned int *v9; // r0

  if ( param == 23 )
  {
    if ( *vals <= 1u )
    {
      effect->Reverb.DecayHFLimit = *vals;
      return;
    }
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      p_LastError = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA003u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
          goto LABEL_17;
      }
      goto LABEL_18;
    }
  }
  else
  {
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      v9 = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA002u, v9) )
      {
        if ( __ldrex(v9) )
          goto LABEL_17;
      }
      goto LABEL_18;
    }
  }
LABEL_17:
  __clrex();
LABEL_18:
  __dmb(0xBu);
}

//----- (0026276C) --------------------------------------------------------
void __fastcall eaxreverb_SetParamf(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALfloat val)
{
  unsigned int *p_LastError; // r0
  unsigned int *v9; // r0
  unsigned int *v12; // r0
  unsigned int *v15; // r0
  unsigned int *v18; // r0
  unsigned int *v21; // r0
  unsigned int *v24; // r0
  unsigned int *v27; // r0
  unsigned int *v30; // r0
  unsigned int *v33; // r0
  unsigned int *v36; // r0
  unsigned int *v39; // r0
  unsigned int *v42; // r0
  unsigned int *v45; // r0
  unsigned int *v48; // r0
  unsigned int *v51; // r0
  unsigned int *v54; // r0
  unsigned int *v57; // r0
  unsigned int *v60; // r0
  unsigned int *v63; // r0
  unsigned int *v66; // r0

  switch ( param )
  {
    case 1:
      if ( val < 0.0 || val > 1.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          p_LastError = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, p_LastError) )
              goto LABEL_209;
          }
          while ( !__ldrex(p_LastError) );
        }
        goto LABEL_208;
      }
      effect->Reverb.Density = val;
      break;
    case 2:
      if ( val < 0.0 || val > 1.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v9 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v9) )
              goto LABEL_209;
          }
          while ( !__ldrex(v9) );
        }
        goto LABEL_208;
      }
      effect->Reverb.Diffusion = val;
      break;
    case 3:
      if ( val < 0.0 || val > 1.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v12 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v12) )
              goto LABEL_209;
          }
          while ( !__ldrex(v12) );
        }
        goto LABEL_208;
      }
      effect->Reverb.Gain = val;
      break;
    case 4:
      if ( val < 0.0 || val > 1.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v15 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v15) )
              goto LABEL_209;
          }
          while ( !__ldrex(v15) );
        }
        goto LABEL_208;
      }
      effect->Reverb.GainHF = val;
      break;
    case 5:
      if ( val < 0.0 || val > 1.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v18 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v18) )
              goto LABEL_209;
          }
          while ( !__ldrex(v18) );
        }
        goto LABEL_208;
      }
      effect->Reverb.GainLF = val;
      break;
    case 6:
      if ( val < 0.1 || val > 20.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v21 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v21) )
              goto LABEL_209;
          }
          while ( !__ldrex(v21) );
        }
        goto LABEL_208;
      }
      effect->Reverb.DecayTime = val;
      break;
    case 7:
      if ( val < 0.1 || val > 2.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v24 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v24) )
              goto LABEL_209;
          }
          while ( !__ldrex(v24) );
        }
        goto LABEL_208;
      }
      effect->Reverb.DecayHFRatio = val;
      break;
    case 8:
      if ( val < 0.1 || val > 2.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v27 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v27) )
              goto LABEL_209;
          }
          while ( !__ldrex(v27) );
        }
        goto LABEL_208;
      }
      effect->Reverb.DecayLFRatio = val;
      break;
    case 9:
      if ( val < 0.0 || val > 3.16 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v30 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v30) )
              goto LABEL_209;
          }
          while ( !__ldrex(v30) );
        }
        goto LABEL_208;
      }
      effect->Reverb.ReflectionsGain = val;
      break;
    case 10:
      if ( val < 0.0 || val > 0.3 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v33 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v33) )
              goto LABEL_209;
          }
          while ( !__ldrex(v33) );
        }
        goto LABEL_208;
      }
      effect->Reverb.ReflectionsDelay = val;
      break;
    case 12:
      if ( val < 0.0 || val > 10.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v39 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v39) )
              goto LABEL_209;
          }
          while ( !__ldrex(v39) );
        }
        goto LABEL_208;
      }
      effect->Reverb.LateReverbGain = val;
      break;
    case 13:
      if ( val < 0.0 || val > 0.1 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v42 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v42) )
              goto LABEL_209;
          }
          while ( !__ldrex(v42) );
        }
        goto LABEL_208;
      }
      effect->Reverb.LateReverbDelay = val;
      break;
    case 15:
      if ( val < 0.075 || val > 0.25 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v45 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v45) )
              goto LABEL_209;
          }
          while ( !__ldrex(v45) );
        }
        goto LABEL_208;
      }
      effect->Reverb.EchoTime = val;
      break;
    case 16:
      if ( val < 0.0 || val > 1.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v48 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v48) )
              goto LABEL_209;
          }
          while ( !__ldrex(v48) );
        }
        goto LABEL_208;
      }
      effect->Reverb.EchoDepth = val;
      break;
    case 17:
      if ( val < 0.04 || val > 4.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v51 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v51) )
              goto LABEL_209;
          }
          while ( !__ldrex(v51) );
        }
        goto LABEL_208;
      }
      effect->Reverb.ModulationTime = val;
      break;
    case 18:
      if ( val < 0.0 || val > 1.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v54 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v54) )
              goto LABEL_209;
          }
          while ( !__ldrex(v54) );
        }
        goto LABEL_208;
      }
      effect->Reverb.ModulationDepth = val;
      break;
    case 19:
      if ( val < 0.892 || val > 1.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v57 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v57) )
              goto LABEL_209;
          }
          while ( !__ldrex(v57) );
        }
        goto LABEL_208;
      }
      effect->Reverb.AirAbsorptionGainHF = val;
      break;
    case 20:
      if ( val < 1000.0 || val > 20000.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v60 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v60) )
              goto LABEL_209;
          }
          while ( !__ldrex(v60) );
        }
        goto LABEL_208;
      }
      effect->Reverb.HFReference = val;
      break;
    case 21:
      if ( val < 20.0 || val > 1000.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v63 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v63) )
              goto LABEL_209;
          }
          while ( !__ldrex(v63) );
        }
        goto LABEL_208;
      }
      effect->Reverb.LFReference = val;
      break;
    case 22:
      if ( val < 0.0 || val > 10.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v66 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v66) )
              goto LABEL_209;
          }
          while ( !__ldrex(v66) );
        }
        goto LABEL_208;
      }
      effect->Reverb.RoomRolloffFactor = val;
      break;
    default:
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&context->ref) )
      {
LABEL_208:
        __clrex();
      }
      else
      {
        v36 = (unsigned int *)&context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, v36) )
        {
          if ( __ldrex(v36) )
            goto LABEL_208;
        }
      }
LABEL_209:
      __dmb(0xBu);
      break;
  }
}

//----- (00262F98) --------------------------------------------------------
void __fastcall eaxreverb_SetParamfv(ALeffect_0 *effect, ALCcontext *context, ALenum param, const ALfloat *vals)
{
  unsigned int *v8; // r0
  unsigned int *p_LastError; // r0

  if ( param == 14 )
  {
    if ( fabsf(*vals) != INFINITY && fabsf(vals[1]) != INFINITY && fabsf(vals[2]) != INFINITY )
    {
      (*(void (**)(void))(*(volatile RefCount *)((char *)&context->Device->ref + (unsigned int)&elf_hash_chain[6161])
                        + 44))();
      effect->Reverb.LateReverbPan[0] = *vals;
      effect->Reverb.LateReverbPan[1] = vals[1];
      effect->Reverb.LateReverbPan[2] = vals[2];
      goto LABEL_11;
    }
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      p_LastError = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA003u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
          goto LABEL_26;
      }
      goto LABEL_27;
    }
  }
  else
  {
    if ( param != 11 )
    {
      eaxreverb_SetParamf(effect, context, param, *vals);
      return;
    }
    if ( fabsf(*vals) != INFINITY && fabsf(vals[1]) != INFINITY && fabsf(vals[2]) != INFINITY )
    {
      (*(void (**)(void))(*(volatile RefCount *)((char *)&context->Device->ref + (unsigned int)&elf_hash_chain[6161])
                        + 44))();
      effect->Reverb.ReflectionsPan[0] = *vals;
      effect->Reverb.ReflectionsPan[1] = vals[1];
      effect->Reverb.ReflectionsPan[2] = vals[2];
LABEL_11:
      (*(void (**)(void))(*(volatile RefCount *)((char *)&context->Device->ref + (unsigned int)&elf_hash_chain[6161])
                        + 48))();
      return;
    }
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      v8 = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA003u, v8) )
      {
        if ( __ldrex(v8) )
          goto LABEL_26;
      }
      goto LABEL_27;
    }
  }
LABEL_26:
  __clrex();
LABEL_27:
  __dmb(0xBu);
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (0026310C) --------------------------------------------------------
void __fastcall eaxreverb_GetParami(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALint *val)
{
  unsigned int *p_LastError; // r0

  if ( param == 23 )
  {
    *val = effect->Reverb.DecayHFLimit;
  }
  else
  {
    if ( TrapALError )
      raise(5);
    if ( __ldrex((unsigned int *)&context->ref) )
    {
LABEL_9:
      __clrex();
    }
    else
    {
      p_LastError = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA002u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
          goto LABEL_9;
      }
    }
    __dmb(0xBu);
  }
}

//----- (00263160) --------------------------------------------------------
void __fastcall eaxreverb_GetParamiv(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALint *vals)
{
  unsigned int *p_LastError; // r0

  if ( param == 23 )
  {
    *vals = effect->Reverb.DecayHFLimit;
  }
  else
  {
    if ( TrapALError )
      raise(5);
    if ( __ldrex((unsigned int *)&context->ref) )
    {
LABEL_9:
      __clrex();
    }
    else
    {
      p_LastError = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA002u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
          goto LABEL_9;
      }
    }
    __dmb(0xBu);
  }
}

//----- (002631B4) --------------------------------------------------------
void __fastcall eaxreverb_GetParamf(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALfloat *val)
{
  unsigned int *p_LastError; // r0

  switch ( param )
  {
    case 1:
      *val = effect->Reverb.Density;
      break;
    case 2:
      *val = effect->Reverb.Diffusion;
      break;
    case 3:
      *val = effect->Reverb.Gain;
      break;
    case 4:
      *val = effect->Reverb.GainHF;
      break;
    case 5:
      *val = effect->Reverb.GainLF;
      break;
    case 6:
      *val = effect->Reverb.DecayTime;
      break;
    case 7:
      *val = effect->Reverb.DecayHFRatio;
      break;
    case 8:
      *val = effect->Reverb.DecayLFRatio;
      break;
    case 9:
      *val = effect->Reverb.ReflectionsGain;
      break;
    case 10:
      *val = effect->Reverb.ReflectionsDelay;
      break;
    case 12:
      *val = effect->Reverb.LateReverbGain;
      break;
    case 13:
      *val = effect->Reverb.LateReverbDelay;
      break;
    case 15:
      *val = effect->Reverb.EchoTime;
      break;
    case 16:
      *val = effect->Reverb.EchoDepth;
      break;
    case 17:
      *val = effect->Reverb.ModulationTime;
      break;
    case 18:
      *val = effect->Reverb.ModulationDepth;
      break;
    case 19:
      *val = effect->Reverb.AirAbsorptionGainHF;
      break;
    case 20:
      *val = effect->Reverb.HFReference;
      break;
    case 21:
      *val = effect->Reverb.LFReference;
      break;
    case 22:
      *val = effect->Reverb.RoomRolloffFactor;
      break;
    default:
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&context->ref) )
      {
LABEL_18:
        __clrex();
      }
      else
      {
        p_LastError = (unsigned int *)&context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_18;
        }
      }
      __dmb(0xBu);
      break;
  }
}

//----- (00263294) --------------------------------------------------------
void __fastcall eaxreverb_GetParamfv(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALfloat *vals)
{
  ALfloat v7; // r0

  if ( param == 14 )
  {
    (*(void (**)(void))(*(volatile RefCount *)((char *)&context->Device->ref + (unsigned int)&elf_hash_chain[6161]) + 44))();
    *vals = effect->Reverb.LateReverbPan[0];
    vals[1] = effect->Reverb.LateReverbPan[1];
    v7 = effect->Reverb.LateReverbPan[2];
    goto LABEL_5;
  }
  if ( param == 11 )
  {
    (*(void (**)(void))(*(volatile RefCount *)((char *)&context->Device->ref + (unsigned int)&elf_hash_chain[6161]) + 44))();
    *vals = effect->Reverb.ReflectionsPan[0];
    vals[1] = effect->Reverb.ReflectionsPan[1];
    v7 = effect->Reverb.ReflectionsPan[2];
LABEL_5:
    vals[2] = v7;
    (*(void (**)(void))(*(volatile RefCount *)((char *)&context->Device->ref + (unsigned int)&elf_hash_chain[6161]) + 48))();
    return;
  }
  eaxreverb_GetParamf(effect, context, param, vals);
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (00263310) --------------------------------------------------------
void __fastcall reverb_SetParami(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALint val)
{
  unsigned int *p_LastError; // r0
  unsigned int *v9; // r0

  if ( param == 13 )
  {
    if ( (unsigned int)val <= 1 )
    {
      effect->Reverb.DecayHFLimit = val;
      return;
    }
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      p_LastError = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA003u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
          goto LABEL_17;
      }
      goto LABEL_18;
    }
  }
  else
  {
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      v9 = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA002u, v9) )
      {
        if ( __ldrex(v9) )
          goto LABEL_17;
      }
      goto LABEL_18;
    }
  }
LABEL_17:
  __clrex();
LABEL_18:
  __dmb(0xBu);
}

//----- (0026339C) --------------------------------------------------------
void __fastcall reverb_SetParamiv(ALeffect_0 *effect, ALCcontext *context, ALenum param, const ALint *vals)
{
  unsigned int *p_LastError; // r0
  unsigned int *v9; // r0

  if ( param == 13 )
  {
    if ( *vals <= 1u )
    {
      effect->Reverb.DecayHFLimit = *vals;
      return;
    }
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      p_LastError = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA003u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
          goto LABEL_17;
      }
      goto LABEL_18;
    }
  }
  else
  {
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      v9 = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA002u, v9) )
      {
        if ( __ldrex(v9) )
          goto LABEL_17;
      }
      goto LABEL_18;
    }
  }
LABEL_17:
  __clrex();
LABEL_18:
  __dmb(0xBu);
}

//----- (0026342C) --------------------------------------------------------
void __fastcall reverb_SetParamf(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALfloat val)
{
  unsigned int *p_LastError; // r0
  unsigned int *v9; // r0
  unsigned int *v12; // r0
  unsigned int *v15; // r0
  unsigned int *v18; // r0
  unsigned int *v21; // r0
  unsigned int *v24; // r0
  unsigned int *v27; // r0
  unsigned int *v30; // r0
  unsigned int *v33; // r0
  unsigned int *v36; // r0
  unsigned int *v39; // r0
  unsigned int *v42; // r0

  switch ( param )
  {
    case 1:
      if ( val < 0.0 || val > 1.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          p_LastError = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, p_LastError) )
              goto LABEL_129;
          }
          while ( !__ldrex(p_LastError) );
        }
        goto LABEL_128;
      }
      effect->Reverb.Density = val;
      break;
    case 2:
      if ( val < 0.0 || val > 1.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v12 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v12) )
              goto LABEL_129;
          }
          while ( !__ldrex(v12) );
        }
        goto LABEL_128;
      }
      effect->Reverb.Diffusion = val;
      break;
    case 3:
      if ( val < 0.0 || val > 1.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v15 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v15) )
              goto LABEL_129;
          }
          while ( !__ldrex(v15) );
        }
        goto LABEL_128;
      }
      effect->Reverb.Gain = val;
      break;
    case 4:
      if ( val < 0.0 || val > 1.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v18 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v18) )
              goto LABEL_129;
          }
          while ( !__ldrex(v18) );
        }
        goto LABEL_128;
      }
      effect->Reverb.GainHF = val;
      break;
    case 5:
      if ( val < 0.1 || val > 20.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v21 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v21) )
              goto LABEL_129;
          }
          while ( !__ldrex(v21) );
        }
        goto LABEL_128;
      }
      effect->Reverb.DecayTime = val;
      break;
    case 6:
      if ( val < 0.1 || val > 2.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v24 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v24) )
              goto LABEL_129;
          }
          while ( !__ldrex(v24) );
        }
        goto LABEL_128;
      }
      effect->Reverb.DecayHFRatio = val;
      break;
    case 7:
      if ( val < 0.0 || val > 3.16 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v27 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v27) )
              goto LABEL_129;
          }
          while ( !__ldrex(v27) );
        }
        goto LABEL_128;
      }
      effect->Reverb.ReflectionsGain = val;
      break;
    case 8:
      if ( val < 0.0 || val > 0.3 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v30 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v30) )
              goto LABEL_129;
          }
          while ( !__ldrex(v30) );
        }
        goto LABEL_128;
      }
      effect->Reverb.ReflectionsDelay = val;
      break;
    case 9:
      if ( val < 0.0 || val > 10.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v33 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v33) )
              goto LABEL_129;
          }
          while ( !__ldrex(v33) );
        }
        goto LABEL_128;
      }
      effect->Reverb.LateReverbGain = val;
      break;
    case 10:
      if ( val < 0.0 || val > 0.1 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v36 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v36) )
              goto LABEL_129;
          }
          while ( !__ldrex(v36) );
        }
        goto LABEL_128;
      }
      effect->Reverb.LateReverbDelay = val;
      break;
    case 11:
      if ( val < 0.892 || val > 1.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v39 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v39) )
              goto LABEL_129;
          }
          while ( !__ldrex(v39) );
        }
        goto LABEL_128;
      }
      effect->Reverb.AirAbsorptionGainHF = val;
      break;
    case 12:
      if ( val < 0.0 || val > 10.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v42 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v42) )
              goto LABEL_129;
          }
          while ( !__ldrex(v42) );
        }
        goto LABEL_128;
      }
      effect->Reverb.RoomRolloffFactor = val;
      break;
    default:
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&context->ref) )
      {
LABEL_128:
        __clrex();
      }
      else
      {
        v9 = (unsigned int *)&context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, v9) )
        {
          if ( __ldrex(v9) )
            goto LABEL_128;
        }
      }
LABEL_129:
      __dmb(0xBu);
      break;
  }
}

//----- (00263918) --------------------------------------------------------
void __fastcall reverb_SetParamfv(ALeffect_0 *effect, ALCcontext *context, ALenum param, const ALfloat *vals)
{
  reverb_SetParamf(effect, context, param, *vals);
}

//----- (0026391C) --------------------------------------------------------
void __fastcall reverb_GetParami(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALint *val)
{
  unsigned int *p_LastError; // r0

  if ( param == 13 )
  {
    *val = effect->Reverb.DecayHFLimit;
  }
  else
  {
    if ( TrapALError )
      raise(5);
    if ( __ldrex((unsigned int *)&context->ref) )
    {
LABEL_9:
      __clrex();
    }
    else
    {
      p_LastError = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA002u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
          goto LABEL_9;
      }
    }
    __dmb(0xBu);
  }
}

//----- (00263970) --------------------------------------------------------
void __fastcall reverb_GetParamiv(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALint *vals)
{
  unsigned int *p_LastError; // r0

  if ( param == 13 )
  {
    *vals = effect->Reverb.DecayHFLimit;
  }
  else
  {
    if ( TrapALError )
      raise(5);
    if ( __ldrex((unsigned int *)&context->ref) )
    {
LABEL_9:
      __clrex();
    }
    else
    {
      p_LastError = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA002u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
          goto LABEL_9;
      }
    }
    __dmb(0xBu);
  }
}

//----- (002639C4) --------------------------------------------------------
void __fastcall reverb_GetParamf(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALfloat *val)
{
  unsigned int *p_LastError; // r0

  switch ( param )
  {
    case 1:
      *val = effect->Reverb.Density;
      break;
    case 2:
      *val = effect->Reverb.Diffusion;
      break;
    case 3:
      *val = effect->Reverb.Gain;
      break;
    case 4:
      *val = effect->Reverb.GainHF;
      break;
    case 5:
      *val = effect->Reverb.DecayTime;
      break;
    case 6:
      *val = effect->Reverb.DecayHFRatio;
      break;
    case 7:
      *val = effect->Reverb.ReflectionsGain;
      break;
    case 8:
      *val = effect->Reverb.ReflectionsDelay;
      break;
    case 9:
      *val = effect->Reverb.LateReverbGain;
      break;
    case 10:
      *val = effect->Reverb.LateReverbDelay;
      break;
    case 11:
      *val = effect->Reverb.AirAbsorptionGainHF;
      break;
    case 12:
      *val = effect->Reverb.RoomRolloffFactor;
      break;
    default:
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&context->ref) )
      {
LABEL_9:
        __clrex();
      }
      else
      {
        p_LastError = (unsigned int *)&context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_9;
        }
      }
      __dmb(0xBu);
      break;
  }
}

//----- (00263A68) --------------------------------------------------------
void __fastcall reverb_GetParamfv(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALfloat *vals)
{
  unsigned int *p_LastError; // r0

  switch ( param )
  {
    case 1:
      *vals = effect->Reverb.Density;
      break;
    case 2:
      *vals = effect->Reverb.Diffusion;
      break;
    case 3:
      *vals = effect->Reverb.Gain;
      break;
    case 4:
      *vals = effect->Reverb.GainHF;
      break;
    case 5:
      *vals = effect->Reverb.DecayTime;
      break;
    case 6:
      *vals = effect->Reverb.DecayHFRatio;
      break;
    case 7:
      *vals = effect->Reverb.ReflectionsGain;
      break;
    case 8:
      *vals = effect->Reverb.ReflectionsDelay;
      break;
    case 9:
      *vals = effect->Reverb.LateReverbGain;
      break;
    case 10:
      *vals = effect->Reverb.LateReverbDelay;
      break;
    case 11:
      *vals = effect->Reverb.AirAbsorptionGainHF;
      break;
    case 12:
      *vals = effect->Reverb.RoomRolloffFactor;
      break;
    default:
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&context->ref) )
      {
LABEL_9:
        __clrex();
      }
      else
      {
        p_LastError = (unsigned int *)&context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_9;
        }
      }
      __dmb(0xBu);
      break;
  }
}

//----- (00263B0C) --------------------------------------------------------
void __fastcall echo_SetParami(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALint val)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (00263B54) --------------------------------------------------------
void __fastcall echo_SetParamiv(ALeffect_0 *effect, ALCcontext *context, ALenum param, const ALint *vals)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (00263B9C) --------------------------------------------------------
void __fastcall echo_SetParamf(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALfloat val)
{
  unsigned int *p_LastError; // r0
  unsigned int *v9; // r0
  unsigned int *v12; // r0
  unsigned int *v15; // r0
  unsigned int *v18; // r0
  unsigned int *v21; // r0

  switch ( param )
  {
    case 1:
      if ( val < 0.0 || val > 0.207 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          p_LastError = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, p_LastError) )
              goto LABEL_59;
          }
          while ( !__ldrex(p_LastError) );
        }
        goto LABEL_58;
      }
      effect->Echo.Delay = val;
      break;
    case 2:
      if ( val < 0.0 || val > 0.404 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v12 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v12) )
              goto LABEL_59;
          }
          while ( !__ldrex(v12) );
        }
        goto LABEL_58;
      }
      effect->Echo.LRDelay = val;
      break;
    case 3:
      if ( val < 0.0 || val > 0.99 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v15 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v15) )
              goto LABEL_59;
          }
          while ( !__ldrex(v15) );
        }
        goto LABEL_58;
      }
      effect->Echo.Damping = val;
      break;
    case 4:
      if ( val < 0.0 || val > 1.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v18 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v18) )
              goto LABEL_59;
          }
          while ( !__ldrex(v18) );
        }
        goto LABEL_58;
      }
      effect->Echo.Feedback = val;
      break;
    case 5:
      if ( val < -1.0 || val > 1.0 )
      {
        if ( TrapALError )
          raise(5);
        if ( !__ldrex((unsigned int *)&context->ref) )
        {
          v21 = (unsigned int *)&context->LastError;
          __dmb(0xBu);
          do
          {
            if ( !__strex(0xA003u, v21) )
              goto LABEL_59;
          }
          while ( !__ldrex(v21) );
        }
        goto LABEL_58;
      }
      effect->Echo.Spread = val;
      break;
    default:
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&context->ref) )
      {
LABEL_58:
        __clrex();
      }
      else
      {
        v9 = (unsigned int *)&context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, v9) )
        {
          if ( __ldrex(v9) )
            goto LABEL_58;
        }
      }
LABEL_59:
      __dmb(0xBu);
      break;
  }
}

//----- (00263DD0) --------------------------------------------------------
void __fastcall echo_SetParamfv(ALeffect_0 *effect, ALCcontext *context, ALenum param, const ALfloat *vals)
{
  echo_SetParamf(effect, context, param, *vals);
}

//----- (00263DD4) --------------------------------------------------------
void __fastcall echo_GetParami(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALint *val)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (00263E1C) --------------------------------------------------------
void __fastcall echo_GetParamiv(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALint *vals)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (00263E64) --------------------------------------------------------
void __fastcall echo_GetParamf(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALfloat *val)
{
  unsigned int *p_LastError; // r0

  switch ( param )
  {
    case 1:
      *val = effect->Echo.Delay;
      break;
    case 2:
      *val = effect->Echo.LRDelay;
      break;
    case 3:
      *val = effect->Echo.Damping;
      break;
    case 4:
      *val = effect->Echo.Feedback;
      break;
    case 5:
      *val = effect->Echo.Spread;
      break;
    default:
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&context->ref) )
      {
LABEL_9:
        __clrex();
      }
      else
      {
        p_LastError = (unsigned int *)&context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_9;
        }
      }
      __dmb(0xBu);
      break;
  }
}

//----- (00263EDC) --------------------------------------------------------
void __fastcall echo_GetParamfv(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALfloat *vals)
{
  unsigned int *p_LastError; // r0

  switch ( param )
  {
    case 1:
      *vals = effect->Echo.Delay;
      break;
    case 2:
      *vals = effect->Echo.LRDelay;
      break;
    case 3:
      *vals = effect->Echo.Damping;
      break;
    case 4:
      *vals = effect->Echo.Feedback;
      break;
    case 5:
      *vals = effect->Echo.Spread;
      break;
    default:
      if ( TrapALError )
        raise(5);
      if ( __ldrex((unsigned int *)&context->ref) )
      {
LABEL_9:
        __clrex();
      }
      else
      {
        p_LastError = (unsigned int *)&context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_9;
        }
      }
      __dmb(0xBu);
      break;
  }
}

//----- (00263F54) --------------------------------------------------------
void __fastcall mod_SetParami(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALint val)
{
  unsigned int *p_LastError; // r0
  unsigned int *v9; // r0

  if ( (unsigned int)(param - 1) < 2 )
  {
    mod_SetParamf(effect, context, param, (float)val);
    return;
  }
  if ( param == 3 )
  {
    if ( (unsigned int)val <= 2 )
    {
      effect->Modulator.Waveform = val;
      return;
    }
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      p_LastError = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA003u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
          goto LABEL_19;
      }
      goto LABEL_20;
    }
  }
  else
  {
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      v9 = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA002u, v9) )
      {
        if ( __ldrex(v9) )
          goto LABEL_19;
      }
      goto LABEL_20;
    }
  }
LABEL_19:
  __clrex();
LABEL_20:
  __dmb(0xBu);
}

//----- (00263FFC) --------------------------------------------------------
void __fastcall mod_SetParamiv(ALeffect_0 *effect, ALCcontext *context, ALenum param, const ALint *vals)
{
  unsigned int v5; // r1
  float v6; // s0
  unsigned int *v8; // r0
  unsigned int *p_LastError; // r0
  unsigned int *v14; // r0
  unsigned int *v17; // r0
  unsigned int *v20; // r0

  v5 = *vals;
  if ( (unsigned int)(param - 1) >= 2 )
  {
    if ( param == 3 )
    {
      if ( v5 <= 2 )
      {
        effect->Modulator.Waveform = v5;
        return;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&context->ref) )
      {
        p_LastError = (unsigned int *)&context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, p_LastError) )
        {
          if ( __ldrex(p_LastError) )
            goto LABEL_45;
        }
        goto LABEL_46;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&context->ref) )
      {
        v14 = (unsigned int *)&context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, v14) )
        {
          if ( __ldrex(v14) )
            goto LABEL_45;
        }
        goto LABEL_46;
      }
    }
  }
  else
  {
    v6 = (float)(int)v5;
    if ( param == 2 )
    {
      if ( v5 <= 0x5DC0 )
      {
        effect->Modulator.HighPassCutoff = v6;
        return;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&context->ref) )
      {
        v17 = (unsigned int *)&context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v17) )
        {
          if ( __ldrex(v17) )
            goto LABEL_45;
        }
        goto LABEL_46;
      }
    }
    else if ( param == 1 )
    {
      if ( v5 <= 0x1F40 )
      {
        effect->Modulator.Frequency = v6;
        return;
      }
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&context->ref) )
      {
        v8 = (unsigned int *)&context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA003u, v8) )
        {
          if ( __ldrex(v8) )
            goto LABEL_45;
        }
        goto LABEL_46;
      }
    }
    else
    {
      if ( TrapALError )
        raise(5);
      if ( !__ldrex((unsigned int *)&context->ref) )
      {
        v20 = (unsigned int *)&context->LastError;
        __dmb(0xBu);
        while ( __strex(0xA002u, v20) )
        {
          if ( __ldrex(v20) )
            goto LABEL_45;
        }
        goto LABEL_46;
      }
    }
  }
LABEL_45:
  __clrex();
LABEL_46:
  __dmb(0xBu);
}

//----- (00264174) --------------------------------------------------------
void __fastcall mod_SetParamf(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALfloat val)
{
  unsigned int *v6; // r0
  unsigned int *p_LastError; // r0
  unsigned int *v12; // r0

  if ( param == 2 )
  {
    if ( val >= 0.0 && val <= 24000.0 )
    {
      effect->Modulator.HighPassCutoff = val;
      return;
    }
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      p_LastError = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA003u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
          goto LABEL_29;
      }
      goto LABEL_30;
    }
  }
  else if ( param == 1 )
  {
    if ( val >= 0.0 && val <= 8000.0 )
    {
      effect->Modulator.Frequency = val;
      return;
    }
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      v6 = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA003u, v6) )
      {
        if ( __ldrex(v6) )
          goto LABEL_29;
      }
      goto LABEL_30;
    }
  }
  else
  {
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      v12 = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA002u, v12) )
      {
        if ( __ldrex(v12) )
          goto LABEL_29;
      }
      goto LABEL_30;
    }
  }
LABEL_29:
  __clrex();
LABEL_30:
  __dmb(0xBu);
}

//----- (00264280) --------------------------------------------------------
void __fastcall mod_SetParamfv(ALeffect_0 *effect, ALCcontext *context, ALenum param, const ALfloat *vals)
{
  float v4; // s0
  unsigned int *v7; // r0
  unsigned int *p_LastError; // r0
  unsigned int *v13; // r0

  v4 = *vals;
  if ( param == 2 )
  {
    if ( v4 >= 0.0 && v4 <= 24000.0 )
    {
      effect->Modulator.HighPassCutoff = v4;
      return;
    }
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      p_LastError = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA003u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
          goto LABEL_29;
      }
      goto LABEL_30;
    }
  }
  else if ( param == 1 )
  {
    if ( v4 >= 0.0 && v4 <= 8000.0 )
    {
      effect->Modulator.Frequency = v4;
      return;
    }
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      v7 = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA003u, v7) )
      {
        if ( __ldrex(v7) )
          goto LABEL_29;
      }
      goto LABEL_30;
    }
  }
  else
  {
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      v13 = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA002u, v13) )
      {
        if ( __ldrex(v13) )
          goto LABEL_29;
      }
      goto LABEL_30;
    }
  }
LABEL_29:
  __clrex();
LABEL_30:
  __dmb(0xBu);
}

//----- (0026438C) --------------------------------------------------------
void __fastcall mod_GetParami(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALint *val)
{
  float HighPassCutoff; // s0
  unsigned int *p_LastError; // r0

  switch ( param )
  {
    case 3:
      *val = effect->Modulator.Waveform;
      return;
    case 2:
      HighPassCutoff = effect->Modulator.HighPassCutoff;
      goto LABEL_7;
    case 1:
      HighPassCutoff = effect->Modulator.Frequency;
LABEL_7:
      *val = (int)HighPassCutoff;
      return;
  }
  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_14:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_14;
    }
  }
  __dmb(0xBu);
}

//----- (002643FC) --------------------------------------------------------
void __fastcall mod_GetParamiv(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALint *vals)
{
  float HighPassCutoff; // s0
  unsigned int *p_LastError; // r0

  switch ( param )
  {
    case 3:
      *vals = effect->Modulator.Waveform;
      return;
    case 2:
      HighPassCutoff = effect->Modulator.HighPassCutoff;
      goto LABEL_7;
    case 1:
      HighPassCutoff = effect->Modulator.Frequency;
LABEL_7:
      *vals = (int)HighPassCutoff;
      return;
  }
  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_14:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_14;
    }
  }
  __dmb(0xBu);
}

//----- (0026446C) --------------------------------------------------------
void __fastcall mod_GetParamf(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALfloat *val)
{
  unsigned int *p_LastError; // r0

  if ( param == 2 )
  {
    *val = effect->Modulator.HighPassCutoff;
  }
  else if ( param == 1 )
  {
    *val = effect->Modulator.Frequency;
  }
  else
  {
    if ( TrapALError )
      raise(5);
    if ( __ldrex((unsigned int *)&context->ref) )
    {
LABEL_10:
      __clrex();
    }
    else
    {
      p_LastError = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA002u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
          goto LABEL_10;
      }
    }
    __dmb(0xBu);
  }
}

//----- (002644CC) --------------------------------------------------------
void __fastcall mod_GetParamfv(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALfloat *vals)
{
  unsigned int *p_LastError; // r0

  if ( param == 2 )
  {
    *vals = effect->Modulator.HighPassCutoff;
  }
  else if ( param == 1 )
  {
    *vals = effect->Modulator.Frequency;
  }
  else
  {
    if ( TrapALError )
      raise(5);
    if ( __ldrex((unsigned int *)&context->ref) )
    {
LABEL_10:
      __clrex();
    }
    else
    {
      p_LastError = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA002u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
          goto LABEL_10;
      }
    }
    __dmb(0xBu);
  }
}

//----- (0026452C) --------------------------------------------------------
void __fastcall ded_SetParami(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALint val)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (00264574) --------------------------------------------------------
void __fastcall ded_SetParamiv(ALeffect_0 *effect, ALCcontext *context, ALenum param, const ALint *vals)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (002645BC) --------------------------------------------------------
void __fastcall ded_SetParamf(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALfloat val)
{
  unsigned int *p_LastError; // r0
  unsigned int *v9; // r0

  if ( param == 1 )
  {
    if ( val >= 0.0 && fabsf(val) != INFINITY )
    {
      effect->Dedicated.Gain = val;
      return;
    }
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      p_LastError = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA003u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
          goto LABEL_18;
      }
      goto LABEL_19;
    }
  }
  else
  {
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      v9 = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA002u, v9) )
      {
        if ( __ldrex(v9) )
          goto LABEL_18;
      }
      goto LABEL_19;
    }
  }
LABEL_18:
  __clrex();
LABEL_19:
  __dmb(0xBu);
}

//----- (00264668) --------------------------------------------------------
void __fastcall ded_SetParamfv(ALeffect_0 *effect, ALCcontext *context, ALenum param, const ALfloat *vals)
{
  float v5; // s0
  unsigned int *p_LastError; // r0
  unsigned int *v10; // r0

  if ( param == 1 )
  {
    v5 = *vals;
    if ( *vals >= 0.0 && fabsf(v5) != INFINITY )
    {
      effect->Dedicated.Gain = v5;
      return;
    }
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      p_LastError = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA003u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
          goto LABEL_18;
      }
      goto LABEL_19;
    }
  }
  else
  {
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      v10 = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA002u, v10) )
      {
        if ( __ldrex(v10) )
          goto LABEL_18;
      }
      goto LABEL_19;
    }
  }
LABEL_18:
  __clrex();
LABEL_19:
  __dmb(0xBu);
}

//----- (00264714) --------------------------------------------------------
void __fastcall ded_GetParami(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALint *val)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (0026475C) --------------------------------------------------------
void __fastcall ded_GetParamiv(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALint *vals)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (002647A4) --------------------------------------------------------
void __fastcall ded_GetParamf(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALfloat *val)
{
  unsigned int *p_LastError; // r0

  if ( param == 1 )
  {
    *val = effect->Dedicated.Gain;
  }
  else
  {
    if ( TrapALError )
      raise(5);
    if ( __ldrex((unsigned int *)&context->ref) )
    {
LABEL_9:
      __clrex();
    }
    else
    {
      p_LastError = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA002u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
          goto LABEL_9;
      }
    }
    __dmb(0xBu);
  }
}

//----- (002647F8) --------------------------------------------------------
void __fastcall ded_GetParamfv(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALfloat *vals)
{
  unsigned int *p_LastError; // r0

  if ( param == 1 )
  {
    *vals = effect->Dedicated.Gain;
  }
  else
  {
    if ( TrapALError )
      raise(5);
    if ( __ldrex((unsigned int *)&context->ref) )
    {
LABEL_9:
      __clrex();
    }
    else
    {
      p_LastError = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA002u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
          goto LABEL_9;
      }
    }
    __dmb(0xBu);
  }
}

//----- (0026484C) --------------------------------------------------------
void __fastcall alEffect_null_SetParami(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALint val)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (00264894) --------------------------------------------------------
void __fastcall alEffect_null_SetParamiv(ALeffect_0 *effect, ALCcontext *context, ALenum param, const ALint *vals)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (002648DC) --------------------------------------------------------
void __fastcall alEffect_null_SetParamf(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALfloat val)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (00264924) --------------------------------------------------------
void __fastcall alEffect_null_SetParamfv(ALeffect_0 *effect, ALCcontext *context, ALenum param, const ALfloat *vals)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (0026496C) --------------------------------------------------------
void __fastcall alEffect_null_GetParami(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALint *val)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (002649B4) --------------------------------------------------------
void __fastcall alEffect_null_GetParamiv(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALint *vals)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (002649FC) --------------------------------------------------------
void __fastcall alEffect_null_GetParamf(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALfloat *val)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (00264A44) --------------------------------------------------------
void __fastcall alEffect_null_GetParamfv(ALeffect_0 *effect, ALCcontext *context, ALenum param, ALfloat *vals)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (00264A8C) --------------------------------------------------------
void __fastcall lp_SetParami(ALfilter_0 *filter, ALCcontext *context, ALenum param, ALint val)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (00264AD4) --------------------------------------------------------
void __fastcall lp_SetParamiv(ALfilter_0 *filter, ALCcontext *context, ALenum param, const ALint *vals)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (00264B1C) --------------------------------------------------------
void __fastcall lp_SetParamf(ALfilter_0 *filter, ALCcontext *context, ALenum param, ALfloat val)
{
  unsigned int *v6; // r0
  unsigned int *p_LastError; // r0
  unsigned int *v12; // r0

  if ( param == 2 )
  {
    if ( val >= 0.0 && val <= 1.0 )
    {
      filter->GainHF = val;
      return;
    }
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      p_LastError = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA003u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
          goto LABEL_29;
      }
      goto LABEL_30;
    }
  }
  else if ( param == 1 )
  {
    if ( val >= 0.0 && val <= 1.0 )
    {
      filter->Gain = val;
      return;
    }
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      v6 = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA003u, v6) )
      {
        if ( __ldrex(v6) )
          goto LABEL_29;
      }
      goto LABEL_30;
    }
  }
  else
  {
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      v12 = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA002u, v12) )
      {
        if ( __ldrex(v12) )
          goto LABEL_29;
      }
      goto LABEL_30;
    }
  }
LABEL_29:
  __clrex();
LABEL_30:
  __dmb(0xBu);
}

//----- (00264C20) --------------------------------------------------------
void __fastcall lp_SetParamfv(ALfilter_0 *filter, ALCcontext *context, ALenum param, const ALfloat *vals)
{
  float v4; // s0
  unsigned int *v7; // r0
  unsigned int *p_LastError; // r0
  unsigned int *v13; // r0

  v4 = *vals;
  if ( param == 2 )
  {
    if ( v4 >= 0.0 && v4 <= 1.0 )
    {
      filter->GainHF = v4;
      return;
    }
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      p_LastError = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA003u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
          goto LABEL_29;
      }
      goto LABEL_30;
    }
  }
  else if ( param == 1 )
  {
    if ( v4 >= 0.0 && v4 <= 1.0 )
    {
      filter->Gain = v4;
      return;
    }
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      v7 = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA003u, v7) )
      {
        if ( __ldrex(v7) )
          goto LABEL_29;
      }
      goto LABEL_30;
    }
  }
  else
  {
    if ( TrapALError )
      raise(5);
    if ( !__ldrex((unsigned int *)&context->ref) )
    {
      v13 = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA002u, v13) )
      {
        if ( __ldrex(v13) )
          goto LABEL_29;
      }
      goto LABEL_30;
    }
  }
LABEL_29:
  __clrex();
LABEL_30:
  __dmb(0xBu);
}

//----- (00264D24) --------------------------------------------------------
void __fastcall lp_GetParami(ALfilter_0 *filter, ALCcontext *context, ALenum param, ALint *val)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (00264D6C) --------------------------------------------------------
void __fastcall lp_GetParamiv(ALfilter_0 *filter, ALCcontext *context, ALenum param, ALint *vals)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (00264DB4) --------------------------------------------------------
void __fastcall lp_GetParamf(ALfilter_0 *filter, ALCcontext *context, ALenum param, ALfloat *val)
{
  unsigned int *p_LastError; // r0

  if ( param == 2 )
  {
    *val = filter->GainHF;
  }
  else if ( param == 1 )
  {
    *val = filter->Gain;
  }
  else
  {
    if ( TrapALError )
      raise(5);
    if ( __ldrex((unsigned int *)&context->ref) )
    {
LABEL_10:
      __clrex();
    }
    else
    {
      p_LastError = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA002u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
          goto LABEL_10;
      }
    }
    __dmb(0xBu);
  }
}

//----- (00264E10) --------------------------------------------------------
void __fastcall lp_GetParamfv(ALfilter_0 *filter, ALCcontext *context, ALenum param, ALfloat *vals)
{
  unsigned int *p_LastError; // r0

  if ( param == 2 )
  {
    *vals = filter->GainHF;
  }
  else if ( param == 1 )
  {
    *vals = filter->Gain;
  }
  else
  {
    if ( TrapALError )
      raise(5);
    if ( __ldrex((unsigned int *)&context->ref) )
    {
LABEL_10:
      __clrex();
    }
    else
    {
      p_LastError = (unsigned int *)&context->LastError;
      __dmb(0xBu);
      while ( __strex(0xA002u, p_LastError) )
      {
        if ( __ldrex(p_LastError) )
          goto LABEL_10;
      }
    }
    __dmb(0xBu);
  }
}

//----- (00264E6C) --------------------------------------------------------
void __fastcall null_SetParami(ALfilter_0 *filter, ALCcontext *context, ALenum param, ALint val)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (00264EB4) --------------------------------------------------------
void __fastcall null_SetParamiv(ALfilter_0 *filter, ALCcontext *context, ALenum param, const ALint *vals)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (00264EFC) --------------------------------------------------------
void __fastcall null_SetParamf(ALfilter_0 *filter, ALCcontext *context, ALenum param, ALfloat val)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (00264F44) --------------------------------------------------------
void __fastcall null_SetParamfv(ALfilter_0 *filter, ALCcontext *context, ALenum param, const ALfloat *vals)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (00264F8C) --------------------------------------------------------
void __fastcall null_GetParami(ALfilter_0 *filter, ALCcontext *context, ALenum param, ALint *val)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (00264FD4) --------------------------------------------------------
void __fastcall null_GetParamiv(ALfilter_0 *filter, ALCcontext *context, ALenum param, ALint *vals)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (0026501C) --------------------------------------------------------
void __fastcall null_GetParamf(ALfilter_0 *filter, ALCcontext *context, ALenum param, ALfloat *val)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (00265064) --------------------------------------------------------
void __fastcall null_GetParamfv(ALfilter_0 *filter, ALCcontext *context, ALenum param, ALfloat *vals)
{
  unsigned int *p_LastError; // r0

  if ( TrapALError )
    raise(5);
  if ( __ldrex((unsigned int *)&context->ref) )
  {
LABEL_7:
    __clrex();
  }
  else
  {
    p_LastError = (unsigned int *)&context->LastError;
    __dmb(0xBu);
    while ( __strex(0xA002u, p_LastError) )
    {
      if ( __ldrex(p_LastError) )
        goto LABEL_7;
    }
  }
  __dmb(0xBu);
}

//----- (002650B0) --------------------------------------------------------
void __fastcall GetSourceOffsets(const ALsource_0 *Source, ALenum name, ALdouble *offset, int a4, ALdouble updateLen)
{
  double v5; // d0
  ALbufferlistitem_0 *queue; // r1
  ALbufferlistitem_0 *v10; // r0
  int *buffer; // r6
  __int64 v12; // d17
  ALuint position; // r0
  ALuint v14; // r2
  unsigned int v15; // r4
  ALsizei SampleLen; // r3
  double v17; // d16
  unsigned int v18; // r11
  unsigned int v19; // r10
  double v20; // d17
  int v21; // s0
  int v22; // r1
  unsigned int v23; // r0
  int v24; // r0
  unsigned int v25; // r0
  int v26; // r0
  unsigned int v27; // r1
  int v28; // r1
  int v29; // r0

  queue = Source->queue;
  if ( queue )
  {
    v10 = Source->queue;
    while ( 1 )
    {
      buffer = (int *)v10->buffer;
      if ( v10->buffer )
        break;
      v10 = v10->next;
      if ( !v10 )
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    buffer = 0;
  }
  if ( Source->state == 4114 )
  {
    if ( !buffer )
    {
LABEL_22:
      v17 = 0.0;
      *offset = 0.0;
      goto LABEL_49;
    }
  }
  else if ( !buffer || Source->state != 4115 )
  {
    goto LABEL_22;
  }
  v12 = *(_QWORD *)&v5;
  if ( v5 < 0.015 )
    v12 = 0x3F8EB851EB851EB8LL;
  position = Source->position;
  if ( v5 > 0.0 )
    v5 = *(double *)&v12;
  if ( queue )
  {
    v14 = 0;
    v15 = 0;
    do
    {
      if ( queue->buffer )
      {
        SampleLen = queue->buffer->SampleLen;
        v15 += SampleLen;
        if ( v14 < Source->BuffersPlayed )
          position += SampleLen;
      }
      queue = queue->next;
      ++v14;
    }
    while ( queue );
  }
  else
  {
    v15 = 0;
  }
  v18 = position;
  if ( Source->state == 4114 )
    v18 = position + (unsigned int)(v5 * (double)buffer[1]);
  if ( Source->Looping )
  {
    v19 = position % v15;
    v18 %= v15;
  }
  else
  {
    v19 = 0;
    if ( v18 >= v15 )
      v18 = 0;
    if ( position < v15 )
      v19 = position;
  }
  switch ( name )
  {
    case 4132:
      *offset = (double)v19 / (double)buffer[1];
      v17 = (double)v18 / (double)buffer[1];
      break;
    case 4133:
    case 4146:
      v20 = (double)v19;
      v21 = v18;
      goto LABEL_48;
    case 4134:
    case 4145:
      v22 = buffer[7];
      if ( v22 == 5132 )
      {
        v23 = buffer[4] - 5376;
        if ( v23 > 6 )
          v24 = 0;
        else
          v24 = off_60A3A0[v23];
        v17 = (double)(v19 / 0x41 * v24);
        *offset = v17;
        if ( Source->state == 4114 )
          v17 = (double)(v24 * ((v18 + 64) / 0x41));
      }
      else
      {
        v25 = buffer[6] - 5376;
        if ( v25 > 6 )
          v26 = 0;
        else
          v26 = dword_60A3C0[v25];
        v27 = v22 - 5120;
        if ( v27 > 0xB )
          v28 = 0;
        else
          v28 = dword_60A3E0[v27];
        v29 = v26 * v28;
        v20 = (double)(v29 * v19);
        v21 = v29 * v18;
LABEL_48:
        v17 = (double)(unsigned int)v21;
        *offset = v20;
      }
      break;
    default:
      return;
  }
LABEL_49:
  offset[1] = v17;
}
// 2650F6: variable 'v5' is possibly undefined
// 60A3A0: using guessed type int off_60A3A0[5];
// 60A3C0: using guessed type _DWORD dword_60A3C0[8];
// 60A3E0: using guessed type _DWORD dword_60A3E0[12];

//----- (002652C4) --------------------------------------------------------
ALCenum __fastcall null_open_playback(ALCdevice *device, const ALCchar *deviceName)
{
  const unsigned __int8 *v2; // r5
  void *v5; // r6
  unsigned __int8 *v6; // r0

  v2 = deviceName;
  if ( deviceName )
  {
    if ( strcmp((const char *)deviceName, (const char *)nullDevice) )
      return 40964;
  }
  else
  {
    v2 = nullDevice;
  }
  v5 = calloc(1u, 8u);
  v6 = j_strdup(v2);
  *(int *)((char *)&elf_hash_chain[6162] + (_DWORD)device) = (int)v5;
  device->DeviceName = v6;
  return 0;
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (0026531C) --------------------------------------------------------
void __fastcall null_close_playback(ALCdevice *device)
{
  free(*(void **)((char *)&elf_hash_chain[6162] + (_DWORD)device));
  *(int *)((char *)&elf_hash_chain[6162] + (_DWORD)device) = 0;
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (00265338) --------------------------------------------------------
ALCboolean __fastcall null_reset_playback(ALCdevice *device)
{
  ALuint *ChannelOffsets; // r9
  int v3; // r11
  int v4; // r12
  int v5; // lr
  int v6; // r0
  ALuint v7; // r8
  int v8; // r2
  int v9; // r10
  int v10; // r6
  int v11; // r3
  int v12; // r1
  int v13; // r3
  volatile RefCount *v14; // r1

  ChannelOffsets = device->ChannelOffsets;
  memset(device->ChannelOffsets, 255, sizeof(device->ChannelOffsets));
  v3 = 3;
  v4 = 5;
  v5 = 4;
  v6 = 1;
  v7 = 0;
  v8 = 2;
  v9 = 1;
  v10 = 0;
  v11 = 1;
  switch ( device->FmtChans )
  {
    case DevFmtMono:
      goto LABEL_8;
    case DevFmtStereo:
      goto LABEL_7;
    case DevFmtQuad:
      goto LABEL_6;
    case DevFmtX51:
      v4 = 5;
      v5 = 4;
      v6 = 3;
      v7 = 2;
      v12 = 1;
      v13 = 0;
      v9 = 3;
      v8 = 4;
      v3 = 5;
      goto LABEL_5;
    case DevFmtX61:
      v4 = 8;
      *ChannelOffsets = 0;
      v8 = 5;
      v5 = 7;
      v9 = 4;
      v6 = 6;
      v7 = 3;
      v12 = 2;
      v13 = 1;
      v3 = 6;
      goto LABEL_5;
    case DevFmtX71:
      device->ChannelOffsets[0] = 0;
      device->ChannelOffsets[1] = 1;
      v4 = 8;
      v8 = 6;
      v5 = 7;
      v6 = 5;
      v7 = 4;
      v12 = 3;
      v13 = 2;
      v9 = 5;
      v3 = 7;
LABEL_5:
      ChannelOffsets[v13] = v13;
      ChannelOffsets[v12] = v12;
LABEL_6:
      ChannelOffsets[v7] = v7;
      v7 = v5;
      v10 = v8;
      ChannelOffsets[v6] = v9;
      v6 = v4;
      v11 = v3;
LABEL_7:
      v14 = &device->ref + v7;
      v8 = v6;
      v7 = v11;
      *((_DWORD *)v14 + 47) = v10;
LABEL_8:
      device->ChannelOffsets[v8] = v7;
      break;
    default:
      return 1;
  }
  return 1;
}

//----- (0026543C) --------------------------------------------------------
ALCboolean __fastcall null_start_playback(ALCdevice *device)
{
  int v1; // r4
  ALvoid *started; // r0

  v1 = *(int *)((char *)&elf_hash_chain[6162] + (_DWORD)device);
  started = j_StartThread(NullProc, device);
  *(_DWORD *)(v1 + 4) = started;
  return started != 0;
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (00265464) --------------------------------------------------------
void __fastcall null_stop_playback(ALCdevice *device)
{
  _DWORD *v1; // r5
  pthread_t *v2; // r4

  v1 = *(_DWORD **)((char *)&elf_hash_chain[6162] + (_DWORD)device);
  v2 = (pthread_t *)v1[1];
  if ( v2 )
  {
    *v1 = 1;
    pthread_join(v2[3], 0);
    free(v2);
    *v1 = 0;
    v1[1] = 0;
  }
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (00265498) --------------------------------------------------------
ALuint __fastcall NullProc(ALvoid *ptr)
{
  _DWORD *v2; // r5
  signed __int64 v3; // kr00_8
  unsigned int v4; // r0
  unsigned __int64 v5; // r8
  unsigned int v6; // r5
  unsigned int v7; // r6
  unsigned __int64 v8; // kr08_8
  unsigned __int64 v9; // r0
  ALsizei v10; // r2
  _DWORD *v11; // r5
  struct timespec v13; // [sp+0h] [bp-40h]
  int Time; // [sp+8h] [bp-38h]
  _DWORD *v15; // [sp+Ch] [bp-34h]
  struct timespec v16; // [sp+10h] [bp-30h] BYREF
  struct timespec requested_time; // [sp+18h] [bp-28h] BYREF

  v2 = *(_DWORD **)((char *)&elf_hash_chain[6162] + (_DWORD)ptr);
  v3 = 1000 * (unsigned __int64)*((unsigned int *)ptr + 5) / *((unsigned int *)ptr + 4);
  Time = j_timeGetTime();
  v15 = v2;
  v4 = v3 >> 1;
  if ( !*v2 )
  {
    v5 = 0LL;
    v13.tv_nsec = (_DWORD)"ist_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly" * v4
                - 1000000000
                * ((unsigned int)(((((unsigned int)"ist_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly"
                                   * v4) >> 9)
                                 * (unsigned __int64)((unsigned int)&stru_44B7C.st_value + 3)) >> 32) >> 7);
    v13.tv_sec = v4 / 0x3E8;
    do
    {
      if ( !*((_BYTE *)ptr + 4) )
        break;
      v8 = (unsigned int)(j_timeGetTime() - Time) * (unsigned __int64)*((unsigned int *)ptr + 4) / 0x3E8;
      v6 = HIDWORD(v8);
      v7 = v8;
      if ( v8 < v5 )
      {
        LODWORD(v9) = 0;
        HIDWORD(v9) = *((_DWORD *)ptr + 4);
        v6 = (v8 + v9 / 0x3E8 - v5) >> 32;
        v7 = v8 + v9 / 0x3E8 - v5;
        v5 = 0LL;
      }
      v10 = *((_DWORD *)ptr + 5);
      if ( __PAIR64__(v6, v7) - v5 >= (unsigned int)v10 )
      {
        do
        {
          j_aluMixData((ALCdevice *)ptr, 0, v10);
          v10 = *((_DWORD *)ptr + 5);
          v5 += (unsigned int)v10;
        }
        while ( __PAIR64__(v6, v7) - v5 >= (unsigned int)v10 );
      }
      else
      {
        requested_time = v13;
        if ( nanosleep(&requested_time, &v16) == -1 )
        {
          v11 = (_DWORD *)_errno(0);
          do
          {
            if ( *v11 != 4 )
              break;
            requested_time = v16;
          }
          while ( nanosleep(&requested_time, &v16) == -1 );
        }
      }
    }
    while ( !*v15 );
  }
  return 0;
}
// 10168: using guessed type int elf_hash_chain[22025];
// 44B7C: using guessed type Elf32_Sym stru_44B7C;
// 19CEE8: using guessed type int __fastcall _errno(_DWORD);

//----- (002655F0) --------------------------------------------------------
ALCenum __fastcall android_open_playback(ALCdevice *device, const ALCchar *deviceName)
{
  JavaVM *p_functions; // r6
  JavaVM_0 *JavaVM; // r0
  void *v6; // r6
  unsigned __int8 *v7; // r0

  p_functions = javaVM;
  if ( !javaVM )
  {
    JavaVM = j_GetJavaVM();
    p_functions = &JavaVM->functions;
    javaVM = &JavaVM->functions;
    if ( apportableOpenALFuncs.alc_android_set_java_vm )
      apportableOpenALFuncs.alc_android_set_java_vm((JavaVM *)JavaVM);
    javaVM = p_functions;
  }
  (*p_functions)->AttachCurrentThread(p_functions, &env, 0);
  if ( cAudioTrack )
  {
    if ( deviceName )
      goto LABEL_7;
LABEL_11:
    deviceName = android_device;
LABEL_12:
    v6 = calloc(1u, 8u);
    v7 = j_strdup(deviceName);
    *(int *)((char *)&elf_hash_chain[6162] + (_DWORD)device) = (int)v6;
    device->FmtChans = DevFmtStereo;
    device->FmtType = DevFmtShort;
    device->DeviceName = v7;
    return 0;
  }
  cAudioTrack = (*env)->FindClass(env, "android/media/AudioTrack");
  if ( !cAudioTrack )
  {
    if ( LogLevel_0 )
      j_al_print(
        "(EE)",
        "android_open_playback",
        "android.media.AudioTrack class is not found. Are you running at least 1.5 version?");
    return 40964;
  }
  cAudioTrack = (jclass)((int (__fastcall *)(JNIEnv *))(*env)->NewGlobalRef)(env);
  mAudioTrack = (*env)->GetMethodID(env, cAudioTrack, "<init>", "(IIIIII)V");
  mGetMinBufferSize = (*env)->GetStaticMethodID(env, cAudioTrack, "getMinBufferSize", "(III)I");
  mPlay = (*env)->GetMethodID(env, cAudioTrack, "play", "()V");
  mPause = (*env)->GetMethodID(env, cAudioTrack, "pause", "()V");
  mStop = (*env)->GetMethodID(env, cAudioTrack, "stop", "()V");
  mRelease = (*env)->GetMethodID(env, cAudioTrack, "release", "()V");
  mWrite = (*env)->GetMethodID(env, cAudioTrack, "write", "([BII)I");
  if ( !deviceName )
    goto LABEL_11;
LABEL_7:
  if ( !strcmp((const char *)deviceName, (const char *)android_device) )
    goto LABEL_12;
  return 40964;
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (002658A0) --------------------------------------------------------
void __fastcall android_close_playback(ALCdevice *device)
{
  void *v2; // r0
  _DWORD *v3; // r4

  v2 = *(void **)((char *)&elf_hash_chain[6162] + (_DWORD)device);
  if ( v2 )
  {
    v3 = (int *)((char *)&elf_hash_chain[6162] + (_DWORD)device);
    free(v2);
    *v3 = 0;
  }
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (002658C6) --------------------------------------------------------
ALCboolean __fastcall android_reset_playback(ALCdevice *device)
{
  DevFmtChannels FmtChans; // r0
  ALuint v3; // r1
  int v4; // r0

  FmtChans = device->FmtChans;
  if ( (unsigned int)(FmtChans - 5377) <= 5 && FmtChans != (DevFmtMono|0x2) || FmtChans == 0x80000000 )
  {
    device->ChannelOffsets[8] = -1;
    device->FmtChans = DevFmtStereo;
    device->ChannelOffsets[0] = 0;
    device->ChannelOffsets[1] = -1;
    v3 = 1;
    device->ChannelOffsets[2] = -1;
    device->ChannelOffsets[3] = -1;
    device->ChannelOffsets[4] = -1;
    device->ChannelOffsets[5] = -1;
    device->ChannelOffsets[6] = -1;
    device->ChannelOffsets[7] = -1;
    v4 = 1;
  }
  else
  {
    device->FmtChans = DevFmtMono;
    memset(device->ChannelOffsets, 255, sizeof(device->ChannelOffsets));
    v3 = 0;
    v4 = 2;
  }
  device->ChannelOffsets[v4] = v3;
  return 1;
}

//----- (0026592C) --------------------------------------------------------
ALCboolean __fastcall android_start_playback(ALCdevice *device)
{
  pthread_t *v2; // r0

  v2 = *(pthread_t **)((char *)&elf_hash_chain[6162] + (_DWORD)device);
  v2[1] = 1;
  pthread_create(v2, 0, thread_function, device);
  return 1;
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (00265954) --------------------------------------------------------
void __fastcall android_stop_playback(ALCdevice *device)
{
  pthread_t *v1; // r1
  pthread_t v2; // r0

  v1 = *(pthread_t **)((char *)&elf_hash_chain[6162] + (_DWORD)device);
  if ( v1[1] )
  {
    v2 = *v1;
    v1[1] = 0;
    sub_195640(v2, 0);
  }
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (00265974) --------------------------------------------------------
void *__fastcall thread_function(void *arg)
{
  int v2; // r8
  JavaVM *p_functions; // r6
  JavaVM_0 *JavaVM; // r0
  int v5; // r11
  unsigned int v6; // r0
  int v7; // r4
  int v8; // r4
  unsigned int v9; // r0
  __int64 v10; // kr00_8
  int v11; // r10
  int v12; // r2
  int v13; // r12
  int v14; // r0
  jobject v15; // r4
  ALvoid *v16; // r11
  int v18; // [sp+18h] [bp-30h]
  ALsizei size; // [sp+1Ch] [bp-2Ch]
  unsigned int sizea; // [sp+1Ch] [bp-2Ch]
  unsigned int v21; // [sp+24h] [bp-24h]
  int v22; // [sp+28h] [bp-20h]
  jbyteArray v23; // [sp+28h] [bp-20h]

  v2 = *(int *)((char *)&elf_hash_chain[6162] + (_DWORD)arg);
  p_functions = javaVM;
  if ( !javaVM )
  {
    JavaVM = j_GetJavaVM();
    p_functions = &JavaVM->functions;
    javaVM = &JavaVM->functions;
    if ( apportableOpenALFuncs.alc_android_set_java_vm )
      apportableOpenALFuncs.alc_android_set_java_vm((JavaVM *)JavaVM);
    javaVM = p_functions;
  }
  (*p_functions)->AttachCurrentThread(p_functions, &env, 0);
  v5 = 2;
  (*env)->PushLocalFrame(env, 2);
  switch ( *((_DWORD *)arg + 7) )
  {
    case 0x1500:
      break;
    default:
      v5 = 3;
      break;
  }
  v6 = *((_DWORD *)arg + 8) - 5120;
  if ( v6 > 6 )
    v7 = 2;
  else
    v7 = dword_265C80[v6];
  v22 = v7;
  v8 = *((_DWORD *)arg + 4);
  v9 = (*env)->CallStaticIntMethod(env, cAudioTrack, mGetMinBufferSize);
  v10 = *((_QWORD *)arg + 3);
  v11 = *((_DWORD *)arg + 8);
  v21 = v9 / *((_DWORD *)arg + 6);
  v12 = 1;
  v13 = v8;
  switch ( HIDWORD(v10) )
  {
    case 0x1500:
      goto LABEL_18;
    case 0x1501:
      v12 = 2;
      goto LABEL_18;
    case 0x1502:
      goto LABEL_14;
    case 0x1503:
      v12 = 4;
      goto LABEL_18;
    case 0x1504:
      goto LABEL_13;
    case 0x1505:
      v12 = 7;
      goto LABEL_18;
    case 0x1506:
      v12 = 8;
      goto LABEL_18;
    default:
      v13 = v8;
      if ( HIDWORD(v10) == 0x80000000 )
LABEL_13:
        v12 = 6;
      else
LABEL_14:
        v12 = 0;
LABEL_18:
      size = v12;
      if ( (unsigned int)(v11 - 5120) > 6 )
        v14 = 0;
      else
        v14 = dword_60A410[v11 - 5120];
      v18 = v14;
      v15 = (*env)->NewObject(env, cAudioTrack, mAudioTrack, 3, v13, v5, v22, v10 * v21, 1);
      (*env)->CallNonvirtualVoidMethod(env, v15, cAudioTrack, mPlay);
      audioTrackPlaying = 1;
      v23 = (*env)->NewByteArray(env, v21);
      sizea = v21 / (v18 * size);
      while ( *(_DWORD *)(v2 + 4) )
      {
        if ( IsAndroidPaused )
        {
          if ( audioTrackPlaying == 1 )
          {
            (*env)->CallNonvirtualVoidMethod(env, v15, cAudioTrack, mPause);
            audioTrackPlaying = 0;
          }
          usleep(0x1388u);
        }
        else
        {
          if ( !audioTrackPlaying )
          {
            (*env)->CallNonvirtualVoidMethod(env, v15, cAudioTrack, mPlay);
            audioTrackPlaying = 1;
          }
          v16 = (*env)->GetPrimitiveArrayCritical(env, v23, 0);
          if ( v16 )
          {
            j_aluMixData((ALCdevice *)arg, v16, sizea);
            (*env)->ReleasePrimitiveArrayCritical(env, v23, v16, 0);
            (*env)->CallNonvirtualIntMethod(env, v15, cAudioTrack, mWrite, v23, 0, v21);
          }
          else if ( LogLevel_0 )
          {
            j_al_print("(EE)", "thread_function", "Failed to get pointer to array bytes");
          }
        }
      }
      (*env)->CallNonvirtualVoidMethod(env, v15, cAudioTrack, mStop);
      (*env)->CallNonvirtualVoidMethod(env, v15, cAudioTrack, mRelease);
      audioTrackPlaying = 0;
      (*env)->PopLocalFrame(env, 0);
      (*p_functions)->DetachCurrentThread(p_functions);
      return 0;
  }
}
// 10168: using guessed type int elf_hash_chain[22025];
// 265C80: using guessed type int dword_265C80[7];
// 60A410: using guessed type _DWORD dword_60A410[7];
// 6D686C: using guessed type char audioTrackPlaying;

//----- (00265D50) --------------------------------------------------------
ALCenum __fastcall loopback_open_playback(ALCdevice *device, const ALCchar *deviceName)
{
  device->DeviceName = j_strdup(deviceName);
  return 0;
}

//----- (00265D64) --------------------------------------------------------
ALCboolean __fastcall loopback_reset_playback(ALCdevice *device)
{
  ALuint *ChannelOffsets; // r9
  int v3; // r11
  int v4; // r12
  int v5; // lr
  int v6; // r0
  ALuint v7; // r8
  int v8; // r2
  int v9; // r10
  int v10; // r6
  int v11; // r3
  int v12; // r1
  int v13; // r3
  volatile RefCount *v14; // r1

  ChannelOffsets = device->ChannelOffsets;
  memset(device->ChannelOffsets, 255, sizeof(device->ChannelOffsets));
  v3 = 3;
  v4 = 5;
  v5 = 4;
  v6 = 1;
  v7 = 0;
  v8 = 2;
  v9 = 1;
  v10 = 0;
  v11 = 1;
  switch ( device->FmtChans )
  {
    case DevFmtMono:
      goto LABEL_8;
    case DevFmtStereo:
      goto LABEL_7;
    case DevFmtQuad:
      goto LABEL_6;
    case DevFmtX51:
      v4 = 5;
      v5 = 4;
      v6 = 3;
      v7 = 2;
      v12 = 1;
      v13 = 0;
      v9 = 3;
      v8 = 4;
      v3 = 5;
      goto LABEL_5;
    case DevFmtX61:
      v4 = 8;
      *ChannelOffsets = 0;
      v8 = 5;
      v5 = 7;
      v9 = 4;
      v6 = 6;
      v7 = 3;
      v12 = 2;
      v13 = 1;
      v3 = 6;
      goto LABEL_5;
    case DevFmtX71:
      device->ChannelOffsets[0] = 0;
      device->ChannelOffsets[1] = 1;
      v4 = 8;
      v8 = 6;
      v5 = 7;
      v6 = 5;
      v7 = 4;
      v12 = 3;
      v13 = 2;
      v9 = 5;
      v3 = 7;
LABEL_5:
      ChannelOffsets[v13] = v13;
      ChannelOffsets[v12] = v12;
LABEL_6:
      ChannelOffsets[v7] = v7;
      v7 = v5;
      v10 = v8;
      ChannelOffsets[v6] = v9;
      v6 = v4;
      v11 = v3;
LABEL_7:
      v14 = &device->ref + v7;
      v8 = v6;
      v7 = v11;
      *((_DWORD *)v14 + 47) = v10;
LABEL_8:
      device->ChannelOffsets[v8] = v7;
      break;
    default:
      return 1;
  }
  return 1;
}

//----- (00265E66) --------------------------------------------------------
ALCboolean __fastcall loopback_start_playback(ALCdevice *device)
{
  return 1;
}

//----- (00265E6C) --------------------------------------------------------
ALCenum __fastcall opensl_open_playback(ALCdevice *Device, const ALCchar *deviceName)
{
  const unsigned __int8 *v2; // r6
  _DWORD *v4; // r0
  _DWORD *v5; // r4
  int Engine; // r0
  unsigned int v7; // r0
  const char *v8; // r1
  int v10; // r0
  unsigned int v11; // r0
  const char *v12; // r1
  int v13; // r0
  int v14; // r0
  int v15; // r0
  unsigned int v16; // r0
  const char *v17; // r1
  int v18; // r0
  unsigned int v19; // r0
  const char *v20; // r1
  int v21; // r0
  unsigned int v22; // r0
  const char *v23; // r1
  unsigned __int8 *v24; // r0

  v2 = deviceName;
  if ( deviceName )
  {
    if ( strcmp((const char *)deviceName, (const char *)opensl_device) )
      return 40964;
  }
  else
  {
    v2 = opensl_device;
  }
  v4 = calloc(1u, 0x1Cu);
  v5 = v4;
  if ( !v4 )
    return 40965;
  Engine = slCreateEngine(v4, 0, 0, 0, 0, 0);
  if ( Engine && LogLevel_0 )
  {
    v7 = Engine - 1;
    if ( v7 > 0xF )
      v8 = "Unknown error code";
    else
      v8 = (&off_661DE0)[v7];
    j_al_print("(EE)", "opensl_open_playback", (const unsigned __int8 *)"%s: %s\n", "slCreateEngine", v8);
    goto LABEL_18;
  }
  if ( Engine )
    goto LABEL_18;
  v10 = (**(int (__fastcall ***)(_DWORD, _DWORD))*v5)(*v5, 0);
  if ( v10 && LogLevel_0 )
  {
    v11 = v10 - 1;
    if ( v11 > 0xF )
      v12 = "Unknown error code";
    else
      v12 = (&off_661DE0)[v11];
    j_al_print("(EE)", "opensl_open_playback", (const unsigned __int8 *)"%s: %s\n", "engine->Realize", v12);
    goto LABEL_18;
  }
  if ( v10 )
    goto LABEL_18;
  v15 = (*(int (__fastcall **)(_DWORD, _DWORD, _DWORD *))(*(_DWORD *)*v5 + 12))(*v5, SL_IID_ENGINE, v5 + 1);
  if ( v15 && LogLevel_0 )
  {
    v16 = v15 - 1;
    if ( v16 > 0xF )
      v17 = "Unknown error code";
    else
      v17 = (&off_661DE0)[v16];
    j_al_print("(EE)", "opensl_open_playback", (const unsigned __int8 *)"%s: %s\n", "engine->GetInterface", v17);
    goto LABEL_18;
  }
  if ( v15 )
    goto LABEL_18;
  v18 = (*(int (__fastcall **)(_DWORD, _DWORD *, _DWORD, _DWORD, _DWORD))(*(_DWORD *)v5[1] + 28))(
          v5[1],
          v5 + 2,
          0,
          0,
          0);
  if ( v18 && LogLevel_0 )
  {
    v19 = v18 - 1;
    if ( v19 > 0xF )
      v20 = "Unknown error code";
    else
      v20 = (&off_661DE0)[v19];
    j_al_print("(EE)", "opensl_open_playback", (const unsigned __int8 *)"%s: %s\n", "engine->CreateOutputMix", v20);
    goto LABEL_18;
  }
  if ( v18 )
    goto LABEL_18;
  v21 = (**(int (__fastcall ***)(_DWORD, _DWORD))v5[2])(v5[2], 0);
  if ( v21 && LogLevel_0 )
  {
    v22 = v21 - 1;
    if ( v22 > 0xF )
      v23 = "Unknown error code";
    else
      v23 = (&off_661DE0)[v22];
    j_al_print("(EE)", "opensl_open_playback", (const unsigned __int8 *)"%s: %s\n", "outputMix->Realize", v23);
    goto LABEL_18;
  }
  if ( v21 )
  {
LABEL_18:
    v13 = v5[2];
    if ( v13 )
      (*(void (__fastcall **)(int))(*(_DWORD *)v13 + 24))(v13);
    v14 = *v5;
    v5[2] = 0;
    if ( v14 )
      (*(void (__fastcall **)(int))(*(_DWORD *)v14 + 24))(v14);
    free(v5);
    return 40964;
  }
  v24 = j_strdup(v2);
  *(int *)((char *)&elf_hash_chain[6162] + (_DWORD)Device) = (int)v5;
  Device->DeviceName = v24;
  return 0;
}
// 10168: using guessed type int elf_hash_chain[22025];
// 19B124: using guessed type int __fastcall slCreateEngine(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 661DE0: using guessed type char *off_661DE0;

//----- (00266124) --------------------------------------------------------
void __fastcall opensl_close_playback(ALCdevice *Device)
{
  _DWORD *v1; // r5
  int *v2; // r4
  int v3; // r0
  int v4; // r0
  int v5; // r0

  v1 = (int *)((char *)&elf_hash_chain[6162] + (_DWORD)Device);
  v2 = *(int **)((char *)&elf_hash_chain[6162] + (_DWORD)Device);
  v3 = v2[3];
  if ( v3 )
    (*(void (__fastcall **)(int))(*(_DWORD *)v3 + 24))(v3);
  v4 = v2[2];
  v2[3] = 0;
  (*(void (__fastcall **)(int))(*(_DWORD *)v4 + 24))(v4);
  v5 = *v2;
  v2[2] = 0;
  (*(void (__fastcall **)(int))(*(_DWORD *)v5 + 24))(v5);
  free(v2);
  *v1 = 0;
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (00266170) --------------------------------------------------------
ALCboolean __fastcall opensl_reset_playback(ALCdevice *Device)
{
  _DWORD *v1; // r5
  __int64 v2; // kr00_8
  ALuint NumUpdates; // r11
  int v4; // r6
  int v5; // r0
  _DWORD *v6; // r4
  int v7; // r0
  int v8; // r0
  unsigned int v9; // r0
  const char *v10; // r1
  int v11; // r0
  unsigned int v12; // r0
  const char *v13; // r1
  ALCboolean result; // r0
  int v15; // [sp+Ch] [bp-74h] BYREF
  int v16; // [sp+10h] [bp-70h] BYREF
  _DWORD v17[2]; // [sp+14h] [bp-6Ch] BYREF
  _DWORD v18[2]; // [sp+1Ch] [bp-64h] BYREF
  _QWORD v19[2]; // [sp+24h] [bp-5Ch] BYREF
  int v20; // [sp+34h] [bp-4Ch]
  int v21; // [sp+38h] [bp-48h]
  int v22; // [sp+3Ch] [bp-44h]
  int v23[2]; // [sp+40h] [bp-40h] BYREF
  int v24[14]; // [sp+48h] [bp-38h] BYREF

  v1 = *(_DWORD **)((char *)&elf_hash_chain[6162] + (_DWORD)Device);
  v2 = *(_QWORD *)&Device->Frequency;
  NumUpdates = Device->NumUpdates;
  Device->ChannelOffsets[0] = 0;
  Device->ChannelOffsets[1] = 1;
  v4 = SL_IID_ANDROIDSIMPLEBUFFERQUEUE;
  Device->ChannelOffsets[2] = -1;
  Device->ChannelOffsets[3] = -1;
  Device->ChannelOffsets[4] = -1;
  Device->ChannelOffsets[5] = -1;
  Device->ChannelOffsets[6] = -1;
  Device->ChannelOffsets[7] = -1;
  Device->ChannelOffsets[8] = -1;
  Device->Frequency = 44100;
  Device->UpdateSize = (NumUpdates * (unsigned int)(44100 * (unsigned __int64)HIDWORD(v2) / (unsigned int)v2)) >> 1;
  Device->NumUpdates = 2;
  Device->FmtChans = DevFmtStereo;
  Device->FmtType = DevFmtShort;
  v24[1] = 2;
  v15 = 1;
  v16 = v4;
  v24[0] = -2147481667;
  v19[0] = 0x200000002LL;
  v19[1] = 0x1002A0E9A0LL;
  v20 = 16;
  v21 = 3;
  v22 = 2;
  v18[0] = v24;
  v18[1] = v19;
  v23[0] = 4;
  v23[1] = v1[2];
  v17[0] = v23;
  v17[1] = 0;
  v6 = v1 + 3;
  v5 = v1[3];
  if ( v5 )
    (*(void (__fastcall **)(int))(*(_DWORD *)v5 + 24))(v5);
  v7 = v1[1];
  v1[3] = 0;
  v8 = (*(int (__fastcall **)(int, _DWORD *, _DWORD *, _DWORD *, int, int *, int *))(*(_DWORD *)v7 + 8))(
         v7,
         v1 + 3,
         v18,
         v17,
         1,
         &v16,
         &v15);
  if ( v8 && LogLevel_0 )
  {
    v9 = v8 - 1;
    if ( v9 > 0xF )
      v10 = "Unknown error code";
    else
      v10 = (&off_661DE0)[v9];
    j_al_print("(EE)", "opensl_reset_playback", (const unsigned __int8 *)"%s: %s\n", "engine->CreateAudioPlayer", v10);
  }
  else if ( !v8 )
  {
    v11 = (**(int (__fastcall ***)(_DWORD, _DWORD))*v6)(*v6, 0);
    if ( v11 && LogLevel_0 )
    {
      v12 = v11 - 1;
      if ( v12 > 0xF )
        v13 = "Unknown error code";
      else
        v13 = (&off_661DE0)[v12];
      j_al_print("(EE)", "opensl_reset_playback", (const unsigned __int8 *)"%s: %s\n", "bufferQueue->Realize", v13);
    }
    else if ( !v11 )
    {
      return 1;
    }
  }
  if ( *v6 )
    (*(void (__fastcall **)(_DWORD))(*(_DWORD *)*v6 + 24))(*v6);
  result = 0;
  *v6 = 0;
  return result;
}
// 10168: using guessed type int elf_hash_chain[22025];
// 661DE0: using guessed type char *off_661DE0;
// 266170: using guessed type _QWORD var_5C[2];
// 266170: using guessed type _DWORD var_64[2];
// 266170: using guessed type _DWORD var_6C[2];

//----- (00266368) --------------------------------------------------------
ALCboolean __fastcall opensl_start_playback(ALCdevice *Device)
{
  int v2; // r6
  int v3; // r5
  const char *v4; // r1
  const char *v5; // r1
  int v6; // r0
  ALuint v7; // r8
  bool v8; // zf
  const char *v9; // r0
  int v10; // r0
  unsigned int v11; // r0
  const char *v12; // r1
  int v13; // r0
  unsigned int v14; // r0
  const char *v15; // r1
  int v16; // r0
  void *v17; // r0
  ALCboolean v18; // r4
  int v20; // r1
  unsigned __int32 v21; // r0
  int v22; // r0
  int v23; // r0
  size_t v24; // r1
  void *v25; // r0
  int (__fastcall ***v26)(_DWORD, int); // [sp+4h] [bp-24h] BYREF
  int v27[8]; // [sp+8h] [bp-20h] BYREF

  v2 = *(int *)((char *)&elf_hash_chain[6162] + (_DWORD)Device);
  v3 = (*(int (__fastcall **)(_DWORD, _DWORD, int *))(**(_DWORD **)(v2 + 12) + 12))(
         *(_DWORD *)(v2 + 12),
         SL_IID_BUFFERQUEUE,
         v27);
  if ( v3 && LogLevel_0 )
  {
    if ( (unsigned int)(v3 - 1) > 0xF )
      v4 = "Unknown error code";
    else
      v4 = (&off_661DE0)[v3 - 1];
    j_al_print("(EE)", "opensl_start_playback", (const unsigned __int8 *)"%s: %s\n", "bufferQueue->GetInterface", v4);
  }
  else if ( !v3 )
  {
    v3 = (*(int (__fastcall **)(int, void (__fastcall *)(SLAndroidSimpleBufferQueueItf, void *), ALCdevice *))(*(_DWORD *)v27[0] + 12))(
           v27[0],
           opensl_callback,
           Device);
    if ( v3 && LogLevel_0 )
    {
      if ( (unsigned int)(v3 - 1) > 0xF )
        v5 = "Unknown error code";
      else
        v5 = (&off_661DE0)[v3 - 1];
      j_al_print(
        "(EE)",
        "opensl_start_playback",
        (const unsigned __int8 *)"%s: %s\n",
        "bufferQueue->RegisterCallback",
        v5);
    }
    else if ( !v3 )
    {
      v20 = 1;
      switch ( Device->FmtChans )
      {
        case DevFmtMono:
          break;
        case DevFmtStereo:
          v20 = 2;
          break;
        case DevFmtQuad:
          v20 = 4;
          break;
        case DevFmtX51:
          v20 = 6;
          break;
        case DevFmtX61:
          v20 = 7;
          break;
        case DevFmtX71:
          v20 = 8;
          break;
        default:
          v20 = 0;
          break;
      }
      v21 = Device->FmtType - 5120;
      if ( v21 > 6 )
        v22 = 0;
      else
        v22 = dword_60A410[v21];
      v23 = v22 * v20;
      *(_DWORD *)(v2 + 24) = v23;
      v24 = Device->UpdateSize * v23;
      *(_DWORD *)(v2 + 20) = v24;
      v25 = calloc(1u, v24);
      *(_DWORD *)(v2 + 16) = v25;
      if ( v25 )
      {
        v3 = 0;
      }
      else
      {
        if ( LogLevel_0 )
          j_al_print("(EE)", "opensl_start_playback", (const unsigned __int8 *)"%s: %s\n", "calloc", "Memory failure");
        v3 = 3;
      }
    }
  }
  v6 = 0;
  v7 = 0;
  if ( !v3 )
    v6 = 1;
  if ( Device->NumUpdates )
  {
    do
    {
      if ( v6 << 31 )
      {
        v3 = (**(int (__fastcall ***)(int, _DWORD, _DWORD))v27[0])(v27[0], *(_DWORD *)(v2 + 16), *(_DWORD *)(v2 + 20));
        v8 = v3 == 0;
        if ( v3 )
          v8 = LogLevel_0 == NoLog;
        if ( !v8 )
        {
          v9 = "Unknown error code";
          if ( (unsigned int)(v3 - 1) <= 0xF )
            v9 = (&off_661DE0)[v3 - 1];
          j_al_print("(EE)", "opensl_start_playback", (const unsigned __int8 *)"%s: %s\n", "bufferQueue->Enqueue", v9);
        }
      }
      v6 = v3 == 0;
      ++v7;
    }
    while ( v7 < Device->NumUpdates );
  }
  if ( v6 == 1 )
  {
    v10 = (*(int (__fastcall **)(_DWORD, _DWORD, int (__fastcall ****)(_DWORD, int)))(**(_DWORD **)(v2 + 12) + 12))(
            *(_DWORD *)(v2 + 12),
            SL_IID_PLAY,
            &v26);
    if ( v10 && LogLevel_0 )
    {
      v11 = v10 - 1;
      if ( v11 > 0xF )
        v12 = "Unknown error code";
      else
        v12 = (&off_661DE0)[v11];
      j_al_print("(EE)", "opensl_start_playback", (const unsigned __int8 *)"%s: %s\n", "bufferQueue->GetInterface", v12);
    }
    else if ( !v10 )
    {
      v13 = (**v26)(v26, 3);
      if ( v13 && LogLevel_0 )
      {
        v14 = v13 - 1;
        if ( v14 > 0xF )
          v15 = "Unknown error code";
        else
          v15 = (&off_661DE0)[v14];
        j_al_print("(EE)", "opensl_start_playback", (const unsigned __int8 *)"%s: %s\n", "player->SetPlayState", v15);
      }
      else if ( !v13 )
      {
        return 1;
      }
    }
  }
  v16 = *(_DWORD *)(v2 + 12);
  if ( v16 )
    (*(void (__fastcall **)(int))(*(_DWORD *)v16 + 24))(v16);
  v17 = *(void **)(v2 + 16);
  v18 = 0;
  *(_DWORD *)(v2 + 12) = 0;
  free(v17);
  *(_DWORD *)(v2 + 16) = 0;
  *(_DWORD *)(v2 + 20) = 0;
  return v18;
}
// 10168: using guessed type int elf_hash_chain[22025];
// 60A410: using guessed type _DWORD dword_60A410[7];
// 661DE0: using guessed type char *off_661DE0;
// 266368: using guessed type int var_20[8];

//----- (002666B4) --------------------------------------------------------
void __fastcall opensl_stop_playback(ALCdevice *Device)
{
  int v1; // r4

  v1 = *(int *)((char *)&elf_hash_chain[6162] + (_DWORD)Device);
  free(*(void **)(v1 + 16));
  *(_DWORD *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 20) = 0;
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (002666D0) --------------------------------------------------------
void __fastcall opensl_callback(SLAndroidSimpleBufferQueueItf bq, void *context)
{
  int v3; // r6
  int v4; // r0
  unsigned int v5; // r0
  const char *v6; // r1

  v3 = *(int *)((char *)&elf_hash_chain[6162] + (_DWORD)context);
  j_aluMixData((ALCdevice *)context, *(ALvoid **)(v3 + 16), *(_DWORD *)(v3 + 20) / *(_DWORD *)(v3 + 24));
  v4 = (**(int (__fastcall ***)(SLAndroidSimpleBufferQueueItf, _DWORD, _DWORD))bq)(
         bq,
         *(_DWORD *)(v3 + 16),
         *(_DWORD *)(v3 + 20));
  if ( v4 && LogLevel_0 )
  {
    v5 = v4 - 1;
    if ( v5 > 0xF )
      v6 = "Unknown error code";
    else
      v6 = (&off_661DE0)[v5];
    j_al_print("(EE)", "opensl_callback", (const unsigned __int8 *)"%s: %s\n", "bq->Enqueue", v6);
  }
}
// 10168: using guessed type int elf_hash_chain[22025];
// 661DE0: using guessed type char *off_661DE0;

//----- (00266780) --------------------------------------------------------
void __fastcall OS_DebugOut(const unsigned __int8 *str)
{
  sub_18F9C8(3, "OSWrapper", (const char *)&dword_266794, str);
}
// 266794: using guessed type int dword_266794;

//----- (00266798) --------------------------------------------------------
void __noreturn OS_DebugBreak()
{
  _android_log_print(3, "OSWrapper", "HALT");
  __debugbreak();
}

//----- (002667B8) --------------------------------------------------------
void __fastcall OS_FileSetAsyncReadMultiple(int val)
{
  MaxAsyncReadMultiply = val;
}

//----- (002667C8) --------------------------------------------------------
void AND_FileInitialize()
{
  pthread_mutex_t *v0; // r4

  v0 = (pthread_mutex_t *)operator new(8u);
  pthread_mutexattr_init(v0[1].__private);
  pthread_mutexattr_settype(&v0[1], 1);
  pthread_mutex_init(v0, v0[1].__private);
  fileMutex = v0;
}
// 19EE74: using guessed type int __fastcall pthread_mutexattr_settype(_DWORD, _DWORD);

//----- (002667FC) --------------------------------------------------------
OSMutex __fastcall OS_MutexCreate(const unsigned __int8 *name)
{
  pthread_mutex_t *v1; // r4

  v1 = (pthread_mutex_t *)operator new(8u);
  pthread_mutexattr_init(v1[1].__private);
  pthread_mutexattr_settype(&v1[1], 1);
  pthread_mutex_init(v1, v1[1].__private);
  return v1;
}
// 19EE74: using guessed type int __fastcall pthread_mutexattr_settype(_DWORD, _DWORD);

//----- (00266824) --------------------------------------------------------
void AND_FileCleanup()
{
  pthread_mutexattr_t *v0; // r4

  v0 = (pthread_mutexattr_t *)fileMutex;
  if ( fileMutex )
  {
    pthread_mutex_destroy((pthread_mutex_t *)fileMutex);
    pthread_mutexattr_destroy(v0 + 1);
    operator delete(v0);
  }
  fileMutex = 0;
}

//----- (00266858) --------------------------------------------------------
void __fastcall OS_MutexDelete(OSMutex toDelete)
{
  if ( toDelete )
  {
    pthread_mutex_destroy((pthread_mutex_t *)toDelete);
    pthread_mutexattr_destroy((pthread_mutexattr_t *)toDelete + 1);
    sub_191374(toDelete);
  }
}

//----- (0026687C) --------------------------------------------------------
void AsyncFileLock()
{
  sub_1971F0((pthread_mutex_t *)fileMutex);
}

//----- (00266890) --------------------------------------------------------
void AsyncFileUnlock()
{
  sub_18D550((pthread_mutex_t *)fileMutex);
}

//----- (002668A8) --------------------------------------------------------
void __fastcall AND_FileUpdate(double deltaTime)
{
  double v2; // d16
  AndroidFile *v3; // r5
  int v4; // r4

  pthread_mutex_lock((pthread_mutex_t *)fileMutex);
  v2 = deltaTime;
  if ( deltaTime <= 0.1 )
    v2 = 0.1;
  if ( v2 > 0.0 )
  {
    v3 = AndroidFile::firstAsyncFile;
    if ( AndroidFile::firstAsyncFile )
    {
      v4 = MaxAsyncReadMultiply * (int)(v2 * 768.0 * 1024.0);
      if ( v4 <= 5120 )
        v4 = 5120;
      do
      {
        AndroidFile::UpdateRead(v3, v4);
        v3 = v3->nextAsyncFile;
      }
      while ( v3 );
    }
  }
  sub_18D550((pthread_mutex_t *)fileMutex);
}

//----- (00266960) --------------------------------------------------------
void __fastcall OS_SetFilePathOffset(const unsigned __int8 *offset)
{
  if ( BasePath )
    free((void *)BasePath);
  BasePath = j_strdup(offset);
}

//----- (00266994) --------------------------------------------------------
unsigned __int8 *__fastcall AND_FileGetArchiveName(OSFileArchive type)
{
  _JNIEnv *CurrentJNIEnv; // r4
  int v3; // r0
  void *v4; // r9
  const char *v5; // r8
  char *v6; // r0
  const char *v7; // r5
  size_t v8; // r10
  char *v9; // r6

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v3 = _JNIEnv::CallObjectMethod(CurrentJNIEnv, s_event_globalThiz, s_FileGetArchiveName, type);
  v4 = (void *)v3;
  if ( !v3 )
    return 0;
  v5 = (const char *)CurrentJNIEnv->functions->GetStringUTFChars(&CurrentJNIEnv->functions, (jstring)v3, 0);
  v6 = strstr(v5, "/Android");
  if ( !v6 )
    v6 = strstr(v5, "/android");
  v7 = v5;
  if ( v6 )
    v7 = v6;
  v8 = strlen(v7);
  v9 = (char *)malloc(v8 + 1);
  strncpy(v9, v7, v8);
  CurrentJNIEnv->functions->ReleaseStringUTFChars(&CurrentJNIEnv->functions, v4, (const unsigned __int8 *)v5);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, v4);
  v9[v8] = 0;
  return (unsigned __int8 *)v9;
}

//----- (00266A4C) --------------------------------------------------------
bool __fastcall OS_FileFromApk(OSFile *intoFile)
{
  return *(_DWORD *)*intoFile != 1;
}

//----- (00266A5A) --------------------------------------------------------
int __fastcall NvFIsApkFile(NvFile *file)
{
  return *(_DWORD *)file != 1;
}

//----- (00266A68) --------------------------------------------------------
OSFileError __fastcall OS_FileOpen(
        OSFileDataArea area,
        OSFile *intoFile,
        const unsigned __int8 *filename,
        OSFileAccessType access)
{
  int v7; // r0
  int v8; // r4
  __int32 v9; // r11
  unsigned __int8 *v10; // r8
  size_t v11; // r6
  size_t v12; // r10
  size_t v13; // r0
  char *v14; // r0
  unsigned __int8 *v15; // r6
  size_t v16; // r11
  unsigned __int8 *v17; // r0
  unsigned __int8 *v18; // r0
  int v19; // t1
  unsigned __int8 *v20; // r2
  int v21; // t1
  char *i; // r0
  FILE *v23; // r0
  NvFile *v24; // r0
  bool v25; // zf
  int v27; // r8
  ZIPFile *v28; // r10
  int v29; // r4
  unsigned __int8 *v30; // r6
  ZIPFile::ZipEntry *dataPtr; // r0
  _DWORD *v32; // r5
  int offset; // r6
  unsigned int length; // r4
  int v35; // r0
  AndroidFile *v36; // r0
  AndroidFile *nextAsyncFile; // r1
  AndroidFile *v38; // [sp+0h] [bp-30h]
  _BOOL4 userOnly; // [sp+4h] [bp-2Ch]
  ZIPFile *inZip; // [sp+Ch] [bp-24h] BYREF
  OSFile file; // [sp+10h] [bp-20h] BYREF

  v7 = operator new(0x20u);
  v8 = 0;
  *(_DWORD *)(v7 + 12) = 0;
  *(_WORD *)(v7 + 8) = 0;
  *(_DWORD *)v7 = 0;
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 20) = 0;
  *(_DWORD *)(v7 + 24) = -1;
  v38 = (AndroidFile *)v7;
  *(_DWORD *)(v7 + 28) = 0;
  if ( !strncmp((const char *)filename, (const char *)&dword_266D6C, 2u) )
    filename += 2;
  if ( !strncmp((const char *)filename, (const char *)&dword_266D70, 2u) )
    filename += 2;
  if ( (unsigned int)(access - 1) < 2 )
    v8 = 1;
  if ( area != OSFDA_User_0 )
    area = OSFDA_Storage_0;
  v9 = area | v8;
  v10 = (unsigned __int8 *)BasePath;
  if ( !BasePath )
  {
    v10 = j_strdup((const unsigned __int8 *)&byte_61CADE);
    BasePath = v10;
  }
  v11 = strlen((const char *)filename);
  v12 = strlen((const char *)v10);
  v13 = strlen((const char *)StorageRootBuffer);
  v14 = (char *)malloc(v13 + v11 + v12 + 10);
  v15 = (unsigned __int8 *)v14;
  userOnly = v9;
  if ( v9 == 1 )
  {
    v16 = strlen((const char *)StorageRootBuffer);
    sprintf(v15, "%s/%s", (const char *)StorageRootBuffer, (const char *)v10);
    mkdir((const char *)v15, 0x1FFu);
    strcat((char *)v15, (const char *)filename);
    v12 += v16 + 1;
  }
  else
  {
    strcpy(v14, (const char *)v10);
    strcat((char *)v15, (const char *)filename);
  }
  v17 = &v15[strlen((const char *)v15)];
  v19 = *(v17 - 1);
  v18 = v17 - 1;
  if ( v19 == 32 )
  {
    v20 = v18;
    do
    {
      v21 = *--v20;
      *v18 = 0;
      v18 = v20;
    }
    while ( v21 == 32 );
  }
  for ( i = strchr((const char *)v15, 92); i; i = strchr((const char *)v15, 92) )
    *i = 47;
  switch ( access )
  {
    case OSFAT_Read_0:
    case OSFAT_ReadAsync_0:
      if ( userOnly || *filename != 47 )
      {
        if ( v38->readFileHandle )
          goto LABEL_28;
      }
      else
      {
        v24 = NvFOpen(0, filename, 0, 1);
        v38->readFileHandle = v24;
        if ( v24 )
          goto LABEL_28;
      }
      v38->readFileHandle = NvFOpen(BasePath, &v15[v12], userOnly, 1);
LABEL_28:
      free(v15);
      v25 = !userOnly;
      if ( !userOnly )
        v25 = v38->readFileHandle == 0;
      if ( v25 )
      {
        v27 = ZIPFile::FindFromStorage(filename, &inZip);
        if ( v27 != -1 )
        {
          v28 = inZip;
          v29 = 21;
          v30 = inZip->filename;
          do
          {
            if ( OS_FileOpen(OSFDA_Storage_0, &file, v30, access) == OSFE_NoError )
              break;
            usleep(0x1Eu);
            --v29;
          }
          while ( v29 > 1 );
          dataPtr = v28->entries.dataPtr;
          v32 = file;
          offset = dataPtr[v27].offset;
          length = dataPtr[v27].length;
          OS_FileSetPosition(file, offset);
          v35 = v32[7] + offset;
          v32[6] = length;
          v32[7] = v35;
          if ( v32 )
          {
            *intoFile = v32;
            return 0;
          }
        }
      }
      if ( access == OSFAT_ReadAsync_0 )
      {
        if ( !v38->readFileHandle )
          goto LABEL_36;
        if ( *(_DWORD *)v38->readFileHandle == 1 )
        {
          pthread_mutex_lock((pthread_mutex_t *)fileMutex);
          v38->fileAsync = 1;
          v38->nextAsyncFile = AndroidFile::firstAsyncFile;
          AndroidFile::firstAsyncFile = v38;
          pthread_mutex_unlock((pthread_mutex_t *)fileMutex);
        }
      }
      if ( v38->readFileHandle )
      {
LABEL_37:
        *intoFile = v38;
        return 0;
      }
LABEL_36:
      if ( v38->writeFileHandle )
        goto LABEL_37;
      *intoFile = 0;
      if ( v38->fileAsync )
      {
        if ( v38->readBuffer )
          AndroidFile::AsyncFlush(v38);
        pthread_mutex_lock((pthread_mutex_t *)fileMutex);
        v36 = AndroidFile::firstAsyncFile;
        if ( AndroidFile::firstAsyncFile == v38 )
        {
          AndroidFile::firstAsyncFile = v38->nextAsyncFile;
        }
        else
        {
          while ( 1 )
          {
            nextAsyncFile = v36->nextAsyncFile;
            if ( nextAsyncFile == v38 )
              break;
            v36 = v36->nextAsyncFile;
            if ( !nextAsyncFile )
              goto LABEL_54;
          }
          v36->nextAsyncFile = v38->nextAsyncFile;
        }
LABEL_54:
        v38->nextAsyncFile = 0;
        pthread_mutex_unlock((pthread_mutex_t *)fileMutex);
      }
      operator delete(v38);
      return 1;
    case OSFAT_Write_0:
      v38->writeFileHandle = fopen((const char *)v15, (const char *)&dword_266D94);
      goto LABEL_28;
    case OSFAT_ReadWrite_0:
      v23 = fopen((const char *)v15, (const char *)&dword_266D8C);
      v38->writeFileHandle = v23;
      if ( !v23 )
      {
        v38->writeFileHandle = fopen((const char *)v15, (const char *)&dword_266D90);
        v38->justCreated = 1;
      }
      goto LABEL_28;
    default:
      goto LABEL_28;
  }
}
// 266D6C: using guessed type int dword_266D6C;
// 266D70: using guessed type int dword_266D70;
// 266D8C: using guessed type int dword_266D8C;
// 266D90: using guessed type int dword_266D90;
// 266D94: using guessed type int dword_266D94;
// 61CADE: using guessed type char byte_61CADE;

//----- (00266DB4) --------------------------------------------------------
NvFile *__fastcall NvFOpen(const unsigned __int8 *appPrefix, const unsigned __int8 *path, bool userOnly, bool checkAPK)
{
  _BOOL4 v5; // r4
  _BOOL4 v6; // r9
  FILE **v8; // r8
  int v9; // r5
  unsigned int numEntries; // r9
  int v11; // r6
  unsigned __int8 **dataPtr; // r5
  const unsigned __int8 *v13; // r4
  AAsset *v14; // r0
  FILE **v15; // r4
  char *v16; // r0
  FILE *v17; // r0
  unsigned __int8 s[516]; // [sp+8h] [bp-220h] BYREF

  v5 = checkAPK;
  v6 = userOnly;
  v8 = (FILE **)malloc(8u);
  if ( !appPrefix )
  {
    if ( *path == 47 )
    {
      if ( strstr((const char *)path, "/data/app") )
      {
        NvFOpen(char const*,char const*,bool,bool)::ReadApkAsZip = 1;
        strcpy((char *)s, (const char *)path);
      }
      else
      {
        if ( NvFOpen(char const*,char const*,bool,bool)::baseRootIndex == -1 )
        {
          v16 = strstr((const char *)StorageRootBuffer, "/Android");
          if ( v16 || (v16 = strstr((const char *)StorageRootBuffer, "/android")) != 0 )
          {
            NvFOpen(char const*,char const*,bool,bool)::baseRootIndex = v16 - (char *)StorageRootBuffer;
            strncpy(
              (char *)NvFOpen(char const*,char const*,bool,bool)::baseRoot,
              (const char *)StorageRootBuffer,
              v16 - (char *)StorageRootBuffer);
            NvFOpen(char const*,char const*,bool,bool)::baseRoot[NvFOpen(char const*,char const*,bool,bool)::baseRootIndex] = 0;
          }
          else
          {
            strcpy((char *)NvFOpen(char const*,char const*,bool,bool)::baseRoot, (const char *)StorageBaseRootBuffer);
            NvFOpen(char const*,char const*,bool,bool)::baseRootIndex = strlen((const char *)NvFOpen(char const*,char const*,bool,bool)::baseRoot);
          }
        }
        sprintf(s, "%s/%s", NvFOpen(char const*,char const*,bool,bool)::baseRoot, path);
      }
    }
    else
    {
      sprintf(s, "%s%s", StorageRootBuffer, path);
    }
    *v8 = 0;
    goto LABEL_22;
  }
  v9 = (unsigned __int8)NvFOpen(char const*,char const*,bool,bool)::ReadApkAsZip;
  sprintf(s, "%s/%s%s", (const char *)StorageRootBuffer, (const char *)appPrefix, (const char *)path);
  *v8 = 0;
  if ( v9 || !v5 || v6 )
  {
LABEL_22:
    v8[1] = 0;
    v15 = v8 + 1;
LABEL_23:
    v17 = fopen((const char *)s, (const char *)&dword_266FB8);
    if ( v17 )
    {
      *v8 = (FILE *)(&dword_0 + 1);
      *v15 = v17;
    }
    else
    {
      free(v8);
      return 0;
    }
    return v8;
  }
  numEntries = assetsFiles.numEntries;
  if ( assetsFiles.numEntries )
  {
    v11 = 0;
    dataPtr = assetsFiles.dataPtr;
    while ( 1 )
    {
      v13 = dataPtr[v11];
      if ( !strcasecmp((const char *)path, (const char *)v13) )
        break;
      if ( ++v11 >= numEntries )
        goto LABEL_9;
    }
  }
  else
  {
LABEL_9:
    v13 = path;
  }
  v14 = AAssetManager_open(s_manager, (const char *)v13, 0);
  v8[1] = (FILE *)v14;
  v15 = v8 + 1;
  if ( !v14 )
    goto LABEL_23;
  return v8;
}
// 0: using guessed type int dword_0;
// 266FB8: using guessed type int dword_266FB8;
// 6D9ED0: using guessed type char NvFOpen(char const*,char const*,bool,bool)::ReadApkAsZip;

//----- (00266FC0) --------------------------------------------------------
OSFile __fastcall ZIPFile::OpenFromStorage(const unsigned __int8 *filename, OSFileAccessType access)
{
  int v3; // r8
  ZIPFile *v4; // r9
  int v5; // r5
  unsigned __int8 *v6; // r6
  ZIPFile::ZipEntry *dataPtr; // r0
  _DWORD *v8; // r4
  int offset; // r5
  unsigned int length; // r6
  int v11; // r0
  ZIPFile *v13; // [sp+0h] [bp-20h] BYREF
  OSFile intoFile; // [sp+4h] [bp-1Ch] BYREF

  v3 = ZIPFile::FindFromStorage(filename, &v13);
  if ( v3 == -1 )
    return 0;
  v4 = v13;
  v5 = 21;
  v6 = v13->filename;
  do
  {
    if ( OS_FileOpen(OSFDA_Storage_0, &intoFile, v6, access) == OSFE_NoError )
      break;
    usleep(0x1Eu);
    --v5;
  }
  while ( v5 > 1 );
  dataPtr = v4->entries.dataPtr;
  v8 = intoFile;
  offset = dataPtr[v3].offset;
  length = dataPtr[v3].length;
  OS_FileSetPosition(intoFile, offset);
  v11 = v8[7] + offset;
  v8[6] = length;
  v8[7] = v11;
  return v8;
}

//----- (00267034) --------------------------------------------------------
void __fastcall OS_FileSubHandle(OSFile file, int offset, int length)
{
  int v6; // r0

  OS_FileSetPosition(file, offset);
  v6 = *((_DWORD *)file + 7) + offset;
  *((_DWORD *)file + 6) = length;
  *((_DWORD *)file + 7) = v6;
}

//----- (00267054) --------------------------------------------------------
OSFileError __fastcall OS_FileSetPosition(OSFile file, int position)
{
  int v3; // r4
  FILE *v4; // r0
  __int64 *v6; // r0
  AAsset *v7; // r0
  __int64 v8; // kr00_8
  off_t v9; // r1
  __int64 v10; // kr08_8
  off_t v11; // r5
  __int64 v12; // kr10_8
  off_t v13; // r0

  v3 = position;
  v4 = (FILE *)*((_DWORD *)file + 1);
  if ( v4 )
  {
    if ( !fseek(v4, position, 0) )
      return 0;
    return 3;
  }
  v6 = *(__int64 **)file;
  if ( !*(_DWORD *)file )
    return 3;
  if ( !*((_BYTE *)file + 8) )
  {
    if ( *((int *)file + 6) >= 0 )
    {
      v10 = *v6;
      v7 = (AAsset *)*((_DWORD *)v6 + 1);
      v9 = *((_DWORD *)file + 7) + position;
      if ( (_DWORD)v10 == 1 )
        goto LABEL_14;
LABEL_16:
      v11 = AAsset_seek(v7, v9, 0);
      if ( v11 != -1 )
        v11 = 0;
      goto LABEL_18;
    }
    v12 = *v6;
    if ( *(_DWORD *)v6 == 1 )
    {
      if ( !fseek((FILE *)HIDWORD(v12), position, 0) )
        return 0;
    }
    else
    {
      v13 = AAsset_seek((AAsset *)HIDWORD(v12), position, 0);
      if ( v13 != -1 )
        v13 = 0;
      if ( !v13 )
        return 0;
    }
    return 3;
  }
  if ( *((_DWORD *)file + 3) )
  {
    AndroidFile::AsyncFlush((AndroidFile *)file);
    v6 = *(__int64 **)file;
  }
  if ( *((int *)file + 6) >= 0 )
    v3 += *((_DWORD *)file + 7);
  v8 = *v6;
  v7 = (AAsset *)*((_DWORD *)v6 + 1);
  if ( (_DWORD)v8 != 1 )
  {
    v9 = v3;
    goto LABEL_16;
  }
  v9 = v3;
LABEL_14:
  v11 = fseek((FILE *)v7, v9, 0);
LABEL_18:
  if ( v11 )
    return 3;
  return v11;
}

//----- (00267104) --------------------------------------------------------
OSFileError __fastcall OS_FileClose(OSFile file)
{
  FILE *v2; // r0
  __int64 *v4; // r5
  __int64 v5; // kr00_8
  AndroidFile *v6; // r0
  AndroidFile *nextAsyncFile; // r1
  _DWORD *v8; // r1

  if ( !file )
    return 1;
  if ( *((_BYTE *)file + 8) )
    AndroidFile::AsyncFlush((AndroidFile *)file);
  v2 = (FILE *)*((_DWORD *)file + 1);
  if ( v2 )
  {
    fclose(v2);
  }
  else
  {
    v4 = *(__int64 **)file;
    if ( *(_DWORD *)file )
    {
      v5 = *v4;
      if ( *(_DWORD *)v4 == 1 )
        fclose((FILE *)HIDWORD(v5));
      else
        AAsset_close((AAsset *)HIDWORD(v5));
      free(v4);
    }
  }
  if ( *((_BYTE *)file + 8) )
  {
    if ( *((_DWORD *)file + 3) )
      AndroidFile::AsyncFlush((AndroidFile *)file);
    pthread_mutex_lock((pthread_mutex_t *)fileMutex);
    v6 = AndroidFile::firstAsyncFile;
    if ( AndroidFile::firstAsyncFile == file )
    {
      v8 = (char *)file + 20;
      AndroidFile::firstAsyncFile = (AndroidFile *)*((_DWORD *)file + 5);
    }
    else
    {
      while ( 1 )
      {
        nextAsyncFile = v6->nextAsyncFile;
        if ( nextAsyncFile == file )
          break;
        v6 = v6->nextAsyncFile;
        if ( !nextAsyncFile )
        {
          v8 = (char *)file + 20;
          goto LABEL_21;
        }
      }
      v8 = (char *)file + 20;
      v6->nextAsyncFile = (AndroidFile *)*((_DWORD *)file + 5);
    }
LABEL_21:
    *v8 = 0;
    pthread_mutex_unlock((pthread_mutex_t *)fileMutex);
  }
  operator delete(file);
  return 0;
}

//----- (002671C0) --------------------------------------------------------
void __fastcall NvFClose(NvFile *file)
{
  __int64 v2; // kr00_8

  v2 = *(_QWORD *)file;
  if ( *(_DWORD *)file == 1 )
    fclose((FILE *)HIDWORD(v2));
  else
    AAsset_close((AAsset *)HIDWORD(v2));
  j_free(file);
}

//----- (002671E2) --------------------------------------------------------
OSFileError __fastcall OS_FileRead(OSFile file, void *buffer, int numBytes)
{
  __int64 v7; // kr00_8
  int v8; // r0
  off_t Length; // r8
  __int64 v10; // kr08_8
  int v11; // r0
  signed int v12; // r6
  __int64 v13; // kr10_8
  __int64 *v14; // r0
  __int64 v15; // kr18_8
  void *v16; // r0
  int v17; // r2
  FILE *v18; // r3
  off_t v19; // r10
  off_t v20; // r5
  int v21; // r2
  __int64 *v22; // r0
  __int64 v23; // kr20_8
  off_t v24; // r8
  off_t v25; // r5
  signed int v26; // r0
  off_t v27; // r6
  unsigned int v28; // r6
  FILE *v29; // r0

  if ( !numBytes )
    return 0;
  if ( *((_BYTE *)file + 8) )
  {
    if ( *((_DWORD *)file + 3) )
      AndroidFile::AsyncFlush((AndroidFile *)file);
    *((_DWORD *)file + 3) = buffer;
    *((_DWORD *)file + 4) = numBytes;
    return 0;
  }
  if ( *((int *)file + 6) >= 0 )
  {
    v7 = *(_QWORD *)*(_DWORD *)file;
    if ( (_DWORD)v7 == 1 )
    {
      v8 = ftell((FILE *)HIDWORD(v7));
    }
    else
    {
      Length = AAsset_getLength((AAsset *)HIDWORD(v7));
      v8 = Length - AAsset_getRemainingLength((AAsset *)HIDWORD(v7));
    }
    v10 = *((_QWORD *)file + 3);
    v11 = v8 - HIDWORD(v10);
    if ( v11 + numBytes > (int)v10 )
    {
      v12 = v10 - v11;
      if ( (int)v10 - v11 >= 1 )
      {
        v13 = *(_QWORD *)*(_DWORD *)file;
        if ( (_DWORD)v13 == 1 )
        {
          fread(buffer, 1u, v12, (FILE *)HIDWORD(v13));
        }
        else
        {
          v24 = AAsset_getLength((AAsset *)HIDWORD(v13));
          v25 = AAsset_getLength((AAsset *)HIDWORD(v13));
          v26 = AAsset_getRemainingLength((AAsset *)HIDWORD(v13)) - v25 + v24;
          if ( v12 > v26 )
            v12 = v26;
          AAsset_read((AAsset *)HIDWORD(v13), buffer, v12);
        }
      }
      return 2;
    }
  }
  v14 = *(__int64 **)file;
  if ( !*(_DWORD *)file )
  {
    v18 = (FILE *)*((_DWORD *)file + 1);
    v16 = buffer;
    v17 = numBytes;
LABEL_19:
    if ( fread(v16, 1u, v17, v18) != numBytes )
      goto LABEL_24;
    return 0;
  }
  v15 = *v14;
  if ( *(_DWORD *)v14 == 1 )
  {
    v16 = buffer;
    v17 = numBytes;
    v18 = (FILE *)HIDWORD(v15);
    goto LABEL_19;
  }
  v19 = AAsset_getLength((AAsset *)HIDWORD(v15));
  v20 = AAsset_getLength((AAsset *)HIDWORD(v15));
  v21 = AAsset_getRemainingLength((AAsset *)HIDWORD(v15)) - v20 + v19;
  if ( v21 >= numBytes )
    v21 = numBytes;
  if ( AAsset_read((AAsset *)HIDWORD(v15), buffer, v21) == numBytes )
    return 0;
LABEL_24:
  v22 = *(__int64 **)file;
  if ( *(_DWORD *)file )
  {
    v23 = *v22;
    if ( *(_DWORD *)v22 == 1 )
    {
      if ( !feof((FILE *)HIDWORD(v23)) )
        goto LABEL_32;
      return 2;
    }
    v27 = AAsset_getLength((AAsset *)HIDWORD(v23));
    v28 = v27 - AAsset_getRemainingLength((AAsset *)HIDWORD(v23));
    if ( v28 >= AAsset_getLength((AAsset *)HIDWORD(v23)) )
      return 2;
  }
LABEL_32:
  v29 = (FILE *)*((_DWORD *)file + 1);
  if ( v29 && feof(v29) )
    return 2;
  return 3;
}

//----- (00267336) --------------------------------------------------------
int __fastcall NvFTell(NvFile *stream)
{
  __int64 v1; // kr00_8
  off_t Length; // r5

  v1 = *(_QWORD *)stream;
  if ( *(_DWORD *)stream == 1 )
    return sub_18E820((FILE *)HIDWORD(v1));
  Length = AAsset_getLength((AAsset *)HIDWORD(v1));
  return Length - AAsset_getRemainingLength((AAsset *)HIDWORD(v1));
}

//----- (0026735E) --------------------------------------------------------
size_t __fastcall NvFRead(void *ptr, size_t size, size_t nmemb, NvFile *stream)
{
  __int64 v5; // kr00_8
  size_t v6; // r4
  signed int v8; // r6
  off_t Length; // r9
  off_t v10; // r10
  signed int v11; // r0
  int v12; // r0

  v5 = *(_QWORD *)stream;
  v6 = size;
  if ( *(_DWORD *)stream == 1 )
    return sub_199830(ptr, size, nmemb, (FILE *)HIDWORD(v5));
  v8 = nmemb * size;
  Length = AAsset_getLength((AAsset *)HIDWORD(v5));
  v10 = AAsset_getLength((AAsset *)HIDWORD(v5));
  v11 = AAsset_getRemainingLength((AAsset *)HIDWORD(v5)) - v10 + Length;
  if ( v8 > v11 )
    v8 = v11;
  v12 = AAsset_read((AAsset *)HIDWORD(v5), ptr, v8);
  if ( !v6 )
    v6 = 1;
  return sub_19E670(v12, v6);
}
// 19E670: using guessed type int __fastcall sub_19E670(_DWORD, _DWORD);

//----- (002673C8) --------------------------------------------------------
int __fastcall NvFEOF(NvFile *stream)
{
  __int64 v1; // kr00_8
  off_t Length; // r5
  unsigned int v4; // r5

  v1 = *(_QWORD *)stream;
  if ( *(_DWORD *)stream == 1 )
    return sub_18E30C((FILE *)HIDWORD(v1));
  Length = AAsset_getLength((AAsset *)HIDWORD(v1));
  v4 = Length - AAsset_getRemainingLength((AAsset *)HIDWORD(v1));
  return v4 >= AAsset_getLength((AAsset *)HIDWORD(v1));
}

//----- (00267400) --------------------------------------------------------
OSFileError __fastcall OS_FileWrite(OSFile file, const void *buffer, int numBytes)
{
  size_t v5; // r0
  OSFileError v6; // r1

  v5 = fwrite(buffer, 1u, numBytes, *((FILE **)file + 1));
  *((_BYTE *)file + 9) = 0;
  v6 = OSFE_UnknownError;
  if ( v5 == numBytes )
    return 0;
  return v6;
}

//----- (00267424) --------------------------------------------------------
OSFileError __fastcall OS_FileDelete(OSFileDataArea area, const unsigned __int8 *filename)
{
  _JNIEnv *CurrentJNIEnv; // r5
  int v4; // r4

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v4 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, filename);
  _JNIEnv::CallBooleanMethod(CurrentJNIEnv, s_event_globalThiz, s_DeleteFile, v4);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v4);
  return 0;
}

//----- (0026746C) --------------------------------------------------------
int __fastcall AND_FileDelete(const unsigned __int8 *filename)
{
  _JNIEnv *CurrentJNIEnv; // r5
  int v3; // r4
  int v4; // r6

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v3 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, filename);
  v4 = _JNIEnv::CallBooleanMethod(CurrentJNIEnv, s_event_globalThiz, s_DeleteFile, v3);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v3);
  return v4 != 0;
}

//----- (002674C4) --------------------------------------------------------
int __fastcall OS_FileSize(OSFile file)
{
  FILE *v2; // r0
  int result; // r0
  int v4; // r6
  int v5; // r5
  int v6; // r6
  int v7; // r4
  int v8; // r5

  v2 = (FILE *)*((_DWORD *)file + 1);
  if ( v2 )
  {
    if ( *((_BYTE *)file + 9) )
    {
      return 0;
    }
    else
    {
      v5 = ftell(v2);
      fseek(*((FILE **)file + 1), 0, 2);
      v6 = ftell(*((FILE **)file + 1));
      fseek(*((FILE **)file + 1), v5, 0);
      return v6;
    }
  }
  else
  {
    v4 = *(_DWORD *)file;
    if ( !*(_DWORD *)file )
      return -1;
    if ( *((_BYTE *)file + 8) )
    {
      if ( *((_DWORD *)file + 3) )
      {
        AndroidFile::AsyncFlush((AndroidFile *)file);
        v4 = *(_DWORD *)file;
      }
    }
    else
    {
      result = *((_DWORD *)file + 6);
      if ( result > -1 )
        return result;
    }
    if ( *(_DWORD *)v4 == 1 )
    {
      v7 = ftell(*(FILE **)(v4 + 4));
      fseek(*(FILE **)(v4 + 4), 0, 2);
      v8 = ftell(*(FILE **)(v4 + 4));
      fseek(*(FILE **)(v4 + 4), v7, 0);
      return v8;
    }
    else
    {
      return sub_1937A8(*(AAsset **)(v4 + 4));
    }
  }
}

//----- (00267570) --------------------------------------------------------
size_t __fastcall NvFSize(NvFile *stream)
{
  int v2; // r5
  int v3; // r6

  if ( *(_DWORD *)stream != 1 )
    return sub_1937A8(*((AAsset **)stream + 1));
  v2 = ftell(*((FILE **)stream + 1));
  fseek(*((FILE **)stream + 1), 0, 2);
  v3 = ftell(*((FILE **)stream + 1));
  fseek(*((FILE **)stream + 1), v2, 0);
  return v3;
}

//----- (002675BA) --------------------------------------------------------
int __fastcall NvFSeek(NvFile *stream, int offset, int type)
{
  __int64 v3; // kr00_8
  int result; // r0

  v3 = *(_QWORD *)stream;
  if ( *(_DWORD *)stream == 1 )
    return sub_195C40((FILE *)HIDWORD(v3), offset, type);
  result = AAsset_seek((AAsset *)HIDWORD(v3), offset, type);
  if ( result != -1 )
    return 0;
  return result;
}

//----- (002675D6) --------------------------------------------------------
int __fastcall OS_FileGetPosition(OSFile file)
{
  FILE *v2; // r0
  int result; // r0
  __int64 v4; // kr00_8
  off_t Length; // r6

  v2 = (FILE *)*((_DWORD *)file + 1);
  if ( v2 )
    return sub_18E820(v2);
  v4 = *(_QWORD *)*(_DWORD *)file;
  if ( (_DWORD)v4 == 1 )
  {
    result = ftell((FILE *)HIDWORD(v4));
  }
  else
  {
    Length = AAsset_getLength((AAsset *)HIDWORD(v4));
    result = Length - AAsset_getRemainingLength((AAsset *)HIDWORD(v4));
  }
  if ( *((int *)file + 6) >= 0 )
    result -= *((_DWORD *)file + 7);
  return result;
}

//----- (00267622) --------------------------------------------------------
OSFileError __fastcall OS_FileGetState(OSFile file)
{
  OSFileError result; // r0

  if ( !*((_BYTE *)file + 8) )
    return 0;
  result = *((_DWORD *)file + 3);
  if ( result )
    return 4;
  return result;
}

//----- (00267636) --------------------------------------------------------
OSFileError __fastcall OS_FileFlush(OSFile file)
{
  if ( *((_BYTE *)file + 8) )
    return sub_18ED74((AndroidFile *)file);
  else
    return 0;
}

//----- (00267644) --------------------------------------------------------
OSFileError __fastcall OS_FileRename(
        OSFileDataArea area,
        const unsigned __int8 *oldFilename,
        const unsigned __int8 *newFilename,
        bool overWrite)
{
  _JNIEnv *CurrentJNIEnv; // r4
  int v7; // r6
  int v8; // r5
  int v9; // r8
  OSFileError result; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v7 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, oldFilename);
  v8 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, newFilename);
  v9 = _JNIEnv::CallBooleanMethod(CurrentJNIEnv, s_event_globalThiz, s_FileRename, v7, v8);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v7);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v8);
  result = OSFE_UnknownError;
  if ( v9 )
    return 0;
  return result;
}

//----- (002676BC) --------------------------------------------------------
int __fastcall AND_FileRename(const unsigned __int8 *oldFilename, const unsigned __int8 *newFilename, int overWrite)
{
  _JNIEnv *CurrentJNIEnv; // r4
  int v6; // r8
  int v7; // r5
  int v8; // r6

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v6 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, oldFilename);
  v7 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, newFilename);
  v8 = _JNIEnv::CallBooleanMethod(CurrentJNIEnv, s_event_globalThiz, s_FileRename, v6, v7);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v6);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v7);
  return v8 != 0;
}

//----- (00267738) --------------------------------------------------------
OSDate __fastcall OS_FileGetDate(OSFileDataArea area, const unsigned __int8 *filename)
{
  size_t v4; // r5
  const char *v5; // r6
  size_t v6; // r5
  size_t v7; // r0
  unsigned __int8 *v8; // r0
  char *v9; // r5
  int v10; // r4
  OSDate result; // r0
  struct stat v12; // [sp+0h] [bp-78h] BYREF

  v4 = strlen((const char *)filename);
  v5 = (const char *)BasePath;
  v6 = v4 + strlen((const char *)BasePath);
  v7 = strlen((const char *)StorageRootBuffer);
  v8 = (unsigned __int8 *)malloc(v7 + v6 + 10);
  v9 = (char *)v8;
  if ( area == OSFDA_User_0 )
  {
    sprintf(v8, "%s/%s", (const char *)StorageRootBuffer, v5);
    strcat(v9, (const char *)filename);
    v10 = stat_0(v9, &v12);
    free(v9);
  }
  else
  {
    strcpy((char *)v8, v5);
    strcat(v9, (const char *)filename);
    v10 = stat_0(v9, &v12);
  }
  result = 0LL;
  if ( !v10 )
    return v12.st_mtim.tv_sec;
  return result;
}

//----- (002677E8) --------------------------------------------------------
bool __fastcall OS_FileCreateDirectory(OSFileDataArea area, const unsigned __int8 *filepath)
{
  return 0;
}

//----- (002677EC) --------------------------------------------------------
const unsigned __int8 **OS_FileListUserFiles()
{
  DIR *v0; // r5
  char *v1; // r9
  struct dirent *v2; // r4
  char *v3; // r8
  int v4; // r10
  const char *d_name; // r4
  int v6; // t1
  unsigned __int8 s[512]; // [sp+4h] [bp-21Ch] BYREF

  sprintf(s, "%s/%s", (const char *)StorageRootBuffer, (const char *)BasePath);
  v0 = opendir((const char *)s);
  v1 = (char *)malloc(0x10400u);
  memset(v1, 0, 0x400u);
  if ( v0 )
  {
    v2 = readdir(v0);
    if ( v2 )
    {
      v3 = v1 + 1024;
      v4 = 0;
      do
      {
        v6 = v2->d_name[0];
        d_name = (const char *)v2->d_name;
        if ( v6 != 46 && strncmp(d_name, (const char *)&off_2678C4, 3u) )
        {
          strcpy(v3, d_name);
          *(_DWORD *)&v1[4 * v4++] = v3;
          v3 += strlen(v3) + 1;
        }
        v2 = readdir(v0);
      }
      while ( v2 );
    }
    closedir(v0);
  }
  return (const unsigned __int8 **)v1;
}
// 2678C4: using guessed type void *off_2678C4;

//----- (002678CC) --------------------------------------------------------
void AND_GamepadInitialize()
{
  *(_QWORD *)&lastGamepadAxis[3][2] = 0LL;
  *(_QWORD *)&lastGamepadAxis[3][4] = 0LL;
  *(_QWORD *)&lastGamepadAxis[2][4] = 0LL;
  *(_QWORD *)&lastGamepadAxis[3][0] = 0LL;
  *(_QWORD *)&lastGamepadAxis[2][0] = 0LL;
  *(_QWORD *)&lastGamepadAxis[2][2] = 0LL;
  *(_QWORD *)&lastGamepadAxis[1][2] = 0LL;
  *(_QWORD *)&lastGamepadAxis[1][4] = 0LL;
  *(_QWORD *)&lastGamepadAxis[0][0] = 0LL;
  *(_QWORD *)&lastGamepadAxis[0][2] = 0LL;
  *(_QWORD *)&lastGamepadAxis[0][4] = 0LL;
  *(_QWORD *)&lastGamepadAxis[1][0] = 0LL;
}

//----- (00267904) --------------------------------------------------------
void AND_GamepadUpdate()
{
  int v0; // r5
  _JNIEnv *CurrentJNIEnv; // r0
  jint v2; // r6
  int v3; // r0
  _JNIEnv *v4; // r0
  _JNIEnv *v5; // r0
  jint v6; // r6
  int v7; // r0
  int v8; // r10
  int v9; // r9
  OSEventType v10; // r0
  _JNIEnv *v11; // r0
  _JNIEnv *v12; // r0
  jfloat *v13; // r6
  _JNIEnv *v14; // r0
  _JNIEnv *v15; // r0
  _JNIEnv *v16; // r0
  _JNIEnv *v17; // r0
  int v19; // [sp+28h] [bp-28h] BYREF
  int v20; // [sp+2Ch] [bp-24h]
  _BOOL4 v21; // [sp+30h] [bp-20h]

  v0 = 0;
  do
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    v2 = _JNIEnv::CallIntMethod(CurrentJNIEnv, s_event_globalThiz, s_getGamepadType, v0);
    v3 = lastGamepadType[v0];
    if ( v2 != v3 )
    {
      v19 = 0;
      v21 = v2 != -1;
      if ( v2 != -1 )
        v3 = v2;
      v20 = v3;
      v4 = NVThreadGetCurrentJNIEnv();
      lastGamepadType[v0] = _JNIEnv::CallIntMethod(v4, s_event_globalThiz, s_getGamepadType, v0);
      OS_ApplicationEvent(OSET_GamepadConnection, &v19);
    }
    if ( v2 == -1 )
      break;
    v5 = NVThreadGetCurrentJNIEnv();
    v6 = _JNIEnv::CallIntMethod(v5, s_event_globalThiz, s_getGamepadButtons, v0);
    v7 = lastGamepadMask[v0];
    if ( v6 != v7 )
    {
      v8 = v7 ^ v6;
      v9 = 0;
      v19 = v0;
      v20 = lastGamepadType[v0];
      do
      {
        if ( ((1 << v9) & v8) != 0 )
        {
          v21 = v9;
          if ( ((1 << v9) & v6) != 0 )
            v10 = OSET_GamepadButtonDown;
          else
            v10 = OSET_GamepadButtonUp;
          LIB_InputEvent(v10, &v19);
        }
        ++v9;
      }
      while ( v9 != 16 );
      lastGamepadMask[v0] = v6;
    }
    v11 = NVThreadGetCurrentJNIEnv();
    lastGamepadAxis[v0][0] = _JNIEnv::CallFloatMethod(v11, s_event_globalThiz, s_getGamepadAxis, v0, 0);
    v12 = NVThreadGetCurrentJNIEnv();
    v13 = lastGamepadAxis[v0];
    v13[1] = _JNIEnv::CallFloatMethod(v12, s_event_globalThiz, s_getGamepadAxis, v0, 1);
    v14 = NVThreadGetCurrentJNIEnv();
    v13[2] = _JNIEnv::CallFloatMethod(v14, s_event_globalThiz, s_getGamepadAxis, v0, 2);
    v15 = NVThreadGetCurrentJNIEnv();
    v13[3] = _JNIEnv::CallFloatMethod(v15, s_event_globalThiz, s_getGamepadAxis, v0, 3);
    v16 = NVThreadGetCurrentJNIEnv();
    v13[4] = _JNIEnv::CallFloatMethod(v16, s_event_globalThiz, s_getGamepadAxis, v0, 4);
    v17 = NVThreadGetCurrentJNIEnv();
    v13[5] = _JNIEnv::CallFloatMethod(v17, s_event_globalThiz, s_getGamepadAxis, v0, 5);
  }
  while ( v0++ < 3 );
}

//----- (00267B10) --------------------------------------------------------
int __fastcall WarGamepad_GetGamepadType(int padId)
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  return sub_18B7B4(CurrentJNIEnv, s_event_globalThiz, s_getGamepadType);
}

//----- (00267B44) --------------------------------------------------------
int __fastcall WarGamepad_GetGamepadButtons(int padId)
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  return sub_18B7B4(CurrentJNIEnv, s_event_globalThiz, s_getGamepadButtons);
}

//----- (00267B78) --------------------------------------------------------
void __fastcall LIB_InputEvent(OSEventType type, void *data)
{
  OSEventType v2; // r11
  _QWORD *v3; // r4
  int v4; // r9
  double v5; // d17
  int v6; // r9
  double v7; // d17
  int v8; // r6
  int *p_systemX; // r0
  int v10; // r12
  __int64 v11; // kr08_8
  __int64 v12; // d8
  int v13; // r6
  ButtonContainer<3> *v14; // r11
  int v15; // r3
  int *v16; // r11
  int systemX; // t1
  int *v18; // r8
  int v19; // r9
  _DWORD *v20; // r5
  unsigned int v21; // r5
  void *v22; // r10
  char *v23; // r4
  _DWORD *v24; // r4
  void *v25; // r6
  void *v26; // t1
  int v27; // r5
  int v28; // r8
  double v29; // d17
  int v30; // r5
  int v31; // r8
  double v32; // d17
  double v33; // d16
  double v34; // d8
  __int64 v35; // kr10_8
  unsigned int numEntries; // r5
  unsigned int v37; // r9
  ButtonStateChange *dataPtr; // r6
  ButtonStateChange *v39; // r11
  double v40; // d16
  __int64 v41; // kr20_8
  unsigned int v42; // r5
  unsigned int v43; // r9
  ButtonStateChange *v44; // r6
  ButtonStateChange *v45; // r11
  double v46; // d16
  int v47; // r4
  ButtonContainer<16> *v48; // r5
  double v49; // d8
  OSArray<ButtonStateChange> *p_pendingChanges; // r5
  unsigned int numAlloced; // t1
  unsigned int v52; // r9
  unsigned int *p_numEntries; // r10
  unsigned __int64 v54; // r2
  unsigned int v55; // r11
  ButtonStateChange *v56; // r6
  ButtonContainer<16> *v57; // r4
  ButtonStateChange **p_dataPtr; // r4
  ButtonStateChange *v59; // r8
  ButtonStateChange *v60; // t1
  double v61; // d16
  int v62; // r4
  ButtonContainer<16> *v63; // r5
  OSArray<ButtonStateChange> *v64; // r5
  unsigned int v65; // t1
  unsigned int v66; // r9
  unsigned __int64 v67; // r2
  unsigned int v68; // r11
  ButtonStateChange *v69; // r6
  ButtonContainer<16> *v70; // r4
  ButtonStateChange **v71; // r4
  ButtonStateChange *v72; // r8
  ButtonStateChange *v73; // t1
  int v74; // r1
  __int64 v75; // kr30_8
  int v76; // r3
  ButtonStateChange *v77; // r1
  char *v78; // r0
  int v79; // [sp+8h] [bp-50h]
  int v80; // [sp+Ch] [bp-4Ch]
  int v81; // [sp+14h] [bp-44h]
  unsigned int v82; // [sp+14h] [bp-44h]
  unsigned int v83; // [sp+14h] [bp-44h]
  int v84; // [sp+18h] [bp-40h]
  unsigned int v85; // [sp+18h] [bp-40h]
  unsigned int v86; // [sp+18h] [bp-40h]
  int v87; // [sp+1Ch] [bp-3Ch]
  int v88; // [sp+1Ch] [bp-3Ch]
  int v89; // [sp+1Ch] [bp-3Ch]
  int v91; // [sp+20h] [bp-38h]
  int v92; // [sp+20h] [bp-38h]
  _QWORD *v93; // [sp+20h] [bp-38h]
  OSEventType v95; // [sp+24h] [bp-34h]
  OSEventType v96; // [sp+24h] [bp-34h]
  OSEventType v97; // [sp+24h] [bp-34h]
  OSEventType v98; // [sp+24h] [bp-34h]
  struct timeval tv; // [sp+28h] [bp-30h] BYREF

  v2 = type;
  v3 = data;
  switch ( type )
  {
    case OSET_KeyboardDown:
      v4 = *(_DWORD *)data;
      gettimeofday(&tv, 0);
      if ( tv.tv_usec > (int)"ist_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly"
        || tv.tv_usec <= -1 )
      {
        v5 = OS_TimeAccurate(void)::last_current_time
           - (double)(unsigned int)OS_TimeAccurate(void)::last_current_time
           + 0.00033;
      }
      else
      {
        v5 = (double)tv.tv_usec / 1000000.0;
      }
      v33 = v5 + (double)tv.tv_sec;
      OS_TimeAccurate(void)::last_current_time = v33;
      if ( v33 - OS_TimeAccurate(void)::lastPrint > 5.0 )
        OS_TimeAccurate(void)::lastPrint = v5 + (double)tv.tv_sec;
      v34 = v33 - base_time;
      v35 = *(_QWORD *)&keys.systemX;
      numEntries = keys.pendingChanges.numEntries;
      if ( keys.pendingChanges.numAlloced >= keys.pendingChanges.numEntries + 1 )
      {
        dataPtr = keys.pendingChanges.dataPtr;
      }
      else
      {
        v91 = v4;
        v95 = v2;
        v37 = 4 * (keys.pendingChanges.numEntries + 1) / 3 + 3;
        dataPtr = (ButtonStateChange *)malloc(32 * v37);
        v39 = keys.pendingChanges.dataPtr;
        if ( keys.pendingChanges.dataPtr )
        {
          qmemcpy(dataPtr, keys.pendingChanges.dataPtr, 32 * numEntries);
          free(v39);
          numEntries = keys.pendingChanges.numEntries;
        }
        v2 = v95;
        keys.pendingChanges.dataPtr = dataPtr;
        keys.pendingChanges.numAlloced = v37;
        v4 = v91;
      }
      dataPtr[numEntries].buttonIndex = v4;
      v77 = &dataPtr[numEntries];
      v77->state = OSPS_ButtonPressed;
      *(_QWORD *)&v77->x = v35;
      goto LABEL_53;
    case OSET_KeyboardUp:
      v6 = *(_DWORD *)data;
      gettimeofday(&tv, 0);
      if ( tv.tv_usec > (int)"ist_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly"
        || tv.tv_usec <= -1 )
      {
        v7 = OS_TimeAccurate(void)::last_current_time
           - (double)(unsigned int)OS_TimeAccurate(void)::last_current_time
           + 0.00033;
      }
      else
      {
        v7 = (double)tv.tv_usec / 1000000.0;
      }
      v40 = v7 + (double)tv.tv_sec;
      OS_TimeAccurate(void)::last_current_time = v40;
      if ( v40 - OS_TimeAccurate(void)::lastPrint > 5.0 )
        OS_TimeAccurate(void)::lastPrint = v7 + (double)tv.tv_sec;
      v34 = v40 - base_time;
      v41 = *(_QWORD *)&keys.systemX;
      v42 = keys.pendingChanges.numEntries;
      if ( keys.pendingChanges.numAlloced >= keys.pendingChanges.numEntries + 1 )
      {
        v44 = keys.pendingChanges.dataPtr;
      }
      else
      {
        v92 = v6;
        v96 = v2;
        v43 = 4 * (keys.pendingChanges.numEntries + 1) / 3 + 3;
        v44 = (ButtonStateChange *)malloc(32 * v43);
        v45 = keys.pendingChanges.dataPtr;
        if ( keys.pendingChanges.dataPtr )
        {
          qmemcpy(v44, keys.pendingChanges.dataPtr, 32 * v42);
          free(v45);
          v42 = keys.pendingChanges.numEntries;
        }
        v2 = v96;
        keys.pendingChanges.dataPtr = v44;
        keys.pendingChanges.numAlloced = v43;
        v6 = v92;
      }
      v44[v42].buttonIndex = v6;
      v77 = &v44[v42];
      v77->state = OSPS_ButtonReleased;
      *(_QWORD *)&v77->x = v41;
LABEL_53:
      v77->timeStamp = v34;
      v77->force = 0.0;
      ++keys.pendingChanges.numEntries;
      break;
    case OSET_PointerMove:
      v8 = *((_DWORD *)data + 8);
      p_systemX = &pointers[*(_DWORD *)data].systemX;
      *(_QWORD *)p_systemX = *(_QWORD *)((char *)data + 12);
      p_systemX[2] = v8;
      break;
    case OSET_PointerButton:
      v10 = *((_DWORD *)data + 1);
      v11 = *((_QWORD *)data + 3);
      v12 = *((_QWORD *)data + 2);
      v13 = 7 * *(_DWORD *)data;
      v14 = &pointers[*(_DWORD *)data];
      systemX = v14->systemX;
      v16 = &v14->systemX;
      v15 = systemX;
      v18 = v16 + 4;
      v19 = v16[4];
      v20 = v16 + 1;
      v84 = v16[1];
      v87 = *((_DWORD *)data + 6);
      if ( v16[3] < (unsigned int)(v19 + 1) )
      {
        v79 = v15;
        v80 = *((_DWORD *)data + 1);
        v21 = 4 * (v19 + 1) / 3u + 3;
        v22 = malloc(32 * v21);
        v81 = v13;
        v23 = (char *)pointers + 16 * v13;
        v26 = (void *)*((_DWORD *)v23 + 11);
        v24 = v23 + 44;
        v25 = v26;
        if ( v26 )
        {
          qmemcpy(v22, v25, 32 * v19);
          free(v25);
          v19 = *v18;
        }
        v16[3] = v21;
        *v24 = v22;
        v3 = data;
        v13 = v81;
        v20 = v16 + 1;
        v15 = v79;
        v10 = v80;
      }
      *(_DWORD *)(v11 + 32 * v19) = v10;
      v74 = v11 + 32 * v19;
      *(_DWORD *)(v74 + 4) = HIDWORD(v11);
      *(_DWORD *)(v74 + 8) = v15;
      *(_DWORD *)(v74 + 12) = v84;
      *(_QWORD *)(v74 + 16) = v12;
      *(_DWORD *)(v74 + 24) = v87;
      ++*v18;
      v75 = v3[1];
      v76 = *((_DWORD *)v3 + 6);
      *v16 = v75;
      *v20 = HIDWORD(v75);
      *((_DWORD *)&pointers[0].systemForce + 4 * v13) = v76;
      v2 = type;
      break;
    case OSET_GamepadButtonDown:
      v27 = *(_DWORD *)data;
      v28 = *((_DWORD *)data + 2);
      gettimeofday(&tv, 0);
      if ( tv.tv_usec > (int)"ist_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly"
        || tv.tv_usec <= -1 )
      {
        v29 = OS_TimeAccurate(void)::last_current_time
            - (double)(unsigned int)OS_TimeAccurate(void)::last_current_time
            + 0.00033;
      }
      else
      {
        v29 = (double)tv.tv_usec / 1000000.0;
      }
      v46 = v29 + (double)tv.tv_sec;
      v93 = v3;
      OS_TimeAccurate(void)::last_current_time = v46;
      if ( v46 - OS_TimeAccurate(void)::lastPrint > 5.0 )
        OS_TimeAccurate(void)::lastPrint = v29 + (double)tv.tv_sec;
      v47 = v27;
      v48 = &gamepads[v27];
      v49 = v46 - base_time;
      numAlloced = v48->pendingChanges.numAlloced;
      p_pendingChanges = &v48->pendingChanges;
      p_numEntries = &p_pendingChanges->numEntries;
      v52 = p_pendingChanges->numEntries;
      v54 = *(_QWORD *)&p_pendingChanges[-1].numAlloced;
      if ( numAlloced >= v52 + 1 )
      {
        v56 = gamepads[v47].pendingChanges.dataPtr;
      }
      else
      {
        v82 = p_pendingChanges[-1].numEntries;
        v85 = p_pendingChanges[-1].numAlloced;
        v88 = v28;
        v97 = v2;
        v55 = 4 * (v52 + 1) / 3 + 3;
        v56 = (ButtonStateChange *)malloc(32 * v55);
        v57 = &gamepads[v47];
        v60 = v57->pendingChanges.dataPtr;
        p_dataPtr = &v57->pendingChanges.dataPtr;
        v59 = v60;
        if ( v60 )
        {
          qmemcpy(v56, v59, 32 * v52);
          free(v59);
          v52 = *p_numEntries;
        }
        v28 = v88;
        v54 = __PAIR64__(v82, v85);
        p_pendingChanges->numAlloced = v55;
        *p_dataPtr = v56;
        v2 = v97;
      }
      v56[v52].buttonIndex = v28;
      v78 = (char *)&v56[v52];
      *((_DWORD *)v78 + 1) = 2;
      *((_QWORD *)v78 + 1) = v54;
      goto LABEL_58;
    case OSET_GamepadButtonUp:
      v30 = *(_DWORD *)data;
      v31 = *((_DWORD *)data + 2);
      gettimeofday(&tv, 0);
      if ( tv.tv_usec > (int)"ist_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly"
        || tv.tv_usec <= -1 )
      {
        v32 = OS_TimeAccurate(void)::last_current_time
            - (double)(unsigned int)OS_TimeAccurate(void)::last_current_time
            + 0.00033;
      }
      else
      {
        v32 = (double)tv.tv_usec / 1000000.0;
      }
      v61 = v32 + (double)tv.tv_sec;
      v93 = v3;
      OS_TimeAccurate(void)::last_current_time = v61;
      if ( v61 - OS_TimeAccurate(void)::lastPrint > 5.0 )
        OS_TimeAccurate(void)::lastPrint = v32 + (double)tv.tv_sec;
      v62 = v30;
      v63 = &gamepads[v30];
      v49 = v61 - base_time;
      v65 = v63->pendingChanges.numAlloced;
      v64 = &v63->pendingChanges;
      p_numEntries = &v64->numEntries;
      v66 = v64->numEntries;
      v67 = *(_QWORD *)&v64[-1].numAlloced;
      if ( v65 >= v66 + 1 )
      {
        v69 = gamepads[v62].pendingChanges.dataPtr;
      }
      else
      {
        v83 = v64[-1].numEntries;
        v86 = v64[-1].numAlloced;
        v89 = v31;
        v98 = v2;
        v68 = 4 * (v66 + 1) / 3 + 3;
        v69 = (ButtonStateChange *)malloc(32 * v68);
        v70 = &gamepads[v62];
        v73 = v70->pendingChanges.dataPtr;
        v71 = &v70->pendingChanges.dataPtr;
        v72 = v73;
        if ( v73 )
        {
          qmemcpy(v69, v72, 32 * v66);
          free(v72);
          v66 = *p_numEntries;
        }
        v31 = v89;
        v64->numAlloced = v68;
        *v71 = v69;
        v2 = v98;
        v67 = __PAIR64__(v83, v86);
      }
      v69[v66].buttonIndex = v31;
      v78 = (char *)&v69[v66];
      *((_DWORD *)v78 + 1) = 0;
      *((_QWORD *)v78 + 1) = v67;
LABEL_58:
      *((double *)v78 + 2) = v49;
      *((_DWORD *)v78 + 6) = 0;
      ++*p_numEntries;
      v3 = v93;
      break;
    case OSET_PointerWheel:
      pointers[*(_DWORD *)data].AccumulatedWheelDelta = *((float *)data + 4)
                                                      + pointers[*(_DWORD *)data].AccumulatedWheelDelta;
      break;
    default:
      break;
  }
  sub_199C78(v2, v3);
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (00268320) --------------------------------------------------------
float __fastcall WarGamepad_GetGamepadAxis(int padId, int axisID)
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  return _JNIEnv::CallFloatMethod(CurrentJNIEnv, s_event_globalThiz, s_getGamepadAxis, padId, axisID);
}

//----- (0026835C) --------------------------------------------------------
bool __fastcall OS_GamepadIsConnected(unsigned int padId, OSGamepadType *setType)
{
  OSGamepadType v2; // r0

  v2 = lastGamepadType[padId];
  if ( v2 == -1 )
    return 0;
  if ( setType )
    *setType = v2;
  return 1;
}

//----- (0026837C) --------------------------------------------------------
bool __fastcall OS_GamepadButton(unsigned int padId, unsigned int buttonId)
{
  return buttonId <= 0x1F && lastGamepadType[padId] != -1 && (lastGamepadMask[padId] & (1 << buttonId)) != 0;
}

//----- (002683B4) --------------------------------------------------------
float __fastcall OS_GamepadAxis(unsigned int padId, unsigned int axisId)
{
  unsigned int v2; // r1
  float v3; // s0

  v2 = axisId - 64;
  v3 = 0.0;
  if ( v2 <= 5 && lastGamepadType[padId] != -1 )
    return lastGamepadAxis[padId][v2];
  return v3;
}

//----- (002683F4) --------------------------------------------------------
bool __fastcall OS_GamepadTouchpad(unsigned int padId, unsigned int touchId, float *x, float *y)
{
  bool result; // r0
  char v8; // r4
  _JNIEnv *CurrentJNIEnv; // r11
  jint v10; // r10
  jint v11; // r0
  bool v12; // r0

  result = 0;
  if ( touchId <= 1 && lastGamepadType[padId] == 1 )
  {
    v8 = 0;
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    v10 = _JNIEnv::CallIntMethod(CurrentJNIEnv, s_event_globalThiz, s_getGamepadTrack, padId, touchId, 0);
    v11 = _JNIEnv::CallIntMethod(CurrentJNIEnv, s_event_globalThiz, s_getGamepadTrack, padId, touchId, 1);
    *x = (float)v10;
    *y = (float)v11;
    v12 = v11 != 0;
    if ( *x != 0.0 )
      v8 = 1;
    return v12 & v8;
  }
  return result;
}

//----- (002684A4) --------------------------------------------------------
void __fastcall WarGamepad_GetGamepadTrack(int padId, int trackId, int *x, int *y)
{
  _JNIEnv *CurrentJNIEnv; // r6

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  *x = _JNIEnv::CallIntMethod(CurrentJNIEnv, s_event_globalThiz, s_getGamepadTrack, padId, trackId, 0);
  *y = _JNIEnv::CallIntMethod(CurrentJNIEnv, s_event_globalThiz, s_getGamepadTrack, padId, trackId, 1);
}

//----- (00268508) --------------------------------------------------------
void __fastcall AND_GamepadUpdateAccelerometer(float x, float y, float z)
{
  accelerometerValues[0] = x;
  accelerometerValues[1] = y;
  accelerometerValues[2] = z;
}

//----- (00268518) --------------------------------------------------------
void __fastcall OS_GamepadAccelerometer(float *x, float *y, float *z)
{
  *x = accelerometerValues[0];
  *y = accelerometerValues[1];
  *z = accelerometerValues[2];
}

//----- (00268538) --------------------------------------------------------
void __fastcall WarKeyboardInit(JNIEnv_0 *env)
{
  WarKeyboard_class = (jclass_0)env->functions->FindClass(env, "com/wardrumstudios/utils/WarMedia");
  s_ShowKeyboard = env->functions->GetMethodID(env, WarKeyboard_class, "ShowKeyboard", "(I)V");
  s_IsKeyboardShown = env->functions->GetMethodID(env, WarKeyboard_class, "IsKeyboardShown", &dword_2685A4);
}
// 2685A4: using guessed type int dword_2685A4;

//----- (002685B0) --------------------------------------------------------
void AND_KeyboardInitialize()
{
  int i; // r0
  OSKeyboardKey *v1; // r2

  for ( i = 0; i != 252; i += 4 )
  {
    v1 = &NVtoKK[i];
    *(_QWORD *)v1 = 0x6400000064LL;
    *((_QWORD *)v1 + 1) = 0x6400000064LL;
  }
  *(_QWORD *)KKDown = 0LL;
  *(_QWORD *)&KKDown[8] = 0LL;
  *(_QWORD *)&KKDown[16] = 0LL;
  *(_QWORD *)&KKDown[24] = 0LL;
  *(_QWORD *)&KKDown[80] = 0LL;
  *(_QWORD *)&KKDown[88] = 0LL;
  *(_QWORD *)&KKDown[64] = 0LL;
  *(_QWORD *)&KKDown[72] = 0LL;
  *(_QWORD *)&KKDown[48] = 0LL;
  *(_QWORD *)&KKDown[56] = 0LL;
  *(_QWORD *)&NVtoKK[17] = 0xF0000000ELL;
  *(_QWORD *)&NVtoKK[19] = 0x1100000010LL;
  *(_QWORD *)&KKDown[32] = 0LL;
  *(_QWORD *)&KKDown[40] = 0LL;
  *(_QWORD *)KKtoShiftedChar = 0LL;
  *(_QWORD *)&KKtoShiftedChar[8] = 0x21297E0000000000LL;
  *(_QWORD *)KKtoChar = 0LL;
  *(_QWORD *)&KKtoChar[8] = 0x3130600000000000LL;
  *(_QWORD *)&NVtoKK[21] = 0x1300000012LL;
  *(_QWORD *)&NVtoKK[23] = 0x1500000014LL;
  *(_DWORD *)&KKDown[96] = 0;
  NVtoKK[252] = KK_MAX;
  NVtoKK[253] = KK_MAX;
  NVtoKK[254] = KK_MAX;
  NVtoKK[1] = KK_ESCAPE;
  NVtoKK[8] = KK_F1;
  NVtoKK[6] = KK_F2;
  NVtoKK[12] = KK_F3;
  NVtoKK[63] = KK_TILDE;
  NVtoKK[25] = KK_8;
  NVtoKK[26] = KK_9;
  NVtoKK[11] = KK_MINUS;
  NVtoKK[59] = KK_EQUALS;
  strcpy((char *)&KKtoChar[16], "23456789-=");
  strcpy((char *)&KKtoChar[27], "\tqwertyuiop[]\\");
  NVtoKK[4] = KK_BACKSPACE;
  NVtoKK[2] = KK_TAB;
  NVtoKK[49] = KK_W;
  NVtoKK[31] = KK_E;
  *(_QWORD *)&NVtoKK[41] = *(_QWORD *)"$";
  *(_QWORD *)&NVtoKK[43] = 0x1F0000001CLL;
  strcpy((char *)&KKtoChar[42], "asdfghjkl;'\r");
  strcpy((char *)&KKtoShiftedChar[16], "@#$%^&*(_+");
  strcpy((char *)&KKtoShiftedChar[27], "\tQWERTYUIOP{}|");
  strcpy((char *)&KKtoShiftedChar[42], "ASDFGHJKL:\"\r");
  NVtoKK[51] = KK_Y;
  NVtoKK[46] = KK_T;
  NVtoKK[47] = KK_U;
  NVtoKK[35] = KK_I;
  NVtoKK[65] = KK_LEFTBRACKET;
  NVtoKK[66] = KK_RIGHTBRACKET;
  NVtoKK[64] = KK_BACKSLASH;
  NVtoKK[27] = KK_A;
  NVtoKK[45] = KK_S;
  NVtoKK[30] = KK_D;
  NVtoKK[32] = KK_F;
  NVtoKK[33] = KK_G;
  NVtoKK[34] = KK_H;
  NVtoKK[36] = KK_J;
  NVtoKK[37] = KK_K;
  NVtoKK[38] = KK_L;
  NVtoKK[57] = KK_APOSTROPHE;
  NVtoKK[58] = KK_SEMICOLON;
  NVtoKK[3] = KK_ENTER;
  NVtoKK[55] = KK_LEFTSHIFT;
  NVtoKK[52] = KK_Z;
  NVtoKK[50] = KK_X;
  NVtoKK[29] = KK_C;
  NVtoKK[48] = KK_V;
  NVtoKK[28] = KK_B;
  NVtoKK[40] = KK_N;
  NVtoKK[39] = KK_M;
  NVtoKK[60] = KK_COMMA;
  NVtoKK[61] = KK_PERIOD;
  strcpy((char *)&KKtoChar[55], "zxcvbnm,./");
  strcpy((char *)&KKtoShiftedChar[55], "ZXCVBNM<>?");
  NVtoKK[56] = KK_RIGHTSHIFT;
  NVtoKK[62] = KK_FORWARDSLASH;
  NVtoKK[53] = KK_LEFTALT;
  NVtoKK[5] = KK_SPACE;
  NVtoKK[54] = KK_RIGHTALT;
  NVtoKK[7] = KK_HOME;
  *(_WORD *)&KKtoChar[66] = 0;
  *(_DWORD *)&KKtoChar[68] = *(_DWORD *)" ";
  *(_QWORD *)&KKtoChar[72] = 0LL;
  *(_WORD *)&KKtoShiftedChar[66] = 0;
  *(_DWORD *)&KKtoShiftedChar[68] = *(_DWORD *)" ";
  *(_QWORD *)&KKtoShiftedChar[72] = 0LL;
  *(_QWORD *)&NVtoKK[13] = 0x4F00000051LL;
  *(_QWORD *)&NVtoKK[15] = 0x5000000052LL;
  NVtoKK[9] = KK_NPMULTIPLY;
  NVtoKK[10] = KK_PLUS;
  *(_QWORD *)&KKtoChar[80] = 0x38372D2A2F000000LL;
  *(_QWORD *)&KKtoChar[88] = 0x3332313635342B39LL;
  *(_QWORD *)&KKtoShiftedChar[80] = 0x38372D2A2F000000LL;
  *(_QWORD *)&KKtoShiftedChar[88] = 0x3332313635342B39LL;
  KKtoChar[96] = 48;
  KKtoShiftedChar[96] = 48;
  KKtoChar[97] = 46;
  KKtoShiftedChar[97] = 46;
  KKtoChar[98] = 64;
  KKtoShiftedChar[98] = 64;
  NVtoKK[68] = KK_AT;
  NVtoKK[69] = KK_BACKSPACE1;
  KKtoChar[99] = 26;
  KKtoShiftedChar[99] = 26;
}

//----- (00268934) --------------------------------------------------------
unsigned int __fastcall AND_KeyboardGetChar(OSKeyboardKey key, int setUpper)
{
  char (**v2)[100]; // r1

  if ( (unsigned int)(setUpper + 1) <= 1 )
  {
    if ( key == KK_BACKSPACE )
      return 26;
    v2 = &KKtoChar_ptr;
  }
  else
  {
    v2 = &KKtoShiftedChar_ptr;
  }
  return (unsigned __int8)(**v2)[key];
}
// 6778B0: using guessed type char (*KKtoShiftedChar_ptr)[100];
// 678B9C: using guessed type char (*KKtoChar_ptr)[100];

//----- (0026895C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall AND_KeyboardEvent(bool pressed, int keyCode, int metaState, bool forceHandle)
{
  _BOOL4 v5; // r4
  int v6; // r1
  OSKeyboardKey v7; // r6
  bool v8; // zf
  char (**v9)[100]; // r0
  int v10; // r0
  OSEventType v11; // r0
  OSKeyboardKey v12; // [sp+0h] [bp-18h] BYREF
  int v13; // [sp+4h] [bp-14h]

  v5 = pressed;
  v7 = NVtoKK[v6];
  v8 = lastGamepadType[0] == 1;
  if ( lastGamepadType[0] == 1 )
    v8 = !forceHandle;
  if ( !v8 )
  {
    if ( pressed == 0x4300000000LL )
    {
      v13 = 0;
      v12 = KK_CAPSLOCK;
      LIB_InputEvent(OSET_KeyboardUp, &v12);
      LIB_InputEvent(OSET_KeyboardDown, &v12);
      LIB_InputEvent(OSET_KeyboardUp, &v12);
    }
    if ( v7 != KK_MAX )
    {
      v12 = v7;
      if ( (unsigned int)(metaState + 1) <= 1 )
      {
        if ( v7 == KK_BACKSPACE )
        {
          v10 = 26;
LABEL_13:
          v13 = v10;
          v11 = OSET_KeyboardUp;
          KKDown[v7] = v5;
          if ( v5 )
            v11 = OSET_KeyboardDown;
          LIB_InputEvent(v11, &v12);
          return;
        }
        v9 = &KKtoChar_ptr;
      }
      else
      {
        v9 = &KKtoShiftedChar_ptr;
      }
      v10 = (unsigned __int8)(**v9)[v7];
      goto LABEL_13;
    }
  }
}
// 26895C: variables would overlap: r0.1 and r0.8
// 6778B0: using guessed type char (*KKtoShiftedChar_ptr)[100];
// 678B9C: using guessed type char (*KKtoChar_ptr)[100];

//----- (00268A08) --------------------------------------------------------
void __fastcall OS_KeyboardRequest(int show)
{
  _JNIEnv *CurrentJNIEnv; // r0
  int v3; // r5
  int v4; // r5
  _JNIEnv *v5; // r0
  int v6; // [sp+0h] [bp-18h] BYREF
  int data[5]; // [sp+4h] [bp-14h] BYREF

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v3 = _JNIEnv::CallBooleanMethod(CurrentJNIEnv, s_event_globalThiz, s_IsKeyboardShown);
  if ( !v3 && KeyboardWasVisible )
  {
    data[0] = 0;
    OS_ApplicationEvent(OSET_KeyboardSoft, data);
  }
  KeyboardWasVisible = v3;
  v4 = v3 != 0;
  if ( v4 != show )
  {
    v5 = NVThreadGetCurrentJNIEnv();
    _JNIEnv::CallVoidMethod(v5, s_event_globalThiz, s_ShowKeyboard, show);
    v6 = v4;
    KeyboardWasVisible = v4;
    OS_ApplicationEvent(OSET_KeyboardSoft, &v6);
  }
}
// 268A08: using guessed type int data[5];

//----- (00268AA0) --------------------------------------------------------
bool OS_KeyboardIsSoftVisible()
{
  _JNIEnv *CurrentJNIEnv; // r0
  int v1; // r4
  int data[3]; // [sp+4h] [bp-Ch] BYREF

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v1 = _JNIEnv::CallBooleanMethod(CurrentJNIEnv, s_event_globalThiz, s_IsKeyboardShown);
  if ( !v1 && KeyboardWasVisible )
  {
    data[0] = 0;
    OS_ApplicationEvent(OSET_KeyboardSoft, data);
  }
  KeyboardWasVisible = v1;
  return v1 != 0;
}
// 268AA0: using guessed type int data[3];

//----- (00268AF4) --------------------------------------------------------
JNIEnv_0 *NVThreadGetCurrentJNIEnv()
{
  JNIEnv_0 *result; // r0
  jint v1; // r4
  void *pointer; // [sp+4h] [bp-Ch] BYREF

  pointer = 0;
  if ( s_jniEnvKey )
  {
    result = (JNIEnv_0 *)pthread_getspecific(s_jniEnvKey);
    pointer = result;
    if ( result )
      return result;
  }
  else
  {
    pthread_key_create(&s_jniEnvKey, 0);
  }
  if ( s_vm )
  {
    v1 = s_vm->functions->AttachCurrentThread((JavaVM *)s_vm, (JNIEnv **)&pointer, 0);
    _android_log_print(3, "OSWrapper", "AttachCurrentThread: %d, 0x%p", v1, pointer);
    if ( !v1 && pointer )
    {
      pthread_setspecific(s_jniEnvKey, pointer);
      return (JNIEnv_0 *)pointer;
    }
    _android_log_print(3, "OSWrapper", "Error - could not attach thread to JVM!");
  }
  else
  {
    _android_log_print(3, "OSWrapper", "Error - could not find JVM!");
  }
  return 0;
}

//----- (00268BF4) --------------------------------------------------------
jobject_0 GetThiz()
{
  return s_event_globalThiz;
}

//----- (00268C00) --------------------------------------------------------
void AND_KeyboardSoftClosed()
{
  int data; // [sp+4h] [bp-Ch] BYREF

  data = 0;
  KeyboardWasVisible = 0;
  OS_ApplicationEvent(OSET_KeyboardSoft, &data);
}

//----- (00268C20) --------------------------------------------------------
int OS_LanguageUserSelected()
{
  _JNIEnv *CurrentJNIEnv; // r0
  unsigned int v1; // r0
  int result; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v1 = _JNIEnv::CallIntMethod(CurrentJNIEnv, s_event_globalThiz, s_GetDeviceLocale);
  if ( v1 > 9 )
    result = 0;
  else
    result = dword_268C58[v1];
  userSelectedLanguage = result;
  return result;
}
// 268C58: using guessed type int dword_268C58[];

//----- (00268C84) --------------------------------------------------------
jint AND_DeviceLocale()
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  return sub_18B7B4(CurrentJNIEnv, s_event_globalThiz, s_GetDeviceLocale);
}

//----- (00268CAC) --------------------------------------------------------
OSLanguageCode OS_LanguageDeviceRegion()
{
  return deviceRegion;
}

//----- (00268CBC) --------------------------------------------------------
int OS_ScreenGetWidth()
{
  return windowSize[0];
}

//----- (00268CCC) --------------------------------------------------------
void *OS_ScreenGetHeight()
{
  return off_6855B8;
}
// 6855B8: using guessed type void *off_6855B8;

//----- (00268CE8) --------------------------------------------------------
void OS_ThreadMakeCurrent()
{
  _JNIEnv *CurrentJNIEnv; // r0

  pthread_mutex_lock((pthread_mutex_t *)AndroidEGLContext);
  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  if ( CurrentJNIEnv && s_event_globalThiz )
  {
    if ( !_JNIEnv::CallBooleanMethod(CurrentJNIEnv, s_event_globalThiz, s_makeCurrent) )
      sub_18F9C8(3, "NVEvent", "Error: MakeCurrent failed");
  }
  else
  {
    sub_18F9C8(3, "NVEvent", "Error: No valid JNI env in MakeCurrent");
  }
}

//----- (00268D50) --------------------------------------------------------
void NVEventEGLMakeCurrent()
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  if ( CurrentJNIEnv && s_event_globalThiz )
  {
    if ( !_JNIEnv::CallBooleanMethod(CurrentJNIEnv, s_event_globalThiz, s_makeCurrent) )
      sub_18F9C8(3, "NVEvent", "Error: MakeCurrent failed");
  }
  else
  {
    sub_18F9C8(3, "NVEvent", "Error: No valid JNI env in MakeCurrent");
  }
}

//----- (00268DA8) --------------------------------------------------------
void OS_ThreadUnmakeCurrent()
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  if ( CurrentJNIEnv && s_event_globalThiz )
  {
    if ( !_JNIEnv::CallBooleanMethod(CurrentJNIEnv, s_event_globalThiz, s_unMakeCurrent) )
      _android_log_print(3, "NVEvent", "Error: UnMakeCurrent failed");
  }
  else
  {
    _android_log_print(3, "NVEvent", "Error: No valid JNI env in UnMakeCurrent");
  }
  sub_18D550((pthread_mutex_t *)AndroidEGLContext);
}

//----- (00268E0C) --------------------------------------------------------
void NVEventEGLUnmakeCurrent()
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  if ( CurrentJNIEnv && s_event_globalThiz )
  {
    if ( !_JNIEnv::CallBooleanMethod(CurrentJNIEnv, s_event_globalThiz, s_unMakeCurrent) )
      sub_18F9C8(3, "NVEvent", "Error: UnMakeCurrent failed");
  }
  else
  {
    sub_18F9C8(3, "NVEvent", "Error: No valid JNI env in UnMakeCurrent");
  }
}

//----- (00268E64) --------------------------------------------------------
void OS_ScreenSwapBuffers()
{
  _JNIEnv *CurrentJNIEnv; // r0

  ++AND_bufferSwaps;
  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  if ( CurrentJNIEnv && s_event_globalThiz )
  {
    if ( !_JNIEnv::CallBooleanMethod(CurrentJNIEnv, s_event_globalThiz, s_swap) )
      _android_log_print(3, "NVEvent", "Error: SwapBuffers failed");
  }
  else
  {
    _android_log_print(3, "NVEvent", "Error: No valid JNI env in SwapBuffers");
  }
  LIB_InputUpdate(0);
}

//----- (00268ECC) --------------------------------------------------------
void NVEventEGLSwapBuffers()
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  if ( CurrentJNIEnv && s_event_globalThiz )
  {
    if ( !_JNIEnv::CallBooleanMethod(CurrentJNIEnv, s_event_globalThiz, s_swap) )
      sub_18F9C8(3, "NVEvent", "Error: SwapBuffers failed");
  }
  else
  {
    sub_18F9C8(3, "NVEvent", "Error: No valid JNI env in SwapBuffers");
  }
}

//----- (00268F24) --------------------------------------------------------
void __fastcall LIB_InputUpdate(int fromApp)
{
  _BOOL4 v1; // r9
  bool v2; // r5
  bool v3; // zf

  if ( fromApp || !inputUpdateFromApp )
  {
    v1 = clearInputNextUpdate;
    inputUpdateFromApp = fromApp != 0;
    v2 = clearInputNextUpdate;
    testIndex = 0;
    if ( clearInputNextUpdate )
      v2 = 1;
    ButtonContainer<3>::Update(pointers, v2);
    testIndex = 1;
    ButtonContainer<3>::Update(&pointers[1], v2);
    testIndex = 2;
    ButtonContainer<3>::Update(&pointers[2], v2);
    testIndex = 3;
    ButtonContainer<3>::Update(&pointers[3], v2);
    testIndex = -1;
    resetPointer = 1;
    v3 = !clearInputNextUpdate;
    if ( clearInputNextUpdate )
      v3 = !v1;
    if ( !v3 )
      clearInputNextUpdate = 0;
    ButtonContainer<100>::Update(&keys, 0);
    ButtonContainer<16>::Update(gamepads, 0);
    ButtonContainer<16>::Update(&gamepads[1], 0);
    ButtonContainer<16>::Update(&gamepads[2], 0);
    ButtonContainer<16>::Update(&gamepads[3], 0);
  }
}

//----- (00269034) --------------------------------------------------------
int initGraphics()
{
  pthread_mutex_t *v0; // r4
  _JNIEnv *CurrentJNIEnv; // r0

  if ( !AndroidEGLContext )
  {
    v0 = (pthread_mutex_t *)operator new(8u);
    pthread_mutexattr_init(v0[1].__private);
    pthread_mutexattr_settype(&v0[1], 1);
    pthread_mutex_init(v0, v0[1].__private);
    AndroidEGLContext = v0;
  }
  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  if ( CurrentJNIEnv && s_event_globalThiz )
  {
    if ( _JNIEnv::CallBooleanMethod(CurrentJNIEnv, s_event_globalThiz, s_initEGL, 2) )
      IsInitGraphics = 1;
    return 1;
  }
  else
  {
    _android_log_print(3, "NVEvent", "Error: No valid JNI env in MakeCurrent");
    return 1;
  }
}
// 19EE74: using guessed type int __fastcall pthread_mutexattr_settype(_DWORD, _DWORD);

//----- (002690C4) --------------------------------------------------------
bool NVEventEGLInit()
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  if ( CurrentJNIEnv && s_event_globalThiz )
    return _JNIEnv::CallBooleanMethod(CurrentJNIEnv, s_event_globalThiz, s_initEGL, 2) != 0;
  _android_log_print(3, "NVEvent", "Error: No valid JNI env in MakeCurrent");
  return 0;
}

//----- (0026910C) --------------------------------------------------------
int32_t_0 __fastcall NVEventAppInit(int32_t_0 argc, unsigned __int8 **argv)
{
  NvUtilInit();
  return 0;
}

//----- (0026911C) --------------------------------------------------------
void NvUtilInit()
{
  _JNIEnv *CurrentJNIEnv; // r4
  _jclass *v1; // r5
  _jmethodID *v2; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v1 = (_jclass *)CurrentJNIEnv->functions->FindClass(&CurrentJNIEnv->functions, "com/nvidia/devtech/NvUtil");
  g_hasAppLocalValue = CurrentJNIEnv->functions->GetMethodID(
                         &CurrentJNIEnv->functions,
                         v1,
                         "hasAppLocalValue",
                         "(Ljava/lang/String;)Z");
  g_getAppLocalValue = CurrentJNIEnv->functions->GetMethodID(
                         &CurrentJNIEnv->functions,
                         v1,
                         "getAppLocalValue",
                         "(Ljava/lang/String;)Ljava/lang/String;");
  g_setAppLocalValue = CurrentJNIEnv->functions->GetMethodID(
                         &CurrentJNIEnv->functions,
                         v1,
                         "setAppLocalValue",
                         "(Ljava/lang/String;Ljava/lang/String;)V");
  g_getParameter = CurrentJNIEnv->functions->GetMethodID(
                     &CurrentJNIEnv->functions,
                     v1,
                     "getParameter",
                     "(Ljava/lang/String;)Ljava/lang/String;");
  v2 = CurrentJNIEnv->functions->GetStaticMethodID(
         &CurrentJNIEnv->functions,
         v1,
         "getInstance",
         "()Lcom/nvidia/devtech/NvUtil;");
  g_globalThiz = (jobject_0)_JNIEnv::CallStaticObjectMethod(CurrentJNIEnv, v1, v2);
  NvUtilGetStringValue(g_getAppLocalValue, StorageRootBuffer, 512, "STORAGE_ROOT");
  NvUtilGetStringValue(g_getAppLocalValue, StorageBaseRootBuffer, 512, "STORAGE_ROOT_BASE");
  sub_18F9C8(3, "OSWrapper", "Storage root is %s", (const char *)StorageRootBuffer);
}

//----- (002692D4) --------------------------------------------------------
bool __fastcall ProcessEvents(bool hasInput)
{
  bool v1; // r4
  __int64 v2; // r0
  int32_t_0 v3; // r8
  int m_action_low; // r9
  int m_x2; // r12
  int m_y; // r5
  int m_y2; // r6
  int m_x; // r4
  int v9; // r1
  int v10; // r2
  unsigned int v11; // r1
  bool v12; // zf
  int v13; // r0
  int v14; // r0
  int v15; // r3
  int v16; // r5
  bool v17; // zf
  int v18; // r0
  int v19; // r9
  int v21; // [sp+4h] [bp-5Ch]
  int v22; // [sp+8h] [bp-58h]
  NVEvent_0 ev; // [sp+2Ch] [bp-34h] BYREF

  if ( NVEventGetNextEvent(&ev, -(IsAndroidInMultiplayer == 0 && IsAndroidPaused != 0)) )
  {
    while ( 2 )
    {
      v1 = 1;
      switch ( ev.m_type )
      {
        case NV_EVENT_KEY:
          v2 = *(_QWORD *)&ev.m_data.m_touch.m_action;
          if ( ev.m_data.m_char.m_unichar != 1 )
            LOBYTE(v2) = 0;
          AND_KeyboardEvent(v2, ev.m_data.m_size.m_h, ev.m_data.m_key.metaState, 0);
          goto LABEL_57;
        case NV_EVENT_MULTITOUCH:
          v3 = ev.m_data.m_char.m_unichar >> 8;
          m_action_low = LOBYTE(ev.m_data.m_touch.m_action);
          m_x2 = (int)ev.m_data.m_multi.m_x2;
          m_y = (int)ev.m_data.m_touch.m_y;
          m_y2 = (int)ev.m_data.m_multi.m_y2;
          m_x = (int)ev.m_data.m_touch.m_x;
          if ( !((int)ev.m_data.m_multi.m_y2 | (int)ev.m_data.m_multi.m_x2)
            && ProcessEvents(bool)::lastY[1] | ProcessEvents(bool)::lastX[1] )
          {
            v9 = ProcessEvents(bool)::lastY[1] - m_y;
            v10 = ProcessEvents(bool)::lastX[1] - m_x;
            if ( ProcessEvents(bool)::lastX[1] - m_x < 0 )
              v10 = m_x - ProcessEvents(bool)::lastX[1];
            if ( v9 < 0 )
              v9 = m_y - ProcessEvents(bool)::lastY[1];
            v11 = v9 + v10;
            if ( v11 < windowSize[0] / 0xAu )
            {
              v3 = LOBYTE(ev.m_data.m_touch.m_action);
              m_x2 = (int)ev.m_data.m_touch.m_x;
              m_y2 = (int)ev.m_data.m_touch.m_y;
              m_action_low = 1;
              m_x = 0;
            }
            if ( v11 < windowSize[0] / 0xAu )
              m_y = 0;
          }
          v12 = ProcessEvents(bool)::lastAction[0] == m_action_low;
          if ( ProcessEvents(bool)::lastAction[0] == m_action_low )
            v12 = m_action_low == 1;
          if ( !v12 )
          {
            switch ( m_action_low )
            {
              case 1:
                v22 = m_x2;
                if ( !m_x )
                {
                  if ( m_y )
                  {
                    m_x = 0;
                  }
                  else
                  {
                    m_y = ProcessEvents(bool)::lastY[0];
                    m_x = ProcessEvents(bool)::lastX[0];
                  }
                }
                m_action_low = 1;
                v14 = 1;
                goto LABEL_39;
              case 2:
                m_action_low = 2;
                v13 = 2;
                goto LABEL_35;
              case 3:
                v22 = m_x2;
                if ( (ProcessEvents(bool)::lastAction[0] & 0xFFFFFFFE) == 2 )
                {
                  m_action_low = 3;
                  v14 = 3;
                }
                else
                {
                  m_action_low = 2;
                  v14 = 2;
                }
LABEL_39:
                AND_TouchEvent(v14, 0, m_x, m_y);
                m_x2 = v22;
                break;
              case 4:
                m_action_low = 4;
                v13 = 4;
LABEL_35:
                v15 = m_y;
                v21 = m_y;
                v16 = m_x2;
                AND_TouchEvent(v13, 0, m_x, v15);
                m_x2 = v16;
                m_y = v21;
                break;
              default:
                break;
            }
            ProcessEvents(bool)::lastAction[0] = m_action_low;
          }
          v17 = ProcessEvents(bool)::lastAction[1] == v3;
          if ( ProcessEvents(bool)::lastAction[1] == v3 )
            v17 = v3 == 1;
          if ( !v17 )
          {
            switch ( v3 )
            {
              case 1:
                if ( !m_x2 )
                {
                  if ( m_y2 )
                  {
                    m_x2 = 0;
                  }
                  else
                  {
                    m_y2 = ProcessEvents(bool)::lastY[1];
                    m_x2 = ProcessEvents(bool)::lastX[1];
                  }
                }
                v3 = 1;
                v18 = 1;
                goto LABEL_54;
              case 2:
                goto LABEL_50;
              case 3:
                if ( (ProcessEvents(bool)::lastAction[1] & 0xFFFFFFFE) == 2 )
                {
                  v3 = 3;
                  v18 = 3;
                }
                else
                {
LABEL_50:
                  v3 = 2;
                  v18 = 2;
                }
                goto LABEL_54;
              case 4:
                v3 = 4;
                v18 = 4;
LABEL_54:
                v19 = m_x2;
                AND_TouchEvent(v18, 1, m_x2, m_y2);
                m_x2 = v19;
                break;
              default:
                break;
            }
            ProcessEvents(bool)::lastAction[1] = v3;
          }
          ProcessEvents(bool)::lastX[0] = m_x;
          ProcessEvents(bool)::lastX[1] = m_x2;
          ProcessEvents(bool)::lastY[0] = m_y;
          ProcessEvents(bool)::lastY[1] = m_y2;
          goto LABEL_57;
        case NV_EVENT_ACCEL:
          *(_QWORD *)accelerometerValues = *(_QWORD *)&ev.m_data.m_touch.m_action;
          accelerometerValues[2] = ev.m_data.m_touch.m_y;
          goto LABEL_57;
        case NV_EVENT_WINDOW_SIZE:
          *(_QWORD *)windowSize = *(_QWORD *)&ev.m_data.m_touch.m_action;
          goto LABEL_57;
        case NV_EVENT_QUIT:
          return v1;
        case NV_EVENT_PAUSE:
          if ( !IsAndroidPaused )
            OS_ApplicationEvent(OSET_Pause, 0);
          WasAndroidPaused = 1;
          IsAndroidPaused = 1;
          goto LABEL_57;
        case NV_EVENT_RESUME:
          if ( IsAndroidPaused )
          {
            initGraphics();
            OS_ApplicationEvent(OSET_Resume, 0);
            IsAndroidPaused = 0;
          }
          goto LABEL_57;
        case NV_EVENT_LOMEM:
          OS_ApplicationEvent(OSET_LowMemory, 0);
          goto LABEL_57;
        default:
LABEL_57:
          v1 = 0;
          if ( !NVEventGetNextEvent(&ev, -(IsAndroidInMultiplayer == 0 && IsAndroidPaused != 0)) )
            return v1;
          continue;
      }
    }
  }
  return 0;
}

//----- (00269634) --------------------------------------------------------
int32_t_0 __fastcall NVEventGetNextEvent(NVEvent_0 *ev, int waitMSecs)
{
  int32_t_0 m_headIndex; // r0
  int32_t_0 v5; // r4
  NVEvent_0 *v6; // r0
  __int64 v7; // d17
  NVEventWindowSize_0 v8; // d18
  NVEventType_0 m_type; // r1
  struct timespec v11; // [sp+0h] [bp-18h] BYREF

  pthread_mutex_lock(&s_eventQueue.m_mutex);
  if ( s_eventQueue.m_processingPause )
  {
    s_eventQueue.m_processingPause = 0;
    pthread_cond_signal(&s_eventQueue.m_javaSync.m_cond);
  }
  m_headIndex = s_eventQueue.m_headIndex;
  if ( s_eventQueue.m_nextInsertIndex != s_eventQueue.m_headIndex )
    goto LABEL_11;
  if ( !waitMSecs )
    goto LABEL_10;
  if ( s_eventQueue.m_nativeSync.m_block )
  {
    if ( waitMSecs <= -1 )
    {
      pthread_cond_wait(&s_eventQueue.m_nativeSync.m_cond, &s_eventQueue.m_mutex);
    }
    else
    {
      v11.tv_sec = 5;
      v11.tv_nsec = 1000 * waitMSecs;
      pthread_cond_timedwait(&s_eventQueue.m_nativeSync.m_cond, &s_eventQueue.m_mutex, &v11);
    }
  }
  m_headIndex = s_eventQueue.m_headIndex;
  if ( s_eventQueue.m_nextInsertIndex == s_eventQueue.m_headIndex )
  {
LABEL_10:
    v5 = 0;
  }
  else
  {
LABEL_11:
    v6 = &s_eventQueue.m_events[m_headIndex];
    v7 = *(_QWORD *)(&v6->m_data.m_char + 1);
    v8 = *(NVEventWindowSize_0 *)((char *)&v6->m_data.m_size + 12);
    *(_QWORD *)&ev->m_type = *(_QWORD *)&v6->m_type;
    *(_QWORD *)(&ev->m_data.m_char + 1) = v7;
    m_type = ev->m_type;
    *(NVEventWindowSize_0 *)((char *)&ev->m_data.m_size + 12) = v8;
    if ( m_type == NV_EVENT_PAUSE )
      s_eventQueue.m_processingPause = 1;
    v5 = 1;
    s_eventQueue.m_headIndex = (unsigned __int8)(LOBYTE(s_eventQueue.m_headIndex) + 1);
  }
  pthread_mutex_unlock(&s_eventQueue.m_mutex);
  return v5;
}
// 269634: using guessed type struct timespec var_18;

//----- (00269740) --------------------------------------------------------
void __fastcall AND_TouchEvent(int actionType, int trackNum, int x, int y)
{
  bool v4; // zf
  int v8; // r5
  AND_TouchPoint *v9; // r0
  double v10; // d17
  double v11; // d16
  int v12; // r2
  AND_TouchPoint *v13; // r0
  float v14; // s0
  AND_TouchPoint *v15; // r8
  __kernel_suseconds_t v16; // r0
  int v17; // r1
  bool v18; // zf
  double v19; // d17
  double v20; // d16
  ButtonContainer<3> *v21; // r0
  __int64 v22; // kr00_8
  double v23; // d17
  double v24; // d16
  struct timeval v25; // [sp+0h] [bp-50h] BYREF
  int v26; // [sp+8h] [bp-48h]
  int v27; // [sp+Ch] [bp-44h]
  double v28; // [sp+10h] [bp-40h]
  double v29; // [sp+18h] [bp-38h]
  int v30; // [sp+20h] [bp-30h]
  struct timeval tv; // [sp+2Ch] [bp-24h] BYREF

  v4 = actionType == 1;
  v8 = 0;
  if ( actionType != 1 )
    v4 = actionType == 4;
  if ( v4 )
  {
    Points[trackNum].state = OSPS_ButtonReleased;
    gettimeofday(&v25, 0);
    if ( v25.tv_usec > (int)"ist_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly"
      || v25.tv_usec <= -1 )
    {
      v10 = OS_TimeAccurate(void)::last_current_time
          - (double)(unsigned int)OS_TimeAccurate(void)::last_current_time
          + 0.00033;
    }
    else
    {
      v10 = (double)v25.tv_usec / 1000000.0;
    }
    v11 = v10 + (double)v25.tv_sec;
    OS_TimeAccurate(void)::last_current_time = v11;
    if ( v11 - OS_TimeAccurate(void)::lastPrint > 5.0 )
      OS_TimeAccurate(void)::lastPrint = v10 + (double)v25.tv_sec;
    v12 = 0;
    v13 = &Points[trackNum];
    v14 = v11 - base_time;
    v13->clickTime[v13->clickIndex] = v14;
    if ( !v13->clickIndex )
      v12 = 1;
    v13->clickIndex = v12;
  }
  else
  {
    if ( actionType != 2 )
      goto LABEL_16;
    Points[trackNum].x = -1;
    v9 = &Points[trackNum];
    v9->y = -1;
    v9->state = OSPS_ButtonPressed;
  }
  v8 = 1;
LABEL_16:
  v15 = &Points[trackNum];
  v16 = v15->x;
  v17 = v15->y;
  v18 = v15->x == x;
  if ( v15->x == x )
    v18 = v17 == y;
  if ( !v18 )
  {
    v25.tv_sec = trackNum;
    v25.tv_usec = v16;
    v26 = v17;
    v27 = x;
    LODWORD(v28) = y;
    gettimeofday(&tv, 0);
    if ( tv.tv_usec > (int)"ist_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly"
      || tv.tv_usec <= -1 )
    {
      v19 = OS_TimeAccurate(void)::last_current_time
          - (double)(unsigned int)OS_TimeAccurate(void)::last_current_time
          + 0.00033;
    }
    else
    {
      v19 = (double)tv.tv_usec / 1000000.0;
    }
    v20 = v19 + (double)tv.tv_sec;
    OS_TimeAccurate(void)::last_current_time = v20;
    if ( v20 - OS_TimeAccurate(void)::lastPrint > 5.0 )
      OS_TimeAccurate(void)::lastPrint = v19 + (double)tv.tv_sec;
    v15->x = x;
    v30 = 0;
    v15->y = y;
    v21 = &pointers[trackNum];
    v29 = v20 - base_time;
    v21->systemX = x;
    v21->systemY = y;
    v21->systemForce = 0.0;
    OS_ApplicationEvent(OSET_PointerMove, &v25);
  }
  if ( v8 == 1 )
  {
    v25.tv_sec = trackNum;
    v22 = *(_QWORD *)&Points[trackNum].y;
    v25.tv_usec = 0;
    HIDWORD(v29) = HIDWORD(v22);
    v26 = v15->x;
    v27 = v22;
    gettimeofday(&tv, 0);
    if ( tv.tv_usec > (int)"ist_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly"
      || tv.tv_usec <= -1 )
    {
      v23 = OS_TimeAccurate(void)::last_current_time
          - (double)(unsigned int)OS_TimeAccurate(void)::last_current_time
          + 0.00033;
    }
    else
    {
      v23 = (double)tv.tv_usec / 1000000.0;
    }
    v24 = v23 + (double)tv.tv_sec;
    OS_TimeAccurate(void)::last_current_time = v24;
    if ( v24 - OS_TimeAccurate(void)::lastPrint > 5.0 )
      OS_TimeAccurate(void)::lastPrint = v23 + (double)tv.tv_sec;
    LODWORD(v29) = 0;
    v28 = v24 - base_time;
    LIB_InputEvent(OSET_PointerButton, &v25);
  }
}

//----- (00269A54) --------------------------------------------------------
int AndroidPaused()
{
  return IsAndroidPaused;
}

//----- (00269A64) --------------------------------------------------------
void __fastcall SetAndroidPaused(int value)
{
  IsAndroidPaused = value;
}

//----- (00269A74) --------------------------------------------------------
void AndroidPause()
{
  IsAndroidPaused = 1;
}

//----- (00269A88) --------------------------------------------------------
int32_t_0 __fastcall NVEventAppMain(int32_t_0 argc, unsigned __int8 **argv)
{
  _DWORD *v4; // r1
  pthread_key_t v5; // r0
  pthread_mutex_t *v6; // r6
  int v7; // r8
  bool v8; // zf
  _JNIEnv *CurrentJNIEnv; // r0
  unsigned __int8 **v10; // r6
  _JNIEnv *v11; // r0
  jint v12; // r0
  pthread_mutex_t *v13; // r4
  pthread_mutex_t *v14; // r4
  _JNIEnv *v15; // r0
  int v16; // r0
  _JNIEnv *v17; // r0
  _JNIEnv *v18; // r0
  double v19; // d11
  _BOOL4 v20; // r5
  double v21; // d17
  double v22; // d16
  double v23; // d12
  double v24; // d11
  float v25; // s0
  _BOOL4 v26; // r6
  pthread_mutexattr_t *v27; // r4
  pthread_mutexattr_t *v28; // r4
  pthread_mutexattr_t *v29; // r4
  int data; // [sp+4h] [bp-54h] BYREF
  struct timeval tv; // [sp+8h] [bp-50h] BYREF

  OS_ApplicationPreinit();
  AND_KeyboardInitialize();
  *(_QWORD *)&lastGamepadAxis[3][2] = 0LL;
  *(_QWORD *)&lastGamepadAxis[3][4] = 0LL;
  *(_QWORD *)&lastGamepadAxis[2][4] = 0LL;
  *(_QWORD *)&lastGamepadAxis[3][0] = 0LL;
  *(_QWORD *)&lastGamepadAxis[2][0] = 0LL;
  *(_QWORD *)&lastGamepadAxis[2][2] = 0LL;
  *(_QWORD *)&lastGamepadAxis[1][2] = 0LL;
  *(_QWORD *)&lastGamepadAxis[1][4] = 0LL;
  *(_QWORD *)&lastGamepadAxis[0][0] = 0LL;
  *(_QWORD *)&lastGamepadAxis[0][2] = 0LL;
  *(_QWORD *)&lastGamepadAxis[0][4] = 0LL;
  *(_QWORD *)&lastGamepadAxis[1][0] = 0LL;
  gettimeofday(&tv, 0);
  base_time = (double)tv.tv_usec / 1000000.0 + (double)tv.tv_sec;
  if ( !ANDThread_Initted )
  {
    pthread_key_create(&ANDThreadStorageKey, ANDThreadData::Destroy);
    v4 = malloc(0xCu);
    *v4 = 0;
    v4[1] = 0;
    v5 = ANDThreadStorageKey;
    v4[2] = 0;
    pthread_setspecific(v5, v4);
    ANDThread_Initted = 1;
  }
  v6 = (pthread_mutex_t *)operator new(8u);
  pthread_mutexattr_init(v6[1].__private);
  pthread_mutexattr_settype(&v6[1], 1);
  pthread_mutex_init(v6, v6[1].__private);
  fileMutex = v6;
  if ( DoInitGraphics )
    initGraphics();
  v7 = 0;
  while ( IsInitGraphics )
  {
    if ( !IsAndroidPaused )
      goto LABEL_14;
LABEL_6:
    ++NVEventAppMain(int,char **)::iter;
    v7 = ProcessEvents(0);
  }
  v8 = IsAndroidPaused == 0;
  if ( !IsAndroidPaused )
    v8 = (v7 ^ 1) << 31 == 0;
  if ( !v8 )
    goto LABEL_6;
LABEL_14:
  pthread_mutex_lock((pthread_mutex_t *)AndroidEGLContext);
  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  if ( CurrentJNIEnv && s_event_globalThiz )
  {
    v10 = argv;
    if ( !_JNIEnv::CallBooleanMethod(CurrentJNIEnv, s_event_globalThiz, s_makeCurrent) )
      _android_log_print(3, "NVEvent", "Error: MakeCurrent failed");
  }
  else
  {
    _android_log_print(3, "NVEvent", "Error: No valid JNI env in MakeCurrent");
    v10 = argv;
  }
  AND_SystemInitialize();
  v11 = NVThreadGetCurrentJNIEnv();
  v12 = _JNIEnv::CallIntMethod(v11, s_event_globalThiz, s_GetDeviceType);
  isLowMemoryDevice = v12 >> 6 < 250 || (v12 & 2) == 0;
  v13 = (pthread_mutex_t *)operator new(8u);
  pthread_mutexattr_init(v13[1].__private);
  pthread_mutexattr_settype(&v13[1], 1);
  pthread_mutex_init(v13, v13[1].__private);
  billingMutex = v13;
  v14 = (pthread_mutex_t *)operator new(8u);
  pthread_mutexattr_init(v14[1].__private);
  pthread_mutexattr_settype(&v14[1], 1);
  pthread_mutex_init(v14, v14[1].__private);
  s_conflictHandler = 0;
  gameServiceMutex = v14;
  if ( OS_ApplicationInitialize(argc, (const unsigned __int8 **)v10) )
  {
    data = 0;
    AND_AppInitialized = 1;
    v15 = NVThreadGetCurrentJNIEnv();
    if ( _JNIEnv::CallBooleanMethod(v15, s_event_globalThiz, s_IsWifiAvailable) )
    {
      v16 = 2;
      goto LABEL_24;
    }
    v17 = NVThreadGetCurrentJNIEnv();
    if ( _JNIEnv::CallBooleanMethod(v17, s_event_globalThiz, s_IsNetworkAvailable) )
    {
      v16 = 1;
LABEL_24:
      data = v16;
    }
    OS_ApplicationEvent(OSET_NetworkChanged, &data);
    v18 = NVThreadGetCurrentJNIEnv();
    if ( v18 && s_event_globalThiz )
    {
      if ( !_JNIEnv::CallBooleanMethod(v18, s_event_globalThiz, s_unMakeCurrent) )
        _android_log_print(3, "NVEvent", "Error: UnMakeCurrent failed");
    }
    else
    {
      _android_log_print(3, "NVEvent", "Error: No valid JNI env in UnMakeCurrent");
    }
    pthread_mutex_unlock((pthread_mutex_t *)AndroidEGLContext);
    if ( OS_ApplicationStartup(windowSize[0], windowSize[1], argc, (const unsigned __int8 **)v10) )
    {
      AND_AppStarted = 1;
      gettimeofday(&tv, 0);
      if ( !(v7 << 31) )
      {
        v19 = (double)tv.tv_usec / 1000000.0 + (double)tv.tv_sec;
        do
        {
          v20 = ProcessEvents(0);
          while ( !v20 && IsAndroidPaused && !IsAndroidInMultiplayer )
          {
            v20 = ProcessEvents(0);
            usleep(0x61A8u);
          }
          gettimeofday(&tv, 0);
          if ( tv.tv_usec > (int)"ist_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly"
            || tv.tv_usec <= -1 )
          {
            v21 = OS_TimeAccurate(void)::last_current_time
                - (double)(unsigned int)OS_TimeAccurate(void)::last_current_time
                + 0.00033;
          }
          else
          {
            v21 = (double)tv.tv_usec / 1000000.0;
          }
          v22 = v21 + (double)tv.tv_sec;
          OS_TimeAccurate(void)::last_current_time = v22;
          if ( v22 - OS_TimeAccurate(void)::lastPrint > 5.0 )
            OS_TimeAccurate(void)::lastPrint = v21 + (double)tv.tv_sec;
          v23 = v22 - base_time;
          v24 = v22 - base_time - v19;
          v25 = v24;
          v26 = OS_ApplicationTick(v25);
          AND_GamepadUpdate();
          AND_FileUpdate(v24);
          AND_BillingUpdate(0);
          v19 = v23;
        }
        while ( v26 && !v20 );
      }
      OS_ApplicationEvent(OSET_RequestExit, 0);
      pthread_key_delete(ANDThreadStorageKey);
      if ( items )
      {
        free(items);
        numItems = 0;
        items = 0;
      }
      v27 = (pthread_mutexattr_t *)billingMutex;
      if ( billingMutex )
      {
        pthread_mutex_destroy((pthread_mutex_t *)billingMutex);
        pthread_mutexattr_destroy(v27 + 1);
        operator delete(v27);
      }
      billingMutex = 0;
      AND_ClearAchievementData(1);
      v28 = (pthread_mutexattr_t *)billingMutex;
      if ( billingMutex )
      {
        pthread_mutex_destroy((pthread_mutex_t *)billingMutex);
        pthread_mutexattr_destroy(v28 + 1);
        operator delete(v28);
      }
      v29 = (pthread_mutexattr_t *)fileMutex;
      if ( fileMutex )
      {
        pthread_mutex_destroy((pthread_mutex_t *)fileMutex);
        pthread_mutexattr_destroy(v29 + 1);
        operator delete(v29);
      }
      fileMutex = 0;
    }
    else
    {
      OS_ApplicationEvent(OSET_RequestExit, 0);
    }
  }
  return 0;
}
// 19EE74: using guessed type int __fastcall pthread_mutexattr_settype(_DWORD, _DWORD);

//----- (0026A080) --------------------------------------------------------
void AND_TimeInitialize()
{
  struct timeval v0; // [sp+0h] [bp-10h] BYREF

  gettimeofday(&v0, 0);
  base_time = (double)v0.tv_usec / 1000000.0 + (double)v0.tv_sec;
}

//----- (0026A0C4) --------------------------------------------------------
void AND_ThreadInitialize()
{
  _DWORD *v0; // r0

  if ( !ANDThread_Initted )
  {
    pthread_key_create(&ANDThreadStorageKey, ANDThreadData::Destroy);
    v0 = malloc(0xCu);
    *v0 = 0;
    v0[1] = 0;
    v0[2] = 0;
    pthread_setspecific(ANDThreadStorageKey, v0);
    ANDThread_Initted = 1;
  }
}

//----- (0026A120) --------------------------------------------------------
void AND_SystemInitialize()
{
  OSDeviceChip v0; // r0
  _JNIEnv *CurrentJNIEnv; // r0
  _JNIEnv *v2; // r5
  int v3; // r6
  const char *v4; // r4
  _JNIEnv *v5; // r5
  int v6; // r4
  const char *v7; // r6
  _JNIEnv *v8; // r5
  int v9; // r4
  const char *v10; // r6
  int v11; // r1
  OSDefinedDevice **v12; // r0
  int v13; // r0
  bool v14; // zf
  char v15; // [sp+7h] [bp-349h] BYREF
  NvSysCaps syscaps; // [sp+8h] [bp-348h] BYREF

  nvGetSystemCapabilities(&syscaps, 1);
  if ( syscaps.cpu_is_tegra )
  {
    if ( syscaps.cpu_is_t3plus )
    {
      v0 = OSDC_Tegra3;
      if ( syscaps.cpu_is_tng )
        v0 = OSDC_Tegra4;
    }
    else
    {
      v0 = OSDC_Tegra2;
    }
  }
  else
  {
    v0 = OSDC_UnknownAndroid;
  }
  deviceChip = v0;
  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  LOBYTE(deviceForm) = _JNIEnv::CallIntMethod(CurrentJNIEnv, s_event_globalThiz, s_GetDeviceType) & 1;
  deviceForm = (unsigned __int8)deviceForm;
  v2 = NVThreadGetCurrentJNIEnv();
  v3 = _JNIEnv::CallObjectMethod(v2, s_event_globalThiz, s_GetAndroidBuildinfo, 0);
  v4 = (const char *)v2->functions->GetStringUTFChars(&v2->functions, (jstring)v3, (jboolean *)&v15);
  strcpy((char *)staticBuildinfo, v4);
  v2->functions->ReleaseStringUTFChars(&v2->functions, (jstring)v3, (const unsigned __int8 *)v4);
  v2->functions->DeleteLocalRef(&v2->functions, (jobject)v3);
  v5 = NVThreadGetCurrentJNIEnv();
  v6 = _JNIEnv::CallObjectMethod(v5, s_event_globalThiz, s_GetAndroidBuildinfo, 1);
  v7 = (const char *)v5->functions->GetStringUTFChars(&v5->functions, (jstring)v6, (jboolean *)&v15);
  strcpy((char *)staticBuildinfo[1], v7);
  v5->functions->ReleaseStringUTFChars(&v5->functions, (jstring)v6, (const unsigned __int8 *)v7);
  v5->functions->DeleteLocalRef(&v5->functions, (jobject)v6);
  v8 = NVThreadGetCurrentJNIEnv();
  v9 = _JNIEnv::CallObjectMethod(v8, s_event_globalThiz, s_GetAndroidBuildinfo, 2);
  v10 = (const char *)v8->functions->GetStringUTFChars(&v8->functions, (jstring)v9, (jboolean *)&v15);
  strcpy((char *)staticBuildinfo[2], v10);
  v8->functions->ReleaseStringUTFChars(&v8->functions, (jstring)v9, (const unsigned __int8 *)v10);
  v8->functions->DeleteLocalRef(&v8->functions, (jobject)v9);
  if ( !strcasecmp((const char *)staticBuildinfo, "Amazon") && strlen((const char *)staticBuildinfo[2]) >= 3 )
  {
    if ( strcasecmp((const char *)staticBuildinfo[2], "Kindle Fire") )
    {
      if ( staticBuildinfo[2][0] == 65 )
      {
        v14 = staticBuildinfo[2][1] == 70;
        if ( staticBuildinfo[2][1] == 70 )
          v14 = staticBuildinfo[2][2] == 84;
        if ( v14 )
        {
          v11 = 24;
          v12 = &definedDevice_ptr;
          goto LABEL_27;
        }
      }
      else if ( staticBuildinfo[2][0] == 75 )
      {
        if ( staticBuildinfo[2][1] == 70 )
          goto LABEL_14;
      }
      else if ( staticBuildinfo[2][0] == 83 && staticBuildinfo[2][1] == 68 )
      {
        deviceChip = OSDC_AmazonFire;
        definedDevice = OSDD_FirePhone;
        return;
      }
      v11 = 27;
      v12 = &definedDevice_ptr;
      goto LABEL_27;
    }
LABEL_14:
    v11 = 23;
    v12 = &definedDevice_ptr;
LABEL_27:
    **v12 = v11;
    return;
  }
  v13 = strcasecmp((const char *)staticBuildinfo, "NVIDIA");
  definedDevice = OSDD_UndefinedAndroid;
  if ( !v13 && strstr((const char *)staticBuildinfo[1], "foster") )
  {
    v11 = 16;
    v12 = (OSDefinedDevice **)&deviceChip_ptr;
    goto LABEL_27;
  }
}
// FC: using guessed type int elf_hash_bucket[16411];
// 67602C: using guessed type OSDeviceChip deviceChip_ptr;
// 6787C8: using guessed type OSDefinedDevice *definedDevice_ptr;

//----- (0026A3F0) --------------------------------------------------------
jint AND_DeviceType()
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  return sub_18B7B4(CurrentJNIEnv, s_event_globalThiz, s_GetDeviceType);
}

//----- (0026A418) --------------------------------------------------------
void AND_BillingInit()
{
  pthread_mutex_t *v0; // r4

  v0 = (pthread_mutex_t *)operator new(8u);
  pthread_mutexattr_init(v0[1].__private);
  pthread_mutexattr_settype(&v0[1], 1);
  pthread_mutex_init(v0, v0[1].__private);
  billingMutex = v0;
}
// 19EE74: using guessed type int __fastcall pthread_mutexattr_settype(_DWORD, _DWORD);

//----- (0026A44C) --------------------------------------------------------
void AND_GameServiceInit()
{
  pthread_mutex_t *v0; // r4

  v0 = (pthread_mutex_t *)operator new(8u);
  pthread_mutexattr_init(v0[1].__private);
  pthread_mutexattr_settype(&v0[1], 1);
  pthread_mutex_init(v0, v0[1].__private);
  gameServiceMutex = v0;
  s_conflictHandler = 0;
}
// 19EE74: using guessed type int __fastcall pthread_mutexattr_settype(_DWORD, _DWORD);

//----- (0026A48C) --------------------------------------------------------
bool OS_ServiceIsWifiAvailable()
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  return _JNIEnv::CallBooleanMethod(CurrentJNIEnv, s_event_globalThiz, s_IsWifiAvailable) != 0;
}

//----- (0026A4B8) --------------------------------------------------------
bool OS_ServiceIsNetworkAvailable()
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  return _JNIEnv::CallBooleanMethod(CurrentJNIEnv, s_event_globalThiz, s_IsNetworkAvailable) != 0;
}

//----- (0026A4E8) --------------------------------------------------------
double OS_TimeAccurate()
{
  double v0; // d17
  double v1; // d16
  struct timeval v3; // [sp+0h] [bp-10h] BYREF

  gettimeofday(&v3, 0);
  if ( v3.tv_usec > (int)"ist_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly" || v3.tv_usec <= -1 )
    v0 = OS_TimeAccurate(void)::last_current_time
       - (double)(unsigned int)OS_TimeAccurate(void)::last_current_time
       + 0.00033;
  else
    v0 = (double)v3.tv_usec / 1000000.0;
  v1 = v0 + (double)v3.tv_sec;
  OS_TimeAccurate(void)::last_current_time = v1;
  if ( v1 - OS_TimeAccurate(void)::lastPrint > 5.0 )
    OS_TimeAccurate(void)::lastPrint = v0 + (double)v3.tv_sec;
  return v1 - base_time;
}

//----- (0026A5AC) --------------------------------------------------------
void __fastcall AND_BillingUpdate(bool calledFromApp)
{
  bool v1; // zf
  int v2; // r0
  int v3; // r4
  int v4; // r5
  ANDBillingItem *v5; // r1
  ANDBillingItem *v6; // r2
  unsigned int eventType; // r0
  int data[9]; // [sp+4h] [bp-2Ch] BYREF

  v1 = !appControlledUpdates;
  if ( appControlledUpdates )
    v1 = calledFromApp;
  if ( v1 )
  {
    appControlledUpdates = calledFromApp;
    if ( appUsesBilling == 1 )
    {
      pthread_mutex_lock((pthread_mutex_t *)billingMutex);
      v2 = numItems;
      if ( numItems >= 1 )
      {
        v3 = 0;
        v4 = 0;
        do
        {
          v5 = items;
          v6 = &items[v3];
          if ( items[v3].hasEvent )
          {
            v6->hasEvent = 0;
            eventType = v6->eventType;
            if ( eventType <= 4 )
              v6->purchased = ((1 << eventType) & 0x13) != 0;
            data[1] = eventType;
            data[0] = (int)v5[v3].id;
            OS_ApplicationEvent(OSET_BillingChange, data);
            v2 = numItems;
          }
          ++v4;
          ++v3;
        }
        while ( v4 < v2 );
      }
      pthread_mutex_unlock((pthread_mutex_t *)billingMutex);
    }
  }
}
// 6D7111: using guessed type char appUsesBilling;

//----- (0026A680) --------------------------------------------------------
void AND_ThreadCleanup()
{
  sub_1918EC(ANDThreadStorageKey);
}

//----- (0026A690) --------------------------------------------------------
void AND_BillingShutdown()
{
  pthread_mutexattr_t *v0; // r4

  if ( items )
  {
    free(items);
    numItems = 0;
    items = 0;
  }
  v0 = (pthread_mutexattr_t *)billingMutex;
  if ( billingMutex )
  {
    pthread_mutex_destroy((pthread_mutex_t *)billingMutex);
    pthread_mutexattr_destroy(v0 + 1);
    operator delete(v0);
  }
  billingMutex = 0;
}

//----- (0026A6F0) --------------------------------------------------------
void AND_GameServiceShutdown()
{
  pthread_mutexattr_t *v0; // r4

  AND_ClearAchievementData(1);
  v0 = (pthread_mutexattr_t *)billingMutex;
  if ( billingMutex )
  {
    pthread_mutex_destroy((pthread_mutex_t *)billingMutex);
    pthread_mutexattr_destroy(v0 + 1);
    sub_191374(v0);
  }
}

//----- (0026A724) --------------------------------------------------------
void __fastcall OS_ScreenSetWakeLock(bool enabled)
{
  _JNIEnv *CurrentJNIEnv; // r0

  if ( enabled != curWakeLock )
  {
    curWakeLock = enabled;
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    sub_193E64(CurrentJNIEnv, s_event_globalThiz, s_ScreenSetWakeLock);
  }
}

//----- (0026A778) --------------------------------------------------------
void __fastcall AND_ScreenSetWakeLock(bool enabled)
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  sub_193E64(CurrentJNIEnv, s_event_globalThiz, s_ScreenSetWakeLock);
}

//----- (0026A7AC) --------------------------------------------------------
bool __fastcall OS_SystemCheckPause(int sleepTime)
{
  bool result; // r0

  result = 0;
  if ( IsAndroidPaused && !IsAndroidInMultiplayer )
  {
    if ( sleepTime <= -1 )
    {
      do
      {
        usleep((__useconds_t)&elf_hash_chain[8526]);
        result = 0;
      }
      while ( IsAndroidPaused && !IsAndroidInMultiplayer );
    }
    else
    {
      usleep(sleepTime);
      result = IsAndroidPaused;
      if ( IsAndroidPaused )
        return 1;
    }
  }
  return result;
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (0026A830) --------------------------------------------------------
void __fastcall OS_SetIsMultiplayer(int value)
{
  IsAndroidInMultiplayer = value;
}

//----- (0026A840) --------------------------------------------------------
void __fastcall OS_MoviePlay(const unsigned __int8 *MovieName, bool skippable, bool loop, float volume)
{
  _BOOL4 v4; // r9
  _BOOL4 v6; // r4
  int v8; // r0
  float v9; // s16
  ZIPFile *v10; // r5
  int v11; // r0
  ZIPFile::ZipEntry *dataPtr; // r1
  unsigned int offset; // r4
  unsigned int length; // r11
  _JNIEnv *v15; // r6
  int v16; // r5
  _JNIEnv *CurrentJNIEnv; // r5
  int v18; // r6
  unsigned int v19; // [sp+18h] [bp-40h]
  _BOOL4 v20; // [sp+28h] [bp-30h]
  ZIPFile *inZip; // [sp+2Ch] [bp-2Ch] BYREF

  v4 = skippable;
  v6 = loop;
  inZip = 0;
  v8 = ZIPFile::FindFromStorage(MovieName, &inZip);
  v9 = volume;
  if ( v8 == -1 )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    v18 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, MovieName);
    _JNIEnv::CallVoidMethod(
      CurrentJNIEnv,
      s_event_globalThiz,
      s_PlayMovieInWindow,
      v18,
      0,
      0,
      windowSize[0],
      windowSize[1],
      v9,
      0,
      0,
      v6,
      0);
    CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v18);
  }
  else
  {
    v10 = inZip;
    v11 = v8;
    dataPtr = inZip->entries.dataPtr;
    v20 = v6;
    offset = dataPtr[v11].offset;
    length = dataPtr[v11].length;
    v15 = NVThreadGetCurrentJNIEnv();
    v16 = (int)v15->functions->NewStringUTF(&v15->functions, v10->filename);
    v19 = offset;
    v6 = v20;
    _JNIEnv::CallVoidMethod(
      v15,
      s_event_globalThiz,
      s_PlayMovieInWindow,
      v16,
      0,
      0,
      windowSize[0],
      windowSize[1],
      v9,
      v19,
      length,
      v20,
      0);
    _JNIEnv::CallVoidMethod(v15, s_event_globalThiz, s_MovieIsSkippable, v4);
    v15->functions->DeleteLocalRef(&v15->functions, (jobject)v16);
  }
  currentLoops = v6;
}

//----- (0026A988) --------------------------------------------------------
int __fastcall ZIPFile::FindFromStorage(const unsigned __int8 *filename, ZIPFile **inZip)
{
  pthread_mutex_t *v4; // r6
  int v5; // r4
  int v6; // r6

  v4 = (pthread_mutex_t *)storageMutex;
  if ( !storageMutex )
  {
    v4 = (pthread_mutex_t *)operator new(8u);
    pthread_mutexattr_init(v4[1].__private);
    pthread_mutexattr_settype(&v4[1], 1);
    pthread_mutex_init(v4, v4[1].__private);
    storageMutex = v4;
  }
  pthread_mutex_lock(v4);
  if ( ZIPFile::storageFiles.numEntries )
  {
    v5 = 0;
    while ( 1 )
    {
      v6 = ((int (__fastcall *)(ZIPFile *, const unsigned __int8 *))*ZIPFile::storageFiles.dataPtr[v5]->_vptr$ZIPFile)(
             ZIPFile::storageFiles.dataPtr[v5],
             filename);
      if ( v6 != -1 )
        break;
      if ( ++v5 >= ZIPFile::storageFiles.numEntries )
        goto LABEL_7;
    }
    *inZip = ZIPFile::storageFiles.dataPtr[v5];
    pthread_mutex_unlock((pthread_mutex_t *)storageMutex);
  }
  else
  {
LABEL_7:
    pthread_mutex_unlock((pthread_mutex_t *)storageMutex);
    v6 = -1;
    *inZip = 0;
  }
  return v6;
}
// 19EE74: using guessed type int __fastcall pthread_mutexattr_settype(_DWORD, _DWORD);

//----- (0026AA60) --------------------------------------------------------
void __fastcall AND_PlayMovie(
        const unsigned __int8 *filename,
        bool skippable,
        bool looping,
        int offset,
        int length,
        float volume)
{
  _BOOL4 v7; // r4
  _BOOL4 v8; // r8
  _JNIEnv *CurrentJNIEnv; // r5
  int v11; // r6

  v7 = looping;
  v8 = skippable;
  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v11 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, filename);
  _JNIEnv::CallVoidMethod(
    CurrentJNIEnv,
    s_event_globalThiz,
    s_PlayMovieInWindow,
    v11,
    0,
    0,
    windowSize[0],
    windowSize[1],
    volume,
    offset,
    length,
    v7,
    0);
  _JNIEnv::CallVoidMethod(CurrentJNIEnv, s_event_globalThiz, s_MovieIsSkippable, v8);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v11);
}

//----- (0026AB04) --------------------------------------------------------
void __fastcall AND_PlayMovie(const unsigned __int8 *filename, bool skippable, bool looping, float volume)
{
  _BOOL4 v5; // r8
  _JNIEnv *CurrentJNIEnv; // r4
  int v8; // r5

  v5 = looping;
  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v8 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, filename);
  _JNIEnv::CallVoidMethod(
    CurrentJNIEnv,
    s_event_globalThiz,
    s_PlayMovieInWindow,
    v8,
    0,
    0,
    windowSize[0],
    windowSize[1],
    volume,
    0,
    0,
    v5,
    0);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v8);
}

//----- (0026AB8C) --------------------------------------------------------
void __fastcall OS_MoviePlayinWindow(
        const unsigned __int8 *MovieName,
        int x,
        int y,
        int width,
        int height,
        int skippable,
        int loop,
        float volume)
{
  int v11; // r0
  ZIPFile *v12; // r6
  int v13; // r0
  ZIPFile::ZipEntry *dataPtr; // r1
  unsigned int offset; // r8
  unsigned int length; // r4
  _JNIEnv *CurrentJNIEnv; // r5
  int v18; // r6
  ZIPFile *inZip; // [sp+2Ch] [bp-2Ch] BYREF

  inZip = 0;
  v11 = ZIPFile::FindFromStorage(MovieName, &inZip);
  if ( v11 == -1 )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    v18 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, MovieName);
    _JNIEnv::CallVoidMethod(
      CurrentJNIEnv,
      s_event_globalThiz,
      s_PlayMovieInWindow,
      v18,
      x,
      y,
      width,
      height,
      volume,
      0,
      0,
      loop,
      1);
  }
  else
  {
    v12 = inZip;
    v13 = v11;
    dataPtr = inZip->entries.dataPtr;
    offset = dataPtr[v13].offset;
    length = dataPtr[v13].length;
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    v18 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, v12->filename);
    _JNIEnv::CallVoidMethod(
      CurrentJNIEnv,
      s_event_globalThiz,
      s_PlayMovieInWindow,
      v18,
      x,
      y,
      width,
      height,
      volume,
      offset,
      length,
      loop,
      1);
  }
  _JNIEnv::CallVoidMethod(CurrentJNIEnv, s_event_globalThiz, s_MovieIsSkippable, skippable);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v18);
  currentLoops = loop;
}

//----- (0026ACC8) --------------------------------------------------------
void __fastcall AND_MoviePlayInWindow(
        const unsigned __int8 *filename,
        int x,
        int y,
        int width,
        int height,
        int skippable,
        int looping,
        int offset,
        int length,
        float volume)
{
  _JNIEnv *CurrentJNIEnv; // r4
  int v15; // r5

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v15 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, filename);
  _JNIEnv::CallVoidMethod(
    CurrentJNIEnv,
    s_event_globalThiz,
    s_PlayMovieInWindow,
    v15,
    x,
    y,
    width,
    height,
    volume,
    offset,
    length,
    looping,
    1);
  _JNIEnv::CallVoidMethod(CurrentJNIEnv, s_event_globalThiz, s_MovieIsSkippable, skippable);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v15);
}

//----- (0026AD64) --------------------------------------------------------
void __fastcall OS_MovieSetSkippable(bool newSkippable)
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  sub_193E64(CurrentJNIEnv, s_event_globalThiz, s_MovieIsSkippable);
}

//----- (0026AD98) --------------------------------------------------------
void __fastcall AND_MovieIsSkippable(bool bSkippable)
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  sub_193E64(CurrentJNIEnv, s_event_globalThiz, s_MovieIsSkippable);
}

//----- (0026ADCC) --------------------------------------------------------
void OS_MovieStop()
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  sub_193E64(CurrentJNIEnv, s_event_globalThiz, s_StopMovie);
}

//----- (0026ADF4) --------------------------------------------------------
void AND_StopMovie()
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  sub_193E64(CurrentJNIEnv, s_event_globalThiz, s_StopMovie);
}

//----- (0026AE1C) --------------------------------------------------------
int __fastcall OS_MovieIsPlaying(int *isLooping)
{
  _JNIEnv *CurrentJNIEnv; // r0

  if ( isLooping )
    *isLooping = currentLoops;
  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  return sub_18B7B4(CurrentJNIEnv, s_event_globalThiz, s_IsMoviePlaying);
}

//----- (0026AE54) --------------------------------------------------------
jint AND_IsMoviePlaying()
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  return sub_18B7B4(CurrentJNIEnv, s_event_globalThiz, s_IsMoviePlaying);
}

//----- (0026AE7C) --------------------------------------------------------
void __fastcall OS_MovieSetText(const unsigned __int8 *text, bool DisplayNow, bool isSubtitle)
{
  _BOOL4 v3; // r8
  _BOOL4 v4; // r5
  _JNIEnv *CurrentJNIEnv; // r4
  int v7; // r6

  v3 = isSubtitle;
  v4 = DisplayNow;
  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v7 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, text);
  _JNIEnv::CallVoidMethod(CurrentJNIEnv, s_event_globalThiz, s_MovieSetText, v7, v4, v3);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v7);
}

//----- (0026AED8) --------------------------------------------------------
void __fastcall AND_MovieSetText(const unsigned __int8 *text, bool DisplayNow, bool isSubtitle)
{
  _BOOL4 v3; // r8
  _BOOL4 v4; // r5
  _JNIEnv *CurrentJNIEnv; // r4
  int v7; // r6

  v3 = isSubtitle;
  v4 = DisplayNow;
  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v7 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, text);
  _JNIEnv::CallVoidMethod(CurrentJNIEnv, s_event_globalThiz, s_MovieSetText, v7, v4, v3);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v7);
}

//----- (0026AF34) --------------------------------------------------------
void __fastcall OS_MovieClearText(bool isSubtitle)
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  sub_193E64(CurrentJNIEnv, s_event_globalThiz, s_MovieClearText);
}

//----- (0026AF5C) --------------------------------------------------------
void __fastcall AND_MovieClearText(bool isSubtitle)
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  sub_193E64(CurrentJNIEnv, s_event_globalThiz, s_MovieClearText);
}

//----- (0026AF84) --------------------------------------------------------
void __fastcall OS_MovieDisplayText(bool disp)
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  sub_193E64(CurrentJNIEnv, s_event_globalThiz, s_MovieDisplayText);
}

//----- (0026AFAC) --------------------------------------------------------
void __fastcall AND_MovieDisplayText(bool disp)
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  sub_193E64(CurrentJNIEnv, s_event_globalThiz, s_MovieDisplayText);
}

//----- (0026AFD4) --------------------------------------------------------
void __fastcall OS_MovieTextScale(int textScale)
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  sub_193E64(CurrentJNIEnv, s_event_globalThiz, s_MovieTextScale);
}

//----- (0026B008) --------------------------------------------------------
void __fastcall AND_MovieTextScale(int textScale)
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  sub_193E64(CurrentJNIEnv, s_event_globalThiz, s_MovieTextScale);
}

//----- (0026B03C) --------------------------------------------------------
int OS_PointerGetNumber()
{
  return 2;
}

//----- (0026B042) --------------------------------------------------------
OSPointingDevice __fastcall OS_PointerGetType(int deviceIndex)
{
  OSPointingDevice v1; // r1

  v1 = OSPD_Invalid;
  if ( (unsigned int)deviceIndex < 2 )
    return 2;
  return v1;
}

//----- (0026B050) --------------------------------------------------------
void __fastcall nvGetSystemCapabilities(NvSysCaps *syscaps, bool getGLESFeatures)
{
  NvSysCaps *v2; // r11
  _BOOL4 v3; // r4
  int Display; // r4
  const unsigned __int8 *String; // r0
  const unsigned __int8 *v6; // r5
  const char *v7; // r0
  const char *v8; // r0
  const char *v9; // r0
  __int64 (*ProcAddress)(void); // r6
  int v11; // r0
  bool v12; // zf
  __int64 (*v13)(void); // r4
  __int64 v14; // kr08_8
  int v15; // r0
  FILE *v16; // r4
  size_t v17; // r5
  unsigned __int8 *v18; // r0
  int v19; // r1
  int v20; // t1
  bool v21; // zf
  bool v22; // zf
  size_t v23; // r4
  int v24; // r3
  bool v25; // zf
  bool v26; // zf
  int v27; // r4
  int v28; // r0
  FILE *v29; // r4
  size_t v30; // r5
  int v31; // r0
  int v32; // r1
  FILE *v33; // r4
  int v34; // r9
  const unsigned __int8 *DataString; // r6
  size_t i; // r5
  unsigned int v37; // r2
  size_t v38; // r4
  unsigned int v39; // r2
  int v40; // r0
  size_t j; // r4
  unsigned int v42; // r2
  const unsigned __int8 *v43; // r0
  int v44; // r1
  int v45; // t1
  bool v46; // zf
  bool v47; // zf
  size_t v48; // r4
  int v49; // r6
  bool v50; // zf
  bool v51; // zf
  unsigned __int8 *v52; // r6
  int v53; // r1
  int v54; // t1
  bool v55; // zf
  bool v56; // zf
  size_t v57; // r2
  unsigned __int8 *v58; // r5
  int v59; // r4
  bool v60; // zf
  bool v61; // zf
  const unsigned __int8 *v62; // r0
  int v63; // r1
  int v64; // t1
  bool v65; // zf
  bool v66; // zf
  size_t v67; // r4
  int v68; // r6
  bool v69; // zf
  bool v70; // zf
  unsigned __int8 *v71; // r5
  int v72; // r1
  int v73; // t1
  bool v74; // zf
  bool v75; // zf
  size_t v76; // r2
  unsigned __int8 *v77; // r6
  int v78; // r4
  bool v79; // zf
  bool v80; // zf
  bool v81; // zf
  FILE *v82; // r4
  int v83; // r5
  const unsigned __int8 *v84; // r0
  const char *v85; // r0
  int v86; // r1
  int v87; // t1
  bool v88; // zf
  bool v89; // zf
  size_t v90; // r4
  int v91; // r6
  bool v92; // zf
  bool v93; // zf
  gzFile v94; // r0
  void *v95; // r5
  int v96; // r10
  int v97; // r8
  char *v98; // r11
  char *v99; // r9
  unsigned __int8 *v100; // r0
  FILE *v101; // r5
  signed int v102; // r4
  FILE *v103; // r5
  int v104; // r0
  int v105; // r1
  FILE *v106; // r5
  signed int v107; // r4
  FILE *v108; // r5
  int v109; // r0
  int v110; // r1
  NvSysCaps *v111; // [sp+0h] [bp-1248h]
  char v112[512]; // [sp+4h] [bp-1244h] BYREF
  char v113[32]; // [sp+204h] [bp-1044h] BYREF
  unsigned __int8 ptr[3548]; // [sp+224h] [bp-1024h] BYREF
  char v115; // [sp+1223h] [bp-25h]

  v2 = syscaps;
  v3 = getGLESFeatures;
  if ( !syscaps )
    return;
  memset(syscaps, 0, sizeof(NvSysCaps));
  if ( v3 )
  {
    Display = eglGetDisplay(0);
    _android_log_print(2, "nv_syscaps", "!!> EGL_EXTENSIONS:\n");
    String = (const unsigned __int8 *)eglQueryString(Display, 12373);
    logExtensionsStrings(String);
    _android_log_print(2, "nv_syscaps", "!!> GL_EXTENSIONS:\n");
    v6 = glGetString(0x1F03u);
    logExtensionsStrings(v6);
    v7 = (const char *)glGetString(0x1F00u);
    strncpy((char *)v2, v7, 0xFFu);
    v2->gl_vendor[255] = 0;
    v8 = (const char *)glGetString(0x1F01u);
    strncpy((char *)v2->gl_renderer, v8, 0xFFu);
    v2->gl_renderer[255] = 0;
    v9 = (const char *)glGetString(0x1F02u);
    strncpy((char *)v2->gl_version, v9, 0xFFu);
    v2->gl_version[255] = 0;
    ProcAddress = (__int64 (*)(void))eglGetProcAddress("eglGetSystemTimeFrequencyNV");
    v11 = eglGetProcAddress("eglGetSystemTimeNV");
    v12 = ProcAddress == 0;
    v13 = (__int64 (*)(void))v11;
    if ( ProcAddress )
      v12 = v11 == 0;
    if ( !v12 )
    {
      if ( ProcAddress() )
      {
        v14 = v13();
        v15 = usleep(0x7D0u);
        if ( ((__int64 (__fastcall *)(int))v13)(v15) != v14 )
          v2->has_nvtime = 1;
      }
    }
    if ( strstr((const char *)v6, "GL_EXT_texture_compression_s3tc") )
      v2->has_s3tc = 1;
    if ( strstr((const char *)v6, "GL_NV_depth_nonlinear") )
      v2->has_nlz = 1;
    if ( strstr((const char *)v6, "GL_NV_coverage_sample") )
      v2->has_csaa = 1;
    if ( strstr((const char *)v6, "GL_IMG_texture_compression_pvrtc") )
      v2->has_pvrtc = 1;
    if ( strstr((const char *)v6, "GL_AMD_compressed_ATC_texture") )
      v2->has_atitc = 1;
  }
  v16 = fopen("/sys/devices/system/cpu/present", (const char *)&dword_26B99C);
  if ( v16 )
  {
    v17 = fread(ptr, 1u, 0x1000u, v16);
    fclose(v16);
    v115 = 0;
    if ( v17 - 2 <= 0xD )
    {
      v18 = ptr;
      while ( 1 )
      {
        do
        {
          do
          {
            v20 = *v18++;
            v19 = v20;
          }
          while ( separators[5] == v20 );
        }
        while ( separators[4] == v19 );
        v21 = separators[3] == v19;
        if ( separators[3] != v19 )
          v21 = separators[2] == v19;
        if ( !v21 )
        {
          v22 = separators[0] == v19;
          if ( separators[0] != v19 )
            v22 = separators[1] == v19;
          if ( !v22 )
            break;
        }
      }
      v23 = 0;
      do
      {
        v24 = v18[v23++];
        if ( separators[5] == v24 )
          break;
        v25 = separators[4] == v24;
        if ( separators[4] != v24 )
          v25 = separators[3] == v24;
        if ( v25 )
          break;
        v26 = separators[2] == v24;
        if ( separators[2] != v24 )
          v26 = separators[0] == v24;
      }
      while ( !v26 && separators[1] != v24 );
      strncpy((char *)foundToken, (const char *)v18 - 1, v23);
      foundToken[v23] = 0;
      v27 = 1;
      if ( strlen((const char *)foundToken) != 1 )
      {
        v28 = atoi((const char *)&foundToken[2]) + 1;
        if ( v28 > 1 )
          v27 = v28;
      }
      v2->cpu_num_cores = v27;
    }
  }
  v29 = fopen("/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq", (const char *)&dword_26B99C);
  if ( v29 )
  {
    v30 = fread(ptr, 1u, 0x1000u, v29);
    fclose(v29);
    v115 = 0;
    if ( v30 - 4 <= 0xB )
    {
      v31 = atoi((const char *)ptr);
      v32 = v31 / 1000;
      if ( v31 < 1000 )
        v32 = 0;
      v2->cpu_max_mhz = v32;
    }
  }
  v33 = fopen("/proc/cpuinfo", (const char *)&dword_26B99C);
  if ( v33 )
  {
    v34 = fread(ptr, 1u, 0x1000u, v33);
    fclose(v33);
    v115 = 0;
    if ( v34 >= 11 )
    {
      DataString = findDataString(ptr, "Features", v34);
      if ( !DataString )
        goto LABEL_68;
      for ( i = 0; ; ++i )
      {
        v37 = DataString[i];
        if ( v37 <= 0xD && ((1 << v37) & 0x2401) != 0 )
          break;
      }
      strncpy((char *)findStringTempData, (const char *)DataString, i);
      v38 = 0;
      findStringTempData[i] = 0;
      v2->cpu_has_neon = findDataString(findStringTempData, "neon", i) != 0;
      while ( 1 )
      {
        v39 = DataString[v38];
        if ( v39 <= 0xD && ((1 << v39) & 0x2401) != 0 )
          break;
        ++v38;
      }
      strncpy((char *)findStringTempData, (const char *)DataString, v38);
      findStringTempData[v38] = 0;
      if ( findDataString(findStringTempData, "vfpv4", v38) )
      {
        v40 = 4;
      }
      else
      {
        for ( j = 0; ; ++j )
        {
          v42 = DataString[j];
          if ( v42 <= 0xD && ((1 << v42) & 0x2401) != 0 )
            break;
        }
        strncpy((char *)findStringTempData, (const char *)DataString, j);
        findStringTempData[j] = 0;
        if ( !findDataString(findStringTempData, "vfpv3", j) )
        {
LABEL_68:
          v43 = findDataString(ptr, "CPU architecture", v34) + 16;
          while ( 1 )
          {
            do
            {
              do
              {
                v45 = *v43++;
                v44 = v45;
              }
              while ( separators[5] == v45 );
            }
            while ( separators[4] == v44 );
            v46 = separators[3] == v44;
            if ( separators[3] != v44 )
              v46 = separators[2] == v44;
            if ( !v46 )
            {
              v47 = separators[0] == v44;
              if ( separators[0] != v44 )
                v47 = separators[1] == v44;
              if ( !v47 )
                break;
            }
          }
          v48 = 0;
          do
          {
            v49 = v43[v48++];
            if ( separators[5] == v49 )
              break;
            v50 = separators[4] == v49;
            if ( separators[4] != v49 )
              v50 = separators[3] == v49;
            if ( v50 )
              break;
            v51 = separators[2] == v49;
            if ( separators[2] != v49 )
              v51 = separators[0] == v49;
          }
          while ( !v51 && separators[1] != v49 );
          v52 = foundToken;
          strncpy((char *)foundToken, (const char *)v43 - 1, v48);
          foundToken[v48] = 0;
          while ( 1 )
          {
            do
            {
              do
              {
                v54 = *v52++;
                v53 = v54;
              }
              while ( separators[5] == v54 );
            }
            while ( separators[4] == v53 );
            v55 = separators[3] == v53;
            if ( separators[3] != v53 )
              v55 = separators[2] == v53;
            if ( !v55 )
            {
              v56 = separators[0] == v53;
              if ( separators[0] != v53 )
                v56 = separators[1] == v53;
              if ( !v56 )
                break;
            }
          }
          v57 = 0;
          v58 = foundToken;
          do
          {
            v59 = v52[v57];
            ++v58;
            ++v57;
            if ( separators[5] == v59 )
              break;
            v60 = separators[4] == v59;
            if ( separators[4] != v59 )
              v60 = separators[3] == v59;
            if ( v60 )
              break;
            v61 = separators[2] == v59;
            if ( separators[2] != v59 )
              v61 = separators[0] == v59;
          }
          while ( !v61 && separators[1] != v59 );
          strncpy((char *)foundToken, (const char *)v52 - 1, v57);
          *v58 = 0;
          strcpy(v112, (const char *)foundToken);
          v62 = findDataString(ptr, "CPU part", v34) + 8;
          while ( 1 )
          {
            do
            {
              do
              {
                v64 = *v62++;
                v63 = v64;
              }
              while ( separators[5] == v64 );
            }
            while ( separators[4] == v63 );
            v65 = separators[3] == v63;
            if ( separators[3] != v63 )
              v65 = separators[2] == v63;
            if ( !v65 )
            {
              v66 = separators[0] == v63;
              if ( separators[0] != v63 )
                v66 = separators[1] == v63;
              if ( !v66 )
                break;
            }
          }
          v67 = 0;
          do
          {
            v68 = v62[v67++];
            if ( separators[5] == v68 )
              break;
            v69 = separators[4] == v68;
            if ( separators[4] != v68 )
              v69 = separators[3] == v68;
            if ( v69 )
              break;
            v70 = separators[2] == v68;
            if ( separators[2] != v68 )
              v70 = separators[0] == v68;
          }
          while ( !v70 && separators[1] != v68 );
          v71 = foundToken;
          strncpy((char *)foundToken, (const char *)v62 - 1, v67);
          foundToken[v67] = 0;
          while ( 1 )
          {
            do
            {
              do
              {
                v73 = *v71++;
                v72 = v73;
              }
              while ( separators[5] == v73 );
            }
            while ( separators[4] == v72 );
            v74 = separators[3] == v72;
            if ( separators[3] != v72 )
              v74 = separators[2] == v72;
            if ( !v74 )
            {
              v75 = separators[0] == v72;
              if ( separators[0] != v72 )
                v75 = separators[1] == v72;
              if ( !v75 )
                break;
            }
          }
          v76 = 0;
          v77 = foundToken;
          do
          {
            v78 = v71[v76];
            ++v77;
            ++v76;
            if ( separators[5] == v78 )
              break;
            v79 = separators[4] == v78;
            if ( separators[4] != v78 )
              v79 = separators[3] == v78;
            if ( v79 )
              break;
            v80 = separators[2] == v78;
            if ( separators[2] != v78 )
              v80 = separators[0] == v78;
          }
          while ( !v80 && separators[1] != v78 );
          strncpy((char *)foundToken, (const char *)v71 - 1, v76);
          *v77 = 0;
          strcpy(v113, (const char *)foundToken);
          v81 = v112[0] == 0;
          if ( v112[0] )
            v81 = v113[0] == 0;
          if ( !v81 )
          {
            v2->cpu_arch_version = strtol(v112, 0, 0);
            v2->cpu_part_version = strtol(v113, 0, 0);
          }
          goto LABEL_144;
        }
        v40 = 3;
      }
      v2->cpu_vfp_version = v40;
      goto LABEL_68;
    }
  }
LABEL_144:
  v82 = fopen("/proc/meminfo", (const char *)&dword_26B99C);
  if ( v82 )
  {
    v83 = fread(ptr, 1u, 0x1000u, v82);
    fclose(v82);
    v115 = 0;
    if ( v83 >= 11 )
    {
      v84 = findDataString(ptr, "MemTotal:", v83);
      if ( v84 )
      {
        v85 = (const char *)(v84 + 9);
        while ( 1 )
        {
          do
          {
            do
            {
              v87 = *(unsigned __int8 *)v85++;
              v86 = v87;
            }
            while ( separators[5] == v87 );
          }
          while ( separators[4] == v86 );
          v88 = separators[3] == v86;
          if ( separators[3] != v86 )
            v88 = separators[2] == v86;
          if ( !v88 )
          {
            v89 = separators[0] == v86;
            if ( separators[0] != v86 )
              v89 = separators[1] == v86;
            if ( !v89 )
              break;
          }
        }
        v90 = 0;
        do
        {
          v91 = (unsigned __int8)v85[v90++];
          if ( separators[5] == v91 )
            break;
          v92 = separators[4] == v91;
          if ( separators[4] != v91 )
            v92 = separators[3] == v91;
          if ( v92 )
            break;
          v93 = separators[2] == v91;
          if ( separators[2] != v91 )
            v93 = separators[0] == v91;
        }
        while ( !v93 && separators[1] != v91 );
        strncpy((char *)foundToken, v85 - 1, v90);
        foundToken[v90] = 0;
        v2->mem_total_mb = atoi((const char *)foundToken) / 1024;
      }
    }
  }
  v94 = j_gzopen("/proc/config.gz", (const unsigned __int8 *)&dword_26B99C);
  v95 = v94;
  if ( v94 )
  {
    if ( j_gzgets(v94, (unsigned __int8 *)v112, 512) )
    {
      v96 = 0;
      v97 = 0;
      do
      {
        while ( v112[0] == 35 || !strstr(v112, (const char *)&dword_26BA14) )
        {
          if ( !j_gzgets(v95, (unsigned __int8 *)v112, 512) )
            goto LABEL_178;
        }
        v111 = v2;
        v98 = strstr(v112, "CONFIG_ARCH_TEGRA");
        v99 = strstr(v112, "CONFIG_TEGRA");
        v100 = j_gzgets(v95, (unsigned __int8 *)v112, 512);
        v12 = v98 == 0;
        v2 = v111;
        if ( !v12 )
          ++v96;
        if ( v99 )
          ++v97;
      }
      while ( v100 );
LABEL_178:
      if ( v97 >= 3 && v96 >= 1 )
        v2->cpu_is_tegra = 1;
    }
    j_gzclose(v95);
  }
  if ( v2->cpu_is_tegra )
  {
    if ( v2->cpu_has_neon )
      v2->cpu_is_t3plus = 1;
    if ( v2->cpu_vfp_version > 3 || (v2->cpu_part_version & 0xFEu) > 9 || v2->cpu_arch_version >= 8 )
      v2->cpu_is_tng = 1;
  }
  v101 = fopen("/sys/devices/platform/tegra-nvmap/misc/nvmap/heap-generic-0/total_size", (const char *)&dword_26B99C);
  if ( v101 )
  {
    v102 = fread(ptr, 1u, 0x1000u, v101);
    fclose(v101);
    v115 = 0;
    if ( v102 > -1 )
      goto LABEL_193;
  }
  v103 = fopen("/sys/devices/virtual/misc/nvmap/heap-generic-0/total_size", (const char *)&dword_26B99C);
  if ( v103 )
  {
    v102 = fread(ptr, 1u, 0x1000u, v103);
    fclose(v103);
    v115 = 0;
LABEL_193:
    if ( (unsigned int)(v102 - 4) <= 0xB )
    {
      v104 = atoi((const char *)ptr);
      v105 = v104 / 0x100000;
      if ( v104 < 0x100000 )
        v105 = 0;
      v2->gpu_mem_total_mb = v105;
    }
  }
  v106 = fopen("/sys/devices/platform/tegra-nvmap/misc/nvmap/heap-generic-0/free_size", (const char *)&dword_26B99C);
  if ( !v106 || (v107 = fread(ptr, 1u, 0x1000u, v106), fclose(v106), v115 = 0, v107 <= -1) )
  {
    v108 = fopen("/sys/devices/virtual/misc/nvmap/heap-generic-0/free_size", (const char *)&dword_26B99C);
    if ( !v108 )
      return;
    v107 = fread(ptr, 1u, 0x1000u, v108);
    fclose(v108);
    v115 = 0;
  }
  if ( (unsigned int)(v107 - 4) <= 0xB )
  {
    v109 = atoi((const char *)ptr);
    v110 = v109 / 0x100000;
    if ( v109 < 0x100000 )
      v110 = 0;
    v2->gpu_mem_free_mb = v110;
  }
}
// 195708: using guessed type int __fastcall eglGetDisplay(_DWORD);
// 197658: using guessed type int __fastcall eglGetProcAddress(_DWORD);
// 1991DC: using guessed type int __fastcall eglQueryString(_DWORD, _DWORD);
// 26B99C: using guessed type int dword_26B99C;
// 26BA14: using guessed type int dword_26BA14;

//----- (0026BA38) --------------------------------------------------------
const unsigned __int8 *__fastcall OS_SystemGetBuildinfo(int index)
{
  char *v2; // r5
  _JNIEnv *CurrentJNIEnv; // r4
  int v4; // r8
  const char *v5; // r6
  jboolean v7[17]; // [sp+7h] [bp-11h] BYREF

  if ( (unsigned int)index > 2 )
    return "UNKNOWN";
  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v4 = _JNIEnv::CallObjectMethod(CurrentJNIEnv, s_event_globalThiz, s_GetAndroidBuildinfo, index);
  v5 = (const char *)CurrentJNIEnv->functions->GetStringUTFChars(&CurrentJNIEnv->functions, (jstring)v4, v7);
  v2 = (char *)staticBuildinfo[index];
  strcpy(v2, v5);
  CurrentJNIEnv->functions->ReleaseStringUTFChars(&CurrentJNIEnv->functions, (jstring)v4, (const unsigned __int8 *)v5);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v4);
  return (const unsigned __int8 *)v2;
}
// 26BA38: using guessed type jboolean var_11[17];

//----- (0026BAC4) --------------------------------------------------------
OSDeviceChip OS_SystemChip()
{
  return deviceChip;
}

//----- (0026BAD4) --------------------------------------------------------
OSDeviceForm OS_SystemForm()
{
  return deviceForm;
}

//----- (0026BAE4) --------------------------------------------------------
OSDefinedDevice OS_SystemDevice()
{
  return definedDevice;
}

//----- (0026BAF4) --------------------------------------------------------
int OS_SystemVersion()
{
  return 10;
}

//----- (0026BAF8) --------------------------------------------------------
int __fastcall OS_GetDeviceInfo(int index)
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  return sub_18B7B4(CurrentJNIEnv, s_event_globalThiz, s_GetDeviceInfo);
}

//----- (0026BB2C) --------------------------------------------------------
int __fastcall AND_GetDeviceInfo(int index)
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  return sub_18B7B4(CurrentJNIEnv, s_event_globalThiz, s_GetDeviceInfo);
}

//----- (0026BB60) --------------------------------------------------------
unsigned __int8 *OS_SystemGetDeviceID()
{
  _JNIEnv *CurrentJNIEnv; // r4
  int v1; // r5
  const char *v2; // r6
  jboolean v4[17]; // [sp+7h] [bp-11h] BYREF

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v1 = _JNIEnv::CallObjectMethod(CurrentJNIEnv, s_event_globalThiz, s_GetDeviceID);
  v2 = (const char *)CurrentJNIEnv->functions->GetStringUTFChars(&CurrentJNIEnv->functions, (jstring)v1, v4);
  strncpy((char *)staticDeviceID, v2, 0x80u);
  CurrentJNIEnv->functions->ReleaseStringUTFChars(&CurrentJNIEnv->functions, (jstring)v1, (const unsigned __int8 *)v2);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v1);
  return staticDeviceID;
}
// 26BB60: using guessed type jboolean var_11[17];

//----- (0026BBD8) --------------------------------------------------------
unsigned __int8 *AND_GetDeviceID()
{
  _JNIEnv *CurrentJNIEnv; // r4
  int v1; // r5
  const char *v2; // r6
  jboolean v4[17]; // [sp+7h] [bp-11h] BYREF

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v1 = _JNIEnv::CallObjectMethod(CurrentJNIEnv, s_event_globalThiz, s_GetDeviceID);
  v2 = (const char *)CurrentJNIEnv->functions->GetStringUTFChars(&CurrentJNIEnv->functions, (jstring)v1, v4);
  strncpy((char *)staticDeviceID, v2, 0x80u);
  CurrentJNIEnv->functions->ReleaseStringUTFChars(&CurrentJNIEnv->functions, (jstring)v1, (const unsigned __int8 *)v2);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v1);
  return staticDeviceID;
}
// 26BBD8: using guessed type jboolean var_11[17];

//----- (0026BC50) --------------------------------------------------------
const unsigned __int8 *__fastcall AND_GetAndroidBuildinfo(int index)
{
  char *v2; // r5
  _JNIEnv *CurrentJNIEnv; // r4
  int v4; // r8
  const char *v5; // r6
  jboolean v7[17]; // [sp+7h] [bp-11h] BYREF

  if ( (unsigned int)index > 2 )
    return "UNKNOWN";
  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v4 = _JNIEnv::CallObjectMethod(CurrentJNIEnv, s_event_globalThiz, s_GetAndroidBuildinfo, index);
  v5 = (const char *)CurrentJNIEnv->functions->GetStringUTFChars(&CurrentJNIEnv->functions, (jstring)v4, v7);
  v2 = (char *)staticBuildinfo[index];
  strcpy(v2, v5);
  CurrentJNIEnv->functions->ReleaseStringUTFChars(&CurrentJNIEnv->functions, (jstring)v4, (const unsigned __int8 *)v5);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v4);
  return (const unsigned __int8 *)v2;
}
// 26BC50: using guessed type jboolean var_11[17];

//----- (0026BCDC) --------------------------------------------------------
unsigned __int8 *OS_SystemGetAppId()
{
  _JNIEnv *CurrentJNIEnv; // r4
  int v1; // r5
  const char *v2; // r6
  jboolean v4[17]; // [sp+7h] [bp-11h] BYREF

  if ( !staticAppId[0] )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    v1 = _JNIEnv::CallObjectMethod(CurrentJNIEnv, s_event_globalThiz, s_GetAppId);
    v2 = (const char *)CurrentJNIEnv->functions->GetStringUTFChars(&CurrentJNIEnv->functions, (jstring)v1, v4);
    strcpy((char *)staticAppId, v2);
    CurrentJNIEnv->functions->ReleaseStringUTFChars(&CurrentJNIEnv->functions, (jstring)v1, (const unsigned __int8 *)v2);
    CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v1);
  }
  return staticAppId;
}
// 26BCDC: using guessed type jboolean var_11[17];

//----- (0026BD68) --------------------------------------------------------
unsigned __int8 *AND_GetAppId()
{
  _JNIEnv *CurrentJNIEnv; // r4
  int v1; // r5
  const char *v2; // r6
  jboolean v4[17]; // [sp+7h] [bp-11h] BYREF

  if ( !staticAppId[0] )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    v1 = _JNIEnv::CallObjectMethod(CurrentJNIEnv, s_event_globalThiz, s_GetAppId);
    v2 = (const char *)CurrentJNIEnv->functions->GetStringUTFChars(&CurrentJNIEnv->functions, (jstring)v1, v4);
    strcpy((char *)staticAppId, v2);
    CurrentJNIEnv->functions->ReleaseStringUTFChars(&CurrentJNIEnv->functions, (jstring)v1, (const unsigned __int8 *)v2);
    CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v1);
  }
  return staticAppId;
}
// 26BD68: using guessed type jboolean var_11[17];

//----- (0026BDF4) --------------------------------------------------------
bool OS_DeviceIsTV()
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  return _JNIEnv::CallBooleanMethod(CurrentJNIEnv, s_event_globalThiz, s_IsTV) != 0;
}

//----- (0026BE20) --------------------------------------------------------
bool AND_DeviceIsTV()
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  return _JNIEnv::CallBooleanMethod(CurrentJNIEnv, s_event_globalThiz, s_IsTV) != 0;
}

//----- (0026BE4C) --------------------------------------------------------
void __fastcall AND_CurrentThreadAffinityMask(const unsigned __int8 *name, int cpuNo)
{
  int v3; // r4
  int v4; // r1
  int v5; // r3
  int v6; // [sp+0h] [bp-10h] BYREF
  int v7[3]; // [sp+4h] [bp-Ch] BYREF

  v3 = gettid(name);
  v7[0] = 3;
  syscall(242, v3, 4, v7);
  if ( v7[0] != 1 )
  {
    v4 = -1;
    do
    {
      v5 = v4 + 1;
      v4 = (1 << (v4 + 1)) & v7[0];
      if ( v4 )
        v4 = v5;
      --cpuNo;
    }
    while ( cpuNo );
    if ( v4 <= 15 )
    {
      v6 = 1 << v4;
      syscall(241, v3, 4, &v6);
    }
  }
}
// 19AE30: using guessed type int __fastcall gettid(_DWORD);
// 26BE4C: using guessed type int var_C[3];

//----- (0026BEA0) --------------------------------------------------------
void *__fastcall ANDRunThread(void *data)
{
  int v2; // r6
  int v3; // r5
  int v4; // r1
  int v5; // r3
  void (__fastcall **v6)(_DWORD); // r5
  int v8; // [sp+0h] [bp-18h] BYREF
  int v9[5]; // [sp+4h] [bp-14h] BYREF

  v2 = *((_DWORD *)data + 17);
  if ( v2 )
  {
    v3 = gettid(data);
    v9[0] = 3;
    syscall(242, v3, 4, v9);
    if ( v9[0] != 1 )
    {
      v4 = -1;
      do
      {
        v5 = v4 + 1;
        v4 = (1 << (v4 + 1)) & v9[0];
        if ( v4 )
          v4 = v5;
        --v2;
      }
      while ( v2 );
      if ( v4 <= 15 )
      {
        v8 = 1 << v4;
        syscall(241, v3, 4, &v8);
      }
    }
  }
  if ( *(_BYTE *)data )
    pthread_setname_np(*((_DWORD *)data + 9), data);
  v6 = (void (__fastcall **)(_DWORD))*((_DWORD *)data + 8);
  pthread_setspecific(ANDThreadStorageKey, v6);
  *((_BYTE *)data + 65) = 1;
  (*v6)(v6[1]);
  *((_WORD *)data + 32) = 1;
  return 0;
}
// 196BC8: using guessed type int __fastcall pthread_setname_np(_DWORD, _DWORD);
// 19AE30: using guessed type int __fastcall gettid(_DWORD);
// 26BEA0: using guessed type int var_14[5];

//----- (0026BF34) --------------------------------------------------------
char *__fastcall OS_ThreadLaunch(
        OSThreadFunction function,
        void *functionData,
        unsigned int processorAffinity,
        const unsigned __int8 *threadName,
        int joinable,
        int a6)
{
  char *v10; // r9
  _DWORD *v11; // r5
  int priority_min; // r5
  int priority_max; // r10
  void *v14; // r5
  struct sched_param param; // [sp+4h] [bp-24h] BYREF
  size_t stacksize[8]; // [sp+8h] [bp-20h] BYREF

  v10 = (char *)malloc(0x48u);
  v11 = malloc(0xCu);
  *v11 = function;
  v11[1] = functionData;
  v11[2] = 0;
  if ( threadName )
    strcpy(v10, (const char *)threadName);
  else
    strcpy(v10, "AppThread");
  *((_DWORD *)v10 + 9) = 0;
  stacksize[0] = 0;
  *((_DWORD *)v10 + 8) = v11;
  *((_WORD *)v10 + 32) = 0;
  *((_DWORD *)v10 + 17) = processorAffinity;
  pthread_attr_init((pthread_attr_t *)(v10 + 40));
  pthread_attr_getstacksize((const pthread_attr_t *)(v10 + 40), stacksize);
  priority_min = sched_get_priority_min(0);
  priority_max = sched_get_priority_max(0);
  pthread_attr_getschedparam((const pthread_attr_t *)(v10 + 40), &param);
  switch ( a6 )
  {
    case 0:
      goto LABEL_8;
    case 1:
      priority_min += 2 * (priority_max - priority_min) / 3;
      goto LABEL_8;
    case 2:
      priority_min += 4 * (priority_max - priority_min) / 5;
      goto LABEL_8;
    case 3:
      priority_min = priority_max;
LABEL_8:
      param.sched_priority = priority_min;
      break;
    default:
      break;
  }
  pthread_attr_setschedparam((pthread_attr_t *)(v10 + 40), &param);
  v14 = malloc(0x28u);
  *(_DWORD *)v14 = v10;
  *((_DWORD *)v14 + 1) = ANDRunThread;
  strncpy((char *)v14 + 8, v10, 0x1Fu);
  if ( pthread_create((pthread_t *)v10 + 9, (const pthread_attr_t *)(v10 + 40), NVThreadSpawnProc, v14) )
    free(v14);
  pthread_setschedparam(*((_DWORD *)v10 + 9), 0, &param);
  pthread_setname_np(*((_DWORD *)v10 + 9), threadName);
  return v10;
}
// 196BC8: using guessed type int __fastcall pthread_setname_np(_DWORD, _DWORD);
// 26BF34: using guessed type size_t stacksize[8];

//----- (0026C074) --------------------------------------------------------
int __fastcall NVThreadSpawnJNIThread(
        pthread_t *thread,
        const pthread_attr_t *attr,
        const unsigned __int8 *name,
        void *(*start_routine)(void *),
        int a5)
{
  void *v9; // r4
  int v10; // r5

  if ( !start_routine )
    return -1;
  v9 = malloc(0x28u);
  *(_DWORD *)v9 = a5;
  *((_DWORD *)v9 + 1) = start_routine;
  strncpy((char *)v9 + 8, (const char *)name, 0x1Fu);
  v10 = pthread_create(thread, attr, NVThreadSpawnProc, v9);
  if ( !v10 )
    return 0;
  free(v9);
  return v10;
}

//----- (0026C0D0) --------------------------------------------------------
void __fastcall OS_ThreadSetValue(void *withValue)
{
  _DWORD *v2; // r0

  v2 = pthread_getspecific(ANDThreadStorageKey);
  if ( v2 )
    v2[2] = withValue;
}

//----- (0026C0F0) --------------------------------------------------------
void *OS_ThreadGetValue()
{
  _DWORD *v0; // r0

  v0 = pthread_getspecific(ANDThreadStorageKey);
  if ( v0 )
    return (void *)v0[2];
  else
    return 0;
}

//----- (0026C112) --------------------------------------------------------
bool __fastcall OS_ThreadIsRunning(OSThreadHandle thread)
{
  return thread && *((_BYTE *)thread + 65) != 0;
}

//----- (0026C126) --------------------------------------------------------
void __fastcall OS_ThreadWait(OSThreadHandle untilFinished)
{
  if ( untilFinished )
    sub_195640(*((_DWORD *)untilFinished + 9), 0);
}

//----- (0026C134) --------------------------------------------------------
void __fastcall OS_ThreadClose(OSThreadHandle thread)
{
  pthread_attr_destroy((pthread_attr_t *)((char *)thread + 40));
  j_free(thread);
}

//----- (0026C14C) --------------------------------------------------------
bool AND_ThreadOnMain()
{
  return *(_DWORD *)pthread_getspecific(ANDThreadStorageKey) == 0;
}

//----- (0026C16C) --------------------------------------------------------
sem_t *OS_SemaphoreCreate()
{
  sem_t *v0; // r4

  v0 = (sem_t *)malloc(4u);
  v0->count = 0;
  sem_init(v0, 0, 0);
  return v0;
}

//----- (0026C196) --------------------------------------------------------
bool __fastcall OS_SemaphoreTryWait(OSSemaphore forSem)
{
  return sem_trywait((sem_t *)forSem) != -1 || *(_DWORD *)_errno() != 11;
}
// 19CEE8: using guessed type int _errno(void);

//----- (0026C1B8) --------------------------------------------------------
int __fastcall OS_SemaphoreGet(OSSemaphore fromSem)
{
  int sval; // [sp+4h] [bp-Ch] BYREF

  sval = 0;
  sem_getvalue((sem_t *)fromSem, &sval);
  return sval;
}

//----- (0026C1D0) --------------------------------------------------------
unsigned int OS_TimeMS()
{
  double v0; // d17
  double v1; // d16
  struct timeval v3; // [sp+0h] [bp-10h] BYREF

  gettimeofday(&v3, 0);
  if ( v3.tv_usec > (int)"ist_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly" || v3.tv_usec <= -1 )
    v0 = OS_TimeAccurate(void)::last_current_time
       - (double)(unsigned int)OS_TimeAccurate(void)::last_current_time
       + 0.00033;
  else
    v0 = (double)v3.tv_usec / 1000000.0;
  v1 = v0 + (double)v3.tv_sec;
  OS_TimeAccurate(void)::last_current_time = v1;
  if ( v1 - OS_TimeAccurate(void)::lastPrint > 5.0 )
    OS_TimeAccurate(void)::lastPrint = v0 + (double)v3.tv_sec;
  return (unsigned int)((v1 - base_time) * 1000.0);
}

//----- (0026C2A4) --------------------------------------------------------
void __fastcall OS_GetDateTime(DateTime *ret)
{
  int tm_mday; // r12
  int tm_hour; // r3
  int tm_sec; // r0
  int tm_min; // lr
  int v6; // r2
  struct tm v7; // [sp+0h] [bp-48h] BYREF
  time_t timer; // [sp+2Ch] [bp-1Ch] BYREF
  struct timespec tp; // [sp+30h] [bp-18h] BYREF

  clock_gettime(0, &tp);
  timer = tp.tv_sec;
  localtime_r(&timer, &v7);
  tm_mday = v7.tm_mday;
  tm_hour = v7.tm_hour;
  tm_sec = v7.tm_sec;
  tm_min = v7.tm_min;
  v6 = v7.tm_year + 1900;
  ret->month = v7.tm_mon + 1;
  ret->day = tm_mday;
  ret->year = v6;
  ret->hour = tm_hour;
  ret->minute = tm_min;
  ret->second = tm_sec;
  ret->centisecond = tm_sec / 100;
}

//----- (0026C300) --------------------------------------------------------
bool __fastcall OS_ServiceIsAppInstalled(const unsigned __int8 *appName)
{
  _JNIEnv *CurrentJNIEnv; // r5
  int v3; // r4
  int v4; // r6

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v3 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, appName);
  v4 = _JNIEnv::CallBooleanMethod(CurrentJNIEnv, s_event_globalThiz, s_IsAppInstalled, v3);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v3);
  return v4 != 0;
}

//----- (0026C358) --------------------------------------------------------
bool __fastcall AND_IsAppInstalled(const unsigned __int8 *app)
{
  _JNIEnv *CurrentJNIEnv; // r5
  int v3; // r4
  int v4; // r6

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v3 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, app);
  v4 = _JNIEnv::CallBooleanMethod(CurrentJNIEnv, s_event_globalThiz, s_IsAppInstalled, v3);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v3);
  return v4 != 0;
}

//----- (0026C3B0) --------------------------------------------------------
void __fastcall OS_ServiceOpenLink(const unsigned __int8 *link)
{
  _JNIEnv *CurrentJNIEnv; // r5
  int v3; // r4

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v3 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, link);
  _JNIEnv::CallVoidMethod(CurrentJNIEnv, s_event_globalThiz, s_OpenLink, v3);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v3);
}

//----- (0026C3F8) --------------------------------------------------------
void __fastcall AND_OpenLink(const unsigned __int8 *link)
{
  _JNIEnv *CurrentJNIEnv; // r5
  int v3; // r4

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v3 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, link);
  _JNIEnv::CallVoidMethod(CurrentJNIEnv, s_event_globalThiz, s_OpenLink, v3);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v3);
}

//----- (0026C440) --------------------------------------------------------
void __fastcall OS_ServiceRateApp(const unsigned __int8 *appId)
{
  _JNIEnv *CurrentJNIEnv; // r5
  int v2; // r4
  unsigned __int8 s[512]; // [sp+4h] [bp-20Ch] BYREF

  snprintf(s, 0x200u, "market://details?id=%s", (const char *)appId);
  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v2 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, s);
  _JNIEnv::CallVoidMethod(CurrentJNIEnv, s_event_globalThiz, s_OpenLink, v2);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v2);
}

//----- (0026C4C4) --------------------------------------------------------
void __fastcall OS_ServiceUpdateApp(const unsigned __int8 *appId)
{
  _JNIEnv *CurrentJNIEnv; // r5
  int v2; // r4
  unsigned __int8 s[512]; // [sp+4h] [bp-20Ch] BYREF

  snprintf(s, 0x200u, "market://details?id=%s", (const char *)appId);
  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v2 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, s);
  _JNIEnv::CallVoidMethod(CurrentJNIEnv, s_event_globalThiz, s_OpenLink, v2);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v2);
}

//----- (0026C548) --------------------------------------------------------
void OS_ServiceShowAd()
{
  _JNIEnv *CurrentJNIEnv; // r0

  if ( AdMobInitialized == 1 )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    sub_193E64(CurrentJNIEnv, WarAdMob_thiz, s_showAdPopup);
  }
}
// 6D70E8: using guessed type char AdMobInitialized;

//----- (0026C57C) --------------------------------------------------------
int __fastcall OS_ServiceGetAdState(int adResultType)
{
  _JNIEnv *CurrentJNIEnv; // r0

  if ( AdMobInitialized != 1 )
    return 0;
  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  return sub_18B7B4(CurrentJNIEnv, WarAdMob_thiz, s_getAdState);
}
// 6D70E8: using guessed type char AdMobInitialized;

//----- (0026C5B8) --------------------------------------------------------
void __fastcall Java_com_wardrumstudios_utils_WarService_jniWarService(JNIEnv_0 *env, jobject_0 clazz)
{
  jclass v4; // r6

  v4 = env->functions->FindClass(env, "com/wardrumstudios/utils/WarService");
  WarService_thiz = (jobject_0)env->functions->NewGlobalRef(env, clazz);
  s_LocalPushNotification = env->functions->GetMethodID(
                              env,
                              v4,
                              "LocalPushNotification",
                              "(ILjava/lang/String;Ljava/lang/String;)V");
  s_LocalPushNotificationCancel = env->functions->GetMethodID(env, v4, "LocalPushNotificationCancel", "()V");
}

//----- (0026C6A8) --------------------------------------------------------
void __fastcall Java_com_wardrumstudios_utils_WarAdMob_jniWarAdMob(JNIEnv_0 *env, jobject_0 clazz)
{
  jclass v3; // r5

  WarAdMob_thiz = (jobject_0)env->functions->NewGlobalRef(env, clazz);
  v3 = env->functions->FindClass(env, "com/wardrumstudios/utils/WarAdMob");
  s_showAdPopup = env->functions->GetMethodID(env, v3, "ShowAdPopup", "()V");
  s_getAdState = env->functions->GetMethodID(env, v3, "GetAdState", "(I)I");
  AdMobInitialized = 1;
}
// 6D70E8: using guessed type char AdMobInitialized;

//----- (0026C758) --------------------------------------------------------
void __fastcall OS_ServiceLocalNotification(
        int secondsToFire,
        const unsigned __int8 *title,
        const unsigned __int8 *message)
{
  _JNIEnv *CurrentJNIEnv; // r6
  int v7; // r5
  int v8; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v7 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, title);
  v8 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, message);
  _JNIEnv::CallVoidMethod(CurrentJNIEnv, WarService_thiz, s_LocalPushNotification, secondsToFire, v7, v8);
}

//----- (0026C7B4) --------------------------------------------------------
void OS_ServiceLocalNotificationCancel()
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  sub_193E64(CurrentJNIEnv, WarService_thiz, s_LocalPushNotificationCancel);
}

//----- (0026C7DC) --------------------------------------------------------
const unsigned __int8 *__fastcall War_HttpPost(const unsigned __int8 *url)
{
  _JNIEnv *CurrentJNIEnv; // r4
  _JNIEnv *v3; // r4
  int v4; // r5
  int v5; // r6
  const char *v6; // r5
  size_t v7; // r0
  char *v8; // r8

  if ( !s_warHttp )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warHttp = (jobject_0)_JNIEnv::NewObject(CurrentJNIEnv, s_warHttp_class, s_warHttp_ctor, s_event_globalThiz);
    s_warHttp = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 49);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v3 = NVThreadGetCurrentJNIEnv();
  v4 = (int)v3->functions->NewStringUTF(&v3->functions, url);
  v5 = _JNIEnv::CallObjectMethod(v3, s_warHttp, s_warHttpPost, v4);
  v3->functions->DeleteLocalRef(&v3->functions, (jobject)v4);
  v6 = (const char *)v3->functions->GetStringUTFChars(&v3->functions, (jstring)v5, 0);
  v7 = strlen(v6);
  v8 = (char *)malloc(v7 + 1);
  strcpy(v8, v6);
  v3->functions->ReleaseStringUTFChars(&v3->functions, (jstring)v5, (const unsigned __int8 *)v6);
  if ( ((int (__fastcall *)(_JNIEnv *))v3->functions->ExceptionCheck)(v3) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 81);
    v3->functions->ExceptionDescribe(&v3->functions);
  }
  return (const unsigned __int8 *)v8;
}

//----- (0026C910) --------------------------------------------------------
const unsigned __int8 *__fastcall War_HttpGet(const unsigned __int8 *url)
{
  _JNIEnv *CurrentJNIEnv; // r4
  _JNIEnv *v3; // r4
  int v4; // r5
  int v5; // r6
  const char *v6; // r5
  size_t v7; // r0
  char *v8; // r8

  if ( !s_warHttp )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warHttp = (jobject_0)_JNIEnv::NewObject(CurrentJNIEnv, s_warHttp_class, s_warHttp_ctor, s_event_globalThiz);
    s_warHttp = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 49);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v3 = NVThreadGetCurrentJNIEnv();
  v4 = (int)v3->functions->NewStringUTF(&v3->functions, url);
  v5 = _JNIEnv::CallObjectMethod(v3, s_warHttp, s_warHttpGet, v4);
  v3->functions->DeleteLocalRef(&v3->functions, (jobject)v4);
  v6 = (const char *)v3->functions->GetStringUTFChars(&v3->functions, (jstring)v5, 0);
  v7 = strlen(v6);
  v8 = (char *)malloc(v7 + 1);
  strcpy(v8, v6);
  v3->functions->ReleaseStringUTFChars(&v3->functions, (jstring)v5, (const unsigned __int8 *)v6);
  if ( ((int (__fastcall *)(_JNIEnv *))v3->functions->ExceptionCheck)(v3) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 103);
    v3->functions->ExceptionDescribe(&v3->functions);
  }
  return (const unsigned __int8 *)v8;
}

//----- (0026CA44) --------------------------------------------------------
unsigned int __fastcall War_HttpGetData(const unsigned __int8 *url, unsigned __int8 **intoData)
{
  _JNIEnv *CurrentJNIEnv; // r5
  _JNIEnv *v5; // r5
  int v6; // r6
  int v7; // r4
  size_t v8; // r9
  jbyte *v9; // r6
  unsigned __int8 *v10; // r0

  if ( !s_warHttp )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warHttp = (jobject_0)_JNIEnv::NewObject(CurrentJNIEnv, s_warHttp_class, s_warHttp_ctor, s_event_globalThiz);
    s_warHttp = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 49);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v5 = NVThreadGetCurrentJNIEnv();
  v6 = (int)v5->functions->NewStringUTF(&v5->functions, url);
  v7 = _JNIEnv::CallObjectMethod(v5, s_warHttp, s_warHttpGetData, v6);
  v5->functions->DeleteLocalRef(&v5->functions, (jobject)v6);
  if ( v7 )
  {
    v8 = v5->functions->GetArrayLength(&v5->functions, (jarray)v7);
    v9 = v5->functions->GetByteArrayElements(&v5->functions, (jbyteArray)v7, 0);
    v10 = (unsigned __int8 *)malloc(v8);
    *intoData = v10;
    qmemcpy(v10, v9, v8);
    v5->functions->ReleaseByteArrayElements(&v5->functions, (jbyteArray)v7, v9, 2);
  }
  else
  {
    v8 = 0;
  }
  if ( ((int (__fastcall *)(_JNIEnv *))v5->functions->ExceptionCheck)(v5) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 126);
    v5->functions->ExceptionDescribe(&v5->functions);
  }
  return v8;
}

//----- (0026CB90) --------------------------------------------------------
ANDBillingItem *__fastcall AND_BillingGetItem(const unsigned __int8 *byId)
{
  int v2; // r6
  int v3; // r5
  ANDBillingItem *i; // r4

  v2 = numItems;
  if ( numItems < 1 )
    return 0;
  v3 = 0;
  for ( i = items; strcmp((const char *)i->id->identifier, (const char *)byId); ++i )
  {
    if ( ++v3 >= v2 )
      return 0;
  }
  return i;
}

//----- (0026CBD8) --------------------------------------------------------
void __fastcall AND_ConnectionChange(bool isConnected)
{
  pthread_mutex_lock((pthread_mutex_t *)billingMutex);
  appDenied = !isConnected;
  sub_18D550((pthread_mutex_t *)billingMutex);
}

//----- (0026CC08) --------------------------------------------------------
void __fastcall AND_SkuChange(const unsigned __int8 *sku, int eventId)
{
  int v4; // r4
  int v5; // r5
  OSBillingItemChangeType *i; // r6

  v4 = numItems;
  if ( numItems >= 1 )
  {
    v5 = 0;
    for ( i = &items->eventType; strcmp(**((const char ***)i - 2), (const char *)sku); i += 3 )
    {
      if ( ++v5 >= v4 )
        return;
    }
    if ( i != (OSBillingItemChangeType *)byte_8 )
    {
      pthread_mutex_lock((pthread_mutex_t *)billingMutex);
      *((_BYTE *)i - 3) = 1;
      *i = eventId;
      sub_18D550((pthread_mutex_t *)billingMutex);
    }
  }
}

//----- (0026CC80) --------------------------------------------------------
void OS_BillingUpdate()
{
  AND_BillingUpdate(1);
}

//----- (0026CC88) --------------------------------------------------------
void __fastcall OS_BillingSubmitPurchaseIDs(OS_BillingPurchaseID *ids, int num)
{
  int v2; // r4
  ANDBillingItem *v4; // r0
  unsigned int v5; // r6
  int v6; // r3
  OS_BillingPurchaseID *v7; // r1
  char *v8; // r1
  int v9; // r8
  int i; // r6
  const unsigned __int8 *identifier; // r4
  _JNIEnv *CurrentJNIEnv; // r5
  int v13; // r4
  _JNIEnv *v14; // r0

  v2 = num;
  v4 = (ANDBillingItem *)malloc(12 * num);
  items = v4;
  numItems = v2;
  if ( v2 < 1 )
  {
    appUsesBilling = 1;
  }
  else
  {
    v5 = 0;
    do
    {
      v6 = 3 * v5;
      v7 = &ids[v5 / 4];
      --v2;
      v5 += 4;
      *(OS_BillingPurchaseID **)((char *)&v4->id + v6) = v7;
      v4 = items;
      v8 = (char *)items + v6;
      *((_DWORD *)v8 + 2) = 2;
      *((_WORD *)v8 + 2) = 0;
    }
    while ( v2 );
    appUsesBilling = 1;
    if ( numItems >= 1 )
    {
      v9 = 1;
      for ( i = 0; ; ++i )
      {
        identifier = v4[i].id->identifier;
        CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
        v13 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, identifier);
        _JNIEnv::CallVoidMethod(CurrentJNIEnv, s_event_globalThiz, s_addSku, v13);
        CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v13);
        if ( v9 >= numItems )
          break;
        v4 = items;
        ++v9;
      }
    }
  }
  v14 = NVThreadGetCurrentJNIEnv();
  sub_196F80(v14, s_event_globalThiz, s_initBilling);
}
// 6D7111: using guessed type char appUsesBilling;

//----- (0026CDB8) --------------------------------------------------------
void __fastcall WarBilling_AddSku(const unsigned __int8 *id)
{
  _JNIEnv *CurrentJNIEnv; // r5
  int v3; // r4

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v3 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, id);
  _JNIEnv::CallVoidMethod(CurrentJNIEnv, s_event_globalThiz, s_addSku, v3);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v3);
}

//----- (0026CE00) --------------------------------------------------------
bool WarBilling_InitBilling()
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  return _JNIEnv::CallBooleanMethod(CurrentJNIEnv, s_event_globalThiz, s_initBilling) != 0;
}

//----- (0026CE2C) --------------------------------------------------------
void __fastcall OS_BillingSetKey(const unsigned __int8 *key)
{
  _JNIEnv *CurrentJNIEnv; // r5
  int v3; // r4

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v3 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, key);
  _JNIEnv::CallVoidMethod(CurrentJNIEnv, s_event_globalThiz, s_setBillingKey, v3);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v3);
}

//----- (0026CE74) --------------------------------------------------------
void __fastcall WarBilling_SetBillingKey(const unsigned __int8 *key)
{
  _JNIEnv *CurrentJNIEnv; // r5
  int v3; // r4

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v3 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, key);
  _JNIEnv::CallVoidMethod(CurrentJNIEnv, s_event_globalThiz, s_setBillingKey, v3);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v3);
}

//----- (0026CEC0) --------------------------------------------------------
bool __fastcall OS_BillingPurchaseRequest(const unsigned __int8 *identifier)
{
  int v2; // r5
  int v3; // r4
  bool *p_purchased; // r6
  bool v5; // zf
  int v6; // r5
  _JNIEnv *CurrentJNIEnv; // r6
  int v8; // r4

  v2 = numItems;
  if ( numItems < 1 )
    goto LABEL_10;
  v3 = 0;
  p_purchased = &items->purchased;
  while ( strcmp(**((const char ***)p_purchased - 1), (const char *)identifier) )
  {
    ++v3;
    p_purchased += 12;
    if ( v3 >= v2 )
      goto LABEL_10;
  }
  v5 = p_purchased == (bool *)byte_4;
  if ( p_purchased != (bool *)byte_4 )
    v5 = !*p_purchased;
  if ( v5 )
  {
LABEL_10:
    LOBYTE(v6) = 0;
    if ( appUsesBilling == 1 && !appDenied )
    {
      CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
      v8 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, identifier);
      v6 = _JNIEnv::CallBooleanMethod(CurrentJNIEnv, s_event_globalThiz, s_requestPurchase, v8);
      CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v8);
      if ( v6 != 1 )
        LOBYTE(v6) = 0;
    }
  }
  else
  {
    LOBYTE(v6) = 0;
  }
  return v6;
}
// 6D7111: using guessed type char appUsesBilling;

//----- (0026CF78) --------------------------------------------------------
bool __fastcall OS_BillingIsPurchased(const unsigned __int8 *identifier)
{
  int v2; // r5
  int v3; // r4
  bool *i; // r6
  bool result; // r0

  v2 = numItems;
  if ( numItems < 1 )
    return 0;
  v3 = 0;
  for ( i = &items->purchased; strcmp(**((const char ***)i - 1), (const char *)identifier); i += 12 )
  {
    if ( ++v3 >= v2 )
      return 0;
  }
  if ( i == (bool *)&byte_4 )
    return 0;
  result = *i;
  if ( *i )
    return 1;
  return result;
}
// 4: using guessed type char byte_4;

//----- (0026CFD4) --------------------------------------------------------
bool __fastcall WarBilling_RequestPurchase(const unsigned __int8 *id)
{
  _JNIEnv *CurrentJNIEnv; // r5
  int v3; // r4
  int v4; // r6

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v3 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, id);
  v4 = _JNIEnv::CallBooleanMethod(CurrentJNIEnv, s_event_globalThiz, s_requestPurchase, v3);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v3);
  if ( v4 != 1 )
    LOBYTE(v4) = 0;
  return v4;
}

//----- (0026D02C) --------------------------------------------------------
const unsigned __int8 *__fastcall OS_BillingPurchasePrice(const unsigned __int8 *identifier)
{
  int v2; // r5
  int v3; // r4
  ANDBillingItem *i; // r6
  _JNIEnv *CurrentJNIEnv; // r5
  int v6; // r4
  int v7; // r8
  const char *v8; // r4

  if ( appUsesBilling != 1 )
    return 0;
  if ( appDenied )
    return 0;
  v2 = numItems;
  if ( numItems < 1 )
    return 0;
  v3 = 0;
  for ( i = items; strcmp((const char *)i->id->identifier, (const char *)identifier); ++i )
  {
    if ( ++v3 >= v2 )
      return 0;
  }
  if ( !i )
    return 0;
  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v6 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, identifier);
  v7 = _JNIEnv::CallObjectMethod(CurrentJNIEnv, s_event_globalThiz, s_localizedPrice, v6);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v6);
  v8 = (const char *)CurrentJNIEnv->functions->GetStringUTFChars(&CurrentJNIEnv->functions, (jstring)v7, 0);
  strcpy((char *)priceBuffer, v8);
  CurrentJNIEnv->functions->ReleaseStringUTFChars(&CurrentJNIEnv->functions, (jstring)v7, (const unsigned __int8 *)v8);
  return sub_18B670(priceBuffer);
}
// 6D7111: using guessed type char appUsesBilling;

//----- (0026D10C) --------------------------------------------------------
const unsigned __int8 *__fastcall WarBilling_LocalizedPrice(const unsigned __int8 *id)
{
  _JNIEnv *CurrentJNIEnv; // r4
  int v3; // r5
  int v4; // r8
  const char *v5; // r5

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v3 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, id);
  v4 = _JNIEnv::CallObjectMethod(CurrentJNIEnv, s_event_globalThiz, s_localizedPrice, v3);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v3);
  v5 = (const char *)CurrentJNIEnv->functions->GetStringUTFChars(&CurrentJNIEnv->functions, (jstring)v4, 0);
  strcpy((char *)priceBuffer, v5);
  CurrentJNIEnv->functions->ReleaseStringUTFChars(&CurrentJNIEnv->functions, (jstring)v4, (const unsigned __int8 *)v5);
  return priceBuffer;
}

//----- (0026D18C) --------------------------------------------------------
OSBillingConnection OS_BillingConnectionStatus()
{
  OSBillingConnection result; // r0

  if ( appUsesBilling != 1 )
    return 1;
  result = appDenied;
  if ( appDenied )
    return 2;
  return result;
}
// 6D7111: using guessed type char appUsesBilling;

//----- (0026D1B0) --------------------------------------------------------
void __fastcall AND_ClearAchievementData(bool needMutex)
{
  _BOOL4 v1; // r8
  ANDAchievementItem *v2; // r0
  int v3; // r5
  int v4; // r6

  v1 = needMutex;
  if ( needMutex )
    pthread_mutex_lock((pthread_mutex_t *)gameServiceMutex);
  v2 = achievements;
  if ( achievements )
  {
    if ( achievementCount < 1 )
    {
      operator delete[](achievements);
    }
    else
    {
      v3 = 0;
      v4 = 0;
      do
      {
        if ( v2[v3].id )
        {
          operator delete[](v2[v3].id);
          v2 = achievements;
        }
        v2[v3++].id = 0;
        ++v4;
        v2 = achievements;
      }
      while ( v4 < achievementCount );
      if ( achievements )
        operator delete[](achievements);
    }
    achievementCount = 0;
    achievements = 0;
  }
  if ( v1 )
    sub_18D550((pthread_mutex_t *)gameServiceMutex);
}

//----- (0026D28C) --------------------------------------------------------
void __fastcall AND_OnSignInChange(bool isSignedIn)
{
  pthread_mutex_lock((pthread_mutex_t *)gameServiceMutex);
  s_isSignedIn = isSignedIn;
  s_isPendingSignInChange = 1;
  sub_18D550((pthread_mutex_t *)gameServiceMutex);
}
// 6D712D: using guessed type char s_isPendingSignInChange;

//----- (0026D2C4) --------------------------------------------------------
void AND_OnSignInFailed()
{
  pthread_mutex_lock((pthread_mutex_t *)gameServiceMutex);
  s_isSignedIn = 0;
  s_isPendingSignInFailed = 1;
  sub_18D550((pthread_mutex_t *)gameServiceMutex);
}
// 6D712E: using guessed type char s_isPendingSignInFailed;

//----- (0026D2FC) --------------------------------------------------------
void LIB_GameServiceUpdate()
{
  _JNIEnv *CurrentJNIEnv; // r4
  _BOOL4 data[5]; // [sp+4h] [bp-14h] BYREF

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  pthread_mutex_lock((pthread_mutex_t *)gameServiceMutex);
  if ( s_isPendingSignInChange == 1 )
  {
    data[0] = !s_isSignedIn;
    OS_ApplicationEvent(OSET_GameServiceChange, data);
    s_isPendingSignInChange = 0;
  }
  if ( s_isPendingSignInFailed == 1 )
  {
    OS_ApplicationEvent(OSET_GameServiceSignInFailed, 0);
    s_isPendingSignInFailed = 0;
  }
  if ( s_isPendingAchievementsReadyNotification == 1 )
  {
    OS_ApplicationEvent(OSET_GameServiceAchievementsReady, 0);
    s_isPendingAchievementsReadyNotification = 0;
  }
  if ( s_isPendingLoadCompleteNotification == 1 )
  {
    OS_ApplicationEvent(OSET_GameServiceCloudLoadReady, &s_loadedData);
    if ( s_loadedData.data )
      operator delete[](s_loadedData.data);
    s_isPendingLoadCompleteNotification = 0;
  }
  if ( s_isPendingSnapshotLoadingNotification == 1 )
  {
    OS_ApplicationEvent(OSET_GameServiceSnapshotLoading, 0);
    s_isPendingSnapshotLoadingNotification = 0;
  }
  if ( s_isPendingSnapshotSelectedNotification == 1 )
  {
    OS_ApplicationEvent(OSET_GameServiceSnapshotSelected, &s_snapshotData);
    if ( s_snapshotData.data )
      operator delete[](s_snapshotData.data);
    s_isPendingSnapshotSelectedNotification = 0;
  }
  if ( s_snapshotCount >= 0 )
  {
    OS_ApplicationEvent(OSET_GameServiceSnapshotCountLoaded, &s_snapshotCount);
    s_snapshotCount = -1;
  }
  pthread_mutex_unlock((pthread_mutex_t *)gameServiceMutex);
}
// 6D712D: using guessed type char s_isPendingSignInChange;
// 6D712E: using guessed type char s_isPendingSignInFailed;
// 6D712F: using guessed type char s_isPendingAchievementsReadyNotification;
// 6D7130: using guessed type char s_isPendingLoadCompleteNotification;
// 6D7144: using guessed type char s_isPendingSnapshotLoadingNotification;
// 6D7145: using guessed type char s_isPendingSnapshotSelectedNotification;
// 26D2FC: using guessed type _BOOL4 data[5];

//----- (0026D4D4) --------------------------------------------------------
void WarGameService_EnsureInitialized()
{
  _JNIEnv *CurrentJNIEnv; // r4

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
}

//----- (0026D574) --------------------------------------------------------
void WarGameService_ShowSignInUI()
{
  _JNIEnv *CurrentJNIEnv; // r4
  _JNIEnv *v1; // r4

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v1 = NVThreadGetCurrentJNIEnv();
  _JNIEnv::CallVoidMethod(v1, s_warGameService, s_showSignInUI);
  if ( ((int (__fastcall *)(_JNIEnv *))v1->functions->ExceptionCheck)(v1) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 285);
    v1->functions->ExceptionDescribe(&v1->functions);
  }
}

//----- (0026D65C) --------------------------------------------------------
void LIB_GameServiceSignOut()
{
  WarGameService_SignOut();
  AND_ClearAchievementData(1);
}

//----- (0026D66C) --------------------------------------------------------
void WarGameService_SignOut()
{
  _JNIEnv *CurrentJNIEnv; // r4
  _JNIEnv *v1; // r4

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v1 = NVThreadGetCurrentJNIEnv();
  _JNIEnv::CallVoidMethod(v1, s_warGameService, s_signOut);
  if ( ((int (__fastcall *)(_JNIEnv *))v1->functions->ExceptionCheck)(v1) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 294);
    v1->functions->ExceptionDescribe(&v1->functions);
  }
}

//----- (0026D758) --------------------------------------------------------
int WarGameService_GameServiceExists()
{
  _JNIEnv *CurrentJNIEnv; // r4
  _JNIEnv *v1; // r4
  int v2; // r5

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v1 = NVThreadGetCurrentJNIEnv();
  v2 = _JNIEnv::CallBooleanMethod(v1, s_warGameService, s_GameServiceExists);
  if ( ((int (__fastcall *)(_JNIEnv *))v1->functions->ExceptionCheck)(v1) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 315);
    v1->functions->ExceptionDescribe(&v1->functions);
  }
  if ( v2 != 1 )
    return 0;
  return v2;
}

//----- (0026D848) --------------------------------------------------------
int WarGameService_GetConnectionStatus()
{
  _JNIEnv *CurrentJNIEnv; // r4
  _JNIEnv *v1; // r4
  int v2; // r5

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v1 = NVThreadGetCurrentJNIEnv();
  v2 = _JNIEnv::CallBooleanMethod(v1, s_warGameService, s_getConnectionStatus);
  if ( ((int (__fastcall *)(_JNIEnv *))v1->functions->ExceptionCheck)(v1) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 304);
    v1->functions->ExceptionDescribe(&v1->functions);
  }
  if ( v2 != 1 )
    return 0;
  return v2;
}

//----- (0026D934) --------------------------------------------------------
ANDAchievementItem *__fastcall AND_GameServiceGetAchievement(const unsigned __int8 *const id)
{
  int v2; // r6
  int v3; // r5
  ANDAchievementItem *i; // r4

  v2 = achievementCount;
  if ( achievementCount < 1 )
    return 0;
  v3 = 0;
  for ( i = achievements; strcmp((const char *)id, (const char *)i->id); ++i )
  {
    if ( ++v3 >= v2 )
      return 0;
  }
  return i;
}

//----- (0026D97C) --------------------------------------------------------
void WarGameService_ShowAchievementList()
{
  _JNIEnv *CurrentJNIEnv; // r4
  _JNIEnv *v1; // r4

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v1 = NVThreadGetCurrentJNIEnv();
  _JNIEnv::CallVoidMethod(v1, s_warGameService, s_showAchievementList);
  if ( ((int (__fastcall *)(_JNIEnv *))v1->functions->ExceptionCheck)(v1) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 337);
    v1->functions->ExceptionDescribe(&v1->functions);
  }
}

//----- (0026DA64) --------------------------------------------------------
void __fastcall LIB_GameServiceUnlockAchievement(const unsigned __int8 *const id)
{
  ANDAchievementItem *v2; // r5
  int v3; // r6
  int v4; // r4

  pthread_mutex_lock((pthread_mutex_t *)gameServiceMutex);
  v2 = achievements;
  if ( achievements )
  {
    v3 = achievementCount;
    if ( achievementCount >= 1 )
    {
      v4 = 0;
      while ( strcmp((const char *)id, (const char *)v2->id) )
      {
        ++v4;
        ++v2;
        if ( v4 >= v3 )
          goto LABEL_8;
      }
      WarGameService_UnlockAchievement(id);
    }
  }
LABEL_8:
  sub_18D550((pthread_mutex_t *)gameServiceMutex);
}

//----- (0026DAD0) --------------------------------------------------------
void __fastcall WarGameService_UnlockAchievement(const unsigned __int8 *const id)
{
  _JNIEnv *CurrentJNIEnv; // r5
  _JNIEnv *v3; // r5
  int v4; // r4

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v3 = NVThreadGetCurrentJNIEnv();
  v4 = (int)v3->functions->NewStringUTF(&v3->functions, id);
  _JNIEnv::CallVoidMethod(v3, s_warGameService, s_unlockAchievement, v4);
  v3->functions->DeleteLocalRef(&v3->functions, (jobject)v4);
  if ( ((int (__fastcall *)(_JNIEnv *))v3->functions->ExceptionCheck)(v3) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 348);
    v3->functions->ExceptionDescribe(&v3->functions);
  }
}

//----- (0026DBD8) --------------------------------------------------------
bool __fastcall LIB_GameServiceIsAchievementUnlocked(const unsigned __int8 *const id)
{
  int v2; // r5
  int v3; // r4
  bool *p_unlockState; // r6
  char v5; // r4

  pthread_mutex_lock((pthread_mutex_t *)gameServiceMutex);
  v2 = achievementCount;
  if ( achievementCount < 1 )
    goto LABEL_10;
  v3 = 0;
  p_unlockState = &achievements->unlockState;
  while ( strcmp((const char *)id, *((const char **)p_unlockState - 1)) )
  {
    ++v3;
    p_unlockState += 16;
    if ( v3 >= v2 )
      goto LABEL_10;
  }
  if ( p_unlockState == (bool *)&byte_4 )
  {
LABEL_10:
    v5 = 0;
  }
  else
  {
    v5 = *p_unlockState;
    if ( *p_unlockState )
      v5 = 1;
  }
  pthread_mutex_unlock((pthread_mutex_t *)gameServiceMutex);
  return v5;
}
// 4: using guessed type char byte_4;

//----- (0026DC50) --------------------------------------------------------
void __fastcall LIB_GameServiceIncrementAchievement(const unsigned __int8 *const id, int numSteps)
{
  int v4; // r4
  int *p_currentSteps; // r6
  int v6; // r5
  __int64 v7; // r0

  pthread_mutex_lock((pthread_mutex_t *)gameServiceMutex);
  if ( achievements )
  {
    v4 = achievementCount;
    if ( achievementCount >= 1 )
    {
      p_currentSteps = &achievements->currentSteps;
      v6 = 0;
      while ( strcmp((const char *)id, (const char *)*(p_currentSteps - 2)) )
      {
        ++v6;
        p_currentSteps += 4;
        if ( v6 >= v4 )
          goto LABEL_10;
      }
      WarGameService_IncrementAchievement(id, numSteps);
      v7 = *(_QWORD *)p_currentSteps;
      if ( *p_currentSteps + numSteps < p_currentSteps[1] )
        HIDWORD(v7) = *p_currentSteps + numSteps;
      *p_currentSteps = HIDWORD(v7);
      WarGameService_RefreshData(0);
    }
  }
LABEL_10:
  sub_18D550((pthread_mutex_t *)gameServiceMutex);
}

//----- (0026DCDC) --------------------------------------------------------
void __fastcall WarGameService_IncrementAchievement(const unsigned __int8 *const id, int numSteps)
{
  _JNIEnv *CurrentJNIEnv; // r6
  _JNIEnv *v5; // r6
  int v6; // r5

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v5 = NVThreadGetCurrentJNIEnv();
  v6 = (int)v5->functions->NewStringUTF(&v5->functions, id);
  _JNIEnv::CallVoidMethod(v5, s_warGameService, s_incrementAchievement, v6, numSteps);
  v5->functions->DeleteLocalRef(&v5->functions, (jobject)v6);
  if ( ((int (__fastcall *)(_JNIEnv *))v5->functions->ExceptionCheck)(v5) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 359);
    v5->functions->ExceptionDescribe(&v5->functions);
  }
}

//----- (0026DDF4) --------------------------------------------------------
int __fastcall LIB_GameServiceGetAchievementCurrentSteps(const unsigned __int8 *const id)
{
  int v2; // r5
  int v3; // r4
  int *p_currentSteps; // r6
  int v5; // r4

  pthread_mutex_lock((pthread_mutex_t *)gameServiceMutex);
  v2 = achievementCount;
  if ( achievementCount < 1 )
  {
LABEL_5:
    v5 = -1;
  }
  else
  {
    v3 = 0;
    p_currentSteps = &achievements->currentSteps;
    while ( strcmp((const char *)id, (const char *)*(p_currentSteps - 2)) )
    {
      ++v3;
      p_currentSteps += 4;
      if ( v3 >= v2 )
        goto LABEL_5;
    }
    if ( p_currentSteps == (int *)byte_8 )
      v5 = -1;
    else
      v5 = *p_currentSteps;
  }
  pthread_mutex_unlock((pthread_mutex_t *)gameServiceMutex);
  return v5;
}

//----- (0026DE6C) --------------------------------------------------------
int __fastcall LIB_GameServiceGetAchievementTotalSteps(const unsigned __int8 *const id)
{
  int v2; // r5
  int v3; // r4
  int *p_totalSteps; // r6
  int v5; // r4

  pthread_mutex_lock((pthread_mutex_t *)gameServiceMutex);
  v2 = achievementCount;
  if ( achievementCount < 1 )
  {
LABEL_5:
    v5 = -1;
  }
  else
  {
    v3 = 0;
    p_totalSteps = &achievements->totalSteps;
    while ( strcmp((const char *)id, (const char *)*(p_totalSteps - 3)) )
    {
      ++v3;
      p_totalSteps += 4;
      if ( v3 >= v2 )
        goto LABEL_5;
    }
    if ( p_totalSteps == (int *)&byte_9[3] )
      v5 = -1;
    else
      v5 = *p_totalSteps;
  }
  pthread_mutex_unlock((pthread_mutex_t *)gameServiceMutex);
  return v5;
}

//----- (0026DEE4) --------------------------------------------------------
void __fastcall AND_OnAchievementsLoaded(
        int count,
        const unsigned __int8 **ids,
        bool *unlockState,
        int *currentSteps,
        int a5)
{
  int v9; // r10
  ANDAchievementItem *v10; // r0
  int v11; // r10
  int v12; // r8
  unsigned int v13; // r0
  int v14; // r2
  ANDAchievementItem *v15; // r6
  int v16; // r5
  size_t v17; // r0
  bool v18; // t1
  ANDAchievementItem *v19; // r1
  int v20; // r0
  int *v21; // [sp+4h] [bp-24h]

  pthread_mutex_lock((pthread_mutex_t *)gameServiceMutex);
  v9 = a5;
  v10 = achievements;
  if ( achievements )
  {
    if ( achievementCount < 1 )
    {
      operator delete[](achievements);
    }
    else
    {
      v21 = currentSteps;
      v11 = 0;
      v12 = 0;
      do
      {
        if ( v10[v11].id )
        {
          operator delete[](v10[v11].id);
          v10 = achievements;
        }
        ++v12;
        v10[v11++].id = 0;
        v10 = achievements;
      }
      while ( v12 < achievementCount );
      v9 = a5;
      currentSteps = v21;
      if ( achievements )
        operator delete[](achievements);
    }
    achievementCount = 0;
    achievements = 0;
  }
  v14 = (unsigned __int64)(unsigned int)count >> 28;
  v13 = 16 * count;
  achievementCount = count;
  if ( !is_mul_ok(0x10u, count) )
    v14 = 1;
  if ( v14 )
    v13 = -1;
  v15 = (ANDAchievementItem *)operator new[](v13);
  achievements = v15;
  if ( count >= 1 )
  {
    v16 = 0;
    do
    {
      v17 = strlen((const char *)ids[v16]);
      v15[v16].id = (unsigned __int8 *)operator new[](v17 + 1);
      strcpy((char *)achievements[v16].id, (const char *)ids[v16]);
      v15 = achievements;
      --count;
      v18 = *unlockState++;
      v19 = &achievements[v16];
      v19->unlockState = v18;
      v19->currentSteps = currentSteps[v16];
      v20 = *(_DWORD *)(v9 + v16 * 4);
      ++v16;
      v19->totalSteps = v20;
    }
    while ( count );
  }
  s_isPendingAchievementsReadyNotification = 1;
  sub_18D550((pthread_mutex_t *)gameServiceMutex);
}
// 6D712F: using guessed type char s_isPendingAchievementsReadyNotification;

//----- (0026E054) --------------------------------------------------------
void __fastcall WarGameService_RefreshData(bool forceReload)
{
  _BOOL4 v1; // r9
  _JNIEnv *CurrentJNIEnv; // r5
  _JNIEnv *v3; // r5

  v1 = forceReload;
  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v3 = NVThreadGetCurrentJNIEnv();
  _JNIEnv::CallVoidMethod(v3, s_warGameService, s_refreshData, v1);
  if ( ((int (__fastcall *)(_JNIEnv *))v3->functions->ExceptionCheck)(v3) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 325);
    v3->functions->ExceptionDescribe(&v3->functions);
  }
}

//----- (0026E144) --------------------------------------------------------
void WarGameService_ShowLeaderboards()
{
  _JNIEnv *CurrentJNIEnv; // r4
  _JNIEnv *v1; // r4

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v1 = NVThreadGetCurrentJNIEnv();
  _JNIEnv::CallVoidMethod(v1, s_warGameService, s_showLeaderboards);
  if ( ((int (__fastcall *)(_JNIEnv *))v1->functions->ExceptionCheck)(v1) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 372);
    v1->functions->ExceptionDescribe(&v1->functions);
  }
}

//----- (0026E230) --------------------------------------------------------
void __fastcall WarGameService_ShowLeaderboard(const unsigned __int8 *const id)
{
  _JNIEnv *CurrentJNIEnv; // r5
  _JNIEnv *v3; // r5
  int v4; // r4

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v3 = NVThreadGetCurrentJNIEnv();
  v4 = (int)v3->functions->NewStringUTF(&v3->functions, id);
  _JNIEnv::CallVoidMethod(v3, s_warGameService, s_showLeaderboard, v4);
  v3->functions->DeleteLocalRef(&v3->functions, (jobject)v4);
  if ( ((int (__fastcall *)(_JNIEnv *))v3->functions->ExceptionCheck)(v3) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 383);
    v3->functions->ExceptionDescribe(&v3->functions);
  }
}

//----- (0026E33C) --------------------------------------------------------
int __fastcall WarGameService_SubmitScore(const unsigned __int8 *a1, int a2, int a3, int a4)
{
  _JNIEnv *CurrentJNIEnv; // r4
  _JNIEnv *v8; // r4
  int v9; // r6
  int result; // r0

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v8 = NVThreadGetCurrentJNIEnv();
  v9 = (int)v8->functions->NewStringUTF(&v8->functions, a1);
  _JNIEnv::CallVoidMethod(v8, s_warGameService, s_submitScore, v9, a3, a4);
  v8->functions->DeleteLocalRef(&v8->functions, (jobject)v9);
  result = ((int (__fastcall *)(_JNIEnv *))v8->functions->ExceptionCheck)(v8);
  if ( result )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 395);
    return ((int (__fastcall *)(_JNIEnv *))v8->functions->ExceptionDescribe)(v8);
  }
  return result;
}

//----- (0026E454) --------------------------------------------------------
void __fastcall WarGameService_SaveToCloud(const unsigned __int8 *data, int sizeInBytes)
{
  _JNIEnv *CurrentJNIEnv; // r6
  _JNIEnv *v5; // r6
  int v6; // r5

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v5 = NVThreadGetCurrentJNIEnv();
  v6 = (int)v5->functions->NewByteArray(&v5->functions, sizeInBytes);
  v5->functions->SetByteArrayRegion(&v5->functions, (jbyteArray)v6, 0, sizeInBytes, (const jbyte *)data);
  _JNIEnv::CallVoidMethod(v5, s_warGameService, s_saveToCloud, v6);
  v5->functions->DeleteLocalRef(&v5->functions, (jobject)v6);
  if ( ((int (__fastcall *)(_JNIEnv *))v5->functions->ExceptionCheck)(v5) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 434);
    v5->functions->ExceptionDescribe(&v5->functions);
  }
}

//----- (0026E580) --------------------------------------------------------
void WarGameService_LoadFromCloud()
{
  _JNIEnv *CurrentJNIEnv; // r4
  _JNIEnv *v1; // r4

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v1 = NVThreadGetCurrentJNIEnv();
  _JNIEnv::CallVoidMethod(v1, s_warGameService, s_loadFromCloud);
  if ( ((int (__fastcall *)(_JNIEnv *))v1->functions->ExceptionCheck)(v1) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 444);
    v1->functions->ExceptionDescribe(&v1->functions);
  }
}

//----- (0026E668) --------------------------------------------------------
void __fastcall LIB_GameServiceSetConflictHandler(LIB_GameServiceConflictHandler *handler)
{
  s_conflictHandler = handler;
}

//----- (0026E674) --------------------------------------------------------
void __fastcall AND_OnStateConflict(
        unsigned __int8 *local,
        int localNumBytes,
        unsigned __int8 *remote,
        int remoteNumBytes,
        unsigned __int8 **result,
        int *resultNumBytes)
{
  s_conflictHandler(local, localNumBytes, remote, remoteNumBytes, result, resultNumBytes);
}

//----- (0026E684) --------------------------------------------------------
void __fastcall AND_OnStateLoaded(LIB_CloudLoadResultStatus status, unsigned __int8 *data, int numBytes)
{
  if ( status == CLRS_SUCCESS )
  {
    pthread_mutex_lock((pthread_mutex_t *)gameServiceMutex);
    if ( s_isPendingLoadCompleteNotification == 1 )
    {
      if ( s_loadedData.data )
        operator delete[](s_loadedData.data);
    }
    s_loadedData.status = CLRS_SUCCESS;
    s_loadedData.key = 0;
    s_loadedData.data = data;
    s_loadedData.dataLength = numBytes;
    s_isPendingLoadCompleteNotification = 1;
    sub_18D550((pthread_mutex_t *)gameServiceMutex);
  }
}
// 6D7130: using guessed type char s_isPendingLoadCompleteNotification;

//----- (0026E6F8) --------------------------------------------------------
void __fastcall WarGameService_SaveSnapshot(
        const unsigned __int8 *const name,
        const unsigned __int8 *const description,
        const unsigned __int8 *const data,
        int dataLength,
        int a5)
{
  _JNIEnv *CurrentJNIEnv; // r5
  _JNIEnv *v9; // r5
  int v10; // r10
  int v11; // r8
  int v12; // r6

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v9 = NVThreadGetCurrentJNIEnv();
  v10 = (int)v9->functions->NewStringUTF(&v9->functions, name);
  v11 = (int)v9->functions->NewStringUTF(&v9->functions, description);
  v12 = (int)v9->functions->NewByteArray(&v9->functions, dataLength);
  v9->functions->SetByteArrayRegion(&v9->functions, (jbyteArray)v12, 0, dataLength, (const jbyte *)data);
  _JNIEnv::CallVoidMethod(v9, s_warGameService, s_saveSnapshot, v10, v11, v12, (__int64)a5);
  if ( ((int (__fastcall *)(_JNIEnv *))v9->functions->ExceptionCheck)(v9) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 599);
    v9->functions->ExceptionDescribe(&v9->functions);
  }
  v9->functions->DeleteLocalRef(&v9->functions, (jobject)v12);
  v9->functions->DeleteLocalRef(&v9->functions, (jobject)v10);
  v9->functions->DeleteLocalRef(&v9->functions, (jobject)v11);
}

//----- (0026E868) --------------------------------------------------------
void WarGameService_ShowSnapshotList()
{
  _JNIEnv *CurrentJNIEnv; // r4
  _JNIEnv *v1; // r4

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v1 = NVThreadGetCurrentJNIEnv();
  _JNIEnv::CallVoidMethod(v1, s_warGameService, s_showSnapshotList);
  if ( ((int (__fastcall *)(_JNIEnv *))v1->functions->ExceptionCheck)(v1) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 575);
    v1->functions->ExceptionDescribe(&v1->functions);
  }
}

//----- (0026E954) --------------------------------------------------------
void WarGameService_LoadSnapshot()
{
  _JNIEnv *CurrentJNIEnv; // r4
  _JNIEnv *v1; // r4

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v1 = NVThreadGetCurrentJNIEnv();
  _JNIEnv::CallVoidMethod(v1, s_warGameService, s_loadSnapshot);
  if ( ((int (__fastcall *)(_JNIEnv *))v1->functions->ExceptionCheck)(v1) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 584);
    v1->functions->ExceptionDescribe(&v1->functions);
  }
}

//----- (0026EA40) --------------------------------------------------------
void WarGameService_LoadSnapshotCount()
{
  _JNIEnv *CurrentJNIEnv; // r4
  _JNIEnv *v1; // r4

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v1 = NVThreadGetCurrentJNIEnv();
  _JNIEnv::CallVoidMethod(v1, s_warGameService, s_loadSnapshotCount);
  if ( ((int (__fastcall *)(_JNIEnv *))v1->functions->ExceptionCheck)(v1) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 613);
    v1->functions->ExceptionDescribe(&v1->functions);
  }
}

//----- (0026EB2C) --------------------------------------------------------
void __fastcall WarGameService_DeleteSnapshot(const unsigned __int8 *const name)
{
  _JNIEnv *CurrentJNIEnv; // r5
  _JNIEnv *v3; // r5
  int v4; // r4

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v3 = NVThreadGetCurrentJNIEnv();
  v4 = (int)v3->functions->NewStringUTF(&v3->functions, name);
  _JNIEnv::CallVoidMethod(v3, s_warGameService, s_deleteSnapshot, v4);
  if ( ((int (__fastcall *)(_JNIEnv *))v3->functions->ExceptionCheck)(v3) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 623);
    v3->functions->ExceptionDescribe(&v3->functions);
  }
  v3->functions->DeleteLocalRef(&v3->functions, (jobject)v4);
}

//----- (0026EC30) --------------------------------------------------------
void WarGameService_DeleteAllSnapshots()
{
  _JNIEnv *CurrentJNIEnv; // r4
  _JNIEnv *v1; // r4

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v1 = NVThreadGetCurrentJNIEnv();
  _JNIEnv::CallVoidMethod(v1, s_warGameService, s_deleteAllSnapshots);
  if ( ((int (__fastcall *)(_JNIEnv *))v1->functions->ExceptionCheck)(v1) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 634);
    v1->functions->ExceptionDescribe(&v1->functions);
  }
}

//----- (0026ED18) --------------------------------------------------------
void AND_OnSnapshotLoading()
{
  s_isPendingSnapshotLoadingNotification = 1;
}
// 6D7144: using guessed type char s_isPendingSnapshotLoadingNotification;

//----- (0026ED28) --------------------------------------------------------
void __fastcall AND_OnSnapshotSelected(unsigned __int8 *data, int numBytes)
{
  char v4; // r3

  pthread_mutex_lock((pthread_mutex_t *)gameServiceMutex);
  if ( s_isPendingSnapshotSelectedNotification == 1 && s_snapshotData.data )
    operator delete[](s_snapshotData.data);
  v4 = (char)data;
  s_snapshotData.data = data;
  if ( data )
    v4 = 1;
  s_snapshotData.success = v4;
  if ( !data )
    numBytes = 0;
  s_snapshotData.dataLength = numBytes;
  s_isPendingSnapshotSelectedNotification = 1;
  sub_18D550((pthread_mutex_t *)gameServiceMutex);
}
// 6D7145: using guessed type char s_isPendingSnapshotSelectedNotification;

//----- (0026ED9C) --------------------------------------------------------
void __fastcall AND_OnSnapshotCountLoaded(int count)
{
  pthread_mutex_lock((pthread_mutex_t *)gameServiceMutex);
  s_snapshotCount = count;
  sub_18D550((pthread_mutex_t *)gameServiceMutex);
}

//----- (0026EDC8) --------------------------------------------------------
void __fastcall AND_OnLeaderboardQuery(int queryId, int count, float *scores, const unsigned __int8 **names)
{
  int *v8; // r4
  int v9; // r0
  unsigned int v10; // r9
  float *v11; // r10
  int v12; // r6
  unsigned int numEntries; // r5
  unsigned int v14; // r9
  LeaderboardQuerySt **dataPtr; // r8
  LeaderboardQuerySt **v16; // r6

  pthread_mutex_lock((pthread_mutex_t *)gameServiceMutex);
  v8 = (int *)operator new(0x10u);
  *v8 = queryId;
  v8[1] = count;
  v8[2] = 0;
  v8[3] = 0;
  if ( count >= 1 )
  {
    v9 = (unsigned __int64)(unsigned int)count >> 30;
    v10 = 4 * count;
    if ( !is_mul_ok(4u, count) )
      v9 = 1;
    if ( v9 )
      v10 = -1;
    v11 = (float *)operator new[](v10);
    v8[2] = (int)v11;
    v8[3] = operator new[](v10);
    *v11 = *scores;
    *(_DWORD *)v8[3] = j_strdup(*names);
    if ( count != 1 )
    {
      v12 = 1;
      do
      {
        *(float *)(v8[2] + 4 * v12) = scores[v12];
        *(_DWORD *)(v8[3] + 4 * v12) = j_strdup(names[v12]);
        ++v12;
      }
      while ( count != v12 );
    }
  }
  numEntries = queries.numEntries;
  if ( queries.numAlloced >= queries.numEntries + 1 )
  {
    dataPtr = queries.dataPtr;
  }
  else
  {
    v14 = 4 * (queries.numEntries + 1) / 3 + 3;
    dataPtr = (LeaderboardQuerySt **)malloc(4 * v14);
    v16 = queries.dataPtr;
    if ( queries.dataPtr )
    {
      qmemcpy(dataPtr, queries.dataPtr, 4 * numEntries);
      free(v16);
      numEntries = queries.numEntries;
    }
    queries.dataPtr = dataPtr;
    queries.numAlloced = v14;
  }
  dataPtr[numEntries] = (LeaderboardQuerySt *)v8;
  ++queries.numEntries;
  sub_18D550((pthread_mutex_t *)gameServiceMutex);
}

//----- (0026EF14) --------------------------------------------------------
void __fastcall WarGameService_CancelLeaderboardQuery(int queryId)
{
  _JNIEnv *CurrentJNIEnv; // r5
  _JNIEnv *v3; // r5

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v3 = NVThreadGetCurrentJNIEnv();
  _JNIEnv::CallVoidMethod(v3, s_warGameService, s_CancelLeaderboardQueryMethod, queryId);
  if ( ((int (__fastcall *)(_JNIEnv *))v3->functions->ExceptionCheck)(v3) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 418);
    v3->functions->ExceptionDescribe(&v3->functions);
  }
}

//----- (0026F000) --------------------------------------------------------
void __fastcall LIB_GameServiceSubmitLeaderboardQuery(
        const unsigned __int8 *lbName,
        int numResults,
        int startIndex,
        int queryID,
        int showFriends,
        int sortAscending)
{
  WarGameService_SubmitLeaderboardQuery(lbName, numResults, startIndex, queryID, showFriends, sortAscending);
}

//----- (0026F018) --------------------------------------------------------
void __fastcall WarGameService_SubmitLeaderboardQuery(
        const unsigned __int8 *lbName,
        int numResults,
        int startIndex,
        int queryID,
        int a5,
        int a6)
{
  int v7; // r10
  int v8; // r11
  int v10; // r8
  _JNIEnv *CurrentJNIEnv; // r5
  _JNIEnv *v13; // r5
  int v14; // r4

  v7 = a6;
  v8 = a5;
  v10 = startIndex;
  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    v7 = a6;
    v10 = startIndex;
    v8 = a5;
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v13 = NVThreadGetCurrentJNIEnv();
  v14 = (int)v13->functions->NewStringUTF(&v13->functions, lbName);
  _JNIEnv::CallVoidMethod(v13, s_warGameService, s_SubmitLeaderboardQueryMethod, v14, numResults, v10, queryID, v8, v7);
  v13->functions->DeleteLocalRef(&v13->functions, (jobject)v14);
  if ( ((int (__fastcall *)(_JNIEnv *))v13->functions->ExceptionCheck)(v13) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 409);
    v13->functions->ExceptionDescribe(&v13->functions);
  }
}

//----- (0026F15C) --------------------------------------------------------
bool __fastcall LIB_LeaderboardQueryFinished(int queryId, LeaderboardQuerySt **lbQuery)
{
  unsigned int v4; // r6
  unsigned int v5; // r4
  LeaderboardQuerySt **dataPtr; // r10
  LeaderboardQuerySt *v7; // r1
  bool v8; // r4
  LeaderboardQuerySt *v9; // r5
  LeaderboardQuerySt **v10; // r0
  __int64 v11; // r0
  unsigned int count; // kr00_4
  float *v13; // r0
  __int64 v14; // r0
  LeaderboardQuerySt *v15; // r0
  int v16; // r5

  pthread_mutex_lock((pthread_mutex_t *)gameServiceMutex);
  if ( queries.numEntries )
  {
    v4 = 0;
    v5 = 0;
    dataPtr = queries.dataPtr;
    while ( 1 )
    {
      v7 = queries.dataPtr[v5];
      if ( v7->queryId == queryId )
        break;
      ++v5;
      v4 -= 4;
      if ( v5 >= queries.numEntries )
        goto LABEL_5;
    }
    if ( v7->count >= 1 )
    {
      v9 = (LeaderboardQuerySt *)operator new(0x10u);
      v9->count = 0;
      v9->scores = 0;
      v9->names = 0;
      *lbQuery = v9;
      v10 = queries.dataPtr;
      v9->count = queries.dataPtr[v5]->count;
      count = v10[v5]->count;
      v11 = 4LL * count;
      if ( !is_mul_ok(4u, count) )
        HIDWORD(v11) = 1;
      if ( HIDWORD(v11) )
        LODWORD(v11) = -1;
      v13 = (float *)operator new[](v11);
      dataPtr = queries.dataPtr;
      v9->scores = v13;
      v14 = 4LL * (unsigned int)dataPtr[v5]->count;
      if ( !is_mul_ok(dataPtr[v5]->count, 4u) )
        HIDWORD(v14) = 1;
      if ( HIDWORD(v14) )
        LODWORD(v14) = -1;
      (*lbQuery)->names = (const unsigned __int8 **)operator new[](v14);
      v15 = dataPtr[v5];
      if ( v15->count >= 1 )
      {
        v16 = 0;
        do
        {
          (*lbQuery)->scores[v16] = v15->scores[v16];
          (*lbQuery)->names[v16] = j_strdup(queries.dataPtr[v5]->names[v16]);
          ++v16;
          dataPtr = queries.dataPtr;
          v15 = queries.dataPtr[v5];
        }
        while ( v16 < v15->count );
      }
    }
    memmove(&dataPtr[v4 / 0xFFFFFFFC], &dataPtr[v4 / 0xFFFFFFFC + 1], v4 + 4 * queries.numEntries-- - 4);
    v8 = 1;
  }
  else
  {
LABEL_5:
    v8 = 0;
  }
  pthread_mutex_unlock((pthread_mutex_t *)gameServiceMutex);
  return v8;
}

//----- (0026F2C0) --------------------------------------------------------
void __fastcall WarGameService_SaveScreenshot(const unsigned __int8 *const screenshot, int screenshotLength)
{
  _JNIEnv *CurrentJNIEnv; // r5
  _JNIEnv *v5; // r6
  int v6; // r5

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v5 = NVThreadGetCurrentJNIEnv();
  v6 = (int)v5->functions->NewByteArray(&v5->functions, screenshotLength);
  v5->functions->SetByteArrayRegion(&v5->functions, (jbyteArray)v6, 0, screenshotLength, (const jbyte *)screenshot);
  _JNIEnv::CallVoidMethod(v5, s_warGameService, s_saveScreenshot, v6);
  if ( ((int (__fastcall *)(_JNIEnv *))v5->functions->ExceptionCheck)(v5) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 713);
    v5->functions->ExceptionDescribe(&v5->functions);
  }
  v5->functions->DeleteLocalRef(&v5->functions, (jobject)v6);
}

//----- (0026F3E0) --------------------------------------------------------
bool LIB_ScreenshotIsDone()
{
  return ScreenshotIsDone;
}

//----- (0026F3F0) --------------------------------------------------------
void __fastcall LIB_ScreenshotIsDone(bool value)
{
  ScreenshotIsDone = value;
}

//----- (0026F404) --------------------------------------------------------
const char *WarGameService_GetPlayerName()
{
  _JNIEnv *CurrentJNIEnv; // r4
  _JNIEnv *v1; // r4
  int v2; // r0
  void *v3; // r6
  const char *v4; // r9
  size_t v5; // r5
  char *v6; // r8

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v1 = NVThreadGetCurrentJNIEnv();
  v2 = _JNIEnv::CallObjectMethod(v1, s_warGameService, s_getPlayerName);
  v3 = (void *)v2;
  if ( !v2 )
    return "default";
  v4 = (const char *)v1->functions->GetStringUTFChars(&v1->functions, (jstring)v2, 0);
  v5 = strlen(v4) + 1;
  v6 = (char *)malloc(v5);
  strncpy(v6, v4, v5);
  v1->functions->ReleaseStringUTFChars(&v1->functions, v3, (const unsigned __int8 *)v4);
  if ( ((int (__fastcall *)(_JNIEnv *))v1->functions->ExceptionCheck)(v1) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 737);
    v1->functions->ExceptionDescribe(&v1->functions);
  }
  return v6;
}

//----- (0026F52C) --------------------------------------------------------
int __fastcall ZIPFile::EntryCompare(const void *e1, const void *e2)
{
  return sub_191ECC(*((const char **)e1 + 2), *((const char **)e2 + 2));
}

//----- (0026F534) --------------------------------------------------------
void __fastcall ZIPFile::SortEntries(ZIPFile *this)
{
  unsigned int numEntries; // r9
  ZIPFile::ZipEntry *dataPtr; // r8
  unsigned int v3; // r4
  const char **p_filename; // r5
  const char *filename; // r0
  const char *v6; // r6

  numEntries = this->entries.numEntries;
  if ( numEntries >= 2 )
  {
    dataPtr = this->entries.dataPtr;
    v3 = 1;
    p_filename = (const char **)&dataPtr[1].filename;
    filename = (const char *)dataPtr->filename;
    while ( 1 )
    {
      v6 = *p_filename;
      if ( strcasecmp(filename, *p_filename) >= 1 )
        break;
      ++v3;
      p_filename += 3;
      filename = v6;
      if ( v3 >= numEntries )
        return;
    }
    sub_197718(dataPtr, numEntries, 0xCu, ZIPFile::EntryCompare);
  }
}

//----- (0026F58C) --------------------------------------------------------
void __fastcall ZIPFile::~ZIPFile(ZIPFile *this)
{
  unsigned __int8 *pooledName; // r0
  unsigned int *p_numEntries; // r8
  unsigned int v4; // r6
  int v5; // r5
  ZIPFile::ZipEntry *dataPtr; // r0

  pooledName = this->pooledName;
  this->_vptr$ZIPFile = (int (**)(void))&off_661E28;
  if ( pooledName )
  {
    free(pooledName);
    p_numEntries = &this->entries.numEntries;
    this->pooledName = 0;
  }
  else
  {
    p_numEntries = &this->entries.numEntries;
    if ( this->entries.numEntries )
    {
      v4 = 0;
      v5 = 8;
      do
      {
        free(*(void **)((char *)&this->entries.dataPtr->offset + v5));
        ++v4;
        v5 += 12;
      }
      while ( v4 < this->entries.numEntries );
    }
  }
  *p_numEntries = 0;
  dataPtr = this->entries.dataPtr;
  if ( dataPtr )
  {
    free(dataPtr);
    this->entries.dataPtr = 0;
  }
  this->entries.numAlloced = 0;
}
// 661E28: using guessed type void *;

//----- (0026F5F8) --------------------------------------------------------
bool __fastcall ZIPFile::Initialize(ZIPFile *this, const unsigned __int8 *withFilename)
{
  bool v4; // r5
  OSFile v5; // r6
  char *v6; // r10
  int v7; // r0
  char *v8; // r2
  unsigned int v9; // r4
  int v10; // r0
  bool v11; // zf
  OSFile v12; // r10
  unsigned __int8 *v13; // r2
  unsigned int v14; // r11
  unsigned int v15; // r0
  ZIPFile::ZipEntry *v16; // r0
  ZIPFile::ZipEntry *v17; // r8
  ZIPFile::ZipEntry *dataPtr; // r5
  ZIPFile::ZipEntry *v19; // r0
  OSArray<ZIPFile::ZipEntry> *p_entries; // r0
  unsigned int *p_numEntries; // r5
  OSFile v22; // r11
  int v23; // r8
  double v24; // d17
  unsigned int v25; // r4
  size_t numAlloced; // r11
  ZIPFile::ZipEntry *v27; // r0
  ZIPFile::ZipEntry *v28; // r6
  ZIPFile::ZipEntry *v29; // r8
  ZIPFile::ZipEntry *v30; // r8
  unsigned int v31; // r5
  const char **p_filename; // r4
  const char *filename; // r0
  const char *v34; // r6
  unsigned int *v35; // r4
  unsigned int v36; // r0
  char *v37; // r4
  signed int v38; // r10
  unsigned int v39; // t1
  ZIPFile::ZipEntry *v40; // r0
  ZIPFile::ZipEntry *v41; // r5
  ZIPFile::ZipEntry *v42; // r11
  unsigned int v43; // r6
  ZIPFile::ZipEntry *v44; // r0
  ZIPFile::ZipEntry *v45; // r5
  ZIPFile::ZipEntry *v46; // r11
  unsigned __int8 *v47; // r11
  int v48; // r5
  size_t v49; // r6
  char *v50; // r4
  int v51; // r0
  unsigned int v52; // r0
  unsigned int tv_sec; // r5
  ZIPFile::ZipEntry *v54; // r0
  ZIPFile::ZipEntry *v55; // r6
  ZIPFile::ZipEntry *v56; // r8
  __kernel_time_t v57; // r4
  unsigned int numEntries; // r5
  unsigned int v59; // r10
  ZIPFile::ZipEntry *v60; // r0
  ZIPFile::ZipEntry *v61; // r6
  ZIPFile::ZipEntry *v62; // r8
  int v63; // r0
  __kernel_time_t v64; // r4
  unsigned __int8 *v65; // r6
  int v66; // r4
  unsigned __int8 *v67; // r0
  __kernel_time_t v68; // r6
  unsigned int v69; // r5
  int v70; // r0
  unsigned int v72; // [sp+4h] [bp-24Ch]
  unsigned __int8 *v73; // [sp+8h] [bp-248h]
  unsigned int v74; // [sp+Ch] [bp-244h]
  unsigned int *p; // [sp+10h] [bp-240h]
  unsigned int *pa; // [sp+10h] [bp-240h]
  int v77; // [sp+14h] [bp-23Ch] BYREF
  __int16 v78; // [sp+1Ah] [bp-236h] BYREF
  unsigned __int16 numBytes; // [sp+1Ch] [bp-234h] BYREF
  char numBytes_2; // [sp+1Eh] [bp-232h] BYREF
  OSFile file; // [sp+20h] [bp-230h] BYREF
  OSFile intoFile; // [sp+24h] [bp-22Ch] BYREF
  struct timeval buffer; // [sp+28h] [bp-228h] BYREF
  unsigned __int8 s[512]; // [sp+30h] [bp-220h] BYREF

  v4 = 0;
  if ( OS_FileOpen(OSFDA_Storage_0, &intoFile, withFilename, OSFAT_Read_0) == OSFE_NoError )
  {
    strcpy((char *)this->filename, (const char *)withFilename);
    snprintf(s, 0x200u, "%s.idx", (const char *)this->filename);
    if ( OS_FileOpen(OSFDA_Storage_0, &file, s, OSFAT_Read_0) )
    {
      v5 = intoFile;
      OS_FileSetPosition(intoFile, 0);
      OS_FileRead(v5, &buffer, 4);
      if ( buffer.tv_sec == 67324752 )
      {
        v6 = 0;
        p = &this->entries.numEntries;
        do
        {
          OS_FileSetPosition(v5, (int)(v6 + 6));
          OS_FileRead(v5, &numBytes_2, 2);
          OS_FileSetPosition(v5, (int)(v6 + 18));
          OS_FileRead(v5, &file, 4);
          OS_FileRead(v5, &v77, 4);
          OS_FileRead(v5, &numBytes, 2);
          OS_FileRead(v5, &v78, 2);
          if ( numBytes )
          {
            OS_FileRead(v5, s, (__int16)numBytes);
            v7 = numBytes;
          }
          else
          {
            v7 = 0;
          }
          v8 = &v6[(__int16)v7 + v78];
          s[(__int16)v7] = 0;
          v9 = (unsigned int)(v8 + 30);
          if ( v7 )
          {
            v10 = s[(__int16)v7 - 1];
            v11 = v10 == 47;
            if ( v10 != 47 )
              v11 = v10 == 92;
            if ( !v11 )
            {
              v12 = file;
              v13 = j_strdup(s);
              v14 = *p;
              v15 = *p + 1;
              if ( this->entries.numAlloced >= v15 )
              {
                dataPtr = this->entries.dataPtr;
              }
              else
              {
                v73 = v13;
                v72 = 4 * v15 / 3 + 3;
                v16 = (ZIPFile::ZipEntry *)malloc(12 * v72);
                v17 = this->entries.dataPtr;
                dataPtr = v16;
                if ( v17 )
                {
                  qmemcpy(v16, this->entries.dataPtr, 12 * v14);
                  free(v17);
                  v14 = *p;
                }
                this->entries.dataPtr = dataPtr;
                this->entries.numAlloced = v72;
                v13 = v73;
              }
              dataPtr[v14].offset = v9;
              v19 = &dataPtr[v14];
              v19->length = (unsigned int)v12;
              v19->filename = v13;
              ++*p;
            }
          }
          v6 = (char *)file + v9;
          if ( (numBytes_2 & 8) != 0 )
          {
            OS_FileSetPosition(v5, (int)file + v9);
            OS_FileRead(v5, &buffer, 4);
            if ( buffer.tv_sec == 134695760 )
              v6 += 4;
            v6 += 12;
          }
          OS_FileSetPosition(v5, (int)v6);
          OS_FileRead(v5, &buffer, 4);
        }
        while ( buffer.tv_sec == 67324752 );
        p_entries = &this->entries;
        p_numEntries = &this->entries.numEntries;
      }
      else
      {
        p_numEntries = &this->entries.numEntries;
        p_entries = &this->entries;
      }
      v25 = *p_numEntries;
      numAlloced = p_entries->numAlloced;
      if ( p_entries->numAlloced != *p_numEntries )
      {
        v27 = (ZIPFile::ZipEntry *)malloc(12 * v25);
        v28 = this->entries.dataPtr;
        v29 = v27;
        numAlloced = v25;
        if ( v28 )
        {
          qmemcpy(v27, this->entries.dataPtr, 12 * v25);
          free(v28);
          numAlloced = *p_numEntries;
        }
        this->entries.dataPtr = v29;
        this->entries.numAlloced = v25;
      }
      if ( numAlloced >= 2 )
      {
        v30 = this->entries.dataPtr;
        v31 = 1;
        p_filename = (const char **)&v30[1].filename;
        filename = (const char *)v30->filename;
        while ( 1 )
        {
          v34 = *p_filename;
          if ( strcasecmp(filename, *p_filename) >= 1 )
            break;
          ++v31;
          p_filename += 3;
          filename = v34;
          if ( v31 >= numAlloced )
            return 1;
        }
        qsort(v30, numAlloced, 0xCu, ZIPFile::EntryCompare);
      }
    }
    else
    {
      v22 = file;
      v23 = OS_FileSize(file);
      gettimeofday(&buffer, 0);
      if ( buffer.tv_usec > (int)"ist_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly"
        || buffer.tv_usec <= -1 )
      {
        v24 = OS_TimeAccurate(void)::last_current_time
            - (double)(unsigned int)OS_TimeAccurate(void)::last_current_time
            + 0.00033;
      }
      else
      {
        v24 = (double)buffer.tv_usec / 1000000.0;
      }
      OS_TimeAccurate(void)::last_current_time = v24 + (double)buffer.tv_sec;
      if ( OS_TimeAccurate(void)::last_current_time - OS_TimeAccurate(void)::lastPrint > 5.0 )
        OS_TimeAccurate(void)::lastPrint = v24 + (double)buffer.tv_sec;
      if ( v23 >= 0x200000 )
      {
        OS_FileRead(v22, &buffer, 4);
        v52 = this->entries.numAlloced;
        tv_sec = buffer.tv_sec;
        if ( v52 >= buffer.tv_sec )
        {
          v57 = buffer.tv_sec;
        }
        else
        {
          v54 = (ZIPFile::ZipEntry *)malloc(12 * buffer.tv_sec);
          v55 = this->entries.dataPtr;
          v56 = v54;
          v57 = tv_sec;
          if ( v55 )
          {
            qmemcpy(v54, this->entries.dataPtr, 12 * this->entries.numEntries);
            free(v55);
            v57 = buffer.tv_sec;
          }
          v52 = tv_sec;
          this->entries.dataPtr = v56;
          this->entries.numAlloced = tv_sec;
        }
        numEntries = this->entries.numEntries;
        if ( v52 < numEntries + v57 )
        {
          v59 = 4 * (numEntries + v57) / 3 + 3;
          v60 = (ZIPFile::ZipEntry *)malloc(12 * v59);
          v61 = this->entries.dataPtr;
          v62 = v60;
          if ( v61 )
          {
            qmemcpy(v60, this->entries.dataPtr, 12 * numEntries);
            free(v61);
            numEntries = this->entries.numEntries;
          }
          this->entries.dataPtr = v62;
          this->entries.numAlloced = v59;
        }
        this->entries.numEntries = numEntries + v57;
        v63 = OS_FileSize(v22);
        v64 = buffer.tv_sec;
        v65 = (unsigned __int8 *)malloc(v63 - 9 * buffer.tv_sec);
        this->pooledName = v65;
        if ( v64 >= 1 )
        {
          OS_FileRead(v22, this->entries.dataPtr, 4);
          OS_FileRead(v22, &this->entries.dataPtr->length, 4);
          LOWORD(v77) = 0;
          OS_FileRead(v22, &v77, 2);
          this->entries.dataPtr->filename = v65;
          OS_FileRead(v22, this->entries.dataPtr->filename, (unsigned __int16)v77);
          this->entries.dataPtr->filename[(unsigned __int16)v77] = 0;
          if ( buffer.tv_sec >= 2 )
          {
            v66 = 20;
            v67 = &v65[(unsigned __int16)v77];
            v68 = 1;
            v69 = (unsigned int)(v67 + 1);
            do
            {
              OS_FileRead(v22, (char *)this->entries.dataPtr + v66 - 8, 4);
              OS_FileRead(v22, (char *)this->entries.dataPtr + v66 - 4, 4);
              LOWORD(v77) = 0;
              OS_FileRead(v22, &v77, 2);
              *(unsigned int *)((char *)&this->entries.dataPtr->offset + v66) = v69;
              OS_FileRead(v22, *(void **)((char *)&this->entries.dataPtr->offset + v66), (unsigned __int16)v77);
              ++v68;
              v70 = *(unsigned int *)((char *)&this->entries.dataPtr->offset + v66);
              v66 += 12;
              *(_BYTE *)(v70 + (unsigned __int16)v77) = 0;
              v69 += (unsigned __int16)v77 + 1;
            }
            while ( v68 < buffer.tv_sec );
          }
        }
        OS_FileClose(v22);
      }
      else
      {
        v35 = (unsigned int *)malloc(v23);
        OS_FileRead(v22, v35, v23);
        OS_FileClose(v22);
        v36 = this->entries.numAlloced;
        pa = v35;
        v39 = *v35;
        v37 = (char *)(v35 + 1);
        v38 = v39;
        if ( v36 < v39 )
        {
          v40 = (ZIPFile::ZipEntry *)malloc(12 * v38);
          v41 = this->entries.dataPtr;
          v42 = v40;
          if ( v41 )
          {
            qmemcpy(v40, this->entries.dataPtr, 12 * this->entries.numEntries);
            free(v41);
          }
          v36 = v38;
          this->entries.dataPtr = v42;
          this->entries.numAlloced = v38;
        }
        v43 = this->entries.numEntries;
        if ( v36 < v43 + v38 )
        {
          v74 = 4 * (v43 + v38) / 3 + 3;
          v44 = (ZIPFile::ZipEntry *)malloc(12 * v74);
          v45 = this->entries.dataPtr;
          v46 = v44;
          if ( v45 )
          {
            qmemcpy(v44, this->entries.dataPtr, 12 * v43);
            free(v45);
            v43 = this->entries.numEntries;
          }
          this->entries.dataPtr = v46;
          this->entries.numAlloced = v74;
        }
        this->entries.numEntries = v43 + v38;
        v47 = (unsigned __int8 *)malloc(-9 * v38 + v23);
        this->pooledName = v47;
        if ( v38 >= 1 )
        {
          v48 = 8;
          do
          {
            *(_DWORD *)((char *)this->entries.dataPtr + v48 - 8) = *(_DWORD *)v37;
            *(_DWORD *)((char *)this->entries.dataPtr + v48 - 4) = *((_DWORD *)v37 + 1);
            v49 = *((unsigned __int16 *)v37 + 4);
            v50 = v37 + 10;
            *(unsigned int *)((char *)&this->entries.dataPtr->offset + v48) = (unsigned int)v47;
            qmemcpy(*(void **)((char *)&this->entries.dataPtr->offset + v48), v50, v49);
            v37 = &v50[v49];
            --v38;
            v51 = *(unsigned int *)((char *)&this->entries.dataPtr->offset + v48);
            v48 += 12;
            *(_BYTE *)(v51 + v49) = 0;
            v47 += v49 + 1;
          }
          while ( v38 );
        }
        free(pa);
      }
    }
    return 1;
  }
  return v4;
}
// 26F5F8: using guessed type unsigned __int8 s[512];

//----- (0026FC64) --------------------------------------------------------
int __fastcall ZIPFile::Find(ZIPFile *this, const unsigned __int8 *filename)
{
  const unsigned __int8 *v3; // r5
  int v4; // r0
  bool v5; // zf
  size_t v6; // r0
  size_t v7; // r2
  int v8; // r3
  char *v9; // r3
  int v10; // r5
  signed int v11; // r4
  int v12; // r6
  int v13; // r0
  char v15[128]; // [sp+4h] [bp-9Ch] BYREF

  v3 = filename;
  if ( *filename == 46 )
  {
    v4 = filename[1];
    v5 = v4 == 92;
    if ( v4 != 92 )
      v5 = v4 == 47;
    if ( v5 )
      v3 = filename + 2;
  }
  v6 = strlen((const char *)v3);
  v7 = 0;
  do
  {
    v8 = v3[v7];
    if ( v8 == 92 )
      LOBYTE(v8) = 47;
    v15[v7++] = v8;
  }
  while ( v7 <= v6 );
  for ( ; v6; *(v9 - 1) = 0 )
  {
    v9 = &v15[v6];
    if ( v15[v6 - 1] != 32 )
      break;
    --v6;
  }
  v10 = 0;
  v11 = this->entries.numEntries - 1;
  while ( v11 >= v10 )
  {
    v12 = v10 + (v11 - v10) / 2;
    v13 = strcasecmp(v15, (const char *)this->entries.dataPtr[v12].filename);
    if ( v13 >= 1 )
    {
      v10 = v12 + 1;
    }
    else
    {
      v11 = v12 - 1;
      if ( !v13 )
        return v12;
    }
  }
  return -1;
}
// 26FC64: using guessed type char var_9C[128];

//----- (0026FD24) --------------------------------------------------------
OSFile __fastcall ZIPFile::Open(ZIPFile *this, int index, OSFileAccessType access, unsigned int *size)
{
  unsigned __int8 *filename; // r6
  int i; // r5
  ZIPFile::ZipEntry *dataPtr; // r0
  int v11; // r6
  _DWORD *v12; // r4
  int offset; // r5
  unsigned int length; // r9
  int v15; // r0
  OSFile file; // [sp+0h] [bp-20h] BYREF

  filename = this->filename;
  for ( i = 21; i > 1; --i )
  {
    if ( OS_FileOpen(OSFDA_Storage_0, &file, filename, access) == OSFE_NoError )
      break;
    usleep(0x1Eu);
  }
  dataPtr = this->entries.dataPtr;
  v11 = index;
  v12 = file;
  offset = dataPtr[index].offset;
  length = dataPtr[index].length;
  OS_FileSetPosition(file, offset);
  v15 = v12[7] + offset;
  v12[6] = length;
  v12[7] = v15;
  if ( size )
    *size = this->entries.dataPtr[v11].length;
  return v12;
}

//----- (0026FD9C) --------------------------------------------------------
void __fastcall ZIPFile::ReadExisting(ZIPFile *this, OSFile withHandle, int index, void *intoData, unsigned int size)
{
  int v6; // r4

  v6 = index;
  OS_FileSetPosition(withHandle, this->entries.dataPtr[index].offset);
  OS_FileRead(withHandle, intoData, this->entries.dataPtr[v6].length);
}

//----- (0026FDD4) --------------------------------------------------------
ZIPFile *__fastcall ZIP_FileCreate(const unsigned __int8 *path)
{
  char *v2; // r6
  _DWORD *v3; // r0
  ZIPFile *v4; // r4
  unsigned __int8 *pooledName; // r0
  unsigned int v6; // r5
  int v7; // r6
  ZIPFile::ZipEntry *dataPtr; // r0

  v2 = strstr((const char *)path, ".apk");
  v3 = (_DWORD *)operator new(0x118u);
  v4 = (ZIPFile *)v3;
  if ( v2 )
  {
    memset(v3, 0, 0x118u);
    v4->_vptr$ZIPFile = (int (**)(void))&off_661F3C;
  }
  else
  {
    v3[69] = 0;
    *(_DWORD *)((char *)v3 + 13) = 0;
    *(_DWORD *)((char *)v3 + 9) = 0;
    *(_QWORD *)v3 = (unsigned int)&off_661E28;
    v3[2] = 0;
  }
  if ( !ZIPFile::Initialize(v4, path) )
  {
    pooledName = v4->pooledName;
    v4->_vptr$ZIPFile = (int (**)(void))&off_661E28;
    if ( pooledName )
    {
      free(pooledName);
      v4->pooledName = 0;
    }
    else if ( v4->entries.numEntries )
    {
      v6 = 0;
      v7 = 8;
      do
      {
        free(*(void **)((char *)&v4->entries.dataPtr->offset + v7));
        ++v6;
        v7 += 12;
      }
      while ( v6 < v4->entries.numEntries );
    }
    dataPtr = v4->entries.dataPtr;
    v4->entries.numEntries = 0;
    if ( dataPtr )
      free(dataPtr);
    operator delete(v4);
    return 0;
  }
  return v4;
}
// 661E28: using guessed type void *off_661E28;
// 661F3C: using guessed type void *;

//----- (0026FE98) --------------------------------------------------------
void LockStorage()
{
  pthread_mutex_t *v0; // r4

  v0 = (pthread_mutex_t *)storageMutex;
  if ( !storageMutex )
  {
    v0 = (pthread_mutex_t *)operator new(8u);
    pthread_mutexattr_init(v0[1].__private);
    pthread_mutexattr_settype(&v0[1], 1);
    pthread_mutex_init(v0, v0[1].__private);
    storageMutex = v0;
  }
  sub_1971F0(v0);
}
// 19EE74: using guessed type int __fastcall pthread_mutexattr_settype(_DWORD, _DWORD);

//----- (0026FEE0) --------------------------------------------------------
void UnlockStorage()
{
  sub_18D550((pthread_mutex_t *)storageMutex);
}

//----- (0026FEF0) --------------------------------------------------------
bool __fastcall ZIP_AddStorage(ZIPFile *toAdd)
{
  pthread_mutex_t *v2; // r5
  unsigned int numEntries; // r10
  int v4; // r4
  ZIPFile **dataPtr; // r6
  unsigned int v6; // r9
  ZIPFile **v7; // r5
  ZIPFile **v8; // r6
  bool v9; // r4

  v2 = (pthread_mutex_t *)storageMutex;
  if ( !storageMutex )
  {
    v2 = (pthread_mutex_t *)operator new(8u);
    pthread_mutexattr_init(v2[1].__private);
    pthread_mutexattr_settype(&v2[1], 1);
    pthread_mutex_init(v2, v2[1].__private);
    storageMutex = v2;
  }
  pthread_mutex_lock(v2);
  numEntries = ZIPFile::storageFiles.numEntries;
  if ( ZIPFile::storageFiles.numEntries )
  {
    v4 = 0;
    dataPtr = ZIPFile::storageFiles.dataPtr;
    while ( strcasecmp((const char *)dataPtr[v4]->filename, (const char *)toAdd->filename) )
    {
      if ( ++v4 >= numEntries )
        goto LABEL_7;
    }
    v9 = 0;
  }
  else
  {
LABEL_7:
    if ( ZIPFile::storageFiles.numAlloced >= numEntries + 1 )
    {
      v7 = ZIPFile::storageFiles.dataPtr;
    }
    else
    {
      v6 = 4 * (numEntries + 1) / 3 + 3;
      v7 = (ZIPFile **)malloc(4 * v6);
      v8 = ZIPFile::storageFiles.dataPtr;
      if ( ZIPFile::storageFiles.dataPtr )
      {
        qmemcpy(v7, ZIPFile::storageFiles.dataPtr, 4 * numEntries);
        free(v8);
        numEntries = ZIPFile::storageFiles.numEntries;
      }
      ZIPFile::storageFiles.dataPtr = v7;
      ZIPFile::storageFiles.numAlloced = v6;
    }
    v9 = 1;
    v7[numEntries] = toAdd;
    ++ZIPFile::storageFiles.numEntries;
  }
  pthread_mutex_unlock((pthread_mutex_t *)storageMutex);
  return v9;
}
// 19EE74: using guessed type int __fastcall pthread_mutexattr_settype(_DWORD, _DWORD);

//----- (00270028) --------------------------------------------------------
OSFileError __fastcall ZIP_FileSet(const unsigned __int8 *zipfilename)
{
  ZIPFile *v1; // r0
  ZIPFile *v2; // r4
  unsigned __int8 *pooledName; // r0
  unsigned int *p_numEntries; // r8
  unsigned int v6; // r6
  int v7; // r5
  ZIPFile::ZipEntry *dataPtr; // r0

  v1 = ZIP_FileCreate(zipfilename);
  v2 = v1;
  if ( v1 )
  {
    if ( ZIP_AddStorage(v1) )
      return 0;
    pooledName = v2->pooledName;
    v2->_vptr$ZIPFile = (int (**)(void))&off_661E28;
    if ( pooledName )
    {
      free(pooledName);
      p_numEntries = &v2->entries.numEntries;
      v2->pooledName = 0;
    }
    else
    {
      p_numEntries = &v2->entries.numEntries;
      if ( v2->entries.numEntries )
      {
        v6 = 0;
        v7 = 8;
        do
        {
          free(*(void **)((char *)&v2->entries.dataPtr->offset + v7));
          ++v6;
          v7 += 12;
        }
        while ( v6 < v2->entries.numEntries );
      }
    }
    *p_numEntries = 0;
    dataPtr = v2->entries.dataPtr;
    if ( dataPtr )
      free(dataPtr);
    operator delete(v2);
  }
  return 1;
}
// 661E28: using guessed type void *off_661E28;

//----- (002700A8) --------------------------------------------------------
int __fastcall LIB_PointerGetCoordinates(int deviceIndex, int *x, int *y, float *force)
{
  ButtonContainer<3> *v5; // r12

  if ( deviceIndex > 1 )
    return 0;
  v5 = &pointers[deviceIndex];
  *x = v5->curX;
  *y = v5->curY;
  if ( force )
    *force = pointers[deviceIndex].curForce;
  return 1;
}

//----- (002700F0) --------------------------------------------------------
OSPointerState __fastcall LIB_PointerGetButton(int deviceIndex, int buttonIndex)
{
  bool v3; // cc
  OSPointerState result; // r0

  v3 = deviceIndex <= 1;
  result = OSPS_ButtonInvalid;
  if ( v3 )
    v3 = buttonIndex <= 2;
  if ( v3 )
    return pointers[deviceIndex].curState[buttonIndex];
  return result;
}

//----- (00270118) --------------------------------------------------------
float __fastcall LIB_PointerGetWheel(int deviceIndex)
{
  if ( deviceIndex <= 1 )
    return pointers[deviceIndex].WheelDelta;
  else
    return 0.0;
}

//----- (00270148) --------------------------------------------------------
void __fastcall LIB_PointerSetDoubleClickDelay(float seconds)
{
  pointers[1].doubleClickDelay = seconds;
  pointers[0].doubleClickDelay = seconds;
  pointers[2].doubleClickDelay = seconds;
  pointers[3].doubleClickDelay = seconds;
}

//----- (00270164) --------------------------------------------------------
int __fastcall LIB_PointerDoubleClicked(int deviceIndex, int buttonIndex)
{
  bool v2; // cc

  v2 = deviceIndex <= 1;
  if ( deviceIndex <= 1 )
    v2 = buttonIndex <= 2;
  return v2 && pointers[deviceIndex].doubleClicked[buttonIndex];
}

//----- (00270190) --------------------------------------------------------
int __fastcall LIB_KeyboardIsDown(OSKeyboardKey key)
{
  return (keys.curState[key] | 1) == 3;
}

//----- (002701AC) --------------------------------------------------------
OSPointerState __fastcall LIB_KeyboardState(OSKeyboardKey key)
{
  return keys.curState[key];
}

//----- (002701BC) --------------------------------------------------------
int __fastcall LIB_KeyboardPressed(OSKeyboardKey key)
{
  return keys.curState[key] == OSPS_ButtonPressed;
}

//----- (002701D4) --------------------------------------------------------
void __fastcall LIB_KeyboardUpdateKey(OSKeyboardKey key)
{
  OSPointerState v1; // r1
  OSPointerState v2; // r1

  v1 = keys.curState[key];
  if ( (unsigned int)(v1 + 1) >= 2 )
  {
    if ( v1 != OSPS_ButtonPressed )
      return;
    v2 = OSPS_ButtonDown;
  }
  else
  {
    v2 = OSPS_ButtonUp;
  }
  keys.curState[key] = v2;
}

//----- (00270204) --------------------------------------------------------
int __fastcall LIB_KeyboardComboPressed(OSKeyboardKey key1, OSKeyboardKey key2)
{
  OSPointerState v2; // r0
  OSPointerState v3; // r1

  v2 = keys.curState[key1];
  if ( (v2 | 1) != 3 )
    return 0;
  v3 = keys.curState[key2];
  if ( (v3 | 1) != 3 )
    return 0;
  if ( v2 == OSPS_ButtonPressed )
    return 1;
  return v3 == OSPS_ButtonPressed;
}

//----- (00270248) --------------------------------------------------------
int __fastcall LIB_KeyboardDoubleTapped(OSKeyboardKey key)
{
  return keys.doubleClicked[key];
}

//----- (0027025C) --------------------------------------------------------
OSPointerState __fastcall LIB_GamepadState(int gamepad, int gamepadButton)
{
  return gamepads[gamepad].curState[gamepadButton];
}

//----- (00270274) --------------------------------------------------------
void LIB_ClearInputNextUpdate()
{
  clearInputNextUpdate = 1;
}

//----- (00270284) --------------------------------------------------------
int __fastcall OS_ConvertUTF16toUTF8(unsigned __int16 *utf16, unsigned __int8 *utf8, int bufferLen)
{
  unsigned __int16 v5; // r1
  int v6; // r6
  unsigned __int16 *v7; // r5
  int v8; // r0
  int v9; // r3
  signed int v10; // r2
  int v11; // r6
  int v12; // r4
  int v13; // r12
  int v14; // r9
  int v15; // r4
  unsigned __int8 *v16; // r0
  int v17; // t1
  char v19[8]; // [sp+1h] [bp-1Fh] BYREF

  if ( utf16 )
  {
    v5 = *utf16;
    v6 = 0;
    if ( *utf16 )
    {
      v7 = utf16 + 1;
      v8 = 0;
      while ( 1 )
      {
        if ( v5 > 0x7Fu )
        {
          LOWORD(v11) = -2;
          if ( (unsigned __int16)(v5 & 0xF800) >> 11 )
          {
            HIWORD(v11) = 1023;
            v12 = (v5 >> 6) & 0x3F | (v11 << 6);
            v19[0] = (v5 >> 12) | 0xE0;
            v9 = 2;
            v10 = 3;
            v13 = 1;
          }
          else
          {
            v9 = 1;
            v12 = (v5 >> 6) & 0x1F | 0xC0;
            v10 = 2;
            v13 = 0;
          }
          LOBYTE(v5) = v5 & 0x3F | 0x80;
          v19[v13] = v12;
        }
        else
        {
          v9 = 0;
          v10 = 1;
        }
        v14 = v10 + v8;
        v19[v9] = v5;
        if ( v10 + v8 >= bufferLen )
          break;
        v15 = 1;
        v16 = &utf8[v8];
        if ( v10 <= 1 )
          v10 = 1;
        qmemcpy(v16, v19, v10);
        v17 = *v7++;
        v5 = v17;
        v8 = v14;
        if ( !v17 )
        {
          v6 = v14;
          goto LABEL_18;
        }
      }
      v15 = 0;
      v6 = v8;
    }
    else
    {
      v15 = 1;
    }
  }
  else
  {
    v15 = 1;
    v6 = 0;
  }
LABEL_18:
  utf8[v6] = 0;
  return v15;
}
// 270284: using guessed type char var_1F[8];

//----- (0027034C) --------------------------------------------------------
jint __fastcall Java_com_rockstargames_bully_bully_initTouchSense(JNIEnv_0 *env, jobject_0 ref, jobject_0 c)
{
  jint result; // r0
  jint v6; // r0
  TouchSense *v7; // r0
  TouchSense *v8; // r0

  result = 1;
  if ( !initializedTouchsense )
  {
    initializedTouchsense = 1;
    e = NVThreadGetCurrentJNIEnv();
    v6 = env->functions->GetJavaVM((JNIEnv *)env, (JavaVM **)&vm);
    if ( !c || v6 )
    {
      vm = 0;
      return -1;
    }
    else
    {
      context = c;
      if ( !g_touchSense )
      {
        v7 = (TouchSense *)operator new(0x30u);
        TouchSense::TouchSense(v7);
        g_touchSense = v8;
      }
      return 0;
    }
  }
  return result;
}
// 2703B4: variable 'v8' is possibly undefined

//----- (002703F4) --------------------------------------------------------
void TouchSense::instance()
{
  TouchSense *v0; // r0
  TouchSense *v1; // r0

  if ( !g_touchSense )
  {
    v0 = (TouchSense *)operator new(0x30u);
    TouchSense::TouchSense(v0);
    g_touchSense = v1;
  }
}
// 270416: variable 'v1' is possibly undefined

//----- (00270428) --------------------------------------------------------
void TouchSense::deleteInstance()
{
  void *v0; // r0

  if ( g_touchSense )
  {
    TouchSense::~TouchSense(g_touchSense);
    operator delete(v0);
  }
  g_touchSense = 0;
}
// 27043A: variable 'v0' is possibly undefined

//----- (00270458) --------------------------------------------------------
void *__fastcall TouchSense::threadFunc(void *t)
{
  TouchSense::run((TouchSense *)t);
  return 0;
}

//----- (00270464) --------------------------------------------------------
void __fastcall TouchSense::run(TouchSense *this)
{
  int m_delayedBuiltinEffect; // r3
  _BOOL4 m_stopThread; // r0
  int m_delayedEffect; // r0
  bool v5; // cc
  int v6; // r1
  int v7; // r0
  int v8; // [sp+4h] [bp-44h]
  VibeInt32 *p_m_currentEffect; // [sp+8h] [bp-40h]
  struct timeval tv; // [sp+18h] [bp-30h] BYREF
  struct timespec v11; // [sp+20h] [bp-28h] BYREF
  int v12[8]; // [sp+28h] [bp-20h] BYREF

  if ( !UseTouchSense )
    return;
  pthread_mutex_lock(&g_accessMutex);
  if ( this->m_stopThread )
    goto LABEL_29;
  p_m_currentEffect = &this->m_currentEffect;
  pthread_cond_wait(&g_cond, &g_accessMutex);
  while ( 1 )
  {
    m_delayedEffect = this->m_delayedEffect;
    v5 = m_delayedEffect < -1;
    if ( m_delayedEffect <= -1 )
      v5 = this->m_delayedBuiltinEffect < 0;
    if ( v5 )
      break;
    do
    {
      gettimeofday(&tv, 0);
      v11.tv_sec = tv.tv_sec;
      v6 = 1000 * tv.tv_usec + 1000000 * this->m_delayLength;
      v11.tv_nsec = v6;
      if ( v6 >= 1000000000 )
      {
        v11.tv_nsec = v6 - 1000000000;
        v11.tv_sec = tv.tv_sec + 1;
      }
      v7 = pthread_cond_timedwait(&g_cond, &g_accessMutex, &v11);
    }
    while ( !v7 );
    if ( this->m_stopThread )
      goto LABEL_29;
    if ( v7 != 110 )
    {
      _android_log_print(6, "TouchSense-GTA3", "pthread_cond_timedwait error %d", v7);
      break;
    }
    if ( this->m_delayedEffect >= 0 )
    {
      this->m_delayedEffect = -1;
      goto LABEL_19;
    }
    m_delayedBuiltinEffect = this->m_delayedBuiltinEffect;
    if ( m_delayedBuiltinEffect < 0 )
      goto LABEL_19;
    if ( UseTouchSense && this->m_hapticsLevel >= 1 )
    {
      if ( *p_m_currentEffect != -1 )
      {
        v8 = this->m_delayedBuiltinEffect;
        ImmVibeGetEffectState(this->m_deviceHandle, *p_m_currentEffect, v12);
        if ( v12[0] == 1 )
        {
          if ( this->m_currentEffectPriority < 20 )
            goto LABEL_16;
          ImmVibeStopPlayingEffect(this->m_deviceHandle);
        }
        *p_m_currentEffect = -1;
        m_delayedBuiltinEffect = v8;
      }
      ImmVibePlayUHLEffect(this->m_deviceHandle, m_delayedBuiltinEffect);
      this->m_currentEffectPriority = 20;
    }
LABEL_16:
    m_stopThread = this->m_stopThread;
    this->m_delayedBuiltinEffect = -1;
    if ( m_stopThread )
      goto LABEL_29;
LABEL_19:
    pthread_cond_wait(&g_cond, &g_accessMutex);
  }
  this->m_stopThread = 1;
LABEL_29:
  _android_log_print(3, "TouchSense-GTA3", "haptics thread exiting");
  pthread_mutex_unlock(&g_accessMutex);
}
// 18D260: using guessed type int __fastcall ImmVibeGetEffectState(_DWORD, _DWORD, _DWORD);
// 19428C: using guessed type int __fastcall ImmVibeStopPlayingEffect(_DWORD);
// 19A180: using guessed type int __fastcall ImmVibePlayUHLEffect(_DWORD, _DWORD);
// 270464: using guessed type int var_20[8];

//----- (00270630) --------------------------------------------------------
void __fastcall TouchSense::TouchSense(TouchSense *this)
{
  void *v2; // r5
  VibeInt32 m_deviceHandle; // r0
  int v4; // r0

  this->m_ivtLoaded = 0;
  this->m_hapticsLevel = 2;
  this->m_delayLength = 100;
  this->m_stopThread = 0;
  this->m_ivtBytes = 0;
  this->m_currentEffect = -1;
  this->m_continuousEffect = -1;
  *(_QWORD *)&this->m_currentEffectPriority = 0x6400000064LL;
  *(_QWORD *)&this->m_delayedEffect = -1LL;
  if ( UseTouchSense )
  {
    NVThreadGetCurrentJNIEnv();
    if ( ImmVibeInitialize2(0, globalVM, s_event_globalThiz) <= -1 )
    {
      _android_log_print(6, "TouchSense-GTA3", "FAILED TO INITIALIZE TOUCHSENSE!");
      this->m_hapticsLevel = 0;
    }
    else
    {
      if ( ImmVibeOpenDevice(0, &this->m_deviceHandle) <= -1 )
      {
        v4 = _android_log_print(6, "TouchSense-GTA3", "FAILED TO OPEN TOUCHSENSE DEVICE!");
        this->m_hapticsLevel = 0;
      }
      else
      {
        v2 = malloc(0x28u);
        *(_DWORD *)v2 = this;
        *((_DWORD *)v2 + 1) = TouchSense::threadFunc;
        strncpy((char *)v2 + 8, "Touchsense", 0x1Fu);
        if ( !pthread_create(&g_thread, 0, NVThreadSpawnProc, v2) )
          return;
        free(v2);
        m_deviceHandle = this->m_deviceHandle;
        this->m_hapticsLevel = 0;
        v4 = ImmVibeCloseDevice(m_deviceHandle);
      }
      ImmVibeTerminate(v4);
    }
  }
}
// 189F34: using guessed type int __fastcall ImmVibeInitialize2(_DWORD, _DWORD, _DWORD);
// 18C768: using guessed type int __fastcall ImmVibeOpenDevice(_DWORD, _DWORD);
// 191A90: using guessed type int __fastcall ImmVibeTerminate(_DWORD);
// 19F000: using guessed type int __fastcall ImmVibeCloseDevice(_DWORD);

//----- (00270794) --------------------------------------------------------
NVEventPlatformAppHandle NVEventGetPlatformAppHandle()
{
  return s_event_globalThiz;
}

//----- (002707A0) --------------------------------------------------------
JavaVM_0 *GetJavaVM()
{
  return globalVM;
}

//----- (002707B0) --------------------------------------------------------
void __fastcall TouchSense::~TouchSense(TouchSense *this)
{
  unsigned __int8 *m_ivtBytes; // r0
  int v3; // r0

  if ( UseTouchSense )
  {
    pthread_mutex_lock(&g_accessMutex);
    this->m_stopThread = 1;
    pthread_cond_signal(&g_cond);
    pthread_mutex_unlock(&g_accessMutex);
    pthread_join(g_thread, 0);
    m_ivtBytes = this->m_ivtBytes;
    if ( m_ivtBytes )
      operator delete[](m_ivtBytes);
    v3 = ImmVibeCloseDevice(this->m_deviceHandle);
    ImmVibeTerminate(v3);
  }
}
// 191A90: using guessed type int __fastcall ImmVibeTerminate(_DWORD);
// 19F000: using guessed type int __fastcall ImmVibeCloseDevice(_DWORD);

//----- (00270818) --------------------------------------------------------
bool __fastcall TouchSense::setIVTFile(TouchSense *this, const unsigned __int8 *filename)
{
  int *v4; // r0
  int v5; // r10
  FILE *v6; // r6
  int v7; // r4
  int Length; // r5
  bool result; // r0
  unsigned __int8 *m_ivtBytes; // r0
  unsigned __int8 *v11; // r0
  unsigned __int8 *v12; // r4
  unsigned __int8 *v13; // r0
  off_t v14; // r10
  off_t v15; // r11
  signed int v16; // r2

  if ( !UseTouchSense )
    return 1;
  v4 = (int *)NvFOpen("GTA3/data/", filename, 0, 1);
  if ( !v4 )
  {
    _android_log_print(6, "TouchSense-GTA3", "Failed to open IVT file \"%s\"!", (const char *)filename);
    return 0;
  }
  this->m_ivtLoaded = 0;
  v5 = *v4;
  v6 = (FILE *)v4[1];
  if ( *v4 == 1 )
  {
    v7 = ftell(v6);
    fseek(v6, 0, 2);
    Length = ftell(v6);
    fseek(v6, v7, 0);
  }
  else
  {
    Length = AAsset_getLength((AAsset *)v6);
  }
  m_ivtBytes = this->m_ivtBytes;
  if ( m_ivtBytes )
    operator delete[](m_ivtBytes);
  v11 = (unsigned __int8 *)operator new[](Length);
  v12 = v11;
  this->m_ivtBytes = v11;
  if ( v5 != 1 )
  {
    v14 = AAsset_getLength((AAsset *)v6);
    v15 = AAsset_getLength((AAsset *)v6);
    v16 = AAsset_getRemainingLength((AAsset *)v6) - v15 + v14;
    if ( Length <= v16 )
      v16 = Length;
    if ( AAsset_read((AAsset *)v6, v12, v16) != Length )
      goto LABEL_12;
LABEL_18:
    result = 1;
    this->m_ivtLoaded = 1;
    return result;
  }
  if ( fread(v11, 1u, Length, v6) == Length )
    goto LABEL_18;
LABEL_12:
  _android_log_print(6, "TouchSense-GTA3", "Failed to read IVT data from \"%s\"!", (const char *)filename);
  v13 = this->m_ivtBytes;
  if ( v13 )
    operator delete[](v13);
  result = 0;
  this->m_ivtBytes = 0;
  return result;
}

//----- (00270980) --------------------------------------------------------
bool __fastcall TouchSense::playEffect(TouchSense *this, int level, int effectIndex, int delay, int priority)
{
  if ( UseTouchSense )
  {
    if ( this->m_hapticsLevel < level )
      return 0;
    pthread_mutex_lock(&g_accessMutex);
    this->m_delayedEffect = effectIndex;
    this->m_delayedBuiltinEffect = -1;
    this->m_delayLength = delay;
    pthread_cond_signal(&g_cond);
    pthread_mutex_unlock(&g_accessMutex);
  }
  return 1;
}

//----- (002709E4) --------------------------------------------------------
bool __fastcall TouchSense::playEffectInternal(TouchSense *this, int effectIndex, int priority)
{
  return this->m_hapticsLevel > 0;
}

//----- (002709F0) --------------------------------------------------------
bool __fastcall TouchSense::hapticsEnabled(TouchSense *this)
{
  return this->m_hapticsLevel > 0;
}

//----- (002709FC) --------------------------------------------------------
int __fastcall TouchSense::playEffect(
        TouchSense *this,
        int level,
        const unsigned __int8 *effectName,
        int delay,
        int a5)
{
  int v9[5]; // [sp+4h] [bp-14h] BYREF

  if ( UseTouchSense )
  {
    if ( this->m_hapticsLevel < level )
      return 0;
    if ( !this->m_ivtLoaded )
      TouchSense::setIVTFile(this, "gta3.ivt");
    v9[0] = -1;
    ImmVibeGetIVTEffectIndexFromName(this->m_ivtBytes, effectName, v9);
    if ( v9[0] < 0 )
      return 0;
    if ( UseTouchSense )
    {
      if ( this->m_hapticsLevel < v9[0] )
        return 0;
      pthread_mutex_lock(&g_accessMutex);
      this->m_delayedEffect = delay;
      this->m_delayedBuiltinEffect = -1;
      this->m_delayLength = a5;
      pthread_cond_signal(&g_cond);
      pthread_mutex_unlock(&g_accessMutex);
    }
  }
  return 1;
}
// 18F02C: using guessed type int __fastcall ImmVibeGetIVTEffectIndexFromName(_DWORD, _DWORD, _DWORD);
// 2709FC: using guessed type int var_14[5];

//----- (00270AA0) --------------------------------------------------------
int __fastcall TouchSense::getHapticsLevel(TouchSense *this)
{
  return this->m_hapticsLevel;
}

//----- (00270AA4) --------------------------------------------------------
int __fastcall TouchSense::getEffectIndexFromName(TouchSense *this, const unsigned __int8 *effectName)
{
  int v5[3]; // [sp+4h] [bp-Ch] BYREF

  if ( !UseTouchSense )
    return 1;
  if ( !this->m_ivtLoaded )
    TouchSense::setIVTFile(this, "gta3.ivt");
  v5[0] = -1;
  ImmVibeGetIVTEffectIndexFromName(this->m_ivtBytes, effectName, v5);
  return v5[0];
}
// 18F02C: using guessed type int __fastcall ImmVibeGetIVTEffectIndexFromName(_DWORD, _DWORD, _DWORD);
// 270AA4: using guessed type int var_C[3];

//----- (00270AEC) --------------------------------------------------------
int __fastcall TouchSense::startContinuousBuiltinEffect(
        TouchSense *this,
        int level,
        int effectIndex,
        int delay,
        int a5)
{
  VibeInt32 m_continuousEffect; // r1
  VibeInt32 *p_m_continuousEffect; // r6
  int v10[5]; // [sp+4h] [bp-14h] BYREF

  if ( UseTouchSense )
  {
    if ( this->m_hapticsLevel < level )
      return 0;
    p_m_continuousEffect = &this->m_continuousEffect;
    m_continuousEffect = this->m_continuousEffect;
    if ( m_continuousEffect != -1 )
    {
      ImmVibeGetEffectState(this->m_deviceHandle, m_continuousEffect, v10);
      if ( v10[0] == 1 )
      {
        if ( this->m_continuousEffectPriority <= a5 )
          return 0;
        ImmVibeStopPlayingEffect(this->m_deviceHandle);
      }
      *p_m_continuousEffect = -1;
    }
    ImmVibePlayUHLEffect(this->m_deviceHandle, effectIndex);
    this->m_continuousEffectPriority = a5;
  }
  return 1;
}
// 18D260: using guessed type int __fastcall ImmVibeGetEffectState(_DWORD, _DWORD, _DWORD);
// 19428C: using guessed type int __fastcall ImmVibeStopPlayingEffect(_DWORD);
// 19A180: using guessed type int __fastcall ImmVibePlayUHLEffect(_DWORD, _DWORD);
// 270AEC: using guessed type int var_14[5];

//----- (00270B5C) --------------------------------------------------------
void __fastcall TouchSense::stopContinuousEffect(TouchSense *this)
{
  bool v2; // zf

  v2 = !UseTouchSense;
  if ( UseTouchSense )
    v2 = this->m_continuousEffect == -1;
  if ( !v2 )
  {
    ImmVibeStopPlayingEffect(this->m_deviceHandle);
    this->m_continuousEffect = -1;
  }
}
// 19428C: using guessed type int __fastcall ImmVibeStopPlayingEffect(_DWORD);

//----- (00270B88) --------------------------------------------------------
bool __fastcall TouchSense::playBuiltinEffect(TouchSense *this, int level, int effectIndex, int delay, int priority)
{
  if ( UseTouchSense )
  {
    if ( this->m_hapticsLevel < level || this->m_delayedBuiltinEffect != -1 )
      return 0;
    pthread_mutex_lock(&g_accessMutex);
    this->m_delayedEffect = -1;
    this->m_delayedBuiltinEffect = effectIndex;
    this->m_delayLength = delay;
    pthread_cond_signal(&g_cond);
    pthread_mutex_unlock(&g_accessMutex);
  }
  return 1;
}

//----- (00270BF0) --------------------------------------------------------
bool __fastcall TouchSense::playBuiltinEffectInternal(TouchSense *this, int effectIndex, int priority)
{
  VibeInt32 m_currentEffect; // r1
  VibeInt32 *p_m_currentEffect; // r6
  int v9[5]; // [sp+4h] [bp-14h] BYREF

  if ( UseTouchSense )
  {
    if ( this->m_hapticsLevel < 1 )
      return 0;
    p_m_currentEffect = &this->m_currentEffect;
    m_currentEffect = this->m_currentEffect;
    if ( m_currentEffect != -1 )
    {
      ImmVibeGetEffectState(this->m_deviceHandle, m_currentEffect, v9);
      if ( v9[0] == 1 )
      {
        if ( this->m_currentEffectPriority < priority )
          return 0;
        ImmVibeStopPlayingEffect(this->m_deviceHandle);
      }
      *p_m_currentEffect = -1;
    }
    ImmVibePlayUHLEffect(this->m_deviceHandle, effectIndex);
    this->m_currentEffectPriority = priority;
  }
  return 1;
}
// 18D260: using guessed type int __fastcall ImmVibeGetEffectState(_DWORD, _DWORD, _DWORD);
// 19428C: using guessed type int __fastcall ImmVibeStopPlayingEffect(_DWORD);
// 19A180: using guessed type int __fastcall ImmVibePlayUHLEffect(_DWORD, _DWORD);
// 270BF0: using guessed type int var_14[5];

//----- (00270C5C) --------------------------------------------------------
void __fastcall TouchSense::stopAllEffects(TouchSense *this)
{
  VibeInt32 m_currentEffect; // r1
  int v3[3]; // [sp+4h] [bp-Ch] BYREF

  if ( UseTouchSense && this->m_hapticsLevel >= 1 )
  {
    if ( this->m_continuousEffect != -1 )
    {
      ImmVibeStopPlayingEffect(this->m_deviceHandle);
      this->m_continuousEffect = -1;
    }
    m_currentEffect = this->m_currentEffect;
    if ( m_currentEffect != -1 )
    {
      ImmVibeGetEffectState(this->m_deviceHandle, m_currentEffect, v3);
      if ( v3[0] == 1 )
        ImmVibeStopPlayingEffect(this->m_deviceHandle);
      this->m_currentEffect = -1;
    }
  }
}
// 18D260: using guessed type int __fastcall ImmVibeGetEffectState(_DWORD, _DWORD, _DWORD);
// 19428C: using guessed type int __fastcall ImmVibeStopPlayingEffect(_DWORD);
// 270C5C: using guessed type int var_C[3];

//----- (00270CB0) --------------------------------------------------------
void __fastcall TouchSense::setHapticsLevel(TouchSense *this, int level)
{
  this->m_hapticsLevel = level;
}

//----- (00270CB4) --------------------------------------------------------
jint __fastcall Java_com_wardrumstudios_utils_WarMedia_setTouchSenseFilepath(
        JNIEnv_0 *env,
        jobject_0 clazz,
        jstring_0 filepath)
{
  return 0;
}

//----- (00270CB8) --------------------------------------------------------
void __fastcall NvAPKInit(jobject_0 assetManager)
{
  JNIEnv_0 *CurrentJNIEnv; // r5
  jobject v3; // r0
  AAssetManager_0 *v4; // r8
  unsigned int numEntries; // r10
  int v6; // r4
  unsigned __int8 **dataPtr; // r6
  const char *v8; // r5
  unsigned int v9; // r10
  AAsset *v10; // r0
  AAsset *v11; // r6
  off_t Length; // r8
  unsigned __int8 *v13; // r5
  off_t v14; // r9
  off_t v15; // r4
  signed int v16; // r2
  int v17; // r11
  int v18; // r0
  int v19; // r4
  int v20; // r1
  bool v21; // zf
  unsigned int v22; // r9
  unsigned __int8 **v23; // r6
  unsigned __int8 **v24; // r4
  unsigned int v25; // r8
  unsigned __int8 **v26; // r6
  unsigned __int8 **v27; // r5
  int v28; // [sp+0h] [bp-20h]

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v3 = CurrentJNIEnv->functions->NewGlobalRef(&CurrentJNIEnv->functions, assetManager);
  v4 = AAssetManager_fromJava(&CurrentJNIEnv->functions, v3);
  numEntries = assetsFiles.numEntries;
  s_manager = v4;
  if ( assetsFiles.numEntries )
  {
    v6 = 0;
    dataPtr = assetsFiles.dataPtr;
    while ( 1 )
    {
      v8 = (const char *)dataPtr[v6];
      if ( !strcasecmp("assetfile.txt", v8) )
        break;
      if ( ++v6 >= numEntries )
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    v8 = "assetfile.txt";
  }
  v9 = 0;
  v10 = AAssetManager_open(v4, v8, 0);
  v11 = v10;
  if ( v10 )
  {
    Length = AAsset_getLength(v10);
    v13 = (unsigned __int8 *)malloc(Length + 1);
    v14 = AAsset_getLength(v11);
    v15 = AAsset_getLength(v11);
    v16 = AAsset_getRemainingLength(v11) - v15 + v14;
    if ( Length <= v16 )
      v16 = Length;
    AAsset_read(v11, v13, v16);
    assetsFiles.numEntries = 0;
    if ( Length )
    {
      v9 = 0;
      v17 = 0;
      v18 = 0;
      v19 = (int)v13;
      do
      {
        v20 = v13[v17];
        v21 = v20 == 13;
        if ( v20 != 13 )
          v21 = v20 == 10;
        if ( v21 )
        {
          v13[v17] = 0;
          if ( !v18 )
          {
            if ( assetsFiles.numAlloced >= v9 + 1 )
            {
              v23 = assetsFiles.dataPtr;
            }
            else
            {
              v28 = v19;
              v22 = 4 * (v9 + 1) / 3 + 3;
              v23 = (unsigned __int8 **)malloc(4 * v22);
              v24 = assetsFiles.dataPtr;
              if ( assetsFiles.dataPtr )
              {
                qmemcpy(v23, assetsFiles.dataPtr, 4 * v9);
                free(v24);
                v9 = assetsFiles.numEntries;
              }
              v19 = v28;
              assetsFiles.dataPtr = v23;
              assetsFiles.numAlloced = v22;
            }
            v23[v9] = (unsigned __int8 *)v19;
            v9 = ++assetsFiles.numEntries;
          }
          v19 = (int)&v13[v17 + 1];
          v18 = 1;
        }
        else
        {
          v18 = 0;
        }
        ++v17;
      }
      while ( Length != v17 );
    }
    else
    {
      v19 = (int)v13;
      Length = 0;
    }
    if ( (int)&v13[-v19] >= 3 )
    {
      v13[Length] = 0;
      if ( assetsFiles.numAlloced >= v9 + 1 )
      {
        v26 = assetsFiles.dataPtr;
      }
      else
      {
        v25 = 4 * (v9 + 1) / 3 + 3;
        v26 = (unsigned __int8 **)malloc(4 * v25);
        v27 = assetsFiles.dataPtr;
        if ( assetsFiles.dataPtr )
        {
          qmemcpy(v26, assetsFiles.dataPtr, 4 * v9);
          free(v27);
          v9 = assetsFiles.numEntries;
        }
        assetsFiles.dataPtr = v26;
        assetsFiles.numAlloced = v25;
      }
      v26[v9] = (unsigned __int8 *)v19;
      ++assetsFiles.numEntries;
    }
  }
}

//----- (00270F24) --------------------------------------------------------
NvAPKFile *__fastcall NvAPKOpen(const unsigned __int8 *path)
{
  unsigned int numEntries; // r9
  int v3; // r6
  unsigned __int8 **dataPtr; // r4
  const unsigned __int8 *v5; // r5

  numEntries = assetsFiles.numEntries;
  if ( assetsFiles.numEntries )
  {
    v3 = 0;
    dataPtr = assetsFiles.dataPtr;
    while ( 1 )
    {
      v5 = dataPtr[v3];
      if ( !strcasecmp((const char *)path, (const char *)v5) )
        break;
      if ( ++v3 >= numEntries )
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    v5 = path;
  }
  return sub_193278(s_manager, (const char *)v5, 0);
}

//----- (00270F80) --------------------------------------------------------
size_t __fastcall NvAPKRead(void *ptr, size_t size, size_t nmemb, NvAPKFile *stream)
{
  size_t v5; // r4
  signed int v7; // r6
  off_t Length; // r9
  off_t v9; // r10
  signed int v10; // r0
  int v11; // r0

  v5 = size;
  v7 = nmemb * size;
  Length = AAsset_getLength((AAsset *)stream);
  v9 = AAsset_getLength((AAsset *)stream);
  v10 = AAsset_getRemainingLength((AAsset *)stream) - v9 + Length;
  if ( v7 > v10 )
    v7 = v10;
  v11 = AAsset_read((AAsset *)stream, ptr, v7);
  if ( !v5 )
    v5 = 1;
  return sub_19E670(v11, v5);
}
// 19E670: using guessed type int __fastcall sub_19E670(_DWORD, _DWORD);

//----- (00270FD4) --------------------------------------------------------
const unsigned __int8 *__fastcall FindFileName(const unsigned __int8 *path)
{
  unsigned int numEntries; // r9
  int v3; // r6
  unsigned __int8 **dataPtr; // r4
  const char *v5; // r5

  numEntries = assetsFiles.numEntries;
  if ( !assetsFiles.numEntries )
    return path;
  v3 = 0;
  dataPtr = assetsFiles.dataPtr;
  while ( 1 )
  {
    v5 = (const char *)dataPtr[v3];
    if ( !strcasecmp((const char *)path, v5) )
      break;
    if ( ++v3 >= numEntries )
      return path;
  }
  return (const unsigned __int8 *)v5;
}

//----- (00271020) --------------------------------------------------------
int __fastcall NvAPKGetc(NvAPKFile *stream)
{
  unsigned __int8 v2; // [sp+7h] [bp-9h] BYREF

  AAsset_read((AAsset *)stream, &v2, 1u);
  return v2;
}

//----- (00271036) --------------------------------------------------------
unsigned __int8 *__fastcall NvAPKGets(unsigned __int8 *s, int size, NvAPKFile *stream)
{
  int v4; // r4
  unsigned __int8 *v6; // r5
  off_t Length; // r9
  unsigned int v8; // r9
  off_t v9; // r9
  off_t v10; // r10
  signed int v11; // r2
  int v12; // t1

  v4 = size;
  v6 = s;
  if ( size >= 2 )
  {
    v6 = s;
    do
    {
      Length = AAsset_getLength((AAsset *)stream);
      v8 = Length - AAsset_getRemainingLength((AAsset *)stream);
      if ( v8 >= AAsset_getLength((AAsset *)stream) )
        break;
      v9 = AAsset_getLength((AAsset *)stream);
      v10 = AAsset_getLength((AAsset *)stream);
      v11 = AAsset_getRemainingLength((AAsset *)stream) - v10 + v9;
      if ( v11 >= 1 )
        v11 = 1;
      AAsset_read((AAsset *)stream, v6, v11);
      v12 = *v6++;
      --v4;
      if ( v12 == 10 )
        v4 = 0;
    }
    while ( v4 > 1 );
  }
  *v6 = 0;
  return s;
}

//----- (002710B0) --------------------------------------------------------
int __fastcall NvAPKEOF(NvAPKFile *stream)
{
  off_t Length; // r5
  unsigned int v3; // r5

  Length = AAsset_getLength((AAsset *)stream);
  v3 = Length - AAsset_getRemainingLength((AAsset *)stream);
  return v3 >= AAsset_getLength((AAsset *)stream);
}

//----- (002710D6) --------------------------------------------------------
int __fastcall NvAPKSeek(NvAPKFile *stream, int offset, int type)
{
  int result; // r0

  result = AAsset_seek((AAsset *)stream, offset, type);
  if ( result != -1 )
    return 0;
  return result;
}

//----- (002710E6) --------------------------------------------------------
int __fastcall NvAPKTell(NvAPKFile *stream)
{
  off_t Length; // r5

  Length = AAsset_getLength((AAsset *)stream);
  return Length - AAsset_getRemainingLength((AAsset *)stream);
}

//----- (002710FC) --------------------------------------------------------
const unsigned __int8 *__fastcall NVEventGetEventStr(NVEventType_0 eventType)
{
  unsigned __int32 v1; // r0

  v1 = eventType - 1;
  if ( v1 > 9 )
    return "unknown event type!";
  else
    return (const unsigned __int8 *)off_661F00[v1];
}
// 661F00: using guessed type char *off_661F00[6];

//----- (0027111C) --------------------------------------------------------
jint NVEventGetOrientation()
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  return sub_18B7B4(CurrentJNIEnv, s_event_globalThiz, s_getOri);
}

//----- (00271140) --------------------------------------------------------
unsigned __int8 *__fastcall NVEventLoadFile(const unsigned __int8 *file)
{
  _JNIEnv *CurrentJNIEnv; // r4
  int v3; // r0
  int v4; // r9
  int v5; // r8
  size_t v6; // r6
  jbyte *v7; // r10
  jbyte *v8; // r5

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v3 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, file);
  v4 = _JNIEnv::CallObjectMethod(CurrentJNIEnv, s_event_globalThiz, s_loadFile, v3);
  v5 = (int)CurrentJNIEnv->functions->GetObjectField(&CurrentJNIEnv->functions, (jobject)v4, s_event_dataId);
  v6 = CurrentJNIEnv->functions->GetIntField(&CurrentJNIEnv->functions, (jobject)v4, s_event_lengthId);
  v7 = CurrentJNIEnv->functions->GetByteArrayElements(&CurrentJNIEnv->functions, (jbyteArray)v5, 0);
  v8 = (jbyte *)operator new[](v6 + 1);
  qmemcpy(v8, v7, v6);
  v8[v6] = 0;
  CurrentJNIEnv->functions->ReleaseByteArrayElements(&CurrentJNIEnv->functions, (jbyteArray)v5, v7, 0);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v4);
  return (unsigned __int8 *)v8;
}

//----- (002711F8) --------------------------------------------------------
void *__fastcall NVEventGetTextureData(
        const unsigned __int8 *filename,
        unsigned __int8 **pixels,
        unsigned int *width,
        unsigned int *height,
        unsigned int *format,
        unsigned int *type)
{
  _JNIEnv *CurrentJNIEnv; // r5
  int v11; // r0
  int v12; // r4
  jobject v13; // r6

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v11 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, filename);
  v12 = _JNIEnv::CallObjectMethod(CurrentJNIEnv, s_event_globalThiz, s_loadTexture, v11);
  v13 = CurrentJNIEnv->functions->GetObjectField(&CurrentJNIEnv->functions, (jobject)v12, s_texDataId);
  *width = CurrentJNIEnv->functions->GetIntField(&CurrentJNIEnv->functions, (jobject)v12, s_widthId);
  *height = CurrentJNIEnv->functions->GetIntField(&CurrentJNIEnv->functions, (jobject)v12, s_heightId);
  *format = 6408;
  *type = 5121;
  *pixels = (unsigned __int8 *)CurrentJNIEnv->functions->GetByteArrayElements(&CurrentJNIEnv->functions, v13, 0);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v12);
  return v13;
}

//----- (002712B8) --------------------------------------------------------
void __fastcall NVEventReleaseTextureData(void *data, unsigned __int8 *pixels)
{
  JNIEnv_0 *CurrentJNIEnv; // r6

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  CurrentJNIEnv->functions->ReleaseByteArrayElements(&CurrentJNIEnv->functions, data, (jbyte *)pixels, 2);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, data);
}

//----- (002712EC) --------------------------------------------------------
int32_t_0 __fastcall NVEventWaitForEvents(const int *eventTypes, int numEvents, int waitMSecs)
{
  NVEventQueue_0 *v6; // r0
  _BOOL4 v7; // r4
  int m_block; // r0
  struct timespec v10; // [sp+0h] [bp-18h] BYREF

  pthread_mutex_lock(&s_eventQueue.m_mutex);
  v6 = (NVEventQueue_0 *)_android_log_print(3, "NVEvent", "entered NVEventWaitForEvents, wait time %d", waitMSecs);
  s_eventQueue.m_waitEventTypes = eventTypes;
  s_eventQueue.m_waitEventTypeCount = numEvents;
  if ( scanForEvents(v6) )
  {
    v7 = 1;
  }
  else
  {
    m_block = s_eventQueue.m_nativeSync.m_block;
    if ( s_eventQueue.m_nativeSync.m_block )
    {
      if ( waitMSecs <= -1 )
      {
        m_block = pthread_cond_wait(&s_eventQueue.m_nativeSync.m_cond, &s_eventQueue.m_mutex);
      }
      else
      {
        v10.tv_sec = 5;
        v10.tv_nsec = 1000 * waitMSecs;
        m_block = pthread_cond_timedwait(&s_eventQueue.m_nativeSync.m_cond, &s_eventQueue.m_mutex, &v10);
      }
    }
    v7 = scanForEvents((NVEventQueue_0 *)m_block);
  }
  s_eventQueue.m_waitEventTypes = 0;
  s_eventQueue.m_waitEventTypeCount = 0;
  pthread_mutex_unlock(&s_eventQueue.m_mutex);
  _android_log_print(3, "NVEvent", "exited NVEventWaitForEvents");
  return v7;
}
// 2712EC: using guessed type struct timespec var_18;

//----- (002713F0) --------------------------------------------------------
bool __fastcall scanForEvents(NVEventQueue_0 *q)
{
  int v1; // r6
  const char *v2; // r3
  unsigned int v3; // r0
  int32_t_0 m_headIndex; // r4
  char *v6; // r10
  _DWORD *v7; // r10
  int v8; // t1
  int v9; // r1
  const char *v10; // r0
  int v11; // r3

  _android_log_print(3, "NVEvent", "scanForEvents");
  if ( s_eventQueue.m_waitEventTypeCount >= 1 )
  {
    v1 = 0;
    do
    {
      v2 = "unknown event type!";
      v3 = s_eventQueue.m_waitEventTypes[v1] - 1;
      if ( v3 <= 9 )
        v2 = off_661F00[v3];
      _android_log_print(3, "NVEvent", "    event %s", v2);
      ++v1;
    }
    while ( v1 < s_eventQueue.m_waitEventTypeCount );
  }
  m_headIndex = s_eventQueue.m_headIndex;
  if ( s_eventQueue.m_headIndex == s_eventQueue.m_nextInsertIndex )
  {
LABEL_7:
    _android_log_print(3, "NVEvent", "event not matched");
    return 0;
  }
  else
  {
    while ( 1 )
    {
      v6 = (char *)&s_eventQueue + 24 * m_headIndex;
      v8 = *((_DWORD *)v6 + 10);
      v7 = v6 + 40;
      v9 = v8 - 1;
      v10 = "unknown event type!";
      if ( (unsigned int)(v8 - 1) <= 9 )
        v10 = off_661F00[v9];
      _android_log_print(3, "NVEvent", "examining event type [%d]: %s", m_headIndex, v10);
      if ( s_eventQueue.m_waitEventTypeCount >= 1 )
        break;
LABEL_14:
      m_headIndex = (unsigned __int8)(m_headIndex + 1);
      if ( m_headIndex == s_eventQueue.m_nextInsertIndex )
        goto LABEL_7;
    }
    v11 = 0;
    while ( *v7 != s_eventQueue.m_waitEventTypes[v11] )
    {
      if ( ++v11 >= s_eventQueue.m_waitEventTypeCount )
        goto LABEL_14;
    }
    _android_log_print(3, "NVEvent", "event matched");
    return 1;
  }
}
// 661F00: using guessed type char *off_661F00[6];

//----- (002715A4) --------------------------------------------------------
void __fastcall NVEventUnhandledEvent(NVEvent_0 *ev)
{
  if ( s_supportPauseResume && (unsigned int)(ev->m_type - 7) <= 1 )
    sub_18F9C8(
      3,
      "NVEvent",
      "C:/Projects/OSWrapper\\OS_AND/BUILD/jnilibs/nv_event/nv_event.cpp, %s, line(694): \"supportPauseResume\" applicati"
      "ons should handle NV_EVENT_PAUSE and NV_EVENT_QUIT",
      "NVEventUnhandledEvent");
}

//----- (002715F0) --------------------------------------------------------
void NVImeClosed()
{
  int data; // [sp+4h] [bp-Ch] BYREF

  data = 0;
  KeyboardWasVisible = 0;
  OS_ApplicationEvent(OSET_KeyboardSoft, &data);
}

//----- (00271610) --------------------------------------------------------
void __fastcall Java_com_nvidia_devtech_NvEventQueueActivity_jniNvAPKInit(
        JNIEnv_0 *env,
        jobject_0 clazz,
        jobject_0 assetManager)
{
  NvAPKInit(assetManager);
}

//----- (00271618) --------------------------------------------------------
void __fastcall android_sigaction(int signal, siginfo_t *info, void *reserved)
{
  _android_log_print(
    3,
    "NVEvent",
    "android_sigaction signal %d (%d %d %d)",
    signal,
    info->si_code,
    info->si_errno,
    info->si_signo);
  OS_ApplicationEvent(OSET_Crash, 0);
  ((void (__fastcall *)(int, siginfo_t *, void *))old_sa[signal]._u._sa_handler)(signal, info, reserved);
}

//----- (00271694) --------------------------------------------------------
jint __fastcall JNI_OnLoad(JavaVM_0 *vm, void *reserved)
{
  jint v3; // r4
  int v4; // r5
  struct sigaction *v5; // r5
  _BYTE v7[156]; // [sp+0h] [bp-B0h] BYREF
  int v8[5]; // [sp+9Ch] [bp-14h] BYREF

  s_vm = vm;
  globalVM = vm;
  _android_log_print(3, "NVEvent", "JNI_OnLoad called");
  v3 = 65540;
  if ( vm->functions->GetEnv((JavaVM *)vm, (void **)v8, 65540) )
  {
    _android_log_print(3, "NVEvent", "Failed to get the environment using GetEnv()");
    return -1;
  }
  else
  {
    qmemcpy(v7, off_661E30, sizeof(v7));
    v4 = (*(int (__fastcall **)(int, const char *))(*(_DWORD *)v8[0] + 24))(
           v8[0],
           "com/nvidia/devtech/NvEventQueueActivity");
    (*(void (__fastcall **)(int, int, _BYTE *, int))(*(_DWORD *)v8[0] + 860))(v8[0], v4, v7, 13);
    _android_log_print(3, "NVEvent", "RegisterNatives %d", 13);
    s_initEGL = (jmethodID)(*(int (__fastcall **)(int, int, const char *, const char *))(*(_DWORD *)v8[0] + 132))(
                             v8[0],
                             v4,
                             "InitEGLAndGLES2",
                             "(I)Z");
    s_finish = (jmethodID)(*(int (__fastcall **)(int, int, const char *, const char *))(*(_DWORD *)v8[0] + 132))(
                            v8[0],
                            v4,
                            "finish",
                            "()V");
    s_swap = (jmethodID)(*(int (__fastcall **)(int, int, const char *, const char *))(*(_DWORD *)v8[0] + 132))(
                          v8[0],
                          v4,
                          "swapBuffers",
                          "()Z");
    s_makeCurrent = (jmethodID)(*(int (__fastcall **)(int, int, const char *, const char *))(*(_DWORD *)v8[0] + 132))(
                                 v8[0],
                                 v4,
                                 "makeCurrent",
                                 "()Z");
    s_unMakeCurrent = (jmethodID)(*(int (__fastcall **)(int, int, const char *, const char *))(*(_DWORD *)v8[0] + 132))(
                                   v8[0],
                                   v4,
                                   "unMakeCurrent",
                                   "()Z");
    v5 = (struct sigaction *)malloc(0x10u);
    v5->_u._sa_handler = (__sighandler_t)android_sigaction;
    sigemptyset(&v5->sa_mask);
    v5->sa_flags = 4;
    sigaction_0(4, v5, &old_sa[4]);
    sigaction_0(6, v5, &old_sa[6]);
    sigaction_0(7, v5, &old_sa[7]);
    sigaction_0(8, v5, &old_sa[8]);
    sigaction_0(11, v5, &old_sa[11]);
    sigaction_0(16, v5, &old_sa[16]);
    sigaction_0(13, v5, &old_sa[13]);
  }
  return v3;
}
// 661E30: using guessed type char *off_661E30[2];
// 271694: using guessed type int var_14[5];

//----- (002718F0) --------------------------------------------------------
void __fastcall NVThreadInit(JavaVM_0 *vm)
{
  s_vm = vm;
}

//----- (002718FC) --------------------------------------------------------
jboolean __fastcall NVEventJNIInit(JNIEnv_0 *env, jobject_0 thiz, bool DoInit)
{
  _jobject *v4; // r3
  jclass v5; // r6
  jfieldID v6; // r2
  const JNINativeInterface *functions; // r0
  int v8; // r0
  jfieldID v9; // r2
  const JNINativeInterface *v10; // r0
  int v11; // r0
  jfieldID v12; // r2
  const JNINativeInterface *v13; // r0
  int v14; // r0
  jfieldID v15; // r2
  const JNINativeInterface *v16; // r0
  int v17; // r0
  jfieldID v18; // r2
  const JNINativeInterface *v19; // r0
  int v20; // r0
  jfieldID v21; // r2
  const JNINativeInterface *v22; // r0
  int v23; // r0
  jfieldID v24; // r2
  const JNINativeInterface *v25; // r0
  int v26; // r0
  jfieldID v27; // r2
  const JNINativeInterface *v28; // r0
  int v29; // r0
  jfieldID v30; // r2
  const JNINativeInterface *v31; // r0
  int v32; // r0
  jfieldID v33; // r2
  const JNINativeInterface *v34; // r0
  int v35; // r0
  jfieldID v36; // r2
  const JNINativeInterface *v37; // r0
  int v38; // r0
  jfieldID v39; // r2
  const JNINativeInterface *v40; // r0
  int v41; // r0
  jfieldID v42; // r2
  const JNINativeInterface *v43; // r0
  int v44; // r0
  jfieldID v45; // r2
  const JNINativeInterface *v46; // r0
  int v47; // r0
  jfieldID v48; // r2
  const JNINativeInterface *v49; // r0
  int v50; // r0
  jfieldID v51; // r2
  const JNINativeInterface *v52; // r0
  int v53; // r0
  jfieldID v54; // r2
  const JNINativeInterface *v55; // r0
  int v56; // r0
  jfieldID v57; // r2
  const JNINativeInterface *v58; // r0
  int v59; // r0
  jfieldID v60; // r2
  const JNINativeInterface *v61; // r0
  int v62; // r0
  jfieldID v63; // r2
  const JNINativeInterface *v64; // r0
  int v65; // r0
  jfieldID v66; // r2
  const JNINativeInterface *v67; // r0
  int v68; // r0
  jfieldID v69; // r2
  const JNINativeInterface *v70; // r0
  int v71; // r0
  jfieldID v72; // r2
  const JNINativeInterface *v73; // r0
  int v74; // r0
  jfieldID v75; // r2
  const JNINativeInterface *v76; // r0
  int v77; // r0
  jfieldID v78; // r2
  const JNINativeInterface *v79; // r0
  int v80; // r0
  jfieldID v81; // r2
  const JNINativeInterface *v82; // r0
  int v83; // r0
  jfieldID v84; // r2
  const JNINativeInterface *v85; // r0
  int v86; // r0
  jfieldID v87; // r2
  const JNINativeInterface *v88; // r0
  int v89; // r0
  jfieldID v90; // r2
  const JNINativeInterface *v91; // r0
  int v92; // r0
  jfieldID v93; // r2
  const JNINativeInterface *v94; // r0
  int v95; // r0
  jfieldID v96; // r2
  const JNINativeInterface *v97; // r0
  int v98; // r0
  jfieldID v99; // r2
  const JNINativeInterface *v100; // r0
  int v101; // r0
  jfieldID v102; // r2
  const JNINativeInterface *v103; // r0
  int v104; // r0
  jfieldID v105; // r2
  const JNINativeInterface *v106; // r0
  int v107; // r0
  jfieldID v108; // r2
  const JNINativeInterface *v109; // r0
  int v110; // r0
  jfieldID v111; // r2
  const JNINativeInterface *v112; // r0
  int v113; // r0
  jfieldID v114; // r2
  const JNINativeInterface *v115; // r0
  int v116; // r0
  jfieldID v117; // r2
  const JNINativeInterface *v118; // r0
  int v119; // r0
  jfieldID v120; // r2
  const JNINativeInterface *v121; // r0
  int v122; // r0
  jfieldID v123; // r2
  const JNINativeInterface *v124; // r0
  int v125; // r0
  jfieldID v126; // r2
  const JNINativeInterface *v127; // r0
  int v128; // r0
  jfieldID v129; // r2
  const JNINativeInterface *v130; // r0
  int v131; // r0
  jfieldID v132; // r2
  const JNINativeInterface *v133; // r0
  int v134; // r0
  jfieldID v135; // r2
  const JNINativeInterface *v136; // r0
  int v137; // r0
  jfieldID v138; // r2
  const JNINativeInterface *v139; // r0
  int v140; // r0
  jfieldID v141; // r2
  const JNINativeInterface *v142; // r0
  int v143; // r0
  jfieldID v144; // r2
  const JNINativeInterface *v145; // r0
  int v146; // r0
  jfieldID v147; // r2
  const JNINativeInterface *v148; // r0
  int v149; // r0
  jfieldID v150; // r2
  const JNINativeInterface *v151; // r0
  int v152; // r0
  jfieldID v153; // r2
  const JNINativeInterface *v154; // r0
  int v155; // r0
  jfieldID v156; // r2
  const JNINativeInterface *v157; // r0
  int v158; // r0
  jfieldID v159; // r2
  const JNINativeInterface *v160; // r0
  int v161; // r0
  jfieldID v162; // r2
  const JNINativeInterface *v163; // r0
  int v164; // r0
  jfieldID v165; // r2
  const JNINativeInterface *v166; // r0
  int v167; // r0
  jfieldID v168; // r2
  const JNINativeInterface *v169; // r0
  int v170; // r0
  jfieldID v171; // r2
  const JNINativeInterface *v172; // r0
  int v173; // r0
  jfieldID v174; // r2
  const JNINativeInterface *v175; // r0
  int v176; // r0
  jfieldID v177; // r2
  const JNINativeInterface *v178; // r0
  int v179; // r0
  jfieldID v180; // r2
  const JNINativeInterface *v181; // r0
  int v182; // r0
  jfieldID v183; // r2
  const JNINativeInterface *v184; // r0
  int v185; // r0
  jfieldID v186; // r2
  const JNINativeInterface *v187; // r0
  int v188; // r0
  jfieldID v189; // r2
  const JNINativeInterface *v190; // r0
  int v191; // r0
  jfieldID v192; // r2
  const JNINativeInterface *v193; // r0
  int v194; // r0
  jfieldID v195; // r2
  const JNINativeInterface *v196; // r0
  int v197; // r0
  jfieldID v198; // r2
  const JNINativeInterface *v199; // r0
  int v200; // r0
  jfieldID v201; // r2
  const JNINativeInterface *v202; // r0
  int v203; // r0
  jfieldID v204; // r2
  const JNINativeInterface *v205; // r0
  int v206; // r0
  jfieldID v207; // r2
  const JNINativeInterface *v208; // r0
  int v209; // r0
  jfieldID v210; // r2
  const JNINativeInterface *v211; // r0
  int v212; // r0
  jfieldID v213; // r2
  const JNINativeInterface *v214; // r0
  int v215; // r0
  jclass v216; // r10
  jclass v217; // r6
  jclass v218; // r6
  jclass v219; // r6
  jclass v220; // r8
  jclass v221; // r0
  _jmethodID *v222; // r2
  _BOOL4 v223; // r3
  void *v224; // r5
  double v227; // [sp+8h] [bp-38h] BYREF
  __int64 v228; // [sp+10h] [bp-30h]
  __int64 v229; // [sp+18h] [bp-28h]

  if ( !s_event_globalThiz )
  {
    v4 = (_jobject *)env->functions->NewGlobalRef(env, thiz);
    s_event_globalThiz = v4;
    if ( !v4 )
    {
      _android_log_print(3, "NVEvent", (const char *)&loc_272774);
      v4 = s_event_globalThiz;
    }
    _android_log_print(3, "NVEvent", "Thiz NewGlobalRef: 0x%p", v4);
  }
  _android_log_print(3, "NVEvent", "initMap");
  v5 = env->functions->FindClass(env, "android/view/KeyEvent");
  memset(s_keyMapping, 0, sizeof(s_keyMapping));
  v6 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_BACK", "I");
  functions = env->functions;
  if ( v6 )
  {
    v8 = ((int (__fastcall *)(JNIEnv_0 *, jclass))functions->GetStaticIntField)(env, v5);
    if ( v8 <= 255 )
      s_keyMapping[v8] = NV_KEYCODE_BACK;
  }
  else
  {
    functions->ExceptionClear(&env->functions);
  }
  v9 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_TAB", "I");
  v10 = env->functions;
  if ( v9 )
  {
    v11 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v10->GetStaticIntField)(env, v5);
    if ( v11 <= 255 )
      s_keyMapping[v11] = NV_KEYCODE_TAB;
  }
  else
  {
    v10->ExceptionClear(&env->functions);
  }
  v12 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_ENTER", "I");
  v13 = env->functions;
  if ( v12 )
  {
    v14 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v13->GetStaticIntField)(env, v5);
    if ( v14 <= 255 )
      s_keyMapping[v14] = NV_KEYCODE_ENTER;
  }
  else
  {
    v13->ExceptionClear(&env->functions);
  }
  v15 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_MENU", "I");
  v16 = env->functions;
  if ( v15 )
  {
    v17 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v16->GetStaticIntField)(env, v5);
    if ( v17 <= 255 )
      s_keyMapping[v17] = NV_KEYCODE_MENU;
  }
  else
  {
    v16->ExceptionClear(&env->functions);
  }
  v18 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_SPACE", "I");
  v19 = env->functions;
  if ( v18 )
  {
    v20 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v19->GetStaticIntField)(env, v5);
    if ( v20 <= 255 )
      s_keyMapping[v20] = NV_KEYCODE_SPACE;
  }
  else
  {
    v19->ExceptionClear(&env->functions);
  }
  v21 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_ENDCALL", "I");
  v22 = env->functions;
  if ( v21 )
  {
    v23 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v22->GetStaticIntField)(env, v5);
    if ( v23 <= 255 )
      s_keyMapping[v23] = NV_KEYCODE_ENDCALL;
  }
  else
  {
    v22->ExceptionClear(&env->functions);
  }
  v24 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_HOME", "I");
  v25 = env->functions;
  if ( v24 )
  {
    v26 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v25->GetStaticIntField)(env, v5);
    if ( v26 <= 255 )
      s_keyMapping[v26] = NV_KEYCODE_HOME;
  }
  else
  {
    v25->ExceptionClear(&env->functions);
  }
  v27 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_DPAD_LEFT", "I");
  v28 = env->functions;
  if ( v27 )
  {
    v29 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v28->GetStaticIntField)(env, v5);
    if ( v29 <= 255 )
      s_keyMapping[v29] = NV_KEYCODE_DPAD_LEFT;
  }
  else
  {
    v28->ExceptionClear(&env->functions);
  }
  v30 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_DPAD_UP", "I");
  v31 = env->functions;
  if ( v30 )
  {
    v32 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v31->GetStaticIntField)(env, v5);
    if ( v32 <= 255 )
      s_keyMapping[v32] = NV_KEYCODE_DPAD_UP;
  }
  else
  {
    v31->ExceptionClear(&env->functions);
  }
  v33 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_DPAD_RIGHT", "I");
  v34 = env->functions;
  if ( v33 )
  {
    v35 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v34->GetStaticIntField)(env, v5);
    if ( v35 <= 255 )
      s_keyMapping[v35] = NV_KEYCODE_DPAD_RIGHT;
  }
  else
  {
    v34->ExceptionClear(&env->functions);
  }
  v36 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_DPAD_DOWN", "I");
  v37 = env->functions;
  if ( v36 )
  {
    v38 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v37->GetStaticIntField)(env, v5);
    if ( v38 <= 255 )
      s_keyMapping[v38] = NV_KEYCODE_DPAD_DOWN;
  }
  else
  {
    v37->ExceptionClear(&env->functions);
  }
  v39 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_DPAD_CENTER", "I");
  v40 = env->functions;
  if ( v39 )
  {
    v41 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v40->GetStaticIntField)(env, v5);
    if ( v41 <= 255 )
      s_keyMapping[v41] = NV_KEYCODE_ENTER;
  }
  else
  {
    v40->ExceptionClear(&env->functions);
  }
  v42 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_DEL", "I");
  v43 = env->functions;
  if ( v42 )
  {
    v44 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v43->GetStaticIntField)(env, v5);
    if ( v44 <= 255 )
      s_keyMapping[v44] = NV_KEYCODE_DEL;
  }
  else
  {
    v43->ExceptionClear(&env->functions);
  }
  v45 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_0", "I");
  v46 = env->functions;
  if ( v45 )
  {
    v47 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v46->GetStaticIntField)(env, v5);
    if ( v47 <= 255 )
      s_keyMapping[v47] = NV_KEYCODE_0;
  }
  else
  {
    v46->ExceptionClear(&env->functions);
  }
  v48 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_1", "I");
  v49 = env->functions;
  if ( v48 )
  {
    v50 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v49->GetStaticIntField)(env, v5);
    if ( v50 <= 255 )
      s_keyMapping[v50] = NV_KEYCODE_1;
  }
  else
  {
    v49->ExceptionClear(&env->functions);
  }
  v51 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_2", "I");
  v52 = env->functions;
  if ( v51 )
  {
    v53 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v52->GetStaticIntField)(env, v5);
    if ( v53 <= 255 )
      s_keyMapping[v53] = NV_KEYCODE_2;
  }
  else
  {
    v52->ExceptionClear(&env->functions);
  }
  v54 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_3", "I");
  v55 = env->functions;
  if ( v54 )
  {
    v56 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v55->GetStaticIntField)(env, v5);
    if ( v56 <= 255 )
      s_keyMapping[v56] = NV_KEYCODE_3;
  }
  else
  {
    v55->ExceptionClear(&env->functions);
  }
  v57 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_4", "I");
  v58 = env->functions;
  if ( v57 )
  {
    v59 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v58->GetStaticIntField)(env, v5);
    if ( v59 <= 255 )
      s_keyMapping[v59] = NV_KEYCODE_4;
  }
  else
  {
    v58->ExceptionClear(&env->functions);
  }
  v60 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_5", "I");
  v61 = env->functions;
  if ( v60 )
  {
    v62 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v61->GetStaticIntField)(env, v5);
    if ( v62 <= 255 )
      s_keyMapping[v62] = NV_KEYCODE_5;
  }
  else
  {
    v61->ExceptionClear(&env->functions);
  }
  v63 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_6", "I");
  v64 = env->functions;
  if ( v63 )
  {
    v65 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v64->GetStaticIntField)(env, v5);
    if ( v65 <= 255 )
      s_keyMapping[v65] = NV_KEYCODE_6;
  }
  else
  {
    v64->ExceptionClear(&env->functions);
  }
  v66 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_7", "I");
  v67 = env->functions;
  if ( v66 )
  {
    v68 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v67->GetStaticIntField)(env, v5);
    if ( v68 <= 255 )
      s_keyMapping[v68] = NV_KEYCODE_7;
  }
  else
  {
    v67->ExceptionClear(&env->functions);
  }
  v69 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_8", "I");
  v70 = env->functions;
  if ( v69 )
  {
    v71 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v70->GetStaticIntField)(env, v5);
    if ( v71 <= 255 )
      s_keyMapping[v71] = NV_KEYCODE_8;
  }
  else
  {
    v70->ExceptionClear(&env->functions);
  }
  v72 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_9", "I");
  v73 = env->functions;
  if ( v72 )
  {
    v74 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v73->GetStaticIntField)(env, v5);
    if ( v74 <= 255 )
      s_keyMapping[v74] = NV_KEYCODE_9;
  }
  else
  {
    v73->ExceptionClear(&env->functions);
  }
  v75 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_A", "I");
  v76 = env->functions;
  if ( v75 )
  {
    v77 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v76->GetStaticIntField)(env, v5);
    if ( v77 <= 255 )
      s_keyMapping[v77] = NV_KEYCODE_A;
  }
  else
  {
    v76->ExceptionClear(&env->functions);
  }
  v78 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_B", "I");
  v79 = env->functions;
  if ( v78 )
  {
    v80 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v79->GetStaticIntField)(env, v5);
    if ( v80 <= 255 )
      s_keyMapping[v80] = NV_KEYCODE_B;
  }
  else
  {
    v79->ExceptionClear(&env->functions);
  }
  v81 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_C", "I");
  v82 = env->functions;
  if ( v81 )
  {
    v83 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v82->GetStaticIntField)(env, v5);
    if ( v83 <= 255 )
      s_keyMapping[v83] = NV_KEYCODE_C;
  }
  else
  {
    v82->ExceptionClear(&env->functions);
  }
  v84 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_D", "I");
  v85 = env->functions;
  if ( v84 )
  {
    v86 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v85->GetStaticIntField)(env, v5);
    if ( v86 <= 255 )
      s_keyMapping[v86] = NV_KEYCODE_D;
  }
  else
  {
    v85->ExceptionClear(&env->functions);
  }
  v87 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_E", "I");
  v88 = env->functions;
  if ( v87 )
  {
    v89 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v88->GetStaticIntField)(env, v5);
    if ( v89 <= 255 )
      s_keyMapping[v89] = NV_KEYCODE_E;
  }
  else
  {
    v88->ExceptionClear(&env->functions);
  }
  v90 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_F", "I");
  v91 = env->functions;
  if ( v90 )
  {
    v92 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v91->GetStaticIntField)(env, v5);
    if ( v92 <= 255 )
      s_keyMapping[v92] = NV_KEYCODE_F;
  }
  else
  {
    v91->ExceptionClear(&env->functions);
  }
  v93 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_G", "I");
  v94 = env->functions;
  if ( v93 )
  {
    v95 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v94->GetStaticIntField)(env, v5);
    if ( v95 <= 255 )
      s_keyMapping[v95] = NV_KEYCODE_G;
  }
  else
  {
    v94->ExceptionClear(&env->functions);
  }
  v96 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_H", "I");
  v97 = env->functions;
  if ( v96 )
  {
    v98 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v97->GetStaticIntField)(env, v5);
    if ( v98 <= 255 )
      s_keyMapping[v98] = NV_KEYCODE_H;
  }
  else
  {
    v97->ExceptionClear(&env->functions);
  }
  v99 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_I", "I");
  v100 = env->functions;
  if ( v99 )
  {
    v101 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v100->GetStaticIntField)(env, v5);
    if ( v101 <= 255 )
      s_keyMapping[v101] = NV_KEYCODE_I;
  }
  else
  {
    v100->ExceptionClear(&env->functions);
  }
  v102 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_J", "I");
  v103 = env->functions;
  if ( v102 )
  {
    v104 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v103->GetStaticIntField)(env, v5);
    if ( v104 <= 255 )
      s_keyMapping[v104] = NV_KEYCODE_J;
  }
  else
  {
    v103->ExceptionClear(&env->functions);
  }
  v105 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_K", "I");
  v106 = env->functions;
  if ( v105 )
  {
    v107 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v106->GetStaticIntField)(env, v5);
    if ( v107 <= 255 )
      s_keyMapping[v107] = NV_KEYCODE_K;
  }
  else
  {
    v106->ExceptionClear(&env->functions);
  }
  v108 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_L", "I");
  v109 = env->functions;
  if ( v108 )
  {
    v110 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v109->GetStaticIntField)(env, v5);
    if ( v110 <= 255 )
      s_keyMapping[v110] = NV_KEYCODE_L;
  }
  else
  {
    v109->ExceptionClear(&env->functions);
  }
  v111 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_M", "I");
  v112 = env->functions;
  if ( v111 )
  {
    v113 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v112->GetStaticIntField)(env, v5);
    if ( v113 <= 255 )
      s_keyMapping[v113] = NV_KEYCODE_M;
  }
  else
  {
    v112->ExceptionClear(&env->functions);
  }
  v114 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_N", "I");
  v115 = env->functions;
  if ( v114 )
  {
    v116 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v115->GetStaticIntField)(env, v5);
    if ( v116 <= 255 )
      s_keyMapping[v116] = NV_KEYCODE_N;
  }
  else
  {
    v115->ExceptionClear(&env->functions);
  }
  v117 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_O", "I");
  v118 = env->functions;
  if ( v117 )
  {
    v119 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v118->GetStaticIntField)(env, v5);
    if ( v119 <= 255 )
      s_keyMapping[v119] = NV_KEYCODE_O;
  }
  else
  {
    v118->ExceptionClear(&env->functions);
  }
  v120 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_P", "I");
  v121 = env->functions;
  if ( v120 )
  {
    v122 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v121->GetStaticIntField)(env, v5);
    if ( v122 <= 255 )
      s_keyMapping[v122] = NV_KEYCODE_P;
  }
  else
  {
    v121->ExceptionClear(&env->functions);
  }
  v123 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_Q", &off_273220);
  v124 = env->functions;
  if ( v123 )
  {
    v125 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v124->GetStaticIntField)(env, v5);
    if ( v125 <= 255 )
      s_keyMapping[v125] = NV_KEYCODE_Q;
  }
  else
  {
    v124->ExceptionClear(&env->functions);
  }
  v126 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_R", &off_273220);
  v127 = env->functions;
  if ( v126 )
  {
    v128 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v127->GetStaticIntField)(env, v5);
    if ( v128 <= 255 )
      s_keyMapping[v128] = NV_KEYCODE_R;
  }
  else
  {
    v127->ExceptionClear(&env->functions);
  }
  v129 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_S", &off_273220);
  v130 = env->functions;
  if ( v129 )
  {
    v131 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v130->GetStaticIntField)(env, v5);
    if ( v131 <= 255 )
      s_keyMapping[v131] = NV_KEYCODE_S;
  }
  else
  {
    v130->ExceptionClear(&env->functions);
  }
  v132 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_T", &off_273220);
  v133 = env->functions;
  if ( v132 )
  {
    v134 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v133->GetStaticIntField)(env, v5);
    if ( v134 <= 255 )
      s_keyMapping[v134] = NV_KEYCODE_T;
  }
  else
  {
    v133->ExceptionClear(&env->functions);
  }
  v135 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_U", &off_273220);
  v136 = env->functions;
  if ( v135 )
  {
    v137 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v136->GetStaticIntField)(env, v5);
    if ( v137 <= 255 )
      s_keyMapping[v137] = NV_KEYCODE_U;
  }
  else
  {
    v136->ExceptionClear(&env->functions);
  }
  v138 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_V", &off_273220);
  v139 = env->functions;
  if ( v138 )
  {
    v140 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v139->GetStaticIntField)(env, v5);
    if ( v140 <= 255 )
      s_keyMapping[v140] = NV_KEYCODE_V;
  }
  else
  {
    v139->ExceptionClear(&env->functions);
  }
  v141 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_W", &off_273220);
  v142 = env->functions;
  if ( v141 )
  {
    v143 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v142->GetStaticIntField)(env, v5);
    if ( v143 <= 255 )
      s_keyMapping[v143] = NV_KEYCODE_W;
  }
  else
  {
    v142->ExceptionClear(&env->functions);
  }
  v144 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_X", &off_273220);
  v145 = env->functions;
  if ( v144 )
  {
    v146 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v145->GetStaticIntField)(env, v5);
    if ( v146 <= 255 )
      s_keyMapping[v146] = NV_KEYCODE_X;
  }
  else
  {
    v145->ExceptionClear(&env->functions);
  }
  v147 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_Y", &off_273220);
  v148 = env->functions;
  if ( v147 )
  {
    v149 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v148->GetStaticIntField)(env, v5);
    if ( v149 <= 255 )
      s_keyMapping[v149] = NV_KEYCODE_Y;
  }
  else
  {
    v148->ExceptionClear(&env->functions);
  }
  v150 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_Z", &off_273220);
  v151 = env->functions;
  if ( v150 )
  {
    v152 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v151->GetStaticIntField)(env, v5);
    if ( v152 <= 255 )
      s_keyMapping[v152] = NV_KEYCODE_Z;
  }
  else
  {
    v151->ExceptionClear(&env->functions);
  }
  v153 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_STAR", &off_273220);
  v154 = env->functions;
  if ( v153 )
  {
    v155 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v154->GetStaticIntField)(env, v5);
    if ( v155 <= 255 )
      s_keyMapping[v155] = NV_KEYCODE_STAR;
  }
  else
  {
    v154->ExceptionClear(&env->functions);
  }
  v156 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_PLUS", &off_273220);
  v157 = env->functions;
  if ( v156 )
  {
    v158 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v157->GetStaticIntField)(env, v5);
    if ( v158 <= 255 )
      s_keyMapping[v158] = NV_KEYCODE_PLUS;
  }
  else
  {
    v157->ExceptionClear(&env->functions);
  }
  v159 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_MINUS", &off_273220);
  v160 = env->functions;
  if ( v159 )
  {
    v161 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v160->GetStaticIntField)(env, v5);
    if ( v161 <= 255 )
      s_keyMapping[v161] = NV_KEYCODE_MINUS;
  }
  else
  {
    v160->ExceptionClear(&env->functions);
  }
  v162 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_NUM", &off_273220);
  v163 = env->functions;
  if ( v162 )
  {
    v164 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v163->GetStaticIntField)(env, v5);
    if ( v164 <= 255 )
      s_keyMapping[v164] = NV_KEYCODE_NUM;
  }
  else
  {
    v163->ExceptionClear(&env->functions);
  }
  v165 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_ALT_LEFT", &off_273220);
  v166 = env->functions;
  if ( v165 )
  {
    v167 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v166->GetStaticIntField)(env, v5);
    if ( v167 <= 255 )
      s_keyMapping[v167] = NV_KEYCODE_ALT_LEFT;
  }
  else
  {
    v166->ExceptionClear(&env->functions);
  }
  v168 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_ALT_RIGHT", &off_273220);
  v169 = env->functions;
  if ( v168 )
  {
    v170 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v169->GetStaticIntField)(env, v5);
    if ( v170 <= 255 )
      s_keyMapping[v170] = NV_KEYCODE_ALT_RIGHT;
  }
  else
  {
    v169->ExceptionClear(&env->functions);
  }
  v171 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_SHIFT_LEFT", &off_273220);
  v172 = env->functions;
  if ( v171 )
  {
    v173 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v172->GetStaticIntField)(env, v5);
    if ( v173 <= 255 )
      s_keyMapping[v173] = NV_KEYCODE_SHIFT_LEFT;
  }
  else
  {
    v172->ExceptionClear(&env->functions);
  }
  v174 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_SHIFT_RIGHT", &off_273220);
  v175 = env->functions;
  if ( v174 )
  {
    v176 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v175->GetStaticIntField)(env, v5);
    if ( v176 <= 255 )
      s_keyMapping[v176] = NV_KEYCODE_SHIFT_RIGHT;
  }
  else
  {
    v175->ExceptionClear(&env->functions);
  }
  v177 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_APOSTROPHE", &off_273220);
  v178 = env->functions;
  if ( v177 )
  {
    v179 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v178->GetStaticIntField)(env, v5);
    if ( v179 <= 255 )
      s_keyMapping[v179] = NV_KEYCODE_APOSTROPHE;
  }
  else
  {
    v178->ExceptionClear(&env->functions);
  }
  v180 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_SEMICOLON", &off_273220);
  v181 = env->functions;
  if ( v180 )
  {
    v182 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v181->GetStaticIntField)(env, v5);
    if ( v182 <= 255 )
      s_keyMapping[v182] = NV_KEYCODE_SEMICOLON;
  }
  else
  {
    v181->ExceptionClear(&env->functions);
  }
  v183 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_EQUALS", &off_273220);
  v184 = env->functions;
  if ( v183 )
  {
    v185 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v184->GetStaticIntField)(env, v5);
    if ( v185 <= 255 )
      s_keyMapping[v185] = NV_KEYCODE_EQUALS;
  }
  else
  {
    v184->ExceptionClear(&env->functions);
  }
  v186 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_COMMA", &off_273220);
  v187 = env->functions;
  if ( v186 )
  {
    v188 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v187->GetStaticIntField)(env, v5);
    if ( v188 <= 255 )
      s_keyMapping[v188] = NV_KEYCODE_COMMA;
  }
  else
  {
    v187->ExceptionClear(&env->functions);
  }
  v189 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_PERIOD", &off_273220);
  v190 = env->functions;
  if ( v189 )
  {
    v191 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v190->GetStaticIntField)(env, v5);
    if ( v191 <= 255 )
      s_keyMapping[v191] = NV_KEYCODE_PERIOD;
  }
  else
  {
    v190->ExceptionClear(&env->functions);
  }
  v192 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_SLASH", &off_273220);
  v193 = env->functions;
  if ( v192 )
  {
    v194 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v193->GetStaticIntField)(env, v5);
    if ( v194 <= 255 )
      s_keyMapping[v194] = NV_KEYCODE_SLASH;
  }
  else
  {
    v193->ExceptionClear(&env->functions);
  }
  v195 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_GRAVE", &off_273220);
  v196 = env->functions;
  if ( v195 )
  {
    v197 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v196->GetStaticIntField)(env, v5);
    if ( v197 <= 255 )
      s_keyMapping[v197] = NV_KEYCODE_GRAVE;
  }
  else
  {
    v196->ExceptionClear(&env->functions);
  }
  v198 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_LEFT_BRACKET", &off_273220);
  v199 = env->functions;
  if ( v198 )
  {
    v200 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v199->GetStaticIntField)(env, v5);
    if ( v200 <= 255 )
      s_keyMapping[v200] = NV_KEYCODE_LEFT_BRACKET;
  }
  else
  {
    v199->ExceptionClear(&env->functions);
  }
  v201 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_BACKSLASH", &off_273220);
  v202 = env->functions;
  if ( v201 )
  {
    v203 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v202->GetStaticIntField)(env, v5);
    if ( v203 <= 255 )
      s_keyMapping[v203] = NV_KEYCODE_BACKSLASH;
  }
  else
  {
    v202->ExceptionClear(&env->functions);
  }
  v204 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_RIGHT_BRACKET", &off_273220);
  v205 = env->functions;
  if ( v204 )
  {
    v206 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v205->GetStaticIntField)(env, v5);
    if ( v206 <= 255 )
      s_keyMapping[v206] = NV_KEYCODE_RIGHT_BRACKET;
  }
  else
  {
    v205->ExceptionClear(&env->functions);
  }
  v207 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_CAPS_LOCK", &off_273220);
  v208 = env->functions;
  if ( v207 )
  {
    v209 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v208->GetStaticIntField)(env, v5);
    if ( v209 <= 255 )
      s_keyMapping[v209] = NV_KEYCODE_CAPS_LOCK;
  }
  else
  {
    v208->ExceptionClear(&env->functions);
  }
  v210 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_AT", &off_273220);
  v211 = env->functions;
  if ( v210 )
  {
    v212 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v211->GetStaticIntField)(env, v5);
    if ( v212 <= 255 )
      s_keyMapping[v212] = NV_KEYCODE_AT;
  }
  else
  {
    v211->ExceptionClear(&env->functions);
  }
  v213 = env->functions->GetStaticFieldID(env, v5, "KEYCODE_BACKSPACE", &off_273220);
  v214 = env->functions;
  if ( v213 )
  {
    v215 = ((int (__fastcall *)(JNIEnv_0 *, jclass))v214->GetStaticIntField)(env, v5);
    if ( v215 <= 255 )
      s_keyMapping[v215] = NV_KEYCODE_BACKSPACE;
  }
  else
  {
    v214->ExceptionClear(&env->functions);
  }
  _android_log_print(3, "NVEvent", "file methods");
  v216 = env->functions->FindClass(env, "com/nvidia/devtech/NvEventQueueActivity");
  s_loadFile = env->functions->GetMethodID(
                 env,
                 v216,
                 "loadFile",
                 "(Ljava/lang/String;)Lcom/nvidia/devtech/NvEventQueueActivity$RawData;");
  v217 = env->functions->FindClass(env, "com/nvidia/devtech/NvEventQueueActivity$RawData");
  s_event_lengthId = env->functions->GetFieldID(env, v217, "length", &off_273220);
  s_event_dataId = env->functions->GetFieldID(env, v217, "data", &dword_273344);
  _android_log_print(3, "NVEvent", "texture methods");
  s_loadTexture = env->functions->GetMethodID(
                    env,
                    v216,
                    "loadTexture",
                    "(Ljava/lang/String;)Lcom/nvidia/devtech/NvEventQueueActivity$RawTexture;");
  v218 = env->functions->FindClass(env, "com/nvidia/devtech/NvEventQueueActivity$RawTexture");
  s_widthId = env->functions->GetFieldID(env, v218, "width", &off_273220);
  s_heightId = env->functions->GetFieldID(env, v218, "height", &off_273220);
  s_texDataId = env->functions->GetFieldID(env, v218, "data", &dword_273344);
  s_getOri = env->functions->GetMethodID(env, v216, "getOrientation", &dword_273378);
  s_eventQueue.m_nextInsertIndex = 0;
  s_eventQueue.m_headIndex = 0;
  pthread_mutex_init(&s_eventQueue.m_mutex, 0);
  pthread_cond_init(&s_eventQueue.m_nativeSync.m_cond, 0);
  s_eventQueue.m_nativeSync.m_block = 1;
  pthread_cond_init(&s_eventQueue.m_javaSync.m_cond, 0);
  s_eventQueue.m_javaSync.m_block = 1;
  s_eventQueue.m_waitEventTypes = 0;
  s_eventQueue.m_waitEventTypeCount = 0;
  s_eventQueue.m_processingPause = 0;
  _android_log_print(3, "NVEvent", "Leave NVEventInit");
  _android_log_print(3, "WarGamepad", "JNI Init");
  v219 = env->functions->FindClass(env, &unk_60AD58);
  LODWORD(v228) = WarGamepad_ProcessTouchpadAsPointer;
  v227 = *(double *)off_661ED0;
  env->functions->RegisterNatives((JNIEnv *)env, v219, (const JNINativeMethod *)&v227, 1);
  s_getGamepadType = env->functions->GetMethodID(env, v219, "GetGamepadType", "(I)I");
  s_getGamepadButtons = env->functions->GetMethodID(env, v219, "GetGamepadButtons", "(I)I");
  s_getGamepadAxis = env->functions->GetMethodID(env, v219, "GetGamepadAxis", "(II)F");
  s_getGamepadTrack = env->functions->GetMethodID(env, v219, "GetGamepadTrack", "(III)I");
  _android_log_print(3, "WarGamepad", "JNI Done Init");
  _android_log_print(3, "OSWrapper", "JNI Init (Billing)");
  v220 = env->functions->FindClass(env, "com/wardrumstudios/utils/WarBilling");
  v227 = *(double *)off_661EE0;
  v228 = *(_QWORD *)&off_661EE8;
  v229 = *(_QWORD *)&off_661EF0;
  env->functions->RegisterNatives((JNIEnv *)env, v220, (const JNINativeMethod *)&v227, 2);
  s_addSku = env->functions->GetMethodID(env, v220, "AddSKU", "(Ljava/lang/String;)V");
  s_initBilling = env->functions->GetMethodID(env, v220, "InitBilling", &dword_2733E8);
  s_requestPurchase = env->functions->GetMethodID(env, v220, "RequestPurchase", "(Ljava/lang/String;)Z");
  s_localizedPrice = env->functions->GetMethodID(env, v220, "LocalizedPrice", "(Ljava/lang/String;)Ljava/lang/String;");
  s_setBillingKey = env->functions->GetMethodID(env, v220, "SetBillingKey", "(Ljava/lang/String;)V");
  _android_log_print(3, "OSWrapper", "JNI Init Done (Billing)");
  WarKeyboard_class = (jclass_0)env->functions->FindClass(env, "com/wardrumstudios/utils/WarMedia");
  s_ShowKeyboard = env->functions->GetMethodID(env, WarKeyboard_class, "ShowKeyboard", "(I)V");
  s_IsKeyboardShown = env->functions->GetMethodID(env, WarKeyboard_class, "IsKeyboardShown", &dword_2733E8);
  s_warHttp_class = (jclass_0)env->functions->FindClass(env, "com/wardrumstudios/utils/WarHttp");
  s_warHttp_class = (jclass_0)((int (__fastcall *)(JNIEnv_0 *))env->functions->NewGlobalRef)(env);
  s_warHttp_ctor = env->functions->GetMethodID(env, s_warHttp_class, "<init>", "(Lcom/wardrumstudios/utils/WarBase;)V");
  s_warHttpGet = env->functions->GetMethodID(env, s_warHttp_class, "HttpGet", "(Ljava/lang/String;)Ljava/lang/String;");
  s_warHttpPost = env->functions->GetMethodID(
                    env,
                    s_warHttp_class,
                    "HttpPost",
                    "(Ljava/lang/String;)Ljava/lang/String;");
  s_warHttpGetData = env->functions->GetMethodID(env, s_warHttp_class, "HttpGetData", "(Ljava/lang/String;)[B");
  s_warAddLineFeeds = env->functions->GetMethodID(env, s_warHttp_class, "AddHttpGetLineFeeds", "(Z)V");
  AND_MovieInit(env);
  DoInitGraphics = DoInit;
  _android_log_print(3, "NVEvent", "Calling NVEventAppInit");
  NvUtilInit();
  v221 = env->functions->FindClass(env, "com/nvidia/devtech/NvEventQueueActivity");
  v222 = env->functions->GetMethodID(env, v221, "getSupportPauseResume", &dword_2733E8);
  if ( v222 )
  {
    v223 = _JNIEnv::CallBooleanMethod(env, s_event_globalThiz, v222) != 0;
    s_supportPauseResume = v223;
  }
  else
  {
    v223 = s_supportPauseResume;
  }
  _android_log_print(3, "NVEvent", "spawning thread support supportPauseResume %d", v223);
  s_alreadyFinishing = 0;
  _android_log_print(3, "NVEvent", "No app jni");
  v224 = malloc(0x28u);
  *(_DWORD *)v224 = 0;
  *((_DWORD *)v224 + 1) = NVEventMainLoopThreadFunc;
  strncpy((char *)v224 + 8, "NVEvent", 0x1Fu);
  if ( pthread_create(&s_mainThread, 0, NVThreadSpawnProc, v224) )
    free(v224);
  _android_log_print(3, "NVEvent", "thread spawned");
  return 1;
}
// 273220: using guessed type void *off_273220;
// 273344: using guessed type int dword_273344;
// 273378: using guessed type int dword_273378;
// 2733E8: using guessed type int dword_2733E8;
// 661ED0: using guessed type char *off_661ED0[2];
// 661EE0: using guessed type char *off_661EE0[2];
// 661EE8: using guessed type void *off_661EE8;
// 661EF0: using guessed type char *off_661EF0;
// 6DF87C: using guessed type char s_alreadyFinishing;

//----- (002734B8) --------------------------------------------------------
int __fastcall NVEventTouchEvent(JNIEnv_0 *env, jobject_0 thiz, jint action, jint mx, jint my)
{
  char v8; // r0
  char v9; // r0
  char v10; // r0
  char v11; // r0
  char v12; // r0
  NVEvent_0 *v13; // r1
  int v15[10]; // [sp+0h] [bp-28h] BYREF

  v8 = `guard variable for'NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::KeyCode_class;
  __dmb(0xBu);
  if ( (v8 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::KeyCode_class) )
  {
    NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::KeyCode_class = (jclass_0)env->functions->FindClass(
                                                                                     env,
                                                                                     "android/view/MotionEvent");
    _cxa_guard_release((__guard *)&`guard variable for'NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::KeyCode_class);
  }
  v9 = `guard variable for'NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::ACTION_DOWN_id;
  __dmb(0xBu);
  if ( (v9 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::ACTION_DOWN_id) )
  {
    NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::ACTION_DOWN_id = env->functions->GetStaticFieldID(
                                                                            env,
                                                                            NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::KeyCode_class,
                                                                            "ACTION_DOWN",
                                                                            &off_273670);
    _cxa_guard_release((__guard *)&`guard variable for'NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::ACTION_DOWN_id);
  }
  v10 = `guard variable for'NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::ACTION_UP_id;
  __dmb(0xBu);
  if ( (v10 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::ACTION_UP_id) )
  {
    NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::ACTION_UP_id = env->functions->GetStaticFieldID(
                                                                          env,
                                                                          NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::KeyCode_class,
                                                                          "ACTION_UP",
                                                                          &off_273670);
    _cxa_guard_release((__guard *)&`guard variable for'NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::ACTION_UP_id);
  }
  v11 = `guard variable for'NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::ACTION_DOWN;
  __dmb(0xBu);
  if ( (v11 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::ACTION_DOWN) )
  {
    NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::ACTION_DOWN = env->functions->GetStaticIntField(
                                                                         (JNIEnv *)env,
                                                                         NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::KeyCode_class,
                                                                         NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::ACTION_DOWN_id);
    _cxa_guard_release((__guard *)&`guard variable for'NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::ACTION_DOWN);
  }
  v12 = `guard variable for'NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::ACTION_UP;
  __dmb(0xBu);
  if ( (v12 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::ACTION_UP) )
  {
    NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::ACTION_UP = env->functions->GetStaticIntField(
                                                                       (JNIEnv *)env,
                                                                       NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::KeyCode_class,
                                                                       NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::ACTION_UP_id);
    _cxa_guard_release((__guard *)&`guard variable for'NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::ACTION_UP);
  }
  v15[0] = 3;
  if ( NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::ACTION_UP == action )
  {
    v13 = 0;
  }
  else
  {
    v13 = (NVEvent_0 *)(&dword_0 + 2);
    if ( NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::ACTION_DOWN == action )
      v13 = (NVEvent_0 *)((char *)&dword_0 + 1);
  }
  v15[1] = (int)v13;
  *(float *)&v15[3] = (float)my;
  *(float *)&v15[2] = (float)mx;
  NVEventInsertNewest((NVEventQueue_0 *)v15, v13);
  return 1;
}
// 0: using guessed type int dword_0;
// 273670: using guessed type void *off_273670;
// 6DFC8C: using guessed type char `guard variable for'NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::KeyCode_class;
// 6DFC94: using guessed type char `guard variable for'NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::ACTION_DOWN_id;
// 6DFC9C: using guessed type char `guard variable for'NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::ACTION_UP_id;
// 6DFCA4: using guessed type char `guard variable for'NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::ACTION_DOWN;
// 6DFCAC: using guessed type char `guard variable for'NVEventTouchEvent(_JNIEnv *,_jobject *,int,int,int)::ACTION_UP;

//----- (002736CC) --------------------------------------------------------
int __fastcall NVEventMultiTouchEvent(
        JNIEnv_0 *env,
        jobject_0 thiz,
        jint action,
        jint count,
        jint mx1,
        jint my1,
        jint mx2,
        jint my2)
{
  char v11; // r0
  char v12; // r0
  char v13; // r0
  char v14; // r0
  char v15; // r0
  char v16; // r0
  char v17; // r0
  char v18; // r0
  char v19; // r0
  jint v20; // r5
  int v21; // r0
  int v22; // r4
  int v23; // r5
  float *v24; // r1
  float *v25; // r2
  int v26; // r0
  int v28; // [sp+0h] [bp-30h] BYREF
  int v29; // [sp+4h] [bp-2Ch]
  float v30; // [sp+8h] [bp-28h] BYREF
  float v31; // [sp+Ch] [bp-24h] BYREF
  float v32; // [sp+10h] [bp-20h] BYREF
  float v33; // [sp+14h] [bp-1Ch] BYREF

  v11 = `guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::KeyCode_class;
  __dmb(0xBu);
  if ( (v11 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::KeyCode_class) )
  {
    NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::KeyCode_class = (jclass_0)env->functions->FindClass(env, "android/view/MotionEvent");
    _cxa_guard_release((__guard *)&`guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::KeyCode_class);
  }
  v12 = `guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_DOWN_id;
  __dmb(0xBu);
  if ( (v12 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_DOWN_id) )
  {
    NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_DOWN_id = env->functions->GetStaticFieldID(
                                                                                             env,
                                                                                             NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::KeyCode_class,
                                                                                             "ACTION_DOWN",
                                                                                             &off_2739FC);
    _cxa_guard_release((__guard *)&`guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_DOWN_id);
  }
  v13 = `guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_UP_id;
  __dmb(0xBu);
  if ( (v13 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_UP_id) )
  {
    NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_UP_id = env->functions->GetStaticFieldID(
                                                                                           env,
                                                                                           NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::KeyCode_class,
                                                                                           "ACTION_UP",
                                                                                           &off_2739FC);
    _cxa_guard_release((__guard *)&`guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_UP_id);
  }
  v14 = `guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_CANCEL_id;
  __dmb(0xBu);
  if ( (v14 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_CANCEL_id) )
  {
    NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_CANCEL_id = env->functions->GetStaticFieldID(
                                                                                               env,
                                                                                               NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::KeyCode_class,
                                                                                               "ACTION_CANCEL",
                                                                                               &off_2739FC);
    _cxa_guard_release((__guard *)&`guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_CANCEL_id);
  }
  v15 = `guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_POINTER_INDEX_MASK_id;
  __dmb(0xBu);
  if ( (v15 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_POINTER_INDEX_MASK_id) )
  {
    NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_POINTER_INDEX_MASK_id = env->functions->GetStaticFieldID(env, NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::KeyCode_class, "ACTION_POINTER_ID_MASK", &off_2739FC);
    _cxa_guard_release((__guard *)&`guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_POINTER_INDEX_MASK_id);
  }
  v16 = `guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_DOWN;
  __dmb(0xBu);
  if ( (v16 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_DOWN) )
  {
    NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_DOWN = env->functions->GetStaticIntField(
                                                                                          (JNIEnv *)env,
                                                                                          NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::KeyCode_class,
                                                                                          NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_DOWN_id);
    _cxa_guard_release((__guard *)&`guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_DOWN);
  }
  v17 = `guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_UP;
  __dmb(0xBu);
  if ( (v17 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_UP) )
  {
    NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_UP = env->functions->GetStaticIntField(
                                                                                        (JNIEnv *)env,
                                                                                        NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::KeyCode_class,
                                                                                        NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_UP_id);
    _cxa_guard_release((__guard *)&`guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_UP);
  }
  v18 = `guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_CANCEL;
  __dmb(0xBu);
  if ( (v18 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_CANCEL) )
  {
    NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_CANCEL = env->functions->GetStaticIntField(
                                                                                            (JNIEnv *)env,
                                                                                            NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::KeyCode_class,
                                                                                            NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_CANCEL_id);
    _cxa_guard_release((__guard *)&`guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_CANCEL);
  }
  v19 = `guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_POINTER_INDEX_MASK;
  __dmb(0xBu);
  if ( (v19 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_POINTER_INDEX_MASK) )
  {
    NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_POINTER_INDEX_MASK = env->functions->GetStaticIntField((JNIEnv *)env, NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::KeyCode_class, NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_POINTER_INDEX_MASK_id);
    _cxa_guard_release((__guard *)&`guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_POINTER_INDEX_MASK);
  }
  v28 = 4;
  v20 = count;
  if ( count )
    v20 = 1;
  v21 = v20 << 8;
  if ( count > 1 )
    v21 = 768;
  v22 = action & ~NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_POINTER_INDEX_MASK;
  if ( v22 == NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_UP )
  {
    v23 = 1;
  }
  else if ( v22 == NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_DOWN )
  {
    v23 = 2;
  }
  else
  {
    v23 = 3;
    if ( v22 == NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_CANCEL )
      v23 = 4;
  }
  v24 = (float *)(v23 | v21);
  v29 = v23 | v21;
  v31 = (float)my1;
  v30 = (float)mx1;
  v32 = (float)mx2;
  v33 = (float)my2;
  if ( action == 262 )
  {
    v24 = &v33;
    v25 = &v32;
    v26 = v23 | 0x100;
    goto LABEL_42;
  }
  if ( action == 6 )
  {
    v24 = &v31;
    v25 = &v30;
    v26 = v21 | 1;
LABEL_42:
    v29 = v26;
    *v25 = 0.0;
    *v24 = 0.0;
  }
  NVEventInsertNewest((NVEventQueue_0 *)&v28, (NVEvent_0 *)v24);
  return 1;
}
// 2739FC: using guessed type void *off_2739FC;
// 6DFCB4: using guessed type char `guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::KeyCode_class;
// 6DFCBC: using guessed type char `guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_DOWN_id;
// 6DFCC4: using guessed type char `guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_UP_id;
// 6DFCCC: using guessed type char `guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_CANCEL_id;
// 6DFCD4: using guessed type char `guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_POINTER_INDEX_MASK_id;
// 6DFCDC: using guessed type char `guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_DOWN;
// 6DFCE4: using guessed type char `guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_UP;
// 6DFCEC: using guessed type char `guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_CANCEL;
// 6DFCF4: using guessed type char `guard variable for'NVEventMultiTouchEvent(_JNIEnv *,_jobject *,int,int,int,int,int,int)::ACTION_POINTER_INDEX_MASK;

//----- (00273AE0) --------------------------------------------------------
int __fastcall NVEventMultiTouchEvent4(
        JNIEnv_0 *env,
        jobject_0 thiz,
        jint action,
        jint count,
        jint mx1,
        jint my1,
        jint mx2,
        jint my2,
        jint mx3,
        jint my3,
        jint mx4,
        jint my4)
{
  return 1;
}

//----- (00273AE4) --------------------------------------------------------
int __fastcall NVEventKeyEvent(JNIEnv_0 *env, jobject_0 thiz, jint action, jint keycode, jint unichar, jint metaState)
{
  char v9; // r0
  char v10; // r0
  char v11; // r0
  NVKeyCode_0 v12; // r5
  NVEvent_0 *v13; // r1
  int v15; // [sp+0h] [bp-28h] BYREF
  jint v16; // [sp+4h] [bp-24h]
  NVKeyCode_0 v17; // [sp+8h] [bp-20h]
  jint v18; // [sp+Ch] [bp-1Ch]

  v9 = `guard variable for'NVEventKeyEvent(_JNIEnv *,_jobject *,int,int,int,int)::KeyCode_class;
  __dmb(0xBu);
  if ( (v9 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'NVEventKeyEvent(_JNIEnv *,_jobject *,int,int,int,int)::KeyCode_class) )
  {
    NVEventKeyEvent(_JNIEnv *,_jobject *,int,int,int,int)::KeyCode_class = (jclass_0)env->functions->FindClass(
                                                                                       env,
                                                                                       "android/view/KeyEvent");
    _cxa_guard_release((__guard *)&`guard variable for'NVEventKeyEvent(_JNIEnv *,_jobject *,int,int,int,int)::KeyCode_class);
  }
  v10 = `guard variable for'NVEventKeyEvent(_JNIEnv *,_jobject *,int,int,int,int)::ACTION_UP_id;
  __dmb(0xBu);
  if ( (v10 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'NVEventKeyEvent(_JNIEnv *,_jobject *,int,int,int,int)::ACTION_UP_id) )
  {
    NVEventKeyEvent(_JNIEnv *,_jobject *,int,int,int,int)::ACTION_UP_id = env->functions->GetStaticFieldID(
                                                                            env,
                                                                            NVEventKeyEvent(_JNIEnv *,_jobject *,int,int,int,int)::KeyCode_class,
                                                                            "ACTION_UP",
                                                                            &off_273C64);
    _cxa_guard_release((__guard *)&`guard variable for'NVEventKeyEvent(_JNIEnv *,_jobject *,int,int,int,int)::ACTION_UP_id);
  }
  v11 = `guard variable for'NVEventKeyEvent(_JNIEnv *,_jobject *,int,int,int,int)::ACTION_UP;
  __dmb(0xBu);
  if ( (v11 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'NVEventKeyEvent(_JNIEnv *,_jobject *,int,int,int,int)::ACTION_UP) )
  {
    NVEventKeyEvent(_JNIEnv *,_jobject *,int,int,int,int)::ACTION_UP = env->functions->GetStaticIntField(
                                                                         (JNIEnv *)env,
                                                                         NVEventKeyEvent(_JNIEnv *,_jobject *,int,int,int,int)::KeyCode_class,
                                                                         NVEventKeyEvent(_JNIEnv *,_jobject *,int,int,int,int)::ACTION_UP_id);
    _cxa_guard_release((__guard *)&`guard variable for'NVEventKeyEvent(_JNIEnv *,_jobject *,int,int,int,int)::ACTION_UP);
  }
  if ( keycode <= 255 )
  {
    v12 = s_keyMapping[keycode];
    if ( (unsigned int)(action - 3) <= 1 && v12 == NV_KEYCODE_CAPS_LOCK )
    {
      capsLockOn = action == 3;
      return 1;
    }
    if ( v12
      && (v12 != NVEventKeyEvent(_JNIEnv *,_jobject *,int,int,int,int)::lastKeyCode
       || NVEventKeyEvent(_JNIEnv *,_jobject *,int,int,int,int)::lastKeyAction != action) )
    {
      v15 = 1;
      v18 = metaState;
      v13 = 0;
      v17 = v12;
      if ( NVEventKeyEvent(_JNIEnv *,_jobject *,int,int,int,int)::ACTION_UP != action )
        v13 = (NVEvent_0 *)((char *)&dword_0 + 1);
      v16 = (jint)v13;
      NVEventInsertNewest((NVEventQueue_0 *)&v15, v13);
    }
    NVEventKeyEvent(_JNIEnv *,_jobject *,int,int,int,int)::lastKeyCode = v12;
    NVEventKeyEvent(_JNIEnv *,_jobject *,int,int,int,int)::lastKeyAction = action;
  }
  if ( unichar && NVEventKeyEvent(_JNIEnv *,_jobject *,int,int,int,int)::ACTION_UP != action )
  {
    v16 = unichar;
    v15 = 2;
    NVEventInsertNewest(
      (NVEventQueue_0 *)&v15,
      (NVEvent_0 *)NVEventKeyEvent(_JNIEnv *,_jobject *,int,int,int,int)::ACTION_UP);
  }
  return 1;
}
// 0: using guessed type int dword_0;
// 273C64: using guessed type void *off_273C64;
// 6DFCFC: using guessed type char `guard variable for'NVEventKeyEvent(_JNIEnv *,_jobject *,int,int,int,int)::KeyCode_class;
// 6DFD04: using guessed type char `guard variable for'NVEventKeyEvent(_JNIEnv *,_jobject *,int,int,int,int)::ACTION_UP_id;
// 6DFD0C: using guessed type char `guard variable for'NVEventKeyEvent(_JNIEnv *,_jobject *,int,int,int,int)::ACTION_UP;

//----- (00273CA8) --------------------------------------------------------
int __fastcall NVEventAccelerometerEvent(JNIEnv_0 *env, jobject_0 thiz, jfloat values0, jfloat values1, jfloat values2)
{
  int v6[8]; // [sp+0h] [bp-20h] BYREF

  if ( !IsAndroidPaused )
  {
    *(jfloat *)&v6[1] = values0;
    v6[0] = 5;
    *(jfloat *)&v6[3] = values2;
    *(jfloat *)&v6[2] = values1;
    NVEventInsertNewest((NVEventQueue_0 *)v6, (NVEvent_0 *)thiz);
  }
  return 1;
}

//----- (00273CEC) --------------------------------------------------------
void __fastcall NVEventCleanup(JNIEnv_0 *env)
{
  JNIEnv_0 *CurrentJNIEnv; // r4
  void *v2; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  if ( !CurrentJNIEnv || !s_event_globalThiz )
    _android_log_print(3, "NVEvent", "Error: DestroyingRegisteredObjectInstance no TLS data!");
  if ( g_touchSense )
  {
    TouchSense::~TouchSense(g_touchSense);
    operator delete(v2);
  }
  g_touchSense = 0;
  CurrentJNIEnv->functions->DeleteGlobalRef(&CurrentJNIEnv->functions, s_event_globalThiz);
  s_event_globalThiz = 0;
  _android_log_print(3, "NVEvent", "Released global thiz!");
  pthread_mutex_destroy(&s_eventQueue.m_mutex);
  s_eventQueue.m_nativeSync.m_block = 0;
  pthread_cond_broadcast(&s_eventQueue.m_nativeSync.m_cond);
  s_eventQueue.m_javaSync.m_block = 0;
  pthread_cond_broadcast(&s_eventQueue.m_javaSync.m_cond);
  pthread_cond_destroy(&s_eventQueue.m_nativeSync.m_cond);
  sub_18F0F0(&s_eventQueue.m_javaSync.m_cond);
}
// 273D1E: variable 'v2' is possibly undefined

//----- (00273DEC) --------------------------------------------------------
void __fastcall NVEventSetWindowSize(JNIEnv_0 *env, jobject_0 thiz, int w, int h)
{
  int v4[8]; // [sp+0h] [bp-20h] BYREF

  v4[1] = w;
  v4[0] = 6;
  v4[2] = h;
  NVEventInsertNewest((NVEventQueue_0 *)v4, (NVEvent_0 *)thiz);
}

//----- (00273E04) --------------------------------------------------------
void NVEventQuitAndWait()
{
  NVEvent_0 *v0; // r1
  int v1; // [sp+0h] [bp-28h] BYREF

  if ( !s_alreadyFinishing )
  {
    _android_log_print(3, "NVEvent", "Posting quit event");
    s_eventQueue.m_headIndex = s_eventQueue.m_nextInsertIndex;
    v1 = 7;
    NVEventInsertNewest((NVEventQueue_0 *)&v1, v0);
    s_eventQueue.m_nativeSync.m_block = 0;
    pthread_cond_broadcast(&s_eventQueue.m_nativeSync.m_cond);
    _android_log_print(3, "NVEvent", "Waiting for main loop exit");
    pthread_join(s_mainThread, 0);
    _android_log_print(3, "NVEvent", "Main loop exited");
  }
}
// 273E32: variable 'v0' is possibly undefined
// 6DF87C: using guessed type char s_alreadyFinishing;

//----- (00273EC0) --------------------------------------------------------
void NVEventResumeEvent()
{
  int32_t_0 m_headIndex; // r3
  char *v1; // r0
  _QWORD *v2; // r0
  int v3; // t1
  __int64 v4; // d17
  int32_t_0 *v5; // r1
  __int64 v6; // d18
  NVEvent_0 *v7; // r1
  int v8; // [sp+0h] [bp-20h] BYREF

  pthread_mutex_lock(&s_eventQueue.m_mutex);
  if ( s_eventQueue.m_headIndex != s_eventQueue.m_nextInsertIndex )
  {
    m_headIndex = s_eventQueue.m_headIndex;
    while ( 1 )
    {
      v1 = (char *)&s_eventQueue + 24 * m_headIndex;
      v3 = *((_DWORD *)v1 + 10);
      v2 = v1 + 40;
      if ( (unsigned int)(v3 - 6) <= 3 )
        break;
      m_headIndex = (unsigned __int8)(m_headIndex + 1);
      if ( m_headIndex == s_eventQueue.m_nextInsertIndex )
        goto LABEL_7;
    }
    v4 = v2[1];
    v5 = &s_eventQueue.m_nextInsertIndex + 6 * s_eventQueue.m_headIndex;
    v6 = v2[2];
    *((_QWORD *)v5 + 5) = *v2;
    *((_QWORD *)v5 + 6) = v4;
    *((_QWORD *)v5 + 7) = v6;
  }
LABEL_7:
  pthread_mutex_unlock(&s_eventQueue.m_mutex);
  v8 = 9;
  NVEventInsertNewest((NVEventQueue_0 *)&v8, v7);
}
// 273F2C: variable 'v7' is possibly undefined

//----- (00273F44) --------------------------------------------------------
void NVEventPauseEvent()
{
  int32_t_0 m_headIndex; // r3
  char *v1; // r0
  _QWORD *v2; // r0
  int v3; // t1
  __int64 v4; // d17
  int32_t_0 *v5; // r1
  __int64 v6; // d18
  NVEvent_0 *v7; // r1
  int v8; // [sp+0h] [bp-20h] BYREF

  pthread_mutex_lock(&s_eventQueue.m_mutex);
  if ( s_eventQueue.m_headIndex != s_eventQueue.m_nextInsertIndex )
  {
    m_headIndex = s_eventQueue.m_headIndex;
    while ( 1 )
    {
      v1 = (char *)&s_eventQueue + 24 * m_headIndex;
      v3 = *((_DWORD *)v1 + 10);
      v2 = v1 + 40;
      if ( (unsigned int)(v3 - 6) <= 3 )
        break;
      m_headIndex = (unsigned __int8)(m_headIndex + 1);
      if ( m_headIndex == s_eventQueue.m_nextInsertIndex )
        goto LABEL_7;
    }
    v4 = v2[1];
    v5 = &s_eventQueue.m_nextInsertIndex + 6 * s_eventQueue.m_headIndex;
    v6 = v2[2];
    *((_QWORD *)v5 + 5) = *v2;
    *((_QWORD *)v5 + 6) = v4;
    *((_QWORD *)v5 + 7) = v6;
  }
LABEL_7:
  pthread_mutex_unlock(&s_eventQueue.m_mutex);
  v8 = 8;
  NVEventInsertNewest((NVEventQueue_0 *)&v8, v7);
}
// 273FB0: variable 'v7' is possibly undefined

//----- (00273FC8) --------------------------------------------------------
void NVLowMemory()
{
  int32_t_0 m_headIndex; // r3
  char *v1; // r0
  _QWORD *v2; // r0
  int v3; // t1
  __int64 v4; // d17
  int32_t_0 *v5; // r1
  __int64 v6; // d18
  NVEvent_0 *v7; // r1
  int v8; // [sp+0h] [bp-20h] BYREF

  pthread_mutex_lock(&s_eventQueue.m_mutex);
  if ( s_eventQueue.m_headIndex != s_eventQueue.m_nextInsertIndex )
  {
    m_headIndex = s_eventQueue.m_headIndex;
    while ( 1 )
    {
      v1 = (char *)&s_eventQueue + 24 * m_headIndex;
      v3 = *((_DWORD *)v1 + 10);
      v2 = v1 + 40;
      if ( (unsigned int)(v3 - 6) <= 3 )
        break;
      m_headIndex = (unsigned __int8)(m_headIndex + 1);
      if ( m_headIndex == s_eventQueue.m_nextInsertIndex )
        goto LABEL_7;
    }
    v4 = v2[1];
    v5 = &s_eventQueue.m_nextInsertIndex + 6 * s_eventQueue.m_headIndex;
    v6 = v2[2];
    *((_QWORD *)v5 + 5) = *v2;
    *((_QWORD *)v5 + 6) = v4;
    *((_QWORD *)v5 + 7) = v6;
  }
LABEL_7:
  pthread_mutex_unlock(&s_eventQueue.m_mutex);
  v8 = 10;
  NVEventInsertNewest((NVEventQueue_0 *)&v8, v7);
}
// 274034: variable 'v7' is possibly undefined

//----- (0027404E) --------------------------------------------------------
int __fastcall NvFGetc(NvFile *stream)
{
  __int64 v1; // kr00_8
  unsigned __int8 v3; // [sp-9h] [bp-9h] BYREF

  v1 = *(_QWORD *)stream;
  if ( *(_DWORD *)stream == 1 )
    return sub_190180((FILE *)HIDWORD(v1));
  AAsset_read((AAsset *)HIDWORD(v1), &v3, 1u);
  return v3;
}

//----- (00274070) --------------------------------------------------------
unsigned __int8 *__fastcall NvFGets(unsigned __int8 *s, int size, NvFile *stream)
{
  __int64 v3; // kr00_8

  v3 = *(_QWORD *)stream;
  if ( *(_DWORD *)stream == 1 )
    return (unsigned __int8 *)sub_18C7D4((char *)s, size, (FILE *)HIDWORD(v3));
  else
    return NvAPKGets(s, size, (NvAPKFile *)HIDWORD(v3));
}

//----- (00274080) --------------------------------------------------------
GLuint __fastcall NvCreateTextureFromDDSEx(
        const unsigned __int8 *filename,
        int flipVertical,
        int useMipmaps,
        NvS32 *width,
        NvS32 *height,
        NvBool *alpha,
        NvBool *isCubeMap)
{
  int v11; // r5
  NVHHDDSImage *v12; // r4
  NvS32 numMipmaps; // r5
  int v14; // r0
  NvS32 v15; // r5
  int v16; // r0
  NvS32 v17; // r5
  int v18; // r0
  NvS32 v19; // r5
  int v20; // r0
  NvS32 v21; // r1
  GLenum v22; // r0
  void *dataBlock; // r0
  GLuint textures[7]; // [sp+4h] [bp-1Ch] BYREF

  glGetError();
  v11 = 0;
  textures[0] = 0;
  v12 = NVHHDDSLoad(filename, flipVertical != 0);
  if ( v12 )
  {
    if ( isCubeMap )
      *isCubeMap = v12->cubemap != 0;
    if ( width )
      *width = v12->width;
    if ( height )
      *height = v12->height;
    if ( alpha )
      *alpha = v12->alpha != 0;
    glGenTextures(1, textures);
    if ( v12->cubemap )
    {
      glBindTexture(0x8513u, textures[0]);
      LoadTextureFromDDSData(0x8516u, 0, v12, useMipmaps);
      numMipmaps = v12->numMipmaps;
      if ( !numMipmaps )
        numMipmaps = 1;
      LoadTextureFromDDSData(0x8515u, numMipmaps, v12, useMipmaps);
      v14 = v12->numMipmaps;
      if ( !v14 )
        v14 = 1;
      v15 = numMipmaps + v14;
      LoadTextureFromDDSData(0x8517u, v15, v12, useMipmaps);
      v16 = v12->numMipmaps;
      if ( !v16 )
        v16 = 1;
      v17 = v15 + v16;
      LoadTextureFromDDSData(0x8518u, v17, v12, useMipmaps);
      v18 = v12->numMipmaps;
      if ( !v18 )
        v18 = 1;
      v19 = v17 + v18;
      LoadTextureFromDDSData(0x8519u, v19, v12, useMipmaps);
      v20 = v12->numMipmaps;
      if ( !v20 )
        v20 = 1;
      v21 = v20 + v19;
      v22 = 34074;
    }
    else
    {
      glBindTexture(0xDE1u, textures[0]);
      v22 = 3553;
      v21 = 0;
    }
    LoadTextureFromDDSData(v22, v21, v12, useMipmaps);
    if ( glGetError() )
      NVLogError("NvCreateTextureFromDDSEx error", (const unsigned __int8 *)&byte_61CADE);
    dataBlock = v12->dataBlock;
    if ( dataBlock )
      operator delete[](dataBlock);
    operator delete(v12);
    return textures[0];
  }
  return v11;
}
// 61CADE: using guessed type char byte_61CADE;
// 274080: using guessed type GLuint textures[7];

//----- (002741E8) --------------------------------------------------------
NVHHDDSImage *__fastcall NVHHDDSLoad(const unsigned __int8 *filename, NvS32 flipVertical)
{
  int *v3; // r0
  int *v4; // r6
  int v5; // r9
  FILE *v6; // r10
  off_t Length; // r8
  off_t v8; // r5
  signed int v9; // r2
  NVHHDDSImage *v10; // r11
  off_t v11; // r4
  off_t v12; // r5
  signed int v13; // r2
  int v14; // r8
  int v15; // r0
  bool v16; // zf
  bool v17; // zf
  int v18; // r2
  int v19; // r4
  int v20; // r12
  int v21; // lr
  int v22; // r3
  int v23; // r5
  int v24; // r6
  int v25; // r0
  int v26; // r1
  bool v27; // zf
  bool v28; // zf
  bool v29; // zf
  bool v30; // zf
  bool v31; // zf
  int v32; // r0
  int v33; // r2
  int v34; // r2
  __int64 v35; // r0
  int v36; // r2
  int v37; // r6
  NvS32 *v38; // r6
  void *v39; // r5
  char *v40; // r6
  void *v41; // t1
  signed int v42; // r4
  off_t v43; // r8
  off_t v44; // r9
  int v45; // r0
  signed int v46; // r0
  char *v47; // r6
  unsigned int v48; // r0
  unsigned int v49; // r8
  void (__fastcall *v50)(char *, int); // r9
  char *v51; // r10
  char *v52; // r11
  int v53; // r6
  char *v54; // r4
  unsigned int v55; // r10
  char *v56; // r8
  int v57; // r5
  char *v58; // r4
  int v59; // r0
  int v60; // r1
  int v61; // r12
  int v62; // r8
  int height; // r4
  int width; // r5
  int v65; // r6
  int v66; // r2
  char *v67; // r0
  char v68; // r1
  int v69; // r2
  AAsset *v70; // r0
  bool v71; // zf
  void *dataBlock; // r0
  int v74; // [sp+8h] [bp-E8h]
  int v75; // [sp+Ch] [bp-E4h]
  int v76; // [sp+10h] [bp-E0h]
  NVHHDDSImage *v77; // [sp+14h] [bp-DCh]
  const unsigned __int8 *v78; // [sp+18h] [bp-D8h]
  int *p; // [sp+1Ch] [bp-D4h]
  FILE *stream; // [sp+20h] [bp-D0h]
  char *v81; // [sp+24h] [bp-CCh]
  int v82; // [sp+2Ch] [bp-C4h]
  int v83; // [sp+30h] [bp-C0h]
  int v84; // [sp+34h] [bp-BCh]
  int v86; // [sp+38h] [bp-B8h]
  int v87; // [sp+3Ch] [bp-B4h]
  int v88; // [sp+40h] [bp-B0h]
  int v89; // [sp+44h] [bp-ACh]
  int v90; // [sp+48h] [bp-A8h]
  int v91; // [sp+50h] [bp-A0h]
  int ptr; // [sp+54h] [bp-9Ch] BYREF
  char buf[4]; // [sp+58h] [bp-98h] BYREF
  int v94; // [sp+5Ch] [bp-94h]
  int v95; // [sp+60h] [bp-90h]
  NvS32 v96; // [sp+64h] [bp-8Ch]
  int v97; // [sp+68h] [bp-88h]
  int v98; // [sp+6Ch] [bp-84h]
  int v99; // [sp+70h] [bp-80h]
  char v100; // [sp+A4h] [bp-4Ch]
  int v101; // [sp+A8h] [bp-48h]
  int v102; // [sp+ACh] [bp-44h]
  int v103; // [sp+B0h] [bp-40h]
  int v104; // [sp+B4h] [bp-3Ch]
  unsigned int v105; // [sp+B8h] [bp-38h]
  int v106; // [sp+BCh] [bp-34h]
  int v107; // [sp+C4h] [bp-2Ch]

  NVLogDebug("NVHHDDSLoad", "NVHHDDSLoad file: %s", (const char *)filename);
  v3 = (int *)NvFOpen((const unsigned __int8 *)&byte_61CADE, filename, 0, 1);
  v4 = v3;
  if ( !v3 )
  {
    NVLogWarn("NVHHDDSLoad", "Could not open file: %s", (const char *)filename);
    return 0;
  }
  v6 = (FILE *)v3[1];
  v5 = *v3;
  if ( *v3 == 1 )
  {
    fread(&ptr, 1u, 4u, v6);
  }
  else
  {
    Length = AAsset_getLength((AAsset *)v6);
    v8 = AAsset_getLength((AAsset *)v6);
    v9 = AAsset_getRemainingLength((AAsset *)v6) - v8 + Length;
    if ( v9 >= 4 )
      v9 = 4;
    AAsset_read((AAsset *)v6, &ptr, v9);
  }
  if ( ptr != 542327876 )
  {
    NVLogError("NVHHDDSLoad", "!> No DDS marker in file header: %s", (const char *)filename);
    if ( v5 == 1 )
      fclose(v6);
    else
      AAsset_close((AAsset *)v6);
    free(v4);
    return 0;
  }
  v78 = filename;
  p = v4;
  v10 = (NVHHDDSImage *)operator new(0x62Cu);
  memset(v10, 0, sizeof(NVHHDDSImage));
  if ( v5 == 1 )
  {
    fread(buf, 0x7Cu, 1u, v6);
  }
  else
  {
    v11 = AAsset_getLength((AAsset *)v6);
    v12 = AAsset_getLength((AAsset *)v6);
    v13 = AAsset_getRemainingLength((AAsset *)v6) - v12 + v11;
    if ( v13 >= 124 )
      v13 = 124;
    AAsset_read((AAsset *)v6, buf, v13);
  }
  if ( (v107 & 0x200) != 0 )
  {
    if ( (v107 & 0xFC00) != 64512 )
    {
      NVLogError("NVHHDDSLoad", "Attempt to load cubemap that doesn't contain all faces (unsupported..) from: %s", v78);
      goto LABEL_151;
    }
    v14 = 1;
  }
  else
  {
    v14 = 0;
  }
  v15 = v107 << 10;
  v10->cubemap = v14;
  if ( v15 < 0 && v98 )
  {
    NVLogError("NVHHDDSLoad", "Attempt to load a volume image (currently not supported..) from: %s", v78);
LABEL_151:
    v70 = (AAsset *)v6;
    if ( v5 != 1 )
      goto LABEL_153;
    fclose(v6);
    goto LABEL_154;
  }
  if ( (v100 & 4) == 0 )
  {
    switch ( v102 )
    {
      case 8:
        if ( v103 != 255 )
        {
          v27 = v103 == 0;
          if ( !v103 )
            v27 = v104 == 0;
          if ( !v27 )
            goto LABEL_150;
          v28 = v105 == 0;
          if ( !v105 )
            v28 = v106 == 255;
          if ( !v28 )
            goto LABEL_150;
          v24 = 1;
          v10->components = 1;
          v19 = 0;
          v10->format = 6406;
          v20 = 20;
          v22 = 16;
          v18 = 5121;
          v23 = 12;
          v25 = 36;
          v21 = 1;
          goto LABEL_43;
        }
        if ( v104 || v106 != __PAIR64__(v105, 0) )
          goto LABEL_150;
        v21 = 1;
        v24 = 0;
        v20 = 20;
        v22 = 16;
        v18 = 5121;
        v10->components = 1;
        v10->format = 6409;
        break;
      case 16:
        v29 = v103 == 63488;
        if ( v103 == 63488 )
          v29 = v104 == 2016;
        if ( !v29 )
          goto LABEL_63;
        v30 = v105 == 31;
        if ( v105 == 31 )
          v30 = v106 == 0;
        if ( !v30 )
        {
LABEL_63:
          if ( v103 == 255 )
          {
            if ( v104 == 255 )
            {
              if ( v105 != 255 )
                goto LABEL_150;
            }
            else
            {
              v31 = v104 == 0;
              if ( !v104 )
                v31 = v105 == 0;
              if ( !v31 )
                goto LABEL_150;
            }
            if ( v106 == 65280 )
            {
              v21 = 2;
              v10->components = 2;
              v19 = 0;
              v10->format = 6410;
              v20 = 20;
              v22 = 16;
              v18 = 5121;
              v23 = 12;
              v24 = 1;
              v25 = 36;
              goto LABEL_43;
            }
          }
LABEL_150:
          NVLogError("NVHHDDSLoad", "Image data is not DXTC or supported RGB(A) format: %s", v78);
          goto LABEL_151;
        }
        v24 = 0;
        v10->components = 3;
        v10->format = 6407;
        v20 = 20;
        v21 = 2;
        v22 = 16;
        v18 = 33635;
        break;
      case 32:
        if ( v103 == 16711680 )
        {
          if ( v104 != 65280 )
            goto LABEL_150;
          v71 = v105 == 255;
          if ( v105 == 255 )
            v71 = v106 == -16777216;
          if ( !v71 )
            goto LABEL_150;
          v18 = 4;
          v10->components = 4;
          v21 = 1;
          v10->format = 6408;
          v19 = 0;
          v20 = 20;
          v22 = 36;
          v23 = 16;
          v24 = 5121;
          v25 = 12;
          v26 = 1;
          goto LABEL_44;
        }
        v16 = v103 == 255;
        if ( v103 == 255 )
          v16 = v104 == 65280;
        if ( !v16 )
          goto LABEL_150;
        v17 = v105 == 16711680;
        if ( v105 == 16711680 )
          v17 = v106 == -16777216;
        if ( !v17 )
          goto LABEL_150;
        v18 = 4;
        v10->components = 4;
        v19 = 0;
        v10->format = 6408;
        v20 = 20;
        v21 = 1;
        v22 = 36;
        v23 = 16;
        v24 = 5121;
        v25 = 12;
LABEL_43:
        v26 = 0;
LABEL_44:
        v74 = v26;
        goto LABEL_73;
      default:
        goto LABEL_150;
    }
    v23 = 12;
    v25 = 36;
    v19 = 0;
    goto LABEL_43;
  }
  switch ( v101 )
  {
    case 894720068:
      v20 = 36;
      v74 = 0;
      v21 = 1;
      v22 = 20;
      v18 = 4;
      v23 = 8;
      v24 = 33779;
      break;
    case 861165636:
      v20 = 36;
      v21 = 1;
      v22 = 20;
      v18 = 4;
      v23 = 8;
      v24 = 33778;
      v74 = 0;
      break;
    case 827611204:
      v19 = 0;
      v20 = 36;
      v21 = 1;
      v22 = 20;
      v18 = 3;
      v23 = 8;
      v24 = 33777;
      v25 = 32;
      goto LABEL_43;
    default:
      NVLogError("NVHHDDSLoad", "Unsupported FOURCC code = [0x%x], from file: %s");
      goto LABEL_151;
  }
  v25 = 32;
  v19 = 1;
LABEL_73:
  *(NvS32 *)((char *)&v10->width + v25) = v24;
  v32 = v94;
  *(NvS32 *)((char *)&v10->width + v23) = v18;
  *(NvS32 *)((char *)&v10->width + v22) = v21;
  *(NvS32 *)((char *)&v10->width + v20) = v19;
  if ( (v32 & 0x80000) == 0 && v97 == 259090157 )
    v14 = 1;
  v33 = v95;
  v10->width = v96;
  v10->height = v33;
  v34 = v99;
  if ( (v32 & 0x20000) == 0 )
    v34 = 1;
  v10->numMipmaps = v34;
  v86 = flipVertical != 0;
  if ( v34 >= 17 )
  {
    NVLogError(
      "NVHHDDSLoad",
      "Too many mipmaps (image->numMipmaps = %d) in file: %s\nIncrease NVHHDDS_MAX_MIPMAPS (== %d) in nvhhdds.h");
    goto LABEL_151;
  }
  NVHHDDSAllocData(v10);
  if ( !v10->dataBlock )
  {
    NVLogError("NVHHDDSLoad", "Failed to allocate memory block for image data storage: %s", v78);
    goto LABEL_151;
  }
  v35 = *(_QWORD *)&v10->numMipmaps;
  v36 = 1;
  v37 = 0;
  if ( HIDWORD(v35) )
    v36 = 6;
  v75 = v36;
  v76 = 0;
  v83 = v14;
  v84 = v5;
  v77 = v10;
  stream = v6;
  while ( (int)v35 < 1 )
  {
LABEL_115:
    if ( ++v76 >= v75 )
    {
      if ( v74 )
      {
        v61 = 0;
        v62 = 0;
        do
        {
          if ( (int)v35 >= 1 )
          {
            height = v10->height;
            width = v10->width;
            v65 = 0;
            do
            {
              v66 = height * width;
              if ( height * width >= 1 )
              {
                v67 = (char *)v10->data[v62];
                do
                {
                  v68 = *v67;
                  --v66;
                  *v67 = v67[2];
                  v67[2] = v68;
                  v67 += 4;
                }
                while ( v66 );
                LODWORD(v35) = v10->numMipmaps;
              }
              HIDWORD(v35) = height >> 1;
              if ( !(height >> 1) )
                HIDWORD(v35) = 1;
              v69 = width >> 1;
              ++v65;
              if ( !(width >> 1) )
                v69 = 1;
              ++v62;
              height = HIDWORD(v35);
              width = v69;
            }
            while ( v65 < (int)v35 );
          }
          ++v61;
        }
        while ( v61 < v75 );
        v6 = (FILE *)p[1];
        v5 = *p;
      }
      if ( v5 == 1 )
        fclose(v6);
      else
        AAsset_close((AAsset *)v6);
      free(p);
      return v10;
    }
  }
  HIDWORD(v35) = 0;
  v89 = v10->width;
  v90 = v10->height;
  while ( 1 )
  {
    v87 = HIDWORD(v35);
    v88 = v37;
    v38 = &v10->width + v37;
    v41 = (void *)v38[11];
    v40 = (char *)(v38 + 11);
    v39 = v41;
    v42 = *((_DWORD *)v40 + 96);
    if ( v5 == 1 )
    {
      fread(v39, *((_DWORD *)v40 + 96), 1u, v6);
    }
    else
    {
      v43 = AAsset_getLength((AAsset *)v6);
      v44 = AAsset_getLength((AAsset *)v6);
      v45 = AAsset_getRemainingLength((AAsset *)v6) - v44;
      v5 = v84;
      v46 = v45 + v43;
      v14 = v83;
      if ( v42 > v46 )
        v42 = v46;
      AAsset_read((AAsset *)v6, v39, v42);
    }
    if ( v14 == v86 )
      goto LABEL_105;
    v47 = *(char **)v40;
    if ( !v10->compressed )
    {
      v55 = v10->bytesPerPixel * v89;
      v56 = (char *)operator new[](v55);
      v57 = v90 >> 1;
      if ( v90 >> 1 >= 1 )
      {
        v58 = &v47[v55 * (v90 - 1)];
        do
        {
          qmemcpy(v56, v58, v55);
          qmemcpy(v58, v47, v55);
          qmemcpy(v47, v56, v55);
          v47 += v55;
          v58 -= v55;
          --v57;
        }
        while ( v57 );
      }
      operator delete[](v56);
      goto LABEL_104;
    }
    v48 = v10->format - 33777;
    if ( v48 > 2 )
      break;
    v81 = v47;
    v91 = v89 / 4;
    v49 = dword_2749B4[v48] * (v89 / 4);
    v50 = (void (__fastcall *)(char *, int))*(&off_661F28 + v48);
    v51 = (char *)operator new[](v49);
    v82 = v90 / 4;
    if ( (v90 / 4) >> 1 >= 1 )
    {
      v52 = v47;
      v53 = (v90 / 4) >> 1;
      v54 = &v81[v49 * (v82 - 1)];
      do
      {
        v50(v52, v91);
        v50(v54, v91);
        qmemcpy(v51, v54, v49);
        qmemcpy(v54, v52, v49);
        qmemcpy(v52, v51, v49);
        v52 += v49;
        --v53;
        v54 -= v49;
      }
      while ( v53 );
    }
    if ( v82 << 31 )
      v50(&v81[v49 * ((v90 / 4) >> 1)], v91);
    operator delete[](v51);
    v10 = v77;
LABEL_104:
    v6 = stream;
    v14 = v83;
    v5 = v84;
LABEL_105:
    v59 = v90 >> 1;
    if ( !(v90 >> 1) )
      v59 = 1;
    v60 = v89 >> 1;
    if ( !(v89 >> 1) )
      v60 = 1;
    if ( v10->compressed )
    {
      if ( v59 <= 4 )
        v59 = 4;
      if ( v60 <= 4 )
        v60 = 4;
    }
    v89 = v60;
    v90 = v59;
    LODWORD(v35) = v10->numMipmaps;
    v37 = v88 + 1;
    HIDWORD(v35) = v87 + 1;
    if ( v87 + 1 >= (int)v35 )
      goto LABEL_115;
  }
  NVLogError("NVHHDDSLoad", "Vertical flip of image data failed: %s", (const char *)v78);
  if ( v5 == 1 )
  {
    fclose(stream);
    goto LABEL_154;
  }
  v70 = (AAsset *)stream;
LABEL_153:
  AAsset_close(v70);
LABEL_154:
  free(p);
  dataBlock = v10->dataBlock;
  if ( dataBlock )
    operator delete[](dataBlock);
  operator delete(v10);
  return 0;
}
// 2749B4: using guessed type int dword_2749B4[3];
// 61CADE: using guessed type char byte_61CADE;
// 661F28: using guessed type void *off_661F28;
// 2741E8: using guessed type char buf[4];

//----- (002749E4) --------------------------------------------------------
void __fastcall LoadTextureFromDDSData(GLenum target, NvS32 startLevel, const NVHHDDSImage *pImage, int useMipmaps)
{
  GLenum v5; // r4
  GLsizei height; // r5
  GLsizei width; // r6
  int v9; // r8
  NvS32 *v10; // r9
  GLint v11; // r4
  NvS32 format; // r2
  int v13; // r2
  NvS32 numMipmaps; // r0
  NvS32 v15; // [sp+18h] [bp-28h]
  GLenum v16; // [sp+1Ch] [bp-24h]

  v5 = target;
  if ( target != 3553 )
    v5 = 34067;
  if ( pImage )
  {
    height = pImage->height;
    width = pImage->width;
    v16 = v5;
    if ( ((width - 1) & width) != 0 || !useMipmaps || ((height - 1) & height) != 0 )
    {
      v9 = startLevel + 1;
      v15 = 1;
    }
    else
    {
      numMipmaps = pImage->numMipmaps;
      if ( numMipmaps < 1 )
        goto LABEL_22;
      v9 = numMipmaps + startLevel;
      v15 = pImage->numMipmaps;
    }
    v10 = &pImage->width + startLevel;
    v11 = 0;
    do
    {
      format = pImage->format;
      if ( pImage->compressed )
        glCompressedTexImage2D(target, v11, format, width, height, 0, v10[v11 + 107], (const GLvoid *)v10[v11 + 11]);
      else
        glTexImage2D(
          target,
          v11,
          format,
          width,
          height,
          0,
          format,
          pImage->componentFormat,
          (const GLvoid *)v10[v11 + 11]);
      ++v11;
      if ( height != 1 )
        height >>= 1;
      if ( width != 1 )
        width >>= 1;
    }
    while ( startLevel + v11 < v9 );
    v5 = v16;
    if ( v15 >= 2 )
    {
      v13 = 1176241152;
LABEL_23:
      glTexParameterf(v5, 0x2801u, *(GLfloat *)&v13);
      glTexParameterf(v5, 0x2800u, 9729.0);
      glTexParameterf(v5, 0x2802u, 33071.0);
      sub_190AA0(v5, 0x2803u, 33071.0);
      return;
    }
LABEL_22:
    v13 = 1175979008;
    goto LABEL_23;
  }
}

//----- (00274B08) --------------------------------------------------------
void __fastcall NVHHDDSFree(NVHHDDSImage *image)
{
  void *dataBlock; // r0

  if ( image )
  {
    dataBlock = image->dataBlock;
    if ( dataBlock )
      operator delete[](dataBlock);
    sub_191374(image);
  }
}

//----- (00274B28) --------------------------------------------------------
GLuint __fastcall NvCreateTextureFromHHDDSImage(
        const NVHHDDSImage *image,
        int useMipmaps,
        NvS32 *width,
        NvS32 *height,
        NvBool *alpha,
        NvBool *isCubeMap)
{
  NvS32 numMipmaps; // r4
  NvS32 v11; // r0
  NvS32 v12; // r4
  NvS32 v13; // r0
  NvS32 v14; // r4
  NvS32 v15; // r0
  NvS32 v16; // r4
  NvS32 v17; // r0
  NvS32 v18; // r1
  GLenum v19; // r0
  GLuint textures[5]; // [sp+4h] [bp-14h] BYREF

  glGetError();
  textures[0] = 0;
  if ( isCubeMap )
    *isCubeMap = image->cubemap != 0;
  if ( width )
    *width = image->width;
  if ( height )
    *height = image->height;
  if ( alpha )
    *alpha = image->alpha != 0;
  glGenTextures(1, textures);
  if ( image->cubemap )
  {
    glBindTexture(0x8513u, textures[0]);
    LoadTextureFromDDSData(0x8516u, 0, image, useMipmaps);
    numMipmaps = image->numMipmaps;
    if ( !numMipmaps )
      numMipmaps = 1;
    LoadTextureFromDDSData(0x8515u, numMipmaps, image, useMipmaps);
    v11 = image->numMipmaps;
    if ( !v11 )
      v11 = 1;
    v12 = numMipmaps + v11;
    LoadTextureFromDDSData(0x8517u, v12, image, useMipmaps);
    v13 = image->numMipmaps;
    if ( !v13 )
      v13 = 1;
    v14 = v12 + v13;
    LoadTextureFromDDSData(0x8518u, v14, image, useMipmaps);
    v15 = image->numMipmaps;
    if ( !v15 )
      v15 = 1;
    v16 = v14 + v15;
    LoadTextureFromDDSData(0x8519u, v16, image, useMipmaps);
    v17 = image->numMipmaps;
    if ( !v17 )
      v17 = 1;
    v18 = v17 + v16;
    v19 = 34074;
  }
  else
  {
    glBindTexture(0xDE1u, textures[0]);
    v19 = 3553;
    v18 = 0;
  }
  LoadTextureFromDDSData(v19, v18, image, useMipmaps);
  if ( glGetError() )
    NVLogError("NvCreateTextureFromHHDDSImage error", (const unsigned __int8 *)&byte_61CADE);
  return textures[0];
}
// 61CADE: using guessed type char byte_61CADE;
// 274B28: using guessed type GLuint textures[5];

//----- (00274C64) --------------------------------------------------------
NVHHDDSImage *NVHHDDSAlloc()
{
  void *v0; // r4

  v0 = (void *)operator new(0x62Cu);
  memset(v0, 0, 0x62Cu);
  return (NVHHDDSImage *)v0;
}

//----- (00274C7E) --------------------------------------------------------
void *__fastcall NVHHDDSAllocData(NVHHDDSImage *image)
{
  NvS32 numMipmaps; // r6
  int v3; // r11
  int v4; // r1
  unsigned int v5; // r0
  int v6; // r5
  int v7; // r10
  __int64 v8; // r2
  int v9; // r12
  NvS32 *v10; // r1
  int v11; // r6
  NvS32 bytesPerPixel; // r5
  int v13; // r5
  NvS32 v14; // r4
  int v15; // r5
  void *result; // r0
  int v17; // r2
  int v18; // r2
  NvS32 *size; // r1
  int v20; // r0
  NvS32 *v21; // r3
  int v22; // t1
  int v23; // [sp+4h] [bp-24h]
  int v24; // [sp+8h] [bp-20h]

  if ( !image )
    return 0;
  numMipmaps = image->numMipmaps;
  LOWORD(v3) = -384;
  v4 = 1;
  if ( image->cubemap )
    v4 = 6;
  v5 = 0;
  HIWORD(v3) = -1;
  v6 = 0;
  v7 = 0;
  v23 = v4;
  do
  {
    if ( numMipmaps >= 1 )
    {
      v8 = *(_QWORD *)&image->width;
      v9 = 203;
      v24 = v6;
      v10 = &image->mipwidth[v6];
      do
      {
        if ( image->compressed )
        {
          v11 = ((int)v8 + 3) / 4 * ((HIDWORD(v8) + 3) / 4);
          bytesPerPixel = 16;
          if ( image->format == 33777 )
            bytesPerPixel = 8;
        }
        else
        {
          v11 = v8 * HIDWORD(v8);
          bytesPerPixel = image->bytesPerPixel;
        }
        v13 = bytesPerPixel * v11;
        v14 = v9 - 202;
        *(NvS32 *)((char *)v10 + v3) = v13;
        v5 += v13;
        *v10 = v8;
        v15 = v9 + 1;
        v10[96] = HIDWORD(v8);
        if ( HIDWORD(v8) != 1 )
          SHIDWORD(v8) >>= 1;
        ++v10;
        if ( (_DWORD)v8 != 1 )
          LODWORD(v8) = (int)v8 >> 1;
        numMipmaps = image->numMipmaps;
        ++v9;
      }
      while ( v14 < numMipmaps );
      v6 = v24 + v15 - 203;
    }
    ++v7;
  }
  while ( v7 < v23 );
  result = (void *)operator new[](v5);
  v17 = 1;
  if ( image->cubemap )
    v17 = 6;
  image->dataBlock = result;
  image->data[0] = result;
  v18 = v17 * numMipmaps;
  if ( v18 >= 2 )
  {
    size = image->size;
    v20 = v18 - 1;
    v21 = image->size;
    do
    {
      v22 = *v21++;
      --v20;
      *(size - 95) = v22 + *(NvS32 *)((char *)size + v3);
      size = v21;
    }
    while ( v20 );
    return image->dataBlock;
  }
  return result;
}

//----- (00274DA0) --------------------------------------------------------
NVHHDDSImage *__fastcall NVCompressToDXT(NVHHDDSImage *srcImage, NvS32 toFormat, NvS32 bMakeMipmaps)
{
  NvS32 format; // r3
  _DWORD *v5; // r5
  _DWORD *v6; // r4
  NvS32 height; // r0
  NvS32 width; // r2
  NvS32 numMipmaps; // r1
  NVHHDDSImage *v10; // r6
  int v12; // r2
  int v13; // r5
  int v14; // r8
  __int128 v15; // q4
  __int128 v16; // q5
  NvS8 *v17; // r0
  int v18; // r0
  int v19; // r1
  _WORD *v20; // r4
  int v21; // r6
  int v22; // r1
  int v23; // r1
  int v24; // r0
  int v25; // r0
  int v26; // r1
  int v27; // r1
  int v28; // r0
  int v29; // r0
  int v30; // r0
  unsigned int v31; // r2
  unsigned int v32; // r4
  unsigned int v33; // r1
  unsigned __int8 *v35; // r3
  unsigned int v36; // r1
  bool v37; // cf
  unsigned int v38; // r1
  bool v39; // cf
  unsigned int v40; // r1
  bool v41; // cf
  int v42; // r3
  __int128 v43; // q8
  unsigned int v44; // r9
  unsigned int v45; // r3
  unsigned int v46; // r5
  unsigned int v47; // r6
  unsigned int v48; // r8
  unsigned __int8 *v49; // r10
  int v50; // r8
  int v51; // r6
  unsigned __int8 v52; // r4
  char *v53; // r5
  int v54; // r9
  char *v55; // r11
  char *v56; // r1
  char *v57; // r0
  unsigned int v58; // r0
  unsigned int v59; // r0
  unsigned int v60; // r3
  char *v61; // r1
  int v62; // r1
  unsigned int v63; // r2
  char *v64; // r1
  int v65; // r0
  int v66; // r1
  int v67; // r8
  unsigned __int8 v68; // r5
  unsigned __int8 v69; // r6
  void *v70; // r0
  Color8888 v71; // r4
  int v72; // r0
  int v73; // r1
  void *v74; // r0
  unsigned int v75; // r4
  unsigned int v76; // r0
  unsigned int v77; // r3
  int v78; // r6
  int v79; // r0
  unsigned int v80; // r10
  unsigned int v81; // lr
  unsigned int v82; // r12
  unsigned int v83; // r5
  _WORD *v84; // r11
  unsigned int v85; // r3
  int v86; // r2
  int v87; // r1
  unsigned __int16 *v88; // r4
  unsigned int v89; // r3
  int v90; // r1
  unsigned int v91; // r2
  int v92; // r1
  unsigned int v93; // r2
  unsigned int v94; // r3
  int v95; // r1
  int v96; // r1
  unsigned int v97; // r2
  unsigned int v98; // r3
  int v99; // r1
  int v100; // r1
  __int16 v101; // r2
  __int16 v102; // r0
  __int16 v103; // r4
  NvS32 v104; // r0
  __int16 v105; // r5
  int v106; // r2
  __int64 v107; // kr10_8
  unsigned __int16 *v108; // r6
  _BOOL4 v109; // r5
  unsigned int v110; // r4
  int v111; // r11
  int v112; // r8
  char *v113; // r9
  int v114; // r1
  void *v115; // r0
  int v116; // r0
  unsigned int v117; // r1
  unsigned int v118; // r0
  unsigned int v119; // r1
  unsigned int v120; // r6
  int v121; // r12
  unsigned int v122; // lr
  unsigned int v123; // r11
  unsigned int v124; // r12
  unsigned int v125; // lr
  int v126; // r2
  unsigned int v127; // r5
  unsigned int v128; // r4
  int v129; // r0
  int v130; // r1
  unsigned int v131; // r3
  unsigned __int8 *v132; // r4
  unsigned int v133; // r5
  bool v134; // cf
  unsigned int v135; // r6
  unsigned int v136; // r3
  int v137; // r0
  int v138; // r1
  unsigned int v139; // r5
  unsigned int v140; // r6
  unsigned int v141; // r3
  int v142; // r0
  int v143; // r1
  unsigned int v144; // r5
  unsigned int v145; // r6
  unsigned int v146; // r3
  int v147; // r0
  int v148; // r1
  unsigned __int8 v149; // r2
  char v150; // r0
  char v151; // r1
  __int16 *v152; // r0
  char v153; // r0
  unsigned __int8 *v154; // r9
  int i; // r0
  unsigned int v156; // r6
  int v157; // r3
  char v158; // r2
  unsigned __int8 *v159; // r1
  unsigned int v160; // r5
  int v161; // r6
  char v162; // r3
  unsigned int v163; // r5
  int v164; // r6
  char v165; // r2
  unsigned int v166; // r3
  int v167; // r10
  NvS8 *v168; // r5
  int v169; // r4
  NvS8 *v170; // r0
  unsigned int v171; // r0
  int v172; // r8
  int v173; // r9
  int v174; // r11
  int v175; // r1
  unsigned int v176; // r4
  NvS8 *v177; // r0
  int v178; // r6
  Color8888 v179; // r3
  unsigned int v180; // r4
  int v181; // r8
  NvS8 *v182; // r0
  int v183; // r1
  int v184; // r11
  int v185; // r5
  Color8888 v186; // r3
  unsigned int v187; // r9
  int v188; // r8
  int v189; // r0
  Color8888 v190; // r4
  NvS8 *v191; // r0
  int v192; // r11
  int v193; // r6
  Color8888 v194; // r3
  unsigned int v195; // r4
  unsigned int v196; // r5
  int v197; // r0
  Color8888 v198; // r8
  NvS8 *v199; // r12
  unsigned int v200; // r1
  unsigned int v201; // r6
  unsigned int v202; // r0
  unsigned int v203; // lr
  NvS8 *v205; // r5
  unsigned int v209; // r1
  int v210; // r0
  __int16 v211; // r6
  unsigned int v212; // r2
  int v213; // r1
  void *dataBlock; // r0
  NVHHDDSImage *v216; // [sp+18h] [bp-170h]
  NvS32 *v218; // [sp+28h] [bp-160h]
  NVHHDDSImage *v219; // [sp+2Ch] [bp-15Ch]
  unsigned int v220; // [sp+30h] [bp-158h]
  int v221; // [sp+70h] [bp-118h]
  int v222; // [sp+74h] [bp-114h]
  int v223; // [sp+98h] [bp-F0h]
  int v224; // [sp+98h] [bp-F0h]
  int v225; // [sp+9Ch] [bp-ECh]
  NvS8 *v226; // [sp+A0h] [bp-E8h]
  _WORD *v227; // [sp+A4h] [bp-E4h]
  int v228; // [sp+A4h] [bp-E4h]
  int v229; // [sp+B0h] [bp-D8h]
  int v230; // [sp+B0h] [bp-D8h]
  int v231; // [sp+BCh] [bp-CCh]
  char v232; // [sp+BCh] [bp-CCh]
  NvS8 *v233; // [sp+BCh] [bp-CCh]
  unsigned __int16 *v234; // [sp+C0h] [bp-C8h]
  int v235; // [sp+C0h] [bp-C8h]
  char *v236; // [sp+C4h] [bp-C4h]
  __int16 v237; // [sp+C4h] [bp-C4h]
  __int16 v238; // [sp+C4h] [bp-C4h]
  NvS8 *v239; // [sp+C4h] [bp-C4h]
  int v240; // [sp+C8h] [bp-C0h]
  unsigned int v241; // [sp+C8h] [bp-C0h]
  __int16 v242; // [sp+C8h] [bp-C0h]
  Color8888 v243; // [sp+C8h] [bp-C0h]
  unsigned int v244; // [sp+CCh] [bp-BCh]
  char *v245; // [sp+CCh] [bp-BCh]
  unsigned int v246; // [sp+CCh] [bp-BCh]
  unsigned int v247; // [sp+D0h] [bp-B8h]
  int v248; // [sp+D0h] [bp-B8h]
  unsigned int v249; // [sp+D0h] [bp-B8h]
  unsigned int v250; // [sp+D4h] [bp-B4h]
  unsigned int v251; // [sp+D4h] [bp-B4h]
  int v253; // [sp+DCh] [bp-ACh]
  NvS8 *v254; // [sp+DCh] [bp-ACh]
  __int128 v255; // [sp+E0h] [bp-A8h]
  __int16 v256; // [sp+F8h] [bp-90h] BYREF
  __int16 v257; // [sp+FAh] [bp-8Eh]
  __int16 v258; // [sp+FCh] [bp-8Ch]
  __int16 v259; // [sp+FEh] [bp-8Ah]
  __int16 v260; // [sp+100h] [bp-88h]
  __int16 v261; // [sp+102h] [bp-86h]
  __int16 v262; // [sp+104h] [bp-84h] BYREF
  __int16 v263; // [sp+106h] [bp-82h]
  unsigned __int16 v264[16]; // [sp+108h] [bp-80h] BYREF
  unsigned __int8 v265; // [sp+128h] [bp-60h] BYREF
  unsigned __int8 v266; // [sp+129h] [bp-5Fh]
  unsigned __int8 v267; // [sp+12Ah] [bp-5Eh]
  unsigned __int8 v268; // [sp+12Bh] [bp-5Dh]
  unsigned __int8 v269; // [sp+12Ch] [bp-5Ch]
  unsigned __int8 v270; // [sp+12Dh] [bp-5Bh]
  unsigned __int8 v271; // [sp+12Eh] [bp-5Ah]
  unsigned __int8 v272; // [sp+12Fh] [bp-59h]
  unsigned __int8 v273; // [sp+130h] [bp-58h]
  unsigned __int8 v274; // [sp+131h] [bp-57h]
  unsigned __int8 v275; // [sp+132h] [bp-56h]
  unsigned __int8 v276; // [sp+133h] [bp-55h]
  unsigned __int8 v277; // [sp+134h] [bp-54h]
  unsigned __int8 v278; // [sp+135h] [bp-53h]
  unsigned __int8 v279; // [sp+136h] [bp-52h]
  unsigned __int8 v280; // [sp+137h] [bp-51h]
  int v281[2]; // [sp+138h] [bp-50h]
  NvS8 *v282; // [sp+140h] [bp-48h]
  int v283; // [sp+144h] [bp-44h]

  if ( !srcImage )
    return 0;
  if ( srcImage->cubemap )
  {
    NVLogError("NVCompressToDXT", "!> Error: cubemap compression not yet supported.");
    return 0;
  }
  format = srcImage->format;
  s_srcType = srcImage->componentFormat;
  s_srcFormat = format;
  v5 = (_DWORD *)operator new(0x62Cu);
  v6 = v5 + 6;
  memset(v5 + 6, 0, 0x614u);
  height = srcImage->height;
  width = srcImage->width;
  *((_QWORD *)v5 + 1) = 0x140100000004LL;
  *((_QWORD *)v5 + 2) = 0x100000001LL;
  *(_QWORD *)v5 = __PAIR64__(height, width);
  v5[8] = toFormat;
  v216 = srcImage;
  numMipmaps = srcImage->numMipmaps;
  if ( width > height )
    height = width;
  v219 = (NVHHDDSImage *)v5;
  if ( numMipmaps < 2 )
  {
    _ZF = bMakeMipmaps == 0;
    if ( bMakeMipmaps )
      _ZF = height == 0;
    if ( _ZF )
    {
      *v6 = 1;
    }
    else
    {
      v12 = 0;
      *v6 = 0;
      do
      {
        ++v12;
        height >>= 1;
      }
      while ( height );
      *v6 = v12;
    }
    v10 = (NVHHDDSImage *)v5;
  }
  else
  {
    v5[6] = numMipmaps;
    v10 = (NVHHDDSImage *)v5;
  }
  v226 = (NvS8 *)v216->data[0];
  if ( !v226 )
  {
LABEL_523:
    dataBlock = v10->dataBlock;
    if ( dataBlock )
      operator delete[](dataBlock);
    operator delete(v5);
    return 0;
  }
  NVHHDDSAllocData(v10);
  if ( !v10->dataBlock )
  {
    NVLogError("NVCompressToDXT", "!> Error allocating DXT conversion buffer");
    goto LABEL_523;
  }
  v14 = v216->height;
  v13 = v216->width;
  *(_QWORD *)&v15 = loc_275A20;
  *((_QWORD *)&v15 + 1) = loc_275A28;
  *(_QWORD *)&v16 = loc_275A30;
  *((_QWORD *)&v16 + 1) = loc_275A38;
  v220 = 0;
  while ( 1 )
  {
    v218 = &v10->width + v220;
    v20 = (_WORD *)v218[11];
    NVLogDebug("NVCompressToDXT", "processing mip level %d, %dx%d", v220, v13, v14);
    v225 = v13;
    v221 = v14;
    if ( v14 >= 1 )
    {
      v21 = 0;
      while ( 1 )
      {
        v22 = v21 * v13;
        if ( (unsigned int)(s_srcType - 32819) < 2 || s_srcType == 33635 )
        {
LABEL_42:
          v23 = (int)&v226[2 * v22];
        }
        else
        {
          if ( s_srcType == 5121 )
          {
            switch ( s_srcFormat )
            {
              case 6406:
              case 6409:
                v24 = (v21 | 1) * v13;
                v281[0] = (int)&v226[v22];
                goto LABEL_49;
              case 6407:
                v23 = (int)&v226[3 * v22];
                goto LABEL_45;
              case 6408:
                v23 = (int)&v226[4 * v22];
                goto LABEL_45;
              case 6410:
                goto LABEL_42;
              default:
                NVLogError("GetTexelAddress", "Unsupported format/type pair [0x%x 0x%x]", s_srcFormat, 5121);
                goto LABEL_44;
            }
          }
          NVLogError("GetTexelAddress", "Unsupported type [0x%x]", s_srcType);
LABEL_44:
          v23 = 0;
        }
LABEL_45:
        v281[0] = v23;
        v24 = (v21 | 1) * v13;
        if ( (unsigned int)(s_srcType - 32819) < 2 )
          break;
        if ( s_srcType == 5121 )
        {
LABEL_49:
          switch ( s_srcFormat )
          {
            case 6406:
            case 6409:
              goto LABEL_53;
            case 6407:
              v24 *= 3;
LABEL_53:
              v25 = (int)&v226[v24];
              break;
            case 6408:
              v25 = (int)&v226[4 * v24];
              break;
            case 6410:
              goto LABEL_50;
            default:
              NVLogError("GetTexelAddress", "Unsupported format/type pair [0x%x 0x%x]", s_srcFormat, 5121);
              goto LABEL_55;
          }
        }
        else
        {
          if ( s_srcType == 33635 )
            break;
          NVLogError("GetTexelAddress", "Unsupported type [0x%x]", s_srcType);
LABEL_55:
          v25 = 0;
        }
LABEL_56:
        v281[1] = v25;
        v26 = (v21 | 2) * v13;
        if ( (unsigned int)(s_srcType - 32819) < 2 )
          goto LABEL_61;
        if ( s_srcType == 5121 )
        {
          switch ( s_srcFormat )
          {
            case 6406:
            case 6409:
              v28 = (v21 | 3) * v13;
              v282 = &v226[v26];
              goto LABEL_71;
            case 6407:
              v27 = (int)&v226[3 * v26];
              goto LABEL_67;
            case 6408:
              v27 = (int)&v226[4 * v26];
              goto LABEL_67;
            case 6410:
              goto LABEL_61;
            default:
              NVLogError("GetTexelAddress", "Unsupported format/type pair [0x%x 0x%x]", s_srcFormat, 5121);
              goto LABEL_66;
          }
        }
        if ( s_srcType == 33635 )
        {
LABEL_61:
          v27 = (int)&v226[2 * v26];
        }
        else
        {
          NVLogError("GetTexelAddress", "Unsupported type [0x%x]", s_srcType);
LABEL_66:
          v27 = 0;
        }
LABEL_67:
        v282 = (NvS8 *)v27;
        v28 = (v21 | 3) * v13;
        if ( (unsigned int)(s_srcType - 32819) < 2 )
        {
LABEL_72:
          v29 = (int)&v226[2 * v28];
          goto LABEL_78;
        }
        if ( s_srcType == 5121 )
        {
LABEL_71:
          switch ( s_srcFormat )
          {
            case 6406:
            case 6409:
              goto LABEL_75;
            case 6407:
              v28 *= 3;
LABEL_75:
              v29 = (int)&v226[v28];
              break;
            case 6408:
              v29 = (int)&v226[4 * v28];
              break;
            case 6410:
              goto LABEL_72;
            default:
              NVLogError("GetTexelAddress", "Unsupported format/type pair [0x%x 0x%x]", s_srcFormat, 5121);
              goto LABEL_77;
          }
        }
        else
        {
          if ( s_srcType == 33635 )
            goto LABEL_72;
          NVLogError("GetTexelAddress", "Unsupported type [0x%x]", s_srcType);
LABEL_77:
          v29 = 0;
        }
LABEL_78:
        v283 = v29;
        v222 = v21;
        if ( v13 >= 1 )
        {
          v229 = 0;
          v253 = 0;
          while ( 1 )
          {
            v234 = v264;
            v49 = &v265;
            v231 = 0;
            v236 = 0;
            v245 = 0;
            v240 = 0;
            v227 = v20;
            v50 = 0;
            v247 = 0;
            v51 = 1;
            v52 = 0;
            v250 = 0;
            do
            {
              v53 = 0;
              v54 = v281[v50];
              v55 = (char *)(v54 + v229);
              do
              {
                v56 = &v53[v253];
                if ( (unsigned int)(s_srcType - 32819) < 2 || s_srcType == 33635 )
                {
LABEL_128:
                  v57 = (char *)(v54 + 2 * (_DWORD)v56);
                }
                else if ( s_srcType == 5121 )
                {
                  v57 = v55;
                  switch ( s_srcFormat )
                  {
                    case 6406:
                    case 6409:
                      v57 = &v56[v54];
                      break;
                    case 6407:
                      v57 = (char *)(3 * (_DWORD)v56 + v54);
                      break;
                    case 6408:
                      break;
                    case 6410:
                      goto LABEL_128;
                    default:
                      NVLogError("GetTexelAddress", "Unsupported format/type pair [0x%x 0x%x]", s_srcFormat, 5121);
                      goto LABEL_130;
                  }
                }
                else
                {
                  NVLogError("GetTexelAddress", "Unsupported type [0x%x]", s_srcType);
LABEL_130:
                  v57 = 0;
                }
                v58 = (unsigned int)TexelToColor8888(v57);
                v53[(_DWORD)v49] = HIBYTE(v58);
                if ( toFormat == 33777 && v58 < 0x7F000000 )
                {
                  v231 = 1;
                }
                else
                {
                  v59 = 3 * (unsigned __int8)v58
                      + (unsigned __int8)__ROR4__(v58, 16)
                      + 2 * (2 * BYTE1(v58) + (unsigned __int8)__ROR4__(v58, 8));
                  v234[(_DWORD)v53] = v59;
                  if ( v51 << 24 )
                  {
                    v247 = v59;
                    v250 = v59;
                    v51 = 0;
                    v240 = v50;
                    v245 = v53;
                    v52 = v50;
                    v236 = v53;
                  }
                  else
                  {
                    v60 = v250;
                    v51 = 0;
                    v61 = v245;
                    if ( (unsigned __int16)v250 < (unsigned int)(unsigned __int16)v59 )
                      v61 = v53;
                    v245 = v61;
                    v62 = v240;
                    if ( (unsigned __int16)v250 < (unsigned int)(unsigned __int16)v59 )
                      v62 = v50;
                    v240 = v62;
                    if ( (unsigned __int16)v250 < (unsigned int)(unsigned __int16)v59 )
                      v60 = v59;
                    v63 = v247;
                    v250 = v60;
                    v64 = v236;
                    if ( v59 < (unsigned __int16)v247 )
                      v64 = v53;
                    v236 = v64;
                    if ( v59 < (unsigned __int16)v247 )
                    {
                      v52 = v50;
                      v63 = v59;
                    }
                    v247 = v63;
                  }
                }
                ++v53;
                v55 += 4;
              }
              while ( v53 != byte_4 );
              ++v50;
              v49 += 4;
              v234 += 4;
            }
            while ( v50 != 4 );
            v65 = v281[v52];
            v66 = v253 + (unsigned __int8)v236;
            if ( (unsigned int)(s_srcType - 32819) < 2 || s_srcType == 33635 )
              break;
            if ( s_srcType != 5121 )
            {
              NVLogError("GetTexelAddress", "Unsupported type [0x%x]", s_srcType);
LABEL_159:
              v70 = 0;
              goto LABEL_160;
            }
            v67 = v231;
            v68 = v240;
            v69 = (unsigned __int8)v245;
            switch ( s_srcFormat )
            {
              case 6406:
              case 6409:
                v70 = (void *)(v65 + v66);
                break;
              case 6407:
                v70 = (void *)(v65 + 3 * v66);
                break;
              case 6408:
                v70 = (void *)(v65 + 4 * v66);
                break;
              case 6410:
                v70 = (void *)(v65 + 2 * v66);
                break;
              default:
                NVLogError("GetTexelAddress", "Unsupported format/type pair [0x%x 0x%x]", s_srcFormat, 5121);
                goto LABEL_159;
            }
LABEL_161:
            v71 = TexelToColor8888(v70);
            v72 = v281[v68];
            v73 = v253 + v69;
            if ( (unsigned int)(s_srcType - 32819) < 2 || s_srcType == 33635 )
            {
LABEL_168:
              v74 = (void *)(v72 + 2 * v73);
            }
            else if ( s_srcType == 5121 )
            {
              switch ( s_srcFormat )
              {
                case 6406:
                case 6409:
                  v74 = (void *)(v72 + v73);
                  break;
                case 6407:
                  v74 = (void *)(v72 + 3 * v73);
                  break;
                case 6408:
                  v74 = (void *)(v72 + 4 * v73);
                  break;
                case 6410:
                  goto LABEL_168;
                default:
                  NVLogError("GetTexelAddress", "Unsupported format/type pair [0x%x 0x%x]", s_srcFormat, 5121);
                  goto LABEL_170;
              }
            }
            else
            {
              NVLogError("GetTexelAddress", "Unsupported type [0x%x]", s_srcType);
LABEL_170:
              v74 = 0;
            }
            v75 = (*(unsigned int *)&v71 >> 5) & 0x7E0 | (*(_DWORD *)&v71 << 8) & 0xF800 | (*(unsigned int *)&v71 >> 19) & 0x1F;
            v76 = (unsigned int)TexelToColor8888(v74);
            v77 = (v76 >> 5) & 0x7E0 | (v76 << 8) & 0xF800 | (v76 >> 19) & 0x1F;
            v241 = v75;
            v246 = v77;
            if ( v67 << 24 || v75 == v77 )
            {
              v106 = 0;
              v80 = 0;
              v107 = 2863311531LL * (2 * (unsigned __int16)v250 + (unsigned int)(unsigned __int16)v247 + 1);
              v108 = v264;
              v109 = v77 < v75;
              if ( v77 > v75 )
                LOWORD(v75) = v77;
              v237 = v75;
              v110 = (unsigned __int16)((2 * (unsigned __int16)v247 + (unsigned int)(unsigned __int16)v250 + 1) / 3);
              do
              {
                v111 = 0;
                v248 = v106;
                v112 = v281[v106];
                v113 = (char *)(v112 + v229);
                do
                {
                  v114 = v111 + v253;
                  if ( (unsigned int)(s_srcType - 32819) < 2 || s_srcType == 33635 )
                  {
LABEL_213:
                    v115 = (void *)(v112 + 2 * v114);
                  }
                  else if ( s_srcType == 5121 )
                  {
                    v115 = v113;
                    switch ( s_srcFormat )
                    {
                      case 6406:
                      case 6409:
                        v115 = (void *)(v112 + v114);
                        break;
                      case 6407:
                        v115 = (void *)(3 * v114 + v112);
                        break;
                      case 6408:
                        break;
                      case 6410:
                        goto LABEL_213;
                      default:
                        NVLogError("GetTexelAddress", "Unsupported format/type pair [0x%x 0x%x]", s_srcFormat, 5121);
                        goto LABEL_215;
                    }
                  }
                  else
                  {
                    NVLogError("GetTexelAddress", "Unsupported type [0x%x]", s_srcType);
LABEL_215:
                    v115 = 0;
                  }
                  if ( *(unsigned int *)&TexelToColor8888(v115) >= 0x7F000000 )
                  {
                    v117 = v108[v111];
                    v116 = v109;
                    if ( v110 < v117 )
                    {
                      v116 = 2;
                      if ( (unsigned __int16)(HIDWORD(v107) >> 1) < v117 )
                        v116 = !v109;
                    }
                  }
                  else
                  {
                    v116 = 3;
                  }
                  ++v111;
                  v80 = (v116 << 30) | (v80 >> 2);
                  v113 += 4;
                }
                while ( v111 != 4 );
                v108 += 4;
                v106 = v248 + 1;
              }
              while ( v248 != 3 );
              v103 = v241;
              if ( v246 < v241 )
                v103 = v246;
              v104 = toFormat;
              v84 = v227;
              v105 = v237;
            }
            else
            {
              v78 = 0;
              v79 = 0;
              if ( v75 < v77 )
                v78 = 1;
              v80 = 0;
              v81 = ((unsigned __int16)v247 + (unsigned int)(unsigned __int16)v250) >> 1;
              v82 = (unsigned __int16)((3 * (unsigned __int16)v250 + (unsigned int)(unsigned __int16)v247 + 2) >> 2);
              v83 = (unsigned __int16)((3 * (unsigned __int16)v247 + (unsigned int)(unsigned __int16)v250 + 2) >> 2);
              v84 = v227;
              do
              {
                v85 = v264[4 * v79];
                v86 = v78;
                if ( v83 < v85 )
                {
                  v86 = v78 | 2;
                  if ( v81 < v85 )
                  {
                    v87 = 3;
                    if ( v82 < v85 )
                      v87 = 1;
                    v86 = v87 ^ v78;
                  }
                }
                v88 = &v264[4 * v79];
                v89 = (v86 << 30) | (v80 >> 2);
                v90 = v78;
                v91 = v88[1];
                if ( v83 < v91 )
                {
                  v90 = v78 | 2;
                  if ( v81 < v91 )
                  {
                    v92 = 3;
                    if ( v82 < v91 )
                      v92 = 1;
                    v90 = v92 ^ v78;
                  }
                }
                v93 = v88[2];
                v94 = (v90 << 30) | (v89 >> 2);
                v95 = v78;
                if ( v83 < v93 )
                {
                  v95 = v78 | 2;
                  if ( v81 < v93 )
                  {
                    v96 = 3;
                    if ( v82 < v93 )
                      v96 = 1;
                    v95 = v96 ^ v78;
                  }
                }
                v97 = v88[3];
                v98 = (v95 << 30) | (v94 >> 2);
                v99 = v78;
                if ( v83 < v97 )
                {
                  v99 = v78 | 2;
                  if ( v81 < v97 )
                  {
                    v100 = 3;
                    if ( v82 < v97 )
                      v100 = 1;
                    v99 = v100 ^ v78;
                  }
                }
                ++v79;
                v80 = (v99 << 30) | (v98 >> 2);
              }
              while ( v79 != 4 );
              v101 = v246;
              v102 = v246;
              if ( v241 > v246 )
                v102 = v241;
              if ( v241 < v246 )
                v101 = v241;
              v103 = v102;
              v104 = toFormat;
              v105 = v101;
            }
            if ( v104 == 33779 )
            {
              v238 = v105;
              v242 = v103;
              v118 = v266;
              v119 = v265;
              if ( v265 > (unsigned int)v266 )
                v119 = v266;
              if ( v119 > v267 )
                v119 = v267;
              if ( v119 > v268 )
                v119 = v268;
              if ( v119 > v269 )
                v119 = v269;
              if ( v119 > v270 )
                v119 = v270;
              if ( v119 > v271 )
                LOBYTE(v119) = v271;
              if ( (unsigned __int8)v119 > (unsigned int)v272 )
                LOBYTE(v119) = v272;
              if ( (unsigned __int8)v119 > (unsigned int)v273 )
                LOBYTE(v119) = v273;
              if ( (unsigned __int8)v119 > (unsigned int)v274 )
                LOBYTE(v119) = v274;
              if ( (unsigned __int8)v119 > (unsigned int)v275 )
                LOBYTE(v119) = v275;
              if ( (unsigned __int8)v119 > (unsigned int)v276 )
                LOBYTE(v119) = v276;
              if ( (unsigned __int8)v119 > (unsigned int)v277 )
                LOBYTE(v119) = v277;
              if ( (unsigned __int8)v119 > (unsigned int)v278 )
                LOBYTE(v119) = v278;
              if ( (unsigned __int8)v119 > (unsigned int)v279 )
                LOBYTE(v119) = v279;
              if ( (unsigned __int8)v119 > (unsigned int)v280 )
                LOBYTE(v119) = v280;
              if ( v265 > (unsigned int)v266 )
                v118 = v265;
              v44 = (unsigned __int8)v119;
              if ( v118 <= v267 )
                v118 = v267;
              if ( v118 <= v268 )
                v118 = v268;
              if ( v118 <= v269 )
                v118 = v269;
              if ( v118 <= v270 )
                v118 = v270;
              if ( v118 <= v271 )
                LOBYTE(v118) = v271;
              if ( (unsigned __int8)v118 <= (unsigned int)v272 )
                LOBYTE(v118) = v272;
              if ( (unsigned __int8)v118 <= (unsigned int)v273 )
                LOBYTE(v118) = v273;
              if ( (unsigned __int8)v118 <= (unsigned int)v274 )
                LOBYTE(v118) = v274;
              if ( (unsigned __int8)v118 <= (unsigned int)v275 )
                LOBYTE(v118) = v275;
              v256 = (unsigned __int8)v119;
              if ( (unsigned __int8)v118 <= (unsigned int)v276 )
                LOBYTE(v118) = v276;
              if ( (unsigned __int8)v118 <= (unsigned int)v277 )
                LOBYTE(v118) = v277;
              if ( (unsigned __int8)v118 <= (unsigned int)v278 )
                LOBYTE(v118) = v278;
              if ( (unsigned __int8)v118 <= (unsigned int)v279 )
                LOBYTE(v118) = v279;
              if ( (unsigned __int8)v118 <= (unsigned int)v280 )
                LOBYTE(v118) = v280;
              v263 = (unsigned __int8)v118;
              v244 = (unsigned __int8)v118;
              if ( (unsigned __int8)v118 - (unsigned __int8)v119 < 129
                || (unsigned __int8)v118 <= 0xFCu && (unsigned __int8)v119 > 2u )
              {
                goto LABEL_292;
              }
              v30 = 0;
              LOWORD(v31) = 255;
              LOWORD(v32) = 0;
              do
              {
                v33 = *(&v265 + 4 * v30);
                _CF = v33 >= 3;
                if ( v33 >= 3 )
                  _CF = v33 - 253 >= 3;
                if ( _CF )
                {
                  if ( (unsigned __int16)v31 > v33 )
                    LOWORD(v31) = *(&v265 + 4 * v30);
                  if ( (unsigned __int16)v32 < v33 )
                    LOWORD(v32) = *(&v265 + 4 * v30);
                }
                v35 = &v265 + 4 * v30;
                v36 = v35[1];
                v37 = v36 >= 3;
                if ( v36 >= 3 )
                  v37 = v36 - 253 >= 3;
                if ( v37 )
                {
                  if ( (unsigned __int16)v31 > v36 )
                    LOWORD(v31) = v35[1];
                  if ( (unsigned __int16)v32 < v36 )
                    LOWORD(v32) = v35[1];
                }
                v38 = v35[2];
                v39 = v38 >= 3;
                if ( v38 >= 3 )
                  v39 = v38 - 253 >= 3;
                if ( v39 )
                {
                  if ( (unsigned __int16)v31 > v38 )
                    LOWORD(v31) = v35[2];
                  if ( (unsigned __int16)v32 < v38 )
                    LOWORD(v32) = v35[2];
                }
                v40 = v35[3];
                v41 = v40 >= 3;
                if ( v40 >= 3 )
                  v41 = v40 - 253 >= 3;
                if ( v41 )
                {
                  if ( (unsigned __int16)v31 > v40 )
                    LOWORD(v31) = v35[3];
                  if ( (unsigned __int16)v32 < v40 )
                    LOWORD(v32) = v35[3];
                }
                ++v30;
              }
              while ( v30 != 4 );
              v42 = (unsigned __int16)v32 - (unsigned __int16)v31;
              if ( v42 <= 127 && v42 )
              {
                v263 = 255;
                v244 = 255;
                v43 = v15;
                v44 = 0;
                v256 = 0;
                v257 = v31;
                v45 = ((unsigned __int16)v31 + 4 * (unsigned int)(unsigned __int16)v32) / 5;
                v46 = ((unsigned __int16)v32 + 4 * (unsigned int)(unsigned __int16)v31) / 5;
                v262 = v32;
                v258 = v46;
                v47 = (3 * (unsigned __int16)v31 + 2 * (unsigned int)(unsigned __int16)v32) / 5;
                v261 = v45;
                v259 = v47;
                v223 = 1;
                v48 = (3 * (unsigned __int16)v32 + 2 * (unsigned int)(unsigned __int16)v31) / 5;
                v260 = v48;
              }
              else
              {
LABEL_292:
                v43 = v16;
                v120 = v44 + 6 * v244;
                v121 = (613566757 * (unsigned __int64)v120) >> 32;
                v122 = v120 - v121;
                v48 = (3 * v244 + 4 * v44) / 7;
                v47 = (3 * v44 + 4 * v244) / 7;
                v46 = (5 * v244 + 2 * v44) / 7;
                v258 = v46;
                v45 = (5 * v44 + 2 * v244) / 7;
                v31 = (v121 + (v122 >> 1)) >> 2;
                v259 = v47;
                v260 = v48;
                v261 = v45;
                v257 = v31;
                v32 = (v244 + 6 * v44) / 7;
                v262 = v32;
                v223 = 0;
              }
              v232 = v31;
              v123 = (unsigned __int16)v31;
              v124 = (unsigned __int16)v46;
              v255 = v43;
              v125 = (unsigned __int16)v47;
              v251 = (unsigned __int16)v45;
              v126 = 0;
              v249 = (unsigned __int16)v32;
              while ( 1 )
              {
                v127 = v123;
                v128 = *(&v265 + 4 * v126);
                if ( v128 >= v44 && (v127 = v123, v123 >= v128) )
                {
                  v129 = 1;
                  v130 = 0;
                  v127 = v44;
                  v131 = v123;
                }
                else if ( v127 <= v128 && v124 >= v128 )
                {
                  v129 = 2;
                  v130 = 1;
                  v131 = v124;
                }
                else if ( v124 <= v128 && v125 >= v128 )
                {
                  v129 = 3;
                  v130 = 2;
                  v127 = v124;
                  v131 = v125;
                }
                else if ( v125 <= v128 && (unsigned __int16)v48 >= v128 )
                {
                  v129 = 4;
                  v130 = 3;
                  v127 = v125;
                  v131 = (unsigned __int16)v48;
                }
                else if ( (unsigned __int16)v48 <= v128 && v251 >= v128 )
                {
                  v131 = v251;
                  v129 = 5;
                  v130 = 4;
                  v127 = (unsigned __int16)v48;
                }
                else if ( v251 <= v128 && v249 >= v128 )
                {
                  v131 = v249;
                  v129 = 6;
                  v130 = 5;
                  v127 = v251;
                }
                else
                {
                  if ( v249 > v128 || v244 < v128 )
                    goto LABEL_318;
                  v129 = 7;
                  v130 = 6;
                  v131 = v244;
                  v127 = v249;
                }
                if ( (int)(v128 - v127) >= (int)(v131 - v128) )
                  v130 = v129;
                *(&v265 + 4 * v126) = *((_BYTE *)&v255 + 2 * v130);
LABEL_318:
                v132 = &v265 + 4 * v126;
                v133 = v132[1];
                v134 = v133 >= v44;
                if ( v133 >= v44 )
                  v134 = v123 >= v133;
                if ( v134 )
                {
                  v137 = 1;
                  v138 = 0;
                  v135 = v44;
                  v136 = v123;
                }
                else
                {
                  v135 = v124;
                  if ( v123 <= v133 && (v135 = v124, v124 >= v133) )
                  {
                    v137 = 2;
                    v138 = 1;
                    v135 = v123;
                    v136 = v124;
                  }
                  else if ( v135 <= v133 && v125 >= v133 )
                  {
                    v137 = 3;
                    v138 = 2;
                    v136 = v125;
                  }
                  else
                  {
                    v135 = (unsigned __int16)v48;
                    if ( v125 <= v133 && (v135 = (unsigned __int16)v48, (unsigned __int16)v48 >= v133) )
                    {
                      v137 = 4;
                      v138 = 3;
                      v135 = v125;
                      v136 = (unsigned __int16)v48;
                    }
                    else if ( v135 <= v133 && v251 >= v133 )
                    {
                      v136 = v251;
                      v137 = 5;
                      v138 = 4;
                    }
                    else
                    {
                      v135 = v249;
                      if ( v251 <= v133 && (v135 = v249, v249 >= v133) )
                      {
                        v136 = v249;
                        v137 = 6;
                        v138 = 5;
                        v135 = v251;
                      }
                      else
                      {
                        if ( v135 > v133 || v244 < v133 )
                          goto LABEL_343;
                        v136 = v244;
                        v137 = 7;
                        v138 = 6;
                      }
                    }
                  }
                }
                if ( (int)(v133 - v135) >= (int)(v136 - v133) )
                  v138 = v137;
                v132[1] = *((_BYTE *)&v255 + 2 * v138);
LABEL_343:
                v139 = v132[2];
                v140 = v123;
                if ( v139 >= v44 && (v140 = v123, v123 >= v139) )
                {
                  v142 = 1;
                  v143 = 0;
                  v140 = v44;
                  v141 = v123;
                }
                else if ( v140 <= v139 && v124 >= v139 )
                {
                  v142 = 2;
                  v143 = 1;
                  v141 = v124;
                }
                else
                {
                  v140 = v125;
                  if ( v124 <= v139 && (v140 = v125, v125 >= v139) )
                  {
                    v142 = 3;
                    v143 = 2;
                    v140 = v124;
                    v141 = v125;
                  }
                  else if ( v140 <= v139 && (unsigned __int16)v48 >= v139 )
                  {
                    v142 = 4;
                    v143 = 3;
                    v141 = (unsigned __int16)v48;
                  }
                  else
                  {
                    v140 = v251;
                    if ( (unsigned __int16)v48 <= v139 && (v140 = v251, v251 >= v139) )
                    {
                      v141 = v251;
                      v142 = 5;
                      v143 = 4;
                      v140 = (unsigned __int16)v48;
                    }
                    else if ( v140 <= v139 && v249 >= v139 )
                    {
                      v141 = v249;
                      v142 = 6;
                      v143 = 5;
                    }
                    else
                    {
                      if ( v249 > v139 || v244 < v139 )
                        goto LABEL_367;
                      v141 = v244;
                      v140 = v249;
                      v142 = 7;
                      v143 = 6;
                    }
                  }
                }
                if ( (int)(v139 - v140) >= (int)(v141 - v139) )
                  v143 = v142;
                v132[2] = *((_BYTE *)&v255 + 2 * v143);
LABEL_367:
                v144 = v132[3];
                v145 = v123;
                if ( v144 >= v44 )
                {
                  v145 = v123;
                  if ( v123 >= v144 )
                  {
                    v147 = 1;
                    v148 = 0;
                    v145 = v44;
                    v146 = v123;
                    goto LABEL_388;
                  }
                }
                if ( v145 <= v144 && v124 >= v144 )
                {
                  v147 = 2;
                  v148 = 1;
                  v146 = v124;
                  goto LABEL_388;
                }
                v145 = v125;
                if ( v124 <= v144 )
                {
                  v145 = v125;
                  if ( v125 >= v144 )
                  {
                    v147 = 3;
                    v148 = 2;
                    v145 = v124;
                    v146 = v125;
                    goto LABEL_388;
                  }
                }
                if ( v145 <= v144 && (unsigned __int16)v48 >= v144 )
                {
                  v147 = 4;
                  v148 = 3;
                  v146 = (unsigned __int16)v48;
                  goto LABEL_388;
                }
                v145 = v251;
                if ( (unsigned __int16)v48 <= v144 )
                {
                  v145 = v251;
                  if ( v251 >= v144 )
                  {
                    v146 = v251;
                    v147 = 5;
                    v148 = 4;
                    v145 = (unsigned __int16)v48;
                    goto LABEL_388;
                  }
                }
                if ( v145 <= v144 && v249 >= v144 )
                {
                  v146 = v249;
                  v147 = 6;
                  v148 = 5;
                  goto LABEL_388;
                }
                if ( v249 <= v144 && v244 >= v144 )
                {
                  v146 = v244;
                  v145 = v249;
                  v147 = 7;
                  v148 = 6;
LABEL_388:
                  if ( (int)(v144 - v145) >= (int)(v146 - v144) )
                    v148 = v147;
                  v132[3] = *((_BYTE *)&v255 + 2 * v148);
                }
                if ( ++v126 == 4 )
                {
                  v149 = 0;
                  v150 = v244;
                  if ( v223 )
                    v150 = v232;
                  v151 = 0;
                  *(_BYTE *)v227 = v150;
                  v152 = &v256;
                  if ( v223 )
                    v152 = &v262;
                  v153 = *(_BYTE *)v152;
                  *(_DWORD *)(v227 + 1) = 0;
                  v154 = (unsigned __int8 *)(v227 + 1);
                  v227[3] = 0;
                  *((_BYTE *)v227 + 1) = v153;
                  for ( i = 0; ; ++i )
                  {
                    v156 = *(&v265 + 4 * i);
                    v157 = (v156 << v151) | v149;
                    *v154 = v157;
                    if ( (unsigned __int8)(v151 + 3) < 8u )
                    {
                      v158 = v151 + 3;
                    }
                    else
                    {
                      v158 = v151 - 5;
                      ++v154;
                      if ( v151 == 5 )
                      {
                        LOBYTE(v157) = *v154;
                        v158 = 0;
                      }
                      else
                      {
                        v157 = v156 >> (8 - v151);
                        *v154 = v157;
                      }
                    }
                    v159 = &v265 + 4 * i;
                    v160 = v159[1];
                    v161 = (v160 << v158) | (unsigned __int8)v157;
                    *v154 = v161;
                    if ( (unsigned __int8)(v158 + 3) <= 7u )
                    {
                      v162 = v158 + 3;
                    }
                    else
                    {
                      v162 = v158 - 5;
                      ++v154;
                      if ( v158 == 5 )
                      {
                        LOBYTE(v161) = *v154;
                        v162 = 0;
                      }
                      else
                      {
                        v161 = v160 >> (8 - v158);
                        *v154 = v161;
                      }
                    }
                    v163 = v159[2];
                    v164 = (unsigned __int8)v161 | (v163 << v162);
                    *v154 = v164;
                    if ( (unsigned __int8)(v162 + 3) < 8u )
                    {
                      v165 = v162 + 3;
                    }
                    else
                    {
                      v165 = v162 - 5;
                      ++v154;
                      if ( v162 == 5 )
                      {
                        LOBYTE(v164) = *v154;
                        v165 = 0;
                      }
                      else
                      {
                        v164 = v163 >> (8 - v162);
                        *v154 = v164;
                      }
                    }
                    v166 = v159[3];
                    *v154 = (v166 << v165) | v164;
                    if ( (unsigned __int8)(v165 + 3) < 8u )
                    {
                      v151 = v165 + 3;
                      if ( i == 3 )
                        goto LABEL_420;
                    }
                    else
                    {
                      v151 = v165 - 5;
                      ++v154;
                      if ( v165 == 5 )
                      {
                        v151 = 0;
                        if ( i == 3 )
                        {
LABEL_420:
                          v103 = v242;
                          v84 = v227 + 4;
                          v105 = v238;
                          goto LABEL_421;
                        }
                      }
                      else
                      {
                        *v154 = v166 >> (8 - v165);
                        if ( i == 3 )
                          goto LABEL_420;
                      }
                    }
                    v149 = *v154;
                  }
                }
              }
            }
            if ( v104 == 33778 )
            {
              *v84 = v266 & 0xF0 | (v265 >> 4) | (16 * v267) & 0xF00 | (v268 << 8) & 0xF000;
              v84[1] = v270 & 0xF0 | (v269 >> 4) | (16 * v271) & 0xF00 | (v272 << 8) & 0xF000;
              v84[2] = v274 & 0xF0 | (v273 >> 4) | (16 * v275) & 0xF00 | (v276 << 8) & 0xF000;
              v84[3] = v278 & 0xF0 | (v277 >> 4) | (16 * v279) & 0xF00 | (v280 << 8) & 0xF000;
              v84 += 4;
            }
LABEL_421:
            v84[1] = v105;
            *v84 = v103;
            v20 = v84 + 4;
            *((_DWORD *)v84 + 1) = v80;
            v13 = v225;
            v229 += 16;
            v253 += 4;
            if ( v253 >= v225 )
              goto LABEL_422;
          }
          v70 = (void *)(v65 + 2 * v66);
LABEL_160:
          v67 = v231;
          v68 = v240;
          v69 = (unsigned __int8)v245;
          goto LABEL_161;
        }
LABEL_422:
        v14 = v221;
        v21 = v222 + 4;
        if ( v222 + 4 >= v221 )
          goto LABEL_423;
      }
LABEL_50:
      v25 = (int)&v226[2 * v24];
      goto LABEL_56;
    }
LABEL_423:
    NVLogDebug("NVCompressToDXT", "Finished dxt mipmap %d (finish size %d)", v220++, v218[107]);
    if ( v220 == v219->numMipmaps )
      goto LABEL_521;
    if ( !bMakeMipmaps )
      break;
    v239 = s_tempStorage;
    if ( !s_tempStorage )
      goto LABEL_428;
    if ( s_tempStorageSize < v13 * v14 )
    {
      operator delete[](s_tempStorage);
LABEL_428:
      s_tempStorageSize = v13 * v14;
      v239 = (NvS8 *)operator new[](v13 * v14);
      s_tempStorage = v239;
    }
    if ( v14 < 1 )
    {
      v17 = v239;
      goto LABEL_23;
    }
    v228 = 8 * v13;
    v230 = 4 * v13;
    v224 = v13 >> 1;
    v235 = 0;
    v233 = v226;
    do
    {
      if ( v13 >= 1 )
      {
        v167 = 0;
        v168 = v233;
        do
        {
          v169 = v167 + v235 * v225;
          if ( (unsigned int)(s_srcType - 32819) < 2 || s_srcType == 33635 )
          {
LABEL_438:
            v170 = &v226[2 * v169];
          }
          else if ( s_srcType == 5121 )
          {
            v170 = v168;
            switch ( s_srcFormat )
            {
              case 6406:
              case 6409:
                v170 = &v226[v169];
                break;
              case 6407:
                v170 = &v226[3 * v169];
                break;
              case 6408:
                break;
              case 6410:
                goto LABEL_438;
              default:
                NVLogError("GetTexelAddress", "Unsupported format/type pair [0x%x 0x%x]", s_srcFormat, 5121);
                goto LABEL_440;
            }
          }
          else
          {
            NVLogError("GetTexelAddress", "Unsupported type [0x%x]", s_srcType);
LABEL_440:
            v170 = 0;
          }
          v171 = (unsigned int)TexelToColor8888(v170);
          v172 = (unsigned __int8)v171;
          v173 = BYTE2(v171);
          v174 = BYTE1(v171);
          v175 = v169 | 1;
          v176 = HIBYTE(v171);
          if ( (unsigned int)(s_srcType - 32819) < 2 || s_srcType == 33635 )
          {
LABEL_446:
            v177 = &v226[2 * v175];
          }
          else if ( s_srcType == 5121 )
          {
            switch ( s_srcFormat )
            {
              case 6406:
              case 6409:
                v177 = &v226[v175];
                break;
              case 6407:
                v177 = &v226[3 * v175];
                break;
              case 6408:
                v177 = v168 + 4;
                break;
              case 6410:
                goto LABEL_446;
              default:
                NVLogError("GetTexelAddress", "Unsupported format/type pair [0x%x 0x%x]", s_srcFormat, 5121);
                goto LABEL_448;
            }
          }
          else
          {
            NVLogError("GetTexelAddress", "Unsupported type [0x%x]", s_srcType);
LABEL_448:
            v177 = 0;
          }
          v178 = v167 + (v235 | 1) * v225;
          v179 = TexelToColor8888(v177);
          v180 = v176 + HIBYTE(*(unsigned int *)&v179);
          v181 = v172 + v179.red;
          v254 = v168;
          if ( (unsigned int)(s_srcType - 32819) < 2 || s_srcType == 33635 )
          {
            v183 = v174;
            v182 = &v226[2 * v178];
          }
          else
          {
            v243 = v179;
            if ( s_srcType == 5121 )
            {
              switch ( s_srcFormat )
              {
                case 6406:
                case 6409:
                  v182 = &v226[v178];
                  break;
                case 6407:
                  v182 = &v226[3 * v178];
                  break;
                case 6408:
                  v182 = &v168[v230];
                  break;
                case 6410:
                  v182 = &v226[2 * v178];
                  break;
                default:
                  NVLogError("GetTexelAddress", "Unsupported format/type pair [0x%x 0x%x]", s_srcFormat, 5121);
                  goto LABEL_456;
              }
            }
            else
            {
              NVLogError("GetTexelAddress", "Unsupported type [0x%x]", s_srcType);
LABEL_456:
              v182 = 0;
            }
            v179 = v243;
            v183 = v174;
          }
          v184 = v173 + (unsigned __int8)__ROR4__(v179, 16);
          v185 = v183 + (unsigned __int8)__ROR4__(v179, 8);
          v186 = TexelToColor8888(v182);
          v187 = v180 + HIBYTE(*(unsigned int *)&v186);
          v188 = v181 + v186.red;
          v189 = v178 + 1;
          if ( (unsigned int)(s_srcType - 32819) < 2 || s_srcType == 33635 )
          {
            v191 = &v226[2 * v189];
          }
          else
          {
            v190 = v186;
            if ( s_srcType == 5121 )
            {
              switch ( s_srcFormat )
              {
                case 6406:
                case 6409:
                  goto LABEL_463;
                case 6407:
                  v189 *= 3;
LABEL_463:
                  v191 = &v226[v189];
                  break;
                case 6408:
                  v191 = &v254[v230 + 4];
                  break;
                case 6410:
                  v191 = &v226[2 * v189];
                  break;
                default:
                  NVLogError("GetTexelAddress", "Unsupported format/type pair [0x%x 0x%x]", s_srcFormat, 5121);
                  goto LABEL_466;
              }
            }
            else
            {
              NVLogError("GetTexelAddress", "Unsupported type [0x%x]", s_srcType);
LABEL_466:
              v191 = 0;
            }
            v186 = v190;
          }
          v192 = v184 + (unsigned __int8)__ROR4__(v186, 16);
          v193 = v185 + (unsigned __int8)__ROR4__(v186, 8);
          v194 = TexelToColor8888(v191);
          v195 = v187 + HIBYTE(*(unsigned int *)&v194);
          v196 = v188 + v194.red;
          v197 = (v235 >> 1) * v224 + (v167 >> 1);
          if ( (unsigned int)(s_srcType - 32819) < 2 || s_srcType == 33635 )
          {
            v199 = &v239[2 * v197];
          }
          else
          {
            v198 = v194;
            if ( s_srcType == 5121 )
            {
              switch ( s_srcFormat )
              {
                case 6406:
                case 6409:
                  goto LABEL_473;
                case 6407:
                  v197 *= 3;
LABEL_473:
                  v199 = &v239[v197];
                  break;
                case 6408:
                  v199 = &v239[4 * v197];
                  break;
                case 6410:
                  v199 = &v239[2 * v197];
                  break;
                default:
                  NVLogError("GetTexelAddress", "Unsupported format/type pair [0x%x 0x%x]", s_srcFormat, 5121);
                  goto LABEL_476;
              }
            }
            else
            {
              NVLogError("GetTexelAddress", "Unsupported type [0x%x]", s_srcType);
LABEL_476:
              v199 = 0;
            }
            v194 = v198;
          }
          v200 = v192 + (unsigned __int8)__ROR4__(v194, 16);
          v201 = v193 + (unsigned __int8)__ROR4__(v194, 8);
          v202 = v195 >> 2;
          v203 = v196 >> 2;
          if ( s_srcType > 32819 )
          {
            v205 = v254;
            v211 = 2 * v201;
            if ( s_srcType == 32820 )
            {
              if ( s_srcFormat == 6408 )
              {
                v213 = (v200 >> 4) & 0x3E | (v203 << 8) & 0xF800 | v211 & 0x7C0;
                if ( (_BYTE)v202 )
                  LOWORD(v213) = v213 | 1;
                *(_WORD *)v199 = v213;
              }
              else
              {
                NVLogError("Color8888ToTexel", "Unsupported format/type pair [0x%x 0x%x]", s_srcFormat, 32820);
              }
              goto LABEL_518;
            }
            if ( s_srcType != 33635 )
              goto LABEL_494;
            if ( s_srcFormat != 6407 )
            {
              NVLogError("Color8888ToTexel", "Unsupported format/type pair [0x%x 0x%x]", s_srcFormat, 33635);
              goto LABEL_518;
            }
            v209 = (v200 >> 5) & 0x1F;
            LOWORD(v210) = ((_WORD)v203 << 8) & 0xF800 | v211 & 0x7E0;
          }
          else
          {
            _R1 = v200 << 14;
            v205 = v254;
            __asm { UXTB16.W        R1, R1 }
            v209 = (_R1 | (v202 << 24)) >> 16;
            if ( s_srcType == 5121 )
            {
              v212 = v201 >> 2;
              switch ( s_srcFormat )
              {
                case 6406:
                  *v199 = v202;
                  break;
                case 6407:
                  v199[1] = v212;
                  *v199 = v203;
                  v199[2] = v209;
                  break;
                case 6408:
                  v199[1] = v212;
                  *v199 = v203;
                  v199[2] = v209;
                  v199[3] = v202;
                  break;
                case 6409:
                  goto LABEL_517;
                case 6410:
                  v199[1] = v202;
LABEL_517:
                  *v199 = v203;
                  break;
                default:
                  NVLogError("Color8888ToTexel", "Unsupported format/type pair [0x%x 0x%x]", v212, 5121);
                  break;
              }
              goto LABEL_518;
            }
            if ( s_srcType != 32819 )
            {
LABEL_494:
              NVLogError("Color8888ToTexel", "Unsupported format/type pair [0x%x 0x%x]", s_srcFormat);
              goto LABEL_518;
            }
            if ( s_srcFormat != 6408 )
            {
              NVLogError("Color8888ToTexel", "Unsupported format/type pair [0x%x 0x%x]", s_srcFormat, 32819);
              goto LABEL_518;
            }
            v210 = (v203 << 8) & 0xF000 | (4 * v201) & 0xF00 | (v195 >> 6) & 0xF;
            LOWORD(v209) = v209 & 0xF0;
          }
          *(_WORD *)v199 = v210 | v209;
LABEL_518:
          v167 += 2;
          v168 = v205 + 8;
        }
        while ( v167 < v225 );
      }
      v14 = v221;
      v233 += v228;
      v13 = v225;
      v235 += 2;
    }
    while ( v235 < v221 );
    v17 = s_tempStorage;
LABEL_23:
    v226 = v17;
LABEL_24:
    v18 = v14 >> 1;
    v19 = v13 >> 1;
    if ( !(v14 >> 1) )
      v18 = 1;
    if ( !(v13 >> 1) )
      v19 = 1;
    v14 = v18;
    v13 = v19;
    v10 = v219;
  }
  if ( v216->numMipmaps >= v220 )
  {
    v226 = (NvS8 *)v216->data[v220];
    if ( v226 )
      goto LABEL_24;
  }
LABEL_521:
  NVLogDebug("NVCompressToDXT", "Finished DXT compression.");
  return v219;
}
// 274DA0: using guessed type unsigned __int16 var_80[16];

//----- (0027688C) --------------------------------------------------------
Color8888 __fastcall TexelToColor8888(void *texel)
{
  NvS32 v1; // r2
  unsigned int v2; // r0
  int v3; // r2
  int v4; // r3
  unsigned int v5; // r1
  int v6; // r0
  unsigned int v7; // r0
  unsigned int v8; // r0

  if ( s_srcType > 32819 )
  {
    if ( s_srcType == 32820 )
    {
      v1 = s_srcFormat;
      if ( s_srcFormat == 6408 )
      {
        v8 = *(unsigned __int16 *)texel;
        v5 = (unsigned int)&stru_3FFEC.st_info & (4 * v8);
        v3 = (v8 >> 3) & 0x1FF8;
        v4 = (v8 >> 8) & 0xF8;
        v6 = -(v8 & 1);
        return (Color8888)(((unsigned __int8)v5 << 16) | (v6 << 24) | ((unsigned __int8)v3 << 8) | v4);
      }
    }
    else
    {
      if ( s_srcType != 33635 )
        goto LABEL_14;
      v1 = s_srcFormat;
      if ( s_srcFormat == 6407 )
      {
        v7 = *(unsigned __int16 *)texel;
        v3 = (v7 >> 3) & 0x1FFC;
        v4 = (v7 >> 8) & 0xF8;
        LOBYTE(v5) = 8 * v7;
        v6 = 255;
        return (Color8888)(((unsigned __int8)v5 << 16) | (v6 << 24) | ((unsigned __int8)v3 << 8) | v4);
      }
    }
LABEL_15:
    NVLogError("TexelToColor8888", "Unsupported format/type pair [0x%x 0x%x]", v1);
LABEL_16:
    v6 = 0;
LABEL_17:
    LOBYTE(v5) = 0;
    LOBYTE(v3) = 0;
    v4 = 0;
    return (Color8888)(((unsigned __int8)v5 << 16) | (v6 << 24) | ((unsigned __int8)v3 << 8) | v4);
  }
  if ( s_srcType != 5121 )
  {
    if ( s_srcType == 32819 )
    {
      v1 = s_srcFormat;
      if ( s_srcFormat == 6408 )
      {
        v2 = *(unsigned __int16 *)texel;
        v3 = (v2 >> 4) & 0xFF0;
        v4 = (v2 >> 8) & 0xF0;
        LOBYTE(v5) = v2 & 0xF0;
        v6 = 16 * v2;
        return (Color8888)(((unsigned __int8)v5 << 16) | (v6 << 24) | ((unsigned __int8)v3 << 8) | v4);
      }
      goto LABEL_15;
    }
LABEL_14:
    NVLogError("TexelToColor8888", "Unsupported format/type pair [0x%x 0x%x]", s_srcFormat);
    goto LABEL_16;
  }
  v1 = s_srcFormat;
  switch ( s_srcFormat )
  {
    case 6406:
      v6 = *(unsigned __int8 *)texel;
      goto LABEL_17;
    case 6407:
      v4 = *(unsigned __int8 *)texel;
      LOBYTE(v3) = *((_BYTE *)texel + 1);
      LOBYTE(v5) = *((_BYTE *)texel + 2);
      v6 = 255;
      return (Color8888)(((unsigned __int8)v5 << 16) | (v6 << 24) | ((unsigned __int8)v3 << 8) | v4);
    case 6408:
      v4 = *(unsigned __int8 *)texel;
      LOBYTE(v3) = *((_BYTE *)texel + 1);
      LOBYTE(v5) = *((_BYTE *)texel + 2);
      v6 = *((unsigned __int8 *)texel + 3);
      return (Color8888)(((unsigned __int8)v5 << 16) | (v6 << 24) | ((unsigned __int8)v3 << 8) | v4);
    case 6409:
      v5 = *(unsigned __int8 *)texel;
      v6 = 255;
      goto LABEL_23;
    case 6410:
      v5 = *(unsigned __int8 *)texel;
      v6 = *((unsigned __int8 *)texel + 1);
LABEL_23:
      LOBYTE(v3) = v5;
      v4 = v5;
      break;
    default:
      goto LABEL_15;
  }
  return (Color8888)(((unsigned __int8)v5 << 16) | (v6 << 24) | ((unsigned __int8)v3 << 8) | v4);
}
// 3FFEC: using guessed type Elf32_Sym stru_3FFEC;

//----- (00276A44) --------------------------------------------------------
void NVCompressFlush()
{
  if ( s_tempStorage )
    operator delete[](s_tempStorage);
  s_tempStorageSize = 0;
  s_tempStorage = 0;
}

//----- (00276A74) --------------------------------------------------------
void NVDefaultLog(
        ENVLogLevel inLevel,
        const unsigned __int8 *inTag,
        const unsigned __int8 *inMessage,
        const unsigned __int8 *inDetails,
        ...)
{
  unsigned __int8 s[16388]; // [sp+8h] [bp-4020h] BYREF
  va_list va; // [sp+4030h] [bp+8h] BYREF

  va_start(va, inDetails);
  memset(s, 0, 0x4000u);
  if ( (g_NVLogMask & inLevel) != 0 )
  {
    vsprintf(s, inDetails, va);
    NVLogMessage(inLevel, inTag, inMessage, s);
  }
}

//----- (00276B00) --------------------------------------------------------
unsigned __int8 *__fastcall NVDefaultLogMessage(
        ENVLogLevel inLevel,
        const unsigned __int8 *inTag,
        const unsigned __int8 *inMessage,
        const unsigned __int8 *inDetails)
{
  size_t v8; // r5
  const char *v9; // r9
  unsigned int v10; // r4
  const char *v11; // r5
  unsigned int v12; // r1
  const char *v13; // r0
  const char *v14; // r2

  v8 = strlen((const char *)inTag);
  v9 = "(Tag too big)";
  if ( v8 <= 0x3F9C )
    v9 = (const char *)inTag;
  v10 = strlen((const char *)inMessage) + v8;
  v11 = "(Message too long)";
  if ( v10 <= 0x3F9C )
    v11 = (const char *)inMessage;
  v12 = v10 + strlen((const char *)inDetails);
  v13 = "(Details too long)";
  if ( v12 <= 0x3F9C )
    v13 = (const char *)inDetails;
  v14 = "DEBUG";
  switch ( inLevel )
  {
    case NVLOGLEVEL_DEBUG:
      break;
    case NVLOGLEVEL_TRACE:
      v14 = "TRACE";
      break;
    case NVLOGLEVEL_INFO:
      v14 = "INFO";
      break;
    case NVLOGLEVEL_WARN:
      v14 = "WARN";
      break;
    case NVLOGLEVEL_ERROR:
      v14 = "ERROR";
      break;
    case NVLOGLEVEL_FATAL:
      v14 = "FATAL";
      break;
    default:
      v14 = "???";
      break;
  }
  sprintf(
    NVDefaultLogMessage(ENVLogLevel,char const*,char const*,char const*)::s_FormattedMesage,
    "%s(%s): %s - %s\n",
    v14,
    v9,
    v11,
    v13);
  NVLogOutput(NVDefaultLogMessage(ENVLogLevel,char const*,char const*,char const*)::s_FormattedMesage);
  return NVDefaultLogMessage(ENVLogLevel,char const*,char const*,char const*)::s_FormattedMesage;
}

//----- (00276C48) --------------------------------------------------------
void __fastcall NVDefaultLogOutput(const unsigned __int8 *inMessage)
{
  printf((const unsigned __int8 *)&dword_276C7C, inMessage);
  if ( g_NVLogFile )
  {
    fputs((const char *)inMessage, (FILE *)g_NVLogFile);
    sub_19D590((FILE *)g_NVLogFile);
  }
}
// 276C7C: using guessed type int dword_276C7C;

//----- (00276C88) --------------------------------------------------------
void NVDefaultLogDebug(const unsigned __int8 *inMessage, const unsigned __int8 *inDetails, ...)
{
  unsigned __int8 s[16388]; // [sp+8h] [bp-4018h] BYREF
  va_list va; // [sp+4028h] [bp+8h] BYREF

  va_start(va, inDetails);
  memset(s, 0, 0x4000u);
  if ( (unsigned __int8)g_NVLogMask << 31 )
  {
    vsprintf(s, inDetails, va);
    NVLogMessage(NVLOGLEVEL_DEBUG, (const unsigned __int8 *)&off_276D18, inMessage, s);
  }
}
// 276D18: using guessed type float **off_276D18;

//----- (00276D20) --------------------------------------------------------
void NVDefaultLogInfo(const unsigned __int8 *inMessage, const unsigned __int8 *inDetails, ...)
{
  unsigned __int8 s[16388]; // [sp+8h] [bp-4018h] BYREF
  va_list va; // [sp+4028h] [bp+8h] BYREF

  va_start(va, inDetails);
  memset(s, 0, 0x4000u);
  if ( (g_NVLogMask & 4) != 0 )
  {
    vsprintf(s, inDetails, va);
    NVLogMessage(NVLOGLEVEL_INFO, (const unsigned __int8 *)&off_276DB0, inMessage, s);
  }
}
// 276DB0: using guessed type float **off_276DB0;

//----- (00276DB8) --------------------------------------------------------
void NVDefaultLogWarn(const unsigned __int8 *inMessage, const unsigned __int8 *inDetails, ...)
{
  unsigned __int8 s[16388]; // [sp+8h] [bp-4018h] BYREF
  va_list va; // [sp+4028h] [bp+8h] BYREF

  va_start(va, inDetails);
  memset(s, 0, 0x4000u);
  if ( (g_NVLogMask & 8) != 0 )
  {
    vsprintf(s, inDetails, va);
    NVLogMessage(NVLOGLEVEL_WARN, (const unsigned __int8 *)&off_276E48, inMessage, s);
  }
}
// 276E48: using guessed type float **off_276E48;

//----- (00276E50) --------------------------------------------------------
void NVDefaultLogError(const unsigned __int8 *inMessage, const unsigned __int8 *inDetails, ...)
{
  unsigned __int8 s[16388]; // [sp+8h] [bp-4018h] BYREF
  va_list va; // [sp+4028h] [bp+8h] BYREF

  va_start(va, inDetails);
  memset(s, 0, 0x4000u);
  if ( (g_NVLogMask & 0x10) != 0 )
  {
    vsprintf(s, inDetails, va);
    NVLogMessage(NVLOGLEVEL_ERROR, (const unsigned __int8 *)&off_276EE0, inMessage, s);
  }
}
// 276EE0: using guessed type float **off_276EE0;

//----- (00276EE8) --------------------------------------------------------
void NVDefaultLogFatal(const unsigned __int8 *inMessage, const unsigned __int8 *inDetails, ...)
{
  unsigned __int8 s[16388]; // [sp+8h] [bp-4018h] BYREF
  va_list va; // [sp+4028h] [bp+8h] BYREF

  va_start(va, inDetails);
  memset(s, 0, 0x4000u);
  if ( (g_NVLogMask & 0x20) != 0 )
  {
    vsprintf(s, inDetails, va);
    NVLogMessage(NVLOGLEVEL_FATAL, (const unsigned __int8 *)&off_276F78, inMessage, s);
  }
}
// 276F78: using guessed type float **off_276F78;

//----- (00276F80) --------------------------------------------------------
void __fastcall NVLogFile(const unsigned __int8 *inFilePath)
{
  if ( g_NVLogFile )
    fclose((FILE *)g_NVLogFile);
  if ( inFilePath )
    g_NVLogFile = fopen((const char *)inFilePath, (const char *)&dword_276FB4);
}
// 276FB4: using guessed type int dword_276FB4;

//----- (00276FBC) --------------------------------------------------------
void __fastcall NVLogEnable(ENVLogLevel inLevel, NvBool inEnable)
{
  __int32 v2; // r0

  if ( inEnable )
    v2 = inLevel | g_NVLogMask;
  else
    v2 = g_NVLogMask & ~inLevel;
  g_NVLogMask = v2;
}

//----- (00276FEC) --------------------------------------------------------
const unsigned __int8 *__fastcall NVLogLevelString(ENVLogLevel inLevel)
{
  __int32 v1; // r1
  const unsigned __int8 *result; // r0

  v1 = inLevel - 1;
  result = NVLogLevelString(ENVLogLevel)::theLevelString[0];
  switch ( v1 )
  {
    case 0:
      return result;
    case 1:
      result = "TRACE";
      break;
    case 3:
      result = "INFO";
      break;
    case 7:
      result = "WARN";
      break;
    case 15:
      result = "ERROR";
      break;
    case 31:
      result = "FATAL";
      break;
    default:
      result = "???";
      break;
  }
  return result;
}

//----- (00277068) --------------------------------------------------------
void NVDefaultLogTrace(const unsigned __int8 *inMessage, const unsigned __int8 *inDetails, ...)
{
  unsigned __int8 s[16388]; // [sp+8h] [bp-4018h] BYREF
  va_list va; // [sp+4028h] [bp+8h] BYREF

  va_start(va, inDetails);
  memset(s, 0, 0x4000u);
  if ( (g_NVLogMask & 2) != 0 )
  {
    vsprintf(s, inDetails, va);
    NVLogMessage(NVLOGLEVEL_TRACE, (const unsigned __int8 *)&off_2770F8, inMessage, s);
  }
}
// 2770F8: using guessed type float **off_2770F8;

//----- (00277100) --------------------------------------------------------
GLfloat_0 NvRandf()
{
  NvRandf(void)::seed = NvRandf(void)::seed * 16807.0
                      - (double)(int)(NvRandf(void)::seed * 16807.0 / 2147483650.0) * 2147483650.0;
  return NvRandf(void)::seed * 4.65661288e-10;
}

//----- (0027715C) --------------------------------------------------------
GLfloat_0 __fastcall NvClockDiffInSecs(__int64 newTime, __int64 oldTime)
{
  return (float)(newTime - oldTime) / 1000000000.0;
}

//----- (00277180) --------------------------------------------------------
int __fastcall NvDifferentMatsf(GLfloat_0 (*a)[4], const GLfloat_0 (*b)[4])
{
  int v2; // r3
  bool v3; // cf
  int v4; // r2
  GLfloat_0 *v5; // r0

  v2 = 0;
  v3 = &(*b)[15] >= (const GLfloat_0 *)a;
  v4 = 0;
  v5 = &(*a)[15];
  if ( !v3 )
    v4 = 1;
  if ( v5 < (GLfloat_0 *)b )
    v2 = 1;
  return v2 | v4;
}

//----- (002771A0) --------------------------------------------------------
void __fastcall NvCopyMatf(GLfloat_0 (*dest)[4], const GLfloat_0 (*source)[4])
{
  (*dest)[0] = (*source)[0];
  (*dest)[1] = (*source)[1];
  (*dest)[2] = (*source)[2];
  (*dest)[3] = (*source)[3];
  (*dest)[4] = (*source)[4];
  (*dest)[5] = (*source)[5];
  (*dest)[6] = (*source)[6];
  (*dest)[7] = (*source)[7];
  (*dest)[8] = (*source)[8];
  (*dest)[9] = (*source)[9];
  (*dest)[10] = (*source)[10];
  (*dest)[11] = (*source)[11];
  (*dest)[12] = (*source)[12];
  (*dest)[13] = (*source)[13];
  (*dest)[14] = (*source)[14];
  (*dest)[15] = (*source)[15];
}

//----- (002771E2) --------------------------------------------------------
void __fastcall NvExtract3x3Matf(GLfloat_0 (*r)[3], const GLfloat_0 (*m)[4])
{
  (*r)[0] = (*m)[0];
  (*r)[1] = (*m)[1];
  (*r)[2] = (*m)[2];
  (*r)[3] = (*m)[4];
  (*r)[4] = (*m)[5];
  (*r)[5] = (*m)[6];
  (*r)[6] = (*m)[8];
  (*r)[7] = (*m)[9];
  (*r)[8] = (*m)[10];
}

//----- (00277208) --------------------------------------------------------
GLfloat_0 __fastcall NvVecLengthf(const GLfloat_0 *v)
{
  return sqrtf((float)((float)(*v * *v) + (float)(v[1] * v[1])) + (float)(v[2] * v[2]));
}

//----- (00277232) --------------------------------------------------------
void __fastcall NvNormalizeVecf(GLfloat_0 *r, const GLfloat_0 *v)
{
  float v2; // s2

  v2 = sqrtf((float)((float)(*v * *v) + (float)(v[1] * v[1])) + (float)(v[2] * v[2]));
  *r = *v / v2;
  r[1] = v[1] / v2;
  r[2] = v[2] / v2;
}

//----- (00277278) --------------------------------------------------------
void __fastcall NvAddVecf(GLfloat_0 *r, const GLfloat_0 *a, const GLfloat_0 *b)
{
  *r = *a + *b;
  r[1] = a[1] + b[1];
  r[2] = a[2] + b[2];
}

//----- (002772AA) --------------------------------------------------------
void __fastcall NvSubVecf(GLfloat_0 *r, const GLfloat_0 *a, const GLfloat_0 *b)
{
  *r = *a - *b;
  r[1] = a[1] - b[1];
  r[2] = a[2] - b[2];
}

//----- (002772DC) --------------------------------------------------------
void __fastcall NvCrossProductf(GLfloat_0 *r, const GLfloat_0 *a, const GLfloat_0 *b)
{
  float v3; // s10
  float v4; // s2
  float v5; // s4
  float v6; // s8
  GLfloat_0 v7; // s6
  GLfloat_0 v8; // s0

  v3 = b[2];
  v4 = a[1];
  v5 = a[2];
  v6 = b[1];
  v7 = (float)(v5 * *b) - (float)(v3 * *a);
  v8 = (float)(v6 * *a) - (float)(v4 * *b);
  *r = (float)(v4 * v3) - (float)(v5 * v6);
  r[1] = v7;
  r[2] = v8;
}

//----- (00277326) --------------------------------------------------------
void __fastcall NvTransformPointf(GLfloat_0 *r, const GLfloat_0 (*m)[4], const GLfloat_0 *a)
{
  float v3; // s10
  float v4; // s12
  float v5; // s2

  v3 = a[1];
  v4 = a[2];
  v5 = 1.0
     / (float)((float)(*m)[15]
             + (float)((float)((float)((float)(*m)[3] * *a) + (float)((float)(*m)[7] * v3))
                     + (float)((float)(*m)[11] * v4)));
  *r = (float)((float)((float)(*a * (*m)[0]) + (float)(v3 * (float)(*m)[4])) + (float)(v4 * (float)(*m)[8]))
     + (float)(v5 * (float)(*m)[12]);
  r[1] = (float)((float)((float)((float)(*m)[1] * *a) + (float)((float)(*m)[5] * a[1])) + (float)((float)(*m)[9] * a[2]))
       + (float)(v5 * (float)(*m)[13]);
  r[2] = (float)((float)((float)((float)(*m)[2] * *a) + (float)((float)(*m)[6] * a[1])) + (float)((float)(*m)[10] * a[2]))
       + (float)(v5 * (float)(*m)[14]);
}

//----- (0027740C) --------------------------------------------------------
void __fastcall NvTransformHomPointf(GLfloat_0 *r, const GLfloat_0 (*m)[4], const GLfloat_0 *a)
{
  *r = (float)((float)((float)((*m)[0] * *a) + (float)((float)(*m)[4] * a[1])) + (float)((float)(*m)[8] * a[2]))
     + (float)((float)(*m)[12] * a[3]);
  r[1] = (float)((float)((float)((float)(*m)[1] * *a) + (float)((float)(*m)[5] * a[1])) + (float)((float)(*m)[9] * a[2]))
       + (float)((float)(*m)[13] * a[3]);
  r[2] = (float)((float)((float)((float)(*m)[2] * *a) + (float)((float)(*m)[6] * a[1])) + (float)((float)(*m)[10] * a[2]))
       + (float)((float)(*m)[14] * a[3]);
  r[3] = (float)((float)((float)((float)(*m)[3] * *a) + (float)((float)(*m)[7] * a[1])) + (float)((float)(*m)[11] * a[2]))
       + (float)((float)(*m)[15] * a[3]);
}

//----- (0027750E) --------------------------------------------------------
void __fastcall NvTransformVecf(GLfloat_0 *r, const GLfloat_0 (*m)[4], const GLfloat_0 *a)
{
  *r = (float)((float)((*m)[0] * *a) + (float)((float)(*m)[4] * a[1])) + (float)((float)(*m)[8] * a[2]);
  r[1] = (float)((float)((float)(*m)[1] * *a) + (float)((float)(*m)[5] * a[1])) + (float)((float)(*m)[9] * a[2]);
  r[2] = (float)((float)((float)(*m)[2] * *a) + (float)((float)(*m)[6] * a[1])) + (float)((float)(*m)[10] * a[2]);
}

//----- (002775A0) --------------------------------------------------------
void __fastcall NvMultMatf(GLfloat_0 (*result)[4], const GLfloat_0 (*a)[4], const GLfloat_0 (*b)[4])
{
  float32x4_t v3; // q3
  int v4; // r3
  float32x4_t v5; // q2
  int v6; // r12
  float32x4_t v7; // q0
  float v8; // s4
  float v9; // s0
  float v10; // s4
  float v11; // s14
  float v12; // s3
  float v13; // s6
  float v14; // s11
  float v15; // s13
  float v16; // s2
  float v17; // s24
  float v18; // s9
  float v19; // s18
  float v20; // s5
  float v21; // s16
  float v22; // s10
  float v23; // s20
  float v24; // s14
  float v25; // s12
  float v26; // s9
  float v27; // s26
  float v28; // s7
  float v29; // s11
  float v30; // s22
  float v31; // s13
  float v32; // s5
  float v33; // s14
  float v34; // s15
  float v35; // s16
  float v36; // s18
  float v37; // s11
  float v38; // s6
  float v39; // s0
  float v40; // s20
  float v41; // s24
  float v42; // s22
  float v43; // s28
  float v44; // s3
  float v45; // s30
  float v46; // s16
  float v47; // s2
  float v48; // s10
  float v49; // s12
  float v50; // s8
  float v51; // s4
  float v52; // s6
  float v53; // s14
  float v54; // s5
  float v55; // s7
  float v56; // s9
  const float *v57; // r3
  float v58; // s0
  const float *v59; // r3
  float v60; // s2
  const float *v61; // r3
  float32x4_t v62; // q4
  float v63; // s6
  float v64; // s1
  float32x4_t v65; // q5
  float v66; // s28
  float v67; // s30
  float v68; // s25
  float v69; // s7
  float v70; // s24
  float32x4_t v71; // q8
  float v72; // s26
  float v73; // s31
  float v74; // s5
  float v75; // r12
  float v76; // s3
  const float *v77; // r2
  float v78; // r3
  float v79; // r1
  float v80; // s27
  float v81; // s7
  float v82; // s29
  float v83; // s24
  float v84; // s26
  float v85; // s30
  float v86; // s6
  float v87; // s8
  float v88; // s10
  float v89; // s12
  float v90; // s5
  float v91; // s15
  float v92; // s9
  float v93; // s13
  float v94; // s28
  float v95; // s30
  float v96; // s19
  float v97; // s21
  float v98; // s25
  float v99; // s24
  float v100; // s23
  float v101; // s7
  float v102; // s20
  float v103; // s16
  float v104; // s9
  float v105; // s6
  float v106; // s22
  float v107; // s18
  float v108; // s17
  float v109; // s26
  float v110; // s27
  float v111; // s6
  float v112; // s10
  float v113; // s13
  float v114; // s8
  float v115; // s12
  float v116; // s19
  float v117; // s4
  float v118; // s11
  float32x4_t v119; // 0:d16.8,8:d17.8
  float32x4_t v120; // 0:d18.8,8:d19.8
  float32x4_t v121; // 0:d18.8,8:d19.8
  float32x4_t v122; // 0:d20.8,8:d21.8

  v3.n128_u32[3] = LODWORD((*a)[7]);
  v4 = 0;
  v5.n128_u32[3] = LODWORD((*a)[3]);
  v6 = 0;
  if ( v3.n128_f32[3] == 0.0 )
    v4 = 1;
  if ( v5.n128_f32[3] == 0.0 )
    v6 = 1;
  if ( (v6 & v4) != 0 && (*a)[11] == 0.0 && (v7.n128_u32[3] = 1.0, (*b)[3] == 0.0 && (*b)[11] == 0.0) )
  {
    v8 = (*a)[12];
    if ( v8 == 0.0 && (*a)[14] == 0.0 && (*b)[13] == 0.0 )
    {
      v9 = (*b)[5];
      v10 = (*a)[5];
      v11 = (*b)[4];
      v12 = (*a)[1];
      v13 = (*a)[6];
      v14 = v12 * v11;
      v15 = (*b)[8];
      v16 = (*a)[4];
      v17 = (*a)[0] * v11;
      v18 = (*b)[9];
      v19 = (*a)[0] * v15;
      v20 = (*a)[2];
      v21 = v16 * v18;
      v22 = (*b)[1];
      v23 = v10 * v18;
      v24 = v20 * v11;
      v25 = (*b)[2];
      v26 = v13 * v18;
      v27 = (*a)[10];
      v28 = v14 + (float)(v10 * v9);
      v29 = (*b)[0] * v20;
      v30 = v12 * v15;
      v31 = v20 * v15;
      v32 = (*b)[6];
      v33 = v24 + (float)(v13 * v9);
      v34 = v19 + v21;
      v35 = (*a)[8];
      v36 = (*a)[9];
      v37 = v29 + (float)(v22 * v13);
      v38 = (*b)[10];
      v39 = v17 + (float)(v16 * v9);
      v40 = v30 + v23;
      v41 = v35 * v32;
      v42 = v25 * v36;
      v43 = v35 * v38;
      v44 = (float)((*b)[0] * v12) + (float)(v22 * v10);
      v45 = v25 * v27;
      v46 = v35 * v25;
      v47 = (float)((*a)[0] * (*b)[0]) + (float)(v16 * v22);
      v48 = v33 + (float)(v27 * v32);
      v49 = v28 + (float)(v36 * v32);
      v50 = v34 + v43;
      v51 = (float)(v31 + v26) + (float)(v27 * v38);
      v52 = v40 + (float)(v36 * v38);
      v53 = v39 + v41;
      v54 = v37 + v45;
      v55 = v44 + v42;
      v56 = v47 + v46;
      v7.n128_u64[0] = 0LL;
      v7.n128_u64[1] = 0x3F80000000000000LL;
    }
    else
    {
      v86 = (*b)[5];
      v87 = (*a)[4];
      v88 = (*a)[5];
      v89 = (*a)[6];
      v90 = (*b)[1];
      v91 = (*a)[2];
      v92 = (*b)[4];
      v93 = (*a)[1];
      v94 = (*b)[9];
      v95 = (*b)[8];
      v96 = (*b)[13];
      v97 = (*b)[14];
      v98 = (*a)[10];
      v99 = (float)((*b)[0] * v91) + (float)(v90 * v89);
      v100 = (*a)[9];
      v101 = (*b)[2];
      v102 = (float)((*a)[0] * v92) + (float)(v87 * v86);
      v103 = (float)(v93 * v92) + (float)(v88 * v86);
      v104 = (float)(v91 * v92) + (float)(v89 * v86);
      v105 = (*b)[12];
      v106 = (float)((*b)[0] * v93) + (float)(v90 * v88);
      v107 = (float)((*a)[0] * v95) + (float)(v87 * v94);
      v108 = (*a)[8];
      v109 = (float)((float)(v91 * v105) + (float)(v89 * v96)) + (float)(v98 * v97);
      v110 = (float)((*a)[0] * v105) + (float)(v87 * v96);
      v111 = (float)(v93 * v105) + (float)(v88 * v96);
      v112 = (float)(v93 * v95) + (float)(v88 * v94);
      v113 = (float)((*a)[0] * (*b)[0]) + (float)(v87 * v90);
      v114 = (float)(v91 * v95) + (float)(v89 * v94);
      v115 = (*b)[6];
      v116 = v108 * v101;
      v53 = v102 + (float)(v108 * v115);
      v7.n128_f32[1] = (float)(*a)[13] + (float)(v111 + (float)(v100 * v97));
      v7.n128_f32[0] = v8 + (float)(v110 + (float)(v108 * v97));
      v117 = (*b)[10];
      v7.n128_f32[2] = v109 + (float)(*a)[14];
      v118 = v108 * v117;
      v52 = v112 + (float)(v100 * v117);
      v51 = v114 + (float)(v98 * v117);
      v48 = v104 + (float)(v98 * v115);
      v49 = v103 + (float)(v100 * v115);
      v54 = v99 + (float)(v101 * v98);
      v50 = v107 + v118;
      v55 = v106 + (float)(v101 * v100);
      v56 = v113 + v116;
    }
    v75 = 0.0;
    v78 = 0.0;
    v79 = 0.0;
  }
  else
  {
    v5.n128_u64[0] = *(_QWORD *)&(*a)[0];
    v5.n128_u32[2] = LODWORD((*a)[2]);
    v3.n128_u64[0] = *(_QWORD *)&(*a)[4];
    v3.n128_u32[2] = LODWORD((*a)[6]);
    v57 = &(*b)[12];
    v58 = (*b)[8];
    v119 = (float32x4_t)vld1q_dup_f32(v57);
    v59 = &(*b)[13];
    v60 = (*b)[9];
    v120 = (float32x4_t)vld1q_dup_f32(v59);
    v61 = &(*b)[14];
    v122 = (float32x4_t)vld1q_dup_f32(v61);
    v62 = *(float32x4_t *)&(*a)[8];
    v63 = (*b)[10];
    v64 = (*b)[11];
    v65 = *(float32x4_t *)&(*a)[12];
    v66 = (*b)[4];
    v67 = (*b)[5];
    v68 = (*b)[6];
    v69 = (*b)[0];
    v70 = (*b)[1];
    v71 = vaddq_f32(vaddq_f32(vmulq_f32(v5, v119), vmulq_f32(v3, v120)), vmulq_f32(v62, v122));
    v72 = (*b)[2];
    v73 = (*b)[0] * (float)(*a)[1];
    v51 = (float)((float)((float)(v5.n128_f32[2] * v58) + (float)(v3.n128_f32[2] * v60)) + (float)(v62.n128_f32[2] * v63))
        + (float)(v65.n128_f32[2] * v64);
    v74 = (*b)[7];
    v75 = (float)((float)((float)(v5.n128_f32[3] * v58) + (float)(v3.n128_f32[3] * v60)) + (float)(v62.n128_f32[3] * v63))
        + (float)(v65.n128_f32[3] * v64);
    v76 = (*b)[3];
    v77 = &(*b)[15];
    v121 = (float32x4_t)vld1q_dup_f32(v77);
    v78 = (float)((float)((float)(v5.n128_f32[3] * v66) + (float)(v3.n128_f32[3] * v67)) + (float)(v62.n128_f32[3] * v68))
        + (float)(v65.n128_f32[3] * v74);
    v79 = (float)((float)((float)(v69 * v5.n128_f32[3]) + (float)(v70 * v3.n128_f32[3])) + (float)(v72 * v62.n128_f32[3]))
        + (float)(v76 * v65.n128_f32[3]);
    v80 = (float)((float)(v5.n128_f32[0] * v69) + (float)(v3.n128_f32[0] * v70)) + (float)(v62.n128_f32[0] * v72);
    v81 = (float)((float)(v69 * v5.n128_f32[2]) + (float)(v70 * v3.n128_f32[2])) + (float)(v72 * v62.n128_f32[2]);
    v82 = (float)(v73 + (float)(v70 * v3.n128_f32[1])) + (float)(v72 * v62.n128_f32[1]);
    v83 = (float)((float)(v5.n128_f32[0] * v66) + (float)(v3.n128_f32[0] * v67)) + (float)(v62.n128_f32[0] * v68);
    v84 = (float)((float)(v5.n128_f32[1] * v66) + (float)(v3.n128_f32[1] * v67)) + (float)(v62.n128_f32[1] * v68);
    v48 = (float)((float)((float)(v5.n128_f32[2] * v66) + (float)(v3.n128_f32[2] * v67)) + (float)(v62.n128_f32[2] * v68))
        + (float)(v65.n128_f32[2] * v74);
    v85 = (float)(v5.n128_f32[0] * v58) + (float)(v3.n128_f32[0] * v60);
    v3.n128_f32[0] = v84 + (float)(v65.n128_f32[1] * v74);
    v3.n128_f32[2] = v83 + (float)(v65.n128_f32[0] * v74);
    v50 = (float)(v85 + (float)(v62.n128_f32[0] * v63)) + (float)(v65.n128_f32[0] * v64);
    v52 = (float)((float)((float)(v5.n128_f32[1] * v58) + (float)(v3.n128_f32[1] * v60)) + (float)(v62.n128_f32[1] * v63))
        + (float)(v65.n128_f32[1] * v64);
    v54 = v81 + (float)(v76 * v65.n128_f32[2]);
    v55 = v82 + (float)(v76 * v65.n128_f32[1]);
    v56 = v80 + (float)(v65.n128_f32[0] * v76);
    v7 = vaddq_f32(v71, vmulq_f32(v65, v121));
  }
  (*result)[0] = v56;
  (*result)[1] = v55;
  (*result)[2] = v54;
  (*result)[3] = v79;
  (*result)[4] = v53;
  (*result)[5] = v49;
  (*result)[6] = v48;
  (*result)[7] = v78;
  (*result)[11] = v75;
  (*result)[8] = v50;
  (*result)[9] = v52;
  (*result)[10] = v51;
  *(float32x4_t *)&(*result)[12] = v7;
}

//----- (00277B20) --------------------------------------------------------
void __fastcall NvInvMatf(GLfloat_0 (*result)[4], const GLfloat_0 (*m)[4])
{
  float v2; // s9
  int v3; // r3
  float v4; // s0
  int v5; // r2
  float v6; // s0
  int v7; // r3
  float v8; // s2
  int v9; // r2
  float v10; // s0
  float v11; // r12
  float v12; // s8
  float v13; // lr
  float v14; // s10
  float v15; // r3
  float v16; // s2
  float v17; // s14
  float v18; // s1
  float v19; // s13
  float v20; // s12
  float v21; // s5
  float v22; // s4
  float v23; // s24
  float v24; // s6
  float v25; // s22
  float v26; // s3
  float v27; // s20
  float v28; // r1
  float v29; // r2
  float v30; // s9
  float v31; // s10
  float v32; // s26
  float v33; // s7
  float v34; // s11
  float v35; // s15
  float v36; // s2
  float v37; // s11
  float v38; // s9
  float v39; // s16
  float v40; // s4
  float v41; // s8
  float v42; // s9
  float v43; // s15
  float v44; // s6
  float v45; // s3
  float v46; // s5
  float v47; // s1
  float v48; // s3
  float v49; // s9
  float v50; // s15
  float v51; // s0
  float v52; // s2
  float v53; // s8
  float v54; // s10
  float v55; // s4
  float v56; // s14
  float v57; // s1
  float v58; // s6
  float v59; // s12
  float v60; // s27
  float v61; // s3
  float v62; // s6
  float v63; // s14
  float v64; // s20
  float v65; // s25
  float v66; // s8
  float v67; // s29
  float v68; // s13
  float v69; // s30
  float v70; // s26
  float v71; // s17
  float v72; // s2
  float v73; // s10
  float v74; // s4
  float v75; // s18
  float v76; // s12
  float v77; // s21
  float v78; // s15
  float v79; // s31
  float v80; // s9
  float v81; // s28
  float v82; // s19
  float v83; // s16
  float v84; // s7
  float v85; // s14
  float v86; // s7
  float v87; // s0
  float v88; // s21
  float v89; // s24
  float v90; // s26
  float v91; // s1
  float v92; // s0
  float v93; // s8
  float v94; // s7
  float v95; // s28
  float v96; // s5
  float v97; // s7
  float v98; // s30
  float v99; // s5
  float v100; // s20
  float v101; // s19
  float v102; // s11
  float v103; // s24
  float v104; // s13
  float v105; // s1
  float v106; // s17
  float v107; // s27
  float v108; // s23
  float v109; // s24
  float v110; // s5
  float v111; // s15
  float v112; // s3
  float v113; // s1
  float v114; // s14
  float v115; // s8
  float v116; // s6
  float v117; // s7
  float v118; // s2
  float v119; // s3
  float v120; // s9
  float v121; // s5
  float v122; // s7
  float v123; // r4
  float v124; // r5
  float v125; // s8
  float v126; // s1
  float v127; // s12
  float v128; // s14
  float v129; // s11
  float v130; // s10
  float v131; // s3
  float v132; // s13
  float v133; // s18
  float v134; // s4
  float v135; // s7
  float v136; // s9
  float v137; // s21
  float v138; // s16
  float v139; // s22
  float v140; // s6
  float v141; // s28
  float v142; // s15
  float v143; // s26
  float v144; // s22
  float v145; // s30
  float v146; // s17
  float v147; // s24
  float v148; // s28
  float v149; // s24
  float v150; // s19
  float v151; // s3
  float v152; // s25
  float v153; // s14
  float v154; // s7
  float v155; // s10
  float v156; // s12
  float v157; // s5
  float v158; // s8
  float v159; // s9
  float *v160; // r0
  float v161; // [sp+0h] [bp-D8h]
  float v162; // [sp+4h] [bp-D4h]
  float v163; // [sp+8h] [bp-D0h]
  float v164; // [sp+Ch] [bp-CCh]
  float v165; // [sp+10h] [bp-C8h]
  float v166; // [sp+14h] [bp-C4h]
  float v167; // [sp+18h] [bp-C0h]
  float v168; // [sp+1Ch] [bp-BCh]
  float v169; // [sp+20h] [bp-B8h]
  float v170; // [sp+24h] [bp-B4h]
  float v171; // [sp+28h] [bp-B0h]
  float v172; // [sp+2Ch] [bp-ACh]
  float v173; // [sp+34h] [bp-A4h]
  float v174; // [sp+38h] [bp-A0h]
  float v175; // [sp+3Ch] [bp-9Ch]
  float v176; // [sp+40h] [bp-98h]
  float v177; // [sp+44h] [bp-94h]
  float v178; // [sp+4Ch] [bp-8Ch]
  float v179; // [sp+50h] [bp-88h]
  float v180; // [sp+54h] [bp-84h]
  float v181; // [sp+58h] [bp-80h]
  float v182; // [sp+5Ch] [bp-7Ch]
  float v183; // [sp+60h] [bp-78h]
  float v184; // [sp+64h] [bp-74h]
  float v185; // [sp+68h] [bp-70h]
  float v186; // [sp+6Ch] [bp-6Ch]
  float v187; // [sp+70h] [bp-68h]
  float v188; // [sp+74h] [bp-64h]
  float v189; // [sp+78h] [bp-60h]
  float v190; // [sp+7Ch] [bp-5Ch]
  float v191; // [sp+80h] [bp-58h]
  float v192; // [sp+84h] [bp-54h]
  float v193; // [sp+88h] [bp-50h]
  float v194; // [sp+8Ch] [bp-4Ch]

  v2 = (*m)[7];
  v3 = 0;
  v4 = (*m)[3];
  v5 = 0;
  if ( v2 == 0.0 )
    v3 = 1;
  if ( v4 == 0.0 )
    v5 = 1;
  if ( (v5 & v3) != 0 && (*m)[11] == 0.0 )
  {
    v6 = (*m)[13];
    v7 = 0;
    v8 = (*m)[12];
    v9 = 0;
    if ( v6 == 0.0 )
      v7 = 1;
    if ( v8 == 0.0 )
      v9 = 1;
    if ( (v9 & v7) != 0 && (*m)[14] == 0.0 )
    {
      v10 = (*m)[0];
      v11 = 0.0;
      v12 = (*m)[5];
      v13 = 1.0;
      v14 = (*m)[6];
      v15 = 0.0;
      v16 = (*m)[1];
      v17 = (*m)[0] * v12;
      v18 = (*m)[8];
      v19 = (*m)[0] * v14;
      v20 = v16 * v14;
      v21 = (*m)[10];
      v22 = (*m)[2];
      v23 = v14 * v18;
      v24 = (*m)[4];
      v25 = v21 * v16;
      v26 = (*m)[9];
      v27 = v18 * v22;
      v28 = 0.0;
      v29 = 0.0;
      v30 = (float)(v16 * v14) * v18;
      v31 = v14 * v26;
      v32 = v12 * v18;
      v33 = (float)(v22 * v24) - v19;
      v34 = v16 * v24;
      v35 = v21 * (float)(v16 * v24);
      v36 = (float)(v16 * v18) - (float)(v10 * v26);
      v37 = v17 - v34;
      v38 = (float)((float)((float)(v17 * v21) + v30) + (float)((float)(v22 * v24) * v26)) - (float)(v19 * v26);
      v39 = v12 * v22;
      v40 = v22 * v26;
      v41 = v12 * v21;
      v42 = v38 - v35;
      v43 = v24 * v26;
      v44 = v21 * v24;
      v45 = v18 * v39;
      v46 = (float)(v10 * v21) - v27;
      v47 = v43 - v32;
      v48 = v42 - v45;
      v49 = v40 - v25;
      v50 = v41 - v31;
      v51 = v36 / v48;
      v52 = v47 / v48;
      v53 = (float)(v23 - v44) / v48;
      v54 = (float)(v20 - v39) / v48;
      v55 = v46 / v48;
      v56 = v49 / v48;
      v57 = v50 / v48;
      v58 = v37 / v48;
      v59 = v33 / v48;
    }
    else
    {
      v125 = (*m)[8];
      v29 = 0.0;
      v126 = (*m)[5];
      v13 = 1.0;
      v127 = (*m)[10];
      v128 = (*m)[4];
      v129 = v126 * v125;
      v130 = (*m)[9];
      v131 = (*m)[6];
      v132 = (*m)[14];
      v133 = v128 * v130;
      v134 = v131 * v130;
      v135 = (*m)[1];
      v136 = (*m)[2];
      v137 = (*m)[0] * v126;
      v138 = v126 * v127;
      v139 = (*m)[0] * v130;
      v140 = (float)(v131 * v125) - (float)(v127 * v128);
      v141 = v139 * v132;
      v142 = (float)((float)((float)((float)((float)((float)(v127 * v128) * v6) + (float)((float)(v126 * v125) * v132))
                                   + (float)((float)(v131 * v130) * v8))
                           - (float)((float)(v128 * v130) * v132))
                   - (float)((float)(v126 * v127) * v8))
           - (float)((float)(v131 * v125) * v6);
      v143 = v127 * v135;
      v144 = (float)(v135 * v125) - v139;
      v145 = v125 * v136;
      v146 = (*m)[0] * v127;
      v147 = (float)((float)((float)((float)(v125 * v136) * v6) + (float)(v141 + (float)((float)(v127 * v135) * v8)))
                   - (float)(v146 * v6))
           - (float)((float)(v135 * v125) * v132);
      v148 = v136 * v130;
      v149 = v147 - (float)((float)(v136 * v130) * v8);
      v150 = v135 * v131;
      v151 = (*m)[0] * v131;
      v152 = v136 * v128;
      v153 = v135 * v128;
      v154 = v137 - v153;
      v155 = (float)((float)((float)((float)(v137 * v127) + (float)(v150 * v125)) + (float)(v152 * v130))
                   - (float)(v151 * v130))
           - (float)(v127 * v153);
      v156 = v126 * v136;
      v157 = v155 - (float)(v125 * (float)(v126 * v136));
      v57 = (float)(v138 - v134) / v157;
      v158 = (float)((float)(v151 * v6) + (float)(v153 * v132)) + (float)(v156 * v8);
      v28 = v142 / v157;
      v56 = (float)(v148 - v143) / v157;
      v159 = (float)((float)((float)(v158 - (float)(v137 * v132)) - (float)(v150 * v8)) - (float)(v152 * v6)) / v157;
      v55 = (float)(v146 - v145) / v157;
      v53 = v140 / v157;
      v51 = v144 / v157;
      v52 = (float)(v133 - v129) / v157;
      v54 = (float)(v150 - v156) / v157;
      v58 = v154 / v157;
      v59 = (float)(v152 - v151) / v157;
      v11 = v159;
      v15 = v149 / v157;
    }
    v123 = 0.0;
    v124 = 0.0;
  }
  else
  {
    v60 = (*m)[2];
    v61 = (*m)[11];
    v62 = (*m)[10];
    v63 = (*m)[4];
    v64 = (*m)[0] * v61;
    v65 = (*m)[0] * v62;
    v66 = (*m)[1];
    v67 = v63 * v60;
    v68 = (*m)[0] * v2;
    v69 = v2 * v60;
    v70 = v63 * v4;
    v192 = v61 * v60;
    v71 = (*m)[8];
    v72 = (*m)[12];
    v73 = (*m)[15];
    v74 = (*m)[14];
    v189 = v62 * v4;
    v194 = (float)((float)((float)((float)((float)(v65 * v73) + (float)(v72 * (float)(v61 * v60)))
                                 + (float)(v74 * (float)(v71 * v4)))
                         - (float)(v64 * v74))
                 - (float)(v73 * (float)(v71 * v60)))
         - (float)(v72 * (float)(v62 * v4));
    v75 = (*m)[6];
    v76 = (*m)[0] * v75;
    v193 = (float)((float)((float)((float)((float)(v68 * v74) + (float)(v73 * (float)(v63 * v60)))
                                 + (float)(v72 * (float)(v75 * v4)))
                         - (float)(v73 * v76))
                 - (float)(v72 * (float)(v2 * v60)))
         - (float)(v74 * (float)(v63 * v4));
    v77 = (*m)[5];
    v78 = (*m)[9];
    v190 = v2 * v71;
    v79 = (*m)[0] * v77;
    v184 = v77 * v61;
    v80 = (*m)[13];
    v179 = (*m)[7];
    v177 = v69;
    v178 = v75 * v4;
    v187 = v61 * v63;
    v181 = v179 * v78;
    v182 = v61 * v66;
    v191 = (float)((float)((float)((float)(v80 * v190)
                                 + (float)((float)(v73 * (float)(v78 * v63)) + (float)((float)(v77 * v61) * v72)))
                         - (float)(v80 * (float)(v61 * v63)))
                 - (float)(v73 * (float)(v77 * v71)))
         - (float)((float)(v179 * v78) * v72);
    v81 = v66 * v71;
    v186 = v78 * v4;
    v188 = (float)(v72 * (float)(v78 * v4))
         + (float)((float)(v73 * (float)(v66 * v71))
                 + (float)((float)(v64 * v80)
                         + (float)((float)((float)-(float)((float)(v61 * v66) * v72)
                                         - (float)(v73 * (float)((*m)[0] * v78)))
                                 - (float)(v80 * (float)(v71 * v4)))));
    v82 = v66 * v63;
    v175 = v62 * v63;
    v174 = v179 * v66;
    v168 = v75 * v78;
    v83 = v77 * v4;
    v84 = (float)((float)((float)(v75 * v78) * v72)
                + (float)((float)(v80 * (float)(v62 * v63)) + (float)(v74 * (float)(v77 * v71))))
        - (float)(v74 * (float)(v78 * v63));
    v85 = (float)(v77 * v62) * v73;
    v86 = v84 - (float)((float)(v77 * v62) * v72);
    v185 = (float)((float)((float)((float)((float)(v79 * v73) + (float)((float)(v179 * v66) * v72)) + (float)(v80 * v70))
                         - (float)(v80 * v68))
                 - (float)(v73 * v82))
         - (float)(v72 * (float)(v77 * v4));
    v87 = v77 * v60;
    v88 = v75 * v71;
    v169 = v78 * v178;
    v170 = v71 * v178;
    v161 = v87;
    v166 = v61 * v87;
    v164 = v62 * (float)(v179 * v66);
    v89 = v62 * v70;
    v90 = v78 * v70;
    v91 = (float)(v164 + (float)(v61 * v87)) + (float)(v78 * v178);
    v92 = v75 * v66;
    v176 = v86 - (float)(v80 * (float)(v75 * v71));
    v93 = v62 * v66;
    v163 = v89;
    v171 = v61 * v92;
    v172 = v78 * v69;
    v94 = v74 * v81;
    v95 = v92 * v71;
    v183 = (float)((float)(v91 - (float)(v61 * v92)) - (float)(v78 * v69)) - (float)(v62 * v83);
    v165 = v62 * v68;
    v96 = (float)((float)((float)((float)((float)((*m)[0] * v78) * v74) + (float)(v93 * v72))
                        + (float)(v80 * (float)(v71 * v60)))
                - (float)(v65 * v80))
        - v94;
    v97 = v78 * v60;
    v162 = v71 * v69;
    v98 = (float)(v76 * v61) * v80;
    v173 = v96 - (float)(v72 * (float)(v78 * v60));
    v99 = v74 * v82;
    v167 = v61 * v67;
    v100 = v61 * v82;
    v101 = v62 * v82;
    v102 = v68 * v78;
    v180 = (float)((float)((float)((float)((float)(v76 * v61) + v162) + v89) - (float)(v62 * v68)) - (float)(v61 * v67))
         - (float)(v71 * v178);
    v103 = (float)((float)(v68 * v78) + v100) + (float)(v71 * v83);
    v104 = v174 * v71;
    v105 = v74 * (float)(v71 * v83);
    v106 = v71 * v161;
    v107 = (float)((float)((float)((float)((float)(v76 * v80) + v99) + (float)(v72 * v161)) - (float)(v79 * v74))
                 - (float)(v92 * v72))
         - (float)(v80 * v67);
    v108 = (float)(v103 - v104) - v90;
    v109 = v79 * v61;
    v110 = v78 * v67;
    v111 = v76 * v78;
    v112 = v75 * v61;
    v113 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v72 * v169) + (float)(v105 + (float)((float)(v80 * v163) + (float)((float)(v80 * v162) + (float)((float)(v72 * v166) + (float)((float)((float)(v164 * v72) + (float)((float)(v73 * v95) + (float)((float)((float)((float)((float)(v79 * v62) * v73) + v98) + (float)(v102 * v74)) + (float)(v74 * v100)))) + (float)(v73 * v110)))))))
                                                                                                 - (float)(v109 * v74))
                                                                                         - (float)(v73 * v111))
                                                                                 - (float)(v80 * v165))
                                                                         - (float)(v73 * v101))
                                                                 - (float)(v171 * v72))
                                                         - (float)(v74 * v104))
                                                 - (float)(v80 * v167))
                                         - (float)(v73 * v106))
                                 - (float)(v72 * v172))
                         - (float)(v74 * v90))
                 - (float)(v72 * (float)(v62 * v83)))
         - (float)(v80 * v170);
    v13 = (float)((float)((float)((float)((float)((float)(v79 * v62) + v95) + v110) - v111) - v101) - v106) / v113;
    v11 = v107 / v113;
    v114 = (float)((float)((float)(v85 + (float)(v112 * v80)) + (float)(v181 * v74)) - (float)(v184 * v74))
         - (float)(v73 * v168);
    v115 = (float)((float)((float)((float)(v74 * v182) + (float)(v73 * v97)) + (float)(v80 * v189)) - (float)(v73 * v93))
         - (float)(v80 * v192);
    v116 = v62 * v179;
    v117 = v116 * v72;
    v118 = v112 * v72;
    v119 = (float)((float)((float)((float)((float)(v73 * v92) + (float)(v80 * v177)) + (float)(v74 * v83))
                         - (float)(v74 * v174))
                 - (float)(v73 * v161))
         - (float)(v80 * v178);
    v120 = v114 - (float)(v80 * v116);
    v15 = v173 / v113;
    v28 = v176 / v113;
    v121 = (float)((float)((float)(v117 + (float)((float)(v74 * v187) + (float)(v73 * v88))) - (float)(v73 * v175))
                 - v118)
         - (float)(v74 * v190);
    v122 = v115 - (float)(v74 * v186);
    v29 = (float)(v108 - v109) / v113;
    v123 = v180 / v113;
    v58 = v185 / v113;
    v124 = v183 / v113;
    v59 = v193 / v113;
    v51 = v188 / v113;
    v52 = v191 / v113;
    v55 = v194 / v113;
    v53 = v121 / v113;
    v54 = v119 / v113;
    v56 = v122 / v113;
    v57 = v120 / v113;
  }
  (*result)[0] = v57;
  (*result)[1] = v56;
  (*result)[2] = v54;
  (*result)[3] = v124;
  (*result)[4] = v53;
  (*result)[5] = v55;
  (*result)[6] = v59;
  (*result)[7] = v123;
  (*result)[8] = v52;
  (*result)[9] = v51;
  (*result)[10] = v58;
  (*result)[11] = v29;
  (*result)[12] = v28;
  v160 = &(*result)[13];
  *v160 = v15;
  v160[1] = v11;
  v160[2] = v13;
}

//----- (0027843E) --------------------------------------------------------
void __fastcall NvBuildIdentityMatf(GLfloat_0 (*r)[4])
{
  _QWORD *v1; // r1
  _QWORD *v2; // r0

  (*r)[0] = 1.0;
  (*r)[5] = 1.0;
  (*r)[10] = 1.0;
  (*r)[15] = 1.0;
  *(_QWORD *)&(*r)[1] = 0LL;
  *(_QWORD *)&(*r)[3] = 0LL;
  v1 = &(*r)[6];
  v2 = &(*r)[11];
  *v1 = 0LL;
  v1[1] = 0LL;
  *v2 = 0LL;
  v2[1] = 0LL;
}

//----- (00278464) --------------------------------------------------------
void __fastcall NvBuildTranslateMatf(GLfloat_0 (*r)[4], GLfloat_0 x, GLfloat_0 y, GLfloat_0 z)
{
  _QWORD *v4; // r1
  _QWORD *v5; // r0

  (*r)[0] = 1.0;
  (*r)[5] = 1.0;
  (*r)[10] = 1.0;
  (*r)[11] = 0.0;
  (*r)[12] = x;
  v4 = &(*r)[1];
  (*r)[13] = y;
  (*r)[14] = z;
  (*r)[15] = 1.0;
  v5 = &(*r)[6];
  *v4 = 0LL;
  v4[1] = 0LL;
  *v5 = 0LL;
  v5[1] = 0LL;
}

//----- (00278498) --------------------------------------------------------
void __fastcall NvMultTranslateMatf(
        GLfloat_0 (*result)[4],
        const GLfloat_0 (*m)[4],
        GLfloat_0 x,
        GLfloat_0 y,
        GLfloat_0 z)
{
  GLfloat_0 *p_z; // lr
  float32x4_t v6; // q10
  float32x4_t v7; // q9
  float32x4_t v8; // q8
  float32x4_t v9; // q12
  float32x4_t v10; // 0:d22.8,8:d23.8

  p_z = &z;
  v6 = *(float32x4_t *)&(*m)[0];
  v10 = (float32x4_t)vld1q_dup_f32(p_z);
  v7 = *(float32x4_t *)&(*m)[8];
  v8 = *(float32x4_t *)&(*m)[12];
  v9 = *(float32x4_t *)&(*m)[4];
  *(float32x4_t *)&(*result)[0] = *(float32x4_t *)&(*m)[0];
  *(float32x4_t *)&(*result)[4] = v9;
  *(float32x4_t *)&(*result)[8] = v7;
  *(float32x4_t *)&(*result)[12] = vaddq_f32(
                                     v8,
                                     vaddq_f32(vaddq_f32(vmulq_n_f32(v6, x), vmulq_n_f32(v9, y)), vmulq_f32(v10, v7)));
}

//----- (00278540) --------------------------------------------------------
void __fastcall NvBuildScaleMatf(GLfloat_0 (*r)[4], GLfloat_0 x, GLfloat_0 y, GLfloat_0 z)
{
  _QWORD *v4; // r1
  _QWORD *v5; // r0

  (*r)[0] = x;
  (*r)[5] = y;
  (*r)[10] = z;
  (*r)[15] = 1.0;
  *(_QWORD *)&(*r)[1] = 0LL;
  *(_QWORD *)&(*r)[3] = 0LL;
  v4 = &(*r)[6];
  v5 = &(*r)[11];
  *v4 = 0LL;
  v4[1] = 0LL;
  *v5 = 0LL;
  v5[1] = 0LL;
}

//----- (00278566) --------------------------------------------------------
void __fastcall NvMultScaleMatf(GLfloat_0 (*result)[4], const GLfloat_0 (*m)[4], GLfloat_0 x, GLfloat_0 y, GLfloat_0 z)
{
  GLfloat_0 *p_z; // r12
  float32x4_t *v6; // lr
  float32x4_t v7; // q9
  float32x4_t v8; // q8
  _QWORD *v9; // r1
  float32x4_t v10; // q12
  __int64 v11; // d21
  float32x4_t v12; // 0:d22.8,8:d23.8

  p_z = &z;
  v6 = (float32x4_t *)&(*m)[4];
  v7 = *(float32x4_t *)&(*m)[8];
  v8 = vmulq_n_f32(*(float32x4_t *)&(*m)[0], x);
  v12 = (float32x4_t)vld1q_dup_f32(p_z);
  v9 = &(*m)[12];
  v10 = vmulq_n_f32(*v6, y);
  v11 = v9[1];
  *(_QWORD *)&(*result)[12] = *v9;
  *(_QWORD *)&(*result)[14] = v11;
  *(float32x4_t *)&(*result)[0] = v8;
  *(float32x4_t *)&(*result)[4] = v10;
  *(float32x4_t *)&(*result)[8] = vmulq_f32(v12, v7);
}

//----- (002785B8) --------------------------------------------------------
void __fastcall NvBuildRotXRadMatf(GLfloat_0 (*r)[4], GLfloat_0 radians)
{
  GLfloat_0 v4; // r0
  float v5; // s20
  float v6; // r0

  (*r)[0] = 1.0;
  (*r)[7] = 0.0;
  (*r)[8] = 0.0;
  (*r)[15] = 1.0;
  v4 = sinf(radians);
  (*r)[6] = v4;
  v5 = v4;
  v6 = cosf(radians);
  (*r)[5] = v6;
  (*r)[10] = v6;
  *(_QWORD *)&(*r)[1] = 0LL;
  *(_QWORD *)&(*r)[3] = 0LL;
  *(_QWORD *)&(*r)[11] = 0LL;
  *(_QWORD *)&(*r)[13] = 0LL;
  (*r)[9] = -v5;
}

//----- (00278610) --------------------------------------------------------
void __fastcall NvBuildRotYRadMatf(GLfloat_0 (*r)[4], GLfloat_0 radians)
{
  float v4; // r6
  float v5; // r0

  (*r)[1] = 0.0;
  (*r)[7] = 0.0;
  (*r)[9] = 0.0;
  (*r)[15] = 1.0;
  v4 = sinf(radians);
  v5 = cosf(radians);
  (*r)[0] = v5;
  (*r)[8] = v4;
  (*r)[10] = v5;
  *(_QWORD *)&(*r)[3] = 0LL;
  *(_QWORD *)&(*r)[5] = 1065353216LL;
  *(_QWORD *)&(*r)[11] = 0LL;
  *(_QWORD *)&(*r)[13] = 0LL;
  (*r)[2] = -v4;
}

//----- (00278690) --------------------------------------------------------
void __fastcall NvBuildRotZRadMatf(GLfloat_0 (*r)[4], GLfloat_0 radians)
{
  GLfloat_0 v4; // r0
  float v5; // s20
  float v6; // r0

  (*r)[2] = 0.0;
  (*r)[3] = 0.0;
  (*r)[10] = 1.0;
  (*r)[15] = 1.0;
  v4 = sinf(radians);
  (*r)[1] = v4;
  v5 = v4;
  v6 = cosf(radians);
  (*r)[0] = v6;
  (*r)[5] = v6;
  *(_QWORD *)&(*r)[6] = 0LL;
  *(_QWORD *)&(*r)[8] = 0LL;
  *(_QWORD *)&(*r)[11] = 0LL;
  *(_QWORD *)&(*r)[13] = 0LL;
  (*r)[4] = -v5;
}

//----- (002786E2) --------------------------------------------------------
void __fastcall NvMultRotXRadMatf(GLfloat_0 (*result)[4], const GLfloat_0 (*m)[4], GLfloat_0 radians)
{
  float v6; // r8
  float v7; // r0
  float32x4_t v8; // q9
  __int64 v9; // d16
  __int64 v10; // d17
  float32x4_t v11; // q10
  __int64 v12; // d27

  v6 = sinf(radians);
  v7 = cosf(radians);
  v8 = *(float32x4_t *)&(*m)[8];
  v9 = *(_QWORD *)&(*m)[0];
  v10 = *(_QWORD *)&(*m)[2];
  v11 = *(float32x4_t *)&(*m)[4];
  v12 = *(_QWORD *)&(*m)[14];
  *(_QWORD *)&(*result)[12] = *(_QWORD *)&(*m)[12];
  *(_QWORD *)&(*result)[14] = v12;
  *(_QWORD *)&(*result)[0] = v9;
  *(_QWORD *)&(*result)[2] = v10;
  *(float32x4_t *)&(*result)[4] = vaddq_f32(vmulq_n_f32(v11, v7), vmulq_n_f32(v8, v6));
  *(float32x4_t *)&(*result)[8] = vaddq_f32(vmulq_n_f32(v11, -v6), vmulq_n_f32(v8, v7));
}

//----- (0027875A) --------------------------------------------------------
void __fastcall NvMultRotYRadMatf(GLfloat_0 (*result)[4], const GLfloat_0 (*m)[4], GLfloat_0 radians)
{
  float v6; // s16
  float v7; // s0
  float32x4_t v8; // q8
  _QWORD *v9; // r0
  float32x4_t v10; // q9
  __int64 v11; // d24
  __int64 v12; // d25
  __int64 v13; // d23

  v6 = sinf(radians);
  v7 = cosf(radians);
  v8 = *(float32x4_t *)&(*m)[8];
  v9 = &(*m)[12];
  v10 = *(float32x4_t *)&(*m++)[0];
  v11 = *(_QWORD *)&(*m)[0];
  v12 = *(_QWORD *)&(*m)[2];
  v13 = v9[1];
  *(_QWORD *)&(*result)[12] = *v9;
  *(_QWORD *)&(*result)[14] = v13;
  *(float32x4_t *)&(*result)[8] = vaddq_f32(vmulq_n_f32(v10, v6), vmulq_n_f32(v8, v7));
  *(float32x4_t *)&(*result++)[0] = vaddq_f32(vmulq_n_f32(v10, v7), vmulq_n_f32(v8, -v6));
  *(_QWORD *)&(*result)[0] = v11;
  *(_QWORD *)&(*result)[2] = v12;
}

//----- (002787D6) --------------------------------------------------------
void __fastcall NvMultRotZRadMatf(GLfloat_0 (*result)[4], const GLfloat_0 (*m)[4], GLfloat_0 radians)
{
  float v6; // s16
  float v7; // r0
  float32x4_t v8; // q8
  float32x4_t v9; // q9
  __int64 v10; // d24
  __int64 v11; // d25
  __int64 v12; // d27
  float32x4_t v13; // q10

  v6 = sinf(radians);
  v7 = cosf(radians);
  v8 = *(float32x4_t *)&(*m)[0];
  v9 = *(float32x4_t *)&(*m)[4];
  v10 = *(_QWORD *)&(*m)[12];
  v11 = *(_QWORD *)&(*m)[14];
  v12 = *(_QWORD *)&(*m)[10];
  v13 = vaddq_f32(vmulq_n_f32(*(float32x4_t *)&(*m)[0], v7), vmulq_n_f32(v9, v6));
  *(_QWORD *)&(*result)[8] = *(_QWORD *)&(*m)[8];
  *(_QWORD *)&(*result)[10] = v12;
  *(_QWORD *)&(*result)[12] = v10;
  *(_QWORD *)&(*result)[14] = v11;
  *(float32x4_t *)&(*result)[0] = v13;
  *(float32x4_t *)&(*result)[4] = vaddq_f32(vmulq_n_f32(v8, -v6), vmulq_n_f32(v9, v7));
}

//----- (00278854) --------------------------------------------------------
void __fastcall NvBuildRotRadMatf(GLfloat_0 (*result)[4], const GLfloat_0 *axis, GLfloat_0 radians)
{
  float v3; // s20
  float v4; // s22
  float v6; // s18
  float v7; // s24
  float v8; // r5
  float v9; // r0
  float v10; // s18
  float v11; // s22
  float v12; // s20
  float v13; // s0
  float v14; // s2
  float v15; // s6
  float v16; // s0

  v3 = *axis;
  v4 = axis[1];
  v6 = axis[2];
  v7 = sqrtf((float)((float)(v3 * v3) + (float)(v4 * v4)) + (float)(v6 * v6));
  if ( v7 <= 0.00000011921 )
  {
    v10 = 0.0;
    v13 = 1.0;
    v11 = 0.0;
    v12 = 0.0;
  }
  else
  {
    v8 = radians * 0.5;
    v9 = sinf(radians * 0.5);
    v10 = v6 * (float)(v9 / v7);
    v11 = v4 * (float)(v9 / v7);
    v12 = v3 * (float)(v9 / v7);
    v13 = cosf(v8);
  }
  (*result)[3] = 0.0;
  (*result)[7] = 0.0;
  v14 = v13 * v11;
  v15 = v13 * v10;
  v16 = v13 * v12;
  *(_QWORD *)&(*result)[11] = 0LL;
  *(_QWORD *)&(*result)[13] = 0LL;
  (*result)[15] = 1.0;
  (*result)[0] = (float)((float)((float)(v10 * v10) + (float)(v11 * v11)) * -2.0) + 1.0;
  (*result)[1] = (float)(v15 + (float)(v11 * v12)) + (float)(v15 + (float)(v11 * v12));
  (*result)[2] = (float)((float)(v10 * v12) - v14) + (float)((float)(v10 * v12) - v14);
  (*result)[4] = (float)((float)(v11 * v12) - v15) + (float)((float)(v11 * v12) - v15);
  (*result)[5] = 1.0
               - (float)((float)((float)(v10 * v10) + (float)(v12 * v12))
                       + (float)((float)(v10 * v10) + (float)(v12 * v12)));
  (*result)[6] = (float)((float)(v10 * v11) + v16) + (float)((float)(v10 * v11) + v16);
  (*result)[8] = (float)(v14 + (float)(v10 * v12)) + (float)(v14 + (float)(v10 * v12));
  (*result)[9] = (float)((float)(v10 * v11) - v16) + (float)((float)(v10 * v11) - v16);
  (*result)[10] = 1.0
                - (float)((float)((float)(v11 * v11) + (float)(v12 * v12))
                        + (float)((float)(v11 * v11) + (float)(v12 * v12)));
}

//----- (002789A0) --------------------------------------------------------
void __fastcall NvMultRotRadMatf(
        GLfloat_0 (*result)[4],
        const GLfloat_0 (*m)[4],
        const GLfloat_0 *axis,
        GLfloat_0 radians)
{
  float v4; // s22
  float v5; // s20
  float v7; // s18
  float v9; // s24
  float v10; // r6
  float v11; // r0
  float v12; // s18
  float v13; // s20
  float v14; // s22
  float v15; // s6
  float v16; // s12
  float v17; // s2
  float v18; // s6
  float v19; // s3
  float v20; // s10
  float v21; // s14
  float v22; // s1
  float v23; // s2
  float v24; // s8
  float v25; // s0
  float v26; // s14
  float v27; // s6

  v4 = *axis;
  v5 = axis[1];
  v7 = axis[2];
  v9 = sqrtf((float)((float)(v4 * v4) + (float)(v5 * v5)) + (float)(v7 * v7));
  if ( v9 <= 0.00000011921 )
  {
    v12 = 0.0;
    v15 = 1.0;
    v13 = 0.0;
    v14 = 0.0;
  }
  else
  {
    v10 = radians * 0.5;
    v11 = sinf(radians * 0.5);
    v12 = v7 * (float)(v11 / v9);
    v13 = v5 * (float)(v11 / v9);
    v14 = v4 * (float)(v11 / v9);
    v15 = cosf(v10);
  }
  v16 = v15 * v12;
  v17 = v15 * v13;
  v18 = v15 * v14;
  v19 = (float)(v16 + (float)(v13 * v14)) + (float)(v16 + (float)(v13 * v14));
  v20 = (float)((float)(v13 * v14) - v16) + (float)((float)(v13 * v14) - v16);
  v21 = (float)((float)((float)(v12 * v12) + (float)(v13 * v13)) * -2.0) + 1.0;
  v22 = (float)((float)(v12 * v14) - v17) + (float)((float)(v12 * v14) - v17);
  v23 = (float)(v17 + (float)(v12 * v14)) + (float)(v17 + (float)(v12 * v14));
  (*result)[0] = (float)((float)(*m)[8] * v22) + (float)((float)((*m)[0] * v21) + (float)((float)(*m)[4] * v19));
  (*result)[1] = (float)((float)(v21 * (float)(*m)[1]) + (float)(v19 * (float)(*m)[5])) + (float)(v22 * (float)(*m)[9]);
  (*result)[2] = (float)((float)(v21 * (float)(*m)[2]) + (float)(v19 * (float)(*m)[6])) + (float)(v22 * (float)(*m)[10]);
  v24 = 1.0
      - (float)((float)((float)(v12 * v12) + (float)(v14 * v14)) + (float)((float)(v12 * v12) + (float)(v14 * v14)));
  v25 = 1.0
      - (float)((float)((float)(v13 * v13) + (float)(v14 * v14)) + (float)((float)(v13 * v13) + (float)(v14 * v14)));
  (*result)[3] = (float)((float)(v21 * (float)(*m)[3]) + (float)(v19 * (float)(*m)[7])) + (float)(v22 * (float)(*m)[11]);
  v26 = (float)((float)(v12 * v13) + v18) + (float)((float)(v12 * v13) + v18);
  v27 = (float)((float)(v12 * v13) - v18) + (float)((float)(v12 * v13) - v18);
  (*result)[4] = (float)((float)(v20 * (*m)[0]) + (float)(v24 * (float)(*m)[4])) + (float)(v26 * (float)(*m)[8]);
  (*result)[5] = (float)((float)(v20 * (float)(*m)[1]) + (float)(v24 * (float)(*m)[5])) + (float)(v26 * (float)(*m)[9]);
  (*result)[6] = (float)((float)(v20 * (float)(*m)[2]) + (float)(v24 * (float)(*m)[6])) + (float)(v26 * (float)(*m)[10]);
  (*result)[7] = (float)((float)(v20 * (float)(*m)[3]) + (float)(v24 * (float)(*m)[7])) + (float)(v26 * (float)(*m)[11]);
  (*result)[8] = (float)((float)(v23 * (*m)[0]) + (float)(v27 * (float)(*m)[4])) + (float)(v25 * (float)(*m)[8]);
  (*result)[9] = (float)((float)(v23 * (float)(*m)[1]) + (float)(v27 * (float)(*m)[5])) + (float)(v25 * (float)(*m)[9]);
  (*result)[10] = (float)((float)(v23 * (float)(*m)[2]) + (float)(v27 * (float)(*m)[6]))
                + (float)(v25 * (float)(*m)[10]);
  (*result)[11] = (float)((float)(v23 * (float)(*m)[3]) + (float)(v27 * (float)(*m)[7]))
                + (float)(v25 * (float)(*m)[11]);
  (*result)[12] = (*m)[12];
  (*result)[13] = (*m)[13];
  (*result)[14] = (*m)[14];
  (*result)[15] = (*m)[15];
}

//----- (00278C7C) --------------------------------------------------------
void __fastcall NvBuildRotXDegMatf(GLfloat_0 (*r)[4], GLfloat_0 degrees)
{
  _QWORD *v3; // r0
  float v4; // r5
  float v5; // r0
  GLfloat_0 v6; // s20
  float v7; // r0

  (*r)[0] = 1.0;
  (*r)[7] = 0.0;
  (*r)[8] = 0.0;
  v3 = &(*r)[1];
  *v3 = 0LL;
  v3[1] = 0LL;
  v4 = degrees * 0.017453;
  v5 = sinf(degrees * 0.017453);
  *(_QWORD *)&(*r)[11] = 0LL;
  *(_QWORD *)&(*r)[13] = 0LL;
  v6 = -v5;
  (*r)[15] = 1.0;
  (*r)[6] = v5;
  v7 = cosf(v4);
  (*r)[5] = v7;
  (*r)[10] = v7;
  (*r)[9] = v6;
}

//----- (00278CF0) --------------------------------------------------------
void __fastcall NvBuildRotYDegMatf(GLfloat_0 (*r)[4], GLfloat_0 degrees)
{
  float v3; // r5
  float v4; // r6
  float v5; // r0

  (*r)[1] = 0.0;
  (*r)[7] = 0.0;
  (*r)[9] = 0.0;
  (*r)[15] = 1.0;
  v3 = degrees * 0.017453;
  v4 = sinf(degrees * 0.017453);
  *(_QWORD *)&(*r)[3] = 0LL;
  *(_QWORD *)&(*r)[5] = 1065353216LL;
  *(_QWORD *)&(*r)[11] = 0LL;
  *(_QWORD *)&(*r)[13] = 0LL;
  v5 = cosf(v3);
  (*r)[0] = v5;
  (*r)[8] = v4;
  (*r)[10] = v5;
  (*r)[2] = -v4;
}

//----- (00278D74) --------------------------------------------------------
void __fastcall NvBuildRotZDegMatf(GLfloat_0 (*r)[4], GLfloat_0 degrees)
{
  _QWORD *v3; // r0
  float v4; // r5
  float v5; // r0
  GLfloat_0 v6; // s20
  float v7; // r0

  (*r)[2] = 0.0;
  (*r)[3] = 0.0;
  v3 = &(*r)[6];
  (*r)[10] = 1.0;
  *v3 = 0LL;
  v3[1] = 0LL;
  v4 = degrees * 0.017453;
  v5 = sinf(degrees * 0.017453);
  *(_QWORD *)&(*r)[11] = 0LL;
  *(_QWORD *)&(*r)[13] = 0LL;
  v6 = -v5;
  (*r)[15] = 1.0;
  (*r)[1] = v5;
  v7 = cosf(v4);
  (*r)[0] = v7;
  (*r)[5] = v7;
  (*r)[4] = v6;
}

//----- (00278DE0) --------------------------------------------------------
void __fastcall NvMultRotXDegMatf(GLfloat_0 (*r)[4], const GLfloat_0 (*m)[4], GLfloat_0 degrees)
{
  float v5; // r6
  float v6; // r8
  float v7; // r0
  float32x4_t v8; // q9
  __int64 v9; // d16
  __int64 v10; // d17
  float32x4_t v11; // q10
  __int64 v12; // d27

  v5 = degrees * 0.017453;
  v6 = sinf(degrees * 0.017453);
  v7 = cosf(v5);
  v8 = *(float32x4_t *)&(*m)[8];
  v9 = *(_QWORD *)&(*m)[0];
  v10 = *(_QWORD *)&(*m)[2];
  v11 = *(float32x4_t *)&(*m)[4];
  v12 = *(_QWORD *)&(*m)[14];
  *(_QWORD *)&(*r)[12] = *(_QWORD *)&(*m)[12];
  *(_QWORD *)&(*r)[14] = v12;
  *(_QWORD *)&(*r)[0] = v9;
  *(_QWORD *)&(*r)[2] = v10;
  *(float32x4_t *)&(*r)[4] = vaddq_f32(vmulq_n_f32(v11, v7), vmulq_n_f32(v8, v6));
  *(float32x4_t *)&(*r)[8] = vaddq_f32(vmulq_n_f32(v11, -v6), vmulq_n_f32(v8, v7));
}

//----- (00278E6C) --------------------------------------------------------
void __fastcall NvMultRotYDegMatf(GLfloat_0 (*r)[4], const GLfloat_0 (*m)[4], GLfloat_0 degrees)
{
  float v5; // r6
  float v6; // s16
  float v7; // s0
  float32x4_t v8; // q8
  _QWORD *v9; // r0
  float32x4_t v10; // q9
  __int64 v11; // d24
  __int64 v12; // d25
  __int64 v13; // d23

  v5 = degrees * 0.017453;
  v6 = sinf(degrees * 0.017453);
  v7 = cosf(v5);
  v8 = *(float32x4_t *)&(*m)[8];
  v9 = &(*m)[12];
  v10 = *(float32x4_t *)&(*m++)[0];
  v11 = *(_QWORD *)&(*m)[0];
  v12 = *(_QWORD *)&(*m)[2];
  v13 = v9[1];
  *(_QWORD *)&(*r)[12] = *v9;
  *(_QWORD *)&(*r)[14] = v13;
  *(float32x4_t *)&(*r)[8] = vaddq_f32(vmulq_n_f32(v10, v6), vmulq_n_f32(v8, v7));
  *(float32x4_t *)&(*r++)[0] = vaddq_f32(vmulq_n_f32(v10, v7), vmulq_n_f32(v8, -v6));
  *(_QWORD *)&(*r)[0] = v11;
  *(_QWORD *)&(*r)[2] = v12;
}

//----- (00278EFC) --------------------------------------------------------
void __fastcall NvMultRotZDegMatf(GLfloat_0 (*r)[4], const GLfloat_0 (*m)[4], GLfloat_0 degrees)
{
  float v5; // r6
  float v6; // s16
  float v7; // r0
  float32x4_t v8; // q8
  float32x4_t v9; // q9
  __int64 v10; // d24
  __int64 v11; // d25
  __int64 v12; // d27
  float32x4_t v13; // q10

  v5 = degrees * 0.017453;
  v6 = sinf(degrees * 0.017453);
  v7 = cosf(v5);
  v8 = *(float32x4_t *)&(*m)[0];
  v9 = *(float32x4_t *)&(*m)[4];
  v10 = *(_QWORD *)&(*m)[12];
  v11 = *(_QWORD *)&(*m)[14];
  v12 = *(_QWORD *)&(*m)[10];
  v13 = vaddq_f32(vmulq_n_f32(*(float32x4_t *)&(*m)[0], v7), vmulq_n_f32(v9, v6));
  *(_QWORD *)&(*r)[8] = *(_QWORD *)&(*m)[8];
  *(_QWORD *)&(*r)[10] = v12;
  *(_QWORD *)&(*r)[12] = v10;
  *(_QWORD *)&(*r)[14] = v11;
  *(float32x4_t *)&(*r)[0] = v13;
  *(float32x4_t *)&(*r)[4] = vaddq_f32(vmulq_n_f32(v8, -v6), vmulq_n_f32(v9, v7));
}

//----- (00278F8C) --------------------------------------------------------
void __fastcall NvBuildRotDegMatf(GLfloat_0 (*r)[4], const GLfloat_0 *axis, GLfloat_0 degrees)
{
  NvBuildRotRadMatf(r, axis, degrees * 0.017453);
}

//----- (00278FA4) --------------------------------------------------------
void __fastcall NvMultRotDegMatf(GLfloat_0 (*r)[4], const GLfloat_0 (*m)[4], const GLfloat_0 *axis, GLfloat_0 degrees)
{
  NvMultRotRadMatf(r, m, axis, degrees * 0.017453);
}

//----- (00278FBC) --------------------------------------------------------
void __fastcall NvBuildLookatMatf(GLfloat_0 (*r)[4], const GLfloat_0 *eye, const GLfloat_0 *obj, const GLfloat_0 *up)
{
  float v4; // s8
  float v5; // s2
  float v6; // s0
  float v7; // s6
  float v8; // s10
  float v9; // s4
  GLfloat_0 v10; // s0
  GLfloat_0 v11; // s2
  GLfloat_0 v12; // s4
  float v13; // s8
  float v14; // s12
  float v15; // s12
  float v16; // s10
  float v17; // s6
  float v18; // s8
  GLfloat_0 v19; // s6
  GLfloat_0 v20; // s12
  GLfloat_0 v21; // s8
  GLfloat_0 v22; // s10
  GLfloat_0 v23; // s14
  GLfloat_0 v24; // s1
  float v25; // s2
  float v26; // s10
  float v27; // s4

  v4 = eye[1] - obj[1];
  v5 = *eye - *obj;
  v6 = eye[2] - obj[2];
  v7 = *up;
  v8 = up[2];
  v9 = sqrtf((float)((float)(v5 * v5) + (float)(v4 * v4)) + (float)(v6 * v6));
  v10 = v6 / v9;
  v11 = v5 / v9;
  v12 = v4 / v9;
  v13 = up[1];
  v14 = *up * v10;
  (*r)[3] = 0.0;
  (*r)[7] = 0.0;
  (*r)[11] = 0.0;
  v15 = (float)(v8 * v11) - v14;
  v16 = (float)(v13 * v10) - (float)(v8 * v12);
  v17 = (float)(v7 * v12) - (float)(v13 * v11);
  v18 = sqrtf((float)(v17 * v17) + (float)((float)(v16 * v16) + (float)(v15 * v15)));
  v19 = v17 / v18;
  v20 = v15 / v18;
  v21 = v16 / v18;
  (*r)[0] = v21;
  v22 = (float)(v12 * v19) - (float)(v10 * v20);
  v23 = (float)(v10 * v21) - (float)(v11 * v19);
  v24 = (float)(v11 * v20) - (float)(v12 * v21);
  (*r)[1] = v22;
  (*r)[2] = v11;
  (*r)[4] = v20;
  (*r)[5] = v23;
  (*r)[6] = v12;
  (*r)[8] = v19;
  (*r)[9] = v24;
  (*r)[10] = v10;
  (*r)[12] = (float)((float)-(float)(v20 * eye[1]) - (float)(v21 * *eye)) - (float)(v19 * eye[2]);
  (*r)[13] = (float)((float)-(float)(v23 * eye[1]) - (float)(v22 * *eye)) - (float)(v24 * eye[2]);
  v25 = v11 * *eye;
  v26 = eye[2];
  v27 = -(float)(v12 * eye[1]);
  (*r)[15] = 1.0;
  (*r)[14] = (float)(v27 - v25) - (float)(v10 * v26);
}

//----- (0027911C) --------------------------------------------------------
void __fastcall NvBuildFrustumMatf(
        GLfloat_0 (*r)[4],
        GLfloat_0 left,
        GLfloat_0 right,
        GLfloat_0 bottom,
        GLfloat_0 top,
        GLfloat_0 znear,
        GLfloat_0 zfar)
{
  (*r)[6] = 0.0;
  (*r)[7] = 0.0;
  (*r)[11] = -1.0;
  (*r)[12] = 0.0;
  (*r)[13] = 0.0;
  (*r)[15] = 0.0;
  *(_QWORD *)&(*r)[1] = 0LL;
  *(_QWORD *)&(*r)[3] = 0LL;
  (*r)[0] = (float)(znear + znear) / (float)(right - left);
  (*r)[5] = (float)(znear + znear) / (float)(top - bottom);
  (*r)[8] = (float)(left + right) / (float)(right - left);
  (*r)[9] = (float)(bottom + top) / (float)(top - bottom);
  (*r)[10] = (float)-(float)(znear + zfar) / (float)(zfar - znear);
  (*r)[14] = (float)-(float)((float)(zfar + zfar) * znear) / (float)(zfar - znear);
}

//----- (002791AC) --------------------------------------------------------
void __fastcall NvBuildOrtho2Matf(GLfloat_0 (*r)[4], GLfloat_0 left, GLfloat_0 right, GLfloat_0 bottom, GLfloat_0 top)
{
  (*r)[10] = 1.0;
  (*r)[11] = 0.0;
  (*r)[14] = 0.0;
  (*r)[15] = 1.0;
  *(_QWORD *)&(*r)[1] = 0LL;
  *(_QWORD *)&(*r)[3] = 0LL;
  *(_QWORD *)&(*r)[6] = 0LL;
  *(_QWORD *)&(*r)[8] = 0LL;
  (*r)[0] = 2.0 / (float)(right - left);
  (*r)[5] = 2.0 / (float)(top - bottom);
  (*r)[12] = (float)-(float)(left + right) / (float)(right - left);
  (*r)[13] = (float)-(float)(bottom + top) / (float)(top - bottom);
}

//----- (0027921A) --------------------------------------------------------
void __fastcall NvBuildOrthoMatf(
        GLfloat_0 (*r)[4],
        GLfloat_0 left,
        GLfloat_0 right,
        GLfloat_0 bottom,
        GLfloat_0 top,
        GLfloat_0 znear,
        GLfloat_0 zfar)
{
  (*r)[11] = 0.0;
  (*r)[15] = 1.0;
  *(_QWORD *)&(*r)[1] = 0LL;
  *(_QWORD *)&(*r)[3] = 0LL;
  *(_QWORD *)&(*r)[6] = 0LL;
  *(_QWORD *)&(*r)[8] = 0LL;
  (*r)[10] = -2.0 / (float)(zfar - znear);
  (*r)[0] = 2.0 / (float)(right - left);
  (*r)[5] = 2.0 / (float)(top - bottom);
  (*r)[12] = (float)-(float)(left + right) / (float)(right - left);
  (*r)[13] = (float)-(float)(bottom + top) / (float)(top - bottom);
  (*r)[14] = (float)-(float)(znear + zfar) / (float)(zfar - znear);
}

//----- (002792AC) --------------------------------------------------------
void __fastcall NvQuatCopy(GLfloat_0 *r, const GLfloat_0 *q)
{
  __int64 v2; // d17

  v2 = *((_QWORD *)q + 1);
  *(_QWORD *)r = *(_QWORD *)q;
  *((_QWORD *)r + 1) = v2;
}

//----- (002792B6) --------------------------------------------------------
void __fastcall NvQuatConvertTo3x3Mat(GLfloat_0 (*r)[3], const GLfloat_0 *q)
{
  float v2; // s0
  float v3; // s2
  float v4; // s4
  float v5; // s8
  float v6; // s6
  float v7; // s1
  float v8; // s5
  float v9; // s3
  float v10; // s2
  float v11; // s7
  float v12; // s6
  float v13; // s8
  float v14; // s4
  float v15; // s0

  v2 = *q;
  v3 = q[1];
  v4 = q[2];
  v5 = v3 + v3;
  v6 = q[3];
  v7 = v3 * (float)(v3 + v3);
  v8 = (float)(v3 + v3) * v6;
  v9 = (float)(v4 + v4) * v6;
  v10 = (float)(v2 + v2) * v3;
  v11 = (float)(v2 + v2) * v4;
  v12 = (float)(v2 + v2) * v6;
  v13 = v5 * v4;
  v14 = v4 * (float)(v4 + v4);
  v15 = 1.0 - (float)(v2 * (float)(v2 + v2));
  (*r)[0] = (float)(1.0 - v7) - v14;
  (*r)[1] = v10 - v9;
  (*r)[2] = v11 + v8;
  (*r)[3] = v10 + v9;
  (*r)[4] = v15 - v14;
  (*r)[5] = v13 - v12;
  (*r)[6] = v11 - v8;
  (*r)[7] = v13 + v12;
  (*r)[8] = v15 - v7;
}

//----- (00279350) --------------------------------------------------------
void __fastcall NvQuatIdentity(GLfloat_0 *r)
{
  *(_QWORD *)r = 0LL;
  *((_QWORD *)r + 1) = 0x3F80000000000000LL;
}

//----- (00279370) --------------------------------------------------------
void __fastcall NvQuatFromAngleAxis(GLfloat_0 *r, GLfloat_0 radians, const GLfloat_0 *axis)
{
  float v5; // r6
  float v6; // s16
  float v7; // r0
  float v8; // s0

  v5 = radians * 0.5;
  v6 = sinf(radians * 0.5);
  *r = v6 * *axis;
  r[1] = v6 * axis[1];
  v7 = cosf(v5);
  v8 = axis[2];
  r[3] = v7;
  r[2] = v6 * v8;
}

//----- (002793D0) --------------------------------------------------------
void __fastcall NvQuatX(GLfloat_0 *r, GLfloat_0 radians)
{
  float v3; // r5

  r[1] = 0.0;
  r[2] = 0.0;
  v3 = radians * 0.5;
  *r = sinf(radians * 0.5);
  r[3] = cosf(v3);
}

//----- (002793FE) --------------------------------------------------------
void __fastcall NvQuatY(GLfloat_0 *r, GLfloat_0 radians)
{
  float v3; // r5

  *r = 0.0;
  r[2] = 0.0;
  v3 = radians * 0.5;
  r[1] = sinf(radians * 0.5);
  r[3] = cosf(v3);
}

//----- (0027942C) --------------------------------------------------------
void __fastcall NvQuatZ(GLfloat_0 *r, GLfloat_0 radians)
{
  float v3; // r5

  *r = 0.0;
  r[1] = 0.0;
  v3 = radians * 0.5;
  r[2] = sinf(radians * 0.5);
  r[3] = cosf(v3);
}

//----- (0027945C) --------------------------------------------------------
void __fastcall NvQuatFromEuler(GLfloat_0 *r, GLfloat_0 heading, GLfloat_0 pitch, GLfloat_0 roll)
{
  float v7; // r5
  float v8; // r4
  float v9; // r5
  float v10; // r6
  float v11; // s18
  float v12; // s24
  float v13; // r0
  float v14; // s0
  float v15; // s16
  float v16; // s18
  float v17; // s20
  float v18; // s22
  float v19; // s24
  float v20; // r0

  v7 = heading * 0.5;
  v8 = cosf(heading * 0.5);
  v9 = sinf(v7);
  v10 = pitch * 0.5;
  v11 = sinf(v10);
  v12 = v9 * v11;
  v13 = cosf(v10);
  v14 = (float)(v8 * v13) - (float)(v11 * 0.0);
  v15 = (float)(v9 * v13) + (float)((float)(v8 * 0.0) + (float)(v11 * 0.0));
  v16 = (float)(v13 * 0.0) + (float)((float)(v9 * 0.0) + (float)(v8 * v11));
  v17 = v14 - (float)(v9 * 0.0);
  v18 = (float)(v13 * 0.0) + (float)((float)(v8 * 0.0) + (float)(0.0 - v12));
  v19 = cosf(roll * 0.5);
  v20 = sinf(roll * 0.5);
  *r = (float)(v17 * 0.0) + (float)((float)(v19 * v16) + (float)((float)(v18 * 0.0) - (float)(v20 * v15)));
  r[1] = (float)(v17 * 0.0) + (float)((float)(v19 * v15) + (float)((float)(v20 * v16) - (float)(v18 * 0.0)));
  r[2] = (float)(v20 * v17) + (float)((float)((float)(v15 * 0.0) - (float)(v16 * 0.0)) + (float)(v19 * v18));
  r[3] = (float)((float)((float)(v19 * v17) - (float)(v16 * 0.0)) - (float)(v15 * 0.0)) - (float)(v20 * v18);
}

//----- (0027959C) --------------------------------------------------------
void __fastcall NvQuatMult(GLfloat_0 *r, const GLfloat_0 *q1, const GLfloat_0 *q2)
{
  float v3; // s2
  float v4; // s12
  float v5; // s4
  float v6; // s11
  float v7; // s10
  float v8; // s14
  float v9; // s6
  float v10; // s5
  float v11; // s16
  float v12; // s0
  float v13; // s2
  float v14; // s3
  float v15; // s7
  float v16; // s14
  GLfloat_0 v17; // s10

  v3 = q2[1];
  v4 = q1[2];
  v5 = q2[2];
  v6 = *q1 * v3;
  v7 = q1[1];
  v8 = q1[3];
  v9 = q2[3];
  v10 = v4 * v3;
  v11 = v8 * v3;
  v12 = v8 * *q2;
  v13 = v7 * v3;
  v14 = (float)(v7 * v5) - v10;
  v15 = (float)(v8 * v9) - (float)(*q1 * *q2);
  v16 = (float)(v6 - (float)(v7 * *q2)) + (float)(v8 * v5);
  v17 = (float)(v7 * v9) + (float)(v11 + (float)((float)(v4 * *q2) - (float)(*q1 * v5)));
  *r = (float)(*q1 * v9) + (float)(v12 + v14);
  r[1] = v17;
  r[2] = v16 + (float)(v4 * v9);
  r[3] = (float)(v15 - v13) - (float)(v4 * v5);
}

//----- (0027964C) --------------------------------------------------------
void __fastcall NvQuatFromEulerReverse(GLfloat_0 *r, GLfloat_0 heading, GLfloat_0 pitch, GLfloat_0 roll)
{
  float v6; // r6
  float v7; // s18
  float v8; // r4
  float v9; // r6
  float v10; // r5
  float v11; // s20
  float v12; // s22
  float v13; // s26
  float v14; // r0
  float v15; // r4
  float v16; // s2
  float v17; // s18
  float v18; // s20
  float v19; // s24
  float v20; // s26
  float v21; // s28
  float v22; // s18
  float v23; // r0

  v6 = pitch * 0.5;
  v7 = roll * 0.5;
  v8 = cosf(pitch * 0.5);
  v9 = sinf(v6);
  v10 = heading * 0.5;
  v11 = sinf(v10);
  v12 = v11 * 0.0;
  v13 = v8;
  v14 = cosf(v10);
  v15 = v7;
  v16 = (float)(0.0 - (float)(v9 * 0.0)) + (float)(v13 * v11);
  v17 = (float)(v13 * v14) - (float)(v9 * 0.0);
  v18 = (float)(v14 * 0.0) + (float)((float)(v13 * 0.0) + (float)(v9 * v11));
  v19 = (float)(v9 * v14) + (float)((float)(v13 * 0.0) + (float)(0.0 - v12));
  v20 = (float)(v14 * 0.0) + v16;
  v21 = sinf(v15);
  v22 = v17 - v12;
  v23 = cosf(v15);
  *r = (float)(v23 * v19) + (float)((float)(v22 * 0.0) + (float)((float)(v21 * v20) - (float)(v18 * 0.0)));
  r[1] = (float)(v23 * v20) + (float)((float)(v22 * 0.0) + (float)((float)(v18 * 0.0) - (float)(v21 * v19)));
  r[2] = (float)(v23 * v18) + (float)((float)(v21 * v22) + (float)((float)(v19 * 0.0) - (float)(v20 * 0.0)));
  r[3] = (float)((float)((float)(v23 * v22) - (float)(v19 * 0.0)) - (float)(v20 * 0.0)) - (float)(v21 * v18);
}

//----- (00279790) --------------------------------------------------------
GLfloat_0 __fastcall NvQuatDot(const GLfloat_0 *q1, const GLfloat_0 *q2)
{
  return (float)((float)((float)(*q1 * *q2) + (float)(q1[1] * q2[1])) + (float)(q1[2] * q2[2])) + (float)(q1[3] * q2[3]);
}

//----- (002797D2) --------------------------------------------------------
void __fastcall NvQuatNLerp(GLfloat_0 *r, const GLfloat_0 *q1, const GLfloat_0 *q2, GLfloat_0 t)
{
  float v4; // s2
  float v5; // s8
  float v6; // s4
  float v7; // s2
  float v8; // s4
  float v9; // s10
  float v10; // s6
  float v11; // s0

  v4 = *q2 * t;
  v5 = 1.0 - t;
  v6 = (float)(1.0 - t) * *q1;
  if ( (float)((float)((float)((float)(*q1 * *q2) + (float)(q1[1] * q2[1])) + (float)(q1[2] * q2[2]))
             + (float)(q1[3] * q2[3])) >= 0.0 )
  {
    v7 = v6 + v4;
    *r = v7;
    v8 = (float)(v5 * q1[1]) + (float)(q2[1] * t);
    r[1] = v8;
    v9 = (float)(v5 * q1[2]) + (float)(q2[2] * t);
    r[2] = v9;
    v10 = (float)(v5 * q1[3]) + (float)(q2[3] * t);
  }
  else
  {
    v7 = v4 - v6;
    *r = v7;
    v8 = (float)(q2[1] * t) - (float)(v5 * q1[1]);
    r[1] = v8;
    v9 = (float)(q2[2] * t) - (float)(v5 * q1[2]);
    r[2] = v9;
    v10 = (float)(q2[3] * t) - (float)(v5 * q1[3]);
  }
  v11 = 1.0 / sqrtf((float)(v10 * v10) + (float)((float)((float)(v7 * v7) + (float)(v8 * v8)) + (float)(v9 * v9)));
  *r = v7 * v11;
  r[1] = v8 * v11;
  r[2] = v9 * v11;
  r[3] = v11 * v10;
}

//----- (0027990C) --------------------------------------------------------
void __fastcall NvQuatNormalize(GLfloat_0 *r, const GLfloat_0 *q)
{
  float v2; // s2

  v2 = 1.0
     / sqrtf((float)((float)((float)(*q * *q) + (float)(q[1] * q[1])) + (float)(q[2] * q[2])) + (float)(q[3] * q[3]));
  *r = *q * v2;
  r[1] = q[1] * v2;
  r[2] = v2 * q[2];
  r[3] = v2 * q[3];
}

//----- (00279974) --------------------------------------------------------
unsigned __int8 *__fastcall load_file(const unsigned __int8 *file)
{
  _DWORD *v1; // r8
  FILE *v2; // r4
  int v3; // r6
  signed int Length; // r5
  void *v5; // r6
  AAsset *v6; // r4
  off_t v7; // r9
  off_t v8; // r10
  signed int v9; // r2

  v1 = NvFOpen((const unsigned __int8 *)&byte_61CADE, file, 0, 1);
  if ( *v1 != 1 )
  {
    v6 = (AAsset *)v1[1];
    Length = AAsset_getLength(v6);
    v5 = (void *)operator new[](Length + 1);
    v7 = AAsset_getLength(v6);
    v8 = AAsset_getLength(v6);
    v9 = AAsset_getRemainingLength(v6) - v8 + v7;
    if ( Length <= v9 )
      v9 = Length;
    AAsset_read(v6, v5, v9);
    goto LABEL_7;
  }
  v2 = (FILE *)v1[1];
  v3 = ftell(v2);
  fseek(v2, 0, 2);
  Length = ftell(v2);
  fseek(v2, v3, 0);
  v5 = (void *)operator new[](Length + 1);
  fread(v5, 1u, Length, v2);
  v6 = (AAsset *)v1[1];
  if ( *v1 != 1 )
  {
LABEL_7:
    AAsset_close(v6);
    goto LABEL_8;
  }
  fclose((FILE *)v6);
LABEL_8:
  free(v1);
  *((_BYTE *)v5 + Length) = 0;
  return (unsigned __int8 *)v5;
}
// 61CADE: using guessed type char byte_61CADE;

//----- (00279A3C) --------------------------------------------------------
GLint __fastcall nv_load_program(const unsigned __int8 *prog, const unsigned __int8 *prepend)
{
  const char *String; // r0
  int Shader; // r10
  int v6; // r6
  int Program; // r8
  int v8; // r5
  unsigned __int8 *file; // r0
  int v10; // r4
  int v11; // r9
  void *v12; // r0
  size_t v13; // r8
  char *v14; // r11
  unsigned __int8 *v15; // r0
  void *v16; // r0
  size_t v17; // r5
  GLint v18; // r9
  char *v19; // r4
  size_t v20; // r5
  char *v21; // r4
  const unsigned __int8 *v23; // [sp+0h] [bp-140h]
  int v24; // [sp+4h] [bp-13Ch]
  int v25; // [sp+8h] [bp-138h]
  int v26[2]; // [sp+Ch] [bp-134h] BYREF
  int v27[2]; // [sp+14h] [bp-12Ch] BYREF
  size_t byte_count; // [sp+1Ch] [bp-124h] BYREF
  unsigned __int8 s[256]; // [sp+20h] [bp-120h] BYREF

  _android_log_print(3, "nv_shader", "in nv_load_program");
  String = (const char *)glGetString(0x1F02u);
  _android_log_print(3, "nv_shader", "gl version: %s", String);
  Shader = glCreateShader(35633);
  v6 = glCreateShader(35632);
  Program = glCreateProgram();
  glAttachShader(Program, Shader);
  glAttachShader(Program, v6);
  if ( prepend )
  {
    _android_log_print(3, "nv_shader", "compiling string:\n\"%s\"\n", (const char *)prepend);
    v27[0] = (int)prepend;
    v8 = 1;
    v26[0] = strlen((const char *)prepend);
    if ( prog )
    {
LABEL_3:
      v24 = v6;
      v23 = prog;
      sprintf(s, "%s.vert", (const char *)prog);
      _android_log_print(3, "nv_shader", "compiling file: %s\n", (const char *)s);
      file = load_file(s);
      v27[v8] = (int)file;
      v10 = v8 + 1;
      v26[v8] = strlen((const char *)file);
      goto LABEL_7;
    }
  }
  else
  {
    v8 = 0;
    if ( prog )
      goto LABEL_3;
  }
  if ( !v8 )
    return 0;
  v10 = 1;
  v23 = prog;
  v24 = v6;
LABEL_7:
  v25 = Program;
  glShaderSource(Shader, v10, v27, v26);
  glCompileShader(Shader);
  v11 = v10 - 1;
  v12 = (void *)v27[v10 - 1];
  if ( v12 )
    operator delete[](v12);
  byte_count = 0;
  glGetShaderiv(Shader, 35716, &byte_count);
  v13 = byte_count;
  if ( (int)byte_count >= 1 )
  {
    v14 = (char *)malloc(byte_count);
    if ( v14 )
    {
      glGetShaderInfoLog(Shader, v13, 0, v14);
      _android_log_print(3, "nv_shader", "shader_debug: %s\n", v14);
      free(v14);
    }
  }
  sprintf(s, "%s.frag", (const char *)v23);
  _android_log_print(3, "nv_shader", "compiling file: %s\n", (const char *)s);
  v15 = load_file(s);
  v27[v11] = (int)v15;
  v26[v11] = strlen((const char *)v15);
  glShaderSource(v24, v10, v27, v26);
  glCompileShader(v24);
  v16 = (void *)v27[v11];
  if ( v16 )
    operator delete[](v16);
  byte_count = 0;
  glGetShaderiv(v24, 35716, &byte_count);
  v17 = byte_count;
  v18 = v25;
  if ( (int)byte_count >= 1 )
  {
    v19 = (char *)malloc(byte_count);
    if ( v19 )
    {
      glGetShaderInfoLog(v24, v17, 0, v19);
      _android_log_print(3, "nv_shader", "shader_debug: %s\n", v19);
      free(v19);
    }
  }
  glLinkProgram(v25);
  byte_count = 0;
  glGetProgramiv(v25, 35716, &byte_count);
  v20 = byte_count;
  if ( (int)byte_count >= 1 )
  {
    v21 = (char *)malloc(byte_count);
    if ( v21 )
    {
      glGetProgramInfoLog(v25, v20, 0, v21);
      _android_log_print(3, "nv_shader", "shader_debug: %s\n", v21);
      free(v21);
    }
  }
  return v18;
}
// 18D3B8: using guessed type int __fastcall glGetShaderInfoLog(_DWORD, _DWORD, _DWORD, _DWORD);
// 19040C: using guessed type int __fastcall glGetProgramInfoLog(_DWORD, _DWORD, _DWORD, _DWORD);
// 190D44: using guessed type int __fastcall glGetProgramiv(_DWORD, _DWORD, _DWORD);
// 193748: using guessed type int __fastcall glCompileShader(_DWORD);
// 194970: using guessed type int __fastcall glCreateShader(_DWORD);
// 19DFD4: using guessed type int __fastcall glAttachShader(_DWORD, _DWORD);
// 19E1C8: using guessed type int glCreateProgram(void);
// 1A0890: using guessed type int __fastcall glGetShaderiv(_DWORD, _DWORD, _DWORD);
// 1A0A08: using guessed type int __fastcall glLinkProgram(_DWORD);
// 1A0C18: using guessed type int __fastcall glShaderSource(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00279CF4) --------------------------------------------------------
void __fastcall nv_set_attrib_by_name(
        GLuint prog,
        const unsigned __int8 *name,
        int size,
        GLenum type,
        int normalized,
        GLsizei stride,
        void *ptr)
{
  int AttribLocation; // r6

  AttribLocation = glGetAttribLocation(prog, name);
  glVertexAttribPointer(AttribLocation, size, type, normalized, stride, ptr);
  sub_18BE4C(AttribLocation);
}
// 18BE4C: using guessed type int __fastcall sub_18BE4C(_DWORD);
// 19783C: using guessed type int __fastcall glGetAttribLocation(_DWORD, _DWORD);
// 19E824: using guessed type int __fastcall glVertexAttribPointer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00279D2C) --------------------------------------------------------
void __fastcall nv_set_attrib_by_index(
        GLint index,
        int size,
        GLenum type,
        GLboolean normalized,
        GLsizei stride,
        void *ptr)
{
  int v7; // r1
  GLenum v8; // r2
  GLboolean v9; // r3

  glVertexAttribPointer(index, size, type, normalized, stride, ptr);
  sub_18BE4C(index, v7, v8, v9, stride, ptr);
}
// 279D4A: variable 'v7' is possibly undefined
// 279D4A: variable 'v8' is possibly undefined
// 279D4A: variable 'v9' is possibly undefined
// 18BE4C: using guessed type void __fastcall sub_18BE4C(GLint index, int size, GLenum type, GLboolean normalized, GLsizei stride, void *ptr);
// 19E824: using guessed type int __fastcall glVertexAttribPointer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00279D50) --------------------------------------------------------
bool __fastcall charIsSeparator(unsigned __int8 c)
{
  return separators[4] == c
      || separators[0] == c
      || separators[1] == c
      || separators[2] == c
      || separators[3] == c
      || separators[5] == c;
}

//----- (00279DC0) --------------------------------------------------------
const unsigned __int8 *__fastcall findDataNextToken(const unsigned __int8 *data)
{
  int v1; // r4
  int v2; // t1
  bool v3; // zf
  bool v4; // zf
  size_t v5; // r4
  int v6; // r6
  bool v7; // zf
  bool v8; // zf

  while ( 1 )
  {
    do
    {
      do
      {
        v2 = *data++;
        v1 = v2;
      }
      while ( separators[0] == v2 );
    }
    while ( separators[1] == v1 );
    v3 = separators[2] == v1;
    if ( separators[2] != v1 )
      v3 = separators[3] == v1;
    if ( !v3 )
    {
      v4 = separators[4] == v1;
      if ( separators[4] != v1 )
        v4 = separators[5] == v1;
      if ( !v4 )
        break;
    }
  }
  if ( separators[0] == v1 || separators[1] == v1 || separators[2] == v1 || separators[3] == v1 || separators[4] == v1 )
  {
    v5 = 0;
  }
  else
  {
    v3 = separators[5] == v1;
    v5 = 0;
    if ( !v3 )
    {
      v5 = 0;
      do
      {
        v6 = data[v5++];
        if ( separators[0] == v6 )
          break;
        v7 = separators[1] == v6;
        if ( separators[1] != v6 )
          v7 = separators[2] == v6;
        if ( v7 )
          break;
        v8 = separators[3] == v6;
        if ( separators[3] != v6 )
          v8 = separators[4] == v6;
      }
      while ( !v8 && separators[5] != v6 );
    }
  }
  strncpy((char *)foundToken, (const char *)data - 1, v5);
  foundToken[v5] = 0;
  return foundToken;
}

//----- (00279E60) --------------------------------------------------------
const unsigned __int8 *__fastcall findDataMatch(const unsigned __int8 *data, const unsigned __int8 *str)
{
  unsigned __int8 v2; // r3
  const unsigned __int8 *v3; // r1
  int v4; // r12
  int v5; // t1
  int v6; // r3
  int v7; // lr
  const unsigned __int8 *v8; // r2
  int v9; // t1

  v2 = *data;
  if ( !*data )
    return 0;
  v5 = *str;
  v3 = str + 1;
  v4 = v5;
  while ( v2 != v4 )
  {
LABEL_9:
    v9 = *++data;
    v2 = v9;
    if ( !v9 )
      return 0;
  }
  if ( v4 )
  {
    v6 = 0;
    while ( 1 )
    {
      v7 = v3[v6];
      if ( !v3[v6] )
        break;
      v8 = &data[v6++];
      if ( v8[1] != v7 )
      {
        data += v6;
        goto LABEL_9;
      }
    }
  }
  return data;
}
// 279E92: conditional instruction was optimized away because r12.4!=0

//----- (00279EA4) --------------------------------------------------------
const unsigned __int8 *__fastcall findDataString(const unsigned __int8 *data, const unsigned __int8 *str, int maxlen)
{
  int v6; // r4
  int v7; // r10
  int v8; // r11
  int v9; // r5
  int v10; // r8
  int v11; // r9
  const unsigned __int8 *v12; // r1
  const unsigned __int8 *result; // r0
  int v14; // r1
  bool v15; // zf
  bool v16; // zf
  bool v17; // zf
  int v18; // r1
  bool v19; // zf
  bool v20; // zf
  bool v21; // zf
  int v22; // [sp+0h] [bp-28h]
  char *v23; // [sp+4h] [bp-24h]
  int v24; // [sp+8h] [bp-20h]

  v6 = strlen((const char *)str);
  if ( v6 <= maxlen )
  {
    v22 = maxlen;
    v23 = (char *)str;
    v7 = separators[0];
    v8 = separators[1];
    v9 = separators[2];
    v10 = separators[3];
    v11 = separators[4];
    v24 = separators[5];
    v12 = data;
    while ( 1 )
    {
      result = (const unsigned __int8 *)strstr((const char *)v12, v23);
      if ( !result )
        break;
      v15 = result == data;
      if ( result != data )
      {
        v14 = *(result - 1);
        v15 = v7 == v14;
      }
      if ( !v15 )
      {
        v16 = v8 == v14;
        if ( v8 != v14 )
          v16 = v9 == v14;
        if ( !v16 )
        {
          v17 = v10 == v14;
          if ( v10 != v14 )
            v17 = v11 == v14;
          if ( !v17 && v24 != v14 )
            goto LABEL_28;
        }
      }
      v18 = result[v6];
      v19 = v7 == v18;
      if ( v7 != v18 )
        v19 = v8 == v18;
      if ( !v19 )
      {
        v20 = v9 == v18;
        if ( v9 != v18 )
          v20 = v10 == v18;
        if ( !v20 )
        {
          v21 = v11 == v18;
          if ( v11 != v18 )
            v21 = v24 == v18;
          if ( !v21 )
          {
LABEL_28:
            v12 = &result[v6];
            if ( &result[v6] - data + v6 <= v22 )
              continue;
          }
        }
      }
      return result;
    }
  }
  return 0;
}
// 279EF8: variable 'v14' is possibly undefined

//----- (00279F48) --------------------------------------------------------
const unsigned __int8 *__fastcall findDataStringEOL(const unsigned __int8 *data, const unsigned __int8 *str)
{
  size_t i; // r5
  unsigned int v4; // r3

  for ( i = 0; ; ++i )
  {
    v4 = data[i];
    if ( v4 <= 0xD && ((1 << v4) & 0x2401) != 0 )
      break;
  }
  strncpy((char *)findStringTempData, (const char *)data, i);
  findStringTempData[i] = 0;
  return findDataString(findStringTempData, str, i);
}

//----- (00279F94) --------------------------------------------------------
int __fastcall readDataFile(const unsigned __int8 *fname, unsigned __int8 *outbuf, size_t buflen)
{
  bool v5; // zf
  FILE *v6; // r6
  int v7; // r8

  if ( !fname )
    return -1;
  v5 = outbuf == 0;
  if ( outbuf )
    v5 = buflen == 0;
  if ( v5 )
    return -1;
  v6 = fopen((const char *)fname, (const char *)&dword_279FE4);
  if ( !v6 )
    return -1;
  v7 = fread(outbuf, 1u, buflen, v6);
  fclose(v6);
  outbuf[buflen - 1] = 0;
  return v7;
}
// 279FE4: using guessed type int dword_279FE4;

//----- (00279FE8) --------------------------------------------------------
void __fastcall logExtensionsStrings(const unsigned __int8 *exts)
{
  const unsigned __int8 *v1; // r6
  const char *v2; // r1
  signed int v3; // r5
  int v4; // r2
  bool v5; // zf
  bool v6; // zf
  char v7[4096]; // [sp+4h] [bp-1024h] BYREF

  v1 = exts;
  if ( exts )
  {
LABEL_5:
    v2 = (const char *)v1;
    v3 = 0;
    while ( 1 )
    {
      v4 = v1[v3];
      if ( !v1[v3] )
        break;
      ++v3;
      if ( separators[0] != v4 )
      {
        v5 = separators[1] == v4;
        if ( separators[1] != v4 )
          v5 = separators[2] == v4;
        if ( !v5 )
        {
          v6 = separators[3] == v4;
          if ( separators[3] != v4 )
            v6 = separators[4] == v4;
          if ( !v6 && separators[5] != v4 )
            continue;
        }
      }
      v1 += v3;
      if ( v3 - 1 >= 0 )
      {
        strncpy(v7, v2, v3);
        v7[v3] = 0;
        _android_log_print(2, "nv_syscaps", "..> %s", v7);
      }
      goto LABEL_5;
    }
    if ( v3 >= 1 )
    {
      strncpy(v7, (const char *)v1, v3);
      v7[v3] = 0;
      _android_log_print(2, "nv_syscaps", "..> %s", v7);
    }
  }
}
// 0: using guessed type int dword_0;
// 279FE8: using guessed type char var_1024[4096];

//----- (0027A0D8) --------------------------------------------------------
void *__fastcall NVThreadSpawnProc(void *arg)
{
  int (__fastcall *v2)(_DWORD); // r4
  int v3; // r8
  _JNIEnv *v4; // r6
  _jclass *v5; // r4
  _jmethodID *v6; // r10
  _jmethodID *v7; // r11
  _jobject *v8; // r10
  int v9; // r4
  void *v10; // r1
  void *v11; // r4
  int (__fastcall *v13)(_DWORD); // [sp+0h] [bp-20h]

  v2 = (int (__fastcall *)(_DWORD))*((_DWORD *)arg + 1);
  v3 = *(_DWORD *)arg;
  NVThreadGetCurrentJNIEnv();
  if ( *((_BYTE *)arg + 8) )
  {
    v4 = (_JNIEnv *)pthread_getspecific(s_jniEnvKey);
    v13 = v2;
    v5 = (_jclass *)v4->functions->FindClass(&v4->functions, "java/lang/Thread");
    v6 = v4->functions->GetStaticMethodID(&v4->functions, v5, "currentThread", "()Ljava/lang/Thread;");
    v7 = v4->functions->GetMethodID(&v4->functions, v5, "setName", "(Ljava/lang/String;)V");
    v8 = (_jobject *)_JNIEnv::CallStaticObjectMethod(v4, v5, v6);
    v9 = (int)v4->functions->NewStringUTF(&v4->functions, (const unsigned __int8 *)arg + 8);
    _JNIEnv::CallVoidMethod(v4, v8, v7, v9);
    v10 = (void *)v9;
    v2 = v13;
    v4->functions->DeleteLocalRef(&v4->functions, v10);
  }
  free(arg);
  v11 = (void *)v2(v3);
  if ( s_vm )
    s_vm->functions->DetachCurrentThread((JavaVM *)s_vm);
  return v11;
}

//----- (0027A1DC) --------------------------------------------------------
int __fastcall NVThreadSleep(unsigned int millisec)
{
  struct timespec v2; // [sp+0h] [bp-18h] BYREF
  struct timespec requested_time; // [sp+8h] [bp-10h] BYREF

  v2.tv_sec = millisec / 0x3E8;
  v2.tv_nsec = millisec % 0x3E8 * (_DWORD)"ist_FillGlobeColPointsER8CPtrListRK8CColLineRP7CEntitybP15CStoredCollPoly";
  requested_time.tv_sec = millisec / 0x3E8;
  requested_time.tv_nsec = v2.tv_nsec;
  if ( nanosleep(&requested_time, &v2) )
  {
    requested_time = v2;
    nanosleep(&requested_time, &v2);
  }
  return 1;
}

//----- (0027A230) --------------------------------------------------------
void __fastcall NvUtilGetLocalAppValue(unsigned __int8 *buffer, int bufferLength, const unsigned __int8 *name)
{
  NvUtilGetStringValue(g_getAppLocalValue, buffer, bufferLength, name);
}

//----- (0027A244) --------------------------------------------------------
void __fastcall NvUtilGetStringValue(
        jmethodID method,
        unsigned __int8 *buffer,
        int bufferLength,
        const unsigned __int8 *name)
{
  _JNIEnv *CurrentJNIEnv; // r5
  int v9; // r0
  int v10; // r0
  void *v11; // r10
  const char *v12; // r4
  int v13; // r6

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v9 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, name);
  v10 = _JNIEnv::CallObjectMethod(CurrentJNIEnv, g_globalThiz, method, v9);
  v11 = (void *)v10;
  if ( v10 )
  {
    v12 = (const char *)CurrentJNIEnv->functions->GetStringUTFChars(&CurrentJNIEnv->functions, (jstring)v10, 0);
    v13 = strlen(v12);
    if ( v13 >= bufferLength )
      v13 = bufferLength - 1;
    strncpy((char *)buffer, v12, v13);
    CurrentJNIEnv->functions->ReleaseStringUTFChars(&CurrentJNIEnv->functions, v11, (const unsigned __int8 *)v12);
  }
  else
  {
    v13 = 0;
  }
  buffer[v13] = 0;
}

//----- (0027A2D0) --------------------------------------------------------
bool __fastcall NvUtilHasLocalAppValue(const unsigned __int8 *name)
{
  _JNIEnv *CurrentJNIEnv; // r5
  int v3; // r0
  int v4; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v3 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, name);
  v4 = _JNIEnv::CallBooleanMethod(CurrentJNIEnv, g_globalThiz, g_hasAppLocalValue, v3);
  if ( v4 != 1 )
    LOBYTE(v4) = 0;
  return v4;
}

//----- (0027A30C) --------------------------------------------------------
void __fastcall NvUtilSetLocalAppValue(const unsigned __int8 *name, const unsigned __int8 *value)
{
  _JNIEnv *CurrentJNIEnv; // r6
  int v5; // r5
  int v6; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v5 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, name);
  v6 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, value);
  _JNIEnv::CallVoidMethod(CurrentJNIEnv, g_globalThiz, g_setAppLocalValue, v5, v6);
}

//----- (0027A360) --------------------------------------------------------
void __fastcall NvUtilGetParameter(unsigned __int8 *buffer, int bufferLength, const unsigned __int8 *parameter)
{
  NvUtilGetStringValue(g_getParameter, buffer, bufferLength, parameter);
}

//----- (0027A374) --------------------------------------------------------
void __fastcall WarGamepadInit(JNIEnv_0 *env)
{
  jclass v2; // r6
  double v3; // [sp+0h] [bp-28h] BYREF
  jboolean (__fastcall *v4)(JNIEnv_0 *, jobject_0, jobject_0, jboolean); // [sp+8h] [bp-20h]

  _android_log_print(3, "WarGamepad", "JNI Init");
  v2 = env->functions->FindClass(env, &unk_60AD58);
  v4 = WarGamepad_ProcessTouchpadAsPointer;
  v3 = *(double *)off_661ED0;
  env->functions->RegisterNatives((JNIEnv *)env, v2, (const JNINativeMethod *)&v3, 1);
  s_getGamepadType = env->functions->GetMethodID(env, v2, "GetGamepadType", "(I)I");
  s_getGamepadButtons = env->functions->GetMethodID(env, v2, "GetGamepadButtons", "(I)I");
  s_getGamepadAxis = env->functions->GetMethodID(env, v2, "GetGamepadAxis", "(II)F");
  s_getGamepadTrack = env->functions->GetMethodID(env, v2, "GetGamepadTrack", "(III)I");
  _android_log_print(3, "WarGamepad", "JNI Done Init");
}
// 661ED0: using guessed type char *off_661ED0[2];

//----- (0027A488) --------------------------------------------------------
jboolean __fastcall WarGamepad_ProcessTouchpadAsPointer(
        JNIEnv_0 *env,
        jobject_0 clazz,
        jobject_0 viewRoot,
        jboolean processTouchpad)
{
  int v6; // r8
  jclass v7; // r1
  _jmethodID *v8; // r2

  v6 = processTouchpad;
  v7 = env->functions->FindClass(env, "android/view/ViewRoot");
  if ( !v7 )
    return 0;
  v8 = env->functions->GetMethodID(env, v7, "setProcessPositionEvents", "(Z)V");
  if ( !v8 )
  {
    if ( !((int (__fastcall *)(JNIEnv_0 *))env->functions->ExceptionCheck)(env) )
      return 0;
    _android_log_print(3, "WarGamepad", "%s - GetMethodID( 'setProcessPositionEvents' ) threw exception!", sub_27A57C);
LABEL_7:
    env->functions->ExceptionClear((JNIEnv *)env);
    return 0;
  }
  _JNIEnv::CallVoidMethod(env, viewRoot, v8, v6);
  if ( ((int (__fastcall *)(JNIEnv_0 *))env->functions->ExceptionCheck)(env) )
  {
    _android_log_print(3, "WarGamepad", "%s - setProcessPositionEvents() threw exception!", sub_27A57C);
    goto LABEL_7;
  }
  return 1;
}

//----- (0027A57C) --------------------------------------------------------
void __fastcall sub_27A57C(int a1, int a2, int a3)
{
  int v3; // r7

  *(_DWORD *)(a3 + 20) = v3;
}
// 27A57C: variable 'v3' is possibly undefined

//----- (0027A5AC) --------------------------------------------------------
JNIEnv_0 *(*AND_GetJNIFunc())()
{
  return NVThreadGetCurrentJNIEnv;
}

//----- (0027A5BC) --------------------------------------------------------
jobject_0 AND_GetObj()
{
  return s_event_globalThiz;
}

//----- (0027A5C8) --------------------------------------------------------
void __fastcall AND_MovieInit(JNIEnv_0 *env)
{
  jclass v2; // r5

  v2 = env->functions->FindClass(env, "com/wardrumstudios/utils/WarMedia");
  s_PlayMovie = env->functions->GetMethodID(env, v2, "PlayMovie", "(Ljava/lang/String;F)V");
  s_PlayMovieInFile = env->functions->GetMethodID(env, v2, "PlayMovieInFile", "(Ljava/lang/String;FII)V");
  s_PlayMovieInWindow = env->functions->GetMethodID(env, v2, "PlayMovieInWindow", "(Ljava/lang/String;IIIIFIIIZ)V");
  s_StopMovie = env->functions->GetMethodID(env, v2, "StopMovie", "()V");
  s_MovieIsSkippable = env->functions->GetMethodID(env, v2, "MovieSetSkippable", "(Z)V");
  s_IsMoviePlaying = env->functions->GetMethodID(env, v2, "IsMoviePlaying", &dword_27AB88);
  s_DeleteFile = env->functions->GetMethodID(env, v2, "DeleteFile", "(Ljava/lang/String;)Z");
  s_FileRename = env->functions->GetMethodID(env, v2, "FileRename", "(Ljava/lang/String;Ljava/lang/String;I)Z");
  s_GetDeviceLocale = env->functions->GetMethodID(env, v2, "GetDeviceLocale", &dword_27AB88);
  s_GetDeviceType = env->functions->GetMethodID(env, v2, "GetDeviceType", &dword_27AB88);
  s_GetDeviceInfo = env->functions->GetMethodID(env, v2, "GetDeviceInfo", "(I)I");
  s_GetAndroidBuildinfo = env->functions->GetMethodID(env, v2, "GetAndroidBuildinfo", "(I)Ljava/lang/String;");
  s_GetDeviceID = env->functions->GetMethodID(env, v2, "OBFU_GetDeviceID", "()Ljava/lang/String;");
  s_FileGetArchiveName = env->functions->GetMethodID(env, v2, "FileGetArchiveName", "(I)Ljava/lang/String;");
  s_IsAppInstalled = env->functions->GetMethodID(env, v2, "IsAppInstalled", "(Ljava/lang/String;)Z");
  s_OpenLink = env->functions->GetMethodID(env, v2, "OpenLink", "(Ljava/lang/String;)V");
  s_LoadAllGamesFromCloud = env->functions->GetMethodID(env, v2, "LoadAllGamesFromCloud", "()V");
  s_LoadGameFromCloud = env->functions->GetMethodID(env, v2, "LoadGameFromCloud", "(I[B)Ljava/lang/String;");
  s_SaveGameToCloud = env->functions->GetMethodID(env, v2, "SaveGameToCloud", "(I[BI)V");
  s_IsCloudAvailable = env->functions->GetMethodID(env, v2, "IsCloudAvailable", &dword_27AC1C);
  s_NewCloudSaveAvailable = env->functions->GetMethodID(env, v2, "NewCloudSaveAvailable", "(I)Z");
  s_MovieKeepAspectRatio = env->functions->GetMethodID(env, v2, "MovieKeepAspectRatio", "(Z)V");
  s_MovieSetText = env->functions->GetMethodID(env, v2, "MovieSetText", "(Ljava/lang/String;ZZ)V");
  s_MovieDisplayText = env->functions->GetMethodID(env, v2, "MovieDisplayText", "(Z)V");
  s_MovieClearText = env->functions->GetMethodID(env, v2, "MovieClearText", "(Z)V");
  s_MovieTextScale = env->functions->GetMethodID(env, v2, "MovieSetTextScale", "(I)V");
  s_GetSpecialBuildType = env->functions->GetMethodID(env, v2, "GetSpecialBuildType", &dword_27AB88);
  s_SendStatEvent = env->functions->GetMethodID(env, v2, "SendStatEvent", "(Ljava/lang/String;Z)V");
  s_SendStatEventParam = env->functions->GetMethodID(
                           env,
                           v2,
                           "SendStatEvent",
                           "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Z)V");
  s_SendTimedStatEventEnd = env->functions->GetMethodID(env, v2, "SendTimedStatEventEnd", "(Ljava/lang/String;)V");
  s_getTotalMemory = env->functions->GetMethodID(env, v2, "GetTotalMemory", &dword_27AB88);
  s_getLowThreshhold = env->functions->GetMethodID(env, v2, "GetLowThreshhold", &dword_27AB88);
  s_getAvailableMemory = env->functions->GetMethodID(env, v2, "GetAvailableMemory", &dword_27AB88);
  s_getScreenWidthInches = env->functions->GetMethodID(env, v2, "GetScreenWidthInches", &off_27ACA0);
  s_GetAppId = env->functions->GetMethodID(env, v2, "GetAppId", "()Ljava/lang/String;");
  s_ScreenSetWakeLock = env->functions->GetMethodID(env, v2, "ScreenSetWakeLock", "(Z)V");
  s_ServiceAppCommand = env->functions->GetMethodID(
                          env,
                          v2,
                          "ServiceAppCommand",
                          "(Ljava/lang/String;Ljava/lang/String;)Z");
  s_ServiceAppCommandValue = env->functions->GetMethodID(
                               env,
                               v2,
                               "ServiceAppCommandValue",
                               "(Ljava/lang/String;Ljava/lang/String;)I");
  s_ServiceAppCommandInt = env->functions->GetMethodID(env, v2, "ServiceAppCommandInt", "(Ljava/lang/String;I)Z");
  s_IsNetworkAvailable = env->functions->GetMethodID(env, v2, "isNetworkAvailable", &dword_27AC1C);
  s_IsWifiAvailable = env->functions->GetMethodID(env, v2, "isWiFiAvailable", &dword_27AC1C);
  s_IsTV = env->functions->GetMethodID(env, v2, "isTV", &dword_27AC1C);
  s_CreateTextBox = env->functions->GetMethodID(env, v2, "CreateTextBox", "(IIIII)V");
  s_ConvertToBitmap = env->functions->GetMethodID(env, v2, "ConvertToBitmap", "([BI)Z");
  s_VibratePhone = env->functions->GetMethodID(env, v2, "VibratePhone", "(I)V");
  s_VibratePhoneEffect = env->functions->GetMethodID(env, v2, "VibratePhoneEffect", "(I)V");
}
// 27AB88: using guessed type int dword_27AB88;
// 27AC1C: using guessed type int dword_27AC1C;
// 27ACA0: using guessed type char **off_27ACA0;

//----- (0027ADA8) --------------------------------------------------------
jint AND_GetSpecialBuildType()
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  return sub_18B7B4(CurrentJNIEnv, s_event_globalThiz, s_GetSpecialBuildType);
}

//----- (0027ADD0) --------------------------------------------------------
void __fastcall OS_SendStatEvent(const unsigned __int8 *eventId, bool timedEvent)
{
  _BOOL4 v2; // r4
  _JNIEnv *CurrentJNIEnv; // r6
  int v5; // r5

  v2 = timedEvent;
  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v5 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, eventId);
  _JNIEnv::CallVoidMethod(CurrentJNIEnv, s_event_globalThiz, s_SendStatEvent, v5, v2);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v5);
}

//----- (0027AE28) --------------------------------------------------------
void __fastcall OS_SendTimedStatEventEnd(const unsigned __int8 *eventId)
{
  _JNIEnv *CurrentJNIEnv; // r5
  int v3; // r4

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v3 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, eventId);
  _JNIEnv::CallVoidMethod(CurrentJNIEnv, s_event_globalThiz, s_SendTimedStatEventEnd, v3);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v3);
}

//----- (0027AE70) --------------------------------------------------------
void __fastcall OS_SendStatEventValue(
        const unsigned __int8 *eventId,
        const unsigned __int8 *pName,
        const unsigned __int8 *pValue,
        bool timedEvent)
{
  _BOOL4 v4; // r8
  _JNIEnv *CurrentJNIEnv; // r4
  int v9; // r10
  int v10; // r6
  int v11; // r5

  v4 = timedEvent;
  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v9 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, eventId);
  v10 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, pName);
  v11 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, pValue);
  _JNIEnv::CallVoidMethod(CurrentJNIEnv, s_event_globalThiz, s_SendStatEventParam, v9, v10, v11, v4);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v11);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v10);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v9);
}

//----- (0027AF04) --------------------------------------------------------
bool __fastcall OS_ServiceAppCommand(const unsigned __int8 *cmd, const unsigned __int8 *args)
{
  _JNIEnv *CurrentJNIEnv; // r4
  int v5; // r8
  int v6; // r5
  int v7; // r6

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v5 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, cmd);
  v6 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, args);
  v7 = _JNIEnv::CallBooleanMethod(CurrentJNIEnv, s_event_globalThiz, s_ServiceAppCommand, v5, v6);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v5);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v6);
  return v7 != 0;
}

//----- (0027AF7C) --------------------------------------------------------
int __fastcall OS_ServiceAppCommandValue(const unsigned __int8 *cmd, const unsigned __int8 *args)
{
  _JNIEnv *CurrentJNIEnv; // r4
  int v5; // r6
  int v6; // r5
  int v7; // r8

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v5 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, cmd);
  v6 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, args);
  v7 = _JNIEnv::CallIntMethod(CurrentJNIEnv, s_event_globalThiz, s_ServiceAppCommandValue, v5, v6);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v5);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v6);
  return v7;
}

//----- (0027AFEC) --------------------------------------------------------
bool __fastcall OS_ServiceAppCommandInt(const unsigned __int8 *cmd, int args)
{
  _JNIEnv *CurrentJNIEnv; // r6
  int v5; // r5
  int v6; // r4

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v5 = (int)CurrentJNIEnv->functions->NewStringUTF(&CurrentJNIEnv->functions, cmd);
  v6 = _JNIEnv::CallBooleanMethod(CurrentJNIEnv, s_event_globalThiz, s_ServiceAppCommandInt, v5, args);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v5);
  return v6 != 0;
}

//----- (0027B04C) --------------------------------------------------------
void __fastcall OS_SystemMemoryStats(int *AvailableMemory, int *TotalMemory, int *LowThreashhold)
{
  _JNIEnv *CurrentJNIEnv; // r5
  int v7; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v7 = _JNIEnv::CallIntMethod(CurrentJNIEnv, s_event_globalThiz, s_getAvailableMemory);
  if ( AvailableMemory )
    *AvailableMemory = v7;
  if ( TotalMemory )
    *TotalMemory = _JNIEnv::CallIntMethod(CurrentJNIEnv, s_event_globalThiz, s_getTotalMemory);
  if ( LowThreashhold )
    *LowThreashhold = _JNIEnv::CallIntMethod(CurrentJNIEnv, s_event_globalThiz, s_getLowThreshhold);
}

//----- (0027B0D8) --------------------------------------------------------
jfloat OS_ScreenGetInches()
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  return sub_194030(CurrentJNIEnv, s_event_globalThiz, s_getScreenWidthInches);
}

//----- (0027B104) --------------------------------------------------------
unsigned __int8 *__fastcall LoadGameFromCloud(unsigned int nIndex, int *pSizeInBytes)
{
  return 0;
}

//----- (0027B10A) --------------------------------------------------------
int IsCloudAvailable()
{
  return 0;
}

//----- (0027B10E) --------------------------------------------------------
bool __fastcall NewCloudSaveAvailable(int nIndex)
{
  return 0;
}

//----- (0027B114) --------------------------------------------------------
void __fastcall OS_MovieKeepAspectRatio(bool keep)
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  sub_193E64(CurrentJNIEnv, s_event_globalThiz, s_MovieKeepAspectRatio);
}

//----- (0027B148) --------------------------------------------------------
void __fastcall AND_CreateTextBox(int id, int x, int y, int x2, int y2)
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  _JNIEnv::CallVoidMethod(CurrentJNIEnv, s_event_globalThiz, s_CreateTextBox, id, x, y, x2, y2);
}

//----- (0027B190) --------------------------------------------------------
bool __fastcall AND_CreateBitmap(unsigned __int8 *bytes, int length)
{
  _JNIEnv *CurrentJNIEnv; // r4
  int v5; // r6
  int v6; // r5

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  v5 = (int)CurrentJNIEnv->functions->NewByteArray(&CurrentJNIEnv->functions, length);
  CurrentJNIEnv->functions->SetByteArrayRegion(
    &CurrentJNIEnv->functions,
    (jbyteArray)v5,
    0,
    length,
    (const jbyte *)bytes);
  v6 = _JNIEnv::CallBooleanMethod(CurrentJNIEnv, s_event_globalThiz, s_ConvertToBitmap, v5, length);
  CurrentJNIEnv->functions->DeleteLocalRef(&CurrentJNIEnv->functions, (jobject)v5);
  return v6 != 0;
}

//----- (0027B204) --------------------------------------------------------
void __fastcall AND_VibratePhone(int length)
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  sub_193E64(CurrentJNIEnv, s_event_globalThiz, s_ConvertToBitmap);
}

//----- (0027B238) --------------------------------------------------------
void __fastcall AND_VibratePhoneEffect(int effect)
{
  _JNIEnv *CurrentJNIEnv; // r0

  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  sub_193E64(CurrentJNIEnv, s_event_globalThiz, s_VibratePhoneEffect);
}

//----- (0027B26C) --------------------------------------------------------
void __fastcall Java_com_wardrumstudios_utils_WarMedia_NativeNotifyNetworkChange(
        JNIEnv_0 *env,
        jobject_0 clazz,
        int networkState)
{
  int data; // [sp+4h] [bp-Ch] BYREF

  data = networkState;
  if ( AND_AppInitialized )
    OS_ApplicationEvent(OSET_NetworkChanged, &data);
}

//----- (0027B294) --------------------------------------------------------
void __fastcall WarBillingInit(JNIEnv_0 *env)
{
  jclass v2; // r6
  _QWORD v3[6]; // [sp+0h] [bp-30h] BYREF

  _android_log_print(3, "OSWrapper", "JNI Init (Billing)");
  v2 = env->functions->FindClass(env, "com/wardrumstudios/utils/WarBilling");
  v3[0] = *(_QWORD *)off_661EE0;
  v3[1] = *(_QWORD *)&off_661EE8;
  v3[2] = *(_QWORD *)&off_661EF0;
  env->functions->RegisterNatives((JNIEnv *)env, v2, (const JNINativeMethod *)v3, 2);
  s_addSku = env->functions->GetMethodID(env, v2, "AddSKU", "(Ljava/lang/String;)V");
  s_initBilling = env->functions->GetMethodID(env, v2, "InitBilling", &dword_27B3A8);
  s_requestPurchase = env->functions->GetMethodID(env, v2, "RequestPurchase", "(Ljava/lang/String;)Z");
  s_localizedPrice = env->functions->GetMethodID(env, v2, "LocalizedPrice", "(Ljava/lang/String;)Ljava/lang/String;");
  s_setBillingKey = env->functions->GetMethodID(env, v2, "SetBillingKey", "(Ljava/lang/String;)V");
  _android_log_print(3, "OSWrapper", "JNI Init Done (Billing)");
}
// 27B3A8: using guessed type int dword_27B3A8;
// 661EE0: using guessed type char *off_661EE0[2];
// 661EE8: using guessed type void *;
// 661EF0: using guessed type char *;

//----- (0027B3D4) --------------------------------------------------------
void __fastcall WarBilling_notifyChange(JNIEnv_0 *env, jobject_0 clazz, jstring_0 sku, int eventId)
{
  const char *v7; // r11
  int v8; // r5
  int v9; // r6
  OSBillingItemChangeType *p_eventType; // r4

  v7 = (const char *)env->functions->GetStringUTFChars(env, sku, 0);
  v8 = numItems;
  if ( numItems >= 1 )
  {
    v9 = 0;
    p_eventType = &items->eventType;
    while ( strcmp(**((const char ***)p_eventType - 2), v7) )
    {
      ++v9;
      p_eventType += 3;
      if ( v9 >= v8 )
        goto LABEL_8;
    }
    if ( p_eventType != (OSBillingItemChangeType *)byte_8 )
    {
      pthread_mutex_lock((pthread_mutex_t *)billingMutex);
      *((_BYTE *)p_eventType - 3) = 1;
      *p_eventType = eventId;
      pthread_mutex_unlock((pthread_mutex_t *)billingMutex);
    }
  }
LABEL_8:
  env->functions->ReleaseStringUTFChars((JNIEnv *)env, sku, (const unsigned __int8 *)v7);
}

//----- (0027B470) --------------------------------------------------------
void __fastcall WarBilling_changeConnection(JNIEnv_0 *env, jobject_0 clazz, jboolean connected)
{
  int v3; // r4

  v3 = connected;
  pthread_mutex_lock((pthread_mutex_t *)billingMutex);
  appDenied = v3 != 1;
  sub_18D550((pthread_mutex_t *)billingMutex);
}

//----- (0027B4A8) --------------------------------------------------------
void __fastcall AND_StartInvitedGame(bool fromUI)
{
  _BOOL4 v1; // r9
  _JNIEnv *CurrentJNIEnv; // r5
  _JNIEnv *v3; // r5

  v1 = fromUI;
  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v3 = NVThreadGetCurrentJNIEnv();
  _JNIEnv::CallVoidMethod(v3, s_warGameService, s_startInvitedGame, v1);
  if ( ((int (__fastcall *)(_JNIEnv *))v3->functions->ExceptionCheck)(v3) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 210);
    v3->functions->ExceptionDescribe(&v3->functions);
  }
}

//----- (0027B594) --------------------------------------------------------
void AND_StartQuickGame()
{
  _JNIEnv *CurrentJNIEnv; // r4
  _JNIEnv *v1; // r4

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v1 = NVThreadGetCurrentJNIEnv();
  _JNIEnv::CallVoidMethod(v1, s_warGameService, s_startQuickGame);
  if ( ((int (__fastcall *)(_JNIEnv *))v1->functions->ExceptionCheck)(v1) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 220);
    v1->functions->ExceptionDescribe(&v1->functions);
  }
}

//----- (0027B67C) --------------------------------------------------------
void AND_SetPopupView()
{
  _JNIEnv *CurrentJNIEnv; // r4
  _JNIEnv *v1; // r4

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v1 = NVThreadGetCurrentJNIEnv();
  _JNIEnv::CallVoidMethod(v1, s_warGameService, s_setPopupView);
  if ( ((int (__fastcall *)(_JNIEnv *))v1->functions->ExceptionCheck)(v1) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 228);
    v1->functions->ExceptionDescribe(&v1->functions);
  }
}

//----- (0027B764) --------------------------------------------------------
void AND_LeaveRoom()
{
  _JNIEnv *CurrentJNIEnv; // r4
  _JNIEnv *v1; // r4

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v1 = NVThreadGetCurrentJNIEnv();
  _JNIEnv::CallVoidMethod(v1, s_warGameService, s_leaveRoom);
  if ( ((int (__fastcall *)(_JNIEnv *))v1->functions->ExceptionCheck)(v1) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 238);
    v1->functions->ExceptionDescribe(&v1->functions);
  }
}

//----- (0027B84C) --------------------------------------------------------
void AND_UpdateMuliplayer()
{
  _JNIEnv *CurrentJNIEnv; // r4
  _JNIEnv *v1; // r4

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v1 = NVThreadGetCurrentJNIEnv();
  _JNIEnv::CallVoidMethod(v1, s_warGameService, s_updateMuliplayer);
  if ( ((int (__fastcall *)(_JNIEnv *))v1->functions->ExceptionCheck)(v1) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 246);
    v1->functions->ExceptionDescribe(&v1->functions);
  }
}

//----- (0027B934) --------------------------------------------------------
void AND_InvitePLayers()
{
  _JNIEnv *CurrentJNIEnv; // r4
  _JNIEnv *v1; // r4

  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v1 = NVThreadGetCurrentJNIEnv();
  _JNIEnv::CallVoidMethod(v1, s_warGameService, s_invitePlayers);
  if ( ((int (__fastcall *)(_JNIEnv *))v1->functions->ExceptionCheck)(v1) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 256);
    v1->functions->ExceptionDescribe(&v1->functions);
  }
}

//----- (0027BA1C) --------------------------------------------------------
void __fastcall AND_SendData(
        const unsigned __int8 *peer,
        const unsigned __int8 *message,
        unsigned int len,
        bool reliable)
{
  _BOOL4 v5; // r8
  _JNIEnv *CurrentJNIEnv; // r4
  _JNIEnv *v9; // r4
  int v10; // r11
  int v11; // r5

  v5 = reliable;
  if ( !s_warGameService )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warGameService = (jobject_0)_JNIEnv::NewObject(
                                    CurrentJNIEnv,
                                    s_warGameService_class,
                                    s_warGameService_ctor,
                                    s_event_globalThiz);
    s_warGameService = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 200);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v9 = NVThreadGetCurrentJNIEnv();
  v10 = (int)v9->functions->NewStringUTF(&v9->functions, peer);
  v11 = (int)v9->functions->NewByteArray(&v9->functions, len);
  v9->functions->SetByteArrayRegion(&v9->functions, (jbyteArray)v11, 0, len, (const jbyte *)message);
  _JNIEnv::CallVoidMethod(v9, s_warGameService, s_sendData, v10, v11, v5);
  v9->functions->DeleteLocalRef(&v9->functions, (jobject)v10);
  v9->functions->DeleteLocalRef(&v9->functions, (jobject)v11);
  if ( ((int (__fastcall *)(_JNIEnv *))v9->functions->ExceptionCheck)(v9) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 275);
    v9->functions->ExceptionDescribe(&v9->functions);
  }
}

//----- (0027BB60) --------------------------------------------------------
void __fastcall WarGameService_notifySignInChange(JNIEnv_0 *env, jobject_0 clazz, jboolean isConnected)
{
  int v3; // r4

  v3 = isConnected;
  pthread_mutex_lock((pthread_mutex_t *)gameServiceMutex);
  if ( v3 != 1 )
    LOBYTE(v3) = 0;
  s_isSignedIn = v3;
  s_isPendingSignInChange = 1;
  sub_18D550((pthread_mutex_t *)gameServiceMutex);
}
// 6D712D: using guessed type char s_isPendingSignInChange;

//----- (0027BB9C) --------------------------------------------------------
void __fastcall WarGameService_notifySignInFailed(JNIEnv_0 *env, jobject_0 clazz)
{
  pthread_mutex_lock((pthread_mutex_t *)gameServiceMutex);
  s_isSignedIn = 0;
  s_isPendingSignInFailed = 1;
  sub_18D550((pthread_mutex_t *)gameServiceMutex);
}
// 6D712E: using guessed type char s_isPendingSignInFailed;

//----- (0027BBD4) --------------------------------------------------------
void __fastcall WarGameService_notifyAchievementsLoaded(
        JNIEnv_0 *env,
        jobject_0 clazz,
        jobjectArray_0 idsArray,
        jbooleanArray_0 unlockStateArray,
        jintArray_0 currentStepsArray,
        jintArray_0 totalStepsArray)
{
  int v8; // r8
  int v9; // r0
  unsigned int v10; // r6
  const unsigned __int8 **v11; // r5
  jstring *v12; // r11
  const JNINativeInterface *functions; // r0
  jsize i; // r10
  jobject v15; // r6
  bool *v16; // r9
  int *v17; // r10
  jint *v18; // r6
  const unsigned __int8 **v19; // r6
  jstring *v20; // r5
  const unsigned __int8 *v21; // t1
  jstring v22; // t1
  const unsigned __int8 **v23; // [sp+4h] [bp-2Ch]

  v8 = env->functions->GetArrayLength((JNIEnv *)env, idsArray);
  v9 = (unsigned __int64)(unsigned int)v8 >> 30;
  v10 = 4 * v8;
  if ( !is_mul_ok(4u, v8) )
    v9 = 1;
  if ( v9 )
    v10 = -1;
  v11 = (const unsigned __int8 **)operator new[](v10);
  v12 = (jstring *)operator new[](v10);
  functions = env->functions;
  if ( v8 >= 1 )
  {
    for ( i = 0; i != v8; ++i )
    {
      v15 = functions->GetObjectArrayElement(&env->functions, idsArray, i);
      v11[i] = env->functions->GetStringUTFChars(env, v15, 0);
      v12[i] = env->functions->NewGlobalRef(env, v15);
      env->functions->DeleteLocalRef((JNIEnv *)env, v15);
      functions = env->functions;
    }
  }
  v16 = (bool *)functions->GetBooleanArrayElements(&env->functions, unlockStateArray, 0);
  v17 = env->functions->GetIntArrayElements(env, currentStepsArray, 0);
  v18 = env->functions->GetIntArrayElements(env, totalStepsArray, 0);
  v23 = v11;
  AND_OnAchievementsLoaded(v8, v11, v16, v17, (int)v18);
  env->functions->ReleaseBooleanArrayElements((JNIEnv *)env, unlockStateArray, (jboolean *)v16, 2);
  env->functions->ReleaseIntArrayElements((JNIEnv *)env, currentStepsArray, v17, 2);
  env->functions->ReleaseIntArrayElements((JNIEnv *)env, totalStepsArray, v18, 2);
  if ( v8 >= 1 )
  {
    v19 = v11;
    v20 = v12;
    do
    {
      v21 = *v19++;
      env->functions->ReleaseStringUTFChars((JNIEnv *)env, *v20, v21);
      v22 = *v20++;
      env->functions->DeleteGlobalRef((JNIEnv *)env, v22);
      --v8;
    }
    while ( v8 );
  }
  operator delete[](v12);
  operator delete[](v23);
  if ( ((int (__fastcall *)(JNIEnv_0 *))env->functions->ExceptionCheck)(env) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 497);
    env->functions->ExceptionDescribe((JNIEnv *)env);
  }
}

//----- (0027BD54) --------------------------------------------------------
void __fastcall WarGameService_notifyStateConflict(
        JNIEnv_0 *env,
        jobject_0 clazz,
        jint key,
        jstring_0 versionString,
        jbyteArray_0 localData,
        jbyteArray_0 remoteData)
{
  jsize v7; // r11
  jsize v8; // r5
  jbyte *v9; // r9
  jbyte *v10; // r10
  void *v11; // r5
  jsize v13; // [sp+Ch] [bp-24h] BYREF
  void *p; // [sp+10h] [bp-20h] BYREF

  v7 = env->functions->GetArrayLength((JNIEnv *)env, localData);
  v8 = env->functions->GetArrayLength((JNIEnv *)env, remoteData);
  v9 = (jbyte *)operator new[](v7);
  v10 = (jbyte *)operator new[](v8);
  env->functions->GetByteArrayRegion((JNIEnv *)env, localData, 0, v7, v9);
  env->functions->GetByteArrayRegion((JNIEnv *)env, remoteData, 0, v8, v10);
  s_conflictHandler((unsigned __int8 *)v9, v7, (unsigned __int8 *)v10, v8, (unsigned __int8 **)&p, &v13);
  if ( v13 )
  {
    v11 = (void *)((int (__fastcall *)(JNIEnv_0 *))env->functions->NewByteArray)(env);
    env->functions->SetByteArrayRegion((JNIEnv *)env, v11, 0, v13, (const jbyte *)p);
    _JNIEnv::CallVoidMethod(env, s_warGameService, s_resolveState, versionString, v11);
  }
  operator delete[](v9);
  operator delete[](v10);
  free(p);
  if ( ((int (__fastcall *)(JNIEnv_0 *))env->functions->ExceptionCheck)(env) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 522);
    env->functions->ExceptionDescribe((JNIEnv *)env);
  }
}

//----- (0027BE64) --------------------------------------------------------
void __fastcall WarGameService_notifyStateLoaded(JNIEnv_0 *env, jobject_0 clazz, jint status, jint key, void *a5)
{
  __int64 v7; // r8

  if ( a5 )
  {
    HIDWORD(v7) = env->functions->GetArrayLength((JNIEnv *)env, a5);
    LODWORD(v7) = operator new[](HIDWORD(v7));
    env->functions->GetByteArrayRegion((JNIEnv *)env, a5, 0, HIDWORD(v7), (jbyte *)v7);
    if ( status )
      goto LABEL_9;
  }
  else
  {
    v7 = 0LL;
    if ( status )
      goto LABEL_9;
  }
  pthread_mutex_lock((pthread_mutex_t *)gameServiceMutex);
  if ( s_isPendingLoadCompleteNotification == 1 && s_loadedData.data )
    operator delete[](s_loadedData.data);
  s_loadedData.status = CLRS_SUCCESS;
  s_loadedData.key = 0;
  *(_QWORD *)&s_loadedData.data = v7;
  s_isPendingLoadCompleteNotification = 1;
  pthread_mutex_unlock((pthread_mutex_t *)gameServiceMutex);
LABEL_9:
  if ( ((int (__fastcall *)(JNIEnv_0 *))env->functions->ExceptionCheck)(env) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 539);
    env->functions->ExceptionDescribe((JNIEnv *)env);
  }
}
// 6D7130: using guessed type char s_isPendingLoadCompleteNotification;

//----- (0027BF54) --------------------------------------------------------
void __fastcall Java_com_wardrumstudios_utils_WarGameSerice_notifyConflict(
        JNIEnv_0 *env,
        jobject_0 clazz,
        jbyteArray_0 conflict,
        jbyteArray_0 latest)
{
  jsize v7; // r5
  jbyte *v8; // r0
  jsize v9; // r5
  jbyte *v10; // r0

  if ( conflict )
  {
    v7 = env->functions->GetArrayLength((JNIEnv *)env, conflict);
    v8 = (jbyte *)operator new[](v7);
    env->functions->GetByteArrayRegion((JNIEnv *)env, conflict, 0, v7, v8);
  }
  if ( latest )
  {
    v9 = env->functions->GetArrayLength((JNIEnv *)env, latest);
    v10 = (jbyte *)operator new[](v9);
    env->functions->GetByteArrayRegion((JNIEnv *)env, latest, 0, v9, v10);
  }
  if ( ((int (__fastcall *)(JNIEnv_0 *))env->functions->ExceptionCheck)(env) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 563);
    env->functions->ExceptionDescribe((JNIEnv *)env);
  }
}

//----- (0027BFF4) --------------------------------------------------------
void __fastcall WarGameService_notifySnapshotLoading(JNIEnv_0 *env, jobject_0 clazz)
{
  s_isPendingSnapshotLoadingNotification = 1;
}
// 6D7144: using guessed type char s_isPendingSnapshotLoadingNotification;

//----- (0027C004) --------------------------------------------------------
void __fastcall WarGameService_notifySnapshotSelected(JNIEnv_0 *env, jobject_0 clazz, jbyteArray_0 data)
{
  jsize v5; // r5
  jbyte *v6; // r6
  bool v7; // r3

  if ( data )
  {
    v5 = env->functions->GetArrayLength((JNIEnv *)env, data);
    v6 = (jbyte *)operator new[](v5);
    env->functions->GetByteArrayRegion((JNIEnv *)env, data, 0, v5, v6);
  }
  else
  {
    v5 = 0;
    v6 = 0;
  }
  pthread_mutex_lock((pthread_mutex_t *)gameServiceMutex);
  if ( s_isPendingSnapshotSelectedNotification == 1 && s_snapshotData.data )
    operator delete[](s_snapshotData.data);
  v7 = (char)v6;
  s_snapshotData.data = (unsigned __int8 *)v6;
  if ( v6 )
    v7 = 1;
  s_snapshotData.success = v7;
  if ( !v6 )
    v5 = 0;
  s_snapshotData.dataLength = v5;
  s_isPendingSnapshotSelectedNotification = 1;
  pthread_mutex_unlock((pthread_mutex_t *)gameServiceMutex);
  if ( ((int (__fastcall *)(JNIEnv_0 *))env->functions->ExceptionCheck)(env) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 656);
    env->functions->ExceptionDescribe((JNIEnv *)env);
  }
}
// 6D7145: using guessed type char s_isPendingSnapshotSelectedNotification;

//----- (0027C0F0) --------------------------------------------------------
void __fastcall WarGameService_notifySnapshotCountLoaded(JNIEnv_0 *env, jobject_0 clazz, jint count)
{
  pthread_mutex_lock((pthread_mutex_t *)gameServiceMutex);
  s_snapshotCount = count;
  pthread_mutex_unlock((pthread_mutex_t *)gameServiceMutex);
  if ( ((int (__fastcall *)(JNIEnv_0 *))env->functions->ExceptionCheck)(env) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 665);
    env->functions->ExceptionDescribe((JNIEnv *)env);
  }
}

//----- (0027C158) --------------------------------------------------------
void __fastcall WarGameService_notifyLeaderboardQuery(
        JNIEnv_0 *env,
        jobject_0 clazz,
        jint queryId,
        jfloatArray_0 scores,
        void *a5)
{
  float *v6; // r10
  int v7; // r8
  int v8; // r0
  unsigned int v9; // r9
  const unsigned __int8 **v10; // r5
  jstring *v11; // r11
  jsize v12; // r9
  jobject v13; // r10
  const unsigned __int8 **v14; // r9
  const unsigned __int8 **v15; // r6
  jstring *v16; // r5
  const unsigned __int8 *v17; // t1
  jstring v18; // t1
  float *v19; // [sp+4h] [bp-24h]

  v6 = env->functions->GetFloatArrayElements(env, scores, 0);
  v7 = env->functions->GetArrayLength((JNIEnv *)env, a5);
  v8 = (unsigned __int64)(unsigned int)v7 >> 30;
  v9 = 4 * v7;
  if ( !is_mul_ok(4u, v7) )
    v8 = 1;
  if ( v8 )
    v9 = -1;
  v10 = (const unsigned __int8 **)operator new[](v9);
  v11 = (jstring *)operator new[](v9);
  if ( v7 < 1 )
  {
    v14 = v10;
    AND_OnLeaderboardQuery(queryId, v7, v6, v10);
  }
  else
  {
    v12 = 0;
    v19 = v6;
    do
    {
      v13 = env->functions->GetObjectArrayElement(env, a5, v12);
      v10[v12] = env->functions->GetStringUTFChars(env, v13, 0);
      v11[v12] = env->functions->NewGlobalRef(env, v13);
      env->functions->DeleteLocalRef((JNIEnv *)env, v13);
      ++v12;
    }
    while ( v7 != v12 );
    v14 = v10;
    AND_OnLeaderboardQuery(queryId, v7, v19, v10);
    v15 = v10;
    v16 = v11;
    do
    {
      v17 = *v15++;
      env->functions->ReleaseStringUTFChars((JNIEnv *)env, *v16, v17);
      v18 = *v16++;
      env->functions->DeleteGlobalRef((JNIEnv *)env, v18);
      --v7;
    }
    while ( v7 );
  }
  operator delete[](v11);
  operator delete[](v14);
  if ( ((int (__fastcall *)(JNIEnv_0 *))env->functions->ExceptionCheck)(env) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 696);
    env->functions->ExceptionDescribe((JNIEnv *)env);
  }
  if ( ((int (__fastcall *)(JNIEnv_0 *))env->functions->ExceptionCheck)(env) )
  {
    _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 700);
    env->functions->ExceptionDescribe((JNIEnv *)env);
  }
}
// 27C20C: conditional instruction was optimized away because r8.4>=1

//----- (0027C2C0) --------------------------------------------------------
void __fastcall WarHttpInit(JNIEnv_0 *env)
{
  s_warHttp_class = (jclass_0)env->functions->FindClass(env, "com/wardrumstudios/utils/WarHttp");
  s_warHttp_class = (jclass_0)((int (__fastcall *)(JNIEnv_0 *))env->functions->NewGlobalRef)(env);
  s_warHttp_ctor = env->functions->GetMethodID(env, s_warHttp_class, "<init>", "(Lcom/wardrumstudios/utils/WarBase;)V");
  s_warHttpGet = env->functions->GetMethodID(env, s_warHttp_class, "HttpGet", "(Ljava/lang/String;)Ljava/lang/String;");
  s_warHttpPost = env->functions->GetMethodID(
                    env,
                    s_warHttp_class,
                    "HttpPost",
                    "(Ljava/lang/String;)Ljava/lang/String;");
  s_warHttpGetData = env->functions->GetMethodID(env, s_warHttp_class, "HttpGetData", "(Ljava/lang/String;)[B");
  s_warAddLineFeeds = env->functions->GetMethodID(env, s_warHttp_class, "AddHttpGetLineFeeds", "(Z)V");
}

//----- (0027C3C0) --------------------------------------------------------
void WarHttp_EnsureInitialized()
{
  _JNIEnv *CurrentJNIEnv; // r4

  if ( !s_warHttp )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warHttp = (jobject_0)_JNIEnv::NewObject(CurrentJNIEnv, s_warHttp_class, s_warHttp_ctor, s_event_globalThiz);
    s_warHttp = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 49);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
}

//----- (0027C45C) --------------------------------------------------------
void __fastcall War_AddHttpGetLineFeeds(bool value)
{
  _JNIEnv *CurrentJNIEnv; // r5
  _JNIEnv *v2; // r0

  if ( !s_warHttp )
  {
    CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
    s_warHttp = (jobject_0)_JNIEnv::NewObject(CurrentJNIEnv, s_warHttp_class, s_warHttp_ctor, s_event_globalThiz);
    s_warHttp = (jobject_0)((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->NewGlobalRef)(CurrentJNIEnv);
    if ( ((int (__fastcall *)(_JNIEnv *))CurrentJNIEnv->functions->ExceptionCheck)(CurrentJNIEnv) )
    {
      _android_log_print(3, "OSWrapper", "JNI Exception (line %d):", 49);
      CurrentJNIEnv->functions->ExceptionDescribe(&CurrentJNIEnv->functions);
    }
  }
  v2 = NVThreadGetCurrentJNIEnv();
  sub_193E64(v2, s_warHttp, s_warAddLineFeeds);
}

//----- (0027C514) --------------------------------------------------------
void *__fastcall NVEventMainLoopThreadFunc(void *a1)
{
  _JNIEnv *CurrentJNIEnv; // r0

  NVEventAppMain(0, 0);
  s_eventQueue.m_javaSync.m_block = 0;
  pthread_cond_broadcast(&s_eventQueue.m_javaSync.m_cond);
  s_alreadyFinishing = 1;
  CurrentJNIEnv = NVThreadGetCurrentJNIEnv();
  _JNIEnv::CallVoidMethod(CurrentJNIEnv, s_event_globalThiz, s_finish);
  return 0;
}
// 6DF87C: using guessed type char s_alreadyFinishing;

//----- (0027C560) --------------------------------------------------------
void __fastcall NVEventInsertNewest(NVEventQueue_0 *q, NVEvent_0 *ev)
{
  int v3; // r3
  int32_t_0 v4; // r0
  unsigned __int32 v5; // r12
  int v6; // r3
  int v7; // r2
  __int64 v8; // d17
  NVEventWindowSize_0 v9; // d18
  NVEvent_0 *v10; // r1
  int32_t_0 v11; // r0
  unsigned __int32 v12; // r12
  int v13; // r3
  int v14; // r2
  __int64 v15; // d17
  NVEventWindowSize_0 v16; // d18
  NVEvent_0 *v17; // r1
  int32_t_0 v18; // r0
  unsigned __int32 v19; // r12
  int v20; // r3
  int v21; // r2
  __int64 v22; // d17
  NVEventWindowSize_0 v23; // d18
  NVEvent_0 *v24; // r1
  __int64 v25; // d17
  NVEventWindowSize_0 v26; // d18
  NVEvent_0 *v27; // r0
  __int64 v28; // d17
  NVEventWindowSize_0 v29; // d18
  NVEvent_0 *v30; // r0
  __int64 v31; // d17
  NVEventWindowSize_0 v32; // d18
  NVEvent_0 *v33; // r0

  if ( s_alreadyFinishing )
    return;
  pthread_mutex_lock(&s_eventQueue.m_mutex);
  if ( s_eventQueue.m_waitEventTypes )
  {
    if ( s_eventQueue.m_waitEventTypeCount >= 1 )
    {
      v3 = 0;
      while ( q->m_nextInsertIndex != s_eventQueue.m_waitEventTypes[v3] )
      {
        if ( ++v3 >= s_eventQueue.m_waitEventTypeCount )
          goto LABEL_7;
      }
      goto LABEL_28;
    }
LABEL_7:
    v4 = (unsigned __int8)(LOBYTE(s_eventQueue.m_nextInsertIndex) + 1);
    if ( v4 != s_eventQueue.m_headIndex || v4 == s_eventQueue.m_nextInsertIndex )
      goto LABEL_15;
    v5 = s_eventQueue.m_events[v4].m_type - 6;
    v6 = (unsigned __int8)(LOBYTE(s_eventQueue.m_nextInsertIndex) + 2);
    v7 = v6;
    if ( v5 > 3 )
      v7 = (unsigned __int8)(LOBYTE(s_eventQueue.m_nextInsertIndex) + 1);
    if ( v6 != s_eventQueue.m_nextInsertIndex && v5 <= 3 )
    {
      v7 = (unsigned __int8)(LOBYTE(s_eventQueue.m_nextInsertIndex) + 2);
      if ( (unsigned int)(s_eventQueue.m_events[v6].m_type - 6) <= 3 )
      {
        while ( 1 )
          ;
      }
    }
    if ( v7 == s_eventQueue.m_nextInsertIndex )
    {
LABEL_15:
      v8 = *(_QWORD *)q->m_mutex.__private;
      v9 = *(NVEventWindowSize_0 *)&q->m_nativeSync.m_block;
      v10 = &s_eventQueue.m_events[s_eventQueue.m_nextInsertIndex];
      *(_QWORD *)&v10->m_type = *(_QWORD *)&q->m_nextInsertIndex;
      *(_QWORD *)(&v10->m_data.m_char + 1) = v8;
      *(NVEventWindowSize_0 *)((char *)&v10->m_data.m_size + 12) = v9;
      s_eventQueue.m_nextInsertIndex = v4;
    }
    else
    {
      v25 = *(_QWORD *)q->m_mutex.__private;
      v26 = *(NVEventWindowSize_0 *)&q->m_nativeSync.m_block;
      v27 = &s_eventQueue.m_events[v7];
      *(_QWORD *)&v27->m_type = *(_QWORD *)&q->m_nextInsertIndex;
      *(_QWORD *)(&v27->m_data.m_char + 1) = v25;
      *(NVEventWindowSize_0 *)((char *)&v27->m_data.m_size + 12) = v26;
    }
LABEL_45:
    sub_18D550(&s_eventQueue.m_mutex);
    return;
  }
  if ( q->m_nextInsertIndex == 8 )
  {
    v11 = (unsigned __int8)(LOBYTE(s_eventQueue.m_nextInsertIndex) + 1);
    if ( v11 != s_eventQueue.m_headIndex || v11 == s_eventQueue.m_nextInsertIndex )
      goto LABEL_26;
    v12 = s_eventQueue.m_events[v11].m_type - 6;
    v13 = (unsigned __int8)(LOBYTE(s_eventQueue.m_nextInsertIndex) + 2);
    v14 = v13;
    if ( v12 > 3 )
      v14 = (unsigned __int8)(LOBYTE(s_eventQueue.m_nextInsertIndex) + 1);
    if ( v13 != s_eventQueue.m_nextInsertIndex && v12 <= 3 )
    {
      v14 = (unsigned __int8)(LOBYTE(s_eventQueue.m_nextInsertIndex) + 2);
      if ( (unsigned int)(s_eventQueue.m_events[v13].m_type - 6) <= 3 )
      {
        while ( 1 )
          ;
      }
    }
    if ( v14 == s_eventQueue.m_nextInsertIndex )
    {
LABEL_26:
      v15 = *(_QWORD *)q->m_mutex.__private;
      v16 = *(NVEventWindowSize_0 *)&q->m_nativeSync.m_block;
      v17 = &s_eventQueue.m_events[s_eventQueue.m_nextInsertIndex];
      *(_QWORD *)&v17->m_type = *(_QWORD *)&q->m_nextInsertIndex;
      *(_QWORD *)(&v17->m_data.m_char + 1) = v15;
      *(NVEventWindowSize_0 *)((char *)&v17->m_data.m_size + 12) = v16;
      s_eventQueue.m_nextInsertIndex = v11;
    }
    else
    {
      v31 = *(_QWORD *)q->m_mutex.__private;
      v32 = *(NVEventWindowSize_0 *)&q->m_nativeSync.m_block;
      v33 = &s_eventQueue.m_events[v14];
      *(_QWORD *)&v33->m_type = *(_QWORD *)&q->m_nextInsertIndex;
      *(_QWORD *)(&v33->m_data.m_char + 1) = v31;
      *(NVEventWindowSize_0 *)((char *)&v33->m_data.m_size + 12) = v32;
    }
    pthread_cond_signal(&s_eventQueue.m_nativeSync.m_cond);
    if ( s_eventQueue.m_javaSync.m_block )
      pthread_cond_wait(&s_eventQueue.m_javaSync.m_cond, &s_eventQueue.m_mutex);
    _android_log_print(3, "NVEvent", "java unblocking from native handling pause");
    goto LABEL_45;
  }
LABEL_28:
  v18 = (unsigned __int8)(LOBYTE(s_eventQueue.m_nextInsertIndex) + 1);
  if ( v18 != s_eventQueue.m_headIndex || v18 == s_eventQueue.m_nextInsertIndex )
    goto LABEL_36;
  v19 = s_eventQueue.m_events[v18].m_type - 6;
  v20 = (unsigned __int8)(LOBYTE(s_eventQueue.m_nextInsertIndex) + 2);
  v21 = v20;
  if ( v19 > 3 )
    v21 = (unsigned __int8)(LOBYTE(s_eventQueue.m_nextInsertIndex) + 1);
  if ( v20 != s_eventQueue.m_nextInsertIndex && v19 <= 3 )
  {
    v21 = (unsigned __int8)(LOBYTE(s_eventQueue.m_nextInsertIndex) + 2);
    if ( (unsigned int)(s_eventQueue.m_events[v20].m_type - 6) <= 3 )
    {
      while ( 1 )
        ;
    }
  }
  if ( v21 == s_eventQueue.m_nextInsertIndex )
  {
LABEL_36:
    v22 = *(_QWORD *)q->m_mutex.__private;
    v23 = *(NVEventWindowSize_0 *)&q->m_nativeSync.m_block;
    v24 = &s_eventQueue.m_events[s_eventQueue.m_nextInsertIndex];
    *(_QWORD *)&v24->m_type = *(_QWORD *)&q->m_nextInsertIndex;
    *(_QWORD *)(&v24->m_data.m_char + 1) = v22;
    *(NVEventWindowSize_0 *)((char *)&v24->m_data.m_size + 12) = v23;
    s_eventQueue.m_nextInsertIndex = v18;
  }
  else
  {
    v28 = *(_QWORD *)q->m_mutex.__private;
    v29 = *(NVEventWindowSize_0 *)&q->m_nativeSync.m_block;
    v30 = &s_eventQueue.m_events[v21];
    *(_QWORD *)&v30->m_type = *(_QWORD *)&q->m_nextInsertIndex;
    *(_QWORD *)(&v30->m_data.m_char + 1) = v28;
    *(NVEventWindowSize_0 *)((char *)&v30->m_data.m_size + 12) = v29;
  }
  pthread_cond_signal(&s_eventQueue.m_nativeSync.m_cond);
  sub_18D550(&s_eventQueue.m_mutex);
}
// 6DF87C: using guessed type char s_alreadyFinishing;

//----- (0027C85C) --------------------------------------------------------
void __fastcall flip_blocks_dxtc1(DXTColBlock *line, NvS32 numBlocks)
{
  NvU8 *row; // r0
  NvU8 v3; // lr
  NvU8 v4; // r12
  NvU8 v5; // r3

  if ( numBlocks >= 1 )
  {
    row = line->row;
    do
    {
      v3 = *row;
      --numBlocks;
      v4 = row[1];
      v5 = row[2];
      *row = row[3];
      row[3] = v3;
      row[1] = v5;
      row[2] = v4;
      row += 8;
    }
    while ( numBlocks );
  }
}

//----- (0027C88A) --------------------------------------------------------
void __fastcall flip_blocks_dxtc3(DXTColBlock *line, NvS32 numBlocks)
{
  NvU16 col0; // lr
  NvU16 col1; // r12
  NvU16 v4; // r2
  NvU8 v5; // r3
  NvU8 v6; // r4
  NvU8 v7; // r5
  NvU8 v8; // r6

  if ( numBlocks >= 1 )
  {
    do
    {
      --numBlocks;
      col0 = line->col0;
      col1 = line->col1;
      v4 = *(_WORD *)line->row;
      line->col0 = *(_WORD *)&line->row[2];
      v5 = line[1].row[0];
      v6 = line[1].row[1];
      v7 = line[1].row[2];
      v8 = line[1].row[3];
      *(_WORD *)&line->row[2] = col0;
      line->col1 = v4;
      *(_WORD *)line->row = col1;
      line[1].row[0] = v8;
      line[1].row[3] = v5;
      line[1].row[1] = v7;
      line[1].row[2] = v6;
      line += 2;
    }
    while ( numBlocks );
  }
}

//----- (0027C8CC) --------------------------------------------------------
void __fastcall flip_blocks_dxtc5(DXTColBlock *line, NvS32 numBlocks)
{
  NvU8 *v2; // r0
  NvU8 v3; // r5
  int v4; // r9
  NvU8 *v5; // r11
  NvU8 v6; // r2
  int v7; // r6
  NvU8 v8; // r10
  unsigned int v9; // r2
  int v10; // r10
  NvU8 *v11; // r5
  int v12; // r9
  int v13; // r6
  unsigned int v14; // r6
  int v15; // r3

  if ( numBlocks >= 1 )
  {
    v2 = &line[1].row[3];
    do
    {
      v3 = *(v2 - 3);
      v5 = v2 - 10;
      v4 = *((unsigned __int16 *)v2 - 5);
      --numBlocks;
      v6 = *(v2 - 1);
      v7 = *(v2 - 8);
      v8 = *(v2 - 2);
      *(v2 - 3) = *v2;
      *v2 = v3;
      *(v2 - 2) = v6;
      v9 = v4 | (v7 << 16);
      *(v2 - 1) = v8;
      v10 = ((unsigned __int16)(v9 >> 12) | (unsigned __int16)((_WORD)v4 << 12)) & 0x7FFF | (v9 << 12) & 0x38000;
      v11 = v2 - 13;
      v12 = *(unsigned __int16 *)(v2 - 13);
      v2 += 16;
      v13 = v11[2];
      *(_WORD *)v11 = v10;
      v14 = v12 | (v13 << 16);
      v15 = (v14 << 12) & 0x38000 | ((unsigned __int16)(v14 >> 12) | (unsigned __int16)((_WORD)v14 << 12)) & 0x7FFF;
      *(_WORD *)v5 = v15;
      v11[2] = ((v9 << 12) & 0xE00000 | (v9 << 12) & 0x1C0000 | v10) >> 16;
      v5[2] = ((v14 << 12) & 0x1C0000 | v15 | (v14 << 12) & 0xE00000) >> 16;
    }
    while ( numBlocks );
  }
}

//----- (0027C988) --------------------------------------------------------
bool __fastcall AndroidFile::UpdateRead(AndroidFile *this, int numBytes)
{
  unsigned __int8 *readBuffer; // r9
  int numReadBytes; // r5
  __int64 v6; // kr00_8
  off_t v7; // r10
  off_t v8; // r5
  int v9; // r2
  __int64 v10; // kr08_8
  off_t Length; // r10
  off_t v13; // r6
  int v14; // r0

  pthread_mutex_lock((pthread_mutex_t *)fileMutex);
  readBuffer = this->readBuffer;
  if ( !readBuffer )
  {
LABEL_16:
    pthread_mutex_unlock((pthread_mutex_t *)fileMutex);
    return 1;
  }
  numReadBytes = this->numReadBytes;
  v6 = *(_QWORD *)this->readFileHandle;
  if ( numReadBytes <= numBytes )
  {
    if ( (_DWORD)v6 == 1 )
    {
      fread(this->readBuffer, 1u, this->numReadBytes, (FILE *)HIDWORD(v6));
    }
    else
    {
      Length = AAsset_getLength((AAsset *)HIDWORD(v6));
      v13 = AAsset_getLength((AAsset *)HIDWORD(v6));
      v14 = AAsset_getRemainingLength((AAsset *)HIDWORD(v6)) - v13 + Length;
      if ( numReadBytes > v14 )
        numReadBytes = v14;
      AAsset_read((AAsset *)HIDWORD(v6), readBuffer, numReadBytes);
    }
    this->readBuffer = 0;
    goto LABEL_16;
  }
  if ( (_DWORD)v6 == 1 )
  {
    fread(this->readBuffer, 1u, numBytes, (FILE *)HIDWORD(v6));
  }
  else
  {
    v7 = AAsset_getLength((AAsset *)HIDWORD(v6));
    v8 = AAsset_getLength((AAsset *)HIDWORD(v6));
    v9 = AAsset_getRemainingLength((AAsset *)HIDWORD(v6)) - v8 + v7;
    if ( v9 >= numBytes )
      v9 = numBytes;
    AAsset_read((AAsset *)HIDWORD(v6), readBuffer, v9);
  }
  v10 = *(_QWORD *)&this->readBuffer;
  this->readBuffer = (unsigned __int8 *)(v10 + numBytes);
  this->numReadBytes = HIDWORD(v10) - numBytes;
  pthread_mutex_unlock((pthread_mutex_t *)fileMutex);
  return 0;
}

//----- (0027CA7C) --------------------------------------------------------
OSFileError __fastcall AndroidFile::AsyncFlush(AndroidFile *this)
{
  unsigned __int8 *readBuffer; // r5
  int numReadBytes; // r8
  __int64 v4; // kr00_8
  off_t Length; // r9
  off_t v6; // r10
  int v7; // r0

  pthread_mutex_lock((pthread_mutex_t *)fileMutex);
  readBuffer = this->readBuffer;
  if ( readBuffer )
  {
    numReadBytes = this->numReadBytes;
    v4 = *(_QWORD *)this->readFileHandle;
    if ( (_DWORD)v4 == 1 )
    {
      fread(this->readBuffer, 1u, this->numReadBytes, (FILE *)HIDWORD(v4));
    }
    else
    {
      Length = AAsset_getLength((AAsset *)HIDWORD(v4));
      v6 = AAsset_getLength((AAsset *)HIDWORD(v4));
      v7 = AAsset_getRemainingLength((AAsset *)HIDWORD(v4)) - v6 + Length;
      if ( numReadBytes > v7 )
        numReadBytes = v7;
      AAsset_read((AAsset *)HIDWORD(v4), readBuffer, numReadBytes);
    }
    this->readBuffer = 0;
  }
  pthread_mutex_unlock((pthread_mutex_t *)fileMutex);
  return 0;
}

//----- (0027CB00) --------------------------------------------------------
void _JNIEnv::CallVoidMethod(_JNIEnv *this, jobject_0 obj, jmethodID methodID, ...)
{
  ((void (__fastcall *)(_JNIEnv *, jobject_0, jmethodID))this->functions->CallVoidMethodV)(this, obj, methodID);
}

//----- (0027CB24) --------------------------------------------------------
int _JNIEnv::CallBooleanMethod(_JNIEnv *this, jobject_0 obj, jmethodID methodID, ...)
{
  return ((int (__fastcall *)(_JNIEnv *, jobject_0, jmethodID))this->functions->CallBooleanMethodV)(this, obj, methodID);
}

//----- (0027CB48) --------------------------------------------------------
void __fastcall ANDThreadData::Destroy(void *toDestroy)
{
  if ( toDestroy )
    j_free(toDestroy);
}

//----- (0027CB52) --------------------------------------------------------
jint _JNIEnv::CallIntMethod(_JNIEnv *this, jobject_0 obj, jmethodID methodID, ...)
{
  return ((int (__fastcall *)(_JNIEnv *, jobject_0, jmethodID))this->functions->CallIntMethodV)(this, obj, methodID);
}

//----- (0027CB76) --------------------------------------------------------
void __fastcall OSArray<LeaderboardQuerySt *>::~OSArray(OSArray<LeaderboardQuerySt *> *this)
{
  LeaderboardQuerySt **dataPtr; // r0

  dataPtr = this->dataPtr;
  this->numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->dataPtr = 0;
  }
  this->numAlloced = 0;
}

//----- (0027CB90) --------------------------------------------------------
void __fastcall OSArray<ZIPFile *>::~OSArray(OSArray<ZIPFile *> *this)
{
  ZIPFile **dataPtr; // r0

  dataPtr = this->dataPtr;
  this->numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->dataPtr = 0;
  }
  this->numAlloced = 0;
}

//----- (0027CBAA) --------------------------------------------------------
void __fastcall ButtonContainer<100>::~ButtonContainer(ButtonContainer<100> *this)
{
  ButtonStateChange *dataPtr; // r0

  dataPtr = this->pendingChanges.dataPtr;
  this->pendingChanges.numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->pendingChanges.dataPtr = 0;
  }
  this->pendingChanges.numAlloced = 0;
}

//----- (0027CBCC) --------------------------------------------------------
bool __fastcall ButtonContainer<3>::Update(ButtonContainer<3> *this, bool clearInput)
{
  float AccumulatedWheelDelta; // r2
  OSPointerState v4; // r0
  OSPointerState v5; // r0
  OSPointerState v6; // r0
  OSPointerState v7; // r0
  OSPointerState v8; // r0
  OSPointerState v9; // r0
  unsigned int numEntries; // r3
  int v11; // r2
  unsigned int v12; // r11
  ButtonStateChange *dataPtr; // r0
  ButtonStateChange *v14; // r1
  int buttonIndex; // r9
  OSPointerState state; // r6
  OSPointerState v17; // r4
  bool v18; // zf
  double timeStamp; // d16
  double *v20; // r0
  float v21; // s0
  OSPointerState *v22; // r1
  int *v23; // r1
  int v24; // t1
  int v25; // r6
  int curY; // r6
  int v27; // r5
  int v28; // r4
  int systemX; // r0
  int systemY; // r1
  float systemForce; // r2

  AccumulatedWheelDelta = this->AccumulatedWheelDelta;
  v4 = this->curState[0];
  this->AccumulatedWheelDelta = 0.0;
  this->WheelDelta = AccumulatedWheelDelta;
  if ( (unsigned int)(v4 + 1) >= 2 )
  {
    if ( v4 != OSPS_ButtonPressed )
      goto LABEL_6;
    v5 = OSPS_ButtonDown;
  }
  else
  {
    v5 = OSPS_ButtonUp;
  }
  this->curState[0] = v5;
LABEL_6:
  if ( this->doubleClicked[0] )
    this->doubleClicked[0] = 0;
  v6 = this->curState[1];
  if ( (unsigned int)(v6 + 1) >= 2 )
  {
    if ( v6 != OSPS_ButtonPressed )
      goto LABEL_13;
    v7 = OSPS_ButtonDown;
  }
  else
  {
    v7 = OSPS_ButtonUp;
  }
  this->curState[1] = v7;
LABEL_13:
  if ( this->doubleClicked[1] )
    this->doubleClicked[1] = 0;
  v8 = this->curState[2];
  if ( (unsigned int)(v8 + 1) < 2 )
  {
    v9 = OSPS_ButtonUp;
LABEL_19:
    this->curState[2] = v9;
    goto LABEL_20;
  }
  if ( v8 == OSPS_ButtonPressed )
  {
    v9 = OSPS_ButtonDown;
    goto LABEL_19;
  }
LABEL_20:
  if ( this->doubleClicked[2] )
    this->doubleClicked[2] = 0;
  if ( clearInput )
  {
    this->pendingChanges.numEntries = 0;
    *(_WORD *)this->doubleClicked = 0;
    this->doubleClicked[2] = 0;
    this->curState[0] = OSPS_ButtonUp;
    this->curState[1] = OSPS_ButtonUp;
    this->curState[2] = OSPS_ButtonUp;
LABEL_47:
    systemX = this->systemX;
    systemY = this->systemY;
    systemForce = this->systemForce;
    this->pendingChanges.numEntries = 0;
    this->curX = systemX;
    this->curY = systemY;
    this->curForce = systemForce;
    return 1;
  }
  numEntries = this->pendingChanges.numEntries;
  if ( !numEntries )
    goto LABEL_47;
  v11 = 0;
  v12 = 0;
  while ( 1 )
  {
    dataPtr = this->pendingChanges.dataPtr;
    v14 = &dataPtr[v11];
    buttonIndex = dataPtr[v11].buttonIndex;
    state = dataPtr[v11].state;
    v17 = this->curState[buttonIndex];
    if ( v17 == state )
      goto LABEL_46;
    v18 = v17 == OSPS_ButtonUp;
    if ( v17 == OSPS_ButtonUp )
      v18 = state == OSPS_ButtonReleased;
    if ( v18 )
      goto LABEL_46;
    if ( v17 != OSPS_ButtonDown )
      break;
    if ( state != OSPS_ButtonPressed )
      goto LABEL_35;
LABEL_46:
    numEntries = this->pendingChanges.numEntries;
    ++v12;
    ++v11;
    if ( v12 >= numEntries )
      goto LABEL_47;
  }
  if ( (unsigned int)(v17 + 1) >= 2 && v17 != OSPS_ButtonPressed )
  {
LABEL_35:
    this->curState[buttonIndex] = state;
    if ( state == OSPS_ButtonReleased )
    {
      timeStamp = this->pendingChanges.dataPtr[v11].timeStamp;
      v20 = &this->lastUp[buttonIndex];
      v21 = timeStamp - *v20;
      if ( this->doubleClickDelay <= v21 )
      {
        v23 = &this->lastUpX[buttonIndex];
      }
      else
      {
        v22 = &this->curState[buttonIndex];
        v24 = *((_DWORD *)v22 + 20);
        v23 = (int *)(v22 + 20);
        v25 = this->curX - v24;
        if ( v25 < 0 )
          v25 = -v25;
        if ( v25 < windowSize[0] / 10 )
        {
          curY = this->curY;
          v27 = this->lastUpY[buttonIndex];
          v28 = curY - v27;
          if ( curY - v27 < 0 )
            v28 = v27 - curY;
          if ( v28 < windowSize[0] / 10 )
          {
            this->doubleClicked[buttonIndex] = 1;
            timeStamp = this->pendingChanges.dataPtr[v11].timeStamp;
          }
        }
      }
      *v20 = timeStamp;
      *v23 = this->curX;
      this->lastUpY[buttonIndex] = this->curY;
    }
    goto LABEL_46;
  }
  this->curX = v14[-1].x;
  this->curY = v14[-1].y;
  this->curForce = v14[-1].force;
  memmove(dataPtr, v14, 32 * (numEntries - v12));
  this->pendingChanges.numEntries -= v12;
  return 0;
}

//----- (0027CDBC) --------------------------------------------------------
bool __fastcall ButtonContainer<100>::Update(ButtonContainer<100> *this, bool clearInput)
{
  float AccumulatedWheelDelta; // r2
  int i; // r2
  OSPointerState v5; // r3
  OSPointerState v6; // r3
  char *v7; // r3
  int j; // r2
  unsigned int numEntries; // r3
  int v10; // r2
  unsigned int v11; // r11
  ButtonStateChange *dataPtr; // r0
  ButtonStateChange *v13; // r1
  int buttonIndex; // r9
  OSPointerState state; // r6
  OSPointerState v16; // r4
  bool v17; // zf
  double timeStamp; // d16
  double *v19; // r0
  float v20; // s0
  OSPointerState *v21; // r4
  int v22; // r6
  int *v23; // r1
  int v24; // r4
  int systemX; // r0
  int systemY; // r1
  float systemForce; // r2

  AccumulatedWheelDelta = this->AccumulatedWheelDelta;
  this->AccumulatedWheelDelta = 0.0;
  this->WheelDelta = AccumulatedWheelDelta;
  for ( i = 0; i != 100; ++i )
  {
    v5 = this->curState[i];
    if ( (unsigned int)(v5 + 1) >= 2 )
    {
      if ( v5 != OSPS_ButtonPressed )
        goto LABEL_7;
      v6 = OSPS_ButtonDown;
    }
    else
    {
      v6 = OSPS_ButtonUp;
    }
    this->curState[i] = v6;
LABEL_7:
    v7 = (char *)this + i;
    if ( v7[440] )
      v7[440] = 0;
  }
  if ( clearInput )
  {
    this->pendingChanges.numEntries = 0;
    if ( this->doubleClicked >= (bool *)&this->curX || &this->doubleClicked[100] <= (bool *)this )
    {
      *(_DWORD *)this->doubleClicked = 0;
      *(_QWORD *)this->curState = 0x100000001LL;
      *(_QWORD *)&this->curState[2] = 0x100000001LL;
      *(_DWORD *)&this->doubleClicked[4] = 0;
      *(_QWORD *)&this->curState[4] = 0x100000001LL;
      *(_QWORD *)&this->curState[6] = 0x100000001LL;
      *(_DWORD *)&this->doubleClicked[8] = 0;
      *(_DWORD *)&this->doubleClicked[12] = 0;
      *(_DWORD *)&this->doubleClicked[16] = 0;
      *(_DWORD *)&this->doubleClicked[20] = 0;
      *(_DWORD *)&this->doubleClicked[24] = 0;
      *(_DWORD *)&this->doubleClicked[28] = 0;
      *(_DWORD *)&this->doubleClicked[32] = 0;
      *(_DWORD *)&this->doubleClicked[36] = 0;
      *(_DWORD *)&this->doubleClicked[40] = 0;
      *(_QWORD *)&this->curState[8] = 0x100000001LL;
      *(_QWORD *)&this->curState[10] = 0x100000001LL;
      *(_QWORD *)&this->curState[12] = 0x100000001LL;
      *(_QWORD *)&this->curState[14] = 0x100000001LL;
      *(_QWORD *)&this->curState[16] = 0x100000001LL;
      *(_QWORD *)&this->curState[18] = 0x100000001LL;
      *(_QWORD *)&this->curState[20] = 0x100000001LL;
      *(_QWORD *)&this->curState[22] = 0x100000001LL;
      *(_QWORD *)&this->curState[24] = 0x100000001LL;
      *(_QWORD *)&this->curState[26] = 0x100000001LL;
      *(_QWORD *)&this->curState[28] = 0x100000001LL;
      *(_QWORD *)&this->curState[30] = 0x100000001LL;
      *(_QWORD *)&this->curState[32] = 0x100000001LL;
      *(_QWORD *)&this->curState[34] = 0x100000001LL;
      *(_QWORD *)&this->curState[36] = 0x100000001LL;
      *(_QWORD *)&this->curState[38] = 0x100000001LL;
      *(_DWORD *)&this->doubleClicked[44] = 0;
      *(_QWORD *)&this->curState[40] = 0x100000001LL;
      *(_QWORD *)&this->curState[42] = 0x100000001LL;
      *(_DWORD *)&this->doubleClicked[48] = 0;
      *(_QWORD *)&this->curState[44] = 0x100000001LL;
      *(_QWORD *)&this->curState[46] = 0x100000001LL;
      *(_DWORD *)&this->doubleClicked[52] = 0;
      *(_QWORD *)&this->curState[48] = 0x100000001LL;
      *(_QWORD *)&this->curState[50] = 0x100000001LL;
      *(_DWORD *)&this->doubleClicked[56] = 0;
      *(_QWORD *)&this->curState[52] = 0x100000001LL;
      *(_QWORD *)&this->curState[54] = 0x100000001LL;
      *(_DWORD *)&this->doubleClicked[60] = 0;
      *(_QWORD *)&this->curState[56] = 0x100000001LL;
      *(_QWORD *)&this->curState[58] = 0x100000001LL;
      *(_DWORD *)&this->doubleClicked[64] = 0;
      *(_QWORD *)&this->curState[60] = 0x100000001LL;
      *(_QWORD *)&this->curState[62] = 0x100000001LL;
      *(_DWORD *)&this->doubleClicked[68] = 0;
      *(_QWORD *)&this->curState[64] = 0x100000001LL;
      *(_QWORD *)&this->curState[66] = 0x100000001LL;
      *(_DWORD *)&this->doubleClicked[72] = 0;
      *(_QWORD *)&this->curState[68] = 0x100000001LL;
      *(_QWORD *)&this->curState[70] = 0x100000001LL;
      *(_DWORD *)&this->doubleClicked[76] = 0;
      *(_QWORD *)&this->curState[72] = 0x100000001LL;
      *(_QWORD *)&this->curState[74] = 0x100000001LL;
      *(_DWORD *)&this->doubleClicked[80] = 0;
      *(_QWORD *)&this->curState[76] = 0x100000001LL;
      *(_QWORD *)&this->curState[78] = 0x100000001LL;
      *(_DWORD *)&this->doubleClicked[84] = 0;
      *(_QWORD *)&this->curState[80] = 0x100000001LL;
      *(_QWORD *)&this->curState[82] = 0x100000001LL;
      *(_DWORD *)&this->doubleClicked[88] = 0;
      *(_QWORD *)&this->curState[84] = 0x100000001LL;
      *(_QWORD *)&this->curState[86] = 0x100000001LL;
      *(_DWORD *)&this->doubleClicked[92] = 0;
      *(_QWORD *)&this->curState[88] = 0x100000001LL;
      *(_QWORD *)&this->curState[90] = 0x100000001LL;
      *(_DWORD *)&this->doubleClicked[96] = 0;
      *(_QWORD *)&this->curState[92] = 0x100000001LL;
      *(_QWORD *)&this->curState[94] = 0x100000001LL;
      *(_QWORD *)&this->curState[96] = 0x100000001LL;
      *(_QWORD *)&this->curState[98] = 0x100000001LL;
    }
    else
    {
      for ( j = 0; j != 100; ++j )
      {
        this->doubleClicked[j] = 0;
        this->curState[j] = OSPS_ButtonUp;
      }
    }
  }
  numEntries = this->pendingChanges.numEntries;
  if ( !numEntries )
  {
LABEL_40:
    systemX = this->systemX;
    systemY = this->systemY;
    systemForce = this->systemForce;
    this->pendingChanges.numEntries = 0;
    this->curX = systemX;
    this->curY = systemY;
    this->curForce = systemForce;
    return 1;
  }
  v10 = 0;
  v11 = 0;
  while ( 2 )
  {
    dataPtr = this->pendingChanges.dataPtr;
    v13 = &dataPtr[v10];
    buttonIndex = dataPtr[v10].buttonIndex;
    state = dataPtr[v10].state;
    v16 = this->curState[buttonIndex];
    if ( v16 == state )
      goto LABEL_39;
    v17 = v16 == OSPS_ButtonUp;
    if ( v16 == OSPS_ButtonUp )
      v17 = state == OSPS_ButtonReleased;
    if ( v17 )
    {
LABEL_39:
      numEntries = this->pendingChanges.numEntries;
      ++v11;
      ++v10;
      if ( v11 >= numEntries )
        goto LABEL_40;
      continue;
    }
    break;
  }
  if ( v16 == OSPS_ButtonDown )
  {
    if ( state == OSPS_ButtonPressed )
      goto LABEL_39;
    goto LABEL_28;
  }
  if ( (unsigned int)(v16 + 1) >= 2 && v16 != OSPS_ButtonPressed )
  {
LABEL_28:
    this->curState[buttonIndex] = state;
    if ( state == OSPS_ButtonReleased )
    {
      timeStamp = this->pendingChanges.dataPtr[v10].timeStamp;
      v19 = &this->lastUp[buttonIndex];
      v20 = timeStamp - *v19;
      if ( this->doubleClickDelay <= v20 )
      {
        v23 = &this->lastUpX[buttonIndex];
      }
      else
      {
        v21 = &this->curState[buttonIndex];
        v22 = this->curX - *((_DWORD *)v21 + 336);
        if ( v22 < 0 )
          v22 = *((_DWORD *)v21 + 336) - this->curX;
        v23 = (int *)(v21 + 336);
        if ( v22 < windowSize[0] / 10 )
        {
          v24 = this->curY - *((_DWORD *)v21 + 436);
          if ( v24 < 0 )
            v24 = -v24;
          if ( v24 < windowSize[0] / 10 )
          {
            this->doubleClicked[buttonIndex] = 1;
            timeStamp = this->pendingChanges.dataPtr[v10].timeStamp;
          }
        }
      }
      *v19 = timeStamp;
      *v23 = this->curX;
      this->lastUpY[buttonIndex] = this->curY;
    }
    goto LABEL_39;
  }
  this->curX = v13[-1].x;
  this->curY = v13[-1].y;
  this->curForce = v13[-1].force;
  memmove(dataPtr, v13, 32 * (numEntries - v11));
  this->pendingChanges.numEntries -= v11;
  return 0;
}

//----- (0027D120) --------------------------------------------------------
bool __fastcall ButtonContainer<16>::Update(ButtonContainer<16> *this, bool clearInput)
{
  float AccumulatedWheelDelta; // r2
  int i; // r2
  OSPointerState v5; // r3
  OSPointerState v6; // r3
  char *v7; // r3
  unsigned int numEntries; // r11
  int v9; // r2
  unsigned int v10; // r10
  ButtonStateChange *dataPtr; // r0
  ButtonStateChange *v12; // r1
  int buttonIndex; // r9
  OSPointerState state; // r6
  OSPointerState v15; // r5
  bool v16; // zf
  double *v17; // r11
  double timeStamp; // d16
  float v19; // s0
  OSPointerState *v20; // r1
  int *v21; // r1
  int v22; // t1
  int v23; // r6
  int curY; // r0
  int v25; // r6
  int v26; // r5
  int systemX; // r0
  int systemY; // r1
  float systemForce; // r2

  AccumulatedWheelDelta = this->AccumulatedWheelDelta;
  this->AccumulatedWheelDelta = 0.0;
  this->WheelDelta = AccumulatedWheelDelta;
  for ( i = 0; i != 16; ++i )
  {
    v5 = this->curState[i];
    if ( (unsigned int)(v5 + 1) >= 2 )
    {
      if ( v5 != OSPS_ButtonPressed )
        goto LABEL_7;
      v6 = OSPS_ButtonDown;
    }
    else
    {
      v6 = OSPS_ButtonUp;
    }
    this->curState[i] = v6;
LABEL_7:
    v7 = (char *)this + i;
    if ( v7[104] )
      v7[104] = 0;
  }
  if ( clearInput )
  {
    this->doubleClicked[0] = 0;
    this->pendingChanges.numEntries = 0;
    this->doubleClicked[3] = 0;
    *(_WORD *)&this->doubleClicked[1] = 0;
    this->doubleClicked[4] = 0;
    *(_QWORD *)this->curState = 0x100000001LL;
    *(_QWORD *)&this->curState[2] = 0x100000001LL;
    this->doubleClicked[5] = 0;
    this->curState[4] = OSPS_ButtonUp;
    *(_QWORD *)&this->curState[7] = 0x100000001LL;
    *(_QWORD *)&this->curState[9] = 0x100000001LL;
    *(_QWORD *)&this->curState[11] = 0x100000001LL;
    *(_QWORD *)&this->curState[13] = 0x100000001LL;
    this->doubleClicked[6] = 0;
    *(_DWORD *)&this->doubleClicked[7] = 0;
    this->curState[5] = OSPS_ButtonUp;
    this->curState[6] = OSPS_ButtonUp;
    *(_DWORD *)&this->doubleClicked[11] = 0;
    this->doubleClicked[15] = 0;
    this->curState[15] = OSPS_ButtonUp;
LABEL_35:
    systemX = this->systemX;
    systemY = this->systemY;
    systemForce = this->systemForce;
    this->pendingChanges.numEntries = 0;
    this->curX = systemX;
    this->curY = systemY;
    this->curForce = systemForce;
    return 1;
  }
  numEntries = this->pendingChanges.numEntries;
  if ( !numEntries )
    goto LABEL_35;
  v9 = 0;
  v10 = 0;
  while ( 2 )
  {
    dataPtr = this->pendingChanges.dataPtr;
    v12 = &dataPtr[v9];
    buttonIndex = dataPtr[v9].buttonIndex;
    state = dataPtr[v9].state;
    v15 = this->curState[buttonIndex];
    if ( v15 == state )
      goto LABEL_34;
    v16 = v15 == OSPS_ButtonUp;
    if ( v15 == OSPS_ButtonUp )
      v16 = state == OSPS_ButtonReleased;
    if ( v16 )
    {
LABEL_34:
      numEntries = this->pendingChanges.numEntries;
      ++v10;
      ++v9;
      if ( v10 >= numEntries )
        goto LABEL_35;
      continue;
    }
    break;
  }
  if ( v15 == OSPS_ButtonDown )
  {
    if ( state == OSPS_ButtonPressed )
      goto LABEL_34;
    goto LABEL_23;
  }
  if ( (unsigned int)(v15 + 1) >= 2 && v15 != OSPS_ButtonPressed )
  {
LABEL_23:
    this->curState[buttonIndex] = state;
    if ( state == OSPS_ButtonReleased )
    {
      v17 = &this->lastUp[buttonIndex];
      timeStamp = this->pendingChanges.dataPtr[v9].timeStamp;
      v19 = timeStamp - *v17;
      if ( this->doubleClickDelay <= v19 )
      {
        v21 = &this->lastUpX[buttonIndex];
      }
      else
      {
        v20 = &this->curState[buttonIndex];
        v22 = *((_DWORD *)v20 + 62);
        v21 = (int *)(v20 + 62);
        v23 = this->curX - v22;
        if ( v23 < 0 )
          v23 = -v23;
        if ( v23 < windowSize[0] / 10 )
        {
          curY = this->curY;
          v25 = this->lastUpY[buttonIndex];
          v26 = curY - v25;
          if ( curY - v25 < 0 )
            v26 = v25 - curY;
          if ( v26 < windowSize[0] / 10 )
          {
            this->doubleClicked[buttonIndex] = 1;
            timeStamp = this->pendingChanges.dataPtr[v9].timeStamp;
          }
        }
      }
      *v17 = timeStamp;
      *v21 = this->curX;
      this->lastUpY[buttonIndex] = this->curY;
    }
    goto LABEL_34;
  }
  this->curX = v12[-1].x;
  this->curY = v12[-1].y;
  this->curForce = v12[-1].force;
  memmove(dataPtr, v12, 32 * (numEntries - v10));
  this->pendingChanges.numEntries -= v10;
  return 0;
}

//----- (0027D2EC) --------------------------------------------------------
void __fastcall OSArray<char *>::~OSArray(OSArray<char *> *this)
{
  unsigned __int8 **dataPtr; // r0

  dataPtr = this->dataPtr;
  this->numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->dataPtr = 0;
  }
  this->numAlloced = 0;
}

//----- (0027D306) --------------------------------------------------------
int _JNIEnv::CallObjectMethod(_JNIEnv *this, jobject_0 obj, jmethodID methodID, ...)
{
  return ((int (__fastcall *)(_JNIEnv *, jobject_0, jmethodID))this->functions->CallObjectMethodV)(this, obj, methodID);
}

//----- (0027D32A) --------------------------------------------------------
int _JNIEnv::CallStaticObjectMethod(_JNIEnv *this, jclass_0 clazz, jmethodID methodID, ...)
{
  return ((int (__fastcall *)(_JNIEnv *, jclass_0, jmethodID))this->functions->CallStaticObjectMethodV)(
           this,
           clazz,
           methodID);
}

//----- (0027D34E) --------------------------------------------------------
jfloat _JNIEnv::CallFloatMethod(_JNIEnv *this, jobject_0 obj, jmethodID methodID, ...)
{
  return COERCE_FLOAT(((int (__fastcall *)(_JNIEnv *, jobject_0, jmethodID))this->functions->CallFloatMethodV)(this, obj, methodID));
}

//----- (0027D372) --------------------------------------------------------
int _JNIEnv::NewObject(_JNIEnv *this, jclass_0 clazz, jmethodID methodID, ...)
{
  return ((int (__fastcall *)(_JNIEnv *, jclass_0, jmethodID))this->functions->NewObjectV)(this, clazz, methodID);
}

//----- (0027D398) --------------------------------------------------------
int __fastcall APKFile::Find(APKFile *this, const unsigned __int8 *filename)
{
  const char *v3; // r9
  const char *v4; // r4
  bool v5; // zf
  size_t v6; // r0
  size_t v7; // r2
  int v8; // r3
  char *v9; // r3
  int v10; // r6
  signed int v11; // r11
  signed int v12; // r5
  int v13; // r4
  int v14; // r0
  bool v15; // zf
  size_t v16; // r0
  size_t v17; // r1
  int v18; // r2
  char *v19; // r2
  int v20; // r6
  int v21; // r0
  char v23[264]; // [sp+0h] [bp-1A8h] BYREF
  char v24[128]; // [sp+108h] [bp-A0h] BYREF

  v3 = v23;
  strcpy(v23, "assets/");
  strcat(v23, (const char *)filename);
  v4 = v23;
  if ( v23[0] == 46 )
  {
    v4 = v23;
    v5 = v23[1] == 92;
    if ( v23[1] != 92 )
      v5 = v23[1] == 47;
    if ( v5 )
      v4 = &v23[2];
  }
  v6 = strlen(v4);
  v7 = 0;
  do
  {
    v8 = (unsigned __int8)v4[v7];
    if ( v8 == 92 )
      LOBYTE(v8) = 47;
    v24[v7++] = v8;
  }
  while ( v7 <= v6 );
  for ( ; v6; *(v9 - 1) = 0 )
  {
    v9 = &v24[v6];
    if ( v24[v6 - 1] != 32 )
      break;
    --v6;
  }
  v10 = 0;
  v11 = this->entries.numEntries - 1;
  v12 = v11;
  while ( v12 >= v10 )
  {
    v13 = v10 + (v12 - v10) / 2;
    v14 = strcasecmp(v24, (const char *)this->entries.dataPtr[v13].filename);
    if ( v14 >= 1 )
    {
      v10 = v13 + 1;
    }
    else
    {
      v12 = v13 - 1;
      if ( !v14 )
      {
        if ( v13 != -1 )
          return v13;
        break;
      }
    }
  }
  strcat(v23, ".mp3");
  if ( v23[0] == 46 )
  {
    v3 = v23;
    v15 = v23[1] == 92;
    if ( v23[1] != 92 )
      v15 = v23[1] == 47;
    if ( v15 )
      v3 = &v23[2];
  }
  v16 = strlen(v3);
  v17 = 0;
  do
  {
    v18 = (unsigned __int8)v3[v17];
    if ( v18 == 92 )
      LOBYTE(v18) = 47;
    v24[v17++] = v18;
  }
  while ( v17 <= v16 );
  for ( ; v16; *(v19 - 1) = 0 )
  {
    v19 = &v24[v16];
    if ( v24[v16 - 1] != 32 )
      break;
    --v16;
  }
  v20 = 0;
  while ( v11 >= v20 )
  {
    v13 = v20 + (v11 - v20) / 2;
    v21 = strcasecmp(v24, (const char *)this->entries.dataPtr[v13].filename);
    if ( v21 >= 1 )
    {
      v20 = v13 + 1;
    }
    else
    {
      v11 = v13 - 1;
      if ( !v21 )
        return v13;
    }
  }
  return -1;
}
// 27D398: using guessed type char var_A0[128];

//----- (0027D524) --------------------------------------------------------
void __fastcall CAEBankLoader::CAEBankLoader(CAEBankLoader *this)
{
  this->m_bInitialised = 0;
}

//----- (0027D52A) --------------------------------------------------------
void __fastcall CAEBankLoader::~CAEBankLoader(CAEBankLoader *this)
{
  tBankSlot *m_pBankSlotData; // r0
  tBankLookup *m_pBankLookupData; // r0

  if ( this->m_bInitialised )
  {
    m_pBankSlotData = this->m_pBankSlotData;
    if ( this->m_pBankSlotData )
      operator delete[](m_pBankSlotData);
    m_pBankLookupData = this->m_pBankLookupData;
    if ( m_pBankLookupData )
      operator delete[](m_pBankLookupData);
  }
}

//----- (0027D54C) --------------------------------------------------------
Bool8 __fastcall CAEBankLoader::Initialise(CAEBankLoader *this)
{
  Bool8 result; // r0

  if ( !CAEBankLoader::LoadBankSlotFile(this)
    || !CAEBankLoader::LoadBankLookupFile(this)
    || !CAEBankLoader::LoadSFXPakLookupFile(this) )
  {
    return 0;
  }
  result = 1;
  this->m_bInitialised = 1;
  return result;
}

//----- (0027D574) --------------------------------------------------------
Bool8 __fastcall CAEBankLoader::LoadBankSlotFile(CAEBankLoader *this)
{
  u_native v2; // r0
  void *v3; // r5
  unsigned int TotalSize; // r6
  Bool8 result; // r0
  __int64 v6; // r0
  tBankSlot *v7; // r1
  unsigned int v8; // r9
  int v9; // r6
  OSFileError v10; // r8

  v2 = CFileMgr::OpenFile("AUDIO\\CONFIG\\BANKSLOT.DAT", "rb");
  v3 = (void *)v2;
  if ( !v2 )
    return 0;
  TotalSize = CFileMgr::GetTotalSize(v2);
  if ( TotalSize <= 2 )
  {
    CFileMgr::CloseFile((u_native)v3);
    return 0;
  }
  OS_FileRead(v3, &this->m_nBankSlotCount, 2);
  v6 = 4820LL * (unsigned int)this->m_nBankSlotCount;
  if ( !is_mul_ok(0x12D4u, this->m_nBankSlotCount) )
    HIDWORD(v6) = 1;
  if ( HIDWORD(v6) )
    LODWORD(v6) = -1;
  v7 = (tBankSlot *)operator new[](v6);
  v8 = TotalSize - 2;
  this->m_pBankSlotData = v7;
  v9 = 4820 * ((TotalSize - 2) / 0x12D4);
  v10 = OS_FileRead(v3, v7, v9);
  CFileMgr::CloseFile((u_native)v3);
  if ( v10 )
    v9 = 0;
  if ( v8 == v9 )
    return 1;
  if ( this->m_pBankSlotData )
    operator delete[](this->m_pBankSlotData);
  result = 0;
  this->m_pBankSlotData = 0;
  return result;
}

//----- (0027D640) --------------------------------------------------------
Bool8 __fastcall CAEBankLoader::LoadBankLookupFile(CAEBankLoader *this)
{
  u_native v2; // r0
  void *v3; // r5
  unsigned int TotalSize; // r0
  unsigned int v5; // r6
  unsigned int v6; // r4
  unsigned int v7; // r0
  int v8; // r2
  tBankLookup *v9; // r0
  int v10; // r4
  OSFileError v11; // r0
  int v12; // r1
  Bool8 v13; // r6
  tBankLookup *m_pBankLookupData; // r0

  v2 = CFileMgr::OpenFile("AUDIO\\CONFIG\\BANKLKUP.DAT", "rb");
  v3 = (void *)v2;
  if ( !v2 )
    return 0;
  TotalSize = CFileMgr::GetTotalSize(v2);
  v5 = TotalSize;
  if ( TotalSize )
  {
    v6 = (__int16)(TotalSize / 0xC);
    this->m_nBankCount = TotalSize / 0xC;
    v8 = (12 * (unsigned __int64)v6) >> 32;
    v7 = 12 * v6;
    if ( !is_mul_ok(0xCu, v6) )
      v8 = 1;
    if ( v8 )
      v7 = -1;
    v9 = (tBankLookup *)operator new[](v7);
    v10 = 3 * v6;
    this->m_pBankLookupData = v9;
    v11 = OS_FileRead(v3, v9, 4 * v10);
    v12 = 0;
    if ( v11 == OSFE_NoError )
      v12 = 4 * v10;
    if ( v5 == v12 )
    {
      CFileMgr::CloseFile((u_native)v3);
      return 1;
    }
    else
    {
      m_pBankLookupData = this->m_pBankLookupData;
      if ( m_pBankLookupData )
        operator delete[](m_pBankLookupData);
      v13 = 0;
      this->m_pBankLookupData = 0;
      CFileMgr::CloseFile((u_native)v3);
    }
  }
  else
  {
    CFileMgr::CloseFile((u_native)v3);
    return 0;
  }
  return v13;
}

//----- (0027D704) --------------------------------------------------------
Bool8 __fastcall CAEBankLoader::LoadSFXPakLookupFile(CAEBankLoader *this)
{
  u_native v2; // r0
  void *v3; // r5
  unsigned int TotalSize; // r6
  unsigned int v5; // r4
  unsigned int v6; // r0
  int v7; // r2
  tSfxPackFile *v8; // r0
  int v9; // r4
  OSFileError v10; // r9
  Bool8 result; // r0
  tSfxPackFile *m_pSfxPakLookupData; // r0

  v2 = CFileMgr::OpenFile("AUDIO\\CONFIG\\PAKFILES.DAT", "rb");
  v3 = (void *)v2;
  if ( !v2 )
    return 0;
  TotalSize = CFileMgr::GetTotalSize(v2);
  if ( !TotalSize )
  {
    CFileMgr::CloseFile((u_native)v3);
    return 0;
  }
  v5 = (__int16)(TotalSize / 0x34);
  this->m_nSfxPakCount = TotalSize / 0x34;
  v7 = (52 * (unsigned __int64)v5) >> 32;
  v6 = 52 * v5;
  if ( !is_mul_ok(0x34u, v5) )
    v7 = 1;
  if ( v7 )
    v6 = -1;
  v8 = (tSfxPackFile *)operator new[](v6);
  v9 = 52 * (__int16)v5;
  this->m_pSfxPakLookupData = v8;
  v10 = OS_FileRead(v3, v8, v9);
  CFileMgr::CloseFile((u_native)v3);
  if ( v10 )
    v9 = 0;
  if ( TotalSize == v9 )
    return 1;
  m_pSfxPakLookupData = this->m_pSfxPakLookupData;
  if ( m_pSfxPakLookupData )
    operator delete[](m_pSfxPakLookupData);
  result = 0;
  this->m_pSfxPakLookupData = 0;
  return result;
}

//----- (0027D7C8) --------------------------------------------------------
tBankLookup *__fastcall CAEBankLoader::GetBankLookup(CAEBankLoader *this, UInt16 BankID)
{
  if ( this->m_bInitialised && BankID < this->m_nBankCount )
    return &this->m_pBankLookupData[BankID];
  else
    return 0;
}

//----- (0027D7E8) --------------------------------------------------------
void __fastcall AddLoaderTask(LoadTask *toAdd)
{
  unsigned int numEntries; // r4
  unsigned int v3; // r9
  LoadTask **dataPtr; // r5
  LoadTask **v5; // r6

  OS_MutexObtain(loaderMutex);
  numEntries = loaderTasks.numEntries;
  if ( loaderTasks.numAlloced >= loaderTasks.numEntries + 1 )
  {
    dataPtr = loaderTasks.dataPtr;
  }
  else
  {
    v3 = 4 * (loaderTasks.numEntries + 1) / 3 + 3;
    dataPtr = (LoadTask **)malloc(4 * v3);
    v5 = loaderTasks.dataPtr;
    if ( loaderTasks.dataPtr )
    {
      qmemcpy(dataPtr, loaderTasks.dataPtr, 4 * numEntries);
      free(v5);
      numEntries = loaderTasks.numEntries;
    }
    loaderTasks.dataPtr = dataPtr;
    loaderTasks.numAlloced = v3;
  }
  dataPtr[numEntries] = toAdd;
  ++loaderTasks.numEntries;
  OS_MutexRelease(loaderMutex);
  sub_19E750(loaderSemaphore);
}

//----- (0027D8B8) --------------------------------------------------------
bool __fastcall HasLoadTask(ZIPFile *zip, int bank, int sound, int intoSlot)
{
  int v7; // r2
  LoadTask *v8; // r3
  ZIPFile *fromZIP; // r4
  bool v10; // zf
  int soundId; // r3
  bool v12; // zf
  bool v13; // r4

  OS_MutexObtain(loaderMutex);
  if ( loaderTasks.numEntries )
  {
    v7 = 0;
    while ( 1 )
    {
      v8 = loaderTasks.dataPtr[v7];
      fromZIP = v8->fromZIP;
      v10 = fromZIP == zip;
      if ( fromZIP == zip )
        v10 = v8->bankId == bank;
      if ( v10 )
      {
        soundId = v8->soundId;
        v12 = soundId == -1;
        v13 = 1;
        if ( soundId != -1 )
          v12 = soundId == sound;
        if ( v12 )
          break;
      }
      if ( ++v7 >= loaderTasks.numEntries )
        goto LABEL_11;
    }
  }
  else
  {
LABEL_11:
    v13 = 0;
  }
  OS_MutexRelease(loaderMutex);
  return v13;
}

//----- (0027D930) --------------------------------------------------------
unsigned int __fastcall BankLoadingThread(void *data)
{
  _BYTE *v1; // r8
  LoadTask *v2; // r5
  unsigned int numEntries; // r9
  unsigned int v4; // r8
  LoadTask **dataPtr; // r6
  LoadTask **v6; // r4

  v1 = data;
  while ( !killLoaderThread )
  {
    if ( SkipBankLoader == 2 )
    {
      OS_ThreadSleep(10000);
    }
    else
    {
      OS_SemaphoreWait(loaderSemaphore);
      if ( killLoaderThread )
        return 0;
      OS_MutexObtain(loaderMutex);
      v2 = *loaderTasks.dataPtr;
      OS_MutexRelease(loaderMutex);
      v1[25] = 1;
      LoadTask::Load(v2);
      v1[25] = 0;
      OS_MutexObtain(loaderMutex);
      memmove(loaderTasks.dataPtr, loaderTasks.dataPtr + 1, 4 * loaderTasks.numEntries - 4);
      numEntries = finishedTasks.numEntries;
      --loaderTasks.numEntries;
      if ( finishedTasks.numAlloced >= finishedTasks.numEntries + 1 )
      {
        dataPtr = finishedTasks.dataPtr;
      }
      else
      {
        v4 = 4 * (finishedTasks.numEntries + 1) / 3 + 3;
        dataPtr = (LoadTask **)malloc(4 * v4);
        v6 = finishedTasks.dataPtr;
        if ( finishedTasks.dataPtr )
        {
          qmemcpy(dataPtr, finishedTasks.dataPtr, 4 * numEntries);
          free(v6);
          numEntries = finishedTasks.numEntries;
        }
        finishedTasks.dataPtr = dataPtr;
        finishedTasks.numAlloced = v4;
        v1 = data;
      }
      dataPtr[numEntries] = v2;
      ++finishedTasks.numEntries;
      OS_MutexRelease(loaderMutex);
      if ( SkipBankLoader == 1 )
        SkipBankLoader = 2;
    }
  }
  return 0;
}

//----- (0027DB04) --------------------------------------------------------
void __fastcall CAEMP3BankLoader::CAEMP3BankLoader(CAEMP3BankLoader *this)
{
  CAEBankLoader::CAEBankLoader((CAEBankLoader *)&this->CAEBankLoader:168);
  *(_QWORD *)&this->zipFiles.numAlloced = 0LL;
  *(_QWORD *)&this->zipFiles.dataPtr = 0LL;
  this->bankIsLoading = 0;
  this->bankSlots.numEntries = 0;
  this->bankSlots.dataPtr = 0;
  this->_vptr$CAEMP3BankLoader = (int (**)(void))&off_661F48;
  loaderSemaphore = OS_SemaphoreCreate();
  loaderMutex = OS_MutexCreate("BankLoaderMutex");
  loaderThread = OS_ThreadLaunch(BankLoadingThread, this, 4u, "BankLoader", 1, 0);
  this->m_bInitialised = 0;
}
// 661F48: using guessed type void *off_661F48;

//----- (0027DBAC) --------------------------------------------------------
void __fastcall CAEMP3BankLoader::~CAEMP3BankLoader(CAEMP3BankLoader *this)
{
  unsigned int numEntries; // r1
  unsigned int i; // r5
  ZIPFile *v4; // r0
  void *v5; // r0
  int v6; // r6
  unsigned int v7; // r5
  CAEMP3BankLoader::LoadedBankData *v8; // r4
  SoundData *dataPtr; // r0
  CAEMP3BankLoader::LoadedBankData *v10; // r0
  ZIPFile **v11; // r0

  this->_vptr$CAEMP3BankLoader = (int (**)(void))&off_661F48;
  killLoaderThread = 1;
  OS_SemaphorePost(loaderSemaphore);
  OS_ThreadWait(loaderThread);
  OS_ThreadClose(loaderThread);
  loaderThread = 0;
  OS_SemaphoreDelete(loaderSemaphore);
  loaderSemaphore = 0;
  while ( this->bankIsLoading )
    OS_ThreadSleep(1000);
  OS_MutexDelete(loaderMutex);
  loaderMutex = 0;
  CFileMgr::CloseFile(soundInfoFile);
  soundInfoFile = 0;
  numEntries = this->zipFiles.numEntries;
  if ( numEntries )
  {
    for ( i = 0; i < numEntries; ++i )
    {
      v4 = this->zipFiles.dataPtr[i];
      if ( v4 )
      {
        ZIPFile::~ZIPFile(v4);
        operator delete(v5);
        numEntries = this->zipFiles.numEntries;
      }
    }
  }
  if ( this->bankSlots.numEntries )
  {
    v6 = 0;
    v7 = 0;
    do
    {
      v8 = &this->bankSlots.dataPtr[v6];
      dataPtr = v8->sounds.dataPtr;
      v8->sounds.numEntries = 0;
      if ( dataPtr )
      {
        free(dataPtr);
        v8->sounds.dataPtr = 0;
      }
      v8->sounds.numAlloced = 0;
      ++v6;
      ++v7;
    }
    while ( v7 < this->bankSlots.numEntries );
  }
  v10 = this->bankSlots.dataPtr;
  this->bankSlots.numEntries = 0;
  if ( v10 )
  {
    free(v10);
    this->bankSlots.dataPtr = 0;
  }
  v11 = this->zipFiles.dataPtr;
  this->zipFiles.numEntries = 0;
  this->bankSlots.numAlloced = 0;
  if ( v11 )
  {
    free(v11);
    this->zipFiles.dataPtr = 0;
  }
  this->zipFiles.numAlloced = 0;
  CAEBankLoader::~CAEBankLoader((CAEBankLoader *)&this->CAEBankLoader:168);
}
// 27DC3A: variable 'v5' is possibly undefined
// 661F48: using guessed type void *;

//----- (0027DCD8) --------------------------------------------------------
void __fastcall CAEMP3BankLoader::~CAEMP3BankLoader(CAEMP3BankLoader *this)
{
  void *v1; // r0

  CAEMP3BankLoader::~CAEMP3BankLoader(this);
  sub_191374(v1);
}
// 27DCE4: variable 'v1' is possibly undefined

//----- (0027DCE8) --------------------------------------------------------
Bool8 __fastcall CAEMP3BankLoader::Initialise(CAEMP3BankLoader *this)
{
  int v2; // r11
  int v3; // r10
  ZIPFile *v4; // r0
  unsigned int numEntries; // r8
  unsigned int v6; // r9
  ZIPFile **v7; // r0
  ZIPFile **v8; // r6
  ZIPFile **dataPtr; // r5
  int m_nSfxPakCount; // r1
  tSfxPackFile *m_pSfxPakLookupData; // r0
  int m_nBankSlotCount; // r9
  unsigned int numAlloced; // r1
  unsigned int v14; // r6
  unsigned int v15; // r10
  CAEMP3BankLoader::LoadedBankData *v16; // r0
  CAEMP3BankLoader::LoadedBankData *v17; // r8
  CAEMP3BankLoader::LoadedBankData *v18; // r5
  int v20; // r1
  int v21; // r0
  unsigned int v22; // r2
  unsigned int v23; // r6
  unsigned int v24; // r0
  BankData *v25; // r4
  BankData *v26; // r5
  int v27; // r4
  unsigned int v28; // r6
  unsigned int v29; // r8
  unsigned int v30; // r11
  BankData *v31; // r5
  BankData *v32; // r9
  int v33; // r1
  ZIPFile *v34; // [sp+14h] [bp-C4h]
  Int32 v35; // [sp+18h] [bp-C0h] BYREF
  int v36; // [sp+1Ch] [bp-BCh]
  unsigned int buffer; // [sp+24h] [bp-B4h] BYREF
  char v38[132]; // [sp+28h] [bp-B0h] BYREF

  if ( !CAEBankLoader::Initialise((CAEBankLoader *)&this->CAEBankLoader:168) )
    return 0;
  if ( this->m_nSfxPakCount >= 1 )
  {
    v2 = 0;
    v3 = 0;
    do
    {
      strcpy(v38, "AUDIO\\SFX\\");
      strcat(v38, (const char *)&this->m_pSfxPakLookupData[v2]);
      strcat(v38, ".osw");
      v4 = ZIP_FileCreate((const unsigned __int8 *)v38);
      numEntries = this->zipFiles.numEntries;
      if ( this->zipFiles.numAlloced >= numEntries + 1 )
      {
        dataPtr = this->zipFiles.dataPtr;
      }
      else
      {
        v34 = v4;
        v6 = 4 * (numEntries + 1) / 3 + 3;
        v7 = (ZIPFile **)malloc(4 * v6);
        v8 = this->zipFiles.dataPtr;
        dataPtr = v7;
        if ( v8 )
        {
          qmemcpy(v7, this->zipFiles.dataPtr, 4 * numEntries);
          free(v8);
          numEntries = this->zipFiles.numEntries;
        }
        this->zipFiles.dataPtr = dataPtr;
        this->zipFiles.numAlloced = v6;
        v4 = v34;
      }
      dataPtr[numEntries] = v4;
      ++v2;
      ++v3;
      m_nSfxPakCount = this->m_nSfxPakCount;
      ++this->zipFiles.numEntries;
    }
    while ( v3 < m_nSfxPakCount );
  }
  m_pSfxPakLookupData = this->m_pSfxPakLookupData;
  if ( m_pSfxPakLookupData )
    operator delete[](m_pSfxPakLookupData);
  m_nBankSlotCount = this->m_nBankSlotCount;
  v14 = this->bankSlots.numEntries;
  numAlloced = this->bankSlots.numAlloced;
  this->m_pSfxPakLookupData = 0;
  if ( numAlloced >= v14 + m_nBankSlotCount )
  {
    v18 = this->bankSlots.dataPtr;
  }
  else
  {
    v15 = 4 * (v14 + m_nBankSlotCount) / 3 + 3;
    v16 = (CAEMP3BankLoader::LoadedBankData *)malloc(20 * v15);
    v17 = this->bankSlots.dataPtr;
    v18 = v16;
    if ( v17 )
    {
      qmemcpy(v16, this->bankSlots.dataPtr, 20 * v14);
      free(v17);
      v14 = this->bankSlots.numEntries;
    }
    this->bankSlots.dataPtr = v18;
    this->bankSlots.numAlloced = v15;
  }
  memset(&v18[v14], 0, 20 * m_nBankSlotCount);
  v20 = (unsigned __int16)this->m_nBankSlotCount;
  this->bankSlots.numEntries += m_nBankSlotCount;
  if ( v20 )
  {
    v21 = 0;
    v22 = 0;
    do
    {
      ++v22;
      this->bankSlots.dataPtr[v21++].Bank = -1;
    }
    while ( v22 < this->m_nBankSlotCount );
  }
  soundInfoFile = CFileMgr::OpenFile("AUDIO/CONFIG/SOUNDINF.DAT", "rb");
  buffer = 0;
  OS_FileRead((OSFile)soundInfoFile, &buffer, 4);
  v23 = buffer;
  v24 = buffer;
  if ( bankInfo.numAlloced < buffer )
  {
    v25 = (BankData *)malloc(8 * buffer);
    v26 = bankInfo.dataPtr;
    v24 = v23;
    if ( bankInfo.dataPtr )
    {
      qmemcpy(v25, bankInfo.dataPtr, 8 * bankInfo.numEntries);
      free(v26);
      v24 = buffer;
    }
    bankInfo.dataPtr = v25;
    bankInfo.numAlloced = v23;
  }
  if ( v24 )
  {
    v27 = 4 * v23 + 4;
    v28 = 0;
    do
    {
      OS_FileRead((OSFile)soundInfoFile, &v35, 4);
      v29 = bankInfo.numEntries;
      v36 = v27;
      if ( bankInfo.numAlloced >= bankInfo.numEntries + 1 )
      {
        v31 = bankInfo.dataPtr;
      }
      else
      {
        v30 = 4 * (bankInfo.numEntries + 1) / 3 + 3;
        v31 = (BankData *)malloc(8 * v30);
        v32 = bankInfo.dataPtr;
        if ( bankInfo.dataPtr )
        {
          qmemcpy(v31, bankInfo.dataPtr, 8 * v29);
          free(v32);
          v29 = bankInfo.numEntries;
        }
        bankInfo.dataPtr = v31;
        bankInfo.numAlloced = v30;
      }
      v33 = v36;
      ++v28;
      v31[v29].numSounds = v35;
      v31[v29].soundInfoOffset = v33;
      ++bankInfo.numEntries;
      v27 += 12 * v35;
    }
    while ( v28 < buffer );
  }
  return 1;
}

//----- (0027E04C) --------------------------------------------------------
void __fastcall CAEMP3BankLoader::Service(CAEMP3BankLoader *this)
{
  int v2; // r4
  CAEMP3BankLoader::LoadedBankData *dataPtr; // r0
  CAEMP3BankLoader::LoadedBankData *v4; // r1
  unsigned int *p_numEntries; // r1
  unsigned int numEntries; // t1
  int v7; // r11
  unsigned int v8; // r10
  OALBuffer *buffer; // r9
  int v10; // r0
  unsigned int v11; // r4
  OALBase **v12; // r5
  OALBase **v13; // r6
  CAEMP3BankLoader::LoadedBankData *v14; // r1
  unsigned int v15; // t1
  CAEMP3BankLoader::LoadedBankData *v16; // r6
  OSArray<SoundData> *p_sounds; // r9
  unsigned int v18; // r4
  unsigned int *v19; // r5
  __int64 v20; // kr00_8
  SoundData *v21; // r3
  SoundData *v22; // r1
  SoundData **p_dataPtr; // r6
  SoundData *v24; // t1
  int v25; // r0
  SoundData *v26; // r4
  unsigned int v27; // r1
  int v28; // r2
  __int64 v29; // d16
  __int64 v30; // d17
  __int64 v31; // d18
  __int64 v32; // d19
  SoundData *v33; // r3
  LoadTask **v34; // r0
  LoadTask *v35; // r5
  SoundData *v36; // r0
  SoundData *v37; // [sp+4h] [bp-64h]
  unsigned int v38; // [sp+8h] [bp-60h]
  int intoSlotId; // [sp+20h] [bp-48h]
  int v40; // [sp+30h] [bp-38h]
  CAEMP3BankLoader *v41; // [sp+34h] [bp-34h]
  unsigned int v42; // [sp+38h] [bp-30h]
  CAEMP3BankLoader::LoadedBankData *v43; // [sp+38h] [bp-30h]

  OS_MutexObtain(loaderMutex);
  if ( finishedTasks.numEntries )
  {
    v2 = 0;
    v41 = this;
    do
    {
      v40 = v2;
      dataPtr = this->bankSlots.dataPtr;
      intoSlotId = finishedTasks.dataPtr[v2]->intoSlotId;
      v4 = &dataPtr[intoSlotId];
      numEntries = v4->sounds.numEntries;
      p_numEntries = &v4->sounds.numEntries;
      if ( numEntries )
      {
        v7 = 0;
        v8 = 0;
        do
        {
          buffer = dataPtr[intoSlotId].sounds.dataPtr[v7].buffer;
          if ( buffer )
          {
            v10 = buffer->refCount - 1;
            buffer->refCount = v10;
            if ( !v10 )
            {
              OS_MutexObtain(trashMutex);
              v11 = OALBase::trashCan.numEntries;
              if ( OALBase::trashCan.numAlloced >= OALBase::trashCan.numEntries + 1 )
              {
                v12 = OALBase::trashCan.dataPtr;
              }
              else
              {
                v42 = 4 * (OALBase::trashCan.numEntries + 1) / 3 + 3;
                v12 = (OALBase **)malloc(4 * v42);
                v13 = OALBase::trashCan.dataPtr;
                if ( OALBase::trashCan.dataPtr )
                {
                  qmemcpy(v12, OALBase::trashCan.dataPtr, 4 * v11);
                  free(v13);
                  v11 = OALBase::trashCan.numEntries;
                }
                this = v41;
                OALBase::trashCan.dataPtr = v12;
                OALBase::trashCan.numAlloced = v42;
              }
              v12[v11] = buffer;
              ++OALBase::trashCan.numEntries;
              OS_MutexRelease(trashMutex);
            }
          }
          dataPtr = this->bankSlots.dataPtr;
          ++v7;
          ++v8;
          v14 = &dataPtr[intoSlotId];
          v15 = v14->sounds.numEntries;
          p_numEntries = &v14->sounds.numEntries;
        }
        while ( v8 < v15 );
      }
      *p_numEntries = 0;
      v16 = &this->bankSlots.dataPtr[intoSlotId];
      p_sounds = &v16->sounds;
      v19 = &v16->sounds.numEntries;
      v18 = v16->sounds.numEntries;
      v20 = *(_QWORD *)&finishedTasks.dataPtr[v40]->result.numEntries;
      if ( v16->sounds.numAlloced < v18 + (unsigned int)v20 )
      {
        v38 = 4 * (v18 + (unsigned int)v20) / 3 + 3;
        v43 = v16;
        v21 = (SoundData *)malloc(28 * v38);
        v24 = v16->sounds.dataPtr;
        p_dataPtr = &v16->sounds.dataPtr;
        v22 = v24;
        if ( v24 )
        {
          v25 = 7 * v18;
          v37 = v21;
          v26 = v22;
          qmemcpy(v21, v22, 4 * v25);
          free(v26);
          v21 = v37;
        }
        p_sounds->numAlloced = v38;
        *p_dataPtr = v21;
        v16 = v43;
      }
      if ( (_DWORD)v20 )
      {
        v27 = 0;
        v28 = v20;
        do
        {
          --v28;
          v29 = *(_QWORD *)(HIDWORD(v20) + v27);
          v30 = *(_QWORD *)(HIDWORD(v20) + v27 + 8);
          v31 = *(_QWORD *)(HIDWORD(v20) + v27 + 12);
          v32 = *(_QWORD *)(HIDWORD(v20) + v27 + 20);
          v33 = &v16->sounds.dataPtr[*v19 + v27 / 0x1C];
          v27 += 28;
          *(_QWORD *)&v33->buffer = v29;
          *(_QWORD *)&v33->channels = v30;
          v33 = (SoundData *)((char *)v33 + 12);
          *(_QWORD *)&v33->buffer = v31;
          *(_QWORD *)&v33->channels = v32;
        }
        while ( v28 );
      }
      *v19 += v20;
      this = v41;
      v41->bankSlots.dataPtr[intoSlotId].Bank = finishedTasks.dataPtr[v40]->bankId;
      v34 = finishedTasks.dataPtr;
      v41->bankSlots.dataPtr[intoSlotId].singleSound = finishedTasks.dataPtr[v40]->soundId;
      v41->m_pBankSlotData[intoSlotId].Bank = v34[v40]->bankId;
      v35 = v34[v40];
      if ( v35 )
      {
        v36 = v35->result.dataPtr;
        v35->result.numEntries = 0;
        if ( v36 )
          free(v36);
        operator delete(v35);
      }
      v2 = v40 + 1;
    }
    while ( v40 + 1 < finishedTasks.numEntries );
  }
  finishedTasks.numEntries = 0;
  sub_18CEF0(loaderMutex);
}

//----- (0027E320) --------------------------------------------------------
OALBuffer *__fastcall CAEMP3BankLoader::GetSoundBuffer(
        CAEMP3BankLoader *this,
        UInt16 SoundID,
        Int16 BankSlotID,
        UInt16 *frequency)
{
  CAEMP3BankLoader::LoadedBankData *v4; // r0
  int v6; // r1

  v4 = &this->bankSlots.dataPtr[BankSlotID];
  if ( v4->singleSound == SoundID )
  {
    *(_DWORD *)&SoundID = 0;
  }
  else if ( v4->sounds.numEntries <= SoundID )
  {
    return 0;
  }
  v6 = SoundID;
  *frequency = v4->sounds.dataPtr[v6].frequency;
  return v4->sounds.dataPtr[v6].buffer;
}

//----- (0027E354) --------------------------------------------------------
void __fastcall CAEMP3BankLoader::LoadRequest(CAEMP3BankLoader *this, ZIPFile *inFile, int bankId, int soundId, int a5)
{
  int v8; // r2
  LoadTask *v9; // r3
  ZIPFile *fromZIP; // r4
  bool v11; // zf
  int v12; // r3
  bool v13; // zf
  LoadTask *v14; // r0

  OS_MutexObtain(loaderMutex);
  if ( loaderTasks.numEntries )
  {
    v8 = 0;
    while ( 1 )
    {
      v9 = loaderTasks.dataPtr[v8];
      fromZIP = v9->fromZIP;
      v11 = fromZIP == inFile;
      if ( fromZIP == inFile )
        v11 = v9->bankId == bankId;
      if ( v11 )
      {
        v12 = v9->soundId;
        v13 = v12 == -1;
        if ( v12 != -1 )
          v13 = v12 == soundId;
        if ( v13 )
          break;
      }
      if ( ++v8 >= loaderTasks.numEntries )
        goto LABEL_11;
    }
    sub_18CEF0(loaderMutex);
  }
  else
  {
LABEL_11:
    OS_MutexRelease(loaderMutex);
    v14 = (LoadTask *)operator new(0x1Cu);
    v14->result.numAlloced = 0;
    v14->result.numEntries = 0;
    v14->result.dataPtr = 0;
    v14->fromZIP = inFile;
    v14->bankId = bankId;
    v14->soundId = soundId;
    v14->intoSlotId = a5;
    AddLoaderTask(v14);
  }
}

//----- (0027E400) --------------------------------------------------------
void __fastcall CAEMP3BankLoader::LoadSoundBank(CAEMP3BankLoader *this, UInt16 BankID, Int16 BankSlotID)
{
  int v4; // r5
  int v5; // r4
  bool v6; // cc
  CAEMP3BankLoader::LoadedBankData *dataPtr; // r0
  tBankLookup *BankLookup; // r0

  v4 = BankSlotID;
  v5 = BankID;
  if ( this->m_bInitialised && BankID <= this->m_nBankCount )
  {
    v6 = BankSlotID < 0;
    if ( BankSlotID >= 0 )
      v6 = this->m_nBankSlotCount < BankSlotID;
    if ( !v6 )
    {
      dataPtr = this->bankSlots.dataPtr;
      if ( dataPtr[BankSlotID].Bank != BankID || dataPtr[BankSlotID].singleSound != 0xFFFF )
      {
        BankLookup = CAEBankLoader::GetBankLookup((CAEBankLoader *)&this->CAEBankLoader:168, BankID);
        CAEMP3BankLoader::LoadRequest(
          (CAEMP3BankLoader *)BankLookup->PackFile,
          this->zipFiles.dataPtr[BankLookup->PackFile],
          v5,
          -1,
          v4);
      }
    }
  }
}

//----- (0027E468) --------------------------------------------------------
Bool8 __fastcall CAEMP3BankLoader::IsSoundBankLoaded(CAEMP3BankLoader *this, UInt16 BankID, Int16 BankSlotID)
{
  Bool8 result; // r0
  CAEMP3BankLoader::LoadedBankData *dataPtr; // r12

  if ( !this->m_bInitialised )
    return 0;
  dataPtr = this->bankSlots.dataPtr;
  result = 0;
  if ( dataPtr[BankSlotID].Bank == BankID && dataPtr[BankSlotID].singleSound == 0xFFFF )
    return 1;
  return result;
}

//----- (0027E49C) --------------------------------------------------------
void __fastcall CAEMP3BankLoader::LoadSound(CAEMP3BankLoader *this, UInt16 BankID, UInt16 SoundID, Int16 BankSlotID)
{
  int v5; // r8
  int v6; // r4
  int v7; // r5
  bool v8; // cc
  CAEMP3BankLoader::LoadedBankData *dataPtr; // r0
  CAEMP3BankLoader::LoadedBankData *v10; // r0
  int singleSound; // r1
  unsigned int PackFile; // r0

  v5 = BankSlotID;
  v6 = SoundID;
  v7 = BankID;
  if ( this->m_bInitialised && (unsigned int)(SoundID >> 4) <= 0x18 && BankID <= this->m_nBankCount )
  {
    v8 = BankSlotID < 0;
    if ( BankSlotID >= 0 )
      v8 = this->m_nBankSlotCount < BankSlotID;
    if ( !v8 )
    {
      dataPtr = this->bankSlots.dataPtr;
      if ( dataPtr[BankSlotID].Bank == BankID )
      {
        v10 = &dataPtr[BankSlotID];
        singleSound = v10->singleSound;
        if ( singleSound == 0xFFFF )
        {
          if ( v10->sounds.numEntries > SoundID )
            return;
        }
        else if ( singleSound == SoundID )
        {
          return;
        }
      }
      PackFile = CAEBankLoader::GetBankLookup((CAEBankLoader *)&this->CAEBankLoader:168, v7)->PackFile;
      if ( this->zipFiles.numEntries > PackFile )
        CAEMP3BankLoader::LoadRequest((CAEMP3BankLoader *)PackFile, this->zipFiles.dataPtr[PackFile], v7, v6, v5);
    }
  }
}

//----- (0027E520) --------------------------------------------------------
Bool8 __fastcall CAEMP3BankLoader::IsSoundLoaded(
        CAEMP3BankLoader *this,
        UInt16 BankID,
        UInt16 SoundID,
        Int16 BankSlotID)
{
  CAEMP3BankLoader::LoadedBankData *dataPtr; // r12
  CAEMP3BankLoader::LoadedBankData *v5; // r0
  int singleSound; // r1

  if ( !this->m_bInitialised )
    return 0;
  dataPtr = this->bankSlots.dataPtr;
  if ( dataPtr[BankSlotID].Bank != BankID )
    return 0;
  v5 = &dataPtr[BankSlotID];
  singleSound = v5->singleSound;
  return singleSound == 0xFFFF && v5->sounds.numEntries > SoundID || singleSound == SoundID;
}

//----- (0027E564) --------------------------------------------------------
float __fastcall CAEMP3BankLoader::GetSoundHeadroom(CAEMP3BankLoader *this, UInt16 SoundID, Int16 BankSlotID)
{
  CAEMP3BankLoader::LoadedBankData *v4; // r0
  int singleSound; // r2
  SoundData *dataPtr; // r0

  if ( !this->m_bInitialised )
    return 0.0;
  v4 = &this->bankSlots.dataPtr[BankSlotID];
  singleSound = v4->singleSound;
  dataPtr = v4->sounds.dataPtr;
  if ( singleSound == SoundID )
    *(_DWORD *)&SoundID = 0;
  return (float)dataPtr[SoundID].info.Headroom / 100.0;
}

//----- (0027E5B4) --------------------------------------------------------
UInt8 __fastcall CAEMP3BankLoader::GetSoundBankLoadingStatus(CAEMP3BankLoader *this, UInt16 BankID, Int16 BankSlotID)
{
  UInt8 result; // r0
  CAEMP3BankLoader::LoadedBankData *dataPtr; // r12

  if ( !this->m_bInitialised )
    return 0;
  dataPtr = this->bankSlots.dataPtr;
  result = 0;
  if ( dataPtr[BankSlotID].Bank == BankID && dataPtr[BankSlotID].singleSound == 0xFFFF )
    return 1;
  return result;
}

//----- (0027E5E8) --------------------------------------------------------
int __fastcall CAEMP3BankLoader::GetLoopOffset(CAEMP3BankLoader *this, UInt16 SoundID, Int16 BankSlotID)
{
  int result; // r0
  CAEMP3BankLoader::LoadedBankData *v4; // r0
  int singleSound; // r2
  SoundData *dataPtr; // r0
  SoundData *v7; // r1

  if ( !this->m_bInitialised )
    return -1;
  v4 = &this->bankSlots.dataPtr[BankSlotID];
  singleSound = v4->singleSound;
  dataPtr = v4->sounds.dataPtr;
  if ( singleSound == SoundID )
    *(_DWORD *)&SoundID = 0;
  v7 = &dataPtr[SoundID];
  result = v7->info.LoopStartOffset;
  if ( result >= 1 )
    return result * v7->frequency / v7->info.Frequency;
  return result;
}

//----- (0027E62C) --------------------------------------------------------
UInt8 __fastcall CAEMP3BankLoader::GetSoundLoadingStatus(
        CAEMP3BankLoader *this,
        UInt16 BankID,
        UInt16 SoundID,
        Int16 BankSlotID)
{
  CAEMP3BankLoader::LoadedBankData *dataPtr; // r12
  CAEMP3BankLoader::LoadedBankData *v5; // r0
  int singleSound; // r1

  if ( !this->m_bInitialised )
    return 0;
  dataPtr = this->bankSlots.dataPtr;
  if ( dataPtr[BankSlotID].Bank != BankID )
    return 0;
  v5 = &dataPtr[BankSlotID];
  singleSound = v5->singleSound;
  return singleSound == 0xFFFF && v5->sounds.numEntries > SoundID || singleSound == SoundID;
}

//----- (0027E670) --------------------------------------------------------
void __fastcall CAEMP3BankLoader::UpdateVirtualChannels(
        CAEMP3BankLoader *this,
        tVirtualChannelSettings *pSettings,
        Int16 *pSoundLengths,
        Int16 *pLoopTimes)
{
  int v7; // r4
  unsigned int v8; // r1
  int v9; // r2
  int v10; // r6
  bool v11; // nf
  CAEMP3BankLoader::LoadedBankData *dataPtr; // r3
  unsigned int v13; // r2
  CAEMP3BankLoader::LoadedBankData *v14; // r12
  int singleSound; // r5
  bool v16; // zf
  unsigned int v17; // r3
  UInt32 *v18; // r5
  CAEMP3BankLoader::LoadedBankData *v19; // r2
  int v20; // r3
  SoundData *v21; // r2
  SoundData *v22; // r1
  signed int LoopStartOffset; // r0
  CAEMP3BankLoader *v24; // [sp+0h] [bp-20h]

  v7 = 0;
  v24 = this;
  do
  {
    v8 = (unsigned int)&pSettings->BankSlotIDs[v7];
    v9 = *(__int16 *)v8;
    v10 = *(unsigned __int16 *)(v8 + 600);
    v11 = v9 < 0;
    pSoundLengths[v7] = -1;
    pLoopTimes[v7] = -1;
    if ( v9 >= 0 )
    {
      v8 = (__int16)v10;
      v11 = (v10 & 0x8000u) != 0;
    }
    if ( !v11 )
    {
      dataPtr = this->bankSlots.dataPtr;
      v13 = v9;
      if ( dataPtr[v13].Bank != 0xFFFF )
      {
        v14 = &dataPtr[v13];
        singleSound = v14->singleSound;
        v16 = singleSound == 0xFFFF;
        if ( singleSound != 0xFFFF )
          v16 = singleSound == v8;
        if ( v16 && (singleSound != 0xFFFF || v14->sounds.numEntries > v8) )
        {
          v17 = 0;
          if ( singleSound == 0xFFFF )
            v17 = v8;
          v18 = (UInt32 *)&v14->sounds.dataPtr[v17];
          pSoundLengths[v7] = v18[3];
          if ( v18[5] != -1 )
          {
            if ( this->m_bInitialised )
            {
              v19 = &this->bankSlots.dataPtr[v13];
              v20 = v19->singleSound;
              v21 = v19->sounds.dataPtr;
              if ( v20 == (unsigned __int16)v8 )
                v10 = 0;
              v22 = &v21[v10];
              LoopStartOffset = v22->info.LoopStartOffset;
              if ( LoopStartOffset >= 1 )
                LoopStartOffset = LoopStartOffset * v22->frequency / v22->info.Frequency;
            }
            else
            {
              LoopStartOffset = -1;
            }
            pLoopTimes[v7] = CAEAudioUtility::ConvertFromBytesToMS(LoopStartOffset, v18[1], 1u);
            this = v24;
          }
        }
      }
    }
    ++v7;
  }
  while ( v7 != 300 );
}

//----- (0027E744) --------------------------------------------------------
void __fastcall OSArray<BankData>::~OSArray(OSArray<BankData> *this)
{
  BankData *dataPtr; // r0

  dataPtr = this->dataPtr;
  this->numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->dataPtr = 0;
  }
  this->numAlloced = 0;
}

//----- (0027E75E) --------------------------------------------------------
void __fastcall OSArray<LoadTask *>::~OSArray(OSArray<LoadTask *> *this)
{
  LoadTask **dataPtr; // r0

  dataPtr = this->dataPtr;
  this->numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->dataPtr = 0;
  }
  this->numAlloced = 0;
}

//----- (0027E778) --------------------------------------------------------
void __fastcall LoadTask::Load(LoadTask *this)
{
  int soundId; // r1
  unsigned int v3; // r5
  unsigned int v4; // r10
  SoundData *v5; // r0
  SoundData *v6; // r9
  SoundData *v7; // r6
  int v8; // r5
  bool *v9; // r9
  unsigned int numEntries; // r11
  bool *v11; // r6
  unsigned int v12; // r10
  SoundData *v13; // r0
  SoundData *v14; // r9
  SoundData *dataPtr; // r8
  __int64 v16; // d17
  SoundData *v17; // r0
  __int64 v18; // d18
  __int64 v19; // d19
  __int64 v20; // d17
  SoundData *v21; // r0
  __int64 v22; // d18
  __int64 v23; // d19
  SoundData v24[2]; // [sp+0h] [bp-38h] BYREF

  soundId = this->soundId;
  if ( soundId == -1 )
  {
    v8 = 0;
    v9 = &killLoaderThread;
    do
    {
      if ( !LoadTask::TryLoadSound(this, v8, v24) )
        break;
      numEntries = this->result.numEntries;
      if ( this->result.numAlloced >= numEntries + 1 )
      {
        dataPtr = this->result.dataPtr;
      }
      else
      {
        v11 = v9;
        v12 = 4 * (numEntries + 1) / 3 + 3;
        v13 = (SoundData *)malloc(28 * v12);
        v14 = this->result.dataPtr;
        dataPtr = v13;
        if ( v14 )
        {
          qmemcpy(v13, this->result.dataPtr, 28 * numEntries);
          free(v14);
          numEntries = this->result.numEntries;
        }
        v9 = v11;
        this->result.dataPtr = dataPtr;
        this->result.numAlloced = v12;
      }
      v16 = *(_QWORD *)&v24[0].channels;
      ++v8;
      v17 = &dataPtr[numEntries];
      v18 = *(_QWORD *)&v24[0].length;
      v19 = *(_QWORD *)&v24[0].info.LoopStartOffset;
      *(_QWORD *)&v17->buffer = *(_QWORD *)&v24[0].buffer;
      *(_QWORD *)&v17->channels = v16;
      v17 = (SoundData *)((char *)v17 + 12);
      *(_QWORD *)&v17->buffer = v18;
      *(_QWORD *)&v17->channels = v19;
      ++this->result.numEntries;
    }
    while ( !*v9 );
  }
  else
  {
    LoadTask::TryLoadSound(this, soundId, v24);
    v3 = this->result.numEntries;
    if ( this->result.numAlloced >= v3 + 1 )
    {
      v7 = this->result.dataPtr;
    }
    else
    {
      v4 = 4 * (v3 + 1) / 3 + 3;
      v5 = (SoundData *)malloc(28 * v4);
      v6 = this->result.dataPtr;
      v7 = v5;
      if ( v6 )
      {
        qmemcpy(v5, this->result.dataPtr, 28 * v3);
        free(v6);
        v3 = this->result.numEntries;
      }
      this->result.dataPtr = v7;
      this->result.numAlloced = v4;
    }
    v20 = *(_QWORD *)&v24[0].channels;
    v21 = &v7[v3];
    v22 = *(_QWORD *)&v24[0].length;
    v23 = *(_QWORD *)&v24[0].info.LoopStartOffset;
    *(_QWORD *)&v21->buffer = *(_QWORD *)&v24[0].buffer;
    *(_QWORD *)&v21->channels = v20;
    v21 = (SoundData *)((char *)v21 + 12);
    *(_QWORD *)&v21->buffer = v22;
    *(_QWORD *)&v21->channels = v23;
    ++this->result.numEntries;
  }
}

//----- (0027E8C4) --------------------------------------------------------
bool __fastcall LoadTask::TryLoadSound(LoadTask *this, int idx, SoundData *intoSound)
{
  _BOOL4 v4; // r11
  unsigned int *p_length; // r9
  UInt32 *p_frequency; // r6
  int v7; // r8
  int bankId; // r0
  int v9; // r4
  int v10; // r10
  int v11; // r4
  int v12; // r0
  ZIPFile *fromZIP; // r10
  ZIPFile *v14; // r0
  SoundData *v15; // r6
  size_t length; // r8
  char *v17; // r0
  int v18; // r2
  char *v19; // r4
  unsigned int *v20; // r10
  char *v21; // r0
  SoundData *v22; // r8
  unsigned int v23; // r1
  unsigned int v24; // r6
  int LoopStartOffset; // r8
  unsigned int v26; // r5
  __int16 *v27; // r4
  __int64 v28; // kr00_8
  unsigned int v29; // r6
  OALBuffer *v30; // r0
  __int16 *v31; // r3
  unsigned int v32; // r2
  OALBuffer *v33; // r0
  int v34; // r0
  int v35; // t1
  __int16 v36; // t1
  int v37; // r2
  __int16 *v38; // r0
  __int16 *v39; // r0
  __int16 v40; // t1
  OALBuffer *v41; // r0
  unsigned int *freq; // [sp+0h] [bp-148h]
  void *v44; // [sp+Ch] [bp-13Ch]
  __int16 *p; // [sp+10h] [bp-138h]
  unsigned int *v47; // [sp+18h] [bp-130h]
  UInt32 *channels; // [sp+1Ch] [bp-12Ch]
  unsigned int finalSize; // [sp+24h] [bp-124h] BYREF
  unsigned __int8 s[256]; // [sp+28h] [bp-120h] BYREF

  LOBYTE(v4) = 0;
  intoSound->buffer = 0;
  p_length = &intoSound->length;
  intoSound->length = 0;
  intoSound->frequency = 0;
  p_frequency = &intoSound->frequency;
  intoSound->channels = 1;
  if ( !this->fromZIP )
  {
    if ( bankInfo.dataPtr[this->bankId].numSounds > idx )
      LOBYTE(v4) = 1;
    return v4;
  }
  v7 = -690;
  bankId = this->bankId;
  v9 = -690;
  channels = &intoSound->channels;
  if ( bankId > 689 )
    goto LABEL_18;
  if ( bankId > 637 )
  {
    v9 = -638;
LABEL_18:
    bankId += v9;
    goto LABEL_19;
  }
  if ( bankId > 428 )
  {
    v9 = -429;
    goto LABEL_18;
  }
  if ( bankId > 410 )
  {
    v9 = -411;
    goto LABEL_18;
  }
  if ( bankId > 364 )
  {
    v9 = -365;
    goto LABEL_18;
  }
  if ( bankId > 146 )
  {
    v9 = -147;
    goto LABEL_18;
  }
  if ( bankId > 143 )
  {
    v9 = -144;
    goto LABEL_18;
  }
  if ( bankId > 6 )
    bankId -= 7;
LABEL_19:
  v10 = idx + 1;
  snprintf(s, 0x100u, "Bank_%03d/sound_%03d.mp3", bankId + 1, idx + 1);
  v11 = ((int (__fastcall *)(ZIPFile *, unsigned __int8 *))*this->fromZIP->_vptr$ZIPFile)(this->fromZIP, s);
  v47 = p_frequency;
  if ( v11 != -1 )
  {
    v4 = 1;
    goto LABEL_39;
  }
  v12 = this->bankId;
  if ( v12 > 689 )
    goto LABEL_37;
  if ( v12 > 637 )
  {
    v7 = -638;
LABEL_37:
    v12 += v7;
    goto LABEL_38;
  }
  if ( v12 > 428 )
  {
    v7 = -429;
    goto LABEL_37;
  }
  if ( v12 > 410 )
  {
    v7 = -411;
    goto LABEL_37;
  }
  if ( v12 > 364 )
  {
    v7 = -365;
    goto LABEL_37;
  }
  if ( v12 > 146 )
  {
    v7 = -147;
    goto LABEL_37;
  }
  if ( v12 > 143 )
  {
    v7 = -144;
    goto LABEL_37;
  }
  if ( v12 > 6 )
    v12 -= 7;
LABEL_38:
  snprintf(s, 0x100u, "Bank_%03d/sound_%03d.wav", v12 + 1, v10);
  v11 = ((int (__fastcall *)(ZIPFile *, unsigned __int8 *))*this->fromZIP->_vptr$ZIPFile)(this->fromZIP, s);
  v4 = 0;
  if ( v11 != -1 )
  {
LABEL_39:
    fromZIP = this->fromZIP;
    v14 = LoadTask::lastZIP;
    if ( LoadTask::lastZIP == fromZIP )
    {
      v15 = intoSound;
    }
    else
    {
      v15 = intoSound;
      if ( LoadTask::lastHandle )
      {
        OS_FileClose(LoadTask::lastHandle);
        fromZIP = this->fromZIP;
      }
      OS_FileOpen(OSFDA_Storage_0, &LoadTask::lastHandle, fromZIP->filename, OSFAT_Read_0);
      fromZIP = this->fromZIP;
      LoadTask::lastZIP = fromZIP;
      v14 = fromZIP;
    }
    length = v14->entries.dataPtr[v11].length;
    if ( !length )
      goto LABEL_71;
    LoadTask::lastZIP = fromZIP;
    v17 = (char *)malloc(length);
    v18 = v11;
    v19 = v17;
    ZIPFile::ReadExisting(fromZIP, LoadTask::lastHandle, v18, v17, length);
    finalSize = 0;
    v44 = v19;
    if ( v4 )
    {
      v20 = v47;
      v21 = CAEMP3Decoder::DecodeEntireFile((unsigned __int8 *)v19, length, &finalSize, channels, v47, p_length);
    }
    else
    {
      v22 = v15;
      *channels = 1;
      v20 = v47;
      v23 = *((_DWORD *)v19 + 6);
      *v47 = v23;
      v24 = *((_DWORD *)v19 + 10);
      *p_length = 500 * v24 / v23;
      v21 = v19 + 44;
      finalSize = v24;
      v15 = v22;
    }
    p = (__int16 *)v21;
    CFileMgr::Seek(soundInfoFile, bankInfo.dataPtr[this->bankId].soundInfoOffset + 12 * idx, 0);
    OS_FileRead((OSFile)soundInfoFile, &v15->info, 12);
    LoopStartOffset = v15->info.LoopStartOffset;
    v26 = finalSize;
    if ( v4 )
    {
      if ( LoopStartOffset <= -1 && *p_length >> 3 > 0x7C )
      {
        v27 = p;
        goto LABEL_67;
      }
      v34 = *p;
      v27 = p;
      if ( v34 >= -2047 )
      {
        do
        {
          if ( v26 <= 0x400 )
            break;
          if ( (__int16)v34 >= 2048 )
            break;
          v35 = v27[1];
          ++v27;
          LOWORD(v34) = v35;
          v26 -= 2;
        }
        while ( v35 > -2048 );
      }
      if ( v27[1] * (__int16)v34 >= 1 )
      {
        do
        {
          v36 = *--v27;
          v26 += 2;
          v37 = (__int16)v34 * v36;
          LOWORD(v34) = v36;
        }
        while ( v37 > 0 );
      }
      if ( v26 > 0x400 )
      {
        v38 = &v27[v26 >> 1];
        if ( (unsigned __int16)(*(v38 - 1) + 2047) <= 0xFFEu )
        {
          v39 = v38 - 2;
          do
          {
            v26 -= 2;
            if ( v26 <= 0x400 )
              break;
            v40 = *v39--;
          }
          while ( (unsigned __int16)(v40 + 2047) < 0xFFFu );
        }
      }
      *p_length = 500 * v26 / *v20;
      if ( LoopStartOffset < 1 )
        goto LABEL_67;
    }
    else
    {
      v27 = p;
      if ( LoopStartOffset < 1 )
      {
LABEL_67:
        v41 = (OALBuffer *)operator new(0x14u);
        OALBuffer::OALBuffer(v41, v27, v26, *v20, *channels);
        goto LABEL_68;
      }
    }
    v28 = *(_QWORD *)&v15->frequency;
    v29 = HIDWORD(v28) * ((int)v28 * LoopStartOffset / (unsigned int)v15->info.Frequency);
    v30 = (OALBuffer *)operator new(0x14u);
    v31 = &v27[v29];
    freq = (unsigned int *)(v26 - 2 * v29);
    v32 = 2 * v29;
    v15 = intoSound;
    OALBuffer::OALBuffer(v30, v27, v32, v31, (unsigned int)freq, v28, HIDWORD(v28));
LABEL_68:
    v15->buffer = v33;
    if ( v4 )
      free(p);
    free(v44);
LABEL_71:
    LOBYTE(v4) = 1;
  }
  return v4;
}
// 27EB58: conditional instruction was optimized away because r8.4<0
// 27EC4A: variable 'v33' is possibly undefined

//----- (0027ECF0) --------------------------------------------------------
void __fastcall CAEMP3Decoder::CAEMP3Decoder(CAEMP3Decoder *this, CAEDataStream *stream, bool bEnforceMinLength)
{
  CAEStreamingDecoder::CAEStreamingDecoder(this, stream);
  *(_QWORD *)&this->length = 0LL;
  *(_QWORD *)&this->frameSize = 0LL;
  this->m_bInitialised = 0;
  this->m_bEnforceMinLength = bEnforceMinLength;
  *(_QWORD *)&this->rate = 0LL;
  *(_QWORD *)&this->encoding = 0LL;
  this->m_pStream = stream;
  this->_vptr$CAEStreamingDecoder = (int (**)(void))&off_661F58;
  this->dataBuffer = (unsigned __int8 *)malloc(0x4000u);
}
// 661F58: using guessed type void *;

//----- (0027ED40) --------------------------------------------------------
void __fastcall CAEMP3Decoder::~CAEMP3Decoder(CAEMP3Decoder *this)
{
  mpg123_handle *mh; // r0
  unsigned __int8 *dataBuffer; // r0
  CAEDataStream *m_pStream; // r0
  bool v5; // zf

  mh = this->mh;
  this->_vptr$CAEStreamingDecoder = (int (**)(void))&off_661F58;
  if ( mh )
  {
    j_mpg123_delete(mh);
    this->mh = 0;
  }
  dataBuffer = this->dataBuffer;
  if ( dataBuffer )
  {
    free(dataBuffer);
    this->dataBuffer = 0;
  }
  m_pStream = this->m_pStream;
  v5 = m_pStream == 0;
  if ( m_pStream )
  {
    m_pStream = (CAEDataStream *)m_pStream->m_pHeader;
    v5 = m_pStream == 0;
  }
  if ( !v5 )
  {
    operator delete(m_pStream);
    this->m_pStream->m_pHeader = 0;
  }
  sub_19D89C(this);
}
// 661F58: using guessed type void *off_661F58;

//----- (0027ED8C) --------------------------------------------------------
void __fastcall CAEMP3Decoder::~CAEMP3Decoder(CAEMP3Decoder *this)
{
  mpg123_handle *mh; // r0
  unsigned __int8 *dataBuffer; // r0
  CAEDataStream *m_pStream; // r0
  bool v5; // zf
  void *v6; // r0

  mh = this->mh;
  this->_vptr$CAEStreamingDecoder = (int (**)(void))&off_661F58;
  if ( mh )
  {
    j_mpg123_delete(mh);
    this->mh = 0;
  }
  dataBuffer = this->dataBuffer;
  if ( dataBuffer )
  {
    free(dataBuffer);
    this->dataBuffer = 0;
  }
  m_pStream = this->m_pStream;
  v5 = m_pStream == 0;
  if ( m_pStream )
  {
    m_pStream = (CAEDataStream *)m_pStream->m_pHeader;
    v5 = m_pStream == 0;
  }
  if ( !v5 )
  {
    operator delete(m_pStream);
    this->m_pStream->m_pHeader = 0;
  }
  CAEStreamingDecoder::~CAEStreamingDecoder(this);
  sub_191374(v6);
}
// 27EDD4: variable 'v6' is possibly undefined
// 661F58: using guessed type void *off_661F58;

//----- (0027EDDC) --------------------------------------------------------
char *__fastcall CAEMP3Decoder::DecodeEntireFile(
        unsigned __int8 *data,
        unsigned int size,
        unsigned int *finalSize,
        unsigned int *channels,
        unsigned int *freq,
        unsigned int *msLength)
{
  char *v10; // r5
  mpg123_handle *v11; // r11
  int v12; // r3
  unsigned int v13; // r4
  unsigned int v14; // r8
  size_t v15; // r9
  unsigned int v16; // r10
  mpg123_handle *v17; // r6
  char *v18; // r11
  unsigned int *v20; // [sp+Ch] [bp-4034h]
  size_t v21; // [sp+10h] [bp-4030h] BYREF
  int encoding; // [sp+14h] [bp-402Ch] BYREF
  unsigned __int8 out[16388]; // [sp+18h] [bp-4028h] BYREF

  v10 = 0;
  v11 = j_mpg123_new(0, 0);
  j_mpg123_param(v11, MPG123_ADD_FLAGS, 32, v12, 0.0);
  j_mpg123_format_all(v11);
  if ( !j_mpg123_open_feed(v11) )
  {
    j_mpg123_feed(v11, data, size);
    if ( j_mpg123_getformat(v11, (int *)freq, (int *)channels, &encoding) )
    {
      return 0;
    }
    else
    {
      v20 = finalSize;
      v13 = 6 * size;
      v10 = (char *)malloc(6 * size);
      v14 = 0;
      while ( 1 )
      {
        j_mpg123_read(v11, out, 0x4000u, &v21);
        v15 = v21;
        if ( !v21 )
          break;
        v16 = v21 + v14;
        if ( v21 + v14 > v13 )
        {
          v13 = (3 * v16) >> 1;
          v17 = v11;
          v18 = (char *)malloc(v13);
          qmemcpy(v18, v10, v14);
          free(v10);
          v10 = v18;
          v11 = v17;
        }
        qmemcpy(&v10[v14], out, v15);
        v14 += v15;
        if ( !v21 )
          goto LABEL_11;
      }
      v16 = v14;
LABEL_11:
      j_mpg123_delete(v11);
      *v20 = v16;
      *msLength = 500 * v16 / *freq;
    }
  }
  return v10;
}
// 27EE12: variable 'v12' is possibly undefined

//----- (0027EF04) --------------------------------------------------------
int __fastcall CAEMP3Decoder::FillBuffer(CAEMP3Decoder *this, void *dest, unsigned int destSize, int *done)
{
  unsigned int v8; // r5
  __int64 v9; // kr00_8
  int frameSize; // r2
  size_t v11; // r2
  size_t v13[7]; // [sp+4h] [bp-1Ch] BYREF

  OS_TimeMS();
  v8 = 0;
  *done = 0;
  if ( destSize )
  {
    v8 = 0;
    do
    {
      v9 = *(_QWORD *)&this->frameSize;
      frameSize = destSize - v8;
      if ( (int)v9 < (int)(destSize - v8) )
        frameSize = this->frameSize;
      if ( j_mpg123_read((mpg123_handle *)HIDWORD(v9), (unsigned __int8 *)dest, frameSize, v13) == -10 )
      {
        v11 = CAEDataStream::FillBuffer(this->m_pStream, this->dataBuffer, 0x4000u);
        if ( !v11 )
          goto LABEL_12;
        j_mpg123_feed(this->mh, this->dataBuffer, v11);
      }
      else
      {
        if ( !v13[0] )
        {
LABEL_12:
          *done = 1;
          break;
        }
        dest = (char *)dest + v13[0];
        v8 += v13[0];
      }
    }
    while ( v8 < destSize );
  }
  this->streamedTime += 1000 * (v8 >> 1) / (this->channels * this->mi.rate);
  return v8;
}
// 27EF04: using guessed type size_t var_1C[7];

//----- (0027EF92) --------------------------------------------------------
unsigned int __fastcall CAEMP3Decoder::Feed(CAEMP3Decoder *this, unsigned int numBytes)
{
  size_t v3; // r5

  v3 = CAEDataStream::FillBuffer(this->m_pStream, this->dataBuffer, numBytes);
  if ( v3 )
    j_mpg123_feed(this->mh, this->dataBuffer, v3);
  return v3;
}

//----- (0027EFB8) --------------------------------------------------------
bool __fastcall CAEMP3Decoder::Initialise(CAEMP3Decoder *this)
{
  bool v2; // r5
  mpg123_handle *v3; // r0
  int v4; // r3
  size_t v5; // r2
  int rate; // r0
  bool v8; // zf
  double v9; // d16
  mpg123_handle *mh; // r0

  v2 = 0;
  if ( this->m_pStream )
  {
    v3 = j_mpg123_new(0, 0);
    this->mh = v3;
    j_mpg123_param(v3, MPG123_ADD_FLAGS, 32, v4, 0.0);
    j_mpg123_format_all(this->mh);
    if ( !j_mpg123_open_feed(this->mh) )
    {
      v5 = CAEDataStream::FillBuffer(this->m_pStream, this->dataBuffer, 0x1400u);
      if ( v5 )
        j_mpg123_feed(this->mh, this->dataBuffer, v5);
      if ( j_mpg123_getformat(this->mh, &this->rate, &this->channels, &this->encoding)
        || j_mpg123_info(this->mh, &this->mi) )
      {
        return 0;
      }
      rate = this->mi.rate;
      v8 = rate == 44100;
      if ( rate == 44100 )
        v8 = this->mi.bitrate == 32;
      if ( v8 )
      {
        return 0;
      }
      else
      {
        j_mpg123_set_filesize(this->mh, this->m_pStream->m_size);
        v9 = (double)j_mpg123_length(this->mh) / (double)this->mi.rate * 1000.0 + -500.0;
        if ( v9 <= 200.0 )
          v9 = 200.0;
        mh = this->mh;
        this->length = (int)v9;
        v2 = 1;
        this->frameSize = j_mpg123_outblock(mh);
        this->m_bInitialised = 1;
      }
    }
  }
  return v2;
}
// 27EFD8: variable 'v4' is possibly undefined

//----- (0027F0B0) --------------------------------------------------------
int __fastcall CAEMP3Decoder::GetSampleRate(CAEMP3Decoder *this)
{
  if ( this->m_bInitialised )
    return this->rate;
  else
    return -1;
}

//----- (0027F0BE) --------------------------------------------------------
int __fastcall CAEMP3Decoder::GetStreamLengthMs(CAEMP3Decoder *this)
{
  if ( this->m_bInitialised )
    return this->length;
  else
    return -1;
}

//----- (0027F0CC) --------------------------------------------------------
int __fastcall CAEMP3Decoder::GetStreamPlayTimeMs(CAEMP3Decoder *this)
{
  if ( this->m_bInitialised )
    return this->streamedTime;
  else
    return -1;
}

//----- (0027F0DA) --------------------------------------------------------
void __fastcall CAEMP3Decoder::SetCursor(CAEMP3Decoder *this, unsigned int ms)
{
  __int64 v3; // r0
  off_t input_offset[3]; // [sp+4h] [bp-Ch] BYREF

  if ( this->m_bInitialised )
  {
    v3 = 274877907LL * this->mi.rate * ms;
    input_offset[0] = 0;
    if ( j_mpg123_feedseek(this->mh, HIDWORD(v3) >> 6, 0, input_offset) >= 0 )
      CAEDataStream::Seek(this->m_pStream, input_offset[0], 0);
  }
}
// 27F0DA: using guessed type off_t input_offset[3];

//----- (0027F118) --------------------------------------------------------
int __fastcall CAEMP3Decoder::GetStreamID(CAEMP3Decoder *this)
{
  return this->m_pStream->m_ID;
}

//----- (0027F11E) --------------------------------------------------------
void *__fastcall CAEStreamingDecoder::GetHeader(CAEStreamingDecoder *this)
{
  CAEDataStream *m_pStream; // r0

  m_pStream = this->m_pStream;
  if ( m_pStream )
    return m_pStream->m_pHeader;
  else
    return 0;
}

//----- (0027F12E) --------------------------------------------------------
void __fastcall CAEMP3TrackLoader::CAEMP3TrackLoader(CAEMP3TrackLoader *this)
{
  this->m_bInitialised = 0;
  this->zipFiles.numAlloced = 0;
  this->zipFiles.numEntries = 0;
  this->zipFiles.dataPtr = 0;
}

//----- (0027F13A) --------------------------------------------------------
void __fastcall CAEMP3TrackLoader::~CAEMP3TrackLoader(CAEMP3TrackLoader *this)
{
  ZIPFile **dataPtr; // r0

  if ( this->m_bInitialised )
  {
    CMemoryMgr::Free(this->m_pTrackLookupTable);
    CMemoryMgr::Free(this->m_pStreamPackTable);
    CFileMgr::CloseFile(this->headerFile);
    this->headerFile = 0;
  }
  dataPtr = this->zipFiles.dataPtr;
  this->zipFiles.numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->zipFiles.dataPtr = 0;
  }
  this->zipFiles.numAlloced = 0;
}

//----- (0027F170) --------------------------------------------------------
bool __fastcall CAEMP3TrackLoader::Initialise(CAEMP3TrackLoader *this)
{
  _BOOL4 StreamPackTable; // r1
  bool result; // r0
  unsigned int v4; // r5
  tTrackLookup *v5; // r0
  u_native v6; // r0
  OSFile intoFile; // [sp+4h] [bp-Ch] BYREF

  StreamPackTable = CAEMP3TrackLoader::LoadStreamPackTable(this);
  result = 0;
  if ( StreamPackTable )
  {
    intoFile = 0;
    if ( OS_FileOpen(OSFDA_Storage_0, &intoFile, "AUDIO\\CONFIG\\TRAKLKUP.DAT", OSFAT_Read_0) )
      return 0;
    v4 = OS_FileSize(intoFile);
    v5 = (tTrackLookup *)CMemoryMgr::Malloc(v4);
    this->m_pTrackLookupTable = v5;
    OS_FileRead(intoFile, v5, v4);
    OS_FileClose(intoFile);
    this->m_numTracks = v4 / 0xC;
    v6 = CFileMgr::OpenFile("AUDIO/CONFIG/TRKHEAD.DAT", "rb");
    this->headerFile = v6;
    if ( !v6 )
    {
      return 0;
    }
    else
    {
      result = 1;
      this->m_bInitialised = 1;
    }
  }
  return result;
}

//----- (0027F204) --------------------------------------------------------
bool __fastcall CAEMP3TrackLoader::LoadStreamPackTable(CAEMP3TrackLoader *this)
{
  bool v2; // r5
  unsigned int v3; // r5
  tStreamPackFile *v4; // r0
  unsigned int numAlloced; // r1
  unsigned int numEntries; // r6
  unsigned int v7; // r0
  unsigned int v8; // r9
  unsigned int v9; // r10
  ZIPFile **v10; // r0
  ZIPFile **v11; // r8
  ZIPFile **dataPtr; // r5
  __int64 v13; // r0
  unsigned int v14; // r6
  ZIPFile **v15; // r0
  ZIPFile **v16; // r5
  ZIPFile **v17; // r8
  OSFile intoFile; // [sp+4h] [bp-1Ch] BYREF

  v2 = 0;
  intoFile = 0;
  if ( OS_FileOpen(OSFDA_Storage_0, &intoFile, "AUDIO\\CONFIG\\STRMPAKS.DAT", OSFAT_Read_0) == OSFE_NoError )
  {
    v3 = OS_FileSize(intoFile);
    v4 = (tStreamPackFile *)CMemoryMgr::Malloc(v3);
    this->m_pStreamPackTable = v4;
    OS_FileRead(intoFile, v4, v3);
    OS_FileClose(intoFile);
    numEntries = this->zipFiles.numEntries;
    numAlloced = this->zipFiles.numAlloced;
    v7 = numEntries + (v3 >> 4);
    v8 = v3 >> 4;
    this->m_numPacks = v3 >> 4;
    if ( numAlloced >= v7 )
    {
      dataPtr = this->zipFiles.dataPtr;
    }
    else
    {
      v9 = 4 * v7 / 3 + 3;
      v10 = (ZIPFile **)malloc(4 * v9);
      v11 = this->zipFiles.dataPtr;
      dataPtr = v10;
      if ( v11 )
      {
        qmemcpy(v10, this->zipFiles.dataPtr, 4 * numEntries);
        free(v11);
        numEntries = this->zipFiles.numEntries;
      }
      this->zipFiles.dataPtr = dataPtr;
      this->zipFiles.numAlloced = v9;
    }
    memset(&dataPtr[numEntries], 0, 4 * v8);
    v13 = *(_QWORD *)&this->zipFiles.numAlloced;
    v14 = HIDWORD(v13) + v8;
    this->zipFiles.numEntries = HIDWORD(v13) + v8;
    if ( (_DWORD)v13 != HIDWORD(v13) + v8 )
    {
      v15 = (ZIPFile **)malloc(4 * v14);
      v16 = this->zipFiles.dataPtr;
      v17 = v15;
      if ( v16 )
      {
        qmemcpy(v15, this->zipFiles.dataPtr, 4 * v14);
        free(v16);
      }
      this->zipFiles.dataPtr = v17;
      this->zipFiles.numAlloced = v14;
    }
    return 1;
  }
  return v2;
}

//----- (0027F304) --------------------------------------------------------
bool __fastcall CAEMP3TrackLoader::LoadTrackLookupTable(CAEMP3TrackLoader *this)
{
  bool v2; // r5
  int v3; // r5
  tTrackLookup *v4; // r0
  __int64 v5; // r0
  OSFile intoFile; // [sp+4h] [bp-Ch] BYREF

  v2 = 0;
  intoFile = 0;
  if ( OS_FileOpen(OSFDA_Storage_0, &intoFile, "AUDIO\\CONFIG\\TRAKLKUP.DAT", OSFAT_Read_0) == OSFE_NoError )
  {
    v3 = OS_FileSize(intoFile);
    v4 = (tTrackLookup *)CMemoryMgr::Malloc(v3);
    this->m_pTrackLookupTable = v4;
    OS_FileRead(intoFile, v4, v3);
    OS_FileClose(intoFile);
    v5 = 2863311531LL * (unsigned int)v3;
    v2 = 1;
    this->m_numTracks = HIDWORD(v5) >> 3;
  }
  return v2;
}

//----- (0027F35C) --------------------------------------------------------
CAEDataStream *__fastcall CAEMP3TrackLoader::GetDataStream(CAEMP3TrackLoader *this, unsigned int TrackID)
{
  __int64 v4; // kr00_8
  CAEDataStream *v5; // r5
  unsigned int v6; // r0
  tStreamPackFile *m_pStreamPackTable; // r4
  unsigned __int8 *v8; // r10
  size_t v9; // r0
  char *v10; // r11
  int v11; // r0
  ZIPFile *v12; // r1
  unsigned int m_numTracks; // r1
  unsigned int v14; // r6
  unsigned int *p_FileOffset; // r4
  int v16; // r3
  int v17; // r0
  ZIPFile::ZipEntry *dataPtr; // r1
  int v19; // r0
  int offset; // r4
  int size; // r6
  tTrackHeader *v22; // r10
  unsigned int v23; // r2
  tTrackHeader *v24; // r3
  int v25; // r1
  tBeatInfoBeat v26; // kr08_8
  _QWORD *v27; // r6
  int v28; // r6
  void *v29; // r0
  int v31; // r2
  unsigned int v32; // r12
  int v33; // r1
  _QWORD *v34; // r6
  unsigned int v35; // r3
  _QWORD *v36; // r4
  _QWORD *v37; // r6
  _QWORD *v38; // r6
  ZIPFile *v39; // [sp+Ch] [bp-1FACh]
  _QWORD v40[1000]; // [sp+10h] [bp-1FA8h] BYREF
  unsigned __int8 s[8]; // [sp+1F54h] [bp-64h] BYREF

  if ( this->m_numTracks <= TrackID )
    return 0;
  v4 = *(_QWORD *)&this->m_numPacks;
  v5 = 0;
  v6 = *(unsigned __int8 *)(HIDWORD(v4) + 12 * TrackID);
  if ( (unsigned int)v4 >= v6 )
  {
    m_pStreamPackTable = this->m_pStreamPackTable;
    v8 = (unsigned __int8 *)(HIDWORD(v4) + 12 * TrackID);
    v9 = strlen((const char *)&m_pStreamPackTable[v6]);
    v10 = (char *)operator new[](v9 + 25);
    strcpy(v10, "AUDIO\\STREAMS\\");
    strcat(v10, (const char *)&m_pStreamPackTable[*v8]);
    strcat(v10, ".osw");
    v11 = *v8;
    v12 = this->zipFiles.dataPtr[v11];
    if ( !v12 )
    {
      this->zipFiles.dataPtr[*v8] = ZIP_FileCreate((const unsigned __int8 *)v10);
      v11 = *v8;
      v12 = this->zipFiles.dataPtr[v11];
    }
    v39 = v12;
    m_numTracks = this->m_numTracks;
    if ( m_numTracks )
    {
      v14 = 0;
      p_FileOffset = &this->m_pTrackLookupTable->FileOffset;
      v16 = 0;
      do
      {
        if ( *((unsigned __int8 *)p_FileOffset - 4) == v11 && *p_FileOffset <= *((_DWORD *)v8 + 1) )
          ++v16;
        ++v14;
        p_FileOffset += 3;
      }
      while ( v14 < m_numTracks );
    }
    else
    {
      v16 = 0;
    }
    snprintf(s, 0x40u, "Track_%03d.mp3", v16);
    v17 = (*(int (__fastcall **)(ZIPFile *, unsigned __int8 *))v39->_vptr$ZIPFile)(v39, s);
    if ( v17 != -1 )
    {
      dataPtr = v39->entries.dataPtr;
      v19 = v17;
      offset = dataPtr[v19].offset;
      size = dataPtr[v19].length;
      v5 = (CAEDataStream *)operator new(0x28u);
      CAEDataStream::CAEDataStream(v5, TrackID, (unsigned __int8 *)v10, offset, size, 0);
      CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
      if ( CAEDataStream::Initialise(v5) )
      {
        v22 = (tTrackHeader *)operator new(0x1F84u);
        CFileMgr::Seek(this->headerFile, 8068 * TrackID, 0);
        OS_FileRead((OSFile)this->headerFile, v22, 8068);
        if ( !v22->BeatInfoList[0].Type )
        {
LABEL_35:
          v5->m_pHeader = v22;
          CAEDataStream::Seek(v5, 0, 0);
          return v5;
        }
        v23 = 0;
        v24 = v22;
        v25 = 0;
        while ( v24->BeatInfoList[0].Type != 33 )
        {
          if ( !(v23 << 31) )
          {
            v26 = v24->BeatInfoList[0];
            LODWORD(v40[v25]) = v24->BeatInfoList[0].Time;
            v27 = &v40[v25++];
            *((_DWORD *)v27 + 1) = v26.Type;
          }
          ++v23;
          v24 = (tTrackHeader *)((char *)v24 + 8);
          if ( v23 >= 0x3E8 )
          {
            v28 = 0;
            goto LABEL_26;
          }
        }
        v28 = v25 + 1;
        v40[v25] = v24->BeatInfoList[0];
        if ( (unsigned int)(v25 + 1) >= 0x3E8 )
          goto LABEL_34;
LABEL_26:
        v31 = 1000 - v28;
        if ( (unsigned int)(1000 - v28) >= 4 && (v32 = v31 & 0xFFFFFFFC, (v31 & 0xFFFFFFFC) != 0) )
        {
          v33 = v28 + v32;
          v34 = &v40[v28];
          v35 = v31 & 0xFFFFFFFC;
          do
          {
            v36 = v34 + 4;
            *v34 = 0xFFFFFFFFLL;
            v34[1] = 0xFFFFFFFFLL;
            v37 = v34 + 2;
            v35 -= 4;
            *v37 = 0xFFFFFFFFLL;
            v37[1] = 0xFFFFFFFFLL;
            v34 = v36;
          }
          while ( v35 );
          if ( v31 == v32 )
            goto LABEL_34;
        }
        else
        {
          v33 = v28;
        }
        do
        {
          LODWORD(v40[v33]) = -1;
          v38 = &v40[v33++];
          *((_DWORD *)v38 + 1) = 0;
        }
        while ( v33 != 1000 );
LABEL_34:
        qmemcpy(v22, v40, 0x1F40u);
        goto LABEL_35;
      }
      CAEDataStream::~CAEDataStream(v5);
      operator delete(v29);
    }
    return 0;
  }
  return v5;
}
// 27F510: variable 'v29' is possibly undefined
// 61CADE: using guessed type char byte_61CADE;
// 27F35C: using guessed type _QWORD var_1FA8[1000];

//----- (0027F5E0) --------------------------------------------------------
void OALService()
{
  unsigned int numEntries; // r1
  OALBase **dataPtr; // r2
  unsigned int v2; // r0
  unsigned int v3; // r0
  unsigned int v4; // r4
  ALuint *v5; // r5
  ALuint v6; // r1
  ALuint v8; // [sp+4h] [bp-24h] BYREF
  ALint value[8]; // [sp+8h] [bp-20h] BYREF

  OS_MutexObtain(trashMutex);
  numEntries = OALBase::trashCan.numEntries;
  if ( OALBase::trashCan.numEntries )
  {
    do
    {
      dataPtr = OALBase::trashCan.dataPtr;
      if ( *OALBase::trashCan.dataPtr )
      {
        (*(void (__fastcall **)(OALBase *))(**(_DWORD **)OALBase::trashCan.dataPtr + 4))(*OALBase::trashCan.dataPtr);
        dataPtr = OALBase::trashCan.dataPtr;
        numEntries = OALBase::trashCan.numEntries;
      }
      *dataPtr = dataPtr[numEntries - 1];
      v2 = OALBase::trashCan.numEntries;
      numEntries = --OALBase::trashCan.numEntries;
    }
    while ( v2 != 1 );
  }
  OS_MutexRelease(trashMutex);
  v3 = OALSource::activeSources.numEntries;
  if ( OALSource::activeSources.numEntries )
  {
    v4 = 0;
    do
    {
      v5 = (ALuint *)OALSource::activeSources.dataPtr[v4];
      v6 = v5[3];
      v5[10] = 0;
      if ( v6 == 2 )
      {
        value[0] = 0;
        j_alGetSourcei(v5[2], 4118, value);
        while ( value[0]-- != 0 )
        {
          v8 = 0;
          j_alSourceUnqueueBuffers(v5[2], 1, &v8);
          j_alSourceQueueBuffers(v5[2], 1, (const ALuint *)(v5[4] + 8));
        }
        v3 = OALSource::activeSources.numEntries;
      }
      ++v4;
    }
    while ( v4 < v3 );
  }
}
// 27F5E0: using guessed type ALint value[8];

//----- (0027F6E4) --------------------------------------------------------
void __fastcall OALSource::Update(OALSource *this)
{
  OALSourceType type; // r1
  bool i; // zf
  ALuint v4; // [sp+0h] [bp-18h] BYREF
  ALint value[5]; // [sp+4h] [bp-14h] BYREF

  type = this->type;
  this->curState = 0;
  if ( type == OST_Preloop )
  {
    value[0] = 0;
    j_alGetSourcei(this->sourceId, 4118, value);
    for ( i = value[0]-- == 0; !i; --value[0] )
    {
      v4 = 0;
      j_alSourceUnqueueBuffers(this->sourceId, 1, &v4);
      j_alSourceQueueBuffers(this->sourceId, 1, &this->oalBuffer->bufferId);
      i = value[0] == 0;
    }
  }
}
// 27F6E4: using guessed type ALint value[5];

//----- (0027F748) --------------------------------------------------------
void __fastcall OALBuffer::OALBuffer(
        OALBuffer *this,
        void *dataPtr,
        unsigned int numBytes,
        unsigned int freq,
        unsigned int channels)
{
  ALenum v9; // r1

  this->_vptr$OALBase = (int (**)(void))&off_661FA8;
  this->refCount = 1;
  ++OALBase::livingCount;
  this->preloopBufferId = 0;
  this->_vptr$OALBase = (int (**)(void))&off_661F88;
  j_alGenBuffers(1, &this->bufferId);
  v9 = 4355;
  if ( channels == 1 )
    v9 = 4353;
  j_alBufferData(this->bufferId, v9, dataPtr, numBytes, freq);
  this->bufferSize = numBytes;
}
// 661F88: using guessed type void *;
// 661FA8: using guessed type void *off_661FA8;

//----- (0027F7C0) --------------------------------------------------------
void __fastcall OALBuffer::OALBuffer(
        OALBuffer *this,
        void *preloopPtr,
        unsigned int preLoopSize,
        void *loopPtr,
        unsigned int loopSize,
        unsigned int freq,
        unsigned int channels)
{
  ALuint *p_bufferId; // r10
  ALenum v12; // r6
  char *v13; // r8

  p_bufferId = &this->bufferId;
  this->_vptr$OALBase = (int (**)(void))&off_661FA8;
  this->refCount = 1;
  ++OALBase::livingCount;
  this->_vptr$OALBase = (int (**)(void))&off_661F88;
  j_alGenBuffers(2, &this->bufferId);
  v12 = 4355;
  if ( channels == 1 )
    v12 = 4353;
  j_alBufferData(this->preloopBufferId, v12, preloopPtr, preLoopSize, freq);
  if ( loopSize >> 4 > 0x18 )
  {
    j_alBufferData(*p_bufferId, v12, loopPtr, loopSize, freq);
  }
  else
  {
    v13 = (char *)malloc(4 * loopSize);
    qmemcpy(v13, loopPtr, loopSize);
    qmemcpy(&v13[loopSize], loopPtr, loopSize);
    qmemcpy(&v13[2 * loopSize], loopPtr, loopSize);
    qmemcpy(&v13[3 * loopSize], loopPtr, loopSize);
    j_alBufferData(*p_bufferId, v12, v13, 4 * loopSize, freq);
    free(v13);
  }
  this->bufferSize = loopSize + preLoopSize;
}
// 661F88: using guessed type void *off_661F88;
// 661FA8: using guessed type void *off_661FA8;

//----- (0027F8B0) --------------------------------------------------------
void __fastcall OALBuffer::~OALBuffer(OALBuffer *this)
{
  ALuint *p_bufferId; // r6
  ALuint preloopBufferId; // r0

  this->_vptr$OALBase = (int (**)(void))&off_661F88;
  p_bufferId = &this->bufferId;
  j_alDeleteBuffers(1, &this->bufferId);
  preloopBufferId = this->preloopBufferId;
  *p_bufferId = 0;
  if ( preloopBufferId )
  {
    j_alDeleteBuffers(1, &this->preloopBufferId);
    this->preloopBufferId = 0;
  }
  this->_vptr$OALBase = (int (**)(void))&off_661FA8;
  --OALBase::livingCount;
}
// 661F88: using guessed type void *off_661F88;
// 661FA8: using guessed type void *off_661FA8;

//----- (0027F918) --------------------------------------------------------
void __fastcall OALBuffer::~OALBuffer(OALBuffer *this)
{
  ALuint *p_bufferId; // r6
  ALuint preloopBufferId; // r0

  this->_vptr$OALBase = (int (**)(void))&off_661F88;
  p_bufferId = &this->bufferId;
  j_alDeleteBuffers(1, &this->bufferId);
  preloopBufferId = this->preloopBufferId;
  *p_bufferId = 0;
  if ( preloopBufferId )
  {
    j_alDeleteBuffers(1, &this->preloopBufferId);
    this->preloopBufferId = 0;
  }
  this->_vptr$OALBase = (int (**)(void))&off_661FA8;
  --OALBase::livingCount;
  sub_191374(this);
}
// 661F88: using guessed type void *off_661F88;
// 661FA8: using guessed type void *off_661FA8;

//----- (0027F984) --------------------------------------------------------
void __fastcall OALSource::OALSource(OALSource *this)
{
  OALBase v1; // r2

  v1.refCount = 1;
  v1._vptr$OALBase = (int (**)(void))&off_661FA8;
  this->OALBase = v1;
  ++OALBase::livingCount;
  *(_QWORD *)&this->queuedBuffers.numAlloced = 0LL;
  *(_QWORD *)&this->queuedBuffers.dataPtr = 0LL;
  *(_QWORD *)&this->sourceId = 0LL;
  *(_QWORD *)&this->oalBuffer = 0LL;
  this->_vptr$OALBase = (int (**)(void))&off_661F98;
  this->curVolume = 1.0;
  this->curState = 0;
  this->wasStopped = 0;
}
// 661F98: using guessed type void *;
// 661FA8: using guessed type void *;

//----- (0027F9E0) --------------------------------------------------------
void __fastcall OALSource::~OALSource(OALSource *this)
{
  OALBuffer *oalBuffer; // r0
  bool v3; // zf
  OALBuffer *v4; // r0
  int v5; // r3
  OALBuffer **dataPtr; // r0

  oalBuffer = this->oalBuffer;
  this->_vptr$OALBase = (int (**)(void))&off_661F98;
  v3 = oalBuffer == 0;
  if ( oalBuffer )
    v3 = this->type == OST_Preloop;
  if ( !v3 )
  {
    if ( this->sourceId )
    {
      j_alSourcei(this->sourceId, 4105, 0);
      v4 = this->oalBuffer;
      if ( v4 )
        OALBase::Release(v4);
    }
    else
    {
      OALBase::Release(oalBuffer);
    }
    this->oalBuffer = 0;
  }
  if ( this->sourceId )
  {
    if ( (this->type & 0xFFFFFFFE) == 2 )
      OALSource::UnqueueBuffers(this);
    if ( OALSource::activeSources.numEntries )
    {
      v5 = 0;
      while ( OALSource::activeSources.dataPtr[v5] != this )
      {
        if ( ++v5 >= OALSource::activeSources.numEntries )
          goto LABEL_17;
      }
    }
    else
    {
LABEL_17:
      v5 = -1;
    }
    memmove(
      &OALSource::activeSources.dataPtr[v5],
      &OALSource::activeSources.dataPtr[v5 + 1],
      4 * (OALSource::activeSources.numEntries + 0x3FFFFFFF - v5));
    --OALSource::activeSources.numEntries;
    j_alDeleteSources(1, &this->sourceId);
    this->sourceId = 0;
  }
  dataPtr = this->queuedBuffers.dataPtr;
  this->queuedBuffers.numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->queuedBuffers.dataPtr = 0;
  }
  this->queuedBuffers.numAlloced = 0;
  this->_vptr$OALBase = (int (**)(void))&off_661FA8;
  --OALBase::livingCount;
}
// 661F98: using guessed type void *off_661F98;
// 661FA8: using guessed type void *off_661FA8;

//----- (0027FACC) --------------------------------------------------------
void __fastcall OALSource::UnqueueBuffers(OALSource *this)
{
  unsigned int numEntries; // r1
  size_t v3; // r2
  OALBuffer **dataPtr; // r0
  unsigned int v5; // r5
  OALBase *v6; // r6
  ALuint bufferId; // r4
  bool i; // zf
  ALuint buffers; // [sp+4h] [bp-24h] BYREF
  ALint value[8]; // [sp+8h] [bp-20h] BYREF

  value[0] = 0;
  j_alGetSourcei(this->sourceId, 4118, value);
  for ( i = value[0]-- == 0; !i; --value[0] )
  {
    buffers = 0;
    j_alSourceUnqueueBuffers(this->sourceId, 1, &buffers);
    numEntries = this->queuedBuffers.numEntries;
    if ( numEntries )
    {
      v3 = 4 * numEntries - 4;
      dataPtr = this->queuedBuffers.dataPtr;
      v5 = 0;
      while ( 1 )
      {
        v6 = *dataPtr;
        bufferId = (*dataPtr)->bufferId;
        i = bufferId == buffers;
        if ( bufferId != buffers )
          i = v6[1].refCount == buffers;
        if ( i )
          break;
        ++v5;
        ++dataPtr;
        v3 -= 4;
        if ( v5 >= numEntries )
          goto LABEL_11;
      }
      this->posOffset += (unsigned int)v6[2]._vptr$OALBase;
      memmove(dataPtr, dataPtr + 1, v3);
      --this->queuedBuffers.numEntries;
      if ( v6 )
        OALBase::Release(v6);
    }
LABEL_11:
    i = value[0] == 0;
  }
}
// 27FACC: using guessed type ALint value[8];

//----- (0027FB7A) --------------------------------------------------------
void __fastcall OALSource::~OALSource(OALSource *this)
{
  void *v1; // r0

  OALSource::~OALSource(this);
  sub_191374(v1);
}
// 27FB86: variable 'v1' is possibly undefined

//----- (0027FB8C) --------------------------------------------------------
void __fastcall OALSource::ObtainSource(OALSource *this)
{
  ALuint *p_sourceId; // r4
  unsigned int numEntries; // r6
  unsigned int v4; // r10
  OALSource **dataPtr; // r8
  OALSource **v6; // r9
  OALBuffer *oalBuffer; // r0
  bool v8; // zf

  p_sourceId = &this->sourceId;
  if ( !this->sourceId )
  {
    j_alGenSources(1, p_sourceId);
    numEntries = OALSource::activeSources.numEntries;
    if ( OALSource::activeSources.numAlloced >= OALSource::activeSources.numEntries + 1 )
    {
      dataPtr = OALSource::activeSources.dataPtr;
    }
    else
    {
      v4 = 4 * (OALSource::activeSources.numEntries + 1) / 3 + 3;
      dataPtr = (OALSource **)malloc(4 * v4);
      v6 = OALSource::activeSources.dataPtr;
      if ( OALSource::activeSources.dataPtr )
      {
        qmemcpy(dataPtr, OALSource::activeSources.dataPtr, 4 * numEntries);
        free(v6);
        numEntries = OALSource::activeSources.numEntries;
      }
      OALSource::activeSources.dataPtr = dataPtr;
      OALSource::activeSources.numAlloced = v4;
    }
    dataPtr[numEntries] = this;
    ++OALSource::activeSources.numEntries;
    oalBuffer = this->oalBuffer;
    v8 = oalBuffer == 0;
    if ( oalBuffer )
      v8 = this->type == OST_Preloop;
    if ( !v8 )
      sub_19058C(*p_sourceId, 4105, oalBuffer->bufferId);
  }
}

//----- (0027FC68) --------------------------------------------------------
void __fastcall OALSource::SetData(
        OALSource *this,
        void *dataPtr,
        unsigned int numBytes,
        unsigned int freq,
        unsigned int channels)
{
  OALBuffer *v9; // r5
  OALSourceType v10; // r6
  ALenum v11; // r1
  OALBuffer *oalBuffer; // r0
  ALuint sourceId; // r0

  v9 = (OALBuffer *)operator new(0x14u);
  v10 = OST_Static;
  v9->refCount = 1;
  ++OALBase::livingCount;
  v9->preloopBufferId = 0;
  v9->_vptr$OALBase = (int (**)(void))&off_661F88;
  j_alGenBuffers(1, &v9->bufferId);
  v11 = 4355;
  if ( channels == 1 )
    v11 = 4353;
  j_alBufferData(v9->bufferId, v11, dataPtr, numBytes, freq);
  v9->bufferSize = numBytes;
  oalBuffer = this->oalBuffer;
  if ( oalBuffer )
    OALBase::Release(oalBuffer);
  sourceId = this->sourceId;
  if ( v9->preloopBufferId )
    v10 = OST_Preloop;
  this->type = v10;
  this->oalBuffer = 0;
  if ( sourceId )
    j_alSourcei(sourceId, 4105, v9->bufferId);
  this->oalBuffer = v9;
  ++v9->refCount;
  sub_1968AC(v9);
}
// 661F88: using guessed type void *off_661F88;

//----- (0027FD1C) --------------------------------------------------------
void __fastcall OALSource::SetBuffer(OALSource *this, OALBuffer *withBuffer)
{
  OALBuffer *oalBuffer; // r0
  OALSourceType v5; // r2
  ALuint sourceId; // r0

  oalBuffer = this->oalBuffer;
  if ( oalBuffer )
    OALBase::Release(oalBuffer);
  v5 = OST_Static;
  this->oalBuffer = 0;
  sourceId = this->sourceId;
  if ( withBuffer->preloopBufferId )
    v5 = OST_Preloop;
  this->type = v5;
  if ( sourceId )
    j_alSourcei(sourceId, 4105, withBuffer->bufferId);
  this->oalBuffer = withBuffer;
  ++withBuffer->refCount;
}

//----- (0027FD58) --------------------------------------------------------
void __fastcall OALSource::SetZero(OALSource *this, unsigned int numBytes, unsigned int freq)
{
  void *v6; // r4

  v6 = malloc(numBytes);
  memset(v6, 0, numBytes);
  OALSource::SetData(this, v6, numBytes, freq, 1u);
  j_free(v6);
}

//----- (0027FD96) --------------------------------------------------------
void __fastcall OALSource::SetStream(OALSource *this)
{
  this->type = OST_Streaming;
}

//----- (0027FD9C) --------------------------------------------------------
void __fastcall OALSource::QueueBuffer(OALSource *this, OALBuffer *toQueue)
{
  unsigned int numEntries; // r6
  unsigned int v5; // r10
  OALBuffer **v6; // r0
  OALBuffer **v7; // r8
  OALBuffer **dataPtr; // r9

  OALSource::ObtainSource(this);
  OALSource::UnqueueBuffers(this);
  j_alSourceQueueBuffers(this->sourceId, 1, &toQueue->bufferId);
  numEntries = this->queuedBuffers.numEntries;
  if ( this->queuedBuffers.numAlloced >= numEntries + 1 )
  {
    dataPtr = this->queuedBuffers.dataPtr;
  }
  else
  {
    v5 = 4 * (numEntries + 1) / 3 + 3;
    v6 = (OALBuffer **)malloc(4 * v5);
    v7 = this->queuedBuffers.dataPtr;
    dataPtr = v6;
    if ( v7 )
    {
      qmemcpy(v6, this->queuedBuffers.dataPtr, 4 * numEntries);
      free(v7);
      numEntries = this->queuedBuffers.numEntries;
    }
    this->queuedBuffers.dataPtr = dataPtr;
    this->queuedBuffers.numAlloced = v5;
  }
  dataPtr[numEntries] = toQueue;
  ++this->queuedBuffers.numEntries;
  ++toQueue->refCount;
}

//----- (0027FE26) --------------------------------------------------------
void __fastcall OALSource::Pause(OALSource *this)
{
  OALSource::ObtainSource(this);
  sub_1A0A14(this->sourceId);
}

//----- (0027FE3A) --------------------------------------------------------
void __fastcall OALSource::Play(OALSource *this)
{
  OALSource::ObtainSource(this);
  if ( this->type == OST_Preloop )
  {
    OALSource::UnqueueBuffers(this);
    j_alSourceQueueBuffers(this->sourceId, 1, &this->oalBuffer->preloopBufferId);
    j_alSourceQueueBuffers(this->sourceId, 1, &this->oalBuffer->bufferId);
    j_alSourceQueueBuffers(this->sourceId, 1, &this->oalBuffer->bufferId);
    j_alSourceQueueBuffers(this->sourceId, 1, &this->oalBuffer->bufferId);
    j_alSourceQueueBuffers(this->sourceId, 1, &this->oalBuffer->bufferId);
    j_alSourceQueueBuffers(this->sourceId, 1, &this->oalBuffer->bufferId);
    j_alSourceQueueBuffers(this->sourceId, 1, &this->oalBuffer->bufferId);
    j_alSourceQueueBuffers(this->sourceId, 1, &this->oalBuffer->bufferId);
    j_alSourceQueueBuffers(this->sourceId, 1, &this->oalBuffer->bufferId);
    j_alSourceQueueBuffers(this->sourceId, 1, &this->oalBuffer->bufferId);
    j_alSourceQueueBuffers(this->sourceId, 1, &this->oalBuffer->bufferId);
  }
  j_alSourcePlay(this->sourceId);
  this->wasStopped = 0;
  this->curState = 4114;
}

//----- (0027FF00) --------------------------------------------------------
float __fastcall OALSource::GetVolume(OALSource *this)
{
  return logf(1.0 / this->curVolume) * -8.6562;
}

//----- (0027FF30) --------------------------------------------------------
void __fastcall OALSource::SetVolume(OALSource *this, float volume)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float v6; // s0

  OALSource::ObtainSource(this);
  v2.n64_u32[0] = 1.0;
  v3.n64_f32[0] = 1.0 / exp2f(volume / -6.0);
  v6 = vmin_f32(v3, v2).n64_f32[0];
  if ( this->curVolume != v6 )
  {
    this->curVolume = v6;
    sub_198FD4(this->sourceId, 4106, v6);
  }
}
// 27FF60: variable 'v3' is possibly undefined
// 27FF60: variable 'v2' is possibly undefined
// 19CA48: using guessed type float __fastcall exp2f(_DWORD);

//----- (0027FF86) --------------------------------------------------------
void __fastcall OSArray<OALBase *>::~OSArray(OSArray<OALBase *> *this)
{
  OALBase **dataPtr; // r0

  dataPtr = this->dataPtr;
  this->numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->dataPtr = 0;
  }
  this->numAlloced = 0;
}

//----- (0027FFA0) --------------------------------------------------------
void __fastcall OSArray<OALSource *>::~OSArray(OSArray<OALSource *> *this)
{
  OALSource **dataPtr; // r0

  dataPtr = this->dataPtr;
  this->numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->dataPtr = 0;
  }
  this->numAlloced = 0;
}

//----- (0027FFBC) --------------------------------------------------------
void __fastcall OALBase::Release(OALBase *this)
{
  unsigned int v2; // r0
  unsigned int numEntries; // r5
  unsigned int v4; // r9
  OALBase **dataPtr; // r8
  OALBase **v6; // r6

  v2 = this->refCount - 1;
  this->refCount = v2;
  if ( !v2 )
  {
    OS_MutexObtain(trashMutex);
    numEntries = OALBase::trashCan.numEntries;
    if ( OALBase::trashCan.numAlloced >= OALBase::trashCan.numEntries + 1 )
    {
      dataPtr = OALBase::trashCan.dataPtr;
    }
    else
    {
      v4 = 4 * (OALBase::trashCan.numEntries + 1) / 3 + 3;
      dataPtr = (OALBase **)malloc(4 * v4);
      v6 = OALBase::trashCan.dataPtr;
      if ( OALBase::trashCan.dataPtr )
      {
        qmemcpy(dataPtr, OALBase::trashCan.dataPtr, 4 * numEntries);
        free(v6);
        numEntries = OALBase::trashCan.numEntries;
      }
      OALBase::trashCan.dataPtr = dataPtr;
      OALBase::trashCan.numAlloced = v4;
    }
    dataPtr[numEntries] = this;
    ++OALBase::trashCan.numEntries;
    sub_18CEF0(trashMutex);
  }
}

//----- (00280090) --------------------------------------------------------
void __fastcall OALBase::~OALBase(OALBase *this)
{
  this->_vptr$OALBase = (int (**)(void))&off_661FA8;
  --OALBase::livingCount;
}
// 661FA8: using guessed type void *off_661FA8;

//----- (002800B0) --------------------------------------------------------
void __fastcall OALBase::~OALBase(OALBase *this)
{
  this->_vptr$OALBase = (int (**)(void))&off_661FA8;
  --OALBase::livingCount;
  sub_191374(this);
}
// 661FA8: using guessed type void *off_661FA8;

//----- (002800D4) --------------------------------------------------------
void __fastcall CBuilding::CBuilding(CBuilding *this)
{
  int v1; // r0
  char v2; // r3

  CEntity::CEntity(this);
  v2 = *(_BYTE *)(v1 + 58);
  *(_DWORD *)(v1 + 28) |= 1u;
  *(_BYTE *)(v1 + 58) = v2 & 0xF8 | 1;
  *(_DWORD *)v1 = &off_661FB8;
}
// 2800E2: variable 'v1' is possibly undefined
// 661FB8: using guessed type void *;

//----- (00280104) --------------------------------------------------------
void *__fastcall CBuilding::operator new(size_t nSize)
{
  int v1; // lr
  CBuildingPool *v2; // r1
  void *result; // r0
  void *m_nSize; // r12
  uint8 *m_aFlags; // r2
  int v6; // r3

  v1 = 0;
  v2 = CPools::ms_pBuildingPool;
  result = (void *)CPools::ms_pBuildingPool->m_nFreeIndex;
  m_nSize = (void *)CPools::ms_pBuildingPool->m_nSize;
  do
  {
    result = (char *)result + 1;
    v2->m_nFreeIndex = (int32)result;
    if ( result == m_nSize )
    {
      result = 0;
      v2->m_nFreeIndex = 0;
      if ( v1 << 31 )
        return result;
      v1 = 1;
    }
    m_aFlags = v2->m_aFlags;
    v6 = *((char *)result + (_DWORD)m_aFlags);
  }
  while ( v6 > -1 );
  *((_BYTE *)result + (_DWORD)m_aFlags) = v6 & 0x7F;
  v2->m_aFlags[v2->m_nFreeIndex] = (v2->m_aFlags[v2->m_nFreeIndex] + 1) & 0x7F | v2->m_aFlags[v2->m_nFreeIndex] & 0x80;
  return v2->m_aStorage[v2->m_nFreeIndex];
}

//----- (00280168) --------------------------------------------------------
void __fastcall CBuilding::operator delete(void *pVoid)
{
  CBuildingPool *v1; // r1
  int v2; // r0

  v1 = CPools::ms_pBuildingPool;
  v2 = -286331153 * ((signed int)((int)pVoid - (unsigned int)CPools::ms_pBuildingPool->m_aStorage) >> 2);
  CPools::ms_pBuildingPool->m_aFlags[v2] |= 0x80u;
  if ( v2 < v1->m_nFreeIndex )
    v1->m_nFreeIndex = v2;
}

//----- (00280198) --------------------------------------------------------
void __fastcall CBuilding::ReplaceWithNewModel(CBuilding *this, int32 index)
{
  int16 v3; // r4
  int32 m_nModelIndex; // r0

  v3 = index;
  (*((void (__fastcall **)(CBuilding *))this->_vptr$CPlaceable + 9))(this);
  m_nModelIndex = this->m_nModelIndex;
  if ( !CModelInfo::ms_modelInfoPtrs[m_nModelIndex]->m_numRefs )
    CStreaming::RemoveModel(m_nModelIndex);
  this->m_nModelIndex = v3;
}

//----- (002801C8) --------------------------------------------------------
bool __fastcall IsBuildingPointerValid(CBuilding *pBuilding)
{
  int v1; // r0
  int32 v2; // r0
  bool result; // r0

  result = pBuilding
        && (v1 = (char *)pBuilding - (char *)CPools::ms_pBuildingPool->m_aStorage, v1 >= 0)
        && (v2 = -286331153 * (v1 >> 2), v2 < CPools::ms_pBuildingPool->m_nSize)
        && (char)CPools::ms_pBuildingPool->m_aFlags[v2] > -1;
  return result;
}

//----- (00280204) --------------------------------------------------------
void __fastcall CAnimatedBuilding::PreRender(CAnimatedBuilding *this)
{
  if ( this->m_pRwObject )
  {
    CEntity::PreRender(this);
    CEntity::UpdateRwFrame(this);
    sub_190518(this);
  }
}

//----- (00280228) --------------------------------------------------------
void __fastcall CAnimatedBuilding::~CAnimatedBuilding(CAnimatedBuilding *this)
{
  CBuildingPool *v1; // r1
  int v2; // r0
  int v3; // r0

  CEntity::~CEntity(this);
  v1 = CPools::ms_pBuildingPool;
  v3 = -286331153 * ((signed int)(v2 - (unsigned int)CPools::ms_pBuildingPool->m_aStorage) >> 2);
  CPools::ms_pBuildingPool->m_aFlags[v3] |= 0x80u;
  if ( v3 < v1->m_nFreeIndex )
    v1->m_nFreeIndex = v3;
}
// 28023C: variable 'v2' is possibly undefined

//----- (00280260) --------------------------------------------------------
void __fastcall CEntity::SetIsStatic(CEntity *this, bool bIsStatic)
{
  *(_DWORD *)&this->m_nFlags = *(_DWORD *)&this->m_nFlags & 0xFFFFFFFB | (4 * bIsStatic);
}

//----- (00280270) --------------------------------------------------------
void __fastcall CAnimatedBuilding::ProcessCollision(CAnimatedBuilding *this)
{
  *(_DWORD *)&this->m_nFlags |= 0x20u;
}

//----- (0028027C) --------------------------------------------------------
bool __fastcall CEntity::TestCollision(CEntity *this, bool bApplySpeed)
{
  return 0;
}

//----- (00280284) --------------------------------------------------------
uint8 __fastcall CEntity::SpecialEntityCalcCollisionSteps(
        CEntity *this,
        bool *bDoPreCheckAtFullSpeed,
        bool *bDoPreCheckAtHalfSpeed)
{
  return 1;
}

//----- (0028028C) --------------------------------------------------------
void __fastcall CBuilding::~CBuilding(CBuilding *this)
{
  CBuildingPool *v1; // r1
  int v2; // r0
  int v3; // r0

  CEntity::~CEntity(this);
  v1 = CPools::ms_pBuildingPool;
  v3 = -286331153 * ((signed int)(v2 - (unsigned int)CPools::ms_pBuildingPool->m_aStorage) >> 2);
  CPools::ms_pBuildingPool->m_aFlags[v3] |= 0x80u;
  if ( v3 < v1->m_nFreeIndex )
    v1->m_nFreeIndex = v3;
}
// 2802A0: variable 'v2' is possibly undefined

//----- (002802D0) --------------------------------------------------------
void CIplStore::Initialise()
{
  CPool<IplDef,IplDef> *v0; // r4
  uint8 *v1; // r0
  uint8 v2; // r1
  int i; // r0
  CQuadTreeNode *v4; // r0
  CQuadTreeNode *v5; // r0
  CRect v6; // [sp+0h] [bp-28h] BYREF

  *(_QWORD *)&v6.left = 0x453B8000C53B8000LL;
  *(_QWORD *)&v6.right = 0xC53B8000453B8000LL;
  gCheckIplPosn = 0;
  if ( !CIplStore::ms_pPool )
  {
    v0 = (CPool<IplDef,IplDef> *)operator new(0x14u);
    v0->m_aStorage = (CPool<IplDef,IplDef>::StorageType *)operator new[](0x3400u);
    v1 = (uint8 *)operator new[](0x100u);
    v0->m_bOwnsArrays = 1;
    v0->m_aFlags = v1;
    v0->m_nSize = 256;
    v0->m_nFreeIndex = -1;
    v2 = v1[1];
    *v1 = 0x80;
    v1[1] = v2 | 0x80;
    v0->m_aFlags[1] &= 0x80u;
    for ( i = 2; i != 256; ++i )
    {
      v0->m_aFlags[i] |= 0x80u;
      v0->m_aFlags[i] &= 0x80u;
    }
    CIplStore::ms_pPool = v0;
  }
  CIplStore::AddIplSlot("generic");
  v4 = (CQuadTreeNode *)CQuadTreeNode::operator new(0x28u);
  CQuadTreeNode::CQuadTreeNode(v4, &v6, 3);
  numEntityIndexArrays = 0;
  ppEntityArrayToUpdate = 0;
  CIplStore::ms_pQuadTree = v5;
}
// 280392: variable 'v5' is possibly undefined
// 6DFDA4: using guessed type char gCheckIplPosn;
// 2802D0: using guessed type CRect var_28;

//----- (002803D0) --------------------------------------------------------
int32 __fastcall CIplStore::AddIplSlot(const unsigned __int8 *pName)
{
  int v2; // r3
  CPool<IplDef,IplDef> *v3; // r0
  int32 m_nFreeIndex; // r4
  int32 m_nSize; // lr
  uint8 *m_aFlags; // r1
  int v7; // r2

  v2 = 0;
  v3 = CIplStore::ms_pPool;
  m_nFreeIndex = CIplStore::ms_pPool->m_nFreeIndex;
  m_nSize = CIplStore::ms_pPool->m_nSize;
  do
  {
    v3->m_nFreeIndex = ++m_nFreeIndex;
    if ( m_nFreeIndex == m_nSize )
    {
      m_nFreeIndex = 0;
      v3->m_nFreeIndex = 0;
      if ( v2 << 31 )
        goto LABEL_7;
      v2 = 1;
    }
    m_aFlags = v3->m_aFlags;
    v7 = (char)m_aFlags[m_nFreeIndex];
  }
  while ( v7 > -1 );
  m_aFlags[m_nFreeIndex] = v7 & 0x7F;
  v3->m_aFlags[v3->m_nFreeIndex] = (v3->m_aFlags[v3->m_nFreeIndex] + 1) & 0x7F | v3->m_aFlags[v3->m_nFreeIndex] & 0x80;
  m_nFreeIndex = (int32)v3->m_aStorage[v3->m_nFreeIndex];
LABEL_7:
  *(_BYTE *)(m_nFreeIndex + 46) = 0;
  *(_DWORD *)(m_nFreeIndex + 34) = -2147450881;
  *(_DWORD *)(m_nFreeIndex + 38) = -2147450881;
  *(_DWORD *)(m_nFreeIndex + 42) = 0xFFFF;
  *(_BYTE *)(m_nFreeIndex + 49) = 0;
  *(_QWORD *)m_nFreeIndex = 0xC974240049742400LL;
  *(_QWORD *)(m_nFreeIndex + 8) = 0x49742400C9742400LL;
  strcpy((char *)(m_nFreeIndex + 16), (const char *)pName);
  *(_WORD *)(m_nFreeIndex + 47) = 1;
  return -991146299 * ((signed int)(m_nFreeIndex - (unsigned int)CIplStore::ms_pPool->m_aStorage) >> 2);
}

//----- (00280498) --------------------------------------------------------
void CIplStore::Shutdown()
{
  int v0; // r5
  uint8 *p_m_flags; // r4
  int v2; // r6
  int32 v3; // r5
  CPool<IplDef,IplDef> *v4; // r4
  CQuadTreeNode *v5; // r0
  uint8 *v6; // r1
  CPool<IplDef,IplDef> *v7; // r0
  uint8 *m_aFlags; // r1
  CPool<IplDef,IplDef>::StorageType *m_aStorage; // r2
  uint8 *v10; // r3
  int v11; // r2
  uint8 *v12; // r0
  uint8 **p_m_aFlags; // r5
  int32 v14; // r1
  int32 v15; // r5
  CEntity **v16; // r0
  void *v17; // r0

  v0 = 0;
  p_m_flags = &CStreaming::ms_aInfoForModel[25256].m_flags;
  do
  {
    if ( (CIplStore::ms_pPool->m_aFlags[v0 + 1] & 0x80u) == 0 && (*p_m_flags & 6) == 0 )
      CStreaming::RemoveModel(v0 + 25256);
    ++v0;
    p_m_flags += 20;
  }
  while ( v0 != 255 );
  v2 = 0;
  v3 = 0;
  v4 = CIplStore::ms_pPool;
  do
  {
    if ( (v4->m_aFlags[v3] & 0x80u) != 0 || !v4->m_aStorage[v2] )
      goto LABEL_19;
    if ( v4->m_aStorage[v2][45] )
    {
      CIplStore::RemoveIpl(v3);
      v4 = CIplStore::ms_pPool;
      v5 = CIplStore::ms_pQuadTree;
      if ( (CIplStore::ms_pPool->m_aFlags[v3] & 0x80u) != 0 )
      {
        v6 = 0;
        goto LABEL_14;
      }
    }
    else
    {
      v5 = CIplStore::ms_pQuadTree;
    }
    v6 = v4->m_aStorage[v2];
LABEL_14:
    CQuadTreeNode::DeleteItem(v5, v6);
    v7 = CIplStore::ms_pPool;
    m_aFlags = CIplStore::ms_pPool->m_aFlags;
    m_aStorage = CIplStore::ms_pPool->m_aStorage;
    if ( (char)m_aFlags[v3] <= -1 )
      v10 = 0;
    else
      v10 = m_aStorage[v2];
    v11 = -991146299 * ((v10 - (uint8 *)m_aStorage) >> 2);
    m_aFlags[v11] |= 0x80u;
    if ( v11 < v7->m_nFreeIndex )
      v7->m_nFreeIndex = v11;
LABEL_19:
    v4 = CIplStore::ms_pPool;
    ++v3;
    ++v2;
  }
  while ( v3 != 256 );
  if ( CIplStore::ms_pPool )
  {
    if ( CIplStore::ms_pPool->m_nSize >= 1 )
    {
      if ( CIplStore::ms_pPool->m_bOwnsArrays )
      {
        if ( CIplStore::ms_pPool->m_aStorage )
          operator delete[](CIplStore::ms_pPool->m_aStorage);
        p_m_aFlags = &v4->m_aFlags;
        v12 = v4->m_aFlags;
        if ( v12 )
          operator delete[](v12);
      }
      else
      {
        p_m_aFlags = &CIplStore::ms_pPool->m_aFlags;
      }
      v4->m_aStorage = 0;
      *p_m_aFlags = 0;
    }
    operator delete(v4);
  }
  v14 = numEntityIndexArrays;
  CIplStore::ms_pPool = 0;
  if ( numEntityIndexArrays >= 1 )
  {
    v15 = 0;
    do
    {
      v16 = ppEntityIndexArray[v15];
      if ( v16 )
      {
        operator delete[](v16);
        v14 = numEntityIndexArrays;
      }
      ++v15;
    }
    while ( v15 < v14 );
  }
  numEntityIndexArrays = 0;
  if ( CIplStore::ms_pQuadTree )
  {
    CQuadTreeNode::~CQuadTreeNode(CIplStore::ms_pQuadTree);
    CQuadTreeNode::operator delete(v17);
  }
  CIplStore::ms_pQuadTree = 0;
}
// 280610: variable 'v17' is possibly undefined
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (00280664) --------------------------------------------------------
void CIplStore::RemoveAllIpls()
{
  int v0; // r5
  uint8 *p_m_flags; // r4

  v0 = 0;
  p_m_flags = &CStreaming::ms_aInfoForModel[25256].m_flags;
  do
  {
    if ( (CIplStore::ms_pPool->m_aFlags[v0 + 1] & 0x80u) == 0 && (*p_m_flags & 6) == 0 )
      CStreaming::RemoveModel(v0 + 25256);
    ++v0;
    p_m_flags += 20;
  }
  while ( v0 != 255 );
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (002806BC) --------------------------------------------------------
void __fastcall CIplStore::RemoveIplSlot(int32 index)
{
  CPool<IplDef,IplDef> *v2; // r1
  uint8 *v3; // r1
  CPool<IplDef,IplDef> *v4; // r0
  uint8 *m_aFlags; // r1
  uint8 *v6; // r3
  int v7; // r2

  v2 = CIplStore::ms_pPool;
  if ( CIplStore::ms_pPool->m_aStorage[index][45] )
  {
    CIplStore::RemoveIpl(index);
    v2 = CIplStore::ms_pPool;
  }
  if ( (v2->m_aFlags[index] & 0x80u) != 0 )
    v3 = 0;
  else
    v3 = v2->m_aStorage[index];
  CQuadTreeNode::DeleteItem(CIplStore::ms_pQuadTree, v3);
  v4 = CIplStore::ms_pPool;
  m_aFlags = CIplStore::ms_pPool->m_aFlags;
  if ( (char)m_aFlags[index] <= -1 )
    v6 = 0;
  else
    v6 = CIplStore::ms_pPool->m_aStorage[index];
  v7 = -991146299 * ((v6 - (uint8 *)CIplStore::ms_pPool->m_aStorage) >> 2);
  m_aFlags[v7] |= 0x80u;
  if ( v7 < v4->m_nFreeIndex )
    v4->m_nFreeIndex = v7;
}

//----- (00280758) --------------------------------------------------------
void __fastcall CIplStore::RemoveIpl(int32 index)
{
  uint8 *v1; // r2
  CObjectPool *v2; // r11
  int v3; // r1
  int v4; // r3
  CDummyPool *v5; // r10
  CBuildingPool *v6; // r6
  int v7; // r4
  int v8; // r8
  CPool<CBuilding,CBuilding>::StorageType *m_aStorage; // r9
  uint8 *v10; // r5
  int m_nSize; // r2
  int v12; // r6
  int i; // r4
  CPool<CObject,CCutsceneObject>::StorageType *v14; // r8
  uint8 *v15; // r5
  CEntity *v16; // r0
  int v17; // r1
  int v18; // r3
  int v19; // r4
  int v20; // r6
  CPool<CDummy,CDummy>::StorageType *v21; // r5
  uint8 *v22; // r8
  uint8 *v23; // [sp+4h] [bp-2Ch]
  int32 v24; // [sp+8h] [bp-28h]

  if ( (CIplStore::ms_pPool->m_aFlags[index] & 0x80u) != 0 )
    v1 = 0;
  else
    v1 = CIplStore::ms_pPool->m_aStorage[index];
  v2 = CPools::ms_pObjectPool;
  v3 = *((__int16 *)v1 + 17);
  v4 = *((__int16 *)v1 + 18);
  v5 = CPools::ms_pDummyPool;
  v6 = CPools::ms_pBuildingPool;
  v23 = v1;
  v1[45] = 0;
  v24 = index;
  if ( v3 <= v4 )
  {
    v7 = v3;
    do
    {
      v8 = v3;
      if ( (v6->m_aFlags[v3] & 0x80u) == 0 )
      {
        m_aStorage = v6->m_aStorage;
        v10 = v6->m_aStorage[v7];
        if ( v10 )
        {
          if ( v10[50] == index )
          {
            CWorld::Remove((CEntity *)v6->m_aStorage[v7]);
            (*(void (__fastcall **)(uint8 *))(*(_DWORD *)&m_aStorage[v7][0] + 4))(v10);
            index = v24;
            LOWORD(v4) = *((_WORD *)v23 + 18);
          }
        }
      }
      ++v7;
      v3 = v8 + 1;
    }
    while ( v8 < (__int16)v4 );
  }
  m_nSize = v2->m_nSize;
  if ( m_nSize >= 1 )
  {
    v12 = 0;
    for ( i = 0; i < m_nSize; ++i )
    {
      if ( (v2->m_aFlags[i] & 0x80u) == 0 )
      {
        v14 = v2->m_aStorage;
        v15 = v2->m_aStorage[v12];
        if ( v15 )
        {
          if ( v15[50] == index )
          {
            v16 = (CEntity *)*((_DWORD *)v15 + 94);
            if ( v16 )
              CWorld::Add(v16);
            CWorld::Remove((CEntity *)v15);
            (*(void (__fastcall **)(uint8 *))(*(_DWORD *)&v14[v12][0] + 4))(v15);
            m_nSize = v2->m_nSize;
            index = v24;
          }
        }
      }
      ++v12;
    }
  }
  v17 = *((__int16 *)v23 + 19);
  v18 = *((__int16 *)v23 + 20);
  if ( v17 <= v18 )
  {
    v19 = v17;
    do
    {
      v20 = v17;
      if ( (v5->m_aFlags[v17] & 0x80u) == 0 )
      {
        v21 = v5->m_aStorage;
        v22 = v5->m_aStorage[v19];
        if ( v22 )
        {
          if ( v22[50] == index )
          {
            CWorld::Remove((CEntity *)v5->m_aStorage[v19]);
            (*(void (__fastcall **)(uint8 *))(*(_DWORD *)&v21[v19][0] + 4))(v22);
            index = v24;
            LOWORD(v18) = *((_WORD *)v23 + 20);
          }
        }
      }
      ++v19;
      v17 = v20 + 1;
    }
    while ( v20 < (__int16)v18 );
  }
  sub_19DC40(index);
}

//----- (002808C0) --------------------------------------------------------
const unsigned __int8 *__fastcall CIplStore::GetIplName(int32 index)
{
  uint8 *v1; // r0

  if ( (CIplStore::ms_pPool->m_aFlags[index] & 0x80u) == 0 )
    v1 = CIplStore::ms_pPool->m_aStorage[index];
  else
    v1 = 0;
  return v1 + 16;
}

//----- (002808E4) --------------------------------------------------------
void __fastcall CIplStore::SetIsInterior(int32 index, bool bInterior)
{
  CIplStore::ms_pPool->m_aStorage[index][44] = bInterior;
}

//----- (00280900) --------------------------------------------------------
int32 __fastcall CIplStore::FindIplSlot(const unsigned __int8 *pName)
{
  CPool<IplDef,IplDef> *v2; // r9
  int32 m_nSize; // r10
  uint8 *m_aFlags; // r6
  int32 v5; // r4
  int i; // r5
  const char *v7; // r1

  v2 = CIplStore::ms_pPool;
  m_nSize = CIplStore::ms_pPool->m_nSize;
  if ( m_nSize < 1 )
    return -1;
  m_aFlags = CIplStore::ms_pPool->m_aFlags;
  v5 = 0;
  for ( i = 16; ; i += 52 )
  {
    if ( (m_aFlags[v5] & 0x80u) == 0 )
    {
      v7 = (const char *)&(*v2->m_aStorage)[i];
      if ( v7 != (const char *)&word_10 && !strcasecmp((const char *)pName, v7) )
        break;
    }
    if ( ++v5 >= m_nSize )
      return -1;
  }
  return v5;
}
// 10: using guessed type __int16 word_10;

//----- (00280958) --------------------------------------------------------
bool __fastcall CIplStore::LoadIpl(int32 index, uint8 *pData, int32 size)
{
  uint8 *v5; // r4
  int *v6; // r1
  __int64 v7; // kr00_8
  unsigned int v8; // s4
  int v9; // r5
  unsigned int v10; // r12
  unsigned int v11; // lr
  unsigned int v12; // s2
  float v13; // s0
  int v14; // r8
  int v15; // r10
  int v16; // r11
  float v17; // s6
  int v18; // r1
  int v20; // r0
  CEntity **v21; // r0
  unsigned __int8 *v22; // r0
  _BOOL4 v23; // r5
  uint8 *v24; // r0
  int v25; // r1
  int v26; // r1
  int v27; // r1
  int v28; // r1
  int v29; // r1
  int v30; // r1
  bool v31; // zf
  int v32; // r1
  bool v33; // zf
  CEntity *ObjectInstance; // r5
  CEntity *m_pLod; // r0
  CEntity *v36; // r0
  unsigned int v37; // r6
  int v38; // r10
  uint8 *v39; // r0
  CEntity *v40; // r5
  CEntity *v41; // r0
  CEntity *v42; // r0
  uint8 *v43; // r0
  int v44; // r1
  int v45; // r1
  int v46; // r1
  CFileCarGenerator *v47; // r0
  unsigned int v48; // r5
  int v49; // r6
  CEntity **v50; // [sp+30h] [bp-28h]
  int32 v51; // [sp+34h] [bp-24h] BYREF
  uint8 *ppData[8]; // [sp+38h] [bp-20h] BYREF

  v51 = size;
  ppData[0] = pData;
  if ( (CIplStore::ms_pPool->m_aFlags[index] & 0x80u) != 0 )
    v5 = 0;
  else
    v5 = CIplStore::ms_pPool->m_aStorage[index];
  if ( *(float *)v5 > *((float *)v5 + 2) || *((float *)v5 + 3) > *((float *)v5 + 1) )
  {
    CIplStore::LoadIplBoundingBox(index, pData, size);
    v6 = dword_280D08;
    if ( !v5[49] )
      v6 = &dword_280D08[1];
    v7 = *((_QWORD *)v5 + 2);
    *(float *)&v8 = *(float *)v6 + *((float *)v5 + 2);
    v9 = *((_DWORD *)v5 + 6);
    v10 = *((_DWORD *)v5 + 7);
    v11 = *((_DWORD *)v5 + 8);
    *(float *)&v12 = *(float *)v6 + *((float *)v5 + 1);
    v13 = *(float *)v5 - *(float *)v6;
    v14 = *((_DWORD *)v5 + 9);
    v15 = *((_DWORD *)v5 + 10);
    v16 = *((_DWORD *)v5 + 11);
    v17 = *((float *)v5 + 3) - *(float *)v6;
    v18 = *((_DWORD *)v5 + 12);
    *(float *)v5 = v13;
    *((_DWORD *)v5 + 1) = v12;
    *((_DWORD *)v5 + 2) = v8;
    *((float *)v5 + 3) = v17;
    CColAccel::setIplDef(
      index,
      v13,
      __SPAIR64__(v8, v12),
      v17,
      v7,
      SHIDWORD(v7),
      v9,
      __SPAIR64__(v11, v10),
      v14,
      v15,
      v16,
      v18);
    CQuadTreeNode::AddItem(CIplStore::ms_pQuadTree, v5, (const CRect *)v5);
    goto LABEL_9;
  }
  v20 = *((__int16 *)v5 + 21);
  if ( v20 == -1 )
    v21 = 0;
  else
    v21 = ppEntityIndexArray[v20];
  v50 = v21;
  if ( strncmp((const char *)pData, "bnry", 4u) )
  {
    v22 = CFileLoader::LoadLine(ppData, &v51);
    if ( !v22 )
      goto LABEL_9;
    v23 = 0;
    while ( 1 )
    {
      v30 = *v22;
      v31 = v30 == 0;
      if ( *v22 )
        v31 = v30 == 35;
      if ( v31 )
        goto LABEL_48;
      if ( v23 )
        break;
      if ( v30 != 105 || v22[1] != 110 || v22[2] != 115 )
        goto LABEL_47;
      v23 = v22[3] == 116;
LABEL_48:
      v22 = CFileLoader::LoadLine(ppData, &v51);
      if ( !v22 )
        goto LABEL_9;
    }
    if ( v30 != 101 )
      goto LABEL_41;
    v32 = v22[1];
    v33 = v32 == 110;
    if ( v32 == 110 )
      v33 = v22[2] == 100;
    if ( !v33 )
    {
LABEL_41:
      ObjectInstance = CFileLoader::LoadObjectInstance(v22);
      m_pLod = ObjectInstance->m_pLod;
      ObjectInstance->m_iplIndex = index;
      if ( m_pLod == (CEntity *)-1 )
      {
        ObjectInstance->m_pLod = 0;
      }
      else
      {
        v36 = v50[(_DWORD)m_pLod];
        ObjectInstance->m_pLod = v36;
        ++v36->numLodChildren;
      }
      (*((void (__fastcall **)(CEntity *))ObjectInstance->_vptr$CPlaceable + 2))(ObjectInstance);
      if ( (CIplStore::ms_pPool->m_aFlags[index] & 0x80u) != 0 )
        v24 = 0;
      else
        v24 = CIplStore::ms_pPool->m_aStorage[index];
      v25 = *(_BYTE *)&ObjectInstance->m_info & 7;
      if ( v25 == 5 )
      {
        v28 = (char *)ObjectInstance - (char *)CPools::ms_pDummyPool->m_aStorage;
        v23 = 1;
        v29 = -286331153 * (v28 >> 2);
        if ( v29 < *((__int16 *)v24 + 19) )
          *((_WORD *)v24 + 19) = v29;
        if ( v29 > *((__int16 *)v24 + 20) )
          *((_WORD *)v24 + 20) = v29;
      }
      else if ( v25 == 1 )
      {
        v26 = (char *)ObjectInstance - (char *)CPools::ms_pBuildingPool->m_aStorage;
        v23 = 1;
        v27 = -286331153 * (v26 >> 2);
        if ( v27 < *((__int16 *)v24 + 17) )
          *((_WORD *)v24 + 17) = v27;
        if ( v27 > *((__int16 *)v24 + 18) )
          *((_WORD *)v24 + 18) = v27;
      }
      else
      {
        v23 = 1;
      }
      goto LABEL_48;
    }
LABEL_47:
    v23 = 0;
    goto LABEL_48;
  }
  if ( *((__int16 *)pData + 2) >= 1 )
  {
    v37 = 1;
    v38 = 0;
    v39 = &pData[*((_DWORD *)pData + 7)];
    *((_DWORD *)pData + 7) = v39;
    while ( 1 )
    {
      v40 = CFileLoader::LoadObjectInstance((CFileObjectInstance *)&v39[v38], 0);
      v41 = v40->m_pLod;
      v40->m_iplIndex = index;
      if ( v41 == (CEntity *)-1 )
      {
        v40->m_pLod = 0;
      }
      else
      {
        v42 = v50[(_DWORD)v41];
        v40->m_pLod = v42;
        ++v42->numLodChildren;
      }
      (*((void (__fastcall **)(CEntity *))v40->_vptr$CPlaceable + 2))(v40);
      v43 = (CIplStore::ms_pPool->m_aFlags[index] & 0x80u) != 0 ? 0 : CIplStore::ms_pPool->m_aStorage[index];
      v44 = *(_BYTE *)&v40->m_info & 7;
      if ( v44 == 5 )
      {
        v46 = -286331153 * (((char *)v40 - (char *)CPools::ms_pDummyPool->m_aStorage) >> 2);
        if ( v46 < *((__int16 *)v43 + 19) )
          *((_WORD *)v43 + 19) = v46;
        if ( v46 > *((__int16 *)v43 + 20) )
          *((_WORD *)v43 + 20) = v46;
      }
      else if ( v44 == 1 )
      {
        v45 = -286331153 * (((char *)v40 - (char *)CPools::ms_pBuildingPool->m_aStorage) >> 2);
        if ( v45 < *((__int16 *)v43 + 17) )
          *((_WORD *)v43 + 17) = v45;
        if ( v45 > *((__int16 *)v43 + 18) )
          *((_WORD *)v43 + 18) = v45;
      }
      if ( v37 >= *((__int16 *)pData + 2) )
        break;
      ++v37;
      v39 = (uint8 *)*((_DWORD *)pData + 7);
      v38 += 40;
    }
  }
  if ( *((__int16 *)pData + 10) >= 1 )
  {
    v47 = (CFileCarGenerator *)&pData[*((_DWORD *)pData + 15)];
    *((_DWORD *)pData + 15) = v47;
    CFileLoader::LoadCarGenerator(v47, index);
    if ( *((unsigned __int16 *)pData + 10) >= 2u )
    {
      v48 = 1;
      v49 = 48;
      do
      {
        CFileLoader::LoadCarGenerator((CFileCarGenerator *)(*((_DWORD *)pData + 15) + v49), index);
        ++v48;
        v49 += 48;
      }
      while ( v48 < *((__int16 *)pData + 10) );
    }
  }
LABEL_9:
  v5[45] = 1;
  return 1;
}
// 280B5C: conditional instruction was optimized away because r5.4==1
// 280D08: using guessed type int dword_280D08[2];

//----- (00280D14) --------------------------------------------------------
bool __fastcall CIplStore::LoadIplBoundingBox(int32 index, uint8 *pData, int32 size)
{
  uint8 *v5; // r4
  int v6; // r0
  CEntity **v7; // r0
  unsigned __int8 *v8; // r0
  _BOOL4 v9; // r5
  int v10; // r1
  bool v11; // zf
  int v12; // r1
  bool v13; // zf
  CEntity *v14; // r5
  CEntity *v15; // r0
  CEntity *v16; // r0
  CEntity **v17; // r0
  uint8 *v18; // r0
  int v19; // r1
  int v20; // r1
  int v21; // r1
  unsigned int v22; // r8
  int v23; // r9
  uint8 *v24; // r0
  CEntity *ObjectInstance; // r6
  CEntity *m_pLod; // r0
  CEntity *v27; // r0
  CEntity **v28; // r0
  uint8 *v29; // r0
  int v30; // r1
  int v31; // r1
  int v32; // r1
  CEntity **v34; // [sp+8h] [bp-48h]
  float v35; // [sp+10h] [bp-40h] BYREF
  float v36; // [sp+14h] [bp-3Ch]
  float v37; // [sp+18h] [bp-38h]
  float v38; // [sp+1Ch] [bp-34h]
  int32 v39; // [sp+20h] [bp-30h] BYREF
  uint8 *ppData[11]; // [sp+24h] [bp-2Ch] BYREF

  v39 = size;
  ppData[0] = pData;
  if ( (CIplStore::ms_pPool->m_aFlags[index] & 0x80u) != 0 )
    v5 = 0;
  else
    v5 = CIplStore::ms_pPool->m_aStorage[index];
  v6 = *((__int16 *)v5 + 21);
  if ( v6 == -1 )
    v7 = 0;
  else
    v7 = ppEntityIndexArray[v6];
  v34 = v7;
  if ( !strncmp((const char *)pData, "bnry", 4u) )
  {
    if ( *((__int16 *)pData + 2) >= 1 )
    {
      v22 = 1;
      v23 = 0;
      v24 = &pData[*((_DWORD *)pData + 7)];
      *((_DWORD *)pData + 7) = v24;
      while ( 1 )
      {
        ObjectInstance = CFileLoader::LoadObjectInstance((CFileObjectInstance *)&v24[v23], 0);
        m_pLod = ObjectInstance->m_pLod;
        ObjectInstance->m_iplIndex = index;
        if ( m_pLod == (CEntity *)-1 )
        {
          ObjectInstance->m_pLod = 0;
        }
        else
        {
          v27 = v34[(_DWORD)m_pLod];
          ObjectInstance->m_pLod = v27;
          ++v27->numLodChildren;
          v28 = ppEntityArrayToUpdate;
          if ( ppEntityArrayToUpdate )
          {
            *ppEntityArrayToUpdate = ObjectInstance;
            ppEntityArrayToUpdate = v28 + 1;
          }
        }
        if ( CModelInfo::ms_modelInfoPtrs[ObjectInstance->m_nModelIndex]->m_lodDistance > 150.0 )
          v5[49] = 1;
        (*((void (__fastcall **)(CEntity *))ObjectInstance->_vptr$CPlaceable + 2))(ObjectInstance);
        v29 = (CIplStore::ms_pPool->m_aFlags[index] & 0x80u) != 0 ? 0 : CIplStore::ms_pPool->m_aStorage[index];
        v30 = *(_BYTE *)&ObjectInstance->m_info & 7;
        if ( v30 == 5 )
        {
          v32 = -286331153 * (((char *)ObjectInstance - (char *)CPools::ms_pDummyPool->m_aStorage) >> 2);
          if ( v32 < *((__int16 *)v29 + 19) )
            *((_WORD *)v29 + 19) = v32;
          if ( v32 > *((__int16 *)v29 + 20) )
            *((_WORD *)v29 + 20) = v32;
        }
        else if ( v30 == 1 )
        {
          v31 = -286331153 * (((char *)ObjectInstance - (char *)CPools::ms_pBuildingPool->m_aStorage) >> 2);
          if ( v31 < *((__int16 *)v29 + 17) )
            *((_WORD *)v29 + 17) = v31;
          if ( v31 > *((__int16 *)v29 + 18) )
            *((_WORD *)v29 + 18) = v31;
        }
        (*((void (__fastcall **)(float *, CEntity *))ObjectInstance->_vptr$CPlaceable + 10))(&v35, ObjectInstance);
        if ( v35 < *(float *)v5 )
          *(float *)v5 = v35;
        if ( v37 > *((float *)v5 + 2) )
          *((float *)v5 + 2) = v37;
        if ( v38 < *((float *)v5 + 3) )
          *((float *)v5 + 3) = v38;
        if ( v36 > *((float *)v5 + 1) )
          *((float *)v5 + 1) = v36;
        if ( v22 >= *((__int16 *)pData + 2) )
          break;
        ++v22;
        v24 = (uint8 *)*((_DWORD *)pData + 7);
        v23 += 40;
      }
    }
  }
  else
  {
    v8 = CFileLoader::LoadLine(ppData, &v39);
    if ( v8 )
    {
      v9 = 0;
      while ( 1 )
      {
        v10 = *v8;
        v11 = v10 == 0;
        if ( *v8 )
          v11 = v10 == 35;
        if ( v11 )
          goto LABEL_51;
        if ( v9 )
          break;
        if ( v10 != 105 || v8[1] != 110 || v8[2] != 115 )
          goto LABEL_25;
        v9 = v8[3] == 116;
LABEL_51:
        v8 = CFileLoader::LoadLine(ppData, &v39);
        if ( !v8 )
          return 1;
      }
      if ( v10 != 101 )
        goto LABEL_18;
      v12 = v8[1];
      v13 = v12 == 110;
      if ( v12 == 110 )
        v13 = v8[2] == 100;
      if ( !v13 )
      {
LABEL_18:
        v14 = CFileLoader::LoadObjectInstance(v8);
        v15 = v14->m_pLod;
        v14->m_iplIndex = index;
        if ( v15 == (CEntity *)-1 )
        {
          v14->m_pLod = 0;
        }
        else
        {
          v16 = v34[(_DWORD)v15];
          v14->m_pLod = v16;
          ++v16->numLodChildren;
          v17 = ppEntityArrayToUpdate;
          if ( ppEntityArrayToUpdate )
          {
            *ppEntityArrayToUpdate = v14;
            ppEntityArrayToUpdate = v17 + 1;
          }
        }
        if ( CModelInfo::ms_modelInfoPtrs[v14->m_nModelIndex]->m_lodDistance > 150.0 )
          v5[49] = 1;
        (*((void (__fastcall **)(CEntity *))v14->_vptr$CPlaceable + 2))(v14);
        if ( (CIplStore::ms_pPool->m_aFlags[index] & 0x80u) != 0 )
          v18 = 0;
        else
          v18 = CIplStore::ms_pPool->m_aStorage[index];
        v19 = *(_BYTE *)&v14->m_info & 7;
        if ( v19 == 5 )
        {
          v21 = -286331153 * (((char *)v14 - (char *)CPools::ms_pDummyPool->m_aStorage) >> 2);
          if ( v21 < *((__int16 *)v18 + 19) )
            *((_WORD *)v18 + 19) = v21;
          if ( v21 > *((__int16 *)v18 + 20) )
            *((_WORD *)v18 + 20) = v21;
        }
        else if ( v19 == 1 )
        {
          v20 = -286331153 * (((char *)v14 - (char *)CPools::ms_pBuildingPool->m_aStorage) >> 2);
          if ( v20 < *((__int16 *)v18 + 17) )
            *((_WORD *)v18 + 17) = v20;
          if ( v20 > *((__int16 *)v18 + 18) )
            *((_WORD *)v18 + 18) = v20;
        }
        (*((void (__fastcall **)(float *, CEntity *))v14->_vptr$CPlaceable + 10))(&v35, v14);
        v9 = 1;
        if ( v35 < *(float *)v5 )
          *(float *)v5 = v35;
        if ( v37 > *((float *)v5 + 2) )
          *((float *)v5 + 2) = v37;
        if ( v38 < *((float *)v5 + 3) )
          *((float *)v5 + 3) = v38;
        if ( v36 > *((float *)v5 + 1) )
          *((float *)v5 + 1) = v36;
        goto LABEL_51;
      }
LABEL_25:
      v9 = 0;
      goto LABEL_51;
    }
  }
  return 1;
}
// 280DD2: conditional instruction was optimized away because r5.4==1

//----- (0028112C) --------------------------------------------------------
CEntity **__fastcall CIplStore::GetIplEntityIndexArray(int32 ipl)
{
  return ppEntityIndexArray[ipl];
}

//----- (0028113C) --------------------------------------------------------
void __fastcall CIplStore::IncludeEntity(int32 index, CEntity *pEntity)
{
  uint8 *v2; // r0
  int v3; // r2
  int v4; // r1
  int v5; // r1

  if ( (CIplStore::ms_pPool->m_aFlags[index] & 0x80u) != 0 )
    v2 = 0;
  else
    v2 = CIplStore::ms_pPool->m_aStorage[index];
  v3 = *(_BYTE *)&pEntity->m_info & 7;
  if ( v3 == 5 )
  {
    v5 = -286331153 * (((char *)pEntity - (char *)CPools::ms_pDummyPool->m_aStorage) >> 2);
    if ( v5 < *((__int16 *)v2 + 19) )
      *((_WORD *)v2 + 19) = v5;
    if ( v5 > *((__int16 *)v2 + 20) )
      *((_WORD *)v2 + 20) = v5;
  }
  else if ( v3 == 1 )
  {
    v4 = -286331153 * (((char *)pEntity - (char *)CPools::ms_pBuildingPool->m_aStorage) >> 2);
    if ( v4 < *((__int16 *)v2 + 17) )
      *((_WORD *)v2 + 17) = v4;
    if ( v4 > *((__int16 *)v2 + 18) )
      *((_WORD *)v2 + 18) = v4;
  }
}

//----- (002811D4) --------------------------------------------------------
CRect *__fastcall CIplStore::GetBoundingBox(int32 index)
{
  if ( (CIplStore::ms_pPool->m_aFlags[index] & 0x80u) == 0 )
    return (CRect *)CIplStore::ms_pPool->m_aStorage[index];
  else
    return 0;
}

//----- (002811F4) --------------------------------------------------------
void __fastcall CIplStore::AddIplsNeededAtPosn(const CVector *posn)
{
  __int64 v1; // d16

  gCheckIplPosn = 1;
  v1 = *(_QWORD *)&posn->x;
  gIplPosn.z = posn->z;
  *(_QWORD *)&gIplPosn.x = v1;
}
// 6DFDA4: using guessed type char gCheckIplPosn;

//----- (00281218) --------------------------------------------------------
void CIplStore::ClearIplsNeededAtPosn()
{
  gCheckIplPosn = 0;
}
// 6DFDA4: using guessed type char gCheckIplPosn;

//----- (00281228) --------------------------------------------------------
void __fastcall CIplStore::EnableDynamicStreaming(int32 index, bool bEnable)
{
  CIplStore::ms_pPool->m_aStorage[index][47] = !bEnable;
}

//----- (00281248) --------------------------------------------------------
int32 __fastcall CIplStore::FindRelatedIplSlot(const unsigned __int8 *pFilename)
{
  char *v1; // r0
  char *v2; // r4
  char *v3; // r0
  char *v4; // r5
  int v5; // r2
  unsigned int v6; // r1
  unsigned int v7; // r4
  bool v8; // cf
  char *v9; // r3
  char *v10; // r6
  unsigned int v11; // r2
  __int64 v12; // d16
  __int64 v13; // d17
  char *v14; // r2
  char v15; // t1
  CPool<IplDef,IplDef> *v16; // r9
  int32 m_nSize; // r10
  uint8 *m_aFlags; // r6
  int32 v19; // r4
  int i; // r5
  const char *v21; // r1
  char v23[32]; // [sp+4h] [bp-3Ch] BYREF

  v1 = strrchr((const char *)pFilename, 92);
  v2 = v1;
  if ( !v1 )
    return -1;
  v3 = strchr(v1, 46);
  if ( !v3 )
    return -1;
  v4 = v2 + 1;
  if ( v2 + 1 == v3 )
  {
    v6 = 0;
    goto LABEL_19;
  }
  v5 = ~(unsigned int)v2;
  v6 = (unsigned int)&v3[~(unsigned int)v2];
  if ( v6 < 0x10 )
    goto LABEL_14;
  v7 = v6 & 0xFFFFFFF0;
  if ( (v6 & 0xFFFFFFF0) == 0 )
    goto LABEL_14;
  v8 = v23 >= v3;
  if ( v23 < v3 )
    v8 = v4 >= &v23[v5 + (int)v3];
  if ( !v8 )
  {
LABEL_14:
    v7 = 0;
    v9 = v4;
LABEL_15:
    v14 = &v23[v7];
    do
    {
      v15 = *v9++;
      *v14++ = v15;
    }
    while ( v3 != v9 );
    goto LABEL_19;
  }
  v9 = &v4[v7];
  v10 = v23;
  v11 = v6 & 0xFFFFFFF0;
  do
  {
    v12 = *(_QWORD *)v4;
    v13 = *((_QWORD *)v4 + 1);
    v4 += 16;
    v11 -= 16;
    *(_QWORD *)v10 = v12;
    *((_QWORD *)v10 + 1) = v13;
    v10 += 16;
  }
  while ( v11 );
  if ( v7 != v6 )
    goto LABEL_15;
LABEL_19:
  *(_DWORD *)&v23[v6] = 1920234335;
  *(_DWORD *)&v23[v6 + 4] = (char *)cos64 + 5;
  v16 = CIplStore::ms_pPool;
  m_nSize = CIplStore::ms_pPool->m_nSize;
  if ( m_nSize < 1 )
    return -1;
  m_aFlags = CIplStore::ms_pPool->m_aFlags;
  v19 = 0;
  for ( i = 16; ; i += 52 )
  {
    if ( (m_aFlags[v19] & 0x80u) == 0 )
    {
      v21 = (const char *)&(*v16->m_aStorage)[i];
      if ( v21 != (const char *)&word_10 && !strcasecmp(v23, v21) )
        break;
    }
    if ( ++v19 >= m_nSize )
      return -1;
  }
  return v19;
}
// 10: using guessed type __int16 word_10;
// 281248: using guessed type char var_3C[32];

//----- (0028134C) --------------------------------------------------------
int32 __fastcall CIplStore::SetupRelatedIpls(
        const unsigned __int8 *pFilename,
        int32 index,
        CEntity **ppLoadedBuildingsArray)
{
  char *v4; // r0
  char *v5; // r4
  char *v6; // r0
  char *v7; // r6
  int v8; // r2
  unsigned int v9; // r4
  unsigned int v10; // r1
  bool v11; // cf
  char *v12; // r3
  char *v13; // r5
  unsigned int v14; // r2
  __int64 v15; // d16
  __int64 v16; // d17
  char *v18; // r1
  char v19; // t1
  bool v20; // r0
  _BOOL4 isCacheLoading; // r0
  CPool<IplDef,IplDef> *v22; // r9
  int32 m_nSize; // r1
  int v24; // r8
  int32 v25; // r5
  uint8 *v26; // r4
  size_t v27; // r0
  __int64 v28; // d16
  __int64 v29; // d17
  __int64 v30; // d18
  __int64 v31; // d19
  __int64 v32; // d20
  __int64 v33; // d21
  int v34; // r6
  int32 v35; // r8
  int v36; // r10
  size_t v37; // r0
  CEntity **v38; // r1
  CEntity **v39; // [sp+Ch] [bp-84h]
  bool v40; // [sp+10h] [bp-80h]
  __int16 v41; // [sp+14h] [bp-7Ch]
  IplDef v42; // [sp+18h] [bp-78h] BYREF
  char v43[32]; // [sp+50h] [bp-40h] BYREF

  v41 = index;
  v4 = strrchr((const char *)pFilename, 92);
  v5 = v4;
  if ( !v4 )
    return 0;
  v6 = strchr(v4, 46);
  if ( !v6 )
    return 0;
  v7 = v5 + 1;
  if ( v5 + 1 == v6 )
  {
    v9 = 0;
  }
  else
  {
    v8 = ~(unsigned int)v5;
    v9 = (unsigned int)&v6[~(unsigned int)v5];
    if ( v9 < 0x10 )
      goto LABEL_15;
    v10 = v9 & 0xFFFFFFF0;
    if ( (v9 & 0xFFFFFFF0) == 0 )
      goto LABEL_15;
    v11 = v43 >= v6;
    if ( v43 < v6 )
      v11 = v7 >= &v43[v8 + (int)v6];
    if ( v11 )
    {
      v12 = &v7[v10];
      v13 = v43;
      v14 = v9 & 0xFFFFFFF0;
      do
      {
        v15 = *(_QWORD *)v7;
        v16 = *((_QWORD *)v7 + 1);
        v7 += 16;
        v14 -= 16;
        *(_QWORD *)v13 = v15;
        *((_QWORD *)v13 + 1) = v16;
        v13 += 16;
      }
      while ( v14 );
      if ( v10 == v9 )
        goto LABEL_20;
    }
    else
    {
LABEL_15:
      v10 = 0;
      v12 = v7;
    }
    v18 = &v43[v10];
    do
    {
      v19 = *v12++;
      *v18++ = v19;
    }
    while ( v6 != v12 );
  }
LABEL_20:
  v43[v9] = 0;
  v20 = !strcasecmp(v43, "gen_int1")
     || !strcasecmp(v43, "gen_int2")
     || !strcasecmp(v43, "gen_int3")
     || !strcasecmp(v43, "gen_int4")
     || !strcasecmp(v43, "gen_int5")
     || !strcasecmp(v43, "gen_intb")
     || !strcasecmp(v43, "savehous")
     || !strcasecmp(v43, "stadint")
     || !strcasecmp(v43, "int_la")
     || !strcasecmp(v43, "int_sf")
     || !strcasecmp(v43, "int_veg")
     || !strcasecmp(v43, "int_cont")
     || !strcasecmp(v43, "levelmap");
  v40 = v20;
  *(_DWORD *)&v43[v9] = 1920234335;
  *(_DWORD *)&v43[v9 + 4] = (char *)cos64 + 5;
  ppEntityArrayToUpdate = ppLoadedBuildingsArray;
  isCacheLoading = CColAccel::isCacheLoading();
  v22 = CIplStore::ms_pPool;
  m_nSize = CIplStore::ms_pPool->m_nSize;
  v39 = ppLoadedBuildingsArray;
  if ( isCacheLoading )
  {
    if ( m_nSize >= 1 )
    {
      v24 = 0;
      v25 = 0;
      do
      {
        if ( (v22->m_aFlags[v25] & 0x80u) == 0 )
        {
          v26 = v22->m_aStorage[v24];
          if ( v26 )
          {
            v27 = strlen(v43);
            if ( !strncasecmp(v43, (const char *)v26 + 16, v27) )
            {
              CColAccel::getIplDef(&v42, v25);
              v28 = *(_QWORD *)&v42.bb.left;
              v29 = *(_QWORD *)&v42.bb.right;
              v30 = *(_QWORD *)&v42.name[16];
              v31 = *(_QWORD *)&v42.lastDummy;
              v32 = *(_QWORD *)v42.name;
              v33 = *(_QWORD *)&v42.name[8];
              *((_WORD *)v26 + 24) = *(_WORD *)&v42.ignoreWhenDeleted;
              *((_QWORD *)v26 + 4) = v30;
              *((_QWORD *)v26 + 5) = v31;
              *(_QWORD *)v26 = v28;
              *((_QWORD *)v26 + 1) = v29;
              *((_QWORD *)v26 + 2) = v32;
              *((_QWORD *)v26 + 3) = v33;
              v26[44] = v40;
              *((_WORD *)v26 + 21) = v41;
              v26[45] = 0;
              CQuadTreeNode::AddItem(CIplStore::ms_pQuadTree, v26, (const CRect *)v26);
              v22 = CIplStore::ms_pPool;
            }
          }
        }
        ++v25;
        ++v24;
      }
      while ( v25 < v22->m_nSize );
    }
  }
  else
  {
    if ( m_nSize >= 1 )
    {
      v34 = 0;
      v35 = 0;
      do
      {
        if ( (v22->m_aFlags[v35] & 0x80u) == 0 )
        {
          v36 = (int)v22->m_aStorage[v34];
          if ( v36 )
          {
            v37 = strlen(v43);
            if ( !strncasecmp(v43, (const char *)(v36 + 16), v37) )
            {
              *(_BYTE *)(v36 + 44) = v40;
              *(_WORD *)(v36 + 42) = v41;
              CIplStore::ms_pPool->m_aStorage[v34][47] = 0;
              CStreaming::RequestModel(v35 + 25255, 8);
              v22 = CIplStore::ms_pPool;
            }
          }
        }
        ++v35;
        ++v34;
      }
      while ( v35 < v22->m_nSize );
    }
    CStreaming::LoadAllRequestedModels(0);
  }
  v38 = ppEntityArrayToUpdate;
  ppEntityArrayToUpdate = 0;
  return v38 - v39;
}
// 28134C: using guessed type char var_40[32];

//----- (002816A0) --------------------------------------------------------
void __fastcall CIplStore::RemoveRelatedIpls(int32 index)
{
  CPool<IplDef,IplDef> *v2; // r0
  int32 v3; // r5
  int v4; // r6

  v2 = CIplStore::ms_pPool;
  if ( CIplStore::ms_pPool->m_nSize >= 1 )
  {
    v3 = 0;
    v4 = 42;
    do
    {
      if ( (v2->m_aFlags[v3] & 0x80u) == 0
        && &(*v2->m_aStorage)[v4] != (uint8 *)&word_2A
        && *(__int16 *)&(*v2->m_aStorage)[v4] == index )
      {
        CStreaming::RemoveModel(v3 + 25255);
        v2 = CIplStore::ms_pPool;
      }
      ++v3;
      v4 += 52;
    }
    while ( v3 < v2->m_nSize );
  }
}
// 2A: using guessed type __int16 word_2A;

//----- (00281704) --------------------------------------------------------
void __fastcall SetIfIplIsRequired(const CVector2D *posn, void *data)
{
  float y; // s0
  float v3; // s2

  if ( *((_BYTE *)data + 44) )
  {
    if ( entityAreaCode )
    {
      if ( posn->x >= (float)(*(float *)data + 140.0) && posn->x <= (float)(*((float *)data + 2) + -140.0) )
      {
        y = posn->y;
        if ( y >= (float)(*((float *)data + 3) + 140.0) )
        {
          v3 = *((float *)data + 1) + -140.0;
          goto LABEL_11;
        }
      }
    }
  }
  else if ( posn->x >= *(float *)data && posn->x <= *((float *)data + 2) )
  {
    y = posn->y;
    if ( y >= *((float *)data + 3) )
    {
      v3 = *((float *)data + 1);
LABEL_11:
      if ( y <= v3 )
        *((_BYTE *)data + 46) = 1;
    }
  }
}

//----- (002817BC) --------------------------------------------------------
void __fastcall SetIfInteriorIplIsRequired(const CVector2D *posn, void *data)
{
  float y; // s0

  if ( *((_BYTE *)data + 44) )
  {
    if ( posn->x >= (float)(*(float *)data + 140.0) && posn->x <= (float)(*((float *)data + 2) + -140.0) )
    {
      y = posn->y;
      if ( y >= (float)(*((float *)data + 3) + 140.0) && y <= (float)(*((float *)data + 1) + -140.0) )
        *((_BYTE *)data + 46) = 1;
    }
  }
}

//----- (0028182C) --------------------------------------------------------
void __fastcall SetIfIplIsRequiredReducedBB(const CVector2D *posn, void *data)
{
  float y; // s0

  if ( posn->x >= (float)(*(float *)data + 160.0) && posn->x <= (float)(*((float *)data + 2) + -160.0) )
  {
    y = posn->y;
    if ( y >= (float)(*((float *)data + 3) + 160.0) && y <= (float)(*((float *)data + 1) + -160.0) )
    {
      if ( entityAreaCode )
      {
        if ( !*((_BYTE *)data + 44) )
          return;
      }
      else if ( *((_BYTE *)data + 44) )
      {
        return;
      }
      *((_BYTE *)data + 46) = 1;
    }
  }
}

//----- (002818B0) --------------------------------------------------------
void __fastcall CIplStore::SetIplsRequired(const CVector *posn, int32 areaCode)
{
  CPlayerPed *PlayerPed; // r0
  CQuadTreeNode *v4; // r0
  void **v5; // r2
  __int64 v6; // r2
  CVector2D v7; // [sp+0h] [bp-10h] BYREF

  if ( areaCode == -1 )
  {
    PlayerPed = FindPlayerPed(-1);
    if ( PlayerPed )
      areaCode = PlayerPed->m_areaCode;
    else
      areaCode = CGame::currArea;
  }
  entityAreaCode = areaCode;
  if ( areaCode && posn->z >= 900.0 )
  {
    v4 = CIplStore::ms_pQuadTree;
    v6 = *(_QWORD *)&posn->x;
    v7.x = posn->x;
    LODWORD(v6) = SetIfInteriorIplIsRequired;
  }
  else
  {
    v4 = CIplStore::ms_pQuadTree;
    if ( areaCode == CGame::currArea )
      v5 = &SetIfIplIsRequired;
    else
      v5 = &SetIfIplIsRequiredReducedBB;
    LODWORD(v6) = *v5;
    HIDWORD(v6) = LODWORD(posn->y);
    v7.x = posn->x;
  }
  v7.y = *((float *)&v6 + 1);
  CQuadTreeNode::ForAllMatching((int)v4, &v7, (void (*)(const CVector2D *, void *))v6);
}
// 675EF4: using guessed type void *SetIfIplIsRequiredReducedBB;
// 67749C: using guessed type void *SetIfIplIsRequired;

//----- (0028195C) --------------------------------------------------------
void __fastcall CIplStore::LoadIpls(CVector posn, int bLoadScene)
{
  float32x2_t v2; // d2
  float32x2_t v3; // d4
  float32x2_t v4; // d5
  float x; // r5
  float y; // r6
  CVehicle *PlayerVehicle; // r0
  int i; // r6
  int Type; // r0
  Int32 v11; // r1
  uint8 *v12; // r1
  Int32 Id; // r1
  int v14; // r3
  unsigned int v15; // r1
  CVector2D *v16; // r2
  CVector2D *v17; // r3
  int v18; // r6
  int v19; // r4
  uint8 *v20; // r5
  int v21; // [sp+0h] [bp-38h]
  CVector2D v22; // [sp+8h] [bp-30h] BYREF
  CVector posna; // [sp+10h] [bp-28h] BYREF

  x = posn.x;
  y = posn.y;
  posna = posn;
  if ( CStreaming::ms_disableStreaming )
    return;
  if ( FindPlayerPed(-1) )
  {
    if ( !bLoadScene )
    {
      PlayerVehicle = FindPlayerVehicle(-1, 0);
      if ( PlayerVehicle )
      {
        v3.n64_f32[0] = PlayerVehicle->m_vecMoveSpeed.y * 80.0;
        v4.n64_u32[0] = 1109393408;
        v2.n64_f32[0] = PlayerVehicle->m_vecMoveSpeed.x * 80.0;
        posna.y = vmin_f32(v3, v4).n64_f32[0] + y;
        posna.x = vmin_f32(v2, v4).n64_f32[0] + x;
      }
    }
  }
  v21 = bLoadScene;
  CIplStore::SetIplsRequired(&posna, -1);
  if ( gCheckIplPosn == 1 )
    CIplStore::SetIplsRequired(&gIplPosn, CGame::currArea);
  for ( i = 0; i != 75; ++i )
  {
    Type = CTheScripts::MissionCleanUp.cleanup_entities[i].Type;
    if ( Type == 2 )
    {
      Id = CTheScripts::MissionCleanUp.cleanup_entities[i].Id;
      if ( Id < 0 )
      {
        v12 = 0;
      }
      else
      {
        v14 = (unsigned __int8)Id;
        v15 = (unsigned int)Id >> 8;
        if ( CPools::ms_pPedPool->m_aFlags[v15] != v14 )
          continue;
        v12 = CPools::ms_pPedPool->m_aStorage[v15];
        if ( !v12 || *((_DWORD *)v12 + 64) || (*((_DWORD *)v12 + 275) & 0xFFFFFFFE) == 54 )
          continue;
      }
    }
    else
    {
      if ( Type != 1 )
        continue;
      v11 = CTheScripts::MissionCleanUp.cleanup_entities[i].Id;
      if ( v11 < 0 || CPools::ms_pVehiclePool->m_aFlags[(unsigned int)v11 >> 8] != (unsigned __int8)v11 )
        continue;
      v12 = CPools::ms_pVehiclePool->m_aStorage[(unsigned int)v11 >> 8];
      if ( v12 )
      {
        if ( *((_DWORD *)v12 + 64) || (v12[58] >> 3) - 2 >= 3u )
          continue;
        goto LABEL_26;
      }
    }
    if ( !v12 )
      continue;
LABEL_26:
    if ( (v12[69] & 0x60) == 0 )
    {
      entityAreaCode = v12[51];
      v16 = (CVector2D *)*((_DWORD *)v12 + 5);
      v17 = v16 + 6;
      if ( !v16 )
        v17 = (CVector2D *)(v12 + 4);
      v22 = *v17;
      CQuadTreeNode::ForAllMatching((int)CIplStore::ms_pQuadTree, &v22, SetIfIplIsRequiredReducedBB);
    }
  }
  v18 = 0;
  v19 = 0;
  do
  {
    if ( (CIplStore::ms_pPool->m_aFlags[v18 + 1] & 0x80u) == 0 )
    {
      v20 = CIplStore::ms_pPool->m_aStorage[v19];
      if ( !v20[99] )
      {
        if ( v20[98] )
        {
          if ( !v20[97] )
            CStreaming::RequestModel(v18 + 25256, 24);
          v20[98] = 0;
        }
        else if ( v20[97] )
        {
          CStreaming::RemoveModel(v18 + 25256);
          if ( v20[100] )
            v20[99] = 1;
        }
      }
    }
    ++v18;
    ++v19;
  }
  while ( v18 != 255 );
  if ( !v21 )
    gCheckIplPosn = 0;
}
// 2819B8: variable 'v3' is possibly undefined
// 2819B8: variable 'v4' is possibly undefined
// 2819BC: variable 'v2' is possibly undefined
// 675EF4: using guessed type void *SetIfIplIsRequiredReducedBB;
// 6DFDA4: using guessed type char gCheckIplPosn;

//----- (00281BB8) --------------------------------------------------------
void __fastcall CIplStore::EnsureIplsAreInMemory(const CVector *posn)
{
  int v2; // r8
  int v3; // r9
  uint8 *p_m_status; // r6
  CCamera *v5; // r12
  CMenuManager *v6; // r3
  uint8 *v7; // r10
  float y; // s0
  CMenuManager *v9; // [sp+0h] [bp-38h]
  CCamera *v10; // [sp+4h] [bp-34h]

  if ( !CStreaming::ms_disableStreaming && (!FindPlayerPed(-1) || CGame::currArea == FindPlayerPed(-1)->m_areaCode) )
  {
    CIplStore::SetIplsRequired(posn, -1);
    v2 = 0;
    v3 = 0;
    p_m_status = &CStreaming::ms_aInfoForModel[25256].m_status;
    v5 = &TheCamera;
    v6 = &FrontEndMenuManager;
    do
    {
      if ( (CIplStore::ms_pPool->m_aFlags[v3 + 1] & 0x80u) == 0 )
      {
        v7 = CIplStore::ms_pPool->m_aStorage[v2];
        if ( !v7[99] )
        {
          if ( v7[98] )
          {
            if ( posn->x >= (float)(*((float *)v7 + 13) + 190.0) && posn->x <= (float)(*((float *)v7 + 15) + -190.0) )
            {
              y = posn->y;
              if ( y >= (float)(*((float *)v7 + 16) + 190.0)
                && y <= (float)(*((float *)v7 + 14) + -190.0)
                && *p_m_status != 1 )
              {
                v9 = v6;
                v10 = v5;
                CStreaming::RequestModel(v3 + 25256, 24);
                if ( !CCamera::GetScreenFadeStatus(v10) )
                  CMenuManager::MessageScreen(v9, "LOADCOL", 0, 0);
                CTimer::Suspend();
                CStreaming::LoadAllRequestedModels(1);
                CTimer::Resume();
                v6 = v9;
                v5 = v10;
              }
            }
            v7[98] = 0;
          }
        }
      }
      ++v3;
      ++v2;
      p_m_status += 20;
    }
    while ( v3 != 255 );
  }
}
// 677DD0: using guessed type CStreamingInfo (*CStreaming::ms_aInfoForModel)[26316];

//----- (00281D40) --------------------------------------------------------
void __fastcall CIplStore::RequestIpls(const CVector *posn, int32 areaCode)
{
  int v3; // r6
  int i; // r4
  CPool<IplDef,IplDef>::StorageType *m_aStorage; // r5
  uint8 *v6; // r0
  float y; // s0

  CIplStore::SetIplsRequired(posn, areaCode);
  v3 = 98;
  for ( i = 0; i != 255; ++i )
  {
    if ( (CIplStore::ms_pPool->m_aFlags[i + 1] & 0x80u) == 0 )
    {
      m_aStorage = CIplStore::ms_pPool->m_aStorage;
      if ( (*CIplStore::ms_pPool->m_aStorage)[v3] )
      {
        v6 = &(*m_aStorage)[v3];
        if ( posn->x >= (float)(*(float *)&(*m_aStorage)[v3 - 46] + 190.0)
          && posn->x <= (float)(*(float *)(v6 - 38) + -190.0) )
        {
          y = posn->y;
          if ( y >= (float)(*(float *)(v6 - 34) + 190.0) && y <= (float)(*(float *)(v6 - 42) + -190.0) )
            CStreaming::RequestModel(i + 25256, 24);
        }
        (*m_aStorage)[v3] = 0;
      }
    }
    v3 += 52;
  }
}

//----- (00281E14) --------------------------------------------------------
bool __fastcall CIplStore::HaveIplsLoaded(const CVector *posn, int32 areaCode)
{
  int v3; // r1
  int i; // r2
  int v5; // r4
  CPool<IplDef,IplDef> *v6; // r1
  int v7; // r3
  uint8 *v8; // r5
  float y; // s4
  bool v10; // zf
  bool result; // r0
  int v12; // r6
  int j; // r2
  CPool<IplDef,IplDef>::StorageType *m_aStorage; // r1

  CIplStore::SetIplsRequired(posn, areaCode);
  v3 = 1;
  for ( i = 1; ; ++i )
  {
    v5 = v3;
    v6 = CIplStore::ms_pPool;
    v7 = (char)CIplStore::ms_pPool->m_aFlags[v5];
    if ( v7 < 0 )
      goto LABEL_12;
    v8 = CIplStore::ms_pPool->m_aStorage[i];
    if ( !v8[46] )
      goto LABEL_12;
    if ( posn->x >= (float)(*(float *)v8 + 190.0) && posn->x <= (float)(*((float *)v8 + 2) + -190.0) )
    {
      y = posn->y;
      if ( y >= (float)(*((float *)v8 + 3) + 190.0) && y <= (float)(*((float *)v8 + 1) + -190.0) )
      {
        v10 = v8[45] == 0;
        if ( !v8[45] )
          v10 = v8[47] == 0;
        if ( v10 )
          break;
      }
    }
    v8[46] = 0;
LABEL_12:
    v3 = v5 + 1;
    if ( v5 >= 255 )
      return 1;
  }
  result = 0;
  if ( v5 <= 255 )
  {
    v12 = v5 + 1;
    for ( j = i * 52 + 46; ; j += 52 )
    {
      if ( (v7 & 0x80u) == 0 )
      {
        m_aStorage = v6->m_aStorage;
        if ( &(*m_aStorage)[j] != (uint8 *)&word_2E )
          (*m_aStorage)[j] = 0;
      }
      if ( v12 - 1 > 254 )
        break;
      v6 = CIplStore::ms_pPool;
      LOBYTE(v7) = CIplStore::ms_pPool->m_aFlags[v12++];
    }
    return 0;
  }
  return result;
}
// 2E: using guessed type __int16 word_2E;

//----- (00281F0C) --------------------------------------------------------
void CIplStore::LoadAllRemainingIpls()
{
  int v0; // r4
  int32 v1; // r9
  int32 v2; // r5
  CPool<IplDef,IplDef>::StorageType *m_aStorage; // r8
  uint8 *v4; // r11
  __int64 v5; // d16
  __int64 v6; // d17
  __int64 v7; // d20
  __int64 v8; // d21
  __int64 v9; // d18
  __int64 v10; // d19
  uint8 *v11; // r0
  uint8 *v12; // r0
  IplDef v13; // [sp+8h] [bp-58h] BYREF

  v0 = 97;
  v1 = 0;
  do
  {
    v2 = v1++;
    if ( (CIplStore::ms_pPool->m_aFlags[v2 + 1] & 0x80u) == 0 )
    {
      m_aStorage = CIplStore::ms_pPool->m_aStorage;
      v4 = &(*CIplStore::ms_pPool->m_aStorage)[v0];
      if ( *(float *)(v4 - 45) > *(float *)(v4 - 37) || *(float *)(v4 - 33) > *(float *)(v4 - 41) )
      {
        if ( CColAccel::isCacheLoading() )
        {
          CColAccel::getIplDef(&v13, v1);
          v5 = *(_QWORD *)&v13.bb.left;
          v6 = *(_QWORD *)&v13.bb.right;
          v7 = *(_QWORD *)v13.name;
          v8 = *(_QWORD *)&v13.name[8];
          v9 = *(_QWORD *)&v13.name[16];
          v10 = *(_QWORD *)&v13.lastDummy;
          *(_WORD *)(v4 + 3) = *(_WORD *)&v13.ignoreWhenDeleted;
          v11 = v4 - 13;
          *(_QWORD *)v11 = v9;
          *((_QWORD *)v11 + 1) = v10;
          v12 = v4 - 29;
          *(_QWORD *)(v4 - 45) = v5;
          *(_QWORD *)(v4 - 37) = v6;
          *(_QWORD *)v12 = v7;
          *((_QWORD *)v12 + 1) = v8;
          (*m_aStorage)[v0] = 0;
          CQuadTreeNode::AddItem(CIplStore::ms_pQuadTree, v4 - 45, (const CRect *)(v4 - 45));
        }
        else
        {
          CStreaming::RequestModel(v2 + 25256, 24);
          CStreaming::LoadAllRequestedModels(1);
          CStreaming::RemoveModel(v2 + 25256);
        }
      }
    }
    v0 += 52;
  }
  while ( v1 != 255 );
}

//----- (00282028) --------------------------------------------------------
void __fastcall CIplStore::RequestIplAndIgnore(int32 index)
{
  uint8 *v1; // r4

  if ( (CIplStore::ms_pPool->m_aFlags[index] & 0x80u) != 0 )
    v1 = 0;
  else
    v1 = CIplStore::ms_pPool->m_aStorage[index];
  CStreaming::RequestModel(index + 25255, 8);
  *(_WORD *)(v1 + 47) = 1;
}

//----- (00282060) --------------------------------------------------------
void __fastcall CIplStore::RemoveIplAndIgnore(int32 index)
{
  uint8 *v1; // r4

  if ( (CIplStore::ms_pPool->m_aFlags[index] & 0x80u) != 0 )
    v1 = 0;
  else
    v1 = CIplStore::ms_pPool->m_aStorage[index];
  CStreaming::RemoveModel(index + 25255);
  *(_WORD *)(v1 + 47) = 1;
}

//----- (00282098) --------------------------------------------------------
void __fastcall CIplStore::RemoveIplWhenFarAway(int32 index)
{
  uint8 *v1; // r0

  if ( (CIplStore::ms_pPool->m_aFlags[index] & 0x80u) != 0 )
    v1 = 0;
  else
    v1 = CIplStore::ms_pPool->m_aStorage[index];
  *(_WORD *)(v1 + 47) = 256;
}

//----- (002820C4) --------------------------------------------------------
int32 __fastcall CIplStore::GetNewIplEntityIndexArray(int32 size)
{
  __int64 v1; // r0
  CEntity **v3; // r0
  int32 v4; // r1

  v1 = 4LL * (unsigned int)size;
  if ( !is_mul_ok(4u, size) )
    HIDWORD(v1) = 1;
  if ( HIDWORD(v1) )
    LODWORD(v1) = -1;
  v3 = (CEntity **)operator new[](v1);
  v4 = numEntityIndexArrays;
  ppEntityIndexArray[numEntityIndexArrays] = v3;
  numEntityIndexArrays = v4 + 1;
  return v4;
}

//----- (00282100) --------------------------------------------------------
void CAdjustableHUD::Toggle()
{
  void *v0; // r0
  CAdjustableHUD *v1; // r0
  CAdjustableHUD *v2; // r0

  if ( CAdjustableHUD::m_pInstance )
  {
    CAdjustableHUD::~CAdjustableHUD(CAdjustableHUD::m_pInstance);
    operator delete(v0);
    v1 = 0;
  }
  else
  {
    v2 = (CAdjustableHUD *)operator new(0x4B0u);
    CAdjustableHUD::CAdjustableHUD(v2);
  }
  CAdjustableHUD::m_pInstance = v1;
}
// 282112: variable 'v0' is possibly undefined
// 28212C: variable 'v1' is possibly undefined

//----- (00282140) --------------------------------------------------------
void __fastcall CAdjustableHUD::CAdjustableHUD(CAdjustableHUD *this)
{
  CRect *p_m_RectInCar; // r0
  int v3; // r4
  _QWORD *v4; // r0
  int v5; // r5
  int v6; // r9
  CTouchInterface::WidgetPositionIDs *v7; // r6
  CTouchInterface::WidgetIDs *v8; // r8
  int *v9; // r10
  int v10; // r4
  float v11; // s30
  float screenWidth; // s17
  float Width; // s21
  float Height; // s23
  float screenHeight; // s25
  float v16; // s19
  float v17; // s27
  float v18; // s29
  float v19; // s2
  float v20; // s4
  float v21; // s0
  RwInt32 v22; // r5
  float v23; // s23
  float v24; // s21
  float v25; // s17
  float v26; // s27
  float v27; // s25
  float v28; // s29
  float v29; // s0
  float v30; // s2
  float v31; // s25
  float v32; // s23
  float v33; // s19
  float v34; // s29
  float v35; // s21
  float v36; // s27
  float v37; // s31
  float v38; // s28
  float v39; // s24
  float v40; // s30
  float v41; // s26
  float v42; // s16
  float v43; // s2
  float v44; // s0
  bool v45; // cc
  float v46; // s0
  float v47; // s2
  RwInt32 v48; // r11
  float v49; // s27
  float v50; // s0
  float v51; // s25
  float v52; // s17
  float v53; // s21
  float v54; // s19
  float v55; // s16
  float v56; // s24
  float v57; // s26
  float v58; // s0
  float v59; // s2
  float *v60; // r0
  __int64 v61; // d17
  _QWORD *v62; // r1
  int v63; // r1
  int v64; // t1
  CTouchInterface::WidgetPositionIDs v65; // t1
  int v66; // t1
  TextureDatabaseRuntime *pMobileDB; // [sp+4h] [bp-94h]
  CAdjustableHUD *v68; // [sp+24h] [bp-74h]
  float fScaleY; // [sp+28h] [bp-70h] BYREF
  float fScaleX; // [sp+2Ch] [bp-6Ch] BYREF
  float fOriginY; // [sp+30h] [bp-68h] BYREF
  float fOriginX[25]; // [sp+34h] [bp-64h] BYREF

  p_m_RectInCar = &this->m_RectInCar;
  v3 = -760;
  *(_QWORD *)&p_m_RectInCar->left = 0xC974240049742400LL;
  *(_QWORD *)&p_m_RectInCar->right = 0x49742400C9742400LL;
  *(_QWORD *)&this->m_RectOnFoot.left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_RectOnFoot.right = 0x49742400C9742400LL;
  *(_QWORD *)&this->m_RectCancel.left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_RectCancel.right = 0x49742400C9742400LL;
  *(_QWORD *)&this->m_RectSave.left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_RectSave.right = 0x49742400C9742400LL;
  *(_QWORD *)&this->m_RectRestoreDefaults.left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_RectRestoreDefaults.right = 0x49742400C9742400LL;
  *(_QWORD *)&this->m_RectOverlapDialog.left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_RectOverlapDialog.right = 0x49742400C9742400LL;
  do
  {
    v4 = (_QWORD *)((char *)&this->m_SavedButtonPositions[0].right + v3);
    *v4 = 0xC974240049742400LL;
    v4[1] = 0x49742400C9742400LL;
    CSprite2d::CSprite2d((CSprite2d *)((char *)&this->m_SavedButtonPositions[1].right + v3));
    CSprite2d::CSprite2d((CSprite2d *)((char *)&this->m_SavedButtonPositions[1].bottom + v3));
    v3 += 40;
  }
  while ( v3 );
  *(_QWORD *)&this->m_SavedButtonPositions[2].left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[2].right = 0x49742400C9742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[1].left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[1].right = 0x49742400C9742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[3].left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[3].right = 0x49742400C9742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[4].left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[4].right = 0x49742400C9742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[5].left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[5].right = 0x49742400C9742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[6].left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[6].right = 0x49742400C9742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[7].left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[7].right = 0x49742400C9742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[8].left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[8].right = 0x49742400C9742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[9].left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[9].right = 0x49742400C9742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[10].left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[10].right = 0x49742400C9742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[11].left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[11].right = 0x49742400C9742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[12].left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[12].right = 0x49742400C9742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[13].left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[13].right = 0x49742400C9742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[14].left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[14].right = 0x49742400C9742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[15].left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[15].right = 0x49742400C9742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[16].left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[16].right = 0x49742400C9742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[17].left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[17].right = 0x49742400C9742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[18].left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[18].right = 0x49742400C9742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[0].left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_SavedButtonPositions[0].right = 0x49742400C9742400LL;
  v5 = 1;
  if ( FindPlayerPed(-1) && FindPlayerPed(-1)->m_nPedState == PED_DRIVING )
    v5 = 2;
  v6 = 864;
  this->m_nSelectedButton = -1;
  this->m_nAdjustmentMode = v5;
  this->m_nInitialTouchID = -1;
  this->m_vecDragOffset.x = 0.0;
  this->m_vecDragOffset.y = 0.0;
  this->m_bQueuedExit = 0;
  *(_WORD *)&this->m_bMovedButton = 0;
  v7 = PositionIDs;
  v8 = WidgetIDs;
  v9 = nAdjustmentModeFlags;
  pMobileDB = CTouchInterface::LoadTextureDB();
  v10 = 0;
  v68 = this;
  do
  {
    fOriginY = 0.0;
    fOriginX[0] = 0.0;
    fScaleY = 0.0;
    fScaleX = 0.0;
    CTouchInterface::GetWidgetPosition(*v7, fOriginX, &fOriginY, &fScaleX, &fScaleY);
    v11 = fOriginX[0];
    screenWidth = (float)RsGlobal.screenWidth;
    Width = (float)(unsigned int)OS_ScreenGetWidth();
    Height = (float)(unsigned int)OS_ScreenGetHeight();
    screenHeight = (float)RsGlobal.screenHeight;
    v16 = fScaleX;
    v17 = (float)RsGlobal.screenWidth;
    v18 = (float)(unsigned int)OS_ScreenGetWidth();
    v19 = 0.0;
    v20 = 0.0;
    v21 = v18 / (float)(unsigned int)OS_ScreenGetHeight();
    if ( (float)(Width / Height) > 1.9 )
      v19 = 30.0;
    if ( v21 > 1.9 )
      v20 = 30.0;
    v22 = RsGlobal.screenHeight;
    v23 = (float)(v17 - v20) / 640.0;
    if ( (float)(v17 / screenHeight) > 1.8 )
      v23 = (float)(v23 + (float)((float)RsGlobal.screenHeight / 448.0)) * 0.5;
    v24 = (float)(screenWidth - v19) / 640.0;
    v25 = fScaleY;
    v26 = fOriginY;
    v27 = (float)RsGlobal.screenWidth;
    v28 = (float)(unsigned int)OS_ScreenGetWidth();
    v29 = 0.0;
    if ( (float)(v28 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
      v29 = 30.0;
    v30 = v27 / (float)v22;
    v31 = (float)(v27 - v29) / 640.0;
    if ( v30 > 1.8 )
      v31 = (float)(v31 + (float)((float)RsGlobal.screenHeight / 448.0)) * 0.5;
    v32 = v16 * v23;
    v33 = v26 * (float)((float)v22 / 448.0);
    v34 = fOriginX[0];
    v35 = v11 * v24;
    v36 = (float)RsGlobal.screenWidth;
    v37 = (float)(unsigned int)OS_ScreenGetWidth();
    v38 = (float)(unsigned int)OS_ScreenGetHeight();
    v39 = (float)RsGlobal.screenHeight;
    v40 = fScaleX;
    v41 = (float)RsGlobal.screenWidth;
    v42 = (float)(unsigned int)OS_ScreenGetWidth();
    v43 = 0.0;
    v44 = v42 / (float)(unsigned int)OS_ScreenGetHeight();
    if ( (float)(v37 / v38) > 1.9 )
      v43 = 30.0;
    v45 = v44 <= 1.9;
    v46 = 0.0;
    v47 = (float)(v36 - v43) / 640.0;
    if ( !v45 )
      v46 = 30.0;
    v48 = RsGlobal.screenHeight;
    v49 = (float)(v41 - v46) / 640.0;
    v50 = v25 * v31;
    v51 = v34 * v47;
    if ( (float)(v41 / v39) > 1.8 )
      v49 = (float)(v49 + (float)((float)RsGlobal.screenHeight / 448.0)) * 0.5;
    v52 = v33 - v50;
    v53 = v35 - v32;
    v54 = fScaleY;
    v55 = fOriginY;
    v56 = (float)RsGlobal.screenWidth;
    v57 = (float)(unsigned int)OS_ScreenGetWidth();
    v58 = 0.0;
    if ( (float)(v57 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
      v58 = 30.0;
    v59 = (float)(v56 - v58) / 640.0;
    if ( (float)(v56 / (float)v48) > 1.8 )
      v59 = (float)(v59 + (float)((float)RsGlobal.screenHeight / 448.0)) * 0.5;
    v60 = (float *)((char *)&v68->m_nAdjustmentMode + v10 * 40);
    v60[28] = v53;
    v60[29] = (float)(v55 * (float)((float)v48 / 448.0)) + (float)(v54 * v59);
    v60[30] = v51 + (float)(v40 * v49);
    v60[31] = v52;
    v61 = *(_QWORD *)&v68->m_AdjustableButtons[v10].m_RectScreen.right;
    v62 = (_QWORD *)((char *)&v68->m_nAdjustmentMode + v6);
    *v62 = *(_QWORD *)&v68->m_AdjustableButtons[v10].m_RectScreen.left;
    v62[1] = v61;
    v64 = *v8++;
    v63 = v64;
    *((_DWORD *)v60 + 26) = v64;
    v65 = *v7++;
    *((_DWORD *)v60 + 27) = v65;
    *((_WORD *)v60 + 70) = 256;
    v66 = *v9++;
    *((_DWORD *)v60 + 34) = v66;
    CSprite2d::SetTexture(&v68->m_AdjustableButtons[v10++].m_Sprite, CTouchInterface::m_pszWidgetTextures[v63]);
    v6 += 16;
  }
  while ( v10 != 19 );
  CTouchInterface::UnloadTextureDB(pMobileDB);
  CAdjustableHUD::Update(v68);
}
// 282140: using guessed type float fOriginX[25];

//----- (0028269C) --------------------------------------------------------
void __fastcall CAdjustableHUD::Update(CAdjustableHUD *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d2
  float32x2_t v4; // d3
  float32x2_t v5; // d4
  float32x2_t v6; // d5
  float32x2_t v7; // d6
  float32x2_t v8; // d7
  float32x2_t v9; // d8
  float32x2_t v10; // d9
  float32x2_t v11; // d10
  float v13; // s0
  float v14; // s2
  int v15; // r0
  int v16; // r0
  int m_nInitialTouchID; // r0
  __int64 v18; // d16
  __int64 v19; // d17
  __int64 v20; // d18
  __int64 v21; // d19
  __int64 v22; // d20
  __int64 v23; // d21
  __int64 v24; // d22
  __int64 v25; // d23
  __int64 v26; // d24
  __int64 v27; // d25
  __int64 v28; // d26
  __int64 v29; // d27
  __int64 v30; // d28
  __int64 v31; // d29
  __int64 v32; // d31
  __int64 v33; // d17
  __int64 v34; // d17
  __int64 v35; // d17
  __int64 v36; // d17
  __int64 v37; // d17
  __int64 v38; // d17
  __int64 v39; // d17
  __int64 v40; // d17
  __int64 v41; // d17
  __int64 v42; // d17
  __int64 v43; // d17
  int m_nSelectedButton; // r0
  int v45; // r0
  float *v46; // r0
  float v47; // s22
  float v48; // s20
  float v49; // s26
  float32x2_t v50; // d12
  float screenWidth; // s16
  float Width; // s18
  float v53; // s21
  float v54; // s0
  OSDeviceForm v55; // r5
  float v56; // s19
  float v57; // s18
  bool v58; // cc
  float v59; // s19
  float v60; // s0
  float v61; // s23
  int v62; // r8
  void *Height; // r9
  int v64; // r10
  void *v65; // r6
  float v66; // s21
  float v67; // s23
  void *v68; // s0
  float v69; // s2
  float *v70; // r0
  float v71; // s2
  float v72; // s6
  int v73; // r0
  float v74; // s23
  int v75; // r8
  void *v76; // r9
  int v77; // r10
  void *v78; // r6
  float v79; // s21
  float v80; // s23
  void *v81; // s0
  float v82; // s2
  float *v83; // r0
  float v84; // s2
  float v85; // s6
  float v86; // s25
  float *v87; // r5
  float v88; // s0
  float *v89; // r0
  void *v90; // r9
  int v91; // r10
  void *v92; // r6
  float v93; // s21
  float v94; // s23
  float v95; // s2
  float *v96; // r0
  float v97; // s2
  float v98; // s0
  float *v99; // r0
  float v100; // s25
  float v101; // s25
  float v102; // s0
  int v103; // r8
  void *v104; // r9
  int v105; // r10
  void *v106; // r11
  float v107; // s21
  float v108; // s23
  float v109; // s2
  float v110; // s0
  float v111; // s2
  float v112; // s27
  float v113; // s27
  float v114; // s0
  int v115; // r8
  void *v116; // r9
  int v117; // r10
  void *v118; // r6
  float v119; // s21
  float v120; // s23
  float v121; // s2
  float v122; // s0
  float v123; // s2
  float v124; // s25
  float v125; // s25
  float v126; // s0
  int v127; // r8
  void *v128; // r9
  int v129; // r10
  void *v130; // r6
  float v131; // s21
  float v132; // s23
  float v133; // s2
  float v134; // s0
  float v135; // s2
  float v136; // s27
  float v137; // s27
  float v138; // s0
  int v139; // r8
  void *v140; // r9
  int v141; // r10
  void *v142; // r6
  float v143; // s21
  float v144; // s23
  float v145; // s2
  float v146; // s0
  float v147; // s2
  float v148; // s2
  float v149; // s25
  float *v150; // r9
  float v151; // s0
  float *v152; // r0
  void *v153; // r5
  int v154; // r10
  void *v155; // r11
  float v156; // s21
  float v157; // s23
  float v158; // s2
  float *v159; // r0
  float v160; // s2
  float v161; // s0
  float *v162; // r0
  float v163; // s25
  float *v164; // r11
  float v165; // s0
  float *v166; // r0
  int v167; // r10
  void *v168; // r6
  float v169; // s21
  float v170; // s23
  float v171; // s2
  float *v172; // r0
  float v173; // s2
  float v174; // s25
  float v175; // s25
  float v176; // s0
  int v177; // r8
  void *v178; // r9
  int v179; // r10
  void *v180; // r6
  float v181; // s21
  float v182; // s23
  float v183; // s2
  float v184; // s0
  float v185; // s2
  float v186; // s27
  float v187; // s27
  float v188; // s0
  int v189; // r8
  void *v190; // r9
  int v191; // r10
  void *v192; // r6
  float v193; // s21
  float v194; // s23
  float v195; // s2
  float v196; // s0
  float v197; // s2
  float v198; // s25
  float v199; // s25
  float v200; // s0
  int v201; // r8
  void *v202; // r9
  int v203; // r10
  void *v204; // r6
  float v205; // s21
  float v206; // s23
  float v207; // s2
  float v208; // s0
  float v209; // s2
  float v210; // s27
  float v211; // s0
  int v212; // r8
  void *v213; // r9
  int v214; // r10
  void *v215; // r6
  float v216; // s21
  float v217; // s23
  float v218; // s2
  float v219; // s0
  float v220; // s2
  float v221; // s2
  int v222; // r8
  void *v223; // r6
  float v224; // s19
  float v225; // s21
  float v226; // s2
  float v227; // s2
  int v228; // r5
  float screenHeight; // s30
  float v230; // s17
  RwInt32 v231; // lr
  float v232; // s4
  float v233; // s20
  float v234; // s26
  int v235; // r2
  float32x2_t v236; // d0
  float32x2_t v237; // d2
  float32x2_t v238; // d1
  float32x2_t v239; // d16
  float v240; // s24
  float v241; // s0
  float32x2_t v242; // d2
  char *v243; // r3
  bool v244; // zf
  float v245; // s6
  int v246; // r1
  float v247; // s8
  float v248; // s12
  float v249; // s10
  int v250; // r3
  float v251; // s8
  float v252; // s12
  float v253; // s6
  float v254; // s10
  float *v255; // r0
  float v256; // s17
  float v257; // s0
  float v258; // s2
  float v259; // s2
  int v260; // r1
  int v261; // r9
  RwInt32 v262; // r5
  int v263; // r8
  int v264; // r3
  int v265; // r2
  float v266; // s12
  float32x2_t v267; // d0
  float32x2_t v268; // d16
  float v269; // s0
  float32x2_t v270; // d17
  float v271; // s4
  char *v272; // r5
  bool v273; // zf
  float v274; // s6
  int v275; // r0
  int v276; // r6
  float v277; // s10
  float v278; // s8
  float v279; // s12
  float v280; // s6
  float v281; // s10
  int v282; // r0
  char *v283; // r0
  float v284; // s22
  int v285; // r5
  AdjustableButton *v286; // r0
  float v287; // s24
  float left; // s26
  float v289; // s28
  float v290; // s30
  int v291; // r1
  int v292; // r0
  AdjustableButton *v293; // r3
  float32x2_t v294; // d3
  float32x2_t v295; // d16
  float v296; // s8
  float32x2_t v297; // d18
  char *v298; // r6
  bool v299; // zf
  float v300; // s12
  float v301; // s14
  float v302; // s14
  bool v303; // fnf
  float *v304; // r0
  float v305; // s28
  float v306; // s26
  float v307; // s30
  float v308; // r2
  float v309; // r3
  CRect *p_m_RectScreen; // r0
  float v311; // s2
  int v312; // r2
  float right; // s12
  float v314; // s6
  float v315; // s8
  float v316; // s17
  int v317; // r5
  AdjustableButton *v318; // r0
  float v319; // s19
  float v320; // s18
  float v321; // s20
  float v322; // s21
  RwInt32 v323; // r10
  float v324; // s22
  int v325; // r1
  int v326; // r0
  AdjustableButton *v327; // r3
  float *p_left; // r12
  float *p_right; // lr
  float v330; // s18
  float v331; // s26
  float32x2_t v332; // d16
  float v333; // s0
  float v334; // s4
  float32x2_t v335; // d18
  float v336; // s2
  float32x2_t v337; // d3
  char *v338; // r6
  bool v339; // zf
  float v340; // s8
  __int64 v341; // r2
  float v342; // s12
  float v343; // s10
  float v344; // s14
  float v345; // s8
  float v346; // s12
  float *v347; // r0
  int v348; // r8
  float v349; // s21
  float v350; // s0
  float v351; // s2
  float v352; // s2
  float v353; // s23
  int v354; // r5
  RwInt32 v355; // r6
  int v356; // r2
  float *v357; // r1
  float32x2_t v358; // d1
  float32x2_t v359; // d0
  float32x2_t v360; // d16
  float v361; // s0
  float32x2_t v362; // d18
  float v363; // s6
  float v364; // s2
  char *v365; // r3
  bool v366; // zf
  float v367; // s8
  float v368; // s12
  float v369; // s10
  float v370; // s10
  bool v371; // fnf
  float *v372; // r0
  int v373; // r0
  int v374; // r2
  int v375; // r1
  float32x2_t *v376; // r2
  bool v377; // zf
  float32x2_t *v378; // r2
  float32x2_t v379; // d2
  float32x2_t v380; // d3
  unsigned int v381; // r2
  float32x2_t v382; // d17
  float v383; // s8
  float v384; // s6
  float32x2_t v385; // d17
  float v386; // s4
  float32x2_t *v387; // r3
  bool v388; // zf
  float32x2_t v389; // d4
  float32x2_t v390; // d5
  float32x2_t v391; // d18
  unsigned __int64 v392; // d5
  float v393; // s10
  bool v394; // fnf
  int v395; // r2
  int v396; // r0
  int v397; // r1
  float32x2_t *v398; // r2
  float32x2_t *v399; // r2
  float32x2_t v400; // d2
  float32x2_t v401; // d3
  unsigned int v402; // r2
  float32x2_t v403; // d17
  float v404; // s8
  float v405; // s6
  float32x2_t v406; // d17
  float v407; // s4
  float32x2_t *v408; // r3
  float32x2_t v409; // d4
  float32x2_t v410; // d5
  float32x2_t v411; // d18
  unsigned __int64 v412; // d5
  float v413; // s10
  bool v414; // fnf
  void *v415; // r0
  CAdjustableHUD *v416; // r0
  CAdjustableHUD *v417; // r0
  __int64 v418; // d16
  __int64 v419; // d17
  __int64 v420; // d18
  __int64 v421; // d19
  __int64 v422; // d20
  __int64 v423; // d21
  __int64 v424; // d22
  __int64 v425; // d23
  __int64 v426; // d24
  __int64 v427; // d25
  __int64 v428; // d26
  __int64 v429; // d27
  __int64 v430; // d28
  __int64 v431; // d29
  __int64 v432; // d31
  __int64 v433; // d17
  __int64 v434; // d17
  __int64 v435; // d17
  __int64 v436; // d17
  __int64 v437; // d17
  __int64 v438; // d17
  __int64 v439; // d17
  __int64 v440; // d17
  __int64 v441; // d17
  __int64 v442; // d17
  __int64 v443; // d17
  void *v444; // [sp+Ch] [bp-84h]
  float *p_y; // [sp+10h] [bp-80h]
  int v446; // [sp+10h] [bp-80h]
  CVector2D *p_m_vecCoords; // [sp+14h] [bp-7Ch]
  int v448; // [sp+14h] [bp-7Ch]
  int v449; // [sp+14h] [bp-7Ch]
  int y; // [sp+18h] [bp-78h] BYREF
  int x; // [sp+1Ch] [bp-74h] BYREF
  float fScaleY; // [sp+20h] [bp-70h] BYREF
  float fScaleX; // [sp+24h] [bp-6Ch] BYREF
  float fOriginY; // [sp+28h] [bp-68h] BYREF
  float fOriginX[25]; // [sp+2Ch] [bp-64h] BYREF

  CAdjustableHUD::EnableButtons(this);
  CAdjustableHUD::SetTextures(this);
  if ( !CTouchInterface::IsTouchDown(lastDevice) )
  {
    m_nInitialTouchID = this->m_nInitialTouchID;
    if ( m_nInitialTouchID == 2 )
    {
      if ( CWidget::IsInsideRect(
             this->m_vecCoords.x,
             this->m_vecCoords.y,
             this->m_RectSave.left,
             this->m_RectSave.top,
             this->m_RectSave.right,
             this->m_RectSave.bottom) == 1 )
      {
LABEL_12:
        this->m_bQueuedExit = 1;
        goto LABEL_13;
      }
      m_nInitialTouchID = this->m_nInitialTouchID;
    }
    if ( m_nInitialTouchID == 3
      && CWidget::IsInsideRect(
           this->m_vecCoords.x,
           this->m_vecCoords.y,
           this->m_RectCancel.left,
           this->m_RectCancel.top,
           this->m_RectCancel.right,
           this->m_RectCancel.bottom)
      || CHID::IsReleased(HID_MAPPING_MENU_BACK) )
    {
      v18 = *(_QWORD *)&this->m_SavedButtonPositions[1].left;
      v19 = *(_QWORD *)&this->m_SavedButtonPositions[1].right;
      v20 = *(_QWORD *)&this->m_SavedButtonPositions[2].left;
      v21 = *(_QWORD *)&this->m_SavedButtonPositions[2].right;
      v22 = *(_QWORD *)&this->m_SavedButtonPositions[3].left;
      v23 = *(_QWORD *)&this->m_SavedButtonPositions[3].right;
      v24 = *(_QWORD *)&this->m_SavedButtonPositions[4].left;
      v25 = *(_QWORD *)&this->m_SavedButtonPositions[4].right;
      v26 = *(_QWORD *)&this->m_SavedButtonPositions[5].left;
      v27 = *(_QWORD *)&this->m_SavedButtonPositions[5].right;
      v28 = *(_QWORD *)&this->m_SavedButtonPositions[6].left;
      v29 = *(_QWORD *)&this->m_SavedButtonPositions[6].right;
      v30 = *(_QWORD *)&this->m_SavedButtonPositions[7].left;
      v31 = *(_QWORD *)&this->m_SavedButtonPositions[7].right;
      v32 = *(_QWORD *)&this->m_SavedButtonPositions[0].right;
      *(_QWORD *)&this->m_AdjustableButtons[0].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[0].left;
      *(_QWORD *)&this->m_AdjustableButtons[0].m_RectScreen.right = v32;
      *(_QWORD *)&this->m_AdjustableButtons[1].m_RectScreen.left = v18;
      *(_QWORD *)&this->m_AdjustableButtons[1].m_RectScreen.right = v19;
      *(_QWORD *)&this->m_AdjustableButtons[2].m_RectScreen.left = v20;
      *(_QWORD *)&this->m_AdjustableButtons[2].m_RectScreen.right = v21;
      *(_QWORD *)&this->m_AdjustableButtons[3].m_RectScreen.left = v22;
      *(_QWORD *)&this->m_AdjustableButtons[3].m_RectScreen.right = v23;
      *(_Q