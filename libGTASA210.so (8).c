WORD *)&this->m_AdjustableButtons[4].m_RectScreen.left = v24;
      *(_QWORD *)&this->m_AdjustableButtons[4].m_RectScreen.right = v25;
      *(_QWORD *)&this->m_AdjustableButtons[5].m_RectScreen.left = v26;
      *(_QWORD *)&this->m_AdjustableButtons[5].m_RectScreen.right = v27;
      *(_QWORD *)&this->m_AdjustableButtons[6].m_RectScreen.left = v28;
      *(_QWORD *)&this->m_AdjustableButtons[6].m_RectScreen.right = v29;
      *(_QWORD *)&this->m_AdjustableButtons[7].m_RectScreen.left = v30;
      *(_QWORD *)&this->m_AdjustableButtons[7].m_RectScreen.right = v31;
      v33 = *(_QWORD *)&this->m_SavedButtonPositions[8].right;
      *(_QWORD *)&this->m_AdjustableButtons[8].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[8].left;
      *(_QWORD *)&this->m_AdjustableButtons[8].m_RectScreen.right = v33;
      v34 = *(_QWORD *)&this->m_SavedButtonPositions[9].right;
      *(_QWORD *)&this->m_AdjustableButtons[9].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[9].left;
      *(_QWORD *)&this->m_AdjustableButtons[9].m_RectScreen.right = v34;
      v35 = *(_QWORD *)&this->m_SavedButtonPositions[10].right;
      *(_QWORD *)&this->m_AdjustableButtons[10].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[10].left;
      *(_QWORD *)&this->m_AdjustableButtons[10].m_RectScreen.right = v35;
      v36 = *(_QWORD *)&this->m_SavedButtonPositions[11].right;
      *(_QWORD *)&this->m_AdjustableButtons[11].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[11].left;
      *(_QWORD *)&this->m_AdjustableButtons[11].m_RectScreen.right = v36;
      v37 = *(_QWORD *)&this->m_SavedButtonPositions[12].right;
      *(_QWORD *)&this->m_AdjustableButtons[12].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[12].left;
      *(_QWORD *)&this->m_AdjustableButtons[12].m_RectScreen.right = v37;
      v38 = *(_QWORD *)&this->m_SavedButtonPositions[13].right;
      *(_QWORD *)&this->m_AdjustableButtons[13].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[13].left;
      *(_QWORD *)&this->m_AdjustableButtons[13].m_RectScreen.right = v38;
      v39 = *(_QWORD *)&this->m_SavedButtonPositions[14].right;
      *(_QWORD *)&this->m_AdjustableButtons[14].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[14].left;
      *(_QWORD *)&this->m_AdjustableButtons[14].m_RectScreen.right = v39;
      v40 = *(_QWORD *)&this->m_SavedButtonPositions[15].right;
      *(_QWORD *)&this->m_AdjustableButtons[15].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[15].left;
      *(_QWORD *)&this->m_AdjustableButtons[15].m_RectScreen.right = v40;
      v41 = *(_QWORD *)&this->m_SavedButtonPositions[16].right;
      *(_QWORD *)&this->m_AdjustableButtons[16].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[16].left;
      *(_QWORD *)&this->m_AdjustableButtons[16].m_RectScreen.right = v41;
      v42 = *(_QWORD *)&this->m_SavedButtonPositions[17].right;
      *(_QWORD *)&this->m_AdjustableButtons[17].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[17].left;
      *(_QWORD *)&this->m_AdjustableButtons[17].m_RectScreen.right = v42;
      v43 = *(_QWORD *)&this->m_SavedButtonPositions[18].right;
      *(_QWORD *)&this->m_AdjustableButtons[18].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[18].left;
      *(_QWORD *)&this->m_AdjustableButtons[18].m_RectScreen.right = v43;
      goto LABEL_12;
    }
    v45 = this->m_nInitialTouchID;
    if ( v45 == 4 )
    {
      if ( CWidget::IsInsideRect(
             this->m_vecCoords.x,
             this->m_vecCoords.y,
             this->m_RectRestoreDefaults.left,
             this->m_RectRestoreDefaults.top,
             this->m_RectRestoreDefaults.right,
             this->m_RectRestoreDefaults.bottom) == 1 )
      {
        CAdjustableHUD::RestoreDefaults(this);
        PlaySelectSound();
        goto LABEL_13;
      }
      v45 = this->m_nInitialTouchID;
    }
    if ( !v45 )
    {
      if ( CWidget::IsInsideRect(
             this->m_vecCoords.x,
             this->m_vecCoords.y,
             this->m_RectOnFoot.left,
             this->m_RectOnFoot.top,
             this->m_RectOnFoot.right,
             this->m_RectOnFoot.bottom) )
      {
        if ( this->m_nAdjustmentMode == 1 )
          goto LABEL_13;
        PlayNavSound();
        v73 = 1;
        goto LABEL_111;
      }
      v45 = this->m_nInitialTouchID;
    }
    if ( v45 != 1
      || CWidget::IsInsideRect(
           this->m_vecCoords.x,
           this->m_vecCoords.y,
           this->m_RectInCar.left,
           this->m_RectInCar.top,
           this->m_RectInCar.right,
           this->m_RectInCar.bottom) != 1
      || this->m_nAdjustmentMode == 2 )
    {
LABEL_13:
      m_nSelectedButton = this->m_nSelectedButton;
      this->m_nInitialTouchID = -1;
      if ( m_nSelectedButton == -1 || this->m_bMovedButton )
        goto LABEL_290;
      if ( bUsedKeyboard == 1 )
      {
        bUsedKeyboard = 0;
LABEL_290:
        this->m_nSelectedButton = -1;
        goto LABEL_291;
      }
      v46 = (float *)(&this->m_nAdjustmentMode + 10 * m_nSelectedButton);
      v47 = v46[28];
      v48 = v46[29];
      v49 = v46[30];
      v50.n64_f32[0] = v46[31];
      screenWidth = (float)RsGlobal.screenWidth;
      Width = (float)(unsigned int)OS_ScreenGetWidth();
      v53 = 0.0;
      v54 = 0.0;
      if ( (float)(Width / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
        v54 = 30.0;
      v55 = OS_SystemForm();
      v56 = (float)(unsigned int)OS_ScreenGetWidth();
      v57 = 1.0;
      v58 = (float)(v56 / (float)(unsigned int)OS_ScreenGetHeight()) <= 1.9;
      v59 = (float)(fabsf(v49 - v47) / (float)((float)(screenWidth - v54) / 640.0)) * 0.5;
      v60 = 1.0;
      if ( !v58 )
        v60 = 0.85;
      if ( v55 == OSDF_Phone )
      {
        v61 = 999.9;
        if ( fabsf(v59 + (float)(v60 * -42.0)) >= 999.9 )
        {
          v53 = 0.0;
        }
        else
        {
          v62 = OS_ScreenGetWidth();
          Height = OS_ScreenGetHeight();
          v64 = OS_ScreenGetWidth();
          v65 = OS_ScreenGetHeight();
          v66 = (float)RsGlobal.screenWidth;
          v67 = (float)(unsigned int)OS_ScreenGetWidth();
          v68 = OS_ScreenGetHeight();
          v69 = 0.0;
          v70 = (float *)&unk_2831F8;
          if ( (float)(v67 / (float)(unsigned int)v68) > 1.9 )
            v69 = 30.0;
          v71 = (float)(v66 - v69) / 640.0;
          if ( (float)((float)(unsigned int)v62 / (float)(unsigned int)Height) > 1.9 )
            v70 = (float *)&loc_2831FC;
          v72 = 11.5;
          v61 = fabsf(v59 - *v70);
          if ( (float)((float)(unsigned int)v64 / (float)(unsigned int)v65) > 1.9 )
            v72 = 9.775;
          v53 = v72 * v71;
        }
        v149 = (float)(unsigned int)OS_ScreenGetWidth();
        v150 = (float *)&unk_283204;
        v151 = (float)(unsigned int)OS_ScreenGetHeight();
        v152 = (float *)&unk_283204;
        if ( (float)(v149 / v151) > 1.9 )
          v152 = (float *)&loc_283208;
        if ( fabsf(v59 - *v152) < v61 )
        {
          v449 = OS_ScreenGetWidth();
          v153 = OS_ScreenGetHeight();
          v154 = OS_ScreenGetWidth();
          v155 = OS_ScreenGetHeight();
          v156 = (float)RsGlobal.screenWidth;
          v157 = (float)(unsigned int)OS_ScreenGetWidth();
          v158 = 0.0;
          if ( (float)(v157 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
            v158 = 30.0;
          v159 = (float *)&unk_283204;
          v160 = (float)(v156 - v158) / 640.0;
          if ( (float)((float)(unsigned int)v449 / (float)(unsigned int)v153) > 1.9 )
            v159 = (float *)&loc_283208;
          v161 = *v159;
          v162 = (float *)&unk_2831F8;
          v61 = fabsf(v59 - v161);
          if ( (float)((float)(unsigned int)v154 / (float)(unsigned int)v155) > 1.9 )
            v162 = (float *)&loc_2831FC;
          v53 = *v162 * v160;
        }
        v163 = (float)(unsigned int)OS_ScreenGetWidth();
        v164 = (float *)&loc_28320C;
        v165 = (float)(unsigned int)OS_ScreenGetHeight();
        v166 = (float *)&loc_28320C;
        if ( (float)(v163 / v165) > 1.9 )
          v166 = (float *)&loc_283210;
        if ( fabsf(v59 - *v166) < v61 )
        {
          v446 = OS_ScreenGetWidth();
          v444 = OS_ScreenGetHeight();
          v167 = OS_ScreenGetWidth();
          v168 = OS_ScreenGetHeight();
          v169 = (float)RsGlobal.screenWidth;
          v170 = (float)(unsigned int)OS_ScreenGetWidth();
          v171 = 0.0;
          if ( (float)(v170 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
            v171 = 30.0;
          v172 = (float *)&loc_28320C;
          v173 = (float)(v169 - v171) / 640.0;
          if ( (float)((float)(unsigned int)v446 / (float)(unsigned int)v444) > 1.9 )
            v172 = (float *)&loc_283210;
          v61 = fabsf(v59 - *v172);
          if ( (float)((float)(unsigned int)v167 / (float)(unsigned int)v168) > 1.9 )
            v150 = (float *)&loc_283208;
          v53 = *v150 * v173;
        }
        v174 = (float)(unsigned int)OS_ScreenGetWidth();
        v58 = (float)(v174 / (float)(unsigned int)OS_ScreenGetHeight()) <= 1.9;
        v175 = 29.0;
        v176 = 29.0;
        if ( !v58 )
          v176 = 24.65;
        if ( fabsf(v59 - v176) < v61 )
        {
          v177 = OS_ScreenGetWidth();
          v178 = OS_ScreenGetHeight();
          v179 = OS_ScreenGetWidth();
          v180 = OS_ScreenGetHeight();
          v181 = (float)RsGlobal.screenWidth;
          v182 = (float)(unsigned int)OS_ScreenGetWidth();
          v183 = 0.0;
          if ( (float)(v182 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
            v183 = 30.0;
          v184 = 29.0;
          v185 = (float)(v181 - v183) / 640.0;
          if ( (float)((float)(unsigned int)v177 / (float)(unsigned int)v178) > 1.9 )
            v184 = 24.65;
          v61 = fabsf(v59 - v184);
          if ( (float)((float)(unsigned int)v179 / (float)(unsigned int)v180) > 1.9 )
            v164 = (float *)&loc_283210;
          v53 = *v164 * v185;
        }
        v186 = (float)(unsigned int)OS_ScreenGetWidth();
        v58 = (float)(v186 / (float)(unsigned int)OS_ScreenGetHeight()) <= 1.9;
        v187 = 24.0;
        v188 = 24.0;
        if ( !v58 )
          v188 = 20.4;
        if ( fabsf(v59 - v188) < v61 )
        {
          v189 = OS_ScreenGetWidth();
          v190 = OS_ScreenGetHeight();
          v191 = OS_ScreenGetWidth();
          v192 = OS_ScreenGetHeight();
          v193 = (float)RsGlobal.screenWidth;
          v194 = (float)(unsigned int)OS_ScreenGetWidth();
          v195 = 0.0;
          if ( (float)(v194 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
            v195 = 30.0;
          v196 = 24.0;
          v197 = (float)(v193 - v195) / 640.0;
          if ( (float)((float)(unsigned int)v189 / (float)(unsigned int)v190) > 1.9 )
            v196 = 20.4;
          v61 = fabsf(v59 - v196);
          if ( (float)((float)(unsigned int)v191 / (float)(unsigned int)v192) > 1.9 )
            v175 = 24.65;
          v53 = v175 * v197;
        }
        v198 = (float)(unsigned int)OS_ScreenGetWidth();
        v58 = (float)(v198 / (float)(unsigned int)OS_ScreenGetHeight()) <= 1.9;
        v199 = 17.0;
        v200 = 17.0;
        if ( !v58 )
          v200 = 14.45;
        if ( fabsf(v59 - v200) < v61 )
        {
          v201 = OS_ScreenGetWidth();
          v202 = OS_ScreenGetHeight();
          v203 = OS_ScreenGetWidth();
          v204 = OS_ScreenGetHeight();
          v205 = (float)RsGlobal.screenWidth;
          v206 = (float)(unsigned int)OS_ScreenGetWidth();
          v207 = 0.0;
          if ( (float)(v206 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
            v207 = 30.0;
          v208 = 17.0;
          v209 = (float)(v205 - v207) / 640.0;
          if ( (float)((float)(unsigned int)v201 / (float)(unsigned int)v202) > 1.9 )
            v208 = 14.45;
          v61 = fabsf(v59 - v208);
          if ( (float)((float)(unsigned int)v203 / (float)(unsigned int)v204) > 1.9 )
            v187 = 20.4;
          v53 = v187 * v209;
        }
        v210 = (float)(unsigned int)OS_ScreenGetWidth();
        v58 = (float)(v210 / (float)(unsigned int)OS_ScreenGetHeight()) <= 1.9;
        v137 = 14.0;
        v211 = 14.0;
        if ( !v58 )
          v211 = 11.9;
        if ( fabsf(v59 - v211) < v61 )
        {
          v212 = OS_ScreenGetWidth();
          v213 = OS_ScreenGetHeight();
          v214 = OS_ScreenGetWidth();
          v215 = OS_ScreenGetHeight();
          v216 = (float)RsGlobal.screenWidth;
          v217 = (float)(unsigned int)OS_ScreenGetWidth();
          v218 = 0.0;
          if ( (float)(v217 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
            v218 = 30.0;
          v219 = 14.0;
          v220 = (float)(v216 - v218) / 640.0;
          if ( (float)((float)(unsigned int)v212 / (float)(unsigned int)v213) > 1.9 )
            v219 = 11.9;
          v61 = fabsf(v59 - v219);
          if ( (float)((float)(unsigned int)v214 / (float)(unsigned int)v215) > 1.9 )
            v199 = 14.45;
          v53 = v199 * v220;
        }
        v50.n64_f32[1] = (float)(unsigned int)OS_ScreenGetWidth();
        v221 = 11.5;
        if ( (float)(v50.n64_f32[1] / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
          v221 = 9.775;
        if ( fabsf(v59 - v221) < v61 )
        {
LABEL_176:
          OS_ScreenGetWidth();
          OS_ScreenGetHeight();
          v222 = OS_ScreenGetWidth();
          v223 = OS_ScreenGetHeight();
          v224 = (float)RsGlobal.screenWidth;
          v225 = (float)(unsigned int)OS_ScreenGetWidth();
          v226 = 0.0;
          if ( (float)(v225 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
            v226 = 30.0;
          v227 = (float)(v224 - v226) / 640.0;
          if ( (float)((float)(unsigned int)v222 / (float)(unsigned int)v223) > 1.9 )
            v137 = 11.9;
          v53 = v137 * v227;
        }
      }
      else
      {
        v74 = 999.9;
        if ( fabsf(v59 + (float)(v60 * -36.0)) < 999.9 )
        {
          v75 = OS_ScreenGetWidth();
          v76 = OS_ScreenGetHeight();
          v77 = OS_ScreenGetWidth();
          v78 = OS_ScreenGetHeight();
          v79 = (float)RsGlobal.screenWidth;
          v80 = (float)(unsigned int)OS_ScreenGetWidth();
          v81 = OS_ScreenGetHeight();
          v82 = 0.0;
          v83 = (float *)&unk_283204;
          if ( (float)(v80 / (float)(unsigned int)v81) > 1.9 )
            v82 = 30.0;
          v84 = (float)(v79 - v82) / 640.0;
          if ( (float)((float)(unsigned int)v75 / (float)(unsigned int)v76) > 1.9 )
            v83 = (float *)&loc_283208;
          v85 = 11.5;
          v74 = fabsf(v59 - *v83);
          if ( (float)((float)(unsigned int)v77 / (float)(unsigned int)v78) > 1.9 )
            v85 = 9.775;
          v53 = v85 * v84;
        }
        v86 = (float)(unsigned int)OS_ScreenGetWidth();
        v87 = (float *)&loc_28320C;
        v88 = (float)(unsigned int)OS_ScreenGetHeight();
        v89 = (float *)&loc_28320C;
        if ( (float)(v86 / v88) > 1.9 )
          v89 = (float *)&loc_283210;
        if ( fabsf(v59 - *v89) < v74 )
        {
          v448 = OS_ScreenGetWidth();
          v90 = OS_ScreenGetHeight();
          v91 = OS_ScreenGetWidth();
          v92 = OS_ScreenGetHeight();
          v93 = (float)RsGlobal.screenWidth;
          v94 = (float)(unsigned int)OS_ScreenGetWidth();
          v95 = 0.0;
          if ( (float)(v94 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
            v95 = 30.0;
          v96 = (float *)&loc_28320C;
          v97 = (float)(v93 - v95) / 640.0;
          if ( (float)((float)(unsigned int)v448 / (float)(unsigned int)v90) > 1.9 )
            v96 = (float *)&loc_283210;
          v98 = *v96;
          v99 = (float *)&unk_283204;
          v74 = fabsf(v59 - v98);
          if ( (float)((float)(unsigned int)v91 / (float)(unsigned int)v92) > 1.9 )
            v99 = (float *)&loc_283208;
          v53 = *v99 * v97;
        }
        v100 = (float)(unsigned int)OS_ScreenGetWidth();
        v58 = (float)(v100 / (float)(unsigned int)OS_ScreenGetHeight()) <= 1.9;
        v101 = 29.0;
        v102 = 29.0;
        if ( !v58 )
          v102 = 24.65;
        if ( fabsf(v59 - v102) < v74 )
        {
          v103 = OS_ScreenGetWidth();
          v104 = OS_ScreenGetHeight();
          v105 = OS_ScreenGetWidth();
          v106 = OS_ScreenGetHeight();
          v107 = (float)RsGlobal.screenWidth;
          v108 = (float)(unsigned int)OS_ScreenGetWidth();
          v109 = 0.0;
          if ( (float)(v108 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
            v109 = 30.0;
          v110 = 29.0;
          v111 = (float)(v107 - v109) / 640.0;
          if ( (float)((float)(unsigned int)v103 / (float)(unsigned int)v104) > 1.9 )
            v110 = 24.65;
          v74 = fabsf(v59 - v110);
          if ( (float)((float)(unsigned int)v105 / (float)(unsigned int)v106) > 1.9 )
            v87 = (float *)&loc_283210;
          v53 = *v87 * v111;
        }
        v112 = (float)(unsigned int)OS_ScreenGetWidth();
        v58 = (float)(v112 / (float)(unsigned int)OS_ScreenGetHeight()) <= 1.9;
        v113 = 24.0;
        v114 = 24.0;
        if ( !v58 )
          v114 = 20.4;
        if ( fabsf(v59 - v114) < v74 )
        {
          v115 = OS_ScreenGetWidth();
          v116 = OS_ScreenGetHeight();
          v117 = OS_ScreenGetWidth();
          v118 = OS_ScreenGetHeight();
          v119 = (float)RsGlobal.screenWidth;
          v120 = (float)(unsigned int)OS_ScreenGetWidth();
          v121 = 0.0;
          if ( (float)(v120 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
            v121 = 30.0;
          v122 = 24.0;
          v123 = (float)(v119 - v121) / 640.0;
          if ( (float)((float)(unsigned int)v115 / (float)(unsigned int)v116) > 1.9 )
            v122 = 20.4;
          v74 = fabsf(v59 - v122);
          if ( (float)((float)(unsigned int)v117 / (float)(unsigned int)v118) > 1.9 )
            v101 = 24.65;
          v53 = v101 * v123;
        }
        v124 = (float)(unsigned int)OS_ScreenGetWidth();
        v58 = (float)(v124 / (float)(unsigned int)OS_ScreenGetHeight()) <= 1.9;
        v125 = 17.0;
        v126 = 17.0;
        if ( !v58 )
          v126 = 14.45;
        if ( fabsf(v59 - v126) < v74 )
        {
          v127 = OS_ScreenGetWidth();
          v128 = OS_ScreenGetHeight();
          v129 = OS_ScreenGetWidth();
          v130 = OS_ScreenGetHeight();
          v131 = (float)RsGlobal.screenWidth;
          v132 = (float)(unsigned int)OS_ScreenGetWidth();
          v133 = 0.0;
          if ( (float)(v132 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
            v133 = 30.0;
          v134 = 17.0;
          v135 = (float)(v131 - v133) / 640.0;
          if ( (float)((float)(unsigned int)v127 / (float)(unsigned int)v128) > 1.9 )
            v134 = 14.45;
          v74 = fabsf(v59 - v134);
          if ( (float)((float)(unsigned int)v129 / (float)(unsigned int)v130) > 1.9 )
            v113 = 20.4;
          v53 = v113 * v135;
        }
        v136 = (float)(unsigned int)OS_ScreenGetWidth();
        v58 = (float)(v136 / (float)(unsigned int)OS_ScreenGetHeight()) <= 1.9;
        v137 = 14.0;
        v138 = 14.0;
        if ( !v58 )
          v138 = 11.9;
        if ( fabsf(v59 - v138) < v74 )
        {
          v139 = OS_ScreenGetWidth();
          v140 = OS_ScreenGetHeight();
          v141 = OS_ScreenGetWidth();
          v142 = OS_ScreenGetHeight();
          v143 = (float)RsGlobal.screenWidth;
          v144 = (float)(unsigned int)OS_ScreenGetWidth();
          v145 = 0.0;
          if ( (float)(v144 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
            v145 = 30.0;
          v146 = 14.0;
          v147 = (float)(v143 - v145) / 640.0;
          if ( (float)((float)(unsigned int)v139 / (float)(unsigned int)v140) > 1.9 )
            v146 = 11.9;
          v74 = fabsf(v59 - v146);
          if ( (float)((float)(unsigned int)v141 / (float)(unsigned int)v142) > 1.9 )
            v125 = 14.45;
          v53 = v125 * v147;
        }
        v50.n64_f32[1] = (float)(unsigned int)OS_ScreenGetWidth();
        v148 = 11.5;
        if ( (float)(v50.n64_f32[1] / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
          v148 = 9.775;
        if ( fabsf(v59 - v148) < v74 )
          goto LABEL_176;
      }
      v228 = 0;
      screenHeight = (float)RsGlobal.screenHeight;
      v230 = (float)RsGlobal.screenWidth;
      fOriginY = 0.0;
      fOriginX[0] = 0.0;
      fScaleY = 0.0;
      fScaleX = 0.0;
      CTouchInterface::GetWidgetPosition(WIDGET_POSITION_PLAYER_INFO, fOriginX, &fOriginY, &fScaleX, &fScaleY);
      OS_ScreenGetWidth();
      OS_ScreenGetHeight();
      OS_ScreenGetWidth();
      OS_ScreenGetHeight();
      v231 = RsGlobal.screenHeight;
      v232 = v48 + v50.n64_f32[0];
      v233 = 0.0;
      v238.n64_f32[1] = screenHeight - v53;
      v238.n64_f32[0] = (float)(v47 + v49) * 0.5;
      v234 = 0.0;
      v235 = this->m_nSelectedButton;
      v4.n64_f32[0] = v238.n64_f32[0] - v53;
      v238.n64_f32[0] = v238.n64_f32[0] + v53;
      v236.n64_f32[1] = v238.n64_f32[0] - v4.n64_f32[0];
      v5.n64_f32[0] = v53 + (float)(v230 * 0.0);
      v237.n64_f32[1] = fabsf(v238.n64_f32[0] - v4.n64_f32[0]);
      v50.n64_f32[0] = (float)(v4.n64_f32[0] + v238.n64_f32[0]) * 0.5;
      v238.n64_u32[0] = 1232348158;
      v236.n64_f32[0] = (float)(v230 - (float)(v230 * 0.0)) - v53;
      v4.n64_f32[0] = (float)(screenHeight - v53) + (float)(screenHeight * -0.067);
      v239.n64_u64[0] = vmax_f32(v50, v5).n64_u64[0];
      v5.n64_f32[0] = (float)(screenHeight - (float)(screenHeight * 0.0)) - v53;
      v7.n64_f32[0] = (float)((float)((float)(v232 * 0.5) + v53) + (float)((float)(v232 * 0.5) - v53)) * 0.5;
      v240 = v237.n64_f32[1] * 0.5;
      v237.n64_f32[0] = v53 + (float)(fScaleX + (float)(fOriginY * (float)((float)RsGlobal.screenHeight / 448.0)));
      LODWORD(v241) = vmin_f32(v239, v236).n64_u32[0];
      v242.n64_u64[0] = vmin_f32(vmax_f32(v7, v237), vmin_f32(v4, v5)).n64_u64[0];
      do
      {
        if ( v235 )
        {
          v243 = (char *)this + v228 * 40;
          v244 = !this->m_AdjustableButtons[v228].m_bEnabled;
          if ( this->m_AdjustableButtons[v228].m_bEnabled )
            v244 = (*((_DWORD *)v243 + 34) & this->m_nAdjustmentMode) == 0;
          if ( !v244 )
          {
            v245 = *((float *)v243 + 28);
            v246 = 0;
            v247 = *((float *)v243 + 29);
            v248 = *((float *)v243 + 31);
            v249 = *((float *)v243 + 30);
            v250 = 0;
            v251 = (float)(v247 + v248) * 0.5;
            v252 = (float)(v245 + v249) * 0.5;
            v238.n64_f32[1] = (float)(v252 - v241) * (float)(v252 - v241);
            v253 = v240 + (float)(fabsf(v249 - v245) * 0.5);
            v254 = sqrtf(v238.n64_f32[1] + (float)((float)(v251 - v242.n64_f32[0]) * (float)(v251 - v242.n64_f32[0])));
            if ( v254 >= v253 )
              v246 = 1;
            if ( v254 >= v238.n64_f32[0] )
              v250 = 1;
            if ( v246 | v250 )
            {
              v254 = v238.n64_f32[0];
              v252 = v234;
              v251 = v233;
            }
            v233 = v251;
            v234 = v252;
            v238.n64_f32[0] = v254;
          }
        }
        ++v228;
        --v235;
      }
      while ( v228 != 19 );
      if ( v238.n64_f32[0] == 1000000.0 )
      {
        v255 = (float *)(&this->m_nAdjustmentMode + 10 * this->m_nSelectedButton);
        v255[28] = v241 - v53;
        v255[29] = v53 + v242.n64_f32[0];
        v255[30] = v53 + v241;
        v255[31] = v242.n64_f32[0] - v53;
      }
      else
      {
        v256 = this->m_vecCoords.y - v233;
        v257 = this->m_vecCoords.x - v234;
        v258 = (float)(v257 * v257) + (float)(v256 * v256);
        if ( v258 > 0.0 )
        {
          v259 = 1.0 / sqrtf(v258);
          v256 = v256 * v259;
          v57 = v257 * v259;
        }
        v260 = 0;
        while ( 1 )
        {
          v261 = v260;
          v262 = RsGlobal.screenWidth;
          fOriginY = 0.0;
          fOriginX[0] = 0.0;
          v263 = v231;
          fScaleY = 0.0;
          fScaleX = 0.0;
          CTouchInterface::GetWidgetPosition(WIDGET_POSITION_PLAYER_INFO, fOriginX, &fOriginY, &fScaleX, &fScaleY);
          OS_ScreenGetWidth();
          OS_ScreenGetHeight();
          OS_ScreenGetWidth();
          OS_ScreenGetHeight();
          v231 = RsGlobal.screenHeight;
          v264 = 0;
          v265 = this->m_nSelectedButton;
          v266 = (float)v262 * 0.0;
          v267.n64_f32[1] = fScaleX;
          v4.n64_f32[0] = (float)((float)v262 * 0.002) * (float)v261;
          v5.n64_f32[0] = (float)((float)v263 - v53) + (float)((float)v263 * -0.067);
          v242.n64_f32[0] = (float)((float)v263 - (float)((float)v263 * 0.0)) - v53;
          v267.n64_f32[0] = v53 + v266;
          v238.n64_f32[0] = (float)((float)v262 - v266) - v53;
          v268.n64_u64[0] = vmin_f32(v5, v242).n64_u64[0];
          v242.n64_f32[0] = v233 + (float)(v256 * v4.n64_f32[0]);
          v4.n64_f32[0] = v234 + (float)(v57 * v4.n64_f32[0]);
          LODWORD(v269) = vmin_f32(vmax_f32(v4, v267), v238).n64_u32[0];
          v238.n64_f32[0] = v53 + (float)(fScaleX + (float)(fOriginY * (float)((float)RsGlobal.screenHeight / 448.0)));
          v270.n64_u64[0] = vmax_f32(v242, v238).n64_u64[0];
          v271 = 1000000.0;
          v238.n64_u64[0] = vmin_f32(v270, v268).n64_u64[0];
          do
          {
            if ( v265 )
            {
              v272 = (char *)this + v264 * 40;
              v273 = !this->m_AdjustableButtons[v264].m_bEnabled;
              if ( this->m_AdjustableButtons[v264].m_bEnabled )
                v273 = (*((_DWORD *)v272 + 34) & this->m_nAdjustmentMode) == 0;
              if ( !v273 )
              {
                v274 = *((float *)v272 + 28);
                v275 = 0;
                v276 = 0;
                v277 = *((float *)v272 + 30);
                v278 = (float)(*((float *)v272 + 29) + *((float *)v272 + 31)) * 0.5;
                v279 = (float)(v274 + v277) * 0.5;
                v242.n64_f32[1] = (float)(v279 - v269) * (float)(v279 - v269);
                v280 = v240 + (float)(fabsf(v277 - v274) * 0.5);
                v281 = sqrtf(v242.n64_f32[1] + (float)((float)(v278 - v238.n64_f32[0]) * (float)(v278 - v238.n64_f32[0])));
                if ( v281 >= v280 )
                  v275 = 1;
                if ( v281 >= v271 )
                  v276 = 1;
                if ( v275 | v276 )
                {
                  v281 = v271;
                  v279 = v234;
                  v278 = v233;
                }
                v233 = v278;
                v234 = v279;
                v271 = v281;
              }
            }
            ++v264;
            --v265;
          }
          while ( v264 != 19 );
          if ( v271 == 1000000.0 )
            break;
          v260 = v261 + 1;
          if ( v261 > 98 )
            goto LABEL_290;
        }
        v372 = (float *)(&this->m_nAdjustmentMode + 10 * this->m_nSelectedButton);
        v372[28] = v269 - v53;
        v372[29] = v53 + v238.n64_f32[0];
        v372[30] = v53 + v269;
        v372[31] = v238.n64_f32[0] - v53;
      }
      goto LABEL_290;
    }
    PlayNavSound();
    v73 = 2;
LABEL_111:
    this->m_nAdjustmentMode = v73;
    goto LABEL_13;
  }
  this->m_bOverlappingDialog = 0;
  x = 0;
  y = 0;
  LIB_PointerGetCoordinates(lastDevice, &x, &y, 0);
  v13 = (float)x;
  v14 = (float)y;
  p_m_vecCoords = &this->m_vecCoords;
  v15 = this->m_nInitialTouchID + 1;
  this->m_vecCoords.x = (float)x;
  p_y = &this->m_vecCoords.y;
  this->m_vecCoords.y = v14;
  if ( v15 )
    goto LABEL_218;
  if ( CWidget::IsInsideRect(
         v13,
         v14,
         this->m_RectSave.left,
         this->m_RectSave.top,
         this->m_RectSave.right,
         this->m_RectSave.bottom) == 1 )
  {
    v16 = 2;
  }
  else if ( CWidget::IsInsideRect(
              this->m_vecCoords.x,
              this->m_vecCoords.y,
              this->m_RectCancel.left,
              this->m_RectCancel.top,
              this->m_RectCancel.right,
              this->m_RectCancel.bottom) == 1 )
  {
    v16 = 3;
  }
  else if ( CWidget::IsInsideRect(
              this->m_vecCoords.x,
              this->m_vecCoords.y,
              this->m_RectRestoreDefaults.left,
              this->m_RectRestoreDefaults.top,
              this->m_RectRestoreDefaults.right,
              this->m_RectRestoreDefaults.bottom) == 1 )
  {
    v16 = 4;
  }
  else if ( CWidget::IsInsideRect(
              this->m_vecCoords.x,
              this->m_vecCoords.y,
              this->m_RectOnFoot.left,
              this->m_RectOnFoot.top,
              this->m_RectOnFoot.right,
              this->m_RectOnFoot.bottom) == 1 )
  {
    v16 = 0;
  }
  else
  {
    if ( CWidget::IsInsideRect(
           this->m_vecCoords.x,
           this->m_vecCoords.y,
           this->m_RectInCar.left,
           this->m_RectInCar.top,
           this->m_RectInCar.right,
           this->m_RectInCar.bottom) != 1 )
      goto LABEL_218;
    v16 = 1;
  }
  this->m_nInitialTouchID = v16;
LABEL_218:
  v282 = this->m_nSelectedButton;
  if ( v282 == -1 )
  {
    v308 = this->m_vecCoords.x;
    v309 = this->m_vecCoords.y;
    p_m_RectScreen = &this->m_AdjustableButtons[0].m_RectScreen;
    this->m_vecDragAnchor.x = v308;
    this->m_vecDragAnchor.y = v309;
    v311 = v308;
    v312 = 0;
    while ( 1 )
    {
      if ( (LODWORD(p_m_RectScreen[1].right) & this->m_nAdjustmentMode) != 0 )
      {
        right = p_m_RectScreen->right;
        v314 = (float)((float)(p_m_RectScreen->top + p_m_RectScreen->bottom) * 0.5) - v309;
        v315 = (float)((float)(p_m_RectScreen->left + right) * 0.5) - v311;
        if ( sqrtf((float)(v315 * v315) + (float)(v314 * v314)) < (float)(fabsf(right - p_m_RectScreen->left) * 0.5) )
          break;
      }
      p_m_RectScreen = (CRect *)((char *)p_m_RectScreen + 40);
      v58 = v312++ < 18;
      if ( !v58 )
        goto LABEL_291;
    }
    this->m_nSelectedButton = v312;
    this->m_bMovedButton = 0;
    this->m_vecDragOffset.x = v315;
    this->m_vecDragOffset.y = v314;
    goto LABEL_291;
  }
  v283 = (char *)this + 40 * v282;
  v11.n64_u32[0] = *((_DWORD *)v283 + 28);
  v9.n64_u32[0] = *((_DWORD *)v283 + 29);
  v284 = *((float *)v283 + 30);
  v10.n64_u32[0] = *((_DWORD *)v283 + 31);
  if ( LIB_KeyboardPressed(KK_ARROWLEFT) || LIB_KeyboardPressed(KK_A) )
  {
    bUsedKeyboard = 1;
    v284 = v284 + -1.0;
    v11.n64_f32[0] = v11.n64_f32[0] + -1.0;
  }
  if ( LIB_KeyboardPressed(KK_ARROWRIGHT) || LIB_KeyboardPressed(KK_D) )
  {
    bUsedKeyboard = 1;
    v284 = v284 + 1.0;
    v11.n64_f32[0] = v11.n64_f32[0] + 1.0;
  }
  if ( LIB_KeyboardPressed(KK_ARROWUP) || LIB_KeyboardPressed(KK_W) )
  {
    bUsedKeyboard = 1;
    v10.n64_f32[0] = v10.n64_f32[0] + -1.0;
    v9.n64_f32[0] = v9.n64_f32[0] + -1.0;
  }
  if ( LIB_KeyboardPressed(KK_ARROWDOWN) || LIB_KeyboardPressed(KK_S) )
  {
    bUsedKeyboard = 1;
    v10.n64_f32[0] = v10.n64_f32[0] + 1.0;
    v9.n64_f32[0] = v9.n64_f32[0] + 1.0;
    goto LABEL_231;
  }
  if ( bUsedKeyboard == 1 )
  {
LABEL_231:
    v285 = 0;
    v286 = &this->m_AdjustableButtons[this->m_nSelectedButton];
    v287 = (float)RsGlobal.screenWidth;
    left = v286->m_RectScreen.left;
    v289 = v286->m_RectScreen.right;
    v290 = (float)RsGlobal.screenHeight;
    fOriginY = 0.0;
    fOriginX[0] = 0.0;
    fScaleY = 0.0;
    fScaleX = 0.0;
    CTouchInterface::GetWidgetPosition(WIDGET_POSITION_PLAYER_INFO, fOriginX, &fOriginY, &fScaleX, &fScaleY);
    OS_ScreenGetWidth();
    OS_ScreenGetHeight();
    OS_ScreenGetWidth();
    OS_ScreenGetHeight();
    v3.n64_f32[1] = v10.n64_f32[0] + v9.n64_f32[0];
    v291 = this->m_nSelectedButton;
    v292 = 5 * v291;
    v293 = &this->m_AdjustableButtons[v291];
    v1.n64_f32[1] = v11.n64_f32[0] + v284;
    v1.n64_f32[0] = fabsf(v289 - left) * 0.5;
    v294.n64_f32[1] = v287 - (float)(v287 * 0.0);
    v10.n64_f32[0] = (float)(v10.n64_f32[0] + v9.n64_f32[0]) * 0.5;
    v5.n64_f32[0] = (float)(v11.n64_f32[0] + v284) * 0.5;
    v2.n64_f32[1] = v290 - v1.n64_f32[0];
    v7.n64_f32[0] = (float)(v287 * 0.0) + v1.n64_f32[0];
    v9.n64_f32[0] = (float)(v290 - (float)(v290 * 0.0)) - v1.n64_f32[0];
    v11.n64_f32[0] = v294.n64_f32[1] - v1.n64_f32[0];
    v294.n64_f32[0] = v1.n64_f32[0]
                    + (float)(fScaleX + (float)(fOriginY * (float)((float)RsGlobal.screenHeight / 448.0)));
    v3.n64_f32[0] = fabsf(v293->m_RectScreen.right - v293->m_RectScreen.left) * 0.5;
    v6.n64_f32[0] = (float)(v290 - v1.n64_f32[0]) + (float)(v290 * -0.067);
    v295.n64_u64[0] = vmax_f32(v5, v7).n64_u64[0];
    v296 = 1000000.0;
    v297.n64_u64[0] = vmax_f32(v10, v294).n64_u64[0];
    v4.n64_u64[0] = vmin_f32(v295, v11).n64_u64[0];
    v6.n64_u64[0] = vmin_f32(v297, vmin_f32(v6, v9)).n64_u64[0];
    do
    {
      if ( v291 )
      {
        v298 = (char *)this + v285 * 40;
        v299 = !this->m_AdjustableButtons[v285].m_bEnabled;
        if ( this->m_AdjustableButtons[v285].m_bEnabled )
          v299 = (*((_DWORD *)v298 + 34) & this->m_nAdjustmentMode) == 0;
        if ( !v299 )
        {
          v300 = *((float *)v298 + 28);
          v1.n64_u32[1] = *((_DWORD *)v298 + 30);
          v301 = (float)((float)(*((float *)v298 + 29) + *((float *)v298 + 31)) * 0.5) - v6.n64_f32[0];
          v2.n64_f32[1] = (float)((float)((float)(v300 + v1.n64_f32[1]) * 0.5) - v4.n64_f32[0])
                        * (float)((float)((float)(v300 + v1.n64_f32[1]) * 0.5) - v4.n64_f32[0]);
          v302 = sqrtf(v2.n64_f32[1] + (float)(v301 * v301));
          v303 = v302 < v296;
          if ( v302 >= (float)(v3.n64_f32[0] + (float)(fabsf(v1.n64_f32[1] - v300) * 0.5)) )
            v302 = v296;
          if ( !v303 )
            v302 = v296;
          v296 = v302;
        }
      }
      ++v285;
      --v291;
    }
    while ( v285 != 19 );
    if ( v296 == 1000000.0 )
    {
      v304 = (float *)(&this->m_nAdjustmentMode + 2 * v292);
      v293->m_RectScreen.left = v4.n64_f32[0] - v1.n64_f32[0];
      v304[29] = v1.n64_f32[0] + v6.n64_f32[0];
      v293->m_RectScreen.right = v1.n64_f32[0] + v4.n64_f32[0];
      v304[31] = v6.n64_f32[0] - v1.n64_f32[0];
    }
  }
  v305 = p_m_vecCoords->x;
  v306 = *p_y;
  v307 = (float)RsGlobal.screenWidth;
  if ( sqrtf(
         (float)((float)(p_m_vecCoords->x - this->m_vecDragAnchor.x)
               * (float)(p_m_vecCoords->x - this->m_vecDragAnchor.x))
       + (float)((float)(*p_y - this->m_vecDragAnchor.y) * (float)(*p_y - this->m_vecDragAnchor.y))) <= (float)((float)RsGlobal.screenWidth * 0.0025) )
  {
    if ( !this->m_bMovedButton )
      goto LABEL_291;
  }
  else
  {
    this->m_bMovedButton = 1;
  }
  v316 = this->m_vecDragOffset.y;
  v317 = 0;
  v318 = &this->m_AdjustableButtons[this->m_nSelectedButton];
  v319 = this->m_vecDragOffset.x;
  v320 = v318->m_RectScreen.left;
  v321 = v318->m_RectScreen.right;
  v322 = (float)RsGlobal.screenHeight;
  fOriginY = 0.0;
  fOriginX[0] = 0.0;
  fScaleY = 0.0;
  fScaleX = 0.0;
  CTouchInterface::GetWidgetPosition(WIDGET_POSITION_PLAYER_INFO, fOriginX, &fOriginY, &fScaleX, &fScaleY);
  OS_ScreenGetWidth();
  OS_ScreenGetHeight();
  OS_ScreenGetWidth();
  OS_ScreenGetHeight();
  v323 = RsGlobal.screenHeight;
  v324 = 0.0;
  v325 = this->m_nSelectedButton;
  v326 = 5 * v325;
  v327 = &this->m_AdjustableButtons[v325];
  p_left = &v327->m_RectScreen.left;
  p_right = &v327->m_RectScreen.right;
  v330 = fabsf(v321 - v320) * 0.5;
  v1.n64_f32[0] = v305 + v319;
  v7.n64_f32[0] = v330 + (float)(v307 * 0.0);
  v4.n64_f32[0] = (float)(v322 - (float)(v322 * 0.0)) - v330;
  v8.n64_f32[0] = (float)(v307 - (float)(v307 * 0.0)) - v330;
  v5.n64_f32[0] = (float)(v322 - v330) + (float)(v322 * -0.067);
  v6.n64_f32[0] = v306 + v316;
  v331 = 0.0;
  v332.n64_u64[0] = vmax_f32(v1, v7).n64_u64[0];
  v333 = fabsf(v327->m_RectScreen.right - v327->m_RectScreen.left) * 0.5;
  v2.n64_f32[0] = v330 + (float)(fScaleX + (float)(fOriginY * (float)((float)RsGlobal.screenHeight / 448.0)));
  v334 = 1000000.0;
  v335.n64_u64[0] = vmax_f32(v6, v2).n64_u64[0];
  LODWORD(v336) = vmin_f32(v332, v8).n64_u32[0];
  v337.n64_u64[0] = vmin_f32(v335, vmin_f32(v5, v4)).n64_u64[0];
  do
  {
    if ( v325 )
    {
      v338 = (char *)this + v317 * 40;
      v339 = !this->m_AdjustableButtons[v317].m_bEnabled;
      if ( this->m_AdjustableButtons[v317].m_bEnabled )
        v339 = (*((_DWORD *)v338 + 34) & this->m_nAdjustmentMode) == 0;
      if ( !v339 )
      {
        v340 = *((float *)v338 + 28);
        v341 = 0LL;
        v342 = *((float *)v338 + 30);
        v343 = (float)(*((float *)v338 + 29) + *((float *)v338 + 31)) * 0.5;
        v344 = (float)(v340 + v342) * 0.5;
        v3.n64_f32[1] = (float)(v344 - v336) * (float)(v344 - v336);
        v345 = v333 + (float)(fabsf(v342 - v340) * 0.5);
        v346 = sqrtf(v3.n64_f32[1] + (float)((float)(v343 - v337.n64_f32[0]) * (float)(v343 - v337.n64_f32[0])));
        if ( v346 >= v345 )
          LODWORD(v341) = 1;
        if ( v346 >= v334 )
          HIDWORD(v341) = 1;
        if ( v341 )
        {
          v346 = v334;
          v343 = v331;
          v344 = v324;
        }
        v324 = v344;
        v331 = v343;
        v334 = v346;
      }
    }
    ++v317;
    --v325;
  }
  while ( v317 != 19 );
  if ( v334 == 1000000.0 )
  {
    v347 = (float *)(&this->m_nAdjustmentMode + 2 * v326);
    *p_left = v336 - v330;
    v347[29] = v330 + v337.n64_f32[0];
    *p_right = v330 + v336;
    v347[31] = v337.n64_f32[0] - v330;
  }
  else
  {
    v348 = 0;
    while ( 1 )
    {
      v349 = (float)(*p_y + this->m_vecDragOffset.y) - v331;
      v350 = (float)(p_m_vecCoords->x + this->m_vecDragOffset.x) - v324;
      v351 = (float)(v350 * v350) + (float)(v349 * v349);
      if ( v351 <= 0.0 )
      {
        v353 = 1.0;
      }
      else
      {
        v352 = 1.0 / sqrtf(v351);
        v349 = v349 * v352;
        v353 = v350 * v352;
      }
      v354 = 0;
      v355 = RsGlobal.screenWidth;
      fOriginY = 0.0;
      fOriginX[0] = 0.0;
      fScaleY = 0.0;
      fScaleX = 0.0;
      CTouchInterface::GetWidgetPosition(WIDGET_POSITION_PLAYER_INFO, fOriginX, &fOriginY, &fScaleX, &fScaleY);
      OS_ScreenGetWidth();
      OS_ScreenGetHeight();
      OS_ScreenGetWidth();
      OS_ScreenGetHeight();
      v356 = this->m_nSelectedButton;
      v357 = (float *)(&this->m_nAdjustmentMode + 10 * v356);
      v358.n64_f32[1] = (float)v355 * 0.0;
      v3.n64_f32[0] = (float)((float)v355 * 0.002) * (float)v348;
      v359.n64_f32[1] = (float)v323 - v330;
      v359.n64_f32[0] = v359.n64_f32[1] + (float)((float)v323 * -0.067);
      v337.n64_f32[0] = (float)((float)v323 - (float)((float)v323 * 0.0)) - v330;
      v6.n64_f32[0] = v330 + v358.n64_f32[1];
      v358.n64_f32[0] = (float)((float)v355 - v358.n64_f32[1]) - v330;
      v8.n64_f32[0] = v324 + (float)(v353 * v3.n64_f32[0]);
      v3.n64_f32[0] = v331 + (float)(v349 * v3.n64_f32[0]);
      v360.n64_u64[0] = vmin_f32(v359, v337).n64_u64[0];
      v337.n64_f32[0] = v330 + (float)(fScaleX + (float)(fOriginY * (float)((float)RsGlobal.screenHeight / 448.0)));
      v361 = fabsf(v357[30] - v357[28]) * 0.5;
      v362.n64_u64[0] = vmax_f32(v3, v337).n64_u64[0];
      v363 = 1000000.0;
      LODWORD(v364) = vmin_f32(vmax_f32(v8, v6), v358).n64_u32[0];
      v3.n64_u64[0] = vmin_f32(v362, v360).n64_u64[0];
      do
      {
        if ( v356 )
        {
          v365 = (char *)this + v354 * 40;
          v366 = !this->m_AdjustableButtons[v354].m_bEnabled;
          if ( this->m_AdjustableButtons[v354].m_bEnabled )
            v366 = (*((_DWORD *)v365 + 34) & this->m_nAdjustmentMode) == 0;
          if ( !v366 )
          {
            v367 = *((float *)v365 + 28);
            v368 = *((float *)v365 + 30);
            v369 = (float)((float)(*((float *)v365 + 29) + *((float *)v365 + 31)) * 0.5) - v3.n64_f32[0];
            v370 = sqrtf(
                     (float)((float)((float)((float)(v367 + v368) * 0.5) - v364)
                           * (float)((float)((float)(v367 + v368) * 0.5) - v364))
                   + (float)(v369 * v369));
            v371 = v370 < v363;
            if ( v370 >= (float)(v361 + (float)(fabsf(v368 - v367) * 0.5)) )
              v370 = v363;
            if ( !v371 )
              v370 = v363;
            v363 = v370;
          }
        }
        ++v354;
        --v356;
      }
      while ( v354 != 19 );
      if ( v363 == 1000000.0 )
        break;
      v58 = v348 <= 98;
      v323 = RsGlobal.screenHeight;
      ++v348;
      if ( !v58 )
        goto LABEL_291;
    }
    v357[28] = v364 - v330;
    v357[29] = v330 + v3.n64_f32[0];
    v357[30] = v330 + v364;
    v357[31] = v3.n64_f32[0] - v330;
  }
LABEL_291:
  if ( this->m_bQueuedExit )
  {
    this->m_nAdjustmentMode = 1;
    v373 = 0;
    v374 = 0;
    while ( 1 )
    {
      v375 = v374;
      this->m_nSelectedButton = v374;
      v376 = (float32x2_t *)((char *)this + 40 * v374);
      v377 = v376[17].n64_u8[5] == 0;
      if ( v376[17].n64_u8[5] )
        v377 = v376[17].n64_u8[0] << 31 == 0;
      if ( !v377 )
      {
        v378 = v376 + 14;
        v379.n64_u64[0] = v378->n64_u64[0];
        v380.n64_u64[0] = v378[1].n64_u64[0];
        v381 = 0;
        v382.n64_u64[0] = vadd_f32(v379, v380).n64_u64[0];
        v383 = v380.n64_f32[0] - v379.n64_f32[0];
        v384 = 1000000.0;
        v385.n64_u64[0] = vmul_f32(v382, (float32x2_t)0x3F0000003F000000LL).n64_u64[0];
        v386 = fabsf(v383) * 0.5;
        do
        {
          if ( v373 != v381 )
          {
            v387 = (float32x2_t *)((char *)this + v381);
            v388 = !this->m_AdjustableButtons[v381 / 0x28].m_bEnabled;
            if ( this->m_AdjustableButtons[v381 / 0x28].m_bEnabled )
              v388 = v387[17].n64_u8[0] << 31 == 0;
            if ( !v388 )
            {
              v389.n64_u64[0] = v387[14].n64_u64[0];
              v390.n64_u64[0] = v387[15].n64_u64[0];
              v391.n64_u64[0] = vsub_f32(vmul_f32(vadd_f32(v389, v390), (float32x2_t)0x3F0000003F000000LL), v385).n64_u64[0];
              v389.n64_f32[0] = fabsf(v390.n64_f32[0] - v389.n64_f32[0]);
              v392 = vmul_f32(v391, v391).n64_u64[0];
              v393 = sqrtf(*(float *)&v392 + *((float *)&v392 + 1));
              v394 = v393 < v384;
              if ( v393 >= (float)(v386 + (float)(v389.n64_f32[0] * 0.5)) )
                v393 = v384;
              if ( !v394 )
                v393 = v384;
              v384 = v393;
            }
          }
          v381 += 40;
        }
        while ( v381 != 760 );
        if ( v384 != 1000000.0 )
          break;
      }
      v373 += 40;
      v374 = v375 + 1;
      if ( v375 >= 18 )
      {
        v395 = 0;
        this->m_nAdjustmentMode = 2;
        v396 = 0;
        while ( 1 )
        {
          v397 = v395;
          this->m_nSelectedButton = v395;
          v398 = (float32x2_t *)((char *)this + 40 * v395);
          if ( v398[17].n64_u8[5] )
          {
            if ( (v398[17].n64_u8[0] & 2) != 0 )
            {
              v399 = v398 + 14;
              v400.n64_u64[0] = v399->n64_u64[0];
              v401.n64_u64[0] = v399[1].n64_u64[0];
              v402 = 0;
              v403.n64_u64[0] = vadd_f32(v400, v401).n64_u64[0];
              v404 = v401.n64_f32[0] - v400.n64_f32[0];
              v405 = 1000000.0;
              v406.n64_u64[0] = vmul_f32(v403, (float32x2_t)0x3F0000003F000000LL).n64_u64[0];
              v407 = fabsf(v404) * 0.5;
              do
              {
                if ( v396 != v402 )
                {
                  v408 = (float32x2_t *)((char *)this + v402);
                  if ( this->m_AdjustableButtons[v402 / 0x28].m_bEnabled && (v408[17].n64_u8[0] & 2) != 0 )
                  {
                    v409.n64_u64[0] = v408[14].n64_u64[0];
                    v410.n64_u64[0] = v408[15].n64_u64[0];
                    v411.n64_u64[0] = vsub_f32(vmul_f32(vadd_f32(v409, v410), (float32x2_t)0x3F0000003F000000LL), v406).n64_u64[0];
                    v409.n64_f32[0] = fabsf(v410.n64_f32[0] - v409.n64_f32[0]);
                    v412 = vmul_f32(v411, v411).n64_u64[0];
                    v413 = sqrtf(*(float *)&v412 + *((float *)&v412 + 1));
                    v414 = v413 < v405;
                    if ( v413 >= (float)(v407 + (float)(v409.n64_f32[0] * 0.5)) )
                      v413 = v405;
                    if ( !v414 )
                      v413 = v405;
                    v405 = v413;
                  }
                }
                v402 += 40;
              }
              while ( v402 != 760 );
              if ( v405 != 1000000.0 )
                goto LABEL_326;
            }
          }
          v396 += 40;
          v395 = v397 + 1;
          if ( v397 >= 18 )
          {
            if ( CAdjustableHUD::m_pInstance )
            {
              CAdjustableHUD::~CAdjustableHUD(CAdjustableHUD::m_pInstance);
              operator delete(v415);
              v416 = 0;
            }
            else
            {
              v417 = (CAdjustableHUD *)operator new(0x4B0u);
              CAdjustableHUD::CAdjustableHUD(v417);
            }
            CAdjustableHUD::m_pInstance = v416;
            PlayBackSound();
            goto LABEL_329;
          }
        }
      }
    }
LABEL_326:
    this->m_nSelectedButton = -1;
    *(_WORD *)&this->m_bOverlappingDialog = 1;
    PlayErrorSound();
  }
  else
  {
LABEL_329:
    if ( LIB_KeyboardState(KK_ESCAPE) == OSPS_ButtonReleased )
    {
      v418 = *(_QWORD *)&this->m_SavedButtonPositions[1].left;
      v419 = *(_QWORD *)&this->m_SavedButtonPositions[1].right;
      v420 = *(_QWORD *)&this->m_SavedButtonPositions[2].left;
      v421 = *(_QWORD *)&this->m_SavedButtonPositions[2].right;
      v422 = *(_QWORD *)&this->m_SavedButtonPositions[3].left;
      v423 = *(_QWORD *)&this->m_SavedButtonPositions[3].right;
      v424 = *(_QWORD *)&this->m_SavedButtonPositions[4].left;
      v425 = *(_QWORD *)&this->m_SavedButtonPositions[4].right;
      v426 = *(_QWORD *)&this->m_SavedButtonPositions[5].left;
      v427 = *(_QWORD *)&this->m_SavedButtonPositions[5].right;
      v428 = *(_QWORD *)&this->m_SavedButtonPositions[6].left;
      v429 = *(_QWORD *)&this->m_SavedButtonPositions[6].right;
      v430 = *(_QWORD *)&this->m_SavedButtonPositions[7].left;
      v431 = *(_QWORD *)&this->m_SavedButtonPositions[7].right;
      v432 = *(_QWORD *)&this->m_SavedButtonPositions[0].right;
      *(_QWORD *)&this->m_AdjustableButtons[0].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[0].left;
      *(_QWORD *)&this->m_AdjustableButtons[0].m_RectScreen.right = v432;
      *(_QWORD *)&this->m_AdjustableButtons[1].m_RectScreen.left = v418;
      *(_QWORD *)&this->m_AdjustableButtons[1].m_RectScreen.right = v419;
      *(_QWORD *)&this->m_AdjustableButtons[2].m_RectScreen.left = v420;
      *(_QWORD *)&this->m_AdjustableButtons[2].m_RectScreen.right = v421;
      *(_QWORD *)&this->m_AdjustableButtons[3].m_RectScreen.left = v422;
      *(_QWORD *)&this->m_AdjustableButtons[3].m_RectScreen.right = v423;
      *(_QWORD *)&this->m_AdjustableButtons[4].m_RectScreen.left = v424;
      *(_QWORD *)&this->m_AdjustableButtons[4].m_RectScreen.right = v425;
      *(_QWORD *)&this->m_AdjustableButtons[5].m_RectScreen.left = v426;
      *(_QWORD *)&this->m_AdjustableButtons[5].m_RectScreen.right = v427;
      *(_QWORD *)&this->m_AdjustableButtons[6].m_RectScreen.left = v428;
      *(_QWORD *)&this->m_AdjustableButtons[6].m_RectScreen.right = v429;
      *(_QWORD *)&this->m_AdjustableButtons[7].m_RectScreen.left = v430;
      *(_QWORD *)&this->m_AdjustableButtons[7].m_RectScreen.right = v431;
      v433 = *(_QWORD *)&this->m_SavedButtonPositions[8].right;
      *(_QWORD *)&this->m_AdjustableButtons[8].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[8].left;
      *(_QWORD *)&this->m_AdjustableButtons[8].m_RectScreen.right = v433;
      v434 = *(_QWORD *)&this->m_SavedButtonPositions[9].right;
      *(_QWORD *)&this->m_AdjustableButtons[9].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[9].left;
      *(_QWORD *)&this->m_AdjustableButtons[9].m_RectScreen.right = v434;
      v435 = *(_QWORD *)&this->m_SavedButtonPositions[10].right;
      *(_QWORD *)&this->m_AdjustableButtons[10].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[10].left;
      *(_QWORD *)&this->m_AdjustableButtons[10].m_RectScreen.right = v435;
      v436 = *(_QWORD *)&this->m_SavedButtonPositions[11].right;
      *(_QWORD *)&this->m_AdjustableButtons[11].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[11].left;
      *(_QWORD *)&this->m_AdjustableButtons[11].m_RectScreen.right = v436;
      v437 = *(_QWORD *)&this->m_SavedButtonPositions[12].right;
      *(_QWORD *)&this->m_AdjustableButtons[12].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[12].left;
      *(_QWORD *)&this->m_AdjustableButtons[12].m_RectScreen.right = v437;
      v438 = *(_QWORD *)&this->m_SavedButtonPositions[13].right;
      *(_QWORD *)&this->m_AdjustableButtons[13].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[13].left;
      *(_QWORD *)&this->m_AdjustableButtons[13].m_RectScreen.right = v438;
      v439 = *(_QWORD *)&this->m_SavedButtonPositions[14].right;
      *(_QWORD *)&this->m_AdjustableButtons[14].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[14].left;
      *(_QWORD *)&this->m_AdjustableButtons[14].m_RectScreen.right = v439;
      v440 = *(_QWORD *)&this->m_SavedButtonPositions[15].right;
      *(_QWORD *)&this->m_AdjustableButtons[15].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[15].left;
      *(_QWORD *)&this->m_AdjustableButtons[15].m_RectScreen.right = v440;
      v441 = *(_QWORD *)&this->m_SavedButtonPositions[16].right;
      *(_QWORD *)&this->m_AdjustableButtons[16].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[16].left;
      *(_QWORD *)&this->m_AdjustableButtons[16].m_RectScreen.right = v441;
      v442 = *(_QWORD *)&this->m_SavedButtonPositions[17].right;
      *(_QWORD *)&this->m_AdjustableButtons[17].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[17].left;
      *(_QWORD *)&this->m_AdjustableButtons[17].m_RectScreen.right = v442;
      v443 = *(_QWORD *)&this->m_SavedButtonPositions[18].right;
      *(_QWORD *)&this->m_AdjustableButtons[18].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[18].left;
      *(_QWORD *)&this->m_AdjustableButtons[18].m_RectScreen.right = v443;
      this->m_bQueuedExit = 1;
    }
  }
}
// 283A14: variable 'v5' is possibly undefined
// 283A30: variable 'v7' is possibly undefined
// 283A2C: variable 'v4' is possibly undefined
// 283EF0: variable 'v10' is possibly undefined
// 283EF4: variable 'v11' is possibly undefined
// 283EF8: variable 'v6' is possibly undefined
// 283EF8: variable 'v9' is possibly undefined
// 2841A2: variable 'v1' is possibly undefined
// 2841B6: variable 'v2' is possibly undefined
// 2841BA: variable 'v8' is possibly undefined
// 2843E0: variable 'v3' is possibly undefined
// 2846E8: variable 'v415' is possibly undefined
// 284716: variable 'v416' is possibly undefined
// 6DFE58: using guessed type char bUsedKeyboard;

//----- (002848A4) --------------------------------------------------------
void __fastcall CAdjustableHUD::~CAdjustableHUD(CAdjustableHUD *this)
{
  CAdjustableHUD::SaveToDisk(this);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[18].m_Sprite);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[18].m_SpriteBackground);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[17].m_Sprite);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[17].m_SpriteBackground);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[16].m_Sprite);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[16].m_SpriteBackground);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[15].m_Sprite);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[15].m_SpriteBackground);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[14].m_Sprite);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[14].m_SpriteBackground);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[13].m_Sprite);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[13].m_SpriteBackground);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[12].m_Sprite);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[12].m_SpriteBackground);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[11].m_Sprite);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[11].m_SpriteBackground);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[10].m_Sprite);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[10].m_SpriteBackground);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[9].m_Sprite);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[9].m_SpriteBackground);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[8].m_Sprite);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[8].m_SpriteBackground);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[7].m_Sprite);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[7].m_SpriteBackground);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[6].m_Sprite);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[6].m_SpriteBackground);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[5].m_Sprite);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[5].m_SpriteBackground);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[4].m_Sprite);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[4].m_SpriteBackground);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[3].m_Sprite);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[3].m_SpriteBackground);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[2].m_Sprite);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[2].m_SpriteBackground);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[1].m_Sprite);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[1].m_SpriteBackground);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[0].m_Sprite);
  CSprite2d::~CSprite2d(&this->m_AdjustableButtons[0].m_SpriteBackground);
}

//----- (002849E4) --------------------------------------------------------
void __fastcall CAdjustableHUD::SaveToDisk(CAdjustableHUD *this)
{
  u_native v1; // r4
  size_t v2; // r0
  unsigned int v3; // r9
  int i; // r4
  _DWORD *v5; // r5
  float *v6; // r6
  float v7; // s21
  float screenWidth; // s18
  int Width; // s22
  float Height; // s24
  float screenHeight; // s26
  float v12; // s25
  float v13; // s28
  float v14; // s30
  float v15; // s2
  float v16; // s0
  bool v17; // fzf
  bool v18; // fnf
  float v19; // s4
  float v20; // s0
  RwInt32 v21; // r9
  float v22; // s18
  float v23; // s30
  float v24; // s19
  float v25; // s22
  float v26; // s24
  float v27; // s26
  float v28; // s0
  float v29; // s27
  float v30; // s17
  float v31; // s24
  float v32; // s31
  float v33; // s26
  float v34; // s21
  float v35; // s18
  float v36; // s22
  float v37; // s28
  float v38; // s25
  float v39; // s23
  float v40; // s20
  bool v41; // cc
  float v42; // s18
  float v43; // s0
  float v44; // s0
  float v45; // s2
  RwInt32 v46; // r5
  float v47; // s23
  float v48; // s22
  float v49; // s26
  float v50; // s24
  float v51; // s20
  float v52; // s28
  float v53; // s2
  float v54; // s2
  float v55; // s28
  float v56; // s18
  float v57; // s20
  float v58; // s22
  float v59; // s0
  float v60; // s20
  float v61; // s22
  void *v62; // s0
  int *v63; // r0
  int *v64; // r5
  float v65; // s30
  float v66; // s19
  float v67; // s18
  float v68; // s0
  float v69; // s18
  void *v70; // s0
  int *v71; // r0
  int *v72; // r5
  float v73; // s18
  float v74; // s0
  float v75; // s18
  void *v76; // s0
  int *v77; // r0
  int *v78; // r5
  float v79; // s18
  float v80; // s0
  float v81; // s18
  float v82; // s0
  float v83; // s18
  float v84; // s0
  float v85; // s18
  float v86; // s0
  float v87; // s18
  float v88; // s0
  float v89; // s18
  float v90; // s0
  float v91; // s18
  float v92; // s0
  float v93; // s18
  float v94; // s0
  float v95; // s18
  float v96; // s0
  float v97; // s18
  float v98; // s0
  float v99; // s18
  float v100; // s20
  float v101; // s22
  float v102; // s24
  float v103; // s0
  size_t v104; // r0
  u_native id; // [sp+20h] [bp-2A8h]
  float fScaleY; // [sp+30h] [bp-298h] BYREF
  float fScaleX; // [sp+34h] [bp-294h] BYREF
  float fOriginY; // [sp+38h] [bp-290h] BYREF
  float fOriginX; // [sp+3Ch] [bp-28Ch] BYREF
  _QWORD v111[4]; // [sp+40h] [bp-288h] BYREF
  unsigned __int8 s[516]; // [sp+60h] [bp-268h] BYREF

  CTouchInterface::LoadDefaultConfigFile();
  CFileMgr::SetDirMyDocuments();
  v1 = CFileMgr::OpenFileForWriting("Adjustable.cfg");
  strcpy(
    (char *)s,
    ";User defined touch control placement. This file contains only positions that have\n"
    "; been modified by the user and is loaded on top of the defaults file.\n");
  v2 = strlen((const char *)s);
  id = v1;
  CFileMgr::Write(v1, s, v2);
  v3 = (unsigned int)v111;
  for ( i = 0; i != 19; ++i )
  {
    fOriginY = 0.0;
    fOriginX = 0.0;
    fScaleY = 0.0;
    fScaleX = 0.0;
    v5 = (_DWORD *)v3;
    v6 = (float *)((char *)&this->m_nAdjustmentMode + i * 40);
    CTouchInterface::GetWidgetPosition(
      this->m_AdjustableButtons[i].m_WidgetPositionID,
      &fOriginX,
      &fOriginY,
      &fScaleX,
      &fScaleY);
    v7 = fOriginX;
    screenWidth = (float)RsGlobal.screenWidth;
    Width = OS_ScreenGetWidth();
    Height = (float)(unsigned int)OS_ScreenGetHeight();
    screenHeight = (float)RsGlobal.screenHeight;
    v12 = fScaleX;
    v13 = (float)RsGlobal.screenWidth;
    v14 = (float)(unsigned int)OS_ScreenGetWidth();
    v15 = 0.0;
    v16 = v14 / (float)(unsigned int)OS_ScreenGetHeight();
    v17 = v16 == 1.9;
    v18 = v16 < 1.9;
    v19 = 0.0;
    if ( (float)((float)(unsigned int)Width / Height) > 1.9 )
      v15 = 30.0;
    v20 = screenWidth - v15;
    if ( !v18 && !v17 )
      v19 = 30.0;
    v21 = RsGlobal.screenHeight;
    v22 = (float)(v13 - v19) / 640.0;
    if ( (float)(v13 / screenHeight) > 1.8 )
      v22 = (float)(v22 + (float)((float)RsGlobal.screenHeight / 448.0)) * 0.5;
    v23 = fScaleY;
    v24 = fOriginY;
    v25 = v20 / 640.0;
    v26 = (float)RsGlobal.screenWidth;
    v27 = (float)(unsigned int)OS_ScreenGetWidth();
    v28 = 0.0;
    if ( (float)(v27 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
      v28 = 30.0;
    v29 = (float)v21;
    v30 = (float)(v26 - v28) / 640.0;
    if ( (float)(v26 / (float)v21) > 1.8 )
      v30 = (float)(v30 + (float)((float)RsGlobal.screenHeight / 448.0)) * 0.5;
    v3 = (unsigned int)v5;
    v31 = v7 * v25;
    v32 = fOriginX;
    v33 = v12 * v22;
    v34 = (float)RsGlobal.screenWidth;
    v35 = (float)(unsigned int)OS_ScreenGetWidth();
    v36 = (float)(unsigned int)OS_ScreenGetHeight();
    v37 = (float)RsGlobal.screenHeight;
    v38 = fScaleX;
    v39 = (float)RsGlobal.screenWidth;
    v40 = (float)(unsigned int)OS_ScreenGetWidth();
    v41 = (float)(v35 / v36) <= 1.9;
    v42 = 0.0;
    v43 = v40 / (float)(unsigned int)OS_ScreenGetHeight();
    if ( !v41 )
      v42 = 30.0;
    v41 = v43 <= 1.9;
    v44 = 0.0;
    if ( !v41 )
      v44 = 30.0;
    v45 = v39 / v37;
    v46 = RsGlobal.screenHeight;
    v47 = (float)(v39 - v44) / 640.0;
    if ( v45 > 1.8 )
      v47 = (float)(v47 + (float)((float)RsGlobal.screenHeight / 448.0)) * 0.5;
    v48 = v31 - v33;
    v49 = fScaleY;
    v50 = fOriginY;
    v51 = (float)RsGlobal.screenWidth;
    v52 = (float)(unsigned int)OS_ScreenGetWidth();
    v53 = 0.0;
    if ( (float)(v52 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
      v53 = 30.0;
    v54 = (float)(v51 - v53) / 640.0;
    if ( (float)(v51 / (float)v46) > 1.8 )
      v54 = (float)(v54 + (float)((float)RsGlobal.screenHeight / 448.0)) * 0.5;
    v55 = v6[28];
    if ( v48 != v55
      || (float)((float)(v24 * (float)(v29 / 448.0)) - (float)(v23 * v30)) != v6[31]
      || (float)((float)(v32 * (float)((float)(v34 - v42) / 640.0)) + (float)(v38 * v47)) != v6[30]
      || (float)((float)(v50 * (float)((float)v46 / 448.0)) + (float)(v49 * v54)) != v6[29] )
    {
      v56 = v6[30];
      v57 = (float)RsGlobal.screenWidth;
      v58 = (float)(unsigned int)OS_ScreenGetWidth();
      v59 = 0.0;
      if ( (float)(v58 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
        v59 = 30.0;
      strcpy((char *)v111, "ERROR");
      v60 = (float)(v57 - v59) / 640.0;
      v61 = (float)(unsigned int)OS_ScreenGetWidth();
      v62 = OS_ScreenGetHeight();
      v63 = dword_285450;
      v64 = &dword_285450[1];
      v65 = 999.9;
      v66 = (float)(fabsf(v56 - v55) / v60) * 0.5;
      if ( (float)(v61 / (float)(unsigned int)v62) > 1.9 )
        v63 = &dword_285450[1];
      if ( fabsf(v66 - *(float *)v63) < 999.9 )
      {
        v67 = (float)(unsigned int)OS_ScreenGetWidth();
        if ( (float)(v67 / (float)(unsigned int)OS_ScreenGetHeight()) <= 1.9 )
          v64 = dword_285450;
        v68 = v66 - *(float *)v64;
        qmemcpy((void *)v3, "SCALE_LARGEST_PH", 16);
        *(_DWORD *)(v3 + 16) = &loc_454E4E;
        v65 = fabsf(v68);
      }
      v69 = (float)(unsigned int)OS_ScreenGetWidth();
      v70 = OS_ScreenGetHeight();
      v71 = dword_285458;
      v72 = &dword_285458[1];
      if ( (float)(v69 / (float)(unsigned int)v70) > 1.9 )
        v71 = &dword_285458[1];
      if ( fabsf(v66 - *(float *)v71) < v65 )
      {
        v73 = (float)(unsigned int)OS_ScreenGetWidth();
        if ( (float)(v73 / (float)(unsigned int)OS_ScreenGetHeight()) <= 1.9 )
          v72 = dword_285458;
        v74 = v66 - *(float *)v72;
        strcpy((char *)(v3 | 6), "LARGEST");
        v65 = fabsf(v74);
        v111[0] = *(_QWORD *)"SCALE_LARGEST";
      }
      v75 = (float)(unsigned int)OS_ScreenGetWidth();
      v76 = OS_ScreenGetHeight();
      v77 = dword_285460;
      v78 = &dword_285460[1];
      if ( (float)(v75 / (float)(unsigned int)v76) > 1.9 )
        v77 = &dword_285460[1];
      if ( fabsf(v66 - *(float *)v77) < v65 )
      {
        v79 = (float)(unsigned int)OS_ScreenGetWidth();
        if ( (float)(v79 / (float)(unsigned int)OS_ScreenGetHeight()) <= 1.9 )
          v78 = dword_285460;
        v80 = v66 - *(float *)v78;
        strcpy((char *)(v3 | 5), "_LARGER");
        v65 = fabsf(v80);
        v111[0] = *(_QWORD *)"SCALE_LARGER";
      }
      v81 = (float)(unsigned int)OS_ScreenGetWidth();
      v82 = 29.0;
      if ( (float)(v81 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
        v82 = 24.65;
      if ( fabsf(v66 - v82) < v65 )
      {
        v83 = (float)(unsigned int)OS_ScreenGetWidth();
        v84 = 29.0;
        if ( (float)(v83 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
          v84 = 24.65;
        strcpy((char *)v111, "SCALE_LARGE");
        v65 = fabsf(v66 - v84);
      }
      v85 = (float)(unsigned int)OS_ScreenGetWidth();
      v86 = 24.0;
      if ( (float)(v85 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
        v86 = 20.4;
      if ( fabsf(v66 - v86) < v65 )
      {
        v87 = (float)(unsigned int)OS_ScreenGetWidth();
        v88 = 24.0;
        if ( (float)(v87 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
          v88 = 20.4;
        strcpy((char *)(v3 | 5), "_MEDIUM");
        v111[0] = *(_QWORD *)"SCALE_MEDIUM";
        v65 = fabsf(v66 - v88);
      }
      v89 = (float)(unsigned int)OS_ScreenGetWidth();
      v90 = 17.0;
      if ( (float)(v89 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
        v90 = 14.45;
      if ( fabsf(v66 - v90) < v65 )
      {
        v91 = (float)(unsigned int)OS_ScreenGetWidth();
        v92 = 17.0;
        if ( (float)(v91 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
          v92 = 14.45;
        strcpy((char *)v111, "SCALE_SMALL");
        v65 = fabsf(v66 - v92);
      }
      v93 = (float)(unsigned int)OS_ScreenGetWidth();
      v94 = 14.0;
      if ( (float)(v93 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
        v94 = 11.9;
      if ( fabsf(v66 - v94) < v65 )
      {
        v95 = (float)(unsigned int)OS_ScreenGetWidth();
        v96 = 14.0;
        if ( (float)(v95 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
          v96 = 11.9;
        strcpy((char *)(v3 | 6), "SMALLER");
        v111[0] = *(_QWORD *)"SCALE_SMALLER";
        v65 = fabsf(v66 - v96);
      }
      v97 = (float)(unsigned int)OS_ScreenGetWidth();
      v98 = 11.5;
      if ( (float)(v97 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
        v98 = 9.775;
      if ( fabsf(v66 - v98) < v65 )
      {
        OS_ScreenGetWidth();
        OS_ScreenGetHeight();
        strcpy((char *)(v3 | 7), "MALLEST");
        v111[0] = *(_QWORD *)"SCALE_SMALLEST";
      }
      v99 = v6[30];
      v100 = v6[28];
      v101 = (float)RsGlobal.screenWidth;
      v102 = (float)(unsigned int)OS_ScreenGetWidth();
      v103 = 0.0;
      if ( (float)(v102 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
        v103 = 30.0;
      sprintf(
        s,
        "PositionAndScale %d, %d, %s ; %s\n",
        (int)(float)((float)((float)(v100 + v99) * 0.5) / (float)((float)(v101 - v103) / 640.0)),
        (int)(float)((float)((float)(v6[29] + v6[31]) * 0.5) / (float)((float)RsGlobal.screenHeight / 448.0)),
        (const char *)v3,
        (const char *)CTouchInterface::m_pszWidgetPositionNames[*((_DWORD *)v6 + 27)]);
      v104 = strlen((const char *)s);
      CFileMgr::Write(id, s, v104);
    }
  }
  CFileMgr::CloseFile(id);
  CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
  CTouchInterface::LoadFromFile("Adjustable.cfg", 0);
  if ( CTouchInterface::m_pWidgets[0] )
    CTouchInterface::RepositionAdjustableWidgets();
}
// 285450: using guessed type int dword_285450[2];
// 285458: using guessed type int dword_285458[2];
// 285460: using guessed type int dword_285460[2];
// 61CADE: using guessed type char byte_61CADE;

//----- (002854D8) --------------------------------------------------------
void __fastcall CAdjustableHUD::EnableButtons(CAdjustableHUD *this)
{
  bool v1; // zf
  bool v2; // zf
  bool v3; // zf
  bool v4; // zf
  bool v5; // zf
  CWidget *v6; // r2
  CWidget *v7; // r1
  bool v8; // zf
  bool v9; // r12
  CWidget *v10; // r3
  CWidget *v11; // r2
  bool v12; // zf
  bool v13; // lr
  int32 value; // r3
  bool v15; // r1
  int32 v16; // r1

  this->m_AdjustableButtons[2].m_bShownAsRed = 1;
  if ( CTouchInterface::m_pWidgets[21] && CTouchInterface::m_pWidgets[21]->m_bCachedEnabled )
    this->m_AdjustableButtons[2].m_bShownAsRed = 0;
  if ( CTouchInterface::m_pWidgets[33] && CTouchInterface::m_pWidgets[33]->m_bCachedEnabled )
    this->m_AdjustableButtons[2].m_bShownAsRed = 0;
  this->m_AdjustableButtons[3].m_bShownAsRed = 1;
  if ( CTouchInterface::m_pWidgets[22] )
    this->m_AdjustableButtons[3].m_bShownAsRed = !CTouchInterface::m_pWidgets[22]->m_bCachedEnabled;
  this->m_AdjustableButtons[4].m_bShownAsRed = 1;
  if ( CTouchInterface::m_pWidgets[29] && CTouchInterface::m_pWidgets[29]->m_bCachedEnabled )
    this->m_AdjustableButtons[4].m_bShownAsRed = 0;
  this->m_AdjustableButtons[5].m_bShownAsRed = 1;
  v1 = CTouchInterface::m_pWidgets[69] == 0;
  if ( CTouchInterface::m_pWidgets[69] )
    v1 = !CTouchInterface::m_pWidgets[69]->m_bCachedEnabled;
  if ( !v1 )
    goto LABEL_31;
  v2 = CTouchInterface::m_pWidgets[71] == 0;
  if ( CTouchInterface::m_pWidgets[71] )
    v2 = !CTouchInterface::m_pWidgets[71]->m_bCachedEnabled;
  if ( !v2 )
    goto LABEL_31;
  v3 = CTouchInterface::m_pWidgets[70] == 0;
  if ( CTouchInterface::m_pWidgets[70] )
    v3 = !CTouchInterface::m_pWidgets[70]->m_bCachedEnabled;
  if ( !v3 )
    goto LABEL_31;
  v4 = CTouchInterface::m_pWidgets[72] == 0;
  if ( CTouchInterface::m_pWidgets[72] )
    v4 = !CTouchInterface::m_pWidgets[72]->m_bCachedEnabled;
  if ( !v4 )
    goto LABEL_31;
  v5 = CTouchInterface::m_pWidgets[28] == 0;
  if ( CTouchInterface::m_pWidgets[28] )
    v5 = !CTouchInterface::m_pWidgets[28]->m_bCachedEnabled;
  if ( !v5 )
LABEL_31:
    this->m_AdjustableButtons[5].m_bShownAsRed = 0;
  v6 = CTouchInterface::m_pWidgets[16];
  v7 = CTouchInterface::m_pWidgets[26];
  this->m_AdjustableButtons[13].m_bShownAsRed = 1;
  v8 = v6 == 0;
  if ( v6 )
    v8 = !v6->m_bCachedEnabled;
  if ( !v8 || v7 && v7->m_bCachedEnabled )
  {
    v9 = 0;
    this->m_AdjustableButtons[13].m_bShownAsRed = 0;
  }
  else
  {
    v9 = 1;
  }
  v10 = CTouchInterface::m_pWidgets[17];
  v11 = CTouchInterface::m_pWidgets[27];
  this->m_AdjustableButtons[14].m_bShownAsRed = 1;
  v12 = v10 == 0;
  if ( v10 )
    v12 = !v10->m_bCachedEnabled;
  if ( !v12 || v11 && v11->m_bCachedEnabled )
  {
    v13 = 0;
    this->m_AdjustableButtons[14].m_bShownAsRed = 0;
  }
  else
  {
    v13 = 1;
  }
  value = MobileSettings::settings[3].value;
  v15 = MobileSettings::settings[3].value != 1;
  this->m_AdjustableButtons[10].m_bShownAsRed = MobileSettings::settings[3].value != 1;
  this->m_AdjustableButtons[9].m_bShownAsRed = v15;
  if ( CTouchInterface::m_pWidgets[50] && CTouchInterface::m_pWidgets[50]->m_bCachedEnabled )
    this->m_AdjustableButtons[9].m_bShownAsRed = 0;
  if ( CTouchInterface::m_pWidgets[51] && CTouchInterface::m_pWidgets[51]->m_bCachedEnabled )
    this->m_AdjustableButtons[10].m_bShownAsRed = 0;
  v16 = MobileSettings::settings[9].value;
  this->m_AdjustableButtons[18].m_bShownAsRed = 1;
  LOBYTE(v16) = v16 != 0;
  this->m_AdjustableButtons[7].m_bShownAsRed = v16;
  this->m_AdjustableButtons[6].m_bShownAsRed = v16;
  this->m_AdjustableButtons[16].m_bShownAsRed = v16;
  if ( CTouchInterface::m_pWidgets[12] && CTouchInterface::m_pWidgets[12]->m_bCachedEnabled )
    this->m_AdjustableButtons[18].m_bShownAsRed = 0;
  if ( value != 1 )
  {
    this->m_AdjustableButtons[10].m_bShownAsRed = v13;
    this->m_AdjustableButtons[9].m_bShownAsRed = v9;
    this->m_AdjustableButtons[13].m_bShownAsRed = 1;
    this->m_AdjustableButtons[14].m_bShownAsRed = 1;
  }
}

//----- (002856E0) --------------------------------------------------------
void __fastcall CAdjustableHUD::SetTextures(CAdjustableHUD *this)
{
  TextureDatabaseRuntime *TextureDB; // r8
  bool v3; // zf
  unsigned __int8 *mpTexture; // r1
  bool v5; // zf
  CSprite2d *p_m_Sprite; // r0
  bool v7; // zf
  unsigned __int8 *v8; // r1
  bool v9; // zf
  bool v10; // zf
  unsigned __int8 *v11; // r1
  bool v12; // zf
  bool v13; // zf
  CSprite2d *v14; // r0
  bool v15; // zf
  bool v16; // zf
  bool v17; // zf
  bool v18; // zf
  bool v19; // zf
  CWidget *v20; // r0
  bool v21; // zf
  unsigned __int8 *v22; // r1
  bool v23; // zf
  bool v24; // zf
  CSprite2d *v25; // r0
  char *v26; // r1
  bool v27; // zf
  unsigned __int8 *v28; // r1
  bool v29; // zf
  unsigned __int8 *v30; // r1
  CSprite2d *v31; // r0
  char *v32; // r1
  __int64 v33; // kr00_8
  bool v34; // zf
  bool v35; // zf

  TextureDB = CTouchInterface::LoadTextureDB();
  v3 = CTouchInterface::m_pWidgets[1] == 0;
  if ( CTouchInterface::m_pWidgets[1] )
    v3 = !CTouchInterface::m_pWidgets[1]->m_bCachedEnabled;
  if ( v3 )
  {
    v5 = CTouchInterface::m_pWidgets[15] == 0;
    if ( CTouchInterface::m_pWidgets[15] )
      v5 = !CTouchInterface::m_pWidgets[15]->m_bCachedEnabled;
    if ( v5 )
    {
      p_m_Sprite = &this->m_AdjustableButtons[1].m_Sprite;
      mpTexture = CTouchInterface::m_pszWidgetTextures[19];
      goto LABEL_13;
    }
    mpTexture = (unsigned __int8 *)CTouchInterface::m_pWidgets[15]->m_Sprite.mpTexture;
  }
  else
  {
    mpTexture = (unsigned __int8 *)CTouchInterface::m_pWidgets[1]->m_Sprite.mpTexture;
  }
  p_m_Sprite = &this->m_AdjustableButtons[1].m_Sprite;
  if ( mpTexture )
    mpTexture += 16;
LABEL_13:
  CSprite2d::SetTexture(p_m_Sprite, mpTexture);
  v7 = CTouchInterface::m_pWidgets[33] == 0;
  if ( CTouchInterface::m_pWidgets[33] )
    v7 = !CTouchInterface::m_pWidgets[33]->m_bCachedEnabled;
  if ( !v7 )
  {
    v8 = (unsigned __int8 *)CTouchInterface::m_pWidgets[33]->m_Sprite.mpTexture;
LABEL_21:
    if ( v8 )
      v8 += 16;
    CSprite2d::SetTexture(&this->m_AdjustableButtons[2].m_Sprite, v8);
    goto LABEL_24;
  }
  v9 = CTouchInterface::m_pWidgets[21] == 0;
  if ( CTouchInterface::m_pWidgets[21] )
    v9 = !CTouchInterface::m_pWidgets[21]->m_bCachedEnabled;
  if ( !v9 )
  {
    v8 = (unsigned __int8 *)CTouchInterface::m_pWidgets[21]->m_Sprite.mpTexture;
    goto LABEL_21;
  }
LABEL_24:
  CSprite2d::SetTexture(&this->m_AdjustableButtons[4].m_Sprite, CTouchInterface::m_pszWidgetTextures[29]);
  v10 = CTouchInterface::m_pWidgets[28] == 0;
  if ( CTouchInterface::m_pWidgets[28] )
    v10 = !CTouchInterface::m_pWidgets[28]->m_bCachedEnabled;
  if ( v10 )
  {
    v12 = CTouchInterface::m_pWidgets[71] == 0;
    if ( CTouchInterface::m_pWidgets[71] )
      v12 = !CTouchInterface::m_pWidgets[71]->m_bCachedEnabled;
    if ( v12 )
    {
      v13 = CTouchInterface::m_pWidgets[72] == 0;
      if ( CTouchInterface::m_pWidgets[72] )
        v13 = !CTouchInterface::m_pWidgets[72]->m_bCachedEnabled;
      if ( v13 )
      {
        v14 = &this->m_AdjustableButtons[5].m_Sprite;
        v11 = CTouchInterface::m_pszWidgetTextures[69];
        goto LABEL_38;
      }
      v11 = (unsigned __int8 *)CTouchInterface::m_pWidgets[72]->m_Sprite.mpTexture;
    }
    else
    {
      v11 = (unsigned __int8 *)CTouchInterface::m_pWidgets[71]->m_Sprite.mpTexture;
    }
  }
  else
  {
    v11 = (unsigned __int8 *)CTouchInterface::m_pWidgets[28]->m_Sprite.mpTexture;
  }
  v14 = &this->m_AdjustableButtons[5].m_Sprite;
  if ( v11 )
    v11 += 16;
LABEL_38:
  CSprite2d::SetTexture(v14, v11);
  CSprite2d::SetTexture(&this->m_AdjustableButtons[15].m_Sprite, CTouchInterface::m_pszWidgetTextures[11]);
  v15 = CTouchInterface::m_pWidgets[30] == 0;
  if ( CTouchInterface::m_pWidgets[30] )
    v15 = !CTouchInterface::m_pWidgets[30]->m_bCachedEnabled;
  if ( !v15 )
    CSprite2d::SetTexture(&this->m_AdjustableButtons[15].m_Sprite, CTouchInterface::m_pszWidgetTextures[30]);
  v16 = CTouchInterface::m_pWidgets[24] == 0;
  if ( CTouchInterface::m_pWidgets[24] )
    v16 = !CTouchInterface::m_pWidgets[24]->m_bCachedEnabled;
  if ( !v16 )
    CSprite2d::SetTexture(&this->m_AdjustableButtons[15].m_Sprite, CTouchInterface::m_pszWidgetTextures[24]);
  v17 = CTouchInterface::m_pWidgets[44] == 0;
  if ( CTouchInterface::m_pWidgets[44] )
    v17 = !CTouchInterface::m_pWidgets[44]->m_bCachedEnabled;
  if ( !v17 )
    CSprite2d::SetTexture(&this->m_AdjustableButtons[15].m_Sprite, CTouchInterface::m_pszWidgetTextures[44]);
  CSprite2d::SetTexture(&this->m_AdjustableButtons[8].m_Sprite, CTouchInterface::m_pszWidgetTextures[4]);
  v18 = CTouchInterface::m_pWidgets[45] == 0;
  if ( CTouchInterface::m_pWidgets[45] )
    v18 = !CTouchInterface::m_pWidgets[45]->m_bCachedEnabled;
  if ( !v18 )
    CSprite2d::SetTexture(&this->m_AdjustableButtons[8].m_Sprite, CTouchInterface::m_pszWidgetTextures[45]);
  v19 = CTouchInterface::m_pWidgets[67] == 0;
  if ( CTouchInterface::m_pWidgets[67] )
    v19 = !CTouchInterface::m_pWidgets[67]->m_bCachedEnabled;
  if ( !v19 )
    CSprite2d::SetTexture(&this->m_AdjustableButtons[8].m_Sprite, CTouchInterface::m_pszWidgetTextures[67]);
  v20 = CTouchInterface::m_pWidgets[73];
  v21 = CTouchInterface::m_pWidgets[14] == 0;
  if ( CTouchInterface::m_pWidgets[14] )
    v21 = !CTouchInterface::m_pWidgets[14]->m_bCachedEnabled;
  if ( !v21 && this->m_nAdjustmentMode == 1 )
  {
    v22 = (unsigned __int8 *)CTouchInterface::m_pWidgets[14]->m_Sprite.mpTexture;
LABEL_69:
    if ( v22 )
      v22 += 16;
    CSprite2d::SetTexture(&this->m_AdjustableButtons[0].m_Sprite, v22);
    goto LABEL_72;
  }
  v23 = CTouchInterface::m_pWidgets[73] == 0;
  if ( CTouchInterface::m_pWidgets[73] )
    v23 = !CTouchInterface::m_pWidgets[73]->m_bCachedEnabled;
  if ( !v23 && this->m_nAdjustmentMode == 1 || (v20 = CTouchInterface::m_pWidgets[0]) != 0 )
  {
    v22 = (unsigned __int8 *)v20->m_Sprite.mpTexture;
    goto LABEL_69;
  }
LABEL_72:
  v24 = CTouchInterface::m_pWidgets[34] == 0;
  if ( CTouchInterface::m_pWidgets[34] )
    v24 = !CTouchInterface::m_pWidgets[34]->m_bCachedEnabled;
  if ( v24 )
  {
    CSprite2d::SetTexture(&this->m_AdjustableButtons[16].m_SpriteBackground, "hud_circle");
    v25 = &this->m_AdjustableButtons[16].m_Sprite;
    v26 = "sprint";
  }
  else
  {
    CSprite2d::SetTexture(&this->m_AdjustableButtons[16].m_SpriteBackground, "hud_circle");
    v25 = &this->m_AdjustableButtons[16].m_Sprite;
    v26 = "hud_swim";
  }
  CSprite2d::SetTexture(v25, (unsigned __int8 *)v26);
  v27 = CTouchInterface::m_pWidgets[26] == 0;
  if ( CTouchInterface::m_pWidgets[26] )
    v27 = !CTouchInterface::m_pWidgets[26]->m_bCachedEnabled;
  if ( v27 )
  {
    if ( !CTouchInterface::m_pWidgets[16] )
      goto LABEL_86;
    v28 = (unsigned __int8 *)CTouchInterface::m_pWidgets[16]->m_Sprite.mpTexture;
  }
  else
  {
    v28 = (unsigned __int8 *)CTouchInterface::m_pWidgets[26]->m_Sprite.mpTexture;
  }
  if ( v28 )
    v28 += 16;
  CSprite2d::SetTexture(&this->m_AdjustableButtons[13].m_Sprite, v28);
LABEL_86:
  v29 = CTouchInterface::m_pWidgets[27] == 0;
  if ( CTouchInterface::m_pWidgets[27] )
    v29 = !CTouchInterface::m_pWidgets[27]->m_bCachedEnabled;
  if ( v29 )
  {
    if ( !CTouchInterface::m_pWidgets[17] )
      goto LABEL_95;
    v30 = (unsigned __int8 *)CTouchInterface::m_pWidgets[17]->m_Sprite.mpTexture;
  }
  else
  {
    v30 = (unsigned __int8 *)CTouchInterface::m_pWidgets[27]->m_Sprite.mpTexture;
  }
  if ( v30 )
    v30 += 16;
  CSprite2d::SetTexture(&this->m_AdjustableButtons[14].m_Sprite, v30);
LABEL_95:
  if ( MobileSettings::settings[3].value == 1 )
  {
    CSprite2d::SetTexture(&this->m_AdjustableButtons[9].m_Sprite, "hud_left");
    CSprite2d::SetTexture(&this->m_AdjustableButtons[10].m_Sprite, "hud_right");
    CSprite2d::SetTexture(&this->m_AdjustableButtons[13].m_Sprite, "leftshoot");
    v31 = &this->m_AdjustableButtons[14].m_Sprite;
    v32 = "shoot";
  }
  else
  {
    CSprite2d::SetTexture(&this->m_AdjustableButtons[9].m_Sprite, "leftshoot");
    CSprite2d::SetTexture(&this->m_AdjustableButtons[10].m_Sprite, "shoot");
    CSprite2d::SetTexture(&this->m_AdjustableButtons[13].m_Sprite, "hud_tank_left");
    v31 = &this->m_AdjustableButtons[14].m_Sprite;
    v32 = "hud_tank_right";
  }
  CSprite2d::SetTexture(v31, (unsigned __int8 *)v32);
  v33 = *(_QWORD *)&CTouchInterface::m_pWidgets[50];
  v34 = CTouchInterface::m_pWidgets[50] == 0;
  if ( CTouchInterface::m_pWidgets[50] )
    v34 = !CTouchInterface::m_pWidgets[50]->m_bCachedEnabled;
  if ( !v34 )
  {
    CSprite2d::SetTexture(&this->m_AdjustableButtons[9].m_SpriteBackground, (unsigned __int8 *)&byte_61CADE);
    CSprite2d::SetTexture(&this->m_AdjustableButtons[9].m_Sprite, "hud_plus");
  }
  v35 = HIDWORD(v33) == 0;
  if ( HIDWORD(v33) )
    v35 = *(_BYTE *)(HIDWORD(v33) + 78) == 0;
  if ( !v35 )
  {
    CSprite2d::SetTexture(&this->m_AdjustableButtons[10].m_SpriteBackground, (unsigned __int8 *)&byte_61CADE);
    CSprite2d::SetTexture(&this->m_AdjustableButtons[10].m_Sprite, "hud_minus");
  }
  sub_198F08(TextureDB);
}
// 61CADE: using guessed type char byte_61CADE;

//----- (00285B44) --------------------------------------------------------
void __fastcall CAdjustableHUD::ConstrainToDraggableRegion(CAdjustableHUD *this, CVector2D *vecOrigin, float fSize)
{
  float32x2_t v3; // d0
  float32x2_t v4; // d1
  float32x2_t v5; // d2
  float32x2_t v6; // d9
  unsigned __int64 v8; // r4
  float32x2_t v9; // d0
  float screenHeight; // s22
  float fScaleY; // [sp+8h] [bp-38h] BYREF
  float fScaleX; // [sp+Ch] [bp-34h] BYREF
  float fOriginY; // [sp+10h] [bp-30h] BYREF
  float fOriginX[11]; // [sp+14h] [bp-2Ch] BYREF

  v8 = __PAIR64__(&RsGlobal, (unsigned int)vecOrigin);
  v5.n64_u32[0] = LODWORD(vecOrigin->x);
  v6.n64_u32[0] = LODWORD(vecOrigin->y);
  v4.n64_f32[0] = (float)RsGlobal.screenWidth * 0.0;
  v3.n64_f32[0] = (float)RsGlobal.screenWidth - v4.n64_f32[0];
  v4.n64_f32[0] = v4.n64_f32[0] + fSize;
  v3.n64_f32[0] = v3.n64_f32[0] - fSize;
  v9.n64_u64[0] = vmin_f32(vmax_f32(v5, v4), v3).n64_u64[0];
  LODWORD(vecOrigin->x) = v9.n64_u32[0];
  screenHeight = (float)RsGlobal.screenHeight;
  fOriginY = 0.0;
  fOriginX[0] = 0.0;
  fScaleY = 0.0;
  fScaleX = 0.0;
  CTouchInterface::GetWidgetPosition(WIDGET_POSITION_PLAYER_INFO, fOriginX, &fOriginY, &fScaleX, &fScaleY);
  OS_ScreenGetWidth();
  OS_ScreenGetHeight();
  OS_ScreenGetWidth();
  OS_ScreenGetHeight();
  v5.n64_f32[0] = (float)(screenHeight - fSize) + (float)(screenHeight * -0.067);
  v9.n64_f32[0] = (float)(fScaleX + (float)(fOriginY * (float)((float)*(int *)(HIDWORD(v8) + 8) / 448.0))) + fSize;
  v4.n64_f32[0] = (float)(screenHeight - (float)(screenHeight * 0.0)) - fSize;
  *(_DWORD *)(v8 + 4) = vmin_f32(vmax_f32(v6, v9), vmin_f32(v5, v4)).n64_u32[0];
}
// 285B86: variable 'v5' is possibly undefined
// 285B86: variable 'v4' is possibly undefined
// 285B8A: variable 'v3' is possibly undefined
// 285BFC: variable 'v6' is possibly undefined
// 285B44: using guessed type float fOriginX[11];

//----- (00285C24) --------------------------------------------------------
bool __fastcall CAdjustableHUD::IsValidPosition(
        CAdjustableHUD *this,
        const CVector2D *vecOrigin,
        float fScale,
        CVector2D *pvecObstruction)
{
  float v4; // s4
  int v5; // r4
  int v6; // r12
  float v7; // s2
  char *v8; // lr
  bool v9; // zf
  float v10; // s10
  int v11; // r2
  int v12; // r5
  float v13; // s12
  float v14; // s6
  float v15; // s8
  float v16; // s14
  float v17; // s10

  v4 = 1000000.0;
  v5 = 0;
  v6 = 0;
  v7 = fScale * 0.5;
  do
  {
    if ( v6 != this->m_nSelectedButton )
    {
      v8 = (char *)this + v5 * 40;
      v9 = !this->m_AdjustableButtons[v5].m_bEnabled;
      if ( this->m_AdjustableButtons[v5].m_bEnabled )
        v9 = (*((_DWORD *)v8 + 34) & this->m_nAdjustmentMode) == 0;
      if ( !v9 )
      {
        v10 = *((float *)v8 + 28);
        v11 = 0;
        v12 = 0;
        v13 = *((float *)v8 + 30);
        v14 = (float)(*((float *)v8 + 29) + *((float *)v8 + 31)) * 0.5;
        v15 = (float)(v10 + v13) * 0.5;
        v16 = fabsf(v13 - v10);
        v17 = sqrtf(
                (float)((float)(v15 - vecOrigin->x) * (float)(v15 - vecOrigin->x))
              + (float)((float)(v14 - vecOrigin->y) * (float)(v14 - vecOrigin->y)));
        if ( v17 >= (float)(v7 + (float)(v16 * 0.5)) )
          v11 = 1;
        if ( v17 >= v4 )
          v12 = 1;
        if ( !(v11 | v12) )
        {
          v4 = v17;
          if ( pvecObstruction )
          {
            pvecObstruction->x = v15;
            pvecObstruction->y = v14;
            v4 = v17;
          }
        }
      }
    }
    ++v5;
    ++v6;
  }
  while ( v5 != 19 );
  return v4 == 1000000.0;
}

//----- (00285D14) --------------------------------------------------------
void __fastcall CAdjustableHUD::RestoreButtonPositions(CAdjustableHUD *this)
{
  __int64 v1; // d16
  __int64 v2; // d17
  __int64 v3; // d18
  __int64 v4; // d19
  __int64 v5; // d20
  __int64 v6; // d21
  __int64 v7; // d22
  __int64 v8; // d23
  __int64 v9; // d24
  __int64 v10; // d25
  __int64 v11; // d27
  __int64 v12; // d17
  __int64 v13; // d17
  __int64 v14; // d17
  __int64 v15; // d17
  __int64 v16; // d17
  __int64 v17; // d17
  __int64 v18; // d17
  __int64 v19; // d17
  __int64 v20; // d17
  __int64 v21; // d17
  __int64 v22; // d17
  __int64 v23; // d17
  CRect *v24; // r1
  CRect *p_m_RectScreen; // r0
  __int64 v26; // d17

  v1 = *(_QWORD *)&this->m_SavedButtonPositions[0].left;
  v2 = *(_QWORD *)&this->m_SavedButtonPositions[0].right;
  v3 = *(_QWORD *)&this->m_SavedButtonPositions[2].left;
  v4 = *(_QWORD *)&this->m_SavedButtonPositions[2].right;
  v5 = *(_QWORD *)&this->m_SavedButtonPositions[3].left;
  v6 = *(_QWORD *)&this->m_SavedButtonPositions[3].right;
  v7 = *(_QWORD *)&this->m_SavedButtonPositions[4].left;
  v8 = *(_QWORD *)&this->m_SavedButtonPositions[4].right;
  v9 = *(_QWORD *)&this->m_SavedButtonPositions[5].left;
  v10 = *(_QWORD *)&this->m_SavedButtonPositions[5].right;
  v11 = *(_QWORD *)&this->m_SavedButtonPositions[1].right;
  *(_QWORD *)&this->m_AdjustableButtons[1].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[1].left;
  *(_QWORD *)&this->m_AdjustableButtons[1].m_RectScreen.right = v11;
  *(_QWORD *)&this->m_AdjustableButtons[0].m_RectScreen.left = v1;
  *(_QWORD *)&this->m_AdjustableButtons[0].m_RectScreen.right = v2;
  *(_QWORD *)&this->m_AdjustableButtons[2].m_RectScreen.left = v3;
  *(_QWORD *)&this->m_AdjustableButtons[2].m_RectScreen.right = v4;
  *(_QWORD *)&this->m_AdjustableButtons[3].m_RectScreen.left = v5;
  *(_QWORD *)&this->m_AdjustableButtons[3].m_RectScreen.right = v6;
  *(_QWORD *)&this->m_AdjustableButtons[4].m_RectScreen.left = v7;
  *(_QWORD *)&this->m_AdjustableButtons[4].m_RectScreen.right = v8;
  *(_QWORD *)&this->m_AdjustableButtons[5].m_RectScreen.left = v9;
  *(_QWORD *)&this->m_AdjustableButtons[5].m_RectScreen.right = v10;
  v12 = *(_QWORD *)&this->m_SavedButtonPositions[6].right;
  *(_QWORD *)&this->m_AdjustableButtons[6].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[6].left;
  *(_QWORD *)&this->m_AdjustableButtons[6].m_RectScreen.right = v12;
  v13 = *(_QWORD *)&this->m_SavedButtonPositions[7].right;
  *(_QWORD *)&this->m_AdjustableButtons[7].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[7].left;
  *(_QWORD *)&this->m_AdjustableButtons[7].m_RectScreen.right = v13;
  v14 = *(_QWORD *)&this->m_SavedButtonPositions[8].right;
  *(_QWORD *)&this->m_AdjustableButtons[8].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[8].left;
  *(_QWORD *)&this->m_AdjustableButtons[8].m_RectScreen.right = v14;
  v15 = *(_QWORD *)&this->m_SavedButtonPositions[9].right;
  *(_QWORD *)&this->m_AdjustableButtons[9].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[9].left;
  *(_QWORD *)&this->m_AdjustableButtons[9].m_RectScreen.right = v15;
  v16 = *(_QWORD *)&this->m_SavedButtonPositions[10].right;
  *(_QWORD *)&this->m_AdjustableButtons[10].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[10].left;
  *(_QWORD *)&this->m_AdjustableButtons[10].m_RectScreen.right = v16;
  v17 = *(_QWORD *)&this->m_SavedButtonPositions[11].right;
  *(_QWORD *)&this->m_AdjustableButtons[11].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[11].left;
  *(_QWORD *)&this->m_AdjustableButtons[11].m_RectScreen.right = v17;
  v18 = *(_QWORD *)&this->m_SavedButtonPositions[12].right;
  *(_QWORD *)&this->m_AdjustableButtons[12].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[12].left;
  *(_QWORD *)&this->m_AdjustableButtons[12].m_RectScreen.right = v18;
  v19 = *(_QWORD *)&this->m_SavedButtonPositions[13].right;
  *(_QWORD *)&this->m_AdjustableButtons[13].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[13].left;
  *(_QWORD *)&this->m_AdjustableButtons[13].m_RectScreen.right = v19;
  v20 = *(_QWORD *)&this->m_SavedButtonPositions[14].right;
  *(_QWORD *)&this->m_AdjustableButtons[14].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[14].left;
  *(_QWORD *)&this->m_AdjustableButtons[14].m_RectScreen.right = v20;
  v21 = *(_QWORD *)&this->m_SavedButtonPositions[15].right;
  *(_QWORD *)&this->m_AdjustableButtons[15].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[15].left;
  *(_QWORD *)&this->m_AdjustableButtons[15].m_RectScreen.right = v21;
  v22 = *(_QWORD *)&this->m_SavedButtonPositions[16].right;
  *(_QWORD *)&this->m_AdjustableButtons[16].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[16].left;
  *(_QWORD *)&this->m_AdjustableButtons[16].m_RectScreen.right = v22;
  v23 = *(_QWORD *)&this->m_SavedButtonPositions[17].right;
  *(_QWORD *)&this->m_AdjustableButtons[17].m_RectScreen.left = *(_QWORD *)&this->m_SavedButtonPositions[17].left;
  *(_QWORD *)&this->m_AdjustableButtons[17].m_RectScreen.right = v23;
  v24 = &this->m_SavedButtonPositions[18];
  p_m_RectScreen = &this->m_AdjustableButtons[18].m_RectScreen;
  v26 = *(_QWORD *)&v24->right;
  *(_QWORD *)&p_m_RectScreen->left = *(_QWORD *)&v24->left;
  *(_QWORD *)&p_m_RectScreen->right = v26;
}

//----- (00285E48) --------------------------------------------------------
void __fastcall CAdjustableHUD::RestoreDefaults(CAdjustableHUD *this)
{
  u_native v2; // r0
  int v3; // r8
  CTouchInterface::WidgetPositionIDs *v4; // r5
  float *v5; // r9
  float v6; // s30
  float screenWidth; // s17
  float Width; // s21
  float Height; // s23
  float screenHeight; // s25
  float v11; // s19
  float v12; // s27
  float v13; // s29
  float v14; // s2
  float v15; // s4
  float v16; // s0
  RwInt32 v17; // r6
  float v18; // s23
  float v19; // s21
  float v20; // s17
  float v21; // s27
  float v22; // s25
  float v23; // s29
  float v24; // s0
  float v25; // s2
  float v26; // s25
  float v27; // s23
  float v28; // s29
  float v29; // s19
  float v30; // s21
  float v31; // s27
  float v32; // s31
  float v33; // s28
  float v34; // s24
  float v35; // s30
  float v36; // s26
  float v37; // s16
  float v38; // s2
  float v39; // s0
  bool v40; // cc
  float v41; // s0
  float v42; // s2
  RwInt32 v43; // r6
  float v44; // s27
  float v45; // s0
  float v46; // s25
  float v47; // s17
  float v48; // s21
  float v49; // s19
  float v50; // s16
  float v51; // s24
  float v52; // s26
  float v53; // s0
  float v54; // s2
  float fScaleY; // [sp+18h] [bp-70h] BYREF
  float fScaleX; // [sp+1Ch] [bp-6Ch] BYREF
  float fOriginY; // [sp+20h] [bp-68h] BYREF
  float fOriginX[25]; // [sp+24h] [bp-64h] BYREF

  CFileMgr::SetDirMyDocuments();
  v2 = CFileMgr::OpenFileForWriting("Adjustable.cfg");
  CFileMgr::CloseFile(v2);
  CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
  CTouchInterface::LoadDefaultConfigFile();
  CTouchInterface::LoadFromFile("Adjustable.cfg", 0);
  v3 = 0;
  v4 = PositionIDs;
  do
  {
    v5 = (float *)((char *)&this->m_nAdjustmentMode + v3 * 40);
    if ( (this->m_nAdjustmentMode & this->m_AdjustableButtons[v3].m_nAdjustmentModeFlags) != 0 )
    {
      fOriginY = 0.0;
      fOriginX[0] = 0.0;
      fScaleY = 0.0;
      fScaleX = 0.0;
      CTouchInterface::GetWidgetPosition(*v4, fOriginX, &fOriginY, &fScaleX, &fScaleY);
      v6 = fOriginX[0];
      screenWidth = (float)RsGlobal.screenWidth;
      Width = (float)(unsigned int)OS_ScreenGetWidth();
      Height = (float)(unsigned int)OS_ScreenGetHeight();
      screenHeight = (float)RsGlobal.screenHeight;
      v11 = fScaleX;
      v12 = (float)RsGlobal.screenWidth;
      v13 = (float)(unsigned int)OS_ScreenGetWidth();
      v14 = 0.0;
      v15 = 0.0;
      v16 = v13 / (float)(unsigned int)OS_ScreenGetHeight();
      if ( (float)(Width / Height) > 1.9 )
        v14 = 30.0;
      if ( v16 > 1.9 )
        v15 = 30.0;
      v17 = RsGlobal.screenHeight;
      v18 = (float)(v12 - v15) / 640.0;
      if ( (float)(v12 / screenHeight) > 1.8 )
        v18 = (float)(v18 + (float)((float)RsGlobal.screenHeight / 448.0)) * 0.5;
      v19 = (float)(screenWidth - v14) / 640.0;
      v20 = fScaleY;
      v21 = fOriginY;
      v22 = (float)RsGlobal.screenWidth;
      v23 = (float)(unsigned int)OS_ScreenGetWidth();
      v24 = 0.0;
      if ( (float)(v23 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
        v24 = 30.0;
      v25 = v22 / (float)v17;
      v26 = (float)(v22 - v24) / 640.0;
      if ( v25 > 1.8 )
        v26 = (float)(v26 + (float)((float)RsGlobal.screenHeight / 448.0)) * 0.5;
      v27 = v11 * v18;
      v28 = fOriginX[0];
      v29 = v21 * (float)((float)v17 / 448.0);
      v30 = v6 * v19;
      v31 = (float)RsGlobal.screenWidth;
      v32 = (float)(unsigned int)OS_ScreenGetWidth();
      v33 = (float)(unsigned int)OS_ScreenGetHeight();
      v34 = (float)RsGlobal.screenHeight;
      v35 = fScaleX;
      v36 = (float)RsGlobal.screenWidth;
      v37 = (float)(unsigned int)OS_ScreenGetWidth();
      v38 = 0.0;
      v39 = v37 / (float)(unsigned int)OS_ScreenGetHeight();
      if ( (float)(v32 / v33) > 1.9 )
        v38 = 30.0;
      v40 = v39 <= 1.9;
      v41 = 0.0;
      v42 = (float)(v31 - v38) / 640.0;
      if ( !v40 )
        v41 = 30.0;
      v43 = RsGlobal.screenHeight;
      v44 = (float)(v36 - v41) / 640.0;
      v45 = v20 * v26;
      v46 = v28 * v42;
      if ( (float)(v36 / v34) > 1.8 )
        v44 = (float)(v44 + (float)((float)RsGlobal.screenHeight / 448.0)) * 0.5;
      v47 = v29 - v45;
      v48 = v30 - v27;
      v49 = fScaleY;
      v50 = fOriginY;
      v51 = (float)RsGlobal.screenWidth;
      v52 = (float)(unsigned int)OS_ScreenGetWidth();
      v53 = 0.0;
      if ( (float)(v52 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
        v53 = 30.0;
      v54 = (float)(v51 - v53) / 640.0;
      if ( (float)(v51 / (float)v43) > 1.8 )
        v54 = (float)(v54 + (float)((float)RsGlobal.screenHeight / 448.0)) * 0.5;
      v5[28] = v48;
      v5[29] = (float)(v50 * (float)((float)v43 / 448.0)) + (float)(v49 * v54);
      v5[30] = v46 + (float)(v35 * v44);
      v5[31] = v47;
    }
    ++v3;
    ++v4;
  }
  while ( v3 != 19 );
}
// 61CADE: using guessed type char byte_61CADE;
// 285E48: using guessed type float fOriginX[25];

//----- (0028620C) --------------------------------------------------------
void __fastcall CAdjustableHUD::Draw(CAdjustableHUD *this)
{
  RwInt32 screenWidth; // r8
  int Width; // r4
  void *Height; // r9
  float v5; // s22
  int v6; // r10
  void *v7; // r5
  unsigned int v8; // s16
  float v9; // s24
  int v10; // r4
  void *v11; // r0
  float screenHeight; // s26
  float v13; // s17
  float v14; // s19
  float v15; // s21
  void *v16; // r0
  float v17; // s2
  float v18; // s16
  bool v19; // cc
  float v20; // s6
  float v21; // s2
  float v22; // s4
  bool v23; // fzf
  bool v24; // fnf
  float v25; // s6
  float v26; // s0
  bool v27; // fzf
  bool v28; // fnf
  float v29; // s0
  float v30; // s4
  float v31; // s2
  float v32; // s6
  float v33; // s4
  float v34; // s10
  float v35; // s26
  float v36; // s30
  float v37; // s4
  float v38; // s6
  RwInt32 v39; // r4
  int v40; // s25
  float v41; // s27
  float v42; // s29
  float v43; // s31
  float v44; // s28
  float v45; // s2
  float v46; // s0
  float v47; // s0
  float v48; // s2
  float v49; // s6
  RwInt32 v50; // r4
  int v51; // s28
  float v52; // s19
  float v53; // s21
  float v54; // s23
  float v55; // s25
  float v56; // s2
  float v57; // s0
  float v58; // s0
  float v59; // s2
  float v60; // s6
  CRect *p_m_RectOnFoot; // r4
  const CRGBA *v62; // r0
  float v63; // s26
  GxtChar *v64; // r0
  CAdjustableHUD *v65; // r10
  float StringWidth; // r0
  float v67; // s0
  GxtChar *v68; // r0
  float v69; // r0
  float v70; // s0
  GxtChar *v71; // r0
  float v72; // r0
  float v73; // s0
  CRGBA v74; // r0
  CRGBA v75; // r0
  float left; // s28
  float right; // s30
  float v78; // s17
  float v79; // s0
  GxtChar *v80; // r0
  float v81; // s28
  float v82; // s30
  float v83; // s17
  float v84; // s0
  GxtChar *v85; // r0
  float v86; // s28
  float v87; // s30
  float v88; // s17
  float v89; // s0
  GxtChar *v90; // r0
  float v91; // s2
  float v92; // s0
  float v93; // s4
  float v94; // s28
  GxtChar *v95; // r0
  float v96; // r0
  float v97; // s0
  GxtChar *v98; // r0
  float v99; // r0
  float v100; // s0
  float v101; // s28
  float v102; // s30
  float v103; // s17
  float v104; // s0
  GxtChar *v105; // r0
  float v106; // s28
  float v107; // s30
  float v108; // s17
  float v109; // s0
  GxtChar *v110; // r0
  char v111; // r0
  char v112; // r0
  float32x4_t v113; // q7
  int v114; // r6
  int v115; // r11
  char *v116; // r5
  bool v117; // zf
  const CRect *v118; // r9
  CAdjustableHUD *v119; // r9
  bool *p_m_bShownAsRed; // r10
  CRGBA *v121; // r0
  CSprite2d *v122; // r5
  CRGBA *v123; // r0
  RwInt32 v124; // r8
  int v125; // r4
  void *v126; // r9
  int v127; // r10
  void *v128; // r5
  unsigned int v129; // s19
  float v130; // s30
  int v131; // r4
  void *v132; // r0
  float v133; // s23
  float v134; // s31
  float v135; // s24
  float v136; // s20
  float v137; // s6
  float v138; // s2
  float v139; // s0
  float v140; // s8
  float v141; // s4
  bool v142; // fzf
  bool v143; // fnf
  float v144; // s6
  float v145; // s0
  bool v146; // fzf
  bool v147; // fnf
  float v148; // s0
  float v149; // s8
  float v150; // s0
  float v151; // s0
  const CRGBA *v152; // r0
  CRGBA v153; // r0
  CRGBA v154; // r0
  float v155; // s16
  GxtChar *v156; // r0
  float v157; // r0
  float v158; // s0
  float v159; // s16
  float v160; // s18
  float v161; // s18
  GxtChar *v162; // r0
  float v163; // [sp+Ch] [bp-9Ch]
  CAdjustableHUD *v164; // [sp+10h] [bp-98h]
  float Rectangle; // [sp+14h] [bp-94h]
  CRGBA v166; // [sp+18h] [bp-90h] BYREF
  CRGBA v167; // [sp+1Ch] [bp-8Ch] BYREF
  float32x4_t v168; // [sp+20h] [bp-88h] BYREF
  CRGBA v169; // [sp+34h] [bp-74h] BYREF
  CRGBA v170; // [sp+38h] [bp-70h] BYREF
  CRGBA v171; // [sp+3Ch] [bp-6Ch] BYREF
  CRGBA v172; // [sp+40h] [bp-68h] BYREF
  CRGBA rgba; // [sp+44h] [bp-64h] BYREF

  screenWidth = RsGlobal.screenWidth;
  Width = OS_ScreenGetWidth();
  Height = OS_ScreenGetHeight();
  v5 = (float)RsGlobal.screenWidth;
  v6 = OS_ScreenGetWidth();
  v7 = OS_ScreenGetHeight();
  v8 = Width;
  v9 = (float)RsGlobal.screenWidth;
  v10 = OS_ScreenGetWidth();
  v11 = OS_ScreenGetHeight();
  screenHeight = (float)RsGlobal.screenHeight;
  v13 = (float)RsGlobal.screenWidth;
  v14 = (float)(unsigned int)v11;
  v15 = (float)(unsigned int)OS_ScreenGetWidth();
  v16 = OS_ScreenGetHeight();
  v17 = (float)v8 / (float)(unsigned int)Height;
  v18 = 0.0;
  v19 = v17 <= 1.9;
  v20 = (float)(unsigned int)v10 / v14;
  v21 = 0.0;
  if ( !v19 )
    v21 = 30.0;
  v22 = 0.0;
  v23 = v20 == 1.9;
  v24 = v20 < 1.9;
  v25 = 0.0;
  v26 = v15 / (float)(unsigned int)v16;
  if ( (float)((float)(unsigned int)v6 / (float)(unsigned int)v7) > 1.9 )
    v22 = 30.0;
  v19 = v24 || v23;
  v27 = v26 == 1.9;
  v28 = v26 < 1.9;
  v29 = 0.0;
  v30 = v5 - v22;
  v31 = (float)((float)screenWidth - v21) / 640.0;
  if ( !v19 )
    v25 = 30.0;
  v32 = v9 - v25;
  v33 = v30 / 640.0;
  if ( !v28 && !v27 )
    v29 = 30.0;
  v34 = screenHeight / 448.0;
  v35 = v31 * 70.0;
  v36 = v33 * 18.0;
  v37 = (float)(v32 / 640.0) * 320.0;
  v38 = v36 + (float)((float)((float)RsGlobal.screenHeight / 448.0) * 70.0);
  this->m_RectOnFoot.left = v37 - (float)((float)(v31 * 70.0) * 3.1);
  this->m_RectOnFoot.top = v38;
  this->m_RectOnFoot.right = (float)((float)((float)(v13 - v29) / 640.0) * 320.0) - (float)((float)(v31 * 70.0) * 0.1);
  this->m_RectOnFoot.bottom = (float)(v34 * 70.0) - v36;
  v39 = RsGlobal.screenWidth;
  v40 = OS_ScreenGetWidth();
  v41 = (float)(unsigned int)OS_ScreenGetHeight();
  v42 = (float)RsGlobal.screenHeight;
  v43 = (float)RsGlobal.screenWidth;
  v44 = (float)(unsigned int)OS_ScreenGetWidth();
  v45 = 0.0;
  v46 = v44 / (float)(unsigned int)OS_ScreenGetHeight();
  if ( (float)((float)(unsigned int)v40 / v41) > 1.9 )
    v45 = 30.0;
  v19 = v46 <= 1.9;
  v47 = 0.0;
  v48 = (float)v39 - v45;
  if ( !v19 )
    v47 = 30.0;
  v49 = v36 + (float)((float)((float)RsGlobal.screenHeight / 448.0) * 70.0);
  this->m_RectInCar.left = (float)(v35 * 0.1) + (float)((float)(v48 / 640.0) * 320.0);
  this->m_RectInCar.top = v49;
  this->m_RectInCar.right = (float)(v35 * 3.1) + (float)((float)((float)(v43 - v47) / 640.0) * 320.0);
  this->m_RectInCar.bottom = (float)((float)(v42 / 448.0) * 70.0) - v36;
  v50 = RsGlobal.screenWidth;
  v51 = OS_ScreenGetWidth();
  v52 = (float)(unsigned int)OS_ScreenGetHeight();
  v53 = (float)RsGlobal.screenHeight;
  v54 = (float)RsGlobal.screenWidth;
  v55 = (float)(unsigned int)OS_ScreenGetWidth();
  v56 = 0.0;
  v57 = v55 / (float)(unsigned int)OS_ScreenGetHeight();
  if ( (float)((float)(unsigned int)v51 / v52) > 1.9 )
    v56 = 30.0;
  v19 = v57 <= 1.9;
  v58 = 0.0;
  v59 = (float)v50 - v56;
  if ( !v19 )
    v58 = 30.0;
  v117 = this->m_nAdjustmentMode == 1;
  v60 = v36 + (float)((float)((float)RsGlobal.screenHeight / 448.0) * 30.0);
  this->m_RectRestoreDefaults.left = (float)((float)(v59 / 640.0) * 320.0) - (float)(v35 * 1.5);
  this->m_RectRestoreDefaults.top = v60;
  this->m_RectRestoreDefaults.right = (float)(v35 * 1.5) + (float)((float)((float)(v54 - v58) / 640.0) * 320.0);
  this->m_RectRestoreDefaults.bottom = (float)((float)(v53 / 448.0) * 30.0) - v36;
  if ( v117 )
    p_m_RectOnFoot = &this->m_RectOnFoot;
  else
    p_m_RectOnFoot = &this->m_RectInCar;
  CRGBA::CRGBA((CRGBA *)&v168, 0xF0u, 0xF0u, 0xF0u, 0x66u);
  CRGBA::CRGBA(&rgba, 0x99u, 0xCCu, 0x99u, 0x66u);
  CRGBA::CRGBA(&v172, 0x99u, 0xCCu, 0x99u, 0x32u);
  CRGBA::CRGBA(&v171, 0x99u, 0xCCu, 0x99u, 0x32u);
  CSprite2d::DrawRect(p_m_RectOnFoot, (const CRGBA *)&v168, &rgba, &v172, v62);
  CWidget::DrawTitleSafeArea();
  CFont::SetBackground(0, 0);
  CFont::SetOrientation(0);
  CFont::SetCentreSize(fabsf(this->m_RectOnFoot.right - this->m_RectOnFoot.left) * 0.875);
  CFont::SetProportional(1u);
  CFont::SetEdge(1);
  CFont::SetFontStyle(2u);
  v63 = fabsf(this->m_RectOnFoot.top - this->m_RectOnFoot.bottom) * 0.03;
  CFont::SetScale(v63);
  v64 = CText::Get(&TheText, "HUD_FOT");
  v65 = this;
  if ( v64 )
  {
    StringWidth = CFont::GetStringWidth(v64, 1u, 0);
    v67 = fabsf(this->m_RectOnFoot.right - this->m_RectOnFoot.left) * 0.875;
    if ( StringWidth > v67 )
    {
      v63 = v63 * (float)(v67 / StringWidth);
      CFont::SetScale(v63);
    }
  }
  v68 = CText::Get(&TheText, "HUD_VEH");
  if ( v68 )
  {
    v69 = CFont::GetStringWidth(v68, 1u, 0);
    v70 = fabsf(this->m_RectInCar.right - this->m_RectInCar.left) * 0.875;
    if ( v69 > v70 )
    {
      v63 = v63 * (float)(v70 / v69);
      CFont::SetScale(v63);
    }
  }
  v71 = CText::Get(&TheText, "HUD_DEF");
  if ( v71 )
  {
    v72 = CFont::GetStringWidth(v71, 1u, 0);
    v73 = fabsf(this->m_RectRestoreDefaults.right - this->m_RectRestoreDefaults.left) * 0.875;
    if ( v72 > v73 )
      CFont::SetScale(v63 * (float)(v73 / v72));
  }
  CRGBA::CRGBA(&v170, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
  CFont::SetColor(v74);
  CRGBA::CRGBA(&v169, 0, 0, 0, 0xFFu);
  CFont::SetDropColor(v75);
  left = this->m_RectOnFoot.left;
  right = this->m_RectOnFoot.right;
  v78 = this->m_RectOnFoot.top + this->m_RectOnFoot.bottom;
  v79 = CFont::GetHeight(0) * 0.5;
  v80 = CText::Get(&TheText, "HUD_FOT");
  CFont::PrintString((float)(left + right) * 0.5, (float)(v78 * 0.5) - v79, v80);
  CFont::RenderFontBuffer();
  v81 = this->m_RectInCar.left;
  v82 = this->m_RectInCar.right;
  v83 = this->m_RectInCar.top + this->m_RectInCar.bottom;
  v84 = CFont::GetHeight(0) * 0.5;
  v85 = CText::Get(&TheText, "HUD_VEH");
  CFont::PrintString((float)(v81 + v82) * 0.5, (float)(v83 * 0.5) - v84, v85);
  CFont::RenderFontBuffer();
  v86 = this->m_RectRestoreDefaults.left;
  v87 = this->m_RectRestoreDefaults.right;
  v88 = this->m_RectRestoreDefaults.top + this->m_RectRestoreDefaults.bottom;
  v89 = CFont::GetHeight(0) * 0.5;
  v90 = CText::Get(&TheText, "HUD_DEF");
  CFont::PrintString((float)(v86 + v87) * 0.5, (float)(v88 * 0.5) - v89, v90);
  CFont::RenderFontBuffer();
  v91 = (float)RsGlobal.screenHeight;
  v92 = (float)RsGlobal.screenWidth;
  this->m_RectCancel.left = 0.0;
  this->m_RectCancel.top = v91;
  v93 = v91 + (float)(v91 * -0.067);
  this->m_RectCancel.right = v92 * 0.1;
  this->m_RectCancel.bottom = v93;
  this->m_RectSave.left = v92 - (float)(v92 * 0.1);
  this->m_RectSave.top = v91;
  this->m_RectSave.right = v92;
  this->m_RectSave.bottom = v93;
  CFont::SetFontStyle(0);
  v94 = fabsf(this->m_RectSave.top - this->m_RectSave.bottom) * 0.0375;
  CFont::SetScale(v94);
  v95 = CText::Get(&TheText, "HUD_SAV");
  if ( v95 )
  {
    v96 = CFont::GetStringWidth(v95, 1u, 0);
    v97 = fabsf(this->m_RectSave.right - this->m_RectSave.left) * 0.875;
    if ( v96 > v97 )
    {
      v94 = v94 * (float)(v97 / v96);
      CFont::SetScale(v94);
    }
  }
  v98 = CText::Get(&TheText, "HUD_CAN");
  if ( v98 )
  {
    v99 = CFont::GetStringWidth(v98, 1u, 0);
    v100 = fabsf(this->m_RectCancel.right - this->m_RectCancel.left) * 0.875;
    if ( v99 > v100 )
      CFont::SetScale(v94 * (float)(v100 / v99));
  }
  v101 = this->m_RectSave.left;
  v102 = this->m_RectSave.right;
  v103 = this->m_RectSave.top + this->m_RectSave.bottom;
  v104 = CFont::GetHeight(0) * 0.5;
  v105 = CText::Get(&TheText, "HUD_SAV");
  CFont::PrintString((float)(v101 + v102) * 0.5, (float)(v103 * 0.5) - v104, v105);
  CFont::RenderFontBuffer();
  v106 = this->m_RectCancel.left;
  v107 = this->m_RectCancel.right;
  v108 = this->m_RectCancel.top + this->m_RectCancel.bottom;
  v109 = CFont::GetHeight(0) * 0.5;
  v110 = CText::Get(&TheText, "HUD_CAN");
  CFont::PrintString((float)(v106 + v107) * 0.5, (float)(v108 * 0.5) - v109, v110);
  CFont::RenderFontBuffer();
  v111 = `guard variable for'CAdjustableHUD::Draw(void)::offColor;
  __dmb(0xBu);
  if ( (v111 & 1) == 0 && _cxa_guard_acquire((__guard *)&`guard variable for'CAdjustableHUD::Draw(void)::offColor) )
  {
    CRGBA::CRGBA(&CAdjustableHUD::Draw(void)::offColor, 0xFFu, 0x50u, 0x50u, 0xFFu);
    _cxa_guard_release((__guard *)&`guard variable for'CAdjustableHUD::Draw(void)::offColor);
  }
  v112 = `guard variable for'CAdjustableHUD::Draw(void)::highlightColor;
  __dmb(0xBu);
  if ( (v112 & 1) == 0 && _cxa_guard_acquire((__guard *)&`guard variable for'CAdjustableHUD::Draw(void)::highlightColor) )
  {
    CRGBA::CRGBA(&CAdjustableHUD::Draw(void)::highlightColor, 0xF0u, 0xF0u, 0xF0u, 0xFFu);
    _cxa_guard_release((__guard *)&`guard variable for'CAdjustableHUD::Draw(void)::highlightColor);
  }
  v113.n128_u64[0] = 0x4000000040000000LL;
  v113.n128_u64[1] = 0x4000000040000000LL;
  v114 = 0;
  v115 = 0;
  v164 = v65;
  do
  {
    v116 = (char *)v65 + v114 * 40;
    v117 = !v65->m_AdjustableButtons[v114].m_bEnabled;
    if ( v65->m_AdjustableButtons[v114].m_bEnabled )
      v117 = (*((_DWORD *)v116 + 34) & v65->m_nAdjustmentMode) == 0;
    if ( !v117 )
    {
      v118 = (const CRect *)(v116 + 112);
      v168 = vaddq_f32(*((float32x4_t *)v116 + 7), v113);
      if ( !*((_DWORD *)v116 + 32) )
      {
        p_m_bShownAsRed = (bool *)(v116 + 140);
        goto LABEL_55;
      }
      v119 = v65;
      CRGBA::CRGBA(&rgba, 0, 0, 0, 0xFFu);
      CSprite2d::Draw((CSprite2d *)v116 + 32, (const CRect *)&v168, &rgba);
      p_m_bShownAsRed = &v65->m_AdjustableButtons[v115].m_bShownAsRed;
      if ( v116[140] )
      {
        v121 = &CAdjustableHUD::Draw(void)::offColor;
      }
      else
      {
        if ( v115 != v119->m_nSelectedButton )
        {
          CRGBA::CRGBA(&rgba, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
LABEL_54:
          v118 = (const CRect *)(v116 + 112);
          CSprite2d::Draw((CSprite2d *)v116 + 32, (const CRect *)v116 + 7, &rgba);
LABEL_55:
          CRGBA::CRGBA(&rgba, 0, 0, 0, 0xFFu);
          v122 = (CSprite2d *)(v116 + 132);
          CSprite2d::Draw(v122, (const CRect *)&v168, &rgba);
          if ( *p_m_bShownAsRed )
          {
            v65 = v164;
            v123 = &CAdjustableHUD::Draw(void)::offColor;
          }
          else
          {
            v65 = v164;
            if ( v115 != v164->m_nSelectedButton )
            {
              CRGBA::CRGBA(&rgba, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
LABEL_60:
              CSprite2d::Draw(v122, v118, &rgba);
              goto LABEL_61;
            }
            v123 = &CAdjustableHUD::Draw(void)::highlightColor;
          }
          rgba = *v123;
          goto LABEL_60;
        }
        v121 = &CAdjustableHUD::Draw(void)::highlightColor;
      }
      rgba = *v121;
      goto LABEL_54;
    }
LABEL_61:
    ++v114;
    ++v115;
  }
  while ( v114 != 19 );
  if ( v65->m_bOverlappingDialog )
  {
    v124 = RsGlobal.screenWidth;
    v125 = OS_ScreenGetWidth();
    v126 = OS_ScreenGetHeight();
    Rectangle = (float)RsGlobal.screenHeight;
    v163 = (float)RsGlobal.screenWidth;
    v127 = OS_ScreenGetWidth();
    v128 = OS_ScreenGetHeight();
    v129 = v125;
    v130 = (float)RsGlobal.screenWidth;
    v131 = OS_ScreenGetWidth();
    v132 = OS_ScreenGetHeight();
    v133 = (float)RsGlobal.screenHeight;
    v134 = (float)RsGlobal.screenWidth;
    v135 = (float)(unsigned int)v132;
    v136 = (float)(unsigned int)OS_ScreenGetWidth();
    v137 = (float)(unsigned int)v131 / v135;
    v138 = 0.0;
    v139 = (float)(unsigned int)OS_ScreenGetHeight();
    v140 = (float)v124;
    if ( (float)((float)v129 / (float)(unsigned int)v126) > 1.9 )
      v138 = 30.0;
    v141 = 0.0;
    v142 = v137 == 1.9;
    v143 = v137 < 1.9;
    v144 = 0.0;
    v145 = v136 / v139;
    if ( (float)((float)(unsigned int)v127 / (float)(unsigned int)v128) > 1.9 )
      v141 = 30.0;
    v19 = v143 || v142;
    v146 = v145 == 1.9;
    v147 = v145 < 1.9;
    v148 = v140 - v138;
    v149 = v140 * 0.5;
    v150 = v148 / 640.0;
    if ( !v19 )
      v144 = 30.0;
    v151 = v149 - (float)(v150 * 120.0);
    if ( !v147 && !v146 )
      v18 = 30.0;
    v164->m_RectOverlapDialog.left = v151;
    v164->m_RectOverlapDialog.top = (float)(v133 * 0.5) + (float)((float)((float)(v134 - v18) / 640.0) * 80.0);
    v164->m_RectOverlapDialog.right = (float)(v130 * 0.5) + (float)((float)((float)(v130 - v144) / 640.0) * 120.0);
    v164->m_RectOverlapDialog.bottom = (float)(Rectangle * 0.5) - (float)((float)((float)(v163 - v141) / 640.0) * 80.0);
    CRGBA::CRGBA((CRGBA *)&v168, 0, 0, 0, 0x40u);
    CRGBA::CRGBA(&rgba, 0, 0, 0, 0x40u);
    CRGBA::CRGBA(&v172, 0, 0, 0, 0xC0u);
    CRGBA::CRGBA(&v171, 0, 0, 0, 0xC0u);
    CSprite2d::DrawRect(&v164->m_RectOverlapDialog, (const CRGBA *)&v168, &rgba, &v172, v152);
    CFont::SetFontStyle(2u);
    CFont::SetCentreSize(fabsf(v164->m_RectOverlapDialog.right - v164->m_RectOverlapDialog.left) * 0.875);
    CRGBA::CRGBA(&v167, 0xF0u, 0xF0u, 0xF0u, 0xFFu);
    CFont::SetColor(v153);
    CRGBA::CRGBA(&v166, 0, 0, 0, 0xFFu);
    CFont::SetDropColor(v154);
    v155 = fabsf(v164->m_RectOverlapDialog.top - v164->m_RectOverlapDialog.bottom) * 0.00625;
    CFont::SetScale(v155);
    v156 = CText::Get(&TheText, "HUD_FOT");
    if ( v156 )
    {
      v157 = CFont::GetStringWidth(v156, 1u, 0);
      v158 = fabsf(v164->m_RectOverlapDialog.right - v164->m_RectOverlapDialog.left) * 0.875;
      if ( v157 > v158 )
        CFont::SetScale(v155 * (float)(v158 / v157));
    }
    v159 = (float)RsGlobal.screenWidth;
    v160 = (float)RsGlobal.screenHeight;
    v161 = (float)(v160 * 0.5) + (float)(CFont::GetHeight(0) * -2.5);
    v162 = CText::Get(&TheText, "HUD_OVR");
    CFont::PrintString(v159 * 0.5, v161, v162);
    CFont::RenderFontBuffer();
  }
}
// 2865AE: variable 'v62' is possibly undefined
// 28673E: variable 'v74' is possibly undefined
// 286752: variable 'v75' is possibly undefined
// 286D86: variable 'v152' is possibly undefined
// 286DBC: variable 'v153' is possibly undefined
// 286DCE: variable 'v154' is possibly undefined
// 6DFE60: using guessed type char `guard variable for'CAdjustableHUD::Draw(void)::offColor;
// 6DFE68: using guessed type char `guard variable for'CAdjustableHUD::Draw(void)::highlightColor;
// 28620C: using guessed type float32x4_t var_88;

//----- (00286F3C) --------------------------------------------------------
float CAdjustableHUD::GetTopAreaHeight()
{
  float fScaleY; // [sp+8h] [bp-18h] BYREF
  float fScaleX; // [sp+Ch] [bp-14h] BYREF
  float fOriginY; // [sp+10h] [bp-10h] BYREF
  float fOriginX; // [sp+14h] [bp-Ch] BYREF

  fOriginY = 0.0;
  fOriginX = 0.0;
  fScaleY = 0.0;
  fScaleX = 0.0;
  CTouchInterface::GetWidgetPosition(WIDGET_POSITION_PLAYER_INFO, &fOriginX, &fOriginY, &fScaleX, &fScaleY);
  OS_ScreenGetWidth();
  OS_ScreenGetHeight();
  OS_ScreenGetWidth();
  OS_ScreenGetHeight();
  return fScaleX + (float)(fOriginY * (float)((float)RsGlobal.screenHeight / 448.0));
}

//----- (00286FA4) --------------------------------------------------------
bool IsSCCloudAvailable()
{
  unsigned int v0; // r4

  v0 = NextCheckTime + 5000;
  if ( v0 < OS_TimeMS() )
  {
    TempSignIn = IsSCSignedIn();
    NextCheckTime = OS_TimeMS();
  }
  return TempSignIn;
}

//----- (00286FF0) --------------------------------------------------------
bool IsSCCloudFree()
{
  return cloudGetBufferPtr() == 0;
}
// 19D16C: using guessed type int cloudGetBufferPtr(void);

//----- (00287004) --------------------------------------------------------
void __fastcall SaveSCCloudGameToDisk(int SlotNum, void *pSaveData, int nBytes)
{
  OSFile file; // [sp+0h] [bp-98h] BYREF
  unsigned __int8 pString[128]; // [sp+4h] [bp-94h] BYREF

  if ( nBytes >= 1 )
  {
    C_PcSave::GenerateGameFilename(&PcSaveHelper, SlotNum + 6, pString);
    if ( OS_FileOpen(OSFDA_User_0, &file, pString, OSFAT_Write_0) == OSFE_NoError )
    {
      OS_FileWrite(file, pSaveData, nBytes);
      OS_FileClose(file);
    }
  }
}

//----- (00287074) --------------------------------------------------------
void UpdateCloudSaves()
{
  unsigned int v0; // r4
  struct timeval v1; // [sp+0h] [bp-10h] BYREF

  gettimeofday(&v1, 0);
  if ( 1000 * v1.tv_sec >= UpdateCloudSaves(void)::lastUpdateCheck + 30 )
  {
    v0 = NextCheckTime + 5000;
    if ( v0 < OS_TimeMS() )
    {
      TempSignIn = IsSCSignedIn();
      NextCheckTime = OS_TimeMS();
    }
    if ( TempSignIn && !cloudGetBufferPtr() && CloudSaveState == 9 )
    {
      CloudSaveState = 1;
      gettimeofday(&v1, 0);
      UpdateCloudSaves(void)::lastUpdateCheck = 1000 * v1.tv_sec;
    }
  }
}
// 19D16C: using guessed type int cloudGetBufferPtr(void);

//----- (00287134) --------------------------------------------------------
void WriteCloudInfo()
{
  OSFile intoFile; // [sp+4h] [bp-Ch] BYREF

  if ( OS_FileOpen(OSFDA_User_0, &intoFile, "gtacloudsave.set", OSFAT_Write_0) == OSFE_NoError )
  {
    OS_FileWrite(intoFile, myCloudSaves, 386);
    OS_FileClose(intoFile);
  }
}

//----- (00287170) --------------------------------------------------------
void AddSCCloudWatch()
{
  OSFile intoFile; // [sp+4h] [bp-Ch] BYREF

  if ( !AddSCCloudWatch(void)::firstTime )
  {
    AddSCCloudWatch(void)::firstTime = 1;
    if ( OS_FileOpen(OSFDA_User_0, &intoFile, "gtacloudsave.set", OSFAT_Read_0) == OSFE_NoError )
    {
      OS_FileRead(intoFile, myCloudSaves, 386);
      OS_FileClose(intoFile);
    }
    if ( CGenericGameStorage::ms_Slots[6] )
      memset(myCloudSaves, 0, 0xC1u);
    if ( CGenericGameStorage::ms_Slots[7] )
      memset(&myCloudSaves[1], 0, sizeof(cloudMod));
  }
  if ( !isWatching )
  {
    isWatching = 1;
    cloudModAddWatch(cloudFilename[0]);
    cloudModAddWatch(cloudFilename[1]);
  }
}
// 18B210: using guessed type int __fastcall cloudModAddWatch(_DWORD);
// 6E000B: using guessed type char AddSCCloudWatch(void)::firstTime;

//----- (00287234) --------------------------------------------------------
bool __fastcall NewSCCloudSaveAvailable(int SlotNum)
{
  _BYTE *v2; // r0
  const char *v3; // r0
  int v4; // t1
  int v5; // r2

  v2 = (_BYTE *)cloudModFind(cloudFilename[SlotNum]);
  if ( v2 )
  {
    if ( *v2
      || (v4 = (unsigned __int8)v2[129], v3 = v2 + 129, v4) && strcmp(v3, (const char *)myCloudSaves[SlotNum].Date) )
    {
      if ( CloudSaveState == 9 )
      {
        v5 = 5;
        if ( !SlotNum )
          v5 = 1;
        CloudSaveState = v5;
        cloudModReset(cloudFilename[SlotNum]);
      }
    }
  }
  return 0;
}
// 18CB20: using guessed type int __fastcall cloudModFind(_DWORD);
// 194744: using guessed type int __fastcall cloudModReset(_DWORD);

//----- (002872B4) --------------------------------------------------------
void __fastcall SaveGameToSCCloud(int SlotNum, const unsigned __int8 *saveGameData, int filesize)
{
  j_cloudStartUpload();
}

//----- (002872E0) --------------------------------------------------------
void OS_ApplicationPreinit()
{
  JNIEnv_0 *(*JNIFunc)(); // r0

  if ( OS_ServiceAppCommand("IsAmazonBuild", (const unsigned __int8 *)&byte_61CADE) )
    SetupDataDownload();
  JNIFunc = AND_GetJNIFunc();
  SetJNEEnvFunc((void *(*)(void))JNIFunc);
  hasTouchScreen = OS_GetDeviceInfo(1) != 0;
}
// 61CADE: using guessed type char byte_61CADE;

//----- (0028732C) --------------------------------------------------------
void SCCloudSaveStateUpdate()
{
  unsigned int v0; // r4
  int v1; // r1
  const void *BufferPtr; // r4
  OSFileError BufferLen; // r0
  int v4; // r5
  const void *v5; // r1
  const void *v6; // r4
  OSFileError v7; // r0
  int v8; // r5
  const void *v9; // r1
  OSFile file; // [sp+0h] [bp-98h] BYREF
  OSFile pString[32]; // [sp+4h] [bp-94h] BYREF

  v0 = NextCheckTime + 5000;
  if ( v0 < OS_TimeMS() )
  {
    TempSignIn = IsSCSignedIn();
    NextCheckTime = OS_TimeMS();
  }
  if ( TempSignIn )
  {
    scmainUpdate();
    switch ( CloudSaveState )
    {
      case 0:
        v1 = 1;
        break;
      case 1:
        if ( cloudStartDownload(cloudFilename[0]) != 1 )
          return;
        v1 = 2;
        break;
      case 2:
        if ( cloudIsBusy() )
          return;
        if ( !cloudGetBufferPtr() )
          goto LABEL_39;
        BufferPtr = (const void *)cloudGetBufferPtr();
        BufferLen = cloudGetBufferLen();
        v4 = BufferLen;
        if ( BufferLen >= OSFE_FileNotFound )
        {
          C_PcSave::GenerateGameFilename(&PcSaveHelper, 6, (unsigned __int8 *)pString);
          BufferLen = OS_FileOpen(OSFDA_User_0, &file, (const unsigned __int8 *)pString, OSFAT_Write_0);
          if ( BufferLen == OSFE_NoError )
          {
            OS_FileWrite(file, BufferPtr, v4);
            BufferLen = OS_FileClose(file);
          }
        }
        cloudGetFree(BufferLen);
        cloudStartCheckMod(cloudFilename[0]);
LABEL_16:
        v1 = 4;
        break;
      case 3:
        if ( cloudIsBusy() )
          return;
        cloudStartCheckMod(cloudFilename[0]);
        goto LABEL_16;
      case 4:
        if ( cloudIsBusy() )
          return;
        v5 = (const void *)cloudModFind(cloudFilename[0]);
        if ( v5 )
        {
          qmemcpy(myCloudSaves, v5, 0xC1u);
          if ( OS_FileOpen(OSFDA_User_0, pString, "gtacloudsave.set", OSFAT_Write_0) == OSFE_NoError )
          {
            OS_FileWrite(pString[0], myCloudSaves, 386);
            OS_FileClose(pString[0]);
          }
          C_PcSave::PopulateSlotInfo(&PcSaveHelper);
        }
        v1 = 5;
        break;
      case 5:
        if ( cloudStartDownload(cloudFilename[1]) != 1 )
          return;
        v1 = 6;
        break;
      case 6:
        if ( cloudIsBusy() )
          return;
        if ( !cloudGetBufferPtr() )
          goto LABEL_39;
        v6 = (const void *)cloudGetBufferPtr();
        v7 = cloudGetBufferLen();
        v8 = v7;
        if ( v7 >= OSFE_FileNotFound )
        {
          C_PcSave::GenerateGameFilename(&PcSaveHelper, 7, (unsigned __int8 *)pString);
          v7 = OS_FileOpen(OSFDA_User_0, &file, (const unsigned __int8 *)pString, OSFAT_Write_0);
          if ( v7 == OSFE_NoError )
          {
            OS_FileWrite(file, v6, v8);
            v7 = OS_FileClose(file);
          }
        }
        cloudGetFree(v7);
        cloudStartCheckMod(cloudFilename[1]);
LABEL_33:
        v1 = 8;
        break;
      case 7:
        if ( cloudIsBusy() )
          return;
        cloudStartCheckMod(cloudFilename[1]);
        goto LABEL_33;
      case 8:
        if ( cloudIsBusy() )
          return;
        v9 = (const void *)cloudModFind(cloudFilename[1]);
        if ( v9 )
        {
          qmemcpy(&myCloudSaves[1], v9, sizeof(cloudMod));
          if ( OS_FileOpen(OSFDA_User_0, pString, "gtacloudsave.set", OSFAT_Write_0) == OSFE_NoError )
          {
            OS_FileWrite(pString[0], myCloudSaves, 386);
            OS_FileClose(pString[0]);
          }
          C_PcSave::PopulateSlotInfo(&PcSaveHelper);
        }
LABEL_39:
        v1 = 9;
        break;
      default:
        return;
    }
    CloudSaveState = v1;
  }
}
// 189FAC: using guessed type int __fastcall cloudStartDownload(_DWORD);
// 18CB20: using guessed type int __fastcall cloudModFind(_DWORD);
// 18D130: using guessed type int cloudIsBusy(void);
// 18EDDC: using guessed type int scmainUpdate(void);
// 1921DC: using guessed type int cloudGetBufferLen(void);
// 197C54: using guessed type int __fastcall cloudStartCheckMod(_DWORD);
// 19B07C: using guessed type int __fastcall cloudGetFree(_DWORD);
// 19D16C: using guessed type int cloudGetBufferPtr(void);
// 28732C: using guessed type OSFile pString[32];

//----- (0028765C) --------------------------------------------------------
void __fastcall CHID::CHID(CHID *this)
{
  unsigned int numAlloced; // r9
  unsigned int numEntries; // r5
  MappingPair *dataPtr; // r10
  unsigned int v4; // r6
  MappingPair *v5; // r0
  MappingPair *v6; // r8
  unsigned int v7; // r4
  MappingPair *v8; // r0
  MappingPair *v9; // r10
  unsigned int v10; // r5
  MappingPair *v11; // r0
  MappingPair *v12; // r8
  unsigned int v13; // r6
  MappingPair *v14; // r0
  MappingPair *v15; // r10
  unsigned int v16; // r5
  MappingPair *v17; // r0
  MappingPair *v18; // r8
  unsigned int v19; // r4
  MappingPair *v20; // r0
  MappingPair *v21; // r11
  unsigned int v22; // r6
  MappingPair *v23; // r0
  MappingPair *v24; // r10
  unsigned int v25; // r5
  MappingPair *v26; // r0
  MappingPair *v27; // r11
  unsigned int v28; // r6
  MappingPair *v29; // r0
  MappingPair *v30; // r8
  unsigned int v31; // r5
  MappingPair *v32; // r0
  MappingPair *v33; // r11
  unsigned int v34; // r6
  MappingPair *v35; // r0
  MappingPair *v36; // r10
  unsigned int v37; // r5
  MappingPair *v38; // r0
  MappingPair *v39; // r8
  unsigned int v40; // r6
  MappingPair *v41; // r0
  MappingPair *v42; // r10
  unsigned int v43; // r4
  MappingPair *v44; // r0
  MappingPair *v45; // r8
  unsigned int v46; // r6
  MappingPair *v47; // r0
  MappingPair *v48; // r11
  unsigned int v49; // r5
  MappingPair *v50; // r0
  MappingPair *v51; // r8
  unsigned int v52; // r6
  MappingPair *v53; // r0
  MappingPair *v54; // r10
  unsigned int v55; // r5
  MappingPair *v56; // r0
  MappingPair *v57; // r11
  unsigned int v58; // r6
  MappingPair *v59; // r0
  MappingPair *v60; // r8
  unsigned int v61; // r4
  MappingPair *v62; // r0
  MappingPair *v63; // r10
  unsigned int v64; // r6
  MappingPair *v65; // r0
  MappingPair *v66; // r11
  unsigned int v67; // r5
  MappingPair *v68; // r0
  MappingPair *v69; // r10
  unsigned int v70; // r6
  MappingPair *v71; // r0
  MappingPair *v72; // r8
  unsigned int v73; // r5
  MappingPair *v74; // r0
  MappingPair *v75; // r10
  unsigned int v76; // r4
  MappingPair *v77; // r0
  MappingPair *v78; // r8
  unsigned int v79; // r6
  MappingPair *v80; // r0
  MappingPair *v81; // r10
  unsigned int v82; // r5
  MappingPair *v83; // r0
  MappingPair *v84; // r8
  unsigned int v85; // r4
  MappingPair *v86; // r0
  MappingPair *v87; // r11
  unsigned int v88; // r6
  MappingPair *v89; // r0
  MappingPair *v90; // r10
  unsigned int v91; // r4
  MappingPair *v92; // r0
  MappingPair *v93; // r11
  unsigned int v94; // r6
  MappingPair *v95; // r0
  MappingPair *v96; // r8
  unsigned int v97; // r5
  MappingPair *v98; // r0
  MappingPair *v99; // r10
  unsigned int v100; // r6
  MappingPair *v101; // r0
  MappingPair *v102; // r8
  unsigned int v103; // r4
  MappingPair *v104; // r0
  MappingPair *v105; // r11
  unsigned int v106; // r5
  MappingPair *v107; // r0
  MappingPair *v108; // r10
  unsigned int v109; // r6
  MappingPair *v110; // r0
  MappingPair *v111; // r8
  unsigned int v112; // r4
  MappingPair *v113; // r0
  MappingPair *v114; // r10
  unsigned int v115; // r5
  MappingPair *v116; // r0
  MappingPair *v117; // r8
  unsigned int v118; // r6
  MappingPair *v119; // r0
  MappingPair *v120; // r11
  unsigned int v121; // r4
  MappingPair *v122; // r0
  MappingPair *v123; // r10
  unsigned int v124; // r6
  MappingPair *v125; // r0
  MappingPair *v126; // r8
  unsigned int v127; // r5
  MappingPair *v128; // r0
  MappingPair *v129; // r10
  unsigned int v130; // r4
  MappingPair *v131; // r0
  MappingPair *v132; // r11
  unsigned int v133; // r6
  MappingPair *v134; // r0
  MappingPair *v135; // r8
  unsigned int v136; // r4
  MappingPair *v137; // r0
  MappingPair *v138; // r10
  unsigned int v139; // r5
  MappingPair *v140; // r0
  MappingPair *v141; // r8
  unsigned int v142; // r6
  MappingPair *v143; // r0
  MappingPair *v144; // r11
  unsigned int v145; // r4
  MappingPair *v146; // r0
  MappingPair *v147; // r10
  unsigned int v148; // r6
  MappingPair *v149; // r0
  MappingPair *v150; // r8
  unsigned int v151; // r5
  MappingPair *v152; // r0
  MappingPair *v153; // r10
  unsigned int v154; // r4
  MappingPair *v155; // r0
  MappingPair *v156; // r8
  unsigned int v157; // r6
  MappingPair *v158; // r0
  MappingPair *v159; // r10
  unsigned int v160; // r5
  MappingPair *v161; // r0
  MappingPair *v162; // r8
  unsigned int v163; // r4
  MappingPair *v164; // r0
  MappingPair *v165; // r11
  unsigned int v166; // r6
  MappingPair *v167; // r0
  MappingPair *v168; // r8
  unsigned int v169; // r4
  MappingPair *v170; // r0
  MappingPair *v171; // r10
  unsigned int v172; // r6
  MappingPair *v173; // r0
  MappingPair *v174; // r8
  unsigned int v175; // r5
  MappingPair *v176; // r0
  MappingPair *v177; // r10
  unsigned int v178; // r6
  MappingPair *v179; // r0
  MappingPair *v180; // r8
  unsigned int v181; // r4
  MappingPair *v182; // r0
  MappingPair *v183; // r11
  unsigned int v184; // r5
  MappingPair *v185; // r0
  MappingPair *v186; // r10
  unsigned int v187; // r6
  MappingPair *v188; // r0
  MappingPair *v189; // r8
  unsigned int v190; // r4
  MappingPair *v191; // r0
  MappingPair *v192; // r10
  unsigned int v193; // r5
  MappingPair *v194; // r0
  MappingPair *v195; // r8
  unsigned int v196; // r6
  MappingPair *v197; // r0
  MappingPair *v198; // r11
  unsigned int v199; // r4
  MappingPair *v200; // r0
  MappingPair *v201; // r10
  unsigned int v202; // r6
  MappingPair *v203; // r0
  MappingPair *v204; // r8
  unsigned int v205; // r4
  MappingPair *v206; // r0
  MappingPair *v207; // r10
  unsigned int v208; // r6
  MappingPair *v209; // r0
  MappingPair *v210; // r8
  unsigned int v211; // r4
  MappingPair *v212; // r0
  MappingPair *v213; // r10
  unsigned int v214; // r6
  MappingPair *v215; // r0
  MappingPair *v216; // r8
  unsigned int v217; // r4
  MappingPair *v218; // r0
  MappingPair *v219; // r10
  unsigned int v220; // r6
  MappingPair *v221; // r0
  MappingPair *v222; // r8
  unsigned int v223; // r4
  MappingPair *v224; // r0
  MappingPair *v225; // r10
  unsigned int v226; // r6
  MappingPair *v227; // r0
  MappingPair *v228; // r8
  unsigned int v229; // r4
  MappingPair *v230; // r0
  MappingPair *v231; // r10
  unsigned int v232; // r6
  MappingPair *v233; // r0
  MappingPair *v234; // r8
  unsigned int v235; // r4
  MappingPair *v236; // r0
  MappingPair *v237; // r10
  unsigned int v238; // r6
  MappingPair *v239; // r0
  MappingPair *v240; // r8
  unsigned int v241; // r5
  MappingPair *v242; // r0
  MappingPair *v243; // r11
  unsigned int v244; // r4
  MappingPair *v245; // r0
  MappingPair *v246; // r10
  unsigned int v247; // r6
  MappingPair *v248; // r0
  MappingPair *v249; // r8
  unsigned int v250; // r4
  MappingPair *v251; // r0
  MappingPair *v252; // r10
  unsigned int v253; // r6
  MappingPair *v254; // r0
  MappingPair *v255; // r8
  unsigned int v256; // r4
  MappingPair *v257; // r0
  MappingPair *v258; // r10
  unsigned int v259; // r6
  MappingPair *v260; // r0
  MappingPair *v261; // r8
  unsigned int v262; // r4
  MappingPair *v263; // r0
  MappingPair *v264; // r10
  unsigned int v265; // r6
  MappingPair *v266; // r0
  MappingPair *v267; // r8
  unsigned int v268; // r5
  MappingPair *v269; // r0
  MappingPair *v270; // r10
  unsigned int v271; // r4
  MappingPair *v272; // r0
  MappingPair *v273; // r8
  unsigned int v274; // r6
  MappingPair *v275; // r0
  MappingPair *v276; // r10
  unsigned int v277; // r5
  MappingPair *v278; // r0
  MappingPair *v279; // r8
  unsigned int v280; // r6
  MappingPair *v281; // r0
  MappingPair *v282; // r10
  unsigned int v283; // r4
  MappingPair *v284; // r0
  MappingPair *v285; // r8
  unsigned int v286; // r5
  MappingPair *v287; // r0
  MappingPair *v288; // r10
  unsigned int v289; // r4
  MappingPair *v290; // r0
  MappingPair *v291; // r8
  unsigned int v292; // r6
  MappingPair *v293; // r0
  MappingPair *v294; // r10
  unsigned int v295; // r5
  MappingPair *v296; // r0
  MappingPair *v297; // r8
  unsigned int v298; // r4
  unsigned int v299; // r6
  MappingPair *v300; // r0
  MappingPair *v301; // r5
  unsigned int v302; // r6
  unsigned int v303; // r9
  MappingPair *v304; // r10
  MappingPair *v305; // r4
  unsigned int v306; // r4
  MappingPair *v307; // r0
  MappingPair *v308; // r8
  unsigned int v309; // r6
  MappingPair *v310; // r0
  MappingPair *v311; // r11
  unsigned int v312; // r5
  MappingPair *v313; // r0
  MappingPair *v314; // r8
  unsigned int v315; // r4
  MappingPair *v316; // r0
  MappingPair *v317; // r10
  unsigned int v318; // r6
  MappingPair *v319; // r0
  MappingPair *v320; // r8
  unsigned int v321; // r4
  MappingPair *v322; // r0
  MappingPair *v323; // r10
  unsigned int v324; // r6
  MappingPair *v325; // r0
  MappingPair *v326; // r8
  unsigned int v327; // r5
  unsigned int v328; // r6
  MappingPair *v329; // r0
  MappingPair *v330; // r4
  int v331[33]; // [sp+8h] [bp-A8h] BYREF

  this->_vptr$CHID = (int (**)(void))&off_662080;
  CHID::m_MappingPairs.numEntries = 0;
  numAlloced = CHID::m_MappingPairs.numAlloced;
  strcpy((char *)&v331[1], "MAPPING_UNKNOWN");
  CHID::m_nDeadFrames = 0;
  v331[0] = 0;
  if ( CHID::m_MappingPairs.numAlloced )
  {
    numEntries = 0;
    dataPtr = CHID::m_MappingPairs.dataPtr;
  }
  else
  {
    dataPtr = (MappingPair *)malloc(0x210u);
    if ( CHID::m_MappingPairs.dataPtr )
    {
      free(CHID::m_MappingPairs.dataPtr);
      numEntries = CHID::m_MappingPairs.numEntries;
    }
    else
    {
      numEntries = 0;
    }
    numAlloced = 4;
    CHID::m_MappingPairs.dataPtr = dataPtr;
    CHID::m_MappingPairs.numAlloced = 4;
  }
  qmemcpy(&dataPtr[numEntries], v331, sizeof(MappingPair));
  v4 = numEntries + 1;
  CHID::m_MappingPairs.numEntries = numEntries + 1;
  v331[0] = 1;
  strcpy((char *)&v331[1], "MAPPING_ATTACK");
  if ( numAlloced >= numEntries + 2 )
  {
    v6 = dataPtr;
  }
  else
  {
    numAlloced = 4 * (numEntries + 2) / 3 + 3;
    v5 = (MappingPair *)malloc(132 * numAlloced);
    v6 = v5;
    if ( dataPtr )
    {
      qmemcpy(v5, dataPtr, 132 * v4);
      free(dataPtr);
      v4 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v6;
    CHID::m_MappingPairs.numAlloced = 4 * (numEntries + 2) / 3 + 3;
  }
  qmemcpy(&v6[v4], v331, sizeof(MappingPair));
  v7 = v4 + 1;
  CHID::m_MappingPairs.numEntries = v4 + 1;
  v331[0] = 2;
  strcpy((char *)&v331[1], "MAPPING_SPRINT");
  if ( numAlloced >= v4 + 2 )
  {
    v9 = v6;
  }
  else
  {
    numAlloced = 4 * (v4 + 2) / 3 + 3;
    v8 = (MappingPair *)malloc(132 * numAlloced);
    v9 = v8;
    if ( v6 )
    {
      qmemcpy(v8, v6, 132 * v7);
      free(v6);
      v7 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v9;
    CHID::m_MappingPairs.numAlloced = 4 * (v4 + 2) / 3 + 3;
  }
  qmemcpy(&v9[v7], v331, sizeof(MappingPair));
  v10 = v7 + 1;
  CHID::m_MappingPairs.numEntries = v7 + 1;
  v331[0] = 3;
  strcpy((char *)&v331[1], "MAPPING_JUMP");
  if ( numAlloced >= v7 + 2 )
  {
    v12 = v9;
  }
  else
  {
    numAlloced = 4 * (v7 + 2) / 3 + 3;
    v11 = (MappingPair *)malloc(132 * numAlloced);
    v12 = v11;
    if ( v9 )
    {
      qmemcpy(v11, v9, 132 * v10);
      free(v9);
      v10 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v12;
    CHID::m_MappingPairs.numAlloced = 4 * (v7 + 2) / 3 + 3;
  }
  qmemcpy(&v12[v10], v331, sizeof(MappingPair));
  v13 = v10 + 1;
  CHID::m_MappingPairs.numEntries = v10 + 1;
  v331[0] = 4;
  strcpy((char *)&v331[1], "MAPPING_CROUCH");
  if ( numAlloced >= v10 + 2 )
  {
    v15 = v12;
  }
  else
  {
    numAlloced = 4 * (v10 + 2) / 3 + 3;
    v14 = (MappingPair *)malloc(132 * numAlloced);
    v15 = v14;
    if ( v12 )
    {
      qmemcpy(v14, v12, 132 * v13);
      free(v12);
      v13 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v15;
    CHID::m_MappingPairs.numAlloced = 4 * (v10 + 2) / 3 + 3;
  }
  qmemcpy(&v15[v13], v331, sizeof(MappingPair));
  v16 = v13 + 1;
  CHID::m_MappingPairs.numEntries = v13 + 1;
  strcpy((char *)&v331[1], "MAPPING_ENTER_CAR");
  v331[0] = 5;
  if ( numAlloced >= v13 + 2 )
  {
    v18 = v15;
  }
  else
  {
    numAlloced = 4 * (v13 + 2) / 3 + 3;
    v17 = (MappingPair *)malloc(132 * numAlloced);
    v18 = v17;
    if ( v15 )
    {
      qmemcpy(v17, v15, 132 * v16);
      free(v15);
      v16 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v18;
    CHID::m_MappingPairs.numAlloced = 4 * (v13 + 2) / 3 + 3;
  }
  qmemcpy(&v18[v16], v331, sizeof(MappingPair));
  v19 = v16 + 1;
  CHID::m_MappingPairs.numEntries = v16 + 1;
  v331[0] = 6;
  strcpy((char *)&v331[1], "MAPPING_BRAKE");
  if ( numAlloced >= v16 + 2 )
  {
    v21 = v18;
  }
  else
  {
    numAlloced = 4 * (v16 + 2) / 3 + 3;
    v20 = (MappingPair *)malloc(132 * numAlloced);
    v21 = v20;
    if ( v18 )
    {
      qmemcpy(v20, v18, 132 * v19);
      free(v18);
      v19 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v21;
    CHID::m_MappingPairs.numAlloced = 4 * (v16 + 2) / 3 + 3;
  }
  qmemcpy(&v21[v19], v331, sizeof(MappingPair));
  v22 = v19 + 1;
  CHID::m_MappingPairs.numEntries = v19 + 1;
  strcpy((char *)&v331[1], "MAPPING_HANDBRAKE");
  v331[0] = 7;
  if ( numAlloced >= v19 + 2 )
  {
    v24 = v21;
  }
  else
  {
    numAlloced = 4 * (v19 + 2) / 3 + 3;
    v23 = (MappingPair *)malloc(132 * numAlloced);
    v24 = v23;
    if ( v21 )
    {
      qmemcpy(v23, v21, 132 * v22);
      free(v21);
      v22 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v24;
    CHID::m_MappingPairs.numAlloced = 4 * (v19 + 2) / 3 + 3;
  }
  qmemcpy(&v24[v22], v331, sizeof(MappingPair));
  v25 = v22 + 1;
  CHID::m_MappingPairs.numEntries = v22 + 1;
  strcpy((char *)&v331[1], "MAPPING_ACCELERATE");
  v331[0] = 8;
  if ( numAlloced >= v22 + 2 )
  {
    v27 = v24;
  }
  else
  {
    numAlloced = 4 * (v22 + 2) / 3 + 3;
    v26 = (MappingPair *)malloc(132 * numAlloced);
    v27 = v26;
    if ( v24 )
    {
      qmemcpy(v26, v24, 132 * v25);
      free(v24);
      v25 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v27;
    CHID::m_MappingPairs.numAlloced = 4 * (v22 + 2) / 3 + 3;
  }
  qmemcpy(&v27[v25], v331, sizeof(MappingPair));
  v28 = v25 + 1;
  CHID::m_MappingPairs.numEntries = v25 + 1;
  strcpy((char *)&v331[1], "MAPPING_CAMERA_CLOSER");
  v331[0] = 9;
  if ( numAlloced >= v25 + 2 )
  {
    v30 = v27;
  }
  else
  {
    numAlloced = 4 * (v25 + 2) / 3 + 3;
    v29 = (MappingPair *)malloc(132 * numAlloced);
    v30 = v29;
    if ( v27 )
    {
      qmemcpy(v29, v27, 132 * v28);
      free(v27);
      v28 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v30;
    CHID::m_MappingPairs.numAlloced = 4 * (v25 + 2) / 3 + 3;
  }
  qmemcpy(&v30[v28], v331, sizeof(MappingPair));
  v31 = v28 + 1;
  CHID::m_MappingPairs.numEntries = v28 + 1;
  strcpy((char *)&v331[1], "MAPPING_CAMERA_FARTHER");
  v331[0] = 10;
  if ( numAlloced >= v28 + 2 )
  {
    v33 = v30;
  }
  else
  {
    numAlloced = 4 * (v28 + 2) / 3 + 3;
    v32 = (MappingPair *)malloc(132 * numAlloced);
    v33 = v32;
    if ( v30 )
    {
      qmemcpy(v32, v30, 132 * v31);
      free(v30);
      v31 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v33;
    CHID::m_MappingPairs.numAlloced = 4 * (v28 + 2) / 3 + 3;
  }
  qmemcpy(&v33[v31], v331, sizeof(MappingPair));
  v34 = v31 + 1;
  CHID::m_MappingPairs.numEntries = v31 + 1;
  v331[0] = 11;
  strcpy((char *)&v331[1], "MAPPING_HORN");
  if ( numAlloced >= v31 + 2 )
  {
    v36 = v33;
  }
  else
  {
    numAlloced = 4 * (v31 + 2) / 3 + 3;
    v35 = (MappingPair *)malloc(132 * numAlloced);
    v36 = v35;
    if ( v33 )
    {
      qmemcpy(v35, v33, 132 * v34);
      free(v33);
      v34 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v36;
    CHID::m_MappingPairs.numAlloced = 4 * (v31 + 2) / 3 + 3;
  }
  qmemcpy(&v36[v34], v331, sizeof(MappingPair));
  v37 = v34 + 1;
  CHID::m_MappingPairs.numEntries = v34 + 1;
  strcpy((char *)&v331[1], "MAPPING_RADIO_PREV_STATION");
  v331[0] = 12;
  if ( numAlloced >= v34 + 2 )
  {
    v39 = v36;
  }
  else
  {
    numAlloced = 4 * (v34 + 2) / 3 + 3;
    v38 = (MappingPair *)malloc(132 * numAlloced);
    v39 = v38;
    if ( v36 )
    {
      qmemcpy(v38, v36, 132 * v37);
      free(v36);
      v37 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v39;
    CHID::m_MappingPairs.numAlloced = 4 * (v34 + 2) / 3 + 3;
  }
  qmemcpy(&v39[v37], v331, sizeof(MappingPair));
  v40 = v37 + 1;
  CHID::m_MappingPairs.numEntries = v37 + 1;
  strcpy((char *)&v331[1], "MAPPING_RADIO_NEXT_STATION");
  v331[0] = 13;
  if ( numAlloced >= v37 + 2 )
  {
    v42 = v39;
  }
  else
  {
    numAlloced = 4 * (v37 + 2) / 3 + 3;
    v41 = (MappingPair *)malloc(132 * numAlloced);
    v42 = v41;
    if ( v39 )
    {
      qmemcpy(v41, v39, 132 * v40);
      free(v39);
      v40 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v42;
    CHID::m_MappingPairs.numAlloced = 4 * (v37 + 2) / 3 + 3;
  }
  qmemcpy(&v42[v40], v331, sizeof(MappingPair));
  v43 = v40 + 1;
  CHID::m_MappingPairs.numEntries = v40 + 1;
  strcpy((char *)&v331[1], "MAPPING_VITAL_STATS");
  v331[0] = 14;
  if ( numAlloced >= v40 + 2 )
  {
    v45 = v42;
  }
  else
  {
    numAlloced = 4 * (v40 + 2) / 3 + 3;
    v44 = (MappingPair *)malloc(132 * numAlloced);
    v45 = v44;
    if ( v42 )
    {
      qmemcpy(v44, v42, 132 * v43);
      free(v42);
      v43 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v45;
    CHID::m_MappingPairs.numAlloced = 4 * (v40 + 2) / 3 + 3;
  }
  qmemcpy(&v45[v43], v331, sizeof(MappingPair));
  v46 = v43 + 1;
  CHID::m_MappingPairs.numEntries = v43 + 1;
  qmemcpy(&v331[1], "MAPPING_NEXT_WEA", 16);
  v331[5] = (int)&loc_4E4F4E + 2;
  v331[0] = 15;
  if ( numAlloced >= v43 + 2 )
  {
    v48 = v45;
  }
  else
  {
    numAlloced = 4 * (v43 + 2) / 3 + 3;
    v47 = (MappingPair *)malloc(132 * numAlloced);
    v48 = v47;
    if ( v45 )
    {
      qmemcpy(v47, v45, 132 * v46);
      free(v45);
      v46 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v48;
    CHID::m_MappingPairs.numAlloced = 4 * (v43 + 2) / 3 + 3;
  }
  qmemcpy(&v48[v46], v331, sizeof(MappingPair));
  v49 = v46 + 1;
  CHID::m_MappingPairs.numEntries = v46 + 1;
  qmemcpy(&v331[1], "MAPPING_PREV_WEA", 16);
  v331[5] = (int)&loc_4E4F4E + 2;
  v331[0] = 16;
  if ( numAlloced >= v46 + 2 )
  {
    v51 = v48;
  }
  else
  {
    numAlloced = 4 * (v46 + 2) / 3 + 3;
    v50 = (MappingPair *)malloc(132 * numAlloced);
    v51 = v50;
    if ( v48 )
    {
      qmemcpy(v50, v48, 132 * v49);
      free(v48);
      v49 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v51;
    CHID::m_MappingPairs.numAlloced = 4 * (v46 + 2) / 3 + 3;
  }
  qmemcpy(&v51[v49], v331, sizeof(MappingPair));
  v52 = v49 + 1;
  CHID::m_MappingPairs.numEntries = v49 + 1;
  v331[0] = 17;
  strcpy((char *)&v331[1], "MAPPING_RADAR");
  if ( numAlloced >= v49 + 2 )
  {
    v54 = v51;
  }
  else
  {
    numAlloced = 4 * (v49 + 2) / 3 + 3;
    v53 = (MappingPair *)malloc(132 * numAlloced);
    v54 = v53;
    if ( v51 )
    {
      qmemcpy(v53, v51, 132 * v52);
      free(v51);
      v52 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v54;
    CHID::m_MappingPairs.numAlloced = 4 * (v49 + 2) / 3 + 3;
  }
  qmemcpy(&v54[v52], v331, sizeof(MappingPair));
  v55 = v52 + 1;
  CHID::m_MappingPairs.numEntries = v52 + 1;
  strcpy((char *)&v331[1], "MAPPING_PED_LOOK_BACK");
  v331[0] = 18;
  if ( numAlloced >= v52 + 2 )
  {
    v57 = v54;
  }
  else
  {
    numAlloced = 4 * (v52 + 2) / 3 + 3;
    v56 = (MappingPair *)malloc(132 * numAlloced);
    v57 = v56;
    if ( v54 )
    {
      qmemcpy(v56, v54, 132 * v55);
      free(v54);
      v55 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v57;
    CHID::m_MappingPairs.numAlloced = 4 * (v52 + 2) / 3 + 3;
  }
  qmemcpy(&v57[v55], v331, sizeof(MappingPair));
  v58 = v55 + 1;
  CHID::m_MappingPairs.numEntries = v55 + 1;
  strcpy((char *)&v331[1], "MAPPING_VEHICLE_LOOK_LEFT");
  v331[0] = 19;
  if ( numAlloced >= v55 + 2 )
  {
    v60 = v57;
  }
  else
  {
    numAlloced = 4 * (v55 + 2) / 3 + 3;
    v59 = (MappingPair *)malloc(132 * numAlloced);
    v60 = v59;
    if ( v57 )
    {
      qmemcpy(v59, v57, 132 * v58);
      free(v57);
      v58 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v60;
    CHID::m_MappingPairs.numAlloced = 4 * (v55 + 2) / 3 + 3;
  }
  qmemcpy(&v60[v58], v331, sizeof(MappingPair));
  v61 = v58 + 1;
  CHID::m_MappingPairs.numEntries = v58 + 1;
  strcpy((char *)&v331[1], "MAPPING_VEHICLE_LOOK_RIGHT");
  v331[0] = 20;
  if ( numAlloced >= v58 + 2 )
  {
    v63 = v60;
  }
  else
  {
    numAlloced = 4 * (v58 + 2) / 3 + 3;
    v62 = (MappingPair *)malloc(132 * numAlloced);
    v63 = v62;
    if ( v60 )
    {
      qmemcpy(v62, v60, 132 * v61);
      free(v60);
      v61 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v63;
    CHID::m_MappingPairs.numAlloced = 4 * (v58 + 2) / 3 + 3;
  }
  qmemcpy(&v63[v61], v331, sizeof(MappingPair));
  v64 = v61 + 1;
  CHID::m_MappingPairs.numEntries = v61 + 1;
  strcpy((char *)&v331[1], "MAPPING_VEHICLE_LOOK_BACK");
  v331[0] = 21;
  if ( numAlloced >= v61 + 2 )
  {
    v66 = v63;
  }
  else
  {
    numAlloced = 4 * (v61 + 2) / 3 + 3;
    v65 = (MappingPair *)malloc(132 * numAlloced);
    v66 = v65;
    if ( v63 )
    {
      qmemcpy(v65, v63, 132 * v64);
      free(v63);
      v64 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v66;
    CHID::m_MappingPairs.numAlloced = 4 * (v61 + 2) / 3 + 3;
  }
  qmemcpy(&v66[v64], v331, sizeof(MappingPair));
  v67 = v64 + 1;
  CHID::m_MappingPairs.numEntries = v64 + 1;
  strcpy((char *)&v331[1], "MAPPING_MISSION_START_AND_CANCEL");
  v331[0] = 22;
  if ( numAlloced >= v64 + 2 )
  {
    v69 = v66;
  }
  else
  {
    numAlloced = 4 * (v64 + 2) / 3 + 3;
    v68 = (MappingPair *)malloc(132 * numAlloced);
    v69 = v68;
    if ( v66 )
    {
      qmemcpy(v68, v66, 132 * v67);
      free(v66);
      v67 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v69;
    CHID::m_MappingPairs.numAlloced = 4 * (v64 + 2) / 3 + 3;
  }
  qmemcpy(&v69[v67], v331, sizeof(MappingPair));
  v70 = v67 + 1;
  CHID::m_MappingPairs.numEntries = v67 + 1;
  strcpy((char *)&v331[1], "MAPPING_MISSION_START_AND_CANCEL_VIGILANTE");
  v331[0] = 23;
  if ( numAlloced >= v67 + 2 )
  {
    v72 = v69;
  }
  else
  {
    numAlloced = 4 * (v67 + 2) / 3 + 3;
    v71 = (MappingPair *)malloc(132 * numAlloced);
    v72 = v71;
    if ( v69 )
    {
      qmemcpy(v71, v69, 132 * v70);
      free(v69);
      v70 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v72;
    CHID::m_MappingPairs.numAlloced = 4 * (v67 + 2) / 3 + 3;
  }
  qmemcpy(&v72[v70], v331, sizeof(MappingPair));
  v73 = v70 + 1;
  CHID::m_MappingPairs.numEntries = v70 + 1;
  strcpy((char *)&v331[1], "MAPPING_VEHICLE_STEER_X");
  v331[0] = 24;
  if ( numAlloced >= v70 + 2 )
  {
    v75 = v72;
  }
  else
  {
    numAlloced = 4 * (v70 + 2) / 3 + 3;
    v74 = (MappingPair *)malloc(132 * numAlloced);
    v75 = v74;
    if ( v72 )
    {
      qmemcpy(v74, v72, 132 * v73);
      free(v72);
      v73 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v75;
    CHID::m_MappingPairs.numAlloced = 4 * (v70 + 2) / 3 + 3;
  }
  qmemcpy(&v75[v73], v331, sizeof(MappingPair));
  v76 = v73 + 1;
  CHID::m_MappingPairs.numEntries = v73 + 1;
  strcpy((char *)&v331[1], "MAPPING_VEHICLE_STEER_Y");
  v331[0] = 25;
  if ( numAlloced >= v73 + 2 )
  {
    v78 = v75;
  }
  else
  {
    numAlloced = 4 * (v73 + 2) / 3 + 3;
    v77 = (MappingPair *)malloc(132 * numAlloced);
    v78 = v77;
    if ( v75 )
    {
      qmemcpy(v77, v75, 132 * v76);
      free(v75);
      v76 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v78;
    CHID::m_MappingPairs.numAlloced = 4 * (v73 + 2) / 3 + 3;
  }
  qmemcpy(&v78[v76], v331, sizeof(MappingPair));
  v79 = v76 + 1;
  CHID::m_MappingPairs.numEntries = v76 + 1;
  strcpy((char *)&v331[1], "MAPPING_VEHICLE_STEER_LEFT");
  v331[0] = 26;
  if ( numAlloced >= v76 + 2 )
  {
    v81 = v78;
  }
  else
  {
    numAlloced = 4 * (v76 + 2) / 3 + 3;
    v80 = (MappingPair *)malloc(132 * numAlloced);
    v81 = v80;
    if ( v78 )
    {
      qmemcpy(v80, v78, 132 * v79);
      free(v78);
      v79 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v81;
    CHID::m_MappingPairs.numAlloced = 4 * (v76 + 2) / 3 + 3;
  }
  qmemcpy(&v81[v79], v331, sizeof(MappingPair));
  v82 = v79 + 1;
  CHID::m_MappingPairs.numEntries = v79 + 1;
  strcpy((char *)&v331[1], "MAPPING_VEHICLE_STEER_RIGHT");
  v331[0] = 27;
  if ( numAlloced >= v79 + 2 )
  {
    v84 = v81;
  }
  else
  {
    numAlloced = 4 * (v79 + 2) / 3 + 3;
    v83 = (MappingPair *)malloc(132 * numAlloced);
    v84 = v83;
    if ( v81 )
    {
      qmemcpy(v83, v81, 132 * v82);
      free(v81);
      v82 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v84;
    CHID::m_MappingPairs.numAlloced = 4 * (v79 + 2) / 3 + 3;
  }
  qmemcpy(&v84[v82], v331, sizeof(MappingPair));
  v85 = v82 + 1;
  CHID::m_MappingPairs.numEntries = v82 + 1;
  v331[0] = 28;
  strcpy((char *)&v331[1], "MAPPING_LOOK_X");
  if ( numAlloced >= v82 + 2 )
  {
    v87 = v84;
  }
  else
  {
    numAlloced = 4 * (v82 + 2) / 3 + 3;
    v86 = (MappingPair *)malloc(132 * numAlloced);
    v87 = v86;
    if ( v84 )
    {
      qmemcpy(v86, v84, 132 * v85);
      free(v84);
      v85 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v87;
    CHID::m_MappingPairs.numAlloced = 4 * (v82 + 2) / 3 + 3;
  }
  qmemcpy(&v87[v85], v331, sizeof(MappingPair));
  v88 = v85 + 1;
  CHID::m_MappingPairs.numEntries = v85 + 1;
  v331[0] = 29;
  strcpy((char *)&v331[1], "MAPPING_LOOK_Y");
  if ( numAlloced >= v85 + 2 )
  {
    v90 = v87;
  }
  else
  {
    numAlloced = 4 * (v85 + 2) / 3 + 3;
    v89 = (MappingPair *)malloc(132 * numAlloced);
    v90 = v89;
    if ( v87 )
    {
      qmemcpy(v89, v87, 132 * v88);
      free(v87);
      v88 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v90;
    CHID::m_MappingPairs.numAlloced = 4 * (v85 + 2) / 3 + 3;
  }
  qmemcpy(&v90[v88], v331, sizeof(MappingPair));
  v91 = v88 + 1;
  CHID::m_MappingPairs.numEntries = v88 + 1;
  strcpy((char *)&v331[1], "MAPPING_PED_MOVE_X");
  v331[0] = 30;
  if ( numAlloced >= v88 + 2 )
  {
    v93 = v90;
  }
  else
  {
    numAlloced = 4 * (v88 + 2) / 3 + 3;
    v92 = (MappingPair *)malloc(132 * numAlloced);
    v93 = v92;
    if ( v90 )
    {
      qmemcpy(v92, v90, 132 * v91);
      free(v90);
      v91 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v93;
    CHID::m_MappingPairs.numAlloced = 4 * (v88 + 2) / 3 + 3;
  }
  qmemcpy(&v93[v91], v331, sizeof(MappingPair));
  v94 = v91 + 1;
  CHID::m_MappingPairs.numEntries = v91 + 1;
  strcpy((char *)&v331[1], "MAPPING_PED_MOVE_Y");
  v331[0] = 31;
  if ( numAlloced >= v91 + 2 )
  {
    v96 = v93;
  }
  else
  {
    numAlloced = 4 * (v91 + 2) / 3 + 3;
    v95 = (MappingPair *)malloc(132 * numAlloced);
    v96 = v95;
    if ( v93 )
    {
      qmemcpy(v95, v93, 132 * v94);
      free(v93);
      v94 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v96;
    CHID::m_MappingPairs.numAlloced = 4 * (v91 + 2) / 3 + 3;
  }
  qmemcpy(&v96[v94], v331, sizeof(MappingPair));
  v97 = v94 + 1;
  CHID::m_MappingPairs.numEntries = v94 + 1;
  strcpy((char *)&v331[1], "MAPPING_AUTO_HYDRAULICS");
  v331[0] = 32;
  if ( numAlloced >= v94 + 2 )
  {
    v99 = v96;
  }
  else
  {
    numAlloced = 4 * (v94 + 2) / 3 + 3;
    v98 = (MappingPair *)malloc(132 * numAlloced);
    v99 = v98;
    if ( v96 )
    {
      qmemcpy(v98, v96, 132 * v97);
      free(v96);
      v97 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v99;
    CHID::m_MappingPairs.numAlloced = 4 * (v94 + 2) / 3 + 3;
  }
  qmemcpy(&v99[v97], v331, sizeof(MappingPair));
  v100 = v97 + 1;
  CHID::m_MappingPairs.numEntries = v97 + 1;
  strcpy((char *)&v331[1], "MAPPING_SWAP_WEAPONS_AND_PURCHASE");
  v331[0] = 33;
  if ( numAlloced >= v97 + 2 )
  {
    v102 = v99;
  }
  else
  {
    numAlloced = 4 * (v97 + 2) / 3 + 3;
    v101 = (MappingPair *)malloc(132 * numAlloced);
    v102 = v101;
    if ( v99 )
    {
      qmemcpy(v101, v99, 132 * v100);
      free(v99);
      v100 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v102;
    CHID::m_MappingPairs.numAlloced = 4 * (v97 + 2) / 3 + 3;
  }
  qmemcpy(&v102[v100], v331, sizeof(MappingPair));
  v103 = v100 + 1;
  CHID::m_MappingPairs.numEntries = v100 + 1;
  strcpy((char *)&v331[1], "MAPPING_WEAPON_ZOOM_IN");
  v331[0] = 34;
  if ( numAlloced >= v100 + 2 )
  {
    v105 = v102;
  }
  else
  {
    numAlloced = 4 * (v100 + 2) / 3 + 3;
    v104 = (MappingPair *)malloc(132 * numAlloced);
    v105 = v104;
    if ( v102 )
    {
      qmemcpy(v104, v102, 132 * v103);
      free(v102);
      v103 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v105;
    CHID::m_MappingPairs.numAlloced = 4 * (v100 + 2) / 3 + 3;
  }
  qmemcpy(&v105[v103], v331, sizeof(MappingPair));
  v106 = v103 + 1;
  CHID::m_MappingPairs.numEntries = v103 + 1;
  strcpy((char *)&v331[1], "MAPPING_WEAPON_ZOOM_OUT");
  v331[0] = 35;
  if ( numAlloced >= v103 + 2 )
  {
    v108 = v105;
  }
  else
  {
    numAlloced = 4 * (v103 + 2) / 3 + 3;
    v107 = (MappingPair *)malloc(132 * numAlloced);
    v108 = v107;
    if ( v105 )
    {
      qmemcpy(v107, v105, 132 * v106);
      free(v105);
      v106 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v108;
    CHID::m_MappingPairs.numAlloced = 4 * (v103 + 2) / 3 + 3;
  }
  qmemcpy(&v108[v106], v331, sizeof(MappingPair));
  v109 = v106 + 1;
  CHID::m_MappingPairs.numEntries = v106 + 1;
  strcpy((char *)&v331[1], "MAPPING_ENTER_AND_EXIT_TARGETING");
  v331[0] = 36;
  if ( numAlloced >= v106 + 2 )
  {
    v111 = v108;
  }
  else
  {
    numAlloced = 4 * (v106 + 2) / 3 + 3;
    v110 = (MappingPair *)malloc(132 * numAlloced);
    v111 = v110;
    if ( v108 )
    {
      qmemcpy(v110, v108, 132 * v109);
      free(v108);
      v109 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v111;
    CHID::m_MappingPairs.numAlloced = 4 * (v106 + 2) / 3 + 3;
  }
  qmemcpy(&v111[v109], v331, sizeof(MappingPair));
  v112 = v109 + 1;
  CHID::m_MappingPairs.numEntries = v109 + 1;
  strcpy((char *)&v331[1], "MAPPING_VEHICLE_BOMB");
  v331[0] = 37;
  if ( numAlloced >= v109 + 2 )
  {
    v114 = v111;
  }
  else
  {
    numAlloced = 4 * (v109 + 2) / 3 + 3;
    v113 = (MappingPair *)malloc(132 * numAlloced);
    v114 = v113;
    if ( v111 )
    {
      qmemcpy(v113, v111, 132 * v112);
      free(v111);
      v112 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v114;
    CHID::m_MappingPairs.numAlloced = 4 * (v109 + 2) / 3 + 3;
  }
  qmemcpy(&v114[v112], v331, sizeof(MappingPair));
  v115 = v112 + 1;
  CHID::m_MappingPairs.numEntries = v112 + 1;
  strcpy((char *)&v331[1], "MAPPING_TURRET_LEFT");
  v331[0] = 38;
  if ( numAlloced >= v112 + 2 )
  {
    v117 = v114;
  }
  else
  {
    numAlloced = 4 * (v112 + 2) / 3 + 3;
    v116 = (MappingPair *)malloc(132 * numAlloced);
    v117 = v116;
    if ( v114 )
    {
      qmemcpy(v116, v114, 132 * v115);
      free(v114);
      v115 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v117;
    CHID::m_MappingPairs.numAlloced = 4 * (v112 + 2) / 3 + 3;
  }
  qmemcpy(&v117[v115], v331, sizeof(MappingPair));
  v118 = v115 + 1;
  CHID::m_MappingPairs.numEntries = v115 + 1;
  strcpy((char *)&v331[1], "MAPPING_TURRET_RIGHT");
  v331[0] = 39;
  if ( numAlloced >= v115 + 2 )
  {
    v120 = v117;
  }
  else
  {
    numAlloced = 4 * (v115 + 2) / 3 + 3;
    v119 = (MappingPair *)malloc(132 * numAlloced);
    v120 = v119;
    if ( v117 )
    {
      qmemcpy(v119, v117, 132 * v118);
      free(v117);
      v118 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v120;
    CHID::m_MappingPairs.numAlloced = 4 * (v115 + 2) / 3 + 3;
  }
  qmemcpy(&v120[v118], v331, sizeof(MappingPair));
  v121 = v118 + 1;
  CHID::m_MappingPairs.numEntries = v118 + 1;
  v331[0] = 40;
  strcpy((char *)&v331[1], "MAPPING_MAGNET");
  if ( numAlloced >= v118 + 2 )
  {
    v123 = v120;
  }
  else
  {
    numAlloced = 4 * (v118 + 2) / 3 + 3;
    v122 = (MappingPair *)malloc(132 * numAlloced);
    v123 = v122;
    if ( v120 )
    {
      qmemcpy(v122, v120, 132 * v121);
      free(v120);
      v121 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v123;
    CHID::m_MappingPairs.numAlloced = 4 * (v118 + 2) / 3 + 3;
  }
  qmemcpy(&v123[v121], v331, sizeof(MappingPair));
  v124 = v121 + 1;
  CHID::m_MappingPairs.numEntries = v121 + 1;
  strcpy((char *)&v331[1], "MAPPING_SKIP_CUTSCENE");
  v331[0] = 41;
  if ( numAlloced >= v121 + 2 )
  {
    v126 = v123;
  }
  else
  {
    numAlloced = 4 * (v121 + 2) / 3 + 3;
    v125 = (MappingPair *)malloc(132 * numAlloced);
    v126 = v125;
    if ( v123 )
    {
      qmemcpy(v125, v123, 132 * v124);
      free(v123);
      v124 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v126;
    CHID::m_MappingPairs.numAlloced = 4 * (v121 + 2) / 3 + 3;
  }
  qmemcpy(&v126[v124], v331, sizeof(MappingPair));
  v127 = v124 + 1;
  CHID::m_MappingPairs.numEntries = v124 + 1;
  strcpy((char *)&v331[1], "MAPPING_GANG_RECRUIT");
  v331[0] = 42;
  if ( numAlloced >= v124 + 2 )
  {
    v129 = v126;
  }
  else
  {
    numAlloced = 4 * (v124 + 2) / 3 + 3;
    v128 = (MappingPair *)malloc(132 * numAlloced);
    v129 = v128;
    if ( v126 )
    {
      qmemcpy(v128, v126, 132 * v127);
      free(v126);
      v127 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v129;
    CHID::m_MappingPairs.numAlloced = 4 * (v124 + 2) / 3 + 3;
  }
  qmemcpy(&v129[v127], v331, sizeof(MappingPair));
  v130 = v127 + 1;
  CHID::m_MappingPairs.numEntries = v127 + 1;
  strcpy((char *)&v331[1], "MAPPING_GANG_IGNORE");
  v331[0] = 43;
  if ( numAlloced >= v127 + 2 )
  {
    v132 = v129;
  }
  else
  {
    numAlloced = 4 * (v127 + 2) / 3 + 3;
    v131 = (MappingPair *)malloc(132 * numAlloced);
    v132 = v131;
    if ( v129 )
    {
      qmemcpy(v131, v129, 132 * v130);
      free(v129);
      v130 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v132;
    CHID::m_MappingPairs.numAlloced = 4 * (v127 + 2) / 3 + 3;
  }
  qmemcpy(&v132[v130], v331, sizeof(MappingPair));
  v133 = v130 + 1;
  CHID::m_MappingPairs.numEntries = v130 + 1;
  strcpy((char *)&v331[1], "MAPPING_GANG_FOLLOW");
  v331[0] = 44;
  if ( numAlloced >= v130 + 2 )
  {
    v135 = v132;
  }
  else
  {
    numAlloced = 4 * (v130 + 2) / 3 + 3;
    v134 = (MappingPair *)malloc(132 * numAlloced);
    v135 = v134;
    if ( v132 )
    {
      qmemcpy(v134, v132, 132 * v133);
      free(v132);
      v133 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v135;
    CHID::m_MappingPairs.numAlloced = 4 * (v130 + 2) / 3 + 3;
  }
  qmemcpy(&v135[v133], v331, sizeof(MappingPair));
  v136 = v133 + 1;
  CHID::m_MappingPairs.numEntries = v133 + 1;
  strcpy((char *)&v331[1], "MAPPING_GANG_HOLD_POSITION");
  v331[0] = 45;
  if ( numAlloced >= v133 + 2 )
  {
    v138 = v135;
  }
  else
  {
    numAlloced = 4 * (v133 + 2) / 3 + 3;
    v137 = (MappingPair *)malloc(132 * numAlloced);
    v138 = v137;
    if ( v135 )
    {
      qmemcpy(v137, v135, 132 * v136);
      free(v135);
      v136 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v138;
    CHID::m_MappingPairs.numAlloced = 4 * (v133 + 2) / 3 + 3;
  }
  qmemcpy(&v138[v136], v331, sizeof(MappingPair));
  v139 = v136 + 1;
  CHID::m_MappingPairs.numEntries = v136 + 1;
  strcpy((char *)&v331[1], "MAPPING_RHYTHM_UP");
  v331[0] = 46;
  if ( numAlloced >= v136 + 2 )
  {
    v141 = v138;
  }
  else
  {
    numAlloced = 4 * (v136 + 2) / 3 + 3;
    v140 = (MappingPair *)malloc(132 * numAlloced);
    v141 = v140;
    if ( v138 )
    {
      qmemcpy(v140, v138, 132 * v139);
      free(v138);
      v139 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v141;
    CHID::m_MappingPairs.numAlloced = 4 * (v136 + 2) / 3 + 3;
  }
  qmemcpy(&v141[v139], v331, sizeof(MappingPair));
  v142 = v139 + 1;
  CHID::m_MappingPairs.numEntries = v139 + 1;
  strcpy((char *)&v331[1], "MAPPING_RHYTHM_DOWN");
  v331[0] = 47;
  if ( numAlloced >= v139 + 2 )
  {
    v144 = v141;
  }
  else
  {
    numAlloced = 4 * (v139 + 2) / 3 + 3;
    v143 = (MappingPair *)malloc(132 * numAlloced);
    v144 = v143;
    if ( v141 )
    {
      qmemcpy(v143, v141, 132 * v142);
      free(v141);
      v142 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v144;
    CHID::m_MappingPairs.numAlloced = 4 * (v139 + 2) / 3 + 3;
  }
  qmemcpy(&v144[v142], v331, sizeof(MappingPair));
  v145 = v142 + 1;
  CHID::m_MappingPairs.numEntries = v142 + 1;
  strcpy((char *)&v331[1], "MAPPING_RHYTHM_LEFT");
  v331[0] = 48;
  if ( numAlloced >= v142 + 2 )
  {
    v147 = v144;
  }
  else
  {
    numAlloced = 4 * (v142 + 2) / 3 + 3;
    v146 = (MappingPair *)malloc(132 * numAlloced);
    v147 = v146;
    if ( v144 )
    {
      qmemcpy(v146, v144, 132 * v145);
      free(v144);
      v145 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v147;
    CHID::m_MappingPairs.numAlloced = 4 * (v142 + 2) / 3 + 3;
  }
  qmemcpy(&v147[v145], v331, sizeof(MappingPair));
  v148 = v145 + 1;
  CHID::m_MappingPairs.numEntries = v145 + 1;
  strcpy((char *)&v331[1], "MAPPING_RHYTHM_RIGHT");
  v331[0] = 49;
  if ( numAlloced >= v145 + 2 )
  {
    v150 = v147;
  }
  else
  {
    numAlloced = 4 * (v145 + 2) / 3 + 3;
    v149 = (MappingPair *)malloc(132 * numAlloced);
    v150 = v149;
    if ( v147 )
    {
      qmemcpy(v149, v147, 132 * v148);
      free(v147);
      v148 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v150;
    CHID::m_MappingPairs.numAlloced = 4 * (v145 + 2) / 3 + 3;
  }
  qmemcpy(&v150[v148], v331, sizeof(MappingPair));
  v151 = v148 + 1;
  CHID::m_MappingPairs.numEntries = v148 + 1;
  strcpy((char *)&v331[1], "MAPPING_DROP_CRANE");
  v331[0] = 50;
  if ( numAlloced >= v148 + 2 )
  {
    v153 = v150;
  }
  else
  {
    numAlloced = 4 * (v148 + 2) / 3 + 3;
    v152 = (MappingPair *)malloc(132 * numAlloced);
    v153 = v152;
    if ( v150 )
    {
      qmemcpy(v152, v150, 132 * v151);
      free(v150);
      v151 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v153;
    CHID::m_MappingPairs.numAlloced = 4 * (v148 + 2) / 3 + 3;
  }
  qmemcpy(&v153[v151], v331, sizeof(MappingPair));
  v154 = v151 + 1;
  CHID::m_MappingPairs.numEntries = v151 + 1;
  strcpy((char *)&v331[1], "MAPPING_DROP_ITEM");
  v331[0] = 51;
  if ( numAlloced >= v151 + 2 )
  {
    v156 = v153;
  }
  else
  {
    numAlloced = 4 * (v151 + 2) / 3 + 3;
    v155 = (MappingPair *)malloc(132 * numAlloced);
    v156 = v155;
    if ( v153 )
    {
      qmemcpy(v155, v153, 132 * v154);
      free(v153);
      v154 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v156;
    CHID::m_MappingPairs.numAlloced = 4 * (v151 + 2) / 3 + 3;
  }
  qmemcpy(&v156[v154], v331, sizeof(MappingPair));
  v157 = v154 + 1;
  CHID::m_MappingPairs.numEntries = v154 + 1;
  v331[0] = 52;
  strcpy((char *)&v331[1], "MAPPING_PHONE");
  if ( numAlloced >= v154 + 2 )
  {
    v159 = v156;
  }
  else
  {
    numAlloced = 4 * (v154 + 2) / 3 + 3;
    v158 = (MappingPair *)malloc(132 * numAlloced);
    v159 = v158;
    if ( v156 )
    {
      qmemcpy(v158, v156, 132 * v157);
      free(v156);
      v157 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v159;
    CHID::m_MappingPairs.numAlloced = 4 * (v154 + 2) / 3 + 3;
  }
  qmemcpy(&v159[v157], v331, sizeof(MappingPair));
  v160 = v157 + 1;
  CHID::m_MappingPairs.numEntries = v157 + 1;
  v331[0] = 53;
  strcpy((char *)&v331[1], "MAPPING_NITRO");
  if ( numAlloced >= v157 + 2 )
  {
    v162 = v159;
  }
  else
  {
    numAlloced = 4 * (v157 + 2) / 3 + 3;
    v161 = (MappingPair *)malloc(132 * numAlloced);
    v162 = v161;
    if ( v159 )
    {
      qmemcpy(v161, v159, 132 * v160);
      free(v159);
      v160 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v162;
    CHID::m_MappingPairs.numAlloced = 4 * (v157 + 2) / 3 + 3;
  }
  qmemcpy(&v162[v160], v331, sizeof(MappingPair));
  v163 = v160 + 1;
  CHID::m_MappingPairs.numEntries = v160 + 1;
  strcpy((char *)&v331[1], "MAPPING_CRANE_UP");
  v331[0] = 54;
  if ( numAlloced >= v160 + 2 )
  {
    v165 = v162;
  }
  else
  {
    numAlloced = 4 * (v160 + 2) / 3 + 3;
    v164 = (MappingPair *)malloc(132 * numAlloced);
    v165 = v164;
    if ( v162 )
    {
      qmemcpy(v164, v162, 132 * v163);
      free(v162);
      v163 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v165;
    CHID::m_MappingPairs.numAlloced = 4 * (v160 + 2) / 3 + 3;
  }
  qmemcpy(&v165[v163], v331, sizeof(MappingPair));
  v166 = v163 + 1;
  CHID::m_MappingPairs.numEntries = v163 + 1;
  strcpy((char *)&v331[1], "MAPPING_CRANE_DOWN");
  v331[0] = 55;
  if ( numAlloced >= v163 + 2 )
  {
    v168 = v165;
  }
  else
  {
    numAlloced = 4 * (v163 + 2) / 3 + 3;
    v167 = (MappingPair *)malloc(132 * numAlloced);
    v168 = v167;
    if ( v165 )
    {
      qmemcpy(v167, v165, 132 * v166);
      free(v165);
      v166 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v168;
    CHID::m_MappingPairs.numAlloced = 4 * (v163 + 2) / 3 + 3;
  }
  qmemcpy(&v168[v166], v331, sizeof(MappingPair));
  v169 = v166 + 1;
  CHID::m_MappingPairs.numEntries = v166 + 1;
  v331[0] = 56;
  strcpy((char *)&v331[1], "MAPPING_ACCEPT");
  if ( numAlloced >= v166 + 2 )
  {
    v171 = v168;
  }
  else
  {
    numAlloced = 4 * (v166 + 2) / 3 + 3;
    v170 = (MappingPair *)malloc(132 * numAlloced);
    v171 = v170;
    if ( v168 )
    {
      qmemcpy(v170, v168, 132 * v169);
      free(v168);
      v169 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v171;
    CHID::m_MappingPairs.numAlloced = 4 * (v166 + 2) / 3 + 3;
  }
  qmemcpy(&v171[v169], v331, sizeof(MappingPair));
  v172 = v169 + 1;
  CHID::m_MappingPairs.numEntries = v169 + 1;
  v331[0] = 57;
  strcpy((char *)&v331[1], "MAPPING_CANCEL");
  if ( numAlloced >= v169 + 2 )
  {
    v174 = v171;
  }
  else
  {
    numAlloced = 4 * (v169 + 2) / 3 + 3;
    v173 = (MappingPair *)malloc(132 * numAlloced);
    v174 = v173;
    if ( v171 )
    {
      qmemcpy(v173, v171, 132 * v172);
      free(v171);
      v172 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v174;
    CHID::m_MappingPairs.numAlloced = 4 * (v169 + 2) / 3 + 3;
  }
  qmemcpy(&v174[v172], v331, sizeof(MappingPair));
  v175 = v172 + 1;
  CHID::m_MappingPairs.numEntries = v172 + 1;
  v331[0] = 58;
  strcpy((char *)&v331[1], "MAPPING_GRAB");
  if ( numAlloced >= v172 + 2 )
  {
    v177 = v174;
  }
  else
  {
    numAlloced = 4 * (v172 + 2) / 3 + 3;
    v176 = (MappingPair *)malloc(132 * numAlloced);
    v177 = v176;
    if ( v174 )
    {
      qmemcpy(v176, v174, 132 * v175);
      free(v174);
      v175 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v177;
    CHID::m_MappingPairs.numAlloced = 4 * (v172 + 2) / 3 + 3;
  }
  qmemcpy(&v177[v175], v331, sizeof(MappingPair));
  v178 = v175 + 1;
  CHID::m_MappingPairs.numEntries = v175 + 1;
  strcpy((char *)&v331[1], "MAPPING_STINGER");
  v331[0] = 59;
  if ( numAlloced >= v175 + 2 )
  {
    v180 = v177;
  }
  else
  {
    numAlloced = 4 * (v175 + 2) / 3 + 3;
    v179 = (MappingPair *)malloc(132 * numAlloced);
    v180 = v179;
    if ( v177 )
    {
      qmemcpy(v179, v177, 132 * v178);
      free(v177);
      v178 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v180;
    CHID::m_MappingPairs.numAlloced = 4 * (v175 + 2) / 3 + 3;
  }
  qmemcpy(&v180[v178], v331, sizeof(MappingPair));
  v181 = v178 + 1;
  CHID::m_MappingPairs.numEntries = v178 + 1;
  strcpy((char *)&v331[1], "MAPPING_MENU_DOWN");
  v331[0] = 60;
  if ( numAlloced >= v178 + 2 )
  {
    v183 = v180;
  }
  else
  {
    numAlloced = 4 * (v178 + 2) / 3 + 3;
    v182 = (MappingPair *)malloc(132 * numAlloced);
    v183 = v182;
    if ( v180 )
    {
      qmemcpy(v182, v180, 132 * v181);
      free(v180);
      v181 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v183;
    CHID::m_MappingPairs.numAlloced = 4 * (v178 + 2) / 3 + 3;
  }
  qmemcpy(&v183[v181], v331, sizeof(MappingPair));
  v184 = v181 + 1;
  CHID::m_MappingPairs.numEntries = v181 + 1;
  strcpy((char *)&v331[1], "MAPPING_MENU_UP");
  v331[0] = 61;
  if ( numAlloced >= v181 + 2 )
  {
    v186 = v183;
  }
  else
  {
    numAlloced = 4 * (v181 + 2) / 3 + 3;
    v185 = (MappingPair *)malloc(132 * numAlloced);
    v186 = v185;
    if ( v183 )
    {
      qmemcpy(v185, v183, 132 * v184);
      free(v183);
      v184 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v186;
    CHID::m_MappingPairs.numAlloced = 4 * (v181 + 2) / 3 + 3;
  }
  qmemcpy(&v186[v184], v331, sizeof(MappingPair));
  v187 = v184 + 1;
  CHID::m_MappingPairs.numEntries = v184 + 1;
  strcpy((char *)&v331[1], "MAPPING_MENU_LEFT");
  v331[0] = 62;
  if ( numAlloced >= v184 + 2 )
  {
    v189 = v186;
  }
  else
  {
    numAlloced = 4 * (v184 + 2) / 3 + 3;
    v188 = (MappingPair *)malloc(132 * numAlloced);
    v189 = v188;
    if ( v186 )
    {
      qmemcpy(v188, v186, 132 * v187);
      free(v186);
      v187 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v189;
    CHID::m_MappingPairs.numAlloced = 4 * (v184 + 2) / 3 + 3;
  }
  qmemcpy(&v189[v187], v331, sizeof(MappingPair));
  v190 = v187 + 1;
  CHID::m_MappingPairs.numEntries = v187 + 1;
  strcpy((char *)&v331[1], "MAPPING_MENU_RIGHT");
  v331[0] = 63;
  if ( numAlloced >= v187 + 2 )
  {
    v192 = v189;
  }
  else
  {
    numAlloced = 4 * (v187 + 2) / 3 + 3;
    v191 = (MappingPair *)malloc(132 * numAlloced);
    v192 = v191;
    if ( v189 )
    {
      qmemcpy(v191, v189, 132 * v190);
      free(v189);
      v190 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v192;
    CHID::m_MappingPairs.numAlloced = 4 * (v187 + 2) / 3 + 3;
  }
  qmemcpy(&v192[v190], v331, sizeof(MappingPair));
  v193 = v190 + 1;
  CHID::m_MappingPairs.numEntries = v190 + 1;
  strcpy((char *)&v331[1], "MAPPING_MENU_ACCEPT");
  v331[0] = 64;
  if ( numAlloced >= v190 + 2 )
  {
    v195 = v192;
  }
  else
  {
    numAlloced = 4 * (v190 + 2) / 3 + 3;
    v194 = (MappingPair *)malloc(132 * numAlloced);
    v195 = v194;
    if ( v192 )
    {
      qmemcpy(v194, v192, 132 * v193);
      free(v192);
      v193 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v195;
    CHID::m_MappingPairs.numAlloced = 4 * (v190 + 2) / 3 + 3;
  }
  qmemcpy(&v195[v193], v331, sizeof(MappingPair));
  v196 = v193 + 1;
  CHID::m_MappingPairs.numEntries = v193 + 1;
  strcpy((char *)&v331[1], "MAPPING_MENU_BACK");
  v331[0] = 65;
  if ( numAlloced >= v193 + 2 )
  {
    v198 = v195;
  }
  else
  {
    numAlloced = 4 * (v193 + 2) / 3 + 3;
    v197 = (MappingPair *)malloc(132 * numAlloced);
    v198 = v197;
    if ( v195 )
    {
      qmemcpy(v197, v195, 132 * v196);
      free(v195);
      v196 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v198;
    CHID::m_MappingPairs.numAlloced = 4 * (v193 + 2) / 3 + 3;
  }
  qmemcpy(&v198[v196], v331, sizeof(MappingPair));
  v199 = v196 + 1;
  CHID::m_MappingPairs.numEntries = v196 + 1;
  strcpy((char *)&v331[1], "MAPPING_MENU_MAP");
  v331[0] = 66;
  if ( numAlloced >= v196 + 2 )
  {
    v201 = v198;
  }
  else
  {
    numAlloced = 4 * (v196 + 2) / 3 + 3;
    v200 = (MappingPair *)malloc(132 * numAlloced);
    v201 = v200;
    if ( v198 )
    {
      qmemcpy(v200, v198, 132 * v199);
      free(v198);
      v199 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v201;
    CHID::m_MappingPairs.numAlloced = 4 * (v196 + 2) / 3 + 3;
  }
  qmemcpy(&v201[v199], v331, sizeof(MappingPair));
  v202 = v199 + 1;
  CHID::m_MappingPairs.numEntries = v199 + 1;
  strcpy((char *)&v331[1], "MAPPING_ARCADE_BUTTON");
  v331[0] = 67;
  if ( numAlloced >= v199 + 2 )
  {
    v204 = v201;
  }
  else
  {
    numAlloced = 4 * (v199 + 2) / 3 + 3;
    v203 = (MappingPair *)malloc(132 * numAlloced);
    v204 = v203;
    if ( v201 )
    {
      qmemcpy(v203, v201, 132 * v202);
      free(v201);
      v202 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v204;
    CHID::m_MappingPairs.numAlloced = 4 * (v199 + 2) / 3 + 3;
  }
  qmemcpy(&v204[v202], v331, sizeof(MappingPair));
  v205 = v202 + 1;
  CHID::m_MappingPairs.numEntries = v202 + 1;
  strcpy((char *)&v331[1], "MAPPING_ARCADE_POWER_OFF");
  v331[0] = 68;
  if ( numAlloced >= v202 + 2 )
  {
    v207 = v204;
  }
  else
  {
    numAlloced = 4 * (v202 + 2) / 3 + 3;
    v206 = (MappingPair *)malloc(132 * numAlloced);
    v207 = v206;
    if ( v204 )
    {
      qmemcpy(v206, v204, 132 * v205);
      free(v204);
      v205 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v207;
    CHID::m_MappingPairs.numAlloced = 4 * (v202 + 2) / 3 + 3;
  }
  qmemcpy(&v207[v205], v331, sizeof(MappingPair));
  v208 = v205 + 1;
  CHID::m_MappingPairs.numEntries = v205 + 1;
  strcpy((char *)&v331[1], "MAPPING_ARCADE_RESET");
  v331[0] = 69;
  if ( numAlloced >= v205 + 2 )
  {
    v210 = v207;
  }
  else
  {
    numAlloced = 4 * (v205 + 2) / 3 + 3;
    v209 = (MappingPair *)malloc(132 * numAlloced);
    v210 = v209;
    if ( v207 )
    {
      qmemcpy(v209, v207, 132 * v208);
      free(v207);
      v208 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v210;
    CHID::m_MappingPairs.numAlloced = 4 * (v205 + 2) / 3 + 3;
  }
  qmemcpy(&v210[v208], v331, sizeof(MappingPair));
  v211 = v208 + 1;
  CHID::m_MappingPairs.numEntries = v208 + 1;
  strcpy((char *)&v331[1], "MAPPING_ARCADE_JOYSTICK");
  v331[0] = 70;
  if ( numAlloced >= v208 + 2 )
  {
    v213 = v210;
  }
  else
  {
    numAlloced = 4 * (v208 + 2) / 3 + 3;
    v212 = (MappingPair *)malloc(132 * numAlloced);
    v213 = v212;
    if ( v210 )
    {
      qmemcpy(v212, v210, 132 * v211);
      free(v210);
      v211 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v213;
    CHID::m_MappingPairs.numAlloced = 4 * (v208 + 2) / 3 + 3;
  }
  qmemcpy(&v213[v211], v331, sizeof(MappingPair));
  v214 = v211 + 1;
  CHID::m_MappingPairs.numEntries = v211 + 1;
  strcpy((char *)&v331[1], "MAPPING_GYM_ACTION");
  v331[0] = 71;
  if ( numAlloced >= v211 + 2 )
  {
    v216 = v213;
  }
  else
  {
    numAlloced = 4 * (v211 + 2) / 3 + 3;
    v215 = (MappingPair *)malloc(132 * numAlloced);
    v216 = v215;
    if ( v213 )
    {
      qmemcpy(v215, v213, 132 * v214);
      free(v213);
      v214 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v216;
    CHID::m_MappingPairs.numAlloced = 4 * (v211 + 2) / 3 + 3;
  }
  qmemcpy(&v216[v214], v331, sizeof(MappingPair));
  v217 = v214 + 1;
  CHID::m_MappingPairs.numEntries = v214 + 1;
  strcpy((char *)&v331[1], "MAPPING_GYM_EASIER_LEVEL");
  v331[0] = 72;
  if ( numAlloced >= v214 + 2 )
  {
    v219 = v216;
  }
  else
  {
    numAlloced = 4 * (v214 + 2) / 3 + 3;
    v218 = (MappingPair *)malloc(132 * numAlloced);
    v219 = v218;
    if ( v216 )
    {
      qmemcpy(v218, v216, 132 * v217);
      free(v216);
      v217 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v219;
    CHID::m_MappingPairs.numAlloced = 4 * (v214 + 2) / 3 + 3;
  }
  qmemcpy(&v219[v217], v331, sizeof(MappingPair));
  v220 = v217 + 1;
  CHID::m_MappingPairs.numEntries = v217 + 1;
  strcpy((char *)&v331[1], "MAPPING_GYM_HARDER_LEVEL");
  v331[0] = 73;
  if ( numAlloced >= v217 + 2 )
  {
    v222 = v219;
  }
  else
  {
    numAlloced = 4 * (v217 + 2) / 3 + 3;
    v221 = (MappingPair *)malloc(132 * numAlloced);
    v222 = v221;
    if ( v219 )
    {
      qmemcpy(v221, v219, 132 * v220);
      free(v219);
      v220 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v222;
    CHID::m_MappingPairs.numAlloced = 4 * (v217 + 2) / 3 + 3;
  }
  qmemcpy(&v222[v220], v331, sizeof(MappingPair));
  v223 = v220 + 1;
  CHID::m_MappingPairs.numEntries = v220 + 1;
  strcpy((char *)&v331[1], "MAPPING_BLACK_JACK_SPLIT");
  v331[0] = 74;
  if ( numAlloced >= v220 + 2 )
  {
    v225 = v222;
  }
  else
  {
    numAlloced = 4 * (v220 + 2) / 3 + 3;
    v224 = (MappingPair *)malloc(132 * numAlloced);
    v225 = v224;
    if ( v222 )
    {
      qmemcpy(v224, v222, 132 * v223);
      free(v222);
      v223 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v225;
    CHID::m_MappingPairs.numAlloced = 4 * (v220 + 2) / 3 + 3;
  }
  qmemcpy(&v225[v223], v331, sizeof(MappingPair));
  v226 = v223 + 1;
  CHID::m_MappingPairs.numEntries = v223 + 1;
  strcpy((char *)&v331[1], "MAPPING_BLACK_JACK_DOUBLE");
  v331[0] = 75;
  if ( numAlloced >= v223 + 2 )
  {
    v228 = v225;
  }
  else
  {
    numAlloced = 4 * (v223 + 2) / 3 + 3;
    v227 = (MappingPair *)malloc(132 * numAlloced);
    v228 = v227;
    if ( v225 )
    {
      qmemcpy(v227, v225, 132 * v226);
      free(v225);
      v226 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v228;
    CHID::m_MappingPairs.numAlloced = 4 * (v223 + 2) / 3 + 3;
  }
  qmemcpy(&v228[v226], v331, sizeof(MappingPair));
  v229 = v226 + 1;
  CHID::m_MappingPairs.numEntries = v226 + 1;
  strcpy((char *)&v331[1], "MAPPING_BLACK_JACK_HIT");
  v331[0] = 76;
  if ( numAlloced >= v226 + 2 )
  {
    v231 = v228;
  }
  else
  {
    numAlloced = 4 * (v226 + 2) / 3 + 3;
    v230 = (MappingPair *)malloc(132 * numAlloced);
    v231 = v230;
    if ( v228 )
    {
      qmemcpy(v230, v228, 132 * v229);
      free(v228);
      v229 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v231;
    CHID::m_MappingPairs.numAlloced = 4 * (v226 + 2) / 3 + 3;
  }
  qmemcpy(&v231[v229], v331, sizeof(MappingPair));
  v232 = v229 + 1;
  CHID::m_MappingPairs.numEntries = v229 + 1;
  strcpy((char *)&v331[1], "MAPPING_BLACK_JACK_STAND");
  v331[0] = 77;
  if ( numAlloced >= v229 + 2 )
  {
    v234 = v231;
  }
  else
  {
    numAlloced = 4 * (v229 + 2) / 3 + 3;
    v233 = (MappingPair *)malloc(132 * numAlloced);
    v234 = v233;
    if ( v231 )
    {
      qmemcpy(v233, v231, 132 * v232);
      free(v231);
      v232 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v234;
    CHID::m_MappingPairs.numAlloced = 4 * (v229 + 2) / 3 + 3;
  }
  qmemcpy(&v234[v232], v331, sizeof(MappingPair));
  v235 = v232 + 1;
  CHID::m_MappingPairs.numEntries = v232 + 1;
  strcpy((char *)&v331[1], "MAPPING_PLACE_BET");
  v331[0] = 78;
  if ( numAlloced >= v232 + 2 )
  {
    v237 = v234;
  }
  else
  {
    numAlloced = 4 * (v232 + 2) / 3 + 3;
    v236 = (MappingPair *)malloc(132 * numAlloced);
    v237 = v236;
    if ( v234 )
    {
      qmemcpy(v236, v234, 132 * v235);
      free(v234);
      v235 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v237;
    CHID::m_MappingPairs.numAlloced = 4 * (v232 + 2) / 3 + 3;
  }
  qmemcpy(&v237[v235], v331, sizeof(MappingPair));
  v238 = v235 + 1;
  CHID::m_MappingPairs.numEntries = v235 + 1;
  strcpy((char *)&v331[1], "MAPPING_REMOVE_BET");
  v331[0] = 79;
  if ( numAlloced >= v235 + 2 )
  {
    v240 = v237;
  }
  else
  {
    numAlloced = 4 * (v235 + 2) / 3 + 3;
    v239 = (MappingPair *)malloc(132 * numAlloced);
    v240 = v239;
    if ( v237 )
    {
      qmemcpy(v239, v237, 132 * v238);
      free(v237);
      v238 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v240;
    CHID::m_MappingPairs.numAlloced = 4 * (v235 + 2) / 3 + 3;
  }
  qmemcpy(&v240[v238], v331, sizeof(MappingPair));
  v241 = v238 + 1;
  CHID::m_MappingPairs.numEntries = v238 + 1;
  qmemcpy(&v331[1], "MAPPING_NEXT_TAR", 16);
  v331[5] = (int)&loc_544544 + 3;
  v331[0] = 80;
  if ( numAlloced >= v238 + 2 )
  {
    v243 = v240;
  }
  else
  {
    numAlloced = 4 * (v238 + 2) / 3 + 3;
    v242 = (MappingPair *)malloc(132 * numAlloced);
    v243 = v242;
    if ( v240 )
    {
      qmemcpy(v242, v240, 132 * v241);
      free(v240);
      v241 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v243;
    CHID::m_MappingPairs.numAlloced = 4 * (v238 + 2) / 3 + 3;
  }
  qmemcpy(&v243[v241], v331, sizeof(MappingPair));
  v244 = v241 + 1;
  CHID::m_MappingPairs.numEntries = v241 + 1;
  qmemcpy(&v331[1], "MAPPING_PREV_TAR", 16);
  v331[5] = (int)&loc_544544 + 3;
  v331[0] = 81;
  if ( numAlloced >= v241 + 2 )
  {
    v246 = v243;
  }
  else
  {
    numAlloced = 4 * (v241 + 2) / 3 + 3;
    v245 = (MappingPair *)malloc(132 * numAlloced);
    v246 = v245;
    if ( v243 )
    {
      qmemcpy(v245, v243, 132 * v244);
      free(v243);
      v244 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v246;
    CHID::m_MappingPairs.numAlloced = 4 * (v241 + 2) / 3 + 3;
  }
  qmemcpy(&v246[v244], v331, sizeof(MappingPair));
  v247 = v244 + 1;
  CHID::m_MappingPairs.numEntries = v244 + 1;
  strcpy((char *)&v331[1], "MAPPING_WAYPOINT_BLIP");
  v331[0] = 82;
  if ( numAlloced >= v244 + 2 )
  {
    v249 = v246;
  }
  else
  {
    numAlloced = 4 * (v244 + 2) / 3 + 3;
    v248 = (MappingPair *)malloc(132 * numAlloced);
    v249 = v248;
    if ( v246 )
    {
      qmemcpy(v248, v246, 132 * v247);
      free(v246);
      v247 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v249;
    CHID::m_MappingPairs.numAlloced = 4 * (v244 + 2) / 3 + 3;
  }
  qmemcpy(&v249[v247], v331, sizeof(MappingPair));
  v250 = v247 + 1;
  CHID::m_MappingPairs.numEntries = v247 + 1;
  strcpy((char *)&v331[1], "MAPPING_HELICOPTER_MAGNET_UP");
  v331[0] = 83;
  if ( numAlloced >= v247 + 2 )
  {
    v252 = v249;
  }
  else
  {
    numAlloced = 4 * (v247 + 2) / 3 + 3;
    v251 = (MappingPair *)malloc(132 * numAlloced);
    v252 = v251;
    if ( v249 )
    {
      qmemcpy(v251, v249, 132 * v250);
      free(v249);
      v250 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v252;
    CHID::m_MappingPairs.numAlloced = 4 * (v247 + 2) / 3 + 3;
  }
  qmemcpy(&v252[v250], v331, sizeof(MappingPair));
  v253 = v250 + 1;
  CHID::m_MappingPairs.numEntries = v250 + 1;
  strcpy((char *)&v331[1], "MAPPING_HELICOPTER_MAGNET_DOWN");
  v331[0] = 84;
  if ( numAlloced >= v250 + 2 )
  {
    v255 = v252;
  }
  else
  {
    numAlloced = 4 * (v250 + 2) / 3 + 3;
    v254 = (MappingPair *)malloc(132 * numAlloced);
    v255 = v254;
    if ( v252 )
    {
      qmemcpy(v254, v252, 132 * v253);
      free(v252);
      v253 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v255;
    CHID::m_MappingPairs.numAlloced = 4 * (v250 + 2) / 3 + 3;
  }
  qmemcpy(&v255[v253], v331, sizeof(MappingPair));
  v256 = v253 + 1;
  CHID::m_MappingPairs.numEntries = v253 + 1;
  strcpy((char *)&v331[1], "MAPPING_LOCK_HYDRAULICS");
  v331[0] = 85;
  if ( numAlloced >= v253 + 2 )
  {
    v258 = v255;
  }
  else
  {
    numAlloced = 4 * (v253 + 2) / 3 + 3;
    v257 = (MappingPair *)malloc(132 * numAlloced);
    v258 = v257;
    if ( v255 )
    {
      qmemcpy(v257, v255, 132 * v256);
      free(v255);
      v256 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v258;
    CHID::m_MappingPairs.numAlloced = 4 * (v253 + 2) / 3 + 3;
  }
  qmemcpy(&v258[v256], v331, sizeof(MappingPair));
  v259 = v256 + 1;
  CHID::m_MappingPairs.numEntries = v256 + 1;
  strcpy((char *)&v331[1], "MAPPING_FLIGHT_ASCEND");
  v331[0] = 86;
  if ( numAlloced >= v256 + 2 )
  {
    v261 = v258;
  }
  else
  {
    numAlloced = 4 * (v256 + 2) / 3 + 3;
    v260 = (MappingPair *)malloc(132 * numAlloced);
    v261 = v260;
    if ( v258 )
    {
      qmemcpy(v260, v258, 132 * v259);
      free(v258);
      v259 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v261;
    CHID::m_MappingPairs.numAlloced = 4 * (v256 + 2) / 3 + 3;
  }
  qmemcpy(&v261[v259], v331, sizeof(MappingPair));
  v262 = v259 + 1;
  CHID::m_MappingPairs.numEntries = v259 + 1;
  strcpy((char *)&v331[1], "MAPPING_FLIGHT_DESCEND");
  v331[0] = 87;
  if ( numAlloced >= v259 + 2 )
  {
    v264 = v261;
  }
  else
  {
    numAlloced = 4 * (v259 + 2) / 3 + 3;
    v263 = (MappingPair *)malloc(132 * numAlloced);
    v264 = v263;
    if ( v261 )
    {
      qmemcpy(v263, v261, 132 * v262);
      free(v261);
      v262 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v264;
    CHID::m_MappingPairs.numAlloced = 4 * (v259 + 2) / 3 + 3;
  }
  qmemcpy(&v264[v262], v331, sizeof(MappingPair));
  v265 = v262 + 1;
  CHID::m_MappingPairs.numEntries = v262 + 1;
  strcpy((char *)&v331[1], "MAPPING_FLIGHT_PRIMARY_ATTACK");
  v331[0] = 88;
  if ( numAlloced >= v262 + 2 )
  {
    v267 = v264;
  }
  else
  {
    numAlloced = 4 * (v262 + 2) / 3 + 3;
    v266 = (MappingPair *)malloc(132 * numAlloced);
    v267 = v266;
    if ( v264 )
    {
      qmemcpy(v266, v264, 132 * v265);
      free(v264);
      v265 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v267;
    CHID::m_MappingPairs.numAlloced = 4 * (v262 + 2) / 3 + 3;
  }
  qmemcpy(&v267[v265], v331, sizeof(MappingPair));
  v268 = v265 + 1;
  CHID::m_MappingPairs.numEntries = v265 + 1;
  strcpy((char *)&v331[1], "MAPPING_FLIGHT_SECONDARY_ATTACK");
  v331[0] = 89;
  if ( numAlloced >= v265 + 2 )
  {
    v270 = v267;
  }
  else
  {
    numAlloced = 4 * (v265 + 2) / 3 + 3;
    v269 = (MappingPair *)malloc(132 * numAlloced);
    v270 = v269;
    if ( v267 )
    {
      qmemcpy(v269, v267, 132 * v268);
      free(v267);
      v268 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v270;
    CHID::m_MappingPairs.numAlloced = 4 * (v265 + 2) / 3 + 3;
  }
  qmemcpy(&v270[v268], v331, sizeof(MappingPair));
  v271 = v268 + 1;
  CHID::m_MappingPairs.numEntries = v268 + 1;
  strcpy((char *)&v331[1], "MAPPING_FLIGHT_ALT_LEFT");
  v331[0] = 90;
  if ( numAlloced >= v268 + 2 )
  {
    v273 = v270;
  }
  else
  {
    numAlloced = 4 * (v268 + 2) / 3 + 3;
    v272 = (MappingPair *)malloc(132 * numAlloced);
    v273 = v272;
    if ( v270 )
    {
      qmemcpy(v272, v270, 132 * v271);
      free(v270);
      v271 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v273;
    CHID::m_MappingPairs.numAlloced = 4 * (v268 + 2) / 3 + 3;
  }
  qmemcpy(&v273[v271], v331, sizeof(MappingPair));
  v274 = v271 + 1;
  CHID::m_MappingPairs.numEntries = v271 + 1;
  strcpy((char *)&v331[1], "MAPPING_FLIGHT_ALT_RIGHT");
  v331[0] = 91;
  if ( numAlloced >= v271 + 2 )
  {
    v276 = v273;
  }
  else
  {
    numAlloced = 4 * (v271 + 2) / 3 + 3;
    v275 = (MappingPair *)malloc(132 * numAlloced);
    v276 = v275;
    if ( v273 )
    {
      qmemcpy(v275, v273, 132 * v274);
      free(v273);
      v274 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v276;
    CHID::m_MappingPairs.numAlloced = 4 * (v271 + 2) / 3 + 3;
  }
  qmemcpy(&v276[v274], v331, sizeof(MappingPair));
  v277 = v274 + 1;
  CHID::m_MappingPairs.numEntries = v274 + 1;
  strcpy((char *)&v331[1], "MAPPING_FLIGHT_ALT_UP");
  v331[0] = 92;
  if ( numAlloced >= v274 + 2 )
  {
    v279 = v276;
  }
  else
  {
    numAlloced = 4 * (v274 + 2) / 3 + 3;
    v278 = (MappingPair *)malloc(132 * numAlloced);
    v279 = v278;
    if ( v276 )
    {
      qmemcpy(v278, v276, 132 * v277);
      free(v276);
      v277 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v279;
    CHID::m_MappingPairs.numAlloced = 4 * (v274 + 2) / 3 + 3;
  }
  qmemcpy(&v279[v277], v331, sizeof(MappingPair));
  v280 = v277 + 1;
  CHID::m_MappingPairs.numEntries = v277 + 1;
  strcpy((char *)&v331[1], "MAPPING_FLIGHT_ALT_DOWN");
  v331[0] = 93;
  if ( numAlloced >= v277 + 2 )
  {
    v282 = v279;
  }
  else
  {
    numAlloced = 4 * (v277 + 2) / 3 + 3;
    v281 = (MappingPair *)malloc(132 * numAlloced);
    v282 = v281;
    if ( v279 )
    {
      qmemcpy(v281, v279, 132 * v280);
      free(v279);
      v280 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v282;
    CHID::m_MappingPairs.numAlloced = 4 * (v277 + 2) / 3 + 3;
  }
  qmemcpy(&v282[v280], v331, sizeof(MappingPair));
  v283 = v280 + 1;
  CHID::m_MappingPairs.numEntries = v280 + 1;
  strcpy((char *)&v331[1], "MAPPING_BASKETBALL_SHOOT");
  v331[0] = 94;
  if ( numAlloced >= v280 + 2 )
  {
    v285 = v282;
  }
  else
  {
    numAlloced = 4 * (v280 + 2) / 3 + 3;
    v284 = (MappingPair *)malloc(132 * numAlloced);
    v285 = v284;
    if ( v282 )
    {
      qmemcpy(v284, v282, 132 * v283);
      free(v282);
      v283 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v285;
    CHID::m_MappingPairs.numAlloced = 4 * (v280 + 2) / 3 + 3;
  }
  qmemcpy(&v285[v283], v331, sizeof(MappingPair));
  v286 = v283 + 1;
  CHID::m_MappingPairs.numEntries = v283 + 1;
  strcpy((char *)&v331[1], "MAPPING_BUNNY_HOP");
  v331[0] = 95;
  if ( numAlloced >= v283 + 2 )
  {
    v288 = v285;
  }
  else
  {
    numAlloced = 4 * (v283 + 2) / 3 + 3;
    v287 = (MappingPair *)malloc(132 * numAlloced);
    v288 = v287;
    if ( v285 )
    {
      qmemcpy(v287, v285, 132 * v286);
      free(v285);
      v286 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v288;
    CHID::m_MappingPairs.numAlloced = 4 * (v283 + 2) / 3 + 3;
  }
  qmemcpy(&v288[v286], v331, sizeof(MappingPair));
  v289 = v286 + 1;
  CHID::m_MappingPairs.numEntries = v286 + 1;
  strcpy((char *)&v331[1], "MAPPING_MAP_ZOOM_IN");
  v331[0] = 96;
  if ( numAlloced >= v286 + 2 )
  {
    v291 = v288;
  }
  else
  {
    numAlloced = 4 * (v286 + 2) / 3 + 3;
    v290 = (MappingPair *)malloc(132 * numAlloced);
    v291 = v290;
    if ( v288 )
    {
      qmemcpy(v290, v288, 132 * v289);
      free(v288);
      v289 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v291;
    CHID::m_MappingPairs.numAlloced = 4 * (v286 + 2) / 3 + 3;
  }
  qmemcpy(&v291[v289], v331, sizeof(MappingPair));
  v292 = v289 + 1;
  CHID::m_MappingPairs.numEntries = v289 + 1;
  strcpy((char *)&v331[1], "MAPPING_MAP_ZOOM_OUT");
  v331[0] = 97;
  if ( numAlloced >= v289 + 2 )
  {
    v294 = v291;
  }
  else
  {
    numAlloced = 4 * (v289 + 2) / 3 + 3;
    v293 = (MappingPair *)malloc(132 * numAlloced);
    v294 = v293;
    if ( v291 )
    {
      qmemcpy(v293, v291, 132 * v292);
      free(v291);
      v292 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v294;
    CHID::m_MappingPairs.numAlloced = 4 * (v289 + 2) / 3 + 3;
  }
  qmemcpy(&v294[v292], v331, sizeof(MappingPair));
  v295 = v292 + 1;
  CHID::m_MappingPairs.numEntries = v292 + 1;
  strcpy((char *)&v331[1], "HID_MAPPING_ALT_ATTACK");
  v331[0] = 98;
  if ( numAlloced >= v292 + 2 )
  {
    v297 = v294;
  }
  else
  {
    numAlloced = 4 * (v292 + 2) / 3 + 3;
    v296 = (MappingPair *)malloc(132 * numAlloced);
    v297 = v296;
    if ( v294 )
    {
      qmemcpy(v296, v294, 132 * v295);
      free(v294);
      v295 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v297;
    CHID::m_MappingPairs.numAlloced = 4 * (v292 + 2) / 3 + 3;
  }
  qmemcpy(&v297[v295], v331, sizeof(MappingPair));
  v298 = v295 + 1;
  CHID::m_MappingPairs.numEntries = v295 + 1;
  strcpy((char *)&v331[1], "HID_MAPPING_BLOCK");
  v331[0] = 99;
  if ( numAlloced >= v295 + 2 )
  {
    v301 = v297;
  }
  else
  {
    v299 = 4 * (v295 + 2) / 3 + 3;
    v300 = (MappingPair *)malloc(132 * v299);
    v301 = v300;
    if ( v297 )
    {
      qmemcpy(v300, v297, 132 * v298);
      free(v297);
      v298 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v301;
    CHID::m_MappingPairs.numAlloced = v299;
  }
  qmemcpy(&v301[v298], v331, sizeof(MappingPair));
  v302 = v298 + 1;
  CHID::m_MappingPairs.numEntries = v298 + 1;
  v303 = CHID::m_MappingPairs.numAlloced;
  strcpy((char *)&v331[1], "HID_MAPPING_TAKE_COVER_LEFT");
  v331[0] = 100;
  if ( CHID::m_MappingPairs.numAlloced >= v298 + 2 )
  {
    v304 = CHID::m_MappingPairs.dataPtr;
  }
  else
  {
    v303 = 4 * (v298 + 2) / 3 + 3;
    v304 = (MappingPair *)malloc(132 * v303);
    v305 = CHID::m_MappingPairs.dataPtr;
    if ( CHID::m_MappingPairs.dataPtr )
    {
      qmemcpy(v304, CHID::m_MappingPairs.dataPtr, 132 * v302);
      free(v305);
      v302 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v304;
    CHID::m_MappingPairs.numAlloced = v303;
  }
  qmemcpy(&v304[v302], v331, sizeof(MappingPair));
  v306 = v302 + 1;
  CHID::m_MappingPairs.numEntries = v302 + 1;
  strcpy((char *)&v331[1], "HID_MAPPING_TAKE_COVER_RIGHT");
  v331[0] = 101;
  if ( v303 >= v302 + 2 )
  {
    v308 = v304;
  }
  else
  {
    v303 = 4 * (v302 + 2) / 3 + 3;
    v307 = (MappingPair *)malloc(132 * v303);
    v308 = v307;
    if ( v304 )
    {
      qmemcpy(v307, v304, 132 * v306);
      free(v304);
      v306 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v308;
    CHID::m_MappingPairs.numAlloced = 4 * (v302 + 2) / 3 + 3;
  }
  qmemcpy(&v308[v306], v331, sizeof(MappingPair));
  v309 = v306 + 1;
  CHID::m_MappingPairs.numEntries = v306 + 1;
  strcpy((char *)&v331[1], "HID_MAPPING_TOGGLE_LANDING_GEAR");
  v331[0] = 102;
  if ( v303 >= v306 + 2 )
  {
    v311 = v308;
  }
  else
  {
    v303 = 4 * (v306 + 2) / 3 + 3;
    v310 = (MappingPair *)malloc(132 * v303);
    v311 = v310;
    if ( v308 )
    {
      qmemcpy(v310, v308, 132 * v309);
      free(v308);
      v309 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v311;
    CHID::m_MappingPairs.numAlloced = 4 * (v306 + 2) / 3 + 3;
  }
  qmemcpy(&v311[v309], v331, sizeof(MappingPair));
  v312 = v309 + 1;
  CHID::m_MappingPairs.numEntries = v309 + 1;
  strcpy((char *)&v331[1], "HID_MAPPING_KISS");
  v331[0] = 103;
  if ( v303 >= v309 + 2 )
  {
    v314 = v311;
  }
  else
  {
    v303 = 4 * (v309 + 2) / 3 + 3;
    v313 = (MappingPair *)malloc(132 * v303);
    v314 = v313;
    if ( v311 )
    {
      qmemcpy(v313, v311, 132 * v312);
      free(v311);
      v312 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v314;
    CHID::m_MappingPairs.numAlloced = 4 * (v309 + 2) / 3 + 3;
  }
  qmemcpy(&v314[v312], v331, sizeof(MappingPair));
  v315 = v312 + 1;
  CHID::m_MappingPairs.numEntries = v312 + 1;
  strcpy((char *)&v331[1], "MAPPING_DANCING_UP");
  v331[0] = 104;
  if ( v303 >= v312 + 2 )
  {
    v317 = v314;
  }
  else
  {
    v303 = 4 * (v312 + 2) / 3 + 3;
    v316 = (MappingPair *)malloc(132 * v303);
    v317 = v316;
    if ( v314 )
    {
      qmemcpy(v316, v314, 132 * v315);
      free(v314);
      v315 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v317;
    CHID::m_MappingPairs.numAlloced = 4 * (v312 + 2) / 3 + 3;
  }
  qmemcpy(&v317[v315], v331, sizeof(MappingPair));
  v318 = v315 + 1;
  CHID::m_MappingPairs.numEntries = v315 + 1;
  strcpy((char *)&v331[1], "MAPPING_DANCING_DOWN");
  v331[0] = 105;
  if ( v303 >= v315 + 2 )
  {
    v320 = v317;
  }
  else
  {
    v303 = 4 * (v315 + 2) / 3 + 3;
    v319 = (MappingPair *)malloc(132 * v303);
    v320 = v319;
    if ( v317 )
    {
      qmemcpy(v319, v317, 132 * v318);
      free(v317);
      v318 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v320;
    CHID::m_MappingPairs.numAlloced = 4 * (v315 + 2) / 3 + 3;
  }
  qmemcpy(&v320[v318], v331, sizeof(MappingPair));
  v321 = v318 + 1;
  CHID::m_MappingPairs.numEntries = v318 + 1;
  strcpy((char *)&v331[1], "MAPPING_DANCING_LEFT");
  v331[0] = 106;
  if ( v303 >= v318 + 2 )
  {
    v323 = v320;
  }
  else
  {
    v303 = 4 * (v318 + 2) / 3 + 3;
    v322 = (MappingPair *)malloc(132 * v303);
    v323 = v322;
    if ( v320 )
    {
      qmemcpy(v322, v320, 132 * v321);
      free(v320);
      v321 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v323;
    CHID::m_MappingPairs.numAlloced = 4 * (v318 + 2) / 3 + 3;
  }
  qmemcpy(&v323[v321], v331, sizeof(MappingPair));
  v324 = v321 + 1;
  CHID::m_MappingPairs.numEntries = v321 + 1;
  strcpy((char *)&v331[1], "MAPPING_DANCING_RIGHT");
  v331[0] = 107;
  if ( v303 >= v321 + 2 )
  {
    v326 = v323;
  }
  else
  {
    v303 = 4 * (v321 + 2) / 3 + 3;
    v325 = (MappingPair *)malloc(132 * v303);
    v326 = v325;
    if ( v323 )
    {
      qmemcpy(v325, v323, 132 * v324);
      free(v323);
      v324 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v326;
    CHID::m_MappingPairs.numAlloced = 4 * (v321 + 2) / 3 + 3;
  }
  qmemcpy(&v326[v324], v331, sizeof(MappingPair));
  v327 = v324 + 1;
  CHID::m_MappingPairs.numEntries = v324 + 1;
  v331[0] = 108;
  strcpy((char *)&v331[1], "MAPPING_REPLAY");
  if ( v303 >= v324 + 2 )
  {
    v330 = v326;
  }
  else
  {
    v328 = 4 * (v324 + 2) / 3 + 3;
    v329 = (MappingPair *)malloc(132 * v328);
    v330 = v329;
    if ( v326 )
    {
      qmemcpy(v329, v326, 132 * v327);
      free(v326);
      v327 = CHID::m_MappingPairs.numEntries;
    }
    CHID::m_MappingPairs.dataPtr = v330;
    CHID::m_MappingPairs.numAlloced = v328;
  }
  qmemcpy(&v330[v327], v331, sizeof(MappingPair));
  CHID::m_MappingPairs.numEntries = v327 + 1;
}
// 662080: using guessed type void *;

//----- (0028C09C) --------------------------------------------------------
HIDMapping __fastcall CHID::GetMappingByName(const unsigned __int8 *pszMapping)
{
  unsigned int numEntries; // r5
  HIDMapping v3; // r4
  unsigned __int8 *i; // r6

  numEntries = CHID::m_MappingPairs.numEntries;
  if ( !CHID::m_MappingPairs.numEntries )
    return 0;
  v3 = HID_MAPPING_UNKNOWN;
  for ( i = CHID::m_MappingPairs.dataPtr->m_szMapping; strcasecmp((const char *)pszMapping, (const char *)i); i += 132 )
  {
    if ( ++v3 >= numEntries )
      return 0;
  }
  return v3;
}

//----- (0028C0E0) --------------------------------------------------------
bool __fastcall CHID::Implements(HIDMapping Mapping)
{
  CHID *v2; // r0

  v2 = CHID::m_pInstance[CHID::currentInstanceIndex];
  if ( v2 )
    return (*(int (__fastcall **)(CHID *, HIDMapping))v2->_vptr$CHID)(v2, Mapping);
  else
    return 0;
}

//----- (0028C10C) --------------------------------------------------------
bool __fastcall CHID::Replaces(HIDMapping Mapping)
{
  CHID *v2; // r0

  v2 = CHID::m_pInstance[CHID::currentInstanceIndex];
  if ( v2 )
    return (*((int (__fastcall **)(CHID *, HIDMapping))v2->_vptr$CHID + 1))(v2, Mapping);
  else
    return 0;
}

//----- (0028C138) --------------------------------------------------------
bool __fastcall CHID::IsDoubleTapped(HIDMapping Mapping)
{
  CHID *v3; // r0

  if ( CHID::m_nDeadFrames <= 0 && (v3 = CHID::m_pInstance[CHID::currentInstanceIndex]) != 0 )
    return (*((int (__fastcall **)(CHID *, HIDMapping))v3->_vptr$CHID + 2))(v3, Mapping);
  else
    return 0;
}

//----- (0028C174) --------------------------------------------------------
int CHID::Use360ClassicVitalStatsHack()
{
  return 0;
}

//----- (0028C178) --------------------------------------------------------
void CHID::Update()
{
  int v0; // r3
  CHID *v1; // r0

  v0 = CHID::m_nDeadFrames - 1;
  if ( CHID::m_nDeadFrames - 1 <= 0 )
    v0 = 0;
  CHID::m_nDeadFrames = v0;
  v1 = CHID::m_pInstance[CHID::currentInstanceIndex];
  if ( v1 )
    (*((void (__fastcall **)(CHID *))v1->_vptr$CHID + 18))(v1);
}

//----- (0028C1B4) --------------------------------------------------------
bool __fastcall CHID::IsJustPressed(HIDMapping Mapping)
{
  CHID *v3; // r0

  if ( CHID::m_nDeadFrames <= 0 && (v3 = CHID::m_pInstance[CHID::currentInstanceIndex]) != 0 )
    return (*((int (__fastcall **)(CHID *, HIDMapping))v3->_vptr$CHID + 3))(v3, Mapping);
  else
    return 0;
}

//----- (0028C1F0) --------------------------------------------------------
bool __fastcall CHID::IsPressed(HIDMapping Mapping, float *pfValueOut)
{
  CHID *v5; // r0

  if ( CHID::m_nDeadFrames <= 0 && (v5 = CHID::m_pInstance[CHID::currentInstanceIndex]) != 0 )
    return (*((int (__fastcall **)(CHID *, HIDMapping, float *))v5->_vptr$CHID + 4))(v5, Mapping, pfValueOut);
  else
    return 0;
}

//----- (0028C22C) --------------------------------------------------------
bool __fastcall CHID::IsReleased(HIDMapping Mapping)
{
  CHID *v3; // r0

  if ( CHID::m_nDeadFrames <= 0 && (v3 = CHID::m_pInstance[CHID::currentInstanceIndex]) != 0 )
    return (*((int (__fastcall **)(CHID *, HIDMapping))v3->_vptr$CHID + 5))(v3, Mapping);
  else
    return 0;
}

//----- (0028C268) --------------------------------------------------------
float __fastcall CHID::GetMappingWeight(HIDMapping Mapping)
{
  CHID *v2; // r0

  v2 = CHID::m_pInstance[CHID::currentInstanceIndex];
  if ( v2 )
    return COERCE_FLOAT((*((int (__fastcall **)(CHID *, HIDMapping))v2->_vptr$CHID + 15))(v2, Mapping));
  else
    return 1.0;
}

//----- (0028C294) --------------------------------------------------------
bool __fastcall CHID::IsReleasedPositive(HIDMapping Mapping)
{
  CHID *v3; // r0

  if ( CHID::m_nDeadFrames <= 0 && (v3 = CHID::m_pInstance[CHID::currentInstanceIndex]) != 0 )
    return (*((int (__fastcall **)(CHID *, HIDMapping))v3->_vptr$CHID + 10))(v3, Mapping);
  else
    return 0;
}

//----- (0028C2D0) --------------------------------------------------------
bool __fastcall CHID::IsReleasedNegative(HIDMapping Mapping)
{
  CHID *v3; // r0

  if ( CHID::m_nDeadFrames <= 0 && (v3 = CHID::m_pInstance[CHID::currentInstanceIndex]) != 0 )
    return (*((int (__fastcall **)(CHID *, HIDMapping))v3->_vptr$CHID + 11))(v3, Mapping);
  else
    return 0;
}

//----- (0028C30C) --------------------------------------------------------
bool __fastcall CHID::IsPressedPositive(HIDMapping Mapping)
{
  CHID *v3; // r0

  if ( CHID::m_nDeadFrames <= 0 && (v3 = CHID::m_pInstance[CHID::currentInstanceIndex]) != 0 )
    return (*((int (__fastcall **)(CHID *, HIDMapping))v3->_vptr$CHID + 12))(v3, Mapping);
  else
    return 0;
}

//----- (0028C348) --------------------------------------------------------
bool __fastcall CHID::IsPressedNegative(HIDMapping Mapping)
{
  CHID *v3; // r0

  if ( CHID::m_nDeadFrames <= 0 && (v3 = CHID::m_pInstance[CHID::currentInstanceIndex]) != 0 )
    return (*((int (__fastcall **)(CHID *, HIDMapping))v3->_vptr$CHID + 13))(v3, Mapping);
  else
    return 0;
}

//----- (0028C384) --------------------------------------------------------
bool __fastcall CHID::MappingIsAnalog(HIDMapping Mapping)
{
  CHID *v2; // r0

  v2 = CHID::m_pInstance[CHID::currentInstanceIndex];
  if ( v2 )
    return (*((int (__fastcall **)(CHID *, HIDMapping))v2->_vptr$CHID + 14))(v2, Mapping);
  else
    return 0;
}

//----- (0028C3B0) --------------------------------------------------------
void __fastcall CHID::DrawHelpIcon(
        const unsigned __int8 *pszCharacters,
        HIDMapping Mapping,
        float fX,
        float fY,
        float fHeight,
        int nAlpha,
        int bNegated)
{
  CHID *v9; // r0

  v9 = CHID::m_pInstance[CHID::currentInstanceIndex];
  if ( v9 )
    (*((void (__fastcall **)(CHID *, const unsigned __int8 *, HIDMapping, _DWORD, _DWORD, _DWORD, int, int))v9->_vptr$CHID
     + 8))(
      v9,
      pszCharacters,
      Mapping,
      LODWORD(fX),
      LODWORD(fY),
      LODWORD(fHeight),
      nAlpha,
      bNegated);
}

//----- (0028C400) --------------------------------------------------------
CSprite2d *__fastcall CHID::GetHelpSprite(
        const unsigned __int8 *pszCharacters,
        HIDMapping Mapping,
        CVector2D *pvecUVLeftTop,
        CVector2D *pvecUVRightBottom)
{
  CHID *v6; // r0

  v6 = CHID::m_pInstance[CHID::currentInstanceIndex];
  if ( v6 )
    return (CSprite2d *)(*((int (__fastcall **)(CHID *, const unsigned __int8 *, HIDMapping, CVector2D *, CVector2D *))v6->_vptr$CHID
                         + 9))(
                          v6,
                          pszCharacters,
                          Mapping,
                          pvecUVLeftTop,
                          pvecUVRightBottom);
  else
    return 0;
}

//----- (0028C444) --------------------------------------------------------
void CHID::FlushQueuedText()
{
  CHID *v0; // r0

  v0 = CHID::m_pInstance[CHID::currentInstanceIndex];
  if ( v0 )
    (*((void (__fastcall **)(CHID *))v0->_vptr$CHID + 16))(v0);
}

//----- (0028C46C) --------------------------------------------------------
void CHID::RemoveQueuedText()
{
  CHID *v0; // r0

  v0 = CHID::m_pInstance[CHID::currentInstanceIndex];
  if ( v0 )
    (*((void (__fastcall **)(CHID *))v0->_vptr$CHID + 17))(v0);
}

//----- (0028C494) --------------------------------------------------------
void CHID::CheckForInputChange()
{
  CHID *v0; // r0
  int v1; // r4
  int v2; // r4
  CHID *v3; // r0
  int v4; // r1
  CHID *v5; // r0
  CHIDKeyboardPC *v6; // r0
  CHID *v7; // r0
  OSKeyboardKey v8; // r5
  int v9; // r0
  bool v10; // zf
  int v11; // r1
  CHID *v12; // r0
  CHIDKeyboardPC *v13; // r0
  CHID *v14; // r0
  int v15; // r0
  CHID *v16; // r0
  int v17; // r1
  CHID *v18; // r0
  CHID *v19; // r0
  CHID *v20; // r0
  CHIDKeyboardPC *v21; // r0
  unsigned int v22; // r8
  _BOOL4 v23; // r5
  _BOOL4 IsConnected; // r0
  CHID *v25; // r1
  OSPointerState v26; // r0
  CHID *v27; // r0
  OSGamepadType v28; // r0
  CHIDJoystickXbox360 *v29; // r0
  CHID *v30; // r0
  CHID *v31; // r0
  CHIDJoystickAmazon *v32; // r0
  CHIDJoystickMogaPocket *v33; // r0
  CHIDJoystickMogaPro *v34; // r0
  CHIDJoystickPS3 *v35; // r0
  CHIDJoystickIOSExtended *v36; // r0
  CHIDJoystickIOSSimple *v37; // r0
  CHIDJoystickAndroidTV *v38; // r0
  CHID *v39; // r0
  int v40; // r1
  CHID *v41; // r0
  OSGamepadType setType[11]; // [sp+3Ch] [bp-2Ch] BYREF

  v0 = CHID::m_pInstance[CHID::currentInstanceIndex];
  if ( !v0
    || !(*((int (__fastcall **)(CHID *))v0->_vptr$CHID + 6))(v0)
    || !CHID::bAllowKeyboardInstance
    || OS_PointerGetNumber() < 2 )
  {
LABEL_8:
    v2 = 0;
    v3 = CHID::m_pInstance[CHID::currentInstanceIndex];
    if ( v3 && (*((int (__fastcall **)(CHID *))v3->_vptr$CHID + 6))(v3) == 2 )
      v2 = 1;
    if ( !v2
      && CHID::bAllowKeyboardInstance
      && (LIB_PointerGetButton(0, 0) == OSPS_ButtonPressed && OS_PointerGetType(0) == OSPD_Mouse
       || LIB_PointerGetButton(1, 0) == OSPS_ButtonPressed && OS_PointerGetType(1) == OSPD_Mouse
       || LIB_PointerGetButton(2, 0) == OSPS_ButtonPressed && OS_PointerGetType(2) == OSPD_Mouse
       || LIB_PointerGetButton(3, 0) == OSPS_ButtonPressed && OS_PointerGetType(3) == OSPD_Mouse) )
    {
      v4 = CHID::currentInstanceIndex;
      v5 = CHID::m_pInstance[CHID::currentInstanceIndex];
      if ( v5 )
      {
        (*((void (__fastcall **)(CHID *))v5->_vptr$CHID + 20))(v5);
        v4 = CHID::currentInstanceIndex;
        CHID::m_pInstance[CHID::currentInstanceIndex] = 0;
      }
      CHID::m_GamepadType[v4] = -1;
      v6 = (CHIDKeyboardPC *)operator new(0x978u);
      CHIDKeyboardPC::CHIDKeyboardPC(v6, "ButtonsKeyboard");
      CHID::m_pInstance[CHID::currentInstanceIndex] = v7;
    }
    v8 = KK_ESCAPE;
    while ( !LIB_KeyboardPressed(v8) )
    {
LABEL_47:
      if ( ++v8 == KK_MAX )
      {
        v22 = 0;
        while ( 1 )
        {
          setType[0] = -1;
          IsConnected = OS_GamepadIsConnected(v22, setType);
          v25 = CHID::m_pInstance[v22];
          if ( IsConnected )
            break;
          if ( v25 )
          {
            if ( !OS_GamepadIsConnected(v22, setType) && CHID::m_GamepadType[v22] != -1 )
            {
              v31 = CHID::m_pInstance[v22];
              if ( v31 )
              {
                (*((void (__fastcall **)(CHID *))v31->_vptr$CHID + 20))(v31);
                CHID::m_pInstance[v22] = 0;
              }
              CHID::m_GamepadType[v22] = -1;
            }
            goto LABEL_96;
          }
LABEL_98:
          if ( ++v22 == 4 )
            return;
        }
        if ( !v25 || setType[0] != CHID::m_GamepadType[v22] )
        {
          v23 = COERCE_FLOAT(COERCE_UNSIGNED_INT(OS_GamepadAxis(v22, 0x40u)) & 0x7FFFFFFF) > 0.75
             || COERCE_FLOAT(COERCE_UNSIGNED_INT(OS_GamepadAxis(v22, 0x41u)) & 0x7FFFFFFF) > 0.75
             || COERCE_FLOAT(COERCE_UNSIGNED_INT(OS_GamepadAxis(v22, 0x42u)) & 0x7FFFFFFF) > 0.75
             || COERCE_FLOAT(COERCE_UNSIGNED_INT(OS_GamepadAxis(v22, 0x43u)) & 0x7FFFFFFF) > 0.75
             || COERCE_FLOAT(COERCE_UNSIGNED_INT(OS_GamepadAxis(v22, 0x44u)) & 0x7FFFFFFF) > 0.75
             || COERCE_FLOAT(COERCE_UNSIGNED_INT(OS_GamepadAxis(v22, 0x45u)) & 0x7FFFFFFF) > 0.75;
          v26 = LIB_GamepadState(v22, 0);
          if ( v23
            || (v26 | 1) == 3
            || (LIB_GamepadState(v22, 1) | 1) == 3
            || (LIB_GamepadState(v22, 2) | 1) == 3
            || (LIB_GamepadState(v22, 3) | 1) == 3
            || (LIB_GamepadState(v22, 4) | 1) == 3
            || (LIB_GamepadState(v22, 5) | 1) == 3
            || (LIB_GamepadState(v22, 6) | 1) == 3
            || (LIB_GamepadState(v22, 7) | 1) == 3
            || (LIB_GamepadState(v22, 8) | 1) == 3
            || (LIB_GamepadState(v22, 9) | 1) == 3
            || (LIB_GamepadState(v22, 10) | 1) == 3
            || (LIB_GamepadState(v22, 11) | 1) == 3
            || (LIB_GamepadState(v22, 12) | 1) == 3
            || (LIB_GamepadState(v22, 13) | 1) == 3
            || (LIB_GamepadState(v22, 14) | 1) == 3
            || (LIB_GamepadState(v22, 15) | 1) == 3 )
          {
            v27 = CHID::m_pInstance[v22];
            if ( v27 )
            {
              (*((void (__fastcall **)(CHID *))v27->_vptr$CHID + 20))(v27);
              CHID::m_pInstance[v22] = 0;
            }
            v28 = setType[0];
            switch ( setType[0] )
            {
              case OSGT_Xbox360:
              case OSGT_Generic:
              case OSGT_Nyko:
                v29 = (CHIDJoystickXbox360 *)operator new(0x18u);
                CHIDJoystickXbox360::CHIDJoystickXbox360(v29, "ButtonsXbox360");
                goto LABEL_94;
              case OSGT_Moga:
                v33 = (CHIDJoystickMogaPocket *)operator new(0x18u);
                CHIDJoystickMogaPocket::CHIDJoystickMogaPocket(v33, "ButtonsMogaPocket");
                goto LABEL_94;
              case OSGT_MogaPro:
                v34 = (CHIDJoystickMogaPro *)operator new(0x18u);
                CHIDJoystickMogaPro::CHIDJoystickMogaPro(v34, "ButtonsMogaPro");
                goto LABEL_94;
              case OSGT_PS3:
                v35 = (CHIDJoystickPS3 *)operator new(0x18u);
                CHIDJoystickPS3::CHIDJoystickPS3(v35, "ButtonsPS3");
                goto LABEL_94;
              case OSGT_IOSExtended:
                v36 = (CHIDJoystickIOSExtended *)operator new(0x18u);
                CHIDJoystickIOSExtended::CHIDJoystickIOSExtended(v36, "ButtonsMoga");
                goto LABEL_94;
              case OSGT_IOSSimple:
                v37 = (CHIDJoystickIOSSimple *)operator new(0x18u);
                CHIDJoystickIOSSimple::CHIDJoystickIOSSimple(v37, "ButtonsIOSSimple");
                goto LABEL_94;
              case OSGT_AmazonRemote:
              case OSGT_AmazonGamepad:
                v32 = (CHIDJoystickAmazon *)operator new(0x18u);
                CHIDJoystickAmazon::CHIDJoystickAmazon(v32, "ButtonsXbox360");
                goto LABEL_94;
              case OSGT_AndroidTV:
                v38 = (CHIDJoystickAndroidTV *)operator new(0x18u);
                CHIDJoystickAndroidTV::CHIDJoystickAndroidTV(v38, "ButtonsXbox360");
LABEL_94:
                CHID::m_pInstance[v22] = v30;
                v28 = setType[0];
                break;
              default:
                break;
            }
            CHID::m_GamepadType[v22] = v28;
          }
        }
LABEL_96:
        v39 = CHID::m_pInstance[v22];
        if ( v39 )
          (*((void (__fastcall **)(CHID *, unsigned int))v39->_vptr$CHID + 7))(v39, v22);
        goto LABEL_98;
      }
    }
    if ( (unsigned int)(v8 - 11) > 1 )
    {
      if ( (unsigned int)v8 > KK_BACKSPACE || ((1 << v8) & 0x4000003) == 0 )
      {
        v20 = CHID::m_pInstance[CHID::currentInstanceIndex];
        if ( v20 )
          v9 = (*((int (__fastcall **)(CHID *))v20->_vptr$CHID + 6))(v20);
        else
          v9 = 0;
        v10 = v9 == 2;
        if ( v9 != 2 )
          v10 = !CHID::bAllowKeyboardInstance;
        if ( !v10 )
        {
          v11 = CHID::currentInstanceIndex;
          v12 = CHID::m_pInstance[CHID::currentInstanceIndex];
          if ( v12 )
          {
            (*((void (__fastcall **)(CHID *))v12->_vptr$CHID + 20))(v12);
            v11 = CHID::currentInstanceIndex;
            CHID::m_pInstance[CHID::currentInstanceIndex] = 0;
          }
          CHID::m_GamepadType[v11] = -1;
          v13 = (CHIDKeyboardPC *)operator new(0x978u);
          CHIDKeyboardPC::CHIDKeyboardPC(v13, "ButtonsKeyboard");
          CHID::m_pInstance[CHID::currentInstanceIndex] = v14;
        }
      }
      goto LABEL_47;
    }
    v15 = CHID::currentInstanceIndex;
    CHID::m_GamepadType[CHID::currentInstanceIndex] = -1;
    v16 = CHID::m_pInstance[v15];
    if ( v16 )
    {
      v17 = (*((int (__fastcall **)(CHID *))v16->_vptr$CHID + 6))(v16);
      v18 = CHID::m_pInstance[CHID::currentInstanceIndex];
      if ( v17 == 2 )
      {
        if ( !v18 )
        {
LABEL_46:
          CHID::bAllowKeyboardInstance = 0;
          goto LABEL_47;
        }
        (*((void (__fastcall **)(CHID *))v18->_vptr$CHID + 20))(v18);
        v19 = 0;
LABEL_45:
        CHID::m_pInstance[CHID::currentInstanceIndex] = v19;
        goto LABEL_46;
      }
      if ( v18 )
      {
        (*((void (__fastcall **)(CHID *))v18->_vptr$CHID + 20))(v18);
        CHID::m_pInstance[CHID::currentInstanceIndex] = 0;
      }
    }
    v21 = (CHIDKeyboardPC *)operator new(0x978u);
    CHIDKeyboardPC::CHIDKeyboardPC(v21, "ButtonsKeyboard");
    goto LABEL_45;
  }
  v1 = 1;
  while ( LIB_PointerGetButton(v1, 0) != OSPS_ButtonPressed )
  {
    if ( ++v1 >= OS_PointerGetNumber() )
      goto LABEL_8;
  }
  v40 = CHID::currentInstanceIndex;
  v41 = CHID::m_pInstance[CHID::currentInstanceIndex];
  if ( v41 )
  {
    (*((void (__fastcall **)(CHID *))v41->_vptr$CHID + 20))(v41);
    v40 = CHID::currentInstanceIndex;
    CHID::m_pInstance[CHID::currentInstanceIndex] = 0;
  }
  CHID::m_GamepadType[v40] = -1;
}
// 28C5EA: variable 'v7' is possibly undefined
// 28C702: variable 'v14' is possibly undefined
// 28C79E: variable 'v19' is possibly undefined
// 28CAD0: variable 'v30' is possibly undefined

//----- (0028CC74) --------------------------------------------------------
int CHID::GetInputType()
{
  CHID *v0; // r0

  v0 = CHID::m_pInstance[CHID::currentInstanceIndex];
  if ( v0 )
    return (*((int (__fastcall **)(CHID *))v0->_vptr$CHID + 6))(v0);
  else
    return 0;
}

//----- (0028CC9C) --------------------------------------------------------
void __fastcall OSArray<MappingPair>::~OSArray(OSArray<MappingPair> *this)
{
  MappingPair *dataPtr; // r0

  dataPtr = this->dataPtr;
  this->numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->dataPtr = 0;
  }
  this->numAlloced = 0;
}

//----- (0028CCBA) --------------------------------------------------------
CSprite2d *__fastcall CHID::InternalGetHelpSprite(
        CHID *this,
        const unsigned __int8 *pszCharacters,
        HIDMapping Mapping,
        CVector2D *pvecUVLeftTop,
        CVector2D *pvecUVRightBottom)
{
  return 0;
}

//----- (0028CCBE) --------------------------------------------------------
bool __fastcall CHID::InternalIsReleasedPositive(CHID *this, HIDMapping Mapping)
{
  return 0;
}

//----- (0028CCC2) --------------------------------------------------------
bool __fastcall CHID::InternalIsReleasedNegative(CHID *this, HIDMapping Mapping)
{
  return 0;
}

//----- (0028CCC6) --------------------------------------------------------
bool __fastcall CHID::InternalIsPressedPositive(CHID *this, HIDMapping Mapping)
{
  return 0;
}

//----- (0028CCCA) --------------------------------------------------------
bool __fastcall CHID::InternalIsPressedNegative(CHID *this, HIDMapping Mapping)
{
  return 0;
}

//----- (0028CCCE) --------------------------------------------------------
bool __fastcall CHID::InternalMappingIsAnalog(CHID *this, HIDMapping Mapping)
{
  return 0;
}

//----- (0028CCD2) --------------------------------------------------------
float __fastcall CHID::InternalGetMappingWeight(CHID *this, HIDMapping Mapping)
{
  return 1.0;
}

//----- (0028CCE8) --------------------------------------------------------
void __fastcall CHIDJoystick::CHIDJoystick(CHIDJoystick *this, const unsigned __int8 *pszIconSprite)
{
  TextureDatabaseRuntime *TextureDB; // r8

  CHID::CHID(this);
  this->_vptr$CHID = (int (**)(void))&off_6620DC;
  this->m_Mappings.numAlloced = 0;
  this->m_Mappings.numEntries = 0;
  this->m_Mappings.dataPtr = 0;
  CSprite2d::CSprite2d(&this->m_Sprite);
  CHIDJoystick::m_bInstanceEverCreated = 1;
  if ( pszIconSprite )
  {
    TextureDB = CTouchInterface::LoadTextureDB();
    CSprite2d::SetTexture(&this->m_Sprite, (unsigned __int8 *)pszIconSprite);
    CTouchInterface::UnloadTextureDB(TextureDB);
  }
  this->m_bContextButtonActive = 0;
}
// 6620DC: using guessed type void *;

//----- (0028CD50) --------------------------------------------------------
void __fastcall CHIDJoystick::InternalDrawHelpIcon(
        CHIDJoystick *this,
        const unsigned __int8 *pszCharacters,
        HIDMapping Mapping,
        float fX,
        float fY,
        float fHeight,
        int nAlpha,
        int bNegated)
{
  CSprite2d *p_m_Sprite; // r4
  CRGBA v10; // [sp+1Ch] [bp-4Ch] BYREF
  CRect Rectangle; // [sp+20h] [bp-48h] BYREF
  float v12; // [sp+30h] [bp-38h] BYREF
  float v13; // [sp+34h] [bp-34h]
  float v14; // [sp+38h] [bp-30h]
  float v15; // [sp+3Ch] [bp-2Ch]

  p_m_Sprite = &this->m_Sprite;
  if ( this->m_Sprite.mpTexture )
  {
    (*((void (__fastcall **)(float *, CHIDJoystick *, const unsigned __int8 *, HIDMapping, int))this->_vptr$CHID + 21))(
      &v12,
      this,
      pszCharacters,
      Mapping,
      bNegated);
    Rectangle.bottom = fY;
    Rectangle.left = fX;
    Rectangle.right = fX + fHeight;
    Rectangle.top = fY + fHeight;
    CRGBA::CRGBA(&v10, 0xC0u, 0xC0u, 0xC0u, nAlpha);
    CSprite2d::Draw(p_m_Sprite, &Rectangle, &v10, v12, v15, v14, v15, v12, v13, v14, v13);
  }
}

//----- (0028CDFA) --------------------------------------------------------
CSprite2d *__fastcall CHIDJoystick::InternalGetHelpSprite(
        CHIDJoystick *this,
        const unsigned __int8 *pszCharacters,
        HIDMapping Mapping,
        CVector2D *pvecUVLeftTop,
        CVector2D *pvecUVRightBottom)
{
  float v7; // r2
  float v8; // r1
  int v10[6]; // [sp+8h] [bp-18h] BYREF

  (*((void (__fastcall **)(int *, CHIDJoystick *, const unsigned __int8 *, HIDMapping, _DWORD))this->_vptr$CHID + 21))(
    v10,
    this,
    pszCharacters,
    Mapping,
    0);
  if ( pvecUVLeftTop )
  {
    v7 = *(float *)&v10[3];
    LODWORD(pvecUVLeftTop->x) = v10[0];
    pvecUVLeftTop->y = v7;
  }
  if ( pvecUVRightBottom )
  {
    v8 = *(float *)&v10[1];
    LODWORD(pvecUVRightBottom->x) = v10[2];
    pvecUVRightBottom->y = v8;
  }
  return &this->m_Sprite;
}

//----- (0028CE3A) --------------------------------------------------------
bool __fastcall CHIDJoystick::InternalImplements(CHIDJoystick *this, HIDMapping Mapping)
{
  unsigned int numEntries; // r12
  unsigned int v4; // r3
  HIDMapping *p_mapping; // r0

  numEntries = this->m_Mappings.numEntries;
  if ( !numEntries )
    return 0;
  v4 = 0;
  p_mapping = &this->m_Mappings.dataPtr->mapping;
  do
  {
    if ( *p_mapping == Mapping )
      return 1;
    ++v4;
    p_mapping += 5;
  }
  while ( v4 < numEntries );
  return 0;
}

//----- (0028CE68) --------------------------------------------------------
bool __fastcall CHIDJoystick::InternalReplaces(CHIDJoystick *this, HIDMapping Mapping)
{
  bool result; // r0

  if ( CCheat::m_bShowMappings )
    return 0;
  switch ( Mapping )
  {
    case HID_MAPPING_RADIO_PREV_STATION:
    case HID_MAPPING_RADIO_NEXT_STATION:
    case HID_MAPPING_VITAL_STATS:
    case HID_MAPPING_NEXT_WEAPON:
    case HID_MAPPING_RADAR:
    case HID_MAPPING_MISSION_START_AND_CANCEL:
    case HID_MAPPING_WEAPON_ZOOM_IN:
    case HID_MAPPING_WEAPON_ZOOM_OUT:
    case HID_MAPPING_MAGNET:
    case HID_MAPPING_SKIP_CUTSCENE:
    case HID_MAPPING_GANG_RECRUIT:
    case HID_MAPPING_GANG_IGNORE:
    case HID_MAPPING_GANG_FOLLOW:
    case HID_MAPPING_GANG_HOLD_POSITION:
    case HID_MAPPING_DROP_CRANE:
    case HID_MAPPING_ACCEPT:
    case HID_MAPPING_CANCEL:
    case HID_MAPPING_GRAB:
    case HID_MAPPING_STINGER:
    case HID_MAPPING_MENU_LEFT:
    case HID_MAPPING_MENU_RIGHT:
    case HID_MAPPING_MENU_ACCEPT:
    case HID_MAPPING_MENU_BACK:
    case HID_MAPPING_GYM_ACTION:
    case HID_MAPPING_GYM_EASIER_LEVEL:
    case HID_MAPPING_GYM_HARDER_LEVEL:
    case HID_MAPPING_BLACK_JACK_SPLIT:
    case HID_MAPPING_BLACK_JACK_DOUBLE:
    case HID_MAPPING_BLACK_JACK_HIT:
    case HID_MAPPING_BLACK_JACK_STAND:
    case HID_MAPPING_PLACE_BET:
    case HID_MAPPING_REMOVE_BET:
    case HID_MAPPING_HELICOPTER_MAGNET_UP:
    case HID_MAPPING_HELICOPTER_MAGNET_DOWN:
      return 0;
    default:
      result = ((int (__fastcall *)(CHIDJoystick *))*this->_vptr$CHID)(this);
      break;
  }
  return result;
}

//----- (0028CEDC) --------------------------------------------------------
void __fastcall CHIDJoystick::InternalCacheAnalogValues(CHIDJoystick *this, unsigned int gamepadIndex)
{
  int v4; // r6
  unsigned int v5; // r4
  int nButtonID; // r1
  float v7; // s0
  JoystickButtonMapping *dataPtr; // r0
  JoystickButtonMapping *v9; // r0
  float v10; // s0
  JoystickButtonMapping *v11; // r0

  if ( this->m_Mappings.numEntries )
  {
    v4 = 0;
    v5 = 0;
    do
    {
      nButtonID = this->m_Mappings.dataPtr[v4].nButtonID;
      if ( nButtonID <= 15 && LIB_GamepadState(gamepadIndex, nButtonID) == OSPS_ButtonReleased )
      {
        v7 = OS_TimeAccurate();
        this->m_Mappings.dataPtr[v4].fLastReleaseTime = v7;
      }
      dataPtr = this->m_Mappings.dataPtr;
      if ( dataPtr[v4].nButtonID >= 16 )
      {
        dataPtr[v4].bAnalogPressedThisFrame = 0;
        this->m_Mappings.dataPtr[v4].bAnalogReleasedThisFrame = 0;
        v9 = this->m_Mappings.dataPtr;
        if ( v9[v4].fLastAnalogValue > 0.5 && OS_GamepadAxis(gamepadIndex, v9[v4].nButtonID) < 0.5 )
        {
          v10 = OS_TimeAccurate();
          this->m_Mappings.dataPtr[v4].fLastReleaseTime = v10;
          this->m_Mappings.dataPtr[v4].bAnalogReleasedThisFrame = 1;
        }
        v11 = this->m_Mappings.dataPtr;
        if ( v11[v4].fLastAnalogValue < 0.5 && OS_GamepadAxis(gamepadIndex, v11[v4].nButtonID) > 0.5 )
          this->m_Mappings.dataPtr[v4].bAnalogPressedThisFrame = 1;
        this->m_Mappings.dataPtr[v4].fLastAnalogValue = OS_GamepadAxis(
                                                          gamepadIndex,
                                                          this->m_Mappings.dataPtr[v4].nButtonID);
      }
      ++v5;
      ++v4;
    }
    while ( v5 < this->m_Mappings.numEntries );
  }
}

//----- (0028CFD8) --------------------------------------------------------
bool __fastcall CHIDJoystick::InternalIsDoubleTapped(CHIDJoystick *this, HIDMapping Mapping)
{
  int v4; // r6
  unsigned int v5; // r4
  JoystickButtonMapping *dataPtr; // r2
  int nButtonID; // r1
  double v8; // r0
  signed int v9; // r1

  if ( !this->m_Mappings.numEntries )
    return 0;
  v4 = 0;
  v5 = 0;
  while ( 1 )
  {
    dataPtr = this->m_Mappings.dataPtr;
    if ( dataPtr[v4].mapping == Mapping )
    {
      nButtonID = dataPtr[v4].nButtonID;
      if ( nButtonID <= 15 )
      {
        if ( LIB_GamepadState(CHID::currentInstanceIndex, nButtonID) )
        {
          dataPtr = this->m_Mappings.dataPtr;
        }
        else
        {
          v8 = OS_TimeAccurate();
          dataPtr = this->m_Mappings.dataPtr;
          if ( v8 - dataPtr[v4].fLastReleaseTime < 0.330000013 )
            return 1;
        }
      }
      v9 = dataPtr[v4].nButtonID;
      if ( v9 >= 16
        && dataPtr[v4].fLastAnalogValue > 0.5
        && OS_GamepadAxis(CHID::currentInstanceIndex, v9) < 0.5
        && OS_TimeAccurate() - this->m_Mappings.dataPtr[v4].fLastReleaseTime < 0.330000013 )
      {
        break;
      }
    }
    ++v5;
    ++v4;
    if ( v5 >= this->m_Mappings.numEntries )
      return 0;
  }
  return 1;
}

//----- (0028D0C8) --------------------------------------------------------
bool __fastcall CHIDJoystick::InternalIsJustPressed(CHIDJoystick *this, HIDMapping Mapping)
{
  unsigned int numEntries; // r0
  int v5; // r6
  unsigned int i; // r4
  JoystickButtonMapping *dataPtr; // r1
  JoystickButtonMapping *v8; // r2
  int nButtonID; // r1
  bool v10; // r0
  char v11; // r1
  bool bAnalogPressedThisFrame; // r0

  numEntries = this->m_Mappings.numEntries;
  if ( numEntries )
  {
    v5 = 0;
    for ( i = 0; i < numEntries; ++i )
    {
      dataPtr = this->m_Mappings.dataPtr;
      v8 = &dataPtr[v5];
      if ( dataPtr[v5].mapping == Mapping )
      {
        nButtonID = dataPtr[v5].nButtonID;
        if ( nButtonID > 15 )
        {
          bAnalogPressedThisFrame = v8->bAnalogPressedThisFrame;
          v11 = 1;
          v10 = bAnalogPressedThisFrame;
          return v10 & v11;
        }
        if ( LIB_GamepadState(CHID::currentInstanceIndex, nButtonID) == OSPS_ButtonPressed )
        {
          v11 = 1;
          v10 = 1;
          return v10 & v11;
        }
        numEntries = this->m_Mappings.numEntries;
      }
      ++v5;
    }
  }
  v10 = 1;
  v11 = 0;
  return v10 & v11;
}

//----- (0028D12C) --------------------------------------------------------
bool __fastcall CHIDJoystick::InternalIsPressed(CHIDJoystick *this, HIDMapping Mapping, float *pfValueOut)
{
  unsigned int numEntries; // r0
  int v7; // r6
  unsigned int i; // r5
  JoystickButtonMapping *dataPtr; // r1
  int nButtonID; // r1
  __int32 v11; // r0
  float v12; // s0
  bool v13; // r5
  unsigned int v15; // r0
  int v16; // r2
  HIDMapping *j; // r1

  numEntries = this->m_Mappings.numEntries;
  if ( numEntries )
  {
    v7 = 0;
    for ( i = 0; i < numEntries; ++i )
    {
      dataPtr = this->m_Mappings.dataPtr;
      if ( dataPtr[v7].mapping == Mapping )
      {
        nButtonID = dataPtr[v7].nButtonID;
        if ( nButtonID > 15 )
        {
          if ( pfValueOut )
          {
            *pfValueOut = OS_GamepadAxis(CHID::currentInstanceIndex, nButtonID);
            nButtonID = this->m_Mappings.dataPtr[v7].nButtonID;
          }
          return COERCE_FLOAT(COERCE_UNSIGNED_INT(OS_GamepadAxis(CHID::currentInstanceIndex, nButtonID)) & 0x7FFFFFFF) > 0.1;
        }
        v11 = LIB_GamepadState(CHID::currentInstanceIndex, nButtonID) | 1;
        if ( pfValueOut )
        {
          v12 = 0.0;
          if ( v11 == 3 )
            v12 = 1.0;
          *pfValueOut = v12;
        }
        if ( v11 == 3 )
          return 1;
        numEntries = this->m_Mappings.numEntries;
      }
      ++v7;
    }
  }
  if ( OS_GetDeviceInfo(1) )
    return 0;
  v15 = this->m_Mappings.numEntries;
  if ( !v15 )
    return 0;
  v16 = 0;
  for ( j = &this->m_Mappings.dataPtr->mapping; *j != Mapping; j += 5 )
  {
    if ( ++v16 >= v15 )
      return 0;
  }
  if ( *((_DWORD *)j - 1) != 4 )
    return 0;
  v13 = 1;
  if ( !LIB_KeyboardIsDown(KK_F1) )
    return 0;
  this->m_bContextButtonActive = 1;
  return v13;
}

//----- (0028D23C) --------------------------------------------------------
int __fastcall CHIDJoystick::GetButtonID(CHIDJoystick *this, HIDMapping Mapping)
{
  unsigned int numEntries; // r12
  unsigned int v4; // r3
  HIDMapping *p_mapping; // r0

  numEntries = this->m_Mappings.numEntries;
  if ( !numEntries )
    return -1;
  v4 = 0;
  p_mapping = &this->m_Mappings.dataPtr->mapping;
  do
  {
    if ( *p_mapping == Mapping )
      return *((_DWORD *)p_mapping - 1);
    ++v4;
    p_mapping += 5;
  }
  while ( v4 < numEntries );
  return -1;
}

//----- (0028D270) --------------------------------------------------------
bool __fastcall CHIDJoystick::InternalIsReleased(CHIDJoystick *this, HIDMapping Mapping)
{
  unsigned int numEntries; // r0
  int v5; // r6
  unsigned int i; // r5
  JoystickButtonMapping *dataPtr; // r1
  JoystickButtonMapping *v8; // r2
  int nButtonID; // r1
  bool result; // r0
  unsigned int v11; // r0
  int v12; // r2
  HIDMapping *j; // r1

  numEntries = this->m_Mappings.numEntries;
  if ( numEntries )
  {
    v5 = 0;
    for ( i = 0; i < numEntries; ++i )
    {
      dataPtr = this->m_Mappings.dataPtr;
      v8 = &dataPtr[v5];
      if ( dataPtr[v5].mapping == Mapping )
      {
        nButtonID = dataPtr[v5].nButtonID;
        if ( nButtonID > 15 )
          return v8->bAnalogReleasedThisFrame;
        if ( LIB_GamepadState(CHID::currentInstanceIndex, nButtonID) == OSPS_ButtonReleased )
          return 1;
        numEntries = this->m_Mappings.numEntries;
      }
      ++v5;
    }
  }
  if ( OS_GetDeviceInfo(1) )
    return 0;
  v11 = this->m_Mappings.numEntries;
  if ( !v11 )
    return 0;
  v12 = 0;
  for ( j = &this->m_Mappings.dataPtr->mapping; *j != Mapping; j += 5 )
  {
    if ( ++v12 >= v11 )
      return 0;
  }
  if ( *((_DWORD *)j - 1) != 4 || LIB_KeyboardIsDown(KK_F1) )
    return 0;
  result = 0;
  if ( this->m_bContextButtonActive )
  {
    this->m_bContextButtonActive = 0;
    return 1;
  }
  return result;
}

//----- (0028D314) --------------------------------------------------------
bool __fastcall CHIDJoystick::InternalIsReleasedNegative(CHIDJoystick *this, HIDMapping Mapping)
{
  unsigned int numEntries; // r3
  int v3; // r4
  float *i; // r0
  bool v6; // r4

  numEntries = this->m_Mappings.numEntries;
  if ( !numEntries )
    return 0;
  v3 = 0;
  for ( i = &this->m_Mappings.dataPtr->fLastAnalogValue; *((_DWORD *)i - 2) != Mapping || *((int *)i - 3) < 16; i += 5 )
  {
    if ( ++v3 >= numEntries )
      return 0;
  }
  v6 = 0;
  if ( *i >= -0.5 )
    return 0;
  if ( COERCE_FLOAT(COERCE_UNSIGNED_INT(OS_GamepadAxis(CHID::currentInstanceIndex, *((_DWORD *)i - 3))) & 0x7FFFFFFF) < 0.5 )
    return 1;
  return v6;
}

//----- (0028D384) --------------------------------------------------------
bool __fastcall CHIDJoystick::InternalIsReleasedPositive(CHIDJoystick *this, HIDMapping Mapping)
{
  unsigned int numEntries; // r3
  int v3; // r4
  float *i; // r0
  bool v5; // r4

  numEntries = this->m_Mappings.numEntries;
  if ( !numEntries )
    return 0;
  v3 = 0;
  for ( i = &this->m_Mappings.dataPtr->fLastAnalogValue; *((_DWORD *)i - 2) != Mapping || *((int *)i - 3) < 16; i += 5 )
  {
    if ( ++v3 >= numEntries )
      return 0;
  }
  v5 = 0;
  if ( *i > 0.5
    && COERCE_FLOAT(COERCE_UNSIGNED_INT(OS_GamepadAxis(CHID::currentInstanceIndex, *((_DWORD *)i - 3))) & 0x7FFFFFFF) < 0.5 )
  {
    return 1;
  }
  return v5;
}

//----- (0028D3F4) --------------------------------------------------------
bool __fastcall CHIDJoystick::InternalIsPressedPositive(CHIDJoystick *this, HIDMapping Mapping)
{
  unsigned int numEntries; // r12
  int v4; // r3
  float *i; // r0

  numEntries = this->m_Mappings.numEntries;
  if ( !numEntries )
    return 0;
  v4 = 0;
  for ( i = &this->m_Mappings.dataPtr->fLastAnalogValue; *((_DWORD *)i - 2) != Mapping || *((int *)i - 3) <= 15; i += 5 )
  {
    if ( ++v4 >= numEntries )
      return 0;
  }
  return *i > 0.5;
}

//----- (0028D43E) --------------------------------------------------------
bool __fastcall CHIDJoystick::InternalIsPressedNegative(CHIDJoystick *this, HIDMapping Mapping)
{
  unsigned int numEntries; // r12
  int v4; // r3
  float *i; // r0

  numEntries = this->m_Mappings.numEntries;
  if ( !numEntries )
    return 0;
  v4 = 0;
  for ( i = &this->m_Mappings.dataPtr->fLastAnalogValue; *((_DWORD *)i - 2) != Mapping || *((int *)i - 3) <= 15; i += 5 )
  {
    if ( ++v4 >= numEntries )
      return 0;
  }
  return *i < -0.5;
}

//----- (0028D488) --------------------------------------------------------
void __fastcall CHIDJoystick::AddMapping(CHIDJoystick *this, int button, HIDMapping Mapping)
{
  unsigned int numEntries; // r6
  unsigned int v7; // r11
  JoystickButtonMapping *v8; // r0
  JoystickButtonMapping *v9; // r10
  JoystickButtonMapping *dataPtr; // r5
  JoystickButtonMapping *v11; // r0

  numEntries = this->m_Mappings.numEntries;
  if ( this->m_Mappings.numAlloced >= numEntries + 1 )
  {
    dataPtr = this->m_Mappings.dataPtr;
  }
  else
  {
    v7 = 4 * (numEntries + 1) / 3 + 3;
    v8 = (JoystickButtonMapping *)malloc(20 * v7);
    v9 = this->m_Mappings.dataPtr;
    dataPtr = v8;
    if ( v9 )
    {
      qmemcpy(v8, this->m_Mappings.dataPtr, 20 * numEntries);
      free(v9);
      numEntries = this->m_Mappings.numEntries;
    }
    this->m_Mappings.dataPtr = dataPtr;
    this->m_Mappings.numAlloced = v7;
  }
  dataPtr[numEntries].nButtonID = button;
  v11 = &dataPtr[numEntries];
  v11->mapping = Mapping;
  *(_WORD *)&v11->bAnalogPressedThisFrame = 0;
  v11->fLastAnalogValue = 0.0;
  v11->fLastReleaseTime = 0.0;
  ++this->m_Mappings.numEntries;
}

//----- (0028D512) --------------------------------------------------------
bool __fastcall CHIDJoystick::MappingHasButtonID(CHIDJoystick *this, int nButtonID)
{
  unsigned int numEntries; // r12
  JoystickButtonMapping *dataPtr; // r0
  unsigned int i; // r3

  numEntries = this->m_Mappings.numEntries;
  if ( !numEntries )
    return 0;
  dataPtr = this->m_Mappings.dataPtr;
  for ( i = 0; i < numEntries; ++i )
  {
    if ( dataPtr->nButtonID == nButtonID )
      return 1;
    ++dataPtr;
  }
  return 0;
}

//----- (0028D53C) --------------------------------------------------------
bool __fastcall CHIDJoystick::InternalMappingIsAnalog(CHIDJoystick *this, HIDMapping Mapping)
{
  unsigned int numEntries; // r12
  int v3; // r3
  HIDMapping *i; // r0

  numEntries = this->m_Mappings.numEntries;
  if ( !numEntries )
    return 0;
  v3 = 0;
  for ( i = &this->m_Mappings.dataPtr->mapping; *i != Mapping || *((int *)i - 1) <= 15; i += 5 )
  {
    if ( ++v3 >= numEntries )
      return 0;
  }
  return 1;
}

//----- (0028D56A) --------------------------------------------------------
HIDInputType __fastcall CHIDJoystick::InternalGetInputType(CHIDJoystick *this)
{
  return 1;
}

//----- (0028D570) --------------------------------------------------------
void __fastcall CHIDJoystick::~CHIDJoystick(CHIDJoystick *this)
{
  JoystickButtonMapping *dataPtr; // r0

  this->_vptr$CHID = (int (**)(void))&off_6620DC;
  CSprite2d::~CSprite2d(&this->m_Sprite);
  dataPtr = this->m_Mappings.dataPtr;
  this->m_Mappings.numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->m_Mappings.dataPtr = 0;
  }
  this->m_Mappings.numAlloced = 0;
}
// 6620DC: using guessed type void *off_6620DC;

//----- (0028D5A4) --------------------------------------------------------
void __fastcall CHIDJoystickAmazon::CHIDJoystickAmazon(CHIDJoystickAmazon *this, const unsigned __int8 *pszIconSprite)
{
  CHIDJoystick::CHIDJoystick(this, pszIconSprite);
  this->_vptr$CHID = (int (**)(void))&off_66213C;
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_SPRINT);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_ACCELERATE);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_ATTACK);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_JUMP);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_BRAKE);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_ENTER_CAR);
  CHIDJoystick::AddMapping(this, 13, HID_MAPPING_CAMERA_CLOSER);
  CHIDJoystick::AddMapping(this, 13, HID_MAPPING_CAMERA_FARTHER);
  CHIDJoystick::AddMapping(this, 8, HID_MAPPING_RADIO_PREV_STATION);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_RADIO_NEXT_STATION);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_VITAL_STATS);
  CHIDJoystick::AddMapping(this, 68, HID_MAPPING_PREV_WEAPON);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_HANDBRAKE);
  CHIDJoystick::AddMapping(this, 69, HID_MAPPING_NEXT_WEAPON);
  CHIDJoystick::AddMapping(this, 12, HID_MAPPING_CROUCH);
  CHIDJoystick::AddMapping(this, 12, HID_MAPPING_HORN);
  CHIDJoystick::AddMapping(this, 4, HID_MAPPING_RADAR);
  CHIDJoystick::AddMapping(this, 68, HID_MAPPING_VEHICLE_LOOK_LEFT);
  CHIDJoystick::AddMapping(this, 69, HID_MAPPING_VEHICLE_LOOK_RIGHT);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_MISSION_START_AND_CANCEL);
  CHIDJoystick::AddMapping(this, 13, HID_MAPPING_MISSION_START_AND_CANCEL_VIGILANTE);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_AUTO_HYDRAULICS);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_SWAP_WEAPONS_AND_PURCHASE);
  CHIDJoystick::AddMapping(this, 68, HID_MAPPING_WEAPON_ZOOM_IN);
  CHIDJoystick::AddMapping(this, 69, HID_MAPPING_WEAPON_ZOOM_OUT);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_ENTER_AND_EXIT_TARGETING);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_VEHICLE_BOMB);
  CHIDJoystick::AddMapping(this, 68, HID_MAPPING_TURRET_LEFT);
  CHIDJoystick::AddMapping(this, 69, HID_MAPPING_TURRET_RIGHT);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_VEHICLE_STEER_X);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_VEHICLE_STEER_Y);
  CHIDJoystick::AddMapping(this, 66, HID_MAPPING_LOOK_X);
  CHIDJoystick::AddMapping(this, 67, HID_MAPPING_LOOK_Y);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_PED_MOVE_X);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_PED_MOVE_Y);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_MAGNET);
  CHIDJoystick::AddMapping(this, 4, HID_MAPPING_SKIP_CUTSCENE);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_SKIP_CUTSCENE);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_GANG_RECRUIT);
  CHIDJoystick::AddMapping(this, 11, HID_MAPPING_GANG_IGNORE);
  CHIDJoystick::AddMapping(this, 8, HID_MAPPING_GANG_FOLLOW);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_GANG_HOLD_POSITION);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_RHYTHM_UP);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_RHYTHM_DOWN);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_RHYTHM_LEFT);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_RHYTHM_RIGHT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_DROP_CRANE);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_DROP_ITEM);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_PHONE);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_NITRO);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_CRANE_UP);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_CRANE_DOWN);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_ACCEPT);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_CANCEL);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_GRAB);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_STINGER);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_MENU_DOWN);
  CHIDJoystick::AddMapping(this, 8, HID_MAPPING_MENU_UP);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_MENU_LEFT);
  CHIDJoystick::AddMapping(this, 11, HID_MAPPING_MENU_RIGHT);
  CHIDJoystick::AddMapping(this, 4, HID_MAPPING_MENU_ACCEPT);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_MENU_ACCEPT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_MENU_BACK);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_MENU_MAP);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_ARCADE_BUTTON);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_ARCADE_POWER_OFF);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_ARCADE_JOYSTICK);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_GYM_ACTION);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_GYM_EASIER_LEVEL);
  CHIDJoystick::AddMapping(this, 11, HID_MAPPING_GYM_HARDER_LEVEL);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_BLACK_JACK_SPLIT);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_BLACK_JACK_DOUBLE);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_BLACK_JACK_HIT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_BLACK_JACK_STAND);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_PLACE_BET);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_REMOVE_BET);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_WAYPOINT_BLIP);
  CHIDJoystick::AddMapping(this, 8, HID_MAPPING_HELICOPTER_MAGNET_UP);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_HELICOPTER_MAGNET_DOWN);
  CHIDJoystick::AddMapping(this, 13, HID_MAPPING_LOCK_HYDRAULICS);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_FLIGHT_PRIMARY_ATTACK);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_FLIGHT_SECONDARY_ATTACK);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_BASKETBALL_SHOOT);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_MAP_ZOOM_IN);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_MAP_ZOOM_OUT);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_TAKE_COVER_LEFT);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_TAKE_COVER_RIGHT);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_KISS);
}
// 66213C: using guessed type void *;

//----- (0028D930) --------------------------------------------------------
CRect *__fastcall CHIDJoystickAmazon::FindUVsFromMapping(
        CRect *retstr,
        CHIDJoystickAmazon *this,
        const unsigned __int8 *pszCharacters,
        HIDMapping Mapping,
        bool bNegated)
{
  unsigned int numEntries; // r0
  unsigned int v8; // r2
  int v9; // r10
  unsigned __int32 v10; // r5
  HIDMapping *p_mapping; // r1
  unsigned __int32 v12; // r6
  int32x4_t v13; // q8
  float32x4_t v14; // q9
  CRect *result; // r0

  numEntries = this->m_Mappings.numEntries;
  if ( !numEntries )
  {
    v10 = 0;
    v9 = 0;
    if ( pszCharacters )
      goto LABEL_22;
LABEL_25:
    v12 = v9;
    goto LABEL_28;
  }
  v8 = 0;
  v9 = 0;
  v10 = 0;
  p_mapping = &this->m_Mappings.dataPtr->mapping;
  do
  {
    if ( *p_mapping == Mapping )
    {
      switch ( *((_DWORD *)p_mapping - 1) )
      {
        case 0:
        case 1:
        case 2:
        case 3:
          v9 = 1;
          v10 = *((_DWORD *)p_mapping - 1);
          break;
        case 4:
          v9 = 0;
          goto LABEL_19;
        case 6:
          v10 = 2;
          v9 = 2;
          break;
        case 7:
          v9 = 2;
          v10 = 3;
          break;
        case 8:
          v9 = 3;
          v10 = 4;
          break;
        case 9:
          v9 = 3;
          goto LABEL_19;
        case 0xA:
          v9 = 3;
          v10 = 2;
          break;
        case 0xB:
          v10 = 3;
          v9 = 3;
          break;
        case 0xC:
          v9 = 5;
          v10 = 0;
          break;
        case 0xD:
          v9 = 6;
          v10 = 0;
          break;
        case 0x40:
        case 0x41:
          v9 = 3;
          v10 = 0;
          break;
        case 0x42:
        case 0x43:
          v9 = 4;
          v10 = 0;
          break;
        case 0x44:
          v9 = 2;
          v10 = 0;
          break;
        case 0x45:
          v9 = 2;
LABEL_19:
          v10 = 1;
          break;
        default:
          break;
      }
    }
    ++v8;
    p_mapping += 5;
  }
  while ( v8 < numEntries );
  if ( !pszCharacters )
    goto LABEL_25;
LABEL_22:
  if ( strstr((const char *)pszCharacters, "widget_ped_move_left") )
  {
LABEL_23:
    v12 = 5;
    v10 = 2;
    goto LABEL_28;
  }
  if ( strstr((const char *)pszCharacters, "widget_ped_move_right") )
    goto LABEL_27;
  if ( strstr((const char *)pszCharacters, "widget_vehicle_steer_left") )
    goto LABEL_23;
  if ( strstr((const char *)pszCharacters, "widget_vehicle_steer_right") )
  {
LABEL_27:
    v12 = 5;
    v10 = 3;
    goto LABEL_28;
  }
  v12 = 5;
  if ( strstr((const char *)pszCharacters, "widget_ped_move_up") )
  {
    v10 = 4;
  }
  else if ( strstr((const char *)pszCharacters, "widget_ped_move_down") )
  {
    v10 = 1;
  }
  else
  {
    v12 = v9;
  }
LABEL_28:
  v13.n128_u32[0] = v10;
  v14.n128_u64[0] = 0x3E0000003E000000LL;
  v14.n128_u64[1] = 0x3E0000003E000000LL;
  v13.n128_u32[2] = v10 + 1;
  result = (CRect *)(v12 + 1);
  v13.n128_u32[1] = v12 + 1;
  v13.n128_u32[3] = v12;
  *(float32x4_t *)retstr = vmulq_f32(vcvtq_f32_s32(v13), v14);
  return result;
}

//----- (0028DB4C) --------------------------------------------------------
void __fastcall CHIDJoystickAmazon::~CHIDJoystickAmazon(CHIDJoystickAmazon *this)
{
  JoystickButtonMapping *dataPtr; // r0

  this->_vptr$CHID = (int (**)(void))&off_6620DC;
  CSprite2d::~CSprite2d(&this->m_Sprite);
  dataPtr = this->m_Mappings.dataPtr;
  this->m_Mappings.numEntries = 0;
  if ( dataPtr )
    free(dataPtr);
  sub_191374(this);
}
// 6620DC: using guessed type void *off_6620DC;

//----- (0028DB80) --------------------------------------------------------
void __fastcall CHIDJoystickAndroidTV::CHIDJoystickAndroidTV(
        CHIDJoystickAndroidTV *this,
        const unsigned __int8 *pszIconSprite)
{
  CHIDJoystick::CHIDJoystick(this, pszIconSprite);
  this->_vptr$CHID = (int (**)(void))&off_66219C;
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_SPRINT);
  CHIDJoystick::AddMapping(this, 69, HID_MAPPING_ACCELERATE);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_ATTACK);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_JUMP);
  CHIDJoystick::AddMapping(this, 68, HID_MAPPING_BRAKE);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_ENTER_CAR);
  CHIDJoystick::AddMapping(this, 5, HID_MAPPING_CAMERA_CLOSER);
  CHIDJoystick::AddMapping(this, 5, HID_MAPPING_CAMERA_FARTHER);
  CHIDJoystick::AddMapping(this, 8, HID_MAPPING_RADIO_PREV_STATION);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_RADIO_NEXT_STATION);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_VITAL_STATS);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_PREV_WEAPON);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_HANDBRAKE);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_NEXT_WEAPON);
  CHIDJoystick::AddMapping(this, 12, HID_MAPPING_CROUCH);
  CHIDJoystick::AddMapping(this, 12, HID_MAPPING_HORN);
  CHIDJoystick::AddMapping(this, 13, HID_MAPPING_PED_LOOK_BACK);
  CHIDJoystick::AddMapping(this, 4, HID_MAPPING_RADAR);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_VEHICLE_LOOK_LEFT);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_VEHICLE_LOOK_RIGHT);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_MISSION_START_AND_CANCEL);
  CHIDJoystick::AddMapping(this, 13, HID_MAPPING_MISSION_START_AND_CANCEL_VIGILANTE);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_AUTO_HYDRAULICS);
  CHIDJoystick::AddMapping(this, 68, HID_MAPPING_SWAP_WEAPONS_AND_PURCHASE);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_WEAPON_ZOOM_IN);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_WEAPON_ZOOM_OUT);
  CHIDJoystick::AddMapping(this, 69, HID_MAPPING_ENTER_AND_EXIT_TARGETING);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_VEHICLE_BOMB);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_TURRET_LEFT);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_TURRET_RIGHT);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_VEHICLE_STEER_X);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_VEHICLE_STEER_Y);
  CHIDJoystick::AddMapping(this, 66, HID_MAPPING_LOOK_X);
  CHIDJoystick::AddMapping(this, 67, HID_MAPPING_LOOK_Y);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_PED_MOVE_X);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_PED_MOVE_Y);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_MAGNET);
  CHIDJoystick::AddMapping(this, 4, HID_MAPPING_SKIP_CUTSCENE);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_SKIP_CUTSCENE);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_GANG_RECRUIT);
  CHIDJoystick::AddMapping(this, 11, HID_MAPPING_GANG_IGNORE);
  CHIDJoystick::AddMapping(this, 8, HID_MAPPING_GANG_FOLLOW);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_GANG_HOLD_POSITION);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_RHYTHM_UP);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_RHYTHM_DOWN);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_RHYTHM_LEFT);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_RHYTHM_RIGHT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_DROP_CRANE);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_DROP_ITEM);
  CHIDJoystick::AddMapping(this, 68, HID_MAPPING_PHONE);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_NITRO);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_CRANE_UP);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_CRANE_DOWN);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_ACCEPT);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_CANCEL);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_GRAB);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_STINGER);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_MENU_DOWN);
  CHIDJoystick::AddMapping(this, 8, HID_MAPPING_MENU_UP);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_MENU_LEFT);
  CHIDJoystick::AddMapping(this, 11, HID_MAPPING_MENU_RIGHT);
  CHIDJoystick::AddMapping(this, 4, HID_MAPPING_MENU_ACCEPT);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_MENU_ACCEPT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_MENU_BACK);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_MENU_MAP);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_ARCADE_BUTTON);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_ARCADE_POWER_OFF);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_ARCADE_JOYSTICK);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_GYM_ACTION);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_GYM_EASIER_LEVEL);
  CHIDJoystick::AddMapping(this, 11, HID_MAPPING_GYM_HARDER_LEVEL);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_BLACK_JACK_SPLIT);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_BLACK_JACK_DOUBLE);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_BLACK_JACK_HIT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_BLACK_JACK_STAND);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_PLACE_BET);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_REMOVE_BET);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_PREV_TARGET);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_NEXT_TARGET);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_WAYPOINT_BLIP);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_HELICOPTER_MAGNET_UP);
  CHIDJoystick::AddMapping(this, 11, HID_MAPPING_HELICOPTER_MAGNET_DOWN);
  CHIDJoystick::AddMapping(this, 13, HID_MAPPING_LOCK_HYDRAULICS);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_FLIGHT_PRIMARY_ATTACK);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_FLIGHT_SECONDARY_ATTACK);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_BASKETBALL_SHOOT);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_BUNNY_HOP);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_MAP_ZOOM_IN);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_MAP_ZOOM_OUT);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_ALT_ATTACK);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_BLOCK);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_TAKE_COVER_LEFT);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_TAKE_COVER_RIGHT);
  CHIDJoystick::AddMapping(this, 12, HID_MAPPING_TOGGLE_LANDING_GEAR);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_KISS);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_DANCING_UP);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_DANCING_DOWN);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_DANCING_LEFT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_DANCING_RIGHT);
}
// 66219C: using guessed type void *;

//----- (0028DF7C) --------------------------------------------------------
CRect *__fastcall CHIDJoystickAndroidTV::FindUVsFromMapping(
        CRect *retstr,
        CHIDJoystickAndroidTV *this,
        const unsigned __int8 *pszCharacters,
        HIDMapping Mapping,
        bool bNegated)
{
  unsigned int numEntries; // r0
  unsigned int v8; // r2
  int v9; // r10
  unsigned __int32 v10; // r5
  HIDMapping *p_mapping; // r1
  unsigned __int32 v12; // r6
  int32x4_t v13; // q8
  float32x4_t v14; // q9
  CRect *result; // r0

  numEntries = this->m_Mappings.numEntries;
  if ( !numEntries )
  {
    v10 = 0;
    v9 = 0;
    if ( pszCharacters )
      goto LABEL_21;
LABEL_24:
    v12 = v9;
    goto LABEL_27;
  }
  v8 = 0;
  v9 = 0;
  v10 = 0;
  p_mapping = &this->m_Mappings.dataPtr->mapping;
  do
  {
    if ( *p_mapping == Mapping )
    {
      switch ( *((_DWORD *)p_mapping - 1) )
      {
        case 0:
        case 1:
        case 2:
        case 3:
          v9 = 1;
          v10 = *((_DWORD *)p_mapping - 1);
          break;
        case 6:
          v10 = 2;
          v9 = 2;
          break;
        case 7:
          v9 = 2;
          v10 = 3;
          break;
        case 8:
          v9 = 3;
          v10 = 4;
          break;
        case 9:
          v9 = 3;
          goto LABEL_18;
        case 0xA:
          v9 = 3;
          v10 = 2;
          break;
        case 0xB:
          v10 = 3;
          v9 = 3;
          break;
        case 0xC:
          v9 = 5;
          v10 = 0;
          break;
        case 0xD:
          v9 = 6;
          v10 = 0;
          break;
        case 0x40:
        case 0x41:
          v9 = 3;
          v10 = 0;
          break;
        case 0x42:
        case 0x43:
          v9 = 4;
          v10 = 0;
          break;
        case 0x44:
          v9 = 2;
          v10 = 0;
          break;
        case 0x45:
          v9 = 2;
LABEL_18:
          v10 = 1;
          break;
        default:
          break;
      }
    }
    ++v8;
    p_mapping += 5;
  }
  while ( v8 < numEntries );
  if ( !pszCharacters )
    goto LABEL_24;
LABEL_21:
  if ( strstr((const char *)pszCharacters, "widget_ped_move_left") )
  {
LABEL_22:
    v12 = 5;
    v10 = 2;
    goto LABEL_27;
  }
  if ( strstr((const char *)pszCharacters, "widget_ped_move_right") )
    goto LABEL_26;
  if ( strstr((const char *)pszCharacters, "widget_vehicle_steer_left") )
    goto LABEL_22;
  if ( strstr((const char *)pszCharacters, "widget_vehicle_steer_right") )
  {
LABEL_26:
    v12 = 5;
    v10 = 3;
    goto LABEL_27;
  }
  v12 = 5;
  if ( strstr((const char *)pszCharacters, "widget_ped_move_up") )
  {
    v10 = 4;
  }
  else if ( strstr((const char *)pszCharacters, "widget_ped_move_down") )
  {
    v10 = 1;
  }
  else
  {
    v12 = v9;
  }
LABEL_27:
  v13.n128_u32[0] = v10;
  v14.n128_u64[0] = 0x3E0000003E000000LL;
  v14.n128_u64[1] = 0x3E0000003E000000LL;
  v13.n128_u32[2] = v10 + 1;
  result = (CRect *)(v12 + 1);
  v13.n128_u32[1] = v12 + 1;
  v13.n128_u32[3] = v12;
  *(float32x4_t *)retstr = vmulq_f32(vcvtq_f32_s32(v13), v14);
  return result;
}

//----- (0028E194) --------------------------------------------------------
void __fastcall CHIDJoystickAndroidTV::~CHIDJoystickAndroidTV(CHIDJoystickAndroidTV *this)
{
  JoystickButtonMapping *dataPtr; // r0

  this->_vptr$CHID = (int (**)(void))&off_6620DC;
  CSprite2d::~CSprite2d(&this->m_Sprite);
  dataPtr = this->m_Mappings.dataPtr;
  this->m_Mappings.numEntries = 0;
  if ( dataPtr )
    free(dataPtr);
  sub_191374(this);
}
// 6620DC: using guessed type void *off_6620DC;

//----- (0028E1C8) --------------------------------------------------------
void __fastcall CHIDJoystickIOSExtended::CHIDJoystickIOSExtended(
        CHIDJoystickIOSExtended *this,
        const unsigned __int8 *pszIconSprite)
{
  CHIDJoystick::CHIDJoystick(this, pszIconSprite);
  this->_vptr$CHID = (int (**)(void))&off_6621FC;
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_SPRINT);
  CHIDJoystick::AddMapping(this, 69, HID_MAPPING_ACCELERATE);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_ATTACK);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_JUMP);
  CHIDJoystick::AddMapping(this, 68, HID_MAPPING_BRAKE);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_ENTER_CAR);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_RADIO_PREV_STATION);
  CHIDJoystick::AddMapping(this, 11, HID_MAPPING_RADIO_NEXT_STATION);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_PREV_WEAPON);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_HANDBRAKE);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_NEXT_WEAPON);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_CROUCH);
  CHIDJoystick::AddMapping(this, 8, HID_MAPPING_HORN);
  CHIDJoystick::AddMapping(this, 4, HID_MAPPING_RADAR);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_VEHICLE_LOOK_LEFT);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_VEHICLE_LOOK_RIGHT);
  CHIDJoystick::AddMapping(this, 8, HID_MAPPING_MISSION_START_AND_CANCEL);
  CHIDJoystick::AddMapping(this, 8, HID_MAPPING_MISSION_START_AND_CANCEL_VIGILANTE);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_AUTO_HYDRAULICS);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_SWAP_WEAPONS_AND_PURCHASE);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_WEAPON_ZOOM_IN);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_WEAPON_ZOOM_OUT);
  CHIDJoystick::AddMapping(this, 69, HID_MAPPING_ENTER_AND_EXIT_TARGETING);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_VEHICLE_BOMB);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_TURRET_LEFT);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_TURRET_RIGHT);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_VEHICLE_STEER_X);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_VEHICLE_STEER_Y);
  CHIDJoystick::AddMapping(this, 66, HID_MAPPING_LOOK_X);
  CHIDJoystick::AddMapping(this, 67, HID_MAPPING_LOOK_Y);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_PED_MOVE_X);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_PED_MOVE_Y);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_MAGNET);
  CHIDJoystick::AddMapping(this, 4, HID_MAPPING_SKIP_CUTSCENE);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_SKIP_CUTSCENE);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_GANG_RECRUIT);
  CHIDJoystick::AddMapping(this, 11, HID_MAPPING_GANG_IGNORE);
  CHIDJoystick::AddMapping(this, 8, HID_MAPPING_GANG_FOLLOW);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_GANG_HOLD_POSITION);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_RHYTHM_UP);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_RHYTHM_DOWN);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_RHYTHM_LEFT);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_RHYTHM_RIGHT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_DROP_CRANE);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_DROP_ITEM);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_PHONE);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_NITRO);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_CRANE_UP);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_CRANE_DOWN);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_ACCEPT);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_CANCEL);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_GRAB);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_STINGER);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_MENU_DOWN);
  CHIDJoystick::AddMapping(this, 8, HID_MAPPING_MENU_UP);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_MENU_LEFT);
  CHIDJoystick::AddMapping(this, 11, HID_MAPPING_MENU_RIGHT);
  CHIDJoystick::AddMapping(this, 4, HID_MAPPING_MENU_ACCEPT);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_MENU_ACCEPT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_MENU_BACK);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_MENU_MAP);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_ARCADE_BUTTON);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_ARCADE_POWER_OFF);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_ARCADE_JOYSTICK);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_GYM_ACTION);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_GYM_EASIER_LEVEL);
  CHIDJoystick::AddMapping(this, 11, HID_MAPPING_GYM_HARDER_LEVEL);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_BLACK_JACK_SPLIT);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_BLACK_JACK_DOUBLE);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_BLACK_JACK_HIT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_BLACK_JACK_STAND);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_PLACE_BET);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_REMOVE_BET);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_WAYPOINT_BLIP);
  CHIDJoystick::AddMapping(this, 8, HID_MAPPING_HELICOPTER_MAGNET_UP);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_HELICOPTER_MAGNET_DOWN);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_LOCK_HYDRAULICS);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_FLIGHT_PRIMARY_ATTACK);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_FLIGHT_SECONDARY_ATTACK);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_BASKETBALL_SHOOT);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_MAP_ZOOM_IN);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_MAP_ZOOM_OUT);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_TAKE_COVER_LEFT);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_TAKE_COVER_RIGHT);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_KISS);
}
// 6621FC: using guessed type void *;

//----- (0028E538) --------------------------------------------------------
CRect *__fastcall CHIDJoystickIOSExtended::FindUVsFromMapping(
        CRect *retstr,
        CHIDJoystickIOSExtended *this,
        const unsigned __int8 *pszCharacters,
        HIDMapping Mapping,
        bool bNegated)
{
  unsigned int numEntries; // r12
  unsigned int v6; // r2
  unsigned __int32 v7; // lr
  unsigned __int32 v8; // r4
  HIDMapping *p_mapping; // r1
  int32x4_t v10; // q8
  float32x4_t v11; // q9

  numEntries = this->m_Mappings.numEntries;
  if ( numEntries )
  {
    v6 = 0;
    v7 = 0;
    v8 = 0;
    p_mapping = &this->m_Mappings.dataPtr->mapping;
    do
    {
      if ( *p_mapping == Mapping )
      {
        switch ( *((_DWORD *)p_mapping - 1) )
        {
          case 0:
          case 1:
          case 2:
          case 3:
            v7 = 1;
            v8 = *((_DWORD *)p_mapping - 1);
            break;
          case 4:
            v7 = 0;
            goto LABEL_17;
          case 6:
            v8 = 2;
            v7 = 2;
            break;
          case 7:
            v7 = 2;
            v8 = 3;
            break;
          case 8:
            v8 = 3;
            v7 = 3;
            break;
          case 9:
            v7 = 3;
            v8 = 0;
            break;
          case 0xA:
            v7 = 3;
            goto LABEL_17;
          case 0xB:
            v7 = 3;
            v8 = 2;
            break;
          case 0x40:
          case 0x41:
            v7 = 0;
            v8 = 2;
            break;
          case 0x42:
          case 0x43:
            v7 = 0;
            v8 = 3;
            break;
          case 0x44:
            v7 = 2;
            v8 = 0;
            break;
          case 0x45:
            v7 = 2;
LABEL_17:
            v8 = 1;
            break;
          default:
            break;
        }
      }
      ++v6;
      p_mapping += 5;
    }
    while ( v6 < numEntries );
  }
  else
  {
    v8 = 0;
    v7 = 0;
  }
  v10.n128_u32[0] = v8;
  v11.n128_f32[0] = 0.25;
  v11.n128_f32[1] = 0.25;
  v11.n128_f32[2] = 0.25;
  v11.n128_f32[3] = 0.25;
  v10.n128_u32[2] = v8 + 1;
  v10.n128_u32[1] = v7 + 1;
  v10.n128_u32[3] = v7;
  *(float32x4_t *)retstr = vmulq_f32(vcvtq_f32_s32(v10), v11);
  return retstr;
}

//----- (0028E64C) --------------------------------------------------------
void __fastcall CHIDJoystickIOSExtended::~CHIDJoystickIOSExtended(CHIDJoystickIOSExtended *this)
{
  JoystickButtonMapping *dataPtr; // r0

  this->_vptr$CHID = (int (**)(void))&off_6620DC;
  CSprite2d::~CSprite2d(&this->m_Sprite);
  dataPtr = this->m_Mappings.dataPtr;
  this->m_Mappings.numEntries = 0;
  if ( dataPtr )
    free(dataPtr);
  sub_191374(this);
}
// 6620DC: using guessed type void *off_6620DC;

//----- (0028E680) --------------------------------------------------------
void __fastcall CHIDJoystickIOSSimple::CHIDJoystickIOSSimple(
        CHIDJoystickIOSSimple *this,
        const unsigned __int8 *pszIconSprite)
{
  CHIDJoystick::CHIDJoystick(this, pszIconSprite);
  this->_vptr$CHID = (int (**)(void))&off_66225C;
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_SPRINT);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_ACCELERATE);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_ATTACK);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_JUMP);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_BRAKE);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_ENTER_CAR);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_HANDBRAKE);
  CHIDJoystick::AddMapping(this, 4, HID_MAPPING_RADAR);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_MISSION_START_AND_CANCEL);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_AUTO_HYDRAULICS);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_SWAP_WEAPONS_AND_PURCHASE);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_WEAPON_ZOOM_IN);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_WEAPON_ZOOM_OUT);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_ENTER_AND_EXIT_TARGETING);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_VEHICLE_BOMB);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_VEHICLE_STEER_X);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_VEHICLE_STEER_Y);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_PED_MOVE_X);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_PED_MOVE_Y);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_MAGNET);
  CHIDJoystick::AddMapping(this, 4, HID_MAPPING_SKIP_CUTSCENE);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_SKIP_CUTSCENE);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_RHYTHM_UP);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_RHYTHM_DOWN);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_RHYTHM_LEFT);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_RHYTHM_RIGHT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_DROP_CRANE);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_DROP_ITEM);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_PHONE);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_NITRO);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_CRANE_UP);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_CRANE_DOWN);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_ACCEPT);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_CANCEL);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_STINGER);
  CHIDJoystick::AddMapping(this, 4, HID_MAPPING_MENU_ACCEPT);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_MENU_ACCEPT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_MENU_BACK);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_MENU_MAP);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_ARCADE_BUTTON);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_ARCADE_POWER_OFF);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_ARCADE_JOYSTICK);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_GYM_ACTION);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_GYM_EASIER_LEVEL);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_GYM_HARDER_LEVEL);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_BLACK_JACK_SPLIT);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_BLACK_JACK_DOUBLE);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_BLACK_JACK_HIT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_BLACK_JACK_STAND);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_PLACE_BET);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_REMOVE_BET);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_WAYPOINT_BLIP);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_LOCK_HYDRAULICS);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_FLIGHT_PRIMARY_ATTACK);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_FLIGHT_SECONDARY_ATTACK);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_BASKETBALL_SHOOT);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_MAP_ZOOM_IN);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_MAP_ZOOM_OUT);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_TAKE_COVER_LEFT);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_TAKE_COVER_RIGHT);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_KISS);
}
// 66225C: using guessed type void *;

//----- (0028E900) --------------------------------------------------------
CRect *__fastcall CHIDJoystickIOSSimple::FindUVsFromMapping(
        CRect *retstr,
        CHIDJoystickIOSSimple *this,
        const unsigned __int8 *pszCharacters,
        HIDMapping Mapping,
        bool bNegated)
{
  unsigned int numEntries; // r12
  unsigned int v6; // r2
  unsigned __int32 v7; // lr
  unsigned __int32 v8; // r4
  HIDMapping *p_mapping; // r1
  int32x4_t v10; // q8
  float32x4_t v11; // q9

  numEntries = this->m_Mappings.numEntries;
  if ( numEntries )
  {
    v6 = 0;
    v7 = 0;
    v8 = 0;
    p_mapping = &this->m_Mappings.dataPtr->mapping;
    do
    {
      if ( *p_mapping == Mapping )
      {
        switch ( *((_DWORD *)p_mapping - 1) )
        {
          case 0:
          case 1:
          case 2:
          case 3:
            v7 = 1;
            v8 = *((_DWORD *)p_mapping - 1);
            break;
          case 4:
            v7 = 0;
            v8 = 1;
            break;
          case 6:
            v8 = 2;
            v7 = 2;
            break;
          case 7:
            v7 = 2;
            goto LABEL_11;
          case 0x40:
            v7 = 0;
            v8 = 2;
            break;
          case 0x41:
            v7 = 0;
LABEL_11:
            v8 = 3;
            break;
          default:
            break;
        }
      }
      ++v6;
      p_mapping += 5;
    }
    while ( v6 < numEntries );
  }
  else
  {
    v8 = 0;
    v7 = 0;
  }
  v10.n128_u32[0] = v8;
  v11.n128_f32[0] = 0.25;
  v11.n128_f32[1] = 0.25;
  v11.n128_f32[2] = 0.25;
  v11.n128_f32[3] = 0.25;
  v10.n128_u32[2] = v8 + 1;
  v10.n128_u32[1] = v7 + 1;
  v10.n128_u32[3] = v7;
  *(float32x4_t *)retstr = vmulq_f32(vcvtq_f32_s32(v10), v11);
  return retstr;
}

//----- (0028E9E4) --------------------------------------------------------
void __fastcall CHIDJoystickIOSSimple::~CHIDJoystickIOSSimple(CHIDJoystickIOSSimple *this)
{
  JoystickButtonMapping *dataPtr; // r0

  this->_vptr$CHID = (int (**)(void))&off_6620DC;
  CSprite2d::~CSprite2d(&this->m_Sprite);
  dataPtr = this->m_Mappings.dataPtr;
  this->m_Mappings.numEntries = 0;
  if ( dataPtr )
    free(dataPtr);
  sub_191374(this);
}
// 6620DC: using guessed type void *off_6620DC;

//----- (0028EA18) --------------------------------------------------------
void __fastcall CHIDJoystickMogaPocket::CHIDJoystickMogaPocket(
        CHIDJoystickMogaPocket *this,
        const unsigned __int8 *pszIconSprite)
{
  CHIDJoystick::CHIDJoystick(this, pszIconSprite);
  this->_vptr$CHID = (int (**)(void))&off_6622BC;
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_SPRINT);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_ACCELERATE);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_ATTACK);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_JUMP);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_BRAKE);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_ENTER_CAR);
  CHIDJoystick::AddMapping(this, 5, HID_MAPPING_CAMERA_CLOSER);
  CHIDJoystick::AddMapping(this, 5, HID_MAPPING_CAMERA_FARTHER);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_HANDBRAKE);
  CHIDJoystick::AddMapping(this, 4, HID_MAPPING_RADAR);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_MISSION_START_AND_CANCEL);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_AUTO_HYDRAULICS);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_SWAP_WEAPONS_AND_PURCHASE);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_WEAPON_ZOOM_IN);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_WEAPON_ZOOM_OUT);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_ENTER_AND_EXIT_TARGETING);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_VEHICLE_BOMB);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_VEHICLE_STEER_X);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_VEHICLE_STEER_Y);
  CHIDJoystick::AddMapping(this, 66, HID_MAPPING_LOOK_X);
  CHIDJoystick::AddMapping(this, 67, HID_MAPPING_LOOK_Y);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_PED_MOVE_X);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_PED_MOVE_Y);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_MAGNET);
  CHIDJoystick::AddMapping(this, 4, HID_MAPPING_SKIP_CUTSCENE);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_SKIP_CUTSCENE);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_RHYTHM_UP);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_RHYTHM_DOWN);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_RHYTHM_LEFT);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_RHYTHM_RIGHT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_DROP_CRANE);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_DROP_ITEM);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_PHONE);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_NITRO);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_CRANE_UP);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_CRANE_DOWN);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_ACCEPT);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_CANCEL);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_STINGER);
  CHIDJoystick::AddMapping(this, 4, HID_MAPPING_MENU_ACCEPT);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_MENU_ACCEPT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_MENU_BACK);
  CHIDJoystick::AddMapping(this, 5, HID_MAPPING_MENU_MAP);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_ARCADE_BUTTON);
  CHIDJoystick::AddMapping(this, 5, HID_MAPPING_ARCADE_RESET);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_ARCADE_POWER_OFF);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_ARCADE_JOYSTICK);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_GYM_ACTION);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_GYM_EASIER_LEVEL);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_GYM_HARDER_LEVEL);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_BLACK_JACK_SPLIT);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_BLACK_JACK_DOUBLE);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_BLACK_JACK_HIT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_BLACK_JACK_STAND);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_PLACE_BET);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_REMOVE_BET);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_WAYPOINT_BLIP);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_LOCK_HYDRAULICS);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_FLIGHT_PRIMARY_ATTACK);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_FLIGHT_SECONDARY_ATTACK);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_BASKETBALL_SHOOT);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_MAP_ZOOM_IN);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_MAP_ZOOM_OUT);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_TAKE_COVER_LEFT);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_TAKE_COVER_RIGHT);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_KISS);
}
// 6622BC: using guessed type void *;

//----- (0028ECC8) --------------------------------------------------------
CRect *__fastcall CHIDJoystickMogaPocket::FindUVsFromMapping(
        CRect *retstr,
        CHIDJoystickMogaPocket *this,
        const unsigned __int8 *pszCharacters,
        HIDMapping Mapping,
        bool bNegated)
{
  unsigned int numEntries; // r12
  unsigned int v6; // r2
  unsigned __int32 v7; // lr
  unsigned __int32 v8; // r4
  HIDMapping *p_mapping; // r1
  int32x4_t v10; // q8
  float32x4_t v11; // q9

  numEntries = this->m_Mappings.numEntries;
  if ( numEntries )
  {
    v6 = 0;
    v7 = 0;
    v8 = 0;
    p_mapping = &this->m_Mappings.dataPtr->mapping;
    do
    {
      if ( *p_mapping == Mapping )
      {
        switch ( *((_DWORD *)p_mapping - 1) )
        {
          case 0:
          case 1:
          case 2:
          case 3:
            v7 = 1;
            v8 = *((_DWORD *)p_mapping - 1);
            break;
          case 4:
            v7 = 0;
            goto LABEL_12;
          case 5:
            v8 = 0;
            v7 = 0;
            break;
          case 6:
            v7 = 2;
            v8 = 0;
            break;
          case 7:
            v7 = 2;
LABEL_12:
            v8 = 1;
            break;
          case 0x40:
          case 0x41:
            v7 = 0;
            v8 = 2;
            break;
          case 0x42:
          case 0x43:
            v7 = 0;
            v8 = 3;
            break;
          default:
            break;
        }
      }
      ++v6;
      p_mapping += 5;
    }
    while ( v6 < numEntries );
  }
  else
  {
    v8 = 0;
    v7 = 0;
  }
  v10.n128_u32[0] = v8;
  v11.n128_f32[0] = 0.25;
  v11.n128_f32[1] = 0.25;
  v11.n128_f32[2] = 0.25;
  v11.n128_f32[3] = 0.25;
  v10.n128_u32[2] = v8 + 1;
  v10.n128_u32[1] = v7 + 1;
  v10.n128_u32[3] = v7;
  *(float32x4_t *)retstr = vmulq_f32(vcvtq_f32_s32(v10), v11);
  return retstr;
}

//----- (0028EDB4) --------------------------------------------------------
void __fastcall CHIDJoystickMogaPocket::~CHIDJoystickMogaPocket(CHIDJoystickMogaPocket *this)
{
  JoystickButtonMapping *dataPtr; // r0

  this->_vptr$CHID = (int (**)(void))&off_6620DC;
  CSprite2d::~CSprite2d(&this->m_Sprite);
  dataPtr = this->m_Mappings.dataPtr;
  this->m_Mappings.numEntries = 0;
  if ( dataPtr )
    free(dataPtr);
  sub_191374(this);
}
// 6620DC: using guessed type void *off_6620DC;

//----- (0028EDE8) --------------------------------------------------------
void __fastcall CHIDJoystickMogaPro::CHIDJoystickMogaPro(
        CHIDJoystickMogaPro *this,
        const unsigned __int8 *pszIconSprite)
{
  CHIDJoystick::CHIDJoystick(this, pszIconSprite);
  this->_vptr$CHID = (int (**)(void))&off_66231C;
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_SPRINT);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_ACCELERATE);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_ATTACK);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_JUMP);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_BRAKE);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_ENTER_CAR);
  CHIDJoystick::AddMapping(this, 5, HID_MAPPING_CAMERA_CLOSER);
  CHIDJoystick::AddMapping(this, 5, HID_MAPPING_CAMERA_FARTHER);
  CHIDJoystick::AddMapping(this, 8, HID_MAPPING_RADIO_PREV_STATION);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_RADIO_NEXT_STATION);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_VITAL_STATS);
  CHIDJoystick::AddMapping(this, 68, HID_MAPPING_PREV_WEAPON);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_HANDBRAKE);
  CHIDJoystick::AddMapping(this, 69, HID_MAPPING_NEXT_WEAPON);
  CHIDJoystick::AddMapping(this, 12, HID_MAPPING_CROUCH);
  CHIDJoystick::AddMapping(this, 12, HID_MAPPING_HORN);
  CHIDJoystick::AddMapping(this, 13, HID_MAPPING_PED_LOOK_BACK);
  CHIDJoystick::AddMapping(this, 4, HID_MAPPING_RADAR);
  CHIDJoystick::AddMapping(this, 68, HID_MAPPING_VEHICLE_LOOK_LEFT);
  CHIDJoystick::AddMapping(this, 69, HID_MAPPING_VEHICLE_LOOK_RIGHT);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_MISSION_START_AND_CANCEL);
  CHIDJoystick::AddMapping(this, 13, HID_MAPPING_MISSION_START_AND_CANCEL_VIGILANTE);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_AUTO_HYDRAULICS);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_SWAP_WEAPONS_AND_PURCHASE);
  CHIDJoystick::AddMapping(this, 68, HID_MAPPING_WEAPON_ZOOM_IN);
  CHIDJoystick::AddMapping(this, 69, HID_MAPPING_WEAPON_ZOOM_OUT);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_ENTER_AND_EXIT_TARGETING);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_VEHICLE_BOMB);
  CHIDJoystick::AddMapping(this, 68, HID_MAPPING_TURRET_LEFT);
  CHIDJoystick::AddMapping(this, 69, HID_MAPPING_TURRET_RIGHT);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_VEHICLE_STEER_X);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_VEHICLE_STEER_Y);
  CHIDJoystick::AddMapping(this, 66, HID_MAPPING_LOOK_X);
  CHIDJoystick::AddMapping(this, 67, HID_MAPPING_LOOK_Y);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_PED_MOVE_X);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_PED_MOVE_Y);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_MAGNET);
  CHIDJoystick::AddMapping(this, 4, HID_MAPPING_SKIP_CUTSCENE);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_SKIP_CUTSCENE);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_GANG_RECRUIT);
  CHIDJoystick::AddMapping(this, 11, HID_MAPPING_GANG_IGNORE);
  CHIDJoystick::AddMapping(this, 8, HID_MAPPING_GANG_FOLLOW);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_GANG_HOLD_POSITION);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_RHYTHM_UP);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_RHYTHM_DOWN);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_RHYTHM_LEFT);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_RHYTHM_RIGHT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_DROP_CRANE);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_DROP_ITEM);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_PHONE);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_NITRO);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_CRANE_UP);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_CRANE_DOWN);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_ACCEPT);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_CANCEL);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_GRAB);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_STINGER);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_MENU_DOWN);
  CHIDJoystick::AddMapping(this, 8, HID_MAPPING_MENU_UP);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_MENU_LEFT);
  CHIDJoystick::AddMapping(this, 11, HID_MAPPING_MENU_RIGHT);
  CHIDJoystick::AddMapping(this, 4, HID_MAPPING_MENU_ACCEPT);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_MENU_ACCEPT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_MENU_BACK);
  CHIDJoystick::AddMapping(this, 5, HID_MAPPING_MENU_MAP);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_ARCADE_BUTTON);
  CHIDJoystick::AddMapping(this, 5, HID_MAPPING_ARCADE_RESET);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_ARCADE_POWER_OFF);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_ARCADE_JOYSTICK);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_GYM_ACTION);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_GYM_EASIER_LEVEL);
  CHIDJoystick::AddMapping(this, 11, HID_MAPPING_GYM_HARDER_LEVEL);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_BLACK_JACK_SPLIT);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_BLACK_JACK_DOUBLE);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_BLACK_JACK_HIT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_BLACK_JACK_STAND);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_PLACE_BET);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_REMOVE_BET);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_WAYPOINT_BLIP);
  CHIDJoystick::AddMapping(this, 8, HID_MAPPING_HELICOPTER_MAGNET_UP);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_HELICOPTER_MAGNET_DOWN);
  CHIDJoystick::AddMapping(this, 13, HID_MAPPING_LOCK_HYDRAULICS);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_FLIGHT_PRIMARY_ATTACK);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_FLIGHT_SECONDARY_ATTACK);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_BASKETBALL_SHOOT);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_MAP_ZOOM_IN);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_MAP_ZOOM_OUT);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_TAKE_COVER_LEFT);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_TAKE_COVER_RIGHT);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_KISS);
}
// 66231C: using guessed type void *;

//----- (0028F188) --------------------------------------------------------
CRect *__fastcall CHIDJoystickMogaPro::FindUVsFromMapping(
        CRect *retstr,
        CHIDJoystickMogaPro *this,
        const unsigned __int8 *pszCharacters,
        HIDMapping Mapping,
        bool bNegated)
{
  unsigned int numEntries; // r0
  unsigned int v8; // r2
  int v9; // r10
  unsigned __int32 v10; // r5
  HIDMapping *p_mapping; // r1
  unsigned __int32 v12; // r6
  int32x4_t v13; // q8
  float32x4_t v14; // q9
  CRect *result; // r0

  numEntries = this->m_Mappings.numEntries;
  if ( !numEntries )
  {
    v10 = 0;
    v9 = 0;
    if ( pszCharacters )
      goto LABEL_23;
LABEL_26:
    v12 = v9;
    goto LABEL_29;
  }
  v8 = 0;
  v9 = 0;
  v10 = 0;
  p_mapping = &this->m_Mappings.dataPtr->mapping;
  do
  {
    if ( *p_mapping == Mapping )
    {
      switch ( *((_DWORD *)p_mapping - 1) )
      {
        case 0:
        case 1:
        case 2:
        case 3:
          v9 = 1;
          v10 = *((_DWORD *)p_mapping - 1);
          break;
        case 4:
          v9 = 0;
          goto LABEL_20;
        case 5:
          v10 = 0;
          v9 = 0;
          break;
        case 6:
          v10 = 2;
          v9 = 2;
          break;
        case 7:
          v9 = 2;
          v10 = 3;
          break;
        case 8:
          v9 = 3;
          v10 = 4;
          break;
        case 9:
          v9 = 3;
          goto LABEL_20;
        case 0xA:
          v9 = 3;
          v10 = 2;
          break;
        case 0xB:
          v10 = 3;
          v9 = 3;
          break;
        case 0xC:
          v9 = 5;
          v10 = 0;
          break;
        case 0xD:
          v9 = 6;
          v10 = 0;
          break;
        case 0x40:
        case 0x41:
          v9 = 3;
          v10 = 0;
          break;
        case 0x42:
        case 0x43:
          v9 = 4;
          v10 = 0;
          break;
        case 0x44:
          v9 = 2;
          v10 = 0;
          break;
        case 0x45:
          v9 = 2;
LABEL_20:
          v10 = 1;
          break;
        default:
          break;
      }
    }
    ++v8;
    p_mapping += 5;
  }
  while ( v8 < numEntries );
  if ( !pszCharacters )
    goto LABEL_26;
LABEL_23:
  if ( strstr((const char *)pszCharacters, "widget_ped_move_left") )
  {
LABEL_24:
    v12 = 5;
    v10 = 2;
    goto LABEL_29;
  }
  if ( strstr((const char *)pszCharacters, "widget_ped_move_right") )
    goto LABEL_28;
  if ( strstr((const char *)pszCharacters, "widget_vehicle_steer_left") )
    goto LABEL_24;
  if ( strstr((const char *)pszCharacters, "widget_vehicle_steer_right") )
  {
LABEL_28:
    v12 = 5;
    v10 = 3;
    goto LABEL_29;
  }
  v12 = 5;
  if ( strstr((const char *)pszCharacters, "widget_ped_move_up") )
  {
    v10 = 4;
  }
  else if ( strstr((const char *)pszCharacters, "widget_ped_move_down") )
  {
    v10 = 1;
  }
  else
  {
    v12 = v9;
  }
LABEL_29:
  v13.n128_u32[0] = v10;
  v14.n128_u64[0] = 0x3E0000003E000000LL;
  v14.n128_u64[1] = 0x3E0000003E000000LL;
  v13.n128_u32[2] = v10 + 1;
  result = (CRect *)(v12 + 1);
  v13.n128_u32[1] = v12 + 1;
  v13.n128_u32[3] = v12;
  *(float32x4_t *)retstr = vmulq_f32(vcvtq_f32_s32(v13), v14);
  return result;
}

//----- (0028F3AC) --------------------------------------------------------
void __fastcall CHIDJoystickMogaPro::~CHIDJoystickMogaPro(CHIDJoystickMogaPro *this)
{
  JoystickButtonMapping *dataPtr; // r0

  this->_vptr$CHID = (int (**)(void))&off_6620DC;
  CSprite2d::~CSprite2d(&this->m_Sprite);
  dataPtr = this->m_Mappings.dataPtr;
  this->m_Mappings.numEntries = 0;
  if ( dataPtr )
    free(dataPtr);
  sub_191374(this);
}
// 6620DC: using guessed type void *off_6620DC;

//----- (0028F3E0) --------------------------------------------------------
void __fastcall CHIDJoystickPS3::CHIDJoystickPS3(CHIDJoystickPS3 *this, const unsigned __int8 *pszIconSprite)
{
  CHIDJoystick::CHIDJoystick(this, pszIconSprite);
  this->_vptr$CHID = (int (**)(void))&off_66237C;
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_SPRINT);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_ACCELERATE);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_ATTACK);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_JUMP);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_BRAKE);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_ENTER_CAR);
  CHIDJoystick::AddMapping(this, 5, HID_MAPPING_CAMERA_CLOSER);
  CHIDJoystick::AddMapping(this, 5, HID_MAPPING_CAMERA_FARTHER);
  CHIDJoystick::AddMapping(this, 8, HID_MAPPING_RADIO_PREV_STATION);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_RADIO_NEXT_STATION);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_VITAL_STATS);
  CHIDJoystick::AddMapping(this, 68, HID_MAPPING_PREV_WEAPON);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_HANDBRAKE);
  CHIDJoystick::AddMapping(this, 69, HID_MAPPING_NEXT_WEAPON);
  CHIDJoystick::AddMapping(this, 12, HID_MAPPING_CROUCH);
  CHIDJoystick::AddMapping(this, 12, HID_MAPPING_HORN);
  CHIDJoystick::AddMapping(this, 13, HID_MAPPING_PED_LOOK_BACK);
  CHIDJoystick::AddMapping(this, 4, HID_MAPPING_RADAR);
  CHIDJoystick::AddMapping(this, 68, HID_MAPPING_VEHICLE_LOOK_LEFT);
  CHIDJoystick::AddMapping(this, 69, HID_MAPPING_VEHICLE_LOOK_RIGHT);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_MISSION_START_AND_CANCEL);
  CHIDJoystick::AddMapping(this, 13, HID_MAPPING_MISSION_START_AND_CANCEL_VIGILANTE);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_AUTO_HYDRAULICS);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_SWAP_WEAPONS_AND_PURCHASE);
  CHIDJoystick::AddMapping(this, 68, HID_MAPPING_WEAPON_ZOOM_IN);
  CHIDJoystick::AddMapping(this, 69, HID_MAPPING_WEAPON_ZOOM_OUT);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_ENTER_AND_EXIT_TARGETING);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_VEHICLE_BOMB);
  CHIDJoystick::AddMapping(this, 68, HID_MAPPING_TURRET_LEFT);
  CHIDJoystick::AddMapping(this, 69, HID_MAPPING_TURRET_RIGHT);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_VEHICLE_STEER_X);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_VEHICLE_STEER_Y);
  CHIDJoystick::AddMapping(this, 66, HID_MAPPING_LOOK_X);
  CHIDJoystick::AddMapping(this, 67, HID_MAPPING_LOOK_Y);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_PED_MOVE_X);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_PED_MOVE_Y);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_MAGNET);
  CHIDJoystick::AddMapping(this, 4, HID_MAPPING_SKIP_CUTSCENE);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_SKIP_CUTSCENE);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_GANG_RECRUIT);
  CHIDJoystick::AddMapping(this, 11, HID_MAPPING_GANG_IGNORE);
  CHIDJoystick::AddMapping(this, 8, HID_MAPPING_GANG_FOLLOW);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_GANG_HOLD_POSITION);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_RHYTHM_UP);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_RHYTHM_DOWN);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_RHYTHM_LEFT);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_RHYTHM_RIGHT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_DROP_CRANE);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_DROP_ITEM);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_PHONE);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_NITRO);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_CRANE_UP);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_CRANE_DOWN);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_ACCEPT);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_CANCEL);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_GRAB);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_STINGER);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_MENU_DOWN);
  CHIDJoystick::AddMapping(this, 8, HID_MAPPING_MENU_UP);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_MENU_LEFT);
  CHIDJoystick::AddMapping(this, 11, HID_MAPPING_MENU_RIGHT);
  CHIDJoystick::AddMapping(this, 4, HID_MAPPING_MENU_ACCEPT);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_MENU_ACCEPT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_MENU_BACK);
  CHIDJoystick::AddMapping(this, 5, HID_MAPPING_MENU_MAP);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_ARCADE_BUTTON);
  CHIDJoystick::AddMapping(this, 5, HID_MAPPING_ARCADE_RESET);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_ARCADE_POWER_OFF);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_ARCADE_JOYSTICK);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_GYM_ACTION);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_GYM_EASIER_LEVEL);
  CHIDJoystick::AddMapping(this, 11, HID_MAPPING_GYM_HARDER_LEVEL);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_BLACK_JACK_SPLIT);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_BLACK_JACK_DOUBLE);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_BLACK_JACK_HIT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_BLACK_JACK_STAND);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_PLACE_BET);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_REMOVE_BET);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_WAYPOINT_BLIP);
  CHIDJoystick::AddMapping(this, 8, HID_MAPPING_HELICOPTER_MAGNET_UP);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_HELICOPTER_MAGNET_DOWN);
  CHIDJoystick::AddMapping(this, 13, HID_MAPPING_LOCK_HYDRAULICS);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_FLIGHT_PRIMARY_ATTACK);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_FLIGHT_SECONDARY_ATTACK);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_BASKETBALL_SHOOT);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_MAP_ZOOM_IN);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_MAP_ZOOM_OUT);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_TAKE_COVER_LEFT);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_TAKE_COVER_RIGHT);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_KISS);
}
// 66237C: using guessed type void *;

//----- (0028F780) --------------------------------------------------------
CRect *__fastcall CHIDJoystickPS3::FindUVsFromMapping(
        CRect *retstr,
        CHIDJoystickPS3 *this,
        const unsigned __int8 *pszCharacters,
        HIDMapping Mapping,
        bool bNegated)
{
  unsigned int numEntries; // r0
  unsigned int v8; // r2
  int v9; // r10
  unsigned __int32 v10; // r5
  HIDMapping *p_mapping; // r1
  unsigned __int32 v12; // r6
  int32x4_t v13; // q8
  float32x4_t v14; // q9
  CRect *result; // r0

  numEntries = this->m_Mappings.numEntries;
  if ( !numEntries )
  {
    v10 = 0;
    v9 = 0;
    if ( pszCharacters )
      goto LABEL_23;
LABEL_26:
    v12 = v9;
    goto LABEL_29;
  }
  v8 = 0;
  v9 = 0;
  v10 = 0;
  p_mapping = &this->m_Mappings.dataPtr->mapping;
  do
  {
    if ( *p_mapping == Mapping )
    {
      switch ( *((_DWORD *)p_mapping - 1) )
      {
        case 0:
        case 1:
        case 2:
        case 3:
          v9 = 1;
          v10 = *((_DWORD *)p_mapping - 1);
          break;
        case 4:
          v9 = 0;
          goto LABEL_20;
        case 5:
          v10 = 0;
          v9 = 0;
          break;
        case 6:
          v10 = 2;
          v9 = 2;
          break;
        case 7:
          v9 = 2;
          v10 = 3;
          break;
        case 8:
          v9 = 3;
          v10 = 4;
          break;
        case 9:
          v9 = 3;
          goto LABEL_20;
        case 0xA:
          v9 = 3;
          v10 = 2;
          break;
        case 0xB:
          v10 = 3;
          v9 = 3;
          break;
        case 0xC:
          v9 = 5;
          v10 = 0;
          break;
        case 0xD:
          v9 = 6;
          v10 = 0;
          break;
        case 0x40:
        case 0x41:
          v9 = 3;
          v10 = 0;
          break;
        case 0x42:
        case 0x43:
          v9 = 4;
          v10 = 0;
          break;
        case 0x44:
          v9 = 2;
          v10 = 0;
          break;
        case 0x45:
          v9 = 2;
LABEL_20:
          v10 = 1;
          break;
        default:
          break;
      }
    }
    ++v8;
    p_mapping += 5;
  }
  while ( v8 < numEntries );
  if ( !pszCharacters )
    goto LABEL_26;
LABEL_23:
  if ( strstr((const char *)pszCharacters, "widget_ped_move_left") )
  {
LABEL_24:
    v12 = 5;
    v10 = 2;
    goto LABEL_29;
  }
  if ( strstr((const char *)pszCharacters, "widget_ped_move_right") )
    goto LABEL_28;
  if ( strstr((const char *)pszCharacters, "widget_vehicle_steer_left") )
    goto LABEL_24;
  if ( strstr((const char *)pszCharacters, "widget_vehicle_steer_right") )
  {
LABEL_28:
    v12 = 5;
    v10 = 3;
    goto LABEL_29;
  }
  v12 = 5;
  if ( strstr((const char *)pszCharacters, "widget_ped_move_up") )
  {
    v10 = 4;
  }
  else if ( strstr((const char *)pszCharacters, "widget_ped_move_down") )
  {
    v10 = 1;
  }
  else
  {
    v12 = v9;
  }
LABEL_29:
  v13.n128_u32[0] = v10;
  v14.n128_u64[0] = 0x3E0000003E000000LL;
  v14.n128_u64[1] = 0x3E0000003E000000LL;
  v13.n128_u32[2] = v10 + 1;
  result = (CRect *)(v12 + 1);
  v13.n128_u32[1] = v12 + 1;
  v13.n128_u32[3] = v12;
  *(float32x4_t *)retstr = vmulq_f32(vcvtq_f32_s32(v13), v14);
  return result;
}

//----- (0028F9A4) --------------------------------------------------------
void __fastcall CHIDJoystickPS3::~CHIDJoystickPS3(CHIDJoystickPS3 *this)
{
  JoystickButtonMapping *dataPtr; // r0

  this->_vptr$CHID = (int (**)(void))&off_6620DC;
  CSprite2d::~CSprite2d(&this->m_Sprite);
  dataPtr = this->m_Mappings.dataPtr;
  this->m_Mappings.numEntries = 0;
  if ( dataPtr )
    free(dataPtr);
  sub_191374(this);
}
// 6620DC: using guessed type void *off_6620DC;

//----- (0028F9D8) --------------------------------------------------------
void __fastcall CHIDJoystickXbox360::CHIDJoystickXbox360(
        CHIDJoystickXbox360 *this,
        const unsigned __int8 *pszIconSprite)
{
  CHIDJoystick::CHIDJoystick(this, pszIconSprite);
  this->_vptr$CHID = (int (**)(void))&off_6623DC;
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_SPRINT);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_ACCELERATE);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_ATTACK);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_JUMP);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_BRAKE);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_ENTER_CAR);
  CHIDJoystick::AddMapping(this, 5, HID_MAPPING_CAMERA_CLOSER);
  CHIDJoystick::AddMapping(this, 5, HID_MAPPING_CAMERA_FARTHER);
  CHIDJoystick::AddMapping(this, 8, HID_MAPPING_RADIO_PREV_STATION);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_RADIO_NEXT_STATION);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_VITAL_STATS);
  CHIDJoystick::AddMapping(this, 68, HID_MAPPING_PREV_WEAPON);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_HANDBRAKE);
  CHIDJoystick::AddMapping(this, 69, HID_MAPPING_NEXT_WEAPON);
  CHIDJoystick::AddMapping(this, 12, HID_MAPPING_CROUCH);
  CHIDJoystick::AddMapping(this, 12, HID_MAPPING_HORN);
  CHIDJoystick::AddMapping(this, 13, HID_MAPPING_PED_LOOK_BACK);
  CHIDJoystick::AddMapping(this, 4, HID_MAPPING_RADAR);
  CHIDJoystick::AddMapping(this, 68, HID_MAPPING_VEHICLE_LOOK_LEFT);
  CHIDJoystick::AddMapping(this, 69, HID_MAPPING_VEHICLE_LOOK_RIGHT);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_MISSION_START_AND_CANCEL);
  CHIDJoystick::AddMapping(this, 13, HID_MAPPING_MISSION_START_AND_CANCEL_VIGILANTE);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_AUTO_HYDRAULICS);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_SWAP_WEAPONS_AND_PURCHASE);
  CHIDJoystick::AddMapping(this, 68, HID_MAPPING_WEAPON_ZOOM_IN);
  CHIDJoystick::AddMapping(this, 69, HID_MAPPING_WEAPON_ZOOM_OUT);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_ENTER_AND_EXIT_TARGETING);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_VEHICLE_BOMB);
  CHIDJoystick::AddMapping(this, 68, HID_MAPPING_TURRET_LEFT);
  CHIDJoystick::AddMapping(this, 69, HID_MAPPING_TURRET_RIGHT);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_VEHICLE_STEER_X);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_VEHICLE_STEER_Y);
  CHIDJoystick::AddMapping(this, 66, HID_MAPPING_LOOK_X);
  CHIDJoystick::AddMapping(this, 67, HID_MAPPING_LOOK_Y);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_PED_MOVE_X);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_PED_MOVE_Y);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_MAGNET);
  CHIDJoystick::AddMapping(this, 4, HID_MAPPING_SKIP_CUTSCENE);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_SKIP_CUTSCENE);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_GANG_RECRUIT);
  CHIDJoystick::AddMapping(this, 11, HID_MAPPING_GANG_IGNORE);
  CHIDJoystick::AddMapping(this, 8, HID_MAPPING_GANG_FOLLOW);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_GANG_HOLD_POSITION);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_RHYTHM_UP);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_RHYTHM_DOWN);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_RHYTHM_LEFT);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_RHYTHM_RIGHT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_DROP_CRANE);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_DROP_ITEM);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_PHONE);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_NITRO);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_CRANE_UP);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_CRANE_DOWN);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_ACCEPT);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_CANCEL);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_GRAB);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_STINGER);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_MENU_DOWN);
  CHIDJoystick::AddMapping(this, 8, HID_MAPPING_MENU_UP);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_MENU_LEFT);
  CHIDJoystick::AddMapping(this, 11, HID_MAPPING_MENU_RIGHT);
  CHIDJoystick::AddMapping(this, 4, HID_MAPPING_MENU_ACCEPT);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_MENU_ACCEPT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_MENU_BACK);
  CHIDJoystick::AddMapping(this, 5, HID_MAPPING_MENU_MAP);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_ARCADE_BUTTON);
  CHIDJoystick::AddMapping(this, 5, HID_MAPPING_ARCADE_RESET);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_ARCADE_POWER_OFF);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_ARCADE_JOYSTICK);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_GYM_ACTION);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_GYM_EASIER_LEVEL);
  CHIDJoystick::AddMapping(this, 11, HID_MAPPING_GYM_HARDER_LEVEL);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_BLACK_JACK_SPLIT);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_BLACK_JACK_DOUBLE);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_BLACK_JACK_HIT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_BLACK_JACK_STAND);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_PLACE_BET);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_REMOVE_BET);
  CHIDJoystick::AddMapping(this, 68, HID_MAPPING_PREV_TARGET);
  CHIDJoystick::AddMapping(this, 69, HID_MAPPING_NEXT_TARGET);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_WAYPOINT_BLIP);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_HELICOPTER_MAGNET_UP);
  CHIDJoystick::AddMapping(this, 11, HID_MAPPING_HELICOPTER_MAGNET_DOWN);
  CHIDJoystick::AddMapping(this, 13, HID_MAPPING_LOCK_HYDRAULICS);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_FLIGHT_PRIMARY_ATTACK);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_FLIGHT_SECONDARY_ATTACK);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_BASKETBALL_SHOOT);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_BUNNY_HOP);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_MAP_ZOOM_IN);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_MAP_ZOOM_OUT);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_ALT_ATTACK);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_BLOCK);
  CHIDJoystick::AddMapping(this, 68, HID_MAPPING_TAKE_COVER_LEFT);
  CHIDJoystick::AddMapping(this, 69, HID_MAPPING_TAKE_COVER_RIGHT);
  CHIDJoystick::AddMapping(this, 12, HID_MAPPING_TOGGLE_LANDING_GEAR);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_KISS);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_DANCING_UP);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_DANCING_DOWN);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_DANCING_LEFT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_DANCING_RIGHT);
}
// 6623DC: using guessed type void *;

//----- (0028FDDC) --------------------------------------------------------
CRect *__fastcall CHIDJoystickXbox360::FindUVsFromMapping(
        CRect *retstr,
        CHIDJoystickXbox360 *this,
        const unsigned __int8 *pszCharacters,
        HIDMapping Mapping,
        bool bNegated)
{
  unsigned int numEntries; // r0
  unsigned int v8; // r2
  int v9; // r10
  unsigned __int32 v10; // r5
  HIDMapping *p_mapping; // r1
  unsigned __int32 v12; // r6
  int32x4_t v13; // q8
  float32x4_t v14; // q9
  CRect *result; // r0

  numEntries = this->m_Mappings.numEntries;
  if ( !numEntries )
  {
    v10 = 0;
    v9 = 0;
    if ( pszCharacters )
      goto LABEL_23;
LABEL_26:
    v12 = v9;
    goto LABEL_29;
  }
  v8 = 0;
  v9 = 0;
  v10 = 0;
  p_mapping = &this->m_Mappings.dataPtr->mapping;
  do
  {
    if ( *p_mapping == Mapping )
    {
      switch ( *((_DWORD *)p_mapping - 1) )
      {
        case 0:
        case 1:
        case 2:
        case 3:
          v9 = 1;
          v10 = *((_DWORD *)p_mapping - 1);
          break;
        case 4:
          v9 = 0;
          goto LABEL_20;
        case 5:
          v10 = 0;
          v9 = 0;
          break;
        case 6:
          v10 = 2;
          v9 = 2;
          break;
        case 7:
          v9 = 2;
          v10 = 3;
          break;
        case 8:
          v9 = 3;
          v10 = 4;
          break;
        case 9:
          v9 = 3;
          goto LABEL_20;
        case 0xA:
          v9 = 3;
          v10 = 2;
          break;
        case 0xB:
          v10 = 3;
          v9 = 3;
          break;
        case 0xC:
          v9 = 5;
          v10 = 0;
          break;
        case 0xD:
          v9 = 6;
          v10 = 0;
          break;
        case 0x40:
        case 0x41:
          v9 = 3;
          v10 = 0;
          break;
        case 0x42:
        case 0x43:
          v9 = 4;
          v10 = 0;
          break;
        case 0x44:
          v9 = 2;
          v10 = 0;
          break;
        case 0x45:
          v9 = 2;
LABEL_20:
          v10 = 1;
          break;
        default:
          break;
      }
    }
    ++v8;
    p_mapping += 5;
  }
  while ( v8 < numEntries );
  if ( !pszCharacters )
    goto LABEL_26;
LABEL_23:
  if ( strstr((const char *)pszCharacters, "widget_ped_move_left") )
  {
LABEL_24:
    v12 = 5;
    v10 = 2;
    goto LABEL_29;
  }
  if ( strstr((const char *)pszCharacters, "widget_ped_move_right") )
    goto LABEL_28;
  if ( strstr((const char *)pszCharacters, "widget_vehicle_steer_left") )
    goto LABEL_24;
  if ( strstr((const char *)pszCharacters, "widget_vehicle_steer_right") )
  {
LABEL_28:
    v12 = 5;
    v10 = 3;
    goto LABEL_29;
  }
  v12 = 5;
  if ( strstr((const char *)pszCharacters, "widget_ped_move_up") )
  {
    v10 = 4;
  }
  else if ( strstr((const char *)pszCharacters, "widget_ped_move_down") )
  {
    v10 = 1;
  }
  else
  {
    v12 = v9;
  }
LABEL_29:
  v13.n128_u32[0] = v10;
  v14.n128_u64[0] = 0x3E0000003E000000LL;
  v14.n128_u64[1] = 0x3E0000003E000000LL;
  v13.n128_u32[2] = v10 + 1;
  result = (CRect *)(v12 + 1);
  v13.n128_u32[1] = v12 + 1;
  v13.n128_u32[3] = v12;
  *(float32x4_t *)retstr = vmulq_f32(vcvtq_f32_s32(v13), v14);
  return result;
}

//----- (00290000) --------------------------------------------------------
void __fastcall CHIDJoystickXbox360::~CHIDJoystickXbox360(CHIDJoystickXbox360 *this)
{
  JoystickButtonMapping *dataPtr; // r0

  this->_vptr$CHID = (int (**)(void))&off_6620DC;
  CSprite2d::~CSprite2d(&this->m_Sprite);
  dataPtr = this->m_Mappings.dataPtr;
  this->m_Mappings.numEntries = 0;
  if ( dataPtr )
    free(dataPtr);
  sub_191374(this);
}
// 6620DC: using guessed type void *off_6620DC;

//----- (00290034) --------------------------------------------------------
void __fastcall CHIDJoystickXbox360Standard::CHIDJoystickXbox360Standard(
        CHIDJoystickXbox360Standard *this,
        const unsigned __int8 *pszIconSprite)
{
  CHIDJoystick::CHIDJoystick(this, pszIconSprite);
  this->_vptr$CHID = (int (**)(void))&off_66243C;
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_SPRINT);
  CHIDJoystick::AddMapping(this, 69, HID_MAPPING_ACCELERATE);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_ATTACK);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_JUMP);
  CHIDJoystick::AddMapping(this, 68, HID_MAPPING_BRAKE);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_ENTER_CAR);
  CHIDJoystick::AddMapping(this, 5, HID_MAPPING_CAMERA_CLOSER);
  CHIDJoystick::AddMapping(this, 5, HID_MAPPING_CAMERA_FARTHER);
  CHIDJoystick::AddMapping(this, 8, HID_MAPPING_RADIO_PREV_STATION);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_RADIO_NEXT_STATION);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_VITAL_STATS);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_PREV_WEAPON);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_HANDBRAKE);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_NEXT_WEAPON);
  CHIDJoystick::AddMapping(this, 12, HID_MAPPING_CROUCH);
  CHIDJoystick::AddMapping(this, 12, HID_MAPPING_HORN);
  CHIDJoystick::AddMapping(this, 13, HID_MAPPING_PED_LOOK_BACK);
  CHIDJoystick::AddMapping(this, 4, HID_MAPPING_RADAR);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_VEHICLE_LOOK_LEFT);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_VEHICLE_LOOK_RIGHT);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_MISSION_START_AND_CANCEL);
  CHIDJoystick::AddMapping(this, 13, HID_MAPPING_MISSION_START_AND_CANCEL_VIGILANTE);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_AUTO_HYDRAULICS);
  CHIDJoystick::AddMapping(this, 68, HID_MAPPING_SWAP_WEAPONS_AND_PURCHASE);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_WEAPON_ZOOM_IN);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_WEAPON_ZOOM_OUT);
  CHIDJoystick::AddMapping(this, 69, HID_MAPPING_ENTER_AND_EXIT_TARGETING);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_VEHICLE_BOMB);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_TURRET_LEFT);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_TURRET_RIGHT);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_VEHICLE_STEER_X);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_VEHICLE_STEER_Y);
  CHIDJoystick::AddMapping(this, 66, HID_MAPPING_LOOK_X);
  CHIDJoystick::AddMapping(this, 67, HID_MAPPING_LOOK_Y);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_PED_MOVE_X);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_PED_MOVE_Y);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_MAGNET);
  CHIDJoystick::AddMapping(this, 4, HID_MAPPING_SKIP_CUTSCENE);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_SKIP_CUTSCENE);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_GANG_RECRUIT);
  CHIDJoystick::AddMapping(this, 11, HID_MAPPING_GANG_IGNORE);
  CHIDJoystick::AddMapping(this, 8, HID_MAPPING_GANG_FOLLOW);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_GANG_HOLD_POSITION);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_RHYTHM_UP);
  CHIDJoystick::AddMapping(this, 65, HID_MAPPING_RHYTHM_DOWN);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_RHYTHM_LEFT);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_RHYTHM_RIGHT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_DROP_CRANE);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_DROP_ITEM);
  CHIDJoystick::AddMapping(this, 68, HID_MAPPING_PHONE);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_NITRO);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_CRANE_UP);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_CRANE_DOWN);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_ACCEPT);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_CANCEL);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_GRAB);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_STINGER);
  CHIDJoystick::AddMapping(this, 9, HID_MAPPING_MENU_DOWN);
  CHIDJoystick::AddMapping(this, 8, HID_MAPPING_MENU_UP);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_MENU_LEFT);
  CHIDJoystick::AddMapping(this, 11, HID_MAPPING_MENU_RIGHT);
  CHIDJoystick::AddMapping(this, 4, HID_MAPPING_MENU_ACCEPT);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_MENU_ACCEPT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_MENU_BACK);
  CHIDJoystick::AddMapping(this, 5, HID_MAPPING_MENU_MAP);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_ARCADE_BUTTON);
  CHIDJoystick::AddMapping(this, 5, HID_MAPPING_ARCADE_RESET);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_ARCADE_POWER_OFF);
  CHIDJoystick::AddMapping(this, 64, HID_MAPPING_ARCADE_JOYSTICK);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_GYM_ACTION);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_GYM_EASIER_LEVEL);
  CHIDJoystick::AddMapping(this, 11, HID_MAPPING_GYM_HARDER_LEVEL);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_BLACK_JACK_SPLIT);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_BLACK_JACK_DOUBLE);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_BLACK_JACK_HIT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_BLACK_JACK_STAND);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_PLACE_BET);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_REMOVE_BET);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_PREV_TARGET);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_NEXT_TARGET);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_WAYPOINT_BLIP);
  CHIDJoystick::AddMapping(this, 10, HID_MAPPING_HELICOPTER_MAGNET_UP);
  CHIDJoystick::AddMapping(this, 11, HID_MAPPING_HELICOPTER_MAGNET_DOWN);
  CHIDJoystick::AddMapping(this, 13, HID_MAPPING_LOCK_HYDRAULICS);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_FLIGHT_PRIMARY_ATTACK);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_FLIGHT_SECONDARY_ATTACK);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_BASKETBALL_SHOOT);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_BUNNY_HOP);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_MAP_ZOOM_IN);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_MAP_ZOOM_OUT);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_ALT_ATTACK);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_BLOCK);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_TAKE_COVER_LEFT);
  CHIDJoystick::AddMapping(this, 7, HID_MAPPING_TAKE_COVER_RIGHT);
  CHIDJoystick::AddMapping(this, 12, HID_MAPPING_TOGGLE_LANDING_GEAR);
  CHIDJoystick::AddMapping(this, 6, HID_MAPPING_KISS);
  CHIDJoystick::AddMapping(this, 3, HID_MAPPING_DANCING_UP);
  CHIDJoystick::AddMapping(this, 0, HID_MAPPING_DANCING_DOWN);
  CHIDJoystick::AddMapping(this, 2, HID_MAPPING_DANCING_LEFT);
  CHIDJoystick::AddMapping(this, 1, HID_MAPPING_DANCING_RIGHT);
}
// 66243C: using guessed type void *;

//----- (00290438) --------------------------------------------------------
CRect *__fastcall CHIDJoystickXbox360Standard::FindUVsFromMapping(
        CRect *retstr,
        CHIDJoystickXbox360Standard *this,
        const unsigned __int8 *pszCharacters,
        HIDMapping Mapping,
        bool bNegated)
{
  unsigned int numEntries; // r0
  unsigned int v8; // r2
  int v9; // r10
  unsigned __int32 v10; // r5
  HIDMapping *p_mapping; // r1
  unsigned __int32 v12; // r6
  int32x4_t v13; // q8
  float32x4_t v14; // q9
  CRect *result; // r0

  numEntries = this->m_Mappings.numEntries;
  if ( !numEntries )
  {
    v10 = 0;
    v9 = 0;
    if ( pszCharacters )
      goto LABEL_23;
LABEL_26:
    v12 = v9;
    goto LABEL_29;
  }
  v8 = 0;
  v9 = 0;
  v10 = 0;
  p_mapping = &this->m_Mappings.dataPtr->mapping;
  do
  {
    if ( *p_mapping == Mapping )
    {
      switch ( *((_DWORD *)p_mapping - 1) )
      {
        case 0:
        case 1:
        case 2:
        case 3:
          v9 = 1;
          v10 = *((_DWORD *)p_mapping - 1);
          break;
        case 4:
          v9 = 0;
          goto LABEL_20;
        case 5:
          v10 = 0;
          v9 = 0;
          break;
        case 6:
          v10 = 2;
          v9 = 2;
          break;
        case 7:
          v9 = 2;
          v10 = 3;
          break;
        case 8:
          v9 = 3;
          v10 = 4;
          break;
        case 9:
          v9 = 3;
          goto LABEL_20;
        case 0xA:
          v9 = 3;
          v10 = 2;
          break;
        case 0xB:
          v10 = 3;
          v9 = 3;
          break;
        case 0xC:
          v9 = 5;
          v10 = 0;
          break;
        case 0xD:
          v9 = 6;
          v10 = 0;
          break;
        case 0x40:
        case 0x41:
          v9 = 3;
          v10 = 0;
          break;
        case 0x42:
        case 0x43:
          v9 = 4;
          v10 = 0;
          break;
        case 0x44:
          v9 = 2;
          v10 = 0;
          break;
        case 0x45:
          v9 = 2;
LABEL_20:
          v10 = 1;
          break;
        default:
          break;
      }
    }
    ++v8;
    p_mapping += 5;
  }
  while ( v8 < numEntries );
  if ( !pszCharacters )
    goto LABEL_26;
LABEL_23:
  if ( strstr((const char *)pszCharacters, "widget_ped_move_left") )
  {
LABEL_24:
    v12 = 5;
    v10 = 2;
    goto LABEL_29;
  }
  if ( strstr((const char *)pszCharacters, "widget_ped_move_right") )
    goto LABEL_28;
  if ( strstr((const char *)pszCharacters, "widget_vehicle_steer_left") )
    goto LABEL_24;
  if ( strstr((const char *)pszCharacters, "widget_vehicle_steer_right") )
  {
LABEL_28:
    v12 = 5;
    v10 = 3;
    goto LABEL_29;
  }
  v12 = 5;
  if ( strstr((const char *)pszCharacters, "widget_ped_move_up") )
  {
    v10 = 4;
  }
  else if ( strstr((const char *)pszCharacters, "widget_ped_move_down") )
  {
    v10 = 1;
  }
  else
  {
    v12 = v9;
  }
LABEL_29:
  v13.n128_u32[0] = v10;
  v14.n128_u64[0] = 0x3E0000003E000000LL;
  v14.n128_u64[1] = 0x3E0000003E000000LL;
  v13.n128_u32[2] = v10 + 1;
  result = (CRect *)(v12 + 1);
  v13.n128_u32[1] = v12 + 1;
  v13.n128_u32[3] = v12;
  *(float32x4_t *)retstr = vmulq_f32(vcvtq_f32_s32(v13), v14);
  return result;
}

//----- (0029065C) --------------------------------------------------------
void __fastcall CHIDJoystickXbox360Standard::~CHIDJoystickXbox360Standard(CHIDJoystickXbox360Standard *this)
{
  JoystickButtonMapping *dataPtr; // r0

  this->_vptr$CHID = (int (**)(void))&off_6620DC;
  CSprite2d::~CSprite2d(&this->m_Sprite);
  dataPtr = this->m_Mappings.dataPtr;
  this->m_Mappings.numEntries = 0;
  if ( dataPtr )
    free(dataPtr);
  sub_191374(this);
}
// 6620DC: using guessed type void *off_6620DC;

//----- (00290690) --------------------------------------------------------
void __fastcall CHIDKeyboard::CHIDKeyboard(CHIDKeyboard *this, const unsigned __int8 *pszIconSprite)
{
  unsigned int v3; // r1
  _QWORD *v4; // r6
  CHIDKeyboard *v5; // r3
  KeyPair *dataPtr; // r5
  unsigned int numEntries; // r0
  KeyPair *v8; // r0
  unsigned int v9; // r0
  unsigned int v10; // r4
  unsigned int v11; // r0
  unsigned int v12; // r9
  KeyPair *v13; // r5
  KeyPair *v14; // r6
  KeyPair *v15; // r2
  unsigned int v16; // r1
  unsigned int v17; // r4
  unsigned int v18; // r9
  KeyPair *v19; // r5
  KeyPair *v20; // r6
  KeyPair *v21; // r0
  unsigned int v22; // r1
  unsigned int v23; // r4
  unsigned int v24; // r1
  unsigned int v25; // r9
  KeyPair *v26; // r5
  KeyPair *v27; // r6
  KeyPair *v28; // r2
  unsigned int v29; // r1
  unsigned int v30; // r4
  unsigned int v31; // r9
  KeyPair *v32; // r5
  KeyPair *v33; // r6
  KeyPair *v34; // r2
  unsigned int v35; // r1
  unsigned int v36; // r4
  unsigned int v37; // r9
  KeyPair *v38; // r5
  KeyPair *v39; // r6
  KeyPair *v40; // r2
  unsigned int v41; // r1
  unsigned int v42; // r4
  unsigned int v43; // r9
  KeyPair *v44; // r5
  KeyPair *v45; // r6
  KeyPair *v46; // r2
  unsigned int v47; // r1
  unsigned int v48; // r4
  unsigned int v49; // r9
  KeyPair *v50; // r5
  KeyPair *v51; // r6
  KeyPair *v52; // r2
  unsigned int v53; // r1
  unsigned int v54; // r9
  unsigned int v55; // r4
  KeyPair *v56; // r5
  KeyPair *v57; // r6
  KeyPair *v58; // r2
  unsigned int v59; // r1
  unsigned int v60; // r4
  unsigned int v61; // r9
  KeyPair *v62; // r5
  KeyPair *v63; // r6
  KeyPair *v64; // r2
  unsigned int v65; // r1
  unsigned int v66; // r4
  unsigned int v67; // r9
  KeyPair *v68; // r5
  KeyPair *v69; // r6
  KeyPair *v70; // r2
  unsigned int v71; // r1
  unsigned int v72; // r4
  unsigned int v73; // r9
  KeyPair *v74; // r5
  KeyPair *v75; // r6
  KeyPair *v76; // r2
  unsigned int v77; // r1
  unsigned int v78; // r4
  unsigned int v79; // r9
  KeyPair *v80; // r5
  KeyPair *v81; // r6
  KeyPair *v82; // r2
  unsigned int v83; // r1
  unsigned int v84; // r4
  unsigned int v85; // r9
  KeyPair *v86; // r5
  KeyPair *v87; // r6
  KeyPair *v88; // r2
  unsigned int v89; // r1
  unsigned int v90; // r4
  unsigned int v91; // r9
  KeyPair *v92; // r5
  KeyPair *v93; // r6
  KeyPair *v94; // r2
  unsigned int v95; // r1
  unsigned int v96; // r4
  unsigned int v97; // r9
  KeyPair *v98; // r5
  KeyPair *v99; // r6
  KeyPair *v100; // r2
  unsigned int v101; // r1
  unsigned int v102; // r4
  unsigned int v103; // r9
  KeyPair *v104; // r5
  KeyPair *v105; // r6
  KeyPair *v106; // r2
  unsigned int v107; // r1
  unsigned int v108; // r4
  unsigned int v109; // r9
  KeyPair *v110; // r5
  KeyPair *v111; // r6
  KeyPair *v112; // r2
  unsigned int v113; // r1
  unsigned int v114; // r4
  unsigned int v115; // r9
  KeyPair *v116; // r5
  KeyPair *v117; // r6
  KeyPair *v118; // r2
  unsigned int v119; // r1
  unsigned int v120; // r4
  unsigned int v121; // r9
  KeyPair *v122; // r5
  KeyPair *v123; // r6
  KeyPair *v124; // r2
  unsigned int v125; // r1
  unsigned int v126; // r4
  unsigned int v127; // r9
  KeyPair *v128; // r5
  KeyPair *v129; // r6
  KeyPair *v130; // r2
  unsigned int v131; // r1
  unsigned int v132; // r4
  unsigned int v133; // r9
  KeyPair *v134; // r5
  KeyPair *v135; // r6
  KeyPair *v136; // r2
  unsigned int v137; // r1
  unsigned int v138; // r4
  unsigned int v139; // r9
  KeyPair *v140; // r5
  KeyPair *v141; // r6
  KeyPair *v142; // r2
  unsigned int v143; // r1
  unsigned int v144; // r4
  unsigned int v145; // r9
  KeyPair *v146; // r5
  KeyPair *v147; // r6
  KeyPair *v148; // r2
  unsigned int v149; // r1
  unsigned int v150; // r4
  unsigned int v151; // r9
  KeyPair *v152; // r5
  KeyPair *v153; // r6
  KeyPair *v154; // r2
  unsigned int v155; // r1
  unsigned int v156; // r4
  unsigned int v157; // r9
  KeyPair *v158; // r5
  KeyPair *v159; // r6
  KeyPair *v160; // r2
  unsigned int v161; // r1
  unsigned int v162; // r4
  unsigned int v163; // r9
  KeyPair *v164; // r5
  KeyPair *v165; // r6
  KeyPair *v166; // r2
  unsigned int v167; // r1
  unsigned int v168; // r4
  unsigned int v169; // r9
  KeyPair *v170; // r5
  KeyPair *v171; // r6
  KeyPair *v172; // r2
  unsigned int v173; // r1
  unsigned int v174; // r4
  unsigned int v175; // r9
  KeyPair *v176; // r5
  KeyPair *v177; // r6
  KeyPair *v178; // r2
  unsigned int v179; // r1
  unsigned int v180; // r4
  unsigned int v181; // r9
  KeyPair *v182; // r5
  KeyPair *v183; // r6
  KeyPair *v184; // r2
  unsigned int v185; // r1
  unsigned int v186; // r4
  unsigned int v187; // r9
  KeyPair *v188; // r5
  KeyPair *v189; // r6
  KeyPair *v190; // r2
  unsigned int v191; // r1
  unsigned int v192; // r4
  unsigned int v193; // r9
  KeyPair *v194; // r5
  KeyPair *v195; // r6
  KeyPair *v196; // r2
  unsigned int v197; // r1
  unsigned int v198; // r4
  unsigned int v199; // r9
  KeyPair *v200; // r5
  KeyPair *v201; // r6
  KeyPair *v202; // r2
  unsigned int v203; // r1
  unsigned int v204; // r4
  unsigned int v205; // r9
  KeyPair *v206; // r5
  KeyPair *v207; // r6
  KeyPair *v208; // r2
  unsigned int v209; // r1
  unsigned int v210; // r4
  unsigned int v211; // r9
  KeyPair *v212; // r5
  KeyPair *v213; // r6
  KeyPair *v214; // r2
  unsigned int v215; // r1
  unsigned int v216; // r4
  unsigned int v217; // r9
  KeyPair *v218; // r5
  KeyPair *v219; // r6
  KeyPair *v220; // r2
  unsigned int v221; // r1
  unsigned int v222; // r4
  unsigned int v223; // r9
  KeyPair *v224; // r5
  KeyPair *v225; // r6
  KeyPair *v226; // r2
  unsigned int v227; // r1
  unsigned int v228; // r4
  unsigned int v229; // r9
  KeyPair *v230; // r5
  KeyPair *v231; // r6
  KeyPair *v232; // r2
  unsigned int v233; // r1
  unsigned int v234; // r4
  unsigned int v235; // r9
  KeyPair *v236; // r5
  KeyPair *v237; // r6
  KeyPair *v238; // r2
  unsigned int v239; // r1
  unsigned int v240; // r4
  unsigned int v241; // r9
  KeyPair *v242; // r5
  KeyPair *v243; // r6
  KeyPair *v244; // r2
  unsigned int v245; // r1
  unsigned int v246; // r4
  unsigned int v247; // r9
  KeyPair *v248; // r5
  KeyPair *v249; // r6
  KeyPair *v250; // r2
  unsigned int v251; // r1
  unsigned int v252; // r4
  unsigned int v253; // r9
  KeyPair *v254; // r5
  KeyPair *v255; // r6
  KeyPair *v256; // r2
  unsigned int v257; // r1
  unsigned int v258; // r4
  unsigned int v259; // r9
  KeyPair *v260; // r5
  KeyPair *v261; // r6
  KeyPair *v262; // r2
  unsigned int v263; // r1
  unsigned int v264; // r4
  unsigned int v265; // r9
  KeyPair *v266; // r5
  KeyPair *v267; // r6
  KeyPair *v268; // r2
  unsigned int v269; // r1
  unsigned int v270; // r4
  unsigned int v271; // r9
  KeyPair *v272; // r5
  KeyPair *v273; // r6
  KeyPair *v274; // r2
  unsigned int v275; // r1
  unsigned int v276; // r4
  unsigned int v277; // r9
  KeyPair *v278; // r5
  KeyPair *v279; // r6
  KeyPair *v280; // r2
  unsigned int v281; // r1
  unsigned int v282; // r4
  unsigned int v283; // r9
  KeyPair *v284; // r5
  KeyPair *v285; // r6
  KeyPair *v286; // r2
  unsigned int v287; // r1
  unsigned int v288; // r4
  unsigned int v289; // r9
  KeyPair *v290; // r5
  KeyPair *v291; // r6
  KeyPair *v292; // r2
  unsigned int v293; // r1
  unsigned int v294; // r4
  unsigned int v295; // r9
  KeyPair *v296; // r5
  KeyPair *v297; // r6
  KeyPair *v298; // r2
  unsigned int v299; // r1
  unsigned int v300; // r4
  unsigned int v301; // r9
  KeyPair *v302; // r5
  KeyPair *v303; // r6
  KeyPair *v304; // r2
  unsigned int v305; // r1
  unsigned int v306; // r4
  unsigned int v307; // r9
  KeyPair *v308; // r5
  KeyPair *v309; // r6
  KeyPair *v310; // r2
  unsigned int v311; // r1
  unsigned int v312; // r4
  unsigned int v313; // r9
  KeyPair *v314; // r5
  KeyPair *v315; // r6
  KeyPair *v316; // r2
  unsigned int v317; // r1
  unsigned int v318; // r4
  unsigned int v319; // r9
  KeyPair *v320; // r5
  KeyPair *v321; // r6
  KeyPair *v322; // r2
  unsigned int v323; // r1
  unsigned int v324; // r4
  unsigned int v325; // r9
  KeyPair *v326; // r5
  KeyPair *v327; // r6
  KeyPair *v328; // r2
  unsigned int v329; // r1
  unsigned int v330; // r4
  unsigned int v331; // r9
  KeyPair *v332; // r5
  KeyPair *v333; // r6
  KeyPair *v334; // r2
  unsigned int v335; // r1
  unsigned int v336; // r4
  unsigned int v337; // r9
  KeyPair *v338; // r5
  KeyPair *v339; // r6
  KeyPair *v340; // r2
  unsigned int v341; // r1
  unsigned int v342; // r4
  unsigned int v343; // r9
  KeyPair *v344; // r5
  KeyPair *v345; // r6
  KeyPair *v346; // r2
  unsigned int v347; // r1
  unsigned int v348; // r4
  unsigned int v349; // r9
  KeyPair *v350; // r5
  KeyPair *v351; // r6
  KeyPair *v352; // r2
  unsigned int v353; // r1
  unsigned int v354; // r4
  unsigned int v355; // r9
  KeyPair *v356; // r5
  KeyPair *v357; // r6
  KeyPair *v358; // r2
  unsigned int v359; // r1
  unsigned int v360; // r4
  unsigned int v361; // r9
  KeyPair *v362; // r5
  KeyPair *v363; // r6
  KeyPair *v364; // r2
  unsigned int v365; // r1
  unsigned int v366; // r4
  unsigned int v367; // r9
  KeyPair *v368; // r5
  KeyPair *v369; // r6
  KeyPair *v370; // r2
  unsigned int v371; // r1
  unsigned int v372; // r4
  unsigned int v373; // r9
  KeyPair *v374; // r5
  KeyPair *v375; // r6
  KeyPair *v376; // r2
  unsigned int v377; // r1
  unsigned int v378; // r4
  unsigned int v379; // r9
  KeyPair *v380; // r5
  KeyPair *v381; // r6
  KeyPair *v382; // r2
  unsigned int v383; // r1
  unsigned int v384; // r4
  unsigned int v385; // r9
  KeyPair *v386; // r5
  KeyPair *v387; // r6
  KeyPair *v388; // r2
  unsigned int v389; // r1
  unsigned int v390; // r4
  unsigned int v391; // r9
  KeyPair *v392; // r5
  KeyPair *v393; // r6
  KeyPair *v394; // r2
  unsigned int v395; // r1
  unsigned int v396; // r4
  unsigned int v397; // r9
  KeyPair *v398; // r5
  KeyPair *v399; // r6
  KeyPair *v400; // r2
  unsigned int v401; // r1
  unsigned int v402; // r4
  unsigned int v403; // r9
  KeyPair *v404; // r5
  KeyPair *v405; // r6
  KeyPair *v406; // r2
  unsigned int v407; // r1
  unsigned int v408; // r4
  unsigned int v409; // r9
  KeyPair *v410; // r5
  KeyPair *v411; // r6
  KeyPair *v412; // r2
  unsigned int v413; // r1
  unsigned int v414; // r4
  unsigned int v415; // r9
  KeyPair *v416; // r5
  KeyPair *v417; // r6
  KeyPair *v418; // r2
  unsigned int v419; // r1
  unsigned int v420; // r4
  unsigned int v421; // r9
  KeyPair *v422; // r5
  KeyPair *v423; // r6
  KeyPair *v424; // r2
  unsigned int v425; // r1
  unsigned int v426; // r4
  unsigned int v427; // r9
  KeyPair *v428; // r5
  KeyPair *v429; // r6
  KeyPair *v430; // r2
  unsigned int v431; // r1
  unsigned int v432; // r4
  unsigned int v433; // r9
  KeyPair *v434; // r5
  KeyPair *v435; // r6
  KeyPair *v436; // r2
  unsigned int v437; // r1
  unsigned int v438; // r4
  unsigned int v439; // r9
  KeyPair *v440; // r5
  KeyPair *v441; // r6
  KeyPair *v442; // r2
  unsigned int v443; // r1
  unsigned int v444; // r4
  unsigned int v445; // r9
  KeyPair *v446; // r5
  KeyPair *v447; // r6
  KeyPair *v448; // r2
  unsigned int v449; // r1
  unsigned int v450; // r4
  unsigned int v451; // r9
  KeyPair *v452; // r5
  KeyPair *v453; // r6
  KeyPair *v454; // r2
  unsigned int v455; // r1
  unsigned int v456; // r4
  unsigned int v457; // r9
  KeyPair *v458; // r5
  KeyPair *v459; // r6
  KeyPair *v460; // r2
  unsigned int v461; // r1
  unsigned int v462; // r4
  unsigned int v463; // r9
  KeyPair *v464; // r5
  KeyPair *v465; // r6
  KeyPair *v466; // r2
  unsigned int v467; // r1
  unsigned int v468; // r4
  unsigned int v469; // r9
  KeyPair *v470; // r5
  KeyPair *v471; // r6
  KeyPair *v472; // r2
  unsigned int v473; // r1
  unsigned int v474; // r4
  unsigned int v475; // r9
  KeyPair *v476; // r5
  KeyPair *v477; // r6
  KeyPair *v478; // r2
  unsigned int v479; // r1
  unsigned int v480; // r4
  unsigned int v481; // r9
  KeyPair *v482; // r5
  KeyPair *v483; // r6
  KeyPair *v484; // r2
  unsigned int v485; // r1
  unsigned int v486; // r4
  unsigned int v487; // r9
  KeyPair *v488; // r5
  KeyPair *v489; // r6
  KeyPair *v490; // r2
  unsigned int v491; // r1
  unsigned int v492; // r4
  unsigned int v493; // r9
  KeyPair *v494; // r5
  KeyPair *v495; // r6
  KeyPair *v496; // r2
  unsigned int v497; // r1
  unsigned int v498; // r4
  unsigned int v499; // r9
  KeyPair *v500; // r5
  KeyPair *v501; // r6
  KeyPair *v502; // r2
  unsigned int v503; // r1
  unsigned int v504; // r4
  unsigned int v505; // r9
  KeyPair *v506; // r5
  KeyPair *v507; // r6
  KeyPair *v508; // r2
  unsigned int v509; // r1
  unsigned int v510; // r4
  unsigned int v511; // r9
  KeyPair *v512; // r5
  KeyPair *v513; // r6
  KeyPair *v514; // r2
  unsigned int v515; // r1
  unsigned int v516; // r4
  unsigned int v517; // r9
  KeyPair *v518; // r5
  KeyPair *v519; // r6
  KeyPair *v520; // r2
  unsigned int v521; // r1
  unsigned int v522; // r4
  unsigned int v523; // r9
  KeyPair *v524; // r5
  KeyPair *v525; // r6
  KeyPair *v526; // r2
  unsigned int v527; // r1
  unsigned int v528; // r4
  unsigned int v529; // r9
  KeyPair *v530; // r5
  KeyPair *v531; // r6
  KeyPair *v532; // r2
  unsigned int v533; // r1
  unsigned int v534; // r4
  unsigned int v535; // r9
  KeyPair *v536; // r5
  KeyPair *v537; // r6
  KeyPair *v538; // r2
  unsigned int v539; // r1
  unsigned int v540; // r4
  unsigned int v541; // r9
  KeyPair *v542; // r5
  KeyPair *v543; // r6
  KeyPair *v544; // r2
  unsigned int v545; // r1
  unsigned int v546; // r4
  unsigned int v547; // r9
  KeyPair *v548; // r5
  KeyPair *v549; // r6
  KeyPair *v550; // r2
  unsigned int v551; // r1
  unsigned int v552; // r4
  unsigned int v553; // r9
  KeyPair *v554; // r5
  KeyPair *v555; // r6
  KeyPair *v556; // r2
  unsigned int v557; // r1
  unsigned int v558; // r4
  unsigned int v559; // r9
  KeyPair *v560; // r5
  KeyPair *v561; // r6
  KeyPair *v562; // r2
  unsigned int v563; // r1
  unsigned int v564; // r4
  unsigned int v565; // r9
  KeyPair *v566; // r5
  KeyPair *v567; // r6
  KeyPair *v568; // r2
  unsigned int v569; // r1
  unsigned int v570; // r4
  unsigned int v571; // r9
  KeyPair *v572; // r5
  KeyPair *v573; // r6
  KeyPair *v574; // r2
  unsigned int v575; // r1
  unsigned int v576; // r4
  unsigned int v577; // r9
  KeyPair *v578; // r5
  KeyPair *v579; // r6
  KeyPair *v580; // r2
  unsigned int v581; // r1
  unsigned int v582; // r4
  unsigned int v583; // r9
  KeyPair *v584; // r5
  KeyPair *v585; // r6
  KeyPair *v586; // r2
  unsigned int v587; // r1
  unsigned int v588; // r4
  unsigned int v589; // r8
  KeyPair *v590; // r5
  KeyPair *v591; // r6
  KeyPair *v592; // r2
  TextureDatabaseRuntime *TextureDB; // r5
  _QWORD v595[2]; // [sp+8h] [bp-30h] BYREF

  CHID::CHID(this);
  this->_vptr$CHID = (int (**)(void))&off_6624A8;
  this->m_Mappings.numAlloced = 0;
  this->m_Mappings.numEntries = 0;
  this->m_Mappings.dataPtr = 0;
  CSprite2d::CSprite2d(&this->m_Sprite);
  v3 = 24;
  do
  {
    *(int (***)(void))((char *)&this->_vptr$CHID + v3) = (int (**)(void))-1;
    v4 = (_QWORD *)((char *)&this->m_Mappings.numAlloced + v3);
    *((_BYTE *)&this->m_nNumTextQueued + v3) = 0;
    v5 = (CHIDKeyboard *)&this->m_QueuedText[v3 / 0x18];
    v3 += 24;
    *v4 = 0LL;
    v4[1] = 0LL;
  }
  while ( v5 != &this[1] );
  this->m_nNumTextQueued = 0;
  CHIDKeyboard::m_KeyPairs.numEntries = 0;
  LODWORD(v595[1]) = &loc_435344;
  v595[0] = 0x5F59454B00000000LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced )
  {
    dataPtr = CHIDKeyboard::m_KeyPairs.dataPtr;
    numEntries = 0;
  }
  else
  {
    dataPtr = (KeyPair *)malloc(0x30u);
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      free(CHIDKeyboard::m_KeyPairs.dataPtr);
      numEntries = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    else
    {
      numEntries = 0;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = dataPtr;
    CHIDKeyboard::m_KeyPairs.numAlloced = 4;
  }
  v8 = &dataPtr[numEntries];
  *(_DWORD *)&v8->m_szTag[4] = v595[1];
  *(_QWORD *)&v8->m_key = v595[0];
  v9 = CHIDKeyboard::m_KeyPairs.numEntries;
  v10 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v11 = v9 + 2;
  strcpy((char *)&v595[1], "F1");
  v595[0] = 0x5F59454B00000001LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v11 )
  {
    v13 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v12 = 4 * v11 / 3 + 3;
    v13 = (KeyPair *)malloc(12 * v12);
    v14 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v13, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v10);
      free(v14);
      v10 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v13;
    CHIDKeyboard::m_KeyPairs.numAlloced = v12;
  }
  v15 = &v13[v10];
  *(_DWORD *)&v15->m_szTag[4] = v595[1];
  *(_QWORD *)&v15->m_key = v595[0];
  v16 = CHIDKeyboard::m_KeyPairs.numEntries;
  strcpy((char *)&v595[1], "F2");
  v17 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000002LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v16 + 2 )
  {
    v19 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v18 = 4 * (v16 + 2) / 3 + 3;
    v19 = (KeyPair *)malloc(12 * v18);
    v20 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v19, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v17);
      free(v20);
      v17 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v19;
    CHIDKeyboard::m_KeyPairs.numAlloced = v18;
  }
  v21 = &v19[v17];
  *(_DWORD *)&v21->m_szTag[4] = v595[1];
  *(_QWORD *)&v21->m_key = v595[0];
  v22 = CHIDKeyboard::m_KeyPairs.numEntries;
  v23 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v24 = v22 + 2;
  strcpy((char *)&v595[1], "F3");
  v595[0] = 0x5F59454B00000003LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v24 )
  {
    v26 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v25 = 4 * v24 / 3 + 3;
    v26 = (KeyPair *)malloc(12 * v25);
    v27 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v26, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v23);
      free(v27);
      v23 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v26;
    CHIDKeyboard::m_KeyPairs.numAlloced = v25;
  }
  v28 = &v26[v23];
  *(_DWORD *)&v28->m_szTag[4] = v595[1];
  *(_QWORD *)&v28->m_key = v595[0];
  v29 = CHIDKeyboard::m_KeyPairs.numEntries;
  strcpy((char *)&v595[1], "F4");
  v30 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000004LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v29 + 2 )
  {
    v32 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v31 = 4 * (v29 + 2) / 3 + 3;
    v32 = (KeyPair *)malloc(12 * v31);
    v33 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v32, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v30);
      free(v33);
      v30 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v32;
    CHIDKeyboard::m_KeyPairs.numAlloced = v31;
  }
  v34 = &v32[v30];
  *(_DWORD *)&v34->m_szTag[4] = v595[1];
  *(_QWORD *)&v34->m_key = v595[0];
  v35 = CHIDKeyboard::m_KeyPairs.numEntries;
  strcpy((char *)&v595[1], "F5");
  v36 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000005LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v35 + 2 )
  {
    v38 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v37 = 4 * (v35 + 2) / 3 + 3;
    v38 = (KeyPair *)malloc(12 * v37);
    v39 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v38, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v36);
      free(v39);
      v36 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v38;
    CHIDKeyboard::m_KeyPairs.numAlloced = v37;
  }
  v40 = &v38[v36];
  *(_DWORD *)&v40->m_szTag[4] = v595[1];
  *(_QWORD *)&v40->m_key = v595[0];
  v41 = CHIDKeyboard::m_KeyPairs.numEntries;
  strcpy((char *)&v595[1], "F6");
  v42 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000006LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v41 + 2 )
  {
    v44 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v43 = 4 * (v41 + 2) / 3 + 3;
    v44 = (KeyPair *)malloc(12 * v43);
    v45 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v44, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v42);
      free(v45);
      v42 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v44;
    CHIDKeyboard::m_KeyPairs.numAlloced = v43;
  }
  v46 = &v44[v42];
  *(_DWORD *)&v46->m_szTag[4] = v595[1];
  *(_QWORD *)&v46->m_key = v595[0];
  v47 = CHIDKeyboard::m_KeyPairs.numEntries;
  strcpy((char *)&v595[1], "F7");
  v48 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000007LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v47 + 2 )
  {
    v50 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v49 = 4 * (v47 + 2) / 3 + 3;
    v50 = (KeyPair *)malloc(12 * v49);
    v51 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v50, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v48);
      free(v51);
      v48 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v50;
    CHIDKeyboard::m_KeyPairs.numAlloced = v49;
  }
  v52 = &v50[v48];
  *(_DWORD *)&v52->m_szTag[4] = v595[1];
  *(_QWORD *)&v52->m_key = v595[0];
  v53 = CHIDKeyboard::m_KeyPairs.numEntries;
  strcpy((char *)&v595[1], "F8");
  v54 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000008LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v53 + 2 )
  {
    v56 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v55 = 4 * (v53 + 2) / 3 + 3;
    v56 = (KeyPair *)malloc(12 * v55);
    v57 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v56, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v54);
      free(v57);
      v54 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v56;
    CHIDKeyboard::m_KeyPairs.numAlloced = v55;
  }
  v58 = &v56[v54];
  *(_DWORD *)&v58->m_szTag[4] = v595[1];
  *(_QWORD *)&v58->m_key = v595[0];
  v59 = CHIDKeyboard::m_KeyPairs.numEntries;
  strcpy((char *)&v595[1], "F9");
  v60 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000009LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v59 + 2 )
  {
    v62 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v61 = 4 * (v59 + 2) / 3 + 3;
    v62 = (KeyPair *)malloc(12 * v61);
    v63 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v62, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v60);
      free(v63);
      v60 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v62;
    CHIDKeyboard::m_KeyPairs.numAlloced = v61;
  }
  v64 = &v62[v60];
  *(_DWORD *)&v64->m_szTag[4] = v595[1];
  *(_QWORD *)&v64->m_key = v595[0];
  v65 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = &loc_303146;
  v66 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000000ALL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v65 + 2 )
  {
    v68 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v67 = 4 * (v65 + 2) / 3 + 3;
    v68 = (KeyPair *)malloc(12 * v67);
    v69 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v68, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v66);
      free(v69);
      v66 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v68;
    CHIDKeyboard::m_KeyPairs.numAlloced = v67;
  }
  v70 = &v68[v66];
  *(_DWORD *)&v70->m_szTag[4] = v595[1];
  *(_QWORD *)&v70->m_key = v595[0];
  v71 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = 3223878;
  v72 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000000BLL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v71 + 2 )
  {
    v74 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v73 = 4 * (v71 + 2) / 3 + 3;
    v74 = (KeyPair *)malloc(12 * v73);
    v75 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v74, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v72);
      free(v75);
      v72 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v74;
    CHIDKeyboard::m_KeyPairs.numAlloced = v73;
  }
  v76 = &v74[v72];
  *(_DWORD *)&v76->m_szTag[4] = v595[1];
  *(_QWORD *)&v76->m_key = v595[0];
  v77 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = 3289414;
  v78 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000000CLL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v77 + 2 )
  {
    v80 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v79 = 4 * (v77 + 2) / 3 + 3;
    v80 = (KeyPair *)malloc(12 * v79);
    v81 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v80, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v78);
      free(v81);
      v78 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v80;
    CHIDKeyboard::m_KeyPairs.numAlloced = v79;
  }
  v82 = &v80[v78];
  *(_DWORD *)&v82->m_szTag[4] = v595[1];
  *(_QWORD *)&v82->m_key = v595[0];
  v83 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = (char *)&loc_444C52 + 2;
  v84 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000000DLL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v83 + 2 )
  {
    v86 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v85 = 4 * (v83 + 2) / 3 + 3;
    v86 = (KeyPair *)malloc(12 * v85);
    v87 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v86, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v84);
      free(v87);
      v84 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v86;
    CHIDKeyboard::m_KeyPairs.numAlloced = v85;
  }
  v88 = &v86[v84];
  *(_DWORD *)&v88->m_szTag[4] = v595[1];
  *(_QWORD *)&v88->m_key = v595[0];
  v89 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 48;
  v90 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000000ELL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v89 + 2 )
  {
    v92 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v91 = 4 * (v89 + 2) / 3 + 3;
    v92 = (KeyPair *)malloc(12 * v91);
    v93 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v92, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v90);
      free(v93);
      v90 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v92;
    CHIDKeyboard::m_KeyPairs.numAlloced = v91;
  }
  v94 = &v92[v90];
  *(_DWORD *)&v94->m_szTag[4] = v595[1];
  *(_QWORD *)&v94->m_key = v595[0];
  v95 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 49;
  v96 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000000FLL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v95 + 2 )
  {
    v98 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v97 = 4 * (v95 + 2) / 3 + 3;
    v98 = (KeyPair *)malloc(12 * v97);
    v99 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v98, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v96);
      free(v99);
      v96 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v98;
    CHIDKeyboard::m_KeyPairs.numAlloced = v97;
  }
  v100 = &v98[v96];
  *(_DWORD *)&v100->m_szTag[4] = v595[1];
  *(_QWORD *)&v100->m_key = v595[0];
  v101 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 50;
  v102 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000010LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v101 + 2 )
  {
    v104 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v103 = 4 * (v101 + 2) / 3 + 3;
    v104 = (KeyPair *)malloc(12 * v103);
    v105 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v104, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v102);
      free(v105);
      v102 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v104;
    CHIDKeyboard::m_KeyPairs.numAlloced = v103;
  }
  v106 = &v104[v102];
  *(_DWORD *)&v106->m_szTag[4] = v595[1];
  *(_QWORD *)&v106->m_key = v595[0];
  v107 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 51;
  v108 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000011LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v107 + 2 )
  {
    v110 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v109 = 4 * (v107 + 2) / 3 + 3;
    v110 = (KeyPair *)malloc(12 * v109);
    v111 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v110, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v108);
      free(v111);
      v108 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v110;
    CHIDKeyboard::m_KeyPairs.numAlloced = v109;
  }
  v112 = &v110[v108];
  *(_DWORD *)&v112->m_szTag[4] = v595[1];
  *(_QWORD *)&v112->m_key = v595[0];
  v113 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 52;
  v114 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000012LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v113 + 2 )
  {
    v116 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v115 = 4 * (v113 + 2) / 3 + 3;
    v116 = (KeyPair *)malloc(12 * v115);
    v117 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v116, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v114);
      free(v117);
      v114 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v116;
    CHIDKeyboard::m_KeyPairs.numAlloced = v115;
  }
  v118 = &v116[v114];
  *(_DWORD *)&v118->m_szTag[4] = v595[1];
  *(_QWORD *)&v118->m_key = v595[0];
  v119 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 53;
  v120 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000013LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v119 + 2 )
  {
    v122 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v121 = 4 * (v119 + 2) / 3 + 3;
    v122 = (KeyPair *)malloc(12 * v121);
    v123 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v122, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v120);
      free(v123);
      v120 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v122;
    CHIDKeyboard::m_KeyPairs.numAlloced = v121;
  }
  v124 = &v122[v120];
  *(_DWORD *)&v124->m_szTag[4] = v595[1];
  *(_QWORD *)&v124->m_key = v595[0];
  v125 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 54;
  v126 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000014LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v125 + 2 )
  {
    v128 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v127 = 4 * (v125 + 2) / 3 + 3;
    v128 = (KeyPair *)malloc(12 * v127);
    v129 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v128, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v126);
      free(v129);
      v126 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v128;
    CHIDKeyboard::m_KeyPairs.numAlloced = v127;
  }
  v130 = &v128[v126];
  *(_DWORD *)&v130->m_szTag[4] = v595[1];
  *(_QWORD *)&v130->m_key = v595[0];
  v131 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 55;
  v132 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000015LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v131 + 2 )
  {
    v134 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v133 = 4 * (v131 + 2) / 3 + 3;
    v134 = (KeyPair *)malloc(12 * v133);
    v135 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v134, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v132);
      free(v135);
      v132 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v134;
    CHIDKeyboard::m_KeyPairs.numAlloced = v133;
  }
  v136 = &v134[v132];
  *(_DWORD *)&v136->m_szTag[4] = v595[1];
  *(_QWORD *)&v136->m_key = v595[0];
  v137 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 56;
  v138 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000016LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v137 + 2 )
  {
    v140 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v139 = 4 * (v137 + 2) / 3 + 3;
    v140 = (KeyPair *)malloc(12 * v139);
    v141 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v140, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v138);
      free(v141);
      v138 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v140;
    CHIDKeyboard::m_KeyPairs.numAlloced = v139;
  }
  v142 = &v140[v138];
  *(_DWORD *)&v142->m_szTag[4] = v595[1];
  *(_QWORD *)&v142->m_key = v595[0];
  v143 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 57;
  v144 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000017LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v143 + 2 )
  {
    v146 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v145 = 4 * (v143 + 2) / 3 + 3;
    v146 = (KeyPair *)malloc(12 * v145);
    v147 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v146, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v144);
      free(v147);
      v144 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v146;
    CHIDKeyboard::m_KeyPairs.numAlloced = v145;
  }
  v148 = &v146[v144];
  *(_DWORD *)&v148->m_szTag[4] = v595[1];
  *(_QWORD *)&v148->m_key = v595[0];
  v149 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = (char *)&off_534E4C + 1;
  v150 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000018LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v149 + 2 )
  {
    v152 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v151 = 4 * (v149 + 2) / 3 + 3;
    v152 = (KeyPair *)malloc(12 * v151);
    v153 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v152, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v150);
      free(v153);
      v150 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v152;
    CHIDKeyboard::m_KeyPairs.numAlloced = v151;
  }
  v154 = &v152[v150];
  *(_DWORD *)&v154->m_szTag[4] = v595[1];
  *(_QWORD *)&v154->m_key = v595[0];
  v155 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = (char *)&loc_535142 + 3;
  v156 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000019LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v155 + 2 )
  {
    v158 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v157 = 4 * (v155 + 2) / 3 + 3;
    v158 = (KeyPair *)malloc(12 * v157);
    v159 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v158, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v156);
      free(v159);
      v156 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v158;
    CHIDKeyboard::m_KeyPairs.numAlloced = v157;
  }
  v160 = &v158[v156];
  *(_DWORD *)&v160->m_szTag[4] = v595[1];
  *(_QWORD *)&v160->m_key = v595[0];
  v161 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = &loc_505342;
  v162 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000001ALL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v161 + 2 )
  {
    v164 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v163 = 4 * (v161 + 2) / 3 + 3;
    v164 = (KeyPair *)malloc(12 * v163);
    v165 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v164, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v162);
      free(v165);
      v162 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v164;
    CHIDKeyboard::m_KeyPairs.numAlloced = v163;
  }
  v166 = &v164[v162];
  *(_DWORD *)&v166->m_szTag[4] = v595[1];
  *(_QWORD *)&v166->m_key = v595[0];
  v167 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = &loc_424154;
  v168 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000001BLL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v167 + 2 )
  {
    v170 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v169 = 4 * (v167 + 2) / 3 + 3;
    v170 = (KeyPair *)malloc(12 * v169);
    v171 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v170, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v168);
      free(v171);
      v168 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v170;
    CHIDKeyboard::m_KeyPairs.numAlloced = v169;
  }
  v172 = &v170[v168];
  *(_DWORD *)&v172->m_szTag[4] = v595[1];
  *(_QWORD *)&v172->m_key = v595[0];
  v173 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 81;
  v174 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000001CLL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v173 + 2 )
  {
    v176 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v175 = 4 * (v173 + 2) / 3 + 3;
    v176 = (KeyPair *)malloc(12 * v175);
    v177 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v176, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v174);
      free(v177);
      v174 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v176;
    CHIDKeyboard::m_KeyPairs.numAlloced = v175;
  }
  v178 = &v176[v174];
  *(_DWORD *)&v178->m_szTag[4] = v595[1];
  *(_QWORD *)&v178->m_key = v595[0];
  v179 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 87;
  v180 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000001DLL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v179 + 2 )
  {
    v182 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v181 = 4 * (v179 + 2) / 3 + 3;
    v182 = (KeyPair *)malloc(12 * v181);
    v183 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v182, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v180);
      free(v183);
      v180 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v182;
    CHIDKeyboard::m_KeyPairs.numAlloced = v181;
  }
  v184 = &v182[v180];
  *(_DWORD *)&v184->m_szTag[4] = v595[1];
  *(_QWORD *)&v184->m_key = v595[0];
  v185 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 69;
  v186 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000001ELL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v185 + 2 )
  {
    v188 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v187 = 4 * (v185 + 2) / 3 + 3;
    v188 = (KeyPair *)malloc(12 * v187);
    v189 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v188, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v186);
      free(v189);
      v186 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v188;
    CHIDKeyboard::m_KeyPairs.numAlloced = v187;
  }
  v190 = &v188[v186];
  *(_DWORD *)&v190->m_szTag[4] = v595[1];
  *(_QWORD *)&v190->m_key = v595[0];
  v191 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 82;
  v192 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000001FLL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v191 + 2 )
  {
    v194 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v193 = 4 * (v191 + 2) / 3 + 3;
    v194 = (KeyPair *)malloc(12 * v193);
    v195 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v194, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v192);
      free(v195);
      v192 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v194;
    CHIDKeyboard::m_KeyPairs.numAlloced = v193;
  }
  v196 = &v194[v192];
  *(_DWORD *)&v196->m_szTag[4] = v595[1];
  *(_QWORD *)&v196->m_key = v595[0];
  v197 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 84;
  v198 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000020LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v197 + 2 )
  {
    v200 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v199 = 4 * (v197 + 2) / 3 + 3;
    v200 = (KeyPair *)malloc(12 * v199);
    v201 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v200, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v198);
      free(v201);
      v198 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v200;
    CHIDKeyboard::m_KeyPairs.numAlloced = v199;
  }
  v202 = &v200[v198];
  *(_DWORD *)&v202->m_szTag[4] = v595[1];
  *(_QWORD *)&v202->m_key = v595[0];
  v203 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 89;
  v204 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000021LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v203 + 2 )
  {
    v206 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v205 = 4 * (v203 + 2) / 3 + 3;
    v206 = (KeyPair *)malloc(12 * v205);
    v207 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v206, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v204);
      free(v207);
      v204 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v206;
    CHIDKeyboard::m_KeyPairs.numAlloced = v205;
  }
  v208 = &v206[v204];
  *(_DWORD *)&v208->m_szTag[4] = v595[1];
  *(_QWORD *)&v208->m_key = v595[0];
  v209 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 85;
  v210 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000022LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v209 + 2 )
  {
    v212 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v211 = 4 * (v209 + 2) / 3 + 3;
    v212 = (KeyPair *)malloc(12 * v211);
    v213 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v212, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v210);
      free(v213);
      v210 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v212;
    CHIDKeyboard::m_KeyPairs.numAlloced = v211;
  }
  v214 = &v212[v210];
  *(_DWORD *)&v214->m_szTag[4] = v595[1];
  *(_QWORD *)&v214->m_key = v595[0];
  v215 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 73;
  v216 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000023LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v215 + 2 )
  {
    v218 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v217 = 4 * (v215 + 2) / 3 + 3;
    v218 = (KeyPair *)malloc(12 * v217);
    v219 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v218, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v216);
      free(v219);
      v216 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v218;
    CHIDKeyboard::m_KeyPairs.numAlloced = v217;
  }
  v220 = &v218[v216];
  *(_DWORD *)&v220->m_szTag[4] = v595[1];
  *(_QWORD *)&v220->m_key = v595[0];
  v221 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 79;
  v222 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000024LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v221 + 2 )
  {
    v224 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v223 = 4 * (v221 + 2) / 3 + 3;
    v224 = (KeyPair *)malloc(12 * v223);
    v225 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v224, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v222);
      free(v225);
      v222 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v224;
    CHIDKeyboard::m_KeyPairs.numAlloced = v223;
  }
  v226 = &v224[v222];
  *(_DWORD *)&v226->m_szTag[4] = v595[1];
  *(_QWORD *)&v226->m_key = v595[0];
  v227 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 80;
  v228 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000025LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v227 + 2 )
  {
    v230 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v229 = 4 * (v227 + 2) / 3 + 3;
    v230 = (KeyPair *)malloc(12 * v229);
    v231 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v230, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v228);
      free(v231);
      v228 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v230;
    CHIDKeyboard::m_KeyPairs.numAlloced = v229;
  }
  v232 = &v230[v228];
  *(_DWORD *)&v232->m_szTag[4] = v595[1];
  *(_QWORD *)&v232->m_key = v595[0];
  v233 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = &loc_4B424C;
  v234 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000026LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v233 + 2 )
  {
    v236 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v235 = 4 * (v233 + 2) / 3 + 3;
    v236 = (KeyPair *)malloc(12 * v235);
    v237 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v236, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v234);
      free(v237);
      v234 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v236;
    CHIDKeyboard::m_KeyPairs.numAlloced = v235;
  }
  v238 = &v236[v234];
  *(_DWORD *)&v238->m_szTag[4] = v595[1];
  *(_QWORD *)&v238->m_key = v595[0];
  v239 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = &loc_4B4252;
  v240 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000027LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v239 + 2 )
  {
    v242 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v241 = 4 * (v239 + 2) / 3 + 3;
    v242 = (KeyPair *)malloc(12 * v241);
    v243 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v242, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v240);
      free(v243);
      v240 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v242;
    CHIDKeyboard::m_KeyPairs.numAlloced = v241;
  }
  v244 = &v242[v240];
  *(_DWORD *)&v244->m_szTag[4] = v595[1];
  *(_QWORD *)&v244->m_key = v595[0];
  v245 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = 4739906;
  v246 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000028LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v245 + 2 )
  {
    v248 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v247 = 4 * (v245 + 2) / 3 + 3;
    v248 = (KeyPair *)malloc(12 * v247);
    v249 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v248, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v246);
      free(v249);
      v246 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v248;
    CHIDKeyboard::m_KeyPairs.numAlloced = v247;
  }
  v250 = &v248[v246];
  *(_DWORD *)&v250->m_szTag[4] = v595[1];
  *(_QWORD *)&v250->m_key = v595[0];
  v251 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = &loc_4C5042;
  v252 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000029LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v251 + 2 )
  {
    v254 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v253 = 4 * (v251 + 2) / 3 + 3;
    v254 = (KeyPair *)malloc(12 * v253);
    v255 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v254, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v252);
      free(v255);
      v252 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v254;
    CHIDKeyboard::m_KeyPairs.numAlloced = v253;
  }
  v256 = &v254[v252];
  *(_DWORD *)&v256->m_szTag[4] = v595[1];
  *(_QWORD *)&v256->m_key = v595[0];
  v257 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 65;
  v258 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000002ALL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v257 + 2 )
  {
    v260 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v259 = 4 * (v257 + 2) / 3 + 3;
    v260 = (KeyPair *)malloc(12 * v259);
    v261 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v260, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v258);
      free(v261);
      v258 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v260;
    CHIDKeyboard::m_KeyPairs.numAlloced = v259;
  }
  v262 = &v260[v258];
  *(_DWORD *)&v262->m_szTag[4] = v595[1];
  *(_QWORD *)&v262->m_key = v595[0];
  v263 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 83;
  v264 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000002BLL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v263 + 2 )
  {
    v266 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v265 = 4 * (v263 + 2) / 3 + 3;
    v266 = (KeyPair *)malloc(12 * v265);
    v267 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v266, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v264);
      free(v267);
      v264 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v266;
    CHIDKeyboard::m_KeyPairs.numAlloced = v265;
  }
  v268 = &v266[v264];
  *(_DWORD *)&v268->m_szTag[4] = v595[1];
  *(_QWORD *)&v268->m_key = v595[0];
  v269 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 68;
  v270 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000002CLL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v269 + 2 )
  {
    v272 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v271 = 4 * (v269 + 2) / 3 + 3;
    v272 = (KeyPair *)malloc(12 * v271);
    v273 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v272, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v270);
      free(v273);
      v270 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v272;
    CHIDKeyboard::m_KeyPairs.numAlloced = v271;
  }
  v274 = &v272[v270];
  *(_DWORD *)&v274->m_szTag[4] = v595[1];
  *(_QWORD *)&v274->m_key = v595[0];
  v275 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 70;
  v276 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000002DLL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v275 + 2 )
  {
    v278 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v277 = 4 * (v275 + 2) / 3 + 3;
    v278 = (KeyPair *)malloc(12 * v277);
    v279 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v278, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v276);
      free(v279);
      v276 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v278;
    CHIDKeyboard::m_KeyPairs.numAlloced = v277;
  }
  v280 = &v278[v276];
  *(_DWORD *)&v280->m_szTag[4] = v595[1];
  *(_QWORD *)&v280->m_key = v595[0];
  v281 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 71;
  v282 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000002ELL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v281 + 2 )
  {
    v284 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v283 = 4 * (v281 + 2) / 3 + 3;
    v284 = (KeyPair *)malloc(12 * v283);
    v285 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v284, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v282);
      free(v285);
      v282 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v284;
    CHIDKeyboard::m_KeyPairs.numAlloced = v283;
  }
  v286 = &v284[v282];
  *(_DWORD *)&v286->m_szTag[4] = v595[1];
  *(_QWORD *)&v286->m_key = v595[0];
  v287 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 72;
  v288 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000002FLL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v287 + 2 )
  {
    v290 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v289 = 4 * (v287 + 2) / 3 + 3;
    v290 = (KeyPair *)malloc(12 * v289);
    v291 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v290, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v288);
      free(v291);
      v288 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v290;
    CHIDKeyboard::m_KeyPairs.numAlloced = v289;
  }
  v292 = &v290[v288];
  *(_DWORD *)&v292->m_szTag[4] = v595[1];
  *(_QWORD *)&v292->m_key = v595[0];
  v293 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 74;
  v294 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000030LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v293 + 2 )
  {
    v296 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v295 = 4 * (v293 + 2) / 3 + 3;
    v296 = (KeyPair *)malloc(12 * v295);
    v297 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v296, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v294);
      free(v297);
      v294 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v296;
    CHIDKeyboard::m_KeyPairs.numAlloced = v295;
  }
  v298 = &v296[v294];
  *(_DWORD *)&v298->m_szTag[4] = v595[1];
  *(_QWORD *)&v298->m_key = v595[0];
  v299 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 75;
  v300 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000031LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v299 + 2 )
  {
    v302 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v301 = 4 * (v299 + 2) / 3 + 3;
    v302 = (KeyPair *)malloc(12 * v301);
    v303 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v302, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v300);
      free(v303);
      v300 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v302;
    CHIDKeyboard::m_KeyPairs.numAlloced = v301;
  }
  v304 = &v302[v300];
  *(_DWORD *)&v304->m_szTag[4] = v595[1];
  *(_QWORD *)&v304->m_key = v595[0];
  v305 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 76;
  v306 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000032LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v305 + 2 )
  {
    v308 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v307 = 4 * (v305 + 2) / 3 + 3;
    v308 = (KeyPair *)malloc(12 * v307);
    v309 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v308, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v306);
      free(v309);
      v306 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v308;
    CHIDKeyboard::m_KeyPairs.numAlloced = v307;
  }
  v310 = &v308[v306];
  *(_DWORD *)&v310->m_szTag[4] = v595[1];
  *(_QWORD *)&v310->m_key = v595[0];
  v311 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = &loc_4D4552;
  v312 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000033LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v311 + 2 )
  {
    v314 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v313 = 4 * (v311 + 2) / 3 + 3;
    v314 = (KeyPair *)malloc(12 * v313);
    v315 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v314, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v312);
      free(v315);
      v312 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v314;
    CHIDKeyboard::m_KeyPairs.numAlloced = v313;
  }
  v316 = &v314[v312];
  *(_DWORD *)&v316->m_szTag[4] = v595[1];
  *(_QWORD *)&v316->m_key = v595[0];
  v317 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = (char *)&word_4F5040 + 1;
  v318 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000034LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v317 + 2 )
  {
    v320 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v319 = 4 * (v317 + 2) / 3 + 3;
    v320 = (KeyPair *)malloc(12 * v319);
    v321 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v320, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v318);
      free(v321);
      v318 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v320;
    CHIDKeyboard::m_KeyPairs.numAlloced = v319;
  }
  v322 = &v320[v318];
  *(_DWORD *)&v322->m_szTag[4] = v595[1];
  *(_QWORD *)&v322->m_key = v595[0];
  v323 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = (char *)&loc_525442 + 3;
  v324 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000035LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v323 + 2 )
  {
    v326 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v325 = 4 * (v323 + 2) / 3 + 3;
    v326 = (KeyPair *)malloc(12 * v325);
    v327 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v326, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v324);
      free(v327);
      v324 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v326;
    CHIDKeyboard::m_KeyPairs.numAlloced = v325;
  }
  v328 = &v326[v324];
  *(_DWORD *)&v328->m_szTag[4] = v595[1];
  *(_QWORD *)&v328->m_key = v595[0];
  v329 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = &loc_48534C;
  v330 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000036LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v329 + 2 )
  {
    v332 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v331 = 4 * (v329 + 2) / 3 + 3;
    v332 = (KeyPair *)malloc(12 * v331);
    v333 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v332, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v330);
      free(v333);
      v330 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v332;
    CHIDKeyboard::m_KeyPairs.numAlloced = v331;
  }
  v334 = &v332[v330];
  *(_DWORD *)&v334->m_szTag[4] = v595[1];
  *(_QWORD *)&v334->m_key = v595[0];
  v335 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 90;
  v336 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000037LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v335 + 2 )
  {
    v338 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v337 = 4 * (v335 + 2) / 3 + 3;
    v338 = (KeyPair *)malloc(12 * v337);
    v339 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v338, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v336);
      free(v339);
      v336 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v338;
    CHIDKeyboard::m_KeyPairs.numAlloced = v337;
  }
  v340 = &v338[v336];
  *(_DWORD *)&v340->m_szTag[4] = v595[1];
  *(_QWORD *)&v340->m_key = v595[0];
  v341 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 88;
  v342 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000038LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v341 + 2 )
  {
    v344 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v343 = 4 * (v341 + 2) / 3 + 3;
    v344 = (KeyPair *)malloc(12 * v343);
    v345 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v344, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v342);
      free(v345);
      v342 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v344;
    CHIDKeyboard::m_KeyPairs.numAlloced = v343;
  }
  v346 = &v344[v342];
  *(_DWORD *)&v346->m_szTag[4] = v595[1];
  *(_QWORD *)&v346->m_key = v595[0];
  v347 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 67;
  v348 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000039LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v347 + 2 )
  {
    v350 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v349 = 4 * (v347 + 2) / 3 + 3;
    v350 = (KeyPair *)malloc(12 * v349);
    v351 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v350, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v348);
      free(v351);
      v348 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v350;
    CHIDKeyboard::m_KeyPairs.numAlloced = v349;
  }
  v352 = &v350[v348];
  *(_DWORD *)&v352->m_szTag[4] = v595[1];
  *(_QWORD *)&v352->m_key = v595[0];
  v353 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 86;
  v354 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000003ALL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v353 + 2 )
  {
    v356 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v355 = 4 * (v353 + 2) / 3 + 3;
    v356 = (KeyPair *)malloc(12 * v355);
    v357 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v356, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v354);
      free(v357);
      v354 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v356;
    CHIDKeyboard::m_KeyPairs.numAlloced = v355;
  }
  v358 = &v356[v354];
  *(_DWORD *)&v358->m_szTag[4] = v595[1];
  *(_QWORD *)&v358->m_key = v595[0];
  v359 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 66;
  v360 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000003BLL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v359 + 2 )
  {
    v362 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v361 = 4 * (v359 + 2) / 3 + 3;
    v362 = (KeyPair *)malloc(12 * v361);
    v363 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v362, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v360);
      free(v363);
      v360 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v362;
    CHIDKeyboard::m_KeyPairs.numAlloced = v361;
  }
  v364 = &v362[v360];
  *(_DWORD *)&v364->m_szTag[4] = v595[1];
  *(_QWORD *)&v364->m_key = v595[0];
  v365 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 78;
  v366 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000003CLL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v365 + 2 )
  {
    v368 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v367 = 4 * (v365 + 2) / 3 + 3;
    v368 = (KeyPair *)malloc(12 * v367);
    v369 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v368, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v366);
      free(v369);
      v366 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v368;
    CHIDKeyboard::m_KeyPairs.numAlloced = v367;
  }
  v370 = &v368[v366];
  *(_DWORD *)&v370->m_szTag[4] = v595[1];
  *(_QWORD *)&v370->m_key = v595[0];
  v371 = CHIDKeyboard::m_KeyPairs.numEntries;
  LOWORD(v595[1]) = 77;
  v372 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000003DLL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v371 + 2 )
  {
    v374 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v373 = 4 * (v371 + 2) / 3 + 3;
    v374 = (KeyPair *)malloc(12 * v373);
    v375 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v374, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v372);
      free(v375);
      v372 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v374;
    CHIDKeyboard::m_KeyPairs.numAlloced = v373;
  }
  v376 = &v374[v372];
  *(_DWORD *)&v376->m_szTag[4] = v595[1];
  *(_QWORD *)&v376->m_key = v595[0];
  v377 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = &loc_414D42;
  v378 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000003ELL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v377 + 2 )
  {
    v380 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v379 = 4 * (v377 + 2) / 3 + 3;
    v380 = (KeyPair *)malloc(12 * v379);
    v381 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v380, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v378);
      free(v381);
      v378 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v380;
    CHIDKeyboard::m_KeyPairs.numAlloced = v379;
  }
  v382 = &v380[v378];
  *(_DWORD *)&v382->m_szTag[4] = v595[1];
  *(_QWORD *)&v382->m_key = v595[0];
  v383 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = &loc_524550;
  v384 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000003FLL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v383 + 2 )
  {
    v386 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v385 = 4 * (v383 + 2) / 3 + 3;
    v386 = (KeyPair *)malloc(12 * v385);
    v387 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v386, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v384);
      free(v387);
      v384 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v386;
    CHIDKeyboard::m_KeyPairs.numAlloced = v385;
  }
  v388 = &v386[v384];
  *(_DWORD *)&v388->m_szTag[4] = v595[1];
  *(_QWORD *)&v388->m_key = v595[0];
  v389 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = 5002054;
  v390 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000040LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v389 + 2 )
  {
    v392 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v391 = 4 * (v389 + 2) / 3 + 3;
    v392 = (KeyPair *)malloc(12 * v391);
    v393 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v392, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v390);
      free(v393);
      v390 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v392;
    CHIDKeyboard::m_KeyPairs.numAlloced = v391;
  }
  v394 = &v392[v390];
  *(_DWORD *)&v394->m_szTag[4] = v595[1];
  *(_QWORD *)&v394->m_key = v595[0];
  v395 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = 4739922;
  v396 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000041LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v395 + 2 )
  {
    v398 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v397 = 4 * (v395 + 2) / 3 + 3;
    v398 = (KeyPair *)malloc(12 * v397);
    v399 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v398, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v396);
      free(v399);
      v396 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v398;
    CHIDKeyboard::m_KeyPairs.numAlloced = v397;
  }
  v400 = &v398[v396];
  *(_DWORD *)&v400->m_szTag[4] = v595[1];
  *(_QWORD *)&v400->m_key = v595[0];
  v401 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = CTaskSimplePutDownEntity::Clone;
  v402 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000042LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v401 + 2 )
  {
    v404 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v403 = 4 * (v401 + 2) / 3 + 3;
    v404 = (KeyPair *)malloc(12 * v403);
    v405 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v404, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v402);
      free(v405);
      v402 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v404;
    CHIDKeyboard::m_KeyPairs.numAlloced = v403;
  }
  v406 = &v404[v402];
  *(_DWORD *)&v406->m_szTag[4] = v595[1];
  *(_QWORD *)&v406->m_key = v595[0];
  v407 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = &loc_4C414C;
  v408 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000043LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v407 + 2 )
  {
    v410 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v409 = 4 * (v407 + 2) / 3 + 3;
    v410 = (KeyPair *)malloc(12 * v409);
    v411 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v410, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v408);
      free(v411);
      v408 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v410;
    CHIDKeyboard::m_KeyPairs.numAlloced = v409;
  }
  v412 = &v410[v408];
  *(_DWORD *)&v412->m_szTag[4] = v595[1];
  *(_QWORD *)&v412->m_key = v595[0];
  v413 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = &loc_435052;
  v414 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000044LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v413 + 2 )
  {
    v416 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v415 = 4 * (v413 + 2) / 3 + 3;
    v416 = (KeyPair *)malloc(12 * v415);
    v417 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v416, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v414);
      free(v417);
      v414 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v416;
    CHIDKeyboard::m_KeyPairs.numAlloced = v415;
  }
  v418 = &v416[v414];
  *(_DWORD *)&v418->m_szTag[4] = v595[1];
  *(_QWORD *)&v418->m_key = v595[0];
  v419 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = &loc_4C4152;
  v420 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000045LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v419 + 2 )
  {
    v422 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v421 = 4 * (v419 + 2) / 3 + 3;
    v422 = (KeyPair *)malloc(12 * v421);
    v423 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v422, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v420);
      free(v423);
      v420 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v422;
    CHIDKeyboard::m_KeyPairs.numAlloced = v421;
  }
  v424 = &v422[v420];
  *(_DWORD *)&v424->m_szTag[4] = v595[1];
  *(_QWORD *)&v424->m_key = v595[0];
  v425 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = (char *)&loc_544350 + 2;
  v426 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000046LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v425 + 2 )
  {
    v428 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v427 = 4 * (v425 + 2) / 3 + 3;
    v428 = (KeyPair *)malloc(12 * v427);
    v429 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v428, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v426);
      free(v429);
      v426 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v428;
    CHIDKeyboard::m_KeyPairs.numAlloced = v427;
  }
  v430 = &v428[v426];
  *(_DWORD *)&v430->m_szTag[4] = v595[1];
  *(_QWORD *)&v430->m_key = v595[0];
  v431 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = &loc_435350;
  v432 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000047LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v431 + 2 )
  {
    v434 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v433 = 4 * (v431 + 2) / 3 + 3;
    v434 = (KeyPair *)malloc(12 * v433);
    v435 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v434, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v432);
      free(v435);
      v432 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v434;
    CHIDKeyboard::m_KeyPairs.numAlloced = v433;
  }
  v436 = &v434[v432];
  *(_DWORD *)&v436->m_szTag[4] = v595[1];
  *(_QWORD *)&v436->m_key = v595[0];
  v437 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = &loc_554150;
  v438 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000048LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v437 + 2 )
  {
    v440 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v439 = 4 * (v437 + 2) / 3 + 3;
    v440 = (KeyPair *)malloc(12 * v439);
    v441 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v440, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v438);
      free(v441);
      v438 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v440;
    CHIDKeyboard::m_KeyPairs.numAlloced = v439;
  }
  v442 = &v440[v438];
  *(_DWORD *)&v442->m_szTag[4] = v595[1];
  *(_QWORD *)&v442->m_key = v595[0];
  v443 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = (char *)&off_534E48 + 1;
  v444 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000049LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v443 + 2 )
  {
    v446 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v445 = 4 * (v443 + 2) / 3 + 3;
    v446 = (KeyPair *)malloc(12 * v445);
    v447 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v446, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v444);
      free(v447);
      v444 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v446;
    CHIDKeyboard::m_KeyPairs.numAlloced = v445;
  }
  v448 = &v446[v444];
  *(_DWORD *)&v448->m_szTag[4] = v595[1];
  *(_QWORD *)&v448->m_key = v595[0];
  v449 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = &off_4C4544;
  v450 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000004ALL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v449 + 2 )
  {
    v452 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v451 = 4 * (v449 + 2) / 3 + 3;
    v452 = (KeyPair *)malloc(12 * v451);
    v453 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v452, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v450);
      free(v453);
      v450 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v452;
    CHIDKeyboard::m_KeyPairs.numAlloced = v451;
  }
  v454 = &v452[v450];
  *(_DWORD *)&v454->m_szTag[4] = v595[1];
  *(_QWORD *)&v454->m_key = v595[0];
  v455 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = (char *)&loc_4D4F46 + 2;
  v456 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000004BLL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v455 + 2 )
  {
    v458 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v457 = 4 * (v455 + 2) / 3 + 3;
    v458 = (KeyPair *)malloc(12 * v457);
    v459 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v458, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v456);
      free(v459);
      v456 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v458;
    CHIDKeyboard::m_KeyPairs.numAlloced = v457;
  }
  v460 = &v458[v456];
  *(_DWORD *)&v460->m_szTag[4] = v595[1];
  *(_QWORD *)&v460->m_key = v595[0];
  v461 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = (char *)&loc_444E42 + 3;
  v462 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000004CLL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v461 + 2 )
  {
    v464 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v463 = 4 * (v461 + 2) / 3 + 3;
    v464 = (KeyPair *)malloc(12 * v463);
    v465 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v464, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v462);
      free(v465);
      v462 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v464;
    CHIDKeyboard::m_KeyPairs.numAlloced = v463;
  }
  v466 = &v464[v462];
  *(_DWORD *)&v466->m_szTag[4] = v595[1];
  *(_QWORD *)&v466->m_key = v595[0];
  v467 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = (char *)&loc_50554E + 2;
  v468 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000004DLL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v467 + 2 )
  {
    v470 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v469 = 4 * (v467 + 2) / 3 + 3;
    v470 = (KeyPair *)malloc(12 * v469);
    v471 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v470, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v468);
      free(v471);
      v468 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v470;
    CHIDKeyboard::m_KeyPairs.numAlloced = v469;
  }
  v472 = &v470[v468];
  *(_DWORD *)&v472->m_szTag[4] = v595[1];
  *(_QWORD *)&v472->m_key = v595[0];
  v473 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = &locret_4E4450;
  v474 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000004ELL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v473 + 2 )
  {
    v476 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v475 = 4 * (v473 + 2) / 3 + 3;
    v476 = (KeyPair *)malloc(12 * v475);
    v477 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v476, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v474);
      free(v477);
      v474 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v476;
    CHIDKeyboard::m_KeyPairs.numAlloced = v475;
  }
  v478 = &v476[v474];
  *(_DWORD *)&v478->m_szTag[4] = v595[1];
  *(_QWORD *)&v478->m_key = v595[0];
  v479 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = &loc_555240;
  v480 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000004FLL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v479 + 2 )
  {
    v482 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v481 = 4 * (v479 + 2) / 3 + 3;
    v482 = (KeyPair *)malloc(12 * v481);
    v483 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v482, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v480);
      free(v483);
      v480 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v482;
    CHIDKeyboard::m_KeyPairs.numAlloced = v481;
  }
  v484 = &v482[v480];
  *(_DWORD *)&v484->m_szTag[4] = v595[1];
  *(_QWORD *)&v484->m_key = v595[0];
  v485 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = 4477505;
  v486 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000050LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v485 + 2 )
  {
    v488 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v487 = 4 * (v485 + 2) / 3 + 3;
    v488 = (KeyPair *)malloc(12 * v487);
    v489 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v488, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v486);
      free(v489);
      v486 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v488;
    CHIDKeyboard::m_KeyPairs.numAlloced = v487;
  }
  v490 = &v488[v486];
  *(_DWORD *)&v490->m_szTag[4] = v595[1];
  *(_QWORD *)&v490->m_key = v595[0];
  v491 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = 5001793;
  v492 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000051LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v491 + 2 )
  {
    v494 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v493 = 4 * (v491 + 2) / 3 + 3;
    v494 = (KeyPair *)malloc(12 * v493);
    v495 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v494, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v492);
      free(v495);
      v492 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v494;
    CHIDKeyboard::m_KeyPairs.numAlloced = v493;
  }
  v496 = &v494[v492];
  *(_DWORD *)&v496->m_szTag[4] = v595[1];
  *(_QWORD *)&v496->m_key = v595[0];
  v497 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = &loc_525240;
  v498 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000052LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v497 + 2 )
  {
    v500 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v499 = 4 * (v497 + 2) / 3 + 3;
    v500 = (KeyPair *)malloc(12 * v499);
    v501 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v500, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v498);
      free(v501);
      v498 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v500;
    CHIDKeyboard::m_KeyPairs.numAlloced = v499;
  }
  v502 = &v500[v498];
  *(_DWORD *)&v502->m_szTag[4] = v595[1];
  *(_QWORD *)&v502->m_key = v595[0];
  v503 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = (char *)&loc_564942 + 2;
  v504 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000053LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v503 + 2 )
  {
    v506 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v505 = 4 * (v503 + 2) / 3 + 3;
    v506 = (KeyPair *)malloc(12 * v505);
    v507 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v506, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v504);
      free(v507);
      v504 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v506;
    CHIDKeyboard::m_KeyPairs.numAlloced = v505;
  }
  v508 = &v506[v504];
  *(_DWORD *)&v508->m_szTag[4] = v595[1];
  *(_QWORD *)&v508->m_key = v595[0];
  v509 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = &loc_4C554C;
  v510 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000054LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v509 + 2 )
  {
    v512 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v511 = 4 * (v509 + 2) / 3 + 3;
    v512 = (KeyPair *)malloc(12 * v511);
    v513 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v512, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v510);
      free(v513);
      v510 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v512;
    CHIDKeyboard::m_KeyPairs.numAlloced = v511;
  }
  v514 = &v512[v510];
  *(_DWORD *)&v514->m_szTag[4] = v595[1];
  *(_QWORD *)&v514->m_key = v595[0];
  v515 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = &loc_4E494C;
  v516 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000055LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v515 + 2 )
  {
    v518 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v517 = 4 * (v515 + 2) / 3 + 3;
    v518 = (KeyPair *)malloc(12 * v517);
    v519 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v518, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v516);
      free(v519);
      v516 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v518;
    CHIDKeyboard::m_KeyPairs.numAlloced = v517;
  }
  v520 = &v518[v516];
  *(_DWORD *)&v520->m_szTag[4] = v595[1];
  *(_QWORD *)&v520->m_key = v595[0];
  v521 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = 3624270;
  v522 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000056LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v521 + 2 )
  {
    v524 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v523 = 4 * (v521 + 2) / 3 + 3;
    v524 = (KeyPair *)malloc(12 * v523);
    v525 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v524, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v522);
      free(v525);
      v522 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v524;
    CHIDKeyboard::m_KeyPairs.numAlloced = v523;
  }
  v526 = &v524[v522];
  *(_DWORD *)&v526->m_szTag[4] = v595[1];
  *(_QWORD *)&v526->m_key = v595[0];
  v527 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = 3689806;
  v528 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000057LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v527 + 2 )
  {
    v530 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v529 = 4 * (v527 + 2) / 3 + 3;
    v530 = (KeyPair *)malloc(12 * v529);
    v531 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v530, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v528);
      free(v531);
      v528 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v530;
    CHIDKeyboard::m_KeyPairs.numAlloced = v529;
  }
  v532 = &v530[v528];
  *(_DWORD *)&v532->m_szTag[4] = v595[1];
  *(_QWORD *)&v532->m_key = v595[0];
  v533 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = &loc_394D4E;
  v534 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000058LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v533 + 2 )
  {
    v536 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v535 = 4 * (v533 + 2) / 3 + 3;
    v536 = (KeyPair *)malloc(12 * v535);
    v537 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v536, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v534);
      free(v537);
      v534 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v536;
    CHIDKeyboard::m_KeyPairs.numAlloced = v535;
  }
  v538 = &v536[v534];
  *(_DWORD *)&v538->m_szTag[4] = v595[1];
  *(_QWORD *)&v538->m_key = v595[0];
  v539 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = &loc_534C50;
  v540 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B00000059LL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v539 + 2 )
  {
    v542 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v541 = 4 * (v539 + 2) / 3 + 3;
    v542 = (KeyPair *)malloc(12 * v541);
    v543 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v542, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v540);
      free(v543);
      v540 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v542;
    CHIDKeyboard::m_KeyPairs.numAlloced = v541;
  }
  v544 = &v542[v540];
  *(_DWORD *)&v544->m_szTag[4] = v595[1];
  *(_QWORD *)&v544->m_key = v595[0];
  v545 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = 3427662;
  v546 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000005ALL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v545 + 2 )
  {
    v548 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v547 = 4 * (v545 + 2) / 3 + 3;
    v548 = (KeyPair *)malloc(12 * v547);
    v549 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v548, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v546);
      free(v549);
      v546 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v548;
    CHIDKeyboard::m_KeyPairs.numAlloced = v547;
  }
  v550 = &v548[v546];
  *(_DWORD *)&v550->m_szTag[4] = v595[1];
  *(_QWORD *)&v550->m_key = v595[0];
  v551 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = 3493198;
  v552 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000005BLL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v551 + 2 )
  {
    v554 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v553 = 4 * (v551 + 2) / 3 + 3;
    v554 = (KeyPair *)malloc(12 * v553);
    v555 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v554, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v552);
      free(v555);
      v552 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v554;
    CHIDKeyboard::m_KeyPairs.numAlloced = v553;
  }
  v556 = &v554[v552];
  *(_DWORD *)&v556->m_szTag[4] = v595[1];
  *(_QWORD *)&v556->m_key = v595[0];
  v557 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = 3558734;
  v558 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000005CLL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v557 + 2 )
  {
    v560 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v559 = 4 * (v557 + 2) / 3 + 3;
    v560 = (KeyPair *)malloc(12 * v559);
    v561 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v560, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v558);
      free(v561);
      v558 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v560;
    CHIDKeyboard::m_KeyPairs.numAlloced = v559;
  }
  v562 = &v560[v558];
  *(_DWORD *)&v562->m_szTag[4] = v595[1];
  *(_QWORD *)&v562->m_key = v595[0];
  v563 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = 3231054;
  v564 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000005DLL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v563 + 2 )
  {
    v566 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v565 = 4 * (v563 + 2) / 3 + 3;
    v566 = (KeyPair *)malloc(12 * v565);
    v567 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v566, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v564);
      free(v567);
      v564 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v566;
    CHIDKeyboard::m_KeyPairs.numAlloced = v565;
  }
  v568 = &v566[v564];
  *(_DWORD *)&v568->m_szTag[4] = v595[1];
  *(_QWORD *)&v568->m_key = v595[0];
  v569 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = 3296590;
  v570 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  v595[0] = 0x5F59454B0000005ELL;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v569 + 2 )
  {
    v572 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v571 = 4 * (v569 + 2) / 3 + 3;
    v572 = (KeyPair *)malloc(12 * v571);
    v573 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v572, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v570);
      free(v573);
      v570 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v572;
    CHIDKeyboard::m_KeyPairs.numAlloced = v571;
  }
  v574 = &v572[v570];
  *(_DWORD *)&v574->m_szTag[4] = v595[1];
  *(_QWORD *)&v574->m_key = v595[0];
  v575 = CHIDKeyboard::m_KeyPairs.numEntries;
  v576 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  strcpy((char *)v595 + 4, "KEY_NM3");
  LODWORD(v595[0]) = 95;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v575 + 2 )
  {
    v578 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v577 = 4 * (v575 + 2) / 3 + 3;
    v578 = (KeyPair *)malloc(12 * v577);
    v579 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v578, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v576);
      free(v579);
      v576 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v578;
    CHIDKeyboard::m_KeyPairs.numAlloced = v577;
  }
  v580 = &v578[v576];
  *(_DWORD *)&v580->m_szTag[4] = v595[1];
  *(_QWORD *)&v580->m_key = v595[0];
  v581 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = &loc_304D4E;
  v582 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  HIDWORD(v595[0]) = 1599685963;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v581 + 2 )
  {
    v584 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v583 = 4 * (v581 + 2) / 3 + 3;
    v584 = (KeyPair *)malloc(12 * v583);
    v585 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v584, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v582);
      free(v585);
      v582 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v584;
    CHIDKeyboard::m_KeyPairs.numAlloced = v583;
  }
  v586 = &v584[v582];
  *(_DWORD *)&v586->m_szTag[4] = v595[1];
  *(_QWORD *)&v586->m_key = 0x5F59454B00000060LL;
  v587 = CHIDKeyboard::m_KeyPairs.numEntries;
  LODWORD(v595[1]) = &loc_52504E;
  v588 = ++CHIDKeyboard::m_KeyPairs.numEntries;
  HIDWORD(v595[0]) = 1599685963;
  if ( CHIDKeyboard::m_KeyPairs.numAlloced >= v587 + 2 )
  {
    v590 = CHIDKeyboard::m_KeyPairs.dataPtr;
  }
  else
  {
    v589 = 4 * (v587 + 2) / 3 + 3;
    v590 = (KeyPair *)malloc(12 * v589);
    v591 = CHIDKeyboard::m_KeyPairs.dataPtr;
    if ( CHIDKeyboard::m_KeyPairs.dataPtr )
    {
      qmemcpy(v590, CHIDKeyboard::m_KeyPairs.dataPtr, 12 * v588);
      free(v591);
      v588 = CHIDKeyboard::m_KeyPairs.numEntries;
    }
    CHIDKeyboard::m_KeyPairs.dataPtr = v590;
    CHIDKeyboard::m_KeyPairs.numAlloced = v589;
  }
  v592 = &v590[v588];
  *(_DWORD *)&v592->m_szTag[4] = v595[1];
  *(_QWORD *)&v592->m_key = 0x5F59454B00000061LL;
  ++CHIDKeyboard::m_KeyPairs.numEntries;
  if ( pszIconSprite )
  {
    TextureDB = CTouchInterface::LoadTextureDB();
    CSprite2d::SetTexture(&this->m_Sprite, (unsigned __int8 *)pszIconSprite);
    CTouchInterface::UnloadTextureDB(TextureDB);
  }
}
// 4C4544: using guessed type float **off_4C4544;
// 4F5040: using guessed type __int16;
// 534E48: using guessed type void **off_534E48;
// 534E4C: using guessed type void **off_534E4C;
// 6624A8: using guessed type void *;

//----- (00294D90) --------------------------------------------------------
void __fastcall CHIDKeyboard::InternalDrawHelpIcon(
        CHIDKeyboard *this,
        const unsigned __int8 *pszCharacters,
        HIDMapping Mapping,
        float fX,
        float fY,
        float fHeight,
        int nAlpha,
        int bNegated)
{
  CSprite2d *p_m_Sprite; // r6
  float v12; // s0
  float v13; // s2
  float v14; // s18
  int v15; // r1
  int v16; // r0
  int m_nNumTextQueued; // r0
  char *v18; // r0
  CRect Rectangle; // [sp+1Ch] [bp-64h] BYREF
  CRGBA v20; // [sp+2Ch] [bp-54h] BYREF
  float v21; // [sp+30h] [bp-50h] BYREF
  float v22; // [sp+34h] [bp-4Ch]
  float v23; // [sp+38h] [bp-48h]
  float v24; // [sp+3Ch] [bp-44h]

  p_m_Sprite = &this->m_Sprite;
  if ( this->m_Sprite.mpTexture )
  {
    (*((void (__fastcall **)(float *, CHIDKeyboard *, const unsigned __int8 *, HIDMapping, int))this->_vptr$CHID + 21))(
      &v21,
      this,
      pszCharacters,
      Mapping,
      bNegated);
    CRGBA::CRGBA(&v20, 0xC0u, 0xC0u, 0xC0u, nAlpha);
    v12 = (float)(fHeight - (float)(fHeight * 0.8)) * 0.5;
    v13 = fX + fHeight;
    v14 = v12 + fX;
    Rectangle.left = v14;
    Rectangle.bottom = v12 + fY;
    Rectangle.right = v13 - v12;
    Rectangle.top = (float)(fY + fHeight) - v12;
    CSprite2d::Draw(p_m_Sprite, &Rectangle, &v20, v21, v24, v23, v24, v21, v22, v23, v22);
    v15 = 0;
    v16 = 0;
    if ( v24 == 0.0 )
      v15 = 1;
    if ( v21 == 0.0 )
      v16 = 1;
    if ( (v16 & v15) != 0 )
    {
      m_nNumTextQueued = this->m_nNumTextQueued;
      if ( m_nNumTextQueued <= 99 )
      {
        v18 = (char *)this + 24 * m_nNumTextQueued;
        *((_DWORD *)v18 + 6) = Mapping;
        *((float *)v18 + 7) = v14;
        *((float *)v18 + 8) = v12 + fY;
        *((float *)v18 + 9) = fHeight * 0.8;
        *((_DWORD *)v18 + 10) = nAlpha;
        v18[44] = bNegated;
        ++this->m_nNumTextQueued;
      }
    }
  }
}

//----- (00294EC4) --------------------------------------------------------
void __fastcall CHIDKeyboard::QueueTextRender(
        CHIDKeyboard *this,
        HIDMapping Mapping,
        float fX,
        float fY,
        float fHeight,
        int nAlpha,
        bool bNegated)
{
  int m_nNumTextQueued; // r12
  char *v9; // r2

  m_nNumTextQueued = this->m_nNumTextQueued;
  if ( m_nNumTextQueued <= 99 )
  {
    v9 = (char *)this + 24 * m_nNumTextQueued;
    *((_DWORD *)v9 + 6) = Mapping;
    *((float *)v9 + 7) = fX;
    *((float *)v9 + 8) = fY;
    *((float *)v9 + 9) = fHeight;
    *((_DWORD *)v9 + 10) = nAlpha;
    v9[44] = bNegated;
    ++this->m_nNumTextQueued;
  }
}

//----- (00294F0C) --------------------------------------------------------
void __fastcall CHIDKeyboard::InternalFlushQueuedText(CHIDKeyboard *this)
{
  int v2; // r10
  int v3; // r0
  unsigned int v4; // r3
  unsigned __int8 *m_szTag; // r1
  GxtChar *v6; // r6
  float v7; // s24
  float StringWidth; // r0
  float v9; // s0
  float v10; // s24
  float v11; // s26
  float Height; // r0
  char *v13; // r8
  CRGBA v14; // r0
  CRGBA v15; // r0
  unsigned int numEntries; // r0
  unsigned int v17; // r6
  HIDMapping *p_mapping; // r1
  CRGBA v19; // [sp+18h] [bp-60h] BYREF
  CRGBA v20; // [sp+1Ch] [bp-5Ch] BYREF

  if ( this->m_nNumTextQueued >= 1 )
  {
    v2 = 0;
    do
    {
      CFont::SetBackground(0, 0);
      CFont::SetOrientation(0);
      CFont::SetCentreSize((float)((float)RsGlobal.screenWidth / 640.0) * 640.0);
      CFont::SetProportional(1u);
      CFont::SetEdge(1);
      CFont::SetFontStyle(1u);
      v13 = (char *)this + 24 * v2;
      CRGBA::CRGBA(&v20, 0xFFu, 0xFFu, 0xFFu, v13[40]);
      CFont::SetColor(v14);
      CRGBA::CRGBA(&v19, 0, 0, 0, v13[40]);
      CFont::SetDropColor(v15);
      numEntries = this->m_Mappings.numEntries;
      if ( numEntries )
      {
        v17 = 0;
        p_mapping = &this->m_Mappings.dataPtr->mapping;
        while ( *p_mapping != *((_DWORD *)v13 + 6) || *((unsigned __int8 *)p_mapping + 4) != (unsigned __int8)v13[44] )
        {
          ++v17;
          p_mapping += 5;
          if ( v17 >= numEntries )
            goto LABEL_18;
        }
        v3 = *((_DWORD *)p_mapping - 1);
        if ( v3 <= 99 )
        {
          if ( CHIDKeyboard::m_KeyPairs.numEntries )
          {
            v4 = 0;
            m_szTag = CHIDKeyboard::m_KeyPairs.dataPtr->m_szTag;
            while ( *((_DWORD *)m_szTag - 1) != v3 )
            {
              ++v4;
              m_szTag += 12;
              if ( v4 >= CHIDKeyboard::m_KeyPairs.numEntries )
              {
                m_szTag = "KEY_UNK";
                break;
              }
            }
          }
          else
          {
            m_szTag = "KEY_UNK";
          }
          v6 = CText::Get(&TheText, m_szTag);
          v7 = *((float *)v13 + 9) * 0.045;
          CFont::SetScale(v7);
          StringWidth = CFont::GetStringWidth(v6, 1u, 0);
          v9 = *((float *)v13 + 9);
          if ( StringWidth > (float)(v9 * 0.9) )
          {
            CFont::SetScale(v7 * (float)((float)(v9 * 0.9) / StringWidth));
            v9 = *((float *)v13 + 9);
          }
          v10 = *((float *)v13 + 7);
          v11 = *((float *)v13 + 8);
          Height = CFont::GetHeight(0);
          CFont::PrintString(v10 + (float)(v9 * 0.5), (float)(v11 + (float)(v9 * 0.5)) - (float)(Height * 0.5), v6);
          CFont::SetEdge(0);
          CFont::RenderFontBuffer();
        }
      }
LABEL_18:
      ++v2;
    }
    while ( v2 < this->m_nNumTextQueued );
  }
  this->m_nNumTextQueued = 0;
}
// 29507A: variable 'v14' is possibly undefined
// 295090: variable 'v15' is possibly undefined

//----- (00295108) --------------------------------------------------------
GxtChar *__fastcall CHIDKeyboard::GetMappingString(OSKeyboardKey key)
{
  unsigned int v1; // r3
  unsigned __int8 *m_szTag; // r1

  if ( CHIDKeyboard::m_KeyPairs.numEntries )
  {
    v1 = 0;
    m_szTag = CHIDKeyboard::m_KeyPairs.dataPtr->m_szTag;
    while ( *((_DWORD *)m_szTag - 1) != key )
    {
      ++v1;
      m_szTag += 12;
      if ( v1 >= CHIDKeyboard::m_KeyPairs.numEntries )
      {
        m_szTag = "KEY_UNK";
        return sub_18A500(&TheText, m_szTag);
      }
    }
  }
  else
  {
    m_szTag = "KEY_UNK";
  }
  return sub_18A500(&TheText, m_szTag);
}

//----- (00295168) --------------------------------------------------------
void __fastcall CHIDKeyboard::InternalRemoveQueuedText(CHIDKeyboard *this)
{
  this->m_nNumTextQueued = 0;
}

//----- (0029516E) --------------------------------------------------------
CSprite2d *__fastcall CHIDKeyboard::InternalGetHelpSprite(
        CHIDKeyboard *this,
        const unsigned __int8 *pszCharacters,
        HIDMapping Mapping,
        CVector2D *pvecUVLeftTop,
        CVector2D *pvecUVRightBottom)
{
  float v7; // r2
  float v8; // r1
  int v10[6]; // [sp+8h] [bp-18h] BYREF

  (*((void (__fastcall **)(int *, CHIDKeyboard *, const unsigned __int8 *, HIDMapping, _DWORD))this->_vptr$CHID + 21))(
    v10,
    this,
    pszCharacters,
    Mapping,
    0);
  if ( pvecUVLeftTop )
  {
    v7 = *(float *)&v10[3];
    LODWORD(pvecUVLeftTop->x) = v10[0];
    pvecUVLeftTop->y = v7;
  }
  if ( pvecUVRightBottom )
  {
    v8 = *(float *)&v10[1];
    LODWORD(pvecUVRightBottom->x) = v10[2];
    pvecUVRightBottom->y = v8;
  }
  return &this->m_Sprite;
}

//----- (002951AE) --------------------------------------------------------
bool __fastcall CHIDKeyboard::InternalImplements(CHIDKeyboard *this, HIDMapping Mapping)
{
  unsigned int numEntries; // r12
  unsigned int v4; // r3
  HIDMapping *p_mapping; // r0

  numEntries = this->m_Mappings.numEntries;
  if ( !numEntries )
    return 0;
  v4 = 0;
  p_mapping = &this->m_Mappings.dataPtr->mapping;
  do
  {
    if ( *p_mapping == Mapping )
      return 1;
    ++v4;
    p_mapping += 5;
  }
  while ( v4 < numEntries );
  return 0;
}

//----- (002951DC) --------------------------------------------------------
bool __fastcall CHIDKeyboard::InternalReplaces(CHIDKeyboard *this, HIDMapping Mapping)
{
  bool result; // r0

  if ( CCheat::m_bShowMappings )
    return 0;
  switch ( Mapping )
  {
    case HID_MAPPING_MISSION_START_AND_CANCEL:
    case HID_MAPPING_MAGNET:
    case HID_MAPPING_SKIP_CUTSCENE:
    case HID_MAPPING_GANG_RECRUIT:
    case HID_MAPPING_GANG_IGNORE:
    case HID_MAPPING_GANG_FOLLOW:
    case HID_MAPPING_GANG_HOLD_POSITION:
    case HID_MAPPING_RHYTHM_UP:
    case HID_MAPPING_RHYTHM_DOWN:
    case HID_MAPPING_RHYTHM_LEFT:
    case HID_MAPPING_RHYTHM_RIGHT:
    case HID_MAPPING_DROP_CRANE:
    case HID_MAPPING_ACCEPT:
    case HID_MAPPING_CANCEL:
    case HID_MAPPING_GRAB:
    case HID_MAPPING_STINGER:
    case HID_MAPPING_MENU_DOWN:
    case HID_MAPPING_MENU_UP:
    case HID_MAPPING_MENU_LEFT:
    case HID_MAPPING_MENU_RIGHT:
    case HID_MAPPING_MENU_ACCEPT:
    case HID_MAPPING_MENU_BACK:
    case HID_MAPPING_GYM_ACTION:
    case HID_MAPPING_GYM_EASIER_LEVEL:
    case HID_MAPPING_GYM_HARDER_LEVEL:
    case HID_MAPPING_BLACK_JACK_SPLIT:
    case HID_MAPPING_BLACK_JACK_DOUBLE:
    case HID_MAPPING_BLACK_JACK_HIT:
    case HID_MAPPING_BLACK_JACK_STAND:
    case HID_MAPPING_PLACE_BET:
    case HID_MAPPING_REMOVE_BET:
    case HID_MAPPING_HELICOPTER_MAGNET_UP:
    case HID_MAPPING_HELICOPTER_MAGNET_DOWN:
      return 0;
    default:
      result = ((int (__fastcall *)(CHIDKeyboard *))*this->_vptr$CHID)(this);
      break;
  }
  return result;
}

//----- (00295248) --------------------------------------------------------
bool __fastcall CHIDKeyboard::InternalIsDoubleTapped(CHIDKeyboard *this, HIDMapping Mapping)
{
  int v4; // r6
  unsigned int v5; // r4
  KeyboardButtonMapping *dataPtr; // r0
  KeyboardButtonMapping *v7; // r1
  int key; // r0
  unsigned int MouseButton; // r1

  if ( this->m_Mappings.numEntries )
  {
    v4 = 0;
    v5 = 0;
    while ( 1 )
    {
      dataPtr = this->m_Mappings.dataPtr;
      v7 = &dataPtr[v4];
      if ( dataPtr[v4].mapping != Mapping )
        goto LABEL_16;
      key = dataPtr[v4].key;
      if ( key <= 99 )
        break;
      MouseButton = v7->MouseButton;
      if ( MouseButton < 3 )
      {
        if ( LIB_PointerGetButton(0, MouseButton) )
          goto LABEL_16;
LABEL_9:
        if ( OS_TimeAccurate() - this->m_Mappings.dataPtr[v4].fLastReleaseTime < 0.330000013 )
          return 1;
        goto LABEL_16;
      }
      if ( MouseButton != 3 )
        goto LABEL_14;
      if ( LIB_PointerGetWheel(0) <= 0.0 )
      {
        MouseButton = this->m_Mappings.dataPtr[v4].MouseButton;
LABEL_14:
        if ( MouseButton == 4 )
          LIB_PointerGetWheel(0);
      }
LABEL_16:
      ++v5;
      ++v4;
      if ( v5 >= this->m_Mappings.numEntries )
        return 0;
    }
    if ( LIB_KeyboardState((OSKeyboardKey)key) )
      goto LABEL_16;
    goto LABEL_9;
  }
  return 0;
}

//----- (002952F8) --------------------------------------------------------
bool __fastcall CHIDKeyboard::InternalIsJustPressed(CHIDKeyboard *this, HIDMapping Mapping)
{
  return (*((int (__fastcall **)(CHIDKeyboard *, HIDMapping))this->_vptr$CHID + 5))(this, Mapping);
}

//----- (00295300) --------------------------------------------------------
bool __fastcall CHIDKeyboard::InternalIsPressed(CHIDKeyboard *this, HIDMapping Mapping, float *pfValueOut)
{
  unsigned int numEntries; // r0
  int v7; // r4
  unsigned int v8; // r5
  KeyboardButtonMapping *dataPtr; // r2
  int key; // r0
  OSPointerState Button; // r0
  unsigned int MouseButton; // r1
  int v13; // r0
  float v14; // s0

  numEntries = this->m_Mappings.numEntries;
  if ( !numEntries )
    return 0;
  v7 = 0;
  v8 = 0;
  while ( 1 )
  {
    dataPtr = this->m_Mappings.dataPtr;
    if ( dataPtr[v7].mapping == Mapping )
      break;
LABEL_22:
    ++v8;
    ++v7;
    if ( v8 >= numEntries )
      return 0;
  }
  key = dataPtr[v7].key;
  if ( key <= 99 )
  {
    Button = LIB_KeyboardState((OSKeyboardKey)key);
    goto LABEL_15;
  }
  MouseButton = dataPtr[v7].MouseButton;
  if ( MouseButton < 3 )
  {
    Button = LIB_PointerGetButton(0, MouseButton);
    goto LABEL_15;
  }
  if ( MouseButton == 3 )
  {
    if ( LIB_PointerGetWheel(0) > 0.0 )
    {
LABEL_13:
      Button = OSPS_ButtonPressed;
      goto LABEL_15;
    }
    MouseButton = this->m_Mappings.dataPtr[v7].MouseButton;
  }
  if ( MouseButton == 4 && LIB_PointerGetWheel(0) < 0.0 )
    goto LABEL_13;
  Button = OSPS_ButtonUp;
LABEL_15:
  v13 = Button | 1;
  if ( pfValueOut )
  {
    v14 = 0.0;
    if ( v13 == 3 )
    {
      v14 = 1.0;
      if ( this->m_Mappings.dataPtr[v7].bNegate )
        v14 = -1.0;
    }
    *pfValueOut = v14;
  }
  if ( v13 != 3 )
  {
    numEntries = this->m_Mappings.numEntries;
    goto LABEL_22;
  }
  return 1;
}

//----- (002953D0) --------------------------------------------------------
bool __fastcall CHIDKeyboard::InternalIsReleased(CHIDKeyboard *this, HIDMapping Mapping)
{
  int v4; // r6
  unsigned int v5; // r4
  KeyboardButtonMapping *dataPtr; // r0
  KeyboardButtonMapping *v7; // r1
  int key; // r0
  unsigned int MouseButton; // r1

  if ( !this->m_Mappings.numEntries )
    return 0;
  v4 = 0;
  v5 = 0;
  while ( 1 )
  {
    dataPtr = this->m_Mappings.dataPtr;
    v7 = &dataPtr[v4];
    if ( dataPtr[v4].mapping != Mapping )
      goto LABEL_15;
    key = dataPtr[v4].key;
    if ( key <= 99 )
    {
      if ( LIB_KeyboardState((OSKeyboardKey)key) == OSPS_ButtonReleased )
        return 1;
      goto LABEL_15;
    }
    MouseButton = v7->MouseButton;
    if ( MouseButton < 3 )
    {
      if ( LIB_PointerGetButton(0, MouseButton) == OSPS_ButtonReleased )
        return 1;
      goto LABEL_15;
    }
    if ( MouseButton == 3 )
    {
      if ( LIB_PointerGetWheel(0) > 0.0 )
        return 1;
      MouseButton = this->m_Mappings.dataPtr[v4].MouseButton;
    }
    if ( MouseButton == 4 && LIB_PointerGetWheel(0) < 0.0 )
      return 1;
LABEL_15:
    ++v5;
    ++v4;
    if ( v5 >= this->m_Mappings.numEntries )
      return 0;
  }
}

//----- (0029545A) --------------------------------------------------------
float __fastcall CHIDKeyboard::InternalGetMappingWeight(CHIDKeyboard *this, HIDMapping Mapping)
{
  unsigned int numEntries; // r12
  int v3; // r3
  MouseButtons *i; // r0
  MouseButtons v6; // r0
  float v7; // s0

  numEntries = this->m_Mappings.numEntries;
  if ( !numEntries )
    return 1.0;
  v3 = 0;
  for ( i = &this->m_Mappings.dataPtr->MouseButton; *((_DWORD *)i - 2) != Mapping; i += 5 )
  {
    if ( ++v3 >= numEntries )
      return 1.0;
  }
  v6 = *i;
  if ( v6 == MOUSE_WHEEL_FORWARD )
    return 0.25;
  v7 = 1.0;
  if ( v6 == MOUSE_WHEEL_BACKWARD )
    return 0.25;
  return v7;
}

//----- (002954AA) --------------------------------------------------------
void __fastcall CHIDKeyboard::AddMapping(
        CHIDKeyboard *this,
        OSKeyboardKey key,
        HIDMapping Mapping,
        bool bNegate,
        MouseButtons a5)
{
  unsigned int numEntries; // r11
  MouseButtons v8; // r5
  unsigned int v10; // r8
  KeyboardButtonMapping *v11; // r0
  KeyboardButtonMapping *v12; // r5
  KeyboardButtonMapping *dataPtr; // r6
  KeyboardButtonMapping *v14; // r0
  bool v15; // [sp+4h] [bp-24h]
  __int16 v16; // [sp+9h] [bp-1Fh]
  bool v17; // [sp+Bh] [bp-1Dh]

  numEntries = this->m_Mappings.numEntries;
  v8 = a5;
  if ( this->m_Mappings.numAlloced >= numEntries + 1 )
  {
    dataPtr = this->m_Mappings.dataPtr;
  }
  else
  {
    v15 = bNegate;
    v10 = 4 * (numEntries + 1) / 3 + 3;
    v11 = (KeyboardButtonMapping *)malloc(20 * v10);
    v12 = this->m_Mappings.dataPtr;
    dataPtr = v11;
    if ( v12 )
    {
      qmemcpy(v11, this->m_Mappings.dataPtr, 20 * numEntries);
      free(v12);
      numEntries = this->m_Mappings.numEntries;
    }
    this->m_Mappings.dataPtr = dataPtr;
    this->m_Mappings.numAlloced = v10;
    bNegate = v15;
    v8 = a5;
  }
  dataPtr[numEntries].key = key;
  v14 = &dataPtr[numEntries];
  v14->bNegate = bNegate;
  v14->mapping = Mapping;
  *(&v14->bNegate + 3) = v17;
  v14->MouseButton = v8;
  v14->fLastReleaseTime = 0.0;
  *(_WORD *)(&v14->bNegate + 1) = v16;
  ++this->m_Mappings.numEntries;
}
// 295530: variable 'v17' is possibly undefined
// 295538: variable 'v16' is possibly undefined

//----- (0029554A) --------------------------------------------------------
void __fastcall CHIDKeyboard::ReplaceMapping(
        CHIDKeyboard *this,
        HIDMapping Mapping,
        OSKeyboardKey key,
        int bNegate,
        MouseButtons a5)
{
  unsigned int numEntries; // lr
  int v6; // r4
  unsigned int i; // r5
  KeyboardButtonMapping *dataPtr; // r8
  HIDMapping v9; // r6
  bool v10; // zf

  numEntries = this->m_Mappings.numEntries;
  if ( numEntries )
  {
    v6 = 0;
    for ( i = 0; i < numEntries; ++i )
    {
      dataPtr = this->m_Mappings.dataPtr;
      v9 = dataPtr[v6].mapping;
      v10 = v9 == Mapping;
      if ( v9 == Mapping )
        v10 = dataPtr[v6].bNegate == bNegate;
      if ( v10 )
      {
        dataPtr[v6].key = key;
        this->m_Mappings.dataPtr[v6].MouseButton = a5;
        numEntries = this->m_Mappings.numEntries;
      }
      ++v6;
    }
  }
}

//----- (0029559A) --------------------------------------------------------
void __fastcall CHIDKeyboard::InternalCacheAnalogValues(CHIDKeyboard *this, unsigned int gamepadIndex)
{
  unsigned int v3; // r5
  int v4; // r6
  KeyboardButtonMapping *dataPtr; // r1
  int v6; // r0
  unsigned int v7; // r1
  float v8; // s0

  if ( this->m_Mappings.numEntries )
  {
    v3 = 0;
    v4 = 12;
    do
    {
      dataPtr = this->m_Mappings.dataPtr;
      v6 = *(_DWORD *)((char *)dataPtr + v4 - 12);
      if ( v6 > 99 )
      {
        v7 = *(OSKeyboardKey *)((char *)&dataPtr->key + v4);
        if ( v7 >= 3 )
        {
          if ( v7 != 3 )
            goto LABEL_12;
          if ( LIB_PointerGetWheel(0) <= 0.0 )
          {
            v7 = *(OSKeyboardKey *)((char *)&this->m_Mappings.dataPtr->key + v4);
LABEL_12:
            if ( v7 == 4 )
              LIB_PointerGetWheel(0);
          }
        }
        else if ( LIB_PointerGetButton(0, v7) == OSPS_ButtonReleased )
        {
LABEL_8:
          v8 = OS_TimeAccurate();
          *(float *)((char *)&this->m_Mappings.dataPtr->mapping + v4) = v8;
        }
      }
      else if ( LIB_KeyboardState((OSKeyboardKey)v6) == OSPS_ButtonReleased )
      {
        goto LABEL_8;
      }
      ++v3;
      v4 += 20;
    }
    while ( v3 < this->m_Mappings.numEntries );
  }
}

//----- (00295618) --------------------------------------------------------
const unsigned __int8 *__fastcall CHIDKeyboard::GetTagName(OSKeyboardKey key)
{
  int v2; // r3
  const unsigned __int8 *result; // r0

  if ( !CHIDKeyboard::m_KeyPairs.numEntries )
    return "KEY_UNK";
  v2 = 0;
  for ( result = CHIDKeyboard::m_KeyPairs.dataPtr->m_szTag; *((_DWORD *)result - 1) != key; result += 12 )
  {
    if ( ++v2 >= CHIDKeyboard::m_KeyPairs.numEntries )
      return "KEY_UNK";
  }
  return result;
}

//----- (00295668) --------------------------------------------------------
GxtChar *__fastcall CHIDKeyboard::GetMappingString(CHIDKeyboard *this, HIDMapping Mapping, bool bNegate)
{
  unsigned int numEntries; // r12
  unsigned int v4; // r3
  bool *p_bNegate; // lr
  int v6; // r0
  bool v7; // zf
  unsigned int v8; // r2
  unsigned __int8 *m_szTag; // r1
  int v10; // r4
  unsigned int v11; // r0
  unsigned int v12; // r3

  numEntries = this->m_Mappings.numEntries;
  if ( numEntries )
  {
    v4 = 0;
    p_bNegate = &this->m_Mappings.dataPtr->bNegate;
    while ( 1 )
    {
      v6 = *((_DWORD *)p_bNegate - 1);
      v7 = v6 == Mapping;
      if ( v6 == Mapping )
        v7 = *p_bNegate == bNegate;
      if ( v7 )
        break;
      ++v4;
      p_bNegate += 20;
      if ( v4 >= numEntries )
        goto LABEL_7;
    }
    v10 = *((_DWORD *)p_bNegate - 2);
    if ( v10 == 100 && (v11 = *((_DWORD *)p_bNegate + 1), v11 < 5) )
    {
      m_szTag = (unsigned __int8 *)off_662510[v11];
    }
    else if ( CHIDKeyboard::m_KeyPairs.numEntries )
    {
      v12 = 0;
      m_szTag = CHIDKeyboard::m_KeyPairs.dataPtr->m_szTag;
      while ( *((_DWORD *)m_szTag - 1) != v10 )
      {
        ++v12;
        m_szTag += 12;
        if ( v12 >= CHIDKeyboard::m_KeyPairs.numEntries )
        {
          m_szTag = "KEY_UNK";
          return sub_18A500(&TheText, m_szTag);
        }
      }
    }
    else
    {
      m_szTag = "KEY_UNK";
    }
  }
  else
  {
LABEL_7:
    if ( CHIDKeyboard::m_KeyPairs.numEntries )
    {
      v8 = 0;
      m_szTag = CHIDKeyboard::m_KeyPairs.dataPtr->m_szTag;
      while ( *((_DWORD *)m_szTag - 1) != 100 )
      {
        ++v8;
        m_szTag += 12;
        if ( v8 >= CHIDKeyboard::m_KeyPairs.numEntries )
        {
          m_szTag = "KEY_UNK";
          return sub_18A500(&TheText, m_szTag);
        }
      }
    }
    else
    {
      m_szTag = "KEY_UNK";
    }
  }
  return sub_18A500(&TheText, m_szTag);
}
// 662510: using guessed type char *off_662510[5];

//----- (00295750) --------------------------------------------------------
void __fastcall CHIDKeyboard::SaveMappingsToDisk(CHIDKeyboard *this)
{
  u_native v2; // r4
  size_t v3; // r0
  size_t v4; // r0
  unsigned int v5; // r5
  KeyboardButtonMapping *dataPtr; // r0
  OSKeyboardKey key; // r2
  unsigned int v8; // r3
  const char *m_szTag; // r1
  KeyboardButtonMapping *v10; // r0
  HIDMapping mapping; // r1
  bool v12; // zf
  int *v13; // r0
  size_t v14; // r0
  _DWORD v15[64]; // [sp+18h] [bp-320h] BYREF
  char v16[512]; // [sp+118h] [bp-220h] BYREF

  CFileMgr::SetDirMyDocuments();
  v2 = CFileMgr::OpenFileForWriting("KeyboardMappings.cfg");
  strcpy(v16, "; Key, Mapping, Negate (used internally)\n");
  v3 = strlen(v16);
  CFileMgr::Write(v2, (unsigned __int8 *)v16, v3);
  strcpy(v16, ";-----------------------------------\n");
  v4 = strlen(v16);
  CFileMgr::Write(v2, (unsigned __int8 *)v16, v4);
  if ( this->m_Mappings.numEntries )
  {
    v5 = 0;
    do
    {
      dataPtr = this->m_Mappings.dataPtr;
      key = dataPtr[v5].key;
      if ( key == KK_MAX )
      {
        switch ( dataPtr[v5].MouseButton )
        {
          case LEFT_MOUSE_BUTTON:
            strcpy((char *)v15, "KEY_LMB");
            break;
          case RIGHT_MOUSE_BUTTON:
            strcpy((char *)v15, "KEY_RMB");
            break;
          case MIDDLE_MOUSE_BUTTON:
            strcpy((char *)v15, "KEY_MMB");
            break;
          case MOUSE_WHEEL_FORWARD:
            v15[0] = 1599685963;
            v15[1] = &loc_444656;
            break;
          case MOUSE_WHEEL_BACKWARD:
            v15[0] = 1599685963;
            v15[1] = (char *)&loc_444254 + 3;
            break;
          default:
            break;
        }
      }
      else
      {
        if ( CHIDKeyboard::m_KeyPairs.numEntries )
        {
          v8 = 0;
          m_szTag = (const char *)CHIDKeyboard::m_KeyPairs.dataPtr->m_szTag;
          while ( *((_DWORD *)m_szTag - 1) != key )
          {
            ++v8;
            m_szTag += 12;
            if ( v8 >= CHIDKeyboard::m_KeyPairs.numEntries )
            {
              m_szTag = "KEY_UNK";
              break;
            }
          }
        }
        else
        {
          m_szTag = "KEY_UNK";
        }
        strcpy((char *)v15, m_szTag);
        dataPtr = this->m_Mappings.dataPtr;
      }
      v10 = &dataPtr[v5];
      mapping = v10->mapping;
      v12 = !v10->bNegate;
      v13 = &dword_295980;
      if ( !v12 )
        v13 = &dword_295984;
      sprintf(
        (unsigned __int8 *)v16,
        "%s %s %s\n",
        (const char *)v15,
        (const char *)CHID::m_MappingPairs.dataPtr[mapping].m_szMapping,
        (const char *)v13);
      v14 = strlen(v16);
      CFileMgr::Write(v2, (unsigned __int8 *)v16, v14);
      ++v5;
    }
    while ( v5 < this->m_Mappings.numEntries );
  }
  CFileMgr::CloseFile(v2);
  CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
}
// 295980: using guessed type int dword_295980;
// 295984: using guessed type int dword_295984;
// 61CADE: using guessed type char byte_61CADE;

//----- (002959A4) --------------------------------------------------------
bool __fastcall CHIDKeyboard::LoadMappingsFromDisk(CHIDKeyboard *this, bool bUserStorage)
{
  u_native v3; // r0
  u_native v4; // r6
  unsigned __int8 *i; // r4
  unsigned int numEntries; // r5
  u_native v7; // r8
  unsigned int v8; // r6
  unsigned __int8 *m_szTag; // r4
  int v10; // r5
  int v11; // r4
  HIDMapping MappingByName; // r8
  int v13; // r0
  unsigned int v14; // r10
  bool v15; // zf
  char v16; // r11
  unsigned int v17; // r0
  KeyboardButtonMapping *v18; // r0
  CHIDKeyboard *v19; // r5
  KeyboardButtonMapping *dataPtr; // r4
  KeyboardButtonMapping *v21; // r9
  KeyboardButtonMapping *v22; // r0
  unsigned int v24; // [sp+8h] [bp-338h]
  int v25; // [sp+Ch] [bp-334h]
  int v26; // [sp+18h] [bp-328h]
  __int16 v27; // [sp+1Dh] [bp-323h]
  bool v28; // [sp+1Fh] [bp-321h]
  char v29[256]; // [sp+20h] [bp-320h] BYREF
  unsigned __int8 pszMapping[256]; // [sp+120h] [bp-220h] BYREF
  char v31[256]; // [sp+220h] [bp-120h] BYREF

  if ( bUserStorage )
    CFileMgr::SetDirMyDocuments();
  else
    CFileMgr::SetDir("data");
  v3 = CFileMgr::OpenFile("KeyboardMappings.cfg", (const unsigned __int8 *)&dword_295BD4);
  v4 = v3;
  if ( v3 )
  {
    this->m_Mappings.numEntries = 0;
    for ( i = CFileLoader::LoadLine(v3); i; i = CFileLoader::LoadLine(v4) )
    {
      if ( *i && !strchr((const char *)i, 59) )
      {
        sscanf((const char *)i, "%s %s %s", v31, pszMapping, v29);
        numEntries = CHIDKeyboard::m_KeyPairs.numEntries;
        if ( CHIDKeyboard::m_KeyPairs.numEntries )
        {
          v7 = v4;
          v8 = 0;
          m_szTag = CHIDKeyboard::m_KeyPairs.dataPtr->m_szTag;
          while ( strcasecmp(v31, (const char *)m_szTag) )
          {
            ++v8;
            m_szTag += 12;
            if ( v8 >= numEntries )
            {
              v10 = 100;
              goto LABEL_15;
            }
          }
          v10 = *((_DWORD *)m_szTag - 1);
LABEL_15:
          v4 = v7;
        }
        else
        {
          v10 = 100;
        }
        if ( !strcasecmp(v31, "KEY_LMB") )
        {
          v11 = 0;
        }
        else if ( !strcasecmp(v31, "KEY_RMB") )
        {
          v11 = 1;
        }
        else if ( !strcasecmp(v31, "KEY_MMB") )
        {
          v11 = 2;
        }
        else if ( !strcasecmp(v31, "KEY_WFD") )
        {
          v11 = 3;
        }
        else
        {
          v11 = -1;
          if ( !strcasecmp(v31, "KEY_WBD") )
            v11 = 4;
        }
        MappingByName = CHID::GetMappingByName(pszMapping);
        if ( MappingByName )
        {
          v26 = v11;
          v13 = strcasecmp(v29, (const char *)&dword_295BEC);
          v14 = this->m_Mappings.numEntries;
          v15 = v13 == 0;
          v16 = 0;
          v17 = v14 + 1;
          if ( v15 )
            v16 = 1;
          if ( this->m_Mappings.numAlloced >= v17 )
          {
            dataPtr = this->m_Mappings.dataPtr;
          }
          else
          {
            v25 = v10;
            v24 = 4 * v17 / 3 + 3;
            v18 = (KeyboardButtonMapping *)malloc(20 * v24);
            v19 = this;
            dataPtr = v18;
            v21 = this->m_Mappings.dataPtr;
            if ( v21 )
            {
              qmemcpy(v18, v21, 20 * v14);
              free(v21);
              v14 = v19->m_Mappings.numEntries;
            }
            this = v19;
            v19->m_Mappings.dataPtr = dataPtr;
            v19->m_Mappings.numAlloced = v24;
            v10 = v25;
          }
          dataPtr[v14].key = v10;
          v22 = &dataPtr[v14];
          v22->bNegate = v16;
          v22->mapping = MappingByName;
          *(&v22->bNegate + 3) = v28;
          v22->MouseButton = v26;
          v22->fLastReleaseTime = 0.0;
          *(_WORD *)(&v22->bNegate + 1) = v27;
          ++this->m_Mappings.numEntries;
        }
      }
    }
    CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
    CFileMgr::CloseFile(v4);
    return 1;
  }
  else
  {
    CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
    return 0;
  }
}
// 295B64: variable 'v28' is possibly undefined
// 295B6E: variable 'v27' is possibly undefined
// 295BD4: using guessed type int dword_295BD4;
// 295BEC: using guessed type int dword_295BEC;
// 61CADE: using guessed type char byte_61CADE;
// 2959A4: using guessed type char var_320[256];
// 2959A4: using guessed type unsigned __int8 pszMapping[256];

//----- (00295C10) --------------------------------------------------------
void CHIDKeyboard::RestoreDefaultMappings()
{
  if ( CHID::m_pInstance[0] )
  {
    if ( CHID::GetInputType() == 2 )
      (*((void (__fastcall **)(CHID *))CHID::m_pInstance[0]->_vptr$CHID + 22))(CHID::m_pInstance[0]);
  }
}

//----- (00295C48) --------------------------------------------------------
void __fastcall OSArray<KeyPair>::~OSArray(OSArray<KeyPair> *this)
{
  KeyPair *dataPtr; // r0

  dataPtr = this->dataPtr;
  this->numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->dataPtr = 0;
  }
  this->numAlloced = 0;
}

//----- (00295C62) --------------------------------------------------------
HIDInputType __fastcall CHIDKeyboard::InternalGetInputType(CHIDKeyboard *this)
{
  return 2;
}

//----- (00295C68) --------------------------------------------------------
void __fastcall CHIDKeyboard::~CHIDKeyboard(CHIDKeyboard *this)
{
  KeyboardButtonMapping *dataPtr; // r0

  this->_vptr$CHID = (int (**)(void))&off_6624A8;
  CSprite2d::~CSprite2d(&this->m_Sprite);
  dataPtr = this->m_Mappings.dataPtr;
  this->m_Mappings.numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->m_Mappings.dataPtr = 0;
  }
  this->m_Mappings.numAlloced = 0;
}
// 6624A8: using guessed type void *off_6624A8;

//----- (00295CA0) --------------------------------------------------------
void __fastcall CHIDKeyboardPC::CHIDKeyboardPC(CHIDKeyboardPC *this, const unsigned __int8 *pszIconSprite)
{
  CHIDKeyboard::CHIDKeyboard(this, pszIconSprite);
  this->_vptr$CHID = (int (**)(void))&off_66252C;
  CHIDKeyboardPC::DoDefaultMappings(this);
  CHIDKeyboard::LoadMappingsFromDisk(this, 1);
}
// 66252C: using guessed type void *;

//----- (00295CCC) --------------------------------------------------------
void __fastcall CHIDKeyboardPC::DoDefaultMappings(CHIDKeyboardPC *this)
{
  this->m_Mappings.numEntries = 0;
  CHIDKeyboard::AddMapping(this, KK_LEFTSHIFT, HID_MAPPING_SPRINT, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_W, HID_MAPPING_ACCELERATE, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_MAX, HID_MAPPING_ATTACK, 0, LEFT_MOUSE_BUTTON);
  CHIDKeyboard::AddMapping(this, KK_SPACE, HID_MAPPING_JUMP, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_S, HID_MAPPING_BRAKE, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_TAB, HID_MAPPING_ENTER_CAR, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_MAX, HID_MAPPING_CAMERA_CLOSER, 0, MOUSE_WHEEL_FORWARD);
  CHIDKeyboard::AddMapping(this, KK_MAX, HID_MAPPING_CAMERA_FARTHER, 0, MOUSE_WHEEL_BACKWARD);
  CHIDKeyboard::AddMapping(this, KK_3, HID_MAPPING_RADIO_PREV_STATION, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_4, HID_MAPPING_RADIO_NEXT_STATION, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_MAX, HID_MAPPING_RADIO_NEXT_STATION, 0, MIDDLE_MOUSE_BUTTON);
  CHIDKeyboard::AddMapping(this, KK_LEFTCONTROL, HID_MAPPING_VITAL_STATS, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_1, HID_MAPPING_PREV_WEAPON, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_2, HID_MAPPING_NEXT_WEAPON, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_MAX, HID_MAPPING_NEXT_WEAPON, 0, RIGHT_MOUSE_BUTTON);
  CHIDKeyboard::AddMapping(this, KK_MAX, HID_MAPPING_HANDBRAKE, 0, RIGHT_MOUSE_BUTTON);
  CHIDKeyboard::AddMapping(this, KK_C, HID_MAPPING_CROUCH, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_V, HID_MAPPING_HORN, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_MAX, HID_MAPPING_PED_LOOK_BACK, 0, MIDDLE_MOUSE_BUTTON);
  CHIDKeyboard::AddMapping(this, KK_Q, HID_MAPPING_VEHICLE_LOOK_LEFT, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_E, HID_MAPPING_VEHICLE_LOOK_RIGHT, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_SPACE, HID_MAPPING_VEHICLE_LOOK_BACK, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_R, HID_MAPPING_MISSION_START_AND_CANCEL, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_R, HID_MAPPING_MISSION_START_AND_CANCEL_VIGILANTE, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_C, HID_MAPPING_AUTO_HYDRAULICS, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_E, HID_MAPPING_SWAP_WEAPONS_AND_PURCHASE, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_MAX, HID_MAPPING_WEAPON_ZOOM_IN, 0, MOUSE_WHEEL_FORWARD);
  CHIDKeyboard::AddMapping(this, KK_MAX, HID_MAPPING_WEAPON_ZOOM_OUT, 0, MOUSE_WHEEL_BACKWARD);
  CHIDKeyboard::AddMapping(this, KK_Q, HID_MAPPING_ENTER_AND_EXIT_TARGETING, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_R, HID_MAPPING_VEHICLE_BOMB, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_A, HID_MAPPING_VEHICLE_STEER_X, 1, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_D, HID_MAPPING_VEHICLE_STEER_X, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_A, HID_MAPPING_VEHICLE_STEER_LEFT, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_D, HID_MAPPING_VEHICLE_STEER_RIGHT, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_A, HID_MAPPING_PED_MOVE_X, 1, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_D, HID_MAPPING_PED_MOVE_X, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_S, HID_MAPPING_PED_MOVE_Y, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_W, HID_MAPPING_PED_MOVE_Y, 1, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_E, HID_MAPPING_MAGNET, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_SPACE, HID_MAPPING_SKIP_CUTSCENE, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_ENTER, HID_MAPPING_SKIP_CUTSCENE, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_E, HID_MAPPING_GANG_RECRUIT, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_R, HID_MAPPING_GANG_IGNORE, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_E, HID_MAPPING_GANG_FOLLOW, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_R, HID_MAPPING_GANG_HOLD_POSITION, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_ARROWUP, HID_MAPPING_RHYTHM_UP, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_ARROWDOWN, HID_MAPPING_RHYTHM_DOWN, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_ARROWLEFT, HID_MAPPING_RHYTHM_LEFT, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_ARROWRIGHT, HID_MAPPING_RHYTHM_RIGHT, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_E, HID_MAPPING_DROP_CRANE, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_E, HID_MAPPING_DROP_ITEM, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_E, HID_MAPPING_PHONE, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_X, HID_MAPPING_NITRO, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_C, HID_MAPPING_CRANE_UP, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_Z, HID_MAPPING_CRANE_DOWN, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_SPACE, HID_MAPPING_ACCEPT, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_ENTER, HID_MAPPING_ACCEPT, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_ESCAPE, HID_MAPPING_CANCEL, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_R, HID_MAPPING_GRAB, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_R, HID_MAPPING_STINGER, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_S, HID_MAPPING_MENU_DOWN, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_ARROWDOWN, HID_MAPPING_MENU_DOWN, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_W, HID_MAPPING_MENU_UP, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_ARROWUP, HID_MAPPING_MENU_UP, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_A, HID_MAPPING_MENU_LEFT, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_ARROWLEFT, HID_MAPPING_MENU_LEFT, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_D, HID_MAPPING_MENU_RIGHT, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_ARROWRIGHT, HID_MAPPING_MENU_RIGHT, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_SPACE, HID_MAPPING_MENU_ACCEPT, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_ENTER, HID_MAPPING_MENU_ACCEPT, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_ESCAPE, HID_MAPPING_MENU_BACK, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_BACKSPACE, HID_MAPPING_MENU_BACK, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_E, HID_MAPPING_GYM_ACTION, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_Z, HID_MAPPING_GYM_EASIER_LEVEL, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_C, HID_MAPPING_GYM_HARDER_LEVEL, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_W, HID_MAPPING_BLACK_JACK_SPLIT, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_D, HID_MAPPING_BLACK_JACK_DOUBLE, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_A, HID_MAPPING_BLACK_JACK_HIT, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_S, HID_MAPPING_BLACK_JACK_STAND, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_C, HID_MAPPING_PLACE_BET, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_Z, HID_MAPPING_REMOVE_BET, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_C, HID_MAPPING_HELICOPTER_MAGNET_UP, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_Z, HID_MAPPING_HELICOPTER_MAGNET_DOWN, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_LEFTSHIFT, HID_MAPPING_LOCK_HYDRAULICS, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_RIGHTSHIFT, HID_MAPPING_LOCK_HYDRAULICS, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_MAX, HID_MAPPING_FLIGHT_ASCEND, 0, LEFT_MOUSE_BUTTON);
  CHIDKeyboard::AddMapping(this, KK_MAX, HID_MAPPING_FLIGHT_DESCEND, 0, RIGHT_MOUSE_BUTTON);
  CHIDKeyboard::AddMapping(this, KK_E, HID_MAPPING_FLIGHT_PRIMARY_ATTACK, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_Q, HID_MAPPING_FLIGHT_SECONDARY_ATTACK, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_ARROWLEFT, HID_MAPPING_FLIGHT_ALT_LEFT, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_ARROWRIGHT, HID_MAPPING_FLIGHT_ALT_RIGHT, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_ARROWUP, HID_MAPPING_FLIGHT_ALT_UP, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_ARROWDOWN, HID_MAPPING_FLIGHT_ALT_DOWN, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_A, HID_MAPPING_TAKE_COVER_LEFT, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_D, HID_MAPPING_TAKE_COVER_RIGHT, 0, (MouseButtons)-1);
  CHIDKeyboard::AddMapping(this, KK_R, HID_MAPPING_KISS, 0, (MouseButtons)-1);
}

//----- (00296250) --------------------------------------------------------
CRect *__fastcall CHIDKeyboardPC::FindUVsFromMapping(
        CRect *retstr,
        CHIDKeyboardPC *this,
        const unsigned __int8 *pszCharacters,
        HIDMapping Mapping,
        bool bNegated)
{
  unsigned int numEntries; // lr
  unsigned int v6; // r2
  MouseButtons *p_MouseButton; // r1
  int v8; // r12
  int v9; // r4
  MouseButtons v10; // r5
  int32x4_t v11; // q8
  float32x4_t v12; // q9

  numEntries = this->m_Mappings.numEntries;
  if ( numEntries )
  {
    v6 = 0;
    p_MouseButton = &this->m_Mappings.dataPtr->MouseButton;
    v8 = 0;
    v9 = 0;
    do
    {
      if ( *((_DWORD *)p_MouseButton - 2) == Mapping )
      {
        v10 = *p_MouseButton;
        if ( *p_MouseButton <= (unsigned int)MOUSE_WHEEL_BACKWARD )
        {
          v8 = dword_2962E0[v10];
          v9 = dword_2962F4[v10];
        }
      }
      ++v6;
      p_MouseButton += 5;
    }
    while ( v6 < numEntries );
  }
  else
  {
    v9 = 0;
    v8 = 0;
  }
  v11.n128_u32[0] = v9;
  v11.n128_u32[2] = v9 + 1;
  v11.n128_u32[1] = v8 + 1;
  v11.n128_u32[3] = v8;
  v12.n128_u64[0] = 0x3EAAAA3B3EAAAA3BLL;
  v12.n128_u64[1] = 0x3EAAAA3B3EAAAA3BLL;
  *(float32x4_t *)retstr = vmulq_f32(vcvtq_f32_s32(v11), v12);
  return retstr;
}
// 2962E0: using guessed type int dword_2962E0[2];
// 2962F4: using guessed type int dword_2962F4[3];

//----- (00296308) --------------------------------------------------------
void __fastcall CHIDKeyboardPC::~CHIDKeyboardPC(CHIDKeyboardPC *this)
{
  KeyboardButtonMapping *dataPtr; // r0

  this->_vptr$CHID = (int (**)(void))&off_6624A8;
  CSprite2d::~CSprite2d(&this->m_Sprite);
  dataPtr = this->m_Mappings.dataPtr;
  this->m_Mappings.numEntries = 0;
  if ( dataPtr )
    free(dataPtr);
  sub_191374(this);
}
// 6624A8: using guessed type void *off_6624A8;

//----- (00296340) --------------------------------------------------------
void __fastcall CHoldEffect::CHoldEffect(
        CHoldEffect *this,
        const unsigned __int8 *pszSprite,
        bool bSquare,
        CRGBA Color,
        bool bExplicitRender)
{
  CSprite2d *v9; // r0
  CHoldEffect *v10; // r3
  CHoldEffect **p_m_pNext; // r5
  RwUInt8 v12; // r1

  CSprite2d::CSprite2d(&this->m_Sprite);
  *(_QWORD *)&this->m_RectScreen.left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_RectScreen.right = 0x49742400C9742400LL;
  v10 = CHoldEffect::m_pChainTail;
  this->m_pPrev = CHoldEffect::m_pChainTail;
  this->m_pNext = 0;
  p_m_pNext = &v10->m_pNext;
  if ( !v10 )
    p_m_pNext = &CHoldEffect::m_pChainHead;
  *p_m_pNext = this;
  CHoldEffect::m_pChainTail = this;
  this->m_bSquare = bSquare;
  this->m_fProgress = 0.0;
  this->m_Color._anon_0._anon_0.red = *(_BYTE *)Color._anon_0._anon_0.red;
  this->m_Color._anon_0._anon_0.green = *(_BYTE *)(*(_DWORD *)&Color + 1);
  this->m_Color._anon_0._anon_0.blue = *(_BYTE *)(*(_DWORD *)&Color + 2);
  v12 = *(_BYTE *)(*(_DWORD *)&Color + 3);
  this->m_bExplicitRender = bExplicitRender;
  this->m_Color._anon_0._anon_0.alpha = v12;
  if ( pszSprite )
    CWidget::SetTextureStatic(v9, (unsigned __int8 *)pszSprite);
}
// 2963B4: variable 'v9' is possibly undefined

//----- (002963D8) --------------------------------------------------------
void __fastcall CHoldEffect::~CHoldEffect(CHoldEffect *this)
{
  CHoldEffect **p_m_pNext; // r3
  __int64 v3; // r0

  p_m_pNext = &this->m_pPrev->m_pNext;
  if ( !this->m_pPrev )
    p_m_pNext = &CHoldEffect::m_pChainHead;
  *p_m_pNext = this->m_pNext;
  v3 = *(_QWORD *)&this->m_pPrev;
  if ( !this->m_pNext )
    HIDWORD(v3) = &CHoldEffect::m_pChainTail;
  *(_DWORD *)HIDWORD(v3) = v3;
  CSprite2d::~CSprite2d(&this->m_Sprite);
}

//----- (00296418) --------------------------------------------------------
void __fastcall CHoldEffect::Draw(CHoldEffect *this)
{
  float32x2_t v1; // d2
  float32x2_t v2; // d8
  CSprite2d *p_m_Sprite; // r0
  float v5; // s2
  int v6; // r1
  float left; // s18
  int v8; // r8
  float right; // s6
  int v10; // r11
  float top; // s4
  float bottom; // s20
  float v13; // s22
  float v14; // s24
  float v15; // s26
  float v16; // s28
  float v17; // s30
  float v18; // s23
  float v19; // s25
  float v20; // r5
  float v21; // r0
  char *v22; // r1
  float v23; // s0
  float *v24; // r0
  float v25; // s4
  float v26; // s0
  float v27; // s2
  RwInt32 v28; // r8
  int *v29; // r1
  int *v30; // r0
  float v31; // s0
  float v32; // r12
  float *p_t; // r3
  int v34; // r6
  int v35; // r2
  int v36; // r5
  int v37; // r2
  int v38; // r5
  int v39; // [sp+Ch] [bp-364h]
  char v40[4]; // [sp+10h] [bp-360h] BYREF
  _BYTE v41[384]; // [sp+14h] [bp-35Ch] BYREF
  int v42; // [sp+194h] [bp-1DCh] BYREF

  v1.n64_u32[0] = LODWORD(this->m_fProgress);
  if ( v1.n64_f32[0] > 0.0 )
  {
    p_m_Sprite = &this->m_Sprite;
    if ( this->m_Sprite.mpTexture )
    {
      v2.n64_u32[0] = 1.0;
      v5 = 0.5;
      if ( this->m_bSquare )
        v5 = 0.6;
      v1.n64_f32[0] = v1.n64_f32[0] * 16.0;
      v6 = (int)vmax_f32(v1, v2).n64_f32[0];
      if ( v6 <= 0 )
      {
        v28 = 3 * v6;
      }
      else
      {
        left = this->m_RectScreen.left;
        v8 = 0;
        right = this->m_RectScreen.right;
        v10 = 0;
        top = this->m_RectScreen.top;
        bottom = this->m_RectScreen.bottom;
        v39 = v6;
        v13 = fabsf(right - left);
        v14 = v13 * v5;
        v15 = (float)(left + right) * 0.5;
        v16 = (float)(top + bottom) * 0.5;
        v17 = fabsf(top - bottom);
        do
        {
          v18 = cosf((float)((float)(v10 + 1) * 0.3927) + -1.5708);
          v19 = v14 * sinf((float)((float)(v10 + 1) * 0.3927) + -1.5708);
          v20 = cosf((float)((float)v10 * 0.3927) + -1.5708);
          v21 = sinf((float)((float)v10 * 0.3927) + -1.5708);
          v22 = &v40[v8];
          *(_DWORD *)&v40[v8] = 1056964608;
          v23 = v14 * v21;
          *((_DWORD *)v22 + 1) = 1056964608;
          v24 = (float *)&v41[v8 + 380];
          v8 += 24;
          ++v10;
          *v24 = v15;
          v24[1] = v16;
          v25 = v15 + (float)(v14 * v18);
          v26 = v16 + v23;
          v27 = v15 + (float)(v14 * v20);
          v24[2] = v25;
          v24[3] = v16 + v19;
          v24[4] = v27;
          *((float *)v22 + 2) = (float)(v25 - left) / v13;
          *((float *)v22 + 3) = (float)((float)(v16 + v19) - bottom) / v17;
          *((float *)v22 + 4) = (float)(v27 - left) / v13;
          *((float *)v22 + 5) = (float)(v26 - bottom) / v17;
          v24[5] = v26;
        }
        while ( v39 != v10 );
        v28 = 3 * v39;
        v29 = &v42;
        v30 = (int *)v41;
        v31 = CSprite2d::NearScreenZ + 1.0;
        v32 = CSprite2d::RecipNearClip;
        p_t = &this->maVertices[0].t;
        v34 = 3 * v39;
        do
        {
          v35 = *v29;
          --v34;
          v36 = *(v29 - 1);
          v29 += 2;
          *(p_t - 4) = v31;
          *((_DWORD *)p_t - 6) = v36;
          *((_DWORD *)p_t - 5) = v35;
          *(p_t - 3) = v32;
          v37 = *(v30 - 1);
          v38 = *v30;
          v30 += 2;
          *((_DWORD *)p_t - 1) = v37;
          *(_DWORD *)p_t = v38;
          *((_BYTE *)p_t - 8) = this->m_Color._anon_0._anon_0.red;
          *((_BYTE *)p_t - 7) = this->m_Color._anon_0._anon_0.green;
          *((_BYTE *)p_t - 6) = this->m_Color._anon_0._anon_0.blue;
          *((_BYTE *)p_t - 5) = this->m_Color._anon_0._anon_0.alpha;
          p_t += 7;
        }
        while ( v34 );
        p_m_Sprite = &this->m_Sprite;
      }
      CSprite2d::SetRenderState(p_m_Sprite);
      RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRILIST, this->maVertices, v28);
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
    }
  }
}
// 2965B2: conditional instruction was optimized away because r1.4>=1
// 29646C: variable 'v1' is possibly undefined
// 29646C: variable 'v2' is possibly undefined

//----- (00296674) --------------------------------------------------------
void __fastcall CHoldEffect::SetVertices(
        CHoldEffect *this,
        int32 number,
        float *pVert,
        float *pTc,
        unsigned __int8 *a5)
{
  float *v5; // r3
  float *v6; // r2
  RwIm2DVertex *maVertices; // r0
  float v8; // lr
  float v9; // s0
  float v10; // r4
  float v11; // r4

  if ( number >= 1 )
  {
    v5 = pTc + 1;
    v6 = pVert + 1;
    maVertices = this->maVertices;
    v8 = CSprite2d::RecipNearClip;
    v9 = CSprite2d::NearScreenZ + 1.0;
    do
    {
      --number;
      maVertices->x = *(v6 - 1);
      v10 = *v6;
      v6 += 2;
      maVertices->z = v9;
      maVertices->y = v10;
      maVertices->rhw = v8;
      maVertices->s = *(v5 - 1);
      v11 = *v5;
      v5 += 2;
      maVertices->t = v11;
      maVertices->r = *a5;
      maVertices->g = a5[1];
      maVertices->b = a5[2];
      maVertices->a = a5[3];
      ++maVertices;
    }
    while ( number );
  }
}

//----- (002966F8) --------------------------------------------------------
void CHoldEffect::UpdateAll()
{
  CHoldEffect **p_m_pNext; // r0
  CHoldEffect *v1; // r1

  p_m_pNext = &CHoldEffect::m_pChainHead;
  do
  {
    v1 = *p_m_pNext;
    p_m_pNext = &(*p_m_pNext)->m_pNext;
  }
  while ( v1 );
}

//----- (0029670C) --------------------------------------------------------
void CHoldEffect::DrawAll()
{
  CHoldEffect *i; // r4

  for ( i = CHoldEffect::m_pChainHead; i; i = i->m_pNext )
  {
    if ( !i->m_bExplicitRender )
      CHoldEffect::Draw(i);
  }
}

//----- (00296740) --------------------------------------------------------
void __fastcall SCSetCurrentLangauge(const unsigned __int8 *lang)
{
  sub_1A12FC("SetLocale", lang);
}

//----- (00296750) --------------------------------------------------------
int NeedsAmazonDownload()
{
  int v0; // r4
  unsigned int *p_size; // r6
  int v2; // r0
  unsigned int v3; // r1
  bool v4; // zf
  unsigned int *v5; // r0
  int v6; // r1
  char v7; // r0
  unsigned __int8 s[64]; // [sp+8h] [bp-60h] BYREF

  if ( !OS_ServiceAppCommand("IsAmazonBuild", (const unsigned __int8 *)&byte_61CADE) )
    return 0;
  if ( !DownloadFileCount )
  {
    v0 = 0;
    TotalDownloadSizeMB = 0;
    DownloadFileCount = 12;
    TotalSizeDownloadedMB = 0;
    TotalDownloadPayloadMB = 0;
    p_size = &AmazonDownloadFilenames[0].size;
    do
    {
      sprintf(s, "%s;%d", (const char *)*(p_size - 1), *p_size);
      ++v0;
      if ( OS_ServiceAppCommand("IsDownloaded", s) )
      {
        v2 = 1;
        *((_BYTE *)p_size + 4) = 1;
      }
      else
      {
        v2 = *((unsigned __int8 *)p_size + 4);
      }
      v3 = *p_size;
      p_size += 4;
      v4 = v2 == 0;
      v5 = &TotalSizeDownloadedMB;
      v6 = (v3 >> 20) + 1;
      TotalDownloadPayloadMB += v6;
      if ( v4 )
      {
        needsAmazonDownload = 1;
        v5 = &TotalDownloadSizeMB;
      }
      *v5 += v6;
    }
    while ( v0 < DownloadFileCount );
  }
  v7 = TotalDownloadSizeMB;
  if ( TotalDownloadSizeMB )
    v7 = 1;
  return (unsigned __int8)v7 & needsAmazonDownload;
}
// 61CADE: using guessed type char byte_61CADE;

//----- (002968B0) --------------------------------------------------------
void SetupDataDownload()
{
  int v0; // r4
  unsigned int *p_size; // r6
  int v2; // r0
  unsigned int v3; // r1
  bool v4; // zf
  unsigned int *v5; // r0
  int v6; // r1
  unsigned __int8 s[64]; // [sp+8h] [bp-60h] BYREF

  DownloadFileCount = 12;
  v0 = 0;
  TotalDownloadPayloadMB = 0;
  TotalDownloadSizeMB = 0;
  TotalSizeDownloadedMB = 0;
  p_size = &AmazonDownloadFilenames[0].size;
  do
  {
    sprintf(s, "%s;%d", (const char *)*(p_size - 1), *p_size);
    ++v0;
    if ( OS_ServiceAppCommand("IsDownloaded", s) )
    {
      v2 = 1;
      *((_BYTE *)p_size + 4) = 1;
    }
    else
    {
      v2 = *((unsigned __int8 *)p_size + 4);
    }
    v3 = *p_size;
    p_size += 4;
    v4 = v2 == 0;
    v5 = &TotalSizeDownloadedMB;
    v6 = (v3 >> 20) + 1;
    TotalDownloadPayloadMB += v6;
    if ( v4 )
    {
      needsAmazonDownload = 1;
      v5 = &TotalDownloadSizeMB;
    }
    *v5 += v6;
  }
  while ( v0 < DownloadFileCount );
}

//----- (002969C4) --------------------------------------------------------
bool AllowNagScreen()
{
  return !OS_ServiceAppCommand("IsAmazonBuild", (const unsigned __int8 *)&byte_61CADE);
}
// 61CADE: using guessed type char byte_61CADE;

//----- (002969E4) --------------------------------------------------------
bool __fastcall IsFileDownloaded(int index)
{
  int v2; // r5
  bool result; // r0
  OSFile intoFile; // [sp+4h] [bp-Ch] BYREF

  result = 0;
  if ( OS_FileOpen(OSFDA_Storage_0, &intoFile, AmazonDownloadFilenames[index].name, OSFAT_Read_0) == OSFE_NoError )
  {
    v2 = OS_FileSize(intoFile);
    OS_FileClose(intoFile);
    if ( v2 == AmazonDownloadFilenames[index].size )
      return 1;
  }
  return result;
}

//----- (00296A34) --------------------------------------------------------
unsigned __int8 *__fastcall GetDownloadFilename(int index)
{
  int v2; // r5
  unsigned int *p_size; // r4
  int v4; // r0
  unsigned int v5; // r1
  bool v6; // zf
  unsigned int *v7; // r0
  int v8; // r1
  int v9; // r2
  int v10; // [sp+4h] [bp-6Ch]
  unsigned __int8 s[64]; // [sp+10h] [bp-60h] BYREF

  if ( DownloadFileCount )
  {
    if ( DownloadFileCount > index )
      return AmazonDownloadFilenames[index].name;
  }
  else
  {
    v10 = index;
    v2 = 0;
    TotalDownloadSizeMB = 0;
    DownloadFileCount = 12;
    TotalSizeDownloadedMB = 0;
    TotalDownloadPayloadMB = 0;
    p_size = &AmazonDownloadFilenames[0].size;
    do
    {
      sprintf(s, "%s;%d", (const char *)*(p_size - 1), *p_size);
      ++v2;
      if ( OS_ServiceAppCommand("IsDownloaded", s) )
      {
        v4 = 1;
        *((_BYTE *)p_size + 4) = 1;
      }
      else
      {
        v4 = *((unsigned __int8 *)p_size + 4);
      }
      v5 = *p_size;
      p_size += 4;
      v6 = v4 == 0;
      v7 = &TotalSizeDownloadedMB;
      v8 = (v5 >> 20) + 1;
      TotalDownloadPayloadMB += v8;
      if ( v6 )
      {
        needsAmazonDownload = 1;
        v7 = &TotalDownloadSizeMB;
      }
      v9 = DownloadFileCount;
      *v7 += v8;
    }
    while ( v2 < v9 );
    index = v10;
    if ( v9 > v10 )
      return AmazonDownloadFilenames[index].name;
  }
  return 0;
}

//----- (00296B74) --------------------------------------------------------
int UseHiDetailPlayer()
{
  return 0;
}

//----- (00296B78) --------------------------------------------------------
void __fastcall AddAmazonFiles(bool loadTexdb)
{
  _BOOL4 v1; // r6
  int v2; // r5
  unsigned int *p_size; // r4
  int v4; // r0
  unsigned int v5; // r1
  bool v6; // zf
  unsigned int *v7; // r0
  int v8; // r1
  int v9; // r4
  unsigned __int8 *DownloadFilename; // r0
  ZIPFile *v11; // r0
  unsigned __int8 s[64]; // [sp+10h] [bp-60h] BYREF

  v1 = loadTexdb;
  if ( !DownloadFileCount )
  {
    v2 = 0;
    TotalDownloadSizeMB = 0;
    DownloadFileCount = 12;
    TotalSizeDownloadedMB = 0;
    TotalDownloadPayloadMB = 0;
    p_size = &AmazonDownloadFilenames[0].size;
    do
    {
      sprintf(s, "%s;%d", (const char *)*(p_size - 1), *p_size);
      ++v2;
      if ( OS_ServiceAppCommand("IsDownloaded", s) )
      {
        v4 = 1;
        *((_BYTE *)p_size + 4) = 1;
      }
      else
      {
        v4 = *((unsigned __int8 *)p_size + 4);
      }
      v5 = *p_size;
      p_size += 4;
      v6 = v4 == 0;
      v7 = &TotalSizeDownloadedMB;
      v8 = (v5 >> 20) + 1;
      TotalDownloadPayloadMB += v8;
      if ( v6 )
      {
        needsAmazonDownload = 1;
        v7 = &TotalDownloadSizeMB;
      }
      *v7 += v8;
    }
    while ( v2 < DownloadFileCount );
  }
  if ( !NeedsAmazonDownload() )
  {
    if ( DownloadFileCount >= 1 )
    {
      v9 = 0;
      do
      {
        DownloadFilename = GetDownloadFilename(v9);
        if ( DownloadFilename )
        {
          v11 = ZIP_FileCreate(DownloadFilename);
          if ( v11 )
            ZIP_AddStorage(v11);
        }
        ++v9;
      }
      while ( v9 < DownloadFileCount );
    }
    if ( v1 )
    {
      TextureDatabaseRuntime::Load("mobile", 0, DF_Default);
      TextureDatabaseRuntime::Load("txd", 0, DF_Default);
      TextureDatabaseRuntime::Load("gta3", 0, DF_Default);
      TextureDatabaseRuntime::Load("gta_int", 0, DF_Default);
      TextureDatabaseRuntime::Load("cutscene", 0, DF_Default);
      TextureDatabaseRuntime::Load("player", 0, DF_PVR);
      TextureDatabaseRuntime::Load("menu", 0, DF_PVR);
    }
  }
}

//----- (00296D5C) --------------------------------------------------------
unsigned int __fastcall DownloadThread(void *data)
{
  int v1; // r0
  signed int v2; // r0
  unsigned __int8 s[64]; // [sp+8h] [bp-60h] BYREF

  sizeDownloadedMB = 0;
  OS_TimeMS();
  while ( 1 )
  {
    v1 = OS_ServiceAppCommandValue("GetDownloadState", (const unsigned __int8 *)&byte_61CADE);
    if ( v1 != 1 )
      break;
    sizeDownloadedMB = OS_ServiceAppCommandValue("GetDownloadBytes", (const unsigned __int8 *)&byte_61CADE) / 0x100000;
    v2 = 100 * (TotalSizeDownloadedMB + sizeDownloadedMB) / TotalDownloadPayloadMB;
    if ( !gMobileMenu.pendingScreen )
    {
      if ( v2 >= 100 )
        v2 = 100;
      (*gMobileMenu.screenStack.dataPtr)[4].arrowTex = (RwTexture_0 *)v2;
    }
    OS_ThreadSleep(5000);
  }
  if ( v1 == 2 )
  {
    sprintf(
      s,
      "%s;%d",
      (const char *)AmazonDownloadFilenames[currentDownloadFile].name,
      AmazonDownloadFilenames[currentDownloadFile].size);
    if ( OS_ServiceAppCommand("IsDownloaded", s) )
    {
      TotalSizeDownloadedMB += sizeDownloadedMB;
      AmazonDownloadFilenames[currentDownloadFile].isDownloaded = 1;
    }
  }
  else
  {
    if ( v1 != 4 )
      v1 = 3;
    CurrentDownloadingError = v1;
  }
  currentDownloadFile = -1;
  return 1;
}
// 61CADE: using guessed type char byte_61CADE;

//----- (00296EFC) --------------------------------------------------------
void __fastcall MobileMenu::UpdateDownload(MobileMenu *this, int percent, bool done)
{
  unsigned int numEntries; // r0
  MenuScreen *v5; // r0
  unsigned int v6; // r0
  MenuScreen *v7; // r0
  MainMenuScreen *v8; // r5
  unsigned int v9; // r6
  unsigned int v10; // r10
  MenuScreen **v11; // r0
  MenuScreen **v12; // r8
  MenuScreen **dataPtr; // r9

  if ( !this->pendingScreen )
  {
    if ( done )
    {
      numEntries = this->screenStack.numEntries;
      if ( numEntries )
      {
        if ( numEntries == 1 )
        {
          v5 = *this->screenStack.dataPtr;
          this->screenStack.numEntries = 0;
          if ( v5 )
          {
            (*((void (__fastcall **)(MenuScreen *))v5->_vptr$MenuScreen + 1))(v5);
            v6 = this->screenStack.numEntries;
            if ( v6 )
            {
              v7 = this->screenStack.dataPtr[v6 - 1];
              (*((void (__fastcall **)(MenuScreen *))v7->_vptr$MenuScreen + 4))(v7);
            }
          }
        }
        else
        {
          this->pendingScreen = this->screenStack.dataPtr[numEntries - 2];
        }
      }
      v8 = (MainMenuScreen *)operator new(0x58u);
      FlowScreen::FlowScreen(v8, 0, 0);
      v8->_vptr$MenuScreen = (int (**)(void))&off_6625C8;
      MainMenuScreen::AddAllItems(v8);
      if ( this->pendingScreen )
        MobileMenu::ProcessPending(this);
      v9 = this->screenStack.numEntries;
      if ( this->screenStack.numAlloced >= v9 + 1 )
      {
        dataPtr = this->screenStack.dataPtr;
      }
      else
      {
        v10 = 4 * (v9 + 1) / 3 + 3;
        v11 = (MenuScreen **)malloc(4 * v10);
        v12 = this->screenStack.dataPtr;
        dataPtr = v11;
        if ( v12 )
        {
          qmemcpy(v11, this->screenStack.dataPtr, 4 * v9);
          free(v12);
          v9 = this->screenStack.numEntries;
        }
        this->screenStack.dataPtr = dataPtr;
        this->screenStack.numAlloced = v10;
      }
      dataPtr[v9] = (MenuScreen *)v8;
      ++this->screenStack.numEntries;
      (*((void (__fastcall **)(MainMenuScreen *))v8->_vptr$MenuScreen + 4))(v8);
    }
    else
    {
      (*this->screenStack.dataPtr)[4].arrowTex = (RwTexture_0 *)percent;
    }
  }
}
// 6625C8: using guessed type void *off_6625C8;

//----- (00296FF8) --------------------------------------------------------
void __fastcall StartDownload(int index)
{
  int v1; // r6
  char v2[132]; // [sp+8h] [bp-98h] BYREF

  strcpy(v2, (const char *)AmazonDownloadFilenames[index].name);
  OS_ServiceAppCommand("Download", (const unsigned __int8 *)v2);
  OS_TimeMS();
  do
  {
    v1 = OS_ServiceAppCommandValue("GetDownloadState", (const unsigned __int8 *)&byte_61CADE);
    OS_TimeMS();
  }
  while ( !v1 );
  OS_ThreadLaunch(DownloadThread, 0, 1u, "DownloadThread", 0, 1);
}
// 61CADE: using guessed type char byte_61CADE;

//----- (002970B4) --------------------------------------------------------
int ProcessDataDownload()
{
  bool *p_isDownloaded; // r2
  int v2; // r0

  if ( CurrentDownloadingError )
  {
    OS_ServiceAppCommandValue("GetNetworkState", (const unsigned __int8 *)&byte_61CADE);
    return 1;
  }
  if ( currentDownloadFile != -1 )
    return 1;
  if ( DownloadFileCount >= 1 )
  {
    p_isDownloaded = &AmazonDownloadFilenames[0].isDownloaded;
    v2 = 0;
    while ( *p_isDownloaded )
    {
      ++v2;
      p_isDownloaded += 16;
      if ( v2 >= DownloadFileCount )
        goto LABEL_11;
    }
    currentDownloadFile = v2;
    StartDownload(v2);
    if ( currentDownloadFile != -1 )
      return 1;
  }
LABEL_11:
  MobileMenu::UpdateDownload(&gMobileMenu, 100, 1);
  needsAmazonDownload = 0;
  AddAmazonFiles(1);
  CAudioEngine::Initialise(&AudioEngine);
  return 0;
}
// 61CADE: using guessed type char byte_61CADE;

//----- (00297174) --------------------------------------------------------
CVector2D *__fastcall MenuToScreen(CVector2D *retstr, const CVector2D *coord)
{
  float v2; // s2

  v2 = (float)(coord->y * (float)RsGlobal.screenHeight) / 480.0;
  retstr->x = (float)((float)RsGlobal.screenWidth * 0.5)
            + (float)((float)((float)(coord->x + -320.0) * (float)RsGlobal.screenHeight) / 480.0);
  retstr->y = v2;
  return retstr;
}

//----- (002971D0) --------------------------------------------------------
CVector2D *__fastcall ScreenToMenu(CVector2D *retstr, const CVector2D *coord)
{
  float v2; // s2

  v2 = (float)(coord->y * 480.0) / (float)RsGlobal.screenHeight;
  retstr->x = (float)((float)((float)(coord->x * 480.0) + (float)((float)RsGlobal.screenWidth * -240.0))
                    / (float)RsGlobal.screenHeight)
            + 320.0;
  retstr->y = v2;
  return retstr;
}

//----- (00297230) --------------------------------------------------------
int __fastcall VectorInBox(float a1, float a2, float a3, float a4, float a5, float a6)
{
  int result; // r0

  if ( a1 < a3 || a1 > a5 )
    return 0;
  result = 0;
  if ( a2 >= a4 && a2 <= a6 )
    return 1;
  return result;
}

//----- (00297280) --------------------------------------------------------
RwTexture_0 *__fastcall GetTexture(const unsigned __int8 *name)
{
  RwTexture_0 *result; // r0

  result = TextureDatabaseRuntime::GetTexture(name);
  ++result->refCount;
  return result;
}

//----- (00297290) --------------------------------------------------------
void __fastcall DestroyTexture(RwTexture_0 **tex)
{
  RwTexture_0 *v2; // r0

  v2 = *tex;
  if ( v2 )
  {
    RwTextureDestroy(v2);
    *tex = 0;
  }
}

//----- (002972A8) --------------------------------------------------------
int PointerClicked()
{
  int v0; // r4

  v0 = 0;
  if ( gMobileMenu.pointerState[lastDevice] == OSPS_ButtonReleased
    && OS_TimeMS() - gMobileMenu.pointerPress[lastDevice] < 0xC8 )
  {
    return 1;
  }
  return v0;
}

//----- (00297304) --------------------------------------------------------
int PS3MenuActive()
{
  return 0;
}

//----- (00297308) --------------------------------------------------------
bool SelectPressed()
{
  return CHID::Implements(HID_MAPPING_MENU_ACCEPT) && sub_18DF74(HID_MAPPING_MENU_ACCEPT);
}

//----- (00297324) --------------------------------------------------------
bool BackPressed()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d2
  float32x2_t v2; // d4
  float v4; // s8
  float32x2_t v5; // d2
  float v6; // s6
  float x; // s8
  float v8; // s6
  float v9; // s0
  float y; // s2

  if ( gMobileMenu.pointerMode && gMobileMenu.pointerState[lastDevice] == OSPS_ButtonReleased )
  {
    v2.n64_u32[0] = 12.5;
    v1.n64_f32[0] = (float)RsGlobal.screenWidth * 0.0;
    v5.n64_u64[0] = vmax_f32(v1, v2).n64_u64[0];
    v4 = (float)RsGlobal.screenWidth - v5.n64_f32[0];
    v5.n64_u32[0] = 1139802112;
    v6 = (float)((float)((float)(v4 * 480.0) + (float)((float)RsGlobal.screenWidth * -240.0))
               / (float)RsGlobal.screenHeight)
       + 320.0;
    x = gMobileMenu.pointerCoords[lastDevice].x;
    v8 = v6 + 16.0;
    if ( x <= v8 && x >= (float)(v8 + -100.0) )
    {
      v0.n64_f32[0] = (float)((float)((float)((float)RsGlobal.screenHeight - (float)((float)RsGlobal.screenHeight * 0.0))
                                    * 480.0)
                            / (float)RsGlobal.screenHeight)
                    + 10.0;
      v9 = vmin_f32(v0, v5).n64_f32[0];
      y = gMobileMenu.pointerCoords[lastDevice].y;
      if ( y >= (float)(v9 + -50.0) && y <= v9 )
        return 1;
    }
  }
  return LIB_KeyboardState(KK_ESCAPE) == OSPS_ButtonReleased
      || CHID::Implements(HID_MAPPING_MENU_BACK) && CHID::IsReleased(HID_MAPPING_MENU_BACK);
}
// 29739E: variable 'v1' is possibly undefined
// 29739E: variable 'v2' is possibly undefined
// 297410: variable 'v0' is possibly undefined

//----- (00297464) --------------------------------------------------------
int UpPressed()
{
  float v0; // s0

  if ( CHID::Implements(HID_MAPPING_MENU_UP) || CHID::Implements(HID_MAPPING_PED_MOVE_Y) )
  {
    if ( CHID::IsReleased(HID_MAPPING_MENU_UP) )
      return 1;
    if ( CHID::IsPressedNegative(HID_MAPPING_PED_MOVE_Y) && OS_TimeAccurate() - fLastAnalogTime > 0.25 )
    {
      v0 = OS_TimeAccurate();
      fLastAnalogTime = v0;
      return 1;
    }
  }
  return 0;
}

//----- (002974D8) --------------------------------------------------------
int DownPressed()
{
  float v0; // s0

  if ( CHID::Implements(HID_MAPPING_MENU_DOWN) || CHID::Implements(HID_MAPPING_PED_MOVE_Y) )
  {
    if ( CHID::IsReleased(HID_MAPPING_MENU_DOWN) )
      return 1;
    if ( CHID::IsPressedPositive(HID_MAPPING_PED_MOVE_Y) && OS_TimeAccurate() - fLastAnalogTime > 0.25 )
    {
      v0 = OS_TimeAccurate();
      fLastAnalogTime = v0;
      return 1;
    }
  }
  return 0;
}

//----- (0029754C) --------------------------------------------------------
int LeftPressed()
{
  float v0; // s0

  if ( CHID::Implements(HID_MAPPING_MENU_LEFT) || CHID::Implements(HID_MAPPING_PED_MOVE_X) )
  {
    if ( CHID::IsReleased(HID_MAPPING_MENU_LEFT) )
      return 1;
    if ( CHID::IsPressedNegative(HID_MAPPING_PED_MOVE_X) && OS_TimeAccurate() - fLastAnalogTime > 0.25 )
    {
      v0 = OS_TimeAccurate();
      fLastAnalogTime = v0;
      return 1;
    }
  }
  return 0;
}

//----- (002975C0) --------------------------------------------------------
int RightPressed()
{
  float v0; // s0

  if ( CHID::Implements(HID_MAPPING_MENU_RIGHT) || CHID::Implements(HID_MAPPING_PED_MOVE_X) )
  {
    if ( CHID::IsReleased(HID_MAPPING_MENU_RIGHT) )
      return 1;
    if ( CHID::IsPressedPositive(HID_MAPPING_PED_MOVE_X) && OS_TimeAccurate() - fLastAnalogTime > 0.25 )
    {
      v0 = OS_TimeAccurate();
      fLastAnalogTime = v0;
      return 1;
    }
  }
  return 0;
}

//----- (00297634) --------------------------------------------------------
bool UpHeld()
{
  return (CHID::Implements(HID_MAPPING_MENU_UP) || CHID::Implements(HID_MAPPING_PED_MOVE_Y))
      && (CHID::IsPressed(HID_MAPPING_MENU_UP, 0) || CHID::IsPressedNegative(HID_MAPPING_PED_MOVE_Y));
}

//----- (00297664) --------------------------------------------------------
bool DownHeld()
{
  return (CHID::Implements(HID_MAPPING_MENU_DOWN) || CHID::Implements(HID_MAPPING_PED_MOVE_Y))
      && (CHID::IsPressed(HID_MAPPING_MENU_DOWN, 0) || CHID::IsPressedPositive(HID_MAPPING_PED_MOVE_Y));
}

//----- (00297694) --------------------------------------------------------
bool LeftHeld()
{
  return (CHID::Implements(HID_MAPPING_MENU_LEFT) || CHID::Implements(HID_MAPPING_PED_MOVE_X))
      && (CHID::IsPressed(HID_MAPPING_MENU_LEFT, 0) || CHID::IsPressedNegative(HID_MAPPING_PED_MOVE_X));
}

//----- (002976C4) --------------------------------------------------------
bool RightHeld()
{
  return (CHID::Implements(HID_MAPPING_MENU_RIGHT) || CHID::Implements(HID_MAPPING_PED_MOVE_X))
      && (CHID::IsPressed(HID_MAPPING_MENU_RIGHT, 0) || CHID::IsPressedPositive(HID_MAPPING_PED_MOVE_X));
}

//----- (002976F4) --------------------------------------------------------
bool ScrollUpHeld()
{
  return sub_1933F8(HID_MAPPING_LOOK_Y);
}

//----- (002976FA) --------------------------------------------------------
bool ScrollDownHeld()
{
  return sub_1906E0(HID_MAPPING_LOOK_Y);
}

//----- (00297700) --------------------------------------------------------
bool ScrollLeftHeld()
{
  return sub_1933F8(HID_MAPPING_LOOK_X);
}

//----- (00297706) --------------------------------------------------------
bool ScrollRightHeld()
{
  return sub_1906E0(HID_MAPPING_LOOK_X);
}

//----- (0029770C) --------------------------------------------------------
void PlayNavSound()
{
  if ( !NeedsAmazonDownload() )
    sub_18FDC4(&AudioEngine, 3, 0.0, 1.0);
}

//----- (00297734) --------------------------------------------------------
void PlaySelectSound()
{
  if ( !NeedsAmazonDownload() )
    sub_18FDC4(&AudioEngine, 1, 0.0, 1.0);
}

//----- (0029775C) --------------------------------------------------------
void PlayBackSound()
{
  if ( !NeedsAmazonDownload() )
    sub_18FDC4(&AudioEngine, 2, 0.0, 1.0);
}

//----- (00297784) --------------------------------------------------------
void PlayErrorSound()
{
  if ( !NeedsAmazonDownload() )
    sub_18FDC4(&AudioEngine, 4, 0.0, 1.0);
}

//----- (002977AC) --------------------------------------------------------
void __fastcall MenuScreen::MenuScreen(MenuScreen *this, bool withBack)
{
  RwTexture *Texture; // r0

  this->hasBack = withBack;
  this->_vptr$MenuScreen = (int (**)(void))&off_662590;
  Texture = TextureDatabaseRuntime::GetTexture("menu_selector");
  ++Texture->refCount;
  *(_QWORD *)&this->arrowTex = (unsigned int)Texture;
}
// 662590: using guessed type void *off_662590;

//----- (002977E0) --------------------------------------------------------
void __fastcall MenuScreen::~MenuScreen(MenuScreen *this)
{
  RwTexture_0 *arrowTex; // r0

  arrowTex = this->arrowTex;
  this->_vptr$MenuScreen = (int (**)(void))&off_662590;
  if ( arrowTex )
  {
    RwTextureDestroy(arrowTex);
    this->arrowTex = 0;
  }
}
// 662590: using guessed type void *off_662590;

//----- (00297806) --------------------------------------------------------
void __fastcall MenuScreen::Update(MenuScreen *this, float deltaTime)
{
  float opacity; // s2
  float v3; // s2

  opacity = this->opacity;
  if ( opacity < 1.0 )
  {
    v3 = (float)(deltaTime * 5.0) + opacity;
    this->opacity = v3;
    if ( v3 > 1.0 )
      this->opacity = 1.0;
  }
}

//----- (00297840) --------------------------------------------------------
float GetTitleSafeFontTop()
{
  float v0; // s18

  CFont::SetScale((float)((float)RsGlobal.screenHeight * 1.35) / 480.0);
  v0 = (float)RsGlobal.screenHeight + (float)((float)RsGlobal.screenHeight * -0.0);
  return (float)((float)(v0 - CFont::GetHeight(0)) * 480.0) / (float)RsGlobal.screenHeight;
}

//----- (002978C0) --------------------------------------------------------
void __fastcall MenuScreen::DrawBack(MenuScreen *this, bool showAcceptButton)
{
  float32x2_t v2; // d2
  float32x2_t v3; // d3
  _BOOL4 v5; // r8
  float screenHeight; // s18
  float screenWidth; // s22
  float v8; // s0
  float v9; // s22
  float v10; // s18
  float v11; // s18
  float v12; // s16
  float x; // s0
  _BOOL4 v14; // r0
  float y; // s0
  GxtChar *v16; // r2
  float v17; // r1
  GxtChar *v18; // r0
  float v19; // s20
  int32 waypoint_blip; // r4
  const char *v21; // r1
  GxtChar *v22; // r0
  float v23; // s20
  float v24; // s22
  CSprite2d *v25; // r0
  RwTexture_0 *v26; // r5
  CRGBA *v27; // r6
  CSprite2d *HelpSprite; // r0
  RwTexture_0 *mpTexture; // r5
  GxtChar *v30; // r0
  CSprite2d *v31; // r0
  GxtChar *v32; // r0
  float v33; // r11
  CSprite2d *v34; // r0
  RwTexture_0 *v35; // r5
  CSprite2d *v36; // r0
  RwTexture_0 *v37; // r5
  CVector2D v38; // [sp+4h] [bp-ECh]
  CVector2D v39; // [sp+4h] [bp-ECh]
  CVector2D varECb; // [sp+4h] [bp-ECh]
  CVector2D varECc; // [sp+4h] [bp-ECh]
  CVector2D v42; // [sp+Ch] [bp-E4h]
  CVector2D v43; // [sp+Ch] [bp-E4h]
  CVector2D v44; // [sp+Ch] [bp-E4h]
  CVector2D v45; // [sp+Ch] [bp-E4h]
  CRGBA v46; // [sp+24h] [bp-CCh] BYREF
  CRGBA v47; // [sp+28h] [bp-C8h] BYREF
  CRGBA v48; // [sp+2Ch] [bp-C4h] BYREF
  CRGBA v49; // [sp+30h] [bp-C0h] BYREF
  CRGBA v50; // [sp+34h] [bp-BCh] BYREF
  CRGBA v51; // [sp+38h] [bp-B8h] BYREF
  CRGBA v52; // [sp+3Ch] [bp-B4h] BYREF
  CVector2D v53; // [sp+40h] [bp-B0h] BYREF
  CRGBA v54; // [sp+48h] [bp-A8h] BYREF
  CRGBA v55; // [sp+4Ch] [bp-A4h] BYREF
  CVector2D pvecUVRightBottom; // [sp+50h] [bp-A0h] BYREF
  __int64 v57; // [sp+58h] [bp-98h]
  __int64 v58; // [sp+60h] [bp-90h]
  __int64 v59; // [sp+68h] [bp-88h]
  CVector2D coords; // [sp+70h] [bp-80h] BYREF
  float v61; // [sp+78h] [bp-78h]
  float v62; // [sp+7Ch] [bp-74h]
  float v63; // [sp+80h] [bp-70h]
  float v64; // [sp+84h] [bp-6Ch]
  float v65; // [sp+88h] [bp-68h]
  float v66; // [sp+8Ch] [bp-64h]
  CRGBA v67; // [sp+90h] [bp-60h] BYREF
  CRGBA v68; // [sp+94h] [bp-5Ch] BYREF
  CRGBA v69; // [sp+98h] [bp-58h] BYREF
  int v70[21]; // [sp+9Ch] [bp-54h] BYREF
  CVector2D v71; // 0:r3.4,4:^0.4
  CVector2D v72; // 0:r3.4,4:^0.4
  CVector2D cvector2db; // 0:r3.4,4:^0.4
  CVector2D cvector2dc; // 0:r3.4,4:^0.4

  v5 = showAcceptButton;
  screenHeight = (float)RsGlobal.screenHeight;
  screenWidth = (float)RsGlobal.screenWidth;
  CFont::SetScale((float)((float)RsGlobal.screenHeight * 1.35) / 480.0);
  v2.n64_u32[0] = 12.5;
  v3.n64_f32[0] = screenWidth * 0.0;
  v8 = (float)RsGlobal.screenHeight;
  v9 = (float)((float)((float)(screenWidth - vmax_f32(v3, v2).n64_f32[0]) * 480.0) + (float)(screenWidth * -240.0))
     / screenHeight;
  v10 = 440.5;
  if ( (float)((float)((float)((float)(v8 - (float)(v8 * 0.0)) - CFont::GetHeight(0)) * 480.0)
             / (float)RsGlobal.screenHeight) < 440.5 )
  {
    CFont::SetScale((float)((float)RsGlobal.screenHeight * 1.35) / 480.0);
    v11 = (float)RsGlobal.screenHeight + (float)((float)RsGlobal.screenHeight * -0.0);
    v10 = (float)((float)(v11 - CFont::GetHeight(0)) * 480.0) / (float)RsGlobal.screenHeight;
  }
  v12 = v9 + 320.0;
  if ( gMobileMenu.pointerMode )
  {
    x = gMobileMenu.pointerCoords[lastDevice].x;
    v14 = 0;
    if ( x >= (float)(v12 + -120.0) && x <= v12 )
    {
      y = gMobileMenu.pointerCoords[lastDevice].y;
      v14 = 0;
      if ( y >= v10 && y <= (float)(v10 + 27.0) )
        v14 = gMobileMenu.pointerState[lastDevice] == OSPS_ButtonDown;
    }
  }
  else
  {
    v14 = 0;
  }
  if ( IsDownloadBack )
  {
    if ( v14 )
      CRGBA::CRGBA(&v69, 0xF0u, 0xF0u, 0xF0u, 0xFFu);
    else
      CRGBA::CRGBA(&v69, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
    v16 = CText::Get(&TheText, "EXIT");
    v17 = *(float *)&v69;
  }
  else
  {
    if ( v14 )
      CRGBA::CRGBA(&v68, 0xF0u, 0xF0u, 0xF0u, 0xFFu);
    else
      CRGBA::CRGBA(&v68, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
    v18 = CText::Get(&TheText, "FEDS_TB");
    v17 = *(float *)&v68;
    v16 = v18;
  }
  pvecUVRightBottom.x = v17;
  v42.x = v12 + -120.0;
  v42.y = v10;
  MenuScreen::DrawTextDirect(
    &coords,
    this,
    v16,
    TA_Right,
    0,
    (CRGBA)&pvecUVRightBottom,
    1,
    v42,
    (CVector2D)0x41D8000042F00000LL,
    0,
    0);
  v19 = coords.x;
  if ( CHID::Implements(HID_MAPPING_MENU_BACK) && CHID::GetInputType() != 2 )
  {
    coords.x = 0.0;
    coords.y = 0.0;
    pvecUVRightBottom.x = 1.0;
    pvecUVRightBottom.y = 1.0;
    HelpSprite = CHID::GetHelpSprite(0, HID_MAPPING_MENU_BACK, &coords, &pvecUVRightBottom);
    if ( HelpSprite )
    {
      mpTexture = HelpSprite->mpTexture;
      CRGBA::CRGBA(&v67, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
      v71.x = v19 + -25.0;
      v71.y = v10 + 5.0;
      v38.x = v19 + -5.0;
      v38.y = v10 + 25.0;
      MenuScreen::DrawSprite(this, mpTexture, (CRGBA)&v67, v71, v38, coords, pvecUVRightBottom);
    }
  }
  else
  {
    pvecUVRightBottom = 0LL;
    v57 = 1065353216LL;
    v58 = 0x3F80000000000000LL;
    v59 = 0x3F8000003F800000LL;
    v63 = v19 + -32.0;
    v65 = v19 + -32.0;
    coords.y = v10 + 4.0;
    coords.x = v19 + -4.0;
    v61 = v19 + -4.0;
    v62 = v10 + 23.0;
    v64 = v10 + 4.0;
    v66 = v10 + 23.0;
    CRGBA::CRGBA((CRGBA *)&v53, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
    CRGBA::CRGBA((CRGBA *)&v53.y, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
    CRGBA::CRGBA(&v54, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
    CRGBA::CRGBA(&v55, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
    MenuScreen::DrawSprite(this, this->arrowTex, &coords, &pvecUVRightBottom, (CRGBA *)&v53, 0);
  }
  if ( CHID::Implements(HID_MAPPING_MENU_ACCEPT) && CHID::GetInputType() == 1 && v5 )
  {
    coords.x = 0.0;
    coords.y = 0.0;
    pvecUVRightBottom.x = 1.0;
    pvecUVRightBottom.y = 1.0;
    if ( gMobileMenu.isMapMode )
    {
      if ( !((CTheScripts::HideAllFrontEndMapBlips | CTheScripts::bPlayerIsOffTheMap) << 24) )
      {
        waypoint_blip = gMobileMenu.waypoint_blip;
        CRGBA::CRGBA(&v52, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
        v21 = "FEH_REM";
        if ( !waypoint_blip )
          v21 = "FEH_WAY";
        v22 = CText::Get(&TheText, (const unsigned __int8 *)v21);
        v23 = -25.0;
        v70[0] = (int)v52;
        v43.x = v12 + -90.0;
        v43.y = v10 + -25.0;
        MenuScreen::DrawTextDirect(
          &v53,
          this,
          v22,
          TA_Right,
          0,
          (CRGBA)v70,
          1,
          v43,
          (CVector2D)0x41D8000042B40000LL,
          0,
          0);
        v24 = v53.x;
        v25 = CHID::GetHelpSprite(0, HID_MAPPING_MENU_ACCEPT, &coords, &pvecUVRightBottom);
        if ( v25 )
        {
          v26 = v25->mpTexture;
          v27 = &v51;
          CRGBA::CRGBA(&v51, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
LABEL_35:
          v72.x = v24 + v23;
          v72.y = v10 + -20.0;
          v39.x = v24 + -5.0;
          v39.y = v10;
          MenuScreen::DrawSprite(this, v26, (CRGBA)v27, v72, v39, coords, pvecUVRightBottom);
        }
      }
    }
    else
    {
      CRGBA::CRGBA(&v50, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
      v23 = -25.0;
      v30 = CText::Get(&TheText, "FEH_SEL");
      v70[0] = (int)v50;
      v44.x = v12 + -120.0;
      v44.y = v10 + -25.0;
      MenuScreen::DrawTextDirect(
        &v53,
        this,
        v30,
        TA_Right,
        0,
        (CRGBA)v70,
        1,
        v44,
        (CVector2D)0x41D8000042F00000LL,
        0,
        0);
      v24 = v53.x;
      v31 = CHID::GetHelpSprite(0, HID_MAPPING_MENU_ACCEPT, &coords, &pvecUVRightBottom);
      if ( v31 )
      {
        v26 = v31->mpTexture;
        v27 = &v49;
        CRGBA::CRGBA(&v49, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
        goto LABEL_35;
      }
    }
  }
  if ( gMobileMenu.isMapMode
    && mapModeOpacity == 1.0
    && CHID::GetInputType() == 1
    && CHID::Implements(HID_MAPPING_MAP_ZOOM_IN)
    && CHID::Implements(HID_MAPPING_MAP_ZOOM_OUT) )
  {
    CRGBA::CRGBA(&v48, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
    v32 = CText::Get(&TheText, "FEI_ZOO");
    LODWORD(pvecUVRightBottom.x) = v48;
    v45.y = 20.0;
    v45.x = v12 + -120.0;
    MenuScreen::DrawTextDirect(
      &coords,
      this,
      v32,
      TA_Right,
      0,
      (CRGBA)&pvecUVRightBottom,
      1,
      v45,
      (CVector2D)0x41D8000042F00000LL,
      0,
      0);
    v33 = coords.x;
    coords.x = 0.0;
    coords.y = 0.0;
    pvecUVRightBottom.x = 1.0;
    pvecUVRightBottom.y = 1.0;
    v34 = CHID::GetHelpSprite(0, HID_MAPPING_MAP_ZOOM_OUT, &coords, &pvecUVRightBottom);
    if ( v34 )
    {
      v35 = v34->mpTexture;
      CRGBA::CRGBA(&v47, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
      varECb.y = 45.0;
      cvector2db.y = 25.0;
      cvector2db.x = v33 + -25.0;
      varECb.x = v33 + -5.0;
      MenuScreen::DrawSprite(this, v35, (CRGBA)&v47, cvector2db, varECb, coords, pvecUVRightBottom);
    }
    v36 = CHID::GetHelpSprite(0, HID_MAPPING_MAP_ZOOM_IN, &coords, &pvecUVRightBottom);
    if ( v36 )
    {
      v37 = v36->mpTexture;
      CRGBA::CRGBA(&v46, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
      varECc.y = 45.0;
      cvector2dc.y = 25.0;
      cvector2dc.x = v33 + -45.0;
      varECc.x = v33 + -25.0;
      MenuScreen::DrawSprite(this, v37, (CRGBA)&v46, cvector2dc, varECc, coords, pvecUVRightBottom);
    }
  }
}
// 29791C: variable 'v3' is possibly undefined
// 29791C: variable 'v2' is possibly undefined

//----- (00298074) --------------------------------------------------------
RsGlobalType_0 *__fastcall MenuScreen::DrawText(
        CVector2D *retstr,
        MenuScreen *this,
        const unsigned __int8 *tag,
        TextAlign alignment,
        int style,
        CRGBA *p_color,
        int shadow,
        CVector2D position,
        CVector2D bounds,
        int wrap)
{
  GxtChar *v13; // r0
  CRGBA v15; // [sp+24h] [bp-14h] BYREF

  v13 = CText::Get(&TheText, tag);
  v15 = *p_color;
  return MenuScreen::DrawTextDirect(retstr, this, v13, alignment, style, (CRGBA)&v15, shadow, position, bounds, wrap, 0);
}
// 298074: using guessed type CVector2D p_color;

//----- (002980D4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall MenuScreen::DrawSprite(
        MenuScreen *this,
        RwTexture_0 *texture,
        CRGBA col,
        CVector2D ul,
        CVector2D lr,
        CVector2D uv1,
        CVector2D uv2)
{
  float x; // r4
  int v8; // r5
  float screenWidth; // s16
  float screenHeight; // s18

  x = ul.x;
  *(_BYTE *)(*(_DWORD *)&col + 3) = (unsigned int)(float)(this->opacity
                                                        * (float)*(unsigned __int8 *)(*(_DWORD *)&col + 3));
  v8 = **(_DWORD **)&col;
  screenWidth = (float)RsGlobal.screenWidth;
  screenHeight = (float)RsGlobal.screenHeight;
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, texture->raster);
  maVertices[0].z = 1.0;
  maVertices[0].rhw = 1.0;
  *(CVector2D *)&maVertices[0].s = uv1;
  *(_DWORD *)&maVertices[0].r = v8;
  maVertices[1].t = uv1.y;
  maVertices[2].s = uv1.x;
  *(_DWORD *)&maVertices[1].r = v8;
  maVertices[1].s = uv2.x;
  maVertices[1].z = 1.0;
  maVertices[1].rhw = 1.0;
  maVertices[0].x = (float)(screenWidth * 0.5) + (float)((float)((float)(x + -320.0) * screenHeight) / 480.0);
  maVertices[0].y = (float)(ul.y * screenHeight) / 480.0;
  maVertices[1].x = (float)(screenWidth * 0.5) + (float)((float)((float)(lr.x + -320.0) * screenHeight) / 480.0);
  maVertices[1].y = (float)(ul.y * screenHeight) / 480.0;
  maVertices[2].z = 1.0;
  maVertices[2].rhw = 1.0;
  maVertices[2].t = uv2.y;
  *(_DWORD *)&maVertices[2].r = v8;
  maVertices[2].x = maVertices[0].x;
  maVertices[2].y = (float)(lr.y * screenHeight) / 480.0;
  maVertices[3].z = 1.0;
  maVertices[3].rhw = 1.0;
  *(CVector2D *)&maVertices[3].s = uv2;
  *(_DWORD *)&maVertices[3].r = v8;
  maVertices[3].x = maVertices[1].x;
  maVertices[3].y = (float)(lr.y * screenHeight) / 480.0;
  sub_18B9D0(rwPRIMTYPETRISTRIP, maVertices, 4);
}
// 2980D4: fragmented variable at 0:r3.4,4:^20.4 may be wrong
// 2980D4: variables would overlap: 0:r3.4,4:^20.4 and ^20.4

//----- (00298220) --------------------------------------------------------
void __fastcall MenuScreen::DrawSprite(
        MenuScreen *this,
        RwTexture_0 *texture,
        CVector2D *coords,
        CVector2D *uvs,
        CRGBA *col,
        int ignoreOpacity)
{
  unsigned int alpha; // r5
  unsigned int v7; // r6
  float v8; // s2
  float v9; // s6
  float y; // s8
  float v11; // s4
  float v12; // s4
  float x; // s8
  float v14; // s2
  float v15; // s6
  float v16; // s8
  float v17; // s4
  float v18; // s0

  if ( !ignoreOpacity )
  {
    alpha = col[2]._anon_0._anon_0.alpha;
    v7 = col[3]._anon_0._anon_0.alpha;
    v8 = (float)col[1]._anon_0._anon_0.alpha;
    col->_anon_0._anon_0.alpha = (unsigned int)(float)(this->opacity * (float)col->_anon_0._anon_0.alpha);
    col[1]._anon_0._anon_0.alpha = (unsigned int)(float)(this->opacity * v8);
    col[2]._anon_0._anon_0.alpha = (unsigned int)(float)(this->opacity * (float)alpha);
    col[3]._anon_0._anon_0.alpha = (unsigned int)(float)(this->opacity * (float)v7);
  }
  v9 = coords[1].x + -320.0;
  y = coords[1].y;
  v11 = (float)(coords->y * (float)RsGlobal.screenHeight) / 480.0;
  coords->x = (float)((float)RsGlobal.screenWidth * 0.5)
            + (float)((float)((float)(coords->x + -320.0) * (float)RsGlobal.screenHeight) / 480.0);
  coords->y = v11;
  v12 = y * (float)RsGlobal.screenHeight;
  x = coords[2].x;
  v14 = (float)RsGlobal.screenWidth * 0.5;
  coords[1].x = v14 + (float)((float)(v9 * (float)RsGlobal.screenHeight) / 480.0);
  v15 = x + -320.0;
  coords[1].y = v12 / 480.0;
  v16 = (float)(coords[2].y * (float)RsGlobal.screenHeight) / 480.0;
  v17 = (float)(coords[3].y * (float)RsGlobal.screenHeight) / 480.0;
  v18 = v14 + (float)((float)((float)(coords[3].x + -320.0) * (float)RsGlobal.screenHeight) / 480.0);
  coords[2].x = v14 + (float)((float)(v15 * (float)RsGlobal.screenHeight) / 480.0);
  coords[2].y = v16;
  coords[3].x = v18;
  coords[3].y = v17;
  MobileMenu::DrawSprite(texture, coords, uvs, col);
}

//----- (002983B4) --------------------------------------------------------
void __fastcall MenuScreen::Render(MenuScreen *this, int stackPos)
{
  if ( this->hasBack )
    (*((void (__fastcall **)(MenuScreen *, int))this->_vptr$MenuScreen + 10))(this, 1);
}

//----- (002983C4) --------------------------------------------------------
void __fastcall MenuScreen::PushScreen(MenuScreen *toPush, bool immediate)
{
  _BOOL4 v3; // r5
  unsigned int numEntries; // r5
  unsigned int v5; // r9
  MenuScreen **dataPtr; // r8
  MenuScreen **v7; // r6

  v3 = immediate;
  if ( gMobileMenu.screenStack.numEntries )
    (*((void (__fastcall **)(MenuScreen *, MenuScreen *))toPush->_vptr$MenuScreen + 5))(
      toPush,
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
  if ( gMobileMenu.pendingScreen )
    MobileMenu::ProcessPending(&gMobileMenu);
  if ( v3 )
  {
    numEntries = gMobileMenu.screenStack.numEntries;
    if ( gMobileMenu.screenStack.numAlloced >= gMobileMenu.screenStack.numEntries + 1 )
    {
      dataPtr = gMobileMenu.screenStack.dataPtr;
    }
    else
    {
      v5 = 4 * (gMobileMenu.screenStack.numEntries + 1) / 3 + 3;
      dataPtr = (MenuScreen **)malloc(4 * v5);
      v7 = gMobileMenu.screenStack.dataPtr;
      if ( gMobileMenu.screenStack.dataPtr )
      {
        qmemcpy(dataPtr, gMobileMenu.screenStack.dataPtr, 4 * numEntries);
        free(v7);
        numEntries = gMobileMenu.screenStack.numEntries;
      }
      gMobileMenu.screenStack.dataPtr = dataPtr;
      gMobileMenu.screenStack.numAlloced = v5;
    }
    dataPtr[numEntries] = toPush;
    ++gMobileMenu.screenStack.numEntries;
    (*((void (__fastcall **)(MenuScreen *))toPush->_vptr$MenuScreen + 4))(toPush);
  }
  else
  {
    gMobileMenu.pendingScreen = toPush;
  }
}

//----- (002984D0) --------------------------------------------------------
void __fastcall MobileMenu::AddScreen(MobileMenu *this, MenuScreen *toAdd, bool immediate)
{
  _BOOL4 v4; // r6
  unsigned int numEntries; // r6
  unsigned int v7; // r10
  MenuScreen **v8; // r0
  MenuScreen **v9; // r8
  MenuScreen **dataPtr; // r9

  v4 = immediate;
  if ( this->pendingScreen )
    MobileMenu::ProcessPending(this);
  if ( v4 )
  {
    numEntries = this->screenStack.numEntries;
    if ( this->screenStack.numAlloced >= numEntries + 1 )
    {
      dataPtr = this->screenStack.dataPtr;
    }
    else
    {
      v7 = 4 * (numEntries + 1) / 3 + 3;
      v8 = (MenuScreen **)malloc(4 * v7);
      v9 = this->screenStack.dataPtr;
      dataPtr = v8;
      if ( v9 )
      {
        qmemcpy(v8, this->screenStack.dataPtr, 4 * numEntries);
        free(v9);
        numEntries = this->screenStack.numEntries;
      }
      this->screenStack.dataPtr = dataPtr;
      this->screenStack.numAlloced = v7;
    }
    dataPtr[numEntries] = toAdd;
    ++this->screenStack.numEntries;
    (*((void (__fastcall **)(MenuScreen *))toAdd->_vptr$MenuScreen + 4))(toAdd);
  }
  else
  {
    this->pendingScreen = toAdd;
  }
}

//----- (00298564) --------------------------------------------------------
void __fastcall MenuScreen::PopScreen(bool immediate)
{
  if ( gMobileMenu.screenStack.numEntries >= 2 )
    (*((void (__fastcall **)(MenuScreen *, MenuScreen *))gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries
                                                                                       - 2]->_vptr$MenuScreen
     + 5))(
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 2],
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
  MobileMenu::RemoveTopScreen(&gMobileMenu, immediate, 0);
}

//----- (002985A8) --------------------------------------------------------
void __fastcall MobileMenu::RemoveTopScreen(MobileMenu *this, bool immediate, bool dontExit)
{
  _BOOL4 v4; // r5
  _BOOL4 v5; // r6
  unsigned int numEntries; // r0
  unsigned int v7; // r1
  MenuScreen *v8; // r0
  MenuScreen *v9; // r0
  unsigned int v10; // r1
  MenuScreen *v11; // r0

  v4 = dontExit;
  v5 = immediate;
  if ( this->screenStack.numEntries )
  {
    if ( this->pendingScreen )
      MobileMenu::ProcessPending(this);
    numEntries = this->screenStack.numEntries;
    if ( v5 )
    {
      v7 = numEntries - 1;
    }
    else
    {
      if ( numEntries != 1 )
      {
        this->pendingScreen = this->screenStack.dataPtr[numEntries - 2];
        return;
      }
      v7 = 0;
    }
    v8 = this->screenStack.dataPtr[v7];
    this->screenStack.numEntries = v7;
    if ( v8 )
    {
      (*((void (__fastcall **)(MenuScreen *))v8->_vptr$MenuScreen + 1))(v8);
      v7 = this->screenStack.numEntries;
    }
    if ( v7 )
    {
      v9 = this->screenStack.dataPtr[v7 - 1];
      (*((void (__fastcall **)(MenuScreen *))v9->_vptr$MenuScreen + 4))(v9);
    }
    else if ( !v4 )
    {
      MobileMenu::Unload(this);
      v10 = this->screenStack.numEntries;
      this->pendingScreen = 0;
      this->isMapMode = 0;
      while ( v10 )
      {
        v11 = this->screenStack.dataPtr[--v10];
        this->screenStack.numEntries = v10;
        if ( v11 )
        {
          (*((void (__fastcall **)(MenuScreen *))v11->_vptr$MenuScreen + 1))(v11);
          v10 = this->screenStack.numEntries;
        }
      }
      Menu_SwitchOffToGame();
      if ( Menu_IsPlayingGame(1) )
        skipFrame = 2;
    }
  }
}

//----- (00298668) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall MenuScreen::DrawQuad(MenuScreen *this, CVector2D ul, CVector2D lr, CRGBA *col)
{
  unsigned int alpha; // r5
  unsigned int v5; // r6
  float v6; // s2

  alpha = col[2]._anon_0._anon_0.alpha;
  v5 = col[3]._anon_0._anon_0.alpha;
  v6 = (float)col[1]._anon_0._anon_0.alpha;
  col->_anon_0._anon_0.alpha = (unsigned int)(float)(this->opacity * (float)col->_anon_0._anon_0.alpha);
  col[1]._anon_0._anon_0.alpha = (unsigned int)(float)(this->opacity * v6);
  col[2]._anon_0._anon_0.alpha = (unsigned int)(float)(this->opacity * (float)alpha);
  col[3]._anon_0._anon_0.alpha = (unsigned int)(float)(this->opacity * (float)v5);
  MobileMenu::DrawQuad(
    (float)((float)RsGlobal.screenWidth * 0.5)
  + (float)((float)((float)(ul.x + -320.0) * (float)RsGlobal.screenHeight) / 480.0),
    (float)(ul.y * (float)RsGlobal.screenHeight) / 480.0,
    (float)((float)RsGlobal.screenWidth * 0.5)
  + (float)((float)((float)(lr.x + -320.0) * (float)RsGlobal.screenHeight) / 480.0),
    (float)(lr.y * (float)RsGlobal.screenHeight) / 480.0,
    col);
}
// 298668: fragmented variable at 0:r3.4,4:^20.4 may be wrong
// 298668: variables would overlap: 0:r3.4,4:^20.4 and ^20.4

//----- (00298788) --------------------------------------------------------
void __fastcall MobileMenu::DrawQuad(float a1, float a2, float a3, float a4, CRGBA *col)
{
  unsigned __int8 alpha; // r3
  unsigned __int8 v10; // r3
  unsigned __int8 v11; // r3

  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  maVertices[0].x = a1;
  maVertices[0].y = a2;
  maVertices[0].z = 1.0;
  maVertices[0].rhw = 1.0;
  maVertices[0].s = 0.0;
  maVertices[0].t = 0.0;
  maVertices[0].r = col->_anon_0._anon_0.red;
  maVertices[0].g = col->_anon_0._anon_0.green;
  maVertices[0].b = col->_anon_0._anon_0.blue;
  alpha = col->_anon_0._anon_0.alpha;
  maVertices[1].z = 1.0;
  maVertices[1].rhw = 1.0;
  maVertices[1].s = 1.0;
  maVertices[1].t = 0.0;
  maVertices[1].x = a3;
  maVertices[1].y = a2;
  maVertices[0].a = alpha;
  maVertices[1].r = col[1]._anon_0._anon_0.red;
  maVertices[1].g = col[1]._anon_0._anon_0.green;
  maVertices[1].b = col[1]._anon_0._anon_0.blue;
  v10 = col[1]._anon_0._anon_0.alpha;
  maVertices[2].y = a4;
  maVertices[2].z = 1.0;
  maVertices[2].rhw = 1.0;
  maVertices[2].s = 0.0;
  maVertices[2].t = 1.0;
  maVertices[1].a = v10;
  maVertices[2].x = a1;
  maVertices[2].r = col[2]._anon_0._anon_0.red;
  maVertices[2].g = col[2]._anon_0._anon_0.green;
  maVertices[2].b = col[2]._anon_0._anon_0.blue;
  v11 = col[2]._anon_0._anon_0.alpha;
  maVertices[3].y = a4;
  maVertices[3].z = 1.0;
  maVertices[3].rhw = 1.0;
  maVertices[3].s = 1.0;
  maVertices[3].t = 1.0;
  maVertices[2].a = v11;
  maVertices[3].x = a3;
  *(CRGBA *)&maVertices[3].r = col[3];
  sub_18B9D0(rwPRIMTYPETRISTRIP, maVertices, 4);
}

//----- (0029884C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall MenuScreen::DrawQuad(MenuScreen *this, CVector2D ul, CVector2D lr, CRGBA col)
{
  float x; // r6
  float y; // r8
  float v6; // r5
  int v7; // r4
  int32x4_t v8; // q8
  float screenWidth; // s16
  float screenHeight; // s18

  x = ul.x;
  y = ul.y;
  v6 = lr.x;
  *(_BYTE *)(*(_DWORD *)&col + 3) = (unsigned int)(float)(this->opacity
                                                        * (float)*(unsigned __int8 *)(*(_DWORD *)&col + 3));
  v7 = **(_DWORD **)&col;
  v8 = vdupq_n_s32(**(_DWORD **)&col);
  screenWidth = (float)RsGlobal.screenWidth;
  screenHeight = (float)RsGlobal.screenHeight;
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  maVertices[0].z = 1.0;
  maVertices[0].rhw = 1.0;
  maVertices[0].s = 0.0;
  maVertices[0].t = 0.0;
  *(_DWORD *)&maVertices[0].r = v7;
  *(_DWORD *)&maVertices[1].r = v7;
  maVertices[1].s = 1.0;
  maVertices[1].t = 0.0;
  maVertices[1].z = 1.0;
  maVertices[1].rhw = 1.0;
  maVertices[0].x = (float)(screenWidth * 0.5) + (float)((float)((float)(x + -320.0) * screenHeight) / 480.0);
  maVertices[0].y = (float)(y * screenHeight) / 480.0;
  maVertices[1].x = (float)(screenWidth * 0.5) + (float)((float)((float)(v6 + -320.0) * screenHeight) / 480.0);
  maVertices[1].y = (float)(y * screenHeight) / 480.0;
  maVertices[2].x = maVertices[0].x;
  maVertices[2].z = 1.0;
  maVertices[2].rhw = 1.0;
  maVertices[2].s = 0.0;
  maVertices[2].t = 1.0;
  *(_DWORD *)&maVertices[2].r = v7;
  maVertices[2].y = (float)(lr.y * screenHeight) / 480.0;
  maVertices[3].z = 1.0;
  maVertices[3].rhw = 1.0;
  maVertices[3].s = 1.0;
  maVertices[3].t = 1.0;
  *(_WORD *)&maVertices[3].r = v7;
  maVertices[3].b = BYTE2(v7);
  maVertices[3].x = maVertices[1].x;
  maVertices[3].y = (float)(lr.y * screenHeight) / 480.0;
  maVertices[3].a = v8.n128_u8[15];
  RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, maVertices, 4);
}
// 29884C: fragmented variable at 0:r3.4,4:^40.4 may be wrong
// 29884C: variables would overlap: 0:r3.4,4:^40.4 and ^40.4

//----- (002989B8) --------------------------------------------------------
void __fastcall MenuScreen::DrawQuad(MenuScreen *this, CVector2D *coords, CRGBA *col)
{
  unsigned int alpha; // lr
  unsigned int v4; // r4
  float v5; // s2
  float y; // s8
  float v7; // s6
  float v8; // s4
  float v9; // s4
  float x; // s8
  float v11; // s0
  float v12; // s6
  float v13; // s8
  float v14; // s4
  float v15; // s6
  float v16; // s0

  alpha = col[2]._anon_0._anon_0.alpha;
  v4 = col[3]._anon_0._anon_0.alpha;
  v5 = (float)col[1]._anon_0._anon_0.alpha;
  col->_anon_0._anon_0.alpha = (unsigned int)(float)(this->opacity * (float)col->_anon_0._anon_0.alpha);
  col[1]._anon_0._anon_0.alpha = (unsigned int)(float)(this->opacity * v5);
  col[2]._anon_0._anon_0.alpha = (unsigned int)(float)(this->opacity * (float)alpha);
  col[3]._anon_0._anon_0.alpha = (unsigned int)(float)(this->opacity * (float)v4);
  y = coords[1].y;
  v7 = coords[1].x + -320.0;
  v8 = (float)(coords->y * (float)RsGlobal.screenHeight) / 480.0;
  coords->x = (float)((float)RsGlobal.screenWidth * 0.5)
            + (float)((float)((float)(coords->x + -320.0) * (float)RsGlobal.screenHeight) / 480.0);
  coords->y = v8;
  v9 = y * (float)RsGlobal.screenHeight;
  x = coords[2].x;
  v11 = (float)RsGlobal.screenWidth * 0.5;
  coords[1].x = v11 + (float)((float)(v7 * (float)RsGlobal.screenHeight) / 480.0);
  v12 = x + -320.0;
  coords[1].y = v9 / 480.0;
  v13 = (float)(coords[2].y * (float)RsGlobal.screenHeight) / 480.0;
  v14 = (float)(coords[3].y * (float)RsGlobal.screenHeight) / 480.0;
  v15 = v11 + (float)((float)(v12 * (float)RsGlobal.screenHeight) / 480.0);
  v16 = v11 + (float)((float)((float)(coords[3].x + -320.0) * (float)RsGlobal.screenHeight) / 480.0);
  coords[2].x = v15;
  coords[2].y = v13;
  coords[3].x = v16;
  coords[3].y = v14;
  MobileMenu::DrawQuad(coords, col);
}

//----- (00298B28) --------------------------------------------------------
void __fastcall MobileMenu::DrawQuad(CVector2D *coords, CRGBA *col)
{
  CVector2D v4; // r2
  CVector2D v5; // r2
  CVector2D v6; // r2
  CVector2D v7; // r2

  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
  v4 = *coords;
  maVertices[0].t = 0.0;
  *(CVector2D *)&maVertices[0].x = v4;
  maVertices[0].z = 1.0;
  maVertices[0].rhw = 1.0;
  maVertices[0].s = 0.0;
  *(CRGBA *)&maVertices[0].r = *col;
  v5 = coords[1];
  maVertices[1].z = 1.0;
  maVertices[1].rhw = 1.0;
  maVertices[1].s = 0.0;
  maVertices[1].t = 0.0;
  *(CVector2D *)&maVertices[1].x = v5;
  *(CRGBA *)&maVertices[1].r = col[1];
  v6 = coords[2];
  maVertices[2].z = 1.0;
  maVertices[2].rhw = 1.0;
  maVertices[2].s = 0.0;
  maVertices[2].t = 0.0;
  *(CVector2D *)&maVertices[2].x = v6;
  *(CRGBA *)&maVertices[2].r = col[2];
  v7 = coords[3];
  maVertices[3].z = 1.0;
  maVertices[3].rhw = 1.0;
  maVertices[3].s = 0.0;
  maVertices[3].t = 0.0;
  *(CVector2D *)&maVertices[3].x = v7;
  *(CRGBA *)&maVertices[3].r = col[3];
  sub_18B9D0(rwPRIMTYPETRISTRIP, maVertices, 4);
}

//----- (00298BF4) --------------------------------------------------------
void __fastcall MobileMenu::DrawSprite(RwTexture_0 *texture, CVector2D *coords, CVector2D *uvs, CRGBA *col)
{
  CVector2D v7; // kr00_8
  CVector2D v8; // kr08_8
  CVector2D v9; // kr10_8
  CVector2D v10; // kr18_8
  CVector2D v11; // kr20_8
  CVector2D v12; // kr28_8
  CVector2D v13; // kr30_8

  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, texture->raster);
  v7 = *uvs;
  *(CVector2D *)&maVertices[0].x = *coords;
  maVertices[0].z = 1.0;
  maVertices[0].rhw = 1.0;
  *(CVector2D *)&maVertices[0].s = v7;
  *(CRGBA *)&maVertices[0].r = *col;
  v8 = uvs[1];
  v9 = coords[1];
  maVertices[1].z = 1.0;
  maVertices[1].rhw = 1.0;
  *(CVector2D *)&maVertices[1].s = v8;
  *(CVector2D *)&maVertices[1].x = v9;
  *(CRGBA *)&maVertices[1].r = col[1];
  v10 = uvs[2];
  v11 = coords[2];
  maVertices[2].z = 1.0;
  maVertices[2].rhw = 1.0;
  *(CVector2D *)&maVertices[2].s = v10;
  *(CVector2D *)&maVertices[2].x = v11;
  *(CRGBA *)&maVertices[2].r = col[2];
  v12 = uvs[3];
  v13 = coords[3];
  maVertices[3].rhw = 1.0;
  *(CVector2D *)&maVertices[3].s = v12;
  *(CVector2D *)&maVertices[3].x = v13;
  maVertices[3].z = 1.0;
  *(CRGBA *)&maVertices[3].r = col[3];
  sub_18B9D0(rwPRIMTYPETRISTRIP, maVertices, 4);
}

//----- (00298CD4) --------------------------------------------------------
void __fastcall MobileMenu::DrawSprite(
        RwTexture_0 *texture,
        CRGBA col,
        CVector2D ul,
        CVector2D lr,
        CVector2D uv1,
        CVector2D uv2)
{
  float y; // r6
  float x; // r8
  unsigned __int8 v9; // r2
  unsigned __int8 v10; // r3

  y = ul.y;
  x = ul.x;
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, texture->raster);
  maVertices[0].x = x;
  maVertices[0].y = y;
  maVertices[0].z = 1.0;
  maVertices[0].rhw = 1.0;
  *(CVector2D *)&maVertices[0].s = uv1;
  maVertices[0].r = *(_BYTE *)col._anon_0._anon_0.red;
  maVertices[0].g = *(_BYTE *)(*(_DWORD *)&col + 1);
  maVertices[0].b = *(_BYTE *)(*(_DWORD *)&col + 2);
  v9 = *(_BYTE *)(*(_DWORD *)&col + 3);
  maVertices[1].y = y;
  maVertices[1].t = uv1.y;
  maVertices[1].z = 1.0;
  maVertices[1].rhw = 1.0;
  maVertices[1].s = uv2.x;
  maVertices[1].x = lr.x;
  maVertices[0].a = v9;
  maVertices[1].r = *(_BYTE *)col._anon_0._anon_0.red;
  maVertices[1].g = *(_BYTE *)(*(_DWORD *)&col + 1);
  maVertices[1].b = *(_BYTE *)(*(_DWORD *)&col + 2);
  maVertices[1].a = *(_BYTE *)(*(_DWORD *)&col + 3);
  maVertices[2].s = uv1.x;
  maVertices[2].z = 1.0;
  maVertices[2].rhw = 1.0;
  maVertices[2].t = uv2.y;
  maVertices[2].x = x;
  maVertices[2].y = lr.y;
  maVertices[2].r = *(_BYTE *)col._anon_0._anon_0.red;
  maVertices[2].g = *(_BYTE *)(*(_DWORD *)&col + 1);
  maVertices[2].b = *(_BYTE *)(*(_DWORD *)&col + 2);
  v10 = *(_BYTE *)(*(_DWORD *)&col + 3);
  maVertices[3].y = lr.y;
  maVertices[3].z = 1.0;
  maVertices[3].rhw = 1.0;
  maVertices[2].a = v10;
  *(CVector2D *)&maVertices[3].s = uv2;
  maVertices[3].x = lr.x;
  maVertices[3].r = *(_BYTE *)col._anon_0._anon_0.red;
  maVertices[3].g = *(_BYTE *)(*(_DWORD *)&col + 1);
  maVertices[3].b = *(_BYTE *)(*(_DWORD *)&col + 2);
  maVertices[3].a = *(_BYTE *)(*(_DWORD *)&col + 3);
  sub_18B9D0(rwPRIMTYPETRISTRIP, maVertices, 4);
}

//----- (00298DA4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall MenuScreen::DrawSprite(
        MenuScreen *this,
        RwTexture_0 *texture,
        CRGBA col,
        CVector2D ul,
        CVector2D lr,
        int ignoreOpacity)
{
  float x; // r9
  int v7; // r5
  float screenWidth; // s16
  float screenHeight; // s18

  x = ul.x;
  if ( !ignoreOpacity )
    *(_BYTE *)(*(_DWORD *)&col + 3) = (unsigned int)(float)(this->opacity
                                                          * (float)*(unsigned __int8 *)(*(_DWORD *)&col + 3));
  v7 = **(_DWORD **)&col;
  screenWidth = (float)RsGlobal.screenWidth;
  screenHeight = (float)RsGlobal.screenHeight;
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, texture->raster);
  maVertices[0].z = 1.0;
  maVertices[0].rhw = 1.0;
  maVertices[0].s = 0.0;
  maVertices[0].t = 0.0;
  *(_DWORD *)&maVertices[0].r = v7;
  *(_DWORD *)&maVertices[1].r = v7;
  maVertices[1].s = 1.0;
  maVertices[1].t = 0.0;
  maVertices[1].z = 1.0;
  maVertices[1].rhw = 1.0;
  maVertices[0].x = (float)(screenWidth * 0.5) + (float)((float)((float)(x + -320.0) * screenHeight) / 480.0);
  maVertices[0].y = (float)(ul.y * screenHeight) / 480.0;
  maVertices[1].x = (float)(screenWidth * 0.5) + (float)((float)((float)(lr.x + -320.0) * screenHeight) / 480.0);
  maVertices[1].y = (float)(ul.y * screenHeight) / 480.0;
  maVertices[2].x = maVertices[0].x;
  maVertices[2].z = 1.0;
  maVertices[2].rhw = 1.0;
  maVertices[2].s = 0.0;
  maVertices[2].t = 1.0;
  *(_DWORD *)&maVertices[2].r = v7;
  maVertices[2].y = (float)(lr.y * screenHeight) / 480.0;
  maVertices[3].z = 1.0;
  maVertices[3].rhw = 1.0;
  maVertices[3].s = 1.0;
  maVertices[3].t = 1.0;
  *(_DWORD *)&maVertices[3].r = v7;
  maVertices[3].x = maVertices[1].x;
  maVertices[3].y = (float)(lr.y * screenHeight) / 480.0;
  sub_18B9D0(rwPRIMTYPETRISTRIP, maVertices, 4);
}
// 298DA4: fragmented variable at 0:r3.4,4:^30.4 may be wrong
// 298DA4: variables would overlap: 0:r3.4,4:^30.4 and ^30.4

//----- (00298EF8) --------------------------------------------------------
void __fastcall MobileMenu::DrawSprite(RwTexture_0 *texture, CRGBA col, CVector2D ul, CVector2D lr)
{
  float y; // r6
  float x; // r8
  unsigned __int8 v7; // r5
  unsigned __int8 v8; // r3

  y = ul.y;
  x = ul.x;
  RwRenderStateSet(rwRENDERSTATETEXTURERASTER, texture->raster);
  maVertices[0].x = x;
  maVertices[0].y = y;
  maVertices[0].z = 1.0;
  maVertices[0].rhw = 1.0;
  maVertices[0].s = 0.0;
  maVertices[0].t = 0.0;
  maVertices[0].r = *(_BYTE *)col._anon_0._anon_0.red;
  maVertices[0].g = *(_BYTE *)(*(_DWORD *)&col + 1);
  maVertices[0].b = *(_BYTE *)(*(_DWORD *)&col + 2);
  v7 = *(_BYTE *)(*(_DWORD *)&col + 3);
  maVertices[1].z = 1.0;
  maVertices[1].rhw = 1.0;
  maVertices[1].s = 1.0;
  maVertices[1].t = 0.0;
  maVertices[1].x = lr.x;
  maVertices[1].y = y;
  maVertices[0].a = v7;
  maVertices[1].r = *(_BYTE *)col._anon_0._anon_0.red;
  maVertices[1].g = *(_BYTE *)(*(_DWORD *)&col + 1);
  maVertices[1].b = *(_BYTE *)(*(_DWORD *)&col + 2);
  LOBYTE(y) = *(_BYTE *)(*(_DWORD *)&col + 3);
  maVertices[2].y = lr.y;
  maVertices[2].z = 1.0;
  maVertices[2].rhw = 1.0;
  maVertices[2].s = 0.0;
  maVertices[2].t = 1.0;
  maVertices[1].a = LOBYTE(y);
  maVertices[2].x = x;
  maVertices[2].r = *(_BYTE *)col._anon_0._anon_0.red;
  maVertices[2].g = *(_BYTE *)(*(_DWORD *)&col + 1);
  maVertices[2].b = *(_BYTE *)(*(_DWORD *)&col + 2);
  v8 = *(_BYTE *)(*(_DWORD *)&col + 3);
  maVertices[3].y = lr.y;
  maVertices[3].z = 1.0;
  maVertices[3].rhw = 1.0;
  maVertices[3].s = 1.0;
  maVertices[3].t = 1.0;
  maVertices[2].a = v8;
  maVertices[3].x = lr.x;
  maVertices[3].r = *(_BYTE *)col._anon_0._anon_0.red;
  maVertices[3].g = *(_BYTE *)(*(_DWORD *)&col + 1);
  maVertices[3].b = *(_BYTE *)(*(_DWORD *)&col + 2);
  maVertices[3].a = *(_BYTE *)(*(_DWORD *)&col + 3);
  sub_18B9D0(rwPRIMTYPETRISTRIP, maVertices, 4);
}

//----- (00298FBC) --------------------------------------------------------
bool __fastcall MenuScreen::DoesTextWrap(int a1, GxtChar *a2, uint8 a3, float a4, float a5)
{
  float screenWidth; // s16

  CFont::SetFontStyle(a3);
  screenWidth = (float)RsGlobal.screenWidth;
  CFont::SetScale((float)((float)(a5 * 0.05) * (float)RsGlobal.screenHeight) / 480.0);
  CFont::SetWrapx((float)RsGlobal.screenWidth);
  return CFont::GetStringWidth(a2, 1u, 0) > (float)((float)(a4 * screenWidth) / 640.0);
}

//----- (00299064) --------------------------------------------------------
RsGlobalType_0 *__fastcall MenuScreen::DrawTextDirect(
        CVector2D *retstr,
        MenuScreen *this,
        GxtChar *text,
        TextAlign alignment,
        int style,
        CRGBA color,
        int shadow,
        CVector2D position,
        CVector2D bounds,
        int wrap,
        int *pnLines)
{
  CRGBA v13; // r0
  float *p_opacity; // r0
  CRGBA v15; // r0
  float y; // r4
  CRGBA v17; // r0
  float screenHeight; // s18
  float v19; // s22
  int v20; // r6
  float v21; // s0
  float StringWidth; // s18
  float v23; // s20
  float Height; // r0
  int v25; // r6
  float v26; // s24
  float v27; // s26
  float screenWidth; // s0
  float v29; // s22
  float v30; // s26
  int Width; // r0
  RsGlobalType_0 *result; // r0
  float v33; // s0
  float v34; // s4
  _BYTE *v35; // [sp+8h] [bp-70h]
  CRGBA v38; // [sp+14h] [bp-64h] BYREF
  CRGBA v39; // [sp+18h] [bp-60h] BYREF
  CRGBA v40; // [sp+1Ch] [bp-5Ch] BYREF

  if ( shadow == 1 )
  {
    v35 = (_BYTE *)(*(_DWORD *)&color + 3);
    CRGBA::CRGBA(
      &v40,
      0,
      0,
      0,
      (unsigned int)(float)(this->opacity * (float)*(unsigned __int8 *)(*(_DWORD *)&color + 3)));
    CFont::SetDropColor(v13);
    CFont::SetEdge(1);
    p_opacity = &this->opacity;
  }
  else
  {
    CRGBA::CRGBA(&v39, 0, 0, 0, 0);
    CFont::SetDropColor(v15);
    CFont::SetEdge(0);
    p_opacity = &this->opacity;
    v35 = (_BYTE *)(*(_DWORD *)&color + 3);
  }
  y = position.y;
  CRGBA::CRGBA(
    &v38,
    *(_BYTE *)color._anon_0._anon_0.red,
    *(_BYTE *)(*(_DWORD *)&color + 1),
    *(_BYTE *)(*(_DWORD *)&color + 2),
    (unsigned int)(float)(*p_opacity * (float)*(unsigned __int8 *)(*(_DWORD *)&color + 3)));
  CFont::SetColor(v17);
  CFont::SetFontStyle(style);
  screenHeight = (float)RsGlobal.screenHeight;
  v19 = (float)((float)(bounds.y * 0.05) * (float)RsGlobal.screenHeight) / 480.0;
  CFont::SetScale(v19);
  v20 = 0;
  v21 = bounds.x * screenHeight;
  StringWidth = CFont::GetStringWidth(text, 1u, 0);
  v23 = v21 / 480.0;
  if ( StringWidth > (float)(v21 / 480.0) )
    v20 = 1;
  Height = CFont::GetHeight(0);
  v25 = v20 & wrap;
  if ( StringWidth > v23 && !wrap )
  {
    v26 = Height;
    CFont::SetScale(v19 * (float)(v23 / StringWidth));
    v25 = 0;
    StringWidth = v21 / 480.0;
    y = (float)((float)(v26 - CFont::GetHeight(0)) * 0.5) + position.y;
  }
  v27 = (float)RsGlobal.screenHeight;
  screenWidth = (float)RsGlobal.screenWidth;
  v29 = (float)((float)RsGlobal.screenWidth * 0.5)
      + (float)((float)((float)(position.x + -320.0) * (float)RsGlobal.screenHeight) / 480.0);
  if ( v25 == 1 )
    screenWidth = v23 + v29;
  CFont::SetWrapx(screenWidth);
  v30 = y * v27;
  Width = OS_ScreenGetWidth();
  if ( alignment == TA_Right )
  {
    v29 = (float)((float)(v23 - StringWidth) + -0.5) + v29;
  }
  else if ( alignment == TA_Center )
  {
    v29 = (float)((float)(unsigned int)Width - StringWidth) * 0.5;
  }
  if ( pnLines )
    *pnLines = CFont::GetNumberLines(v29, v30 / 480.0, text);
  if ( *v35 )
    CFont::PrintString(v29, v30 / 480.0, text);
  result = &RsGlobal;
  v33 = (float)RsGlobal.screenWidth * 240.0;
  v34 = (float)((float)((float)((float)(StringWidth + v29) * 480.0) - v33) / (float)RsGlobal.screenHeight) + 320.0;
  retstr->x = (float)((float)((float)(v29 * 480.0) - v33) / (float)RsGlobal.screenHeight) + 320.0;
  retstr->y = v34;
  return result;
}
// 2990BC: variable 'v13' is possibly undefined
// 2990DC: variable 'v15' is possibly undefined
// 299118: variable 'v17' is possibly undefined
// 299064: using guessed type _DWORD wrap_0;

//----- (002992FC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
RsGlobalType_0 *__fastcall MenuScreen::DrawText(
        CVector2D *retstr,
        MenuScreen *this,
        GxtChar *pString,
        TextAlign alignment,
        int style,
        CRGBA *p_color,
        int shadow,
        CVector2D position,
        CVector2D bounds,
        int wrap)
{
  float shadow_4; // [sp+Ch] [bp-3Ch] OVERLAPPED
  __int64 v12; // [sp+10h] [bp-38h] OVERLAPPED
  float y; // [sp+18h] [bp-30h]
  CRGBA v14; // [sp+28h] [bp-20h] BYREF

  v14 = *p_color;
  shadow_4 = position.x;
  v12 = *(__int64 *)&position.y;
  y = bounds.y;
  return MenuScreen::DrawTextDirect(
           retstr,
           this,
           pString,
           alignment,
           style,
           (CRGBA)&v14,
           shadow,
           *(CVector2D *)&shadow_4,
           *(CVector2D *)((char *)&v12 + 4),
           wrap,
           0);
}
// 2992FC: variables would overlap: ^5C.8 and ^5C.12
// 2992FC: variables would overlap: ^68.4 and ^64.8
// 2992FC: variables would overlap: ^68.4 and ^60.8
// 29932B: failed to expand linear variable ^C.4
// 29932F: failed to expand linear variable ^10.8

//----- (00299348) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall MenuScreen::DrawSlider(
        MenuScreen *this,
        CVector2D ul,
        CVector2D lr,
        float percent,
        int nub,
        unsigned int alpha,
        bool isStat)
{
  float32x2_t v7; // d0
  float32x2_t v8; // d1
  float32x2_t v9; // d4
  float32x2_t v10; // d13
  float y; // r8
  float x; // r6
  float v13; // s18
  float v14; // s16
  float v15; // s20
  float v17; // s22
  float v18; // s0
  float v19; // s6
  bool v20; // nf
  float v21; // s28
  float v22; // s24
  float v23; // s30
  RwTexture_0 *sliderFull; // r5
  unsigned int v25; // s4
  float v26; // s19
  RwTexture_0 *v27; // r6
  RwTexture_0 *v28; // r6
  RwTexture_0 *sliderEmpty; // r4
  RwTexture_0 *v30; // r6
  unsigned int v31; // s0
  RwTexture_0 *v32; // r5
  float v33; // s24
  CRGBA v34; // r0
  CRGBA v35; // r0
  RwTexture_0 *sliderNub; // r4
  CVector2D var10C; // [sp+4h] [bp-10Ch]
  CVector2D var10Ca; // [sp+4h] [bp-10Ch]
  CVector2D var10Cb; // [sp+4h] [bp-10Ch]
  CVector2D v40; // [sp+4h] [bp-10Ch]
  CVector2D var10Cd; // [sp+4h] [bp-10Ch]
  CVector2D var10Ce; // [sp+4h] [bp-10Ch]
  CVector2D var10Cf; // [sp+4h] [bp-10Ch]
  CVector2D uv1; // [sp+Ch] [bp-104h]
  CVector2D uv1a; // [sp+Ch] [bp-104h]
  CVector2D v46; // [sp+14h] [bp-FCh]
  CVector2D v47; // [sp+14h] [bp-FCh]
  CVector2D v48; // [sp+14h] [bp-FCh]
  CVector2D v49; // [sp+14h] [bp-FCh]
  CRGBA v50; // [sp+28h] [bp-E8h] BYREF
  CRGBA v51; // [sp+2Ch] [bp-E4h] BYREF
  CVector2D v52; // [sp+30h] [bp-E0h] BYREF
  CRGBA v53; // [sp+38h] [bp-D8h] BYREF
  GxtChar pOutput[32]; // [sp+3Ch] [bp-D4h] BYREF
  CRGBA v55; // [sp+7Ch] [bp-94h] BYREF
  CRGBA v56; // [sp+80h] [bp-90h] BYREF
  CRGBA v57; // [sp+84h] [bp-8Ch] BYREF
  CRGBA v58; // [sp+88h] [bp-88h] BYREF
  CRGBA v59; // [sp+8Ch] [bp-84h] BYREF
  CRGBA v60; // [sp+90h] [bp-80h] BYREF
  unsigned __int8 s[32]; // [sp+94h] [bp-7Ch] BYREF
  CVector2D v62; // 0:r3.4,4:^0.4
  CVector2D v63; // 0:r3.4,4:^0.4
  CVector2D v64; // 0:r3.4,4:^0.4
  CVector2D v65; // 0:r3.4,4:^0.4
  CVector2D v66; // 0:r3.4,4:^0.4
  CVector2D v67; // 0:r3.4,4:^0.4
  CVector2D v68; // 0:r3.4,4:^0.4

  y = ul.y;
  x = ul.x;
  v13 = ul.y;
  v14 = ul.x;
  v15 = lr.y - ul.y;
  v17 = lr.x - ul.x;
  v10.n64_u32[0] = 1.0;
  v18 = (float)(lr.y - ul.y) / (float)(lr.x - ul.x);
  v9.n64_f32[0] = percent / v18;
  v19 = percent - v18;
  v20 = (float)(percent / v18) < 0.0;
  LODWORD(v21) = vmin_f32(v9, v10).n64_u32[0];
  v8.n64_f32[0] = (float)(v18 * -2.0) + 1.0;
  v7.n64_f32[0] = (float)(percent - (float)(1.0 - v18)) / v18;
  if ( v20 )
    v21 = 0.0;
  v8.n64_f32[0] = v19 / v8.n64_f32[0];
  LODWORD(v22) = vmin_f32(v7, v10).n64_u32[0];
  LODWORD(v23) = vmin_f32(v8, v10).n64_u32[0];
  if ( v7.n64_f32[0] < 0.0 )
    v22 = 0.0;
  if ( v8.n64_f32[0] < 0.0 )
    v23 = 0.0;
  if ( v21 != 0.0 )
  {
    sliderFull = gMobileMenu.sliderFull;
    CRGBA::CRGBA(&v60, 0xFFu, 0xFFu, 0xFFu, alpha);
    v62.x = x;
    *(float *)&v25 = v21 * 0.2;
    var10C.y = v15 + v13;
    v62.y = y;
    var10C.x = (float)(v15 * v21) + v14;
    MenuScreen::DrawSprite(this, sliderFull, (CRGBA)&v60, v62, var10C, 0LL, (CVector2D)(v25 | 0x3F80000000000000LL));
  }
  v26 = v17 - v15;
  if ( v23 != 0.0 )
  {
    v27 = gMobileMenu.sliderFull;
    CRGBA::CRGBA(&v59, 0xFFu, 0xFFu, 0xFFu, alpha);
    v46.y = 1.0;
    v63.x = v15 + v14;
    var10Ca.y = v15 + v13;
    v63.y = y;
    v46.x = (float)(v23 * 0.6) + 0.2;
    var10Ca.x = (float)(v15 + v14) + (float)((float)(v26 - v15) * v23);
    MenuScreen::DrawSprite(this, v27, (CRGBA)&v59, v63, var10Ca, (CVector2D)1045220557LL, v46);
  }
  if ( v22 != 0.0 )
  {
    v28 = gMobileMenu.sliderFull;
    CRGBA::CRGBA(&v58, 0xFFu, 0xFFu, 0xFFu, alpha);
    v47.y = 1.0;
    v64.x = v26 + v14;
    var10Cb.y = v15 + v13;
    v64.y = y;
    v47.x = (float)(v22 * 0.2) + 0.8;
    var10Cb.x = (float)(v26 + v14) + (float)((float)(v17 - v26) * v22);
    MenuScreen::DrawSprite(this, v28, (CRGBA)&v58, v64, var10Cb, (CVector2D)1061997773LL, v47);
  }
  if ( v21 != 1.0 )
  {
    sliderEmpty = gMobileMenu.sliderEmpty;
    CRGBA::CRGBA(&v57, 0xFFu, 0xFFu, 0xFFu, alpha);
    v40.x = v15 + v14;
    v40.y = v15 + v13;
    v65.x = (float)(v15 * v21) + v14;
    v65.y = y;
    MenuScreen::DrawSprite(
      this,
      sliderEmpty,
      (CRGBA)&v57,
      v65,
      v40,
      (CVector2D)COERCE_UNSIGNED_INT(v21 * 0.2),
      (CVector2D)0x3F8000003E4CCCCDLL);
  }
  if ( v23 != 1.0 )
  {
    v30 = gMobileMenu.sliderEmpty;
    CRGBA::CRGBA(&v56, 0xFFu, 0xFFu, 0xFFu, alpha);
    v66.x = (float)(v15 + v14) + (float)((float)(v26 - v15) * v23);
    *(float *)&v31 = (float)(v23 * 0.6) + 0.2;
    var10Cd.y = v15 + v13;
    var10Cd.x = v26 + v14;
    v66.y = y;
    MenuScreen::DrawSprite(this, v30, (CRGBA)&v56, v66, var10Cd, (CVector2D)v31, (CVector2D)0x3F8000003F4CCCCDLL);
  }
  if ( v22 != 1.0 )
  {
    v32 = gMobileMenu.sliderEmpty;
    CRGBA::CRGBA(&v55, 0xFFu, 0xFFu, 0xFFu, alpha);
    var10Ce.y = v15 + v13;
    var10Ce.x = v17 + v14;
    v67.y = y;
    v67.x = (float)(v26 + v14) + (float)((float)(v17 - v26) * v22);
    MenuScreen::DrawSprite(
      this,
      v32,
      (CRGBA)&v55,
      v67,
      var10Ce,
      (CVector2D)COERCE_UNSIGNED_INT((float)(v22 * 0.2) + 0.8),
      (CVector2D)0x3F8000003F800000LL);
  }
  sprintf(s, "%d%%", (int)(float)(percent * 100.0));
  AsciiToGxtChar(s, pOutput);
  v7.n64_f32[0] = (float)(1.0 - v23) * 5.0;
  LODWORD(v33) = vmin_f32(v7, v10).n64_u32[0];
  if ( v7.n64_f32[0] < 0.0 )
    v33 = 0.0;
  if ( v33 != 0.0 )
  {
    CRGBA::CRGBA(&v53, 0xF0u, 0xF0u, 0xF0u, (unsigned int)(float)(v33 * (float)alpha));
    uv1.x = v14 + 4.0;
    uv1.y = v13 + 3.0;
    v48.x = v17 + -8.0;
    v48.y = v15 + -5.0;
    MenuScreen::DrawTextDirect(&v52, this, pOutput, TA_Right, 1, v34, 0, uv1, v48, 0, 0);
  }
  if ( (float)(1.0 - v33) != 0.0 )
  {
    CRGBA::CRGBA(&v51, 0, 0, 0, (unsigned int)(float)((float)(1.0 - v33) * (float)alpha));
    uv1a.x = v14 + 4.0;
    uv1a.y = v13 + 3.0;
    v49.x = v17 + -8.0;
    v49.y = v15 + -5.0;
    MenuScreen::DrawTextDirect(&v52, this, pOutput, TA_Left, 1, v35, 0, uv1a, v49, 0, 0);
  }
  CFont::RenderFontBuffer();
  if ( nub == 1 )
  {
    sliderNub = gMobileMenu.sliderNub;
    CRGBA::CRGBA(&v50, 0xFFu, 0xFFu, 0xFFu, alpha);
    var10Cf.y = v15 + v13;
    v68.y = y;
    v68.x = (float)((float)((float)((float)(v17 + v14) - v15) - v14) * percent) + v14;
    var10Cf.x = v15 + v68.x;
    MenuScreen::DrawSprite(this, sliderNub, (CRGBA)&v50, v68, var10Cf, 0);
  }
}
// 299348: fragmented variable at 0:r3.4,4:^118.4 may be wrong
// 299348: variables would overlap: 0:r3.4,4:^118.4 and ^118.4

//----- (002998C4) --------------------------------------------------------
void __fastcall MenuScreen::OnBack(MenuScreen *this)
{
  if ( gMobileMenu.screenStack.numEntries >= 2 )
    (*((void (__fastcall **)(MenuScreen *, MenuScreen *))gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries
                                                                                       - 2]->_vptr$MenuScreen
     + 5))(
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 2],
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
  MobileMenu::RemoveTopScreen(&gMobileMenu, 0, 0);
}

//----- (00299908) --------------------------------------------------------
bool __fastcall IsCloudSlot(int slotNum)
{
  return (slotNum | 1) == 7 && UseCloudSaves;
}

//----- (0029992C) --------------------------------------------------------
void __fastcall MobileMenu::Initialize(MobileMenu *this)
{
  float screenHeight; // s0
  float v3; // s2
  float x; // s24
  int v5; // r0
  float y; // s26
  float v7; // s28
  int v8; // r0
  float v9; // s2
  float v10; // s24
  float v11; // s2
  float v12; // s0
  int v13; // r0
  float v14; // s26
  float v15; // s28
  int v16; // r0
  float v17; // s6
  float v18; // s0
  float v19; // s2
  float v20; // s4
  float v21; // s4
  float v22; // s6
  float v23; // s0
  float v24; // s2
  float v25; // s8

  if ( RsGlobal.screenHeight )
  {
    screenHeight = (float)RsGlobal.screenHeight;
    v3 = (float)RsGlobal.screenWidth * 0.4;
  }
  else
  {
    v3 = 974.4;
    screenHeight = 1125.0;
    RsGlobal.screenWidth = 2436;
    RsGlobal.screenHeight = 1125;
  }
  x = v3 / screenHeight;
  this->bgUVSize.y = 0.4;
  for ( this->bgUVSize.x = v3 / screenHeight; ; x = this->bgUVSize.x )
  {
    v5 = rand();
    y = this->bgUVSize.y;
    v7 = (float)v5;
    v8 = rand();
    v9 = 1.0 - x;
    v10 = this->bgUVSize.x;
    v11 = (float)(v9 * (float)(v7 * 4.6566e-10)) + 0.0;
    v12 = (float)((float)(1.0 - y) * (float)((float)v8 * 4.6566e-10)) + 0.0;
    this->bgCurCoords.x = v11;
    this->bgCurCoords.y = v12;
    this->bgStartCoords.x = v11;
    this->bgStartCoords.y = v12;
    v13 = rand();
    v14 = this->bgUVSize.y;
    v15 = (float)v13;
    v16 = rand();
    v17 = this->bgStartCoords.y;
    v18 = (float)((float)(1.0 - v10) * (float)(v15 * 4.6566e-10)) + 0.0;
    v19 = (float)((float)(1.0 - v14) * (float)((float)v16 * 4.6566e-10)) + 0.0;
    v20 = this->bgStartCoords.x;
    this->bgTargetCoords.x = v18;
    this->bgTargetCoords.y = v19;
    if ( sqrtf((float)((float)(v20 - v18) * (float)(v20 - v18)) + (float)((float)(v17 - v19) * (float)(v17 - v19))) >= 0.35 )
      break;
  }
  v21 = this->bgCurCoords.x;
  v22 = this->bgCurCoords.y;
  v23 = v18 - v21;
  v24 = v19 - v22;
  v25 = 1.0 / sqrtf((float)(v23 * v23) + (float)(v24 * v24));
  this->bgCurCoords.x = v21 + (float)((float)(v23 * v25) * 0.15);
  this->bgCurCoords.y = v22 + (float)((float)(v24 * v25) * 0.15);
}

//----- (00299AD8) --------------------------------------------------------
CVector2D *__fastcall MobileMenu::CalcBGUVSize(CVector2D *retstr, MobileMenu *this)
{
  float screenWidth; // s0
  float screenHeight; // s2

  screenWidth = (float)RsGlobal.screenWidth;
  screenHeight = (float)RsGlobal.screenHeight;
  retstr->y = 0.4;
  retstr->x = (float)(screenWidth * 0.4) / screenHeight;
  return retstr;
}

//----- (00299B14) --------------------------------------------------------
CVector2D *__fastcall MobileMenu::GetRandomBGCoords(CVector2D *retstr, MobileMenu *this)
{
  float x; // s16
  int v5; // r0
  float y; // s20
  float v7; // s22
  CVector2D *result; // r0

  x = this->bgUVSize.x;
  v5 = rand();
  y = this->bgUVSize.y;
  v7 = (float)v5;
  result = (CVector2D *)rand();
  retstr->x = (float)((float)(1.0 - x) * (float)(v7 * 4.6566e-10)) + 0.0;
  retstr->y = (float)((float)(1.0 - y) * (float)((float)(int)result * 4.6566e-10)) + 0.0;
  return result;
}

//----- (00299B84) --------------------------------------------------------
void __fastcall MobileMenu::MobileMenu(MobileMenu *this)
{
  OSArray<MenuScreen *> *p_screenStack; // r0

  this->bgTex = 0;
  this->WantsToLoad = 0;
  this->NEW_MAP_SCALE = 1100.0;
  this->MAP_OFFSET_X = 320.0;
  this->MAP_OFFSET_Y = 224.0;
  this->isMapMode = 0;
  *(_WORD *)&this->CurrentGameNotResumable = 0;
  p_screenStack = &this->screenStack;
  *(_QWORD *)&p_screenStack->numAlloced = 0LL;
  *(_QWORD *)&p_screenStack->dataPtr = 0LL;
  MobileMenu::InitGameVars(this);
  this->pointerMode = 1;
}

//----- (00299BD4) --------------------------------------------------------
void __fastcall MobileMenu::Render(MobileMenu *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d4
  unsigned int numEntries; // r0
  bool v6; // zf
  unsigned int v7; // r0
  MenuScreen *v8; // r0
  float v9; // s0
  float screenHeight; // s20
  float screenWidth; // s18
  RwInt32 v12; // s2
  float v13; // s18
  float v14; // s20
  MenuScreen *v15; // r0
  float opacity; // r4
  MenuScreen *v17; // r0
  float x; // s4
  float y; // s6
  RwTexture_0 *bgTex; // r5
  float v21; // s0
  float v22; // s16
  float v23; // s18
  CVector2D bgCurCoords; // kr00_8
  float v25; // s20
  float v26; // s22
  RwInt32 v27; // s0
  RwInt32 v28; // s2
  float v29; // s16
  float v30; // s18
  float TopAreaHeight; // r5
  RwTexture_0 **p_controlsBack2; // r1
  float v33; // s20
  void **v34; // r11
  float v35; // s2
  float v36; // s18
  float v37; // s16
  float v38; // s20
  RwInt32 v39; // s0
  unsigned int v40; // r0
  MenuScreen *v41; // r0
  CRGBA v42; // [sp+8h] [bp-70h] BYREF
  CRGBA v43; // [sp+Ch] [bp-6Ch] BYREF
  CRGBA v44; // [sp+10h] [bp-68h] BYREF
  CRGBA v45; // [sp+14h] [bp-64h] BYREF
  CRGBA v46; // [sp+18h] [bp-60h] BYREF
  CRGBA v47; // [sp+1Ch] [bp-5Ch] BYREF
  CRGBA v48; // [sp+20h] [bp-58h] BYREF
  CRGBA v49; // [sp+24h] [bp-54h] BYREF
  CRGBA v50; // [sp+28h] [bp-50h] BYREF
  CRGBA v51; // [sp+2Ch] [bp-4Ch] BYREF
  CRGBA v52; // [sp+30h] [bp-48h] BYREF
  CRGBA v53; // [sp+34h] [bp-44h] BYREF

  numEntries = this->screenStack.numEntries;
  v6 = numEntries == 0;
  if ( !numEntries )
    v6 = this->pendingScreen == 0;
  if ( !v6 )
  {
    if ( emu_IsAltRenderTarget() )
      emu_FlushAltRenderTarget();
    CRGBA::CRGBA(&v50, 0, 0, 0, 0);
    CRGBA::CRGBA(&v51, 0, 0, 0, 0);
    CRGBA::CRGBA(&v52, 0, 0, 0, 0xFFu);
    CRGBA::CRGBA(&v53, 0, 0, 0, 0xFFu);
    CRGBA::CRGBA(&v46, 0, 0, 0, 0xFFu);
    CRGBA::CRGBA(&v47, 0, 0, 0, 0xFFu);
    CRGBA::CRGBA(&v48, 0, 0, 0, 0xFFu);
    CRGBA::CRGBA(&v49, 0, 0, 0, 0xFFu);
    v7 = this->screenStack.numEntries;
    if ( v7
      && (v8 = this->screenStack.dataPtr[v7 - 1],
          (*((int (__fastcall **)(MenuScreen *))v8->_vptr$MenuScreen + 11))(v8) == 1)
      && Menu_IsPlayingGame(1)
      && !gMobileMenu.InitializedForSignOut )
    {
      Menu_MapRender();
      MobileMenu::PrepareToRender();
      v9 = mapModeOpacity;
      if ( mapModeOpacity < 1.0 )
      {
        v50._anon_0._anon_0.alpha = (unsigned int)(float)((float)(1.0 - mapModeOpacity)
                                                        * (float)v50._anon_0._anon_0.alpha);
        v46._anon_0._anon_0.alpha = (unsigned int)(float)((float)(1.0 - mapModeOpacity)
                                                        * (float)v46._anon_0._anon_0.alpha);
        v51._anon_0._anon_0.alpha = (unsigned int)(float)((float)(1.0 - mapModeOpacity)
                                                        * (float)v51._anon_0._anon_0.alpha);
        v52._anon_0._anon_0.alpha = (unsigned int)(float)((float)(1.0 - mapModeOpacity)
                                                        * (float)v52._anon_0._anon_0.alpha);
        v53._anon_0._anon_0.alpha = (unsigned int)(float)((float)(1.0 - mapModeOpacity)
                                                        * (float)v53._anon_0._anon_0.alpha);
        screenHeight = (float)RsGlobal.screenHeight;
        screenWidth = (float)RsGlobal.screenWidth;
        v47._anon_0._anon_0.alpha = (unsigned int)(float)((float)(1.0 - mapModeOpacity)
                                                        * (float)v47._anon_0._anon_0.alpha);
        v48._anon_0._anon_0.alpha = (unsigned int)(float)((float)(1.0 - mapModeOpacity)
                                                        * (float)v48._anon_0._anon_0.alpha);
        v49._anon_0._anon_0.alpha = (unsigned int)(float)((float)(1.0 - mapModeOpacity)
                                                        * (float)v49._anon_0._anon_0.alpha);
        RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
        *(CRGBA *)&maVertices[0].r = v50;
        maVertices[0].x = 0.0;
        maVertices[0].y = 0.0;
        maVertices[0].z = 1.0;
        maVertices[0].rhw = 1.0;
        maVertices[0].s = 0.0;
        maVertices[0].t = 0.0;
        maVertices[1].x = screenWidth;
        maVertices[1].y = 0.0;
        maVertices[1].z = 1.0;
        maVertices[1].rhw = 1.0;
        maVertices[1].s = 1.0;
        maVertices[1].t = 0.0;
        *(CRGBA *)&maVertices[1].r = v51;
        maVertices[2].y = screenHeight * 0.85;
        maVertices[2].z = 1.0;
        maVertices[2].rhw = 1.0;
        maVertices[2].s = 0.0;
        maVertices[2].t = 1.0;
        maVertices[2].x = 0.0;
        *(CRGBA *)&maVertices[2].r = v52;
        maVertices[3].z = 1.0;
        maVertices[3].rhw = 1.0;
        maVertices[3].s = 1.0;
        maVertices[3].t = 1.0;
        maVertices[3].x = screenWidth;
        maVertices[3].y = screenHeight * 0.85;
        *(CRGBA *)&maVertices[3].r = v53;
        RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, maVertices, 4);
        v12 = RsGlobal.screenHeight;
        v13 = (float)RsGlobal.screenWidth;
        v14 = (float)RsGlobal.screenHeight;
        RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
        maVertices[0].x = 0.0;
        maVertices[0].z = 1.0;
        maVertices[0].rhw = 1.0;
        maVertices[0].s = 0.0;
        maVertices[0].t = 0.0;
        maVertices[1].z = 1.0;
        maVertices[1].rhw = 1.0;
        maVertices[1].s = 1.0;
        maVertices[1].t = 0.0;
        *(CRGBA *)&maVertices[0].r = v46;
        maVertices[1].x = v13;
        maVertices[1].y = v14 * 0.85;
        maVertices[0].y = v14 * 0.85;
        *(CRGBA *)&maVertices[1].r = v47;
        maVertices[2].y = (float)v12;
        maVertices[2].z = 1.0;
        maVertices[2].rhw = 1.0;
        maVertices[2].s = 0.0;
        maVertices[2].t = 1.0;
        maVertices[2].x = 0.0;
        *(CRGBA *)&maVertices[2].r = v48;
        maVertices[3].z = 1.0;
        maVertices[3].rhw = 1.0;
        maVertices[3].s = 1.0;
        maVertices[3].t = 1.0;
        maVertices[3].x = v13;
        maVertices[3].y = (float)v12;
        *(CRGBA *)&maVertices[3].r = v49;
        RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, maVertices, 4);
        v9 = mapModeOpacity;
      }
      if ( v9 > 0.0 )
      {
        v15 = this->screenStack.dataPtr[this->screenStack.numEntries - 1];
        opacity = v15->opacity;
        v15->opacity = v9;
        v17 = this->screenStack.dataPtr[this->screenStack.numEntries - 1];
        (*((void (__fastcall **)(MenuScreen *, int))v17->_vptr$MenuScreen + 10))(v17, 1);
        this->screenStack.dataPtr[this->screenStack.numEntries - 1]->opacity = opacity;
      }
    }
    else
    {
      MobileMenu::PrepareToRender();
      x = this->bgCurCoords.x;
      y = this->bgCurCoords.y;
      bgTex = this->bgTex;
      v3.n64_u32[0] = 1.0;
      v1.n64_f32[0] = sqrtf(
                        (float)((float)(x - this->bgTargetCoords.x) * (float)(x - this->bgTargetCoords.x))
                      + (float)((float)(y - this->bgTargetCoords.y) * (float)(y - this->bgTargetCoords.y)))
                    * 25.0;
      v2.n64_f32[0] = sqrtf(
                        (float)((float)(x - this->bgStartCoords.x) * (float)(x - this->bgStartCoords.x))
                      + (float)((float)(y - this->bgStartCoords.y) * (float)(y - this->bgStartCoords.y)))
                    * 35.0;
      v21 = vmin_f32(v2, v3).n64_f32[0] * vmin_f32(v1, v3).n64_f32[0];
      CRGBA::CRGBA(
        &v45,
        (unsigned int)(float)(v21 * 50.0),
        (unsigned int)(float)(v21 * 50.0),
        (unsigned int)(float)(v21 * 50.0),
        0xFFu);
      v22 = this->bgUVSize.x;
      v23 = this->bgUVSize.y;
      bgCurCoords = this->bgCurCoords;
      v25 = (float)RsGlobal.screenHeight;
      v26 = (float)RsGlobal.screenWidth;
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, bgTex->raster);
      maVertices[0].x = 0.0;
      maVertices[0].y = 0.0;
      maVertices[0].z = 1.0;
      maVertices[0].rhw = 1.0;
      *(CVector2D *)&maVertices[0].s = bgCurCoords;
      *(CRGBA *)&maVertices[0].r = v45;
      maVertices[1].y = 0.0;
      maVertices[1].z = 1.0;
      maVertices[1].rhw = 1.0;
      maVertices[1].t = bgCurCoords.y;
      *(CRGBA *)&maVertices[1].r = v45;
      maVertices[1].x = v26;
      maVertices[1].s = v22 + bgCurCoords.x;
      maVertices[2].s = bgCurCoords.x;
      maVertices[2].y = v25;
      maVertices[2].z = 1.0;
      maVertices[2].rhw = 1.0;
      maVertices[2].t = v23 + bgCurCoords.y;
      *(CRGBA *)&maVertices[2].r = v45;
      maVertices[2].x = 0.0;
      *(CRGBA *)&maVertices[3].r = v45;
      maVertices[3].y = v25;
      maVertices[3].z = 1.0;
      maVertices[3].rhw = 1.0;
      maVertices[3].s = v22 + bgCurCoords.x;
      maVertices[3].t = v23 + bgCurCoords.y;
      maVertices[3].x = v26;
      RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, maVertices, 4);
      v27 = RsGlobal.screenWidth;
      v28 = RsGlobal.screenHeight;
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
      maVertices[0].x = 0.0;
      maVertices[0].y = 0.0;
      maVertices[0].z = 1.0;
      maVertices[0].rhw = 1.0;
      maVertices[0].s = 0.0;
      maVertices[0].t = 0.0;
      maVertices[1].y = 0.0;
      maVertices[1].z = 1.0;
      maVertices[1].rhw = 1.0;
      maVertices[1].s = 1.0;
      maVertices[1].t = 0.0;
      *(CRGBA *)&maVertices[0].r = v50;
      maVertices[1].x = (float)v27;
      *(CRGBA *)&maVertices[1].r = v51;
      maVertices[2].y = (float)v28;
      maVertices[2].z = 1.0;
      maVertices[2].rhw = 1.0;
      maVertices[2].s = 0.0;
      maVertices[2].t = 1.0;
      maVertices[2].x = 0.0;
      *(CRGBA *)&maVertices[2].r = v52;
      maVertices[3].z = 1.0;
      maVertices[3].rhw = 1.0;
      maVertices[3].s = 1.0;
      maVertices[3].t = 1.0;
      maVertices[3].x = (float)v27;
      maVertices[3].y = (float)v28;
      *(CRGBA *)&maVertices[3].r = v53;
      RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, maVertices, 4);
    }
    if ( CAdjustableHUD::m_pInstance )
    {
      v29 = (float)RsGlobal.screenWidth;
      v30 = (float)RsGlobal.screenHeight;
      TopAreaHeight = CAdjustableHUD::GetTopAreaHeight();
      p_controlsBack2 = &this->controlsBack2;
      v33 = (float)RsGlobal.screenHeight;
      if ( CAdjustableHUD::m_pInstance->m_nAdjustmentMode == 1 )
        p_controlsBack2 = &this->controlsBack;
      v34 = (void **)*p_controlsBack2;
      CRGBA::CRGBA(&v44, 0x80u, 0x80u, 0x80u, 0xFFu);
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, *v34);
      maVertices[0].y = 0.0;
      maVertices[0].z = 1.0;
      maVertices[0].rhw = 1.0;
      maVertices[0].s = 0.0;
      maVertices[0].t = 0.0;
      *(CRGBA *)&maVertices[0].r = v44;
      maVertices[1].y = 0.0;
      maVertices[1].z = 1.0;
      maVertices[1].rhw = 1.0;
      maVertices[1].s = 1.0;
      maVertices[1].t = 0.0;
      *(CRGBA *)&maVertices[1].r = v44;
      v35 = (float)(v30 * 427.0) / 480.0;
      v36 = (float)(v29 * 0.5) + (float)((float)(v30 * -427.0) / 480.0);
      v37 = (float)(v29 * 0.5) + v35;
      maVertices[0].x = v36;
      maVertices[1].x = v37;
      maVertices[2].x = v36;
      *(CRGBA *)&maVertices[2].r = v44;
      *(CRGBA *)&maVertices[3].r = v44;
      maVertices[2].y = TopAreaHeight;
      maVertices[2].z = 1.0;
      maVertices[2].rhw = 1.0;
      maVertices[2].s = 0.0;
      maVertices[2].t = 0.235;
      maVertices[3].s = 1.0;
      maVertices[3].t = 0.235;
      maVertices[3].y = TopAreaHeight;
      maVertices[3].z = 1.0;
      maVertices[3].rhw = 1.0;
      maVertices[3].x = v37;
      RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, maVertices, 4);
      CRGBA::CRGBA(&v43, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, *v34);
      maVertices[0].y = TopAreaHeight;
      maVertices[1].y = TopAreaHeight;
      maVertices[0].t = 0.235;
      maVertices[1].t = 0.235;
      v38 = v33 + (float)(v33 * -0.067);
      maVertices[0].x = v36;
      maVertices[0].z = 1.0;
      maVertices[0].rhw = 1.0;
      maVertices[0].s = 0.0;
      maVertices[1].x = v37;
      *(CRGBA *)&maVertices[0].r = v43;
      maVertices[1].z = 1.0;
      maVertices[1].rhw = 1.0;
      maVertices[1].s = 1.0;
      *(CRGBA *)&maVertices[1].r = v43;
      maVertices[2].x = v36;
      maVertices[2].y = v38;
      maVertices[2].z = 1.0;
      maVertices[2].rhw = 1.0;
      maVertices[2].s = 0.0;
      maVertices[2].t = 0.933;
      *(CRGBA *)&maVertices[2].r = v43;
      *(CRGBA *)&maVertices[3].r = v43;
      maVertices[3].z = 1.0;
      maVertices[3].rhw = 1.0;
      maVertices[3].s = 1.0;
      maVertices[3].t = 0.933;
      maVertices[3].x = v37;
      maVertices[3].y = v38;
      RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, maVertices, 4);
      CRGBA::CRGBA(&v42, 0x80u, 0x80u, 0x80u, 0xFFu);
      v39 = RsGlobal.screenHeight;
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, *v34);
      maVertices[1].t = 0.933;
      maVertices[0].x = v36;
      maVertices[0].y = v38;
      maVertices[0].z = 1.0;
      maVertices[0].rhw = 1.0;
      maVertices[0].s = 0.0;
      maVertices[0].t = 0.933;
      *(CRGBA *)&maVertices[0].r = v42;
      maVertices[1].x = v37;
      maVertices[1].y = v38;
      maVertices[1].z = 1.0;
      maVertices[1].rhw = 1.0;
      maVertices[1].s = 1.0;
      *(CRGBA *)&maVertices[1].r = v42;
      maVertices[2].x = v36;
      maVertices[2].z = 1.0;
      maVertices[2].rhw = 1.0;
      maVertices[2].s = 0.0;
      maVertices[2].t = 1.0;
      *(CRGBA *)&maVertices[2].r = v42;
      maVertices[2].y = (float)v39;
      maVertices[3].z = 1.0;
      maVertices[3].rhw = 1.0;
      maVertices[3].s = 1.0;
      maVertices[3].t = 1.0;
      *(CRGBA *)&maVertices[3].r = v42;
      maVertices[3].x = v37;
      maVertices[3].y = (float)v39;
      RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, maVertices, 4);
      CAdjustableHUD::Draw(CAdjustableHUD::m_pInstance);
    }
    else
    {
      v40 = this->screenStack.numEntries;
      if ( v40 )
      {
        v41 = this->screenStack.dataPtr[v40 - 1];
        if ( !this->isMapMode || v41->opacity > 0.0 )
          (*((void (__fastcall **)(MenuScreen *))v41->_vptr$MenuScreen + 3))(v41);
      }
      CFont::RenderFontBuffer();
      CWidget::DrawTitleSafeArea();
    }
  }
}
// 29A06A: variable 'v2' is possibly undefined
// 29A06A: variable 'v3' is possibly undefined
// 29A066: variable 'v1' is possibly undefined
// 10: using guessed type __int16 word_10;
// 12: using guessed type __int16 word_12;
// 2C: using guessed type __int16 word_2C;
// 2E: using guessed type __int16 word_2E;
// 48: using guessed type int dword_48;
// 64: using guessed type int dword_64;

//----- (0029A574) --------------------------------------------------------
void MobileMenu::PrepareToRender()
{
  CFont::SetAlphaFade(255.0);
  CSprite2d::InitPerFrame();
  CFont::InitPerFrame();
  CFont::SetBackground(0, 0);
  CFont::SetWrapx((float)RsGlobal.screenWidth);
  CFont::SetOrientation(1u);
  CFont::SetCentreSize((float)RsGlobal.screenWidth);
  CFont::SetProportional(1u);
  DefinedState2d();
  RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
  RwRenderStateSet(rwRENDERSTATEFOGENABLE, 0);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  RwRenderStateSet(rwRENDERSTATEVERTEXALPHAENABLE, (char *)&dword_0 + 1);
  RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
  sub_192840(rwRENDERSTATETEXTUREADDRESS, (char *)&dword_0 + 3);
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;

//----- (0029A614) --------------------------------------------------------
void __fastcall MobileMenu::ClampBGCoords(MobileMenu *this, CVector2D *toClamp)
{
  float y; // s2

  if ( (float)(toClamp->x + this->bgUVSize.x) > 1.0 )
    toClamp->x = 1.0 - this->bgUVSize.x;
  y = this->bgUVSize.y;
  if ( (float)(toClamp->y + y) > 1.0 )
    toClamp->y = 1.0 - y;
}

//----- (0029A656) --------------------------------------------------------
void __fastcall MobileMenu::ProcessPending(MobileMenu *this)
{
  unsigned int numEntries; // r6
  MenuScreen **dataPtr; // r1
  unsigned int v4; // r9
  MenuScreen **v5; // r0
  MenuScreen **v6; // r8
  MenuScreen **v7; // r5
  MenuScreen *pendingScreen; // r0
  unsigned int v9; // r2
  MenuScreen *v10; // r0

  numEntries = this->screenStack.numEntries;
  if ( numEntries >= 2 && (dataPtr = this->screenStack.dataPtr, this->pendingScreen == dataPtr[numEntries - 2]) )
  {
    v9 = numEntries - 1;
    v10 = dataPtr[numEntries - 1];
    this->screenStack.numEntries = numEntries - 1;
    if ( v10 )
    {
      (*((void (__fastcall **)(MenuScreen *))v10->_vptr$MenuScreen + 1))(v10);
      dataPtr = this->screenStack.dataPtr;
      v9 = this->screenStack.numEntries;
    }
    (*((void (__fastcall **)(MenuScreen *))dataPtr[v9 - 1]->_vptr$MenuScreen + 4))(dataPtr[v9 - 1]);
  }
  else
  {
    if ( this->screenStack.numAlloced >= numEntries + 1 )
    {
      v7 = this->screenStack.dataPtr;
    }
    else
    {
      v4 = 4 * (numEntries + 1) / 3 + 3;
      v5 = (MenuScreen **)malloc(4 * v4);
      v6 = this->screenStack.dataPtr;
      v7 = v5;
      if ( v6 )
      {
        qmemcpy(v5, this->screenStack.dataPtr, 4 * numEntries);
        free(v6);
        numEntries = this->screenStack.numEntries;
      }
      this->screenStack.dataPtr = v7;
      this->screenStack.numAlloced = v4;
    }
    v7[numEntries] = this->pendingScreen;
    pendingScreen = this->pendingScreen;
    ++this->screenStack.numEntries;
    (*((void (__fastcall **)(MenuScreen *))pendingScreen->_vptr$MenuScreen + 4))(pendingScreen);
    if ( this->pointerMode )
      this->pointerMode = 0;
  }
  this->pendingScreen = 0;
}

//----- (0029A714) --------------------------------------------------------
void __fastcall MobileMenu::PopAllScreens(MobileMenu *this)
{
  while ( this->screenStack.numEntries )
    MobileMenu::RemoveTopScreen(this, 1, 0);
}

//----- (0029A730) --------------------------------------------------------
void __fastcall MobileMenu::Update(MobileMenu *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d8
  float32x2_t v4; // d9
  unsigned int numEntries; // r0
  bool v7; // zf
  double v8; // d16
  double v9; // d17
  float v10; // s20
  float v11; // s22
  float v12; // s0
  float v13; // s4
  float v14; // s6
  float v15; // s8
  float v16; // s2
  float v17; // s8
  float v18; // s6
  float v19; // s10
  int v20; // r0
  float v21; // s28
  float v22; // s30
  int v23; // r0
  float v24; // s2
  float v25; // s22
  float v26; // s2
  float v27; // s0
  int v28; // r0
  float v29; // s28
  float v30; // s30
  int v31; // r0
  float v32; // s6
  float v33; // s2
  float v34; // s0
  float v35; // s4
  int v36; // r6
  OSPointingDevice Type; // r0
  int v38; // r5
  float *v39; // r0
  float v40; // s0
  float v41; // s2
  float *p_y; // r1
  OSPointerState Button; // r0
  char *v44; // r8
  bool v45; // r0
  unsigned int v46; // r0
  MenuScreen *v47; // r0
  float opacity; // s0
  CPad *Pad; // r0
  _BOOL4 EscapeJustDown; // r0
  MenuScreen *v51; // r0
  float v52; // s0
  unsigned int v53; // r0
  MenuScreen *v54; // r0
  MenuScreen *pendingScreen; // r0
  MenuScreen *v56; // r1
  unsigned __int32 v57; // s2
  tAudioEvent v58; // r1
  unsigned __int32 v59; // s2
  unsigned __int32 v60; // s2
  int v61; // [sp+4h] [bp-6Ch]
  int y; // [sp+8h] [bp-68h] BYREF
  int x[25]; // [sp+Ch] [bp-64h] BYREF

  numEntries = this->screenStack.numEntries;
  v7 = numEntries == 0;
  if ( !numEntries )
    v7 = this->pendingScreen == 0;
  if ( v7 )
  {
    Pad = CPad::GetPad(0);
    EscapeJustDown = CPad::GetEscapeJustDown(Pad);
    if ( !CCutsceneMgr::ms_running && EscapeJustDown )
      MobileMenu::InitForPause(this);
    return;
  }
  v8 = OS_TimeAccurate();
  v4.n64_u32[0] = 1.0;
  v3.n64_u32[0] = 0;
  v9 = v8 - MobileMenu::Update(void)::lastTime;
  v10 = v8 - MobileMenu::Update(void)::lastTime;
  v11 = (float)((float)RsGlobal.screenWidth * 0.4) / (float)RsGlobal.screenHeight;
  if ( v8 - MobileMenu::Update(void)::lastTime < 0.0 )
    v10 = 0.0;
  MobileMenu::Update(void)::lastTime = v8;
  v12 = this->bgCurCoords.x;
  if ( v9 > 0.100000001 )
    v10 = 0.0;
  this->bgUVSize.y = 0.4;
  this->bgUVSize.x = v11;
  if ( (float)(v12 + v11) > 1.0 )
  {
    v12 = 1.0 - v11;
    this->bgCurCoords.x = 1.0 - v11;
  }
  v13 = this->bgCurCoords.y;
  if ( (float)(v13 + 0.4) > 1.0 )
  {
    v13 = 0.6;
    this->bgCurCoords.y = 0.6;
  }
  v14 = this->bgTargetCoords.x;
  if ( (float)(v14 + v11) > 1.0 )
  {
    v14 = 1.0 - v11;
    this->bgTargetCoords.x = 1.0 - v11;
  }
  v15 = this->bgTargetCoords.y;
  if ( (float)(v15 + 0.4) > 1.0 )
  {
    v15 = 0.6;
    this->bgTargetCoords.y = 0.6;
  }
  v16 = v10 * 0.009;
  if ( sqrtf((float)((float)(v12 - v14) * (float)(v12 - v14)) + (float)((float)(v13 - v15) * (float)(v13 - v15))) <= (float)(v10 * 0.009) )
  {
    while ( 1 )
    {
      v20 = rand();
      v21 = this->bgUVSize.y;
      v22 = (float)v20;
      v23 = rand();
      v24 = 1.0 - v11;
      v25 = this->bgUVSize.x;
      v26 = (float)(v24 * (float)(v22 * 4.6566e-10)) + 0.0;
      v27 = (float)((float)(1.0 - v21) * (float)((float)v23 * 4.6566e-10)) + 0.0;
      this->bgCurCoords.x = v26;
      this->bgCurCoords.y = v27;
      this->bgStartCoords.x = v26;
      this->bgStartCoords.y = v27;
      v28 = rand();
      v29 = this->bgUVSize.y;
      v30 = (float)v28;
      v31 = rand();
      v32 = this->bgStartCoords.y;
      v33 = (float)((float)(1.0 - v25) * (float)(v30 * 4.6566e-10)) + 0.0;
      v34 = (float)((float)(1.0 - v29) * (float)((float)v31 * 4.6566e-10)) + 0.0;
      v35 = this->bgStartCoords.x - v33;
      this->bgTargetCoords.x = v33;
      this->bgTargetCoords.y = v34;
      if ( sqrtf((float)(v35 * v35) + (float)((float)(v32 - v34) * (float)(v32 - v34))) >= 0.35 )
        break;
      v11 = this->bgUVSize.x;
    }
  }
  else
  {
    v17 = v15 - v13;
    v18 = v14 - v12;
    v19 = 1.0 / sqrtf((float)(v18 * v18) + (float)(v17 * v17));
    this->bgCurCoords.x = v12 + (float)(v16 * (float)(v18 * v19));
    this->bgCurCoords.y = (float)(v16 * (float)(v17 * v19)) + v13;
  }
  v36 = 0;
  Type = OS_PointerGetType(0);
  if ( Type != OSPD_Mouse )
    LOBYTE(Type) = 0;
  this->isMouse = Type;
  v38 = 0;
  v61 = 0;
  do
  {
    LIB_PointerGetCoordinates(v38, x, &y, 0);
    v7 = (LIB_PointerGetButton(v38, 0) | 1) == 3;
    v39 = (float *)((char *)&this->bgUVSize.x + v36);
    if ( v7 )
      lastDevice = v38;
    v40 = (float)((float)y * 480.0) / (float)RsGlobal.screenHeight;
    v41 = (float)((float)((float)((float)x[0] * 480.0) + (float)((float)RsGlobal.screenWidth * -240.0))
                / (float)RsGlobal.screenHeight)
        + 320.0;
    if ( this->pointerMode )
    {
      p_y = v39 + 29;
      v39[28] = v41;
    }
    else
    {
      if ( (float)((float)((float)(v41 - v39[28]) * (float)(v41 - v39[28]))
                 + (float)((float)(v40 - v39[29]) * (float)(v40 - v39[29]))) <= 1.0 )
      {
        this->pointerState[v38] = OSPS_ButtonUp;
        goto LABEL_33;
      }
      v39[28] = v41;
      p_y = &this->pointerCoords[v38].y;
      v61 = 1;
    }
    *p_y = v40;
    Button = LIB_PointerGetButton(v38, 0);
    v44 = (char *)(&this->bgUVSize.x + v38);
    *((_DWORD *)v44 + 36) = Button;
    if ( Button == OSPS_ButtonPressed )
      *((_DWORD *)v44 + 40) = OS_TimeMS();
LABEL_33:
    ++v38;
    v36 += 8;
  }
  while ( v38 != 4 );
  if ( this->pointerMode )
  {
    if ( !(v61 << 31) && (LeftPressed() || RightPressed() || UpPressed() || DownPressed() == 1) )
    {
      v45 = 0;
      goto LABEL_44;
    }
  }
  else if ( v61 << 31 || this->pointerState[lastDevice] == OSPS_ButtonPressed )
  {
    v45 = 1;
LABEL_44:
    this->pointerMode = v45;
  }
  if ( CAdjustableHUD::m_pInstance )
  {
    CAdjustableHUD::Update(CAdjustableHUD::m_pInstance);
    return;
  }
  if ( this->pendingScreen )
  {
    v46 = this->screenStack.numEntries;
    if ( v46 && (v47 = this->screenStack.dataPtr[v46 - 1], opacity = v47->opacity, opacity != 0.0) )
    {
      v52 = opacity + (float)(v10 * -5.0);
      v47->opacity = v52;
      if ( v52 < 0.0 )
        v47->opacity = 0.0;
    }
    else
    {
      MobileMenu::ProcessPending(this);
    }
  }
  else if ( !this->isMapMode )
  {
    v51 = this->screenStack.dataPtr[this->screenStack.numEntries - 1];
    (*((void (__fastcall **)(MenuScreen *, float))v51->_vptr$MenuScreen + 2))(v51, COERCE_FLOAT(LODWORD(v10)));
  }
  v53 = this->screenStack.numEntries;
  if ( v53
    && (v54 = this->screenStack.dataPtr[v53 - 1],
        (*((int (__fastcall **)(MenuScreen *))v54->_vptr$MenuScreen + 11))(v54) == 1)
    && Menu_IsPlayingGame(1)
    && ((pendingScreen = this->pendingScreen) == 0
     || (*((int (__fastcall **)(MenuScreen *))pendingScreen->_vptr$MenuScreen + 11))(pendingScreen) == 1)
    && !gMobileMenu.InitializedForSignOut )
  {
    if ( this->isMapMode )
    {
      v56 = this->screenStack.dataPtr[this->screenStack.numEntries - 1];
      v2.n64_f32[0] = v56->opacity - (float)(v10 * 5.0);
      LODWORD(v56->opacity) = vmax_f32(v2, v3).n64_u32[0];
      v1.n64_f32[0] = (float)(v10 * 5.0) + mapModeOpacity;
      v57 = vmin_f32(v1, v4).n64_u32[0];
      if ( v1.n64_f32[0] < 0.0 )
        v57 = 0;
      LODWORD(mapModeOpacity) = v57;
      Menu_MapUpdate(v10);
      if ( CHID::IsReleased(HID_MAPPING_MENU_MAP) || CHID::IsReleasedPositive(HID_MAPPING_MENU_MAP) || BackPressed() )
      {
        this->isMapMode = 0;
        if ( !NeedsAmazonDownload() )
        {
          v58 = 2;
          goto LABEL_83;
        }
      }
    }
    else
    {
      v1.n64_f32[0] = mapModeOpacity + (float)(v10 * -5.0);
      v60 = vmin_f32(v1, v4).n64_u32[0];
      if ( v1.n64_f32[0] < 0.0 )
        v60 = 0;
      LODWORD(mapModeOpacity) = v60;
      if ( CHID::IsReleased(HID_MAPPING_MENU_MAP)
        || CHID::IsReleasedPositive(HID_MAPPING_MENU_MAP)
        || gMobileMenu.pointerState[lastDevice] == OSPS_ButtonReleased
        && OS_TimeMS() - gMobileMenu.pointerPress[lastDevice] <= 0xC7
        && this->pointerCoords[lastDevice].y < 320.0 )
      {
        this->isMapMode = 1;
        if ( !NeedsAmazonDownload() )
        {
          v58 = 1;
LABEL_83:
          CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, v58, 0.0, 1.0);
        }
      }
    }
  }
  else
  {
    v1.n64_f32[0] = mapModeOpacity + (float)(v10 * -5.0);
    v59 = vmin_f32(v1, v4).n64_u32[0];
    if ( v1.n64_f32[0] < 0.0 )
      v59 = 0;
    LODWORD(mapModeOpacity) = v59;
  }
  CHID::CheckForInputChange();
}
// 29AC1E: variable 'v2' is possibly undefined
// 29AC1E: variable 'v3' is possibly undefined
// 29AC2E: variable 'v1' is possibly undefined
// 29AC2E: variable 'v4' is possibly undefined
// 54: using guessed type int dword_54;
// 29A730: using guessed type int x[25];

//----- (0029ADA8) --------------------------------------------------------
void __fastcall MobileMenu::InitForPause(MobileMenu *this)
{
  int v2; // r5

  this->InitializedForSignOut = 0;
  CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 0, 0.0, 1.0);
  CAudioEngine::Service(&AudioEngine);
  Menu_SwitchOnFromGame();
  Menu_MapInitPause();
  MobileMenu::Load(this);
  v2 = operator new(0x58u);
  FlowScreen::FlowScreen((FlowScreen *)v2, 1, 1);
  *(_DWORD *)v2 = &off_6625C8;
  MainMenuScreen::AddAllItems((MainMenuScreen *)v2);
  if ( this->pendingScreen )
    MobileMenu::ProcessPending(this);
  this->pendingScreen = (MenuScreen *)v2;
  if ( CTouchInterface::m_pWidgets[161]
    && (unsigned int)(CEntryExitManager::ms_exitEnterState - 1) >= 2
    && CTouchInterface::m_pWidgets[161]->m_fTapHoldTime > 0.66 )
  {
    this->isMapMode = 1;
    *(_DWORD *)(v2 + 8) = 1065353216;
  }
}
// 6625C8: using guessed type void *;

//----- (0029AE5C) --------------------------------------------------------
bool __fastcall MobileMenu::IsMainMenuScreen(MobileMenu *this)
{
  unsigned int numEntries; // r0

  numEntries = this->screenStack.numEntries;
  if ( numEntries != 1 )
    LOBYTE(numEntries) = 0;
  return numEntries;
}

//----- (0029AE68) --------------------------------------------------------
void __fastcall MobileMenu::Exit(MobileMenu *this)
{
  unsigned int numEntries; // r1
  MenuScreen *v3; // r0

  MobileMenu::Unload(this);
  numEntries = this->screenStack.numEntries;
  this->pendingScreen = 0;
  this->isMapMode = 0;
  while ( numEntries )
  {
    v3 = this->screenStack.dataPtr[--numEntries];
    this->screenStack.numEntries = numEntries;
    if ( v3 )
    {
      (*((void (__fastcall **)(MenuScreen *))v3->_vptr$MenuScreen + 1))(v3);
      numEntries = this->screenStack.numEntries;
    }
  }
  Menu_SwitchOffToGame();
  if ( Menu_IsPlayingGame(1) )
    skipFrame = 2;
}

//----- (0029AEB8) --------------------------------------------------------
void __fastcall MobileMenu::Load(MobileMenu *this)
{
  TextureDatabaseRuntime *Database; // r5
  RwTexture *Texture; // r0
  RwTexture *v4; // r0
  RwTexture *v5; // r0
  RwTexture *v6; // r0
  RwTexture *v7; // r0
  RwTexture *v8; // r0
  float v9; // s2
  float v10; // s2
  float v11; // s2
  float v12; // s2
  int v13; // [sp+0h] [bp-30h] BYREF
  int x[11]; // [sp+4h] [bp-2Ch] BYREF

  OS_ServiceAppCommand("resetinput", 0);
  Database = TextureDatabaseRuntime::GetDatabase("menu");
  TextureDatabaseRuntime::UpdateStreaming(0.01, 1);
  TextureDatabaseRuntime::Register(Database);
  Texture = TextureDatabaseRuntime::GetTexture("menu_bgmap");
  ++Texture->refCount;
  this->bgTex = Texture;
  v4 = TextureDatabaseRuntime::GetTexture("menu_sliderempty");
  ++v4->refCount;
  this->sliderEmpty = v4;
  v5 = TextureDatabaseRuntime::GetTexture("menu_sliderfull");
  ++v5->refCount;
  this->sliderFull = v5;
  v6 = TextureDatabaseRuntime::GetTexture("menu_slidernub");
  ++v6->refCount;
  this->sliderNub = v6;
  v7 = TextureDatabaseRuntime::GetTexture("menu_adjback");
  ++v7->refCount;
  this->controlsBack = v7;
  v8 = TextureDatabaseRuntime::GetTexture("menu_adjback2");
  ++v8->refCount;
  this->controlsBack2 = v8;
  CTimer::StartUserPause();
  LIB_PointerGetCoordinates(0, x, &v13, 0);
  v9 = (float)((float)v13 * 480.0) / (float)RsGlobal.screenHeight;
  this->pointerCoords[0].x = (float)((float)((float)((float)x[0] * 480.0) - (float)((float)RsGlobal.screenWidth * 240.0))
                                   / (float)RsGlobal.screenHeight)
                           + 320.0;
  this->pointerCoords[0].y = v9;
  LIB_PointerGetCoordinates(1, x, &v13, 0);
  v10 = (float)((float)v13 * 480.0) / (float)RsGlobal.screenHeight;
  this->pointerCoords[1].x = (float)((float)((float)((float)x[0] * 480.0) - (float)((float)RsGlobal.screenWidth * 240.0))
                                   / (float)RsGlobal.screenHeight)
                           + 320.0;
  this->pointerCoords[1].y = v10;
  LIB_PointerGetCoordinates(2, x, &v13, 0);
  v11 = (float)((float)v13 * 480.0) / (float)RsGlobal.screenHeight;
  this->pointerCoords[2].x = (float)((float)((float)((float)x[0] * 480.0) - (float)((float)RsGlobal.screenWidth * 240.0))
                                   / (float)RsGlobal.screenHeight)
                           + 320.0;
  this->pointerCoords[2].y = v11;
  LIB_PointerGetCoordinates(3, x, &v13, 0);
  v12 = (float)((float)v13 * 480.0) / (float)RsGlobal.screenHeight;
  this->pointerCoords[3].x = (float)((float)((float)((float)x[0] * 480.0) - (float)((float)RsGlobal.screenWidth * 240.0))
                                   / (float)RsGlobal.screenHeight)
                           + 320.0;
  this->pointerCoords[3].y = v12;
}

//----- (0029B12C) --------------------------------------------------------
void __fastcall MobileMenu::Unload(MobileMenu *this)
{
  TextureDatabaseRuntime *Database; // r0
  RwTexture_0 *bgTex; // r0
  RwTexture_0 *sliderEmpty; // r0
  RwTexture_0 *sliderFull; // r0
  RwTexture_0 *sliderNub; // r0
  RwTexture_0 *controlsBack; // r0
  RwTexture_0 *controlsBack2; // r0

  Database = TextureDatabaseRuntime::GetDatabase("menu");
  TextureDatabaseRuntime::Unregister(Database);
  bgTex = this->bgTex;
  if ( bgTex )
  {
    RwTextureDestroy(bgTex);
    this->bgTex = 0;
  }
  sliderEmpty = this->sliderEmpty;
  if ( sliderEmpty )
  {
    RwTextureDestroy(sliderEmpty);
    this->sliderEmpty = 0;
  }
  sliderFull = this->sliderFull;
  if ( sliderFull )
  {
    RwTextureDestroy(sliderFull);
    this->sliderFull = 0;
  }
  sliderNub = this->sliderNub;
  if ( sliderNub )
  {
    RwTextureDestroy(sliderNub);
    this->sliderNub = 0;
  }
  controlsBack = this->controlsBack;
  if ( controlsBack )
  {
    RwTextureDestroy(controlsBack);
    this->controlsBack = 0;
  }
  controlsBack2 = this->controlsBack2;
  if ( controlsBack2 )
  {
    RwTextureDestroy(controlsBack2);
    this->controlsBack2 = 0;
  }
  TextureDatabaseRuntime::UpdateStreaming(0.01, 1);
  sub_190240();
}

//----- (0029B1A0) --------------------------------------------------------
void __fastcall MobileMenu::InitForTitle(MobileMenu *this)
{
  MainMenuScreen *v2; // r5

  this->InitializedForSignOut = 0;
  MobileMenu::Load(this);
  v2 = (MainMenuScreen *)operator new(0x58u);
  FlowScreen::FlowScreen(v2, 0, 0);
  v2->_vptr$MenuScreen = (int (**)(void))&off_6625C8;
  MainMenuScreen::AddAllItems(v2);
  if ( this->pendingScreen )
    MobileMenu::ProcessPending(this);
  this->pendingScreen = (MenuScreen *)v2;
}
// 6625C8: using guessed type void *off_6625C8;

//----- (0029B1E8) --------------------------------------------------------
void __fastcall MobileMenu::InitForDownload(MobileMenu *this)
{
  DownloadScreen *v2; // r5

  this->InitializedForSignOut = 0;
  MobileMenu::Load(this);
  v2 = (DownloadScreen *)operator new(0x4Cu);
  DownloadScreen::DownloadScreen(v2);
  if ( this->pendingScreen )
    MobileMenu::ProcessPending(this);
  this->pendingScreen = v2;
}

//----- (0029B218) --------------------------------------------------------
void __fastcall MobileMenu::InitForSignedOut(MobileMenu *this)
{
  unsigned int numEntries; // r1
  MenuScreen *v3; // r0
  MainMenuScreen *v4; // r5

  this->InitializedForSignOut = 1;
  AllowMissionReplay = 0;
LABEL_3:
  numEntries = this->screenStack.numEntries;
  while ( numEntries )
  {
    v3 = this->screenStack.dataPtr[--numEntries];
    this->screenStack.numEntries = numEntries;
    if ( v3 )
    {
      (*((void (__fastcall **)(MenuScreen *))v3->_vptr$MenuScreen + 1))(v3);
      goto LABEL_3;
    }
  }
  if ( CCutsceneMgr::ms_cutsceneProcessing )
  {
    CCutsceneMgr::SkipCutscene();
    CCutsceneMgr::DeleteCutsceneData();
  }
  CTimer::EndUserPause();
  MobileMenu::Load(this);
  v4 = (MainMenuScreen *)operator new(0x58u);
  FlowScreen::FlowScreen(v4, 0, 0);
  v4->_vptr$MenuScreen = (int (**)(void))&off_6625C8;
  MainMenuScreen::AddAllItems(v4);
  if ( this->pendingScreen )
    MobileMenu::ProcessPending(this);
  this->pendingScreen = (MenuScreen *)v4;
}
// 6625C8: using guessed type void *off_6625C8;

//----- (0029B2A4) --------------------------------------------------------
void __fastcall MobileMenu::InitForSave(MobileMenu *this)
{
  CharSelectScreen *v2; // r5
  int v3; // r0
  int v4; // r6
  int v5; // r0

  this->InitializedForSignOut = 0;
  MobileMenu::Load(this);
  v2 = (CharSelectScreen *)operator new(0x48u);
  CharSelectScreen::CharSelectScreen(v2, "FET_SG", 1);
  v2->_vptr$MenuScreen = (int (**)(void))&off_662B4C;
  Menu_PopulateSaves(0);
  v2[1]._vptr$MenuScreen = 0;
  v3 = GameToSKip;
  v2->_vptr$MenuScreen = (int (**)(void))&off_662CB8;
  if ( v3 <= 7 )
  {
    v4 = 0;
    do
    {
      v5 = operator new(0x14u);
      *(_BYTE *)(v5 + 12) = 0;
      *(_DWORD *)(v5 + 16) = v2;
      *(_DWORD *)v5 = &off_662D14;
      *(_DWORD *)(v5 + 4) = &byte_61CADE;
      *(_DWORD *)(v5 + 8) = v4;
      SelectScreen::AddItem(v2, (SelectScreen::MenuSelection *)v5);
      ++v4;
    }
    while ( v4 < 8 - GameToSKip );
  }
  if ( this->pendingScreen )
    MobileMenu::ProcessPending(this);
  this->pendingScreen = v2;
}
// 61CADE: using guessed type char byte_61CADE;
// 662B4C: using guessed type void *off_662B4C;
// 662CB8: using guessed type void *;
// 662D14: using guessed type void *;

//----- (0029B36C) --------------------------------------------------------
void __fastcall Menu_RetryMissionWrapped(void *data)
{
  Menu_DrawLoadScreen(0, 30);
  sub_196F90();
}

//----- (0029B380) --------------------------------------------------------
void __fastcall Menu_DontRetryMission(void *data)
{
  AllowMissionReplay = 0;
}

//----- (0029B390) --------------------------------------------------------
void __fastcall MobileMenu::InitForRetry(MobileMenu *this)
{
  int v2; // r5
  SelectScreen::MenuSelection *v3; // r0
  SelectScreen::MenuSelection *v4; // r0

  this->InitializedForSignOut = 0;
  MobileMenu::Load(this);
  v2 = operator new(0x54u);
  CharSelectScreen::CharSelectScreen((CharSelectScreen *)v2, "FESZ_MF", 0);
  *(_DWORD *)v2 = &off_662D9C;
  *(_DWORD *)(v2 + 68) = "FESZ_RM";
  *(_DWORD *)(v2 + 72) = Menu_RetryMissionWrapped;
  *(_DWORD *)(v2 + 76) = 0;
  *(_DWORD *)(v2 + 80) = Menu_DontRetryMission;
  CachePlayerControls();
  v3 = (SelectScreen::MenuSelection *)operator new(0x10u);
  v3->_vptr$MenuSelection = (int (**)(void))&off_66280C;
  v3->tag = "FEM_NO";
  v3[1]._vptr$MenuSelection = (int (**)(void))YesNoScreen::NoFunc;
  v3[1].tag = 0;
  SelectScreen::AddItem((SelectScreen *)v2, v3);
  v4 = (SelectScreen::MenuSelection *)operator new(0x10u);
  v4->_vptr$MenuSelection = (int (**)(void))&off_66280C;
  v4->tag = "FEM_YES";
  v4[1]._vptr$MenuSelection = (int (**)(void))YesNoScreen::YesFunc;
  v4[1].tag = 0;
  SelectScreen::AddItem((SelectScreen *)v2, v4);
  if ( this->pendingScreen )
    MobileMenu::ProcessPending(this);
  this->pendingScreen = (MenuScreen *)v2;
}
// 66280C: using guessed type void *off_66280C;
// 662D9C: using guessed type void *;

//----- (0029B46C) --------------------------------------------------------
void __fastcall Menu_LoadFailedOK(void *data)
{
  MobileMenu::InitForSignedOut(&gMobileMenu);
}

//----- (0029B478) --------------------------------------------------------
void __fastcall MobileMenu::LoadFailed(MobileMenu *this)
{
  int v2; // r5
  SelectScreen::MenuSelection *v3; // r0

  this->InitializedForSignOut = 0;
  MobileMenu::Load(this);
  v2 = operator new(0x50u);
  CharSelectScreen::CharSelectScreen((CharSelectScreen *)v2, "FET_LG", 1);
  *(_DWORD *)v2 = &off_662DF8;
  *(_DWORD *)(v2 + 68) = "FES_LCE";
  *(_DWORD *)(v2 + 72) = Menu_LoadFailedOK;
  *(_DWORD *)(v2 + 76) = 0;
  v3 = (SelectScreen::MenuSelection *)operator new(0x10u);
  v3->_vptr$MenuSelection = (int (**)(void))&off_66280C;
  v3->tag = "FEM_OK";
  v3[1]._vptr$MenuSelection = (int (**)(void))OkScreen::OkFunc;
  v3[1].tag = 0;
  SelectScreen::AddItem((SelectScreen *)v2, v3);
  *(_BYTE *)(v2 + 12) = 0;
  if ( this->pendingScreen )
    MobileMenu::ProcessPending(this);
  this->pendingScreen = (MenuScreen *)v2;
}
// 66280C: using guessed type void *off_66280C;
// 662DF8: using guessed type void *off_662DF8;

//----- (0029B518) --------------------------------------------------------
void __fastcall MobileMenu::SaveFailed(MobileMenu *this)
{
  int v2; // r5
  SelectScreen::MenuSelection *v3; // r0

  this->InitializedForSignOut = 0;
  MobileMenu::Load(this);
  v2 = operator new(0x50u);
  CharSelectScreen::CharSelectScreen((CharSelectScreen *)v2, "FES_SVF", 1);
  *(_DWORD *)v2 = &off_662DF8;
  *(_DWORD *)(v2 + 68) = "FES_CMP";
  *(_DWORD *)(v2 + 72) = Menu_SaveFailedOK;
  *(_DWORD *)(v2 + 76) = 0;
  v3 = (SelectScreen::MenuSelection *)operator new(0x10u);
  v3->_vptr$MenuSelection = (int (**)(void))&off_66280C;
  v3->tag = "FEM_OK";
  v3[1]._vptr$MenuSelection = (int (**)(void))OkScreen::OkFunc;
  v3[1].tag = 0;
  SelectScreen::AddItem((SelectScreen *)v2, v3);
  if ( this->pendingScreen )
    MobileMenu::ProcessPending(this);
  this->pendingScreen = (MenuScreen *)v2;
}
// 66280C: using guessed type void *off_66280C;
// 662DF8: using guessed type void *;

//----- (0029B5B4) --------------------------------------------------------
void __fastcall Menu_RateGame(void *data)
{
  if ( CLocalisation::GermanGame() )
    sub_19EC64("com.rockstargames.gtasager");
  else
    sub_19EC64("com.rockstargames.gtasa");
}

//----- (0029B600) --------------------------------------------------------
void __fastcall MobileMenu::InitForNag(MobileMenu *this)
{
  int v2; // r5
  SelectScreen::MenuSelection *v3; // r0
  SelectScreen::MenuSelection *v4; // r0

  this->InitializedForSignOut = 0;
  if ( !OS_ServiceAppCommand("IsAmazonBuild", (const unsigned __int8 *)&byte_61CADE) )
  {
    MobileMenu::Load(this);
    v2 = operator new(0x54u);
    CharSelectScreen::CharSelectScreen((CharSelectScreen *)v2, "FEH_RTE", 0);
    *(_DWORD *)v2 = &off_662D9C;
    *(_DWORD *)(v2 + 68) = "SA_RATE";
    *(_DWORD *)(v2 + 72) = Menu_RateGame;
    *(_DWORD *)(v2 + 76) = 0;
    *(_DWORD *)(v2 + 80) = 0;
    CachePlayerControls();
    v3 = (SelectScreen::MenuSelection *)operator new(0x10u);
    v3->_vptr$MenuSelection = (int (**)(void))&off_66280C;
    v3->tag = "FEM_NO";
    v3[1]._vptr$MenuSelection = (int (**)(void))YesNoScreen::NoFunc;
    v3[1].tag = 0;
    SelectScreen::AddItem((SelectScreen *)v2, v3);
    v4 = (SelectScreen::MenuSelection *)operator new(0x10u);
    v4->_vptr$MenuSelection = (int (**)(void))&off_66280C;
    v4->tag = "FEM_YES";
    v4[1]._vptr$MenuSelection = (int (**)(void))YesNoScreen::YesFunc;
    v4[1].tag = 0;
    SelectScreen::AddItem((SelectScreen *)v2, v4);
    if ( this->pendingScreen )
      MobileMenu::ProcessPending(this);
    this->pendingScreen = (MenuScreen *)v2;
  }
}
// 61CADE: using guessed type char byte_61CADE;
// 66280C: using guessed type void *off_66280C;
// 662D9C: using guessed type void *off_662D9C;

//----- (0029B6EC) --------------------------------------------------------
void __fastcall SetVert(int i, float x, float y, float u, float v, const CRGBA *CRGBA)
{
  int v6; // r0
  RwIm2DVertex *v7; // r0

  v6 = i;
  maVertices[v6].x = x;
  v7 = &maVertices[v6];
  v7->y = y;
  v7->z = 1.0;
  v7->rhw = 1.0;
  v7->s = u;
  v7->t = v;
  *(CRGBA *)&v7->r = *CRGBA;
}

//----- (0029B73C) --------------------------------------------------------
void __fastcall OnSelectKey(SelectScreen *screen, int32 data)
{
  bInputDialogActive = 1;
}
// 6E01B0: using guessed type char bInputDialogActive;

//----- (0029B74C) --------------------------------------------------------
void __fastcall MobileMenu::~MobileMenu(MobileMenu *this)
{
  MenuScreen **dataPtr; // r0

  dataPtr = this->screenStack.dataPtr;
  this->screenStack.numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->screenStack.dataPtr = 0;
  }
  this->screenStack.numAlloced = 0;
}

//----- (0029B768) --------------------------------------------------------
void __fastcall DownloadScreen::DownloadScreen(DownloadScreen *this)
{
  int v1; // r4
  _DWORD *v2; // r0
  unsigned int *p_size; // r5
  int v4; // r0
  unsigned int v5; // r1
  bool v6; // zf
  unsigned int *v7; // r0
  int v8; // r1
  _DWORD *v9; // [sp+4h] [bp-6Ch]
  unsigned __int8 s[64]; // [sp+10h] [bp-60h] BYREF

  CharSelectScreen::CharSelectScreen(this, "MOB_DNL", 1);
  v1 = 0;
  v2[18] = 0;
  v9 = v2;
  *v2 = &off_662C5C;
  DownloadFileCount = 12;
  TotalDownloadSizeMB = 0;
  p_size = &AmazonDownloadFilenames[0].size;
  TotalDownloadPayloadMB = 0;
  TotalSizeDownloadedMB = 0;
  do
  {
    sprintf(s, "%s;%d", (const char *)*(p_size - 1), *p_size);
    ++v1;
    if ( OS_ServiceAppCommand("IsDownloaded", s) )
    {
      v4 = 1;
      *((_BYTE *)p_size + 4) = 1;
    }
    else
    {
      v4 = *((unsigned __int8 *)p_size + 4);
    }
    v5 = *p_size;
    p_size += 4;
    v6 = v4 == 0;
    v7 = &TotalSizeDownloadedMB;
    v8 = (v5 >> 20) + 1;
    TotalDownloadPayloadMB += v8;
    if ( v6 )
    {
      needsAmazonDownload = 1;
      v7 = &TotalDownloadSizeMB;
    }
    *v7 += v8;
  }
  while ( v1 < DownloadFileCount );
  v9[17] = 0;
}
// 29B7A4: variable 'v2' is possibly undefined
// 662C5C: using guessed type void *;

//----- (0029B8B0) --------------------------------------------------------
bool __fastcall MenuScreen::IsFlowScreen(MenuScreen *this)
{
  return 0;
}

//----- (0029B8B4) --------------------------------------------------------
bool __fastcall MenuScreen::IsPauseScreen(MenuScreen *this)
{
  return 0;
}

//----- (0029B8B8) --------------------------------------------------------
bool __fastcall MenuScreen::IsSaveLoadDeleteScreen(MenuScreen *this)
{
  return 0;
}

//----- (0029B8BC) --------------------------------------------------------
bool __fastcall MenuScreen::IsFlow(MenuScreen *this)
{
  return 0;
}

//----- (0029B8C0) --------------------------------------------------------
void __fastcall FlowScreen::FlowScreen(FlowScreen *this, bool withBack, bool isPauseScreen)
{
  RwTexture *Texture; // r0
  char pMessage; // r0
  RwTexture *v7; // r0
  int v8; // r0
  RwTexture *v9; // r0
  RwTexture *v10; // r0
  int v11; // r0
  RwTexture_0 *curCharTex; // r1
  unsigned __int8 s[256]; // [sp+4h] [bp-114h] BYREF

  this->hasBack = withBack;
  this->_vptr$MenuScreen = (int (**)(void))&off_662590;
  Texture = TextureDatabaseRuntime::GetTexture("menu_selector");
  ++Texture->refCount;
  this->_vptr$MenuScreen = (int (**)(void))&off_662600;
  this->arrowTex = Texture;
  this->opacity = 0.0;
  this->isPauseScreen = isPauseScreen;
  this->items.numAlloced = 0;
  this->items.numEntries = 0;
  this->items.dataPtr = 0;
  if ( !Menu_IsPlayingGame(1) || gMobileMenu.InitializedForSignOut )
  {
    v7 = TextureDatabaseRuntime::GetTexture("menu_mainpresents");
    ++v7->refCount;
    this->presentsTex = v7;
    this->hasBriefs = 0;
    v8 = rand();
    sprintf(s, "menu_main%d", v8 % 4 + 1);
    v9 = TextureDatabaseRuntime::GetTexture(s);
    ++v9->refCount;
    this->curCharTex = v9;
    this->newCharTex = 0;
    v10 = 0;
    do
    {
      if ( v10 )
      {
        RwTextureDestroy(v10);
        this->newCharTex = 0;
      }
      v11 = rand();
      sprintf(s, "menu_main%d", v11 % 4 + 1);
      v10 = TextureDatabaseRuntime::GetTexture(s);
      ++v10->refCount;
      curCharTex = this->curCharTex;
      this->newCharTex = v10;
    }
    while ( v10 == curCharTex );
    this->charCountdown = 5.0;
    this->panelFlip = rand() % 3;
  }
  else
  {
    this->presentsTex = 0;
    this->curCharTex = 0;
    this->newCharTex = 0;
    pMessage = (char)CMessages::PreviousBriefs[0].pMessage;
    if ( CMessages::PreviousBriefs[0].pMessage )
      pMessage = 1;
    this->hasBriefs = pMessage;
  }
  this->selectedItem = 0;
  this->curItemOffset = 0.0;
  this->selectOnScroll = 0;
}
// 662590: using guessed type void *off_662590;
// 662600: using guessed type void *;

//----- (0029BA44) --------------------------------------------------------
void __fastcall MainMenuScreen::AddAllItems(MainMenuScreen *this)
{
  RwTexture *Texture; // r5
  unsigned int numEntries; // r4
  unsigned int *p_numEntries; // r9
  OSArray<FlowScreen::MenuItem> *p_items; // r11
  unsigned int v6; // r10
  FlowScreen::MenuItem *v7; // r0
  FlowScreen::MenuItem *v8; // r11
  FlowScreen::MenuItem *dataPtr; // r6
  RwTexture *v10; // r5
  unsigned int v11; // r4
  unsigned int v12; // r10
  FlowScreen::MenuItem *v13; // r0
  FlowScreen::MenuItem *v14; // r11
  FlowScreen::MenuItem *v15; // r6
  FlowScreen::MenuItem *v16; // r1
  RwTexture *v17; // r5
  unsigned int v18; // r4
  unsigned int v19; // r0
  unsigned int v20; // r10
  FlowScreen::MenuItem *v21; // r0
  FlowScreen::MenuItem *v22; // r11
  FlowScreen::MenuItem *v23; // r6
  FlowScreen::MenuItem *v24; // r1
  RwTexture *v25; // r5
  unsigned int v26; // r4
  unsigned int v27; // r0
  unsigned int v28; // r10
  FlowScreen::MenuItem *v29; // r0
  FlowScreen::MenuItem *v30; // r11
  FlowScreen::MenuItem *v31; // r6
  FlowScreen::MenuItem *v32; // r3
  RwTexture *v33; // r5
  unsigned int v34; // r4
  unsigned int v35; // r0
  unsigned int v36; // r10
  FlowScreen::MenuItem *v37; // r0
  FlowScreen::MenuItem *v38; // r11
  FlowScreen::MenuItem *v39; // r6
  __int64 v40; // r0
  RwTexture *v41; // r5
  int v42; // r4
  unsigned int v43; // r0
  unsigned int v44; // r10
  FlowScreen::MenuItem *v45; // r0
  FlowScreen::MenuItem *v46; // r11
  FlowScreen::MenuItem *v47; // r6
  int v48; // r1
  const char *v49; // r2
  void **v50; // r0
  FlowScreen::MenuItem *v51; // r1
  RwTexture *v52; // r5
  unsigned int v53; // r4
  unsigned int v54; // r0
  unsigned int v55; // r10
  FlowScreen::MenuItem *v56; // r0
  FlowScreen::MenuItem *v57; // r11
  FlowScreen::MenuItem *v58; // r6
  FlowScreen::MenuItem *v59; // r1
  RwTexture *v60; // r5
  int v61; // r4
  unsigned int v62; // r0
  unsigned int v63; // r10
  FlowScreen::MenuItem *v64; // r0
  FlowScreen::MenuItem *v65; // r11
  FlowScreen::MenuItem *v66; // r1
  RwTexture *v67; // r5
  unsigned int v68; // r4
  unsigned int v69; // r0
  unsigned int v70; // r11
  FlowScreen::MenuItem *v71; // r0
  FlowScreen::MenuItem *v72; // r10
  FlowScreen::MenuItem *v73; // r6
  FlowScreen::MenuItem *v74; // r1
  OSArray<FlowScreen::MenuItem> *v75; // [sp+0h] [bp-20h]

  if ( this->isPauseScreen )
  {
    Texture = TextureDatabaseRuntime::GetTexture("menu_mainresume");
    ++Texture->refCount;
    p_numEntries = &this->items.numEntries;
    numEntries = this->items.numEntries;
    p_items = &this->items;
    if ( this->items.numAlloced >= numEntries + 1 )
    {
      dataPtr = this->items.dataPtr;
    }
    else
    {
      v6 = 4 * (numEntries + 1) / 3 + 3;
      v7 = (FlowScreen::MenuItem *)malloc(12 * v6);
      v8 = this->items.dataPtr;
      dataPtr = v7;
      if ( v8 )
      {
        qmemcpy(v7, this->items.dataPtr, 12 * numEntries);
        free(v8);
        numEntries = *p_numEntries;
      }
      p_items = &this->items;
      this->items.dataPtr = dataPtr;
      this->items.numAlloced = v6;
    }
    dataPtr[numEntries].itemTex = Texture;
    v16 = &dataPtr[numEntries];
    v16->text = "FEP_RES";
    v16->selected = MainMenuScreen::OnResume;
    ++*p_numEntries;
    v17 = TextureDatabaseRuntime::GetTexture("menu_mainsettings");
    ++v17->refCount;
    v18 = *p_numEntries;
    v19 = *p_numEntries + 1;
    if ( p_items->numAlloced >= v19 )
    {
      v23 = this->items.dataPtr;
    }
    else
    {
      v20 = 4 * v19 / 3 + 3;
      v21 = (FlowScreen::MenuItem *)malloc(12 * v20);
      v22 = this->items.dataPtr;
      v23 = v21;
      if ( v22 )
      {
        qmemcpy(v21, this->items.dataPtr, 12 * v18);
        free(v22);
        v18 = *p_numEntries;
      }
      p_items = &this->items;
      this->items.dataPtr = v23;
      this->items.numAlloced = v20;
    }
    v23[v18].itemTex = v17;
    v24 = &v23[v18];
    v24->text = "FEP_OPT";
    v24->selected = MainMenuScreen::OnSettings;
    ++*p_numEntries;
    v25 = TextureDatabaseRuntime::GetTexture("menu_mainstats");
    ++v25->refCount;
    v26 = *p_numEntries;
    v27 = *p_numEntries + 1;
    if ( p_items->numAlloced >= v27 )
    {
      v31 = this->items.dataPtr;
    }
    else
    {
      v28 = 4 * v27 / 3 + 3;
      v29 = (FlowScreen::MenuItem *)malloc(12 * v28);
      v30 = this->items.dataPtr;
      v31 = v29;
      if ( v30 )
      {
        qmemcpy(v29, this->items.dataPtr, 12 * v26);
        free(v30);
        v26 = *p_numEntries;
      }
      p_items = &this->items;
      this->items.dataPtr = v31;
      this->items.numAlloced = v28;
    }
    v31[v26].itemTex = v25;
    v32 = &v31[v26];
    v32->text = "FEH_STA";
    v32->selected = FlowScreen::OnStats;
    ++*p_numEntries;
    if ( CMessages::PreviousBriefs[0].pMessage )
    {
      v33 = TextureDatabaseRuntime::GetTexture("menu_mainbriefs");
      ++v33->refCount;
      v34 = *p_numEntries;
      v35 = *p_numEntries + 1;
      if ( p_items->numAlloced >= v35 )
      {
        v39 = this->items.dataPtr;
      }
      else
      {
        v36 = 4 * v35 / 3 + 3;
        v37 = (FlowScreen::MenuItem *)malloc(12 * v36);
        v38 = this->items.dataPtr;
        v39 = v37;
        if ( v38 )
        {
          qmemcpy(v37, this->items.dataPtr, 12 * v34);
          free(v38);
          v34 = *p_numEntries;
        }
        p_items = &this->items;
        this->items.dataPtr = v39;
        this->items.numAlloced = v36;
      }
      v39[v34].itemTex = v33;
      HIDWORD(v40) = FlowScreen::OnBriefs;
      LODWORD(v40) = "FEH_BRI";
      *(_QWORD *)&v39[v34].text = v40;
      ++*p_numEntries;
    }
    v41 = TextureDatabaseRuntime::GetTexture("menu_mainplay");
    ++v41->refCount;
    v42 = *p_numEntries;
    v43 = *p_numEntries + 1;
    if ( p_items->numAlloced >= v43 )
    {
      v47 = this->items.dataPtr;
    }
    else
    {
      v44 = 4 * v43 / 3 + 3;
      v45 = (FlowScreen::MenuItem *)malloc(12 * v44);
      v46 = this->items.dataPtr;
      v47 = v45;
      if ( v46 )
      {
        qmemcpy(v45, this->items.dataPtr, 12 * v42);
        free(v46);
        v42 = *p_numEntries;
      }
      p_items = &this->items;
      this->items.dataPtr = v47;
      this->items.numAlloced = v44;
    }
    v48 = v42;
    v49 = "FEP_STG";
    v47[v42].itemTex = v41;
    v50 = &MainMenuScreen::OnStartGame;
  }
  else
  {
    if ( MainMenuScreen::HasCPSave(this) )
    {
      v10 = TextureDatabaseRuntime::GetTexture("menu_mainresume");
      ++v10->refCount;
      p_numEntries = &this->items.numEntries;
      v11 = this->items.numEntries;
      p_items = &this->items;
      if ( this->items.numAlloced >= v11 + 1 )
      {
        v15 = this->items.dataPtr;
      }
      else
      {
        v12 = 4 * (v11 + 1) / 3 + 3;
        v13 = (FlowScreen::MenuItem *)malloc(12 * v12);
        v14 = this->items.dataPtr;
        v15 = v13;
        if ( v14 )
        {
          qmemcpy(v13, this->items.dataPtr, 12 * v11);
          free(v14);
          v11 = *p_numEntries;
        }
        this->items.dataPtr = v15;
        this->items.numAlloced = v12;
        p_items = &this->items;
      }
      v15[v11].itemTex = v10;
      v51 = &v15[v11];
      v51->text = "FEP_RES";
      v51->selected = MainMenuScreen::OnResume;
      ++*p_numEntries;
    }
    else
    {
      p_items = &this->items;
      p_numEntries = &this->items.numEntries;
    }
    v52 = TextureDatabaseRuntime::GetTexture("menu_mainplay");
    ++v52->refCount;
    v53 = *p_numEntries;
    v54 = *p_numEntries + 1;
    v75 = p_items;
    if ( p_items->numAlloced >= v54 )
    {
      v58 = this->items.dataPtr;
    }
    else
    {
      v55 = 4 * v54 / 3 + 3;
      v56 = (FlowScreen::MenuItem *)malloc(12 * v55);
      v57 = this->items.dataPtr;
      v58 = v56;
      if ( v57 )
      {
        qmemcpy(v56, this->items.dataPtr, 12 * v53);
        free(v57);
        v53 = *p_numEntries;
      }
      p_items = v75;
      this->items.dataPtr = v58;
      this->items.numAlloced = v55;
    }
    v58[v53].itemTex = v52;
    v59 = &v58[v53];
    v59->text = "FEP_STG";
    v59->selected = MainMenuScreen::OnStartGame;
    ++*p_numEntries;
    v60 = TextureDatabaseRuntime::GetTexture("menu_mainsettings");
    ++v60->refCount;
    v61 = *p_numEntries;
    v62 = *p_numEntries + 1;
    if ( p_items->numAlloced >= v62 )
    {
      v47 = this->items.dataPtr;
    }
    else
    {
      v63 = 4 * v62 / 3 + 3;
      v64 = (FlowScreen::MenuItem *)malloc(12 * v63);
      v65 = this->items.dataPtr;
      v47 = v64;
      if ( v65 )
      {
        qmemcpy(v64, this->items.dataPtr, 12 * v61);
        free(v65);
        v61 = *p_numEntries;
      }
      p_items = v75;
      this->items.dataPtr = v47;
      this->items.numAlloced = v63;
    }
    v48 = v61;
    v49 = "FEP_OPT";
    v47[v61].itemTex = v60;
    v50 = &MainMenuScreen::OnSettings;
  }
  v66 = &v47[v48];
  v66->text = (const unsigned __int8 *)v49;
  v66->selected = (void (*)(void))*v50;
  ++*p_numEntries;
  v67 = TextureDatabaseRuntime::GetTexture("menu_mainquit");
  ++v67->refCount;
  v68 = *p_numEntries;
  v69 = *p_numEntries + 1;
  if ( p_items->numAlloced >= v69 )
  {
    v73 = this->items.dataPtr;
  }
  else
  {
    v70 = 4 * v69 / 3 + 3;
    v71 = (FlowScreen::MenuItem *)malloc(12 * v70);
    v72 = this->items.dataPtr;
    v73 = v71;
    if ( v72 )
    {
      qmemcpy(v71, this->items.dataPtr, 12 * v68);
      free(v72);
      v68 = *p_numEntries;
    }
    this->items.dataPtr = v73;
    this->items.numAlloced = v70;
  }
  v73[v68].itemTex = v67;
  v74 = &v73[v68];
  v74->text = "FEP_QUI";
  v74->selected = MainMenuScreen::OnExit;
  ++*p_numEntries;
}
// 676804: using guessed type void *MainMenuScreen::OnStartGame;
// 67791C: using guessed type void *MainMenuScreen::OnSettings;

//----- (0029C05C) --------------------------------------------------------
void __fastcall MainMenuScreen::~MainMenuScreen(MainMenuScreen *this)
{
  void *v1; // r0

  FlowScreen::~FlowScreen(this);
  sub_191374(v1);
}
// 29C068: variable 'v1' is possibly undefined

//----- (0029C06C) --------------------------------------------------------
void __fastcall MainMenuScreen::Update(MainMenuScreen *this, float deltaTime)
{
  if ( this->isPauseScreen || LIB_KeyboardState(KK_ESCAPE) != OSPS_ButtonDown )
    sub_18B8A0(this, deltaTime);
  else
    RsGlobal.quit = 1;
}

//----- (0029C0A0) --------------------------------------------------------
void __fastcall FlowScreen::Render(FlowScreen *this, int stackPos)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d2
  float32x2_t v5; // d3
  float32x2_t v6; // d8
  float32x2_t v7; // d10
  float32x2_t v8; // d11
  FlowScreen *v9; // r9
  RwTexture_0 *presentsTex; // r6
  float32x4_t v11; // q2
  float32x4_t v12; // q9
  float *v13; // r5
  int v14; // r11
  int64x2_t v16; // q9
  int64x2_t v21; // q8
  float v22; // s6
  float v23; // s8
  float v24; // s0
  float v25; // s4
  float v26; // s2
  float v27; // s19
  float v28; // s25
  float v29; // s27
  float v30; // s31
  int32x4_t v31; // q8
  int32x4_t v32; // q8
  _BOOL4 IsPlayingGame; // r0
  float screenHeight; // s16
  float screenWidth; // s18
  GxtChar *v37; // r0
  CSprite2d *HelpSprite; // r0
  RwTexture_0 *mpTexture; // r5
  float v40; // s20
  int v41; // r6
  unsigned int v42; // r10
  float v43; // s18
  float32x2_t v44; // d0
  float32x2_t v45; // d0
  float v46; // s16
  float v47; // r8
  float v48; // r9
  float v49; // r11
  float v50; // r6
  float v51; // s16
  float v52; // r5
  float v53; // s20
  float v54; // r4
  float v55; // r0
  float v56; // s16
  float v57; // s26
  float v58; // s22
  float v59; // s28
  float v60; // s23
  float v61; // s22
  float v62; // s20
  float v63; // s29
  float v64; // s26
  float v65; // s30
  float v66; // s24
  float v67; // s21
  float v68; // s29
  float v69; // s2
  float v70; // s0
  float v71; // s2
  float v72; // s31
  float v73; // s26
  float v74; // s0
  float v75; // s0
  float v76; // s4
  RwTexture_0 *v77; // r1
  float v78; // s0
  float v79; // s2
  float v80; // s16
  float v81; // s2
  float v82; // s16
  float v83; // s0
  const unsigned __int8 *v84; // r4
  GxtChar *v85; // r0
  _BOOL4 v86; // r0
  bool v87; // zf
  float opacity; // r8
  float v89; // s4
  float v90; // s0
  float v91; // s2
  float statsStart; // s22
  float briefsEnd; // s24
  float v94; // s26
  float v95; // s28
  RwInt32 v96; // r4
  GxtChar *v97; // r2
  float v98; // r0
  RwInt32 v99; // r4
  float v100; // s24
  float v101; // s26
  float v102; // s0
  float v103; // s22
  float v104; // s22
  GxtChar *v105; // r2
  CSprite2d *v106; // r0
  RwTexture_0 *v107; // r5
  RwInt32 v108; // r4
  CVector2D var184; // [sp+4h] [bp-184h]
  CVector2D v110; // [sp+4h] [bp-184h]
  CVector2D var184b; // [sp+4h] [bp-184h]
  CVector2D ignoreOpacity; // [sp+Ch] [bp-17Ch]
  CVector2D ignoreOpacitya; // [sp+Ch] [bp-17Ch]
  CVector2D ignoreOpacityb; // [sp+Ch] [bp-17Ch]
  CVector2D ignoreOpacityc; // [sp+Ch] [bp-17Ch]
  int v116; // [sp+3Ch] [bp-14Ch]
  unsigned __int64 v117; // [sp+40h] [bp-148h]
  float v120; // [sp+58h] [bp-130h]
  float v121; // [sp+58h] [bp-130h]
  CRGBA v122; // [sp+5Ch] [bp-12Ch] BYREF
  CRGBA v123; // [sp+60h] [bp-128h] BYREF
  CRGBA v124; // [sp+64h] [bp-124h] BYREF
  CRGBA v125; // [sp+68h] [bp-120h] BYREF
  CRGBA v126; // [sp+6Ch] [bp-11Ch] BYREF
  CRGBA v127; // [sp+70h] [bp-118h] BYREF
  float v128; // [sp+74h] [bp-114h] BYREF
  CRGBA v129; // [sp+78h] [bp-110h] BYREF
  CRGBA v130; // [sp+7Ch] [bp-10Ch] BYREF
  CVector2D uvs; // [sp+80h] [bp-108h] BYREF
  float v132; // [sp+88h] [bp-100h]
  int v133; // [sp+8Ch] [bp-FCh]
  float v134; // [sp+90h] [bp-F8h]
  int v135; // [sp+94h] [bp-F4h]
  float v136; // [sp+98h] [bp-F0h]
  int v137; // [sp+9Ch] [bp-ECh]
  CVector2D coords; // [sp+A0h] [bp-E8h] BYREF
  float x; // [sp+A8h] [bp-E0h] BYREF
  CRGBA v140; // [sp+ACh] [bp-DCh] BYREF
  float v141; // [sp+B0h] [bp-D8h]
  int v142; // [sp+B4h] [bp-D4h]
  float v143; // [sp+B8h] [bp-D0h]
  int v144; // [sp+BCh] [bp-CCh]
  CVector2D v145; // [sp+C0h] [bp-C8h] BYREF
  __int64 v146; // [sp+C8h] [bp-C0h]
  CRGBA v147; // [sp+D8h] [bp-B0h] BYREF
  CVector2D v148; // [sp+DCh] [bp-ACh] BYREF
  unsigned __int64 v149; // [sp+E4h] [bp-A4h] BYREF
  float v150; // [sp+ECh] [bp-9Ch]
  float v151; // [sp+F0h] [bp-98h]
  float v152; // [sp+F4h] [bp-94h]
  float v153; // [sp+F8h] [bp-90h]
  int v154; // [sp+FCh] [bp-8Ch]
  int v155; // [sp+100h] [bp-88h]
  int v156; // [sp+104h] [bp-84h]
  unsigned __int32 v157; // [sp+108h] [bp-80h]
  unsigned __int32 v158; // [sp+10Ch] [bp-7Ch]
  int v159; // [sp+110h] [bp-78h]
  float v160; // [sp+114h] [bp-74h]
  float v161; // [sp+118h] [bp-70h]
  int v162; // [sp+11Ch] [bp-6Ch]
  unsigned __int32 v163; // [sp+120h] [bp-68h]
  CRGBA v164; // [sp+124h] [bp-64h] BYREF
  CVector2D cvector2d; // 0:r3.4,4:^0.4
  CVector2D cvector2da; // 0:r3.4,4:^0.4
  CVector2D v167; // 0:r3.4,4:^0.4
  CVector2D v168; // 0:r3.4,4:^0.4

  v9 = this;
  if ( !Menu_IsPlayingGame(1) || gMobileMenu.InitializedForSignOut )
  {
    presentsTex = v9->presentsTex;
    CRGBA::CRGBA(&v164, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
    cvector2d.y = 7.0;
    cvector2d.x = 230.0;
    MenuScreen::DrawSprite(
      (MenuScreen *)v9,
      presentsTex,
      (CRGBA)&v164,
      cvector2d,
      (CVector2D)0x4198000043CD0000LL,
      stackPos > 0);
    v11.n128_u32[0] = LODWORD(v9->charCountdown);
    v7.n64_u32[0] = 1.0;
    v12.n128_f32[0] = 1.0;
    v12.n128_f32[1] = 1.0;
    v12.n128_f32[2] = 1.0;
    v12.n128_f32[3] = 1.0;
    v11.n128_f32[3] = v11.n128_f32[0] + -0.375;
    v13 = (float *)&unk_60C960;
    v11.n128_f32[2] = v11.n128_f32[0] + -0.25;
    v11.n128_f32[1] = v11.n128_f32[0] + -0.125;
    v6.n64_u32[1] = 1142947840;
    v14 = 0;
    _Q8 = vaddq_f32(v11, v11);
    v4.n64_f32[0] = (float)(v11.n128_f32[0] + -0.625) + (float)(v11.n128_f32[0] + -0.625);
    v5.n64_f32[0] = (float)(v11.n128_f32[0] + -0.5) + (float)(v11.n128_f32[0] + -0.5);
    v16 = vminq_f32(_Q8, v12);
    __asm { VCLT.F32        Q8, Q8, #0.0 }
    v3.n64_u64[0] = vmin_f32(v4, v7).n64_u64[0];
    v21 = vbicq_s64(v16, _Q8);
    v2.n64_u64[0] = vmin_f32(v5, v7).n64_u64[0];
    if ( v4.n64_f32[0] < 0.0 )
      v3.n64_u32[0] = 0;
    if ( v5.n64_f32[0] < 0.0 )
      v2.n64_u32[0] = 0;
    v154 = v21.n128_i32[3];
    v155 = v21.n128_i32[2];
    v156 = v21.n128_i32[1];
    v157 = v21.n128_u32[0];
    v148 = (CVector2D)v21.n128_u64[0];
    v149 = v21.n128_u64[1];
    v150 = v2.n64_f32[0];
    v158 = v21.n128_u32[0];
    v159 = v21.n128_i32[2];
    v162 = v21.n128_i32[2];
    v163 = v21.n128_u32[0];
    v151 = v3.n64_f32[0];
    v152 = v3.n64_f32[0];
    v153 = v2.n64_f32[0];
    v160 = v2.n64_f32[0];
    v161 = v2.n64_f32[0];
    do
    {
      v22 = 1.0;
      v23 = 1.0;
      v8.n64_u32[1] = 1.0;
      v24 = *(float *)((char *)&v148.x + 24 * this->panelFlip + v14);
      v25 = (float)(v24 * 4.0) + -0.5;
      if ( v25 < 1.0 )
        v22 = (float)(v24 * 4.0) + -0.5;
      if ( v22 <= 0.0 )
        v23 = 0.0;
      v26 = v23;
      if ( v25 < 1.0 )
        v26 = (float)(v24 * 4.0) + -0.5;
      if ( v22 <= 0.0 )
        v26 = v23;
      if ( v24 > 0.25 )
        v8.n64_f32[1] = 1.0 - (float)((float)(v24 / 0.8) + -0.25);
      CRGBA::CRGBA(&v147, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)(v26 * 255.0));
      v27 = *(v13 - 2);
      v28 = *(v13 - 1);
      v29 = *v13;
      v30 = v13[1];
      uvs.y = 0.0;
      uvs.x = v27;
      v31 = vdupq_n_s32(*(_DWORD *)&v147);
      coords.y = 0.0;
      v132 = v28;
      v133 = 0;
      v134 = v29;
      v135 = 1065353216;
      v136 = v30;
      v145 = (CVector2D)v31.n128_u64[0];
      v146 = v31.n128_i64[1];
      v137 = 1065353216;
      coords.x = (float)(v27 * 640.0) + 0.0;
      v140 = 0;
      x = (float)(v28 * 640.0) + 0.0;
      v142 = 1135869952;
      v141 = (float)(v29 * 640.0) + 0.0;
      v144 = 1135869952;
      v143 = (float)(v30 * 640.0) + 0.0;
      if ( *(unsigned int *)&v147 >= 0x1000000 )
        MenuScreen::DrawSprite((MenuScreen *)this, this->curCharTex, &coords, &uvs, (CRGBA *)&v145, stackPos > 0);
      CRGBA::CRGBA(&v147, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)(v8.n64_f32[1] * 255.0));
      coords.y = 0.0;
      coords.x = (float)(v27 * 640.0) + 0.0;
      v32 = vdupq_n_s32(*(_DWORD *)&v147);
      uvs.y = 0.0;
      x = (float)(v28 * 640.0) + 0.0;
      v140 = 0;
      v141 = (float)(v29 * 640.0) + 0.0;
      v142 = 1135869952;
      v143 = (float)(v30 * 640.0) + 0.0;
      uvs.x = v27;
      v132 = v28;
      v133 = 0;
      v134 = v29;
      v135 = 1065353216;
      v136 = v30;
      v145 = (CVector2D)v32.n128_u64[0];
      v146 = v32.n128_i64[1];
      v144 = 1135869952;
      v137 = 1065353216;
      if ( *(unsigned int *)&v147 >= 0x1000000 )
        MenuScreen::DrawSprite((MenuScreen *)this, this->newCharTex, &coords, &uvs, (CRGBA *)&v145, stackPos > 0);
      v14 += 4;
      v13 += 4;
    }
    while ( v14 != 24 );
    v9 = this;
  }
  IsPlayingGame = Menu_IsPlayingGame(1);
  _ZF = gMobileMenu.screenStack.numEntries == 1;
  if ( gMobileMenu.screenStack.numEntries == 1 )
    _ZF = !IsPlayingGame;
  if ( _ZF && CHID::Implements(HID_MAPPING_MENU_ACCEPT) && CHID::GetInputType() == 1 )
  {
    screenHeight = (float)RsGlobal.screenHeight;
    screenWidth = (float)RsGlobal.screenWidth;
    CRGBA::CRGBA(&v130, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
    v3.n64_u32[0] = 12.5;
    v2.n64_f32[0] = screenWidth * 0.0;
    v2.n64_u64[0] = vmax_f32(v2, v3).n64_u64[0];
    v37 = CText::Get(&TheText, "FEH_SEL");
    LODWORD(coords.x) = v130;
    ignoreOpacity.y = 431.0;
    ignoreOpacity.x = (float)((float)((float)((float)((float)(screenWidth - v2.n64_f32[0]) * 480.0)
                                            + (float)(screenWidth * -240.0))
                                    / screenHeight)
                            + 320.0)
                    + -120.0;
    MenuScreen::DrawTextDirect(
      &v148,
      (MenuScreen *)v9,
      v37,
      TA_Right,
      0,
      (CRGBA)&coords,
      1,
      ignoreOpacity,
      (CVector2D)0x41D8000042F00000LL,
      0,
      0);
    coords.x = 0.0;
    coords.y = 0.0;
    uvs.x = 1.0;
    uvs.y = 1.0;
    HelpSprite = CHID::GetHelpSprite(0, HID_MAPPING_MENU_ACCEPT, &coords, &uvs);
    if ( HelpSprite )
    {
      mpTexture = HelpSprite->mpTexture;
      CRGBA::CRGBA(&v129, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
      var184.y = 456.0;
      cvector2da.y = 436.0;
      cvector2da.x = v148.x + -25.0;
      var184.x = v148.x + -5.0;
      MenuScreen::DrawSprite((MenuScreen *)v9, mpTexture, (CRGBA)&v129, cvector2da, var184, coords, uvs);
    }
  }
  if ( v9->items.numEntries )
  {
    v40 = 0.5;
    v41 = 0;
    v42 = 0;
    do
    {
      v116 = v41;
      v8.n64_u32[0] = 2.0;
      v43 = (float)(int)v42 - v9->curItemOffset;
      v6.n64_f32[0] = fabsf(v43);
      v44.n64_u64[0] = vmin_f32(v6, v8).n64_u64[0];
      v117 = v44.n64_u64[0];
      CRGBA::CRGBA((CRGBA *)&uvs, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)((float)(v44.n64_f32[0] * -127.0) + 254.0));
      v44.n64_u32[0] = 1.0;
      v45.n64_u64[0] = vmin_f32(v6, v44).n64_u64[0];
      v45.n64_f32[0] = v40 - (float)((float)((float)(v45.n64_f32[0] * 0.8) + 0.025) * 0.1);
      v46 = v43 + (float)(v43 * 0.1);
      v3.n64_f32[0] = v46 - v45.n64_f32[0];
      v45.n64_f32[0] = v46 + v45.n64_f32[0];
      v47 = sinf(v3.n64_f32[0] * 0.12);
      v48 = cosf(v3.n64_f32[0] * 0.12);
      v120 = sinf(v45.n64_f32[0] * 0.12);
      v49 = cosf(v45.n64_f32[0] * 0.12);
      v50 = (float)(v46 + -0.45) * 0.12;
      v51 = (float)(v46 + 0.45) * 0.12;
      v52 = sinf(v50);
      v53 = cosf(v50);
      v54 = sinf(v51);
      v55 = cosf(v51);
      v45.n64_f32[0] = fabsf(v43 + 0.4);
      v3.n64_f32[0] = fabsf(v43 + -0.4);
      LODWORD(v56) = vmin_f32(v45, v8).n64_u32[0];
      v2.n64_u64[0] = vmin_f32(v3, v8).n64_u64[0];
      v57 = (float)(v55 * 1050.0) + -700.0;
      v58 = v48;
      v9 = this;
      if ( v42 == this->selectedItem )
        CRGBA::CRGBA((CRGBA *)&v145, 0xF0u, 0xF0u, 0xF0u, 0xFFu);
      else
        CRGBA::CRGBA(
          (CRGBA *)&v145,
          0xB4u,
          0xB4u,
          0xB4u,
          (unsigned int)(float)((float)(v2.n64_f32[0] * -127.0) + 254.0));
      v59 = (float)((float)(v53 * 1050.0) + -700.0) + (float)(v2.n64_f32[0] * 5.0);
      v60 = v58 * 1130.0;
      v61 = (float)(v52 * 1050.0) + 320.0;
      v62 = (float)(v56 * 5.0) + v57;
      v63 = v120;
      v121 = (float)(v54 * 1050.0) + 320.0;
      if ( v42 == this->selectedItem )
        CRGBA::CRGBA(&v147, 0xF0u, 0xF0u, 0xF0u, 0xFFu);
      else
        CRGBA::CRGBA(&v147, 0xB4u, 0xB4u, 0xB4u, (unsigned int)(float)((float)(v56 * -127.0) + 254.0));
      v64 = v63 * 1130.0;
      v65 = v60 + -700.0;
      v66 = (float)(v47 * 1130.0) + 320.0;
      coords.x = v145.x;
      x = v145.x;
      LODWORD(coords.y) = v147;
      v140 = v147;
      v148.y = v59 + -1.7;
      v148.x = v61 + -1.7;
      *(float *)&v149 = v121 + 1.7;
      *((float *)&v149 + 1) = v62 + -1.7;
      v150 = v61 + -1.7;
      v151 = v59 + 1.7;
      v152 = v121 + 1.7;
      v153 = v62 + 1.7;
      FlowScreen::DrawFeatheredQuad(this, &v148, (CRGBA *)&coords);
      coords.x = v145.x;
      coords.y = v145.x;
      CRGBA::CRGBA((CRGBA *)&x, 0, 0, 0, 0);
      CRGBA::CRGBA(&v140, 0, 0, 0, 0);
      v67 = v62 - v59;
      v68 = v121 - v61;
      v6.n64_f32[1] = (float)(v68 * v68) + (float)(v67 * v67);
      v69 = 1.0;
      v70 = v62 - v59;
      if ( v6.n64_f32[1] > 0.0 )
      {
        v71 = 1.0 / sqrtf(v6.n64_f32[1]);
        v70 = v67 * v71;
        v69 = v68 * v71;
      }
      v72 = (float)(v49 * 1130.0) + -700.0;
      v148.y = v59 + 1.7;
      v148.x = v61 + -1.7;
      v73 = v64 + 320.0;
      v150 = v66 + -1.7;
      v151 = v65 + 1.7;
      v152 = v66 + 1.7;
      v153 = v65 + 1.7;
      *(float *)&v149 = (float)(v61 + -1.7) + (float)((float)(v69 * 1.7) + (float)(v69 * 1.7));
      *((float *)&v149 + 1) = (float)(v59 + 1.7) + (float)((float)(v70 * 1.7) + (float)(v70 * 1.7));
      FlowScreen::DrawFeatheredQuad(this, &v148, (CRGBA *)&coords);
      LODWORD(coords.x) = v147;
      LODWORD(coords.y) = v147;
      CRGBA::CRGBA((CRGBA *)&x, 0, 0, 0, 0);
      CRGBA::CRGBA(&v140, 0, 0, 0, 0);
      if ( v6.n64_f32[1] <= 0.0 )
      {
        v75 = 1.0;
      }
      else
      {
        v74 = 1.0 / sqrtf(v6.n64_f32[1]);
        v67 = v67 * v74;
        v75 = v68 * v74;
      }
      *(float *)&v149 = v121 + 1.7;
      *((float *)&v149 + 1) = v62 + 1.7;
      v150 = v73 + -1.7;
      v151 = v72 + 1.7;
      v152 = v73 + 1.7;
      v153 = v72 + 1.7;
      v148.y = (float)(v62 + 1.7) - (float)((float)(v67 * 1.7) + (float)(v67 * 1.7));
      v148.x = (float)(v121 + 1.7) - (float)((float)(v75 * 1.7) + (float)(v75 * 1.7));
      FlowScreen::DrawFeatheredQuad(this, &v148, (CRGBA *)&coords);
      v76 = 18.0;
      if ( v42 == this->selectedItem )
        v76 = 21.0;
      v77 = *(RwTexture_0 **)((char *)&this->items.dataPtr->itemTex + v116);
      v128 = uvs.x;
      v78 = (float)((float)((float)(v61 + v121) + v66) + v73) * 0.25;
      v79 = (float)((float)((float)(v59 + v62) + v65) + v72) * 0.25;
      v167.x = v78 - v76;
      v167.y = v79 - v76;
      v110.x = v78 + v76;
      v110.y = v79 + v76;
      MenuScreen::DrawSprite((MenuScreen *)this, v77, (CRGBA)&v128, v167, v110, 0);
      v40 = 0.5;
      v8.n64_u32[1] = HIDWORD(v117);
      if ( *(float *)&v117 < 0.5 )
      {
        CFont::SetScale((float)((float)RsGlobal.screenHeight * 1.35) / 480.0);
        v80 = (float)RsGlobal.screenHeight + (float)((float)RsGlobal.screenHeight * -0.0);
        v81 = (float)((float)(v80 - CFont::GetHeight(0)) * 480.0) / (float)RsGlobal.screenHeight;
        v82 = 438.0;
        if ( v81 < 438.0 )
        {
          CFont::SetScale((float)((float)RsGlobal.screenHeight * 1.35) / 480.0);
          v83 = (float)RsGlobal.screenHeight;
          v82 = (float)((float)((float)(v83 + (float)(v83 * -0.0)) - CFont::GetHeight(0)) * 480.0)
              / (float)RsGlobal.screenHeight;
        }
        v84 = *(const unsigned __int8 **)((char *)&this->items.dataPtr->text + v116);
        CRGBA::CRGBA(
          &v127,
          0xF0u,
          0xF0u,
          0xF0u,
          (unsigned int)(float)((float)((float)((float)(*(float *)&v117 * -2.0) + 1.0)
                                      * (float)((float)(*(float *)&v117 * -2.0) + 1.0))
                              * 255.0));
        v85 = CText::Get(&TheText, v84);
        LODWORD(coords.x) = v127;
        ignoreOpacitya.y = v82;
        ignoreOpacitya.x = 0.0;
        MenuScreen::DrawTextDirect(
          &v148,
          (MenuScreen *)this,
          v85,
          TA_Center,
          0,
          (CRGBA)&coords,
          0,
          ignoreOpacitya,
          (CVector2D)0x41D8000044200000LL,
          0,
          0);
      }
      ++v42;
      v41 = v116 + 12;
    }
    while ( v42 < this->items.numEntries );
  }
  v86 = Menu_IsPlayingGame(1);
  v87 = !gMobileMenu.InitializedForSignOut;
  if ( !gMobileMenu.InitializedForSignOut )
    v87 = !v86;
  if ( !v87 )
  {
    opacity = v9->opacity;
    v9->opacity = 1.0 - mapModeOpacity;
    v89 = (float)RsGlobal.screenWidth * 240.0;
    v90 = (float)((float)((float)((float)RsGlobal.screenWidth * 480.0) - v89) / (float)RsGlobal.screenHeight) + 320.0;
    v9->statsStart = (float)((float)(0.0 - v89) / (float)RsGlobal.screenHeight) + 320.0;
    v9->briefsEnd = v90;
    CRGBA::CRGBA((CRGBA *)&v148, 0, 0, 0, 0x80u);
    CRGBA::CRGBA((CRGBA *)&v148.y, 0, 0, 0, 0x80u);
    CRGBA::CRGBA((CRGBA *)&v149, 0, 0, 0, 0);
    CRGBA::CRGBA((CRGBA *)&v149 + 1, 0, 0, 0, 0);
    v91 = this->opacity;
    statsStart = this->statsStart;
    briefsEnd = this->briefsEnd;
    HIBYTE(v148.x) = (unsigned int)(float)(v91 * (float)HIBYTE(v148.x));
    v94 = (float)RsGlobal.screenWidth;
    v95 = (float)RsGlobal.screenHeight;
    HIBYTE(v148.y) = (unsigned int)(float)(v91 * (float)HIBYTE(v148.y));
    BYTE3(v149) = (unsigned int)(float)(v91 * (float)BYTE3(v149));
    HIBYTE(v149) = (unsigned int)(float)(v91 * (float)HIBYTE(v149));
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
    *(float *)&maVertices[0].r = v148.x;
    maVertices[0].z = 1.0;
    maVertices[0].rhw = 1.0;
    maVertices[0].s = 0.0;
    maVertices[0].t = 0.0;
    maVertices[1].z = 1.0;
    maVertices[1].rhw = 1.0;
    maVertices[1].s = 1.0;
    maVertices[1].t = 0.0;
    maVertices[0].x = (float)(v94 * 0.5) + (float)((float)((float)(statsStart + -320.0) * v95) / 480.0);
    maVertices[0].y = (float)(v95 * 0.0) / 480.0;
    maVertices[1].x = (float)(v94 * 0.5) + (float)((float)((float)(briefsEnd + -320.0) * v95) / 480.0);
    maVertices[1].y = (float)(v95 * 0.0) / 480.0;
    *(float *)&maVertices[1].r = v148.y;
    maVertices[2].z = 1.0;
    maVertices[2].rhw = 1.0;
    maVertices[2].s = 0.0;
    maVertices[2].t = 1.0;
    maVertices[2].x = maVertices[0].x;
    maVertices[2].y = (float)(v95 * 50.0) / 480.0;
    *(_DWORD *)&maVertices[2].r = v149;
    v9 = this;
    maVertices[3].z = 1.0;
    maVertices[3].rhw = 1.0;
    maVertices[3].s = 1.0;
    maVertices[3].t = 1.0;
    maVertices[3].x = maVertices[1].x;
    maVertices[3].y = (float)(v95 * 50.0) / 480.0;
    *(_DWORD *)&maVertices[3].r = HIDWORD(v149);
    RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, maVertices, 4);
    if ( !Menu_IsPlayingGame(1) || gMobileMenu.InitializedForSignOut )
      goto LABEL_62;
    if ( CHID::GetInputType() )
    {
      if ( CHID::GetInputType() == 2 )
      {
        CRGBA::CRGBA(&v125, 0xE0u, 0xE0u, 0xE0u, 0xFFu);
        v96 = RsGlobal.screenHeight;
        v97 = CText::Get(&TheText, "MOB_VW2");
        v2.n64_f32[0] = (float)v96;
        v98 = *(float *)&v125;
      }
      else
      {
        if ( CHID::GetInputType() != 1 )
          goto LABEL_62;
        v100 = (float)RsGlobal.screenHeight;
        v101 = (float)RsGlobal.screenWidth;
        CFont::SetScale((float)((float)RsGlobal.screenHeight * 1.35) / 480.0);
        v102 = (float)RsGlobal.screenHeight;
        v103 = 438.0;
        if ( (float)((float)((float)((float)(v102 - (float)(v102 * 0.0)) - CFont::GetHeight(0)) * 480.0)
                   / (float)RsGlobal.screenHeight) < 438.0 )
        {
          CFont::SetScale((float)((float)RsGlobal.screenHeight * 1.35) / 480.0);
          v104 = (float)RsGlobal.screenHeight + (float)((float)RsGlobal.screenHeight * -0.0);
          v103 = (float)((float)(v104 - CFont::GetHeight(0)) * 480.0) / (float)RsGlobal.screenHeight;
        }
        if ( CHID::Implements(HID_MAPPING_MENU_MAP) )
        {
          v2.n64_u32[0] = 20.0;
          v3.n64_f32[0] = v101 * 0.0;
          CRGBA::CRGBA(&v124, 0xF0u, 0xF0u, 0xF0u, 0xFFu);
          v105 = CText::Get(&TheText, "FEH_MAP");
          LODWORD(uvs.x) = v124;
          ignoreOpacityc.x = (float)((float)((float)(vmax_f32(v3, v2).n64_f32[0] * 480.0) + (float)(v101 * -240.0))
                                   / v100)
                           + 320.0;
          ignoreOpacityc.y = v103;
          MenuScreen::DrawTextDirect(
            &coords,
            (MenuScreen *)this,
            v105,
            TA_Left,
            0,
            (CRGBA)&uvs,
            1,
            ignoreOpacityc,
            (CVector2D)0x41D8000042F00000LL,
            0,
            0);
          uvs.x = 0.0;
          uvs.y = 0.0;
          v145 = (CVector2D)0x3F8000003F800000LL;
          v106 = CHID::GetHelpSprite(0, HID_MAPPING_MENU_MAP, &uvs, &v145);
          if ( v106 )
          {
            v107 = v106->mpTexture;
            CRGBA::CRGBA(&v123, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
            var184b.y = 463.0;
            v9 = this;
            v168.x = coords.y + 5.0;
            v168.y = v103 + 5.0;
            var184b.x = coords.y + 25.0;
            MenuScreen::DrawSprite((MenuScreen *)this, v107, (CRGBA)&v123, v168, var184b, uvs, v145);
          }
          goto LABEL_62;
        }
        CRGBA::CRGBA(&v122, 0xE0u, 0xE0u, 0xE0u, 0xFFu);
        v108 = RsGlobal.screenHeight;
        v97 = CText::Get(&TheText, "MOB_VWM");
        v2.n64_f32[0] = (float)v108;
        v98 = *(float *)&v122;
      }
    }
    else
    {
      CRGBA::CRGBA(&v126, 0xE0u, 0xE0u, 0xE0u, 0xFFu);
      v99 = RsGlobal.screenHeight;
      v97 = CText::Get(&TheText, "MOB_VWM");
      v2.n64_f32[0] = (float)v99;
      v98 = *(float *)&v126;
    }
    v3.n64_u32[0] = 15.0;
    v2.n64_f32[0] = v2.n64_f32[0] * 0.0;
    uvs.x = v98;
    ignoreOpacityb.x = 0.0;
    LODWORD(ignoreOpacityb.y) = vmax_f32(v2, v3).n64_u32[0];
    MenuScreen::DrawTextDirect(
      &coords,
      (MenuScreen *)this,
      v97,
      TA_Center,
      2,
      (CRGBA)&uvs,
      1,
      ignoreOpacityb,
      (CVector2D)0x41A8000044200000LL,
      0,
      0);
LABEL_62:
    v9->opacity = opacity;
  }
  if ( v9->hasBack )
    (*((void (__fastcall **)(FlowScreen *, int))v9->_vptr$MenuScreen + 10))(v9, 1);
}
// 29C1AE: variable 'v4' is possibly undefined
// 29C1AE: variable 'v7' is possibly undefined
// 29C1C2: variable 'v5' is possibly undefined
// 29C4B2: variable 'v2' is possibly undefined
// 29C4B2: variable 'v3' is possibly undefined
// 29C5FA: variable 'v6' is possibly undefined
// 29C5FA: variable 'v8' is possibly undefined

//----- (0029D1B4) --------------------------------------------------------
void __fastcall FlowScreen::GainedFocus(FlowScreen *this)
{
  this->curItemOffset = (float)this->selectedItem;
}

//----- (0029D1C2) --------------------------------------------------------
void __fastcall FlowScreen::SetPreviousScreen(FlowScreen *this, MenuScreen *previous)
{
  __int64 v4; // kr00_8
  float opacity; // r2
  RwTexture_0 *newCharTex; // r1

  if ( (*((int (__fastcall **)(MenuScreen *))previous->_vptr$MenuScreen + 6))(previous) == 1 )
  {
    v4 = *(_QWORD *)&this->curCharTex;
    opacity = previous[1].opacity;
    *(float *)&this->curCharTex = opacity;
    newCharTex = *(RwTexture_0 **)&previous[1].hasBack;
    this->newCharTex = newCharTex;
    if ( opacity != 0.0 )
    {
      ++*(_DWORD *)(LODWORD(opacity) + 84);
      newCharTex = this->newCharTex;
    }
    if ( newCharTex )
      ++newCharTex->refCount;
    if ( (_DWORD)v4 )
      RwTextureDestroy((RwTexture_0 *)v4);
    if ( HIDWORD(v4) )
      RwTextureDestroy((RwTexture_0 *)HIDWORD(v4));
    LODWORD(this->charCountdown) = previous[2]._vptr$MenuScreen;
    this->panelFlip = (int)previous[2].arrowTex;
  }
}

//----- (0029D21C) --------------------------------------------------------
bool __fastcall FlowScreen::IsFlowScreen(FlowScreen *this)
{
  return 1;
}

//----- (0029D220) --------------------------------------------------------
bool __fastcall FlowScreen::IsPauseScreen(FlowScreen *this)
{
  return this->isPauseScreen;
}

//----- (0029D224) --------------------------------------------------------
void __fastcall MainMenuScreen::OnBack(MainMenuScreen *this)
{
  unsigned int numEntries; // r1
  MenuScreen *v2; // r0

  if ( this->isPauseScreen )
  {
    MobileMenu::Unload(&gMobileMenu);
    numEntries = gMobileMenu.screenStack.numEntries;
    gMobileMenu.pendingScreen = 0;
    gMobileMenu.isMapMode = 0;
    while ( numEntries )
    {
      v2 = gMobileMenu.screenStack.dataPtr[--numEntries];
      gMobileMenu.screenStack.numEntries = numEntries;
      if ( v2 )
      {
        (*((void (__fastcall **)(MenuScreen *))v2->_vptr$MenuScreen + 1))(v2);
        numEntries = gMobileMenu.screenStack.numEntries;
      }
    }
    Menu_SwitchOffToGame();
    if ( Menu_IsPlayingGame(1) )
      skipFrame = 2;
  }
  else
  {
    RsGlobal.quit = 1;
  }
}
// 6C: using guessed type int dword_6C;

//----- (0029D2AC) --------------------------------------------------------
bool __fastcall FlowScreen::IsFlow(FlowScreen *this)
{
  return 1;
}

//----- (0029D2B0) --------------------------------------------------------
void __fastcall FlowScreen::~FlowScreen(FlowScreen *this)
{
  RwTexture_0 *curCharTex; // r0
  RwTexture_0 *newCharTex; // r0
  RwTexture_0 *presentsTex; // r0
  unsigned int numEntries; // r1
  int v6; // r6
  unsigned int i; // r5
  FlowScreen::MenuItem *dataPtr; // r4
  RwTexture_0 *itemTex; // r0
  FlowScreen::MenuItem *v10; // r0
  RwTexture_0 *arrowTex; // r0

  curCharTex = this->curCharTex;
  this->_vptr$MenuScreen = (int (**)(void))&off_662600;
  if ( curCharTex )
  {
    RwTextureDestroy(curCharTex);
    this->curCharTex = 0;
  }
  newCharTex = this->newCharTex;
  if ( newCharTex )
  {
    RwTextureDestroy(newCharTex);
    this->newCharTex = 0;
  }
  presentsTex = this->presentsTex;
  if ( presentsTex )
  {
    RwTextureDestroy(presentsTex);
    this->presentsTex = 0;
  }
  numEntries = this->items.numEntries;
  if ( numEntries )
  {
    v6 = 0;
    for ( i = 0; i < numEntries; ++i )
    {
      dataPtr = this->items.dataPtr;
      itemTex = dataPtr[v6].itemTex;
      if ( itemTex )
      {
        RwTextureDestroy(itemTex);
        dataPtr[v6].itemTex = 0;
        numEntries = this->items.numEntries;
      }
      ++v6;
    }
  }
  v10 = this->items.dataPtr;
  this->items.numEntries = 0;
  if ( v10 )
  {
    free(v10);
    this->items.dataPtr = 0;
  }
  this->items.numAlloced = 0;
  arrowTex = this->arrowTex;
  this->_vptr$MenuScreen = (int (**)(void))&off_662590;
  if ( arrowTex )
  {
    RwTextureDestroy(arrowTex);
    this->arrowTex = 0;
  }
}
// 662590: using guessed type void *off_662590;
// 662600: using guessed type void *off_662600;

//----- (0029D364) --------------------------------------------------------
void __fastcall FlowScreen::~FlowScreen(FlowScreen *this)
{
  void *v1; // r0

  FlowScreen::~FlowScreen(this);
  sub_191374(v1);
}
// 29D370: variable 'v1' is possibly undefined

//----- (0029D374) --------------------------------------------------------
void __fastcall FlowScreen::Update(FlowScreen *this, float deltaTime)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  int selectedItem; // r5
  int v7; // r1
  int v8; // r0
  unsigned int numEntries; // r1
  int v10; // r0
  float v11; // s16
  OSPointerState v12; // r2
  int v13; // r0
  int (**v14)(void); // r0
  tAudioEvent v15; // r1
  int v16; // r0
  FlowScreen::MenuItem *dataPtr; // r1
  float totalOffset; // s6
  int v19; // r1
  float v20; // s4
  bool v21; // nf
  float v22; // s2
  float v23; // s0
  unsigned int v24; // r0
  float x; // s0
  float opacity; // s0
  float v27; // s4
  CVector2D *v28; // r0
  float v29; // s0
  float v30; // s0
  int v31; // r0
  RwTexture_0 *curCharTex; // r1
  RwTexture *Texture; // r0
  int v34; // r0
  RwTexture_0 *v35; // r1
  int v36; // r0
  int v37; // r0
  unsigned __int8 v38[256]; // [sp+4h] [bp-12Ch] BYREF

  selectedItem = this->selectedItem;
  if ( LeftPressed() == 1 )
  {
    v7 = this->selectedItem;
    this->selectOnScroll = 0;
    this->selectedItem = v7 - 1;
    if ( v7 <= 0 )
    {
      this->selectedItem = 0;
      if ( !NeedsAmazonDownload() )
        CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 4, 0.0, 1.0);
    }
  }
  if ( RightPressed() == 1 )
  {
    v8 = this->selectedItem;
    numEntries = this->items.numEntries;
    this->selectOnScroll = 0;
    this->selectedItem = v8 + 1;
    if ( v8 + 1 >= numEntries )
    {
      this->selectedItem = v8;
      if ( !NeedsAmazonDownload() )
        CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 4, 0.0, 1.0);
    }
  }
  if ( CHID::Implements(HID_MAPPING_MENU_ACCEPT)
    && CHID::IsReleased(HID_MAPPING_MENU_ACCEPT)
    && gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]->opacity >= 1.0 )
  {
    v16 = this->selectedItem;
    dataPtr = this->items.dataPtr;
    this->selectOnScroll = 0;
    dataPtr[v16].selected();
    if ( NeedsAmazonDownload() )
      return;
LABEL_36:
    v15 = 1;
    goto LABEL_37;
  }
  if ( this->hasBack
    && BackPressed()
    && gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]->opacity >= 1.0 )
  {
    v14 = this->_vptr$MenuScreen;
    this->selectOnScroll = 0;
    ((void (__fastcall *)(FlowScreen *))v14[9])(this);
    if ( NeedsAmazonDownload() )
      return;
    v15 = 2;
LABEL_37:
    sub_18FDC4(&AudioEngine, v15, 0.0, 1.0);
    return;
  }
  v10 = this->selectedItem;
  v2.n64_u32[0] = LODWORD(this->curItemOffset);
  v11 = (float)((float)v10 - v2.n64_f32[0]) * 0.1;
  if ( !gMobileMenu.pointerMode )
    goto LABEL_43;
  v12 = gMobileMenu.pointerState[lastDevice];
  switch ( v12 )
  {
    case OSPS_ButtonReleased:
      totalOffset = this->totalOffset;
      if ( totalOffset <= 0.15 || totalOffset >= 0.5 )
      {
        if ( totalOffset >= 0.1
          || OS_TimeMS() - this->timeClicked > 0xC7
          || gMobileMenu.pointerCoords[lastDevice].y <= 320.0 )
        {
          goto LABEL_43;
        }
        x = gMobileMenu.pointerCoords[lastDevice].x;
        if ( x >= 120.0 )
        {
          if ( x >= 240.0 )
          {
            if ( x <= 520.0 )
            {
              v37 = this->selectedItem;
              if ( x <= 400.0 )
              {
                this->items.dataPtr[v37].selected();
                if ( NeedsAmazonDownload() )
                  return;
                goto LABEL_36;
              }
              this->selectOnScroll = 1;
              v19 = v37 + 1;
            }
            else
            {
              v19 = this->selectedItem + 2;
            }
          }
          else
          {
            v36 = this->selectedItem;
            this->selectOnScroll = 1;
            v19 = v36 - 1;
          }
        }
        else
        {
          v19 = this->selectedItem - 2;
        }
      }
      else
      {
        v19 = (int)(float)(v2.n64_f32[0] + 0.85);
        if ( v10 == v19 )
        {
          v19 = (int)(float)(v2.n64_f32[0] + 0.15);
          if ( v10 == v19 )
            goto LABEL_43;
        }
      }
      this->selectedItem = v19;
      if ( v19 < 0 )
        goto LABEL_32;
LABEL_44:
      v24 = this->items.numEntries - 1;
      if ( v19 <= v24 )
        goto LABEL_46;
      goto LABEL_45;
    case OSPS_ButtonDown:
      v11 = 0.0;
      v20 = (float)(this->lastMouseCoords.x - gMobileMenu.pointerCoords[lastDevice].x) * 0.007;
      v2.n64_f32[0] = v20 + v2.n64_f32[0];
      v3.n64_f32[0] = (float)this->items.numEntries + 1.0;
      v21 = v2.n64_f32[0] < -1.0;
      LODWORD(v22) = vmin_f32(v2, v3).n64_u32[0];
      v23 = this->totalOffset + fabsf(v20);
      if ( v21 )
        v22 = -1.0;
      this->totalOffset = v23;
      this->selectedItem = (int)(float)(v22 + 0.5);
      this->curItemOffset = v22;
      v19 = (int)(float)(v22 + 0.5);
      if ( v19 < 0 )
        goto LABEL_32;
      goto LABEL_44;
    case OSPS_ButtonPressed:
      this->selectOnScroll = 0;
      v13 = OS_TimeMS();
      this->totalOffset = 0.0;
      this->timeClicked = v13;
      goto LABEL_43;
  }
  if ( fabsf(v11) < 0.003 && this->selectOnScroll )
  {
    this->selectOnScroll = 0;
    this->items.dataPtr[v10].selected();
    if ( NeedsAmazonDownload() )
      return;
    goto LABEL_36;
  }
LABEL_43:
  v19 = this->selectedItem;
  if ( v19 >= 0 )
    goto LABEL_44;
LABEL_32:
  v24 = 0;
LABEL_45:
  v19 = v24;
  this->selectedItem = v24;
LABEL_46:
  if ( selectedItem != v19 && !NeedsAmazonDownload() )
    CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 3, 0.0, 1.0);
  opacity = this->opacity;
  v27 = v11 + this->curItemOffset;
  v28 = &gMobileMenu.bgUVSize + lastDevice;
  this->lastMouseCoords.x = v28[14].x;
  this->lastMouseCoords.y = v28[14].y;
  this->curItemOffset = v27;
  if ( opacity < 1.0 )
  {
    v29 = (float)(deltaTime * 5.0) + opacity;
    this->opacity = v29;
    if ( v29 > 1.0 )
      this->opacity = 1.0;
  }
  if ( !Menu_IsPlayingGame(1) || gMobileMenu.InitializedForSignOut )
  {
    v30 = this->charCountdown + (float)(deltaTime * -0.35);
    this->charCountdown = v30;
    if ( v30 < 0.0 )
    {
      v31 = rand();
      curCharTex = this->curCharTex;
      this->charCountdown = 5.0;
      this->panelFlip = v31 % 3;
      RwTextureDestroy(curCharTex);
      this->curCharTex = this->newCharTex;
      this->newCharTex = 0;
      Texture = 0;
      do
      {
        if ( Texture )
        {
          RwTextureDestroy(Texture);
          this->newCharTex = 0;
        }
        v34 = rand();
        sprintf(v38, "menu_main%d", v34 % 4 + 1);
        Texture = TextureDatabaseRuntime::GetTexture(v38);
        ++Texture->refCount;
        v35 = this->curCharTex;
        this->newCharTex = Texture;
      }
      while ( Texture == v35 );
    }
  }
  TextureDatabaseRuntime::UpdateStreaming(deltaTime, 1);
}
// 29D5D6: variable 'v2' is possibly undefined
// 29D5D6: variable 'v3' is possibly undefined

//----- (0029D944) --------------------------------------------------------
void __fastcall FlowScreen::OnBack(FlowScreen *this)
{
  if ( gMobileMenu.screenStack.numEntries >= 2 )
    (*((void (__fastcall **)(MenuScreen *, MenuScreen *))gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries
                                                                                       - 2]->_vptr$MenuScreen
     + 5))(
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 2],
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
  sub_191808(&gMobileMenu, 0, 0);
}

//----- (0029D988) --------------------------------------------------------
void MainMenuScreen::OnResume()
{
  unsigned int v0; // r1
  MenuScreen *v1; // r0
  unsigned int numEntries; // r1
  MenuScreen *v3; // r0

  AddMenuStat(eMenuResume, 1);
  if ( Menu_IsPlayingGame(1) || !CGenericGameStorage::CheckSlotDataValid(lastSaveForResume, 1) )
  {
    MobileMenu::Unload(&gMobileMenu);
    numEntries = gMobileMenu.screenStack.numEntries;
    gMobileMenu.pendingScreen = 0;
    gMobileMenu.isMapMode = 0;
    while ( numEntries )
    {
      v3 = gMobileMenu.screenStack.dataPtr[--numEntries];
      gMobileMenu.screenStack.numEntries = numEntries;
      if ( v3 )
      {
        (*((void (__fastcall **)(MenuScreen *))v3->_vptr$MenuScreen + 1))(v3);
        numEntries = gMobileMenu.screenStack.numEntries;
      }
    }
    Menu_SwitchOffToGame();
    if ( Menu_IsPlayingGame(1) )
      goto LABEL_14;
  }
  else
  {
    Menu_LoadSlot(lastSaveForResume);
    MobileMenu::Unload(&gMobileMenu);
    v0 = gMobileMenu.screenStack.numEntries;
    gMobileMenu.pendingScreen = 0;
    gMobileMenu.isMapMode = 0;
    while ( v0 )
    {
      v1 = gMobileMenu.screenStack.dataPtr[--v0];
      gMobileMenu.screenStack.numEntries = v0;
      if ( v1 )
      {
        (*((void (__fastcall **)(MenuScreen *))v1->_vptr$MenuScreen + 1))(v1);
        v0 = gMobileMenu.screenStack.numEntries;
      }
    }
    Menu_SwitchOffToGame();
    if ( Menu_IsPlayingGame(1) )
LABEL_14:
      skipFrame = 2;
  }
  gMobileMenu.CurrentGameNotResumable = 0;
}
// 6C: using guessed type int dword_6C;

//----- (0029DA9C) --------------------------------------------------------
void MainMenuScreen::OnSettings()
{
  SettingsScreen *v0; // r0
  MenuScreen *v1; // r0

  AddMenuStat(eOptions, 1);
  v0 = (SettingsScreen *)operator new(0x58u);
  SettingsScreen::SettingsScreen(v0);
  sub_197200(v1, 1);
}
// 29DAB8: variable 'v1' is possibly undefined

//----- (0029DABC) --------------------------------------------------------
void FlowScreen::OnStats()
{
  StatsScreen *v0; // r4

  v0 = (StatsScreen *)operator new(0x44u);
  StatsScreen::StatsScreen(v0);
  if ( gMobileMenu.screenStack.numEntries )
    (*((void (__fastcall **)(StatsScreen *, MenuScreen *))v0->_vptr$MenuScreen + 5))(
      v0,
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
  if ( gMobileMenu.pendingScreen )
    MobileMenu::ProcessPending(&gMobileMenu);
  gMobileMenu.pendingScreen = v0;
}

//----- (0029DB20) --------------------------------------------------------
void FlowScreen::OnBriefs()
{
  BriefScreen *v0; // r4

  v0 = (BriefScreen *)operator new(0x54u);
  BriefScreen::BriefScreen(v0);
  if ( gMobileMenu.screenStack.numEntries )
    (*((void (__fastcall **)(BriefScreen *, MenuScreen *))v0->_vptr$MenuScreen + 5))(
      v0,
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
  if ( gMobileMenu.pendingScreen )
    MobileMenu::ProcessPending(&gMobileMenu);
  gMobileMenu.pendingScreen = v0;
}

//----- (0029DB84) --------------------------------------------------------
void MainMenuScreen::OnStartGame()
{
  int v0; // r4
  _BOOL4 IsPlayingGame; // r0
  int v2; // r2
  FlowScreen *v3; // r4
  RwTexture *Texture; // r9
  unsigned int numEntries; // r5
  unsigned int v6; // r10
  FlowScreen::MenuItem *v7; // r0
  FlowScreen::MenuItem *v8; // r8
  FlowScreen::MenuItem *dataPtr; // r6
  unsigned int v10; // r1
  MenuScreen *v11; // r0
  FlowScreen::MenuItem *v12; // r1
  RwTexture *v13; // r9
  unsigned int v14; // r5
  unsigned int v15; // r10
  FlowScreen::MenuItem *v16; // r0
  FlowScreen::MenuItem *v17; // r8
  FlowScreen::MenuItem *v18; // r6
  __int64 v19; // r0
  RwTexture *v20; // r9
  unsigned int v21; // r5
  unsigned int v22; // r10
  FlowScreen::MenuItem *v23; // r0
  FlowScreen::MenuItem *v24; // r8
  FlowScreen::MenuItem *v25; // r6
  __int64 v26; // r0

  AddMenuStat(eStartGame, 1);
  v0 = 0;
  Menu_PopulateSaves(0);
  IsPlayingGame = Menu_IsPlayingGame(1);
  if ( !gMobileMenu.CurrentGameNotResumable )
    v0 = 1;
  if ( GameToSKip <= 8 )
  {
    v2 = 0;
    while ( CGenericGameStorage::ms_Slots[v2] )
    {
      if ( ++v2 >= 9 - GameToSKip )
        goto LABEL_7;
    }
    goto LABEL_8;
  }
LABEL_7:
  if ( (IsPlayingGame & v0) == 1 )
  {
LABEL_8:
    v3 = (FlowScreen *)operator new(0x58u);
    FlowScreen::FlowScreen(v3, 1, 0);
    v3->_vptr$MenuScreen = (int (**)(void))&off_662AB8;
    Texture = TextureDatabaseRuntime::GetTexture("menu_mainplay");
    ++Texture->refCount;
    numEntries = v3->items.numEntries;
    if ( v3->items.numAlloced >= numEntries + 1 )
    {
      dataPtr = v3->items.dataPtr;
    }
    else
    {
      v6 = 4 * (numEntries + 1) / 3 + 3;
      v7 = (FlowScreen::MenuItem *)malloc(12 * v6);
      v8 = v3->items.dataPtr;
      dataPtr = v7;
      if ( v8 )
      {
        qmemcpy(v7, v3->items.dataPtr, 12 * numEntries);
        free(v8);
        numEntries = v3->items.numEntries;
      }
      v3->items.dataPtr = dataPtr;
      v3->items.numAlloced = v6;
    }
    dataPtr[numEntries].itemTex = Texture;
    v12 = &dataPtr[numEntries];
    v12->text = "FES_NGA";
    v12->selected = StartGameScreen::OnNewGameCheck;
    ++v3->items.numEntries;
    v13 = TextureDatabaseRuntime::GetTexture("menu_mainresume");
    ++v13->refCount;
    v14 = v3->items.numEntries;
    if ( v3->items.numAlloced >= v14 + 1 )
    {
      v18 = v3->items.dataPtr;
    }
    else
    {
      v15 = 4 * (v14 + 1) / 3 + 3;
      v16 = (FlowScreen::MenuItem *)malloc(12 * v15);
      v17 = v3->items.dataPtr;
      v18 = v16;
      if ( v17 )
      {
        qmemcpy(v16, v3->items.dataPtr, 12 * v14);
        free(v17);
        v14 = v3->items.numEntries;
      }
      v3->items.dataPtr = v18;
      v3->items.numAlloced = v15;
    }
    v18[v14].itemTex = v13;
    HIDWORD(v19) = StartGameScreen::OnLoadGame;
    LODWORD(v19) = "FET_LG";
    *(_QWORD *)&v18[v14].text = v19;
    ++v3->items.numEntries;
    v20 = TextureDatabaseRuntime::GetTexture("menu_maindelete");
    ++v20->refCount;
    v21 = v3->items.numEntries;
    if ( v3->items.numAlloced >= v21 + 1 )
    {
      v25 = v3->items.dataPtr;
    }
    else
    {
      v22 = 4 * (v21 + 1) / 3 + 3;
      v23 = (FlowScreen::MenuItem *)malloc(12 * v22);
      v24 = v3->items.dataPtr;
      v25 = v23;
      if ( v24 )
      {
        qmemcpy(v23, v3->items.dataPtr, 12 * v21);
        free(v24);
        v21 = v3->items.numEntries;
      }
      v3->items.dataPtr = v25;
      v3->items.numAlloced = v22;
    }
    v25[v21].itemTex = v20;
    HIDWORD(v26) = StartGameScreen::OnDeleteGame;
    LODWORD(v26) = "FES_DEL";
    *(_QWORD *)&v25[v21].text = v26;
    ++v3->items.numEntries;
    sub_197200((MenuScreen *)v3, 1);
    return;
  }
  Menu_NewGame();
  MobileMenu::Unload(&gMobileMenu);
  v10 = gMobileMenu.screenStack.numEntries;
  gMobileMenu.pendingScreen = 0;
  gMobileMenu.isMapMode = 0;
  while ( v10 )
  {
    v11 = gMobileMenu.screenStack.dataPtr[--v10];
    gMobileMenu.screenStack.numEntries = v10;
    if ( v11 )
    {
      (*((void (__fastcall **)(MenuScreen *))v11->_vptr$MenuScreen + 1))(v11);
      v10 = gMobileMenu.screenStack.numEntries;
    }
  }
  Menu_SwitchOffToGame();
  if ( Menu_IsPlayingGame(1) )
    skipFrame = 2;
}
// 6C: using guessed type int dword_6C;
// 662AB8: using guessed type void *off_662AB8;

//----- (0029DE50) --------------------------------------------------------
bool __fastcall MainMenuScreen::HasCPSave(MainMenuScreen *this)
{
  int v1; // r4
  OSDate Date; // kr00_8
  OSDate v3; // r0
  unsigned __int8 v5[260]; // [sp+0h] [bp-120h] BYREF

  v1 = lastSaveForResume;
  if ( lastSaveForResume == -1 )
  {
    C_PcSave::GenerateGameFilename(&PcSaveHelper, 9, v5);
    Date = OS_FileGetDate(OSFDA_User_0, v5);
    v1 = 8;
    C_PcSave::GenerateGameFilename(&PcSaveHelper, 8, v5);
    v3 = OS_FileGetDate(OSFDA_User_0, v5);
    if ( !(v3 | Date) )
      v1 = 9;
    if ( v3 < Date )
      v1 = 9;
    lastSaveForResume = v1;
  }
  return CGenericGameStorage::CheckSlotDataValid(v1, 1);
}

//----- (0029DEF8) --------------------------------------------------------
void MainMenuScreen::OnExit()
{
  RsGlobal.quit = 1;
}

//----- (0029DF08) --------------------------------------------------------
void __fastcall SettingsScreen::SettingsScreen(SettingsScreen *this)
{
  RwTexture *Texture; // r9
  unsigned int numEntries; // r5
  unsigned int v4; // r10
  FlowScreen::MenuItem *v5; // r0
  FlowScreen::MenuItem *v6; // r8
  FlowScreen::MenuItem *dataPtr; // r6
  __int64 v8; // r0
  RwTexture *v9; // r9
  unsigned int v10; // r5
  unsigned int v11; // r10
  FlowScreen::MenuItem *v12; // r0
  FlowScreen::MenuItem *v13; // r8
  FlowScreen::MenuItem *v14; // r6
  __int64 v15; // r0
  RwTexture *v16; // r9
  unsigned int v17; // r5
  unsigned int v18; // r10
  FlowScreen::MenuItem *v19; // r0
  FlowScreen::MenuItem *v20; // r8
  FlowScreen::MenuItem *v21; // r6
  FlowScreen::MenuItem *v22; // r1
  RwTexture *v23; // r9
  unsigned int v24; // r5
  unsigned int v25; // r10
  FlowScreen::MenuItem *v26; // r0
  FlowScreen::MenuItem *v27; // r8
  FlowScreen::MenuItem *v28; // r6
  FlowScreen::MenuItem *v29; // r1
  RwTexture *v30; // r9
  unsigned int v31; // r5
  unsigned int v32; // r10
  FlowScreen::MenuItem *v33; // r0
  FlowScreen::MenuItem *v34; // r8
  FlowScreen::MenuItem *v35; // r6
  FlowScreen::MenuItem *v36; // r1

  FlowScreen::FlowScreen(this, 1, 0);
  this->_vptr$MenuScreen = (int (**)(void))&off_662638;
  Texture = TextureDatabaseRuntime::GetTexture("menu_maincontrols");
  ++Texture->refCount;
  numEntries = this->items.numEntries;
  if ( this->items.numAlloced >= numEntries + 1 )
  {
    dataPtr = this->items.dataPtr;
  }
  else
  {
    v4 = 4 * (numEntries + 1) / 3 + 3;
    v5 = (FlowScreen::MenuItem *)malloc(12 * v4);
    v6 = this->items.dataPtr;
    dataPtr = v5;
    if ( v6 )
    {
      qmemcpy(v5, this->items.dataPtr, 12 * numEntries);
      free(v6);
      numEntries = this->items.numEntries;
    }
    this->items.dataPtr = dataPtr;
    this->items.numAlloced = v4;
  }
  dataPtr[numEntries].itemTex = Texture;
  HIDWORD(v8) = SettingsScreen::OnAdjustControls;
  LODWORD(v8) = "FEC_RED";
  *(_QWORD *)&dataPtr[numEntries].text = v8;
  ++this->items.numEntries;
  v9 = TextureDatabaseRuntime::GetTexture("menu_mainsettings");
  ++v9->refCount;
  v10 = this->items.numEntries;
  if ( this->items.numAlloced >= v10 + 1 )
  {
    v14 = this->items.dataPtr;
  }
  else
  {
    v11 = 4 * (v10 + 1) / 3 + 3;
    v12 = (FlowScreen::MenuItem *)malloc(12 * v11);
    v13 = this->items.dataPtr;
    v14 = v12;
    if ( v13 )
    {
      qmemcpy(v12, this->items.dataPtr, 12 * v10);
      free(v13);
      v10 = this->items.numEntries;
    }
    this->items.dataPtr = v14;
    this->items.numAlloced = v11;
  }
  v14[v10].itemTex = v9;
  HIDWORD(v15) = SettingsScreen::OnGameOptions;
  LODWORD(v15) = "FEH_LOA";
  *(_QWORD *)&v14[v10].text = v15;
  ++this->items.numEntries;
  v16 = TextureDatabaseRuntime::GetTexture("menu_maindisplay");
  ++v16->refCount;
  v17 = this->items.numEntries;
  if ( this->items.numAlloced >= v17 + 1 )
  {
    v21 = this->items.dataPtr;
  }
  else
  {
    v18 = 4 * (v17 + 1) / 3 + 3;
    v19 = (FlowScreen::MenuItem *)malloc(12 * v18);
    v20 = this->items.dataPtr;
    v21 = v19;
    if ( v20 )
    {
      qmemcpy(v19, this->items.dataPtr, 12 * v17);
      free(v20);
      v17 = this->items.numEntries;
    }
    this->items.dataPtr = v21;
    this->items.numAlloced = v18;
  }
  v21[v17].itemTex = v16;
  v22 = &v21[v17];
  v22->text = "FEO_DIS";
  v22->selected = SettingsScreen::OnDisplayOptions;
  ++this->items.numEntries;
  v23 = TextureDatabaseRuntime::GetTexture("menu_mainaudio");
  ++v23->refCount;
  v24 = this->items.numEntries;
  if ( this->items.numAlloced >= v24 + 1 )
  {
    v28 = this->items.dataPtr;
  }
  else
  {
    v25 = 4 * (v24 + 1) / 3 + 3;
    v26 = (FlowScreen::MenuItem *)malloc(12 * v25);
    v27 = this->items.dataPtr;
    v28 = v26;
    if ( v27 )
    {
      qmemcpy(v26, this->items.dataPtr, 12 * v24);
      free(v27);
      v24 = this->items.numEntries;
    }
    this->items.dataPtr = v28;
    this->items.numAlloced = v25;
  }
  v28[v24].itemTex = v23;
  v29 = &v28[v24];
  v29->text = "FEO_AUD";
  v29->selected = SettingsScreen::OnSoundOptions;
  ++this->items.numEntries;
  v30 = TextureDatabaseRuntime::GetTexture("menu_mainlanguage");
  ++v30->refCount;
  v31 = this->items.numEntries;
  if ( this->items.numAlloced >= v31 + 1 )
  {
    v35 = this->items.dataPtr;
  }
  else
  {
    v32 = 4 * (v31 + 1) / 3 + 3;
    v33 = (FlowScreen::MenuItem *)malloc(12 * v32);
    v34 = this->items.dataPtr;
    v35 = v33;
    if ( v34 )
    {
      qmemcpy(v33, this->items.dataPtr, 12 * v31);
      free(v34);
      v31 = this->items.numEntries;
    }
    this->items.dataPtr = v35;
    this->items.numAlloced = v32;
  }
  v35[v31].itemTex = v30;
  v36 = &v35[v31];
  v36->text = "FEO_LAN";
  v36->selected = SettingsScreen::OnLanguageOptions;
  ++this->items.numEntries;
}
// 662638: using guessed type void *off_662638;

//----- (0029E250) --------------------------------------------------------
void SettingsScreen::OnAdjustControls()
{
  ControlsScreen *v0; // r4

  AddMenuStat(eRedefineControls, 1);
  v0 = (ControlsScreen *)operator new(0x44u);
  ControlsScreen::ControlsScreen(v0);
  if ( gMobileMenu.screenStack.numEntries )
    (*((void (__fastcall **)(ControlsScreen *, MenuScreen *))v0->_vptr$MenuScreen + 5))(
      v0,
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
  if ( gMobileMenu.pendingScreen )
    MobileMenu::ProcessPending(&gMobileMenu);
  gMobileMenu.pendingScreen = v0;
}

//----- (0029E2BC) --------------------------------------------------------
void SettingsScreen::OnGameOptions()
{
  GameScreen *v0; // r4

  AddMenuStat(eGame, 1);
  v0 = (GameScreen *)operator new(0x44u);
  GameScreen::GameScreen(v0);
  if ( gMobileMenu.screenStack.numEntries )
    (*((void (__fastcall **)(GameScreen *, MenuScreen *))v0->_vptr$MenuScreen + 5))(
      v0,
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
  if ( gMobileMenu.pendingScreen )
    MobileMenu::ProcessPending(&gMobileMenu);
  gMobileMenu.pendingScreen = v0;
}

//----- (0029E328) --------------------------------------------------------
void SettingsScreen::OnDisplayOptions()
{
  DisplayScreen *v0; // r4

  AddMenuStat(eDisplaySetup, 1);
  v0 = (DisplayScreen *)operator new(0x44u);
  DisplayScreen::DisplayScreen(v0);
  if ( gMobileMenu.screenStack.numEntries )
    (*((void (__fastcall **)(DisplayScreen *, MenuScreen *))v0->_vptr$MenuScreen + 5))(
      v0,
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
  if ( gMobileMenu.pendingScreen )
    MobileMenu::ProcessPending(&gMobileMenu);
  gMobileMenu.pendingScreen = v0;
}

//----- (0029E394) --------------------------------------------------------
void SettingsScreen::OnSoundOptions()
{
  AudioScreen *v0; // r4

  AddMenuStat(eAudioSetup, 1);
  v0 = (AudioScreen *)operator new(0x44u);
  AudioScreen::AudioScreen(v0);
  if ( gMobileMenu.screenStack.numEntries )
    (*((void (__fastcall **)(AudioScreen *, MenuScreen *))v0->_vptr$MenuScreen + 5))(
      v0,
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
  if ( gMobileMenu.pendingScreen )
    MobileMenu::ProcessPending(&gMobileMenu);
  gMobileMenu.pendingScreen = v0;
}

//----- (0029E400) --------------------------------------------------------
void SettingsScreen::OnLanguageOptions()
{
  LanguageScreen *v0; // r4

  AddMenuStat(eLanguage, 1);
  v0 = (LanguageScreen *)operator new(0x44u);
  LanguageScreen::LanguageScreen(v0);
  if ( gMobileMenu.screenStack.numEntries )
    (*((void (__fastcall **)(LanguageScreen *, MenuScreen *))v0->_vptr$MenuScreen + 5))(
      v0,
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
  if ( gMobileMenu.pendingScreen )
    MobileMenu::ProcessPending(&gMobileMenu);
  gMobileMenu.pendingScreen = v0;
}

//----- (0029E46C) --------------------------------------------------------
void __fastcall SettingsScreen::~SettingsScreen(SettingsScreen *this)
{
  void *v1; // r0

  FlowScreen::~FlowScreen(this);
  sub_191374(v1);
}
// 29E478: variable 'v1' is possibly undefined

//----- (0029E47C) --------------------------------------------------------
void __fastcall SettingsScreen::OnBack(SettingsScreen *this)
{
  Menu_SaveSettings();
  if ( gMobileMenu.screenStack.numEntries >= 2 )
    (*((void (__fastcall **)(MenuScreen *, MenuScreen *))gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries
                                                                                       - 2]->_vptr$MenuScreen
     + 5))(
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 2],
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
  sub_191808(&gMobileMenu, 0, 0);
}

//----- (0029E4C4) --------------------------------------------------------
void __fastcall ControlsScreen::ControlsScreen(ControlsScreen *this)
{
  int InputType; // r5
  SelectScreen::MenuSelection *v3; // r1
  const char *v4; // r3
  void **v5; // r2
  int (**v6)(void); // r2
  int v7; // r0
  const unsigned __int8 *name; // r2
  int v9; // r1
  const unsigned __int8 *v10; // r0
  int v11; // r1
  const unsigned __int8 *v12; // r0
  int v13; // r1
  const unsigned __int8 *v14; // r0
  int v15; // r0
  const unsigned __int8 *v16; // r2
  int v17; // r1
  const unsigned __int8 *v18; // r0
  int v19; // r0
  const unsigned __int8 *v20; // r2
  const unsigned __int8 *v21; // r0
  int v22; // r0
  int v23; // r0
  const unsigned __int8 *v24; // r2
  const unsigned __int8 *v25; // r0
  int v26; // r0
  SelectScreen::MenuSelection *v27; // r0

  CharSelectScreen::CharSelectScreen(this, "FEC_RED", 1);
  this->_vptr$MenuScreen = (int (**)(void))&off_662670;
  InputType = CHID::GetInputType();
  v3 = (SelectScreen::MenuSelection *)operator new(0x10u);
  if ( InputType == 2 )
  {
    v4 = "FEC_KEY";
    v5 = &ControlsScreen::OnKeyboardControls;
  }
  else
  {
    v4 = "FEC_ADJ";
    v5 = &ControlsScreen::DoAdjustableHUD;
  }
  v3->tag = (const unsigned __int8 *)v4;
  v6 = (int (**)(void))*v5;
  v3[1].tag = 0;
  v3[1]._vptr$MenuSelection = v6;
  v3->_vptr$MenuSelection = (int (**)(void))&off_66280C;
  SelectScreen::AddItem(this, v3);
  v7 = operator new(0x1Cu);
  name = MobileSettings::settings[9].name;
  *(_DWORD *)v7 = &off_662838;
  *(_DWORD *)(v7 + 4) = name;
  *(_DWORD *)(v7 + 8) = 9;
  *(_DWORD *)(v7 + 21) = 0;
  *(_DWORD *)(v7 + 17) = 0;
  *(_DWORD *)(v7 + 12) = 0;
  *(_DWORD *)(v7 + 16) = 0;
  SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v7);
  v9 = operator new(0x1Cu);
  v10 = MobileSettings::settings[3].name;
  *(_DWORD *)v9 = &off_662838;
  *(_DWORD *)(v9 + 4) = v10;
  *(_DWORD *)(v9 + 8) = 3;
  *(_DWORD *)(v9 + 21) = 0;
  *(_DWORD *)(v9 + 17) = 0;
  *(_DWORD *)(v9 + 12) = 0;
  *(_DWORD *)(v9 + 16) = 0;
  SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v9);
  v11 = operator new(0x1Cu);
  v12 = MobileSettings::settings[8].name;
  *(_DWORD *)v11 = &off_662838;
  *(_DWORD *)(v11 + 4) = v12;
  *(_DWORD *)(v11 + 8) = 8;
  *(_DWORD *)(v11 + 21) = 0;
  *(_DWORD *)(v11 + 17) = 0;
  *(_DWORD *)(v11 + 12) = 0;
  *(_DWORD *)(v11 + 16) = 0;
  SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v11);
  v13 = operator new(0x1Cu);
  v14 = MobileSettings::settings[15].name;
  *(_DWORD *)v13 = &off_662838;
  *(_DWORD *)(v13 + 4) = v14;
  *(_DWORD *)(v13 + 8) = 15;
  *(_DWORD *)(v13 + 21) = 0;
  *(_DWORD *)(v13 + 17) = 0;
  *(_DWORD *)(v13 + 12) = 0;
  *(_DWORD *)(v13 + 16) = 0;
  SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v13);
  if ( CHID::GetInputType() == 1 )
  {
    v15 = operator new(0x1Cu);
    v16 = MobileSettings::settings[25].name;
    *(_DWORD *)v15 = &off_662838;
    *(_DWORD *)(v15 + 4) = v16;
    *(_DWORD *)(v15 + 8) = 25;
    *(_DWORD *)(v15 + 21) = 0;
    *(_DWORD *)(v15 + 17) = 0;
    *(_DWORD *)(v15 + 12) = 0;
    *(_DWORD *)(v15 + 16) = 0;
    SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v15);
    v17 = operator new(0x1Cu);
    v18 = MobileSettings::settings[26].name;
    *(_DWORD *)v17 = &off_662838;
    *(_DWORD *)(v17 + 4) = v18;
    *(_DWORD *)(v17 + 8) = 26;
    *(_DWORD *)(v17 + 21) = 0;
    *(_DWORD *)(v17 + 17) = 0;
    *(_DWORD *)(v17 + 12) = 0;
    *(_DWORD *)(v17 + 16) = 0;
LABEL_11:
    SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v17);
    goto LABEL_12;
  }
  if ( CHID::GetInputType() == 2 )
  {
    v19 = operator new(0x1Cu);
    v20 = MobileSettings::settings[31].name;
    *(_DWORD *)v19 = &off_662838;
    *(_DWORD *)(v19 + 4) = v20;
    *(_DWORD *)(v19 + 8) = 31;
    *(_DWORD *)(v19 + 21) = 0;
    *(_DWORD *)(v19 + 17) = 0;
    *(_DWORD *)(v19 + 12) = 0;
    *(_DWORD *)(v19 + 16) = 0;
    SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v19);
    v17 = operator new(0x1Cu);
    v21 = MobileSettings::settings[32].name;
    *(_DWORD *)v17 = &off_662838;
    *(_DWORD *)(v17 + 4) = v21;
    v22 = 32;
LABEL_10:
    *(_DWORD *)(v17 + 8) = v22;
    *(_DWORD *)(v17 + 21) = 0;
    *(_DWORD *)(v17 + 17) = 0;
    *(_DWORD *)(v17 + 16) = 0;
    *(_DWORD *)(v17 + 12) = 0;
    goto LABEL_11;
  }
  if ( !CHID::GetInputType() )
  {
    v23 = operator new(0x1Cu);
    v24 = MobileSettings::settings[18].name;
    *(_DWORD *)v23 = &off_662838;
    *(_DWORD *)(v23 + 4) = v24;
    *(_DWORD *)(v23 + 8) = 18;
    *(_DWORD *)(v23 + 21) = 0;
    *(_DWORD *)(v23 + 17) = 0;
    *(_DWORD *)(v23 + 12) = 0;
    *(_DWORD *)(v23 + 16) = 0;
    SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v23);
    v17 = operator new(0x1Cu);
    v25 = MobileSettings::settings[23].name;
    *(_DWORD *)v17 = &off_662838;
    *(_DWORD *)(v17 + 4) = v25;
    v22 = 23;
    goto LABEL_10;
  }
LABEL_12:
  v26 = operator new(0x1Cu);
  *(_DWORD *)(v26 + 4) = MobileSettings::settings[35].name;
  *(_DWORD *)(v26 + 8) = 35;
  *(_DWORD *)(v26 + 21) = 0;
  *(_DWORD *)(v26 + 17) = 0;
  *(_DWORD *)(v26 + 12) = 0;
  *(_DWORD *)(v26 + 16) = 0;
  *(_DWORD *)v26 = &off_662838;
  SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v26);
  v27 = (SelectScreen::MenuSelection *)operator new(0x10u);
  v27->_vptr$MenuSelection = (int (**)(void))&off_66280C;
  v27->tag = "MOB_RTD";
  v27[1]._vptr$MenuSelection = (int (**)(void))SelectScreen::OnRestoreDefaults;
  v27[1].tag = 0;
  SelectScreen::AddItem(this, v27);
  this->renderLastAtBottom = 1;
}
// FC: using guessed type int elf_hash_bucket[16411];
// 662670: using guessed type void *;
// 66280C: using guessed type void *off_66280C;
// 662838: using guessed type void *;
// 6790D4: using guessed type void *ControlsScreen::OnKeyboardControls;
// 679988: using guessed type void *ControlsScreen::DoAdjustableHUD;

//----- (0029E7AC) --------------------------------------------------------
void __fastcall CharSelectScreen::CharSelectScreen(CharSelectScreen *this, const unsigned __int8 *tag, bool withBack)
{
  RwTexture *Texture; // r0
  int v6; // r0
  RwTexture *v7; // r0
  RwTexture *v8; // r0
  int v9; // r0
  RwTexture_0 *curCharTex; // r1
  unsigned __int8 s[256]; // [sp+4h] [bp-114h] BYREF

  this->hasBack = withBack;
  this->_vptr$MenuScreen = (int (**)(void))&off_662590;
  Texture = TextureDatabaseRuntime::GetTexture("menu_selector");
  ++Texture->refCount;
  *(_QWORD *)((char *)&this->selected.numAlloced + 1) = 0LL;
  *(_QWORD *)((char *)&this->selected.dataPtr + 1) = 0LL;
  *(_QWORD *)&this->items.numAlloced = 0LL;
  *(_QWORD *)&this->items.dataPtr = 0LL;
  this->titleTag = tag;
  this->_vptr$MenuScreen = (int (**)(void))&off_6626CC;
  this->arrowTex = Texture;
  this->opacity = 0.0;
  v6 = rand();
  sprintf(s, "menu_char%d", v6 % 8);
  v7 = TextureDatabaseRuntime::GetTexture(s);
  ++v7->refCount;
  this->curCharTex = v7;
  this->newCharTex = 0;
  v8 = 0;
  do
  {
    if ( v8 )
    {
      RwTextureDestroy(v8);
      this->newCharTex = 0;
    }
    v9 = rand();
    sprintf(s, "menu_char%d", v9 % 8);
    v8 = TextureDatabaseRuntime::GetTexture(s);
    ++v8->refCount;
    curCharTex = this->curCharTex;
    this->newCharTex = v8;
  }
  while ( v8 == curCharTex );
  this->charCountdown = 5.0;
  this->panelFlip = rand() % 3;
}
// 662590: using guessed type void *off_662590;
// 6626CC: using guessed type void *;

//----- (0029E8CC) --------------------------------------------------------
void __fastcall SelectScreen::AddItem(SelectScreen *this, SelectScreen::MenuSelection *toAdd)
{
  unsigned int numEntries; // r5
  unsigned int v5; // r10
  SelectScreen::MenuSelection **v6; // r0
  SelectScreen::MenuSelection **v7; // r9
  SelectScreen::MenuSelection **dataPtr; // r6
  unsigned int numAlloced; // r1
  unsigned int v10; // r6
  unsigned int v11; // r9
  float *v12; // r0
  float *v13; // r8
  float *v14; // r5

  numEntries = this->items.numEntries;
  if ( this->items.numAlloced >= numEntries + 1 )
  {
    dataPtr = this->items.dataPtr;
  }
  else
  {
    v5 = 4 * (numEntries + 1) / 3 + 3;
    v6 = (SelectScreen::MenuSelection **)malloc(4 * v5);
    v7 = this->items.dataPtr;
    dataPtr = v6;
    if ( v7 )
    {
      qmemcpy(v6, this->items.dataPtr, 4 * numEntries);
      free(v7);
      numEntries = this->items.numEntries;
    }
    this->items.dataPtr = dataPtr;
    this->items.numAlloced = v5;
  }
  dataPtr[numEntries] = toAdd;
  v10 = this->selected.numEntries;
  numAlloced = this->selected.numAlloced;
  ++this->items.numEntries;
  if ( numAlloced >= v10 + 1 )
  {
    v14 = this->selected.dataPtr;
  }
  else
  {
    v11 = 4 * (v10 + 1) / 3 + 3;
    v12 = (float *)malloc(4 * v11);
    v13 = this->selected.dataPtr;
    v14 = v12;
    if ( v13 )
    {
      qmemcpy(v12, this->selected.dataPtr, 4 * v10);
      free(v13);
      v10 = this->selected.numEntries;
    }
    this->selected.dataPtr = v14;
    this->selected.numAlloced = v11;
  }
  v14[v10] = 0.0;
  ++this->selected.numEntries;
}

//----- (0029E990) --------------------------------------------------------
void __fastcall ControlsScreen::OnKeyboardControls(SelectScreen *scr, int32 i)
{
  KeyboardControlsScreen *v2; // r4

  v2 = (KeyboardControlsScreen *)operator new(0x294u);
  KeyboardControlsScreen::KeyboardControlsScreen(v2);
  if ( gMobileMenu.screenStack.numEntries )
    (*((void (__fastcall **)(KeyboardControlsScreen *, MenuScreen *))v2->_vptr$MenuScreen + 5))(
      v2,
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
  if ( gMobileMenu.pendingScreen )
    MobileMenu::ProcessPending(&gMobileMenu);
  gMobileMenu.pendingScreen = v2;
}

//----- (0029E9FC) --------------------------------------------------------
void __fastcall SelectScreen::OnRestoreDefaults(SelectScreen *screen, int32 data)
{
  const unsigned __int8 *titleTag; // r5
  MenuStat v4; // r0
  unsigned int v5; // r5
  SelectScreen::MenuSelection *v6; // r0

  titleTag = screen->titleTag;
  if ( !strcmp((const char *)titleTag, "FEH_LOA") )
  {
    v4 = eGameRestoreDefaults;
  }
  else if ( !strcmp((const char *)titleTag, "FEC_RED") )
  {
    v4 = eRedefineControlsRestoreDefaults;
  }
  else if ( !strcmp((const char *)titleTag, "FEH_DIS") )
  {
    v4 = eDisplayRestoreDefaults;
  }
  else
  {
    if ( strcmp((const char *)titleTag, "FEH_AUD") )
      goto LABEL_10;
    v4 = eAudioRestoreDefaults;
  }
  AddMenuStat(v4, 1);
LABEL_10:
  if ( screen->items.numEntries )
  {
    v5 = 0;
    do
    {
      v6 = screen->items.dataPtr[v5];
      (*((void (__fastcall **)(SelectScreen::MenuSelection *))v6->_vptr$MenuSelection + 7))(v6);
      ++v5;
    }
    while ( v5 < screen->items.numEntries );
  }
}

//----- (0029EA78) --------------------------------------------------------
void __fastcall ControlsScreen::~ControlsScreen(ControlsScreen *this)
{
  void *v1; // r0

  SelectScreen::~SelectScreen(this);
  sub_191374(v1);
}
// 29EA84: variable 'v1' is possibly undefined

//----- (0029EA88) --------------------------------------------------------
void __fastcall CharSelectScreen::Update(CharSelectScreen *this, float deltaTime)
{
  float v4; // s0
  int v5; // r1
  RwTexture_0 *curCharTex; // r0
  RwTexture *Texture; // r0
  int v8; // r0
  RwTexture_0 *v9; // r1
  unsigned __int8 v10[256]; // [sp+4h] [bp-11Ch] BYREF

  v4 = this->charCountdown + (float)(deltaTime * -0.5);
  this->charCountdown = v4;
  if ( v4 < 0.0 )
  {
    v5 = rand();
    curCharTex = this->curCharTex;
    this->charCountdown = 5.0;
    this->panelFlip = v5 % 3;
    if ( curCharTex )
    {
      RwTextureDestroy(curCharTex);
      this->curCharTex = 0;
    }
    this->curCharTex = this->newCharTex;
    this->newCharTex = 0;
    Texture = 0;
    do
    {
      if ( Texture )
      {
        RwTextureDestroy(Texture);
        this->newCharTex = 0;
      }
      v8 = rand();
      sprintf(v10, "menu_char%d", v8 % 8);
      Texture = TextureDatabaseRuntime::GetTexture(v10);
      ++Texture->refCount;
      v9 = this->curCharTex;
      this->newCharTex = Texture;
    }
    while ( Texture == v9 );
  }
  SelectScreen::Update(this, deltaTime);
}

//----- (0029EB70) --------------------------------------------------------
void __fastcall CharSelectScreen::Render(CharSelectScreen *this, int stackPos)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d2
  float32x2_t v5; // d8
  float *v6; // r4
  int v7; // r8
  float v8; // s8
  bool v9; // nf
  float v10; // s4
  float v11; // s10
  float v12; // s21
  float v13; // s2
  float v14; // s19
  float v15; // s23
  float v16; // s25
  float v17; // s29
  CVector2D uvs; // [sp+10h] [bp-D8h] BYREF
  float v21; // [sp+18h] [bp-D0h]
  int v22; // [sp+1Ch] [bp-CCh]
  float v23; // [sp+20h] [bp-C8h]
  int v24; // [sp+24h] [bp-C4h]
  float v25; // [sp+28h] [bp-C0h]
  int v26; // [sp+2Ch] [bp-BCh]
  CVector2D coords; // [sp+30h] [bp-B8h] BYREF
  float v28; // [sp+38h] [bp-B0h]
  int v29; // [sp+3Ch] [bp-ACh]
  float v30; // [sp+40h] [bp-A8h]
  int v31; // [sp+44h] [bp-A4h]
  float v32; // [sp+48h] [bp-A0h]
  int v33; // [sp+4Ch] [bp-9Ch]
  int32x4_t v34; // [sp+50h] [bp-98h] BYREF
  CRGBA v35; // [sp+60h] [bp-88h] BYREF
  float v36[9]; // [sp+64h] [bp-84h]

  v4.n64_u32[0] = LODWORD(this->charCountdown);
  v5.n64_u32[0] = 1.0;
  v2.n64_f32[0] = v4.n64_f32[0] + -0.5;
  v6 = (float *)&unk_60C930;
  v3.n64_f32[0] = v4.n64_f32[0] + -1.0;
  v4.n64_f32[0] = v4.n64_f32[0] + v4.n64_f32[0];
  v7 = 0;
  v2.n64_f32[0] = v2.n64_f32[0] + v2.n64_f32[0];
  LODWORD(v8) = vmin_f32(v4, v5).n64_u32[0];
  v9 = v4.n64_f32[0] < 0.0;
  v3.n64_f32[0] = v3.n64_f32[0] + v3.n64_f32[0];
  LODWORD(v10) = vmin_f32(v2, v5).n64_u32[0];
  LODWORD(v11) = vmin_f32(v3, v5).n64_u32[0];
  if ( v9 )
    v8 = 0.0;
  if ( v2.n64_f32[0] < 0.0 )
    v10 = 0.0;
  if ( v3.n64_f32[0] < 0.0 )
    v11 = 0.0;
  v36[2] = v8;
  v36[3] = v8;
  v36[7] = v8;
  v36[1] = v10;
  v36[0] = v11;
  v36[5] = v10;
  v36[4] = v11;
  v36[6] = v11;
  v36[8] = v10;
  do
  {
    v12 = 1.0;
    v13 = v36[3 * this->panelFlip + v7];
    v2.n64_f32[0] = v13 * 4.0;
    v2.n64_u64[0] = vmin_f32(v2, v5).n64_u64[0];
    if ( v13 > 0.25 )
      v12 = 1.0 - (float)((float)(v13 / 0.8) + -0.25);
    CRGBA::CRGBA(&v35, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)(v2.n64_f32[0] * 255.0));
    v14 = *(v6 - 2);
    v15 = *(v6 - 1);
    v16 = *v6;
    v17 = v6[1];
    uvs.y = 0.0;
    uvs.x = v14;
    coords.y = 15.0;
    v21 = v15;
    v22 = 0;
    v23 = v16;
    v24 = 1065353216;
    v25 = v17;
    v34 = vdupq_n_s32(*(_DWORD *)&v35);
    v26 = 1065353216;
    coords.x = (float)(v14 * 200.0) + 23.0;
    v29 = 1097859072;
    v28 = (float)(v15 * 200.0) + 23.0;
    v31 = 1139212288;
    v30 = (float)(v16 * 200.0) + 23.0;
    v33 = 1139212288;
    v32 = (float)(v17 * 200.0) + 23.0;
    if ( *(unsigned int *)&v35 >= 0x1000000 )
      MenuScreen::DrawSprite(this, this->curCharTex, &coords, &uvs, (CRGBA *)&v34, 0);
    CRGBA::CRGBA(&v35, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)(v12 * 255.0));
    coords.y = 15.0;
    coords.x = (float)(v14 * 200.0) + 23.0;
    uvs.y = 0.0;
    v28 = (float)(v15 * 200.0) + 23.0;
    v29 = 1097859072;
    v30 = (float)(v16 * 200.0) + 23.0;
    v31 = 1139212288;
    v32 = (float)(v17 * 200.0) + 23.0;
    uvs.x = v14;
    v21 = v15;
    v22 = 0;
    v23 = v16;
    v24 = 1065353216;
    v25 = v17;
    v34 = vdupq_n_s32(*(_DWORD *)&v35);
    v33 = 1139212288;
    v26 = 1065353216;
    if ( *(unsigned int *)&v35 >= 0x1000000 )
      MenuScreen::DrawSprite(this, this->newCharTex, &coords, &uvs, (CRGBA *)&v34, 0);
    ++v7;
    v6 += 4;
  }
  while ( v7 != 3 );
  SelectScreen::Render(this, stackPos);
}
// 29EBE4: variable 'v4' is possibly undefined
// 29EBE4: variable 'v5' is possibly undefined
// 29EBF4: variable 'v2' is possibly undefined
// 29EBFC: variable 'v3' is possibly undefined

//----- (0029EDD8) --------------------------------------------------------
float __fastcall CharSelectScreen::GetMenuLeft(CharSelectScreen *this)
{
  return 245.0;
}

//----- (0029EDE0) --------------------------------------------------------
float __fastcall SelectScreen::GetMenuRight(SelectScreen *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d2
  float result; // r0

  v2.n64_u32[0] = 1142784000;
  v1.n64_f32[0] = (float)((float)((float)((float)((float)RsGlobal.screenWidth
                                                + (float)((float)RsGlobal.screenWidth * -0.0))
                                        * 480.0)
                                + (float)((float)RsGlobal.screenWidth * -240.0))
                        / (float)RsGlobal.screenHeight)
                + 320.0;
  LODWORD(result) = vmin_f32(v1, v2).n64_u32[0];
  return result;
}
// 29EE26: variable 'v1' is possibly undefined
// 29EE26: variable 'v2' is possibly undefined

//----- (0029EE48) --------------------------------------------------------
bool __fastcall SelectScreen::LoopSelections(SelectScreen *this)
{
  return 1;
}

//----- (0029EE4C) --------------------------------------------------------
float __fastcall SelectScreen::GetScrollY(SelectScreen *this)
{
  return 0.0;
}

//----- (0029EE50) --------------------------------------------------------
float __fastcall SelectScreen::GetStartY(SelectScreen *this)
{
  return 70.0;
}

//----- (0029EE58) --------------------------------------------------------
float __fastcall SelectScreen::GetYSize(SelectScreen *this, int item)
{
  float v3; // s18
  float numEntries; // s16
  float v5; // r0

  v3 = COERCE_FLOAT((*((int (__fastcall **)(SelectScreen *))this->_vptr$MenuScreen + 18))(this));
  numEntries = 9.0;
  v5 = COERCE_FLOAT((*((int (__fastcall **)(SelectScreen *))this->_vptr$MenuScreen + 16))(this));
  if ( this->items.numEntries > 9 )
    numEntries = (float)this->items.numEntries;
  return (float)(v3 - v5) / numEntries;
}

//----- (0029EEA2) --------------------------------------------------------
float __fastcall SelectScreen::GetEndY(SelectScreen *this)
{
  return 430.0;
}

//----- (0029EEAA) --------------------------------------------------------
CRect *__fastcall SelectScreen::GetScissorRect(CRect *retstr, SelectScreen *this)
{
  *(_QWORD *)&retstr->left = 0LL;
  *(_QWORD *)&retstr->right = 0LL;
  return retstr;
}

//----- (0029EEB4) --------------------------------------------------------
bool __fastcall SelectScreen::IsScrolling(SelectScreen *this)
{
  return 0;
}

//----- (0029EEB8) --------------------------------------------------------
void __fastcall CharSelectScreen::~CharSelectScreen(CharSelectScreen *this)
{
  void *v1; // r0

  SelectScreen::~SelectScreen(this);
  sub_191374(v1);
}
// 29EEC4: variable 'v1' is possibly undefined

//----- (0029EEC8) --------------------------------------------------------
void __fastcall SelectScreen::~SelectScreen(SelectScreen *this)
{
  void *v1; // r0

  SelectScreen::~SelectScreen(this);
  sub_191374(v1);
}
// 29EED4: variable 'v1' is possibly undefined

//----- (0029EED8) --------------------------------------------------------
void __fastcall SelectScreen::Update(SelectScreen *this, float deltaTime)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d3
  float v7; // s16
  int v8; // r1
  int v9; // r0
  int selectedItem; // r2
  int *p_selectedItem; // r6
  unsigned int v12; // r1
  float *v13; // r0
  int v14; // r0
  unsigned int v15; // r1
  float *v16; // r2
  unsigned __int32 v17; // s8
  float v18; // r5
  float v19; // r0
  float v20; // s24
  signed int v21; // r6
  int v22; // r11
  float v23; // s26
  _BOOL4 v24; // r5
  float v25; // r5
  float v26; // s28
  float v27; // r5
  float v28; // s28
  int v29; // r0
  bool v30; // zf
  CVector2D *v31; // r0
  float x; // s30
  float y; // s28
  float v34; // s17
  float v35; // r0
  int v36; // r0
  bool v37; // zf
  SelectScreen::MenuSelection *v38; // r0
  char *v39; // r0
  _DWORD *v40; // r0
  int v41; // t1
  float opacity; // s2
  float v43; // s2
  unsigned int numEntries; // r0
  bool v45; // zf
  SelectScreen::MenuSelection *v46; // r0
  int *v47; // [sp+0h] [bp-78h]
  float v48; // [sp+4h] [bp-74h]
  float v49; // [sp+8h] [bp-70h] BYREF
  float v50; // [sp+Ch] [bp-6Ch]
  float v51; // [sp+14h] [bp-64h]

  if ( this->hasBack && BackPressed() )
  {
    (*((void (__fastcall **)(SelectScreen *))this->_vptr$MenuScreen + 9))(this);
    if ( !NeedsAmazonDownload() )
      sub_18FDC4(&AudioEngine, 2, 0.0, 1.0);
  }
  else
  {
    v7 = deltaTime;
    if ( this->items.numEntries )
    {
      if ( DownPressed() == 1 )
      {
        if ( (*((int (__fastcall **)(SelectScreen *))this->_vptr$MenuScreen + 14))(this) == 1 )
        {
          v8 = (this->selectedItem + 1) % this->items.numEntries;
        }
        else
        {
          v2.n64_f32[0] = (float)(this->selectedItem + 1);
          v3.n64_f32[0] = (float)(this->items.numEntries - 1);
          v2.n64_u64[0] = vmin_f32(v2, v3).n64_u64[0];
          v8 = (int)v2.n64_f32[0];
        }
        this->selectedItem = v8;
        if ( !NeedsAmazonDownload() )
          CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 3, 0.0, 1.0);
      }
      if ( UpPressed() )
      {
        v9 = (*((int (__fastcall **)(SelectScreen *))this->_vptr$MenuScreen + 14))(this);
        p_selectedItem = &this->selectedItem;
        selectedItem = this->selectedItem;
        if ( v9 == 1 )
        {
          v12 = (selectedItem + this->items.numEntries - 1) % this->items.numEntries;
        }
        else
        {
          v2.n64_u32[0] = 0;
          v3.n64_f32[0] = (float)(selectedItem - 1);
          v12 = (int)vmax_f32(v3, v2).n64_f32[0];
        }
        *p_selectedItem = v12;
        if ( !NeedsAmazonDownload() )
          CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 3, 0.0, 1.0);
      }
      else
      {
        p_selectedItem = &this->selectedItem;
      }
      if ( *p_selectedItem != -1 )
      {
        v13 = &this->selected.dataPtr[*p_selectedItem];
        *v13 = (float)(deltaTime + deltaTime) + *v13;
      }
      if ( this->selected.numEntries )
      {
        v3.n64_u32[0] = 1053609165;
        v14 = 0;
        v15 = 0;
        do
        {
          ++v15;
          v16 = &this->selected.dataPtr[v14++];
          v4.n64_f32[0] = *v16 - (float)(deltaTime * 0.5);
          v17 = vmin_f32(v4, v3).n64_u32[0];
          if ( v4.n64_f32[0] < 0.0 )
            v17 = 0;
          *(_DWORD *)v16 = v17;
        }
        while ( v15 < this->selected.numEntries );
      }
      if ( gMobileMenu.pointerMode && gMobileMenu.pointerState[lastDevice] != OSPS_ButtonDown )
      {
        v47 = p_selectedItem;
        v48 = deltaTime;
        v18 = COERCE_FLOAT((*((int (__fastcall **)(SelectScreen *))this->_vptr$MenuScreen + 16))(this));
        v19 = COERCE_FLOAT((*((int (__fastcall **)(SelectScreen *))this->_vptr$MenuScreen + 15))(this));
        if ( this->items.numEntries )
        {
          v20 = v18 + v19;
          v21 = 0;
          v22 = -1;
          do
          {
            v23 = COERCE_FLOAT((*((int (__fastcall **)(SelectScreen *, signed int))this->_vptr$MenuScreen + 17))(this, v21));
            if ( v21 == this->items.numEntries - 1 && v21 <= 7 && this->renderLastAtBottom )
              v20 = (*((float (__fastcall **)(SelectScreen *))this->_vptr$MenuScreen + 18))(this) + (float)(v23 * -1.5);
            (*((void (__fastcall **)(float *, SelectScreen *))this->_vptr$MenuScreen + 19))(&v49, this);
            v24 = 0;
            if ( v50 != 0.0 || v51 != 0.0 )
            {
              v25 = COERCE_FLOAT((*((int (__fastcall **)(SelectScreen *, signed int))this->_vptr$MenuScreen + 17))(this, v21));
              v26 = v51;
              if ( (float)(v20 + (float)(v25 * 0.5)) < (float)(v26
                                                             * (float)(480.0 / (float)(unsigned int)OS_ScreenGetHeight()))
                || (v27 = COERCE_FLOAT((*((int (__fastcall **)(SelectScreen *, signed int))this->_vptr$MenuScreen + 17))(this, v21)),
                    v28 = v50,
                    (float)(v20 + (float)(v27 * 0.5)) > (float)(v28
                                                              * (float)(480.0 / (float)(unsigned int)OS_ScreenGetHeight()))) )
              {
                v24 = 1;
              }
            }
            v29 = (*((int (__fastcall **)(SelectScreen *))this->_vptr$MenuScreen + 20))(this);
            v30 = !v24;
            if ( !v24 )
              v30 = v29 == 0;
            if ( v30 )
            {
              v31 = &gMobileMenu.bgUVSize + lastDevice;
              x = v31[14].x;
              y = v31[14].y;
              v34 = COERCE_FLOAT((*((int (__fastcall **)(SelectScreen *))this->_vptr$MenuScreen + 12))(this));
              v35 = COERCE_FLOAT((*((int (__fastcall **)(SelectScreen *))this->_vptr$MenuScreen + 13))(this));
              if ( x >= v34 && x <= v35 )
              {
                v36 = v22;
                if ( y <= (float)(v23 + v20) )
                  v36 = v21;
                if ( y >= v20 )
                  v22 = v36;
              }
            }
            v20 = v23 + v20;
            ++v21;
          }
          while ( v21 < this->items.numEntries );
        }
        else
        {
          v22 = -1;
        }
        deltaTime = v48;
        v37 = !gMobileMenu.pointerMode;
        if ( gMobileMenu.pointerMode )
          v37 = *v47 == v22;
        if ( !v37 )
        {
          if ( v22 != -1 )
          {
            if ( !NeedsAmazonDownload() )
              CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 3, 0.0, 1.0);
            if ( *v47 != -1 )
            {
              v38 = this->items.dataPtr[*v47];
              (*((void (__fastcall **)(SelectScreen::MenuSelection *))v38->_vptr$MenuSelection + 8))(v38);
            }
          }
          *v47 = v22;
          v39 = (char *)(&gMobileMenu.bgUVSize.x + lastDevice);
          v41 = *((_DWORD *)v39 + 36);
          v40 = v39 + 144;
          if ( !v41 )
            *v40 = 1;
        }
      }
    }
    opacity = this->opacity;
    if ( opacity < 1.0 )
    {
      v43 = (float)(v7 * 5.0) + opacity;
      this->opacity = v43;
      if ( v43 > 1.0 )
        this->opacity = 1.0;
    }
    numEntries = this->items.numEntries;
    v45 = numEntries == 0;
    if ( numEntries )
    {
      numEntries = this->selectedItem;
      v45 = numEntries == -1;
    }
    if ( !v45 )
    {
      v46 = this->items.dataPtr[numEntries];
      (*((void (__fastcall **)(SelectScreen::MenuSelection *, SelectScreen *, _DWORD))v46->_vptr$MenuSelection + 6))(
        v46,
        this,
        LODWORD(deltaTime));
    }
  }
}
// 29EF72: variable 'v2' is possibly undefined
// 29EF72: variable 'v3' is possibly undefined
// 29F03C: variable 'v4' is possibly undefined

//----- (0029F348) --------------------------------------------------------
void __fastcall SelectScreen::Render(SelectScreen *this, int stackPos)
{
  const unsigned __int8 *titleTag; // r6
  int v4; // r5
  float v5; // s16
  float v6; // s18
  GxtChar *v7; // r0
  float v8; // r5
  float v9; // r0
  float v10; // s23
  int v11; // r4
  signed int v12; // r8
  float v13; // s16
  float v14; // s22
  float v15; // s23
  float v16; // s0
  float v17; // s0
  float v18; // r9
  float v19; // r4
  float opacity; // s6
  float screenWidth; // s26
  float screenHeight; // s28
  SelectScreen::MenuSelection *v23; // r6
  void (__fastcall *v24)(SelectScreen::MenuSelection *, SelectScreen *, int, _DWORD, _DWORD, _DWORD, _DWORD); // r10
  int v25; // r9
  float v26; // r4
  float v27; // s22
  float v28; // s2
  float v29; // s0
  CVector2D v30; // [sp+14h] [bp-ACh]
  int v31; // [sp+34h] [bp-8Ch]
  CRGBA v32; // [sp+38h] [bp-88h] BYREF
  CRGBA v33; // [sp+3Ch] [bp-84h] BYREF
  CRGBA v34; // [sp+40h] [bp-80h] BYREF
  CRGBA v35; // [sp+44h] [bp-7Ch] BYREF
  CRect v36; // [sp+48h] [bp-78h] BYREF
  CRGBA v37; // [sp+5Ch] [bp-64h] BYREF

  titleTag = this->titleTag;
  CRGBA::CRGBA(&v37, 0xF0u, 0xF0u, 0xF0u, 0xFFu);
  v4 = (*((int (__fastcall **)(SelectScreen *))this->_vptr$MenuScreen + 12))(this);
  v5 = COERCE_FLOAT((*((int (__fastcall **)(SelectScreen *))this->_vptr$MenuScreen + 13))(this));
  v6 = COERCE_FLOAT((*((int (__fastcall **)(SelectScreen *))this->_vptr$MenuScreen + 12))(this));
  v7 = CText::Get(&TheText, titleTag);
  v32 = v37;
  v30.y = 38.0;
  v30.x = v5 - v6;
  MenuScreen::DrawTextDirect(
    (CVector2D *)&v36,
    this,
    v7,
    TA_Left,
    0,
    (CRGBA)&v32,
    1,
    (CVector2D)((unsigned int)v4 | 0x41F0000000000000LL),
    v30,
    0,
    0);
  CFont::RenderFontBuffer();
  (*((void (__fastcall **)(CRect *, SelectScreen *))this->_vptr$MenuScreen + 19))(&v36, this);
  CWidget::SetScissor(&v36);
  v8 = COERCE_FLOAT((*((int (__fastcall **)(SelectScreen *))this->_vptr$MenuScreen + 16))(this));
  v9 = COERCE_FLOAT((*((int (__fastcall **)(SelectScreen *))this->_vptr$MenuScreen + 15))(this));
  if ( this->items.numEntries )
  {
    v10 = v8 + v9;
    v11 = 0;
    v12 = 0;
    do
    {
      v13 = COERCE_FLOAT((*((int (__fastcall **)(SelectScreen *, signed int))this->_vptr$MenuScreen + 17))(this, v12));
      if ( v12 == this->items.numEntries - 1 && v12 <= 7 )
      {
        v14 = v10;
        if ( this->renderLastAtBottom )
          v14 = (*((float (__fastcall **)(SelectScreen *))this->_vptr$MenuScreen + 18))(this) + (float)(v13 * -1.5);
      }
      else
      {
        v14 = v10;
      }
      v15 = 1.0;
      if ( bInputDialogActive == 1 )
      {
        v15 = 0.0;
        if ( v12 == this->selectedItem )
        {
          v16 = OS_TimeAccurate() * 4.0;
          v15 = (float)((float)((float)(sinf(v16) + 1.0) * 0.5) * 0.67) + 0.33;
        }
      }
      v17 = *(float *)((char *)this->selected.dataPtr + v11);
      v31 = v11;
      if ( v17 == 0.0 )
      {
        v10 = v13 + v14;
      }
      else
      {
        CRGBA::CRGBA(&v32, 0xF0u, 0xF0u, 0xF0u, (unsigned int)(float)(v15 * (float)(v17 * 255.0)));
        CRGBA::CRGBA(
          &v33,
          0xF0u,
          0xF0u,
          0xF0u,
          (unsigned int)(float)(v15 * (float)(*(float *)((char *)this->selected.dataPtr + v11) * 255.0)));
        CRGBA::CRGBA(
          &v34,
          0xF0u,
          0xF0u,
          0xF0u,
          (unsigned int)(float)(v15 * (float)(*(float *)((char *)this->selected.dataPtr + v11) * 127.0)));
        CRGBA::CRGBA(
          &v35,
          0xF0u,
          0xF0u,
          0xF0u,
          (unsigned int)(float)(v15 * (float)(*(float *)((char *)this->selected.dataPtr + v11) * 127.0)));
        v18 = COERCE_FLOAT((*((int (__fastcall **)(SelectScreen *))this->_vptr$MenuScreen + 12))(this));
        v19 = COERCE_FLOAT((*((int (__fastcall **)(SelectScreen *))this->_vptr$MenuScreen + 13))(this));
        opacity = this->opacity;
        screenWidth = (float)RsGlobal.screenWidth;
        screenHeight = (float)RsGlobal.screenHeight;
        v32._anon_0._anon_0.alpha = (unsigned int)(float)(opacity * (float)v32._anon_0._anon_0.alpha);
        v35._anon_0._anon_0.alpha = (unsigned int)(float)(opacity * (float)v35._anon_0._anon_0.alpha);
        v34._anon_0._anon_0.alpha = (unsigned int)(float)(opacity * (float)v34._anon_0._anon_0.alpha);
        v33._anon_0._anon_0.alpha = (unsigned int)(float)(opacity * (float)v33._anon_0._anon_0.alpha);
        RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
        v10 = v13 + v14;
        maVertices[0].z = 1.0;
        maVertices[0].rhw = 1.0;
        maVertices[0].s = 0.0;
        maVertices[0].t = 0.0;
        maVertices[1].z = 1.0;
        maVertices[1].rhw = 1.0;
        maVertices[1].s = 1.0;
        maVertices[1].t = 0.0;
        *(CRGBA *)&maVertices[0].r = v32;
        maVertices[1].x = (float)(screenWidth * 0.5) + (float)((float)((float)(v19 + -320.0) * screenHeight) / 480.0);
        maVertices[1].y = (float)((float)(v14 + 4.0) * screenHeight) / 480.0;
        maVertices[0].x = (float)(screenWidth * 0.5)
                        + (float)((float)((float)((float)(v18 + -5.0) + -320.0) * screenHeight) / 480.0);
        maVertices[0].y = (float)((float)(v14 + 4.0) * screenHeight) / 480.0;
        *(CRGBA *)&maVertices[1].r = v33;
        maVertices[2].z = 1.0;
        maVertices[2].rhw = 1.0;
        maVertices[2].s = 0.0;
        maVertices[2].t = 1.0;
        maVertices[2].x = maVertices[0].x;
        maVertices[2].y = (float)((float)((float)(v13 + v14) + -4.0) * screenHeight) / 480.0;
        *(CRGBA *)&maVertices[2].r = v34;
        maVertices[3].z = 1.0;
        maVertices[3].rhw = 1.0;
        maVertices[3].s = 1.0;
        maVertices[3].t = 1.0;
        maVertices[3].x = maVertices[1].x;
        maVertices[3].y = maVertices[2].y;
        *(CRGBA *)&maVertices[3].r = v35;
        RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, maVertices, 4);
      }
      v23 = this->items.dataPtr[v12];
      v24 = (void (__fastcall *)(SelectScreen::MenuSelection *, SelectScreen *, int, _DWORD, _DWORD, _DWORD, _DWORD))*((_DWORD *)v23->_vptr$MenuSelection + 2);
      v25 = (*((int (__fastcall **)(SelectScreen *))this->_vptr$MenuScreen + 12))(this);
      v26 = v14;
      v27 = COERCE_FLOAT((*((int (__fastcall **)(SelectScreen *))this->_vptr$MenuScreen + 13))(this));
      v28 = 0.0;
      v29 = v27 - COERCE_FLOAT((*((int (__fastcall **)(SelectScreen *))this->_vptr$MenuScreen + 12))(this));
      if ( v12 == this->selectedItem )
        v28 = 1.0;
      v24(v23, this, v25, LODWORD(v26), v29 + -10.0, LODWORD(v13), LODWORD(v28));
      ++v12;
      v11 = v31 + 4;
    }
    while ( v12 < this->items.numEntries );
  }
  CFont::RenderFontBuffer();
  memset(&v36, 0, sizeof(v36));
  CWidget::SetScissor(&v36);
  if ( this->hasBack )
    (*((void (__fastcall **)(SelectScreen *, int))this->_vptr$MenuScreen + 10))(this, 1);
}
// 10: using guessed type __int16 word_10;
// 12: using guessed type __int16 word_12;
// 2C: using guessed type __int16 word_2C;
// 2E: using guessed type __int16 word_2E;
// 48: using guessed type int dword_48;
// 64: using guessed type int dword_64;
// 6E01B0: using guessed type char bInputDialogActive;

//----- (0029F860) --------------------------------------------------------
float __fastcall SelectScreen::GetMenuLeft(SelectScreen *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d2
  float result; // r0

  v2.n64_u32[0] = 20.0;
  v1.n64_f32[0] = (float)((float)((float)((float)((float)RsGlobal.screenWidth * 0.0) * 480.0)
                                + (float)((float)RsGlobal.screenWidth * -240.0))
                        / (float)RsGlobal.screenHeight)
                + 320.0;
  LODWORD(result) = vmax_f32(v1, v2).n64_u32[0];
  return result;
}
// 29F8A2: variable 'v1' is possibly undefined
// 29F8A2: variable 'v2' is possibly undefined

//----- (0029F8C0) --------------------------------------------------------
void __fastcall KeyboardControlsScreen::KeyboardControlsScreen(KeyboardControlsScreen *this)
{
  RwTexture *Texture; // r0

  this->hasBack = 1;
  this->_vptr$MenuScreen = (int (**)(void))&off_662590;
  Texture = TextureDatabaseRuntime::GetTexture("menu_selector");
  ++Texture->refCount;
  *(_QWORD *)((char *)&this->selected.numAlloced + 1) = 0LL;
  *(_QWORD *)((char *)&this->selected.dataPtr + 1) = 0LL;
  *(_QWORD *)&this->items.numAlloced = 0LL;
  *(_QWORD *)&this->items.dataPtr = 0LL;
  *(_QWORD *)&this->m_RectOnFoot.left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_RectOnFoot.right = 0x49742400C9742400LL;
  *(_QWORD *)&this->m_RectRestoreDefaults.left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_RectRestoreDefaults.right = 0x49742400C9742400LL;
  this->titleTag = (const unsigned __int8 *)&byte_61CADE;
  this->_vptr$MenuScreen = (int (**)(void))&off_662784;
  this->arrowTex = Texture;
  this->opacity = 0.0;
  *(_QWORD *)&this->m_RectInCar.left = 0xC974240049742400LL;
  this->m_RectInCar.right = -1000000.0;
  this->m_RectInCar.bottom = 1000000.0;
  bInputDialogActive = 0;
  this->m_MappingStructs.numAlloced = 0;
  this->m_MappingStructs.numEntries = 0;
  this->m_MappingStructs.dataPtr = 0;
  this->m_fAnchorY = 0.0;
  this->m_fScrollY = 0.0;
  this->m_nInitialTouchID = -1;
  this->m_bAutoScroll = 0;
  this->m_szHelpBottom[0] = 0;
  *(float *)((char *)&this->m_fConflictedOpacity + 2) = 0.0;
  *(float *)((char *)&this->m_fHelpOpacityBottom + 2) = 0.0;
  this->m_fHelpOpacityTop = 0.0;
  this->m_fHelpOpacityBottom = 0.0;
  if ( FindPlayerPed(-1) && FindPlayerPed(-1)->m_nPedState == PED_DRIVING )
  {
    this->m_nAdjustmentMode = 2;
    KeyboardControlsScreen::DoVehicleMappings(this);
  }
  else
  {
    this->m_nAdjustmentMode = 1;
    KeyboardControlsScreen::DoOnFootMappings(this);
  }
}
// 61CADE: using guessed type char byte_61CADE;
// 662590: using guessed type void *off_662590;
// 662784: using guessed type void *off_662784;
// 6E01B0: using guessed type char bInputDialogActive;

//----- (0029F9D4) --------------------------------------------------------
void __fastcall KeyboardControlsScreen::DoOnFootMappings(KeyboardControlsScreen *this)
{
  int v2; // r4
  unsigned int v3; // r6
  MappingStruct *dataPtr; // r9
  void *v5; // r0
  MappingStruct *v6; // r5
  unsigned int numEntries; // r0
  MappingStruct *v8; // r0
  MappingStruct *v9; // r5
  unsigned int v10; // r8
  unsigned int v11; // r10
  MappingStruct *v12; // r0
  MappingStruct *v13; // r6
  MappingStruct *v14; // r5
  MappingStruct *v15; // r5
  unsigned int v16; // r6
  unsigned int v17; // r10
  MappingStruct *v18; // r0
  MappingStruct *v19; // r8
  MappingStruct *v20; // r5
  MappingStruct *v21; // r5
  unsigned int v22; // r6
  unsigned int v23; // r10
  MappingStruct *v24; // r0
  MappingStruct *v25; // r8
  MappingStruct *v26; // r5
  MappingStruct *v27; // r5
  unsigned int v28; // r6
  unsigned int v29; // r10
  MappingStruct *v30; // r0
  MappingStruct *v31; // r8
  MappingStruct *v32; // r5
  MappingStruct *v33; // r5
  unsigned int v34; // r6
  unsigned int v35; // r10
  MappingStruct *v36; // r0
  MappingStruct *v37; // r8
  MappingStruct *v38; // r5
  MappingStruct *v39; // r5
  unsigned int v40; // r6
  unsigned int v41; // r10
  MappingStruct *v42; // r0
  MappingStruct *v43; // r8
  MappingStruct *v44; // r5
  MappingStruct *v45; // r5
  unsigned int v46; // r6
  unsigned int v47; // r10
  MappingStruct *v48; // r0
  MappingStruct *v49; // r8
  MappingStruct *v50; // r5
  MappingStruct *v51; // r5
  unsigned int v52; // r6
  unsigned int v53; // r10
  MappingStruct *v54; // r0
  MappingStruct *v55; // r8
  MappingStruct *v56; // r5
  MappingStruct *v57; // r5
  unsigned int v58; // r6
  unsigned int v59; // r10
  MappingStruct *v60; // r0
  MappingStruct *v61; // r8
  MappingStruct *v62; // r5
  MappingStruct *v63; // r5
  unsigned int v64; // r6
  unsigned int v65; // r10
  MappingStruct *v66; // r0
  MappingStruct *v67; // r8
  MappingStruct *v68; // r5
  MappingStruct *v69; // r5
  unsigned int v70; // r6
  unsigned int v71; // r10
  MappingStruct *v72; // r0
  MappingStruct *v73; // r8
  MappingStruct *v74; // r5
  MappingStruct *v75; // r5
  unsigned int v76; // r6
  unsigned int v77; // r10
  MappingStruct *v78; // r0
  MappingStruct *v79; // r8
  MappingStruct *v80; // r5
  MappingStruct *v81; // r5
  unsigned int v82; // r6
  unsigned int v83; // r10
  MappingStruct *v84; // r0
  MappingStruct *v85; // r8
  MappingStruct *v86; // r5
  MappingStruct *v87; // r5
  unsigned int v88; // r6
  unsigned int v89; // r10
  MappingStruct *v90; // r0
  MappingStruct *v91; // r8
  MappingStruct *v92; // r5
  MappingStruct *v93; // r5
  unsigned int v94; // r6
  unsigned int v95; // r10
  MappingStruct *v96; // r0
  MappingStruct *v97; // r8
  MappingStruct *v98; // r5
  MappingStruct *v99; // r5
  unsigned int v100; // r6
  unsigned int v101; // r10
  MappingStruct *v102; // r0
  MappingStruct *v103; // r8
  MappingStruct *v104; // r5
  MappingStruct *v105; // r5
  unsigned int v106; // r6
  unsigned int v107; // r10
  MappingStruct *v108; // r0
  MappingStruct *v109; // r8
  MappingStruct *v110; // r5
  MappingStruct *v111; // r5
  unsigned int v112; // r6
  unsigned int v113; // r10
  MappingStruct *v114; // r0
  MappingStruct *v115; // r8
  MappingStruct *v116; // r5
  MappingStruct *v117; // r5
  unsigned int v118; // r6
  unsigned int v119; // r10
  MappingStruct *v120; // r0
  MappingStruct *v121; // r8
  MappingStruct *v122; // r5
  MappingStruct *v123; // r5
  unsigned int v124; // r6
  unsigned int v125; // r10
  MappingStruct *v126; // r0
  MappingStruct *v127; // r8
  MappingStruct *v128; // r5
  MappingStruct *v129; // r5
  unsigned int v130; // r6
  unsigned int v131; // r10
  MappingStruct *v132; // r0
  MappingStruct *v133; // r8
  MappingStruct *v134; // r5
  MappingStruct *v135; // r5
  int v136; // r5
  unsigned int v137; // r6
  SelectScreen::MenuSelection *v138; // r1
  MappingStruct *v139; // r0
  _DWORD v140[130]; // [sp+8h] [bp-238h] BYREF
  OSArray<int> v141; // [sp+210h] [bp-30h] BYREF

  if ( this->m_MappingStructs.numEntries )
  {
    v2 = 520;
    v3 = 0;
    do
    {
      dataPtr = this->m_MappingStructs.dataPtr;
      v5 = *(void **)&dataPtr->m_szTag[v2 + 8];
      *(_DWORD *)&dataPtr->m_szTag[v2 + 4] = 0;
      if ( v5 )
      {
        free(v5);
        *(_DWORD *)&dataPtr->m_szTag[v2 + 8] = 0;
      }
      *(_DWORD *)&dataPtr->m_szTag[v2] = 0;
      v2 += 532;
      ++v3;
    }
    while ( v3 < this->m_MappingStructs.numEntries );
  }
  this->items.numEntries = 0;
  this->m_MappingStructs.numEntries = 0;
  memset(&v141, 0, sizeof(v141));
  v140[128] = 31;
  v140[64] = 1598181197;
  v140[0] = 1598181197;
  v140[1] = (char *)&loc_504D48 + 3;
  v140[65] = &loc_373558;
  LOBYTE(v140[129]) = 1;
  if ( this->m_MappingStructs.numAlloced )
  {
    v6 = this->m_MappingStructs.dataPtr;
    numEntries = 0;
  }
  else
  {
    v6 = (MappingStruct *)malloc(0x850u);
    v8 = this->m_MappingStructs.dataPtr;
    if ( v8 )
    {
      free(v8);
      numEntries = this->m_MappingStructs.numEntries;
    }
    else
    {
      numEntries = 0;
    }
    this->m_MappingStructs.dataPtr = v6;
    this->m_MappingStructs.numAlloced = 4;
  }
  v9 = &v6[numEntries];
  qmemcpy(v9, v140, 0x205u);
  OSArray<int>::OSArray(&v9->m_Whitelist, &v141);
  v10 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v10;
  v141.numEntries = 0;
  if ( v141.dataPtr )
  {
    free(v141.dataPtr);
    v141.dataPtr = 0;
    v10 = this->m_MappingStructs.numEntries;
  }
  memset(&v141, 0, sizeof(v141));
  v140[128] = 30;
  v140[64] = 1598181197;
  v140[0] = 1598181197;
  v140[1] = &loc_4C4D4A;
  v140[65] = (char *)&loc_353556 + 2;
  LOBYTE(v140[129]) = 1;
  if ( this->m_MappingStructs.numAlloced >= v10 + 1 )
  {
    v14 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v11 = 4 * (v10 + 1) / 3 + 3;
    v12 = (MappingStruct *)malloc(532 * v11);
    v13 = this->m_MappingStructs.dataPtr;
    v14 = v12;
    if ( v13 )
    {
      qmemcpy(v12, this->m_MappingStructs.dataPtr, 532 * v10);
      free(v13);
      v10 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v14;
    this->m_MappingStructs.numAlloced = v11;
  }
  v15 = &v14[v10];
  qmemcpy(v15, v140, 0x205u);
  OSArray<int>::OSArray(&v15->m_Whitelist, &v141);
  v16 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v16;
  v141.numEntries = 0;
  if ( v141.dataPtr )
  {
    free(v141.dataPtr);
    v141.dataPtr = 0;
    v16 = this->m_MappingStructs.numEntries;
  }
  memset(&v141, 0, sizeof(v141));
  v140[128] = 31;
  v140[64] = 1598181197;
  v140[0] = 1598181197;
  v140[1] = &loc_424D4A;
  v140[65] = (char *)&loc_383556 + 2;
  LOBYTE(v140[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v16 + 1 )
  {
    v20 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v17 = 4 * (v16 + 1) / 3 + 3;
    v18 = (MappingStruct *)malloc(532 * v17);
    v19 = this->m_MappingStructs.dataPtr;
    v20 = v18;
    if ( v19 )
    {
      qmemcpy(v18, this->m_MappingStructs.dataPtr, 532 * v16);
      free(v19);
      v16 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v20;
    this->m_MappingStructs.numAlloced = v17;
  }
  v21 = &v20[v16];
  qmemcpy(v21, v140, 0x205u);
  OSArray<int>::OSArray(&v21->m_Whitelist, &v141);
  v22 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v22;
  v141.numEntries = 0;
  if ( v141.dataPtr )
  {
    free(v141.dataPtr);
    v141.dataPtr = 0;
    v22 = this->m_MappingStructs.numEntries;
  }
  memset(&v141, 0, sizeof(v141));
  v140[128] = 30;
  v140[64] = 1598181197;
  v140[0] = 1598181197;
  v140[1] = (char *)&loc_524D48 + 3;
  v140[65] = &loc_363558;
  LOBYTE(v140[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v22 + 1 )
  {
    v26 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v23 = 4 * (v22 + 1) / 3 + 3;
    v24 = (MappingStruct *)malloc(532 * v23);
    v25 = this->m_MappingStructs.dataPtr;
    v26 = v24;
    if ( v25 )
    {
      qmemcpy(v24, this->m_MappingStructs.dataPtr, 532 * v22);
      free(v25);
      v22 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v26;
    this->m_MappingStructs.numAlloced = v23;
  }
  v27 = &v26[v22];
  qmemcpy(v27, v140, 0x205u);
  OSArray<int>::OSArray(&v27->m_Whitelist, &v141);
  v28 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v28;
  v141.numEntries = 0;
  if ( v141.dataPtr )
  {
    free(v141.dataPtr);
    v141.dataPtr = 0;
    v28 = this->m_MappingStructs.numEntries;
  }
  memset(&v141, 0, sizeof(v141));
  v140[128] = 1;
  v140[64] = 1598181197;
  v140[0] = 1598181197;
  v140[1] = &loc_54414A;
  v140[65] = (char *)&loc_303056 + 2;
  LOBYTE(v140[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v28 + 1 )
  {
    v32 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v29 = 4 * (v28 + 1) / 3 + 3;
    v30 = (MappingStruct *)malloc(532 * v29);
    v31 = this->m_MappingStructs.dataPtr;
    v32 = v30;
    if ( v31 )
    {
      qmemcpy(v30, this->m_MappingStructs.dataPtr, 532 * v28);
      free(v31);
      v28 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v32;
    this->m_MappingStructs.numAlloced = v29;
  }
  v33 = &v32[v28];
  qmemcpy(v33, v140, 0x205u);
  OSArray<int>::OSArray(&v33->m_Whitelist, &v141);
  v34 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v34;
  v141.numEntries = 0;
  if ( v141.dataPtr )
  {
    free(v141.dataPtr);
    v141.dataPtr = 0;
    v34 = this->m_MappingStructs.numEntries;
  }
  memset(&v141, 0, sizeof(v141));
  v140[128] = 5;
  v140[64] = 1598181197;
  v140[0] = 1598181197;
  v140[1] = (char *)&off_434548 + 3;
  v140[65] = &loc_313058;
  LOBYTE(v140[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v34 + 1 )
  {
    v38 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v35 = 4 * (v34 + 1) / 3 + 3;
    v36 = (MappingStruct *)malloc(532 * v35);
    v37 = this->m_MappingStructs.dataPtr;
    v38 = v36;
    if ( v37 )
    {
      qmemcpy(v36, this->m_MappingStructs.dataPtr, 532 * v34);
      free(v37);
      v34 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v38;
    this->m_MappingStructs.numAlloced = v35;
  }
  v39 = &v38[v34];
  qmemcpy(v39, v140, 0x205u);
  OSArray<int>::OSArray(&v39->m_Whitelist, &v141);
  v40 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v40;
  v141.numEntries = 0;
  if ( v141.dataPtr )
  {
    free(v141.dataPtr);
    v141.dataPtr = 0;
    v40 = this->m_MappingStructs.numEntries;
  }
  memset(&v141, 0, sizeof(v141));
  v140[128] = 2;
  v140[64] = 1598181197;
  v140[0] = 1598181197;
  v140[1] = (char *)&loc_505348 + 3;
  v140[65] = &loc_323058;
  LOBYTE(v140[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v40 + 1 )
  {
    v44 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v41 = 4 * (v40 + 1) / 3 + 3;
    v42 = (MappingStruct *)malloc(532 * v41);
    v43 = this->m_MappingStructs.dataPtr;
    v44 = v42;
    if ( v43 )
    {
      qmemcpy(v42, this->m_MappingStructs.dataPtr, 532 * v40);
      free(v43);
      v40 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v44;
    this->m_MappingStructs.numAlloced = v41;
  }
  v45 = &v44[v40];
  qmemcpy(v45, v140, 0x205u);
  OSArray<int>::OSArray(&v45->m_Whitelist, &v141);
  v46 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v46;
  v141.numEntries = 0;
  if ( v141.dataPtr )
  {
    free(v141.dataPtr);
    v141.dataPtr = 0;
    v46 = this->m_MappingStructs.numEntries;
  }
  memset(&v141, 0, sizeof(v141));
  v140[128] = 3;
  v140[64] = 1598181197;
  v140[0] = 1598181197;
  v140[1] = &loc_554A4A;
  v140[65] = (char *)&loc_333056 + 2;
  LOBYTE(v140[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v46 + 1 )
  {
    v50 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v47 = 4 * (v46 + 1) / 3 + 3;
    v48 = (MappingStruct *)malloc(532 * v47);
    v49 = this->m_MappingStructs.dataPtr;
    v50 = v48;
    if ( v49 )
    {
      qmemcpy(v48, this->m_MappingStructs.dataPtr, 532 * v46);
      free(v49);
      v46 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v50;
    this->m_MappingStructs.numAlloced = v47;
  }
  v51 = &v50[v46];
  qmemcpy(v51, v140, 0x205u);
  OSArray<int>::OSArray(&v51->m_Whitelist, &v141);
  v52 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v52;
  v141.numEntries = 0;
  if ( v141.dataPtr )
  {
    free(v141.dataPtr);
    v141.dataPtr = 0;
    v52 = this->m_MappingStructs.numEntries;
  }
  memset(&v141, 0, sizeof(v141));
  v140[128] = 16;
  v140[64] = 1598181197;
  v140[0] = 1598181197;
  v140[1] = &loc_57504A;
  v140[65] = (char *)&loc_343056 + 2;
  LOBYTE(v140[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v52 + 1 )
  {
    v56 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v53 = 4 * (v52 + 1) / 3 + 3;
    v54 = (MappingStruct *)malloc(532 * v53);
    v55 = this->m_MappingStructs.dataPtr;
    v56 = v54;
    if ( v55 )
    {
      qmemcpy(v54, this->m_MappingStructs.dataPtr, 532 * v52);
      free(v55);
      v52 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v56;
    this->m_MappingStructs.numAlloced = v53;
  }
  v57 = &v56[v52];
  qmemcpy(v57, v140, 0x205u);
  OSArray<int>::OSArray(&v57->m_Whitelist, &v141);
  v58 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v58;
  v141.numEntries = 0;
  if ( v141.dataPtr )
  {
    free(v141.dataPtr);
    v141.dataPtr = 0;
    v58 = this->m_MappingStructs.numEntries;
  }
  memset(&v141, 0, sizeof(v141));
  v140[128] = 15;
  v140[64] = 1598181197;
  v140[0] = 1598181197;
  v140[1] = &loc_574E4A;
  v140[65] = &word_353058;
  LOBYTE(v140[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v58 + 1 )
  {
    v62 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v59 = 4 * (v58 + 1) / 3 + 3;
    v60 = (MappingStruct *)malloc(532 * v59);
    v61 = this->m_MappingStructs.dataPtr;
    v62 = v60;
    if ( v61 )
    {
      qmemcpy(v60, this->m_MappingStructs.dataPtr, 532 * v58);
      free(v61);
      v58 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v62;
    this->m_MappingStructs.numAlloced = v59;
  }
  v63 = &v62[v58];
  qmemcpy(v63, v140, 0x205u);
  OSArray<int>::OSArray(&v63->m_Whitelist, &v141);
  v64 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v64;
  v141.numEntries = 0;
  if ( v141.dataPtr )
  {
    free(v141.dataPtr);
    v141.dataPtr = 0;
    v64 = this->m_MappingStructs.numEntries;
  }
  memset(&v141, 0, sizeof(v141));
  v140[128] = 4;
  v140[64] = 1598181197;
  v140[0] = 1598181197;
  v140[1] = &loc_52434A;
  v140[65] = (char *)&loc_363056 + 2;
  LOBYTE(v140[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v64 + 1 )
  {
    v68 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v65 = 4 * (v64 + 1) / 3 + 3;
    v66 = (MappingStruct *)malloc(532 * v65);
    v67 = this->m_MappingStructs.dataPtr;
    v68 = v66;
    if ( v67 )
    {
      qmemcpy(v66, this->m_MappingStructs.dataPtr, 532 * v64);
      free(v67);
      v64 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v68;
    this->m_MappingStructs.numAlloced = v65;
  }
  v69 = &v68[v64];
  qmemcpy(v69, v140, 0x205u);
  OSArray<int>::OSArray(&v69->m_Whitelist, &v141);
  v70 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v70;
  v141.numEntries = 0;
  if ( v141.dataPtr )
  {
    free(v141.dataPtr);
    v141.dataPtr = 0;
    v70 = this->m_MappingStructs.numEntries;
  }
  memset(&v141, 0, sizeof(v141));
  v140[128] = 9;
  v140[64] = 1598181197;
  v140[0] = 1598181197;
  v140[1] = (char *)&loc_434348 + 3;
  v140[65] = &loc_373058;
  LOBYTE(v140[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v70 + 1 )
  {
    v74 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v71 = 4 * (v70 + 1) / 3 + 3;
    v72 = (MappingStruct *)malloc(532 * v71);
    v73 = this->m_MappingStructs.dataPtr;
    v74 = v72;
    if ( v73 )
    {
      qmemcpy(v72, this->m_MappingStructs.dataPtr, 532 * v70);
      free(v73);
      v70 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v74;
    this->m_MappingStructs.numAlloced = v71;
  }
  v75 = &v74[v70];
  qmemcpy(v75, v140, 0x205u);
  OSArray<int>::OSArray(&v75->m_Whitelist, &v141);
  v76 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v76;
  v141.numEntries = 0;
  if ( v141.dataPtr )
  {
    free(v141.dataPtr);
    v141.dataPtr = 0;
    v76 = this->m_MappingStructs.numEntries;
  }
  memset(&v141, 0, sizeof(v141));
  v140[128] = 10;
  v140[64] = 1598181197;
  v140[0] = 1598181197;
  v140[1] = &byte_46434B;
  v140[65] = &loc_383058;
  LOBYTE(v140[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v76 + 1 )
  {
    v80 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v77 = 4 * (v76 + 1) / 3 + 3;
    v78 = (MappingStruct *)malloc(532 * v77);
    v79 = this->m_MappingStructs.dataPtr;
    v80 = v78;
    if ( v79 )
    {
      qmemcpy(v78, this->m_MappingStructs.dataPtr, 532 * v76);
      free(v79);
      v76 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v80;
    this->m_MappingStructs.numAlloced = v77;
  }
  v81 = &v80[v76];
  qmemcpy(v81, v140, 0x205u);
  OSArray<int>::OSArray(&v81->m_Whitelist, &v141);
  v82 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v82;
  v141.numEntries = 0;
  if ( v141.dataPtr )
  {
    free(v141.dataPtr);
    v141.dataPtr = 0;
    v82 = this->m_MappingStructs.numEntries;
  }
  memset(&v141, 0, sizeof(v141));
  v140[128] = 14;
  v140[64] = 1598181197;
  v140[0] = 1598181197;
  v140[1] = &loc_54534A;
  v140[65] = &loc_393058;
  LOBYTE(v140[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v82 + 1 )
  {
    v86 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v83 = 4 * (v82 + 1) / 3 + 3;
    v84 = (MappingStruct *)malloc(532 * v83);
    v85 = this->m_MappingStructs.dataPtr;
    v86 = v84;
    if ( v85 )
    {
      qmemcpy(v84, this->m_MappingStructs.dataPtr, 532 * v82);
      free(v85);
      v82 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v86;
    this->m_MappingStructs.numAlloced = v83;
  }
  v87 = &v86[v82];
  qmemcpy(v87, v140, 0x205u);
  OSArray<int>::OSArray(&v87->m_Whitelist, &v141);
  v88 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v88;
  v141.numEntries = 0;
  if ( v141.dataPtr )
  {
    free(v141.dataPtr);
    v141.dataPtr = 0;
    v88 = this->m_MappingStructs.numEntries;
  }
  memset(&v141, 0, sizeof(v141));
  v140[128] = 18;
  v140[64] = 1598181197;
  v140[0] = 1598181197;
  v140[1] = (char *)&loc_424C48 + 3;
  v140[65] = (char *)&loc_303156 + 2;
  LOBYTE(v140[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v88 + 1 )
  {
    v92 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v89 = 4 * (v88 + 1) / 3 + 3;
    v90 = (MappingStruct *)malloc(532 * v89);
    v91 = this->m_MappingStructs.dataPtr;
    v92 = v90;
    if ( v91 )
    {
      qmemcpy(v90, this->m_MappingStructs.dataPtr, 532 * v88);
      free(v91);
      v88 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v92;
    this->m_MappingStructs.numAlloced = v89;
  }
  v93 = &v92[v88];
  qmemcpy(v93, v140, 0x205u);
  OSArray<int>::OSArray(&v93->m_Whitelist, &v141);
  v94 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v94;
  v141.numEntries = 0;
  if ( v141.dataPtr )
  {
    free(v141.dataPtr);
    v141.dataPtr = 0;
    v94 = this->m_MappingStructs.numEntries;
  }
  memset(&v141, 0, sizeof(v141));
  v140[128] = 36;
  v140[64] = 1598181197;
  v140[0] = 1598181197;
  v140[1] = &loc_41544A;
  v140[65] = &loc_313158;
  LOBYTE(v140[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v94 + 1 )
  {
    v98 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v95 = 4 * (v94 + 1) / 3 + 3;
    v96 = (MappingStruct *)malloc(532 * v95);
    v97 = this->m_MappingStructs.dataPtr;
    v98 = v96;
    if ( v97 )
    {
      qmemcpy(v96, this->m_MappingStructs.dataPtr, 532 * v94);
      free(v97);
      v94 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v98;
    this->m_MappingStructs.numAlloced = v95;
  }
  v99 = &v98[v94];
  qmemcpy(v99, v140, 0x205u);
  OSArray<int>::OSArray(&v99->m_Whitelist, &v141);
  v100 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v100;
  v141.numEntries = 0;
  if ( v141.dataPtr )
  {
    free(v141.dataPtr);
    v141.dataPtr = 0;
    v100 = this->m_MappingStructs.numEntries;
  }
  memset(&v141, 0, sizeof(v141));
  v140[128] = 34;
  v140[64] = 1598181197;
  v140[0] = 1598181197;
  v140[1] = &loc_495A4A;
  v140[65] = &off_323158;
  LOBYTE(v140[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v100 + 1 )
  {
    v104 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v101 = 4 * (v100 + 1) / 3 + 3;
    v102 = (MappingStruct *)malloc(532 * v101);
    v103 = this->m_MappingStructs.dataPtr;
    v104 = v102;
    if ( v103 )
    {
      qmemcpy(v102, this->m_MappingStructs.dataPtr, 532 * v100);
      free(v103);
      v100 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v104;
    this->m_MappingStructs.numAlloced = v101;
  }
  v105 = &v104[v100];
  qmemcpy(v105, v140, 0x205u);
  OSArray<int>::OSArray(&v105->m_Whitelist, &v141);
  v106 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v106;
  v141.numEntries = 0;
  if ( v141.dataPtr )
  {
    free(v141.dataPtr);
    v141.dataPtr = 0;
    v106 = this->m_MappingStructs.numEntries;
  }
  memset(&v141, 0, sizeof(v141));
  v140[128] = 35;
  v140[64] = 1598181197;
  v140[0] = 1598181197;
  v140[1] = (char *)&loc_4F5A48 + 3;
  v140[65] = &loc_333158;
  LOBYTE(v140[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v106 + 1 )
  {
    v110 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v107 = 4 * (v106 + 1) / 3 + 3;
    v108 = (MappingStruct *)malloc(532 * v107);
    v109 = this->m_MappingStructs.dataPtr;
    v110 = v108;
    if ( v109 )
    {
      qmemcpy(v108, this->m_MappingStructs.dataPtr, 532 * v106);
      free(v109);
      v106 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v110;
    this->m_MappingStructs.numAlloced = v107;
  }
  v111 = &v110[v106];
  qmemcpy(v111, v140, 0x205u);
  OSArray<int>::OSArray(&v111->m_Whitelist, &v141);
  v112 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v112;
  v141.numEntries = 0;
  if ( v141.dataPtr )
  {
    free(v141.dataPtr);
    v141.dataPtr = 0;
    v112 = this->m_MappingStructs.numEntries;
  }
  memset(&v141, 0, sizeof(v141));
  v140[128] = 52;
  v140[64] = 1598181197;
  v140[0] = 1598181197;
  v140[1] = &loc_48504A;
  v140[65] = &loc_343158;
  LOBYTE(v140[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v112 + 1 )
  {
    v116 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v113 = 4 * (v112 + 1) / 3 + 3;
    v114 = (MappingStruct *)malloc(532 * v113);
    v115 = this->m_MappingStructs.dataPtr;
    v116 = v114;
    if ( v115 )
    {
      qmemcpy(v114, this->m_MappingStructs.dataPtr, 532 * v112);
      free(v115);
      v112 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v116;
    this->m_MappingStructs.numAlloced = v113;
  }
  v117 = &v116[v112];
  qmemcpy(v117, v140, 0x205u);
  OSArray<int>::OSArray(&v117->m_Whitelist, &v141);
  v118 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v118;
  v141.numEntries = 0;
  if ( v141.dataPtr )
  {
    free(v141.dataPtr);
    v141.dataPtr = 0;
    v118 = this->m_MappingStructs.numEntries;
  }
  memset(&v141, 0, sizeof(v141));
  v140[128] = 22;
  v140[64] = 1598181197;
  v140[0] = 1598181197;
  v140[1] = &loc_534D4A;
  v140[65] = &loc_353158;
  LOBYTE(v140[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v118 + 1 )
  {
    v122 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v119 = 4 * (v118 + 1) / 3 + 3;
    v120 = (MappingStruct *)malloc(532 * v119);
    v121 = this->m_MappingStructs.dataPtr;
    v122 = v120;
    if ( v121 )
    {
      qmemcpy(v120, this->m_MappingStructs.dataPtr, 532 * v118);
      free(v121);
      v118 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v122;
    this->m_MappingStructs.numAlloced = v119;
  }
  v123 = &v122[v118];
  qmemcpy(v123, v140, 0x205u);
  OSArray<int>::OSArray(&v123->m_Whitelist, &v141);
  v124 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v124;
  v141.numEntries = 0;
  if ( v141.dataPtr )
  {
    free(v141.dataPtr);
    v141.dataPtr = 0;
    v124 = this->m_MappingStructs.numEntries;
  }
  memset(&v141, 0, sizeof(v141));
  v140[128] = 42;
  v140[64] = 1598181197;
  v140[0] = 1598181197;
  v140[1] = &loc_52474A;
  v140[65] = (char *)&loc_393156 + 2;
  LOBYTE(v140[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v124 + 1 )
  {
    v128 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v125 = 4 * (v124 + 1) / 3 + 3;
    v126 = (MappingStruct *)malloc(532 * v125);
    v127 = this->m_MappingStructs.dataPtr;
    v128 = v126;
    if ( v127 )
    {
      qmemcpy(v126, this->m_MappingStructs.dataPtr, 532 * v124);
      free(v127);
      v124 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v128;
    this->m_MappingStructs.numAlloced = v125;
  }
  v129 = &v128[v124];
  qmemcpy(v129, v140, 0x205u);
  OSArray<int>::OSArray(&v129->m_Whitelist, &v141);
  v130 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v130;
  v141.numEntries = 0;
  if ( v141.dataPtr )
  {
    free(v141.dataPtr);
    v141.dataPtr = 0;
    v130 = this->m_MappingStructs.numEntries;
  }
  memset(&v141, 0, sizeof(v141));
  v140[128] = 43;
  v140[64] = 1598181197;
  v140[0] = 1598181197;
  v140[1] = (char *)&loc_494748 + 3;
  v140[65] = &loc_303258;
  LOBYTE(v140[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v130 + 1 )
  {
    v134 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v131 = 4 * (v130 + 1) / 3 + 3;
    v132 = (MappingStruct *)malloc(532 * v131);
    v133 = this->m_MappingStructs.dataPtr;
    v134 = v132;
    if ( v133 )
    {
      qmemcpy(v132, this->m_MappingStructs.dataPtr, 532 * v130);
      free(v133);
      v130 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v134;
    this->m_MappingStructs.numAlloced = v131;
  }
  v135 = &v134[v130];
  qmemcpy(v135, v140, 0x205u);
  OSArray<int>::OSArray(&v135->m_Whitelist, &v141);
  ++this->m_MappingStructs.numEntries;
  v141.numEntries = 0;
  if ( v141.dataPtr )
  {
    free(v141.dataPtr);
    v141.dataPtr = 0;
  }
  KeyboardControlsScreen::WhitelistAdd(this, HID_MAPPING_CAMERA_CLOSER, HID_MAPPING_WEAPON_ZOOM_IN);
  KeyboardControlsScreen::WhitelistAdd(this, HID_MAPPING_CAMERA_FARTHER, HID_MAPPING_WEAPON_ZOOM_OUT);
  KeyboardControlsScreen::WhitelistAdd(this, HID_MAPPING_PHONE, HID_MAPPING_GANG_RECRUIT);
  KeyboardControlsScreen::WhitelistAdd(this, HID_MAPPING_MISSION_START_AND_CANCEL, HID_MAPPING_GANG_IGNORE);
  if ( this->m_MappingStructs.numEntries )
  {
    v136 = 0;
    v137 = 0;
    do
    {
      v138 = (SelectScreen::MenuSelection *)operator new(0x10u);
      v139 = &this->m_MappingStructs.dataPtr[v136];
      v138->_vptr$MenuSelection = (int (**)(void))&off_6627E0;
      v138->tag = (const unsigned __int8 *)v139;
      v138[1]._vptr$MenuSelection = (int (**)(void))OnSelectKey;
      v138[1].tag = 0;
      SelectScreen::AddItem(this, v138);
      ++v137;
      ++v136;
    }
    while ( v137 < this->m_MappingStructs.numEntries );
  }
}
// 323158: using guessed type int (**off_323158)[16];
// 353058: using guessed type __int16;
// 434548: using guessed type int *off_434548;
// 46434B: using guessed type char;
// 6627E0: using guessed type void *;

//----- (002A0CAC) --------------------------------------------------------
void __fastcall KeyboardControlsScreen::DoVehicleMappings(KeyboardControlsScreen *this)
{
  int v2; // r4
  unsigned int v3; // r6
  MappingStruct *dataPtr; // r9
  void *v5; // r0
  MappingStruct *v6; // r5
  unsigned int numEntries; // r0
  MappingStruct *v8; // r0
  MappingStruct *v9; // r5
  unsigned int v10; // r8
  unsigned int v11; // r10
  MappingStruct *v12; // r0
  MappingStruct *v13; // r6
  MappingStruct *v14; // r5
  MappingStruct *v15; // r5
  unsigned int v16; // r6
  unsigned int v17; // r10
  MappingStruct *v18; // r0
  MappingStruct *v19; // r8
  MappingStruct *v20; // r5
  MappingStruct *v21; // r5
  unsigned int v22; // r6
  unsigned int v23; // r10
  MappingStruct *v24; // r0
  MappingStruct *v25; // r8
  MappingStruct *v26; // r5
  MappingStruct *v27; // r5
  unsigned int v28; // r6
  unsigned int v29; // r10
  MappingStruct *v30; // r0
  MappingStruct *v31; // r8
  MappingStruct *v32; // r5
  MappingStruct *v33; // r5
  unsigned int v34; // r6
  unsigned int v35; // r10
  MappingStruct *v36; // r0
  MappingStruct *v37; // r8
  MappingStruct *v38; // r5
  MappingStruct *v39; // r5
  unsigned int v40; // r6
  unsigned int v41; // r10
  MappingStruct *v42; // r0
  MappingStruct *v43; // r8
  MappingStruct *v44; // r5
  MappingStruct *v45; // r5
  unsigned int v46; // r6
  unsigned int v47; // r10
  MappingStruct *v48; // r0
  MappingStruct *v49; // r8
  MappingStruct *v50; // r5
  MappingStruct *v51; // r5
  unsigned int v52; // r6
  unsigned int v53; // r10
  MappingStruct *v54; // r0
  MappingStruct *v55; // r8
  MappingStruct *v56; // r5
  MappingStruct *v57; // r5
  unsigned int v58; // r6
  unsigned int v59; // r10
  MappingStruct *v60; // r0
  MappingStruct *v61; // r8
  MappingStruct *v62; // r5
  MappingStruct *v63; // r5
  unsigned int v64; // r6
  unsigned int v65; // r10
  MappingStruct *v66; // r0
  MappingStruct *v67; // r8
  MappingStruct *v68; // r5
  MappingStruct *v69; // r5
  unsigned int v70; // r6
  unsigned int v71; // r10
  MappingStruct *v72; // r0
  MappingStruct *v73; // r8
  MappingStruct *v74; // r5
  MappingStruct *v75; // r5
  unsigned int v76; // r6
  unsigned int v77; // r10
  MappingStruct *v78; // r0
  MappingStruct *v79; // r8
  MappingStruct *v80; // r5
  MappingStruct *v81; // r5
  unsigned int v82; // r6
  unsigned int v83; // r10
  MappingStruct *v84; // r0
  MappingStruct *v85; // r8
  MappingStruct *v86; // r5
  MappingStruct *v87; // r5
  unsigned int v88; // r6
  unsigned int v89; // r10
  MappingStruct *v90; // r0
  MappingStruct *v91; // r8
  MappingStruct *v92; // r5
  MappingStruct *v93; // r5
  unsigned int v94; // r6
  unsigned int v95; // r10
  MappingStruct *v96; // r0
  MappingStruct *v97; // r8
  MappingStruct *v98; // r5
  MappingStruct *v99; // r5
  unsigned int v100; // r6
  unsigned int v101; // r10
  MappingStruct *v102; // r0
  MappingStruct *v103; // r8
  MappingStruct *v104; // r5
  MappingStruct *v105; // r5
  unsigned int v106; // r6
  unsigned int v107; // r10
  MappingStruct *v108; // r0
  MappingStruct *v109; // r8
  MappingStruct *v110; // r5
  MappingStruct *v111; // r5
  unsigned int v112; // r6
  unsigned int v113; // r10
  MappingStruct *v114; // r0
  MappingStruct *v115; // r8
  MappingStruct *v116; // r5
  MappingStruct *v117; // r5
  unsigned int v118; // r6
  unsigned int v119; // r10
  MappingStruct *v120; // r0
  MappingStruct *v121; // r8
  MappingStruct *v122; // r5
  MappingStruct *v123; // r5
  unsigned int v124; // r6
  unsigned int v125; // r10
  MappingStruct *v126; // r0
  MappingStruct *v127; // r8
  MappingStruct *v128; // r5
  MappingStruct *v129; // r5
  unsigned int v130; // r6
  unsigned int v131; // r10
  MappingStruct *v132; // r0
  MappingStruct *v133; // r8
  MappingStruct *v134; // r5
  MappingStruct *v135; // r5
  unsigned int v136; // r6
  unsigned int v137; // r10
  MappingStruct *v138; // r0
  MappingStruct *v139; // r8
  MappingStruct *v140; // r5
  MappingStruct *v141; // r5
  unsigned int v142; // r6
  unsigned int v143; // r10
  MappingStruct *v144; // r0
  MappingStruct *v145; // r8
  MappingStruct *v146; // r5
  MappingStruct *v147; // r5
  unsigned int v148; // r6
  unsigned int v149; // r10
  MappingStruct *v150; // r0
  MappingStruct *v151; // r8
  MappingStruct *v152; // r5
  MappingStruct *v153; // r5
  unsigned int v154; // r6
  unsigned int v155; // r10
  MappingStruct *v156; // r0
  MappingStruct *v157; // r8
  MappingStruct *v158; // r5
  MappingStruct *v159; // r5
  unsigned int v160; // r6
  unsigned int v161; // r10
  MappingStruct *v162; // r0
  MappingStruct *v163; // r8
  MappingStruct *v164; // r5
  MappingStruct *v165; // r5
  unsigned int v166; // r6
  unsigned int v167; // r10
  MappingStruct *v168; // r0
  MappingStruct *v169; // r8
  MappingStruct *v170; // r5
  MappingStruct *v171; // r5
  unsigned int v172; // r6
  unsigned int v173; // r10
  MappingStruct *v174; // r0
  MappingStruct *v175; // r8
  MappingStruct *v176; // r5
  MappingStruct *v177; // r5
  unsigned int v178; // r6
  unsigned int v179; // r10
  MappingStruct *v180; // r0
  MappingStruct *v181; // r8
  MappingStruct *v182; // r5
  MappingStruct *v183; // r5
  int v184; // r5
  unsigned int v185; // r6
  SelectScreen::MenuSelection *v186; // r1
  MappingStruct *v187; // r0
  _DWORD v188[130]; // [sp+8h] [bp-238h] BYREF
  OSArray<int> v189; // [sp+210h] [bp-30h] BYREF

  if ( this->m_MappingStructs.numEntries )
  {
    v2 = 520;
    v3 = 0;
    do
    {
      dataPtr = this->m_MappingStructs.dataPtr;
      v5 = *(void **)&dataPtr->m_szTag[v2 + 8];
      *(_DWORD *)&dataPtr->m_szTag[v2 + 4] = 0;
      if ( v5 )
      {
        free(v5);
        *(_DWORD *)&dataPtr->m_szTag[v2 + 8] = 0;
      }
      *(_DWORD *)&dataPtr->m_szTag[v2] = 0;
      v2 += 532;
      ++v3;
    }
    while ( v3 < this->m_MappingStructs.numEntries );
  }
  this->items.numEntries = 0;
  this->m_MappingStructs.numEntries = 0;
  memset(&v189, 0, sizeof(v189));
  v188[128] = 8;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = &byte_43414B;
  v188[65] = &loc_313658;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced )
  {
    v6 = this->m_MappingStructs.dataPtr;
    numEntries = 0;
  }
  else
  {
    v6 = (MappingStruct *)malloc(0x850u);
    v8 = this->m_MappingStructs.dataPtr;
    if ( v8 )
    {
      free(v8);
      numEntries = this->m_MappingStructs.numEntries;
    }
    else
    {
      numEntries = 0;
    }
    this->m_MappingStructs.dataPtr = v6;
    this->m_MappingStructs.numAlloced = 4;
  }
  v9 = &v6[numEntries];
  qmemcpy(v9, v188, 0x205u);
  OSArray<int>::OSArray(&v9->m_Whitelist, &v189);
  v10 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v10;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v10 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 24;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = &loc_4C534A;
  v188[65] = &loc_393558;
  LOBYTE(v188[129]) = 1;
  if ( this->m_MappingStructs.numAlloced >= v10 + 1 )
  {
    v14 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v11 = 4 * (v10 + 1) / 3 + 3;
    v12 = (MappingStruct *)malloc(532 * v11);
    v13 = this->m_MappingStructs.dataPtr;
    v14 = v12;
    if ( v13 )
    {
      qmemcpy(v12, this->m_MappingStructs.dataPtr, 532 * v10);
      free(v13);
      v10 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v14;
    this->m_MappingStructs.numAlloced = v11;
  }
  v15 = &v14[v10];
  qmemcpy(v15, v188, 0x205u);
  OSArray<int>::OSArray(&v15->m_Whitelist, &v189);
  v16 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v16;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v16 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 6;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = (char *)&off_524248 + 3;
  v188[65] = &loc_323658;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v16 + 1 )
  {
    v20 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v17 = 4 * (v16 + 1) / 3 + 3;
    v18 = (MappingStruct *)malloc(532 * v17);
    v19 = this->m_MappingStructs.dataPtr;
    v20 = v18;
    if ( v19 )
    {
      qmemcpy(v18, this->m_MappingStructs.dataPtr, 532 * v16);
      free(v19);
      v16 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v20;
    this->m_MappingStructs.numAlloced = v17;
  }
  v21 = &v20[v16];
  qmemcpy(v21, v188, 0x205u);
  OSArray<int>::OSArray(&v21->m_Whitelist, &v189);
  v22 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v22;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v22 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 24;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = &loc_52534A;
  v188[65] = &loc_303658;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v22 + 1 )
  {
    v26 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v23 = 4 * (v22 + 1) / 3 + 3;
    v24 = (MappingStruct *)malloc(532 * v23);
    v25 = this->m_MappingStructs.dataPtr;
    v26 = v24;
    if ( v25 )
    {
      qmemcpy(v24, this->m_MappingStructs.dataPtr, 532 * v22);
      free(v25);
      v22 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v26;
    this->m_MappingStructs.numAlloced = v23;
  }
  v27 = &v26[v22];
  qmemcpy(v27, v188, 0x205u);
  OSArray<int>::OSArray(&v27->m_Whitelist, &v189);
  v28 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v28;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v28 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 5;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = (char *)&off_434548 + 3;
  v188[65] = (char *)&loc_353256 + 2;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v28 + 1 )
  {
    v32 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v29 = 4 * (v28 + 1) / 3 + 3;
    v30 = (MappingStruct *)malloc(532 * v29);
    v31 = this->m_MappingStructs.dataPtr;
    v32 = v30;
    if ( v31 )
    {
      qmemcpy(v30, this->m_MappingStructs.dataPtr, 532 * v28);
      free(v31);
      v28 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v32;
    this->m_MappingStructs.numAlloced = v29;
  }
  v33 = &v32[v28];
  qmemcpy(v33, v188, 0x205u);
  OSArray<int>::OSArray(&v33->m_Whitelist, &v189);
  v34 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v34;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v34 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 9;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = (char *)&loc_434348 + 3;
  v188[65] = &loc_363258;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v34 + 1 )
  {
    v38 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v35 = 4 * (v34 + 1) / 3 + 3;
    v36 = (MappingStruct *)malloc(532 * v35);
    v37 = this->m_MappingStructs.dataPtr;
    v38 = v36;
    if ( v37 )
    {
      qmemcpy(v36, this->m_MappingStructs.dataPtr, 532 * v34);
      free(v37);
      v34 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v38;
    this->m_MappingStructs.numAlloced = v35;
  }
  v39 = &v38[v34];
  qmemcpy(v39, v188, 0x205u);
  OSArray<int>::OSArray(&v39->m_Whitelist, &v189);
  v40 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v40;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v40 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 10;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = &byte_46434B;
  v188[65] = &loc_373258;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v40 + 1 )
  {
    v44 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v41 = 4 * (v40 + 1) / 3 + 3;
    v42 = (MappingStruct *)malloc(532 * v41);
    v43 = this->m_MappingStructs.dataPtr;
    v44 = v42;
    if ( v43 )
    {
      qmemcpy(v42, this->m_MappingStructs.dataPtr, 532 * v40);
      free(v43);
      v40 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v44;
    this->m_MappingStructs.numAlloced = v41;
  }
  v45 = &v44[v40];
  qmemcpy(v45, v188, 0x205u);
  OSArray<int>::OSArray(&v45->m_Whitelist, &v189);
  v46 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v46;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v46 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 12;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = &loc_50524A;
  v188[65] = &loc_383258;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v46 + 1 )
  {
    v50 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v47 = 4 * (v46 + 1) / 3 + 3;
    v48 = (MappingStruct *)malloc(532 * v47);
    v49 = this->m_MappingStructs.dataPtr;
    v50 = v48;
    if ( v49 )
    {
      qmemcpy(v48, this->m_MappingStructs.dataPtr, 532 * v46);
      free(v49);
      v46 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v50;
    this->m_MappingStructs.numAlloced = v47;
  }
  v51 = &v50[v46];
  qmemcpy(v51, v188, 0x205u);
  OSArray<int>::OSArray(&v51->m_Whitelist, &v189);
  v52 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v52;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v52 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 13;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = &loc_4E524A;
  v188[65] = (char *)&loc_393256 + 2;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v52 + 1 )
  {
    v56 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v53 = 4 * (v52 + 1) / 3 + 3;
    v54 = (MappingStruct *)malloc(532 * v53);
    v55 = this->m_MappingStructs.dataPtr;
    v56 = v54;
    if ( v55 )
    {
      qmemcpy(v54, this->m_MappingStructs.dataPtr, 532 * v52);
      free(v55);
      v52 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v56;
    this->m_MappingStructs.numAlloced = v53;
  }
  v57 = &v56[v52];
  qmemcpy(v57, v188, 0x205u);
  OSArray<int>::OSArray(&v57->m_Whitelist, &v189);
  v58 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v58;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v58 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 14;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = &loc_54534A;
  v188[65] = &loc_303358;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v58 + 1 )
  {
    v62 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v59 = 4 * (v58 + 1) / 3 + 3;
    v60 = (MappingStruct *)malloc(532 * v59);
    v61 = this->m_MappingStructs.dataPtr;
    v62 = v60;
    if ( v61 )
    {
      qmemcpy(v60, this->m_MappingStructs.dataPtr, 532 * v58);
      free(v61);
      v58 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v62;
    this->m_MappingStructs.numAlloced = v59;
  }
  v63 = &v62[v58];
  qmemcpy(v63, v188, 0x205u);
  OSArray<int>::OSArray(&v63->m_Whitelist, &v189);
  v64 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v64;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v64 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 7;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = &loc_42484A;
  v188[65] = &loc_313358;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v64 + 1 )
  {
    v68 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v65 = 4 * (v64 + 1) / 3 + 3;
    v66 = (MappingStruct *)malloc(532 * v65);
    v67 = this->m_MappingStructs.dataPtr;
    v68 = v66;
    if ( v67 )
    {
      qmemcpy(v66, this->m_MappingStructs.dataPtr, 532 * v64);
      free(v67);
      v64 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v68;
    this->m_MappingStructs.numAlloced = v65;
  }
  v69 = &v68[v64];
  qmemcpy(v69, v188, 0x205u);
  OSArray<int>::OSArray(&v69->m_Whitelist, &v189);
  v70 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v70;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v70 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 11;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = &loc_4E484A;
  v188[65] = (char *)&loc_323356 + 2;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v70 + 1 )
  {
    v74 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v71 = 4 * (v70 + 1) / 3 + 3;
    v72 = (MappingStruct *)malloc(532 * v71);
    v73 = this->m_MappingStructs.dataPtr;
    v74 = v72;
    if ( v73 )
    {
      qmemcpy(v72, this->m_MappingStructs.dataPtr, 532 * v70);
      free(v73);
      v70 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v74;
    this->m_MappingStructs.numAlloced = v71;
  }
  v75 = &v74[v70];
  qmemcpy(v75, v188, 0x205u);
  OSArray<int>::OSArray(&v75->m_Whitelist, &v189);
  v76 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v76;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v76 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 19;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = &loc_4C4C4A;
  v188[65] = &off_333358;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v76 + 1 )
  {
    v80 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v77 = 4 * (v76 + 1) / 3 + 3;
    v78 = (MappingStruct *)malloc(532 * v77);
    v79 = this->m_MappingStructs.dataPtr;
    v80 = v78;
    if ( v79 )
    {
      qmemcpy(v78, this->m_MappingStructs.dataPtr, 532 * v76);
      free(v79);
      v76 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v80;
    this->m_MappingStructs.numAlloced = v77;
  }
  v81 = &v80[v76];
  qmemcpy(v81, v188, 0x205u);
  OSArray<int>::OSArray(&v81->m_Whitelist, &v189);
  v82 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v82;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v82 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 20;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = (char *)&loc_524C48 + 3;
  v188[65] = &loc_343358;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v82 + 1 )
  {
    v86 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v83 = 4 * (v82 + 1) / 3 + 3;
    v84 = (MappingStruct *)malloc(532 * v83);
    v85 = this->m_MappingStructs.dataPtr;
    v86 = v84;
    if ( v85 )
    {
      qmemcpy(v84, this->m_MappingStructs.dataPtr, 532 * v82);
      free(v85);
      v82 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v86;
    this->m_MappingStructs.numAlloced = v83;
  }
  v87 = &v86[v82];
  qmemcpy(v87, v188, 0x205u);
  OSArray<int>::OSArray(&v87->m_Whitelist, &v189);
  v88 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v88;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v88 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 21;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = (char *)&loc_425648 + 3;
  v188[65] = &loc_353358;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v88 + 1 )
  {
    v92 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v89 = 4 * (v88 + 1) / 3 + 3;
    v90 = (MappingStruct *)malloc(532 * v89);
    v91 = this->m_MappingStructs.dataPtr;
    v92 = v90;
    if ( v91 )
    {
      qmemcpy(v90, this->m_MappingStructs.dataPtr, 532 * v88);
      free(v91);
      v88 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v92;
    this->m_MappingStructs.numAlloced = v89;
  }
  v93 = &v92[v88];
  qmemcpy(v93, v188, 0x205u);
  OSArray<int>::OSArray(&v93->m_Whitelist, &v189);
  v94 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v94;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v94 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 32;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = &loc_51454A;
  v188[65] = (char *)&loc_363356 + 2;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v94 + 1 )
  {
    v98 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v95 = 4 * (v94 + 1) / 3 + 3;
    v96 = (MappingStruct *)malloc(532 * v95);
    v97 = this->m_MappingStructs.dataPtr;
    v98 = v96;
    if ( v97 )
    {
      qmemcpy(v96, this->m_MappingStructs.dataPtr, 532 * v94);
      free(v97);
      v94 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v98;
    this->m_MappingStructs.numAlloced = v95;
  }
  v99 = &v98[v94];
  qmemcpy(v99, v188, 0x205u);
  OSArray<int>::OSArray(&v99->m_Whitelist, &v189);
  v100 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v100;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v100 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 23;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = (char *)off_4D5648 + 3;
  v188[65] = &loc_373358;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v100 + 1 )
  {
    v104 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v101 = 4 * (v100 + 1) / 3 + 3;
    v102 = (MappingStruct *)malloc(532 * v101);
    v103 = this->m_MappingStructs.dataPtr;
    v104 = v102;
    if ( v103 )
    {
      qmemcpy(v102, this->m_MappingStructs.dataPtr, 532 * v100);
      free(v103);
      v100 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v104;
    this->m_MappingStructs.numAlloced = v101;
  }
  v105 = &v104[v100];
  qmemcpy(v105, v188, 0x205u);
  OSArray<int>::OSArray(&v105->m_Whitelist, &v189);
  v106 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v106;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v106 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 86;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = (char *)&off_414648 + 3;
  v188[65] = &loc_383358;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v106 + 1 )
  {
    v110 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v107 = 4 * (v106 + 1) / 3 + 3;
    v108 = (MappingStruct *)malloc(532 * v107);
    v109 = this->m_MappingStructs.dataPtr;
    v110 = v108;
    if ( v109 )
    {
      qmemcpy(v108, this->m_MappingStructs.dataPtr, 532 * v106);
      free(v109);
      v106 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v110;
    this->m_MappingStructs.numAlloced = v107;
  }
  v111 = &v110[v106];
  qmemcpy(v111, v188, 0x205u);
  OSArray<int>::OSArray(&v111->m_Whitelist, &v189);
  v112 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v112;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v112 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 87;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = &loc_44464A;
  v188[65] = &loc_393358;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v112 + 1 )
  {
    v116 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v113 = 4 * (v112 + 1) / 3 + 3;
    v114 = (MappingStruct *)malloc(532 * v113);
    v115 = this->m_MappingStructs.dataPtr;
    v116 = v114;
    if ( v115 )
    {
      qmemcpy(v114, this->m_MappingStructs.dataPtr, 532 * v112);
      free(v115);
      v112 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v116;
    this->m_MappingStructs.numAlloced = v113;
  }
  v117 = &v116[v112];
  qmemcpy(v117, v188, 0x205u);
  OSArray<int>::OSArray(&v117->m_Whitelist, &v189);
  v118 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v118;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v118 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 88;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = (char *)&loc_504648 + 3;
  v188[65] = &loc_303458;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v118 + 1 )
  {
    v122 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v119 = 4 * (v118 + 1) / 3 + 3;
    v120 = (MappingStruct *)malloc(532 * v119);
    v121 = this->m_MappingStructs.dataPtr;
    v122 = v120;
    if ( v121 )
    {
      qmemcpy(v120, this->m_MappingStructs.dataPtr, 532 * v118);
      free(v121);
      v118 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v122;
    this->m_MappingStructs.numAlloced = v119;
  }
  v123 = &v122[v118];
  qmemcpy(v123, v188, 0x205u);
  OSArray<int>::OSArray(&v123->m_Whitelist, &v189);
  v124 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v124;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v124 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 89;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = (char *)&loc_534648 + 3;
  v188[65] = (char *)&loc_313456 + 2;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v124 + 1 )
  {
    v128 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v125 = 4 * (v124 + 1) / 3 + 3;
    v126 = (MappingStruct *)malloc(532 * v125);
    v127 = this->m_MappingStructs.dataPtr;
    v128 = v126;
    if ( v127 )
    {
      qmemcpy(v126, this->m_MappingStructs.dataPtr, 532 * v124);
      free(v127);
      v124 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v128;
    this->m_MappingStructs.numAlloced = v125;
  }
  v129 = &v128[v124];
  qmemcpy(v129, v188, 0x205u);
  OSArray<int>::OSArray(&v129->m_Whitelist, &v189);
  v130 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v130;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v130 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 53;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = &loc_494E4A;
  v188[65] = &loc_343458;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v130 + 1 )
  {
    v134 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v131 = 4 * (v130 + 1) / 3 + 3;
    v132 = (MappingStruct *)malloc(532 * v131);
    v133 = this->m_MappingStructs.dataPtr;
    v134 = v132;
    if ( v133 )
    {
      qmemcpy(v132, this->m_MappingStructs.dataPtr, 532 * v130);
      free(v133);
      v130 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v134;
    this->m_MappingStructs.numAlloced = v131;
  }
  v135 = &v134[v130];
  qmemcpy(v135, v188, 0x205u);
  OSArray<int>::OSArray(&v135->m_Whitelist, &v189);
  v136 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v136;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v136 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 85;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = &loc_484C4A;
  v188[65] = &loc_353458;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v136 + 1 )
  {
    v140 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v137 = 4 * (v136 + 1) / 3 + 3;
    v138 = (MappingStruct *)malloc(532 * v137);
    v139 = this->m_MappingStructs.dataPtr;
    v140 = v138;
    if ( v139 )
    {
      qmemcpy(v138, this->m_MappingStructs.dataPtr, 532 * v136);
      free(v139);
      v136 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v140;
    this->m_MappingStructs.numAlloced = v137;
  }
  v141 = &v140[v136];
  qmemcpy(v141, v188, 0x205u);
  OSArray<int>::OSArray(&v141->m_Whitelist, &v189);
  v142 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v142;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v142 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 54;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = &loc_55434A;
  v188[65] = &loc_373458;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v142 + 1 )
  {
    v146 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v143 = 4 * (v142 + 1) / 3 + 3;
    v144 = (MappingStruct *)malloc(532 * v143);
    v145 = this->m_MappingStructs.dataPtr;
    v146 = v144;
    if ( v145 )
    {
      qmemcpy(v144, this->m_MappingStructs.dataPtr, 532 * v142);
      free(v145);
      v142 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v146;
    this->m_MappingStructs.numAlloced = v143;
  }
  v147 = &v146[v142];
  qmemcpy(v147, v188, 0x205u);
  OSArray<int>::OSArray(&v147->m_Whitelist, &v189);
  v148 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v148;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v148 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 55;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = &loc_44434A;
  v188[65] = (char *)&loc_383456 + 2;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v148 + 1 )
  {
    v152 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v149 = 4 * (v148 + 1) / 3 + 3;
    v150 = (MappingStruct *)malloc(532 * v149);
    v151 = this->m_MappingStructs.dataPtr;
    v152 = v150;
    if ( v151 )
    {
      qmemcpy(v150, this->m_MappingStructs.dataPtr, 532 * v148);
      free(v151);
      v148 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v152;
    this->m_MappingStructs.numAlloced = v149;
  }
  v153 = &v152[v148];
  qmemcpy(v153, v188, 0x205u);
  OSArray<int>::OSArray(&v153->m_Whitelist, &v189);
  v154 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v154;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v154 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 50;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = &loc_43444A;
  v188[65] = &loc_393458;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v154 + 1 )
  {
    v158 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v155 = 4 * (v154 + 1) / 3 + 3;
    v156 = (MappingStruct *)malloc(532 * v155);
    v157 = this->m_MappingStructs.dataPtr;
    v158 = v156;
    if ( v157 )
    {
      qmemcpy(v156, this->m_MappingStructs.dataPtr, 532 * v154);
      free(v157);
      v154 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v158;
    this->m_MappingStructs.numAlloced = v155;
  }
  v159 = &v158[v154];
  qmemcpy(v159, v188, 0x205u);
  OSArray<int>::OSArray(&v159->m_Whitelist, &v189);
  v160 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v160;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v160 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 90;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = (char *)&loc_4C5048 + 3;
  v188[65] = &loc_333658;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v160 + 1 )
  {
    v164 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v161 = 4 * (v160 + 1) / 3 + 3;
    v162 = (MappingStruct *)malloc(532 * v161);
    v163 = this->m_MappingStructs.dataPtr;
    v164 = v162;
    if ( v163 )
    {
      qmemcpy(v162, this->m_MappingStructs.dataPtr, 532 * v160);
      free(v163);
      v160 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v164;
    this->m_MappingStructs.numAlloced = v161;
  }
  v165 = &v164[v160];
  qmemcpy(v165, v188, 0x205u);
  OSArray<int>::OSArray(&v165->m_Whitelist, &v189);
  v166 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v166;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v166 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 91;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = &algn_52504A[1];
  v188[65] = (char *)&loc_343656 + 2;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v166 + 1 )
  {
    v170 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v167 = 4 * (v166 + 1) / 3 + 3;
    v168 = (MappingStruct *)malloc(532 * v167);
    v169 = this->m_MappingStructs.dataPtr;
    v170 = v168;
    if ( v169 )
    {
      qmemcpy(v168, this->m_MappingStructs.dataPtr, 532 * v166);
      free(v169);
      v166 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v170;
    this->m_MappingStructs.numAlloced = v167;
  }
  v171 = &v170[v166];
  qmemcpy(v171, v188, 0x205u);
  OSArray<int>::OSArray(&v171->m_Whitelist, &v189);
  v172 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v172;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v172 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 92;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = &loc_55504A;
  v188[65] = &loc_353658;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v172 + 1 )
  {
    v176 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v173 = 4 * (v172 + 1) / 3 + 3;
    v174 = (MappingStruct *)malloc(532 * v173);
    v175 = this->m_MappingStructs.dataPtr;
    v176 = v174;
    if ( v175 )
    {
      qmemcpy(v174, this->m_MappingStructs.dataPtr, 532 * v172);
      free(v175);
      v172 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v176;
    this->m_MappingStructs.numAlloced = v173;
  }
  v177 = &v176[v172];
  qmemcpy(v177, v188, 0x205u);
  OSArray<int>::OSArray(&v177->m_Whitelist, &v189);
  v178 = this->m_MappingStructs.numEntries + 1;
  this->m_MappingStructs.numEntries = v178;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
    v178 = this->m_MappingStructs.numEntries;
  }
  memset(&v189, 0, sizeof(v189));
  v188[128] = 93;
  v188[64] = 1598181197;
  v188[0] = 1598181197;
  v188[1] = &loc_44504A;
  v188[65] = (char *)&loc_363656 + 2;
  LOBYTE(v188[129]) = 0;
  if ( this->m_MappingStructs.numAlloced >= v178 + 1 )
  {
    v182 = this->m_MappingStructs.dataPtr;
  }
  else
  {
    v179 = 4 * (v178 + 1) / 3 + 3;
    v180 = (MappingStruct *)malloc(532 * v179);
    v181 = this->m_MappingStructs.dataPtr;
    v182 = v180;
    if ( v181 )
    {
      qmemcpy(v180, this->m_MappingStructs.dataPtr, 532 * v178);
      free(v181);
      v178 = this->m_MappingStructs.numEntries;
    }
    this->m_MappingStructs.dataPtr = v182;
    this->m_MappingStructs.numAlloced = v179;
  }
  v183 = &v182[v178];
  qmemcpy(v183, v188, 0x205u);
  OSArray<int>::OSArray(&v183->m_Whitelist, &v189);
  ++this->m_MappingStructs.numEntries;
  v189.numEntries = 0;
  if ( v189.dataPtr )
  {
    free(v189.dataPtr);
    v189.dataPtr = 0;
  }
  KeyboardControlsScreen::WhitelistAdd(this, HID_MAPPING_HANDBRAKE, HID_MAPPING_FLIGHT_DESCEND);
  KeyboardControlsScreen::WhitelistAdd(this, HID_MAPPING_VEHICLE_LOOK_LEFT, HID_MAPPING_FLIGHT_SECONDARY_ATTACK);
  KeyboardControlsScreen::WhitelistAdd(this, HID_MAPPING_VEHICLE_LOOK_RIGHT, HID_MAPPING_FLIGHT_PRIMARY_ATTACK);
  KeyboardControlsScreen::WhitelistAdd(this, HID_MAPPING_VEHICLE_LOOK_RIGHT, HID_MAPPING_DROP_CRANE);
  KeyboardControlsScreen::WhitelistAdd(this, HID_MAPPING_AUTO_HYDRAULICS, HID_MAPPING_CRANE_UP);
  KeyboardControlsScreen::WhitelistAdd(this, HID_MAPPING_FLIGHT_PRIMARY_ATTACK, HID_MAPPING_DROP_CRANE);
  if ( this->m_MappingStructs.numEntries )
  {
    v184 = 0;
    v185 = 0;
    do
    {
      v186 = (SelectScreen::MenuSelection *)operator new(0x10u);
      v187 = &this->m_MappingStructs.dataPtr[v184];
      v186->_vptr$MenuSelection = (int (**)(void))&off_6627E0;
      v186->tag = (const unsigned __int8 *)v187;
      v186[1]._vptr$MenuSelection = (int (**)(void))OnSelectKey;
      v186[1].tag = 0;
      SelectScreen::AddItem(this, v186);
      ++v185;
      ++v184;
    }
    while ( v185 < this->m_MappingStructs.numEntries );
  }
}
// 333358: using guessed type int **off_333358;
// 414648: using guessed type CRope (**off_414648)[8];
// 43414B: using guessed type char;
// 434548: using guessed type int *off_434548;
// 46434B: using guessed type char byte_46434B;
// 4D5648: using guessed type CCoverPoint (**off_4D5648[4])[100];
// 524248: using guessed type int **off_524248;
// 6627E0: using guessed type void *off_6627E0;

//----- (002A2638) --------------------------------------------------------
void __fastcall KeyboardControlsScreen::~KeyboardControlsScreen(KeyboardControlsScreen *this)
{
  unsigned int numEntries; // r1
  int v3; // r6
  unsigned int v4; // r5
  MappingStruct *dataPtr; // r10
  void *v6; // r0
  MappingStruct *v7; // r0

  numEntries = this->m_MappingStructs.numEntries;
  this->_vptr$MenuScreen = (int (**)(void))&off_662784;
  if ( numEntries )
  {
    v3 = 520;
    v4 = 0;
    do
    {
      dataPtr = this->m_MappingStructs.dataPtr;
      v6 = *(void **)&dataPtr->m_szTag[v3 + 8];
      *(_DWORD *)&dataPtr->m_szTag[v3 + 4] = 0;
      if ( v6 )
      {
        free(v6);
        *(_DWORD *)&dataPtr->m_szTag[v3 + 8] = 0;
      }
      *(_DWORD *)&dataPtr->m_szTag[v3] = 0;
      v3 += 532;
      ++v4;
    }
    while ( v4 < this->m_MappingStructs.numEntries );
  }
  v7 = this->m_MappingStructs.dataPtr;
  this->m_MappingStructs.numEntries = 0;
  if ( v7 )
  {
    free(v7);
    this->m_MappingStructs.dataPtr = 0;
  }
  this->m_MappingStructs.numAlloced = 0;
  sub_19B7F4(this);
}
// 662784: using guessed type void *;

//----- (002A26B8) --------------------------------------------------------
void __fastcall KeyboardControlsScreen::~KeyboardControlsScreen(KeyboardControlsScreen *this)
{
  unsigned int numEntries; // r1
  int v3; // r6
  unsigned int v4; // r5
  MappingStruct *dataPtr; // r10
  void *v6; // r0
  MappingStruct *v7; // r0
  void *v8; // r0

  numEntries = this->m_MappingStructs.numEntries;
  this->_vptr$MenuScreen = (int (**)(void))&off_662784;
  if ( numEntries )
  {
    v3 = 520;
    v4 = 0;
    do
    {
      dataPtr = this->m_MappingStructs.dataPtr;
      v6 = *(void **)&dataPtr->m_szTag[v3 + 8];
      *(_DWORD *)&dataPtr->m_szTag[v3 + 4] = 0;
      if ( v6 )
      {
        free(v6);
        *(_DWORD *)&dataPtr->m_szTag[v3 + 8] = 0;
      }
      *(_DWORD *)&dataPtr->m_szTag[v3] = 0;
      v3 += 532;
      ++v4;
    }
    while ( v4 < this->m_MappingStructs.numEntries );
  }
  v7 = this->m_MappingStructs.dataPtr;
  this->m_MappingStructs.numEntries = 0;
  if ( v7 )
  {
    free(v7);
    this->m_MappingStructs.dataPtr = 0;
  }
  this->m_MappingStructs.numAlloced = 0;
  SelectScreen::~SelectScreen(this);
  sub_191374(v8);
}
// 2A2732: variable 'v8' is possibly undefined
// 662784: using guessed type void *off_662784;

//----- (002A273C) --------------------------------------------------------
void __fastcall KeyboardControlsScreen::Update(KeyboardControlsScreen *this, float deltaTime)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d2
  float32x2_t v5; // d3
  int selectedItem; // r0
  float m_fHelpOpacityTop; // r1
  float v10; // s16
  float32x2_t v11; // d1
  _BOOL4 m_bConflicts; // r0
  unsigned __int32 v13; // s2
  OSKeyboardKey v14; // r5
  OSPointerState v15; // r0
  MouseButtons v16; // r6
  float Wheel; // s0
  MouseButtons v19; // r2
  KeyboardControlsScreen *v20; // r0
  OSKeyboardKey v21; // r1
  float v22; // r8
  float v23; // r6
  __int64 v24; // r2
  __int64 v25; // r0
  int v26; // r0
  int m_nInitialTouchID; // r0
  int v28; // r0
  float opacity; // s2
  float v30; // s2
  int y; // [sp+8h] [bp-20h] BYREF
  int x[7]; // [sp+Ch] [bp-1Ch] BYREF

  selectedItem = this->selectedItem;
  if ( KeyboardControlsScreen::Update(float)::LastSelectedItem != (float)selectedItem )
  {
    strcpy((char *)this->m_szHelpBottom, (const char *)this->m_szHelpTop);
    selectedItem = this->selectedItem;
    m_fHelpOpacityTop = this->m_fHelpOpacityTop;
    this->m_fHelpOpacityTop = 0.0;
    this->m_fHelpOpacityBottom = m_fHelpOpacityTop;
    KeyboardControlsScreen::Update(float)::LastSelectedItem = (float)selectedItem;
  }
  v10 = deltaTime;
  if ( selectedItem == -1 )
  {
    v4.n64_u32[0] = 0;
    v2.n64_f32[0] = deltaTime * 3.0;
    v3.n64_f32[0] = this->m_fHelpOpacityTop - (float)(deltaTime * 3.0);
    v11.n64_u64[0] = vmax_f32(v3, v4).n64_u64[0];
  }
  else
  {
    strcpy((char *)this->m_szHelpTop, (const char *)this->m_MappingStructs.dataPtr[selectedItem].m_szHelpTag);
    v4.n64_u32[0] = 1.0;
    v2.n64_f32[0] = deltaTime * 3.0;
    v3.n64_f32[0] = (float)(deltaTime * 3.0) + this->m_fHelpOpacityTop;
    v11.n64_u64[0] = vmin_f32(v3, v4).n64_u64[0];
  }
  m_bConflicts = this->m_bConflicts;
  v4.n64_u32[0] = LODWORD(this->m_fConflictedOpacity);
  LODWORD(this->m_fHelpOpacityTop) = v11.n64_u32[0];
  if ( m_bConflicts )
  {
    v11.n64_u32[0] = 1.0;
    v4.n64_f32[0] = v2.n64_f32[0] + v4.n64_f32[0];
    v13 = vmin_f32(v4, v11).n64_u32[0];
  }
  else
  {
    v4.n64_f32[0] = v4.n64_f32[0] - v2.n64_f32[0];
    v11.n64_u32[0] = 0;
    v13 = vmax_f32(v4, v11).n64_u32[0];
  }
  v5.n64_u32[0] = 0;
  v2.n64_f32[0] = this->m_fHelpOpacityBottom - v2.n64_f32[0];
  LODWORD(this->m_fHelpOpacityBottom) = vmax_f32(v2, v5).n64_u32[0];
  LODWORD(this->m_fConflictedOpacity) = v13;
  if ( bInputDialogActive == 1 )
  {
    v14 = KK_ESCAPE;
    do
    {
      v15 = LIB_KeyboardState(v14);
      if ( v14 && v15 == OSPS_ButtonReleased )
      {
        v20 = this;
        v21 = v14;
        v19 = -1;
LABEL_28:
        sub_18E4B4(v20, v21, v19);
        return;
      }
      v16 = LEFT_MOUSE_BUTTON;
      if ( LIB_PointerGetButton(0, 0) )
      {
        v16 = RIGHT_MOUSE_BUTTON;
        if ( LIB_PointerGetButton(0, 1) )
        {
          v16 = MIDDLE_MOUSE_BUTTON;
          if ( LIB_PointerGetButton(0, 2) )
            continue;
        }
      }
      sub_18E4B4(this, KK_MAX, v16);
      return;
    }
    while ( v14++ < KK_BACKSPACE1 );
    Wheel = LIB_PointerGetWheel(0);
    if ( Wheel != 0.0 )
    {
      v19 = MOUSE_WHEEL_BACKWARD;
      v20 = this;
      v21 = KK_MAX;
      if ( Wheel > 0.0 )
        v19 = MOUSE_WHEEL_FORWARD;
      goto LABEL_28;
    }
    if ( this->hasBack && BackPressed() )
    {
      (*((void (__fastcall **)(KeyboardControlsScreen *))this->_vptr$MenuScreen + 9))(this);
      if ( !NeedsAmazonDownload() )
        sub_18FDC4(&AudioEngine, 2, 0.0, 1.0);
      return;
    }
    opacity = this->opacity;
    if ( opacity < 1.0 )
    {
      v30 = (float)(v10 * 5.0) + opacity;
      this->opacity = v30;
      if ( v30 > 1.0 )
        this->opacity = 1.0;
    }
  }
  else
  {
    KeyboardControlsScreen::ManageScrolling(this, deltaTime);
    SelectScreen::Update(this, deltaTime);
  }
  x[0] = 0;
  y = 0;
  LIB_PointerGetCoordinates(lastDevice, x, &y, 0);
  v22 = (float)y;
  v23 = (float)x[0];
  if ( gMobileMenu.pointerState[lastDevice] == OSPS_ButtonPressed && !bInputDialogActive )
  {
    v24 = *(_QWORD *)&this->m_RectRestoreDefaults.left;
    v25 = *(_QWORD *)&this->m_RectRestoreDefaults.right;
    this->m_nInitialTouchID = -1;
    if ( CWidget::IsInsideRect(v23, v22, *(float *)&v24, *((float *)&v24 + 1), *(float *)&v25, *((float *)&v25 + 1)) )
    {
      v26 = 2;
    }
    else if ( CWidget::IsInsideRect(
                v23,
                v22,
                this->m_RectOnFoot.left,
                this->m_RectOnFoot.top,
                this->m_RectOnFoot.right,
                this->m_RectOnFoot.bottom) == 1 )
    {
      v26 = 0;
    }
    else
    {
      if ( CWidget::IsInsideRect(
             v23,
             v22,
             this->m_RectInCar.left,
             this->m_RectInCar.top,
             this->m_RectInCar.right,
             this->m_RectInCar.bottom) != 1 )
        goto LABEL_39;
      v26 = 1;
    }
    this->m_nInitialTouchID = v26;
  }
LABEL_39:
  if ( gMobileMenu.pointerState[lastDevice] )
    return;
  m_nInitialTouchID = this->m_nInitialTouchID;
  if ( m_nInitialTouchID != 2 )
  {
LABEL_49:
    if ( m_nInitialTouchID
      || CWidget::IsInsideRect(
           v23,
           v22,
           this->m_RectOnFoot.left,
           this->m_RectOnFoot.top,
           this->m_RectOnFoot.right,
           this->m_RectOnFoot.bottom) != 1
      || this->m_nAdjustmentMode == 1 )
    {
      if ( this->m_nInitialTouchID != 1
        || CWidget::IsInsideRect(
             v23,
             v22,
             this->m_RectInCar.left,
             this->m_RectInCar.top,
             this->m_RectInCar.right,
             this->m_RectInCar.bottom) != 1
        || this->m_nAdjustmentMode == 2 )
      {
        return;
      }
      if ( !NeedsAmazonDownload() )
        CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 3, 0.0, 1.0);
      KeyboardControlsScreen::DoVehicleMappings(this);
      this->m_fScrollY = 0.0;
      v28 = 2;
    }
    else
    {
      if ( !NeedsAmazonDownload() )
        CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 3, 0.0, 1.0);
      KeyboardControlsScreen::DoOnFootMappings(this);
      this->m_fScrollY = 0.0;
      v28 = 1;
    }
    this->m_nAdjustmentMode = v28;
    return;
  }
  if ( CWidget::IsInsideRect(
         v23,
         v22,
         this->m_RectRestoreDefaults.left,
         this->m_RectRestoreDefaults.top,
         this->m_RectRestoreDefaults.right,
         this->m_RectRestoreDefaults.bottom) != 1 )
  {
    m_nInitialTouchID = this->m_nInitialTouchID;
    goto LABEL_49;
  }
  CHIDKeyboard::RestoreDefaultMappings();
  if ( CHID::m_pInstance[CHID::currentInstanceIndex] && CHID::GetInputType() == 2 )
    CHIDKeyboard::SaveMappingsToDisk((CHIDKeyboard *)CHID::m_pInstance[CHID::currentInstanceIndex]);
  if ( !NeedsAmazonDownload() )
    CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 1, 0.0, 1.0);
}
// 2A27CC: variable 'v3' is possibly undefined
// 2A27CC: variable 'v4' is possibly undefined
// 2A2824: variable 'v2' is possibly undefined
// 2A2824: variable 'v5' is possibly undefined
// 6E01B0: using guessed type char bInputDialogActive;
// 2A273C: using guessed type int x[7];

//----- (002A2B64) --------------------------------------------------------
void __fastcall KeyboardControlsScreen::Render(KeyboardControlsScreen *this, int stackPos)
{
  GxtChar *v3; // r0
  GxtChar *v4; // r0
  GxtChar *v5; // r0
  float opacity; // s2
  float screenWidth; // s18
  float screenHeight; // s20
  GxtChar *v9; // r6
  GxtChar *v10; // r5
  float v11; // s0
  float v12; // s2
  float v13; // s10
  float v14; // s6
  float v15; // s2
  float v16; // s4
  float v17; // s0
  float v18; // s12
  float v19; // s8
  float v20; // s10
  float v21; // s1
  float v22; // s6
  CRect *p_m_RectOnFoot; // r9
  const CRGBA *v24; // r0
  float left; // s18
  float right; // s20
  float v27; // s18
  CRGBA v28; // r0
  CRGBA v29; // r0
  float v30; // s16
  GxtChar *v31; // r0
  float StringWidth; // r0
  GxtChar *v33; // r0
  float v34; // r0
  GxtChar *v35; // r0
  float v36; // r0
  float v37; // s18
  float v38; // s20
  float v39; // s22
  float v40; // s0
  GxtChar *v41; // r0
  float v42; // s18
  float v43; // s20
  float v44; // s22
  float v45; // s0
  GxtChar *v46; // r0
  float v47; // s18
  float v48; // s20
  float v49; // s22
  float v50; // s0
  GxtChar *v51; // r0
  CRGBA v52; // [sp+24h] [bp-7Ch] BYREF
  CRGBA v53; // [sp+28h] [bp-78h] BYREF
  CRGBA v54; // [sp+2Ch] [bp-74h] BYREF
  CRGBA v55; // [sp+30h] [bp-70h] BYREF
  CVector2D color; // [sp+34h] [bp-6Ch] BYREF
  CRGBA v57; // [sp+3Ch] [bp-64h] BYREF
  CVector2D v58; // [sp+40h] [bp-60h] BYREF
  CRGBA v59; // [sp+48h] [bp-58h] BYREF
  CRGBA v60; // [sp+4Ch] [bp-54h] BYREF
  CRGBA v61; // [sp+50h] [bp-50h] BYREF
  CRGBA v62; // [sp+54h] [bp-4Ch] BYREF
  CRGBA v63; // [sp+58h] [bp-48h] BYREF
  CRGBA v64; // [sp+5Ch] [bp-44h] BYREF

  this->m_bConflicts = 0;
  SelectScreen::Render(this, stackPos);
  CRGBA::CRGBA(
    &v63,
    0xF0u,
    0xF0u,
    0xF0u,
    (unsigned int)(float)((float)(this->opacity * 255.0) * this->m_fHelpOpacityBottom));
  v3 = CText::Get(&TheText, this->m_szHelpBottom);
  LODWORD(color.x) = v63;
  MenuScreen::DrawTextDirect(
    &v58,
    this,
    v3,
    TA_Left,
    2,
    (CRGBA)&color,
    1,
    (CVector2D)0x43E6000041F00000LL,
    (CVector2D)0x4140000043F50000LL,
    0,
    0);
  CRGBA::CRGBA(
    &v62,
    0xF0u,
    0xF0u,
    0xF0u,
    (unsigned int)(float)((float)(this->opacity * 255.0) * this->m_fHelpOpacityTop));
  v4 = CText::Get(&TheText, this->m_szHelpTop);
  LODWORD(color.x) = v62;
  MenuScreen::DrawTextDirect(
    &v58,
    this,
    v4,
    TA_Left,
    2,
    (CRGBA)&color,
    1,
    (CVector2D)0x43E6000041F00000LL,
    (CVector2D)0x4140000043F50000LL,
    0,
    0);
  CRGBA::CRGBA(&v61, 0xFFu, 0, 0, (unsigned int)(float)((float)(this->opacity * 255.0) * this->m_fConflictedOpacity));
  v5 = CText::Get(&TheText, "MOB_X98");
  LODWORD(color.x) = v61;
  MenuScreen::DrawTextDirect(
    &v58,
    this,
    v5,
    TA_Left,
    2,
    (CRGBA)&color,
    1,
    (CVector2D)0x43DE800041F00000LL,
    (CVector2D)0x4140000043F50000LL,
    0,
    0);
  if ( bInputDialogActive == 1 )
  {
    CRGBA::CRGBA((CRGBA *)&v58, 0, 0, 0, 0x80u);
    CRGBA::CRGBA((CRGBA *)&v58.y, 0, 0, 0, 0x80u);
    CRGBA::CRGBA(&v59, 0x80u, 0x80u, 0x80u, 0xC0u);
    CRGBA::CRGBA(&v60, 0x80u, 0x80u, 0x80u, 0xC0u);
    opacity = this->opacity;
    HIBYTE(v58.x) = (unsigned int)(float)(opacity * (float)HIBYTE(v58.x));
    screenWidth = (float)RsGlobal.screenWidth;
    screenHeight = (float)RsGlobal.screenHeight;
    HIBYTE(v58.y) = (unsigned int)(float)(opacity * (float)HIBYTE(v58.y));
    v59._anon_0._anon_0.alpha = (unsigned int)(float)(opacity * (float)v59._anon_0._anon_0.alpha);
    v60._anon_0._anon_0.alpha = (unsigned int)(float)(opacity * (float)v60._anon_0._anon_0.alpha);
    RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
    *(float *)&maVertices[0].r = v58.x;
    maVertices[0].z = 1.0;
    maVertices[0].rhw = 1.0;
    maVertices[0].s = 0.0;
    maVertices[0].t = 0.0;
    maVertices[1].z = 1.0;
    maVertices[1].rhw = 1.0;
    maVertices[1].s = 1.0;
    maVertices[1].t = 0.0;
    maVertices[0].x = (float)(screenWidth * 0.5) + (float)((float)(screenHeight * -120.0) / 480.0);
    maVertices[0].y = (float)(screenHeight * 174.0) / 480.0;
    maVertices[1].x = (float)(screenWidth * 0.5) + (float)((float)(screenHeight * 120.0) / 480.0);
    maVertices[1].y = (float)(screenHeight * 174.0) / 480.0;
    *(float *)&maVertices[1].r = v58.y;
    maVertices[2].z = 1.0;
    maVertices[2].rhw = 1.0;
    maVertices[2].s = 0.0;
    maVertices[2].t = 1.0;
    maVertices[2].x = maVertices[0].x;
    maVertices[2].y = (float)(screenHeight * 274.0) / 480.0;
    *(CRGBA *)&maVertices[2].r = v59;
    maVertices[3].z = 1.0;
    maVertices[3].rhw = 1.0;
    maVertices[3].s = 1.0;
    maVertices[3].t = 1.0;
    maVertices[3].x = maVertices[1].x;
    maVertices[3].y = (float)(screenHeight * 274.0) / 480.0;
    *(CRGBA *)&maVertices[3].r = v60;
    RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, maVertices, 4);
    v9 = CText::Get(&TheText, "MOB_DLG");
    CRGBA::CRGBA(&v57, 0xF0u, 0xF0u, 0xF0u, 0xFFu);
    v64 = v57;
    MenuScreen::DrawTextDirect(
      &color,
      this,
      v9,
      TA_Left,
      1,
      (CRGBA)&v64,
      1,
      (CVector2D)0x4334000043520000LL,
      (CVector2D)0x41900000435C0000LL,
      1,
      0);
    v10 = CText::Get(&TheText, "MOB_ESC");
    CRGBA::CRGBA(&v55, 0xF0u, 0xF0u, 0xF0u, 0xFFu);
    v64 = v55;
    MenuScreen::DrawTextDirect(
      &color,
      this,
      v10,
      TA_Left,
      1,
      (CRGBA)&v64,
      1,
      (CVector2D)0x4370000043520000LL,
      (CVector2D)0x41900000435C0000LL,
      1,
      0);
  }
  v11 = (float)RsGlobal.screenWidth / 640.0;
  v12 = (float)RsGlobal.screenHeight / 448.0;
  v13 = v11 * 70.0;
  v14 = v12 * 70.0;
  v15 = v12 * 30.0;
  v16 = v11 * 18.0;
  v17 = v11 * 320.0;
  v18 = v13 * 0.1;
  v19 = v13 * 3.1;
  v20 = v13 * 1.5;
  v21 = v16 + v14;
  v22 = v14 - v16;
  this->m_RectOnFoot.left = v17 - v19;
  this->m_RectOnFoot.top = v21;
  this->m_RectOnFoot.right = v17 - v18;
  this->m_RectOnFoot.bottom = v22;
  this->m_RectInCar.left = v18 + v17;
  this->m_RectInCar.top = v21;
  this->m_RectInCar.right = v19 + v17;
  this->m_RectInCar.bottom = v22;
  this->m_RectRestoreDefaults.left = v17 - v20;
  this->m_RectRestoreDefaults.top = v16 + v15;
  this->m_RectRestoreDefaults.right = v20 + v17;
  this->m_RectRestoreDefaults.bottom = v15 - v16;
  if ( this->m_nAdjustmentMode == 1 )
    p_m_RectOnFoot = &this->m_RectOnFoot;
  else
    p_m_RectOnFoot = &this->m_RectInCar;
  CRGBA::CRGBA((CRGBA *)&v58, 0xF0u, 0xF0u, 0xF0u, (unsigned int)(float)(this->opacity * 102.0));
  CRGBA::CRGBA((CRGBA *)&color, 0x99u, 0xCCu, 0x99u, (unsigned int)(float)(this->opacity * 102.0));
  CRGBA::CRGBA(&v64, 0x99u, 0xCCu, 0x99u, (unsigned int)(float)(this->opacity * 50.8));
  CRGBA::CRGBA(&v54, 0x99u, 0xCCu, 0x99u, (unsigned int)(float)(this->opacity * 50.8));
  CSprite2d::DrawRect(p_m_RectOnFoot, (const CRGBA *)&v58, (const CRGBA *)&color, &v64, v24);
  left = this->m_RectOnFoot.left;
  right = this->m_RectOnFoot.right;
  CFont::SetBackground(0, 0);
  CFont::SetOrientation(0);
  v27 = fabsf(right - left) * 0.95;
  CFont::SetCentreSize(v27);
  CFont::SetProportional(1u);
  CFont::SetEdge(1);
  CFont::SetFontStyle(2u);
  CFont::SetWrapx((float)RsGlobal.screenWidth);
  CRGBA::CRGBA(&v53, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)(this->opacity * 255.0));
  CFont::SetColor(v28);
  CRGBA::CRGBA(&v52, 0, 0, 0, (unsigned int)(float)(this->opacity * 255.0));
  CFont::SetDropColor(v29);
  v30 = fabsf(this->m_RectOnFoot.top - this->m_RectOnFoot.bottom) * 0.03;
  CFont::SetScale(v30);
  v31 = CText::Get(&TheText, "HUD_FOT");
  if ( v31 )
  {
    StringWidth = CFont::GetStringWidth(v31, 1u, 0);
    if ( StringWidth > v27 )
    {
      v30 = v30 * (float)(v27 / StringWidth);
      CFont::SetScale(v30);
    }
  }
  v33 = CText::Get(&TheText, "HUD_VEH");
  if ( v33 )
  {
    v34 = CFont::GetStringWidth(v33, 1u, 0);
    if ( v34 > v27 )
    {
      v30 = v30 * (float)(v27 / v34);
      CFont::SetScale(v30);
    }
  }
  v35 = CText::Get(&TheText, "HUD_DEF");
  if ( v35 )
  {
    v36 = CFont::GetStringWidth(v35, 1u, 0);
    if ( v36 > v27 )
      CFont::SetScale(v30 * (float)(v27 / v36));
  }
  v37 = this->m_RectOnFoot.left;
  v38 = this->m_RectOnFoot.right;
  v39 = this->m_RectOnFoot.top + this->m_RectOnFoot.bottom;
  v40 = CFont::GetHeight(0) * 0.5;
  v41 = CText::Get(&TheText, "HUD_FOT");
  CFont::PrintString((float)(v37 + v38) * 0.5, (float)(v39 * 0.5) - v40, v41);
  CFont::RenderFontBuffer();
  v42 = this->m_RectInCar.left;
  v43 = this->m_RectInCar.right;
  v44 = this->m_RectInCar.top + this->m_RectInCar.bottom;
  v45 = CFont::GetHeight(0) * 0.5;
  v46 = CText::Get(&TheText, "HUD_VEH");
  CFont::PrintString((float)(v42 + v43) * 0.5, (float)(v44 * 0.5) - v45, v46);
  CFont::RenderFontBuffer();
  v47 = this->m_RectRestoreDefaults.left;
  v48 = this->m_RectRestoreDefaults.right;
  v49 = this->m_RectRestoreDefaults.top + this->m_RectRestoreDefaults.bottom;
  v50 = CFont::GetHeight(0) * 0.5;
  v51 = CText::Get(&TheText, "HUD_DEF");
  CFont::PrintString((float)(v47 + v48) * 0.5, (float)(v49 * 0.5) - v50, v51);
  CFont::RenderFontBuffer();
}
// 2A30FC: variable 'v24' is possibly undefined
// 2A3176: variable 'v28' is possibly undefined
// 2A3198: variable 'v29' is possibly undefined
// 6E01B0: using guessed type char bInputDialogActive;

//----- (002A33D0) --------------------------------------------------------
void __fastcall KeyboardControlsScreen::OnBack(KeyboardControlsScreen *this)
{
  if ( bInputDialogActive )
  {
    bInputDialogActive = 0;
  }
  else
  {
    if ( gMobileMenu.screenStack.numEntries >= 2 )
      (*((void (__fastcall **)(MenuScreen *, MenuScreen *))gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries
                                                                                         - 2]->_vptr$MenuScreen
       + 5))(
        gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 2],
        gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
    sub_191808(&gMobileMenu, 0, 0);
  }
}
// 6E01B0: using guessed type char bInputDialogActive;

//----- (002A3430) --------------------------------------------------------
float __fastcall KeyboardControlsScreen::GetMenuLeft(KeyboardControlsScreen *this)
{
  return 20.0;
}

//----- (002A3438) --------------------------------------------------------
bool __fastcall KeyboardControlsScreen::LoopSelections(KeyboardControlsScreen *this)
{
  return 0;
}

//----- (002A343C) --------------------------------------------------------
float __fastcall KeyboardControlsScreen::GetScrollY(KeyboardControlsScreen *this)
{
  return this->m_fScrollY;
}

//----- (002A3440) --------------------------------------------------------
float __fastcall KeyboardControlsScreen::GetStartY(KeyboardControlsScreen *this)
{
  return 120.0;
}

//----- (002A3448) --------------------------------------------------------
float __fastcall KeyboardControlsScreen::GetYSize(KeyboardControlsScreen *this, int item)
{
  float v3; // s16

  v3 = COERCE_FLOAT((*((int (__fastcall **)(KeyboardControlsScreen *))this->_vptr$MenuScreen + 18))(this));
  return (float)(v3 - (*((float (__fastcall **)(KeyboardControlsScreen *))this->_vptr$MenuScreen + 16))(this)) / 10.5;
}

//----- (002A3480) --------------------------------------------------------
float __fastcall KeyboardControlsScreen::GetEndY(KeyboardControlsScreen *this)
{
  return 410.0;
}

//----- (002A3488) --------------------------------------------------------
CRect *__fastcall KeyboardControlsScreen::GetScissorRect(CRect *retstr, KeyboardControlsScreen *this)
{
  float v4; // r6
  void *Height; // r8
  float v6; // s16
  float v7; // s18
  float v8; // s16
  float v9; // s18
  int Width; // s0
  CRect *result; // r0

  v4 = COERCE_FLOAT((*((int (__fastcall **)(KeyboardControlsScreen *))this->_vptr$MenuScreen + 16))(this));
  Height = OS_ScreenGetHeight();
  v6 = COERCE_FLOAT((*((int (__fastcall **)(KeyboardControlsScreen *))this->_vptr$MenuScreen + 18))(this));
  v7 = (float)(v6 - (*((float (__fastcall **)(KeyboardControlsScreen *))this->_vptr$MenuScreen + 16))(this)) / 480.0;
  v8 = (float)(v4 / 480.0) * (float)(unsigned int)Height;
  v9 = v7 * (float)(unsigned int)OS_ScreenGetHeight();
  Width = OS_ScreenGetWidth();
  result = 0;
  retstr->left = 0.0;
  retstr->top = v8 + v9;
  retstr->right = (float)(unsigned int)Width;
  retstr->bottom = v8;
  return result;
}

//----- (002A3520) --------------------------------------------------------
bool __fastcall KeyboardControlsScreen::IsScrolling(KeyboardControlsScreen *this)
{
  float m_fAnchorY; // s16
  bool v2; // r4

  m_fAnchorY = this->m_fAnchorY;
  v2 = 0;
  if ( m_fAnchorY != 0.0
    && fabsf(gMobileMenu.pointerCoords[lastDevice].y - m_fAnchorY) > (float)((*((float (__fastcall **)(KeyboardControlsScreen *, _DWORD))this->_vptr$MenuScreen
                                                                              + 17))(
                                                                               this,
                                                                               0)
                                                                           * 0.5) )
  {
    return 1;
  }
  return v2;
}

//----- (002A3588) --------------------------------------------------------
void __fastcall KeyboardControlsScreen::WhitelistAdd(
        KeyboardControlsScreen *this,
        HIDMapping Mapping0,
        HIDMapping Mapping1)
{
  unsigned int numEntries; // r12
  int v5; // r5
  unsigned int v6; // r4
  int v7; // r6
  HIDMapping *p_m_Mapping; // r3
  HIDMapping v9; // r0
  bool v10; // zf
  MappingStruct *v11; // r4
  unsigned int v12; // r11
  unsigned int *p_numEntries; // r2
  int *v14; // r0
  int *v15; // r8
  int **p_dataPtr; // r4
  int *dataPtr; // r9
  MappingStruct *v18; // r4
  unsigned int v19; // r5
  unsigned int *v20; // r8
  unsigned int v21; // r11
  int *v22; // r0
  int *v23; // r9
  int **v24; // r4
  int *v25; // r10
  unsigned int v26; // [sp+0h] [bp-28h]
  OSArray<int> *p_m_Whitelist; // [sp+4h] [bp-24h]
  unsigned int *v28; // [sp+8h] [bp-20h]
  OSArray<int> *v29; // [sp+8h] [bp-20h]

  numEntries = this->m_MappingStructs.numEntries;
  if ( numEntries )
  {
    v5 = -1;
    v6 = 0;
    v7 = -1;
    p_m_Mapping = &this->m_MappingStructs.dataPtr->m_Mapping;
    do
    {
      v9 = *p_m_Mapping;
      p_m_Mapping += 133;
      if ( v9 == Mapping1 )
        v5 = v6;
      if ( v9 == Mapping0 )
        v7 = v6;
      ++v6;
    }
    while ( v6 < numEntries );
    v10 = v7 == -1;
    if ( v7 != -1 )
      v10 = v5 == -1;
    if ( !v10 )
    {
      v11 = &this->m_MappingStructs.dataPtr[v7];
      v12 = v11->m_Whitelist.numEntries;
      p_numEntries = &v11->m_Whitelist.numEntries;
      if ( v11->m_Whitelist.numAlloced >= v12 + 1 )
      {
        dataPtr = v11->m_Whitelist.dataPtr;
      }
      else
      {
        p_m_Whitelist = &v11->m_Whitelist;
        v28 = &v11->m_Whitelist.numEntries;
        v26 = 4 * (v12 + 1) / 3 + 3;
        v14 = (int *)malloc(4 * v26);
        v15 = v11->m_Whitelist.dataPtr;
        p_dataPtr = &v11->m_Whitelist.dataPtr;
        dataPtr = v14;
        if ( v15 )
        {
          qmemcpy(v14, v15, 4 * v12);
          free(v15);
          p_numEntries = v28;
          v12 = *v28;
        }
        else
        {
          p_numEntries = v28;
        }
        p_m_Whitelist->numAlloced = v26;
        *p_dataPtr = dataPtr;
      }
      dataPtr[v12] = v5;
      ++*p_numEntries;
      v18 = &this->m_MappingStructs.dataPtr[v5];
      v19 = v18->m_Whitelist.numEntries;
      v20 = &v18->m_Whitelist.numEntries;
      if ( v18->m_Whitelist.numAlloced >= v19 + 1 )
      {
        v25 = v18->m_Whitelist.dataPtr;
      }
      else
      {
        v29 = &v18->m_Whitelist;
        v21 = 4 * (v19 + 1) / 3 + 3;
        v22 = (int *)malloc(4 * v21);
        v23 = v18->m_Whitelist.dataPtr;
        v24 = &v18->m_Whitelist.dataPtr;
        v25 = v22;
        if ( v23 )
        {
          qmemcpy(v22, v23, 4 * v19);
          free(v23);
          v19 = *v20;
        }
        v29->numAlloced = v21;
        *v24 = v25;
      }
      v25[v19] = v7;
      ++*v20;
    }
  }
}

//----- (002A36E2) --------------------------------------------------------
void __fastcall OSArray<int>::OSArray(OSArray<int> *this, const OSArray<int> *other)
{
  const OSArray<int> *v3; // r11
  unsigned int numEntries; // r6
  int *v5; // r0
  unsigned int v6; // r9
  unsigned int v7; // r5
  int *dataPtr; // r10
  unsigned int v9; // r8
  int *v10; // r0
  int *v11; // r11
  int *v12; // r6
  int v13; // r0
  const OSArray<int> *v14; // [sp+0h] [bp-20h]

  this->numAlloced = 0;
  this->numEntries = 0;
  v3 = other;
  this->dataPtr = 0;
  numEntries = other->numEntries;
  if ( numEntries )
  {
    v5 = (int *)malloc(4 * numEntries);
    this->numAlloced = numEntries;
    this->dataPtr = v5;
    if ( v3->numEntries )
    {
      v6 = 0;
      v7 = 0;
      v14 = v3;
      while ( 1 )
      {
        dataPtr = v3->dataPtr;
        if ( numEntries >= v6 + 1 )
        {
          v12 = this->dataPtr;
        }
        else
        {
          v9 = 4 * (v6 + 1) / 3 + 3;
          v10 = (int *)malloc(4 * v9);
          v11 = this->dataPtr;
          v12 = v10;
          if ( v11 )
          {
            qmemcpy(v10, this->dataPtr, 4 * v6);
            free(v11);
            v6 = this->numEntries;
          }
          v3 = v14;
          this->dataPtr = v12;
          this->numAlloced = v9;
        }
        v13 = dataPtr[v7++];
        v12[v6] = v13;
        v6 = this->numEntries + 1;
        this->numEntries = v6;
        if ( v7 >= v3->numEntries )
          break;
        numEntries = this->numAlloced;
      }
    }
  }
}

//----- (002A37A4) --------------------------------------------------------
void __fastcall KeyboardControlsScreen::KeyboardMappingSelection::Render(
        KeyboardControlsScreen::KeyboardMappingSelection *this,
        SelectScreen *fromScreen,
        CVector2D location,
        CVector2D bounds,
        float selectAlpha)
{
  float y; // r6
  float v8; // s16
  _BOOL4 IsConflictedControl; // r6
  GxtChar *v10; // r2
  GxtChar *MappingFromTag; // r5
  GxtChar *v12; // r2
  GxtChar *v13; // r2
  CVector2D position; // [sp+Ch] [bp-64h]
  CVector2D v15; // [sp+14h] [bp-5Ch]
  CVector2D v16; // [sp+14h] [bp-5Ch]
  CVector2D v17; // [sp+14h] [bp-5Ch]
  CVector2D v18; // [sp+14h] [bp-5Ch]
  CRGBA v19; // [sp+28h] [bp-48h] BYREF
  CRGBA v20; // [sp+2Ch] [bp-44h] BYREF
  CVector2D v21; // [sp+30h] [bp-40h] BYREF
  CRGBA x_low; // [sp+38h] [bp-38h] BYREF
  int color[13]; // [sp+3Ch] [bp-34h] BYREF

  y = location.y;
  CRGBA::CRGBA(&x_low, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
  v8 = (float)((float)((float)(bounds.y * 0.5) + y) + -8.0) - selectAlpha;
  if ( bInputDialogActive == 1 )
  {
    if ( selectAlpha <= 0.0 )
      CRGBA::CRGBA((CRGBA *)&v21, 0x80u, 0x80u, 0x80u, 0x80u);
    else
      CRGBA::CRGBA((CRGBA *)&v21, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
    x_low = (CRGBA)LODWORD(v21.x);
  }
  IsConflictedControl = KeyboardControlsScreen::IsConflictedControl((KeyboardControlsScreen *)fromScreen, this->tag);
  v10 = (GxtChar *)(*((int (__fastcall **)(KeyboardControlsScreen::KeyboardMappingSelection *))this->_vptr$MenuSelection
                    + 5))(this);
  color[0] = (int)x_low;
  v15.x = 300.0;
  v15.y = (float)(selectAlpha + selectAlpha) + 16.0;
  if ( IsConflictedControl )
  {
    MenuScreen::DrawTextDirect(
      &v21,
      fromScreen,
      v10,
      TA_Left,
      2,
      (CRGBA)color,
      1,
      (CVector2D)__PAIR64__(LODWORD(v8), 1108082688),
      v15,
      0,
      0);
    MappingFromTag = KeyboardControlsScreen::GetMappingFromTag((KeyboardControlsScreen *)fromScreen, this->tag);
    CRGBA::CRGBA(&v20, 0xFFu, 0, 0, 0xFFu);
    color[0] = (int)v20;
    v16.x = 280.0;
    v16.y = (float)(selectAlpha + selectAlpha) + 16.0;
    position.x = 345.0;
    position.y = v8;
    MenuScreen::DrawTextDirect(&v21, fromScreen, MappingFromTag, TA_Right, 2, (CRGBA)color, 1, position, v16, 0, 0);
    CRGBA::CRGBA(&v19, 0xFFu, 0, 0, 0xFFu);
    v12 = CText::Get(&TheText, "MOB_X99");
    color[0] = (int)v19;
    v17.x = 10.0;
    v17.y = (float)(selectAlpha + selectAlpha) + 16.0;
    MenuScreen::DrawTextDirect(
      &v21,
      fromScreen,
      v12,
      TA_Left,
      2,
      (CRGBA)color,
      1,
      (CVector2D)__PAIR64__(LODWORD(v8), 1101004800),
      v17,
      0,
      0);
  }
  else
  {
    MenuScreen::DrawTextDirect(
      &v21,
      fromScreen,
      v10,
      TA_Left,
      2,
      (CRGBA)color,
      1,
      (CVector2D)__PAIR64__(LODWORD(v8), 1101004800),
      v15,
      0,
      0);
    v13 = KeyboardControlsScreen::GetMappingFromTag((KeyboardControlsScreen *)fromScreen, this->tag);
    color[0] = (int)x_low;
    v18.x = 280.0;
    v18.y = (float)(selectAlpha + selectAlpha) + 16.0;
    MenuScreen::DrawTextDirect(
      &v21,
      fromScreen,
      v13,
      TA_Right,
      2,
      (CRGBA)color,
      1,
      (CVector2D)__PAIR64__(LODWORD(v8), 1135378432),
      v18,
      0,
      0);
  }
}
// 6E01B0: using guessed type char bInputDialogActive;

//----- (002A39DC) --------------------------------------------------------
float __fastcall SelectScreen::MenuSelection::GetTextPercent(SelectScreen::MenuSelection *this)
{
  return 0.6;
}

//----- (002A39E6) --------------------------------------------------------
void __fastcall SelectScreen::MenuSelection::GetColor(CRGBA *a1, SelectScreen::MenuSelection *this)
{
  CRGBA::CRGBA(a1, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
}

//----- (002A3A00) --------------------------------------------------------
GxtChar *__fastcall SelectScreen::MenuSelection::GetTitle(SelectScreen::MenuSelection *this)
{
  const char *tag; // r4

  tag = (const char *)this->tag;
  if ( !strcmp(tag, "MOB_SCI") )
  {
    tag = "MOB_SCO";
    if ( !IsSCCloudAvailable() )
      tag = "MOB_SCI";
  }
  return sub_18A500(&TheText, (const unsigned __int8 *)tag);
}

//----- (002A3A48) --------------------------------------------------------
void __fastcall KeyboardControlsScreen::KeyboardMappingSelection::HandleInput(
        KeyboardControlsScreen::KeyboardMappingSelection *this,
        SelectScreen *fromScreen,
        float deltaTime)
{
  if ( CHID::Implements(HID_MAPPING_MENU_ACCEPT) && CHID::IsReleased(HID_MAPPING_MENU_ACCEPT)
    || gMobileMenu.pointerState[lastDevice] == OSPS_ButtonReleased )
  {
    if ( !NeedsAmazonDownload() )
      CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 1, 0.0, 1.0);
    this->OnSelect(fromScreen, this->data);
  }
}

//----- (002A3AB4) --------------------------------------------------------
void __fastcall SelectScreen::MenuSelection::Render(
        SelectScreen::MenuSelection *this,
        SelectScreen *fromScreen,
        CVector2D location,
        CVector2D bounds,
        float selectAlpha)
{
  float y; // r4
  float x; // r9
  float v9; // r6
  GxtChar *v10; // r10
  CVector2D v11; // [sp+Ch] [bp-44h]
  CVector2D v12; // [sp+14h] [bp-3Ch]
  CVector2D v13; // [sp+28h] [bp-28h] BYREF
  char v14[32]; // [sp+30h] [bp-20h] BYREF

  y = location.y;
  x = location.x;
  v9 = COERCE_FLOAT((*((int (__fastcall **)(SelectScreen::MenuSelection *))this->_vptr$MenuSelection + 3))(this));
  v10 = (GxtChar *)(*((int (__fastcall **)(SelectScreen::MenuSelection *))this->_vptr$MenuSelection + 5))(this);
  (*((void (__fastcall **)(char *, SelectScreen::MenuSelection *))this->_vptr$MenuSelection + 4))(v14, this);
  v12.y = (float)(selectAlpha + selectAlpha) + 16.0;
  v12.x = v9 * bounds.x;
  v11.x = x;
  v11.y = (float)((float)((float)(bounds.y * 0.5) + y) + -8.0) - selectAlpha;
  MenuScreen::DrawTextDirect(&v13, fromScreen, v10, TA_Left, 2, (CRGBA)v14, 1, v11, v12, 0, 0);
}

//----- (002A3B56) --------------------------------------------------------
bool __fastcall KeyboardControlsScreen::IsConflictedControl(
        KeyboardControlsScreen *this,
        const unsigned __int8 *pszTag)
{
  unsigned int numEntries; // r6
  int v5; // r5
  int v6; // r4
  GxtChar *MappingFromTag; // r6
  MappingStruct *v8; // r1
  unsigned int v9; // r0
  int *dataPtr; // r1
  int v11; // r2
  bool result; // r0

  numEntries = this->items.numEntries;
  if ( !numEntries )
    return 0;
  v5 = 0;
  while ( strcasecmp((const char *)this->items.dataPtr[v5]->tag, (const char *)pszTag) )
  {
LABEL_14:
    if ( ++v5 >= numEntries )
      return 0;
  }
  v6 = 0;
  while ( 1 )
  {
    if ( v5 != v6 )
    {
      MappingFromTag = KeyboardControlsScreen::GetMappingFromTag(this, pszTag);
      if ( MappingFromTag == KeyboardControlsScreen::GetMappingFromTag(this, this->m_MappingStructs.dataPtr[v6].m_szTag) )
        break;
    }
LABEL_11:
    numEntries = this->items.numEntries;
    if ( ++v6 >= numEntries )
      goto LABEL_14;
  }
  v8 = &this->m_MappingStructs.dataPtr[v5];
  v9 = v8->m_Whitelist.numEntries;
  if ( v9 )
  {
    dataPtr = v8->m_Whitelist.dataPtr;
    v11 = 0;
    while ( dataPtr[v11] != v6 )
    {
      if ( ++v11 >= v9 )
        goto LABEL_16;
    }
    goto LABEL_11;
  }
LABEL_16:
  result = 1;
  this->m_bConflicts = 1;
  return result;
}

//----- (002A3BF0) --------------------------------------------------------
GxtChar *__fastcall KeyboardControlsScreen::GetMappingFromTag(
        KeyboardControlsScreen *this,
        const unsigned __int8 *pszTag)
{
  unsigned int numEntries; // r5
  unsigned int v5; // r4
  MappingStruct *dataPtr; // r6
  CHIDKeyboard *v7; // r8

  if ( !CHID::m_pInstance[CHID::currentInstanceIndex] )
    return sub_19A20C(KK_MAX);
  if ( CHID::GetInputType() != 2 )
    return sub_19A20C(KK_MAX);
  numEntries = this->m_MappingStructs.numEntries;
  if ( !numEntries )
    return sub_19A20C(KK_MAX);
  v5 = 0;
  dataPtr = this->m_MappingStructs.dataPtr;
  v7 = (CHIDKeyboard *)CHID::m_pInstance[CHID::currentInstanceIndex];
  while ( strcasecmp((const char *)dataPtr, (const char *)pszTag) )
  {
    ++v5;
    ++dataPtr;
    if ( v5 >= numEntries )
      return sub_19A20C(KK_MAX);
  }
  return sub_19A1E4(v7, dataPtr->m_Mapping, dataPtr->m_bNegate);
}

//----- (002A3C7C) --------------------------------------------------------
void __fastcall KeyboardControlsScreen::RemapKey(
        KeyboardControlsScreen *this,
        OSKeyboardKey Key,
        MouseButtons MouseButton)
{
  MappingStruct *v6; // r2
  CHIDKeyboard *v7; // r8
  int selectedItem; // r0
  MappingStruct *dataPtr; // r1
  HIDMapping m_Mapping; // r2
  MappingStruct *v11; // r0
  HIDMapping v12; // r1

  if ( !CHID::m_pInstance[CHID::currentInstanceIndex] || CHID::GetInputType() != 2 )
    goto LABEL_15;
  v6 = &this->m_MappingStructs.dataPtr[this->selectedItem];
  v7 = (CHIDKeyboard *)CHID::m_pInstance[CHID::currentInstanceIndex];
  CHIDKeyboard::ReplaceMapping(v7, v6->m_Mapping, Key, v6->m_bNegate, MouseButton);
  selectedItem = this->selectedItem;
  dataPtr = this->m_MappingStructs.dataPtr;
  m_Mapping = dataPtr[selectedItem].m_Mapping;
  if ( m_Mapping == HID_MAPPING_PHONE )
  {
    CHIDKeyboard::ReplaceMapping(v7, HID_MAPPING_SWAP_WEAPONS_AND_PURCHASE, Key, 0, MouseButton);
    CHIDKeyboard::ReplaceMapping(v7, HID_MAPPING_DROP_ITEM, Key, 0, MouseButton);
    selectedItem = this->selectedItem;
    dataPtr = this->m_MappingStructs.dataPtr;
    m_Mapping = dataPtr[selectedItem].m_Mapping;
    if ( m_Mapping != HID_MAPPING_MISSION_START_AND_CANCEL_VIGILANTE )
    {
LABEL_5:
      if ( m_Mapping != HID_MAPPING_CRANE_UP )
        goto LABEL_6;
      goto LABEL_19;
    }
  }
  else if ( m_Mapping != HID_MAPPING_MISSION_START_AND_CANCEL_VIGILANTE )
  {
    goto LABEL_5;
  }
  CHIDKeyboard::ReplaceMapping(v7, HID_MAPPING_VEHICLE_BOMB, Key, 0, MouseButton);
  CHIDKeyboard::ReplaceMapping(v7, HID_MAPPING_STINGER, Key, 0, MouseButton);
  CHIDKeyboard::ReplaceMapping(v7, HID_MAPPING_GRAB, Key, 0, MouseButton);
  selectedItem = this->selectedItem;
  dataPtr = this->m_MappingStructs.dataPtr;
  m_Mapping = dataPtr[selectedItem].m_Mapping;
  if ( m_Mapping != HID_MAPPING_CRANE_UP )
  {
LABEL_6:
    if ( m_Mapping != HID_MAPPING_CRANE_DOWN )
      goto LABEL_7;
    goto LABEL_20;
  }
LABEL_19:
  CHIDKeyboard::ReplaceMapping(v7, HID_MAPPING_HELICOPTER_MAGNET_UP, Key, 0, MouseButton);
  selectedItem = this->selectedItem;
  dataPtr = this->m_MappingStructs.dataPtr;
  m_Mapping = dataPtr[selectedItem].m_Mapping;
  if ( m_Mapping != HID_MAPPING_CRANE_DOWN )
  {
LABEL_7:
    if ( m_Mapping != HID_MAPPING_DROP_CRANE )
      goto LABEL_8;
    goto LABEL_21;
  }
LABEL_20:
  CHIDKeyboard::ReplaceMapping(v7, HID_MAPPING_HELICOPTER_MAGNET_DOWN, Key, 0, MouseButton);
  selectedItem = this->selectedItem;
  dataPtr = this->m_MappingStructs.dataPtr;
  m_Mapping = dataPtr[selectedItem].m_Mapping;
  if ( m_Mapping != HID_MAPPING_DROP_CRANE )
  {
LABEL_8:
    if ( m_Mapping != HID_MAPPING_GANG_RECRUIT )
      goto LABEL_9;
    goto LABEL_22;
  }
LABEL_21:
  CHIDKeyboard::ReplaceMapping(v7, HID_MAPPING_MAGNET, Key, 0, MouseButton);
  selectedItem = this->selectedItem;
  dataPtr = this->m_MappingStructs.dataPtr;
  m_Mapping = dataPtr[selectedItem].m_Mapping;
  if ( m_Mapping != HID_MAPPING_GANG_RECRUIT )
  {
LABEL_9:
    if ( m_Mapping != HID_MAPPING_GANG_IGNORE )
      goto LABEL_10;
LABEL_23:
    CHIDKeyboard::ReplaceMapping(v7, HID_MAPPING_GANG_HOLD_POSITION, Key, 0, MouseButton);
    selectedItem = this->selectedItem;
    dataPtr = this->m_MappingStructs.dataPtr;
    if ( dataPtr[selectedItem].m_Mapping == HID_MAPPING_VEHICLE_STEER_X )
      goto LABEL_11;
    goto LABEL_14;
  }
LABEL_22:
  CHIDKeyboard::ReplaceMapping(v7, HID_MAPPING_GANG_FOLLOW, Key, 0, MouseButton);
  selectedItem = this->selectedItem;
  dataPtr = this->m_MappingStructs.dataPtr;
  m_Mapping = dataPtr[selectedItem].m_Mapping;
  if ( m_Mapping == HID_MAPPING_GANG_IGNORE )
    goto LABEL_23;
LABEL_10:
  if ( m_Mapping == HID_MAPPING_VEHICLE_STEER_X )
  {
LABEL_11:
    v11 = &dataPtr[selectedItem];
    v12 = HID_MAPPING_VEHICLE_STEER_RIGHT;
    if ( v11->m_bNegate )
      v12 = HID_MAPPING_VEHICLE_STEER_LEFT;
    CHIDKeyboard::ReplaceMapping(v7, v12, Key, 0, MouseButton);
  }
LABEL_14:
  CHIDKeyboard::SaveMappingsToDisk(v7);
LABEL_15:
  bInputDialogActive = 0;
  if ( !NeedsAmazonDownload() )
    sub_18FDC4(&AudioEngine, 1, 0.0, 1.0);
}
// 6E01B0: using guessed type char bInputDialogActive;

//----- (002A3E9C) --------------------------------------------------------
void __fastcall KeyboardControlsScreen::ManageScrolling(KeyboardControlsScreen *this, float fDeltaTime)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d2
  float32x2_t v4; // d8
  float Wheel; // r6
  bool v8; // zf
  float v9; // s16
  float v10; // r8
  float v11; // r6
  float v12; // r5
  float v13; // s22
  float v14; // s20
  float v15; // r5
  float v16; // s22
  char v17; // r0
  float v18; // s18
  float y; // s20
  float v20; // s18
  float v21; // s20
  float v22; // r0
  OSPointerState v23; // r1
  float numEntries; // s18
  float v25; // r5
  float v26; // s22
  int v27; // [sp+0h] [bp-40h] BYREF
  float v28; // [sp+4h] [bp-3Ch]
  float v29; // [sp+Ch] [bp-34h]

  Wheel = LIB_PointerGetWheel(0);
  this->m_fScrollY = this->m_fScrollY
                   + (float)((float)(Wheel
                                   * (*((float (__fastcall **)(KeyboardControlsScreen *, _DWORD))this->_vptr$MenuScreen
                                      + 17))(
                                       this,
                                       0))
                           * 0.5);
  if ( DownPressed() || UpPressed() == 1 )
    this->m_bAutoScroll = 1;
  if ( gMobileMenu.pointerState[lastDevice] == OSPS_ButtonPressed )
    this->m_bAutoScroll = 0;
  (*((void (__fastcall **)(int *, KeyboardControlsScreen *))this->_vptr$MenuScreen + 19))(&v27, this);
  v8 = !this->m_bAutoScroll;
  if ( this->m_bAutoScroll )
    v8 = this->selectedItem == -1;
  if ( !v8 )
  {
    v9 = fDeltaTime;
    v10 = COERCE_FLOAT((*((int (__fastcall **)(KeyboardControlsScreen *))this->_vptr$MenuScreen + 16))(this));
    v11 = COERCE_FLOAT((*((int (__fastcall **)(KeyboardControlsScreen *))this->_vptr$MenuScreen + 15))(this));
    v12 = COERCE_FLOAT((*((int (__fastcall **)(KeyboardControlsScreen *, _DWORD))this->_vptr$MenuScreen + 17))(this, 0));
    v13 = v29;
    v14 = (float)(v10 + v11) + (float)(v12 * (float)this->selectedItem);
    if ( v14 < (float)(v13 * (float)(480.0 / (float)(unsigned int)OS_ScreenGetHeight())) )
      this->m_fScrollY = this->m_fScrollY
                       + (float)((float)((*((float (__fastcall **)(KeyboardControlsScreen *, _DWORD))this->_vptr$MenuScreen
                                          + 17))(
                                           this,
                                           0)
                                       * v9)
                               * 7.5);
    v15 = COERCE_FLOAT((*((int (__fastcall **)(KeyboardControlsScreen *, _DWORD))this->_vptr$MenuScreen + 17))(this, 0));
    v16 = v28;
    if ( (float)(v14 + v15) > (float)(v16 * (float)(480.0 / (float)(unsigned int)OS_ScreenGetHeight())) )
      this->m_fScrollY = this->m_fScrollY
                       + (float)((float)((*((float (__fastcall **)(KeyboardControlsScreen *, _DWORD))this->_vptr$MenuScreen
                                          + 17))(
                                           this,
                                           0)
                                       * v9)
                               * -7.5);
  }
  v17 = `guard variable for'KeyboardControlsScreen::ManageScrolling(float)::lastMouseCoords;
  __dmb(0xBu);
  if ( (v17 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'KeyboardControlsScreen::ManageScrolling(float)::lastMouseCoords) )
  {
    KeyboardControlsScreen::ManageScrolling(float)::lastMouseCoords = gMobileMenu.pointerCoords[lastDevice];
    _cxa_guard_release((__guard *)&`guard variable for'KeyboardControlsScreen::ManageScrolling(float)::lastMouseCoords);
  }
  if ( gMobileMenu.pointerState[lastDevice] == OSPS_ButtonPressed )
  {
    v18 = v29;
    y = gMobileMenu.pointerCoords[lastDevice].y;
    if ( y > (float)(v18 * (float)(480.0 / (float)(unsigned int)OS_ScreenGetHeight())) )
    {
      v20 = v28;
      v21 = gMobileMenu.pointerCoords[lastDevice].y;
      if ( v21 < (float)(v20 * (float)(480.0 / (float)(unsigned int)OS_ScreenGetHeight())) )
      {
        v22 = gMobileMenu.pointerCoords[lastDevice].y;
LABEL_25:
        this->m_fAnchorY = v22;
        goto LABEL_26;
      }
    }
  }
  v23 = gMobileMenu.pointerState[lastDevice];
  if ( v23 == OSPS_ButtonUp )
  {
    v22 = 0.0;
    goto LABEL_25;
  }
  if ( v23 == OSPS_ButtonDown && this->m_fAnchorY != 0.0 )
    this->m_fScrollY = this->m_fScrollY
                     + (float)(gMobileMenu.pointerCoords[lastDevice].y
                             - KeyboardControlsScreen::ManageScrolling(float)::lastMouseCoords.y);
LABEL_26:
  v4.n64_u32[0] = LODWORD(this->m_fScrollY);
  numEntries = (float)this->m_MappingStructs.numEntries;
  v25 = COERCE_FLOAT((*((int (__fastcall **)(KeyboardControlsScreen *, _DWORD))this->_vptr$MenuScreen + 17))(this, 0));
  v26 = COERCE_FLOAT((*((int (__fastcall **)(KeyboardControlsScreen *))this->_vptr$MenuScreen + 18))(this));
  v3.n64_u32[0] = 0;
  v2.n64_f32[0] = (float)(v26 - (*((float (__fastcall **)(KeyboardControlsScreen *))this->_vptr$MenuScreen + 16))(this))
                - (float)(v25 * numEntries);
  LODWORD(this->m_fScrollY) = vmax_f32(vmin_f32(v4, v3), v2).n64_u32[0];
  KeyboardControlsScreen::ManageScrolling(float)::lastMouseCoords = gMobileMenu.pointerCoords[lastDevice];
}
// 2A419C: variable 'v4' is possibly undefined
// 2A419C: variable 'v3' is possibly undefined
// 2A41B2: variable 'v2' is possibly undefined
// 6E01BC: using guessed type char `guard variable for'KeyboardControlsScreen::ManageScrolling(float)::lastMouseCoords;

//----- (002A4238) --------------------------------------------------------
float __fastcall SelectScreen::ActionSelection::GetTextPercent(SelectScreen::ActionSelection *this)
{
  return 1.0;
}

//----- (002A4240) --------------------------------------------------------
void __fastcall SelectScreen::ActionSelection::HandleInput(
        SelectScreen::ActionSelection *this,
        SelectScreen *fromScreen,
        float deltaTime)
{
  if ( CHID::Implements(HID_MAPPING_MENU_ACCEPT) && CHID::IsReleased(HID_MAPPING_MENU_ACCEPT)
    || gMobileMenu.pointerState[lastDevice] == OSPS_ButtonReleased )
  {
    if ( !NeedsAmazonDownload() )
      CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 1, 0.0, 1.0);
    this->OnSelect(fromScreen, this->data);
  }
}

//----- (002A42AC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall SelectScreen::SettingSelection::Render(
        SelectScreen::SettingSelection *this,
        SelectScreen *fromScreen,
        CVector2D location,
        CVector2D bounds,
        float selectAlpha)
{
  float32x2_t v5; // d0
  float32x2_t v6; // d2
  float y; // r5
  float x; // r10
  float v11; // r4
  GxtChar *v12; // r11
  float v13; // s20
  MobileSetting forSetting; // r0
  float v15; // s18
  MobileSettingType type; // r1
  MobileSettings::Setting *v17; // r2
  int32 value; // r1
  int32 min; // r2
  const unsigned __int8 *v20; // r4
  GxtChar *v21; // r0
  float v22; // s18
  float v23; // r1 OVERLAPPED
  float v24; // r2
  float v25; // s4
  CVector2D v26; // [sp+Ch] [bp-74h]
  CVector2D var74a; // [sp+Ch] [bp-74h]
  CVector2D v28; // [sp+14h] [bp-6Ch]
  CVector2D v29; // [sp+14h] [bp-6Ch]
  CRGBA v30; // [sp+28h] [bp-58h] BYREF
  CVector2D v31; // [sp+2Ch] [bp-54h] BYREF
  int v32[19]; // [sp+34h] [bp-4Ch] BYREF
  CVector2D cvector2d; // 0:r3.4,4:^0.4

  y = location.y;
  x = location.x;
  v11 = COERCE_FLOAT((*((int (__fastcall **)(SelectScreen::SettingSelection *))this->_vptr$MenuSelection + 3))(this));
  v12 = (GxtChar *)(*((int (__fastcall **)(SelectScreen::SettingSelection *))this->_vptr$MenuSelection + 5))(this);
  (*((void (__fastcall **)(int *, SelectScreen::SettingSelection *))this->_vptr$MenuSelection + 4))(v32, this);
  v13 = (float)(bounds.y * 0.5) + y;
  v28.y = (float)(selectAlpha + selectAlpha) + 16.0;
  v28.x = v11 * bounds.x;
  v26.x = x;
  v26.y = (float)(v13 + -8.0) - selectAlpha;
  MenuScreen::DrawTextDirect(&v31, fromScreen, v12, TA_Left, 2, (CRGBA)v32, 1, v26, v28, 0, 0);
  forSetting = this->forSetting;
  v15 = bounds.x * 0.6;
  type = MobileSettings::settings[forSetting].type;
  if ( type == MST_Range )
  {
    v22 = v15 + x;
    v23 = v22;
    v5.n64_f32[0] = (float)((float)MobileSettings::settings[forSetting].value
                          - (float)MobileSettings::settings[forSetting].min)
                  / (float)((float)MobileSettings::settings[forSetting].max
                          - (float)MobileSettings::settings[forSetting].min);
    v6.n64_u32[0] = 1.0;
    LODWORD(v25) = vmin_f32(v5, v6).n64_u32[0];
    if ( v5.n64_f32[0] < 0.0 )
      v25 = 0.0;
    cvector2d.y = v13 + 9.0;
    v24 = v13 + -9.0;
    cvector2d.x = x + bounds.x;
    MenuScreen::DrawSlider(fromScreen, *(CVector2D *)&v23, cvector2d, v25, 1, 0xFFu, 0);
    this->sliderX1 = v22;
    this->sliderX2 = x + bounds.x;
  }
  else if ( type == MST_Toggle )
  {
    v17 = &MobileSettings::settings[forSetting];
    value = v17->value;
    min = v17->min;
    if ( value >= min && value <= MobileSettings::settings[forSetting].max )
    {
      v20 = MobileSettings::settings[forSetting].values[value - min];
      CRGBA::CRGBA(&v30, 0xF0u, 0xF0u, 0xF0u, 0xFFu);
      v21 = CText::Get(&TheText, v20);
      v32[0] = (int)v30;
      v29.y = (float)(selectAlpha + selectAlpha) + 16.0;
      v29.x = bounds.x - v15;
      var74a.y = (float)(v13 + -8.0) - selectAlpha;
      var74a.x = v15 + x;
      MenuScreen::DrawTextDirect(&v31, fromScreen, v21, TA_Right, 2, (CRGBA)v32, 1, var74a, v29, 0, 0);
    }
  }
}
// 2A42AC: variables would overlap: r1.4 and r1.8

//----- (002A44BC) --------------------------------------------------------
void __fastcall SelectScreen::SettingSelection::HandleInput(
        SelectScreen::SettingSelection *this,
        SelectScreen *fromScreen,
        float deltaTime)
{
  float32x2_t v3; // d8
  float32x2_t v4; // d9
  float v7; // s18
  int v8; // r5
  MobileSetting forSetting; // r0
  MobileSettings::Setting *v10; // r1
  int32 *v11; // r1
  int32 v12; // t1
  int32 v13; // r3
  float v14; // s20
  float *p_curMoveReq; // r6
  float v16; // s0
  MobileSettings::Setting *v17; // r1
  int32 *p_value; // r1
  int32 v19; // r2
  int32 value; // t1
  int v21; // r5
  MobileSettings::Setting *v22; // r1
  int32 *v23; // r1
  int32 v24; // r2
  int32 v25; // t1
  OSPointerState v26; // r0
  float v27; // s0
  MobileSettings::Setting *v28; // r0
  int32 *v29; // r0
  int32 v30; // r2
  int32 v31; // t1
  int v32; // r1
  MobileSetting v33; // r1
  MobileSettings::Setting *v34; // r0
  int32 *v35; // r0
  int32 v36; // r2
  int32 v37; // t1
  int32 max; // r1

  if ( MobileSettings::settings[this->forSetting].type == MST_Range )
  {
    if ( (CHID::Implements(HID_MAPPING_MENU_LEFT) || CHID::Implements(HID_MAPPING_PED_MOVE_X))
      && (CHID::IsPressed(HID_MAPPING_MENU_LEFT, 0) || CHID::IsPressedNegative(HID_MAPPING_PED_MOVE_X)) )
    {
      v7 = -1.0;
    }
    else
    {
      v7 = 0.0;
    }
    if ( !CHID::Implements(HID_MAPPING_MENU_RIGHT) && !CHID::Implements(HID_MAPPING_PED_MOVE_X)
      || (v14 = 1.0, !CHID::IsPressed(HID_MAPPING_MENU_RIGHT, 0)) && !CHID::IsPressedPositive(HID_MAPPING_PED_MOVE_X) )
    {
      if ( v7 == 0.0 )
      {
        p_curMoveReq = &this->curMoveReq;
        goto LABEL_27;
      }
      v14 = v7;
    }
    p_curMoveReq = &this->curMoveReq;
    if ( this->curMoveReq == 0.0 && !NeedsAmazonDownload() )
      CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 1, 0.0, 1.0);
    v7 = v14;
LABEL_27:
    v3.n64_u32[0] = 1.0;
    v16 = (float)((float)(v7 * deltaTime) * 20.0) + *p_curMoveReq;
    *p_curMoveReq = v16;
    if ( v16 <= 1.0 )
    {
      v21 = 0;
    }
    else
    {
      do
      {
        v17 = &MobileSettings::settings[this->forSetting];
        value = v17->value;
        p_value = &v17->value;
        v19 = value;
        if ( value != p_value[3] )
        {
          *p_value = v19 + 1;
          v16 = *p_curMoveReq;
        }
        v16 = v16 + -1.0;
        *p_curMoveReq = v16;
      }
      while ( v16 > 1.0 );
      v21 = 1;
    }
    if ( v16 < -1.0 )
    {
      do
      {
        v22 = &MobileSettings::settings[this->forSetting];
        v25 = v22->value;
        v23 = &v22->value;
        v24 = v25;
        if ( v25 != v23[2] )
        {
          *v23 = v24 - 1;
          v16 = *p_curMoveReq;
        }
        v16 = v16 + 1.0;
        *p_curMoveReq = v16;
      }
      while ( v16 < -1.0 );
      v21 = 1;
    }
    if ( gMobileMenu.pointerMode )
    {
      v4.n64_f32[0] = (float)(gMobileMenu.pointerCoords[lastDevice].x - this->sliderX1)
                    / (float)(this->sliderX2 - this->sliderX1);
      if ( v4.n64_f32[0] < 1.0 && gMobileMenu.pointerState[lastDevice] == OSPS_ButtonPressed && v4.n64_f32[0] > 0.0 )
      {
        this->sliding = 1;
        if ( !NeedsAmazonDownload() )
          CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 1, 0.0, 1.0);
      }
      if ( this->sliding )
      {
        v26 = gMobileMenu.pointerState[lastDevice];
        if ( v26 == OSPS_ButtonReleased )
        {
          (*((void (__fastcall **)(SelectScreen::SettingSelection *))this->_vptr$MenuSelection + 8))(this);
          if ( !v21 )
            goto LABEL_71;
          goto LABEL_64;
        }
        if ( v26 == OSPS_ButtonDown )
        {
          LODWORD(v27) = vmin_f32(v4, v3).n64_u32[0];
          v28 = &MobileSettings::settings[this->forSetting];
          v31 = v28->value;
          v29 = &v28->value;
          v30 = v31;
          if ( v4.n64_f32[0] < 0.0 )
            v27 = 0.0;
          v32 = v29[2] + (int)(float)(v27 * (float)(v29[3] - v29[2]));
          if ( v32 != v30 )
          {
            *v29 = v32;
            goto LABEL_64;
          }
        }
      }
    }
    else if ( this->sliding )
    {
      this->sliding = 0;
    }
    if ( !v21 )
      goto LABEL_71;
    goto LABEL_64;
  }
  if ( CHID::Implements(HID_MAPPING_MENU_ACCEPT) && CHID::IsReleased(HID_MAPPING_MENU_ACCEPT)
    || RightPressed()
    || gMobileMenu.pointerState[lastDevice] == OSPS_ButtonReleased )
  {
    forSetting = this->forSetting;
    v10 = &MobileSettings::settings[forSetting];
    v12 = v10->value;
    v11 = &v10->value;
    v13 = v11[3];
    *v11 = v12 + 1;
    if ( v12 >= v13 )
      *v11 = MobileSettings::settings[forSetting].min;
    v8 = 1;
    if ( !NeedsAmazonDownload() )
      CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 1, 0.0, 1.0);
  }
  else
  {
    v8 = 0;
  }
  if ( LeftPressed() == 1 )
  {
    v33 = this->forSetting;
    v34 = &MobileSettings::settings[v33];
    v37 = v34->value;
    v35 = &v34->value;
    v36 = v37;
    if ( v37 <= v35[2] )
      max = MobileSettings::settings[v33].max;
    else
      max = v36 - 1;
    *v35 = max;
    if ( !NeedsAmazonDownload() )
      CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 1, 0.0, 1.0);
  }
  else if ( v8 != 1 )
  {
    goto LABEL_71;
  }
LABEL_64:
  switch ( this->forSetting )
  {
    case MS_TouchLayout:
      CTouchInterface::SetupLayoutObjects();
      break;
    case MS_SFXVolume:
    case MS_MusicVolume:
      Menu_ApplyAudioSettings();
      break;
    case MS_DefaultStation:
      CAudioEngine::RetuneRadio(&AudioEngine, MobileSettings::settings[14].value);
      break;
    case MS_HRTF:
      CAEAudioHardware::SetHRTF(&AEAudioHardware, MobileSettings::settings[33].value);
      break;
    default:
      break;
  }
LABEL_71:
  if ( SelectScreen::SettingSelection::HandleInput(SelectScreen*,float)::WaitingForScreenRecordingResponse )
  {
    SelectScreen::SettingSelection::HandleInput(SelectScreen*,float)::WaitingForScreenRecordingResponse = 0;
    MobileSettings::settings[36].value = 0;
  }
}
// 2A473A: variable 'v4' is possibly undefined
// 2A473A: variable 'v3' is possibly undefined

//----- (002A48EC) --------------------------------------------------------
void __fastcall SelectScreen::SettingSelection::SetDefault(SelectScreen::SettingSelection *this)
{
  MobileSettings::settings[this->forSetting].value = MobileSettings::settings[this->forSetting].defaultValue;
  if ( this->forSetting == MS_TouchLayout )
    sub_18EA70();
}

//----- (002A490C) --------------------------------------------------------
void __fastcall SelectScreen::SettingSelection::Deselected(SelectScreen::SettingSelection *this)
{
  if ( this->sliding )
  {
    this->sliding = 0;
    if ( !NeedsAmazonDownload() )
      sub_18FDC4(&AudioEngine, 1, 0.0, 1.0);
  }
}

//----- (002A4940) --------------------------------------------------------
void __fastcall GameScreen::GameScreen(GameScreen *this)
{
  int v2; // r0
  int v3; // r0
  int v4; // r0
  int v5; // r0
  int v6; // r0
  SelectScreen::MenuSelection *v7; // r0
  SelectScreen::MenuSelection *v8; // r0

  CharSelectScreen::CharSelectScreen(this, "FEH_LOA", 1);
  this->_vptr$MenuScreen = (int (**)(void))&off_662864;
  v2 = operator new(0x1Cu);
  *(_DWORD *)(v2 + 4) = MobileSettings::settings[4].name;
  *(_DWORD *)(v2 + 8) = 4;
  *(_DWORD *)(v2 + 21) = 0;
  *(_DWORD *)(v2 + 17) = 0;
  *(_DWORD *)(v2 + 12) = 0;
  *(_DWORD *)(v2 + 16) = 0;
  *(_DWORD *)v2 = &off_662838;
  SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v2);
  v3 = operator new(0x1Cu);
  *(_DWORD *)(v3 + 4) = MobileSettings::settings[6].name;
  *(_DWORD *)(v3 + 8) = 6;
  *(_DWORD *)(v3 + 21) = 0;
  *(_DWORD *)(v3 + 17) = 0;
  *(_DWORD *)(v3 + 12) = 0;
  *(_DWORD *)(v3 + 16) = 0;
  *(_DWORD *)v3 = &off_662838;
  SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v3);
  v4 = operator new(0x1Cu);
  *(_DWORD *)(v4 + 4) = MobileSettings::settings[10].name;
  *(_DWORD *)(v4 + 8) = 10;
  *(_DWORD *)(v4 + 21) = 0;
  *(_DWORD *)(v4 + 17) = 0;
  *(_DWORD *)(v4 + 12) = 0;
  *(_DWORD *)(v4 + 16) = 0;
  *(_DWORD *)v4 = &off_662838;
  SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v4);
  v5 = operator new(0x1Cu);
  *(_DWORD *)(v5 + 4) = MobileSettings::settings[29].name;
  *(_DWORD *)(v5 + 8) = 29;
  *(_DWORD *)(v5 + 21) = 0;
  *(_DWORD *)(v5 + 17) = 0;
  *(_DWORD *)(v5 + 12) = 0;
  *(_DWORD *)(v5 + 16) = 0;
  *(_DWORD *)v5 = &off_662838;
  SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v5);
  v6 = operator new(0x1Cu);
  *(_DWORD *)(v6 + 4) = MobileSettings::settings[30].name;
  *(_DWORD *)(v6 + 8) = 30;
  *(_DWORD *)(v6 + 21) = 0;
  *(_DWORD *)(v6 + 17) = 0;
  *(_DWORD *)(v6 + 12) = 0;
  *(_DWORD *)(v6 + 16) = 0;
  *(_DWORD *)v6 = &off_662838;
  SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v6);
  if ( hasTouchScreen )
  {
    v7 = (SelectScreen::MenuSelection *)operator new(0x10u);
    v7->tag = "MOB_SCI";
    v7[1]._vptr$MenuSelection = (int (**)(void))SelectScreen::OnSocialClub;
    v7[1].tag = 0;
    v7->_vptr$MenuSelection = (int (**)(void))&off_66280C;
    SelectScreen::AddItem(this, v7);
  }
  v8 = (SelectScreen::MenuSelection *)operator new(0x10u);
  v8->tag = "MOB_RTD";
  v8[1]._vptr$MenuSelection = (int (**)(void))SelectScreen::OnRestoreDefaults;
  v8[1].tag = 0;
  v8->_vptr$MenuSelection = (int (**)(void))&off_66280C;
  SelectScreen::AddItem(this, v8);
  this->renderLastAtBottom = 1;
}
// FC: using guessed type int elf_hash_bucket[16411];
// 66280C: using guessed type void *off_66280C;
// 662838: using guessed type void *off_662838;
// 662864: using guessed type void *;

//----- (002A4AC8) --------------------------------------------------------
void __fastcall SelectScreen::OnSocialClub(SelectScreen *screen, int32 data)
{
  AddMenuStat(eSocialClub, 1);
  SetAndroidPaused(1);
  SigningOutfromApp = 1;
  IsSCCloudAvailable();
  sub_18D498();
}

//----- (002A4AF4) --------------------------------------------------------
void __fastcall GameScreen::~GameScreen(GameScreen *this)
{
  void *v1; // r0

  SelectScreen::~SelectScreen(this);
  sub_191374(v1);
}
// 2A4B00: variable 'v1' is possibly undefined

//----- (002A4B04) --------------------------------------------------------
void __fastcall DisplayScreen::DisplayScreen(DisplayScreen *this)
{
  int v2; // r0
  int v3; // r1
  const unsigned __int8 *name; // r0
  int v5; // r0
  int v6; // r0
  int v7; // r0
  int v8; // r0
  int v9; // r0
  SelectScreen::MenuSelection *v10; // r0

  CharSelectScreen::CharSelectScreen(this, "FEH_DIS", 1);
  this->_vptr$MenuScreen = (int (**)(void))&off_6628C0;
  v2 = operator new(0x1Cu);
  *(_DWORD *)(v2 + 4) = MobileSettings::settings[16].name;
  *(_DWORD *)(v2 + 8) = 16;
  *(_DWORD *)(v2 + 21) = 0;
  *(_DWORD *)(v2 + 17) = 0;
  *(_DWORD *)(v2 + 12) = 0;
  *(_DWORD *)(v2 + 16) = 0;
  *(_DWORD *)v2 = &off_662838;
  SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v2);
  v3 = operator new(0x1Cu);
  name = MobileSettings::settings[0].name;
  *(_QWORD *)(v3 + 8) = 0LL;
  *(_QWORD *)(v3 + 16) = 0LL;
  *(_DWORD *)v3 = &off_662838;
  *(_DWORD *)(v3 + 4) = name;
  *(_BYTE *)(v3 + 24) = 0;
  SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v3);
  v5 = operator new(0x1Cu);
  *(_DWORD *)(v5 + 4) = MobileSettings::settings[1].name;
  *(_DWORD *)(v5 + 8) = 1;
  *(_DWORD *)(v5 + 21) = 0;
  *(_DWORD *)(v5 + 17) = 0;
  *(_DWORD *)(v5 + 12) = 0;
  *(_DWORD *)(v5 + 16) = 0;
  *(_DWORD *)v5 = &off_662838;
  SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v5);
  v6 = operator new(0x1Cu);
  *(_DWORD *)(v6 + 4) = MobileSettings::settings[2].name;
  *(_DWORD *)(v6 + 8) = 2;
  *(_DWORD *)(v6 + 21) = 0;
  *(_DWORD *)(v6 + 17) = 0;
  *(_DWORD *)(v6 + 12) = 0;
  *(_DWORD *)(v6 + 16) = 0;
  *(_DWORD *)v6 = &off_662838;
  SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v6);
  v7 = operator new(0x1Cu);
  *(_DWORD *)(v7 + 4) = MobileSettings::settings[5].name;
  *(_DWORD *)(v7 + 8) = 5;
  *(_DWORD *)(v7 + 21) = 0;
  *(_DWORD *)(v7 + 17) = 0;
  *(_DWORD *)(v7 + 12) = 0;
  *(_DWORD *)(v7 + 16) = 0;
  *(_DWORD *)v7 = &off_662838;
  SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v7);
  v8 = operator new(0x1Cu);
  *(_DWORD *)(v8 + 4) = MobileSettings::settings[7].name;
  *(_DWORD *)(v8 + 8) = 7;
  *(_DWORD *)(v8 + 21) = 0;
  *(_DWORD *)(v8 + 17) = 0;
  *(_DWORD *)(v8 + 12) = 0;
  *(_DWORD *)(v8 + 16) = 0;
  *(_DWORD *)v8 = &off_662838;
  SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v8);
  v9 = operator new(0x1Cu);
  *(_DWORD *)(v9 + 4) = MobileSettings::settings[24].name;
  *(_DWORD *)(v9 + 8) = 24;
  *(_DWORD *)(v9 + 21) = 0;
  *(_DWORD *)(v9 + 17) = 0;
  *(_DWORD *)(v9 + 12) = 0;
  *(_DWORD *)(v9 + 16) = 0;
  *(_DWORD *)v9 = &off_662838;
  SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v9);
  v10 = (SelectScreen::MenuSelection *)operator new(0x10u);
  v10->_vptr$MenuSelection = (int (**)(void))&off_66280C;
  v10->tag = "MOB_RTD";
  v10[1]._vptr$MenuSelection = (int (**)(void))SelectScreen::OnRestoreDefaults;
  v10[1].tag = 0;
  SelectScreen::AddItem(this, v10);
  this->renderLastAtBottom = 1;
}
// FC: using guessed type int elf_hash_bucket[16411];
// 66280C: using guessed type void *off_66280C;
// 662838: using guessed type void *off_662838;
// 6628C0: using guessed type void *;

//----- (002A4C94) --------------------------------------------------------
void __fastcall DisplayScreen::~DisplayScreen(DisplayScreen *this)
{
  void *v1; // r0

  SelectScreen::~SelectScreen(this);
  sub_191374(v1);
}
// 2A4CA0: variable 'v1' is possibly undefined

//----- (002A4CA4) --------------------------------------------------------
void __fastcall AudioScreen::AudioScreen(AudioScreen *this)
{
  int v2; // r0
  int v3; // r0
  int v4; // r0
  int v5; // r0
  int v6; // r0
  AudioScreen::RadioSelection *v7; // r5
  SelectScreen::MenuSelection *v8; // r0

  CharSelectScreen::CharSelectScreen(this, "FEH_AUD", 1);
  this->_vptr$MenuScreen = (int (**)(void))&off_66291C;
  v2 = operator new(0x1Cu);
  *(_DWORD *)(v2 + 4) = MobileSettings::settings[11].name;
  *(_DWORD *)(v2 + 8) = 11;
  *(_DWORD *)(v2 + 21) = 0;
  *(_DWORD *)(v2 + 17) = 0;
  *(_DWORD *)(v2 + 12) = 0;
  *(_DWORD *)(v2 + 16) = 0;
  *(_DWORD *)v2 = &off_662838;
  SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v2);
  v3 = operator new(0x1Cu);
  *(_DWORD *)(v3 + 4) = MobileSettings::settings[12].name;
  *(_DWORD *)(v3 + 8) = 12;
  *(_DWORD *)(v3 + 21) = 0;
  *(_DWORD *)(v3 + 17) = 0;
  *(_DWORD *)(v3 + 12) = 0;
  *(_DWORD *)(v3 + 16) = 0;
  *(_DWORD *)v3 = &off_662838;
  SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v3);
  v4 = operator new(0x1Cu);
  *(_DWORD *)(v4 + 4) = MobileSettings::settings[33].name;
  *(_DWORD *)(v4 + 8) = 33;
  *(_DWORD *)(v4 + 21) = 0;
  *(_DWORD *)(v4 + 17) = 0;
  *(_DWORD *)(v4 + 12) = 0;
  *(_DWORD *)(v4 + 16) = 0;
  *(_DWORD *)v4 = &off_662838;
  SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v4);
  v5 = operator new(0x1Cu);
  *(_DWORD *)(v5 + 4) = MobileSettings::settings[13].name;
  *(_DWORD *)(v5 + 8) = 13;
  *(_DWORD *)(v5 + 21) = 0;
  *(_DWORD *)(v5 + 17) = 0;
  *(_DWORD *)(v5 + 12) = 0;
  *(_DWORD *)(v5 + 16) = 0;
  *(_DWORD *)v5 = &off_662838;
  SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v5);
  v6 = operator new(0x1Cu);
  *(_DWORD *)(v6 + 4) = MobileSettings::settings[14].name;
  *(_DWORD *)(v6 + 8) = 14;
  *(_DWORD *)(v6 + 21) = 0;
  *(_DWORD *)(v6 + 17) = 0;
  *(_DWORD *)(v6 + 12) = 0;
  *(_DWORD *)(v6 + 16) = 0;
  *(_DWORD *)v6 = &off_662838;
  SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v6);
  v7 = (AudioScreen::RadioSelection *)operator new(0x5Cu);
  AudioScreen::RadioSelection::RadioSelection(v7);
  SelectScreen::AddItem(this, v7);
  v8 = (SelectScreen::MenuSelection *)operator new(0x10u);
  v8->_vptr$MenuSelection = (int (**)(void))&off_66280C;
  v8->tag = "MOB_RTD";
  v8[1]._vptr$MenuSelection = (int (**)(void))AudioScreen::OnRestoreDefaults;
  v8[1].tag = 0;
  SelectScreen::AddItem(this, v8);
  this->renderLastAtBottom = 1;
  if ( MobileSettings::settings[14].value <= 12 )
  {
    CAudioEngine::StartRadio(&AudioEngine, MobileSettings::settings[14].value, 0);
    CAudioEngine::Service(&AudioEngine);
    CAudioEngine::StopRadio(&AudioEngine, 0, 0);
    CAudioEngine::Service(&AudioEngine);
    CAudioEngine::RetuneRadio(&AudioEngine, MobileSettings::settings[14].value);
  }
}
// FC: using guessed type int elf_hash_bucket[16411];
// 66280C: using guessed type void *off_66280C;
// 662838: using guessed type void *off_662838;
// 66291C: using guessed type void *;

//----- (002A4E44) --------------------------------------------------------
void __fastcall AudioScreen::RadioSelection::RadioSelection(AudioScreen::RadioSelection *this)
{
  TextureDatabaseRuntime *Database; // r0
  RwTexture *Texture; // r0
  RwTexture *v4; // r0
  RwTexture *v5; // r0
  RwTexture *v6; // r0
  RwTexture *v7; // r0
  RwTexture *v8; // r0
  RwTexture *v9; // r0
  RwTexture *v10; // r0
  RwTexture *v11; // r0
  RwTexture *v12; // r0
  RwTexture *v13; // r0

  this->tag = MobileSettings::settings[14].name;
  this->forSetting = MS_DefaultStation;
  *(float *)((char *)&this->sliderX2 + 1) = 0.0;
  *(float *)((char *)&this->sliderX1 + 1) = 0.0;
  this->_vptr$MenuSelection = (int (**)(void))&off_662978;
  this->curMoveReq = 0.0;
  this->sliderX1 = 0.0;
  Database = TextureDatabaseRuntime::GetDatabase((const char *)&off_2A4F28);
  TextureDatabaseRuntime::Register(Database);
  Texture = TextureDatabaseRuntime::GetTexture("radio_playback");
  ++Texture->refCount;
  this->radioTex[0] = Texture;
  v4 = TextureDatabaseRuntime::GetTexture("radio_krose");
  ++v4->refCount;
  this->radioTex[1] = v4;
  v5 = TextureDatabaseRuntime::GetTexture("radio_KDST");
  ++v5->refCount;
  this->radioTex[2] = v5;
  v6 = TextureDatabaseRuntime::GetTexture("radio_bounce");
  ++v6->refCount;
  this->radioTex[3] = v6;
  v7 = TextureDatabaseRuntime::GetTexture("radio_SFUR");
  ++v7->refCount;
  this->radioTex[4] = v7;
  v8 = TextureDatabaseRuntime::GetTexture("radio_RLS");
  ++v8->refCount;
  this->radioTex[5] = v8;
  v9 = TextureDatabaseRuntime::GetTexture("radio_RADIOX");
  ++v9->refCount;
  this->radioTex[6] = v9;
  v10 = TextureDatabaseRuntime::GetTexture("radio_csr");
  ++v10->refCount;
  this->radioTex[7] = v10;
  v11 = TextureDatabaseRuntime::GetTexture("radio_kjah");
  ++v11->refCount;
  this->radioTex[8] = v11;
  v12 = TextureDatabaseRuntime::GetTexture("radio_mastersounds");
  ++v12->refCount;
  this->radioTex[9] = v12;
  v13 = TextureDatabaseRuntime::GetTexture("radio_WCTR");
  ++v13->refCount;
  this->radioTex[10] = v13;
  this->radioTex[11] = 0;
}
// 2A4F28: using guessed type void *off_2A4F28;
// 662978: using guessed type void *;

//----- (002A4FC4) --------------------------------------------------------
void __fastcall AudioScreen::OnRestoreDefaults(SelectScreen *screen, int32 data)
{
  SelectScreen::OnRestoreDefaults(screen, data);
  Menu_ApplyAudioSettings();
  sub_19C1C0(&AudioEngine, MobileSettings::settings[14].value);
}

//----- (002A4FF0) --------------------------------------------------------
void __fastcall AudioScreen::~AudioScreen(AudioScreen *this)
{
  void *v1; // r0

  SelectScreen::~SelectScreen(this);
  sub_191374(v1);
}
// 2A4FFC: variable 'v1' is possibly undefined

//----- (002A5008) --------------------------------------------------------
void __fastcall AudioScreen::OnBack(AudioScreen *this)
{
  if ( gMobileMenu.screenStack.numEntries >= 2 )
    (*((void (__fastcall **)(MenuScreen *, MenuScreen *))gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries
                                                                                       - 2]->_vptr$MenuScreen
     + 5))(
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 2],
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
  MobileMenu::RemoveTopScreen(&gMobileMenu, 0, 0);
  CAudioEngine::StopRadio(&AudioEngine, 0, 0);
  CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 35, 0.0, 1.0);
  sub_18FDF8();
}

//----- (002A5074) --------------------------------------------------------
void __fastcall AudioScreen::RadioSelection::~RadioSelection(AudioScreen::RadioSelection *this)
{
  RwTexture_0 *v2; // r0
  RwTexture_0 *v3; // r0
  RwTexture_0 *v4; // r0
  RwTexture_0 *v5; // r0
  RwTexture_0 *v6; // r0
  RwTexture_0 *v7; // r0
  RwTexture_0 *v8; // r0
  RwTexture_0 *v9; // r0
  RwTexture_0 *v10; // r0
  RwTexture_0 *v11; // r0
  RwTexture_0 *v12; // r0
  RwTexture_0 *v13; // r0

  v2 = this->radioTex[0];
  this->_vptr$MenuSelection = (int (**)(void))&off_662978;
  if ( v2 )
  {
    RwTextureDestroy(v2);
    this->radioTex[0] = 0;
  }
  v3 = this->radioTex[1];
  if ( v3 )
  {
    RwTextureDestroy(v3);
    this->radioTex[1] = 0;
  }
  v4 = this->radioTex[2];
  if ( v4 )
  {
    RwTextureDestroy(v4);
    this->radioTex[2] = 0;
  }
  v5 = this->radioTex[3];
  if ( v5 )
  {
    RwTextureDestroy(v5);
    this->radioTex[3] = 0;
  }
  v6 = this->radioTex[4];
  if ( v6 )
  {
    RwTextureDestroy(v6);
    this->radioTex[4] = 0;
  }
  v7 = this->radioTex[5];
  if ( v7 )
  {
    RwTextureDestroy(v7);
    this->radioTex[5] = 0;
  }
  v8 = this->radioTex[6];
  if ( v8 )
  {
    RwTextureDestroy(v8);
    this->radioTex[6] = 0;
  }
  v9 = this->radioTex[7];
  if ( v9 )
  {
    RwTextureDestroy(v9);
    this->radioTex[7] = 0;
  }
  v10 = this->radioTex[8];
  if ( v10 )
  {
    RwTextureDestroy(v10);
    this->radioTex[8] = 0;
  }
  v11 = this->radioTex[9];
  if ( v11 )
  {
    RwTextureDestroy(v11);
    this->radioTex[9] = 0;
  }
  v12 = this->radioTex[10];
  if ( v12 )
  {
    RwTextureDestroy(v12);
    this->radioTex[10] = 0;
  }
  v13 = this->radioTex[11];
  if ( v13 )
  {
    RwTextureDestroy(v13);
    this->radioTex[11] = 0;
  }
}
// 662978: using guessed type void *off_662978;

//----- (002A511C) --------------------------------------------------------
void __fastcall AudioScreen::RadioSelection::~RadioSelection(AudioScreen::RadioSelection *this)
{
  void *v1; // r0

  AudioScreen::RadioSelection::~RadioSelection(this);
  sub_191374(v1);
}
// 2A5128: variable 'v1' is possibly undefined

//----- (002A512C) --------------------------------------------------------
void __fastcall AudioScreen::RadioSelection::Render(
        AudioScreen::RadioSelection *this,
        SelectScreen *fromScreen,
        CVector2D location,
        CVector2D bounds,
        float selectAlpha)
{
  float32x2_t v5; // d0
  float32x2_t v6; // d3
  float v8; // s18
  float v9; // s20
  float v10; // s29
  float v11; // s22
  int v12; // r8
  RwTexture_0 *v13; // r6
  int v14; // r10
  UInt8 alpha; // r0
  float v16; // s23
  float opacity; // s6
  float screenWidth; // s31
  float screenHeight; // s17
  float v20; // s27
  float v21; // s6
  float v22; // s17
  float v23; // s21
  float v24; // s31
  float v25; // s29
  float v26; // s6
  float v27; // s17
  float v28; // s21
  float v29; // s6
  float v30; // s17
  float v31; // s21
  float v32; // s8
  float v33; // s17
  float v34; // s21
  CVector2D v35; // [sp+4h] [bp-ACh]
  RwTexture_0 **radioTex; // [sp+18h] [bp-98h]
  AudioScreen::RadioSelection *v37; // [sp+24h] [bp-8Ch]
  CRGBA v39; // [sp+2Ch] [bp-84h] BYREF
  CRGBA v40; // [sp+30h] [bp-80h] BYREF
  CRGBA v41; // [sp+34h] [bp-7Ch] BYREF
  CRGBA v42; // [sp+38h] [bp-78h] BYREF
  CRGBA v43; // [sp+3Ch] [bp-74h] BYREF
  CRGBA v44; // [sp+40h] [bp-70h] BYREF
  CRGBA v45; // [sp+44h] [bp-6Ch] BYREF
  CRGBA v46; // [sp+48h] [bp-68h] BYREF
  CRGBA v47; // [sp+4Ch] [bp-64h] BYREF
  CVector2D v48; // 0:r3.4,4:^0.4

  v5.n64_f32[0] = bounds.y + 2.0;
  v6.n64_f32[0] = (float)(bounds.x + 2.0) / 12.0;
  v8 = vmin_f32(v5, v6).n64_f32[0];
  v9 = (float)((float)(bounds.y * 0.5) + location.y) - (float)(v8 * 0.5);
  v10 = (float)((float)(bounds.x * 0.5) + location.x) + (float)(v8 * -6.0);
  v11 = v8 + v9;
  this->ul.x = v10;
  this->ul.y = v9;
  this->lr.x = (float)(v8 * 12.0) + v10;
  this->lr.y = v8 + v9;
  CRGBA::CRGBA(&v44, 0, 0, 0, 0);
  CRGBA::CRGBA(&v45, 0, 0, 0, 0);
  CRGBA::CRGBA(&v46, 0xF0u, 0xF0u, 0xF0u, 0x60u);
  CRGBA::CRGBA(&v47, 0xF0u, 0xF0u, 0xF0u, 0x60u);
  CRGBA::CRGBA(&v40, 0xFFu, 0xFFu, 0xFFu, 0x80u);
  CRGBA::CRGBA(&v41, 0xFFu, 0xFFu, 0xFFu, 0x80u);
  CRGBA::CRGBA(&v42, 0xFFu, 0xFFu, 0xFFu, 0x80u);
  CRGBA::CRGBA(&v43, 0xFFu, 0xFFu, 0xFFu, 0x80u);
  v12 = 0;
  v37 = this;
  radioTex = this->radioTex;
  do
  {
    v13 = radioTex[v12];
    v14 = MobileSettings::settings[v37->forSetting].value - 1;
    alpha = -116;
    if ( v12 == v14 )
      alpha = -1;
    CRGBA::CRGBA(&v39, 0xFFu, 0xFFu, 0xFFu, alpha);
    v48.x = v10;
    v16 = v8 + v10;
    v35.y = v8 + v9;
    v35.x = v8 + v10;
    v48.y = v9;
    MenuScreen::DrawSprite(fromScreen, v13, (CRGBA)&v39, v48, v35, 0);
    if ( v12 == v14 )
    {
      opacity = fromScreen->opacity;
      screenWidth = (float)RsGlobal.screenWidth;
      screenHeight = (float)RsGlobal.screenHeight;
      v44._anon_0._anon_0.alpha = (unsigned int)(float)(opacity * (float)v44._anon_0._anon_0.alpha);
      v45._anon_0._anon_0.alpha = (unsigned int)(float)(opacity * (float)v45._anon_0._anon_0.alpha);
      v46._anon_0._anon_0.alpha = (unsigned int)(float)(opacity * (float)v46._anon_0._anon_0.alpha);
      v47._anon_0._anon_0.alpha = (unsigned int)(float)(opacity * (float)v47._anon_0._anon_0.alpha);
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
      v20 = v10 + -320.0;
      *(CRGBA *)&maVertices[0].r = v44;
      maVertices[0].z = 1.0;
      maVertices[0].rhw = 1.0;
      maVertices[0].s = 0.0;
      maVertices[0].t = 0.0;
      maVertices[1].z = 1.0;
      maVertices[1].rhw = 1.0;
      maVertices[1].s = 1.0;
      maVertices[1].t = 0.0;
      maVertices[0].x = (float)(screenWidth * 0.5) + (float)((float)((float)(v10 + -320.0) * screenHeight) / 480.0);
      maVertices[0].y = (float)(v9 * screenHeight) / 480.0;
      maVertices[1].x = (float)(screenWidth * 0.5) + (float)((float)((float)(v16 + -320.0) * screenHeight) / 480.0);
      maVertices[1].y = (float)(v9 * screenHeight) / 480.0;
      *(CRGBA *)&maVertices[1].r = v45;
      maVertices[2].z = 1.0;
      maVertices[2].rhw = 1.0;
      maVertices[2].s = 0.0;
      maVertices[2].t = 1.0;
      maVertices[2].x = maVertices[0].x;
      maVertices[2].y = (float)(v11 * screenHeight) / 480.0;
      *(CRGBA *)&maVertices[2].r = v46;
      maVertices[3].z = 1.0;
      maVertices[3].rhw = 1.0;
      maVertices[3].s = 1.0;
      maVertices[3].t = 1.0;
      maVertices[3].x = maVertices[1].x;
      maVertices[3].y = (float)(v11 * screenHeight) / 480.0;
      *(CRGBA *)&maVertices[3].r = v47;
      RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, maVertices, 4);
      v21 = fromScreen->opacity;
      v22 = (float)RsGlobal.screenWidth;
      v23 = (float)RsGlobal.screenHeight;
      v40._anon_0._anon_0.alpha = (unsigned int)(float)(v21 * (float)v40._anon_0._anon_0.alpha);
      v43._anon_0._anon_0.alpha = (unsigned int)(float)(v21 * (float)v43._anon_0._anon_0.alpha);
      v42._anon_0._anon_0.alpha = (unsigned int)(float)(v21 * (float)v42._anon_0._anon_0.alpha);
      v41._anon_0._anon_0.alpha = (unsigned int)(float)(v21 * (float)v41._anon_0._anon_0.alpha);
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
      *(CRGBA *)&maVertices[0].r = v40;
      maVertices[0].z = 1.0;
      maVertices[0].rhw = 1.0;
      maVertices[0].s = 0.0;
      maVertices[0].t = 0.0;
      maVertices[1].z = 1.0;
      maVertices[1].rhw = 1.0;
      maVertices[1].s = 1.0;
      maVertices[1].t = 0.0;
      v24 = (float)(v10 + 1.0) + -320.0;
      v25 = (float)(v16 + -1.0) + -320.0;
      maVertices[0].x = (float)(v22 * 0.5) + (float)((float)(v24 * v23) / 480.0);
      maVertices[0].y = (float)(v9 * v23) / 480.0;
      maVertices[1].x = (float)(v22 * 0.5) + (float)((float)(v25 * v23) / 480.0);
      maVertices[1].y = (float)(v9 * v23) / 480.0;
      *(CRGBA *)&maVertices[1].r = v41;
      maVertices[2].z = 1.0;
      maVertices[2].rhw = 1.0;
      maVertices[2].s = 0.0;
      maVertices[2].t = 1.0;
      maVertices[2].x = maVertices[0].x;
      maVertices[2].y = (float)((float)(v9 + 0.75) * v23) / 480.0;
      *(CRGBA *)&maVertices[2].r = v42;
      maVertices[3].z = 1.0;
      maVertices[3].rhw = 1.0;
      maVertices[3].s = 1.0;
      maVertices[3].t = 1.0;
      maVertices[3].x = maVertices[1].x;
      maVertices[3].y = (float)((float)(v9 + 0.75) * v23) / 480.0;
      *(CRGBA *)&maVertices[3].r = v43;
      RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, maVertices, 4);
      v26 = fromScreen->opacity;
      v27 = (float)RsGlobal.screenHeight;
      v28 = (float)RsGlobal.screenWidth;
      v40._anon_0._anon_0.alpha = (unsigned int)(float)(v26 * (float)v40._anon_0._anon_0.alpha);
      v41._anon_0._anon_0.alpha = (unsigned int)(float)(v26 * (float)v41._anon_0._anon_0.alpha);
      v42._anon_0._anon_0.alpha = (unsigned int)(float)(v26 * (float)v42._anon_0._anon_0.alpha);
      v43._anon_0._anon_0.alpha = (unsigned int)(float)(v26 * (float)v43._anon_0._anon_0.alpha);
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
      *(CRGBA *)&maVertices[0].r = v40;
      maVertices[0].z = 1.0;
      maVertices[0].rhw = 1.0;
      maVertices[0].s = 0.0;
      maVertices[0].t = 0.0;
      maVertices[1].z = 1.0;
      maVertices[1].rhw = 1.0;
      maVertices[1].s = 1.0;
      maVertices[1].t = 0.0;
      maVertices[0].x = (float)(v28 * 0.5) + (float)((float)(v24 * v27) / 480.0);
      maVertices[0].y = (float)((float)(v11 + -0.75) * v27) / 480.0;
      maVertices[1].x = (float)(v28 * 0.5) + (float)((float)(v25 * v27) / 480.0);
      maVertices[1].y = (float)((float)(v11 + -0.75) * v27) / 480.0;
      *(CRGBA *)&maVertices[1].r = v41;
      maVertices[2].z = 1.0;
      maVertices[2].rhw = 1.0;
      maVertices[2].s = 0.0;
      maVertices[2].t = 1.0;
      maVertices[2].x = maVertices[0].x;
      maVertices[2].y = (float)(v11 * v27) / 480.0;
      *(CRGBA *)&maVertices[2].r = v42;
      maVertices[3].z = 1.0;
      maVertices[3].rhw = 1.0;
      maVertices[3].s = 1.0;
      maVertices[3].t = 1.0;
      maVertices[3].x = maVertices[1].x;
      maVertices[3].y = (float)(v11 * v27) / 480.0;
      *(CRGBA *)&maVertices[3].r = v43;
      RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, maVertices, 4);
      v29 = fromScreen->opacity;
      v30 = (float)RsGlobal.screenHeight;
      v31 = (float)RsGlobal.screenWidth;
      v40._anon_0._anon_0.alpha = (unsigned int)(float)(v29 * (float)v40._anon_0._anon_0.alpha);
      v41._anon_0._anon_0.alpha = (unsigned int)(float)(v29 * (float)v41._anon_0._anon_0.alpha);
      v42._anon_0._anon_0.alpha = (unsigned int)(float)(v29 * (float)v42._anon_0._anon_0.alpha);
      v43._anon_0._anon_0.alpha = (unsigned int)(float)(v29 * (float)v43._anon_0._anon_0.alpha);
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
      *(CRGBA *)&maVertices[0].r = v40;
      maVertices[0].z = 1.0;
      maVertices[0].rhw = 1.0;
      maVertices[0].s = 0.0;
      maVertices[0].t = 0.0;
      maVertices[1].z = 1.0;
      maVertices[1].rhw = 1.0;
      maVertices[1].s = 1.0;
      maVertices[1].t = 0.0;
      maVertices[0].x = (float)(v31 * 0.5) + (float)((float)(v20 * v30) / 480.0);
      maVertices[0].y = (float)(v9 * v30) / 480.0;
      maVertices[1].x = (float)(v31 * 0.5) + (float)((float)(v24 * v30) / 480.0);
      maVertices[1].y = (float)(v9 * v30) / 480.0;
      *(CRGBA *)&maVertices[1].r = v41;
      maVertices[2].z = 1.0;
      maVertices[2].rhw = 1.0;
      maVertices[2].s = 0.0;
      maVertices[2].t = 1.0;
      maVertices[2].x = maVertices[0].x;
      maVertices[2].y = (float)(v11 * v30) / 480.0;
      *(CRGBA *)&maVertices[2].r = v42;
      maVertices[3].z = 1.0;
      maVertices[3].rhw = 1.0;
      maVertices[3].s = 1.0;
      maVertices[3].t = 1.0;
      maVertices[3].x = maVertices[1].x;
      maVertices[3].y = (float)(v11 * v30) / 480.0;
      *(CRGBA *)&maVertices[3].r = v43;
      RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, maVertices, 4);
      v32 = fromScreen->opacity;
      v33 = (float)RsGlobal.screenHeight;
      v34 = (float)RsGlobal.screenWidth;
      v40._anon_0._anon_0.alpha = (unsigned int)(float)(v32 * (float)v40._anon_0._anon_0.alpha);
      v41._anon_0._anon_0.alpha = (unsigned int)(float)(v32 * (float)v41._anon_0._anon_0.alpha);
      v42._anon_0._anon_0.alpha = (unsigned int)(float)(v32 * (float)v42._anon_0._anon_0.alpha);
      v43._anon_0._anon_0.alpha = (unsigned int)(float)(v32 * (float)v43._anon_0._anon_0.alpha);
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, 0);
      maVertices[0].z = 1.0;
      maVertices[0].rhw = 1.0;
      maVertices[0].s = 0.0;
      maVertices[0].t = 0.0;
      maVertices[1].z = 1.0;
      maVertices[1].rhw = 1.0;
      maVertices[1].s = 1.0;
      maVertices[1].t = 0.0;
      *(CRGBA *)&maVertices[0].r = v40;
      maVertices[0].x = (float)(v34 * 0.5) + (float)((float)(v25 * v33) / 480.0);
      maVertices[0].y = (float)(v9 * v33) / 480.0;
      maVertices[1].x = (float)(v34 * 0.5) + (float)((float)((float)(v16 + -320.0) * v33) / 480.0);
      maVertices[1].y = (float)(v9 * v33) / 480.0;
      *(CRGBA *)&maVertices[1].r = v41;
      maVertices[2].z = 1.0;
      maVertices[2].rhw = 1.0;
      maVertices[2].s = 0.0;
      maVertices[2].t = 1.0;
      maVertices[2].x = maVertices[0].x;
      maVertices[2].y = (float)(v11 * v33) / 480.0;
      *(CRGBA *)&maVertices[2].r = v42;
      maVertices[3].z = 1.0;
      maVertices[3].rhw = 1.0;
      maVertices[3].s = 1.0;
      maVertices[3].t = 1.0;
      maVertices[3].x = maVertices[1].x;
      maVertices[3].y = (float)(v11 * v33) / 480.0;
      *(CRGBA *)&maVertices[3].r = v43;
      RwIm2DRenderPrimitive_BUGFIX(rwPRIMTYPETRISTRIP, maVertices, 4);
    }
    v10 = v16;
    ++v12;
  }
  while ( v12 != 11 );
}
// 2A5180: variable 'v5' is possibly undefined
// 2A5180: variable 'v6' is possibly undefined
// 10: using guessed type __int16 word_10;
// 12: using guessed type __int16 word_12;
// 2C: using guessed type __int16 word_2C;
// 2E: using guessed type __int16 word_2E;
// 48: using guessed type int dword_48;
// 64: using guessed type int dword_64;

//----- (002A5AA0) --------------------------------------------------------
void __fastcall AudioScreen::RadioSelection::HandleInput(
        AudioScreen::RadioSelection *this,
        SelectScreen *fromScreen,
        float deltaTime)
{
  float x; // s0
  float v4; // s2
  float v5; // s4
  float y; // s6
  int v7; // s0
  int v8; // r1

  if ( gMobileMenu.pointerState[lastDevice] )
  {
    sub_19FC7C(this, fromScreen, deltaTime);
  }
  else
  {
    x = this->ul.x;
    v4 = gMobileMenu.pointerCoords[lastDevice].x;
    if ( v4 >= x )
    {
      v5 = this->lr.x;
      if ( v4 <= v5 )
      {
        y = gMobileMenu.pointerCoords[lastDevice].y;
        if ( y >= this->ul.y && y <= this->lr.y )
        {
          v7 = (int)(float)((float)((float)(v4 - x) * 12.0) / (float)(v5 - x));
          v8 = v7 + 1;
          if ( v7 != 11 && v8 != MobileSettings::settings[14].value )
          {
            MobileSettings::settings[14].value = v7 + 1;
            sub_19C1C0(&AudioEngine, v8);
          }
        }
      }
    }
  }
}

//----- (002A5B8C) --------------------------------------------------------
void __fastcall LanguageScreen::LanguageScreen(LanguageScreen *this)
{
  SelectScreen::MenuSelection *v2; // r0
  SelectScreen::MenuSelection v3; // r2
  SelectScreen::MenuSelection *v4; // r0
  SelectScreen::MenuSelection *v5; // r0
  SelectScreen::MenuSelection *v6; // r0
  SelectScreen::MenuSelection *v7; // r0
  SelectScreen::MenuSelection *v8; // r0
  SelectScreen::MenuSelection *v9; // r0

  CharSelectScreen::CharSelectScreen(this, "FEH_LAN", 1);
  this->_vptr$MenuScreen = (int (**)(void))&off_6629A4;
  v2 = (SelectScreen::MenuSelection *)operator new(0x10u);
  v3.tag = "FEL_ENG";
  v3._vptr$MenuSelection = (int (**)(void))&off_66280C;
  *v2 = v3;
  v2[1]._vptr$MenuSelection = (int (**)(void))LanguageScreen::English;
  v2[1].tag = 0;
  SelectScreen::AddItem(this, v2);
  if ( !ForceGermanBuild )
  {
    v4 = (SelectScreen::MenuSelection *)operator new(0x10u);
    v4->tag = "FEL_FRE";
    v4[1]._vptr$MenuSelection = (int (**)(void))LanguageScreen::French;
    v4[1].tag = 0;
    v4->_vptr$MenuSelection = (int (**)(void))&off_66280C;
    SelectScreen::AddItem(this, v4);
    v5 = (SelectScreen::MenuSelection *)operator new(0x10u);
    v5->_vptr$MenuSelection = (int (**)(void))&off_66280C;
    v5->tag = "FEL_ITA";
    v5[1]._vptr$MenuSelection = (int (**)(void))LanguageScreen::Italian;
    v5[1].tag = 0;
    SelectScreen::AddItem(this, v5);
  }
  v6 = (SelectScreen::MenuSelection *)operator new(0x10u);
  v6->tag = "FEL_GER";
  v6[1]._vptr$MenuSelection = (int (**)(void))LanguageScreen::German;
  v6[1].tag = 0;
  v6->_vptr$MenuSelection = (int (**)(void))&off_66280C;
  SelectScreen::AddItem(this, v6);
  if ( !ForceGermanBuild )
  {
    v7 = (SelectScreen::MenuSelection *)operator new(0x10u);
    v7->tag = "FEL_SPA";
    v7[1]._vptr$MenuSelection = (int (**)(void))LanguageScreen::Spanish;
    v7[1].tag = 0;
    v7->_vptr$MenuSelection = (int (**)(void))&off_66280C;
    SelectScreen::AddItem(this, v7);
    v8 = (SelectScreen::MenuSelection *)operator new(0x10u);
    v8->_vptr$MenuSelection = (int (**)(void))&off_66280C;
    v8->tag = "FEL_JPN";
    v8[1]._vptr$MenuSelection = (int (**)(void))LanguageScreen::Japenese;
    v8[1].tag = 0;
    SelectScreen::AddItem(this, v8);
    v9 = (SelectScreen::MenuSelection *)operator new(0x10u);
    v9->_vptr$MenuSelection = (int (**)(void))&off_66280C;
    v9->tag = "FEL_RUS";
    v9[1]._vptr$MenuSelection = (int (**)(void))LanguageScreen::Russian;
    v9[1].tag = 0;
    SelectScreen::AddItem(this, v9);
  }
}
// 66280C: using guessed type void *off_66280C;
// 6629A4: using guessed type void *off_6629A4;

//----- (002A5D38) --------------------------------------------------------
void __fastcall LanguageScreen::English(SelectScreen *fromScreen, int32 data)
{
  MobileSettings::settings[17].value = 0;
  OS_ServiceAppCommand("SetLocale", (const unsigned __int8 *)&dword_2A5D64);
  sub_19F2D0();
}
// 2A5D64: using guessed type int dword_2A5D64;

//----- (002A5D68) --------------------------------------------------------
void __fastcall LanguageScreen::Japenese(SelectScreen *fromScreen, int32 data)
{
  MobileSettings::settings[17].value = 6;
  OS_ServiceAppCommand("SetLocale", (const unsigned __int8 *)&dword_2A5D94);
  sub_19F2D0();
}
// 2A5D94: using guessed type int dword_2A5D94;

//----- (002A5D98) --------------------------------------------------------
void __fastcall LanguageScreen::French(SelectScreen *fromScreen, int32 data)
{
  MobileSettings::settings[17].value = 1;
  OS_ServiceAppCommand("SetLocale", (const unsigned __int8 *)&dword_2A5DC4);
  sub_19F2D0();
}
// 2A5DC4: using guessed type int dword_2A5DC4;

//----- (002A5DC8) --------------------------------------------------------
void __fastcall LanguageScreen::Italian(SelectScreen *fromScreen, int32 data)
{
  MobileSettings::settings[17].value = 3;
  OS_ServiceAppCommand("SetLocale", (const unsigned __int8 *)&dword_2A5DF4);
  sub_19F2D0();
}
// 2A5DF4: using guessed type int dword_2A5DF4;

//----- (002A5DF8) --------------------------------------------------------
void __fastcall LanguageScreen::German(SelectScreen *fromScreen, int32 data)
{
  MobileSettings::settings[17].value = 2;
  OS_ServiceAppCommand("SetLocale", (const unsigned __int8 *)&off_2A5E24);
  sub_19F2D0();
}
// 2A5E24: using guessed type void *off_2A5E24;

//----- (002A5E28) --------------------------------------------------------
void __fastcall LanguageScreen::Spanish(SelectScreen *fromScreen, int32 data)
{
  MobileSettings::settings[17].value = 4;
  OS_ServiceAppCommand("SetLocale", (const unsigned __int8 *)&dword_2A5E54);
  sub_19F2D0();
}
// 2A5E54: using guessed type int dword_2A5E54;

//----- (002A5E58) --------------------------------------------------------
void __fastcall LanguageScreen::Russian(SelectScreen *fromScreen, int32 data)
{
  MobileSettings::settings[17].value = 5;
  OS_ServiceAppCommand("SetLocale", (const unsigned __int8 *)&dword_2A5E84);
  sub_19F2D0();
}
// 2A5E84: using guessed type int dword_2A5E84;

//----- (002A5E88) --------------------------------------------------------
void __fastcall LanguageScreen::~LanguageScreen(LanguageScreen *this)
{
  void *v1; // r0

  SelectScreen::~SelectScreen(this);
  sub_191374(v1);
}
// 2A5E94: variable 'v1' is possibly undefined

//----- (002A5E98) --------------------------------------------------------
void __fastcall StatsScreen::StatsScreen(StatsScreen *this)
{
  RwTexture *Texture; // r0
  SelectScreen::MenuSelection *v3; // r0
  SelectScreen::MenuSelection *v4; // r0
  SelectScreen::MenuSelection *v5; // r0
  SelectScreen::MenuSelection *v6; // r0
  SelectScreen::MenuSelection *v7; // r0
  SelectScreen::MenuSelection *v8; // r0
  SelectScreen::MenuSelection *v9; // r0
  SelectScreen::MenuSelection *v10; // r0

  this->hasBack = 1;
  this->_vptr$MenuScreen = (int (**)(void))&off_662590;
  Texture = TextureDatabaseRuntime::GetTexture("menu_selector");
  ++Texture->refCount;
  *(_QWORD *)((char *)&this->selected.numAlloced + 1) = 0LL;
  *(_QWORD *)((char *)&this->selected.dataPtr + 1) = 0LL;
  *(_QWORD *)&this->items.numAlloced = 0LL;
  *(_QWORD *)&this->items.dataPtr = 0LL;
  this->titleTag = "FEH_STA";
  this->_vptr$MenuScreen = (int (**)(void))&off_662A00;
  this->arrowTex = Texture;
  this->opacity = 0.0;
  this->scrollPos = -200.0;
  this->currentCategory = 0;
  AddMenuStat(eStats, 1);
  AddMenuStat((MenuStat)(this->currentCategory + 14), 1);
  v3 = (SelectScreen::MenuSelection *)operator new(0x10u);
  v3->tag = "FES_PLA";
  v3->_vptr$MenuSelection = (int (**)(void))&off_66280C;
  v3[1]._vptr$MenuSelection = (int (**)(void))StatsScreen::StatsCat;
  v3[1].tag = 0;
  SelectScreen::AddItem(this, v3);
  v4 = (SelectScreen::MenuSelection *)operator new(0x10u);
  v4->_vptr$MenuSelection = (int (**)(void))&off_66280C;
  v4->tag = "FES_MON";
  v4[1]._vptr$MenuSelection = (int (**)(void))StatsScreen::StatsCat;
  v4[1].tag = (_BYTE *)(&dword_0 + 1);
  SelectScreen::AddItem(this, v4);
  v5 = (SelectScreen::MenuSelection *)operator new(0x10u);
  v5->_vptr$MenuSelection = (int (**)(void))&off_66280C;
  v5->tag = "FES_WEA";
  v5[1]._vptr$MenuSelection = (int (**)(void))StatsScreen::StatsCat;
  v5[1].tag = (_BYTE *)(&dword_0 + 2);
  SelectScreen::AddItem(this, v5);
  v6 = (SelectScreen::MenuSelection *)operator new(0x10u);
  v6->_vptr$MenuSelection = (int (**)(void))&off_66280C;
  v6->tag = "FES_CRI";
  v6[1]._vptr$MenuSelection = (int (**)(void))StatsScreen::StatsCat;
  v6[1].tag = (_BYTE *)(&dword_0 + 3);
  SelectScreen::AddItem(this, v6);
  v7 = (SelectScreen::MenuSelection *)operator new(0x10u);
  v7->_vptr$MenuSelection = (int (**)(void))&off_66280C;
  v7->tag = "FES_GAN";
  v7[1]._vptr$MenuSelection = (int (**)(void))StatsScreen::StatsCat;
  v7[1].tag = (const unsigned __int8 *)byte_4;
  SelectScreen::AddItem(this, v7);
  v8 = (SelectScreen::MenuSelection *)operator new(0x10u);
  v8->_vptr$MenuSelection = (int (**)(void))&off_66280C;
  v8->tag = "FES_ACH";
  v8[1]._vptr$MenuSelection = (int (**)(void))StatsScreen::StatsCat;
  v8[1].tag = (const unsigned __int8 *)&byte_5;
  SelectScreen::AddItem(this, v8);
  v9 = (SelectScreen::MenuSelection *)operator new(0x10u);
  v9->_vptr$MenuSelection = (int (**)(void))&off_66280C;
  v9->tag = "FES_MIS";
  v9[1]._vptr$MenuSelection = (int (**)(void))StatsScreen::StatsCat;
  v9[1].tag = (const unsigned __int8 *)&byte_6;
  SelectScreen::AddItem(this, v9);
  v10 = (SelectScreen::MenuSelection *)operator new(0x10u);
  v10->_vptr$MenuSelection = (int (**)(void))&off_66280C;
  v10->tag = "FES_MSC";
  v10[1]._vptr$MenuSelection = (int (**)(void))StatsScreen::StatsCat;
  v10[1].tag = (const unsigned __int8 *)&byte_7;
  SelectScreen::AddItem(this, v10);
}
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;
// 7: using guessed type char byte_7;
// 662590: using guessed type void *off_662590;
// 66280C: using guessed type void *off_66280C;
// 662A00: using guessed type void *;

//----- (002A604C) --------------------------------------------------------
void __fastcall StatsScreen::StatsCat(SelectScreen *screen, int data)
{
  if ( screen[1].arrowTex != (RwTexture_0 *)data )
  {
    screen[1]._vptr$MenuScreen = (int (**)(void))-1018691584;
    screen[1].arrowTex = (RwTexture_0 *)data;
    sub_199F18((MenuStat)(data + 14), 1);
  }
}

//----- (002A6068) --------------------------------------------------------
void __fastcall StatsScreen::~StatsScreen(StatsScreen *this)
{
  void *v1; // r0

  SelectScreen::~SelectScreen(this);
  sub_191374(v1);
}
// 2A6074: variable 'v1' is possibly undefined

//----- (002A6078) --------------------------------------------------------
void __fastcall StatsScreen::Update(StatsScreen *this, float deltaTime)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d2
  float v6; // s0
  float v7; // s0
  float y; // s2
  float v9; // s0
  CVector2D *v10; // r0
  CVector2D *v11; // r0

  SelectScreen::Update(this, deltaTime);
  if ( CHID::IsPressedPositive(HID_MAPPING_LOOK_Y) )
  {
    v6 = 150.0;
  }
  else
  {
    if ( CHID::IsPressedNegative(HID_MAPPING_LOOK_Y) )
    {
      v7 = this->scrollPos + (float)(deltaTime * -150.0);
      goto LABEL_11;
    }
    if ( gMobileMenu.pointerMode
      && gMobileMenu.pointerState[lastDevice] == OSPS_ButtonDown
      && gMobileMenu.pointerCoords[lastDevice].x > 200.0 )
    {
      v3.n64_u32[0] = -30.0;
      v2.n64_u32[0] = LODWORD(this->scrollPos);
      y = this->lastCoords.y;
      v9 = vmax_f32(v2, v3).n64_f32[0];
      v10 = &gMobileMenu.bgUVSize + lastDevice;
      this->scrollPos = v9;
      v7 = v9 - (float)(v10[14].y - y);
      goto LABEL_11;
    }
    v6 = 20.0;
  }
  v7 = (float)(deltaTime * v6) + this->scrollPos;
LABEL_11:
  this->scrollPos = v7;
  if ( v7 < -200.0 )
    this->scrollPos = -200.0;
  v11 = &gMobileMenu.bgUVSize + lastDevice;
  this->lastCoords.x = v11[14].x;
  this->lastCoords.y = v11[14].y;
}
// 2A610C: variable 'v2' is possibly undefined
// 2A610C: variable 'v3' is possibly undefined

//----- (002A61A0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall StatsScreen::Render(StatsScreen *this, int stackPos)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d2
  float32x2_t v5; // d13
  Int32 v7; // r5
  Int32 v8; // r8
  float v9; // s20
  float v10; // s31
  GxtChar *v11; // r0
  GxtChar *v12; // r0
  GxtChar *v13; // r0
  GxtChar *v14; // r0
  GxtChar *v15; // r0
  GxtChar *v16; // r0
  GxtChar *v17; // r0
  GxtChar *v18; // r0
  GxtChar *v19; // r0
  GxtChar *v20; // r0
  bool v21; // zf
  _BOOL4 v22; // r0
  float v23; // s25
  float i; // s29
  float v25; // s2
  float v26; // s2
  int v27; // s0
  float32x2_t v28; // d0
  unsigned int v29; // r11
  int v30; // r0
  float StatValue; // r0
  int v32; // r1 OVERLAPPED
  int v33; // r3
  float v34; // r2
  GxtChar *v35; // r0
  GxtChar *v36; // r0
  GxtChar *v37; // r0
  GxtChar *v38; // r0
  GxtChar *v39; // r0
  CPlayerPed *PlayerPed; // r0
  int WeaponSkill; // r0
  const char *v42; // r1
  GxtChar *v43; // r1
  Int32 CriminalRatingNumber; // r0
  const GxtChar *CriminalRatingString; // r0
  float v46; // s22
  float v47; // r6
  float v48; // s18
  int v49; // r0
  CRGBA v50; // r0
  float alpha; // [sp+0h] [bp-370h]
  CVector2D position; // [sp+Ch] [bp-364h]
  CVector2D positiona; // [sp+Ch] [bp-364h]
  CVector2D positionb; // [sp+Ch] [bp-364h]
  CVector2D positionc; // [sp+Ch] [bp-364h]
  CVector2D positiond; // [sp+Ch] [bp-364h]
  CVector2D positione; // [sp+Ch] [bp-364h]
  int v59; // [sp+C8h] [bp-2A8h]
  CVector2D pOutput; // [sp+DCh] [bp-294h] BYREF
  CRGBA v61; // [sp+E4h] [bp-28Ch] BYREF
  CRGBA v62; // [sp+E8h] [bp-288h] BYREF
  CRGBA v63; // [sp+ECh] [bp-284h] BYREF
  CRGBA color; // [sp+F0h] [bp-280h] BYREF
  CRGBA v65; // [sp+F4h] [bp-27Ch] BYREF
  CVector2D v66; // [sp+F8h] [bp-278h] BYREF
  CRGBA v67; // [sp+100h] [bp-270h] BYREF
  CVector2D v68; // [sp+104h] [bp-26Ch] BYREF
  CRGBA v69; // [sp+304h] [bp-6Ch] BYREF
  CRGBA v70; // [sp+308h] [bp-68h] BYREF
  CRGBA v71; // [sp+30Ch] [bp-64h] BYREF

  v7 = CStats::ConstructStatLine(99999, this->currentCategory);
  CRGBA::CRGBA(&v71, 0xF0u, 0xF0u, 0xF0u, 0xFFu);
  CRGBA::CRGBA(&v70, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
  if ( v7 >= 1 )
  {
    v3.n64_u32[0] = -30.0;
    v2.n64_u32[0] = LODWORD(this->scrollPos);
    v8 = 0;
    v5.n64_u32[0] = 1132396544;
    v9 = (float)(v7 + 7) * 34.0;
    v10 = (float)(50.0 - vmax_f32(v2, v3).n64_f32[0]) + -34.0;
    v59 = 0;
    while ( 1 )
    {
      CStats::ConstructStatLine(v8, this->currentCategory);
      v23 = v10 + 34.0;
      if ( !gGxtString[0] )
        v23 = v10;
      for ( i = v23; i < 50.0; i = v9 + i )
        ;
      while ( i > (float)((float)RsGlobal.screenHeight + -50.0) )
        i = i - v9;
      if ( i <= 20.0 || i >= 450.0 )
      {
        v10 = v23;
        goto LABEL_71;
      }
      v25 = 0.0;
      v4.n64_u32[0] = 0;
      if ( i > 390.0 )
        v25 = (float)(420.0 - i) * 8.0;
      if ( i < 420.0 )
        v4.n64_f32[0] = v25;
      v26 = v4.n64_f32[0];
      if ( i < 80.0 )
        v26 = (float)(i + -50.0) * 8.0;
      if ( i > 50.0 )
        v4.n64_f32[0] = v26;
      v27 = v4.n64_u32[0];
      if ( i <= 390.0 )
        v27 = 1132396544;
      if ( i >= 80.0 )
        v4.n64_u32[0] = v27;
      v28.n64_u64[0] = vmin_f32(v4, v5).n64_u64[0];
      v29 = (unsigned int)v28.n64_f32[0];
      v71._anon_0._anon_0.alpha = (unsigned int)v28.n64_f32[0];
      v69 = v71;
      v70._anon_0._anon_0.alpha = v71._anon_0._anon_0.alpha;
      v30 = 1131413504;
      if ( !this->currentCategory )
        v30 = 1129447424;
      positionb.y = i + 8.5;
      positionb.x = 210.0;
      MenuScreen::DrawTextDirect(
        &v68,
        this,
        gGxtString,
        TA_Left,
        1,
        (CRGBA)&v69,
        1,
        positionb,
        (CVector2D)((unsigned int)v30 | 0x4188000000000000LL),
        0,
        0);
      if ( CStats::m_ThisStatIsABarChart )
      {
        StatValue = CStats::GetStatValue(CStats::m_ThisStatIsABarChart);
        v4.n64_u32[0] = 1.0;
        v32 = 1139146752;
        v28.n64_f32[0] = StatValue / 1000.0;
        v33 = 1142456320;
        v4.n64_u64[0] = vmin_f32(v28, v4).n64_u64[0];
        if ( (float)(StatValue / 1000.0) < 0.0 )
          v4.n64_u32[0] = 0;
        alpha = i + 25.5;
        v34 = i + 8.5;
        MenuScreen::DrawSlider(this, *(CVector2D *)&v32, *(CVector2D *)&v33, v4.n64_f32[0], 0, v29, 0);
        goto LABEL_51;
      }
      v35 = CText::Get(&TheText, "STAT328");
      if ( CMessages::GxtStringCompare(v35, gGxtString, 0x190u)
        || (v36 = CText::Get(&TheText, "ST_LAB0"), CMessages::GxtStringCompare(v36, gGxtString, 0x190u))
        || (v37 = CText::Get(&TheText, "ST_LAB1"), CMessages::GxtStringCompare(v37, gGxtString, 0x190u))
        || (v38 = CText::Get(&TheText, "ST_LAB2"), CMessages::GxtStringCompare(v38, gGxtString, 0x190u)) )
      {
        CStats::ConstructStatLine(v8, this->currentCategory);
        v39 = CText::Get(&TheText, "STAT328");
        if ( CMessages::GxtStringCompare(v39, gGxtString, 0x190u) )
        {
          PlayerPed = FindPlayerPed(-1);
          WeaponSkill = CPed::GetWeaponSkill(PlayerPed);
          switch ( WeaponSkill )
          {
            case 0:
              goto LABEL_65;
            case 2:
              v42 = "WS_PRO";
              break;
            case 1:
              v42 = "WS_STD";
              break;
            default:
LABEL_65:
              v42 = "WS_POOR";
              break;
          }
          v43 = CText::Get(&TheText, (const unsigned __int8 *)v42);
        }
        else
        {
          v43 = gGxtString2;
        }
        GxtCharStrcpy((GxtChar *)&v68, v43);
        AsciiToGxtChar((const Char *)&dword_2A6B14, (GxtChar *)&pOutput);
        GxtCharStrcat((GxtChar *)&v68, (GxtChar *)&pOutput);
        CStats::ConstructStatLine(v8 + 1, this->currentCategory);
        GxtCharStrcat((GxtChar *)&v68, gGxtString2);
        if ( FrontEndMenuManager.m_PrefsLanguage == 5 )
        {
          v67 = v70;
          positionc.x = 360.0;
          positionc.y = i + 8.5;
          MenuScreen::DrawTextDirect(
            &v66,
            this,
            (GxtChar *)&v68,
            TA_Right,
            1,
            (CRGBA)&v67,
            1,
            positionc,
            (CVector2D)0x41880000437A0000LL,
            0,
            0);
        }
        else
        {
          v65 = v70;
          positiond.x = 460.0;
          positiond.y = i + 8.5;
          MenuScreen::DrawTextDirect(
            &v66,
            this,
            (GxtChar *)&v68,
            TA_Right,
            1,
            (CRGBA)&v65,
            1,
            positiond,
            (CVector2D)0x4188000043160000LL,
            0,
            0);
        }
        v10 = v23;
        v59 = 1;
        goto LABEL_71;
      }
      if ( CFont::GetStringWidth(gGxtString2, 1u, 0) <= 200.0 )
        break;
      v11 = CText::Get(&TheText, "NOSTUC");
      if ( !CMessages::GxtStringCompare(v11, gGxtString2, 0x190u) )
      {
        v12 = CText::Get(&TheText, "INSTUN");
        if ( !CMessages::GxtStringCompare(v12, gGxtString2, 0x190u) )
        {
          v13 = CText::Get(&TheText, "PRINST");
          if ( !CMessages::GxtStringCompare(v13, gGxtString2, 0x190u) )
          {
            v14 = CText::Get(&TheText, "DBINST");
            if ( !CMessages::GxtStringCompare(v14, gGxtString2, 0x190u) )
            {
              v15 = CText::Get(&TheText, "DBPINS");
              if ( !CMessages::GxtStringCompare(v15, gGxtString2, 0x190u) )
              {
                v16 = CText::Get(&TheText, "TRINST");
                if ( !CMessages::GxtStringCompare(v16, gGxtString2, 0x190u) )
                {
                  v17 = CText::Get(&TheText, "PRTRST");
                  if ( !CMessages::GxtStringCompare(v17, gGxtString2, 0x190u) )
                  {
                    v18 = CText::Get(&TheText, "QUINST");
                    if ( !CMessages::GxtStringCompare(v18, gGxtString2, 0x190u) )
                    {
                      v19 = CText::Get(&TheText, "PQUINS");
                      if ( !CMessages::GxtStringCompare(v19, gGxtString2, 0x190u) )
                      {
                        v20 = CText::Get(&TheText, "NOSTUC");
                        if ( !CMessages::GxtStringCompare(v20, gGxtString2, 0x190u) )
                          break;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      color = v70;
      position.x = 330.0;
      position.y = (float)(i + 8.5) + 17.0;
      MenuScreen::DrawTextDirect(
        &v68,
        this,
        gGxtString2,
        TA_Right,
        1,
        (CRGBA)&color,
        1,
        position,
        (CVector2D)0x41880000438C0000LL,
        0,
        0);
      v10 = v23 + 17.0;
LABEL_71:
      if ( ++v8 == v7 )
        goto LABEL_72;
    }
    v21 = v7 == 16;
    if ( v7 == 16 )
      v21 = v8 == 1;
    if ( v21 )
    {
      v22 = this->currentCategory == 2;
      if ( (v59 | v22) << 31 )
      {
        v59 &= v22;
LABEL_51:
        v10 = v23;
        goto LABEL_71;
      }
    }
    else if ( v59 << 31 )
    {
      v59 = 0;
      goto LABEL_51;
    }
    v63 = v70;
    positiona.x = 460.0;
    positiona.y = i + 8.5;
    v59 = 0;
    MenuScreen::DrawTextDirect(
      &v68,
      this,
      gGxtString2,
      TA_Right,
      1,
      (CRGBA)&v63,
      1,
      positiona,
      (CVector2D)0x4188000043160000LL,
      0,
      0);
    goto LABEL_51;
  }
LABEL_72:
  CriminalRatingNumber = CStats::FindCriminalRatingNumber();
  sprintf(gString, (const unsigned __int8 *)&dword_2A6BC8, CriminalRatingNumber);
  AsciiToGxtChar(gString, (GxtChar *)&v68);
  CriminalRatingString = CStats::FindCriminalRatingString();
  GxtCharStrcpy(gGxtString, CriminalRatingString);
  CFont::SetScale((float)((float)RsGlobal.screenHeight * 1.35) / 480.0);
  v46 = (float)RsGlobal.screenHeight + (float)((float)RsGlobal.screenHeight * -0.0);
  if ( (float)((float)((float)(v46 - CFont::GetHeight(0)) * 480.0) / (float)RsGlobal.screenHeight) <= 449.5 )
  {
    CFont::SetScale((float)((float)RsGlobal.screenHeight * 1.35) / 480.0);
    v48 = (float)RsGlobal.screenHeight + (float)((float)RsGlobal.screenHeight * -0.0);
    v47 = (float)((float)(v48 - CFont::GetHeight(0)) * 480.0) / (float)RsGlobal.screenHeight;
  }
  else
  {
    v47 = 449.5;
  }
  CRGBA::CRGBA(&v62, 0xF0u, 0xF0u, 0xF0u, 0xFFu);
  v49 = (*((int (__fastcall **)(StatsScreen *))this->_vptr$MenuScreen + 12))(this);
  MenuScreen::DrawTextDirect(
    &v66,
    this,
    gGxtString,
    TA_Left,
    3,
    (CRGBA)&v62,
    1,
    (CVector2D)__PAIR64__(LODWORD(v47), v49),
    (CVector2D)0x4190000043480000LL,
    0,
    0);
  CRGBA::CRGBA(&v61, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
  positione.y = v47;
  positione.x = v66.y + 10.0;
  MenuScreen::DrawTextDirect(
    &pOutput,
    this,
    (GxtChar *)&v68,
    TA_Left,
    3,
    v50,
    1,
    positione,
    (CVector2D)0x4190000043480000LL,
    0,
    0);
  SelectScreen::Render(this, stackPos);
}
// 2A61A0: variables would overlap: r1.4 and r1.8
// 2A61A0: fragmented variable at r3.4 may be wrong
// 2A6B14: using guessed type int dword_2A6B14;
// 2A6BC8: using guessed type int dword_2A6BC8;

//----- (002A6BEC) --------------------------------------------------------
float __fastcall StatsScreen::GetMenuRight(StatsScreen *this)
{
  return 200.0;
}

//----- (002A6BF4) --------------------------------------------------------
void __fastcall BriefScreen::BriefScreen(BriefScreen *this)
{
  int v2; // r0

  CharSelectScreen::CharSelectScreen(this, "FEH_BRI", 1);
  this->numBriefs = 20;
  this->_vptr$MenuScreen = (int (**)(void))&off_662A5C;
  if ( !CMessages::PreviousBriefs[0].pMessage )
  {
    v2 = 0;
    goto LABEL_41;
  }
  if ( !CMessages::PreviousBriefs[1].pMessage )
  {
    v2 = 1;
    goto LABEL_41;
  }
  if ( !CMessages::PreviousBriefs[2].pMessage )
  {
    v2 = 2;
    goto LABEL_41;
  }
  if ( !CMessages::PreviousBriefs[3].pMessage )
  {
    v2 = 3;
    goto LABEL_41;
  }
  if ( !CMessages::PreviousBriefs[4].pMessage )
  {
    v2 = 4;
    goto LABEL_41;
  }
  if ( !CMessages::PreviousBriefs[5].pMessage )
  {
    v2 = 5;
    goto LABEL_41;
  }
  if ( !CMessages::PreviousBriefs[6].pMessage )
  {
    v2 = 6;
    goto LABEL_41;
  }
  if ( !CMessages::PreviousBriefs[7].pMessage )
  {
    v2 = 7;
    goto LABEL_41;
  }
  if ( !CMessages::PreviousBriefs[8].pMessage )
  {
    v2 = 8;
    goto LABEL_41;
  }
  if ( !CMessages::PreviousBriefs[9].pMessage )
  {
    v2 = 9;
    goto LABEL_41;
  }
  if ( !CMessages::PreviousBriefs[10].pMessage )
  {
    v2 = 10;
    goto LABEL_41;
  }
  if ( !CMessages::PreviousBriefs[11].pMessage )
  {
    v2 = 11;
    goto LABEL_41;
  }
  if ( !CMessages::PreviousBriefs[12].pMessage )
  {
    v2 = 12;
    goto LABEL_41;
  }
  if ( !CMessages::PreviousBriefs[13].pMessage )
  {
    v2 = 13;
    goto LABEL_41;
  }
  if ( !CMessages::PreviousBriefs[14].pMessage )
  {
    v2 = 14;
    goto LABEL_41;
  }
  if ( !CMessages::PreviousBriefs[15].pMessage )
  {
    v2 = 15;
    goto LABEL_41;
  }
  if ( !CMessages::PreviousBriefs[16].pMessage )
  {
    v2 = 16;
    goto LABEL_41;
  }
  if ( !CMessages::PreviousBriefs[17].pMessage )
  {
    v2 = 17;
    goto LABEL_41;
  }
  if ( !CMessages::PreviousBriefs[18].pMessage )
  {
    v2 = 18;
    goto LABEL_41;
  }
  if ( !CMessages::PreviousBriefs[19].pMessage )
  {
    v2 = 19;
LABEL_41:
    this->numBriefs = v2;
  }
  this->fBriefDisplay = 200.0 - BriefScreen::ComputeTotalHeight(this);
}
// 662A5C: using guessed type void *;

//----- (002A6DE0) --------------------------------------------------------
float __fastcall BriefScreen::ComputeTotalHeight(BriefScreen *this)
{
  int numBriefs; // r5
  float v3; // s16
  int v4; // r6
  float v5; // r0
  int v6; // r4
  GxtChar **p_pShortMessage; // r1
  GxtChar *v8; // r0
  GxtChar **v9; // r6
  CVector2D v11; // [sp+28h] [bp-50h] BYREF
  CRGBA v12; // [sp+30h] [bp-48h] BYREF
  int pnLines[17]; // [sp+34h] [bp-44h] BYREF

  numBriefs = this->numBriefs;
  v3 = 0.0;
LABEL_2:
  p_pShortMessage = &CMessages::PreviousBriefs[numBriefs].pShortMessage;
  while ( numBriefs > 0 )
  {
    v8 = *(p_pShortMessage - 17);
    v9 = p_pShortMessage - 10;
    --numBriefs;
    p_pShortMessage -= 10;
    if ( v8 )
    {
      CMessages::InsertNumberInString(
        v8,
        (Int32)*(v9 - 6),
        (Int32)*(v9 - 5),
        (Int32)*(v9 - 4),
        (Int32)*(v9 - 3),
        (Int32)*(v9 - 2),
        (Int32)*(v9 - 1),
        gGxtString);
      CMessages::InsertStringInString(gGxtString, *v9);
      pnLines[0] = 0;
      CRGBA::CRGBA(&v12, 0xFFu, 0xFFu, 0xFFu, 0);
      v4 = (*((int (__fastcall **)(BriefScreen *))this->_vptr$MenuScreen + 12))(this);
      v5 = (*((float (__fastcall **)(BriefScreen *))this->_vptr$MenuScreen + 12))(this);
      MenuScreen::DrawTextDirect(
        &v11,
        this,
        gGxtString,
        TA_Left,
        1,
        (CRGBA)&v12,
        1,
        (CVector2D)__PAIR64__(LODWORD(v3), v4),
        (CVector2D)(COERCE_UNSIGNED_INT(630.0 - v5) | 0x41A0000000000000LL),
        1,
        pnLines);
      v6 = pnLines[0];
      v3 = v3
         + (float)((float)(CFont::GetHeight(0) * (float)((float)v6 + 1.5))
                 / (float)((float)RsGlobal.screenHeight / 448.0));
      goto LABEL_2;
    }
  }
  return v3;
}
// 2A6DE0: using guessed type int var_44[17];

//----- (002A6F14) --------------------------------------------------------
void __fastcall BriefScreen::~BriefScreen(BriefScreen *this)
{
  void *v1; // r0

  SelectScreen::~SelectScreen(this);
  sub_191374(v1);
}
// 2A6F20: variable 'v1' is possibly undefined

//----- (002A6F24) --------------------------------------------------------
void __fastcall BriefScreen::Update(BriefScreen *this, float deltaTime)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d8
  float v8; // s0
  float v9; // s0
  CVector2D *v10; // r0

  if ( (!CHID::Implements(HID_MAPPING_MENU_DOWN) && !CHID::Implements(HID_MAPPING_PED_MOVE_Y)
     || !CHID::IsPressed(HID_MAPPING_MENU_DOWN, 0) && !CHID::IsPressedPositive(HID_MAPPING_PED_MOVE_Y))
    && !CHID::IsPressedPositive(HID_MAPPING_LOOK_Y) )
  {
    if ( (CHID::Implements(HID_MAPPING_MENU_UP) || CHID::Implements(HID_MAPPING_PED_MOVE_Y))
      && (CHID::IsPressed(HID_MAPPING_MENU_UP, 0) || CHID::IsPressedNegative(HID_MAPPING_PED_MOVE_Y))
      || CHID::IsPressedNegative(HID_MAPPING_LOOK_Y) )
    {
      v8 = 1.5;
    }
    else
    {
      if ( gMobileMenu.pointerMode
        && gMobileMenu.pointerState[lastDevice] == OSPS_ButtonDown
        && gMobileMenu.pointerCoords[lastDevice].x > 200.0 )
      {
        v9 = gMobileMenu.pointerCoords[lastDevice].y - this->lastCoords.y;
        goto LABEL_14;
      }
      v8 = 0.15;
    }
    v9 = (float)(deltaTime * v8) * 70.0;
LABEL_14:
    v4.n64_f32[0] = v9 + this->fBriefDisplay;
    goto LABEL_15;
  }
  v4.n64_f32[0] = this->fBriefDisplay + (float)((float)(deltaTime * -1.5) * 70.0);
LABEL_15:
  LODWORD(this->fBriefDisplay) = v4.n64_u32[0];
  v3.n64_u32[0] = 1120403456;
  v2.n64_f32[0] = 150.0 - BriefScreen::ComputeTotalHeight(this);
  LODWORD(this->fBriefDisplay) = vmax_f32(vmin_f32(v4, v3), v2).n64_u32[0];
  v10 = &gMobileMenu.bgUVSize + lastDevice;
  this->lastCoords.x = v10[14].x;
  this->lastCoords.y = v10[14].y;
  sub_19F14C(this, deltaTime);
}
// 2A6FDE: variable 'v4' is possibly undefined
// 2A6FDE: variable 'v3' is possibly undefined
// 2A6FEC: variable 'v2' is possibly undefined

//----- (002A70A4) --------------------------------------------------------
void __fastcall BriefScreen::Render(BriefScreen *this, int stackPos)
{
  float32x2_t v2; // d11
  int numBriefs; // r10
  float fBriefDisplay; // s16
  CPreviousMessage *v6; // r3
  __int64 v7; // d0
  int v8; // r4
  float v9; // r0
  int v10; // r4
  float Height; // r0
  int p_pShortMessage; // r2
  GxtChar *v13; // r0
  GxtChar **v14; // r4
  CPreviousMessage *v15; // [sp+2Ch] [bp-7Ch]
  int v16; // [sp+34h] [bp-74h]
  CVector2D v17; // [sp+38h] [bp-70h] BYREF
  CRGBA v18; // [sp+40h] [bp-68h] BYREF
  int pnLines[25]; // [sp+44h] [bp-64h] BYREF

  numBriefs = this->numBriefs;
  fBriefDisplay = this->fBriefDisplay;
  v6 = CMessages::PreviousBriefs;
  v2.n64_u32[0] = 0;
LABEL_7:
  p_pShortMessage = (int)&v6[numBriefs].pShortMessage;
  while ( numBriefs >= 1 )
  {
    v13 = *(GxtChar **)(p_pShortMessage - 68);
    v14 = (GxtChar **)(p_pShortMessage - 40);
    --numBriefs;
    p_pShortMessage -= 40;
    if ( v13 )
    {
      v15 = v6;
      v16 = stackPos;
      CMessages::InsertNumberInString(
        v13,
        (Int32)*(v14 - 6),
        (Int32)*(v14 - 5),
        (Int32)*(v14 - 4),
        (Int32)*(v14 - 3),
        (Int32)*(v14 - 2),
        (Int32)*(v14 - 1),
        gGxtString);
      CMessages::InsertStringInString(gGxtString, *v14);
      v7 = COERCE_UNSIGNED_INT(1.0) | 0x441D800000000000LL;
      if ( fBriefDisplay < 100.0 )
        *(float *)&v7 = (float)(fBriefDisplay / 50.0) + -1.0;
      if ( fBriefDisplay > 410.0 )
        *(float *)&v7 = (float)((float)(410.0 - fBriefDisplay) / 20.0) + 1.0;
      pnLines[0] = 0;
      CRGBA::CRGBA(&v18, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)(vmax_f32((float32x2_t)v7, v2).n64_f32[0] * 255.0));
      v8 = (*((int (__fastcall **)(BriefScreen *))this->_vptr$MenuScreen + 12))(this);
      v9 = (*((float (__fastcall **)(BriefScreen *))this->_vptr$MenuScreen + 12))(this);
      MenuScreen::DrawTextDirect(
        &v17,
        this,
        gGxtString,
        TA_Left,
        1,
        (CRGBA)&v18,
        1,
        (CVector2D)__PAIR64__(LODWORD(fBriefDisplay), v8),
        (CVector2D)(COERCE_UNSIGNED_INT(630.0 - v9) | 0x41A0000000000000LL),
        1,
        pnLines);
      v10 = pnLines[0];
      Height = CFont::GetHeight(0);
      stackPos = v16;
      v6 = v15;
      fBriefDisplay = fBriefDisplay
                    + (float)((float)(Height * (float)((float)v10 + 1.5)) / (float)((float)RsGlobal.screenHeight / 448.0));
      goto LABEL_7;
    }
  }
  CharSelectScreen::Render(this, stackPos);
}
// 2A715E: variable 'v2' is possibly undefined
// 2A70A4: using guessed type int var_64[25];

//----- (002A7268) --------------------------------------------------------
void __fastcall BriefScreen::DrawBack(BriefScreen *this, bool showAcceptButton)
{
  sub_19C6B4(this, 0);
}

//----- (002A7270) --------------------------------------------------------
void StartGameScreen::OnNewGameCheck()
{
  unsigned int numEntries; // r1
  MenuScreen *v1; // r0

  Menu_NewGame();
  if ( Menu_IsPlayingGame(1) )
    Menu_DrawLoadScreen(1, 0);
  MobileMenu::Unload(&gMobileMenu);
  numEntries = gMobileMenu.screenStack.numEntries;
  gMobileMenu.pendingScreen = 0;
  gMobileMenu.isMapMode = 0;
  while ( numEntries )
  {
    v1 = gMobileMenu.screenStack.dataPtr[--numEntries];
    gMobileMenu.screenStack.numEntries = numEntries;
    if ( v1 )
    {
      (*((void (__fastcall **)(MenuScreen *))v1->_vptr$MenuScreen + 1))(v1);
      numEntries = gMobileMenu.screenStack.numEntries;
    }
  }
  Menu_SwitchOffToGame();
  if ( Menu_IsPlayingGame(1) )
    skipFrame = 2;
  gMobileMenu.CurrentGameNotResumable = 0;
}
// 6C: using guessed type int dword_6C;

//----- (002A7304) --------------------------------------------------------
void StartGameScreen::OnLoadGame()
{
  LoadScreen *v0; // r4
  bool IsPlayingGame; // r0

  UpdateCloudSaves();
  Menu_PopulateSaves(0);
  AddMenuStat(eNewGame, 1);
  v0 = (LoadScreen *)operator new(0x44u);
  IsPlayingGame = Menu_IsPlayingGame(1);
  LoadScreen::LoadScreen(v0, IsPlayingGame);
  if ( gMobileMenu.screenStack.numEntries )
    (*((void (__fastcall **)(LoadScreen *, MenuScreen *))v0->_vptr$MenuScreen + 5))(
      v0,
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
  if ( gMobileMenu.pendingScreen )
    MobileMenu::ProcessPending(&gMobileMenu);
  gMobileMenu.pendingScreen = v0;
}

//----- (002A7384) --------------------------------------------------------
void StartGameScreen::OnDeleteGame()
{
  CharSelectScreen *v0; // r10
  int v1; // r0
  int v2; // r5
  int v3; // r0

  AddMenuStat(eDeleteGame, 1);
  v0 = (CharSelectScreen *)operator new(0x44u);
  CharSelectScreen::CharSelectScreen(v0, "FES_DEL", 1);
  v0->_vptr$MenuScreen = (int (**)(void))&off_662B4C;
  Menu_PopulateSaves(0);
  v1 = GameToSKip;
  v0->_vptr$MenuScreen = (int (**)(void))&off_662BD4;
  if ( v1 <= 7 )
  {
    v2 = 0;
    do
    {
      if ( (v2 | 1) != 7 || !UseCloudSaves )
      {
        v3 = operator new(0x10u);
        *(_BYTE *)(v3 + 12) = 0;
        *(_DWORD *)v3 = &off_662C30;
        *(_DWORD *)(v3 + 4) = &byte_61CADE;
        *(_DWORD *)(v3 + 8) = v2;
        SelectScreen::AddItem(v0, (SelectScreen::MenuSelection *)v3);
        v1 = GameToSKip;
      }
      ++v2;
    }
    while ( v2 < 8 - v1 );
  }
  if ( gMobileMenu.screenStack.numEntries )
    (*((void (__fastcall **)(CharSelectScreen *, MenuScreen *))v0->_vptr$MenuScreen + 5))(
      v0,
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
  if ( gMobileMenu.pendingScreen )
    MobileMenu::ProcessPending(&gMobileMenu);
  gMobileMenu.pendingScreen = v0;
}
// 61CADE: using guessed type char byte_61CADE;
// 662B4C: using guessed type void *off_662B4C;
// 662BD4: using guessed type void *;
// 662C30: using guessed type void *;

//----- (002A74A4) --------------------------------------------------------
void __fastcall StartGameScreen::~StartGameScreen(StartGameScreen *this)
{
  void *v1; // r0

  FlowScreen::~FlowScreen(this);
  sub_191374(v1);
}
// 2A74B0: variable 'v1' is possibly undefined

//----- (002A74B4) --------------------------------------------------------
void __fastcall LoadScreen::LoadScreen(LoadScreen *this, bool shouldConfirm)
{
  int v4; // r0
  int v5; // r4
  int v6; // r0

  CharSelectScreen::CharSelectScreen(this, "FET_LG", 1);
  this->_vptr$MenuScreen = (int (**)(void))&off_662B4C;
  Menu_PopulateSaves(0);
  this->_vptr$MenuScreen = (int (**)(void))&off_662AF0;
  v4 = operator new(0x10u);
  *(_BYTE *)(v4 + 12) = 1;
  *(_DWORD *)v4 = &off_662BA8;
  *(_DWORD *)(v4 + 4) = &byte_61CADE;
  *(_DWORD *)(v4 + 8) = 8;
  *(_BYTE *)(v4 + 13) = shouldConfirm;
  SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v4);
  if ( GameToSKip <= 7 )
  {
    v5 = 0;
    do
    {
      v6 = operator new(0x10u);
      *(_BYTE *)(v6 + 12) = 0;
      *(_BYTE *)(v6 + 13) = shouldConfirm;
      *(_DWORD *)v6 = &off_662BA8;
      *(_DWORD *)(v6 + 4) = &byte_61CADE;
      *(_DWORD *)(v6 + 8) = v5;
      SelectScreen::AddItem(this, (SelectScreen::MenuSelection *)v6);
      ++v5;
    }
    while ( v5 < 8 - GameToSKip );
  }
}
// 61CADE: using guessed type char byte_61CADE;
// 662AF0: using guessed type void *;
// 662B4C: using guessed type void *;
// 662BA8: using guessed type void *;

//----- (002A7590) --------------------------------------------------------
void __fastcall LoadScreen::~LoadScreen(LoadScreen *this)
{
  void *v1; // r0

  SelectScreen::~SelectScreen(this);
  sub_191374(v1);
}
// 2A759C: variable 'v1' is possibly undefined

//----- (002A75A4) --------------------------------------------------------
bool __fastcall SaveSelectScreen::IsSaveLoadDeleteScreen(SaveSelectScreen *this)
{
  return 1;
}

//----- (002A75A8) --------------------------------------------------------
void __fastcall SaveSelectScreen::~SaveSelectScreen(SaveSelectScreen *this)
{
  void *v1; // r0

  SelectScreen::~SelectScreen(this);
  sub_191374(v1);
}
// 2A75B4: variable 'v1' is possibly undefined

//----- (002A75C0) --------------------------------------------------------
void __fastcall SaveSelectScreen::SaveSelection::GetColor(CRGBA *a1, SaveSelectScreen::SaveSelection *this)
{
  if ( this->autosave || (this->slotNum | 1) == 7 && UseCloudSaves )
    CRGBA::CRGBA(a1, 0xFFu, 0xFFu, 0x80u, 0xFFu);
  else
    CRGBA::CRGBA(a1, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
}

//----- (002A7600) --------------------------------------------------------
GxtChar *__fastcall SaveSelectScreen::SaveSelection::GetTitle(SaveSelectScreen::SaveSelection *this)
{
  GxtChar *v2; // r0
  int slotNum; // r0
  int v4; // r0
  GxtChar *v5; // r1
  GxtChar *v6; // r4
  GxtChar Tail[2]; // [sp+4h] [bp-Ch] BYREF

  if ( this->autosave )
  {
    v2 = CText::Get(&TheText, "MOB_ASV");
    *(_DWORD *)Tail = 32;
    GxtCharStrcpy(SaveSelectScreen::SaveSelection::GetTitle(void)::chars, v2);
    GxtCharStrcat(SaveSelectScreen::SaveSelection::GetTitle(void)::chars, Tail);
    slotNum = this->slotNum;
    if ( CGenericGameStorage::ms_Slots[slotNum] )
    {
      if ( (slotNum | 1) == 7 && UseCloudSaves )
      {
        if ( IsSCCloudAvailable() )
          sprintf(gString, "FEM_CS%d", this->slotNum + 1);
        else
          strcpy((char *)gString, "FEM_NC");
      }
      else
      {
        sprintf(gString, "FEM_SL%d", slotNum + 1);
      }
      v5 = CText::Get(&TheText, gString);
    }
    else
    {
      v5 = CGenericGameStorage::ms_SlotFileName[slotNum];
    }
    v6 = SaveSelectScreen::SaveSelection::GetTitle(void)::chars;
    GxtCharStrcat(SaveSelectScreen::SaveSelection::GetTitle(void)::chars, v5);
    return v6;
  }
  v4 = this->slotNum;
  if ( !CGenericGameStorage::ms_Slots[v4] )
    return CGenericGameStorage::ms_SlotFileName[v4];
  if ( (v4 | 1) == 7 && UseCloudSaves )
  {
    if ( IsSCCloudAvailable() )
      sprintf(gString, "FEM_CS%d", this->slotNum + 1);
    else
      strcpy((char *)gString, "FEM_NC");
  }
  else
  {
    sprintf(gString, "FEM_SL%d", v4 + 1);
  }
  return sub_18A500(&TheText, gString);
}

//----- (002A77B8) --------------------------------------------------------
void __fastcall LoadScreen::LoadScreenSelection::HandleInput(
        LoadScreen::LoadScreenSelection *this,
        SelectScreen *fromScreen,
        float deltaTime)
{
  int v4; // r4
  SelectScreen::MenuSelection *v5; // r0
  SelectScreen::MenuSelection *v6; // r0

  if ( (CHID::Implements(HID_MAPPING_MENU_ACCEPT) && CHID::IsReleased(HID_MAPPING_MENU_ACCEPT)
     || gMobileMenu.pointerState[lastDevice] == OSPS_ButtonReleased)
    && !CGenericGameStorage::ms_Slots[this->slotNum] )
  {
    if ( !NeedsAmazonDownload() )
      CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 1, 0.0, 1.0);
    if ( this->shouldConfirm )
    {
      v4 = operator new(0x54u);
      CharSelectScreen::CharSelectScreen((CharSelectScreen *)v4, "FET_LG", 1);
      *(_DWORD *)(v4 + 68) = "FESZ_QL";
      *(_DWORD *)(v4 + 76) = this;
      *(_DWORD *)(v4 + 80) = 0;
      *(_DWORD *)(v4 + 72) = LoadScreen::LoadScreenSelection::ConfirmLoad;
      *(_DWORD *)v4 = &off_662D9C;
      CachePlayerControls();
      v5 = (SelectScreen::MenuSelection *)operator new(0x10u);
      v5->_vptr$MenuSelection = (int (**)(void))&off_66280C;
      v5->tag = "FEM_NO";
      v5[1]._vptr$MenuSelection = (int (**)(void))YesNoScreen::NoFunc;
      v5[1].tag = 0;
      SelectScreen::AddItem((SelectScreen *)v4, v5);
      v6 = (SelectScreen::MenuSelection *)operator new(0x10u);
      v6->_vptr$MenuSelection = (int (**)(void))&off_66280C;
      v6->tag = "FEM_YES";
      v6[1]._vptr$MenuSelection = (int (**)(void))YesNoScreen::YesFunc;
      v6[1].tag = 0;
      SelectScreen::AddItem((SelectScreen *)v4, v6);
      if ( gMobileMenu.screenStack.numEntries )
        (*(void (__fastcall **)(int, MenuScreen *))(*(_DWORD *)v4 + 20))(
          v4,
          gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
      if ( gMobileMenu.pendingScreen )
        MobileMenu::ProcessPending(&gMobileMenu);
      gMobileMenu.pendingScreen = (MenuScreen *)v4;
    }
    else
    {
      sub_18DE04(this);
    }
  }
}
// 66280C: using guessed type void *off_66280C;
// 662D9C: using guessed type void *off_662D9C;

//----- (002A7940) --------------------------------------------------------
void __fastcall LoadScreen::LoadScreenSelection::Load(LoadScreen::LoadScreenSelection *this)
{
  unsigned int numEntries; // r1
  MenuScreen *v2; // r0
  int v3; // r4
  SelectScreen::MenuSelection *v4; // r0

  if ( Menu_LoadSlot(this->slotNum) )
  {
    if ( Menu_IsPlayingGame(1) )
      Menu_DrawLoadScreen(0, 30);
    MobileMenu::Unload(&gMobileMenu);
    numEntries = gMobileMenu.screenStack.numEntries;
    gMobileMenu.pendingScreen = 0;
    gMobileMenu.isMapMode = 0;
    while ( numEntries )
    {
      v2 = gMobileMenu.screenStack.dataPtr[--numEntries];
      gMobileMenu.screenStack.numEntries = numEntries;
      if ( v2 )
      {
        (*((void (__fastcall **)(MenuScreen *))v2->_vptr$MenuScreen + 1))(v2);
        numEntries = gMobileMenu.screenStack.numEntries;
      }
    }
    Menu_SwitchOffToGame();
    if ( Menu_IsPlayingGame(1) )
      skipFrame = 2;
    gMobileMenu.CurrentGameNotResumable = 0;
  }
  else
  {
    v3 = operator new(0x50u);
    CharSelectScreen::CharSelectScreen((CharSelectScreen *)v3, "FET_LG", 1);
    *(_DWORD *)(v3 + 68) = "FES_LCE";
    *(_DWORD *)(v3 + 72) = LoadScreen::LoadScreenSelection::LoadFailed;
    *(_DWORD *)(v3 + 76) = 0;
    *(_DWORD *)v3 = &off_662DF8;
    v4 = (SelectScreen::MenuSelection *)operator new(0x10u);
    v4->_vptr$MenuSelection = (int (**)(void))&off_66280C;
    v4->tag = "FEM_OK";
    v4[1]._vptr$MenuSelection = (int (**)(void))OkScreen::OkFunc;
    v4[1].tag = 0;
    SelectScreen::AddItem((SelectScreen *)v3, v4);
    if ( gMobileMenu.screenStack.numEntries )
      (*(void (__fastcall **)(int, MenuScreen *))(*(_DWORD *)v3 + 20))(
        v3,
        gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
    if ( gMobileMenu.pendingScreen )
      MobileMenu::ProcessPending(&gMobileMenu);
    gMobileMenu.pendingScreen = (MenuScreen *)v3;
  }
}
// 6C: using guessed type int dword_6C;
// 66280C: using guessed type void *off_66280C;
// 662DF8: using guessed type void *off_662DF8;

//----- (002A7AA2) --------------------------------------------------------
void __fastcall DeleteScreen::~DeleteScreen(DeleteScreen *this)
{
  void *v1; // r0

  SelectScreen::~SelectScreen(this);
  sub_191374(v1);
}
// 2A7AAE: variable 'v1' is possibly undefined

//----- (002A7AB8) --------------------------------------------------------
void __fastcall DeleteScreen::DeleteScreenSelection::HandleInput(
        DeleteScreen::DeleteScreenSelection *this,
        SelectScreen *fromScreen,
        float deltaTime)
{
  int v4; // r4
  SelectScreen::MenuSelection *v5; // r0
  SelectScreen::MenuSelection *v6; // r0

  if ( (CHID::Implements(HID_MAPPING_MENU_ACCEPT) && CHID::IsReleased(HID_MAPPING_MENU_ACCEPT)
     || gMobileMenu.pointerState[lastDevice] == OSPS_ButtonReleased)
    && !CGenericGameStorage::ms_Slots[this->slotNum] )
  {
    if ( !NeedsAmazonDownload() )
      CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 1, 0.0, 1.0);
    v4 = operator new(0x54u);
    CharSelectScreen::CharSelectScreen((CharSelectScreen *)v4, "FES_DEL", 1);
    *(_DWORD *)(v4 + 68) = "FESZ_QD";
    *(_DWORD *)(v4 + 76) = this;
    *(_DWORD *)(v4 + 80) = 0;
    *(_DWORD *)(v4 + 72) = DeleteScreen::DeleteScreenSelection::ConfirmDelete;
    *(_DWORD *)v4 = &off_662D9C;
    CachePlayerControls();
    v5 = (SelectScreen::MenuSelection *)operator new(0x10u);
    v5->_vptr$MenuSelection = (int (**)(void))&off_66280C;
    v5->tag = "FEM_NO";
    v5[1]._vptr$MenuSelection = (int (**)(void))YesNoScreen::NoFunc;
    v5[1].tag = 0;
    SelectScreen::AddItem((SelectScreen *)v4, v5);
    v6 = (SelectScreen::MenuSelection *)operator new(0x10u);
    v6->_vptr$MenuSelection = (int (**)(void))&off_66280C;
    v6->tag = "FEM_YES";
    v6[1]._vptr$MenuSelection = (int (**)(void))YesNoScreen::YesFunc;
    v6[1].tag = 0;
    SelectScreen::AddItem((SelectScreen *)v4, v6);
    if ( gMobileMenu.screenStack.numEntries )
      (*(void (__fastcall **)(int, MenuScreen *))(*(_DWORD *)v4 + 20))(
        v4,
        gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
    if ( gMobileMenu.pendingScreen )
      MobileMenu::ProcessPending(&gMobileMenu);
    gMobileMenu.pendingScreen = (MenuScreen *)v4;
  }
}
// 66280C: using guessed type void *off_66280C;
// 662D9C: using guessed type void *off_662D9C;

//----- (002A7C28) --------------------------------------------------------
void __fastcall DeleteScreen::DeleteScreenSelection::ConfirmDelete(void *data)
{
  if ( Menu_DeleteSlot(*((_DWORD *)data + 2)) )
    sub_18E53C(1);
}

//----- (002A7C44) --------------------------------------------------------
void __fastcall FlowScreen::DrawFeatheredQuad(FlowScreen *this, CVector2D *coords, CRGBA *colors)
{
  float Width; // s16
  void *Height; // r0
  float v8; // s16
  float v9; // s18
  float v10; // s2
  float v11; // s2
  float v12; // s2
  float v13; // s2
  CVector2D v14; // d17
  CVector2D v15; // d17
  float32x4_t v16; // q0
  float32x4_t v17; // q8
  float32x4_t v18; // q9
  float32x4_t v19; // q8
  float32x4_t v20; // q9
  CVector2D v21[8]; // [sp+0h] [bp-40h] BYREF

  Width = (float)(unsigned int)OS_ScreenGetWidth();
  Height = OS_ScreenGetHeight();
  colors->_anon_0._anon_0.alpha = 2 * (unsigned int)colors->_anon_0._anon_0.alpha / 3;
  v8 = (float)(640.0 / Width) * 0.25;
  v9 = (float)(480.0 / (float)(unsigned int)Height) * 0.25;
  v10 = coords->y - v9;
  coords->x = coords->x - v8;
  coords->y = v10;
  colors[1]._anon_0._anon_0.alpha = 2 * (unsigned int)colors[1]._anon_0._anon_0.alpha / 3;
  v11 = coords[1].y - v9;
  coords[1].x = coords[1].x - v8;
  coords[1].y = v11;
  colors[2]._anon_0._anon_0.alpha = 2 * (unsigned int)colors[2]._anon_0._anon_0.alpha / 3;
  v12 = coords[2].y - v9;
  coords[2].x = coords[2].x - v8;
  coords[2].y = v12;
  colors[3]._anon_0._anon_0.alpha = 2 * (unsigned int)colors[3]._anon_0._anon_0.alpha / 3;
  v13 = coords[3].y - v9;
  coords[3].x = coords[3].x - v8;
  coords[3].y = v13;
  v14 = coords[1];
  v21[0] = *coords;
  v21[1] = v14;
  v15 = coords[3];
  v21[2] = coords[2];
  v21[3] = v15;
  MenuScreen::DrawQuad((MenuScreen *)this, v21, colors);
  v16.n128_f32[0] = v8 + v8;
  v17.n128_u64[0] = (unsigned __int64)*coords;
  *(CVector2D *)&v17.n128_i8[8] = coords[1];
  v16.n128_f32[1] = v9 + v9;
  v18.n128_u64[0] = (unsigned __int64)coords[2];
  *(CVector2D *)&v18.n128_i8[8] = coords[3];
  v16.n128_f32[2] = v8 + v8;
  v16.n128_f32[3] = v9 + v9;
  v19 = vaddq_f32(v16, v17);
  v20 = vaddq_f32(v16, v18);
  *coords = (CVector2D)v19.n128_u64[0];
  coords[1] = *(CVector2D *)&v19.n128_i8[8];
  coords[2] = (CVector2D)v20.n128_u64[0];
  coords[3] = *(CVector2D *)&v20.n128_i8[8];
  MenuScreen::DrawQuad((MenuScreen *)this, coords, colors);
}

//----- (002A7D8C) --------------------------------------------------------
void __fastcall SelectScreen::~SelectScreen(SelectScreen *this)
{
  unsigned int numEntries; // r1
  unsigned int i; // r5
  SelectScreen::MenuSelection *v4; // r0
  float *dataPtr; // r0
  SelectScreen::MenuSelection **v6; // r0
  RwTexture_0 *arrowTex; // r0

  numEntries = this->items.numEntries;
  this->_vptr$MenuScreen = (int (**)(void))&off_662728;
  if ( numEntries )
  {
    for ( i = 0; i < numEntries; ++i )
    {
      v4 = this->items.dataPtr[i];
      if ( v4 )
      {
        (*((void (__fastcall **)(SelectScreen::MenuSelection *))v4->_vptr$MenuSelection + 1))(v4);
        numEntries = this->items.numEntries;
      }
    }
  }
  dataPtr = this->selected.dataPtr;
  this->selected.numEntries = 0;
  if ( dataPtr )
  {
    free(dataPtr);
    this->selected.dataPtr = 0;
  }
  v6 = this->items.dataPtr;
  this->items.numEntries = 0;
  this->selected.numAlloced = 0;
  if ( v6 )
  {
    free(v6);
    this->items.dataPtr = 0;
  }
  this->items.numAlloced = 0;
  arrowTex = this->arrowTex;
  this->_vptr$MenuScreen = (int (**)(void))&off_662590;
  if ( arrowTex )
  {
    RwTextureDestroy(arrowTex);
    this->arrowTex = 0;
  }
}
// 662590: using guessed type void *off_662590;
// 662728: using guessed type void *;

//----- (002A7E00) --------------------------------------------------------
void __fastcall DownloadScreen::~DownloadScreen(DownloadScreen *this)
{
  void *v1; // r0

  SelectScreen::~SelectScreen(this);
  sub_191374(v1);
}
// 2A7E0C: variable 'v1' is possibly undefined

//----- (002A7E10) --------------------------------------------------------
void __fastcall DownloadScreen::Render(DownloadScreen *this, int stackPos)
{
  int v3; // r8
  float v4; // r6
  float v5; // r4
  GxtChar *v6; // r0
  float v7; // r4
  CVector2D v8; // r1
  int v9; // r6
  int v10; // r4
  SelectScreen::MenuSelection *v11; // r0
  SelectScreen::MenuSelection *v12; // r0
  SelectScreen::MenuSelection *v13; // r0
  SelectScreen::MenuSelection *v14; // r0
  CVector2D v15; // [sp+14h] [bp-3Ch]
  CVector2D v16; // [sp+24h] [bp-2Ch] BYREF
  CRGBA v17; // [sp+2Ch] [bp-24h] BYREF
  CRGBA v18; // [sp+30h] [bp-20h] BYREF
  CVector2D v19; // 0:r3.4,4:^0.4

  IsDownloadBack = 1;
  CharSelectScreen::Render(this, stackPos);
  IsDownloadBack = 0;
  CRGBA::CRGBA(&v17, 0xF0u, 0xF0u, 0xF0u, 0xFFu);
  v3 = (*((int (__fastcall **)(DownloadScreen *))this->_vptr$MenuScreen + 12))(this);
  v4 = COERCE_FLOAT((*((int (__fastcall **)(DownloadScreen *))this->_vptr$MenuScreen + 13))(this));
  v5 = COERCE_FLOAT((*((int (__fastcall **)(DownloadScreen *))this->_vptr$MenuScreen + 12))(this));
  v6 = CText::Get(&TheText, "FES_WP8");
  v18 = v17;
  v15.y = 23.0;
  v15.x = v4 - v5;
  MenuScreen::DrawTextDirect(
    &v16,
    this,
    v6,
    TA_Left,
    1,
    (CRGBA)&v18,
    1,
    (CVector2D)((unsigned int)v3 | 0x42A0000000000000LL),
    v15,
    1,
    0);
  v7 = COERCE_FLOAT((*((int (__fastcall **)(DownloadScreen *))this->_vptr$MenuScreen + 12))(this));
  LODWORD(v19.x) = (*((int (__fastcall **)(DownloadScreen *))this->_vptr$MenuScreen + 13))(this);
  v8.y = 300.0;
  v19.y = 330.0;
  v8.x = v7;
  MenuScreen::DrawSlider(this, v8, v19, (float)this->curPercent * 0.01, 0, 0xFFu, 0);
  v9 = CurrentDownloadingError;
  if ( CurrentDownloadingError && !this->askedForRetry )
  {
    this->askedForRetry = 1;
    v10 = operator new(0x54u);
    CharSelectScreen::CharSelectScreen((CharSelectScreen *)v10, "FES_DLE", 0);
    if ( v9 == 4 )
    {
      *(_DWORD *)(v10 + 68) = "FES_R81";
      *(_DWORD *)(v10 + 72) = DownloadScreen::RetryDownload;
      *(_DWORD *)(v10 + 76) = this;
      *(_DWORD *)(v10 + 80) = DownloadScreen::CancelDownload;
      *(_DWORD *)v10 = &off_662D9C;
      CachePlayerControls();
      v11 = (SelectScreen::MenuSelection *)operator new(0x10u);
      v11->_vptr$MenuSelection = (int (**)(void))&off_66280C;
      v11->tag = "FEM_NO";
      v11[1]._vptr$MenuSelection = (int (**)(void))YesNoScreen::NoFunc;
      v11[1].tag = 0;
      SelectScreen::AddItem((SelectScreen *)v10, v11);
      v12 = (SelectScreen::MenuSelection *)operator new(0x10u);
      v12->_vptr$MenuSelection = (int (**)(void))&off_66280C;
      v12->tag = "FEM_YES";
      v12[1]._vptr$MenuSelection = (int (**)(void))YesNoScreen::YesFunc;
      v12[1].tag = 0;
      SelectScreen::AddItem((SelectScreen *)v10, v12);
      if ( gMobileMenu.screenStack.numEntries )
        (*(void (__fastcall **)(int, MenuScreen *))(*(_DWORD *)v10 + 20))(
          v10,
          gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
      if ( gMobileMenu.pendingScreen )
        MobileMenu::ProcessPending(&gMobileMenu);
    }
    else
    {
      *(_DWORD *)(v10 + 68) = "FES_RTY";
      *(_DWORD *)(v10 + 72) = DownloadScreen::RetryDownload;
      *(_DWORD *)(v10 + 76) = this;
      *(_DWORD *)(v10 + 80) = DownloadScreen::CancelDownload;
      *(_DWORD *)v10 = &off_662D9C;
      CachePlayerControls();
      v13 = (SelectScreen::MenuSelection *)operator new(0x10u);
      v13->_vptr$MenuSelection = (int (**)(void))&off_66280C;
      v13->tag = "FEM_NO";
      v13[1]._vptr$MenuSelection = (int (**)(void))YesNoScreen::NoFunc;
      v13[1].tag = 0;
      SelectScreen::AddItem((SelectScreen *)v10, v13);
      v14 = (SelectScreen::MenuSelection *)operator new(0x10u);
      v14->_vptr$MenuSelection = (int (**)(void))&off_66280C;
      v14->tag = "FEM_YES";
      v14[1]._vptr$MenuSelection = (int (**)(void))YesNoScreen::YesFunc;
      v14[1].tag = 0;
      SelectScreen::AddItem((SelectScreen *)v10, v14);
      if ( gMobileMenu.screenStack.numEntries )
        (*(void (__fastcall **)(int, MenuScreen *))(*(_DWORD *)v10 + 20))(
          v10,
          gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
      if ( gMobileMenu.pendingScreen )
        MobileMenu::ProcessPending(&gMobileMenu);
    }
    gMobileMenu.pendingScreen = (MenuScreen *)v10;
  }
}
// 66280C: using guessed type void *off_66280C;
// 662D9C: using guessed type void *off_662D9C;

//----- (002A8124) --------------------------------------------------------
void __fastcall DownloadScreen::OnBack(DownloadScreen *this)
{
  RsGlobal.quit = 1;
}

//----- (002A8134) --------------------------------------------------------
void __fastcall DownloadScreen::RetryDownload(void *data)
{
  *((_DWORD *)data + 18) = 0;
  CurrentDownloadingError = 0;
  startDownloadTime = OS_TimeMS();
}

//----- (002A815C) --------------------------------------------------------
void __fastcall DownloadScreen::CancelDownload(void *data)
{
  RsGlobal.quit = 1;
}

//----- (002A816C) --------------------------------------------------------
void __fastcall SaveScreen::~SaveScreen(SaveScreen *this)
{
  void *v1; // r0

  SelectScreen::~SelectScreen(this);
  sub_191374(v1);
}
// 2A8178: variable 'v1' is possibly undefined

//----- (002A8180) --------------------------------------------------------
void __fastcall SaveScreen::SaveScreenSelection::HandleInput(
        SaveScreen::SaveScreenSelection *this,
        SelectScreen *fromScreen,
        float deltaTime)
{
  int v4; // r5
  SelectScreen::MenuSelection *v5; // r0
  SelectScreen::MenuSelection *v6; // r0

  if ( (CHID::Implements(HID_MAPPING_MENU_ACCEPT) && CHID::IsReleased(HID_MAPPING_MENU_ACCEPT)
     || gMobileMenu.pointerState[lastDevice] == OSPS_ButtonReleased)
    && ((this->slotNum | 1) != 7 || !UseCloudSaves || IsSCCloudAvailable()) )
  {
    if ( !NeedsAmazonDownload() )
      CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 1, 0.0, 1.0);
    if ( CGenericGameStorage::ms_Slots[this->slotNum] )
    {
      sub_199E74(this);
    }
    else
    {
      v4 = operator new(0x54u);
      CharSelectScreen::CharSelectScreen((CharSelectScreen *)v4, "FET_SG", 1);
      *(_DWORD *)(v4 + 68) = "FESZ_QO";
      *(_DWORD *)(v4 + 76) = this;
      *(_DWORD *)(v4 + 80) = 0;
      *(_DWORD *)(v4 + 72) = SaveScreen::SaveScreenSelection::ConfirmSave;
      *(_DWORD *)v4 = &off_662D9C;
      CachePlayerControls();
      v5 = (SelectScreen::MenuSelection *)operator new(0x10u);
      v5->_vptr$MenuSelection = (int (**)(void))&off_66280C;
      v5->tag = "FEM_NO";
      v5[1]._vptr$MenuSelection = (int (**)(void))YesNoScreen::NoFunc;
      v5[1].tag = 0;
      SelectScreen::AddItem((SelectScreen *)v4, v5);
      v6 = (SelectScreen::MenuSelection *)operator new(0x10u);
      v6->_vptr$MenuSelection = (int (**)(void))&off_66280C;
      v6->tag = "FEM_YES";
      v6[1]._vptr$MenuSelection = (int (**)(void))YesNoScreen::YesFunc;
      v6[1].tag = 0;
      SelectScreen::AddItem((SelectScreen *)v4, v6);
      if ( gMobileMenu.screenStack.numEntries )
        (*(void (__fastcall **)(int, MenuScreen *))(*(_DWORD *)v4 + 20))(
          v4,
          gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
      if ( gMobileMenu.pendingScreen )
        MobileMenu::ProcessPending(&gMobileMenu);
      gMobileMenu.pendingScreen = (MenuScreen *)v4;
    }
  }
}
// 66280C: using guessed type void *off_66280C;
// 662D9C: using guessed type void *off_662D9C;

//----- (002A8320) --------------------------------------------------------
void __fastcall SaveScreen::SaveScreenSelection::Save(SaveScreen::SaveScreenSelection *this)
{
  int *p_slotNum; // r5
  int v2; // r6
  int v3; // r4
  SelectScreen::MenuSelection *v4; // r0
  SelectScreen::MenuSelection *v5; // r0

  SaveGameStateType = eNormalSave;
  p_slotNum = &this->slotNum;
  v2 = C_PcSave::SaveSlot(&PcSaveHelper, this->slotNum, 0);
  if ( (*p_slotNum | 1) == 7 && UseCloudSaves )
  {
    v3 = operator new(0x58u);
    CharSelectScreen::CharSelectScreen((CharSelectScreen *)v3, "FET_SG", 0);
    *(_DWORD *)(v3 + 68) = "FESZ_WR";
    *(_DWORD *)(v3 + 72) = SaveScreen::SaveScreenSelection::SaveDone;
    *(_DWORD *)(v3 + 76) = p_slotNum;
    *(_DWORD *)v3 = &off_662D40;
    *(double *)(v3 + 80) = OS_TimeAccurate();
    if ( gMobileMenu.screenStack.numEntries )
      (*(void (__fastcall **)(int, MenuScreen *))(*(_DWORD *)v3 + 20))(
        v3,
        gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
    if ( gMobileMenu.pendingScreen )
LABEL_15:
      MobileMenu::ProcessPending(&gMobileMenu);
  }
  else
  {
    v3 = operator new(0x50u);
    CharSelectScreen::CharSelectScreen((CharSelectScreen *)v3, "FET_SG", 1);
    if ( v2 )
    {
      *(_DWORD *)(v3 + 68) = "FES_SVF";
      *(_DWORD *)(v3 + 72) = SaveScreen::SaveScreenSelection::SaveFailed;
      *(_DWORD *)(v3 + 76) = 0;
      *(_DWORD *)v3 = &off_662DF8;
      v4 = (SelectScreen::MenuSelection *)operator new(0x10u);
      v4->_vptr$MenuSelection = (int (**)(void))&off_66280C;
      v4->tag = "FEM_OK";
      v4[1]._vptr$MenuSelection = (int (**)(void))OkScreen::OkFunc;
      v4[1].tag = 0;
      SelectScreen::AddItem((SelectScreen *)v3, v4);
      if ( gMobileMenu.screenStack.numEntries )
        (*(void (__fastcall **)(int, MenuScreen *))(*(_DWORD *)v3 + 20))(
          v3,
          gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
      if ( gMobileMenu.pendingScreen )
        goto LABEL_15;
    }
    else
    {
      *(_DWORD *)(v3 + 68) = "FES_SSC";
      *(_DWORD *)(v3 + 72) = SaveScreen::SaveScreenSelection::SaveDone;
      *(_DWORD *)(v3 + 76) = 0;
      *(_DWORD *)v3 = &off_662DF8;
      v5 = (SelectScreen::MenuSelection *)operator new(0x10u);
      v5->_vptr$MenuSelection = (int (**)(void))&off_66280C;
      v5->tag = "FEM_OK";
      v5[1]._vptr$MenuSelection = (int (**)(void))OkScreen::OkFunc;
      v5[1].tag = 0;
      SelectScreen::AddItem((SelectScreen *)v3, v5);
      if ( gMobileMenu.screenStack.numEntries )
        (*(void (__fastcall **)(int, MenuScreen *))(*(_DWORD *)v3 + 20))(
          v3,
          gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
      if ( gMobileMenu.pendingScreen )
        goto LABEL_15;
    }
  }
  gMobileMenu.pendingScreen = (MenuScreen *)v3;
}
// 66280C: using guessed type void *off_66280C;
// 662D40: using guessed type void *;
// 662DF8: using guessed type void *off_662DF8;

//----- (002A8564) --------------------------------------------------------
void __fastcall SaveScreen::SaveScreenSelection::SaveDone(void *data)
{
  if ( gMobileMenu.screenStack.numEntries >= 2 )
    (*((void (__fastcall **)(MenuScreen *, MenuScreen *))gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries
                                                                                       - 2]->_vptr$MenuScreen
     + 5))(
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 2],
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
  sub_191808(&gMobileMenu, 0, 0);
}

//----- (002A85AA) --------------------------------------------------------
void __fastcall CloudWaitScreen::~CloudWaitScreen(CloudWaitScreen *this)
{
  void *v1; // r0

  SelectScreen::~SelectScreen(this);
  sub_191374(v1);
}
// 2A85B6: variable 'v1' is possibly undefined

//----- (002A85BC) --------------------------------------------------------
void __fastcall CloudWaitScreen::Render(CloudWaitScreen *this, int stackPos)
{
  const unsigned __int8 *subtitle; // r6
  int v4; // r5
  float v5; // s16
  GxtChar *v6; // r0
  RsGlobalType_0 *v7; // r0
  int CloudUploadResult; // r5
  double v9; // d8
  int v10; // r4
  SelectScreen::MenuSelection *v11; // r0
  SelectScreen::MenuSelection *v12; // r0
  CVector2D v13; // [sp+14h] [bp-3Ch]
  CVector2D v14; // [sp+28h] [bp-28h] BYREF
  CRGBA v15; // [sp+30h] [bp-20h] BYREF
  CRGBA v16; // [sp+34h] [bp-1Ch] BYREF

  CharSelectScreen::Render(this, stackPos);
  subtitle = this->subtitle;
  CRGBA::CRGBA(&v15, 0xF0u, 0xF0u, 0xF0u, 0xFFu);
  v4 = (*((int (__fastcall **)(CloudWaitScreen *))this->_vptr$MenuScreen + 12))(this);
  v5 = COERCE_FLOAT((*((int (__fastcall **)(CloudWaitScreen *))this->_vptr$MenuScreen + 12))(this));
  v6 = CText::Get(&TheText, subtitle);
  v16 = v15;
  v13.y = 18.0;
  v13.x = 630.0 - v5;
  v7 = MenuScreen::DrawTextDirect(
         &v14,
         this,
         v6,
         TA_Left,
         1,
         (CRGBA)&v16,
         1,
         (CVector2D)((unsigned int)v4 | 0x428C000000000000LL),
         v13,
         1,
         0);
  CloudUploadResult = GetCloudUploadResult(v7);
  if ( CloudUploadResult || (v9 = this->lastTime + 20.0, v9 < OS_TimeAccurate()) )
  {
    if ( gMobileMenu.screenStack.numEntries >= 2 )
      (*((void (__fastcall **)(MenuScreen *, MenuScreen *))gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries
                                                                                         - 2]->_vptr$MenuScreen
       + 5))(
        gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 2],
        gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
    MobileMenu::RemoveTopScreen(&gMobileMenu, 0, 0);
    v10 = operator new(0x50u);
    CharSelectScreen::CharSelectScreen((CharSelectScreen *)v10, "FET_SG", 1);
    if ( CloudUploadResult == 1 )
    {
      *(_DWORD *)(v10 + 68) = "FES_SSC";
      *(_DWORD *)(v10 + 72) = CloudWaitScreen::SaveDone;
      *(_DWORD *)(v10 + 76) = 0;
      *(_DWORD *)v10 = &off_662DF8;
      v11 = (SelectScreen::MenuSelection *)operator new(0x10u);
      v11->_vptr$MenuSelection = (int (**)(void))&off_66280C;
      v11->tag = "FEM_OK";
      v11[1]._vptr$MenuSelection = (int (**)(void))OkScreen::OkFunc;
      v11[1].tag = 0;
      SelectScreen::AddItem((SelectScreen *)v10, v11);
      if ( gMobileMenu.screenStack.numEntries )
        (*(void (__fastcall **)(int, MenuScreen *))(*(_DWORD *)v10 + 20))(
          v10,
          gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
      if ( !gMobileMenu.pendingScreen )
        goto LABEL_14;
    }
    else
    {
      *(_DWORD *)(v10 + 68) = "FES_SVF";
      *(_DWORD *)(v10 + 72) = CloudWaitScreen::SaveDone;
      *(_DWORD *)(v10 + 76) = 0;
      *(_DWORD *)v10 = &off_662DF8;
      v12 = (SelectScreen::MenuSelection *)operator new(0x10u);
      v12->_vptr$MenuSelection = (int (**)(void))&off_66280C;
      v12->tag = "FEM_OK";
      v12[1]._vptr$MenuSelection = (int (**)(void))OkScreen::OkFunc;
      v12[1].tag = 0;
      SelectScreen::AddItem((SelectScreen *)v10, v12);
      if ( gMobileMenu.screenStack.numEntries )
        (*(void (__fastcall **)(int, MenuScreen *))(*(_DWORD *)v10 + 20))(
          v10,
          gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
      if ( !gMobileMenu.pendingScreen )
        goto LABEL_14;
    }
    MobileMenu::ProcessPending(&gMobileMenu);
LABEL_14:
    gMobileMenu.pendingScreen = (MenuScreen *)v10;
  }
}
// 195124: using guessed type int __fastcall GetCloudUploadResult(_DWORD);
// 66280C: using guessed type void *off_66280C;
// 662DF8: using guessed type void *off_662DF8;

//----- (002A8824) --------------------------------------------------------
float __fastcall ConfirmationScreen::GetStartY(ConfirmationScreen *this)
{
  return 140.0;
}

//----- (002A882C) --------------------------------------------------------
void __fastcall ConfirmationScreen::Render(ConfirmationScreen *this, int stackPos)
{
  const unsigned __int8 *subtitle; // r6
  int v4; // r5
  float v5; // s16
  GxtChar *v6; // r0
  CVector2D v7; // [sp+14h] [bp-3Ch]
  CVector2D v8; // [sp+28h] [bp-28h] BYREF
  CRGBA v9; // [sp+30h] [bp-20h] BYREF
  CRGBA v10; // [sp+34h] [bp-1Ch] BYREF

  CharSelectScreen::Render(this, stackPos);
  subtitle = this->subtitle;
  CRGBA::CRGBA(&v9, 0xF0u, 0xF0u, 0xF0u, 0xFFu);
  v4 = (*((int (__fastcall **)(ConfirmationScreen *))this->_vptr$MenuScreen + 12))(this);
  v5 = COERCE_FLOAT((*((int (__fastcall **)(ConfirmationScreen *))this->_vptr$MenuScreen + 12))(this));
  v6 = CText::Get(&TheText, subtitle);
  v10 = v9;
  v7.y = 18.0;
  v7.x = 630.0 - v5;
  MenuScreen::DrawTextDirect(
    &v8,
    this,
    v6,
    TA_Left,
    1,
    (CRGBA)&v10,
    1,
    (CVector2D)((unsigned int)v4 | 0x428C000000000000LL),
    v7,
    1,
    0);
}

//----- (002A88C8) --------------------------------------------------------
void __fastcall CloudWaitScreen::SaveDone(void *data)
{
  if ( gMobileMenu.screenStack.numEntries >= 2 )
    (*((void (__fastcall **)(MenuScreen *, MenuScreen *))gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries
                                                                                       - 2]->_vptr$MenuScreen
     + 5))(
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 2],
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
  sub_191808(&gMobileMenu, 0, 0);
}

//----- (002A890C) --------------------------------------------------------
void __fastcall YesNoScreen::NoFunc(SelectScreen *screen, int data)
{
  SelectScreen::MenuSelection **dataPtr; // r4

  dataPtr = screen[1].items.dataPtr;
  if ( gMobileMenu.screenStack.numEntries >= 2 )
    (*((void (__fastcall **)(MenuScreen *, MenuScreen *))gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries
                                                                                       - 2]->_vptr$MenuScreen
     + 5))(
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 2],
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
  MobileMenu::RemoveTopScreen(&gMobileMenu, 0, 0);
  if ( dataPtr )
    ((void (__fastcall *)(_DWORD))dataPtr)(0);
}

//----- (002A8960) --------------------------------------------------------
void __fastcall YesNoScreen::YesFunc(SelectScreen *screen, int data)
{
  __int64 v2; // kr00_8

  v2 = *(_QWORD *)&screen[1].items.numAlloced;
  if ( gMobileMenu.screenStack.numEntries >= 2 )
    (*((void (__fastcall **)(MenuScreen *, MenuScreen *))gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries
                                                                                       - 2]->_vptr$MenuScreen
     + 5))(
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 2],
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
  MobileMenu::RemoveTopScreen(&gMobileMenu, 0, 0);
  ((void (__fastcall *)(_DWORD))v2)(HIDWORD(v2));
}

//----- (002A89B0) --------------------------------------------------------
void __fastcall YesNoScreen::~YesNoScreen(YesNoScreen *this)
{
  void *v1; // r0

  SelectScreen::~SelectScreen(this);
  sub_191374(v1);
}
// 2A89BC: variable 'v1' is possibly undefined

//----- (002A89C0) --------------------------------------------------------
void __fastcall YesNoScreen::Render(YesNoScreen *this, int stackPos)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  const unsigned __int8 *subtitle; // r6
  int v6; // r5
  float v7; // s16
  GxtChar *v8; // r0
  float screenHeight; // s16
  float screenWidth; // s18
  GxtChar *v11; // r2
  CSprite2d *HelpSprite; // r0
  RwTexture_0 *mpTexture; // r10
  CVector2D var6C; // [sp+4h] [bp-6Ch]
  CVector2D v15; // [sp+Ch] [bp-64h]
  CVector2D v16; // [sp+14h] [bp-5Ch]
  CRGBA v17; // [sp+28h] [bp-48h] BYREF
  CVector2D v18; // [sp+2Ch] [bp-44h] BYREF
  CVector2D pvecUVLeftTop; // [sp+34h] [bp-3Ch] BYREF
  CRGBA v20; // [sp+3Ch] [bp-34h] BYREF
  CVector2D v21; // [sp+40h] [bp-30h] BYREF
  CVector2D cvector2d; // 0:r3.4,4:^0.4

  CharSelectScreen::Render(this, stackPos);
  subtitle = this->subtitle;
  CRGBA::CRGBA((CRGBA *)&v18, 0xF0u, 0xF0u, 0xF0u, 0xFFu);
  v6 = (*((int (__fastcall **)(YesNoScreen *))this->_vptr$MenuScreen + 12))(this);
  v7 = COERCE_FLOAT((*((int (__fastcall **)(YesNoScreen *))this->_vptr$MenuScreen + 12))(this));
  v8 = CText::Get(&TheText, subtitle);
  pvecUVLeftTop.x = v18.x;
  v16.y = 18.0;
  v16.x = 630.0 - v7;
  MenuScreen::DrawTextDirect(
    &v21,
    this,
    v8,
    TA_Left,
    1,
    (CRGBA)&pvecUVLeftTop,
    1,
    (CVector2D)((unsigned int)v6 | 0x428C000000000000LL),
    v16,
    1,
    0);
  if ( !this->hasBack && CHID::Implements(HID_MAPPING_MENU_ACCEPT) && CHID::GetInputType() == 1 )
  {
    screenHeight = (float)RsGlobal.screenHeight;
    screenWidth = (float)RsGlobal.screenWidth;
    CRGBA::CRGBA(&v20, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
    v3.n64_u32[0] = 12.5;
    v2.n64_f32[0] = screenWidth * 0.0;
    v11 = CText::Get(&TheText, "FEH_SEL");
    LODWORD(pvecUVLeftTop.x) = v20;
    v15.y = 431.0;
    v15.x = (float)((float)((float)((float)((float)(screenWidth - vmax_f32(v2, v3).n64_f32[0]) * 480.0)
                                  + (float)(screenWidth * -240.0))
                          / screenHeight)
                  + 320.0)
          + -120.0;
    MenuScreen::DrawTextDirect(
      &v21,
      this,
      v11,
      TA_Right,
      0,
      (CRGBA)&pvecUVLeftTop,
      1,
      v15,
      (CVector2D)0x41D8000042F00000LL,
      0,
      0);
    pvecUVLeftTop.x = 0.0;
    pvecUVLeftTop.y = 0.0;
    v18 = (CVector2D)0x3F8000003F800000LL;
    HelpSprite = CHID::GetHelpSprite(0, HID_MAPPING_MENU_ACCEPT, &pvecUVLeftTop, &v18);
    if ( HelpSprite )
    {
      mpTexture = HelpSprite->mpTexture;
      CRGBA::CRGBA(&v17, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
      var6C.y = 456.0;
      cvector2d.y = 436.0;
      cvector2d.x = v21.x + -25.0;
      var6C.x = v21.x + -5.0;
      MenuScreen::DrawSprite(this, mpTexture, (CRGBA)&v17, cvector2d, var6C, pvecUVLeftTop, v18);
    }
  }
}
// 2A8AA8: variable 'v2' is possibly undefined
// 2A8AA8: variable 'v3' is possibly undefined

//----- (002A8BBC) --------------------------------------------------------
void __fastcall OkScreen::OkFunc(SelectScreen *screen, int data)
{
  __int64 v2; // kr00_8

  v2 = *(_QWORD *)&screen[1].items.numAlloced;
  if ( gMobileMenu.screenStack.numEntries >= 2 )
    (*((void (__fastcall **)(MenuScreen *, MenuScreen *))gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries
                                                                                       - 2]->_vptr$MenuScreen
     + 5))(
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 2],
      gMobileMenu.screenStack.dataPtr[gMobileMenu.screenStack.numEntries - 1]);
  MobileMenu::RemoveTopScreen(&gMobileMenu, 0, 0);
  ((void (__fastcall *)(_DWORD))v2)(HIDWORD(v2));
}

//----- (002A8C0C) --------------------------------------------------------
void __fastcall OkScreen::~OkScreen(OkScreen *this)
{
  void *v1; // r0

  SelectScreen::~SelectScreen(this);
  sub_191374(v1);
}
// 2A8C18: variable 'v1' is possibly undefined

//----- (002A8C1C) --------------------------------------------------------
void __fastcall MobileMenu::InitGameVars(MobileMenu *this)
{
  this->m_WantsToRestartGame = 0;
  this->waypoint_blip = 0;
}

//----- (002A8C28) --------------------------------------------------------
void SettingsBeforeStartingGame()
{
  CStats::FavoriteRadioStationList[12] = 0;
  CStats::FavoriteRadioStationList[13] = 0;
  *(_QWORD *)&CStats::FavoriteRadioStationList[8] = 0LL;
  *(_QWORD *)&CStats::FavoriteRadioStationList[10] = 0LL;
  *(_QWORD *)CStats::FavoriteRadioStationList = 0LL;
  *(_QWORD *)&CStats::FavoriteRadioStationList[2] = 0LL;
  *(_QWORD *)&CStats::FavoriteRadioStationList[4] = 0LL;
  *(_QWORD *)&CStats::FavoriteRadioStationList[6] = 0LL;
  CAudioEngine::Reset(&AudioEngine);
  gMobileMenu.m_WantsToRestartGame = 1;
  if ( gMobileMenu.waypoint_blip )
  {
    CRadar::ClearBlip(gMobileMenu.waypoint_blip);
    gMobileMenu.waypoint_blip = 0;
  }
  CStats::UpdateRespectStat(1u);
  CCheat::m_bHasPlayerCheated = 0;
  CHud::SetZoneName(0, 1u);
  CCamera::SetFadeColour(&TheCamera, 0, 0, 0);
  CCamera::Fade(&TheCamera, 0.0, 0);
  CCamera::ProcessFade(&TheCamera);
  CCamera::Fade(&TheCamera, 2.0, 1);
  if ( CTouchInterface::m_pWidgets[162] )
    CWidgetHelpText::ClearQueue((CWidgetHelpText *)CTouchInterface::m_pWidgets[162], 1);
  CHID::RemoveQueuedText();
  sub_199388(WIDGET_SHOP);
}

//----- (002A8CF4) --------------------------------------------------------
void SendLanguageToSC()
{
  switch ( FrontEndMenuManager.m_PrefsLanguage )
  {
    case 0:
      sub_1967C0((const unsigned __int8 *)&dword_2A8D58);
      break;
    case 1:
      sub_1967C0((const unsigned __int8 *)&dword_2A8D4C);
      break;
    case 2:
      sub_1967C0((const unsigned __int8 *)&off_2A8D48);
      break;
    case 3:
      sub_1967C0((const unsigned __int8 *)&dword_2A8D54);
      break;
    case 4:
      sub_1967C0((const unsigned __int8 *)&dword_2A8D50);
      break;
    case 5:
      sub_1967C0((const unsigned __int8 *)&dword_2A8D44);
      break;
    case 6:
      sub_1967C0((const unsigned __int8 *)&dword_2A8D40);
      break;
  }
}
// 2A8D40: using guessed type int dword_2A8D40;
// 2A8D44: using guessed type int dword_2A8D44;
// 2A8D48: using guessed type void *off_2A8D48;
// 2A8D4C: using guessed type int dword_2A8D4C;
// 2A8D50: using guessed type int dword_2A8D50;
// 2A8D54: using guessed type int dword_2A8D54;
// 2A8D58: using guessed type int dword_2A8D58;

//----- (002A8D5C) --------------------------------------------------------
void Menu_ApplyLanguage()
{
  unsigned __int8 pStringToFill[8]; // [sp+4h] [bp-14h] BYREF

  if ( MobileSettings::settings[17].value != FrontEndMenuManager.m_PrefsLanguage )
  {
    FrontEndMenuManager.m_PrefsLanguage = MobileSettings::settings[17].value;
    CText::GetNameOfLoadedMissionText(&TheText, pStringToFill);
    CText::Load(&TheText, 0);
    if ( pStringToFill[0] )
      CText::LoadMissionText(&TheText, pStringToFill);
    if ( MobileSettings::settings[17].value >= 5u )
    {
      if ( MobileSettings::settings[17].value == 5 )
      {
        CFont::AddRussianTexture();
      }
      else if ( MobileSettings::settings[17].value == 6 )
      {
        CFont::AddJapaneseTexture();
      }
    }
    else
    {
      CFont::AddEFIGSFont();
    }
  }
}

//----- (002A8E10) --------------------------------------------------------
void Menu_ApplyAudioSettings()
{
  CAudioEngine::SetMusicMasterVolume(&AudioEngine, MobileSettings::settings[12].value);
  CAudioEngine::SetEffectsMasterVolume(&AudioEngine, MobileSettings::settings[11].value);
  CAudioEngine::SetBassEnhanceOnOff(&AudioEngine, 0);
  sub_18FC78(&AudioEngine, MobileSettings::settings[13].value);
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (002A8E54) --------------------------------------------------------
void Menu_SaveSettings()
{
  u_native v0; // r0
  u_native v1; // r4
  unsigned __int8 pData[4]; // [sp+4h] [bp-Ch] BYREF

  CFileMgr::SetDirMyDocuments();
  v0 = CFileMgr::OpenFile("gta_sa.set", (const unsigned __int8 *)&off_2A8EE4);
  v1 = v0;
  if ( v0 )
  {
    CFileMgr::Write(v0, "\b", 4);
    CFileMgr::Write(v1, (unsigned __int8 *)&CCamera::m_fMouseAccelHorzntl, 4);
    CFileMgr::Write(v1, (unsigned __int8 *)&MousePointerStateHelper.m_bUpAndDownInverted, 1);
    CFileMgr::Write(v1, (unsigned __int8 *)&CVehicle::m_bEnableMouseSteering, 1);
    CFileMgr::Write(v1, (unsigned __int8 *)&CVehicle::m_bEnableMouseFlying, 1);
    *(_DWORD *)pData = Fx_c::GetFxQuality(&g_fx);
    CFileMgr::Write(v1, pData, 4);
    MobileSettings::SaveToFile(v1);
    CFileMgr::CloseFile(v1);
  }
  CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
}
// 2A8EE4: using guessed type void *off_2A8EE4;
// 61CADE: using guessed type char byte_61CADE;

//----- (002A8F04) --------------------------------------------------------
void Menu_LoadSettings()
{
  void *v0; // r0
  void *v1; // r4
  int v2; // [sp+0h] [bp-18h] BYREF
  FxQuality_e buffer[5]; // [sp+4h] [bp-14h] BYREF

  CFileMgr::SetDirMyDocuments();
  v0 = (void *)CFileMgr::OpenFile("gta_sa.set", (const unsigned __int8 *)&dword_2A8FF8);
  v1 = v0;
  if ( v0 )
  {
    v2 = 0;
    MousePointerStateHelper.m_bUpAndDownInverted = 1;
    OS_FileRead(v0, &v2, 4);
    if ( v2 >= 8 )
    {
      OS_FileRead(v1, &CCamera::m_fMouseAccelHorzntl, 4);
      OS_FileRead(v1, &MousePointerStateHelper.m_bUpAndDownInverted, 1);
      OS_FileRead(v1, &CVehicle::m_bEnableMouseSteering, 1);
      OS_FileRead(v1, &CVehicle::m_bEnableMouseFlying, 1);
      CVehicle::m_bEnableMouseSteering = 0;
      CVehicle::m_bEnableMouseFlying = 0;
      OS_FileRead(v1, buffer, 4);
      Fx_c::SetFxQuality(&g_fx, buffer[0]);
      MobileSettings::LoadFromFile((u_native)v1);
      CAudioEngine::SetMusicMasterVolume(&AudioEngine, MobileSettings::settings[12].value);
      CAudioEngine::SetEffectsMasterVolume(&AudioEngine, MobileSettings::settings[11].value);
      CAudioEngine::SetBassEnhanceOnOff(&AudioEngine, 0);
      CAudioEngine::SetRadioAutoRetuneOnOff(&AudioEngine, MobileSettings::settings[13].value);
      Menu_ApplyLanguage();
    }
    CFileMgr::CloseFile((u_native)v1);
  }
  CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
}
// FC: using guessed type int elf_hash_bucket[16411];
// 2A8FF8: using guessed type int dword_2A8FF8;
// 61CADE: using guessed type char byte_61CADE;
// 2A8F04: using guessed type FxQuality_e buffer[5];

//----- (002A9020) --------------------------------------------------------
void CachePlayerControls()
{
  oldDisablePlayerControls = CPad::GetPad(0)->DisablePlayerControls;
}

//----- (002A903C) --------------------------------------------------------
void RestorePlayerControls()
{
  UInt16 v0; // r4

  v0 = oldDisablePlayerControls;
  CPad::GetPad(0)->DisablePlayerControls = v0;
}

//----- (002A9058) --------------------------------------------------------
void Menu_SwitchOnFromGame()
{
  CPad *Pad; // r0
  CPad *v1; // r0

  DoRWStuffStartOfFrame(0, 0, 0, 0, 0, 0, 255);
  DoRWStuffEndOfFrame(0);
  oldDisablePlayerControls = CPad::GetPad(0)->DisablePlayerControls;
  CPad::GetPad(0)->DisablePlayerControls = 1;
  Pad = CPad::GetPad(0);
  CPad::Clear(Pad, 0, 1);
  CPad::GetPad(0);
  CPad::ClearKeyBoardHistory();
  v1 = CPad::GetPad(0);
  sub_194820(v1);
}

//----- (002A90C4) --------------------------------------------------------
void __fastcall Menu_DrawLoadScreen(bool lastOne, int ChunksToLoad)
{
  CLoadingScreen::DoPCScreenChange(lastOne, !lastOne);
  skipFrame = 1;
}

//----- (002A90E0) --------------------------------------------------------
void Menu_RetryMission()
{
  AllowMissionReplay = 6;
  CMissionCleanup::Process(&CTheScripts::MissionCleanUp);
  if ( CGenericGameStorage::CheckSlotDataValid(9, 1) )
  {
    if ( gGameState == 9 )
      SettingsBeforeStartingGame();
    gMobileMenu.SelectedSlot = 9;
    CGame::bMissionPackGame = 0;
    gMobileMenu.WantsToLoad = 1;
    if ( AllowMissionReplay != 6 )
      AllowMissionReplay = 0;
  }
}

//----- (002A9164) --------------------------------------------------------
bool __fastcall Menu_LoadSlot(int slot)
{
  bool result; // r0

  if ( !CGenericGameStorage::CheckSlotDataValid(slot, 1) )
    return 0;
  if ( gGameState == 9 )
    SettingsBeforeStartingGame();
  gMobileMenu.SelectedSlot = slot;
  CGame::bMissionPackGame = 0;
  result = 1;
  gMobileMenu.WantsToLoad = 1;
  if ( AllowMissionReplay != 6 )
  {
    AllowMissionReplay = 0;
    return 1;
  }
  return result;
}

//----- (002A91D0) --------------------------------------------------------
void Menu_ShowMissionRetry()
{
  bool v0; // zf

  v0 = gMobileMenu.screenStack.numEntries == 0;
  if ( !gMobileMenu.screenStack.numEntries )
    v0 = gMobileMenu.pendingScreen == 0;
  if ( v0 )
    sub_18F2F4(&gMobileMenu);
}

//----- (002A91F8) --------------------------------------------------------
void Menu_ShowNag()
{
  bool v0; // zf

  v0 = gMobileMenu.screenStack.numEntries == 0;
  if ( !gMobileMenu.screenStack.numEntries )
    v0 = gMobileMenu.pendingScreen == 0;
  if ( v0 )
    sub_197BA4(&gMobileMenu);
}

//----- (002A9220) --------------------------------------------------------
void ProcessShaderCache()
{
  const char *v0; // r0
  u_native v1; // r0
  u_native v2; // r5
  unsigned int v3; // r10
  size_t v4; // r5
  unsigned int v5; // r11
  GLuint *v6; // r4
  void *v7; // r8
  void *v8; // r9
  void *v9; // r0
  GLuint v10; // r1
  void *p; // [sp+4h] [bp-12Ch]
  u_native id; // [sp+8h] [bp-128h]
  GLuint v13; // [sp+Ch] [bp-124h] BYREF
  unsigned __int8 pLine[256]; // [sp+10h] [bp-120h] BYREF

  v0 = "scache_small.txt";
  if ( !MobileSettings::settings[0].value )
    v0 = "scache_small_low.txt";
  v1 = CFileMgr::OpenFile((const unsigned __int8 *)v0, "r");
  v2 = v1;
  if ( v1 )
  {
    p = 0;
    if ( CFileMgr::ReadLine(v1, pLine, 256) )
    {
      id = v2;
      v3 = 1;
      v4 = 0;
      v5 = 0;
      v6 = 0;
      v7 = 0;
      v8 = 0;
      do
      {
        v13 = 0;
        sscanf((const char *)pLine, "%x", &v13);
        if ( v5 < v3 )
        {
          v5 = (v4 * 4 + 4) / 3 + 3;
          v9 = malloc(4 * v5);
          v8 = v9;
          if ( v6 )
          {
            qmemcpy(v9, v7, v4 * 4);
            free(v7);
          }
          v7 = v8;
          v6 = (GLuint *)v8;
        }
        v6[v4++] = v13;
        ++v3;
      }
      while ( CFileMgr::ReadLine(id, pLine, 256) );
      v2 = id;
      v10 = v3 - 1;
      p = v8;
    }
    else
    {
      v6 = 0;
      v10 = 0;
    }
    emu_ShaderListCompile(v6, v10);
    CFileMgr::CloseFile(v2);
    if ( v6 )
      free(p);
  }
}

//----- (002A9360) --------------------------------------------------------
void Menu_SwitchOffToGame()
{
  CPad *Pad; // r0
  CPad *v1; // r0
  UInt16 v2; // r4

  if ( CHID::m_pInstance[0] )
    CHID::m_nDeadFrames = 1;
  if ( !Menu_SwitchOffToGame(void)::bInitWidgets )
  {
    CTouchInterface::CreateAll();
    Menu_SwitchOffToGame(void)::bInitWidgets = 1;
  }
  Pad = CPad::GetPad(0);
  CPad::Clear(Pad, 0, 1);
  CPad::GetPad(0);
  CPad::ClearKeyBoardHistory();
  v1 = CPad::GetPad(0);
  CPad::ClearMouseHistory(v1);
  CTimer::EndUserPause();
  CTimer::Update();
  SaveTelemetry();
  CPad::GetPad(0)->JustOutOfFrontEnd = 1;
  CPad::GetPad(0)->LastTimeTouched = 0;
  CPad::GetPad(1)->LastTimeTouched = 0;
  v2 = oldDisablePlayerControls;
  CPad::GetPad(0)->DisablePlayerControls = v2;
  CRenderer::ms_lodDistScale = (float)((float)((float)MobileSettings::settings[2].value * 0.875) * 0.01) + 0.875;
}
// 6E03C4: using guessed type char Menu_SwitchOffToGame(void)::bInitWidgets;

//----- (002A943C) --------------------------------------------------------
void Menu_NewGame()
{
  AllowMissionReplay = 0;
  SettingsBeforeStartingGame();
}

//----- (002A9450) --------------------------------------------------------
void __fastcall Menu_PauseGame(bool pause)
{
  if ( pause )
    sub_196814();
  else
    sub_190240();
}

//----- (002A945C) --------------------------------------------------------
void Menu_Resume()
{
  if ( CGenericGameStorage::CheckSlotDataValid(9, 1) )
  {
    gMobileMenu.SelectedSlot = 9;
    SettingsBeforeStartingGame();
    gMobileMenu.WantsToLoad = 1;
  }
}
// 4C: using guessed type int;

//----- (002A9490) --------------------------------------------------------
bool __fastcall Menu_IsPlayingGame(bool checkThatGameIsResumable)
{
  return gGameState == 9;
}

//----- (002A94A8) --------------------------------------------------------
bool __fastcall Menu_DeleteSlot(int slotIndex)
{
  return sub_19F10C(&PcSaveHelper, slotIndex);
}

//----- (002A94BC) --------------------------------------------------------
void Menu_ClearSlots()
{
  *(_QWORD *)CGenericGameStorage::ms_Slots = 0x100000001LL;
  *(_QWORD *)&CGenericGameStorage::ms_Slots[2] = 0x100000001LL;
  *(_QWORD *)&CGenericGameStorage::ms_Slots[4] = 0x100000001LL;
  *(_QWORD *)&CGenericGameStorage::ms_Slots[6] = 0x100000001LL;
  CGenericGameStorage::ms_SlotFileName[8][0] = 0;
  CGenericGameStorage::ms_SlotFileName[0][0] = 0;
  CGenericGameStorage::ms_SlotFileName[1][0] = 0;
  CGenericGameStorage::ms_SlotFileName[2][0] = 0;
  CGenericGameStorage::ms_SlotFileName[3][0] = 0;
  CGenericGameStorage::ms_SlotFileName[4][0] = 0;
  CGenericGameStorage::ms_SlotFileName[5][0] = 0;
  CGenericGameStorage::ms_SlotFileName[6][0] = 0;
  CGenericGameStorage::ms_SlotFileName[7][0] = 0;
  CGenericGameStorage::ms_SlotSaveDate[0][0] = 0;
  CGenericGameStorage::ms_SlotSaveDate[1][0] = 0;
  CGenericGameStorage::ms_SlotSaveDate[2][0] = 0;
  CGenericGameStorage::ms_SlotSaveDate[3][0] = 0;
  CGenericGameStorage::ms_SlotSaveDate[4][0] = 0;
  CGenericGameStorage::ms_SlotSaveDate[5][0] = 0;
  CGenericGameStorage::ms_SlotSaveDate[6][0] = 0;
  CGenericGameStorage::ms_SlotSaveDate[7][0] = 0;
  CGenericGameStorage::ms_Slots[8] = 1;
  CGenericGameStorage::ms_SlotSaveDate[8][0] = 0;
}
// FC: using guessed type int elf_hash_bucket[16411];

//----- (002A9538) --------------------------------------------------------
void __fastcall Menu_PopulateSaves(bool ForceUpdate)
{
  GxtChar (*v1)[260]; // r11
  int v2; // r8
  u_native v3; // r0
  void *v4; // r10
  Char *v5; // r0
  GxtChar *v6; // r0
  __int64 *v7; // r1
  __int64 v8; // d16
  __int64 v9; // d17
  __int64 v10; // d18
  __int64 v11; // d19
  __int64 v12; // d20
  __int64 v13; // d21
  GxtChar *v14; // r0
  uint32 savedKey; // [sp+24h] [bp-304h] BYREF
  _QWORD v16[53]; // [sp+28h] [bp-300h] BYREF
  __int64 pInString[6]; // [sp+1D0h] [bp-158h] BYREF
  unsigned __int8 pString[260]; // [sp+204h] [bp-124h] BYREF

  v1 = CGenericGameStorage::ms_SlotFileName;
  v2 = 0;
  *(_QWORD *)CGenericGameStorage::ms_Slots = 0x100000001LL;
  *(_QWORD *)&CGenericGameStorage::ms_Slots[2] = 0x100000001LL;
  *(_QWORD *)&CGenericGameStorage::ms_Slots[4] = 0x100000001LL;
  *(_QWORD *)&CGenericGameStorage::ms_Slots[6] = 0x100000001LL;
  CGenericGameStorage::ms_SlotFileName[8][0] = 0;
  CGenericGameStorage::ms_Slots[8] = 1;
  CGenericGameStorage::ms_SlotSaveDate[0][0] = 0;
  CGenericGameStorage::ms_SlotFileName[0][0] = 0;
  CGenericGameStorage::ms_SlotFileName[1][0] = 0;
  CGenericGameStorage::ms_SlotSaveDate[1][0] = 0;
  CGenericGameStorage::ms_SlotFileName[2][0] = 0;
  CGenericGameStorage::ms_SlotSaveDate[2][0] = 0;
  CGenericGameStorage::ms_SlotFileName[3][0] = 0;
  CGenericGameStorage::ms_SlotSaveDate[3][0] = 0;
  CGenericGameStorage::ms_SlotFileName[4][0] = 0;
  CGenericGameStorage::ms_SlotSaveDate[4][0] = 0;
  CGenericGameStorage::ms_SlotFileName[5][0] = 0;
  CGenericGameStorage::ms_SlotSaveDate[5][0] = 0;
  CGenericGameStorage::ms_SlotFileName[6][0] = 0;
  CGenericGameStorage::ms_SlotSaveDate[6][0] = 0;
  CGenericGameStorage::ms_SlotSaveDate[7][0] = 0;
  CGenericGameStorage::ms_SlotFileName[7][0] = 0;
  CGenericGameStorage::ms_SlotSaveDate[8][0] = 0;
  do
  {
    C_PcSave::GenerateGameFilename(&PcSaveHelper, v2, pString);
    CFileMgr::SetDirMyDocuments();
    v3 = CFileMgr::OpenFile(pString, (const unsigned __int8 *)&dword_2A972C);
    v4 = (void *)v3;
    if ( v3 )
    {
      CFileMgr::Seek(v3, 5, 0);
      OS_FileRead(v4, &savedKey, 428);
      if ( (int)CGenericGameStorage::GetSavedVersionNumber(savedKey) >= 2
        && strncmp((const char *)v16, (const char *)TopLineEmptyFile, 0x1Au) )
      {
        CGenericGameStorage::ms_Slots[v2] = 0;
        pInString[4] = v16[4];
        pInString[5] = v16[5];
        pInString[0] = v16[0];
        pInString[1] = v16[1];
        pInString[2] = v16[2];
        pInString[3] = v16[3];
        v5 = GxtCharToAscii((GxtChar *)pInString, 0);
        v6 = CText::Get(&TheText, v5);
        v7 = (__int64 *)(v6 + 16);
        v8 = *(_QWORD *)v6;
        v9 = *((_QWORD *)v6 + 1);
        v6 += 8;
        v10 = *(_QWORD *)v6;
        v11 = *((_QWORD *)v6 + 1);
        v12 = *v7;
        v13 = v7[1];
        (*v1)[24] = 0;
        *(_QWORD *)&(*v1)[16] = v12;
        *(_QWORD *)&(*v1)[20] = v13;
        *(_QWORD *)v1 = v8;
        *(_QWORD *)&(*v1)[4] = v9;
        *(_QWORD *)&(*v1)[8] = v10;
        *(_QWORD *)&(*v1)[12] = v11;
      }
      CFileMgr::CloseFile((u_native)v4);
    }
    if ( !CGenericGameStorage::ms_Slots[v2] && !CGenericGameStorage::CheckDataNotCorrupt(v2, pString) )
    {
      v14 = CText::Get(&TheText, "FEC_SLC");
      CMessages::InsertNumberInString(v14, v2 + 1, -1, -1, -1, -1, -1, (GxtChar *)v1);
    }
    ++v2;
    ++v1;
  }
  while ( v2 != 9 );
  CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
}
// 2A972C: using guessed type int dword_2A972C;
// 61CADE: using guessed type char byte_61CADE;

//----- (002A9760) --------------------------------------------------------
bool IsWideScreen()
{
  return (float)((float)RsGlobal.screenWidth / (float)RsGlobal.screenHeight) > 1.8;
}

//----- (002A9798) --------------------------------------------------------
void __fastcall UpdateMapArea(bool bForceTouch)
{
  _BOOL4 v1; // r4
  int InputType; // r0
  bool v3; // zf
  RwInt32 screenHeight; // r0
  int v5; // r1
  int v6; // r2
  CVector2D v7; // [sp+0h] [bp-28h] BYREF
  CVector2D radarPt; // [sp+8h] [bp-20h] BYREF
  CVector2D screenPt; // [sp+10h] [bp-18h] BYREF
  int y; // [sp+18h] [bp-10h] BYREF
  int x[3]; // [sp+1Ch] [bp-Ch] BYREF

  v1 = bForceTouch;
  y = 0;
  x[0] = 0;
  InputType = CHID::GetInputType();
  v3 = InputType == 1;
  if ( InputType == 1 )
    v3 = !v1;
  if ( v3 )
  {
    screenHeight = RsGlobal.screenHeight;
    v6 = RsGlobal.screenHeight / 2;
    y = RsGlobal.screenHeight / 2;
    v5 = RsGlobal.screenWidth / 2;
    x[0] = RsGlobal.screenWidth / 2;
  }
  else
  {
    LIB_PointerGetCoordinates(lastDevice, x, &y, 0);
    screenHeight = RsGlobal.screenHeight;
    v6 = y;
    v5 = x[0];
  }
  screenPt.y = (float)((float)v6 * 448.0) / (float)screenHeight;
  screenPt.x = (float)((float)v5 * 448.0) / (float)screenHeight;
  CRadar::TransformScreenSpaceToRadarPoint(&screenPt, &radarPt);
  CRadar::TransformRadarPointToRealWorldSpace(&v7, &radarPt);
  *(CVector2D *)&gMobileMenu.MAP_AREA_X = v7;
}
// 2A9798: using guessed type int x[3];

//----- (002A9858) --------------------------------------------------------
void __fastcall CalculateMapLimits(float *pTop, float *pBottom, float *pLeft, float *pRight)
{
  float NEW_MAP_SCALE; // s2

  *pTop = gMobileMenu.MAP_OFFSET_Y - gMobileMenu.NEW_MAP_SCALE;
  *pBottom = gMobileMenu.MAP_OFFSET_Y + gMobileMenu.NEW_MAP_SCALE;
  *pLeft = gMobileMenu.MAP_OFFSET_X - gMobileMenu.NEW_MAP_SCALE;
  NEW_MAP_SCALE = gMobileMenu.NEW_MAP_SCALE;
  if ( (float)((float)RsGlobal.screenWidth / (float)RsGlobal.screenHeight) <= 1.8 )
    NEW_MAP_SCALE = (float)(gMobileMenu.NEW_MAP_SCALE * (float)RsGlobal.screenWidth) / (float)RsGlobal.screenHeight;
  *pRight = gMobileMenu.MAP_OFFSET_X + NEW_MAP_SCALE;
}

//----- (002A98E0) --------------------------------------------------------
bool __fastcall ProcessMapTeleport(bool bClicked, float fElapsedTime)
{
  return 0;
}

//----- (002A98E4) --------------------------------------------------------
void __fastcall PlaceRedMarker(bool bClicked)
{
  _BOOL4 IsReleased; // r0

  if ( bClicked )
  {
    if ( (CTheScripts::HideAllFrontEndMapBlips | CTheScripts::bPlayerIsOffTheMap) << 24 )
      return;
    goto LABEL_6;
  }
  IsReleased = CHID::IsReleased(HID_MAPPING_WAYPOINT_BLIP);
  if ( !((CTheScripts::HideAllFrontEndMapBlips | CTheScripts::bPlayerIsOffTheMap) << 24) && IsReleased )
  {
LABEL_6:
    if ( gMobileMenu.waypoint_blip )
    {
      CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 2, 0.0, 1.0);
      CRadar::ClearBlip(gMobileMenu.waypoint_blip);
      gMobileMenu.waypoint_blip = 0;
    }
    else
    {
      CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 1, 0.0, 1.0);
      gMobileMenu.waypoint_blip = CRadar::SetCoordBlip(
                                    4,
                                    SLODWORD(gMobileMenu.MAP_AREA_X),
                                    SLODWORD(gMobileMenu.MAP_AREA_Y),
                                    0,
                                    0,
                                    2);
      sub_19FF24(gMobileMenu.waypoint_blip, 41);
    }
  }
}

//----- (002A99BC) --------------------------------------------------------
void Menu_MapInitPause()
{
  float MAP_OFFSET_X; // s4
  float v1; // s12
  float MAP_OFFSET_Y; // s0
  float v3; // s8
  bool v4; // zf
  bool v5; // nf
  float NEW_MAP_SCALE; // s12
  float v7; // s6
  float v8; // s8
  float v9; // s2

  MAP_OFFSET_X = gMobileMenu.MAP_OFFSET_X;
  v1 = (float)RsGlobal.screenWidth / (float)RsGlobal.screenHeight;
  MAP_OFFSET_Y = gMobileMenu.MAP_OFFSET_Y;
  v3 = gMobileMenu.MAP_OFFSET_X - gMobileMenu.NEW_MAP_SCALE;
  v4 = v1 == 1.8;
  v5 = v1 < 1.8;
  NEW_MAP_SCALE = gMobileMenu.NEW_MAP_SCALE;
  if ( v5 || v4 )
    NEW_MAP_SCALE = (float)(gMobileMenu.NEW_MAP_SCALE * (float)RsGlobal.screenWidth) / (float)RsGlobal.screenHeight;
  v7 = gMobileMenu.MAP_OFFSET_X + NEW_MAP_SCALE;
  if ( v3 > 0.0 )
  {
    MAP_OFFSET_X = gMobileMenu.MAP_OFFSET_X - v3;
    gMobileMenu.MAP_OFFSET_X = gMobileMenu.MAP_OFFSET_X - v3;
  }
  v8 = gMobileMenu.MAP_OFFSET_Y - gMobileMenu.NEW_MAP_SCALE;
  if ( v7 < 640.0 )
    gMobileMenu.MAP_OFFSET_X = (float)(640.0 - v7) + MAP_OFFSET_X;
  v9 = gMobileMenu.MAP_OFFSET_Y + gMobileMenu.NEW_MAP_SCALE;
  if ( v8 > 0.0 )
  {
    MAP_OFFSET_Y = gMobileMenu.MAP_OFFSET_Y - v8;
    gMobileMenu.MAP_OFFSET_Y = gMobileMenu.MAP_OFFSET_Y - v8;
  }
  if ( v9 < 448.0 )
    gMobileMenu.MAP_OFFSET_Y = (float)(448.0 - v9) + MAP_OFFSET_Y;
  CRadar::SetMapCentreToPlayerCoords();
  Menu_MapUpdate(0.0);
}

//----- (002A9AB8) --------------------------------------------------------
void __fastcall Menu_MapUpdate(float deltaTime)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d13
  float v4; // s16
  int v5; // s20
  int InputType; // r0
  int v7; // r10
  float NEW_MAP_SCALE; // s22
  int v9; // r11
  int v10; // r8
  __int64 v11; // r0
  float v12; // s0
  float v13; // s2
  int v14; // r2
  float MAP_OFFSET_X; // s30
  float MAP_OFFSET_Y; // s25
  float v17; // s4
  bool v18; // fzf
  bool v19; // fnf
  float v20; // s4
  char v21; // r0
  float v22; // s0
  float v23; // s21
  float v24; // s23
  float v25; // s0
  float v26; // s0
  OSPointerState Button; // r0
  float v28; // s0
  char v29; // r1
  float screenHeight; // s2
  int v31; // r0
  int v32; // r0
  float v33; // s29
  float v34; // s31
  CWidget *v35; // r5
  float v36; // s20
  float v37; // s19
  float v38; // r0
  float v39; // s0
  float Wheel; // r0
  float v41; // s0
  float v42; // s16
  float i; // s0
  float v44; // s16
  float v45; // s16
  float j; // s0
  float v47; // s16
  float v48; // s0
  float v49; // r0
  float v50; // s0
  int v51; // r4
  int v52; // r10
  char v53; // r0
  float v54; // s0
  float v55; // s4
  float v56; // s0
  float v57; // s0
  int v58; // r3
  bool v59; // r6
  float v60; // s4
  float v61; // s2
  float v62; // s0
  float v63; // s12
  float v64; // s8
  float v65; // s6
  float v66; // s22
  float v67; // s24
  float v68; // s8
  float v69; // s2
  float v70; // s26
  float v71; // s28
  int v72; // s0
  int v73; // s0
  int32 v74; // r4
  float v75; // s30
  float v76; // s29
  float v77; // s19
  int v78; // r8
  int32 k; // r5
  int v80; // r0
  float v81; // s4
  float v82; // s0
  float v83; // s0
  double v84; // d16
  int v85; // r9
  char v86; // [sp+4h] [bp-8Ch]
  int v87; // [sp+Ch] [bp-84h]
  int v88; // [sp+10h] [bp-80h]
  float pfValueOut; // [sp+14h] [bp-7Ch] BYREF
  CVector2D worldPt; // [sp+18h] [bp-78h] BYREF
  CVector2D y; // [sp+20h] [bp-70h] BYREF
  CVector2D x[13]; // [sp+28h] [bp-68h] BYREF

  v4 = (float)RsGlobal.screenWidth / (float)RsGlobal.screenHeight;
  v5 = (int)((double)RsGlobal.screenHeight * 0.05);
  gMobileMenu.DisplayingMap = 1;
  mapScroll = mapScroll + deltaTime;
  InputType = CHID::GetInputType();
  v7 = v5;
  NEW_MAP_SCALE = gMobileMenu.NEW_MAP_SCALE;
  if ( v4 <= 1.8 )
    v7 = 0;
  if ( InputType == 1 )
  {
    v9 = 225;
    v10 = 228;
    v11 = *(_QWORD *)&RsGlobal.screenWidth;
    v12 = (float)((float)RsGlobal.screenWidth / (float)RsGlobal.screenHeight) + -1.0;
    v13 = (float)(gMobileMenu.NEW_MAP_SCALE + -300.0) / 800.0;
    v14 = (int)(float)((float)((float)((float)(v12 * 530.0) + -410.0)
                             + (float)(v13
                                     * (float)((float)((float)(v12 * 1300.0) + -400.0)
                                             - (float)((float)(v12 * 530.0) + -410.0))))
                     + 640.0);
    v7 = (int)(float)((float)((float)((float)(v12 * 220.0) + 220.0)
                            + (float)(v13
                                    * (float)((float)((float)(v12 * 250.0) + 200.0)
                                            - (float)((float)(v12 * 220.0) + 220.0))))
                    + (float)v7);
  }
  else
  {
    v14 = 640;
    v9 = 0;
    v10 = 388;
    v11 = *(_QWORD *)&RsGlobal.screenWidth;
  }
  v88 = v14;
  MAP_OFFSET_X = gMobileMenu.MAP_OFFSET_X;
  MAP_OFFSET_Y = gMobileMenu.MAP_OFFSET_Y;
  v17 = (float)(int)v11 / (float)SHIDWORD(v11);
  v18 = v17 == 1.8;
  v19 = v17 < 1.8;
  v20 = gMobileMenu.NEW_MAP_SCALE;
  if ( v19 || v18 )
    v20 = (float)(gMobileMenu.NEW_MAP_SCALE * (float)(int)v11) / (float)SHIDWORD(v11);
  UpdateMapArea(0);
  v21 = `guard variable for'Menu_MapUpdate(float)::fTime;
  __dmb(0xBu);
  if ( (v21 & 1) == 0 && _cxa_guard_acquire((__guard *)&`guard variable for'Menu_MapUpdate(float)::fTime) )
  {
    v22 = OS_TimeAccurate();
    Menu_MapUpdate(float)::fTime = v22;
    _cxa_guard_release((__guard *)&`guard variable for'Menu_MapUpdate(float)::fTime);
  }
  v23 = 224.0 - MAP_OFFSET_Y;
  v24 = 320.0 - MAP_OFFSET_X;
  v25 = OS_TimeAccurate() - Menu_MapUpdate(float)::fTime;
  Menu_MapUpdate(float)::fElapsedTime = v25;
  v26 = OS_TimeAccurate();
  Menu_MapUpdate(float)::fTime = v26;
  Button = LIB_PointerGetButton(lastDevice, 0);
  if ( (Button | 1) == 3 )
  {
    if ( Button == OSPS_ButtonPressed )
      LIB_PointerGetCoordinates(lastDevice, &Menu_MapUpdate(float)::nPressedX, &Menu_MapUpdate(float)::nPressedY, 0);
    v86 = 0;
    v28 = Menu_MapUpdate(float)::fElapsedTime + Menu_MapUpdate(float)::fStationaryTime;
  }
  else
  {
    if ( Button )
    {
      v86 = 0;
      goto LABEL_34;
    }
    v29 = 0;
    if ( Menu_MapUpdate(float)::fStationaryTime < 0.66 )
    {
      x[0].x = 0.0;
      y.x = 0.0;
      LIB_PointerGetCoordinates(lastDevice, (int *)x, (int *)&y, 0);
      v29 = 0;
      screenHeight = (float)RsGlobal.screenHeight;
      if ( (float)((float)((float)v7 / 448.0) * (float)RsGlobal.screenHeight) < (float)SLODWORD(x[0].x) )
      {
        if ( (float)((float)((float)v88 / 448.0) * screenHeight) <= (float)SLODWORD(x[0].x)
          || (float)((float)((float)v9 / 448.0) * screenHeight) >= (float)SLODWORD(y.x)
          || (float)((float)((float)v10 / 448.0) * screenHeight) <= (float)SLODWORD(y.x) )
        {
          goto LABEL_31;
        }
        v31 = LODWORD(x[0].x) - Menu_MapUpdate(float)::nPressedX;
        if ( LODWORD(x[0].x) - Menu_MapUpdate(float)::nPressedX < 0 )
          v31 = Menu_MapUpdate(float)::nPressedX - LODWORD(x[0].x);
        if ( v31 > 14 )
        {
LABEL_31:
          v29 = 0;
        }
        else
        {
          v32 = LODWORD(y.x) - Menu_MapUpdate(float)::nPressedY;
          v29 = 0;
          if ( LODWORD(y.x) - Menu_MapUpdate(float)::nPressedY < 0 )
            v32 = Menu_MapUpdate(float)::nPressedY - LODWORD(y.x);
          if ( v32 < 15 )
            v29 = 1;
        }
      }
    }
    v86 = v29;
    v28 = 0.0;
    Menu_MapUpdate(float)::nPressedY = 0;
    Menu_MapUpdate(float)::nPressedX = 0;
  }
  Menu_MapUpdate(float)::fStationaryTime = v28;
LABEL_34:
  v33 = v23 / NEW_MAP_SCALE;
  v34 = v24 / NEW_MAP_SCALE;
  if ( !CTouchInterface::IsPinchZooming(WIDGET_MAP, 0, 1) )
  {
    v37 = 1.0;
    Menu_MapUpdate(float)::bZoomStarted = 0;
    goto LABEL_46;
  }
  v35 = CTouchInterface::m_pWidgets[150];
  if ( !CTouchInterface::m_pWidgets[150] )
  {
    v37 = 1.0;
    goto LABEL_46;
  }
  if ( Menu_MapUpdate(float)::bZoomStarted == 1 )
  {
    v36 = Menu_MapUpdate(float)::fPrevDistance;
  }
  else
  {
    v36 = COERCE_FLOAT((*((int (__fastcall **)(CWidget *))CTouchInterface::m_pWidgets[150]->_vptr$CWidget + 6))(CTouchInterface::m_pWidgets[150]));
    Menu_MapUpdate(float)::fPrevDistance = v36;
    Menu_MapUpdate(float)::bZoomStarted = 1;
  }
  v37 = 1.0;
  if ( v36 != (*((float (__fastcall **)(CWidget *))v35->_vptr$CWidget + 6))(v35) )
  {
    v38 = (*((float (__fastcall **)(CWidget *))v35->_vptr$CWidget + 6))(v35);
    if ( (float)(v38 / Menu_MapUpdate(float)::fPrevDistance) == -INFINITY )
      v37 = INFINITY;
    else
      v37 = fabsf(sqrtf(v38 / Menu_MapUpdate(float)::fPrevDistance));
  }
  LODWORD(Menu_MapUpdate(float)::fPrevDistance) = (*((int (__fastcall **)(CWidget *))v35->_vptr$CWidget + 6))(v35);
  if ( v37 <= 1.0 )
  {
LABEL_46:
    if ( LIB_PointerGetWheel(0) <= 0.0 && !CHID::IsPressed(HID_MAPPING_MAP_ZOOM_OUT, 0) )
      goto LABEL_63;
  }
  if ( v37 == 1.0 )
    v39 = (float)((float)(deltaTime * 7.0) * 100.0) + gMobileMenu.NEW_MAP_SCALE;
  else
    v39 = v37 * gMobileMenu.NEW_MAP_SCALE;
  gMobileMenu.NEW_MAP_SCALE = v39;
  Wheel = LIB_PointerGetWheel(0);
  v41 = gMobileMenu.NEW_MAP_SCALE;
  if ( Wheel > 0.0 )
  {
    v41 = gMobileMenu.NEW_MAP_SCALE + 21.0;
    gMobileMenu.NEW_MAP_SCALE = gMobileMenu.NEW_MAP_SCALE + 21.0;
  }
  if ( v41 > 1100.0 )
  {
    v41 = 1100.0;
    gMobileMenu.NEW_MAP_SCALE = 1100.0;
  }
  gMobileMenu.MAP_OFFSET_X = gMobileMenu.MAP_OFFSET_X - (float)((float)(v34 * v41) - v24);
  gMobileMenu.MAP_OFFSET_Y = gMobileMenu.MAP_OFFSET_Y - (float)((float)(v33 * v41) - v23);
  y = *(CVector2D *)&gMobileMenu.MAP_AREA_X;
  CRadar::TransformRealWorldPointToRadarSpace(x, &y);
  CRadar::LimitRadarPoint(x);
  CRadar::TransformRadarPointToScreenSpace(&y, x);
  v42 = (float)(v88 - 4);
  for ( i = y.x; y.x > v42; i = y.x )
  {
    gMobileMenu.MAP_AREA_X = gMobileMenu.MAP_AREA_X + -1.0;
    worldPt = *(CVector2D *)&gMobileMenu.MAP_AREA_X;
    CRadar::TransformRealWorldPointToRadarSpace(x, &worldPt);
    CRadar::LimitRadarPoint(x);
    CRadar::TransformRadarPointToScreenSpace(&y, x);
  }
  v44 = (float)(v7 + 4);
  if ( i < v44 )
  {
    do
    {
      gMobileMenu.MAP_AREA_X = gMobileMenu.MAP_AREA_X + 1.0;
      worldPt = *(CVector2D *)&gMobileMenu.MAP_AREA_X;
      CRadar::TransformRealWorldPointToRadarSpace(x, &worldPt);
      CRadar::LimitRadarPoint(x);
      CRadar::TransformRadarPointToScreenSpace(&y, x);
    }
    while ( y.x < v44 );
  }
  v45 = (float)(v9 | 4);
  for ( j = y.y; y.y < v45; j = y.y )
  {
    gMobileMenu.MAP_AREA_Y = gMobileMenu.MAP_AREA_Y + -1.0;
    worldPt = *(CVector2D *)&gMobileMenu.MAP_AREA_X;
    CRadar::TransformRealWorldPointToRadarSpace(x, &worldPt);
    CRadar::LimitRadarPoint(x);
    CRadar::TransformRadarPointToScreenSpace(&y, x);
  }
  v47 = (float)(v10 - 4);
  if ( j > v47 )
  {
    do
    {
      gMobileMenu.MAP_AREA_Y = gMobileMenu.MAP_AREA_Y + 1.0;
      worldPt = *(CVector2D *)&gMobileMenu.MAP_AREA_X;
      CRadar::TransformRealWorldPointToRadarSpace(x, &worldPt);
      CRadar::LimitRadarPoint(x);
      CRadar::TransformRadarPointToScreenSpace(&y, x);
    }
    while ( y.y > v47 );
  }
LABEL_63:
  v2.n64_u32[0] = 1.0;
  if ( v37 < 1.0 || LIB_PointerGetWheel(0) < 0.0 || CHID::IsPressed(HID_MAPPING_MAP_ZOOM_IN, 0) )
  {
    if ( v37 == 1.0 )
      v48 = gMobileMenu.NEW_MAP_SCALE + (float)((float)(deltaTime * -7.0) * 100.0);
    else
      v48 = v37 * gMobileMenu.NEW_MAP_SCALE;
    gMobileMenu.NEW_MAP_SCALE = v48;
    v49 = LIB_PointerGetWheel(0);
    v50 = gMobileMenu.NEW_MAP_SCALE;
    if ( v49 < 0.0 )
    {
      v50 = gMobileMenu.NEW_MAP_SCALE + -21.0;
      gMobileMenu.NEW_MAP_SCALE = gMobileMenu.NEW_MAP_SCALE + -21.0;
    }
    if ( v50 < 300.0 )
    {
      v50 = 300.0;
      gMobileMenu.NEW_MAP_SCALE = 300.0;
    }
    gMobileMenu.MAP_OFFSET_X = gMobileMenu.MAP_OFFSET_X - (float)((float)(v34 * v50) - v24);
    gMobileMenu.MAP_OFFSET_Y = gMobileMenu.MAP_OFFSET_Y - (float)((float)(v33 * v50) - v23);
  }
  worldPt = *(CVector2D *)&gMobileMenu.MAP_AREA_X;
  CRadar::TransformRealWorldPointToRadarSpace(x, &worldPt);
  CRadar::LimitRadarPoint(x);
  CRadar::TransformRadarPointToScreenSpace(&y, x);
  LOWORD(v51) = -128;
  v87 = v7;
  if ( UpHeld() || ScrollUpHeld() )
    LOWORD(v52) = -128;
  else
    LOWORD(v52) = 0;
  if ( DownHeld() )
  {
    LOWORD(v52) = 128;
  }
  else if ( ScrollDownHeld() )
  {
    LOWORD(v52) = 128;
  }
  if ( !LeftHeld() && !ScrollLeftHeld() )
    LOWORD(v51) = 0;
  if ( RightHeld() )
  {
    LOWORD(v51) = 128;
  }
  else if ( ScrollRightHeld() )
  {
    LOWORD(v51) = 128;
  }
  pfValueOut = 0.0;
  if ( CHID::Implements(HID_MAPPING_PED_MOVE_X) && CHID::IsPressed(HID_MAPPING_PED_MOVE_X, &pfValueOut) )
    v51 = (int)(float)(pfValueOut * 128.0);
  if ( CHID::Implements(HID_MAPPING_PED_MOVE_Y) && CHID::IsPressed(HID_MAPPING_PED_MOVE_Y, &pfValueOut) )
    v52 = (int)(float)(pfValueOut * 128.0);
  if ( (__int16)v51 >= 1 )
  {
    gMobileMenu.MAP_OFFSET_X = gMobileMenu.MAP_OFFSET_X
                             + (float)((float)((float)((float)(__int16)v51 * -0.0078125) * 300.0) * deltaTime);
    worldPt = *(CVector2D *)&gMobileMenu.MAP_AREA_X;
    CRadar::TransformRealWorldPointToRadarSpace(x, &worldPt);
    CRadar::LimitRadarPoint(x);
    CRadar::TransformRadarPointToScreenSpace(&y, x);
    if ( (float)(MAP_OFFSET_X + v20) <= (float)v88 || y.x >= 320.0 )
      goto LABEL_103;
    do
    {
      gMobileMenu.MAP_AREA_X = gMobileMenu.MAP_AREA_X + 1.0;
      worldPt = *(CVector2D *)&gMobileMenu.MAP_AREA_X;
      CRadar::TransformRealWorldPointToRadarSpace(x, &worldPt);
      CRadar::LimitRadarPoint(x);
      CRadar::TransformRadarPointToScreenSpace(&y, x);
    }
    while ( y.x < 320.0 );
  }
  if ( (__int16)v51 <= -1 )
  {
    gMobileMenu.MAP_OFFSET_X = (float)((float)((float)((float)-(__int16)v51 * 0.0078125) * 300.0) * deltaTime)
                             + gMobileMenu.MAP_OFFSET_X;
    worldPt = *(CVector2D *)&gMobileMenu.MAP_AREA_X;
    CRadar::TransformRealWorldPointToRadarSpace(x, &worldPt);
    CRadar::LimitRadarPoint(x);
    CRadar::TransformRadarPointToScreenSpace(&y, x);
    if ( (float)(MAP_OFFSET_X - NEW_MAP_SCALE) < (float)v87 )
    {
      while ( y.x > 320.0 )
      {
        gMobileMenu.MAP_AREA_X = gMobileMenu.MAP_AREA_X + -1.0;
        worldPt = *(CVector2D *)&gMobileMenu.MAP_AREA_X;
        CRadar::TransformRealWorldPointToRadarSpace(x, &worldPt);
        CRadar::LimitRadarPoint(x);
        CRadar::TransformRadarPointToScreenSpace(&y, x);
      }
    }
  }
LABEL_103:
  if ( (__int16)v52 >= 1 )
  {
    gMobileMenu.MAP_OFFSET_Y = gMobileMenu.MAP_OFFSET_Y
                             + (float)((float)((float)((float)(__int16)v52 * -0.0078125) * 300.0) * deltaTime);
    worldPt = *(CVector2D *)&gMobileMenu.MAP_AREA_X;
    CRadar::TransformRealWorldPointToRadarSpace(x, &worldPt);
    CRadar::LimitRadarPoint(x);
    CRadar::TransformRadarPointToScreenSpace(&y, x);
    if ( (float)(MAP_OFFSET_Y + NEW_MAP_SCALE) <= (float)v10 || y.y >= 224.0 )
      goto LABEL_111;
    do
    {
      gMobileMenu.MAP_AREA_Y = gMobileMenu.MAP_AREA_Y + -1.0;
      worldPt = *(CVector2D *)&gMobileMenu.MAP_AREA_X;
      CRadar::TransformRealWorldPointToRadarSpace(x, &worldPt);
      CRadar::LimitRadarPoint(x);
      CRadar::TransformRadarPointToScreenSpace(&y, x);
    }
    while ( y.y < 224.0 );
  }
  if ( (__int16)v52 <= -1 )
  {
    gMobileMenu.MAP_OFFSET_Y = (float)((float)((float)((float)-(__int16)v52 * 0.0078125) * 300.0) * deltaTime)
                             + gMobileMenu.MAP_OFFSET_Y;
    worldPt = *(CVector2D *)&gMobileMenu.MAP_AREA_X;
    CRadar::TransformRealWorldPointToRadarSpace(x, &worldPt);
    CRadar::LimitRadarPoint(x);
    CRadar::TransformRadarPointToScreenSpace(&y, x);
    if ( (float)(MAP_OFFSET_Y - NEW_MAP_SCALE) < (float)v9 )
    {
      while ( y.y > 224.0 )
      {
        gMobileMenu.MAP_AREA_Y = gMobileMenu.MAP_AREA_Y + 1.0;
        worldPt = *(CVector2D *)&gMobileMenu.MAP_AREA_X;
        CRadar::TransformRealWorldPointToRadarSpace(x, &worldPt);
        CRadar::LimitRadarPoint(x);
        CRadar::TransformRadarPointToScreenSpace(&y, x);
      }
    }
  }
LABEL_111:
  v53 = `guard variable for'Menu_MapUpdate(float)::curTouch;
  __dmb(0xBu);
  if ( (v53 & 1) == 0 && _cxa_guard_acquire((__guard *)&`guard variable for'Menu_MapUpdate(float)::curTouch) )
  {
    Menu_MapUpdate(float)::curTouch.x = 0.0;
    Menu_MapUpdate(float)::curTouch.y = 0.0;
    _cxa_guard_release((__guard *)&`guard variable for'Menu_MapUpdate(float)::curTouch);
  }
  worldPt.x = 0.0;
  worldPt.y = 0.0;
  if ( CTouchInterface::IsTouched(WIDGET_MAP, &worldPt, 2) && (int)CTouchInterface::GetNumTouches() <= 1 )
  {
    v54 = 448.0 / (float)RsGlobal.screenHeight;
    v55 = worldPt.x * v54;
    v56 = worldPt.y * v54;
    Menu_MapUpdate(float)::curTouch.x = v55;
    Menu_MapUpdate(float)::curTouch.y = v56;
  }
  else
  {
    v1.n64_f32[0] = deltaTime * 4.0;
    v57 = 1.0 - vmin_f32(v1, v2).n64_f32[0];
    v55 = v57 * Menu_MapUpdate(float)::curTouch.x;
    v56 = v57 * Menu_MapUpdate(float)::curTouch.y;
    Menu_MapUpdate(float)::curTouch.x = v55;
    Menu_MapUpdate(float)::curTouch.y = v56;
    if ( v55 != 0.0 )
    {
      v59 = v86;
      v58 = v9;
      if ( sqrtf((float)(v55 * v55) + (float)(v56 * v56)) < 0.01 )
      {
        v56 = 0.0;
        v55 = 0.0;
        Menu_MapUpdate(float)::curTouch.x = 0.0;
        Menu_MapUpdate(float)::curTouch.y = 0.0;
      }
      goto LABEL_121;
    }
  }
  v59 = v86;
  v58 = v9;
LABEL_121:
  v60 = v55 + gMobileMenu.MAP_OFFSET_X;
  v61 = gMobileMenu.NEW_MAP_SCALE;
  v62 = v56 + gMobileMenu.MAP_OFFSET_Y;
  v63 = gMobileMenu.NEW_MAP_SCALE;
  v64 = v60 - gMobileMenu.NEW_MAP_SCALE;
  gMobileMenu.MAP_OFFSET_X = v60;
  gMobileMenu.MAP_OFFSET_Y = v62;
  if ( (float)((float)RsGlobal.screenWidth / (float)RsGlobal.screenHeight) <= 1.8 )
    v63 = (float)(gMobileMenu.NEW_MAP_SCALE * (float)RsGlobal.screenWidth) / (float)RsGlobal.screenHeight;
  v65 = v60 + v63;
  v66 = (float)v87;
  v67 = (float)v88;
  if ( (int)(float)((float)v87 - v64) + (int)(float)((float)(v60 + v63) - (float)v88) <= -1 )
    gMobileMenu.NEW_MAP_SCALE = gMobileMenu.NEW_MAP_SCALE
                              - (float)((int)(float)((float)v87 - v64) + (int)(float)((float)(v60 + v63) - (float)v88));
  if ( v64 > v66 )
  {
    v60 = v60 - (float)(v64 - v66);
    gMobileMenu.MAP_OFFSET_X = v60;
  }
  v68 = v62 - v61;
  if ( v65 < v67 )
    gMobileMenu.MAP_OFFSET_X = (float)(v67 - v65) + v60;
  v69 = v62 + v61;
  v70 = (float)v58;
  if ( v68 > (float)v58 )
  {
    v62 = v62 - (float)(v68 - v70);
    gMobileMenu.MAP_OFFSET_Y = v62;
  }
  v71 = (float)v10;
  if ( v69 < (float)v10 )
    gMobileMenu.MAP_OFFSET_Y = (float)(v71 - v69) + v62;
  v72 = 1161527296;
  if ( gMobileMenu.MAP_AREA_X > 3000.0 || (v72 = -985956352, gMobileMenu.MAP_AREA_X < -3000.0) )
    LODWORD(gMobileMenu.MAP_AREA_X) = v72;
  v73 = 1161527296;
  if ( gMobileMenu.MAP_AREA_Y > 3000.0 || (v73 = -985956352, gMobileMenu.MAP_AREA_Y < -3000.0) )
    LODWORD(gMobileMenu.MAP_AREA_Y) = v73;
  if ( CTimer::m_snTimeInMillisecondsPauseMode - Menu_MapUpdate(float)::LastMapPress >= 0x15 )
    Menu_MapUpdate(float)::LastMapPress = CTimer::m_snTimeInMillisecondsPauseMode;
  PlaceRedMarker(v59);
  v74 = 0;
  v75 = gMobileMenu.NEW_MAP_SCALE / 6.0;
  v76 = gMobileMenu.MAP_OFFSET_X - gMobileMenu.NEW_MAP_SCALE;
  gMobileMenu.DisplayingMap = 0;
  v77 = gMobileMenu.MAP_OFFSET_Y - gMobileMenu.NEW_MAP_SCALE;
  do
  {
    v78 = v74 + 1;
    for ( k = 0; k != 12; ++k )
    {
      while ( 1 )
      {
        v80 = CHID::GetInputType();
        v81 = (float)RsGlobal.screenWidth / (float)RsGlobal.screenHeight;
        v82 = 3.0;
        if ( v80 == 1 )
          v82 = 10.0;
        if ( v81 > 1.8 )
          v82 = 5.0;
        v83 = v75 * v82;
        v84 = 0.0;
        if ( v81 > 1.8 )
          v84 = (double)RsGlobal.screenHeight * 0.05;
        if ( (float)(v66 - v83) - v84 >= (float)(v76 + (float)(v75 * (float)(unsigned __int8)v74)) )
          break;
        if ( (float)(v77 + (float)(v75 * (float)(unsigned __int8)k)) <= (float)(v70 - v83) )
          break;
        if ( v84 + (float)(v83 + v67) <= (float)(v76 + (float)(v75 * (float)(v74 + 1))) )
          break;
        v85 = k + 1;
        if ( (float)(v77 + (float)(v75 * (float)(k + 1))) >= (float)(v83 + v71) )
          break;
        CRadar::RequestMapSection(v74, k++);
        if ( v85 == 12 )
          goto LABEL_156;
      }
      CRadar::RemoveMapSection(v74, k);
    }
LABEL_156:
    ++v74;
  }
  while ( v78 != 12 );
  TextureDatabaseRuntime::UpdateStreaming(deltaTime + deltaTime, !gMobileMenu.isMapMode);
}
// 2AA7D8: variable 'v1' is possibly undefined
// 2AA7D8: variable 'v2' is possibly undefined
// 6E03DC: using guessed type char `guard variable for'Menu_MapUpdate(float)::fTime;
// 6E03E8: using guessed type char Menu_MapUpdate(float)::bZoomStarted;
// 6E03F8: using guessed type char `guard variable for'Menu_MapUpdate(float)::curTouch;

//----- (002AAD00) --------------------------------------------------------
void Menu_MapRender()
{
  float32x2_t v0; // d0
  float32x2_t v1; // d1
  float NEW_MAP_SCALE; // s16
  float v3; // s20
  float v4; // s18
  __int64 v5; // r4
  RwInt32 screenHeight; // r1
  RwInt32 screenWidth; // r2
  float v8; // s26
  float v9; // s22
  int v10; // r10
  float MAP_OFFSET_X; // s24
  float MAP_OFFSET_Y; // s16
  float v13; // s2
  float v14; // s24
  bool8 (*v15)[10]; // r8
  float v16; // s18
  float v17; // s20
  float v18; // s28
  int v19; // s0
  int v20; // r10
  float v21; // s30
  int v22; // r11
  float v23; // s0
  float v24; // s23
  float v25; // s0
  float v26; // s2
  float v27; // s19
  float v28; // s21
  float v29; // s25
  float v30; // s31
  float v31; // s23
  float v32; // s27
  float v33; // s25
  int32 v34; // r9
  float v35; // s26
  float v36; // s0
  float v37; // s0
  float v38; // s2
  float v39; // s0
  float v40; // s24
  float v41; // s22
  int v42; // r4
  int32 i; // r5
  float v44; // s4
  float v45; // s0
  float v46; // s2
  float v47; // s6
  float v48; // s10
  float v49; // s4
  float v50; // r0
  GxtChar *v51; // r9
  const CRGBA *v52; // r0
  CRGBA v53; // r0
  CRGBA v54; // r0
  unsigned __int64 v55; // r0
  RwInt32 v56; // r0
  CRGBA v57; // r0
  CRGBA v58; // r0
  double v59; // d18
  float v60; // s0
  double v61; // d16
  signed int v62; // r9
  float v63; // s4
  double v64; // d17
  int v65; // r6
  double v66; // d16
  Int32 v67; // r10
  Int32 v68; // r5
  float v69; // s27
  GxtChar *v70; // r4
  const char *v71; // r1
  float StringWidth; // r0
  RwInt32 v73; // r1
  double v74; // d18
  float v75; // s2
  double v76; // d16
  float32x4_t v77; // q5
  float32x4_t v78; // q9
  float32x4_t v79; // q1
  int v80; // [sp+28h] [bp-A0h]
  CRGBA v81; // [sp+30h] [bp-98h] BYREF
  CRGBA v82; // [sp+34h] [bp-94h] BYREF
  CRGBA v83; // [sp+38h] [bp-90h] BYREF
  CRGBA v84; // [sp+3Ch] [bp-8Ch] BYREF
  CRGBA v85; // [sp+40h] [bp-88h] BYREF
  CRGBA v86; // [sp+44h] [bp-84h] BYREF
  CRGBA v87; // [sp+48h] [bp-80h] BYREF
  CRGBA v88; // [sp+4Ch] [bp-7Ch] BYREF
  CRect Rect; // [sp+50h] [bp-78h] BYREF
  CRect v90; // 0:r2.8,8:^0.8

  gMobileMenu.DisplayingMap = 1;
  CRadar::InitFrontEndMap();
  NEW_MAP_SCALE = gMobileMenu.NEW_MAP_SCALE;
  v3 = gMobileMenu.NEW_MAP_SCALE;
  v4 = gMobileMenu.NEW_MAP_SCALE / 5.0;
  v5 = *(_QWORD *)&RsGlobal.screenWidth;
  screenHeight = RsGlobal.screenHeight;
  screenWidth = RsGlobal.screenWidth;
  if ( CTouchInterface::m_pWidgets[150] )
  {
    Rect.bottom = 0.0;
    Rect.left = 0.0;
    Rect.right = (float)RsGlobal.screenWidth;
    Rect.top = (float)RsGlobal.screenHeight;
    CWidget::SetScreenRect(CTouchInterface::m_pWidgets[150], &Rect);
    screenHeight = RsGlobal.screenHeight;
    screenWidth = RsGlobal.screenWidth;
    v3 = gMobileMenu.NEW_MAP_SCALE;
  }
  v8 = (float)screenHeight;
  v9 = NEW_MAP_SCALE / 6.0;
  v10 = 0;
  Rect.bottom = 0.0;
  Rect.left = 0.0;
  MAP_OFFSET_X = gMobileMenu.MAP_OFFSET_X;
  MAP_OFFSET_Y = gMobileMenu.MAP_OFFSET_Y;
  Rect.right = (float)screenWidth;
  Rect.top = (float)screenHeight;
  CRGBA::CRGBA(&v88, 0, 0, 0, 0xFFu);
  CSprite2d::DrawRect(&Rect, &v88);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 2);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
  emu_glEnable(0xBE2u);
  v13 = MAP_OFFSET_X - v3;
  v14 = v4 / 448.0;
  v15 = CTheZones::ZonesVisited;
  v16 = (float)((float)(MAP_OFFSET_Y - v3) / 448.0) * v8;
  v17 = (float)(v13 / 448.0) * v8;
  do
  {
    v18 = (float)v10;
    v80 = v10 + 1;
    v19 = v10 + 1;
    v20 = 0;
    v21 = (float)v19;
    do
    {
      CRGBA::CRGBA(&v88, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
      CRGBA::CRGBA(&v87, 0, 0, 0, 0xFFu);
      v22 = v20 + 1;
      v23 = (float)RsGlobal.screenHeight;
      if ( (*v15)[v20] )
      {
        v24 = v14 * v23;
        v25 = (float)(v14 * v23) * (float)(v20 + 1);
        v26 = v24 * (float)v20;
        v27 = v17 + (float)(v24 * v21);
        v28 = v17 + (float)(v24 * v18);
        Rect.bottom = v16 + v26;
        Rect.left = v28;
        Rect.right = v27;
        Rect.top = v16 + v25;
        CSprite2d::DrawRect(&Rect, &v88);
        v29 = v24 * 0.125;
        Rect.right = v28;
        Rect.top = v16 + v26;
        v30 = (float)(v16 + v26) - (float)(v24 * 0.125);
        v31 = v28 - (float)(v24 * 0.125);
        Rect.bottom = v30;
        Rect.left = v31;
        CSprite2d::DrawRect(&Rect, &v87, &v88, &v87, &v87);
        Rect.bottom = v30;
        Rect.left = v28;
        Rect.right = v27;
        Rect.top = v16 + v26;
        CSprite2d::DrawRect(&Rect, &v88, &v88, &v87, &v87);
        v32 = v29 + v27;
        Rect.bottom = v30;
        Rect.left = v29 + v27;
        Rect.right = v27;
        Rect.top = v16 + v26;
        CSprite2d::DrawRect(&Rect, &v87, &v88, &v87, &v87);
        Rect.bottom = v16 + v26;
        Rect.left = v31;
        Rect.right = v28;
        Rect.top = v16 + v25;
        CSprite2d::DrawRect(&Rect, &v87, &v88, &v87, &v88);
        Rect.bottom = v16 + v26;
        Rect.left = v27;
        Rect.right = v29 + v27;
        Rect.top = v16 + v25;
        CSprite2d::DrawRect(&Rect, &v88, &v87, &v88, &v87);
        v33 = v29 + (float)(v16 + v25);
        Rect.bottom = v16 + v25;
        Rect.left = v28;
        Rect.right = v31;
        Rect.top = v33;
        CSprite2d::DrawRect(&Rect, &v87, &v87, &v88, &v87);
        Rect.bottom = v16 + v25;
        Rect.left = v28;
        Rect.right = v27;
        Rect.top = v33;
        CSprite2d::DrawRect(&Rect, &v87, &v87, &v88, &v88);
        Rect.bottom = v16 + v25;
        Rect.left = v27;
        Rect.right = v32;
        Rect.top = v33;
        CSprite2d::DrawRect(&Rect, &v87, &v87, &v88, &v87);
      }
      ++v20;
    }
    while ( v22 != 10 );
    v10 = v80;
    ++v15;
  }
  while ( v80 != 10 );
  RwRenderStateSet(rwRENDERSTATESRCBLEND, byte_9);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 1);
  v34 = 0;
  Rect.left = 0.0;
  Rect.bottom = 0.0;
  Rect.right = (float)RsGlobal.screenWidth;
  Rect.top = (float)RsGlobal.screenHeight;
  CRGBA::CRGBA(&v88, 0x60u, 0x60u, 0x60u, 0xFFu);
  CSprite2d::DrawRect(&Rect, &v88);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, (char *)&dword_0 + 2);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 2);
  Rect.left = 0.0;
  Rect.bottom = 0.0;
  Rect.right = (float)RsGlobal.screenWidth;
  Rect.top = (float)RsGlobal.screenHeight;
  CRGBA::CRGBA(&v88, 0xA0u, 0xA0u, 0xA0u, 0xFFu);
  CSprite2d::DrawRect(&Rect, &v88);
  RwRenderStateSet(rwRENDERSTATESRCBLEND, byte_9);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, (char *)&dword_0 + 1);
  v35 = v9 / 448.0;
  Rect.left = 0.0;
  Rect.bottom = v16;
  Rect.right = v17;
  Rect.top = v16 + (float)((float)((float)(v9 / 448.0) * (float)RsGlobal.screenHeight) * 12.0);
  CRGBA::CRGBA(&v88, 0x6Fu, 0x89u, 0xAAu, 0xFFu);
  CSprite2d::DrawRect(&Rect, &v88);
  Rect.bottom = v16;
  v36 = (float)(v9 / 448.0) * (float)RsGlobal.screenHeight;
  Rect.left = v17 + (float)(v36 * 12.0);
  Rect.right = v17 + (float)(v36 * 24.0);
  Rect.top = v16 + (float)(v36 * 12.0);
  CRGBA::CRGBA(&v88, 0x6Fu, 0x89u, 0xAAu, 0xFFu);
  CSprite2d::DrawRect(&Rect, &v88);
  Rect.left = 0.0;
  Rect.bottom = 0.0;
  Rect.top = v16;
  Rect.right = v17 + (float)((float)((float)(v9 / 448.0) * (float)RsGlobal.screenHeight) * 24.0);
  CRGBA::CRGBA(&v88, 0x6Fu, 0x89u, 0xAAu, 0xFFu);
  CSprite2d::DrawRect(&Rect, &v88);
  Rect.left = 0.0;
  v37 = (float)(v9 / 448.0) * (float)RsGlobal.screenHeight;
  v38 = v37 * 12.0;
  v39 = v37 * 24.0;
  Rect.bottom = v16 + v38;
  Rect.right = v17 + v39;
  Rect.top = v16 + v39;
  CRGBA::CRGBA(&v88, 0x6Fu, 0x89u, 0xAAu, 0xFFu);
  CSprite2d::DrawRect(&Rect, &v88);
  v40 = (float)SHIDWORD(v5);
  v41 = (float)(int)v5;
  do
  {
    v42 = v34 + 1;
    for ( i = 0; i != 12; ++i )
    {
      v44 = v35 * (float)RsGlobal.screenHeight;
      v45 = v17 + (float)(v44 * (float)v34);
      if ( v45 > (float)(0.0 - v44) )
      {
        v46 = v16 + (float)(v44 * (float)i);
        if ( v46 > (float)(0.0 - v44) )
        {
          v47 = v17 + (float)(v44 * (float)(v34 + 1));
          if ( v47 < (float)(v44 + v41) )
          {
            v48 = v44 + v40;
            v49 = v16 + (float)(v44 * (float)(i + 1));
            if ( v49 < v48 )
            {
              *(_QWORD *)&v90.left = __PAIR64__(LODWORD(v49), LODWORD(v45));
              *(_QWORD *)&v90.right = __PAIR64__(LODWORD(v46), LODWORD(v47));
              CRadar::DrawRadarSectionMap(v34, i, v90, 1.0);
            }
          }
        }
      }
    }
    ++v34;
  }
  while ( v42 != 12 );
  RwRenderStateSet(rwRENDERSTATESRCBLEND, &byte_5);
  RwRenderStateSet(rwRENDERSTATEDESTBLEND, &byte_6);
  CRadar::DrawRadarGangOverlay(1);
  if ( !((CTheScripts::HideAllFrontEndMapBlips | CTheScripts::bPlayerIsOffTheMap) << 24) )
  {
    v50 = fmodf(mapScroll, 1.0);
    CRadar::DrawBlips(v50);
  }
  v51 = CPlaceName::GetForMap(&CUserDisplay::PlaceName, gMobileMenu.MAP_AREA_X, gMobileMenu.MAP_AREA_Y);
  Rect.left = 0.0;
  Rect.right = (float)RsGlobal.screenWidth;
  Rect.top = (float)RsGlobal.screenHeight;
  Rect.bottom = (float)RsGlobal.screenHeight * 0.7;
  CRGBA::CRGBA(&v88, 0, 0, 0, (unsigned int)(float)(mapModeOpacity * 255.0));
  CRGBA::CRGBA(&v87, 0, 0, 0, (unsigned int)(float)(mapModeOpacity * 255.0));
  CRGBA::CRGBA(&v86, 0, 0, 0, 0);
  CRGBA::CRGBA(&v85, 0, 0, 0, 0);
  CSprite2d::DrawRect(&Rect, &v88, &v87, &v86, v52);
  if ( (gMobileMenu.isMouse || gMobileMenu.pointerState[lastDevice] == OSPS_ButtonDown)
    && (CTheZones::ZonesRevealed > 0x4F
     || CTheZones::GetCurrentZoneLockedOrUnlocked(gMobileMenu.MAP_AREA_X, gMobileMenu.MAP_AREA_Y)) )
  {
    CFont::SetFontStyle(3u);
    CFont::SetWrapx(640.0);
    CRGBA::CRGBA(&v84, 0, 0, 0, 0xFFu);
    CFont::SetDropColor(v53);
    CFont::SetScale((float)RsGlobal.screenHeight * 0.0017857);
    CRGBA::CRGBA(&v83, 0xF0u, 0xF0u, 0xF0u, 0xFFu);
    CFont::SetColor(v54);
    CFont::SetEdge(2);
    CFont::SetOrientation(2u);
    v1.n64_f32[0] = v41 + (float)((float)RsGlobal.screenHeight * -0.040179);
    v0.n64_f32[0] = (float)RsGlobal.screenWidth + (float)((float)RsGlobal.screenWidth * -0.0);
    v55 = __PAIR64__(v40 + (float)((float)RsGlobal.screenHeight * -0.20089), vmin_f32(v1, v0).n64_u32[0]);
    CFont::PrintString(*(float *)&v55, *((float *)&v55 + 1), v51);
  }
  v56 = RsGlobal.screenWidth;
  if ( mapModeOpacity != 0.0 )
  {
    CFont::SetWrapx((float)(RsGlobal.screenWidth - 40));
    CFont::SetRightJustifyWrap(84.0);
    CFont::SetDropShadowPosition(1);
    CRGBA::CRGBA(&v82, 0, 0, 0, (unsigned int)(float)(mapModeOpacity * 255.0));
    CFont::SetDropColor(v57);
    CFont::SetOrientation(1u);
    CFont::SetFontStyle(2u);
    CFont::SetScale((float)RsGlobal.screenHeight * 0.0012277);
    CRGBA::CRGBA(&v81, 0xACu, 0xCBu, 0xF1u, (unsigned int)(float)(mapModeOpacity * 255.0));
    CFont::SetColor(v58);
    v56 = RsGlobal.screenWidth;
    v59 = 0.0;
    v60 = (float)RsGlobal.screenHeight;
    v61 = (double)RsGlobal.screenHeight;
    v62 = 4;
    v63 = (float)RsGlobal.screenWidth / (float)RsGlobal.screenHeight;
    v64 = 0.0;
    if ( v63 > 1.8 )
      v59 = v61 * 0.05;
    if ( v63 > 1.8 )
      v64 = (double)RsGlobal.screenHeight * 0.05 + (double)RsGlobal.screenHeight * 0.05;
    if ( (unsigned int)CRadar::MapLegendCounter + 2 > 0xE )
      v62 = ((unsigned int)CRadar::MapLegendCounter + 2) / 3;
    if ( CRadar::MapLegendCounter )
    {
      v65 = 0;
      v66 = v61 - v59 + (float)((float)((float)RsGlobal.screenWidth / -640.0) * 16.0);
      if ( v64 < (float)(v60 * 0.022321) )
        v64 = (float)(v60 * 0.022321);
      v67 = (int)v64;
      if ( v66 > (float)(v60 * 0.96205) )
        v66 = (float)(v60 * 0.96205);
      do
      {
        v68 = (int)v66;
        v69 = (float)v67;
        while ( 1 )
        {
          v70 = 0;
          v71 = "LG_02";
          switch ( CRadar::MapLegendList[v65] )
          {
            case -5:
              v71 = "LG_56";
              goto LABEL_102;
            case -4:
              v71 = "LG_55";
              goto LABEL_102;
            case -3:
              v71 = "LG_54";
              goto LABEL_102;
            case -2:
              v71 = "LG_50";
              goto LABEL_102;
            case -1:
              v71 = "LG_49";
              goto LABEL_102;
            case 3:
              v71 = "LG_01";
              goto LABEL_102;
            case 5:
              goto LABEL_102;
            case 6:
              v71 = "LG_03";
              goto LABEL_102;
            case 7:
              v71 = "LG_04";
              goto LABEL_102;
            case 8:
              v71 = "LG_05";
              goto LABEL_102;
            case 9:
              v71 = "LG_06";
              goto LABEL_102;
            case 10:
              v71 = "LG_07";
              goto LABEL_102;
            case 11:
              v71 = "LG_66";
              goto LABEL_102;
            case 12:
              v71 = "LG_09";
              goto LABEL_102;
            case 13:
              v71 = "LG_10";
              goto LABEL_102;
            case 14:
              v71 = "LG_11";
              goto LABEL_102;
            case 15:
              v71 = "LG_12";
              goto LABEL_102;
            case 16:
              v71 = "LG_13";
              goto LABEL_102;
            case 17:
              v71 = "LG_67";
              goto LABEL_102;
            case 18:
              v71 = "LG_15";
              goto LABEL_102;
            case 19:
              v71 = "LG_16";
              goto LABEL_102;
            case 20:
              v71 = "LG_17";
              goto LABEL_102;
            case 21:
              v71 = "LG_18";
              goto LABEL_102;
            case 22:
              v71 = "LG_19";
              goto LABEL_102;
            case 23:
              v71 = "LG_20";
              goto LABEL_102;
            case 24:
              v71 = "LG_21";
              goto LABEL_102;
            case 25:
              v71 = "LG_22";
              goto LABEL_102;
            case 26:
              v71 = "LG_23";
              goto LABEL_102;
            case 27:
              v71 = "LG_24";
              goto LABEL_102;
            case 28:
              v71 = "LG_25";
              goto LABEL_102;
            case 29:
              v71 = "LG_26";
              goto LABEL_102;
            case 30:
              v71 = "LG_27";
              goto LABEL_102;
            case 31:
              v71 = "LG_28";
              goto LABEL_102;
            case 32:
              v71 = "LG_29";
              goto LABEL_102;
            case 33:
              v71 = "LG_30";
              goto LABEL_102;
            case 34:
              v71 = "LG_31";
              goto LABEL_102;
            case 35:
              v71 = "LG_32";
              goto LABEL_102;
            case 36:
              v71 = "LG_33";
              goto LABEL_102;
            case 37:
              v71 = "LG_63";
              goto LABEL_102;
            case 38:
              v71 = "LG_35";
              goto LABEL_102;
            case 39:
              v71 = "LG_36";
              goto LABEL_102;
            case 40:
              v71 = "LG_37";
              goto LABEL_102;
            case 41:
              v71 = "LG_64";
              goto LABEL_102;
            case 42:
              v71 = "LG_39";
              goto LABEL_102;
            case 43:
              v71 = "LG_40";
              goto LABEL_102;
            case 44:
              v71 = "LG_41";
              goto LABEL_102;
            case 45:
              v71 = "LG_42";
              goto LABEL_102;
            case 46:
              v71 = "LG_43";
              goto LABEL_102;
            case 47:
              v71 = "LG_44";
              goto LABEL_102;
            case 48:
              v71 = "LG_45";
              goto LABEL_102;
            case 49:
              v71 = "LG_46";
              goto LABEL_102;
            case 50:
              v71 = "LG_47";
              goto LABEL_102;
            case 51:
              v71 = "LG_48";
              goto LABEL_102;
            case 52:
              v71 = "LG_51";
              goto LABEL_102;
            case 53:
              v71 = "LG_52";
              goto LABEL_102;
            case 54:
              v71 = "LG_53";
              goto LABEL_102;
            case 55:
              v71 = "LG_57";
              goto LABEL_102;
            case 57:
              v71 = "LG_65";
              goto LABEL_102;
            case 58:
              v71 = "LG_58";
              goto LABEL_102;
            case 59:
              v71 = "LG_59";
              goto LABEL_102;
            case 60:
              v71 = "LG_60";
              goto LABEL_102;
            case 61:
              v71 = "LG_61";
              goto LABEL_102;
            case 62:
              v71 = "LG_62";
              goto LABEL_102;
            case 63:
              v71 = "LG_34";
LABEL_102:
              v70 = CText::Get(&TheText, (const unsigned __int8 *)v71);
              break;
            default:
              break;
          }
          CFont::SetScale((float)RsGlobal.screenHeight * 0.0012277);
          StringWidth = CFont::GetStringWidth(v70, 1u, 0, 0);
          v73 = RsGlobal.screenHeight;
          if ( StringWidth > (float)((float)RsGlobal.screenHeight * 0.27902) )
          {
            CFont::SetScale(
              (float)((float)((float)RsGlobal.screenHeight * 0.0012277) * (float)((float)RsGlobal.screenHeight * 0.27902))
            / StringWidth);
            v73 = RsGlobal.screenHeight;
          }
          CFont::PrintString(
            (float)((float)((float)RsGlobal.screenWidth / 640.0) * 20.0) + v69,
            (float)((float)((float)v73 / 448.0) * 3.0) + (float)v68,
            v70);
          CRadar::DrawLegend(v67, v68, CRadar::MapLegendList[v65++]);
          if ( !(v65 % v62) )
            break;
          v56 = RsGlobal.screenWidth;
          v68 = (int)(float)((float)v68 + (float)((float)((float)RsGlobal.screenWidth / -640.0) * 16.0));
          if ( v65 >= CRadar::MapLegendCounter )
            goto LABEL_113;
        }
        v74 = 0.0;
        v56 = RsGlobal.screenWidth;
        v75 = (float)RsGlobal.screenHeight;
        v76 = (double)RsGlobal.screenHeight;
        if ( (float)((float)RsGlobal.screenWidth / (float)RsGlobal.screenHeight) > 1.8 )
          v74 = v76 * 0.05;
        v66 = v76 - v74 + (float)((float)((float)RsGlobal.screenWidth / -640.0) * 16.0);
        v67 = (int)(float)((float)((float)RsGlobal.screenHeight * 0.33482) + v69);
        if ( v66 > (float)(v75 * 0.96205) )
          v66 = (float)(v75 * 0.96205);
      }
      while ( v65 < CRadar::MapLegendCounter );
    }
  }
LABEL_113:
  CFont::SetWrapx((float)(v56 - 10));
  CFont::SetRightJustifyWrap(10.0);
  CFont::RenderFontBuffer();
  if ( CHID::GetInputType() == 1 && gMobileMenu.isMapMode )
  {
    v77.n128_u64[0] = 0x3F800000C1700000LL;
    v77.n128_u64[1] = 0xBF80000041700000LL;
    v78.n128_u64[0] = 0x3F800000BF800000LL;
    v78.n128_u64[1] = 0xBF8000003F800000LL;
    v79.n128_f32[1] = (float)RsGlobal.screenHeight * 0.5;
    v79.n128_f32[0] = (float)RsGlobal.screenWidth * 0.5;
    v79.n128_f32[2] = v79.n128_f32[0];
    v79.n128_f32[3] = v79.n128_f32[1];
    Rect = (CRect)vaddq_f32(vaddq_f32(v79, v77), v78);
    CRGBA::CRGBA(&v88, 0, 0, 0, 0xFFu);
    CSprite2d::DrawRect(&Rect, &v88);
    v79.n128_f32[1] = (float)RsGlobal.screenHeight * 0.5;
    v79.n128_f32[0] = (float)RsGlobal.screenWidth * 0.5;
    v79.n128_f32[2] = v79.n128_f32[0];
    v79.n128_f32[3] = v79.n128_f32[1];
    Rect = (CRect)vaddq_f32(v79, v77);
    CRGBA::CRGBA(&v88, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
    CSprite2d::DrawRect(&Rect, &v88);
    v78.n128_f32[0] = -1.0;
    v78.n128_f32[1] = -1.0;
    v78.n128_f32[2] = -1.0;
    v78.n128_f32[3] = -1.0;
    v77.n128_u64[0] = 0x41700000BF800000LL;
    v77.n128_u64[1] = 0xC17000003F800000LL;
    v79.n128_f32[1] = (float)RsGlobal.screenHeight * 0.5;
    v79.n128_f32[0] = (float)RsGlobal.screenWidth * 0.5;
    v79.n128_f32[2] = v79.n128_f32[0];
    v79.n128_f32[3] = v79.n128_f32[1];
    Rect = (CRect)vaddq_f32(vaddq_f32(v79, v77), v78);
    CRGBA::CRGBA(&v88, 0, 0, 0, 0xFFu);
    CSprite2d::DrawRect(&Rect, &v88);
    v79.n128_f32[1] = (float)RsGlobal.screenHeight * 0.5;
    v79.n128_f32[0] = (float)RsGlobal.screenWidth * 0.5;
    v79.n128_f32[2] = v79.n128_f32[0];
    v79.n128_f32[3] = v79.n128_f32[1];
    Rect = (CRect)vaddq_f32(v79, v77);
    CRGBA::CRGBA(&v88, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
    CSprite2d::DrawRect(&Rect, &v88);
  }
  gMobileMenu.DisplayingMap = 0;
}
// 2AB3B6: variable 'v52' is possibly undefined
// 2AB420: variable 'v53' is possibly undefined
// 2AB454: variable 'v54' is possibly undefined
// 2AB49E: variable 'v1' is possibly undefined
// 2AB49E: variable 'v0' is possibly undefined
// 2AB514: variable 'v57' is possibly undefined
// 2AB564: variable 'v58' is possibly undefined
// 0: using guessed type int dword_0;
// 5: using guessed type char byte_5;
// 6: using guessed type char byte_6;
// 6C: using guessed type int dword_6C;

//----- (002ABEA4) --------------------------------------------------------
void MobileSettings::Initialize()
{
  const unsigned __int8 *v0; // r1
  MobileSettingType *p_type; // r0
  int v2; // r2
  MobileSettings::Setting *v3; // r5
  const unsigned __int8 *v4; // r4
  const unsigned __int8 **v5; // r4
  OSDeviceForm v6; // r0
  int32 v7; // r1
  int v8; // r4
  int32 v9; // r1
  int32 v10; // r2
  OSDeviceForm v11; // r0
  int32 v12; // r2
  OSDefinedDevice v13; // r0
  int32 v14; // r2
  int32 v15; // r1
  int32 v16; // r2
  int v17; // r0
  int i; // r0
  MobileSettings::Setting *v19; // r2

  v0 = defaultName;
  p_type = &setupValues[0].type;
  v2 = 0;
  do
  {
    v3 = &MobileSettings::settings[v2];
    v3->value = *(p_type - 3);
    v3->min = *(p_type - 2);
    v3->max = *(p_type - 1);
    v3->type = *p_type;
    v4 = (const unsigned __int8 *)*((_DWORD *)p_type + 1);
    if ( !v4 )
      v4 = v0;
    MobileSettings::settings[v2++].name = v4;
    v5 = (const unsigned __int8 **)*((_DWORD *)p_type + 2);
    p_type += 7;
    v3->visible = 1;
    if ( !v5 )
      v5 = defaultValues;
    v3->values = v5;
  }
  while ( v2 != 37 );
  switch ( OS_SystemChip() )
  {
    case OSDC_A3:
    case OSDC_A4:
      v9 = 0;
      v10 = 20;
      MobileSettings::settings[1].value = 0;
      goto LABEL_28;
    case OSDC_A5:
      v11 = OS_SystemForm();
      v12 = 80;
      MobileSettings::settings[1].value = 75;
      MobileSettings::settings[0].value = 1;
      if ( v11 == OSDF_Phone )
        v12 = 65;
      MobileSettings::settings[2].value = v12;
      MobileSettings::settings[5].value = 1;
      MobileSettings::settings[7].value = 1;
      break;
    case OSDC_A5X:
      MobileSettings::settings[1].value = 60;
      MobileSettings::settings[0].value = 2;
      MobileSettings::settings[2].value = 100;
      v9 = 1;
      goto LABEL_29;
    case OSDC_A6:
      v13 = OS_SystemDevice();
      v14 = 100;
      if ( v13 == OSDD_iPod5 )
        v14 = 75;
      v15 = 100;
      MobileSettings::settings[1].value = v14;
      v16 = 2;
      if ( v13 == OSDD_iPod5 )
        v16 = 1;
      MobileSettings::settings[0].value = v16;
      if ( v13 == OSDD_iPod5 )
        v15 = 65;
      MobileSettings::settings[2].value = v15;
      MobileSettings::settings[5].value = v16;
      MobileSettings::settings[7].value = v16;
      break;
    case OSDC_A6X:
      MobileSettings::settings[1].value = 80;
      MobileSettings::settings[0].value = 3;
      MobileSettings::settings[2].value = 100;
      v9 = 2;
      goto LABEL_29;
    case OSDC_A7:
    case OSDC_A8:
    case OSDC_A8X:
    case OSDC_A9:
    case OSDC_A9X:
    case OSDC_A10:
    case OSDC_UnknownApple:
      MobileSettings::settings[0].value = 3;
      v6 = OS_SystemForm();
      MobileSettings::settings[2].value = 100;
      v7 = 80;
      if ( v6 == OSDF_Phone )
        v7 = 100;
      MobileSettings::settings[1].value = v7;
      MobileSettings::settings[5].value = 2;
      MobileSettings::settings[7].value = 3;
      break;
    case OSDC_Tegra2:
      v8 = 16000;
      goto LABEL_31;
    case OSDC_Tegra3:
      v8 = 48000;
      MobileSettings::settings[1].value = 80;
      MobileSettings::settings[0].value = 2;
      MobileSettings::settings[2].value = 80;
      MobileSettings::settings[5].value = 1;
      MobileSettings::settings[7].value = 2;
      goto LABEL_32;
    case OSDC_Tegra4:
    case OSDC_TegraK1:
    case OSDC_TegraX1:
      v8 = 64000;
      MobileSettings::settings[1].value = 100;
      MobileSettings::settings[0].value = 2;
      MobileSettings::settings[2].value = 60;
      MobileSettings::settings[5].value = 2;
      MobileSettings::settings[7].value = 3;
      goto LABEL_32;
    case OSDC_AmazonFire:
      v10 = 55;
      MobileSettings::settings[1].value = 50;
      v9 = 1;
LABEL_28:
      MobileSettings::settings[0].value = v9;
      MobileSettings::settings[2].value = v10;
LABEL_29:
      MobileSettings::settings[5].value = v9;
      MobileSettings::settings[7].value = v9;
      break;
    case OSDC_UnknownAndroid:
      v8 = 32000;
LABEL_31:
      MobileSettings::settings[1].value = 70;
      MobileSettings::settings[0].value = 2;
      MobileSettings::settings[2].value = 55;
      MobileSettings::settings[5].value = 1;
LABEL_32:
      v17 = v8 / (OS_ScreenGetWidth() - 640);
      if ( v17 <= 0 )
        v17 = 0;
      if ( v17 >= 100 )
        v17 = 100;
      MobileSettings::settings[1].value = v17;
      break;
    default:
      break;
  }
  for ( i = 0; i != 37; ++i )
  {
    v19 = &MobileSettings::settings[i];
    v19->defaultValue = v19->value;
  }
}

//----- (002AC0F0) --------------------------------------------------------
void __fastcall MobileSettings::SaveToFile(u_native fid)
{
  int i; // r5
  unsigned __int8 pData[4]; // [sp+4h] [bp-14h] BYREF

  *(_DWORD *)pData = 37;
  CFileMgr::Write(fid, pData, 4);
  for ( i = 8; i != 1192; i += 32 )
    CFileMgr::Write(fid, (unsigned __int8 *)MobileSettings::settings + i, 4);
}

//----- (002AC130) --------------------------------------------------------
void MobileSettings::SetRendererDefaults()
{
  int i; // r0
  MobileSettings::Setting *v1; // r2

  if ( RQCaps[14] )
  {
    MobileSettings::settings[5].defaultValue = 0;
    MobileSettings::settings[0].defaultValue = 1;
    MobileSettings::settings[7].defaultValue = 1;
    if ( RQCaps[5] )
      MobileSettings::settings[30].defaultValue = 1;
  }
  else if ( OS_SystemChip() != OSDC_AmazonFire && (RQCaps[5] || RQCaps[4]) << 24 )
  {
    MobileSettings::settings[0].defaultValue = 1;
    MobileSettings::settings[5].defaultValue = 0;
  }
  if ( !MobileSettings::loaded )
  {
    for ( i = 0; i != 37; ++i )
    {
      v1 = &MobileSettings::settings[i];
      v1->value = v1->defaultValue;
    }
  }
}

//----- (002AC1DC) --------------------------------------------------------
void __fastcall MobileSettings::LoadFromFile(u_native fid)
{
  int v2; // r5
  bool *p_forceDefault; // r6
  int32 *p_value; // r4
  _BOOL4 v5; // t1
  int *v6; // r0
  int v7; // [sp+0h] [bp-20h] BYREF
  int buffer[7]; // [sp+4h] [bp-1Ch] BYREF

  buffer[0] = 0;
  MobileSettings::loaded = 1;
  OS_FileRead((OSFile)fid, buffer, 4);
  if ( buffer[0] >= 1 )
  {
    v2 = 0;
    p_forceDefault = &setupValues[0].forceDefault;
    p_value = &MobileSettings::settings[0].value;
    do
    {
      v7 = 0;
      OS_FileRead((OSFile)fid, &v7, 4);
      v5 = *p_forceDefault;
      p_forceDefault += 28;
      ++v2;
      v6 = &v7;
      if ( v5 )
        v6 = p_value + 1;
      *p_value = *v6;
      p_value += 8;
    }
    while ( v2 < buffer[0] );
  }
}
// 2AC1DC: using guessed type int buffer[7];

//----- (002AC260) --------------------------------------------------------
int MobileSettings::IsFreeAimMode()
{
  if ( MobileSettings::settings[6].value == 1 )
    return CGameLogic::IsCoopGameGoingOn() ^ 1;
  else
    return 0;
}

//----- (002AC284) --------------------------------------------------------
bool MobileSettings::IsLockOnMode()
{
  return !MobileSettings::settings[6].value || sub_193420();
}

//----- (002AC2A0) --------------------------------------------------------
void __fastcall CTapEffect::CTapEffect(CTapEffect *this, const unsigned __int8 *pszSprite, float a3, float a4)
{
  CSprite2d *v8; // r0
  CTapEffect *v9; // r3
  CTapEffect **p_m_pNext; // r5
  RwInt32 screenWidth; // s0
  RwInt32 screenHeight; // s2

  CSprite2d::CSprite2d(&this->m_Sprite);
  *(_QWORD *)&this->m_RectScreen.left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_RectScreen.right = 0x49742400C9742400LL;
  v9 = CTapEffect::m_pChainTail;
  this->m_pPrev = CTapEffect::m_pChainTail;
  this->m_pNext = 0;
  p_m_pNext = &v9->m_pNext;
  if ( !v9 )
    p_m_pNext = &CTapEffect::m_pChainHead;
  *p_m_pNext = this;
  screenWidth = RsGlobal.screenWidth;
  screenHeight = RsGlobal.screenHeight;
  CTapEffect::m_pChainTail = this;
  this->m_fScale = 0.0;
  this->m_fRate = 200.0;
  this->m_vecScreen.x = (float)(a3 / (float)screenWidth) * 640.0;
  this->m_vecScreen.y = (float)(a4 / (float)screenHeight) * 448.0;
  if ( pszSprite )
    CWidget::SetTextureStatic(v8, (unsigned __int8 *)pszSprite);
}
// 2AC33C: variable 'v8' is possibly undefined

//----- (002AC374) --------------------------------------------------------
void __fastcall CTapEffect::~CTapEffect(CTapEffect *this)
{
  CTapEffect **p_m_pNext; // r3
  __int64 v3; // r0

  p_m_pNext = &this->m_pPrev->m_pNext;
  if ( !this->m_pPrev )
    p_m_pNext = &CTapEffect::m_pChainHead;
  *p_m_pNext = this->m_pNext;
  v3 = *(_QWORD *)&this->m_pPrev;
  if ( !this->m_pNext )
    HIDWORD(v3) = &CTapEffect::m_pChainTail;
  *(_DWORD *)HIDWORD(v3) = v3;
  CSprite2d::~CSprite2d(&this->m_Sprite);
}

//----- (002AC3B8) --------------------------------------------------------
void __fastcall CTapEffect::Update(CTapEffect *this)
{
  float32x2_t v1; // d3
  float32x2_t v2; // d4
  double m_fRate; // d18
  float v5; // s0
  float x; // s2
  float y; // s4
  float v8; // s6
  float v9; // s2
  float v10; // s4
  CTapEffect **p_m_pNext; // r3
  __int64 v12; // r0

  v2.n64_u32[0] = 25.0;
  m_fRate = this->m_fRate;
  v1.n64_f32[0] = m_fRate + CWidget::m_fElapsedTime * -250.0;
  v5 = CWidget::m_fElapsedTime * m_fRate + this->m_fScale;
  x = this->m_vecScreen.x;
  y = this->m_vecScreen.y;
  this->m_fScale = v5;
  LODWORD(this->m_fRate) = vmax_f32(v1, v2).n64_u32[0];
  v8 = (float)RsGlobal.screenWidth / 640.0;
  v9 = x * v8;
  v10 = y * (float)((float)RsGlobal.screenHeight / 448.0);
  this->m_RectScreen.left = v9 - (float)(v8 * v5);
  this->m_RectScreen.right = v9 + (float)(v8 * v5);
  this->m_RectScreen.top = (float)(v8 * v5) + v10;
  this->m_RectScreen.bottom = v10 - (float)(v8 * v5);
  if ( this && v5 > 60.0 )
  {
    p_m_pNext = &this->m_pPrev->m_pNext;
    if ( !this->m_pPrev )
      p_m_pNext = &CTapEffect::m_pChainHead;
    *p_m_pNext = this->m_pNext;
    v12 = *(_QWORD *)&this->m_pPrev;
    if ( !this->m_pNext )
      HIDWORD(v12) = &CTapEffect::m_pChainTail;
    *(_DWORD *)HIDWORD(v12) = v12;
    CSprite2d::~CSprite2d(&this->m_Sprite);
    sub_191374(this);
  }
}
// 2AC400: variable 'v1' is possibly undefined
// 2AC400: variable 'v2' is possibly undefined

//----- (002AC4D4) --------------------------------------------------------
void __fastcall CTapEffect::Draw(CTapEffect *this)
{
  CSprite2d *p_m_Sprite; // r4
  float m_fScale; // s0
  unsigned int alpha; // r0
  CRGBA v5; // [sp+4h] [bp-14h] BYREF

  p_m_Sprite = &this->m_Sprite;
  if ( this->m_Sprite.mpTexture )
  {
    m_fScale = this->m_fScale;
    if ( m_fScale <= 30.0 )
      LOBYTE(alpha) = 0x80;
    else
      alpha = (unsigned int)(float)((float)((float)((float)(m_fScale + -30.0) / -30.0) + 1.0) * 128.0);
    CRGBA::CRGBA(&v5, 0xFFu, 0xFFu, 0xFFu, alpha);
    CSprite2d::Draw(p_m_Sprite, &this->m_RectScreen, &v5);
  }
}

//----- (002AC54C) --------------------------------------------------------
void CTapEffect::UpdateAll()
{
  CTapEffect *v0; // r0
  CTapEffect *m_pNext; // r4

  v0 = CTapEffect::m_pChainHead;
  if ( CTapEffect::m_pChainHead )
  {
    do
    {
      m_pNext = v0->m_pNext;
      CTapEffect::Update(v0);
      v0 = m_pNext;
    }
    while ( m_pNext );
  }
}

//----- (002AC570) --------------------------------------------------------
void CTapEffect::DrawAll()
{
  CTapEffect *i; // r6
  float m_fScale; // s0
  unsigned int alpha; // r0
  CRGBA v3; // [sp+4h] [bp-34h] BYREF

  for ( i = CTapEffect::m_pChainHead; i; i = i->m_pNext )
  {
    if ( i->m_Sprite.mpTexture )
    {
      m_fScale = i->m_fScale;
      if ( m_fScale <= 30.0 )
        LOBYTE(alpha) = 0x80;
      else
        alpha = (unsigned int)(float)((float)((float)((float)(m_fScale + -30.0) / -30.0) + 1.0) * 128.0);
      CRGBA::CRGBA(&v3, 0xFFu, 0xFFu, 0xFFu, alpha);
      CSprite2d::Draw(&i->m_Sprite, &i->m_RectScreen, &v3);
    }
  }
}

//----- (002AC600) --------------------------------------------------------
void InitProfileData()
{
  int v0; // r12
  int v1; // r2
  int v2; // r0
  stProfileData *v3; // r1
  int v4; // r2
  stProfileData *v5; // r1
  int v6; // r3
  int v7; // r3
  stProfileData::$89FFCF613E5C9ED492039769C679EDBD *p_anon_0; // r2
  int v9; // r4
  int i; // r0
  stProfileData *v11; // r3
  int v12; // r2
  stProfileData *v13; // r1
  int v14; // r4
  struct timeval v15; // [sp+0h] [bp-10h] BYREF

  if ( !firstStartTime )
  {
    gettimeofday(&v15, 0);
    firstStartTime = 1000 * v15.tv_sec;
  }
  v0 = baseID;
  ProfileData[0].type = TeleStat;
  ProfileData[0].id = baseID;
  ProfileData[2]._anon_0.lastValue = 0;
  ProfileData[0]._anon_0.lastValue = 0;
  ProfileData[1].type = TeleStat;
  ProfileData[1].id = baseID + 1;
  ProfileData[1]._anon_0.lastValue = 0;
  ProfileData[2].type = TeleStat;
  v1 = baseID + 3;
  ProfileData[2].id = baseID + 2;
  v2 = 0;
  do
  {
    v3 = &ProfileData[v2++];
    v3[3]._anon_0.lastValue = 0;
    v3[3].type = TeleMenu;
    v3[3].id = v1++;
  }
  while ( v2 != 27 );
  v4 = 30;
  v5 = &ProfileData[30];
  do
  {
    v6 = v0 + v4;
    v5->_anon_0.lastValue = 0;
    ++v4;
    v5->type = TeleSetting;
    v5->id = v6;
    ++v5;
  }
  while ( v4 != 63 );
  v7 = 0;
  p_anon_0 = &ProfileData[63]._anon_0;
  do
  {
    v9 = v0 + 63 + v7;
    p_anon_0->lastValue = 0;
    ++v7;
    p_anon_0[-3].lastValue = 2;
    p_anon_0[-2].lastValue = v9;
    p_anon_0 += 4;
  }
  while ( v7 != 82 );
  for ( i = 0; i != 38; ++i )
  {
    v11 = &ProfileData[i];
    v11[145].id = -1;
  }
  v12 = 0;
  v13 = &ProfileData[183];
  do
  {
    v14 = v0 + 145 + v12;
    v13->_anon_0.lastValue = 0;
    ++v12;
    v13->type = TeleStat;
    v13->id = v14;
    ++v13;
  }
  while ( v12 != 181 );
}

//----- (002AC73C) --------------------------------------------------------
void DoProfileStats()
{
  int v0; // r4
  int v1; // r9
  int i; // r11
  int TimesMissionAttempted; // r0
  int v4; // r0
  int v5; // r1
  unsigned __int8 *v6; // r2
  int v7; // r0
  int v8; // r1
  int v9; // r2
  unsigned __int8 *v10; // r3
  int id; // r1
  stProfileData *v12; // r0
  stProfileData::$89FFCF613E5C9ED492039769C679EDBD *v13; // r0
  int v14; // t1
  int v15; // r1
  int v16; // r2
  int v17; // r3
  unsigned __int8 *v18; // r6
  int v19; // r0
  stProfileData *v20; // r1
  stProfileData::$89FFCF613E5C9ED492039769C679EDBD *p_anon_0; // r1
  int lastValue; // t1
  int v23; // r2
  int v24; // r3
  unsigned __int8 *v25; // r6
  bool v26; // cc
  float StatValue; // s0
  stProfileData *v28; // r0
  float *p_lastValuef; // r0
  int v30; // r3
  int v31; // r1
  unsigned __int8 *v32; // r2

  if ( !IsProfileStatsBusy() )
  {
    v0 = 0;
    statValueLength = 0;
    while ( v0 )
    {
      if ( v0 == 1 )
      {
        if ( ProfileData[1]._anon_0.lastValue == CTimer::m_snTimeInMilliseconds / 0x3E8 )
          goto LABEL_3;
        v7 = CTimer::m_snTimeInMilliseconds / 0x3E8;
        id = ProfileData[1].id;
        v9 = statValueLength;
        ProfileData[1]._anon_0.lastValue = CTimer::m_snTimeInMilliseconds / 0x3E8;
        statValue[statValueLength] = HIBYTE(ProfileData[1].id);
        v10 = &statValue[v9];
        v10[1] = BYTE2(id);
        v10[2] = BYTE1(id);
        v10[3] = id;
        *((_WORD *)v10 + 2) = 4;
LABEL_17:
        v10[6] = BYTE2(v7);
        v10[7] = BYTE1(v7);
        v10[8] = v7;
        statValueLength = v9 + 9;
LABEL_3:
        ++v0;
      }
      else
      {
        if ( v0 == 2 )
        {
          v1 = 0;
          for ( i = 0; i != 100; ++i )
          {
            TimesMissionAttempted = CStats::GetTimesMissionAttempted(i);
            if ( TimesMissionAttempted == 255 )
              ++v1;
          }
          if ( v1 != ProfileData[2]._anon_0.lastValue )
          {
            v4 = ProfileData[2].id;
            v5 = statValueLength;
            ProfileData[2]._anon_0.lastValue = v1;
            statValue[statValueLength] = HIBYTE(ProfileData[2].id);
            v6 = &statValue[v5];
            v6[1] = BYTE2(v4);
            v6[2] = BYTE1(v4);
            v6[3] = v4;
            v6[4] = 4;
            v6[5] = HIBYTE(v1);
            v6[6] = BYTE2(v1);
            v6[7] = BYTE1(v1);
            v6[8] = v1;
            statValueLength = v5 + 9;
          }
        }
        else if ( v0 > 29 )
        {
          if ( v0 > 62 )
          {
            v26 = (unsigned int)(v0 - 63) > 0x52;
            if ( (unsigned int)(v0 - 63) >= 0x52 )
              v26 = (unsigned int)(v0 - 183) > 0xB4;
            if ( !v26 )
            {
              StatValue = CStats::GetStatValue(v0 - 63);
              v28 = &ProfileData[v0];
              if ( StatValue != v28->_anon_0.lastValuef )
              {
                p_lastValuef = &v28->_anon_0.lastValuef;
                v30 = ProfileData[v0].id;
                v31 = statValueLength;
                statValue[statValueLength] = HIBYTE(v30);
                v32 = &statValue[v31];
                v32[3] = v30;
                v32[1] = BYTE2(v30);
                v32[2] = BYTE1(v30);
                if ( v0 > 144 )
                  v32[4] = 4;
                else
                  v32[4] = 3;
                v32[8] = (int)StatValue;
                v32[5] = (unsigned int)(int)StatValue >> 24;
                v32[6] = (unsigned int)(int)StatValue >> 16;
                v32[7] = (unsigned __int16)(int)StatValue >> 8;
                statValueLength = v31 + 9;
                *p_lastValuef = StatValue;
              }
            }
          }
          else
          {
            v19 = *((_DWORD *)&MobileSettings::settings[v0 - 29] - 6);
            v20 = &ProfileData[v0];
            lastValue = v20->_anon_0.lastValue;
            p_anon_0 = &v20->_anon_0;
            if ( v19 != lastValue )
            {
              v23 = ProfileData[v0].id;
              v24 = statValueLength;
              statValue[statValueLength] = HIBYTE(v23);
              v25 = &statValue[v24];
              v25[3] = v23;
              v25[4] = 4;
              v25[5] = HIBYTE(v19);
              v25[6] = BYTE2(v19);
              v25[7] = BYTE1(v19);
              v25[8] = v19;
              v25[1] = BYTE2(v23);
              v25[2] = BYTE1(v23);
              statValueLength = v24 + 9;
              p_anon_0->lastValue = v19;
            }
          }
        }
        else
        {
          v12 = &ProfileData[v0];
          v14 = v12->_anon_0.lastValue;
          v13 = &v12->_anon_0;
          v15 = MenuCounts[v0 - 3];
          if ( v15 != v14 )
          {
            v16 = ProfileData[v0].id;
            v17 = statValueLength;
            statValue[statValueLength] = HIBYTE(v16);
            v18 = &statValue[v17];
            v18[3] = v16;
            v18[4] = 4;
            v18[5] = HIBYTE(v15);
            v18[6] = BYTE2(v15);
            v18[7] = BYTE1(v15);
            v18[8] = v15;
            v18[1] = BYTE2(v16);
            v18[2] = BYTE1(v16);
            statValueLength = v17 + 9;
            v13->lastValue = v15;
          }
        }
        if ( ++v0 == 406 )
        {
          if ( statValueLength > 0 )
            sub_19E428((const char *)statValue, statValueLength);
          return;
        }
      }
    }
    v7 = (int)(float)(CStats::GetPercentageProgress() * 100.0);
    if ( ProfileData[0]._anon_0.lastValue == v7 )
      goto LABEL_3;
    v8 = ProfileData[0].id;
    v9 = statValueLength;
    ProfileData[0]._anon_0.lastValue = v7;
    statValue[statValueLength] = HIBYTE(ProfileData[0].id);
    v10 = &statValue[v9];
    v10[1] = BYTE2(v8);
    v10[2] = BYTE1(v8);
    v10[3] = v8;
    v10[4] = 4;
    v10[5] = HIBYTE(v7);
    goto LABEL_17;
  }
}
// 19F264: using guessed type int IsProfileStatsBusy(void);

//----- (002ACBAC) --------------------------------------------------------
void __fastcall updateUsage(bool background)
{
  _BOOL4 v1; // r11
  int v2; // r10
  __int64 v3; // kr00_8
  __int64 v4; // r2
  int *v5; // r8
  unsigned int v6; // r5
  int **v7; // r0
  struct timeval tv; // [sp+4h] [bp-24h] BYREF

  v1 = background;
  gettimeofday(&tv, 0);
  v2 = 1000 * tv.tv_sec;
  v3 = updateUsage(bool)::lastTime;
  if ( updateUsage(bool)::lastTime )
  {
    v4 = v2 / 86400000LL % 30;
    v5 = &TimeInBackground[v4];
    if ( currentDayindex != (_DWORD)v4 )
    {
      TimeInBackground[(_DWORD)v4] = 0;
      DailyUse[(_DWORD)v4] = 0;
      currentDayindex = v2 / 86400000LL % 30;
    }
    if ( !v1 )
      v5 = &DailyUse[v4];
    *v5 += (v2 - v3) / 1000;
    if ( !IsProfileStatsBusy() )
    {
      v6 = OS_TimeMS();
      if ( lastUpdateProfilestatsTime + DelayBetweenProfilestats < v6 )
      {
        DoProfileStats();
        v7 = &lastUpdateProfilestatsTime_ptr;
LABEL_14:
        **v7 = v6;
        goto LABEL_15;
      }
      if ( lastUpdateTime - 1 >= v6
        || DelayBetweenSends + lastUpdateTime < v6
        || v6 > OneTimeSend && lastUpdateTime < OneTimeSend )
      {
        Telemetry::SendTelemetry();
        v7 = lastUpdateTime_ptr;
        goto LABEL_14;
      }
    }
  }
LABEL_15:
  updateUsage(bool)::lastTime = v2;
}
// 19F264: using guessed type int IsProfileStatsBusy(void);
// 679AE4: using guessed type int *lastUpdateProfilestatsTime_ptr;
// 679B74: using guessed type int *lastUpdateTime_ptr[2];

//----- (002ACD18) --------------------------------------------------------
void UpdateTelemetry()
{
  unsigned int v0; // r4
  int **v1; // r0

  if ( !IsProfileStatsBusy() )
  {
    v0 = OS_TimeMS();
    if ( lastUpdateProfilestatsTime + DelayBetweenProfilestats < v0 )
    {
      DoProfileStats();
      v1 = &lastUpdateProfilestatsTime_ptr;
LABEL_9:
      **v1 = v0;
      return;
    }
    if ( lastUpdateTime - 1 >= v0
      || DelayBetweenSends + lastUpdateTime < v0
      || v0 > OneTimeSend && lastUpdateTime < OneTimeSend )
    {
      Telemetry::SendTelemetry();
      v1 = lastUpdateTime_ptr;
      goto LABEL_9;
    }
  }
}
// 19F264: using guessed type int IsProfileStatsBusy(void);
// 679AE4: using guessed type int *lastUpdateProfilestatsTime_ptr;
// 679B74: using guessed type int *lastUpdateTime_ptr[2];

//----- (002ACDA8) --------------------------------------------------------
void Telemetry::SendTelemetry()
{
  int v0; // r0
  int8x16_t v1; // q9
  int8x16_t v2; // q8
  int32x4_t v3; // q9
  int32x4_t v4; // q8
  unsigned __int32 v5; // r3
  unsigned __int32 v6; // r6
  unsigned int v7; // r8
  unsigned int v8; // r1
  int8x16_t v9; // q8
  int8x16_t v10; // q9
  unsigned int v11; // r3
  int32x4_t *v12; // r0
  int32x4_t *v13; // r2
  int32x4_t v14; // q10
  int32x4_t v15; // q11
  int32x4_t v16; // q9
  int32x4_t v17; // q8
  unsigned __int32 v18; // r5
  unsigned __int32 v19; // r0
  unsigned int v20; // r2
  int *v21; // r3
  int *v22; // r1
  int v23; // r6
  int v24; // t1
  int v25; // t1
  const unsigned __int8 *Buildinfo; // r5
  const unsigned __int8 *v27; // r6
  const unsigned __int8 *v28; // r0
  struct timeval tv; // [sp+8h] [bp-18h] BYREF

  gettimeofday(&tv, 0);
  gettimeofday(&tv, 0);
  v0 = (1000 * tv.tv_sec - firstStartTime) / 86400000;
  if ( v0 < 30 )
  {
    v7 = v0 + 1;
    if ( v0 < 0 )
    {
      v18 = 0;
      v19 = 0;
    }
    else
    {
      if ( v7 > 3 && (v8 = v7 & 0xFFFFFFFC, (v7 & 0xFFFFFFFC) != 0) )
      {
        v9 = 0uLL;
        v10 = 0uLL;
        v11 = v7 & 0xFFFFFFFC;
        v12 = (int32x4_t *)DailyUse;
        v13 = (int32x4_t *)TimeInBackground;
        do
        {
          v14 = *v13++;
          v11 -= 4;
          v10 = vaddq_s32(v14, v10);
          v15 = *v12++;
          v9 = vaddq_s32(v15, v9);
        }
        while ( v11 );
        v16 = vaddq_s32(v10, vextq_s8(v10, v9, 8u));
        v17 = vaddq_s32(v9, vextq_s8(v9, v9, 8u));
        v18 = vaddq_s32(v16, vdupq_lane_s32((int32x2_t)v16.n128_u64[0], 1)).n128_u32[0];
        v19 = vaddq_s32(v17, vdupq_lane_s32((int32x2_t)v17.n128_u64[0], 1)).n128_u32[0];
        if ( v7 == v8 )
          goto LABEL_15;
      }
      else
      {
        v19 = 0;
        v18 = 0;
        v8 = 0;
      }
      v20 = v7 - v8;
      v21 = &TimeInBackground[v8];
      v22 = &DailyUse[v8];
      do
      {
        v24 = *v21++;
        v23 = v24;
        --v20;
        v25 = *v22++;
        v18 += v23;
        v19 += v25;
      }
      while ( v20 );
    }
LABEL_15:
    v6 = v19 / v7;
    v5 = v18 / v7;
    goto LABEL_16;
  }
  v1 = vaddq_s32(
         *(int32x4_t *)&TimeInBackground[24],
         vaddq_s32(
           *(int32x4_t *)&TimeInBackground[20],
           vaddq_s32(
             *(int32x4_t *)&TimeInBackground[16],
             vaddq_s32(
               *(int32x4_t *)&TimeInBackground[12],
               vaddq_s32(
                 *(int32x4_t *)&TimeInBackground[8],
                 vaddq_s32(*(int32x4_t *)&TimeInBackground[4], *(int32x4_t *)TimeInBackground))))));
  v2 = vaddq_s32(
         *(int32x4_t *)&DailyUse[24],
         vaddq_s32(
           *(int32x4_t *)&DailyUse[20],
           vaddq_s32(
             *(int32x4_t *)&DailyUse[16],
             vaddq_s32(
               *(int32x4_t *)&DailyUse[12],
               vaddq_s32(*(int32x4_t *)&DailyUse[8], vaddq_s32(*(int32x4_t *)&DailyUse[4], *(int32x4_t *)DailyUse))))));
  v3 = vaddq_s32(v1, vextq_s8(v1, v2, 8u));
  v4 = vaddq_s32(v2, vextq_s8(v2, v2, 8u));
  v5 = (TimeInBackground[29]
      + vaddq_s32(v3, vdupq_lane_s32((int32x2_t)v3.n128_u64[0], 1)).n128_u32[0]
      + TimeInBackground[28])
     / 0x1E;
  v6 = (DailyUse[29] + DailyUse[28] + vaddq_s32(v4, vdupq_lane_s32((int32x2_t)v4.n128_u64[0], 1)).n128_u32[0]) / 0x1E;
LABEL_16:
  sprintf(strforjson, "{\"u\":%d,\"i\":%d}", v6, v5);
  TelemetryDataSend("usage", (const char *)strforjson);
  OS_SystemGetBuildinfo(0);
  Buildinfo = OS_SystemGetBuildinfo(0);
  v27 = OS_SystemGetBuildinfo(1);
  v28 = OS_SystemGetBuildinfo(2);
  sprintf(strforjson, "{\"and_%s_%s_%s\"}", (const char *)Buildinfo, (const char *)v27, (const char *)v28);
  TelemetryDataSend("device", (const char *)strforjson);
  sub_191430();
}

//----- (002AD03C) --------------------------------------------------------
void EnterGameFromSC()
{
  if ( IsSCSignedIn() == 1 )
    lastUpdateTime = 0;
}

//----- (002AD05C) --------------------------------------------------------
void __fastcall AddMenuStat(MenuStat stat, int count)
{
  isDirty = 1;
  MenuCounts[stat] += count;
}

//----- (002AD084) --------------------------------------------------------
void ClearMenuStats()
{
  *(_QWORD *)&MenuCounts[23] = 0LL;
  *(_QWORD *)&MenuCounts[25] = 0LL;
  *(_QWORD *)&MenuCounts[20] = 0LL;
  *(_QWORD *)&MenuCounts[22] = 0LL;
  *(_QWORD *)&MenuCounts[16] = 0LL;
  *(_QWORD *)&MenuCounts[18] = 0LL;
  *(_QWORD *)&MenuCounts[12] = 0LL;
  *(_QWORD *)&MenuCounts[14] = 0LL;
  *(_QWORD *)&MenuCounts[8] = 0LL;
  *(_QWORD *)&MenuCounts[10] = 0LL;
  *(_QWORD *)MenuCounts = 0LL;
  *(_QWORD *)&MenuCounts[2] = 0LL;
  *(_QWORD *)&MenuCounts[4] = 0LL;
  *(_QWORD *)&MenuCounts[6] = 0LL;
}

//----- (002AD0C4) --------------------------------------------------------
void __fastcall SaveMenuStats(OSFile statsFile)
{
  int buffer[3]; // [sp+4h] [bp-Ch] BYREF

  *(_QWORD *)&MenuCounts[23] = 0LL;
  *(_QWORD *)&MenuCounts[25] = 0LL;
  *(_QWORD *)&MenuCounts[20] = 0LL;
  *(_QWORD *)&MenuCounts[22] = 0LL;
  *(_QWORD *)&MenuCounts[16] = 0LL;
  *(_QWORD *)&MenuCounts[18] = 0LL;
  *(_QWORD *)&MenuCounts[12] = 0LL;
  *(_QWORD *)&MenuCounts[14] = 0LL;
  *(_QWORD *)&MenuCounts[8] = 0LL;
  *(_QWORD *)&MenuCounts[10] = 0LL;
  *(_QWORD *)MenuCounts = 0LL;
  *(_QWORD *)&MenuCounts[2] = 0LL;
  *(_QWORD *)&MenuCounts[4] = 0LL;
  *(_QWORD *)&MenuCounts[6] = 0LL;
  buffer[0] = 27;
  OS_FileWrite(statsFile, buffer, 4);
  OS_FileWrite(statsFile, MenuCounts, 108);
}
// 2AD0C4: using guessed type int buffer[3];

//----- (002AD128) --------------------------------------------------------
void __fastcall LoadMenuStats(OSFile statsFile)
{
  int buffer[3]; // [sp+4h] [bp-Ch] BYREF

  *(_QWORD *)&MenuCounts[23] = 0LL;
  *(_QWORD *)&MenuCounts[25] = 0LL;
  *(_QWORD *)&MenuCounts[20] = 0LL;
  *(_QWORD *)&MenuCounts[22] = 0LL;
  *(_QWORD *)&MenuCounts[16] = 0LL;
  *(_QWORD *)&MenuCounts[18] = 0LL;
  *(_QWORD *)&MenuCounts[12] = 0LL;
  *(_QWORD *)&MenuCounts[14] = 0LL;
  *(_QWORD *)&MenuCounts[8] = 0LL;
  *(_QWORD *)&MenuCounts[10] = 0LL;
  *(_QWORD *)MenuCounts = 0LL;
  *(_QWORD *)&MenuCounts[2] = 0LL;
  *(_QWORD *)&MenuCounts[4] = 0LL;
  *(_QWORD *)&MenuCounts[6] = 0LL;
  buffer[0] = 27;
  OS_FileRead(statsFile, buffer, 4);
  OS_FileRead(statsFile, MenuCounts, 4 * buffer[0]);
}
// 2AD128: using guessed type int buffer[3];

//----- (002AD194) --------------------------------------------------------
void __fastcall SaveUsage(OSFile statsFile)
{
  struct timeval v2; // [sp+0h] [bp-10h] BYREF

  OS_FileWrite(statsFile, "Usage", 6);
  gettimeofday(&v2, 0);
  v2.tv_sec *= 1000;
  v2.tv_usec = v2.tv_sec >> 31;
  OS_FileWrite(statsFile, &v2, 8);
  OS_FileWrite(statsFile, &firstStartTime, 8);
  OS_FileWrite(statsFile, &currentDayindex, 4);
  OS_FileWrite(statsFile, DailyUse, 120);
  OS_FileWrite(statsFile, TimeInBackground, 120);
}

//----- (002AD218) --------------------------------------------------------
void __fastcall LoadUsage(OSFile statsFile)
{
  struct timeval v2; // [sp+0h] [bp-20h] BYREF
  unsigned __int8 pData[8]; // [sp+Ah] [bp-16h] BYREF

  CFileMgr::ReadBytes((u_native)statsFile, pData, 6);
  gettimeofday(&v2, 0);
  v2.tv_sec *= 1000;
  v2.tv_usec = v2.tv_sec >> 31;
  OS_FileRead(statsFile, &v2, 8);
  OS_FileRead(statsFile, &firstStartTime, 8);
  OS_FileRead(statsFile, &currentDayindex, 4);
  OS_FileRead(statsFile, DailyUse, 28);
  OS_FileRead(statsFile, TimeInBackground, 28);
}
// 2AD218: using guessed type unsigned __int8 pData[8];

//----- (002AD2BC) --------------------------------------------------------
void SaveTelemetry()
{
  OSFile v0; // r5
  OSFile v1; // r4
  OSFile intoFile; // [sp+4h] [bp-14h] BYREF
  struct timeval buffer[2]; // [sp+8h] [bp-10h] BYREF

  if ( OS_FileOpen(OSFDA_User_0, &intoFile, telemFileName, OSFAT_Write_0) == OSFE_NoError )
  {
    OS_FileWrite(intoFile, teleheader, 10);
    OS_FileWrite(intoFile, &lastUpdateTime, 4);
    v0 = intoFile;
    *(_QWORD *)&MenuCounts[23] = 0LL;
    *(_QWORD *)&MenuCounts[25] = 0LL;
    *(_QWORD *)&MenuCounts[20] = 0LL;
    *(_QWORD *)&MenuCounts[22] = 0LL;
    *(_QWORD *)&MenuCounts[16] = 0LL;
    *(_QWORD *)&MenuCounts[18] = 0LL;
    *(_QWORD *)&MenuCounts[12] = 0LL;
    *(_QWORD *)&MenuCounts[14] = 0LL;
    *(_QWORD *)&MenuCounts[8] = 0LL;
    *(_QWORD *)&MenuCounts[10] = 0LL;
    *(_QWORD *)MenuCounts = 0LL;
    *(_QWORD *)&MenuCounts[2] = 0LL;
    *(_QWORD *)&MenuCounts[4] = 0LL;
    *(_QWORD *)&MenuCounts[6] = 0LL;
    buffer[0].tv_sec = 27;
    OS_FileWrite(intoFile, buffer, 4);
    OS_FileWrite(v0, MenuCounts, 108);
    v1 = intoFile;
    OS_FileWrite(intoFile, "Usage", 6);
    gettimeofday(buffer, 0);
    buffer[0].tv_sec *= 1000;
    buffer[0].tv_usec = buffer[0].tv_sec >> 31;
    OS_FileWrite(v1, buffer, 8);
    OS_FileWrite(v1, &firstStartTime, 8);
    OS_FileWrite(v1, &currentDayindex, 4);
    OS_FileWrite(v1, DailyUse, 120);
    OS_FileWrite(v1, TimeInBackground, 120);
    OS_FileClose(intoFile);
    isDirty = 0;
  }
}

//----- (002AD3F0) --------------------------------------------------------
void LoadTelemetry()
{
  OSFile v0; // r5
  OSFile v1; // r4
  int v2; // r2
  int *v3; // r1
  OSFile v4; // r0
  OSFile intoFile; // [sp+4h] [bp-34h] BYREF
  struct timeval tv; // [sp+8h] [bp-30h] BYREF
  char buffer[16]; // [sp+10h] [bp-28h] BYREF
  unsigned __int8 pData[4]; // [sp+20h] [bp-18h] BYREF

  if ( OS_FileOpen(OSFDA_User_0, &intoFile, telemFileName, OSFAT_Read_0) == OSFE_NoError )
  {
    OS_FileRead(intoFile, buffer, 10);
    if ( !strcmp(buffer, "telemetry") )
    {
      *(_DWORD *)pData = 27;
      OS_FileRead(intoFile, pData, 4);
      v4 = intoFile;
      v3 = MenuCounts;
      v2 = 4 * *(_DWORD *)pData;
    }
    else
    {
      if ( strncmp(buffer, "telemv", 6u) )
        return;
      OS_FileRead(intoFile, &lastUpdateTime, 4);
      v0 = intoFile;
      *(_QWORD *)&MenuCounts[23] = 0LL;
      *(_QWORD *)&MenuCounts[25] = 0LL;
      *(_QWORD *)&MenuCounts[20] = 0LL;
      *(_QWORD *)&MenuCounts[22] = 0LL;
      *(_QWORD *)&MenuCounts[16] = 0LL;
      *(_QWORD *)&MenuCounts[18] = 0LL;
      *(_QWORD *)&MenuCounts[12] = 0LL;
      *(_QWORD *)&MenuCounts[14] = 0LL;
      *(_QWORD *)&MenuCounts[8] = 0LL;
      *(_QWORD *)&MenuCounts[10] = 0LL;
      *(_QWORD *)MenuCounts = 0LL;
      *(_QWORD *)&MenuCounts[2] = 0LL;
      *(_QWORD *)&MenuCounts[4] = 0LL;
      *(_QWORD *)&MenuCounts[6] = 0LL;
      *(_DWORD *)pData = 27;
      OS_FileRead(intoFile, pData, 4);
      OS_FileRead(v0, MenuCounts, 4 * *(_DWORD *)pData);
      v1 = intoFile;
      CFileMgr::ReadBytes((u_native)intoFile, pData, 6);
      gettimeofday(&tv, 0);
      tv.tv_sec *= 1000;
      tv.tv_usec = tv.tv_sec >> 31;
      OS_FileRead(v1, &tv, 8);
      OS_FileRead(v1, &firstStartTime, 8);
      OS_FileRead(v1, &currentDayindex, 4);
      OS_FileRead(v1, DailyUse, 28);
      v2 = 28;
      v3 = TimeInBackground;
      v4 = v1;
    }
    OS_FileRead(v4, v3, v2);
    OS_FileClose(intoFile);
  }
}

//----- (002AD580) --------------------------------------------------------
void CTouchInterface::LoadDefaultConfigFile()
{
  int v0; // r5
  int v1; // r6

  v0 = 2;
  v1 = 0;
  if ( (float)((float)RsGlobal.screenWidth / (float)RsGlobal.screenHeight) >= 1.5 )
  {
    v0 = 3;
    v1 = 1;
  }
  if ( OS_SystemForm() == OSDF_Phone )
    v1 = v0;
  CTouchInterface::LoadFromFile((const unsigned __int8 *)off_662E4C[v1], 1);
}
// 662E4C: using guessed type char *off_662E4C[6];

//----- (002AD5E4) --------------------------------------------------------
void __fastcall CTouchInterface::LoadFromFile(const unsigned __int8 *pszFilename, bool bFullLoad)
{
  _BOOL4 v3; // r4
  u_native v4; // r0
  u_native v5; // r8
  bool v6; // zf
  const char *Line; // r9
  float *v8; // r6
  float Width; // s29
  void *Height; // s0
  int *v11; // r0
  int v12; // s0
  int v13; // r6
  float *p_m_fScaleX; // r4
  float v16; // s29
  __int64 v17; // r0
  __int64 v18; // r2
  float v19; // s29
  float v20; // s29
  float v21; // s29
  float v22; // s29
  float v23; // s29
  float *v24; // [sp+1Ch] [bp-484h]
  _BOOL4 v25; // [sp+24h] [bp-47Ch]
  float v26; // [sp+28h] [bp-478h] BYREF
  float v27; // [sp+2Ch] [bp-474h] BYREF
  __int64 v28; // [sp+30h] [bp-470h] BYREF
  char v29; // [sp+38h] [bp-468h] BYREF
  char v30[256]; // [sp+138h] [bp-368h] BYREF
  char v31; // [sp+238h] [bp-268h] BYREF
  char v32; // [sp+338h] [bp-168h] BYREF

  v3 = bFullLoad;
  if ( bFullLoad )
    CFileMgr::SetDir("data");
  else
    CFileMgr::SetDirMyDocuments();
  v4 = CFileMgr::OpenFile(pszFilename, "rb");
  v5 = v4;
  v6 = v4 == 0;
  if ( !v4 )
    v6 = !v3;
  if ( v6 )
  {
    sub_18A2F4((const unsigned __int8 *)&byte_61CADE);
  }
  else
  {
    v25 = v3;
    Line = (const char *)CFileLoader::LoadLine(v4);
    if ( Line )
    {
      v8 = &v27;
      while ( 1 )
      {
        while ( !*Line || !strstr(Line, "PositionAndScale") )
        {
          Line = (const char *)CFileLoader::LoadLine(v5);
          if ( !Line )
            goto LABEL_66;
        }
        v24 = v8;
        if ( strstr(Line, "SCALE_SMALLEST")
          || strstr(Line, "SCALE_SMALLER")
          || strstr(Line, "SCALE_SMALL")
          || strstr(Line, "SCALE_MEDIUM")
          || strstr(Line, "SCALE_LARGE")
          || strstr(Line, "SCALE_LARGER")
          || strstr(Line, "SCALE_LARGEST")
          || strstr(Line, "SCALE_LARGEST_PHONE") )
        {
          break;
        }
        sscanf(Line, "%s %f %f %f %f %s %s", &v32, &v26, v8, &v28, (char *)&v28 + 4, &v31, v30);
LABEL_28:
        v13 = 0;
        p_m_fScaleX = &CTouchInterface::m_WidgetPosition[0].m_fScaleX;
        while ( strcasecmp(v30, (const char *)CTouchInterface::m_pszWidgetPositionNames[v13]) )
        {
          p_m_fScaleX += 4;
          if ( v13++ >= 137 )
            goto LABEL_40;
        }
        if ( v25 )
        {
          v16 = v26;
          if ( v26 < 160.0 )
          {
            v16 = v26 + 0.0;
            v26 = v26 + 0.0;
          }
          if ( !strcasecmp(v30, "WIDGET_POSITION_RADAR") )
          {
            *(float *)&v17 = v16 + 0.0;
            v26 = v16 + 0.0;
            v27 = v27 + 0.0;
          }
          else
          {
            *(float *)&v17 = v16;
          }
        }
        else
        {
          *(float *)&v17 = v26;
        }
        *((float *)&v17 + 1) = v27;
        v18 = v28;
        *((_QWORD *)p_m_fScaleX - 1) = v17;
        *(_QWORD *)p_m_fScaleX = v18;
LABEL_40:
        v8 = v24;
        Line = (const char *)CFileLoader::LoadLine(v5);
        if ( !Line )
          goto LABEL_66;
      }
      sscanf(Line, "%s %f %f %s %s %s", &v32, &v26, v8, &v29, &v31, v30);
      if ( strstr(Line, "SCALE_LARGEST_PHONE") )
      {
        Width = (float)(unsigned int)OS_ScreenGetWidth();
        Height = OS_ScreenGetHeight();
        v11 = dword_2ADAE4;
      }
      else if ( strstr(Line, "SCALE_LARGEST") )
      {
        Width = (float)(unsigned int)OS_ScreenGetWidth();
        Height = OS_ScreenGetHeight();
        v11 = dword_2ADAEC;
      }
      else
      {
        if ( !strstr(Line, "SCALE_LARGER") )
        {
          if ( strstr(Line, "SCALE_LARGE") )
          {
            v19 = (float)(unsigned int)OS_ScreenGetWidth();
            v12 = 29.0;
            if ( (float)(v19 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
              v12 = 1103442740;
          }
          else if ( strstr(Line, "SCALE_SMALLEST") )
          {
            v20 = (float)(unsigned int)OS_ScreenGetWidth();
            v12 = 11.5;
            if ( (float)(v20 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
              v12 = 1092380263;
          }
          else if ( strstr(Line, "SCALE_SMALLER") )
          {
            v21 = (float)(unsigned int)OS_ScreenGetWidth();
            v12 = 14.0;
            if ( (float)(v21 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
              v12 = 1094608487;
          }
          else if ( strstr(Line, "SCALE_MEDIUM") )
          {
            v22 = (float)(unsigned int)OS_ScreenGetWidth();
            v12 = 24.0;
            if ( (float)(v22 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
              v12 = 1101214516;
          }
          else
          {
            v12 = 0;
            if ( strstr(Line, "SCALE_SMALL") )
            {
              v23 = (float)(unsigned int)OS_ScreenGetWidth();
              v12 = 17.0;
              if ( (float)(v23 / (float)(unsigned int)OS_ScreenGetHeight()) > 1.9 )
                v12 = 1097282356;
            }
          }
          goto LABEL_27;
        }
        Width = (float)(unsigned int)OS_ScreenGetWidth();
        Height = OS_ScreenGetHeight();
        v11 = dword_2ADAF4;
      }
      if ( (float)(Width / (float)(unsigned int)Height) > 1.9 )
        ++v11;
      v12 = *v11;
LABEL_27:
      HIDWORD(v28) = v12;
      LODWORD(v28) = v12;
      goto LABEL_28;
    }
LABEL_66:
    CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
    CFileMgr::CloseFile(v5);
  }
}
// 2ADAE4: using guessed type int dword_2ADAE4[2];
// 2ADAEC: using guessed type int dword_2ADAEC[2];
// 2ADAF4: using guessed type int dword_2ADAF4[2];
// 61CADE: using guessed type char byte_61CADE;

//----- (002ADB20) --------------------------------------------------------
void CTouchInterface::LoadTouchControls()
{
  float32x2_t v0; // d1
  float32x2_t v1; // d2
  int v2; // r6
  int v3; // r5

  v2 = 2;
  v1.n64_f32[0] = (float)OS_PointerGetNumber();
  v3 = 0;
  v0.n64_u32[0] = 4.0;
  CTouchInterface::m_nMaxTouches = (int)vmin_f32(v1, v0).n64_f32[0];
  if ( (float)((float)RsGlobal.screenWidth / (float)RsGlobal.screenHeight) >= 1.5 )
  {
    v2 = 3;
    v3 = 1;
  }
  if ( OS_SystemForm() == OSDF_Phone )
    v3 = v2;
  CTouchInterface::LoadFromFile((const unsigned __int8 *)off_662E4C[v3], 1);
  CTouchInterface::LoadFromFile("Adjustable.cfg", 0);
  *(_DWORD *)&CTouchInterface::m_pszWidgetTextures[0][4] = (char *)&CStreaming::ms_aInfoForModel[4072].m_cdPosn + 3;
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[2], "accelerate");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[4], "handbrake");
  *(_DWORD *)&CTouchInterface::m_pszWidgetTextures[0][0] = 1600419176;
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[1], "punch");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[3], "brake");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[5], "hud_left");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[6], "hud_right");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[7], "horn");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[8], "hud_Cellphone");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[9], "Gift");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[10], "kiss");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[11], "shoot");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[12], "fadeinbox");
  *(_DWORD *)&CTouchInterface::m_pszWidgetTextures[13][4] = &CWidgetListShop::m_FileEntry[611].m_szFileName[27];
  *(_DWORD *)&CTouchInterface::m_pszWidgetTextures[13][0] = 1970169197;
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[14], "crane_release");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[15], "drop_item");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[16], "leftshoot");
  strcpy((char *)&CTouchInterface::m_pszWidgetTextures[17][4], "t");
  *(_DWORD *)&CTouchInterface::m_pszWidgetTextures[17][0] = *(_DWORD *)&CTouchInterface::m_pszWidgetTextures[11][0];
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[18], "cam-toggle");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[19], "hud_lockon");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[20], "hud_lockon");
  strcpy((char *)&CTouchInterface::m_pszWidgetTextures[21][4], "t");
  *(_DWORD *)&CTouchInterface::m_pszWidgetTextures[21][0] = *(_DWORD *)&CTouchInterface::m_pszWidgetTextures[11][0];
  strcpy((char *)&CTouchInterface::m_pszWidgetTextures[22][4], "t");
  *(_DWORD *)&CTouchInterface::m_pszWidgetTextures[22][0] = *(_DWORD *)&CTouchInterface::m_pszWidgetTextures[11][0];
  *(_DWORD *)&CTouchInterface::m_pszWidgetTextures[23][0] = *(_DWORD *)&CTouchInterface::m_pszWidgetTextures[11][0];
  strcpy((char *)&CTouchInterface::m_pszWidgetTextures[23][4], "t");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[24], "hud_rockets");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[25], "hud_detonator");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[26], "hud_tank_left");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[27], "hud_tank_right");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[28], "hud_buy");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[29], "hud_swapgun");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[30], "hud_nitro");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[110], "Yes");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[111], "No");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[31], "hud_circle");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[32], "hud_crouch");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[33], "hud_dive");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[34], "hud_circle");
  *(_DWORD *)&CTouchInterface::m_pszWidgetTextures[37][16] = &unk_646573;
  qmemcpy(CTouchInterface::m_pszWidgetTextures[37], "ArcadeGreenRelea", 16);
  *(_DWORD *)&CTouchInterface::m_pszWidgetTextures[38][16] = &CWidgetListShop::m_FileEntry[518].m_RectUVs.right;
  qmemcpy(CTouchInterface::m_pszWidgetTextures[38], "ArcadeButton_Exi", 16);
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[39], "ArcadeButton_ResetUp");
  *(_DWORD *)&CTouchInterface::m_pszWidgetTextures[40][16] = &unk_626F6E;
  qmemcpy(CTouchInterface::m_pszWidgetTextures[40], "ArcadeJoystick_K", 16);
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[41], "hud_right");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[42], "hud_right");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[43], "crane_up");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[44], "crane_up");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[45], "crane_down");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[46], "crane_up");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[47], "crane_down");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[48], "hud_left");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[49], "hud_right");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[50], "hud_plus");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[51], "hud_minus");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[52], "hud_left");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[53], "hud_right");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[54], "hud_check");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[55], "hud_drop_jetpack");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[56], "menu_back");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[57], "StoreBuy");
  *(_DWORD *)&CTouchInterface::m_pszWidgetTextures[58][4] = &CWidgetListShop::m_FileEntry[611].m_szFileName[27];
  *(_DWORD *)&CTouchInterface::m_pszWidgetTextures[58][0] = 1970169197;
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[59], "menu_down");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[60], "hud_left");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[61], "hud_right");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[62], "hud_plus");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[63], "hud_minus");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[64], "DialogBox");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[65], "DialogBox");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[66], "StopHand");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[67], "hud_magnet");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[68], "hud_stinger");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[69], "mission_start");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[70], "mission_start");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[71], "hud_x");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[72], "hud_x");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[73], "mission_start");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[74], "hud_drop_jetpack");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[79], "hud_right");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[76], "TVArrow_Left");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[77], "TVArrow_Right");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[87], "basketball_shoot");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[88], "basketball_trick");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[89], "hud_x");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[90], "hud_check");
  *(_DWORD *)&CTouchInterface::m_pszWidgetTextures[91][4] = &CStreaming::ms_aInfoForModel[10729];
  *(_DWORD *)&CTouchInterface::m_pszWidgetTextures[91][0] = 1884506690;
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[92], "BJDouble");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[93], "BJHit");
  *(_DWORD *)&CTouchInterface::m_pszWidgetTextures[94][4] = &unk_646E61;
  *(_DWORD *)&CTouchInterface::m_pszWidgetTextures[94][0] = 1951615554;
  *(_DWORD *)&CTouchInterface::m_pszWidgetTextures[97][8] = (char *)&CStreaming::ms_aInfoForModel[20636].m_cdPosn + 2;
  *(_QWORD *)&CTouchInterface::m_pszWidgetTextures[97][0] = *(_QWORD *)"YellowArrow";
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[98], "BlueArrow");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[99], "RedArrow");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[100], "GreenArrow");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[102], "hud_drop_jetpack");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[106], "FistBump");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[107], "hud_x");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[108], "LetsGoHand");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[109], "StopHand");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[105], "GangBackground");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[164], "hud_circle");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[167], "hud_circle");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[172], "hud_circle");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[187], "hud_parachute");
  strcpy((char *)CTouchInterface::m_pszWidgetTextures[159], "circle");
}
// 2ADB68: variable 'v1' is possibly undefined
// 2ADB68: variable 'v0' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 662E4C: using guessed type char *off_662E4C[6];

//----- (002AE570) --------------------------------------------------------
void CTouchInterface::CreateAll()
{
  int i; // r4
  CWidget *v1; // r0
  CWidgetButton *v2; // r0
  CWidget *v3; // r0
  CWidgetButton *v4; // r0
  CWidget *v5; // r0
  CWidgetButtonEnterCar *v6; // r0
  CWidget *v7; // r0
  CWidgetButtonAttack *v8; // r0
  CWidget *v9; // r0
  CWidgetButton *v10; // r0
  CWidget *v11; // r0
  CWidgetButton *v12; // r0
  CWidget *v13; // r0
  CWidgetButton *v14; // r0
  CWidget *v15; // r0
  CWidgetButton *v16; // r0
  CWidget *v17; // r0
  CWidgetButton *v18; // r0
  CWidget *v19; // r0
  CWidgetButton *v20; // r0
  CWidget *v21; // r0
  CWidgetButtonVehicleShoot *v22; // r0
  CWidget *v23; // r0
  CWidgetButtonVehicleShoot *v24; // r0
  CWidget *v25; // r0
  CWidgetButtonHydraulics *v26; // r0
  CWidget *v27; // r0
  CWidgetButtonAutoHydraulics *v28; // r0
  CWidget *v29; // r0
  CWidgetButtonDrop *v30; // r0
  CWidget *v31; // r0
  CWidgetButtonDrop *v32; // r0
  CWidget *v33; // r0
  CWidgetButtonVCShoot *v34; // r0
  CWidget *v35; // r0
  CWidgetButtonVCShoot *v36; // r0
  CWidget *v37; // r0
  CWidgetButtonTargeting *v38; // r0
  CWidget *v39; // r0
  CWidgetButtonTargeting *v40; // r0
  CWidget *v41; // r0
  CWidgetButton *v42; // r0
  CWidget *v43; // r0
  CWidgetButton *v44; // r0
  CWidget *v45; // r0
  CWidgetButtonRocket *v46; // r0
  CWidget *v47; // r0
  CWidgetButton *v48; // r0
  CWidget *v49; // r0
  CWidgetButton *v50; // r0
  CWidget *v51; // r0
  CWidgetButton *v52; // r0
  CWidget *v53; // r0
  CWidgetButton *v54; // r0
  CWidget *v55; // r0
  CWidgetButtonSwapWeapons *v56; // r0
  CWidget *v57; // r0
  CWidgetButton *v58; // r0
  CWidget *v59; // r0
  CWidgetButton *v60; // r0
  CWidget *v61; // r0
  CWidgetRegionPoolEnglish *v62; // r0
  CWidget *v63; // r0
  CWidgetRegionPoolBallInHand *v64; // r0
  CWidget *v65; // r0
  CWidgetButtonAnimatedArcade *v66; // r0
  CWidget *v67; // r0
  CWidgetButtonAnimated *v68; // r0
  CWidget *v69; // r0
  CWidgetButtonAnimated *v70; // r0
  CWidget *v71; // r0
  CWidgetRegionArcadeStick *v72; // r0
  CWidget *v73; // r0
  CWidgetButtonSkipCutscene *v74; // r0
  CWidget *v75; // r0
  CWidgetButton *v76; // r0
  CWidget *v77; // r0
  CWidgetButton *v78; // r0
  CWidget *v79; // r0
  CWidgetButton *v80; // r0
  CWidget *v81; // r0
  CWidgetButton *v82; // r0
  CWidget *v83; // r0
  CWidgetButton *v84; // r0
  CWidget *v85; // r0
  CWidgetButton *v86; // r0
  CWidget *v87; // r0
  CWidgetButton *v88; // r0
  CWidget *v89; // r0
  CWidgetButton *v90; // r0
  CWidget *v91; // r0
  CWidgetButtonZoom *v92; // r0
  CWidget *v93; // r0
  CWidgetButtonZoom *v94; // r0
  CWidget *v95; // r0
  CWidgetButton *v96; // r0
  CWidget *v97; // r0
  CWidgetButton *v98; // r0
  CWidget *v99; // r0
  CWidgetButton *v100; // r0
  CWidget *v101; // r0
  CWidgetButton *v102; // r0
  CWidget *v103; // r0
  CWidgetButton *v104; // r0
  CWidget *v105; // r0
  CWidgetButton *v106; // r0
  CWidget *v107; // r0
  CWidgetButton *v108; // r0
  CWidget *v109; // r0
  CWidgetButton *v110; // r0
  CWidget *v111; // r0
  CWidgetButton *v112; // r0
  CWidget *v113; // r0
  CWidgetButton *v114; // r0
  CWidget *v115; // r0
  CWidgetButton *v116; // r0
  CWidget *v117; // r0
  CWidgetButton *v118; // r0
  CWidget *v119; // r0
  CWidgetRegionSteeringSelection *v120; // r0
  CWidget *v121; // r0
  CWidgetRegionTouchLayoutSelection *v122; // r0
  CWidget *v123; // r0
  CWidgetButton *v124; // r0
  CWidget *v125; // r0
  CWidgetButton *v126; // r0
  CWidget *v127; // r0
  CWidgetButton *v128; // r0
  CWidget *v129; // r0
  CWidgetButtonMissionStart *v130; // r0
  CWidget *v131; // r0
  CWidgetButtonMissionCancel *v132; // r0
  CWidget *v133; // r0
  CWidgetButtonMissionStart *v134; // r0
  CWidget *v135; // r0
  CWidgetButtonMissionCancel *v136; // r0
  CWidget *v137; // r0
  CWidgetButton *v138; // r0
  CWidget *v139; // r0
  CWidgetButton *v140; // r0
  CWidget *v141; // r0
  CWidgetInfoFrame *v142; // r0
  int v143; // r0
  int v144; // r1
  CWidgetInfoFrame *v145; // r0
  CWidget *v146; // r0
  unsigned int m_nFlags; // r1
  CWidgetInfoFrame *v148; // r0
  CWidget *v149; // r0
  unsigned int v150; // r1
  CWidgetInfoFrame *v151; // r0
  CWidget *v152; // r0
  unsigned int v153; // r1
  CWidgetInfoFrame *v154; // r0
  CWidget *v155; // r0
  unsigned int v156; // r1
  CWidgetInfoFrame *v157; // r0
  CWidget *v158; // r0
  unsigned int v159; // r1
  CWidgetInfoFrame *v160; // r0
  CWidget *v161; // r0
  unsigned int v162; // r1
  CWidgetButton *v163; // r0
  CWidget *v164; // r0
  CWidgetButtonSchool *v165; // r0
  CWidget *v166; // r0
  CWidgetButtonSchool *v167; // r0
  CWidget *v168; // r0
  CWidgetButtonSchool *v169; // r0
  CWidget *v170; // r0
  CWidgetButtonSchool *v171; // r0
  CWidget *v172; // r0
  CWidgetButtonBasketballShoot *v173; // r0
  CWidget *v174; // r0
  CWidgetButton *v175; // r0
  CWidget *v176; // r0
  CWidgetButton *v177; // r0
  CWidget *v178; // r0
  CWidgetButton *v179; // r0
  CWidget *v180; // r0
  CWidgetButton *v181; // r0
  CWidget *v182; // r0
  CWidgetButton *v183; // r0
  CWidget *v184; // r0
  CWidgetButton *v185; // r0
  CWidget *v186; // r0
  CWidgetButton *v187; // r0
  CWidget *v188; // r0
  CWidgetRegion *v189; // r0
  CWidget *v190; // r0
  CWidgetButton *v191; // r0
  CWidget *v192; // r0
  CWidgetButton *v193; // r0
  CWidget *v194; // r0
  CWidgetButton *v195; // r0
  CWidget *v196; // r0
  CWidgetButton *v197; // r0
  CWidget *v198; // r0
  CWidgetButton *v199; // r0
  CWidget *v200; // r0
  CWidgetInfoFrame *v201; // r0
  CWidget *v202; // r0
  CWidgetInfoFrame *v203; // r0
  CWidget *v204; // r0
  CWidgetButton *v205; // r0
  CWidget *v206; // r0
  CWidgetButton *v207; // r0
  CWidget *v208; // r0
  CWidgetButton *v209; // r0
  CWidget *v210; // r0
  CWidgetButton *v211; // r4
  CWidgetRegionGang *v212; // r0
  CWidget *v213; // r0
  const WidgetPosition *v214; // r4
  CWidgetRegionColorPicker *v215; // r0
  CWidget *v216; // r0
  CWidgetButton *v217; // r0
  CWidget *v218; // r0
  CWidgetButton *v219; // r0
  CWidget *v220; // r0
  CWidgetButton *v221; // r0
  CWidget *v222; // r0
  CWidgetButton *v223; // r0
  CWidget *v224; // r0
  CWidgetButton *v225; // r0
  CWidget *v226; // r0
  CWidgetButton *v227; // r0
  CWidget *v228; // r0
  CWidgetButtonAnimated *v229; // r0
  CWidget *v230; // r0
  CWidgetButtonAnimated *v231; // r0
  CWidget *v232; // r0
  CWidgetButtonAnimated *v233; // r0
  CWidget *v234; // r0
  CWidgetButtonAnimated *v235; // r0
  CWidget *v236; // r0
  CWidgetButtonAnimated *v237; // r0
  CWidget *v238; // r0
  CWidgetButtonAnimated *v239; // r0
  CWidget *v240; // r0
  CWidgetButtonAnimated *v241; // r0
  CWidget *v242; // r0
  CWidgetRegion *v243; // r0
  CWidget *v244; // r0
  CWidgetRegion *v245; // r0
  CWidget *v246; // r0
  CWidgetRegion *v247; // r0
  CWidget *v248; // r0
  CWidgetRegion *v249; // r0
  CWidget *v250; // r0
  CWidgetRegion *v251; // r0
  CWidget *v252; // r0
  CWidgetButtonAnimated *v253; // r0
  CWidget *v254; // r0
  CWidgetButtonAnimated *v255; // r0
  CWidget *v256; // r0
  CWidgetRegion *v257; // r0
  CWidget *v258; // r0
  CWidgetRegion *v259; // r0
  CWidget *v260; // r0
  CWidgetRegion *v261; // r0
  CWidget *v262; // r0
  CWidgetRegion *v263; // r0
  CWidget *v264; // r0
  CWidgetRegion *v265; // r0
  CWidget *v266; // r0
  CWidgetRegion *v267; // r0
  CWidget *v268; // r0
  CWidgetRegion *v269; // r0
  CWidget *v270; // r0
  CWidgetRegion *v271; // r0
  CWidget *v272; // r0
  CWidgetRegion *v273; // r0
  CWidget *v274; // r0
  CWidgetRegion *v275; // r0
  CWidget *v276; // r0
  CWidgetRegion *v277; // r0
  CWidget *v278; // r0
  CWidgetRegion *v279; // r0
  CWidget *v280; // r0
  CWidgetRegion *v281; // r0
  CWidget *v282; // r0
  CWidgetRegion *v283; // r0
  CWidget *v284; // r0
  CWidgetButtonAnimated *v285; // r0
  CWidget *v286; // r0
  CWidgetMap *v287; // r0
  CWidget *v288; // r0
  CWidgetRegionResponse *v289; // r0
  CWidget *v290; // r0
  CWidgetPlayerInfo *v291; // r0
  CWidget *v292; // r0
  CWidgetRadar *v293; // r0
  CWidget *v294; // r0
  CWidgetHelpText *v295; // r4
  CWidgetThumbCircle *v296; // r4
  CWidgetTapMeter *v297; // r0
  CWidget *v298; // r0
  CWidgetRegionSwipeRadio *v299; // r0
  CWidget *v300; // r0
  CWidgetRegionMove *v301; // r0
  CWidget *v302; // r0
  CWidgetRegionBasketBallJump *v303; // r0
  CWidget *v304; // r0
  CWidgetRegion *v305; // r0
  CWidget *v306; // r0
  CWidgetRegionLook *v307; // r0
  CWidget *v308; // r0
  CWidgetMissionTimers *v309; // r0
  CWidget *v310; // r0
  CWidgetRacing *v311; // r0
  CWidget *v312; // r0
  CWidgetRaceResults *v313; // r0
  CWidget *v314; // r0
  CWidgetHorseResults *v315; // r0
  CWidget *v316; // r0
  CWidgetWager *v317; // r0
  CWidget *v318; // r0
  CWidgetPool *v319; // r0
  CWidget *v320; // r0
  CWidgetVitalStats *v321; // r0
  CWidget *v322; // r0
  CWidgetRouletteSpin *v323; // r0
  CWidget *v324; // r0
  CWidgetInfoFrame *v325; // r0
  CWidget *v326; // r0
  CWidgetButton *v327; // r0
  CWidget *v328; // r0
  CWidgetRegion *v329; // r0
  CWidget *v330; // r0
  CWidgetRegion *v331; // r0
  CWidget *v332; // r0
  CWidgetButton *v333; // r0
  CWidget *v334; // r0
  CWidgetRegion *v335; // r0
  CWidget *v336; // r0
  CWidgetSaveNotification *v337; // r0
  CWidget *v338; // r0
  CWidgetReplay *v339; // r0
  CWidget *v340; // r0
  OSDeviceForm v341; // [sp+20h] [bp-68h]
  TextureDatabaseRuntime *toUnregister; // [sp+24h] [bp-64h]
  CRGBA v343; // [sp+2Ch] [bp-5Ch] BYREF
  WidgetPosition v344; // [sp+30h] [bp-58h] BYREF
  WidgetPosition v345; // [sp+40h] [bp-48h] BYREF

  v341 = OS_SystemForm();
  toUnregister = TextureDatabaseRuntime::GetDatabase("mobile");
  TextureDatabaseRuntime::Register(toUnregister);
  for ( i = 0; i != 190; ++i )
  {
    v1 = CTouchInterface::m_pWidgets[i];
    if ( v1 )
    {
      (*((void (__fastcall **)(CWidget *))v1->_vptr$CWidget + 1))(v1);
      CTouchInterface::m_pWidgets[i] = 0;
    }
  }
  v2 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v2,
    CTouchInterface::m_pszWidgetTextures[3],
    &CTouchInterface::m_WidgetPosition[4],
    1u,
    0x40u,
    HID_MAPPING_BRAKE);
  CTouchInterface::m_pWidgets[3] = v3;
  v4 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v4,
    CTouchInterface::m_pszWidgetTextures[4],
    &CTouchInterface::m_WidgetPosition[12],
    1u,
    0x40u,
    HID_MAPPING_HANDBRAKE);
  CTouchInterface::m_pWidgets[4] = v5;
  v6 = (CWidgetButtonEnterCar *)operator new(0xC0u);
  CWidgetButtonEnterCar::CWidgetButtonEnterCar(
    v6,
    CTouchInterface::m_pszWidgetTextures[0],
    CTouchInterface::m_WidgetPosition);
  CTouchInterface::m_pWidgets[0] = v7;
  v8 = (CWidgetButtonAttack *)operator new(0xA8u);
  CWidgetButtonAttack::CWidgetButtonAttack(
    v8,
    CTouchInterface::m_pszWidgetTextures[1],
    &CTouchInterface::m_WidgetPosition[14]);
  CTouchInterface::m_pWidgets[1] = v9;
  v10 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v10,
    CTouchInterface::m_pszWidgetTextures[7],
    &CTouchInterface::m_WidgetPosition[7],
    1u,
    0,
    HID_MAPPING_HORN);
  CTouchInterface::m_pWidgets[7] = v11;
  v12 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v12,
    CTouchInterface::m_pszWidgetTextures[8],
    &CTouchInterface::m_WidgetPosition[9],
    1u,
    0,
    HID_MAPPING_PHONE);
  CTouchInterface::m_pWidgets[8] = v13;
  v14 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v14,
    CTouchInterface::m_pszWidgetTextures[9],
    &CTouchInterface::m_WidgetPosition[9],
    1u,
    0x800u,
    HID_MAPPING_VITAL_STATS);
  CTouchInterface::m_pWidgets[9] = v15;
  v16 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v16,
    CTouchInterface::m_pszWidgetTextures[10],
    &CTouchInterface::m_WidgetPosition[9],
    1u,
    0,
    HID_MAPPING_KISS);
  CTouchInterface::m_pWidgets[10] = v17;
  v18 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v18,
    CTouchInterface::m_pszWidgetTextures[11],
    &CTouchInterface::m_WidgetPosition[1],
    1u,
    0,
    HID_MAPPING_ATTACK);
  CTouchInterface::m_pWidgets[11] = v19;
  v20 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v20,
    CTouchInterface::m_pszWidgetTextures[18],
    &CTouchInterface::m_WidgetPosition[13],
    1u,
    0,
    HID_MAPPING_CAMERA_CLOSER);
  CTouchInterface::m_pWidgets[18] = v21;
  v22 = (CWidgetButtonVehicleShoot *)operator new(0xA8u);
  CWidgetButtonVehicleShoot::CWidgetButtonVehicleShoot(
    v22,
    CTouchInterface::m_pszWidgetTextures[16],
    &CTouchInterface::m_WidgetPosition[10],
    HID_MAPPING_VEHICLE_LOOK_LEFT);
  CTouchInterface::m_pWidgets[16] = v23;
  v24 = (CWidgetButtonVehicleShoot *)operator new(0xA8u);
  CWidgetButtonVehicleShoot::CWidgetButtonVehicleShoot(
    v24,
    CTouchInterface::m_pszWidgetTextures[17],
    &CTouchInterface::m_WidgetPosition[11],
    HID_MAPPING_VEHICLE_LOOK_RIGHT);
  CTouchInterface::m_pWidgets[17] = v25;
  v26 = (CWidgetButtonHydraulics *)operator new(0xCCu);
  CWidgetButtonHydraulics::CWidgetButtonHydraulics(
    v26,
    CTouchInterface::m_pszWidgetTextures[12],
    &CTouchInterface::m_WidgetPosition[110]);
  CTouchInterface::m_pWidgets[12] = v27;
  v28 = (CWidgetButtonAutoHydraulics *)operator new(0xACu);
  CWidgetButtonAutoHydraulics::CWidgetButtonAutoHydraulics(
    v28,
    CTouchInterface::m_pszWidgetTextures[13],
    &CTouchInterface::m_WidgetPosition[1]);
  CTouchInterface::m_pWidgets[13] = v29;
  v30 = (CWidgetButtonDrop *)operator new(0xA8u);
  CWidgetButtonDrop::CWidgetButtonDrop(
    v30,
    CTouchInterface::m_pszWidgetTextures[14],
    CTouchInterface::m_WidgetPosition,
    HID_MAPPING_DROP_CRANE);
  CTouchInterface::m_pWidgets[14] = v31;
  v32 = (CWidgetButtonDrop *)operator new(0xA8u);
  CWidgetButtonDrop::CWidgetButtonDrop(
    v32,
    CTouchInterface::m_pszWidgetTextures[15],
    &CTouchInterface::m_WidgetPosition[14],
    HID_MAPPING_DROP_ITEM);
  CTouchInterface::m_pWidgets[15] = v33;
  v34 = (CWidgetButtonVCShoot *)operator new(0xA8u);
  CWidgetButtonVCShoot::CWidgetButtonVCShoot(
    v34,
    CTouchInterface::m_pszWidgetTextures[21],
    &CTouchInterface::m_WidgetPosition[15]);
  CTouchInterface::m_pWidgets[21] = v35;
  v36 = (CWidgetButtonVCShoot *)operator new(0xA8u);
  CWidgetButtonVCShoot::CWidgetButtonVCShoot(
    v36,
    CTouchInterface::m_pszWidgetTextures[21],
    &CTouchInterface::m_WidgetPosition[16]);
  CTouchInterface::m_pWidgets[22] = v37;
  v38 = (CWidgetButtonTargeting *)operator new(0xA8u);
  CWidgetButtonTargeting::CWidgetButtonTargeting(
    v38,
    CTouchInterface::m_pszWidgetTextures[19],
    &CTouchInterface::m_WidgetPosition[14]);
  CTouchInterface::m_pWidgets[19] = v39;
  v40 = (CWidgetButtonTargeting *)operator new(0xA8u);
  CWidgetButtonTargeting::CWidgetButtonTargeting(
    v40,
    CTouchInterface::m_pszWidgetTextures[20],
    &CTouchInterface::m_WidgetPosition[14]);
  CTouchInterface::m_pWidgets[20] = v41;
  v42 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v42,
    CTouchInterface::m_pszWidgetTextures[23],
    &CTouchInterface::m_WidgetPosition[12],
    1u,
    0,
    HID_MAPPING_FLIGHT_PRIMARY_ATTACK);
  CTouchInterface::m_pWidgets[23] = v43;
  v44 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v44,
    CTouchInterface::m_pszWidgetTextures[25],
    &CTouchInterface::m_WidgetPosition[38],
    1u,
    0xC00u,
    HID_MAPPING_VEHICLE_BOMB);
  CTouchInterface::m_pWidgets[25] = v45;
  v46 = (CWidgetButtonRocket *)operator new(0xA8u);
  CWidgetButtonRocket::CWidgetButtonRocket(
    v46,
    CTouchInterface::m_pszWidgetTextures[24],
    &CTouchInterface::m_WidgetPosition[1]);
  CTouchInterface::m_pWidgets[24] = v47;
  v48 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v48,
    CTouchInterface::m_pszWidgetTextures[26],
    &CTouchInterface::m_WidgetPosition[10],
    1u,
    0,
    HID_MAPPING_TURRET_LEFT);
  CTouchInterface::m_pWidgets[26] = v49;
  v50 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v50,
    CTouchInterface::m_pszWidgetTextures[27],
    &CTouchInterface::m_WidgetPosition[11],
    1u,
    0,
    HID_MAPPING_TURRET_RIGHT);
  CTouchInterface::m_pWidgets[27] = v51;
  v52 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v52,
    CTouchInterface::m_pszWidgetTextures[28],
    &CTouchInterface::m_WidgetPosition[38],
    1u,
    0xC00u,
    HID_MAPPING_SWAP_WEAPONS_AND_PURCHASE);
  CTouchInterface::m_pWidgets[28] = v53;
  v54 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v54,
    CTouchInterface::m_pszWidgetTextures[30],
    &CTouchInterface::m_WidgetPosition[1],
    1u,
    0,
    HID_MAPPING_NITRO);
  CTouchInterface::m_pWidgets[30] = v55;
  v56 = (CWidgetButtonSwapWeapons *)operator new(0xA8u);
  CWidgetButtonSwapWeapons::CWidgetButtonSwapWeapons(
    v56,
    CTouchInterface::m_pszWidgetTextures[29],
    &CTouchInterface::m_WidgetPosition[17]);
  CTouchInterface::m_pWidgets[29] = v57;
  v58 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v58,
    CTouchInterface::m_pszWidgetTextures[111],
    &CTouchInterface::m_WidgetPosition[20],
    1u,
    0xC04u,
    HID_MAPPING_GANG_IGNORE);
  CTouchInterface::m_pWidgets[111] = v59;
  v60 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v60,
    CTouchInterface::m_pszWidgetTextures[110],
    &CTouchInterface::m_WidgetPosition[21],
    1u,
    0x2C04u,
    HID_MAPPING_GANG_RECRUIT);
  CTouchInterface::m_pWidgets[110] = v61;
  v62 = (CWidgetRegionPoolEnglish *)operator new(0x90u);
  CWidgetRegionPoolEnglish::CWidgetRegionPoolEnglish(
    v62,
    CTouchInterface::m_pszWidgetTextures[35],
    &CTouchInterface::m_WidgetPosition[22]);
  CTouchInterface::m_pWidgets[35] = v63;
  *(_QWORD *)&v345.m_fOriginX = loc_2AE5D0;
  *(_QWORD *)&v345.m_fScaleX = loc_2AE5D8;
  v64 = (CWidgetRegionPoolBallInHand *)operator new(0x90u);
  CWidgetRegionPoolBallInHand::CWidgetRegionPoolBallInHand(v64, CTouchInterface::m_pszWidgetTextures[36], &v345);
  CTouchInterface::m_pWidgets[36] = v65;
  v66 = (CWidgetButtonAnimatedArcade *)operator new(0x1C0u);
  CWidgetButtonAnimatedArcade::CWidgetButtonAnimatedArcade(
    v66,
    CTouchInterface::m_pszWidgetTextures[37],
    "ArcadeGreenPressed",
    &CTouchInterface::m_WidgetPosition[23],
    0,
    0x1C14u,
    0,
    HID_MAPPING_ARCADE_BUTTON);
  CTouchInterface::m_pWidgets[37] = v67;
  v68 = (CWidgetButtonAnimated *)operator new(0x1C0u);
  CWidgetButtonAnimated::CWidgetButtonAnimated(
    v68,
    CTouchInterface::m_pszWidgetTextures[38],
    "ArcadeButton_ExitDown",
    &CTouchInterface::m_WidgetPosition[24],
    0,
    0x3C14u,
    HID_MAPPING_UNKNOWN,
    68);
  CTouchInterface::m_pWidgets[38] = v69;
  v70 = (CWidgetButtonAnimated *)operator new(0x1C0u);
  CWidgetButtonAnimated::CWidgetButtonAnimated(
    v70,
    CTouchInterface::m_pszWidgetTextures[39],
    "ArcadeButton_ResetDown",
    &CTouchInterface::m_WidgetPosition[25],
    0,
    0x1C14u,
    HID_MAPPING_UNKNOWN,
    69);
  CTouchInterface::m_pWidgets[39] = v71;
  v72 = (CWidgetRegionArcadeStick *)operator new(0x98u);
  CWidgetRegionArcadeStick::CWidgetRegionArcadeStick(
    v72,
    CTouchInterface::m_pszWidgetTextures[40],
    &CTouchInterface::m_WidgetPosition[26],
    7188,
    HID_MAPPING_ARCADE_JOYSTICK);
  CTouchInterface::m_pWidgets[40] = v73;
  v74 = (CWidgetButtonSkipCutscene *)operator new(0xA8u);
  CWidgetButtonSkipCutscene::CWidgetButtonSkipCutscene(
    v74,
    CTouchInterface::m_pszWidgetTextures[41],
    &CTouchInterface::m_WidgetPosition[27]);
  CTouchInterface::m_pWidgets[41] = v75;
  v76 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v76,
    CTouchInterface::m_pszWidgetTextures[42],
    &CTouchInterface::m_WidgetPosition[38],
    1u,
    0xC04u,
    HID_MAPPING_ACCEPT);
  CTouchInterface::m_pWidgets[42] = v77;
  v78 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v78,
    CTouchInterface::m_pszWidgetTextures[43],
    &CTouchInterface::m_WidgetPosition[37],
    1u,
    0xC04u,
    HID_MAPPING_GYM_ACTION);
  CTouchInterface::m_pWidgets[43] = v79;
  v80 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v80,
    CTouchInterface::m_pszWidgetTextures[44],
    &CTouchInterface::m_WidgetPosition[1],
    1u,
    4u,
    HID_MAPPING_CRANE_UP);
  CTouchInterface::m_pWidgets[44] = v81;
  v82 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v82,
    CTouchInterface::m_pszWidgetTextures[45],
    &CTouchInterface::m_WidgetPosition[12],
    1u,
    4u,
    HID_MAPPING_CRANE_DOWN);
  CTouchInterface::m_pWidgets[45] = v83;
  v84 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v84,
    CTouchInterface::m_pszWidgetTextures[46],
    &CTouchInterface::m_WidgetPosition[1],
    1u,
    0xC04u,
    HID_MAPPING_HELICOPTER_MAGNET_UP);
  CTouchInterface::m_pWidgets[46] = v85;
  v86 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v86,
    CTouchInterface::m_pszWidgetTextures[47],
    &CTouchInterface::m_WidgetPosition[12],
    1u,
    0xC04u,
    HID_MAPPING_HELICOPTER_MAGNET_DOWN);
  CTouchInterface::m_pWidgets[47] = v87;
  v88 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v88,
    CTouchInterface::m_pszWidgetTextures[48],
    &CTouchInterface::m_WidgetPosition[57],
    1u,
    0xC04u,
    HID_MAPPING_GYM_EASIER_LEVEL);
  CTouchInterface::m_pWidgets[48] = v89;
  v90 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v90,
    CTouchInterface::m_pszWidgetTextures[49],
    &CTouchInterface::m_WidgetPosition[58],
    1u,
    0xC04u,
    HID_MAPPING_GYM_HARDER_LEVEL);
  CTouchInterface::m_pWidgets[49] = v91;
  v92 = (CWidgetButtonZoom *)operator new(0xA8u);
  CWidgetButtonZoom::CWidgetButtonZoom(
    v92,
    CTouchInterface::m_pszWidgetTextures[50],
    &CTouchInterface::m_WidgetPosition[5],
    HID_MAPPING_WEAPON_ZOOM_IN);
  CTouchInterface::m_pWidgets[50] = v93;
  v94 = (CWidgetButtonZoom *)operator new(0xA8u);
  CWidgetButtonZoom::CWidgetButtonZoom(
    v94,
    CTouchInterface::m_pszWidgetTextures[51],
    &CTouchInterface::m_WidgetPosition[6],
    HID_MAPPING_WEAPON_ZOOM_OUT);
  CTouchInterface::m_pWidgets[51] = v95;
  v96 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v96,
    CTouchInterface::m_pszWidgetTextures[52],
    &CTouchInterface::m_WidgetPosition[28],
    1u,
    0xC04u,
    HID_MAPPING_MENU_LEFT);
  CTouchInterface::m_pWidgets[52] = v97;
  v98 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v98,
    CTouchInterface::m_pszWidgetTextures[53],
    &CTouchInterface::m_WidgetPosition[29],
    1u,
    0xC04u,
    HID_MAPPING_MENU_RIGHT);
  CTouchInterface::m_pWidgets[53] = v99;
  v100 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v100,
    CTouchInterface::m_pszWidgetTextures[54],
    &CTouchInterface::m_WidgetPosition[30],
    1u,
    0xC04u,
    HID_MAPPING_ACCEPT);
  CTouchInterface::m_pWidgets[54] = v101;
  v102 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v102,
    CTouchInterface::m_pszWidgetTextures[55],
    &CTouchInterface::m_WidgetPosition[31],
    1u,
    0x2C04u,
    HID_MAPPING_CANCEL);
  CTouchInterface::m_pWidgets[55] = v103;
  v104 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v104,
    CTouchInterface::m_pszWidgetTextures[56],
    &CTouchInterface::m_WidgetPosition[31],
    1u,
    0x2C04u,
    HID_MAPPING_CANCEL);
  CTouchInterface::m_pWidgets[56] = v105;
  v106 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v106,
    CTouchInterface::m_pszWidgetTextures[57],
    &CTouchInterface::m_WidgetPosition[32],
    1u,
    0xC04u,
    HID_MAPPING_ACCEPT);
  CTouchInterface::m_pWidgets[57] = v107;
  v108 = (CWidgetButton *)operator new(0xA8u);
  *(_QWORD *)&v344.m_fOriginX = 0LL;
  *(_QWORD *)&v344.m_fScaleX = 0x4120000041200000LL;
  CWidgetButton::CWidgetButton(v108, CTouchInterface::m_pszWidgetTextures[58], &v344, 1u, 0x414u, HID_MAPPING_MENU_UP);
  CTouchInterface::m_pWidgets[58] = v109;
  v110 = (CWidgetButton *)operator new(0xA8u);
  *(_QWORD *)&v344.m_fOriginX = 0LL;
  *(_QWORD *)&v344.m_fScaleX = 0x4120000041200000LL;
  CWidgetButton::CWidgetButton(v110, CTouchInterface::m_pszWidgetTextures[59], &v344, 1u, 0x414u, HID_MAPPING_MENU_DOWN);
  CTouchInterface::m_pWidgets[59] = v111;
  v112 = (CWidgetButton *)operator new(0xA8u);
  *(_QWORD *)&v344.m_fOriginX = 0LL;
  *(_QWORD *)&v344.m_fScaleX = 0x4120000041200000LL;
  CWidgetButton::CWidgetButton(v112, CTouchInterface::m_pszWidgetTextures[60], &v344, 1u, 0x414u, HID_MAPPING_MENU_LEFT);
  CTouchInterface::m_pWidgets[60] = v113;
  v114 = (CWidgetButton *)operator new(0xA8u);
  *(_QWORD *)&v344.m_fOriginX = 0LL;
  *(_QWORD *)&v344.m_fScaleX = 0x4120000041200000LL;
  CWidgetButton::CWidgetButton(
    v114,
    CTouchInterface::m_pszWidgetTextures[61],
    &v344,
    1u,
    0x414u,
    HID_MAPPING_MENU_RIGHT);
  CTouchInterface::m_pWidgets[61] = v115;
  v116 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v116,
    CTouchInterface::m_pszWidgetTextures[62],
    &CTouchInterface::m_WidgetPosition[18],
    1u,
    0xC04u,
    HID_MAPPING_PLACE_BET);
  CTouchInterface::m_pWidgets[62] = v117;
  v118 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v118,
    CTouchInterface::m_pszWidgetTextures[63],
    &CTouchInterface::m_WidgetPosition[19],
    1u,
    0xC04u,
    HID_MAPPING_REMOVE_BET);
  CTouchInterface::m_pWidgets[63] = v119;
  v120 = (CWidgetRegionSteeringSelection *)operator new(0x100u);
  CWidgetRegionSteeringSelection::CWidgetRegionSteeringSelection(
    v120,
    CTouchInterface::m_pszWidgetTextures[64],
    &CTouchInterface::m_WidgetPosition[33]);
  CTouchInterface::m_pWidgets[64] = v121;
  v122 = (CWidgetRegionTouchLayoutSelection *)operator new(0xE4u);
  CWidgetRegionTouchLayoutSelection::CWidgetRegionTouchLayoutSelection(
    v122,
    CTouchInterface::m_pszWidgetTextures[65],
    &CTouchInterface::m_WidgetPosition[34]);
  CTouchInterface::m_pWidgets[65] = v123;
  v124 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v124,
    CTouchInterface::m_pszWidgetTextures[66],
    &CTouchInterface::m_WidgetPosition[38],
    1u,
    0xC00u,
    HID_MAPPING_GRAB);
  CTouchInterface::m_pWidgets[66] = v125;
  v126 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v126,
    CTouchInterface::m_pszWidgetTextures[67],
    &CTouchInterface::m_WidgetPosition[12],
    1u,
    0xC00u,
    HID_MAPPING_MAGNET);
  CTouchInterface::m_pWidgets[67] = v127;
  v128 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v128,
    CTouchInterface::m_pszWidgetTextures[68],
    &CTouchInterface::m_WidgetPosition[38],
    1u,
    0xC00u,
    HID_MAPPING_STINGER);
  CTouchInterface::m_pWidgets[68] = v129;
  v130 = (CWidgetButtonMissionStart *)operator new(0xA8u);
  CWidgetButtonMissionStart::CWidgetButtonMissionStart(
    v130,
    CTouchInterface::m_pszWidgetTextures[69],
    &CTouchInterface::m_WidgetPosition[38],
    HID_MAPPING_MISSION_START_AND_CANCEL);
  CTouchInterface::m_pWidgets[69] = v131;
  v132 = (CWidgetButtonMissionCancel *)operator new(0xA8u);
  CWidgetButtonMissionCancel::CWidgetButtonMissionCancel(
    v132,
    CTouchInterface::m_pszWidgetTextures[71],
    &CTouchInterface::m_WidgetPosition[38],
    HID_MAPPING_MISSION_START_AND_CANCEL);
  CTouchInterface::m_pWidgets[71] = v133;
  v134 = (CWidgetButtonMissionStart *)operator new(0xA8u);
  CWidgetButtonMissionStart::CWidgetButtonMissionStart(
    v134,
    CTouchInterface::m_pszWidgetTextures[70],
    &CTouchInterface::m_WidgetPosition[38],
    HID_MAPPING_MISSION_START_AND_CANCEL_VIGILANTE);
  CTouchInterface::m_pWidgets[70] = v135;
  v136 = (CWidgetButtonMissionCancel *)operator new(0xA8u);
  CWidgetButtonMissionCancel::CWidgetButtonMissionCancel(
    v136,
    CTouchInterface::m_pszWidgetTextures[72],
    &CTouchInterface::m_WidgetPosition[38],
    HID_MAPPING_MISSION_START_AND_CANCEL_VIGILANTE);
  CTouchInterface::m_pWidgets[72] = v137;
  v138 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v138,
    CTouchInterface::m_pszWidgetTextures[73],
    CTouchInterface::m_WidgetPosition,
    1u,
    0xC80u,
    HID_MAPPING_MISSION_START_AND_CANCEL);
  CTouchInterface::m_pWidgets[73] = v139;
  v140 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v140,
    CTouchInterface::m_pszWidgetTextures[74],
    &CTouchInterface::m_WidgetPosition[132],
    1u,
    0x2C14u,
    HID_MAPPING_MISSION_START_AND_CANCEL);
  CTouchInterface::m_pWidgets[74] = v141;
  v142 = (CWidgetInfoFrame *)operator new(0xB0u);
  CWidgetInfoFrame::CWidgetInfoFrame(
    v142,
    CTouchInterface::m_pszWidgetTextures[80],
    &CTouchInterface::m_WidgetPosition[45]);
  v144 = *(_DWORD *)(v143 + 128);
  CTouchInterface::m_pWidgets[80] = (CWidget *)v143;
  *(_DWORD *)(v143 + 28) = 1176255488;
  *(_DWORD *)(v143 + 128) = v144 & 0xFFFFFFEF;
  v145 = (CWidgetInfoFrame *)operator new(0xB0u);
  CWidgetInfoFrame::CWidgetInfoFrame(
    v145,
    CTouchInterface::m_pszWidgetTextures[81],
    &CTouchInterface::m_WidgetPosition[46]);
  m_nFlags = v146->m_nFlags;
  CTouchInterface::m_pWidgets[81] = v146;
  v146->m_nFlags = m_nFlags & 0xFFFFFFEF;
  v148 = (CWidgetInfoFrame *)operator new(0xB0u);
  CWidgetInfoFrame::CWidgetInfoFrame(
    v148,
    CTouchInterface::m_pszWidgetTextures[82],
    &CTouchInterface::m_WidgetPosition[47]);
  v150 = v149->m_nFlags;
  CTouchInterface::m_pWidgets[82] = v149;
  v149->m_nFlags = v150 & 0xFFFFFFEF;
  v151 = (CWidgetInfoFrame *)operator new(0xB0u);
  CWidgetInfoFrame::CWidgetInfoFrame(
    v151,
    CTouchInterface::m_pszWidgetTextures[83],
    &CTouchInterface::m_WidgetPosition[48]);
  v153 = v152->m_nFlags;
  CTouchInterface::m_pWidgets[83] = v152;
  v152->m_nFlags = v153 & 0xFFFFFFEF;
  v154 = (CWidgetInfoFrame *)operator new(0xB0u);
  CWidgetInfoFrame::CWidgetInfoFrame(
    v154,
    CTouchInterface::m_pszWidgetTextures[84],
    &CTouchInterface::m_WidgetPosition[49]);
  v156 = v155->m_nFlags;
  CTouchInterface::m_pWidgets[84] = v155;
  v155->m_nFlags = v156 & 0xFFFFFFEF;
  v157 = (CWidgetInfoFrame *)operator new(0xB0u);
  CWidgetInfoFrame::CWidgetInfoFrame(
    v157,
    CTouchInterface::m_pszWidgetTextures[85],
    &CTouchInterface::m_WidgetPosition[50]);
  v159 = v158->m_nFlags;
  CTouchInterface::m_pWidgets[85] = v158;
  v158->m_nFlags = v159 & 0xFFFFFFEF;
  v160 = (CWidgetInfoFrame *)operator new(0xB0u);
  CWidgetInfoFrame::CWidgetInfoFrame(
    v160,
    CTouchInterface::m_pszWidgetTextures[86],
    &CTouchInterface::m_WidgetPosition[51]);
  v162 = v161->m_nFlags;
  CTouchInterface::m_pWidgets[86] = v161;
  v161->m_nFlags = v162 & 0xFFFFFFEF;
  v163 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v163,
    CTouchInterface::m_pszWidgetTextures[79],
    &CTouchInterface::m_WidgetPosition[44],
    1u,
    0xC14u,
    HID_MAPPING_ACCEPT);
  CTouchInterface::m_pWidgets[79] = v164;
  v165 = (CWidgetButtonSchool *)operator new(0x1A8u);
  CWidgetButtonSchool::CWidgetButtonSchool(
    v165,
    CTouchInterface::m_pszWidgetTextures[76],
    &CTouchInterface::m_WidgetPosition[41],
    0,
    5140,
    HID_MAPPING_MENU_LEFT);
  CTouchInterface::m_pWidgets[76] = v166;
  v167 = (CWidgetButtonSchool *)operator new(0x1A8u);
  CWidgetButtonSchool::CWidgetButtonSchool(
    v167,
    CTouchInterface::m_pszWidgetTextures[77],
    &CTouchInterface::m_WidgetPosition[42],
    0,
    5140,
    HID_MAPPING_MENU_RIGHT);
  CTouchInterface::m_pWidgets[77] = v168;
  v169 = (CWidgetButtonSchool *)operator new(0x1A8u);
  CWidgetButtonSchool::CWidgetButtonSchool(
    v169,
    CTouchInterface::m_pszWidgetTextures[75],
    &CTouchInterface::m_WidgetPosition[40],
    "EXIT",
    15380,
    HID_MAPPING_MENU_BACK);
  CTouchInterface::m_pWidgets[75] = v170;
  v171 = (CWidgetButtonSchool *)operator new(0x1A8u);
  CWidgetButtonSchool::CWidgetButtonSchool(
    v171,
    CTouchInterface::m_pszWidgetTextures[78],
    &CTouchInterface::m_WidgetPosition[43],
    "START",
    7188,
    HID_MAPPING_MENU_ACCEPT);
  CTouchInterface::m_pWidgets[78] = v172;
  CTouchInterface::m_pWidgets[76]->m_fFadeRate = 9999.0;
  CTouchInterface::m_pWidgets[77]->m_fFadeRate = 9999.0;
  CTouchInterface::m_pWidgets[75]->m_fFadeRate = 9999.0;
  CTouchInterface::m_pWidgets[78]->m_fFadeRate = 9999.0;
  CTouchInterface::m_pWidgets[78]->m_fExtraPaddingScale = 1.75;
  CTouchInterface::m_pWidgets[75]->m_fExtraPaddingScale = 1.75;
  CTouchInterface::m_pWidgets[76]->m_fExtraPaddingScale = 3.0;
  CTouchInterface::m_pWidgets[77]->m_fExtraPaddingScale = 3.0;
  v173 = (CWidgetButtonBasketballShoot *)operator new(0xA8u);
  CWidgetButtonBasketballShoot::CWidgetButtonBasketballShoot(
    v173,
    CTouchInterface::m_pszWidgetTextures[87],
    &CTouchInterface::m_WidgetPosition[52]);
  CTouchInterface::m_pWidgets[87] = v174;
  v175 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v175,
    CTouchInterface::m_pszWidgetTextures[88],
    &CTouchInterface::m_WidgetPosition[53],
    1u,
    4u,
    HID_MAPPING_JUMP);
  CTouchInterface::m_pWidgets[88] = v176;
  v177 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v177,
    CTouchInterface::m_pszWidgetTextures[89],
    &CTouchInterface::m_WidgetPosition[54],
    1u,
    0x2C14u,
    HID_MAPPING_CANCEL);
  CTouchInterface::m_pWidgets[89] = v178;
  v179 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v179,
    CTouchInterface::m_pszWidgetTextures[90],
    &CTouchInterface::m_WidgetPosition[55],
    1u,
    0xC14u,
    HID_MAPPING_ACCEPT);
  CTouchInterface::m_pWidgets[90] = v180;
  v181 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v181,
    CTouchInterface::m_pszWidgetTextures[91],
    &CTouchInterface::m_WidgetPosition[56],
    1u,
    0xC04u,
    HID_MAPPING_BLACK_JACK_SPLIT);
  CTouchInterface::m_pWidgets[91] = v182;
  v183 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v183,
    CTouchInterface::m_pszWidgetTextures[92],
    &CTouchInterface::m_WidgetPosition[57],
    1u,
    0xC04u,
    HID_MAPPING_BLACK_JACK_DOUBLE);
  CTouchInterface::m_pWidgets[92] = v184;
  v185 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v185,
    CTouchInterface::m_pszWidgetTextures[93],
    &CTouchInterface::m_WidgetPosition[58],
    1u,
    0xC04u,
    HID_MAPPING_BLACK_JACK_HIT);
  CTouchInterface::m_pWidgets[93] = v186;
  v187 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v187,
    CTouchInterface::m_pszWidgetTextures[94],
    &CTouchInterface::m_WidgetPosition[59],
    1u,
    0xC04u,
    HID_MAPPING_BLACK_JACK_STAND);
  CTouchInterface::m_pWidgets[94] = v188;
  v189 = (CWidgetRegion *)operator new(0x90u);
  CWidgetRegion::CWidgetRegion(
    v189,
    CTouchInterface::m_pszWidgetTextures[95],
    &CTouchInterface::m_WidgetPosition[60],
    4,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[95] = v190;
  v191 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v191,
    CTouchInterface::m_pszWidgetTextures[97],
    &CTouchInterface::m_WidgetPosition[62],
    1u,
    4u,
    HID_MAPPING_RHYTHM_UP);
  CTouchInterface::m_pWidgets[97] = v192;
  v193 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v193,
    CTouchInterface::m_pszWidgetTextures[98],
    &CTouchInterface::m_WidgetPosition[63],
    1u,
    4u,
    HID_MAPPING_RHYTHM_DOWN);
  CTouchInterface::m_pWidgets[98] = v194;
  v195 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v195,
    CTouchInterface::m_pszWidgetTextures[99],
    &CTouchInterface::m_WidgetPosition[64],
    1u,
    4u,
    HID_MAPPING_RHYTHM_LEFT);
  CTouchInterface::m_pWidgets[99] = v196;
  v197 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v197,
    CTouchInterface::m_pszWidgetTextures[100],
    &CTouchInterface::m_WidgetPosition[65],
    1u,
    4u,
    HID_MAPPING_RHYTHM_RIGHT);
  CTouchInterface::m_pWidgets[100] = v198;
  v199 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v199,
    CTouchInterface::m_pszWidgetTextures[102],
    &CTouchInterface::m_WidgetPosition[67],
    1u,
    0x2C04u,
    HID_MAPPING_MISSION_START_AND_CANCEL);
  CTouchInterface::m_pWidgets[102] = v200;
  v201 = (CWidgetInfoFrame *)operator new(0xB0u);
  CWidgetInfoFrame::CWidgetInfoFrame(
    v201,
    CTouchInterface::m_pszWidgetTextures[83],
    &CTouchInterface::m_WidgetPosition[68]);
  CTouchInterface::m_pWidgets[103] = v202;
  v203 = (CWidgetInfoFrame *)operator new(0xB0u);
  CWidgetInfoFrame::CWidgetInfoFrame(
    v203,
    CTouchInterface::m_pszWidgetTextures[83],
    &CTouchInterface::m_WidgetPosition[69]);
  CTouchInterface::m_pWidgets[104] = v204;
  v205 = (CWidgetButton *)operator new(0xA8u);
  *(_QWORD *)&v344.m_fOriginX = 0LL;
  *(_QWORD *)&v344.m_fScaleX = 0x4120000041200000LL;
  CWidgetButton::CWidgetButton(
    v205,
    CTouchInterface::m_pszWidgetTextures[106],
    &v344,
    1u,
    0xC04u,
    HID_MAPPING_GANG_RECRUIT);
  CTouchInterface::m_pWidgets[106] = v206;
  v207 = (CWidgetButton *)operator new(0xA8u);
  *(_QWORD *)&v344.m_fOriginX = 0LL;
  *(_QWORD *)&v344.m_fScaleX = 0x4120000041200000LL;
  CWidgetButton::CWidgetButton(
    v207,
    CTouchInterface::m_pszWidgetTextures[107],
    &v344,
    1u,
    0xC04u,
    HID_MAPPING_GANG_IGNORE);
  CTouchInterface::m_pWidgets[107] = v208;
  v209 = (CWidgetButton *)operator new(0xA8u);
  *(_QWORD *)&v344.m_fOriginX = 0LL;
  *(_QWORD *)&v344.m_fScaleX = 0x4120000041200000LL;
  CWidgetButton::CWidgetButton(
    v209,
    CTouchInterface::m_pszWidgetTextures[108],
    &v344,
    1u,
    0xC04u,
    HID_MAPPING_GANG_FOLLOW);
  CTouchInterface::m_pWidgets[108] = v210;
  v211 = (CWidgetButton *)operator new(0xA8u);
  *(_QWORD *)&v344.m_fOriginX = 0LL;
  *(_QWORD *)&v344.m_fScaleX = 0x4120000041200000LL;
  CWidgetButton::CWidgetButton(
    v211,
    CTouchInterface::m_pszWidgetTextures[109],
    &v344,
    1u,
    0xC04u,
    HID_MAPPING_GANG_HOLD_POSITION);
  CTouchInterface::m_pWidgets[109] = v211;
  CRGBA::CRGBA(&v343, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
  CWidget::CreateHoldEffect(v211, "hud_ticks", 0, (CRGBA)&v343, 0);
  v212 = (CWidgetRegionGang *)operator new(0xA8u);
  CWidgetRegionGang::CWidgetRegionGang(
    v212,
    CTouchInterface::m_pszWidgetTextures[105],
    &CTouchInterface::m_WidgetPosition[70]);
  CTouchInterface::m_pWidgets[105] = v213;
  v214 = &CTouchInterface::m_WidgetPosition[71];
  if ( v341 == OSDF_Phone )
    v214 = &CTouchInterface::m_WidgetPosition[72];
  v215 = (CWidgetRegionColorPicker *)operator new(0x90u);
  CWidgetRegionColorPicker::CWidgetRegionColorPicker(v215, CTouchInterface::m_pszWidgetTextures[112], v214);
  CTouchInterface::m_pWidgets[112] = v216;
  v217 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v217,
    CTouchInterface::m_pszWidgetTextures[115],
    &CTouchInterface::m_WidgetPosition[73],
    0,
    4u,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[115] = v218;
  v219 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v219,
    CTouchInterface::m_pszWidgetTextures[116],
    &CTouchInterface::m_WidgetPosition[74],
    0,
    4u,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[116] = v220;
  v221 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v221,
    CTouchInterface::m_pszWidgetTextures[117],
    &CTouchInterface::m_WidgetPosition[75],
    0,
    4u,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[117] = v222;
  v223 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v223,
    CTouchInterface::m_pszWidgetTextures[118],
    &CTouchInterface::m_WidgetPosition[76],
    0,
    4u,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[118] = v224;
  v225 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v225,
    CTouchInterface::m_pszWidgetTextures[119],
    &CTouchInterface::m_WidgetPosition[77],
    0,
    4u,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[119] = v226;
  v227 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v227,
    CTouchInterface::m_pszWidgetTextures[120],
    &CTouchInterface::m_WidgetPosition[78],
    0,
    4u,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[120] = v228;
  v229 = (CWidgetButtonAnimated *)operator new(0x1C0u);
  CWidgetButtonAnimated::CWidgetButtonAnimated(
    v229,
    "ArrowRight",
    "ArrowRightPressed",
    &CTouchInterface::m_WidgetPosition[79],
    0,
    0x1C14u,
    (HIDMapping)&byte_61CADE,
    56);
  CTouchInterface::m_pWidgets[121] = v230;
  v231 = (CWidgetButtonAnimated *)operator new(0x1C0u);
  CWidgetButtonAnimated::CWidgetButtonAnimated(
    v231,
    "ArrowLeft",
    "ArrowLeftPressed",
    &CTouchInterface::m_WidgetPosition[80],
    0,
    0x1C14u,
    (HIDMapping)&byte_61CADE,
    56);
  CTouchInterface::m_pWidgets[122] = v232;
  v233 = (CWidgetButtonAnimated *)operator new(0x1C0u);
  CWidgetButtonAnimated::CWidgetButtonAnimated(
    v233,
    "HoldButton",
    "HoldButtonPressed",
    &CTouchInterface::m_WidgetPosition[81],
    0,
    0x1C14u,
    (HIDMapping)"VP19",
    56);
  CTouchInterface::m_pWidgets[124] = v234;
  v235 = (CWidgetButtonAnimated *)operator new(0x1C0u);
  CWidgetButtonAnimated::CWidgetButtonAnimated(
    v235,
    "HoldButton",
    "HoldButtonPressed",
    &CTouchInterface::m_WidgetPosition[82],
    0,
    0x1C14u,
    (HIDMapping)"VP19",
    56);
  CTouchInterface::m_pWidgets[125] = v236;
  v237 = (CWidgetButtonAnimated *)operator new(0x1C0u);
  CWidgetButtonAnimated::CWidgetButtonAnimated(
    v237,
    "HoldButton",
    "HoldButtonPressed",
    &CTouchInterface::m_WidgetPosition[83],
    0,
    0x1C14u,
    (HIDMapping)"VP19",
    56);
  CTouchInterface::m_pWidgets[126] = v238;
  v239 = (CWidgetButtonAnimated *)operator new(0x1C0u);
  CWidgetButtonAnimated::CWidgetButtonAnimated(
    v239,
    "HoldButton",
    "HoldButtonPressed",
    &CTouchInterface::m_WidgetPosition[84],
    0,
    0x1C14u,
    (HIDMapping)"VP19",
    56);
  CTouchInterface::m_pWidgets[127] = v240;
  v241 = (CWidgetButtonAnimated *)operator new(0x1C0u);
  CWidgetButtonAnimated::CWidgetButtonAnimated(
    v241,
    "HoldButton",
    "HoldButtonPressed",
    &CTouchInterface::m_WidgetPosition[85],
    0,
    0x1C14u,
    (HIDMapping)"VP19",
    56);
  CTouchInterface::m_pWidgets[128] = v242;
  v243 = (CWidgetRegion *)operator new(0x90u);
  CWidgetRegion::CWidgetRegion(
    v243,
    (const unsigned __int8 *)&byte_61CADE,
    &CTouchInterface::m_WidgetPosition[86],
    4116,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[129] = v244;
  v245 = (CWidgetRegion *)operator new(0x90u);
  CWidgetRegion::CWidgetRegion(
    v245,
    (const unsigned __int8 *)&byte_61CADE,
    &CTouchInterface::m_WidgetPosition[87],
    4116,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[130] = v246;
  v247 = (CWidgetRegion *)operator new(0x90u);
  CWidgetRegion::CWidgetRegion(
    v247,
    (const unsigned __int8 *)&byte_61CADE,
    &CTouchInterface::m_WidgetPosition[88],
    4116,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[131] = v248;
  v249 = (CWidgetRegion *)operator new(0x90u);
  CWidgetRegion::CWidgetRegion(
    v249,
    (const unsigned __int8 *)&byte_61CADE,
    &CTouchInterface::m_WidgetPosition[89],
    4116,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[132] = v250;
  v251 = (CWidgetRegion *)operator new(0x90u);
  CWidgetRegion::CWidgetRegion(
    v251,
    (const unsigned __int8 *)&byte_61CADE,
    &CTouchInterface::m_WidgetPosition[90],
    4116,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[133] = v252;
  v253 = (CWidgetButtonAnimated *)operator new(0x1C0u);
  CWidgetButtonAnimated::CWidgetButtonAnimated(
    v253,
    "PokerButton",
    "PokerButtonPressed",
    &CTouchInterface::m_WidgetPosition[91],
    0,
    0x3C14u,
    (HIDMapping)"EXIT",
    56);
  CTouchInterface::m_pWidgets[134] = v254;
  v255 = (CWidgetButtonAnimated *)operator new(0x1C0u);
  CWidgetButtonAnimated::CWidgetButtonAnimated(
    v255,
    "PokerButton",
    "PokerButtonPressed",
    &CTouchInterface::m_WidgetPosition[92],
    0,
    0x1C14u,
    (HIDMapping)"VP21",
    56);
  CTouchInterface::m_pWidgets[123] = v256;
  CTouchInterface::m_pWidgets[121]->m_fFadeRate = 9999.9;
  CTouchInterface::m_pWidgets[122]->m_fFadeRate = 9999.9;
  CTouchInterface::m_pWidgets[124]->m_fFadeRate = 9999.9;
  CTouchInterface::m_pWidgets[125]->m_fFadeRate = 9999.9;
  CTouchInterface::m_pWidgets[126]->m_fFadeRate = 9999.9;
  CTouchInterface::m_pWidgets[127]->m_fFadeRate = 9999.9;
  CTouchInterface::m_pWidgets[128]->m_fFadeRate = 9999.9;
  CTouchInterface::m_pWidgets[123]->m_fFadeRate = 9999.9;
  CTouchInterface::m_pWidgets[134]->m_fFadeRate = 9999.9;
  v257 = (CWidgetRegion *)operator new(0x90u);
  CWidgetRegion::CWidgetRegion(
    v257,
    CTouchInterface::m_pszWidgetTextures[135],
    &CTouchInterface::m_WidgetPosition[93],
    4116,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[135] = v258;
  v259 = (CWidgetRegion *)operator new(0x90u);
  CWidgetRegion::CWidgetRegion(
    v259,
    CTouchInterface::m_pszWidgetTextures[136],
    &CTouchInterface::m_WidgetPosition[94],
    4116,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[136] = v260;
  v261 = (CWidgetRegion *)operator new(0x90u);
  CWidgetRegion::CWidgetRegion(
    v261,
    CTouchInterface::m_pszWidgetTextures[137],
    &CTouchInterface::m_WidgetPosition[95],
    4116,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[137] = v262;
  v263 = (CWidgetRegion *)operator new(0x90u);
  CWidgetRegion::CWidgetRegion(
    v263,
    CTouchInterface::m_pszWidgetTextures[138],
    &CTouchInterface::m_WidgetPosition[96],
    4116,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[138] = v264;
  v265 = (CWidgetRegion *)operator new(0x90u);
  CWidgetRegion::CWidgetRegion(
    v265,
    CTouchInterface::m_pszWidgetTextures[139],
    &CTouchInterface::m_WidgetPosition[97],
    4116,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[139] = v266;
  v267 = (CWidgetRegion *)operator new(0x90u);
  CWidgetRegion::CWidgetRegion(
    v267,
    CTouchInterface::m_pszWidgetTextures[140],
    &CTouchInterface::m_WidgetPosition[98],
    4116,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[140] = v268;
  v269 = (CWidgetRegion *)operator new(0x90u);
  CWidgetRegion::CWidgetRegion(
    v269,
    CTouchInterface::m_pszWidgetTextures[141],
    &CTouchInterface::m_WidgetPosition[99],
    4116,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[141] = v270;
  v271 = (CWidgetRegion *)operator new(0x90u);
  CWidgetRegion::CWidgetRegion(
    v271,
    CTouchInterface::m_pszWidgetTextures[142],
    &CTouchInterface::m_WidgetPosition[100],
    4116,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[142] = v272;
  v273 = (CWidgetRegion *)operator new(0x90u);
  CWidgetRegion::CWidgetRegion(
    v273,
    CTouchInterface::m_pszWidgetTextures[143],
    &CTouchInterface::m_WidgetPosition[101],
    4116,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[143] = v274;
  v275 = (CWidgetRegion *)operator new(0x90u);
  CWidgetRegion::CWidgetRegion(
    v275,
    CTouchInterface::m_pszWidgetTextures[144],
    &CTouchInterface::m_WidgetPosition[102],
    4116,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[144] = v276;
  v277 = (CWidgetRegion *)operator new(0x90u);
  CWidgetRegion::CWidgetRegion(
    v277,
    CTouchInterface::m_pszWidgetTextures[145],
    &CTouchInterface::m_WidgetPosition[103],
    4116,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[145] = v278;
  v279 = (CWidgetRegion *)operator new(0x90u);
  CWidgetRegion::CWidgetRegion(
    v279,
    CTouchInterface::m_pszWidgetTextures[146],
    &CTouchInterface::m_WidgetPosition[104],
    4116,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[146] = v280;
  v281 = (CWidgetRegion *)operator new(0x90u);
  CWidgetRegion::CWidgetRegion(
    v281,
    CTouchInterface::m_pszWidgetTextures[147],
    &CTouchInterface::m_WidgetPosition[105],
    4116,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[147] = v282;
  v283 = (CWidgetRegion *)operator new(0x90u);
  CWidgetRegion::CWidgetRegion(
    v283,
    CTouchInterface::m_pszWidgetTextures[148],
    &CTouchInterface::m_WidgetPosition[106],
    4116,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[148] = v284;
  v285 = (CWidgetButtonAnimated *)operator new(0x1C0u);
  CWidgetButtonAnimated::CWidgetButtonAnimated(
    v285,
    (const unsigned __int8 *)&byte_61CADE,
    (const unsigned __int8 *)&byte_61CADE,
    &CTouchInterface::m_WidgetPosition[107],
    0,
    0x3C14u,
    (HIDMapping)"EXIT",
    57);
  CTouchInterface::m_pWidgets[149] = v286;
  v287 = (CWidgetMap *)operator new(0x90u);
  CWidgetMap::CWidgetMap(v287, CTouchInterface::m_pszWidgetTextures[150], &CTouchInterface::m_WidgetPosition[108]);
  CTouchInterface::m_pWidgets[150] = v288;
  v289 = (CWidgetRegionResponse *)operator new(0x94u);
  CWidgetRegionResponse::CWidgetRegionResponse(
    v289,
    CTouchInterface::m_pszWidgetTextures[157],
    &CTouchInterface::m_WidgetPosition[109]);
  CTouchInterface::m_pWidgets[157] = v290;
  v291 = (CWidgetPlayerInfo *)operator new(0xB8u);
  CWidgetPlayerInfo::CWidgetPlayerInfo(
    v291,
    CTouchInterface::m_pszWidgetTextures[160],
    &CTouchInterface::m_WidgetPosition[112]);
  CTouchInterface::m_pWidgets[160] = v292;
  v293 = (CWidgetRadar *)operator new(0x94u);
  CWidgetRadar::CWidgetRadar(v293, CTouchInterface::m_pszWidgetTextures[161], &CTouchInterface::m_WidgetPosition[113]);
  CTouchInterface::m_pWidgets[161] = v294;
  v295 = (CWidgetHelpText *)operator new(0x20C0u);
  CWidgetHelpText::CWidgetHelpText(
    v295,
    CTouchInterface::m_pszWidgetTextures[162],
    &CTouchInterface::m_WidgetPosition[114]);
  CTouchInterface::m_pWidgets[162] = v295;
  if ( CTouchInterface::m_pWidgets[164] )
  {
    (*((void (__fastcall **)(CWidget *))CTouchInterface::m_pWidgets[164]->_vptr$CWidget + 1))(CTouchInterface::m_pWidgets[164]);
    CTouchInterface::m_pWidgets[164] = 0;
  }
  v296 = (CWidgetThumbCircle *)operator new(0xE8u);
  CWidgetThumbCircle::CWidgetThumbCircle(
    v296,
    CTouchInterface::m_pszWidgetTextures[164],
    &CTouchInterface::m_WidgetPosition[35]);
  CTouchInterface::m_pWidgets[164] = v296;
  if ( CTouchInterface::m_pWidgets[163] )
  {
    (*((void (__fastcall **)(CWidget *))CTouchInterface::m_pWidgets[163]->_vptr$CWidget + 1))(CTouchInterface::m_pWidgets[163]);
    CTouchInterface::m_pWidgets[163] = 0;
  }
  v297 = (CWidgetTapMeter *)operator new(0xBCu);
  CWidgetTapMeter::CWidgetTapMeter(
    v297,
    CTouchInterface::m_pszWidgetTextures[163],
    &CTouchInterface::m_WidgetPosition[36]);
  CTouchInterface::m_pWidgets[163] = v298;
  v299 = (CWidgetRegionSwipeRadio *)operator new(0x90u);
  CWidgetRegionSwipeRadio::CWidgetRegionSwipeRadio(
    v299,
    CTouchInterface::m_pszWidgetTextures[166],
    &CTouchInterface::m_WidgetPosition[117]);
  CTouchInterface::m_pWidgets[166] = v300;
  v301 = (CWidgetRegionMove *)operator new(0xACu);
  CWidgetRegionMove::CWidgetRegionMove(
    v301,
    CTouchInterface::m_pszWidgetTextures[167],
    &CTouchInterface::m_WidgetPosition[118]);
  CTouchInterface::m_pWidgets[167] = v302;
  v303 = (CWidgetRegionBasketBallJump *)operator new(0x94u);
  CWidgetRegionBasketBallJump::CWidgetRegionBasketBallJump(
    v303,
    CTouchInterface::m_pszWidgetTextures[169],
    &CTouchInterface::m_WidgetPosition[119]);
  CTouchInterface::m_pWidgets[169] = v304;
  v305 = (CWidgetRegion *)operator new(0x90u);
  CWidgetRegion::CWidgetRegion(
    v305,
    CTouchInterface::m_pszWidgetTextures[174],
    &CTouchInterface::m_WidgetPosition[112],
    0,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[174] = v306;
  v307 = (CWidgetRegionLook *)operator new(0x94u);
  CWidgetRegionLook::CWidgetRegionLook(
    v307,
    CTouchInterface::m_pszWidgetTextures[175],
    &CTouchInterface::m_WidgetPosition[123]);
  CTouchInterface::m_pWidgets[175] = v308;
  v309 = (CWidgetMissionTimers *)operator new(0x90u);
  CWidgetMissionTimers::CWidgetMissionTimers(
    v309,
    CTouchInterface::m_pszWidgetTextures[176],
    &CTouchInterface::m_WidgetPosition[124]);
  CTouchInterface::m_pWidgets[176] = v310;
  v311 = (CWidgetRacing *)operator new(0xA4u);
  CWidgetRacing::CWidgetRacing(v311, CTouchInterface::m_pszWidgetTextures[177], &CTouchInterface::m_WidgetPosition[125]);
  CTouchInterface::m_pWidgets[177] = v312;
  v313 = (CWidgetRaceResults *)operator new(0x64Cu);
  CWidgetRaceResults::CWidgetRaceResults(
    v313,
    CTouchInterface::m_pszWidgetTextures[178],
    &CTouchInterface::m_WidgetPosition[126]);
  CTouchInterface::m_pWidgets[178] = v314;
  v315 = (CWidgetHorseResults *)operator new(0x7E4u);
  CWidgetHorseResults::CWidgetHorseResults(
    v315,
    CTouchInterface::m_pszWidgetTextures[179],
    &CTouchInterface::m_WidgetPosition[127]);
  CTouchInterface::m_pWidgets[179] = v316;
  v317 = (CWidgetWager *)operator new(0x544u);
  CWidgetWager::CWidgetWager(v317, CTouchInterface::m_pszWidgetTextures[180], &CTouchInterface::m_WidgetPosition[128]);
  CTouchInterface::m_pWidgets[180] = v318;
  v319 = (CWidgetPool *)operator new(0x2A8u);
  CWidgetPool::CWidgetPool(v319, CTouchInterface::m_pszWidgetTextures[181], &CTouchInterface::m_WidgetPosition[129]);
  CTouchInterface::m_pWidgets[181] = v320;
  v321 = (CWidgetVitalStats *)operator new(0x90u);
  CWidgetVitalStats::CWidgetVitalStats(
    v321,
    CTouchInterface::m_pszWidgetTextures[183],
    &CTouchInterface::m_WidgetPosition[131]);
  CTouchInterface::m_pWidgets[183] = v322;
  v323 = (CWidgetRouletteSpin *)operator new(0x98u);
  CWidgetRouletteSpin::CWidgetRouletteSpin(v323);
  CTouchInterface::m_pWidgets[184] = v324;
  v325 = (CWidgetInfoFrame *)operator new(0xB0u);
  CWidgetInfoFrame::CWidgetInfoFrame(
    v325,
    CTouchInterface::m_pszWidgetTextures[182],
    &CTouchInterface::m_WidgetPosition[130]);
  CTouchInterface::m_pWidgets[182] = v326;
  v327 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v327,
    CTouchInterface::m_pszWidgetTextures[33],
    &CTouchInterface::m_WidgetPosition[15],
    1u,
    0x40u,
    HID_MAPPING_ATTACK);
  CTouchInterface::m_pWidgets[33] = v328;
  v329 = (CWidgetRegion *)operator new(0x90u);
  CWidgetRegion::CWidgetRegion(
    v329,
    CTouchInterface::m_pszWidgetTextures[185],
    &CTouchInterface::m_WidgetPosition[133],
    4,
    HID_MAPPING_MENU_LEFT);
  CTouchInterface::m_pWidgets[185] = v330;
  v331 = (CWidgetRegion *)operator new(0x90u);
  CWidgetRegion::CWidgetRegion(
    v331,
    CTouchInterface::m_pszWidgetTextures[186],
    &CTouchInterface::m_WidgetPosition[134],
    4,
    HID_MAPPING_MENU_RIGHT);
  CTouchInterface::m_pWidgets[186] = v332;
  v333 = (CWidgetButton *)operator new(0xA8u);
  CWidgetButton::CWidgetButton(
    v333,
    CTouchInterface::m_pszWidgetTextures[187],
    &CTouchInterface::m_WidgetPosition[14],
    1u,
    0xC00u,
    HID_MAPPING_ATTACK);
  CTouchInterface::m_pWidgets[187] = v334;
  v335 = (CWidgetRegion *)operator new(0x90u);
  CWidgetRegion::CWidgetRegion(
    v335,
    CTouchInterface::m_pszWidgetTextures[188],
    &CTouchInterface::m_WidgetPosition[135],
    0,
    HID_MAPPING_UNKNOWN);
  CTouchInterface::m_pWidgets[188] = v336;
  v337 = (CWidgetSaveNotification *)operator new(0x98u);
  CWidgetSaveNotification::CWidgetSaveNotification(
    v337,
    CTouchInterface::m_pszWidgetTextures[189],
    &CTouchInterface::m_WidgetPosition[136]);
  CTouchInterface::m_pWidgets[189] = v338;
  v339 = (CWidgetReplay *)operator new(0xA0u);
  CWidgetReplay::CWidgetReplay(v339, CTouchInterface::m_pszWidgetTextures[159], &CTouchInterface::m_WidgetPosition[137]);
  CTouchInterface::m_pWidgets[159] = v340;
  CTouchInterface::SetupLayoutObjects();
  CTouchInterface::SetupSteeringMode();
  TextureDatabaseRuntime::Unregister(toUnregister);
}
// 2AE640: variable 'v3' is possibly undefined
// 2AE660: variable 'v5' is possibly undefined
// 2AE672: variable 'v7' is possibly undefined
// 2AE68A: variable 'v9' is possibly undefined
// 2AE6AC: variable 'v11' is possibly undefined
// 2AE6CE: variable 'v13' is possibly undefined
// 2AE6EE: variable 'v15' is possibly undefined
// 2AE70A: variable 'v17' is possibly undefined
// 2AE72A: variable 'v19' is possibly undefined
// 2AE74A: variable 'v21' is possibly undefined
// 2AE764: variable 'v23' is possibly undefined
// 2AE77E: variable 'v25' is possibly undefined
// 2AE794: variable 'v27' is possibly undefined
// 2AE7A8: variable 'v29' is possibly undefined
// 2AE7BE: variable 'v31' is possibly undefined
// 2AE7D4: variable 'v33' is possibly undefined
// 2AE7EC: variable 'v35' is possibly undefined
// 2AE800: variable 'v37' is possibly undefined
// 2AE814: variable 'v39' is possibly undefined
// 2AE828: variable 'v41' is possibly undefined
// 2AE844: variable 'v43' is possibly undefined
// 2AE868: variable 'v45' is possibly undefined
// 2AE880: variable 'v47' is possibly undefined
// 2AE89E: variable 'v49' is possibly undefined
// 2AE8BC: variable 'v51' is possibly undefined
// 2AE8E2: variable 'v53' is possibly undefined
// 2AE900: variable 'v55' is possibly undefined
// 2AE916: variable 'v57' is possibly undefined
// 2AE938: variable 'v59' is possibly undefined
// 2AE95A: variable 'v61' is possibly undefined
// 2AE970: variable 'v63' is possibly undefined
// 2AE992: variable 'v65' is possibly undefined
// 2AE9C6: variable 'v67' is possibly undefined
// 2AE9F2: variable 'v69' is possibly undefined
// 2AEA1C: variable 'v71' is possibly undefined
// 2AEA3A: variable 'v73' is possibly undefined
// 2AEA50: variable 'v75' is possibly undefined
// 2AEA70: variable 'v77' is possibly undefined
// 2AEA8E: variable 'v79' is possibly undefined
// 2AEAAE: variable 'v81' is possibly undefined
// 2AEACC: variable 'v83' is possibly undefined
// 2AEAEC: variable 'v85' is possibly undefined
// 2AEB08: variable 'v87' is possibly undefined
// 2AEB2C: variable 'v89' is possibly undefined
// 2AEB50: variable 'v91' is possibly undefined
// 2AEB68: variable 'v93' is possibly undefined
// 2AEB80: variable 'v95' is possibly undefined
// 2AEB9E: variable 'v97' is possibly undefined
// 2AEBBC: variable 'v99' is possibly undefined
// 2AEBDE: variable 'v101' is possibly undefined
// 2AEC04: variable 'v103' is possibly undefined
// 2AEC1E: variable 'v105' is possibly undefined
// 2AEC3E: variable 'v107' is possibly undefined
// 2AEC6E: variable 'v109' is possibly undefined
// 2AEC8E: variable 'v111' is possibly undefined
// 2AECAE: variable 'v113' is possibly undefined
// 2AECCE: variable 'v115' is possibly undefined
// 2AECF0: variable 'v117' is possibly undefined
// 2AED0E: variable 'v119' is possibly undefined
// 2AED26: variable 'v121' is possibly undefined
// 2AED3C: variable 'v123' is possibly undefined
// 2AED5E: variable 'v125' is possibly undefined
// 2AED80: variable 'v127' is possibly undefined
// 2AED9C: variable 'v129' is possibly undefined
// 2AEDB2: variable 'v131' is possibly undefined
// 2AEDC8: variable 'v133' is possibly undefined
// 2AEDDE: variable 'v135' is possibly undefined
// 2AEDF4: variable 'v137' is possibly undefined
// 2AEE14: variable 'v139' is possibly undefined
// 2AEE34: variable 'v141' is possibly undefined
// 2AEE4A: variable 'v143' is possibly undefined
// 2AEE78: variable 'v146' is possibly undefined
// 2AEE9A: variable 'v149' is possibly undefined
// 2AEEBE: variable 'v152' is possibly undefined
// 2AEEE0: variable 'v155' is possibly undefined
// 2AEF02: variable 'v158' is possibly undefined
// 2AEF24: variable 'v161' is possibly undefined
// 2AEF52: variable 'v164' is possibly undefined
// 2AEF76: variable 'v166' is possibly undefined
// 2AEF96: variable 'v168' is possibly undefined
// 2AEFBC: variable 'v170' is possibly undefined
// 2AEFE2: variable 'v172' is possibly undefined
// 2AF03C: variable 'v174' is possibly undefined
// 2AF05C: variable 'v176' is possibly undefined
// 2AF07E: variable 'v178' is possibly undefined
// 2AF09E: variable 'v180' is possibly undefined
// 2AF0C0: variable 'v182' is possibly undefined
// 2AF0E0: variable 'v184' is possibly undefined
// 2AF0FC: variable 'v186' is possibly undefined
// 2AF11A: variable 'v188' is possibly undefined
// 2AF136: variable 'v190' is possibly undefined
// 2AF156: variable 'v192' is possibly undefined
// 2AF176: variable 'v194' is possibly undefined
// 2AF194: variable 'v196' is possibly undefined
// 2AF1B2: variable 'v198' is possibly undefined
// 2AF1D4: variable 'v200' is possibly undefined
// 2AF1EA: variable 'v202' is possibly undefined
// 2AF1FE: variable 'v204' is possibly undefined
// 2AF220: variable 'v206' is possibly undefined
// 2AF242: variable 'v208' is possibly undefined
// 2AF262: variable 'v210' is possibly undefined
// 2AF2C0: variable 'v213' is possibly undefined
// 2AF2E6: variable 'v216' is possibly undefined
// 2AF30A: variable 'v218' is possibly undefined
// 2AF330: variable 'v220' is possibly undefined
// 2AF34C: variable 'v222' is possibly undefined
// 2AF368: variable 'v224' is possibly undefined
// 2AF384: variable 'v226' is possibly undefined
// 2AF3A0: variable 'v228' is possibly undefined
// 2AF3D8: variable 'v230' is possibly undefined
// 2AF400: variable 'v232' is possibly undefined
// 2AF434: variable 'v234' is possibly undefined
// 2AF45C: variable 'v236' is possibly undefined
// 2AF484: variable 'v238' is possibly undefined
// 2AF4AC: variable 'v240' is possibly undefined
// 2AF4D4: variable 'v242' is possibly undefined
// 2AF4F6: variable 'v244' is possibly undefined
// 2AF512: variable 'v246' is possibly undefined
// 2AF52E: variable 'v248' is possibly undefined
// 2AF54A: variable 'v250' is possibly undefined
// 2AF566: variable 'v252' is possibly undefined
// 2AF59E: variable 'v254' is possibly undefined
// 2AF5CE: variable 'v256' is possibly undefined
// 2AF62A: variable 'v258' is possibly undefined
// 2AF648: variable 'v260' is possibly undefined
// 2AF666: variable 'v262' is possibly undefined
// 2AF684: variable 'v264' is possibly undefined
// 2AF6A2: variable 'v266' is possibly undefined
// 2AF6C0: variable 'v268' is possibly undefined
// 2AF6DE: variable 'v270' is possibly undefined
// 2AF6FC: variable 'v272' is possibly undefined
// 2AF71A: variable 'v274' is possibly undefined
// 2AF738: variable 'v276' is possibly undefined
// 2AF756: variable 'v278' is possibly undefined
// 2AF774: variable 'v280' is possibly undefined
// 2AF792: variable 'v282' is possibly undefined
// 2AF7B0: variable 'v284' is possibly undefined
// 2AF7DE: variable 'v286' is possibly undefined
// 2AF7F4: variable 'v288' is possibly undefined
// 2AF80A: variable 'v290' is possibly undefined
// 2AF820: variable 'v292' is possibly undefined
// 2AF836: variable 'v294' is possibly undefined
// 2AF8D2: variable 'v298' is possibly undefined
// 2AF8E8: variable 'v300' is possibly undefined
// 2AF8FE: variable 'v302' is possibly undefined
// 2AF914: variable 'v304' is possibly undefined
// 2AF934: variable 'v306' is possibly undefined
// 2AF94A: variable 'v308' is possibly undefined
// 2AF960: variable 'v310' is possibly undefined
// 2AF976: variable 'v312' is possibly undefined
// 2AF98E: variable 'v314' is possibly undefined
// 2AF9A6: variable 'v316' is possibly undefined
// 2AF9BE: variable 'v318' is possibly undefined
// 2AF9D6: variable 'v320' is possibly undefined
// 2AF9EC: variable 'v322' is possibly undefined
// 2AF9FA: variable 'v324' is possibly undefined
// 2AFA10: variable 'v326' is possibly undefined
// 2AFA32: variable 'v328' is possibly undefined
// 2AFA4E: variable 'v330' is possibly undefined
// 2AFA6A: variable 'v332' is possibly undefined
// 2AFA8A: variable 'v334' is possibly undefined
// 2AFAA6: variable 'v336' is possibly undefined
// 2AFABC: variable 'v338' is possibly undefined
// 2AFAD2: variable 'v340' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];
// 61CADE: using guessed type char byte_61CADE;
// 2AE570: using guessed type WidgetPosition var_48;

//----- (002AFBE8) --------------------------------------------------------
TextureDatabaseRuntime *CTouchInterface::LoadTextureDB()
{
  TextureDatabaseRuntime *Database; // r4

  Database = TextureDatabaseRuntime::GetDatabase("mobile");
  TextureDatabaseRuntime::Register(Database);
  return Database;
}

//----- (002AFC04) --------------------------------------------------------
void CTouchInterface::DeleteAll()
{
  int i; // r4
  CWidget *v1; // r0

  for ( i = 0; i != 190; ++i )
  {
    v1 = CTouchInterface::m_pWidgets[i];
    if ( v1 )
    {
      (*((void (__fastcall **)(CWidget *))v1->_vptr$CWidget + 1))(v1);
      CTouchInterface::m_pWidgets[i] = 0;
    }
  }
}

//----- (002AFC44) --------------------------------------------------------
void CTouchInterface::CreateThumbCircleWidget()
{
  CWidgetThumbCircle *v0; // r0
  CWidget *v1; // r0

  if ( CTouchInterface::m_pWidgets[164] )
  {
    (*((void (__fastcall **)(CWidget *))CTouchInterface::m_pWidgets[164]->_vptr$CWidget + 1))(CTouchInterface::m_pWidgets[164]);
    CTouchInterface::m_pWidgets[164] = 0;
  }
  v0 = (CWidgetThumbCircle *)operator new(0xE8u);
  CWidgetThumbCircle::CWidgetThumbCircle(
    v0,
    CTouchInterface::m_pszWidgetTextures[164],
    &CTouchInterface::m_WidgetPosition[35]);
  CTouchInterface::m_pWidgets[164] = v1;
}
// 2AFC8A: variable 'v1' is possibly undefined

//----- (002AFCA4) --------------------------------------------------------
void CTouchInterface::CreateTapMeterWidget()
{
  CWidgetTapMeter *v0; // r0
  CWidget *v1; // r0

  if ( CTouchInterface::m_pWidgets[163] )
  {
    (*((void (__fastcall **)(CWidget *))CTouchInterface::m_pWidgets[163]->_vptr$CWidget + 1))(CTouchInterface::m_pWidgets[163]);
    CTouchInterface::m_pWidgets[163] = 0;
  }
  v0 = (CWidgetTapMeter *)operator new(0xBCu);
  CWidgetTapMeter::CWidgetTapMeter(
    v0,
    CTouchInterface::m_pszWidgetTextures[163],
    &CTouchInterface::m_WidgetPosition[36]);
  CTouchInterface::m_pWidgets[163] = v1;
}
// 2AFCEA: variable 'v1' is possibly undefined

//----- (002AFD04) --------------------------------------------------------
void CTouchInterface::SetupLayoutObjects()
{
  TextureDatabaseRuntime *Database; // r8
  CWidgetButton *v1; // r0
  CWidget *v2; // r0
  CWidgetButtonSwim *v3; // r0
  CWidget *v4; // r0
  CWidgetButtonSprint *v5; // r0
  CWidget *v6; // r0
  CWidgetRegionDriveHybrid *v7; // r0
  CWidget *v8; // r0
  CWidgetRegionSprint *v9; // r0
  CWidget *v10; // r0

  if ( CTouchInterface::m_pWidgets[2] )
  {
    (*((void (__fastcall **)(CWidget *))CTouchInterface::m_pWidgets[2]->_vptr$CWidget + 1))(CTouchInterface::m_pWidgets[2]);
    CTouchInterface::m_pWidgets[2] = 0;
  }
  if ( CTouchInterface::m_pWidgets[32] )
  {
    (*((void (__fastcall **)(CWidget *))CTouchInterface::m_pWidgets[32]->_vptr$CWidget + 1))(CTouchInterface::m_pWidgets[32]);
    CTouchInterface::m_pWidgets[32] = 0;
  }
  if ( CTouchInterface::m_pWidgets[34] )
  {
    (*((void (__fastcall **)(CWidget *))CTouchInterface::m_pWidgets[34]->_vptr$CWidget + 1))(CTouchInterface::m_pWidgets[34]);
    CTouchInterface::m_pWidgets[34] = 0;
  }
  if ( CTouchInterface::m_pWidgets[31] )
  {
    (*((void (__fastcall **)(CWidget *))CTouchInterface::m_pWidgets[31]->_vptr$CWidget + 1))(CTouchInterface::m_pWidgets[31]);
    CTouchInterface::m_pWidgets[31] = 0;
  }
  if ( CTouchInterface::m_pWidgets[158] )
  {
    (*((void (__fastcall **)(CWidget *))CTouchInterface::m_pWidgets[158]->_vptr$CWidget + 1))(CTouchInterface::m_pWidgets[158]);
    CTouchInterface::m_pWidgets[158] = 0;
  }
  if ( CTouchInterface::m_pWidgets[168] )
  {
    (*((void (__fastcall **)(CWidget *))CTouchInterface::m_pWidgets[168]->_vptr$CWidget + 1))(CTouchInterface::m_pWidgets[168]);
    CTouchInterface::m_pWidgets[168] = 0;
  }
  Database = TextureDatabaseRuntime::GetDatabase("mobile");
  TextureDatabaseRuntime::Register(Database);
  if ( MobileSettings::settings[9].value == 1 )
  {
    v7 = (CWidgetRegionDriveHybrid *)operator new(0x9Cu);
    CWidgetRegionDriveHybrid::CWidgetRegionDriveHybrid(
      v7,
      CTouchInterface::m_pszWidgetTextures[158],
      &CTouchInterface::m_WidgetPosition[111]);
    CTouchInterface::m_pWidgets[158] = v8;
    v9 = (CWidgetRegionSprint *)operator new(0xA4u);
    CWidgetRegionSprint::CWidgetRegionSprint(
      v9,
      CTouchInterface::m_pszWidgetTextures[168],
      &CTouchInterface::m_WidgetPosition[119]);
    CTouchInterface::m_pWidgets[168] = v10;
  }
  else if ( !MobileSettings::settings[9].value )
  {
    v1 = (CWidgetButton *)operator new(0xA8u);
    CWidgetButton::CWidgetButton(
      v1,
      CTouchInterface::m_pszWidgetTextures[2],
      &CTouchInterface::m_WidgetPosition[2],
      1u,
      0x40u,
      HID_MAPPING_ACCELERATE);
    CTouchInterface::m_pWidgets[2] = v2;
    v3 = (CWidgetButtonSwim *)operator new(0xA8u);
    CWidgetButtonSwim::CWidgetButtonSwim(
      v3,
      CTouchInterface::m_pszWidgetTextures[34],
      &CTouchInterface::m_WidgetPosition[3]);
    CTouchInterface::m_pWidgets[34] = v4;
    v5 = (CWidgetButtonSprint *)operator new(0xA8u);
    CWidgetButtonSprint::CWidgetButtonSprint(
      v5,
      CTouchInterface::m_pszWidgetTextures[31],
      &CTouchInterface::m_WidgetPosition[3]);
    CTouchInterface::m_pWidgets[31] = v6;
  }
  sub_18BFA4(Database);
}
// 2AFE08: variable 'v2' is possibly undefined
// 2AFE1C: variable 'v4' is possibly undefined
// 2AFE30: variable 'v6' is possibly undefined
// 2AFE58: variable 'v8' is possibly undefined
// 2AFE6E: variable 'v10' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];

//----- (002AFED4) --------------------------------------------------------
void CTouchInterface::SetupSteeringMode()
{
  CPlayerPed *PlayerPed; // r0
  CPad *PadFromPlayer; // r0
  int32 SteeringMode; // r5
  TextureDatabaseRuntime *Database; // r4
  CWidgetButton *v4; // r0
  CWidget *v5; // r0
  CWidgetButton *v6; // r0
  CWidget *v7; // r0
  CWidgetRegionSteer *v8; // r0
  CWidget *v9; // r0
  CWidgetRegionFlick *v10; // r0
  CWidget *v11; // r0

  PlayerPed = FindPlayerPed(-1);
  if ( PlayerPed )
  {
    if ( (PadFromPlayer = CPlayerPed::GetPadFromPlayer(PlayerPed),
          SteeringMode = CPad::GetSteeringMode(PadFromPlayer),
          SteeringMode == 1)
      && !CTouchInterface::m_pWidgets[5]
      || !SteeringMode && !CTouchInterface::m_pWidgets[172]
      || SteeringMode == 2 && !CTouchInterface::m_pWidgets[173] )
    {
      Database = TextureDatabaseRuntime::GetDatabase("mobile");
      TextureDatabaseRuntime::Register(Database);
      if ( CTouchInterface::m_pWidgets[5] )
      {
        (*((void (__fastcall **)(CWidget *))CTouchInterface::m_pWidgets[5]->_vptr$CWidget + 1))(CTouchInterface::m_pWidgets[5]);
        CTouchInterface::m_pWidgets[5] = 0;
      }
      if ( CTouchInterface::m_pWidgets[6] )
      {
        (*((void (__fastcall **)(CWidget *))CTouchInterface::m_pWidgets[6]->_vptr$CWidget + 1))(CTouchInterface::m_pWidgets[6]);
        CTouchInterface::m_pWidgets[6] = 0;
      }
      if ( CTouchInterface::m_pWidgets[172] )
      {
        (*((void (__fastcall **)(CWidget *))CTouchInterface::m_pWidgets[172]->_vptr$CWidget + 1))(CTouchInterface::m_pWidgets[172]);
        CTouchInterface::m_pWidgets[172] = 0;
      }
      if ( CTouchInterface::m_pWidgets[173] )
      {
        (*((void (__fastcall **)(CWidget *))CTouchInterface::m_pWidgets[173]->_vptr$CWidget + 1))(CTouchInterface::m_pWidgets[173]);
        CTouchInterface::m_pWidgets[173] = 0;
      }
      if ( SteeringMode )
      {
        if ( SteeringMode == 2 )
        {
          v10 = (CWidgetRegionFlick *)operator new(0x98u);
          CWidgetRegionFlick::CWidgetRegionFlick(
            v10,
            CTouchInterface::m_pszWidgetTextures[173],
            &CTouchInterface::m_WidgetPosition[122]);
          CTouchInterface::m_pWidgets[173] = v11;
        }
        else
        {
          v4 = (CWidgetButton *)operator new(0xA8u);
          CWidgetButton::CWidgetButton(
            v4,
            CTouchInterface::m_pszWidgetTextures[5],
            &CTouchInterface::m_WidgetPosition[5],
            1u,
            0x40u,
            HID_MAPPING_VEHICLE_STEER_LEFT);
          CTouchInterface::m_pWidgets[5] = v5;
          v6 = (CWidgetButton *)operator new(0xA8u);
          CWidgetButton::CWidgetButton(
            v6,
            CTouchInterface::m_pszWidgetTextures[6],
            &CTouchInterface::m_WidgetPosition[6],
            1u,
            0x40u,
            HID_MAPPING_VEHICLE_STEER_RIGHT);
          CTouchInterface::m_pWidgets[6] = v7;
        }
      }
      else
      {
        v8 = (CWidgetRegionSteer *)operator new(0xA8u);
        CWidgetRegionSteer::CWidgetRegionSteer(
          v8,
          CTouchInterface::m_pszWidgetTextures[172],
          &CTouchInterface::m_WidgetPosition[121]);
        CTouchInterface::m_pWidgets[172] = v9;
      }
      sub_18BFA4(Database);
    }
  }
}
// 2AFFAA: conditional instruction was optimized away because r5.4==1
// 2AFFE0: variable 'v5' is possibly undefined
// 2AFFFC: variable 'v7' is possibly undefined
// 2B002C: variable 'v9' is possibly undefined
// 2B0056: variable 'v11' is possibly undefined

//----- (002B00D0) --------------------------------------------------------
void CTouchInterface::RepositionAdjustableWidgets()
{
  _QWORD *v0; // r12
  int v1; // r1
  CWidget *v2; // r0
  _QWORD *p_m_fOriginX; // r0
  WidgetPosition *v4; // r3
  __int64 v5; // d17

  v1 = 0;
  v0[4] = 0xE0000000FLL;
  v0[5] = 0xE00000013LL;
  v0[6] = 0xE00000014LL;
  v0[7] = 0xF00000015LL;
  v0[8] = 0xF00000021LL;
  v0[9] = 0x1000000016LL;
  v0[10] = 0x110000001DLL;
  v0[11] = 0x2600000019LL;
  v0[12] = 0x260000001CLL;
  v0[13] = 0x260000002ALL;
  v0[14] = 0x2600000044LL;
  v0[15] = 0x2600000045LL;
  v0[16] = 0x2600000047LL;
  v0[17] = 0x2600000046LL;
  v0[18] = 0x2600000048LL;
  v0[19] = 0x2600000042LL;
  v0[20] = 0x200000002LL;
  v0[21] = 0x400000003LL;
  v0[22] = 0xC00000004LL;
  v0[23] = 0xC00000017LL;
  v0[24] = 0xC0000002DLL;
  v0[25] = 0xC0000002FLL;
  v0[26] = 0xC00000043LL;
  v0[27] = 0x500000032LL;
  v0[28] = 0x500000005LL;
  v0[29] = 0x600000033LL;
  v0[30] = 0x600000006LL;
  v0[31] = 0x700000007LL;
  v0[32] = 0xD00000012LL;
  v0[33] = 0xA00000010LL;
  v0[34] = 0xA0000001ALL;
  v0[35] = 0xB00000011LL;
  v0[36] = 0xB0000001BLL;
  v0[37] = 0x10000000BLL;
  *v0 = 0LL;
  v0[1] = 14LL;
  v0[2] = 73LL;
  v0[3] = 0xE00000001LL;
  v0[40] = 0x100000018LL;
  v0[41] = 0x10000001ELL;
  v0[38] = 0x10000000DLL;
  v0[39] = 0x6E0000000CLL;
  v0[42] = 0x10000002CLL;
  v0[43] = 0x10000002ELL;
  v0[44] = 0x300000022LL;
  v0[45] = 0x30000001FLL;
  v0[46] = 0x900000008LL;
  v0[47] = 0x900000009LL;
  do
  {
    v2 = CTouchInterface::m_pWidgets[LODWORD(v0[v1])];
    if ( v2 )
    {
      p_m_fOriginX = (_QWORD *)&v2->m_fOriginX;
      v4 = &CTouchInterface::m_WidgetPosition[HIDWORD(v0[v1])];
      v5 = *(_QWORD *)&v4->m_fScaleX;
      *p_m_fOriginX = *(_QWORD *)&v4->m_fOriginX;
      p_m_fOriginX[1] = v5;
    }
    ++v1;
  }
  while ( v1 != 49 );
}
// 2B0116: variable 'v0' is possibly undefined

//----- (002B03F8) --------------------------------------------------------
void CTouchInterface::Clear()
{
  int32x4_t v0; // q9
  unsigned int v1; // r6
  float *p_y; // r5
  float *v3; // r4
  OSPointerState Button; // r10
  float x_low; // s0
  float v6; // s2
  float v7; // s4
  float v8; // s8
  float v9; // s6
  bool v10; // zf
  int v11; // r0
  int v12; // r5
  int v13; // r0
  int v14; // r6
  CWidget *v15; // r0
  bool v16; // zf
  int (__fastcall *v17)(CWidget *, __int64 *, int); // r3
  CWidget *v18; // r1
  CVector2D *v19; // r6
  CVector2D *v20; // r11
  int v21; // r0
  int v22; // r10
  CWidget *v23; // r1
  bool v24; // zf
  int v25; // r4
  __int32 v26; // r0
  bool v27; // zf
  CWidget *v28; // r6
  float32x2_t *v29; // r10
  float v30; // r1
  int v31; // r0
  int v32; // r11
  CWidget *v33; // r0
  bool v34; // zf
  int (__fastcall *v35)(CWidget *, __int64 *, _DWORD); // r3
  float v36; // s20
  int i; // r6
  CWidget *v38; // r0
  bool v39; // zf
  CWidget *v40; // r0
  int (__fastcall *v41)(CWidget *, __int64 *, int); // r3
  CWidget *v42; // r1
  float32x2_t v43; // d16
  unsigned __int64 v44; // d0
  int v45; // r6
  int8x16_t v46; // q8
  bool *v47; // r2
  unsigned int v48; // r1
  unsigned __int32 v49; // t1
  int32x4_t v50; // q8
  int v51; // r2
  int v52; // r1
  bool *v53; // r3
  int v54; // t1
  char v55; // r4
  int j; // r4
  CWidget *v57; // r0
  int v58; // r6
  int8x16_t v59; // q8
  bool *v60; // r2
  unsigned int v61; // r1
  unsigned __int32 v62; // t1
  int32x4_t v63; // q8
  int v64; // r2
  int v65; // r0
  bool *v66; // r1
  int v67; // t1
  int v68; // r0
  int v69; // r8
  CWidget *v70; // r0
  bool v71; // zf
  int (__fastcall *v72)(CWidget *, __int64 *, _DWORD); // r3
  CWidget *v73; // r0
  int (__fastcall *v74)(CWidget *, CVector2D *, _DWORD); // r3
  CVector2D v75; // [sp+40h] [bp-50h] BYREF
  __int64 v76[9]; // [sp+48h] [bp-48h] BYREF

  CWidget::UpdateTiming();
  if ( !CTouchInterface::m_nMaxTouches )
    goto LABEL_74;
  v1 = 0;
  p_y = &CTouchInterface::m_vecCachedPos[0].y;
  v3 = &CTouchInterface::m_vecCachedDelta[0].y;
  do
  {
    LODWORD(v76[0]) = 0;
    v75.x = 0.0;
    Button = LIB_PointerGetButton(v1, 0);
    LIB_PointerGetCoordinates(v1, (int *)v76, (int *)&v75, 0);
    x_low = (float)SLODWORD(v75.x);
    v6 = (float)SLODWORD(v76[0]);
    v7 = *(p_y - 1);
    if ( v7 != 0.0 || (v8 = 0.0, v9 = 0.0, *p_y != 0.0) )
    {
      if ( LODWORD(v76[0]) )
      {
        v10 = Button == OSPS_ButtonPressed;
      }
      else
      {
        v9 = 0.0;
        v8 = 0.0;
        if ( Button == OSPS_ButtonPressed )
          goto LABEL_11;
        v10 = LODWORD(v75.x) == 0;
      }
      v9 = 0.0;
      v8 = 0.0;
      if ( !v10 )
      {
        v9 = v6 - v7;
        v8 = x_low - *p_y;
      }
    }
LABEL_11:
    v11 = CTouchInterface::m_nMaxTouches;
    ++v1;
    *(v3 - 1) = v9;
    *v3 = v8;
    v3 += 2;
    *(p_y - 1) = v6;
    *p_y = x_low;
    p_y += 2;
  }
  while ( v1 < v11 );
  if ( v11 < 1 )
    goto LABEL_74;
  v12 = 0;
  while ( 2 )
  {
    CWidget::SetReleasedWidget(v12, 0);
    CWidget::SetSwipedWidget(v12, 0);
    if ( (LIB_PointerGetButton(v12, 0) | 1) == 3 || !CTouchInterface::m_bTouchDown[v12] )
      goto LABEL_36;
    v13 = 0;
    while ( 2 )
    {
      v14 = v13;
      v15 = CTouchInterface::m_pWidgets[v13];
      v16 = v15 == 0;
      if ( v15 )
        v16 = !v15->m_bEnabled;
      if ( !v16 && v15 == CWidget::m_pInitialTouchWidget[v12] )
      {
        v17 = (int (__fastcall *)(CWidget *, __int64 *, int))*((_DWORD *)v15->_vptr$CWidget + 3);
        v76[0] = (__int64)CTouchInterface::m_vecCachedPos[v12];
        if ( v17(v15, v76, 1) == 1 )
        {
          v18 = CTouchInterface::m_pWidgets[v14];
LABEL_24:
          CWidget::SetReleasedWidget(v12, v18);
          if ( (CTouchInterface::m_pWidgets[v14]->m_nFlags & 8) == 0 )
            break;
        }
        else
        {
          v18 = CTouchInterface::m_pWidgets[v14];
          if ( (v18->m_nFlags & 0x100) != 0 )
            goto LABEL_24;
        }
      }
      v13 = v14 + 1;
      if ( v14 < 189 )
        continue;
      break;
    }
    v19 = &CTouchInterface::m_vecCachedPos[v12];
    v20 = &CWidget::m_vecTouchAnchor[v12];
    v21 = 0;
    do
    {
      v22 = v21;
      v23 = CTouchInterface::m_pWidgets[v21];
      v24 = v23 == 0;
      if ( v23 )
        v24 = !v23->m_bEnabled;
      if ( !v24
        && v23 == CWidget::m_pInitialTouchWidget[v12]
        && (fabsf(v19->x - v20->x) > CWidget::SWIPE_DISTANCE || fabsf(v19->y - v20->y) > CWidget::SWIPE_DISTANCE) )
      {
        CWidget::SetSwipedWidget(v12, v23);
        if ( (CTouchInterface::m_pWidgets[v22]->m_nFlags & 8) == 0 )
          break;
      }
      v21 = v22 + 1;
    }
    while ( v22 < 189 );
    CWidget::SetInitialTouchWidget(v12, 0);
    CTouchInterface::m_bTouchDown[v12] = 0;
LABEL_36:
    if ( ++v12 < CTouchInterface::m_nMaxTouches )
      continue;
    break;
  }
  if ( CTouchInterface::m_nMaxTouches < 1 )
    goto LABEL_74;
  v25 = 0;
  do
  {
    v26 = LIB_PointerGetButton(v25, 0) | 1;
    v27 = v26 == 3;
    if ( v26 == 3 )
      v27 = !CTouchInterface::m_bTouchDown[v25];
    if ( v27 )
    {
      v28 = 0;
      v29 = (float32x2_t *)&CTouchInterface::m_vecCachedPos[v25];
      v30 = v29->n64_f32[1];
      LODWORD(CWidget::m_vecTouchAnchor[v25].x) = v29->n64_u32[0];
      CWidget::m_vecTouchAnchor[v25].y = v30;
      v31 = 0;
      do
      {
        v32 = v31;
        v33 = CTouchInterface::m_pWidgets[v31];
        v34 = v33 == 0;
        if ( v33 )
          v34 = !v33->m_bEnabled;
        if ( !v34 )
        {
          v35 = (int (__fastcall *)(CWidget *, __int64 *, _DWORD))*((_DWORD *)v33->_vptr$CWidget + 3);
          v76[0] = v29->n64_i64[0];
          if ( v35(v33, v76, 0) == 1 )
          {
            v28 = CTouchInterface::m_pWidgets[v32];
            CWidget::SetInitialTouchWidget(v25, v28);
            if ( (CTouchInterface::m_pWidgets[v32]->m_nFlags & 8) == 0 )
              break;
          }
        }
        v31 = v32 + 1;
      }
      while ( v32 < 189 );
      if ( !v28 || !(*((int (__fastcall **)(CWidget *))v28->_vptr$CWidget + 9))(v28) )
      {
        v36 = 100000.0;
        for ( i = 0; i != 190; ++i )
        {
          v38 = CTouchInterface::m_pWidgets[i];
          v39 = v38 == 0;
          if ( v38 )
            v39 = !v38->m_bEnabled;
          if ( !v39 && (*((int (__fastcall **)(CWidget *))v38->_vptr$CWidget + 9))(v38) == 1 )
          {
            v40 = CTouchInterface::m_pWidgets[i];
            v41 = (int (__fastcall *)(CWidget *, __int64 *, int))*((_DWORD *)v40->_vptr$CWidget + 3);
            v76[0] = v29->n64_i64[0];
            if ( v41(v40, v76, 1) == 1 )
            {
              v42 = CTouchInterface::m_pWidgets[i];
              v43.n64_u64[0] = vsub_f32(
                                 (float32x2_t)v29->n64_u64[0],
                                 vmul_f32(
                                   vadd_f32(
                                     *(float32x2_t *)&v42->m_RectScreen.left,
                                     *(float32x2_t *)&v42->m_RectScreen.right),
                                   (float32x2_t)0x3F0000003F000000LL)).n64_u64[0];
              v44 = vmul_f32(v43, v43).n64_u64[0];
              if ( (float)(*(float *)&v44 + *((float *)&v44 + 1)) < v36 )
              {
                CWidget::SetInitialTouchWidget(v25, v42);
                v36 = *(float *)&v44 + *((float *)&v44 + 1);
              }
            }
          }
        }
      }
      CTouchInterface::m_bTouchDown[v25] = 1;
    }
    ++v25;
  }
  while ( v25 < CTouchInterface::m_nMaxTouches );
  if ( CTouchInterface::m_nMaxTouches < 1 )
  {
LABEL_74:
    v55 = 0;
    CWidget::SetPinchZoomWidget(0);
    goto LABEL_75;
  }
  if ( (unsigned int)CTouchInterface::m_nMaxTouches < 4
    || (v45 = CTouchInterface::m_nMaxTouches & 0x7FFFFFFC, (CTouchInterface::m_nMaxTouches & 0xFFFFFFFC) == 0) )
  {
    v45 = 0;
    v51 = 0;
LABEL_71:
    v52 = CTouchInterface::m_nMaxTouches - v45;
    v53 = &CTouchInterface::m_bTouchDown[v45];
    do
    {
      v54 = *v53++;
      --v52;
      v51 += v54;
    }
    while ( v52 );
    goto LABEL_73;
  }
  v46 = 0uLL;
  v47 = CTouchInterface::m_bTouchDown;
  v48 = CTouchInterface::m_nMaxTouches & 0xFFFFFFFC;
  do
  {
    v49 = *(_DWORD *)v47;
    v47 += 4;
    v48 -= 4;
    v0.n128_u32[0] = v49;
    v0 = vmovl_u16((uint16x4_t)vmovl_u8((uint8x8_t)v0.n128_u64[0]).n128_u64[0]);
    v46 = vaddq_s32(v46, v0);
  }
  while ( v48 );
  v50 = vaddq_s32(v46, vextq_s8(v46, v46, 8u));
  v0 = vdupq_lane_s32((int32x2_t)v50.n128_u64[0], 1);
  v51 = vaddq_s32(v50, v0).n128_u32[0];
  if ( CTouchInterface::m_nMaxTouches != v45 )
    goto LABEL_71;
LABEL_73:
  if ( v51 < 2 )
    goto LABEL_74;
  if ( (unsigned int)CTouchInterface::m_nMaxTouches <= 3
    || (v58 = CTouchInterface::m_nMaxTouches & 0x7FFFFFFC, (CTouchInterface::m_nMaxTouches & 0xFFFFFFFC) == 0) )
  {
    v58 = 0;
    v64 = 0;
LABEL_88:
    v65 = CTouchInterface::m_nMaxTouches - v58;
    v66 = &CTouchInterface::m_bTouchDown[v58];
    do
    {
      v67 = *v66++;
      --v65;
      v64 += v67;
    }
    while ( v65 );
    goto LABEL_90;
  }
  v59 = 0uLL;
  v60 = CTouchInterface::m_bTouchDown;
  v61 = CTouchInterface::m_nMaxTouches & 0xFFFFFFFC;
  do
  {
    v62 = *(_DWORD *)v60;
    v60 += 4;
    v61 -= 4;
    v0.n128_u32[0] = v62;
    v0 = vmovl_u16((uint16x4_t)vmovl_u8((uint8x8_t)v0.n128_u64[0]).n128_u64[0]);
    v59 = vaddq_s32(v59, v0);
  }
  while ( v61 );
  v63 = vaddq_s32(v59, vextq_s8(v59, v59, 8u));
  v64 = vaddq_s32(v63, vdupq_lane_s32((int32x2_t)v63.n128_u64[0], 1)).n128_u32[0];
  if ( CTouchInterface::m_nMaxTouches != v58 )
    goto LABEL_88;
LABEL_90:
  if ( v64 >= 2 && !CTouchInterface::m_bPinchZoom )
  {
    v68 = 0;
    do
    {
      v69 = v68;
      v70 = CTouchInterface::m_pWidgets[v68];
      v71 = v70 == 0;
      if ( v70 )
        v71 = !v70->m_bEnabled;
      if ( !v71 )
      {
        v72 = (int (__fastcall *)(CWidget *, __int64 *, _DWORD))*((_DWORD *)v70->_vptr$CWidget + 3);
        v76[0] = (__int64)CTouchInterface::m_vecCachedPos[0];
        if ( v72(v70, v76, 0) )
        {
          v73 = CTouchInterface::m_pWidgets[v69];
          v74 = (int (__fastcall *)(CWidget *, CVector2D *, _DWORD))*((_DWORD *)v73->_vptr$CWidget + 3);
          v75 = CTouchInterface::m_vecCachedPos[1];
          if ( v74(v73, &v75, 0) == 1 )
          {
            CWidget::SetPinchZoomWidget(CTouchInterface::m_pWidgets[v69]);
            if ( (CTouchInterface::m_pWidgets[v69]->m_nFlags & 8) == 0 )
              break;
          }
        }
      }
      v68 = v69 + 1;
    }
    while ( v69 < 189 );
    v55 = 1;
LABEL_75:
    CTouchInterface::m_bPinchZoom = v55;
  }
  for ( j = 0; j != 190; ++j )
  {
    v57 = CTouchInterface::m_pWidgets[j];
    if ( v57 )
      CWidget::DecrementFrameCount(v57);
  }
}
// 2B0864: mask 0xFFFFFFFC is shortened because r0.4 <= 0x7FFFFFFF
// 2B0904: mask 0xFFFFFFFC is shortened because r0.4 <= 0x7FFFFFFF
// 2B0884: variable 'v0' is possibly undefined

//----- (002B0AA8) --------------------------------------------------------
bool __fastcall CTouchInterface::IsTouchDown(int nTouchIndex)
{
  return (LIB_PointerGetButton(nTouchIndex, 0) | 1) == 3;
}

//----- (002B0AC4) --------------------------------------------------------
CVector2D *__fastcall CTouchInterface::GetTouchPosition(CVector2D *retstr, int nTouchIndex)
{
  float x; // r3
  float y; // r1

  x = CTouchInterface::m_vecCachedPos[nTouchIndex].x;
  y = CTouchInterface::m_vecCachedPos[nTouchIndex].y;
  retstr->x = x;
  retstr->y = y;
  return retstr;
}

//----- (002B0AE0) --------------------------------------------------------
unsigned __int32 CTouchInterface::GetNumTouches()
{
  int32x4_t v0; // q9
  signed int v1; // r2
  int8x16_t v2; // q8
  unsigned int v3; // r3
  bool *v4; // r0
  unsigned __int32 v5; // t1
  int32x4_t v6; // q8
  unsigned __int32 result; // r0
  int v8; // r1

  if ( CTouchInterface::m_nMaxTouches < 1 )
    return 0;
  if ( (unsigned int)CTouchInterface::m_nMaxTouches <= 3
    || (v1 = CTouchInterface::m_nMaxTouches & 0xFFFFFFFC, (CTouchInterface::m_nMaxTouches & 0xFFFFFFFC) == 0) )
  {
    v1 = 0;
    result = 0;
    do
    {
LABEL_9:
      v8 = CTouchInterface::m_bTouchDown[v1++];
      result += v8;
    }
    while ( v1 < CTouchInterface::m_nMaxTouches );
    return result;
  }
  v2 = 0uLL;
  v3 = CTouchInterface::m_nMaxTouches & 0xFFFFFFFC;
  v4 = CTouchInterface::m_bTouchDown;
  do
  {
    v5 = *(_DWORD *)v4;
    v4 += 4;
    v3 -= 4;
    v0.n128_u32[0] = v5;
    v0 = vmovl_u16((uint16x4_t)vmovl_u8((uint8x8_t)v0.n128_u64[0]).n128_u64[0]);
    v2 = vaddq_s32(v2, v0);
  }
  while ( v3 );
  v6 = vaddq_s32(v2, vextq_s8(v2, v2, 8u));
  result = vaddq_s32(v6, vdupq_lane_s32((int32x2_t)v6.n128_u64[0], 1)).n128_u32[0];
  if ( CTouchInterface::m_nMaxTouches != v1 )
    goto LABEL_9;
  return result;
}
// 2B0B1C: variable 'v0' is possibly undefined

//----- (002B0B70) --------------------------------------------------------
void CTouchInterface::Update()
{
  int i; // r4
  CWidget *v1; // r0
  int j; // r4
  CWidget *v3; // r0

  CTouchInterface::SetupSteeringMode();
  if ( CPad::GetPad(0)->DisablePlayerControls )
  {
    for ( i = 0; i != 190; ++i )
    {
      v1 = CTouchInterface::m_pWidgets[i];
      if ( v1 && (v1->m_nFlags & 4) == 0 )
        CWidget::SetEnabled(v1, 0);
    }
  }
  for ( j = 0; j != 190; ++j )
  {
    v3 = CTouchInterface::m_pWidgets[j];
    if ( v3 )
      (*((void (__fastcall **)(CWidget *))v3->_vptr$CWidget + 33))(v3);
  }
  CTapEffect::UpdateAll();
  sub_18B168();
}

//----- (002B0BD8) --------------------------------------------------------
void __fastcall CTouchInterface::DrawAll(bool bAfterFade)
{
  int v1; // r8
  bool v2; // zf
  int v3; // r10
  CWidget *v4; // r0
  _BOOL4 v5; // r0
  CWidget *v6; // r0
  unsigned int m_nFlags; // r1

  v1 = bAfterFade;
  if ( !CWeapon::ms_bTakePhoto )
  {
    v2 = gMobileMenu.screenStack.numEntries == 0;
    if ( !gMobileMenu.screenStack.numEntries )
      v2 = gMobileMenu.pendingScreen == 0;
    if ( v2 )
    {
      v3 = 0;
      while ( 1 )
      {
        v4 = CTouchInterface::m_pWidgets[v3];
        if ( v4 )
        {
          CHID::currentInstanceIndex = 0;
          if ( !CHID::Replaces(v4->m_HIDMapping) )
          {
            CHID::currentInstanceIndex = 1;
            v5 = CHID::Replaces(CTouchInterface::m_pWidgets[v3]->m_HIDMapping);
            CHID::currentInstanceIndex = 0;
            if ( !v5 )
            {
              v6 = CTouchInterface::m_pWidgets[v3];
              m_nFlags = v6->m_nFlags;
LABEL_13:
              if ( v1 == (unsigned __int8)(m_nFlags & 0x10) >> 4 )
              {
                (*((void (__fastcall **)(CWidget *))v6->_vptr$CWidget + 5))(v6);
                v6 = CTouchInterface::m_pWidgets[v3];
              }
              v6->m_bCachedEnabled = v6->m_bEnabled;
              goto LABEL_16;
            }
          }
          v6 = CTouchInterface::m_pWidgets[v3];
          m_nFlags = v6->m_nFlags;
          if ( (m_nFlags & 0x400) != 0 )
            goto LABEL_13;
        }
LABEL_16:
        if ( ++v3 == 190 )
        {
          if ( !v1 )
          {
            CTapEffect::DrawAll();
            CHoldEffect::DrawAll();
          }
          sub_19794C();
          return;
        }
      }
    }
  }
}

//----- (002B0CF0) --------------------------------------------------------
void __fastcall CTouchInterface::VisualizeAll(bool bShowDisabled)
{
  _BOOL4 v1; // r4
  int v2; // r0
  int v3; // r6
  CWidget *v4; // r0

  v1 = bShowDisabled;
  v2 = 189;
  do
  {
    v3 = v2;
    v4 = CTouchInterface::m_pWidgets[v2];
    if ( v4 && (v4->m_bEnabled || v1) )
      (*((void (__fastcall **)(CWidget *))v4->_vptr$CWidget + 34))(v4);
    v2 = v3 - 1;
  }
  while ( v3 > 0 );
}

//----- (002B0D2C) --------------------------------------------------------
bool __fastcall CTouchInterface::IsTouched(CTouchInterface::WidgetIDs WidgetID, CVector2D *pVecOut, int nFrameCount)
{
  float32x2_t v3; // d0
  float32x2_t v4; // d1
  CWidget *v9; // r0

  if ( !CTouchInterface::m_pWidgets[WidgetID]
    || CPad::GetPad(0)->DisablePlayerControls && (CTouchInterface::m_pWidgets[WidgetID]->m_nFlags & 4) == 0 )
  {
    return 0;
  }
  if ( nFrameCount >= 1 )
  {
    CWidget::SetEnabled(CTouchInterface::m_pWidgets[WidgetID], 1);
    v9 = CTouchInterface::m_pWidgets[WidgetID];
    v4.n64_f32[0] = (float)nFrameCount;
    v3.n64_f32[0] = (float)v9->m_nFrameCount;
    v9->m_nFrameCount = (int)vmax_f32(v4, v3).n64_f32[0];
  }
  return (*((int (__fastcall **)(CWidget *, CVector2D *))CTouchInterface::m_pWidgets[WidgetID]->_vptr$CWidget + 20))(
           CTouchInterface::m_pWidgets[WidgetID],
           pVecOut);
}
// 2B0D94: variable 'v4' is possibly undefined
// 2B0D94: variable 'v3' is possibly undefined

//----- (002B0DCC) --------------------------------------------------------
bool __fastcall CTouchInterface::IsReleased(CTouchInterface::WidgetIDs WidgetID, CVector2D *pVecOut, int nFrameCount)
{
  float32x2_t v3; // d0
  float32x2_t v4; // d1
  CWidget *v9; // r0

  if ( !CTouchInterface::m_pWidgets[WidgetID]
    || CPad::GetPad(0)->DisablePlayerControls && (CTouchInterface::m_pWidgets[WidgetID]->m_nFlags & 4) == 0 )
  {
    return 0;
  }
  if ( nFrameCount >= 1 )
  {
    CWidget::SetEnabled(CTouchInterface::m_pWidgets[WidgetID], 1);
    v9 = CTouchInterface::m_pWidgets[WidgetID];
    v4.n64_f32[0] = (float)nFrameCount;
    v3.n64_f32[0] = (float)v9->m_nFrameCount;
    v9->m_nFrameCount = (int)vmax_f32(v4, v3).n64_f32[0];
  }
  return (*((int (__fastcall **)(CWidget *, CVector2D *))CTouchInterface::m_pWidgets[WidgetID]->_vptr$CWidget + 13))(
           CTouchInterface::m_pWidgets[WidgetID],
           pVecOut);
}
// 2B0E34: variable 'v4' is possibly undefined
// 2B0E34: variable 'v3' is possibly undefined

//----- (002B0E6C) --------------------------------------------------------
bool __fastcall CTouchInterface::IsPinchZooming(
        CTouchInterface::WidgetIDs WidgetID,
        CVector2D *pVecOut,
        int nFrameCount)
{
  float32x2_t v3; // d0
  float32x2_t v4; // d1
  CWidget *v9; // r0

  if ( !CTouchInterface::m_pWidgets[WidgetID]
    || CPad::GetPad(0)->DisablePlayerControls && (CTouchInterface::m_pWidgets[WidgetID]->m_nFlags & 4) == 0 )
  {
    return 0;
  }
  if ( nFrameCount >= 1 )
  {
    CWidget::SetEnabled(CTouchInterface::m_pWidgets[WidgetID], 1);
    v9 = CTouchInterface::m_pWidgets[WidgetID];
    v4.n64_f32[0] = (float)nFrameCount;
    v3.n64_f32[0] = (float)v9->m_nFrameCount;
    v9->m_nFrameCount = (int)vmax_f32(v4, v3).n64_f32[0];
  }
  return (*((int (__fastcall **)(CWidget *, CVector2D *))CTouchInterface::m_pWidgets[WidgetID]->_vptr$CWidget + 12))(
           CTouchInterface::m_pWidgets[WidgetID],
           pVecOut);
}
// 2B0ED4: variable 'v4' is possibly undefined
// 2B0ED4: variable 'v3' is possibly undefined

//----- (002B0F0C) --------------------------------------------------------
bool __fastcall CTouchInterface::IsSwipedLeft(CTouchInterface::WidgetIDs WidgetID, int nFrameCount)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  CWidget *v7; // r0

  if ( !CTouchInterface::m_pWidgets[WidgetID]
    || CPad::GetPad(0)->DisablePlayerControls && (CTouchInterface::m_pWidgets[WidgetID]->m_nFlags & 4) == 0 )
  {
    return 0;
  }
  if ( nFrameCount >= 1 )
  {
    CWidget::SetEnabled(CTouchInterface::m_pWidgets[WidgetID], 1);
    v7 = CTouchInterface::m_pWidgets[WidgetID];
    v3.n64_f32[0] = (float)nFrameCount;
    v2.n64_f32[0] = (float)v7->m_nFrameCount;
    v7->m_nFrameCount = (int)vmax_f32(v3, v2).n64_f32[0];
  }
  return (*((int (__fastcall **)(CWidget *))CTouchInterface::m_pWidgets[WidgetID]->_vptr$CWidget + 17))(CTouchInterface::m_pWidgets[WidgetID]);
}
// 2B0F72: variable 'v3' is possibly undefined
// 2B0F72: variable 'v2' is possibly undefined

//----- (002B0FA8) --------------------------------------------------------
bool __fastcall CTouchInterface::IsSwipedRight(CTouchInterface::WidgetIDs WidgetID, int nFrameCount)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  CWidget *v7; // r0

  if ( !CTouchInterface::m_pWidgets[WidgetID]
    || CPad::GetPad(0)->DisablePlayerControls && (CTouchInterface::m_pWidgets[WidgetID]->m_nFlags & 4) == 0 )
  {
    return 0;
  }
  if ( nFrameCount >= 1 )
  {
    CWidget::SetEnabled(CTouchInterface::m_pWidgets[WidgetID], 1);
    v7 = CTouchInterface::m_pWidgets[WidgetID];
    v3.n64_f32[0] = (float)nFrameCount;
    v2.n64_f32[0] = (float)v7->m_nFrameCount;
    v7->m_nFrameCount = (int)vmax_f32(v3, v2).n64_f32[0];
  }
  return (*((int (__fastcall **)(CWidget *))CTouchInterface::m_pWidgets[WidgetID]->_vptr$CWidget + 18))(CTouchInterface::m_pWidgets[WidgetID]);
}
// 2B100E: variable 'v3' is possibly undefined
// 2B100E: variable 'v2' is possibly undefined

//----- (002B1044) --------------------------------------------------------
bool __fastcall CTouchInterface::IsSwipedUp(CTouchInterface::WidgetIDs WidgetID, int nFrameCount)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  CWidget *v7; // r0

  if ( !CTouchInterface::m_pWidgets[WidgetID]
    || CPad::GetPad(0)->DisablePlayerControls && (CTouchInterface::m_pWidgets[WidgetID]->m_nFlags & 4) == 0 )
  {
    return 0;
  }
  if ( nFrameCount >= 1 )
  {
    CWidget::SetEnabled(CTouchInterface::m_pWidgets[WidgetID], 1);
    v7 = CTouchInterface::m_pWidgets[WidgetID];
    v3.n64_f32[0] = (float)nFrameCount;
    v2.n64_f32[0] = (float)v7->m_nFrameCount;
    v7->m_nFrameCount = (int)vmax_f32(v3, v2).n64_f32[0];
  }
  return (*((int (__fastcall **)(CWidget *))CTouchInterface::m_pWidgets[WidgetID]->_vptr$CWidget + 19))(CTouchInterface::m_pWidgets[WidgetID]);
}
// 2B10AA: variable 'v3' is possibly undefined
// 2B10AA: variable 'v2' is possibly undefined

//----- (002B10E0) --------------------------------------------------------
bool __fastcall CTouchInterface::IsHeldDown(CTouchInterface::WidgetIDs WidgetID, int nFrameCount)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  CWidget *v7; // r0

  if ( !CTouchInterface::m_pWidgets[WidgetID]
    || CPad::GetPad(0)->DisablePlayerControls && (CTouchInterface::m_pWidgets[WidgetID]->m_nFlags & 4) == 0 )
  {
    return 0;
  }
  if ( nFrameCount >= 1 )
  {
    CWidget::SetEnabled(CTouchInterface::m_pWidgets[WidgetID], 1);
    v7 = CTouchInterface::m_pWidgets[WidgetID];
    v3.n64_f32[0] = (float)nFrameCount;
    v2.n64_f32[0] = (float)v7->m_nFrameCount;
    v7->m_nFrameCount = (int)vmax_f32(v3, v2).n64_f32[0];
  }
  return (*((int (__fastcall **)(CWidget *))CTouchInterface::m_pWidgets[WidgetID]->_vptr$CWidget + 11))(CTouchInterface::m_pWidgets[WidgetID]);
}
// 2B1146: variable 'v3' is possibly undefined
// 2B1146: variable 'v2' is possibly undefined

//----- (002B117C) --------------------------------------------------------
bool __fastcall CTouchInterface::IsSwipedDown(CTouchInterface::WidgetIDs WidgetID, int nFrameCount)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  CWidget *v7; // r0

  if ( !CTouchInterface::m_pWidgets[WidgetID]
    || CPad::GetPad(0)->DisablePlayerControls && (CTouchInterface::m_pWidgets[WidgetID]->m_nFlags & 4) == 0 )
  {
    return 0;
  }
  if ( nFrameCount >= 1 )
  {
    CWidget::SetEnabled(CTouchInterface::m_pWidgets[WidgetID], 1);
    v7 = CTouchInterface::m_pWidgets[WidgetID];
    v3.n64_f32[0] = (float)nFrameCount;
    v2.n64_f32[0] = (float)v7->m_nFrameCount;
    v7->m_nFrameCount = (int)vmax_f32(v3, v2).n64_f32[0];
  }
  return (*((int (__fastcall **)(CWidget *))CTouchInterface::m_pWidgets[WidgetID]->_vptr$CWidget + 16))(CTouchInterface::m_pWidgets[WidgetID]);
}
// 2B11E2: variable 'v3' is possibly undefined
// 2B11E2: variable 'v2' is possibly undefined

//----- (002B1218) --------------------------------------------------------
void __fastcall CTouchInterface::ClearTapHistory(CTouchInterface::WidgetIDs WidgetID)
{
  CWidget *v1; // r0

  v1 = CTouchInterface::m_pWidgets[WidgetID];
  if ( v1 )
    sub_18E5EC(v1);
}

//----- (002B1230) --------------------------------------------------------
void __fastcall CTouchInterface::DrawHelpIcon(
        const unsigned __int8 *pszCharacters,
        float fX,
        float fY,
        float fHeight,
        int a5)
{
  char *v9; // r0
  const char *v10; // r5
  char *v11; // r0
  int v12; // r6
  CWidget *v13; // r1
  int v14; // r0
  char *v15; // r1
  HIDMapping v16; // r1
  CWidget *v17; // r0
  int32 value; // r1
  char v19[256]; // [sp+Ch] [bp-12Ch] BYREF

  if ( pszCharacters
    && (CFont::RenderState.Colour._anon_0._anon_0.blue | CFont::RenderState.Colour._anon_0._anon_0.red | CFont::RenderState.Colour._anon_0._anon_0.green) << 24 )
  {
    v19[0] = 0;
    v9 = strstr((const char *)pszCharacters, "widget");
    v10 = v9;
    if ( v9 )
    {
      v11 = strchr(v9, 126);
      if ( v11 )
      {
        v12 = v11 - v10;
        strncpy(v19, v10, v11 - v10);
        v19[v12] = 0;
      }
    }
    if ( strlen(v19) )
    {
      if ( !strcasecmp(v19, "widget_explicit_bicycle") )
      {
        CWidgetButton::DrawHelpIconExplicit(HID_MAPPING_ENTER_CAR, "hud_bicycle", fX, fY, fHeight, a5);
        return;
      }
      if ( !strcasecmp(v19, "widget_explicit_extinguisher") )
      {
        v15 = "hud_extinguisher";
      }
      else if ( !strcasecmp(v19, "widget_explicit_punch") )
      {
        v15 = "punch";
      }
      else if ( !strcasecmp(v19, "widget_explicit_throw") )
      {
        v15 = "hud_throw";
      }
      else if ( !strcasecmp(v19, "widget_explicit_detonator") )
      {
        v15 = "hud_detonator";
      }
      else if ( !strcasecmp(v19, "widget_explicit_shoot") )
      {
        v15 = "shoot";
      }
      else
      {
        if ( strcasecmp(v19, "widget_explicit_NVG") )
        {
          if ( !strcasecmp(v19, "widget_explicit_prev_weapon") )
          {
            v16 = HID_MAPPING_PREV_WEAPON;
          }
          else if ( !strcasecmp(v19, "widget_explicit_next_weapon") )
          {
            v16 = HID_MAPPING_NEXT_WEAPON;
          }
          else if ( !strcasecmp(v19, "widget_explicit_look_back_keyboard") )
          {
            v16 = HID_MAPPING_VEHICLE_LOOK_BACK;
          }
          else if ( !strcasecmp(v19, "widget_explicit_flight_ascend") )
          {
            v16 = HID_MAPPING_FLIGHT_ASCEND;
          }
          else if ( !strcasecmp(v19, "widget_explicit_flight_descend") )
          {
            v16 = HID_MAPPING_FLIGHT_DESCEND;
          }
          else if ( !strcasecmp(v19, "widget_explicit_flight_primary_attack") )
          {
            v16 = HID_MAPPING_FLIGHT_PRIMARY_ATTACK;
          }
          else if ( !strcasecmp(v19, "widget_explicit_flight_secondary_attack") )
          {
            v16 = HID_MAPPING_FLIGHT_SECONDARY_ATTACK;
          }
          else if ( !strcasecmp(v19, "widget_explicit_camera_zoom_in") )
          {
            v16 = HID_MAPPING_CAMERA_CLOSER;
          }
          else if ( !strcasecmp(v19, "widget_explicit_camera_zoom_out") )
          {
            v16 = HID_MAPPING_CAMERA_FARTHER;
          }
          else if ( !strcasecmp(v19, "widget_explicit_bunny_hop") )
          {
            v16 = HID_MAPPING_BUNNY_HOP;
          }
          else if ( !strcasecmp(v19, "widget_explicit_accept") )
          {
            v16 = HID_MAPPING_ACCEPT;
          }
          else if ( !strcasecmp(v19, "widget_explicit_look_x") )
          {
            v16 = HID_MAPPING_LOOK_X;
          }
          else if ( !strcasecmp(v19, "widget_explicit_move_x") )
          {
            v16 = HID_MAPPING_PED_MOVE_X;
          }
          else if ( !strcasecmp(v19, "widget_explicit_take_cover_left") )
          {
            v16 = HID_MAPPING_TAKE_COVER_LEFT;
          }
          else if ( !strcasecmp(v19, "widget_explicit_take_cover_right") )
          {
            v16 = HID_MAPPING_TAKE_COVER_RIGHT;
          }
          else if ( !strcasecmp(v19, "widget_explicit_alt_attack") )
          {
            v16 = HID_MAPPING_ALT_ATTACK;
          }
          else if ( !strcasecmp(v19, "widget_explicit_toggle_landing_gear") )
          {
            v16 = HID_MAPPING_TOGGLE_LANDING_GEAR;
          }
          else if ( !strcasecmp(v19, "widget_explicit_jump") )
          {
            v16 = HID_MAPPING_JUMP;
          }
          else
          {
            if ( strcasecmp(v19, "widget_explicit_crouch") )
            {
              if ( !strcasecmp(v19, "widget_camera") )
              {
                v14 = 18;
              }
              else if ( !strcasecmp(v19, "widget_ped_move")
                     || !strcasecmp(v19, "widget_ped_move_left")
                     || !strcasecmp(v19, "widget_ped_move_right")
                     || !strcasecmp(v19, "widget_ped_move_up")
                     || !strcasecmp(v19, "widget_ped_move_down") )
              {
                v14 = 167;
              }
              else if ( !strcasecmp(v19, "widget_enter_car") )
              {
                v14 = 0;
              }
              else if ( !strcasecmp(v19, "widget_brake") )
              {
                v14 = 3;
              }
              else if ( !strcasecmp(v19, "widget_swipe_radio_up") || !strcasecmp(v19, "widget_swipe_radio_down") )
              {
                v14 = 166;
              }
              else if ( !strcasecmp(v19, "widget_phone") )
              {
                v14 = 8;
              }
              else if ( !strcasecmp(v19, "widget_gift") )
              {
                v14 = 9;
              }
              else if ( !strcasecmp(v19, "widget_kiss") )
              {
                v14 = 10;
              }
              else if ( !strcasecmp(v19, "widget_attack") )
              {
                v14 = 1;
              }
              else if ( !strcasecmp(v19, "widget_swap_weapons") )
              {
                v14 = 29;
              }
              else if ( !strcasecmp(v19, "widget_player_info") )
              {
                v14 = 160;
              }
              else if ( !strcasecmp(v19, "widget_gang_follow") )
              {
                v14 = 108;
              }
              else if ( !strcasecmp(v19, "widget_look_left") || !strcasecmp(v19, "widget_look_right") )
              {
                v14 = 175;
              }
              else if ( !strcasecmp(v19, "widget_gang_recruit") )
              {
                v14 = 106;
              }
              else if ( !strcasecmp(v19, "widget_gang_hold") )
              {
                v14 = 109;
              }
              else if ( !strcasecmp(v19, "widget_reply_yes") )
              {
                v14 = 110;
              }
              else if ( !strcasecmp(v19, "widget_reply_no") )
              {
                v14 = 111;
              }
              else if ( !strcasecmp(v19, "widget_black_jack_hit") )
              {
                v14 = 93;
              }
              else if ( !strcasecmp(v19, "widget_black_jack_stand") )
              {
                v14 = 94;
              }
              else if ( !strcasecmp(v19, "widget_black_jack_double") )
              {
                v14 = 92;
              }
              else if ( !strcasecmp(v19, "widget_black_jack_split") )
              {
                v14 = 91;
              }
              else if ( !strcasecmp(v19, "widget_mission_start") )
              {
                v14 = 69;
              }
              else if ( !strcasecmp(v19, "widget_mission_cancel") )
              {
                v14 = 71;
              }
              else if ( !strcasecmp(v19, "widget_mission_start_vigilante") )
              {
                v14 = 70;
              }
              else if ( !strcasecmp(v19, "widget_mission_cancel_vigilante") )
              {
                v14 = 72;
              }
              else if ( !strcasecmp(v19, "widget_minigame_start") )
              {
                v14 = 73;
              }
              else if ( !strcasecmp(v19, "widget_minigame_cancel") )
              {
                v14 = 74;
              }
              else if ( !strcasecmp(v19, "widget_skip_cutscene") )
              {
                v14 = 41;
              }
              else if ( !strcasecmp(v19, "widget_gambling_continue") )
              {
                v14 = 90;
              }
              else if ( !strcasecmp(v19, "widget_gambling_quit") )
              {
                v14 = 89;
              }
              else if ( !strcasecmp(v19, "widget_enter_targeting") )
              {
                v14 = 19;
              }
              else if ( !strcasecmp(v19, "widget_zoom_in") )
              {
                v14 = 50;
              }
              else if ( !strcasecmp(v19, "widget_zoom_out") )
              {
                v14 = 51;
              }
              else if ( !strcasecmp(v19, "widget_crane_up") )
              {
                v14 = 44;
              }
              else if ( !strcasecmp(v19, "widget_crane_down") )
              {
                v14 = 45;
              }
              else if ( !strcasecmp(v19, "widget_helicopter_magnet_up") )
              {
                v14 = 46;
              }
              else if ( !strcasecmp(v19, "widget_helicopter_magnet_down") )
              {
                v14 = 47;
              }
              else if ( !strcasecmp(v19, "widget_vc_shoot") )
              {
                v14 = 21;
              }
              else if ( !strcasecmp(v19, "widget_purchase") )
              {
                v14 = 28;
              }
              else if ( !strcasecmp(v19, "widget_race_left") )
              {
                v14 = 52;
              }
              else if ( !strcasecmp(v19, "widget_race_right") )
              {
                v14 = 53;
              }
              else if ( !strcasecmp(v19, "widget_store_buy") )
              {
                v14 = 57;
              }
              else if ( !strcasecmp(v19, "widget_roulette_up") )
              {
                v14 = 58;
              }
              else if ( !strcasecmp(v19, "widget_roulette_down") )
              {
                v14 = 59;
              }
              else if ( !strcasecmp(v19, "widget_roulette_left") )
              {
                v14 = 60;
              }
              else if ( !strcasecmp(v19, "widget_roulette_right") )
              {
                v14 = 61;
              }
              else if ( !strcasecmp(v19, "widget_place_bet") )
              {
                v14 = 62;
              }
              else if ( !strcasecmp(v19, "widget_remove_bet") )
              {
                v14 = 63;
              }
              else if ( !strcasecmp(v19, "widget_store_accept") )
              {
                v14 = 54;
              }
              else if ( !strcasecmp(v19, "widget_store_cancel") )
              {
                v14 = 55;
              }
              else if ( !strcasecmp(v19, "widget_store_back") )
              {
                v14 = 56;
              }
              else if ( !strcasecmp(v19, "widget_button_dive") )
              {
                v14 = 33;
              }
              else if ( !strcasecmp(v19, "widget_grab") )
              {
                v14 = 66;
              }
              else if ( !strcasecmp(v19, "widget_vehicle_bomb") )
              {
                v14 = 25;
              }
              else if ( !strcasecmp(v19, "widget_nitro") )
              {
                v14 = 30;
              }
              else if ( !strcasecmp(v19, "widget_magnet") )
              {
                v14 = 67;
              }
              else if ( !strcasecmp(v19, "widget_drop_item") )
              {
                v14 = 15;
              }
              else if ( !strcasecmp(v19, "widget_drop_crane") )
              {
                v14 = 14;
              }
              else if ( !strcasecmp(v19, "widget_vehicle_shoot_left") )
              {
                v14 = 16;
              }
              else if ( !strcasecmp(v19, "widget_vehicle_shoot_right") )
              {
                v14 = 17;
              }
              else if ( !strcasecmp(v19, "widget_vehicle_turret_left") )
              {
                v14 = 26;
              }
              else if ( !strcasecmp(v19, "widget_vehicle_turret_right") )
              {
                v14 = 27;
              }
              else if ( !strcasecmp(v19, "widget_horn") )
              {
                v14 = 7;
              }
              else if ( !strcasecmp(v19, "widget_stinger") )
              {
                v14 = 68;
              }
              else if ( !strcasecmp(v19, "widget_rocket") )
              {
                v14 = 24;
              }
              else if ( !strcasecmp(v19, "widget_basketball_shoot") )
              {
                v14 = 87;
              }
              else if ( !strcasecmp(v19, "widget_arcade_button") )
              {
                v14 = 37;
              }
              else if ( !strcasecmp(v19, "widget_arcade_power_off") )
              {
                v14 = 38;
              }
              else if ( !strcasecmp(v19, "widget_arcade_reset") )
              {
                v14 = 39;
              }
              else if ( !strcasecmp(v19, "widget_arcade_joystick") )
              {
                v14 = 40;
              }
              else if ( !strcasecmp(v19, "widget_train_next_station") )
              {
                v14 = 42;
              }
              else if ( !strcasecmp(v19, "widget_tap_meter_button") )
              {
                v14 = 43;
              }
              else if ( !strcasecmp(v19, "widget_handbrake") )
              {
                v14 = 4;
              }
              else if ( !strcasecmp(v19, "widget_auto_hydraulics") )
              {
                v14 = 13;
              }
              else if ( !strcasecmp(v19, "widget_radar") )
              {
                v14 = 161;
              }
              else if ( !strcasecmp(v19, "widget_rhythm_exit") )
              {
                v14 = 102;
              }
              else if ( !strcasecmp(v19, "widget_air_gun") )
              {
                v14 = 23;
              }
              else if ( !strcasecmp(v19, "widget_school_left") )
              {
                v14 = 76;
              }
              else if ( !strcasecmp(v19, "widget_school_right") )
              {
                v14 = 77;
              }
              else if ( !strcasecmp(v19, "widget_hydraulics") )
              {
                v14 = 12;
              }
              else if ( !strcasecmp(v19, "widget_gym_easier") )
              {
                v14 = 48;
              }
              else if ( !strcasecmp(v19, "widget_gym_harder") )
              {
                v14 = 49;
              }
              else if ( !strcasecmp(v19, "widget_school_continue") )
              {
                v14 = 79;
              }
              else if ( !strcasecmp(v19, "widget_school_exit") )
              {
                v14 = 75;
              }
              else if ( !strcasecmp(v19, "widget_itb_exit") )
              {
                v14 = 149;
              }
              else if ( !strcasecmp(v19, "widget_video_poker_exit") )
              {
                v14 = 134;
              }
              else if ( !strcasecmp(v19, "widget_thumb_circle") )
              {
                v14 = 164;
              }
              else if ( !strcasecmp(v19, "widget_accelerate") )
              {
                v14 = 2;
                if ( MobileSettings::settings[9].value == 1 )
                  v14 = 158;
              }
              else
              {
                if ( !strcasecmp(v19, "widget_button_swim") )
                {
                  value = MobileSettings::settings[9].value;
                  v14 = 34;
                }
                else
                {
                  if ( strcasecmp(v19, "widget_sprint") )
                  {
                    if ( !strcasecmp(v19, "widget_vehicle_steer_left") )
                    {
                      v13 = CTouchInterface::m_pWidgets[5];
                      v14 = 5;
                    }
                    else
                    {
                      if ( strcasecmp(v19, "widget_vehicle_steer_right") )
                        return;
                      v13 = CTouchInterface::m_pWidgets[6];
                      v14 = 6;
                    }
                    if ( !v13 )
                      v14 = 167;
                    goto LABEL_163;
                  }
                  value = MobileSettings::settings[9].value;
                  v14 = 31;
                }
                if ( value == 1 )
                  v14 = 168;
              }
LABEL_163:
              v17 = CTouchInterface::m_pWidgets[v14];
              if ( v17 )
                (*((void (__fastcall **)(CWidget *, char *, _DWORD, _DWORD, _DWORD, int))v17->_vptr$CWidget + 4))(
                  v17,
                  v19,
                  LODWORD(fX),
                  LODWORD(fY),
                  LODWORD(fHeight),
                  a5);
              return;
            }
            v16 = HID_MAPPING_CROUCH;
          }
          CHID::DrawHelpIcon(pszCharacters, v16, fX, fY, fHeight, a5, 0);
          return;
        }
        v15 = "goggles";
      }
      CWidgetButton::DrawHelpIconExplicit(HID_MAPPING_ATTACK, (const unsigned __int8 *)v15, fX, fY, fHeight, a5);
    }
  }
}
// 2B1230: using guessed type char var_12C[256];

//----- (002B20D8) --------------------------------------------------------
bool __fastcall CTouchInterface::IsDoubleTapped(
        CTouchInterface::WidgetIDs WidgetID,
        bool bShowEffects,
        int nFrameCount)
{
  float32x2_t v3; // d0
  float32x2_t v4; // d1
  _BOOL4 v7; // r8
  int v8; // r0
  CWidget *v9; // r0
  bool v10; // zf
  CTapEffect *v11; // r0
  int m_nTouchIndex; // r6

  v7 = bShowEffects;
  if ( CTouchInterface::m_pWidgets[WidgetID]
    && (!CPad::GetPad(0)->DisablePlayerControls || (CTouchInterface::m_pWidgets[WidgetID]->m_nFlags & 4) != 0) )
  {
    if ( nFrameCount >= 1 )
    {
      CWidget::SetEnabled(CTouchInterface::m_pWidgets[WidgetID], 1);
      v9 = CTouchInterface::m_pWidgets[WidgetID];
      v4.n64_f32[0] = (float)nFrameCount;
      v3.n64_f32[0] = (float)v9->m_nFrameCount;
      v9->m_nFrameCount = (int)vmax_f32(v4, v3).n64_f32[0];
    }
    v8 = (*((int (__fastcall **)(CWidget *))CTouchInterface::m_pWidgets[WidgetID]->_vptr$CWidget + 10))(CTouchInterface::m_pWidgets[WidgetID]);
    v10 = v8 == 1;
    if ( v8 == 1 )
      v10 = v7;
    if ( v10 )
    {
      if ( !CHID::Implements(CTouchInterface::m_pWidgets[WidgetID]->m_HIDMapping) )
      {
        v11 = (CTapEffect *)operator new(0x2Cu);
        m_nTouchIndex = CTouchInterface::m_pWidgets[WidgetID]->m_nTouchIndex;
        CTapEffect::CTapEffect(
          v11,
          "hud_circle",
          CTouchInterface::m_vecCachedPos[m_nTouchIndex].x,
          CTouchInterface::m_vecCachedPos[m_nTouchIndex].y);
      }
      LOBYTE(v8) = 1;
    }
  }
  else
  {
    LOBYTE(v8) = 0;
  }
  return v8;
}
// 2B2140: variable 'v4' is possibly undefined
// 2B2140: variable 'v3' is possibly undefined

//----- (002B21CC) --------------------------------------------------------
float __fastcall CTouchInterface::GetWidgetValue(CTouchInterface::WidgetIDs WidgetID)
{
  int DisablePlayerControls; // r2
  CWidget *v3; // r0

  if ( !CTouchInterface::m_pWidgets[WidgetID] )
    return 0.0;
  DisablePlayerControls = CPad::GetPad(0)->DisablePlayerControls;
  v3 = CTouchInterface::m_pWidgets[WidgetID];
  if ( DisablePlayerControls )
  {
    if ( (v3->m_nFlags & 4) == 0 )
      return 0.0;
  }
  CWidget::SetEnabled(v3, 1);
  return COERCE_FLOAT((*((int (__fastcall **)(CWidget *))CTouchInterface::m_pWidgets[WidgetID]->_vptr$CWidget + 7))(CTouchInterface::m_pWidgets[WidgetID]));
}

//----- (002B2228) --------------------------------------------------------
void __fastcall CTouchInterface::GetWidgetValue2(CTouchInterface::WidgetIDs WidgetID, float *pfValue0, float *pfValue1)
{
  bool v4; // zf

  v4 = pfValue1 == 0;
  if ( pfValue1 )
    v4 = pfValue0 == 0;
  if ( !v4 && CTouchInterface::m_pWidgets[WidgetID] )
  {
    if ( CPad::GetPad(0)->DisablePlayerControls )
    {
      if ( (CTouchInterface::m_pWidgets[WidgetID]->m_nFlags & 4) == 0 )
      {
        *pfValue0 = 0.0;
        *pfValue1 = 0.0;
      }
    }
    CWidget::SetEnabled(CTouchInterface::m_pWidgets[WidgetID], 1);
    (*((void (__fastcall **)(CWidget *, float *, float *))CTouchInterface::m_pWidgets[WidgetID]->_vptr$CWidget + 8))(
      CTouchInterface::m_pWidgets[WidgetID],
      pfValue0,
      pfValue1);
  }
}

//----- (002B22AC) --------------------------------------------------------
void __fastcall CTouchInterface::SetWidgetValue(CTouchInterface::WidgetIDs WidgetID, float fValue)
{
  int DisablePlayerControls; // r2
  CWidget *v5; // r0

  if ( CTouchInterface::m_pWidgets[WidgetID] )
  {
    DisablePlayerControls = CPad::GetPad(0)->DisablePlayerControls;
    v5 = CTouchInterface::m_pWidgets[WidgetID];
    if ( !DisablePlayerControls || (v5->m_nFlags & 4) != 0 )
    {
      CWidget::SetEnabled(v5, 1);
      (*((void (__fastcall **)(CWidget *, _DWORD))CTouchInterface::m_pWidgets[WidgetID]->_vptr$CWidget + 28))(
        CTouchInterface::m_pWidgets[WidgetID],
        LODWORD(fValue));
    }
  }
}

//----- (002B2310) --------------------------------------------------------
void __fastcall CTouchInterface::SetWidgetValue2(CTouchInterface::WidgetIDs WidgetID, float fValue0, float fValue1)
{
  int DisablePlayerControls; // r2
  CWidget *v7; // r0

  if ( CTouchInterface::m_pWidgets[WidgetID] )
  {
    DisablePlayerControls = CPad::GetPad(0)->DisablePlayerControls;
    v7 = CTouchInterface::m_pWidgets[WidgetID];
    if ( !DisablePlayerControls || (v7->m_nFlags & 4) != 0 )
    {
      CWidget::SetEnabled(v7, 1);
      (*((void (__fastcall **)(CWidget *, _DWORD, _DWORD))CTouchInterface::m_pWidgets[WidgetID]->_vptr$CWidget + 29))(
        CTouchInterface::m_pWidgets[WidgetID],
        LODWORD(fValue0),
        LODWORD(fValue1));
    }
  }
}

//----- (002B2380) --------------------------------------------------------
void __fastcall CTouchInterface::SetWidgetValue3(
        CTouchInterface::WidgetIDs WidgetID,
        float fValue0,
        float fValue1,
        float fValue2)
{
  int DisablePlayerControls; // r2
  CWidget *v9; // r0

  if ( CTouchInterface::m_pWidgets[WidgetID] )
  {
    DisablePlayerControls = CPad::GetPad(0)->DisablePlayerControls;
    v9 = CTouchInterface::m_pWidgets[WidgetID];
    if ( !DisablePlayerControls || (v9->m_nFlags & 4) != 0 )
    {
      CWidget::SetEnabled(v9, 1);
      (*((void (__fastcall **)(CWidget *, _DWORD, _DWORD, _DWORD))CTouchInterface::m_pWidgets[WidgetID]->_vptr$CWidget
       + 30))(
        CTouchInterface::m_pWidgets[WidgetID],
        LODWORD(fValue0),
        LODWORD(fValue1),
        LODWORD(fValue2));
    }
  }
}

//----- (002B23F4) --------------------------------------------------------
void __fastcall CTouchInterface::SetWidgetInfo(
        CTouchInterface::WidgetIDs WidgetID,
        unsigned __int8 *pszText,
        float fValue,
        int bTitle,
        int bPercentage,
        int bTime,
        int bNumber,
        int nColor)
{
  CWidget *v12; // r0

  v12 = CTouchInterface::m_pWidgets[WidgetID];
  if ( v12 )
  {
    CWidget::SetEnabled(v12, 1);
    (*((void (__fastcall **)(CWidget *, unsigned __int8 *, _DWORD, int, int, int, int, int))CTouchInterface::m_pWidgets[WidgetID]->_vptr$CWidget
     + 31))(
      CTouchInterface::m_pWidgets[WidgetID],
      pszText,
      LODWORD(fValue),
      bTitle,
      bPercentage,
      bTime,
      bNumber,
      nColor);
  }
}
// 2B23F4: using guessed type _DWORD bTime_0;

//----- (002B2454) --------------------------------------------------------
void __fastcall CTouchInterface::SetWidgetInfo2(
        CTouchInterface::WidgetIDs WidgetID,
        int nValue0,
        int nValue1,
        int nValue2,
        int nValue3,
        unsigned __int8 *pszText0,
        unsigned __int8 *pszText1)
{
  CWidget *v11; // r0

  v11 = CTouchInterface::m_pWidgets[WidgetID];
  if ( v11 )
  {
    CWidget::SetEnabled(v11, 1);
    (*((void (__fastcall **)(CWidget *, int, int, int))CTouchInterface::m_pWidgets[WidgetID]->_vptr$CWidget + 32))(
      CTouchInterface::m_pWidgets[WidgetID],
      nValue0,
      nValue1,
      nValue2);
  }
}

//----- (002B24A4) --------------------------------------------------------
void __fastcall CTouchInterface::SetWidgetTexture(CTouchInterface::WidgetIDs WidgetID, unsigned __int8 *pszTexture)
{
  CWidget *v2; // r0

  v2 = CTouchInterface::m_pWidgets[WidgetID];
  if ( v2 )
    sub_18CDC4(v2, &v2->m_Sprite, pszTexture, 1);
}

//----- (002B24C4) --------------------------------------------------------
void __fastcall CTouchInterface::SetEquippedItem(CTouchInterface::WidgetIDs WidgetID, int nValue)
{
  CWidget *v2; // r0

  v2 = CTouchInterface::m_pWidgets[WidgetID];
  if ( v2 )
    (*((void (__fastcall **)(CWidget *, int))v2->_vptr$CWidget + 26))(v2, nValue);
}

//----- (002B24E0) --------------------------------------------------------
void __fastcall CTouchInterface::SetSliderRange(CTouchInterface::WidgetIDs WidgetID, float fValue0, float fValue1)
{
  int DisablePlayerControls; // r2
  CWidget *v7; // r0

  if ( CTouchInterface::m_pWidgets[WidgetID] )
  {
    DisablePlayerControls = CPad::GetPad(0)->DisablePlayerControls;
    v7 = CTouchInterface::m_pWidgets[WidgetID];
    if ( !DisablePlayerControls || (v7->m_nFlags & 4) != 0 )
    {
      CWidget::SetEnabled(v7, 1);
      (*((void (__fastcall **)(CWidget *, _DWORD, _DWORD))CTouchInterface::m_pWidgets[WidgetID]->_vptr$CWidget + 27))(
        CTouchInterface::m_pWidgets[WidgetID],
        LODWORD(fValue0),
        LODWORD(fValue1));
    }
  }
}

//----- (002B2550) --------------------------------------------------------
void __fastcall CTouchInterface::AddWidgetFlag(CTouchInterface::WidgetIDs WidgetID, int nFlag)
{
  CWidget *v2; // r0

  v2 = CTouchInterface::m_pWidgets[WidgetID];
  if ( v2 )
    v2->m_nFlags |= nFlag;
}

//----- (002B2570) --------------------------------------------------------
void __fastcall CTouchInterface::RemoveWidgetFlag(CTouchInterface::WidgetIDs WidgetID, int nFlag)
{
  CWidget *v2; // r0

  v2 = CTouchInterface::m_pWidgets[WidgetID];
  if ( v2 )
    v2->m_nFlags &= ~nFlag;
}

//----- (002B2590) --------------------------------------------------------
void __fastcall CTouchInterface::AddButtonFlag(CTouchInterface::WidgetIDs WidgetID, int nFlag)
{
  CWidget *v4; // r0

  v4 = CTouchInterface::m_pWidgets[WidgetID];
  if ( v4 )
  {
    if ( (*((int (__fastcall **)(CWidget *))v4->_vptr$CWidget + 9))(v4) == 1 )
      CTouchInterface::m_pWidgets[WidgetID][1]._vptr$CWidget = (int (**)(void))((int)CTouchInterface::m_pWidgets[WidgetID][1]._vptr$CWidget | nFlag);
  }
}

//----- (002B25D0) --------------------------------------------------------
void __fastcall CTouchInterface::RemoveButtonFlag(CTouchInterface::WidgetIDs WidgetID, int nFlag)
{
  CWidget *v4; // r0

  v4 = CTouchInterface::m_pWidgets[WidgetID];
  if ( v4 )
  {
    if ( (*((int (__fastcall **)(CWidget *))v4->_vptr$CWidget + 9))(v4) == 1 )
      CTouchInterface::m_pWidgets[WidgetID][1]._vptr$CWidget = (int (**)(void))((int)CTouchInterface::m_pWidgets[WidgetID][1]._vptr$CWidget & ~nFlag);
  }
}

//----- (002B2610) --------------------------------------------------------
int __fastcall CTouchInterface::GetWidgetPosition(
        CTouchInterface::WidgetIDs WidgetID,
        float *fOriginX,
        float *fOriginY,
        float *fScaleX,
        float *a5)
{
  CWidget *v5; // r12

  v5 = CTouchInterface::m_pWidgets[WidgetID];
  if ( !v5 )
    return 0;
  *fOriginX = v5->m_fOriginX;
  *fOriginY = CTouchInterface::m_pWidgets[WidgetID]->m_fOriginY;
  *fScaleX = CTouchInterface::m_pWidgets[WidgetID]->m_fScaleX;
  *a5 = CTouchInterface::m_pWidgets[WidgetID]->m_fScaleY;
  return 1;
}

//----- (002B2664) --------------------------------------------------------
void __fastcall CTouchInterface::GetWidgetPosition(
        CTouchInterface::WidgetPositionIDs WidgetPositionID,
        float *fOriginX,
        float *fOriginY,
        float *fScaleX,
        float *fScaleY)
{
  CTouchInterface::WidgetPositionIDs v5; // lr
  WidgetPosition *v6; // r0

  v5 = WidgetPositionID;
  v6 = &CTouchInterface::m_WidgetPosition[WidgetPositionID];
  *fOriginX = CTouchInterface::m_WidgetPosition[v5].m_fOriginX;
  *fOriginY = v6->m_fOriginY;
  *fScaleX = v6->m_fScaleX;
  *fScaleY = v6->m_fScaleY;
}

//----- (002B2698) --------------------------------------------------------
CVector2D *__fastcall CTouchInterface::GetTouchDelta(CVector2D *retstr, int nTouchIndex)
{
  float x; // r3
  float y; // r1

  x = CTouchInterface::m_vecCachedDelta[nTouchIndex].x;
  y = CTouchInterface::m_vecCachedDelta[nTouchIndex].y;
  retstr->x = x;
  retstr->y = y;
  return retstr;
}

//----- (002B26B4) --------------------------------------------------------
void __fastcall CTouchInterface::CreateListTextWidget(
        const unsigned __int8 **pszEntries,
        int nNumEntries,
        CTouchInterface::WidgetIDs wId,
        int bAlphabetize,
        bool a5,
        bool a6)
{
  CWidget *v10; // r0
  int *v11; // r0
  float v12; // s0
  CWidgetListText *v13; // r0
  CWidget *v14; // r0
  WidgetPosition WidgetPos; // [sp+10h] [bp-28h] BYREF

  v10 = CTouchInterface::m_pWidgets[wId];
  if ( v10 )
  {
    (*((void (__fastcall **)(CWidget *))v10->_vptr$CWidget + 1))(v10);
    CTouchInterface::m_pWidgets[wId] = 0;
  }
  WidgetPos.m_fOriginY = 220.0;
  WidgetPos.m_fOriginX = 320.0;
  v11 = dword_2B2754;
  if ( wId != WIDGET_CAR_CHEATS )
    v11 = &dword_2B2754[1];
  v12 = *(float *)v11;
  WidgetPos.m_fScaleY = 200.0;
  WidgetPos.m_fScaleX = v12;
  v13 = (CWidgetListText *)operator new((unsigned int)&elf_hash_chain[1762]);
  CWidgetListText::CWidgetListText(
    v13,
    CTouchInterface::m_pszWidgetTextures[wId],
    &WidgetPos,
    pszEntries,
    nNumEntries,
    bAlphabetize,
    a5,
    a6);
  CTouchInterface::m_pWidgets[wId] = v14;
}
// 2B273E: variable 'v14' is possibly undefined
// 10168: using guessed type int elf_hash_chain[22025];
// 2B2754: using guessed type int dword_2B2754[2];

//----- (002B2764) --------------------------------------------------------
void __fastcall CTouchInterface::CreateListTextWidget(
        const unsigned __int8 **pszEntries,
        int nNumEntries,
        CTouchInterface::WidgetIDs wId,
        WidgetPosition *WidgetPos,
        int a5,
        bool a6,
        bool a7)
{
  CWidget *v11; // r0
  CWidgetListText *v12; // r0
  CWidget *v13; // r0

  v11 = CTouchInterface::m_pWidgets[wId];
  if ( v11 )
  {
    (*((void (__fastcall **)(CWidget *))v11->_vptr$CWidget + 1))(v11);
    CTouchInterface::m_pWidgets[wId] = 0;
  }
  v12 = (CWidgetListText *)operator new((unsigned int)&elf_hash_chain[1762]);
  CWidgetListText::CWidgetListText(
    v12,
    CTouchInterface::m_pszWidgetTextures[wId],
    WidgetPos,
    pszEntries,
    nNumEntries,
    a5,
    a6,
    a7);
  CTouchInterface::m_pWidgets[wId] = v13;
}
// 2B27C8: variable 'v13' is possibly undefined
// 10168: using guessed type int elf_hash_chain[22025];

//----- (002B27E4) --------------------------------------------------------
void __fastcall CTouchInterface::CreateShopWidget(
        const unsigned __int8 *pszTitle,
        const unsigned __int8 **pszEntries,
        int nNumEntries,
        WidgetPosition *WidgetPos,
        bool a5)
{
  CWidgetListShop *v9; // r0
  CWidget *v10; // r0

  if ( CTouchInterface::m_pWidgets[156] )
  {
    (*((void (__fastcall **)(CWidget *))CTouchInterface::m_pWidgets[156]->_vptr$CWidget + 1))(CTouchInterface::m_pWidgets[156]);
    CTouchInterface::m_pWidgets[156] = 0;
  }
  v9 = (CWidgetListShop *)operator new((unsigned int)&elf_hash_chain[1827]);
  CWidgetListShop::CWidgetListShop(
    v9,
    pszTitle,
    CTouchInterface::m_pszWidgetTextures[156],
    WidgetPos,
    pszEntries,
    nNumEntries,
    a5);
  CTouchInterface::m_pWidgets[156] = v10;
}
// 2B2844: variable 'v10' is possibly undefined
// 10168: using guessed type int elf_hash_chain[22025];

//----- (002B2860) --------------------------------------------------------
void __fastcall CTouchInterface::DeleteWidget(CTouchInterface::WidgetIDs WidgetID)
{
  CWidget *v2; // r0

  v2 = CTouchInterface::m_pWidgets[WidgetID];
  if ( v2 )
  {
    (*((void (__fastcall **)(CWidget *))v2->_vptr$CWidget + 1))(v2);
    CTouchInterface::m_pWidgets[WidgetID] = 0;
  }
}

//----- (002B2894) --------------------------------------------------------
void CTouchInterface::LoadAllTextureDBs()
{
  TextureDatabaseRuntime *Database; // r0
  TextureDatabaseRuntime *v1; // r0

  Database = TextureDatabaseRuntime::GetDatabase("mobile");
  TextureDatabaseRuntime::Register(Database);
  v1 = TextureDatabaseRuntime::GetDatabase((const char *)&off_2B28B8);
  sub_195DE0(v1);
}
// 2B28B8: using guessed type void *off_2B28B8;

//----- (002B28BC) --------------------------------------------------------
void CTouchInterface::UnloadAllTextureDBs()
{
  TextureDatabaseRuntime *Database; // r0
  TextureDatabaseRuntime *v1; // r0

  Database = TextureDatabaseRuntime::GetDatabase("mobile");
  TextureDatabaseRuntime::Unregister(Database);
  v1 = TextureDatabaseRuntime::GetDatabase((const char *)&off_2B28E0);
  sub_18BFA4(v1);
}
// 2B28E0: using guessed type void *off_2B28E0;

//----- (002B28E4) --------------------------------------------------------
void CTouchInterface::DebugReload()
{
  CWidgetListShop::LoadFromFile();
  CTouchInterface::LoadTouchControls();
  CTouchInterface::CreateAll();
}

//----- (002B28F8) --------------------------------------------------------
void __fastcall CTouchInterface::MarketingHack(int nFrames)
{
  int i; // r1
  CWidget *v2; // r3

  for ( i = 0; i != 190; ++i )
  {
    v2 = CTouchInterface::m_pWidgets[i];
    if ( v2 )
    {
      if ( v2->m_nFrameCount >= 1 )
        v2->m_nFrameCount = nFrames;
    }
  }
}

//----- (002B2924) --------------------------------------------------------
int CTouchInterface::AnyWidgetsUsingAltBack()
{
  int v0; // r0
  int v1; // r6
  CWidget *v2; // r0

  v0 = 0;
  while ( 1 )
  {
    v1 = v0;
    v2 = CTouchInterface::m_pWidgets[v0];
    if ( v2 )
    {
      if ( CWidget::GetEnabled(v2) && (CTouchInterface::m_pWidgets[v1]->m_nFlags & 0x2000) != 0 )
        break;
    }
    v0 = v1 + 1;
    if ( v1 >= 189 )
      return 0;
  }
  return 1;
}

//----- (002B2980) --------------------------------------------------------
void __fastcall CWidget::CWidget(
        CWidget *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos,
        unsigned int nFlags,
        HIDMapping Mapping)
{
  __int64 v7; // r0
  CSprite2d *p_m_Sprite; // r6
  float m_fScaleY; // r1
  TextureDatabaseRuntime *TextureDB; // r8

  HIDWORD(v7) = Mapping;
  p_m_Sprite = &this->m_Sprite;
  LODWORD(v7) = &off_662E6C;
  *(_QWORD *)&this->_vptr$CWidget = v7;
  CSprite2d::CSprite2d(&this->m_Sprite);
  this->m_fOriginX = WidgetPos->m_fOriginX;
  this->m_fOriginY = WidgetPos->m_fOriginY;
  this->m_fScaleX = WidgetPos->m_fScaleX;
  m_fScaleY = WidgetPos->m_fScaleY;
  *(_QWORD *)&this->m_fFadeRate = 0x4974240044400000LL;
  *(_QWORD *)&this->m_RectScreen.top = 0xC9742400C9742400LL;
  *(_QWORD *)&this->m_RectScreen.bottom = 0x3F80000049742400LL;
  *(_QWORD *)&this->m_RectPaddedScreen.left = 0xC974240049742400LL;
  this->m_fScaleY = m_fScaleY;
  this->m_bTaphold = 1;
  this->m_RectPaddedScreen.right = -1000000.0;
  this->m_RectPaddedScreen.bottom = 1000000.0;
  this->m_fTapHoldTime = 0.0;
  CRGBA::CRGBA(&this->m_Color, 0xFFu, 0xFFu, 0xFFu, 0);
  *(_WORD *)&this->m_bEnabled = 0;
  this->m_nTouchIndex = 0;
  this->m_nFrameCount = 0;
  this->m_nFlags = nFlags;
  this->m_fUserData = 0.0;
  this->m_pHoldEffect = 0;
  this->m_fHoldEffectPeriod = 1.2;
  if ( pszSprite
    && (!p_m_Sprite->mpTexture || strcasecmp((const char *)p_m_Sprite->mpTexture->name, (const char *)pszSprite)) )
  {
    TextureDB = CTouchInterface::LoadTextureDB();
    CSprite2d::SetTexture(p_m_Sprite, (unsigned __int8 *)pszSprite);
    CTouchInterface::UnloadTextureDB(TextureDB);
  }
  this->m_fTapHistory[8] = 0.0;
  this->m_fTapHistory[9] = 0.0;
  *(_QWORD *)&this->m_fTapHistory[4] = 0LL;
  *(_QWORD *)&this->m_fTapHistory[6] = 0LL;
  *(_QWORD *)this->m_fTapHistory = 0LL;
  *(_QWORD *)&this->m_fTapHistory[2] = 0LL;
}
// 662E6C: using guessed type void *off_662E6C;

//----- (002B2A94) --------------------------------------------------------
void __fastcall CWidget::SetTexture(CWidget *this, CSprite2d *Sprite, unsigned __int8 *pszSprite, bool bForce)
{
  TextureDatabaseRuntime *TextureDB; // r6

  if ( this->m_bEnabled || bForce )
  {
    if ( pszSprite )
    {
      if ( !Sprite->mpTexture || strcasecmp((const char *)Sprite->mpTexture->name, (const char *)pszSprite) )
      {
        TextureDB = CTouchInterface::LoadTextureDB();
        CSprite2d::SetTexture(Sprite, pszSprite);
        sub_198F08(TextureDB);
      }
    }
    else
    {
      sub_192928(Sprite, 0);
    }
  }
}

//----- (002B2AEE) --------------------------------------------------------
void __fastcall CWidget::ClearTapHistory(CWidget *this)
{
  float *v1; // r1
  float *m_fTapHistory; // r0

  this->m_fTapHistory[8] = 0.0;
  this->m_fTapHistory[9] = 0.0;
  v1 = &this->m_fTapHistory[4];
  m_fTapHistory = this->m_fTapHistory;
  *(_QWORD *)v1 = 0LL;
  *((_QWORD *)v1 + 1) = 0LL;
  *(_QWORD *)m_fTapHistory = 0LL;
  *((_QWORD *)m_fTapHistory + 1) = 0LL;
}

//----- (002B2B08) --------------------------------------------------------
void __fastcall CWidget::~CWidget(CWidget *this)
{
  CHoldEffect *m_pHoldEffect; // r0
  void *v3; // r0

  this->_vptr$CWidget = (int (**)(void))&off_662E6C;
  if ( CWidget::m_pInitialTouchWidget[0] == this )
    CWidget::m_pInitialTouchWidget[0] = 0;
  if ( CWidget::m_pReleasedWidget[0] == this )
    CWidget::m_pReleasedWidget[0] = 0;
  if ( CWidget::m_pSwipedWidget[0] == this )
    CWidget::m_pSwipedWidget[0] = 0;
  if ( CWidget::m_pInitialTouchWidget[1] == this )
    CWidget::m_pInitialTouchWidget[1] = 0;
  if ( CWidget::m_pReleasedWidget[1] == this )
    CWidget::m_pReleasedWidget[1] = 0;
  if ( CWidget::m_pSwipedWidget[1] == this )
    CWidget::m_pSwipedWidget[1] = 0;
  if ( CWidget::m_pInitialTouchWidget[2] == this )
    CWidget::m_pInitialTouchWidget[2] = 0;
  if ( CWidget::m_pReleasedWidget[2] == this )
    CWidget::m_pReleasedWidget[2] = 0;
  if ( CWidget::m_pSwipedWidget[2] == this )
    CWidget::m_pSwipedWidget[2] = 0;
  if ( CWidget::m_pInitialTouchWidget[3] == this )
    CWidget::m_pInitialTouchWidget[3] = 0;
  if ( CWidget::m_pReleasedWidget[3] == this )
    CWidget::m_pReleasedWidget[3] = 0;
  if ( CWidget::m_pSwipedWidget[3] == this )
    CWidget::m_pSwipedWidget[3] = 0;
  if ( CWidget::m_pPinchZoomWidget == this )
    CWidget::m_pPinchZoomWidget = 0;
  m_pHoldEffect = this->m_pHoldEffect;
  if ( m_pHoldEffect )
  {
    CHoldEffect::~CHoldEffect(m_pHoldEffect);
    operator delete(v3);
    this->m_pHoldEffect = 0;
  }
  CSprite2d::~CSprite2d(&this->m_Sprite);
}
// 2B2C40: variable 'v3' is possibly undefined
// 662E6C: using guessed type void *off_662E6C;

//----- (002B2CC8) --------------------------------------------------------
void __fastcall CWidget::Update(CWidget *this)
{
  float32x2_t v1; // d3
  int m_nTouchIndex; // r1
  int v4; // r1
  float m_fTapHoldTime; // s0
  float v6; // s0
  unsigned int m_nFlags; // r0
  float v8; // s6
  RwInt32 screenWidth; // r2
  float v10; // s0
  float v11; // s2
  float v12; // s10
  float v13; // s0
  float v14; // s6
  float v15; // s4
  float v16; // s8
  float v17; // s6
  float v18; // s12
  float v19; // s10
  float v20; // s14
  float32x2_t v21; // d0
  float32x2_t v22; // d1
  float m_fOriginX; // r0
  float m_fOriginY; // r1
  float m_fScaleY; // r3
  float m_fExtraPaddingScale; // s0
  float v27; // s6
  float v28; // s8
  float v29; // s10
  float v30; // s12
  float v31; // s0
  float v32; // s14
  float v33; // s4
  int (__fastcall *v34)(CWidget *, CVector2D *, int); // r6
  int (__fastcall *v35)(CWidget *, CVector2D *, int); // r6
  int (__fastcall *v36)(CWidget *, CVector2D *, int); // r6
  int (__fastcall *v37)(CWidget *, CVector2D *, int); // r6
  CHoldEffect *m_pHoldEffect; // r0
  float32x2_t v39; // d0
  unsigned __int32 v40; // s0
  __int64 v41; // d17
  CRect *p_m_RectScreen; // r0
  float v43; // [sp+0h] [bp-30h] BYREF
  float x; // [sp+4h] [bp-2Ch] BYREF
  CVector2D v45; // [sp+8h] [bp-28h] BYREF
  CVector2D v46; // [sp+10h] [bp-20h] BYREF

  if ( this->m_bTaphold )
  {
    m_nTouchIndex = this->m_nTouchIndex;
    if ( CWidget::m_pInitialTouchWidget[m_nTouchIndex] == this )
    {
      CTouchInterface::GetTouchPosition(&v46, m_nTouchIndex);
      v4 = this->m_nTouchIndex;
      if ( fabsf(v46.x - CWidget::m_vecTouchAnchor[v4].x) < 10.0 )
      {
        CTouchInterface::GetTouchPosition(&v45, v4);
        if ( fabsf(v45.y - CWidget::m_vecTouchAnchor[this->m_nTouchIndex].y) < 10.0 )
        {
          m_fTapHoldTime = this->m_fTapHoldTime;
LABEL_9:
          v6 = CWidget::m_fElapsedTime + m_fTapHoldTime;
          this->m_fTapHoldTime = v6;
          goto LABEL_11;
        }
      }
    }
  }
  if ( CHID::Implements(this->m_HIDMapping) && CHID::IsPressed(this->m_HIDMapping, 0) )
  {
    m_fTapHoldTime = this->m_fTapHoldTime;
    this->m_bTaphold = 1;
    goto LABEL_9;
  }
  this->m_fTapHoldTime = 0.0;
  this->m_bTaphold = 0;
LABEL_11:
  m_nFlags = this->m_nFlags;
  if ( (m_nFlags & 0x1000) != 0 )
  {
    m_fOriginX = this->m_fOriginX;
    m_fOriginY = this->m_fOriginY;
    m_fScaleY = this->m_fScaleY;
    v46.x = this->m_fScaleX;
    v45.x = m_fScaleY;
    v43 = m_fOriginY;
    x = m_fOriginX;
    CorrectAspect(&x, &v43, &v46.x, &v45.x);
    m_fExtraPaddingScale = this->m_fExtraPaddingScale;
    v27 = v46.x * m_fExtraPaddingScale;
    v28 = x;
    v29 = m_fExtraPaddingScale * v45.x;
    v30 = v43;
    v31 = x + v46.x;
    v32 = v43 + v45.x;
    v33 = v43 - v45.x;
    v21.n64_f32[1] = x - v27;
    v22.n64_f32[1] = v43 + v29;
    this->m_RectScreen.left = x - v46.x;
    v22.n64_f32[0] = v30 - v29;
    this->m_RectScreen.top = v32;
    this->m_RectScreen.right = v31;
    v21.n64_f32[0] = v28 + v27;
    this->m_RectScreen.bottom = v33;
    LODWORD(this->m_RectPaddedScreen.left) = v21.n64_u32[1];
    LODWORD(this->m_RectPaddedScreen.top) = v22.n64_u32[1];
    m_nFlags = this->m_nFlags;
  }
  else
  {
    v8 = 448.0;
    screenWidth = RsGlobal.screenWidth;
    if ( (m_nFlags & 2) != 0 )
      v8 = 640.0;
    else
      screenWidth = RsGlobal.screenHeight;
    v10 = (float)RsGlobal.screenWidth / 640.0;
    v11 = this->m_fScaleY * (float)((float)screenWidth / v8);
    v12 = this->m_fScaleX * v10;
    v13 = v10 * this->m_fOriginX;
    v14 = this->m_fExtraPaddingScale;
    v15 = this->m_fOriginY * (float)((float)RsGlobal.screenHeight / 448.0);
    v16 = v12 * v14;
    v17 = v11 * v14;
    v18 = v13 - v12;
    v19 = v12 + v13;
    v20 = v15 + v11;
    v21.n64_f32[1] = v15 - v11;
    v22.n64_f32[1] = v13 - v16;
    v21.n64_f32[0] = v16 + v13;
    this->m_RectScreen.left = v18;
    v22.n64_f32[0] = v15 - v17;
    this->m_RectScreen.top = v20;
    this->m_RectScreen.right = v19;
    LODWORD(this->m_RectScreen.bottom) = v21.n64_u32[1];
    LODWORD(this->m_RectPaddedScreen.left) = v22.n64_u32[1];
    this->m_RectPaddedScreen.top = v17 + v15;
  }
  LODWORD(this->m_RectPaddedScreen.right) = v21.n64_u32[0];
  LODWORD(this->m_RectPaddedScreen.bottom) = v22.n64_u32[0];
  if ( (m_nFlags & 0x40) != 0 )
  {
    if ( CTouchInterface::IsTouchDown(0) )
    {
      v34 = (int (__fastcall *)(CWidget *, CVector2D *, int))*((_DWORD *)this->_vptr$CWidget + 3);
      CTouchInterface::GetTouchPosition(&v46, 0);
      if ( v34(this, &v46, 1) == 1 )
        this->m_nTouchIndex = 0;
    }
    if ( CTouchInterface::IsTouchDown(1) )
    {
      v35 = (int (__fastcall *)(CWidget *, CVector2D *, int))*((_DWORD *)this->_vptr$CWidget + 3);
      CTouchInterface::GetTouchPosition(&v46, 1);
      if ( v35(this, &v46, 1) == 1 )
        this->m_nTouchIndex = 1;
    }
    if ( CTouchInterface::IsTouchDown(2) )
    {
      v36 = (int (__fastcall *)(CWidget *, CVector2D *, int))*((_DWORD *)this->_vptr$CWidget + 3);
      CTouchInterface::GetTouchPosition(&v46, 2);
      if ( v36(this, &v46, 1) == 1 )
        this->m_nTouchIndex = 2;
    }
    if ( CTouchInterface::IsTouchDown(3) )
    {
      v37 = (int (__fastcall *)(CWidget *, CVector2D *, int))*((_DWORD *)this->_vptr$CWidget + 3);
      CTouchInterface::GetTouchPosition(&v46, 3);
      if ( v37(this, &v46, 1) == 1 )
        this->m_nTouchIndex = 3;
    }
    m_nFlags = this->m_nFlags;
  }
  if ( (m_nFlags & 0x80) != 0 )
    (*((void (__fastcall **)(CWidget *))this->_vptr$CWidget + 25))(this);
  m_pHoldEffect = this->m_pHoldEffect;
  if ( m_pHoldEffect )
  {
    v1.n64_u32[0] = LODWORD(this->m_fHoldEffectPeriod);
    v21.n64_f32[0] = v1.n64_f32[0] * -0.25;
    v22.n64_f32[0] = v1.n64_f32[0] * 0.625;
    v1.n64_u32[0] = 0;
    v21.n64_f32[0] = this->m_fTapHoldTime + v21.n64_f32[0];
    v39.n64_u64[0] = vmax_f32(v21, v1).n64_u64[0];
    v39.n64_f32[0] = v39.n64_f32[0] / v22.n64_f32[0];
    v22.n64_u32[0] = 1.0;
    v40 = vmin_f32(v39, v22).n64_u32[0];
    if ( this->m_bEnabled )
      v1.n64_u32[0] = v40;
    LODWORD(m_pHoldEffect->m_fProgress) = v1.n64_u32[0];
    v41 = *(_QWORD *)&this->m_RectScreen.right;
    p_m_RectScreen = &this->m_pHoldEffect->m_RectScreen;
    *(_QWORD *)&p_m_RectScreen->left = *(_QWORD *)&this->m_RectScreen.left;
    *(_QWORD *)&p_m_RectScreen->right = v41;
  }
}
// 2B2FBA: variable 'v1' is possibly undefined

//----- (002B3020) --------------------------------------------------------
void __fastcall CWidget::Visualize(CWidget *this)
{
  float m_fExtraPaddingScale; // s16
  __int64 v3; // d17
  float32x4_t v4; // q8
  float v5; // s0
  float screenWidth; // s18
  float m_fScaleX; // s20
  float v8; // s4
  float v9; // s0
  CRGBA v10; // r0
  CRGBA v11; // r0
  const Char *v12; // r0
  CRect v13[32]; // [sp+10h] [bp-238h] BYREF
  CRGBA v14; // [sp+214h] [bp-34h] BYREF
  CRGBA v15; // [sp+218h] [bp-30h] BYREF
  CRGBA rgba; // [sp+21Ch] [bp-2Ch] BYREF

  m_fExtraPaddingScale = this->m_fExtraPaddingScale;
  if ( LOBYTE(this->m_nFlags) << 31 )
  {
    if ( m_fExtraPaddingScale > 1.0 )
    {
      v5 = (float)(this->m_RectScreen.left + this->m_RectScreen.right) * 0.5;
      screenWidth = (float)RsGlobal.screenWidth;
      v13[0].top = (float)(this->m_RectScreen.top + this->m_RectScreen.bottom) * 0.5;
      v13[0].left = v5;
      m_fScaleX = this->m_fScaleX;
      CRGBA::CRGBA(&rgba, 0xFFu, 0xFFu, 0, 0x80u);
      CSprite2d::DrawCircleAtNearClip(
        (const CVector2D *)v13,
        m_fExtraPaddingScale
      * (float)((float)((float)(screenWidth / 640.0) - m_fScaleX) + (float)((float)(screenWidth / 640.0) - m_fScaleX)),
        &rgba,
        15);
    }
    v8 = this->m_RectScreen.left + this->m_RectScreen.right;
    v13[0].top = (float)(this->m_RectScreen.top + this->m_RectScreen.bottom) * 0.5;
    v13[0].left = v8 * 0.5;
    v9 = (float)((float)RsGlobal.screenWidth / 640.0) - this->m_fScaleX;
    if ( this->m_bEnabled )
      CRGBA::CRGBA(&rgba, 0, 0xFFu, 0, 0x80u);
    else
      CRGBA::CRGBA(&rgba, 0xFFu, 0, 0, 0x80u);
    CSprite2d::DrawCircleAtNearClip((const CVector2D *)v13, v9 + v9, &rgba, 15);
  }
  else
  {
    if ( m_fExtraPaddingScale > 1.0 )
    {
      v3 = *(_QWORD *)&this->m_RectPaddedScreen.right;
      *(_QWORD *)&v13[0].left = *(_QWORD *)&this->m_RectPaddedScreen.left;
      *(_QWORD *)&v13[0].right = v3;
      CRGBA::CRGBA(&rgba, 0xFFu, 0xFFu, 0, 0x80u);
      CSprite2d::DrawRect(v13, &rgba);
    }
    CRGBA::CRGBA((CRGBA *)v13, 0xFFu, 0xFFu, 0xFFu, 0x80u);
    CSprite2d::DrawRect(&this->m_RectScreen, (const CRGBA *)v13);
    v4.n128_u64[0] = 0xC000000040000000LL;
    v4.n128_u64[1] = 0x40000000C0000000LL;
    v13[0] = (CRect)vaddq_f32((float32x4_t)this->m_RectScreen, v4);
    if ( this->m_bEnabled )
      CRGBA::CRGBA(&rgba, 0, 0xFFu, 0, 0x80u);
    else
      CRGBA::CRGBA(&rgba, 0xFFu, 0, 0, 0x80u);
    CSprite2d::DrawRect(v13, &rgba);
  }
  CFont::SetFontStyle(3u);
  CFont::SetBackground(0, 0);
  CFont::SetWrapx((float)RsGlobal.screenWidth);
  CFont::SetScale(0.75);
  CFont::SetOrientation(0);
  CFont::SetCentreSize((float)((float)RsGlobal.screenWidth / 640.0) * (float)RsGlobal.screenWidth);
  CFont::SetProportional(1u);
  CRGBA::CRGBA(&v15, 0, 0, 0, 0xFFu);
  CFont::SetColor(v10);
  CRGBA::CRGBA(&v14, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
  CFont::SetDropColor(v11);
  CFont::SetEdge(0);
  v12 = (const Char *)(*((int (__fastcall **)(CWidget *))this->_vptr$CWidget + 2))(this);
  AsciiToGxtChar(v12, (GxtChar *)v13);
  CFont::PrintString(
    this->m_fOriginX * (float)((float)RsGlobal.screenWidth / 640.0),
    this->m_fOriginY * (float)((float)RsGlobal.screenHeight / 448.0),
    (GxtChar *)v13);
}
// 2B3242: variable 'v10' is possibly undefined
// 2B3254: variable 'v11' is possibly undefined

//----- (002B32E4) --------------------------------------------------------
bool __fastcall CWidget::AndroidBackEnabled(CWidget *this)
{
  if ( !this->m_bEnabled || (this->m_nFlags & 0x2000) == 0 )
    return 0;
  if ( CTouchInterface::m_pWidgets[161] )
    return !CTouchInterface::m_pWidgets[161]->m_bEnabled;
  return 1;
}

//----- (002B331C) --------------------------------------------------------
bool __fastcall CWidget::GetEnabled(CWidget *this)
{
  return this->m_bEnabled;
}

//----- (002B3324) --------------------------------------------------------
bool __fastcall CWidget::IsTouched(CWidget *this, CVector2D *pVecOut)
{
  bool v3; // zf
  _BOOL4 v4; // r1
  HIDMapping m_HIDMapping; // r0
  bool v7; // r5
  int (__fastcall *v8)(CWidget *, CVector2D *, int); // r6
  int m_nTouchIndex; // r0
  CWidget *v10; // r1
  int (__fastcall *v11)(CWidget *, CVector2D *, int); // r6
  int v12; // r0
  CVector2D v13[3]; // [sp+0h] [bp-18h] BYREF

  if ( this->m_bEnabled && (this->m_nFlags & 0x2000) != 0 )
  {
    v3 = CTouchInterface::m_pWidgets[161] == 0;
    if ( CTouchInterface::m_pWidgets[161] )
      v3 = !CTouchInterface::m_pWidgets[161]->m_bEnabled;
    if ( v3
      && (LIB_KeyboardState(KK_ESCAPE) == OSPS_ButtonPressed || LIB_KeyboardState(KK_ESCAPE) == OSPS_ButtonDown)
      && !skipFrame )
    {
      return 1;
    }
  }
  v4 = CHID::Replaces(this->m_HIDMapping);
  m_HIDMapping = this->m_HIDMapping;
  if ( v4 )
    return sub_196BD4(m_HIDMapping, 0);
  if ( CHID::Implements(m_HIDMapping) && CHID::IsPressed(this->m_HIDMapping, 0) )
    return 1;
  if ( (this->m_nFlags & 0x40) != 0 && CTouchInterface::IsTouchDown(this->m_nTouchIndex) )
  {
    v8 = (int (__fastcall *)(CWidget *, CVector2D *, int))*((_DWORD *)this->_vptr$CWidget + 3);
    CTouchInterface::GetTouchPosition(v13, this->m_nTouchIndex);
    v7 = 1;
    if ( v8(this, v13, 1) )
      return v7;
  }
  m_nTouchIndex = this->m_nTouchIndex;
  v10 = CWidget::m_pInitialTouchWidget[m_nTouchIndex];
  if ( (this->m_nFlags & 0x20) == 0 )
  {
    if ( v10 == this && CTouchInterface::IsTouchDown(m_nTouchIndex) )
    {
      v11 = (int (__fastcall *)(CWidget *, CVector2D *, int))*((_DWORD *)this->_vptr$CWidget + 3);
      CTouchInterface::GetTouchPosition(v13, this->m_nTouchIndex);
      v7 = 1;
      v12 = v11(this, v13, 1);
      goto LABEL_29;
    }
    return 0;
  }
  if ( !v10 )
  {
    if ( !this )
      return 1;
LABEL_27:
    if ( CTouchInterface::IsTouchDown(m_nTouchIndex) )
    {
      v7 = 1;
      v12 = (*((int (__fastcall **)(CWidget *, CVector2D *, int))this->_vptr$CWidget + 3))(
              this,
              &CWidget::m_vecTouchAnchor[this->m_nTouchIndex],
              1);
LABEL_29:
      if ( !v12 )
        return 0;
      return v7;
    }
    return 0;
  }
  if ( (*((int (__fastcall **)(CWidget *))v10->_vptr$CWidget + 9))(CWidget::m_pInitialTouchWidget[m_nTouchIndex]) )
    return 0;
  m_nTouchIndex = this->m_nTouchIndex;
  if ( CWidget::m_pInitialTouchWidget[m_nTouchIndex] != this )
    goto LABEL_27;
  return 1;
}

//----- (002B3484) --------------------------------------------------------
bool __fastcall CWidget::IsReleased(CWidget *this, CVector2D *pVecOut)
{
  bool v3; // zf
  _BOOL4 v4; // r1
  HIDMapping m_HIDMapping; // r0
  unsigned int v7; // r0

  if ( !this->m_bEnabled || (this->m_nFlags & 0x2000) == 0 )
    goto LABEL_8;
  v3 = CTouchInterface::m_pWidgets[161] == 0;
  if ( CTouchInterface::m_pWidgets[161] )
    v3 = !CTouchInterface::m_pWidgets[161]->m_bEnabled;
  if ( !v3 || LIB_KeyboardState(KK_ESCAPE) | skipFrame )
  {
LABEL_8:
    v4 = CHID::Replaces(this->m_HIDMapping);
    m_HIDMapping = this->m_HIDMapping;
    if ( v4 )
    {
      if ( !CHID::IsReleased(m_HIDMapping) )
        return 0;
    }
    else if ( (!CHID::Implements(m_HIDMapping) || !CHID::IsReleased(this->m_HIDMapping))
           && CWidget::m_pReleasedWidget[this->m_nTouchIndex] != this )
    {
      return 0;
    }
  }
  if ( CTouchInterface::m_pWidgets[8] == this )
  {
    v7 = 128;
  }
  else if ( CTouchInterface::m_pWidgets[1] == this )
  {
    v7 = 256;
  }
  else
  {
    if ( CTouchInterface::m_pWidgets[66] != this )
      return 1;
    v7 = 0x2000;
  }
  CWidgetHelpText::ConditionSatisfied(v7);
  return 1;
}

//----- (002B3558) --------------------------------------------------------
bool __fastcall CWidget::IsPinchZooming(CWidget *this, CVector2D *pVecOut)
{
  return CWidget::m_pPinchZoomWidget == this;
}

//----- (002B3570) --------------------------------------------------------
bool __fastcall CWidget::IsSwipedLeft(CWidget *this)
{
  int m_nTouchIndex; // r1
  bool v3; // r4
  CVector2D v5; // [sp+0h] [bp-10h] BYREF

  m_nTouchIndex = this->m_nTouchIndex;
  v3 = 0;
  if ( CWidget::m_pSwipedWidget[m_nTouchIndex] == this )
  {
    CTouchInterface::GetTouchPosition(&v5, m_nTouchIndex);
    if ( v5.x < (float)(CWidget::m_vecTouchAnchor[this->m_nTouchIndex].x - CWidget::SWIPE_DISTANCE) )
      return 1;
  }
  return v3;
}

//----- (002B35D0) --------------------------------------------------------
bool __fastcall CWidget::IsSwipedRight(CWidget *this)
{
  int m_nTouchIndex; // r1
  bool v3; // r4
  CVector2D v5; // [sp+0h] [bp-10h] BYREF

  m_nTouchIndex = this->m_nTouchIndex;
  v3 = 0;
  if ( CWidget::m_pSwipedWidget[m_nTouchIndex] == this )
  {
    CTouchInterface::GetTouchPosition(&v5, m_nTouchIndex);
    if ( v5.x > (float)(CWidget::m_vecTouchAnchor[this->m_nTouchIndex].x + CWidget::SWIPE_DISTANCE) )
      return 1;
  }
  return v3;
}

//----- (002B3630) --------------------------------------------------------
bool __fastcall CWidget::IsSwipedDown(CWidget *this)
{
  int m_nTouchIndex; // r1
  bool v3; // r4
  CVector2D v5; // [sp+0h] [bp-10h] BYREF

  m_nTouchIndex = this->m_nTouchIndex;
  v3 = 0;
  if ( CWidget::m_pSwipedWidget[m_nTouchIndex] == this )
  {
    CTouchInterface::GetTouchPosition(&v5, m_nTouchIndex);
    if ( v5.y > (float)(CWidget::m_vecTouchAnchor[this->m_nTouchIndex].y + CWidget::SWIPE_DISTANCE) )
      return 1;
  }
  return v3;
}

//----- (002B3690) --------------------------------------------------------
bool __fastcall CWidget::IsSwipedUp(CWidget *this)
{
  int m_nTouchIndex; // r1
  bool v3; // r4
  CVector2D v5; // [sp+0h] [bp-10h] BYREF

  m_nTouchIndex = this->m_nTouchIndex;
  v3 = 0;
  if ( CWidget::m_pSwipedWidget[m_nTouchIndex] == this )
  {
    CTouchInterface::GetTouchPosition(&v5, m_nTouchIndex);
    if ( v5.y < (float)(CWidget::m_vecTouchAnchor[this->m_nTouchIndex].y - CWidget::SWIPE_DISTANCE) )
      return 1;
  }
  return v3;
}

//----- (002B36F0) --------------------------------------------------------
bool __fastcall CWidget::CoordsAreInsideWidget(CWidget *this, const CVector2D *vecCoords, bool bUseExtraPaddingScale)
{
  float x; // s2
  float y; // s0
  float v6; // s0
  float m_fScaleX; // s2
  float v8; // s4
  float v9; // s6
  float v10; // s4

  if ( !(LOBYTE(this->m_nFlags) << 31) )
  {
    x = vecCoords->x;
    y = vecCoords->y;
    if ( bUseExtraPaddingScale )
    {
      if ( x >= this->m_RectPaddedScreen.left
        && x <= this->m_RectPaddedScreen.right
        && y >= this->m_RectPaddedScreen.bottom )
      {
        return y <= this->m_RectPaddedScreen.top;
      }
    }
    else if ( x >= this->m_RectScreen.left
           && x <= this->m_RectScreen.right
           && y >= this->m_RectScreen.bottom
           && y <= this->m_RectScreen.top )
    {
      return 1;
    }
    return 0;
  }
  v6 = (float)RsGlobal.screenWidth / 640.0;
  m_fScaleX = this->m_fScaleX;
  v8 = (float)(this->m_fOriginY * (float)((float)RsGlobal.screenHeight / 448.0)) - vecCoords->y;
  v9 = (float)(this->m_fOriginX * v6) - vecCoords->x;
  v10 = (float)(v9 * v9) + (float)(v8 * v8);
  if ( bUseExtraPaddingScale )
    m_fScaleX = m_fScaleX * this->m_fExtraPaddingScale;
  return sqrtf(v10) < (float)(m_fScaleX * v6);
}

//----- (002B3808) --------------------------------------------------------
void __fastcall CWidget::SetInitialTouchWidget(int nTouchIndex, CWidget *pInitialTouchWidget)
{
  CWidget::m_pInitialTouchWidget[nTouchIndex] = pInitialTouchWidget;
  if ( pInitialTouchWidget )
  {
    pInitialTouchWidget->m_nTouchIndex = nTouchIndex;
    (*((void (__fastcall **)(CWidget *))CWidget::m_pInitialTouchWidget[nTouchIndex]->_vptr$CWidget + 21))(CWidget::m_pInitialTouchWidget[nTouchIndex]);
  }
}

//----- (002B3834) --------------------------------------------------------
void __fastcall CWidget::SetReleasedWidget(int nTouchIndex, CWidget *pReleasedWidget)
{
  CWidget::m_pReleasedWidget[nTouchIndex] = pReleasedWidget;
  if ( pReleasedWidget )
    (*((void (__fastcall **)(CWidget *))pReleasedWidget->_vptr$CWidget + 23))(pReleasedWidget);
}

//----- (002B3850) --------------------------------------------------------
void __fastcall CWidget::SetPinchZoomWidget(CWidget *pPinchZoomWidget)
{
  int v2; // r2
  CWidget *v3; // r0

  v2 = CWidget::m_pInitialTouchWidget[1] == pPinchZoomWidget;
  if ( CWidget::m_pInitialTouchWidget[0] == pPinchZoomWidget )
    ++v2;
  if ( CWidget::m_pInitialTouchWidget[2] == pPinchZoomWidget )
    ++v2;
  if ( CWidget::m_pInitialTouchWidget[3] == pPinchZoomWidget )
    ++v2;
  v3 = 0;
  if ( v2 == 2 )
    v3 = pPinchZoomWidget;
  CWidget::m_pPinchZoomWidget = v3;
  if ( v3 )
    (*((void (__fastcall **)(CWidget *))v3->_vptr$CWidget + 22))(v3);
}

//----- (002B38B0) --------------------------------------------------------
void __fastcall CWidget::SetSwipedWidget(int nTouchIndex, CWidget *pSwipedWidget)
{
  CWidget::m_pSwipedWidget[nTouchIndex] = pSwipedWidget;
  if ( pSwipedWidget )
    (*((void (__fastcall **)(CWidget *))pSwipedWidget->_vptr$CWidget + 24))(pSwipedWidget);
}

//----- (002B38CC) --------------------------------------------------------
void __fastcall CWidget::OnInitialTouch(CWidget *this)
{
  __int64 v1; // d16
  __int64 v2; // d17
  __int64 v3; // d19
  float v4; // r2
  float v5; // s0

  v1 = *(_QWORD *)this->m_fTapHistory;
  v2 = *(_QWORD *)&this->m_fTapHistory[2];
  this->m_fTapHoldTime = 0.0;
  this->m_bTaphold = 1;
  v3 = *(_QWORD *)&this->m_fTapHistory[6];
  v4 = this->m_fTapHistory[8];
  *(_QWORD *)&this->m_fTapHistory[5] = *(_QWORD *)&this->m_fTapHistory[4];
  *(_QWORD *)&this->m_fTapHistory[7] = v3;
  this->m_fTapHistory[9] = v4;
  *(_QWORD *)&this->m_fTapHistory[1] = v1;
  *(_QWORD *)&this->m_fTapHistory[3] = v2;
  v5 = CWidget::m_fTime;
  this->m_fTapHistory[0] = v5;
}

//----- (002B3914) --------------------------------------------------------
float __fastcall CWidget::GetPinchDistance(CWidget *this)
{
  int v1; // r4
  int v2; // r1
  int v3; // r4
  float v4; // s0
  CVector2D v6; // [sp+0h] [bp-18h] BYREF
  CVector2D v7; // [sp+8h] [bp-10h] BYREF

  v1 = 0;
  v2 = 0;
  if ( CWidget::m_pPinchZoomWidget != CWidget::m_pInitialTouchWidget[0] )
  {
    v1 = 1;
    v2 = -1;
  }
  if ( CWidget::m_pPinchZoomWidget == CWidget::m_pInitialTouchWidget[1] )
    v2 = v1;
  v3 = 1;
  if ( CWidget::m_pPinchZoomWidget != CWidget::m_pInitialTouchWidget[0] )
    v3 = -1;
  if ( CWidget::m_pPinchZoomWidget != CWidget::m_pInitialTouchWidget[1] )
    v3 = -1;
  if ( CWidget::m_pPinchZoomWidget == CWidget::m_pInitialTouchWidget[2] )
  {
    if ( v2 == -1 )
    {
      v2 = 2;
    }
    else if ( v3 == -1 )
    {
      v3 = 2;
    }
  }
  if ( CWidget::m_pPinchZoomWidget == CWidget::m_pInitialTouchWidget[3] )
  {
    if ( v2 == -1 )
    {
      v2 = 3;
    }
    else if ( v3 == -1 )
    {
      v3 = 3;
    }
  }
  v4 = 0.0;
  if ( v3 != -1 && v2 != -1 )
  {
    CTouchInterface::GetTouchPosition(&v7, v2);
    CTouchInterface::GetTouchPosition(&v6, v3);
    return sqrtf((float)((float)(v7.x - v6.x) * (float)(v7.x - v6.x)) + (float)((float)(v7.y - v6.y)
                                                                              * (float)(v7.y - v6.y)));
  }
  return v4;
}

//----- (002B39D8) --------------------------------------------------------
int __fastcall CWidget::GetNumTapsInTime(CWidget *this, float fSeconds)
{
  float v3; // s0
  int result; // r0
  double v5; // d18
  double v6; // d17
  float v7; // s0
  double v8; // d18
  float v9; // s0
  double v10; // d18
  float v11; // s0
  double v12; // d18
  float v13; // s0
  double v14; // d18
  float v15; // s0
  double v16; // d18
  float v17; // s0
  double v18; // d18
  float v19; // s0
  double v20; // d18
  float v21; // s0
  double v22; // d18
  float v23; // s0
  int v24; // r1
  double v25; // d16

  v3 = this->m_fTapHistory[0];
  if ( v3 <= 0.0 )
    return 0;
  result = 0;
  v5 = CWidget::m_fTime - v3;
  if ( v5 > 0.0 )
  {
    v6 = fSeconds;
    if ( v5 < fSeconds )
    {
      v7 = this->m_fTapHistory[1];
      if ( v7 <= 0.0 )
      {
        return 1;
      }
      else
      {
        result = 1;
        v8 = CWidget::m_fTime - v7;
        if ( v8 > 0.0 && v8 < v6 )
        {
          v9 = this->m_fTapHistory[2];
          if ( v9 > 0.0 )
          {
            result = 2;
            v10 = CWidget::m_fTime - v9;
            if ( v10 > 0.0 && v10 < v6 )
            {
              v11 = this->m_fTapHistory[3];
              if ( v11 > 0.0 )
              {
                result = 3;
                v12 = CWidget::m_fTime - v11;
                if ( v12 > 0.0 && v12 < v6 )
                {
                  v13 = this->m_fTapHistory[4];
                  if ( v13 > 0.0 )
                  {
                    result = 4;
                    v14 = CWidget::m_fTime - v13;
                    if ( v14 > 0.0 && v14 < v6 )
                    {
                      v15 = this->m_fTapHistory[5];
                      if ( v15 > 0.0 )
                      {
                        result = 5;
                        v16 = CWidget::m_fTime - v15;
                        if ( v16 > 0.0 && v16 < v6 )
                        {
                          v17 = this->m_fTapHistory[6];
                          if ( v17 > 0.0 )
                          {
                            result = 6;
                            v18 = CWidget::m_fTime - v17;
                            if ( v18 > 0.0 && v18 < v6 )
                            {
                              v19 = this->m_fTapHistory[7];
                              if ( v19 > 0.0 )
                              {
                                result = 7;
                                v20 = CWidget::m_fTime - v19;
                                if ( v20 > 0.0 && v20 < v6 )
                                {
                                  v21 = this->m_fTapHistory[8];
                                  if ( v21 > 0.0 )
                                  {
                                    result = 8;
                                    v22 = CWidget::m_fTime - v21;
                                    if ( v22 > 0.0 && v22 < v6 )
                                    {
                                      v23 = this->m_fTapHistory[9];
                                      result = 9;
                                      if ( v23 > 0.0 )
                                      {
                                        v24 = 9;
                                        v25 = CWidget::m_fTime - v23;
                                        if ( v25 < v6 )
                                          v24 = 10;
                                        if ( v25 <= 0.0 )
                                          return 9;
                                        return v24;
                                      }
                                    }
                                  }
                                  else
                                  {
                                    return 8;
                                  }
                                }
                              }
                              else
                              {
                                return 7;
                              }
                            }
                          }
                          else
                          {
                            return 6;
                          }
                        }
                      }
                      else
                      {
                        return 5;
                      }
                    }
                  }
                  else
                  {
                    return 4;
                  }
                }
              }
              else
              {
                return 3;
              }
            }
          }
          else
          {
            return 2;
          }
        }
      }
    }
  }
  return result;
}

//----- (002B3BEC) --------------------------------------------------------
void __fastcall CWidget::DrawHelpIcon(
        CWidget *this,
        const unsigned __int8 *pszCharacters,
        float fX,
        float fY,
        float fHeight,
        int nAlpha)
{
  if ( CHID::Implements(this->m_HIDMapping) )
    CHID::DrawHelpIcon(pszCharacters, this->m_HIDMapping, fX, fY, fHeight, nAlpha, 0);
}

//----- (002B3C2C) --------------------------------------------------------
bool __fastcall CWidget::IsDoubleTapped(CWidget *this)
{
  _BOOL4 v2; // r1
  HIDMapping m_HIDMapping; // r0

  v2 = CHID::Replaces(this->m_HIDMapping);
  m_HIDMapping = this->m_HIDMapping;
  if ( v2 )
    return sub_196DE8(m_HIDMapping);
  if ( CHID::Implements(m_HIDMapping) && CHID::IsDoubleTapped(this->m_HIDMapping) )
    return 1;
  return CWidget::GetNumTapsInTime(this, 0.33) > 1;
}

//----- (002B3C78) --------------------------------------------------------
void __fastcall CWidget::DecrementFrameCount(CWidget *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  int v3; // s0

  v1.n64_u32[0] = 0;
  v2.n64_f32[0] = (float)(this->m_nFrameCount - 1);
  v3 = (int)vmax_f32(v2, v1).n64_f32[0];
  this->m_nFrameCount = v3;
  if ( !v3 )
    this->m_bEnabled = 0;
}
// 2B3C88: variable 'v2' is possibly undefined
// 2B3C88: variable 'v1' is possibly undefined

//----- (002B3CAC) --------------------------------------------------------
void __fastcall CWidget::SetEnabled(CWidget *this, bool bEnabled)
{
  this->m_bEnabled = bEnabled;
}

//----- (002B3CB8) --------------------------------------------------------
void __fastcall CWidget::GetGradientColor(CRGBA *a1, CWidget *this, float fLevel, int nAlpha)
{
  float32x2_t v4; // d0
  float32x2_t v5; // d1
  float32x2_t v6; // d2
  float32x2_t v7; // d3

  v7.n64_u32[0] = 0;
  v5.n64_u32[0] = 1.0;
  v4.n64_f32[0] = fLevel + -0.5;
  v6.n64_f32[0] = fLevel + fLevel;
  CRGBA::CRGBA(
    a1,
    (unsigned int)(float)((float)(1.0 - vmax_f32(v4, v7).n64_f32[0]) * 255.0),
    (unsigned int)(float)(vmin_f32(v6, v5).n64_f32[0] * 255.0),
    0,
    nAlpha);
}
// 2B3CDA: variable 'v4' is possibly undefined
// 2B3CDA: variable 'v7' is possibly undefined
// 2B3CE6: variable 'v6' is possibly undefined
// 2B3CE6: variable 'v5' is possibly undefined

//----- (002B3D14) --------------------------------------------------------
void __fastcall CWidget::SetScreenRect(CWidget *this, const CRect *Rect)
{
  __int64 v2; // d17
  float right; // s6
  float top; // s4
  float bottom; // s8
  float v6; // s14
  float v7; // s0
  float left; // s2
  float v9; // s12
  float v10; // s2
  float v11; // s0
  float v12; // s6
  float v13; // s4
  float v14; // s8
  float v15; // s10
  float v16; // s6
  float m_fExtraPaddingScale; // s14
  float v18; // s12
  float v19; // s14

  v2 = *(_QWORD *)&Rect->right;
  *(_QWORD *)&this->m_RectScreen.left = *(_QWORD *)&Rect->left;
  *(_QWORD *)&this->m_RectScreen.right = v2;
  right = this->m_RectScreen.right;
  top = this->m_RectScreen.top;
  bottom = this->m_RectScreen.bottom;
  v6 = top - bottom;
  v7 = (float)RsGlobal.screenWidth / 640.0;
  left = this->m_RectScreen.left;
  v9 = (float)((float)(left + right) * 0.5) / v7;
  this->m_fOriginX = v9;
  v10 = (float)(fabsf(right - left) / v7) * 0.5;
  v11 = v9 * v7;
  v12 = (float)RsGlobal.screenHeight / 448.0;
  v13 = (float)((float)(top + bottom) * 0.5) / v12;
  v14 = (float)(fabsf(v6) / v12) * 0.5;
  v15 = v10;
  v16 = v13 * v12;
  if ( (this->m_nFlags & 2) == 0 )
    v15 = v14;
  m_fExtraPaddingScale = this->m_fExtraPaddingScale;
  this->m_fScaleY = v14;
  v18 = v10 * m_fExtraPaddingScale;
  this->m_fScaleX = v10;
  v19 = m_fExtraPaddingScale * v15;
  this->m_RectPaddedScreen.left = v11 - v18;
  this->m_RectPaddedScreen.right = v11 + v18;
  this->m_fOriginY = v13;
  this->m_fScaleY = v15;
  this->m_RectPaddedScreen.top = v19 + v16;
  this->m_RectPaddedScreen.bottom = v16 - v19;
}

//----- (002B3DFC) --------------------------------------------------------
void __fastcall CWidget::ManageAlpha(CWidget *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  double v3; // d16
  double alpha; // d17
  unsigned __int32 v5; // s0

  v3 = CWidget::m_fElapsedTime * this->m_fFadeRate;
  alpha = (double)this->m_Color._anon_0._anon_0.alpha;
  if ( this->m_bEnabled )
  {
    v1.n64_f32[0] = v3 + alpha;
    v2.n64_u32[0] = 1132396544;
    v5 = vmin_f32(v1, v2).n64_u32[0];
  }
  else
  {
    v1.n64_f32[0] = alpha - v3;
    v2.n64_u32[0] = 0;
    v5 = vmax_f32(v1, v2).n64_u32[0];
  }
  this->m_Color._anon_0._anon_0.alpha = (unsigned int)*(float *)&v5;
}
// 2B3E30: variable 'v1' is possibly undefined
// 2B3E30: variable 'v2' is possibly undefined

//----- (002B3E60) --------------------------------------------------------
void CWidget::UpdateTiming()
{
  CWidget::SWIPE_DISTANCE = (float)RsGlobal.screenWidth * 0.015;
  CWidget::m_fElapsedTime = OS_TimeAccurate() - CWidget::m_fTime;
  CWidget::m_fTime = OS_TimeAccurate();
}

//----- (002B3EC4) --------------------------------------------------------
void __fastcall CWidget::SetScissor(CRect *rectScissor)
{
  RenderQueue *v1; // r2
  unsigned __int8 *mainWorkPointer; // r3
  RenderQueue *v3; // r2
  RenderQueue *v4; // r2
  RenderQueue *v5; // r2
  float top; // s0
  float bottom; // s2
  RenderQueue *v8; // r0
  RenderQueue *v9; // r4
  __int64 v10; // kr00_8
  unsigned int *p_mainPointer; // r0
  unsigned int v12; // r2

  v1 = renderQueue;
  mainWorkPointer = renderQueue->mainWorkPointer;
  renderQueue->curQueueingCommand = rqTargetScissor;
  *(_DWORD *)mainWorkPointer = 31;
  v1->mainWorkPointer += 4;
  v3 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = (unsigned int)rectScissor->left;
  v3->mainWorkPointer += 4;
  v4 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = (unsigned int)rectScissor->bottom;
  v4->mainWorkPointer += 4;
  v5 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = (unsigned int)fabsf(rectScissor->right - rectScissor->left);
  v5->mainWorkPointer += 4;
  top = rectScissor->top;
  bottom = rectScissor->bottom;
  v8 = renderQueue;
  *(_DWORD *)renderQueue->mainWorkPointer = (unsigned int)fabsf(top - bottom);
  v8->mainWorkPointer += 4;
  v9 = renderQueue;
  if ( renderQueue->useMutex )
    OS_MutexObtain(renderQueue->commandMutex);
  v10 = *(_QWORD *)&v9->mainPointer;
  p_mainPointer = (unsigned int *)&v9->mainPointer;
  __dmb(0xBu);
  do
    v12 = __ldrex(p_mainPointer);
  while ( __strex(v12 + HIDWORD(v10) - v10, p_mainPointer) );
  __dmb(0xBu);
  if ( v9->useMutex )
    OS_MutexRelease(v9->commandMutex);
  if ( !v9->multiThread )
    RenderQueue::Process(v9);
  if ( v9->mainPointer + 1024 > v9->queueEnd )
    sub_1A148C(v9);
}

//----- (002B3FE8) --------------------------------------------------------
void __fastcall CWidget::SetTextureStatic(CSprite2d *Sprite, unsigned __int8 *pszSprite)
{
  TextureDatabaseRuntime *TextureDB; // r6

  TextureDB = CTouchInterface::LoadTextureDB();
  CSprite2d::SetTexture(Sprite, pszSprite);
  sub_198F08(TextureDB);
}

//----- (002B4010) --------------------------------------------------------
void __fastcall CWidget::CreateHoldEffect(
        CWidget *this,
        const unsigned __int8 *pszSprite,
        bool bSquare,
        CRGBA Color,
        bool bExplicitRender)
{
  CHoldEffect *m_pHoldEffect; // r0
  void *v10; // r0
  CHoldEffect *v11; // r0
  CHoldEffect *v12; // r0
  int v13[7]; // [sp+4h] [bp-1Ch] BYREF

  m_pHoldEffect = this->m_pHoldEffect;
  if ( m_pHoldEffect )
  {
    CHoldEffect::~CHoldEffect(m_pHoldEffect);
    operator delete(v10);
    this->m_pHoldEffect = 0;
  }
  v11 = (CHoldEffect *)operator new(0x568u);
  v13[0] = **(_DWORD **)&Color;
  CHoldEffect::CHoldEffect(v11, pszSprite, bSquare, (CRGBA)v13, bExplicitRender);
  this->m_pHoldEffect = v12;
}
// 2B4030: variable 'v10' is possibly undefined
// 2B4052: variable 'v12' is possibly undefined
// 2B4010: using guessed type int var_1C[7];

//----- (002B405E) --------------------------------------------------------
int __fastcall CWidget::IsInsideRect(float a1, float a2, float a3, float a4, float a5, float a6)
{
  int result; // r0

  if ( a1 <= a3 || a1 >= a5 )
    return 0;
  result = 0;
  if ( a2 > a6 && a2 < a4 )
    return 1;
  return result;
}

//----- (002B40AE) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
bool __fastcall CWidget::IsInsideCircle(CVector2D vecTouch, CRect RectBox)
{
  return sqrtf(
           (float)((float)(vecTouch.x - (float)((float)(RectBox.left + RectBox.right) * 0.5))
                 * (float)(vecTouch.x - (float)((float)(RectBox.left + RectBox.right) * 0.5)))
         + (float)((float)(vecTouch.y - (float)((float)(RectBox.top + RectBox.bottom) * 0.5))
                 * (float)(vecTouch.y - (float)((float)(RectBox.top + RectBox.bottom) * 0.5)))) < (float)(fabsf(RectBox.right - RectBox.left) * 0.5);
}
// 2B40AE: fragmented variable at 0:r2.8,8:^0.8 may be wrong
// 2B40AE: variables would overlap: 0:r2.8,8:^0.8 and ^0.4
// 2B40AE: variables would overlap: 0:r2.8,8:^0.8 and ^4.4

//----- (002B4112) --------------------------------------------------------
float __fastcall CWidget::GetWidgetValue(CWidget *this)
{
  return this->m_fUserData;
}

//----- (002B411A) --------------------------------------------------------
bool __fastcall CWidget::IsButton(CWidget *this)
{
  return 0;
}

//----- (002B411E) --------------------------------------------------------
bool __fastcall CWidget::IsHeldDown(CWidget *this)
{
  return 0;
}

//----- (002B4122) --------------------------------------------------------
bool __fastcall CWidget::IsRegion(CWidget *this)
{
  return 0;
}

//----- (002B4126) --------------------------------------------------------
bool __fastcall CWidget::IsSwiped(CWidget *this)
{
  if ( (*((int (__fastcall **)(CWidget *))this->_vptr$CWidget + 17))(this)
    || (*((int (__fastcall **)(CWidget *))this->_vptr$CWidget + 18))(this)
    || (*((int (__fastcall **)(CWidget *))this->_vptr$CWidget + 19))(this) )
  {
    return 1;
  }
  else
  {
    return (*((int (__fastcall **)(CWidget *))this->_vptr$CWidget + 16))(this);
  }
}

//----- (002B4166) --------------------------------------------------------
void __fastcall CWidget::SetWidgetValue(CWidget *this, float fValue)
{
  this->m_fUserData = fValue;
}

//----- (002B4174) --------------------------------------------------------
void __fastcall CWidgetButton::CWidgetButton(
        CWidgetButton *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos,
        unsigned int nButtonFlags,
        unsigned int nExtraFlags,
        HIDMapping Mapping)
{
  CWidget::CWidget(this, pszSprite, WidgetPos, nExtraFlags | 3, Mapping);
  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::CSprite2d(&this->m_SpriteFill);
  this->m_nButtonFlags = nButtonFlags;
  this->m_fPulssateTime = 0.0;
  this->m_fFillLevel = 0.0;
  this->m_fTVTop = 0.0;
  this->m_fTVBottom = 1.0;
}
// 662F00: using guessed type void *off_662F00;

//----- (002B41BC) --------------------------------------------------------
void __fastcall CWidgetButton::Update(CWidgetButton *this)
{
  RwUInt8 v2; // r1
  RwUInt8 v3; // r0

  CWidget::Update(this);
  if ( (*((int (__fastcall **)(CWidgetButton *, _DWORD))this->_vptr$CWidget + 20))(this, 0) == 1 )
  {
    v2 = -1;
    v3 = -1;
    if ( (this->m_nButtonFlags & 1) != 0 )
    {
      v2 = -52;
      v3 = -103;
    }
  }
  else
  {
    v3 = -1;
    v2 = -1;
  }
  this->m_Color._anon_0._anon_0.green = v2;
  this->m_Color._anon_0._anon_0.red = v3;
  this->m_Color._anon_0._anon_0.blue = v3;
  sub_19751C(this);
}

//----- (002B420C) --------------------------------------------------------
void __fastcall CWidgetButton::Draw(CWidgetButton *this)
{
  float m_fTVTop; // s2
  float bottom; // s6
  float right; // r0
  float v5; // s0
  float top; // s4
  float tv2; // s16
  float v8; // s0
  float v9; // s2
  float v10; // r0
  float v11; // s0
  float v12; // s4
  CRGBA v13; // [sp+1Ch] [bp-44h] BYREF
  CRect v14; // [sp+20h] [bp-40h] BYREF
  CRect Rectangle; // [sp+30h] [bp-30h] BYREF

  if ( this->m_Color._anon_0._anon_0.alpha )
  {
    if ( this->m_Sprite.mpTexture )
      CSprite2d::Draw(&this->m_Sprite, &this->m_RectScreen, &this->m_Color);
    if ( this->m_SpriteFill.mpTexture )
    {
      m_fTVTop = this->m_fTVTop;
      bottom = this->m_RectScreen.bottom;
      right = this->m_RectScreen.right;
      v5 = (float)(this->m_fTVBottom - m_fTVTop) * this->m_fFillLevel;
      top = this->m_RectScreen.top;
      Rectangle.left = this->m_RectScreen.left;
      Rectangle.right = right;
      Rectangle.bottom = bottom;
      tv2 = 1.0 - (float)(m_fTVTop + v5);
      Rectangle.top = bottom + (float)(tv2 * fabsf(top - bottom));
      CRGBA::CRGBA((CRGBA *)&v14, 0xFFu, 0xFFu, 0xFFu, this->m_Color._anon_0._anon_0.alpha);
      CSprite2d::Draw(&this->m_SpriteFill, &Rectangle, (const CRGBA *)&v14, 0.0, 0.0, 1.0, 0.0, 0.0, tv2, 1.0, tv2);
      v8 = this->m_RectScreen.top;
      v9 = this->m_RectScreen.bottom;
      v10 = this->m_RectScreen.right;
      v14.left = this->m_RectScreen.left;
      v14.right = v10;
      v14.top = v8;
      v14.bottom = v9 + (float)(tv2 * fabsf(v8 - v9));
      CRGBA::CRGBA(&v13, 0x99u, 0xCCu, 0x99u, this->m_Color._anon_0._anon_0.alpha);
      CSprite2d::Draw(&this->m_SpriteFill, &v14, &v13, 0.0, tv2, 1.0, tv2, 0.0, 1.0, 1.0, 1.0);
    }
    if ( CHID::Implements(this->m_HIDMapping) && ((this->m_nFlags & 0x800) != 0 || CCheat::m_bShowMappings) )
    {
      v11 = this->m_RectScreen.top;
      v12 = fabsf(v11 - this->m_RectScreen.bottom) * 0.375;
      CHID::DrawHelpIcon(
        0,
        this->m_HIDMapping,
        this->m_RectScreen.right - v12,
        v11 - v12,
        v12,
        this->m_Color._anon_0._anon_0.alpha,
        0);
    }
  }
}

//----- (002B4394) --------------------------------------------------------
void __fastcall CWidgetButton::Pulsate(CWidgetButton *this)
{
  float v2; // s0
  float v3; // r0
  float v4; // s0
  float v5; // s0
  float v6; // s2
  float v7; // s0
  float v8; // s4
  float v9; // s2

  v2 = CWidget::m_fElapsedTime + this->m_fPulssateTime;
  v3 = fmodf(v2, 1.5);
  this->m_fPulssateTime = v3;
  if ( v3 > 1.1 && v3 < 1.2 )
  {
    v4 = -1.1;
LABEL_7:
    v5 = (float)((float)(v3 + v4) * 1.45) + 1.0;
    goto LABEL_8;
  }
  v5 = 1.0;
  if ( v3 > 1.3 && v3 < 1.4 )
  {
    v4 = -1.3;
    goto LABEL_7;
  }
LABEL_8:
  v6 = (float)RsGlobal.screenWidth / 640.0;
  v7 = (float)(v5 * this->m_fScaleX) * v6;
  v8 = this->m_fOriginY * (float)((float)RsGlobal.screenHeight / 448.0);
  v9 = this->m_fOriginX * v6;
  this->m_RectScreen.left = v9 - v7;
  this->m_RectScreen.top = v7 + v8;
  this->m_RectScreen.right = v9 + v7;
  this->m_RectScreen.bottom = v8 - v7;
}

//----- (002B44B4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CWidgetButton::SetFillSprite(
        CWidgetButton *this,
        const unsigned __int8 *pszSprite,
        float fTVTop,
        float fTVBottom)
{
  *(_QWORD *)&this->m_fTVTop = *(_QWORD *)&fTVTop;
  sub_18CDC4(this, &this->m_SpriteFill, (unsigned __int8 *)pszSprite, 1);
}
// 2B44B4: variables would overlap: r2.4 and r2.8

//----- (002B44C6) --------------------------------------------------------
void __fastcall CWidgetButton::DrawHelpIcon(
        CWidgetButton *this,
        const unsigned __int8 *pszCharacters,
        float fX,
        float fY,
        float fHeight,
        int nAlpha)
{
  CSprite2d *p_m_Sprite; // r4
  RwTexture_0 *mpTexture; // t1
  CRGBA v14; // [sp+Ch] [bp-44h] BYREF
  CRect Rectangle; // [sp+10h] [bp-40h] BYREF

  if ( CHID::Implements(this->m_HIDMapping) )
  {
    CHID::DrawHelpIcon(pszCharacters, this->m_HIDMapping, fX, fY, fHeight, nAlpha, 0);
  }
  else
  {
    if ( this->m_SpriteFill.mpTexture )
    {
      Rectangle.bottom = fY;
      Rectangle.left = fX;
      Rectangle.right = fX + fHeight;
      Rectangle.top = fY + fHeight;
      CRGBA::CRGBA(&v14, 0xFFu, 0xFFu, 0xFFu, nAlpha);
      CSprite2d::Draw(&this->m_SpriteFill, &Rectangle, &v14);
    }
    mpTexture = this->m_Sprite.mpTexture;
    p_m_Sprite = &this->m_Sprite;
    if ( mpTexture )
    {
      Rectangle.bottom = fY;
      Rectangle.left = fX;
      Rectangle.right = fX + fHeight;
      Rectangle.top = fY + fHeight;
      CRGBA::CRGBA(&v14, 0xFFu, 0xFFu, 0xFFu, nAlpha);
      CSprite2d::Draw(p_m_Sprite, &Rectangle, &v14);
    }
  }
}

//----- (002B4594) --------------------------------------------------------
void __fastcall CWidgetButton::DrawHelpIconExplicit(
        HIDMapping Mapping,
        const unsigned __int8 *pszCharacters,
        float fX,
        float fY,
        float fHeight,
        int nAlpha)
{
  CRGBA v12; // [sp+Ch] [bp-44h] BYREF
  CRect Rectangle; // [sp+10h] [bp-40h] BYREF

  if ( CHID::Implements(Mapping) )
  {
    CHID::DrawHelpIcon(0, Mapping, fX, fY, fHeight, nAlpha, 0);
  }
  else
  {
    CWidget::SetTextureStatic(&CWidgetButton::m_StaticSprite, (unsigned __int8 *)pszCharacters);
    Rectangle.bottom = fY;
    Rectangle.left = fX;
    Rectangle.right = fX + fHeight;
    Rectangle.top = fY + fHeight;
    CRGBA::CRGBA(&v12, 0xFFu, 0xFFu, 0xFFu, nAlpha);
    CSprite2d::Draw(&CWidgetButton::m_StaticSprite, &Rectangle, &v12);
  }
}

//----- (002B4630) --------------------------------------------------------
void __fastcall CWidgetButton::~CWidgetButton(CWidgetButton *this)
{
  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  sub_19C514(this);
}
// 662F00: using guessed type void *off_662F00;

//----- (002B4658) --------------------------------------------------------
void __fastcall CWidgetButton::~CWidgetButton(CWidgetButton *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2B467C: variable 'v2' is possibly undefined
// 662F00: using guessed type void *off_662F00;

//----- (002B4684) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetButton::GetName(CWidgetButton *this)
{
  return (_BYTE *)sub_2B4688;
}
// 2B4688: using guessed type int sub_2B4688();

//----- (002B468C) --------------------------------------------------------
bool __fastcall CWidgetButton::IsButton(CWidgetButton *this)
{
  return 1;
}

//----- (002B4690) --------------------------------------------------------
void __fastcall CWidgetButtonAnimated::CWidgetButtonAnimated(
        CWidgetButtonAnimated *this,
        const unsigned __int8 *pszSprite,
        const unsigned __int8 *pszDepressedSprite,
        const WidgetPosition *WidgetPos,
        unsigned int nButtonFlags,
        unsigned int nExtraFlags,
        HIDMapping Mapping,
        signed int nExtraFlagsa)
{
  CWidgetButtonAnimated *v10; // r2
  CWidgetButtonAnimated **p_m_pNext; // r3
  const char *v12; // r1
  CRGBA v13; // [sp+Ch] [bp-14h] BYREF

  CWidgetButton::CWidgetButton(this, pszSprite, WidgetPos, nButtonFlags, nExtraFlags | 3, (HIDMapping)nExtraFlagsa);
  this->_vptr$CWidget = (int (**)(void))&off_662F94;
  CSprite2d::CSprite2d(&this->m_SpriteDepressed);
  this->m_HIDMappingInitial = this->m_HIDMapping;
  v10 = CWidgetButtonAnimated::m_pChainTail;
  *(_QWORD *)&this->m_pPrev = (unsigned int)CWidgetButtonAnimated::m_pChainTail;
  p_m_pNext = &v10->m_pNext;
  if ( !v10 )
    p_m_pNext = &CWidgetButtonAnimated::m_pChainHead;
  *p_m_pNext = this;
  CWidgetButtonAnimated::m_pChainTail = this;
  this->m_nFlags &= ~1u;
  if ( pszDepressedSprite )
    CWidget::SetTexture(this, &this->m_SpriteDepressed, (unsigned __int8 *)pszDepressedSprite, 1);
  v12 = &byte_61CADE;
  if ( Mapping )
    v12 = (const char *)Mapping;
  strcpy((char *)this->m_szText, v12);
  CRGBA::CRGBA(&v13, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
  this->m_TextColor = v13;
  this->m_fTextPctY = 0.5;
}
// 61CADE: using guessed type char byte_61CADE;
// 662F94: using guessed type void *;

//----- (002B4778) --------------------------------------------------------
void __fastcall CWidgetButtonAnimated::~CWidgetButtonAnimated(CWidgetButtonAnimated *this)
{
  __int64 v2; // kr00_8
  CWidgetButtonAnimated **v3; // r0
  __int64 v4; // r0
  CWidgetButtonAnimated **v5; // r2

  v2 = *(_QWORD *)&this->m_pPrev;
  this->_vptr$CWidget = (int (**)(void))&off_662F94;
  v3 = (CWidgetButtonAnimated **)(v2 + 172);
  if ( !(_DWORD)v2 )
    v3 = &CWidgetButtonAnimated::m_pChainHead;
  *v3 = (CWidgetButtonAnimated *)HIDWORD(v2);
  v4 = *(_QWORD *)&this->m_pPrev;
  v5 = (CWidgetButtonAnimated **)(HIDWORD(v4) + 168);
  if ( !HIDWORD(v4) )
    v5 = &CWidgetButtonAnimated::m_pChainTail;
  *v5 = (CWidgetButtonAnimated *)v4;
  CSprite2d::~CSprite2d(&this->m_SpriteDepressed);
  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  sub_19C514(this);
}
// 662F00: using guessed type void *off_662F00;
// 662F94: using guessed type void *off_662F94;

//----- (002B47EC) --------------------------------------------------------
void __fastcall CWidgetButtonAnimated::~CWidgetButtonAnimated(CWidgetButtonAnimated *this)
{
  __int64 v2; // kr00_8
  CWidgetButtonAnimated **v3; // r0
  __int64 v4; // r0
  CWidgetButtonAnimated **v5; // r2
  void *v6; // r0

  v2 = *(_QWORD *)&this->m_pPrev;
  this->_vptr$CWidget = (int (**)(void))&off_662F94;
  v3 = (CWidgetButtonAnimated **)(v2 + 172);
  if ( !(_DWORD)v2 )
    v3 = &CWidgetButtonAnimated::m_pChainHead;
  *v3 = (CWidgetButtonAnimated *)HIDWORD(v2);
  v4 = *(_QWORD *)&this->m_pPrev;
  v5 = (CWidgetButtonAnimated **)(HIDWORD(v4) + 168);
  if ( !HIDWORD(v4) )
    v5 = &CWidgetButtonAnimated::m_pChainTail;
  *v5 = (CWidgetButtonAnimated *)v4;
  CSprite2d::~CSprite2d(&this->m_SpriteDepressed);
  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  CWidget::~CWidget(this);
  sub_191374(v6);
}
// 2B484E: variable 'v6' is possibly undefined
// 662F00: using guessed type void *off_662F00;
// 662F94: using guessed type void *off_662F94;

//----- (002B4864) --------------------------------------------------------
void __fastcall CWidgetButtonAnimated::Update(CWidgetButtonAnimated *this)
{
  unsigned int m_nButtonFlags; // r0
  bool v3; // zf
  int v4; // r0
  unsigned int v5; // r1
  HIDMapping m_HIDMappingInitial; // r0

  CWidgetButton::Update(this);
  m_nButtonFlags = this->m_nButtonFlags;
  v3 = (m_nButtonFlags & 2) == 0;
  if ( (m_nButtonFlags & 2) != 0 )
    v3 = !this->m_bEnabled;
  if ( !v3 )
  {
    v4 = (*((int (__fastcall **)(CWidgetButtonAnimated *, _DWORD))this->_vptr$CWidget + 13))(this, 0);
    v5 = this->m_nButtonFlags;
    if ( v4 == 1 )
    {
      m_nButtonFlags = v5 | 4;
      if ( (v5 & 4) != 0 )
        m_nButtonFlags = v5 & 0xFFFFFFFB;
      this->m_nButtonFlags = m_nButtonFlags;
    }
    else
    {
      m_nButtonFlags = this->m_nButtonFlags;
    }
  }
  if ( (m_nButtonFlags & 0x10) != 0 )
    m_HIDMappingInitial = HID_MAPPING_UNKNOWN;
  else
    m_HIDMappingInitial = this->m_HIDMappingInitial;
  this->m_HIDMapping = m_HIDMappingInitial;
}

//----- (002B48B8) --------------------------------------------------------
void __fastcall CWidgetButtonAnimated::Draw(CWidgetButtonAnimated *this)
{
  CSprite2d *p_m_SpriteDepressed; // r6
  float left; // s0
  float right; // s4
  float top; // s2
  float bottom; // s6
  float v7; // s10
  float v8; // s8
  float v9; // s0
  float v10; // s2
  float v11; // s4
  float v12; // s6
  CRGBA v13; // r0
  CRGBA v14; // r0
  float v15; // s16
  GxtChar *v16; // r0
  float StringWidth; // r0
  float v18; // s0
  int v19; // r0
  float v20; // s0
  float v21; // s4
  float v22; // s2
  float v23; // s18
  float v24; // s16
  float v25; // s22
  float v26; // s2
  float v27; // s0
  GxtChar *v28; // r0
  CRGBA v29; // [sp+Ch] [bp-4Ch] BYREF
  CRGBA v30; // [sp+10h] [bp-48h] BYREF
  CRGBA v31; // [sp+14h] [bp-44h] BYREF
  CRect Rectangle; // [sp+18h] [bp-40h] BYREF

  if ( this->m_Color._anon_0._anon_0.alpha )
  {
    p_m_SpriteDepressed = &this->m_SpriteDepressed;
    if ( this->m_SpriteDepressed.mpTexture
      && ((*((int (__fastcall **)(CWidgetButtonAnimated *, _DWORD))this->_vptr$CWidget + 20))(this, 0)
       || (this->m_nButtonFlags & 4) != 0)
      || (p_m_SpriteDepressed = &this->m_Sprite, this->m_Sprite.mpTexture)
      && !(*((int (__fastcall **)(CWidgetButtonAnimated *, _DWORD))this->_vptr$CWidget + 20))(this, 0) )
    {
      CSprite2d::Draw(p_m_SpriteDepressed, &this->m_RectScreen, &this->m_Color);
    }
    if ( (this->m_nButtonFlags & 8) != 0 )
    {
      left = this->m_RectScreen.left;
      right = this->m_RectScreen.right;
      top = this->m_RectScreen.top;
      bottom = this->m_RectScreen.bottom;
      v7 = right - left;
      v8 = top - bottom;
      v9 = (float)(left + right) * 0.5;
      v10 = (float)(top + bottom) * 0.5;
      v11 = fabsf(v7) * 0.5;
      v12 = fabsf(v8) * 0.5;
      Rectangle.bottom = v10 - v12;
      Rectangle.left = v9 - v11;
      Rectangle.right = v9 + v11;
      Rectangle.top = v10 + v12;
      CRGBA::CRGBA(&v31, 0, 0xFFu, 0, (unsigned int)(float)((float)this->m_Color._anon_0._anon_0.alpha * 0.3));
      CSprite2d::Draw(&this->m_Sprite, &Rectangle, &v31);
    }
    if ( strlen((const char *)this->m_szText) )
    {
      CFont::SetBackground(0, 0);
      CFont::SetProportional(1u);
      CFont::SetFontStyle(2u);
      CFont::SetOrientation(0);
      CFont::SetEdge(0);
      CRGBA::CRGBA(&v30, 0, 0, 0, this->m_Color._anon_0._anon_0.alpha);
      CFont::SetDropColor(v13);
      CRGBA::CRGBA(
        &v29,
        this->m_TextColor._anon_0._anon_0.red,
        this->m_TextColor._anon_0._anon_0.green,
        this->m_TextColor._anon_0._anon_0.blue,
        (unsigned int)(float)((float)((float)this->m_TextColor._anon_0._anon_0.alpha / 255.0)
                            * (float)this->m_Color._anon_0._anon_0.alpha));
      CFont::SetColor(v14);
      v15 = fabsf(this->m_RectScreen.top - this->m_RectScreen.bottom) * 0.01;
      CFont::SetScale(v15);
      v16 = CText::Get(&TheText, this->m_szText);
      StringWidth = CFont::GetStringWidth(v16, 1u, 0);
      v18 = fabsf(this->m_RectScreen.right - this->m_RectScreen.left) * 0.65;
      if ( StringWidth > v18 )
        CFont::SetScale((float)(v18 / StringWidth) * v15);
      v19 = (*((int (__fastcall **)(CWidgetButtonAnimated *, _DWORD))this->_vptr$CWidget + 20))(this, 0);
      v20 = this->m_RectScreen.left;
      v21 = this->m_RectScreen.right;
      v22 = this->m_RectScreen.top;
      v23 = this->m_RectScreen.bottom;
      v24 = (float)(v20 + v21) * 0.5;
      if ( v19 == 1 )
      {
        v25 = fabsf(v21 - v20) * 0.01;
        v26 = v25 + (float)(v23 + (float)(fabsf(v22 - v23) * this->m_fTextPctY));
        v27 = CFont::GetHeight(0) * -0.5;
        v24 = v24 + v25;
      }
      else
      {
        v26 = v23 + (float)(fabsf(v22 - v23) * this->m_fTextPctY);
        v27 = CFont::GetHeight(0) * -0.5;
      }
      v28 = CText::Get(&TheText, this->m_szText);
      CFont::PrintString(v24, v26 + v27, v28);
    }
    if ( CHID::Implements(this->m_HIDMapping) && ((this->m_nFlags & 0x800) != 0 || CCheat::m_bShowMappings) )
      CHID::DrawHelpIcon(
        0,
        this->m_HIDMapping,
        this->m_RectScreen.right - (float)((float)((float)RsGlobal.screenWidth / 640.0) * 18.0),
        this->m_RectScreen.top - (float)((float)((float)RsGlobal.screenWidth / 640.0) * 18.0),
        (float)((float)RsGlobal.screenWidth / 640.0) * 18.0,
        this->m_Color._anon_0._anon_0.alpha,
        0);
  }
}
// 2B49F0: variable 'v13' is possibly undefined
// 2B4A34: variable 'v14' is possibly undefined

//----- (002B4C00) --------------------------------------------------------
int CWidgetButtonAnimated::AnyObjectEnabled()
{
  CWidgetButtonAnimated *v0; // r4

  v0 = CWidgetButtonAnimated::m_pChainHead;
  if ( !CWidgetButtonAnimated::m_pChainHead )
    return 0;
  while ( !CWidget::GetEnabled(v0) )
  {
    v0 = v0->m_pNext;
    if ( !v0 )
      return 0;
  }
  return 1;
}

//----- (002B4C30) --------------------------------------------------------
void __fastcall CWidgetButtonAnimated::SetWidgetValue2(CWidgetButtonAnimated *this, float fValue0, float fValue1)
{
  CRGBA v5; // [sp+4h] [bp-14h] BYREF

  if ( fValue0 == 1.0 )
  {
    CRGBA::CRGBA(&v5, 0, 0, 0, 0xFFu);
    this->m_TextColor = v5;
  }
  this->m_fTextPctY = fValue1;
}

//----- (002B4C8E) --------------------------------------------------------
void __fastcall CWidgetButtonAnimated::SetWidgetValue(CWidgetButtonAnimated *this, float fValue)
{
  unsigned int m_nButtonFlags; // r2
  unsigned int v4; // r1

  m_nButtonFlags = this->m_nButtonFlags;
  v4 = m_nButtonFlags & 0xFFFFFFFB;
  if ( fValue == 1.0 )
    v4 = m_nButtonFlags | 4;
  this->m_nButtonFlags = v4;
}

//----- (002B4CB4) --------------------------------------------------------
float __fastcall CWidgetButtonAnimated::GetWidgetValue(CWidgetButtonAnimated *this)
{
  float v1; // s0

  v1 = 1.0;
  if ( (this->m_nButtonFlags & 4) == 0 )
    return 0.0;
  return v1;
}

//----- (002B4CD4) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetButtonAnimated::GetName(CWidgetButtonAnimated *this)
{
  return "BTN AN";
}

//----- (002B4CE0) --------------------------------------------------------
void __fastcall CWidgetButtonAnimatedArcade::CWidgetButtonAnimatedArcade(
        CWidgetButtonAnimatedArcade *this,
        const unsigned __int8 *pszSprite,
        const unsigned __int8 *pszDepressedSprite,
        const WidgetPosition *WidgetPos,
        unsigned int nButtonFlags,
        unsigned int nExtraFlags,
        const unsigned __int8 *pszString,
        HIDMapping Mapping)
{
  _DWORD *v8; // r0

  CWidgetButtonAnimated::CWidgetButtonAnimated(
    this,
    pszSprite,
    pszDepressedSprite,
    WidgetPos,
    nButtonFlags,
    nExtraFlags,
    (HIDMapping)pszString,
    Mapping);
  *v8 = &off_663028;
}
// 2B4D02: variable 'v8' is possibly undefined
// 663028: using guessed type void *;

//----- (002B4D0C) --------------------------------------------------------
void __fastcall CWidgetButtonAnimatedArcade::SetWidgetValue(CWidgetButtonAnimatedArcade *this, float fValue)
{
  if ( fValue == 0.0 )
  {
    CWidget::SetTexture(this, &this->m_Sprite, "ArcadeGreenReleased", 1);
    CWidget::SetTexture(this, &this->m_SpriteDepressed, "ArcadeGreenPressed", 1);
  }
  if ( fValue == 1.0 )
  {
    CWidget::SetTexture(this, &this->m_Sprite, "ArcadeYellowReleased", 1);
    CWidget::SetTexture(this, &this->m_SpriteDepressed, "ArcadeYellowPressed", 1);
  }
  if ( fValue == 2.0 )
  {
    CWidget::SetTexture(this, &this->m_Sprite, "ArcadeRedReleased", 1);
    CWidget::SetTexture(this, &this->m_SpriteDepressed, "ArcadeRedPressed", 1);
  }
  if ( fValue == 3.0 )
  {
    CWidget::SetTexture(this, &this->m_Sprite, "ArcadeBlackReleased", 1);
    sub_18CDC4(this, &this->m_SpriteDepressed, "ArcadeBlackPressed", 1);
  }
}

//----- (002B4E64) --------------------------------------------------------
void __fastcall CWidgetButtonAnimatedArcade::~CWidgetButtonAnimatedArcade(CWidgetButtonAnimatedArcade *this)
{
  void *v1; // r0

  CWidgetButtonAnimated::~CWidgetButtonAnimated(this);
  sub_191374(v1);
}
// 2B4E70: variable 'v1' is possibly undefined

//----- (002B4E74) --------------------------------------------------------
void __fastcall CWidgetButtonAttack::CWidgetButtonAttack(
        CWidgetButtonAttack *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  _DWORD *v3; // r0

  CWidgetButton::CWidgetButton(this, pszSprite, WidgetPos, 1u, 0x100u, HID_MAPPING_ATTACK);
  *v3 = &off_6630BC;
}
// 2B4E94: variable 'v3' is possibly undefined
// 6630BC: using guessed type void *off_6630BC;

//----- (002B4EA0) --------------------------------------------------------
void __fastcall CWidgetButtonAttack::Update(CWidgetButtonAttack *this)
{
  CPlayerPed *PlayerPed; // r0
  unsigned __int8 *v3; // r2
  eWeaponType m_eWeaponType; // r1
  const char *v5; // r0
  HIDMapping v6; // r6
  CPlayerPed *v7; // r0

  CWidgetButton::Update(this);
  PlayerPed = FindPlayerPed(-1);
  if ( PlayerPed )
  {
    v3 = (unsigned __int8 *)"shoot";
    m_eWeaponType = PlayerPed->m_WeaponSlots[PlayerPed->m_nCurrentWeapon].m_eWeaponType;
    v5 = "hud_throw";
    switch ( m_eWeaponType )
    {
      case WEAPONTYPE_UNARMED:
        v5 = "punch";
        goto LABEL_28;
      case WEAPONTYPE_BRASSKNUCKLE:
        v5 = "brassknuckle";
        goto LABEL_28;
      case WEAPONTYPE_GOLFCLUB:
        v5 = "hud_golfclub";
        goto LABEL_28;
      case WEAPONTYPE_NIGHTSTICK:
        v5 = "hud_nightstick";
        goto LABEL_28;
      case WEAPONTYPE_KNIFE:
        v5 = "hud_knife";
        goto LABEL_28;
      case WEAPONTYPE_BASEBALLBAT:
        v5 = "hud_bat";
        goto LABEL_28;
      case WEAPONTYPE_SHOVEL:
        v5 = "shovel";
        goto LABEL_28;
      case WEAPONTYPE_POOL_CUE:
        v5 = "hud_poolcue";
        goto LABEL_28;
      case WEAPONTYPE_KATANA:
        v5 = "hud_katana";
        goto LABEL_28;
      case WEAPONTYPE_CHAINSAW:
        v5 = "hud_chainsaw";
        goto LABEL_28;
      case WEAPONTYPE_DILDO1:
        v5 = "hud_dildo1";
        goto LABEL_28;
      case WEAPONTYPE_DILDO2:
        v5 = "hud_dildo1";
        goto LABEL_28;
      case WEAPONTYPE_VIBE1:
        v5 = "hud_dildo2";
        goto LABEL_28;
      case WEAPONTYPE_VIBE2:
        v5 = "hud_dildo2";
        goto LABEL_28;
      case WEAPONTYPE_FLOWERS:
        v5 = "hud_flowers";
        goto LABEL_28;
      case WEAPONTYPE_CANE:
        v5 = "hud_cane";
        goto LABEL_28;
      case WEAPONTYPE_GRENADE:
      case WEAPONTYPE_MOLOTOV:
      case WEAPONTYPE_REMOTE_SATCHEL_CHARGE:
        goto LABEL_28;
      case WEAPONTYPE_TEARGAS:
        v5 = "hud_teargas";
        goto LABEL_28;
      case WEAPONTYPE_FLAMETHROWER:
        v5 = "flamethrower";
        goto LABEL_28;
      case WEAPONTYPE_DETONATOR:
        v5 = "hud_detonator";
        goto LABEL_28;
      case WEAPONTYPE_SPRAYCAN:
        v5 = "hud_spraycan";
        goto LABEL_28;
      case WEAPONTYPE_EXTINGUISHER:
        v5 = "hud_extinguisher";
        goto LABEL_28;
      case WEAPONTYPE_NIGHTVISION:
        v5 = "goggles";
        goto LABEL_28;
      case WEAPONTYPE_INFRARED:
        v5 = "goggles";
        goto LABEL_28;
      case WEAPONTYPE_PARACHUTE:
        v5 = "punch";
LABEL_28:
        v3 = (unsigned __int8 *)v5;
        break;
      default:
        break;
    }
  }
  else
  {
    v3 = (unsigned __int8 *)"shoot";
  }
  v6 = HID_MAPPING_ATTACK;
  CWidget::SetTexture(this, &this->m_Sprite, v3, 1);
  if ( CHID::GetInputType() == 2 )
  {
    v6 = HID_MAPPING_ATTACK;
    if ( FindPlayerPed(-1) )
    {
      v7 = FindPlayerPed(-1);
      if ( CPedIntelligence::GetTaskJetPack(v7->m_pPedIntelligence) )
        v6 = HID_MAPPING_FLIGHT_PRIMARY_ATTACK;
    }
  }
  this->m_HIDMapping = v6;
}

//----- (002B5050) --------------------------------------------------------
char *CWidgetButtonAttack::GetTextureName()
{
  CPlayerPed *PlayerPed; // r1
  char *result; // r0
  unsigned int m_eWeaponType; // r2
  const char *v3; // r1

  PlayerPed = FindPlayerPed(-1);
  if ( !PlayerPed )
    return "shoot";
  result = "shoot";
  m_eWeaponType = PlayerPed->m_WeaponSlots[PlayerPed->m_nCurrentWeapon].m_eWeaponType;
  if ( m_eWeaponType <= 0x2E )
    JUMPOUT(0x2B507C);
  v3 = "hud_throw";
  switch ( m_eWeaponType )
  {
    case 0u:
      v3 = "punch";
      goto LABEL_29;
    case 1u:
      v3 = "brassknuckle";
      goto LABEL_29;
    case 2u:
      v3 = "hud_golfclub";
      goto LABEL_29;
    case 3u:
      v3 = "hud_nightstick";
      goto LABEL_29;
    case 4u:
      v3 = "hud_knife";
      goto LABEL_29;
    case 5u:
      v3 = "hud_bat";
      goto LABEL_29;
    case 6u:
      v3 = "shovel";
      goto LABEL_29;
    case 7u:
      v3 = "hud_poolcue";
      goto LABEL_29;
    case 8u:
      v3 = "hud_katana";
      goto LABEL_29;
    case 9u:
      v3 = "hud_chainsaw";
      goto LABEL_29;
    case 0xAu:
      v3 = "hud_dildo1";
      goto LABEL_29;
    case 0xBu:
      v3 = "hud_dildo1";
      goto LABEL_29;
    case 0xCu:
      v3 = "hud_dildo2";
      goto LABEL_29;
    case 0xDu:
      v3 = "hud_dildo2";
      goto LABEL_29;
    case 0xEu:
      v3 = "hud_flowers";
      goto LABEL_29;
    case 0xFu:
      v3 = "hud_cane";
      goto LABEL_29;
    case 0x10u:
    case 0x12u:
    case 0x27u:
      goto LABEL_29;
    case 0x11u:
      v3 = "hud_teargas";
      goto LABEL_29;
    case 0x13u:
    case 0x14u:
    case 0x15u:
    case 0x16u:
    case 0x17u:
    case 0x18u:
    case 0x19u:
    case 0x1Au:
    case 0x1Bu:
    case 0x1Cu:
    case 0x1Du:
    case 0x1Eu:
    case 0x1Fu:
    case 0x20u:
    case 0x21u:
    case 0x22u:
    case 0x23u:
    case 0x24u:
    case 0x26u:
    case 0x2Bu:
      return result;
    case 0x25u:
      v3 = "flamethrower";
      goto LABEL_29;
    case 0x28u:
      v3 = "hud_detonator";
      goto LABEL_29;
    case 0x29u:
      v3 = "hud_spraycan";
      goto LABEL_29;
    case 0x2Au:
      v3 = "hud_extinguisher";
      goto LABEL_29;
    case 0x2Cu:
      v3 = "goggles";
      goto LABEL_29;
    case 0x2Du:
      v3 = "goggles";
      goto LABEL_29;
    case 0x2Eu:
      v3 = "punch";
LABEL_29:
      result = (char *)v3;
      break;
  }
  return result;
}
// 2B5078: control flows out of bounds to 2B507C

//----- (002B51B8) --------------------------------------------------------
void __fastcall CWidgetButtonAttack::~CWidgetButtonAttack(CWidgetButtonAttack *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2B51DC: variable 'v2' is possibly undefined
// 662F00: using guessed type void *off_662F00;

//----- (002B51E4) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetButtonAttack::GetName(CWidgetButtonAttack *this)
{
  return (_BYTE *)sub_2B51E8;
}
// 2B51E8: using guessed type int sub_2B51E8();

//----- (002B51F0) --------------------------------------------------------
void __fastcall CWidgetButtonBasketballShoot::CWidgetButtonBasketballShoot(
        CWidgetButtonBasketballShoot *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  _DWORD *v3; // r0

  CWidgetButton::CWidgetButton(this, pszSprite, WidgetPos, 1u, 4u, HID_MAPPING_BASKETBALL_SHOOT);
  *v3 = &off_663150;
}
// 2B520E: variable 'v3' is possibly undefined
// 663150: using guessed type void *;

//----- (002B5218) --------------------------------------------------------
void __fastcall CWidgetButtonBasketballShoot::Update(CWidgetButtonBasketballShoot *this)
{
  float v2; // s0
  float v3; // s4
  float v4; // s0
  float v5; // s2
  float v6; // s6
  RwUInt8 v7; // r1
  int v8; // r0
  int v9; // r0
  float v10; // s0

  CWidgetButton::Update(this);
  if ( (*((int (__fastcall **)(CWidgetButtonBasketballShoot *, _DWORD))this->_vptr$CWidget + 20))(this, 0) != 1 )
  {
    v7 = -1;
    CWidgetButtonBasketballShoot::Update(void)::fTimeDown = 0.0;
    LOBYTE(v8) = -1;
    this->m_Color._anon_0._anon_0.red = -1;
    goto LABEL_22;
  }
  CWidgetButtonBasketballShoot::Update(void)::fTimeDown = CWidgetButtonBasketballShoot::Update(void)::fTimeDown
                                                        + (float)(CTimer::ms_fTimeStep / 50.0);
  v2 = (float)((float)((float)(CStats::GetStatValue(0x17u) / 1000.0) + 1.0) * 0.15) + 0.4;
  v3 = v2 - (float)(v2 * 0.15);
  v4 = v2 + (float)(v2 * 0.15);
  v5 = CWidgetButtonBasketballShoot::Update(void)::fTimeDown;
  if ( CWidgetButtonBasketballShoot::Update(void)::fTimeDown >= v3 )
  {
    if ( CWidgetButtonBasketballShoot::Update(void)::fTimeDown <= v4 )
    {
      this->m_Color._anon_0._anon_0.red = 0;
      goto LABEL_15;
    }
    v6 = (float)((float)((float)(CWidgetButtonBasketballShoot::Update(void)::fTimeDown - v4) / v4) * 255.0)
       + (float)((float)((float)(CWidgetButtonBasketballShoot::Update(void)::fTimeDown - v4) / v4) * 255.0);
  }
  else
  {
    v6 = 200.0 - (float)((float)(CWidgetButtonBasketballShoot::Update(void)::fTimeDown / v3) * 200.0);
  }
  v9 = (int)v6;
  if ( (int)v6 < 1 )
  {
    LOBYTE(v9) = 0;
  }
  else if ( v9 >= 255 )
  {
    LOBYTE(v9) = -1;
  }
  this->m_Color._anon_0._anon_0.red = v9;
  if ( v5 < v3 )
  {
    v10 = (float)(v5 / v3) * 200.0;
    goto LABEL_17;
  }
LABEL_15:
  if ( v5 > v4 )
  {
    v10 = (float)((float)((float)((float)(v5 - v4) / v4) * 255.0) * -2.0) + 255.0;
LABEL_17:
    v8 = (int)v10;
    if ( (int)v10 < 1 )
    {
      LOBYTE(v8) = 0;
      v7 = 0;
      goto LABEL_22;
    }
    goto LABEL_20;
  }
  v8 = 255;
LABEL_20:
  v7 = 0;
  if ( v8 >= 255 )
    LOBYTE(v8) = -1;
LABEL_22:
  this->m_Color._anon_0._anon_0.blue = v7;
  this->m_Color._anon_0._anon_0.green = v8;
  sub_19751C(this);
}

//----- (002B538C) --------------------------------------------------------
void __fastcall CWidgetButtonBasketballShoot::~CWidgetButtonBasketballShoot(CWidgetButtonBasketballShoot *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2B53B0: variable 'v2' is possibly undefined
// 662F00: using guessed type void *off_662F00;

//----- (002B53B8) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetButtonBasketballShoot::GetName(CWidgetButtonBasketballShoot *this)
{
  return "Basketball Shoot";
}

//----- (002B53D0) --------------------------------------------------------
void __fastcall CWidgetButtonHelpText::CWidgetButtonHelpText(
        CWidgetButtonHelpText *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  _DWORD *v3; // r0

  CWidgetButton::CWidgetButton(this, pszSprite, WidgetPos, 1u, 4u, HID_MAPPING_UNKNOWN);
  *v3 = &off_6631E4;
}
// 2B53EE: variable 'v3' is possibly undefined
// 6631E4: using guessed type void *;

//----- (002B53F8) --------------------------------------------------------
void __fastcall CWidgetButtonHelpText::~CWidgetButtonHelpText(CWidgetButtonHelpText *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2B541C: variable 'v2' is possibly undefined
// 662F00: using guessed type void *off_662F00;

//----- (002B5424) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetButtonHelpText::GetName(CWidgetButtonHelpText *this)
{
  return (_BYTE *)sub_2B5428;
}
// 2B5428: using guessed type int sub_2B5428();

//----- (002B5434) --------------------------------------------------------
void __fastcall CWidgetButtonHydraulics::CWidgetButtonHydraulics(
        CWidgetButtonHydraulics *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  CWidgetButton::CWidgetButton(this, pszSprite, WidgetPos, 1u, 0, HID_MAPPING_LOCK_HYDRAULICS);
  this->_vptr$CWidget = (int (**)(void))&off_663278;
  CSprite2d::CSprite2d(&this->m_SpriteLock);
  this->vCurrAnchor = 0LL;
  this->vCurrPoint = 0LL;
  this->m_eHydraulicState = 0;
  *(_WORD *)&this->m_bLocked = 0;
  this->fRadians = 3.1416;
  this->fCurRadians = 3.1416;
  CWidget::SetTexture(this, &this->m_SpriteLock, "lock", 1);
}
// 663278: using guessed type void *;

//----- (002B54A8) --------------------------------------------------------
void __fastcall CWidgetButtonHydraulics::Draw(CWidgetButtonHydraulics *this)
{
  float right; // s4
  float bottom; // s6
  float v4; // s0
  float v5; // s2
  CRGBA v6; // [sp+4h] [bp-Ch] BYREF

  if ( this->m_bHasHydraulics )
  {
    CWidgetButton::Draw(this);
    if ( this->m_bLocked )
    {
      right = this->m_RectScreen.right;
      bottom = this->m_RectScreen.bottom;
      v4 = this->m_RectScreen.left + (float)(fabsf(right - this->m_RectScreen.left) * 0.25);
      v5 = this->m_RectScreen.top - (float)(fabsf(this->m_RectScreen.top - bottom) * 0.25);
      this->m_RectScreen.left = v4;
      this->m_RectScreen.top = v5;
      this->m_RectScreen.right = right - (float)(fabsf(right - v4) * 0.25);
      this->m_RectScreen.bottom = bottom + (float)(fabsf(v5 - bottom) * 0.25);
      CRGBA::CRGBA(&v6, 0xFFu, 0xFFu, 0xFFu, this->m_Color._anon_0._anon_0.alpha);
      CSprite2d::Draw(&this->m_SpriteLock, &this->m_RectScreen, &v6);
    }
  }
}

//----- (002B5550) --------------------------------------------------------
void __fastcall CWidgetButtonHydraulics::Update(CWidgetButtonHydraulics *this)
{
  CVehicle *PlayerVehicle; // r0
  CPad *Pad; // r0
  _BOOL4 m_bLocked; // r0
  int v5; // r0
  bool v6; // zf
  int m_nTouchIndex; // r1
  float v8; // s2
  float y; // r0
  float v10; // r0
  float v11; // s0
  int v12; // r0
  CVector2D v13; // [sp+0h] [bp-20h] BYREF
  CVector2D v14; // [sp+8h] [bp-18h] BYREF

  CWidgetButton::Update(this);
  this->m_bHasHydraulics = 1;
  PlayerVehicle = FindPlayerVehicle(-1, 0);
  if ( !PlayerVehicle )
  {
    this->m_eHydraulicState = 0;
    *(_WORD *)&this->m_bLocked = 0;
    return;
  }
  if ( (PlayerVehicle->hFlagsLocal & 0x20000) == 0 )
  {
    this->m_eHydraulicState = 0;
    *(_WORD *)&this->m_bLocked = 0;
    return;
  }
  Pad = CPad::GetPad(0);
  if ( CPad::GetExitVehicle(Pad) )
  {
    this->m_eHydraulicState = 0;
    *(_WORD *)&this->m_bLocked = 0;
  }
  if ( (*((int (__fastcall **)(CWidgetButtonHydraulics *, _DWORD))this->_vptr$CWidget + 13))(this, 0) == 1
    && (CHID::GetInputType() || CWidget::GetNumTapsInTime(this, 0.42) >= 1) )
  {
    m_bLocked = this->m_bLocked;
    this->m_bLocked = !m_bLocked;
    if ( m_bLocked )
      this->m_eHydraulicState = 0;
LABEL_12:
    bMovementDetected = 0;
    bAnchorSet = 0;
    nLastTouch = -1;
    return;
  }
  v5 = (*((int (__fastcall **)(CWidgetButtonHydraulics *, _DWORD))this->_vptr$CWidget + 20))(this, 0);
  v6 = v5 == 0;
  m_nTouchIndex = nLastTouch;
  if ( !v5 )
    v6 = nLastTouch == -1;
  if ( !v6 )
  {
    if ( !bAnchorSet )
    {
      m_nTouchIndex = this->m_nTouchIndex;
      nLastTouch = m_nTouchIndex;
      v8 = (float)(this->m_RectScreen.top + this->m_RectScreen.bottom) * 0.5;
      this->vCurrAnchor.x = (float)(this->m_RectScreen.left + this->m_RectScreen.right) * 0.5;
      this->vCurrAnchor.y = v8;
      bAnchorSet = 1;
    }
    CTouchInterface::GetTouchDelta(&v14, m_nTouchIndex);
    if ( fabsf(v14.x) > 2.5 || (CTouchInterface::GetTouchDelta(&v13, nLastTouch), fabsf(v13.y) > 2.5) )
      bMovementDetected = 1;
    if ( (*((int (__fastcall **)(CWidgetButtonHydraulics *, _DWORD))this->_vptr$CWidget + 20))(this, 0) != 1
      || bMovementDetected == 1 )
    {
      CTouchInterface::GetTouchPosition(&v14, nLastTouch);
      this->vCurrPoint.x = v14.x;
      CTouchInterface::GetTouchPosition(&v14, nLastTouch);
      y = v14.y;
      this->vCurrPoint.y = v14.y;
      v10 = atan2f(-(float)(this->vCurrPoint.x - this->vCurrAnchor.x), y - this->vCurrAnchor.y);
      this->fRadians = v10;
      v11 = (float)(v10 * 180.0) / 3.1416;
      if ( CWidgetButtonHydraulics::Update(void)::fOldAngle == v11 )
      {
        CWidgetButtonHydraulics::Update(void)::fSameAngleTimer = CWidgetButtonHydraulics::Update(void)::fSameAngleTimer
                                                               + (float)(CTimer::ms_fTimeStep / 50.0);
        if ( CWidgetButtonHydraulics::Update(void)::fSameAngleTimer > 2.0 )
          this->m_bLocked = 1;
      }
      else
      {
        CWidgetButtonHydraulics::Update(void)::fSameAngleTimer = 0.0;
        CWidgetButtonHydraulics::Update(void)::fOldAngle = (float)(v10 * 180.0) / 3.1416;
      }
      if ( v11 < 22.5 && v11 > -22.5 )
      {
        v12 = 2;
LABEL_50:
        this->m_eHydraulicState = v12;
        goto LABEL_51;
      }
      if ( v11 > 22.5 && v11 < 67.5 )
      {
        v12 = 7;
        goto LABEL_50;
      }
      if ( v11 > 67.5 && v11 < 112.5 )
      {
        v12 = 3;
        goto LABEL_50;
      }
      if ( v11 > 112.5 && v11 < 157.5 )
      {
        v12 = 5;
        goto LABEL_50;
      }
      v12 = 1;
      if ( v11 > 157.5 || v11 < -157.5 )
        goto LABEL_50;
      if ( v11 > -157.5 && v11 < -112.5 )
      {
        v12 = 6;
        goto LABEL_50;
      }
      if ( v11 > -112.5 && v11 < -67.5 )
      {
        v12 = 4;
        goto LABEL_50;
      }
      if ( v11 > -67.5 && v11 < -22.5 )
      {
        v12 = 8;
        goto LABEL_50;
      }
    }
LABEL_51:
    if ( !(*((int (__fastcall **)(CWidgetButtonHydraulics *, _DWORD))this->_vptr$CWidget + 20))(this, 0)
      && !CTouchInterface::IsTouchDown(nLastTouch) )
    {
      if ( !this->m_bLocked )
        this->m_eHydraulicState = 0;
      goto LABEL_12;
    }
  }
}
// 6FA2FC: using guessed type char bAnchorSet;
// 6FA2FD: using guessed type char bMovementDetected;

//----- (002B5928) --------------------------------------------------------
void __fastcall CWidgetButtonHydraulics::~CWidgetButtonHydraulics(CWidgetButtonHydraulics *this)
{
  this->_vptr$CWidget = (int (**)(void))&off_663278;
  CSprite2d::~CSprite2d(&this->m_SpriteLock);
  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  sub_19C514(this);
}
// 662F00: using guessed type void *off_662F00;
// 663278: using guessed type void *off_663278;

//----- (002B5968) --------------------------------------------------------
void __fastcall CWidgetButtonHydraulics::~CWidgetButtonHydraulics(CWidgetButtonHydraulics *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_663278;
  CSprite2d::~CSprite2d(&this->m_SpriteLock);
  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2B59A0: variable 'v2' is possibly undefined
// 662F00: using guessed type void *off_662F00;
// 663278: using guessed type void *off_663278;

//----- (002B59AC) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetButtonHydraulics::GetName(CWidgetButtonHydraulics *this)
{
  return "Hydraulics";
}

//----- (002B59BC) --------------------------------------------------------
void __fastcall CWidgetButtonMissionStart::CWidgetButtonMissionStart(
        CWidgetButtonMissionStart *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos,
        HIDMapping Mapping)
{
  _DWORD *v4; // r0

  CWidgetButton::CWidgetButton(this, pszSprite, WidgetPos, 1u, 0xC80u, Mapping);
  *v4 = &off_66330C;
}
// 2B59D8: variable 'v4' is possibly undefined
// 66330C: using guessed type void *;

//----- (002B59E4) --------------------------------------------------------
void __fastcall CWidgetButtonMissionStart::Update(CWidgetButtonMissionStart *this)
{
  if ( CTouchInterface::m_pWidgets[25] && CWidget::GetEnabled(CTouchInterface::m_pWidgets[25]) )
    CWidget::SetEnabled(this, 0);
  if ( CTouchInterface::m_pWidgets[66] && CWidget::GetEnabled(CTouchInterface::m_pWidgets[66]) )
    CWidget::SetEnabled(this, 0);
  sub_192FB4(this);
}

//----- (002B5A34) --------------------------------------------------------
void __fastcall CWidgetButtonMissionStart::~CWidgetButtonMissionStart(CWidgetButtonMissionStart *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2B5A58: variable 'v2' is possibly undefined
// 662F00: using guessed type void *off_662F00;

//----- (002B5A60) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetButtonMissionStart::GetName(CWidgetButtonMissionStart *this)
{
  return "BT Start";
}

//----- (002B5A70) --------------------------------------------------------
void __fastcall CWidgetButtonRocket::CWidgetButtonRocket(
        CWidgetButtonRocket *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  _DWORD *v3; // r0

  CWidgetButton::CWidgetButton(this, pszSprite, WidgetPos, 1u, 0, HID_MAPPING_FLIGHT_SECONDARY_ATTACK);
  *v3 = &off_6633A0;
}
// 2B5A8E: variable 'v3' is possibly undefined
// 6633A0: using guessed type void *off_6633A0;

//----- (002B5A9C) --------------------------------------------------------
void __fastcall CWidgetButtonRocket::~CWidgetButtonRocket(CWidgetButtonRocket *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2B5AC0: variable 'v2' is possibly undefined
// 662F00: using guessed type void *off_662F00;

//----- (002B5AC8) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetButtonRocket::GetName(CWidgetButtonRocket *this)
{
  return (_BYTE *)sub_2B5ACC;
}

//----- (002B5ACC) --------------------------------------------------------
void __fastcall sub_2B5ACC(
        CWidgetButtonSchool *a1,
        const unsigned __int8 *a2,
        const WidgetPosition *a3,
        int a4,
        int a5,
        HIDMapping a6)
{
  CWidgetButtonSchool::CWidgetButtonSchool(a1, a2, a3, loc_2B5C18, a5, a6);
}

//----- (002B5AD0) --------------------------------------------------------
void __fastcall CWidgetButtonSchool::CWidgetButtonSchool(
        CWidgetButtonSchool *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos,
        const unsigned __int8 *pszString,
        int nFlags,
        HIDMapping Mapping)
{
  const char *v8; // r1
  unsigned int v9; // r0

  CWidgetButton::CWidgetButton(this, pszSprite, WidgetPos, 1u, nFlags, Mapping);
  v8 = &byte_61CADE;
  this->_vptr$CWidget = (int (**)(void))&off_663434;
  if ( pszString )
    v8 = (const char *)pszString;
  strcpy((char *)this->m_szText, v8);
  v9 = this->m_nFlags & 0xFFFFFFFE;
  this->m_fFadeRate = 2560.0;
  this->m_nFlags = v9;
}
// 61CADE: using guessed type char byte_61CADE;
// 663434: using guessed type void *off_663434;

//----- (002B5B30) --------------------------------------------------------
void __fastcall CWidgetButtonSchool::Draw(CWidgetButtonSchool *this)
{
  CRGBA v2; // r0
  CRGBA v3; // r0
  float v4; // s16
  GxtChar *v5; // r0
  float StringWidth; // r0
  float left; // s18
  float right; // s20
  float v9; // s0
  float v10; // s22
  float v11; // s0
  GxtChar *v12; // r0
  CRGBA v13; // [sp+4h] [bp-34h] BYREF
  CRGBA v14; // [sp+8h] [bp-30h] BYREF
  CRGBA v15; // [sp+Ch] [bp-2Ch] BYREF

  CWidgetButton::Draw(this);
  if ( this->m_Color._anon_0._anon_0.alpha && strlen((const char *)this->m_szText) )
  {
    CFont::SetBackground(0, 0);
    CFont::SetProportional(1u);
    CFont::SetFontStyle(2u);
    CFont::SetOrientation(0);
    CFont::SetEdge(0);
    CRGBA::CRGBA(&v15, 0, 0, 0, this->m_Color._anon_0._anon_0.alpha);
    CFont::SetDropColor(v2);
    if ( (*((int (__fastcall **)(CWidgetButtonSchool *, _DWORD))this->_vptr$CWidget + 20))(this, 0) == 1 )
      CRGBA::CRGBA(&v14, 0xFFu, 0, 0, this->m_Color._anon_0._anon_0.alpha);
    else
      CRGBA::CRGBA(&v13, 0xFFu, 0xFFu, 0xFFu, this->m_Color._anon_0._anon_0.alpha);
    CFont::SetColor(v3);
    v4 = fabsf(this->m_RectScreen.top - this->m_RectScreen.bottom) * 0.01;
    CFont::SetScale(v4);
    v5 = CText::Get(&TheText, this->m_szText);
    StringWidth = CFont::GetStringWidth(v5, 1u, 0);
    left = this->m_RectScreen.left;
    right = this->m_RectScreen.right;
    v9 = fabsf(right - left) * 0.65;
    if ( StringWidth > v9 )
    {
      CFont::SetScale((float)(v9 / StringWidth) * v4);
      left = this->m_RectScreen.left;
      right = this->m_RectScreen.right;
    }
    v10 = this->m_RectScreen.top + this->m_RectScreen.bottom;
    v11 = CFont::GetHeight(0) * 0.5;
    v12 = CText::Get(&TheText, this->m_szText);
    CFont::PrintString((float)(left + right) * 0.5, (float)(v10 * 0.5) - v11, v12);
  }
}
// 2B5B8C: variable 'v2' is possibly undefined
// 2B5BBC: variable 'v3' is possibly undefined

//----- (002B5CA4) --------------------------------------------------------
void __fastcall CWidgetButtonSchool::~CWidgetButtonSchool(CWidgetButtonSchool *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2B5CC8: variable 'v2' is possibly undefined
// 662F00: using guessed type void *off_662F00;

//----- (002B5CD0) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetButtonSchool::GetName(CWidgetButtonSchool *this)
{
  return "BTN SCHOOL";
}

//----- (002B5CE0) --------------------------------------------------------
void __fastcall CWidgetButtonSkipCutscene::CWidgetButtonSkipCutscene(
        CWidgetButtonSkipCutscene *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  _DWORD *v3; // r0

  CWidgetButton::CWidgetButton(this, pszSprite, WidgetPos, 1u, 0x2004u, HID_MAPPING_SKIP_CUTSCENE);
  *v3 = &off_6634C8;
}
// 2B5D00: variable 'v3' is possibly undefined
// 6634C8: using guessed type void *;

//----- (002B5D0C) --------------------------------------------------------
void __fastcall CWidgetButtonSkipCutscene::Update(CWidgetButtonSkipCutscene *this)
{
  int InputType; // r0
  unsigned int m_nFlags; // r1
  unsigned int v4; // r2

  InputType = CHID::GetInputType();
  m_nFlags = this->m_nFlags;
  v4 = m_nFlags | 0x800;
  if ( InputType == 2 )
    v4 = m_nFlags & 0xFFFFF7FF;
  this->m_nFlags = v4;
  sub_192FB4(this);
}

//----- (002B5D34) --------------------------------------------------------
void __fastcall CWidgetButtonSkipCutscene::~CWidgetButtonSkipCutscene(CWidgetButtonSkipCutscene *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2B5D58: variable 'v2' is possibly undefined
// 662F00: using guessed type void *off_662F00;

//----- (002B5D60) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetButtonSkipCutscene::GetName(CWidgetButtonSkipCutscene *this)
{
  return (_BYTE *)sub_2B5D64;
}
// 2B5D64: using guessed type int sub_2B5D64();

//----- (002B5D70) --------------------------------------------------------
void __fastcall CWidgetButtonSwapWeapons::CWidgetButtonSwapWeapons(
        CWidgetButtonSwapWeapons *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  _DWORD *v3; // r0

  CWidgetButton::CWidgetButton(this, pszSprite, WidgetPos, 1u, 0xC00u, HID_MAPPING_SWAP_WEAPONS_AND_PURCHASE);
  *v3 = &off_66355C;
}
// 2B5D90: variable 'v3' is possibly undefined
// 66355C: using guessed type void *;

//----- (002B5D9C) --------------------------------------------------------
void __fastcall CWidgetButtonSwapWeapons::Update(CWidgetButtonSwapWeapons *this)
{
  CTouchInterface::WidgetPositionIDs v2; // r0
  float v3; // r0
  float v4; // r1
  float fScaleY; // [sp+8h] [bp-18h] BYREF
  float fScaleX; // [sp+Ch] [bp-14h] BYREF
  float fOriginY; // [sp+10h] [bp-10h] BYREF
  unsigned int fOriginX[3]; // [sp+14h] [bp-Ch] BYREF

  fOriginY = 0.0;
  fOriginX[0] = 0;
  fScaleY = 0.0;
  fScaleX = 0.0;
  if ( CGameLogic::IsCoopGameGoingOn() == 1 )
    v2 = WIDGET_POSITION_TARGETING_AND_ATTACK;
  else
    v2 = WIDGET_POSITION_SWAP_WEAPONS;
  CTouchInterface::GetWidgetPosition(v2, (float *)fOriginX, &fOriginY, &fScaleX, &fScaleY);
  v3 = fScaleY;
  v4 = fScaleX;
  *(_QWORD *)&this->m_fOriginX = __PAIR64__(LODWORD(fOriginY), fOriginX[0]);
  this->m_fScaleX = v4;
  this->m_fScaleY = v3;
  CWidgetButton::Update(this);
}
// 2B5D9C: using guessed type unsigned int fOriginX[3];

//----- (002B5DE0) --------------------------------------------------------
void __fastcall CWidgetButtonSwapWeapons::~CWidgetButtonSwapWeapons(CWidgetButtonSwapWeapons *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2B5E04: variable 'v2' is possibly undefined
// 662F00: using guessed type void *off_662F00;

//----- (002B5E0C) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetButtonSwapWeapons::GetName(CWidgetButtonSwapWeapons *this)
{
  return "BTN SW";
}

//----- (002B5E18) --------------------------------------------------------
void __fastcall CWidgetButtonTargeting::CWidgetButtonTargeting(
        CWidgetButtonTargeting *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  _DWORD *v3; // r0

  CWidgetButton::CWidgetButton(this, pszSprite, WidgetPos, 1u, 0, HID_MAPPING_ENTER_AND_EXIT_TARGETING);
  *v3 = &off_6635F0;
}
// 2B5E36: variable 'v3' is possibly undefined
// 6635F0: using guessed type void *off_6635F0;

//----- (002B5E44) --------------------------------------------------------
void __fastcall CWidgetButtonTargeting::~CWidgetButtonTargeting(CWidgetButtonTargeting *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2B5E68: variable 'v2' is possibly undefined
// 662F00: using guessed type void *off_662F00;

//----- (002B5E70) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetButtonTargeting::GetName(CWidgetButtonTargeting *this)
{
  return (_BYTE *)&nullsub_1;
}

//----- (002B5E78) --------------------------------------------------------
void __fastcall CWidgetButtonVehicleShoot::CWidgetButtonVehicleShoot(
        CWidgetButtonVehicleShoot *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos,
        HIDMapping Mapping)
{
  _DWORD *v4; // r0

  CWidgetButton::CWidgetButton(this, pszSprite, WidgetPos, 1u, 0, Mapping);
  *v4 = &off_663684;
}
// 2B5E94: variable 'v4' is possibly undefined
// 663684: using guessed type void *;

//----- (002B5EA0) --------------------------------------------------------
void __fastcall CWidgetButtonVehicleShoot::Update(CWidgetButtonVehicleShoot *this)
{
  HIDMapping m_HIDMapping; // r0
  CTouchInterface::WidgetPositionIDs v3; // r0
  float v4; // r0
  float v5; // r1
  float fScaleY; // [sp+8h] [bp-18h] BYREF
  float fScaleX; // [sp+Ch] [bp-14h] BYREF
  float fOriginY; // [sp+10h] [bp-10h] BYREF
  unsigned int fOriginX[3]; // [sp+14h] [bp-Ch] BYREF

  CWidgetButton::Update(this);
  fOriginX[0] = 0;
  fScaleX = 0.0;
  fOriginY = 0.0;
  fScaleY = 0.0;
  m_HIDMapping = this->m_HIDMapping;
  if ( m_HIDMapping == HID_MAPPING_VEHICLE_LOOK_RIGHT )
  {
    v3 = WIDGET_POSITION_VEHICLE_SHOOT_RIGHT;
    if ( MobileSettings::settings[3].value != 1 )
      v3 = WIDGET_POSITION_VEHICLE_STEER_RIGHT;
    goto LABEL_8;
  }
  if ( m_HIDMapping == HID_MAPPING_VEHICLE_LOOK_LEFT )
  {
    v3 = WIDGET_POSITION_VEHICLE_SHOOT_LEFT;
    if ( MobileSettings::settings[3].value != 1 )
      v3 = WIDGET_POSITION_VEHICLE_STEER_LEFT;
LABEL_8:
    CTouchInterface::GetWidgetPosition(v3, (float *)fOriginX, &fOriginY, &fScaleX, &fScaleY);
  }
  v4 = fScaleY;
  v5 = fScaleX;
  *(_QWORD *)&this->m_fOriginX = __PAIR64__(LODWORD(fOriginY), fOriginX[0]);
  this->m_fScaleX = v5;
  this->m_fScaleY = v4;
}
// 2B5EA0: using guessed type unsigned int fOriginX[3];

//----- (002B5F04) --------------------------------------------------------
void __fastcall CWidgetButtonVehicleShoot::UpdatePosition(CWidgetButtonVehicleShoot *this)
{
  HIDMapping m_HIDMapping; // r0
  CTouchInterface::WidgetPositionIDs v3; // r0
  float v4; // r0
  float v5; // r1
  float fScaleY; // [sp+8h] [bp-18h] BYREF
  float fScaleX; // [sp+Ch] [bp-14h] BYREF
  float fOriginY; // [sp+10h] [bp-10h] BYREF
  unsigned int fOriginX[3]; // [sp+14h] [bp-Ch] BYREF

  fOriginY = 0.0;
  fOriginX[0] = 0;
  fScaleY = 0.0;
  fScaleX = 0.0;
  m_HIDMapping = this->m_HIDMapping;
  if ( m_HIDMapping == HID_MAPPING_VEHICLE_LOOK_RIGHT )
  {
    v3 = WIDGET_POSITION_VEHICLE_SHOOT_RIGHT;
    if ( MobileSettings::settings[3].value != 1 )
      v3 = WIDGET_POSITION_VEHICLE_STEER_RIGHT;
    goto LABEL_8;
  }
  if ( m_HIDMapping == HID_MAPPING_VEHICLE_LOOK_LEFT )
  {
    v3 = WIDGET_POSITION_VEHICLE_SHOOT_LEFT;
    if ( MobileSettings::settings[3].value != 1 )
      v3 = WIDGET_POSITION_VEHICLE_STEER_LEFT;
LABEL_8:
    CTouchInterface::GetWidgetPosition(v3, (float *)fOriginX, &fOriginY, &fScaleX, &fScaleY);
  }
  v4 = fScaleY;
  v5 = fScaleX;
  *(_QWORD *)&this->m_fOriginX = __PAIR64__(LODWORD(fOriginY), fOriginX[0]);
  this->m_fScaleX = v5;
  this->m_fScaleY = v4;
}
// 2B5F04: using guessed type unsigned int fOriginX[3];

//----- (002B5F64) --------------------------------------------------------
bool __fastcall CWidgetButtonVehicleShoot::IsTouched(CWidgetButtonVehicleShoot *this, CVector2D *pVecOut)
{
  if ( CHID::Implements(this->m_HIDMapping) )
    return sub_196BD4(this->m_HIDMapping, 0);
  else
    return sub_18EC48(this, pVecOut);
}

//----- (002B5F8E) --------------------------------------------------------
bool __fastcall CWidgetButtonVehicleShoot::IsHeldDown(CWidgetButtonVehicleShoot *this)
{
  if ( !CHID::Implements(this->m_HIDMapping) || !CHID::Implements(HID_MAPPING_ATTACK) )
    return sub_18EC48(this, 0);
  if ( CHID::IsPressed(this->m_HIDMapping, 0) )
    return sub_196BD4(HID_MAPPING_ATTACK, 0);
  return 0;
}

//----- (002B5FD0) --------------------------------------------------------
void __fastcall CWidgetButtonVehicleShoot::~CWidgetButtonVehicleShoot(CWidgetButtonVehicleShoot *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2B5FF4: variable 'v2' is possibly undefined
// 662F00: using guessed type void *off_662F00;

//----- (002B5FFC) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetButtonVehicleShoot::GetName(CWidgetButtonVehicleShoot *this)
{
  return "BTN VEH SHOOT";
}

//----- (002B6010) --------------------------------------------------------
void __fastcall CWidgetButtonDrop::CWidgetButtonDrop(
        CWidgetButtonDrop *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos,
        HIDMapping Mapping)
{
  _DWORD *v4; // r0

  CWidgetButton::CWidgetButton(this, pszSprite, WidgetPos, 1u, 0xC00u, Mapping);
  *v4 = &off_663718;
}
// 2B602C: variable 'v4' is possibly undefined
// 663718: using guessed type void *off_663718;

//----- (002B6038) --------------------------------------------------------
void __fastcall CWidgetButtonDrop::~CWidgetButtonDrop(CWidgetButtonDrop *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2B605C: variable 'v2' is possibly undefined
// 662F00: using guessed type void *off_662F00;

//----- (002B6064) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetButtonDrop::GetName(CWidgetButtonDrop *this)
{
  return "BTN DROP";
}

//----- (002B6080) --------------------------------------------------------
void __fastcall CWidgetButtonEnterCar::CWidgetButtonEnterCar(
        CWidgetButtonEnterCar *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  float v4[7]; // [sp+Ch] [bp-1Ch] BYREF

  CWidgetButton::CWidgetButton(this, pszSprite, WidgetPos, 1u, 0, HID_MAPPING_ENTER_CAR);
  *(_QWORD *)&this->m_RectDot.left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_RectDot.right = 0x49742400C9742400LL;
  this->_vptr$CWidget = (int (**)(void))&off_6637AC;
  CSprite2d::CSprite2d(&this->m_SpriteIndicator);
  *(_QWORD *)&this->m_fRadians = 0LL;
  *(_QWORD *)&this->m_RectDot.top = 0LL;
  this->m_RectDot.bottom = 0.0;
  CWidget::SetTexture(this, &this->m_SpriteIndicator, "hud_arrow", 1);
  memset(v4, 0, 12);
  CWidgetButtonEnterCar::SetEnterCarVehicleType(this, 0, 0, 0, v4, -1);
}
// 6637AC: using guessed type void *;

//----- (002B6120) --------------------------------------------------------
void __fastcall CWidgetButtonEnterCar::SetEnterCarVehicleType(
        CWidgetButtonEnterCar *this,
        int nVehicleType,
        int hFlagsLocal,
        int bEntering,
        float *a5,
        int a6)
{
  CRect *p_m_RectDot; // r8
  CSprite2d *p_m_Sprite; // r1
  char *v12; // r2
  TextureDatabaseRuntime *v13; // r6
  CPlayerPed *v14; // r0
  CSprite2d *v15; // r1
  char *v16; // r2
  CSprite2d *v17; // r1
  char *v18; // r2
  CSprite2d *v19; // r1
  char *v20; // r2
  __int64 v21; // r0
  CPlayerPed *PlayerPed; // r0
  CMatrix *m_pMat; // r1
  float *p_tx; // r3
  float v25; // s20
  float v26; // s18
  float v27; // s16
  float xy; // s4
  float yy; // s0
  float v30; // s10
  float zy; // s2
  float v32; // s6
  float m_heading; // r4
  float v34; // r5
  float v35; // r0
  float v36; // r4
  float v37; // r0
  float left; // s0
  float v39; // s26
  float right; // s4
  float top; // s2
  float bottom; // s6
  float v43; // s24
  float v44; // s16
  float v45; // s22
  float v46; // r0
  float v47; // s2
  float v48; // s0
  TextureDatabaseRuntime *pMobileDB; // [sp+4h] [bp-54h]

  p_m_RectDot = &this->m_RectDot;
  pMobileDB = CTouchInterface::LoadTextureDB();
  *(_QWORD *)&p_m_RectDot->left = 0LL;
  *(_QWORD *)&p_m_RectDot->right = 0LL;
  if ( bEntering == 1 )
  {
    if ( a6 == 539 )
    {
      p_m_Sprite = &this->m_Sprite;
      v12 = "hud_boat";
LABEL_4:
      CWidget::SetTexture(this, p_m_Sprite, (unsigned __int8 *)v12, 1);
      v13 = pMobileDB;
      if ( !nVehicleType && (hFlagsLocal & 0x20000) != 0 )
        CWidget::SetTexture(this, &this->m_Sprite, "hydraulicCar", 1);
    }
    else
    {
      switch ( nVehicleType )
      {
        case 0:
          p_m_Sprite = &this->m_Sprite;
          v12 = "hud_car";
          goto LABEL_4;
        case 1:
          v17 = &this->m_Sprite;
          v18 = "hud_monstertruck";
          break;
        case 2:
        case 9:
          v17 = &this->m_Sprite;
          v18 = "hud_bike";
          break;
        case 3:
          v17 = &this->m_Sprite;
          v18 = "hud_chopper";
          break;
        case 4:
        case 8:
          v17 = &this->m_Sprite;
          v18 = "hud_plane";
          break;
        case 5:
          v17 = &this->m_Sprite;
          v18 = "hud_boat";
          break;
        case 6:
          v17 = &this->m_Sprite;
          v18 = "hud_train";
          break;
        case 10:
          v17 = &this->m_Sprite;
          v18 = "hud_bicycle";
          break;
        case 11:
          v17 = &this->m_Sprite;
          v18 = "hud_trailer";
          break;
        default:
          v17 = &this->m_Sprite;
          v18 = "hud_car";
          break;
      }
      CWidget::SetTexture(this, v17, (unsigned __int8 *)v18, 1);
      v13 = pMobileDB;
    }
    v21 = 0LL;
    if ( a5[1] != 0.0 )
      HIDWORD(v21) = 1;
    if ( *a5 != 0.0 )
      LODWORD(v21) = 1;
    if ( v21 )
    {
      PlayerPed = FindPlayerPed(-1);
      if ( PlayerPed )
      {
        m_pMat = PlayerPed->m_pMat;
        p_tx = &m_pMat->tx;
        if ( !m_pMat )
          p_tx = &PlayerPed->m_transform.m_translate.x;
        v25 = *p_tx - *a5;
        v26 = p_tx[1] - a5[1];
        v27 = p_tx[2] - a5[2];
        if ( TheCamera.m_pMat )
        {
          xy = TheCamera.m_pMat->xy;
          yy = TheCamera.m_pMat->yy;
          v30 = v27 * TheCamera.m_pMat->zx;
          zy = TheCamera.m_pMat->zy;
          v32 = (float)(v25 * TheCamera.m_pMat->xx) + (float)(v26 * TheCamera.m_pMat->yx);
        }
        else
        {
          m_heading = TheCamera.m_transform.m_heading;
          v34 = cosf(TheCamera.m_transform.m_heading);
          v35 = sinf(m_heading);
          zy = 0.0;
          yy = v34;
          v30 = v27 * 0.0;
          xy = -v35;
          v32 = (float)(v25 * v34) + (float)(v26 * v35);
        }
        v36 = atan2f((float)((float)(v25 * xy) + (float)(v26 * yy)) + (float)(v27 * zy), v32 + v30);
        v37 = cosf(v36);
        left = this->m_RectScreen.left;
        v39 = v37;
        right = this->m_RectScreen.right;
        top = this->m_RectScreen.top;
        bottom = this->m_RectScreen.bottom;
        v43 = top + bottom;
        v44 = fabsf(right - left);
        v45 = fabsf(top - bottom);
        v46 = sinf(v36);
        this->m_fRadians = v36;
        v47 = (float)((float)((float)(left + right) * 0.5) + (float)(v44 * -0.0075))
            + (float)((float)(v44 * v39) * 0.51);
        v48 = (float)((float)(v43 * 0.5) + (float)(v45 * -0.005)) + (float)((float)(v46 * v45) * 0.51);
        this->m_RectDot.left = v47 - (float)(v44 * 0.11);
        this->m_RectDot.top = (float)(v44 * 0.11) + v48;
        this->m_RectDot.right = (float)(v44 * 0.11) + v47;
        this->m_RectDot.bottom = v48 - (float)(v44 * 0.11);
      }
    }
    goto LABEL_49;
  }
  if ( FindPlayerPed(-1) )
  {
    v14 = FindPlayerPed(-1);
    if ( CPedIntelligence::GetTaskJetPack(v14->m_pPedIntelligence) )
    {
      v15 = &this->m_Sprite;
      v16 = "hud_drop_jetpack";
LABEL_13:
      CWidget::SetTexture(this, v15, (unsigned __int8 *)v16, 1);
      v13 = pMobileDB;
      goto LABEL_49;
    }
  }
  if ( FindPlayerVehicle(-1, 0) && FindPlayerVehicle(-1, 0)->m_nModelIndex == 539 )
  {
    v15 = &this->m_Sprite;
    v16 = "hud_boat";
    goto LABEL_13;
  }
  v13 = pMobileDB;
  switch ( nVehicleType )
  {
    case -1:
    case 0:
    case 7:
      v19 = &this->m_Sprite;
      v20 = "hud_car";
      break;
    case 1:
      v19 = &this->m_Sprite;
      v20 = "hud_monstertruck";
      break;
    case 2:
    case 9:
      v19 = &this->m_Sprite;
      v20 = "hud_bike";
      break;
    case 3:
      v19 = &this->m_Sprite;
      v20 = "hud_chopper";
      break;
    case 4:
    case 8:
      v19 = &this->m_Sprite;
      v20 = "hud_plane";
      break;
    case 5:
      v19 = &this->m_Sprite;
      v20 = "hud_boat";
      break;
    case 6:
      v19 = &this->m_Sprite;
      v20 = "hud_train";
      break;
    case 10:
      v19 = &this->m_Sprite;
      v20 = "hud_bicycle";
      break;
    case 11:
      v19 = &this->m_Sprite;
      v20 = "hud_trailer";
      break;
    default:
      v15 = &this->m_Sprite;
      v16 = "hud_car";
      goto LABEL_13;
  }
  CWidget::SetTexture(this, v19, (unsigned __int8 *)v20, 1);
LABEL_49:
  sub_198F08(v13);
}

//----- (002B653C) --------------------------------------------------------
void __fastcall CWidgetButtonEnterCar::Draw(CWidgetButtonEnterCar *this)
{
  CWidgetButton::Draw(this);
  if ( this->m_RectDot.left != 0.0 || this->m_RectDot.right != 0.0 )
    sub_196D84(&this->m_SpriteIndicator, &this->m_RectDot, this->m_fRadians + -1.5708, &this->m_Color);
}

//----- (002B65A8) --------------------------------------------------------
void __fastcall CWidgetButtonEnterCar::~CWidgetButtonEnterCar(CWidgetButtonEnterCar *this)
{
  this->_vptr$CWidget = (int (**)(void))&off_6637AC;
  CSprite2d::~CSprite2d(&this->m_SpriteIndicator);
  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  sub_19C514(this);
}
// 662F00: using guessed type void *off_662F00;
// 6637AC: using guessed type void *off_6637AC;

//----- (002B65E8) --------------------------------------------------------
void __fastcall CWidgetButtonEnterCar::~CWidgetButtonEnterCar(CWidgetButtonEnterCar *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_6637AC;
  CSprite2d::~CSprite2d(&this->m_SpriteIndicator);
  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2B6620: variable 'v2' is possibly undefined
// 662F00: using guessed type void *off_662F00;
// 6637AC: using guessed type void *off_6637AC;

//----- (002B662C) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetButtonEnterCar::GetName(CWidgetButtonEnterCar *this)
{
  return "BTN EC";
}

//----- (002B6638) --------------------------------------------------------
void __fastcall CWidgetButtonHorn::CWidgetButtonHorn(
        CWidgetButtonHorn *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  CTouchInterface::WidgetPositionIDs v4; // r0
  float v5; // r0
  float v6; // r1
  float fScaleY; // [sp+8h] [bp-18h] BYREF
  float fScaleX; // [sp+Ch] [bp-14h] BYREF
  float fOriginY; // [sp+10h] [bp-10h] BYREF
  unsigned int fOriginX[3]; // [sp+14h] [bp-Ch] BYREF

  CWidgetButton::CWidgetButton(this, pszSprite, WidgetPos, 1u, 0, HID_MAPPING_HORN);
  this->_vptr$CWidget = (int (**)(void))&off_663840;
  fOriginX[0] = 0;
  fScaleX = 0.0;
  fOriginY = 0.0;
  v4 = WIDGET_POSITION_HORN;
  fScaleY = 0.0;
  if ( bRhythm )
    v4 = WIDGET_POSITION_HORN_ALT;
  CTouchInterface::GetWidgetPosition(v4, (float *)fOriginX, &fOriginY, &fScaleX, &fScaleY);
  v5 = fScaleY;
  v6 = fScaleX;
  *(_QWORD *)&this->m_fOriginX = __PAIR64__(LODWORD(fOriginY), fOriginX[0]);
  this->m_fScaleX = v6;
  this->m_fScaleY = v5;
}
// 663840: using guessed type void *;
// 2B6638: using guessed type unsigned int fOriginX[3];

//----- (002B669C) --------------------------------------------------------
void __fastcall CWidgetButtonHorn::SetupPositionAndScale(CWidgetButtonHorn *this)
{
  CTouchInterface::WidgetPositionIDs v2; // r0
  float v3; // r0
  float v4; // r1
  float fScaleY; // [sp+8h] [bp-18h] BYREF
  float fScaleX; // [sp+Ch] [bp-14h] BYREF
  float fOriginY; // [sp+10h] [bp-10h] BYREF
  unsigned int fOriginX[3]; // [sp+14h] [bp-Ch] BYREF

  fOriginX[0] = 0;
  fScaleX = 0.0;
  fOriginY = 0.0;
  fScaleY = 0.0;
  v2 = WIDGET_POSITION_HORN;
  if ( bRhythm )
    v2 = WIDGET_POSITION_HORN_ALT;
  CTouchInterface::GetWidgetPosition(v2, (float *)fOriginX, &fOriginY, &fScaleX, &fScaleY);
  v3 = fScaleY;
  v4 = fScaleX;
  *(_QWORD *)&this->m_fOriginX = __PAIR64__(LODWORD(fOriginY), fOriginX[0]);
  this->m_fScaleX = v4;
  this->m_fScaleY = v3;
}
// 2B669C: using guessed type unsigned int fOriginX[3];

//----- (002B66E4) --------------------------------------------------------
void __fastcall CWidgetButtonHorn::Update(CWidgetButtonHorn *this)
{
  int v2; // r0
  _BOOL4 v3; // r2
  CTouchInterface::WidgetPositionIDs v4; // r4
  float v5; // r0
  float v6; // r1
  float v7; // r4
  float fScaleY; // [sp+8h] [bp-18h] BYREF
  float fScaleX; // [sp+Ch] [bp-14h] BYREF
  float fOriginY; // [sp+10h] [bp-10h] BYREF
  float fOriginX[3]; // [sp+14h] [bp-Ch] BYREF

  CWidgetButton::Update(this);
  v2 = strcmp((const char *)CTheScripts::pActiveScripts->ScriptName, "lowgame");
  v3 = v2 == 0;
  bRhythm = v2 == 0;
  if ( v3 != bOldRhythm )
  {
    fOriginY = 0.0;
    fOriginX[0] = 0.0;
    v4 = WIDGET_POSITION_HORN;
    fScaleY = 0.0;
    fScaleX = 0.0;
    if ( !v2 )
      v4 = WIDGET_POSITION_HORN_ALT;
    CTouchInterface::GetWidgetPosition(v4, fOriginX, &fOriginY, &fScaleX, &fScaleY);
    v5 = fScaleY;
    v6 = fScaleX;
    v7 = fOriginY;
    this->m_fOriginX = fOriginX[0];
    this->m_fOriginY = v7;
    this->m_fScaleX = v6;
    this->m_fScaleY = v5;
    LOBYTE(v3) = bRhythm;
  }
  bOldRhythm = v3;
}
// 2B66E4: using guessed type float fOriginX[3];

//----- (002B677C) --------------------------------------------------------
void __fastcall CWidgetButtonHorn::~CWidgetButtonHorn(CWidgetButtonHorn *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2B67A0: variable 'v2' is possibly undefined
// 662F00: using guessed type void *off_662F00;

//----- (002B67A8) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetButtonHorn::GetName(CWidgetButtonHorn *this)
{
  return (_BYTE *)sub_2B67AC;
}
// 2B67AC: using guessed type int sub_2B67AC();

//----- (002B67B4) --------------------------------------------------------
void __fastcall CWidgetButtonAutoHydraulics::CWidgetButtonAutoHydraulics(
        CWidgetButtonAutoHydraulics *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  int v3; // r0

  CWidgetButton::CWidgetButton(this, pszSprite, WidgetPos, 1u, 0xC00u, HID_MAPPING_AUTO_HYDRAULICS);
  *(_BYTE *)(v3 + 168) = 0;
  *(_DWORD *)v3 = &off_6638D4;
}
// 2B67D0: variable 'v3' is possibly undefined
// 6638D4: using guessed type void *;

//----- (002B67E4) --------------------------------------------------------
void __fastcall CWidgetButtonAutoHydraulics::Update(CWidgetButtonAutoHydraulics *this)
{
  int m_bIsPlayerOnAMission; // r5
  CVehicle *PlayerVehicle; // r0
  int m_nModelIndex; // r0
  int v5; // r1
  CSprite2d *p_m_Sprite; // r1
  char *v7; // r2

  CWidgetButton::Update(this);
  m_bIsPlayerOnAMission = this->m_bIsPlayerOnAMission;
  if ( m_bIsPlayerOnAMission != CTheScripts::IsPlayerOnAMission() && CTheScripts::IsPlayerOnAMission() )
    this->m_fUserData = 0.0;
  this->m_bIsPlayerOnAMission = CTheScripts::IsPlayerOnAMission();
  PlayerVehicle = FindPlayerVehicle(-1, 0);
  if ( PlayerVehicle )
  {
    m_nModelIndex = PlayerVehicle->m_nModelIndex;
    v5 = 531;
    if ( m_nModelIndex != 531 )
      v5 = 525;
    if ( m_nModelIndex == 531 || m_nModelIndex == v5 )
    {
      p_m_Sprite = &this->m_Sprite;
      if ( this->m_fUserData > 0.0 )
      {
LABEL_10:
        v7 = "menu_up";
LABEL_13:
        sub_18CDC4(this, p_m_Sprite, (unsigned __int8 *)v7, 0);
        return;
      }
    }
    else
    {
      p_m_Sprite = &this->m_Sprite;
      if ( this->m_fUserData <= 0.0 )
        goto LABEL_10;
    }
    v7 = "menu_down";
    goto LABEL_13;
  }
}

//----- (002B6880) --------------------------------------------------------
void __fastcall CWidgetButtonAutoHydraulics::~CWidgetButtonAutoHydraulics(CWidgetButtonAutoHydraulics *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2B68A4: variable 'v2' is possibly undefined
// 662F00: using guessed type void *off_662F00;

//----- (002B68AC) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetButtonAutoHydraulics::GetName(CWidgetButtonAutoHydraulics *this)
{
  return (_BYTE *)sub_2B68B0;
}
// 2B68B0: using guessed type int sub_2B68B0();

//----- (002B68C0) --------------------------------------------------------
void __fastcall CWidgetButtonMissionCancel::CWidgetButtonMissionCancel(
        CWidgetButtonMissionCancel *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos,
        HIDMapping Mapping)
{
  _DWORD *v4; // r0

  CWidgetButton::CWidgetButton(this, pszSprite, WidgetPos, 1u, 0x2C00u, Mapping);
  *v4 = &off_663968;
}
// 2B68DC: variable 'v4' is possibly undefined
// 663968: using guessed type void *;

//----- (002B68E8) --------------------------------------------------------
void __fastcall CWidgetButtonMissionCancel::Update(CWidgetButtonMissionCancel *this)
{
  CRunningScript *v2; // r11

  CWidgetButton::Update(this);
  CTouchInterface::GetWidgetPosition(
    WIDGET_POSITION_MISSION_START_AND_MISSION_CANCEL,
    &this->m_fOriginX,
    &this->m_fOriginY,
    &this->m_fScaleX,
    &this->m_fScaleY);
  CWidget::SetTexture(this, &this->m_Sprite, "hud_x", 0);
  v2 = CTheScripts::pActiveScripts;
  if ( CTheScripts::pActiveScripts )
  {
    if ( strcmp((const char *)CTheScripts::pActiveScripts->ScriptName, "bball")
      && strcmp((const char *)v2->ScriptName, "bbchal")
      && strcmp((const char *)v2->ScriptName, "shrange")
      || (CWidget::SetTexture(this, &this->m_Sprite, "hud_drop_jetpack", 0), (v2 = CTheScripts::pActiveScripts) != 0) )
    {
      if ( !strcmp((const char *)v2->ScriptName, "shrange") )
        CTouchInterface::GetWidgetPosition(
          WIDGET_POSITION_ENTER_CAR,
          &this->m_fOriginX,
          &this->m_fOriginY,
          &this->m_fScaleX,
          &this->m_fScaleY);
    }
  }
}

//----- (002B69D8) --------------------------------------------------------
void __fastcall CWidgetButtonMissionCancel::~CWidgetButtonMissionCancel(CWidgetButtonMissionCancel *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2B69FC: variable 'v2' is possibly undefined
// 662F00: using guessed type void *off_662F00;

//----- (002B6A04) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetButtonMissionCancel::GetName(CWidgetButtonMissionCancel *this)
{
  return "BT Cancel";
}

//----- (002B6A14) --------------------------------------------------------
void __fastcall CWidgetButtonSprint::CWidgetButtonSprint(
        CWidgetButtonSprint *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  CWidgetButton::CWidgetButton(this, pszSprite, WidgetPos, 1u, 0x40u, HID_MAPPING_SPRINT);
  this->_vptr$CWidget = (int (**)(void))&off_6639FC;
  CWidgetButton::SetFillSprite(this, "sprint", 0.12, 0.88);
}
// 6639FC: using guessed type void *;

//----- (002B6A60) --------------------------------------------------------
void __fastcall CWidgetButtonSprint::Update(CWidgetButtonSprint *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d2
  float FatAndMuscleModifier; // r5

  CWidgetButton::Update(this);
  if ( FindPlayerPed(-1) )
  {
    FatAndMuscleModifier = CStats::GetFatAndMuscleModifier(STAT_MODIFIER_SPRINT_ENERGY);
    v3.n64_u32[0] = 0;
    v2.n64_u32[0] = 1.0;
    v1.n64_f32[0] = 1.0
                  - (float)((float)(FindPlayerPed(-1)->m_pPlayerData->m_fSprintEnergy + 150.0)
                          / (float)(FatAndMuscleModifier + 150.0));
    LODWORD(this->m_fFillLevel) = vmax_f32(vmin_f32(v1, v2), v3).n64_u32[0];
  }
}
// 2B6AB0: variable 'v1' is possibly undefined
// 2B6AB0: variable 'v2' is possibly undefined
// 2B6AB4: variable 'v3' is possibly undefined

//----- (002B6AC8) --------------------------------------------------------
bool __fastcall CWidgetButtonSprint::IsDoubleTapped(CWidgetButtonSprint *this)
{
  if ( CHID::Implements(HID_MAPPING_JUMP) )
    return sub_18DF74(HID_MAPPING_JUMP);
  else
    return sub_196C68(this);
}

//----- (002B6AEC) --------------------------------------------------------
void __fastcall CWidgetButtonSprint::DrawHelpIcon(
        CWidgetButtonSprint *this,
        const unsigned __int8 *pszCharacters,
        float fX,
        float fY,
        float fHeight,
        int nAlpha)
{
  if ( CHID::Implements(HID_MAPPING_SPRINT) )
    CHID::DrawHelpIcon(pszCharacters, HID_MAPPING_SPRINT, fX, fY, fHeight, nAlpha, 0);
  else
    sub_19F52C(this, pszCharacters, fX, fY, fHeight, nAlpha);
}

//----- (002B6B44) --------------------------------------------------------
void __fastcall CWidgetButtonSprint::~CWidgetButtonSprint(CWidgetButtonSprint *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2B6B68: variable 'v2' is possibly undefined
// 662F00: using guessed type void *off_662F00;

//----- (002B6B70) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetButtonSprint::GetName(CWidgetButtonSprint *this)
{
  return "BTN SPRINT";
}

//----- (002B6B80) --------------------------------------------------------
void __fastcall CWidgetButtonSwim::CWidgetButtonSwim(
        CWidgetButtonSwim *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  CWidgetButton::CWidgetButton(this, pszSprite, WidgetPos, 1u, 0x40u, HID_MAPPING_SPRINT);
  this->_vptr$CWidget = (int (**)(void))&off_663A90;
  CWidgetButton::SetFillSprite(this, "hud_swim", 0.25, 0.8);
}
// 663A90: using guessed type void *;

//----- (002B6BCC) --------------------------------------------------------
void __fastcall CWidgetButtonSwim::Update(CWidgetButtonSwim *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d2
  float FatAndMuscleModifier; // r5

  CWidgetButton::Update(this);
  if ( FindPlayerPed(-1) )
  {
    FatAndMuscleModifier = CStats::GetFatAndMuscleModifier(STAT_MODIFIER_SPRINT_ENERGY);
    v3.n64_u32[0] = 0;
    v2.n64_u32[0] = 1.0;
    v1.n64_f32[0] = 1.0
                  - (float)((float)(FindPlayerPed(-1)->m_pPlayerData->m_fSprintEnergy + 150.0)
                          / (float)(FatAndMuscleModifier + 150.0));
    LODWORD(this->m_fFillLevel) = vmax_f32(vmin_f32(v1, v2), v3).n64_u32[0];
  }
}
// 2B6C1C: variable 'v1' is possibly undefined
// 2B6C1C: variable 'v2' is possibly undefined
// 2B6C20: variable 'v3' is possibly undefined

//----- (002B6C34) --------------------------------------------------------
void __fastcall CWidgetButtonSwim::~CWidgetButtonSwim(CWidgetButtonSwim *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2B6C58: variable 'v2' is possibly undefined
// 662F00: using guessed type void *off_662F00;

//----- (002B6C60) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetButtonSwim::GetName(CWidgetButtonSwim *this)
{
  return "BTN SWIM";
}

//----- (002B6C70) --------------------------------------------------------
void __fastcall CWidgetButtonVCShoot::CWidgetButtonVCShoot(
        CWidgetButtonVCShoot *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  _DWORD *v3; // r0

  CWidgetButton::CWidgetButton(this, pszSprite, WidgetPos, 1u, 0x100u, HID_MAPPING_ATTACK);
  *v3 = &off_663B24;
}
// 2B6C90: variable 'v3' is possibly undefined
// 663B24: using guessed type void *off_663B24;

//----- (002B6C9C) --------------------------------------------------------
void __fastcall CWidgetButtonVCShoot::Update(CWidgetButtonVCShoot *this)
{
  CPlayerPed *PlayerPed; // r0
  CSprite2d *p_m_Sprite; // r1
  char *v4; // r2
  HIDMapping v5; // r5
  CPlayerPed *v6; // r0

  CWidgetButton::Update(this);
  if ( FindPlayerPed(-1)
    && (PlayerPed = FindPlayerPed(-1),
        PlayerPed->m_WeaponSlots[PlayerPed->m_nCurrentWeapon].m_eWeaponType == WEAPONTYPE_CAMERA) )
  {
    p_m_Sprite = &this->m_Sprite;
    v4 = "hud_camera";
  }
  else
  {
    p_m_Sprite = &this->m_Sprite;
    v4 = "shoot";
  }
  CWidget::SetTexture(this, p_m_Sprite, (unsigned __int8 *)v4, 0);
  if ( CHID::GetInputType() == 2 )
  {
    v5 = HID_MAPPING_ATTACK;
    if ( FindPlayerPed(-1) )
    {
      v6 = FindPlayerPed(-1);
      if ( CPedIntelligence::GetTaskJetPack(v6->m_pPedIntelligence) )
        v5 = HID_MAPPING_FLIGHT_PRIMARY_ATTACK;
    }
    this->m_HIDMapping = v5;
  }
  else
  {
    this->m_HIDMapping = HID_MAPPING_ATTACK;
  }
}

//----- (002B6D2C) --------------------------------------------------------
void __fastcall CWidgetButtonVCShoot::~CWidgetButtonVCShoot(CWidgetButtonVCShoot *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2B6D50: variable 'v2' is possibly undefined
// 662F00: using guessed type void *off_662F00;

//----- (002B6D58) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetButtonVCShoot::GetName(CWidgetButtonVCShoot *this)
{
  return "VC Shoot";
}

//----- (002B6D68) --------------------------------------------------------
void __fastcall CWidgetButtonZoom::CWidgetButtonZoom(
        CWidgetButtonZoom *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos,
        HIDMapping Mapping)
{
  _DWORD *v4; // r0

  CWidgetButton::CWidgetButton(this, pszSprite, WidgetPos, 1u, 0xC00u, Mapping);
  *v4 = &off_663BB8;
}
// 2B6D84: variable 'v4' is possibly undefined
// 663BB8: using guessed type void *;

//----- (002B6D90) --------------------------------------------------------
void __fastcall CWidgetButtonZoom::Update(CWidgetButtonZoom *this)
{
  CWidgetButton::Update(this);
  this->m_nFlags |= 0xC00u;
  if ( CHID::GetInputType() == 2 )
    this->m_nFlags &= 0xFFFFF3FF;
}

//----- (002B6DBC) --------------------------------------------------------
void __fastcall CWidgetButtonZoom::~CWidgetButtonZoom(CWidgetButtonZoom *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2B6DE0: variable 'v2' is possibly undefined
// 662F00: using guessed type void *off_662F00;

//----- (002B6DE8) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetButtonZoom::GetName(CWidgetButtonZoom *this)
{
  return "BT Zoom";
}

//----- (002B6E00) --------------------------------------------------------
void __fastcall CWidgetHelpText::CWidgetHelpText(
        CWidgetHelpText *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  float fScaleY; // [sp+8h] [bp-20h] BYREF
  float fScaleX; // [sp+Ch] [bp-1Ch] BYREF
  float fOriginY; // [sp+10h] [bp-18h] BYREF
  float fOriginX[5]; // [sp+14h] [bp-14h] BYREF

  CWidget::CWidget(this, pszSprite, WidgetPos, 4u, HID_MAPPING_UNKNOWN);
  *(_QWORD *)&this->m_RectClient.left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_RectClient.right = 0x49742400C9742400LL;
  this->_vptr$CWidget = (int (**)(void))&off_663C4C;
  AsciiToGxtChar((const Char *)&byte_61CADE, this->m_messages[0].m_GxtString);
  this->m_messages[0].m_nStatID = 0;
  this->m_messages[0].m_fDisplayPeriod = 0.0;
  this->m_messages[0].m_fStatRate = 0.0;
  this->m_messages[0].m_fStatMaxValue = 0.0;
  this->m_messages[0].m_nConditionFlag = 0;
  AsciiToGxtChar((const Char *)&byte_61CADE, this->m_messages[1].m_GxtString);
  this->m_messages[1].m_nStatID = 0;
  this->m_messages[1].m_fDisplayPeriod = 0.0;
  this->m_messages[1].m_fStatRate = 0.0;
  this->m_messages[1].m_fStatMaxValue = 0.0;
  this->m_messages[1].m_nConditionFlag = 0;
  AsciiToGxtChar((const Char *)&byte_61CADE, this->m_messages[2].m_GxtString);
  this->m_messages[2].m_nStatID = 0;
  this->m_messages[2].m_fDisplayPeriod = 0.0;
  this->m_messages[2].m_fStatRate = 0.0;
  this->m_messages[2].m_fStatMaxValue = 0.0;
  this->m_messages[2].m_nConditionFlag = 0;
  AsciiToGxtChar((const Char *)&byte_61CADE, this->m_messages[3].m_GxtString);
  this->m_messages[3].m_nStatID = 0;
  this->m_messages[3].m_fDisplayPeriod = 0.0;
  this->m_messages[3].m_fStatRate = 0.0;
  this->m_messages[3].m_fStatMaxValue = 0.0;
  this->m_messages[3].m_nConditionFlag = 0;
  AsciiToGxtChar((const Char *)&byte_61CADE, this->m_messages[4].m_GxtString);
  this->m_messages[4].m_nStatID = 0;
  this->m_messages[4].m_fDisplayPeriod = 0.0;
  this->m_messages[4].m_fStatRate = 0.0;
  this->m_messages[4].m_fStatMaxValue = 0.0;
  this->m_messages[4].m_nConditionFlag = 0;
  AsciiToGxtChar((const Char *)&byte_61CADE, this->m_messages[5].m_GxtString);
  this->m_messages[5].m_nStatID = 0;
  this->m_messages[5].m_fDisplayPeriod = 0.0;
  this->m_messages[5].m_fStatRate = 0.0;
  this->m_messages[5].m_fStatMaxValue = 0.0;
  this->m_messages[5].m_nConditionFlag = 0;
  AsciiToGxtChar((const Char *)&byte_61CADE, this->m_messages[6].m_GxtString);
  this->m_messages[6].m_nStatID = 0;
  this->m_messages[6].m_fDisplayPeriod = 0.0;
  this->m_messages[6].m_fStatRate = 0.0;
  this->m_messages[6].m_fStatMaxValue = 0.0;
  this->m_messages[6].m_nConditionFlag = 0;
  AsciiToGxtChar((const Char *)&byte_61CADE, this->m_messages[7].m_GxtString);
  this->m_messages[7].m_nStatID = 0;
  this->m_messages[7].m_fDisplayPeriod = 0.0;
  this->m_messages[7].m_fStatRate = 0.0;
  this->m_messages[7].m_fStatMaxValue = 0.0;
  this->m_messages[7].m_nConditionFlag = 0;
  AsciiToGxtChar((const Char *)&byte_61CADE, this->m_messages[8].m_GxtString);
  this->m_messages[8].m_nStatID = 0;
  this->m_messages[8].m_fDisplayPeriod = 0.0;
  this->m_messages[8].m_fStatRate = 0.0;
  this->m_messages[8].m_fStatMaxValue = 0.0;
  this->m_messages[8].m_nConditionFlag = 0;
  AsciiToGxtChar((const Char *)&byte_61CADE, this->m_messages[9].m_GxtString);
  this->m_messages[9].m_nStatID = 0;
  this->m_messages[9].m_fDisplayPeriod = 0.0;
  this->m_messages[9].m_fStatRate = 0.0;
  this->m_messages[9].m_fStatMaxValue = 0.0;
  this->m_messages[9].m_nConditionFlag = 0;
  CWidgetHelpText::m_pInstance = this;
  *(_QWORD *)&this->m_fTextAlpha = 0LL;
  *(_QWORD *)&this->m_fStateTime = 0LL;
  this->m_fYOffset = 0.0;
  fOriginY = 0.0;
  fOriginX[0] = 0.0;
  fScaleY = 0.0;
  fScaleX = 0.0;
  CTouchInterface::GetWidgetPosition(WIDGET_POSITION_HELP_TEXT, fOriginX, &fOriginY, &fScaleX, &fScaleY);
  this->m_fTextHeight = fScaleY * (float)((float)RsGlobal.screenHeight / 448.0);
}
// 61CADE: using guessed type char byte_61CADE;
// 663C4C: using guessed type void *off_663C4C;
// 2B6E00: using guessed type float fOriginX[5];

//----- (002B7024) --------------------------------------------------------
void __fastcall CWidgetHelpText::~CWidgetHelpText(CWidgetHelpText *this)
{
  this->_vptr$CWidget = (int (**)(void))&off_663C4C;
  CWidgetHelpText::m_pInstance = 0;
  sub_19C514(this);
}
// 663C4C: using guessed type void *;

//----- (002B7044) --------------------------------------------------------
void __fastcall CWidgetHelpText::~CWidgetHelpText(CWidgetHelpText *this)
{
  void *v1; // r0

  this->_vptr$CWidget = (int (**)(void))&off_663C4C;
  CWidgetHelpText::m_pInstance = 0;
  CWidget::~CWidget(this);
  sub_191374(v1);
}
// 2B7064: variable 'v1' is possibly undefined
// 663C4C: using guessed type void *off_663C4C;

//----- (002B7070) --------------------------------------------------------
void __fastcall CWidgetHelpText::AddMessageToQueue(
        CWidgetHelpText *this,
        GxtChar *pMessage,
        int bInfinite,
        int nStatID,
        float fStatRate,
        float fStatMaxValue,
        unsigned int nConditionFlag)
{
  QueuedMessage *m_messages; // r5
  float v12; // s0
  float v13[216]; // [sp+0h] [bp-360h] BYREF

  if ( !CMessages::GetGxtStringLength(this->m_messages[9].m_GxtString)
    && (nStatID || !CWidgetHelpText::IsStringQueued(this, pMessage)) )
  {
    m_messages = this->m_messages;
    if ( !CMessages::GetGxtStringLength(this->m_messages[0].m_GxtString) )
      goto LABEL_14;
    m_messages = &this->m_messages[1];
    if ( !CMessages::GetGxtStringLength(this->m_messages[1].m_GxtString) )
      goto LABEL_14;
    m_messages = &this->m_messages[2];
    if ( !CMessages::GetGxtStringLength(this->m_messages[2].m_GxtString)
      || (m_messages = &this->m_messages[3], !CMessages::GetGxtStringLength(this->m_messages[3].m_GxtString))
      || (m_messages = &this->m_messages[4], !CMessages::GetGxtStringLength(this->m_messages[4].m_GxtString))
      || (m_messages = &this->m_messages[5], !CMessages::GetGxtStringLength(this->m_messages[5].m_GxtString))
      || (m_messages = &this->m_messages[6], !CMessages::GetGxtStringLength(this->m_messages[6].m_GxtString))
      || (m_messages = &this->m_messages[7], !CMessages::GetGxtStringLength(this->m_messages[7].m_GxtString))
      || (m_messages = &this->m_messages[8], !CMessages::GetGxtStringLength(this->m_messages[8].m_GxtString))
      || (m_messages = &this->m_messages[9], !CMessages::GetGxtStringLength(this->m_messages[9].m_GxtString)) )
    {
LABEL_14:
      AsciiToGxtChar((const Char *)&byte_61CADE, (GxtChar *)v13);
      CMessages::GxtStringCopy((GxtChar *)v13, pMessage, 0x190u);
      v12 = 5.0;
      if ( bInfinite )
        v12 = 9.0;
      LOWORD(v13[201]) = nStatID;
      v13[202] = fStatRate;
      v13[203] = fStatMaxValue;
      LODWORD(v13[204]) = nConditionFlag;
      v13[200] = v12;
      qmemcpy(m_messages, v13, sizeof(QueuedMessage));
    }
  }
}
// 61CADE: using guessed type char byte_61CADE;

//----- (002B7190) --------------------------------------------------------
bool __fastcall CWidgetHelpText::IsStringQueued(CWidgetHelpText *this, GxtChar *pMessage)
{
  return CMessages::GxtStringCompare(pMessage, this->m_messages[0].m_GxtString, 0x190u)
      || CMessages::GxtStringCompare(pMessage, this->m_messages[1].m_GxtString, 0x190u)
      || CMessages::GxtStringCompare(pMessage, this->m_messages[2].m_GxtString, 0x190u)
      || CMessages::GxtStringCompare(pMessage, this->m_messages[3].m_GxtString, 0x190u)
      || CMessages::GxtStringCompare(pMessage, this->m_messages[4].m_GxtString, 0x190u)
      || CMessages::GxtStringCompare(pMessage, this->m_messages[5].m_GxtString, 0x190u)
      || CMessages::GxtStringCompare(pMessage, this->m_messages[6].m_GxtString, 0x190u)
      || CMessages::GxtStringCompare(pMessage, this->m_messages[7].m_GxtString, 0x190u)
      || CMessages::GxtStringCompare(pMessage, this->m_messages[8].m_GxtString, 0x190u)
      || CMessages::GxtStringCompare(pMessage, this->m_messages[9].m_GxtString, 0x190u) != 0;
}

//----- (002B724E) --------------------------------------------------------
void __fastcall CWidgetHelpText::Process(CWidgetHelpText *this)
{
  if ( CWidgetHelpText::UseTopStyle(this) )
    CWidgetHelpText::ProcessTopStyle(this);
  else
    CWidgetHelpText::ProcessMidScreenStyle(this);
}

//----- (002B726C) --------------------------------------------------------
bool __fastcall CWidgetHelpText::UseTopStyle(CWidgetHelpText *this)
{
  return CWidgetInfoFrame::AnyObjectEnabled()
      || CWidgetButtonAnimated::AnyObjectEnabled()
      || CTouchInterface::m_pWidgets[64] && CWidget::GetEnabled(CTouchInterface::m_pWidgets[64])
      || CTouchInterface::m_pWidgets[65] && CWidget::GetEnabled(CTouchInterface::m_pWidgets[65])
      || CTouchInterface::m_pWidgets[180] && CWidget::GetEnabled(CTouchInterface::m_pWidgets[180])
      || CTouchInterface::m_pWidgets[177] && CWidget::GetEnabled(CTouchInterface::m_pWidgets[177])
      || CTouchInterface::m_pWidgets[181] && CWidget::GetEnabled(CTouchInterface::m_pWidgets[181])
      || CTouchInterface::m_pWidgets[176] && CWidget::GetEnabled(CTouchInterface::m_pWidgets[176])
      || CTouchInterface::m_pWidgets[183] && CWidget::GetEnabled(CTouchInterface::m_pWidgets[183])
      || CTouchInterface::m_pWidgets[156] && CWidget::GetEnabled(CTouchInterface::m_pWidgets[156]);
}

//----- (002B7338) --------------------------------------------------------
void __fastcall CWidgetHelpText::ProcessTopStyle(CWidgetHelpText *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d2
  float32x2_t v4; // d3
  float32x2_t v5; // d4
  float32x2_t v6; // d8
  int v8; // r6
  float v9; // s2
  double v10; // d16
  float v11; // s2
  int v12; // r1
  float m_fTextHeight; // s16
  double v14; // d16
  float m_fDisplayPeriod; // r0
  float v16; // s2
  float m_fStateTime; // s4
  float v18; // s2
  double v19; // d16
  float v20; // s4
  float v21; // s2
  int GxtStringLength; // r0
  int m_nState; // r0

  v8 = CWidgetHelpText::SetFontProps(this, this->m_messages[this->m_nState == 3].m_GxtString);
  v6.n64_u32[0] = 0;
  switch ( this->m_nState )
  {
    case 0:
      this->m_fTextAlpha = 0.0;
      this->m_fBackdropAlpha = 0.0;
      if ( CMessages::GetGxtStringLength(this->m_messages[0].m_GxtString) )
      {
        this->m_fStateTime = 0.0;
        this->m_nState = 1;
        goto LABEL_14;
      }
      goto LABEL_23;
    case 1:
      v5.n64_u32[0] = 1.0;
      v3.n64_u32[0] = 1051092582;
      v1.n64_f32[0] = CWidget::m_fElapsedTime + this->m_fStateTime;
      v1.n64_u64[0] = vmin_f32(v1, v3).n64_u64[0];
      v6.n64_f32[0] = this->m_fTextHeight * (float)v8;
      v3.n64_f32[0] = v1.n64_f32[0] / 0.325;
      LODWORD(v11) = vmin_f32(v3, v5).n64_u32[0];
      this->m_fTextAlpha = v11;
      this->m_fBackdropAlpha = v11;
      LODWORD(this->m_fStateTime) = v1.n64_u32[0];
      goto LABEL_6;
    case 2:
      v2.n64_u32[0] = LODWORD(this->m_messages[0].m_fDisplayPeriod);
      m_fTextHeight = this->m_fTextHeight;
      v14 = CWidget::m_fElapsedTime + this->m_fStateTime;
      this->m_fTextAlpha = 1.0;
      this->m_fBackdropAlpha = 1.0;
      v1.n64_f32[0] = v14;
      v1.n64_u64[0] = vmin_f32(v2, v1).n64_u64[0];
      LODWORD(this->m_fStateTime) = v1.n64_u32[0];
      if ( CTouchInterface::IsReleased(WIDGET_HELP_TEXT, 0, 1) )
      {
        m_fDisplayPeriod = this->m_messages[0].m_fDisplayPeriod;
        this->m_fStateTime = m_fDisplayPeriod;
        v16 = m_fDisplayPeriod;
        m_fStateTime = m_fDisplayPeriod;
      }
      else
      {
        m_fStateTime = this->m_fStateTime;
        v16 = this->m_messages[0].m_fDisplayPeriod;
      }
      v6.n64_f32[0] = m_fTextHeight * (float)v8;
      if ( m_fStateTime != v16 )
        goto LABEL_23;
      GxtStringLength = CMessages::GetGxtStringLength(this->m_messages[1].m_GxtString);
      v12 = 5;
      if ( GxtStringLength )
        v12 = 3;
      break;
    case 3:
      v4.n64_u32[0] = 1.0;
      v3.n64_u32[0] = 1051092582;
      v18 = this->m_fTextHeight;
      v19 = CWidget::m_fElapsedTime + this->m_fStateTime;
      this->m_fBackdropAlpha = 1.0;
      v1.n64_f32[0] = v19;
      v1.n64_u64[0] = vmin_f32(v1, v3).n64_u64[0];
      v6.n64_f32[0] = v18 * (float)v8;
      v3.n64_f32[0] = v1.n64_f32[0] / 0.325;
      LODWORD(this->m_fStateTime) = v1.n64_u32[0];
      v20 = 1.0 - vmin_f32(v3, v4).n64_f32[0];
      this->m_fTextAlpha = v20;
      if ( v20 == 0.0 )
      {
        this->m_fStateTime = 0.0;
        this->m_nState = 4;
        qmemcpy(this->m_messages, &this->m_messages[1], 0x334u);
        qmemcpy(&this->m_messages[1], &this->m_messages[2], sizeof(this->m_messages[1]));
        qmemcpy(&this->m_messages[2], &this->m_messages[3], sizeof(this->m_messages[2]));
        qmemcpy(&this->m_messages[3], &this->m_messages[4], sizeof(this->m_messages[3]));
        qmemcpy(&this->m_messages[4], &this->m_messages[5], sizeof(this->m_messages[4]));
        qmemcpy(&this->m_messages[5], &this->m_messages[6], sizeof(this->m_messages[5]));
        qmemcpy(&this->m_messages[6], &this->m_messages[7], sizeof(this->m_messages[6]));
        qmemcpy(&this->m_messages[7], &this->m_messages[8], sizeof(this->m_messages[7]));
        qmemcpy(&this->m_messages[8], &this->m_messages[9], sizeof(this->m_messages[8]));
        AsciiToGxtChar((const Char *)&byte_61CADE, this->m_messages[9].m_GxtString);
        this->m_messages[9].m_nStatID = 0;
        this->m_messages[9].m_fDisplayPeriod = 0.0;
        this->m_messages[9].m_fStatRate = 0.0;
        this->m_messages[9].m_fStatMaxValue = 0.0;
        this->m_messages[9].m_nConditionFlag = 0;
LABEL_14:
        CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 32, 0.0, 1.0);
      }
      goto LABEL_23;
    case 4:
      v5.n64_u32[0] = 1.0;
      v3.n64_u32[0] = 1051092582;
      v9 = this->m_fTextHeight;
      v10 = CWidget::m_fElapsedTime + this->m_fStateTime;
      this->m_fBackdropAlpha = 1.0;
      v1.n64_f32[0] = v10;
      v1.n64_u64[0] = vmin_f32(v1, v3).n64_u64[0];
      v6.n64_f32[0] = v9 * (float)v8;
      v3.n64_f32[0] = v1.n64_f32[0] / 0.325;
      LODWORD(v11) = vmin_f32(v3, v5).n64_u32[0];
      LODWORD(this->m_fStateTime) = v1.n64_u32[0];
      this->m_fTextAlpha = v11;
LABEL_6:
      if ( v11 != v5.n64_f32[0] )
        goto LABEL_23;
      v12 = 2;
      break;
    case 5:
      v3.n64_u32[0] = 1.0;
      v2.n64_u32[0] = 1051092582;
      v1.n64_f32[0] = CWidget::m_fElapsedTime + this->m_fStateTime;
      v1.n64_u64[0] = vmin_f32(v1, v2).n64_u64[0];
      v2.n64_f32[0] = v1.n64_f32[0] / 0.325;
      v21 = 1.0 - vmin_f32(v2, v3).n64_f32[0];
      this->m_fTextAlpha = v21;
      this->m_fBackdropAlpha = v21;
      LODWORD(this->m_fStateTime) = v1.n64_u32[0];
      if ( v21 == 0.0 )
      {
        this->m_fStateTime = 0.0;
        this->m_nState = 0;
        AsciiToGxtChar((const Char *)&byte_61CADE, this->m_messages[0].m_GxtString);
      }
      goto LABEL_23;
    default:
      goto LABEL_23;
  }
  this->m_fStateTime = 0.0;
  this->m_nState = v12;
LABEL_23:
  v1.n64_u32[0] = LODWORD(this->m_fYOffset);
  if ( v6.n64_f32[0] <= v1.n64_f32[0] )
  {
    if ( v6.n64_f32[0] >= v1.n64_f32[0] )
      goto LABEL_28;
    v1.n64_f32[0] = v1.n64_f32[0] + CWidget::m_fElapsedTime * -0.224999994 * (double)RsGlobal.screenHeight;
    v1.n64_u32[0] = vmax_f32(v6, v1).n64_u32[0];
  }
  else
  {
    v1.n64_f32[0] = CWidget::m_fElapsedTime * 0.224999994 * (double)RsGlobal.screenHeight + v1.n64_f32[0];
    v1.n64_u32[0] = vmin_f32(v6, v1).n64_u32[0];
  }
  LODWORD(this->m_fYOffset) = v1.n64_u32[0];
LABEL_28:
  m_nState = this->m_nState;
  this->m_RectScreen.top = this->m_RectScreen.bottom + v1.n64_f32[0];
  if ( m_nState )
    CWidgetHelpText::RenderTopStyle(this);
}
// 2B73DE: variable 'v1' is possibly undefined
// 2B73DE: variable 'v3' is possibly undefined
// 2B73EA: variable 'v5' is possibly undefined
// 2B7492: variable 'v2' is possibly undefined
// 2B7500: variable 'v4' is possibly undefined
// 2B76EC: variable 'v6' is possibly undefined
// 61CADE: using guessed type char byte_61CADE;

//----- (002B77B0) --------------------------------------------------------
void __fastcall CWidgetHelpText::ProcessMidScreenStyle(CWidgetHelpText *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d2
  float left; // s0
  QueuedMessage *m_messages; // r9
  float right; // s4
  float top; // s2
  float v9; // s8
  float v10; // s6
  float *p_m_fTextAlpha; // r5
  double v12; // d16
  double v13; // d17
  int v14; // r1
  double v15; // d16
  double m_fStateTime; // d17
  float m_fDisplayPeriod; // r0
  float v18; // s0
  float v19; // s2
  double v20; // d16
  double v21; // d17
  int GxtStringLength; // r0
  CRGBA v23; // r0
  float m_fTextHeight; // s20
  float v25; // s20
  float v26; // s24
  float bottom; // s22
  int NumberLines; // r5
  float Height; // r0
  int v30; // r5
  float v31; // r0
  float v32; // s0
  const CRGBA *v33; // r0
  CRGBA v34; // [sp+4h] [bp-64h] BYREF
  CRGBA v35; // [sp+8h] [bp-60h] BYREF
  CRGBA v36; // [sp+Ch] [bp-5Ch] BYREF
  CRGBA v37; // [sp+10h] [bp-58h] BYREF
  CRGBA v38; // [sp+14h] [bp-54h] BYREF

  left = this->m_RectScreen.left;
  m_messages = this->m_messages;
  right = this->m_RectScreen.right;
  top = this->m_RectScreen.top;
  v9 = fabsf(right - left);
  v10 = this->m_RectScreen.bottom + (float)(v9 * 0.025);
  this->m_RectClient.left = left + (float)(v9 * 0.025);
  this->m_RectClient.top = top - (float)(v9 * 0.025);
  this->m_RectClient.right = right - (float)(v9 * 0.025);
  this->m_RectClient.bottom = v10;
  if ( CMessages::GetGxtStringLength(this->m_messages[0].m_GxtString) )
  {
    switch ( this->m_nState )
    {
      case 0:
        this->m_fTextAlpha = 0.0;
        p_m_fTextAlpha = &this->m_fTextAlpha;
        this->m_fBackdropAlpha = 0.0;
        if ( CMessages::GetGxtStringLength(m_messages->m_GxtString) )
        {
          this->m_fStateTime = 0.0;
          this->m_nState = 1;
          goto LABEL_14;
        }
        goto LABEL_22;
      case 1:
        v3.n64_u32[0] = 1.0;
        v2.n64_u32[0] = 1051092582;
        v1.n64_f32[0] = CWidget::m_fElapsedTime + this->m_fStateTime;
        v1.n64_u64[0] = vmin_f32(v1, v2).n64_u64[0];
        v2.n64_f32[0] = v1.n64_f32[0] / 0.325;
        v2.n64_u64[0] = vmin_f32(v2, v3).n64_u64[0];
        LODWORD(this->m_fTextAlpha) = v2.n64_u32[0];
        LODWORD(this->m_fBackdropAlpha) = v2.n64_u32[0];
        LODWORD(this->m_fStateTime) = v1.n64_u32[0];
        goto LABEL_8;
      case 2:
        v15 = CWidget::m_fElapsedTime;
        this->m_fTextAlpha = 1.0;
        p_m_fTextAlpha = &this->m_fTextAlpha;
        v2.n64_u32[0] = LODWORD(this->m_messages[0].m_fDisplayPeriod);
        m_fStateTime = this->m_fStateTime;
        this->m_fBackdropAlpha = 1.0;
        v1.n64_f32[0] = v15 + m_fStateTime;
        v1.n64_u64[0] = vmin_f32(v2, v1).n64_u64[0];
        LODWORD(this->m_fStateTime) = v1.n64_u32[0];
        if ( CTouchInterface::IsReleased(WIDGET_HELP_TEXT, 0, 1) )
        {
          m_fDisplayPeriod = this->m_messages[0].m_fDisplayPeriod;
          this->m_fStateTime = m_fDisplayPeriod;
          v18 = m_fDisplayPeriod;
          v19 = m_fDisplayPeriod;
        }
        else
        {
          v19 = this->m_fStateTime;
          v18 = this->m_messages[0].m_fDisplayPeriod;
        }
        if ( v19 != v18 )
          goto LABEL_22;
        GxtStringLength = CMessages::GetGxtStringLength(this->m_messages[1].m_GxtString);
        v14 = 5;
        if ( GxtStringLength )
          v14 = 3;
        break;
      case 3:
        v3.n64_u32[0] = 1.0;
        p_m_fTextAlpha = &this->m_fTextAlpha;
        v2.n64_u32[0] = 1051092582;
        v20 = this->m_fStateTime;
        v21 = CWidget::m_fElapsedTime;
        this->m_fBackdropAlpha = 1.0;
        v1.n64_f32[0] = v21 + v20;
        v1.n64_u64[0] = vmin_f32(v1, v2).n64_u64[0];
        v2.n64_f32[0] = v1.n64_f32[0] / 0.325;
        v2.n64_u64[0] = vmin_f32(v2, v3).n64_u64[0];
        LODWORD(this->m_fStateTime) = v1.n64_u32[0];
        v2.n64_f32[0] = 1.0 - v2.n64_f32[0];
        LODWORD(this->m_fTextAlpha) = v2.n64_u32[0];
        if ( v2.n64_f32[0] == 0.0 )
        {
          this->m_fStateTime = 0.0;
          this->m_nState = 4;
          qmemcpy(m_messages, &this->m_messages[1], sizeof(QueuedMessage));
          qmemcpy(&this->m_messages[1], &this->m_messages[2], sizeof(this->m_messages[1]));
          qmemcpy(&this->m_messages[2], &this->m_messages[3], sizeof(this->m_messages[2]));
          qmemcpy(&this->m_messages[3], &this->m_messages[4], sizeof(this->m_messages[3]));
          qmemcpy(&this->m_messages[4], &this->m_messages[5], sizeof(this->m_messages[4]));
          qmemcpy(&this->m_messages[5], &this->m_messages[6], sizeof(this->m_messages[5]));
          qmemcpy(&this->m_messages[6], &this->m_messages[7], sizeof(this->m_messages[6]));
          qmemcpy(&this->m_messages[7], &this->m_messages[8], sizeof(this->m_messages[7]));
          qmemcpy(&this->m_messages[8], &this->m_messages[9], sizeof(this->m_messages[8]));
          AsciiToGxtChar((const Char *)&byte_61CADE, this->m_messages[9].m_GxtString);
          this->m_messages[9].m_nStatID = 0;
          this->m_messages[9].m_fDisplayPeriod = 0.0;
          this->m_messages[9].m_fStatRate = 0.0;
          this->m_messages[9].m_fStatMaxValue = 0.0;
          this->m_messages[9].m_nConditionFlag = 0;
LABEL_14:
          CAudioEngine::ReportFrontendAudioEvent(&AudioEngine, 32, 0.0, 1.0);
        }
        goto LABEL_22;
      case 4:
        v3.n64_u32[0] = 1.0;
        v2.n64_u32[0] = 1051092582;
        v12 = this->m_fStateTime;
        v13 = CWidget::m_fElapsedTime;
        this->m_fBackdropAlpha = 1.0;
        v1.n64_f32[0] = v13 + v12;
        v1.n64_u64[0] = vmin_f32(v1, v2).n64_u64[0];
        v2.n64_f32[0] = v1.n64_f32[0] / 0.325;
        v2.n64_u64[0] = vmin_f32(v2, v3).n64_u64[0];
        LODWORD(this->m_fStateTime) = v1.n64_u32[0];
        LODWORD(this->m_fTextAlpha) = v2.n64_u32[0];
LABEL_8:
        p_m_fTextAlpha = &this->m_fTextAlpha;
        if ( v2.n64_f32[0] != v3.n64_f32[0] )
          goto LABEL_22;
        v14 = 2;
        break;
      case 5:
        v3.n64_u32[0] = 1.0;
        p_m_fTextAlpha = &this->m_fTextAlpha;
        v2.n64_u32[0] = 1051092582;
        v1.n64_f32[0] = CWidget::m_fElapsedTime + this->m_fStateTime;
        v1.n64_u64[0] = vmin_f32(v1, v2).n64_u64[0];
        v2.n64_f32[0] = v1.n64_f32[0] / 0.325;
        v2.n64_u64[0] = vmin_f32(v2, v3).n64_u64[0];
        v2.n64_f32[0] = 1.0 - v2.n64_f32[0];
        LODWORD(this->m_fTextAlpha) = v2.n64_u32[0];
        LODWORD(this->m_fBackdropAlpha) = v2.n64_u32[0];
        LODWORD(this->m_fStateTime) = v1.n64_u32[0];
        if ( v2.n64_f32[0] == 0.0 )
        {
          this->m_fStateTime = 0.0;
          this->m_nState = 0;
          AsciiToGxtChar((const Char *)&byte_61CADE, m_messages->m_GxtString);
        }
        goto LABEL_22;
      default:
        p_m_fTextAlpha = &this->m_fTextAlpha;
        goto LABEL_22;
    }
    this->m_fStateTime = 0.0;
    this->m_nState = v14;
LABEL_22:
    CFont::SetProportional(1u);
    CFont::SetOrientation(1u);
    CFont::SetJustify(0);
    CFont::SetFontStyle(1u);
    CFont::SetBackground(0, 0);
    CFont::SetDropShadowPosition(0);
    CRGBA::CRGBA(&v38, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)(*p_m_fTextAlpha * 255.0));
    CFont::SetColor(v23);
    CFont::SetScale(1.0);
    m_fTextHeight = this->m_fTextHeight;
    v1.n64_u32[0] = 1.0;
    v2.n64_u32[0] = CFont::GetHeight(0);
    v25 = (float)(m_fTextHeight / vmax_f32(v2, v1).n64_f32[0]) * 0.75;
    CFont::SetScale(v25);
    if ( this->m_messages[0].m_nStatID )
    {
      CFont::SetWrapx((float)RsGlobal.screenWidth);
      v26 = 2.0;
      bottom = this->m_RectClient.bottom;
    }
    else
    {
      CFont::SetWrapx(this->m_RectClient.right);
      NumberLines = CFont::GetNumberLines(this->m_RectClient.left, this->m_RectClient.bottom, m_messages->m_GxtString);
      Height = CFont::GetHeight(0);
      bottom = this->m_RectClient.bottom;
      v26 = (float)NumberLines;
      if ( (float)(Height * (float)NumberLines) >= fabsf(this->m_RectClient.top - bottom) )
      {
        do
        {
          v25 = v25 * 0.98;
          CFont::SetScale(v25);
          v30 = CFont::GetNumberLines(this->m_RectClient.left, this->m_RectClient.bottom, m_messages->m_GxtString);
          v31 = CFont::GetHeight(0);
          bottom = this->m_RectClient.bottom;
          v26 = (float)v30;
        }
        while ( (float)(v31 * (float)v30) >= fabsf(this->m_RectClient.top - bottom) );
      }
    }
    v32 = bottom + (float)(v26 * CFont::GetHeight(0));
    this->m_RectClient.top = v32;
    this->m_RectScreen.top = (float)(v9 * 0.025) + v32;
    CRGBA::CRGBA(&v37, 0, 0, 0, (unsigned int)(float)(this->m_fBackdropAlpha * 128.0));
    CRGBA::CRGBA(&v36, 0, 0, 0, (unsigned int)(float)(this->m_fBackdropAlpha * 128.0));
    CRGBA::CRGBA(&v35, 0, 0, 0, (unsigned int)(float)(this->m_fBackdropAlpha * 255.0));
    CRGBA::CRGBA(&v34, 0, 0, 0, (unsigned int)(float)(this->m_fBackdropAlpha * 255.0));
    CSprite2d::DrawRect(&this->m_RectScreen, &v37, &v36, &v35, v33);
    if ( this->m_messages[0].m_nStatID )
      CWidgetHelpText::RenderStat(this, this->m_RectClient.left, this->m_RectClient.bottom, 1, v25);
    else
      CFont::PrintString(this->m_RectClient.left, this->m_RectClient.bottom, m_messages->m_GxtString);
  }
}
// 2B7880: variable 'v1' is possibly undefined
// 2B7880: variable 'v2' is possibly undefined
// 2B7888: variable 'v3' is possibly undefined
// 2B7B66: variable 'v23' is possibly undefined
// 2B7D08: variable 'v33' is possibly undefined
// 61CADE: using guessed type char byte_61CADE;

//----- (002B7D84) --------------------------------------------------------
void __fastcall CWidgetHelpText::RenderStat(
        CWidgetHelpText *this,
        float fX,
        float fY,
        int bMidScreenStyle,
        float fTextScale)
{
  float32x2_t v5; // d0
  float32x2_t v6; // d1
  float32x2_t v7; // d2
  float32x2_t v8; // d3
  float32x2_t v9; // d5
  float32x2_t v10; // d10
  unsigned int m_nStatID; // r2
  float v16; // s16
  GxtChar *v17; // r0
  GxtChar *v18; // r2
  float StringWidth; // r0
  float v20; // s0
  float Height; // s22
  float v22; // s0
  float v23; // s0
  float v24; // r1
  float v25; // r0
  int v26; // r0
  CPlayerPed *PlayerPed; // r0
  GxtChar *v28; // r0
  float v29; // r0
  RwInt32 screenWidth; // r11
  float v31; // r0
  float v32; // s22
  float right; // s24
  int v34; // r6
  float m_fTextHeight; // s28
  float m_fStatRate; // s30
  float m_fStatMaxValue; // s17
  float v38; // s4
  float v39; // s20
  CRGBA c2; // [sp+18h] [bp-68h] BYREF
  CRGBA c[25]; // [sp+1Ch] [bp-64h] BYREF

  m_nStatID = this->m_messages[0].m_nStatID;
  if ( m_nStatID > 9 )
  {
    if ( m_nStatID > 0x63 )
      sprintf(gString, "STAT%d");
    else
      sprintf(gString, "STAT0%d");
  }
  else
  {
    sprintf(gString, "STAT00%d");
  }
  v16 = fX;
  v17 = CText::Get(&TheText, gString);
  v18 = v17;
  if ( bMidScreenStyle == 1 )
  {
    StringWidth = CFont::GetStringWidth(v17, 1u, 0);
    v20 = fabsf(this->m_RectClient.right - this->m_RectClient.left);
    if ( StringWidth > v20 )
      CFont::SetScale((float)(v20 / StringWidth) * fTextScale);
    Height = CFont::GetHeight(0);
    v22 = this->m_RectClient.top + this->m_RectClient.bottom;
    v23 = (float)(v22 * 0.5) - CFont::GetHeight(0);
    v18 = CText::Get(&TheText, gString);
    v24 = v23 + (float)(Height * -0.1);
    v25 = fX;
  }
  else
  {
    v25 = fX;
    v24 = fY;
  }
  CFont::PrintString(v25, v24, v18);
  v26 = this->m_messages[0].m_nStatID;
  if ( v26 == 336 )
  {
    PlayerPed = FindPlayerPed(-1);
    v10.n64_f32[0] = (float)CPedGroupMembership::CountMembersExcludingLeader(&CPedGroups::ms_groups[PlayerPed->m_pPlayerData->m_PlayerGroup].m_membership);
  }
  else
  {
    v10.n64_u32[0] = CStats::GetStatValue(v26);
  }
  v28 = CText::Get(&TheText, gString);
  v29 = CFont::GetStringWidth(v28, 1u, 0);
  screenWidth = RsGlobal.screenWidth;
  if ( bMidScreenStyle == 1 )
  {
    v31 = CFont::GetHeight(0);
    screenWidth = RsGlobal.screenWidth;
    v32 = (float)(v31 * 0.1) + (float)((float)(this->m_RectClient.top + this->m_RectClient.bottom) * 0.5);
  }
  else
  {
    v32 = (float)((float)(this->m_RectScreen.top + this->m_RectScreen.bottom) * 0.5)
        + (float)((float)(this->m_fTextHeight * -0.7) * 0.5);
    v16 = (float)(v29 + fX) + (float)((float)((float)RsGlobal.screenWidth / 640.0) * 5.0);
  }
  right = this->m_RectScreen.right;
  AsciiToGxtChar((const Char *)&off_2B80FC, gGxtString);
  v34 = CMessages::GxtStringCompare(gGxtString, this->m_messages[0].m_GxtString, 0x190u);
  m_fTextHeight = this->m_fTextHeight;
  m_fStatRate = this->m_messages[0].m_fStatRate;
  m_fStatMaxValue = this->m_messages[0].m_fStatMaxValue;
  CHudColours::GetRGB(c, &HudColour, 5u, (unsigned int)(float)(this->m_fTextAlpha * 255.0));
  CHudColours::GetRGB(&c2, &HudColour, v34 != 0, (unsigned int)(float)(this->m_fTextAlpha * 255.0));
  v6.n64_f32[0] = m_fStatRate / m_fStatMaxValue;
  v9.n64_u32[0] = 3.0;
  v7.n64_f32[0] = v10.n64_f32[0] / m_fStatMaxValue;
  v5.n64_f32[0] = (float)screenWidth / 640.0;
  v10.n64_u32[0] = 2.0;
  v8.n64_f32[0] = v5.n64_f32[0] * -14.0;
  v5.n64_f32[0] = v5.n64_f32[0] * 75.0;
  v7.n64_f32[0] = v7.n64_f32[0] * 100.0;
  v8.n64_f32[0] = (float)(right - v16) + v8.n64_f32[0];
  LODWORD(v38) = vmax_f32(v7, v10).n64_u32[0];
  v39 = vmin_f32(v5, v8).n64_f32[0];
  CSprite2d::DrawBarChart(
    v16,
    v32,
    (unsigned int)v39,
    (unsigned int)(float)(m_fTextHeight * 0.7),
    v38,
    (int)vmax_f32(v6, v9).n64_f32[0],
    0,
    1,
    (CRGBA)c,
    (CRGBA)&c2);
  CFont::PrintString(
    (float)(v16 + v39)
  + (float)((float)((float)RsGlobal.screenWidth / 640.0) + (float)((float)RsGlobal.screenWidth / 640.0)),
    v32,
    this->m_messages[0].m_GxtString);
}
// 2B8046: variable 'v7' is possibly undefined
// 2B8046: variable 'v10' is possibly undefined
// 2B804A: variable 'v5' is possibly undefined
// 2B804A: variable 'v8' is possibly undefined
// 2B7FFC: variable 'v6' is possibly undefined
// 2B7FFC: variable 'v9' is possibly undefined
// 2B80FC: using guessed type void *off_2B80FC;

//----- (002B8118) --------------------------------------------------------
int __fastcall CWidgetHelpText::SetFontProps(CWidgetHelpText *this, GxtChar *pString)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  CRGBA v6; // r0
  float m_fTextHeight; // s18
  CRGBA v9; // [sp+4h] [bp-1Ch] BYREF

  v2.n64_u32[0] = 0;
  if ( CTouchInterface::m_pWidgets[41] && CTouchInterface::m_pWidgets[41]->m_bCachedEnabled )
    v2.n64_f32[0] = fabsf(
                      CTouchInterface::m_pWidgets[41]->m_RectScreen.right
                    - CTouchInterface::m_pWidgets[41]->m_RectScreen.left);
  CFont::SetWrapx(
    (float)(this->m_RectScreen.right - (float)(fabsf(this->m_RectScreen.right - this->m_RectScreen.left) * 0.0125))
  - v2.n64_f32[0]);
  CFont::SetProportional(1u);
  CFont::SetOrientation(1u);
  CFont::SetJustify(0);
  CFont::SetFontStyle(1u);
  CFont::SetBackground(0, 0);
  CFont::SetDropShadowPosition(0);
  CRGBA::CRGBA(&v9, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)(this->m_fTextAlpha * 255.0));
  CFont::SetColor(v6);
  CFont::SetScale(1.0);
  m_fTextHeight = this->m_fTextHeight;
  v2.n64_u32[0] = 1.0;
  v3.n64_u32[0] = CFont::GetHeight(0);
  CFont::SetScale((float)(m_fTextHeight / vmax_f32(v3, v2).n64_f32[0]) * 0.75);
  return CFont::GetNumberLines(
           this->m_RectScreen.left + (float)(fabsf(this->m_RectScreen.right - this->m_RectScreen.left) * 0.0125),
           this->m_RectScreen.bottom,
           pString);
}
// 2B81BE: variable 'v6' is possibly undefined
// 2B81DC: variable 'v3' is possibly undefined
// 2B81DC: variable 'v2' is possibly undefined

//----- (002B8230) --------------------------------------------------------
void __fastcall CWidgetHelpText::RenderTopStyle(CWidgetHelpText *this)
{
  CRect *p_m_RectScreen; // r0
  __int64 v3; // d17
  int v4; // r6
  float top; // s16
  float Height; // r0
  float v7; // s2
  CRGBA v8; // [sp+Ch] [bp-2Ch] BYREF
  CRect v9; // [sp+10h] [bp-28h] BYREF

  p_m_RectScreen = &this->m_RectScreen;
  v3 = *(_QWORD *)&p_m_RectScreen->right;
  *(_QWORD *)&v9.left = *(_QWORD *)&p_m_RectScreen->left;
  *(_QWORD *)&v9.right = v3;
  CRGBA::CRGBA(&v8, 0, 0, 0, (unsigned int)(float)(this->m_fBackdropAlpha * 255.0));
  CSprite2d::DrawRect(&v9, &v8);
  v4 = CWidgetHelpText::SetFontProps(this, this->m_messages[0].m_GxtString);
  top = this->m_RectScreen.top;
  Height = CFont::GetHeight(0);
  v7 = this->m_RectScreen.left + (float)(fabsf(this->m_RectScreen.right - this->m_RectScreen.left) * 0.0125);
  if ( this->m_messages[0].m_nStatID )
    CWidgetHelpText::RenderStat(this, v7, top + (float)((float)(Height * (float)v4) * -1.2), 0, 1.0);
  else
    CFont::PrintString(v7, top + (float)((float)(Height * (float)v4) * -1.2), this->m_messages[0].m_GxtString);
}

//----- (002B831C) --------------------------------------------------------
void __fastcall CWidgetHelpText::Visualize(CWidgetHelpText *this)
{
  CRGBA v2; // [sp+8h] [bp-18h] BYREF
  CRGBA v3; // [sp+Ch] [bp-14h] BYREF

  CRGBA::CRGBA(&v3, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
  CSprite2d::DrawRect(&this->m_RectScreen, &v3);
  CRGBA::CRGBA(&v2, 0x80u, 0x80u, 0x80u, 0xFFu);
  CSprite2d::DrawRect(&this->m_RectClient, &v2);
}

//----- (002B8366) --------------------------------------------------------
int __fastcall CWidgetHelpText::GetNumQueuedMessages(CWidgetHelpText *this)
{
  int GxtStringLength; // r6
  int v3; // r5

  GxtStringLength = CMessages::GetGxtStringLength(this->m_messages[0].m_GxtString);
  v3 = CMessages::GetGxtStringLength(this->m_messages[1].m_GxtString) != 0;
  if ( GxtStringLength )
    ++v3;
  if ( CMessages::GetGxtStringLength(this->m_messages[2].m_GxtString) )
    ++v3;
  if ( CMessages::GetGxtStringLength(this->m_messages[3].m_GxtString) )
    ++v3;
  if ( CMessages::GetGxtStringLength(this->m_messages[4].m_GxtString) )
    ++v3;
  if ( CMessages::GetGxtStringLength(this->m_messages[5].m_GxtString) )
    ++v3;
  if ( CMessages::GetGxtStringLength(this->m_messages[6].m_GxtString) )
    ++v3;
  if ( CMessages::GetGxtStringLength(this->m_messages[7].m_GxtString) )
    ++v3;
  if ( CMessages::GetGxtStringLength(this->m_messages[8].m_GxtString) )
    ++v3;
  if ( CMessages::GetGxtStringLength(this->m_messages[9].m_GxtString) )
    ++v3;
  return v3;
}

//----- (002B8414) --------------------------------------------------------
void __fastcall CWidgetHelpText::ConditionSatisfied(unsigned int nConditionFlag)
{
  CWidgetHelpText *v1; // r1

  v1 = CWidgetHelpText::m_pInstance;
  if ( CWidgetHelpText::m_pInstance )
  {
    if ( CWidgetHelpText::m_pInstance->m_messages[0].m_nConditionFlag == nConditionFlag )
      CWidgetHelpText::m_pInstance->m_messages[0].m_fDisplayPeriod = 5.0;
    if ( v1->m_messages[1].m_nConditionFlag == nConditionFlag )
      v1->m_messages[1].m_fDisplayPeriod = 5.0;
    if ( v1->m_messages[2].m_nConditionFlag == nConditionFlag )
      v1->m_messages[2].m_fDisplayPeriod = 5.0;
    if ( v1->m_messages[3].m_nConditionFlag == nConditionFlag )
      v1->m_messages[3].m_fDisplayPeriod = 5.0;
    if ( v1->m_messages[4].m_nConditionFlag == nConditionFlag )
      v1->m_messages[4].m_fDisplayPeriod = 5.0;
    if ( v1->m_messages[5].m_nConditionFlag == nConditionFlag )
      v1->m_messages[5].m_fDisplayPeriod = 5.0;
    if ( v1->m_messages[6].m_nConditionFlag == nConditionFlag )
      v1->m_messages[6].m_fDisplayPeriod = 5.0;
    if ( v1->m_messages[7].m_nConditionFlag == nConditionFlag )
      v1->m_messages[7].m_fDisplayPeriod = 5.0;
    if ( v1->m_messages[8].m_nConditionFlag == nConditionFlag )
      v1->m_messages[8].m_fDisplayPeriod = 5.0;
    if ( v1->m_messages[9].m_nConditionFlag == nConditionFlag )
      v1->m_messages[9].m_fDisplayPeriod = 5.0;
  }
}

//----- (002B84F4) --------------------------------------------------------
void __fastcall CWidgetHelpText::ConditionSatisfiedInstance(CWidgetHelpText *this, unsigned int nConditionFlag)
{
  if ( this->m_messages[0].m_nConditionFlag == nConditionFlag )
    this->m_messages[0].m_fDisplayPeriod = 5.0;
  if ( this->m_messages[1].m_nConditionFlag == nConditionFlag )
    this->m_messages[1].m_fDisplayPeriod = 5.0;
  if ( this->m_messages[2].m_nConditionFlag == nConditionFlag )
    this->m_messages[2].m_fDisplayPeriod = 5.0;
  if ( this->m_messages[3].m_nConditionFlag == nConditionFlag )
    this->m_messages[3].m_fDisplayPeriod = 5.0;
  if ( this->m_messages[4].m_nConditionFlag == nConditionFlag )
    this->m_messages[4].m_fDisplayPeriod = 5.0;
  if ( this->m_messages[5].m_nConditionFlag == nConditionFlag )
    this->m_messages[5].m_fDisplayPeriod = 5.0;
  if ( this->m_messages[6].m_nConditionFlag == nConditionFlag )
    this->m_messages[6].m_fDisplayPeriod = 5.0;
  if ( this->m_messages[7].m_nConditionFlag == nConditionFlag )
    this->m_messages[7].m_fDisplayPeriod = 5.0;
  if ( this->m_messages[8].m_nConditionFlag == nConditionFlag )
    this->m_messages[8].m_fDisplayPeriod = 5.0;
  if ( this->m_messages[9].m_nConditionFlag == nConditionFlag )
    this->m_messages[9].m_fDisplayPeriod = 5.0;
}

//----- (002B85C4) --------------------------------------------------------
void __fastcall CWidgetHelpText::ClearQueue(CWidgetHelpText *this, bool bHardReset)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  _BOOL4 v4; // r8

  v4 = bHardReset;
  AsciiToGxtChar((const Char *)&byte_61CADE, this->m_messages[1].m_GxtString);
  this->m_messages[1].m_nStatID = 0;
  this->m_messages[1].m_fDisplayPeriod = 0.0;
  this->m_messages[1].m_fStatRate = 0.0;
  this->m_messages[1].m_fStatMaxValue = 0.0;
  this->m_messages[1].m_nConditionFlag = 0;
  AsciiToGxtChar((const Char *)&byte_61CADE, this->m_messages[2].m_GxtString);
  this->m_messages[2].m_nStatID = 0;
  this->m_messages[2].m_fDisplayPeriod = 0.0;
  this->m_messages[2].m_fStatRate = 0.0;
  this->m_messages[2].m_fStatMaxValue = 0.0;
  this->m_messages[2].m_nConditionFlag = 0;
  AsciiToGxtChar((const Char *)&byte_61CADE, this->m_messages[3].m_GxtString);
  this->m_messages[3].m_nStatID = 0;
  this->m_messages[3].m_fDisplayPeriod = 0.0;
  this->m_messages[3].m_fStatRate = 0.0;
  this->m_messages[3].m_fStatMaxValue = 0.0;
  this->m_messages[3].m_nConditionFlag = 0;
  AsciiToGxtChar((const Char *)&byte_61CADE, this->m_messages[4].m_GxtString);
  this->m_messages[4].m_nStatID = 0;
  this->m_messages[4].m_fDisplayPeriod = 0.0;
  this->m_messages[4].m_fStatRate = 0.0;
  this->m_messages[4].m_fStatMaxValue = 0.0;
  this->m_messages[4].m_nConditionFlag = 0;
  AsciiToGxtChar((const Char *)&byte_61CADE, this->m_messages[5].m_GxtString);
  this->m_messages[5].m_nStatID = 0;
  this->m_messages[5].m_fDisplayPeriod = 0.0;
  this->m_messages[5].m_fStatRate = 0.0;
  this->m_messages[5].m_fStatMaxValue = 0.0;
  this->m_messages[5].m_nConditionFlag = 0;
  AsciiToGxtChar((const Char *)&byte_61CADE, this->m_messages[6].m_GxtString);
  this->m_messages[6].m_nStatID = 0;
  this->m_messages[6].m_fDisplayPeriod = 0.0;
  this->m_messages[6].m_fStatRate = 0.0;
  this->m_messages[6].m_fStatMaxValue = 0.0;
  this->m_messages[6].m_nConditionFlag = 0;
  AsciiToGxtChar((const Char *)&byte_61CADE, this->m_messages[7].m_GxtString);
  this->m_messages[7].m_nStatID = 0;
  this->m_messages[7].m_fDisplayPeriod = 0.0;
  this->m_messages[7].m_fStatRate = 0.0;
  this->m_messages[7].m_fStatMaxValue = 0.0;
  this->m_messages[7].m_nConditionFlag = 0;
  AsciiToGxtChar((const Char *)&byte_61CADE, this->m_messages[8].m_GxtString);
  this->m_messages[8].m_nStatID = 0;
  this->m_messages[8].m_fDisplayPeriod = 0.0;
  this->m_messages[8].m_fStatRate = 0.0;
  this->m_messages[8].m_fStatMaxValue = 0.0;
  this->m_messages[8].m_nConditionFlag = 0;
  AsciiToGxtChar((const Char *)&byte_61CADE, this->m_messages[9].m_GxtString);
  this->m_messages[9].m_nStatID = 0;
  this->m_messages[9].m_fDisplayPeriod = 0.0;
  this->m_messages[9].m_fStatRate = 0.0;
  this->m_messages[9].m_fStatMaxValue = 0.0;
  this->m_messages[9].m_nConditionFlag = 0;
  if ( v4 || !CMessages::GetGxtStringLength(this->m_messages[0].m_GxtString) )
  {
    AsciiToGxtChar((const Char *)&byte_61CADE, this->m_messages[0].m_GxtString);
    this->m_messages[0].m_nStatID = 0;
    this->m_messages[0].m_fDisplayPeriod = 0.0;
    this->m_messages[0].m_fStatRate = 0.0;
    this->m_messages[0].m_fStatMaxValue = 0.0;
    this->m_messages[0].m_nConditionFlag = 0;
    this->m_fStateTime = 0.0;
    this->m_nState = 0;
  }
  else if ( this->m_nState == 2 )
  {
    v3.n64_u32[0] = LODWORD(this->m_fStateTime);
    v2.n64_f32[0] = this->m_messages[0].m_fDisplayPeriod + -0.125;
    LODWORD(this->m_fStateTime) = vmax_f32(v3, v2).n64_u32[0];
  }
  else
  {
    this->m_messages[0].m_fDisplayPeriod = 0.125;
  }
}
// 2B8754: variable 'v3' is possibly undefined
// 2B8754: variable 'v2' is possibly undefined
// 61CADE: using guessed type char byte_61CADE;

//----- (002B879C) --------------------------------------------------------
void __fastcall CWidgetHelpText::Update(CWidgetHelpText *this)
{
  CTouchInterface::WidgetPositionIDs v2; // r0

  if ( CWidgetHelpText::UseTopStyle(this) )
    v2 = WIDGET_POSITION_HELP_TEXT;
  else
    v2 = WIDGET_POSITION_HELP_TEXT_ALT;
  CTouchInterface::GetWidgetPosition(v2, &this->m_fOriginX, &this->m_fOriginY, &this->m_fScaleX, &this->m_fScaleY);
  sub_18E400(this);
}

//----- (002B87D4) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetHelpText::GetName(CWidgetHelpText *this)
{
  return "Help";
}

//----- (002B87E0) --------------------------------------------------------
void __fastcall CWidgetHorseResults::CWidgetHorseResults(
        CWidgetHorseResults *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  int v3; // r0

  CWidget::CWidget(this, pszSprite, WidgetPos, 0x14u, HID_MAPPING_UNKNOWN);
  *(_BYTE *)(v3 + 144) = 0;
  *(_BYTE *)(v3 + 272) = 0;
  *(_DWORD *)(v3 + 400) = 0;
  *(_DWORD *)(v3 + 409) = 0;
  *(_DWORD *)(v3 + 405) = 0;
  *(_DWORD *)(v3 + 404) = 0;
  *(_BYTE *)(v3 + 540) = 0;
  *(_DWORD *)(v3 + 673) = 0;
  *(_DWORD *)(v3 + 668) = 0;
  *(_DWORD *)(v3 + 672) = 0;
  *(_DWORD *)v3 = &off_663CE0;
  *(_DWORD *)(v3 + 677) = 0;
  *(_BYTE *)(v3 + 808) = 0;
  *(_DWORD *)(v3 + 936) = 0;
  *(_DWORD *)(v3 + 940) = 0;
  *(_DWORD *)(v3 + 945) = 0;
  *(_DWORD *)(v3 + 941) = 0;
  *(_BYTE *)(v3 + 1076) = 0;
  *(_DWORD *)(v3 + 1204) = 0;
  *(_DWORD *)(v3 + 1208) = 0;
  *(_DWORD *)(v3 + 1213) = 0;
  *(_DWORD *)(v3 + 1209) = 0;
  *(_BYTE *)(v3 + 1344) = 0;
  *(_DWORD *)(v3 + 1472) = 0;
  *(_DWORD *)(v3 + 1476) = 0;
  *(_DWORD *)(v3 + 1481) = 0;
  *(_DWORD *)(v3 + 1477) = 0;
  *(_BYTE *)(v3 + 1612) = 0;
  *(_DWORD *)(v3 + 1740) = 0;
  *(_DWORD *)(v3 + 1744) = 0;
  *(_DWORD *)(v3 + 1749) = 0;
  *(_DWORD *)(v3 + 1745) = 0;
  *(_BYTE *)(v3 + 1880) = 0;
  *(_DWORD *)(v3 + 2008) = 0;
  *(_DWORD *)(v3 + 2012) = 0;
  *(_DWORD *)(v3 + 2016) = 0;
}
// 2B87F2: variable 'v3' is possibly undefined
// 663CE0: using guessed type void *;

//----- (002B8888) --------------------------------------------------------
void __fastcall CWidgetHorseResults::Update(CWidgetHorseResults *this)
{
  CWidget::Update(this);
  sub_19751C(this);
}

//----- (002B889C) --------------------------------------------------------
void __fastcall CWidgetHorseResults::Draw(CWidgetHorseResults *this)
{
  CWidgetHorseResults *v1; // r4
  unsigned int v2; // r9
  SDataCell *m_DataCell; // r5
  int v4; // r8
  float top; // s16
  float bottom; // s18
  float v7; // s20
  CRGBA v8; // r0
  float v9; // s16
  float v10; // s18
  int v11; // r6
  float left; // s24
  float right; // s26
  float v14; // s24
  GxtChar *v15; // r0
  float StringWidth; // r0
  int *p_m_nIntegerValue0; // r8
  unsigned int v18; // r6
  float v19; // s24
  float v20; // r0
  bool v21; // zf
  float v22; // r1
  const CRGBA *v23; // r0
  int v24; // r0
  float v25; // s6
  CRGBA v26; // r0
  float v27; // s27
  float v28; // s26
  float v29; // s17
  float v30; // s26
  GxtChar *v31; // r0
  const char *v32; // r1
  GxtChar *v33; // r0
  GxtChar *v34; // r0
  CRGBA v35; // r0
  float v36; // s26
  float v37; // s17
  float v38; // s27
  float Height; // r0
  float v40; // s0
  GxtChar *v41; // r0
  GxtChar *v42; // r0
  GxtChar *v43; // r0
  float v44; // s26
  float v45; // s17
  float v46; // s27
  float v47; // r0
  CWidgetHorseResults *v48; // [sp+30h] [bp-5B0h]
  unsigned int alpha; // [sp+34h] [bp-5ACh]
  unsigned int v50; // [sp+38h] [bp-5A8h]
  unsigned int v51; // [sp+3Ch] [bp-5A4h]
  CRGBA v52; // [sp+40h] [bp-5A0h] BYREF
  CRGBA v53; // [sp+44h] [bp-59Ch] BYREF
  CRGBA v54; // [sp+244h] [bp-39Ch] BYREF
  CRect v55; // [sp+248h] [bp-398h] BYREF
  CRGBA v56; // [sp+25Ch] [bp-384h] BYREF
  CRGBA v57; // [sp+260h] [bp-380h] BYREF
  CRect Rectangle; // [sp+264h] [bp-37Ch] BYREF
  GxtChar Dest[256]; // [sp+274h] [bp-36Ch] BYREF
  CRGBA v60; // [sp+474h] [bp-16Ch] BYREF
  Char aStr[256]; // [sp+478h] [bp-168h] BYREF

  v1 = this;
  v2 = this->m_Color._anon_0._anon_0.alpha;
  if ( this->m_Color._anon_0._anon_0.alpha )
  {
    m_DataCell = this->m_DataCell;
    if ( strlen((const char *)this->m_DataCell) )
      v4 = strcasecmp((const char *)v1->m_DataCell, "DUMMY") != 0;
    else
      v4 = 0;
    if ( strlen((const char *)&v1->m_DataCell[1]) && strcasecmp((const char *)&v1->m_DataCell[1], "DUMMY") )
      ++v4;
    if ( strlen((const char *)&v1->m_DataCell[2]) && strcasecmp((const char *)&v1->m_DataCell[2], "DUMMY") )
      ++v4;
    if ( strlen((const char *)&v1->m_DataCell[3]) && strcasecmp((const char *)&v1->m_DataCell[3], "DUMMY") )
      ++v4;
    if ( strlen((const char *)&v1->m_DataCell[4]) && strcasecmp((const char *)&v1->m_DataCell[4], "DUMMY") )
      ++v4;
    if ( strlen((const char *)&v1->m_DataCell[5]) && strcasecmp((const char *)&v1->m_DataCell[5], "DUMMY") )
      ++v4;
    if ( strlen((const char *)&v1->m_DataCell[6]) && strcasecmp((const char *)&v1->m_DataCell[6], "DUMMY") )
      ++v4;
    if ( v4 == 7 )
    {
      top = v1->m_RectScreen.top;
      bottom = v1->m_RectScreen.bottom;
      CFont::SetBackground(0, 0);
      CFont::SetProportional(1u);
      CFont::SetOrientation(1u);
      CFont::SetRightJustifyWrap(0.0);
      CFont::SetEdge(0);
      v7 = (float)v2 / 255.0;
      alpha = (unsigned int)(float)(v7 * 255.0);
      CRGBA::CRGBA(&v60, 0, 0, 0, alpha);
      CFont::SetDropColor(v8);
      CFont::SetWrapx((float)RsGlobal.screenWidth);
      CFont::SetFontStyle(2u);
      v9 = (float)(fabsf(top - bottom) + -6.0) * 0.125;
      v10 = v9 * 0.021;
      CFont::SetScale(v9 * 0.021);
      v11 = -1;
      do
      {
        left = v1->m_RectScreen.left;
        right = v1->m_RectScreen.right;
        if ( strlen((const char *)m_DataCell) )
        {
          if ( strcasecmp((const char *)m_DataCell, "DUMMY") )
          {
            v14 = fabsf(right - left) * 0.625;
            v15 = CText::Get(&TheText, m_DataCell->m_szLabel);
            StringWidth = CFont::GetStringWidth(v15, 1u, 0);
            if ( StringWidth > v14 )
            {
              v10 = v10 * (float)(v14 / StringWidth);
              CFont::SetScale(v10);
            }
          }
        }
        ++v11;
        ++m_DataCell;
      }
      while ( v11 < 6 );
      p_m_nIntegerValue0 = &v1->m_DataCell[0].m_nIntegerValue0;
      v18 = -1;
      v50 = (unsigned int)(float)(v7 * 128.0);
      v19 = v1->m_RectScreen.bottom;
      v48 = v1;
      do
      {
        v20 = v1->m_RectScreen.left;
        v21 = v18 == 5;
        v22 = v1->m_RectScreen.right;
        Rectangle.bottom = v19;
        Rectangle.left = v20;
        Rectangle.right = v22;
        Rectangle.top = v9 + v19;
        if ( v18 != 5 )
          v21 = v18 == -1;
        if ( v21 )
        {
          Rectangle.left = v20;
          Rectangle.right = v22;
          Rectangle.bottom = v19;
          Rectangle.top = (float)(v9 * 1.5) + v19;
        }
        v51 = v18 + 1;
        CRGBA::CRGBA(&v53, 0, 0, 0, v50);
        CRGBA::CRGBA((CRGBA *)&v55, 0, 0, 0, v50);
        CRGBA::CRGBA(&v57, 0, 0, 0, alpha);
        CRGBA::CRGBA(&v56, 0, 0, 0, alpha);
        CSprite2d::DrawRect(&Rectangle, &v53, (const CRGBA *)&v55, &v57, v23);
        memset(&v55, 0, sizeof(v55));
        if ( v18 > 4 )
        {
          v33 = CText::Get(&TheText, (const unsigned __int8 *)p_m_nIntegerValue0 - 256);
          GxtCharStrcpy(Dest, v33);
          strcpy((char *)aStr, "~g~ ");
          AsciiToGxtChar(aStr, (GxtChar *)&v53);
          GxtCharStrcat(Dest, (GxtChar *)&v53);
          v34 = CText::Get(&TheText, "DOLLAR");
          GxtCharStrcat(Dest, v34);
          sprintf(aStr, "%d", *p_m_nIntegerValue0);
          AsciiToGxtChar(aStr, (GxtChar *)&v53);
          GxtCharStrcat(Dest, (GxtChar *)&v53);
          CFont::SetScale(v10 * 1.5);
          CRGBA::CRGBA(&v52, 0xFFu, 0xFFu, 0xFFu, alpha);
          CFont::SetColor(v35);
          CFont::SetOrientation(0);
          v36 = Rectangle.left;
          v37 = Rectangle.right;
          v38 = Rectangle.top + Rectangle.bottom;
          Height = CFont::GetHeight(0);
          CFont::PrintString((float)(v36 + v37) * 0.5, (float)(v38 * 0.5) - (float)(Height * 0.5), Dest);
          CFont::RenderFontBuffer();
          v1 = v48;
          ++v18;
          if ( v51 != 6 )
            goto LABEL_47;
          goto LABEL_60;
        }
        v24 = *p_m_nIntegerValue0;
        if ( !*p_m_nIntegerValue0 )
        {
          CRGBA::CRGBA(&v57, 0x2Au, 0x60u, 0xE4u, alpha);
          v53 = v57;
          v24 = *p_m_nIntegerValue0;
        }
        v1 = v48;
        ++v18;
        if ( v24 == 1 )
        {
          CRGBA::CRGBA(&v57, 0xD1u, 0x74u, 0x74u, alpha);
          v53 = v57;
          v24 = *p_m_nIntegerValue0;
          if ( *p_m_nIntegerValue0 != 2 )
          {
LABEL_41:
            if ( v24 != 3 )
              goto LABEL_42;
            goto LABEL_52;
          }
        }
        else if ( v24 != 2 )
        {
          goto LABEL_41;
        }
        CRGBA::CRGBA(&v57, 0xDEu, 0xB9u, 0x67u, alpha);
        v53 = v57;
        v24 = *p_m_nIntegerValue0;
        if ( *p_m_nIntegerValue0 != 3 )
        {
LABEL_42:
          if ( v24 != 4 )
            goto LABEL_44;
LABEL_43:
          CRGBA::CRGBA(&v57, 0x41u, 0xBEu, 0x97u, alpha);
          v53 = v57;
          goto LABEL_44;
        }
LABEL_52:
        CRGBA::CRGBA(&v57, 0x85u, 0x41u, 0xBEu, alpha);
        v53 = v57;
        if ( *p_m_nIntegerValue0 == 4 )
          goto LABEL_43;
LABEL_44:
        v25 = fabsf(Rectangle.top - Rectangle.bottom);
        v55.left = Rectangle.left + (float)(v25 * 0.15);
        v55.top = Rectangle.top - (float)(v25 * 0.15);
        v55.bottom = Rectangle.bottom + (float)(v25 * 0.15);
        v55.right = v55.left + (float)(v25 + (float)((float)(v25 * 0.15) * -2.0));
        CSprite2d::DrawRect(&v55, &v53);
        CFont::SetScale(v10);
        CFont::SetOrientation(1u);
        CRGBA::CRGBA(&v54, 0xFFu, 0xFFu, 0xFFu, alpha);
        CFont::SetColor(v26);
        v27 = v55.right;
        v28 = Rectangle.top + Rectangle.bottom;
        v29 = fabsf(v48->m_RectScreen.right - v48->m_RectScreen.left);
        v30 = (float)(v28 * 0.5) - (float)(CFont::GetHeight(0) * 0.5);
        v31 = CText::Get(&TheText, (const unsigned __int8 *)p_m_nIntegerValue0 - 256);
        CFont::PrintString(v27 + (float)(v29 * 0.03), v30, v31);
        switch ( v51 )
        {
          case 1u:
            v32 = "FIRST";
            goto LABEL_56;
          case 2u:
            v32 = "SECOND";
            goto LABEL_56;
          case 3u:
            v32 = "THIRD";
LABEL_56:
            v41 = CText::Get(&TheText, (const unsigned __int8 *)v32);
            GxtCharStrcpy(Dest, v41);
            break;
          case 4u:
            v42 = CText::Get(&TheText, (const unsigned __int8 *)&dword_2B9010);
            CMessages::InsertNumberInString(v42, 4, -1, -1, -1, -1, -1, Dest);
            break;
          case 5u:
            v43 = CText::Get(&TheText, (const unsigned __int8 *)&dword_2B9010);
            CMessages::InsertNumberInString(v43, 5, -1, -1, -1, -1, -1, Dest);
            break;
          default:
            break;
        }
        CFont::SetOrientation(2u);
        v44 = Rectangle.right;
        v45 = Rectangle.top + Rectangle.bottom;
        v46 = fabsf(Rectangle.right - Rectangle.left);
        v47 = CFont::GetHeight(0);
        CFont::PrintString(v44 + (float)(v46 * -0.03), (float)(v45 * 0.5) - (float)(v47 * 0.5), Dest);
        CFont::RenderFontBuffer();
        if ( v51 != 6 )
        {
LABEL_47:
          v40 = v9;
          if ( !v18 )
            v40 = v9 * 1.5;
          goto LABEL_61;
        }
LABEL_60:
        v40 = v9 * 1.5;
LABEL_61:
        p_m_nIntegerValue0 += 67;
        v19 = v19 + (float)(v40 + 1.0);
      }
      while ( v18 != 6 );
    }
  }
}
// 2B8A04: variable 'v8' is possibly undefined
// 2B8BD4: variable 'v23' is possibly undefined
// 2B8CD6: variable 'v26' is possibly undefined
// 2B8DDE: variable 'v35' is possibly undefined
// 2B9010: using guessed type int dword_2B9010;

//----- (002B9040) --------------------------------------------------------
void __fastcall CWidgetHorseResults::SetWidgetInfo2(
        CWidgetHorseResults *this,
        int nValue0,
        int nValue1,
        int nValue2,
        int nValue3,
        unsigned __int8 *pszText0,
        unsigned __int8 *pszText1)
{
  const char *v11; // r1
  const char *v12; // r5
  _DWORD v13[67]; // [sp+0h] [bp-130h] BYREF

  if ( (unsigned int)nValue0 <= 6 )
  {
    v11 = (const char *)pszText0;
    v12 = &byte_61CADE;
    if ( !pszText0 )
      v11 = &byte_61CADE;
    strcpy((char *)v13, v11);
    if ( pszText1 )
      v12 = (const char *)pszText1;
    strcpy((char *)&v13[32], v12);
    v13[64] = nValue1;
    v13[65] = nValue2;
    v13[66] = nValue3;
    qmemcpy(&this->m_DataCell[nValue0], v13, sizeof(this->m_DataCell[nValue0]));
  }
}
// 61CADE: using guessed type char byte_61CADE;

//----- (002B90CC) --------------------------------------------------------
void __fastcall CWidgetHorseResults::~CWidgetHorseResults(CWidgetHorseResults *this)
{
  void *v1; // r0

  CWidget::~CWidget(this);
  sub_191374(v1);
}
// 2B90D8: variable 'v1' is possibly undefined

//----- (002B90DC) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetHorseResults::GetName(CWidgetHorseResults *this)
{
  return "Horse Results";
}

//----- (002B90F0) --------------------------------------------------------
void __fastcall CWidgetInfoFrame::CWidgetInfoFrame(
        CWidgetInfoFrame *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  int v3; // r0
  CWidgetInfoFrame *v4; // r2
  CWidgetInfoFrame **p_m_pNext; // r3

  CWidget::CWidget(this, pszSprite, WidgetPos, 0x14u, HID_MAPPING_UNKNOWN);
  *(_DWORD *)v3 = &off_663D74;
  v4 = CWidgetInfoFrame::m_pChainTail;
  *(_DWORD *)(v3 + 144) = CWidgetInfoFrame::m_pChainTail;
  *(_DWORD *)(v3 + 148) = 0;
  p_m_pNext = &v4->m_pNext;
  if ( !v4 )
    p_m_pNext = &CWidgetInfoFrame::m_pChainHead;
  *p_m_pNext = (CWidgetInfoFrame *)v3;
  CWidgetInfoFrame::m_pChainTail = (CWidgetInfoFrame *)v3;
  *(_DWORD *)(v3 + 164) = 0;
  *(_DWORD *)(v3 + 168) = 0;
  *(_DWORD *)(v3 + 172) = 0;
  *(_BYTE *)(v3 + 152) = 0;
}
// 2B9114: variable 'v3' is possibly undefined
// 663D74: using guessed type void *off_663D74;

//----- (002B9148) --------------------------------------------------------
void __fastcall CWidgetInfoFrame::~CWidgetInfoFrame(CWidgetInfoFrame *this)
{
  __int64 v1; // kr00_8
  CWidgetInfoFrame **v2; // r1
  __int64 v3; // kr08_8
  CWidgetInfoFrame **v4; // r3

  v1 = *(_QWORD *)&this->m_pPrev;
  this->_vptr$CWidget = (int (**)(void))&off_663D74;
  v2 = (CWidgetInfoFrame **)(v1 + 148);
  if ( !(_DWORD)v1 )
    v2 = &CWidgetInfoFrame::m_pChainHead;
  *v2 = (CWidgetInfoFrame *)HIDWORD(v1);
  v3 = *(_QWORD *)&this->m_pPrev;
  v4 = (CWidgetInfoFrame **)(HIDWORD(v3) + 144);
  if ( !HIDWORD(v3) )
    v4 = &CWidgetInfoFrame::m_pChainTail;
  *v4 = (CWidgetInfoFrame *)v3;
  sub_19C514(this);
}
// 663D74: using guessed type void *;

//----- (002B919C) --------------------------------------------------------
void __fastcall CWidgetInfoFrame::~CWidgetInfoFrame(CWidgetInfoFrame *this)
{
  __int64 v1; // kr00_8
  CWidgetInfoFrame **v2; // r1
  __int64 v3; // kr08_8
  CWidgetInfoFrame **v4; // r3
  void *v5; // r0

  v1 = *(_QWORD *)&this->m_pPrev;
  this->_vptr$CWidget = (int (**)(void))&off_663D74;
  v2 = (CWidgetInfoFrame **)(v1 + 148);
  if ( !(_DWORD)v1 )
    v2 = &CWidgetInfoFrame::m_pChainHead;
  *v2 = (CWidgetInfoFrame *)HIDWORD(v1);
  v3 = *(_QWORD *)&this->m_pPrev;
  v4 = (CWidgetInfoFrame **)(HIDWORD(v3) + 144);
  if ( !HIDWORD(v3) )
    v4 = &CWidgetInfoFrame::m_pChainTail;
  *v4 = (CWidgetInfoFrame *)v3;
  CWidget::~CWidget(this);
  sub_191374(v5);
}
// 2B91E4: variable 'v5' is possibly undefined
// 663D74: using guessed type void *off_663D74;

//----- (002B91F4) --------------------------------------------------------
void __fastcall CWidgetInfoFrame::Update(CWidgetInfoFrame *this)
{
  if ( CHud::bDrawingVitalStats )
    CWidget::SetEnabled(this, 0);
  CWidget::Update(this);
  sub_19751C(this);
}

//----- (002B9224) --------------------------------------------------------
void __fastcall CWidgetInfoFrame::Draw(CWidgetInfoFrame *this)
{
  unsigned int alpha; // r5
  float top; // s16
  float bottom; // s18
  float v5; // s20
  CRGBA v6; // r0
  CRGBA v7; // r0
  float v8; // s22
  float v9; // s16
  float v10; // s24
  GxtChar *v11; // r0
  float StringWidth; // r0
  float left; // r0
  float right; // r1
  const CRGBA *v15; // r0
  int m_nValue; // r2
  CRGBA v17; // [sp+10h] [bp-168h] BYREF
  CRGBA v18; // [sp+14h] [bp-164h] BYREF
  CRGBA v19; // [sp+18h] [bp-160h] BYREF
  CRect Rectangle; // [sp+1Ch] [bp-15Ch] BYREF
  CRGBA v21; // [sp+2Ch] [bp-14Ch] BYREF
  CRGBA v22; // [sp+30h] [bp-148h] BYREF
  CRGBA v23; // [sp+34h] [bp-144h] BYREF

  alpha = this->m_Color._anon_0._anon_0.alpha;
  if ( this->m_Color._anon_0._anon_0.alpha )
  {
    top = this->m_RectScreen.top;
    bottom = this->m_RectScreen.bottom;
    CFont::SetBackground(0, 0);
    CFont::SetProportional(1u);
    CFont::SetFontStyle(2u);
    CFont::SetOrientation(1u);
    CFont::SetRightJustifyWrap(0.0);
    CFont::SetEdge(0);
    v5 = (float)alpha / 255.0;
    CRGBA::CRGBA(&v22, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)(v5 * 255.0));
    CFont::SetColor(v6);
    CRGBA::CRGBA(&v21, 0, 0, 0, (unsigned int)(float)(v5 * 255.0));
    CFont::SetDropColor(v7);
    v8 = fabsf(top - bottom);
    v9 = v8 * 0.02;
    CFont::SetScale(v8 * 0.02);
    v10 = fabsf(this->m_RectScreen.right - this->m_RectScreen.left) * 0.6125;
    v11 = CText::Get(&TheText, this->TextLabel);
    StringWidth = CFont::GetStringWidth(v11, 1u, 0);
    if ( StringWidth > v10 )
    {
      v9 = v9 * (float)(v10 / StringWidth);
      CFont::SetScale(v9);
    }
    left = this->m_RectScreen.left;
    right = this->m_RectScreen.right;
    Rectangle.bottom = bottom;
    Rectangle.left = left;
    Rectangle.right = right;
    Rectangle.top = bottom + v8;
    CRGBA::CRGBA(&v23, 0, 0, 0, (unsigned int)(float)(v5 * 100.0));
    CRGBA::CRGBA(&v19, 0, 0, 0, (unsigned int)(float)(v5 * 100.0));
    CRGBA::CRGBA(&v18, 0, 0, 0, (unsigned int)(float)(v5 * 255.0));
    CRGBA::CRGBA(&v17, 0, 0, 0, (unsigned int)(float)(v5 * 255.0));
    CSprite2d::DrawRect(&Rectangle, &v23, &v19, &v18, v15);
    CText::Get(&TheText, this->TextLabel);
    if ( this->m_bIsTime )
    {
      sprintf((unsigned __int8 *)&v23, "%d:%.2d", this->m_nValue / 60, this->m_nValue % 60);
    }
    else
    {
      m_nValue = this->m_nValue;
      if ( this->m_bIsPercentage )
        sprintf((unsigned __int8 *)&v23, "%d%%", m_nValue);
      else
        sprintf((unsigned __int8 *)&v23, "%d", m_nValue);
    }
    if ( this->m_bHasTitle )
      CWidgetInfoFrame::RenderRowText(this, Rectangle, (const unsigned __int8 *)&v23, v9);
  }
}
// 2B92A0: variable 'v6' is possibly undefined
// 2B92B2: variable 'v7' is possibly undefined
// 2B938C: variable 'v15' is possibly undefined

//----- (002B944C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CWidgetInfoFrame::RenderRowText(
        CWidgetInfoFrame *this,
        CRect RectCell,
        const unsigned __int8 *pszStat,
        float fTextScale)
{
  float left; // r4
  float right; // r5
  float top; // r6
  float v8; // s20
  float Height; // s6
  float v10; // s22
  GxtChar *v11; // r0
  bool v12; // zf
  int m_nColorType; // r1
  float v14; // s2
  CRGBA v15; // r0
  float StringWidth; // r0
  float v17; // r0
  GxtChar pOutput[256]; // [sp+8h] [bp-350h] BYREF
  CRGBA v19; // [sp+208h] [bp-150h] BYREF
  CRGBA v20; // [sp+20Ch] [bp-14Ch] BYREF
  CRGBA v21; // [sp+210h] [bp-148h] BYREF
  unsigned __int8 s[256]; // [sp+214h] [bp-144h] BYREF

  left = RectCell.left;
  right = RectCell.right;
  top = RectCell.top;
  CFont::SetWrapx((float)RsGlobal.screenWidth);
  CFont::SetScale(fTextScale);
  CFont::SetOrientation(1u);
  v8 = fabsf(right - left);
  Height = CFont::GetHeight(0);
  v10 = (float)(top + RectCell.bottom) * 0.5;
  v11 = CText::Get(&TheText, this->TextLabel);
  CFont::PrintString((float)(v8 * 0.055) + left, v10 - (float)(Height * 0.5), v11);
  v12 = !this->m_bIsPercentage;
  if ( !this->m_bIsPercentage )
    v12 = !this->m_bIsTime;
  if ( !v12 || this->m_bIsNumber )
  {
    m_nColorType = this->m_nColorType;
    v14 = (float)this->m_Color._anon_0._anon_0.alpha / 255.0;
    switch ( m_nColorType )
    {
      case 1:
        CRGBA::CRGBA(&v21, 0x5Du, 0x8Eu, 0xBEu, (unsigned int)(float)(v14 * 255.0));
        goto LABEL_10;
      case 2:
      case 4:
        CRGBA::CRGBA(&v20, 0x9Au, 0xCCu, 0x97u, (unsigned int)(float)(v14 * 255.0));
        goto LABEL_10;
      case 3:
        CRGBA::CRGBA(&v19, 0xFFu, 0, 0, (unsigned int)(float)(v14 * 255.0));
LABEL_10:
        CFont::SetColor(v15);
        m_nColorType = this->m_nColorType;
        break;
      default:
        break;
    }
    if ( m_nColorType == 4 )
      sprintf(s, "$~1~%s", (const char *)pszStat);
    else
      strcpy((char *)s, (const char *)pszStat);
    AsciiToGxtChar(s, pOutput);
    StringWidth = CFont::GetStringWidth(pOutput, 1u, 0);
    if ( StringWidth > (float)(v8 * 0.275) )
      CFont::SetScale((float)((float)(v8 * 0.275) / StringWidth) * fTextScale);
    CFont::SetOrientation(2u);
    v17 = CFont::GetHeight(0);
    CFont::PrintString(right + (float)(v8 * -0.052), v10 + (float)(v17 * -0.5), pOutput);
    CFont::RenderFontBuffer();
  }
}
// 2B944C: fragmented variable at 0:r1.12,12:^360.4 may be wrong
// 2B944C: variables would overlap: 0:r1.12,12:^360.4 and ^360.4

//----- (002B9658) --------------------------------------------------------
void __fastcall CWidgetInfoFrame::SetWidgetInfo(
        CWidgetInfoFrame *this,
        unsigned __int8 *pszText,
        float fValue,
        bool bTitle,
        bool bPercentage,
        _BOOL4 bTime,
        bool bNumber,
        int nColor)
{
  float v11; // s2

  strcpy((char *)this->TextLabel, (const char *)pszText);
  v11 = fValue;
  if ( bTime )
    v11 = fValue / 1000.0;
  this->m_bHasTitle = bTitle;
  this->m_bIsPercentage = bPercentage;
  this->m_bIsTime = bTime;
  this->m_bIsNumber = bNumber;
  this->m_nColorType = nColor;
  this->m_nFrameCount = 2;
  this->m_nValue = (int)v11;
}

//----- (002B96B4) --------------------------------------------------------
int CWidgetInfoFrame::AnyObjectEnabled()
{
  CWidgetInfoFrame *v0; // r4

  v0 = CWidgetInfoFrame::m_pChainHead;
  if ( !CWidgetInfoFrame::m_pChainHead )
    return 0;
  while ( !CWidget::GetEnabled(v0) )
  {
    v0 = v0->m_pNext;
    if ( !v0 )
      return 0;
  }
  return 1;
}

//----- (002B96E4) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetInfoFrame::GetName(CWidgetInfoFrame *this)
{
  return "InfoFrame";
}

//----- (002B9700) --------------------------------------------------------
void __fastcall CWidgetList::CWidgetList(
        CWidgetList *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos,
        const unsigned __int8 **pszEntries,
        int nNumEntries,
        int bAlphabetize,
        bool bLocalize,
        bool bShowNumbers)
{
  float32x2_t v8; // d0
  float32x2_t v9; // d1
  _DWORD *v11; // r0
  RwTexture_0 **v12; // r8
  _DWORD *v13; // r4
  _QWORD *v14; // r6
  _QWORD *v15; // r0
  int *v16; // r10
  int v17; // r0
  CRGBA *v18; // r4
  int v19; // r6
  const char *v20; // t1
  char *v21; // r4
  CRGBA *v22; // r5
  int v23; // r6
  int v24; // r11
  const char *v25; // r6
  RwUInt8 red; // r6
  RwUInt8 green; // r4
  RwUInt8 blue; // r9
  RwUInt8 alpha; // r10
  __int64 v30; // d16
  __int64 v31; // d17
  float screenHeight; // s0
  _DWORD *v33; // [sp+8h] [bp-8050h]
  const unsigned __int8 **v34; // [sp+14h] [bp-8044h]
  CRGBA v35; // [sp+1Ch] [bp-803Ch] BYREF
  CRGBA v36[64]; // [sp+20h] [bp-8038h] BYREF
  CSprite2d v37; // [sp+120h] [bp-7F38h] BYREF
  __int64 v38; // [sp+124h] [bp-7F34h]
  __int64 v39; // [sp+12Ch] [bp-7F2Ch]
  CRGBA v40; // [sp+134h] [bp-7F24h]
  char v41; // [sp+138h] [bp-7F20h]

  CWidget::CWidget(this, pszSprite, WidgetPos, 0, HID_MAPPING_UNKNOWN);
  v12 = (RwTexture_0 **)(v11 + 100);
  v13 = v11 + 100;
  *v11 = &off_663E08;
  v33 = v11;
  v14 = v11 + 18212;
  do
  {
    CSprite2d::CSprite2d((CSprite2d *)v13);
    *((_WORD *)v13 - 128) = 48;
    *((_WORD *)v13 - 64) = 48;
    *(_QWORD *)(v13 + 1) = 0x3F80000000000000LL;
    *(_QWORD *)(v13 + 3) = 1065353216LL;
    CRGBA::CRGBA(v36, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
    v13[5] = v36[0];
    *((_BYTE *)v13 + 24) = 0;
    v15 = v13 + 7;
    v13 += 71;
  }
  while ( v15 != v14 );
  v9.n64_f32[0] = (float)nNumEntries;
  v8.n64_u32[0] = 1132462080;
  *((_BYTE *)&elf_hash_chain[1755] + (_DWORD)v33 + 1) = bLocalize;
  *((_BYTE *)v33 + 72918) = 0;
  *(int *)((char *)&elf_hash_chain[1754] + (_DWORD)v33) = 0;
  *((_BYTE *)&elf_hash_chain[1755] + (_DWORD)v33) = 0;
  *((_BYTE *)v33 + 72919) = bShowNumbers;
  *(int *)((char *)&elf_hash_chain[1753] + (_DWORD)v33) = 0;
  v16 = (int *)((char *)&elf_hash_chain[1746] + (_DWORD)v33);
  v17 = (int)vmin_f32(v9, v8).n64_f32[0];
  *(int *)((char *)&elf_hash_chain[1746] + (_DWORD)v33) = v17;
  *((_QWORD *)v33 + 9108) = 0xC974240049742400LL;
  *((_QWORD *)v33 + 9109) = 0x49742400C9742400LL;
  *v14 = 0xC974240049742400LL;
  v14[1] = 0x49742400C9742400LL;
  if ( bAlphabetize )
  {
    if ( nNumEntries >= 1 )
    {
      v18 = v36;
      v19 = nNumEntries;
      do
      {
        v20 = (const char *)*pszEntries++;
        strcpy((char *)v18, v20);
        v18 += 32;
        --v19;
      }
      while ( v19 );
    }
    qsort(v36, nNumEntries, 0x80u, CWidgetList::AlphabetizeSort);
    if ( *v16 >= 1 )
    {
      v21 = (char *)(v33 + 36);
      v22 = v36;
      v23 = 0;
      do
      {
        strcpy(v21, (const char *)v22);
        ++v23;
        v21 += 284;
        v22 += 32;
      }
      while ( v23 < *v16 );
    }
  }
  else if ( v17 >= 1 )
  {
    v24 = 0;
    v34 = pszEntries;
    do
    {
      v25 = (const char *)pszEntries[v24];
      CRGBA::CRGBA(&v35, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
      CSprite2d::CSprite2d(&v37);
      v38 = 0xC974240049742400LL;
      v39 = 0x49742400C9742400LL;
      if ( !v25 )
        v25 = (const char *)&off_2B9BE8;
      strcpy((char *)v36, v25);
      *(_WORD *)&v36[32]._anon_0._anon_0.red = 48;
      red = v35._anon_0._anon_0.red;
      v38 = 0x3F80000000000000LL;
      v39 = 1065353216LL;
      v41 = 0;
      green = v35._anon_0._anon_0.green;
      blue = v35._anon_0._anon_0.blue;
      alpha = v35._anon_0._anon_0.alpha;
      v40 = v35;
      qmemcpy(v12 - 64, v36, 0x100u);
      *v12 = v37.mpTexture;
      v30 = v38;
      v31 = v39;
      *((_BYTE *)v12 + 20) = red;
      *((_BYTE *)v12 + 21) = green;
      *((_BYTE *)v12 + 22) = blue;
      *((_BYTE *)v12 + 23) = alpha;
      pszEntries = v34;
      *((_BYTE *)v12 + 24) = 0;
      *(_QWORD *)(v12 + 1) = v30;
      *(_QWORD *)(v12 + 3) = v31;
      CSprite2d::~CSprite2d(&v37);
      ++v24;
      v12 += 71;
    }
    while ( v24 < *(int *)((char *)&elf_hash_chain[1746] + (_DWORD)v33) );
  }
  screenHeight = (float)RsGlobal.screenHeight;
  *(int *)((char *)&elf_hash_chain[1748] + (_DWORD)v33) = 0;
  *(int *)((char *)&elf_hash_chain[1749] + (_DWORD)v33) = 0;
  *(int *)((char *)&elf_hash_chain[1750] + (_DWORD)v33) = -1;
  *(int *)((char *)&elf_hash_chain[1751] + (_DWORD)v33) = -1;
  *((float *)v33 + 18221) = (float)(screenHeight / 448.0) * 15.0;
  CRGBA::CRGBA(v36, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
  *((_BYTE *)&elf_hash_chain[1756] + (_DWORD)v33) = v36[0]._anon_0._anon_0.red;
  *((_BYTE *)v33 + 72921) = v36[0]._anon_0._anon_0.green;
  *((_WORD *)v33 + 36461) = *(_WORD *)&v36[0]._anon_0.col[2];
  CRGBA::CRGBA(v36, 0xC0u, 0xC0u, 0xC0u, 0xC0u);
  *((_BYTE *)&elf_hash_chain[1757] + (_DWORD)v33) = v36[0]._anon_0._anon_0.red;
  *(_WORD *)((char *)v33 + 72925) = *(_WORD *)&v36[0]._anon_0._anon_0.green;
  *((_BYTE *)v33 + 72927) = v36[0]._anon_0._anon_0.alpha;
  CRGBA::CRGBA(v36, 0xC0u, 0xC0u, 0xC0u, 0xC0u);
  *((_BYTE *)&elf_hash_chain[1758] + (_DWORD)v33) = v36[0]._anon_0._anon_0.red;
  *(_WORD *)((char *)v33 + 72929) = *(_WORD *)&v36[0]._anon_0._anon_0.green;
  *((_BYTE *)v33 + 72931) = v36[0]._anon_0._anon_0.alpha;
  CRGBA::CRGBA(v36, 0xFFu, 0, 0, 0xC0u);
  *((_BYTE *)&elf_hash_chain[1759] + (_DWORD)v33) = v36[0]._anon_0._anon_0.red;
  *(_WORD *)((char *)v33 + 72933) = *(_WORD *)&v36[0]._anon_0._anon_0.green;
  *((_BYTE *)v33 + 72935) = v36[0]._anon_0._anon_0.alpha;
  CRGBA::CRGBA(v36, 0xC0u, 0, 0, 0xC0u);
  *((_BYTE *)&elf_hash_chain[1760] + (_DWORD)v33) = v36[0]._anon_0._anon_0.red;
  *(_WORD *)((char *)v33 + 72937) = *(_WORD *)&v36[0]._anon_0._anon_0.green;
  *((_BYTE *)v33 + 72939) = v36[0]._anon_0._anon_0.alpha;
  CRGBA::CRGBA(v36, 0xC0u, 0xC0u, 0, 0xFFu);
  *((_BYTE *)&elf_hash_chain[1761] + (_DWORD)v33) = v36[0]._anon_0._anon_0.red;
  *(_WORD *)((char *)v33 + 72941) = *(_WORD *)&v36[0]._anon_0._anon_0.green;
  *((_BYTE *)v33 + 72943) = v36[0]._anon_0._anon_0.alpha;
}
// 2B9732: variable 'v11' is possibly undefined
// 2B97F0: variable 'v9' is possibly undefined
// 2B97F0: variable 'v8' is possibly undefined
// 10168: using guessed type int elf_hash_chain[22025];
// 2B9BE8: using guessed type __int16 *off_2B9BE8;
// 663E08: using guessed type void *;

//----- (002B9BFC) --------------------------------------------------------
void __fastcall CWidgetList::Alphebetize(CWidgetList *this, const unsigned __int8 **pszEntries, int nEntries)
{
  char *v6; // r4
  int v7; // r5
  const char *v8; // t1
  ItemData *m_ItemData; // r4
  int v10; // r6
  const char *v11; // r5
  _BYTE v12[32792]; // [sp+0h] [bp-8018h] BYREF

  if ( nEntries >= 1 )
  {
    v6 = v12;
    v7 = nEntries;
    do
    {
      v8 = (const char *)*pszEntries++;
      strcpy(v6, v8);
      v6 += 128;
      --v7;
    }
    while ( v7 );
  }
  qsort(v12, nEntries, 0x80u, CWidgetList::AlphabetizeSort);
  if ( *(int *)((char *)&elf_hash_chain[1746] + (_DWORD)this) >= 1 )
  {
    m_ItemData = this->m_ItemData;
    v10 = 0;
    v11 = v12;
    do
    {
      strcpy((char *)m_ItemData, v11);
      ++v10;
      v11 += 128;
      ++m_ItemData;
    }
    while ( v10 < *(int *)((char *)&elf_hash_chain[1746] + (_DWORD)this) );
  }
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (002B9C7C) --------------------------------------------------------
void __fastcall CWidgetList::Update(CWidgetList *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d2
  float32x2_t v3; // d3
  float32x2_t v4; // d10
  int *p_m_nEntries; // r5
  float *p_m_fScroll; // r6
  float bottom; // s6
  float v9; // s2
  float right; // s4
  float *p_m_fRowHeight; // r9
  float v12; // s6
  __int64 v13; // d17
  float v14; // s8
  float v15; // s6
  float *p_bottom; // r8
  float32x2_t v17; // d11
  double v18; // d16
  float *p_m_fLastPressTime; // r0
  float v20; // s0
  int v21; // r1
  int v22; // r2
  int v23; // r1
  double v24; // d16
  float *v25; // r0
  float v26; // s0
  int v27; // r1
  int m_nTouchIndex; // r1
  float v29; // s0
  CPad *Pad; // r0
  CPad *v31; // r0
  float v32; // s2
  float *p_m_fScrollVelocity; // r0
  float32x2_t v34; // d0
  double v35; // d16
  float v36; // s0
  CPad *v37; // r0
  CPad *v38; // r0
  float v39; // s0
  float v40; // s2
  float v41; // s4
  float v42; // s0
  float v43; // s4
  CVector2D v44[8]; // [sp+0h] [bp-40h] BYREF

  if ( CHID::GetInputType() == 1 && *(int *)((char *)&elf_hash_chain[1750] + (_DWORD)this) == -1 )
    *(int *)((char *)&elf_hash_chain[1750] + (_DWORD)this) = 0;
  CWidget::Update(this);
  CWidget::ManageAlpha(this);
  p_m_nEntries = &this->m_nEntries;
  p_m_fScroll = &this->m_fScroll;
  bottom = this->m_RectScreen.bottom;
  v9 = this->m_RectScreen.top - bottom;
  right = this->m_RectScreen.right;
  p_m_fRowHeight = &this->m_fRowHeight;
  v12 = bottom - this->m_fScroll;
  v1.n64_f32[0] = this->m_RectScreen.left + 2.0;
  v13 = *(_QWORD *)&this->m_RectScreen.right;
  v4.n64_u32[0] = 0;
  v14 = this->m_fRowHeight * (float)this->m_nEntries;
  *(_QWORD *)&this->m_RectScissor.left = *(_QWORD *)&this->m_RectScreen.left;
  *(_QWORD *)&this->m_RectScissor.right = v13;
  v15 = v12 + 2.0;
  LODWORD(this->m_RectClient.left) = v1.n64_u32[0];
  this->m_RectClient.right = right + -2.0;
  p_bottom = &this->m_RectClient.bottom;
  this->m_RectClient.bottom = v15;
  v1.n64_f32[0] = (float)(v14 - fabsf(v9)) + 4.0;
  this->m_RectClient.top = v15 + v14;
  v17.n64_u64[0] = vmax_f32(v1, v4).n64_u64[0];
  if ( CHID::IsReleased(HID_MAPPING_MENU_DOWN) )
  {
    v18 = CWidget::m_fTime;
    p_m_fLastPressTime = &this->m_fLastPressTime;
  }
  else
  {
    if ( !CHID::IsPressedPositive(HID_MAPPING_PED_MOVE_Y) )
      goto LABEL_12;
    p_m_fLastPressTime = &this->m_fLastPressTime;
    v18 = CWidget::m_fTime;
    if ( CWidget::m_fTime - this->m_fLastPressTime <= 0.25 )
      goto LABEL_12;
  }
  v20 = v18;
  *p_m_fLastPressTime = v20;
  v21 = *(int *)((char *)&elf_hash_chain[1750] + (_DWORD)this);
  v22 = v21 + 2;
  v23 = v21 + 1;
  *(int *)((char *)&elf_hash_chain[1750] + (_DWORD)this) = v23;
  if ( (float)(*p_bottom + (float)(*p_m_fRowHeight * (float)v22)) > (float)(this->m_RectScreen.top + 2.0) )
    this->m_fScrollVelocity = *p_m_fRowHeight * 10.0;
  if ( v23 >= *p_m_nEntries )
  {
    *(int *)((char *)&elf_hash_chain[1750] + (_DWORD)this) = 0;
    *p_m_fScroll = 0.0;
    *(int *)((char *)&elf_hash_chain[1749] + (_DWORD)this) = 0;
  }
LABEL_12:
  if ( CHID::IsReleased(HID_MAPPING_MENU_UP) )
  {
    v24 = CWidget::m_fTime;
    v25 = &this->m_fLastPressTime;
  }
  else
  {
    if ( !CHID::IsPressedNegative(HID_MAPPING_PED_MOVE_Y) )
      goto LABEL_20;
    v25 = &this->m_fLastPressTime;
    v24 = CWidget::m_fTime;
    if ( CWidget::m_fTime - this->m_fLastPressTime <= 0.25 )
      goto LABEL_20;
  }
  v26 = v24;
  *v25 = v26;
  v27 = *(int *)((char *)&elf_hash_chain[1750] + (_DWORD)this);
  *(int *)((char *)&elf_hash_chain[1750] + (_DWORD)this) = v27 - 1;
  if ( (float)(*p_bottom + (float)(*p_m_fRowHeight * (float)(v27 - 1))) < (float)(this->m_RectScreen.bottom + 2.0) )
    this->m_fScrollVelocity = *p_m_fRowHeight * -10.0;
  if ( v27 <= 0 )
  {
    *(int *)((char *)&elf_hash_chain[1750] + (_DWORD)this) = *p_m_nEntries - 1;
    *p_m_fScroll = v17.n64_f32[0];
    *(int *)((char *)&elf_hash_chain[1749] + (_DWORD)this) = 0;
  }
LABEL_20:
  if ( !CTouchInterface::IsTouchDown(this->m_nTouchIndex) )
    goto LABEL_29;
  m_nTouchIndex = this->m_nTouchIndex;
  if ( this != CWidget::m_pInitialTouchWidget[m_nTouchIndex] )
    goto LABEL_29;
  CWidgetList::Update(void)::isLastInputJoystick = 0;
  CTouchInterface::GetTouchPosition(v44, m_nTouchIndex);
  v29 = v44[0].y - this->m_fLastTouchPositionY;
  if ( fabsf(v29) <= (float)((float)RsGlobal.screenHeight * 0.01) )
  {
    if ( !*((_BYTE *)&elf_hash_chain[1755] + (_DWORD)this) )
      goto LABEL_29;
    goto LABEL_26;
  }
  if ( *((_BYTE *)&elf_hash_chain[1755] + (_DWORD)this) )
LABEL_26:
    *p_m_fScroll = *p_m_fScroll - v29;
  CTouchInterface::GetTouchPosition(v44, this->m_nTouchIndex);
  this->m_fLastTouchPositionY = v44[0].y;
  *((_BYTE *)&elf_hash_chain[1755] + (_DWORD)this) = 1;
  if ( !this->m_bAlwaysHasSelection )
    *(int *)((char *)&elf_hash_chain[1750] + (_DWORD)this) = -1;
LABEL_29:
  CPad::GetPad(0);
  if ( CPad::NewMouseControllerState.m_fWheelMoved != 0.0 )
  {
    CPad::GetPad(0);
    this->m_fScrollVelocity = this->m_fScrollVelocity
                            + (float)((float)((float)(CPad::NewMouseControllerState.m_fWheelMoved / -120.0)
                                            * *p_m_fRowHeight)
                                    * 10.0);
  }
  CPad::GetPad(0);
  if ( LIB_KeyboardPressed(KK_ARROWUP)
    || IsCheatMenuOpen() == 1 && (Pad = CPad::GetPad(0), Pad->NewState.LeftShoulder1) && !Pad->OldState.LeftShoulder1 )
  {
    *p_m_fScroll = *p_m_fScroll + (float)(fabsf(this->m_RectScreen.top - this->m_RectScreen.bottom) * -0.5);
  }
  CPad::GetPad(0);
  if ( LIB_KeyboardPressed(KK_ARROWDOWN)
    || IsCheatMenuOpen() == 1 && (v31 = CPad::GetPad(0), v31->NewState.RightShoulder1) && !v31->OldState.RightShoulder1 )
  {
    *p_m_fScroll = *p_m_fScroll + (float)(fabsf(this->m_RectScreen.top - this->m_RectScreen.bottom) * 0.5);
  }
  v32 = *p_m_fRowHeight;
  p_m_fScrollVelocity = &this->m_fScrollVelocity;
  v2.n64_f32[0] = -(float)(*p_m_fRowHeight * 50.0);
  v3.n64_u32[0] = LODWORD(this->m_fScrollVelocity);
  v1.n64_f32[0] = *p_m_fRowHeight * 50.0;
  v34.n64_u64[0] = vmin_f32(vmax_f32(v3, v2), v1).n64_u64[0];
  LODWORD(this->m_fScrollVelocity) = v34.n64_u32[0];
  if ( v34.n64_f32[0] <= 0.0 )
  {
    if ( v34.n64_f32[0] >= 0.0 )
    {
      v35 = CWidget::m_fElapsedTime;
      goto LABEL_47;
    }
    v35 = CWidget::m_fElapsedTime;
    v34.n64_f32[0] = CWidget::m_fElapsedTime * (float)(v32 * 35.0) + v34.n64_f32[0];
    v34.n64_u64[0] = vmin_f32(v34, v4).n64_u64[0];
  }
  else
  {
    v35 = CWidget::m_fElapsedTime;
    v34.n64_f32[0] = v34.n64_f32[0] + CWidget::m_fElapsedTime * (float)(v32 * -35.0);
    v34.n64_u64[0] = vmax_f32(v34, v4).n64_u64[0];
  }
  *p_m_fScrollVelocity = v34.n64_f32[0];
LABEL_47:
  v34.n64_f32[0] = v35 * v34.n64_f32[0] + *p_m_fScroll;
  v36 = vmin_f32(vmax_f32(v34, v4), v17).n64_f32[0];
  *p_m_fScroll = v36;
  if ( v36 == 0.0 )
    *p_m_fScrollVelocity = 0.0;
  if ( IsCheatMenuOpen() == 1 )
  {
    if ( (v37 = CPad::GetPad(0), v37->NewState.LeftShoulder1) && !v37->OldState.LeftShoulder1
      || (v38 = CPad::GetPad(0), v38->NewState.RightShoulder1) && !v38->OldState.RightShoulder1 )
    {
      CWidgetList::Update(void)::isLastInputJoystick = 1;
    }
  }
  if ( CHID::GetInputType() == 1 && IsCheatMenuOpen() == 1 && CWidgetList::Update(void)::isLastInputJoystick == 1 )
  {
    v39 = *p_m_fRowHeight;
    v40 = *p_bottom;
    v41 = (float)(this->m_RectScreen.bottom - *p_m_fRowHeight) + 2.0;
    if ( (float)(*p_bottom + (float)(*p_m_fRowHeight * (float)*(int *)((char *)&elf_hash_chain[1750] + (_DWORD)this))) >= v41 )
    {
      v43 = (float)(v39 + this->m_RectScreen.top) + -2.0;
      if ( (float)(v40 + (float)(v39 * (float)(*(int *)((char *)&elf_hash_chain[1750] + (_DWORD)this) + 1))) <= v43 )
        return;
      v42 = (float)((float)(v43 - v40) / v39) + -2.0;
    }
    else
    {
      v42 = (float)((float)(v41 - v40) / v39) + 2.0;
    }
    *(int *)((char *)&elf_hash_chain[1750] + (_DWORD)this) = (int)v42;
  }
}
// 2B9D68: variable 'v1' is possibly undefined
// 2B9D68: variable 'v4' is possibly undefined
// 2BA0A2: variable 'v3' is possibly undefined
// 2BA0A2: variable 'v2' is possibly undefined
// 10168: using guessed type int elf_hash_chain[22025];
// 6FA318: using guessed type char CWidgetList::Update(void)::isLastInputJoystick;

//----- (002BA280) --------------------------------------------------------
void __fastcall CWidgetList::Draw(CWidgetList *this)
{
  float32x2_t v1; // d2
  float32x2_t v2; // d3
  CRect *p_m_RectScissor; // r5
  unsigned int v5; // r1
  unsigned int alpha; // r0
  bool v7; // zf
  float32x4_t v8; // q8
  int v9; // r0
  int v10; // r5
  int *p_m_nSelectedItem; // r11
  float *p_m_fRowHeight; // r10
  float *p_bottom; // r9
  int v14; // r8
  float bottom; // s6
  float v16; // s0
  float top; // s8
  float v18; // s2
  float v19; // s22
  float v20; // r0
  float left; // r1
  float v22; // s0
  RwUInt8 blue; // r3
  float v24; // s2
  RwUInt8 green; // r2
  CRGBA *p_m_ColorSelectedItemLeft; // r0
  float v27; // s2
  float v28; // s0
  float v29; // s6
  CRect *p_m_RectClient; // [sp+60h] [bp-98h]
  float *p_right; // [sp+64h] [bp-94h]
  CRGBA v32; // [sp+68h] [bp-90h] BYREF
  CRGBA bottomleftrgba; // [sp+6Ch] [bp-8Ch] BYREF
  CRect Rectangle; // [sp+70h] [bp-88h] BYREF
  float32x4_t v35; // [sp+80h] [bp-78h] BYREF

  p_m_RectScissor = &this->m_RectScissor;
  CWidget::SetScissor(&this->m_RectScissor);
  alpha = this->m_ColorBorder._anon_0._anon_0.alpha;
  v7 = alpha == 0;
  if ( this->m_ColorBorder._anon_0._anon_0.alpha )
  {
    v5 = this->m_Color._anon_0._anon_0.alpha;
    v7 = v5 == 0;
  }
  if ( !v7 )
  {
    CRGBA::CRGBA(
      (CRGBA *)&v35,
      *((_BYTE *)&elf_hash_chain[1756] + (_DWORD)this),
      this->m_ColorBorder._anon_0._anon_0.green,
      this->m_ColorBorder._anon_0._anon_0.blue,
      (unsigned int)(float)((float)((float)v5 / 255.0) * (float)alpha));
    CSprite2d::DrawRect(&this->m_RectScreen, (const CRGBA *)&v35);
  }
  v8.n128_u64[0] = 0xC000000040000000LL;
  v8.n128_u64[1] = 0x40000000C0000000LL;
  v35 = vaddq_f32(*(float32x4_t *)p_m_RectScissor, v8);
  CWidget::SetScissor((CRect *)&v35);
  v9 = *(int *)((char *)&elf_hash_chain[1746] + (_DWORD)this);
  if ( v9 >= 1 )
  {
    v10 = 0;
    p_m_nSelectedItem = &this->m_nSelectedItem;
    p_right = &this->m_RectClient.right;
    p_m_fRowHeight = &this->m_fRowHeight;
    p_bottom = &this->m_RectClient.bottom;
    p_m_RectClient = &this->m_RectClient;
    while ( 1 )
    {
      v14 = v10++;
      v1.n64_f32[0] = *p_m_fRowHeight;
      bottom = this->m_RectScreen.bottom;
      v16 = *p_bottom + (float)(*p_m_fRowHeight * (float)v14);
      if ( v16 > (float)((float)(bottom - *p_m_fRowHeight) + 2.0) )
      {
        top = this->m_RectScreen.top;
        v18 = *p_bottom + (float)(v1.n64_f32[0] * (float)v10);
        if ( v18 < (float)((float)(v1.n64_f32[0] + top) + -2.0) )
          break;
      }
LABEL_25:
      if ( v10 >= v9 )
        goto LABEL_26;
    }
    if ( v16 >= bottom )
    {
      v19 = 1.0;
      if ( v18 <= top )
      {
LABEL_14:
        if ( v14 == this->m_nEquippedItem )
        {
          v20 = *p_right;
          left = p_m_RectClient->left;
          Rectangle.bottom = *p_bottom + (float)(*p_m_fRowHeight * (float)v14);
          Rectangle.left = left;
          Rectangle.right = v20;
          Rectangle.top = v18;
          CRGBA::CRGBA(
            &bottomleftrgba,
            this->m_ColorEquippedItem._anon_0._anon_0.red,
            this->m_ColorEquippedItem._anon_0._anon_0.green,
            this->m_ColorEquippedItem._anon_0._anon_0.blue,
            (unsigned int)(float)((float)(v19 * (float)this->m_ColorEquippedItem._anon_0._anon_0.alpha)
                                * (float)((float)this->m_Color._anon_0._anon_0.alpha / 255.0)));
          CSprite2d::DrawRect(&Rectangle, &bottomleftrgba);
        }
        if ( v14 == *p_m_nSelectedItem )
        {
          v22 = (float)this->m_Color._anon_0._anon_0.alpha / 255.0;
          blue = this->m_ColorSelectedItemLeft._anon_0._anon_0.blue;
          v24 = v19 * (float)this->m_ColorSelectedItemLeft._anon_0._anon_0.alpha;
          green = this->m_ColorSelectedItemLeft._anon_0._anon_0.green;
          p_m_ColorSelectedItemLeft = &this->m_ColorSelectedItemLeft;
        }
        else
        {
          v22 = (float)this->m_Color._anon_0._anon_0.alpha / 255.0;
          if ( v14 << 31 )
          {
            blue = this->m_ColorOddItem._anon_0._anon_0.blue;
            v24 = v19 * (float)this->m_ColorOddItem._anon_0._anon_0.alpha;
            green = this->m_ColorOddItem._anon_0._anon_0.green;
            p_m_ColorSelectedItemLeft = &this->m_ColorOddItem;
          }
          else
          {
            blue = this->m_ColorEvenItem._anon_0._anon_0.blue;
            v24 = v19 * (float)this->m_ColorEvenItem._anon_0._anon_0.alpha;
            green = this->m_ColorEvenItem._anon_0._anon_0.green;
            p_m_ColorSelectedItemLeft = &this->m_ColorEvenItem;
          }
        }
        CRGBA::CRGBA(
          &bottomleftrgba,
          p_m_ColorSelectedItemLeft->_anon_0._anon_0.red,
          green,
          blue,
          (unsigned int)(float)(v24 * v22));
        if ( v14 == *p_m_nSelectedItem )
          CRGBA::CRGBA(
            &v32,
            this->m_ColorSelectedItemRight._anon_0._anon_0.red,
            this->m_ColorSelectedItemRight._anon_0._anon_0.green,
            this->m_ColorSelectedItemRight._anon_0._anon_0.blue,
            (unsigned int)(float)((float)(v19 * (float)this->m_ColorSelectedItemRight._anon_0._anon_0.alpha)
                                * (float)((float)this->m_Color._anon_0._anon_0.alpha / 255.0)));
        else
          v32 = bottomleftrgba;
        v27 = *p_bottom + (float)(*p_m_fRowHeight * (float)v14);
        v28 = *p_bottom + (float)(*p_m_fRowHeight * (float)v10);
        v29 = *p_right;
        Rectangle.left = p_m_RectClient->left + 1.0;
        Rectangle.right = v29 + -1.0;
        Rectangle.bottom = v27 + 1.0;
        Rectangle.top = v28 + -1.0;
        CSprite2d::DrawRect(&Rectangle, &bottomleftrgba, &v32, &bottomleftrgba, &v32);
        v9 = *(int *)((char *)&elf_hash_chain[1746] + (_DWORD)this);
        goto LABEL_25;
      }
      v2.n64_f32[0] = v18 - top;
    }
    else
    {
      v2.n64_f32[0] = bottom - v16;
    }
    v1.n64_f32[0] = (float)(1.0 / v1.n64_f32[0]) * v2.n64_f32[0];
    v2.n64_u32[0] = 0;
    v1.n64_f32[0] = 1.0 - v1.n64_f32[0];
    LODWORD(v19) = vmax_f32(v1, v2).n64_u32[0];
    goto LABEL_14;
  }
LABEL_26:
  memset(&v35, 0, sizeof(v35));
  CWidget::SetScissor((CRect *)&v35);
}
// 2BA2C8: variable 'v5' is possibly undefined
// 2BA4BE: variable 'v1' is possibly undefined
// 2BA4BE: variable 'v2' is possibly undefined
// 10168: using guessed type int elf_hash_chain[22025];
// 2BA280: using guessed type float32x4_t var_78;

//----- (002BA6B8) --------------------------------------------------------
float __fastcall CWidgetList::GetAlphaAtIndex(CWidgetList *this, int ndx)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float bottom; // s8
  float v5; // s4
  float v6; // s6
  float v7; // s2
  float top; // s4
  float result; // r0

  bottom = this->m_RectScreen.bottom;
  v2.n64_u32[0] = LODWORD(this->m_fRowHeight);
  v5 = this->m_RectClient.bottom;
  v6 = v5 + (float)(v2.n64_f32[0] * (float)ndx);
  if ( v6 >= bottom )
  {
    v7 = v5 + (float)(v2.n64_f32[0] * (float)(ndx + 1));
    top = this->m_RectScreen.top;
    if ( v7 <= top )
      return 1.0;
    v3.n64_f32[0] = v7 - top;
  }
  else
  {
    v3.n64_f32[0] = bottom - v6;
  }
  v2.n64_f32[0] = (float)(1.0 / v2.n64_f32[0]) * v3.n64_f32[0];
  v3.n64_u32[0] = 0;
  v2.n64_f32[0] = 1.0 - v2.n64_f32[0];
  LODWORD(result) = vmax_f32(v2, v3).n64_u32[0];
  return result;
}
// 2BA732: variable 'v2' is possibly undefined
// 2BA732: variable 'v3' is possibly undefined

//----- (002BA740) --------------------------------------------------------
void __fastcall CWidgetList::OnInitialTouch(CWidgetList *this)
{
  float32x2_t v1; // d1
  float32x2_t v2; // d2
  float32x2_t v3; // d4
  float32x2_t v4; // d5
  int v6; // r0
  int m_nTouchIndex; // r1
  float m_fRowHeight; // s0
  CVector2D *v9; // r5
  int v10; // r4
  int v11; // r2
  float bottom; // s6
  int v13; // r3
  float *p_y; // r4
  int v15; // r5
  CVector2D v16; // [sp+0h] [bp-18h] BYREF

  CWidget::OnInitialTouch(this);
  v6 = *(int *)((char *)&elf_hash_chain[1746] + (_DWORD)this);
  if ( v6 <= 0 )
  {
    m_nTouchIndex = this->m_nTouchIndex;
  }
  else
  {
    m_nTouchIndex = this->m_nTouchIndex;
    m_fRowHeight = this->m_fRowHeight;
    v9 = &CWidget::m_vecTouchAnchor[m_nTouchIndex];
    v10 = 0;
    v11 = 0;
    bottom = this->m_RectClient.bottom;
    if ( v9->x < this->m_RectClient.left )
      v10 = 1;
    v13 = (v9->x > this->m_RectClient.right) | v10;
    p_y = &v9->y;
    while ( 1 )
    {
      v15 = v11++;
      if ( !v13 )
      {
        v4.n64_f32[0] = bottom + (float)(m_fRowHeight * (float)v15);
        v2.n64_f32[0] = this->m_RectScreen.bottom + 2.0;
        if ( *p_y >= vmax_f32(v4, v2).n64_f32[0] )
        {
          v3.n64_f32[0] = bottom + (float)(m_fRowHeight * (float)v11);
          v1.n64_f32[0] = this->m_RectScreen.top + -2.0;
          v3.n64_u64[0] = vmin_f32(v3, v1).n64_u64[0];
          if ( *p_y <= v3.n64_f32[0] )
            break;
        }
      }
      if ( v11 >= v6 )
        goto LABEL_12;
    }
    *(int *)((char *)&elf_hash_chain[1750] + (_DWORD)this) = v15;
  }
LABEL_12:
  CTouchInterface::GetTouchPosition(&v16, m_nTouchIndex);
  *(int *)((char *)&elf_hash_chain[1754] + (_DWORD)this) = LODWORD(v16.y);
  *((_BYTE *)&elf_hash_chain[1755] + (_DWORD)this) = 0;
}
// 2BA7FA: variable 'v4' is possibly undefined
// 2BA7FA: variable 'v2' is possibly undefined
// 2BA814: variable 'v3' is possibly undefined
// 2BA814: variable 'v1' is possibly undefined
// 10168: using guessed type int elf_hash_chain[22025];

//----- (002BA860) --------------------------------------------------------
bool __fastcall CWidgetList::IsSwipedLeft(CWidgetList *this)
{
  int (__fastcall *v2)(CWidgetList *, CVector2D *, _DWORD); // r6
  CVector2D v4[3]; // [sp+0h] [bp-18h] BYREF

  if ( !CWidget::IsSwipedLeft(this) )
    return 0;
  v2 = (int (__fastcall *)(CWidgetList *, CVector2D *, _DWORD))*((_DWORD *)this->_vptr$CWidget + 3);
  CTouchInterface::GetTouchPosition(v4, this->m_nTouchIndex);
  return v2(this, v4, 0) ^ 1;
}

//----- (002BA89A) --------------------------------------------------------
bool __fastcall CWidgetList::IsSwipedRight(CWidgetList *this)
{
  int (__fastcall *v2)(CWidgetList *, CVector2D *, _DWORD); // r6
  CVector2D v4[3]; // [sp+0h] [bp-18h] BYREF

  if ( !CWidget::IsSwipedRight(this) )
    return 0;
  v2 = (int (__fastcall *)(CWidgetList *, CVector2D *, _DWORD))*((_DWORD *)this->_vptr$CWidget + 3);
  CTouchInterface::GetTouchPosition(v4, this->m_nTouchIndex);
  return v2(this, v4, 0) ^ 1;
}

//----- (002BA8D4) --------------------------------------------------------
int __fastcall CWidgetList::GetSelectedEntry(CWidgetList *this, unsigned __int8 *pszAsciiName)
{
  int v2; // r2
  bool v3; // zf
  int *p_m_nSelectedItem; // r4

  v2 = (int)&this->m_ItemData[230].m_szItemName[72];
  v3 = pszAsciiName == 0;
  p_m_nSelectedItem = &this->m_nSelectedItem;
  if ( pszAsciiName )
  {
    v2 = *p_m_nSelectedItem;
    v3 = *p_m_nSelectedItem == -1;
  }
  if ( !v3 )
    strcpy((char *)pszAsciiName, (const char *)&this->m_ItemData[v2]);
  return *p_m_nSelectedItem;
}

//----- (002BA904) --------------------------------------------------------
int __fastcall CWidgetList::AlphabetizeSort(const void *pObj0, const void *pObj1)
{
  int v2; // r0
  int v3; // r1

  v2 = strcmp((const char *)pObj0, (const char *)pObj1);
  v3 = -1;
  if ( v2 > 0 )
    return 1;
  return v3;
}

//----- (002BA91C) --------------------------------------------------------
void __fastcall CWidgetList::ShrinkTextToFit(CWidgetList *this, float fWidthLimit)
{
  float *p_m_fTextScale; // r11
  _DWORD *v4; // r10
  ItemData *m_ItemData; // r4
  bool *p_m_bLocalize; // r5
  int i; // r6
  GxtChar *v8; // r0
  float StringWidth; // s0
  float v10; // r0
  GxtChar v11[152]; // [sp+0h] [bp-130h] BYREF

  if ( *(int *)((char *)&elf_hash_chain[1746] + (_DWORD)this) >= 1 )
  {
    p_m_fTextScale = &this->m_fTextScale;
    v4 = (int *)((char *)&elf_hash_chain[1746] + (_DWORD)this);
    m_ItemData = this->m_ItemData;
    p_m_bLocalize = &this->m_bLocalize;
    for ( i = 0; i < *v4; ++i )
    {
      if ( *p_m_bLocalize )
      {
        v8 = CText::Get(&TheText, m_ItemData->m_szItemName);
        StringWidth = 0.0;
        if ( !v8 )
          goto LABEL_8;
      }
      else
      {
        AsciiToGxtChar(m_ItemData->m_szItemName, v11);
        v8 = v11;
      }
      StringWidth = CFont::GetStringWidth(v8, 1u, 0);
LABEL_8:
      if ( StringWidth > fWidthLimit )
      {
        v10 = (float)(fWidthLimit / StringWidth) * *p_m_fTextScale;
        *p_m_fTextScale = v10;
        CFont::SetScale(v10);
      }
      ++m_ItemData;
    }
  }
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (002BA9E0) --------------------------------------------------------
void __fastcall CWidgetList::AddItem(
        CWidgetList *this,
        const unsigned __int8 *pszItemName,
        const unsigned __int8 *pszItemPrice)
{
  const unsigned __int8 *v6; // r4
  RwUInt8 red; // r5
  RwUInt8 green; // r11
  RwUInt8 blue; // r4
  RwUInt8 alpha; // r8
  char *v11; // r9
  __int64 v12; // d16
  __int64 v13; // d17
  CRGBA v14; // [sp+Ch] [bp-144h] BYREF
  char v15[256]; // [sp+10h] [bp-140h] BYREF
  CSprite2d v16; // [sp+110h] [bp-40h] BYREF
  __int64 v17; // [sp+114h] [bp-3Ch]
  __int64 v18; // [sp+11Ch] [bp-34h]
  CRGBA v19; // [sp+124h] [bp-2Ch]
  char v20; // [sp+128h] [bp-28h]

  CRGBA::CRGBA(&v14, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
  CSprite2d::CSprite2d(&v16);
  v6 = (const unsigned __int8 *)&off_2BAB14;
  v17 = 0xC974240049742400LL;
  v18 = 0x49742400C9742400LL;
  if ( !pszItemName )
    pszItemName = (const unsigned __int8 *)&off_2BAB14;
  strcpy(v15, (const char *)pszItemName);
  if ( pszItemPrice )
    v6 = pszItemPrice;
  strcpy(&v15[128], (const char *)v6);
  red = v14._anon_0._anon_0.red;
  green = v14._anon_0._anon_0.green;
  blue = v14._anon_0._anon_0.blue;
  v17 = 0x3F80000000000000LL;
  v18 = 1065353216LL;
  v19 = v14;
  v20 = 0;
  alpha = v14._anon_0._anon_0.alpha;
  v11 = (char *)this + 284 * *(int *)((char *)&elf_hash_chain[1746] + (_DWORD)this);
  qmemcpy(v11 + 144, v15, 0x100u);
  *((CSprite2d *)v11 + 100) = v16;
  v12 = v17;
  v13 = v18;
  v11[420] = red;
  v11[424] = 0;
  v11[422] = blue;
  v11[421] = green;
  v11[423] = alpha;
  *(_QWORD *)(v11 + 404) = v12;
  *(_QWORD *)(v11 + 412) = v13;
  CSprite2d::~CSprite2d(&v16);
  ++*(int *)((char *)&elf_hash_chain[1746] + (_DWORD)this);
}
// 10168: using guessed type int elf_hash_chain[22025];
// 2BAB14: using guessed type __int16 *off_2BAB14;
// 2BA9E0: using guessed type char var_140[256];

//----- (002BAB1C) --------------------------------------------------------
bool __fastcall CWidgetList::IsReleased(CWidgetList *this, CVector2D *pVecOut)
{
  return *(int *)((char *)&elf_hash_chain[1750] + (_DWORD)this) != -1 && sub_191CC0(this, pVecOut);
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (002BAB32) --------------------------------------------------------
void __fastcall CWidgetList::Visualize(CWidgetList *this)
{
  CRGBA v2; // [sp+4h] [bp-Ch] BYREF

  CWidget::Visualize(this);
  CRGBA::CRGBA(&v2, 0, 0, 0xFFu, 0x80u);
  CSprite2d::DrawRect(&this->m_RectClient, &v2);
}

//----- (002BAB64) --------------------------------------------------------
void __fastcall CWidgetList::~CWidgetList(CWidgetList *this)
{
  int *v2; // r5

  v2 = &elf_hash_chain[1731];
  this->_vptr$CWidget = (int (**)(void))&off_663E08;
  do
  {
    CSprite2d::~CSprite2d((CSprite2d *)((char *)v2 + (_DWORD)this));
    v2 -= 71;
  }
  while ( v2 != &dword_74 );
  sub_19C514(this);
}
// 74: using guessed type int dword_74;
// 10168: using guessed type int elf_hash_chain[22025];
// 663E08: using guessed type void *off_663E08;

//----- (002BAB9A) --------------------------------------------------------
float __fastcall CWidgetList::GetWidgetValue(CWidgetList *this)
{
  return (float)this->m_nSelectedItem;
}

//----- (002BABB0) --------------------------------------------------------
bool __fastcall CWidgetList::IsSwiped(CWidgetList *this)
{
  if ( (*((int (__fastcall **)(CWidgetList *))this->_vptr$CWidget + 17))(this) )
    return 1;
  else
    return (*((int (__fastcall **)(CWidgetList *))this->_vptr$CWidget + 18))(this);
}

//----- (002BABD2) --------------------------------------------------------
void __fastcall CWidgetList::SetEquippedItem(CWidgetList *this, int nValue)
{
  *(int *)((char *)&elf_hash_chain[1751] + (_DWORD)this) = nValue;
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (002BABDE) --------------------------------------------------------
void __fastcall CWidgetList::SetWidgetValue(CWidgetList *this, float fValue)
{
  *(int *)((char *)&elf_hash_chain[1750] + (_DWORD)this) = (int)fValue;
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (002BAC00) --------------------------------------------------------
void __fastcall CWidgetListShop::CWidgetListShop(
        CWidgetListShop *this,
        const unsigned __int8 *pszTitle,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos,
        const unsigned __int8 **pszEntries,
        int nNumEntries,
        bool bShowThumbs)
{
  unsigned int m_nFlags; // r2
  int v10; // r5
  CRGBA v11; // [sp+14h] [bp-14h] BYREF

  CWidgetList::CWidgetList(this, pszSprite, WidgetPos, pszEntries, nNumEntries, 0, 1, 0);
  this->m_bAlwaysHasSelection = 1;
  m_nFlags = this->m_nFlags;
  *(int *)((char *)&elf_hash_chain[1750] + (_DWORD)this) = 0;
  this->_vptr$CWidget = (int (**)(void))&off_663EA0;
  this->m_nFlags = m_nFlags | 4;
  if ( !pszTitle )
    pszTitle = (const unsigned __int8 *)&byte_61CADE;
  strcpy((char *)this->m_szTitle, (const char *)pszTitle);
  this->m_fRowHeight = (float)((float)RsGlobal.screenHeight / 448.0) * 40.0;
  CRGBA::CRGBA(&v11, 0, 0, 0, 0);
  *((_BYTE *)&elf_hash_chain[1756] + (_DWORD)this) = v11._anon_0._anon_0.red;
  *(_WORD *)&this->m_ColorBorder._anon_0._anon_0.green = *(_WORD *)&v11._anon_0._anon_0.green;
  this->m_ColorBorder._anon_0._anon_0.alpha = v11._anon_0._anon_0.alpha;
  CRGBA::CRGBA(&v11, 0xFFu, 0xFFu, 0xFFu, 0x40u);
  *((_BYTE *)&elf_hash_chain[1757] + (_DWORD)this) = v11._anon_0._anon_0.red;
  *(_WORD *)&this->m_ColorSelectedItemLeft._anon_0._anon_0.green = *(_WORD *)&v11._anon_0._anon_0.green;
  this->m_ColorSelectedItemLeft._anon_0._anon_0.alpha = v11._anon_0._anon_0.alpha;
  CRGBA::CRGBA(&v11, 0xFFu, 0xFFu, 0xFFu, 0x20u);
  *((_BYTE *)&elf_hash_chain[1758] + (_DWORD)this) = v11._anon_0._anon_0.red;
  *(_WORD *)&this->m_ColorSelectedItemRight._anon_0._anon_0.green = *(_WORD *)&v11._anon_0._anon_0.green;
  this->m_ColorSelectedItemRight._anon_0._anon_0.alpha = v11._anon_0._anon_0.alpha;
  CRGBA::CRGBA(&v11, 0xFFu, 0xFFu, 0xFFu, 0);
  *((_BYTE *)&elf_hash_chain[1759] + (_DWORD)this) = v11._anon_0._anon_0.red;
  *(_WORD *)&this->m_ColorEvenItem._anon_0._anon_0.green = *(_WORD *)&v11._anon_0._anon_0.green;
  this->m_ColorEvenItem._anon_0._anon_0.alpha = v11._anon_0._anon_0.alpha;
  CRGBA::CRGBA(&v11, 0xFFu, 0xFFu, 0xFFu, 0);
  *((_BYTE *)&elf_hash_chain[1760] + (_DWORD)this) = v11._anon_0._anon_0.red;
  *(_WORD *)&this->m_ColorOddItem._anon_0._anon_0.green = *(_WORD *)&v11._anon_0._anon_0.green;
  this->m_ColorOddItem._anon_0._anon_0.alpha = v11._anon_0._anon_0.alpha;
  *((_BYTE *)&elf_hash_chain[1826] + (_DWORD)this) = bShowThumbs;
  if ( *(int *)((char *)&elf_hash_chain[1746] + (_DWORD)this) >= 1 )
  {
    v10 = 0;
    do
      CWidgetListShop::AssignImage(this, v10++);
    while ( v10 < *(int *)((char *)&elf_hash_chain[1746] + (_DWORD)this) );
  }
}
// 10168: using guessed type int elf_hash_chain[22025];
// 61CADE: using guessed type char byte_61CADE;
// 663EA0: using guessed type void *;

//----- (002BAE4C) --------------------------------------------------------
void __fastcall CWidgetListShop::AssignImages(CWidgetListShop *this)
{
  int v2; // r5

  if ( *(int *)((char *)&elf_hash_chain[1746] + (_DWORD)this) >= 1 )
  {
    v2 = 0;
    do
      CWidgetListShop::AssignImage(this, v2++);
    while ( v2 < *(int *)((char *)&elf_hash_chain[1746] + (_DWORD)this) );
  }
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (002BAE7E) --------------------------------------------------------
void __fastcall CWidgetListShop::Update(CWidgetListShop *this)
{
  float bottom; // s10
  float v3; // s0
  float m_fRowHeight; // s8
  float v5; // s6

  CWidget::SetEnabled(this, 1);
  CWidgetList::Update(this);
  bottom = this->m_RectScreen.bottom;
  v3 = this->m_RectScreen.right + -2.0;
  m_fRowHeight = this->m_fRowHeight;
  v5 = m_fRowHeight + (float)(this->m_RectScreen.top + -2.0);
  this->m_RectScissor.left = this->m_RectScreen.left + 2.0;
  this->m_RectScissor.right = v3;
  this->m_RectScissor.top = v5;
  this->m_RectScissor.bottom = (float)(bottom + 2.0) - m_fRowHeight;
}

//----- (002BAEF8) --------------------------------------------------------
void __fastcall CWidgetListShop::Draw(CWidgetListShop *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d2
  float32x2_t v4; // d4
  float right; // r1
  const CRGBA *v7; // r0
  RwInt32 screenWidth; // s0
  float *p_m_fRowHeight; // r4
  float m_fRowHeight; // s18
  int v11; // r0
  unsigned __int8 *m_szItemPrice; // r6
  int v13; // r8
  float *p_m_fTextScale; // r9
  CRect *p_m_RectClient; // r5
  float *p_bottom; // r2
  float v17; // s18
  float v18; // s20
  int v19; // r1
  float v20; // s27
  float AlphaAtIndex; // s29
  float v22; // s0
  int v23; // r0
  CVehicle *m_pMyVehicle; // r11
  bool v25; // zf
  CPlayerPed *PlayerPed; // r0
  bool v27; // zf
  int v28; // r0
  uint8 *p_m_colour2; // r1
  CRGBA v30; // r0
  CRGBA v31; // r0
  float v32; // r0
  float v33; // s31
  float Height; // s16
  float v35; // s23
  float v36; // s2
  float v37; // s16
  float v38; // s23
  GxtChar *v39; // r0
  CRGBA v40; // r0
  GxtChar *v41; // r0
  float v42; // s16
  float v43; // s27
  float v44; // s16
  GxtChar *v45; // r0
  CRGBA v46; // r0
  CRGBA v47; // r0
  float v48; // r0
  float v49; // s16
  float left; // s18
  float v51; // s16
  GxtChar *v52; // r0
  float StringWidth; // r0
  float v54; // s0
  float v55; // r0
  float screenHeight; // s20
  float v57; // s0
  GxtChar *v58; // r0
  bool *p_m_bShowThumbs; // [sp+44h] [bp-494h]
  CRGBA v60; // [sp+48h] [bp-490h] BYREF
  CRGBA v61; // [sp+4Ch] [bp-48Ch] BYREF
  CRGBA v62; // [sp+50h] [bp-488h] BYREF
  CRect Rectangle; // [sp+250h] [bp-288h] BYREF
  CRGBA v64; // [sp+450h] [bp-88h] BYREF
  CRGBA v65; // [sp+454h] [bp-84h] BYREF
  CRGBA v66; // [sp+458h] [bp-80h] BYREF
  CRect v67; // [sp+45Ch] [bp-7Ch] BYREF
  CRGBA v68; // [sp+46Ch] [bp-6Ch] BYREF
  CRGBA v69; // [sp+470h] [bp-68h] BYREF

  CFont::RenderFontBuffer();
  right = this->m_RectScreen.right;
  Rectangle.left = this->m_RectScreen.left;
  Rectangle.right = right;
  Rectangle.bottom = 0.0;
  Rectangle.top = (float)RsGlobal.screenHeight;
  CRGBA::CRGBA(&v62, 0, 0, 0, 0xFFu);
  CRGBA::CRGBA((CRGBA *)&v67, 0, 0, 0, 0x64u);
  CRGBA::CRGBA(&v69, 0, 0, 0, 0xFFu);
  CRGBA::CRGBA(&v68, 0, 0, 0, 0x64u);
  CSprite2d::DrawRect(&Rectangle, &v62, (const CRGBA *)&v67, &v69, v7);
  CFont::SetBackground(0, 0);
  CFont::SetWrapx((float)RsGlobal.screenWidth);
  CFont::SetOrientation(1u);
  CFont::SetCentreSize((float)((float)RsGlobal.screenWidth / 640.0) * 640.0);
  CFont::SetProportional(1u);
  CFont::SetEdge(1);
  CWidgetList::Draw(this);
  screenWidth = RsGlobal.screenWidth;
  p_m_fRowHeight = &this->m_fRowHeight;
  m_fRowHeight = this->m_fRowHeight;
  CWidget::SetScissor(&this->m_RectScissor);
  v11 = *(int *)((char *)&elf_hash_chain[1746] + (_DWORD)this);
  if ( v11 <= 0 )
  {
    p_m_fTextScale = &this->m_fTextScale;
    p_m_RectClient = &this->m_RectClient;
  }
  else
  {
    p_m_bShowThumbs = &this->m_bShowThumbs;
    m_szItemPrice = this->m_ItemData[0].m_szItemPrice;
    v13 = 0;
    p_m_fTextScale = &this->m_fTextScale;
    p_m_RectClient = &this->m_RectClient;
    p_bottom = &this->m_RectClient.bottom;
    v17 = m_fRowHeight * 0.875;
    v18 = (float)((float)screenWidth / 640.0) * 3.0;
    do
    {
      v19 = v13++;
      v20 = *p_bottom + (float)(*p_m_fRowHeight * (float)v19);
      if ( v20 > (float)((float)(this->m_RectScreen.bottom - *p_m_fRowHeight) + 2.0)
        && (float)(*p_bottom + (float)(*p_m_fRowHeight * (float)v13)) < (float)((float)(*p_m_fRowHeight
                                                                                      + this->m_RectScreen.top)
                                                                              + -2.0) )
      {
        AlphaAtIndex = CWidgetList::GetAlphaAtIndex(this, v19);
        v3.n64_f32[0] = v18 + p_m_RectClient->left;
        v2.n64_f32[0] = (float)RsGlobal.screenWidth * 0.0;
        v4.n64_f32[0] = v17 + v3.n64_f32[0];
        v22 = v20 + (float)((float)(*p_m_fRowHeight - v17) * 0.5);
        v3.n64_u64[0] = vmax_f32(v3, v2).n64_u64[0];
        v2.n64_f32[0] = v17 + v2.n64_f32[0];
        LODWORD(v67.left) = v3.n64_u32[0];
        v2.n64_u64[0] = vmax_f32(v4, v2).n64_u64[0];
        LODWORD(v67.right) = v2.n64_u32[0];
        v67.bottom = v22;
        v67.top = v17 + v22;
        m_pMyVehicle = (CVehicle *)(m_szItemPrice + 128);
        v23 = *((_DWORD *)m_szItemPrice + 32);
        v25 = v23 == 0;
        if ( v23 )
          v25 = !*p_m_bShowThumbs;
        if ( !v25 )
        {
          if ( m_szItemPrice[152] )
          {
            CRGBA::CRGBA(
              (CRGBA *)&Rectangle,
              0,
              0,
              0,
              (unsigned int)(float)(AlphaAtIndex
                                  * (float)((float)((float)m_szItemPrice[151] / 255.0)
                                          * (float)this->m_Color._anon_0._anon_0.alpha)));
            CSprite2d::DrawRect(&v67, (const CRGBA *)&Rectangle);
            v67.left = v18 + v67.left;
            v67.top = v67.top - v18;
            v67.right = v67.right - v18;
            v67.bottom = v18 + v67.bottom;
          }
          if ( !strcasecmp((const char *)m_szItemPrice - 128, "CARCOL1")
            || !strcasecmp((const char *)m_szItemPrice - 128, "CARCOL2") )
          {
            PlayerPed = FindPlayerPed(0);
            v27 = PlayerPed == 0;
            if ( PlayerPed )
            {
              m_pMyVehicle = PlayerPed->m_pMyVehicle;
              v27 = m_pMyVehicle == 0;
            }
            if ( !v27 )
            {
              v28 = strcasecmp((const char *)m_szItemPrice - 128, "CARCOL1");
              p_m_colour2 = &m_pMyVehicle->m_colour2;
              if ( !v28 )
                p_m_colour2 = &m_pMyVehicle->m_colour1;
              CRGBA::CRGBA(
                (CRGBA *)&Rectangle,
                CVehicleModelInfo::ms_vehicleColourTable[*p_m_colour2]._anon_0._anon_0.red,
                CVehicleModelInfo::ms_vehicleColourTable[*p_m_colour2]._anon_0._anon_0.green,
                CVehicleModelInfo::ms_vehicleColourTable[*p_m_colour2]._anon_0._anon_0.blue,
                (unsigned int)(float)(AlphaAtIndex
                                    * (float)((float)((float)m_szItemPrice[151] / 255.0)
                                            * (float)this->m_Color._anon_0._anon_0.alpha)));
              CSprite2d::DrawRect(&v67, (const CRGBA *)&Rectangle);
            }
          }
          else
          {
            CRGBA::CRGBA(
              (CRGBA *)&Rectangle,
              (unsigned int)(float)((float)((float)m_szItemPrice[148] / 255.0) * (float)this->m_Color._anon_0._anon_0.red),
              (unsigned int)(float)((float)((float)m_szItemPrice[149] / 255.0)
                                  * (float)this->m_Color._anon_0._anon_0.green),
              (unsigned int)(float)((float)((float)m_szItemPrice[150] / 255.0)
                                  * (float)this->m_Color._anon_0._anon_0.blue),
              (unsigned int)(float)(AlphaAtIndex
                                  * (float)((float)((float)m_szItemPrice[151] / 255.0)
                                          * (float)this->m_Color._anon_0._anon_0.alpha)));
            CSprite2d::Draw(
              (CSprite2d *)m_szItemPrice + 32,
              &v67,
              (const CRGBA *)&Rectangle,
              *((float *)m_szItemPrice + 33),
              *((float *)m_szItemPrice + 36),
              *((float *)m_szItemPrice + 35),
              *((float *)m_szItemPrice + 36),
              *((float *)m_szItemPrice + 33),
              *((float *)m_szItemPrice + 34),
              *((float *)m_szItemPrice + 35),
              *((float *)m_szItemPrice + 34));
          }
        }
        CRGBA::CRGBA(
          &v66,
          0xFFu,
          0xFFu,
          0xFFu,
          (unsigned int)(float)(AlphaAtIndex * (float)this->m_Color._anon_0._anon_0.alpha));
        CFont::SetColor(v30);
        CRGBA::CRGBA(&v65, 0, 0, 0, (unsigned int)(float)(AlphaAtIndex * (float)this->m_Color._anon_0._anon_0.alpha));
        CFont::SetDropColor(v31);
        CFont::SetFontStyle(2u);
        p_m_fTextScale = &this->m_fTextScale;
        v32 = *p_m_fRowHeight * 0.0225;
        this->m_fTextScale = v32;
        CFont::SetScale(v32);
        CWidgetList::ShrinkTextToFit(this, (float)(this->m_RectClient.right - v67.right) - (float)(v18 * 4.0));
        v33 = v17 * 0.5;
        if ( *p_m_bShowThumbs )
          v33 = v17;
        if ( !strcasecmp((const char *)m_szItemPrice, (const char *)&off_2BB708) )
        {
          v42 = *p_m_fRowHeight * 0.5;
          v43 = (float)(v20 + v42) - (float)(CFont::GetHeight(0) * 0.5);
          v44 = (float)(v18 + v18) + (float)(v33 + v67.left);
          v45 = CText::Get(&TheText, m_szItemPrice - 128);
          CFont::PrintString(v44, v43, v45);
          CFont::RenderFontBuffer();
        }
        else
        {
          Height = CFont::GetHeight(0);
          v35 = v20 + (float)(*p_m_fRowHeight * 0.5);
          v36 = v35 - CFont::GetHeight(0);
          v37 = Height * 0.1;
          v38 = v18 + (float)(v33 + v67.left);
          v39 = CText::Get(&TheText, m_szItemPrice - 128);
          CFont::PrintString(v38, v36 - v37, v39);
          CFont::RenderFontBuffer();
          CRGBA::CRGBA(
            &v64,
            0x51u,
            0x9Cu,
            0x42u,
            (unsigned int)(float)(AlphaAtIndex * (float)this->m_Color._anon_0._anon_0.alpha));
          CFont::SetColor(v40);
          v41 = CText::Get(&TheText, "DOLLAR");
          GxtCharStrcpy((GxtChar *)&Rectangle, v41);
          AsciiToGxtChar(m_szItemPrice, (GxtChar *)&v62);
          GxtCharStrcat((GxtChar *)&Rectangle, (GxtChar *)&v62);
          CFont::PrintString(
            v18 + (float)(v33 + v67.left),
            v37 + (float)(v20 + (float)(*p_m_fRowHeight * 0.5)),
            (GxtChar *)&Rectangle);
        }
        p_bottom = &this->m_RectClient.bottom;
        p_m_RectClient = &this->m_RectClient;
        v11 = *(int *)((char *)&elf_hash_chain[1746] + (_DWORD)this);
      }
      m_szItemPrice += 284;
    }
    while ( v13 < v11 );
  }
  CFont::RenderFontBuffer();
  memset(&Rectangle, 0, sizeof(Rectangle));
  CWidget::SetScissor(&Rectangle);
  CFont::SetFontStyle(0);
  CRGBA::CRGBA(&v61, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
  CFont::SetColor(v46);
  CRGBA::CRGBA(&v60, 0, 0, 0, 0xFFu);
  CFont::SetDropColor(v47);
  v48 = *p_m_fRowHeight * 0.08;
  v49 = (float)RsGlobal.screenWidth;
  left = p_m_RectClient->left;
  *p_m_fTextScale = v48;
  CFont::SetScale(v48);
  v2.n64_f32[0] = v49 * 0.0;
  v1.n64_f32[0] = left + (float)((float)(v49 / 640.0) * 5.0);
  LODWORD(v51) = vmax_f32(v1, v2).n64_u32[0];
  v52 = CText::Get(&TheText, this->m_szTitle);
  if ( v52 )
  {
    StringWidth = CFont::GetStringWidth(v52, 1u, 0);
    v54 = (float)(this->m_RectClient.right - v51) + (float)((float)((float)RsGlobal.screenWidth / -640.0) * 10.0);
    if ( StringWidth > v54 )
    {
      v55 = (float)(v54 / StringWidth) * *p_m_fTextScale;
      *p_m_fTextScale = v55;
      CFont::SetScale(v55);
    }
  }
  screenHeight = (float)RsGlobal.screenHeight;
  v57 = CFont::GetHeight(0) * -0.5;
  v58 = CText::Get(&TheText, this->m_szTitle);
  CFont::PrintString(v51, (float)(screenHeight * 0.1) + v57, v58);
  CFont::RenderFontBuffer();
}
// 2BAF88: variable 'v7' is possibly undefined
// 2BB14A: variable 'v3' is possibly undefined
// 2BB14A: variable 'v2' is possibly undefined
// 2BB15A: variable 'v4' is possibly undefined
// 2BB3B8: variable 'v30' is possibly undefined
// 2BB3E4: variable 'v31' is possibly undefined
// 2BB4C0: variable 'v40' is possibly undefined
// 2BB5B4: variable 'v46' is possibly undefined
// 2BB5C6: variable 'v47' is possibly undefined
// 2BB61C: variable 'v1' is possibly undefined
// 10168: using guessed type int elf_hash_chain[22025];
// 2BB708: using guessed type __int16 *off_2BB708;

//----- (002BB740) --------------------------------------------------------
void CWidgetListShop::LoadFromFile()
{
  int v0; // r5
  CRect *p_m_RectUVs; // r4
  CRGBA *v2; // r0
  u_native v3; // r4
  char *v4; // r8
  int v5; // r10
  const char *Line; // r0
  const char *v7; // r11
  int v8; // r6
  SFileEntry *v9; // r5
  int v10; // r8
  int v11; // r5
  int v12; // r11
  SFileEntry *v13; // r6
  RwUInt8 green; // r9
  int v15; // r0
  unsigned __int64 v16; // [sp+24h] [bp-3E4h]
  char *v17; // [sp+2Ch] [bp-3DCh]
  CRGBA v18; // [sp+54h] [bp-3B4h] BYREF
  __int64 red; // [sp+58h] [bp-3B0h] BYREF
  __int64 blue; // [sp+60h] [bp-3A8h] BYREF
  __int64 v21; // [sp+68h] [bp-3A0h] BYREF
  __int64 v22; // [sp+70h] [bp-398h] BYREF
  char v23[80]; // [sp+78h] [bp-390h] BYREF
  CRGBA v24; // [sp+C8h] [bp-340h]
  bool v25; // [sp+CCh] [bp-33Ch]
  char v26[256]; // [sp+D0h] [bp-338h] BYREF
  char v27[256]; // [sp+1D0h] [bp-238h] BYREF
  CRGBA v28[65]; // [sp+2D0h] [bp-138h] BYREF

  v0 = 800;
  p_m_RectUVs = &CWidgetListShop::m_FileEntry[0].m_RectUVs;
  v2 = v28;
  do
  {
    LOBYTE(p_m_RectUVs[-2].left) = 0;
    LOBYTE(p_m_RectUVs[-4].left) = 0;
    *(_QWORD *)&p_m_RectUVs->left = loc_2BB9E0;
    *(_QWORD *)&p_m_RectUVs->right = loc_2BB9E8;
    CRGBA::CRGBA(v2, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
    --v0;
    LODWORD(p_m_RectUVs[1].left) = v28[0];
    LOBYTE(p_m_RectUVs[1].top) = 0;
    p_m_RectUVs = (CRect *)((char *)p_m_RectUVs + 88);
  }
  while ( v0 );
  CFileMgr::SetDir("data");
  v3 = CFileMgr::OpenFile("ShopUVs.dat", "r");
  CFileMgr::SetDir((const unsigned __int8 *)&byte_61CADE);
  v4 = (char *)&blue + 4;
  v5 = 0;
  while ( 1 )
  {
    Line = (const char *)CFileLoader::LoadLine(v3);
    v7 = Line;
    if ( !Line )
      break;
    if ( *Line && !strchr(Line, 59) )
    {
      memset(v28, 0, 0x100u);
      memset(v27, 0, sizeof(v27));
      v21 = 0LL;
      v22 = 0x3F8000003F800000LL;
      red = unk_60EDA8;
      blue = unk_60EDB0;
      memset(v26, 0, sizeof(v26));
      v17 = v4;
      sscanf(
        v7,
        "%s %s %f %f %f %f %d %d %d %d %s",
        v28,
        v27,
        &v21,
        (char *)&v21 + 4,
        &v22,
        (char *)&v22 + 4,
        &red,
        (char *)&red + 4,
        &blue,
        v4,
        v26);
      if ( v5 >= 1 )
      {
        v8 = 0;
        v9 = CWidgetListShop::m_FileEntry;
        while ( strcasecmp((const char *)v9, (const char *)v28) )
        {
          ++v8;
          ++v9;
          if ( v8 >= v5 )
            goto LABEL_11;
        }
LABEL_13:
        v15 = 1;
        goto LABEL_14;
      }
LABEL_11:
      v10 = v21;
      v11 = HIDWORD(v22);
      v16 = __PAIR64__(HIDWORD(v21), v22);
      CRGBA::CRGBA(&v18, red, BYTE4(red), blue, BYTE4(blue));
      v12 = strcasecmp(v26, "TRUE");
      strcpy(v23, (const char *)v28);
      strcpy(&v23[32], v27);
      v13 = &CWidgetListShop::m_FileEntry[v5];
      *(_DWORD *)&v23[64] = v10;
      *(_DWORD *)&v23[68] = v11;
      *(_QWORD *)&v23[72] = v16;
      LOBYTE(v11) = v12 == 0;
      v25 = v12 == 0;
      BYTE4(v16) = v18._anon_0._anon_0.red;
      v24 = v18;
      green = v18._anon_0._anon_0.green;
      LOBYTE(v10) = v18._anon_0._anon_0.blue;
      LOBYTE(v12) = v18._anon_0._anon_0.alpha;
      qmemcpy(v13, v23, 0x50u);
      ++v5;
      v13->m_Color._anon_0._anon_0.blue = v10;
      v13->m_Color._anon_0._anon_0.green = green;
      v13->m_Color._anon_0._anon_0.alpha = v12;
      v13->m_Color._anon_0._anon_0.red = BYTE4(v16);
      v13->m_bBorder = v11;
      if ( v5 != 800 )
        goto LABEL_13;
      v5 = 800;
      v15 = 0;
LABEL_14:
      v4 = v17;
      if ( !v15 )
        break;
    }
  }
  CFileMgr::CloseFile(v3);
}
// 2BB792: variable 'v2' is possibly undefined
// 60ED98: using guessed type __int128 xmmword_60ED98;
// 61CADE: using guessed type char byte_61CADE;

//----- (002BBA6C) --------------------------------------------------------
void __fastcall CWidgetListShop::AssignImage(CWidgetListShop *this, int nIndex)
{
  ItemData *v4; // r6
  int v5; // r5
  bool *p_m_bBorder; // r4
  char *v7; // r5
  __int64 v8; // d17

  v4 = &this->m_ItemData[nIndex];
  CTouchInterface::LoadAllTextureDBs();
  v5 = -1;
  p_m_bBorder = &CWidgetListShop::m_FileEntry[0].m_bBorder;
  while ( strcasecmp((const char *)p_m_bBorder - 84, (const char *)v4) )
  {
    ++v5;
    p_m_bBorder += 88;
    if ( v5 >= 799 )
      goto LABEL_6;
  }
  v7 = (char *)this + 284 * nIndex;
  CSprite2d::SetTexture((CSprite2d *)v7 + 100, (unsigned __int8 *)p_m_bBorder - 52);
  v8 = *(_QWORD *)(p_m_bBorder - 12);
  *(_QWORD *)(v7 + 404) = *(_QWORD *)(p_m_bBorder - 20);
  *(_QWORD *)(v7 + 412) = v8;
  v7[420] = *(p_m_bBorder - 4);
  v7[421] = *(p_m_bBorder - 3);
  v7[422] = *(p_m_bBorder - 2);
  v7[423] = *(p_m_bBorder - 1);
  v7[424] = *p_m_bBorder;
LABEL_6:
  sub_19185C();
}

//----- (002BBB0C) --------------------------------------------------------
void __fastcall CWidgetListShop::AddItem(
        CWidgetListShop *this,
        const unsigned __int8 *pszItemName,
        const unsigned __int8 *pszItemPrice)
{
  if ( pszItemName && !strcasecmp("REMCLT", (const char *)pszItemName) )
    *((_BYTE *)&elf_hash_chain[1826] + (_DWORD)this) = 0;
  CWidgetList::AddItem(this, pszItemName, pszItemPrice);
  CWidgetListShop::AssignImage(this, *(int *)((char *)&elf_hash_chain[1746] + (_DWORD)this) - 1);
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (002BBB5C) --------------------------------------------------------
void __fastcall CWidgetListShop::~CWidgetListShop(CWidgetListShop *this)
{
  int *v2; // r5
  void *v3; // r0

  v2 = &elf_hash_chain[1731];
  this->_vptr$CWidget = (int (**)(void))&off_663E08;
  do
  {
    CSprite2d::~CSprite2d((CSprite2d *)((char *)v2 + (_DWORD)this));
    v2 -= 71;
  }
  while ( v2 != &dword_74 );
  CWidget::~CWidget(this);
  sub_191374(v3);
}
// 2BBB8C: variable 'v3' is possibly undefined
// 74: using guessed type int dword_74;
// 10168: using guessed type int elf_hash_chain[22025];
// 663E08: using guessed type void *off_663E08;

//----- (002BBB94) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetListShop::GetName(CWidgetListShop *this)
{
  return "ListShop";
}

//----- (002BBBA4) --------------------------------------------------------
void __fastcall CWidgetListText::CWidgetListText(
        CWidgetListText *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos,
        const unsigned __int8 **pszEntries,
        int nNumEntries,
        int bAlphabetize,
        bool bLocalize,
        bool bShowNumbers)
{
  CWidgetList::CWidgetList(this, pszSprite, WidgetPos, pszEntries, nNumEntries, bAlphabetize, bLocalize, bShowNumbers);
  JUMPOUT(0x2BBBC4);
}
// 2BBBC2: control flows out of bounds to 2BBBC4
// 2BBBA4: using guessed type int bAlphabetize;

//----- (002BBC30) --------------------------------------------------------
void __fastcall CWidgetListText::Update(CWidgetListText *this)
{
  CWidgetList::Update(this);
  CWidgetListText::m_fLastScroll = *(float *)((char *)&elf_hash_chain[1748] + (_DWORD)this);
}
// 10168: using guessed type int elf_hash_chain[22025];

//----- (002BBC54) --------------------------------------------------------
void __fastcall CWidgetListText::Draw(CWidgetListText *this)
{
  int v2; // r0
  float *p_m_fRowHeight; // r10
  float *p_bottom; // r9
  ItemData *m_ItemData; // r5
  int v6; // r6
  int v7; // r1
  float v8; // s17
  float AlphaAtIndex; // r11
  CRGBA v10; // r0
  CRGBA v11; // r0
  float v12; // s19
  float v13; // s0
  GxtChar *v14; // r0
  float v15; // s2
  float v16; // s17
  float v17; // s21
  float v18; // s17
  float v19; // r1
  float v20; // s0
  CRect *p_m_RectClient; // [sp+20h] [bp-1A8h]
  bool *p_m_bShowNumbers; // [sp+24h] [bp-1A4h]
  GxtChar pOutput[16]; // [sp+28h] [bp-1A0h] BYREF
  CRect Dest[16]; // [sp+48h] [bp-180h] BYREF
  CRGBA v25; // [sp+14Ch] [bp-7Ch] BYREF
  CRGBA v26; // [sp+150h] [bp-78h] BYREF
  unsigned __int8 s[16]; // [sp+154h] [bp-74h] BYREF

  CWidgetList::Draw(this);
  CWidget::SetScissor(&this->m_RectScissor);
  v2 = *(int *)((char *)&elf_hash_chain[1746] + (_DWORD)this);
  if ( v2 >= 1 )
  {
    p_m_RectClient = &this->m_RectClient;
    p_m_bShowNumbers = &this->m_bShowNumbers;
    p_m_fRowHeight = &this->m_fRowHeight;
    p_bottom = &this->m_RectClient.bottom;
    m_ItemData = this->m_ItemData;
    v6 = 0;
    do
    {
      v7 = v6++;
      v8 = (float)v7;
      if ( (float)(*p_bottom + (float)(*p_m_fRowHeight * (float)v7)) > (float)((float)(this->m_RectScreen.bottom
                                                                                     - *p_m_fRowHeight)
                                                                             + 2.0)
        && (float)(*p_bottom + (float)(*p_m_fRowHeight * (float)v6)) < (float)((float)(*p_m_fRowHeight
                                                                                     + this->m_RectScreen.top)
                                                                             + -2.0) )
      {
        AlphaAtIndex = CWidgetList::GetAlphaAtIndex(this, v7);
        CFont::SetWrapx((float)RsGlobal.screenWidth);
        CFont::SetFontStyle(1u);
        CFont::SetBackground(0, 0);
        CFont::SetScale(this->m_fTextScale);
        CFont::SetOrientation(1u);
        CFont::SetCentreSize((float)((float)RsGlobal.screenWidth / 640.0) * 640.0);
        CFont::SetProportional(1u);
        CRGBA::CRGBA(
          &v26,
          0xFFu,
          0xFFu,
          0xFFu,
          (unsigned int)(float)(AlphaAtIndex * (float)this->m_Color._anon_0._anon_0.alpha));
        CFont::SetColor(v10);
        CRGBA::CRGBA(&v25, 0, 0, 0, (unsigned int)(float)(AlphaAtIndex * (float)this->m_Color._anon_0._anon_0.alpha));
        CFont::SetDropColor(v11);
        CFont::SetEdge(0);
        v12 = CFont::GetCharacterSize(0x39u, 0) * 3.0;
        v13 = fabsf(this->m_RectClient.right - p_m_RectClient->left);
        if ( v12 < 10.0 )
          v12 = 30.0;
        if ( *p_m_bShowNumbers )
          v13 = v13 - v12;
        CWidgetList::ShrinkTextToFit(this, v13 + -2.0);
        if ( this->m_bLocalize )
        {
          v14 = CText::Get(&TheText, m_ItemData->m_szItemName);
          GxtCharStrcpy((GxtChar *)Dest, v14);
        }
        else
        {
          AsciiToGxtChar(m_ItemData->m_szItemName, (GxtChar *)Dest);
        }
        v15 = *p_m_fRowHeight * v8;
        v16 = *p_m_fRowHeight * 0.5;
        v17 = *p_bottom + v15;
        v18 = (float)(v16 + v17) - (float)(CFont::GetHeight(0) * 0.5);
        if ( *p_m_bShowNumbers )
        {
          sprintf(s, (const unsigned __int8 *)&dword_2BBF78, v6);
          AsciiToGxtChar(s, pOutput);
          p_bottom = &this->m_RectClient.bottom;
          CFont::PrintString(p_m_RectClient->left + 1.0, v18, pOutput);
          v19 = v18;
          v20 = v12 + (float)(p_m_RectClient->left + 1.0);
        }
        else
        {
          v19 = v18;
          v20 = p_m_RectClient->left + 1.0;
        }
        CFont::PrintString(v20, v19, (GxtChar *)Dest);
        v2 = *(int *)((char *)&elf_hash_chain[1746] + (_DWORD)this);
      }
      ++m_ItemData;
    }
    while ( v6 < v2 );
  }
  CFont::RenderFontBuffer();
  memset(Dest, 0, 16);
  CWidget::SetScissor(Dest);
}
// 2BBDEA: variable 'v10' is possibly undefined
// 2BBE14: variable 'v11' is possibly undefined
// 10168: using guessed type int elf_hash_chain[22025];
// 2BBF78: using guessed type int dword_2BBF78;

//----- (002BBF80) --------------------------------------------------------
void __fastcall CWidgetListText::~CWidgetListText(CWidgetListText *this)
{
  int *v2; // r5
  void *v3; // r0

  v2 = &elf_hash_chain[1731];
  this->_vptr$CWidget = (int (**)(void))&off_663E08;
  do
  {
    CSprite2d::~CSprite2d((CSprite2d *)((char *)v2 + (_DWORD)this));
    v2 -= 71;
  }
  while ( v2 != &dword_74 );
  CWidget::~CWidget(this);
  sub_191374(v3);
}
// 2BBFB0: variable 'v3' is possibly undefined
// 74: using guessed type int dword_74;
// 10168: using guessed type int elf_hash_chain[22025];
// 663E08: using guessed type void *off_663E08;

//----- (002BBFB8) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetListText::GetName(CWidgetListText *this)
{
  return "ListText";
}

//----- (002BBFC8) --------------------------------------------------------
void __fastcall CWidgetMap::CWidgetMap(
        CWidgetMap *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  _DWORD *v3; // r0

  CWidget::CWidget(this, pszSprite, WidgetPos, 4u, HID_MAPPING_UNKNOWN);
  *v3 = &off_663FD0;
}
// 2BBFE0: variable 'v3' is possibly undefined
// 663FD0: using guessed type void *;

//----- (002BBFEC) --------------------------------------------------------
bool __fastcall CWidgetMap::IsTouched(CWidgetMap *this, CVector2D *pVecOut)
{
  CVector2D v5; // [sp+0h] [bp-10h] BYREF

  if ( pVecOut )
  {
    CTouchInterface::GetTouchDelta(&v5, this->m_nTouchIndex);
    *pVecOut = v5;
  }
  return this == CWidget::m_pInitialTouchWidget[this->m_nTouchIndex];
}

//----- (002BC024) --------------------------------------------------------
void __fastcall CWidgetMap::~CWidgetMap(CWidgetMap *this)
{
  void *v1; // r0

  CWidget::~CWidget(this);
  sub_191374(v1);
}
// 2BC030: variable 'v1' is possibly undefined

//----- (002BC034) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetMap::GetName(CWidgetMap *this)
{
  return (_BYTE *)dword_2BC038;
}
// 2BC038: using guessed type int[2];

//----- (002BC040) --------------------------------------------------------
void __fastcall CWidgetMissionTimers::CWidgetMissionTimers(
        CWidgetMissionTimers *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  _DWORD *v3; // r0

  CWidget::CWidget(this, pszSprite, WidgetPos, 4u, HID_MAPPING_UNKNOWN);
  *v3 = &off_664064;
}
// 2BC058: variable 'v3' is possibly undefined
// 664064: using guessed type void *;

//----- (002BC064) --------------------------------------------------------
void __fastcall CWidgetMissionTimers::Update(CWidgetMissionTimers *this)
{
  CWidget *v2; // r5
  Char *ScriptName; // r5
  float v4; // r0
  float v5; // r1
  float fScaleY; // [sp+8h] [bp-18h] BYREF
  float fScaleX; // [sp+Ch] [bp-14h] BYREF
  float fOriginY; // [sp+10h] [bp-10h] BYREF
  unsigned int fOriginX[3]; // [sp+14h] [bp-Ch] BYREF

  if ( CHud::bDrawingVitalStats )
    CWidget::SetEnabled(this, 0);
  v2 = CTouchInterface::m_pWidgets[105];
  if ( CTouchInterface::m_pWidgets[105]
    && CWidget::GetEnabled(CTouchInterface::m_pWidgets[105])
    && this->m_RectScreen.right > v2->m_RectScreen.left )
  {
    CWidget::SetEnabled(this, 0);
  }
  fOriginY = 0.0;
  fOriginX[0] = 0;
  fScaleY = 0.0;
  fScaleX = 0.0;
  CTouchInterface::GetWidgetPosition(WIDGET_POSITION_MISSION_TIMERS, (float *)fOriginX, &fOriginY, &fScaleX, &fScaleY);
  if ( CTheScripts::pActiveScripts )
  {
    ScriptName = CTheScripts::pActiveScripts->ScriptName;
    if ( !strcasecmp((const char *)CTheScripts::pActiveScripts->ScriptName, "gymls")
      || !strcasecmp((const char *)ScriptName, "gymbike")
      || !strcasecmp((const char *)ScriptName, "gymdumb") )
    {
      *(float *)fOriginX = fScaleX + 10.0;
      fOriginY = fScaleY + 10.0;
    }
  }
  v4 = fScaleY;
  v5 = fScaleX;
  *(_QWORD *)&this->m_fOriginX = __PAIR64__(LODWORD(fOriginY), fOriginX[0]);
  this->m_fScaleX = v5;
  this->m_fScaleY = v4;
  CWidget::Update(this);
  CWidget::ManageAlpha(this);
}
// 2BC064: using guessed type unsigned int fOriginX[3];

//----- (002BC158) --------------------------------------------------------
void __fastcall CWidgetMissionTimers::Draw(CWidgetMissionTimers *this)
{
  __int64 v1; // d8
  __int64 v2; // d9
  __int64 v3; // d10
  __int64 v4; // d11
  __int64 v5; // d12
  __int64 v6; // d13
  __int64 v7; // d14
  __int64 v8; // d15
  GxtChar *v9; // r5
  GxtChar *v10; // r4
  int v11; // r10
  char *v12; // r1
  char *v13; // r1
  int v14; // r8
  GxtChar *v15; // r0
  int i; // r6
  GxtChar *v17; // r0
  int v18; // r0
  uint8 iColour_id; // r2
  char *v20; // r1
  int v21; // r1
  unsigned __int8 *CounterString; // r0
  int v23; // r0
  const char *v24; // r1
  GxtChar *v25; // r0
  unsigned int alpha; // r4
  float v27; // s16
  float v28; // s20
  GxtChar *v29; // r5
  GxtChar *v30; // r6
  float v31; // s18
  int v32; // r4
  float v33; // s28
  float StringWidth; // r0
  float left; // s28
  float right; // s30
  float v37; // r0
  float v38; // s0
  float v39; // r0
  float v40; // r1
  float v41; // s20
  int v42; // r11
  float v43; // s26
  float v44; // s28
  float bottom; // s30
  const CRGBA *v46; // r0
  CRGBA v47; // r0
  CRGBA v48; // r0
  float v49; // s21
  float Height; // r0
  CRGBA v51; // r0
  float v52; // s21
  float v53; // r0
  float v54; // s19
  float v55; // s21
  float v56; // s23
  double v57; // d16
  GxtChar *v59; // [sp+68h] [bp-14E8h]
  CHudColours *v60; // [sp+6Ch] [bp-14E4h]
  GxtChar *pCharacters; // [sp+70h] [bp-14E0h]
  CRGBA v62; // [sp+74h] [bp-14DCh] BYREF
  int c; // [sp+78h] [bp-14D8h] BYREF
  CRGBA v64; // [sp+7Ch] [bp-14D4h] BYREF
  CRGBA v65; // [sp+80h] [bp-14D0h] BYREF
  CRGBA v66; // [sp+84h] [bp-14CCh] BYREF
  CRGBA v67; // [sp+88h] [bp-14C8h] BYREF
  CRGBA v68; // [sp+8Ch] [bp-14C4h] BYREF
  CRGBA v69; // [sp+90h] [bp-14C0h] BYREF
  CRGBA v70; // [sp+94h] [bp-14BCh] BYREF
  CRect v71[4]; // [sp+98h] [bp-14B8h] BYREF
  GxtChar v72[1280]; // [sp+E4h] [bp-146Ch] BYREF
  GxtChar pOutput[1282]; // [sp+AE4h] [bp-A6Ch] BYREF
  __int64 v74; // [sp+14E8h] [bp-68h]
  __int64 v75; // [sp+14F0h] [bp-60h]
  __int64 v76; // [sp+14F8h] [bp-58h]
  __int64 v77; // [sp+1500h] [bp-50h]
  __int64 v78; // [sp+1508h] [bp-48h]
  __int64 v79; // [sp+1510h] [bp-40h]
  __int64 v80; // [sp+1518h] [bp-38h]
  __int64 v81; // [sp+1520h] [bp-30h]

  if ( !this->m_Color._anon_0._anon_0.alpha )
    return;
  v74 = v1;
  v75 = v2;
  v76 = v3;
  v77 = v4;
  v78 = v5;
  v79 = v6;
  v80 = v7;
  v81 = v8;
  v9 = pOutput;
  v10 = v72;
  v11 = 0;
  do
  {
    AsciiToGxtChar((const Char *)&byte_61CADE, v9);
    AsciiToGxtChar((const Char *)&byte_61CADE, v10);
    CRGBA::CRGBA((CRGBA *)v71, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
    v12 = (char *)&v71[3].right + v11;
    *((_BYTE *)&v71[3].right + v11) = LOBYTE(v71[0].left);
    *(_WORD *)(v12 + 1) = *(_WORD *)((char *)&v71[0].left + 1);
    v12[3] = HIBYTE(v71[0].left);
    *(float *)((char *)&v71[2].top + v11) = 0.0;
    CRGBA::CRGBA((CRGBA *)v71, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
    v13 = (char *)&v71[1] + v11;
    *((_BYTE *)&v71[1].left + v11) = LOBYTE(v71[0].left);
    v11 += 4;
    v10 += 256;
    v9 += 256;
    *(_WORD *)(v13 + 1) = *(_WORD *)((char *)&v71[0].left + 1);
    v13[3] = HIBYTE(v71[0].left);
  }
  while ( v11 != 20 );
  v14 = 0;
  if ( CUserDisplay::OnscnTimer.TimerEntry[0].Clock && CUserDisplay::OnscnTimer.TimerEntry[0].ClockTextKey[0] )
  {
    v15 = CText::Get(&TheText, CUserDisplay::OnscnTimer.TimerEntry[0].ClockTextKey);
    GxtCharStrcpy(pOutput, v15);
    AsciiToGxtChar(CUserDisplay::OnscnTimer.TimerEntry[0].ClockString, v72);
    v14 = 1;
  }
  for ( i = 0; i != 4; ++i )
  {
    if ( !CUserDisplay::OnscnTimer.CounterEntry[i].Counter )
      continue;
    if ( CUserDisplay::OnscnTimer.CounterEntry[i].CounterTextKey[0] )
    {
      CHudColours::GetRGBA((CRGBA *)v71, &HudColour, CUserDisplay::OnscnTimer.CounterEntry[i].iColour_id);
      *((_DWORD *)&v71[3].right + v14) = LODWORD(v71[0].left);
      v17 = CText::Get(&TheText, CUserDisplay::OnscnTimer.CounterEntry[i].CounterTextKey);
      GxtCharStrcpy(&pOutput[256 * v14], v17);
    }
    if ( CUserDisplay::OnscnTimer.CounterEntry[i].CounterDisplayMethod == 1 )
    {
      v18 = atoi((const char *)CUserDisplay::OnscnTimer.CounterEntry[i].CounterString);
      iColour_id = CUserDisplay::OnscnTimer.CounterEntry[i].iColour_id;
      *((_DWORD *)&v71[2].top + v14) = v18;
      CHudColours::GetRGBA((CRGBA *)v71, &HudColour, iColour_id);
      v20 = (char *)(&v71[1].left + v14);
      *v20 = LOBYTE(v71[0].left);
      *(_WORD *)(v20 + 1) = *(_WORD *)((char *)&v71[0].left + 1);
      v20[3] = HIBYTE(v71[0].left);
    }
    else
    {
      v21 = strcasecmp((const char *)CUserDisplay::OnscnTimer.CounterEntry[i].CounterTextKey, "GYM1_72");
      CounterString = CUserDisplay::OnscnTimer.CounterEntry[i].CounterString;
      if ( v21 )
      {
        AsciiToGxtChar(CounterString, &v72[256 * v14]);
      }
      else
      {
        v23 = atoi((const char *)CounterString);
        if ( v23 <= 159 )
        {
          switch ( v23 )
          {
            case 20:
              v24 = "GYM1_26";
              goto LABEL_39;
            case 30:
              v24 = "GYM1_27";
              goto LABEL_39;
            case 40:
              v24 = "GYM1_8";
              goto LABEL_39;
            case 50:
              v24 = "GYM1_29";
              goto LABEL_39;
            case 60:
              v24 = "GYM1_9";
              goto LABEL_39;
            case 70:
              v24 = "GYM1_31";
              goto LABEL_39;
            case 80:
              v24 = "GYM1_10";
              goto LABEL_39;
            case 90:
              v24 = "GYM1_33";
              goto LABEL_39;
            case 100:
              v24 = "GYM1_11";
              goto LABEL_39;
            case 110:
              v24 = "GYM1_35";
              goto LABEL_39;
            case 120:
              v24 = "GYM1_12";
              goto LABEL_39;
            default:
              goto LABEL_40;
          }
          goto LABEL_40;
        }
        if ( v23 <= 239 )
        {
          if ( v23 == 160 )
          {
            v24 = "GYM1_13";
          }
          else
          {
            if ( v23 != 200 )
              goto LABEL_40;
            v24 = "GYM1_14";
          }
LABEL_39:
          v25 = CText::Get(&TheText, (const unsigned __int8 *)v24);
          GxtCharStrcpy(&v72[256 * v14], v25);
          goto LABEL_40;
        }
        switch ( v23 )
        {
          case 240:
            v24 = "GYM1_15";
            goto LABEL_39;
          case 280:
            v24 = "GYM1_16";
            goto LABEL_39;
          case 320:
            v24 = "GYM1_17";
            goto LABEL_39;
        }
      }
    }
LABEL_40:
    ++v14;
  }
  CFont::SetBackground(0, 0);
  CFont::SetProportional(1u);
  CFont::SetFontStyle(2u);
  CFont::SetRightJustifyWrap(0.0);
  CFont::SetEdge(0);
  CFont::SetWrapx((float)RsGlobal.screenWidth);
  alpha = this->m_Color._anon_0._anon_0.alpha;
  v27 = (float)(fabsf(this->m_RectScreen.top - this->m_RectScreen.bottom) + -2.0) / 3.0;
  v28 = v27 * 0.0325;
  CFont::SetScale(v27 * 0.0325);
  if ( v14 >= 1 )
  {
    v29 = pOutput;
    v30 = v72;
    v31 = (float)alpha / 255.0;
    v32 = v14;
    v33 = fabsf(this->m_RectScreen.right - this->m_RectScreen.left);
    do
    {
      StringWidth = CFont::GetStringWidth(v29, 1u, 0);
      if ( StringWidth > (float)(v33 * 0.55) )
      {
        v28 = v28 * (float)((float)(v33 * 0.55) / StringWidth);
        CFont::SetScale(v28);
      }
      left = this->m_RectScreen.left;
      right = this->m_RectScreen.right;
      v37 = CFont::GetStringWidth(v30, 1u, 0);
      v38 = fabsf(right - left) * 0.425;
      if ( v37 > v38 )
      {
        v28 = v28 * (float)(v38 / v37);
        CFont::SetScale(v28);
      }
      v30 += 256;
      v29 += 256;
      --v32;
      v33 = fabsf(this->m_RectScreen.right - this->m_RectScreen.left);
    }
    while ( v32 );
    v39 = this->m_RectScreen.right;
    v40 = this->m_RectScreen.left;
    v41 = v33 * 0.03;
    v42 = 0;
    v43 = (float)(v33 * 0.03) * 0.5;
    v44 = v27 * 0.5;
    v60 = (CHudColours *)(v14 - 1);
    bottom = this->m_RectScreen.bottom;
    v59 = pOutput;
    for ( pCharacters = v72; ; pCharacters += 256 )
    {
      v71[0].bottom = bottom;
      v71[0].left = v40;
      v71[0].right = v39;
      v71[0].top = v27 + bottom;
      CRGBA::CRGBA(&v70, 0, 0, 0, (unsigned int)(float)(v31 * 128.0));
      CRGBA::CRGBA(&v69, 0, 0, 0, (unsigned int)(float)(v31 * 128.0));
      CRGBA::CRGBA(&v68, 0, 0, 0, (unsigned int)(float)(v31 * 255.0));
      CRGBA::CRGBA(&v67, 0, 0, 0, (unsigned int)(float)(v31 * 255.0));
      CSprite2d::DrawRect(v71, &v70, &v69, &v68, v46);
      CRGBA::CRGBA(
        &v66,
        *((_BYTE *)&v71[3].right + v42),
        *((_BYTE *)&v71[3].right + v42 + 1),
        *((_BYTE *)&v71[3].right + v42 + 2),
        (unsigned int)(float)(v31 * (float)*((unsigned __int8 *)&v71[3].right + v42 + 3)));
      CFont::SetColor(v47);
      CRGBA::CRGBA(&v65, 0, 0, 0, (unsigned int)(float)(v31 * 255.0));
      CFont::SetDropColor(v48);
      CFont::SetOrientation(1u);
      v49 = this->m_RectScreen.left;
      Height = CFont::GetHeight(0);
      CFont::PrintString(v41 + v49, (float)(v44 + bottom) + (float)(Height * -0.5), v59);
      if ( *pCharacters )
      {
        CFont::SetOrientation(2u);
        CRGBA::CRGBA(&v64, 0x5Du, 0x8Eu, 0xBEu, (unsigned int)(float)(v31 * 255.0));
        CFont::SetColor(v51);
        v52 = this->m_RectScreen.right;
        v53 = CFont::GetHeight(0);
        CFont::PrintString(v52 - v41, (float)(v44 + bottom) + (float)(v53 * -0.5), pCharacters);
      }
      else
      {
        v54 = this->m_RectScreen.left;
        v55 = this->m_RectScreen.right;
        v56 = (float)*(int *)((char *)&v71[2].top + v42);
        c = *(_DWORD *)((char *)&v71[1].left + v42);
        CRGBA::CRGBA(&v62, 0, 0, 0, 0);
        v57 = fabsf(v55 - v54) * 0.39;
        CSprite2d::DrawBarChart(
          (float)(int)((float)(v55 - v43) - v57),
          (float)(int)(float)((float)(v27 * 0.225) + bottom),
          (int)v57,
          (int)(float)(v27 * 0.575),
          v56,
          0,
          0,
          1,
          (CRGBA)&c,
          (CRGBA)&v62);
      }
      if ( !v60 )
        break;
      bottom = (float)(v27 + 1.0) + bottom;
      v40 = this->m_RectScreen.left;
      v42 += 4;
      v39 = this->m_RectScreen.right;
      v59 += 256;
      v60 = (CHudColours *)((char *)v60 - 1);
    }
  }
}
// 2BC700: conditional instruction was optimized away because r8.4>=1
// 2BC16C: variable 'v1' is possibly undefined
// 2BC16C: variable 'v2' is possibly undefined
// 2BC16C: variable 'v3' is possibly undefined
// 2BC16C: variable 'v4' is possibly undefined
// 2BC16C: variable 'v5' is possibly undefined
// 2BC16C: variable 'v6' is possibly undefined
// 2BC16C: variable 'v7' is possibly undefined
// 2BC16C: variable 'v8' is possibly undefined
// 2BC80A: variable 'v46' is possibly undefined
// 2BC83C: variable 'v47' is possibly undefined
// 2BC84E: variable 'v48' is possibly undefined
// 2BC8A2: variable 'v51' is possibly undefined
// 61CADE: using guessed type char byte_61CADE;
// 2BC158: using guessed type GxtChar pOutput[1282];
// 2BC158: using guessed type GxtChar var_146C[1280];

//----- (002BCAA8) --------------------------------------------------------
void __fastcall CWidgetMissionTimers::~CWidgetMissionTimers(CWidgetMissionTimers *this)
{
  void *v1; // r0

  CWidget::~CWidget(this);
  sub_191374(v1);
}
// 2BCAB4: variable 'v1' is possibly undefined

//----- (002BCAB8) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetMissionTimers::GetName(CWidgetMissionTimers *this)
{
  return "Timers";
}

//----- (002BCAD0) --------------------------------------------------------
void __fastcall CWidgetPlayerInfo::CWidgetPlayerInfo(
        CWidgetPlayerInfo *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  CRGBA v4; // [sp+4h] [bp-14h] BYREF

  CWidget::CWidget(this, pszSprite, WidgetPos, 0x402u, HID_MAPPING_VITAL_STATS);
  *(_QWORD *)&this->m_RectWeapon.left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_RectWeapon.right = 0x49742400C9742400LL;
  this->_vptr$CWidget = (int (**)(void))&off_6640F8;
  CSprite2d::CSprite2d(&this->m_SpriteSwipe);
  this->m_LastWanted = 0;
  this->m_LastBreathTime = 0;
  this->m_fSwipeLeftTime = 0.0;
  this->m_fSwipeRightTime = 0.0;
  CWidget::SetTexture(this, &this->m_SpriteSwipe, "SwipeArrow", 1);
  CRGBA::CRGBA(&v4, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
  CWidget::CreateHoldEffect(this, "SquareTick", 1, (CRGBA)&v4, 1);
  this->m_bAltDrawingMode = 0;
  this->m_fHoldEffectPeriod = 0.5;
}
// 6640F8: using guessed type void *off_6640F8;

//----- (002BCB90) --------------------------------------------------------
void __fastcall CWidgetPlayerInfo::Update(CWidgetPlayerInfo *this)
{
  float left; // s6
  float right; // s2
  float bottom; // s0
  int *v5; // r0
  float v6; // s8
  float v7; // s10
  CHoldEffect *m_pHoldEffect; // r0
  float v9; // s4
  float v10; // s10
  float v11; // s6
  float v12; // s8
  float v13; // s2
  float v14; // s6
  float v15; // s2
  float v16; // s0

  CWidget::Update(this);
  CWidget::ManageAlpha(this);
  left = this->m_RectScreen.left;
  right = this->m_RectScreen.right;
  bottom = this->m_RectScreen.bottom;
  v5 = dword_2BCC9C;
  v6 = fabsf(right - left);
  if ( CDraw::ms_fAspectRatio > 1.9 )
    v5 = &dword_2BCC9C[1];
  v7 = *(float *)v5;
  m_pHoldEffect = this->m_pHoldEffect;
  v9 = 1.0 - v7;
  v10 = v7 * v6;
  v11 = left + (float)(v6 * v9);
  this->m_RectWeapon.left = v11;
  this->m_RectWeapon.top = bottom + v10;
  this->m_RectWeapon.right = right;
  this->m_RectWeapon.bottom = bottom;
  if ( m_pHoldEffect )
  {
    v12 = right - v11;
    v13 = v11 + right;
    v14 = fabsf(v12);
    v15 = v13 * 0.5;
    v16 = (float)((float)(bottom + v10) + bottom) * 0.5;
    m_pHoldEffect->m_RectScreen.left = v15 - (float)(v14 * 0.52);
    m_pHoldEffect->m_RectScreen.top = (float)(v14 * 0.52) + v16;
    m_pHoldEffect->m_RectScreen.right = v15 + (float)(v14 * 0.52);
    m_pHoldEffect->m_RectScreen.bottom = v16 - (float)(v14 * 0.52);
    if ( this->m_fTapHoldTime >= 0.5 || CHID::Use360ClassicVitalStatsHack() == 1 )
      this->m_pHoldEffect->m_fProgress = 0.0;
  }
  this->m_bAltDrawingMode = 0;
  if ( CTouchInterface::m_pWidgets[180] )
  {
    if ( CWidget::GetEnabled(CTouchInterface::m_pWidgets[180]) )
      this->m_bAltDrawingMode = 1;
  }
}
// 2BCC9C: using guessed type int dword_2BCC9C[2];

//----- (002BCCAC) --------------------------------------------------------
bool __fastcall CWidgetPlayerInfo::CoordsAreInsideWidget(
        CWidgetPlayerInfo *this,
        const CVector2D *vecCoords,
        bool bUseExtraPaddingScale)
{
  float y; // s0
  bool result; // r0

  result = 0;
  if ( vecCoords->x >= this->m_RectWeapon.left && vecCoords->x <= this->m_RectWeapon.right )
  {
    y = vecCoords->y;
    if ( y >= this->m_RectWeapon.bottom && y <= this->m_RectWeapon.top )
      return 1;
  }
  return result;
}

//----- (002BCCF8) --------------------------------------------------------
void __fastcall CWidgetPlayerInfo::Draw(CWidgetPlayerInfo *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d8
  int m_nTouchIndex; // r1
  int v5; // r1
  CPlayerPed *PlayerPed; // r0
  CPlayerPed *v7; // r5
  eWeaponType m_eWeaponType; // r0
  bool v9; // zf
  CPlayerPedData *m_pPlayerData; // r0
  int v11; // r6
  eWeaponType v12; // r0
  bool v13; // zf
  eWeaponType v14; // r0
  bool v15; // zf
  eWeaponType v16; // r0
  bool v17; // zf
  eWeaponType v18; // r0
  bool v19; // zf
  eWeaponType v20; // r0
  bool v21; // zf
  float m_fSwipeLeftTime; // s0
  float left; // s2
  float top; // s4
  float bottom; // s8
  float v26; // s6
  float v27; // s10
  double v28; // d16
  float v29; // s0
  float right; // s4
  float v31; // s2
  float v32; // s6
  float v33; // s0
  float v34; // s8
  CPlayerPed *pPed; // r8
  uint8 v36; // r0
  float v37; // s0
  CRGBA v38; // r0
  float v39; // s0
  uint8 v40; // r0
  CRGBA v41; // r0
  CRGBA *v42; // r5
  uint8 v43; // r2
  float v44; // s0
  CHoldEffect *m_pHoldEffect; // r0
  float v46; // s0
  CVehicle *m_pMyVehicle; // r0
  bool v48; // zf
  float m_fBreath; // s16
  char v50; // [sp+10h] [bp-298h] BYREF
  char v51; // [sp+14h] [bp-294h] BYREF
  CRGBA v52; // [sp+18h] [bp-290h] BYREF
  CRGBA v53; // [sp+1Ch] [bp-28Ch] BYREF
  CRGBA v54; // [sp+20h] [bp-288h] BYREF
  CRect v55[25]; // [sp+24h] [bp-284h] BYREF
  CRGBA rgba; // [sp+1B4h] [bp-F4h] BYREF
  CRect v57; // 0:r2.8,8:^0.8
  CRect v58; // 0:r2.8,8:^0.8

  emu_GammaSet(1u);
  m_nTouchIndex = this->m_nTouchIndex;
  if ( this == CWidget::m_pInitialTouchWidget[m_nTouchIndex] )
  {
    CTouchInterface::GetTouchPosition((CVector2D *)v55, m_nTouchIndex);
    v5 = this->m_nTouchIndex;
    if ( v55[0].left < (float)(CWidget::m_vecTouchAnchor[v5].x - CWidget::SWIPE_DISTANCE) )
      this->m_fSwipeLeftTime = 0.66;
    CTouchInterface::GetTouchPosition((CVector2D *)v55, v5);
    if ( v55[0].left > (float)(CWidget::m_vecTouchAnchor[this->m_nTouchIndex].x + CWidget::SWIPE_DISTANCE) )
      this->m_fSwipeRightTime = 0.66;
  }
  v2.n64_u32[0] = 0;
  v1.n64_f32[0] = this->m_fSwipeLeftTime - CWidget::m_fElapsedTime;
  LODWORD(this->m_fSwipeLeftTime) = vmax_f32(v1, v2).n64_u32[0];
  PlayerPed = FindPlayerPed(-1);
  v7 = PlayerPed;
  if ( !PlayerPed )
    goto LABEL_43;
  m_eWeaponType = PlayerPed->m_WeaponSlots[0].m_eWeaponType;
  v9 = m_eWeaponType == WEAPONTYPE_UNARMED;
  if ( m_eWeaponType == WEAPONTYPE_UNARMED )
    v9 = v7->m_WeaponSlots[1].m_eWeaponType == WEAPONTYPE_UNARMED;
  if ( v9 && v7->m_WeaponSlots[2].m_eWeaponType == WEAPONTYPE_UNARMED )
  {
    v12 = v7->m_WeaponSlots[3].m_eWeaponType;
    v13 = v12 == WEAPONTYPE_UNARMED;
    if ( v12 == WEAPONTYPE_UNARMED )
      v13 = v7->m_WeaponSlots[4].m_eWeaponType == WEAPONTYPE_UNARMED;
    if ( v13 )
    {
      v14 = v7->m_WeaponSlots[5].m_eWeaponType;
      v15 = v14 == WEAPONTYPE_UNARMED;
      if ( v14 == WEAPONTYPE_UNARMED )
        v15 = v7->m_WeaponSlots[6].m_eWeaponType == WEAPONTYPE_UNARMED;
      if ( v15 )
      {
        v16 = v7->m_WeaponSlots[7].m_eWeaponType;
        v17 = v16 == WEAPONTYPE_UNARMED;
        if ( v16 == WEAPONTYPE_UNARMED )
          v17 = v7->m_WeaponSlots[8].m_eWeaponType == WEAPONTYPE_UNARMED;
        if ( v17 )
        {
          v18 = v7->m_WeaponSlots[9].m_eWeaponType;
          v19 = v18 == WEAPONTYPE_UNARMED;
          if ( v18 == WEAPONTYPE_UNARMED )
            v19 = v7->m_WeaponSlots[10].m_eWeaponType == WEAPONTYPE_UNARMED;
          if ( v19 )
          {
            v20 = v7->m_WeaponSlots[11].m_eWeaponType;
            v21 = v20 == WEAPONTYPE_UNARMED;
            if ( v20 == WEAPONTYPE_UNARMED )
              v21 = v7->m_WeaponSlots[12].m_eWeaponType == WEAPONTYPE_UNARMED;
            if ( v21 )
              goto LABEL_43;
          }
        }
      }
    }
  }
  if ( !CPed::IsPedShootable(v7)
    || v7->m_nPedState == PED_ANSWER_MOBILE
    || CWorld::Players[CWorld::FindPlayerSlotWithPedPointer(v7)].pRemoteVehicle
    || CDarkel::FrenzyOnGoing()
    || v7->m_pAttachToEntity
    || CPedIntelligence::GetTaskJetPack(v7->m_pPedIntelligence)
    || v7->m_pEntLockOnTarget
    || (m_pPlayerData = v7->m_pPlayerData, (*((_WORD *)m_pPlayerData + 26) & 8) != 0) )
  {
LABEL_43:
    v11 = 1;
  }
  else
  {
    v11 = 1;
    if ( (*((_WORD *)m_pPlayerData + 26) & 0x800) == 0 && !m_pPlayerData->m_bDontAllowWeaponChange )
    {
      v11 = 1;
      switch ( TheCamera.PlayerWeaponMode.Mode )
      {
        case 7:
        case 8:
        case 0x22:
        case 0x27:
        case 0x28:
        case 0x2A:
        case 0x2E:
        case 0x33:
        case 0x34:
          break;
        default:
          v11 = 0;
          break;
      }
    }
  }
  m_fSwipeLeftTime = this->m_fSwipeLeftTime;
  if ( m_fSwipeLeftTime > 0.0 )
  {
    left = this->m_RectWeapon.left;
    top = this->m_RectWeapon.top;
    bottom = this->m_RectWeapon.bottom;
    v26 = this->m_RectWeapon.right - left;
    v55[0].right = left;
    v27 = fabsf(top - bottom) * 0.1;
    v55[0].bottom = bottom + v27;
    v55[0].left = left + (float)(fabsf(v26) * -0.2);
    v55[0].top = top - v27;
    if ( v11 == 1 )
      CRGBA::CRGBA(
        &rgba,
        0xFFu,
        0,
        0,
        (unsigned int)(float)(m_fSwipeLeftTime * (float)this->m_Color._anon_0._anon_0.alpha));
    else
      CRGBA::CRGBA(
        &rgba,
        0xFFu,
        0xFFu,
        0xFFu,
        (unsigned int)(float)(m_fSwipeLeftTime * (float)this->m_Color._anon_0._anon_0.alpha));
    CSprite2d::Draw(&this->m_SpriteSwipe, v55, &rgba);
  }
  v28 = this->m_fSwipeRightTime - CWidget::m_fElapsedTime;
  v29 = v28;
  if ( v29 > 0.0 )
    v2.n64_f32[0] = v28;
  LODWORD(this->m_fSwipeRightTime) = v2.n64_u32[0];
  if ( v29 > 0.0 )
  {
    right = this->m_RectWeapon.right;
    v31 = this->m_RectWeapon.top;
    v32 = this->m_RectWeapon.bottom;
    v33 = right - this->m_RectWeapon.left;
    v55[0].right = right;
    v34 = fabsf(v31 - v32) * 0.1;
    v55[0].bottom = v32 + v34;
    v55[0].left = right + (float)(fabsf(v33) * 0.2);
    v55[0].top = v31 - v34;
    if ( v11 == 1 )
      CRGBA::CRGBA(
        &rgba,
        0xFFu,
        0,
        0,
        (unsigned int)(float)(v2.n64_f32[0] * (float)this->m_Color._anon_0._anon_0.alpha));
    else
      CRGBA::CRGBA(
        &rgba,
        0xFFu,
        0xFFu,
        0xFFu,
        (unsigned int)(float)(v2.n64_f32[0] * (float)this->m_Color._anon_0._anon_0.alpha));
    CSprite2d::Draw(&this->m_SpriteSwipe, v55, &rgba);
  }
  if ( !FrontEndMenuManager.m_PrefsDisplayHud || !CTheScripts::bDisplayHud )
    goto LABEL_82;
  pPed = CWorld::Players[CWorld::PlayerInFocus].pPed;
  CFont::SetBackground(0, 0);
  CFont::SetProportional(0);
  v36 = 5;
  if ( CFont::UsingEFIGSLanguage )
    v36 = 3;
  CFont::SetFontStyle(v36);
  CFont::SetOrientation(2u);
  CFont::SetRightJustifyWrap(0.0);
  CFont::SetEdge(1);
  v37 = fabsf(this->m_RectScreen.right - this->m_RectScreen.left) * 0.006;
  CFont::SetScale(v37);
  CRGBA::CRGBA(&v54, 0, 0, 0, this->m_Color._anon_0._anon_0.alpha);
  CFont::SetDropColor(v38);
  CHudColours::GetRGB(&v53, &HudColour, 5u, this->m_Color._anon_0._anon_0.alpha);
  CFont::SetColor((CRGBA)&v53);
  sprintf((unsigned __int8 *)&rgba, "%02d:%02d", CClock::ms_nGameClockHours, CClock::ms_nGameClockMinutes);
  AsciiToGxtChar((const Char *)&rgba, (GxtChar *)v55);
  if ( this->m_bAltDrawingMode )
    v39 = this->m_RectScreen.right;
  else
    v39 = this->m_RectScreen.left + (float)(fabsf(this->m_RectScreen.right - this->m_RectScreen.left) * 0.55);
  CFont::PrintString(
    v39,
    this->m_RectScreen.bottom + (float)(fabsf(this->m_RectScreen.top - this->m_RectScreen.bottom) * 0.05),
    (GxtChar *)v55);
  CFont::SetProportional(0);
  CFont::SetBackground(0, 0);
  CFont::SetOrientation(2u);
  CFont::SetRightJustifyWrap(0.0);
  v40 = 5;
  if ( CFont::UsingEFIGSLanguage )
    v40 = 3;
  CFont::SetFontStyle(v40);
  CFont::SetDropShadowPosition(0);
  CRGBA::CRGBA(&v52, 0, 0, 0, this->m_Color._anon_0._anon_0.alpha);
  CFont::SetDropColor(v41);
  CFont::SetEdge(1);
  CFont::SetScale(fabsf(this->m_RectScreen.right - this->m_RectScreen.left) * 0.00525);
  if ( CWorld::Players[CWorld::PlayerInFocus].DisplayScore < 0 )
  {
    v42 = (CRGBA *)&v50;
    v43 = 0;
  }
  else
  {
    v42 = (CRGBA *)&v51;
    v43 = 1;
  }
  CHudColours::GetRGB(v42, &HudColour, v43, this->m_Color._anon_0._anon_0.alpha);
  CFont::SetColor((CRGBA)v42);
  sprintf(
    (unsigned __int8 *)&rgba,
    (const unsigned __int8 *)&off_2BD640,
    CWorld::Players[CWorld::PlayerInFocus].DisplayScore);
  AsciiToGxtChar((const Char *)&rgba, (GxtChar *)v55);
  if ( CWorld::Players[CWorld::PlayerInFocus].DisplayScore >= (int)&CWorld::m_aTempColPts[2].m_vecNormal.z )
    CFont::SetScale(fabsf(this->m_RectScreen.right - this->m_RectScreen.left) * 0.00485);
  CFont::PrintString(
    v39,
    this->m_RectScreen.bottom + (float)(fabsf(this->m_RectScreen.top - this->m_RectScreen.bottom) * 0.255),
    (GxtChar *)v55);
  if ( !this->m_bAltDrawingMode )
  {
    CWidgetPlayerInfo::RenderHealthBar(
      this,
      CWorld::PlayerInFocus,
      this->m_RectScreen.bottom + (float)(fabsf(this->m_RectScreen.top - this->m_RectScreen.bottom) * 0.455));
    CWidgetPlayerInfo::RenderArmorBar(
      this,
      CWorld::PlayerInFocus,
      this->m_RectScreen.bottom + (float)(fabsf(this->m_RectScreen.top - this->m_RectScreen.bottom) * 0.565));
    if ( CWorld::Players[1].pPed )
    {
      CWidgetPlayerInfo::RenderHealthBar(
        this,
        1,
        this->m_RectScreen.bottom + (float)(fabsf(this->m_RectScreen.top - this->m_RectScreen.bottom) * 1.455));
      CWidgetPlayerInfo::RenderArmorBar(
        this,
        1,
        this->m_RectScreen.bottom + (float)(fabsf(this->m_RectScreen.top - this->m_RectScreen.bottom) * 1.565));
    }
    if ( CPedIntelligence::GetTaskSwim(pPed->m_pPedIntelligence) )
      goto LABEL_74;
    if ( *((unsigned __int8 *)&pPed->m_nPedFlags + 1) << 31 )
    {
      m_pMyVehicle = pPed->m_pMyVehicle;
      v48 = m_pMyVehicle == 0;
      if ( m_pMyVehicle )
        v48 = *((unsigned __int8 *)&m_pMyVehicle->m_nPhysicalFlags + 1) << 31 == 0;
      if ( !v48 && (*((_BYTE *)&m_pMyVehicle->m_nVehicleFlags + 3) & 0x40) != 0 )
        goto LABEL_74;
    }
    m_fBreath = pPed->m_pPlayerData->m_fBreath;
    if ( m_fBreath < CStats::GetFatAndMuscleModifier(STAT_MODIFIER_BREATH_UNDERWATER)
      && this->m_LastBreathTime + 500 > CTimer::m_snTimeInMilliseconds )
    {
LABEL_74:
      CWidgetPlayerInfo::RenderBreathBar(
        this,
        CWorld::PlayerInFocus,
        this->m_RectScreen.bottom + (float)(fabsf(this->m_RectScreen.top - this->m_RectScreen.bottom) * 0.675));
      this->m_LastBreathTime = CTimer::m_snTimeInMilliseconds;
    }
    CWidgetPlayerInfo::DrawWeaponIcon(
      (CWidgetPlayerInfo *)LODWORD(this->m_RectWeapon.right),
      pPed,
      this->m_RectWeapon,
      (float)this->m_Color._anon_0._anon_0.alpha);
    if ( CWorld::Players[1].pPed )
    {
      v44 = fabsf(this->m_RectScreen.top - this->m_RectScreen.bottom);
      v57.top = this->m_RectWeapon.top + v44;
      v57.left = this->m_RectWeapon.left;
      v57.right = this->m_RectWeapon.right;
      v57.bottom = this->m_RectWeapon.bottom + v44;
      CWidgetPlayerInfo::DrawWeaponIcon(
        (CWidgetPlayerInfo *)LODWORD(v57.right),
        CWorld::Players[1].pPed,
        v57,
        (float)this->m_Color._anon_0._anon_0.alpha);
    }
    m_pHoldEffect = this->m_pHoldEffect;
    if ( m_pHoldEffect )
      CHoldEffect::Draw(m_pHoldEffect);
    CWidgetPlayerInfo::DrawAmmo(this, pPed, this->m_RectWeapon, (float)this->m_Color._anon_0._anon_0.alpha);
    if ( CWorld::Players[1].pPed )
    {
      v46 = fabsf(this->m_RectScreen.top - this->m_RectScreen.bottom);
      v58.top = this->m_RectWeapon.top + v46;
      v58.left = this->m_RectWeapon.left;
      v58.right = this->m_RectWeapon.right;
      v58.bottom = this->m_RectWeapon.bottom + v46;
      CWidgetPlayerInfo::DrawAmmo(this, CWorld::Players[1].pPed, v58, (float)this->m_Color._anon_0._anon_0.alpha);
    }
    CWidgetPlayerInfo::DrawWanted(this);
LABEL_82:
    emu_GammaSet(0);
  }
}
// 2BCDD8: variable 'v1' is possibly undefined
// 2BCDD8: variable 'v2' is possibly undefined
// 2BD164: variable 'v38' is possibly undefined
// 2BD248: variable 'v41' is possibly undefined
// 2BD640: using guessed type void *off_2BD640;

//----- (002BD680) --------------------------------------------------------
void __fastcall CWidgetPlayerInfo::RenderHealthBar(CWidgetPlayerInfo *this, Int32 Player, float fTop)
{
  float32x2_t v3; // d0
  float32x2_t v4; // d2
  CPlayerInfo *v7; // r6
  float StatValue; // r10
  RwUInt8 alpha; // r3
  float left; // s18
  float m_nHealth; // s26
  float top; // s20
  float right; // s22
  float bottom; // s24
  unsigned int MaxHealth; // r4
  float v16; // s2
  unsigned int v17; // r2
  CRGBA c2; // r0
  CRGBA v19; // [sp+18h] [bp-50h] BYREF
  CRGBA v20[19]; // [sp+1Ch] [bp-4Ch] BYREF

  if ( (CHud::m_ItemToFlash != 4 || CTimer::m_snTimeInMilliseconds % 0x15E >= 0x97)
    && ((int)CWorld::Players[Player].pPed->m_nHealth > 9 || CTimer::m_snTimeInMilliseconds % 0x15E >= 0x97) )
  {
    v7 = &CWorld::Players[Player];
    StatValue = CStats::GetStatValue(0x18u);
    alpha = this->m_Color._anon_0._anon_0.alpha;
    left = this->m_RectScreen.left;
    m_nHealth = v7->pPed->m_nHealth;
    top = this->m_RectScreen.top;
    right = this->m_RectScreen.right;
    bottom = this->m_RectScreen.bottom;
    MaxHealth = v7->MaxHealth;
    CHudColours::GetRGB(v20, &HudColour, 0, alpha);
    CRGBA::CRGBA(&v19, 0, 0, 0, 0);
    v4.n64_u32[0] = 1.0;
    v3.n64_f32[0] = StatValue / 1000.0;
    v16 = fabsf(right - left);
    v17 = (unsigned int)(float)((float)(vmin_f32(v3, v4).n64_f32[0] * v16) * 0.55);
    CSprite2d::DrawBarChart(
      (float)(int)(float)((float)(left + (float)(v16 * 0.55)) - (float)v17),
      (float)(int)fTop,
      v17,
      (int)(float)(fabsf(top - bottom) * 0.095),
      (float)(m_nHealth / (float)MaxHealth) * 100.0,
      0,
      0,
      1,
      (CRGBA)v20,
      c2);
  }
}
// 2BD77E: variable 'v3' is possibly undefined
// 2BD77E: variable 'v4' is possibly undefined
// 2BD800: variable 'c2' is possibly undefined

//----- (002BD838) --------------------------------------------------------
void __fastcall CWidgetPlayerInfo::RenderArmorBar(CWidgetPlayerInfo *this, Int32 Player, float fTop)
{
  float32x2_t v3; // d0
  float32x2_t v4; // d1
  float32x2_t v5; // d3
  float m_nArmour; // s16
  float left; // s20
  float top; // s22
  float right; // s24
  float bottom; // s26
  unsigned int MaxArmour; // r4
  float v13; // s4
  unsigned int v14; // r2
  CRGBA c2; // r0
  CRGBA v16; // [sp+18h] [bp-48h] BYREF
  CRGBA v17[17]; // [sp+1Ch] [bp-44h] BYREF

  if ( CHud::m_ItemToFlash == 3 )
  {
    if ( CTimer::m_snTimeInMilliseconds % 0x15E < 0x97 )
      return;
    m_nArmour = CWorld::Players[Player].pPed->m_nArmour;
  }
  else
  {
    m_nArmour = CWorld::Players[Player].pPed->m_nArmour;
    if ( m_nArmour <= 1.0 )
      return;
  }
  left = this->m_RectScreen.left;
  top = this->m_RectScreen.top;
  right = this->m_RectScreen.right;
  bottom = this->m_RectScreen.bottom;
  MaxArmour = CWorld::Players[Player].MaxArmour;
  CHudColours::GetRGB(v17, &HudColour, 5u, this->m_Color._anon_0._anon_0.alpha);
  CRGBA::CRGBA(&v16, 0, 0, 0, 0);
  v5.n64_u32[0] = 1.0;
  v13 = fabsf(right - left);
  v4.n64_f32[0] = (float)MaxArmour / 150.0;
  v3.n64_f32[0] = m_nArmour / (float)MaxArmour;
  v14 = (unsigned int)(float)((float)(v13 * vmin_f32(v4, v5).n64_f32[0]) * 0.55);
  CSprite2d::DrawBarChart(
    (float)(int)(float)((float)(left + (float)(v13 * 0.55)) - (float)v14),
    (float)(int)fTop,
    v14,
    (int)(float)(fabsf(top - bottom) * 0.095),
    vmin_f32(v3, v5).n64_f32[0] * 100.0,
    0,
    0,
    1,
    (CRGBA)v17,
    c2);
}
// 2BD91E: variable 'v4' is possibly undefined
// 2BD91E: variable 'v5' is possibly undefined
// 2BD92E: variable 'v3' is possibly undefined
// 2BD994: variable 'c2' is possibly undefined

//----- (002BD9CC) --------------------------------------------------------
void __fastcall CWidgetPlayerInfo::RenderBreathBar(CWidgetPlayerInfo *this, Int32 Player, float fTop)
{
  float32x2_t v3; // d0
  float32x2_t v4; // d4
  float m_fBreath; // s18
  float FatAndMuscleModifier; // r5
  float left; // s20
  float top; // s22
  float right; // s24
  float bottom; // s26
  CRGBA c2; // r0
  CRGBA v14; // [sp+18h] [bp-48h] BYREF
  CRGBA v15; // [sp+1Ch] [bp-44h] BYREF

  if ( CHud::m_ItemToFlash != 10 || CTimer::m_snTimeInMilliseconds % 0x15E >= 0x97 )
  {
    m_fBreath = CWorld::Players[Player].pPed->m_pPlayerData->m_fBreath;
    FatAndMuscleModifier = CStats::GetFatAndMuscleModifier(STAT_MODIFIER_BREATH_UNDERWATER);
    left = this->m_RectScreen.left;
    top = this->m_RectScreen.top;
    right = this->m_RectScreen.right;
    bottom = this->m_RectScreen.bottom;
    CRGBA::CRGBA(&v15, 0x89u, 0xA2u, 0xC0u, this->m_Color._anon_0._anon_0.alpha);
    CRGBA::CRGBA(&v14, 0, 0, 0, 0);
    v3.n64_f32[0] = m_fBreath / FatAndMuscleModifier;
    v4.n64_u32[0] = 1.0;
    CSprite2d::DrawBarChart(
      (float)(int)left,
      (float)(int)fTop,
      (int)(float)(fabsf(right - left) * 0.55),
      (int)(float)(fabsf(top - bottom) * 0.095),
      vmin_f32(v3, v4).n64_f32[0] * 100.0,
      0,
      0,
      1,
      (CRGBA)&v15,
      c2);
  }
}
// 2BDAAC: variable 'v3' is possibly undefined
// 2BDAAC: variable 'v4' is possibly undefined
// 2BDAD6: variable 'c2' is possibly undefined

//----- (002BDB00) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CWidgetPlayerInfo::DrawWeaponIcon(
        CWidgetPlayerInfo *this,
        CPed *pPlayerPed,
        CRect RectWeapon,
        float fWeaponAlpha)
{
  CWeaponInfo *WeaponInfo; // r4
  TextureDatabaseRuntime *Database; // r0
  RwTexture_0 *v7; // r4
  float v8; // s2
  float v9; // r3
  CRect Rectangle; // [sp+2Ch] [bp-84h] BYREF
  char v11[32]; // [sp+3Ch] [bp-74h] BYREF
  CRGBA s[16]; // [sp+5Ch] [bp-54h] BYREF

  Rectangle = RectWeapon;
  RwRenderStateSet(rwRENDERSTATETEXTUREFILTER, (char *)&dword_0 + 2);
  WeaponInfo = CWeaponInfo::GetWeaponInfo(pPlayerPed->m_WeaponSlots[pPlayerPed->m_nCurrentWeapon].m_eWeaponType, 1);
  if ( WeaponInfo->m_modelId < 1 )
  {
    CRGBA::CRGBA(s, 0xFFu, 0xFFu, 0xFFu, (unsigned int)fWeaponAlpha);
    CSprite2d::Draw(CHud::Sprites, &Rectangle, s);
  }
  else
  {
    Database = TextureDatabaseRuntime::GetDatabase("gta3");
    TextureDatabaseRuntime::Register(Database);
    strcpy(v11, (const char *)CModelInfo::ms_modelInfoPtrs[WeaponInfo->m_modelId]->m_modelName);
    snprintf((unsigned __int8 *)s, 0x40u, "%sicon", v11);
    v7 = RwTextureRead((const RwChar *)s, (const RwChar *)&byte_61CADE);
    if ( v7
      || ((*((void (__fastcall **)(char *))RwEngineInstance + 71))(v11),
          snprintf((unsigned __int8 *)s, 0x40u, "%sicon", v11),
          (v7 = RwTextureRead((const RwChar *)s, (const RwChar *)&byte_61CADE)) != 0) )
    {
      RwRenderStateSet(rwRENDERSTATEZTESTENABLE, 0);
      RwRenderStateSet(rwRENDERSTATETEXTURERASTER, v7->raster);
      v8 = fabsf(Rectangle.top - Rectangle.bottom) * 0.5;
      v9 = fabsf(Rectangle.right - Rectangle.left) * 0.5;
      CSprite::RenderOneXLUSprite(
        Rectangle.left + v9,
        Rectangle.bottom + v8,
        10.0,
        v9,
        v8,
        255,
        255,
        255,
        255,
        1.0,
        (int)fWeaponAlpha,
        0,
        0,
        0.0,
        0.0);
      RwRenderStateSet(rwRENDERSTATEZWRITEENABLE, 0);
    }
  }
}
// 2BDB00: fragmented variable at 0:r2.8,8:^B8.8 may be wrong
// 2BDB00: variables would overlap: 0:r2.8,8:^B8.8 and ^B8.8
// 0: using guessed type int dword_0;
// 61CADE: using guessed type char byte_61CADE;

//----- (002BDCB8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CWidgetPlayerInfo::DrawAmmo(
        CWidgetPlayerInfo *this,
        CPed *pPlayerPed,
        CRect RectWeapon,
        float fWeaponAlpha)
{
  float32x2_t v4; // d0
  float32x2_t v5; // d1
  float top; // r8
  float left; // r9
  char *v10; // r0
  int v11; // r4
  eWeaponType m_eWeaponType; // r0
  eWeaponType v13; // r10
  int8 WeaponSkill; // r0
  char *v15; // r0
  int v16; // r3
  int v17; // r2
  uint8 v18; // r0
  CRGBA v19; // r0
  float v20; // s16
  float v21; // s18
  float right; // s20
  float StringWidth; // r0
  float v24; // s0
  float v25; // s2
  CRGBA v26; // [sp+8h] [bp-40h] BYREF
  CRGBA v27[15]; // [sp+Ch] [bp-3Ch] BYREF

  top = RectWeapon.top;
  v4.n64_u32[0] = 1176255488;
  left = RectWeapon.left;
  v10 = (char *)pPlayerPed + 28 * pPlayerPed->m_nCurrentWeapon;
  v11 = *((_DWORD *)v10 + 364);
  v5.n64_f32[0] = (float)(v11 - *((_DWORD *)v10 + 363));
  if ( vmin_f32(v5, v4).n64_f32[0] != 9999.0 && !CDarkel::FrenzyOnGoing() )
  {
    m_eWeaponType = pPlayerPed->m_WeaponSlots[pPlayerPed->m_nCurrentWeapon].m_eWeaponType;
    switch ( m_eWeaponType )
    {
      case WEAPONTYPE_UNARMED:
      case WEAPONTYPE_DILDO1:
      case WEAPONTYPE_DILDO2:
      case WEAPONTYPE_VIBE1:
      case WEAPONTYPE_VIBE2:
      case WEAPONTYPE_FLOWERS:
      case WEAPONTYPE_CANE:
      case WEAPONTYPE_DETONATOR:
      case WEAPONTYPE_PARACHUTE:
        return;
      default:
        if ( CWeaponInfo::GetWeaponInfo(m_eWeaponType, 1)->m_eFireType != FIRETYPE_USE
          && CWeaponInfo::GetWeaponInfo(pPlayerPed->m_WeaponSlots[pPlayerPed->m_nCurrentWeapon].m_eWeaponType, 1)->m_nWeaponSlot >= 2 )
        {
          v13 = pPlayerPed->m_WeaponSlots[pPlayerPed->m_nCurrentWeapon].m_eWeaponType;
          WeaponSkill = CPed::GetWeaponSkill(pPlayerPed);
          if ( (unsigned __int16)(CWeaponInfo::GetWeaponInfo(v13, WeaponSkill)->m_nAmmo - 2) > 0x3E5u )
          {
            sprintf(gString, (const unsigned __int8 *)&dword_2BDF80, v11);
          }
          else
          {
            v15 = (char *)pPlayerPed + 28 * pPlayerPed->m_nCurrentWeapon;
            v16 = *((_DWORD *)v15 + 363);
            v17 = v11 - v16;
            if ( *((_DWORD *)v15 + 361) == 37 )
              sprintf(gString, "%d-%d", v17 / 10, v16 / 10);
            else
              sprintf(gString, "%d-%d", v17, v16);
          }
          AsciiToGxtChar(gString, gGxtString);
          CFont::SetBackground(0, 0);
          CFont::SetOrientation(0);
          CFont::SetCentreSize((float)((float)RsGlobal.screenWidth / 640.0) * 640.0);
          CFont::SetProportional(1u);
          v18 = 6;
          if ( CFont::UsingEFIGSLanguage )
            v18 = 1;
          CFont::SetFontStyle(v18);
          CFont::SetEdge(1);
          CHudColours::GetRGB(v27, &HudColour, 3u, (unsigned int)fWeaponAlpha);
          CFont::SetColor((CRGBA)v27);
          CRGBA::CRGBA(&v26, 0, 0, 0, (unsigned int)fWeaponAlpha);
          CFont::SetDropColor(v19);
          v20 = fabsf(this->m_RectScreen.right - this->m_RectScreen.left) * 0.0055;
          CFont::SetScale(v20);
          v21 = this->m_RectScreen.left;
          right = this->m_RectScreen.right;
          StringWidth = CFont::GetStringWidth(gGxtString, 1u, 0);
          v24 = fabsf(right - v21) * 0.425;
          if ( StringWidth > v24 )
            CFont::SetScale((float)(v24 / StringWidth) * v20);
          v25 = fabsf(RectWeapon.right - left) * 0.5 + left;
          CFont::PrintString(v25, (float)(fabsf(top - RectWeapon.bottom) * 0.9) + RectWeapon.bottom, gGxtString);
        }
        break;
    }
  }
}
// 2BDCB8: fragmented variable at 0:r2.8,8:^50.8 may be wrong
// 2BDCB8: variables would overlap: 0:r2.8,8:^50.8 and ^50.4
// 2BDCB8: variables would overlap: 0:r2.8,8:^50.8 and ^54.4
// 2BDF80: using guessed type int dword_2BDF80;

//----- (002BDFB8) --------------------------------------------------------
void __fastcall CWidgetPlayerInfo::DrawWanted(CWidgetPlayerInfo *this)
{
  Int32 m_WantedLevel; // r11
  CWanted *PlayerWanted; // r0
  int v4; // r1
  int v5; // r0
  Int32 v6; // r9
  uint8 v7; // r0
  float top; // s18
  float right; // s16
  float v10; // s0
  float v11; // r8
  CRGBA v12; // r0
  float v13; // s0
  uint32 v14; // r10
  CRGBA v15; // r0
  CRGBA v16; // r0
  float v17; // s0
  int m_WantedLevelBeforeParole; // [sp+1Ch] [bp-A4h]
  CRGBA v19; // [sp+20h] [bp-A0h] BYREF
  CRGBA v20; // [sp+24h] [bp-9Ch] BYREF
  CRGBA v21; // [sp+28h] [bp-98h] BYREF
  CRGBA v22; // [sp+2Ch] [bp-94h] BYREF
  GxtChar pOutput[20]; // [sp+30h] [bp-90h] BYREF
  Char aStr[2]; // [sp+58h] [bp-68h] BYREF

  m_WantedLevel = FindPlayerWanted(-1)->m_WantedLevel;
  PlayerWanted = FindPlayerWanted(-1);
  v4 = 0;
  m_WantedLevelBeforeParole = PlayerWanted->m_WantedLevelBeforeParole;
  if ( this->m_LastWanted == m_WantedLevel )
  {
    v5 = 1;
  }
  else
  {
    this->m_LastWanted = m_WantedLevel;
    v5 = 0;
  }
  if ( m_WantedLevel > 0 )
    v4 = 1;
  if ( m_WantedLevelBeforeParole > 0 || (v5 & v4) == 1 )
  {
    v6 = 0;
    CFont::SetBackground(0, 0);
    CFont::SetOrientation(2u);
    CFont::SetProportional(1u);
    v7 = 4;
    if ( CFont::UsingEFIGSLanguage )
      v7 = 0;
    CFont::SetFontStyle(v7);
    strcpy((char *)aStr, "]");
    AsciiToGxtChar(aStr, pOutput);
    top = this->m_RectScreen.top;
    right = this->m_RectScreen.right;
    v10 = top - CFont::GetHeight(0);
    if ( CDraw::ms_fAspectRatio > 1.9 )
      v10 = v10 + -30.0;
    v11 = v10;
    while ( 1 )
    {
      CFont::SetEdge(1);
      CRGBA::CRGBA(&v22, 0, 0, 0, this->m_Color._anon_0._anon_0.alpha);
      CFont::SetDropColor(v12);
      v13 = fabsf(this->m_RectScreen.right - this->m_RectScreen.left) * 0.007;
      CFont::SetScale(v13);
      if ( m_WantedLevel > v6 )
      {
        v14 = CTimer::m_snTimeInMilliseconds;
        if ( v14 > FindPlayerWanted(-1)->m_LastTimeWantedLevelChanged + 2000
          || CTimer::m_snTimeInMilliseconds % 0x15E >= 0x97 )
        {
          break;
        }
      }
      if ( m_WantedLevelBeforeParole > v6 && CTimer::m_snTimeInMilliseconds % 0x15E >= 0x97 )
      {
        CRGBA::CRGBA(
          &v20,
          (unsigned int)(float)((float)HudColour.value[7]._anon_0._anon_0.red * 0.8),
          (unsigned int)(float)((float)HudColour.value[7]._anon_0._anon_0.green * 0.8),
          (unsigned int)(float)((float)HudColour.value[7]._anon_0._anon_0.blue * 0.8),
          this->m_Color._anon_0._anon_0.alpha);
        CFont::SetColor(v15);
        goto LABEL_22;
      }
      if ( m_WantedLevel <= v6 )
      {
        CFont::SetEdge(0);
        CRGBA::CRGBA(&v19, 0, 0, 0, (unsigned int)(float)((float)this->m_Color._anon_0._anon_0.alpha * 0.7));
        CFont::SetColor(v16);
        v17 = fabsf(this->m_RectScreen.right - this->m_RectScreen.left) * 0.0075;
        CFont::SetScale(v17);
        goto LABEL_22;
      }
LABEL_23:
      ++v6;
      right = right + (float)(fabsf(this->m_RectScreen.right - this->m_RectScreen.left) * -0.15);
      if ( v6 == 6 )
      {
        CFont::SetEdge(0);
        return;
      }
    }
    CHudColours::GetRGB(&v21, &HudColour, 7u, this->m_Color._anon_0._anon_0.alpha);
    CFont::SetColor((CRGBA)&v21);
LABEL_22:
    CFont::PrintString(right, v11, pOutput);
    CFont::RenderFontBuffer();
    goto LABEL_23;
  }
}
// 2BE0E6: variable 'v12' is possibly undefined
// 2BE1D4: variable 'v15' is possibly undefined
// 2BE20A: variable 'v16' is possibly undefined

//----- (002BE2D8) --------------------------------------------------------
bool __fastcall CWidgetPlayerInfo::PassesDisplayConditions(CWidgetPlayerInfo *this)
{
  bool result; // r0
  bool v2; // zf

  if ( MobileSettings::settings[22].value && (CTimer::m_UserPause || CTimer::m_CodePause) << 24 )
    return this->m_nFrameCount > 5;
  result = 0;
  if ( !gMobileMenu.pendingScreen && FrontEndMenuManager.m_PrefsDisplayHud && CTheScripts::bDisplayHud )
  {
    v2 = !CWeapon::ms_bTakePhoto;
    if ( !CWeapon::ms_bTakePhoto )
      v2 = gMobileMenu.screenStack.numEntries == 0;
    if ( v2 )
    {
      result = 0;
      if ( gbCineyCamProcessedOnFrame != CTimer::m_FrameCounter && !TheCamera.m_WideScreenOn )
        return 1;
    }
  }
  return result;
}

//----- (002BE38C) --------------------------------------------------------
bool __fastcall CWidgetPlayerInfo::IsHeldDown(CWidgetPlayerInfo *this)
{
  CHID::Implements(HID_MAPPING_VITAL_STATS);
  return this->m_fTapHoldTime >= this->m_fHoldEffectPeriod;
}

//----- (002BE3B0) --------------------------------------------------------
bool __fastcall CWidgetPlayerInfo::IsSwipedLeft(CWidgetPlayerInfo *this)
{
  if ( CHID::Replaces(HID_MAPPING_PREV_WEAPON) )
    return sub_192D40(HID_MAPPING_PREV_WEAPON);
  if ( CHID::Implements(HID_MAPPING_PREV_WEAPON) && CHID::IsJustPressed(HID_MAPPING_PREV_WEAPON) )
    return 1;
  return sub_19F50C(this);
}

//----- (002BE3EC) --------------------------------------------------------
bool __fastcall CWidgetPlayerInfo::IsSwipedRight(CWidgetPlayerInfo *this)
{
  if ( CHID::Replaces(HID_MAPPING_NEXT_WEAPON) )
    return sub_192D40(HID_MAPPING_NEXT_WEAPON);
  if ( CHID::Implements(HID_MAPPING_NEXT_WEAPON) && CHID::IsJustPressed(HID_MAPPING_NEXT_WEAPON)
    || !CHID::GetInputType() && (*((int (__fastcall **)(CWidgetPlayerInfo *, _DWORD))this->_vptr$CWidget + 13))(this, 0) )
  {
    return 1;
  }
  return sub_198F7C(this);
}

//----- (002BE438) --------------------------------------------------------
void __fastcall CWidgetPlayerInfo::DrawHelpIcon(
        CWidgetPlayerInfo *this,
        const unsigned __int8 *pszCharacters,
        float fX,
        float fY,
        float fHeight,
        int nAlpha)
{
  CPlayerPed *PlayerPed; // r0
  CRect v13; // 0:r2.8,8:^0.8

  if ( CHID::Implements(this->m_HIDMapping) )
  {
    CHID::DrawHelpIcon(pszCharacters, this->m_HIDMapping, fX, fY, fHeight, nAlpha, 0);
  }
  else
  {
    PlayerPed = FindPlayerPed(-1);
    if ( PlayerPed )
    {
      v13.left = fX;
      v13.top = fY + fHeight;
      v13.right = fX + fHeight;
      v13.bottom = fY;
      CWidgetPlayerInfo::DrawWeaponIcon((CWidgetPlayerInfo *)PlayerPed, PlayerPed, v13, (float)nAlpha);
    }
  }
}

//----- (002BE4C0) --------------------------------------------------------
void __fastcall CWidgetPlayerInfo::~CWidgetPlayerInfo(CWidgetPlayerInfo *this)
{
  this->_vptr$CWidget = (int (**)(void))&off_6640F8;
  CSprite2d::~CSprite2d(&this->m_SpriteSwipe);
  sub_19C514(this);
}
// 6640F8: using guessed type void *off_6640F8;

//----- (002BE4E8) --------------------------------------------------------
void __fastcall CWidgetPlayerInfo::~CWidgetPlayerInfo(CWidgetPlayerInfo *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_6640F8;
  CSprite2d::~CSprite2d(&this->m_SpriteSwipe);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2BE50C: variable 'v2' is possibly undefined
// 6640F8: using guessed type void *off_6640F8;

//----- (002BE514) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetPlayerInfo::GetName(CWidgetPlayerInfo *this)
{
  return "PlayerInfo";
}

//----- (002BE524) --------------------------------------------------------
void __fastcall CWidgetPool::CWidgetPool(
        CWidgetPool *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  int v3; // r0

  CWidget::CWidget(this, pszSprite, WidgetPos, 4u, HID_MAPPING_UNKNOWN);
  *(_BYTE *)(v3 + 144) = 0;
  *(_BYTE *)(v3 + 272) = 0;
  *(_DWORD *)(v3 + 668) = 0;
  *(_DWORD *)(v3 + 672) = 0;
  *(_DWORD *)(v3 + 676) = 0;
  *(_DWORD *)(v3 + 400) = 0;
  *(_DWORD *)(v3 + 409) = 0;
  *(_DWORD *)(v3 + 405) = 0;
  *(_DWORD *)(v3 + 404) = 0;
  *(_BYTE *)(v3 + 540) = 0;
  *(_DWORD *)v3 = &off_66418C;
}
// 2BE536: variable 'v3' is possibly undefined
// 66418C: using guessed type void *;

//----- (002BE56C) --------------------------------------------------------
void __fastcall CWidgetPool::Update(CWidgetPool *this)
{
  CWidget::Update(this);
  sub_19751C(this);
}

//----- (002BE580) --------------------------------------------------------
void __fastcall CWidgetPool::Draw(CWidgetPool *this)
{
  unsigned int v1; // r6
  SDataCell *m_DataCell; // r11
  int v3; // r5
  float top; // s16
  float bottom; // s18
  float v6; // s20
  CRGBA v7; // r0
  float v8; // s18
  float v9; // s22
  int v10; // r6
  unsigned __int8 *m_szText; // r4
  float v12; // s0
  bool v13; // zf
  int *v14; // r0
  float v15; // s26
  GxtChar *v16; // r0
  float StringWidth; // r0
  GxtChar *v18; // r0
  float v19; // r0
  float v20; // s22
  float left; // r0
  float right; // r1
  const CRGBA *v23; // r0
  CRGBA v24; // r0
  float v25; // s26
  float v26; // s28
  float v27; // s30
  float v28; // s28
  GxtChar *v29; // r0
  CRGBA v30; // r0
  float v31; // s26
  float v32; // s28
  float v33; // s30
  float v34; // s28
  GxtChar *v35; // r0
  CRGBA v36; // r0
  float v37; // s26
  float v38; // s28
  float v39; // s30
  float v40; // s0
  GxtChar *v41; // r0
  unsigned int v42; // [sp+4h] [bp-A4h]
  unsigned int alpha; // [sp+10h] [bp-98h]
  CRGBA v45; // [sp+18h] [bp-90h] BYREF
  CRGBA v46; // [sp+1Ch] [bp-8Ch] BYREF
  CRGBA v47; // [sp+20h] [bp-88h] BYREF
  CRGBA v48; // [sp+24h] [bp-84h] BYREF
  CRGBA v49; // [sp+28h] [bp-80h] BYREF
  CRGBA v50; // [sp+2Ch] [bp-7Ch] BYREF
  CRGBA v51; // [sp+30h] [bp-78h] BYREF
  CRect Rectangle; // [sp+34h] [bp-74h] BYREF
  CRGBA v53; // [sp+44h] [bp-64h] BYREF

  v1 = this->m_Color._anon_0._anon_0.alpha;
  if ( this->m_Color._anon_0._anon_0.alpha )
  {
    m_DataCell = this->m_DataCell;
    if ( strlen((const char *)this->m_DataCell) )
      v3 = strcasecmp((const char *)m_DataCell, "DUMMY") != 0;
    else
      v3 = 0;
    if ( strlen((const char *)&this->m_DataCell[1]) && strcasecmp((const char *)&this->m_DataCell[1], "DUMMY") )
      ++v3;
    if ( v3 )
    {
      top = this->m_RectScreen.top;
      bottom = this->m_RectScreen.bottom;
      CFont::SetBackground(0, 0);
      CFont::SetProportional(1u);
      CFont::SetFontStyle(2u);
      CFont::SetOrientation(1u);
      CFont::SetRightJustifyWrap(0.0);
      CFont::SetEdge(0);
      v6 = (float)v1 / 255.0;
      CRGBA::CRGBA(&v53, 0, 0, 0, (unsigned int)(float)(v6 * 255.0));
      CFont::SetDropColor(v7);
      CFont::SetWrapx((float)RsGlobal.screenWidth);
      CFont::SetCentreSize((float)RsGlobal.screenWidth);
      v8 = (float)(fabsf(top - bottom) + -1.0) * 0.5;
      v9 = v8 * 0.0325;
      CFont::SetScale(v8 * 0.0325);
      if ( v3 >= 1 )
      {
        v42 = (unsigned int)(float)(v6 * 255.0);
        v10 = v3;
        m_szText = this->m_DataCell[0].m_szText;
        do
        {
          v12 = 0.9;
          if ( strlen((const char *)m_szText) )
          {
            v13 = strcasecmp((const char *)m_szText, "DUMMY") == 0;
            v14 = dword_2BE9B4;
            if ( !v13 )
              v14 = &dword_2BE9B4[1];
            v12 = *(float *)v14;
          }
          v15 = v12 * fabsf(this->m_RectScreen.right - this->m_RectScreen.left);
          if ( strlen((const char *)m_szText - 128) )
          {
            if ( strcasecmp((const char *)m_szText - 128, "DUMMY") )
            {
              v16 = CText::Get(&TheText, m_szText - 128);
              StringWidth = CFont::GetStringWidth(v16, 1u, 0);
              if ( StringWidth > v15 )
              {
                v9 = v9 * (float)(v15 / StringWidth);
                CFont::SetScale(v9);
              }
            }
          }
          if ( strlen((const char *)m_szText) )
          {
            if ( strcasecmp((const char *)m_szText, "DUMMY") )
            {
              v18 = CText::Get(&TheText, m_szText);
              v19 = CFont::GetStringWidth(v18, 1u, 0);
              if ( v19 > v15 )
              {
                v9 = v9 * (float)(v15 / v19);
                CFont::SetScale(v9);
              }
            }
          }
          m_szText += 268;
          --v10;
        }
        while ( v10 );
        v20 = this->m_RectScreen.bottom;
        alpha = (unsigned int)(float)(v6 * 128.0);
        do
        {
          left = this->m_RectScreen.left;
          right = this->m_RectScreen.right;
          Rectangle.bottom = v20;
          Rectangle.left = left;
          Rectangle.right = right;
          Rectangle.top = v8 + v20;
          CRGBA::CRGBA(&v51, 0, 0, 0, alpha);
          CRGBA::CRGBA(&v50, 0, 0, 0, alpha);
          CRGBA::CRGBA(&v49, 0, 0, 0, v42);
          CRGBA::CRGBA(&v48, 0, 0, 0, v42);
          CSprite2d::DrawRect(&Rectangle, &v51, &v50, &v49, v23);
          if ( !strlen((const char *)m_DataCell->m_szText) || !strcasecmp((const char *)m_DataCell->m_szText, "DUMMY") )
          {
            CFont::SetOrientation(0);
            CRGBA::CRGBA(&v45, 0x5Du, 0x8Eu, 0xBEu, v42);
            CFont::SetColor(v36);
            v37 = Rectangle.left;
            v38 = Rectangle.right;
            v39 = Rectangle.top + Rectangle.bottom;
            v40 = CFont::GetHeight(0) * 0.5;
            v41 = CText::Get(&TheText, m_DataCell->m_szLabel);
            CFont::PrintString((float)(v37 + v38) * 0.5, (float)(v39 * 0.5) - v40, v41);
          }
          else
          {
            CFont::SetOrientation(1u);
            CRGBA::CRGBA(&v47, 0xFFu, 0xFFu, 0xFFu, v42);
            CFont::SetColor(v24);
            v25 = Rectangle.left;
            v26 = Rectangle.top + Rectangle.bottom;
            v27 = fabsf(Rectangle.right - Rectangle.left);
            v28 = (float)(v26 * 0.5) - (float)(CFont::GetHeight(0) * 0.5);
            v29 = CText::Get(&TheText, m_DataCell->m_szLabel);
            CFont::PrintString(v25 + (float)(v27 * 0.03), v28, v29);
            CFont::SetOrientation(2u);
            CRGBA::CRGBA(&v46, 0x5Du, 0x8Eu, 0xBEu, v42);
            CFont::SetColor(v30);
            v31 = Rectangle.right;
            v32 = Rectangle.top + Rectangle.bottom;
            v33 = fabsf(Rectangle.right - Rectangle.left);
            v34 = (float)(v32 * 0.5) - (float)(CFont::GetHeight(0) * 0.5);
            v35 = CText::Get(&TheText, m_DataCell->m_szText);
            CFont::PrintString(v31 - (float)(v33 * 0.03), v34, v35);
            CFont::RenderFontBuffer();
          }
          v20 = (float)(v8 + 1.0) + v20;
          ++m_DataCell;
          --v3;
        }
        while ( v3 );
      }
    }
  }
}
// 2BE784: conditional instruction was optimized away because r5.4>=1
// 2BE63C: variable 'v7' is possibly undefined
// 2BE824: variable 'v23' is possibly undefined
// 2BE858: variable 'v24' is possibly undefined
// 2BE8C4: variable 'v30' is possibly undefined
// 2BE934: variable 'v36' is possibly undefined
// 2BE9B4: using guessed type int dword_2BE9B4[2];

//----- (002BE9D4) --------------------------------------------------------
void __fastcall CWidgetPool::SetWidgetInfo2(
        CWidgetPool *this,
        int nValue0,
        int nValue1,
        int nValue2,
        int nValue3,
        unsigned __int8 *pszText0,
        unsigned __int8 *pszText1)
{
  const char *v9; // r1
  const char *v10; // r6
  int v11[67]; // [sp+0h] [bp-128h] BYREF

  if ( (unsigned int)nValue0 <= 1 )
  {
    v9 = (const char *)pszText0;
    v10 = &byte_61CADE;
    if ( !pszText0 )
      v9 = &byte_61CADE;
    strcpy((char *)v11, v9);
    if ( pszText1 )
      v10 = (const char *)pszText1;
    strcpy((char *)&v11[32], v10);
    memset(&v11[64], 0, 12);
    qmemcpy(&this->m_DataCell[nValue0], v11, sizeof(this->m_DataCell[nValue0]));
  }
}
// 61CADE: using guessed type char byte_61CADE;

//----- (002BEA5C) --------------------------------------------------------
void __fastcall CWidgetPool::~CWidgetPool(CWidgetPool *this)
{
  void *v1; // r0

  CWidget::~CWidget(this);
  sub_191374(v1);
}
// 2BEA68: variable 'v1' is possibly undefined

//----- (002BEA6C) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetPool::GetName(CWidgetPool *this)
{
  return "Pool";
}

//----- (002BEA80) --------------------------------------------------------
void __fastcall CWidgetRaceResults::CWidgetRaceResults(
        CWidgetRaceResults *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  int v3; // r0

  CWidget::CWidget(this, pszSprite, WidgetPos, 4u, HID_MAPPING_UNKNOWN);
  *(_BYTE *)(v3 + 144) = 0;
  *(_BYTE *)(v3 + 272) = 0;
  *(_DWORD *)(v3 + 400) = 0;
  *(_DWORD *)(v3 + 409) = 0;
  *(_DWORD *)(v3 + 405) = 0;
  *(_DWORD *)(v3 + 404) = 0;
  *(_BYTE *)(v3 + 540) = 0;
  *(_DWORD *)(v3 + 673) = 0;
  *(_DWORD *)(v3 + 668) = 0;
  *(_DWORD *)(v3 + 672) = 0;
  *(_DWORD *)v3 = &off_664220;
  *(_DWORD *)(v3 + 677) = 0;
  *(_BYTE *)(v3 + 808) = 0;
  *(_DWORD *)(v3 + 936) = 0;
  *(_DWORD *)(v3 + 940) = 0;
  *(_DWORD *)(v3 + 945) = 0;
  *(_DWORD *)(v3 + 941) = 0;
  *(_DWORD *)(v3 + 1204) = 0;
  *(_DWORD *)(v3 + 1208) = 0;
  *(_BYTE *)(v3 + 1076) = 0;
  *(_DWORD *)(v3 + 1213) = 0;
  *(_DWORD *)(v3 + 1209) = 0;
  *(_QWORD *)(v3 + 1472) = 0LL;
  *(_QWORD *)(v3 + 1480) = 0x46545700000000LL;
  *(_BYTE *)(v3 + 1344) = 0;
}
// 2BEA94: variable 'v3' is possibly undefined
// 664220: using guessed type void *;

//----- (002BEB14) --------------------------------------------------------
void __fastcall CWidgetRaceResults::Update(CWidgetRaceResults *this)
{
  CWidget::Update(this);
  sub_19751C(this);
}

//----- (002BEB28) --------------------------------------------------------
void __fastcall CWidgetRaceResults::Draw(CWidgetRaceResults *this)
{
  CWidgetRaceResults *v1; // r4
  unsigned int v2; // r8
  int v3; // r9
  float top; // s16
  float bottom; // s20
  float v6; // s18
  unsigned int alpha; // r5
  CRGBA v8; // r0
  float right; // r0
  float v10; // s16
  float v11; // s4
  const CRGBA *v12; // r0
  float v13; // s18
  int *p_m_nColor; // r11
  int *v15; // r8
  int v16; // r5
  float left; // s24
  const unsigned __int8 *v18; // r10
  float v19; // s26
  float v20; // s24
  GxtChar *v21; // r0
  float StringWidth; // r0
  const unsigned __int8 *v23; // r1
  float v24; // s24
  float v25; // r0
  float v26; // s20
  float v27; // r0
  float v28; // r1
  const CRGBA *v29; // r0
  CRGBA v30; // r0
  float v31; // s28
  float v32; // s30
  float v33; // s17
  float Height; // s0
  GxtChar *v35; // r0
  CRGBA v36; // r0
  CRGBA v37; // r0
  CRGBA v38; // r0
  float v39; // s28
  float v40; // s30
  float v41; // s17
  float v42; // r0
  UInt8 v43; // [sp+Ch] [bp-3BCh]
  unsigned int v44; // [sp+14h] [bp-3B4h]
  CText *v45; // [sp+18h] [bp-3B0h]
  CWidgetRaceResults *v46; // [sp+1Ch] [bp-3ACh]
  CRGBA v47; // [sp+20h] [bp-3A8h] BYREF
  CRGBA v48; // [sp+24h] [bp-3A4h] BYREF
  CRGBA v49; // [sp+28h] [bp-3A0h] BYREF
  CRGBA v50; // [sp+2Ch] [bp-39Ch] BYREF
  CRGBA v51; // [sp+30h] [bp-398h] BYREF
  CRGBA v52; // [sp+34h] [bp-394h] BYREF
  CRGBA v53; // [sp+38h] [bp-390h] BYREF
  CRect v54; // [sp+3Ch] [bp-38Ch] BYREF
  CRGBA v55; // [sp+4Ch] [bp-37Ch] BYREF
  CRGBA v56; // [sp+24Ch] [bp-17Ch] BYREF
  CRect Rectangle; // [sp+250h] [bp-178h] BYREF
  CRGBA v58; // [sp+260h] [bp-168h] BYREF
  CRGBA v59; // [sp+264h] [bp-164h] BYREF

  v1 = this;
  v2 = this->m_Color._anon_0._anon_0.alpha;
  if ( this->m_Color._anon_0._anon_0.alpha )
  {
    if ( strlen((const char *)this->m_DataCell) )
      v3 = strcasecmp((const char *)v1->m_DataCell, "DUMMY") != 0;
    else
      v3 = 0;
    if ( strlen((const char *)&v1->m_DataCell[1]) && strcasecmp((const char *)&v1->m_DataCell[1], "DUMMY") )
      ++v3;
    if ( strlen((const char *)&v1->m_DataCell[2]) && strcasecmp((const char *)&v1->m_DataCell[2], "DUMMY") )
      ++v3;
    if ( strlen((const char *)&v1->m_DataCell[3]) && strcasecmp((const char *)&v1->m_DataCell[3], "DUMMY") )
      ++v3;
    if ( strlen((const char *)&v1->m_DataCell[4]) && strcasecmp((const char *)&v1->m_DataCell[4], "DUMMY") )
      ++v3;
    if ( v3 )
    {
      top = v1->m_RectScreen.top;
      bottom = v1->m_RectScreen.bottom;
      CFont::SetBackground(0, 0);
      CFont::SetProportional(1u);
      CFont::SetOrientation(1u);
      CFont::SetRightJustifyWrap(0.0);
      CFont::SetEdge(0);
      v6 = (float)v2 / 255.0;
      alpha = (unsigned int)(float)(v6 * 255.0);
      CRGBA::CRGBA(&v58, 0, 0, 0, alpha);
      CFont::SetDropColor(v8);
      CFont::SetWrapx((float)RsGlobal.screenWidth);
      right = v1->m_RectScreen.right;
      v10 = (float)(fabsf(top - bottom) - (float)v3) / 6.5;
      v11 = v1->m_RectScreen.bottom;
      Rectangle.left = v1->m_RectScreen.left;
      Rectangle.right = right;
      Rectangle.bottom = v11;
      Rectangle.top = (float)(v10 * 1.5) + v11;
      CRGBA::CRGBA(&v55, 0, 0, 0, (unsigned int)(float)(v6 * 128.0));
      v44 = (unsigned int)(float)(v6 * 128.0);
      CRGBA::CRGBA(&v59, 0, 0, 0, v44);
      CRGBA::CRGBA((CRGBA *)&v54, 0, 0, 0, alpha);
      CRGBA::CRGBA(&v56, 0, 0, 0, alpha);
      CSprite2d::DrawRect(&Rectangle, &v55, &v59, (const CRGBA *)&v54, v12);
      CWidgetRaceResults::RenderTitleText(v1, Rectangle, v6);
      CFont::SetFontStyle(2u);
      v13 = v10 * 0.021;
      CFont::SetScale(v10 * 0.021);
      if ( v3 >= 1 )
      {
        p_m_nColor = &v1->m_DataCell[0].m_nColor;
        v43 = alpha;
        v15 = &v1->m_DataCell[0].m_nColor;
        v16 = v3;
        v46 = v1;
        do
        {
          left = v1->m_RectScreen.left;
          v18 = (const unsigned __int8 *)(v15 - 66);
          v19 = v1->m_RectScreen.right;
          if ( strlen((const char *)v15 - 264) )
          {
            if ( strcasecmp((const char *)v18, "DUMMY") )
            {
              v20 = fabsf(v19 - left) * 0.625;
              v21 = CText::Get(&TheText, v18);
              StringWidth = CFont::GetStringWidth(v21, 1u, 0);
              if ( StringWidth > v20 )
              {
                v13 = v13 * (float)(v20 / StringWidth);
                CFont::SetScale(v13);
              }
            }
          }
          if ( *v15 == 1 )
            v23 = "$~1~%d";
          else
            v23 = (const unsigned __int8 *)&dword_2BF074;
          v24 = fabsf(v1->m_RectScreen.right - v1->m_RectScreen.left) * 0.25;
          sprintf((unsigned __int8 *)&v59, v23, *(v15 - 2));
          AsciiToGxtChar((const Char *)&v59, (GxtChar *)&v55);
          v25 = CFont::GetStringWidth((GxtChar *)&v55, 1u, 0);
          if ( v25 > v24 )
          {
            v13 = v13 * (float)(v24 / v25);
            CFont::SetScale(v13);
          }
          v1 = v46;
          v15 += 67;
          --v16;
        }
        while ( v16 );
        v26 = Rectangle.top + 1.0;
        do
        {
          v45 = (CText *)v3;
          v27 = v1->m_RectScreen.left;
          v28 = v1->m_RectScreen.right;
          v54.bottom = v26;
          v54.left = v27;
          v54.right = v28;
          v54.top = v10 + v26;
          CRGBA::CRGBA(&v56, 0, 0, 0, v44);
          CRGBA::CRGBA(&v53, 0, 0, 0, v44);
          CRGBA::CRGBA(&v52, 0, 0, 0, v43);
          CRGBA::CRGBA(&v51, 0, 0, 0, v43);
          CSprite2d::DrawRect(&v54, &v56, &v53, &v52, v29);
          CFont::SetOrientation(1u);
          CRGBA::CRGBA(&v50, 0xFFu, 0xFFu, 0xFFu, v43);
          CFont::SetColor(v30);
          v31 = v54.left;
          v32 = v54.top + v54.bottom;
          v33 = fabsf(v54.right - v54.left);
          Height = CFont::GetHeight(0);
          v35 = CText::Get(&TheText, (const unsigned __int8 *)p_m_nColor - 264);
          CFont::PrintString(v31 + (float)(v33 * 0.03), (float)(v32 * 0.5) - (float)(Height * 0.5), v35);
          if ( *p_m_nColor == 1 )
          {
            CRGBA::CRGBA(&v49, 0, 0x67u, 0, v43);
            CFont::SetColor(v36);
            sprintf((unsigned __int8 *)&v59, "$~1~%d", *(p_m_nColor - 2));
          }
          else if ( *(p_m_nColor - 1) == 1 )
          {
            CRGBA::CRGBA(&v48, 0x5Du, 0x8Eu, 0xBEu, v43);
            CFont::SetColor(v37);
            sprintf((unsigned __int8 *)&v59, "%d:%.2d", *(p_m_nColor - 2) / 60, *(p_m_nColor - 2) % 60);
          }
          else
          {
            CRGBA::CRGBA(&v47, 0x5Du, 0x8Eu, 0xBEu, v43);
            CFont::SetColor(v38);
            sprintf((unsigned __int8 *)&v59, (const unsigned __int8 *)&dword_2BF074, *(p_m_nColor - 2));
          }
          v1 = v46;
          AsciiToGxtChar((const Char *)&v59, (GxtChar *)&v55);
          CFont::SetOrientation(2u);
          v39 = v54.right;
          v40 = v54.top + v54.bottom;
          v41 = fabsf(v54.right - v54.left);
          v42 = CFont::GetHeight(0);
          CFont::PrintString(v39 + (float)(v41 * -0.03), (float)(v40 * 0.5) - (float)(v42 * 0.5), (GxtChar *)&v55);
          v26 = (float)(v10 + 1.0) + v26;
          CFont::RenderFontBuffer();
          p_m_nColor += 67;
          --v3;
        }
        while ( v45 != (CText *)((char *)&dword_0 + 1) );
      }
    }
  }
}
// 2BEE26: conditional instruction was optimized away because r9.4>=1
// 2BEC4E: variable 'v8' is possibly undefined
// 2BED06: variable 'v12' is possibly undefined
// 2BEEBA: variable 'v29' is possibly undefined
// 2BEED4: variable 'v30' is possibly undefined
// 2BEF4A: variable 'v36' is possibly undefined
// 2BEF72: variable 'v37' is possibly undefined
// 2BEFB4: variable 'v38' is possibly undefined
// 0: using guessed type int dword_0;
// 2BF074: using guessed type int dword_2BF074;

//----- (002BF098) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CWidgetRaceResults::RenderTitleText(CWidgetRaceResults *this, CRect RectCell, float fAlpha)
{
  float right; // r8
  float top; // r4
  float left; // r5
  CRGBA v7; // r0
  float v8; // s20
  unsigned __int8 *m_szTitle; // r6
  GxtChar *v10; // r0
  float StringWidth; // r0
  float v12; // s0
  float v13; // s0
  GxtChar *v14; // r0
  CRGBA v15; // [sp+4h] [bp-3Ch] BYREF

  right = RectCell.right;
  top = RectCell.top;
  left = RectCell.left;
  CFont::SetOrientation(0);
  CFont::SetFontStyle(0);
  CRGBA::CRGBA(&v15, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)(fAlpha * 255.0));
  CFont::SetColor(v7);
  v8 = fabsf(top - RectCell.bottom) * 0.0325;
  CFont::SetScale(v8);
  m_szTitle = this->m_szTitle;
  v10 = CText::Get(&TheText, m_szTitle);
  StringWidth = CFont::GetStringWidth(v10, 1u, 0);
  v12 = fabsf(right - left) * 0.875;
  if ( StringWidth > v12 )
    CFont::SetScale(v8 * (float)(v12 / StringWidth));
  v13 = CFont::GetHeight(0) * 0.5;
  v14 = CText::Get(&TheText, m_szTitle);
  CFont::PrintString((float)(left + right) * 0.5, (float)((float)(top + RectCell.bottom) * 0.5) - v13, v14);
  CFont::RenderFontBuffer();
}
// 2BF098: fragmented variable at 0:r1.12,12:^48.4 may be wrong
// 2BF098: variables would overlap: 0:r1.12,12:^48.4 and ^48.4

//----- (002BF1B0) --------------------------------------------------------
void __fastcall CWidgetRaceResults::SetWidgetInfo2(
        CWidgetRaceResults *this,
        int nValue0,
        int nValue1,
        int nValue2,
        int nValue3,
        unsigned __int8 *pszText0,
        unsigned __int8 *pszText1)
{
  const char *v11; // r1
  const char *v12; // r5
  _DWORD v13[67]; // [sp+0h] [bp-130h] BYREF

  if ( (unsigned int)nValue0 <= 4 )
  {
    v11 = (const char *)pszText0;
    v12 = &byte_61CADE;
    if ( !pszText0 )
      v11 = &byte_61CADE;
    strcpy((char *)v13, v11);
    if ( pszText1 )
      v12 = (const char *)pszText1;
    strcpy((char *)&v13[32], v12);
    v13[64] = nValue1;
    v13[65] = nValue2;
    v13[66] = nValue3;
    qmemcpy(&this->m_DataCell[nValue0], v13, sizeof(this->m_DataCell[nValue0]));
  }
}
// 61CADE: using guessed type char byte_61CADE;

//----- (002BF23C) --------------------------------------------------------
void __fastcall CWidgetRaceResults::~CWidgetRaceResults(CWidgetRaceResults *this)
{
  void *v1; // r0

  CWidget::~CWidget(this);
  sub_191374(v1);
}
// 2BF248: variable 'v1' is possibly undefined

//----- (002BF24C) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetRaceResults::GetName(CWidgetRaceResults *this)
{
  return "Race Results";
}

//----- (002BF260) --------------------------------------------------------
void __fastcall CWidgetRacing::CWidgetRacing(
        CWidgetRacing *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  int v3; // r0

  CWidget::CWidget(this, pszSprite, WidgetPos, 0, HID_MAPPING_UNKNOWN);
  *(_QWORD *)(v3 + 144) = 0LL;
  *(_QWORD *)(v3 + 152) = 0LL;
  *(_DWORD *)(v3 + 160) = 0;
  *(_DWORD *)v3 = &off_6642B4;
}
// 2BF276: variable 'v3' is possibly undefined
// 6642B4: using guessed type void *;

//----- (002BF294) --------------------------------------------------------
void __fastcall CWidgetRacing::Update(CWidgetRacing *this)
{
  if ( CHud::bDrawingVitalStats )
    CWidget::SetEnabled(this, 0);
  CWidget::Update(this);
  sub_19751C(this);
}

//----- (002BF2C4) --------------------------------------------------------
void __fastcall CWidgetRacing::Draw(CWidgetRacing *this)
{
  unsigned int alpha; // r5
  float top; // s16
  float bottom; // s18
  int m_nMaxLaps; // r6
  float v6; // s20
  CRGBA v7; // r0
  CRGBA v8; // r0
  float v9; // s16
  float v10; // s18
  float v11; // s22
  GxtChar *v12; // r0
  float StringWidth; // r0
  int v14; // r1
  GxtChar *v15; // r0
  float v16; // r0
  GxtChar *v17; // r0
  float v18; // r0
  int v19; // r8
  float v20; // s22
  float left; // r0
  float right; // r1
  const CRGBA *v23; // r0
  int v24; // [sp+10h] [bp-170h]
  CRGBA v25; // [sp+18h] [bp-168h] BYREF
  CRGBA v26; // [sp+1Ch] [bp-164h] BYREF
  CRGBA v27; // [sp+20h] [bp-160h] BYREF
  CRect Rectangle; // [sp+24h] [bp-15Ch] BYREF
  CRGBA v29; // [sp+34h] [bp-14Ch] BYREF
  CRGBA v30; // [sp+38h] [bp-148h] BYREF
  CRGBA v31; // [sp+3Ch] [bp-144h] BYREF

  alpha = this->m_Color._anon_0._anon_0.alpha;
  if ( this->m_Color._anon_0._anon_0.alpha )
  {
    top = this->m_RectScreen.top;
    bottom = this->m_RectScreen.bottom;
    m_nMaxLaps = this->m_nMaxLaps;
    CFont::SetBackground(0, 0);
    CFont::SetProportional(1u);
    CFont::SetFontStyle(2u);
    CFont::SetOrientation(1u);
    CFont::SetRightJustifyWrap(0.0);
    CFont::SetEdge(0);
    v6 = (float)alpha / 255.0;
    CRGBA::CRGBA(&v30, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)(v6 * 255.0));
    CFont::SetColor(v7);
    CRGBA::CRGBA(&v29, 0, 0, 0, (unsigned int)(float)(v6 * 255.0));
    CFont::SetDropColor(v8);
    CFont::SetWrapx((float)RsGlobal.screenWidth);
    v9 = (float)(fabsf(top - bottom) + -2.0) / 3.0;
    v10 = v9 * 0.0325;
    CFont::SetScale(v9 * 0.0325);
    v11 = fabsf(this->m_RectScreen.right - this->m_RectScreen.left) * 0.6125;
    v12 = CText::Get(&TheText, "RAC_PTN");
    StringWidth = CFont::GetStringWidth(v12, 1u, 0);
    v14 = 3;
    if ( !m_nMaxLaps )
      v14 = 2;
    v24 = v14;
    if ( StringWidth > v11 )
    {
      v10 = v10 * (float)(v11 / StringWidth);
      CFont::SetScale(v10);
    }
    v15 = CText::Get(&TheText, "RAC_LAP");
    v16 = CFont::GetStringWidth(v15, 1u, 0);
    if ( v16 > v11 )
    {
      v10 = v10 * (float)(v11 / v16);
      CFont::SetScale(v10);
    }
    v17 = CText::Get(&TheText, "RAC_TIM");
    v18 = CFont::GetStringWidth(v17, 1u, 0);
    if ( v18 > v11 )
    {
      v10 = v10 * (float)(v11 / v18);
      CFont::SetScale(v10);
    }
    v19 = 0;
    v20 = this->m_RectScreen.bottom;
    while ( 1 )
    {
      left = this->m_RectScreen.left;
      right = this->m_RectScreen.right;
      Rectangle.bottom = v20;
      Rectangle.left = left;
      Rectangle.right = right;
      Rectangle.top = v9 + v20;
      CRGBA::CRGBA(&v31, 0, 0, 0, (unsigned int)(float)(v6 * 128.0));
      CRGBA::CRGBA(&v27, 0, 0, 0, (unsigned int)(float)(v6 * 128.0));
      CRGBA::CRGBA(&v26, 0, 0, 0, (unsigned int)(float)(v6 * 255.0));
      CRGBA::CRGBA(&v25, 0, 0, 0, (unsigned int)(float)(v6 * 255.0));
      CSprite2d::DrawRect(&Rectangle, &v31, &v27, &v26, v23);
      if ( !m_nMaxLaps )
        break;
      if ( v19 == 2 )
        goto LABEL_18;
      if ( v19 != 1 )
        goto LABEL_16;
      sprintf((unsigned __int8 *)&v31, "~f~%d~w~/%d", this->m_nCurrentLap, this->m_nMaxLaps);
      CWidgetRacing::RenderRowText(
        (CWidgetRacing *)LODWORD(Rectangle.right),
        "RAC_LAP",
        Rectangle,
        (const unsigned __int8 *)&v31,
        v10);
LABEL_19:
      v20 = (float)(v9 + 1.0) + v20;
      if ( ++v19 >= v24 )
        return;
    }
    if ( v19 != 1 )
    {
LABEL_16:
      if ( !v19 )
      {
        sprintf((unsigned __int8 *)&v31, "~f~%d~w~/%d", this->m_nPlace, this->m_nOpponents);
        CWidgetRacing::RenderRowText(
          (CWidgetRacing *)LODWORD(Rectangle.right),
          "RAC_PTN",
          Rectangle,
          (const unsigned __int8 *)&v31,
          v10);
      }
      goto LABEL_19;
    }
LABEL_18:
    sprintf((unsigned __int8 *)&v31, "%d:%.2d", this->m_nTimeInSeconds / 60, this->m_nTimeInSeconds % 60);
    CWidgetRacing::RenderRowText(
      (CWidgetRacing *)LODWORD(Rectangle.right),
      "RAC_TIM",
      Rectangle,
      (const unsigned __int8 *)&v31,
      v10);
    goto LABEL_19;
  }
}
// 2BF348: variable 'v7' is possibly undefined
// 2BF35C: variable 'v8' is possibly undefined
// 2BF4E0: variable 'v23' is possibly undefined

//----- (002BF608) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CWidgetRacing::RenderRowText(
        CWidgetRacing *this,
        const unsigned __int8 *pszTitle,
        CRect RectCell,
        const unsigned __int8 *pszStat,
        float fTextScale)
{
  float top; // r5
  float left; // r6
  float v8; // s26
  float Height; // s6
  float v10; // s22
  GxtChar *v11; // r0
  float StringWidth; // r0
  float v13; // r0
  GxtChar v14[292]; // [sp+0h] [bp-248h] BYREF

  top = RectCell.top;
  left = RectCell.left;
  CFont::SetScale(fTextScale);
  CFont::SetOrientation(1u);
  v8 = fabsf(RectCell.right - left);
  Height = CFont::GetHeight(0);
  v10 = (float)(top + RectCell.bottom) * 0.5;
  v11 = CText::Get(&TheText, pszTitle);
  CFont::PrintString((float)(v8 * 0.03) + left, v10 - (float)(Height * 0.5), v11);
  AsciiToGxtChar(pszStat, v14);
  StringWidth = CFont::GetStringWidth(v14, 1u, 0);
  if ( StringWidth > (float)(v8 * 0.275) )
    CFont::SetScale((float)((float)(v8 * 0.275) / StringWidth) * fTextScale);
  CFont::SetOrientation(2u);
  v13 = CFont::GetHeight(0);
  CFont::PrintString(RectCell.right - (float)(v8 * 0.03), v10 + (float)(v13 * -0.5), v14);
  CFont::RenderFontBuffer();
}
// 2BF608: fragmented variable at 0:r2.8,8:^250.8 may be wrong
// 2BF608: variables would overlap: 0:r2.8,8:^250.8 and ^250.4
// 2BF608: variables would overlap: 0:r2.8,8:^250.8 and ^254.4

//----- (002BF714) --------------------------------------------------------
void __fastcall CWidgetRacing::SetWidgetValue2(CWidgetRacing *this, float fValue0, float fValue1)
{
  this->m_nCurrentLap = (int)fValue0;
  this->m_nMaxLaps = (int)fValue1;
}

//----- (002BF72E) --------------------------------------------------------
void __fastcall CWidgetRacing::SetWidgetValue3(CWidgetRacing *this, float fValue0, float fValue1, float fValue2)
{
  this->m_nPlace = (int)fValue0;
  this->m_nOpponents = (int)fValue1;
  this->m_nTimeInSeconds = (int)fValue2;
}

//----- (002BF754) --------------------------------------------------------
void __fastcall CWidgetRacing::~CWidgetRacing(CWidgetRacing *this)
{
  void *v1; // r0

  CWidget::~CWidget(this);
  sub_191374(v1);
}
// 2BF760: variable 'v1' is possibly undefined

//----- (002BF764) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetRacing::GetName(CWidgetRacing *this)
{
  return "Race";
}

//----- (002BF770) --------------------------------------------------------
void __fastcall CWidgetRadar::CWidgetRadar(
        CWidgetRadar *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  CRGBA v4; // [sp+4h] [bp-14h] BYREF

  CWidget::CWidget(this, pszSprite, WidgetPos, 0x402u, HID_MAPPING_RADAR);
  this->_vptr$CWidget = (int (**)(void))&off_664348;
  CSprite2d::CSprite2d(&this->mSpriteCrossHairs);
  CRGBA::CRGBA(&v4, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
  CWidget::CreateHoldEffect(this, "hud_ticks", 0, (CRGBA)&v4, 1);
  this->m_fHoldEffectPeriod = 0.66;
  CSprite2d::SetTexture(&this->mSpriteCrossHairs, "crosshair", "crosshaira");
}
// 664348: using guessed type void *;

//----- (002BF808) --------------------------------------------------------
void __fastcall CWidgetRadar::Update(CWidgetRadar *this)
{
  CHoldEffect *m_pHoldEffect; // r0
  float left; // s0
  float right; // s4
  float v5; // s8
  float v6; // s0
  float v7; // s2
  float v8; // s4

  CWidget::Update(this);
  CWidget::ManageAlpha(this);
  m_pHoldEffect = this->m_pHoldEffect;
  if ( m_pHoldEffect )
  {
    left = this->m_RectScreen.left;
    right = this->m_RectScreen.right;
    v5 = right - left;
    v6 = (float)(left + right) * 0.5;
    v7 = (float)(this->m_RectScreen.top + this->m_RectScreen.bottom) * 0.5;
    v8 = fabsf(v5) * 0.52;
    m_pHoldEffect->m_RectScreen.left = v6 - v8;
    m_pHoldEffect->m_RectScreen.top = v8 + v7;
    m_pHoldEffect->m_RectScreen.right = v6 + v8;
    m_pHoldEffect->m_RectScreen.bottom = v7 - v8;
  }
}

//----- (002BF87C) --------------------------------------------------------
bool __fastcall CWidgetRadar::IsHeldDown(CWidgetRadar *this)
{
  _BOOL4 v2; // r0
  float m_fTapHoldTime; // s0
  char v4; // r1
  float m_fHoldEffectPeriod; // s2
  int v6; // r0

  v2 = CHID::Implements(this->m_HIDMapping);
  m_fTapHoldTime = this->m_fTapHoldTime;
  v4 = 0;
  m_fHoldEffectPeriod = this->m_fHoldEffectPeriod;
  if ( m_fTapHoldTime >= m_fHoldEffectPeriod )
    v4 = 1;
  v6 = !v2;
  if ( v6 || m_fTapHoldTime < m_fHoldEffectPeriod )
    return v6 & v4;
  else
    return sub_196BD4(this->m_HIDMapping, 0);
}

//----- (002BF8C0) --------------------------------------------------------
void __fastcall CWidgetRadar::~CWidgetRadar(CWidgetRadar *this)
{
  this->_vptr$CWidget = (int (**)(void))&off_664348;
  CSprite2d::~CSprite2d(&this->mSpriteCrossHairs);
  sub_19C514(this);
}
// 664348: using guessed type void *off_664348;

//----- (002BF8E8) --------------------------------------------------------
void __fastcall CWidgetRadar::~CWidgetRadar(CWidgetRadar *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_664348;
  CSprite2d::~CSprite2d(&this->mSpriteCrossHairs);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2BF90C: variable 'v2' is possibly undefined
// 664348: using guessed type void *off_664348;

//----- (002BF914) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetRadar::GetName(CWidgetRadar *this)
{
  return "Radar";
}

//----- (002BF920) --------------------------------------------------------
void __fastcall CWidgetRegion::CWidgetRegion(
        CWidgetRegion *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos,
        int nExtraFlags,
        HIDMapping Mapping)
{
  _DWORD *v5; // r0

  CWidget::CWidget(this, pszSprite, WidgetPos, nExtraFlags, Mapping);
  *v5 = &off_6643DC;
}
// 2BF93A: variable 'v5' is possibly undefined
// 6643DC: using guessed type void *;

//----- (002BF948) --------------------------------------------------------
void __fastcall CWidgetRegion::Draw(CWidgetRegion *this)
{
  CSprite2d *p_m_Sprite; // r0
  RwTexture_0 *mpTexture; // t1
  bool v4; // zf

  mpTexture = this->m_Sprite.mpTexture;
  p_m_Sprite = &this->m_Sprite;
  v4 = mpTexture == 0;
  if ( mpTexture )
    v4 = this->m_Color._anon_0._anon_0.alpha == 0;
  if ( !v4 )
    j_CSprite2d::Draw(p_m_Sprite, &this->m_RectScreen, &this->m_Color);
}

//----- (002BF968) --------------------------------------------------------
float __fastcall CWidgetRegion::StretchX(CWidgetRegion *this, float x)
{
  float v2; // s0

  v2 = x;
  if ( RsGlobal.screenWidth != 640 )
    return (float)(x / 640.0) * (float)RsGlobal.screenWidth;
  return v2;
}

//----- (002BF99C) --------------------------------------------------------
float __fastcall CWidgetRegion::StretchY(CWidgetRegion *this, float y)
{
  float v2; // s0

  v2 = y;
  if ( RsGlobal.screenHeight != 448 )
    return (float)(y / 448.0) * (float)RsGlobal.screenHeight;
  return v2;
}

//----- (002BF9D0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CWidgetRegion::DrawFrame(CWidgetRegion *this, float fCornerSize, CRect rect, float fAlpha)
{
  float32x2_t v4; // d3
  float32x2_t v5; // d4
  float32x2_t v6; // d6
  float top; // r6
  float left; // r10
  float v11; // s24
  float v12; // s6
  float v13; // [sp+20h] [bp-E0h]
  CRect v14; // [sp+24h] [bp-DCh] BYREF
  CRect v15; // [sp+34h] [bp-CCh] BYREF
  CRect v16; // [sp+44h] [bp-BCh] BYREF
  CRect v17; // [sp+54h] [bp-ACh] BYREF
  CRect v18; // [sp+64h] [bp-9Ch] BYREF
  CRect v19; // [sp+74h] [bp-8Ch] BYREF
  CRect v20; // [sp+84h] [bp-7Ch] BYREF
  char v21[20]; // [sp+94h] [bp-6Ch] BYREF
  float v22; // [sp+A8h] [bp-58h]
  float v23; // [sp+ACh] [bp-54h]
  float bottom; // [sp+B0h] [bp-50h]
  CRGBA v25; // [sp+B4h] [bp-4Ch] BYREF

  top = rect.top;
  v13 = rect.top;
  left = rect.left;
  CRGBA::CRGBA(&v25, 0xFFu, 0xFFu, 0xFFu, (unsigned int)fAlpha);
  this = (CWidgetRegion *)((char *)this + 8);
  bottom = rect.bottom;
  *(_QWORD *)&v21[12] = __PAIR64__(LODWORD(left), LODWORD(rect.bottom));
  v6.n64_f32[0] = fCornerSize;
  v5.n64_f32[0] = fabsf(top - rect.bottom) * 0.5;
  v4.n64_f32[0] = fabsf(rect.right - left) * 0.5;
  v11 = vmin_f32(v5, v6).n64_f32[0];
  v12 = vmin_f32(v4, v6).n64_f32[0];
  v20.left = rect.right - v12;
  *(_QWORD *)&v20.right = *(_QWORD *)&rect.right;
  v23 = v12 + left;
  *(float *)v21 = v12 + left;
  *(float *)&v21[8] = rect.right - v12;
  v22 = v11 + rect.bottom;
  *(float *)&v21[4] = v11 + rect.bottom;
  v20.top = v11 + rect.bottom;
  CSprite2d::Draw((CSprite2d *)this, (const CRect *)&v21[16], &v25, 0.0, 0.0, 0.33, 0.0, 0.0, 0.33, 0.33, 0.33);
  CSprite2d::Draw((CSprite2d *)this, (const CRect *)v21, &v25, 0.33, 0.0, 0.66, 0.0, 0.33, 0.33, 0.66, 0.33);
  CSprite2d::Draw((CSprite2d *)this, &v20, &v25, 0.66, 0.0, 1.0, 0.0, 0.66, 0.33, 1.0, 0.33);
  v17.bottom = v11 + rect.bottom;
  v17.left = rect.right - v12;
  v17.right = rect.right;
  v19.bottom = v11 + rect.bottom;
  v19.left = left;
  v19.right = v12 + left;
  v18.bottom = v11 + rect.bottom;
  v18.left = v12 + left;
  v18.right = rect.right - v12;
  v19.top = top - v11;
  v18.top = top - v11;
  v17.top = top - v11;
  CSprite2d::Draw((CSprite2d *)this, &v19, &v25, 0.0, 0.33, 0.33, 0.33, 0.0, 0.66, 0.33, 0.66);
  CSprite2d::Draw((CSprite2d *)this, &v18, &v25, 0.33, 0.33, 0.66, 0.33, 0.33, 0.66, 0.66, 0.66);
  CSprite2d::Draw((CSprite2d *)this, &v17, &v25, 0.66, 0.33, 1.0, 0.33, 0.66, 0.66, 1.0, 0.66);
  v16.left = left;
  v16.bottom = top - v11;
  v16.right = v12 + left;
  v15.bottom = top - v11;
  v15.left = v12 + left;
  v15.right = rect.right - v12;
  v14.bottom = top - v11;
  v16.top = v13;
  v15.top = v13;
  v14.left = rect.right - v12;
  v14.top = v13;
  v14.right = rect.right;
  CSprite2d::Draw((CSprite2d *)this, &v16, &v25, 0.0, 0.66, 0.33, 0.66, 0.0, 1.0, 0.33, 1.0);
  CSprite2d::Draw((CSprite2d *)this, &v15, &v25, 0.33, 0.66, 0.66, 0.66, 0.33, 1.0, 0.66, 1.0);
  CSprite2d::Draw((CSprite2d *)this, &v14, &v25, 0.66, 0.66, 1.0, 0.66, 0.66, 1.0, 1.0, 1.0);
}
// 2BF9D0: fragmented variable at 0:r2.8,8:^108.8 may be wrong
// 2BF9D0: variables would overlap: 0:r2.8,8:^108.8 and ^108.4
// 2BF9D0: variables would overlap: 0:r2.8,8:^108.8 and ^10C.4

//----- (002BFBF0) --------------------------------------------------------
void __fastcall CWidgetRegion::~CWidgetRegion(CWidgetRegion *this)
{
  void *v1; // r0

  CWidget::~CWidget(this);
  sub_191374(v1);
}
// 2BFBFC: variable 'v1' is possibly undefined

//----- (002BFC00) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetRegion::GetName(CWidgetRegion *this)
{
  return (_BYTE *)&nullsub_2;
}

//----- (002BFC08) --------------------------------------------------------
bool __fastcall CWidgetRegion::IsRegion(CWidgetRegion *this)
{
  return 1;
}

//----- (002BFC0C) --------------------------------------------------------
void __fastcall CWidgetRegionArcadeStick::CWidgetRegionArcadeStick(
        CWidgetRegionArcadeStick *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos,
        int nExtraFlags,
        HIDMapping Mapping)
{
  _DWORD *v5; // r0

  CWidgetRegion::CWidgetRegion(this, pszSprite, WidgetPos, nExtraFlags, Mapping);
  v5[36] = 1;
  v5[37] = 1;
  *v5 = &off_664470;
}
// 2BFC22: variable 'v5' is possibly undefined
// 664470: using guessed type void *;

//----- (002BFC38) --------------------------------------------------------
void __fastcall CWidgetRegionArcadeStick::Update(CWidgetRegionArcadeStick *this)
{
  CWidgetRegion::Update(this);
  sub_19751C(this);
}

//----- (002BFC4C) --------------------------------------------------------
void __fastcall CWidgetRegionArcadeStick::Draw(CWidgetRegionArcadeStick *this)
{
  int m_nTouchIndex; // r0
  int v3; // r1
  CVector2D *v4; // r0
  float v5; // s6
  float v6; // s8
  float v7; // s2
  float v8; // s10
  float v9; // s6
  float v10; // s6
  float top; // s2
  float left; // s0
  float v13; // s6
  float right; // s4
  float v15; // s0
  float v16; // s4
  __int64 v17; // r0
  CRect v18; // [sp+20h] [bp-18h] BYREF

  if ( this->m_Color._anon_0._anon_0.alpha )
  {
    m_nTouchIndex = this->m_nTouchIndex;
    this->m_nCellX = 1;
    this->m_nCellY = 1;
    if ( CTouchInterface::IsTouchDown(m_nTouchIndex) )
    {
      v3 = this->m_nTouchIndex;
      if ( this == CWidget::m_pInitialTouchWidget[v3] )
      {
        CTouchInterface::GetTouchPosition((CVector2D *)&v18, v3);
        v4 = &CWidget::m_vecTouchAnchor[this->m_nTouchIndex];
        v5 = fabsf(this->m_RectScreen.right - this->m_RectScreen.left);
        v6 = v18.left - v4->x;
        v7 = v18.top - v4->y;
        v8 = v5 * -0.1;
        v9 = v5 * 0.1;
        if ( v6 < v8 )
          this->m_nCellX = 0;
        if ( v6 > v9 )
          this->m_nCellX = 2;
        v10 = fabsf(this->m_RectScreen.top - this->m_RectScreen.bottom);
        if ( v7 < (float)(v10 * -0.1) )
          this->m_nCellY = 0;
        if ( v7 > (float)(v10 * 0.1) )
          this->m_nCellY = 2;
      }
    }
    top = this->m_RectScreen.top;
    left = this->m_RectScreen.left;
    v13 = top - this->m_RectScreen.bottom;
    right = this->m_RectScreen.right;
    v18.top = top;
    v15 = (float)(left + right) * 0.5;
    v16 = fabsf(v13) * 0.75;
    v18.bottom = top - v16;
    v18.left = v15 - (float)(v16 * 0.5);
    v18.right = (float)(v16 * 0.5) + v15;
    v17 = *(_QWORD *)&this->m_nCellX;
    CSprite2d::Draw(
      &this->m_Sprite,
      &v18,
      &this->m_Color,
      (float)this->m_nCellX * 0.333,
      (float)this->m_nCellY * 0.333,
      (float)(v17 + 1) * 0.333,
      (float)this->m_nCellY * 0.333,
      (float)this->m_nCellX * 0.333,
      (float)(HIDWORD(v17) + 1) * 0.333,
      (float)(v17 + 1) * 0.333,
      (float)(HIDWORD(v17) + 1) * 0.333);
  }
}

//----- (002BFDF0) --------------------------------------------------------
void __fastcall CWidgetRegionArcadeStick::GetWidgetValue2(
        CWidgetRegionArcadeStick *this,
        float *pfValue0,
        float *pfValue1)
{
  *pfValue0 = (float)this->m_nCellX;
  *pfValue1 = (float)this->m_nCellY;
}

//----- (002BFE0C) --------------------------------------------------------
void __fastcall CWidgetRegionArcadeStick::SetWidgetValue(CWidgetRegionArcadeStick *this, float fValue)
{
  if ( fValue == 0.0 )
    CWidget::SetTexture(this, &this->m_Sprite, "ArcadeJoystick_Knob", 1);
  if ( fValue == 1.0 )
    CWidget::SetTexture(this, &this->m_Sprite, "ArcadeJoystick_Knob_orange", 1);
  if ( fValue == 2.0 )
    CWidget::SetTexture(this, &this->m_Sprite, "ArcadeJoystick_Knob_Teal", 1);
  if ( fValue == 3.0 )
    sub_18CDC4(this, &this->m_Sprite, "ArcadeJoystick_Knob_white", 1);
}

//----- (002BFEFC) --------------------------------------------------------
void __fastcall CWidgetRegionArcadeStick::~CWidgetRegionArcadeStick(CWidgetRegionArcadeStick *this)
{
  void *v1; // r0

  CWidget::~CWidget(this);
  sub_191374(v1);
}
// 2BFF08: variable 'v1' is possibly undefined

//----- (002BFF0C) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetRegionArcadeStick::GetName(CWidgetRegionArcadeStick *this)
{
  return "STICK";
}

//----- (002BFF18) --------------------------------------------------------
void __fastcall CWidgetRegionBasketBallJump::CWidgetRegionBasketBallJump(
        CWidgetRegionBasketBallJump *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  int v3; // r0
  int v4; // r2

  CWidgetRegion::CWidgetRegion(this, pszSprite, WidgetPos, 0, HID_MAPPING_UNKNOWN);
  *(_BYTE *)(v3 + 144) = 0;
  v4 = *(_DWORD *)(v3 + 128);
  *(_DWORD *)v3 = &off_664504;
  *(_DWORD *)(v3 + 128) = v4 | 4;
}
// 2BFF2A: variable 'v3' is possibly undefined
// 664504: using guessed type void *;

//----- (002BFF4C) --------------------------------------------------------
void __fastcall CWidgetRegionBasketBallJump::Update(CWidgetRegionBasketBallJump *this)
{
  CWidgetRegion::Update(this);
  if ( !CTouchInterface::IsTouchDown(this->m_nTouchIndex) )
    this->m_bTouched = 0;
}

//----- (002BFF68) --------------------------------------------------------
void __fastcall CWidgetRegionBasketBallJump::OnInitialTouch(CWidgetRegionBasketBallJump *this)
{
  CWidget::OnInitialTouch(this);
  this->m_bTouched = 1;
}

//----- (002BFF7A) --------------------------------------------------------
bool __fastcall CWidgetRegionBasketBallJump::IsTouched(CWidgetRegionBasketBallJump *this, CVector2D *pVecOut)
{
  return this->m_bTouched;
}

//----- (002BFF80) --------------------------------------------------------
void __fastcall CWidgetRegionBasketBallJump::~CWidgetRegionBasketBallJump(CWidgetRegionBasketBallJump *this)
{
  void *v1; // r0

  CWidget::~CWidget(this);
  sub_191374(v1);
}
// 2BFF8C: variable 'v1' is possibly undefined

//----- (002BFF90) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetRegionBasketBallJump::GetName(CWidgetRegionBasketBallJump *this)
{
  return (_BYTE *)sub_2BFF94;
}
// 2BFF94: using guessed type int sub_2BFF94();

//----- (002BFF9C) --------------------------------------------------------
void __fastcall CWidgetRegionColorPicker::CWidgetRegionColorPicker(
        CWidgetRegionColorPicker *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  _DWORD *v3; // r0

  CWidgetRegion::CWidgetRegion(this, pszSprite, WidgetPos, 4, HID_MAPPING_UNKNOWN);
  *v3 = &off_664598;
}
// 2BFFB4: variable 'v3' is possibly undefined
// 664598: using guessed type void *;

//----- (002BFFC0) --------------------------------------------------------
float __fastcall CWidgetRegionColorPicker::GetWidgetValue(CWidgetRegionColorPicker *this)
{
  float left; // s16
  float right; // s18
  float x; // s20
  CVector2D v7[5]; // [sp+0h] [bp-28h] BYREF

  if ( (*((int (__fastcall **)(CWidgetRegionColorPicker *, _DWORD))this->_vptr$CWidget + 20))(this, 0) != 1 )
    return 0.0;
  CTouchInterface::GetTouchPosition(v7, this->m_nTouchIndex);
  left = this->m_RectScreen.left;
  right = this->m_RectScreen.right;
  x = v7[0].x;
  CTouchInterface::GetTouchPosition(v7, this->m_nTouchIndex);
  return (float)((int)(float)((float)((float)(x - left) / fabsf(right - left)) * 8.0)
               + 8
               * (int)(float)((float)((float)(v7[0].y - this->m_RectScreen.bottom)
                                    / fabsf(this->m_RectScreen.top - this->m_RectScreen.bottom))
                            * 8.0));
}

//----- (002C0060) --------------------------------------------------------
void __fastcall CWidgetRegionColorPicker::~CWidgetRegionColorPicker(CWidgetRegionColorPicker *this)
{
  void *v1; // r0

  CWidget::~CWidget(this);
  sub_191374(v1);
}
// 2C006C: variable 'v1' is possibly undefined

//----- (002C0070) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetRegionColorPicker::GetName(CWidgetRegionColorPicker *this)
{
  return "Color Pick";
}

//----- (002C0080) --------------------------------------------------------
void __fastcall CWidgetRegionDriveHybrid::CWidgetRegionDriveHybrid(
        CWidgetRegionDriveHybrid *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  CWidgetRegion::CWidgetRegion(this, pszSprite, WidgetPos, 0, HID_MAPPING_ACCELERATE);
  this->_vptr$CWidget = (int (**)(void))&off_66462C;
  CSprite2d::CSprite2d(&this->mSpriteCorner);
  CSprite2d::CSprite2d(&this->mSpriteCornerIcon);
  this->m_nCornerAlpha = 0;
  CWidget::SetTexture(this, &this->mSpriteCorner, "CornerGradient", 1);
  CWidget::SetTexture(this, &this->mSpriteCornerIcon, "accelerate_solo", 1);
}
// 66462C: using guessed type void *;

//----- (002C0108) --------------------------------------------------------
void __fastcall CWidgetRegionDriveHybrid::Update(CWidgetRegionDriveHybrid *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  int v4; // r5
  CVehicle *PlayerVehicle; // r0
  CVehicle *v6; // r0
  float v7; // s16
  CPlayerPed *PlayerPed; // r0
  int bApplyBrake; // r6
  CPlayerPed *v10; // r0
  CPad *PadFromPlayer; // r0
  CPad *Pad; // r0
  CPlayerPed *v13; // r0
  CPad *v14; // r0
  CPlayerPed *v15; // r0
  CPlayerPed *v16; // r0
  double v17; // d17
  double m_nCornerAlpha; // d16
  unsigned __int32 v19; // s0
  CVector v20; // [sp+4h] [bp-24h] BYREF
  CVector v21; // 0:r2.8,8:^0.4

  CWidgetRegion::Update(this);
  v4 = 0;
  if ( !FindPlayerVehicle(-1, 0) )
    goto LABEL_28;
  PlayerVehicle = FindPlayerVehicle(-1, 0);
  *(_QWORD *)&v21.x = 0LL;
  v21.z = 0.0;
  CPhysical::GetSpeed(&v20, PlayerVehicle, v21);
  v6 = FindPlayerVehicle(-1, 0);
  v7 = (float)((float)((float)(v20.x * v6->m_pMat->xy) + (float)(v20.y * v6->m_pMat->yy))
             + (float)(v20.z * v6->m_pMat->zy))
     / 0.0055556;
  if ( fabsf(v7) < 0.42 )
    v7 = 0.0;
  if ( (*((int (__fastcall **)(CWidgetRegionDriveHybrid *, _DWORD))this->_vptr$CWidget + 20))(this, 0) != 1 )
  {
    PlayerPed = FindPlayerPed(-1);
    if ( CPlayerPed::GetPadFromPlayer(PlayerPed)->bApplyGas )
    {
      bApplyBrake = 1;
    }
    else
    {
      v10 = FindPlayerPed(-1);
      PadFromPlayer = CPlayerPed::GetPadFromPlayer(v10);
      bApplyBrake = PadFromPlayer->bApplyBrake;
      if ( PadFromPlayer->bApplyBrake )
        bApplyBrake = 1;
    }
    if ( FindPlayerVehicle(-1, 0)->m_vehicleType == 4
      || FindPlayerVehicle(-1, 0)->m_vehicleType == 3
      || (Pad = CPad::GetPad(0), CPad::IsFlyingRCVehicle(Pad))
      || CTheScripts::pActiveScripts && !strcmp((const char *)CTheScripts::pActiveScripts->ScriptName, "lowgame") )
    {
      if ( bApplyBrake )
        goto LABEL_17;
    }
    else
    {
      if ( v7 == 0.0 )
      {
        v4 = 0;
        if ( (bApplyBrake & !CTouchInterface::IsTouched(WIDGET_HANDBRAKE, 0, 1)) == 0 )
          goto LABEL_28;
LABEL_17:
        v13 = FindPlayerPed(-1);
        v14 = CPlayerPed::GetPadFromPlayer(v13);
        v4 = 0;
LABEL_18:
        v14->bApplyGas = v4;
        v15 = FindPlayerPed(-1);
        CPlayerPed::GetPadFromPlayer(v15)->bApplyBrake = v4;
        goto LABEL_28;
      }
      if ( bApplyBrake == 1 )
        goto LABEL_17;
    }
    v4 = 0;
    goto LABEL_28;
  }
  if ( v7 > 15.0
    || (*((int (__fastcall **)(CWidgetRegionDriveHybrid *))this->_vptr$CWidget + 10))(this) != 1
    || FindPlayerVehicle(-1, 0)->m_vehicleType == 10 )
  {
    v4 = 1;
    goto LABEL_28;
  }
  v4 = 1;
  if ( FindPlayerVehicle(-1, 0)->m_vehicleType != 4 )
  {
    v16 = FindPlayerPed(-1);
    v14 = CPlayerPed::GetPadFromPlayer(v16);
    goto LABEL_18;
  }
LABEL_28:
  v17 = CWidget::m_fElapsedTime * this->m_fFadeRate;
  m_nCornerAlpha = (double)this->m_nCornerAlpha;
  if ( v4 == 1 )
  {
    v2.n64_u32[0] = 1120403456;
    v1.n64_f32[0] = v17 * 0.389999986 + m_nCornerAlpha;
    v19 = vmin_f32(v1, v2).n64_u32[0];
  }
  else
  {
    v2.n64_u32[0] = 0;
    v1.n64_f32[0] = m_nCornerAlpha + v17 * -0.689999998;
    v19 = vmax_f32(v1, v2).n64_u32[0];
  }
  this->m_nCornerAlpha = (int)*(float *)&v19;
}
// 2C02FA: variable 'v1' is possibly undefined
// 2C02FA: variable 'v2' is possibly undefined

//----- (002C0364) --------------------------------------------------------
bool __fastcall CWidgetRegionDriveHybrid::IsTouched(CWidgetRegionDriveHybrid *this, CVector2D *pVecOut)
{
  CWidget *v4; // r4
  bool v5; // r5
  CWidget *v6; // r4

  if ( FindPlayerVehicle(-1, 0) || CPad::GetPad(0)->bHasJetPack || CPad::GetPad(0)->bTrainPassenger )
  {
    if ( CWidget::IsTouched(this, pVecOut) )
    {
      v4 = CTouchInterface::m_pWidgets[3];
      if ( CTouchInterface::m_pWidgets[3] )
      {
        if ( CWidget::GetEnabled(CTouchInterface::m_pWidgets[3]) )
        {
          v5 = 0;
          if ( (*((int (__fastcall **)(CWidget *, _DWORD))v4->_vptr$CWidget + 20))(v4, 0) )
            return v5;
        }
      }
      v6 = CTouchInterface::m_pWidgets[4];
      if ( CTouchInterface::m_pWidgets[4] && CWidget::GetEnabled(CTouchInterface::m_pWidgets[4]) )
        return (*((int (__fastcall **)(CWidget *, _DWORD))v6->_vptr$CWidget + 20))(v6, 0) == 0;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    CWidget::SetEnabled(this, 0);
    return 0;
  }
}

//----- (002C040C) --------------------------------------------------------
void __fastcall CWidgetRegionDriveHybrid::Draw(CWidgetRegionDriveHybrid *this)
{
  CVehicle *PlayerVehicle; // r5
  CPlayerPed *PlayerPed; // r0
  CRGBA v4; // [sp+4h] [bp-34h] BYREF
  CRect v5; // [sp+8h] [bp-30h] BYREF
  CRect Rectangle; // [sp+18h] [bp-20h] BYREF

  if ( this->m_bEnabled && this->m_nCornerAlpha >= 2 && FindPlayerVehicle(-1, 0) )
  {
    PlayerVehicle = FindPlayerVehicle(-1, 0);
    PlayerPed = FindPlayerPed(-1);
    if ( CVehicle::IsDriver(PlayerVehicle, PlayerPed) )
    {
      Rectangle.top = (float)RsGlobal.screenHeight + (float)((float)RsGlobal.screenHeight * -0.02);
      Rectangle.right = (float)RsGlobal.screenWidth + (float)((float)RsGlobal.screenWidth * -0.015);
      Rectangle.bottom = Rectangle.top + (float)((float)RsGlobal.screenHeight * -0.0835);
      Rectangle.left = Rectangle.right + (float)((float)RsGlobal.screenWidth * -0.0625);
      CRGBA::CRGBA((CRGBA *)&v5, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)((float)this->m_nCornerAlpha * 2.55));
      CSprite2d::Draw(&this->mSpriteCornerIcon, &Rectangle, (const CRGBA *)&v5);
      v5.right = (float)RsGlobal.screenWidth;
      v5.top = (float)RsGlobal.screenHeight;
      v5.left = (float)RsGlobal.screenWidth + (float)((float)RsGlobal.screenWidth * -0.125);
      v5.bottom = v5.top + (float)(v5.top * -0.167);
      CRGBA::CRGBA(&v4, 0xFFu, 0xFFu, 0xFFu, this->m_nCornerAlpha);
      CSprite2d::Draw(&this->mSpriteCorner, &v5, &v4);
    }
  }
}

//----- (002C0568) --------------------------------------------------------
void __fastcall CWidgetRegionDriveHybrid::~CWidgetRegionDriveHybrid(CWidgetRegionDriveHybrid *this)
{
  CSprite2d *p_mSpriteCorner; // r5

  this->_vptr$CWidget = (int (**)(void))&off_66462C;
  p_mSpriteCorner = &this->mSpriteCorner;
  CSprite2d::~CSprite2d(&this->mSpriteCornerIcon);
  CSprite2d::~CSprite2d(p_mSpriteCorner);
  sub_19C514(this);
}
// 66462C: using guessed type void *off_66462C;

//----- (002C0598) --------------------------------------------------------
void __fastcall CWidgetRegionDriveHybrid::~CWidgetRegionDriveHybrid(CWidgetRegionDriveHybrid *this)
{
  CSprite2d *p_mSpriteCorner; // r5
  void *v3; // r0

  this->_vptr$CWidget = (int (**)(void))&off_66462C;
  p_mSpriteCorner = &this->mSpriteCorner;
  CSprite2d::~CSprite2d(&this->mSpriteCornerIcon);
  CSprite2d::~CSprite2d(p_mSpriteCorner);
  CWidget::~CWidget(this);
  sub_191374(v3);
}
// 2C05C4: variable 'v3' is possibly undefined
// 66462C: using guessed type void *off_66462C;

//----- (002C05CC) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetRegionDriveHybrid::GetName(CWidgetRegionDriveHybrid *this)
{
  return "Drive Hybrid";
}

//----- (002C05E0) --------------------------------------------------------
void __fastcall CWidgetRegionFlick::CWidgetRegionFlick(
        CWidgetRegionFlick *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  CWidgetRegion::CWidgetRegion(this, pszSprite, WidgetPos, 0, HID_MAPPING_UNKNOWN);
  this->_vptr$CWidget = (int (**)(void))&off_6646C0;
  CSprite2d::CSprite2d(&this->mSpriteArrow);
  this->m_nSteerAmount = 0;
  CWidget::SetTexture(this, &this->mSpriteArrow, "Arrow", 1);
}
// 6646C0: using guessed type void *;

//----- (002C0630) --------------------------------------------------------
void __fastcall CWidgetRegionFlick::Update(CWidgetRegionFlick *this)
{
  float v2; // s0
  float x; // s2
  int v4; // r1
  bool *v5; // r0
  bool *v6; // r2
  CVector2D v7; // [sp+0h] [bp-10h] BYREF

  CWidgetRegion::Update(this);
  if ( CWidget::IsTouched(this, 0) )
  {
    if ( !this->m_nSteerAmount )
    {
      CTouchInterface::GetTouchPosition(&v7, this->m_nTouchIndex);
      v2 = (float)RsGlobal.screenWidth * 0.004883;
      x = CWidget::m_vecTouchAnchor[this->m_nTouchIndex].x;
      if ( v7.x > (float)(x + v2) )
      {
        v4 = 128;
        v5 = &bDrawLeft;
        v6 = &bDrawRight;
LABEL_9:
        *v6 = 1;
        *v5 = 0;
        this->m_nSteerAmount = v4;
        return;
      }
      if ( v7.x < (float)(x - v2) )
      {
        v4 = -128;
        v5 = &bDrawRight;
        v6 = &bDrawLeft;
        goto LABEL_9;
      }
    }
  }
  else
  {
    bDrawLeft = 0;
    bDrawRight = 0;
    this->m_nSteerAmount = 0;
  }
}

//----- (002C0700) --------------------------------------------------------
void __fastcall CWidgetRegionFlick::Draw(CWidgetRegionFlick *this)
{
  float v2; // s0
  float v3; // s2
  float v4; // s4
  float v5; // s0
  float v6; // s2
  float v7; // s4
  CRGBA v8; // [sp+4h] [bp-24h] BYREF
  CRect Rectangle; // [sp+8h] [bp-20h] BYREF
  CVector2D v10; // [sp+18h] [bp-10h] BYREF

  CWidgetRegion::Draw(this);
  if ( !CPad::GetPad(0)->DisablePlayerControls && CWidget::IsTouched(this, 0) )
  {
    CTouchInterface::GetTouchPosition(&v10, this->m_nTouchIndex);
    if ( bDrawRight )
    {
      v2 = (float)RsGlobal.screenWidth * 0.03125;
      v3 = v10.y + (float)((float)RsGlobal.screenHeight * -0.065104);
      v4 = v10.x + (float)((float)RsGlobal.screenWidth * 0.032227);
      Rectangle.bottom = v3 - v2;
      Rectangle.left = v4 - v2;
      Rectangle.right = v4 + v2;
      Rectangle.top = v3 + v2;
      CRGBA::CRGBA(&v8, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
      CSprite2d::Draw(&this->mSpriteArrow, &Rectangle, &v8);
    }
    else if ( bDrawLeft )
    {
      v5 = (float)RsGlobal.screenWidth * 0.03125;
      v6 = v10.y + (float)((float)RsGlobal.screenHeight * -0.065104);
      v7 = v10.x + (float)((float)RsGlobal.screenWidth * -0.032227);
      Rectangle.bottom = v6 - v5;
      Rectangle.left = v7 - v5;
      Rectangle.right = v7 + v5;
      Rectangle.top = v6 + v5;
      CRGBA::CRGBA(&v8, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
      CSprite2d::DrawRotated(&this->mSpriteArrow, &Rectangle, 3.14, &v8);
    }
  }
}

//----- (002C0870) --------------------------------------------------------
bool __fastcall CWidgetRegionFlick::IsTouched(CWidgetRegionFlick *this, CVector2D *pVecOut)
{
  CVector2D *p_y; // r1
  float v5; // s0
  bool result; // r0
  float m_nSteerAmount; // s0

  if ( !CHID::Implements(HID_MAPPING_VEHICLE_STEER_X) && !CHID::Implements(HID_MAPPING_VEHICLE_STEER_Y) )
    goto LABEL_10;
  CHID::IsPressed(HID_MAPPING_VEHICLE_STEER_X, &pVecOut->x);
  p_y = pVecOut;
  if ( pVecOut )
    p_y = (CVector2D *)&pVecOut->y;
  CHID::IsPressed(HID_MAPPING_VEHICLE_STEER_Y, &p_y->x);
  if ( CHID::IsPressed(HID_MAPPING_VEHICLE_STEER_X, 0) || CHID::IsPressed(HID_MAPPING_VEHICLE_STEER_Y, 0) )
  {
    if ( pVecOut )
    {
      v5 = pVecOut->y * 128.0;
      pVecOut->x = pVecOut->x * 128.0;
      pVecOut->y = v5;
    }
    return 1;
  }
  else
  {
LABEL_10:
    result = CWidget::IsTouched(this, 0);
    if ( pVecOut )
    {
      m_nSteerAmount = (float)this->m_nSteerAmount;
      pVecOut->y = 0.0;
      pVecOut->x = m_nSteerAmount;
    }
  }
  return result;
}

//----- (002C090C) --------------------------------------------------------
void __fastcall CWidgetRegionFlick::~CWidgetRegionFlick(CWidgetRegionFlick *this)
{
  this->_vptr$CWidget = (int (**)(void))&off_6646C0;
  CSprite2d::~CSprite2d(&this->mSpriteArrow);
  sub_19C514(this);
}
// 6646C0: using guessed type void *off_6646C0;

//----- (002C0934) --------------------------------------------------------
void __fastcall CWidgetRegionFlick::~CWidgetRegionFlick(CWidgetRegionFlick *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_6646C0;
  CSprite2d::~CSprite2d(&this->mSpriteArrow);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2C0958: variable 'v2' is possibly undefined
// 6646C0: using guessed type void *off_6646C0;

//----- (002C0960) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetRegionFlick::GetName(CWidgetRegionFlick *this)
{
  return (_BYTE *)sub_2C0964;
}
// 2C0964: using guessed type int sub_2C0964();

//----- (002C0970) --------------------------------------------------------
void __fastcall CWidgetRegionGang::CWidgetRegionGang(
        CWidgetRegionGang *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  CWidgetRegion::CWidgetRegion(this, pszSprite, WidgetPos, 3084, HID_MAPPING_GANG_RECRUIT);
  *(_QWORD *)&this->mTitle.left = 0xC974240049742400LL;
  *(_QWORD *)&this->mTitle.right = 0x49742400C9742400LL;
  this->_vptr$CWidget = (int (**)(void))&off_664754;
  CSprite2d::CSprite2d(&this->mGangTitle);
  CSprite2d::CSprite2d(&this->mSpriteOverlay);
  CWidget::SetTexture(this, &this->mSpriteOverlay, "white", 1);
  CWidget::SetTexture(this, &this->mGangTitle, "GangBackground", 1);
  CWidgetRegionGang::BuildRects(this);
}
// 664754: using guessed type void *;

//----- (002C0A0C) --------------------------------------------------------
void __fastcall CWidgetRegionGang::BuildRects(CWidgetRegionGang *this)
{
  float left; // s0
  float right; // s4
  float top; // s2
  float v5; // s16
  float v6; // s6
  __int64 v7; // kr00_8
  __int64 v8; // kr08_8
  __int64 v9; // kr10_8
  bool v10; // zf
  bool v11; // zf
  bool v12; // zf
  float v13; // s0
  float bottom; // s6
  float v15; // s2
  float v16; // s6
  float v17; // s4
  float v18; // s0
  CRect v19; // [sp+0h] [bp-48h] BYREF
  CRect Rect; // [sp+10h] [bp-38h] BYREF

  left = this->m_RectScreen.left;
  right = this->m_RectScreen.right;
  top = this->m_RectScreen.top;
  v5 = fabsf(top - this->m_RectScreen.bottom) * 0.05;
  v6 = fabsf(right - left) * 0.4;
  Rect.left = v5 + left;
  Rect.bottom = top - (float)(v6 + v5);
  Rect.right = v6 + (float)(v5 + left);
  Rect.top = v6 + Rect.bottom;
  v7 = *(_QWORD *)&CTouchInterface::m_pWidgets[106];
  v8 = *(_QWORD *)&CTouchInterface::m_pWidgets[108];
  v9 = *(_QWORD *)&CTouchInterface::m_pWidgets[110];
  v10 = CTouchInterface::m_pWidgets[106] == 0;
  v19.bottom = Rect.bottom;
  v19.right = right - v5;
  v19.left = (float)(right - v5) - v6;
  v19.top = v6 + Rect.bottom;
  if ( CTouchInterface::m_pWidgets[106] )
    v10 = CTouchInterface::m_pWidgets[107] == 0;
  if ( !v10 )
  {
    v11 = CTouchInterface::m_pWidgets[108] == 0;
    if ( CTouchInterface::m_pWidgets[108] )
      v11 = CTouchInterface::m_pWidgets[109] == 0;
    if ( !v11 )
    {
      v12 = CTouchInterface::m_pWidgets[111] == 0;
      if ( CTouchInterface::m_pWidgets[111] )
        v12 = CTouchInterface::m_pWidgets[110] == 0;
      if ( !v12 )
      {
        CWidget::SetScreenRect(CTouchInterface::m_pWidgets[106], &Rect);
        CWidget::SetScreenRect((CWidget *)HIDWORD(v7), &v19);
        CWidget::SetScreenRect((CWidget *)v8, &Rect);
        CWidget::SetScreenRect((CWidget *)HIDWORD(v8), &v19);
        CWidget::SetScreenRect((CWidget *)v9, &Rect);
        CWidget::SetScreenRect((CWidget *)HIDWORD(v9), &v19);
        if ( CWidget::GetEnabled((CWidget *)HIDWORD(v9)) || CWidget::GetEnabled((CWidget *)v9) )
        {
          CWidget::SetEnabled((CWidget *)v7, 0);
          CWidget::SetEnabled((CWidget *)HIDWORD(v7), 0);
          CWidget::SetEnabled((CWidget *)v8, 0);
          CWidget::SetEnabled((CWidget *)HIDWORD(v8), 0);
        }
      }
    }
  }
  v13 = this->m_RectScreen.left;
  bottom = this->m_RectScreen.bottom;
  v15 = this->m_RectScreen.top - bottom;
  v16 = v5 + bottom;
  v17 = fabsf(this->m_RectScreen.right - v13);
  v18 = (float)(v5 * 0.45) + v13;
  this->mTitle.left = v18;
  this->mTitle.top = v16 + (float)(fabsf(v15) * 0.22);
  this->mTitle.right = v18 + (float)(v17 * 0.5);
  this->mTitle.bottom = v16;
}

//----- (002C0B98) --------------------------------------------------------
void __fastcall CWidgetRegionGang::Update(CWidgetRegionGang *this)
{
  CWidget::SetEnabled(this, 0);
  if ( CTouchInterface::m_pWidgets[106] && CWidget::GetEnabled(CTouchInterface::m_pWidgets[106])
    || CTouchInterface::m_pWidgets[107] && CWidget::GetEnabled(CTouchInterface::m_pWidgets[107])
    || CTouchInterface::m_pWidgets[108] && CWidget::GetEnabled(CTouchInterface::m_pWidgets[108])
    || CTouchInterface::m_pWidgets[109] && CWidget::GetEnabled(CTouchInterface::m_pWidgets[109])
    || CTouchInterface::m_pWidgets[110] && CWidget::GetEnabled(CTouchInterface::m_pWidgets[110])
    || CTouchInterface::m_pWidgets[111] && CWidget::GetEnabled(CTouchInterface::m_pWidgets[111]) )
  {
    CWidget::SetEnabled(this, 1);
  }
  CWidgetRegion::Update(this);
  CWidget::ManageAlpha(this);
  BYTE1(CTouchInterface::m_pWidgets[159][1].m_HIDMapping) = this->m_bEnabled;
  CWidgetRegionGang::BuildRects(this);
}

//----- (002C0C5C) --------------------------------------------------------
void __fastcall CWidgetRegionGang::Draw(CWidgetRegionGang *this)
{
  unsigned int alpha; // r0
  __int64 v3; // d17
  const CRGBA *v4; // r0
  CRGBA v5; // [sp+8h] [bp-40h] BYREF
  CRGBA v6; // [sp+Ch] [bp-3Ch] BYREF
  CRGBA v7; // [sp+10h] [bp-38h] BYREF
  CRGBA v8; // [sp+14h] [bp-34h] BYREF
  CRect v9[3]; // [sp+18h] [bp-30h] BYREF

  alpha = this->m_Color._anon_0._anon_0.alpha;
  if ( alpha )
  {
    v3 = *(_QWORD *)&this->m_RectScreen.right;
    *(_QWORD *)&v9[0].left = *(_QWORD *)&this->m_RectScreen.left;
    *(_QWORD *)&v9[0].right = v3;
    CRGBA::CRGBA(&v8, 0, 0, 0, (unsigned int)(float)((float)alpha * 0.5));
    CRGBA::CRGBA(&v7, 0, 0, 0, (unsigned int)(float)((float)this->m_Color._anon_0._anon_0.alpha * 0.5));
    CRGBA::CRGBA(&v6, 0, 0, 0, this->m_Color._anon_0._anon_0.alpha);
    CRGBA::CRGBA(&v5, 0, 0, 0, this->m_Color._anon_0._anon_0.alpha);
    CSprite2d::DrawRectXLU(v9, &v8, &v7, &v6, v4);
    CRGBA::CRGBA((CRGBA *)v9, 0xFFu, 0xFFu, 0xFFu, this->m_Color._anon_0._anon_0.alpha);
    CSprite2d::Draw(&this->mGangTitle, &this->mTitle, (const CRGBA *)v9);
  }
}
// 2C0D06: variable 'v4' is possibly undefined

//----- (002C0D38) --------------------------------------------------------
void __fastcall CWidgetRegionGang::~CWidgetRegionGang(CWidgetRegionGang *this)
{
  CSprite2d *p_mGangTitle; // r5

  this->_vptr$CWidget = (int (**)(void))&off_664754;
  p_mGangTitle = &this->mGangTitle;
  CSprite2d::~CSprite2d(&this->mSpriteOverlay);
  CSprite2d::~CSprite2d(p_mGangTitle);
  sub_19C514(this);
}
// 664754: using guessed type void *off_664754;

//----- (002C0D68) --------------------------------------------------------
void __fastcall CWidgetRegionGang::~CWidgetRegionGang(CWidgetRegionGang *this)
{
  CSprite2d *p_mGangTitle; // r5
  void *v3; // r0

  this->_vptr$CWidget = (int (**)(void))&off_664754;
  p_mGangTitle = &this->mGangTitle;
  CSprite2d::~CSprite2d(&this->mSpriteOverlay);
  CSprite2d::~CSprite2d(p_mGangTitle);
  CWidget::~CWidget(this);
  sub_191374(v3);
}
// 2C0D94: variable 'v3' is possibly undefined
// 664754: using guessed type void *off_664754;

//----- (002C0D9C) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetRegionGang::GetName(CWidgetRegionGang *this)
{
  return "Gang";
}

//----- (002C0DA8) --------------------------------------------------------
void __fastcall CWidgetRegionLook::CWidgetRegionLook(
        CWidgetRegionLook *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  CRGBA v4; // [sp+4h] [bp-14h] BYREF

  CWidgetRegion::CWidgetRegion(this, pszSprite, WidgetPos, 0, HID_MAPPING_PED_LOOK_BACK);
  *(_WORD *)&this->m_bLookBack = 0;
  this->_vptr$CWidget = (int (**)(void))&off_6647E8;
  CRGBA::CRGBA(&v4, 0xFFu, 0xFFu, 0xFFu, 0x40u);
  CWidget::CreateHoldEffect(this, "hud_ticks", 0, (CRGBA)&v4, 0);
  this->m_fHoldEffectPeriod = 0.5;
}
// 6647E8: using guessed type void *;

//----- (002C0E14) --------------------------------------------------------
void __fastcall CWidgetRegionLook::Update(CWidgetRegionLook *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d9
  float m_fTapHoldTime; // s16
  bool v6; // r0
  float m_fHoldEffectPeriod; // s20
  CHoldEffect *m_pHoldEffect; // r0
  float32x2_t v9; // d0
  unsigned __int32 v10; // s0
  RwInt32 screenWidth; // r5
  CHoldEffect *v12; // r0
  float v13; // s0
  float v14; // s8
  float v15; // s6
  float v16; // s4
  CPlayerPed *PlayerPed; // r0
  CVector2D v18; // [sp+0h] [bp-28h] BYREF

  CWidgetRegion::Update(this);
  if ( CTouchInterface::m_pWidgets[168]
    && (*((int (__fastcall **)(CWidget *, _DWORD))CTouchInterface::m_pWidgets[168]->_vptr$CWidget + 20))(
         CTouchInterface::m_pWidgets[168],
         0)
    || this == CWidget::m_pPinchZoomWidget )
  {
    this->m_fTapHoldTime = 0.0;
  }
  if ( CHID::GetInputType()
    || !FindPlayerPed(-1)
    || !FindPlayerPed(-1)->m_pPedIntelligence
    || (PlayerPed = FindPlayerPed(-1), !CPedIntelligence::GetTaskJetPack(PlayerPed->m_pPedIntelligence)) )
  {
    if ( CCamera::Using1stPersonWeaponMode(&TheCamera) || TheCamera.Cams[TheCamera.ActiveCam].Mode == 53 )
      this->m_fTapHoldTime = 0.0;
  }
  if ( CTheScripts::pActiveScripts && !strcmp((const char *)CTheScripts::pActiveScripts->ScriptName, "pool2") )
    this->m_fTapHoldTime = 0.0;
  if ( this->m_bDisableLookBack )
    this->m_fTapHoldTime = 0.0;
  if ( FindPlayerPed(-1) && !FindPlayerVehicle(-1, 0) && (*((_BYTE *)&FindPlayerPed(-1)->m_nPedFlags + 1) & 2) != 0 )
    this->m_fTapHoldTime = 0.0;
  if ( CHID::GetInputType() == 2 )
  {
    m_fTapHoldTime = 0.0;
    this->m_fTapHoldTime = 0.0;
  }
  else
  {
    m_fTapHoldTime = this->m_fTapHoldTime;
    if ( m_fTapHoldTime > 0.5 )
    {
      v6 = 1;
      goto LABEL_24;
    }
  }
  if ( this == CWidget::m_pInitialTouchWidget[this->m_nTouchIndex] )
    goto LABEL_25;
  v6 = 0;
LABEL_24:
  this->m_bLookBack = v6;
LABEL_25:
  if ( this->m_pHoldEffect )
  {
    m_fHoldEffectPeriod = this->m_fHoldEffectPeriod;
    v3.n64_u32[0] = 0;
    if ( CHID::Implements(HID_MAPPING_PED_LOOK_BACK) && CHID::IsPressed(HID_MAPPING_PED_LOOK_BACK, 0) )
    {
      m_pHoldEffect = this->m_pHoldEffect;
    }
    else
    {
      m_pHoldEffect = this->m_pHoldEffect;
      if ( !this->m_bLookBack )
      {
        v1.n64_f32[0] = m_fTapHoldTime + (float)(m_fHoldEffectPeriod * -0.25);
        v9.n64_u64[0] = vmax_f32(v1, v3).n64_u64[0];
        v3.n64_u32[0] = 0;
        v9.n64_f32[0] = v9.n64_f32[0] / (float)(m_fHoldEffectPeriod * 0.625);
        v2.n64_u32[0] = 1.0;
        v10 = vmin_f32(v9, v2).n64_u32[0];
        if ( this->m_bEnabled )
          v3.n64_u32[0] = v10;
      }
    }
    LODWORD(m_pHoldEffect->m_fProgress) = v3.n64_u32[0];
    screenWidth = RsGlobal.screenWidth;
    CTouchInterface::GetTouchPosition(&v18, this->m_nTouchIndex);
    v12 = this->m_pHoldEffect;
    v13 = (float)((float)screenWidth / 640.0) * 20.0;
    v14 = v13 + v18.y;
    v15 = v13 + v18.x;
    v16 = v18.y - v13;
    v12->m_RectScreen.left = v18.x - v13;
    v12->m_RectScreen.top = v14;
    v12->m_RectScreen.right = v15;
    v12->m_RectScreen.bottom = v16;
  }
}
// 2C0F5C: variable 'v1' is possibly undefined
// 2C0F5C: variable 'v3' is possibly undefined
// 2C0F6C: variable 'v2' is possibly undefined

//----- (002C103C) --------------------------------------------------------
bool __fastcall CWidgetRegionLook::IsTouched(CWidgetRegionLook *this, CVector2D *pVecOut)
{
  float32x2_t v2; // d0
  float32x2_t v3; // d1
  float32x2_t v4; // d2
  float32x2_t v5; // d3
  CPlayerPed *PlayerPed; // r0
  CPad *PadFromPlayer; // r0
  int bHasJetPack; // r6
  bool result; // r0
  float v12; // s0
  CVector2D v13; // [sp+0h] [bp-18h] BYREF

  if ( FindPlayerPed(-1) )
  {
    PlayerPed = FindPlayerPed(-1);
    PadFromPlayer = CPlayerPed::GetPadFromPlayer(PlayerPed);
    bHasJetPack = PadFromPlayer->bHasJetPack;
    if ( PadFromPlayer->bHasJetPack )
      bHasJetPack = 1;
  }
  else
  {
    bHasJetPack = 0;
  }
  if ( CHID::Implements(HID_MAPPING_LOOK_X) && CHID::Implements(HID_MAPPING_LOOK_Y) )
  {
    if ( pVecOut )
    {
      CHID::IsPressed(HID_MAPPING_LOOK_X, &pVecOut->x);
      CHID::IsPressed(HID_MAPPING_LOOK_Y, &pVecOut->y);
      result = 1;
      v12 = pVecOut->y * 128.0;
      pVecOut->x = pVecOut->x * 128.0;
      pVecOut->y = v12;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    if ( pVecOut && bHasJetPack | !this->m_bLookBack && this != CWidget::m_pPinchZoomWidget )
    {
      CTouchInterface::GetTouchDelta(&v13, this->m_nTouchIndex);
      v5.n64_u32[0] = -1023410176;
      v4.n64_f32[0] = v13.y * 5.0;
      v2.n64_f32[0] = v13.x * 5.0;
      v3.n64_u32[0] = 1124073472;
      LODWORD(pVecOut->x) = vmin_f32(vmax_f32(v2, v5), v3).n64_u32[0];
      LODWORD(pVecOut->y) = vmin_f32(vmax_f32(v4, v5), v3).n64_u32[0];
    }
    return this == CWidget::m_pInitialTouchWidget[this->m_nTouchIndex] && this != CWidget::m_pPinchZoomWidget;
  }
  return result;
}
// 2C10FE: variable 'v2' is possibly undefined
// 2C10FE: variable 'v5' is possibly undefined
// 2C1106: variable 'v3' is possibly undefined
// 2C10FA: variable 'v4' is possibly undefined

//----- (002C115C) --------------------------------------------------------
void __fastcall CWidgetRegionLook::OnInitialTouch(CWidgetRegionLook *this)
{
  int m_nTouchIndex; // r0
  int v3; // r0
  int v4; // r4
  CWidget *v5; // r6
  float left; // s18
  float right; // s20
  float x; // s22
  float v9; // s2
  CVector2D v10[8]; // [sp+0h] [bp-40h] BYREF

  CWidget::OnInitialTouch(this);
  m_nTouchIndex = this->m_nTouchIndex;
  this->m_bDisableLookBack = 0;
  if ( CTouchInterface::IsTouchDown(m_nTouchIndex) )
  {
    v3 = 0;
    while ( 1 )
    {
      v4 = v3;
      v5 = CTouchInterface::m_pWidgets[v3];
      if ( v5 )
      {
        if ( (*((int (__fastcall **)(CWidget *))v5->_vptr$CWidget + 9))(CTouchInterface::m_pWidgets[v3]) == 1
          && CWidget::GetEnabled(v5) )
        {
          CTouchInterface::GetTouchPosition(v10, this->m_nTouchIndex);
          left = v5->m_RectScreen.left;
          right = v5->m_RectScreen.right;
          x = v10[0].x;
          CTouchInterface::GetTouchPosition(v10, this->m_nTouchIndex);
          v9 = v10[0].y - (float)((float)(v5->m_RectScreen.top + v5->m_RectScreen.bottom) * 0.5);
          if ( sqrtf(
                 (float)((float)(x - (float)((float)(left + right) * 0.5))
                       * (float)(x - (float)((float)(left + right) * 0.5)))
               + (float)(v9 * v9)) < fabsf(v5->m_RectScreen.right - v5->m_RectScreen.left) )
            break;
        }
      }
      v3 = v4 + 1;
      if ( v4 >= 189 )
        return;
    }
    this->m_bDisableLookBack = 1;
  }
}

//----- (002C123C) --------------------------------------------------------
void __fastcall CWidgetRegionLook::OnReleasedTouch(CWidgetRegionLook *this)
{
  int m_nTouchIndex; // r1
  CPlayerPed *PlayerPed; // r0
  CPlayerPed *v4; // r5
  ePedState m_nPedState; // r0
  bool v6; // zf
  float x; // r6
  CVector2D v8; // [sp+0h] [bp-20h] BYREF
  CVector2D v9; // [sp+8h] [bp-18h] BYREF

  CTouchInterface::GetTouchPosition(&v9, this->m_nTouchIndex);
  m_nTouchIndex = this->m_nTouchIndex;
  if ( fabsf(v9.x - CWidget::m_vecTouchAnchor[m_nTouchIndex].x) < CWidget::SWIPE_DISTANCE )
  {
    CTouchInterface::GetTouchPosition(&v8, m_nTouchIndex);
    if ( fabsf(v8.y - CWidget::m_vecTouchAnchor[this->m_nTouchIndex].y) < CWidget::SWIPE_DISTANCE )
    {
      PlayerPed = FindPlayerPed(-1);
      v4 = PlayerPed;
      if ( PlayerPed )
      {
        if ( LOBYTE(CWeaponInfo::GetWeaponInfo(PlayerPed->m_WeaponSlots[PlayerPed->m_nCurrentWeapon].m_eWeaponType, 1)->m_nFlags) << 31 )
        {
          m_nPedState = v4->m_nPedState;
          v6 = m_nPedState == PED_AIMGUN;
          if ( m_nPedState != PED_AIMGUN )
            v6 = m_nPedState == PED_IDLE;
          if ( v6 )
          {
            CTouchInterface::GetTouchPosition(&v9, this->m_nTouchIndex);
            x = v9.x;
            CTouchInterface::GetTouchPosition(&v8, this->m_nTouchIndex);
            CPlayerPed::HandleTapToTarget(v4, x, v8.y, 0);
          }
        }
      }
    }
  }
}

//----- (002C1320) --------------------------------------------------------
void __fastcall CWidgetRegionLook::GetWidgetValue2(CWidgetRegionLook *this, float *pfValue0, float *pfValue1)
{
  CVector2D v6[3]; // [sp+0h] [bp-18h] BYREF

  CTouchInterface::GetTouchDelta(v6, this->m_nTouchIndex);
  *pfValue0 = v6[0].x;
  CTouchInterface::GetTouchDelta(v6, this->m_nTouchIndex);
  *pfValue1 = v6[0].y;
}

//----- (002C1350) --------------------------------------------------------
bool __fastcall CWidgetRegionLook::IsPinchZooming(CWidgetRegionLook *this, CVector2D *pVecOut)
{
  if ( CTheScripts::pActiveScripts && !strcmp((const char *)CTheScripts::pActiveScripts->ScriptName, "barb") )
    return 0;
  if ( CHID::Implements(HID_MAPPING_CAMERA_CLOSER) )
    return sub_18DF74(HID_MAPPING_CAMERA_CLOSER);
  return sub_19696C(this, pVecOut);
}

//----- (002C139C) --------------------------------------------------------
bool __fastcall CWidgetRegionLook::IsHeldDown(CWidgetRegionLook *this)
{
  if ( FindPlayerPed(-1) && FindPlayerPed(-1)->m_nPedState == PED_DRIVING )
  {
    if ( !CHID::Implements(HID_MAPPING_VEHICLE_LOOK_LEFT)
      || !CHID::Implements(HID_MAPPING_VEHICLE_LOOK_RIGHT)
      || !CHID::IsPressed(HID_MAPPING_VEHICLE_LOOK_LEFT, 0)
      || !CHID::IsPressed(HID_MAPPING_VEHICLE_LOOK_RIGHT, 0) )
    {
      if ( CHID::Implements(HID_MAPPING_VEHICLE_LOOK_BACK) && CHID::IsPressed(HID_MAPPING_VEHICLE_LOOK_BACK, 0) )
        return 1;
      return this->m_bLookBack;
    }
    return 1;
  }
  if ( CHID::Implements(HID_MAPPING_PED_LOOK_BACK) && CHID::IsPressed(HID_MAPPING_PED_LOOK_BACK, 0) )
    return 1;
  return this->m_bLookBack;
}

//----- (002C1426) --------------------------------------------------------
bool __fastcall CWidgetRegionLook::IsSwipedLeft(CWidgetRegionLook *this)
{
  if ( CHID::Replaces(HID_MAPPING_PREV_TARGET) )
    return sub_18DF74(HID_MAPPING_PREV_TARGET);
  if ( CHID::Implements(HID_MAPPING_PREV_TARGET) && CHID::IsReleased(HID_MAPPING_PREV_TARGET) )
    return 1;
  return sub_19F50C(this);
}

//----- (002C1462) --------------------------------------------------------
bool __fastcall CWidgetRegionLook::IsSwipedRight(CWidgetRegionLook *this)
{
  if ( CHID::Replaces(HID_MAPPING_NEXT_TARGET) )
    return sub_18DF74(HID_MAPPING_NEXT_TARGET);
  if ( CHID::Implements(HID_MAPPING_NEXT_TARGET) && CHID::IsReleased(HID_MAPPING_NEXT_TARGET) )
    return 1;
  return sub_198F7C(this);
}

//----- (002C14A0) --------------------------------------------------------
void __fastcall CWidgetRegionLook::DrawHelpIcon(
        CWidgetRegionLook *this,
        const unsigned __int8 *pszCharacters,
        float fX,
        float fY,
        float fHeight,
        int nAlpha)
{
  HIDMapping v9; // r1

  if ( strstr((const char *)pszCharacters, "widget_look_left") )
    v9 = HID_MAPPING_VEHICLE_LOOK_LEFT;
  else
    v9 = HID_MAPPING_VEHICLE_LOOK_RIGHT;
  CHID::DrawHelpIcon(pszCharacters, v9, fX, fY, fHeight, nAlpha, 0);
}

//----- (002C14F8) --------------------------------------------------------
void __fastcall CWidgetRegionLook::~CWidgetRegionLook(CWidgetRegionLook *this)
{
  void *v1; // r0

  CWidget::~CWidget(this);
  sub_191374(v1);
}
// 2C1504: variable 'v1' is possibly undefined

//----- (002C1508) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetRegionLook::GetName(CWidgetRegionLook *this)
{
  return "Look";
}

//----- (002C1514) --------------------------------------------------------
void __fastcall CWidgetRegionMove::CWidgetRegionMove(
        CWidgetRegionMove *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  CWidgetRegion::CWidgetRegion(this, pszSprite, WidgetPos, 32, HID_MAPPING_PED_MOVE_X);
  this->_vptr$CWidget = (int (**)(void))&off_66487C;
  CSprite2d::CSprite2d(&this->m_SpriteIndicator);
  this->m_vecIndicatorOrigin = 0LL;
  this->m_vecTouchAnchorInternal = 0LL;
  this->m_fRadians = 0.0;
  this->m_fTouchLimit = 0.45;
  CWidget::SetTexture(this, &this->m_SpriteIndicator, "hud_analognub", 1);
}
// 66487C: using guessed type void *;

//----- (002C157C) --------------------------------------------------------
void __fastcall CWidgetRegionMove::Update(CWidgetRegionMove *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d3
  CPad *Pad; // r0
  int *v6; // r2
  int m_nTouchIndex; // r0
  CVector2D *v8; // r1
  _BOOL4 m_bEnabled; // r1
  float32x2_t v10; // d1
  float32x2_t v11; // d0
  float v12; // s18
  float v13; // s20
  float v14; // s0
  float v15; // s2
  float v16; // s0
  float v17; // s2
  int v18; // r1
  int v19; // r2
  float v20; // r0
  CVector2D v21; // [sp+0h] [bp-28h] BYREF

  CWidgetRegion::Update(this);
  Pad = CPad::GetPad(0);
  v6 = dword_2C1778;
  if ( Pad->bHasJetPack )
    v6 = &dword_2C1778[1];
  v1.n64_u32[0] = *v6;
  LODWORD(this->m_fTouchLimit) = *v6;
  m_nTouchIndex = this->m_nTouchIndex;
  v8 = &CWidget::m_vecTouchAnchor[m_nTouchIndex];
  v3.n64_u32[0] = LODWORD(v8->y);
  v1.n64_f32[0] = v1.n64_f32[0] * (float)(this->m_fScaleX * (float)((float)RsGlobal.screenWidth / 640.0));
  v2.n64_u32[0] = LODWORD(v8->x);
  m_bEnabled = this->m_bEnabled;
  v10.n64_u64[0] = vmax_f32(v2, v1).n64_u64[0];
  v1.n64_f32[0] = (float)RsGlobal.screenHeight - v1.n64_f32[0];
  LODWORD(this->m_vecTouchAnchorInternal.x) = v10.n64_u32[0];
  v11.n64_u64[0] = vmin_f32(v3, v1).n64_u64[0];
  LODWORD(this->m_vecTouchAnchorInternal.y) = v11.n64_u32[0];
  if ( m_bEnabled
    && CTouchInterface::IsTouchDown(m_nTouchIndex)
    && (*((int (__fastcall **)(CWidgetRegionMove *, CVector2D *, _DWORD))this->_vptr$CWidget + 3))(
         this,
         &this->m_vecTouchAnchorInternal,
         0) == 1 )
  {
    this->m_Color._anon_0._anon_0.alpha = -1;
  }
  else if ( (*((int (__fastcall **)(CWidgetRegionMove *, CVector2D *, _DWORD))this->_vptr$CWidget + 3))(
              this,
              &this->m_vecTouchAnchorInternal,
              0) == 1 )
  {
    v10.n64_u32[0] = 0;
    v11.n64_f32[0] = (double)this->m_Color._anon_0._anon_0.alpha - CWidget::m_fElapsedTime * this->m_fFadeRate;
    this->m_Color._anon_0._anon_0.alpha = (unsigned int)vmax_f32(v11, v10).n64_f32[0];
  }
  else
  {
    this->m_Color._anon_0._anon_0.alpha = 0;
  }
  CTouchInterface::GetTouchPosition(&v21, this->m_nTouchIndex);
  v12 = v21.x - this->m_vecTouchAnchorInternal.x;
  v13 = v21.y - this->m_vecTouchAnchorInternal.y;
  v14 = sqrtf((float)(v12 * v12) + (float)(v13 * v13));
  v15 = this->m_fTouchLimit * (float)(this->m_fScaleX * (float)((float)RsGlobal.screenWidth / 640.0));
  if ( v14 > v15 )
  {
    v16 = 1.0 / (float)(v14 / v15);
    v13 = v13 * v16;
    v12 = v12 * v16;
  }
  if ( CTouchInterface::IsTouchDown(this->m_nTouchIndex) )
  {
    v17 = v13 + this->m_vecTouchAnchorInternal.y;
    this->m_vecIndicatorOrigin.x = v12 + this->m_vecTouchAnchorInternal.x;
    this->m_vecIndicatorOrigin.y = v17;
  }
  v18 = 0;
  v19 = 0;
  if ( v13 == 0.0 )
    v18 = 1;
  if ( v12 == 0.0 )
    v19 = 1;
  if ( (v19 & v18) != 0 )
  {
    this->m_fRadians = 0.0;
  }
  else
  {
    v20 = atan2f(v13, v12);
    this->m_fRadians = v20 + 1.5708;
    if ( (float)(v20 + 1.5708) < 0.0 )
      this->m_fRadians = (float)(v20 + 1.5708) + 6.2832;
  }
}
// 2C15EA: variable 'v2' is possibly undefined
// 2C15EA: variable 'v1' is possibly undefined
// 2C15F6: variable 'v3' is possibly undefined
// 2C1778: using guessed type int dword_2C1778[2];

//----- (002C179C) --------------------------------------------------------
void __fastcall CWidgetRegionMove::ClampInternalTouchAnchor(CWidgetRegionMove *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d2
  float32x2_t v3; // d3
  CVector2D *v4; // r1
  float v5; // s4

  v4 = &CWidget::m_vecTouchAnchor[this->m_nTouchIndex];
  v2.n64_u32[0] = LODWORD(v4->x);
  v1.n64_f32[0] = this->m_fTouchLimit * (float)(this->m_fScaleX * (float)((float)RsGlobal.screenWidth / 640.0));
  v3.n64_u32[0] = LODWORD(v4->y);
  LODWORD(v5) = vmax_f32(v2, v1).n64_u32[0];
  v1.n64_f32[0] = (float)RsGlobal.screenHeight - v1.n64_f32[0];
  this->m_vecTouchAnchorInternal.x = v5;
  LODWORD(this->m_vecTouchAnchorInternal.y) = vmin_f32(v3, v1).n64_u32[0];
}
// 2C17DE: variable 'v2' is possibly undefined
// 2C17DE: variable 'v1' is possibly undefined
// 2C17EA: variable 'v3' is possibly undefined

//----- (002C1800) --------------------------------------------------------
void __fastcall CWidgetRegionMove::Draw(CWidgetRegionMove *this)
{
  float x; // s2
  float v3; // s0
  float y; // s4
  float v5; // s4
  float v6; // s0
  float v7; // s2
  CRect v8[2]; // [sp+0h] [bp-28h] BYREF

  if ( this->m_Color._anon_0._anon_0.alpha )
  {
    x = this->m_vecTouchAnchorInternal.x;
    v3 = this->m_fTouchLimit * (float)(this->m_fScaleX * (float)((float)RsGlobal.screenWidth / 640.0));
    y = this->m_vecTouchAnchorInternal.y;
    v8[0].bottom = y - v3;
    v8[0].left = x - v3;
    v8[0].right = x + v3;
    v8[0].top = y + v3;
    CSprite2d::Draw(&this->m_Sprite, v8, &this->m_Color);
    v5 = this->m_vecIndicatorOrigin.y;
    v6 = (float)(this->m_fScaleX * (float)((float)RsGlobal.screenWidth / 640.0)) * 0.15;
    v7 = this->m_vecIndicatorOrigin.x;
    v8[0].bottom = v5 - v6;
    v8[0].left = v7 - v6;
    v8[0].right = v7 + v6;
    v8[0].top = v5 + v6;
    CSprite2d::Draw(&this->m_SpriteIndicator, v8, &this->m_Color);
  }
}

//----- (002C18E0) --------------------------------------------------------
bool __fastcall CWidgetRegionMove::IsTouched(CWidgetRegionMove *this, CVector2D *pVecOut)
{
  CVector2D *p_y; // r1
  float v5; // s0
  float v7; // s0
  float v8; // s2

  if ( !CHID::Implements(HID_MAPPING_PED_MOVE_X) || !CHID::Implements(HID_MAPPING_PED_MOVE_Y) )
    goto LABEL_10;
  CHID::IsPressed(HID_MAPPING_PED_MOVE_X, &pVecOut->x);
  p_y = pVecOut;
  if ( pVecOut )
    p_y = (CVector2D *)&pVecOut->y;
  CHID::IsPressed(HID_MAPPING_PED_MOVE_Y, &p_y->x);
  if ( CHID::IsPressed(HID_MAPPING_PED_MOVE_X, 0) || CHID::IsPressed(HID_MAPPING_PED_MOVE_Y, 0) )
  {
    if ( pVecOut )
    {
      v5 = pVecOut->y * 128.0;
      pVecOut->x = pVecOut->x * 128.0;
      pVecOut->y = v5;
    }
    return 1;
  }
  else
  {
LABEL_10:
    if ( pVecOut )
    {
      v7 = 1.0 / (float)(this->m_fTouchLimit * (float)(this->m_fScaleX * (float)((float)RsGlobal.screenWidth / 640.0)));
      v8 = (float)((float)(this->m_vecIndicatorOrigin.y - this->m_vecTouchAnchorInternal.y) * v7) * 128.0;
      pVecOut->x = (float)((float)(this->m_vecIndicatorOrigin.x - this->m_vecTouchAnchorInternal.x) * v7) * 128.0;
      pVecOut->y = v8;
    }
    return sub_18EC48(this, pVecOut);
  }
}

//----- (002C19C8) --------------------------------------------------------
bool __fastcall CWidgetRegionMove::IsDoubleTapped(CWidgetRegionMove *this)
{
  if ( CHID::Replaces(HID_MAPPING_CROUCH) )
    return sub_18DF74(HID_MAPPING_CROUCH);
  if ( CHID::Implements(HID_MAPPING_CROUCH) && CHID::IsReleased(HID_MAPPING_CROUCH) )
    return 1;
  return CWidget::GetNumTapsInTime(this, 0.33) > 1;
}

//----- (002C1A14) --------------------------------------------------------
void __fastcall CWidgetRegionMove::DrawHelpIcon(
        CWidgetRegionMove *this,
        const unsigned __int8 *pszCharacters,
        float fX,
        float fY,
        float fHeight,
        int nAlpha)
{
  int v9; // r0
  int v10; // r0

  if ( strstr((const char *)pszCharacters, "widget_ped_move_left")
    || strstr((const char *)pszCharacters, "widget_vehicle_steer_left") )
  {
    v9 = 1;
LABEL_4:
    CHID::DrawHelpIcon(pszCharacters, HID_MAPPING_PED_MOVE_X, fX, fY, fHeight, nAlpha, v9);
    return;
  }
  if ( strstr((const char *)pszCharacters, "widget_ped_move_right")
    || strstr((const char *)pszCharacters, "widget_vehicle_steer_right") )
  {
LABEL_7:
    v9 = 0;
    goto LABEL_4;
  }
  if ( strstr((const char *)pszCharacters, "widget_ped_move_up") )
  {
    v10 = 1;
LABEL_12:
    CHID::DrawHelpIcon(pszCharacters, HID_MAPPING_PED_MOVE_Y, fX, fY, fHeight, nAlpha, v10);
    return;
  }
  if ( strstr((const char *)pszCharacters, "widget_ped_move_down") )
  {
    v10 = 0;
    goto LABEL_12;
  }
  if ( strstr((const char *)pszCharacters, "widget_ped_move") )
    goto LABEL_7;
}

//----- (002C1B50) --------------------------------------------------------
void __fastcall CWidgetRegionMove::OnInitialTouch(CWidgetRegionMove *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d2
  float32x2_t v3; // d3
  CVector2D *v5; // r0
  float v6; // s4
  float v7; // s0

  CWidget::OnInitialTouch(this);
  v5 = &CWidget::m_vecTouchAnchor[this->m_nTouchIndex];
  v2.n64_u32[0] = LODWORD(v5->x);
  v1.n64_f32[0] = this->m_fTouchLimit * (float)(this->m_fScaleX * (float)((float)RsGlobal.screenWidth / 640.0));
  v3.n64_u32[0] = LODWORD(v5->y);
  LODWORD(v6) = vmax_f32(v2, v1).n64_u32[0];
  v1.n64_f32[0] = (float)RsGlobal.screenHeight - v1.n64_f32[0];
  this->m_vecIndicatorOrigin.x = v6;
  LODWORD(v7) = vmin_f32(v3, v1).n64_u32[0];
  this->m_vecIndicatorOrigin.y = v7;
  this->m_vecTouchAnchorInternal.x = v6;
  this->m_vecTouchAnchorInternal.y = v7;
}
// 2C1B9C: variable 'v2' is possibly undefined
// 2C1B9C: variable 'v1' is possibly undefined
// 2C1BA8: variable 'v3' is possibly undefined

//----- (002C1BC8) --------------------------------------------------------
void __fastcall CWidgetRegionMove::GetWidgetValue2(CWidgetRegionMove *this, float *pfValue0, float *pfValue1)
{
  CVector2D v6[3]; // [sp+0h] [bp-18h] BYREF

  if ( (*((int (__fastcall **)(CWidgetRegionMove *, _DWORD))this->_vptr$CWidget + 20))(this, 0) == 1 )
  {
    CTouchInterface::GetTouchPosition(v6, this->m_nTouchIndex);
    *pfValue0 = v6[0].x - this->m_vecTouchAnchorInternal.x;
    CTouchInterface::GetTouchPosition(v6, this->m_nTouchIndex);
    *pfValue1 = v6[0].y - this->m_vecTouchAnchorInternal.y;
  }
  else
  {
    *pfValue0 = 0.0;
    *pfValue1 = 0.0;
  }
}

//----- (002C1C2C) --------------------------------------------------------
void __fastcall CWidgetRegionMove::~CWidgetRegionMove(CWidgetRegionMove *this)
{
  this->_vptr$CWidget = (int (**)(void))&off_66487C;
  CSprite2d::~CSprite2d(&this->m_SpriteIndicator);
  sub_19C514(this);
}
// 66487C: using guessed type void *off_66487C;

//----- (002C1C54) --------------------------------------------------------
void __fastcall CWidgetRegionMove::~CWidgetRegionMove(CWidgetRegionMove *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_66487C;
  CSprite2d::~CSprite2d(&this->m_SpriteIndicator);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2C1C78: variable 'v2' is possibly undefined
// 66487C: using guessed type void *off_66487C;

//----- (002C1C80) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetRegionMove::GetName(CWidgetRegionMove *this)
{
  return "Move";
}

//----- (002C1C90) --------------------------------------------------------
void __fastcall CWidgetRegionPoolBallInHand::CWidgetRegionPoolBallInHand(
        CWidgetRegionPoolBallInHand *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  _DWORD *v3; // r0

  CWidgetRegion::CWidgetRegion(this, pszSprite, WidgetPos, 4, HID_MAPPING_UNKNOWN);
  *v3 = &off_664910;
}
// 2C1CA8: variable 'v3' is possibly undefined
// 664910: using guessed type void *;

//----- (002C1CB8) --------------------------------------------------------
void __fastcall CWidgetRegionPoolBallInHand::GetWidgetValue2(
        CWidgetRegionPoolBallInHand *this,
        float *pfValue0,
        float *pfValue1)
{
  float x; // s16
  float v7; // s0
  float y; // s16
  float v9; // s0
  CVector2D v10[5]; // [sp+0h] [bp-28h] BYREF

  CTouchInterface::GetTouchDelta(v10, this->m_nTouchIndex);
  x = v10[0].x;
  v7 = x * 0.2 * (float)(1024.0 / (float)CWidget::GetScreenWidth());
  *pfValue0 = v7;
  CTouchInterface::GetTouchDelta(v10, this->m_nTouchIndex);
  y = v10[0].y;
  v9 = y * -0.2 * (float)(1024.0 / (float)CWidget::GetScreenWidth());
  *pfValue1 = v9;
}

//----- (002C1D64) --------------------------------------------------------
bool __fastcall CWidgetRegionPoolBallInHand::IsTouched(CWidgetRegionPoolBallInHand *this, CVector2D *pVecOut)
{
  return this == CWidget::m_pInitialTouchWidget[this->m_nTouchIndex];
}

//----- (002C1D80) --------------------------------------------------------
void __fastcall CWidgetRegionPoolBallInHand::SetWidgetValue3(
        CWidgetRegionPoolBallInHand *this,
        float fValue0,
        float fValue1,
        float fValue2)
{
  float v5; // s0
  float v6; // s2
  CRect In; // [sp+Ch] [bp-24h] BYREF
  RwV3d_0 pResult; // [sp+1Ch] [bp-14h] BYREF

  memset(&pResult, 0, sizeof(pResult));
  In.left = fValue0;
  In.top = fValue1;
  In.right = fValue2;
  CSprite::CalcScreenCoors((const RwV3d_0 *)&In, &pResult, 0, 0, 1, 1);
  v5 = fabsf(this->m_RectScreen.right - this->m_RectScreen.left) * 0.5;
  v6 = fabsf(this->m_RectScreen.top - this->m_RectScreen.bottom) * 0.5;
  In.left = pResult.x - v5;
  In.bottom = pResult.y - v5;
  In.right = pResult.x + v6;
  In.top = pResult.y + v6;
  CWidget::SetScreenRect(this, &In);
}

//----- (002C1E06) --------------------------------------------------------
void __fastcall CWidgetRegionPoolBallInHand::~CWidgetRegionPoolBallInHand(CWidgetRegionPoolBallInHand *this)
{
  void *v1; // r0

  CWidget::~CWidget(this);
  sub_191374(v1);
}
// 2C1E12: variable 'v1' is possibly undefined

//----- (002C1E18) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetRegionPoolBallInHand::GetName(CWidgetRegionPoolBallInHand *this)
{
  return "Pool BIH";
}

//----- (002C1E28) --------------------------------------------------------
void __fastcall CWidgetRegionPoolEnglish::CWidgetRegionPoolEnglish(
        CWidgetRegionPoolEnglish *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  _DWORD *v3; // r0

  CWidgetRegion::CWidgetRegion(this, pszSprite, WidgetPos, 4, HID_MAPPING_UNKNOWN);
  *v3 = &off_6649A4;
}
// 2C1E40: variable 'v3' is possibly undefined
// 6649A4: using guessed type void *;

//----- (002C1E4C) --------------------------------------------------------
void __fastcall CWidgetRegionPoolEnglish::GetWidgetValue2(
        CWidgetRegionPoolEnglish *this,
        float *pfValue0,
        float *pfValue1)
{
  CVector2D v6[3]; // [sp+0h] [bp-18h] BYREF

  CTouchInterface::GetTouchDelta(v6, this->m_nTouchIndex);
  *pfValue0 = v6[0].x;
  CTouchInterface::GetTouchDelta(v6, this->m_nTouchIndex);
  *pfValue1 = v6[0].y;
}

//----- (002C1E7C) --------------------------------------------------------
bool __fastcall CWidgetRegionPoolEnglish::IsTouched(CWidgetRegionPoolEnglish *this, CVector2D *pVecOut)
{
  return this == CWidget::m_pInitialTouchWidget[this->m_nTouchIndex];
}

//----- (002C1E98) --------------------------------------------------------
void __fastcall CWidgetRegionPoolEnglish::~CWidgetRegionPoolEnglish(CWidgetRegionPoolEnglish *this)
{
  void *v1; // r0

  CWidget::~CWidget(this);
  sub_191374(v1);
}
// 2C1EA4: variable 'v1' is possibly undefined

//----- (002C1EA8) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetRegionPoolEnglish::GetName(CWidgetRegionPoolEnglish *this)
{
  return "Pool English";
}

//----- (002C1EBC) --------------------------------------------------------
void __fastcall CWidgetRegionResponse::CWidgetRegionResponse(
        CWidgetRegionResponse *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  int v3; // r0

  CWidgetRegion::CWidgetRegion(this, pszSprite, WidgetPos, 8, HID_MAPPING_UNKNOWN);
  *(_WORD *)(v3 + 144) = 0;
  *(_DWORD *)v3 = &off_664A38;
}
// 2C1ECE: variable 'v3' is possibly undefined
// 664A38: using guessed type void *;

//----- (002C1EE4) --------------------------------------------------------
void __fastcall CWidgetRegionResponse::Update(CWidgetRegionResponse *this)
{
  CPlayerPed *PlayerPed; // r0
  RwV3d_0 v3; // [sp+8h] [bp-40h] BYREF
  RwV3d_0 pResult; // [sp+14h] [bp-34h] BYREF
  CVector vecPedFeet; // [sp+20h] [bp-28h] BYREF
  CVector vecPedHead; // [sp+2Ch] [bp-1Ch] BYREF

  CWidgetRegion::Update(this);
  LOBYTE(CTouchInterface::m_pWidgets[159][1].m_HIDMapping) = this->m_bEnabled;
  if ( !this->m_bEnabled || !FindPlayerPed(-1) )
    return;
  *(_WORD *)&this->m_bTapped = 0;
  if ( !CTouchInterface::IsDoubleTapped(WIDGET_RESPONSE, 0, 1) )
  {
    if ( !CWidgetRegionResponse::Update(void)::bWait )
    {
      if ( CWidgetRegionResponse::Update(void)::bTapped == 1 )
      {
        CWidgetRegionResponse::Update(void)::bTapped = 0;
        this->m_bTapped = 1;
      }
      goto LABEL_11;
    }
    goto LABEL_7;
  }
  CWidgetRegionResponse::Update(void)::bTapped = 0;
  this->m_bDoubleTapped = 1;
  if ( CWidgetRegionResponse::Update(void)::bWait == 1 )
  {
LABEL_7:
    CWidgetRegionResponse::Update(void)::fTimer = CWidgetRegionResponse::Update(void)::fTimer
                                                + (float)(CTimer::ms_fTimeStep / 50.0);
    if ( CWidgetRegionResponse::Update(void)::fTimer > 0.33 )
    {
      CWidgetRegionResponse::Update(void)::bWait = 0;
      CWidgetRegionResponse::Update(void)::fTimer = 0.0;
    }
  }
LABEL_11:
  if ( CTouchInterface::IsReleased(WIDGET_RESPONSE, 0, 1) )
  {
    CWidgetRegionResponse::Update(void)::bTapped = 1;
    CWidgetRegionResponse::Update(void)::bWait = 1;
  }
  memset(&vecPedFeet, 0, sizeof(vecPedFeet));
  memset(&vecPedHead, 0, sizeof(vecPedHead));
  memset(&v3, 0, sizeof(v3));
  memset(&pResult, 0, sizeof(pResult));
  PlayerPed = FindPlayerPed(-1);
  CPed::GetHeadAndFootPositions(PlayerPed, &vecPedHead, &vecPedFeet, 1);
  if ( CSprite::CalcScreenCoors(&vecPedHead, &pResult, 0, 0, 1, 1) == 1
    && CSprite::CalcScreenCoors(&vecPedFeet, &v3, 0, 0, 1, 1) == 1 )
  {
    rect.left = pResult.x;
    rect.top = v3.y;
    rect.right = v3.x;
    rect.bottom = pResult.y;
    CWidget::SetScreenRect(this, &rect);
  }
}
// 70B624: using guessed type char CWidgetRegionResponse::Update(void)::bWait;
// 70B625: using guessed type char CWidgetRegionResponse::Update(void)::bTapped;

//----- (002C207E) --------------------------------------------------------
void __fastcall CWidgetRegionResponse::~CWidgetRegionResponse(CWidgetRegionResponse *this)
{
  void *v1; // r0

  CWidget::~CWidget(this);
  sub_191374(v1);
}
// 2C208A: variable 'v1' is possibly undefined

//----- (002C2090) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetRegionResponse::GetName(CWidgetRegionResponse *this)
{
  return "Response";
}

//----- (002C20A0) --------------------------------------------------------
void __fastcall CWidgetRegionRhythmSelect::CWidgetRegionRhythmSelect(
        CWidgetRegionRhythmSelect *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  CRGBA v4; // [sp+8h] [bp-20h] BYREF
  CRGBA v5; // [sp+Ch] [bp-1Ch] BYREF

  CWidgetButton::CWidgetButton(this, pszSprite, WidgetPos, 0, 4u, HID_MAPPING_UNKNOWN);
  this->_vptr$CWidget = (int (**)(void))&off_664ACC;
  CSprite2d::CSprite2d(&this->mSpriteNext);
  CSprite2d::CSprite2d(&this->mSpritePrev);
  CSprite2d::CSprite2d(&this->mSpriteCurrent);
  CSprite2d::SetTexture(&this->m_Sprite, "cring");
  CSprite2d::SetTexture(&this->mSpriteNext, "up");
  CSprite2d::SetTexture(&this->mSpriteCurrent, "up");
  CSprite2d::SetTexture(&this->mSpritePrev, "up");
  this->nCurrDir = -1;
  this->fRadians = 3.1416;
  this->fCurRadians = 3.1416;
  this->bRhythm = 0;
  CRGBA::CRGBA(&v5, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
  this->SpriteNextColor = v5;
  CRGBA::CRGBA(&v4, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
  this->SpritePrevColor = v4;
  this->nSpritePrevAlpha = 0;
}
// 664ACC: using guessed type void *;

//----- (002C21A0) --------------------------------------------------------
void __fastcall CWidgetRegionRhythmSelect::Update(CWidgetRegionRhythmSelect *this)
{
  tBeatInfo *BeatInfo; // r9
  int v3; // r5
  int Time; // r4
  int Type; // r8
  int BeatNumber; // r10
  Char *ScriptName; // r6
  RwUInt8 red; // r0
  UInt8 v9; // r1
  UInt8 v10; // r1
  UInt8 v11; // r2
  RwUInt8 green; // r0
  UInt8 v13; // r3
  RwUInt8 blue; // r0
  int nSpritePrevAlpha; // r1
  RwUInt8 v16; // r0
  float v17; // s0
  float v18; // s2
  float x; // s4
  float v20; // s4
  float v21; // s6
  float fRadians; // s0
  int v23; // r0
  int v24; // r1
  int v25; // r0
  int y; // [sp+4h] [bp-24h] BYREF
  CRGBA v27; // [sp+8h] [bp-20h] BYREF

  CWidgetButton::Update(this);
  BeatInfo = CAudioEngine::GetBeatInfo(&AudioEngine);
  if ( BeatInfo->bBeatInfoPresent )
  {
    v3 = 1;
    Type = BeatInfo->BeatWindow[10].Type;
    Time = BeatInfo->BeatWindow[10].Time;
    nBeatTime = Time;
    BeatNumber = BeatInfo->BeatNumber;
  }
  else
  {
    v3 = 0;
    Type = -1;
    BeatNumber = -1;
    Time = nBeatTime;
  }
  this->bRhythm = 0;
  if ( Time <= 3499
    && CTheScripts::pActiveScripts
    && ((ScriptName = CTheScripts::pActiveScripts->ScriptName,
         !strcmp((const char *)CTheScripts::pActiveScripts->ScriptName, "lowgame"))
     || !strcmp((const char *)ScriptName, "bdisply"))
    || Type != -1 && (unsigned int)(Time - 1) <= 0xDAA )
  {
    this->bRhythm = 1;
    if ( v3 == 1 )
    {
      if ( CWidgetRegionRhythmSelect::Update(void)::nLastBeatNumber != BeatNumber )
      {
        bScore = 0;
        this->nPrevDir = -1;
        CWidgetRegionRhythmSelect::Update(void)::nLastBeatNumber = BeatNumber;
      }
      CRGBA::CRGBA(&v27, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
      this->SpriteNextColor = v27;
      if ( bScore == 1 )
      {
        switch ( this->nPrevDir )
        {
          case 0:
            CRGBA::CRGBA(&v27, 0xFFu, 0xFFu, 0, 0xFFu);
            red = v27._anon_0._anon_0.red;
            v9 = -1;
            goto LABEL_18;
          case 1:
            CRGBA::CRGBA(&v27, 0, 0, 0xFFu, 0xFFu);
            v10 = 0;
            this->SpriteNextColor._anon_0._anon_0.red = v27._anon_0._anon_0.red;
            v11 = 0;
            green = v27._anon_0._anon_0.green;
            v13 = -1;
            goto LABEL_20;
          case 2:
            CRGBA::CRGBA(&v27, 0, 0xFFu, 0, 0xFFu);
            red = v27._anon_0._anon_0.red;
            v9 = 0;
LABEL_18:
            this->SpriteNextColor._anon_0._anon_0.red = red;
            *(_WORD *)&this->SpriteNextColor._anon_0._anon_0.green = *(_WORD *)&v27._anon_0._anon_0.green;
            this->SpriteNextColor._anon_0._anon_0.alpha = v27._anon_0._anon_0.alpha;
            CRGBA::CRGBA(&v27, v9, 0xFFu, 0, 0xFFu);
            goto LABEL_21;
          case 3:
            CRGBA::CRGBA(&v27, 0xFFu, 0xA5u, 0, 0xFFu);
            v10 = -1;
            this->SpriteNextColor._anon_0._anon_0.red = v27._anon_0._anon_0.red;
            v11 = -91;
            green = v27._anon_0._anon_0.green;
            v13 = 0;
LABEL_20:
            this->SpriteNextColor._anon_0._anon_0.green = green;
            *(_WORD *)&this->SpriteNextColor._anon_0.col[2] = *(_WORD *)&v27._anon_0.col[2];
            CRGBA::CRGBA(&v27, v10, v11, v13, 0xFFu);
LABEL_21:
            this->SpritePrevColor = v27;
            this->nSpritePrevAlpha = 255;
            break;
          default:
            break;
        }
      }
      switch ( Type )
      {
        case 1:
        case 14:
          CSprite2d::SetTexture(&this->mSpriteNext, "down");
          if ( (unsigned int)(nBeatTime - 1) <= 0x1386 && this->nCurrDir == 1 )
          {
            CSprite2d::SetTexture(&this->mSpritePrev, "down");
            this->nPrevDir = this->nCurrDir;
            CRGBA::CRGBA(&v27, 0, 0, 0xFFu, 0xFFu);
            this->SpriteNextColor = v27;
            CRGBA::CRGBA(&v27, 0, 0, 0xFFu, 0xFFu);
            *(_WORD *)&this->SpritePrevColor._anon_0._anon_0.red = *(_WORD *)&v27._anon_0._anon_0.red;
            blue = v27._anon_0._anon_0.blue;
            goto LABEL_35;
          }
          break;
        case 2:
        case 9:
          CSprite2d::SetTexture(&this->mSpriteNext, "left");
          if ( (unsigned int)(nBeatTime - 1) <= 0x1386 && this->nCurrDir == 2 )
          {
            CSprite2d::SetTexture(&this->mSpritePrev, "left");
            this->nPrevDir = this->nCurrDir;
            CRGBA::CRGBA(&v27, 0, 0xFFu, 0, 0xFFu);
            this->SpriteNextColor = v27;
            CRGBA::CRGBA(&v27, 0, 0xFFu, 0, 0xFFu);
            *(_WORD *)&this->SpritePrevColor._anon_0._anon_0.red = *(_WORD *)&v27._anon_0._anon_0.red;
            blue = v27._anon_0._anon_0.blue;
            goto LABEL_35;
          }
          break;
        case 3:
        case 13:
          CSprite2d::SetTexture(&this->mSpriteNext, (unsigned __int8 *)&dword_2C27E8);
          if ( (unsigned int)(nBeatTime - 1) <= 0x1386 && !this->nCurrDir )
          {
            CSprite2d::SetTexture(&this->mSpritePrev, (unsigned __int8 *)&dword_2C27E8);
            this->nPrevDir = this->nCurrDir;
            CRGBA::CRGBA(&v27, 0xFFu, 0xFFu, 0, 0xFFu);
            this->SpriteNextColor = v27;
            CRGBA::CRGBA(&v27, 0xFFu, 0xFFu, 0, 0xFFu);
            *(_WORD *)&this->SpritePrevColor._anon_0._anon_0.red = *(_WORD *)&v27._anon_0._anon_0.red;
            blue = v27._anon_0._anon_0.blue;
            goto LABEL_35;
          }
          break;
        case 4:
        case 10:
          CSprite2d::SetTexture(&this->mSpriteNext, "right");
          if ( (unsigned int)(nBeatTime - 1) <= 0x1386 && this->nCurrDir == 3 )
          {
            CSprite2d::SetTexture(&this->mSpritePrev, "right");
            this->nPrevDir = this->nCurrDir;
            CRGBA::CRGBA(&v27, 0xFFu, 0xA5u, 0, 0xFFu);
            this->SpriteNextColor = v27;
            CRGBA::CRGBA(&v27, 0xFFu, 0xA5u, 0, 0xFFu);
            *(_WORD *)&this->SpritePrevColor._anon_0._anon_0.red = *(_WORD *)&v27._anon_0._anon_0.red;
            blue = v27._anon_0._anon_0.blue;
LABEL_35:
            this->SpritePrevColor._anon_0._anon_0.blue = blue;
            this->SpritePrevColor._anon_0._anon_0.alpha = v27._anon_0._anon_0.alpha;
            this->nSpritePrevAlpha = 255;
            bScore = 1;
          }
          break;
        default:
          break;
      }
      nSpritePrevAlpha = this->nSpritePrevAlpha;
      if ( nSpritePrevAlpha )
      {
        if ( BeatInfo->BeatWindow[9].Time > 0
          || (v16 = nSpritePrevAlpha - 10, this->nSpritePrevAlpha = nSpritePrevAlpha - 10, nSpritePrevAlpha <= 9) )
        {
          v16 = 0;
          this->nSpritePrevAlpha = 0;
        }
      }
      else
      {
        v16 = 0;
      }
      this->SpritePrevColor._anon_0._anon_0.alpha = v16;
    }
    y = 0;
    v27 = 0;
    if ( LIB_PointerGetButton(0, 0) == OSPS_ButtonDown )
    {
      LIB_PointerGetCoordinates(0, (int *)&v27, &y, 0);
      v17 = (float)(int)v27;
      this->vCurrPoint.x = (float)(int)v27;
      v18 = (float)y;
      this->vCurrPoint.y = (float)y;
      if ( CWidgetRegionRhythmSelect::Update(void)::bAnchorSet == 1 )
      {
        x = this->vCurrAnchor.x;
      }
      else
      {
        x = v17;
        this->vCurrAnchor.x = v17;
        this->vCurrAnchor.y = v18;
        CWidgetRegionRhythmSelect::Update(void)::bAnchorSet = 1;
      }
      v20 = v17 - x;
      v21 = this->vCurrAnchor.y;
      if ( fabsf(v20) > 22.0 || fabsf(v18 - v21) > 22.0 )
      {
        this->vCurrAnchor.x = v17;
        this->vCurrAnchor.y = v18;
        this->fRadians = atan2f(COERCE_FLOAT(LODWORD(v20) ^ 0x80000000), v18 - v21);
      }
    }
    else
    {
      CWidgetRegionRhythmSelect::Update(void)::bAnchorSet = 0;
      this->nCurrDir = -1;
    }
    fRadians = this->fRadians;
    if ( fRadians < 1.3 || fRadians > 1.9 )
    {
      if ( fRadians > -1.3 || fRadians < -1.9 )
      {
        if ( fRadians < -0.3 || fRadians > 0.3 )
        {
          v24 = 0;
          v25 = 0;
          if ( fRadians < 2.9 )
            v24 = 1;
          if ( fRadians >= -3.0 )
            v25 = 1;
          v23 = -(v25 & v24);
        }
        else
        {
          v23 = 1;
        }
      }
      else
      {
        v23 = 3;
      }
    }
    else
    {
      v23 = 2;
    }
    this->nCurrDir = v23;
    if ( LIB_PointerGetButton(0, 0) != OSPS_ButtonDown )
      this->nCurrDir = -1;
  }
}
// 2C27E8: using guessed type int dword_2C27E8;
// 70B630: using guessed type char bScore;
// 70B631: using guessed type char CWidgetRegionRhythmSelect::Update(void)::bAnchorSet;

//----- (002C2838) --------------------------------------------------------
void __fastcall CWidgetRegionRhythmSelect::Draw(CWidgetRegionRhythmSelect *this)
{
  __int64 v2; // d17
  float v3; // s0
  float fRadians; // r5
  CRGBA v5; // [sp+4h] [bp-24h] BYREF
  CRect Rectangle; // [sp+8h] [bp-20h] BYREF

  if ( this->bRhythm )
  {
    this->m_Color._anon_0._anon_0.alpha = -1;
    CWidgetButton::Draw(this);
    v2 = *(_QWORD *)&this->m_RectScreen.right;
    *(_QWORD *)&Rectangle.left = *(_QWORD *)&this->m_RectScreen.left;
    *(_QWORD *)&Rectangle.right = v2;
    v3 = fabsf(this->m_RectScreen.top - this->m_RectScreen.bottom);
    Rectangle.left = Rectangle.left + (float)(v3 * 0.08);
    Rectangle.bottom = *((float *)&v2 + 1) + (float)(v3 * 0.08);
    Rectangle.right = Rectangle.left + (float)(v3 * 0.85);
    Rectangle.top = Rectangle.bottom + (float)(fabsf(this->m_RectScreen.right - this->m_RectScreen.left) * 0.85);
    CSprite2d::Draw(&this->mSpriteNext, &Rectangle, &this->SpriteNextColor);
    if ( this->SpritePrevColor._anon_0._anon_0.alpha )
      CSprite2d::Draw(&this->mSpritePrev, &Rectangle, &this->SpritePrevColor);
    if ( LIB_PointerGetButton(0, 0) == OSPS_ButtonDown )
    {
      fRadians = this->fRadians;
      CRGBA::CRGBA(&v5, 0xFFu, 0xFFu, 0xFFu, 0x80u);
      CSprite2d::DrawRotated(&this->mSpriteCurrent, &Rectangle, fRadians, &v5);
    }
  }
}

//----- (002C2924) --------------------------------------------------------
void __fastcall CWidgetRegionRhythmSelect::~CWidgetRegionRhythmSelect(CWidgetRegionRhythmSelect *this)
{
  CSprite2d *p_mSpriteNext; // r5

  this->_vptr$CWidget = (int (**)(void))&off_664ACC;
  p_mSpriteNext = &this->mSpriteNext;
  CSprite2d::~CSprite2d(&this->mSpriteCurrent);
  CSprite2d::~CSprite2d(&this->mSpritePrev);
  CSprite2d::~CSprite2d(p_mSpriteNext);
  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  sub_19C514(this);
}
// 662F00: using guessed type void *off_662F00;
// 664ACC: using guessed type void *off_664ACC;

//----- (002C2974) --------------------------------------------------------
void __fastcall CWidgetRegionRhythmSelect::~CWidgetRegionRhythmSelect(CWidgetRegionRhythmSelect *this)
{
  CSprite2d *p_mSpriteNext; // r5
  void *v3; // r0

  this->_vptr$CWidget = (int (**)(void))&off_664ACC;
  p_mSpriteNext = &this->mSpriteNext;
  CSprite2d::~CSprite2d(&this->mSpriteCurrent);
  CSprite2d::~CSprite2d(&this->mSpritePrev);
  CSprite2d::~CSprite2d(p_mSpriteNext);
  this->_vptr$CWidget = (int (**)(void))&off_662F00;
  CSprite2d::~CSprite2d(&this->m_SpriteFill);
  CWidget::~CWidget(this);
  sub_191374(v3);
}
// 2C29BC: variable 'v3' is possibly undefined
// 662F00: using guessed type void *off_662F00;
// 664ACC: using guessed type void *off_664ACC;

//----- (002C29C8) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetRegionRhythmSelect::GetName(CWidgetRegionRhythmSelect *this)
{
  return "Rhythm";
}

//----- (002C29D8) --------------------------------------------------------
void __fastcall CWidgetRegionSprint::CWidgetRegionSprint(
        CWidgetRegionSprint *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  CWidgetRegion::CWidgetRegion(this, pszSprite, WidgetPos, 0, HID_MAPPING_SPRINT);
  this->_vptr$CWidget = (int (**)(void))&off_664B60;
  CSprite2d::CSprite2d(&this->mSpriteCorner);
  CSprite2d::CSprite2d(&this->mSpriteCornerIcon);
  this->m_nCornerAlpha = 0;
  this->m_bTouched = 0;
  CWidget::SetTexture(this, &this->mSpriteCorner, "CornerGradient", 1);
  CWidget::SetTexture(this, &this->mSpriteCornerIcon, "sprint", 1);
  this->m_nFlags |= 8u;
}
// 664B60: using guessed type void *;

//----- (002C2A68) --------------------------------------------------------
void __fastcall CWidgetRegionSprint::Update(CWidgetRegionSprint *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  CPlayerPed *PlayerPed; // r0
  char *v5; // r2
  CPlayerPed *v6; // r0
  CPad *PadFromPlayer; // r0
  CPlayerPed *v8; // r0
  CPad *v9; // r0
  CPlayerPed *v10; // r0
  unsigned __int32 v11; // s0
  float FatAndMuscleModifier; // r5
  RwV3d_0 posn; // [sp+4h] [bp-14h] BYREF

  CWidgetRegion::Update(this);
  PlayerPed = FindPlayerPed(-1);
  if ( CPedIntelligence::GetTaskSwim(PlayerPed->m_pPedIntelligence) )
    v5 = "hud_swim";
  else
    v5 = "sprint";
  CWidget::SetTexture(this, &this->mSpriteCornerIcon, (unsigned __int8 *)v5, 0);
  if ( !CTouchInterface::IsTouchDown(this->m_nTouchIndex) )
  {
    this->m_bTouched = 0;
LABEL_12:
    v1.n64_f32[0] = (double)this->m_nCornerAlpha + CWidget::m_fElapsedTime * this->m_fFadeRate * -0.689999998;
    v2.n64_u32[0] = 0;
    v11 = vmax_f32(v1, v2).n64_u32[0];
    goto LABEL_13;
  }
  if ( !this->m_bTouched )
    goto LABEL_12;
  if ( !FindPlayerPed(-1) )
    goto LABEL_12;
  v6 = FindPlayerPed(-1);
  PadFromPlayer = CPlayerPed::GetPadFromPlayer(v6);
  if ( !CPad::GetPedWalkLeftRight(PadFromPlayer) )
  {
    v8 = FindPlayerPed(-1);
    v9 = CPlayerPed::GetPadFromPlayer(v8);
    if ( !CPad::GetPedWalkUpDown(v9) )
      goto LABEL_12;
  }
  posn.x = 0.0;
  posn.y = 0.0;
  posn.z = 0.1;
  v10 = FindPlayerPed(-1);
  CPed::GetTransformedBonePosition(v10, &posn, 5u, 0);
  if ( posn.z < mod_Buoyancy.fWaterLevel )
    goto LABEL_14;
  v1.n64_f32[0] = CWidget::m_fElapsedTime * this->m_fFadeRate * 0.389999986 + (double)this->m_nCornerAlpha;
  v2.n64_u32[0] = 1120403456;
  v11 = vmin_f32(v1, v2).n64_u32[0];
LABEL_13:
  this->m_nCornerAlpha = (int)*(float *)&v11;
LABEL_14:
  if ( FindPlayerPed(-1) )
  {
    FatAndMuscleModifier = CStats::GetFatAndMuscleModifier(STAT_MODIFIER_SPRINT_ENERGY);
    this->m_fSprintEnergyPercentage = (float)(FindPlayerPed(-1)->m_pPlayerData->m_fSprintEnergy + 150.0)
                                    / (float)(FatAndMuscleModifier + 150.0);
  }
}
// 2C2B4C: variable 'v1' is possibly undefined
// 2C2B4C: variable 'v2' is possibly undefined

//----- (002C2C1C) --------------------------------------------------------
void __fastcall CWidgetRegionSprint::OnInitialTouch(CWidgetRegionSprint *this)
{
  CWidget::OnInitialTouch(this);
  this->m_bTouched = 1;
}

//----- (002C2C2E) --------------------------------------------------------
bool __fastcall CWidgetRegionSprint::IsTouched(CWidgetRegionSprint *this, CVector2D *pVecOut)
{
  if ( CHID::Implements(HID_MAPPING_SPRINT) )
    return sub_18EC48(this, pVecOut);
  else
    return this->m_bTouched;
}

//----- (002C2C52) --------------------------------------------------------
bool __fastcall CWidgetRegionSprint::IsDoubleTapped(CWidgetRegionSprint *this)
{
  if ( CHID::Implements(HID_MAPPING_JUMP) )
    return sub_18DF74(HID_MAPPING_JUMP);
  else
    return sub_196C68(this);
}

//----- (002C2C78) --------------------------------------------------------
void __fastcall CWidgetRegionSprint::Draw(CWidgetRegionSprint *this)
{
  int m_nCornerAlpha; // r0
  float m_fSprintEnergyPercentage; // s4
  float v4; // s6
  float v5; // s16
  float v6; // s18
  float v7; // s2
  CRGBA v8; // [sp+1Ch] [bp-64h] BYREF
  CRect v9; // [sp+20h] [bp-60h] BYREF
  CRect Rectangle; // [sp+30h] [bp-50h] BYREF

  CWidgetRegion::Draw(this);
  if ( this->m_bEnabled )
  {
    m_nCornerAlpha = this->m_nCornerAlpha;
    if ( m_nCornerAlpha >= 2 )
    {
      m_fSprintEnergyPercentage = this->m_fSprintEnergyPercentage;
      v4 = (float)RsGlobal.screenWidth * 0.1;
      v5 = (float)RsGlobal.screenHeight + (float)((float)RsGlobal.screenHeight * -0.02);
      v6 = (float)RsGlobal.screenWidth + (float)((float)RsGlobal.screenWidth * -0.015);
      Rectangle.right = v6;
      v7 = v5 - (1.0 - m_fSprintEnergyPercentage) * v4;
      Rectangle.left = v6 - v4;
      Rectangle.top = v7;
      Rectangle.bottom = v7 - (float)(v4 * m_fSprintEnergyPercentage);
      CRGBA::CRGBA((CRGBA *)&v9, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)((float)m_nCornerAlpha * 2.55));
      CSprite2d::Draw(
        &this->mSpriteCornerIcon,
        &Rectangle,
        (const CRGBA *)&v9,
        0.0,
        0.0,
        1.0,
        0.0,
        0.0,
        this->m_fSprintEnergyPercentage,
        1.0,
        this->m_fSprintEnergyPercentage);
      Rectangle.right = v6;
      Rectangle.left = v6 - v4;
      Rectangle.bottom = Rectangle.top;
      Rectangle.top = v5;
      CRGBA::CRGBA((CRGBA *)&v9, 0x99u, 0xCCu, 0x99u, (unsigned int)(float)((float)this->m_nCornerAlpha * 2.55));
      CSprite2d::Draw(
        &this->mSpriteCornerIcon,
        &Rectangle,
        (const CRGBA *)&v9,
        0.0,
        this->m_fSprintEnergyPercentage,
        1.0,
        this->m_fSprintEnergyPercentage,
        0.0,
        1.0,
        1.0,
        1.0);
      v9.right = (float)RsGlobal.screenWidth;
      v9.top = (float)RsGlobal.screenHeight;
      v9.left = (float)RsGlobal.screenWidth - (float)((float)RsGlobal.screenWidth * 0.125);
      v9.bottom = (float)RsGlobal.screenHeight - (float)((float)RsGlobal.screenWidth * 0.125);
      CRGBA::CRGBA(&v8, 0xFFu, 0xFFu, 0xFFu, this->m_nCornerAlpha);
      CSprite2d::Draw(&this->mSpriteCorner, &v9, &v8);
    }
  }
}

//----- (002C2E44) --------------------------------------------------------
void __fastcall CWidgetRegionSprint::~CWidgetRegionSprint(CWidgetRegionSprint *this)
{
  CSprite2d *p_mSpriteCorner; // r5

  this->_vptr$CWidget = (int (**)(void))&off_664B60;
  p_mSpriteCorner = &this->mSpriteCorner;
  CSprite2d::~CSprite2d(&this->mSpriteCornerIcon);
  CSprite2d::~CSprite2d(p_mSpriteCorner);
  sub_19C514(this);
}
// 664B60: using guessed type void *off_664B60;

//----- (002C2E74) --------------------------------------------------------
void __fastcall CWidgetRegionSprint::~CWidgetRegionSprint(CWidgetRegionSprint *this)
{
  CSprite2d *p_mSpriteCorner; // r5
  void *v3; // r0

  this->_vptr$CWidget = (int (**)(void))&off_664B60;
  p_mSpriteCorner = &this->mSpriteCorner;
  CSprite2d::~CSprite2d(&this->mSpriteCornerIcon);
  CSprite2d::~CSprite2d(p_mSpriteCorner);
  CWidget::~CWidget(this);
  sub_191374(v3);
}
// 2C2EA0: variable 'v3' is possibly undefined
// 664B60: using guessed type void *off_664B60;

//----- (002C2EA8) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetRegionSprint::GetName(CWidgetRegionSprint *this)
{
  return "Sprint";
}

//----- (002C2EB4) --------------------------------------------------------
void __fastcall CWidgetRegionSteer::CWidgetRegionSteer(
        CWidgetRegionSteer *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  CWidgetRegion::CWidgetRegion(this, pszSprite, WidgetPos, 32, HID_MAPPING_UNKNOWN);
  this->_vptr$CWidget = (int (**)(void))&off_664BF4;
  CSprite2d::CSprite2d(&this->m_SpriteIndicator);
  this->m_vecIndicatorOrigin = 0LL;
  this->m_vecTouchAnchorInternal = 0LL;
  this->m_fTouchLimit = 0.275;
  CWidget::SetTexture(this, &this->m_SpriteIndicator, "hud_analognub", 1);
}
// 664BF4: using guessed type void *;

//----- (002C2F1C) --------------------------------------------------------
void __fastcall CWidgetRegionSteer::Update(CWidgetRegionSteer *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d3
  int m_nTouchIndex; // r0
  CVector2D *v6; // r1
  _BOOL4 m_bEnabled; // r1
  float32x2_t v8; // d1
  float32x2_t v9; // d0

  CWidgetRegion::Update(this);
  v1.n64_f32[0] = (float)((float)MobileSettings::settings[23].value / -100.0) + 0.65;
  LODWORD(this->m_fTouchLimit) = v1.n64_u32[0];
  m_nTouchIndex = this->m_nTouchIndex;
  v6 = &CWidget::m_vecTouchAnchor[m_nTouchIndex];
  v3.n64_u32[0] = LODWORD(v6->y);
  v1.n64_f32[0] = v1.n64_f32[0] * (float)(this->m_fScaleX * (float)((float)RsGlobal.screenWidth / 640.0));
  v2.n64_u32[0] = LODWORD(v6->x);
  m_bEnabled = this->m_bEnabled;
  v8.n64_u64[0] = vmax_f32(v2, v1).n64_u64[0];
  v1.n64_f32[0] = (float)RsGlobal.screenHeight - v1.n64_f32[0];
  LODWORD(this->m_vecTouchAnchorInternal.x) = v8.n64_u32[0];
  v9.n64_u64[0] = vmin_f32(v3, v1).n64_u64[0];
  LODWORD(this->m_vecTouchAnchorInternal.y) = v9.n64_u32[0];
  if ( m_bEnabled
    && CTouchInterface::IsTouchDown(m_nTouchIndex)
    && (*((int (__fastcall **)(CWidgetRegionSteer *, CVector2D *, _DWORD))this->_vptr$CWidget + 3))(
         this,
         &this->m_vecTouchAnchorInternal,
         0) == 1 )
  {
    this->m_Color._anon_0._anon_0.alpha = -1;
  }
  else if ( (*((int (__fastcall **)(CWidgetRegionSteer *, CVector2D *, _DWORD))this->_vptr$CWidget + 3))(
              this,
              &this->m_vecTouchAnchorInternal,
              0) == 1 )
  {
    v8.n64_u32[0] = 0;
    v9.n64_f32[0] = (double)this->m_Color._anon_0._anon_0.alpha - CWidget::m_fElapsedTime * this->m_fFadeRate;
    this->m_Color._anon_0._anon_0.alpha = (unsigned int)vmax_f32(v9, v8).n64_f32[0];
  }
  else
  {
    this->m_Color._anon_0._anon_0.alpha = 0;
  }
}
// 2C2F8C: variable 'v2' is possibly undefined
// 2C2F8C: variable 'v1' is possibly undefined
// 2C2F98: variable 'v3' is possibly undefined

//----- (002C3040) --------------------------------------------------------
void __fastcall CWidgetRegionSteer::ClampInternalTouchAnchor(CWidgetRegionSteer *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d2
  float32x2_t v3; // d3
  CVector2D *v4; // r1
  float v5; // s4

  v4 = &CWidget::m_vecTouchAnchor[this->m_nTouchIndex];
  v2.n64_u32[0] = LODWORD(v4->x);
  v1.n64_f32[0] = this->m_fTouchLimit * (float)(this->m_fScaleX * (float)((float)RsGlobal.screenWidth / 640.0));
  v3.n64_u32[0] = LODWORD(v4->y);
  LODWORD(v5) = vmax_f32(v2, v1).n64_u32[0];
  v1.n64_f32[0] = (float)RsGlobal.screenHeight - v1.n64_f32[0];
  this->m_vecTouchAnchorInternal.x = v5;
  LODWORD(this->m_vecTouchAnchorInternal.y) = vmin_f32(v3, v1).n64_u32[0];
}
// 2C3082: variable 'v2' is possibly undefined
// 2C3082: variable 'v1' is possibly undefined
// 2C308E: variable 'v3' is possibly undefined

//----- (002C30A4) --------------------------------------------------------
void __fastcall CWidgetRegionSteer::Draw(CWidgetRegionSteer *this)
{
  float x; // s2
  float v3; // s0
  float y; // s4
  float v5; // s4
  float v6; // s0
  float v7; // s2
  CRect v8[2]; // [sp+0h] [bp-28h] BYREF

  if ( (*((int (__fastcall **)(CWidgetRegionSteer *, _DWORD))this->_vptr$CWidget + 20))(this, 0) == 1 )
  {
    if ( this->m_Color._anon_0._anon_0.alpha )
    {
      x = this->m_vecTouchAnchorInternal.x;
      v3 = this->m_fTouchLimit * (float)(this->m_fScaleX * (float)((float)RsGlobal.screenWidth / 640.0));
      y = this->m_vecTouchAnchorInternal.y;
      v8[0].bottom = y - v3;
      v8[0].left = x - v3;
      v8[0].right = x + v3;
      v8[0].top = y + v3;
      CSprite2d::Draw(&this->m_Sprite, v8, &this->m_Color);
      v5 = this->m_vecIndicatorOrigin.y;
      v6 = (float)(this->m_fScaleX * (float)((float)RsGlobal.screenWidth / 640.0)) * 0.15;
      v7 = this->m_vecIndicatorOrigin.x;
      v8[0].bottom = v5 - v6;
      v8[0].left = v7 - v6;
      v8[0].right = v7 + v6;
      v8[0].top = v5 + v6;
      CSprite2d::Draw(&this->m_SpriteIndicator, v8, &this->m_Color);
    }
  }
}

//----- (002C3190) --------------------------------------------------------
bool __fastcall CWidgetRegionSteer::IsTouched(CWidgetRegionSteer *this, CVector2D *pVecOut)
{
  CVector2D *p_y; // r1
  bool result; // r0
  float v6; // s0
  float v7; // s20
  float v8; // s18
  float v9; // s0
  float v10; // s2
  float v11; // s0
  float v12; // s2
  float v13; // s0
  float v14; // s2
  CVector2D v15; // [sp+0h] [bp-28h] BYREF

  if ( !CHID::Implements(HID_MAPPING_VEHICLE_STEER_X) && !CHID::Implements(HID_MAPPING_VEHICLE_STEER_Y) )
    goto LABEL_9;
  CHID::IsPressed(HID_MAPPING_VEHICLE_STEER_X, &pVecOut->x);
  p_y = pVecOut;
  if ( pVecOut )
    p_y = (CVector2D *)&pVecOut->y;
  CHID::IsPressed(HID_MAPPING_VEHICLE_STEER_Y, &p_y->x);
  if ( CHID::IsPressed(HID_MAPPING_VEHICLE_STEER_X, 0) || CHID::IsPressed(HID_MAPPING_VEHICLE_STEER_Y, 0) )
  {
    result = 1;
    if ( pVecOut )
    {
      v6 = pVecOut->y * 128.0;
      pVecOut->x = pVecOut->x * 128.0;
      pVecOut->y = v6;
    }
  }
  else
  {
LABEL_9:
    CTouchInterface::GetTouchPosition(&v15, this->m_nTouchIndex);
    v7 = v15.x - this->m_vecTouchAnchorInternal.x;
    v8 = v15.y - this->m_vecTouchAnchorInternal.y;
    v9 = sqrtf((float)(v7 * v7) + (float)(v8 * v8));
    v10 = this->m_fTouchLimit * (float)(this->m_fScaleX * (float)((float)RsGlobal.screenWidth / 640.0));
    if ( v9 > v10 )
    {
      v11 = 1.0 / (float)(v9 / v10);
      v8 = v8 * v11;
      v7 = v7 * v11;
    }
    if ( CTouchInterface::IsTouchDown(this->m_nTouchIndex) )
    {
      v12 = v8 + this->m_vecTouchAnchorInternal.y;
      this->m_vecIndicatorOrigin.x = v7 + this->m_vecTouchAnchorInternal.x;
      this->m_vecIndicatorOrigin.y = v12;
    }
    if ( pVecOut )
    {
      v13 = 1.0 / (float)(this->m_fTouchLimit * (float)(this->m_fScaleX * (float)((float)RsGlobal.screenWidth / 640.0)));
      v14 = (float)((float)(this->m_vecIndicatorOrigin.y - this->m_vecTouchAnchorInternal.y) * v13) * 128.0;
      pVecOut->x = (float)((float)(this->m_vecIndicatorOrigin.x - this->m_vecTouchAnchorInternal.x) * v13) * 128.0;
      pVecOut->y = v14;
    }
    return CWidget::IsTouched(this, pVecOut);
  }
  return result;
}

//----- (002C331C) --------------------------------------------------------
void __fastcall CWidgetRegionSteer::OnInitialTouch(CWidgetRegionSteer *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d2
  float32x2_t v3; // d3
  CVector2D *v5; // r0
  float v6; // s4
  float v7; // s0

  CWidget::OnInitialTouch(this);
  v5 = &CWidget::m_vecTouchAnchor[this->m_nTouchIndex];
  v2.n64_u32[0] = LODWORD(v5->x);
  v1.n64_f32[0] = this->m_fTouchLimit * (float)(this->m_fScaleX * (float)((float)RsGlobal.screenWidth / 640.0));
  v3.n64_u32[0] = LODWORD(v5->y);
  LODWORD(v6) = vmax_f32(v2, v1).n64_u32[0];
  v1.n64_f32[0] = (float)RsGlobal.screenHeight - v1.n64_f32[0];
  this->m_vecIndicatorOrigin.x = v6;
  LODWORD(v7) = vmin_f32(v3, v1).n64_u32[0];
  this->m_vecIndicatorOrigin.y = v7;
  this->m_vecTouchAnchorInternal.x = v6;
  this->m_vecTouchAnchorInternal.y = v7;
}
// 2C3368: variable 'v2' is possibly undefined
// 2C3368: variable 'v1' is possibly undefined
// 2C3374: variable 'v3' is possibly undefined

//----- (002C3394) --------------------------------------------------------
void __fastcall CWidgetRegionSteer::~CWidgetRegionSteer(CWidgetRegionSteer *this)
{
  this->_vptr$CWidget = (int (**)(void))&off_664BF4;
  CSprite2d::~CSprite2d(&this->m_SpriteIndicator);
  sub_19C514(this);
}
// 664BF4: using guessed type void *off_664BF4;

//----- (002C33BC) --------------------------------------------------------
void __fastcall CWidgetRegionSteer::~CWidgetRegionSteer(CWidgetRegionSteer *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_664BF4;
  CSprite2d::~CSprite2d(&this->m_SpriteIndicator);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2C33E0: variable 'v2' is possibly undefined
// 664BF4: using guessed type void *off_664BF4;

//----- (002C33E8) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetRegionSteer::GetName(CWidgetRegionSteer *this)
{
  return "Steer";
}

//----- (002C3400) --------------------------------------------------------
void __fastcall CWidgetRegionHydraulics::CWidgetRegionHydraulics(
        CWidgetRegionHydraulics *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  double v4; // d16
  _BOOL4 m_bLocked; // r1
  float v6; // s0

  CWidgetRegion::CWidgetRegion(this, pszSprite, WidgetPos, 0, HID_MAPPING_LOOK_X);
  *(_QWORD *)&this->m_RectLock.left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_RectLock.right = 0x49742400C9742400LL;
  this->_vptr$CWidget = (int (**)(void))&off_664C88;
  CSprite2d::CSprite2d(&this->m_SpriteLock);
  this->m_eHydraulicState = 0;
  this->m_fDeltaX = 0.0;
  this->m_fDeltaY = 0.0;
  this->m_bActive = 0;
  this->vLastTouchPos[0] = 0LL;
  this->vLastTouchPos[1] = 0LL;
  v4 = CWidget::m_fElapsedTime * -0.5 + 0.0;
  if ( v4 <= 0.075000003 )
    v4 = 0.075000003;
  m_bLocked = this->m_bLocked;
  this->OldTouchPosition.x = 0.0;
  this->OldTouchPosition.y = 0.0;
  v6 = v4;
  this->m_fFade = v6;
  if ( !m_bLocked )
    this->m_eHydraulicState = 0;
  this->m_bLocked = 0;
  CWidget::SetTexture(this, &this->m_Sprite, "fadeinbox", 1);
  CWidget::SetTexture(this, &this->m_SpriteLock, "lock", 1);
}
// 664C88: using guessed type void *;

//----- (002C34F8) --------------------------------------------------------
void __fastcall CWidgetRegionHydraulics::ResetHydraulicRegion(CWidgetRegionHydraulics *this)
{
  double v1; // d16
  _BOOL4 m_bLocked; // r2
  float v3; // s0

  this->m_bActive = 0;
  this->m_fDeltaX = 0.0;
  this->m_fDeltaY = 0.0;
  v1 = this->m_fFade + CWidget::m_fElapsedTime * -0.5;
  if ( v1 <= 0.075000003 )
    v1 = 0.075000003;
  m_bLocked = this->m_bLocked;
  this->OldTouchPosition.x = 0.0;
  this->OldTouchPosition.y = 0.0;
  v3 = v1;
  this->m_fFade = v3;
  if ( !m_bLocked )
    this->m_eHydraulicState = 0;
}

//----- (002C355C) --------------------------------------------------------
void __fastcall CWidgetRegionHydraulics::Draw(CWidgetRegionHydraulics *this)
{
  float left; // s0
  float right; // s2
  float v4; // s4
  float v5; // s16
  float v6; // s0
  float v7; // s6
  UInt8 alpha; // r6
  CSprite2d *p_m_SpriteLock; // r5
  float v10; // s2
  float top; // s4
  _BOOL4 m_bLocked; // r0
  CRect *p_m_RectLock; // r4
  CRGBA rgba; // [sp+4h] [bp-2Ch] BYREF
  CRect Rectangle; // [sp+8h] [bp-28h] BYREF

  if ( this->m_bEnabled )
  {
    left = this->m_RectScreen.left;
    right = this->m_RectScreen.right;
    v4 = this->m_fFade * 255.0;
    v5 = fabsf(right - left);
    Rectangle.top = this->m_RectScreen.top;
    v6 = (float)(left + right) * 0.5;
    v7 = v5 * 0.5 + v6;
    alpha = (int)v4;
    Rectangle.bottom = Rectangle.top + (float)(v5 * -0.625);
    Rectangle.left = v6 - (float)(v5 * 0.5);
    Rectangle.right = v7;
    CRGBA::CRGBA(&rgba, 0xFFu, 0xFFu, 0xFFu, alpha);
    CSprite2d::Draw(&this->m_Sprite, &Rectangle, &rgba);
    p_m_SpriteLock = &this->m_SpriteLock;
    v10 = Rectangle.left;
    top = Rectangle.top;
    this->m_RectLock.left = Rectangle.left;
    this->m_RectLock.top = top;
    this->m_RectLock.right = (float)(v5 * 0.175) + v10;
    this->m_RectLock.bottom = top - (float)(v5 * 0.175);
    m_bLocked = this->m_bLocked;
    p_m_RectLock = &this->m_RectLock;
    if ( m_bLocked )
      CRGBA::CRGBA(&rgba, 0xFFu, 0, 0, 0x7Au);
    else
      CRGBA::CRGBA(&rgba, 0xFFu, 0xFFu, 0xFFu, alpha);
    CSprite2d::Draw(p_m_SpriteLock, p_m_RectLock, &rgba);
  }
}

//----- (002C3678) --------------------------------------------------------
void __fastcall CWidgetRegionHydraulics::Update(CWidgetRegionHydraulics *this)
{
  CVehicle *PlayerVehicle; // r0
  int m_nModelIndex; // r0
  int v4; // r5
  bool v5; // zf
  float left; // s0
  float right; // s2
  float bottom; // s4
  float top; // s6
  float x; // s8
  float y; // s0
  float v12; // s0
  float v13; // s2
  float v14; // s4
  float v15; // s6
  float v16; // s8
  float v17; // s0
  float m_fFade; // s0
  double v19; // d16
  double v20; // d18
  _BOOL4 m_bActive; // r0
  float v22; // s0
  float v23; // s0
  float v24; // s4
  float v25; // s6
  float v26; // s3
  float v27; // s10
  float v28; // s2
  bool v29; // fzf
  bool v30; // fnf
  float v31; // s10
  int v32; // r0
  double v33; // d16
  _BOOL4 m_bLocked; // r1
  float v35; // s0
  float v36; // r0
  float v37; // r1
  double v38; // d16
  _BOOL4 v39; // r0
  float v40; // s0
  CVector2D v41; // [sp+0h] [bp-18h] BYREF

  CWidgetRegion::Update(this);
  PlayerVehicle = FindPlayerVehicle(-1, 0);
  if ( !PlayerVehicle )
    goto LABEL_78;
  if ( (PlayerVehicle->hFlagsLocal & 0x20000) != 0 )
  {
    v4 = 0;
    goto LABEL_11;
  }
  m_nModelIndex = PlayerVehicle->m_nModelIndex;
  if ( m_nModelIndex >= 486 )
  {
    v4 = 0;
    switch ( m_nModelIndex )
    {
      case 486:
      case 525:
      case 531:
        goto LABEL_10;
      case 487:
      case 488:
      case 489:
      case 490:
      case 491:
      case 492:
      case 493:
      case 494:
      case 495:
      case 496:
      case 497:
      case 498:
      case 499:
      case 500:
      case 501:
      case 502:
      case 503:
      case 504:
      case 505:
      case 506:
      case 507:
      case 508:
      case 509:
      case 510:
      case 511:
      case 512:
      case 513:
      case 514:
      case 515:
      case 516:
      case 517:
      case 518:
      case 519:
      case 521:
      case 522:
      case 523:
      case 524:
      case 526:
      case 527:
      case 528:
      case 529:
        goto LABEL_78;
      case 520:
      case 530:
        goto LABEL_11;
      default:
        if ( m_nModelIndex == 592 )
          goto LABEL_11;
        break;
    }
    goto LABEL_78;
  }
  v5 = m_nModelIndex == 406;
  if ( m_nModelIndex != 406 )
    v5 = m_nModelIndex == 443;
  if ( v5 )
  {
LABEL_10:
    v4 = 1;
LABEL_11:
    if ( CTouchInterface::IsTouchDown(0) )
    {
      bFirstTouchIsDown = 1;
      CTouchInterface::GetTouchPosition(&v41, 0);
      this->vLastTouchPos[0] = v41;
    }
    if ( CTouchInterface::IsTouchDown(1) )
    {
      bSecondTouchIsDown = 1;
      CTouchInterface::GetTouchPosition(&v41, 1);
      this->vLastTouchPos[1] = v41;
    }
    if ( !CTouchInterface::IsTouchDown(0) && bFirstTouchIsDown == 1 )
    {
      left = this->m_RectLock.left;
      if ( CWidget::m_vecTouchAnchor[0].x >= left )
      {
        right = this->m_RectLock.right;
        if ( CWidget::m_vecTouchAnchor[0].x <= right )
        {
          bottom = this->m_RectLock.bottom;
          if ( CWidget::m_vecTouchAnchor[0].y >= bottom )
          {
            top = this->m_RectLock.top;
            if ( CWidget::m_vecTouchAnchor[0].y <= top )
            {
              x = this->vLastTouchPos[0].x;
              if ( x >= left && x <= right )
              {
                y = this->vLastTouchPos[0].y;
                if ( y >= bottom && y <= top )
                  this->m_bLocked ^= 1u;
              }
            }
          }
        }
      }
      bFirstTouchIsDown = 0;
    }
    if ( !CTouchInterface::IsTouchDown(1) && bSecondTouchIsDown == 1 )
    {
      v12 = this->m_RectLock.left;
      if ( CWidget::m_vecTouchAnchor[1].x >= v12 )
      {
        v13 = this->m_RectLock.right;
        if ( CWidget::m_vecTouchAnchor[1].x <= v13 )
        {
          v14 = this->m_RectLock.bottom;
          if ( CWidget::m_vecTouchAnchor[1].y >= v14 )
          {
            v15 = this->m_RectLock.top;
            if ( CWidget::m_vecTouchAnchor[1].y <= v15 )
            {
              v16 = this->vLastTouchPos[1].x;
              if ( v16 >= v12 && v16 <= v13 )
              {
                v17 = this->vLastTouchPos[1].y;
                if ( v17 >= v14 && v17 <= v15 )
                  this->m_bLocked ^= 1u;
              }
            }
          }
        }
      }
      bSecondTouchIsDown = 0;
    }
    if ( (*((int (__fastcall **)(CWidgetRegionHydraulics *, _DWORD))this->_vptr$CWidget + 20))(this, 0) != 1 )
      goto LABEL_78;
    m_fFade = this->m_fFade;
    v19 = CWidget::m_fElapsedTime;
    v20 = 0.25;
    if ( v19 + v19 + m_fFade < 0.25 )
      v20 = CWidget::m_fElapsedTime + CWidget::m_fElapsedTime + m_fFade;
    m_bActive = this->m_bActive;
    v22 = v20;
    this->m_fFade = v22;
    if ( !m_bActive )
    {
      v33 = v22 + v19 * -0.5;
      if ( v33 <= 0.075000003 )
        v33 = 0.075000003;
      m_bLocked = this->m_bLocked;
      this->m_fDeltaX = 0.0;
      this->m_fDeltaY = 0.0;
      this->m_bActive = 0;
      this->OldTouchPosition.x = 0.0;
      this->OldTouchPosition.y = 0.0;
      v35 = v33;
      this->m_fFade = v35;
      if ( !m_bLocked )
        this->m_eHydraulicState = 0;
      if ( FindPlayerPed(-1) && *((unsigned __int8 *)&FindPlayerPed(-1)->m_nPedFlags + 1) << 31 )
      {
        if ( (*((int (__fastcall **)(CWidgetRegionHydraulics *, CVector2D *, _DWORD))this->_vptr$CWidget + 3))(
               this,
               CWidget::m_vecTouchAnchor,
               0) == 1 )
        {
          this->m_bActive = 1;
          v36 = CWidget::m_vecTouchAnchor[0].y;
          v37 = CWidget::m_vecTouchAnchor[0].x;
        }
        else
        {
          if ( (*((int (__fastcall **)(CWidgetRegionHydraulics *, CVector2D *, _DWORD))this->_vptr$CWidget + 3))(
                 this,
                 &CWidget::m_vecTouchAnchor[1],
                 0) != 1 )
            goto LABEL_78;
          this->m_bActive = 1;
          v36 = CWidget::m_vecTouchAnchor[1].y;
          v37 = CWidget::m_vecTouchAnchor[1].x;
        }
        this->OldTouchPosition.x = v37;
        this->OldTouchPosition.y = v36;
        goto LABEL_78;
      }
      goto LABEL_78;
    }
    CTouchInterface::GetTouchPosition(&v41, this->m_nTouchIndex);
    v23 = v41.x;
    v24 = this->OldTouchPosition.y;
    v25 = v41.x - this->OldTouchPosition.x;
    v26 = -1.0;
    this->m_fDeltaX = v25;
    v27 = fabsf(v25);
    v28 = v41.y;
    if ( v25 > 0.0 )
      v26 = 1.0;
    v29 = v27 == 10.0;
    v30 = v27 < 10.0;
    v31 = 0.0;
    if ( !v30 && !v29 )
      v31 = v26;
    if ( v4 )
      v31 = -v31;
    this->m_fDeltaY = v41.y - v24;
    if ( v31 == -1.0 )
    {
      v32 = 3;
    }
    else if ( v31 == -1.0 )
    {
      v32 = 5;
    }
    else if ( v31 == -1.0 )
    {
      v32 = 7;
    }
    else if ( v31 == 1.0 )
    {
      v32 = 4;
    }
    else
    {
      if ( v31 != 0.0 )
        goto LABEL_77;
      v32 = 1;
    }
    this->m_eHydraulicState = v32;
LABEL_77:
    this->OldTouchPosition.x = v23;
    this->OldTouchPosition.y = v28;
  }
LABEL_78:
  if ( (*((int (__fastcall **)(CWidgetRegionHydraulics *, _DWORD))this->_vptr$CWidget + 20))(this, 0) != 1
    || CTheScripts::pActiveScripts && !strcmp((const char *)CTheScripts::pActiveScripts->ScriptName, "lowgame") )
  {
    this->m_bActive = 0;
    this->m_fDeltaX = 0.0;
    this->m_fDeltaY = 0.0;
    v38 = this->m_fFade + CWidget::m_fElapsedTime * -0.5;
    if ( v38 <= 0.075000003 )
      v38 = 0.075000003;
    v39 = this->m_bLocked;
    this->OldTouchPosition.x = 0.0;
    this->OldTouchPosition.y = 0.0;
    v40 = v38;
    this->m_fFade = v40;
    if ( !v39 )
      this->m_eHydraulicState = 0;
  }
  if ( !this->m_bEnabled )
    this->m_bLocked = 0;
  if ( !CTouchInterface::IsTouchDown(0) )
  {
    bFirstTouchIsDown = 0;
    this->vLastTouchPos[0].x = 0.0;
    this->vLastTouchPos[0].y = 0.0;
  }
  if ( !CTouchInterface::IsTouchDown(1) )
  {
    bSecondTouchIsDown = 0;
    this->vLastTouchPos[1].x = 0.0;
    this->vLastTouchPos[1].y = 0.0;
  }
}
// 70B632: using guessed type char bFirstTouchIsDown;
// 70B633: using guessed type char bSecondTouchIsDown;
// 2C3678: using guessed type CVector2D var_18;

//----- (002C3C58) --------------------------------------------------------
void __fastcall CWidgetRegionHydraulics::~CWidgetRegionHydraulics(CWidgetRegionHydraulics *this)
{
  this->_vptr$CWidget = (int (**)(void))&off_664C88;
  CSprite2d::~CSprite2d(&this->m_SpriteLock);
  sub_19C514(this);
}
// 664C88: using guessed type void *off_664C88;

//----- (002C3C80) --------------------------------------------------------
void __fastcall CWidgetRegionHydraulics::~CWidgetRegionHydraulics(CWidgetRegionHydraulics *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_664C88;
  CSprite2d::~CSprite2d(&this->m_SpriteLock);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2C3CA4: variable 'v2' is possibly undefined
// 664C88: using guessed type void *off_664C88;

//----- (002C3CAC) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetRegionHydraulics::GetName(CWidgetRegionHydraulics *this)
{
  return "Hydraulics";
}

//----- (002C3CC0) --------------------------------------------------------
void __fastcall CWidgetRegionSteeringSelection::CWidgetRegionSteeringSelection(
        CWidgetRegionSteeringSelection *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  float bottom; // s2
  float v5; // s0
  float left; // r0
  float right; // r1
  float v8; // s0
  float v9; // s4
  float v10; // s8
  float v11; // s12
  float v12; // s0
  float v13; // s4
  float v14; // s8
  float v15; // s12
  float v16; // s3

  CWidgetRegion::CWidgetRegion(this, pszSprite, WidgetPos, 0x2000, HID_MAPPING_UNKNOWN);
  *(_QWORD *)&this->mTitle.left = 0xC974240049742400LL;
  *(_QWORD *)&this->mTitle.right = 0x49742400C9742400LL;
  this->_vptr$CWidget = (int (**)(void))&off_664D1C;
  CSprite2d::CSprite2d(&this->mSpriteOverlay);
  *(_QWORD *)&this->mAnalogSelection.left = 0xC974240049742400LL;
  *(_QWORD *)&this->mAnalogSelection.right = 0x49742400C9742400LL;
  *(_QWORD *)&this->mInfo.left = 0xC974240049742400LL;
  *(_QWORD *)&this->mInfo.right = 0x49742400C9742400LL;
  CSprite2d::CSprite2d(&this->mSpriteNub);
  CSprite2d::CSprite2d(&this->mSpriteCircle);
  *(_QWORD *)&this->mDigitalSelection.left = 0xC974240049742400LL;
  this->mDigitalSelection.right = -1000000.0;
  this->mDigitalSelection.bottom = 1000000.0;
  CSprite2d::CSprite2d(&this->mSpriteLeft);
  CSprite2d::CSprite2d(&this->mSpriteRight);
  *(_QWORD *)&this->mFlickSelection.left = 0xC974240049742400LL;
  *(_QWORD *)&this->mFlickSelection.right = 0x49742400C9742400LL;
  CSprite2d::CSprite2d(&this->mSpriteArrow);
  CWidget::SetTexture(this, &this->mSpriteOverlay, "white", 1);
  this->m_nCurrentSelection = -1;
  this->m_nInitialSelection = -1;
  CWidget::SetTexture(this, &this->mSpriteNub, "hud_analognub", 1);
  CWidget::SetTexture(this, &this->mSpriteCircle, "hud_circle", 1);
  CWidget::SetTexture(this, &this->mSpriteLeft, "hud_left", 1);
  CWidget::SetTexture(this, &this->mSpriteRight, "hud_right", 1);
  CWidget::SetTexture(this, &this->mSpriteArrow, "Arrow", 1);
  bottom = this->m_RectScreen.bottom;
  v5 = this->m_RectScreen.top - bottom;
  left = this->m_RectScreen.left;
  right = this->m_RectScreen.right;
  this->mTitle.left = left;
  this->mTitle.right = right;
  this->mInfo.right = right;
  this->mInfo.left = left;
  this->mTitle.bottom = bottom;
  v8 = fabsf(v5) + -4.0;
  v9 = v8 * 0.175;
  v10 = v8 * 0.1;
  v11 = v8 * 0.275;
  v12 = v8 * 0.225;
  v13 = bottom + v9;
  this->mTitle.top = v13;
  v14 = v10 + (float)(v13 + 1.0);
  this->mInfo.bottom = v13 + 1.0;
  this->mInfo.top = v14;
  this->mAnalogSelection.right = right;
  this->mAnalogSelection.left = left;
  v15 = v11 + (float)(v14 + 1.0);
  this->mAnalogSelection.bottom = v14 + 1.0;
  this->mAnalogSelection.top = v15;
  this->mDigitalSelection.right = right;
  this->mDigitalSelection.left = left;
  v16 = v12 + (float)(v15 + 1.0);
  this->mDigitalSelection.bottom = v15 + 1.0;
  this->mDigitalSelection.top = v16;
  this->mFlickSelection.right = right;
  this->mFlickSelection.left = left;
  this->mFlickSelection.bottom = v16 + 1.0;
  this->mFlickSelection.top = v12 + (float)(v16 + 1.0);
}
// 664D1C: using guessed type void *;

//----- (002C3EE8) --------------------------------------------------------
void __fastcall CWidgetRegionSteeringSelection::BuildRects(CWidgetRegionSteeringSelection *this)
{
  float bottom; // s2
  float v2; // s0
  float left; // r1
  float right; // r2
  float v5; // s0
  float v6; // s4
  float v7; // s8
  float v8; // s12
  float v9; // s0
  float v10; // s4
  float v11; // s8
  float v12; // s12
  float v13; // s3

  bottom = this->m_RectScreen.bottom;
  v2 = this->m_RectScreen.top - bottom;
  left = this->m_RectScreen.left;
  right = this->m_RectScreen.right;
  this->mTitle.left = left;
  this->mTitle.right = right;
  this->mInfo.right = right;
  this->mInfo.left = left;
  this->mTitle.bottom = bottom;
  v5 = fabsf(v2) + -4.0;
  v6 = v5 * 0.175;
  v7 = v5 * 0.1;
  v8 = v5 * 0.275;
  v9 = v5 * 0.225;
  v10 = bottom + v6;
  this->mTitle.top = v10;
  v11 = v7 + (float)(v10 + 1.0);
  this->mInfo.bottom = v10 + 1.0;
  this->mInfo.top = v11;
  this->mAnalogSelection.right = right;
  this->mAnalogSelection.left = left;
  v12 = v8 + (float)(v11 + 1.0);
  this->mAnalogSelection.bottom = v11 + 1.0;
  this->mAnalogSelection.top = v12;
  this->mDigitalSelection.right = right;
  this->mDigitalSelection.left = left;
  v13 = v9 + (float)(v12 + 1.0);
  this->mDigitalSelection.bottom = v12 + 1.0;
  this->mDigitalSelection.top = v13;
  this->mFlickSelection.right = right;
  this->mFlickSelection.left = left;
  this->mFlickSelection.bottom = v13 + 1.0;
  this->mFlickSelection.top = v9 + (float)(v13 + 1.0);
}

//----- (002C3FB0) --------------------------------------------------------
void __fastcall CWidgetRegionSteeringSelection::Draw(CWidgetRegionSteeringSelection *this)
{
  unsigned int v2; // r0
  float v3; // s0
  float left; // s18
  float right; // s20
  float v6; // s16
  unsigned int alpha; // r9
  unsigned int v8; // r10
  CRGBA v9; // r0
  CRGBA v10; // r0
  float v11; // s24
  float v12; // s18
  float v13; // s20
  GxtChar *v14; // r0
  float StringWidth; // r0
  float v16; // s24
  float v17; // s26
  float v18; // s26
  GxtChar *v19; // r0
  float v20; // s24
  float v21; // s22
  GxtChar *v22; // r0
  float v23; // r0
  float v24; // s22
  float v25; // s24
  float v26; // s0
  GxtChar *v27; // r0
  float v28; // s20
  float v29; // s22
  GxtChar *v30; // r0
  float v31; // r0
  GxtChar *v32; // r0
  float v33; // r0
  GxtChar *v34; // r0
  float v35; // r0
  float bottom; // s4
  float v37; // s0
  float v38; // s2
  GxtChar *v39; // r0
  float v40; // s4
  float v41; // s0
  float v42; // s2
  GxtChar *v43; // r0
  float v44; // s4
  float v45; // s0
  float v46; // s2
  GxtChar *v47; // r0
  float v48; // s20
  float v49; // s4
  float v50; // s0
  float v51; // s2
  GxtChar *v52; // r0
  int NumberLines; // r6
  float Height; // r0
  float top; // s2
  float v56; // s0
  float v57; // s4
  GxtChar *v58; // r0
  int v59; // r5
  float v60; // r0
  float v61; // s2
  float v62; // s0
  float v63; // s4
  GxtChar *v64; // r0
  int v65; // r5
  CRGBA v66; // r0
  float v67; // s4
  float v68; // s0
  float v69; // s2
  GxtChar *v70; // r0
  float v71; // s4
  float v72; // s0
  float v73; // s2
  GxtChar *v74; // r0
  float v75; // s4
  float v76; // s18
  float v77; // s2
  GxtChar *v78; // r0
  int m_nCurrentSelection; // r0
  CSprite2d *p_mSpriteOverlay; // r0
  CRect *p_mDigitalSelection; // r1
  CRGBA v82; // [sp+Ch] [bp-7Ch] BYREF
  CRGBA v83; // [sp+10h] [bp-78h] BYREF
  CRGBA v84; // [sp+14h] [bp-74h] BYREF
  CRGBA v85; // [sp+18h] [bp-70h] BYREF
  CRGBA v86; // [sp+1Ch] [bp-6Ch] BYREF
  CRGBA v87; // [sp+20h] [bp-68h] BYREF
  CRGBA v88; // [sp+24h] [bp-64h] BYREF

  v2 = this->m_Color._anon_0._anon_0.alpha;
  if ( v2 )
  {
    v3 = (float)v2;
    left = this->m_RectScreen.left;
    right = this->m_RectScreen.right;
    v6 = (float)v2 / 255.0;
    alpha = (unsigned int)(float)(v6 * 150.0);
    CRGBA::CRGBA(&v88, 0, 0, 0, alpha);
    CRGBA::CRGBA(&v87, 0, 0, 0, (unsigned int)(float)((float)(v3 / 255.0) * 150.0));
    v8 = (unsigned int)(float)(v6 * 255.0);
    CRGBA::CRGBA(&v86, 0, 0, 0, v8);
    CRGBA::CRGBA(&v85, 0, 0, 0, v8);
    CSprite2d::DrawRectXLU(&this->mTitle, &v88, &v87, &v86, &v85);
    CRGBA::CRGBA(&v88, 0, 0, 0, alpha);
    CRGBA::CRGBA(&v87, 0, 0, 0, alpha);
    CRGBA::CRGBA(&v86, 0, 0, 0, v8);
    CRGBA::CRGBA(&v85, 0, 0, 0, v8);
    CSprite2d::DrawRectXLU(&this->mInfo, &v88, &v87, &v86, &v85);
    CRGBA::CRGBA(&v88, 0, 0, 0, alpha);
    CRGBA::CRGBA(&v87, 0, 0, 0, alpha);
    CRGBA::CRGBA(&v86, 0, 0, 0, v8);
    CRGBA::CRGBA(&v85, 0, 0, 0, v8);
    CSprite2d::DrawRectXLU(&this->mAnalogSelection, &v88, &v87, &v86, &v85);
    CRGBA::CRGBA(&v88, 0, 0, 0, alpha);
    CRGBA::CRGBA(&v87, 0, 0, 0, alpha);
    CRGBA::CRGBA(&v86, 0, 0, 0, v8);
    CRGBA::CRGBA(&v85, 0, 0, 0, v8);
    CSprite2d::DrawRectXLU(&this->mDigitalSelection, &v88, &v87, &v86, &v85);
    CRGBA::CRGBA(&v88, 0, 0, 0, alpha);
    CRGBA::CRGBA(&v87, 0, 0, 0, alpha);
    CRGBA::CRGBA(&v86, 0, 0, 0, v8);
    CRGBA::CRGBA(&v85, 0, 0, 0, v8);
    CSprite2d::DrawRectXLU(&this->mFlickSelection, &v88, &v87, &v86, &v85);
    CFont::SetBackground(0, 0);
    CFont::SetWrapx((float)RsGlobal.screenWidth);
    CFont::SetCentreSize((float)((float)RsGlobal.screenWidth / 640.0) * 640.0);
    CFont::SetProportional(1u);
    CRGBA::CRGBA(&v84, 0xFFu, 0xFFu, 0xFFu, v8);
    CFont::SetColor(v9);
    CRGBA::CRGBA(&v83, 0, 0, 0, v8);
    CFont::SetDropColor(v10);
    CFont::SetEdge(1);
    CFont::SetOrientation(1u);
    CFont::SetFontStyle(0);
    v11 = fabsf(this->mTitle.top - this->mTitle.bottom) * 0.0265;
    CFont::SetScale(v11);
    v12 = fabsf(right - left) * 0.035;
    v13 = fabsf(this->m_RectScreen.right - this->m_RectScreen.left) - (float)(v12 + v12);
    v14 = CText::Get(&TheText, "STR_HEA");
    StringWidth = CFont::GetStringWidth(v14, 1u, 0);
    if ( StringWidth > v13 )
      CFont::SetScale(v11 * (float)(v13 / StringWidth));
    v16 = this->mTitle.left;
    v17 = this->mTitle.top + this->mTitle.bottom;
    v18 = (float)(v17 * 0.5) - (float)(CFont::GetHeight(0) * 0.5);
    v19 = CText::Get(&TheText, "STR_HEA");
    CFont::PrintString(v12 + v16, v18, v19);
    CFont::RenderFontBuffer();
    CFont::SetFontStyle(1u);
    v20 = fabsf(this->mTitle.top - this->mTitle.bottom) * 0.015;
    CFont::SetScale(v20);
    v21 = fabsf(this->m_RectScreen.right - this->m_RectScreen.left) - (float)(v12 + v12);
    v22 = CText::Get(&TheText, "STR_TXT");
    v23 = CFont::GetStringWidth(v22, 1u, 0);
    if ( v23 > v21 )
      CFont::SetScale(v20 * (float)(v21 / v23));
    v24 = this->mInfo.left;
    v25 = this->mInfo.top + this->mInfo.bottom;
    v26 = CFont::GetHeight(0) * 0.5;
    v27 = CText::Get(&TheText, "STR_TXT");
    CFont::PrintString(v12 + v24, (float)(v25 * 0.5) - v26, v27);
    CFont::RenderFontBuffer();
    CFont::SetFontStyle(2u);
    v28 = fabsf(this->mTitle.top - this->mTitle.bottom) * 0.0165;
    CFont::SetScale(v28);
    v29 = fabsf(this->m_RectScreen.right - this->m_RectScreen.left) * 0.62;
    v30 = CText::Get(&TheText, "STR_A");
    v31 = CFont::GetStringWidth(v30, 1u, 0);
    if ( v31 > v29 )
    {
      v28 = v28 * (float)(v29 / v31);
      CFont::SetScale(v28);
    }
    v32 = CText::Get(&TheText, "STR_B");
    v33 = CFont::GetStringWidth(v32, 1u, 0);
    if ( v33 > v29 )
    {
      v28 = v28 * (float)(v29 / v33);
      CFont::SetScale(v28);
    }
    v34 = CText::Get(&TheText, "STR_F");
    v35 = CFont::GetStringWidth(v34, 1u, 0);
    if ( v35 > v29 )
      CFont::SetScale(v28 * (float)(v29 / v35));
    bottom = this->mAnalogSelection.bottom;
    v37 = this->mAnalogSelection.left;
    v38 = fabsf(this->mAnalogSelection.top - bottom);
    v39 = CText::Get(&TheText, "STR_A");
    CFont::PrintString(v12 + v37, bottom + (float)(v38 * 0.1), v39);
    CFont::RenderFontBuffer();
    v40 = this->mDigitalSelection.bottom;
    v41 = this->mDigitalSelection.left;
    v42 = fabsf(this->mDigitalSelection.top - v40);
    v43 = CText::Get(&TheText, "STR_B");
    CFont::PrintString(v12 + v41, v40 + (float)(v42 * 0.1), v43);
    CFont::RenderFontBuffer();
    v44 = this->mFlickSelection.bottom;
    v45 = this->mFlickSelection.left;
    v46 = fabsf(this->mFlickSelection.top - v44);
    v47 = CText::Get(&TheText, "STR_F");
    CFont::PrintString(v12 + v45, v44 + (float)(v46 * 0.1), v47);
    CFont::RenderFontBuffer();
    CFont::SetFontStyle(1u);
    v48 = (float)((float)(fabsf(this->mDigitalSelection.top - this->mDigitalSelection.bottom) * 0.05) * 0.65) * 0.25;
    CFont::SetScale(v48);
    CFont::SetWrapx(this->m_RectScreen.left + (float)(fabsf(this->m_RectScreen.right - this->m_RectScreen.left) * 0.65));
    while ( 1 )
    {
      v49 = this->mDigitalSelection.bottom;
      v50 = this->mDigitalSelection.left;
      v51 = fabsf(this->mDigitalSelection.top - v49);
      v52 = CText::Get(&TheText, "STR_ANA");
      NumberLines = CFont::GetNumberLines(v12 + v50, v49 + (float)(v51 * 0.35), v52);
      Height = CFont::GetHeight(0);
      top = this->mDigitalSelection.top;
      v56 = this->mDigitalSelection.bottom;
      if ( (float)(Height * (float)NumberLines) < (float)(fabsf(top - v56) * 0.575) )
        break;
      v48 = v48 * 0.98;
      CFont::SetScale(v48);
    }
    while ( 1 )
    {
      v57 = this->mDigitalSelection.left;
      v58 = CText::Get(&TheText, "STR_BUT");
      v59 = CFont::GetNumberLines(v12 + v57, v56 + (float)(fabsf(top - v56) * 0.35), v58);
      v60 = CFont::GetHeight(0);
      v61 = this->mDigitalSelection.top;
      v62 = this->mDigitalSelection.bottom;
      if ( (float)(v60 * (float)v59) < (float)(fabsf(v61 - v62) * 0.575) )
        break;
      v48 = v48 * 0.98;
      CFont::SetScale(v48);
      top = this->mDigitalSelection.top;
      v56 = this->mDigitalSelection.bottom;
    }
    while ( 1 )
    {
      v63 = this->mDigitalSelection.left;
      v64 = CText::Get(&TheText, "STR_FLI");
      v65 = CFont::GetNumberLines(v12 + v63, v62 + (float)(fabsf(v61 - v62) * 0.35), v64);
      if ( (float)(CFont::GetHeight(0) * (float)v65) < (float)(fabsf(
                                                                 this->mDigitalSelection.top
                                                               - this->mDigitalSelection.bottom)
                                                             * 0.575) )
        break;
      v48 = v48 * 0.98;
      CFont::SetScale(v48);
      v61 = this->mDigitalSelection.top;
      v62 = this->mDigitalSelection.bottom;
    }
    CRGBA::CRGBA(&v82, 0x80u, 0x80u, 0x80u, v8);
    CFont::SetColor(v66);
    v67 = this->mAnalogSelection.bottom;
    v68 = this->mAnalogSelection.left;
    v69 = fabsf(this->mAnalogSelection.top - v67);
    v70 = CText::Get(&TheText, "STR_ANA");
    CFont::PrintString(v12 + v68, v67 + (float)(v69 * 0.395), v70);
    CFont::RenderFontBuffer();
    v71 = this->mDigitalSelection.bottom;
    v72 = this->mDigitalSelection.left;
    v73 = fabsf(this->mDigitalSelection.top - v71);
    v74 = CText::Get(&TheText, "STR_BUT");
    CFont::PrintString(v12 + v72, v71 + (float)(v73 * 0.395), v74);
    CFont::RenderFontBuffer();
    v75 = this->mFlickSelection.bottom;
    v76 = v12 + this->mFlickSelection.left;
    v77 = fabsf(this->mFlickSelection.top - v75) * 0.395;
    v78 = CText::Get(&TheText, "STR_FLI");
    CFont::PrintString(v76, v75 + v77, v78);
    CFont::RenderFontBuffer();
    CWidgetRegionSteeringSelection::DrawButtons(this);
    m_nCurrentSelection = this->m_nCurrentSelection;
    if ( m_nCurrentSelection )
    {
      if ( m_nCurrentSelection == 1 )
      {
        CRGBA::CRGBA(&v88, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)(v6 * 75.0));
        p_mSpriteOverlay = &this->mSpriteOverlay;
        p_mDigitalSelection = &this->mDigitalSelection;
      }
      else
      {
        if ( m_nCurrentSelection != 2 )
          return;
        CRGBA::CRGBA(&v88, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)(v6 * 75.0));
        p_mSpriteOverlay = &this->mSpriteOverlay;
        p_mDigitalSelection = &this->mFlickSelection;
      }
    }
    else
    {
      CRGBA::CRGBA(&v88, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)(v6 * 75.0));
      p_mSpriteOverlay = &this->mSpriteOverlay;
      p_mDigitalSelection = &this->mAnalogSelection;
    }
    CSprite2d::Draw(p_mSpriteOverlay, p_mDigitalSelection, &v88);
  }
}
// 2C4224: variable 'v9' is possibly undefined
// 2C4238: variable 'v10' is possibly undefined
// 2C4794: variable 'v66' is possibly undefined

//----- (002C4978) --------------------------------------------------------
void __fastcall CWidgetRegionSteeringSelection::DrawButtons(CWidgetRegionSteeringSelection *this)
{
  CWidgetRegionSteeringSelection *v1; // r4
  float right; // s4
  float top; // s2
  float bottom; // s6
  float v5; // s8
  float v6; // s18
  float v7; // s0
  float v8; // s20
  UInt8 alpha; // r10
  float v10; // s4
  float v11; // s0
  float v12; // s4
  float v13; // s20
  float left; // s22
  float v15; // s2
  float v16; // s18
  float v17; // s0
  float v18; // s2
  float v19; // s4
  float v20; // s6
  float v21; // s18
  float v22; // s4
  float v23; // s0
  float v24; // s0
  float v25; // s2
  CRGBA v26; // [sp+4h] [bp-7Ch] BYREF
  CRect v27; // [sp+8h] [bp-78h] BYREF
  CRect v28; // [sp+18h] [bp-68h] BYREF
  CRect v29; // [sp+28h] [bp-58h] BYREF
  CRect Rectangle; // [sp+38h] [bp-48h] BYREF

  v1 = this;
  right = this->mDigitalSelection.right;
  top = this->mDigitalSelection.top;
  bottom = this->mDigitalSelection.bottom;
  v5 = (float)this->m_Color._anon_0._anon_0.alpha;
  v6 = fabsf(right - this->mDigitalSelection.left) * 0.035;
  v7 = (float)(top + bottom) * 0.5;
  v8 = fabsf(top - bottom) * 0.325;
  Rectangle.bottom = v7 - v8;
  Rectangle.right = right - v6;
  Rectangle.top = v8 + v7;
  alpha = (unsigned int)(float)((float)(v5 / 255.0) * 255.0);
  Rectangle.left = (float)(right - v6) - (float)(v8 + v8);
  CRGBA::CRGBA((CRGBA *)&v29, 0xFFu, 0xFFu, 0xFFu, alpha);
  CSprite2d::Draw(&v1->mSpriteRight, &Rectangle, (const CRGBA *)&v29);
  CRGBA::CRGBA((CRGBA *)&v29, 0xFFu, 0xFFu, 0xFFu, alpha);
  CSprite2d::Draw(&v1->mSpriteRight, &Rectangle, (const CRGBA *)&v29);
  v10 = (float)(v1->mDigitalSelection.top + v1->mDigitalSelection.bottom) * 0.5;
  v11 = v1->mDigitalSelection.right + (float)(v6 * -1.5);
  v29.left = v11 + (float)(v8 * -4.0);
  v29.right = v11 - (float)(v8 + v8);
  v29.bottom = v10 - v8;
  v29.top = v8 + v10;
  CRGBA::CRGBA((CRGBA *)&v28, 0xFFu, 0xFFu, 0xFFu, alpha);
  CSprite2d::Draw(&v1->mSpriteLeft, &v29, (const CRGBA *)&v28);
  CRGBA::CRGBA((CRGBA *)&v28, 0xFFu, 0xFFu, 0xFFu, alpha);
  CSprite2d::Draw(&v1->mSpriteLeft, &v29, (const CRGBA *)&v28);
  v12 = v1->mFlickSelection.top + v1->mFlickSelection.bottom;
  v13 = v29.right;
  left = v29.left;
  v15 = (float)(Rectangle.left + Rectangle.right) * 0.5;
  v16 = fabsf(v1->mDigitalSelection.top - v1->mDigitalSelection.bottom) * 0.26;
  Rectangle.right = v15 + v16;
  Rectangle.left = v15 - v16;
  Rectangle.top = v16 + (float)(v12 * 0.5);
  Rectangle.bottom = (float)(v12 * 0.5) - v16;
  CRGBA::CRGBA((CRGBA *)&v28, 0xFFu, 0xFFu, 0xFFu, alpha);
  CSprite2d::DrawRotated(&v1->mSpriteArrow, &Rectangle, 0.0, (const CRGBA *)&v28);
  v17 = (float)(left + v13) * 0.5;
  v18 = (float)(v1->mFlickSelection.top + v1->mFlickSelection.bottom) * 0.5;
  v29.left = v17 - v16;
  v29.right = v16 + v17;
  v29.top = v16 + v18;
  v29.bottom = v18 - v16;
  CRGBA::CRGBA((CRGBA *)&v28, 0xFFu, 0xFFu, 0xFFu, alpha);
  CSprite2d::DrawRotated(&v1->mSpriteArrow, &v29, 3.14, (const CRGBA *)&v28);
  v19 = v1->mAnalogSelection.top;
  v20 = v1->mAnalogSelection.bottom;
  v21 = fabsf(v19 - v20);
  v22 = (float)(v19 + v20) * 0.5;
  v23 = (float)((float)((float)(v29.left + v29.right) * 0.5) + (float)((float)(Rectangle.left + Rectangle.right) * 0.5))
      * 0.5;
  v28.bottom = v22 - (float)(v21 * 0.4125);
  v28.top = (float)(v21 * 0.4125) + v22;
  v28.left = v23 - (float)(v21 * 0.4125);
  v28.right = (float)(v21 * 0.4125) + v23;
  CRGBA::CRGBA((CRGBA *)&v27, 0xFFu, 0xFFu, 0xFFu, alpha);
  CSprite2d::Draw(&v1->mSpriteCircle, &v28, (const CRGBA *)&v27);
  CRGBA::CRGBA((CRGBA *)&v27, 0xFFu, 0xFFu, 0xFFu, alpha);
  CSprite2d::Draw(&v1->mSpriteCircle, &v28, (const CRGBA *)&v27);
  v24 = v28.left + (float)(fabsf(v28.right - v28.left) * 0.35);
  v25 = v28.bottom + (float)(fabsf(v28.top - v28.bottom) * 0.35);
  v27.left = v24 - (float)(v21 * 0.15);
  v27.bottom = v25 - (float)(v21 * 0.15);
  v27.right = (float)(v21 * 0.15) + v24;
  v27.top = (float)(v21 * 0.15) + v25;
  CRGBA::CRGBA(&v26, 0xFFu, 0xFFu, 0xFFu, alpha);
  v1 = (CWidgetRegionSteeringSelection *)((char *)v1 + 204);
  CSprite2d::Draw((CSprite2d *)v1, &v27, &v26);
  CRGBA::CRGBA(&v26, 0xFFu, 0xFFu, 0xFFu, alpha);
  CSprite2d::Draw((CSprite2d *)v1, &v27, &v26);
}

//----- (002C4D18) --------------------------------------------------------
void __fastcall CWidgetRegionSteeringSelection::OnInitialTouch(CWidgetRegionSteeringSelection *this)
{
  int v2; // r0
  CVector2D v3[2]; // [sp+0h] [bp-10h] BYREF

  CTouchInterface::GetTouchPosition(v3, this->m_nTouchIndex);
  if ( v3[0].x >= this->mAnalogSelection.left
    && v3[0].x <= this->mAnalogSelection.right
    && v3[0].y >= this->mAnalogSelection.bottom
    && v3[0].y <= this->mAnalogSelection.top )
  {
    v2 = 0;
  }
  else
  {
    CTouchInterface::GetTouchPosition(v3, this->m_nTouchIndex);
    if ( v3[0].x >= this->mDigitalSelection.left
      && v3[0].x <= this->mDigitalSelection.right
      && v3[0].y >= this->mDigitalSelection.bottom
      && v3[0].y <= this->mDigitalSelection.top )
    {
      v2 = 1;
    }
    else
    {
      CTouchInterface::GetTouchPosition(v3, this->m_nTouchIndex);
      if ( v3[0].x >= this->mFlickSelection.left
        && v3[0].x <= this->mFlickSelection.right
        && v3[0].y >= this->mFlickSelection.bottom
        && v3[0].y <= this->mFlickSelection.top )
      {
        v2 = 2;
      }
      else
      {
        v2 = -1;
      }
    }
  }
  this->m_nInitialSelection = v2;
}

//----- (002C4E10) --------------------------------------------------------
void __fastcall CWidgetRegionSteeringSelection::Update(CWidgetRegionSteeringSelection *this)
{
  float v2; // s0
  float left; // r0
  float right; // r1
  float v5; // s0
  float v6; // s4
  float v7; // s8
  float v8; // s12
  float v9; // s0
  float v10; // s4
  float v11; // s8
  float v12; // s12
  float32x2_t v13; // d1
  int m_nInitialSelection; // r0
  int v15; // r0
  float32x2_t v16; // d0
  float v17; // s0
  float v18; // s0
  CVector2D v19[2]; // [sp+0h] [bp-10h] BYREF

  v13.n64_u32[0] = LODWORD(this->m_RectScreen.bottom);
  v2 = this->m_RectScreen.top - v13.n64_f32[0];
  left = this->m_RectScreen.left;
  right = this->m_RectScreen.right;
  this->mTitle.left = left;
  this->mTitle.right = right;
  this->mInfo.left = left;
  this->mInfo.right = right;
  this->mAnalogSelection.right = right;
  this->mAnalogSelection.left = left;
  this->mDigitalSelection.right = right;
  this->mDigitalSelection.left = left;
  LODWORD(this->mTitle.bottom) = v13.n64_u32[0];
  v5 = fabsf(v2) + -4.0;
  v6 = v5 * 0.175;
  v7 = v5 * 0.1;
  v8 = v5 * 0.275;
  v9 = v5 * 0.225;
  v10 = v13.n64_f32[0] + v6;
  this->mTitle.top = v10;
  v11 = v7 + (float)(v10 + 1.0);
  this->mInfo.bottom = v10 + 1.0;
  this->mInfo.top = v11;
  v12 = v8 + (float)(v11 + 1.0);
  this->mAnalogSelection.bottom = v11 + 1.0;
  this->mAnalogSelection.top = v12;
  v13.n64_f32[1] = v9 + (float)(v12 + 1.0);
  this->mDigitalSelection.bottom = v12 + 1.0;
  LODWORD(this->mDigitalSelection.top) = v13.n64_u32[1];
  this->mFlickSelection.right = right;
  this->mFlickSelection.left = left;
  this->mFlickSelection.bottom = v13.n64_f32[1] + 1.0;
  this->mFlickSelection.top = v9 + (float)(v13.n64_f32[1] + 1.0);
  CWidget::ManageAlpha(this);
  CWidgetRegion::Update(this);
  if ( !this->m_bEnabled )
    return;
  if ( this == CWidget::m_pInitialTouchWidget[this->m_nTouchIndex] )
  {
    if ( (*((int (__fastcall **)(CWidgetRegionSteeringSelection *, _DWORD))this->_vptr$CWidget + 20))(this, 0) != 1 )
    {
      if ( (*((int (__fastcall **)(CWidgetRegionSteeringSelection *, _DWORD))this->_vptr$CWidget + 13))(this, 0) )
        goto LABEL_26;
      goto LABEL_24;
    }
    m_nInitialSelection = this->m_nInitialSelection;
    if ( m_nInitialSelection )
    {
      if ( m_nInitialSelection != 1 )
        goto LABEL_6;
    }
    else
    {
      CTouchInterface::GetTouchPosition(v19, this->m_nTouchIndex);
      if ( v19[0].x >= this->mAnalogSelection.left
        && v19[0].x <= this->mAnalogSelection.right
        && v19[0].y >= this->mAnalogSelection.bottom
        && v19[0].y <= this->mAnalogSelection.top )
      {
        v15 = 0;
        goto LABEL_25;
      }
      m_nInitialSelection = this->m_nInitialSelection;
      if ( m_nInitialSelection != 1 )
      {
LABEL_6:
        if ( m_nInitialSelection != 2 )
          goto LABEL_24;
        goto LABEL_20;
      }
    }
    CTouchInterface::GetTouchPosition(v19, this->m_nTouchIndex);
    if ( v19[0].x >= this->mDigitalSelection.left
      && v19[0].x <= this->mDigitalSelection.right
      && v19[0].y >= this->mDigitalSelection.bottom
      && v19[0].y <= this->mDigitalSelection.top )
    {
      v15 = 1;
      goto LABEL_25;
    }
    if ( this->m_nInitialSelection != 2 )
    {
LABEL_24:
      v15 = -1;
LABEL_25:
      this->m_nCurrentSelection = v15;
      goto LABEL_26;
    }
LABEL_20:
    CTouchInterface::GetTouchPosition(v19, this->m_nTouchIndex);
    if ( v19[0].x >= this->mFlickSelection.left
      && v19[0].x <= this->mFlickSelection.right
      && v19[0].y >= this->mFlickSelection.bottom
      && v19[0].y <= this->mFlickSelection.top )
    {
      v15 = 2;
      goto LABEL_25;
    }
    goto LABEL_24;
  }
LABEL_26:
  if ( CHID::Implements(HID_MAPPING_MENU_UP)
    || CHID::Implements(HID_MAPPING_MENU_DOWN)
    || CHID::Implements(HID_MAPPING_PED_MOVE_Y) )
  {
    if ( CHID::Replaces(HID_MAPPING_MENU_UP)
      || CHID::Replaces(HID_MAPPING_MENU_DOWN)
      || CHID::Replaces(HID_MAPPING_PED_MOVE_Y) )
    {
      v13.n64_u32[0] = 0;
      v16.n64_f32[0] = (float)this->m_nCurrentSelection;
      v16.n64_f32[1] = v12 + 1.0;
      this->m_nCurrentSelection = (int)vmax_f32(v16, v13).n64_f32[0];
    }
    if ( CHID::IsReleased(HID_MAPPING_MENU_UP)
      || OS_TimeAccurate() - CWidgetRegionSteeringSelection::Update(void)::fLastAnalogtime > 0.25
      && CHID::IsPressedNegative(HID_MAPPING_PED_MOVE_Y) )
    {
      --this->m_nCurrentSelection;
      v17 = OS_TimeAccurate();
      CWidgetRegionSteeringSelection::Update(void)::fLastAnalogtime = v17;
      if ( this->m_nCurrentSelection <= -1 )
        this->m_nCurrentSelection = 2;
    }
    if ( CHID::IsReleased(HID_MAPPING_MENU_DOWN)
      || OS_TimeAccurate() - CWidgetRegionSteeringSelection::Update(void)::fLastAnalogtime > 0.25
      && CHID::IsPressedPositive(HID_MAPPING_PED_MOVE_Y) )
    {
      ++this->m_nCurrentSelection;
      v18 = OS_TimeAccurate();
      CWidgetRegionSteeringSelection::Update(void)::fLastAnalogtime = v18;
      if ( this->m_nCurrentSelection >= 3 )
        this->m_nCurrentSelection = 0;
    }
  }
}

//----- (002C5168) --------------------------------------------------------
bool __fastcall CWidgetRegionSteeringSelection::IsReleased(CWidgetRegionSteeringSelection *this, CVector2D *pVecOut)
{
  if ( LIB_KeyboardState(KK_ESCAPE) == OSPS_ButtonReleased )
    this->m_nCurrentSelection = 0;
  return CWidget::IsReleased(this, pVecOut)
      || CHID::Implements(HID_MAPPING_ACCEPT) && CHID::IsReleased(HID_MAPPING_ACCEPT);
}

//----- (002C51B0) --------------------------------------------------------
void __fastcall CWidgetRegionSteeringSelection::~CWidgetRegionSteeringSelection(CWidgetRegionSteeringSelection *this)
{
  CSprite2d *p_mSpriteOverlay; // r5

  this->_vptr$CWidget = (int (**)(void))&off_664D1C;
  p_mSpriteOverlay = &this->mSpriteOverlay;
  CSprite2d::~CSprite2d(&this->mSpriteArrow);
  CSprite2d::~CSprite2d(&this->mSpriteRight);
  CSprite2d::~CSprite2d(&this->mSpriteLeft);
  CSprite2d::~CSprite2d(&this->mSpriteCircle);
  CSprite2d::~CSprite2d(&this->mSpriteNub);
  CSprite2d::~CSprite2d(p_mSpriteOverlay);
  sub_19C514(this);
}
// 664D1C: using guessed type void *off_664D1C;

//----- (002C5200) --------------------------------------------------------
void __fastcall CWidgetRegionSteeringSelection::~CWidgetRegionSteeringSelection(CWidgetRegionSteeringSelection *this)
{
  CSprite2d *p_mSpriteOverlay; // r5
  void *v3; // r0

  this->_vptr$CWidget = (int (**)(void))&off_664D1C;
  p_mSpriteOverlay = &this->mSpriteOverlay;
  CSprite2d::~CSprite2d(&this->mSpriteArrow);
  CSprite2d::~CSprite2d(&this->mSpriteRight);
  CSprite2d::~CSprite2d(&this->mSpriteLeft);
  CSprite2d::~CSprite2d(&this->mSpriteCircle);
  CSprite2d::~CSprite2d(&this->mSpriteNub);
  CSprite2d::~CSprite2d(p_mSpriteOverlay);
  CWidget::~CWidget(this);
  sub_191374(v3);
}
// 2C524C: variable 'v3' is possibly undefined
// 664D1C: using guessed type void *off_664D1C;

//----- (002C5254) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetRegionSteeringSelection::GetName(CWidgetRegionSteeringSelection *this)
{
  return "Steering Selection";
}

//----- (002C526C) --------------------------------------------------------
void __fastcall CWidgetRegionSwipeRadio::CWidgetRegionSwipeRadio(
        CWidgetRegionSwipeRadio *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  _DWORD *v3; // r0

  CWidgetRegion::CWidgetRegion(this, pszSprite, WidgetPos, 0, HID_MAPPING_UNKNOWN);
  *v3 = &off_664DB0;
}
// 2C5284: variable 'v3' is possibly undefined
// 664DB0: using guessed type void *;

//----- (002C5290) --------------------------------------------------------
bool __fastcall CWidgetRegionSwipeRadio::IsSwipedLeft(CWidgetRegionSwipeRadio *this)
{
  if ( CHID::Replaces(HID_MAPPING_RADIO_PREV_STATION) )
    return sub_18DF74(HID_MAPPING_RADIO_PREV_STATION);
  if ( CHID::Implements(HID_MAPPING_RADIO_PREV_STATION) && CHID::IsReleased(HID_MAPPING_RADIO_PREV_STATION) )
    return 1;
  return sub_19F50C(this);
}

//----- (002C52CC) --------------------------------------------------------
bool __fastcall CWidgetRegionSwipeRadio::IsSwipedRight(CWidgetRegionSwipeRadio *this)
{
  if ( CHID::Replaces(HID_MAPPING_RADIO_NEXT_STATION) )
    return sub_18DF74(HID_MAPPING_RADIO_NEXT_STATION);
  if ( CHID::Implements(HID_MAPPING_RADIO_NEXT_STATION) && CHID::IsReleased(HID_MAPPING_RADIO_NEXT_STATION) )
    return 1;
  return sub_198F7C(this);
}

//----- (002C5308) --------------------------------------------------------
void __fastcall CWidgetRegionSwipeRadio::DrawHelpIcon(
        CWidgetRegionSwipeRadio *this,
        const unsigned __int8 *pszCharacters,
        float fX,
        float fY,
        float fHeight,
        int nAlpha)
{
  HIDMapping v9; // r1

  if ( strstr((const char *)pszCharacters, "widget_swipe_radio_up") )
    v9 = HID_MAPPING_RADIO_PREV_STATION;
  else
    v9 = HID_MAPPING_RADIO_NEXT_STATION;
  CHID::DrawHelpIcon(pszCharacters, v9, fX, fY, fHeight, nAlpha, 0);
}

//----- (002C5364) --------------------------------------------------------
void __fastcall CWidgetRegionSwipeRadio::~CWidgetRegionSwipeRadio(CWidgetRegionSwipeRadio *this)
{
  void *v1; // r0

  CWidget::~CWidget(this);
  sub_191374(v1);
}
// 2C5370: variable 'v1' is possibly undefined

//----- (002C5374) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetRegionSwipeRadio::GetName(CWidgetRegionSwipeRadio *this)
{
  return "Radio";
}

//----- (002C5380) --------------------------------------------------------
void __fastcall CWidgetRegionTouchLayoutSelection::CWidgetRegionTouchLayoutSelection(
        CWidgetRegionTouchLayoutSelection *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  float bottom; // s2
  float v5; // s0
  float left; // r0
  float right; // r1
  float v8; // s0
  float v9; // s6
  float v10; // s4

  CWidgetRegion::CWidgetRegion(this, pszSprite, WidgetPos, 0, HID_MAPPING_UNKNOWN);
  *(_QWORD *)&this->mTitle.left = 0xC974240049742400LL;
  *(_QWORD *)&this->mTitle.right = 0x49742400C9742400LL;
  this->_vptr$CWidget = (int (**)(void))&off_664E44;
  CSprite2d::CSprite2d(&this->mSpriteOverlay);
  *(_QWORD *)&this->mClassicSelection.left = 0xC974240049742400LL;
  *(_QWORD *)&this->mClassicSelection.right = 0x49742400C9742400LL;
  CSprite2d::CSprite2d(&this->mSpriteCrouch);
  CSprite2d::CSprite2d(&this->mSpriteSprint);
  CSprite2d::CSprite2d(&this->mSpriteSprintRim);
  *(_QWORD *)&this->mAdvancedSelection.left = 0xC974240049742400LL;
  *(_QWORD *)&this->mAdvancedSelection.right = 0x49742400C9742400LL;
  CSprite2d::CSprite2d(&this->mSpriteRunningMan);
  CSprite2d::CSprite2d(&this->mSpriteRunningManBack);
  CSprite2d::CSprite2d(&this->mSpriteAttack);
  this->m_fFadeRate = 1024.0;
  CWidget::SetTexture(this, &this->mSpriteOverlay, "white", 1);
  this->m_nCurrentSelection = -1;
  this->m_nInitialSelection = -1;
  CWidget::SetTexture(this, &this->mSpriteAttack, "punch", 1);
  CWidget::SetTexture(this, &this->mSpriteCrouch, "hud_crouch", 1);
  CWidget::SetTexture(this, &this->mSpriteSprint, "sprint", 1);
  CWidget::SetTexture(this, &this->mSpriteSprintRim, "hud_circle", 1);
  CWidget::SetTexture(this, &this->mSpriteRunningMan, "sprint", 1);
  CWidget::SetTexture(this, &this->mSpriteRunningManBack, "CornerGradient", 1);
  bottom = this->m_RectScreen.bottom;
  v5 = this->m_RectScreen.top - bottom;
  left = this->m_RectScreen.left;
  right = this->m_RectScreen.right;
  this->mTitle.left = left;
  this->mTitle.right = right;
  this->mClassicSelection.right = right;
  this->mClassicSelection.left = left;
  v8 = fabsf(v5);
  v9 = bottom + (float)(v8 * 0.15);
  v10 = bottom + (float)(v8 * 0.5625);
  this->mTitle.top = v9;
  this->mTitle.bottom = bottom + (float)(v8 * 0.0);
  this->mClassicSelection.top = v10;
  this->mClassicSelection.bottom = v9;
  this->mAdvancedSelection.right = right;
  this->mAdvancedSelection.top = bottom + v8;
  this->mAdvancedSelection.bottom = v10;
  this->mAdvancedSelection.left = left;
}
// 664E44: using guessed type void *;

//----- (002C554C) --------------------------------------------------------
void __fastcall CWidgetRegionTouchLayoutSelection::BuildRects(CWidgetRegionTouchLayoutSelection *this)
{
  float bottom; // s2
  float v2; // s0
  float left; // r1
  float right; // r2
  float v5; // s0
  float v6; // s6
  float v7; // s4

  bottom = this->m_RectScreen.bottom;
  v2 = this->m_RectScreen.top - bottom;
  left = this->m_RectScreen.left;
  right = this->m_RectScreen.right;
  this->mTitle.left = left;
  this->mTitle.right = right;
  this->mClassicSelection.right = right;
  this->mClassicSelection.left = left;
  v5 = fabsf(v2);
  v6 = bottom + (float)(v5 * 0.15);
  v7 = bottom + (float)(v5 * 0.5625);
  this->mTitle.top = v6;
  this->mTitle.bottom = bottom + (float)(v5 * 0.0);
  this->mClassicSelection.top = v7;
  this->mClassicSelection.bottom = v6;
  this->mAdvancedSelection.right = right;
  this->mAdvancedSelection.top = bottom + v5;
  this->mAdvancedSelection.bottom = v7;
  this->mAdvancedSelection.left = left;
}

//----- (002C55C4) --------------------------------------------------------
void __fastcall CWidgetRegionTouchLayoutSelection::Draw(CWidgetRegionTouchLayoutSelection *this)
{
  unsigned int v2; // r0
  float v3; // s0
  float v4; // s16
  unsigned int alpha; // r5
  CRGBA v6; // r0
  CRGBA v7; // r0
  float v8; // s18
  float v9; // s20
  GxtChar *v10; // r0
  float StringWidth; // r0
  GxtChar *v12; // r0
  float v13; // r0
  GxtChar *v14; // r0
  float v15; // r0
  float left; // s18
  float right; // s20
  float v18; // s24
  float v19; // s0
  GxtChar *v20; // r0
  float v21; // s0
  float bottom; // s6
  float v23; // s2
  float v24; // s4
  GxtChar *v25; // r0
  float v26; // s0
  float v27; // s6
  float v28; // s2
  float v29; // s4
  GxtChar *v30; // r0
  float v31; // s20
  float v32; // s22
  GxtChar *v33; // r0
  float v34; // r0
  GxtChar *v35; // r0
  float v36; // r0
  float v37; // s0
  float v38; // s6
  float v39; // s2
  float v40; // s4
  GxtChar *v41; // r0
  float v42; // s0
  float v43; // s6
  float v44; // s2
  float v45; // s4
  GxtChar *v46; // r0
  int m_nCurrentSelection; // r0
  CSprite2d *p_mSpriteOverlay; // r0
  CRect *p_mAdvancedSelection; // r1
  CRGBA v50; // [sp+8h] [bp-60h] BYREF
  CRGBA v51; // [sp+Ch] [bp-5Ch] BYREF
  CRGBA v52; // [sp+10h] [bp-58h] BYREF
  CRGBA v53; // [sp+14h] [bp-54h] BYREF
  CRGBA v54; // [sp+18h] [bp-50h] BYREF
  CRGBA v55; // [sp+1Ch] [bp-4Ch] BYREF

  v2 = this->m_Color._anon_0._anon_0.alpha;
  if ( v2 )
  {
    v3 = (float)v2;
    v4 = (float)v2 / 255.0;
    alpha = (unsigned int)(float)(v4 * 150.0);
    CRGBA::CRGBA(&v55, 0, 0, 0, alpha);
    CRGBA::CRGBA(&v54, 0, 0, 0, (unsigned int)(float)((float)(v3 / 255.0) * 150.0));
    CRGBA::CRGBA(&v53, 0, 0, 0, (unsigned int)(float)(v4 * 255.0));
    CRGBA::CRGBA(&v52, 0, 0, 0, (unsigned int)(float)(v4 * 255.0));
    CSprite2d::DrawRectXLU(&this->mTitle, &v55, &v54, &v53, &v52);
    CRGBA::CRGBA(&v55, 0, 0, 0, alpha);
    CRGBA::CRGBA(&v54, 0, 0, 0, alpha);
    CRGBA::CRGBA(&v53, 0, 0, 0, (unsigned int)(float)(v4 * 255.0));
    CRGBA::CRGBA(&v52, 0, 0, 0, (unsigned int)(float)(v4 * 255.0));
    CSprite2d::DrawRectXLU(&this->mClassicSelection, &v55, &v54, &v53, &v52);
    CRGBA::CRGBA(&v55, 0, 0, 0, alpha);
    CRGBA::CRGBA(&v54, 0, 0, 0, alpha);
    CRGBA::CRGBA(&v53, 0, 0, 0, (unsigned int)(float)(v4 * 255.0));
    CRGBA::CRGBA(&v52, 0, 0, 0, (unsigned int)(float)(v4 * 255.0));
    CSprite2d::DrawRectXLU(&this->mAdvancedSelection, &v55, &v54, &v53, &v52);
    CFont::SetBackground(0, 0);
    CFont::SetWrapx((float)RsGlobal.screenWidth);
    CFont::SetCentreSize((float)((float)RsGlobal.screenWidth / 640.0) * 640.0);
    CFont::SetProportional(1u);
    CRGBA::CRGBA(&v51, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)(v4 * 255.0));
    CFont::SetColor(v6);
    CRGBA::CRGBA(&v50, 0, 0, 0, (unsigned int)(float)(v4 * 255.0));
    CFont::SetDropColor(v7);
    CFont::SetEdge(1);
    CFont::SetFontStyle(3u);
    v8 = fabsf(this->mTitle.top - this->mTitle.bottom) * 0.02125;
    CFont::SetScale(v8);
    v9 = fabsf(this->m_RectScreen.right - this->m_RectScreen.left) * 0.66;
    v10 = CText::Get(&TheText, "TOU_HEA");
    StringWidth = CFont::GetStringWidth(v10, 1u, 0);
    if ( StringWidth > v9 )
    {
      v8 = v8 * (float)(v9 / StringWidth);
      CFont::SetScale(v8);
    }
    v12 = CText::Get(&TheText, "TOU_C");
    v13 = CFont::GetStringWidth(v12, 1u, 0);
    if ( v13 > v9 )
    {
      v8 = v8 * (float)(v9 / v13);
      CFont::SetScale(v8);
    }
    v14 = CText::Get(&TheText, "TOU_A");
    v15 = CFont::GetStringWidth(v14, 1u, 0);
    if ( v15 > v9 )
      CFont::SetScale(v8 * (float)(v9 / v15));
    CFont::SetOrientation(0);
    left = this->mTitle.left;
    right = this->mTitle.right;
    v18 = this->mTitle.top + this->mTitle.bottom;
    v19 = CFont::GetHeight(0) * 0.5;
    v20 = CText::Get(&TheText, "TOU_HEA");
    CFont::PrintString((float)(left + right) * 0.5, (float)(v18 * 0.5) - v19, v20);
    CFont::RenderFontBuffer();
    CFont::SetOrientation(1u);
    v21 = this->mClassicSelection.left;
    bottom = this->mClassicSelection.bottom;
    v23 = fabsf(this->mClassicSelection.top - bottom);
    v24 = fabsf(this->mClassicSelection.right - v21) * 0.05;
    v25 = CText::Get(&TheText, "TOU_C");
    CFont::PrintString(v21 + v24, bottom + (float)(v23 * 0.1), v25);
    CFont::RenderFontBuffer();
    v26 = this->mAdvancedSelection.left;
    v27 = this->mAdvancedSelection.bottom;
    v28 = fabsf(this->mAdvancedSelection.top - v27);
    v29 = fabsf(this->mAdvancedSelection.right - v26) * 0.05;
    v30 = CText::Get(&TheText, "TOU_A");
    CFont::PrintString(v26 + v29, v27 + (float)(v28 * 0.1), v30);
    CFont::RenderFontBuffer();
    CFont::SetFontStyle(1u);
    v31 = fabsf(this->mTitle.top - this->mTitle.bottom) * 0.019;
    CFont::SetScale(v31);
    v32 = (float)(fabsf(this->m_RectScreen.right - this->m_RectScreen.left) * 0.625) * 3.0;
    v33 = CText::Get(&TheText, "TOU_CLA");
    v34 = CFont::GetStringWidth(v33, 1u, 0);
    if ( v34 > v32 )
    {
      v31 = v31 * (float)(v32 / v34);
      CFont::SetScale(v31);
    }
    v35 = CText::Get(&TheText, "TOU_ADV");
    v36 = CFont::GetStringWidth(v35, 1u, 0);
    if ( v36 > v32 )
      CFont::SetScale(v31 * (float)(v32 / v36));
    CFont::SetWrapx(this->m_RectScreen.left + (float)(fabsf(this->m_RectScreen.right - this->m_RectScreen.left) * 0.675));
    v37 = this->mClassicSelection.left;
    v38 = this->mClassicSelection.bottom;
    v39 = fabsf(this->mClassicSelection.top - v38);
    v40 = fabsf(this->mClassicSelection.right - v37) * 0.05;
    v41 = CText::Get(&TheText, "TOU_CLA");
    CFont::PrintString(v37 + v40, v38 + (float)(v39 * 0.35), v41);
    CFont::RenderFontBuffer();
    v42 = this->mAdvancedSelection.left;
    v43 = this->mAdvancedSelection.bottom;
    v44 = fabsf(this->mAdvancedSelection.top - v43);
    v45 = fabsf(this->mAdvancedSelection.right - v42) * 0.05;
    v46 = CText::Get(&TheText, "TOU_ADV");
    CFont::PrintString(v42 + v45, v43 + (float)(v44 * 0.35), v46);
    CFont::RenderFontBuffer();
    CWidgetRegionTouchLayoutSelection::DrawClassicButtons(this);
    CWidgetRegionTouchLayoutSelection::DrawAdaptedButtons(this);
    m_nCurrentSelection = this->m_nCurrentSelection;
    if ( m_nCurrentSelection == 1 )
    {
      CRGBA::CRGBA(&v55, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)(v4 * 75.0));
      p_mSpriteOverlay = &this->mSpriteOverlay;
      p_mAdvancedSelection = &this->mAdvancedSelection;
    }
    else
    {
      if ( m_nCurrentSelection )
        return;
      CRGBA::CRGBA(&v55, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)(v4 * 75.0));
      p_mSpriteOverlay = &this->mSpriteOverlay;
      p_mAdvancedSelection = &this->mClassicSelection;
    }
    CSprite2d::Draw(p_mSpriteOverlay, p_mAdvancedSelection, &v55);
  }
}
// 2C5772: variable 'v6' is possibly undefined
// 2C5786: variable 'v7' is possibly undefined

//----- (002C5BB8) --------------------------------------------------------
void __fastcall CWidgetRegionTouchLayoutSelection::DrawClassicButtons(CWidgetRegionTouchLayoutSelection *this)
{
  CWidgetRegionTouchLayoutSelection *v1; // r4
  float bottom; // s2
  float v3; // s4
  float v4; // s0
  float v5; // s16
  float v6; // s18
  float v7; // s2
  unsigned int alpha; // r9
  float v9; // s2
  float v10; // s0
  float v11; // s4
  float v12; // s0
  float v13; // s0
  CRGBA v14; // [sp+4h] [bp-6Ch] BYREF
  CRect v15; // [sp+8h] [bp-68h] BYREF
  CRect v16; // [sp+18h] [bp-58h] BYREF
  CRect Rectangle; // [sp+28h] [bp-48h] BYREF

  v1 = this;
  bottom = this->mClassicSelection.bottom;
  v3 = (float)this->m_Color._anon_0._anon_0.alpha;
  v4 = fabsf(this->mClassicSelection.top - bottom);
  v5 = v4 * 0.2125;
  v6 = v4 * 0.04;
  v7 = bottom + (float)(v4 * 0.275);
  Rectangle.right = this->mClassicSelection.right - (float)(v4 * 0.04);
  alpha = (unsigned int)(float)((float)(v3 / 255.0) * 255.0);
  Rectangle.bottom = v7 - (float)(v4 * 0.2125);
  Rectangle.left = Rectangle.right - (float)(v5 + v5);
  Rectangle.top = (float)(v4 * 0.2125) + v7;
  CRGBA::CRGBA((CRGBA *)&v16, 0xFFu, 0xFFu, 0xFFu, alpha);
  CSprite2d::Draw(&v1->mSpriteCrouch, &Rectangle, (const CRGBA *)&v16);
  CRGBA::CRGBA((CRGBA *)&v16, 0xFFu, 0xFFu, 0xFFu, alpha);
  CSprite2d::Draw(&v1->mSpriteCrouch, &Rectangle, (const CRGBA *)&v16);
  v9 = v1->mClassicSelection.right - (float)(v6 + v6);
  v10 = v1->mClassicSelection.bottom + (float)(fabsf(v1->mClassicSelection.top - v1->mClassicSelection.bottom) * 0.275);
  v16.left = v9 + (float)(v5 * -4.0);
  v16.right = v9 - (float)(v5 + v5);
  v16.bottom = v10 - v5;
  v16.top = v5 + v10;
  CRGBA::CRGBA((CRGBA *)&v15, 0xFFu, 0xFFu, 0xFFu, alpha);
  CSprite2d::Draw(&v1->mSpriteAttack, &v16, (const CRGBA *)&v15);
  CRGBA::CRGBA((CRGBA *)&v15, 0xFFu, 0xFFu, 0xFFu, alpha);
  CSprite2d::Draw(&v1->mSpriteAttack, &v16, (const CRGBA *)&v15);
  v11 = v1->mClassicSelection.bottom;
  v12 = fabsf(v1->mClassicSelection.top - v11);
  v15.right = v1->mClassicSelection.right - v6;
  v13 = v11 + (float)(v12 * 0.75);
  v15.left = v15.right - (float)(v5 + v5);
  v15.bottom = v13 - v5;
  v15.top = v5 + v13;
  CRGBA::CRGBA(&v14, 0xFFu, 0xFFu, 0xFFu, alpha);
  CSprite2d::Draw(&v1->mSpriteSprintRim, &v15, &v14);
  CRGBA::CRGBA(&v14, 0xFFu, 0xFFu, 0xFFu, alpha);
  CSprite2d::Draw(&v1->mSpriteSprintRim, &v15, &v14);
  CRGBA::CRGBA(&v14, 0xFFu, 0xFFu, 0xFFu, alpha);
  v1 = (CWidgetRegionTouchLayoutSelection *)((char *)v1 + 192);
  CSprite2d::Draw((CSprite2d *)v1, &v15, &v14);
  CRGBA::CRGBA(&v14, 0xFFu, 0xFFu, 0xFFu, alpha);
  CSprite2d::Draw((CSprite2d *)v1, &v15, &v14);
}

//----- (002C5DE0) --------------------------------------------------------
void __fastcall CWidgetRegionTouchLayoutSelection::DrawAdaptedButtons(CWidgetRegionTouchLayoutSelection *this)
{
  float bottom; // s2
  float v3; // s0
  float v4; // s16
  float v5; // s18
  float v6; // s20
  float v7; // s2
  float v8; // s0
  unsigned int alpha; // r5
  float v10; // s4
  float v11; // s0
  float v12; // s0
  float top; // s0
  float v14; // s4
  float v15; // s4
  CRGBA v16; // [sp+4h] [bp-6Ch] BYREF
  CRect v17; // [sp+8h] [bp-68h] BYREF
  CRect v18; // [sp+18h] [bp-58h] BYREF
  CRect Rectangle; // [sp+28h] [bp-48h] BYREF

  bottom = this->mAdvancedSelection.bottom;
  v3 = fabsf(this->mAdvancedSelection.top - bottom);
  v4 = (float)this->m_Color._anon_0._anon_0.alpha / 255.0;
  v5 = v3 * 0.04;
  v6 = v3 * 0.2125;
  v7 = bottom + (float)(v3 * 0.275);
  v8 = this->mAdvancedSelection.right + (float)((float)(v3 * 0.04) * -2.0);
  Rectangle.bottom = v7 - v6;
  Rectangle.top = v6 + v7;
  Rectangle.left = v8 + (float)(v6 * -4.0);
  Rectangle.right = v8 - (float)(v6 + v6);
  alpha = (unsigned int)(float)(v4 * 255.0);
  CRGBA::CRGBA((CRGBA *)&v18, 0xFFu, 0xFFu, 0xFFu, alpha);
  CSprite2d::Draw(&this->mSpriteAttack, &Rectangle, (const CRGBA *)&v18);
  CRGBA::CRGBA((CRGBA *)&v18, 0xFFu, 0xFFu, 0xFFu, alpha);
  CSprite2d::Draw(&this->mSpriteAttack, &Rectangle, (const CRGBA *)&v18);
  v10 = this->mAdvancedSelection.bottom;
  v11 = fabsf(this->mAdvancedSelection.top - v10);
  v18.right = this->mAdvancedSelection.right - v5;
  v12 = v10 + (float)(v11 * 0.75);
  v18.left = v18.right - (float)((float)(v6 * 1.5) + (float)(v6 * 1.5));
  v18.bottom = v12 - (float)(v6 * 1.5);
  v18.top = (float)(v6 * 1.5) + v12;
  CRGBA::CRGBA((CRGBA *)&v17, 0xFFu, 0xFFu, 0xFFu, alpha);
  CSprite2d::Draw(&this->mSpriteRunningMan, &v18, (const CRGBA *)&v17);
  CRGBA::CRGBA((CRGBA *)&v17, 0xFFu, 0xFFu, 0xFFu, alpha);
  CSprite2d::Draw(&this->mSpriteRunningMan, &v18, (const CRGBA *)&v17);
  top = this->mAdvancedSelection.top;
  v14 = top - this->mAdvancedSelection.bottom;
  v17.right = this->mAdvancedSelection.right;
  v17.top = top;
  v15 = fabsf(v14) * 0.75;
  v17.bottom = top - v15;
  v17.left = v17.right - v15;
  CRGBA::CRGBA(&v16, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)(v4 * 100.0));
  CSprite2d::Draw(&this->mSpriteRunningManBack, &v17, &v16);
}

//----- (002C5FC0) --------------------------------------------------------
void __fastcall CWidgetRegionTouchLayoutSelection::OnInitialTouch(CWidgetRegionTouchLayoutSelection *this)
{
  int v2; // r0
  CVector2D v3[2]; // [sp+0h] [bp-10h] BYREF

  CTouchInterface::GetTouchPosition(v3, this->m_nTouchIndex);
  if ( v3[0].x >= this->mClassicSelection.left
    && v3[0].x <= this->mClassicSelection.right
    && v3[0].y >= this->mClassicSelection.bottom
    && v3[0].y <= this->mClassicSelection.top )
  {
    v2 = 0;
  }
  else
  {
    CTouchInterface::GetTouchPosition(v3, this->m_nTouchIndex);
    if ( v3[0].x >= this->mAdvancedSelection.left
      && v3[0].x <= this->mAdvancedSelection.right
      && v3[0].y >= this->mAdvancedSelection.bottom
      && v3[0].y <= this->mAdvancedSelection.top )
    {
      v2 = 1;
    }
    else
    {
      v2 = -1;
    }
  }
  this->m_nInitialSelection = v2;
}

//----- (002C606C) --------------------------------------------------------
void __fastcall CWidgetRegionTouchLayoutSelection::Update(CWidgetRegionTouchLayoutSelection *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d8
  float bottom; // s2
  float v5; // s0
  float right; // r0
  float left; // r1
  float v8; // s0
  float v9; // s6
  float v10; // s8
  float v11; // s4
  float v12; // s0
  float v13; // s6
  float v14; // s8
  float v15; // s2
  int m_nInitialSelection; // r0
  int v17; // r0
  float v18; // s0
  float v19; // s0
  CVector2D v20[3]; // [sp+0h] [bp-18h] BYREF

  bottom = this->m_RectScreen.bottom;
  v5 = this->m_RectScreen.top - bottom;
  v2.n64_u32[0] = 0;
  right = this->m_RectScreen.right;
  left = this->m_RectScreen.left;
  this->mTitle.left = left;
  this->mTitle.right = right;
  this->mClassicSelection.left = left;
  this->mClassicSelection.right = right;
  v8 = fabsf(v5);
  this->mAdvancedSelection.right = right;
  this->mAdvancedSelection.left = left;
  v9 = v8 * 0.15;
  v10 = v8 * 0.0;
  v11 = v8 * 0.5625;
  v12 = bottom + v8;
  v13 = bottom + v9;
  v14 = bottom + v10;
  v15 = bottom + v11;
  this->mAdvancedSelection.top = v12;
  this->mTitle.top = v13;
  this->mTitle.bottom = v14;
  this->mClassicSelection.top = v15;
  this->mClassicSelection.bottom = v13;
  this->mAdvancedSelection.bottom = v15;
  CWidget::ManageAlpha(this);
  CWidgetRegion::Update(this);
  if ( !this->m_bEnabled )
    return;
  if ( this == CWidget::m_pInitialTouchWidget[this->m_nTouchIndex] )
  {
    if ( (*((int (__fastcall **)(CWidgetRegionTouchLayoutSelection *, _DWORD))this->_vptr$CWidget + 20))(this, 0) != 1 )
    {
      if ( (*((int (__fastcall **)(CWidgetRegionTouchLayoutSelection *, _DWORD))this->_vptr$CWidget + 13))(this, 0) )
        goto LABEL_20;
      goto LABEL_18;
    }
    m_nInitialSelection = this->m_nInitialSelection;
    if ( m_nInitialSelection )
    {
      if ( m_nInitialSelection != 1 )
        goto LABEL_18;
    }
    else
    {
      CTouchInterface::GetTouchPosition(v20, this->m_nTouchIndex);
      if ( v20[0].x >= this->mClassicSelection.left
        && v20[0].x <= this->mClassicSelection.right
        && v20[0].y >= this->mClassicSelection.bottom
        && v20[0].y <= this->mClassicSelection.top )
      {
        v17 = 0;
        goto LABEL_19;
      }
      if ( this->m_nInitialSelection != 1 )
        goto LABEL_18;
    }
    CTouchInterface::GetTouchPosition(v20, this->m_nTouchIndex);
    if ( v20[0].x >= this->mAdvancedSelection.left
      && v20[0].x <= this->mAdvancedSelection.right
      && v20[0].y >= this->mAdvancedSelection.bottom
      && v20[0].y <= this->mAdvancedSelection.top )
    {
      v17 = 1;
      goto LABEL_19;
    }
LABEL_18:
    v17 = -1;
LABEL_19:
    this->m_nCurrentSelection = v17;
  }
LABEL_20:
  if ( CHID::Implements(HID_MAPPING_MENU_UP)
    || CHID::Implements(HID_MAPPING_MENU_DOWN)
    || CHID::Implements(HID_MAPPING_PED_MOVE_Y) )
  {
    if ( CHID::Replaces(HID_MAPPING_MENU_UP)
      || CHID::Replaces(HID_MAPPING_MENU_DOWN)
      || CHID::Replaces(HID_MAPPING_PED_MOVE_Y) )
    {
      v1.n64_f32[0] = (float)this->m_nCurrentSelection;
      this->m_nCurrentSelection = (int)vmax_f32(v1, v2).n64_f32[0];
    }
    if ( CHID::IsReleased(HID_MAPPING_MENU_UP)
      || OS_TimeAccurate() - CWidgetRegionTouchLayoutSelection::Update(void)::fLastAnalogtime > 0.25
      && CHID::IsPressedNegative(HID_MAPPING_PED_MOVE_Y) )
    {
      --this->m_nCurrentSelection;
      v18 = OS_TimeAccurate();
      CWidgetRegionTouchLayoutSelection::Update(void)::fLastAnalogtime = v18;
      if ( this->m_nCurrentSelection <= -1 )
        this->m_nCurrentSelection = 1;
    }
    if ( CHID::IsReleased(HID_MAPPING_MENU_DOWN)
      || OS_TimeAccurate() - CWidgetRegionTouchLayoutSelection::Update(void)::fLastAnalogtime > 0.25
      && CHID::IsPressedPositive(HID_MAPPING_PED_MOVE_Y) )
    {
      ++this->m_nCurrentSelection;
      v19 = OS_TimeAccurate();
      CWidgetRegionTouchLayoutSelection::Update(void)::fLastAnalogtime = v19;
      if ( this->m_nCurrentSelection >= 2 )
        this->m_nCurrentSelection = 0;
    }
  }
}
// 2C6214: variable 'v1' is possibly undefined
// 2C6214: variable 'v2' is possibly undefined

//----- (002C6318) --------------------------------------------------------
bool __fastcall CWidgetRegionTouchLayoutSelection::IsReleased(
        CWidgetRegionTouchLayoutSelection *this,
        CVector2D *pVecOut)
{
  return CWidget::IsReleased(this, pVecOut)
      || CHID::Implements(HID_MAPPING_ACCEPT) && CHID::IsReleased(HID_MAPPING_ACCEPT);
}

//----- (002C633C) --------------------------------------------------------
void __fastcall CWidgetRegionTouchLayoutSelection::~CWidgetRegionTouchLayoutSelection(
        CWidgetRegionTouchLayoutSelection *this)
{
  CSprite2d *p_mSpriteOverlay; // r5

  this->_vptr$CWidget = (int (**)(void))&off_664E44;
  p_mSpriteOverlay = &this->mSpriteOverlay;
  CSprite2d::~CSprite2d(&this->mSpriteAttack);
  CSprite2d::~CSprite2d(&this->mSpriteRunningManBack);
  CSprite2d::~CSprite2d(&this->mSpriteRunningMan);
  CSprite2d::~CSprite2d(&this->mSpriteSprintRim);
  CSprite2d::~CSprite2d(&this->mSpriteSprint);
  CSprite2d::~CSprite2d(&this->mSpriteCrouch);
  CSprite2d::~CSprite2d(p_mSpriteOverlay);
  sub_19C514(this);
}
// 664E44: using guessed type void *off_664E44;

//----- (002C6394) --------------------------------------------------------
void __fastcall CWidgetRegionTouchLayoutSelection::~CWidgetRegionTouchLayoutSelection(
        CWidgetRegionTouchLayoutSelection *this)
{
  CSprite2d *p_mSpriteOverlay; // r5
  void *v3; // r0

  this->_vptr$CWidget = (int (**)(void))&off_664E44;
  p_mSpriteOverlay = &this->mSpriteOverlay;
  CSprite2d::~CSprite2d(&this->mSpriteAttack);
  CSprite2d::~CSprite2d(&this->mSpriteRunningManBack);
  CSprite2d::~CSprite2d(&this->mSpriteRunningMan);
  CSprite2d::~CSprite2d(&this->mSpriteSprintRim);
  CSprite2d::~CSprite2d(&this->mSpriteSprint);
  CSprite2d::~CSprite2d(&this->mSpriteCrouch);
  CSprite2d::~CSprite2d(p_mSpriteOverlay);
  CWidget::~CWidget(this);
  sub_191374(v3);
}
// 2C63E8: variable 'v3' is possibly undefined
// 664E44: using guessed type void *off_664E44;

//----- (002C63F0) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetRegionTouchLayoutSelection::GetName(CWidgetRegionTouchLayoutSelection *this)
{
  return "Touch Layout Selection";
}

//----- (002C640C) --------------------------------------------------------
void __fastcall CWidgetReplay::CWidgetReplay(
        CWidgetReplay *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  CRGBA v4; // [sp+4h] [bp-Ch] BYREF

  CWidget::CWidget(this, pszSprite, WidgetPos, 0x402u, HID_MAPPING_REPLAY);
  this->_vptr$CWidget = (int (**)(void))&off_664ED8;
  CSprite2d::CSprite2d(&this->mSpriteCrossHairs);
  CRGBA::CRGBA(&v4, 0xFFu, 0, 0, 0);
  this->m_Color = v4;
  this->displayingRecordingTexture = 0;
  *(_DWORD *)&this->ResponseWidgetActive = 0;
  this->m_fExtraPaddingScale = 4.0;
}
// 664ED8: using guessed type void *;

//----- (002C647C) --------------------------------------------------------
void __fastcall CWidgetReplay::Update(CWidgetReplay *this)
{
  bool v2; // zf
  bool v3; // zf

  CWidget::Update(this);
  CWidget::ManageAlpha(this);
  v2 = (CTimer::m_UserPause || CTimer::m_CodePause) << 24 == 0;
  if ( (CTimer::m_UserPause || CTimer::m_CodePause) << 24 )
    v2 = !this->waitingForSave;
  if ( !v2 )
  {
    CTimer::EndUserPause();
    this->waitingForSave = 0;
  }
  v3 = MobileSettings::settings[36].value == 0;
  if ( MobileSettings::settings[36].value )
    v3 = !this->displayingRecordingTexture;
  if ( !v3 )
  {
    CWidget::SetTexture(this, &this->m_Sprite, (unsigned __int8 *)"circle", 1);
    *(_WORD *)&this->screenRecordingTouched = 0;
  }
}

//----- (002C64F4) --------------------------------------------------------
void __fastcall CWidgetReplay::ForceStopRecording(CWidgetReplay *this)
{
  CWidget::SetTexture(this, &this->m_Sprite, (unsigned __int8 *)"circle", 1);
  isRecording = 0;
  this->screenRecordingTouched = 0;
}

//----- (002C6520) --------------------------------------------------------
void __fastcall CWidgetReplay::OnReleasedTouch(CWidgetReplay *this)
{
  bool v2; // zf

  if ( (CTimer::m_UserPause || CTimer::m_CodePause) << 24 )
  {
    CTimer::EndUserPause();
    this->waitingForSave = 0;
  }
  else
  {
    v2 = !this->ResponseWidgetActive;
    if ( !this->ResponseWidgetActive )
      v2 = !this->GangWidgetActive;
    if ( v2 && MobileSettings::settings[36].value )
    {
      if ( isRecording )
      {
        CWidget::SetTexture(this, &this->m_Sprite, (unsigned __int8 *)"circle", 1);
        this->displayingRecordingTexture = 0;
        CTimer::StartUserPause();
        this->screenRecordingTouched = 0;
        isRecording = 0;
        this->waitingForSave = 1;
      }
      else if ( this->screenRecordingTouched )
      {
        sub_19FC20();
      }
      else
      {
        CWidget::SetTexture(this, &this->m_Sprite, "white", 1);
        isRecording = 1;
        this->startRecordTime = OS_TimeMS();
        *(_WORD *)&this->screenRecordingTouched = 257;
      }
    }
  }
}

//----- (002C6614) --------------------------------------------------------
void __fastcall CWidgetReplay::Draw(CWidgetReplay *this)
{
  CSprite2d *p_m_Sprite; // r3
  bool v2; // zf
  bool v3; // zf

  v2 = !this->ResponseWidgetActive;
  if ( !this->ResponseWidgetActive )
    v2 = !this->GangWidgetActive;
  if ( v2 )
  {
    v3 = this->m_Color._anon_0._anon_0.alpha == 0;
    if ( this->m_Color._anon_0._anon_0.alpha )
    {
      p_m_Sprite = &this->m_Sprite;
      v3 = this->m_Sprite.mpTexture == 0;
    }
    if ( !v3 )
      j_CSprite2d::Draw(p_m_Sprite, &this->m_RectScreen, &this->m_Color);
  }
}
// 2C6642: variable 'p_m_Sprite' is possibly undefined

//----- (002C6648) --------------------------------------------------------
void __fastcall CWidgetReplay::~CWidgetReplay(CWidgetReplay *this)
{
  this->_vptr$CWidget = (int (**)(void))&off_664ED8;
  CSprite2d::~CSprite2d(&this->mSpriteCrossHairs);
  sub_19C514(this);
}
// 664ED8: using guessed type void *off_664ED8;

//----- (002C6670) --------------------------------------------------------
void __fastcall CWidgetReplay::~CWidgetReplay(CWidgetReplay *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_664ED8;
  CSprite2d::~CSprite2d(&this->mSpriteCrossHairs);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2C6694: variable 'v2' is possibly undefined
// 664ED8: using guessed type void *off_664ED8;

//----- (002C669C) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetReplay::GetName(CWidgetReplay *this)
{
  return "Replay";
}

//----- (002C66B0) --------------------------------------------------------
void __fastcall CWidgetRouletteSpin::CWidgetRouletteSpin(CWidgetRouletteSpin *this)
{
  WidgetPosition WidgetPos; // [sp+10h] [bp-28h] BYREF

  *(_QWORD *)&WidgetPos.m_fOriginX = 0LL;
  *(_QWORD *)&WidgetPos.m_fScaleX = 0x4120000041200000LL;
  CWidget::CWidget(this, 0, &WidgetPos, 0x14u, HID_MAPPING_UNKNOWN);
  this->_vptr$CWidget = (int (**)(void))&off_664F6C;
  CSprite2d::CSprite2d(&this->m_SpriteBallColor);
  this->m_nBallNumber = 0;
  CWidget::SetTexture(this, &this->m_SpriteBallColor, "roulred", 1);
}
// 664F6C: using guessed type void *;

//----- (002C6738) --------------------------------------------------------
void __fastcall CWidgetRouletteSpin::Update(CWidgetRouletteSpin *this)
{
  CWidget::Update(this);
  sub_19751C(this);
}

//----- (002C674C) --------------------------------------------------------
void __fastcall CWidgetRouletteSpin::Draw(CWidgetRouletteSpin *this)
{
  CRGBA v2; // r0
  float left; // s16
  float right; // s18
  float v5; // s22
  float Height; // r0
  GxtChar pOutput[256]; // [sp+8h] [bp-338h] BYREF
  CRGBA v8; // [sp+208h] [bp-138h] BYREF
  unsigned __int8 s[256]; // [sp+20Ch] [bp-134h] BYREF

  if ( this->m_Color._anon_0._anon_0.alpha )
  {
    CSprite2d::Draw(&this->m_SpriteBallColor, &this->m_RectScreen, &this->m_Color);
    CFont::SetBackground(0, 0);
    CFont::SetProportional(1u);
    CFont::SetFontStyle(2u);
    CFont::SetOrientation(0);
    CFont::SetRightJustifyWrap(0.0);
    CFont::SetEdge(0);
    CRGBA::CRGBA(&v8, 0xFFu, 0xFFu, 0xFFu, this->m_Color._anon_0._anon_0.alpha);
    CFont::SetColor(v2);
    CFont::SetScale(fabsf(this->m_RectScreen.top - this->m_RectScreen.bottom) * 0.0175);
    sprintf(s, (const unsigned __int8 *)&dword_2C6860, this->m_nBallNumber);
    AsciiToGxtChar(s, pOutput);
    left = this->m_RectScreen.left;
    right = this->m_RectScreen.right;
    v5 = this->m_RectScreen.top + this->m_RectScreen.bottom;
    Height = CFont::GetHeight(0);
    CFont::PrintString((float)(left + right) * 0.5, (float)(v5 * 0.5) - (float)(Height * 0.5), pOutput);
  }
}
// 2C67B8: variable 'v2' is possibly undefined
// 2C6860: using guessed type int dword_2C6860;

//----- (002C6868) --------------------------------------------------------
void __fastcall CWidgetRouletteSpin::SetWidgetValue2(CWidgetRouletteSpin *this, float fValue0, float fValue1)
{
  if ( fValue0 == 1.0 )
    CWidget::SetTexture(this, &this->m_SpriteBallColor, "roulbla", 1);
  if ( fValue0 == 2.0 )
    CWidget::SetTexture(this, &this->m_SpriteBallColor, "roulred", 1);
  if ( fValue0 == 3.0 )
    CWidget::SetTexture(this, &this->m_SpriteBallColor, "roulgre", 1);
  this->m_nBallNumber = (int)fValue1;
}

//----- (002C68F4) --------------------------------------------------------
void __fastcall CWidgetRouletteSpin::~CWidgetRouletteSpin(CWidgetRouletteSpin *this)
{
  this->_vptr$CWidget = (int (**)(void))&off_664F6C;
  CSprite2d::~CSprite2d(&this->m_SpriteBallColor);
  sub_19C514(this);
}
// 664F6C: using guessed type void *off_664F6C;

//----- (002C691C) --------------------------------------------------------
void __fastcall CWidgetRouletteSpin::~CWidgetRouletteSpin(CWidgetRouletteSpin *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_664F6C;
  CSprite2d::~CSprite2d(&this->m_SpriteBallColor);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2C6940: variable 'v2' is possibly undefined
// 664F6C: using guessed type void *off_664F6C;

//----- (002C6948) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetRouletteSpin::GetName(CWidgetRouletteSpin *this)
{
  return "Rte Spin";
}

//----- (002C6958) --------------------------------------------------------
void __fastcall CWidgetSaveNotification::CWidgetSaveNotification(
        CWidgetSaveNotification *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  _DWORD *v3; // r0

  CWidget::CWidget(this, pszSprite, WidgetPos, 4u, HID_MAPPING_UNKNOWN);
  v3[36] = 0;
  v3[37] = 0;
  *v3 = &off_665000;
}
// 2C696A: variable 'v3' is possibly undefined
// 665000: using guessed type void *;

//----- (002C6980) --------------------------------------------------------
void __fastcall CWidgetSaveNotification::Update(CWidgetSaveNotification *this)
{
  double v2; // d16
  float v3; // s0

  CWidget::Update(this);
  v2 = this->m_fTimeRemaining - CWidget::m_fElapsedTime;
  v3 = v2;
  if ( v2 <= 0.0 )
    v3 = 0.0;
  this->m_fTimeRemaining = v3;
  if ( v3 > 0.0 )
    this->m_bEnabled = 1;
  sub_19751C(this);
}

//----- (002C69DC) --------------------------------------------------------
void __fastcall CWidgetSaveNotification::Draw(CWidgetSaveNotification *this)
{
  unsigned int alpha; // r0
  __int64 v3; // d17
  const CRGBA *v4; // r0
  CRGBA v5; // r0
  CRGBA v6; // r0
  float v7; // s18
  float v8; // s20
  GxtChar *v9; // r0
  float StringWidth; // r0
  float left; // s18
  float right; // s20
  float v13; // s22
  float v14; // s0
  GxtChar *v15; // r0
  CRGBA v16; // [sp+8h] [bp-60h] BYREF
  CRGBA v17; // [sp+Ch] [bp-5Ch] BYREF
  CRGBA v18; // [sp+10h] [bp-58h] BYREF
  CRGBA v19; // [sp+14h] [bp-54h] BYREF
  CRGBA v20; // [sp+18h] [bp-50h] BYREF
  CRGBA v21; // [sp+1Ch] [bp-4Ch] BYREF
  CRect v22; // [sp+20h] [bp-48h] BYREF

  alpha = this->m_Color._anon_0._anon_0.alpha;
  if ( alpha )
  {
    v3 = *(_QWORD *)&this->m_RectScreen.right;
    *(_QWORD *)&v22.left = *(_QWORD *)&this->m_RectScreen.left;
    *(_QWORD *)&v22.right = v3;
    CRGBA::CRGBA(&v21, 0, 0, 0, (unsigned int)(float)((float)alpha * 0.5));
    CRGBA::CRGBA(&v20, 0, 0, 0, (unsigned int)(float)((float)this->m_Color._anon_0._anon_0.alpha * 0.5));
    CRGBA::CRGBA(&v19, 0, 0, 0, this->m_Color._anon_0._anon_0.alpha);
    CRGBA::CRGBA(&v18, 0, 0, 0, this->m_Color._anon_0._anon_0.alpha);
    CSprite2d::DrawRect(&v22, &v21, &v20, &v19, v4);
    CFont::SetBackground(0, 0);
    CFont::SetProportional(1u);
    CFont::SetFontStyle(1u);
    CFont::SetOrientation(0);
    CFont::SetRightJustifyWrap(0.0);
    CFont::SetEdge(0);
    CRGBA::CRGBA(&v17, 0xFFu, 0xFFu, 0xFFu, this->m_Color._anon_0._anon_0.alpha);
    CFont::SetColor(v5);
    CRGBA::CRGBA(&v16, 0, 0, 0, this->m_Color._anon_0._anon_0.alpha);
    CFont::SetDropColor(v6);
    CFont::SetWrapx((float)RsGlobal.screenWidth);
    CFont::SetCentreSize((float)RsGlobal.screenWidth);
    v7 = fabsf(this->m_RectScreen.top - this->m_RectScreen.bottom) * 0.0325;
    CFont::SetScale(v7);
    v8 = fabsf(this->m_RectScreen.right - this->m_RectScreen.left) * 0.875;
    v9 = CText::Get(&TheText, "SAV_GAM");
    StringWidth = CFont::GetStringWidth(v9, 1u, 0);
    if ( StringWidth > v8 )
      CFont::SetScale(v7 * (float)(v8 / StringWidth));
    left = this->m_RectScreen.left;
    right = this->m_RectScreen.right;
    v13 = this->m_RectScreen.top + this->m_RectScreen.bottom;
    v14 = CFont::GetHeight(0) * 0.5;
    v15 = CText::Get(&TheText, "SAV_GAM");
    CFont::PrintString((float)(left + right) * 0.5, (float)(v13 * 0.5) - v14, v15);
  }
}
// 2C6A90: variable 'v4' is possibly undefined
// 2C6ACC: variable 'v5' is possibly undefined
// 2C6AE2: variable 'v6' is possibly undefined

//----- (002C6BF0) --------------------------------------------------------
void __fastcall CWidgetSaveNotification::EndSave(CWidgetSaveNotification *this)
{
  float v1; // s2
  float v2; // s4

  v1 = CWidget::m_fTime - this->m_fTimeEnabled;
  v2 = 2.0 - v1;
  if ( v1 > 2.0 )
    v2 = 0.0;
  this->m_fTimeRemaining = v2;
}

//----- (002C6C34) --------------------------------------------------------
void __fastcall CWidgetSaveNotification::~CWidgetSaveNotification(CWidgetSaveNotification *this)
{
  void *v1; // r0

  CWidget::~CWidget(this);
  sub_191374(v1);
}
// 2C6C40: variable 'v1' is possibly undefined

//----- (002C6C44) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetSaveNotification::GetName(CWidgetSaveNotification *this)
{
  return "Save Notify";
}

//----- (002C6C60) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CWidgetSlider::CWidgetSlider(
        CWidgetSlider *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos,
        unsigned int nSliderFlags,
        unsigned int nExtraFlags,
        unsigned int nNotches,
        CTouchInterface::WidgetIDs LeftControlButtonID,
        CTouchInterface::WidgetIDs RightControlButtonID)
{
  float *m_fNotchValues; // r5
  int v11; // r0
  int v12; // s4
  CRGBA v13; // [sp+8h] [bp-20h] BYREF
  CRGBA v14; // [sp+Ch] [bp-1Ch] BYREF

  CWidget::CWidget(this, pszSprite, WidgetPos, nExtraFlags, HID_MAPPING_UNKNOWN);
  this->_vptr$CWidget = (int (**)(void))&off_665094;
  CSprite2d::CSprite2d(&this->m_SpriteThumb);
  CSprite2d::CSprite2d(&this->m_SpriteNotch);
  m_fNotchValues = this->m_fNotchValues;
  *(_QWORD *)&this->m_RectBar.left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_RectBar.right = 0x49742400C9742400LL;
  memset(this->m_fNotchValues, 0, sizeof(this->m_fNotchValues));
  this->m_nSliderFlags = nSliderFlags;
  CRGBA::CRGBA(&v14, 0, 0, 0xFFu, 0xFFu);
  this->m_ColorBar = v14;
  CRGBA::CRGBA(&v13, 0xFFu, 0, 0, 0xFFu);
  this->m_ColorThumb = v13;
  this->m_fSliderPosition = 0.0;
  this->m_nCurrentNotch = 0;
  *(_QWORD *)&this->m_LeftControlButtonID = *(_QWORD *)&LeftControlButtonID;
  this->m_nNotches = nNotches;
  if ( (int)nNotches >= 1 )
  {
    v11 = 0;
    do
    {
      v12 = v11++;
      *m_fNotchValues++ = (float)((float)(99.0 / (float)(int)(nNotches - 1)) * (float)v12) + 1.0;
    }
    while ( v11 < this->m_nNotches );
  }
  CWidget::SetTexture(this, &this->m_SpriteThumb, "SliderThumb", 1);
  CWidget::SetTexture(this, &this->m_SpriteNotch, "White", 1);
}
// 2C6C60: variables would overlap: ^38.4 and ^38.8
// 665094: using guessed type void *;

//----- (002C6DBC) --------------------------------------------------------
void __fastcall CWidgetSlider::SetupNotches(CWidgetSlider *this, int nNotches, float fMin, float fMax)
{
  float v4; // s2
  float *m_fNotchValues; // r1
  int v7; // r2
  float v8; // s2
  int v9; // s4

  v4 = (float)(nNotches - 1);
  this->m_nNotches = nNotches;
  if ( nNotches >= 1 )
  {
    m_fNotchValues = this->m_fNotchValues;
    v7 = 0;
    v8 = (float)(fMax - fMin) / v4;
    do
    {
      v9 = v7++;
      *m_fNotchValues++ = (float)(v8 * (float)v9) + fMin;
    }
    while ( v7 < this->m_nNotches );
  }
}

//----- (002C6E08) --------------------------------------------------------
void __fastcall CWidgetSlider::Update(CWidgetSlider *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d9
  int m_nTouchIndex; // r1
  float v6; // s16
  float m_fSliderPosition; // s20
  int v8; // r0
  float bottom; // s0
  CWidget *v10; // r0
  float v11; // s20
  float left; // s2
  CWidget *v13; // r0
  float right; // s2
  float v15; // s6
  float v16; // s0
  CRect v17[3]; // [sp+0h] [bp-38h] BYREF

  CWidget::Update(this);
  v3.n64_u32[0] = 1.0;
  m_nTouchIndex = this->m_nTouchIndex;
  v6 = 1.0 / (float)((float)this->m_nNotches + -1.0);
  if ( this == CWidget::m_pInitialTouchWidget[m_nTouchIndex] )
  {
    CTouchInterface::GetTouchPosition((CVector2D *)v17, m_nTouchIndex);
    v1.n64_f32[0] = (float)(v17[0].left - this->m_RectBar.left) / fabsf(this->m_RectBar.right - this->m_RectBar.left);
    v2.n64_u32[0] = 0;
    v1.n64_u64[0] = vmin_f32(vmax_f32(v1, v2), v3).n64_u64[0];
    LODWORD(this->m_fSliderPosition) = v1.n64_u32[0];
    this->m_nCurrentNotch = (int)(float)(v1.n64_f32[0] / v6);
  }
  else if ( (this->m_nSliderFlags & 2) == 0 )
  {
    m_fSliderPosition = this->m_fSliderPosition;
    v8 = (int)floorf((float)(m_fSliderPosition / v6) + 0.5);
    if ( (float)(m_fSliderPosition - (float)(v6 * (float)v8)) >= (float)(v6 * 0.5) )
      ++v8;
    this->m_nCurrentNotch = v8;
    this->m_fSliderPosition = v6 * (float)v8;
  }
  CWidget::ManageAlpha(this);
  if ( this->m_bEnabled && (this->m_nSliderFlags & 0x40) != 0 )
  {
    bottom = this->m_RectScreen.bottom;
    v10 = CTouchInterface::m_pWidgets[this->m_LeftControlButtonID];
    v11 = fabsf(this->m_RectScreen.top - bottom) * 0.75;
    if ( v10 )
    {
      left = this->m_RectBar.left;
      v17[0].bottom = this->m_RectScreen.bottom;
      v17[0].left = left;
      v17[0].top = v11 + bottom;
      v17[0].right = left - v11;
      CWidget::SetScreenRect(v10, v17);
    }
    v13 = CTouchInterface::m_pWidgets[this->m_RightControlButtonID];
    if ( v13 )
    {
      right = this->m_RectBar.right;
      v15 = v11 + this->m_RectScreen.bottom;
      v17[0].bottom = this->m_RectScreen.bottom;
      v17[0].left = right;
      v17[0].right = v11 + right;
      v17[0].top = v15;
      CWidget::SetScreenRect(v13, v17);
    }
    if ( CTouchInterface::IsTouched(this->m_LeftControlButtonID, 0, 1) )
    {
      v2.n64_u32[0] = 0;
      v1.n64_f32[0] = this->m_fSliderPosition + CWidget::m_fElapsedTime * -0.400000006;
      v1.n64_u64[0] = vmax_f32(v1, v2).n64_u64[0];
      LODWORD(this->m_fSliderPosition) = v1.n64_u32[0];
      this->m_nCurrentNotch = (int)(float)(v1.n64_f32[0] / v6);
    }
    if ( CTouchInterface::IsTouched(this->m_RightControlButtonID, 0, 1) )
    {
      v1.n64_f32[0] = CWidget::m_fElapsedTime * 0.400000006 + this->m_fSliderPosition;
      v16 = vmin_f32(v1, v3).n64_f32[0];
      this->m_fSliderPosition = v16;
      this->m_nCurrentNotch = (int)(float)(v16 / v6);
    }
  }
}
// 2C6EC4: variable 'v1' is possibly undefined
// 2C6EC4: variable 'v2' is possibly undefined
// 2C6EC8: variable 'v3' is possibly undefined

//----- (002C7040) --------------------------------------------------------
void __fastcall CWidgetSlider::Draw(CWidgetSlider *this)
{
  float32x2_t v1; // d5
  float32x2_t v2; // d7
  unsigned int ScreenWidth; // r0
  float top; // s2
  float bottom; // s6
  CRect *p_m_RectBar; // r8
  float v8; // s8
  float v9; // s18
  float v10; // s4
  float32x4_t v11; // q9
  float32x4_t v12; // q8
  int m_nNotches; // r0
  float left; // s0
  int v15; // r6
  float v16; // s20
  float v17; // s6
  float v18; // s0
  float v19; // s2
  float v20; // s0
  float32x4_t v21; // q8
  CRGBA v22; // r0
  CRGBA v23; // r0
  unsigned int m_nSliderFlags; // r0
  int m_nCurrentNotch; // r0
  float v26; // s0
  int v27; // r0
  int v28; // r0
  float v29; // s0
  float v30; // s20
  float v31; // s0
  float v32; // s20
  float v33; // s20
  CRect Rectangle; // [sp+10h] [bp-368h] BYREF
  CRGBA v35; // [sp+210h] [bp-168h] BYREF
  CRGBA v36; // [sp+214h] [bp-164h] BYREF
  CRGBA v37; // [sp+218h] [bp-160h] BYREF
  CRGBA v38; // [sp+21Ch] [bp-15Ch] BYREF
  float32x4_t v39; // [sp+220h] [bp-158h] BYREF
  CRGBA v40; // [sp+234h] [bp-144h] BYREF

  if ( this->m_Color._anon_0._anon_0.alpha )
  {
    ScreenWidth = CWidget::GetScreenWidth();
    top = this->m_RectScreen.top;
    bottom = this->m_RectScreen.bottom;
    v2.n64_u32[0] = 5.5;
    p_m_RectBar = &this->m_RectBar;
    v1.n64_f32[0] = (float)ScreenWidth * 0.0125;
    v8 = fabsf(top - bottom) * 0.2;
    v9 = vmax_f32(v1, v2).n64_f32[0];
    v10 = this->m_RectScreen.right - v9;
    this->m_RectBar.left = this->m_RectScreen.left + v9;
    this->m_RectBar.top = top - v8;
    this->m_RectBar.right = v10;
    this->m_RectBar.bottom = bottom - v8;
    if ( this->m_Sprite.mpTexture )
    {
      CRGBA::CRGBA(&v40, 0, 0, 0, this->m_Color._anon_0._anon_0.alpha);
      v11.n128_u64[0] = *(_QWORD *)&p_m_RectBar->left;
      v11.n128_u64[1] = *(_QWORD *)&this->m_RectBar.right;
      v12.n128_u64[0] = 0x40000000C0000000LL;
      v12.n128_u64[1] = 0xC000000040000000LL;
      Rectangle = (CRect)vaddq_f32(v11, v12);
      CSprite2d::Draw(&this->m_Sprite, &Rectangle, &v40);
      CRGBA::CRGBA(
        (CRGBA *)&Rectangle,
        this->m_ColorBar._anon_0._anon_0.red,
        this->m_ColorBar._anon_0._anon_0.green,
        this->m_ColorBar._anon_0._anon_0.blue,
        (unsigned int)(float)((float)((float)this->m_ColorBar._anon_0._anon_0.alpha / 255.0)
                            * (float)this->m_Color._anon_0._anon_0.alpha));
      CSprite2d::Draw(&this->m_Sprite, &this->m_RectBar, (const CRGBA *)&Rectangle);
    }
    if ( LOBYTE(this->m_nSliderFlags) << 31 )
    {
      m_nNotches = this->m_nNotches;
      if ( m_nNotches >= 1 )
      {
        left = this->m_RectBar.left;
        v15 = 0;
        v16 = fabsf(this->m_RectBar.right - left) / (float)(m_nNotches - 1);
        while ( 1 )
        {
          v17 = this->m_RectBar.bottom;
          v18 = (float)(v16 * (float)v15) + left;
          v19 = fabsf(this->m_RectScreen.top - this->m_RectScreen.bottom) * 0.2;
          Rectangle.left = v18 + -2.5;
          Rectangle.right = v18 + 2.5;
          Rectangle.bottom = v17 - v19;
          Rectangle.top = v17 + v19;
          CSprite2d::Draw(&this->m_SpriteNotch, &Rectangle, &this->m_Color);
          if ( ++v15 >= this->m_nNotches )
            break;
          left = p_m_RectBar->left;
        }
      }
    }
    v20 = this->m_RectBar.left + (float)(this->m_fSliderPosition * fabsf(this->m_RectBar.right - this->m_RectBar.left));
    v39.n128_f32[3] = this->m_RectBar.bottom + (float)(fabsf(this->m_RectBar.top - this->m_RectBar.bottom) * 0.5);
    v39.n128_f32[0] = v20 - v9;
    v39.n128_f32[2] = v9 + v20;
    v39.n128_f32[1] = (float)(v9 + v9) + v39.n128_f32[3];
    CRGBA::CRGBA(&v38, 0, 0, 0, this->m_Color._anon_0._anon_0.alpha);
    v21.n128_u64[0] = 0x40000000C0000000LL;
    v21.n128_u64[1] = 0xC000000040000000LL;
    Rectangle = (CRect)vaddq_f32(v39, v21);
    CSprite2d::Draw(&this->m_SpriteThumb, &Rectangle, &v38);
    CRGBA::CRGBA(
      &v37,
      this->m_ColorThumb._anon_0._anon_0.red,
      this->m_ColorThumb._anon_0._anon_0.green,
      this->m_ColorThumb._anon_0._anon_0.blue,
      (unsigned int)(float)((float)((float)this->m_ColorThumb._anon_0._anon_0.alpha / 255.0)
                          * (float)this->m_Color._anon_0._anon_0.alpha));
    CSprite2d::Draw(&this->m_SpriteThumb, (const CRect *)&v39, &v37);
    if ( (this->m_nSliderFlags & 0x20) == 0 )
    {
      CFont::SetFontStyle(1u);
      CFont::SetBackground(0, 0);
      CFont::SetScale((float)RsGlobal.screenHeight / 448.0);
      CFont::SetOrientation(0);
      CFont::SetCentreSize((float)((float)RsGlobal.screenWidth / 640.0) * 640.0);
      CFont::SetProportional(1u);
      CRGBA::CRGBA(&v36, 0xFFu, 0xFFu, 0xFFu, this->m_Color._anon_0._anon_0.alpha);
      CFont::SetColor(v22);
      CRGBA::CRGBA(&v35, 0, 0, 0, this->m_Color._anon_0._anon_0.alpha);
      CFont::SetDropColor(v23);
      CFont::SetEdge(0);
      m_nSliderFlags = this->m_nSliderFlags;
      if ( (m_nSliderFlags & 2) != 0 )
      {
        if ( (m_nSliderFlags & 0x10) != 0 )
        {
          if ( this->m_fSliderPosition != 1.0 )
          {
            v30 = 1.0 / (float)((float)this->m_nNotches + -1.0);
            v26 = this->m_fNotchValues[this->m_nCurrentNotch]
                + (float)((float)(this->m_fNotchValues[this->m_nCurrentNotch + 1]
                                - this->m_fNotchValues[this->m_nCurrentNotch])
                        * (float)(fmodf(this->m_fSliderPosition, v30) * (float)(1.0 / v30)));
            goto LABEL_18;
          }
          goto LABEL_16;
        }
        if ( (m_nSliderFlags & 4) == 0 )
        {
          if ( (m_nSliderFlags & 8) != 0 )
          {
            if ( this->m_fSliderPosition != 1.0 )
            {
              v33 = 1.0 / (float)((float)this->m_nNotches + -1.0);
              v31 = this->m_fNotchValues[this->m_nCurrentNotch]
                  + (float)((float)(this->m_fNotchValues[this->m_nCurrentNotch + 1]
                                  - this->m_fNotchValues[this->m_nCurrentNotch])
                          * (float)(fmodf(this->m_fSliderPosition, v33) * (float)(1.0 / v33)));
              goto LABEL_41;
            }
            goto LABEL_37;
          }
          goto LABEL_26;
        }
        if ( this->m_fSliderPosition != 1.0 )
        {
          v32 = 1.0 / (float)((float)this->m_nNotches + -1.0);
          v29 = this->m_fNotchValues[this->m_nCurrentNotch]
              + (float)((float)(this->m_fNotchValues[this->m_nCurrentNotch + 1]
                              - this->m_fNotchValues[this->m_nCurrentNotch])
                      * (float)(fmodf(this->m_fSliderPosition, v32) * (float)(1.0 / v32)));
          goto LABEL_32;
        }
      }
      else
      {
        if ( (m_nSliderFlags & 0x10) != 0 )
        {
          if ( this->m_fSliderPosition == 1.0 )
          {
            m_nCurrentNotch = this->m_nNotches - 1;
LABEL_17:
            v26 = this->m_fNotchValues[m_nCurrentNotch];
LABEL_18:
            sprintf((unsigned __int8 *)&v40, "%d%%", (int)v26);
            goto LABEL_33;
          }
LABEL_16:
          m_nCurrentNotch = this->m_nCurrentNotch;
          goto LABEL_17;
        }
        if ( (m_nSliderFlags & 4) == 0 )
        {
          if ( (m_nSliderFlags & 8) != 0 )
          {
            if ( this->m_fSliderPosition == 1.0 )
            {
              v27 = this->m_nNotches - 1;
LABEL_38:
              v31 = this->m_fNotchValues[v27];
LABEL_41:
              sprintf((unsigned __int8 *)&v40, "%d", (int)v31);
              goto LABEL_33;
            }
LABEL_37:
            v27 = this->m_nCurrentNotch;
            goto LABEL_38;
          }
LABEL_26:
          v40._anon_0._anon_0.red = 0;
LABEL_33:
          AsciiToGxtChar((const Char *)&v40, (GxtChar *)&Rectangle);
          CFont::PrintString((float)(v39.n128_f32[0] + v39.n128_f32[2]) * 0.5, v39.n128_f32[1], (GxtChar *)&Rectangle);
          return;
        }
        if ( this->m_fSliderPosition == 1.0 )
        {
          v28 = this->m_nNotches - 1;
LABEL_31:
          v29 = this->m_fNotchValues[v28];
LABEL_32:
          sprintf((unsigned __int8 *)&v40, "%.2f", v29);
          goto LABEL_33;
        }
      }
      v28 = this->m_nCurrentNotch;
      goto LABEL_31;
    }
  }
}
// 2C70AE: variable 'v1' is possibly undefined
// 2C70AE: variable 'v2' is possibly undefined
// 2C734C: variable 'v22' is possibly undefined
// 2C7362: variable 'v23' is possibly undefined

//----- (002C75EC) --------------------------------------------------------
float __fastcall CWidgetSlider::GetTweenedValue(CWidgetSlider *this)
{
  float v2; // s18

  if ( this->m_fSliderPosition == 1.0 )
    return this->m_fNotchValues[this->m_nCurrentNotch];
  v2 = 1.0 / (float)((float)this->m_nNotches + -1.0);
  return this->m_fNotchValues[this->m_nCurrentNotch]
       + (float)((float)(this->m_fNotchValues[this->m_nCurrentNotch + 1] - this->m_fNotchValues[this->m_nCurrentNotch])
               * (float)(fmodf(this->m_fSliderPosition, v2) * (float)(1.0 / v2)));
}

//----- (002C766C) --------------------------------------------------------
float __fastcall CWidgetSlider::GetNotchedValue(CWidgetSlider *this)
{
  int m_nCurrentNotch; // r1

  if ( this->m_fSliderPosition == 1.0 )
    m_nCurrentNotch = this->m_nNotches - 1;
  else
    m_nCurrentNotch = this->m_nCurrentNotch;
  return this->m_fNotchValues[m_nCurrentNotch];
}

//----- (002C7692) --------------------------------------------------------
void __fastcall CWidgetSlider::SetWidgetValue(CWidgetSlider *this, float fValue)
{
  int m_nNotches; // r12
  float *v4; // r3
  int v5; // r1
  float v6; // s2

  m_nNotches = this->m_nNotches;
  if ( m_nNotches >= 2 )
  {
    v4 = &this->m_fNotchValues[1];
    v5 = 0;
    while ( 1 )
    {
      v6 = *(v4 - 1);
      if ( v6 <= fValue && *v4 >= fValue )
        break;
      ++v5;
      ++v4;
      if ( v5 >= m_nNotches - 1 )
        return;
    }
    this->m_fSliderPosition = (float)((float)((float)(fValue - v6) / (float)(*v4 - v6)) + (float)v5)
                            / (float)((float)m_nNotches + -1.0);
  }
}

//----- (002C7704) --------------------------------------------------------
void __fastcall CWidgetSlider::SetSliderRange(CWidgetSlider *this, float fMinValue, float fMaxValue)
{
  float32x2_t v3; // d0
  float32x2_t v4; // d3
  float v6; // s4
  float *m_fNotchValues; // r0
  unsigned __int32 v8; // r1
  float v9; // s4

  v3.n64_f32[0] = fMaxValue;
  if ( fMinValue == 50.0 )
  {
    v6 = 95.0;
    this->m_nNotches = 96;
  }
  else
  {
    v6 = (float)this->m_nNotches + -1.0;
  }
  m_fNotchValues = this->m_fNotchValues;
  v8 = 0;
  v9 = (float)(fMaxValue - fMinValue) / v6;
  do
  {
    v4.n64_u32[0] = v8++;
    v4.n64_f32[0] = (float)(v9 * (float)v4.n64_i32[0]) + fMinValue;
    v4.n64_u64[0] = vmin_f32(v4, v3).n64_u64[0];
    *m_fNotchValues++ = v4.n64_f32[0];
  }
  while ( v8 != 100 );
}
// 2C7756: variable 'v4' is possibly undefined
// 2C7756: variable 'v3' is possibly undefined

//----- (002C776C) --------------------------------------------------------
void __fastcall CWidgetSlider::~CWidgetSlider(CWidgetSlider *this)
{
  this->_vptr$CWidget = (int (**)(void))&off_665094;
  CSprite2d::~CSprite2d(&this->m_SpriteNotch);
  CSprite2d::~CSprite2d(&this->m_SpriteThumb);
  sub_19C514(this);
}
// 665094: using guessed type void *off_665094;

//----- (002C779C) --------------------------------------------------------
void __fastcall CWidgetSlider::~CWidgetSlider(CWidgetSlider *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_665094;
  CSprite2d::~CSprite2d(&this->m_SpriteNotch);
  CSprite2d::~CSprite2d(&this->m_SpriteThumb);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2C77C6: variable 'v2' is possibly undefined
// 665094: using guessed type void *off_665094;

//----- (002C77D0) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetSlider::GetName(CWidgetSlider *this)
{
  return "Slider";
}

//----- (002C77DC) --------------------------------------------------------
float __fastcall CWidgetSlider::GetWidgetValue(CWidgetSlider *this)
{
  float m_fSliderPosition; // s0
  int m_nCurrentNotch; // r0
  float v5; // s18

  m_fSliderPosition = this->m_fSliderPosition;
  if ( (this->m_nSliderFlags & 2) != 0 )
  {
    if ( m_fSliderPosition != 1.0 )
    {
      v5 = 1.0 / (float)((float)this->m_nNotches + -1.0);
      return this->m_fNotchValues[this->m_nCurrentNotch]
           + (float)((float)(this->m_fNotchValues[this->m_nCurrentNotch + 1]
                           - this->m_fNotchValues[this->m_nCurrentNotch])
                   * (float)(fmodf(this->m_fSliderPosition, v5) * (float)(1.0 / v5)));
    }
    goto LABEL_5;
  }
  if ( m_fSliderPosition != 1.0 )
  {
LABEL_5:
    m_nCurrentNotch = this->m_nCurrentNotch;
    return this->m_fNotchValues[m_nCurrentNotch];
  }
  m_nCurrentNotch = this->m_nNotches - 1;
  return this->m_fNotchValues[m_nCurrentNotch];
}

//----- (002C7880) --------------------------------------------------------
void __fastcall CWidgetTapMeter::CWidgetTapMeter(
        CWidgetTapMeter *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  int v3; // r0
  float v4; // s0

  CWidget::CWidget(this, pszSprite, WidgetPos, 6u, HID_MAPPING_UNKNOWN);
  *(_DWORD *)(v3 + 184) = 1232348160;
  *(_DWORD *)(v3 + 144) = 0;
  *(_DWORD *)v3 = &off_665128;
  v4 = (float)CTimer::m_snTimeInMilliseconds;
  *(_QWORD *)(v3 + 152) = 0x3F80000000000000LL;
  *(_QWORD *)(v3 + 160) = 1065353216LL;
  *(_QWORD *)(v3 + 168) = 0x497424003DCCCCCDLL;
  *(_QWORD *)(v3 + 176) = 0xC9742400C9742400LL;
  *(float *)(v3 + 148) = v4 / 1000.0;
}
// 2C789E: variable 'v3' is possibly undefined
// 665128: using guessed type void *off_665128;

//----- (002C7920) --------------------------------------------------------
void __fastcall CWidgetTapMeter::Update(CWidgetTapMeter *this)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d2
  float32x2_t v4; // d3
  float32x4_t v6; // q8
  int m_nState; // r0
  float m_fLevelInc; // s4
  float v9; // s2

  CWidget::Update(this);
  v6.n128_u64[0] = 0xC040000040400000LL;
  v6.n128_u64[1] = 0x40400000C0400000LL;
  this->m_RectClient = (CRect)vaddq_f32((float32x4_t)this->m_RectScreen, v6);
  CWidget::ManageAlpha(this);
  v1.n64_f32[0] = CStats::GetStatValue(0x17u) + -50.0;
  m_nState = this->m_nState;
  v3.n64_f32[0] = v1.n64_f32[0] / 950.0;
  v2.n64_u32[0] = 0;
  v1.n64_u32[0] = 1.0;
  this->m_fSuccessLevelMax = (float)(vmin_f32(vmax_f32(v3, v2), v1).n64_f32[0] * 0.2) + 0.1;
  if ( m_nState == 1 )
  {
    this->m_nState = 0;
  }
  else if ( !m_nState )
  {
    m_fLevelInc = this->m_fLevelInc;
    v4.n64_f32[0] = CWidget::m_fElapsedTime * m_fLevelInc * this->m_fLevelRate + this->m_fLevel;
    v9 = vmin_f32(vmax_f32(v4, v2), v1).n64_f32[0];
    this->m_fLevel = v9;
    if ( v9 == 0.0 )
      this->m_fLevelInc = -m_fLevelInc;
  }
}
// 2C7976: variable 'v3' is possibly undefined
// 2C7976: variable 'v2' is possibly undefined
// 2C797A: variable 'v1' is possibly undefined
// 2C79C4: variable 'v4' is possibly undefined

//----- (002C7A28) --------------------------------------------------------
void __fastcall CWidgetTapMeter::Draw(CWidgetTapMeter *this)
{
  unsigned int alpha; // r0
  const CRGBA *v3; // r0
  float top; // s4
  float m_fLevel; // s0
  float v6; // s8
  float v7; // s6
  float v8; // s6
  float m_fSuccessLevelMax; // s4
  float v10; // s0
  float v11; // s2
  float v12; // s8
  CRGBA v13; // [sp+8h] [bp-50h] BYREF
  CRect v14; // [sp+Ch] [bp-4Ch] BYREF
  CRGBA v15; // [sp+1Ch] [bp-3Ch] BYREF
  CRGBA v16; // [sp+20h] [bp-38h] BYREF
  CRGBA v17; // [sp+24h] [bp-34h] BYREF

  alpha = this->m_Color._anon_0._anon_0.alpha;
  if ( alpha )
  {
    CRGBA::CRGBA((CRGBA *)&v14, 0, 0, 0, (unsigned int)((float)((float)alpha / 255.0) * 100.0));
    CRGBA::CRGBA(&v17, 0, 0, 0, (unsigned int)((float)((float)this->m_Color._anon_0._anon_0.alpha / 255.0) * 100.0));
    CRGBA::CRGBA(&v16, 0, 0, 0, (unsigned int)((float)((float)this->m_Color._anon_0._anon_0.alpha / 255.0) * 255.0));
    CRGBA::CRGBA(&v15, 0, 0, 0, (unsigned int)((float)((float)this->m_Color._anon_0._anon_0.alpha / 255.0) * 255.0));
    CSprite2d::DrawRect(&this->m_RectScreen, (const CRGBA *)&v14, &v17, &v16, v3);
    top = this->m_RectClient.top;
    m_fLevel = this->m_fLevel;
    v6 = fabsf(top - this->m_RectClient.bottom);
    v7 = this->m_RectClient.right + -3.0;
    v14.left = this->m_RectClient.left + 3.0;
    v14.right = v7;
    v14.top = top + -3.0;
    v14.bottom = (float)(top + -3.0) - (float)(m_fLevel * (float)(v6 + -6.0));
    CRGBA::CRGBA(&v17, 0, 0xFFu, 0, this->m_Color._anon_0._anon_0.alpha);
    CRGBA::CRGBA(&v16, 0, 0xFFu, 0, this->m_Color._anon_0._anon_0.alpha);
    CWidget::GetGradientColor(&v15, this, 1.0 - this->m_fLevel, this->m_Color._anon_0._anon_0.alpha);
    CWidget::GetGradientColor(&v13, this, 1.0 - this->m_fLevel, this->m_Color._anon_0._anon_0.alpha);
    CSprite2d::DrawRect(&v14, &v17, &v16, &v15, &v13);
    v8 = this->m_RectClient.top;
    m_fSuccessLevelMax = this->m_fSuccessLevelMax;
    v10 = this->m_RectScreen.left + 1.0;
    v11 = this->m_RectScreen.right + -1.0;
    v12 = fabsf(v8 - this->m_RectClient.bottom);
    v14.bottom = v8 + -1.0;
    v14.left = v10;
    v14.right = v11;
    v14.top = (float)(v8 + -3.0) - (float)(m_fSuccessLevelMax * (float)(v12 + -6.0));
    CRGBA::CRGBA(&v17, 0x80u, 0x80u, 0x80u, (unsigned int)(float)((float)this->m_Color._anon_0._anon_0.alpha * 0.75));
    CSprite2d::DrawRect(&v14, &v17);
  }
}
// 2C7B16: variable 'v3' is possibly undefined

//----- (002C7C7C) --------------------------------------------------------
bool __fastcall CWidgetTapMeter::RespondToTap(CWidgetTapMeter *this)
{
  float m_fLevel; // s0

  if ( this->m_nState )
    return 0;
  m_fLevel = this->m_fLevel;
  if ( m_fLevel < this->m_fSuccessLevelMin || m_fLevel > this->m_fSuccessLevelMax )
    return 0;
  this->m_nState = 1;
  this->m_fStateTime = (float)CTimer::m_snTimeInMilliseconds / 1000.0;
  return 1;
}

//----- (002C7CD4) --------------------------------------------------------
bool __fastcall CWidgetTapMeter::IsReleased(CWidgetTapMeter *this, CVector2D *pVecOut)
{
  float m_fLevel; // s0
  bool result; // r0

  if ( !CTouchInterface::IsReleased(WIDGET_TAP_METER_BUTTON, 0, 1)
    && this != CWidget::m_pReleasedWidget[this->m_nTouchIndex] )
  {
    return 0;
  }
  if ( this->m_nState )
    return 0;
  m_fLevel = this->m_fLevel;
  if ( m_fLevel < this->m_fSuccessLevelMin || m_fLevel > this->m_fSuccessLevelMax )
    return 0;
  result = 1;
  this->m_nState = 1;
  this->m_fStateTime = (float)CTimer::m_snTimeInMilliseconds / 1000.0;
  return result;
}

//----- (002C7D50) --------------------------------------------------------
void __fastcall CWidgetTapMeter::SetWidgetValue(CWidgetTapMeter *this, float fValue)
{
  this->m_fLevelRate = (float)(fValue * 0.125) + 1.0;
}

//----- (002C7D6A) --------------------------------------------------------
void __fastcall CWidgetTapMeter::~CWidgetTapMeter(CWidgetTapMeter *this)
{
  void *v1; // r0

  CWidget::~CWidget(this);
  sub_191374(v1);
}
// 2C7D76: variable 'v1' is possibly undefined

//----- (002C7D7C) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetTapMeter::GetName(CWidgetTapMeter *this)
{
  return (const unsigned __int8 *)&off_2C7D80;
}
// 2C7D80: using guessed type void *;

//----- (002C7D90) --------------------------------------------------------
void __fastcall CWidgetThumbCircle::CWidgetThumbCircle(
        CWidgetThumbCircle *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  CWidget::CWidget(this, pszSprite, WidgetPos, 6u, HID_MAPPING_GYM_ACTION);
  this->_vptr$CWidget = (int (**)(void))&off_6651BC;
  CSprite2d::CSprite2d(&this->m_SpriteIndicator);
  *(_QWORD *)&this->m_RectTop.left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_RectTop.right = 0x49742400C9742400LL;
  *(_QWORD *)&this->m_RectClient.left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_RectClient.right = 0x49742400C9742400LL;
  *(_QWORD *)&this->m_RectBottom.left = 0xC974240049742400LL;
  *(_QWORD *)&this->m_RectBottom.right = 0x49742400C9742400LL;
  CWidget::SetTexture(this, &this->m_SpriteIndicator, "hud_analognub", 1);
  this->m_vecIndicatorOrigin = 0LL;
  this->m_vecMouseToOrigin = 0LL;
  this->m_fPower = 0.0;
  this->m_fLosePowerRate = 0.5;
  this->m_fGainPowerRate = 0.75;
  this->m_fDragDirection = 1.0;
  this->m_nLastSubsection = 0;
}
// 6651BC: using guessed type void *;

//----- (002C7E34) --------------------------------------------------------
void __fastcall CWidgetThumbCircle::Update(CWidgetThumbCircle *this)
{
  float32x2_t v1; // d2
  float32x2_t v2; // d10
  float top; // s0
  float v5; // s16
  float bottom; // s2
  float left; // r1
  float right; // s12
  float v9; // s12
  float v10; // s4
  float v11; // s8
  float v12; // s10
  float32x2_t v13; // d0
  int m_nTouchIndex; // r0
  float32x2_t v15; // d0
  float v16; // s2
  float y; // s0
  float x; // s2
  int v19; // r2
  CVector2D v20; // r0
  float v21; // s4
  float v22; // s4
  float v23; // s2
  float v24; // r0
  float v25; // s0
  int v26; // r0
  float m_fPower; // s2
  CVector2D v28; // [sp+0h] [bp-28h] BYREF

  CWidget::Update(this);
  CWidget::ManageAlpha(this);
  top = this->m_RectScreen.top;
  v5 = 1.0;
  bottom = this->m_RectScreen.bottom;
  left = this->m_RectScreen.left;
  right = this->m_RectScreen.right;
  this->m_RectTop.left = left;
  this->m_RectTop.right = right;
  this->m_RectBottom.right = right;
  this->m_RectBottom.left = left;
  this->m_RectTop.bottom = bottom;
  this->m_RectBottom.top = top;
  v2.n64_u32[0] = 0;
  v9 = (float)(left + right) * 0.5;
  v10 = bottom + (float)(fabsf(top - bottom) * 0.225);
  this->m_RectTop.top = v10;
  this->m_RectBottom.bottom = v10 + 1.0;
  v11 = (float)(fabsf(top - (float)(v10 + 1.0)) * 0.75) * 0.5;
  v12 = (float)((float)(v10 + 1.0) + top) * 0.5;
  v13.n64_f32[1] = v12 + v11;
  this->m_RectClient.left = v9 - v11;
  this->m_RectClient.top = v12 + v11;
  this->m_RectClient.right = v9 + v11;
  this->m_RectClient.bottom = v12 - v11;
  m_nTouchIndex = this->m_nTouchIndex;
  v13.n64_f32[0] = this->m_fPower - CWidget::m_fElapsedTime * this->m_fLosePowerRate;
  v15.n64_u64[0] = vmax_f32(v13, v2).n64_u64[0];
  LODWORD(this->m_fPower) = v15.n64_u32[0];
  if ( this == CWidget::m_pInitialTouchWidget[m_nTouchIndex] && CTouchInterface::IsTouchDown(m_nTouchIndex) )
  {
    CTouchInterface::GetTouchPosition(&v28, this->m_nTouchIndex);
    v16 = v28.y - (float)((float)(this->m_RectScreen.top + this->m_RectScreen.bottom) * 0.5);
    this->m_vecMouseToOrigin.x = v28.x - (float)((float)(this->m_RectScreen.left + this->m_RectScreen.right) * 0.5);
    this->m_vecMouseToOrigin.y = v16;
  }
  y = this->m_vecMouseToOrigin.y;
  x = this->m_vecMouseToOrigin.x;
  v19 = 0;
  v20 = 0LL;
  if ( y == 0.0 )
    LODWORD(v20.y) = 1;
  if ( x == 0.0 )
    v19 = 1;
  if ( (v19 & LODWORD(v20.y)) != 0 )
  {
    y = -1.0;
    v20.y = -1.0;
    x = 0.0;
    this->m_vecMouseToOrigin = v20;
  }
  v21 = (float)(x * x) + (float)(y * y);
  if ( v21 <= 0.0 )
  {
    this->m_vecMouseToOrigin.x = 1.0;
  }
  else
  {
    v22 = 1.0 / sqrtf(v21);
    v5 = x * v22;
    y = y * v22;
    this->m_vecMouseToOrigin.x = x * v22;
    this->m_vecMouseToOrigin.y = y;
  }
  v23 = fabsf(this->m_RectClient.right - this->m_RectClient.left) * 0.5;
  this->m_vecMouseToOrigin.x = v5 * v23;
  this->m_vecMouseToOrigin.y = y * v23;
  v24 = atan2f(y * v23, v5 * v23);
  v25 = v24 + 1.5708;
  if ( (float)(v24 + 1.5708) < 0.0 )
    v25 = (float)(v24 + 1.5708) + 6.2832;
  v26 = (int)(float)(v25 / 0.7854);
  if ( this->m_nLastSubsection != v26 )
  {
    v1.n64_u32[0] = LODWORD(this->m_fGainPowerRate);
    m_fPower = this->m_fPower;
    this->m_nLastSubsection = v26;
    v15.n64_f32[0] = v1.n64_f32[0] * 0.125;
    v1.n64_u32[0] = 1.0;
    v15.n64_f32[0] = m_fPower + v15.n64_f32[0];
    LODWORD(this->m_fPower) = vmin_f32(v15, v1).n64_u32[0];
  }
}
// 2C7F14: variable 'v2' is possibly undefined
// 2C806A: variable 'v1' is possibly undefined

//----- (002C8098) --------------------------------------------------------
void __fastcall CWidgetThumbCircle::Draw(CWidgetThumbCircle *this)
{
  float left; // s4
  float right; // s8
  float v4; // s14
  float v5; // s4
  float v6; // s8
  float v7; // s0
  float v8; // s2
  float top; // s2
  float bottom; // s6
  float v11; // s8
  float v12; // s0
  float v13; // s4
  float v14; // s0
  float m_fPower; // s10
  CRGBA v16; // [sp+8h] [bp-60h] BYREF
  CRGBA v17; // [sp+Ch] [bp-5Ch] BYREF
  CRect v18; // [sp+10h] [bp-58h] BYREF
  CRect v19; // [sp+20h] [bp-48h] BYREF
  CRGBA v20; // [sp+30h] [bp-38h] BYREF
  CRGBA v21; // [sp+34h] [bp-34h] BYREF

  if ( this->m_Color._anon_0._anon_0.alpha )
  {
    if ( CHID::GetInputType() != 1 )
    {
      CRGBA::CRGBA(
        (CRGBA *)&v19,
        0,
        0,
        0,
        (unsigned int)((float)((float)this->m_Color._anon_0._anon_0.alpha / 255.0) * 100.0));
      CRGBA::CRGBA(
        (CRGBA *)&v18,
        0,
        0,
        0,
        (unsigned int)((float)((float)this->m_Color._anon_0._anon_0.alpha / 255.0) * 100.0));
      CRGBA::CRGBA(&v21, 0, 0, 0, (unsigned int)((float)((float)this->m_Color._anon_0._anon_0.alpha / 255.0) * 255.0));
      CRGBA::CRGBA(&v20, 0, 0, 0, (unsigned int)((float)((float)this->m_Color._anon_0._anon_0.alpha / 255.0) * 255.0));
      CSprite2d::DrawRect(&this->m_RectTop, (const CRGBA *)&v19, (const CRGBA *)&v18, &v21, &v20);
      CRGBA::CRGBA(
        (CRGBA *)&v19,
        0,
        0,
        0,
        (unsigned int)((float)((float)this->m_Color._anon_0._anon_0.alpha / 255.0) * 100.0));
      CRGBA::CRGBA(
        (CRGBA *)&v18,
        0,
        0,
        0,
        (unsigned int)((float)((float)this->m_Color._anon_0._anon_0.alpha / 255.0) * 100.0));
      CRGBA::CRGBA(&v21, 0, 0, 0, (unsigned int)((float)((float)this->m_Color._anon_0._anon_0.alpha / 255.0) * 255.0));
      CRGBA::CRGBA(&v20, 0, 0, 0, (unsigned int)((float)((float)this->m_Color._anon_0._anon_0.alpha / 255.0) * 255.0));
      CSprite2d::DrawRect(&this->m_RectBottom, (const CRGBA *)&v19, (const CRGBA *)&v18, &v21, &v20);
      CSprite2d::Draw(&this->m_Sprite, &this->m_RectClient, &this->m_Color);
      left = this->m_RectClient.left;
      right = this->m_RectClient.right;
      v4 = right - left;
      v5 = left + right;
      v6 = fabsf(v4) * 0.175;
      v7 = (float)(v5 * 0.5) + this->m_vecMouseToOrigin.x;
      v8 = (float)((float)(this->m_RectClient.top + this->m_RectClient.bottom) * 0.5) + this->m_vecMouseToOrigin.y;
      v19.left = v7 - v6;
      v19.right = v6 + v7;
      v19.bottom = v8 - v6;
      v19.top = v6 + v8;
      CSprite2d::Draw(&this->m_SpriteIndicator, &v19, &this->m_Color);
      top = this->m_RectTop.top;
      bottom = this->m_RectTop.bottom;
      v11 = fabsf(top - bottom) * 0.125;
      v12 = this->m_RectTop.left + v11;
      v13 = this->m_RectTop.right - v11;
      v19.bottom = bottom + v11;
      v19.left = v12;
      v19.right = v13;
      v19.top = top - v11;
      CRGBA::CRGBA(
        (CRGBA *)&v18,
        0xFFu,
        0xFFu,
        0xFFu,
        (unsigned int)((float)((float)this->m_Color._anon_0._anon_0.alpha / 255.0) * 40.0));
      CSprite2d::DrawRect(&v19, (const CRGBA *)&v18);
      v14 = fabsf(this->m_RectTop.top - this->m_RectTop.bottom) * 0.075;
      m_fPower = this->m_fPower;
      v18.left = v19.left + v14;
      v18.bottom = v19.bottom + v14;
      v18.top = v19.top - v14;
      v18.right = (float)(v19.left + v14)
                + (float)(m_fPower * (float)(fabsf(v19.right - v19.left) + (float)(v14 * -2.0)));
      CRGBA::CRGBA(&v21, 0, 0xFFu, 0, this->m_Color._anon_0._anon_0.alpha);
      CWidget::GetGradientColor(&v20, this, 1.0 - this->m_fPower, this->m_Color._anon_0._anon_0.alpha);
      CRGBA::CRGBA(&v17, 0, 0xFFu, 0, this->m_Color._anon_0._anon_0.alpha);
      CWidget::GetGradientColor(&v16, this, 1.0 - this->m_fPower, this->m_Color._anon_0._anon_0.alpha);
      CSprite2d::DrawRect(&v18, &v21, &v20, &v17, &v16);
    }
  }
}

//----- (002C8474) --------------------------------------------------------
float __fastcall CWidgetThumbCircle::GetWidgetValue(CWidgetThumbCircle *this)
{
  return this->m_fPower;
}

//----- (002C847A) --------------------------------------------------------
void __fastcall CWidgetThumbCircle::SetWidgetValue(CWidgetThumbCircle *this, float fValue)
{
  this->m_fLosePowerRate = (float)(fValue * 0.125) + 0.5;
}

//----- (002C8494) --------------------------------------------------------
void __fastcall CWidgetThumbCircle::~CWidgetThumbCircle(CWidgetThumbCircle *this)
{
  this->_vptr$CWidget = (int (**)(void))&off_6651BC;
  CSprite2d::~CSprite2d(&this->m_SpriteIndicator);
  sub_19C514(this);
}
// 6651BC: using guessed type void *off_6651BC;

//----- (002C84BC) --------------------------------------------------------
void __fastcall CWidgetThumbCircle::~CWidgetThumbCircle(CWidgetThumbCircle *this)
{
  void *v2; // r0

  this->_vptr$CWidget = (int (**)(void))&off_6651BC;
  CSprite2d::~CSprite2d(&this->m_SpriteIndicator);
  CWidget::~CWidget(this);
  sub_191374(v2);
}
// 2C84E0: variable 'v2' is possibly undefined
// 6651BC: using guessed type void *off_6651BC;

//----- (002C84E8) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetThumbCircle::GetName(CWidgetThumbCircle *this)
{
  return "Circle";
}

//----- (002C84F4) --------------------------------------------------------
void __fastcall CWidgetThumbCircle::OnInitialTouch(CWidgetThumbCircle *this)
{
  CWidget::OnInitialTouch(this);
  this->m_vecIndicatorOrigin = CWidget::m_vecTouchAnchor[this->m_nTouchIndex];
}

//----- (002C8520) --------------------------------------------------------
void __fastcall CWidgetVitalStats::CWidgetVitalStats(
        CWidgetVitalStats *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  _DWORD *v3; // r0

  CWidget::CWidget(this, pszSprite, WidgetPos, 0, HID_MAPPING_UNKNOWN);
  v3[7] = 1157627904;
  *v3 = &off_665250;
}
// 2C8536: variable 'v3' is possibly undefined
// 665250: using guessed type void *;

//----- (002C8548) --------------------------------------------------------
void __fastcall CWidgetVitalStats::Update(CWidgetVitalStats *this)
{
  CWidget::Update(this);
  sub_19751C(this);
}

//----- (002C855C) --------------------------------------------------------
void __fastcall CWidgetVitalStats::Draw(CWidgetVitalStats *this)
{
  float32x2_t v1; // d2
  float32x2_t v2; // d8
  CPlayerPed *PlayerPed; // r0
  int m_eWeaponType; // r4
  CVehicle *PlayerVehicle; // r0
  int v7; // r0
  const char *v8; // r0
  int v9; // r0
  int v10; // r6
  float v11; // s0
  float right; // r0
  float v13; // s2
  const CRGBA *v14; // r0
  float v15; // s2
  float v16; // r1
  float v17; // s2
  const CRGBA *v18; // r0
  float top; // s24
  float bottom; // s26
  CRGBA v21; // r0
  CRGBA v22; // r0
  float v23; // s0
  float left; // s26
  float v25; // s28
  float v26; // s24
  float v27; // s0
  GxtChar *v28; // r0
  GxtChar *v29; // r4
  float v30; // s20
  float v31; // s26
  float Height; // r0
  float v33; // s28
  float v34; // s20
  float v35; // s30
  float v36; // s22
  float v37; // s26
  float v38; // s23
  float v39; // s24
  float v40; // s28
  GxtChar *v41; // r0
  float StringWidth; // r0
  float v43; // s2
  int v44; // r11
  float v45; // s24
  uint16 v46; // r8
  float v47; // s25
  int32 SkillStatIndex; // r0
  float *v49; // r4
  float v50; // s25
  float v51; // s27
  float StatValue; // r0
  float v53; // s2
  float v54; // s0
  GxtChar *v55; // r0
  float v56; // r9
  CVehicle *v57; // r0
  const char *v58; // r2
  bool v59; // zf
  eWeaponType WeaponType; // [sp+20h] [bp-E8h]
  char *v61; // [sp+24h] [bp-E4h]
  unsigned int alpha; // [sp+30h] [bp-D8h]
  int v63; // [sp+34h] [bp-D4h]
  CRGBA c2; // [sp+38h] [bp-D0h] BYREF
  CRGBA v65; // [sp+3Ch] [bp-CCh] BYREF
  CRGBA v66; // [sp+40h] [bp-C8h] BYREF
  CRGBA v67; // [sp+44h] [bp-C4h] BYREF
  CRGBA v68; // [sp+48h] [bp-C0h] BYREF
  CRect v69; // [sp+4Ch] [bp-BCh] BYREF
  CRGBA v70; // [sp+5Ch] [bp-ACh] BYREF
  CRGBA v71; // [sp+60h] [bp-A8h] BYREF
  CRGBA v72; // [sp+64h] [bp-A4h] BYREF
  CRect Rectangle; // [sp+68h] [bp-A0h] BYREF
  _QWORD v74[3]; // [sp+78h] [bp-90h]
  _QWORD v75[2]; // [sp+90h] [bp-78h]
  __int64 v76; // [sp+A0h] [bp-68h]

  if ( !this->m_Color._anon_0._anon_0.alpha )
    return;
  if ( FindPlayerPed(-1) )
  {
    PlayerPed = FindPlayerPed(-1);
    m_eWeaponType = PlayerPed->m_WeaponSlots[PlayerPed->m_nCurrentWeapon].m_eWeaponType;
  }
  else
  {
    m_eWeaponType = 0;
  }
  v75[0] = *(_QWORD *)off_6652E0;
  v75[1] = *(_QWORD *)off_6652E8;
  v76 = *(_QWORD *)off_6652F0;
  v74[0] = *(_QWORD *)"@";
  v74[1] = unk_60EDF8;
  v74[2] = unk_60EE00;
  PlayerVehicle = FindPlayerVehicle(-1, 0);
  if ( m_eWeaponType == 32 )
    m_eWeaponType = 28;
  if ( PlayerVehicle )
  {
    if ( FindPlayerVehicle(-1, 0)->m_vehicleType == 4 || FindPlayerVehicle(-1, 0)->m_vehicleType == 3 )
    {
      HIDWORD(v75[0]) = "STAT223";
      v7 = 223;
    }
    else if ( FindPlayerVehicle(-1, 0)->m_vehicleType == 9 )
    {
      HIDWORD(v75[0]) = "STAT229";
      v7 = 229;
    }
    else
    {
      v57 = FindPlayerVehicle(-1, 0);
      v58 = "STAT230";
      v59 = v57->m_vehicleType == 10;
      v7 = 160;
      if ( !v59 )
        v58 = "STAT160";
      HIDWORD(v75[0]) = v58;
      if ( v59 )
        v7 = 230;
    }
    HIDWORD(v74[0]) = v7;
  }
  WeaponType = m_eWeaponType;
  if ( CPedIntelligence::GetTaskSwim(CWorld::Players[CWorld::PlayerInFocus].pPed->m_pPedIntelligence) )
  {
    v8 = "STAT225";
LABEL_16:
    HIDWORD(v76) = v8;
    v9 = 6;
    goto LABEL_17;
  }
  if ( (unsigned int)(m_eWeaponType - 22) <= 0xA )
  {
    v8 = "CURWSKL";
    goto LABEL_16;
  }
  v9 = 5;
LABEL_17:
  v63 = v9;
  v10 = 0;
  v11 = (float)this->m_Color._anon_0._anon_0.alpha;
  v1.n64_u32[0] = LODWORD(this->m_RectScreen.bottom);
  right = this->m_RectScreen.right;
  v13 = this->m_RectScreen.top - v1.n64_f32[0];
  Rectangle.left = this->m_RectScreen.left;
  Rectangle.right = right;
  LODWORD(Rectangle.bottom) = v1.n64_u32[0];
  Rectangle.top = v1.n64_f32[0] + (float)(fabsf(v13) * 0.2);
  CRGBA::CRGBA((CRGBA *)&v69, 0, 0, 0, (unsigned int)(float)((float)(v11 / 255.0) * 120.0));
  CRGBA::CRGBA(&v72, 0, 0, 0, (unsigned int)(float)((float)(v11 / 255.0) * 120.0));
  CRGBA::CRGBA(&v71, 0, 0, 0, (unsigned int)(float)((float)(v11 / 255.0) * 220.0));
  CRGBA::CRGBA(&v70, 0, 0, 0, (unsigned int)(float)((float)(v11 / 255.0) * 220.0));
  CSprite2d::DrawRect(&Rectangle, (const CRGBA *)&v69, &v72, &v71, v14);
  v2.n64_u32[0] = 2.0;
  v15 = this->m_RectScreen.top - this->m_RectScreen.bottom;
  v16 = this->m_RectScreen.right;
  v69.left = this->m_RectScreen.left;
  v69.right = v16;
  v17 = fabsf(v15);
  v1.n64_f32[0] = v17 * 0.01;
  v69.bottom = Rectangle.top + vmax_f32(v1, v2).n64_f32[0];
  v69.top = v69.bottom + (float)((float)((float)v63 / 6.0) * v17);
  CRGBA::CRGBA(&v72, 0, 0, 0, (unsigned int)(float)((float)(v11 / 255.0) * 120.0));
  CRGBA::CRGBA(&v71, 0, 0, 0, (unsigned int)(float)((float)(v11 / 255.0) * 120.0));
  CRGBA::CRGBA(&v70, 0, 0, 0, (unsigned int)(float)((float)(v11 / 255.0) * 220.0));
  CRGBA::CRGBA(&v68, 0, 0, 0, (unsigned int)(float)((float)(v11 / 255.0) * 220.0));
  CSprite2d::DrawRect(&v69, &v72, &v71, &v70, v18);
  top = v69.top;
  bottom = v69.bottom;
  CFont::SetFontStyle(0);
  CFont::SetOrientation(1u);
  CFont::SetEdge(1);
  CRGBA::CRGBA(&v67, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)((float)(v11 / 255.0) * 255.0));
  CFont::SetColor(v21);
  alpha = (unsigned int)(float)((float)(v11 / 255.0) * 255.0);
  CRGBA::CRGBA(&v66, 0, 0, 0, alpha);
  CFont::SetDropColor(v22);
  CFont::SetProportional(1u);
  CFont::SetScale(fabsf(Rectangle.top - Rectangle.bottom) * 0.035);
  v23 = top - bottom;
  left = Rectangle.left;
  v25 = Rectangle.top + Rectangle.bottom;
  v26 = fabsf(v23) * 0.075;
  v27 = CFont::GetHeight(0) * 0.5;
  v28 = CText::Get(&TheText, "FEH_STA");
  CFont::PrintString(v26 + left, (float)(v25 * 0.5) - v27, v28);
  CFont::RenderFontBuffer();
  CFont::SetOrientation(2u);
  CFont::SetFontStyle(2u);
  CFont::SetScale(fabsf(Rectangle.top - Rectangle.bottom) * 0.0275);
  sprintf(gString, "DAY_%d", CClock::CurrentDay);
  v29 = CText::Get(&TheText, gString);
  v30 = Rectangle.right;
  v31 = Rectangle.top + Rectangle.bottom;
  Height = CFont::GetHeight(0);
  CFont::PrintString(v30 - v26, (float)(v31 * 0.5) - (float)(Height * 0.5), v29);
  CFont::RenderFontBuffer();
  v33 = v69.left;
  v34 = v26 + v69.bottom;
  v35 = v69.right;
  v36 = fabsf((float)(v69.top - v26) - (float)(v26 + v69.bottom)) / (float)v63;
  v37 = v36 * 0.04;
  CFont::SetScale(v36 * 0.04);
  CFont::SetOrientation(1u);
  v38 = v26 + v33;
  v39 = fabsf((float)(v35 - v26) - (float)(v26 + v33));
  v40 = v39 * 0.5;
  CFont::SetWrapx(v38 + (float)(v39 * 0.5));
  do
  {
    v41 = CText::Get(&TheText, *((const unsigned __int8 **)v75 + v10));
    StringWidth = CFont::GetStringWidth(v41, 1u, 0);
    if ( StringWidth > v40 )
    {
      v37 = v37 * (float)(v40 / StringWidth);
      CFont::SetScale(v37);
    }
    ++v10;
  }
  while ( v10 < v63 );
  v43 = v39 * 0.44;
  v44 = 0;
  v45 = (float)(int)(float)(v38 + (float)(v39 * 0.55));
  v61 = (char *)HIDWORD(v76);
  v46 = (int)v43;
  do
  {
    v47 = (float)(CStats::GetStatValue(*((_WORD *)v74 + 2 * v44)) / 1000.0) * 100.0;
    if ( v44 == 5 && !strcasecmp(v61, "CURWSKL") )
    {
      SkillStatIndex = CWeaponInfo::GetSkillStatIndex(WeaponType);
      v49 = &CStats::StatReactionValue[SkillStatIndex];
      v50 = *(v49 - 23);
      v51 = *(v49 - 57);
      StatValue = CStats::GetStatValue(SkillStatIndex);
      v53 = 1.0;
      if ( StatValue <= 999.0 )
        v53 = (float)((float)(v50 * v51) / 1000.0)
            * floorf((float)(StatValue + (float)(*(v49 - 57) * 0.1)) / (float)(v50 * v51));
      v47 = v53 * 100.0;
    }
    v54 = CFont::GetHeight(0);
    v55 = CText::Get(&TheText, *((const unsigned __int8 **)v75 + v44));
    CFont::PrintString(v38, (float)(v34 + (float)(v36 * (float)v44)) + (float)((float)(v36 - v54) * 0.5), v55);
    v56 = CFont::GetHeight(0);
    CRGBA::CRGBA(&v65, 0xC8u, 0xC8u, 0xC8u, alpha);
    CRGBA::CRGBA(&c2, 0, 0, 0, 0);
    CSprite2d::DrawBarChart(
      v45,
      (float)(int)(float)((float)((float)(v34 + (float)(v36 * (float)v44++)) + (float)((float)(v36 - v54) * 0.5)) + 2.0),
      v46,
      (int)(float)(v56 + -2.0),
      v47,
      0,
      0,
      1,
      (CRGBA)&v65,
      (CRGBA)&c2);
  }
  while ( v44 < v63 );
}
// 2C8720: variable 'v14' is possibly undefined
// 2C8776: variable 'v1' is possibly undefined
// 2C8776: variable 'v2' is possibly undefined
// 2C87C8: variable 'v18' is possibly undefined
// 2C8800: variable 'v21' is possibly undefined
// 2C8814: variable 'v22' is possibly undefined
// 6652E0: using guessed type char *off_6652E0[6];
// 6652E8: using guessed type char *[4];
// 6652F0: using guessed type char *[2];

//----- (002C8C34) --------------------------------------------------------
void __fastcall CWidgetVitalStats::~CWidgetVitalStats(CWidgetVitalStats *this)
{
  void *v1; // r0

  CWidget::~CWidget(this);
  sub_191374(v1);
}
// 2C8C40: variable 'v1' is possibly undefined

//----- (002C8C44) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetVitalStats::GetName(CWidgetVitalStats *this)
{
  return (_BYTE *)sub_2C8C48;
}
// 2C8C48: using guessed type int sub_2C8C48();

//----- (002C8C54) --------------------------------------------------------
void __fastcall CWidgetWager::CWidgetWager(
        CWidgetWager *this,
        const unsigned __int8 *pszSprite,
        const WidgetPosition *WidgetPos)
{
  int v4[67]; // [sp+8h] [bp-120h] BYREF

  CWidget::CWidget(this, pszSprite, WidgetPos, 4u, HID_MAPPING_UNKNOWN);
  this->m_DataCell[3].m_szLabel[0] = 0;
  this->_vptr$CWidget = (int (**)(void))&off_665300;
  this->m_DataCell[3].m_nIntegerValue0 = 0;
  this->m_DataCell[3].m_szText[0] = 0;
  strcpy((char *)this->m_szTitle, "WAGER1");
  this->m_bExtraCell = 0;
  LOBYTE(v4[32]) = 0;
  LOBYTE(v4[0]) = 0;
  memset(&v4[64], 0, 12);
  qmemcpy(this->m_DataCell, v4, 0x10Cu);
  LOBYTE(v4[32]) = 0;
  LOBYTE(v4[0]) = 0;
  memset(&v4[64], 0, 12);
  qmemcpy(&this->m_DataCell[1], v4, sizeof(this->m_DataCell[1]));
  LOBYTE(v4[32]) = 0;
  LOBYTE(v4[0]) = 0;
  memset(&v4[64], 0, 12);
  qmemcpy(&this->m_DataCell[2], v4, sizeof(this->m_DataCell[2]));
  LOBYTE(v4[32]) = 0;
  LOBYTE(v4[0]) = 0;
  memset(&v4[64], 0, 12);
  qmemcpy(&this->m_DataCell[3], v4, sizeof(this->m_DataCell[3]));
}
// 665300: using guessed type void *;

//----- (002C8D44) --------------------------------------------------------
void __fastcall CWidgetWager::Update(CWidgetWager *this)
{
  CWidget::Update(this);
  sub_19751C(this);
}

//----- (002C8D58) --------------------------------------------------------
void __fastcall CWidgetWager::Draw(CWidgetWager *this)
{
  CWidgetWager *v1; // r4
  unsigned int v2; // r8
  int v3; // r6
  float top; // s22
  float bottom; // s18
  float v6; // s16
  CRGBA v7; // r0
  float v8; // s18
  float v9; // s20
  int *p_m_nColor; // r11
  int v11; // r10
  float v12; // s0
  float v13; // s26
  GxtChar *v14; // r0
  float StringWidth; // r0
  GxtChar *p_Rectangle; // r0
  int v17; // r2
  float v18; // r0
  float right; // r1
  float v20; // s20
  const CRGBA *v21; // r0
  float v22; // s4
  float v23; // s24
  float v24; // s22
  float v25; // s0
  float v26; // s0
  float v27; // s0
  float v28; // s0
  float v29; // s0
  float v30; // s2
  float v31; // s4
  int v32; // r9
  CRGBA *v33; // r8
  int *v34; // r5
  float v35; // r1
  const CRGBA *v36; // r0
  CRGBA *v37; // r6
  GxtChar *v38; // r8
  GxtChar *v39; // r0
  GxtChar *v40; // r1
  int v41; // r2
  GxtChar *v42; // r0
  float v43; // r1
  const CRGBA *v44; // r0
  CWidgetWager *v45; // [sp+24h] [bp-484h]
  unsigned int v46; // [sp+28h] [bp-480h]
  unsigned int alpha; // [sp+2Ch] [bp-47Ch]
  CRGBA v48; // [sp+30h] [bp-478h] BYREF
  CRGBA v49; // [sp+34h] [bp-474h] BYREF
  CRect v50; // [sp+38h] [bp-470h] BYREF
  CRGBA v51; // [sp+48h] [bp-460h] BYREF
  CRect Rectangle; // [sp+4Ch] [bp-45Ch] BYREF
  CRGBA v53; // [sp+24Ch] [bp-25Ch] BYREF
  CRect v54[16]; // [sp+250h] [bp-258h] BYREF
  CRect s[16]; // [sp+350h] [bp-158h] BYREF

  v1 = this;
  v2 = this->m_Color._anon_0._anon_0.alpha;
  if ( this->m_Color._anon_0._anon_0.alpha )
  {
    if ( strlen((const char *)this->m_DataCell) )
      v3 = strcasecmp((const char *)v1->m_DataCell, "DUMMY") != 0;
    else
      v3 = 0;
    if ( strlen((const char *)&v1->m_DataCell[1]) && strcasecmp((const char *)&v1->m_DataCell[1], "DUMMY") )
      ++v3;
    if ( strlen((const char *)&v1->m_DataCell[2]) && strcasecmp((const char *)&v1->m_DataCell[2], "DUMMY") )
      ++v3;
    if ( strlen((const char *)&v1->m_DataCell[3]) && strcasecmp((const char *)&v1->m_DataCell[3], "DUMMY") )
      ++v3;
    if ( v3 )
    {
      top = v1->m_RectScreen.top;
      bottom = v1->m_RectScreen.bottom;
      CFont::SetBackground(0, 0);
      CFont::SetProportional(1u);
      CFont::SetFontStyle(2u);
      CFont::SetOrientation(1u);
      CFont::SetRightJustifyWrap(0.0);
      CFont::SetEdge(0);
      v6 = (float)v2 / 255.0;
      alpha = (unsigned int)(float)(v6 * 255.0);
      CRGBA::CRGBA(&v53, 0, 0, 0, alpha);
      CFont::SetDropColor(v7);
      v8 = (float)(fabsf(top - bottom) - (float)v3) / 5.25;
      v9 = v8 * 0.0175;
      CFont::SetScale(v8 * 0.0175);
      if ( v3 >= 1 )
      {
        p_m_nColor = &v1->m_DataCell[0].m_nColor;
        v11 = v3;
        do
        {
          v12 = fabsf(v1->m_RectScreen.right - v1->m_RectScreen.left);
          v13 = v12 + (float)((float)(v12 * -0.0675) + (float)(v12 * -0.0675));
          v14 = CText::Get(&TheText, (const unsigned __int8 *)p_m_nColor - 264);
          StringWidth = CFont::GetStringWidth(v14, 1u, 0);
          if ( StringWidth > v13 )
          {
            v9 = v9 * (float)(v13 / StringWidth);
            CFont::SetScale(v9);
          }
          if ( !strlen((const char *)p_m_nColor - 264) || !strcasecmp((const char *)p_m_nColor - 136, "DUMMY") )
          {
            v17 = *(p_m_nColor - 2);
            if ( *p_m_nColor == 1 )
              sprintf((unsigned __int8 *)s, "$~1~%d", v17);
            else
              sprintf((unsigned __int8 *)s, (const unsigned __int8 *)&dword_2C9448, v17);
            AsciiToGxtChar((const Char *)s, (GxtChar *)&Rectangle);
            p_Rectangle = (GxtChar *)&Rectangle;
          }
          else
          {
            p_Rectangle = CText::Get(&TheText, (const unsigned __int8 *)p_m_nColor - 136);
          }
          v18 = CFont::GetStringWidth(p_Rectangle, 1u, 0);
          if ( v18 > v13 )
          {
            v9 = v9 * (float)(v13 / v18);
            CFont::SetScale(v9);
          }
          p_m_nColor += 67;
          --v11;
        }
        while ( v11 );
      }
      if ( v1->m_bExtraCell )
      {
        right = v1->m_RectScreen.right;
        Rectangle.left = v1->m_RectScreen.left;
        Rectangle.right = right;
        Rectangle.top = top;
        v20 = top + (float)(v8 * -2.5);
        Rectangle.bottom = v20;
        CRGBA::CRGBA((CRGBA *)s, 0, 0, 0, (unsigned int)(float)(v6 * 128.0));
        CRGBA::CRGBA((CRGBA *)v54, 0, 0, 0, (unsigned int)(float)(v6 * 128.0));
        CRGBA::CRGBA((CRGBA *)&v50, 0, 0, 0, alpha);
        CRGBA::CRGBA(&v51, 0, 0, 0, alpha);
        CSprite2d::DrawRect(&Rectangle, (const CRGBA *)s, (const CRGBA *)v54, (const CRGBA *)&v50, v21);
        v22 = fabsf(Rectangle.top - Rectangle.bottom);
        v23 = v22 * 0.05;
        v24 = v22 * 0.425;
        if ( CTouchInterface::m_pWidgets[60] )
        {
          v25 = (float)(Rectangle.top + Rectangle.bottom) * 0.5;
          s[0].left = v23 + Rectangle.left;
          s[0].right = v24 + (float)(v23 + Rectangle.left);
          s[0].bottom = v25 - (float)(v24 * 0.5);
          s[0].top = (float)(v24 * 0.5) + v25;
          CWidget::SetScreenRect(CTouchInterface::m_pWidgets[60], s);
        }
        if ( CTouchInterface::m_pWidgets[61] )
        {
          v26 = (float)(Rectangle.top + Rectangle.bottom) * 0.5;
          s[0].right = Rectangle.right - v23;
          s[0].left = (float)(Rectangle.right - v23) - v24;
          s[0].bottom = v26 - (float)(v24 * 0.5);
          s[0].top = (float)(v24 * 0.5) + v26;
          CWidget::SetScreenRect(CTouchInterface::m_pWidgets[61], s);
        }
        if ( CTouchInterface::m_pWidgets[58] )
        {
          v27 = (float)(Rectangle.left + Rectangle.right) * 0.5;
          s[0].bottom = v23 + Rectangle.bottom;
          s[0].top = v24 + (float)(v23 + Rectangle.bottom);
          s[0].left = v27 - (float)(v24 * 0.5);
          s[0].right = (float)(v24 * 0.5) + v27;
          CWidget::SetScreenRect(CTouchInterface::m_pWidgets[58], s);
        }
        if ( CTouchInterface::m_pWidgets[59] )
        {
          v28 = (float)(Rectangle.left + Rectangle.right) * 0.5;
          s[0].top = Rectangle.top - v23;
          s[0].bottom = (float)(Rectangle.top - v23) - v24;
          s[0].left = v28 - (float)(v24 * 0.5);
          s[0].right = (float)(v24 * 0.5) + v28;
          CWidget::SetScreenRect(CTouchInterface::m_pWidgets[59], s);
        }
        if ( CTouchInterface::m_pWidgets[184] )
        {
          v29 = (float)(Rectangle.top + Rectangle.bottom) * 0.5;
          v30 = (float)(Rectangle.left + Rectangle.right) * 0.5;
          v31 = (float)(fabsf(Rectangle.top - Rectangle.bottom) * 0.85) * 0.5;
          s[0].left = v30 - v31;
          s[0].bottom = v29 - v31;
          s[0].right = v31 + v30;
          s[0].top = v31 + v29;
          CWidget::SetScreenRect(CTouchInterface::m_pWidgets[184], s);
        }
        if ( v3 > 0 )
          goto LABEL_41;
      }
      else
      {
        v20 = top;
        if ( v3 > 0 )
        {
LABEL_41:
          v32 = v3 + 1;
          v33 = (CRGBA *)v54;
          v34 = (int *)&v1->m_szTitle[268 * v3 + 124];
          v45 = v1;
          v46 = (unsigned int)(float)(v6 * 128.0);
          while ( 1 )
          {
            v35 = v1->m_RectScreen.right;
            v50.left = v1->m_RectScreen.left;
            v50.right = v35;
            v50.top = v20;
            v50.bottom = v20 - v8;
            CRGBA::CRGBA(v33, 0, 0, 0, v46);
            CRGBA::CRGBA(&v51, 0, 0, 0, v46);
            CRGBA::CRGBA(&v49, 0, 0, 0, alpha);
            CRGBA::CRGBA(&v48, 0, 0, 0, alpha);
            CSprite2d::DrawRect(&v50, v33, &v51, &v49, v36);
            if ( !strlen((const char *)v34 - 264) || !strcasecmp((const char *)v34 - 136, "DUMMY") )
              break;
            if ( !strcasecmp((const char *)v34 - 136, "BJ_OR2") )
            {
              sprintf((unsigned __int8 *)v33, "%d/%d", *(v34 - 2), *(v34 - 1));
              AsciiToGxtChar((const Char *)v33, (GxtChar *)&Rectangle);
LABEL_51:
              v42 = CText::Get(&TheText, (const unsigned __int8 *)v34 - 264);
              CWidgetWager::RenderRowText((CWidgetWager *)v42, v42, (GxtChar *)&Rectangle, v50, *v34, v6);
              goto LABEL_52;
            }
            v37 = v33;
            v38 = CText::Get(&TheText, (const unsigned __int8 *)v34 - 264);
            v39 = CText::Get(&TheText, (const unsigned __int8 *)v34 - 136);
            v40 = v38;
            v33 = v37;
            CWidgetWager::RenderRowText((CWidgetWager *)v39, v40, v39, v50, *v34, v6);
LABEL_52:
            v20 = v20 - (float)(v8 + 1.0);
            v1 = v45;
            --v32;
            v34 -= 67;
            if ( v32 <= 1 )
              goto LABEL_56;
          }
          v41 = *(v34 - 2);
          if ( *v34 == 1 )
            sprintf((unsigned __int8 *)s, "$~1~%d", v41);
          else
            sprintf((unsigned __int8 *)s, (const unsigned __int8 *)&dword_2C9448, v41);
          AsciiToGxtChar((const Char *)s, (GxtChar *)&Rectangle);
          goto LABEL_51;
        }
      }
      v46 = (unsigned int)(float)(v6 * 128.0);
LABEL_56:
      v43 = v1->m_RectScreen.right;
      v54[0].left = v1->m_RectScreen.left;
      v54[0].right = v43;
      v54[0].top = v20;
      v54[0].bottom = v20 + (float)(v8 * -1.25);
      CRGBA::CRGBA((CRGBA *)&v50, 0, 0, 0, v46);
      CRGBA::CRGBA(&v51, 0, 0, 0, v46);
      CRGBA::CRGBA(&v49, 0, 0, 0, alpha);
      CRGBA::CRGBA(&v48, 0, 0, 0, alpha);
      CSprite2d::DrawRect(v54, (const CRGBA *)&v50, &v51, &v49, v44);
      CWidgetWager::RenderTitleText(v1, v54[0], v6);
    }
  }
}
// 2C8E5C: variable 'v7' is possibly undefined
// 2C9022: variable 'v21' is possibly undefined
// 2C92B2: variable 'v36' is possibly undefined
// 2C93F8: variable 'v44' is possibly undefined
// 2C9448: using guessed type int dword_2C9448;

//----- (002C9490) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CWidgetWager::RenderRowText(
        CWidgetWager *this,
        GxtChar *pGxtTop,
        GxtChar *pGxtBottom,
        CRect RectCell,
        int nColorIndex,
        float fAlpha)
{
  float left; // r5
  CRGBA v9; // r0
  float v10; // s22
  float Height; // r0
  float v12; // s18
  RwUInt8 red; // r1
  RwUInt8 green; // r2
  RwUInt8 blue; // r3
  unsigned int alpha; // r0
  CRGBA v17; // r0
  float v18; // r0
  CRGBA v19; // [sp+8h] [bp-40h] BYREF
  CRGBA v20; // [sp+Ch] [bp-3Ch] BYREF
  CRGBA v21; // [sp+10h] [bp-38h] BYREF
  CRGBA v22; // [sp+14h] [bp-34h] BYREF

  left = RectCell.left;
  CRGBA::CRGBA(&v22, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)(fAlpha * 255.0));
  CFont::SetColor(v9);
  v10 = fabsf(RectCell.right - left);
  Height = CFont::GetHeight(0);
  v12 = (float)(RectCell.top + RectCell.bottom) * 0.5;
  CFont::PrintString((float)(v10 * 0.0675) + left, v12 + (float)(Height * -1.25), pGxtTop);
  CFont::RenderFontBuffer();
  CRGBA::CRGBA(&v21, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
  if ( nColorIndex == 1 )
  {
    CRGBA::CRGBA(&v20, 0, 0x67u, 0, 0xFFu);
  }
  else
  {
    if ( nColorIndex != 2 )
    {
      red = v21._anon_0._anon_0.red;
      green = v21._anon_0._anon_0.green;
      blue = v21._anon_0._anon_0.blue;
      alpha = v21._anon_0._anon_0.alpha;
      goto LABEL_7;
    }
    CRGBA::CRGBA(&v20, 0x5Du, 0x8Eu, 0xBEu, 0xFFu);
  }
  red = v20._anon_0._anon_0.red;
  green = v20._anon_0._anon_0.green;
  blue = v20._anon_0._anon_0.blue;
  alpha = v20._anon_0._anon_0.alpha;
  v21 = v20;
LABEL_7:
  CRGBA::CRGBA(&v19, red, green, blue, (unsigned int)(float)((float)alpha * fAlpha));
  CFont::SetColor(v17);
  v18 = CFont::GetHeight(0);
  CFont::PrintString((float)(v10 * 0.0675) + left, v12 + (float)(v18 * 0.25), pGxtBottom);
  CFont::RenderFontBuffer();
}
// 2C9490: fragmented variable at 0:r3.4,4:^50.12 may be wrong
// 2C9490: variables would overlap: 0:r3.4,4:^50.12 and ^50.4
// 2C9490: variables would overlap: 0:r3.4,4:^50.12 and ^54.4
// 2C9490: variables would overlap: 0:r3.4,4:^50.12 and ^58.4

//----- (002C95E8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall CWidgetWager::RenderTitleText(CWidgetWager *this, CRect RectCell, float fAlpha)
{
  float right; // r8
  float top; // r4
  float left; // r5
  CRGBA v7; // r0
  float v8; // s0
  unsigned __int8 *m_szTitle; // r6
  GxtChar *v10; // r0
  float StringWidth; // r0
  float v12; // s24
  float v13; // s2
  GxtChar *v14; // r0
  CRGBA v15; // [sp+4h] [bp-3Ch] BYREF

  right = RectCell.right;
  top = RectCell.top;
  left = RectCell.left;
  CFont::SetFontStyle(0);
  CRGBA::CRGBA(&v15, 0xFFu, 0xFFu, 0xFFu, (unsigned int)(float)(fAlpha * 255.0));
  CFont::SetColor(v7);
  v8 = fabsf(top - RectCell.bottom);
  CFont::SetScale(v8 * 0.0325);
  m_szTitle = this->m_szTitle;
  v10 = CText::Get(&TheText, m_szTitle);
  StringWidth = CFont::GetStringWidth(v10, 1u, 0);
  v12 = fabsf(right - left);
  if ( StringWidth > (float)(v12 * 0.875) )
    CFont::SetScale((float)(v8 * 0.0325) * (float)((float)(v12 * 0.875) / StringWidth));
  v13 = CFont::GetHeight(0) * 0.5;
  v14 = CText::Get(&TheText, m_szTitle);
  CFont::PrintString((float)(v12 * 0.0675) + left, (float)((float)(top + RectCell.bottom) * 0.5) - v13, v14);
  CFont::RenderFontBuffer();
}
// 2C95E8: fragmented variable at 0:r1.12,12:^48.4 may be wrong
// 2C95E8: variables would overlap: 0:r1.12,12:^48.4 and ^48.4

//----- (002C9700) --------------------------------------------------------
void __fastcall CWidgetWager::SetWidgetInfo2(
        CWidgetWager *this,
        int nValue0,
        int nValue1,
        int nValue2,
        int nValue3,
        unsigned __int8 *pszText0,
        unsigned __int8 *pszText1)
{
  const char *v11; // r1
  const char *v12; // r5
  _DWORD v13[67]; // [sp+0h] [bp-130h] BYREF

  if ( (unsigned int)nValue0 <= 3 )
  {
    v11 = (const char *)pszText0;
    v12 = &byte_61CADE;
    if ( !pszText0 )
      v11 = &byte_61CADE;
    strcpy((char *)v13, v11);
    if ( pszText1 )
      v12 = (const char *)pszText1;
    strcpy((char *)&v13[32], v12);
    v13[64] = nValue1;
    v13[65] = nValue2;
    v13[66] = nValue3;
    qmemcpy(&this->m_DataCell[nValue0], v13, sizeof(this->m_DataCell[nValue0]));
  }
}
// 61CADE: using guessed type char byte_61CADE;

//----- (002C978C) --------------------------------------------------------
void __fastcall CWidgetWager::~CWidgetWager(CWidgetWager *this)
{
  void *v1; // r0

  CWidget::~CWidget(this);
  sub_191374(v1);
}
// 2C9798: variable 'v1' is possibly undefined

//----- (002C979C) --------------------------------------------------------
const unsigned __int8 *__fastcall CWidgetWager::GetName(CWidgetWager *this)
{
  return "Wager";
}

//----- (002C97A8) --------------------------------------------------------
void __fastcall CWidgetWager::SetWidgetValue(CWidgetWager *this, float fValue)
{
  this->m_bExtraCell = fValue == 1.0;
}

//----- (002C97C4) --------------------------------------------------------
void CdStreamInitThread()
{
  int v0; // r6
  int v1; // r4
  int v2; // r5
  OSMutex v3; // r0
  int v4; // r1

  v0 = gNumChannels;
  if ( gNumChannels < 1 )
  {
LABEL_6:
    gChannelRequestQ.pMem = (int *)malloc(4 * v0 + 4);
    memset(gChannelRequestQ.pMem, 0, 4 * v0 + 4);
    gChannelRequestQ.first = 0;
    gChannelRequestQ.last = 0;
    gChannelRequestQ.size = v0 + 1;
    cdSemaphore = OS_SemaphoreCreate();
    if ( cdSemaphore )
    {
      cdThread = OS_ThreadLaunch(CdStreamThread, 0, 3u, "CdStream", 0, 3);
      if ( cdThread )
        sub_19FBF8();
    }
  }
  else
  {
    v1 = 0;
    v2 = 20;
    while ( 1 )
    {
      *(unsigned int *)((char *)&gpReadInfo->posn + v2) = (unsigned int)OS_SemaphoreCreate();
      v3 = OS_MutexCreate(0);
      v4 = *(unsigned int *)((char *)&gpReadInfo->posn + v2);
      *(unsigned int *)((char *)&gpReadInfo->size + v2) = (unsigned int)v3;
      if ( !v3 || !v4 )
        break;
      v0 = gNumChannels;
      ++v1;
      v2 += 32;
      if ( v1 >= gNumChannels )
        goto LABEL_6;
    }
  }
}

//----- (002C98A8) --------------------------------------------------------
unsigned int __fastcall __noreturn CdStreamThread(void *data)
{
  __int64 v1; // r0
  int v2; // r2
  CdStreamReadInfo *v3; // r3
  CdStreamReadInfo *v4; // r9
  OSFileError v5; // r0

  while ( 1 )
  {
    OS_SemaphoreWait(cdSemaphore);
    v1 = *(_QWORD *)&gChannelRequestQ.first;
    v2 = -1;
    if ( gChannelRequestQ.first != gChannelRequestQ.last )
      v2 = gChannelRequestQ.pMem[gChannelRequestQ.first];
    v3 = gpReadInfo;
    v4 = &gpReadInfo[v2];
    v4->loading = 1;
    if ( v4->error )
      break;
    OS_FileSetPosition(v4->hImgFile, v3[v2].posn << 11);
    v5 = OS_FileRead(v4->hImgFile, v4->pBuffer, v4->size << 11);
    if ( v5 )
      v5 = 254;
    v4->error = v5;
    LODWORD(v1) = gChannelRequestQ.first;
    if ( gChannelRequestQ.first != gChannelRequestQ.last )
      goto LABEL_13;
LABEL_2:
    OS_MutexObtain(v4->mutex);
    v4->size = 0;
    if ( v4->sync )
      OS_SemaphorePost(v4->semaphore);
    v4->loading = 0;
    OS_MutexRelease(v4->mutex);
  }
  if ( (_DWORD)v1 == HIDWORD(v1) )
    goto LABEL_2;
LABEL_13:
  gChannelRequestQ.first = ((int)v1 + 1) % gChannelRequestQ.size;
  goto LABEL_2;
}

//----- (002C998C) --------------------------------------------------------
void __fastcall CdStreamInit(int numChannels)
{
  size_t v1; // r4

  *(_QWORD *)&gImgHandleArray[28] = 0LL;
  *(_QWORD *)&gImgHandleArray[30] = 0LL;
  *(_QWORD *)&gImgHandleArray[24] = 0LL;
  *(_QWORD *)&gImgHandleArray[26] = 0LL;
  *(_QWORD *)&gImgHandleArray[20] = 0LL;
  *(_QWORD *)&gImgHandleArray[22] = 0LL;
  *(_QWORD *)&gImgHandleArray[16] = 0LL;
  *(_QWORD *)&gImgHandleArray[18] = 0LL;
  *(_QWORD *)&gImgHandleArray[12] = 0LL;
  *(_QWORD *)&gImgHandleArray[14] = 0LL;
  *(_QWORD *)&gImgHandleArray[8] = 0LL;
  *(_QWORD *)&gImgHandleArray[10] = 0LL;
  v1 = 32 * numChannels;
  *(_QWORD *)gImgHandleArray = 0LL;
  *(_QWORD *)&gImgHandleArray[2] = 0LL;
  *(_QWORD *)&gImgHandleArray[4] = 0LL;
  *(_QWORD *)&gImgHandleArray[6] = 0LL;
  gNumChannels = numChannels;
  gCdImageNames[0][0] = 0;
  gCdImageNames[1][0] = 0;
  gCdImageNames[2][0] = 0;
  gCdImageNames[3][0] = 0;
  gCdImageNames[4][0] = 0;
  gCdImageNames[5][0] = 0;
  gCdImageNames[6][0] = 0;
  gCdImageNames[7][0] = 0;
  gCdImageNames[8][0] = 0;
  gCdImageNames[9][0] = 0;
  gCdImageNames[11][0] = 0;
  gCdImageNames[10][0] = 0;
  gCdImageNames[12][0] = 0;
  gCdImageNames[13][0] = 0;
  gCdImageNames[14][0] = 0;
  gCdImageNames[15][0] = 0;
  gCdImageNames[16][0] = 0;
  gCdImageNames[17][0] = 0;
  gCdImageNames[18][0] = 0;
  gCdImageNames[19][0] = 0;
  gCdImageNames[20][0] = 0;
  gCdImageNames[21][0] = 0;
  gCdImageNames[22][0] = 0;
  gCdImageNames[23][0] = 0;
  gCdImageNames[24][0] = 0;
  gCdImageNames[25][0] = 0;
  gCdImageNames[26][0] = 0;
  gCdImageNames[27][0] = 0;
  gCdImageNames[28][0] = 0;
  gCdImageNames[30][0] = 0;
  gCdImageNames[29][0] = 0;
  gCdImageNames[31][0] = 0;
  gpReadInfo = (CdStreamReadInfo *)malloc(32 * numChannels);
  memset(gpReadInfo, 0, v1);
  CdStreamInitThread();
}

//----- (002C9A88) --------------------------------------------------------
int32 GetGTA3ImgSize()
{
  return sub_193A6C(gImgHandleArray[0]);
}

//----- (002C9A98) --------------------------------------------------------
void CdStreamShutdown()
{
  int v0; // r5
  int v1; // r4
  CdStreamReadInfo *v2; // r0

  free(gChannelRequestQ.pMem);
  OS_SemaphoreDelete(cdSemaphore);
  OS_ThreadClose(cdThread);
  StopTexdbThread();
  if ( gNumChannels <= 0 )
  {
    v2 = gpReadInfo;
  }
  else
  {
    v0 = 20;
    v1 = 0;
    v2 = gpReadInfo;
    do
    {
      OS_SemaphoreDelete(*(OSSemaphore *)((char *)&v2->posn + v0));
      OS_MutexDelete(*(OSMutex *)((char *)&gpReadInfo->size + v0));
      v2 = gpReadInfo;
      ++v1;
      *(unsigned int *)((char *)&gpReadInfo->posn + v0) = 0;
      v0 += 32;
    }
    while ( v1 < gNumChannels );
  }
  j_free(v2);
}

//----- (002C9B3C) --------------------------------------------------------
int __fastcall CdStreamRead(int cid, void *pBuffer, unsigned int posn, unsigned int size)
{
  CdStreamReadInfo *v4; // lr
  CdStreamReadInfo *v5; // r4
  int v6; // r12
  int last; // r2

  v4 = gpReadInfo;
  lastPosnRead = size + posn;
  v5 = &gpReadInfo[cid];
  v5->hImgFile = gImgHandleArray[HIBYTE(posn)];
  if ( v5->size )
    return 0;
  v6 = 0;
  if ( !v5->loading )
  {
    v5->error = 0;
    v4[cid].posn = posn & 0xFFFFFF;
    v5->size = size;
    v5->pBuffer = pBuffer;
    v5->sync = 0;
    last = gChannelRequestQ.last;
    gChannelRequestQ.pMem[gChannelRequestQ.last] = cid;
    gChannelRequestQ.last = (last + 1) % gChannelRequestQ.size;
    OS_SemaphorePost(cdSemaphore);
    return 1;
  }
  return v6;
}

//----- (002C9BE0) --------------------------------------------------------
void __fastcall AddToQueue(Queue *pQ, int value)
{
  pQ->pMem[pQ->last] = value;
  pQ->last = (pQ->last + 1) % pQ->size;
}

//----- (002C9BFC) --------------------------------------------------------
int __fastcall CdStreamGetStatus(int cid)
{
  CdStreamReadInfo *v1; // r1
  int result; // r0
  int *p_error; // r1
  int error; // t1
  int v5; // r2

  v1 = &gpReadInfo[cid];
  if ( v1->loading )
    return 255;
  if ( v1->size )
    return 250;
  error = v1->error;
  p_error = &v1->error;
  result = 0;
  if ( error )
  {
    v5 = *p_error;
    *p_error = 0;
    return v5;
  }
  return result;
}

//----- (002C9C30) --------------------------------------------------------
int CdStreamGetLastPosn()
{
  return lastPosnRead;
}

//----- (002C9C3C) --------------------------------------------------------
int __fastcall CdStreamSync(int cid)
{
  CdStreamReadInfo *v1; // r4
  OSMutex *p_mutex; // r5

  v1 = &gpReadInfo[cid];
  p_mutex = &v1->mutex;
  OS_MutexObtain(v1->mutex);
  if ( v1->size )
  {
    v1->sync = 1;
    OS_MutexRelease(*p_mutex);
    OS_SemaphoreWait(v1->semaphore);
    v1->loading = 0;
  }
  else
  {
    v1->loading = 0;
    OS_MutexRelease(*p_mutex);
  }
  return v1->error;
}

//----- (002C9C84) --------------------------------------------------------
int __fastcall GetFirstInQueue(Queue *pQ)
{
  __int64 v1; // kr00_8

  v1 = *(_QWORD *)&pQ->first;
  if ( (_DWORD)v1 == HIDWORD(v1) )
    return -1;
  else
    return pQ->pMem[v1];
}

//----- (002C9C98) --------------------------------------------------------
void __fastcall RemoveFirstInQueue(Queue *pQ)
{
  __int64 v2; // r0

  v2 = *(_QWORD *)&pQ->first;
  if ( (_DWORD)v2 != HIDWORD(v2) )
    pQ->first = ((int)v2 + 1) % pQ->size;
}

//----- (002C9CB4) --------------------------------------------------------
void CdStreamRemoveImages()
{
  int v0; // r4
  int v1; // r5
  CdStreamReadInfo *v2; // r6

  if ( gNumChannels >= 1 )
  {
    v0 = 0;
    v1 = 0;
    do
    {
      v2 = &gpReadInfo[v0];
      OS_MutexObtain(gpReadInfo[v0].mutex);
      if ( v2->size )
      {
        v2->sync = 1;
        OS_MutexRelease(v2->mutex);
        OS_SemaphoreWait(v2->semaphore);
        v2->loading = 0;
      }
      else
      {
        v2->loading = 0;
        OS_MutexRelease(v2->mutex);
      }
      ++v0;
      ++v1;
    }
    while ( v1 < gNumChannels );
  }
}

//----- (002C9D38) --------------------------------------------------------
int __fastcall CdStreamOpen(const unsigned __int8 *pFilename, bool bUseHardDrive)
{
  int v3; // r0
  int v4; // r6
  int v6; // r5

  v3 = 0;
  while ( gImgHandleArray[v3] )
  {
    v4 = v3 + 1;
    if ( v3++ >= 31 )
      goto LABEL_6;
  }
  v4 = v3;
LABEL_6:
  v6 = 0;
  OS_FileOpen(OSFDA_Storage_0, &gImgHandleArray[v4], pFilename, OSFAT_Read_0);
  if ( gImgHandleArray[v4] )
  {
    strcpy((char *)gCdImageNames[v4], (const char *)pFilename);
    return v4 << 24;
  }
  return v6;
}

//----- (002C9D9C) --------------------------------------------------------
bool __fastcall CdStreamClose(int32 image)
{
  int32 v1; // r5
  bool v2; // r4
  OSFile v3; // r0

  v1 = image >> 24;
  v2 = 0;
  v3 = gImgHandleArray[image >> 24];
  if ( v3 )
  {
    OS_FileClose(v3);
    gImgHandleArray[v1] = 0;
    gCdImageNames[v1][0] = 0;
    return 1;
  }
  return v2;
}

//----- (002C9DD8) --------------------------------------------------------
bool CCarFXRenderer::Initialise()
{
  return CCustomCarEnvMapPipeline::CreatePipe() != 0;
}

//----- (002C9DE8) --------------------------------------------------------
void CCarFXRenderer::Shutdown()
{
  if ( CCarFXRenderer::ms_aDirtTextures[0] )
  {
    RwTextureDestroy(CCarFXRenderer::ms_aDirtTextures[0]);
    CCarFXRenderer::ms_aDirtTextures[0] = 0;
  }
  if ( CCarFXRenderer::ms_aDirtTextures[1] )
  {
    RwTextureDestroy(CCarFXRenderer::ms_aDirtTextures[1]);
    CCarFXRenderer::ms_aDirtTextures[1] = 0;
  }
  if ( CCarFXRenderer::ms_aDirtTextures[2] )
  {
    RwTextureDestroy(CCarFXRenderer::ms_aDirtTextures[2]);
    CCarFXRenderer::ms_aDirtTextures[2] = 0;
  }
  if ( CCarFXRenderer::ms_aDirtTextures[3] )
  {
    RwTextureDestroy(CCarFXRenderer::ms_aDirtTextures[3]);
    CCarFXRenderer::ms_aDirtTextures[3] = 0;
  }
  if ( CCarFXRenderer::ms_aDirtTextures[4] )
  {
    RwTextureDestroy(CCarFXRenderer::ms_aDirtTextures[4]);
    CCarFXRenderer::ms_aDirtTextures[4] = 0;
  }
  if ( CCarFXRenderer::ms_aDirtTextures[5] )
  {
    RwTextureDestroy(CCarFXRenderer::ms_aDirtTextures[5]);
    CCarFXRenderer::ms_aDirtTextures[5] = 0;
  }
  if ( CCarFXRenderer::ms_aDirtTextures[6] )
  {
    RwTextureDestroy(CCarFXRenderer::ms_aDirtTextures[6]);
    CCarFXRenderer::ms_aDirtTextures[6] = 0;
  }
  if ( CCarFXRenderer::ms_aDirtTextures[7] )
  {
    RwTextureDestroy(CCarFXRenderer::ms_aDirtTextures[7]);
    CCarFXRenderer::ms_aDirtTextures[7] = 0;
  }
  if ( CCarFXRenderer::ms_aDirtTextures[8] )
  {
    RwTextureDestroy(CCarFXRenderer::ms_aDirtTextures[8]);
    CCarFXRenderer::ms_aDirtTextures[8] = 0;
  }
  if ( CCarFXRenderer::ms_aDirtTextures[9] )
  {
    RwTextureDestroy(CCarFXRenderer::ms_aDirtTextures[9]);
    CCarFXRenderer::ms_aDirtTextures[9] = 0;
  }
  if ( CCarFXRenderer::ms_aDirtTextures[10] )
  {
    RwTextureDestroy(CCarFXRenderer::ms_aDirtTextures[10]);
    CCarFXRenderer::ms_aDirtTextures[10] = 0;
  }
  if ( CCarFXRenderer::ms_aDirtTextures[11] )
  {
    RwTextureDestroy(CCarFXRenderer::ms_aDirtTextures[11]);
    CCarFXRenderer::ms_aDirtTextures[11] = 0;
  }
  if ( CCarFXRenderer::ms_aDirtTextures[12] )
  {
    RwTextureDestroy(CCarFXRenderer::ms_aDirtTextures[12]);
    CCarFXRenderer::ms_aDirtTextures[12] = 0;
  }
  if ( CCarFXRenderer::ms_aDirtTextures[13] )
  {
    RwTextureDestroy(CCarFXRenderer::ms_aDirtTextures[13]);
    CCarFXRenderer::ms_aDirtTextures[13] = 0;
  }
  if ( CCarFXRenderer::ms_aDirtTextures[14] )
  {
    RwTextureDestroy(CCarFXRenderer::ms_aDirtTextures[14]);
    CCarFXRenderer::ms_aDirtTextures[14] = 0;
  }
  if ( CCarFXRenderer::ms_aDirtTextures[15] )
  {
    RwTextureDestroy(CCarFXRenderer::ms_aDirtTextures[15]);
    CCarFXRenderer::ms_aDirtTextures[15] = 0;
  }
  sub_19ABAC();
}

//----- (002C9FF4) --------------------------------------------------------
bool CCarFXRenderer::RegisterPlugins()
{
  return CCustomCarEnvMapPipeline::RegisterPlugin() != 0;
}

//----- (002CA00C) --------------------------------------------------------
RpClump_0 *__fastcall CCarFXRenderer::CustomCarPipeClumpSetup(RpClump_0 *pClump)
{
  RpClumpForAllAtomics(pClump, customCarPipelineSetupAtomicCB, 0);
  return pClump;
}

//----- (002CA028) --------------------------------------------------------
RpAtomic_0 *__fastcall CCarFXRenderer::SetCustomFXAtomicRenderPipelinesVMICB(RpAtomic_0 *pAtomic, void *pData)
{
  CCustomCarEnvMapPipeline::CustomPipeAtomicSetup(pAtomic);
  return pAtomic;
}

//----- (002CA036) --------------------------------------------------------
RwBool __fastcall CCarFXRenderer::IsCCPCPipelineAttached(RpAtomic_0 *pAtomic)
{
  return GetPipelineID(pAtomic) == 1408368794;
}

//----- (002CA050) --------------------------------------------------------
void __fastcall CCarFXRenderer::SetFxEnvMapLightMult(float m)
{
  CCustomCarEnvMapPipeline::m_EnvMapLightingMult = m;
}

//----- (002CA060) --------------------------------------------------------
float CCarFXRenderer::GetFxEnvMapLightMult()
{
  return CCustomCarEnvMapPipeline::m_EnvMapLightingMult;
}

//----- (002CA070) --------------------------------------------------------
RwBool CCarFXRenderer::InitialiseDirtTexture()
{
  int32 TxdSlot; // r4
  int v1; // r5
  RwTexture_0 *v2; // r0
  RwRaster_0 *v3; // r2
  __int64 v4; // kr00_8
  RwTexture_0 *v5; // r0
  RwUInt8 *v6; // r0
  RwUInt8 *v7; // r12
  int v8; // lr
  unsigned int v9; // r1
  RwUInt8 *v10; // r3
  int v11; // r4
  int v12; // r0
  int v13; // r2
  RwTexture_0 *pSrc; // [sp+4h] [bp-24h]
  RwRaster_0 *raster; // [sp+8h] [bp-20h]

  TxdSlot = CTxdStore::FindTxdSlot("vehicle");
  CTxdStore::PushCurrentTxd();
  v1 = 0;
  CTxdStore::SetCurrentTxd(TxdSlot, 0);
  v2 = RwTextureRead((const RwChar *)"vehiclegrunge256", 0);
  v3 = v2->raster;
  pSrc = v2;
  LOBYTE(v2->filterAddressing) = 2;
  v4 = *(_QWORD *)&v3->width;
  do
  {
    v5 = CClothesBuilder::CopyTexture(pSrc);
    CCarFXRenderer::ms_aDirtTextures[v1] = v5;
    RwTextureSetName(v5, (const RwChar *)"vehiclegrunge256");
    raster = CCarFXRenderer::ms_aDirtTextures[v1]->raster;
    v6 = RwRasterLock(raster, 0, 3);
    if ( SHIDWORD(v4) >= 1 )
    {
      v7 = v6 + 1;
      v8 = 0;
      v9 = (unsigned int)(255 * (16 - v1)) >> 4;
      do
      {
        v10 = v7;
        v11 = v4;
        if ( (int)v4 >= 1 )
        {
          do
          {
            --v11;
            v12 = v1 * *v10;
            v13 = v1 * v10[1];
            *(v10 - 1) = v9 + v1 * *(v10 - 1) / 16;
            *v10 = v9 + v12 / 16;
            v10[1] = v9 + v13 / 16;
            v10 += 4;
          }
          while ( v11 );
        }
        ++v8;
        v7 += 4 * v4;
      }
      while ( v8 != HIDWORD(v4) );
    }
    RwRasterUnlock(raster);
    ++v1;
  }
  while ( v1 != 16 );
  CTxdStore::PopCurrentTxd();
  return 1;
}

//----- (002CA17C) --------------------------------------------------------
RpMaterial_0 *__fastcall CCarFXRenderer::MaterialRemapDirtCB(RpMaterial_0 *pMaterial, void *pData)
{
  RwTexture_0 *texture; // r0

  texture = pMaterial->texture;
  if ( !texture
    || (*((int (__fastcall **)(RwChar *, const char *))RwEngineInstance + 68))(texture->name, "vehiclegrunge256") )
  {
    return pMaterial;
  }
  RpMaterialSetTexture(pMaterial, CCarFXRenderer::ms_aDirtTextures[(_DWORD)pData]);
  return pMaterial;
}

//----- (002CA1C4) --------------------------------------------------------
RpAtomic_0 *__fastcall CCarFXRenderer::AtomicRemapDirtCB(RpAtomic_0 *pAtomic, void *pData)
{
  RpGeometryForAllMaterials(pAtomic->geometry, CCarFXRenderer::MaterialRemapDirtCB, pData);
  return pAtomic;
}

//----- (002CA1E0) --------------------------------------------------------
void __fastcall CCarFXRenderer::RemapDirt(CVehicleModelInfo *pModelInfo, UInt32 dirtLevel)
{
  RpMaterial_0 **m_aDirtMaterials; // r5
  int i; // r6
  RpMaterial_0 *v5; // r0

  m_aDirtMaterials = pModelInfo->m_aDirtMaterials;
  for ( i = 0; i != 64; ++i )
  {
    v5 = m_aDirtMaterials[i];
    if ( v5 )
      RpMaterialSetTexture(v5, CCarFXRenderer::ms_aDirtTextures[dirtLevel]);
  }
}

//----- (002CA21C) --------------------------------------------------------
bool CCustomBuildingRenderer::Initialise()
{
  return CCustomBuildingPipeline::CreatePipe() && CCustomBuildingDNPipeline::CreatePipe();
}

//----- (002CA238) --------------------------------------------------------
void CCustomBuildingRenderer::Shutdown()
{
  CCustomBuildingPipeline::DestroyPipe();
  sub_18ACCC();
}

//----- (002CA248) --------------------------------------------------------
bool CCustomBuildingRenderer::PluginAttach()
{
  return CCustomBuildingDNPipeline::ExtraVertColourPluginAttach();
}

//----- (002CA258) --------------------------------------------------------
RpAtomic_0 *__fastcall CCustomBuildingRenderer::AtomicSetup(RpAtomic_0 *pAtomic)
{
  RpGeometry_0 *geometry; // r5
  uint8 *ExtraVertColourPtr; // r0
  bool v4; // zf

  geometry = pAtomic->geometry;
  if ( (geometry->flags & 0x208) == 520 )
    return sub_18BDB8(pAtomic);
  ExtraVertColourPtr = CCustomBuildingDNPipeline::GetExtraVertColourPtr(geometry);
  v4 = ExtraVertColourPtr == 0;
  if ( ExtraVertColourPtr )
    v4 = geometry->preLitLum == 0;
  if ( v4 )
    return sub_196300(pAtomic);
  else
    return sub_18BDB8(pAtomic);
}

//----- (002CA290) --------------------------------------------------------
RwBool __fastcall CCustomBuildingRenderer::IsCBPCPipelineAttached(RpAtomic_0 *pAtomic)
{
  RpGeometry_0 *geometry; // r4
  uint8 *ExtraVertColourPtr; // r0
  bool v4; // zf

  if ( (GetPipelineID(pAtomic) | 4) == 1408368796 )
    return 1;
  geometry = pAtomic->geometry;
  if ( (geometry->flags & 0x208) == 520 )
    return 1;
  ExtraVertColourPtr = CCustomBuildingDNPipeline::GetExtraVertColourPtr(geometry);
  v4 = ExtraVertColourPtr == 0;
  if ( ExtraVertColourPtr )
    v4 = geometry->preLitLum == 0;
  return !v4;
}

//----- (002CA2D0) --------------------------------------------------------
void CCustomBuildingRenderer::UpdateDayNightBalanceParam()
{
  float v0; // s2
  float v1; // s0

  v0 = (float)((float)CClock::ms_nGameClockSeconds / 60.0)
     + (float)(CClock::ms_nGameClockMinutes + 60 * CClock::ms_nGameClockHours);
  v1 = 1.0;
  if ( v0 >= 360.0 )
  {
    if ( v0 >= 420.0 )
    {
      if ( v0 >= 1200.0 )
      {
        if ( v0 < 1260.0 )
          v1 = (float)((float)(1260.0 - v0) / -60.0) + 1.0;
      }
      else
      {
        v1 = 0.0;
      }
    }
    else
    {
      v1 = (float)(420.0 - v0) / 60.0;
    }
  }
  CCustomBuildingDNPipeline::m_fDNBalanceParam = v1;
}

//----- (002CA3A4) --------------------------------------------------------
void CCustomBuildingRenderer::Update()
{
  float v0; // s2
  float v1; // s0

  v0 = (float)((float)CClock::ms_nGameClockSeconds / 60.0)
     + (float)(CClock::ms_nGameClockMinutes + 60 * CClock::ms_nGameClockHours);
  v1 = 1.0;
  if ( v0 >= 360.0 )
  {
    if ( v0 >= 420.0 )
    {
      if ( v0 >= 1200.0 )
      {
        if ( v0 < 1260.0 )
          v1 = (float)((float)(1260.0 - v0) / -60.0) + 1.0;
      }
      else
      {
        v1 = 0.0;
      }
    }
    else
    {
      v1 = (float)(420.0 - v0) / 60.0;
    }
  }
  CCustomBuildingDNPipeline::m_fDNBalanceParam = v1;
}

//----- (002CA47C) --------------------------------------------------------
bool CCustomBuildingDNPipeline::CreatePipe()
{
  CCustomBuildingDNPipeline::ObjPipeline = CCustomBuildingDNPipeline::CreateCustomObjPipe();
  return CCustomBuildingDNPipeline::ObjPipeline != 0;
}

//----- (002CA498) --------------------------------------------------------
RxPipeline_0 *CCustomBuildingDNPipeline::CreateCustomObjPipe()
{
  RxPipeline_0 *v0; // r4
  RxNodeDefinition_0 *OpenGLAtomicAllInOne; // r5
  RxPipeline_0 *v2; // r0
  RxPipeline_0 *v3; // r6
  RxPipelineNode_0 *NodeByName; // r5

  v0 = RxPipelineCreate();
  OpenGLAtomicAllInOne = RxNodeDefinitionGetOpenGLAtomicAllInOne();
  if ( !v0 )
    return 0;
  v2 = RxPipelineLock(v0);
  v3 = v2;
  if ( !v2 || !RxLockedPipeAddFragment(v2, 0, OpenGLAtomicAllInOne, 0) || !RxLockedPipeUnlock(v3) )
  {
    _rxPipelineDestroy(v0);
    return 0;
  }
  NodeByName = RxPipelineFindNodeByName(v0, OpenGLAtomicAllInOne->name, 0, 0);
  RxOpenGLAllInOneSetInstanceCallBack(NodeByName, CCustomBuildingDNPipeline::CustomPipeInstanceCB);
  RxOpenGLAllInOneSetRenderCallBack(
    NodeByName,
    (RxOpenGLAllInOneRenderCallBack)CCustomBuildingDNPipeline::CustomPipeRenderCB);
  v0->pluginId = 1408368792;
  v0->pluginData = 1408368792;
  return v0;
}

//----- (002CA518) --------------------------------------------------------
void CCustomBuildingDNPipeline::DestroyPipe()
{
  if ( CCustomBuildingDNPipeline::ObjPipeline )
  {
    _rxPipelineDestroy(CCustomBuildingDNPipeline::ObjPipeline);
    CCustomBuildingDNPipeline::ObjPipeline = 0;
  }
}

//----- (002CA548) --------------------------------------------------------
RpMaterial_0 *__fastcall CCustomBuildingDNPipeline::CustomPipeMaterialSetup(RpMaterial_0 *pMaterial, void *__unused__)
{
  CustomEnvMapPipeMaterialData *v3; // r0
  RwTexDictionary_0 *dict; // r1
  int v5; // r0
  _BOOL4 v6; // r0

  pMaterial->surfaceProps.specular = 0.0;
  if ( RpMatFXMaterialGetEffects(pMaterial) == rpMATFXEFFECTENVMAP )
  {
    v3 = CCustomCarEnvMapPipeline::DuplicateCustomEnvMapPipeMaterialData((CustomEnvMapPipeMaterialData **)((char *)pMaterial + CCustomCarEnvMapPipeline::ms_envMapPluginOffset));
    if ( v3 )
    {
      dict = (*(RwTexture_0 **)((char *)&pMaterial->texture + MatFXMaterialDataOffset))->dict;
      v3->pEnvTexture = (RwTexture_0 *)dict;
      if ( dict )
        LOWORD(dict[3].texturesInDict.link.next) = 4354;
    }
  }
  v5 = *(int *)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset);
  v6 = v5 && (float)((float)*(unsigned __int8 *)(v5 + 4) * 0.0039216) != 0.0 && *(_DWORD *)(v5 + 8) != 0;
  LODWORD(pMaterial->surfaceProps.specular) = v6 | LODWORD(pMaterial->surfaceProps.specular) & 0xFFFFFFF8;
  return pMaterial;
}
// 677174: using guessed type int *CCustomCarEnvMapPipeline::ms_envMapPluginOffset[2];

//----- (002CA5D8) --------------------------------------------------------
void __fastcall CCustomBuildingDNPipeline::SetFxEnvTexture(RpMaterial_0 *pMaterial, RwTexture_0 *fxTexture)
{
  CustomEnvMapPipeMaterialData *v4; // r0

  v4 = CCustomCarEnvMapPipeline::DuplicateCustomEnvMapPipeMaterialData((CustomEnvMapPipeMaterialData **)((char *)pMaterial + CCustomCarEnvMapPipeline::ms_envMapPluginOffset));
  if ( v4 )
  {
    if ( fxTexture )
    {
      v4->pEnvTexture = fxTexture;
    }
    else
    {
      if ( !pMaterial )
      {
        v4->pEnvTexture = 0;
        return;
      }
      fxTexture = (RwTexture_0 *)(*(RwTexture_0 **)((char *)&pMaterial->texture + MatFXMaterialDataOffset))->dict;
      v4->pEnvTexture = fxTexture;
      if ( !fxTexture )
        return;
    }
    LOWORD(fxTexture->filterAddressing) = 4354;
  }
}
// 677174: using guessed type int *CCustomCarEnvMapPipeline::ms_envMapPluginOffset[2];

//----- (002CA624) --------------------------------------------------------
float __fastcall CCustomBuildingDNPipeline::GetFxEnvShininess(RpMaterial_0 *pMaterial)
{
  int v1; // r0

  v1 = *(int *)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset);
  if ( v1 )
    return (float)*(unsigned __int8 *)(v1 + 4) * 0.0039216;
  else
    return 0.0;
}

//----- (002CA660) --------------------------------------------------------
RwTexture_0 *__fastcall CCustomBuildingDNPipeline::GetFxEnvTexture(RpMaterial_0 *pMaterial)
{
  int v1; // r0

  v1 = *(int *)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset);
  if ( v1 )
    return *(RwTexture_0 **)(v1 + 8);
  else
    return 0;
}

//----- (002CA678) --------------------------------------------------------
RpAtomic_0 *__fastcall CCustomBuildingDNPipeline::CustomPipeAtomicSetup(RpAtomic_0 *pAtomic)
{
  RpGeometryForAllMaterials(pAtomic->geometry, CCustomBuildingDNPipeline::CustomPipeMaterialSetup, 0);
  pAtomic->pipeline = CCustomBuildingDNPipeline::ObjPipeline;
  SetPipelineID(pAtomic, 0x53F20098u);
  return pAtomic;
}

//----- (002CA6B0) --------------------------------------------------------
RwBool __fastcall CCustomBuildingDNPipeline::UsesThisPipeline(RpAtomic_0 *pAtomic)
{
  return CCustomBuildingDNPipeline::ObjPipeline == pAtomic->pipeline;
}

//----- (002CA6C8) --------------------------------------------------------
RwBool __fastcall CCustomBuildingDNPipeline::CustomPipeInstanceCB(
        void *object,
        RxOpenGLMeshInstanceData_0 *instanceData,
        const RwBool instanceDLandVA,
        const RwBool reinstance)
{
  int v6; // r5
  signed int v8; // r9
  RwInt32 v9; // r10
  RwRGBA_0 *v10; // r11
  u_native emuArrayRef; // r0
  size_t vertexDataSize; // r0
  int v13; // r1
  char v14; // r3
  RwUInt32 numVertices; // r2
  RwUInt32 v16; // r1
  RwUInt8 *v17; // r11
  RwUInt16 *indexData; // r0
  GLsizei offset; // r5
  GLenum v20; // r2
  RwRGBA_0 *vertexColor; // [sp+18h] [bp-28h]
  RwRGBA_0 *secondVertexColor; // [sp+1Ch] [bp-24h]

  v6 = *((_DWORD *)object + 6);
  v8 = *(_DWORD *)(v6 + 8);
  v9 = *(_DWORD *)(v6 + 28);
  instanceData->vertexDesc = v8;
  if ( !reinstance || (*(_WORD *)(v6 + 12) & 0xFFF) != 0 )
  {
    if ( *(unsigned __int8 *)(v6 + 11) << 31 )
    {
      instanceData->vertexBufferRef = *(_DWORD *)(v6 + 84);
    }
    else
    {
      v10 = *(RwRGBA_0 **)(v6 + CCustomBuildingDNPipeline::ms_extraVertColourPluginOffset);
      vertexColor = *(RwRGBA_0 **)(CCustomBuildingDNPipeline::ms_extraVertColourPluginOffset + v6 + 4);
      if ( reinstance )
      {
        emuArrayRef = instanceData->emuArrayRef;
        if ( emuArrayRef )
          emu_ArraysDelete(emuArrayRef);
      }
      secondVertexColor = v10;
      if ( reinstance )
      {
        vertexDataSize = instanceData->vertexDataSize;
      }
      else
      {
        v13 = 24;
        v14 = 3;
        if ( (v8 & 0x10) == 0 )
          v13 = 12;
        numVertices = instanceData->numVertices;
        if ( (v8 & 8) != 0 )
          v13 += 8;
        if ( !RwHackNoCompressedTexCoords )
          v14 = 2;
        v16 = v13 + (v9 << v14);
        instanceData->vertexStride = v16;
        vertexDataSize = v16 * numVertices;
        instanceData->vertexDataSize = v16 * numVertices;
      }
      v17 = (RwUInt8 *)malloc(vertexDataSize);
      _rxOpenGLAllInOneAtomicInstanceVertexArray(
        instanceData,
        (const RpAtomic_0 *)object,
        (const RpGeometry_0 *)v6,
        (RpGeometryFlag_0)v8,
        v9,
        reinstance,
        v17,
        vertexColor,
        secondVertexColor);
      emu_ArraysReset();
      indexData = instanceData->indexData;
      if ( indexData )
        emu_ArraysIndices(indexData, 0x1403u, instanceData->numIndices);
      emu_ArraysVertex(v17, instanceData->vertexDataSize, instanceData->numVertices, instanceData->vertexStride);
      emu_ArraysVertexAttrib(0, 3, 0x1406u, 0, 0);
      offset = 12;
      if ( (v8 & 0x10) != 0 )
      {
        emu_ArraysVertexAttrib(2u, 3, 0x1406u, 0, 12);
        offset = 24;
      }
      if ( (v8 & 8) != 0 )
      {
        emu_ArraysVertexAttrib(3u, 4, 0x1401u, 1u, offset);
        emu_ArraysVertexAttrib(6u, 4, 0x1401u, 1u, offset + 4);
        offset += 8;
      }
      if ( v9 >= 1 )
      {
        if ( RwHackNoCompressedTexCoords )
          v20 = 5126;
        else
          v20 = 5123;
        emu_ArraysVertexAttrib(1u, 2, v20, 0, offset);
      }
      instanceData->emuArrayRef = emu_ArraysStore(reinstance != 0, 1u);
    }
  }
  return 1;
}

//----- (002CA85C) --------------------------------------------------------
void __fastcall CCustomBuildingDNPipeline::CustomPipeRenderCB(
        RwResEntry_0 *repEntry,
        void *object,
        RwUInt8 type,
        RwUInt32 flags)
{
  unsigned __int8 *texture; // r9
  int next_high; // r11
  RxOpenGLMeshInstanceData *p_prev; // r5
  RwUInt32 v8; // r4
  __int64 v9; // r0
  bool v10; // zf
  unsigned int v11; // r0
  unsigned __int8 *v12; // r6
  RpMaterial_0 *material; // r0
  int v14; // r8
  char *v15; // r0
  float v16; // s0
  int *v17; // r2
  int v18; // r4
  int v19; // r6
  int v20; // r0
  int v21; // s2
  float v22; // s0
  bool v23; // zf
  void *v24; // r1
  RwRenderState_0 v25; // r0

  emu_SetSecondVertexColor(1u, CCustomBuildingDNPipeline::m_fDNBalanceParam);
  next_high = HIWORD(repEntry[1].link.next);
  if ( HIWORD(repEntry[1].link.next) )
  {
    p_prev = (RxOpenGLMeshInstanceData *)&repEntry[1].link.prev;
    v8 = flags & 0x84;
    while ( 1 )
    {
      v9 = *(_QWORD *)&p_prev->material;
      --next_high;
      v10 = HIDWORD(v9) == 0;
      v11 = *(unsigned __int8 *)(v9 + 7);
      if ( !HIDWORD(v9) )
        v10 = v11 == 255;
      if ( v10 )
        break;
      if ( v11 )
      {
        emu_EnableAlphaModulate((float)v11 / 255.0);
        v12 = (_BYTE *)(&dword_0 + 1);
LABEL_10:
        _rwOpenGLSetRenderState(rwRENDERSTATEVERTEXALPHAENABLE, v12);
        if ( rwOpenGLLightingEnabled )
        {
          _rwOpenGLLightsSetMaterialProperties(p_prev->material, flags);
        }
        else
        {
          if ( rwOpenGLColorMaterialEnabled )
          {
            emu_glDisable(0xB57u);
            rwOpenGLColorMaterialEnabled = 0;
          }
          if ( (flags & 8) == 0 )
            emu_glColor4fv(rwOpenGLOpaqueBlack);
        }
        material = p_prev->material;
        v14 = LODWORD(material->surfaceProps.specular) & 1;
        if ( v14 )
        {
          texture = v12;
          v15 = *(char **)((char *)&material->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset);
          v16 = (float)(unsigned __int8)v15[4];
          v17 = (int *)*((_DWORD *)v15 + 2);
          v18 = v15[1];
          v19 = *v15;
          v20 = *v17;
          *((_BYTE *)v17 + 81) = 17;
          emu_SetEnvMap(*(void **)(v20 + RasterExtOffset), (float)(v16 * 0.0039216) * 1.5, 0);
          v21 = v18;
          v22 = (float)v19;
          v8 = flags & 0x84;
          v12 = texture;
          SetNormalMatrix(v22 * 0.125, (float)v21 * 0.125, 0.0, 0.0);
          doPop = 0;
        }
        v23 = v8 == 0;
        if ( v8 )
        {
          texture = (unsigned __int8 *)p_prev->material->texture;
          v23 = texture == 0;
        }
        if ( v23 )
        {
          v25 = rwRENDERSTATETEXTURERASTER;
          v24 = 0;
          goto LABEL_24;
        }
        if ( *(unsigned __int8 *)(*(_DWORD *)texture + 48) << 31 )
        {
          if ( v12 )
            emu_DisableAlphaModulate();
          ++p_prev;
          if ( !(next_high << 16) )
            goto LABEL_36;
        }
        else
        {
          _rwOpenGLSetRenderStateNoExtras(rwRENDERSTATETEXTURERASTER, *(void **)texture);
          v24 = (void *)texture[80];
          v25 = rwRENDERSTATETEXTUREFILTER;
LABEL_24:
          _rwOpenGLSetRenderState(v25, v24);
          RxOpenGLMeshInstanceData::DrawStored(p_prev++);
          if ( v12 )
            emu_DisableAlphaModulate();
          if ( v14 )
          {
            emu_ResetEnvMap();
            if ( !doPop )
            {
              emu_glPopMatrix();
              emu_glMatrixMode(0x1700u);
            }
          }
          if ( !(next_high << 16) )
            goto LABEL_36;
        }
      }
      else
      {
        ++p_prev;
        if ( !(next_high << 16) )
          goto LABEL_36;
      }
    }
    v12 = 0;
    goto LABEL_10;
  }
LABEL_36:
  sub_19A1C8(0, 0.0);
}
// 2CA9CE: variable 'texture' is possibly undefined
// 0: using guessed type int dword_0;
// 677174: using guessed type int *CCustomCarEnvMapPipeline::ms_envMapPluginOffset[2];
// 70BF44: using guessed type char doPop;

//----- (002CAA8C) --------------------------------------------------------
void __fastcall SetEnvMapTexture(RwTexture_0 *tex, float shininess, float scaleX, float scaleY, RwV2d_0 offset)
{
  RwRaster_0 *raster; // r3

  raster = tex->raster;
  BYTE1(tex->filterAddressing) = 17;
  emu_SetEnvMap(*(void **)((char *)&raster->parent + RasterExtOffset), shininess * 1.5, 0);
  SetNormalMatrix(scaleX, scaleY, offset.x, offset.y);
  doPop = 0;
}
// 70BF44: using guessed type char doPop;

//----- (002CAAE4) --------------------------------------------------------
void ResetEnvMap()
{
  emu_ResetEnvMap();
  if ( !doPop )
  {
    emu_glPopMatrix();
    sub_19C104(0x1700u);
  }
}
// 70BF44: using guessed type char doPop;

//----- (002CAB0C) --------------------------------------------------------
bool CCustomBuildingDNPipeline::ExtraVertColourPluginAttach()
{
  int v0; // r4

  v0 = 0;
  CCustomBuildingDNPipeline::ms_extraVertColourPluginOffset = -1;
  CCustomBuildingDNPipeline::ms_extraVertColourPluginOffset = RpGeometryRegisterPlugin(
                                                                12,
                                                                0x253F2F9u,
                                                                CCustomBuildingDNPipeline::pluginExtraVertColourConstructorCB,
                                                                CCustomBuildingDNPipeline::pluginExtraVertColourDestructorCB,
                                                                0);
  if ( CCustomBuildingDNPipeline::ms_extraVertColourPluginOffset != -1 )
  {
    if ( RpGeometryRegisterPluginStream(
           0x253F2F9u,
           CCustomBuildingDNPipeline::pluginExtraVertColourStreamReadCB,
           CCustomBuildingDNPipeline::pluginExtraVertColourStreamWriteCB,
           CCustomBuildingDNPipeline::pluginExtraVertColourStreamGetSizeCB) < 0 )
    {
      v0 = 0;
      CCustomBuildingDNPipeline::ms_extraVertColourPluginOffset = -1;
    }
    else
    {
      return CCustomBuildingDNPipeline::ms_extraVertColourPluginOffset != -1;
    }
  }
  return v0;
}

//----- (002CABB0) --------------------------------------------------------
void *__fastcall CCustomBuildingDNPipeline::pluginExtraVertColourConstructorCB(
        void *object,
        RwInt32 offset,
        RwInt32 size)
{
  int32 v3; // r1
  char *v4; // r1

  v3 = CCustomBuildingDNPipeline::ms_extraVertColourPluginOffset;
  if ( CCustomBuildingDNPipeline::ms_extraVertColourPluginOffset >= 1 )
  {
    *(_DWORD *)((char *)object + CCustomBuildingDNPipeline::ms_extraVertColourPluginOffset) = 0;
    v4 = (char *)object + v3;
    *((_DWORD *)v4 + 1) = 0;
    *((_DWORD *)v4 + 2) = 0;
  }
  return object;
}

//----- (002CABCC) --------------------------------------------------------
void *__fastcall CCustomBuildingDNPipeline::pluginExtraVertColourDestructorCB(
        void *object,
        RwInt32 offset,
        RwInt32 size)
{
  int32 v4; // r1
  void *v5; // r0
  void *v6; // r0

  v4 = CCustomBuildingDNPipeline::ms_extraVertColourPluginOffset;
  v5 = *(void **)((char *)object + CCustomBuildingDNPipeline::ms_extraVertColourPluginOffset);
  if ( v5 )
  {
    CMemoryMgr::Free(v5);
    *(_DWORD *)((char *)object + CCustomBuildingDNPipeline::ms_extraVertColourPluginOffset) = 0;
    v4 = CCustomBuildingDNPipeline::ms_extraVertColourPluginOffset;
  }
  v6 = *(void **)((char *)object + v4 + 4);
  if ( v6 )
  {
    CMemoryMgr::Free(v6);
    *(_DWORD *)((char *)object + CCustomBuildingDNPipeline::ms_extraVertColourPluginOffset + 4) = 0;
  }
  return object;
}

//----- (002CAC18) --------------------------------------------------------
RwStream_0 *__fastcall CCustomBuildingDNPipeline::pluginExtraVertColourStreamReadCB(
        RwStream_0 *pStream,
        RwInt32 len,
        void *pData,
        RwInt32 offset,
        RwInt32 size)
{
  int32 v8; // r6
  char *v9; // r6
  int v10; // r1
  unsigned int v11; // r6
  int v12; // r1
  char *v13; // r12
  int v14; // r5
  unsigned int v15; // r0
  bool v16; // cf
  char *v17; // r2
  unsigned int v18; // r0
  int v19; // r1
  int v20; // r3
  char *v21; // r4
  _BYTE *v22; // r6
  int v23; // r6
  int v25; // r3
  char *v26; // r2
  const char *v27; // r0
  const char *v28; // r0
  char *v29; // r2
  int buffer[7]; // [sp+4h] [bp-1Ch] BYREF
  int8x8x4_t v31; // 0:d16.8,8:d18.8,16:d20.8,24:d22.8
  int8x8x4_t v32; // 0:d17.8,8:d19.8,16:d21.8,24:d23.8

  v8 = CCustomBuildingDNPipeline::ms_extraVertColourPluginOffset;
  RwStreamRead(pStream, buffer, 4u);
  if ( buffer[0] )
  {
    v9 = (char *)pData + v8;
    v10 = *((_DWORD *)pData + 5);
    *((_DWORD *)pData + 2) |= 0x200u;
    *(_DWORD *)v9 = CMemoryMgr::Malloc(4 * v10);
    *(_QWORD *)(v9 + 4) = (unsigned int)CMemoryMgr::Malloc(4 * *((_DWORD *)pData + 5)) | 0x3F80000000000000LL;
    RwStreamRead(pStream, *(void **)v9, 4 * *((_DWORD *)pData + 5));
    v11 = *((_DWORD *)pData + 12);
    if ( v11 )
    {
      v12 = *((_DWORD *)pData + 5);
      if ( v12 >= 1 )
      {
        v13 = *(char **)((char *)pData + CCustomBuildingDNPipeline::ms_extraVertColourPluginOffset + 4);
        if ( (unsigned int)v12 < 0x10 )
          goto LABEL_9;
        v14 = v12 & 0x7FFFFFF0;
        if ( (v12 & 0xFFFFFFF0) == 0 )
          goto LABEL_9;
        v15 = v11 + 4 * v12;
        v16 = (unsigned int)v13 >= v15;
        if ( (unsigned int)v13 < v15 )
          v16 = v11 >= (unsigned int)&v13[4 * v12];
        if ( !v16 )
        {
LABEL_9:
          v14 = 0;
LABEL_10:
          v17 = &v13[4 * v14];
          v18 = v11 + 4 * v14;
          v19 = v12 - v14;
          v20 = 0;
          do
          {
            v21 = &v17[v20];
            v17[v20] = *(_BYTE *)(v18 + v20);
            v22 = (_BYTE *)(v18 + v20);
            v20 += 4;
            --v19;
            v21[2] = v22[2];
            v21[1] = v22[1];
            v21[3] = v22[3];
          }
          while ( v19 );
          return pStream;
        }
        v25 = v12 & 0x7FFFFFF0;
        v26 = v13;
        v27 = (const char *)v11;
        do
        {
          v31 = vld4_s8(v27);
          v28 = v27 + 32;
          v25 -= 16;
          v32 = vld4_s8(v28);
          v27 = v28 + 32;
          vst4_s8(v26, v31);
          v29 = v26 + 32;
          vst4_s8(v29, v32);
          v26 = v29 + 32;
        }
        while ( v25 );
        if ( v12 != v14 )
          goto LABEL_10;
      }
    }
  }
  else if ( len >= 5 )
  {
    v23 = 4 - len;
    do
    {
      RwStreamRead(pStream, buffer, 4u);
      v23 += 4;
    }
    while ( v23 );
  }
  return pStream;
}
// 2CAC8C: mask 0xFFFFFFF0 is shortened because r1.4 <= 0x7FFFFFFF
// 2CACF0: mask 0xFFFFFFF0 is shortened because r1.4 <= 0x7FFFFFFF

//----- (002CAD18) --------------------------------------------------------
RwStream_0 *__fastcall CCustomBuildingDNPipeline::pluginExtraVertColourStreamWriteCB(
        RwStream_0 *pStream,
        RwInt32 len,
        const void *pData,
        RwInt32 offset,
        RwInt32 size)
{
  const void *v7; // r6

  v7 = *(const void **)((char *)pData + CCustomBuildingDNPipeline::ms_extraVertColourPluginOffset);
  RwStreamWrite(pStream, v7, 4u);
  if ( v7 )
    RwStreamWrite(pStream, v7, 4 * *((_DWORD *)pData + 5));
  return pStream;
}

//----- (002CAD54) --------------------------------------------------------
RwInt32 __fastcall CCustomBuildingDNPipeline::pluginExtraVertColourStreamGetSizeCB(
        const void *pData,
        RwInt32 offset,
        RwInt32 size)
{
  RwInt32 result; // r0

  result = 0;
  if ( pData )
  {
    if ( *(_DWORD *)((char *)pData + CCustomBuildingDNPipeline::ms_extraVertColourPluginOffset) )
      return 4 * *((_DWORD *)pData + 5) + 4;
  }
  return result;
}

//----- (002CAD7C) --------------------------------------------------------
void __fastcall SwapColors(RpAtomic_0 *at)
{
  RpGeometry_0 *geometry; // r12
  int v2; // lr
  RwRGBA_0 *preLitLum; // r2
  bool v4; // zf
  unsigned int v5; // r3
  RwRGBA_0 v6; // r0

  geometry = at->geometry;
  v2 = *(_DWORD *)(&geometry->object.type + CCustomBuildingDNPipeline::ms_extraVertColourPluginOffset);
  if ( v2 )
  {
    preLitLum = geometry->preLitLum;
    v4 = preLitLum == 0;
    if ( preLitLum )
      v4 = geometry->numVertices == 0;
    if ( !v4 )
    {
      v5 = 0;
      do
      {
        v6 = preLitLum[v5];
        preLitLum[v5] = *(RwRGBA_0 *)(v2 + 4 * v5);
        *(RwRGBA_0 *)(v2 + 4 * v5++) = v6;
      }
      while ( v5 < geometry->numVertices );
    }
  }
}

//----- (002CADCC) --------------------------------------------------------
uint8 *__fastcall CCustomBuildingDNPipeline::GetExtraVertColourPtr(RpGeometry_0 *pGeom)
{
  return *(uint8 **)(&pGeom->object.type + CCustomBuildingDNPipeline::ms_extraVertColourPluginOffset);
}

//----- (002CADDC) --------------------------------------------------------
RwRGBA_0 *__fastcall GetExtraColorPtr(RpGeometry_0 *pGeom)
{
  return *(RwRGBA_0 **)(&pGeom->object.type + CCustomBuildingDNPipeline::ms_extraVertColourPluginOffset);
}

//----- (002CADEC) --------------------------------------------------------
void __fastcall CCustomBuildingDNPipeline::SetFxEnvScale(RpMaterial_0 *pMaterial, float envScaleX, float envScaleY)
{
  CustomEnvMapPipeMaterialData *v5; // r0

  v5 = CCustomCarEnvMapPipeline::DuplicateCustomEnvMapPipeMaterialData((CustomEnvMapPipeMaterialData **)((char *)pMaterial + CCustomCarEnvMapPipeline::ms_envMapPluginOffset));
  if ( v5 )
  {
    v5->cfEnvScaleY = (int)(float)(envScaleY * 8.0);
    v5->cfEnvScaleX = (int)(float)(envScaleX * 8.0);
  }
}
// 677174: using guessed type int *CCustomCarEnvMapPipeline::ms_envMapPluginOffset[2];

//----- (002CAE38) --------------------------------------------------------
float __fastcall CCustomBuildingDNPipeline::GetFxEnvScaleX(RpMaterial_0 *pMaterial)
{
  char *v1; // r0

  v1 = *(char **)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset);
  if ( v1 )
    return (float)*v1 * 0.125;
  else
    return 0.0;
}

//----- (002CAE74) --------------------------------------------------------
float __fastcall CCustomBuildingDNPipeline::GetFxEnvScaleY(RpMaterial_0 *pMaterial)
{
  int v1; // r0

  v1 = *(int *)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset);
  if ( v1 )
    return (float)*(char *)(v1 + 1) * 0.125;
  else
    return 0.0;
}

//----- (002CAEB0) --------------------------------------------------------
void __fastcall CCustomBuildingDNPipeline::SetFxEnvTransScl(RpMaterial_0 *pMaterial, float envTransX, float envTransY)
{
  CustomEnvMapPipeMaterialData *v5; // r0

  v5 = CCustomCarEnvMapPipeline::DuplicateCustomEnvMapPipeMaterialData((CustomEnvMapPipeMaterialData **)((char *)pMaterial + CCustomCarEnvMapPipeline::ms_envMapPluginOffset));
  if ( v5 )
  {
    v5->cfEnvTransSclY = (int)(float)(envTransY * 8.0);
    v5->cfEnvTransSclX = (int)(float)(envTransX * 8.0);
  }
}
// 677174: using guessed type int *CCustomCarEnvMapPipeline::ms_envMapPluginOffset[2];

//----- (002CAEFC) --------------------------------------------------------
float __fastcall CCustomBuildingDNPipeline::GetFxEnvTransSclX(RpMaterial_0 *pMaterial)
{
  int v1; // r0

  v1 = *(int *)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset);
  if ( v1 )
    return (float)*(char *)(v1 + 2) * 0.125;
  else
    return 0.0;
}

//----- (002CAF38) --------------------------------------------------------
float __fastcall CCustomBuildingDNPipeline::GetFxEnvTransSclY(RpMaterial_0 *pMaterial)
{
  int v1; // r0

  v1 = *(int *)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset);
  if ( v1 )
    return (float)*(char *)(v1 + 3) * 0.125;
  else
    return 0.0;
}

//----- (002CAF74) --------------------------------------------------------
void __fastcall CCustomBuildingDNPipeline::SetFxEnvShininess(RpMaterial_0 *pMaterial, float envShininess)
{
  CustomEnvMapPipeMaterialData *v3; // r0

  v3 = CCustomCarEnvMapPipeline::DuplicateCustomEnvMapPipeMaterialData((CustomEnvMapPipeMaterialData **)((char *)pMaterial + CCustomCarEnvMapPipeline::ms_envMapPluginOffset));
  if ( v3 )
    v3->cfShininess = (unsigned int)(float)(envShininess * 255.0);
}
// 677174: using guessed type int *CCustomCarEnvMapPipeline::ms_envMapPluginOffset[2];

//----- (002CAFB0) --------------------------------------------------------
void __fastcall SetNormalMatrix(float scaleX, float scaleY, RwReal a3, RwReal a4)
{
  RwMatrix *v6; // r4
  RwMatrix *v7; // r5
  RwMatrix *LTM; // r1
  __int64 *p_at; // r2
  _QWORD *p_x; // r0
  __int64 v11; // d16
  __int64 v12; // d17
  __int64 v13; // d23
  __int64 v14; // d18
  __int64 v15; // d19
  __int64 v16; // d20
  __int64 v17; // d21
  RwMatrix v18; // [sp+0h] [bp-60h] BYREF

  memset(&v18.right.y, 0, 16);
  memset(&v18.up.z, 0, 16);
  v18.right.x = scaleX;
  v18.up.y = scaleY;
  v18.at.z = 1.0;
  v18.pos.x = scaleX;
  v18.pad2 = 0;
  v18.pad3 = 0;
  v18.pos.y = scaleY;
  v18.pos.z = 0.0;
  emu_glMatrixMode(0x1702u);
  emu_glPushMatrix();
  emu_glLoadIdentity();
  v6 = RwMatrixCreate();
  v7 = RwMatrixCreate();
  LTM = RwFrameGetLTM(*(RwFrame_0 **)(*(_DWORD *)RwEngineInstance + 4));
  p_at = (__int64 *)&LTM->at;
  p_x = (_QWORD *)&LTM->pos.x;
  v11 = *(_QWORD *)&LTM->right.x;
  v12 = *(_QWORD *)&LTM->right.z;
  LTM = (RwMatrix *)((char *)LTM + 16);
  v13 = p_x[1];
  v14 = *p_at;
  v15 = p_at[1];
  v16 = *(_QWORD *)&LTM->right.x;
  v17 = *(_QWORD *)&LTM->right.z;
  *(_QWORD *)&v6->pos.x = *p_x;
  *(_QWORD *)&v6->pos.z = v13;
  *(_QWORD *)&v6->at.x = v14;
  *(_QWORD *)&v6->at.z = v15;
  *(_QWORD *)&v6->right.x = v11;
  *(_QWORD *)&v6->right.z = v12;
  v6->flags = 0;
  *(_QWORD *)&v6->up.x = v16;
  *(_QWORD *)&v6->up.z = v17;
  v6->pos.x = a3;
  v6->pos.y = a4;
  v6->pos.z = 0.0;
  RwMatrixMultiply(v7, v6, &v18);
  _rwOpenGLApplyRwMatrix(v7);
  RwMatrixDestroy(v6);
  RwMatrixDestroy(v7);
}

//----- (002CB084) --------------------------------------------------------
void __fastcall SetReflMap(float shininess)
{
  if ( CMirrors::reflBuffer[0] )
    emu_SetEnvMap(**(void ***)((char *)&CMirrors::reflBuffer[0]->stride + RasterExtOffset), shininess, 1);
  doPop = 1;
}
// 70BF44: using guessed type char doPop;

//----- (002CB0C8) --------------------------------------------------------
bool CCustomBuildingPipeline::CreatePipe()
{
  CCustomBuildingPipeline::ObjPipeline = CCustomBuildingPipeline::CreateCustomObjPipe();
  return CCustomBuildingPipeline::ObjPipeline != 0;
}

//----- (002CB0E4) --------------------------------------------------------
RxPipeline_0 *CCustomBuildingPipeline::CreateCustomObjPipe()
{
  RxPipeline_0 *v0; // r4
  RxNodeDefinition_0 *OpenGLAtomicAllInOne; // r5
  RxPipeline_0 *v2; // r0
  RxPipeline_0 *v3; // r6
  RxPipelineNode_0 *NodeByName; // r0

  v0 = RxPipelineCreate();
  OpenGLAtomicAllInOne = RxNodeDefinitionGetOpenGLAtomicAllInOne();
  if ( !v0 )
    return 0;
  v2 = RxPipelineLock(v0);
  v3 = v2;
  if ( !v2 || !RxLockedPipeAddFragment(v2, 0, OpenGLAtomicAllInOne, 0) || !RxLockedPipeUnlock(v3) )
  {
    _rxPipelineDestroy(v0);
    return 0;
  }
  NodeByName = RxPipelineFindNodeByName(v0, OpenGLAtomicAllInOne->name, 0, 0);
  RxOpenGLAllInOneSetRenderCallBack(
    NodeByName,
    (RxOpenGLAllInOneRenderCallBack)CCustomBuildingPipeline::CustomPipeRenderCB);
  v0->pluginId = 1408368796;
  v0->pluginData = 1408368796;
  return v0;
}

//----- (002CB150) --------------------------------------------------------
void CCustomBuildingPipeline::DestroyPipe()
{
  if ( CCustomBuildingPipeline::ObjPipeline )
  {
    _rxPipelineDestroy(CCustomBuildingPipeline::ObjPipeline);
    CCustomBuildingPipeline::ObjPipeline = 0;
  }
}

//----- (002CB180) --------------------------------------------------------
RpMaterial_0 *__fastcall CCustomBuildingPipeline::CustomPipeMaterialSetup(RpMaterial_0 *pMaterial, void *__unused__)
{
  CustomEnvMapPipeMaterialData *v3; // r0
  RwTexDictionary_0 *dict; // r1
  int v5; // r0
  _BOOL4 v6; // r0

  pMaterial->surfaceProps.specular = 0.0;
  if ( RpMatFXMaterialGetEffects(pMaterial) == rpMATFXEFFECTENVMAP )
  {
    v3 = CCustomCarEnvMapPipeline::DuplicateCustomEnvMapPipeMaterialData((CustomEnvMapPipeMaterialData **)((char *)pMaterial + CCustomCarEnvMapPipeline::ms_envMapPluginOffset));
    if ( v3 )
    {
      dict = (*(RwTexture_0 **)((char *)&pMaterial->texture + MatFXMaterialDataOffset))->dict;
      v3->pEnvTexture = (RwTexture_0 *)dict;
      if ( dict )
        LOWORD(dict[3].texturesInDict.link.next) = 4354;
    }
  }
  v5 = *(int *)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset);
  v6 = v5 && (float)((float)*(unsigned __int8 *)(v5 + 4) * 0.0039216) != 0.0 && *(_DWORD *)(v5 + 8) != 0;
  LODWORD(pMaterial->surfaceProps.specular) = v6 | LODWORD(pMaterial->surfaceProps.specular) & 0xFFFFFFF8;
  return pMaterial;
}
// 677174: using guessed type int *CCustomCarEnvMapPipeline::ms_envMapPluginOffset[2];

//----- (002CB210) --------------------------------------------------------
void __fastcall CCustomBuildingPipeline::SetFxEnvTexture(RpMaterial_0 *pMaterial, RwTexture_0 *fxTexture)
{
  CustomEnvMapPipeMaterialData *v4; // r0

  v4 = CCustomCarEnvMapPipeline::DuplicateCustomEnvMapPipeMaterialData((CustomEnvMapPipeMaterialData **)((char *)pMaterial + CCustomCarEnvMapPipeline::ms_envMapPluginOffset));
  if ( v4 )
  {
    if ( fxTexture )
    {
      v4->pEnvTexture = fxTexture;
    }
    else
    {
      if ( !pMaterial )
      {
        v4->pEnvTexture = 0;
        return;
      }
      fxTexture = (RwTexture_0 *)(*(RwTexture_0 **)((char *)&pMaterial->texture + MatFXMaterialDataOffset))->dict;
      v4->pEnvTexture = fxTexture;
      if ( !fxTexture )
        return;
    }
    LOWORD(fxTexture->filterAddressing) = 4354;
  }
}
// 677174: using guessed type int *CCustomCarEnvMapPipeline::ms_envMapPluginOffset[2];

//----- (002CB25C) --------------------------------------------------------
float __fastcall CCustomBuildingPipeline::GetFxEnvShininess(RpMaterial_0 *pMaterial)
{
  int v1; // r0

  v1 = *(int *)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset);
  if ( v1 )
    return (float)*(unsigned __int8 *)(v1 + 4) * 0.0039216;
  else
    return 0.0;
}

//----- (002CB298) --------------------------------------------------------
RwTexture_0 *__fastcall CCustomBuildingPipeline::GetFxEnvTexture(RpMaterial_0 *pMaterial)
{
  int v1; // r0

  v1 = *(int *)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset);
  if ( v1 )
    return *(RwTexture_0 **)(v1 + 8);
  else
    return 0;
}

//----- (002CB2B0) --------------------------------------------------------
RpAtomic_0 *__fastcall CCustomBuildingPipeline::CustomPipeAtomicSetup(RpAtomic_0 *pAtomic)
{
  RpGeometryForAllMaterials(pAtomic->geometry, CCustomBuildingPipeline::CustomPipeMaterialSetup, 0);
  pAtomic->pipeline = CCustomBuildingPipeline::ObjPipeline;
  SetPipelineID(pAtomic, 0x53F2009Cu);
  return pAtomic;
}

//----- (002CB2E8) --------------------------------------------------------
void __fastcall CCustomBuildingPipeline::CustomPipeRenderCB(
        RwResEntry_0 *repEntry,
        void *object,
        RwUInt8 type,
        RwUInt32 flags)
{
  RwTexture_0 *texture; // r11
  int next_high; // r4
  RxOpenGLMeshInstanceData *p_prev; // r5
  RwUInt32 v8; // r10
  __int64 v9; // r0
  bool v10; // zf
  unsigned int v11; // r0
  void *v12; // r6
  bool v13; // zf
  void *filterAddressing_low; // r1
  RwRenderState_0 v15; // r0
  RwUInt32 v16; // [sp+Ch] [bp-2Ch]

  next_high = HIWORD(repEntry[1].link.next);
  if ( HIWORD(repEntry[1].link.next) )
  {
    p_prev = (RxOpenGLMeshInstanceData *)&repEntry[1].link.prev;
    v8 = flags & 0x84;
    v16 = flags & 8;
    while ( 1 )
    {
      v9 = *(_QWORD *)&p_prev->material;
      --next_high;
      v10 = HIDWORD(v9) == 0;
      v11 = *(unsigned __int8 *)(v9 + 7);
      if ( !HIDWORD(v9) )
        v10 = v11 == 255;
      if ( v10 )
        break;
      if ( v11 )
      {
        emu_EnableAlphaModulate((float)v11 / 255.0);
        v12 = &dword_0 + 1;
LABEL_10:
        _rwOpenGLSetRenderState(rwRENDERSTATEVERTEXALPHAENABLE, v12);
        if ( rwOpenGLLightingEnabled )
        {
          _rwOpenGLLightsSetMaterialProperties(p_prev->material, flags);
        }
        else
        {
          if ( rwOpenGLColorMaterialEnabled )
          {
            emu_glDisable(0xB57u);
            rwOpenGLColorMaterialEnabled = 0;
          }
          if ( !v16 )
            emu_glColor4fv(rwOpenGLOpaqueBlack);
        }
        v13 = v8 == 0;
        if ( v8 )
        {
          texture = p_prev->material->texture;
          v13 = texture == 0;
        }
        if ( v13 )
        {
          v15 = rwRENDERSTATETEXTURERASTER;
          filterAddressing_low = 0;
          goto LABEL_22;
        }
        if ( LOBYTE(texture->raster->privateFlags) << 31 )
        {
          if ( v12 )
            emu_DisableAlphaModulate();
          ++p_prev;
          if ( !(next_high << 16) )
            return;
        }
        else
        {
          _rwOpenGLSetRenderStateNoExtras(rwRENDERSTATETEXTURERASTER, texture->raster);
          filterAddressing_low = (void *)LOBYTE(texture->filterAddressing);
          v15 = rwRENDERSTATETEXTUREFILTER;
LABEL_22:
          _rwOpenGLSetRenderState(v15, filterAddressing_low);
          RxOpenGLMeshInstanceData::DrawStored(p_prev++);
          if ( v12 )
            emu_DisableAlphaModulate();
          if ( !(next_high << 16) )
            return;
        }
      }
      else
      {
        ++p_prev;
        if ( !(next_high << 16) )
          return;
      }
    }
    v12 = 0;
    goto LABEL_10;
  }
}
// 2CB3AA: variable 'texture' is possibly undefined
// 0: using guessed type int dword_0;

//----- (002CB41C) --------------------------------------------------------
void __fastcall CCustomBuildingPipeline::SetFxEnvScale(RpMaterial_0 *pMaterial, float envScaleX, float envScaleY)
{
  CustomEnvMapPipeMaterialData *v5; // r0

  v5 = CCustomCarEnvMapPipeline::DuplicateCustomEnvMapPipeMaterialData((CustomEnvMapPipeMaterialData **)((char *)pMaterial + CCustomCarEnvMapPipeline::ms_envMapPluginOffset));
  if ( v5 )
  {
    v5->cfEnvScaleY = (int)(float)(envScaleY * 8.0);
    v5->cfEnvScaleX = (int)(float)(envScaleX * 8.0);
  }
}
// 677174: using guessed type int *CCustomCarEnvMapPipeline::ms_envMapPluginOffset[2];

//----- (002CB468) --------------------------------------------------------
float __fastcall CCustomBuildingPipeline::GetFxEnvScaleX(RpMaterial_0 *pMaterial)
{
  char *v1; // r0

  v1 = *(char **)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset);
  if ( v1 )
    return (float)*v1 * 0.125;
  else
    return 0.0;
}

//----- (002CB4A4) --------------------------------------------------------
float __fastcall CCustomBuildingPipeline::GetFxEnvScaleY(RpMaterial_0 *pMaterial)
{
  int v1; // r0

  v1 = *(int *)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset);
  if ( v1 )
    return (float)*(char *)(v1 + 1) * 0.125;
  else
    return 0.0;
}

//----- (002CB4E0) --------------------------------------------------------
void __fastcall CCustomBuildingPipeline::SetFxEnvTransScl(RpMaterial_0 *pMaterial, float envTransX, float envTransY)
{
  CustomEnvMapPipeMaterialData *v5; // r0

  v5 = CCustomCarEnvMapPipeline::DuplicateCustomEnvMapPipeMaterialData((CustomEnvMapPipeMaterialData **)((char *)pMaterial + CCustomCarEnvMapPipeline::ms_envMapPluginOffset));
  if ( v5 )
  {
    v5->cfEnvTransSclY = (int)(float)(envTransY * 8.0);
    v5->cfEnvTransSclX = (int)(float)(envTransX * 8.0);
  }
}
// 677174: using guessed type int *CCustomCarEnvMapPipeline::ms_envMapPluginOffset[2];

//----- (002CB52C) --------------------------------------------------------
float __fastcall CCustomBuildingPipeline::GetFxEnvTransSclX(RpMaterial_0 *pMaterial)
{
  int v1; // r0

  v1 = *(int *)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset);
  if ( v1 )
    return (float)*(char *)(v1 + 2) * 0.125;
  else
    return 0.0;
}

//----- (002CB568) --------------------------------------------------------
float __fastcall CCustomBuildingPipeline::GetFxEnvTransSclY(RpMaterial_0 *pMaterial)
{
  int v1; // r0

  v1 = *(int *)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset);
  if ( v1 )
    return (float)*(char *)(v1 + 3) * 0.125;
  else
    return 0.0;
}

//----- (002CB5A4) --------------------------------------------------------
void __fastcall CCustomBuildingPipeline::SetFxEnvShininess(RpMaterial_0 *pMaterial, float envShininess)
{
  CustomEnvMapPipeMaterialData *v3; // r0

  v3 = CCustomCarEnvMapPipeline::DuplicateCustomEnvMapPipeMaterialData((CustomEnvMapPipeMaterialData **)((char *)pMaterial + CCustomCarEnvMapPipeline::ms_envMapPluginOffset));
  if ( v3 )
    v3->cfShininess = (unsigned int)(float)(envShininess * 255.0);
}
// 677174: using guessed type int *CCustomCarEnvMapPipeline::ms_envMapPluginOffset[2];

//----- (002CB5E4) --------------------------------------------------------
RpMaterial_0 *__fastcall CCustomCarEnvMapPipeline::CustomPipeMaterialSetup(RpMaterial_0 *pMaterial, void *__unused__)
{
  int v3; // r0
  int v4; // r0
  int v5; // r1
  int v6; // r0
  int v7; // r1

  pMaterial->surfaceProps.specular = 0.0;
  if ( RpMatFXMaterialGetEffects(pMaterial) == rpMATFXEFFECTENVMAP )
    CCustomCarEnvMapPipeline::SetFxEnvTexture(pMaterial, 0);
  v3 = *(int *)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset);
  if ( v3 && (float)((float)*(unsigned __int8 *)(v3 + 4) * 0.0039216) != 0.0 && (v4 = *(_DWORD *)(v3 + 8)) != 0 )
  {
    v5 = *(unsigned __int8 *)(v4 + 16);
    v6 = 1;
    if ( v5 == 120 )
      v6 = 2;
  }
  else
  {
    v6 = 0;
  }
  v7 = *(int *)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_specularMapPluginOffset);
  if ( v7 && *(_DWORD *)(v7 + 4) )
    v6 |= 4u;
  LODWORD(pMaterial->surfaceProps.specular) = v6 | LODWORD(pMaterial->surfaceProps.specular) & 0xFFFFFFF8;
  return pMaterial;
}
// 677174: using guessed type int *CCustomCarEnvMapPipeline::ms_envMapPluginOffset[2];
// 6795C4: using guessed type int *CCustomCarEnvMapPipeline::ms_specularMapPluginOffset;

//----- (002CB67C) --------------------------------------------------------
void __fastcall CCustomCarEnvMapPipeline::SetFxEnvTexture(RpMaterial_0 *pMaterial, RwTexture_0 *fxTexture)
{
  int32 v2; // r12
  int v3; // r3
  int v4; // r4
  CustomEnvMapPipeMaterialDataPool *v5; // r3
  int32 m_nFreeIndex; // r2
  int32 m_nSize; // lr
  uint8 *m_aFlags; // r5
  int v9; // r6
  __int64 v10; // d16
  CustomEnvMapPipeMaterialDataPool *v11; // r1
  int v12; // r2

  v2 = CCustomCarEnvMapPipeline::ms_envMapPluginOffset;
  v3 = *(int *)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset);
  if ( (CustomEnvMapPipeMaterialData *)v3 == &CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData )
  {
    v4 = 0;
    v5 = CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool;
    m_nFreeIndex = CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool->m_nFreeIndex;
    m_nSize = CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool->m_nSize;
    do
    {
      v5->m_nFreeIndex = ++m_nFreeIndex;
      if ( m_nFreeIndex == m_nSize )
      {
        m_nFreeIndex = 0;
        v5->m_nFreeIndex = 0;
        if ( v4 << 31 )
        {
          *(RwTexture_0 **)((char *)&pMaterial->texture + v2) = 0;
          return;
        }
        v4 = 1;
      }
      m_aFlags = v5->m_aFlags;
      v9 = (char)m_aFlags[m_nFreeIndex];
    }
    while ( v9 > -1 );
    m_aFlags[m_nFreeIndex] = v9 & 0x7F;
    v5->m_aFlags[v5->m_nFreeIndex] = (v5->m_aFlags[v5->m_nFreeIndex] + 1) & 0x7F | v5->m_aFlags[v5->m_nFreeIndex] & 0x80;
    v3 = (int)v5->m_aStorage[v5->m_nFreeIndex];
    *(RwTexture_0 **)((char *)&pMaterial->texture + v2) = (RwTexture_0 *)v3;
    if ( !v3 )
      return;
    v10 = *(_QWORD *)&CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData.cfEnvScaleX;
    *(_DWORD *)(v3 + 8) = CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData.pEnvTexture;
    *(_QWORD *)v3 = v10;
  }
  else if ( !v3 )
  {
    return;
  }
  if ( fxTexture )
  {
    *(_DWORD *)(v3 + 8) = fxTexture;
LABEL_5:
    LOWORD(fxTexture->filterAddressing) = 4354;
    return;
  }
  fxTexture = (RwTexture_0 *)(*(RwTexture_0 **)((char *)&pMaterial->texture + MatFXMaterialDataOffset))->dict;
  *(_DWORD *)(v3 + 8) = fxTexture;
  if ( fxTexture && (float)((float)*(unsigned __int8 *)(v3 + 4) * 0.0039216) != 0.0 )
    goto LABEL_5;
  v11 = CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool;
  v12 = -1431655765
      * ((signed int)(v3 - (unsigned int)CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool->m_aStorage) >> 2);
  CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool->m_aFlags[v12] = CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool->m_aFlags[-1431655765 * ((signed int)(v3 - (unsigned int)CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool->m_aStorage) >> 2)] | 0x80;
  if ( v12 < v11->m_nFreeIndex )
    v11->m_nFreeIndex = v12;
  *(RwTexture_0 **)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset) = (RwTexture_0 *)&CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData;
  fxTexture = CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData.pEnvTexture;
  if ( CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData.pEnvTexture )
    goto LABEL_5;
}
// 2CB71E: conditional instruction was optimized away because r3.4!=0

//----- (002CB7C0) --------------------------------------------------------
float __fastcall CCustomCarEnvMapPipeline::GetFxEnvShininess(RpMaterial_0 *pMaterial)
{
  int v1; // r0

  v1 = *(int *)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset);
  if ( v1 )
    return (float)*(unsigned __int8 *)(v1 + 4) * 0.0039216;
  else
    return 0.0;
}

//----- (002CB7FC) --------------------------------------------------------
RwTexture_0 *__fastcall CCustomCarEnvMapPipeline::GetFxEnvTexture(RpMaterial_0 *pMaterial)
{
  int v1; // r0

  v1 = *(int *)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset);
  if ( v1 )
    return *(RwTexture_0 **)(v1 + 8);
  else
    return 0;
}

//----- (002CB814) --------------------------------------------------------
float __fastcall CCustomCarEnvMapPipeline::GetFxSpecSpecularity(RpMaterial_0 *pMaterial)
{
  float *v1; // r0

  v1 = *(float **)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_specularMapPluginOffset);
  if ( v1 )
    return *v1;
  else
    return 0.0;
}

//----- (002CB838) --------------------------------------------------------
RwTexture_0 *__fastcall CCustomCarEnvMapPipeline::GetFxSpecTexture(RpMaterial_0 *pMaterial)
{
  int v1; // r0

  v1 = *(int *)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_specularMapPluginOffset);
  if ( v1 )
    return *(RwTexture_0 **)(v1 + 4);
  else
    return 0;
}

//----- (002CB850) --------------------------------------------------------
RpAtomic_0 *__fastcall CCustomCarEnvMapPipeline::CustomPipeAtomicSetup(RpAtomic_0 *pAtomic)
{
  RpAtomic_0 *v2; // r5

  v2 = 0;
  RpGeometryForAllMaterials(pAtomic->geometry, CCustomCarEnvMapPipeline::CustomPipeMaterialSetup, 0);
  pAtomic->pipeline = CCustomCarEnvMapPipeline::ObjPipeline;
  if ( pAtomic )
  {
    SetPipelineID(pAtomic, 0x53F2009Au);
    return pAtomic;
  }
  return v2;
}

//----- (002CB890) --------------------------------------------------------
RwBool __fastcall CCustomCarEnvMapPipeline::CustomPipeInstanceCB(
        void *object,
        RxOpenGLMeshInstanceData_0 *instanceData,
        const RwBool instanceDLandVA,
        const RwBool reinstance)
{
  int v6; // r5
  signed int v8; // r9
  RwInt32 v9; // r11
  u_native emuArrayRef; // r0
  size_t vertexDataSize; // r0
  int v12; // r1
  char v13; // r3
  RwUInt32 numVertices; // r2
  RwUInt32 v15; // r1
  RwUInt8 *v16; // r10
  RwUInt16 *indexData; // r0
  GLsizei offset; // r5
  GLenum v19; // r2

  v6 = *((_DWORD *)object + 6);
  v8 = *(_DWORD *)(v6 + 8);
  v9 = *(_DWORD *)(v6 + 28);
  instanceData->vertexDesc = v8;
  if ( !reinstance || (*(_WORD *)(v6 + 12) & 0xFFF) != 0 )
  {
    if ( !(*(unsigned __int8 *)(v6 + 11) << 31) )
    {
      if ( reinstance )
      {
        emuArrayRef = instanceData->emuArrayRef;
        if ( emuArrayRef )
          emu_ArraysDelete(emuArrayRef);
      }
      if ( reinstance )
      {
        vertexDataSize = instanceData->vertexDataSize;
      }
      else
      {
        v12 = 24;
        v13 = 3;
        if ( (v8 & 0x10) == 0 )
          v12 = 12;
        numVertices = instanceData->numVertices;
        if ( (v8 & 8) != 0 )
          v12 += 4;
        if ( !RwHackNoCompressedTexCoords )
          v13 = 2;
        v15 = v12 + (v9 << v13);
        instanceData->vertexStride = v15;
        vertexDataSize = v15 * numVertices;
        instanceData->vertexDataSize = v15 * numVertices;
      }
      v16 = (RwUInt8 *)malloc(vertexDataSize);
      _rxOpenGLAllInOneAtomicInstanceVertexArray(
        instanceData,
        (const RpAtomic_0 *)object,
        (const RpGeometry_0 *)v6,
        (RpGeometryFlag_0)v8,
        v9,
        reinstance,
        v16,
        0,
        0);
      emu_ArraysReset();
      indexData = instanceData->indexData;
      if ( indexData )
        emu_ArraysIndices(indexData, 0x1403u, instanceData->numIndices);
      emu_ArraysVertex(v16, instanceData->vertexDataSize, instanceData->numVertices, instanceData->vertexStride);
      emu_ArraysVertexAttrib(0, 3, 0x1406u, 0, 0);
      offset = 12;
      if ( (v8 & 0x10) != 0 )
      {
        emu_ArraysVertexAttrib(2u, 3, 0x1406u, 0, 12);
        offset = 24;
        if ( (v8 & 8) == 0 )
        {
LABEL_21:
          if ( v9 >= 1 )
          {
LABEL_22:
            if ( RwHackNoCompressedTexCoords )
              v19 = 5126;
            else
              v19 = 5123;
            emu_ArraysVertexAttrib(1u, 2, v19, 0, offset);
          }
LABEL_26:
          instanceData->emuArrayRef = emu_ArraysStore(reinstance != 0, 1u);
          return 1;
        }
      }
      else if ( (v8 & 8) == 0 )
      {
        goto LABEL_21;
      }
      emu_ArraysVertexAttrib(3u, 4, 0x1401u, 1u, offset);
      offset += 4;
      if ( v9 >= 1 )
        goto LABEL_22;
      goto LABEL_26;
    }
    instanceData->vertexBufferRef = *(_DWORD *)(v6 + 84);
  }
  return 1;
}

//----- (002CBA00) --------------------------------------------------------
void __fastcall CCustomCarEnvMapPipeline::CustomPipeRenderCB(
        RwResEntry_0 *repEntry,
        void *object,
        RwUInt8 type,
        RwUInt32 flags)
{
  float32x2_t v4; // d6
  float32x2_t v5; // d7
  float32x2_t v6; // d8
  float32x2_t v7; // d11
  RwReal diffuse; // s29
  RwReal ambient; // s31
  __int16 AtomicId; // r6
  unsigned int v12; // r0
  _BOOL4 m_updatingShadows; // r8
  _BOOL4 v14; // r2
  int next_high; // r6
  RxOpenGLMeshInstanceData *p_prev; // r9
  RpMaterial_0 *material; // r5
  unsigned int blue; // r1
  int v19; // r0
  __int64 v20; // r0
  void *v21; // r4
  float v22; // s20
  RpMaterial_0 *v23; // r0
  RwReal specular; // r10
  int v25; // r2
  RwTexture_0 **v26; // r11
  int v27; // r4
  int v28; // r1
  int v29; // r2
  RwTexture_0 *texture; // r0
  int v31; // r0
  unsigned __int8 v32; // r6
  int v33; // r4
  int v34; // r8
  int v35; // r0
  RwFrame_0 **v36; // r1
  RwMatrix *LTM; // r0
  float y; // s6
  float v39; // s12
  float x; // s2
  float v41; // s0
  int red; // r0
  float v43; // s14
  float v44; // s0
  unsigned __int8 v45; // r10
  RpMaterial_0 *dbEntry; // r0
  void *v47; // r6
  RwTexture_0 *v48; // r4
  RwRaster_0 *raster; // r1
  bool v50; // zf
  void *filterAddressing_low; // r1
  RwRenderState_0 v52; // r0
  bool v53; // zf
  _BOOL4 v54; // [sp+20h] [bp-A0h]
  float *color; // [sp+4Ch] [bp-74h]
  _BOOL4 v58; // [sp+50h] [bp-70h]
  int v59; // [sp+54h] [bp-6Ch]
  void *v60; // [sp+58h] [bp-68h]
  int v61; // [sp+5Ch] [bp-64h]

  if ( (*(_BYTE *)(*((_DWORD *)object + 6) + 9) & 4) != 0 )
    return;
  AtomicId = CVisibilityPlugins::GetAtomicId((RpAtomic_0 *)object);
  v12 = CVisibilityPlugins::GetAtomicId((RpAtomic_0 *)object) & 0x4000;
  if ( (AtomicId & 0x6000) != 0 && !v12 )
  {
    m_updatingShadows = g_realTimeShadowMan.m_updatingShadows;
    v14 = 0;
LABEL_8:
    v58 = v14;
    goto LABEL_9;
  }
  m_updatingShadows = g_realTimeShadowMan.m_updatingShadows;
  v58 = 0;
  if ( MobileSettings::settings[7].value >= 1 && !g_realTimeShadowMan.m_updatingShadows )
  {
    m_updatingShadows = 0;
    v14 = CMirrors::TypeOfMirror != 3;
    goto LABEL_8;
  }
LABEL_9:
  next_high = HIWORD(repEntry[1].link.next);
  if ( HIWORD(repEntry[1].link.next) )
  {
    v61 = (pDirect->object.object.flags << 31 == 0) & (v12 >> 14);
    v7.n64_u32[0] = 1.0;
    p_prev = (RxOpenGLMeshInstanceData *)&repEntry[1].link.prev;
    v6.n64_u32[0] = 0;
    v54 = m_updatingShadows;
    color = &carLodLerp;
    while ( 1 )
    {
      material = p_prev->material;
      if ( v61 == 1 )
      {
        blue = material->color._anon_0._anon_0.blue;
        v19 = material->color._anon_0._anon_0.green >> 3;
        color = (float *)material->color;
        material->color._anon_0._anon_0.red = (unsigned __int8)color >> 3;
        material->color._anon_0._anon_0.green = v19;
        material->color._anon_0._anon_0.blue = blue >> 3;
        diffuse = material->surfaceProps.diffuse;
        ambient = material->surfaceProps.ambient;
        p_prev->material->surfaceProps.diffuse = 0.0;
        p_prev->material->surfaceProps.ambient = 0.0;
      }
      HIDWORD(v20) = p_prev->vertexAlpha;
      --next_high;
      LODWORD(v20) = material->color._anon_0._anon_0.alpha;
      if ( v20 == 255 )
        break;
      if ( material->color._anon_0._anon_0.alpha )
      {
        emu_EnableAlphaModulate((float)(unsigned int)v20 / 255.0);
        v21 = &dword_0 + 1;
LABEL_20:
        _rwOpenGLSetRenderState(rwRENDERSTATEVERTEXALPHAENABLE, v21);
        v60 = v21;
        if ( rwOpenGLLightingEnabled )
        {
          _rwOpenGLLightsSetMaterialProperties(p_prev->material, flags);
        }
        else
        {
          if ( rwOpenGLColorMaterialEnabled )
          {
            emu_glDisable(0xB57u);
            rwOpenGLColorMaterialEnabled = 0;
          }
          if ( (flags & 8) == 0 )
            emu_glColor4fv(rwOpenGLOpaqueBlack);
        }
        v22 = 0.0;
        v23 = p_prev->material;
        specular = v23->surfaceProps.specular;
        v25 = LOBYTE(specular) & 3;
        if ( (LOBYTE(specular) & 3) != 0 )
          v25 = 1;
        v26 = *(RwTexture_0 ***)((char *)&v23->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset);
        v27 = v58 & v25;
        if ( v26 )
          v22 = (float)*((unsigned __int8 *)v26 + 4) * 0.0039216;
        v28 = 0;
        v29 = 0;
        if ( v22 < 0.9 )
          v28 = 1;
        if ( LODWORD(specular) == 4 )
          v29 = 1;
        v59 = next_high;
        if ( MobileSettings::settings[7].value >= 2 && (v28 & v29 & v58) == 1 )
        {
          if ( material->color._anon_0._anon_0.red >= 0xF0u )
          {
            if ( material->color._anon_0._anon_0.green >= 0xF0u && material->color._anon_0._anon_0.blue >= 0xF0u )
              goto LABEL_44;
          }
          else if ( !material->color._anon_0._anon_0.red )
          {
            goto LABEL_44;
          }
          texture = v23->texture;
          if ( !texture || !strstr((const char *)texture->name, "interior") )
          {
            v22 = 0.2;
            v27 = 1;
          }
        }
LABEL_44:
        v31 = (int)v26;
        if ( v26 )
          v31 = 1;
        v32 = v27 & v31;
        if ( (v27 & v31) == 1 && carLodLerp < 1.0 )
        {
          v33 = *((char *)v26 + 2);
          v34 = *((char *)v26 + 3);
          v35 = *((_DWORD *)object + 15);
          v36 = (RwFrame_0 **)(v35 + 4);
          if ( !v35 )
            v36 = (RwFrame_0 **)((char *)object + 4);
          LTM = RwFrameGetLTM(*v36);
          y = LTM->pos.y;
          v39 = 0.05;
          x = LTM->pos.x;
          v41 = (float)((float)v34 * 0.125) * 50.0;
          if ( !v61 )
          {
            if ( LODWORD(specular) == 2 )
            {
              v39 = v22 * 0.125;
            }
            else if ( v60 )
            {
              v39 = v22;
            }
            else
            {
              red = material->color._anon_0._anon_0.red;
              v43 = (float)(material->color._anon_0._anon_0.green + red + material->color._anon_0._anon_0.blue);
              v4.n64_f32[0] = (float)((float)(255.0 - v43) + (float)(255.0 - v43)) / 255.0;
              v4.n64_u64[0] = vmax_f32(v4, v7).n64_u64[0];
              if ( red != 255 && v4.n64_f32[0] == 1.0 )
              {
                v4.n64_f32[0] = (float)(v43 / 600.0) * (float)(v43 / 600.0);
                v4.n64_u64[0] = vmax_f32(v4, v7).n64_u64[0];
              }
              v39 = v22 * v4.n64_f32[0];
            }
          }
          if ( carLodLerp > 0.0 )
          {
            v5.n64_f32[0] = 1.0 - carLodLerp;
            v5.n64_u64[0] = vmax_f32(v5, v6).n64_u64[0];
            v39 = v39 * v5.n64_f32[0];
          }
          m_updatingShadows = v54;
          if ( MobileSettings::settings[7].value < 2 )
          {
            SetEnvMapTexture(
              v26[2],
              v39,
              (float)*(char *)v26 * 0.125,
              (float)*((char *)v26 + 1) * 0.125,
              (RwV2d_0)__PAIR64__(
                         -(float)((float)(y - (float)(v41 * (float)(int)(float)(y / v41))) / v41),
                         -(float)((float)(x
                                        - (float)((float)((float)((float)v33 * 0.125) * 50.0)
                                                * (float)(int)(float)(x / (float)((float)((float)v33 * 0.125) * 50.0))))
                                / (float)((float)((float)v33 * 0.125) * 50.0))));
          }
          else
          {
            v44 = v39 * 5.0;
            if ( !v60 )
              v44 = v39;
            SetReflMap(v44);
          }
        }
        if ( v61 == 1 )
        {
          material->color = (RwRGBA_0)color;
          p_prev->material->surfaceProps.diffuse = diffuse;
          p_prev->material->surfaceProps.ambient = ambient;
        }
        v45 = v32;
        if ( (flags & 0x84) != 0 )
        {
          dbEntry = p_prev->material;
          v47 = v60;
          v48 = dbEntry->texture;
          if ( m_updatingShadows )
          {
            if ( !v48 )
              goto LABEL_83;
            raster = v48->raster;
            v50 = v48->raster == 0;
            if ( v48->raster )
            {
              dbEntry = (RpMaterial_0 *)raster->dbEntry;
              v50 = dbEntry == 0;
            }
            if ( v50 || ((int)dbEntry->pipeline & 0xF0) == 0 )
            {
LABEL_83:
              v52 = rwRENDERSTATETEXTURERASTER;
              filterAddressing_low = 0;
LABEL_84:
              _rwOpenGLSetRenderState(v52, filterAddressing_low);
              goto LABEL_85;
            }
          }
          else
          {
            if ( !v48 )
              goto LABEL_83;
            raster = v48->raster;
            if ( !v48->raster )
              goto LABEL_11;
          }
          if ( LOBYTE(raster->privateFlags) << 31 )
          {
LABEL_11:
            if ( v60 )
              emu_DisableAlphaModulate();
            ++p_prev;
            goto LABEL_95;
          }
          _rwOpenGLSetRenderStateNoExtras(rwRENDERSTATETEXTURERASTER, raster);
          filterAddressing_low = (void *)LOBYTE(v48->filterAddressing);
          v52 = rwRENDERSTATETEXTUREFILTER;
          goto LABEL_84;
        }
        _rwOpenGLSetRenderState(rwRENDERSTATETEXTURERASTER, 0);
        v47 = v60;
LABEL_85:
        v53 = !m_updatingShadows;
        if ( m_updatingShadows )
          v53 = v47 == 0;
        if ( v53 && (material->color._anon_0._anon_0.alpha > 0xC0u) | v61 ^ 1 )
          RxOpenGLMeshInstanceData::DrawStored(p_prev);
        ++p_prev;
        if ( v47 )
          emu_DisableAlphaModulate();
        if ( ((carLodLerp < 1.0) & v45) == 1 )
          ResetEnvMap();
LABEL_95:
        next_high = v59;
        if ( !(v59 << 16) )
          return;
      }
      else
      {
        ++p_prev;
        if ( !(next_high << 16) )
          return;
      }
    }
    v21 = 0;
    goto LABEL_20;
  }
}
// 2CBD6A: variable 'v4' is possibly undefined
// 2CBD6A: variable 'v7' is possibly undefined
// 2CBDA2: variable 'v5' is possibly undefined
// 2CBDA2: variable 'v6' is possibly undefined
// 2CBE4E: variable 'diffuse' is possibly undefined
// 2CBE56: variable 'ambient' is possibly undefined
// 0: using guessed type int dword_0;
// 677174: using guessed type int *CCustomCarEnvMapPipeline::ms_envMapPluginOffset[2];

//----- (002CBF80) --------------------------------------------------------
RxPipeline_0 *CCustomCarEnvMapPipeline::CreateCustomOpenGLObjPipe()
{
  RxPipeline_0 *v0; // r0
  RxPipeline_0 *v1; // r4
  RxPipeline_0 *v2; // r6
  RxNodeDefinition_0 *OpenGLAtomicAllInOne; // r5
  RxPipeline_0 *v4; // r0
  RxPipelineNode_0 *NodeByName; // r5

  v0 = RxPipelineCreate();
  v1 = v0;
  if ( !v0 )
    return 0;
  v2 = RxPipelineLock(v0);
  if ( !v2
    || (OpenGLAtomicAllInOne = RxNodeDefinitionGetOpenGLAtomicAllInOne(),
        v4 = RxLockedPipeAddFragment(v2, 0, OpenGLAtomicAllInOne, 0),
        !RxLockedPipeUnlock(v4)) )
  {
    _rxPipelineDestroy(v1);
    return 0;
  }
  NodeByName = RxPipelineFindNodeByName(v1, OpenGLAtomicAllInOne->name, 0, 0);
  RxOpenGLAllInOneSetInstanceCallBack(NodeByName, CCustomCarEnvMapPipeline::CustomPipeInstanceCB);
  RxOpenGLAllInOneSetRenderCallBack(
    NodeByName,
    (RxOpenGLAllInOneRenderCallBack)CCustomCarEnvMapPipeline::CustomPipeRenderCB);
  v1->pluginId = 1408368794;
  v1->pluginData = 1408368794;
  return v1;
}

//----- (002CBFFC) --------------------------------------------------------
RwBool CCustomCarEnvMapPipeline::CreatePipe()
{
  CustomEnvMapPipeMaterialDataPool *v0; // r4
  uint8 *v1; // r0
  uint8 v2; // r1
  int i; // r0
  CustomEnvMapPipeAtomicDataPool *v4; // r4
  uint8 *v5; // r0
  uint8 v6; // r1
  int j; // r0
  CustomSpecMapPipeMaterialDataPool *v8; // r4
  uint8 *v9; // r0
  uint8 v10; // r1
  int k; // r0

  CCustomCarEnvMapPipeline::ObjPipeline = CCustomCarEnvMapPipeline::CreateCustomOpenGLObjPipe();
  if ( !CCustomCarEnvMapPipeline::ObjPipeline )
    return 0;
  v0 = (CustomEnvMapPipeMaterialDataPool *)operator new(0x14u);
  v0->m_aStorage = (CPool<CustomEnvMapPipeMaterialData,CustomEnvMapPipeMaterialData>::StorageType *)operator new[](0xC000u);
  v1 = (uint8 *)operator new[](0x1000u);
  v0->m_bOwnsArrays = 1;
  v0->m_aFlags = v1;
  v0->m_nSize = 4096;
  v0->m_nFreeIndex = -1;
  v2 = v1[1];
  *v1 = 0x80;
  v1[1] = v2 | 0x80;
  v0->m_aFlags[1] &= 0x80u;
  for ( i = 2; i != 4096; ++i )
  {
    v0->m_aFlags[i] |= 0x80u;
    v0->m_aFlags[i] &= 0x80u;
  }
  CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool = v0;
  v4 = (CustomEnvMapPipeAtomicDataPool *)operator new(0x14u);
  v4->m_aStorage = (CPool<CustomEnvMapPipeAtomicData,CustomEnvMapPipeAtomicData>::StorageType *)operator new[](0x3000u);
  v5 = (uint8 *)operator new[](0x400u);
  v4->m_bOwnsArrays = 1;
  v4->m_aFlags = v5;
  v4->m_nSize = 1024;
  v4->m_nFreeIndex = -1;
  v6 = v5[1];
  *v5 = 0x80;
  v5[1] = v6 | 0x80;
  v4->m_aFlags[1] &= 0x80u;
  for ( j = 2; j != 1024; ++j )
  {
    v4->m_aFlags[j] |= 0x80u;
    v4->m_aFlags[j] &= 0x80u;
  }
  CCustomCarEnvMapPipeline::m_gEnvMapPipeAtmDataPool = v4;
  v8 = (CustomSpecMapPipeMaterialDataPool *)operator new(0x14u);
  v8->m_aStorage = (CPool<CustomSpecMapPipeMaterialData,CustomSpecMapPipeMaterialData>::StorageType *)operator new[](0x8000u);
  v9 = (uint8 *)operator new[](0x1000u);
  v8->m_bOwnsArrays = 1;
  v8->m_aFlags = v9;
  v8->m_nSize = 4096;
  v8->m_nFreeIndex = -1;
  v10 = v9[1];
  *v9 = 0x80;
  v9[1] = v10 | 0x80;
  v8->m_aFlags[1] &= 0x80u;
  for ( k = 2; k != 4096; ++k )
  {
    v8->m_aFlags[k] |= 0x80u;
    v8->m_aFlags[k] &= 0x80u;
  }
  CCustomCarEnvMapPipeline::m_gSpecMapPipeMatDataPool = v8;
  return 1;
}

//----- (002CC164) --------------------------------------------------------
void CCustomCarEnvMapPipeline::DestroyPipe()
{
  CustomEnvMapPipeMaterialDataPool *v0; // r4
  uint8 *m_aFlags; // r0
  uint8 **p_m_aFlags; // r5
  CustomEnvMapPipeAtomicDataPool *v3; // r4
  uint8 *v4; // r0
  uint8 **v5; // r6
  CustomSpecMapPipeMaterialDataPool *v6; // r4
  uint8 *v7; // r0
  uint8 **v8; // r5

  v0 = CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool;
  if ( CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool )
  {
    if ( CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool->m_nSize >= 1 )
    {
      if ( CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool->m_bOwnsArrays )
      {
        if ( CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool->m_aStorage )
          operator delete[](CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool->m_aStorage);
        p_m_aFlags = &v0->m_aFlags;
        m_aFlags = v0->m_aFlags;
        if ( m_aFlags )
          operator delete[](m_aFlags);
      }
      else
      {
        p_m_aFlags = &CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool->m_aFlags;
      }
      v0->m_aStorage = 0;
      *p_m_aFlags = 0;
    }
    operator delete(v0);
  }
  v3 = CCustomCarEnvMapPipeline::m_gEnvMapPipeAtmDataPool;
  CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool = 0;
  if ( CCustomCarEnvMapPipeline::m_gEnvMapPipeAtmDataPool )
  {
    if ( CCustomCarEnvMapPipeline::m_gEnvMapPipeAtmDataPool->m_nSize >= 1 )
    {
      if ( CCustomCarEnvMapPipeline::m_gEnvMapPipeAtmDataPool->m_bOwnsArrays )
      {
        if ( CCustomCarEnvMapPipeline::m_gEnvMapPipeAtmDataPool->m_aStorage )
          operator delete[](CCustomCarEnvMapPipeline::m_gEnvMapPipeAtmDataPool->m_aStorage);
        v5 = &v3->m_aFlags;
        v4 = v3->m_aFlags;
        if ( v4 )
          operator delete[](v4);
      }
      else
      {
        v5 = &CCustomCarEnvMapPipeline::m_gEnvMapPipeAtmDataPool->m_aFlags;
      }
      v3->m_aStorage = 0;
      *v5 = 0;
    }
    operator delete(v3);
  }
  v6 = CCustomCarEnvMapPipeline::m_gSpecMapPipeMatDataPool;
  CCustomCarEnvMapPipeline::m_gEnvMapPipeAtmDataPool = 0;
  if ( CCustomCarEnvMapPipeline::m_gSpecMapPipeMatDataPool )
  {
    if ( CCustomCarEnvMapPipeline::m_gSpecMapPipeMatDataPool->m_nSize >= 1 )
    {
      if ( CCustomCarEnvMapPipeline::m_gSpecMapPipeMatDataPool->m_bOwnsArrays )
      {
        if ( CCustomCarEnvMapPipeline::m_gSpecMapPipeMatDataPool->m_aStorage )
          operator delete[](CCustomCarEnvMapPipeline::m_gSpecMapPipeMatDataPool->m_aStorage);
        v8 = &v6->m_aFlags;
        v7 = v6->m_aFlags;
        if ( v7 )
          operator delete[](v7);
      }
      else
      {
        v8 = &CCustomCarEnvMapPipeline::m_gSpecMapPipeMatDataPool->m_aFlags;
      }
      v6->m_aStorage = 0;
      *v8 = 0;
    }
    operator delete(v6);
  }
  CCustomCarEnvMapPipeline::m_gSpecMapPipeMatDataPool = 0;
  if ( CCustomCarEnvMapPipeline::ObjPipeline )
  {
    _rxPipelineDestroy(CCustomCarEnvMapPipeline::ObjPipeline);
    CCustomCarEnvMapPipeline::ObjPipeline = 0;
  }
}

//----- (002CC278) --------------------------------------------------------
CustomEnvMapPipeMaterialData *__fastcall CCustomCarEnvMapPipeline::DuplicateCustomEnvMapPipeMaterialData(
        CustomEnvMapPipeMaterialData **ppData)
{
  CustomEnvMapPipeMaterialData *result; // r0
  int v3; // r1
  CustomEnvMapPipeMaterialDataPool *v4; // r2
  CustomEnvMapPipeMaterialData *m_nSize; // lr
  uint8 *m_aFlags; // r3
  int v7; // r4
  __int64 v8; // d16

  result = *ppData;
  if ( result == &CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData )
  {
    v3 = 0;
    v4 = CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool;
    result = (CustomEnvMapPipeMaterialData *)CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool->m_nFreeIndex;
    m_nSize = (CustomEnvMapPipeMaterialData *)CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool->m_nSize;
    do
    {
      result = (CustomEnvMapPipeMaterialData *)((char *)result + 1);
      v4->m_nFreeIndex = (int32)result;
      if ( result == m_nSize )
      {
        result = 0;
        v4->m_nFreeIndex = 0;
        if ( v3 << 31 )
        {
          *ppData = 0;
          return result;
        }
        v3 = 1;
      }
      m_aFlags = v4->m_aFlags;
      v7 = *(&result->cfEnvScaleX + (_DWORD)m_aFlags);
    }
    while ( v7 > -1 );
    *(&result->cfEnvScaleX + (_DWORD)m_aFlags) = v7 & 0x7F;
    v4->m_aFlags[v4->m_nFreeIndex] = (v4->m_aFlags[v4->m_nFreeIndex] + 1) & 0x7F | v4->m_aFlags[v4->m_nFreeIndex] & 0x80;
    result = (CustomEnvMapPipeMaterialData *)v4->m_aStorage[v4->m_nFreeIndex];
    *ppData = result;
    if ( result )
    {
      v8 = *(_QWORD *)&CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData.cfEnvScaleX;
      result->pEnvTexture = CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData.pEnvTexture;
      *(_QWORD *)&result->cfEnvScaleX = v8;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (002CC310) --------------------------------------------------------
void __fastcall CCustomCarEnvMapPipeline::SetFxEnvScale(RpMaterial_0 *pMaterial, float envScaleX, float envScaleY)
{
  int32 v3; // r12
  int v4; // r3
  int v5; // r5
  CustomEnvMapPipeMaterialDataPool *v6; // lr
  int32 m_nFreeIndex; // r3
  int32 m_nSize; // r8
  uint8 *m_aFlags; // r6
  int v10; // r4
  __int64 v11; // d16

  v3 = CCustomCarEnvMapPipeline::ms_envMapPluginOffset;
  v4 = *(int *)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset);
  if ( (CustomEnvMapPipeMaterialData *)v4 == &CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData )
  {
    v5 = 0;
    v6 = CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool;
    m_nFreeIndex = CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool->m_nFreeIndex;
    m_nSize = CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool->m_nSize;
    do
    {
      v6->m_nFreeIndex = ++m_nFreeIndex;
      if ( m_nFreeIndex == m_nSize )
      {
        m_nFreeIndex = 0;
        v6->m_nFreeIndex = 0;
        if ( v5 << 31 )
        {
          *(RwTexture_0 **)((char *)&pMaterial->texture + v3) = 0;
          return;
        }
        v5 = 1;
      }
      m_aFlags = v6->m_aFlags;
      v10 = (char)m_aFlags[m_nFreeIndex];
    }
    while ( v10 > -1 );
    m_aFlags[m_nFreeIndex] = v10 & 0x7F;
    v6->m_aFlags[v6->m_nFreeIndex] = (v6->m_aFlags[v6->m_nFreeIndex] + 1) & 0x7F | v6->m_aFlags[v6->m_nFreeIndex] & 0x80;
    v4 = (int)v6->m_aStorage[v6->m_nFreeIndex];
    *(RwTexture_0 **)((char *)&pMaterial->texture + v3) = (RwTexture_0 *)v4;
    if ( !v4 )
      return;
    v11 = *(_QWORD *)&CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData.cfEnvScaleX;
    *(_DWORD *)(v4 + 8) = CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData.pEnvTexture;
    *(_QWORD *)v4 = v11;
  }
  else if ( !v4 )
  {
    return;
  }
  *(_BYTE *)(v4 + 1) = (int)(float)(envScaleY * 8.0);
  *(_BYTE *)v4 = (int)(float)(envScaleX * 8.0);
}
// 2CC3DC: conditional instruction was optimized away because r3.4!=0

//----- (002CC3FC) --------------------------------------------------------
float __fastcall CCustomCarEnvMapPipeline::GetFxEnvScaleX(RpMaterial_0 *pMaterial)
{
  char *v1; // r0

  v1 = *(char **)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset);
  if ( v1 )
    return (float)*v1 * 0.125;
  else
    return 0.0;
}

//----- (002CC438) --------------------------------------------------------
float __fastcall CCustomCarEnvMapPipeline::GetFxEnvScaleY(RpMaterial_0 *pMaterial)
{
  int v1; // r0

  v1 = *(int *)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset);
  if ( v1 )
    return (float)*(char *)(v1 + 1) * 0.125;
  else
    return 0.0;
}

//----- (002CC474) --------------------------------------------------------
void __fastcall CCustomCarEnvMapPipeline::SetFxEnvTransScl(RpMaterial_0 *pMaterial, float envTransX, float envTransY)
{
  int32 v3; // r12
  int v4; // r3
  int v5; // r5
  CustomEnvMapPipeMaterialDataPool *v6; // lr
  int32 m_nFreeIndex; // r3
  int32 m_nSize; // r8
  uint8 *m_aFlags; // r6
  int v10; // r4
  __int64 v11; // d16

  v3 = CCustomCarEnvMapPipeline::ms_envMapPluginOffset;
  v4 = *(int *)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset);
  if ( (CustomEnvMapPipeMaterialData *)v4 == &CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData )
  {
    v5 = 0;
    v6 = CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool;
    m_nFreeIndex = CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool->m_nFreeIndex;
    m_nSize = CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool->m_nSize;
    do
    {
      v6->m_nFreeIndex = ++m_nFreeIndex;
      if ( m_nFreeIndex == m_nSize )
      {
        m_nFreeIndex = 0;
        v6->m_nFreeIndex = 0;
        if ( v5 << 31 )
        {
          *(RwTexture_0 **)((char *)&pMaterial->texture + v3) = 0;
          return;
        }
        v5 = 1;
      }
      m_aFlags = v6->m_aFlags;
      v10 = (char)m_aFlags[m_nFreeIndex];
    }
    while ( v10 > -1 );
    m_aFlags[m_nFreeIndex] = v10 & 0x7F;
    v6->m_aFlags[v6->m_nFreeIndex] = (v6->m_aFlags[v6->m_nFreeIndex] + 1) & 0x7F | v6->m_aFlags[v6->m_nFreeIndex] & 0x80;
    v4 = (int)v6->m_aStorage[v6->m_nFreeIndex];
    *(RwTexture_0 **)((char *)&pMaterial->texture + v3) = (RwTexture_0 *)v4;
    if ( !v4 )
      return;
    v11 = *(_QWORD *)&CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData.cfEnvScaleX;
    *(_DWORD *)(v4 + 8) = CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData.pEnvTexture;
    *(_QWORD *)v4 = v11;
  }
  else if ( !v4 )
  {
    return;
  }
  *(_BYTE *)(v4 + 3) = (int)(float)(envTransY * 8.0);
  *(_BYTE *)(v4 + 2) = (int)(float)(envTransX * 8.0);
}
// 2CC540: conditional instruction was optimized away because r3.4!=0

//----- (002CC560) --------------------------------------------------------
float __fastcall CCustomCarEnvMapPipeline::GetFxEnvTransSclX(RpMaterial_0 *pMaterial)
{
  int v1; // r0

  v1 = *(int *)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset);
  if ( v1 )
    return (float)*(char *)(v1 + 2) * 0.125;
  else
    return 0.0;
}

//----- (002CC59C) --------------------------------------------------------
float __fastcall CCustomCarEnvMapPipeline::GetFxEnvTransSclY(RpMaterial_0 *pMaterial)
{
  int v1; // r0

  v1 = *(int *)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset);
  if ( v1 )
    return (float)*(char *)(v1 + 3) * 0.125;
  else
    return 0.0;
}

//----- (002CC5D8) --------------------------------------------------------
void __fastcall CCustomCarEnvMapPipeline::SetFxEnvShininess(RpMaterial_0 *pMaterial, float envShininess)
{
  int32 v2; // r12
  int v3; // r2
  int v4; // r4
  CustomEnvMapPipeMaterialDataPool *v5; // r3
  int32 m_nFreeIndex; // r2
  int32 m_nSize; // lr
  uint8 *m_aFlags; // r5
  int v9; // r6
  __int64 v10; // d16

  v2 = CCustomCarEnvMapPipeline::ms_envMapPluginOffset;
  v3 = *(int *)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_envMapPluginOffset);
  if ( (CustomEnvMapPipeMaterialData *)v3 == &CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData )
  {
    v4 = 0;
    v5 = CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool;
    m_nFreeIndex = CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool->m_nFreeIndex;
    m_nSize = CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool->m_nSize;
    do
    {
      v5->m_nFreeIndex = ++m_nFreeIndex;
      if ( m_nFreeIndex == m_nSize )
      {
        m_nFreeIndex = 0;
        v5->m_nFreeIndex = 0;
        if ( v4 << 31 )
        {
          *(RwTexture_0 **)((char *)&pMaterial->texture + v2) = 0;
          return;
        }
        v4 = 1;
      }
      m_aFlags = v5->m_aFlags;
      v9 = (char)m_aFlags[m_nFreeIndex];
    }
    while ( v9 > -1 );
    m_aFlags[m_nFreeIndex] = v9 & 0x7F;
    v5->m_aFlags[v5->m_nFreeIndex] = (v5->m_aFlags[v5->m_nFreeIndex] + 1) & 0x7F | v5->m_aFlags[v5->m_nFreeIndex] & 0x80;
    v3 = (int)v5->m_aStorage[v5->m_nFreeIndex];
    *(RwTexture_0 **)((char *)&pMaterial->texture + v2) = (RwTexture_0 *)v3;
    if ( !v3 )
      return;
    v10 = *(_QWORD *)&CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData.cfEnvScaleX;
    *(_DWORD *)(v3 + 8) = CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData.pEnvTexture;
    *(_QWORD *)v3 = v10;
  }
  if ( v3 )
    *(_BYTE *)(v3 + 4) = (unsigned int)(float)(envShininess * 255.0);
}

//----- (002CC6A0) --------------------------------------------------------
void __fastcall CCustomCarEnvMapPipeline::SetFxSpecTexture(RpMaterial_0 *pMaterial, RwTexture_0 *customTexture)
{
  int v3; // r5
  RwTexture_0 *v4; // r0
  int v5; // r0

  v3 = *(int *)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_specularMapPluginOffset);
  if ( v3 )
  {
    if ( customTexture )
    {
      v4 = *(RwTexture_0 **)(v3 + 4);
      if ( v4 )
      {
        RwTextureDestroy(v4);
        *(_DWORD *)(v3 + 4) = 0;
      }
      *(_DWORD *)(v3 + 4) = customTexture;
      ++customTexture->refCount;
    }
    v5 = *(_DWORD *)(v3 + 4);
    if ( v5 )
      *(_WORD *)(v5 + 80) = 4354;
  }
}
// 6795C4: using guessed type int *CCustomCarEnvMapPipeline::ms_specularMapPluginOffset;

//----- (002CC6E0) --------------------------------------------------------
void __fastcall CCustomCarEnvMapPipeline::SetFxSpecSpecularity(RpMaterial_0 *pMaterial, float specularity)
{
  float *v2; // r0

  v2 = *(float **)((char *)&pMaterial->texture + CCustomCarEnvMapPipeline::ms_specularMapPluginOffset);
  if ( v2 )
    *v2 = specularity;
}

//----- (002CC6FC) --------------------------------------------------------
RwBool CCustomCarEnvMapPipeline::RegisterPlugin()
{
  int v0; // r5
  int **v1; // r0

  CCustomCarEnvMapPipeline::ms_envMapPluginOffset = RpMaterialRegisterPlugin(
                                                      4,
                                                      0x253F2FCu,
                                                      CCustomCarEnvMapPipeline::pluginEnvMatConstructorCB,
                                                      CCustomCarEnvMapPipeline::pluginEnvMatDestructorCB,
                                                      CCustomCarEnvMapPipeline::pluginEnvMatCopyConstructorCB);
  if ( CCustomCarEnvMapPipeline::ms_envMapPluginOffset < 0 )
    return 0;
  if ( RpMaterialRegisterPluginStream(
         0x253F2FCu,
         CCustomCarEnvMapPipeline::pluginEnvMatStreamReadCB,
         CCustomCarEnvMapPipeline::pluginEnvMatStreamWriteCB,
         CCustomCarEnvMapPipeline::pluginEnvMatStreamGetSizeCB) <= -1 )
  {
    v1 = CCustomCarEnvMapPipeline::ms_envMapPluginOffset;
    goto LABEL_9;
  }
  CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData.cfShininess = -1;
  v0 = 0;
  *(_DWORD *)&CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData.cfEnvScaleX = 134744072;
  CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData.pEnvTexture = 0;
  CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData.nCurrentRenderFrame = 0;
  CCustomCarEnvMapPipeline::ms_envMapAtmPluginOffset = RpAtomicRegisterPlugin(
                                                         4,
                                                         0x253F2F4u,
                                                         CCustomCarEnvMapPipeline::pluginEnvAtmConstructorCB,
                                                         CCustomCarEnvMapPipeline::pluginEnvAtmDestructorCB,
                                                         CCustomCarEnvMapPipeline::pluginEnvAtmCopyConstructorCB);
  if ( CCustomCarEnvMapPipeline::ms_envMapAtmPluginOffset >= 0 )
  {
    CCustomCarEnvMapPipeline::ms_specularMapPluginOffset = RpMaterialRegisterPlugin(
                                                             4,
                                                             0x253F2F6u,
                                                             CCustomCarEnvMapPipeline::pluginSpecMatConstructorCB,
                                                             CCustomCarEnvMapPipeline::pluginSpecMatDestructorCB,
                                                             CCustomCarEnvMapPipeline::pluginSpecMatCopyConstructorCB);
    if ( CCustomCarEnvMapPipeline::ms_specularMapPluginOffset < 0 )
      return 0;
    if ( RpMaterialRegisterPluginStream(
           0x253F2F6u,
           CCustomCarEnvMapPipeline::pluginSpecMatStreamReadCB,
           CCustomCarEnvMapPipeline::pluginSpecMatStreamWriteCB,
           CCustomCarEnvMapPipeline::pluginSpecMatStreamGetSizeCB) > -1 )
      return 1;
    v1 = &CCustomCarEnvMapPipeline::ms_specularMapPluginOffset;
LABEL_9:
    **v1 = -1;
    return 0;
  }
  return v0;
}
// 677174: using guessed type int *CCustomCarEnvMapPipeline::ms_envMapPluginOffset[2];
// 6795C4: using guessed type int *CCustomCarEnvMapPipeline::ms_specularMapPluginOffset;

//----- (002CC850) --------------------------------------------------------
void *__fastcall CCustomCarEnvMapPipeline::pluginEnvMatConstructorCB(
        void *object,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  *(_DWORD *)((char *)object + offsetInObject) = &CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData;
  return object;
}

//----- (002CC860) --------------------------------------------------------
void *__fastcall CCustomCarEnvMapPipeline::pluginEnvMatDestructorCB(
        void *object,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  CustomEnvMapPipeMaterialData *v3; // r3
  bool v4; // zf
  CustomEnvMapPipeMaterialDataPool *v5; // r4
  signed int v6; // r12

  v3 = *(CustomEnvMapPipeMaterialData **)((char *)object + offsetInObject);
  v4 = v3 == &CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData;
  if ( v3 != &CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData )
    v4 = v3 == 0;
  if ( !v4 )
  {
    v5 = CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool;
    v6 = ((char *)v3 - (char *)CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool->m_aStorage) >> 2;
    CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool->m_aFlags[-1431655765 * v6] |= 0x80u;
    if ( -1431655765 * v6 < v5->m_nFreeIndex )
      v5->m_nFreeIndex = -1431655765 * v6;
    *(_DWORD *)((char *)object + offsetInObject) = 0;
  }
  return object;
}

//----- (002CC8BC) --------------------------------------------------------
void *__fastcall CCustomCarEnvMapPipeline::pluginEnvMatCopyConstructorCB(
        void *dstObject,
        const void *srcObject,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  const void *v4; // r1
  uint8 *v6; // r0
  int v7; // lr
  CustomEnvMapPipeMaterialDataPool *v8; // r0
  int32 m_nFreeIndex; // r4
  int32 m_nSize; // r12
  uint8 *m_aFlags; // r5
  int v12; // r6

  v4 = *(const void **)((char *)srcObject + offsetInObject);
  if ( v4 )
  {
    v6 = *(uint8 **)((char *)dstObject + offsetInObject);
    if ( v6 )
    {
LABEL_9:
      qmemcpy(v6, v4, sizeInObject);
    }
    else
    {
      v7 = 0;
      v8 = CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool;
      m_nFreeIndex = CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool->m_nFreeIndex;
      m_nSize = CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool->m_nSize;
      do
      {
        v8->m_nFreeIndex = ++m_nFreeIndex;
        if ( m_nFreeIndex == m_nSize )
        {
          m_nFreeIndex = 0;
          v8->m_nFreeIndex = 0;
          if ( v7 << 31 )
          {
            *(_DWORD *)((char *)dstObject + offsetInObject) = 0;
            goto LABEL_11;
          }
          v7 = 1;
        }
        m_aFlags = v8->m_aFlags;
        v12 = (char)m_aFlags[m_nFreeIndex];
      }
      while ( v12 > -1 );
      m_aFlags[m_nFreeIndex] = v12 & 0x7F;
      v8->m_aFlags[v8->m_nFreeIndex] = (v8->m_aFlags[v8->m_nFreeIndex] + 1) & 0x7F | v8->m_aFlags[v8->m_nFreeIndex] & 0x80;
      v6 = v8->m_aStorage[v8->m_nFreeIndex];
      *(_DWORD *)((char *)dstObject + offsetInObject) = v6;
      if ( v6 )
        goto LABEL_9;
LABEL_11:
      *(_DWORD *)((char *)dstObject + offsetInObject) = &CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData;
    }
  }
  return dstObject;
}

//----- (002CC954) --------------------------------------------------------
RwStream_0 *__fastcall CCustomCarEnvMapPipeline::pluginEnvMatStreamReadCB(
        RwStream_0 *stream,
        RwInt32 binaryLength,
        void *object,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  float v8; // s0
  int v9; // r3
  CustomEnvMapPipeMaterialDataPool *v10; // r0
  int32 m_nFreeIndex; // r1
  int32 m_nSize; // r2
  uint8 *m_aFlags; // r5
  int v14; // r6
  int v15; // r0
  double v16; // d16
  double v18; // [sp+0h] [bp-40h] BYREF
  int v19; // [sp+8h] [bp-38h]
  float buffer[4]; // [sp+10h] [bp-30h] BYREF
  float v21; // [sp+20h] [bp-20h]
  int v22; // [sp+24h] [bp-1Ch]

  v22 = 0;
  RwStreamRead(stream, buffer, binaryLength);
  v8 = v21;
  if ( (int)v21 )
  {
    v8 = v21 - (float)(int)v21;
    v21 = v8;
  }
  v19 = v22;
  LOBYTE(v18) = (int)(float)(buffer[0] * 8.0);
  BYTE1(v18) = (int)(float)(buffer[1] * 8.0);
  BYTE2(v18) = (int)(float)(buffer[2] * 8.0);
  BYTE3(v18) = (int)(float)(buffer[3] * 8.0);
  BYTE4(v18) = (unsigned int)(float)(v8 * 255.0);
  HIWORD(v18) = 0;
  if ( !memcmp(&v18, &CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData, 0xCu) )
  {
LABEL_13:
    *(_DWORD *)((char *)object + offsetInObject) = &CCustomCarEnvMapPipeline::fakeEnvMapPipeMatData;
  }
  else
  {
    v9 = 0;
    v10 = CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool;
    m_nFreeIndex = CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool->m_nFreeIndex;
    m_nSize = CCustomCarEnvMapPipeline::m_gEnvMapPipeMatDataPool->m_nSize;
    do
    {
      v10->m_nFreeIndex = ++m_nFreeIndex;
      if ( m_nFreeIndex == m_nSize )
      {
        m_nFreeIndex = 0;
        v10->m_nFreeIndex = 0;
        if ( v9 << 31 )
        {
          *(_DWORD *)((char *)object + offsetInObject) = 0;
          goto LABEL_13;
        }
        v9 = 1;
      }
      m_aFlags = v10->m_aFlags;
      v14 = (char)m_aFlags[m_nFreeIndex];
    }
    while ( v14 > -1 );
    m_aFlags[m_nFreeIndex] = v14 & 0x7F;
    v10->m_aFlags[v10->m_nFreeIndex] = (v10->m_aFlags[v10->m_nFreeIndex] + 1) & 0x7F | v10->m_aFlags[v10->m_nFreeIndex] & 0x80;
    v15 = (int)v10->m_aStorage[v10->m_nFreeIndex];
    *(_DWORD *)((char *)object + offsetInObject) = v15;
    if ( !v15 )
      goto LABEL_13;
    v16 = v18;
    *(_DWORD *)(v15 + 8) = v19;
    *(double *)v15 = v16;
  }
  return stream;
}

//----- (002CCAB0) --------------------------------------------------------
RwStream_0 *__fastcall CCustomCarEnvMapPipeline::pluginEnvMatStreamWriteCB(
        RwStream_0 *stream,
        RwInt32 binaryLength,
        const void *object,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  float *v6; // r0
  float v8[8]; // [sp+0h] [bp-20h] BYREF

  v6 = *(float **)((char *)object + offsetInObject);
  v8[0] = (float)*(char *)v6 * 0.125;
  v8[1] = (float)*((char *)v6 + 1) * 0.125;
  v8[2] = (float)*((char *)v6 + 2) * 0.125;
  v8[3] = (float)*((char *)v6 + 3) * 0.125;
  v8[4] = (float)*((unsigned __int8 *)v6 + 4) * 0.0039216;
  v8[5] = v6[2];
  RwStreamWrite(stream, v8, binaryLength);
  return stream;
}

//----- (002CCB40) --------------------------------------------------------
RwInt32 __fastcall CCustomCarEnvMapPipeline::pluginEnvMatStreamGetSizeCB(
        RwInt32 object,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  if ( object )
    return 24;
  return object;
}

//----- (002CCB48) --------------------------------------------------------
void __fastcall CCustomCarEnvMapPipeline::SetCustomEnvMapPipeMaterialDataDefaults(CustomEnvMapPipeMaterialData *pData)
{
  pData->cfShininess = -1;
  *(_DWORD *)&pData->cfEnvScaleX = 134744072;
  pData->pEnvTexture = 0;
  pData->nCurrentRenderFrame = 0;
}

//----- (002CCB5A) --------------------------------------------------------
void *__fastcall CCustomCarEnvMapPipeline::pluginEnvAtmConstructorCB(
        void *object,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  *(_DWORD *)((char *)object + offsetInObject) = 0;
  return object;
}

//----- (002CCB60) --------------------------------------------------------
void *__fastcall CCustomCarEnvMapPipeline::pluginEnvAtmDestructorCB(
        void *object,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  int v3; // r3
  CustomEnvMapPipeAtomicDataPool *v4; // r4
  signed int v5; // r12

  v3 = *(_DWORD *)((char *)object + offsetInObject);
  if ( v3 )
  {
    v4 = CCustomCarEnvMapPipeline::m_gEnvMapPipeAtmDataPool;
    v5 = (signed int)(v3 - (unsigned int)CCustomCarEnvMapPipeline::m_gEnvMapPipeAtmDataPool->m_aStorage) >> 2;
    CCustomCarEnvMapPipeline::m_gEnvMapPipeAtmDataPool->m_aFlags[-1431655765 * v5] |= 0x80u;
    if ( -1431655765 * v5 < v4->m_nFreeIndex )
      v4->m_nFreeIndex = -1431655765 * v5;
    *(_DWORD *)((char *)object + offsetInObject) = 0;
  }
  return object;
}

//----- (002CCBB0) --------------------------------------------------------
void *__fastcall CCustomCarEnvMapPipeline::pluginEnvAtmCopyConstructorCB(
        void *dstObject,
        const void *srcObject,
        RwInt32 offsetInObject,
        RwInt32 sizeInObject)
{
  const void *v4; // r1
  uint8 *v6; // r0
  int v7; // lr
  CustomEnvMapPipeAtomicDataPool *v8; // r0
  int32 m_nFreeIndex; // r4
  int32 m_nSize; // r12
  uint8 *m_aFlags; // r5
  int v12; // r6

  v4 = *(const void **)((char *)srcObject + offsetInObject);
  if ( v4 )
  {
    v6 = *(uint8 **)((char *)dstObject + offsetInObject);
    if ( !v6 )
    {
      v7 = 0;
      v8 = CCustomCarEnvMapPipeline::m_gEnvMapPipeAtmDataPool;
      m_nFreeIndex = CCustomCarEnvMapPipeline::m_gEnvMapPipeAtmDataPool->m_nFreeIndex;
      m_nSize = CCustomCarEnvMapPipeline::m_gEnvMapPipeAtmDataPool->m_nSize;
      do
      {
        v8->m_nFreeIndex = ++m_nFreeIndex;
        if ( m_nFreeIndex == m_nSize )
        {
          m_nFreeIndex = 0;
          v8->m_nFreeIndex = 0;
          if ( v7 << 31 )
          {
            *(_DWORD *)((char *)dstObject + offsetInObject) = 0;
            return dstObject;
          }
          v7 = 1;
        }
        m_aFlags = v8->m_aFlags;
        v12 = (char)m_aFlags[m_nFreeIndex];
      }
      while ( v12 > -1 );
      m_aFlags[m_nFreeIndex] = v12 & 0x7F;
      v8->m_aFlags[v8->m_nFreeIndex] = (v8->m_aFlags[v8->m_nFreeIndex] + 1) & 0x7F | v8->m_aFlags[v8->m_nFreeIndex] & 0x80;
      v6 = v8->m_aStorage[v8->m_nFreeIndex];
      *(_DWORD *)((char *)dstObject + offsetInObject) = v6;
      if ( !v6 )
        return dstObject;
    }
    qmemcpy(v6, v4, sizeInObject);
  }
  return dstObject;
}

//----- (002CCC3C) --------------------------------------------------------
void *__fastcall CCustomCarEnvMapPipeline::pluginSpecMatConstructorCB(
        void *object,
        int offsetInObject,
        int sizeInObject)
{
  *(_DWORD *)((char *)object + CCustomCarEnvMapPipeline::ms_specularMapPluginOffset) = 0;
  return object;
}

//----- (002CCC50) --------------------------------------------------------
void *__fastcall CCustomCarEnvMapPipeline::pluginSpecMatDestructorCB(
        void *object,
        int offsetInObject,
        int sizeInObject)
{
  int32 v4; // r5
  int v5; // r6
  RwTexture_0 *v6; // r0
  CustomSpecMapPipeMaterialDataPool *v7; // r0
  signed int v8; // r1

  v4 = CCustomCarEnvMapPipeline::ms_specularMapPluginOffset;
  v5 = *(_DWORD *)((char *)object + CCustomCarEnvMapPipeline::ms_specularMapPluginOffset);
  if ( v5 )
  {
    v6 = *(RwTexture_0 **)(v5 + 4);
    if ( v6 )
    {
      RwTextureDestroy(v6);
      *(_DWORD *)(v5 + 4) = 0;
    }
    v7 = CCustomCarEnvMapPipeline::m_gSpecMapPipeMatDataPool;
    v8 = (signed int)(v5 - (unsigned int)CCustomCarEnvMapPipeline::m_gSpecMapPipeMatDataPool->m_aStorage) >> 3;
    CCustomCarEnvMapPipeline::m_gSpecMapPipeMatDataPool->m_aFlags[v8] |= 0x80u;
    if ( v8 < v7->m_nFreeIndex )
      v7->m_nFreeIndex = v8;
    *(_DWORD *)((char *)object + v4) = 0;
  }
  return object;
}
// 6795C4: using guessed type int *CCustomCarEnvMapPipeline::ms_specularMapPluginOffset;

//----- (002CCCA8) --------------------------------------------------------
void *__fastcall CCustomCarEnvMapPipeline::pluginSpecMatCopyConstructorCB(
        void *dstObject,
        const void *srcObject,
        int offsetInObject,
        int sizeInObject)
{
  int32 v4; // lr
  _DWORD *v5; // r12
  uint8 *v6; // r1
  int v7; // r4
  CustomSpecMapPipeMaterialDataPool *v8; // r3
  int32 m_nFreeIndex; // r1
  int32 m_nSize; // r2
  uint8 *m_aFlags; // r5
  int v12; // r6
  int v13; // r2

  v4 = CCustomCarEnvMapPipeline::ms_specularMapPluginOffset;
  v5 = *(_DWORD **)((char *)srcObject + CCustomCarEnvMapPipeline::ms_specularMapPluginOffset);
  if ( v5 )
  {
    v6 = *(uint8 **)((char *)dstObject + CCustomCarEnvMapPipeline::ms_specularMapPluginOffset);
    if ( !v6 )
    {
      v7 = 0;
      v8 = CCustomCarEnvMapPipeline::m_gSpecMapPipeMatDataPool;
      m_nFreeIndex = CCustomCarEnvMapPipeline::m_gSpecMapPipeMatDataPool->m_nFreeIndex;
      m_nSize = CCustomCarEnvMapPipeline::m_gSpecMapPipeMatDataPool->m_nSize;
      do
      {
        v8->m_nFreeIndex = ++m_nFreeIndex;
        if ( m_nFreeIndex == m_nSize )
        {
          m_nFreeIndex = 0;
          v8->m_nFreeIndex = 0;
          if ( v7 << 31 )
          {
            *(_DWORD *)((char *)dstObject + v4) = 0;
            return dstObject;
          }
          v7 = 1;
        }
        m_aFlags = v8->m_aFlags;
        v12 = (char)m_aFlags[m_nFreeIndex];
      }
      while ( v12 > -1 );
      m_aFlags[m_nFreeIndex] = v12 & 0x7F;
      v8->m_aFlags[v8->m_nFreeIndex] = (v8->m_aFlags[v8->m_nFreeIndex] + 1) & 0x7F | v8->m_aFlags[v8->m_nFreeIndex] & 0x80;
      v6 = v8->m_aStorage[v8->m_nFreeIndex];
      *(_DWORD *)((char *)dstObject + v4) = v6;
      if ( !v6 )
        return dstObject;
    }
    *(_DWORD *)v6 = *v5;
    v13 = v5[1];
    *((_DWORD *)v6 + 1) = v13;
    if ( v13 )
      ++*(_DWORD *)(v13 + 84);
  }
  return dstObject;
}

//----- (002CCD4C) --------------------------------------------------------
RwStream_0 *__fastcall CCustomCarEnvMapPipeline::pluginSpecMatStreamReadCB(
        RwStream_0 *pStream,
        RwInt32 len,
        void *pData,
        RwInt32 offset,
        RwInt32 size)
{
  int32 v7; // r9
  TextureDatabaseRuntime *Database; // r0
  RwTexture_0 *v9; // r0
  int v10; // r6
  CustomSpecMapPipeMaterialDataPool *v11; // r1
  int32 m_nFreeIndex; // r2
  int32 m_nSize; // r3
  uint8 *m_aFlags; // r5
  int v15; // r4
  CPool<CustomSpecMapPipeMaterialData,CustomSpecMapPipeMaterialData>::StorageType *m_aStorage; // r2
  int32 v17; // r1
  uint8 *v18; // r3
  float v20; // [sp+0h] [bp-38h] BYREF
  RwChar v21[24]; // [sp+4h] [bp-34h] BYREF

  v7 = CCustomCarEnvMapPipeline::ms_specularMapPluginOffset;
  RwStreamRead(pStream, &v20, len);
  Database = TextureDatabaseRuntime::GetDatabase((const char *)&off_2CCE24);
  TextureDatabaseRuntime::Register(Database);
  if ( v20 != 0.0 )
  {
    v9 = RwTextureRead(v21, 0);
    if ( v9 )
    {
      v10 = 0;
      v11 = CCustomCarEnvMapPipeline::m_gSpecMapPipeMatDataPool;
      m_nFreeIndex = CCustomCarEnvMapPipeline::m_gSpecMapPipeMatDataPool->m_nFreeIndex;
      m_nSize = CCustomCarEnvMapPipeline::m_gSpecMapPipeMatDataPool->m_nSize;
      do
      {
        v11->m_nFreeIndex = ++m_nFreeIndex;
        if ( m_nFreeIndex == m_nSize )
        {
          m_nFreeIndex = 0;
          v11->m_nFreeIndex = 0;
          if ( v10 << 31 )
          {
            *(_DWORD *)((char *)pData + v7) = 0;
            return pStream;
          }
          v10 = 1;
        }
        m_aFlags = v11->m_aFlags;
        v15 = (char)m_aFlags[m_nFreeIndex];
      }
      while ( v15 > -1 );
      m_aFlags[m_nFreeIndex] = v15 & 0x7F;
      v11->m_aFlags[v11->m_nFreeIndex] = (v11->m_aFlags[v11->m_nFreeIndex] + 1) & 0x7F | v11->m_aFlags[v11->m_nFreeIndex] & 0x80;
      m_aStorage = v11->m_aStorage;
      v17 = v11->m_nFreeIndex;
      v18 = m_aStorage[v17];
      *(_DWORD *)((char *)pData + v7) = v18;
      if ( v18 )
      {
        *((_DWORD *)v18 + 1) = v9;
        *(float *)&m_aStorage[v17][0] = v20;
      }
    }
  }
  return pStream;
}
// 2CCE24: using guessed type void *off_2CCE24;
// 6795C4: using guessed type int *CCustomCarEnvMapPipeline::ms_specularMapPluginOffset;
// 2CCD4C: using guessed type RwChar anonymous_0[24];

//----- (002CCE30) --------------------------------------------------------
RwStream_0 *__fastcall CCustomCarEnvMapPipeline::pluginSpecMatStreamWriteCB(
        RwStream_0 *pStream,
        RwInt32 len,
        const void *pData,
        RwInt32 offset,
        RwInt32 size)
{
  int *v7; // r1
  int v8; // r1
  int v10[5]; // [sp+0h] [bp-28h] BYREF
  __int64 v11; // [sp+14h] [bp-14h]

  v7 = *(int **)((char *)pData + CCustomCarEnvMapPipeline::ms_specularMapPluginOffset);
  v11 = 0LL;
  memset(v10, 0, sizeof(v10));
  if ( v7 )
  {
    v10[0] = *v7;
    v8 = v7[1];
    if ( v8 )
      strncpy((char *)&v10[1], (const char *)(v8 + 16), 0x18u);
  }
  RwStreamWrite(pStream, v10, len);
  return pStream;
}
// 6795C4: using guessed type int *CCustomCarEnvMapPipeline::ms_specularMapPluginOffset;

//----- (002CCEA8) --------------------------------------------------------
RwInt32 __fastcall CCustomCarEnvMapPipeline::pluginSpecMatStreamGetSizeCB(
        const void *pData,
        RwInt32 offset,
        RwInt32 size)
{
  RwInt32 result; // r0

  result = CCustomCarEnvMapPipeline::ms_specularMapPluginOffset;
  if ( CCustomCarEnvMapPipeline::ms_specularMapPluginOffset != -1 )
    return 28;
  return result;
}

//----- (002CCEBC) --------------------------------------------------------
void __fastcall CCustomCarEnvMapPipeline::SetCustomEnvMapPipeAtomicDataDefaults(CustomEnvMapPipeAtomicData *pData)
{
  pData->fOffsetU = 0.0;
  pData->fPrevMapPosX = 0.0;
  pData->fPrevMapPosY = 0.0;
}

//----- (002CCEC8) --------------------------------------------------------
CustomEnvMapPipeAtomicData *__fastcall CCustomCarEnvMapPipeline::AllocEnvMapPipeAtomicData(RpAtomic_0 *pAtomic)
{
  int32 v1; // r12
  int v3; // r2
  CustomEnvMapPipeAtomicDataPool *v4; // r3
  int32 m_nFreeIndex; // r1
  int32 m_nSize; // lr
  uint8 *m_aFlags; // r4
  int v8; // r5
  int v9; // r2
  CustomEnvMapPipeAtomicData *v10; // r1

  v1 = CCustomCarEnvMapPipeline::ms_envMapAtmPluginOffset;
  if ( *(_DWORD *)(&pAtomic->object.object.type + CCustomCarEnvMapPipeline::ms_envMapAtmPluginOffset) )
    return *(CustomEnvMapPipeAtomicData **)(&pAtomic->object.object.type
                                          + CCustomCarEnvMapPipeline::ms_envMapAtmPluginOffset);
  v3 = 0;
  v4 = CCustomCarEnvMapPipeline::m_gEnvMapPipeAtmDataPool;
  m_nFreeIndex = CCustomCarEnvMapPipeline::m_gEnvMapPipeAtmDataPool->m_nFreeIndex;
  m_nSize = CCustomCarEnvMapPipeline::m_gEnvMapPipeAtmDataPool->m_nSize;
  do
  {
    v4->m_nFreeIndex = ++m_nFreeIndex;
    if ( m_nFreeIndex == m_nSize )
    {
      m_nFreeIndex = 0;
      v4->m_nFreeIndex = 0;
      if ( v3 << 31 )
      {
        *(_DWORD *)(&pAtomic->object.object.type + v1) = 0;
        return 0;
      }
      v3 = 1;
    }
    m_aFlags = v4->m_aFlags;
    v8 = (char)m_aFlags[m_nFreeIndex];
  }
  while ( v8 > -1 );
  m_aFlags[m_nFreeIndex] = v8 & 0x7F;
  v4->m_aFlags[v4->m_nFreeIndex] = (v4->m_aFlags[v4->m_nFreeIndex] + 1) & 0x7F | v4->m_aFlags[v4->m_nFreeIndex] & 0x80;
  v9 = (int)v4->m_aStorage[v4->m_nFreeIndex];
  v10 = 0;
  *(_DWORD *)(&pAtomic->object.object.type + v1) = v9;
  if ( v9 )
  {
    *(_DWORD *)v9 = 0;
    *(_DWORD *)(v9 + 4) = 0;
    *(_DWORD *)(v9 + 8) = 0;
    return (CustomEnvMapPipeAtomicData *)v9;
  }
  return v10;
}

//----- (002CCF60) --------------------------------------------------------
void __fastcall CGrassRenderer::AddTriPlant(PPTriPlant *pSrcPlant, uint32 ePlantModelSet)
{
  RpAtomic_0 **v4; // r6
  int v5; // r8
  RwMatrix *v6; // r3
  int32 m_currentIndex; // r5
  RpAtomic_0 **v8; // r6
  int v9; // r5
  RwMatrix *v10; // r3
  RpAtomic_0 **v11; // r5
  int v12; // r4
  RwMatrix *v13; // r3

  if ( PPTriPlantBuffer.m_plantModelsSet != ePlantModelSet )
  {
    if ( PPTriPlantBuffer.m_currentIndex >= 1 )
    {
      v4 = 0;
      if ( PPTriPlantBuffer.m_plantModelsSet <= 3u )
        v4 = PPTriPlantBuffer.m_pPlantModelsTab[PPTriPlantBuffer.m_plantModelsSet];
      v5 = rand();
      CGrassRenderer::DrawTriPlants(PPTriPlantBuffer.m_Buffer, PPTriPlantBuffer.m_currentIndex, v4, v6);
      PPTriPlantBuffer.m_currentIndex = 0;
      srand(v5);
    }
    PPTriPlantBuffer.m_plantModelsSet = ePlantModelSet;
  }
  m_currentIndex = PPTriPlantBuffer.m_currentIndex;
  if ( PPTriPlantBuffer.m_currentIndex >= 32 )
  {
    v8 = 0;
    if ( ePlantModelSet <= 3 )
      v8 = PPTriPlantBuffer.m_pPlantModelsTab[ePlantModelSet];
    v9 = rand();
    CGrassRenderer::DrawTriPlants(PPTriPlantBuffer.m_Buffer, PPTriPlantBuffer.m_currentIndex, v8, v10);
    PPTriPlantBuffer.m_currentIndex = 0;
    srand(v9);
    m_currentIndex = PPTriPlantBuffer.m_currentIndex;
  }
  qmemcpy(&PPTriPlantBuffer.m_Buffer[m_currentIndex], pSrcPlant, sizeof(PPTriPlantBuffer.m_Buffer[m_currentIndex]));
  if ( PPTriPlantBuffer.m_plantModelsSet == ePlantModelSet )
  {
    PPTriPlantBuffer.m_currentIndex = m_currentIndex + 1;
    if ( m_currentIndex >= 31 )
    {
      v11 = 0;
      if ( ePlantModelSet <= 3 )
        v11 = PPTriPlantBuffer.m_pPlantModelsTab[ePlantModelSet];
      v12 = rand();
      CGrassRenderer::DrawTriPlants(PPTriPlantBuffer.m_Buffer, PPTriPlantBuffer.m_currentIndex, v11, v13);
      PPTriPlantBuffer.m_currentIndex = 0;
      sub_18D6C4(v12);
    }
  }
}
// 2CCFAC: variable 'v6' is possibly undefined
// 2CCFF8: variable 'v10' is possibly undefined
// 2CD05E: variable 'v13' is possibly undefined
// FC: using guessed type int elf_hash_bucket[16411];

//----- (002CD0AC) --------------------------------------------------------
void __fastcall CPPTriPlantBuffer::ChangeCurrentPlantModelsSet(CPPTriPlantBuffer *this, int32 newSet)
{
  unsigned int m_plantModelsSet; // r0
  RpAtomic_0 **v5; // r6
  int v6; // r8
  RwMatrix *v7; // r3

  m_plantModelsSet = this->m_plantModelsSet;
  if ( m_plantModelsSet != newSet )
  {
    if ( this->m_currentIndex >= 1 )
    {
      v5 = 0;
      if ( m_plantModelsSet <= 3 )
        v5 = this->m_pPlantModelsTab[m_plantModelsSet];
      v6 = rand();
      CGrassRenderer::DrawTriPlants(this->m_Buffer, this->m_currentIndex, v5, v7);
      this->m_currentIndex = 0;
      srand(v6);
    }
    this->m_plantModelsSet = newSet;
  }
}
// 2CD0E8: variable 'v7' is possibly undefined

//----- (002CD100) --------------------------------------------------------
PPTriPlant *__fastcall CPPTriPlantBuffer::GetPPTriPlantPtr(CPPTriPlantBuffer *this, int32 amountToAdd)
{
  int32 m_currentIndex; // r0
  bool v4; // cc
  unsigned int m_plantModelsSet; // r0
  RpAtomic_0 **v6; // r5
  int v7; // r6
  RwMatrix *v8; // r3

  m_currentIndex = this->m_currentIndex;
  v4 = m_currentIndex < 1;
  if ( m_currentIndex >= 1 )
    v4 = amountToAdd + m_currentIndex < 33;
  if ( !v4 )
  {
    m_plantModelsSet = this->m_plantModelsSet;
    v6 = 0;
    if ( m_plantModelsSet <= 3 )
      v6 = this->m_pPlantModelsTab[m_plantModelsSet];
    v7 = rand();
    CGrassRenderer::DrawTriPlants(this->m_Buffer, this->m_currentIndex, v6, v8);
    this->m_currentIndex = 0;
    srand(v7);
    m_currentIndex = this->m_currentIndex;
  }
  return &this->m_Buffer[m_currentIndex];
}
// 2CD13A: variable 'v8' is possibly undefined

//----- (002CD158) --------------------------------------------------------
void __fastcall CPPTriPlantBuffer::IncreaseBufferIndex(CPPTriPlantBuffer *this, int32 pipeMode, int32 amount)
{
  int32 v4; // r0
  RpAtomic_0 **v5; // r5
  int v6; // r6
  RwMatrix *v7; // r3

  if ( this->m_plantModelsSet == pipeMode )
  {
    v4 = this->m_currentIndex + amount;
    this->m_currentIndex = v4;
    if ( v4 >= 32 )
    {
      v5 = 0;
      if ( (unsigned int)pipeMode <= 3 )
        v5 = this->m_pPlantModelsTab[pipeMode];
      v6 = rand();
      CGrassRenderer::DrawTriPlants(this->m_Buffer, this->m_currentIndex, v5, v7);
      this->m_currentIndex = 0;
      sub_18D6C4(v6);
    }
  }
}
// 2CD196: variable 'v7' is possibly undefined

//----- (002CD1B4) --------------------------------------------------------
void CGrassRenderer::FlushTriPlantBuffer()
{
  RpAtomic_0 **v0; // r4
  int v1; // r5
  RwMatrix *v2; // r3

  if ( PPTriPlantBuffer.m_currentIndex >= 1 )
  {
    v0 = 0;
    if ( PPTriPlantBuffer.m_plantModelsSet <= 3u )
      v0 = PPTriPlantBuffer.m_pPlantModelsTab[PPTriPlantBuffer.m_plantModelsSet];
    v1 = rand();
    CGrassRenderer::DrawTriPlants(PPTriPlantBuffer.m_Buffer, PPTriPlantBuffer.m_currentIndex, v0, v2);
    PPTriPlantBuffer.m_currentIndex = 0;
    sub_18D6C4(v1);
  }
}
// 2CD1F8: variable 'v2' is possibly undefined

//----- (002CD220) --------------------------------------------------------
void __fastcall CPPTriPlantBuffer::Flush(CPPTriPlantBuffer *this)
{
  unsigned int m_plantModelsSet; // r0
  RpAtomic_0 **v3; // r5
  int v4; // r6
  RwMatrix *v5; // r3

  if ( this->m_currentIndex >= 1 )
  {
    m_plantModelsSet = this->m_plantModelsSet;
    v3 = 0;
    if ( m_plantModelsSet <= 3 )
      v3 = this->m_pPlantModelsTab[m_plantModelsSet];
    v4 = rand();
    CGrassRenderer::DrawTriPlants(this->m_Buffer, this->m_currentIndex, v3, v5);
    this->m_currentIndex = 0;
    sub_18D6C4(v4);
  }
}
// 2CD254: variable 'v5' is possibly undefined

//----- (002CD270) --------------------------------------------------------
bool8 __fastcall CGrassRenderer::SetPlantModelsTab(uint32 index, RpAtomic_0 **plantModels)
{
  if ( index > 3 )
    return 0;
  PPTriPlantBuffer.m_pPlantModelsTab[index] = plantModels;
  return 1;
}

//----- (002CD28C) --------------------------------------------------------
bool8 __fastcall CPPTriPlantBuffer::SetPlantModelsTab(CPPTriPlantBuffer *this, uint32 index, RpAtomic_0 **pPlantModels)
{
  if ( index > 3 )
    return 0;
  this->m_pPlantModelsTab[index] = pPlantModels;
  return 1;
}

//----- (002CD2A0) --------------------------------------------------------
RpAtomic_0 **__fastcall CGrassRenderer::GetPlantModelsTab(uint32 index)
{
  if ( index <= 3 )
    return PPTriPlantBuffer.m_pPlantModelsTab[index];
  else
    return 0;
}

//----- (002CD2BC) --------------------------------------------------------
RpAtomic_0 **__fastcall CPPTriPlantBuffer::GetPlantModelsTab(CPPTriPlantBuffer *this, uint32 index)
{
  if ( index <= 3 )
    return this->m_pPlantModelsTab[index];
  else
    return 0;
}

//----- (002CD2CC) --------------------------------------------------------
void __fastcall CGrassRenderer::SetGlobalCameraPos(const CVector *camPos)
{
  __int64 v1; // d16

  v1 = *(_QWORD *)&camPos->x;
  CGrassRenderer::m_vecCameraPos.z = camPos->z;
  *(_QWORD *)&CGrassRenderer::m_vecCameraPos.x = v1;
}

//----- (002CD2E4) --------------------------------------------------------
void __fastcall CGrassRenderer::SetCloseFarAlphaDist(float closeDist, float farDist)
{
  CGrassRenderer::m_farDist = farDist;
  CGrassRenderer::m_closeDist = closeDist;
}

//----- (002CD300) --------------------------------------------------------
void __fastcall CGrassRenderer::SetGlobalWindBending(float bending)
{
  CGrassRenderer::m_windBending = bending;
}

//----- (002CD310) --------------------------------------------------------
RwBool __fastcall CGrassRenderer::DrawTriPlants(
        PPTriPlant *triPlants,
        RwInt32 numTriPlants,
        RpAtomic_0 **plantModelsTab,
        RwMatrix *pLTM)
{
  float32x2_t v4; // d0
  float32x2_t v5; // d10
  float32x2_t v6; // d12
  int v7; // r1
  PPTriPlant *v8; // r10
  float32x2_t v9; // d16
  unsigned __int64 v10; // d1
  float v11; // s0
  FxQuality_e FxQuality; // r0
  float v13; // s30
  float v14; // s17
  RwFrame_0 *parent; // r9
  int alpha; // r0
  float32x2_t v17; // d0
  RwTexture_0 *texture_ptr; // r6
  RpGeometry_0 *geometry; // r0
  int num_plants; // r8
  float v27; // s2
  float v28; // s0
  float v29; // s4
  float32x2_t v30; // d16
  float v31; // s2
  unsigned __int64 v32; // d2
  float x; // s30
  float scale_var_xy; // s17
  float v35; // s0
  RwReal v36; // s2
  RwReal v37; // s0
  float y; // s30
  float scale_var_z; // s17
  float wind_bend_var; // s30
  RwReal v41; // s0
  int v46; // [sp+18h] [bp-A0h]
  RpAtomic_0 *v47; // [sp+3Ch] [bp-7Ch]
  RwV3d_0 pData[9]; // [sp+4Ch] [bp-6Ch] BYREF

  if ( numTriPlants >= 1 )
  {
    v5.n64_u32[0] = 1132396544;
    v7 = 0;
    v6.n64_u32[0] = 0;
    do
    {
      v8 = &triPlants[v7];
      v46 = v7;
      v9.n64_u64[0] = vsub_f32(*(float32x2_t *)&v8->center.y, *(float32x2_t *)&CGrassRenderer::m_vecCameraPos.y).n64_u64[0];
      v10 = vmul_f32(v9, v9).n64_u64[0];
      v11 = (float)((float)(v8->center.x - CGrassRenderer::m_vecCameraPos.x)
                  * (float)(v8->center.x - CGrassRenderer::m_vecCameraPos.x))
          + *(float *)&v10;
      FxQuality = Fx_c::GetFxQuality(&g_fx);
      v13 = sqrtf(v11 + *((float *)&v10 + 1));
      v14 = CGrassRenderer::m_farDist * 0.5;
      if ( FxQuality > FX_QUALITY_MEDIUM )
        v14 = CGrassRenderer::m_farDist;
      if ( v13 <= (float)(v14 + 20.0) )
      {
        v47 = plantModelsTab[v8->model_id];
        parent = (RwFrame_0 *)v47->object.object.parent;
        srand((unsigned int)v8->seed);
        alpha = v8->color._anon_0._anon_0.alpha;
        if ( v13 >= v14 )
        {
          v4.n64_f32[0] = (float)(int)floorf((float)((float)((float)(v14 + 20.0) - v13) / 20.0) * (float)(unsigned int)alpha);
          v17.n64_u64[0] = vmin_f32(v4, v5).n64_u64[0];
          v17.n64_f32[0] = (float)(int)v17.n64_f32[0];
          v4.n64_u64[0] = vmax_f32(v17, v6).n64_u64[0];
          alpha = (int)v4.n64_f32[0];
        }
        v4.n64_f32[0] = (float)v8->intensity;
        v4.n64_u64[0] = vmin_f32(v4, v5).n64_u64[0];
        v4.n64_u32[0] = (unsigned int)v4.n64_f32[0];
        texture_ptr = v8->texture_ptr;
        _R1 = (v8->color._anon_0._anon_0.blue * v4.n64_u32[0]) << 8;
        __asm { UXTB16.W        R1, R1 }
        LODWORD(pData[0].x) = (v8->color._anon_0._anon_0.green * v4.n64_u16[0]) & 0xFF00 | (alpha << 24) | _R1 | (unsigned __int8)((unsigned __int16)(v8->color._anon_0._anon_0.red * v4.n64_u16[0]) >> 8);
        geometry = v47->geometry;
        _pPlantTexture = texture_ptr;
        RpGeometryForAllMaterials(geometry, setMatColourAndTextureCB, pData);
        num_plants = v8->num_plants;
        if ( v8->num_plants )
        {
          do
          {
            while ( 1 )
            {
              v27 = (float)((float)rand() * 4.6566e-10) + 0.0;
              v28 = (float)((float)rand() * 4.6566e-10) + 0.0;
              if ( (float)(v27 + v28) > 1.0 )
              {
                v27 = 1.0 - v27;
                v28 = 1.0 - v28;
              }
              v29 = (float)(1.0 - v27) - v28;
              *(float32x2_t *)&pData[0].x = vadd_f32(
                                              vmul_n_f32(*(float32x2_t *)&v8->V3.x, v28),
                                              vadd_f32(
                                                vmul_n_f32(*(float32x2_t *)&v8->V2.x, v27),
                                                vmul_n_f32(*(float32x2_t *)&v8->V1.x, v29)));
              v30.n64_u64[0] = vsub_f32(*(float32x2_t *)&pData[0].x, *(float32x2_t *)&CGrassRenderer::m_vecCameraPos.x).n64_u64[0];
              v31 = (float)(v29 * v8->V1.z) + (float)(v27 * v8->V2.z);
              v32 = vmul_f32(v30, v30).n64_u64[0];
              pData[0].z = v31 + (float)(v28 * v8->V3.z);
              if ( sqrtf(
                     (float)(*(float *)&v32 + *((float *)&v32 + 1))
                   + (float)((float)(pData[0].z - CGrassRenderer::m_vecCameraPos.z)
                           * (float)(pData[0].z - CGrassRenderer::m_vecCameraPos.z))) >= (float)(CGrassRenderer::m_closeDist
                                                                                               + -2.0) )
                break;
              rand();
              rand();
              rand();
              if ( !--num_plants )
                goto LABEL_15;
            }
            RwFrameTranslate(parent, pData, rwCOMBINEREPLACE);
            x = v8->scale.x;
            scale_var_xy = v8->scale_var_xy;
            v35 = x + (float)(scale_var_xy * (float)((float)((float)rand() * 4.6566e-10) + 0.0));
            v36 = parent->modelling.right.x * v35;
            v37 = parent->modelling.up.y * v35;
            parent->modelling.right.x = v36;
            parent->modelling.up.y = v37;
            y = v8->scale.y;
            scale_var_z = v8->scale_var_z;
            parent->modelling.at.z = parent->modelling.at.z
                                   * (float)(y
                                           + (float)(scale_var_z * (float)((float)((float)rand() * 4.6566e-10) + 0.0)));
            wind_bend_var = v8->wind_bend_var;
            v41 = (float)(CGrassRenderer::m_windBending * v8->wind_bend_scale)
                * (float)((float)(wind_bend_var * (float)((float)((float)rand() * 4.6566e-10) + 0.0)) + 1.0);
            parent->modelling.at.x = v41;
            parent->modelling.at.y = v41;
            RwMatrixUpdate(&parent->modelling);
            ((void (*)(void))v47->renderCallBack)();
            --num_plants;
          }
          while ( num_plants );
        }
      }
LABEL_15:
      v7 = v46 + 1;
    }
    while ( v46 + 1 != numTriPlants );
  }
  return 1;
}
// 2CD432: variable 'v4' is possibly undefined
// 2CD432: variable 'v5' is possibly undefined
// 2CD43E: variable 'v6' is possibly undefined

//----- (002CD6F8) --------------------------------------------------------
void __fastcall CPPTriPlantBuffer::CPPTriPlantBuffer(CPPTriPlantBuffer *this)
{
  this->m_pPlantModelsTab[3] = 0;
  this->m_currentIndex = 0;
  *(_QWORD *)&this->m_plantModelsSet = 0LL;
  *(_QWORD *)&this->m_pPlantModelsTab[1] = 0LL;
}

//----- (002CD710) --------------------------------------------------------
RpMaterial_0 *__fastcall setMatColourAndTextureCB(RpMaterial_0 *pMat, void *pData)
{
  RwTexture_0 *texture; // r2

  texture = pMat->texture;
  pMat->color = *(RwRGBA_0 *)pData;
  if ( texture != _pPlantTexture )
    RpMaterialSetTexture(pMat, _pPlantTexture);
  return pMat;
}

//----- (002CD738) --------------------------------------------------------
void CPlantMgr::Shutdown()
{
  CPlantColEntEntry *v0; // r0
  CPlantColEntEntry *m_pNextEntry; // r4
  int i; // r11
  RpAtomic_0 *v3; // r0
  RwFrame_0 *parent; // r4
  RpAtomic_0 *v5; // r0
  RwFrame_0 *v6; // r4
  RpAtomic_0 *v7; // r0
  RwFrame_0 *v8; // r4
  RpAtomic_0 *v9; // r0
  RwFrame_0 *v10; // r4
  int32 TxdSlot; // r0

  v0 = CPlantMgr::m_CloseColEntListHead;
  if ( CPlantMgr::m_CloseColEntListHead )
  {
    do
    {
      m_pNextEntry = v0->m_pNextEntry;
      CPlantColEntEntry::ReleaseEntry(v0);
      v0 = m_pNextEntry;
    }
    while ( m_pNextEntry );
  }
  for ( i = 0; i != 4; ++i )
  {
    v3 = CPlantMgr::PC_PlantModelsTab0[i];
    if ( v3 )
    {
      parent = (RwFrame_0 *)v3->object.object.parent;
      if ( parent )
      {
        RpAtomicSetFrame(v3, 0);
        RwFrameDestroy(parent);
        v3 = CPlantMgr::PC_PlantModelsTab0[i];
      }
      RpAtomicDestroy(v3);
      CPlantMgr::PC_PlantModelsTab0[i] = 0;
    }
    v5 = CPlantMgr::PC_PlantModelsTab1[i];
    if ( v5 )
    {
      v6 = (RwFrame_0 *)v5->object.object.parent;
      if ( v6 )
      {
        RpAtomicSetFrame(v5, 0);
        RwFrameDestroy(v6);
        v5 = CPlantMgr::PC_PlantModelsTab1[i];
      }
      RpAtomicDestroy(v5);
      CPlantMgr::PC_PlantModelsTab1[i] = 0;
    }
    v7 = CPlantMgr::PC_PlantModelsTab2[i];
    if ( v7 )
    {
      v8 = (RwFrame_0 *)v7->object.object.parent;
      if ( v8 )
      {
        RpAtomicSetFrame(v7, 0);
        RwFrameDestroy(v8);
        v7 = CPlantMgr::PC_PlantModelsTab2[i];
      }
      RpAtomicDestroy(v7);
      CPlantMgr::PC_PlantModelsTab2[i] = 0;
    }
    v9 = CPlantMgr::PC_PlantModelsTab3[i];
    if ( v9 )
    {
      v10 = (RwFrame_0 *)v9->object.object.parent;
      if ( v10 )
      {
        RpAtomicSetFrame(v9, 0);
        RwFrameDestroy(v10);
        v9 = CPlantMgr::PC_PlantModelsTab3[i];
      }
      RpAtomicDestroy(v9);
      CPlantMgr::PC_PlantModelsTab3[i] = 0;
    }
  }
  if ( CPlantMgr::PC_PlantTextureTab0[0] )
  {
    RwTextureDestroy(CPlantMgr::PC_PlantTextureTab0[0]);
    CPlantMgr::PC_PlantTextureTab0[0] = 0;
  }
  if ( CPlantMgr::PC_PlantTextureTab1[0] )
  {
    RwTextureDestroy(CPlantMgr::PC_PlantTextureTab1[0]);
    CPlantMgr::PC_PlantTextureTab1[0] = 0;
  }
  if ( CPlantMgr::PC_PlantTextureTab2[0] )
  {
    RwTextureDestroy(CPlantMgr::PC_PlantTextureTab2[0]);
    CPlantMgr::PC_PlantTextureTab2[0] = 0;
  }
  if ( CPlantMgr::PC_PlantTextureTab3[0] )
  {
    RwTextureDestroy(CPlantMgr::PC_PlantTextureTab3[0]);
    CPlantMgr::PC_PlantTextureTab3[0] = 0;
  }
  if ( CPlantMgr::PC_PlantTextureTab0[1] )
  {
    RwTextureDestroy(CPlantMgr::PC_PlantTextureTab0[1]);
    CPlantMgr::PC_PlantTextureTab0[1] = 0;
  }
  if ( CPlantMgr::PC_PlantTextureTab1[1] )
  {
    RwTextureDestroy(CPlantMgr::PC_PlantTextureTab1[1]);
    CPlantMgr::PC_PlantTextureTab1[1] = 0;
  }
  if ( CPlantMgr::PC_PlantTextureTab2[1] )
  {
    RwTextureDestroy(CPlantMgr::PC_PlantTextureTab2[1]);
    CPlantMgr::PC_PlantTextureTab2[1] = 0;
  }
  if ( CPlantMgr::PC_PlantTextureTab3[1] )
  {
    RwTextureDestroy(CPlantMgr::PC_PlantTextureTab3[1]);
    CPlantMgr::PC_PlantTextureTab3[1] = 0;
  }
  if ( CPlantMgr::PC_PlantTextureTab0[2] )
  {
    RwTextureDestroy(CPlantMgr::PC_PlantTextureTab0[2]);
    CPlantMgr::PC_PlantTextureTab0[2] = 0;
  }
  if ( CPlantMgr::PC_PlantTextureTab1[2] )
  {
    RwTextureDestroy(CPlantMgr::PC_PlantTextureTab1[2]);
    CPlantMgr::PC_PlantTextureTab1[2] = 0;
  }
  if ( CPlantMgr::PC_PlantTextureTab2[2] )
  {
    RwTextureDestroy(CPlantMgr::PC_PlantTextureTab2[2]);
    CPlantMgr::PC_PlantTextureTab2[2] = 0;
  }
  if ( CPlantMgr::PC_PlantTextureTab3[2] )
  {
    RwTextureDestroy(CPlantMgr::PC_PlantTextureTab3[2]);
    CPlantMgr::PC_PlantTextureTab3[2] = 0;
  }
  if ( CPlantMgr::PC_PlantTextureTab0[3] )
  {
    RwTextureDestroy(CPlantMgr::PC_PlantTextureTab0[3]);
    CPlantMgr::PC_PlantTextureTab0[3] = 0;
  }
  if ( CPlantMgr::PC_PlantTextureTab1[3] )
  {
    RwTextureDestroy(CPlantMgr::PC_PlantTextureTab1[3]);
    CPlantMgr::PC_PlantTextureTab1[3] = 0;
  }
  if ( CPlantMgr::PC_PlantTextureTab2[3] )
  {
    RwTextureDestroy(CPlantMgr::PC_PlantTextureTab2[3]);
    CPlantMgr::PC_PlantTextureTab2[3] = 0;
  }
  if ( CPlantMgr::PC_PlantTextureTab3[3] )
  {
    RwTextureDestroy(CPlantMgr::PC_PlantTextureTab3[3]);
    CPlantMgr::PC_PlantTextureTab3[3] = 0;
  }
  TxdSlot = CTxdStore::FindTxdSlot("grass_pc");
  if ( TxdSlot != -1 )
    sub_197460(TxdSlot);
}

//----- (002CDAC0) --------------------------------------------------------
void __fastcall CPlantColEntEntry::ReleaseEntry(CPlantColEntEntry *this)
{
  CPlantLocTri **m_LocTriArray; // r0
  uint16 m_nNumTris; // r1
  int v4; // r5
  CPlantLocTri *v5; // r0
  CPlantColEntEntry *m_pPrevEntry; // r0
  CPlantColEntEntry *m_pNextEntry; // r1
  CPlantColEntEntry *v8; // r1
  CPlantColEntEntry *v9; // r0

  m_LocTriArray = this->m_LocTriArray;
  if ( m_LocTriArray )
  {
    m_nNumTris = this->m_nNumTris;
    if ( m_nNumTris )
    {
      v4 = 0;
      while ( 1 )
      {
        v5 = m_LocTriArray[v4];
        if ( v5 )
        {
          CPlantLocTri::Release(v5);
          m_nNumTris = this->m_nNumTris;
        }
        if ( ++v4 >= m_nNumTris )
          break;
        m_LocTriArray = this->m_LocTriArray;
      }
      m_LocTriArray = this->m_LocTriArray;
    }
    CMemoryMgr::Free(m_LocTriArray);
    this->m_nNumTris = 0;
    this->m_LocTriArray = 0;
  }
  if ( this->m_pEntity )
  {
    CEntity::CleanUpOldReference(this->m_pEntity, &this->m_pEntity);
    this->m_pEntity = 0;
  }
  m_pPrevEntry = this->m_pPrevEntry;
  m_pNextEntry = this->m_pNextEntry;
  if ( m_pPrevEntry )
  {
    if ( m_pNextEntry )
    {
      m_pNextEntry->m_pPrevEntry = m_pPrevEntry;
      m_pPrevEntry = this->m_pPrevEntry;
      v8 = this->m_pNextEntry;
    }
    else
    {
      v8 = 0;
    }
    m_pPrevEntry->m_pNextEntry = v8;
  }
  else
  {
    CPlantMgr::m_CloseColEntListHead = this->m_pNextEntry;
    if ( m_pNextEntry )
      m_pNextEntry->m_pPrevEntry = 0;
  }
  v9 = CPlantMgr::m_UnusedColEntListHead;
  this->m_pNextEntry = CPlantMgr::m_UnusedColEntListHead;
  this->m_pPrevEntry = 0;
  CPlantMgr::m_UnusedColEntListHead = this;
  if ( v9 )
    v9->m_pPrevEntry = this;
}

//----- (002CDB48) --------------------------------------------------------
bool8 __fastcall CPlantMgr::PreUpdateOnceForNewCameraPos(const CVector *newCameraPos)
{
  float v2; // s18
  float v3; // s20
  float v4; // s0
  unsigned int v5; // s2
  unsigned int v6; // r1
  unsigned int v7; // s0
  RwUInt8 v8; // r1
  RwUInt8 v9; // r1
  float v10; // r0
  CPlantColEntEntry *i; // r5

  CGrassRenderer::SetCurrentScanCode(++CPlantMgr::m_scanCode);
  CGrassRenderer::SetGlobalCameraPos(newCameraPos);
  v2 = CTimeCycle::GetAmbientRed() * 2.5;
  v3 = CTimeCycle::GetAmbientGreen() * 2.5;
  v4 = (float)(CTimeCycle::GetAmbientBlue() * 2.5) * 255.0;
  v5 = (unsigned int)(float)(v3 * 255.0);
  v6 = (unsigned int)(float)(v2 * 255.0) + 64;
  if ( (unsigned __int16)v6 > 0xFFu )
    LOBYTE(v6) = -1;
  CPlantMgr::m_AmbientColor._anon_0._anon_0.red = v6;
  v7 = (unsigned int)v4;
  v8 = v5 + 64;
  if ( (unsigned __int16)(v5 + 64) > 0xFFu )
    v8 = -1;
  CPlantMgr::m_AmbientColor._anon_0._anon_0.green = v8;
  v9 = v7 + 64;
  if ( (unsigned __int16)(v7 + 64) > 0xFFu )
    v9 = -1;
  CPlantMgr::m_AmbientColor._anon_0._anon_0.blue = v9;
  v10 = CPlantMgr::CalculateWindBending();
  CGrassRenderer::SetGlobalWindBending(v10);
  CPlantMgr::_ColEntityCache_Update(newCameraPos, 0);
  for ( i = CPlantMgr::m_CloseColEntListHead; i; i = i->m_pNextEntry )
    CPlantMgr::_ProcessEntryCollisionDataSections(i, newCameraPos, -84215046);
  return 1;
}
// 0: using guessed type int dword_0;

//----- (002CDC30) --------------------------------------------------------
void CPlantMgr::UpdateAmbientColor()
{
  float AmbientRed; // s18
  unsigned int v1; // s2
  unsigned int v2; // s0
  unsigned int v3; // r1
  RwUInt8 v4; // r1
  RwUInt8 v5; // r1

  AmbientRed = CTimeCycle::GetAmbientRed();
  v1 = (unsigned int)(float)((float)(CTimeCycle::GetAmbientGreen() * 2.5) * 255.0);
  v2 = (unsigned int)(float)((float)(CTimeCycle::GetAmbientBlue() * 2.5) * 255.0);
  v3 = (unsigned int)(float)((float)(AmbientRed * 2.5) * 255.0) + 64;
  if ( (unsigned __int16)v3 > 0xFFu )
    LOBYTE(v3) = -1;
  CPlantMgr::m_AmbientColor._anon_0._anon_0.red = v3;
  v4 = v1 + 64;
  if ( (unsigned __int16)(v1 + 64) > 0xFFu )
    v4 = -1;
  CPlantMgr::m_AmbientColor._anon_0._anon_0.green = v4;
  v5 = v2 + 64;
  if ( (unsigned __int16)(v2 + 64) > 0xFFu )
    v5 = -1;
  CPlantMgr::m_AmbientColor._anon_0._anon_0.blue = v5;
}
// 0: using guessed type int dword_0;

//----- (002CDCC8) --------------------------------------------------------
float CPlantMgr::CalculateWindBending()
{
  char v0; // r0
  float v1; // s16
  float v2; // r0
  float v3; // s2
  float v5; // s0

  v0 = `guard variable for'CPlantMgr::CalculateWindBending(void)::RandomSeed;
  __dmb(0xBu);
  if ( (v0 & 1) == 0
    && _cxa_guard_acquire((__guard *)&`guard variable for'CPlantMgr::CalculateWindBending(void)::RandomSeed) )
  {
    CPlantMgr::CalculateWindBending(void)::RandomSeed = rand();
    _cxa_guard_release((__guard *)&`guard variable for'CPlantMgr::CalculateWindBending(void)::RandomSeed);
  }
  v1 = CWeather::Wind;
  if ( CWeather::Wind >= 0.5 )
  {
    v5 = (float)(((_WORD)CPlantMgr::CalculateWindBending(void)::RandomSeed + 8 * (_WORD)CTimer::m_snTimeInMilliseconds) & 0xFFF)
       * 0.00024414;
    return CWeather::Wind
         * (float)((float)((float)(WindTabel[((unsigned __int8)((CPlantMgr::CalculateWindBending(void)::RandomSeed
                                                               + 8 * CTimer::m_snTimeInMilliseconds) >> 12)
                                            + 1) & 0xF]
                                 * v5)
                         + (float)((float)(WindTabel[(unsigned __int16)(CPlantMgr::CalculateWindBending(void)::RandomSeed
                                                                      + 8 * CTimer::m_snTimeInMilliseconds) >> 12]
                                         * (float)(1.0 - v5))
                                 + 1.0))
                 * 0.015);
  }
  else
  {
    v2 = sinf((float)(CTimer::m_snTimeInMilliseconds & 0xFFF) * 0.0015332);
    if ( v1 < 0.2 )
      v3 = 0.005;
    else
      v3 = 0.008;
    return v2 * v3;
  }
}
// 712314: using guessed type char `guard variable for'CPlantMgr::CalculateWindBending(void)::RandomSeed;

//----- (002CDE10) --------------------------------------------------------
bool8 __fastcall CPlantMgr::_ColEntityCache_Update(const CVector *camPos, bool8 bQuickUpdate)
{
  float v2; // s0
  CPlantColEntEntry *v4; // r5
  CPlantColEntEntry *m_pNextEntry; // r4
  CPlantColEntEntry *v6; // r6
  CEntity *m_pEntity; // r0
  int m_areaCode; // r0
  bool v9; // zf
  float y; // s4
  float v11; // s20
  float v12; // s24
  float v13; // r5
  float v14; // s16
  float v15; // r0
  int v16; // r2
  float v17; // s0
  int v18; // r1
  int v19; // r5
  int v20; // r2
  uint16 v21; // r0
  bool8 result; // r0
  int v23; // r0
  int v24; // r9
  int v25; // r0
  CPtrNode *m_pHead; // r4
  CPtrNode v27; // kr00_8
  int v28; // r1
  bool v29; // zf
  CBaseModelInfo *v30; // r6
  int v31; // r0
  CPlantColEntEntry *v32; // r0
  int v34; // [sp+0h] [bp-70h]
  int v35; // [sp+4h] [bp-6Ch]
  int v36; // [sp+8h] [bp-68h]
  CVector *pos; // [sp+14h] [bp-5Ch]
  int v38; // [sp+20h] [bp-50h]
  int v39; // [sp+24h] [bp-4Ch]

  v4 = CPlantMgr::m_CloseColEntListHead;
  if ( bQuickUpdate )
  {
    if ( CPlantMgr::m_CloseColEntListHead )
    {
      do
      {
        m_pNextEntry = v4->m_pNextEntry;
        if ( !v4->m_pEntity )
          CPlantColEntEntry::ReleaseEntry(v4);
        v4 = m_pNextEntry;
      }
      while ( m_pNextEntry );
    }
    return 1;
  }
  if ( CPlantMgr::m_CloseColEntListHead )
  {
    do
    {
      v6 = v4;
      m_pEntity = v4->m_pEntity;
      v4 = v4->m_pNextEntry;
      if ( m_pEntity )
      {
        _CalcDistanceSqrToEntity(m_pEntity, camPos);
        if ( v2 <= 115600.0 )
        {
          m_areaCode = v6->m_pEntity->m_areaCode;
          v9 = m_areaCode == 13;
          if ( m_areaCode != 13 )
            v9 = CGame::currArea == m_areaCode;
          if ( v9 )
            continue;
        }
      }
      CPlantColEntEntry::ReleaseEntry(v6);
    }
    while ( v4 );
  }
  if ( !CPlantMgr::m_UnusedColEntListHead )
    return 1;
  y = camPos->y;
  v11 = camPos->x + 340.0;
  v12 = floorf((float)((float)(camPos->x + -340.0) / 50.0) + 60.0);
  v13 = floorf((float)((float)(y + -340.0) / 50.0) + 60.0);
  v14 = floorf((float)(v11 / 50.0) + 60.0);
  v15 = floorf((float)((float)(y + 340.0) / 50.0) + 60.0);
  v16 = 119;
  LODWORD(v17) = (int)v15;
  v18 = (int)v15;
  v19 = (int)v13;
  if ( (int)v15 >= 119 )
    v18 = 119;
  v34 = v18;
  if ( (int)v14 < 119 )
    v16 = (int)v14;
  v39 = v16;
  v20 = 0;
  if ( v19 <= 0 )
    v19 = 0;
  if ( (int)v12 > 0 )
    v20 = (int)v12;
  v35 = v20;
  if ( CWorld::ms_nCurrentScanCode == 0xFFFF )
  {
    CWorld::ClearScanCodes();
    v21 = 1;
  }
  else
  {
    v21 = CWorld::ms_nCurrentScanCode + 1;
  }
  CWorld::ms_nCurrentScanCode = v21;
  if ( v19 > v34 )
    return 1;
  pos = (CVector *)camPos;
  do
  {
    v36 = v19;
    if ( v35 <= v39 )
    {
      v23 = 119;
      if ( v19 < 119 )
        v23 = v19;
      v24 = v35;
      v38 = 120 * v23;
      while ( 2 )
      {
        v25 = 119;
        if ( v24 < 119 )
          v25 = v24;
        m_pHead = CWorld::ms_aSectors[v25 + v38].m_buildingPtrListArray.m_pHead;
        while ( m_pHead )
        {
          v27 = *m_pHead;
          m_pHead = m_pHead->m_pNext;
          if ( (*((_BYTE *)v27.m_pVoid + 31) & 4) == 0
            && *((unsigned __int16 *)v27.m_pVoid + 24) != CWorld::ms_nCurrentScanCode )
          {
            v28 = *((unsigned __int8 *)v27.m_pVoid + 51);
            *((_WORD *)v27.m_pVoid + 24) = CWorld::ms_nCurrentScanCode;
            v29 = v28 == 13;
            if ( v28 != 13 )
              v29 = CGame::currArea == v28;
            if ( v29 )
            {
              v30 = CModelInfo::ms_modelInfoPtrs[*((__int16 *)v27.m_pVoid + 19)];
              v31 = (*((int (__fastcall **)(CBaseModelInfo *))v30->_vptr$CBaseModelInfo + 5))(v30);
              if ( v30 )
              {
                if ( v31 == 1 && (v30->m_flags & 0x200) != 0 )
                {
                  v32 = CPlantMgr::m_CloseColEntListHead;
                  if ( CPlantMgr::m_CloseColEntListHead )
                  {
                    while ( v32->m_pEntity != v27.m_pVoid )
                    {
                      v32 = v32->m_pNextEntry;
                      if ( !v32 )
                        goto LABEL_50;
                    }
                  }
                  else
                  {
LABEL_50:
                    _CalcDistanceSqrToEntity((CEntity *)v27.m_pVoid, pos);
                    if ( v17 <= 115600.0 )
                    {
                      if ( !CPlantMgr::m_UnusedColEntListHead )
                        return 0;
                      CPlantColEntEntry::AddEntry(CPlantMgr::m_UnusedColEntListHead, (CEntity *)v27.m_pVoid);
                      if ( !CPlantMgr::m_UnusedColEntListHead )
                        return 0;
                    }
                  }
                }
              }
            }
          }
        }
        if ( v24++ < v39 )
          continue;
        break;
      }
    }
    result = 1;
    ++v19;
  }
  while ( v36 < v34 );
  return result;
}
// 2CDE6C: variable 'v2' is possibly undefined

//----- (002CE0EC) --------------------------------------------------------
bool8 __fastcall CPlantMgr::_UpdateLocTris(const CVector *camPos, int32 iTriProcessSkipMask)
{
  CPlantColEntEntry *i; // r6

  for ( i = CPlantMgr::m_CloseColEntListHead; i; i = i->m_pNextEntry )
    CPlantMgr::_ProcessEntryCollisionDataSections(i, camPos, iTriProcessSkipMask);
  return 1;
}

//----- (002CE120) --------------------------------------------------------
bool8 __fastcall CPlantMgr::Update(const CVector *cameraPos)
{
  float v2; // s18
  float v3; // s20
  float v4; // s0
  unsigned int v5; // s2
  unsigned int v6; // r1
  unsigned int v7; // s0
  RwUInt8 v8; // r1
  RwUInt8 v9; // r1
  float v10; // r0
  CPlantColEntEntry *v11; // r0
  CPlantColEntEntry *m_pNextEntry; // r5
  uint8 v13; // r0
  CPlantColEntEntry *v14; // r5
  int v15; // r6

  CGrassRenderer::SetCurrentScanCode(++CPlantMgr::m_scanCode);
  CGrassRenderer::SetGlobalCameraPos(cameraPos);
  v2 = CTimeCycle::GetAmbientRed() * 2.5;
  v3 = CTimeCycle::GetAmbientGreen() * 2.5;
  v4 = (float)(CTimeCycle::GetAmbientBlue() * 2.5) * 255.0;
  v5 = (unsigned int)(float)(v3 * 255.0);
  v6 = (unsigned int)(float)(v2 * 255.0) + 64;
  if ( (unsigned __int16)v6 > 0xFFu )
    LOBYTE(v6) = -1;
  CPlantMgr::m_AmbientColor._anon_0._anon_0.red = v6;
  v7 = (unsigned int)v4;
  v8 = v5 + 64;
  if ( (unsigned __int16)(v5 + 64) > 0xFFu )
    v8 = -1;
  CPlantMgr::m_AmbientColor._anon_0._anon_0.green = v8;
  v9 = v7 + 64;
  if ( (unsigned __int16)(v7 + 64) > 0xFFu )
    v9 = -1;
  CPlantMgr::m_AmbientColor._anon_0._anon_0.blue = v9;
  v10 = CPlantMgr::CalculateWindBending();
  CGrassRenderer::SetGlobalWindBending(v10);
  if ( (++CPlantMgr::Update(CVector const&)::nUpdateEntCache & 0x1F) != 0 )
  {
    v11 = CPlantMgr::m_CloseColEntListHead;
    if ( !CPlantMgr::m_CloseColEntListHead )
    {
      ++CPlantMgr::Update(CVector const&)::nLocTriSkipCounter;
      return 1;
    }
    do
    {
      m_pNextEntry = v11->m_pNextEntry;
      if ( !v11->m_pEntity )
        CPlantColEntEntry::ReleaseEntry(v11);
      v11 = m_pNextEntry;
    }
    while ( m_pNextEntry );
  }
  else
  {
    CPlantMgr::_ColEntityCache_Update(cameraPos, 0);
  }
  v13 = CPlantMgr::Update(CVector const&)::nLocTriSkipCounter;
  v14 = CPlantMgr::m_CloseColEntListHead;
  ++CPlantMgr::Update(CVector const&)::nLocTriSkipCounter;
  if ( CPlantMgr::m_CloseColEntListHead )
  {
    v15 = v13 & 7;
    do
    {
      CPlantMgr::_ProcessEntryCollisionDataSections(v14, cameraPos, v15);
      v14 = v14->m_pNextEntry;
    }
    while ( v14 );
  }
  return 1;
}
// 0: using guessed type int dword_0;

//----- (002CE266) --------------------------------------------------------
float __fastcall _CalcDistanceSqrToEntity(CEntity *pEntity, const CVector *pos)
{
  CColModel *ColModel; // r0
  CMatrix *m_pMat; // r1
  const RwV3d_0 *p_m_vecCentre; // r2
  __int64 v6; // d16
  float result; // r0
  RwV3d_0 v8; // [sp+0h] [bp-40h] BYREF
  CVector v; // [sp+10h] [bp-30h] BYREF
  CVector v10; // [sp+20h] [bp-20h] BYREF

  ColModel = CEntity::GetColModel(pEntity);
  m_pMat = pEntity->m_pMat;
  p_m_vecCentre = &ColModel->m_sphereBound.m_vecCentre;
  if ( m_pMat )
  {
    v6 = *(_QWORD *)&p_m_vecCentre->x;
    v.z = ColModel->m_sphereBound.m_vecCentre.z;
    *(_QWORD *)&v.x = v6;
    operator*(&v10, m_pMat, &v);
    result = v10.z;
    v8 = v10.RwV3d_0;
  }
  else
  {
    TransformPoint(&v8, &pEntity->m_transform, p_m_vecCentre);
  }
  return result;
}

//----- (002CE2FC) --------------------------------------------------------
CPlantColEntEntry *__fastcall CPlantMgr::_ColEntityCache_FindInCache(CEntity *pEntity)
{
  CPlantColEntEntry *result; // r0

  result = CPlantMgr::m_CloseColEntListHead;
  if ( !CPlantMgr::m_CloseColEntListHead )
    return 0;
  while ( result->m_pEntity != pEntity )
  {
    result = result->m_pNextEntry;
    if ( !result )
      return 0;
  }
  return result;
}

//----- (002CE320) --------------------------------------------------------
CPlantColEntEntry *__fastcall CPlantMgr::_ColEntityCache_Add(CEntity *pEntity, bool8 bCheckCacheFirst)
{
  CPlantColEntEntry *v2; // r4
  CPlantColEntEntry *v4; // r4

  if ( bCheckCacheFirst && (v2 = CPlantMgr::m_CloseColEntListHead) != 0 )
  {
    while ( v2->m_pEntity != pEntity )
    {
      v2 = v2->m_pNextEntry;
      if ( !v2 )
        goto LABEL_7;
    }
    return v2;
  }
  else
  {
LABEL_7:
    v4 = CPlantMgr::m_UnusedColEntListHead;
    if ( CPlantMgr::m_UnusedColEntListHead )
    {
      if ( !CPlantColEntEntry::AddEntry(CPlantMgr::m_UnusedColEntListHead, pEntity) )
        return 0;
      return v4;
    }
    else
    {
      return 0;
    }
  }
}

//----- (002CE36C) --------------------------------------------------------
CPlantColEntEntry *__fastcall CPlantColEntEntry::AddEntry(CPlantColEntEntry *this, CEntity *pEntity)
{
  CCollisionData *m_pColData; // r0
  int m_nNoOfTriangles; // r6
  CPlantColEntEntry *v6; // r5
  CPlantLocTri **v7; // r0
  int i; // r0
  CPlantColEntEntry *m_pPrevEntry; // r0
  CPlantColEntEntry *m_pNextEntry; // r1
  CPlantColEntEntry *v11; // r1
  CPlantColEntEntry *v12; // r0

  this->m_pEntity = pEntity;
  CEntity::RegisterReference(pEntity, &this->m_pEntity);
  m_pColData = CEntity::GetColModel(pEntity)->m_pColData;
  if ( !m_pColData )
    return 0;
  m_nNoOfTriangles = m_pColData->m_nNoOfTriangles;
  v6 = 0;
  if ( m_nNoOfTriangles >= 1 )
  {
    this->m_nNumTris = m_nNoOfTriangles;
    v7 = (CPlantLocTri **)CMemoryMgr::Malloc(4 * m_nNoOfTriangles);
    this->m_LocTriArray = v7;
    *v7 = 0;
    if ( m_nNoOfTriangles != 1 )
    {
      for ( i = 1; i != m_nNoOfTriangles; ++i )
        this->m_LocTriArray[i] = 0;
    }
    m_pPrevEntry = this->m_pPrevEntry;
    m_pNextEntry = this->m_pNextEntry;
    if ( m_pPrevEntry )
    {
      if ( m_pNextEntry )
      {
        m_pNextEntry->m_pPrevEntry = m_pPrevEntry;
        m_pPrevEntry = this->m_pPrevEntry;
        v11 = this->m_pNextEntry;
      }
      else
      {
        v11 = 0;
      }
      m_pPrevEntry->m_pNextEntry = v11;
    }
    else
    {
      CPlantMgr::m_UnusedColEntListHead = this->m_pNextEntry;
      if ( m_pNextEntry )
        m_pNextEntry->m_pPrevEntry = 0;
    }
    v6 = this;
    v12 = CPlantMgr::m_CloseColEntListHead;
    this->m_pNextEntry = CPlantMgr::m_CloseColEntListHead;
    this->m_pPrevEntry = 0;
    CPlantMgr::m_CloseColEntListHead = this;
    if ( v12 )
      v12->m_pPrevEntry = this;
  }
  return v6;
}

//----- (002CE408) --------------------------------------------------------
void __fastcall CPlantMgr::_ColEntityCache_Remove(CEntity *pEntity)
{
  CPlantColEntEntry *i; // r1

  for ( i = CPlantMgr::m_CloseColEntListHead; i; i = i->m_pNextEntry )
  {
    if ( i->m_pEntity == pEntity )
    {
      CPlantColEntEntry::ReleaseEntry(i);
      return;
    }
  }
}

//----- (002CE42C) --------------------------------------------------------
bool8 __fastcall CPlantMgr::_ProcessEntryCollisionDataSections(
        CPlantColEntEntry *pEntry,
        const CVector *camPos,
        int32 iTriProcessSkipMask)
{
  CCollisionData *m_pColData; // r6
  int m_nNoOfTriangles; // r0
  int32 colEndIndex; // r5
  int32 *m_modelSec; // r5
  int v11; // r10
  int i; // r8
  __int64 v13; // d16
  __int64 v14; // d16
  const CMatrix *m_pMat; // r2
  CPlantColEntEntry *v16; // [sp+Ch] [bp-94h]
  int32 v17; // [sp+10h] [bp-90h]
  CEntity *m_pEntity; // [sp+24h] [bp-7Ch]
  CBox v19; // [sp+28h] [bp-78h] BYREF
  CSphere v20; // [sp+40h] [bp-60h] BYREF
  RwV3d_0 pResult; // [sp+50h] [bp-50h] BYREF
  CVector v22; // [sp+5Ch] [bp-44h] BYREF
  RwV3d_0 pSource; // [sp+68h] [bp-38h] BYREF
  __int64 v24; // [sp+74h] [bp-2Ch]
  int32 v25; // [sp+7Ch] [bp-24h]

  m_pEntity = pEntry->m_pEntity;
  m_pColData = CEntity::GetColModel(pEntry->m_pEntity)->m_pColData;
  if ( !m_pColData )
    return 0;
  m_nNoOfTriangles = m_pColData->m_nNoOfTriangles;
  if ( m_nNoOfTriangles != pEntry->m_nNumTris )
    return 0;
  colEndIndex = m_nNoOfTriangles - 1;
  CPlantMgr::_ProcessEntryCollisionDataSections_RemoveLocTris(
    pEntry,
    camPos,
    iTriProcessSkipMask,
    0,
    m_nNoOfTriangles - 1);
  if ( (*((_BYTE *)m_pColData + 7) & 2) != 0 )
  {
    m_modelSec = m_pColData->m_modelSec;
    if ( *m_modelSec >= 1 )
    {
      v16 = pEntry;
      v17 = iTriProcessSkipMask;
      v11 = *m_modelSec - 1;
      for ( i = -1; ; i -= 7 )
      {
        v13 = *(_QWORD *)&m_modelSec[i - 6];
        LODWORD(pSource.z) = m_modelSec[i - 4];
        *(_QWORD *)&pSource.x = v13;
        v14 = *(_QWORD *)&m_modelSec[i - 3];
        v25 = m_modelSec[i - 1];
        v24 = v14;
        m_pMat = m_pEntity->m_pMat;
        if ( !m_pMat )
        {
          CPlaceable::AllocateMatrix(m_pEntity);
          CSimpleTransform::UpdateMatrix(&m_pEntity->m_transform, m_pEntity->m_pMat);
          m_pMat = m_pEntity->m_pMat;
        }
        TransformPoints(&pResult, 2, m_pMat, &pSource);
        CBox::Set(&v19, (const CVector *)&pResult, &v22);
        CBox::Recalc(&v19);
        CSphere::Set(&v20, 100.0, camPos);
        if ( CCollision::TestSphereBox(&v20, &v19) )
          CPlantMgr::_ProcessEntryCollisionDataSections_AddLocTris(
            v16,
            camPos,
            v17,
            SLOWORD(m_modelSec[i]),
            SHIWORD(m_modelSec[i]));
        if ( !v11 )
          break;
        --v11;
        m_modelSec = m_pColData->m_modelSec;
      }
    }
  }
  else
  {
    CPlantMgr::_ProcessEntryCollisionDataSections_AddLocTris(pEntry, camPos, iTriProcessSkipMask, 0, colEndIndex);
  }
  return 1;
}

//----- (002CE558) --------------------------------------------------------
void __fastcall CPlantMgr::_ProcessEntryCollisionDataSections_RemoveLocTris(
        CPlantColEntEntry *pEntry,
        const CVector *camPos,
        int32 iTriProcessSkipMask,
        int32 colStartIndex,
        int32 a5)
{
  int32 v9; // r11
  CPlantLocTri *v10; // r5
  bool v11; // zf
  CPlantLocTri *v12; // r0
  float y; // s4
  float v14; // s12
  float v15; // s14
  float v16; // s6
  float v17; // s10
  float z; // s2
  float v19; // s1
  float v20; // s8
  float v21; // s3
  float v22; // s7
  float v23; // s5

  CEntity::GetColModel(pEntry->m_pEntity);
  if ( colStartIndex <= a5 )
  {
    do
    {
      v9 = colStartIndex;
      v10 = pEntry->m_LocTriArray[colStartIndex];
      if ( v10 && (*((_BYTE *)v10 + 72) & 6) == 2 && ProcObjectMan_c::ProcessTriangleAdded(&g_procObjMan, v10) )
        *((_BYTE *)v10 + 72) |= 4u;
      v11 = iTriProcessSkipMask == -84215046;
      if ( iTriProcessSkipMask != -84215046 )
        v11 = (v9 & 7) == iTriProcessSkipMask;
      if ( v11 )
      {
        v12 = pEntry->m_LocTriArray[v9];
        if ( v12 )
        {
          y = camPos->y;
          v14 = camPos->x - v12->m_V1.x;
          v15 = y - v12->m_V1.y;
          v16 = camPos->x - v12->m_V3.x;
          v17 = y - v12->m_V3.y;
          z = camPos->z;
          v19 = z - v12->m_V1.z;
          v20 = z - v12->m_V3.z;
          if ( (float)((float)((float)((float)((float)(v14 + v16) * 0.5) * (float)((float)(v14 + v16) * 0.5))
                             + (float)((float)((float)(v15 + v17) * 0.5) * (float)((float)(v15 + v17) * 0.5)))
                     + (float)((float)((float)(v19 + v20) * 0.5) * (float)((float)(v19 + v20) * 0.5))) >= 10000.0 )
          {
            v21 = camPos->x - v12->m_V2.x;
            v22 = y - v12->m_V2.y;
            v23 = z - v12->m_V2.z;
            if ( (float)((float)((float)((float)((float)(v21 + v16) * 0.5) * (float)((float)(v21 + v16) * 0.5))
                               + (float)((float)((float)(v22 + v17) * 0.5) * (float)((float)(v22 + v17) * 0.5)))
                       + (float)((float)((float)(v23 + v20) * 0.5) * (float)((float)(v23 + v20) * 0.5))) >= 10000.0
              && (float)((float)((float)((float)((float)(v14 + v21) * 0.5) * (float)((float)(v14 + v21) * 0.5))
                               + (float)((float)((float)(v15 + v22) * 0.5) * (float)((float)(v15 + v22) * 0.5)))
                       + (float)((float)((float)(v19 + v23) * 0.5) * (float)((float)(v19 + v23) * 0.5))) >= 10000.0
              && (float)((float)((float)(v14 * v14) + (float)(v15 * v15)) + (float)(v19 * v19)) >= 10000.0
              && (float)((float)((float)(v16 * v16) + (float)(v17 * v17)) + (float)(v20 * v20)) >= 10000.0 )
            {
              CPlantLocTri::Release(v12);
              pEntry->m_LocTriArray[v9] = 0;
            }
          }
        }
      }
      colStartIndex = v9 + 1;
    }
    while ( v9 < a5 );
  }
}

//----- (002CE794) --------------------------------------------------------
void __fastcall CPlantMgr::_ProcessEntryCollisionDataSections_AddLocTris(
        CPlantColEntEntry *pEntry,
        const CVector *camPos,
        int32 iTriProcessSkipMask,
        int32 colStartIndex,
        int32 colEndIndex)
{
  CPlantColEntEntry *v5; // r5
  int32 v8; // r3
  int v9; // r9
  int v10; // r11
  bool v11; // zf
  int32 v12; // r8
  CColTriangle *m_pTriangleArray; // r6
  const CMatrix *m_pMat; // r2
  float z; // s3
  float x; // s7
  float v17; // s6
  float v18; // s4
  float y; // s15
  float v20; // s10
  float v21; // s8
  float v22; // s14
  float v23; // s12
  float v24; // s11
  int v25; // r6
  int createsObjects; // r0
  CPlantLocTri *v27; // r5
  int v28; // r0
  int v29; // r1
  CCollisionData *m_pColData; // [sp+30h] [bp-C0h]
  CPlantColEntEntry *v32; // [sp+38h] [bp-B8h]
  CEntity *m_pEntity; // [sp+40h] [bp-B0h]
  CColTriangle *v34; // [sp+44h] [bp-ACh]
  RwV3d_0 pResult; // [sp+48h] [bp-A8h] BYREF
  RwV3d_0 v36; // [sp+54h] [bp-9Ch] BYREF
  RwV3d_0 v37; // [sp+60h] [bp-90h] BYREF
  CVector pt; // [sp+6Ch] [bp-84h] BYREF
  CVector v39; // [sp+78h] [bp-78h] BYREF
  CVector v40[9]; // [sp+84h] [bp-6Ch] BYREF

  v5 = pEntry;
  m_pEntity = pEntry->m_pEntity;
  m_pColData = CEntity::GetColModel(pEntry->m_pEntity)->m_pColData;
  if ( m_pColData )
  {
    v8 = colEndIndex;
    if ( colStartIndex <= colEndIndex )
    {
      v9 = (16 * colStartIndex) | 8;
      v10 = colStartIndex;
      v32 = v5;
      do
      {
        v11 = iTriProcessSkipMask == -84215046;
        v12 = colStartIndex;
        if ( iTriProcessSkipMask != -84215046 )
          v11 = (colStartIndex & 7) == iTriProcessSkipMask;
        if ( v11 && !v5->m_LocTriArray[v10] && CPlantMgr::m_UnusedLocTriListHead )
        {
          m_pTriangleArray = m_pColData->m_pTriangleArray;
          CCollisionData::GetTrianglePoint(m_pColData, &pt, *(_DWORD *)((char *)m_pTriangleArray + v9 - 8));
          v34 = &m_pTriangleArray[v10];
          CCollisionData::GetTrianglePoint(m_pColData, &v39, v34->m_nIndex2);
          CCollisionData::GetTrianglePoint(m_pColData, v40, *(int32 *)((char *)&m_pTriangleArray->m_nIndex1 + v9));
          m_pMat = m_pEntity->m_pMat;
          if ( !m_pMat )
          {
            CPlaceable::AllocateMatrix(m_pEntity);
            CSimpleTransform::UpdateMatrix(&m_pEntity->m_transform, m_pEntity->m_pMat);
            m_pMat = m_pEntity->m_pMat;
          }
          TransformPoints(&pResult, 3, m_pMat, &pt);
          z = camPos->z;
          x = camPos->x;
          v17 = z - v37.z;
          v18 = camPos->x - pResult.x;
          y = camPos->y;
          v20 = camPos->x - v37.x;
          v21 = y - v37.y;
          if ( (float)((float)((float)((float)((float)(v20 + v18) * 0.5) * (float)((float)(v20 + v18) * 0.5))
                             + (float)((float)((float)((float)(y - v37.y) + (float)(y - pResult.y)) * 0.5)
                                     * (float)((float)((float)(y - v37.y) + (float)(y - pResult.y)) * 0.5)))
                     + (float)((float)((float)((float)(z - v37.z) + (float)(z - pResult.z)) * 0.5)
                             * (float)((float)((float)(z - v37.z) + (float)(z - pResult.z)) * 0.5))) < 10000.0
            || (v22 = x - v36.x,
                v23 = y - v36.y,
                v24 = z - v36.z,
                (float)((float)((float)((float)((float)((float)(x - v36.x) + v20) * 0.5)
                                      * (float)((float)((float)(x - v36.x) + v20) * 0.5))
                              + (float)((float)((float)((float)(y - v36.y) + v21) * 0.5)
                                      * (float)((float)((float)(y - v36.y) + v21) * 0.5)))
                      + (float)((float)((float)((float)(z - v36.z) + v17) * 0.5)
                              * (float)((float)((float)(z - v36.z) + v17) * 0.5))) < 10000.0)
            || (float)((float)((float)((float)((float)(v18 + v22) * 0.5) * (float)((float)(v18 + v22) * 0.5))
                             + (float)((float)((float)((float)(y - pResult.y) + v23) * 0.5)
                                     * (float)((float)((float)(y - pResult.y) + v23) * 0.5)))
                     + (float)((float)((float)((float)(z - pResult.z) + v24) * 0.5)
                             * (float)((float)((float)(z - pResult.z) + v24) * 0.5))) < 10000.0
            || (float)((float)((float)((float)(x - (float)((float)((float)(pResult.x + v36.x) + v37.x) * 0.33333))
                                     * (float)(x - (float)((float)((float)(pResult.x + v36.x) + v37.x) * 0.33333)))
                             + (float)((float)(y - (float)((float)((float)(pResult.y + v36.y) + v37.y) * 0.33333))
                                     * (float)(y - (float)((float)((float)(pResult.y + v36.y) + v37.y) * 0.33333))))
                     + (float)((float)(z - (float)((float)((float)(pResult.z + v36.z) + v37.z) * 0.33333))
                             * (float)(z - (float)((float)((float)(pResult.z + v36.z) + v37.z) * 0.33333)))) < 10000.0
            || (float)((float)((float)(v20 * v20) + (float)(v21 * v21)) + (float)(v17 * v17)) < 10000.0
            || (float)((float)((float)(v22 * v22) + (float)(v23 * v23)) + (float)(v24 * v24)) < 10000.0 )
          {
            v25 = SurfaceInfos_c::CreatesPlants(&g_surfaceInfos, v34->m_nSurfaceType);
            createsObjects = SurfaceInfos_c::CreatesObjects(&g_surfaceInfos, v34->m_nSurfaceType);
            if ( createsObjects | v25 )
            {
              v27 = CPlantMgr::m_UnusedLocTriListHead;
              if ( CPlantLocTri::Add(
                     CPlantMgr::m_UnusedLocTriListHead,
                     &pResult,
                     &v36,
                     &v37,
                     v34->m_nSurfaceType,
                     v34->m_nLighting,
                     v25,
                     createsObjects) )
              {
                v32->m_LocTriArray[v10] = v27;
                if ( (*((_BYTE *)v27 + 72) & 2) != 0 )
                {
                  v28 = ProcObjectMan_c::ProcessTriangleAdded(&g_procObjMan, v27);
                  v29 = *((unsigned __int8 *)v27 + 72);
                  if ( v28 )
                  {
                    *((_BYTE *)v27 + 72) = v29 | 4;
                  }
                  else if ( !(v29 << 31) )
                  {
                    CPlantLocTri::Release(v27);
                    v32->m_LocTriArray[v10] = 0;
                  }
                }
              }
            }
          }
          v5 = v32;
          v8 = colEndIndex;
        }
        v9 += 16;
        ++v10;
        ++colStartIndex;
      }
      while ( v12 < v8 );
    }
  }
}

//----- (002CEB00) --------------------------------------------------------
void __fastcall CPlantLocTri::Release(CPlantLocTri *this)
{
  char v2; // r0
  CPlantLocTri *m_pPrevTri; // r0
  CPlantLocTri *m_pNextTri; // r1
  CPlantLocTri *v5; // r1
  CPlantSurfProp *SurfProperties; // r0
  CPlantLocTri *v7; // r1
  CPlantLocTri *v8; // r2
  CPlantLocTri *v9; // r0
  CPlantLocTri *v10; // r0
  uint8 v11; // r0
  CPlantLocTri *v12; // r0

  v2 = *((_BYTE *)this + 72);
  this->m_nMaxNumPlants[2] = 0;
  *(_DWORD *)this->m_nMaxNumPlants = 0;
  if ( (v2 & 4) != 0 )
  {
    ProcObjectMan_c::ProcessTriangleRemoved(&g_procObjMan, this);
    v2 = *((_BYTE *)this + 72);
  }
  if ( (v2 & 3) == 2 )
  {
    m_pPrevTri = this->m_pPrevTri;
    m_pNextTri = this->m_pNextTri;
    if ( m_pPrevTri )
    {
      if ( m_pNextTri )
      {
        m_pNextTri->m_pPrevTri = m_pPrevTri;
        m_pPrevTri = this->m_pPrevTri;
        v5 = this->m_pNextTri;
      }
      else
      {
        v5 = 0;
      }
      m_pPrevTri->m_pNextTri = v5;
    }
    else
    {
      CPlantMgr::m_CloseLocTriListHead[3] = this->m_pNextTri;
      if ( m_pNextTri )
        m_pNextTri->m_pPrevTri = 0;
    }
    v10 = CPlantMgr::m_UnusedLocTriListHead;
    this->m_pNextTri = CPlantMgr::m_UnusedLocTriListHead;
    this->m_pPrevTri = 0;
    CPlantMgr::m_UnusedLocTriListHead = this;
    if ( v10 )
      v10->m_pPrevTri = this;
    v11 = -2;
  }
  else
  {
    SurfProperties = CPlantSurfPropMgr::GetSurfProperties(this->m_nSurfaceType);
    v8 = this->m_pPrevTri;
    v7 = this->m_pNextTri;
    if ( v8 )
    {
      if ( v7 )
      {
        v7->m_pPrevTri = v8;
        v8 = this->m_pPrevTri;
        v9 = this->m_pNextTri;
      }
      else
      {
        v9 = 0;
      }
      v8->m_pNextTri = v9;
    }
    else
    {
      CPlantMgr::m_CloseLocTriListHead[SurfProperties->m_nPlantSlotID] = v7;
      if ( v7 )
        v7->m_pPrevTri = 0;
    }
    v12 = CPlantMgr::m_UnusedLocTriListHead;
    this->m_pNextTri = CPlantMgr::m_UnusedLocTriListHead;
    this->m_pPrevTri = 0;
    CPlantMgr::m_UnusedLocTriListHead = this;
    if ( v12 )
      v12->m_pPrevTri = this;
    v11 = -1;
  }
  this->m_nSurfaceType = v11;
  *((_BYTE *)this + 72) &= 0xF8u;
}

//----- (002CEBE0) --------------------------------------------------------
CPlantLocTri *__fastcall CPlantLocTri::Add(
        CPlantLocTri *this,
        const RwV3d_0 *v1,
        const RwV3d_0 *v2,
        const RwV3d_0 *v3,
        __int16 nSurfaceType,
        uint8 nLighting,
        bool8 createsPlants,
        bool8 createsObjects)
{
  __int64 v8; // d16
  CPlantLocTri *v9; // r4
  __int64 v10; // d16
  char v11; // lr
  __int64 v12; // d16
  int v13; // r5
  RwReal v14; // s0
  RwReal v15; // s2
  RwReal v16; // s4
  CPlantLocTri *m_pPrevTri; // r0
  __int64 v18; // kr00_8
  CPlantLocTri *m_pNextTri; // r1
  float *SurfProperties; // r5
  float y; // s2
  RwReal v22; // s6
  float z; // s4
  RwReal v24; // s8
  RwReal v25; // s10
  RwReal v26; // s0
  RwReal v27; // s2
  float v28; // s6
  float v29; // s0
  unsigned int v30; // r8
  unsigned int v31; // r9
  unsigned int v32; // r6
  int v33; // r0
  CPlantLocTri *v34; // r1
  CPlantLocTri *v35; // r2
  int v36; // r0
  CPlantLocTri *v37; // r2
  CPlantLocTri *v38; // r0
  CPlantLocTri *v39; // r1
  CPlantLocTri *v40; // r1
  CPlantLocTri *v41; // r0
  CVector v43; // [sp+4h] [bp-4Ch] BYREF
  CVector v44; // [sp+10h] [bp-40h] BYREF
  CVector v45; // [sp+1Ch] [bp-34h] BYREF

  v8 = *(_QWORD *)&v1->x;
  v9 = this;
  this->m_V1.z = v1->z;
  *(_QWORD *)&this->m_V1.x = v8;
  v10 = *(_QWORD *)&v2->x;
  this->m_V2.z = v2->z;
  *(_QWORD *)&this->m_V2.x = v10;
  v11 = *((_BYTE *)this + 72);
  v12 = *(_QWORD *)&v3->x;
  this->m_V3.z = v3->z;
  v13 = createsPlants & 1 | (2 * (createsObjects & 1));
  *((_BYTE *)this + 72) = v11 & 0xF8 | v13;
  this->m_nSurfaceType = nSurfaceType;
  this->m_nLighting = nLighting;
  *(_QWORD *)&this->m_V3.x = v12;
  v14 = (float)((float)(v1->x + v2->x) + v3->x) * 0.33333;
  v15 = (float)((float)(v1->y + v2->y) + v3->y) * 0.33333;
  v16 = (float)((float)(v1->z + v2->z) + v3->z) * 0.33333;
  this->m_Center.z = v16;
  this->m_Center.y = v15;
  this->m_Center.x = v14;
  this->m_SphereRadius = sqrtf(
                           (float)((float)((float)(v14 - this->m_V1.x) * (float)(v14 - this->m_V1.x))
                                 + (float)((float)(v15 - this->m_V1.y) * (float)(v15 - this->m_V1.y)))
                         + (float)((float)(v16 - this->m_V1.z) * (float)(v16 - this->m_V1.z)))
                       * 1.75;
  if ( v13 == 2 )
  {
    v18 = *(_QWORD *)&this->m_pNextTri;
    m_pPrevTri = this->m_pPrevTri;
    if ( m_pPrevTri )
    {
      if ( (_DWORD)v18 )
      {
        *(_DWORD *)(v18 + 80) = m_pPrevTri;
        m_pPrevTri = v9->m_pPrevTri;
        m_pNextTri = v9->m_pNextTri;
      }
      else
      {
        m_pNextTri = 0;
      }
      m_pPrevTri->m_pNextTri = m_pNextTri;
    }
    else
    {
      CPlantMgr::m_UnusedLocTriListHead = (CPlantLocTri *)v18;
      if ( (_DWORD)v18 )
        *(_DWORD *)(v18 + 80) = 0;
    }
  }
  else
  {
    SurfProperties = (float *)CPlantSurfPropMgr::GetSurfProperties(nSurfaceType);
    if ( !SurfProperties )
      return 0;
    y = v9->m_V1.y;
    v22 = v9->m_V2.x - v9->m_V1.x;
    z = v9->m_V1.z;
    v24 = v9->m_V2.y - y;
    v25 = v9->m_V2.z - z;
    v26 = v9->m_V3.x - v9->m_V1.x;
    v27 = v9->m_V3.y - y;
    v45.y = v24;
    v45.x = v22;
    v45.z = v25;
    v28 = v9->m_V3.z;
    v44.y = v27;
    v44.x = v26;
    v44.z = v28 - z;
    CrossProduct(&v43, &v45, &v44);
    v29 = sqrtf((float)((float)(v43.x * v43.x) + (float)(v43.y * v43.y)) + (float)(v43.z * v43.z)) * 0.5;
    v30 = (unsigned int)(float)(v29 * SurfProperties[8]);
    v31 = (unsigned int)(float)(v29 * SurfProperties[18]);
    v32 = (unsigned int)(float)(v29 * SurfProperties[28]);
    if ( v31 + v30 + v32 )
    {
      v9->m_Seed[0] = (float)((float)rand() * 4.6566e-10) + 0.0;
      v9->m_Seed[1] = (float)((float)rand() * 4.6566e-10) + 0.0;
      v33 = rand();
      v34 = v9->m_pPrevTri;
      v35 = v9->m_pNextTri;
      v9->m_nMaxNumPlants[2] = v32;
      v9->m_nMaxNumPlants[1] = v31;
      v9->m_nMaxNumPlants[0] = v30;
      v9->m_Seed[2] = (float)((float)v33 * 4.6566e-10) + 0.0;
      v36 = *(unsigned __int16 *)SurfProperties;
      if ( v34 )
      {
        if ( v35 )
        {
          v35->m_pPrevTri = v34;
          v34 = v9->m_pPrevTri;
          v37 = v9->m_pNextTri;
        }
        else
        {
          v37 = 0;
        }
        v34->m_pNextTri = v37;
      }
      else
      {
        CPlantMgr::m_UnusedLocTriListHead = v35;
        if ( v35 )
          v35->m_pPrevTri = 0;
      }
      v9->m_pNextTri = CPlantMgr::m_CloseLocTriListHead[v36];
      v9->m_pPrevTri = 0;
      CPlantMgr::m_CloseLocTriListHead[v36] = v9;
      v41 = v9->m_pNextTri;
      goto LABEL_30;
    }
    if ( (*((_BYTE *)v9 + 72) & 2) == 0 )
      return 0;
    v38 = v9->m_pPrevTri;
    v39 = v9->m_pNextTri;
    *((_BYTE *)v9 + 72) &= ~1u;
    if ( v38 )
    {
      if ( v39 )
      {
        v39->m_pPrevTri = v38;
        v38 = v9->m_pPrevTri;
        v40 = v9->m_pNextTri;
      }
      else
      {
        v40 = 0;
      }
      v38->m_pNextTri = v40;
    }
    else
    {
      CPlantMgr::m_UnusedLocTriListHead = v39;
      if ( v39 )
        v39->m_pPrevTri = 0;
    }
  }
  v41 = CPlantMgr::m_CloseLocTriListHead[3];
  v9->m_pNextTri = CPlantMgr::m_CloseLocTriListHead[3];
  v9->m_pPrevTri = 0;
  CPlantMgr::m_CloseLocTriListHead[3] = v9;
LABEL_30:
  if ( v41 )
    v41->m_pPrevTri = v9;
  return v9;
}

//----- (002CEEFC) --------------------------------------------------------
int CPlantMgr::DbgRenderLocTris()
{
  return 1;
}

//----- (002CEF00) --------------------------------------------------------
bool8 __fastcall CPlantMgr::DbgRenderCachedEntities(uint32 *pCountAll)
{
  return 1;
}

//----- (002CEF04) --------------------------------------------------------
bool8 __fastcall CPlantMgr::DbgCountLocTrisAndPlants(uint32 groupID, uint32 *pCountLocTris, uint32 *pCountPlants)
{
  return 1;
}

//----- (002CEF08) --------------------------------------------------------
bool8 __fastcall CPlantMgr::DbgCountCachedEntities(uint32 *pCountAll)
{
  return 1;
}

//----- (002CEF0C) --------------------------------------------------------
CPlantLocTri *__fastcall CPlantMgr::MoveLocTriToList(
        CPlantLocTri **ppCurrentList,
        CPlantLocTri **ppNewList,
        CPlantLocTri *pTri)
{
  CPlantLocTri *m_pPrevTri; // r3
  CPlantLocTri *m_pNextTri; // r12
  CPlantLocTri *v5; // r0
  CPlantLocTri *v6; // r0

  m_pPrevTri = pTri->m_pPrevTri;
  m_pNextTri = pTri->m_pNextTri;
  if ( m_pPrevTri )
  {
    if ( m_pNextTri )
    {
      m_pNextTri->m_pPrevTri = m_pPrevTri;
      m_pPrevTri = pTri->m_pPrevTri;
      v5 = pTri->m_pNextTri;
    }
    else
    {
      v5 = 0;
    }
    m_pPrevTri->m_pNextTri = v5;
  }
  else
  {
    *ppCurrentList = m_pNextTri;
    if ( m_pNextTri )
      m_pNextTri->m_pPrevTri = 0;
  }
  pTri->m_pNextTri = *ppNewList;
  pTri->m_pPrevTri = 0;
  *ppNewList = pTri;
  v6 = pTri->m_pNextTri;
  if ( v6 )
    v6->m_pPrevTri = pTri;
  return pTri;
}

//----- (002CEF4C) --------------------------------------------------------
CPlantColEntEntry *__fastcall CPlantMgr::MoveColEntToList(
        CPlantColEntEntry **ppCurrentList,
        CPlantColEntEntry **ppNewList,
        CPlantColEntEntry *pEntry)
{
  CPlantColEntEntry *m_pPrevEntry; // r3
  CPlantColEntEntry *m_pNextEntry; // r12
  CPlantColEntEntry *v5; // r0
  CPlantColEntEntry *v6; // r0

  m_pPrevEntry = pEntry->m_pPrevEntry;
  m_pNextEntry = pEntry->m_pNextEntry;
  if ( m_pPrevEntry )
  {
    if ( m_pNextEntry )
    {
      m_pNextEntry->m_pPrevEntry = m_pPrevEntry;
      m_pPrevEntry = pEntry->m_pPrevEntry;
      v5 = pEntry->m_pNextEntry;
    }
    else
    {
      v5 = 0;
    }
    m_pPrevEntry->m_pNextEntry = v5;
  }
  else
  {
    *ppCurrentList = m_pNextEntry;
    if ( m_pNextEntry )
      m_pNextEntry->m_pPrevEntry = 0;
  }
  pEntry->m_pNextEntry = *ppNewList;
  pEntry->m_pPrevEntry = 0;
  *ppNewList = pEntry;
  v6 = pEntry->m_pNextEntry;
  if ( v6 )
    v6->m_pPrevEntry = pEntry;
  return pEntry;
}

//----- (002CEF8C) --------------------------------------------------------
bool8 __fastcall CPlantMgr::SetPlantFriendlyFlagInAtomicMI(CAtomicModelInfo *pModelInfo)
{
  CColModel *m_pColModel; // r2
  CCollisionData *m_pColData; // r4
  int m_nNoOfTriangles; // r9
  int v4; // r5
  int i; // r6
  CColTriangle *m_pTriangleArray; // r8

  m_pColModel = pModelInfo->m_pColModel;
  pModelInfo->m_flags &= ~0x200u;
  m_pColData = m_pColModel->m_pColData;
  if ( !m_pColData )
    return 0;
  m_nNoOfTriangles = m_pColData->m_nNoOfTriangles;
  if ( m_nNoOfTriangles < 1 )
    return 0;
  v4 = 0;
  for ( i = 12; ; i += 16 )
  {
    m_pTriangleArray = m_pColData->m_pTriangleArray;
    if ( SurfaceInfos_c::CreatesPlants(&g_surfaceInfos, *((unsigned __int8 *)&m_pTriangleArray->m_nIndex1 + i))
      || SurfaceInfos_c::CreatesObjects(&g_surfaceInfos, *((unsigned __int8 *)&m_pTriangleArray->m_nIndex1 + i)) )
    {
      break;
    }
    if ( ++v4 >= m_nNoOfTriangles )
      return 0;
  }
  pModelInfo->m_flags |= 0x200u;
  return 1;
}

//----- (002CF008) --------------------------------------------------------
int CPlantMgr::Initialise()
{
  int v0; // r5
  char *v1; // r12
  char *v2; // lr
  char *v3; // r6
  int v4; // r2
  CPlantColEntEntry *v5; // r3
  int v6; // r6
  CPlantColEntEntry *v7; // r5

  CPlantSurfPropMgr::Initialise();
  v0 = -21504;
  *(_QWORD *)CPlantMgr::m_CloseLocTriListHead = 0LL;
  *(_QWORD *)&CPlantMgr::m_CloseLocTriListHead[2] = 0LL;
  CPlantMgr::m_UnusedLocTriListHead = CPlantMgr::m_LocTrisTab;
  do
  {
    v1 = (char *)CPlantMgr::m_LocTrisTab + v0;
    v2 = (char *)&CPlantMgr::m_LocTrisTab[255] + v0;
    v1[21574] = 0;
    *((_WORD *)v1 + 10786) = 0;
    *((_DWORD *)v1 + 5392) = 0;
    if ( v0 == -21504 )
      v2 = 0;
    v3 = v1 + 21588;
    v0 += 84;
    *((_DWORD *)v1 + 5396) = v2;
    if ( !v0 )
      v3 = 0;
    *((_DWORD *)v1 + 5395) = v3;
    *((_QWORD *)v1 + 2692) = 0LL;
    *((_QWORD *)v1 + 2693) = 0LL;
    *((_QWORD *)v1 + 2690) = 0LL;
    *((_QWORD *)v1 + 2691) = 0LL;
    *((_QWORD *)v1 + 2688) = 0LL;
    *((_QWORD *)v1 + 2689) = 0LL;
  }
  while ( v0 );
  CPlantMgr::m_UnusedColEntListHead = CPlantMgr::m_ColEntCacheTab;
  CPlantMgr::m_CloseColEntListHead = 0;
  v4 = 0;
  do
  {
    v5 = &CPlantMgr::m_ColEntCacheTab[v4];
    v6 = v4 * 20;
    CPlantMgr::m_ColEntCacheTab[v4].m_pEntity = 0;
    v7 = &CPlantMgr::m_ColEntCacheTab[v4 + 1];
    v5->m_LocTriArray = 0;
    v5->m_nNumTris = 0;
    if ( v4 * 20 )
      v6 = (int)&v5[-1];
    if ( v4++ == 39 )
      v7 = 0;
    v5->m_pNextEntry = v7;
    v5->m_pPrevEntry = (CPlantColEntEntry *)v6;
  }
  while ( v4 != 40 );
  return 1;
}

//----- (002CF128) --------------------------------------------------------
int CPlantMgr::ReloadConfig()
{
  int v0; // r5
  char *v1; // r12
  char *v2; // lr
  char *v3; // r6
  int v4; // r2
  CPlantColEntEntry *v5; // r3
  int v6; // r6
  CPlantColEntEntry *v7; // r5

  CPlantSurfPropMgr::Initialise();
  v0 = -21504;
  *(_QWORD *)CPlantMgr::m_CloseLocTriListHead = 0LL;
  *(_QWORD *)&CPlantMgr::m_CloseLocTriListHead[2] = 0LL;
  CPlantMgr::m_UnusedLocTriListHead = CPlantMgr::m_LocTrisTab;
  do
  {
    v1 = (char *)CPlantMgr::m_LocTrisTab + v0;
    v2 = (char *)&CPlantMgr::m_LocTrisTab[255] + v0;
    v1[21574] = 0;
    *((_WORD *)v1 + 10786) = 0;
    *((_DWORD *)v1 + 5392) = 0;
    if ( v0 == -21504 )
      v2 = 0;
    v3 = v1 + 21588;
    v0 += 84;
    *((_DWORD *)v1 + 5396) = v2;
    if ( !v0 )
      v3 = 0;
    *((_DWORD *)v1 + 5395) = v3;
    *((_QWORD *)v1 + 2692) = 0LL;
    *((_QWORD *)v1 + 2693) = 0LL;
    *((_QWORD *)v1 + 2690) = 0LL;
    *((_QWORD *)v1 + 2691) = 0LL;
    *((_QWORD *)v1 + 2688) = 0LL;
    *((_QWORD *)v1 + 2689) = 0LL;
  }
  while ( v0 );
  CPlantMgr::m_UnusedColEntListHead = CPlantMgr::m_ColEntCacheTab;
  CPlantMgr::m_CloseColEntListHead = 0;
  v4 = 0;
  do
  {
    v5 = &CPlantMgr::m_ColEntCacheTab[v4];
    v6 = v4 * 20;
    CPlantMgr::m_ColEntCacheTab[v4].m_pEntity = 0;
    v7 = &CPlantMgr::m_ColEntCacheTab[v4 + 1];
    v5->m_LocTriArray = 0;
    v5->m_nNumTris = 0;
    if ( v4 * 20 )
      v6 = (int)&v5[-1];
    if ( v4++ == 39 )
      v7 = 0;
    v5->m_pNextEntry = v7;
    v5->m_pPrevEntry = (CPlantColEntEntry *)v6;
  }
  while ( v4 != 40 );
  return 1;
}

//----- (002CF248) --------------------------------------------------------
int CPlantSurfPropMgr::Initialise()
{
  int v0; // r5
  float *p_m_fScaleVarXY; // r6
  CRGBA *v2; // r0
  float *v3; // r1
  CRGBA *v4; // r0
  float *v5; // r1
  CRGBA *v6; // r0
  CRGBA v8; // [sp+4h] [bp-2Ch] BYREF

  CPlantSurfPropMgr::m_countSurfPropsAllocated = 0;
  memset(CPlantSurfPropMgr::m_SurfPropPtrTab, 0, sizeof(CPlantSurfPropMgr::m_SurfPropPtrTab));
  v0 = 57;
  p_m_fScaleVarXY = &CPlantSurfPropMgr::m_SurfPropTab[0].m_PlantData[2].m_fScaleVarXY;
  v2 = &v8;
  do
  {
    *((_WORD *)p_m_fScaleVarXY - 50) = -1;
    *((_WORD *)p_m_fScaleVarXY - 52) = 0;
    *((_WORD *)p_m_fScaleVarXY - 49) = 0;
    CRGBA::CRGBA(v2, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
    *((CRGBA *)p_m_fScaleVarXY - 24) = v8;
    v3 = p_m_fScaleVarXY - 20;
    *(_QWORD *)v3 = 0LL;
    *((_QWORD *)v3 + 1) = 0LL;
    *((_WORD *)p_m_fScaleVarXY - 46) = 255;
    *(p_m_fScaleVarXY - 22) = 1.0;
    *(p_m_fScaleVarXY - 21) = 1.0;
    *(p_m_fScaleVarXY - 16) = 0.0;
    *((_WORD *)p_m_fScaleVarXY - 30) = -1;
    *((_WORD *)p_m_fScaleVarXY - 29) = 0;
    CRGBA::CRGBA(v4, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
    *((CRGBA *)p_m_fScaleVarXY - 14) = v8;
    v5 = p_m_fScaleVarXY - 10;
    *(_QWORD *)v5 = 0LL;
    *((_QWORD *)v5 + 1) = 0LL;
    *((_WORD *)p_m_fScaleVarXY - 26) = 255;
    *(p_m_fScaleVarXY - 12) = 1.0;
    *(p_m_fScaleVarXY - 11) = 1.0;
    *(p_m_fScaleVarXY - 6) = 0.0;
    *((_WORD *)p_m_fScaleVarXY - 10) = -1;
    *((_WORD *)p_m_fScaleVarXY - 9) = 0;
    CRGBA::CRGBA(v6, 0xFFu, 0xFFu, 0xFFu, 0xFFu);
    --v0;
    *((CRGBA *)p_m_fScaleVarXY - 4) = v8;
    *((_WORD *)p_m_fScaleVarXY - 6) = 255;
    *(p_m_fScaleVarXY - 2) = 1.0;
    *(p_m_fScaleVarXY - 1) = 1.0;
    *(_QWORD *)p_m_fScaleVarXY = 0LL;
    *((_QWORD *)p_m_fScaleVarXY + 1) = 0LL;
    p_m_fScaleVarXY[4] = 0.0;
    p_m_fScaleVarXY += 31;
  }
  while ( v0 );
  return 1;
}
// 2CF2A6: variable 'v2' is possibly undefined
// 2CF2D6: variable 'v4' is possibly undefined
// 2CF306: variable 'v6' is possibly undefined

//----- (002CF344) --------------------------------------------------------
CPlantSurfProp *__fastcall CPlantSurfPropMgr::AllocSurfProperties(uint16 nSurfaceType, bool8 restartAlloc)
{
  uint32 v3; // r1
  CPlantSurfProp *v4; // r1

  if ( restartAlloc )
  {
    CPlantSurfPropMgr::m_countSurfPropsAllocated = 0;
    return 0;
  }
  else
  {
    v3 = CPlantSurfPropMgr::m_countSurfPropsAllocated;
    if ( CPlantSurfPropMgr::m_countSurfPropsAllocated <= 0x38 )
    {
      ++CPlantSurfPropMgr::m_countSurfPropsAllocated;
      v4 = &CPlantSurfPropMgr::m_SurfPropTab[v3];
      CPlantSurfPropMgr::m_SurfPropPtrTab[nSurfaceType] = v4;
      return v4;
    }
    else
    {
      return 0;
    }
  }
}

//----- (002CF3B0) --------------------------------------------------------
bool8 __fastcall CPlantSurfPropMgr::LoadPlantsDat(const unsigned __int8 *pFilename)
{
  return 1;
}

//----- (002CF3B4) --------------------------------------------------------
int CGrassRenderer::Initialise()
{
  return 1;
}

//----- (002CF3B8) --------------------------------------------------------
void __fastcall CMBlur::CMBlur(CMBlur *this)
{
  CMBlur::pFrontBuffer = 0;
}

//----- (002CF3CA) --------------------------------------------------------
RwBool CMBlur::MotionBlurClose()
{
  return 1;
}

//----- (002CF3D8) --------------------------------------------------------
RwBool __fastcall CMBlur::MotionBlurOpen(RwCamera_0 *camera)
{
  return 1;
}

//----- (002CF3DC) --------------------------------------------------------
void __fastcall CMBlur::SetDrunkBlur(float value)
{
  float32x2_t v1; // d0
  float32x2_t v2; // d1
  float32x2_t v3; // d2

  v1.n64_u32[0] = 1.0;
  v2.n64_f32[0] = value;
  v3.n64_u32[0] = 0;
  LODWORD(CMBlur::Drunkness) = vmax_f32(vmin_f32(v2, v1), v3).n64_u32[0];
}
// 2CF3EE: variable 'v2' is possibly undefined
// 2CF3EE: variable 'v1' is possibly undefined
// 2CF3F2: variable 'v3' is possibly undefined

//----- (002CF404) --------------------------------------------------------
void CMBlur::ClearDrunkBlur()
{
  CMBlur::Drunkness = 0.0;
  CTimer::ms_fTimeScale = 1.0;
}

//----- (002CF424) --------------------------------------------------------
void __fastcall CStreamingInfo::Init(CStreamingInfo *this)
{
  this->m_status = 0;
  *(_DWORD *)&this->m_nextIndex = -1;
  this->m_nextModelOnCd = -1;
  this->m_image = 0;
  this->m_cdPosn = 0;
  this->m_cdSize = 0;
}

//----- (002CF43C) --------------------------------------------------------
void __fastcall CStreamingInfo::AddToList(CStreamingInfo *this, CStreamingInfo *pListHead)
{
  unsigned int v2; // r3
  int16 v3; // r4

  v2 = (unsigned int)((char *)this - (char *)CStreamingInfo::ms_pArrayBase) >> 2;
  v3 = -13107 * ((unsigned int)((char *)pListHead - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
  this->m_nextIndex = pListHead->m_nextIndex;
  LOWORD(v2) = -13107 * v2;
  this->m_prevIndex = v3;
  pListHead->m_nextIndex = v2;
  CStreamingInfo::ms_pArrayBase[this->m_nextIndex].m_prevIndex = v2;
}

//----- (002CF484) --------------------------------------------------------
void __fastcall CStreamingInfo::RemoveFromList(CStreamingInfo *this)
{
  CStreamingInfo::ms_pArrayBase[this->m_nextIndex].m_prevIndex = this->m_prevIndex;
  CStreamingInfo::ms_pArrayBase[this->m_prevIndex].m_nextIndex = this->m_nextIndex;
  *(_DWORD *)&this->m_nextIndex = -1;
}

//----- (002CF4C0) --------------------------------------------------------
CStreamingInfo *__fastcall CStreamingInfo::GetNext(CStreamingInfo *this)
{
  int m_nextIndex; // r0

  m_nextIndex = this->m_nextIndex;
  if ( m_nextIndex == -1 )
    return 0;
  else
    return &CStreamingInfo::ms_pArrayBase[m_nextIndex];
}

//----- (002CF4E4) --------------------------------------------------------
CStreamingInfo *__fastcall CStreamingInfo::GetPrev(CStreamingInfo *this)
{
  int m_prevIndex; // r0

  m_prevIndex = this->m_prevIndex;
  if ( m_prevIndex == -1 )
    return 0;
  else
    return &CStreamingInfo::ms_pArrayBase[m_prevIndex];
}

//----- (002CF508) --------------------------------------------------------
void __fastcall CStreamingInfo::SetNext(CStreamingInfo *this, CStreamingInfo *info)
{
  if ( info )
    this->m_nextIndex = -13107 * (((char *)info - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
  else
    this->m_nextIndex = -1;
}

//----- (002CF534) --------------------------------------------------------
void __fastcall CStreamingInfo::SetPrev(CStreamingInfo *this, CStreamingInfo *info)
{
  if ( info )
    this->m_prevIndex = -13107 * (((char *)info - (char *)CStreamingInfo::ms_pArrayBase) >> 2);
  else
    this->m_prevIndex = -1;
}

//----- (002CF560) --------------------------------------------------------
bool __fastcall CStreamingInfo::InList(CStreamingInfo *this)
{
  return (unsigned __int16)this->m_nextIndex != 0xFFFF;
}

//----- (002CF570) --------------------------------------------------------
uint32 __fastcall CStreamingInfo::GetCdPosn(CStreamingInfo *this)
{
  return this->m_cdPosn + CStreaming::ms_files[this->m_image].m_lsn;
}

//----- (002CF58C) --------------------------------------------------------
uint32 __fastcall CStreamingInfo::GetCdSize(CStreamingInfo *this)
{
  return this->m_cdSize;
}

//----- (002CF590) --------------------------------------------------------
bool __fastcall CStreamingInfo::GetCdPosnAndSize(CStreamingInfo *this, uint32 *posn, uint32 *size)
{
  if ( !this->m_cdSize )
    return 0;
  *posn = CStreaming::ms_files[this->m_image].m_lsn + this->m_cdPosn;
  *size = this->m_cdSize;
  return 1;
}

//----- (002CF5C8) --------------------------------------------------------
void __fastcall CStreamingInfo::SetCdPosnAndSize(CStreamingInfo *this, uint32 posn, uint32 size)
{
  this->m_cdPosn = posn;
  this->m_cdSize = size;
}

//----- (002CF5D0) --------------------------------------------------------
const unsigned __int8 *__fastcall CStreaming::GetModelCDName(int32 index)
{
  int32 v1; // r0

  v1 = index;
  if ( !CStreaming::ms_aInfoForModel[v1].m_cdSize )
    return (const unsigned __int8 *)&off_2CF654;
  strcpy(
    (char *)CStreaming::GetModelCDName(int)::name,
    (const char *)gCdImageNames
  + (((CStreaming::ms_aInfoForModel[v1].m_cdPosn + CStreaming::ms_files[CStreaming::ms_aInfoForModel[v1].m_image].m_lsn) >> 18) & 0x3FC0));
  CStreaming::GetModelCDName(int)::name[strlen((const char *)CStreaming::GetModelCDName(int)::name) - 4] = 0;
  (*((void (__fastcall **)(unsigned __int8 *))RwEngineInstance + 72))(CStreaming::GetModelCDName(int)::name);
  return (const unsigned __int8 *)(strchr((const char *)CStreaming::GetModelCDName(int)::name, 92) + 1);
}
// 2CF654: using guessed type void *off_2CF654;

//----- (002CF66C) --------------------------------------------------------
int32 CStreaming::IsInitialised()
{
  int32 result; // r0

  result = CStreaming::ms_bIsInitialised;
  if ( CStreaming::ms_bIsInitialised )
    return 1;
  return result;
}

//----- (002CF680) --------------------------------------------------------
void CStreaming::InitImageList()
{
  int v0; // r6
  CStreamingFile *v1; // r5
  int v2; // r0
  CStreamingFile *v3; // r1

  v0 = 0;
  v1 = CStreaming::ms_files;
  CStreaming::ms_files[1].m_name[0] = 0;
  CStreaming::ms_files[0].m_lsn = 0;
  CStreaming::ms_files[1].m_lsn = 0;
  CStreaming::ms_files[2].m_lsn = 0;
  CStreaming::ms_files[2].m_name[0] = 0;
  CStreaming::ms_files[3].m_lsn = 0;
  CStreaming::ms_files[3].m_name[0] = 0;
  CStreaming::ms_files[4].m_lsn = 0;
  CStreaming::ms_files[4].m_name[0] = 0;
  CStreaming::ms_files[5].m_lsn = 0;
  CStreaming::ms_files[5].m_name[0] = 0;
  CStreaming::ms_files[6].m_lsn = 0;
  CStreaming::ms_files[6].m_name[0] = 0;
  CStreaming::ms_files[7].m_lsn = 0;
  CStreaming::ms_files[7].m_name[0] = 0;
  strcpy((char *)CStreaming::ms_files, "TEXDB\\GTA3.IMG");
  CStreaming::ms_files[0].m_lsn = CdStreamOpen("TEXDB\\GTA3.IMG", 0);
  CStreaming::ms_files[0].m_bRegister = 1;
  gGta3ImageIndex = 0;
  if ( CStreaming::ms_files[0].m_name[0] )
  {
    v1 = &CStreaming::ms_files[1];
    if ( CStreaming::ms_files[1].m_name[0] )
    {
      v1 = &CStreaming::ms_files[2];
      if ( CStreaming::ms_files[2].m_name[0] )
      {
        v1 = &CStreaming::ms_files[3];
        if ( CStreaming::ms_files[3].m_name[0] )
        {
          v1 = &CStreaming::ms_files[4];
          if ( CStreaming::ms_files[4].m_name[0] )
          {
            v1 = &CStreaming::ms_files[5];
            if ( CStreaming::ms_files[5].m_name[0] )
            {
              if ( CStreaming::ms_files[6].m_name[0] )
              {
                if ( CStreaming::ms_files[7].m_name[0] )
                  return;
                v1 = &CStreaming::ms_files[7];
                v0 = 7;
              }
              else
              {
                v1 = &CStreaming::ms_files[6];
                v0 = 6;
              }
            }
            else
            {
              v0 = 5;
            }
          }
          else
          {
            v0 = 4;
          }
        }
        else
        {
          v0 = 3;
        }
      }
      else
      {
        v0 = 2;
      }
    }
    else
    {
      v0 = 1;
    }
  }
  strcpy((char *)v1, "TEXDB\\GTA_INT.IMG");
  v2 = CdStreamOpen("TEXDB\\GTA_INT.IMG", 0);
  v3 = &CStreaming::ms_files[v0];
  v3->m_lsn = v2;
  v3->m_bRegister = 1;
}

//----- (002CF7D0) --------------------------------------------------------
int32 __fastcall CStreaming::AddImageToList(const unsigned __int8 *pImageName, bool bRegisterFiles)
{
  CStreamingFile *v4; // r0
  int32 v5; // r6
  int v6; // r0
  CStreamingFile *v7; // r1

  v4 = CStreaming::ms_files;
  if ( !CStreaming::ms_files[0].m_name[0] )
  {
    v5 = 0;
LABEL_18:
    strcpy((char *)v4, (const char *)pImageName);
    v6 = CdStreamOpen(pImageName, 0);
    v7 = &CStreaming::ms_files[v5];
    v7->m_lsn = v6;
    v7->m_bRegister = bRegisterFiles;
    return v5;
  }
  v4 = &CStreaming::ms_files[1];
  if ( !CStreaming::ms_files[1].m_name[0] )
  {
    v5 = 1;
    goto LABEL_18;
  }
  v4 = &CStreaming::ms_files[2];
  if ( !CStreaming::ms_files[2].m_name[0] )
  {
    v5 = 2;
    goto LABEL_18;
  }
  v4 = &CStreaming::ms_files[3];
  if ( !CStreaming::ms_files[3].m_name[0] )
  {
    v5 = 3;
    goto LABEL_18;
  }
  v4 = &CStreaming::ms_files[4];
  if ( !CStreaming::ms_files[4].m_name[0] )
  {
    v5 = 4;
    goto LABEL_18;
  }
  v4 = &CStreaming::ms_files[5];
  if ( !CStreaming::ms_files[5].m_name[0] )
  {
    v5 = 5;
    goto LABEL_18;
  }
  if ( !CStreaming::ms_files[6].m_name[0] )
  {
    v4 = &CStreaming::ms_files[6];
    v5 = 6;
    goto LABEL_18;
  }
  if ( !CStreaming::ms_files[7].m_name[0] )
  {
    v4 = &CStreaming::ms_files[7];
    v5 = 7;
    goto LABEL_18;
  }
  return 0;
}

//----- (002C